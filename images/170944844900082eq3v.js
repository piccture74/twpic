/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/moment/moment.js
var require_moment = __commonJS({
  "node_modules/moment/moment.js"(exports, module2) {
    (function(global, factory) {
      typeof exports === "object" && typeof module2 !== "undefined" ? module2.exports = factory() : typeof define === "function" && define.amd ? define(factory) : global.moment = factory();
    })(exports, function() {
      "use strict";
      var hookCallback;
      function hooks() {
        return hookCallback.apply(null, arguments);
      }
      function setHookCallback(callback) {
        hookCallback = callback;
      }
      function isArray(input) {
        return input instanceof Array || Object.prototype.toString.call(input) === "[object Array]";
      }
      function isObject(input) {
        return input != null && Object.prototype.toString.call(input) === "[object Object]";
      }
      function hasOwnProp(a, b) {
        return Object.prototype.hasOwnProperty.call(a, b);
      }
      function isObjectEmpty(obj) {
        if (Object.getOwnPropertyNames) {
          return Object.getOwnPropertyNames(obj).length === 0;
        } else {
          var k;
          for (k in obj) {
            if (hasOwnProp(obj, k)) {
              return false;
            }
          }
          return true;
        }
      }
      function isUndefined(input) {
        return input === void 0;
      }
      function isNumber(input) {
        return typeof input === "number" || Object.prototype.toString.call(input) === "[object Number]";
      }
      function isDate(input) {
        return input instanceof Date || Object.prototype.toString.call(input) === "[object Date]";
      }
      function map2(arr, fn) {
        var res = [], i;
        for (i = 0; i < arr.length; ++i) {
          res.push(fn(arr[i], i));
        }
        return res;
      }
      function extend(a, b) {
        for (var i in b) {
          if (hasOwnProp(b, i)) {
            a[i] = b[i];
          }
        }
        if (hasOwnProp(b, "toString")) {
          a.toString = b.toString;
        }
        if (hasOwnProp(b, "valueOf")) {
          a.valueOf = b.valueOf;
        }
        return a;
      }
      function createUTC(input, format2, locale2, strict) {
        return createLocalOrUTC(input, format2, locale2, strict, true).utc();
      }
      function defaultParsingFlags() {
        return {
          empty: false,
          unusedTokens: [],
          unusedInput: [],
          overflow: -2,
          charsLeftOver: 0,
          nullInput: false,
          invalidEra: null,
          invalidMonth: null,
          invalidFormat: false,
          userInvalidated: false,
          iso: false,
          parsedDateParts: [],
          era: null,
          meridiem: null,
          rfc2822: false,
          weekdayMismatch: false
        };
      }
      function getParsingFlags(m) {
        if (m._pf == null) {
          m._pf = defaultParsingFlags();
        }
        return m._pf;
      }
      var some;
      if (Array.prototype.some) {
        some = Array.prototype.some;
      } else {
        some = function(fun) {
          var t = Object(this), len = t.length >>> 0, i;
          for (i = 0; i < len; i++) {
            if (i in t && fun.call(this, t[i], i, t)) {
              return true;
            }
          }
          return false;
        };
      }
      function isValid(m) {
        if (m._isValid == null) {
          var flags = getParsingFlags(m), parsedParts = some.call(flags.parsedDateParts, function(i) {
            return i != null;
          }), isNowValid = !isNaN(m._d.getTime()) && flags.overflow < 0 && !flags.empty && !flags.invalidEra && !flags.invalidMonth && !flags.invalidWeekday && !flags.weekdayMismatch && !flags.nullInput && !flags.invalidFormat && !flags.userInvalidated && (!flags.meridiem || flags.meridiem && parsedParts);
          if (m._strict) {
            isNowValid = isNowValid && flags.charsLeftOver === 0 && flags.unusedTokens.length === 0 && flags.bigHour === void 0;
          }
          if (Object.isFrozen == null || !Object.isFrozen(m)) {
            m._isValid = isNowValid;
          } else {
            return isNowValid;
          }
        }
        return m._isValid;
      }
      function createInvalid(flags) {
        var m = createUTC(NaN);
        if (flags != null) {
          extend(getParsingFlags(m), flags);
        } else {
          getParsingFlags(m).userInvalidated = true;
        }
        return m;
      }
      var momentProperties = hooks.momentProperties = [], updateInProgress = false;
      function copyConfig(to2, from2) {
        var i, prop, val;
        if (!isUndefined(from2._isAMomentObject)) {
          to2._isAMomentObject = from2._isAMomentObject;
        }
        if (!isUndefined(from2._i)) {
          to2._i = from2._i;
        }
        if (!isUndefined(from2._f)) {
          to2._f = from2._f;
        }
        if (!isUndefined(from2._l)) {
          to2._l = from2._l;
        }
        if (!isUndefined(from2._strict)) {
          to2._strict = from2._strict;
        }
        if (!isUndefined(from2._tzm)) {
          to2._tzm = from2._tzm;
        }
        if (!isUndefined(from2._isUTC)) {
          to2._isUTC = from2._isUTC;
        }
        if (!isUndefined(from2._offset)) {
          to2._offset = from2._offset;
        }
        if (!isUndefined(from2._pf)) {
          to2._pf = getParsingFlags(from2);
        }
        if (!isUndefined(from2._locale)) {
          to2._locale = from2._locale;
        }
        if (momentProperties.length > 0) {
          for (i = 0; i < momentProperties.length; i++) {
            prop = momentProperties[i];
            val = from2[prop];
            if (!isUndefined(val)) {
              to2[prop] = val;
            }
          }
        }
        return to2;
      }
      function Moment(config) {
        copyConfig(this, config);
        this._d = new Date(config._d != null ? config._d.getTime() : NaN);
        if (!this.isValid()) {
          this._d = new Date(NaN);
        }
        if (updateInProgress === false) {
          updateInProgress = true;
          hooks.updateOffset(this);
          updateInProgress = false;
        }
      }
      function isMoment(obj) {
        return obj instanceof Moment || obj != null && obj._isAMomentObject != null;
      }
      function warn2(msg) {
        if (hooks.suppressDeprecationWarnings === false && typeof console !== "undefined" && console.warn) {
          console.warn("Deprecation warning: " + msg);
        }
      }
      function deprecate(msg, fn) {
        var firstTime = true;
        return extend(function() {
          if (hooks.deprecationHandler != null) {
            hooks.deprecationHandler(null, msg);
          }
          if (firstTime) {
            var args = [], arg, i, key;
            for (i = 0; i < arguments.length; i++) {
              arg = "";
              if (typeof arguments[i] === "object") {
                arg += "\n[" + i + "] ";
                for (key in arguments[0]) {
                  if (hasOwnProp(arguments[0], key)) {
                    arg += key + ": " + arguments[0][key] + ", ";
                  }
                }
                arg = arg.slice(0, -2);
              } else {
                arg = arguments[i];
              }
              args.push(arg);
            }
            warn2(
              msg + "\nArguments: " + Array.prototype.slice.call(args).join("") + "\n" + new Error().stack
            );
            firstTime = false;
          }
          return fn.apply(this, arguments);
        }, fn);
      }
      var deprecations = {};
      function deprecateSimple(name, msg) {
        if (hooks.deprecationHandler != null) {
          hooks.deprecationHandler(name, msg);
        }
        if (!deprecations[name]) {
          warn2(msg);
          deprecations[name] = true;
        }
      }
      hooks.suppressDeprecationWarnings = false;
      hooks.deprecationHandler = null;
      function isFunction(input) {
        return typeof Function !== "undefined" && input instanceof Function || Object.prototype.toString.call(input) === "[object Function]";
      }
      function set2(config) {
        var prop, i;
        for (i in config) {
          if (hasOwnProp(config, i)) {
            prop = config[i];
            if (isFunction(prop)) {
              this[i] = prop;
            } else {
              this["_" + i] = prop;
            }
          }
        }
        this._config = config;
        this._dayOfMonthOrdinalParseLenient = new RegExp(
          (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + "|" + /\d{1,2}/.source
        );
      }
      function mergeConfigs(parentConfig, childConfig) {
        var res = extend({}, parentConfig), prop;
        for (prop in childConfig) {
          if (hasOwnProp(childConfig, prop)) {
            if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
              res[prop] = {};
              extend(res[prop], parentConfig[prop]);
              extend(res[prop], childConfig[prop]);
            } else if (childConfig[prop] != null) {
              res[prop] = childConfig[prop];
            } else {
              delete res[prop];
            }
          }
        }
        for (prop in parentConfig) {
          if (hasOwnProp(parentConfig, prop) && !hasOwnProp(childConfig, prop) && isObject(parentConfig[prop])) {
            res[prop] = extend({}, res[prop]);
          }
        }
        return res;
      }
      function Locale(config) {
        if (config != null) {
          this.set(config);
        }
      }
      var keys;
      if (Object.keys) {
        keys = Object.keys;
      } else {
        keys = function(obj) {
          var i, res = [];
          for (i in obj) {
            if (hasOwnProp(obj, i)) {
              res.push(i);
            }
          }
          return res;
        };
      }
      var defaultCalendar = {
        sameDay: "[Today at] LT",
        nextDay: "[Tomorrow at] LT",
        nextWeek: "dddd [at] LT",
        lastDay: "[Yesterday at] LT",
        lastWeek: "[Last] dddd [at] LT",
        sameElse: "L"
      };
      function calendar(key, mom, now2) {
        var output = this._calendar[key] || this._calendar["sameElse"];
        return isFunction(output) ? output.call(mom, now2) : output;
      }
      function zeroFill(number, targetLength, forceSign) {
        var absNumber = "" + Math.abs(number), zerosToFill = targetLength - absNumber.length, sign2 = number >= 0;
        return (sign2 ? forceSign ? "+" : "" : "-") + Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
      }
      var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g, localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g, formatFunctions = {}, formatTokenFunctions = {};
      function addFormatToken(token2, padded, ordinal2, callback) {
        var func = callback;
        if (typeof callback === "string") {
          func = function() {
            return this[callback]();
          };
        }
        if (token2) {
          formatTokenFunctions[token2] = func;
        }
        if (padded) {
          formatTokenFunctions[padded[0]] = function() {
            return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
          };
        }
        if (ordinal2) {
          formatTokenFunctions[ordinal2] = function() {
            return this.localeData().ordinal(
              func.apply(this, arguments),
              token2
            );
          };
        }
      }
      function removeFormattingTokens(input) {
        if (input.match(/\[[\s\S]/)) {
          return input.replace(/^\[|\]$/g, "");
        }
        return input.replace(/\\/g, "");
      }
      function makeFormatFunction(format2) {
        var array = format2.match(formattingTokens), i, length;
        for (i = 0, length = array.length; i < length; i++) {
          if (formatTokenFunctions[array[i]]) {
            array[i] = formatTokenFunctions[array[i]];
          } else {
            array[i] = removeFormattingTokens(array[i]);
          }
        }
        return function(mom) {
          var output = "", i2;
          for (i2 = 0; i2 < length; i2++) {
            output += isFunction(array[i2]) ? array[i2].call(mom, format2) : array[i2];
          }
          return output;
        };
      }
      function formatMoment(m, format2) {
        if (!m.isValid()) {
          return m.localeData().invalidDate();
        }
        format2 = expandFormat(format2, m.localeData());
        formatFunctions[format2] = formatFunctions[format2] || makeFormatFunction(format2);
        return formatFunctions[format2](m);
      }
      function expandFormat(format2, locale2) {
        var i = 5;
        function replaceLongDateFormatTokens(input) {
          return locale2.longDateFormat(input) || input;
        }
        localFormattingTokens.lastIndex = 0;
        while (i >= 0 && localFormattingTokens.test(format2)) {
          format2 = format2.replace(
            localFormattingTokens,
            replaceLongDateFormatTokens
          );
          localFormattingTokens.lastIndex = 0;
          i -= 1;
        }
        return format2;
      }
      var defaultLongDateFormat = {
        LTS: "h:mm:ss A",
        LT: "h:mm A",
        L: "MM/DD/YYYY",
        LL: "MMMM D, YYYY",
        LLL: "MMMM D, YYYY h:mm A",
        LLLL: "dddd, MMMM D, YYYY h:mm A"
      };
      function longDateFormat(key) {
        var format2 = this._longDateFormat[key], formatUpper = this._longDateFormat[key.toUpperCase()];
        if (format2 || !formatUpper) {
          return format2;
        }
        this._longDateFormat[key] = formatUpper.match(formattingTokens).map(function(tok) {
          if (tok === "MMMM" || tok === "MM" || tok === "DD" || tok === "dddd") {
            return tok.slice(1);
          }
          return tok;
        }).join("");
        return this._longDateFormat[key];
      }
      var defaultInvalidDate = "Invalid date";
      function invalidDate() {
        return this._invalidDate;
      }
      var defaultOrdinal = "%d", defaultDayOfMonthOrdinalParse = /\d{1,2}/;
      function ordinal(number) {
        return this._ordinal.replace("%d", number);
      }
      var defaultRelativeTime = {
        future: "in %s",
        past: "%s ago",
        s: "a few seconds",
        ss: "%d seconds",
        m: "a minute",
        mm: "%d minutes",
        h: "an hour",
        hh: "%d hours",
        d: "a day",
        dd: "%d days",
        w: "a week",
        ww: "%d weeks",
        M: "a month",
        MM: "%d months",
        y: "a year",
        yy: "%d years"
      };
      function relativeTime(number, withoutSuffix, string2, isFuture) {
        var output = this._relativeTime[string2];
        return isFunction(output) ? output(number, withoutSuffix, string2, isFuture) : output.replace(/%d/i, number);
      }
      function pastFuture(diff2, output) {
        var format2 = this._relativeTime[diff2 > 0 ? "future" : "past"];
        return isFunction(format2) ? format2(output) : format2.replace(/%s/i, output);
      }
      var aliases = {};
      function addUnitAlias(unit, shorthand) {
        var lowerCase = unit.toLowerCase();
        aliases[lowerCase] = aliases[lowerCase + "s"] = aliases[shorthand] = unit;
      }
      function normalizeUnits(units) {
        return typeof units === "string" ? aliases[units] || aliases[units.toLowerCase()] : void 0;
      }
      function normalizeObjectUnits(inputObject) {
        var normalizedInput = {}, normalizedProp, prop;
        for (prop in inputObject) {
          if (hasOwnProp(inputObject, prop)) {
            normalizedProp = normalizeUnits(prop);
            if (normalizedProp) {
              normalizedInput[normalizedProp] = inputObject[prop];
            }
          }
        }
        return normalizedInput;
      }
      var priorities = {};
      function addUnitPriority(unit, priority) {
        priorities[unit] = priority;
      }
      function getPrioritizedUnits(unitsObj) {
        var units = [], u;
        for (u in unitsObj) {
          if (hasOwnProp(unitsObj, u)) {
            units.push({ unit: u, priority: priorities[u] });
          }
        }
        units.sort(function(a, b) {
          return a.priority - b.priority;
        });
        return units;
      }
      function isLeapYear(year) {
        return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
      }
      function absFloor(number) {
        if (number < 0) {
          return Math.ceil(number) || 0;
        } else {
          return Math.floor(number);
        }
      }
      function toInt(argumentForCoercion) {
        var coercedNumber = +argumentForCoercion, value = 0;
        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
          value = absFloor(coercedNumber);
        }
        return value;
      }
      function makeGetSet(unit, keepTime) {
        return function(value) {
          if (value != null) {
            set$1(this, unit, value);
            hooks.updateOffset(this, keepTime);
            return this;
          } else {
            return get(this, unit);
          }
        };
      }
      function get(mom, unit) {
        return mom.isValid() ? mom._d["get" + (mom._isUTC ? "UTC" : "") + unit]() : NaN;
      }
      function set$1(mom, unit, value) {
        if (mom.isValid() && !isNaN(value)) {
          if (unit === "FullYear" && isLeapYear(mom.year()) && mom.month() === 1 && mom.date() === 29) {
            value = toInt(value);
            mom._d["set" + (mom._isUTC ? "UTC" : "") + unit](
              value,
              mom.month(),
              daysInMonth(value, mom.month())
            );
          } else {
            mom._d["set" + (mom._isUTC ? "UTC" : "") + unit](value);
          }
        }
      }
      function stringGet(units) {
        units = normalizeUnits(units);
        if (isFunction(this[units])) {
          return this[units]();
        }
        return this;
      }
      function stringSet(units, value) {
        if (typeof units === "object") {
          units = normalizeObjectUnits(units);
          var prioritized = getPrioritizedUnits(units), i;
          for (i = 0; i < prioritized.length; i++) {
            this[prioritized[i].unit](units[prioritized[i].unit]);
          }
        } else {
          units = normalizeUnits(units);
          if (isFunction(this[units])) {
            return this[units](value);
          }
        }
        return this;
      }
      var match1 = /\d/, match2 = /\d\d/, match3 = /\d{3}/, match4 = /\d{4}/, match6 = /[+-]?\d{6}/, match1to2 = /\d\d?/, match3to4 = /\d\d\d\d?/, match5to6 = /\d\d\d\d\d\d?/, match1to3 = /\d{1,3}/, match1to4 = /\d{1,4}/, match1to6 = /[+-]?\d{1,6}/, matchUnsigned = /\d+/, matchSigned = /[+-]?\d+/, matchOffset = /Z|[+-]\d\d:?\d\d/gi, matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi, matchTimestamp = /[+-]?\d+(\.\d{1,3})?/, matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i, regexes;
      regexes = {};
      function addRegexToken(token2, regex, strictRegex) {
        regexes[token2] = isFunction(regex) ? regex : function(isStrict, localeData2) {
          return isStrict && strictRegex ? strictRegex : regex;
        };
      }
      function getParseRegexForToken(token2, config) {
        if (!hasOwnProp(regexes, token2)) {
          return new RegExp(unescapeFormat(token2));
        }
        return regexes[token2](config._strict, config._locale);
      }
      function unescapeFormat(s) {
        return regexEscape(
          s.replace("\\", "").replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function(matched, p1, p2, p3, p4) {
            return p1 || p2 || p3 || p4;
          })
        );
      }
      function regexEscape(s) {
        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
      }
      var tokens = {};
      function addParseToken(token2, callback) {
        var i, func = callback;
        if (typeof token2 === "string") {
          token2 = [token2];
        }
        if (isNumber(callback)) {
          func = function(input, array) {
            array[callback] = toInt(input);
          };
        }
        for (i = 0; i < token2.length; i++) {
          tokens[token2[i]] = func;
        }
      }
      function addWeekParseToken(token2, callback) {
        addParseToken(token2, function(input, array, config, token3) {
          config._w = config._w || {};
          callback(input, config._w, config, token3);
        });
      }
      function addTimeToArrayFromToken(token2, input, config) {
        if (input != null && hasOwnProp(tokens, token2)) {
          tokens[token2](input, config._a, config, token2);
        }
      }
      var YEAR = 0, MONTH = 1, DATE = 2, HOUR = 3, MINUTE = 4, SECOND = 5, MILLISECOND = 6, WEEK = 7, WEEKDAY = 8;
      function mod(n, x) {
        return (n % x + x) % x;
      }
      var indexOf;
      if (Array.prototype.indexOf) {
        indexOf = Array.prototype.indexOf;
      } else {
        indexOf = function(o) {
          var i;
          for (i = 0; i < this.length; ++i) {
            if (this[i] === o) {
              return i;
            }
          }
          return -1;
        };
      }
      function daysInMonth(year, month) {
        if (isNaN(year) || isNaN(month)) {
          return NaN;
        }
        var modMonth = mod(month, 12);
        year += (month - modMonth) / 12;
        return modMonth === 1 ? isLeapYear(year) ? 29 : 28 : 31 - modMonth % 7 % 2;
      }
      addFormatToken("M", ["MM", 2], "Mo", function() {
        return this.month() + 1;
      });
      addFormatToken("MMM", 0, 0, function(format2) {
        return this.localeData().monthsShort(this, format2);
      });
      addFormatToken("MMMM", 0, 0, function(format2) {
        return this.localeData().months(this, format2);
      });
      addUnitAlias("month", "M");
      addUnitPriority("month", 8);
      addRegexToken("M", match1to2);
      addRegexToken("MM", match1to2, match2);
      addRegexToken("MMM", function(isStrict, locale2) {
        return locale2.monthsShortRegex(isStrict);
      });
      addRegexToken("MMMM", function(isStrict, locale2) {
        return locale2.monthsRegex(isStrict);
      });
      addParseToken(["M", "MM"], function(input, array) {
        array[MONTH] = toInt(input) - 1;
      });
      addParseToken(["MMM", "MMMM"], function(input, array, config, token2) {
        var month = config._locale.monthsParse(input, token2, config._strict);
        if (month != null) {
          array[MONTH] = month;
        } else {
          getParsingFlags(config).invalidMonth = input;
        }
      });
      var defaultLocaleMonths = "January_February_March_April_May_June_July_August_September_October_November_December".split(
        "_"
      ), defaultLocaleMonthsShort = "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split(
        "_"
      ), MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/, defaultMonthsShortRegex = matchWord, defaultMonthsRegex = matchWord;
      function localeMonths(m, format2) {
        if (!m) {
          return isArray(this._months) ? this._months : this._months["standalone"];
        }
        return isArray(this._months) ? this._months[m.month()] : this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format2) ? "format" : "standalone"][m.month()];
      }
      function localeMonthsShort(m, format2) {
        if (!m) {
          return isArray(this._monthsShort) ? this._monthsShort : this._monthsShort["standalone"];
        }
        return isArray(this._monthsShort) ? this._monthsShort[m.month()] : this._monthsShort[MONTHS_IN_FORMAT.test(format2) ? "format" : "standalone"][m.month()];
      }
      function handleStrictParse(monthName, format2, strict) {
        var i, ii, mom, llc = monthName.toLocaleLowerCase();
        if (!this._monthsParse) {
          this._monthsParse = [];
          this._longMonthsParse = [];
          this._shortMonthsParse = [];
          for (i = 0; i < 12; ++i) {
            mom = createUTC([2e3, i]);
            this._shortMonthsParse[i] = this.monthsShort(
              mom,
              ""
            ).toLocaleLowerCase();
            this._longMonthsParse[i] = this.months(mom, "").toLocaleLowerCase();
          }
        }
        if (strict) {
          if (format2 === "MMM") {
            ii = indexOf.call(this._shortMonthsParse, llc);
            return ii !== -1 ? ii : null;
          } else {
            ii = indexOf.call(this._longMonthsParse, llc);
            return ii !== -1 ? ii : null;
          }
        } else {
          if (format2 === "MMM") {
            ii = indexOf.call(this._shortMonthsParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._longMonthsParse, llc);
            return ii !== -1 ? ii : null;
          } else {
            ii = indexOf.call(this._longMonthsParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._shortMonthsParse, llc);
            return ii !== -1 ? ii : null;
          }
        }
      }
      function localeMonthsParse(monthName, format2, strict) {
        var i, mom, regex;
        if (this._monthsParseExact) {
          return handleStrictParse.call(this, monthName, format2, strict);
        }
        if (!this._monthsParse) {
          this._monthsParse = [];
          this._longMonthsParse = [];
          this._shortMonthsParse = [];
        }
        for (i = 0; i < 12; i++) {
          mom = createUTC([2e3, i]);
          if (strict && !this._longMonthsParse[i]) {
            this._longMonthsParse[i] = new RegExp(
              "^" + this.months(mom, "").replace(".", "") + "$",
              "i"
            );
            this._shortMonthsParse[i] = new RegExp(
              "^" + this.monthsShort(mom, "").replace(".", "") + "$",
              "i"
            );
          }
          if (!strict && !this._monthsParse[i]) {
            regex = "^" + this.months(mom, "") + "|^" + this.monthsShort(mom, "");
            this._monthsParse[i] = new RegExp(regex.replace(".", ""), "i");
          }
          if (strict && format2 === "MMMM" && this._longMonthsParse[i].test(monthName)) {
            return i;
          } else if (strict && format2 === "MMM" && this._shortMonthsParse[i].test(monthName)) {
            return i;
          } else if (!strict && this._monthsParse[i].test(monthName)) {
            return i;
          }
        }
      }
      function setMonth(mom, value) {
        var dayOfMonth;
        if (!mom.isValid()) {
          return mom;
        }
        if (typeof value === "string") {
          if (/^\d+$/.test(value)) {
            value = toInt(value);
          } else {
            value = mom.localeData().monthsParse(value);
            if (!isNumber(value)) {
              return mom;
            }
          }
        }
        dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
        mom._d["set" + (mom._isUTC ? "UTC" : "") + "Month"](value, dayOfMonth);
        return mom;
      }
      function getSetMonth(value) {
        if (value != null) {
          setMonth(this, value);
          hooks.updateOffset(this, true);
          return this;
        } else {
          return get(this, "Month");
        }
      }
      function getDaysInMonth() {
        return daysInMonth(this.year(), this.month());
      }
      function monthsShortRegex(isStrict) {
        if (this._monthsParseExact) {
          if (!hasOwnProp(this, "_monthsRegex")) {
            computeMonthsParse.call(this);
          }
          if (isStrict) {
            return this._monthsShortStrictRegex;
          } else {
            return this._monthsShortRegex;
          }
        } else {
          if (!hasOwnProp(this, "_monthsShortRegex")) {
            this._monthsShortRegex = defaultMonthsShortRegex;
          }
          return this._monthsShortStrictRegex && isStrict ? this._monthsShortStrictRegex : this._monthsShortRegex;
        }
      }
      function monthsRegex(isStrict) {
        if (this._monthsParseExact) {
          if (!hasOwnProp(this, "_monthsRegex")) {
            computeMonthsParse.call(this);
          }
          if (isStrict) {
            return this._monthsStrictRegex;
          } else {
            return this._monthsRegex;
          }
        } else {
          if (!hasOwnProp(this, "_monthsRegex")) {
            this._monthsRegex = defaultMonthsRegex;
          }
          return this._monthsStrictRegex && isStrict ? this._monthsStrictRegex : this._monthsRegex;
        }
      }
      function computeMonthsParse() {
        function cmpLenRev(a, b) {
          return b.length - a.length;
        }
        var shortPieces = [], longPieces = [], mixedPieces = [], i, mom;
        for (i = 0; i < 12; i++) {
          mom = createUTC([2e3, i]);
          shortPieces.push(this.monthsShort(mom, ""));
          longPieces.push(this.months(mom, ""));
          mixedPieces.push(this.months(mom, ""));
          mixedPieces.push(this.monthsShort(mom, ""));
        }
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);
        for (i = 0; i < 12; i++) {
          shortPieces[i] = regexEscape(shortPieces[i]);
          longPieces[i] = regexEscape(longPieces[i]);
        }
        for (i = 0; i < 24; i++) {
          mixedPieces[i] = regexEscape(mixedPieces[i]);
        }
        this._monthsRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
        this._monthsShortRegex = this._monthsRegex;
        this._monthsStrictRegex = new RegExp(
          "^(" + longPieces.join("|") + ")",
          "i"
        );
        this._monthsShortStrictRegex = new RegExp(
          "^(" + shortPieces.join("|") + ")",
          "i"
        );
      }
      addFormatToken("Y", 0, 0, function() {
        var y = this.year();
        return y <= 9999 ? zeroFill(y, 4) : "+" + y;
      });
      addFormatToken(0, ["YY", 2], 0, function() {
        return this.year() % 100;
      });
      addFormatToken(0, ["YYYY", 4], 0, "year");
      addFormatToken(0, ["YYYYY", 5], 0, "year");
      addFormatToken(0, ["YYYYYY", 6, true], 0, "year");
      addUnitAlias("year", "y");
      addUnitPriority("year", 1);
      addRegexToken("Y", matchSigned);
      addRegexToken("YY", match1to2, match2);
      addRegexToken("YYYY", match1to4, match4);
      addRegexToken("YYYYY", match1to6, match6);
      addRegexToken("YYYYYY", match1to6, match6);
      addParseToken(["YYYYY", "YYYYYY"], YEAR);
      addParseToken("YYYY", function(input, array) {
        array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
      });
      addParseToken("YY", function(input, array) {
        array[YEAR] = hooks.parseTwoDigitYear(input);
      });
      addParseToken("Y", function(input, array) {
        array[YEAR] = parseInt(input, 10);
      });
      function daysInYear(year) {
        return isLeapYear(year) ? 366 : 365;
      }
      hooks.parseTwoDigitYear = function(input) {
        return toInt(input) + (toInt(input) > 68 ? 1900 : 2e3);
      };
      var getSetYear = makeGetSet("FullYear", true);
      function getIsLeapYear() {
        return isLeapYear(this.year());
      }
      function createDate(y, m, d, h, M, s, ms) {
        var date;
        if (y < 100 && y >= 0) {
          date = new Date(y + 400, m, d, h, M, s, ms);
          if (isFinite(date.getFullYear())) {
            date.setFullYear(y);
          }
        } else {
          date = new Date(y, m, d, h, M, s, ms);
        }
        return date;
      }
      function createUTCDate(y) {
        var date, args;
        if (y < 100 && y >= 0) {
          args = Array.prototype.slice.call(arguments);
          args[0] = y + 400;
          date = new Date(Date.UTC.apply(null, args));
          if (isFinite(date.getUTCFullYear())) {
            date.setUTCFullYear(y);
          }
        } else {
          date = new Date(Date.UTC.apply(null, arguments));
        }
        return date;
      }
      function firstWeekOffset(year, dow, doy) {
        var fwd = 7 + dow - doy, fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;
        return -fwdlw + fwd - 1;
      }
      function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
        var localWeekday = (7 + weekday - dow) % 7, weekOffset = firstWeekOffset(year, dow, doy), dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset, resYear, resDayOfYear;
        if (dayOfYear <= 0) {
          resYear = year - 1;
          resDayOfYear = daysInYear(resYear) + dayOfYear;
        } else if (dayOfYear > daysInYear(year)) {
          resYear = year + 1;
          resDayOfYear = dayOfYear - daysInYear(year);
        } else {
          resYear = year;
          resDayOfYear = dayOfYear;
        }
        return {
          year: resYear,
          dayOfYear: resDayOfYear
        };
      }
      function weekOfYear(mom, dow, doy) {
        var weekOffset = firstWeekOffset(mom.year(), dow, doy), week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1, resWeek, resYear;
        if (week < 1) {
          resYear = mom.year() - 1;
          resWeek = week + weeksInYear(resYear, dow, doy);
        } else if (week > weeksInYear(mom.year(), dow, doy)) {
          resWeek = week - weeksInYear(mom.year(), dow, doy);
          resYear = mom.year() + 1;
        } else {
          resYear = mom.year();
          resWeek = week;
        }
        return {
          week: resWeek,
          year: resYear
        };
      }
      function weeksInYear(year, dow, doy) {
        var weekOffset = firstWeekOffset(year, dow, doy), weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
        return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
      }
      addFormatToken("w", ["ww", 2], "wo", "week");
      addFormatToken("W", ["WW", 2], "Wo", "isoWeek");
      addUnitAlias("week", "w");
      addUnitAlias("isoWeek", "W");
      addUnitPriority("week", 5);
      addUnitPriority("isoWeek", 5);
      addRegexToken("w", match1to2);
      addRegexToken("ww", match1to2, match2);
      addRegexToken("W", match1to2);
      addRegexToken("WW", match1to2, match2);
      addWeekParseToken(["w", "ww", "W", "WW"], function(input, week, config, token2) {
        week[token2.substr(0, 1)] = toInt(input);
      });
      function localeWeek(mom) {
        return weekOfYear(mom, this._week.dow, this._week.doy).week;
      }
      var defaultLocaleWeek = {
        dow: 0,
        // Sunday is the first day of the week.
        doy: 6
        // The week that contains Jan 6th is the first week of the year.
      };
      function localeFirstDayOfWeek() {
        return this._week.dow;
      }
      function localeFirstDayOfYear() {
        return this._week.doy;
      }
      function getSetWeek(input) {
        var week = this.localeData().week(this);
        return input == null ? week : this.add((input - week) * 7, "d");
      }
      function getSetISOWeek(input) {
        var week = weekOfYear(this, 1, 4).week;
        return input == null ? week : this.add((input - week) * 7, "d");
      }
      addFormatToken("d", 0, "do", "day");
      addFormatToken("dd", 0, 0, function(format2) {
        return this.localeData().weekdaysMin(this, format2);
      });
      addFormatToken("ddd", 0, 0, function(format2) {
        return this.localeData().weekdaysShort(this, format2);
      });
      addFormatToken("dddd", 0, 0, function(format2) {
        return this.localeData().weekdays(this, format2);
      });
      addFormatToken("e", 0, 0, "weekday");
      addFormatToken("E", 0, 0, "isoWeekday");
      addUnitAlias("day", "d");
      addUnitAlias("weekday", "e");
      addUnitAlias("isoWeekday", "E");
      addUnitPriority("day", 11);
      addUnitPriority("weekday", 11);
      addUnitPriority("isoWeekday", 11);
      addRegexToken("d", match1to2);
      addRegexToken("e", match1to2);
      addRegexToken("E", match1to2);
      addRegexToken("dd", function(isStrict, locale2) {
        return locale2.weekdaysMinRegex(isStrict);
      });
      addRegexToken("ddd", function(isStrict, locale2) {
        return locale2.weekdaysShortRegex(isStrict);
      });
      addRegexToken("dddd", function(isStrict, locale2) {
        return locale2.weekdaysRegex(isStrict);
      });
      addWeekParseToken(["dd", "ddd", "dddd"], function(input, week, config, token2) {
        var weekday = config._locale.weekdaysParse(input, token2, config._strict);
        if (weekday != null) {
          week.d = weekday;
        } else {
          getParsingFlags(config).invalidWeekday = input;
        }
      });
      addWeekParseToken(["d", "e", "E"], function(input, week, config, token2) {
        week[token2] = toInt(input);
      });
      function parseWeekday(input, locale2) {
        if (typeof input !== "string") {
          return input;
        }
        if (!isNaN(input)) {
          return parseInt(input, 10);
        }
        input = locale2.weekdaysParse(input);
        if (typeof input === "number") {
          return input;
        }
        return null;
      }
      function parseIsoWeekday(input, locale2) {
        if (typeof input === "string") {
          return locale2.weekdaysParse(input) % 7 || 7;
        }
        return isNaN(input) ? null : input;
      }
      function shiftWeekdays(ws, n) {
        return ws.slice(n, 7).concat(ws.slice(0, n));
      }
      var defaultLocaleWeekdays = "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split(
        "_"
      ), defaultLocaleWeekdaysShort = "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"), defaultLocaleWeekdaysMin = "Su_Mo_Tu_We_Th_Fr_Sa".split("_"), defaultWeekdaysRegex = matchWord, defaultWeekdaysShortRegex = matchWord, defaultWeekdaysMinRegex = matchWord;
      function localeWeekdays(m, format2) {
        var weekdays = isArray(this._weekdays) ? this._weekdays : this._weekdays[m && m !== true && this._weekdays.isFormat.test(format2) ? "format" : "standalone"];
        return m === true ? shiftWeekdays(weekdays, this._week.dow) : m ? weekdays[m.day()] : weekdays;
      }
      function localeWeekdaysShort(m) {
        return m === true ? shiftWeekdays(this._weekdaysShort, this._week.dow) : m ? this._weekdaysShort[m.day()] : this._weekdaysShort;
      }
      function localeWeekdaysMin(m) {
        return m === true ? shiftWeekdays(this._weekdaysMin, this._week.dow) : m ? this._weekdaysMin[m.day()] : this._weekdaysMin;
      }
      function handleStrictParse$1(weekdayName, format2, strict) {
        var i, ii, mom, llc = weekdayName.toLocaleLowerCase();
        if (!this._weekdaysParse) {
          this._weekdaysParse = [];
          this._shortWeekdaysParse = [];
          this._minWeekdaysParse = [];
          for (i = 0; i < 7; ++i) {
            mom = createUTC([2e3, 1]).day(i);
            this._minWeekdaysParse[i] = this.weekdaysMin(
              mom,
              ""
            ).toLocaleLowerCase();
            this._shortWeekdaysParse[i] = this.weekdaysShort(
              mom,
              ""
            ).toLocaleLowerCase();
            this._weekdaysParse[i] = this.weekdays(mom, "").toLocaleLowerCase();
          }
        }
        if (strict) {
          if (format2 === "dddd") {
            ii = indexOf.call(this._weekdaysParse, llc);
            return ii !== -1 ? ii : null;
          } else if (format2 === "ddd") {
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          } else {
            ii = indexOf.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          }
        } else {
          if (format2 === "dddd") {
            ii = indexOf.call(this._weekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          } else if (format2 === "ddd") {
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._weekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          } else {
            ii = indexOf.call(this._minWeekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._weekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          }
        }
      }
      function localeWeekdaysParse(weekdayName, format2, strict) {
        var i, mom, regex;
        if (this._weekdaysParseExact) {
          return handleStrictParse$1.call(this, weekdayName, format2, strict);
        }
        if (!this._weekdaysParse) {
          this._weekdaysParse = [];
          this._minWeekdaysParse = [];
          this._shortWeekdaysParse = [];
          this._fullWeekdaysParse = [];
        }
        for (i = 0; i < 7; i++) {
          mom = createUTC([2e3, 1]).day(i);
          if (strict && !this._fullWeekdaysParse[i]) {
            this._fullWeekdaysParse[i] = new RegExp(
              "^" + this.weekdays(mom, "").replace(".", "\\.?") + "$",
              "i"
            );
            this._shortWeekdaysParse[i] = new RegExp(
              "^" + this.weekdaysShort(mom, "").replace(".", "\\.?") + "$",
              "i"
            );
            this._minWeekdaysParse[i] = new RegExp(
              "^" + this.weekdaysMin(mom, "").replace(".", "\\.?") + "$",
              "i"
            );
          }
          if (!this._weekdaysParse[i]) {
            regex = "^" + this.weekdays(mom, "") + "|^" + this.weekdaysShort(mom, "") + "|^" + this.weekdaysMin(mom, "");
            this._weekdaysParse[i] = new RegExp(regex.replace(".", ""), "i");
          }
          if (strict && format2 === "dddd" && this._fullWeekdaysParse[i].test(weekdayName)) {
            return i;
          } else if (strict && format2 === "ddd" && this._shortWeekdaysParse[i].test(weekdayName)) {
            return i;
          } else if (strict && format2 === "dd" && this._minWeekdaysParse[i].test(weekdayName)) {
            return i;
          } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
            return i;
          }
        }
      }
      function getSetDayOfWeek(input) {
        if (!this.isValid()) {
          return input != null ? this : NaN;
        }
        var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
        if (input != null) {
          input = parseWeekday(input, this.localeData());
          return this.add(input - day, "d");
        } else {
          return day;
        }
      }
      function getSetLocaleDayOfWeek(input) {
        if (!this.isValid()) {
          return input != null ? this : NaN;
        }
        var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
        return input == null ? weekday : this.add(input - weekday, "d");
      }
      function getSetISODayOfWeek(input) {
        if (!this.isValid()) {
          return input != null ? this : NaN;
        }
        if (input != null) {
          var weekday = parseIsoWeekday(input, this.localeData());
          return this.day(this.day() % 7 ? weekday : weekday - 7);
        } else {
          return this.day() || 7;
        }
      }
      function weekdaysRegex(isStrict) {
        if (this._weekdaysParseExact) {
          if (!hasOwnProp(this, "_weekdaysRegex")) {
            computeWeekdaysParse.call(this);
          }
          if (isStrict) {
            return this._weekdaysStrictRegex;
          } else {
            return this._weekdaysRegex;
          }
        } else {
          if (!hasOwnProp(this, "_weekdaysRegex")) {
            this._weekdaysRegex = defaultWeekdaysRegex;
          }
          return this._weekdaysStrictRegex && isStrict ? this._weekdaysStrictRegex : this._weekdaysRegex;
        }
      }
      function weekdaysShortRegex(isStrict) {
        if (this._weekdaysParseExact) {
          if (!hasOwnProp(this, "_weekdaysRegex")) {
            computeWeekdaysParse.call(this);
          }
          if (isStrict) {
            return this._weekdaysShortStrictRegex;
          } else {
            return this._weekdaysShortRegex;
          }
        } else {
          if (!hasOwnProp(this, "_weekdaysShortRegex")) {
            this._weekdaysShortRegex = defaultWeekdaysShortRegex;
          }
          return this._weekdaysShortStrictRegex && isStrict ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
        }
      }
      function weekdaysMinRegex(isStrict) {
        if (this._weekdaysParseExact) {
          if (!hasOwnProp(this, "_weekdaysRegex")) {
            computeWeekdaysParse.call(this);
          }
          if (isStrict) {
            return this._weekdaysMinStrictRegex;
          } else {
            return this._weekdaysMinRegex;
          }
        } else {
          if (!hasOwnProp(this, "_weekdaysMinRegex")) {
            this._weekdaysMinRegex = defaultWeekdaysMinRegex;
          }
          return this._weekdaysMinStrictRegex && isStrict ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
        }
      }
      function computeWeekdaysParse() {
        function cmpLenRev(a, b) {
          return b.length - a.length;
        }
        var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [], i, mom, minp, shortp, longp;
        for (i = 0; i < 7; i++) {
          mom = createUTC([2e3, 1]).day(i);
          minp = regexEscape(this.weekdaysMin(mom, ""));
          shortp = regexEscape(this.weekdaysShort(mom, ""));
          longp = regexEscape(this.weekdays(mom, ""));
          minPieces.push(minp);
          shortPieces.push(shortp);
          longPieces.push(longp);
          mixedPieces.push(minp);
          mixedPieces.push(shortp);
          mixedPieces.push(longp);
        }
        minPieces.sort(cmpLenRev);
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);
        this._weekdaysRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
        this._weekdaysShortRegex = this._weekdaysRegex;
        this._weekdaysMinRegex = this._weekdaysRegex;
        this._weekdaysStrictRegex = new RegExp(
          "^(" + longPieces.join("|") + ")",
          "i"
        );
        this._weekdaysShortStrictRegex = new RegExp(
          "^(" + shortPieces.join("|") + ")",
          "i"
        );
        this._weekdaysMinStrictRegex = new RegExp(
          "^(" + minPieces.join("|") + ")",
          "i"
        );
      }
      function hFormat() {
        return this.hours() % 12 || 12;
      }
      function kFormat() {
        return this.hours() || 24;
      }
      addFormatToken("H", ["HH", 2], 0, "hour");
      addFormatToken("h", ["hh", 2], 0, hFormat);
      addFormatToken("k", ["kk", 2], 0, kFormat);
      addFormatToken("hmm", 0, 0, function() {
        return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2);
      });
      addFormatToken("hmmss", 0, 0, function() {
        return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
      });
      addFormatToken("Hmm", 0, 0, function() {
        return "" + this.hours() + zeroFill(this.minutes(), 2);
      });
      addFormatToken("Hmmss", 0, 0, function() {
        return "" + this.hours() + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
      });
      function meridiem(token2, lowercase) {
        addFormatToken(token2, 0, 0, function() {
          return this.localeData().meridiem(
            this.hours(),
            this.minutes(),
            lowercase
          );
        });
      }
      meridiem("a", true);
      meridiem("A", false);
      addUnitAlias("hour", "h");
      addUnitPriority("hour", 13);
      function matchMeridiem(isStrict, locale2) {
        return locale2._meridiemParse;
      }
      addRegexToken("a", matchMeridiem);
      addRegexToken("A", matchMeridiem);
      addRegexToken("H", match1to2);
      addRegexToken("h", match1to2);
      addRegexToken("k", match1to2);
      addRegexToken("HH", match1to2, match2);
      addRegexToken("hh", match1to2, match2);
      addRegexToken("kk", match1to2, match2);
      addRegexToken("hmm", match3to4);
      addRegexToken("hmmss", match5to6);
      addRegexToken("Hmm", match3to4);
      addRegexToken("Hmmss", match5to6);
      addParseToken(["H", "HH"], HOUR);
      addParseToken(["k", "kk"], function(input, array, config) {
        var kInput = toInt(input);
        array[HOUR] = kInput === 24 ? 0 : kInput;
      });
      addParseToken(["a", "A"], function(input, array, config) {
        config._isPm = config._locale.isPM(input);
        config._meridiem = input;
      });
      addParseToken(["h", "hh"], function(input, array, config) {
        array[HOUR] = toInt(input);
        getParsingFlags(config).bigHour = true;
      });
      addParseToken("hmm", function(input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
        getParsingFlags(config).bigHour = true;
      });
      addParseToken("hmmss", function(input, array, config) {
        var pos1 = input.length - 4, pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
        getParsingFlags(config).bigHour = true;
      });
      addParseToken("Hmm", function(input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
      });
      addParseToken("Hmmss", function(input, array, config) {
        var pos1 = input.length - 4, pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
      });
      function localeIsPM(input) {
        return (input + "").toLowerCase().charAt(0) === "p";
      }
      var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i, getSetHour = makeGetSet("Hours", true);
      function localeMeridiem(hours2, minutes2, isLower) {
        if (hours2 > 11) {
          return isLower ? "pm" : "PM";
        } else {
          return isLower ? "am" : "AM";
        }
      }
      var baseConfig = {
        calendar: defaultCalendar,
        longDateFormat: defaultLongDateFormat,
        invalidDate: defaultInvalidDate,
        ordinal: defaultOrdinal,
        dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
        relativeTime: defaultRelativeTime,
        months: defaultLocaleMonths,
        monthsShort: defaultLocaleMonthsShort,
        week: defaultLocaleWeek,
        weekdays: defaultLocaleWeekdays,
        weekdaysMin: defaultLocaleWeekdaysMin,
        weekdaysShort: defaultLocaleWeekdaysShort,
        meridiemParse: defaultLocaleMeridiemParse
      };
      var locales = {}, localeFamilies = {}, globalLocale;
      function commonPrefix(arr1, arr2) {
        var i, minl = Math.min(arr1.length, arr2.length);
        for (i = 0; i < minl; i += 1) {
          if (arr1[i] !== arr2[i]) {
            return i;
          }
        }
        return minl;
      }
      function normalizeLocale(key) {
        return key ? key.toLowerCase().replace("_", "-") : key;
      }
      function chooseLocale(names) {
        var i = 0, j, next, locale2, split;
        while (i < names.length) {
          split = normalizeLocale(names[i]).split("-");
          j = split.length;
          next = normalizeLocale(names[i + 1]);
          next = next ? next.split("-") : null;
          while (j > 0) {
            locale2 = loadLocale(split.slice(0, j).join("-"));
            if (locale2) {
              return locale2;
            }
            if (next && next.length >= j && commonPrefix(split, next) >= j - 1) {
              break;
            }
            j--;
          }
          i++;
        }
        return globalLocale;
      }
      function loadLocale(name) {
        var oldLocale = null, aliasedRequire;
        if (locales[name] === void 0 && typeof module2 !== "undefined" && module2 && module2.exports) {
          try {
            oldLocale = globalLocale._abbr;
            aliasedRequire = require;
            aliasedRequire("./locale/" + name);
            getSetGlobalLocale(oldLocale);
          } catch (e) {
            locales[name] = null;
          }
        }
        return locales[name];
      }
      function getSetGlobalLocale(key, values) {
        var data;
        if (key) {
          if (isUndefined(values)) {
            data = getLocale(key);
          } else {
            data = defineLocale(key, values);
          }
          if (data) {
            globalLocale = data;
          } else {
            if (typeof console !== "undefined" && console.warn) {
              console.warn(
                "Locale " + key + " not found. Did you forget to load it?"
              );
            }
          }
        }
        return globalLocale._abbr;
      }
      function defineLocale(name, config) {
        if (config !== null) {
          var locale2, parentConfig = baseConfig;
          config.abbr = name;
          if (locales[name] != null) {
            deprecateSimple(
              "defineLocaleOverride",
              "use moment.updateLocale(localeName, config) to change an existing locale. moment.defineLocale(localeName, config) should only be used for creating a new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more info."
            );
            parentConfig = locales[name]._config;
          } else if (config.parentLocale != null) {
            if (locales[config.parentLocale] != null) {
              parentConfig = locales[config.parentLocale]._config;
            } else {
              locale2 = loadLocale(config.parentLocale);
              if (locale2 != null) {
                parentConfig = locale2._config;
              } else {
                if (!localeFamilies[config.parentLocale]) {
                  localeFamilies[config.parentLocale] = [];
                }
                localeFamilies[config.parentLocale].push({
                  name,
                  config
                });
                return null;
              }
            }
          }
          locales[name] = new Locale(mergeConfigs(parentConfig, config));
          if (localeFamilies[name]) {
            localeFamilies[name].forEach(function(x) {
              defineLocale(x.name, x.config);
            });
          }
          getSetGlobalLocale(name);
          return locales[name];
        } else {
          delete locales[name];
          return null;
        }
      }
      function updateLocale(name, config) {
        if (config != null) {
          var locale2, tmpLocale, parentConfig = baseConfig;
          if (locales[name] != null && locales[name].parentLocale != null) {
            locales[name].set(mergeConfigs(locales[name]._config, config));
          } else {
            tmpLocale = loadLocale(name);
            if (tmpLocale != null) {
              parentConfig = tmpLocale._config;
            }
            config = mergeConfigs(parentConfig, config);
            if (tmpLocale == null) {
              config.abbr = name;
            }
            locale2 = new Locale(config);
            locale2.parentLocale = locales[name];
            locales[name] = locale2;
          }
          getSetGlobalLocale(name);
        } else {
          if (locales[name] != null) {
            if (locales[name].parentLocale != null) {
              locales[name] = locales[name].parentLocale;
              if (name === getSetGlobalLocale()) {
                getSetGlobalLocale(name);
              }
            } else if (locales[name] != null) {
              delete locales[name];
            }
          }
        }
        return locales[name];
      }
      function getLocale(key) {
        var locale2;
        if (key && key._locale && key._locale._abbr) {
          key = key._locale._abbr;
        }
        if (!key) {
          return globalLocale;
        }
        if (!isArray(key)) {
          locale2 = loadLocale(key);
          if (locale2) {
            return locale2;
          }
          key = [key];
        }
        return chooseLocale(key);
      }
      function listLocales() {
        return keys(locales);
      }
      function checkOverflow(m) {
        var overflow, a = m._a;
        if (a && getParsingFlags(m).overflow === -2) {
          overflow = a[MONTH] < 0 || a[MONTH] > 11 ? MONTH : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH]) ? DATE : a[HOUR] < 0 || a[HOUR] > 24 || a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0) ? HOUR : a[MINUTE] < 0 || a[MINUTE] > 59 ? MINUTE : a[SECOND] < 0 || a[SECOND] > 59 ? SECOND : a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND : -1;
          if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
            overflow = DATE;
          }
          if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
            overflow = WEEK;
          }
          if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
            overflow = WEEKDAY;
          }
          getParsingFlags(m).overflow = overflow;
        }
        return m;
      }
      var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, tzRegex = /Z|[+-]\d\d(?::?\d\d)?/, isoDates = [
        ["YYYYYY-MM-DD", /[+-]\d{6}-\d\d-\d\d/],
        ["YYYY-MM-DD", /\d{4}-\d\d-\d\d/],
        ["GGGG-[W]WW-E", /\d{4}-W\d\d-\d/],
        ["GGGG-[W]WW", /\d{4}-W\d\d/, false],
        ["YYYY-DDD", /\d{4}-\d{3}/],
        ["YYYY-MM", /\d{4}-\d\d/, false],
        ["YYYYYYMMDD", /[+-]\d{10}/],
        ["YYYYMMDD", /\d{8}/],
        ["GGGG[W]WWE", /\d{4}W\d{3}/],
        ["GGGG[W]WW", /\d{4}W\d{2}/, false],
        ["YYYYDDD", /\d{7}/],
        ["YYYYMM", /\d{6}/, false],
        ["YYYY", /\d{4}/, false]
      ], isoTimes = [
        ["HH:mm:ss.SSSS", /\d\d:\d\d:\d\d\.\d+/],
        ["HH:mm:ss,SSSS", /\d\d:\d\d:\d\d,\d+/],
        ["HH:mm:ss", /\d\d:\d\d:\d\d/],
        ["HH:mm", /\d\d:\d\d/],
        ["HHmmss.SSSS", /\d\d\d\d\d\d\.\d+/],
        ["HHmmss,SSSS", /\d\d\d\d\d\d,\d+/],
        ["HHmmss", /\d\d\d\d\d\d/],
        ["HHmm", /\d\d\d\d/],
        ["HH", /\d\d/]
      ], aspNetJsonRegex = /^\/?Date\((-?\d+)/i, rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/, obsOffsets = {
        UT: 0,
        GMT: 0,
        EDT: -4 * 60,
        EST: -5 * 60,
        CDT: -5 * 60,
        CST: -6 * 60,
        MDT: -6 * 60,
        MST: -7 * 60,
        PDT: -7 * 60,
        PST: -8 * 60
      };
      function configFromISO(config) {
        var i, l, string2 = config._i, match = extendedIsoRegex.exec(string2) || basicIsoRegex.exec(string2), allowTime, dateFormat, timeFormat, tzFormat;
        if (match) {
          getParsingFlags(config).iso = true;
          for (i = 0, l = isoDates.length; i < l; i++) {
            if (isoDates[i][1].exec(match[1])) {
              dateFormat = isoDates[i][0];
              allowTime = isoDates[i][2] !== false;
              break;
            }
          }
          if (dateFormat == null) {
            config._isValid = false;
            return;
          }
          if (match[3]) {
            for (i = 0, l = isoTimes.length; i < l; i++) {
              if (isoTimes[i][1].exec(match[3])) {
                timeFormat = (match[2] || " ") + isoTimes[i][0];
                break;
              }
            }
            if (timeFormat == null) {
              config._isValid = false;
              return;
            }
          }
          if (!allowTime && timeFormat != null) {
            config._isValid = false;
            return;
          }
          if (match[4]) {
            if (tzRegex.exec(match[4])) {
              tzFormat = "Z";
            } else {
              config._isValid = false;
              return;
            }
          }
          config._f = dateFormat + (timeFormat || "") + (tzFormat || "");
          configFromStringAndFormat(config);
        } else {
          config._isValid = false;
        }
      }
      function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
        var result = [
          untruncateYear(yearStr),
          defaultLocaleMonthsShort.indexOf(monthStr),
          parseInt(dayStr, 10),
          parseInt(hourStr, 10),
          parseInt(minuteStr, 10)
        ];
        if (secondStr) {
          result.push(parseInt(secondStr, 10));
        }
        return result;
      }
      function untruncateYear(yearStr) {
        var year = parseInt(yearStr, 10);
        if (year <= 49) {
          return 2e3 + year;
        } else if (year <= 999) {
          return 1900 + year;
        }
        return year;
      }
      function preprocessRFC2822(s) {
        return s.replace(/\([^)]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").replace(/^\s\s*/, "").replace(/\s\s*$/, "");
      }
      function checkWeekday(weekdayStr, parsedInput, config) {
        if (weekdayStr) {
          var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr), weekdayActual = new Date(
            parsedInput[0],
            parsedInput[1],
            parsedInput[2]
          ).getDay();
          if (weekdayProvided !== weekdayActual) {
            getParsingFlags(config).weekdayMismatch = true;
            config._isValid = false;
            return false;
          }
        }
        return true;
      }
      function calculateOffset(obsOffset, militaryOffset, numOffset) {
        if (obsOffset) {
          return obsOffsets[obsOffset];
        } else if (militaryOffset) {
          return 0;
        } else {
          var hm = parseInt(numOffset, 10), m = hm % 100, h = (hm - m) / 100;
          return h * 60 + m;
        }
      }
      function configFromRFC2822(config) {
        var match = rfc2822.exec(preprocessRFC2822(config._i)), parsedArray;
        if (match) {
          parsedArray = extractFromRFC2822Strings(
            match[4],
            match[3],
            match[2],
            match[5],
            match[6],
            match[7]
          );
          if (!checkWeekday(match[1], parsedArray, config)) {
            return;
          }
          config._a = parsedArray;
          config._tzm = calculateOffset(match[8], match[9], match[10]);
          config._d = createUTCDate.apply(null, config._a);
          config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
          getParsingFlags(config).rfc2822 = true;
        } else {
          config._isValid = false;
        }
      }
      function configFromString(config) {
        var matched = aspNetJsonRegex.exec(config._i);
        if (matched !== null) {
          config._d = new Date(+matched[1]);
          return;
        }
        configFromISO(config);
        if (config._isValid === false) {
          delete config._isValid;
        } else {
          return;
        }
        configFromRFC2822(config);
        if (config._isValid === false) {
          delete config._isValid;
        } else {
          return;
        }
        if (config._strict) {
          config._isValid = false;
        } else {
          hooks.createFromInputFallback(config);
        }
      }
      hooks.createFromInputFallback = deprecate(
        "value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.",
        function(config) {
          config._d = new Date(config._i + (config._useUTC ? " UTC" : ""));
        }
      );
      function defaults(a, b, c) {
        if (a != null) {
          return a;
        }
        if (b != null) {
          return b;
        }
        return c;
      }
      function currentDateArray(config) {
        var nowValue = new Date(hooks.now());
        if (config._useUTC) {
          return [
            nowValue.getUTCFullYear(),
            nowValue.getUTCMonth(),
            nowValue.getUTCDate()
          ];
        }
        return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
      }
      function configFromArray(config) {
        var i, date, input = [], currentDate, expectedWeekday, yearToUse;
        if (config._d) {
          return;
        }
        currentDate = currentDateArray(config);
        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
          dayOfYearFromWeekInfo(config);
        }
        if (config._dayOfYear != null) {
          yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);
          if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {
            getParsingFlags(config)._overflowDayOfYear = true;
          }
          date = createUTCDate(yearToUse, 0, config._dayOfYear);
          config._a[MONTH] = date.getUTCMonth();
          config._a[DATE] = date.getUTCDate();
        }
        for (i = 0; i < 3 && config._a[i] == null; ++i) {
          config._a[i] = input[i] = currentDate[i];
        }
        for (; i < 7; i++) {
          config._a[i] = input[i] = config._a[i] == null ? i === 2 ? 1 : 0 : config._a[i];
        }
        if (config._a[HOUR] === 24 && config._a[MINUTE] === 0 && config._a[SECOND] === 0 && config._a[MILLISECOND] === 0) {
          config._nextDay = true;
          config._a[HOUR] = 0;
        }
        config._d = (config._useUTC ? createUTCDate : createDate).apply(
          null,
          input
        );
        expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay();
        if (config._tzm != null) {
          config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
        }
        if (config._nextDay) {
          config._a[HOUR] = 24;
        }
        if (config._w && typeof config._w.d !== "undefined" && config._w.d !== expectedWeekday) {
          getParsingFlags(config).weekdayMismatch = true;
        }
      }
      function dayOfYearFromWeekInfo(config) {
        var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow, curWeek;
        w = config._w;
        if (w.GG != null || w.W != null || w.E != null) {
          dow = 1;
          doy = 4;
          weekYear = defaults(
            w.GG,
            config._a[YEAR],
            weekOfYear(createLocal(), 1, 4).year
          );
          week = defaults(w.W, 1);
          weekday = defaults(w.E, 1);
          if (weekday < 1 || weekday > 7) {
            weekdayOverflow = true;
          }
        } else {
          dow = config._locale._week.dow;
          doy = config._locale._week.doy;
          curWeek = weekOfYear(createLocal(), dow, doy);
          weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);
          week = defaults(w.w, curWeek.week);
          if (w.d != null) {
            weekday = w.d;
            if (weekday < 0 || weekday > 6) {
              weekdayOverflow = true;
            }
          } else if (w.e != null) {
            weekday = w.e + dow;
            if (w.e < 0 || w.e > 6) {
              weekdayOverflow = true;
            }
          } else {
            weekday = dow;
          }
        }
        if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
          getParsingFlags(config)._overflowWeeks = true;
        } else if (weekdayOverflow != null) {
          getParsingFlags(config)._overflowWeekday = true;
        } else {
          temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
          config._a[YEAR] = temp.year;
          config._dayOfYear = temp.dayOfYear;
        }
      }
      hooks.ISO_8601 = function() {
      };
      hooks.RFC_2822 = function() {
      };
      function configFromStringAndFormat(config) {
        if (config._f === hooks.ISO_8601) {
          configFromISO(config);
          return;
        }
        if (config._f === hooks.RFC_2822) {
          configFromRFC2822(config);
          return;
        }
        config._a = [];
        getParsingFlags(config).empty = true;
        var string2 = "" + config._i, i, parsedInput, tokens2, token2, skipped, stringLength = string2.length, totalParsedInputLength = 0, era;
        tokens2 = expandFormat(config._f, config._locale).match(formattingTokens) || [];
        for (i = 0; i < tokens2.length; i++) {
          token2 = tokens2[i];
          parsedInput = (string2.match(getParseRegexForToken(token2, config)) || [])[0];
          if (parsedInput) {
            skipped = string2.substr(0, string2.indexOf(parsedInput));
            if (skipped.length > 0) {
              getParsingFlags(config).unusedInput.push(skipped);
            }
            string2 = string2.slice(
              string2.indexOf(parsedInput) + parsedInput.length
            );
            totalParsedInputLength += parsedInput.length;
          }
          if (formatTokenFunctions[token2]) {
            if (parsedInput) {
              getParsingFlags(config).empty = false;
            } else {
              getParsingFlags(config).unusedTokens.push(token2);
            }
            addTimeToArrayFromToken(token2, parsedInput, config);
          } else if (config._strict && !parsedInput) {
            getParsingFlags(config).unusedTokens.push(token2);
          }
        }
        getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
        if (string2.length > 0) {
          getParsingFlags(config).unusedInput.push(string2);
        }
        if (config._a[HOUR] <= 12 && getParsingFlags(config).bigHour === true && config._a[HOUR] > 0) {
          getParsingFlags(config).bigHour = void 0;
        }
        getParsingFlags(config).parsedDateParts = config._a.slice(0);
        getParsingFlags(config).meridiem = config._meridiem;
        config._a[HOUR] = meridiemFixWrap(
          config._locale,
          config._a[HOUR],
          config._meridiem
        );
        era = getParsingFlags(config).era;
        if (era !== null) {
          config._a[YEAR] = config._locale.erasConvertYear(era, config._a[YEAR]);
        }
        configFromArray(config);
        checkOverflow(config);
      }
      function meridiemFixWrap(locale2, hour, meridiem2) {
        var isPm;
        if (meridiem2 == null) {
          return hour;
        }
        if (locale2.meridiemHour != null) {
          return locale2.meridiemHour(hour, meridiem2);
        } else if (locale2.isPM != null) {
          isPm = locale2.isPM(meridiem2);
          if (isPm && hour < 12) {
            hour += 12;
          }
          if (!isPm && hour === 12) {
            hour = 0;
          }
          return hour;
        } else {
          return hour;
        }
      }
      function configFromStringAndArray(config) {
        var tempConfig, bestMoment, scoreToBeat, i, currentScore, validFormatFound, bestFormatIsValid = false;
        if (config._f.length === 0) {
          getParsingFlags(config).invalidFormat = true;
          config._d = new Date(NaN);
          return;
        }
        for (i = 0; i < config._f.length; i++) {
          currentScore = 0;
          validFormatFound = false;
          tempConfig = copyConfig({}, config);
          if (config._useUTC != null) {
            tempConfig._useUTC = config._useUTC;
          }
          tempConfig._f = config._f[i];
          configFromStringAndFormat(tempConfig);
          if (isValid(tempConfig)) {
            validFormatFound = true;
          }
          currentScore += getParsingFlags(tempConfig).charsLeftOver;
          currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;
          getParsingFlags(tempConfig).score = currentScore;
          if (!bestFormatIsValid) {
            if (scoreToBeat == null || currentScore < scoreToBeat || validFormatFound) {
              scoreToBeat = currentScore;
              bestMoment = tempConfig;
              if (validFormatFound) {
                bestFormatIsValid = true;
              }
            }
          } else {
            if (currentScore < scoreToBeat) {
              scoreToBeat = currentScore;
              bestMoment = tempConfig;
            }
          }
        }
        extend(config, bestMoment || tempConfig);
      }
      function configFromObject(config) {
        if (config._d) {
          return;
        }
        var i = normalizeObjectUnits(config._i), dayOrDate = i.day === void 0 ? i.date : i.day;
        config._a = map2(
          [i.year, i.month, dayOrDate, i.hour, i.minute, i.second, i.millisecond],
          function(obj) {
            return obj && parseInt(obj, 10);
          }
        );
        configFromArray(config);
      }
      function createFromConfig(config) {
        var res = new Moment(checkOverflow(prepareConfig(config)));
        if (res._nextDay) {
          res.add(1, "d");
          res._nextDay = void 0;
        }
        return res;
      }
      function prepareConfig(config) {
        var input = config._i, format2 = config._f;
        config._locale = config._locale || getLocale(config._l);
        if (input === null || format2 === void 0 && input === "") {
          return createInvalid({ nullInput: true });
        }
        if (typeof input === "string") {
          config._i = input = config._locale.preparse(input);
        }
        if (isMoment(input)) {
          return new Moment(checkOverflow(input));
        } else if (isDate(input)) {
          config._d = input;
        } else if (isArray(format2)) {
          configFromStringAndArray(config);
        } else if (format2) {
          configFromStringAndFormat(config);
        } else {
          configFromInput(config);
        }
        if (!isValid(config)) {
          config._d = null;
        }
        return config;
      }
      function configFromInput(config) {
        var input = config._i;
        if (isUndefined(input)) {
          config._d = new Date(hooks.now());
        } else if (isDate(input)) {
          config._d = new Date(input.valueOf());
        } else if (typeof input === "string") {
          configFromString(config);
        } else if (isArray(input)) {
          config._a = map2(input.slice(0), function(obj) {
            return parseInt(obj, 10);
          });
          configFromArray(config);
        } else if (isObject(input)) {
          configFromObject(config);
        } else if (isNumber(input)) {
          config._d = new Date(input);
        } else {
          hooks.createFromInputFallback(config);
        }
      }
      function createLocalOrUTC(input, format2, locale2, strict, isUTC) {
        var c = {};
        if (format2 === true || format2 === false) {
          strict = format2;
          format2 = void 0;
        }
        if (locale2 === true || locale2 === false) {
          strict = locale2;
          locale2 = void 0;
        }
        if (isObject(input) && isObjectEmpty(input) || isArray(input) && input.length === 0) {
          input = void 0;
        }
        c._isAMomentObject = true;
        c._useUTC = c._isUTC = isUTC;
        c._l = locale2;
        c._i = input;
        c._f = format2;
        c._strict = strict;
        return createFromConfig(c);
      }
      function createLocal(input, format2, locale2, strict) {
        return createLocalOrUTC(input, format2, locale2, strict, false);
      }
      var prototypeMin = deprecate(
        "moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/",
        function() {
          var other = createLocal.apply(null, arguments);
          if (this.isValid() && other.isValid()) {
            return other < this ? this : other;
          } else {
            return createInvalid();
          }
        }
      ), prototypeMax = deprecate(
        "moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/",
        function() {
          var other = createLocal.apply(null, arguments);
          if (this.isValid() && other.isValid()) {
            return other > this ? this : other;
          } else {
            return createInvalid();
          }
        }
      );
      function pickBy(fn, moments) {
        var res, i;
        if (moments.length === 1 && isArray(moments[0])) {
          moments = moments[0];
        }
        if (!moments.length) {
          return createLocal();
        }
        res = moments[0];
        for (i = 1; i < moments.length; ++i) {
          if (!moments[i].isValid() || moments[i][fn](res)) {
            res = moments[i];
          }
        }
        return res;
      }
      function min() {
        var args = [].slice.call(arguments, 0);
        return pickBy("isBefore", args);
      }
      function max() {
        var args = [].slice.call(arguments, 0);
        return pickBy("isAfter", args);
      }
      var now = function() {
        return Date.now ? Date.now() : +new Date();
      };
      var ordering = [
        "year",
        "quarter",
        "month",
        "week",
        "day",
        "hour",
        "minute",
        "second",
        "millisecond"
      ];
      function isDurationValid(m) {
        var key, unitHasDecimal = false, i;
        for (key in m) {
          if (hasOwnProp(m, key) && !(indexOf.call(ordering, key) !== -1 && (m[key] == null || !isNaN(m[key])))) {
            return false;
          }
        }
        for (i = 0; i < ordering.length; ++i) {
          if (m[ordering[i]]) {
            if (unitHasDecimal) {
              return false;
            }
            if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
              unitHasDecimal = true;
            }
          }
        }
        return true;
      }
      function isValid$1() {
        return this._isValid;
      }
      function createInvalid$1() {
        return createDuration(NaN);
      }
      function Duration(duration) {
        var normalizedInput = normalizeObjectUnits(duration), years2 = normalizedInput.year || 0, quarters = normalizedInput.quarter || 0, months2 = normalizedInput.month || 0, weeks2 = normalizedInput.week || normalizedInput.isoWeek || 0, days2 = normalizedInput.day || 0, hours2 = normalizedInput.hour || 0, minutes2 = normalizedInput.minute || 0, seconds2 = normalizedInput.second || 0, milliseconds2 = normalizedInput.millisecond || 0;
        this._isValid = isDurationValid(normalizedInput);
        this._milliseconds = +milliseconds2 + seconds2 * 1e3 + // 1000
        minutes2 * 6e4 + // 1000 * 60
        hours2 * 1e3 * 60 * 60;
        this._days = +days2 + weeks2 * 7;
        this._months = +months2 + quarters * 3 + years2 * 12;
        this._data = {};
        this._locale = getLocale();
        this._bubble();
      }
      function isDuration(obj) {
        return obj instanceof Duration;
      }
      function absRound(number) {
        if (number < 0) {
          return Math.round(-1 * number) * -1;
        } else {
          return Math.round(number);
        }
      }
      function compareArrays(array1, array2, dontConvert) {
        var len = Math.min(array1.length, array2.length), lengthDiff = Math.abs(array1.length - array2.length), diffs = 0, i;
        for (i = 0; i < len; i++) {
          if (dontConvert && array1[i] !== array2[i] || !dontConvert && toInt(array1[i]) !== toInt(array2[i])) {
            diffs++;
          }
        }
        return diffs + lengthDiff;
      }
      function offset(token2, separator) {
        addFormatToken(token2, 0, 0, function() {
          var offset2 = this.utcOffset(), sign2 = "+";
          if (offset2 < 0) {
            offset2 = -offset2;
            sign2 = "-";
          }
          return sign2 + zeroFill(~~(offset2 / 60), 2) + separator + zeroFill(~~offset2 % 60, 2);
        });
      }
      offset("Z", ":");
      offset("ZZ", "");
      addRegexToken("Z", matchShortOffset);
      addRegexToken("ZZ", matchShortOffset);
      addParseToken(["Z", "ZZ"], function(input, array, config) {
        config._useUTC = true;
        config._tzm = offsetFromString(matchShortOffset, input);
      });
      var chunkOffset = /([\+\-]|\d\d)/gi;
      function offsetFromString(matcher, string2) {
        var matches = (string2 || "").match(matcher), chunk, parts, minutes2;
        if (matches === null) {
          return null;
        }
        chunk = matches[matches.length - 1] || [];
        parts = (chunk + "").match(chunkOffset) || ["-", 0, 0];
        minutes2 = +(parts[1] * 60) + toInt(parts[2]);
        return minutes2 === 0 ? 0 : parts[0] === "+" ? minutes2 : -minutes2;
      }
      function cloneWithOffset(input, model) {
        var res, diff2;
        if (model._isUTC) {
          res = model.clone();
          diff2 = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
          res._d.setTime(res._d.valueOf() + diff2);
          hooks.updateOffset(res, false);
          return res;
        } else {
          return createLocal(input).local();
        }
      }
      function getDateOffset(m) {
        return -Math.round(m._d.getTimezoneOffset());
      }
      hooks.updateOffset = function() {
      };
      function getSetOffset(input, keepLocalTime, keepMinutes) {
        var offset2 = this._offset || 0, localAdjust;
        if (!this.isValid()) {
          return input != null ? this : NaN;
        }
        if (input != null) {
          if (typeof input === "string") {
            input = offsetFromString(matchShortOffset, input);
            if (input === null) {
              return this;
            }
          } else if (Math.abs(input) < 16 && !keepMinutes) {
            input = input * 60;
          }
          if (!this._isUTC && keepLocalTime) {
            localAdjust = getDateOffset(this);
          }
          this._offset = input;
          this._isUTC = true;
          if (localAdjust != null) {
            this.add(localAdjust, "m");
          }
          if (offset2 !== input) {
            if (!keepLocalTime || this._changeInProgress) {
              addSubtract(
                this,
                createDuration(input - offset2, "m"),
                1,
                false
              );
            } else if (!this._changeInProgress) {
              this._changeInProgress = true;
              hooks.updateOffset(this, true);
              this._changeInProgress = null;
            }
          }
          return this;
        } else {
          return this._isUTC ? offset2 : getDateOffset(this);
        }
      }
      function getSetZone(input, keepLocalTime) {
        if (input != null) {
          if (typeof input !== "string") {
            input = -input;
          }
          this.utcOffset(input, keepLocalTime);
          return this;
        } else {
          return -this.utcOffset();
        }
      }
      function setOffsetToUTC(keepLocalTime) {
        return this.utcOffset(0, keepLocalTime);
      }
      function setOffsetToLocal(keepLocalTime) {
        if (this._isUTC) {
          this.utcOffset(0, keepLocalTime);
          this._isUTC = false;
          if (keepLocalTime) {
            this.subtract(getDateOffset(this), "m");
          }
        }
        return this;
      }
      function setOffsetToParsedOffset() {
        if (this._tzm != null) {
          this.utcOffset(this._tzm, false, true);
        } else if (typeof this._i === "string") {
          var tZone = offsetFromString(matchOffset, this._i);
          if (tZone != null) {
            this.utcOffset(tZone);
          } else {
            this.utcOffset(0, true);
          }
        }
        return this;
      }
      function hasAlignedHourOffset(input) {
        if (!this.isValid()) {
          return false;
        }
        input = input ? createLocal(input).utcOffset() : 0;
        return (this.utcOffset() - input) % 60 === 0;
      }
      function isDaylightSavingTime() {
        return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();
      }
      function isDaylightSavingTimeShifted() {
        if (!isUndefined(this._isDSTShifted)) {
          return this._isDSTShifted;
        }
        var c = {}, other;
        copyConfig(c, this);
        c = prepareConfig(c);
        if (c._a) {
          other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
          this._isDSTShifted = this.isValid() && compareArrays(c._a, other.toArray()) > 0;
        } else {
          this._isDSTShifted = false;
        }
        return this._isDSTShifted;
      }
      function isLocal() {
        return this.isValid() ? !this._isUTC : false;
      }
      function isUtcOffset() {
        return this.isValid() ? this._isUTC : false;
      }
      function isUtc() {
        return this.isValid() ? this._isUTC && this._offset === 0 : false;
      }
      var aspNetRegex = /^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)?)?$/, isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
      function createDuration(input, key) {
        var duration = input, match = null, sign2, ret, diffRes;
        if (isDuration(input)) {
          duration = {
            ms: input._milliseconds,
            d: input._days,
            M: input._months
          };
        } else if (isNumber(input) || !isNaN(+input)) {
          duration = {};
          if (key) {
            duration[key] = +input;
          } else {
            duration.milliseconds = +input;
          }
        } else if (match = aspNetRegex.exec(input)) {
          sign2 = match[1] === "-" ? -1 : 1;
          duration = {
            y: 0,
            d: toInt(match[DATE]) * sign2,
            h: toInt(match[HOUR]) * sign2,
            m: toInt(match[MINUTE]) * sign2,
            s: toInt(match[SECOND]) * sign2,
            ms: toInt(absRound(match[MILLISECOND] * 1e3)) * sign2
            // the millisecond decimal point is included in the match
          };
        } else if (match = isoRegex.exec(input)) {
          sign2 = match[1] === "-" ? -1 : 1;
          duration = {
            y: parseIso(match[2], sign2),
            M: parseIso(match[3], sign2),
            w: parseIso(match[4], sign2),
            d: parseIso(match[5], sign2),
            h: parseIso(match[6], sign2),
            m: parseIso(match[7], sign2),
            s: parseIso(match[8], sign2)
          };
        } else if (duration == null) {
          duration = {};
        } else if (typeof duration === "object" && ("from" in duration || "to" in duration)) {
          diffRes = momentsDifference(
            createLocal(duration.from),
            createLocal(duration.to)
          );
          duration = {};
          duration.ms = diffRes.milliseconds;
          duration.M = diffRes.months;
        }
        ret = new Duration(duration);
        if (isDuration(input) && hasOwnProp(input, "_locale")) {
          ret._locale = input._locale;
        }
        if (isDuration(input) && hasOwnProp(input, "_isValid")) {
          ret._isValid = input._isValid;
        }
        return ret;
      }
      createDuration.fn = Duration.prototype;
      createDuration.invalid = createInvalid$1;
      function parseIso(inp, sign2) {
        var res = inp && parseFloat(inp.replace(",", "."));
        return (isNaN(res) ? 0 : res) * sign2;
      }
      function positiveMomentsDifference(base, other) {
        var res = {};
        res.months = other.month() - base.month() + (other.year() - base.year()) * 12;
        if (base.clone().add(res.months, "M").isAfter(other)) {
          --res.months;
        }
        res.milliseconds = +other - +base.clone().add(res.months, "M");
        return res;
      }
      function momentsDifference(base, other) {
        var res;
        if (!(base.isValid() && other.isValid())) {
          return { milliseconds: 0, months: 0 };
        }
        other = cloneWithOffset(other, base);
        if (base.isBefore(other)) {
          res = positiveMomentsDifference(base, other);
        } else {
          res = positiveMomentsDifference(other, base);
          res.milliseconds = -res.milliseconds;
          res.months = -res.months;
        }
        return res;
      }
      function createAdder(direction, name) {
        return function(val, period) {
          var dur, tmp;
          if (period !== null && !isNaN(+period)) {
            deprecateSimple(
              name,
              "moment()." + name + "(period, number) is deprecated. Please use moment()." + name + "(number, period). See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info."
            );
            tmp = val;
            val = period;
            period = tmp;
          }
          dur = createDuration(val, period);
          addSubtract(this, dur, direction);
          return this;
        };
      }
      function addSubtract(mom, duration, isAdding, updateOffset) {
        var milliseconds2 = duration._milliseconds, days2 = absRound(duration._days), months2 = absRound(duration._months);
        if (!mom.isValid()) {
          return;
        }
        updateOffset = updateOffset == null ? true : updateOffset;
        if (months2) {
          setMonth(mom, get(mom, "Month") + months2 * isAdding);
        }
        if (days2) {
          set$1(mom, "Date", get(mom, "Date") + days2 * isAdding);
        }
        if (milliseconds2) {
          mom._d.setTime(mom._d.valueOf() + milliseconds2 * isAdding);
        }
        if (updateOffset) {
          hooks.updateOffset(mom, days2 || months2);
        }
      }
      var add = createAdder(1, "add"), subtract = createAdder(-1, "subtract");
      function isString(input) {
        return typeof input === "string" || input instanceof String;
      }
      function isMomentInput(input) {
        return isMoment(input) || isDate(input) || isString(input) || isNumber(input) || isNumberOrStringArray(input) || isMomentInputObject(input) || input === null || input === void 0;
      }
      function isMomentInputObject(input) {
        var objectTest = isObject(input) && !isObjectEmpty(input), propertyTest = false, properties = [
          "years",
          "year",
          "y",
          "months",
          "month",
          "M",
          "days",
          "day",
          "d",
          "dates",
          "date",
          "D",
          "hours",
          "hour",
          "h",
          "minutes",
          "minute",
          "m",
          "seconds",
          "second",
          "s",
          "milliseconds",
          "millisecond",
          "ms"
        ], i, property;
        for (i = 0; i < properties.length; i += 1) {
          property = properties[i];
          propertyTest = propertyTest || hasOwnProp(input, property);
        }
        return objectTest && propertyTest;
      }
      function isNumberOrStringArray(input) {
        var arrayTest = isArray(input), dataTypeTest = false;
        if (arrayTest) {
          dataTypeTest = input.filter(function(item) {
            return !isNumber(item) && isString(input);
          }).length === 0;
        }
        return arrayTest && dataTypeTest;
      }
      function isCalendarSpec(input) {
        var objectTest = isObject(input) && !isObjectEmpty(input), propertyTest = false, properties = [
          "sameDay",
          "nextDay",
          "lastDay",
          "nextWeek",
          "lastWeek",
          "sameElse"
        ], i, property;
        for (i = 0; i < properties.length; i += 1) {
          property = properties[i];
          propertyTest = propertyTest || hasOwnProp(input, property);
        }
        return objectTest && propertyTest;
      }
      function getCalendarFormat(myMoment, now2) {
        var diff2 = myMoment.diff(now2, "days", true);
        return diff2 < -6 ? "sameElse" : diff2 < -1 ? "lastWeek" : diff2 < 0 ? "lastDay" : diff2 < 1 ? "sameDay" : diff2 < 2 ? "nextDay" : diff2 < 7 ? "nextWeek" : "sameElse";
      }
      function calendar$1(time, formats) {
        if (arguments.length === 1) {
          if (!arguments[0]) {
            time = void 0;
            formats = void 0;
          } else if (isMomentInput(arguments[0])) {
            time = arguments[0];
            formats = void 0;
          } else if (isCalendarSpec(arguments[0])) {
            formats = arguments[0];
            time = void 0;
          }
        }
        var now2 = time || createLocal(), sod = cloneWithOffset(now2, this).startOf("day"), format2 = hooks.calendarFormat(this, sod) || "sameElse", output = formats && (isFunction(formats[format2]) ? formats[format2].call(this, now2) : formats[format2]);
        return this.format(
          output || this.localeData().calendar(format2, this, createLocal(now2))
        );
      }
      function clone() {
        return new Moment(this);
      }
      function isAfter(input, units) {
        var localInput = isMoment(input) ? input : createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
          return false;
        }
        units = normalizeUnits(units) || "millisecond";
        if (units === "millisecond") {
          return this.valueOf() > localInput.valueOf();
        } else {
          return localInput.valueOf() < this.clone().startOf(units).valueOf();
        }
      }
      function isBefore(input, units) {
        var localInput = isMoment(input) ? input : createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
          return false;
        }
        units = normalizeUnits(units) || "millisecond";
        if (units === "millisecond") {
          return this.valueOf() < localInput.valueOf();
        } else {
          return this.clone().endOf(units).valueOf() < localInput.valueOf();
        }
      }
      function isBetween(from2, to2, units, inclusivity) {
        var localFrom = isMoment(from2) ? from2 : createLocal(from2), localTo = isMoment(to2) ? to2 : createLocal(to2);
        if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
          return false;
        }
        inclusivity = inclusivity || "()";
        return (inclusivity[0] === "(" ? this.isAfter(localFrom, units) : !this.isBefore(localFrom, units)) && (inclusivity[1] === ")" ? this.isBefore(localTo, units) : !this.isAfter(localTo, units));
      }
      function isSame(input, units) {
        var localInput = isMoment(input) ? input : createLocal(input), inputMs;
        if (!(this.isValid() && localInput.isValid())) {
          return false;
        }
        units = normalizeUnits(units) || "millisecond";
        if (units === "millisecond") {
          return this.valueOf() === localInput.valueOf();
        } else {
          inputMs = localInput.valueOf();
          return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
        }
      }
      function isSameOrAfter(input, units) {
        return this.isSame(input, units) || this.isAfter(input, units);
      }
      function isSameOrBefore(input, units) {
        return this.isSame(input, units) || this.isBefore(input, units);
      }
      function diff(input, units, asFloat) {
        var that, zoneDelta, output;
        if (!this.isValid()) {
          return NaN;
        }
        that = cloneWithOffset(input, this);
        if (!that.isValid()) {
          return NaN;
        }
        zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;
        units = normalizeUnits(units);
        switch (units) {
          case "year":
            output = monthDiff(this, that) / 12;
            break;
          case "month":
            output = monthDiff(this, that);
            break;
          case "quarter":
            output = monthDiff(this, that) / 3;
            break;
          case "second":
            output = (this - that) / 1e3;
            break;
          case "minute":
            output = (this - that) / 6e4;
            break;
          case "hour":
            output = (this - that) / 36e5;
            break;
          case "day":
            output = (this - that - zoneDelta) / 864e5;
            break;
          case "week":
            output = (this - that - zoneDelta) / 6048e5;
            break;
          default:
            output = this - that;
        }
        return asFloat ? output : absFloor(output);
      }
      function monthDiff(a, b) {
        if (a.date() < b.date()) {
          return -monthDiff(b, a);
        }
        var wholeMonthDiff = (b.year() - a.year()) * 12 + (b.month() - a.month()), anchor = a.clone().add(wholeMonthDiff, "months"), anchor2, adjust;
        if (b - anchor < 0) {
          anchor2 = a.clone().add(wholeMonthDiff - 1, "months");
          adjust = (b - anchor) / (anchor - anchor2);
        } else {
          anchor2 = a.clone().add(wholeMonthDiff + 1, "months");
          adjust = (b - anchor) / (anchor2 - anchor);
        }
        return -(wholeMonthDiff + adjust) || 0;
      }
      hooks.defaultFormat = "YYYY-MM-DDTHH:mm:ssZ";
      hooks.defaultFormatUtc = "YYYY-MM-DDTHH:mm:ss[Z]";
      function toString() {
        return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
      }
      function toISOString(keepOffset) {
        if (!this.isValid()) {
          return null;
        }
        var utc = keepOffset !== true, m = utc ? this.clone().utc() : this;
        if (m.year() < 0 || m.year() > 9999) {
          return formatMoment(
            m,
            utc ? "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYYYY-MM-DD[T]HH:mm:ss.SSSZ"
          );
        }
        if (isFunction(Date.prototype.toISOString)) {
          if (utc) {
            return this.toDate().toISOString();
          } else {
            return new Date(this.valueOf() + this.utcOffset() * 60 * 1e3).toISOString().replace("Z", formatMoment(m, "Z"));
          }
        }
        return formatMoment(
          m,
          utc ? "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYY-MM-DD[T]HH:mm:ss.SSSZ"
        );
      }
      function inspect() {
        if (!this.isValid()) {
          return "moment.invalid(/* " + this._i + " */)";
        }
        var func = "moment", zone = "", prefix, year, datetime, suffix;
        if (!this.isLocal()) {
          func = this.utcOffset() === 0 ? "moment.utc" : "moment.parseZone";
          zone = "Z";
        }
        prefix = "[" + func + '("]';
        year = 0 <= this.year() && this.year() <= 9999 ? "YYYY" : "YYYYYY";
        datetime = "-MM-DD[T]HH:mm:ss.SSS";
        suffix = zone + '[")]';
        return this.format(prefix + year + datetime + suffix);
      }
      function format(inputString) {
        if (!inputString) {
          inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
        }
        var output = formatMoment(this, inputString);
        return this.localeData().postformat(output);
      }
      function from(time, withoutSuffix) {
        if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
          return createDuration({ to: this, from: time }).locale(this.locale()).humanize(!withoutSuffix);
        } else {
          return this.localeData().invalidDate();
        }
      }
      function fromNow(withoutSuffix) {
        return this.from(createLocal(), withoutSuffix);
      }
      function to(time, withoutSuffix) {
        if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
          return createDuration({ from: this, to: time }).locale(this.locale()).humanize(!withoutSuffix);
        } else {
          return this.localeData().invalidDate();
        }
      }
      function toNow(withoutSuffix) {
        return this.to(createLocal(), withoutSuffix);
      }
      function locale(key) {
        var newLocaleData;
        if (key === void 0) {
          return this._locale._abbr;
        } else {
          newLocaleData = getLocale(key);
          if (newLocaleData != null) {
            this._locale = newLocaleData;
          }
          return this;
        }
      }
      var lang = deprecate(
        "moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.",
        function(key) {
          if (key === void 0) {
            return this.localeData();
          } else {
            return this.locale(key);
          }
        }
      );
      function localeData() {
        return this._locale;
      }
      var MS_PER_SECOND = 1e3, MS_PER_MINUTE = 60 * MS_PER_SECOND, MS_PER_HOUR = 60 * MS_PER_MINUTE, MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;
      function mod$1(dividend, divisor) {
        return (dividend % divisor + divisor) % divisor;
      }
      function localStartOfDate(y, m, d) {
        if (y < 100 && y >= 0) {
          return new Date(y + 400, m, d) - MS_PER_400_YEARS;
        } else {
          return new Date(y, m, d).valueOf();
        }
      }
      function utcStartOfDate(y, m, d) {
        if (y < 100 && y >= 0) {
          return Date.UTC(y + 400, m, d) - MS_PER_400_YEARS;
        } else {
          return Date.UTC(y, m, d);
        }
      }
      function startOf(units) {
        var time, startOfDate;
        units = normalizeUnits(units);
        if (units === void 0 || units === "millisecond" || !this.isValid()) {
          return this;
        }
        startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
        switch (units) {
          case "year":
            time = startOfDate(this.year(), 0, 1);
            break;
          case "quarter":
            time = startOfDate(
              this.year(),
              this.month() - this.month() % 3,
              1
            );
            break;
          case "month":
            time = startOfDate(this.year(), this.month(), 1);
            break;
          case "week":
            time = startOfDate(
              this.year(),
              this.month(),
              this.date() - this.weekday()
            );
            break;
          case "isoWeek":
            time = startOfDate(
              this.year(),
              this.month(),
              this.date() - (this.isoWeekday() - 1)
            );
            break;
          case "day":
          case "date":
            time = startOfDate(this.year(), this.month(), this.date());
            break;
          case "hour":
            time = this._d.valueOf();
            time -= mod$1(
              time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
              MS_PER_HOUR
            );
            break;
          case "minute":
            time = this._d.valueOf();
            time -= mod$1(time, MS_PER_MINUTE);
            break;
          case "second":
            time = this._d.valueOf();
            time -= mod$1(time, MS_PER_SECOND);
            break;
        }
        this._d.setTime(time);
        hooks.updateOffset(this, true);
        return this;
      }
      function endOf(units) {
        var time, startOfDate;
        units = normalizeUnits(units);
        if (units === void 0 || units === "millisecond" || !this.isValid()) {
          return this;
        }
        startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
        switch (units) {
          case "year":
            time = startOfDate(this.year() + 1, 0, 1) - 1;
            break;
          case "quarter":
            time = startOfDate(
              this.year(),
              this.month() - this.month() % 3 + 3,
              1
            ) - 1;
            break;
          case "month":
            time = startOfDate(this.year(), this.month() + 1, 1) - 1;
            break;
          case "week":
            time = startOfDate(
              this.year(),
              this.month(),
              this.date() - this.weekday() + 7
            ) - 1;
            break;
          case "isoWeek":
            time = startOfDate(
              this.year(),
              this.month(),
              this.date() - (this.isoWeekday() - 1) + 7
            ) - 1;
            break;
          case "day":
          case "date":
            time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
            break;
          case "hour":
            time = this._d.valueOf();
            time += MS_PER_HOUR - mod$1(
              time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
              MS_PER_HOUR
            ) - 1;
            break;
          case "minute":
            time = this._d.valueOf();
            time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
            break;
          case "second":
            time = this._d.valueOf();
            time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
            break;
        }
        this._d.setTime(time);
        hooks.updateOffset(this, true);
        return this;
      }
      function valueOf() {
        return this._d.valueOf() - (this._offset || 0) * 6e4;
      }
      function unix() {
        return Math.floor(this.valueOf() / 1e3);
      }
      function toDate() {
        return new Date(this.valueOf());
      }
      function toArray() {
        var m = this;
        return [
          m.year(),
          m.month(),
          m.date(),
          m.hour(),
          m.minute(),
          m.second(),
          m.millisecond()
        ];
      }
      function toObject() {
        var m = this;
        return {
          years: m.year(),
          months: m.month(),
          date: m.date(),
          hours: m.hours(),
          minutes: m.minutes(),
          seconds: m.seconds(),
          milliseconds: m.milliseconds()
        };
      }
      function toJSON() {
        return this.isValid() ? this.toISOString() : null;
      }
      function isValid$2() {
        return isValid(this);
      }
      function parsingFlags() {
        return extend({}, getParsingFlags(this));
      }
      function invalidAt() {
        return getParsingFlags(this).overflow;
      }
      function creationData() {
        return {
          input: this._i,
          format: this._f,
          locale: this._locale,
          isUTC: this._isUTC,
          strict: this._strict
        };
      }
      addFormatToken("N", 0, 0, "eraAbbr");
      addFormatToken("NN", 0, 0, "eraAbbr");
      addFormatToken("NNN", 0, 0, "eraAbbr");
      addFormatToken("NNNN", 0, 0, "eraName");
      addFormatToken("NNNNN", 0, 0, "eraNarrow");
      addFormatToken("y", ["y", 1], "yo", "eraYear");
      addFormatToken("y", ["yy", 2], 0, "eraYear");
      addFormatToken("y", ["yyy", 3], 0, "eraYear");
      addFormatToken("y", ["yyyy", 4], 0, "eraYear");
      addRegexToken("N", matchEraAbbr);
      addRegexToken("NN", matchEraAbbr);
      addRegexToken("NNN", matchEraAbbr);
      addRegexToken("NNNN", matchEraName);
      addRegexToken("NNNNN", matchEraNarrow);
      addParseToken(["N", "NN", "NNN", "NNNN", "NNNNN"], function(input, array, config, token2) {
        var era = config._locale.erasParse(input, token2, config._strict);
        if (era) {
          getParsingFlags(config).era = era;
        } else {
          getParsingFlags(config).invalidEra = input;
        }
      });
      addRegexToken("y", matchUnsigned);
      addRegexToken("yy", matchUnsigned);
      addRegexToken("yyy", matchUnsigned);
      addRegexToken("yyyy", matchUnsigned);
      addRegexToken("yo", matchEraYearOrdinal);
      addParseToken(["y", "yy", "yyy", "yyyy"], YEAR);
      addParseToken(["yo"], function(input, array, config, token2) {
        var match;
        if (config._locale._eraYearOrdinalRegex) {
          match = input.match(config._locale._eraYearOrdinalRegex);
        }
        if (config._locale.eraYearOrdinalParse) {
          array[YEAR] = config._locale.eraYearOrdinalParse(input, match);
        } else {
          array[YEAR] = parseInt(input, 10);
        }
      });
      function localeEras(m, format2) {
        var i, l, date, eras = this._eras || getLocale("en")._eras;
        for (i = 0, l = eras.length; i < l; ++i) {
          switch (typeof eras[i].since) {
            case "string":
              date = hooks(eras[i].since).startOf("day");
              eras[i].since = date.valueOf();
              break;
          }
          switch (typeof eras[i].until) {
            case "undefined":
              eras[i].until = Infinity;
              break;
            case "string":
              date = hooks(eras[i].until).startOf("day").valueOf();
              eras[i].until = date.valueOf();
              break;
          }
        }
        return eras;
      }
      function localeErasParse(eraName, format2, strict) {
        var i, l, eras = this.eras(), name, abbr, narrow;
        eraName = eraName.toUpperCase();
        for (i = 0, l = eras.length; i < l; ++i) {
          name = eras[i].name.toUpperCase();
          abbr = eras[i].abbr.toUpperCase();
          narrow = eras[i].narrow.toUpperCase();
          if (strict) {
            switch (format2) {
              case "N":
              case "NN":
              case "NNN":
                if (abbr === eraName) {
                  return eras[i];
                }
                break;
              case "NNNN":
                if (name === eraName) {
                  return eras[i];
                }
                break;
              case "NNNNN":
                if (narrow === eraName) {
                  return eras[i];
                }
                break;
            }
          } else if ([name, abbr, narrow].indexOf(eraName) >= 0) {
            return eras[i];
          }
        }
      }
      function localeErasConvertYear(era, year) {
        var dir = era.since <= era.until ? 1 : -1;
        if (year === void 0) {
          return hooks(era.since).year();
        } else {
          return hooks(era.since).year() + (year - era.offset) * dir;
        }
      }
      function getEraName() {
        var i, l, val, eras = this.localeData().eras();
        for (i = 0, l = eras.length; i < l; ++i) {
          val = this.clone().startOf("day").valueOf();
          if (eras[i].since <= val && val <= eras[i].until) {
            return eras[i].name;
          }
          if (eras[i].until <= val && val <= eras[i].since) {
            return eras[i].name;
          }
        }
        return "";
      }
      function getEraNarrow() {
        var i, l, val, eras = this.localeData().eras();
        for (i = 0, l = eras.length; i < l; ++i) {
          val = this.clone().startOf("day").valueOf();
          if (eras[i].since <= val && val <= eras[i].until) {
            return eras[i].narrow;
          }
          if (eras[i].until <= val && val <= eras[i].since) {
            return eras[i].narrow;
          }
        }
        return "";
      }
      function getEraAbbr() {
        var i, l, val, eras = this.localeData().eras();
        for (i = 0, l = eras.length; i < l; ++i) {
          val = this.clone().startOf("day").valueOf();
          if (eras[i].since <= val && val <= eras[i].until) {
            return eras[i].abbr;
          }
          if (eras[i].until <= val && val <= eras[i].since) {
            return eras[i].abbr;
          }
        }
        return "";
      }
      function getEraYear() {
        var i, l, dir, val, eras = this.localeData().eras();
        for (i = 0, l = eras.length; i < l; ++i) {
          dir = eras[i].since <= eras[i].until ? 1 : -1;
          val = this.clone().startOf("day").valueOf();
          if (eras[i].since <= val && val <= eras[i].until || eras[i].until <= val && val <= eras[i].since) {
            return (this.year() - hooks(eras[i].since).year()) * dir + eras[i].offset;
          }
        }
        return this.year();
      }
      function erasNameRegex(isStrict) {
        if (!hasOwnProp(this, "_erasNameRegex")) {
          computeErasParse.call(this);
        }
        return isStrict ? this._erasNameRegex : this._erasRegex;
      }
      function erasAbbrRegex(isStrict) {
        if (!hasOwnProp(this, "_erasAbbrRegex")) {
          computeErasParse.call(this);
        }
        return isStrict ? this._erasAbbrRegex : this._erasRegex;
      }
      function erasNarrowRegex(isStrict) {
        if (!hasOwnProp(this, "_erasNarrowRegex")) {
          computeErasParse.call(this);
        }
        return isStrict ? this._erasNarrowRegex : this._erasRegex;
      }
      function matchEraAbbr(isStrict, locale2) {
        return locale2.erasAbbrRegex(isStrict);
      }
      function matchEraName(isStrict, locale2) {
        return locale2.erasNameRegex(isStrict);
      }
      function matchEraNarrow(isStrict, locale2) {
        return locale2.erasNarrowRegex(isStrict);
      }
      function matchEraYearOrdinal(isStrict, locale2) {
        return locale2._eraYearOrdinalRegex || matchUnsigned;
      }
      function computeErasParse() {
        var abbrPieces = [], namePieces = [], narrowPieces = [], mixedPieces = [], i, l, eras = this.eras();
        for (i = 0, l = eras.length; i < l; ++i) {
          namePieces.push(regexEscape(eras[i].name));
          abbrPieces.push(regexEscape(eras[i].abbr));
          narrowPieces.push(regexEscape(eras[i].narrow));
          mixedPieces.push(regexEscape(eras[i].name));
          mixedPieces.push(regexEscape(eras[i].abbr));
          mixedPieces.push(regexEscape(eras[i].narrow));
        }
        this._erasRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
        this._erasNameRegex = new RegExp("^(" + namePieces.join("|") + ")", "i");
        this._erasAbbrRegex = new RegExp("^(" + abbrPieces.join("|") + ")", "i");
        this._erasNarrowRegex = new RegExp(
          "^(" + narrowPieces.join("|") + ")",
          "i"
        );
      }
      addFormatToken(0, ["gg", 2], 0, function() {
        return this.weekYear() % 100;
      });
      addFormatToken(0, ["GG", 2], 0, function() {
        return this.isoWeekYear() % 100;
      });
      function addWeekYearFormatToken(token2, getter) {
        addFormatToken(0, [token2, token2.length], 0, getter);
      }
      addWeekYearFormatToken("gggg", "weekYear");
      addWeekYearFormatToken("ggggg", "weekYear");
      addWeekYearFormatToken("GGGG", "isoWeekYear");
      addWeekYearFormatToken("GGGGG", "isoWeekYear");
      addUnitAlias("weekYear", "gg");
      addUnitAlias("isoWeekYear", "GG");
      addUnitPriority("weekYear", 1);
      addUnitPriority("isoWeekYear", 1);
      addRegexToken("G", matchSigned);
      addRegexToken("g", matchSigned);
      addRegexToken("GG", match1to2, match2);
      addRegexToken("gg", match1to2, match2);
      addRegexToken("GGGG", match1to4, match4);
      addRegexToken("gggg", match1to4, match4);
      addRegexToken("GGGGG", match1to6, match6);
      addRegexToken("ggggg", match1to6, match6);
      addWeekParseToken(["gggg", "ggggg", "GGGG", "GGGGG"], function(input, week, config, token2) {
        week[token2.substr(0, 2)] = toInt(input);
      });
      addWeekParseToken(["gg", "GG"], function(input, week, config, token2) {
        week[token2] = hooks.parseTwoDigitYear(input);
      });
      function getSetWeekYear(input) {
        return getSetWeekYearHelper.call(
          this,
          input,
          this.week(),
          this.weekday(),
          this.localeData()._week.dow,
          this.localeData()._week.doy
        );
      }
      function getSetISOWeekYear(input) {
        return getSetWeekYearHelper.call(
          this,
          input,
          this.isoWeek(),
          this.isoWeekday(),
          1,
          4
        );
      }
      function getISOWeeksInYear() {
        return weeksInYear(this.year(), 1, 4);
      }
      function getISOWeeksInISOWeekYear() {
        return weeksInYear(this.isoWeekYear(), 1, 4);
      }
      function getWeeksInYear() {
        var weekInfo = this.localeData()._week;
        return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
      }
      function getWeeksInWeekYear() {
        var weekInfo = this.localeData()._week;
        return weeksInYear(this.weekYear(), weekInfo.dow, weekInfo.doy);
      }
      function getSetWeekYearHelper(input, week, weekday, dow, doy) {
        var weeksTarget;
        if (input == null) {
          return weekOfYear(this, dow, doy).year;
        } else {
          weeksTarget = weeksInYear(input, dow, doy);
          if (week > weeksTarget) {
            week = weeksTarget;
          }
          return setWeekAll.call(this, input, week, weekday, dow, doy);
        }
      }
      function setWeekAll(weekYear, week, weekday, dow, doy) {
        var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy), date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);
        this.year(date.getUTCFullYear());
        this.month(date.getUTCMonth());
        this.date(date.getUTCDate());
        return this;
      }
      addFormatToken("Q", 0, "Qo", "quarter");
      addUnitAlias("quarter", "Q");
      addUnitPriority("quarter", 7);
      addRegexToken("Q", match1);
      addParseToken("Q", function(input, array) {
        array[MONTH] = (toInt(input) - 1) * 3;
      });
      function getSetQuarter(input) {
        return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
      }
      addFormatToken("D", ["DD", 2], "Do", "date");
      addUnitAlias("date", "D");
      addUnitPriority("date", 9);
      addRegexToken("D", match1to2);
      addRegexToken("DD", match1to2, match2);
      addRegexToken("Do", function(isStrict, locale2) {
        return isStrict ? locale2._dayOfMonthOrdinalParse || locale2._ordinalParse : locale2._dayOfMonthOrdinalParseLenient;
      });
      addParseToken(["D", "DD"], DATE);
      addParseToken("Do", function(input, array) {
        array[DATE] = toInt(input.match(match1to2)[0]);
      });
      var getSetDayOfMonth = makeGetSet("Date", true);
      addFormatToken("DDD", ["DDDD", 3], "DDDo", "dayOfYear");
      addUnitAlias("dayOfYear", "DDD");
      addUnitPriority("dayOfYear", 4);
      addRegexToken("DDD", match1to3);
      addRegexToken("DDDD", match3);
      addParseToken(["DDD", "DDDD"], function(input, array, config) {
        config._dayOfYear = toInt(input);
      });
      function getSetDayOfYear(input) {
        var dayOfYear = Math.round(
          (this.clone().startOf("day") - this.clone().startOf("year")) / 864e5
        ) + 1;
        return input == null ? dayOfYear : this.add(input - dayOfYear, "d");
      }
      addFormatToken("m", ["mm", 2], 0, "minute");
      addUnitAlias("minute", "m");
      addUnitPriority("minute", 14);
      addRegexToken("m", match1to2);
      addRegexToken("mm", match1to2, match2);
      addParseToken(["m", "mm"], MINUTE);
      var getSetMinute = makeGetSet("Minutes", false);
      addFormatToken("s", ["ss", 2], 0, "second");
      addUnitAlias("second", "s");
      addUnitPriority("second", 15);
      addRegexToken("s", match1to2);
      addRegexToken("ss", match1to2, match2);
      addParseToken(["s", "ss"], SECOND);
      var getSetSecond = makeGetSet("Seconds", false);
      addFormatToken("S", 0, 0, function() {
        return ~~(this.millisecond() / 100);
      });
      addFormatToken(0, ["SS", 2], 0, function() {
        return ~~(this.millisecond() / 10);
      });
      addFormatToken(0, ["SSS", 3], 0, "millisecond");
      addFormatToken(0, ["SSSS", 4], 0, function() {
        return this.millisecond() * 10;
      });
      addFormatToken(0, ["SSSSS", 5], 0, function() {
        return this.millisecond() * 100;
      });
      addFormatToken(0, ["SSSSSS", 6], 0, function() {
        return this.millisecond() * 1e3;
      });
      addFormatToken(0, ["SSSSSSS", 7], 0, function() {
        return this.millisecond() * 1e4;
      });
      addFormatToken(0, ["SSSSSSSS", 8], 0, function() {
        return this.millisecond() * 1e5;
      });
      addFormatToken(0, ["SSSSSSSSS", 9], 0, function() {
        return this.millisecond() * 1e6;
      });
      addUnitAlias("millisecond", "ms");
      addUnitPriority("millisecond", 16);
      addRegexToken("S", match1to3, match1);
      addRegexToken("SS", match1to3, match2);
      addRegexToken("SSS", match1to3, match3);
      var token, getSetMillisecond;
      for (token = "SSSS"; token.length <= 9; token += "S") {
        addRegexToken(token, matchUnsigned);
      }
      function parseMs(input, array) {
        array[MILLISECOND] = toInt(("0." + input) * 1e3);
      }
      for (token = "S"; token.length <= 9; token += "S") {
        addParseToken(token, parseMs);
      }
      getSetMillisecond = makeGetSet("Milliseconds", false);
      addFormatToken("z", 0, 0, "zoneAbbr");
      addFormatToken("zz", 0, 0, "zoneName");
      function getZoneAbbr() {
        return this._isUTC ? "UTC" : "";
      }
      function getZoneName() {
        return this._isUTC ? "Coordinated Universal Time" : "";
      }
      var proto = Moment.prototype;
      proto.add = add;
      proto.calendar = calendar$1;
      proto.clone = clone;
      proto.diff = diff;
      proto.endOf = endOf;
      proto.format = format;
      proto.from = from;
      proto.fromNow = fromNow;
      proto.to = to;
      proto.toNow = toNow;
      proto.get = stringGet;
      proto.invalidAt = invalidAt;
      proto.isAfter = isAfter;
      proto.isBefore = isBefore;
      proto.isBetween = isBetween;
      proto.isSame = isSame;
      proto.isSameOrAfter = isSameOrAfter;
      proto.isSameOrBefore = isSameOrBefore;
      proto.isValid = isValid$2;
      proto.lang = lang;
      proto.locale = locale;
      proto.localeData = localeData;
      proto.max = prototypeMax;
      proto.min = prototypeMin;
      proto.parsingFlags = parsingFlags;
      proto.set = stringSet;
      proto.startOf = startOf;
      proto.subtract = subtract;
      proto.toArray = toArray;
      proto.toObject = toObject;
      proto.toDate = toDate;
      proto.toISOString = toISOString;
      proto.inspect = inspect;
      if (typeof Symbol !== "undefined" && Symbol.for != null) {
        proto[Symbol.for("nodejs.util.inspect.custom")] = function() {
          return "Moment<" + this.format() + ">";
        };
      }
      proto.toJSON = toJSON;
      proto.toString = toString;
      proto.unix = unix;
      proto.valueOf = valueOf;
      proto.creationData = creationData;
      proto.eraName = getEraName;
      proto.eraNarrow = getEraNarrow;
      proto.eraAbbr = getEraAbbr;
      proto.eraYear = getEraYear;
      proto.year = getSetYear;
      proto.isLeapYear = getIsLeapYear;
      proto.weekYear = getSetWeekYear;
      proto.isoWeekYear = getSetISOWeekYear;
      proto.quarter = proto.quarters = getSetQuarter;
      proto.month = getSetMonth;
      proto.daysInMonth = getDaysInMonth;
      proto.week = proto.weeks = getSetWeek;
      proto.isoWeek = proto.isoWeeks = getSetISOWeek;
      proto.weeksInYear = getWeeksInYear;
      proto.weeksInWeekYear = getWeeksInWeekYear;
      proto.isoWeeksInYear = getISOWeeksInYear;
      proto.isoWeeksInISOWeekYear = getISOWeeksInISOWeekYear;
      proto.date = getSetDayOfMonth;
      proto.day = proto.days = getSetDayOfWeek;
      proto.weekday = getSetLocaleDayOfWeek;
      proto.isoWeekday = getSetISODayOfWeek;
      proto.dayOfYear = getSetDayOfYear;
      proto.hour = proto.hours = getSetHour;
      proto.minute = proto.minutes = getSetMinute;
      proto.second = proto.seconds = getSetSecond;
      proto.millisecond = proto.milliseconds = getSetMillisecond;
      proto.utcOffset = getSetOffset;
      proto.utc = setOffsetToUTC;
      proto.local = setOffsetToLocal;
      proto.parseZone = setOffsetToParsedOffset;
      proto.hasAlignedHourOffset = hasAlignedHourOffset;
      proto.isDST = isDaylightSavingTime;
      proto.isLocal = isLocal;
      proto.isUtcOffset = isUtcOffset;
      proto.isUtc = isUtc;
      proto.isUTC = isUtc;
      proto.zoneAbbr = getZoneAbbr;
      proto.zoneName = getZoneName;
      proto.dates = deprecate(
        "dates accessor is deprecated. Use date instead.",
        getSetDayOfMonth
      );
      proto.months = deprecate(
        "months accessor is deprecated. Use month instead",
        getSetMonth
      );
      proto.years = deprecate(
        "years accessor is deprecated. Use year instead",
        getSetYear
      );
      proto.zone = deprecate(
        "moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/",
        getSetZone
      );
      proto.isDSTShifted = deprecate(
        "isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information",
        isDaylightSavingTimeShifted
      );
      function createUnix(input) {
        return createLocal(input * 1e3);
      }
      function createInZone() {
        return createLocal.apply(null, arguments).parseZone();
      }
      function preParsePostFormat(string2) {
        return string2;
      }
      var proto$1 = Locale.prototype;
      proto$1.calendar = calendar;
      proto$1.longDateFormat = longDateFormat;
      proto$1.invalidDate = invalidDate;
      proto$1.ordinal = ordinal;
      proto$1.preparse = preParsePostFormat;
      proto$1.postformat = preParsePostFormat;
      proto$1.relativeTime = relativeTime;
      proto$1.pastFuture = pastFuture;
      proto$1.set = set2;
      proto$1.eras = localeEras;
      proto$1.erasParse = localeErasParse;
      proto$1.erasConvertYear = localeErasConvertYear;
      proto$1.erasAbbrRegex = erasAbbrRegex;
      proto$1.erasNameRegex = erasNameRegex;
      proto$1.erasNarrowRegex = erasNarrowRegex;
      proto$1.months = localeMonths;
      proto$1.monthsShort = localeMonthsShort;
      proto$1.monthsParse = localeMonthsParse;
      proto$1.monthsRegex = monthsRegex;
      proto$1.monthsShortRegex = monthsShortRegex;
      proto$1.week = localeWeek;
      proto$1.firstDayOfYear = localeFirstDayOfYear;
      proto$1.firstDayOfWeek = localeFirstDayOfWeek;
      proto$1.weekdays = localeWeekdays;
      proto$1.weekdaysMin = localeWeekdaysMin;
      proto$1.weekdaysShort = localeWeekdaysShort;
      proto$1.weekdaysParse = localeWeekdaysParse;
      proto$1.weekdaysRegex = weekdaysRegex;
      proto$1.weekdaysShortRegex = weekdaysShortRegex;
      proto$1.weekdaysMinRegex = weekdaysMinRegex;
      proto$1.isPM = localeIsPM;
      proto$1.meridiem = localeMeridiem;
      function get$1(format2, index, field, setter) {
        var locale2 = getLocale(), utc = createUTC().set(setter, index);
        return locale2[field](utc, format2);
      }
      function listMonthsImpl(format2, index, field) {
        if (isNumber(format2)) {
          index = format2;
          format2 = void 0;
        }
        format2 = format2 || "";
        if (index != null) {
          return get$1(format2, index, field, "month");
        }
        var i, out = [];
        for (i = 0; i < 12; i++) {
          out[i] = get$1(format2, i, field, "month");
        }
        return out;
      }
      function listWeekdaysImpl(localeSorted, format2, index, field) {
        if (typeof localeSorted === "boolean") {
          if (isNumber(format2)) {
            index = format2;
            format2 = void 0;
          }
          format2 = format2 || "";
        } else {
          format2 = localeSorted;
          index = format2;
          localeSorted = false;
          if (isNumber(format2)) {
            index = format2;
            format2 = void 0;
          }
          format2 = format2 || "";
        }
        var locale2 = getLocale(), shift = localeSorted ? locale2._week.dow : 0, i, out = [];
        if (index != null) {
          return get$1(format2, (index + shift) % 7, field, "day");
        }
        for (i = 0; i < 7; i++) {
          out[i] = get$1(format2, (i + shift) % 7, field, "day");
        }
        return out;
      }
      function listMonths(format2, index) {
        return listMonthsImpl(format2, index, "months");
      }
      function listMonthsShort(format2, index) {
        return listMonthsImpl(format2, index, "monthsShort");
      }
      function listWeekdays(localeSorted, format2, index) {
        return listWeekdaysImpl(localeSorted, format2, index, "weekdays");
      }
      function listWeekdaysShort(localeSorted, format2, index) {
        return listWeekdaysImpl(localeSorted, format2, index, "weekdaysShort");
      }
      function listWeekdaysMin(localeSorted, format2, index) {
        return listWeekdaysImpl(localeSorted, format2, index, "weekdaysMin");
      }
      getSetGlobalLocale("en", {
        eras: [
          {
            since: "0001-01-01",
            until: Infinity,
            offset: 1,
            name: "Anno Domini",
            narrow: "AD",
            abbr: "AD"
          },
          {
            since: "0000-12-31",
            until: -Infinity,
            offset: 1,
            name: "Before Christ",
            narrow: "BC",
            abbr: "BC"
          }
        ],
        dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
        ordinal: function(number) {
          var b = number % 10, output = toInt(number % 100 / 10) === 1 ? "th" : b === 1 ? "st" : b === 2 ? "nd" : b === 3 ? "rd" : "th";
          return number + output;
        }
      });
      hooks.lang = deprecate(
        "moment.lang is deprecated. Use moment.locale instead.",
        getSetGlobalLocale
      );
      hooks.langData = deprecate(
        "moment.langData is deprecated. Use moment.localeData instead.",
        getLocale
      );
      var mathAbs = Math.abs;
      function abs() {
        var data = this._data;
        this._milliseconds = mathAbs(this._milliseconds);
        this._days = mathAbs(this._days);
        this._months = mathAbs(this._months);
        data.milliseconds = mathAbs(data.milliseconds);
        data.seconds = mathAbs(data.seconds);
        data.minutes = mathAbs(data.minutes);
        data.hours = mathAbs(data.hours);
        data.months = mathAbs(data.months);
        data.years = mathAbs(data.years);
        return this;
      }
      function addSubtract$1(duration, input, value, direction) {
        var other = createDuration(input, value);
        duration._milliseconds += direction * other._milliseconds;
        duration._days += direction * other._days;
        duration._months += direction * other._months;
        return duration._bubble();
      }
      function add$1(input, value) {
        return addSubtract$1(this, input, value, 1);
      }
      function subtract$1(input, value) {
        return addSubtract$1(this, input, value, -1);
      }
      function absCeil(number) {
        if (number < 0) {
          return Math.floor(number);
        } else {
          return Math.ceil(number);
        }
      }
      function bubble() {
        var milliseconds2 = this._milliseconds, days2 = this._days, months2 = this._months, data = this._data, seconds2, minutes2, hours2, years2, monthsFromDays;
        if (!(milliseconds2 >= 0 && days2 >= 0 && months2 >= 0 || milliseconds2 <= 0 && days2 <= 0 && months2 <= 0)) {
          milliseconds2 += absCeil(monthsToDays(months2) + days2) * 864e5;
          days2 = 0;
          months2 = 0;
        }
        data.milliseconds = milliseconds2 % 1e3;
        seconds2 = absFloor(milliseconds2 / 1e3);
        data.seconds = seconds2 % 60;
        minutes2 = absFloor(seconds2 / 60);
        data.minutes = minutes2 % 60;
        hours2 = absFloor(minutes2 / 60);
        data.hours = hours2 % 24;
        days2 += absFloor(hours2 / 24);
        monthsFromDays = absFloor(daysToMonths(days2));
        months2 += monthsFromDays;
        days2 -= absCeil(monthsToDays(monthsFromDays));
        years2 = absFloor(months2 / 12);
        months2 %= 12;
        data.days = days2;
        data.months = months2;
        data.years = years2;
        return this;
      }
      function daysToMonths(days2) {
        return days2 * 4800 / 146097;
      }
      function monthsToDays(months2) {
        return months2 * 146097 / 4800;
      }
      function as(units) {
        if (!this.isValid()) {
          return NaN;
        }
        var days2, months2, milliseconds2 = this._milliseconds;
        units = normalizeUnits(units);
        if (units === "month" || units === "quarter" || units === "year") {
          days2 = this._days + milliseconds2 / 864e5;
          months2 = this._months + daysToMonths(days2);
          switch (units) {
            case "month":
              return months2;
            case "quarter":
              return months2 / 3;
            case "year":
              return months2 / 12;
          }
        } else {
          days2 = this._days + Math.round(monthsToDays(this._months));
          switch (units) {
            case "week":
              return days2 / 7 + milliseconds2 / 6048e5;
            case "day":
              return days2 + milliseconds2 / 864e5;
            case "hour":
              return days2 * 24 + milliseconds2 / 36e5;
            case "minute":
              return days2 * 1440 + milliseconds2 / 6e4;
            case "second":
              return days2 * 86400 + milliseconds2 / 1e3;
            case "millisecond":
              return Math.floor(days2 * 864e5) + milliseconds2;
            default:
              throw new Error("Unknown unit " + units);
          }
        }
      }
      function valueOf$1() {
        if (!this.isValid()) {
          return NaN;
        }
        return this._milliseconds + this._days * 864e5 + this._months % 12 * 2592e6 + toInt(this._months / 12) * 31536e6;
      }
      function makeAs(alias) {
        return function() {
          return this.as(alias);
        };
      }
      var asMilliseconds = makeAs("ms"), asSeconds = makeAs("s"), asMinutes = makeAs("m"), asHours = makeAs("h"), asDays = makeAs("d"), asWeeks = makeAs("w"), asMonths = makeAs("M"), asQuarters = makeAs("Q"), asYears = makeAs("y");
      function clone$1() {
        return createDuration(this);
      }
      function get$2(units) {
        units = normalizeUnits(units);
        return this.isValid() ? this[units + "s"]() : NaN;
      }
      function makeGetter(name) {
        return function() {
          return this.isValid() ? this._data[name] : NaN;
        };
      }
      var milliseconds = makeGetter("milliseconds"), seconds = makeGetter("seconds"), minutes = makeGetter("minutes"), hours = makeGetter("hours"), days = makeGetter("days"), months = makeGetter("months"), years = makeGetter("years");
      function weeks() {
        return absFloor(this.days() / 7);
      }
      var round = Math.round, thresholds = {
        ss: 44,
        // a few seconds to seconds
        s: 45,
        // seconds to minute
        m: 45,
        // minutes to hour
        h: 22,
        // hours to day
        d: 26,
        // days to month/week
        w: null,
        // weeks to month
        M: 11
        // months to year
      };
      function substituteTimeAgo(string2, number, withoutSuffix, isFuture, locale2) {
        return locale2.relativeTime(number || 1, !!withoutSuffix, string2, isFuture);
      }
      function relativeTime$1(posNegDuration, withoutSuffix, thresholds2, locale2) {
        var duration = createDuration(posNegDuration).abs(), seconds2 = round(duration.as("s")), minutes2 = round(duration.as("m")), hours2 = round(duration.as("h")), days2 = round(duration.as("d")), months2 = round(duration.as("M")), weeks2 = round(duration.as("w")), years2 = round(duration.as("y")), a = seconds2 <= thresholds2.ss && ["s", seconds2] || seconds2 < thresholds2.s && ["ss", seconds2] || minutes2 <= 1 && ["m"] || minutes2 < thresholds2.m && ["mm", minutes2] || hours2 <= 1 && ["h"] || hours2 < thresholds2.h && ["hh", hours2] || days2 <= 1 && ["d"] || days2 < thresholds2.d && ["dd", days2];
        if (thresholds2.w != null) {
          a = a || weeks2 <= 1 && ["w"] || weeks2 < thresholds2.w && ["ww", weeks2];
        }
        a = a || months2 <= 1 && ["M"] || months2 < thresholds2.M && ["MM", months2] || years2 <= 1 && ["y"] || ["yy", years2];
        a[2] = withoutSuffix;
        a[3] = +posNegDuration > 0;
        a[4] = locale2;
        return substituteTimeAgo.apply(null, a);
      }
      function getSetRelativeTimeRounding(roundingFunction) {
        if (roundingFunction === void 0) {
          return round;
        }
        if (typeof roundingFunction === "function") {
          round = roundingFunction;
          return true;
        }
        return false;
      }
      function getSetRelativeTimeThreshold(threshold, limit) {
        if (thresholds[threshold] === void 0) {
          return false;
        }
        if (limit === void 0) {
          return thresholds[threshold];
        }
        thresholds[threshold] = limit;
        if (threshold === "s") {
          thresholds.ss = limit - 1;
        }
        return true;
      }
      function humanize(argWithSuffix, argThresholds) {
        if (!this.isValid()) {
          return this.localeData().invalidDate();
        }
        var withSuffix = false, th = thresholds, locale2, output;
        if (typeof argWithSuffix === "object") {
          argThresholds = argWithSuffix;
          argWithSuffix = false;
        }
        if (typeof argWithSuffix === "boolean") {
          withSuffix = argWithSuffix;
        }
        if (typeof argThresholds === "object") {
          th = Object.assign({}, thresholds, argThresholds);
          if (argThresholds.s != null && argThresholds.ss == null) {
            th.ss = argThresholds.s - 1;
          }
        }
        locale2 = this.localeData();
        output = relativeTime$1(this, !withSuffix, th, locale2);
        if (withSuffix) {
          output = locale2.pastFuture(+this, output);
        }
        return locale2.postformat(output);
      }
      var abs$1 = Math.abs;
      function sign(x) {
        return (x > 0) - (x < 0) || +x;
      }
      function toISOString$1() {
        if (!this.isValid()) {
          return this.localeData().invalidDate();
        }
        var seconds2 = abs$1(this._milliseconds) / 1e3, days2 = abs$1(this._days), months2 = abs$1(this._months), minutes2, hours2, years2, s, total = this.asSeconds(), totalSign, ymSign, daysSign, hmsSign;
        if (!total) {
          return "P0D";
        }
        minutes2 = absFloor(seconds2 / 60);
        hours2 = absFloor(minutes2 / 60);
        seconds2 %= 60;
        minutes2 %= 60;
        years2 = absFloor(months2 / 12);
        months2 %= 12;
        s = seconds2 ? seconds2.toFixed(3).replace(/\.?0+$/, "") : "";
        totalSign = total < 0 ? "-" : "";
        ymSign = sign(this._months) !== sign(total) ? "-" : "";
        daysSign = sign(this._days) !== sign(total) ? "-" : "";
        hmsSign = sign(this._milliseconds) !== sign(total) ? "-" : "";
        return totalSign + "P" + (years2 ? ymSign + years2 + "Y" : "") + (months2 ? ymSign + months2 + "M" : "") + (days2 ? daysSign + days2 + "D" : "") + (hours2 || minutes2 || seconds2 ? "T" : "") + (hours2 ? hmsSign + hours2 + "H" : "") + (minutes2 ? hmsSign + minutes2 + "M" : "") + (seconds2 ? hmsSign + s + "S" : "");
      }
      var proto$2 = Duration.prototype;
      proto$2.isValid = isValid$1;
      proto$2.abs = abs;
      proto$2.add = add$1;
      proto$2.subtract = subtract$1;
      proto$2.as = as;
      proto$2.asMilliseconds = asMilliseconds;
      proto$2.asSeconds = asSeconds;
      proto$2.asMinutes = asMinutes;
      proto$2.asHours = asHours;
      proto$2.asDays = asDays;
      proto$2.asWeeks = asWeeks;
      proto$2.asMonths = asMonths;
      proto$2.asQuarters = asQuarters;
      proto$2.asYears = asYears;
      proto$2.valueOf = valueOf$1;
      proto$2._bubble = bubble;
      proto$2.clone = clone$1;
      proto$2.get = get$2;
      proto$2.milliseconds = milliseconds;
      proto$2.seconds = seconds;
      proto$2.minutes = minutes;
      proto$2.hours = hours;
      proto$2.days = days;
      proto$2.weeks = weeks;
      proto$2.months = months;
      proto$2.years = years;
      proto$2.humanize = humanize;
      proto$2.toISOString = toISOString$1;
      proto$2.toString = toISOString$1;
      proto$2.toJSON = toISOString$1;
      proto$2.locale = locale;
      proto$2.localeData = localeData;
      proto$2.toIsoString = deprecate(
        "toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)",
        toISOString$1
      );
      proto$2.lang = lang;
      addFormatToken("X", 0, 0, "unix");
      addFormatToken("x", 0, 0, "valueOf");
      addRegexToken("x", matchSigned);
      addRegexToken("X", matchTimestamp);
      addParseToken("X", function(input, array, config) {
        config._d = new Date(parseFloat(input) * 1e3);
      });
      addParseToken("x", function(input, array, config) {
        config._d = new Date(toInt(input));
      });
      hooks.version = "2.29.1";
      setHookCallback(createLocal);
      hooks.fn = proto;
      hooks.min = min;
      hooks.max = max;
      hooks.now = now;
      hooks.utc = createUTC;
      hooks.unix = createUnix;
      hooks.months = listMonths;
      hooks.isDate = isDate;
      hooks.locale = getSetGlobalLocale;
      hooks.invalid = createInvalid;
      hooks.duration = createDuration;
      hooks.isMoment = isMoment;
      hooks.weekdays = listWeekdays;
      hooks.parseZone = createInZone;
      hooks.localeData = getLocale;
      hooks.isDuration = isDuration;
      hooks.monthsShort = listMonthsShort;
      hooks.weekdaysMin = listWeekdaysMin;
      hooks.defineLocale = defineLocale;
      hooks.updateLocale = updateLocale;
      hooks.locales = listLocales;
      hooks.weekdaysShort = listWeekdaysShort;
      hooks.normalizeUnits = normalizeUnits;
      hooks.relativeTimeRounding = getSetRelativeTimeRounding;
      hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
      hooks.calendarFormat = getCalendarFormat;
      hooks.prototype = proto;
      hooks.HTML5_FMT = {
        DATETIME_LOCAL: "YYYY-MM-DDTHH:mm",
        // <input type="datetime-local" />
        DATETIME_LOCAL_SECONDS: "YYYY-MM-DDTHH:mm:ss",
        // <input type="datetime-local" step="1" />
        DATETIME_LOCAL_MS: "YYYY-MM-DDTHH:mm:ss.SSS",
        // <input type="datetime-local" step="0.001" />
        DATE: "YYYY-MM-DD",
        // <input type="date" />
        TIME: "HH:mm",
        // <input type="time" />
        TIME_SECONDS: "HH:mm:ss",
        // <input type="time" step="1" />
        TIME_MS: "HH:mm:ss.SSS",
        // <input type="time" step="0.001" />
        WEEK: "GGGG-[W]WW",
        // <input type="week" />
        MONTH: "YYYY-MM"
        // <input type="month" />
      };
      return hooks;
    });
  }
});

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => MyPlugin
});
module.exports = __toCommonJS(main_exports);

// updateNoteTypeModal.ts
var import_obsidian3 = require("obsidian");

// tagrenamer/renaming.ts
var import_obsidian2 = require("obsidian");

// tagrenamer/Tag.ts
var tagBody = /^#[^\u2000-\u206F\u2E00-\u2E7F'!"#$%&()*+,.:;<=>?@^`{|}~\[\]\\\s]+$/;
var Tag = class {
  constructor(name) {
    const hashed = this.tag = Tag.toTag(name), canonical = this.canonical = hashed.toLowerCase(), canonical_prefix = this.canonical_prefix = canonical + "/";
    this.name = hashed.slice(1);
    this.matches = function(text) {
      text = text.toLowerCase();
      return text == canonical || text.startsWith(canonical_prefix);
    };
  }
  toString() {
    return this.tag;
  }
  static isTag(s) {
    return tagBody.test(s);
  }
  static toTag(name) {
    while (name.startsWith("##"))
      name = name.slice(1);
    return name.startsWith("#") ? name : "#" + name;
  }
  static canonical(name) {
    return Tag.toTag(name).toLowerCase();
  }
};
var Replacement = class {
  constructor(fromTag, toTag) {
    const cache = Object.assign(
      /* @__PURE__ */ Object.create(null),
      {
        [fromTag.tag]: toTag.tag,
        [fromTag.name]: toTag.name
      }
    );
    this.inString = function(text, pos = 0) {
      return text.slice(0, pos) + toTag.tag + text.slice(pos + fromTag.tag.length);
    };
    this.inArray = (tags, skipOdd, isAlias2) => {
      return tags.map((t, i) => {
        if (skipOdd && i & 1)
          return t;
        if (!t)
          return t;
        if (isAlias2) {
          if (!t.startsWith("#") || !Tag.isTag(t))
            return t;
        } else if (/[ ,\n]/.test(t)) {
          return this.inArray(t.split(/([, \n]+)/), true, isAlias2).join("");
        }
        if (cache[t])
          return cache[t];
        const lc = t.toLowerCase();
        if (cache[lc]) {
          return cache[t] = cache[lc];
        } else if (lc.startsWith(fromTag.canonical_prefix)) {
          return cache[t] = cache[lc] = this.inString(t);
        } else if (("#" + lc).startsWith(fromTag.canonical_prefix)) {
          return cache[t] = cache[lc] = this.inString("#" + t).slice(1);
        }
        return cache[t] = cache[lc] = t;
      });
    };
    this.willMergeTags = function(tagNames) {
      if (fromTag.canonical === toTag.canonical)
        return;
      const existing = new Set(tagNames.map((s) => s.toLowerCase()));
      for (const tagName of tagNames.filter(fromTag.matches)) {
        const changed = this.inString(tagName);
        if (existing.has(changed.toLowerCase()))
          return [new Tag(tagName), new Tag(changed)];
      }
    };
  }
};

// tagrenamer/File.ts
var import_obsidian = require("obsidian");

// node_modules/yaml/browser/dist/nodes/Node.js
var ALIAS = Symbol.for("yaml.alias");
var DOC = Symbol.for("yaml.document");
var MAP = Symbol.for("yaml.map");
var PAIR = Symbol.for("yaml.pair");
var SCALAR = Symbol.for("yaml.scalar");
var SEQ = Symbol.for("yaml.seq");
var NODE_TYPE = Symbol.for("yaml.node.type");
var isAlias = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === ALIAS;
var isDocument = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === DOC;
var isMap = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === MAP;
var isPair = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === PAIR;
var isScalar = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === SCALAR;
var isSeq = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === SEQ;
function isCollection(node) {
  if (node && typeof node === "object")
    switch (node[NODE_TYPE]) {
      case MAP:
      case SEQ:
        return true;
    }
  return false;
}
function isNode(node) {
  if (node && typeof node === "object")
    switch (node[NODE_TYPE]) {
      case ALIAS:
      case MAP:
      case SCALAR:
      case SEQ:
        return true;
    }
  return false;
}
var hasAnchor = (node) => (isScalar(node) || isCollection(node)) && !!node.anchor;
var NodeBase = class {
  constructor(type) {
    Object.defineProperty(this, NODE_TYPE, { value: type });
  }
  /** Create a copy of this node.  */
  clone() {
    const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
    if (this.range)
      copy.range = this.range.slice();
    return copy;
  }
};

// node_modules/yaml/browser/dist/visit.js
var BREAK = Symbol("break visit");
var SKIP = Symbol("skip children");
var REMOVE = Symbol("remove node");
function visit(node, visitor) {
  if (typeof visitor === "object" && (visitor.Collection || visitor.Node || visitor.Value)) {
    visitor = Object.assign({
      Alias: visitor.Node,
      Map: visitor.Node,
      Scalar: visitor.Node,
      Seq: visitor.Node
    }, visitor.Value && {
      Map: visitor.Value,
      Scalar: visitor.Value,
      Seq: visitor.Value
    }, visitor.Collection && {
      Map: visitor.Collection,
      Seq: visitor.Collection
    }, visitor);
  }
  if (isDocument(node)) {
    const cd = _visit(null, node.contents, visitor, Object.freeze([node]));
    if (cd === REMOVE)
      node.contents = null;
  } else
    _visit(null, node, visitor, Object.freeze([]));
}
visit.BREAK = BREAK;
visit.SKIP = SKIP;
visit.REMOVE = REMOVE;
function _visit(key, node, visitor, path) {
  let ctrl = void 0;
  if (typeof visitor === "function")
    ctrl = visitor(key, node, path);
  else if (isMap(node)) {
    if (visitor.Map)
      ctrl = visitor.Map(key, node, path);
  } else if (isSeq(node)) {
    if (visitor.Seq)
      ctrl = visitor.Seq(key, node, path);
  } else if (isPair(node)) {
    if (visitor.Pair)
      ctrl = visitor.Pair(key, node, path);
  } else if (isScalar(node)) {
    if (visitor.Scalar)
      ctrl = visitor.Scalar(key, node, path);
  } else if (isAlias(node)) {
    if (visitor.Alias)
      ctrl = visitor.Alias(key, node, path);
  }
  if (isNode(ctrl) || isPair(ctrl)) {
    const parent = path[path.length - 1];
    if (isCollection(parent)) {
      parent.items[key] = ctrl;
    } else if (isPair(parent)) {
      if (key === "key")
        parent.key = ctrl;
      else
        parent.value = ctrl;
    } else if (isDocument(parent)) {
      parent.contents = ctrl;
    } else {
      const pt = isAlias(parent) ? "alias" : "scalar";
      throw new Error(`Cannot replace node with ${pt} parent`);
    }
    return _visit(key, ctrl, visitor, path);
  }
  if (typeof ctrl !== "symbol") {
    if (isCollection(node)) {
      path = Object.freeze(path.concat(node));
      for (let i = 0; i < node.items.length; ++i) {
        const ci = _visit(i, node.items[i], visitor, path);
        if (typeof ci === "number")
          i = ci - 1;
        else if (ci === BREAK)
          return BREAK;
        else if (ci === REMOVE) {
          node.items.splice(i, 1);
          i -= 1;
        }
      }
    } else if (isPair(node)) {
      path = Object.freeze(path.concat(node));
      const ck = _visit("key", node.key, visitor, path);
      if (ck === BREAK)
        return BREAK;
      else if (ck === REMOVE)
        node.key = null;
      const cv = _visit("value", node.value, visitor, path);
      if (cv === BREAK)
        return BREAK;
      else if (cv === REMOVE)
        node.value = null;
    }
  }
  return ctrl;
}

// node_modules/yaml/browser/dist/doc/directives.js
var escapeChars = {
  "!": "%21",
  ",": "%2C",
  "[": "%5B",
  "]": "%5D",
  "{": "%7B",
  "}": "%7D"
};
var escapeTagName = (tn) => tn.replace(/[!,[\]{}]/g, (ch) => escapeChars[ch]);
var Directives = class {
  constructor(yaml, tags) {
    this.marker = null;
    this.yaml = Object.assign({}, Directives.defaultYaml, yaml);
    this.tags = Object.assign({}, Directives.defaultTags, tags);
  }
  clone() {
    const copy = new Directives(this.yaml, this.tags);
    copy.marker = this.marker;
    return copy;
  }
  /**
   * During parsing, get a Directives instance for the current document and
   * update the stream state according to the current version's spec.
   */
  atDocument() {
    const res = new Directives(this.yaml, this.tags);
    switch (this.yaml.version) {
      case "1.1":
        this.atNextDocument = true;
        break;
      case "1.2":
        this.atNextDocument = false;
        this.yaml = {
          explicit: Directives.defaultYaml.explicit,
          version: "1.2"
        };
        this.tags = Object.assign({}, Directives.defaultTags);
        break;
    }
    return res;
  }
  /**
   * @param onError - May be called even if the action was successful
   * @returns `true` on success
   */
  add(line, onError) {
    if (this.atNextDocument) {
      this.yaml = { explicit: Directives.defaultYaml.explicit, version: "1.1" };
      this.tags = Object.assign({}, Directives.defaultTags);
      this.atNextDocument = false;
    }
    const parts = line.trim().split(/[ \t]+/);
    const name = parts.shift();
    switch (name) {
      case "%TAG": {
        if (parts.length !== 2) {
          onError(0, "%TAG directive should contain exactly two parts");
          if (parts.length < 2)
            return false;
        }
        const [handle, prefix] = parts;
        this.tags[handle] = prefix;
        return true;
      }
      case "%YAML": {
        this.yaml.explicit = true;
        if (parts.length < 1) {
          onError(0, "%YAML directive should contain exactly one part");
          return false;
        }
        const [version] = parts;
        if (version === "1.1" || version === "1.2") {
          this.yaml.version = version;
          return true;
        } else {
          onError(6, `Unsupported YAML version ${version}`, true);
          return false;
        }
      }
      default:
        onError(0, `Unknown directive ${name}`, true);
        return false;
    }
  }
  /**
   * Resolves a tag, matching handles to those defined in %TAG directives.
   *
   * @returns Resolved tag, which may also be the non-specific tag `'!'` or a
   *   `'!local'` tag, or `null` if unresolvable.
   */
  tagName(source, onError) {
    if (source === "!")
      return "!";
    if (source[0] !== "!") {
      onError(`Not a valid tag: ${source}`);
      return null;
    }
    if (source[1] === "<") {
      const verbatim = source.slice(2, -1);
      if (verbatim === "!" || verbatim === "!!") {
        onError(`Verbatim tags aren't resolved, so ${source} is invalid.`);
        return null;
      }
      if (source[source.length - 1] !== ">")
        onError("Verbatim tags must end with a >");
      return verbatim;
    }
    const [, handle, suffix] = source.match(/^(.*!)([^!]*)$/);
    if (!suffix)
      onError(`The ${source} tag has no suffix`);
    const prefix = this.tags[handle];
    if (prefix)
      return prefix + decodeURIComponent(suffix);
    if (handle === "!")
      return source;
    onError(`Could not resolve tag: ${source}`);
    return null;
  }
  /**
   * Given a fully resolved tag, returns its printable string form,
   * taking into account current tag prefixes and defaults.
   */
  tagString(tag2) {
    for (const [handle, prefix] of Object.entries(this.tags)) {
      if (tag2.startsWith(prefix))
        return handle + escapeTagName(tag2.substring(prefix.length));
    }
    return tag2[0] === "!" ? tag2 : `!<${tag2}>`;
  }
  toString(doc) {
    const lines = this.yaml.explicit ? [`%YAML ${this.yaml.version || "1.2"}`] : [];
    const tagEntries = Object.entries(this.tags);
    let tagNames;
    if (doc && tagEntries.length > 0 && isNode(doc.contents)) {
      const tags = {};
      visit(doc.contents, (_key, node) => {
        if (isNode(node) && node.tag)
          tags[node.tag] = true;
      });
      tagNames = Object.keys(tags);
    } else
      tagNames = [];
    for (const [handle, prefix] of tagEntries) {
      if (handle === "!!" && prefix === "tag:yaml.org,2002:")
        continue;
      if (!doc || tagNames.some((tn) => tn.startsWith(prefix)))
        lines.push(`%TAG ${handle} ${prefix}`);
    }
    return lines.join("\n");
  }
};
Directives.defaultYaml = { explicit: false, version: "1.2" };
Directives.defaultTags = { "!!": "tag:yaml.org,2002:" };

// node_modules/yaml/browser/dist/doc/anchors.js
function anchorIsValid(anchor) {
  if (/[\x00-\x19\s,[\]{}]/.test(anchor)) {
    const sa = JSON.stringify(anchor);
    const msg = `Anchor must not contain whitespace or control characters: ${sa}`;
    throw new Error(msg);
  }
  return true;
}
function anchorNames(root) {
  const anchors = /* @__PURE__ */ new Set();
  visit(root, {
    Value(_key, node) {
      if (node.anchor)
        anchors.add(node.anchor);
    }
  });
  return anchors;
}
function findNewAnchor(prefix, exclude) {
  for (let i = 1; true; ++i) {
    const name = `${prefix}${i}`;
    if (!exclude.has(name))
      return name;
  }
}
function createNodeAnchors(doc, prefix) {
  const aliasObjects = [];
  const sourceObjects = /* @__PURE__ */ new Map();
  let prevAnchors = null;
  return {
    onAnchor(source) {
      aliasObjects.push(source);
      if (!prevAnchors)
        prevAnchors = anchorNames(doc);
      const anchor = findNewAnchor(prefix, prevAnchors);
      prevAnchors.add(anchor);
      return anchor;
    },
    /**
     * With circular references, the source node is only resolved after all
     * of its child nodes are. This is why anchors are set only after all of
     * the nodes have been created.
     */
    setAnchors() {
      for (const source of aliasObjects) {
        const ref = sourceObjects.get(source);
        if (typeof ref === "object" && ref.anchor && (isScalar(ref.node) || isCollection(ref.node))) {
          ref.node.anchor = ref.anchor;
        } else {
          const error = new Error("Failed to resolve repeated object (this should not happen)");
          error.source = source;
          throw error;
        }
      }
    },
    sourceObjects
  };
}

// node_modules/yaml/browser/dist/nodes/Alias.js
var Alias = class extends NodeBase {
  constructor(source) {
    super(ALIAS);
    this.source = source;
    Object.defineProperty(this, "tag", {
      set() {
        throw new Error("Alias nodes cannot have tags");
      }
    });
  }
  /**
   * Resolve the value of this alias within `doc`, finding the last
   * instance of the `source` anchor before this node.
   */
  resolve(doc) {
    let found = void 0;
    visit(doc, {
      Node: (_key, node) => {
        if (node === this)
          return visit.BREAK;
        if (node.anchor === this.source)
          found = node;
      }
    });
    return found;
  }
  toJSON(_arg, ctx) {
    if (!ctx)
      return { source: this.source };
    const { anchors, doc, maxAliasCount } = ctx;
    const source = this.resolve(doc);
    if (!source) {
      const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
      throw new ReferenceError(msg);
    }
    const data = anchors.get(source);
    if (!data || data.res === void 0) {
      const msg = "This should not happen: Alias anchor was not resolved?";
      throw new ReferenceError(msg);
    }
    if (maxAliasCount >= 0) {
      data.count += 1;
      if (data.aliasCount === 0)
        data.aliasCount = getAliasCount(doc, source, anchors);
      if (data.count * data.aliasCount > maxAliasCount) {
        const msg = "Excessive alias count indicates a resource exhaustion attack";
        throw new ReferenceError(msg);
      }
    }
    return data.res;
  }
  toString(ctx, _onComment, _onChompKeep) {
    const src = `*${this.source}`;
    if (ctx) {
      anchorIsValid(this.source);
      if (ctx.options.verifyAliasOrder && !ctx.anchors.has(this.source)) {
        const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
        throw new Error(msg);
      }
      if (ctx.implicitKey)
        return `${src} `;
    }
    return src;
  }
};
function getAliasCount(doc, node, anchors) {
  if (isAlias(node)) {
    const source = node.resolve(doc);
    const anchor = anchors && source && anchors.get(source);
    return anchor ? anchor.count * anchor.aliasCount : 0;
  } else if (isCollection(node)) {
    let count = 0;
    for (const item of node.items) {
      const c = getAliasCount(doc, item, anchors);
      if (c > count)
        count = c;
    }
    return count;
  } else if (isPair(node)) {
    const kc = getAliasCount(doc, node.key, anchors);
    const vc = getAliasCount(doc, node.value, anchors);
    return Math.max(kc, vc);
  }
  return 1;
}

// node_modules/yaml/browser/dist/nodes/toJS.js
function toJS(value, arg, ctx) {
  if (Array.isArray(value))
    return value.map((v, i) => toJS(v, String(i), ctx));
  if (value && typeof value.toJSON === "function") {
    if (!ctx || !hasAnchor(value))
      return value.toJSON(arg, ctx);
    const data = { aliasCount: 0, count: 1, res: void 0 };
    ctx.anchors.set(value, data);
    ctx.onCreate = (res2) => {
      data.res = res2;
      delete ctx.onCreate;
    };
    const res = value.toJSON(arg, ctx);
    if (ctx.onCreate)
      ctx.onCreate(res);
    return res;
  }
  if (typeof value === "bigint" && !(ctx && ctx.keep))
    return Number(value);
  return value;
}

// node_modules/yaml/browser/dist/nodes/Scalar.js
var isScalarValue = (value) => !value || typeof value !== "function" && typeof value !== "object";
var Scalar = class extends NodeBase {
  constructor(value) {
    super(SCALAR);
    this.value = value;
  }
  toJSON(arg, ctx) {
    return ctx && ctx.keep ? this.value : toJS(this.value, arg, ctx);
  }
  toString() {
    return String(this.value);
  }
};
Scalar.BLOCK_FOLDED = "BLOCK_FOLDED";
Scalar.BLOCK_LITERAL = "BLOCK_LITERAL";
Scalar.PLAIN = "PLAIN";
Scalar.QUOTE_DOUBLE = "QUOTE_DOUBLE";
Scalar.QUOTE_SINGLE = "QUOTE_SINGLE";

// node_modules/yaml/browser/dist/doc/createNode.js
var defaultTagPrefix = "tag:yaml.org,2002:";
function findTagObject(value, tagName, tags) {
  if (tagName) {
    const match = tags.filter((t) => t.tag === tagName);
    const tagObj = match.find((t) => !t.format) || match[0];
    if (!tagObj)
      throw new Error(`Tag ${tagName} not found`);
    return tagObj;
  }
  return tags.find((t) => t.identify && t.identify(value) && !t.format);
}
function createNode(value, tagName, ctx) {
  var _a, _b;
  if (isDocument(value))
    value = value.contents;
  if (isNode(value))
    return value;
  if (isPair(value)) {
    const map2 = (_b = (_a = ctx.schema[MAP]).createNode) === null || _b === void 0 ? void 0 : _b.call(_a, ctx.schema, null, ctx);
    map2.items.push(value);
    return map2;
  }
  if (value instanceof String || value instanceof Number || value instanceof Boolean || typeof BigInt === "function" && value instanceof BigInt) {
    value = value.valueOf();
  }
  const { aliasDuplicateObjects, onAnchor, onTagObj, schema: schema4, sourceObjects } = ctx;
  let ref = void 0;
  if (aliasDuplicateObjects && value && typeof value === "object") {
    ref = sourceObjects.get(value);
    if (ref) {
      if (!ref.anchor)
        ref.anchor = onAnchor(value);
      return new Alias(ref.anchor);
    } else {
      ref = { anchor: null, node: null };
      sourceObjects.set(value, ref);
    }
  }
  if (tagName && tagName.startsWith("!!"))
    tagName = defaultTagPrefix + tagName.slice(2);
  let tagObj = findTagObject(value, tagName, schema4.tags);
  if (!tagObj) {
    if (value && typeof value.toJSON === "function")
      value = value.toJSON();
    if (!value || typeof value !== "object") {
      const node2 = new Scalar(value);
      if (ref)
        ref.node = node2;
      return node2;
    }
    tagObj = value instanceof Map ? schema4[MAP] : Symbol.iterator in Object(value) ? schema4[SEQ] : schema4[MAP];
  }
  if (onTagObj) {
    onTagObj(tagObj);
    delete ctx.onTagObj;
  }
  const node = (tagObj === null || tagObj === void 0 ? void 0 : tagObj.createNode) ? tagObj.createNode(ctx.schema, value, ctx) : new Scalar(value);
  if (tagName)
    node.tag = tagName;
  if (ref)
    ref.node = node;
  return node;
}

// node_modules/yaml/browser/dist/nodes/Collection.js
function collectionFromPath(schema4, path, value) {
  let v = value;
  for (let i = path.length - 1; i >= 0; --i) {
    const k = path[i];
    if (typeof k === "number" && Number.isInteger(k) && k >= 0) {
      const a = [];
      a[k] = v;
      v = a;
    } else {
      v = /* @__PURE__ */ new Map([[k, v]]);
    }
  }
  return createNode(v, void 0, {
    aliasDuplicateObjects: false,
    keepUndefined: false,
    onAnchor: () => {
      throw new Error("This should not happen, please report a bug.");
    },
    schema: schema4,
    sourceObjects: /* @__PURE__ */ new Map()
  });
}
var isEmptyPath = (path) => path == null || typeof path === "object" && !!path[Symbol.iterator]().next().done;
var Collection = class extends NodeBase {
  constructor(type, schema4) {
    super(type);
    Object.defineProperty(this, "schema", {
      value: schema4,
      configurable: true,
      enumerable: false,
      writable: true
    });
  }
  /**
   * Create a copy of this collection.
   *
   * @param schema - If defined, overwrites the original's schema
   */
  clone(schema4) {
    const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
    if (schema4)
      copy.schema = schema4;
    copy.items = copy.items.map((it) => isNode(it) || isPair(it) ? it.clone(schema4) : it);
    if (this.range)
      copy.range = this.range.slice();
    return copy;
  }
  /**
   * Adds a value to the collection. For `!!map` and `!!omap` the value must
   * be a Pair instance or a `{ key, value }` object, which may not have a key
   * that already exists in the map.
   */
  addIn(path, value) {
    if (isEmptyPath(path))
      this.add(value);
    else {
      const [key, ...rest] = path;
      const node = this.get(key, true);
      if (isCollection(node))
        node.addIn(rest, value);
      else if (node === void 0 && this.schema)
        this.set(key, collectionFromPath(this.schema, rest, value));
      else
        throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
    }
  }
  /**
   * Removes a value from the collection.
   * @returns `true` if the item was found and removed.
   */
  deleteIn(path) {
    const [key, ...rest] = path;
    if (rest.length === 0)
      return this.delete(key);
    const node = this.get(key, true);
    if (isCollection(node))
      return node.deleteIn(rest);
    else
      throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
  }
  /**
   * Returns item at `key`, or `undefined` if not found. By default unwraps
   * scalar values from their surrounding node; to disable set `keepScalar` to
   * `true` (collections are always returned intact).
   */
  getIn(path, keepScalar) {
    const [key, ...rest] = path;
    const node = this.get(key, true);
    if (rest.length === 0)
      return !keepScalar && isScalar(node) ? node.value : node;
    else
      return isCollection(node) ? node.getIn(rest, keepScalar) : void 0;
  }
  hasAllNullValues(allowScalar) {
    return this.items.every((node) => {
      if (!isPair(node))
        return false;
      const n = node.value;
      return n == null || allowScalar && isScalar(n) && n.value == null && !n.commentBefore && !n.comment && !n.tag;
    });
  }
  /**
   * Checks if the collection includes a value with the key `key`.
   */
  hasIn(path) {
    const [key, ...rest] = path;
    if (rest.length === 0)
      return this.has(key);
    const node = this.get(key, true);
    return isCollection(node) ? node.hasIn(rest) : false;
  }
  /**
   * Sets a value in this collection. For `!!set`, `value` needs to be a
   * boolean to add/remove the item from the set.
   */
  setIn(path, value) {
    const [key, ...rest] = path;
    if (rest.length === 0) {
      this.set(key, value);
    } else {
      const node = this.get(key, true);
      if (isCollection(node))
        node.setIn(rest, value);
      else if (node === void 0 && this.schema)
        this.set(key, collectionFromPath(this.schema, rest, value));
      else
        throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
    }
  }
};
Collection.maxFlowStringSingleLineLength = 60;

// node_modules/yaml/browser/dist/stringify/stringifyComment.js
var stringifyComment = (str) => str.replace(/^(?!$)(?: $)?/gm, "#");
function indentComment(comment, indent) {
  if (/^\n+$/.test(comment))
    return comment.substring(1);
  return indent ? comment.replace(/^(?! *$)/gm, indent) : comment;
}
var lineComment = (str, indent, comment) => comment.includes("\n") ? "\n" + indentComment(comment, indent) : (str.endsWith(" ") ? "" : " ") + comment;

// node_modules/yaml/browser/dist/stringify/foldFlowLines.js
var FOLD_FLOW = "flow";
var FOLD_BLOCK = "block";
var FOLD_QUOTED = "quoted";
function foldFlowLines(text, indent, mode = "flow", { indentAtStart, lineWidth = 80, minContentWidth = 20, onFold, onOverflow } = {}) {
  if (!lineWidth || lineWidth < 0)
    return text;
  const endStep = Math.max(1 + minContentWidth, 1 + lineWidth - indent.length);
  if (text.length <= endStep)
    return text;
  const folds = [];
  const escapedFolds = {};
  let end = lineWidth - indent.length;
  if (typeof indentAtStart === "number") {
    if (indentAtStart > lineWidth - Math.max(2, minContentWidth))
      folds.push(0);
    else
      end = lineWidth - indentAtStart;
  }
  let split = void 0;
  let prev = void 0;
  let overflow = false;
  let i = -1;
  let escStart = -1;
  let escEnd = -1;
  if (mode === FOLD_BLOCK) {
    i = consumeMoreIndentedLines(text, i);
    if (i !== -1)
      end = i + endStep;
  }
  for (let ch; ch = text[i += 1]; ) {
    if (mode === FOLD_QUOTED && ch === "\\") {
      escStart = i;
      switch (text[i + 1]) {
        case "x":
          i += 3;
          break;
        case "u":
          i += 5;
          break;
        case "U":
          i += 9;
          break;
        default:
          i += 1;
      }
      escEnd = i;
    }
    if (ch === "\n") {
      if (mode === FOLD_BLOCK)
        i = consumeMoreIndentedLines(text, i);
      end = i + endStep;
      split = void 0;
    } else {
      if (ch === " " && prev && prev !== " " && prev !== "\n" && prev !== "	") {
        const next = text[i + 1];
        if (next && next !== " " && next !== "\n" && next !== "	")
          split = i;
      }
      if (i >= end) {
        if (split) {
          folds.push(split);
          end = split + endStep;
          split = void 0;
        } else if (mode === FOLD_QUOTED) {
          while (prev === " " || prev === "	") {
            prev = ch;
            ch = text[i += 1];
            overflow = true;
          }
          const j = i > escEnd + 1 ? i - 2 : escStart - 1;
          if (escapedFolds[j])
            return text;
          folds.push(j);
          escapedFolds[j] = true;
          end = j + endStep;
          split = void 0;
        } else {
          overflow = true;
        }
      }
    }
    prev = ch;
  }
  if (overflow && onOverflow)
    onOverflow();
  if (folds.length === 0)
    return text;
  if (onFold)
    onFold();
  let res = text.slice(0, folds[0]);
  for (let i2 = 0; i2 < folds.length; ++i2) {
    const fold = folds[i2];
    const end2 = folds[i2 + 1] || text.length;
    if (fold === 0)
      res = `
${indent}${text.slice(0, end2)}`;
    else {
      if (mode === FOLD_QUOTED && escapedFolds[fold])
        res += `${text[fold]}\\`;
      res += `
${indent}${text.slice(fold + 1, end2)}`;
    }
  }
  return res;
}
function consumeMoreIndentedLines(text, i) {
  let ch = text[i + 1];
  while (ch === " " || ch === "	") {
    do {
      ch = text[i += 1];
    } while (ch && ch !== "\n");
    ch = text[i + 1];
  }
  return i;
}

// node_modules/yaml/browser/dist/stringify/stringifyString.js
var getFoldOptions = (ctx) => ({
  indentAtStart: ctx.indentAtStart,
  lineWidth: ctx.options.lineWidth,
  minContentWidth: ctx.options.minContentWidth
});
var containsDocumentMarker = (str) => /^(%|---|\.\.\.)/m.test(str);
function lineLengthOverLimit(str, lineWidth, indentLength) {
  if (!lineWidth || lineWidth < 0)
    return false;
  const limit = lineWidth - indentLength;
  const strLen = str.length;
  if (strLen <= limit)
    return false;
  for (let i = 0, start = 0; i < strLen; ++i) {
    if (str[i] === "\n") {
      if (i - start > limit)
        return true;
      start = i + 1;
      if (strLen - start <= limit)
        return false;
    }
  }
  return true;
}
function doubleQuotedString(value, ctx) {
  const json = JSON.stringify(value);
  if (ctx.options.doubleQuotedAsJSON)
    return json;
  const { implicitKey } = ctx;
  const minMultiLineLength = ctx.options.doubleQuotedMinMultiLineLength;
  const indent = ctx.indent || (containsDocumentMarker(value) ? "  " : "");
  let str = "";
  let start = 0;
  for (let i = 0, ch = json[i]; ch; ch = json[++i]) {
    if (ch === " " && json[i + 1] === "\\" && json[i + 2] === "n") {
      str += json.slice(start, i) + "\\ ";
      i += 1;
      start = i;
      ch = "\\";
    }
    if (ch === "\\")
      switch (json[i + 1]) {
        case "u":
          {
            str += json.slice(start, i);
            const code = json.substr(i + 2, 4);
            switch (code) {
              case "0000":
                str += "\\0";
                break;
              case "0007":
                str += "\\a";
                break;
              case "000b":
                str += "\\v";
                break;
              case "001b":
                str += "\\e";
                break;
              case "0085":
                str += "\\N";
                break;
              case "00a0":
                str += "\\_";
                break;
              case "2028":
                str += "\\L";
                break;
              case "2029":
                str += "\\P";
                break;
              default:
                if (code.substr(0, 2) === "00")
                  str += "\\x" + code.substr(2);
                else
                  str += json.substr(i, 6);
            }
            i += 5;
            start = i + 1;
          }
          break;
        case "n":
          if (implicitKey || json[i + 2] === '"' || json.length < minMultiLineLength) {
            i += 1;
          } else {
            str += json.slice(start, i) + "\n\n";
            while (json[i + 2] === "\\" && json[i + 3] === "n" && json[i + 4] !== '"') {
              str += "\n";
              i += 2;
            }
            str += indent;
            if (json[i + 2] === " ")
              str += "\\";
            i += 1;
            start = i + 1;
          }
          break;
        default:
          i += 1;
      }
  }
  str = start ? str + json.slice(start) : json;
  return implicitKey ? str : foldFlowLines(str, indent, FOLD_QUOTED, getFoldOptions(ctx));
}
function singleQuotedString(value, ctx) {
  if (ctx.options.singleQuote === false || ctx.implicitKey && value.includes("\n") || /[ \t]\n|\n[ \t]/.test(value))
    return doubleQuotedString(value, ctx);
  const indent = ctx.indent || (containsDocumentMarker(value) ? "  " : "");
  const res = "'" + value.replace(/'/g, "''").replace(/\n+/g, `$&
${indent}`) + "'";
  return ctx.implicitKey ? res : foldFlowLines(res, indent, FOLD_FLOW, getFoldOptions(ctx));
}
function quotedString(value, ctx) {
  const { singleQuote } = ctx.options;
  let qs;
  if (singleQuote === false)
    qs = doubleQuotedString;
  else {
    const hasDouble = value.includes('"');
    const hasSingle = value.includes("'");
    if (hasDouble && !hasSingle)
      qs = singleQuotedString;
    else if (hasSingle && !hasDouble)
      qs = doubleQuotedString;
    else
      qs = singleQuote ? singleQuotedString : doubleQuotedString;
  }
  return qs(value, ctx);
}
function blockString({ comment, type, value }, ctx, onComment, onChompKeep) {
  const { blockQuote, commentString, lineWidth } = ctx.options;
  if (!blockQuote || /\n[\t ]+$/.test(value) || /^\s*$/.test(value)) {
    return quotedString(value, ctx);
  }
  const indent = ctx.indent || (ctx.forceBlockIndent || containsDocumentMarker(value) ? "  " : "");
  const literal = blockQuote === "literal" ? true : blockQuote === "folded" || type === Scalar.BLOCK_FOLDED ? false : type === Scalar.BLOCK_LITERAL ? true : !lineLengthOverLimit(value, lineWidth, indent.length);
  if (!value)
    return literal ? "|\n" : ">\n";
  let chomp;
  let endStart;
  for (endStart = value.length; endStart > 0; --endStart) {
    const ch = value[endStart - 1];
    if (ch !== "\n" && ch !== "	" && ch !== " ")
      break;
  }
  let end = value.substring(endStart);
  const endNlPos = end.indexOf("\n");
  if (endNlPos === -1) {
    chomp = "-";
  } else if (value === end || endNlPos !== end.length - 1) {
    chomp = "+";
    if (onChompKeep)
      onChompKeep();
  } else {
    chomp = "";
  }
  if (end) {
    value = value.slice(0, -end.length);
    if (end[end.length - 1] === "\n")
      end = end.slice(0, -1);
    end = end.replace(/\n+(?!\n|$)/g, `$&${indent}`);
  }
  let startWithSpace = false;
  let startEnd;
  let startNlPos = -1;
  for (startEnd = 0; startEnd < value.length; ++startEnd) {
    const ch = value[startEnd];
    if (ch === " ")
      startWithSpace = true;
    else if (ch === "\n")
      startNlPos = startEnd;
    else
      break;
  }
  let start = value.substring(0, startNlPos < startEnd ? startNlPos + 1 : startEnd);
  if (start) {
    value = value.substring(start.length);
    start = start.replace(/\n+/g, `$&${indent}`);
  }
  const indentSize = indent ? "2" : "1";
  let header = (literal ? "|" : ">") + (startWithSpace ? indentSize : "") + chomp;
  if (comment) {
    header += " " + commentString(comment.replace(/ ?[\r\n]+/g, " "));
    if (onComment)
      onComment();
  }
  if (literal) {
    value = value.replace(/\n+/g, `$&${indent}`);
    return `${header}
${indent}${start}${value}${end}`;
  }
  value = value.replace(/\n+/g, "\n$&").replace(/(?:^|\n)([\t ].*)(?:([\n\t ]*)\n(?![\n\t ]))?/g, "$1$2").replace(/\n+/g, `$&${indent}`);
  const body = foldFlowLines(`${start}${value}${end}`, indent, FOLD_BLOCK, getFoldOptions(ctx));
  return `${header}
${indent}${body}`;
}
function plainString(item, ctx, onComment, onChompKeep) {
  const { type, value } = item;
  const { actualString, implicitKey, indent, inFlow } = ctx;
  if (implicitKey && /[\n[\]{},]/.test(value) || inFlow && /[[\]{},]/.test(value)) {
    return quotedString(value, ctx);
  }
  if (!value || /^[\n\t ,[\]{}#&*!|>'"%@`]|^[?-]$|^[?-][ \t]|[\n:][ \t]|[ \t]\n|[\n\t ]#|[\n\t :]$/.test(value)) {
    return implicitKey || inFlow || value.indexOf("\n") === -1 ? quotedString(value, ctx) : blockString(item, ctx, onComment, onChompKeep);
  }
  if (!implicitKey && !inFlow && type !== Scalar.PLAIN && value.indexOf("\n") !== -1) {
    return blockString(item, ctx, onComment, onChompKeep);
  }
  if (indent === "" && containsDocumentMarker(value)) {
    ctx.forceBlockIndent = true;
    return blockString(item, ctx, onComment, onChompKeep);
  }
  const str = value.replace(/\n+/g, `$&
${indent}`);
  if (actualString) {
    const test = (tag2) => {
      var _a;
      return tag2.default && tag2.tag !== "tag:yaml.org,2002:str" && ((_a = tag2.test) === null || _a === void 0 ? void 0 : _a.test(str));
    };
    const { compat, tags } = ctx.doc.schema;
    if (tags.some(test) || (compat === null || compat === void 0 ? void 0 : compat.some(test)))
      return quotedString(value, ctx);
  }
  return implicitKey ? str : foldFlowLines(str, indent, FOLD_FLOW, getFoldOptions(ctx));
}
function stringifyString(item, ctx, onComment, onChompKeep) {
  const { implicitKey, inFlow } = ctx;
  const ss = typeof item.value === "string" ? item : Object.assign({}, item, { value: String(item.value) });
  let { type } = item;
  if (type !== Scalar.QUOTE_DOUBLE) {
    if (/[\x00-\x08\x0b-\x1f\x7f-\x9f\u{D800}-\u{DFFF}]/u.test(ss.value))
      type = Scalar.QUOTE_DOUBLE;
  }
  const _stringify = (_type) => {
    switch (_type) {
      case Scalar.BLOCK_FOLDED:
      case Scalar.BLOCK_LITERAL:
        return implicitKey || inFlow ? quotedString(ss.value, ctx) : blockString(ss, ctx, onComment, onChompKeep);
      case Scalar.QUOTE_DOUBLE:
        return doubleQuotedString(ss.value, ctx);
      case Scalar.QUOTE_SINGLE:
        return singleQuotedString(ss.value, ctx);
      case Scalar.PLAIN:
        return plainString(ss, ctx, onComment, onChompKeep);
      default:
        return null;
    }
  };
  let res = _stringify(type);
  if (res === null) {
    const { defaultKeyType, defaultStringType } = ctx.options;
    const t = implicitKey && defaultKeyType || defaultStringType;
    res = _stringify(t);
    if (res === null)
      throw new Error(`Unsupported default string type ${t}`);
  }
  return res;
}

// node_modules/yaml/browser/dist/stringify/stringify.js
function createStringifyContext(doc, options) {
  const opt = Object.assign({
    blockQuote: true,
    commentString: stringifyComment,
    defaultKeyType: null,
    defaultStringType: "PLAIN",
    directives: null,
    doubleQuotedAsJSON: false,
    doubleQuotedMinMultiLineLength: 40,
    falseStr: "false",
    indentSeq: true,
    lineWidth: 80,
    minContentWidth: 20,
    nullStr: "null",
    simpleKeys: false,
    singleQuote: null,
    trueStr: "true",
    verifyAliasOrder: true
  }, doc.schema.toStringOptions, options);
  let inFlow;
  switch (opt.collectionStyle) {
    case "block":
      inFlow = false;
      break;
    case "flow":
      inFlow = true;
      break;
    default:
      inFlow = null;
  }
  return {
    anchors: /* @__PURE__ */ new Set(),
    doc,
    indent: "",
    indentStep: typeof opt.indent === "number" ? " ".repeat(opt.indent) : "  ",
    inFlow,
    options: opt
  };
}
function getTagObject(tags, item) {
  if (item.tag) {
    const match = tags.filter((t) => t.tag === item.tag);
    if (match.length > 0)
      return match.find((t) => t.format === item.format) || match[0];
  }
  let tagObj = void 0;
  let obj;
  if (isScalar(item)) {
    obj = item.value;
    const match = tags.filter((t) => t.identify && t.identify(obj));
    tagObj = match.find((t) => t.format === item.format) || match.find((t) => !t.format);
  } else {
    obj = item;
    tagObj = tags.find((t) => t.nodeClass && obj instanceof t.nodeClass);
  }
  if (!tagObj) {
    const name = obj && obj.constructor ? obj.constructor.name : typeof obj;
    throw new Error(`Tag not resolved for ${name} value`);
  }
  return tagObj;
}
function stringifyProps(node, tagObj, { anchors, doc }) {
  if (!doc.directives)
    return "";
  const props = [];
  const anchor = (isScalar(node) || isCollection(node)) && node.anchor;
  if (anchor && anchorIsValid(anchor)) {
    anchors.add(anchor);
    props.push(`&${anchor}`);
  }
  const tag2 = node.tag || (tagObj.default ? null : tagObj.tag);
  if (tag2)
    props.push(doc.directives.tagString(tag2));
  return props.join(" ");
}
function stringify(item, ctx, onComment, onChompKeep) {
  var _a;
  if (isPair(item))
    return item.toString(ctx, onComment, onChompKeep);
  if (isAlias(item)) {
    if (ctx.doc.directives)
      return item.toString(ctx);
    if ((_a = ctx.resolvedAliases) === null || _a === void 0 ? void 0 : _a.has(item)) {
      throw new TypeError(`Cannot stringify circular structure without alias nodes`);
    } else {
      if (ctx.resolvedAliases)
        ctx.resolvedAliases.add(item);
      else
        ctx.resolvedAliases = /* @__PURE__ */ new Set([item]);
      item = item.resolve(ctx.doc);
    }
  }
  let tagObj = void 0;
  const node = isNode(item) ? item : ctx.doc.createNode(item, { onTagObj: (o) => tagObj = o });
  if (!tagObj)
    tagObj = getTagObject(ctx.doc.schema.tags, node);
  const props = stringifyProps(node, tagObj, ctx);
  if (props.length > 0)
    ctx.indentAtStart = (ctx.indentAtStart || 0) + props.length + 1;
  const str = typeof tagObj.stringify === "function" ? tagObj.stringify(node, ctx, onComment, onChompKeep) : isScalar(node) ? stringifyString(node, ctx, onComment, onChompKeep) : node.toString(ctx, onComment, onChompKeep);
  if (!props)
    return str;
  return isScalar(node) || str[0] === "{" || str[0] === "[" ? `${props} ${str}` : `${props}
${ctx.indent}${str}`;
}

// node_modules/yaml/browser/dist/stringify/stringifyPair.js
function stringifyPair({ key, value }, ctx, onComment, onChompKeep) {
  const { allNullValues, doc, indent, indentStep, options: { commentString, indentSeq, simpleKeys } } = ctx;
  let keyComment = isNode(key) && key.comment || null;
  if (simpleKeys) {
    if (keyComment) {
      throw new Error("With simple keys, key nodes cannot have comments");
    }
    if (isCollection(key)) {
      const msg = "With simple keys, collection cannot be used as a key value";
      throw new Error(msg);
    }
  }
  let explicitKey = !simpleKeys && (!key || keyComment && value == null && !ctx.inFlow || isCollection(key) || (isScalar(key) ? key.type === Scalar.BLOCK_FOLDED || key.type === Scalar.BLOCK_LITERAL : typeof key === "object"));
  ctx = Object.assign({}, ctx, {
    allNullValues: false,
    implicitKey: !explicitKey && (simpleKeys || !allNullValues),
    indent: indent + indentStep
  });
  let keyCommentDone = false;
  let chompKeep = false;
  let str = stringify(key, ctx, () => keyCommentDone = true, () => chompKeep = true);
  if (!explicitKey && !ctx.inFlow && str.length > 1024) {
    if (simpleKeys)
      throw new Error("With simple keys, single line scalar must not span more than 1024 characters");
    explicitKey = true;
  }
  if (ctx.inFlow) {
    if (allNullValues || value == null) {
      if (keyCommentDone && onComment)
        onComment();
      return explicitKey ? `? ${str}` : str;
    }
  } else if (allNullValues && !simpleKeys || value == null && explicitKey) {
    str = `? ${str}`;
    if (keyComment && !keyCommentDone) {
      str += lineComment(str, ctx.indent, commentString(keyComment));
    } else if (chompKeep && onChompKeep)
      onChompKeep();
    return str;
  }
  if (keyCommentDone)
    keyComment = null;
  if (explicitKey) {
    if (keyComment)
      str += lineComment(str, ctx.indent, commentString(keyComment));
    str = `? ${str}
${indent}:`;
  } else {
    str = `${str}:`;
    if (keyComment)
      str += lineComment(str, ctx.indent, commentString(keyComment));
  }
  let vcb = "";
  let valueComment = null;
  if (isNode(value)) {
    if (value.spaceBefore)
      vcb = "\n";
    if (value.commentBefore) {
      const cs = commentString(value.commentBefore);
      vcb += `
${indentComment(cs, ctx.indent)}`;
    }
    valueComment = value.comment;
  } else if (value && typeof value === "object") {
    value = doc.createNode(value);
  }
  ctx.implicitKey = false;
  if (!explicitKey && !keyComment && isScalar(value))
    ctx.indentAtStart = str.length + 1;
  chompKeep = false;
  if (!indentSeq && indentStep.length >= 2 && !ctx.inFlow && !explicitKey && isSeq(value) && !value.flow && !value.tag && !value.anchor) {
    ctx.indent = ctx.indent.substr(2);
  }
  let valueCommentDone = false;
  const valueStr = stringify(value, ctx, () => valueCommentDone = true, () => chompKeep = true);
  let ws = " ";
  if (vcb || keyComment) {
    ws = valueStr === "" && !ctx.inFlow ? vcb : `${vcb}
${ctx.indent}`;
  } else if (!explicitKey && isCollection(value)) {
    const flow = valueStr[0] === "[" || valueStr[0] === "{";
    if (!flow || valueStr.includes("\n"))
      ws = `
${ctx.indent}`;
  } else if (valueStr === "" || valueStr[0] === "\n")
    ws = "";
  str += ws + valueStr;
  if (ctx.inFlow) {
    if (valueCommentDone && onComment)
      onComment();
  } else if (valueComment && !valueCommentDone) {
    str += lineComment(str, ctx.indent, commentString(valueComment));
  } else if (chompKeep && onChompKeep) {
    onChompKeep();
  }
  return str;
}

// node_modules/yaml/browser/dist/log.js
function warn(logLevel, warning) {
  if (logLevel === "debug" || logLevel === "warn") {
    if (typeof process !== "undefined" && process.emitWarning)
      process.emitWarning(warning);
    else
      console.warn(warning);
  }
}

// node_modules/yaml/browser/dist/nodes/addPairToJSMap.js
var MERGE_KEY = "<<";
function addPairToJSMap(ctx, map2, { key, value }) {
  if (ctx && ctx.doc.schema.merge && isMergeKey(key)) {
    value = isAlias(value) ? value.resolve(ctx.doc) : value;
    if (isSeq(value))
      for (const it of value.items)
        mergeToJSMap(ctx, map2, it);
    else if (Array.isArray(value))
      for (const it of value)
        mergeToJSMap(ctx, map2, it);
    else
      mergeToJSMap(ctx, map2, value);
  } else {
    const jsKey = toJS(key, "", ctx);
    if (map2 instanceof Map) {
      map2.set(jsKey, toJS(value, jsKey, ctx));
    } else if (map2 instanceof Set) {
      map2.add(jsKey);
    } else {
      const stringKey = stringifyKey(key, jsKey, ctx);
      const jsValue = toJS(value, stringKey, ctx);
      if (stringKey in map2)
        Object.defineProperty(map2, stringKey, {
          value: jsValue,
          writable: true,
          enumerable: true,
          configurable: true
        });
      else
        map2[stringKey] = jsValue;
    }
  }
  return map2;
}
var isMergeKey = (key) => key === MERGE_KEY || isScalar(key) && key.value === MERGE_KEY && (!key.type || key.type === Scalar.PLAIN);
function mergeToJSMap(ctx, map2, value) {
  const source = ctx && isAlias(value) ? value.resolve(ctx.doc) : value;
  if (!isMap(source))
    throw new Error("Merge sources must be maps or map aliases");
  const srcMap = source.toJSON(null, ctx, Map);
  for (const [key, value2] of srcMap) {
    if (map2 instanceof Map) {
      if (!map2.has(key))
        map2.set(key, value2);
    } else if (map2 instanceof Set) {
      map2.add(key);
    } else if (!Object.prototype.hasOwnProperty.call(map2, key)) {
      Object.defineProperty(map2, key, {
        value: value2,
        writable: true,
        enumerable: true,
        configurable: true
      });
    }
  }
  return map2;
}
function stringifyKey(key, jsKey, ctx) {
  if (jsKey === null)
    return "";
  if (typeof jsKey !== "object")
    return String(jsKey);
  if (isNode(key) && ctx && ctx.doc) {
    const strCtx = createStringifyContext(ctx.doc, {});
    strCtx.anchors = /* @__PURE__ */ new Set();
    for (const node of ctx.anchors.keys())
      strCtx.anchors.add(node.anchor);
    strCtx.inFlow = true;
    strCtx.inStringifyKey = true;
    const strKey = key.toString(strCtx);
    if (!ctx.mapKeyWarned) {
      let jsonStr = JSON.stringify(strKey);
      if (jsonStr.length > 40)
        jsonStr = jsonStr.substring(0, 36) + '..."';
      warn(ctx.doc.options.logLevel, `Keys with collection values will be stringified due to JS Object restrictions: ${jsonStr}. Set mapAsMap: true to use object keys.`);
      ctx.mapKeyWarned = true;
    }
    return strKey;
  }
  return JSON.stringify(jsKey);
}

// node_modules/yaml/browser/dist/nodes/Pair.js
function createPair(key, value, ctx) {
  const k = createNode(key, void 0, ctx);
  const v = createNode(value, void 0, ctx);
  return new Pair(k, v);
}
var Pair = class {
  constructor(key, value = null) {
    Object.defineProperty(this, NODE_TYPE, { value: PAIR });
    this.key = key;
    this.value = value;
  }
  clone(schema4) {
    let { key, value } = this;
    if (isNode(key))
      key = key.clone(schema4);
    if (isNode(value))
      value = value.clone(schema4);
    return new Pair(key, value);
  }
  toJSON(_, ctx) {
    const pair = ctx && ctx.mapAsMap ? /* @__PURE__ */ new Map() : {};
    return addPairToJSMap(ctx, pair, this);
  }
  toString(ctx, onComment, onChompKeep) {
    return ctx && ctx.doc ? stringifyPair(this, ctx, onComment, onChompKeep) : JSON.stringify(this);
  }
};

// node_modules/yaml/browser/dist/options.js
var defaultOptions = {
  intAsBigInt: false,
  keepSourceTokens: false,
  logLevel: "warn",
  prettyErrors: true,
  strict: true,
  uniqueKeys: true,
  version: "1.2"
};

// node_modules/yaml/browser/dist/stringify/stringifyCollection.js
function stringifyCollection(collection, ctx, options) {
  var _a;
  const flow = (_a = ctx.inFlow) !== null && _a !== void 0 ? _a : collection.flow;
  const stringify4 = flow ? stringifyFlowCollection : stringifyBlockCollection;
  return stringify4(collection, ctx, options);
}
function stringifyBlockCollection({ comment, items }, ctx, { blockItemPrefix, flowChars, itemIndent, onChompKeep, onComment }) {
  const { indent, options: { commentString } } = ctx;
  const itemCtx = Object.assign({}, ctx, { indent: itemIndent, type: null });
  let chompKeep = false;
  const lines = [];
  for (let i = 0; i < items.length; ++i) {
    const item = items[i];
    let comment2 = null;
    if (isNode(item)) {
      if (!chompKeep && item.spaceBefore)
        lines.push("");
      addCommentBefore(ctx, lines, item.commentBefore, chompKeep);
      if (item.comment)
        comment2 = item.comment;
    } else if (isPair(item)) {
      const ik = isNode(item.key) ? item.key : null;
      if (ik) {
        if (!chompKeep && ik.spaceBefore)
          lines.push("");
        addCommentBefore(ctx, lines, ik.commentBefore, chompKeep);
      }
    }
    chompKeep = false;
    let str2 = stringify(item, itemCtx, () => comment2 = null, () => chompKeep = true);
    if (comment2)
      str2 += lineComment(str2, itemIndent, commentString(comment2));
    if (chompKeep && comment2)
      chompKeep = false;
    lines.push(blockItemPrefix + str2);
  }
  let str;
  if (lines.length === 0) {
    str = flowChars.start + flowChars.end;
  } else {
    str = lines[0];
    for (let i = 1; i < lines.length; ++i) {
      const line = lines[i];
      str += line ? `
${indent}${line}` : "\n";
    }
  }
  if (comment) {
    str += "\n" + indentComment(commentString(comment), indent);
    if (onComment)
      onComment();
  } else if (chompKeep && onChompKeep)
    onChompKeep();
  return str;
}
function stringifyFlowCollection({ comment, items }, ctx, { flowChars, itemIndent, onComment }) {
  const { indent, indentStep, options: { commentString } } = ctx;
  itemIndent += indentStep;
  const itemCtx = Object.assign({}, ctx, {
    indent: itemIndent,
    inFlow: true,
    type: null
  });
  let reqNewline = false;
  let linesAtValue = 0;
  const lines = [];
  for (let i = 0; i < items.length; ++i) {
    const item = items[i];
    let comment2 = null;
    if (isNode(item)) {
      if (item.spaceBefore)
        lines.push("");
      addCommentBefore(ctx, lines, item.commentBefore, false);
      if (item.comment)
        comment2 = item.comment;
    } else if (isPair(item)) {
      const ik = isNode(item.key) ? item.key : null;
      if (ik) {
        if (ik.spaceBefore)
          lines.push("");
        addCommentBefore(ctx, lines, ik.commentBefore, false);
        if (ik.comment)
          reqNewline = true;
      }
      const iv = isNode(item.value) ? item.value : null;
      if (iv) {
        if (iv.comment)
          comment2 = iv.comment;
        if (iv.commentBefore)
          reqNewline = true;
      } else if (item.value == null && ik && ik.comment) {
        comment2 = ik.comment;
      }
    }
    if (comment2)
      reqNewline = true;
    let str2 = stringify(item, itemCtx, () => comment2 = null);
    if (i < items.length - 1)
      str2 += ",";
    if (comment2)
      str2 += lineComment(str2, itemIndent, commentString(comment2));
    if (!reqNewline && (lines.length > linesAtValue || str2.includes("\n")))
      reqNewline = true;
    lines.push(str2);
    linesAtValue = lines.length;
  }
  let str;
  const { start, end } = flowChars;
  if (lines.length === 0) {
    str = start + end;
  } else {
    if (!reqNewline) {
      const len = lines.reduce((sum, line) => sum + line.length + 2, 2);
      reqNewline = len > Collection.maxFlowStringSingleLineLength;
    }
    if (reqNewline) {
      str = start;
      for (const line of lines)
        str += line ? `
${indentStep}${indent}${line}` : "\n";
      str += `
${indent}${end}`;
    } else {
      str = `${start} ${lines.join(" ")} ${end}`;
    }
  }
  if (comment) {
    str += lineComment(str, commentString(comment), indent);
    if (onComment)
      onComment();
  }
  return str;
}
function addCommentBefore({ indent, options: { commentString } }, lines, comment, chompKeep) {
  if (comment && chompKeep)
    comment = comment.replace(/^\n+/, "");
  if (comment) {
    const ic = indentComment(commentString(comment), indent);
    lines.push(ic.trimStart());
  }
}

// node_modules/yaml/browser/dist/nodes/YAMLMap.js
function findPair(items, key) {
  const k = isScalar(key) ? key.value : key;
  for (const it of items) {
    if (isPair(it)) {
      if (it.key === key || it.key === k)
        return it;
      if (isScalar(it.key) && it.key.value === k)
        return it;
    }
  }
  return void 0;
}
var YAMLMap = class extends Collection {
  constructor(schema4) {
    super(MAP, schema4);
    this.items = [];
  }
  static get tagName() {
    return "tag:yaml.org,2002:map";
  }
  /**
   * Adds a value to the collection.
   *
   * @param overwrite - If not set `true`, using a key that is already in the
   *   collection will throw. Otherwise, overwrites the previous value.
   */
  add(pair, overwrite) {
    let _pair;
    if (isPair(pair))
      _pair = pair;
    else if (!pair || typeof pair !== "object" || !("key" in pair)) {
      _pair = new Pair(pair, pair.value);
    } else
      _pair = new Pair(pair.key, pair.value);
    const prev = findPair(this.items, _pair.key);
    const sortEntries = this.schema && this.schema.sortMapEntries;
    if (prev) {
      if (!overwrite)
        throw new Error(`Key ${_pair.key} already set`);
      if (isScalar(prev.value) && isScalarValue(_pair.value))
        prev.value.value = _pair.value;
      else
        prev.value = _pair.value;
    } else if (sortEntries) {
      const i = this.items.findIndex((item) => sortEntries(_pair, item) < 0);
      if (i === -1)
        this.items.push(_pair);
      else
        this.items.splice(i, 0, _pair);
    } else {
      this.items.push(_pair);
    }
  }
  delete(key) {
    const it = findPair(this.items, key);
    if (!it)
      return false;
    const del = this.items.splice(this.items.indexOf(it), 1);
    return del.length > 0;
  }
  get(key, keepScalar) {
    const it = findPair(this.items, key);
    const node = it && it.value;
    return !keepScalar && isScalar(node) ? node.value : node;
  }
  has(key) {
    return !!findPair(this.items, key);
  }
  set(key, value) {
    this.add(new Pair(key, value), true);
  }
  /**
   * @param ctx - Conversion context, originally set in Document#toJS()
   * @param {Class} Type - If set, forces the returned collection type
   * @returns Instance of Type, Map, or Object
   */
  toJSON(_, ctx, Type) {
    const map2 = Type ? new Type() : ctx && ctx.mapAsMap ? /* @__PURE__ */ new Map() : {};
    if (ctx && ctx.onCreate)
      ctx.onCreate(map2);
    for (const item of this.items)
      addPairToJSMap(ctx, map2, item);
    return map2;
  }
  toString(ctx, onComment, onChompKeep) {
    if (!ctx)
      return JSON.stringify(this);
    for (const item of this.items) {
      if (!isPair(item))
        throw new Error(`Map items must all be pairs; found ${JSON.stringify(item)} instead`);
    }
    if (!ctx.allNullValues && this.hasAllNullValues(false))
      ctx = Object.assign({}, ctx, { allNullValues: true });
    return stringifyCollection(this, ctx, {
      blockItemPrefix: "",
      flowChars: { start: "{", end: "}" },
      itemIndent: ctx.indent || "",
      onChompKeep,
      onComment
    });
  }
};

// node_modules/yaml/browser/dist/schema/common/map.js
function createMap(schema4, obj, ctx) {
  const { keepUndefined, replacer } = ctx;
  const map2 = new YAMLMap(schema4);
  const add = (key, value) => {
    if (typeof replacer === "function")
      value = replacer.call(obj, key, value);
    else if (Array.isArray(replacer) && !replacer.includes(key))
      return;
    if (value !== void 0 || keepUndefined)
      map2.items.push(createPair(key, value, ctx));
  };
  if (obj instanceof Map) {
    for (const [key, value] of obj)
      add(key, value);
  } else if (obj && typeof obj === "object") {
    for (const key of Object.keys(obj))
      add(key, obj[key]);
  }
  if (typeof schema4.sortMapEntries === "function") {
    map2.items.sort(schema4.sortMapEntries);
  }
  return map2;
}
var map = {
  collection: "map",
  createNode: createMap,
  default: true,
  nodeClass: YAMLMap,
  tag: "tag:yaml.org,2002:map",
  resolve(map2, onError) {
    if (!isMap(map2))
      onError("Expected a mapping for this tag");
    return map2;
  }
};

// node_modules/yaml/browser/dist/nodes/YAMLSeq.js
var YAMLSeq = class extends Collection {
  constructor(schema4) {
    super(SEQ, schema4);
    this.items = [];
  }
  static get tagName() {
    return "tag:yaml.org,2002:seq";
  }
  add(value) {
    this.items.push(value);
  }
  /**
   * Removes a value from the collection.
   *
   * `key` must contain a representation of an integer for this to succeed.
   * It may be wrapped in a `Scalar`.
   *
   * @returns `true` if the item was found and removed.
   */
  delete(key) {
    const idx = asItemIndex(key);
    if (typeof idx !== "number")
      return false;
    const del = this.items.splice(idx, 1);
    return del.length > 0;
  }
  /**
   * Returns item at `key`, or `undefined` if not found. By default unwraps
   * scalar values from their surrounding node; to disable set `keepScalar` to
   * `true` (collections are always returned intact).
   *
   * `key` must contain a representation of an integer for this to succeed.
   * It may be wrapped in a `Scalar`.
   */
  get(key, keepScalar) {
    const idx = asItemIndex(key);
    if (typeof idx !== "number")
      return void 0;
    const it = this.items[idx];
    return !keepScalar && isScalar(it) ? it.value : it;
  }
  /**
   * Checks if the collection includes a value with the key `key`.
   *
   * `key` must contain a representation of an integer for this to succeed.
   * It may be wrapped in a `Scalar`.
   */
  has(key) {
    const idx = asItemIndex(key);
    return typeof idx === "number" && idx < this.items.length;
  }
  /**
   * Sets a value in this collection. For `!!set`, `value` needs to be a
   * boolean to add/remove the item from the set.
   *
   * If `key` does not contain a representation of an integer, this will throw.
   * It may be wrapped in a `Scalar`.
   */
  set(key, value) {
    const idx = asItemIndex(key);
    if (typeof idx !== "number")
      throw new Error(`Expected a valid index, not ${key}.`);
    const prev = this.items[idx];
    if (isScalar(prev) && isScalarValue(value))
      prev.value = value;
    else
      this.items[idx] = value;
  }
  toJSON(_, ctx) {
    const seq2 = [];
    if (ctx && ctx.onCreate)
      ctx.onCreate(seq2);
    let i = 0;
    for (const item of this.items)
      seq2.push(toJS(item, String(i++), ctx));
    return seq2;
  }
  toString(ctx, onComment, onChompKeep) {
    if (!ctx)
      return JSON.stringify(this);
    return stringifyCollection(this, ctx, {
      blockItemPrefix: "- ",
      flowChars: { start: "[", end: "]" },
      itemIndent: (ctx.indent || "") + "  ",
      onChompKeep,
      onComment
    });
  }
};
function asItemIndex(key) {
  let idx = isScalar(key) ? key.value : key;
  if (idx && typeof idx === "string")
    idx = Number(idx);
  return typeof idx === "number" && Number.isInteger(idx) && idx >= 0 ? idx : null;
}

// node_modules/yaml/browser/dist/schema/common/seq.js
function createSeq(schema4, obj, ctx) {
  const { replacer } = ctx;
  const seq2 = new YAMLSeq(schema4);
  if (obj && Symbol.iterator in Object(obj)) {
    let i = 0;
    for (let it of obj) {
      if (typeof replacer === "function") {
        const key = obj instanceof Set ? it : String(i++);
        it = replacer.call(obj, key, it);
      }
      seq2.items.push(createNode(it, void 0, ctx));
    }
  }
  return seq2;
}
var seq = {
  collection: "seq",
  createNode: createSeq,
  default: true,
  nodeClass: YAMLSeq,
  tag: "tag:yaml.org,2002:seq",
  resolve(seq2, onError) {
    if (!isSeq(seq2))
      onError("Expected a sequence for this tag");
    return seq2;
  }
};

// node_modules/yaml/browser/dist/schema/common/string.js
var string = {
  identify: (value) => typeof value === "string",
  default: true,
  tag: "tag:yaml.org,2002:str",
  resolve: (str) => str,
  stringify(item, ctx, onComment, onChompKeep) {
    ctx = Object.assign({ actualString: true }, ctx);
    return stringifyString(item, ctx, onComment, onChompKeep);
  }
};

// node_modules/yaml/browser/dist/schema/common/null.js
var nullTag = {
  identify: (value) => value == null,
  createNode: () => new Scalar(null),
  default: true,
  tag: "tag:yaml.org,2002:null",
  test: /^(?:~|[Nn]ull|NULL)?$/,
  resolve: () => new Scalar(null),
  stringify: ({ source }, ctx) => source && nullTag.test.test(source) ? source : ctx.options.nullStr
};

// node_modules/yaml/browser/dist/schema/core/bool.js
var boolTag = {
  identify: (value) => typeof value === "boolean",
  default: true,
  tag: "tag:yaml.org,2002:bool",
  test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,
  resolve: (str) => new Scalar(str[0] === "t" || str[0] === "T"),
  stringify({ source, value }, ctx) {
    if (source && boolTag.test.test(source)) {
      const sv = source[0] === "t" || source[0] === "T";
      if (value === sv)
        return source;
    }
    return value ? ctx.options.trueStr : ctx.options.falseStr;
  }
};

// node_modules/yaml/browser/dist/stringify/stringifyNumber.js
function stringifyNumber({ format, minFractionDigits, tag: tag2, value }) {
  if (typeof value === "bigint")
    return String(value);
  const num = typeof value === "number" ? value : Number(value);
  if (!isFinite(num))
    return isNaN(num) ? ".nan" : num < 0 ? "-.inf" : ".inf";
  let n = JSON.stringify(value);
  if (!format && minFractionDigits && (!tag2 || tag2 === "tag:yaml.org,2002:float") && /^\d/.test(n)) {
    let i = n.indexOf(".");
    if (i < 0) {
      i = n.length;
      n += ".";
    }
    let d = minFractionDigits - (n.length - i - 1);
    while (d-- > 0)
      n += "0";
  }
  return n;
}

// node_modules/yaml/browser/dist/schema/core/float.js
var floatNaN = {
  identify: (value) => typeof value === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  test: /^(?:[-+]?\.(?:inf|Inf|INF|nan|NaN|NAN))$/,
  resolve: (str) => str.slice(-3).toLowerCase() === "nan" ? NaN : str[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
  stringify: stringifyNumber
};
var floatExp = {
  identify: (value) => typeof value === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  format: "EXP",
  test: /^[-+]?(?:\.[0-9]+|[0-9]+(?:\.[0-9]*)?)[eE][-+]?[0-9]+$/,
  resolve: (str) => parseFloat(str),
  stringify(node) {
    const num = Number(node.value);
    return isFinite(num) ? num.toExponential() : stringifyNumber(node);
  }
};
var float = {
  identify: (value) => typeof value === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  test: /^[-+]?(?:\.[0-9]+|[0-9]+\.[0-9]*)$/,
  resolve(str) {
    const node = new Scalar(parseFloat(str));
    const dot = str.indexOf(".");
    if (dot !== -1 && str[str.length - 1] === "0")
      node.minFractionDigits = str.length - dot - 1;
    return node;
  },
  stringify: stringifyNumber
};

// node_modules/yaml/browser/dist/schema/core/int.js
var intIdentify = (value) => typeof value === "bigint" || Number.isInteger(value);
var intResolve = (str, offset, radix, { intAsBigInt }) => intAsBigInt ? BigInt(str) : parseInt(str.substring(offset), radix);
function intStringify(node, radix, prefix) {
  const { value } = node;
  if (intIdentify(value) && value >= 0)
    return prefix + value.toString(radix);
  return stringifyNumber(node);
}
var intOct = {
  identify: (value) => intIdentify(value) && value >= 0,
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "OCT",
  test: /^0o[0-7]+$/,
  resolve: (str, _onError, opt) => intResolve(str, 2, 8, opt),
  stringify: (node) => intStringify(node, 8, "0o")
};
var int = {
  identify: intIdentify,
  default: true,
  tag: "tag:yaml.org,2002:int",
  test: /^[-+]?[0-9]+$/,
  resolve: (str, _onError, opt) => intResolve(str, 0, 10, opt),
  stringify: stringifyNumber
};
var intHex = {
  identify: (value) => intIdentify(value) && value >= 0,
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "HEX",
  test: /^0x[0-9a-fA-F]+$/,
  resolve: (str, _onError, opt) => intResolve(str, 2, 16, opt),
  stringify: (node) => intStringify(node, 16, "0x")
};

// node_modules/yaml/browser/dist/schema/core/schema.js
var schema = [
  map,
  seq,
  string,
  nullTag,
  boolTag,
  intOct,
  int,
  intHex,
  floatNaN,
  floatExp,
  float
];

// node_modules/yaml/browser/dist/schema/json/schema.js
function intIdentify2(value) {
  return typeof value === "bigint" || Number.isInteger(value);
}
var stringifyJSON = ({ value }) => JSON.stringify(value);
var jsonScalars = [
  {
    identify: (value) => typeof value === "string",
    default: true,
    tag: "tag:yaml.org,2002:str",
    resolve: (str) => str,
    stringify: stringifyJSON
  },
  {
    identify: (value) => value == null,
    createNode: () => new Scalar(null),
    default: true,
    tag: "tag:yaml.org,2002:null",
    test: /^null$/,
    resolve: () => null,
    stringify: stringifyJSON
  },
  {
    identify: (value) => typeof value === "boolean",
    default: true,
    tag: "tag:yaml.org,2002:bool",
    test: /^true|false$/,
    resolve: (str) => str === "true",
    stringify: stringifyJSON
  },
  {
    identify: intIdentify2,
    default: true,
    tag: "tag:yaml.org,2002:int",
    test: /^-?(?:0|[1-9][0-9]*)$/,
    resolve: (str, _onError, { intAsBigInt }) => intAsBigInt ? BigInt(str) : parseInt(str, 10),
    stringify: ({ value }) => intIdentify2(value) ? value.toString() : JSON.stringify(value)
  },
  {
    identify: (value) => typeof value === "number",
    default: true,
    tag: "tag:yaml.org,2002:float",
    test: /^-?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,
    resolve: (str) => parseFloat(str),
    stringify: stringifyJSON
  }
];
var jsonError = {
  default: true,
  tag: "",
  test: /^/,
  resolve(str, onError) {
    onError(`Unresolved plain scalar ${JSON.stringify(str)}`);
    return str;
  }
};
var schema2 = [map, seq].concat(jsonScalars, jsonError);

// node_modules/yaml/browser/dist/schema/yaml-1.1/binary.js
var binary = {
  identify: (value) => value instanceof Uint8Array,
  default: false,
  tag: "tag:yaml.org,2002:binary",
  /**
   * Returns a Buffer in node and an Uint8Array in browsers
   *
   * To use the resulting buffer as an image, you'll want to do something like:
   *
   *   const blob = new Blob([buffer], { type: 'image/jpeg' })
   *   document.querySelector('#photo').src = URL.createObjectURL(blob)
   */
  resolve(src, onError) {
    if (typeof Buffer === "function") {
      return Buffer.from(src, "base64");
    } else if (typeof atob === "function") {
      const str = atob(src.replace(/[\n\r]/g, ""));
      const buffer = new Uint8Array(str.length);
      for (let i = 0; i < str.length; ++i)
        buffer[i] = str.charCodeAt(i);
      return buffer;
    } else {
      onError("This environment does not support reading binary tags; either Buffer or atob is required");
      return src;
    }
  },
  stringify({ comment, type, value }, ctx, onComment, onChompKeep) {
    const buf = value;
    let str;
    if (typeof Buffer === "function") {
      str = buf instanceof Buffer ? buf.toString("base64") : Buffer.from(buf.buffer).toString("base64");
    } else if (typeof btoa === "function") {
      let s = "";
      for (let i = 0; i < buf.length; ++i)
        s += String.fromCharCode(buf[i]);
      str = btoa(s);
    } else {
      throw new Error("This environment does not support writing binary tags; either Buffer or btoa is required");
    }
    if (!type)
      type = Scalar.BLOCK_LITERAL;
    if (type !== Scalar.QUOTE_DOUBLE) {
      const lineWidth = Math.max(ctx.options.lineWidth - ctx.indent.length, ctx.options.minContentWidth);
      const n = Math.ceil(str.length / lineWidth);
      const lines = new Array(n);
      for (let i = 0, o = 0; i < n; ++i, o += lineWidth) {
        lines[i] = str.substr(o, lineWidth);
      }
      str = lines.join(type === Scalar.BLOCK_LITERAL ? "\n" : " ");
    }
    return stringifyString({ comment, type, value: str }, ctx, onComment, onChompKeep);
  }
};

// node_modules/yaml/browser/dist/schema/yaml-1.1/pairs.js
function resolvePairs(seq2, onError) {
  if (isSeq(seq2)) {
    for (let i = 0; i < seq2.items.length; ++i) {
      let item = seq2.items[i];
      if (isPair(item))
        continue;
      else if (isMap(item)) {
        if (item.items.length > 1)
          onError("Each pair must have its own sequence indicator");
        const pair = item.items[0] || new Pair(new Scalar(null));
        if (item.commentBefore)
          pair.key.commentBefore = pair.key.commentBefore ? `${item.commentBefore}
${pair.key.commentBefore}` : item.commentBefore;
        if (item.comment) {
          const cn = pair.value || pair.key;
          cn.comment = cn.comment ? `${item.comment}
${cn.comment}` : item.comment;
        }
        item = pair;
      }
      seq2.items[i] = isPair(item) ? item : new Pair(item);
    }
  } else
    onError("Expected a sequence for this tag");
  return seq2;
}
function createPairs(schema4, iterable, ctx) {
  const { replacer } = ctx;
  const pairs2 = new YAMLSeq(schema4);
  pairs2.tag = "tag:yaml.org,2002:pairs";
  let i = 0;
  if (iterable && Symbol.iterator in Object(iterable))
    for (let it of iterable) {
      if (typeof replacer === "function")
        it = replacer.call(iterable, String(i++), it);
      let key, value;
      if (Array.isArray(it)) {
        if (it.length === 2) {
          key = it[0];
          value = it[1];
        } else
          throw new TypeError(`Expected [key, value] tuple: ${it}`);
      } else if (it && it instanceof Object) {
        const keys = Object.keys(it);
        if (keys.length === 1) {
          key = keys[0];
          value = it[key];
        } else
          throw new TypeError(`Expected { key: value } tuple: ${it}`);
      } else {
        key = it;
      }
      pairs2.items.push(createPair(key, value, ctx));
    }
  return pairs2;
}
var pairs = {
  collection: "seq",
  default: false,
  tag: "tag:yaml.org,2002:pairs",
  resolve: resolvePairs,
  createNode: createPairs
};

// node_modules/yaml/browser/dist/schema/yaml-1.1/omap.js
var YAMLOMap = class extends YAMLSeq {
  constructor() {
    super();
    this.add = YAMLMap.prototype.add.bind(this);
    this.delete = YAMLMap.prototype.delete.bind(this);
    this.get = YAMLMap.prototype.get.bind(this);
    this.has = YAMLMap.prototype.has.bind(this);
    this.set = YAMLMap.prototype.set.bind(this);
    this.tag = YAMLOMap.tag;
  }
  /**
   * If `ctx` is given, the return type is actually `Map<unknown, unknown>`,
   * but TypeScript won't allow widening the signature of a child method.
   */
  toJSON(_, ctx) {
    if (!ctx)
      return super.toJSON(_);
    const map2 = /* @__PURE__ */ new Map();
    if (ctx && ctx.onCreate)
      ctx.onCreate(map2);
    for (const pair of this.items) {
      let key, value;
      if (isPair(pair)) {
        key = toJS(pair.key, "", ctx);
        value = toJS(pair.value, key, ctx);
      } else {
        key = toJS(pair, "", ctx);
      }
      if (map2.has(key))
        throw new Error("Ordered maps must not include duplicate keys");
      map2.set(key, value);
    }
    return map2;
  }
};
YAMLOMap.tag = "tag:yaml.org,2002:omap";
var omap = {
  collection: "seq",
  identify: (value) => value instanceof Map,
  nodeClass: YAMLOMap,
  default: false,
  tag: "tag:yaml.org,2002:omap",
  resolve(seq2, onError) {
    const pairs2 = resolvePairs(seq2, onError);
    const seenKeys = [];
    for (const { key } of pairs2.items) {
      if (isScalar(key)) {
        if (seenKeys.includes(key.value)) {
          onError(`Ordered maps must not include duplicate keys: ${key.value}`);
        } else {
          seenKeys.push(key.value);
        }
      }
    }
    return Object.assign(new YAMLOMap(), pairs2);
  },
  createNode(schema4, iterable, ctx) {
    const pairs2 = createPairs(schema4, iterable, ctx);
    const omap2 = new YAMLOMap();
    omap2.items = pairs2.items;
    return omap2;
  }
};

// node_modules/yaml/browser/dist/schema/yaml-1.1/bool.js
function boolStringify({ value, source }, ctx) {
  const boolObj = value ? trueTag : falseTag;
  if (source && boolObj.test.test(source))
    return source;
  return value ? ctx.options.trueStr : ctx.options.falseStr;
}
var trueTag = {
  identify: (value) => value === true,
  default: true,
  tag: "tag:yaml.org,2002:bool",
  test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,
  resolve: () => new Scalar(true),
  stringify: boolStringify
};
var falseTag = {
  identify: (value) => value === false,
  default: true,
  tag: "tag:yaml.org,2002:bool",
  test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/i,
  resolve: () => new Scalar(false),
  stringify: boolStringify
};

// node_modules/yaml/browser/dist/schema/yaml-1.1/float.js
var floatNaN2 = {
  identify: (value) => typeof value === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  test: /^[-+]?\.(?:inf|Inf|INF|nan|NaN|NAN)$/,
  resolve: (str) => str.slice(-3).toLowerCase() === "nan" ? NaN : str[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
  stringify: stringifyNumber
};
var floatExp2 = {
  identify: (value) => typeof value === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  format: "EXP",
  test: /^[-+]?(?:[0-9][0-9_]*)?(?:\.[0-9_]*)?[eE][-+]?[0-9]+$/,
  resolve: (str) => parseFloat(str.replace(/_/g, "")),
  stringify(node) {
    const num = Number(node.value);
    return isFinite(num) ? num.toExponential() : stringifyNumber(node);
  }
};
var float2 = {
  identify: (value) => typeof value === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  test: /^[-+]?(?:[0-9][0-9_]*)?\.[0-9_]*$/,
  resolve(str) {
    const node = new Scalar(parseFloat(str.replace(/_/g, "")));
    const dot = str.indexOf(".");
    if (dot !== -1) {
      const f = str.substring(dot + 1).replace(/_/g, "");
      if (f[f.length - 1] === "0")
        node.minFractionDigits = f.length;
    }
    return node;
  },
  stringify: stringifyNumber
};

// node_modules/yaml/browser/dist/schema/yaml-1.1/int.js
var intIdentify3 = (value) => typeof value === "bigint" || Number.isInteger(value);
function intResolve2(str, offset, radix, { intAsBigInt }) {
  const sign = str[0];
  if (sign === "-" || sign === "+")
    offset += 1;
  str = str.substring(offset).replace(/_/g, "");
  if (intAsBigInt) {
    switch (radix) {
      case 2:
        str = `0b${str}`;
        break;
      case 8:
        str = `0o${str}`;
        break;
      case 16:
        str = `0x${str}`;
        break;
    }
    const n2 = BigInt(str);
    return sign === "-" ? BigInt(-1) * n2 : n2;
  }
  const n = parseInt(str, radix);
  return sign === "-" ? -1 * n : n;
}
function intStringify2(node, radix, prefix) {
  const { value } = node;
  if (intIdentify3(value)) {
    const str = value.toString(radix);
    return value < 0 ? "-" + prefix + str.substr(1) : prefix + str;
  }
  return stringifyNumber(node);
}
var intBin = {
  identify: intIdentify3,
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "BIN",
  test: /^[-+]?0b[0-1_]+$/,
  resolve: (str, _onError, opt) => intResolve2(str, 2, 2, opt),
  stringify: (node) => intStringify2(node, 2, "0b")
};
var intOct2 = {
  identify: intIdentify3,
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "OCT",
  test: /^[-+]?0[0-7_]+$/,
  resolve: (str, _onError, opt) => intResolve2(str, 1, 8, opt),
  stringify: (node) => intStringify2(node, 8, "0")
};
var int2 = {
  identify: intIdentify3,
  default: true,
  tag: "tag:yaml.org,2002:int",
  test: /^[-+]?[0-9][0-9_]*$/,
  resolve: (str, _onError, opt) => intResolve2(str, 0, 10, opt),
  stringify: stringifyNumber
};
var intHex2 = {
  identify: intIdentify3,
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "HEX",
  test: /^[-+]?0x[0-9a-fA-F_]+$/,
  resolve: (str, _onError, opt) => intResolve2(str, 2, 16, opt),
  stringify: (node) => intStringify2(node, 16, "0x")
};

// node_modules/yaml/browser/dist/schema/yaml-1.1/set.js
var YAMLSet = class extends YAMLMap {
  constructor(schema4) {
    super(schema4);
    this.tag = YAMLSet.tag;
  }
  add(key) {
    let pair;
    if (isPair(key))
      pair = key;
    else if (typeof key === "object" && "key" in key && "value" in key && key.value === null)
      pair = new Pair(key.key, null);
    else
      pair = new Pair(key, null);
    const prev = findPair(this.items, pair.key);
    if (!prev)
      this.items.push(pair);
  }
  get(key, keepPair) {
    const pair = findPair(this.items, key);
    return !keepPair && isPair(pair) ? isScalar(pair.key) ? pair.key.value : pair.key : pair;
  }
  set(key, value) {
    if (typeof value !== "boolean")
      throw new Error(`Expected boolean value for set(key, value) in a YAML set, not ${typeof value}`);
    const prev = findPair(this.items, key);
    if (prev && !value) {
      this.items.splice(this.items.indexOf(prev), 1);
    } else if (!prev && value) {
      this.items.push(new Pair(key));
    }
  }
  toJSON(_, ctx) {
    return super.toJSON(_, ctx, Set);
  }
  toString(ctx, onComment, onChompKeep) {
    if (!ctx)
      return JSON.stringify(this);
    if (this.hasAllNullValues(true))
      return super.toString(Object.assign({}, ctx, { allNullValues: true }), onComment, onChompKeep);
    else
      throw new Error("Set items must all have null values");
  }
};
YAMLSet.tag = "tag:yaml.org,2002:set";
var set = {
  collection: "map",
  identify: (value) => value instanceof Set,
  nodeClass: YAMLSet,
  default: false,
  tag: "tag:yaml.org,2002:set",
  resolve(map2, onError) {
    if (isMap(map2)) {
      if (map2.hasAllNullValues(true))
        return Object.assign(new YAMLSet(), map2);
      else
        onError("Set items must all have null values");
    } else
      onError("Expected a mapping for this tag");
    return map2;
  },
  createNode(schema4, iterable, ctx) {
    const { replacer } = ctx;
    const set2 = new YAMLSet(schema4);
    if (iterable && Symbol.iterator in Object(iterable))
      for (let value of iterable) {
        if (typeof replacer === "function")
          value = replacer.call(iterable, value, value);
        set2.items.push(createPair(value, null, ctx));
      }
    return set2;
  }
};

// node_modules/yaml/browser/dist/schema/yaml-1.1/timestamp.js
function parseSexagesimal(str, asBigInt) {
  const sign = str[0];
  const parts = sign === "-" || sign === "+" ? str.substring(1) : str;
  const num = (n) => asBigInt ? BigInt(n) : Number(n);
  const res = parts.replace(/_/g, "").split(":").reduce((res2, p) => res2 * num(60) + num(p), num(0));
  return sign === "-" ? num(-1) * res : res;
}
function stringifySexagesimal(node) {
  let { value } = node;
  let num = (n) => n;
  if (typeof value === "bigint")
    num = (n) => BigInt(n);
  else if (isNaN(value) || !isFinite(value))
    return stringifyNumber(node);
  let sign = "";
  if (value < 0) {
    sign = "-";
    value *= num(-1);
  }
  const _60 = num(60);
  const parts = [value % _60];
  if (value < 60) {
    parts.unshift(0);
  } else {
    value = (value - parts[0]) / _60;
    parts.unshift(value % _60);
    if (value >= 60) {
      value = (value - parts[0]) / _60;
      parts.unshift(value);
    }
  }
  return sign + parts.map((n) => n < 10 ? "0" + String(n) : String(n)).join(":").replace(/000000\d*$/, "");
}
var intTime = {
  identify: (value) => typeof value === "bigint" || Number.isInteger(value),
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "TIME",
  test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+$/,
  resolve: (str, _onError, { intAsBigInt }) => parseSexagesimal(str, intAsBigInt),
  stringify: stringifySexagesimal
};
var floatTime = {
  identify: (value) => typeof value === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  format: "TIME",
  test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\.[0-9_]*$/,
  resolve: (str) => parseSexagesimal(str, false),
  stringify: stringifySexagesimal
};
var timestamp = {
  identify: (value) => value instanceof Date,
  default: true,
  tag: "tag:yaml.org,2002:timestamp",
  // If the time zone is omitted, the timestamp is assumed to be specified in UTC. The time part
  // may be omitted altogether, resulting in a date format. In such a case, the time part is
  // assumed to be 00:00:00Z (start of day, UTC).
  test: RegExp("^([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})(?:(?:t|T|[ \\t]+)([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\.[0-9]+)?)(?:[ \\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?)?$"),
  resolve(str) {
    const match = str.match(timestamp.test);
    if (!match)
      throw new Error("!!timestamp expects a date, starting with yyyy-mm-dd");
    const [, year, month, day, hour, minute, second] = match.map(Number);
    const millisec = match[7] ? Number((match[7] + "00").substr(1, 3)) : 0;
    let date = Date.UTC(year, month - 1, day, hour || 0, minute || 0, second || 0, millisec);
    const tz = match[8];
    if (tz && tz !== "Z") {
      let d = parseSexagesimal(tz, false);
      if (Math.abs(d) < 30)
        d *= 60;
      date -= 6e4 * d;
    }
    return new Date(date);
  },
  stringify: ({ value }) => value.toISOString().replace(/((T00:00)?:00)?\.000Z$/, "")
};

// node_modules/yaml/browser/dist/schema/yaml-1.1/schema.js
var schema3 = [
  map,
  seq,
  string,
  nullTag,
  trueTag,
  falseTag,
  intBin,
  intOct2,
  int2,
  intHex2,
  floatNaN2,
  floatExp2,
  float2,
  binary,
  omap,
  pairs,
  set,
  intTime,
  floatTime,
  timestamp
];

// node_modules/yaml/browser/dist/schema/tags.js
var schemas = /* @__PURE__ */ new Map([
  ["core", schema],
  ["failsafe", [map, seq, string]],
  ["json", schema2],
  ["yaml11", schema3],
  ["yaml-1.1", schema3]
]);
var tagsByName = {
  binary,
  bool: boolTag,
  float,
  floatExp,
  floatNaN,
  floatTime,
  int,
  intHex,
  intOct,
  intTime,
  map,
  null: nullTag,
  omap,
  pairs,
  seq,
  set,
  timestamp
};
var coreKnownTags = {
  "tag:yaml.org,2002:binary": binary,
  "tag:yaml.org,2002:omap": omap,
  "tag:yaml.org,2002:pairs": pairs,
  "tag:yaml.org,2002:set": set,
  "tag:yaml.org,2002:timestamp": timestamp
};
function getTags(customTags, schemaName) {
  let tags = schemas.get(schemaName);
  if (!tags) {
    if (Array.isArray(customTags))
      tags = [];
    else {
      const keys = Array.from(schemas.keys()).filter((key) => key !== "yaml11").map((key) => JSON.stringify(key)).join(", ");
      throw new Error(`Unknown schema "${schemaName}"; use one of ${keys} or define customTags array`);
    }
  }
  if (Array.isArray(customTags)) {
    for (const tag2 of customTags)
      tags = tags.concat(tag2);
  } else if (typeof customTags === "function") {
    tags = customTags(tags.slice());
  }
  return tags.map((tag2) => {
    if (typeof tag2 !== "string")
      return tag2;
    const tagObj = tagsByName[tag2];
    if (tagObj)
      return tagObj;
    const keys = Object.keys(tagsByName).map((key) => JSON.stringify(key)).join(", ");
    throw new Error(`Unknown custom tag "${tag2}"; use one of ${keys}`);
  });
}

// node_modules/yaml/browser/dist/schema/Schema.js
var sortMapEntriesByKey = (a, b) => a.key < b.key ? -1 : a.key > b.key ? 1 : 0;
var Schema = class {
  constructor({ compat, customTags, merge, resolveKnownTags, schema: schema4, sortMapEntries, toStringDefaults }) {
    this.compat = Array.isArray(compat) ? getTags(compat, "compat") : compat ? getTags(null, compat) : null;
    this.merge = !!merge;
    this.name = typeof schema4 === "string" && schema4 || "core";
    this.knownTags = resolveKnownTags ? coreKnownTags : {};
    this.tags = getTags(customTags, this.name);
    this.toStringOptions = toStringDefaults || null;
    Object.defineProperty(this, MAP, { value: map });
    Object.defineProperty(this, SCALAR, { value: string });
    Object.defineProperty(this, SEQ, { value: seq });
    this.sortMapEntries = sortMapEntries === true ? sortMapEntriesByKey : sortMapEntries || null;
  }
  clone() {
    const copy = Object.create(Schema.prototype, Object.getOwnPropertyDescriptors(this));
    copy.tags = this.tags.slice();
    return copy;
  }
};

// node_modules/yaml/browser/dist/stringify/stringifyDocument.js
function stringifyDocument(doc, options) {
  const lines = [];
  let hasDirectives = options.directives === true;
  if (options.directives !== false && doc.directives) {
    const dir = doc.directives.toString(doc);
    if (dir) {
      lines.push(dir);
      hasDirectives = true;
    } else if (doc.directives.marker)
      hasDirectives = true;
  }
  if (hasDirectives)
    lines.push("---");
  const ctx = createStringifyContext(doc, options);
  const { commentString } = ctx.options;
  if (doc.commentBefore) {
    if (lines.length !== 1)
      lines.unshift("");
    const cs = commentString(doc.commentBefore);
    lines.unshift(indentComment(cs, ""));
  }
  let chompKeep = false;
  let contentComment = null;
  if (doc.contents) {
    if (isNode(doc.contents)) {
      if (doc.contents.spaceBefore && hasDirectives)
        lines.push("");
      if (doc.contents.commentBefore) {
        const cs = commentString(doc.contents.commentBefore);
        lines.push(indentComment(cs, ""));
      }
      ctx.forceBlockIndent = !!doc.comment;
      contentComment = doc.contents.comment;
    }
    const onChompKeep = contentComment ? void 0 : () => chompKeep = true;
    let body = stringify(doc.contents, ctx, () => contentComment = null, onChompKeep);
    if (contentComment)
      body += lineComment(body, "", commentString(contentComment));
    if ((body[0] === "|" || body[0] === ">") && lines[lines.length - 1] === "---") {
      lines[lines.length - 1] = `--- ${body}`;
    } else
      lines.push(body);
  } else {
    lines.push(stringify(doc.contents, ctx));
  }
  let dc = doc.comment;
  if (dc && chompKeep)
    dc = dc.replace(/^\n+/, "");
  if (dc) {
    if ((!chompKeep || contentComment) && lines[lines.length - 1] !== "")
      lines.push("");
    lines.push(indentComment(commentString(dc), ""));
  }
  return lines.join("\n") + "\n";
}

// node_modules/yaml/browser/dist/doc/applyReviver.js
function applyReviver(reviver, obj, key, val) {
  if (val && typeof val === "object") {
    if (Array.isArray(val)) {
      for (let i = 0, len = val.length; i < len; ++i) {
        const v0 = val[i];
        const v1 = applyReviver(reviver, val, String(i), v0);
        if (v1 === void 0)
          delete val[i];
        else if (v1 !== v0)
          val[i] = v1;
      }
    } else if (val instanceof Map) {
      for (const k of Array.from(val.keys())) {
        const v0 = val.get(k);
        const v1 = applyReviver(reviver, val, k, v0);
        if (v1 === void 0)
          val.delete(k);
        else if (v1 !== v0)
          val.set(k, v1);
      }
    } else if (val instanceof Set) {
      for (const v0 of Array.from(val)) {
        const v1 = applyReviver(reviver, val, v0, v0);
        if (v1 === void 0)
          val.delete(v0);
        else if (v1 !== v0) {
          val.delete(v0);
          val.add(v1);
        }
      }
    } else {
      for (const [k, v0] of Object.entries(val)) {
        const v1 = applyReviver(reviver, val, k, v0);
        if (v1 === void 0)
          delete val[k];
        else if (v1 !== v0)
          val[k] = v1;
      }
    }
  }
  return reviver.call(obj, key, val);
}

// node_modules/yaml/browser/dist/doc/Document.js
var Document = class {
  constructor(value, replacer, options) {
    this.commentBefore = null;
    this.comment = null;
    this.errors = [];
    this.warnings = [];
    Object.defineProperty(this, NODE_TYPE, { value: DOC });
    let _replacer = null;
    if (typeof replacer === "function" || Array.isArray(replacer)) {
      _replacer = replacer;
    } else if (options === void 0 && replacer) {
      options = replacer;
      replacer = void 0;
    }
    const opt = Object.assign({}, defaultOptions, options);
    this.options = opt;
    let { version } = opt;
    if (options === null || options === void 0 ? void 0 : options.directives) {
      this.directives = options.directives.atDocument();
      if (this.directives.yaml.explicit)
        version = this.directives.yaml.version;
    } else
      this.directives = new Directives({ version });
    this.setSchema(version, options);
    if (value === void 0)
      this.contents = null;
    else {
      this.contents = this.createNode(value, _replacer, options);
    }
  }
  /**
   * Create a deep copy of this Document and its contents.
   *
   * Custom Node values that inherit from `Object` still refer to their original instances.
   */
  clone() {
    const copy = Object.create(Document.prototype, {
      [NODE_TYPE]: { value: DOC }
    });
    copy.commentBefore = this.commentBefore;
    copy.comment = this.comment;
    copy.errors = this.errors.slice();
    copy.warnings = this.warnings.slice();
    copy.options = Object.assign({}, this.options);
    if (this.directives)
      copy.directives = this.directives.clone();
    copy.schema = this.schema.clone();
    copy.contents = isNode(this.contents) ? this.contents.clone(copy.schema) : this.contents;
    if (this.range)
      copy.range = this.range.slice();
    return copy;
  }
  /** Adds a value to the document. */
  add(value) {
    if (assertCollection(this.contents))
      this.contents.add(value);
  }
  /** Adds a value to the document. */
  addIn(path, value) {
    if (assertCollection(this.contents))
      this.contents.addIn(path, value);
  }
  /**
   * Create a new `Alias` node, ensuring that the target `node` has the required anchor.
   *
   * If `node` already has an anchor, `name` is ignored.
   * Otherwise, the `node.anchor` value will be set to `name`,
   * or if an anchor with that name is already present in the document,
   * `name` will be used as a prefix for a new unique anchor.
   * If `name` is undefined, the generated anchor will use 'a' as a prefix.
   */
  createAlias(node, name) {
    if (!node.anchor) {
      const prev = anchorNames(this);
      node.anchor = !name || prev.has(name) ? findNewAnchor(name || "a", prev) : name;
    }
    return new Alias(node.anchor);
  }
  createNode(value, replacer, options) {
    let _replacer = void 0;
    if (typeof replacer === "function") {
      value = replacer.call({ "": value }, "", value);
      _replacer = replacer;
    } else if (Array.isArray(replacer)) {
      const keyToStr = (v) => typeof v === "number" || v instanceof String || v instanceof Number;
      const asStr = replacer.filter(keyToStr).map(String);
      if (asStr.length > 0)
        replacer = replacer.concat(asStr);
      _replacer = replacer;
    } else if (options === void 0 && replacer) {
      options = replacer;
      replacer = void 0;
    }
    const { aliasDuplicateObjects, anchorPrefix, flow, keepUndefined, onTagObj, tag: tag2 } = options || {};
    const { onAnchor, setAnchors, sourceObjects } = createNodeAnchors(this, anchorPrefix || "a");
    const ctx = {
      aliasDuplicateObjects: aliasDuplicateObjects !== null && aliasDuplicateObjects !== void 0 ? aliasDuplicateObjects : true,
      keepUndefined: keepUndefined !== null && keepUndefined !== void 0 ? keepUndefined : false,
      onAnchor,
      onTagObj,
      replacer: _replacer,
      schema: this.schema,
      sourceObjects
    };
    const node = createNode(value, tag2, ctx);
    if (flow && isCollection(node))
      node.flow = true;
    setAnchors();
    return node;
  }
  /**
   * Convert a key and a value into a `Pair` using the current schema,
   * recursively wrapping all values as `Scalar` or `Collection` nodes.
   */
  createPair(key, value, options = {}) {
    const k = this.createNode(key, null, options);
    const v = this.createNode(value, null, options);
    return new Pair(k, v);
  }
  /**
   * Removes a value from the document.
   * @returns `true` if the item was found and removed.
   */
  delete(key) {
    return assertCollection(this.contents) ? this.contents.delete(key) : false;
  }
  /**
   * Removes a value from the document.
   * @returns `true` if the item was found and removed.
   */
  deleteIn(path) {
    if (isEmptyPath(path)) {
      if (this.contents == null)
        return false;
      this.contents = null;
      return true;
    }
    return assertCollection(this.contents) ? this.contents.deleteIn(path) : false;
  }
  /**
   * Returns item at `key`, or `undefined` if not found. By default unwraps
   * scalar values from their surrounding node; to disable set `keepScalar` to
   * `true` (collections are always returned intact).
   */
  get(key, keepScalar) {
    return isCollection(this.contents) ? this.contents.get(key, keepScalar) : void 0;
  }
  /**
   * Returns item at `path`, or `undefined` if not found. By default unwraps
   * scalar values from their surrounding node; to disable set `keepScalar` to
   * `true` (collections are always returned intact).
   */
  getIn(path, keepScalar) {
    if (isEmptyPath(path))
      return !keepScalar && isScalar(this.contents) ? this.contents.value : this.contents;
    return isCollection(this.contents) ? this.contents.getIn(path, keepScalar) : void 0;
  }
  /**
   * Checks if the document includes a value with the key `key`.
   */
  has(key) {
    return isCollection(this.contents) ? this.contents.has(key) : false;
  }
  /**
   * Checks if the document includes a value at `path`.
   */
  hasIn(path) {
    if (isEmptyPath(path))
      return this.contents !== void 0;
    return isCollection(this.contents) ? this.contents.hasIn(path) : false;
  }
  /**
   * Sets a value in this document. For `!!set`, `value` needs to be a
   * boolean to add/remove the item from the set.
   */
  set(key, value) {
    if (this.contents == null) {
      this.contents = collectionFromPath(this.schema, [key], value);
    } else if (assertCollection(this.contents)) {
      this.contents.set(key, value);
    }
  }
  /**
   * Sets a value in this document. For `!!set`, `value` needs to be a
   * boolean to add/remove the item from the set.
   */
  setIn(path, value) {
    if (isEmptyPath(path))
      this.contents = value;
    else if (this.contents == null) {
      this.contents = collectionFromPath(this.schema, Array.from(path), value);
    } else if (assertCollection(this.contents)) {
      this.contents.setIn(path, value);
    }
  }
  /**
   * Change the YAML version and schema used by the document.
   * A `null` version disables support for directives, explicit tags, anchors, and aliases.
   * It also requires the `schema` option to be given as a `Schema` instance value.
   *
   * Overrides all previously set schema options.
   */
  setSchema(version, options = {}) {
    if (typeof version === "number")
      version = String(version);
    let opt;
    switch (version) {
      case "1.1":
        if (this.directives)
          this.directives.yaml.version = "1.1";
        else
          this.directives = new Directives({ version: "1.1" });
        opt = { merge: true, resolveKnownTags: false, schema: "yaml-1.1" };
        break;
      case "1.2":
        if (this.directives)
          this.directives.yaml.version = "1.2";
        else
          this.directives = new Directives({ version: "1.2" });
        opt = { merge: false, resolveKnownTags: true, schema: "core" };
        break;
      case null:
        if (this.directives)
          delete this.directives;
        opt = null;
        break;
      default: {
        const sv = JSON.stringify(version);
        throw new Error(`Expected '1.1', '1.2' or null as first argument, but found: ${sv}`);
      }
    }
    if (options.schema instanceof Object)
      this.schema = options.schema;
    else if (opt)
      this.schema = new Schema(Object.assign(opt, options));
    else
      throw new Error(`With a null YAML version, the { schema: Schema } option is required`);
  }
  // json & jsonArg are only used from toJSON()
  toJS({ json, jsonArg, mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {
    const ctx = {
      anchors: /* @__PURE__ */ new Map(),
      doc: this,
      keep: !json,
      mapAsMap: mapAsMap === true,
      mapKeyWarned: false,
      maxAliasCount: typeof maxAliasCount === "number" ? maxAliasCount : 100,
      stringify
    };
    const res = toJS(this.contents, jsonArg || "", ctx);
    if (typeof onAnchor === "function")
      for (const { count, res: res2 } of ctx.anchors.values())
        onAnchor(res2, count);
    return typeof reviver === "function" ? applyReviver(reviver, { "": res }, "", res) : res;
  }
  /**
   * A JSON representation of the document `contents`.
   *
   * @param jsonArg Used by `JSON.stringify` to indicate the array index or
   *   property name.
   */
  toJSON(jsonArg, onAnchor) {
    return this.toJS({ json: true, jsonArg, mapAsMap: false, onAnchor });
  }
  /** A YAML representation of the document. */
  toString(options = {}) {
    if (this.errors.length > 0)
      throw new Error("Document with errors cannot be stringified");
    if ("indent" in options && (!Number.isInteger(options.indent) || Number(options.indent) <= 0)) {
      const s = JSON.stringify(options.indent);
      throw new Error(`"indent" option must be a positive integer, not ${s}`);
    }
    return stringifyDocument(this, options);
  }
};
function assertCollection(contents) {
  if (isCollection(contents))
    return true;
  throw new Error("Expected a YAML collection as document contents");
}

// node_modules/yaml/browser/dist/errors.js
var YAMLError = class extends Error {
  constructor(name, pos, code, message) {
    super();
    this.name = name;
    this.code = code;
    this.message = message;
    this.pos = pos;
  }
};
var YAMLParseError = class extends YAMLError {
  constructor(pos, code, message) {
    super("YAMLParseError", pos, code, message);
  }
};
var YAMLWarning = class extends YAMLError {
  constructor(pos, code, message) {
    super("YAMLWarning", pos, code, message);
  }
};
var prettifyError = (src, lc) => (error) => {
  if (error.pos[0] === -1)
    return;
  error.linePos = error.pos.map((pos) => lc.linePos(pos));
  const { line, col } = error.linePos[0];
  error.message += ` at line ${line}, column ${col}`;
  let ci = col - 1;
  let lineStr = src.substring(lc.lineStarts[line - 1], lc.lineStarts[line]).replace(/[\n\r]+$/, "");
  if (ci >= 60 && lineStr.length > 80) {
    const trimStart = Math.min(ci - 39, lineStr.length - 79);
    lineStr = "\u2026" + lineStr.substring(trimStart);
    ci -= trimStart - 1;
  }
  if (lineStr.length > 80)
    lineStr = lineStr.substring(0, 79) + "\u2026";
  if (line > 1 && /^ *$/.test(lineStr.substring(0, ci))) {
    let prev = src.substring(lc.lineStarts[line - 2], lc.lineStarts[line - 1]);
    if (prev.length > 80)
      prev = prev.substring(0, 79) + "\u2026\n";
    lineStr = prev + lineStr;
  }
  if (/[^ ]/.test(lineStr)) {
    let count = 1;
    const end = error.linePos[1];
    if (end && end.line === line && end.col > col) {
      count = Math.min(end.col - col, 80 - ci);
    }
    const pointer = " ".repeat(ci) + "^".repeat(count);
    error.message += `:

${lineStr}
${pointer}
`;
  }
};

// node_modules/yaml/browser/dist/compose/resolve-props.js
function resolveProps(tokens, { flow, indicator, next, offset, onError, startOnNewline }) {
  let spaceBefore = false;
  let atNewline = startOnNewline;
  let hasSpace = startOnNewline;
  let comment = "";
  let commentSep = "";
  let hasNewline = false;
  let reqSpace = false;
  let anchor = null;
  let tag2 = null;
  let comma = null;
  let found = null;
  let start = null;
  for (const token of tokens) {
    if (reqSpace) {
      if (token.type !== "space" && token.type !== "newline" && token.type !== "comma")
        onError(token.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space");
      reqSpace = false;
    }
    switch (token.type) {
      case "space":
        if (!flow && atNewline && indicator !== "doc-start" && token.source[0] === "	")
          onError(token, "TAB_AS_INDENT", "Tabs are not allowed as indentation");
        hasSpace = true;
        break;
      case "comment": {
        if (!hasSpace)
          onError(token, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
        const cb = token.source.substring(1) || " ";
        if (!comment)
          comment = cb;
        else
          comment += commentSep + cb;
        commentSep = "";
        atNewline = false;
        break;
      }
      case "newline":
        if (atNewline) {
          if (comment)
            comment += token.source;
          else
            spaceBefore = true;
        } else
          commentSep += token.source;
        atNewline = true;
        hasNewline = true;
        hasSpace = true;
        break;
      case "anchor":
        if (anchor)
          onError(token, "MULTIPLE_ANCHORS", "A node can have at most one anchor");
        anchor = token;
        if (start === null)
          start = token.offset;
        atNewline = false;
        hasSpace = false;
        reqSpace = true;
        break;
      case "tag": {
        if (tag2)
          onError(token, "MULTIPLE_TAGS", "A node can have at most one tag");
        tag2 = token;
        if (start === null)
          start = token.offset;
        atNewline = false;
        hasSpace = false;
        reqSpace = true;
        break;
      }
      case indicator:
        if (anchor || tag2)
          onError(token, "BAD_PROP_ORDER", `Anchors and tags must be after the ${token.source} indicator`);
        if (found)
          onError(token, "UNEXPECTED_TOKEN", `Unexpected ${token.source} in ${flow || "collection"}`);
        found = token;
        atNewline = false;
        hasSpace = false;
        break;
      case "comma":
        if (flow) {
          if (comma)
            onError(token, "UNEXPECTED_TOKEN", `Unexpected , in ${flow}`);
          comma = token;
          atNewline = false;
          hasSpace = false;
          break;
        }
      default:
        onError(token, "UNEXPECTED_TOKEN", `Unexpected ${token.type} token`);
        atNewline = false;
        hasSpace = false;
    }
  }
  const last = tokens[tokens.length - 1];
  const end = last ? last.offset + last.source.length : offset;
  if (reqSpace && next && next.type !== "space" && next.type !== "newline" && next.type !== "comma" && (next.type !== "scalar" || next.source !== ""))
    onError(next.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space");
  return {
    comma,
    found,
    spaceBefore,
    comment,
    hasNewline,
    anchor,
    tag: tag2,
    end,
    start: start !== null && start !== void 0 ? start : end
  };
}

// node_modules/yaml/browser/dist/compose/util-contains-newline.js
function containsNewline(key) {
  if (!key)
    return null;
  switch (key.type) {
    case "alias":
    case "scalar":
    case "double-quoted-scalar":
    case "single-quoted-scalar":
      if (key.source.includes("\n"))
        return true;
      if (key.end) {
        for (const st of key.end)
          if (st.type === "newline")
            return true;
      }
      return false;
    case "flow-collection":
      for (const it of key.items) {
        for (const st of it.start)
          if (st.type === "newline")
            return true;
        if (it.sep) {
          for (const st of it.sep)
            if (st.type === "newline")
              return true;
        }
        if (containsNewline(it.key) || containsNewline(it.value))
          return true;
      }
      return false;
    default:
      return true;
  }
}

// node_modules/yaml/browser/dist/compose/util-flow-indent-check.js
function flowIndentCheck(indent, fc, onError) {
  if ((fc === null || fc === void 0 ? void 0 : fc.type) === "flow-collection") {
    const end = fc.end[0];
    if (end.indent === indent && (end.source === "]" || end.source === "}") && containsNewline(fc)) {
      const msg = "Flow end indicator should be more indented than parent";
      onError(end, "BAD_INDENT", msg, true);
    }
  }
}

// node_modules/yaml/browser/dist/compose/util-map-includes.js
function mapIncludes(ctx, items, search) {
  const { uniqueKeys } = ctx.options;
  if (uniqueKeys === false)
    return false;
  const isEqual = typeof uniqueKeys === "function" ? uniqueKeys : (a, b) => a === b || isScalar(a) && isScalar(b) && a.value === b.value && !(a.value === "<<" && ctx.schema.merge);
  return items.some((pair) => isEqual(pair.key, search));
}

// node_modules/yaml/browser/dist/compose/resolve-block-map.js
var startColMsg = "All mapping items must start at the same column";
function resolveBlockMap({ composeNode: composeNode2, composeEmptyNode: composeEmptyNode2 }, ctx, bm, onError) {
  var _a;
  const map2 = new YAMLMap(ctx.schema);
  if (ctx.atRoot)
    ctx.atRoot = false;
  let offset = bm.offset;
  for (const collItem of bm.items) {
    const { start, key, sep, value } = collItem;
    const keyProps = resolveProps(start, {
      indicator: "explicit-key-ind",
      next: key || (sep === null || sep === void 0 ? void 0 : sep[0]),
      offset,
      onError,
      startOnNewline: true
    });
    const implicitKey = !keyProps.found;
    if (implicitKey) {
      if (key) {
        if (key.type === "block-seq")
          onError(offset, "BLOCK_AS_IMPLICIT_KEY", "A block sequence may not be used as an implicit map key");
        else if ("indent" in key && key.indent !== bm.indent)
          onError(offset, "BAD_INDENT", startColMsg);
      }
      if (!keyProps.anchor && !keyProps.tag && !sep) {
        if (keyProps.comment) {
          if (map2.comment)
            map2.comment += "\n" + keyProps.comment;
          else
            map2.comment = keyProps.comment;
        }
        continue;
      }
    } else if (((_a = keyProps.found) === null || _a === void 0 ? void 0 : _a.indent) !== bm.indent)
      onError(offset, "BAD_INDENT", startColMsg);
    if (implicitKey && containsNewline(key))
      onError(
        key,
        // checked by containsNewline()
        "MULTILINE_IMPLICIT_KEY",
        "Implicit keys need to be on a single line"
      );
    const keyStart = keyProps.end;
    const keyNode = key ? composeNode2(ctx, key, keyProps, onError) : composeEmptyNode2(ctx, keyStart, start, null, keyProps, onError);
    if (ctx.schema.compat)
      flowIndentCheck(bm.indent, key, onError);
    if (mapIncludes(ctx, map2.items, keyNode))
      onError(keyStart, "DUPLICATE_KEY", "Map keys must be unique");
    const valueProps = resolveProps(sep || [], {
      indicator: "map-value-ind",
      next: value,
      offset: keyNode.range[2],
      onError,
      startOnNewline: !key || key.type === "block-scalar"
    });
    offset = valueProps.end;
    if (valueProps.found) {
      if (implicitKey) {
        if ((value === null || value === void 0 ? void 0 : value.type) === "block-map" && !valueProps.hasNewline)
          onError(offset, "BLOCK_AS_IMPLICIT_KEY", "Nested mappings are not allowed in compact mappings");
        if (ctx.options.strict && keyProps.start < valueProps.found.offset - 1024)
          onError(keyNode.range, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit block mapping key");
      }
      const valueNode = value ? composeNode2(ctx, value, valueProps, onError) : composeEmptyNode2(ctx, offset, sep, null, valueProps, onError);
      if (ctx.schema.compat)
        flowIndentCheck(bm.indent, value, onError);
      offset = valueNode.range[2];
      const pair = new Pair(keyNode, valueNode);
      if (ctx.options.keepSourceTokens)
        pair.srcToken = collItem;
      map2.items.push(pair);
    } else {
      if (implicitKey)
        onError(keyNode.range, "MISSING_CHAR", "Implicit map keys need to be followed by map values");
      if (valueProps.comment) {
        if (keyNode.comment)
          keyNode.comment += "\n" + valueProps.comment;
        else
          keyNode.comment = valueProps.comment;
      }
      const pair = new Pair(keyNode);
      if (ctx.options.keepSourceTokens)
        pair.srcToken = collItem;
      map2.items.push(pair);
    }
  }
  map2.range = [bm.offset, offset, offset];
  return map2;
}

// node_modules/yaml/browser/dist/compose/resolve-block-seq.js
function resolveBlockSeq({ composeNode: composeNode2, composeEmptyNode: composeEmptyNode2 }, ctx, bs, onError) {
  const seq2 = new YAMLSeq(ctx.schema);
  if (ctx.atRoot)
    ctx.atRoot = false;
  let offset = bs.offset;
  for (const { start, value } of bs.items) {
    const props = resolveProps(start, {
      indicator: "seq-item-ind",
      next: value,
      offset,
      onError,
      startOnNewline: true
    });
    offset = props.end;
    if (!props.found) {
      if (props.anchor || props.tag || value) {
        if (value && value.type === "block-seq")
          onError(offset, "BAD_INDENT", "All sequence items must start at the same column");
        else
          onError(offset, "MISSING_CHAR", "Sequence item without - indicator");
      } else {
        if (props.comment)
          seq2.comment = props.comment;
        continue;
      }
    }
    const node = value ? composeNode2(ctx, value, props, onError) : composeEmptyNode2(ctx, offset, start, null, props, onError);
    if (ctx.schema.compat)
      flowIndentCheck(bs.indent, value, onError);
    offset = node.range[2];
    seq2.items.push(node);
  }
  seq2.range = [bs.offset, offset, offset];
  return seq2;
}

// node_modules/yaml/browser/dist/compose/resolve-end.js
function resolveEnd(end, offset, reqSpace, onError) {
  let comment = "";
  if (end) {
    let hasSpace = false;
    let sep = "";
    for (const token of end) {
      const { source, type } = token;
      switch (type) {
        case "space":
          hasSpace = true;
          break;
        case "comment": {
          if (reqSpace && !hasSpace)
            onError(token, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
          const cb = source.substring(1) || " ";
          if (!comment)
            comment = cb;
          else
            comment += sep + cb;
          sep = "";
          break;
        }
        case "newline":
          if (comment)
            sep += source;
          hasSpace = true;
          break;
        default:
          onError(token, "UNEXPECTED_TOKEN", `Unexpected ${type} at node end`);
      }
      offset += source.length;
    }
  }
  return { comment, offset };
}

// node_modules/yaml/browser/dist/compose/resolve-flow-collection.js
var blockMsg = "Block collections are not allowed within flow collections";
var isBlock = (token) => token && (token.type === "block-map" || token.type === "block-seq");
function resolveFlowCollection({ composeNode: composeNode2, composeEmptyNode: composeEmptyNode2 }, ctx, fc, onError) {
  const isMap2 = fc.start.source === "{";
  const fcName = isMap2 ? "flow map" : "flow sequence";
  const coll = isMap2 ? new YAMLMap(ctx.schema) : new YAMLSeq(ctx.schema);
  coll.flow = true;
  const atRoot = ctx.atRoot;
  if (atRoot)
    ctx.atRoot = false;
  let offset = fc.offset + fc.start.source.length;
  for (let i = 0; i < fc.items.length; ++i) {
    const collItem = fc.items[i];
    const { start, key, sep, value } = collItem;
    const props = resolveProps(start, {
      flow: fcName,
      indicator: "explicit-key-ind",
      next: key || (sep === null || sep === void 0 ? void 0 : sep[0]),
      offset,
      onError,
      startOnNewline: false
    });
    if (!props.found) {
      if (!props.anchor && !props.tag && !sep && !value) {
        if (i === 0 && props.comma)
          onError(props.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${fcName}`);
        else if (i < fc.items.length - 1)
          onError(props.start, "UNEXPECTED_TOKEN", `Unexpected empty item in ${fcName}`);
        if (props.comment) {
          if (coll.comment)
            coll.comment += "\n" + props.comment;
          else
            coll.comment = props.comment;
        }
        offset = props.end;
        continue;
      }
      if (!isMap2 && ctx.options.strict && containsNewline(key))
        onError(
          key,
          // checked by containsNewline()
          "MULTILINE_IMPLICIT_KEY",
          "Implicit keys of flow sequence pairs need to be on a single line"
        );
    }
    if (i === 0) {
      if (props.comma)
        onError(props.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${fcName}`);
    } else {
      if (!props.comma)
        onError(props.start, "MISSING_CHAR", `Missing , between ${fcName} items`);
      if (props.comment) {
        let prevItemComment = "";
        loop:
          for (const st of start) {
            switch (st.type) {
              case "comma":
              case "space":
                break;
              case "comment":
                prevItemComment = st.source.substring(1);
                break loop;
              default:
                break loop;
            }
          }
        if (prevItemComment) {
          let prev = coll.items[coll.items.length - 1];
          if (isPair(prev))
            prev = prev.value || prev.key;
          if (prev.comment)
            prev.comment += "\n" + prevItemComment;
          else
            prev.comment = prevItemComment;
          props.comment = props.comment.substring(prevItemComment.length + 1);
        }
      }
    }
    if (!isMap2 && !sep && !props.found) {
      const valueNode = value ? composeNode2(ctx, value, props, onError) : composeEmptyNode2(ctx, props.end, sep, null, props, onError);
      coll.items.push(valueNode);
      offset = valueNode.range[2];
      if (isBlock(value))
        onError(valueNode.range, "BLOCK_IN_FLOW", blockMsg);
    } else {
      const keyStart = props.end;
      const keyNode = key ? composeNode2(ctx, key, props, onError) : composeEmptyNode2(ctx, keyStart, start, null, props, onError);
      if (isBlock(key))
        onError(keyNode.range, "BLOCK_IN_FLOW", blockMsg);
      const valueProps = resolveProps(sep || [], {
        flow: fcName,
        indicator: "map-value-ind",
        next: value,
        offset: keyNode.range[2],
        onError,
        startOnNewline: false
      });
      if (valueProps.found) {
        if (!isMap2 && !props.found && ctx.options.strict) {
          if (sep)
            for (const st of sep) {
              if (st === valueProps.found)
                break;
              if (st.type === "newline") {
                onError(st, "MULTILINE_IMPLICIT_KEY", "Implicit keys of flow sequence pairs need to be on a single line");
                break;
              }
            }
          if (props.start < valueProps.found.offset - 1024)
            onError(valueProps.found, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit flow sequence key");
        }
      } else if (value) {
        if ("source" in value && value.source && value.source[0] === ":")
          onError(value, "MISSING_CHAR", `Missing space after : in ${fcName}`);
        else
          onError(valueProps.start, "MISSING_CHAR", `Missing , or : between ${fcName} items`);
      }
      const valueNode = value ? composeNode2(ctx, value, valueProps, onError) : valueProps.found ? composeEmptyNode2(ctx, valueProps.end, sep, null, valueProps, onError) : null;
      if (valueNode) {
        if (isBlock(value))
          onError(valueNode.range, "BLOCK_IN_FLOW", blockMsg);
      } else if (valueProps.comment) {
        if (keyNode.comment)
          keyNode.comment += "\n" + valueProps.comment;
        else
          keyNode.comment = valueProps.comment;
      }
      const pair = new Pair(keyNode, valueNode);
      if (ctx.options.keepSourceTokens)
        pair.srcToken = collItem;
      if (isMap2) {
        const map2 = coll;
        if (mapIncludes(ctx, map2.items, keyNode))
          onError(keyStart, "DUPLICATE_KEY", "Map keys must be unique");
        map2.items.push(pair);
      } else {
        const map2 = new YAMLMap(ctx.schema);
        map2.flow = true;
        map2.items.push(pair);
        coll.items.push(map2);
      }
      offset = valueNode ? valueNode.range[2] : valueProps.end;
    }
  }
  const expectedEnd = isMap2 ? "}" : "]";
  const [ce, ...ee] = fc.end;
  let cePos = offset;
  if (ce && ce.source === expectedEnd)
    cePos = ce.offset + ce.source.length;
  else {
    const name = fcName[0].toUpperCase() + fcName.substring(1);
    const msg = atRoot ? `${name} must end with a ${expectedEnd}` : `${name} in block collection must be sufficiently indented and end with a ${expectedEnd}`;
    onError(offset, atRoot ? "MISSING_CHAR" : "BAD_INDENT", msg);
    if (ce && ce.source.length !== 1)
      ee.unshift(ce);
  }
  if (ee.length > 0) {
    const end = resolveEnd(ee, cePos, ctx.options.strict, onError);
    if (end.comment) {
      if (coll.comment)
        coll.comment += "\n" + end.comment;
      else
        coll.comment = end.comment;
    }
    coll.range = [fc.offset, cePos, end.offset];
  } else {
    coll.range = [fc.offset, cePos, cePos];
  }
  return coll;
}

// node_modules/yaml/browser/dist/compose/compose-collection.js
function composeCollection(CN2, ctx, token, tagToken, onError) {
  let coll;
  switch (token.type) {
    case "block-map": {
      coll = resolveBlockMap(CN2, ctx, token, onError);
      break;
    }
    case "block-seq": {
      coll = resolveBlockSeq(CN2, ctx, token, onError);
      break;
    }
    case "flow-collection": {
      coll = resolveFlowCollection(CN2, ctx, token, onError);
      break;
    }
  }
  if (!tagToken)
    return coll;
  const tagName = ctx.directives.tagName(tagToken.source, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg));
  if (!tagName)
    return coll;
  const Coll = coll.constructor;
  if (tagName === "!" || tagName === Coll.tagName) {
    coll.tag = Coll.tagName;
    return coll;
  }
  const expType = isMap(coll) ? "map" : "seq";
  let tag2 = ctx.schema.tags.find((t) => t.collection === expType && t.tag === tagName);
  if (!tag2) {
    const kt = ctx.schema.knownTags[tagName];
    if (kt && kt.collection === expType) {
      ctx.schema.tags.push(Object.assign({}, kt, { default: false }));
      tag2 = kt;
    } else {
      onError(tagToken, "TAG_RESOLVE_FAILED", `Unresolved tag: ${tagName}`, true);
      coll.tag = tagName;
      return coll;
    }
  }
  const res = tag2.resolve(coll, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg), ctx.options);
  const node = isNode(res) ? res : new Scalar(res);
  node.range = coll.range;
  node.tag = tagName;
  if (tag2 === null || tag2 === void 0 ? void 0 : tag2.format)
    node.format = tag2.format;
  return node;
}

// node_modules/yaml/browser/dist/compose/resolve-block-scalar.js
function resolveBlockScalar(scalar, strict, onError) {
  const start = scalar.offset;
  const header = parseBlockScalarHeader(scalar, strict, onError);
  if (!header)
    return { value: "", type: null, comment: "", range: [start, start, start] };
  const type = header.mode === ">" ? Scalar.BLOCK_FOLDED : Scalar.BLOCK_LITERAL;
  const lines = scalar.source ? splitLines(scalar.source) : [];
  let chompStart = lines.length;
  for (let i = lines.length - 1; i >= 0; --i) {
    const content = lines[i][1];
    if (content === "" || content === "\r")
      chompStart = i;
    else
      break;
  }
  if (!scalar.source || chompStart === 0) {
    const value2 = header.chomp === "+" ? "\n".repeat(Math.max(0, lines.length - 1)) : "";
    let end2 = start + header.length;
    if (scalar.source)
      end2 += scalar.source.length;
    return { value: value2, type, comment: header.comment, range: [start, end2, end2] };
  }
  let trimIndent = scalar.indent + header.indent;
  let offset = scalar.offset + header.length;
  let contentStart = 0;
  for (let i = 0; i < chompStart; ++i) {
    const [indent, content] = lines[i];
    if (content === "" || content === "\r") {
      if (header.indent === 0 && indent.length > trimIndent)
        trimIndent = indent.length;
    } else {
      if (indent.length < trimIndent) {
        const message = "Block scalars with more-indented leading empty lines must use an explicit indentation indicator";
        onError(offset + indent.length, "MISSING_CHAR", message);
      }
      if (header.indent === 0)
        trimIndent = indent.length;
      contentStart = i;
      break;
    }
    offset += indent.length + content.length + 1;
  }
  let value = "";
  let sep = "";
  let prevMoreIndented = false;
  for (let i = 0; i < contentStart; ++i)
    value += lines[i][0].slice(trimIndent) + "\n";
  for (let i = contentStart; i < chompStart; ++i) {
    let [indent, content] = lines[i];
    offset += indent.length + content.length + 1;
    const crlf = content[content.length - 1] === "\r";
    if (crlf)
      content = content.slice(0, -1);
    if (content && indent.length < trimIndent) {
      const src = header.indent ? "explicit indentation indicator" : "first line";
      const message = `Block scalar lines must not be less indented than their ${src}`;
      onError(offset - content.length - (crlf ? 2 : 1), "BAD_INDENT", message);
      indent = "";
    }
    if (type === Scalar.BLOCK_LITERAL) {
      value += sep + indent.slice(trimIndent) + content;
      sep = "\n";
    } else if (indent.length > trimIndent || content[0] === "	") {
      if (sep === " ")
        sep = "\n";
      else if (!prevMoreIndented && sep === "\n")
        sep = "\n\n";
      value += sep + indent.slice(trimIndent) + content;
      sep = "\n";
      prevMoreIndented = true;
    } else if (content === "") {
      if (sep === "\n")
        value += "\n";
      else
        sep = "\n";
    } else {
      value += sep + content;
      sep = " ";
      prevMoreIndented = false;
    }
  }
  switch (header.chomp) {
    case "-":
      break;
    case "+":
      for (let i = chompStart; i < lines.length; ++i)
        value += "\n" + lines[i][0].slice(trimIndent);
      if (value[value.length - 1] !== "\n")
        value += "\n";
      break;
    default:
      value += "\n";
  }
  const end = start + header.length + scalar.source.length;
  return { value, type, comment: header.comment, range: [start, end, end] };
}
function parseBlockScalarHeader({ offset, props }, strict, onError) {
  if (props[0].type !== "block-scalar-header") {
    onError(props[0], "IMPOSSIBLE", "Block scalar header not found");
    return null;
  }
  const { source } = props[0];
  const mode = source[0];
  let indent = 0;
  let chomp = "";
  let error = -1;
  for (let i = 1; i < source.length; ++i) {
    const ch = source[i];
    if (!chomp && (ch === "-" || ch === "+"))
      chomp = ch;
    else {
      const n = Number(ch);
      if (!indent && n)
        indent = n;
      else if (error === -1)
        error = offset + i;
    }
  }
  if (error !== -1)
    onError(error, "UNEXPECTED_TOKEN", `Block scalar header includes extra characters: ${source}`);
  let hasSpace = false;
  let comment = "";
  let length = source.length;
  for (let i = 1; i < props.length; ++i) {
    const token = props[i];
    switch (token.type) {
      case "space":
        hasSpace = true;
      case "newline":
        length += token.source.length;
        break;
      case "comment":
        if (strict && !hasSpace) {
          const message = "Comments must be separated from other tokens by white space characters";
          onError(token, "MISSING_CHAR", message);
        }
        length += token.source.length;
        comment = token.source.substring(1);
        break;
      case "error":
        onError(token, "UNEXPECTED_TOKEN", token.message);
        length += token.source.length;
        break;
      default: {
        const message = `Unexpected token in block scalar header: ${token.type}`;
        onError(token, "UNEXPECTED_TOKEN", message);
        const ts = token.source;
        if (ts && typeof ts === "string")
          length += ts.length;
      }
    }
  }
  return { mode, indent, chomp, comment, length };
}
function splitLines(source) {
  const split = source.split(/\n( *)/);
  const first = split[0];
  const m = first.match(/^( *)/);
  const line0 = m && m[1] ? [m[1], first.slice(m[1].length)] : ["", first];
  const lines = [line0];
  for (let i = 1; i < split.length; i += 2)
    lines.push([split[i], split[i + 1]]);
  return lines;
}

// node_modules/yaml/browser/dist/compose/resolve-flow-scalar.js
function resolveFlowScalar(scalar, strict, onError) {
  const { offset, type, source, end } = scalar;
  let _type;
  let value;
  const _onError = (rel, code, msg) => onError(offset + rel, code, msg);
  switch (type) {
    case "scalar":
      _type = Scalar.PLAIN;
      value = plainValue(source, _onError);
      break;
    case "single-quoted-scalar":
      _type = Scalar.QUOTE_SINGLE;
      value = singleQuotedValue(source, _onError);
      break;
    case "double-quoted-scalar":
      _type = Scalar.QUOTE_DOUBLE;
      value = doubleQuotedValue(source, _onError);
      break;
    default:
      onError(scalar, "UNEXPECTED_TOKEN", `Expected a flow scalar value, but found: ${type}`);
      return {
        value: "",
        type: null,
        comment: "",
        range: [offset, offset + source.length, offset + source.length]
      };
  }
  const valueEnd = offset + source.length;
  const re = resolveEnd(end, valueEnd, strict, onError);
  return {
    value,
    type: _type,
    comment: re.comment,
    range: [offset, valueEnd, re.offset]
  };
}
function plainValue(source, onError) {
  let badChar = "";
  switch (source[0]) {
    case "	":
      badChar = "a tab character";
      break;
    case ",":
      badChar = "flow indicator character ,";
      break;
    case "%":
      badChar = "directive indicator character %";
      break;
    case "|":
    case ">": {
      badChar = `block scalar indicator ${source[0]}`;
      break;
    }
    case "@":
    case "`": {
      badChar = `reserved character ${source[0]}`;
      break;
    }
  }
  if (badChar)
    onError(0, "BAD_SCALAR_START", `Plain value cannot start with ${badChar}`);
  return foldLines(source);
}
function singleQuotedValue(source, onError) {
  if (source[source.length - 1] !== "'" || source.length === 1)
    onError(source.length, "MISSING_CHAR", "Missing closing 'quote");
  return foldLines(source.slice(1, -1)).replace(/''/g, "'");
}
function foldLines(source) {
  let first, line;
  try {
    first = new RegExp("(.*?)(?<![ 	])[ 	]*\r?\n", "sy");
    line = new RegExp("[ 	]*(.*?)(?:(?<![ 	])[ 	]*)?\r?\n", "sy");
  } catch (_) {
    first = /(.*?)[ \t]*\r?\n/sy;
    line = /[ \t]*(.*?)[ \t]*\r?\n/sy;
  }
  let match = first.exec(source);
  if (!match)
    return source;
  let res = match[1];
  let sep = " ";
  let pos = first.lastIndex;
  line.lastIndex = pos;
  while (match = line.exec(source)) {
    if (match[1] === "") {
      if (sep === "\n")
        res += sep;
      else
        sep = "\n";
    } else {
      res += sep + match[1];
      sep = " ";
    }
    pos = line.lastIndex;
  }
  const last = /[ \t]*(.*)/sy;
  last.lastIndex = pos;
  match = last.exec(source);
  return res + sep + (match && match[1] || "");
}
function doubleQuotedValue(source, onError) {
  let res = "";
  for (let i = 1; i < source.length - 1; ++i) {
    const ch = source[i];
    if (ch === "\r" && source[i + 1] === "\n")
      continue;
    if (ch === "\n") {
      const { fold, offset } = foldNewline(source, i);
      res += fold;
      i = offset;
    } else if (ch === "\\") {
      let next = source[++i];
      const cc = escapeCodes[next];
      if (cc)
        res += cc;
      else if (next === "\n") {
        next = source[i + 1];
        while (next === " " || next === "	")
          next = source[++i + 1];
      } else if (next === "\r" && source[i + 1] === "\n") {
        next = source[++i + 1];
        while (next === " " || next === "	")
          next = source[++i + 1];
      } else if (next === "x" || next === "u" || next === "U") {
        const length = { x: 2, u: 4, U: 8 }[next];
        res += parseCharCode(source, i + 1, length, onError);
        i += length;
      } else {
        const raw = source.substr(i - 1, 2);
        onError(i - 1, "BAD_DQ_ESCAPE", `Invalid escape sequence ${raw}`);
        res += raw;
      }
    } else if (ch === " " || ch === "	") {
      const wsStart = i;
      let next = source[i + 1];
      while (next === " " || next === "	")
        next = source[++i + 1];
      if (next !== "\n" && !(next === "\r" && source[i + 2] === "\n"))
        res += i > wsStart ? source.slice(wsStart, i + 1) : ch;
    } else {
      res += ch;
    }
  }
  if (source[source.length - 1] !== '"' || source.length === 1)
    onError(source.length, "MISSING_CHAR", 'Missing closing "quote');
  return res;
}
function foldNewline(source, offset) {
  let fold = "";
  let ch = source[offset + 1];
  while (ch === " " || ch === "	" || ch === "\n" || ch === "\r") {
    if (ch === "\r" && source[offset + 2] !== "\n")
      break;
    if (ch === "\n")
      fold += "\n";
    offset += 1;
    ch = source[offset + 1];
  }
  if (!fold)
    fold = " ";
  return { fold, offset };
}
var escapeCodes = {
  "0": "\0",
  a: "\x07",
  b: "\b",
  e: "\x1B",
  f: "\f",
  n: "\n",
  r: "\r",
  t: "	",
  v: "\v",
  N: "\x85",
  _: "\xA0",
  L: "\u2028",
  P: "\u2029",
  " ": " ",
  '"': '"',
  "/": "/",
  "\\": "\\",
  "	": "	"
};
function parseCharCode(source, offset, length, onError) {
  const cc = source.substr(offset, length);
  const ok = cc.length === length && /^[0-9a-fA-F]+$/.test(cc);
  const code = ok ? parseInt(cc, 16) : NaN;
  if (isNaN(code)) {
    const raw = source.substr(offset - 2, length + 2);
    onError(offset - 2, "BAD_DQ_ESCAPE", `Invalid escape sequence ${raw}`);
    return raw;
  }
  return String.fromCodePoint(code);
}

// node_modules/yaml/browser/dist/compose/compose-scalar.js
function composeScalar(ctx, token, tagToken, onError) {
  const { value, type, comment, range } = token.type === "block-scalar" ? resolveBlockScalar(token, ctx.options.strict, onError) : resolveFlowScalar(token, ctx.options.strict, onError);
  const tagName = tagToken ? ctx.directives.tagName(tagToken.source, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg)) : null;
  const tag2 = tagToken && tagName ? findScalarTagByName(ctx.schema, value, tagName, tagToken, onError) : token.type === "scalar" ? findScalarTagByTest(ctx, value, token, onError) : ctx.schema[SCALAR];
  let scalar;
  try {
    const res = tag2.resolve(value, (msg) => onError(tagToken || token, "TAG_RESOLVE_FAILED", msg), ctx.options);
    scalar = isScalar(res) ? res : new Scalar(res);
  } catch (error) {
    const msg = error instanceof Error ? error.message : String(error);
    onError(tagToken || token, "TAG_RESOLVE_FAILED", msg);
    scalar = new Scalar(value);
  }
  scalar.range = range;
  scalar.source = value;
  if (type)
    scalar.type = type;
  if (tagName)
    scalar.tag = tagName;
  if (tag2.format)
    scalar.format = tag2.format;
  if (comment)
    scalar.comment = comment;
  return scalar;
}
function findScalarTagByName(schema4, value, tagName, tagToken, onError) {
  var _a;
  if (tagName === "!")
    return schema4[SCALAR];
  const matchWithTest = [];
  for (const tag2 of schema4.tags) {
    if (!tag2.collection && tag2.tag === tagName) {
      if (tag2.default && tag2.test)
        matchWithTest.push(tag2);
      else
        return tag2;
    }
  }
  for (const tag2 of matchWithTest)
    if ((_a = tag2.test) === null || _a === void 0 ? void 0 : _a.test(value))
      return tag2;
  const kt = schema4.knownTags[tagName];
  if (kt && !kt.collection) {
    schema4.tags.push(Object.assign({}, kt, { default: false, test: void 0 }));
    return kt;
  }
  onError(tagToken, "TAG_RESOLVE_FAILED", `Unresolved tag: ${tagName}`, tagName !== "tag:yaml.org,2002:str");
  return schema4[SCALAR];
}
function findScalarTagByTest({ directives, schema: schema4 }, value, token, onError) {
  const tag2 = schema4.tags.find((tag3) => {
    var _a;
    return tag3.default && ((_a = tag3.test) === null || _a === void 0 ? void 0 : _a.test(value));
  }) || schema4[SCALAR];
  if (schema4.compat) {
    const compat = schema4.compat.find((tag3) => {
      var _a;
      return tag3.default && ((_a = tag3.test) === null || _a === void 0 ? void 0 : _a.test(value));
    }) || schema4[SCALAR];
    if (tag2.tag !== compat.tag) {
      const ts = directives.tagString(tag2.tag);
      const cs = directives.tagString(compat.tag);
      const msg = `Value may be parsed as either ${ts} or ${cs}`;
      onError(token, "TAG_RESOLVE_FAILED", msg, true);
    }
  }
  return tag2;
}

// node_modules/yaml/browser/dist/compose/util-empty-scalar-position.js
function emptyScalarPosition(offset, before, pos) {
  if (before) {
    if (pos === null)
      pos = before.length;
    for (let i = pos - 1; i >= 0; --i) {
      let st = before[i];
      switch (st.type) {
        case "space":
        case "comment":
        case "newline":
          offset -= st.source.length;
          continue;
      }
      st = before[++i];
      while ((st === null || st === void 0 ? void 0 : st.type) === "space") {
        offset += st.source.length;
        st = before[++i];
      }
      break;
    }
  }
  return offset;
}

// node_modules/yaml/browser/dist/compose/compose-node.js
var CN = { composeNode, composeEmptyNode };
function composeNode(ctx, token, props, onError) {
  const { spaceBefore, comment, anchor, tag: tag2 } = props;
  let node;
  switch (token.type) {
    case "alias":
      node = composeAlias(ctx, token, onError);
      if (anchor || tag2)
        onError(token, "ALIAS_PROPS", "An alias node must not specify any properties");
      break;
    case "scalar":
    case "single-quoted-scalar":
    case "double-quoted-scalar":
    case "block-scalar":
      node = composeScalar(ctx, token, tag2, onError);
      if (anchor)
        node.anchor = anchor.source.substring(1);
      break;
    case "block-map":
    case "block-seq":
    case "flow-collection":
      node = composeCollection(CN, ctx, token, tag2, onError);
      if (anchor)
        node.anchor = anchor.source.substring(1);
      break;
    default:
      console.log(token);
      throw new Error(`Unsupporten token type: ${token.type}`);
  }
  if (anchor && node.anchor === "")
    onError(anchor, "BAD_ALIAS", "Anchor cannot be an empty string");
  if (spaceBefore)
    node.spaceBefore = true;
  if (comment) {
    if (token.type === "scalar" && token.source === "")
      node.comment = comment;
    else
      node.commentBefore = comment;
  }
  if (ctx.options.keepSourceTokens)
    node.srcToken = token;
  return node;
}
function composeEmptyNode(ctx, offset, before, pos, { spaceBefore, comment, anchor, tag: tag2 }, onError) {
  const token = {
    type: "scalar",
    offset: emptyScalarPosition(offset, before, pos),
    indent: -1,
    source: ""
  };
  const node = composeScalar(ctx, token, tag2, onError);
  if (anchor) {
    node.anchor = anchor.source.substring(1);
    if (node.anchor === "")
      onError(anchor, "BAD_ALIAS", "Anchor cannot be an empty string");
  }
  if (spaceBefore)
    node.spaceBefore = true;
  if (comment)
    node.comment = comment;
  return node;
}
function composeAlias({ options }, { offset, source, end }, onError) {
  const alias = new Alias(source.substring(1));
  if (alias.source === "")
    onError(offset, "BAD_ALIAS", "Alias cannot be an empty string");
  const valueEnd = offset + source.length;
  const re = resolveEnd(end, valueEnd, options.strict, onError);
  alias.range = [offset, valueEnd, re.offset];
  if (re.comment)
    alias.comment = re.comment;
  return alias;
}

// node_modules/yaml/browser/dist/compose/compose-doc.js
function composeDoc(options, directives, { offset, start, value, end }, onError) {
  const opts = Object.assign({ directives }, options);
  const doc = new Document(void 0, opts);
  const ctx = {
    atRoot: true,
    directives: doc.directives,
    options: doc.options,
    schema: doc.schema
  };
  const props = resolveProps(start, {
    indicator: "doc-start",
    next: value || (end === null || end === void 0 ? void 0 : end[0]),
    offset,
    onError,
    startOnNewline: true
  });
  if (props.found) {
    doc.directives.marker = true;
    if (value && (value.type === "block-map" || value.type === "block-seq") && !props.hasNewline)
      onError(props.end, "MISSING_CHAR", "Block collection cannot start on same line with directives-end marker");
  }
  doc.contents = value ? composeNode(ctx, value, props, onError) : composeEmptyNode(ctx, props.end, start, null, props, onError);
  const contentEnd = doc.contents.range[2];
  const re = resolveEnd(end, contentEnd, false, onError);
  if (re.comment)
    doc.comment = re.comment;
  doc.range = [offset, contentEnd, re.offset];
  return doc;
}

// node_modules/yaml/browser/dist/compose/composer.js
function getErrorPos(src) {
  if (typeof src === "number")
    return [src, src + 1];
  if (Array.isArray(src))
    return src.length === 2 ? src : [src[0], src[1]];
  const { offset, source } = src;
  return [offset, offset + (typeof source === "string" ? source.length : 1)];
}
function parsePrelude(prelude) {
  var _a;
  let comment = "";
  let atComment = false;
  let afterEmptyLine = false;
  for (let i = 0; i < prelude.length; ++i) {
    const source = prelude[i];
    switch (source[0]) {
      case "#":
        comment += (comment === "" ? "" : afterEmptyLine ? "\n\n" : "\n") + (source.substring(1) || " ");
        atComment = true;
        afterEmptyLine = false;
        break;
      case "%":
        if (((_a = prelude[i + 1]) === null || _a === void 0 ? void 0 : _a[0]) !== "#")
          i += 1;
        atComment = false;
        break;
      default:
        if (!atComment)
          afterEmptyLine = true;
        atComment = false;
    }
  }
  return { comment, afterEmptyLine };
}
var Composer = class {
  constructor(options = {}) {
    this.doc = null;
    this.atDirectives = false;
    this.prelude = [];
    this.errors = [];
    this.warnings = [];
    this.onError = (source, code, message, warning) => {
      const pos = getErrorPos(source);
      if (warning)
        this.warnings.push(new YAMLWarning(pos, code, message));
      else
        this.errors.push(new YAMLParseError(pos, code, message));
    };
    this.directives = new Directives({
      version: options.version || defaultOptions.version
    });
    this.options = options;
  }
  decorate(doc, afterDoc) {
    const { comment, afterEmptyLine } = parsePrelude(this.prelude);
    if (comment) {
      const dc = doc.contents;
      if (afterDoc) {
        doc.comment = doc.comment ? `${doc.comment}
${comment}` : comment;
      } else if (afterEmptyLine || doc.directives.marker || !dc) {
        doc.commentBefore = comment;
      } else if (isCollection(dc) && !dc.flow && dc.items.length > 0) {
        let it = dc.items[0];
        if (isPair(it))
          it = it.key;
        const cb = it.commentBefore;
        it.commentBefore = cb ? `${comment}
${cb}` : comment;
      } else {
        const cb = dc.commentBefore;
        dc.commentBefore = cb ? `${comment}
${cb}` : comment;
      }
    }
    if (afterDoc) {
      Array.prototype.push.apply(doc.errors, this.errors);
      Array.prototype.push.apply(doc.warnings, this.warnings);
    } else {
      doc.errors = this.errors;
      doc.warnings = this.warnings;
    }
    this.prelude = [];
    this.errors = [];
    this.warnings = [];
  }
  /**
   * Current stream status information.
   *
   * Mostly useful at the end of input for an empty stream.
   */
  streamInfo() {
    return {
      comment: parsePrelude(this.prelude).comment,
      directives: this.directives,
      errors: this.errors,
      warnings: this.warnings
    };
  }
  /**
   * Compose tokens into documents.
   *
   * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
   * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
   */
  *compose(tokens, forceDoc = false, endOffset = -1) {
    for (const token of tokens)
      yield* this.next(token);
    yield* this.end(forceDoc, endOffset);
  }
  /** Advance the composer by one CST token. */
  *next(token) {
    switch (token.type) {
      case "directive":
        this.directives.add(token.source, (offset, message, warning) => {
          const pos = getErrorPos(token);
          pos[0] += offset;
          this.onError(pos, "BAD_DIRECTIVE", message, warning);
        });
        this.prelude.push(token.source);
        this.atDirectives = true;
        break;
      case "document": {
        const doc = composeDoc(this.options, this.directives, token, this.onError);
        if (this.atDirectives && !doc.directives.marker)
          this.onError(token, "MISSING_CHAR", "Missing directives-end indicator line");
        this.decorate(doc, false);
        if (this.doc)
          yield this.doc;
        this.doc = doc;
        this.atDirectives = false;
        break;
      }
      case "byte-order-mark":
      case "space":
        break;
      case "comment":
      case "newline":
        this.prelude.push(token.source);
        break;
      case "error": {
        const msg = token.source ? `${token.message}: ${JSON.stringify(token.source)}` : token.message;
        const error = new YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", msg);
        if (this.atDirectives || !this.doc)
          this.errors.push(error);
        else
          this.doc.errors.push(error);
        break;
      }
      case "doc-end": {
        if (!this.doc) {
          const msg = "Unexpected doc-end without preceding document";
          this.errors.push(new YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", msg));
          break;
        }
        const end = resolveEnd(token.end, token.offset + token.source.length, this.doc.options.strict, this.onError);
        this.decorate(this.doc, true);
        if (end.comment) {
          const dc = this.doc.comment;
          this.doc.comment = dc ? `${dc}
${end.comment}` : end.comment;
        }
        this.doc.range[2] = end.offset;
        break;
      }
      default:
        this.errors.push(new YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", `Unsupported token ${token.type}`));
    }
  }
  /**
   * Call at end of input to yield any remaining document.
   *
   * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
   * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
   */
  *end(forceDoc = false, endOffset = -1) {
    if (this.doc) {
      this.decorate(this.doc, true);
      yield this.doc;
      this.doc = null;
    } else if (forceDoc) {
      const opts = Object.assign({ directives: this.directives }, this.options);
      const doc = new Document(void 0, opts);
      if (this.atDirectives)
        this.onError(endOffset, "MISSING_CHAR", "Missing directives-end indicator line");
      doc.range = [0, endOffset, endOffset];
      this.decorate(doc, false);
      yield doc;
    }
  }
};

// node_modules/yaml/browser/dist/parse/cst.js
var cst_exports = {};
__export(cst_exports, {
  BOM: () => BOM,
  DOCUMENT: () => DOCUMENT,
  FLOW_END: () => FLOW_END,
  SCALAR: () => SCALAR2,
  createScalarToken: () => createScalarToken,
  isCollection: () => isCollection2,
  isScalar: () => isScalar2,
  prettyToken: () => prettyToken,
  resolveAsScalar: () => resolveAsScalar,
  setScalarValue: () => setScalarValue,
  stringify: () => stringify2,
  tokenType: () => tokenType,
  visit: () => visit2
});

// node_modules/yaml/browser/dist/parse/cst-scalar.js
function resolveAsScalar(token, strict = true, onError) {
  if (token) {
    const _onError = (pos, code, message) => {
      const offset = typeof pos === "number" ? pos : Array.isArray(pos) ? pos[0] : pos.offset;
      if (onError)
        onError(offset, code, message);
      else
        throw new YAMLParseError([offset, offset + 1], code, message);
    };
    switch (token.type) {
      case "scalar":
      case "single-quoted-scalar":
      case "double-quoted-scalar":
        return resolveFlowScalar(token, strict, _onError);
      case "block-scalar":
        return resolveBlockScalar(token, strict, _onError);
    }
  }
  return null;
}
function createScalarToken(value, context) {
  var _a;
  const { implicitKey = false, indent, inFlow = false, offset = -1, type = "PLAIN" } = context;
  const source = stringifyString({ type, value }, {
    implicitKey,
    indent: indent > 0 ? " ".repeat(indent) : "",
    inFlow,
    options: { blockQuote: true, lineWidth: -1 }
  });
  const end = (_a = context.end) !== null && _a !== void 0 ? _a : [
    { type: "newline", offset: -1, indent, source: "\n" }
  ];
  switch (source[0]) {
    case "|":
    case ">": {
      const he = source.indexOf("\n");
      const head = source.substring(0, he);
      const body = source.substring(he + 1) + "\n";
      const props = [
        { type: "block-scalar-header", offset, indent, source: head }
      ];
      if (!addEndtoBlockProps(props, end))
        props.push({ type: "newline", offset: -1, indent, source: "\n" });
      return { type: "block-scalar", offset, indent, props, source: body };
    }
    case '"':
      return { type: "double-quoted-scalar", offset, indent, source, end };
    case "'":
      return { type: "single-quoted-scalar", offset, indent, source, end };
    default:
      return { type: "scalar", offset, indent, source, end };
  }
}
function setScalarValue(token, value, context = {}) {
  let { afterKey = false, implicitKey = false, inFlow = false, type } = context;
  let indent = "indent" in token ? token.indent : null;
  if (afterKey && typeof indent === "number")
    indent += 2;
  if (!type)
    switch (token.type) {
      case "single-quoted-scalar":
        type = "QUOTE_SINGLE";
        break;
      case "double-quoted-scalar":
        type = "QUOTE_DOUBLE";
        break;
      case "block-scalar": {
        const header = token.props[0];
        if (header.type !== "block-scalar-header")
          throw new Error("Invalid block scalar header");
        type = header.source[0] === ">" ? "BLOCK_FOLDED" : "BLOCK_LITERAL";
        break;
      }
      default:
        type = "PLAIN";
    }
  const source = stringifyString({ type, value }, {
    implicitKey: implicitKey || indent === null,
    indent: indent !== null && indent > 0 ? " ".repeat(indent) : "",
    inFlow,
    options: { blockQuote: true, lineWidth: -1 }
  });
  switch (source[0]) {
    case "|":
    case ">":
      setBlockScalarValue(token, source);
      break;
    case '"':
      setFlowScalarValue(token, source, "double-quoted-scalar");
      break;
    case "'":
      setFlowScalarValue(token, source, "single-quoted-scalar");
      break;
    default:
      setFlowScalarValue(token, source, "scalar");
  }
}
function setBlockScalarValue(token, source) {
  const he = source.indexOf("\n");
  const head = source.substring(0, he);
  const body = source.substring(he + 1) + "\n";
  if (token.type === "block-scalar") {
    const header = token.props[0];
    if (header.type !== "block-scalar-header")
      throw new Error("Invalid block scalar header");
    header.source = head;
    token.source = body;
  } else {
    const { offset } = token;
    const indent = "indent" in token ? token.indent : -1;
    const props = [
      { type: "block-scalar-header", offset, indent, source: head }
    ];
    if (!addEndtoBlockProps(props, "end" in token ? token.end : void 0))
      props.push({ type: "newline", offset: -1, indent, source: "\n" });
    for (const key of Object.keys(token))
      if (key !== "type" && key !== "offset")
        delete token[key];
    Object.assign(token, { type: "block-scalar", indent, props, source: body });
  }
}
function addEndtoBlockProps(props, end) {
  if (end)
    for (const st of end)
      switch (st.type) {
        case "space":
        case "comment":
          props.push(st);
          break;
        case "newline":
          props.push(st);
          return true;
      }
  return false;
}
function setFlowScalarValue(token, source, type) {
  switch (token.type) {
    case "scalar":
    case "double-quoted-scalar":
    case "single-quoted-scalar":
      token.type = type;
      token.source = source;
      break;
    case "block-scalar": {
      const end = token.props.slice(1);
      let oa = source.length;
      if (token.props[0].type === "block-scalar-header")
        oa -= token.props[0].source.length;
      for (const tok of end)
        tok.offset += oa;
      delete token.props;
      Object.assign(token, { type, source, end });
      break;
    }
    case "block-map":
    case "block-seq": {
      const offset = token.offset + source.length;
      const nl = { type: "newline", offset, indent: token.indent, source: "\n" };
      delete token.items;
      Object.assign(token, { type, source, end: [nl] });
      break;
    }
    default: {
      const indent = "indent" in token ? token.indent : -1;
      const end = "end" in token && Array.isArray(token.end) ? token.end.filter((st) => st.type === "space" || st.type === "comment" || st.type === "newline") : [];
      for (const key of Object.keys(token))
        if (key !== "type" && key !== "offset")
          delete token[key];
      Object.assign(token, { type, indent, source, end });
    }
  }
}

// node_modules/yaml/browser/dist/parse/cst-stringify.js
var stringify2 = (cst) => "type" in cst ? stringifyToken(cst) : stringifyItem(cst);
function stringifyToken(token) {
  switch (token.type) {
    case "block-scalar": {
      let res = "";
      for (const tok of token.props)
        res += stringifyToken(tok);
      return res + token.source;
    }
    case "block-map":
    case "block-seq": {
      let res = "";
      for (const item of token.items)
        res += stringifyItem(item);
      return res;
    }
    case "flow-collection": {
      let res = token.start.source;
      for (const item of token.items)
        res += stringifyItem(item);
      for (const st of token.end)
        res += st.source;
      return res;
    }
    case "document": {
      let res = stringifyItem(token);
      if (token.end)
        for (const st of token.end)
          res += st.source;
      return res;
    }
    default: {
      let res = token.source;
      if ("end" in token && token.end)
        for (const st of token.end)
          res += st.source;
      return res;
    }
  }
}
function stringifyItem({ start, key, sep, value }) {
  let res = "";
  for (const st of start)
    res += st.source;
  if (key)
    res += stringifyToken(key);
  if (sep)
    for (const st of sep)
      res += st.source;
  if (value)
    res += stringifyToken(value);
  return res;
}

// node_modules/yaml/browser/dist/parse/cst-visit.js
var BREAK2 = Symbol("break visit");
var SKIP2 = Symbol("skip children");
var REMOVE2 = Symbol("remove item");
function visit2(cst, visitor) {
  if ("type" in cst && cst.type === "document")
    cst = { start: cst.start, value: cst.value };
  _visit2(Object.freeze([]), cst, visitor);
}
visit2.BREAK = BREAK2;
visit2.SKIP = SKIP2;
visit2.REMOVE = REMOVE2;
visit2.itemAtPath = (cst, path) => {
  let item = cst;
  for (const [field, index] of path) {
    const tok = item && item[field];
    if (tok && "items" in tok) {
      item = tok.items[index];
    } else
      return void 0;
  }
  return item;
};
visit2.parentCollection = (cst, path) => {
  const parent = visit2.itemAtPath(cst, path.slice(0, -1));
  const field = path[path.length - 1][0];
  const coll = parent && parent[field];
  if (coll && "items" in coll)
    return coll;
  throw new Error("Parent collection not found");
};
function _visit2(path, item, visitor) {
  let ctrl = visitor(item, path);
  if (typeof ctrl === "symbol")
    return ctrl;
  for (const field of ["key", "value"]) {
    const token = item[field];
    if (token && "items" in token) {
      for (let i = 0; i < token.items.length; ++i) {
        const ci = _visit2(Object.freeze(path.concat([[field, i]])), token.items[i], visitor);
        if (typeof ci === "number")
          i = ci - 1;
        else if (ci === BREAK2)
          return BREAK2;
        else if (ci === REMOVE2) {
          token.items.splice(i, 1);
          i -= 1;
        }
      }
      if (typeof ctrl === "function" && field === "key")
        ctrl = ctrl(item, path);
    }
  }
  return typeof ctrl === "function" ? ctrl(item, path) : ctrl;
}

// node_modules/yaml/browser/dist/parse/cst.js
var BOM = "\uFEFF";
var DOCUMENT = "";
var FLOW_END = "";
var SCALAR2 = "";
var isCollection2 = (token) => !!token && "items" in token;
var isScalar2 = (token) => !!token && (token.type === "scalar" || token.type === "single-quoted-scalar" || token.type === "double-quoted-scalar" || token.type === "block-scalar");
function prettyToken(token) {
  switch (token) {
    case BOM:
      return "<BOM>";
    case DOCUMENT:
      return "<DOC>";
    case FLOW_END:
      return "<FLOW_END>";
    case SCALAR2:
      return "<SCALAR>";
    default:
      return JSON.stringify(token);
  }
}
function tokenType(source) {
  switch (source) {
    case BOM:
      return "byte-order-mark";
    case DOCUMENT:
      return "doc-mode";
    case FLOW_END:
      return "flow-error-end";
    case SCALAR2:
      return "scalar";
    case "---":
      return "doc-start";
    case "...":
      return "doc-end";
    case "":
    case "\n":
    case "\r\n":
      return "newline";
    case "-":
      return "seq-item-ind";
    case "?":
      return "explicit-key-ind";
    case ":":
      return "map-value-ind";
    case "{":
      return "flow-map-start";
    case "}":
      return "flow-map-end";
    case "[":
      return "flow-seq-start";
    case "]":
      return "flow-seq-end";
    case ",":
      return "comma";
  }
  switch (source[0]) {
    case " ":
    case "	":
      return "space";
    case "#":
      return "comment";
    case "%":
      return "directive-line";
    case "*":
      return "alias";
    case "&":
      return "anchor";
    case "!":
      return "tag";
    case "'":
      return "single-quoted-scalar";
    case '"':
      return "double-quoted-scalar";
    case "|":
    case ">":
      return "block-scalar-header";
  }
  return null;
}

// node_modules/yaml/browser/dist/parse/lexer.js
function isEmpty(ch) {
  switch (ch) {
    case void 0:
    case " ":
    case "\n":
    case "\r":
    case "	":
      return true;
    default:
      return false;
  }
}
var hexDigits = "0123456789ABCDEFabcdef".split("");
var tagChars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-#;/?:@&=+$_.!~*'()".split("");
var invalidFlowScalarChars = ",[]{}".split("");
var invalidAnchorChars = " ,[]{}\n\r	".split("");
var isNotAnchorChar = (ch) => !ch || invalidAnchorChars.includes(ch);
var Lexer = class {
  constructor() {
    this.atEnd = false;
    this.blockScalarIndent = -1;
    this.blockScalarKeep = false;
    this.buffer = "";
    this.flowKey = false;
    this.flowLevel = 0;
    this.indentNext = 0;
    this.indentValue = 0;
    this.lineEndPos = null;
    this.next = null;
    this.pos = 0;
  }
  /**
   * Generate YAML tokens from the `source` string. If `incomplete`,
   * a part of the last line may be left as a buffer for the next call.
   *
   * @returns A generator of lexical tokens
   */
  *lex(source, incomplete = false) {
    if (source) {
      this.buffer = this.buffer ? this.buffer + source : source;
      this.lineEndPos = null;
    }
    this.atEnd = !incomplete;
    let next = this.next || "stream";
    while (next && (incomplete || this.hasChars(1)))
      next = yield* this.parseNext(next);
  }
  atLineEnd() {
    let i = this.pos;
    let ch = this.buffer[i];
    while (ch === " " || ch === "	")
      ch = this.buffer[++i];
    if (!ch || ch === "#" || ch === "\n")
      return true;
    if (ch === "\r")
      return this.buffer[i + 1] === "\n";
    return false;
  }
  charAt(n) {
    return this.buffer[this.pos + n];
  }
  continueScalar(offset) {
    let ch = this.buffer[offset];
    if (this.indentNext > 0) {
      let indent = 0;
      while (ch === " ")
        ch = this.buffer[++indent + offset];
      if (ch === "\r") {
        const next = this.buffer[indent + offset + 1];
        if (next === "\n" || !next && !this.atEnd)
          return offset + indent + 1;
      }
      return ch === "\n" || indent >= this.indentNext || !ch && !this.atEnd ? offset + indent : -1;
    }
    if (ch === "-" || ch === ".") {
      const dt = this.buffer.substr(offset, 3);
      if ((dt === "---" || dt === "...") && isEmpty(this.buffer[offset + 3]))
        return -1;
    }
    return offset;
  }
  getLine() {
    let end = this.lineEndPos;
    if (typeof end !== "number" || end !== -1 && end < this.pos) {
      end = this.buffer.indexOf("\n", this.pos);
      this.lineEndPos = end;
    }
    if (end === -1)
      return this.atEnd ? this.buffer.substring(this.pos) : null;
    if (this.buffer[end - 1] === "\r")
      end -= 1;
    return this.buffer.substring(this.pos, end);
  }
  hasChars(n) {
    return this.pos + n <= this.buffer.length;
  }
  setNext(state) {
    this.buffer = this.buffer.substring(this.pos);
    this.pos = 0;
    this.lineEndPos = null;
    this.next = state;
    return null;
  }
  peek(n) {
    return this.buffer.substr(this.pos, n);
  }
  *parseNext(next) {
    switch (next) {
      case "stream":
        return yield* this.parseStream();
      case "line-start":
        return yield* this.parseLineStart();
      case "block-start":
        return yield* this.parseBlockStart();
      case "doc":
        return yield* this.parseDocument();
      case "flow":
        return yield* this.parseFlowCollection();
      case "quoted-scalar":
        return yield* this.parseQuotedScalar();
      case "block-scalar":
        return yield* this.parseBlockScalar();
      case "plain-scalar":
        return yield* this.parsePlainScalar();
    }
  }
  *parseStream() {
    let line = this.getLine();
    if (line === null)
      return this.setNext("stream");
    if (line[0] === BOM) {
      yield* this.pushCount(1);
      line = line.substring(1);
    }
    if (line[0] === "%") {
      let dirEnd = line.length;
      const cs = line.indexOf("#");
      if (cs !== -1) {
        const ch = line[cs - 1];
        if (ch === " " || ch === "	")
          dirEnd = cs - 1;
      }
      while (true) {
        const ch = line[dirEnd - 1];
        if (ch === " " || ch === "	")
          dirEnd -= 1;
        else
          break;
      }
      const n = (yield* this.pushCount(dirEnd)) + (yield* this.pushSpaces(true));
      yield* this.pushCount(line.length - n);
      this.pushNewline();
      return "stream";
    }
    if (this.atLineEnd()) {
      const sp = yield* this.pushSpaces(true);
      yield* this.pushCount(line.length - sp);
      yield* this.pushNewline();
      return "stream";
    }
    yield DOCUMENT;
    return yield* this.parseLineStart();
  }
  *parseLineStart() {
    const ch = this.charAt(0);
    if (!ch && !this.atEnd)
      return this.setNext("line-start");
    if (ch === "-" || ch === ".") {
      if (!this.atEnd && !this.hasChars(4))
        return this.setNext("line-start");
      const s = this.peek(3);
      if (s === "---" && isEmpty(this.charAt(3))) {
        yield* this.pushCount(3);
        this.indentValue = 0;
        this.indentNext = 0;
        return "doc";
      } else if (s === "..." && isEmpty(this.charAt(3))) {
        yield* this.pushCount(3);
        return "stream";
      }
    }
    this.indentValue = yield* this.pushSpaces(false);
    if (this.indentNext > this.indentValue && !isEmpty(this.charAt(1)))
      this.indentNext = this.indentValue;
    return yield* this.parseBlockStart();
  }
  *parseBlockStart() {
    const [ch0, ch1] = this.peek(2);
    if (!ch1 && !this.atEnd)
      return this.setNext("block-start");
    if ((ch0 === "-" || ch0 === "?" || ch0 === ":") && isEmpty(ch1)) {
      const n = (yield* this.pushCount(1)) + (yield* this.pushSpaces(true));
      this.indentNext = this.indentValue + 1;
      this.indentValue += n;
      return yield* this.parseBlockStart();
    }
    return "doc";
  }
  *parseDocument() {
    yield* this.pushSpaces(true);
    const line = this.getLine();
    if (line === null)
      return this.setNext("doc");
    let n = yield* this.pushIndicators();
    switch (line[n]) {
      case "#":
        yield* this.pushCount(line.length - n);
      case void 0:
        yield* this.pushNewline();
        return yield* this.parseLineStart();
      case "{":
      case "[":
        yield* this.pushCount(1);
        this.flowKey = false;
        this.flowLevel = 1;
        return "flow";
      case "}":
      case "]":
        yield* this.pushCount(1);
        return "doc";
      case "*":
        yield* this.pushUntil(isNotAnchorChar);
        return "doc";
      case '"':
      case "'":
        return yield* this.parseQuotedScalar();
      case "|":
      case ">":
        n += yield* this.parseBlockScalarHeader();
        n += yield* this.pushSpaces(true);
        yield* this.pushCount(line.length - n);
        yield* this.pushNewline();
        return yield* this.parseBlockScalar();
      default:
        return yield* this.parsePlainScalar();
    }
  }
  *parseFlowCollection() {
    let nl, sp;
    let indent = -1;
    do {
      nl = yield* this.pushNewline();
      sp = yield* this.pushSpaces(true);
      if (nl > 0)
        this.indentValue = indent = sp;
    } while (nl + sp > 0);
    const line = this.getLine();
    if (line === null)
      return this.setNext("flow");
    if (indent !== -1 && indent < this.indentNext && line[0] !== "#" || indent === 0 && (line.startsWith("---") || line.startsWith("...")) && isEmpty(line[3])) {
      const atFlowEndMarker = indent === this.indentNext - 1 && this.flowLevel === 1 && (line[0] === "]" || line[0] === "}");
      if (!atFlowEndMarker) {
        this.flowLevel = 0;
        yield FLOW_END;
        return yield* this.parseLineStart();
      }
    }
    let n = 0;
    while (line[n] === ",") {
      n += yield* this.pushCount(1);
      n += yield* this.pushSpaces(true);
      this.flowKey = false;
    }
    n += yield* this.pushIndicators();
    switch (line[n]) {
      case void 0:
        return "flow";
      case "#":
        yield* this.pushCount(line.length - n);
        return "flow";
      case "{":
      case "[":
        yield* this.pushCount(1);
        this.flowKey = false;
        this.flowLevel += 1;
        return "flow";
      case "}":
      case "]":
        yield* this.pushCount(1);
        this.flowKey = true;
        this.flowLevel -= 1;
        return this.flowLevel ? "flow" : "doc";
      case "*":
        yield* this.pushUntil(isNotAnchorChar);
        return "flow";
      case '"':
      case "'":
        this.flowKey = true;
        return yield* this.parseQuotedScalar();
      case ":": {
        const next = this.charAt(1);
        if (this.flowKey || isEmpty(next) || next === ",") {
          this.flowKey = false;
          yield* this.pushCount(1);
          yield* this.pushSpaces(true);
          return "flow";
        }
      }
      default:
        this.flowKey = false;
        return yield* this.parsePlainScalar();
    }
  }
  *parseQuotedScalar() {
    const quote = this.charAt(0);
    let end = this.buffer.indexOf(quote, this.pos + 1);
    if (quote === "'") {
      while (end !== -1 && this.buffer[end + 1] === "'")
        end = this.buffer.indexOf("'", end + 2);
    } else {
      while (end !== -1) {
        let n = 0;
        while (this.buffer[end - 1 - n] === "\\")
          n += 1;
        if (n % 2 === 0)
          break;
        end = this.buffer.indexOf('"', end + 1);
      }
    }
    const qb = this.buffer.substring(0, end);
    let nl = qb.indexOf("\n", this.pos);
    if (nl !== -1) {
      while (nl !== -1) {
        const cs = this.continueScalar(nl + 1);
        if (cs === -1)
          break;
        nl = qb.indexOf("\n", cs);
      }
      if (nl !== -1) {
        end = nl - (qb[nl - 1] === "\r" ? 2 : 1);
      }
    }
    if (end === -1) {
      if (!this.atEnd)
        return this.setNext("quoted-scalar");
      end = this.buffer.length;
    }
    yield* this.pushToIndex(end + 1, false);
    return this.flowLevel ? "flow" : "doc";
  }
  *parseBlockScalarHeader() {
    this.blockScalarIndent = -1;
    this.blockScalarKeep = false;
    let i = this.pos;
    while (true) {
      const ch = this.buffer[++i];
      if (ch === "+")
        this.blockScalarKeep = true;
      else if (ch > "0" && ch <= "9")
        this.blockScalarIndent = Number(ch) - 1;
      else if (ch !== "-")
        break;
    }
    return yield* this.pushUntil((ch) => isEmpty(ch) || ch === "#");
  }
  *parseBlockScalar() {
    let nl = this.pos - 1;
    let indent = 0;
    let ch;
    loop:
      for (let i = this.pos; ch = this.buffer[i]; ++i) {
        switch (ch) {
          case " ":
            indent += 1;
            break;
          case "\n":
            nl = i;
            indent = 0;
            break;
          case "\r": {
            const next = this.buffer[i + 1];
            if (!next && !this.atEnd)
              return this.setNext("block-scalar");
            if (next === "\n")
              break;
          }
          default:
            break loop;
        }
      }
    if (!ch && !this.atEnd)
      return this.setNext("block-scalar");
    if (indent >= this.indentNext) {
      if (this.blockScalarIndent === -1)
        this.indentNext = indent;
      else
        this.indentNext += this.blockScalarIndent;
      do {
        const cs = this.continueScalar(nl + 1);
        if (cs === -1)
          break;
        nl = this.buffer.indexOf("\n", cs);
      } while (nl !== -1);
      if (nl === -1) {
        if (!this.atEnd)
          return this.setNext("block-scalar");
        nl = this.buffer.length;
      }
    }
    if (!this.blockScalarKeep) {
      do {
        let i = nl - 1;
        let ch2 = this.buffer[i];
        if (ch2 === "\r")
          ch2 = this.buffer[--i];
        while (ch2 === " " || ch2 === "	")
          ch2 = this.buffer[--i];
        if (ch2 === "\n" && i >= this.pos)
          nl = i;
        else
          break;
      } while (true);
    }
    yield SCALAR2;
    yield* this.pushToIndex(nl + 1, true);
    return yield* this.parseLineStart();
  }
  *parsePlainScalar() {
    const inFlow = this.flowLevel > 0;
    let end = this.pos - 1;
    let i = this.pos - 1;
    let ch;
    while (ch = this.buffer[++i]) {
      if (ch === ":") {
        const next = this.buffer[i + 1];
        if (isEmpty(next) || inFlow && next === ",")
          break;
        end = i;
      } else if (isEmpty(ch)) {
        let next = this.buffer[i + 1];
        if (ch === "\r") {
          if (next === "\n") {
            i += 1;
            ch = "\n";
            next = this.buffer[i + 1];
          } else
            end = i;
        }
        if (next === "#" || inFlow && invalidFlowScalarChars.includes(next))
          break;
        if (ch === "\n") {
          const cs = this.continueScalar(i + 1);
          if (cs === -1)
            break;
          i = Math.max(i, cs - 2);
        }
      } else {
        if (inFlow && invalidFlowScalarChars.includes(ch))
          break;
        end = i;
      }
    }
    if (!ch && !this.atEnd)
      return this.setNext("plain-scalar");
    yield SCALAR2;
    yield* this.pushToIndex(end + 1, true);
    return inFlow ? "flow" : "doc";
  }
  *pushCount(n) {
    if (n > 0) {
      yield this.buffer.substr(this.pos, n);
      this.pos += n;
      return n;
    }
    return 0;
  }
  *pushToIndex(i, allowEmpty) {
    const s = this.buffer.slice(this.pos, i);
    if (s) {
      yield s;
      this.pos += s.length;
      return s.length;
    } else if (allowEmpty)
      yield "";
    return 0;
  }
  *pushIndicators() {
    switch (this.charAt(0)) {
      case "!":
        return (yield* this.pushTag()) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
      case "&":
        return (yield* this.pushUntil(isNotAnchorChar)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
      case ":":
      case "?":
      case "-":
        if (isEmpty(this.charAt(1))) {
          if (this.flowLevel === 0)
            this.indentNext = this.indentValue + 1;
          else if (this.flowKey)
            this.flowKey = false;
          return (yield* this.pushCount(1)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
        }
    }
    return 0;
  }
  *pushTag() {
    if (this.charAt(1) === "<") {
      let i = this.pos + 2;
      let ch = this.buffer[i];
      while (!isEmpty(ch) && ch !== ">")
        ch = this.buffer[++i];
      return yield* this.pushToIndex(ch === ">" ? i + 1 : i, false);
    } else {
      let i = this.pos + 1;
      let ch = this.buffer[i];
      while (ch) {
        if (tagChars.includes(ch))
          ch = this.buffer[++i];
        else if (ch === "%" && hexDigits.includes(this.buffer[i + 1]) && hexDigits.includes(this.buffer[i + 2])) {
          ch = this.buffer[i += 3];
        } else
          break;
      }
      return yield* this.pushToIndex(i, false);
    }
  }
  *pushNewline() {
    const ch = this.buffer[this.pos];
    if (ch === "\n")
      return yield* this.pushCount(1);
    else if (ch === "\r" && this.charAt(1) === "\n")
      return yield* this.pushCount(2);
    else
      return 0;
  }
  *pushSpaces(allowTabs) {
    let i = this.pos - 1;
    let ch;
    do {
      ch = this.buffer[++i];
    } while (ch === " " || allowTabs && ch === "	");
    const n = i - this.pos;
    if (n > 0) {
      yield this.buffer.substr(this.pos, n);
      this.pos = i;
    }
    return n;
  }
  *pushUntil(test) {
    let i = this.pos;
    let ch = this.buffer[i];
    while (!test(ch))
      ch = this.buffer[++i];
    return yield* this.pushToIndex(i, false);
  }
};

// node_modules/yaml/browser/dist/parse/line-counter.js
var LineCounter = class {
  constructor() {
    this.lineStarts = [];
    this.addNewLine = (offset) => this.lineStarts.push(offset);
    this.linePos = (offset) => {
      let low = 0;
      let high = this.lineStarts.length;
      while (low < high) {
        const mid = low + high >> 1;
        if (this.lineStarts[mid] < offset)
          low = mid + 1;
        else
          high = mid;
      }
      if (this.lineStarts[low] === offset)
        return { line: low + 1, col: 1 };
      if (low === 0)
        return { line: 0, col: offset };
      const start = this.lineStarts[low - 1];
      return { line: low, col: offset - start + 1 };
    };
  }
};

// node_modules/yaml/browser/dist/parse/parser.js
function includesToken(list, type) {
  for (let i = 0; i < list.length; ++i)
    if (list[i].type === type)
      return true;
  return false;
}
function includesNonEmpty(list) {
  for (let i = 0; i < list.length; ++i) {
    switch (list[i].type) {
      case "space":
      case "comment":
      case "newline":
        break;
      default:
        return true;
    }
  }
  return false;
}
function isFlowToken(token) {
  switch (token === null || token === void 0 ? void 0 : token.type) {
    case "alias":
    case "scalar":
    case "single-quoted-scalar":
    case "double-quoted-scalar":
    case "flow-collection":
      return true;
    default:
      return false;
  }
}
function getPrevProps(parent) {
  switch (parent.type) {
    case "document":
      return parent.start;
    case "block-map": {
      const it = parent.items[parent.items.length - 1];
      return it.sep || it.start;
    }
    case "block-seq":
      return parent.items[parent.items.length - 1].start;
    default:
      return [];
  }
}
function getFirstKeyStartProps(prev) {
  var _a;
  if (prev.length === 0)
    return [];
  let i = prev.length;
  loop:
    while (--i >= 0) {
      switch (prev[i].type) {
        case "doc-start":
        case "explicit-key-ind":
        case "map-value-ind":
        case "seq-item-ind":
        case "newline":
          break loop;
      }
    }
  while (((_a = prev[++i]) === null || _a === void 0 ? void 0 : _a.type) === "space") {
  }
  return prev.splice(i, prev.length);
}
function fixFlowSeqItems(fc) {
  if (fc.start.type === "flow-seq-start") {
    for (const it of fc.items) {
      if (it.sep && !it.value && !includesToken(it.start, "explicit-key-ind") && !includesToken(it.sep, "map-value-ind")) {
        if (it.key)
          it.value = it.key;
        delete it.key;
        if (isFlowToken(it.value)) {
          if (it.value.end)
            Array.prototype.push.apply(it.value.end, it.sep);
          else
            it.value.end = it.sep;
        } else
          Array.prototype.push.apply(it.start, it.sep);
        delete it.sep;
      }
    }
  }
}
var Parser = class {
  /**
   * @param onNewLine - If defined, called separately with the start position of
   *   each new line (in `parse()`, including the start of input).
   */
  constructor(onNewLine) {
    this.atNewLine = true;
    this.atScalar = false;
    this.indent = 0;
    this.offset = 0;
    this.onKeyLine = false;
    this.stack = [];
    this.source = "";
    this.type = "";
    this.lexer = new Lexer();
    this.onNewLine = onNewLine;
  }
  /**
   * Parse `source` as a YAML stream.
   * If `incomplete`, a part of the last line may be left as a buffer for the next call.
   *
   * Errors are not thrown, but yielded as `{ type: 'error', message }` tokens.
   *
   * @returns A generator of tokens representing each directive, document, and other structure.
   */
  *parse(source, incomplete = false) {
    if (this.onNewLine && this.offset === 0)
      this.onNewLine(0);
    for (const lexeme of this.lexer.lex(source, incomplete))
      yield* this.next(lexeme);
    if (!incomplete)
      yield* this.end();
  }
  /**
   * Advance the parser by the `source` of one lexical token.
   */
  *next(source) {
    this.source = source;
    if (this.atScalar) {
      this.atScalar = false;
      yield* this.step();
      this.offset += source.length;
      return;
    }
    const type = tokenType(source);
    if (!type) {
      const message = `Not a YAML token: ${source}`;
      yield* this.pop({ type: "error", offset: this.offset, message, source });
      this.offset += source.length;
    } else if (type === "scalar") {
      this.atNewLine = false;
      this.atScalar = true;
      this.type = "scalar";
    } else {
      this.type = type;
      yield* this.step();
      switch (type) {
        case "newline":
          this.atNewLine = true;
          this.indent = 0;
          if (this.onNewLine)
            this.onNewLine(this.offset + source.length);
          break;
        case "space":
          if (this.atNewLine && source[0] === " ")
            this.indent += source.length;
          break;
        case "explicit-key-ind":
        case "map-value-ind":
        case "seq-item-ind":
          if (this.atNewLine)
            this.indent += source.length;
          break;
        case "doc-mode":
        case "flow-error-end":
          return;
        default:
          this.atNewLine = false;
      }
      this.offset += source.length;
    }
  }
  /** Call at end of input to push out any remaining constructions */
  *end() {
    while (this.stack.length > 0)
      yield* this.pop();
  }
  get sourceToken() {
    const st = {
      type: this.type,
      offset: this.offset,
      indent: this.indent,
      source: this.source
    };
    return st;
  }
  *step() {
    const top = this.peek(1);
    if (this.type === "doc-end" && (!top || top.type !== "doc-end")) {
      while (this.stack.length > 0)
        yield* this.pop();
      this.stack.push({
        type: "doc-end",
        offset: this.offset,
        source: this.source
      });
      return;
    }
    if (!top)
      return yield* this.stream();
    switch (top.type) {
      case "document":
        return yield* this.document(top);
      case "alias":
      case "scalar":
      case "single-quoted-scalar":
      case "double-quoted-scalar":
        return yield* this.scalar(top);
      case "block-scalar":
        return yield* this.blockScalar(top);
      case "block-map":
        return yield* this.blockMap(top);
      case "block-seq":
        return yield* this.blockSequence(top);
      case "flow-collection":
        return yield* this.flowCollection(top);
      case "doc-end":
        return yield* this.documentEnd(top);
    }
    yield* this.pop();
  }
  peek(n) {
    return this.stack[this.stack.length - n];
  }
  *pop(error) {
    const token = error || this.stack.pop();
    if (!token) {
      const message = "Tried to pop an empty stack";
      yield { type: "error", offset: this.offset, source: "", message };
    } else if (this.stack.length === 0) {
      yield token;
    } else {
      const top = this.peek(1);
      if (token.type === "block-scalar") {
        token.indent = "indent" in top ? top.indent : 0;
      } else if (token.type === "flow-collection" && top.type === "document") {
        token.indent = 0;
      }
      if (token.type === "flow-collection")
        fixFlowSeqItems(token);
      switch (top.type) {
        case "document":
          top.value = token;
          break;
        case "block-scalar":
          top.props.push(token);
          break;
        case "block-map": {
          const it = top.items[top.items.length - 1];
          if (it.value) {
            top.items.push({ start: [], key: token, sep: [] });
            this.onKeyLine = true;
            return;
          } else if (it.sep) {
            it.value = token;
          } else {
            Object.assign(it, { key: token, sep: [] });
            this.onKeyLine = !includesToken(it.start, "explicit-key-ind");
            return;
          }
          break;
        }
        case "block-seq": {
          const it = top.items[top.items.length - 1];
          if (it.value)
            top.items.push({ start: [], value: token });
          else
            it.value = token;
          break;
        }
        case "flow-collection": {
          const it = top.items[top.items.length - 1];
          if (!it || it.value)
            top.items.push({ start: [], key: token, sep: [] });
          else if (it.sep)
            it.value = token;
          else
            Object.assign(it, { key: token, sep: [] });
          return;
        }
        default:
          yield* this.pop();
          yield* this.pop(token);
      }
      if ((top.type === "document" || top.type === "block-map" || top.type === "block-seq") && (token.type === "block-map" || token.type === "block-seq")) {
        const last = token.items[token.items.length - 1];
        if (last && !last.sep && !last.value && last.start.length > 0 && !includesNonEmpty(last.start) && (token.indent === 0 || last.start.every((st) => st.type !== "comment" || st.indent < token.indent))) {
          if (top.type === "document")
            top.end = last.start;
          else
            top.items.push({ start: last.start });
          token.items.splice(-1, 1);
        }
      }
    }
  }
  *stream() {
    switch (this.type) {
      case "directive-line":
        yield { type: "directive", offset: this.offset, source: this.source };
        return;
      case "byte-order-mark":
      case "space":
      case "comment":
      case "newline":
        yield this.sourceToken;
        return;
      case "doc-mode":
      case "doc-start": {
        const doc = {
          type: "document",
          offset: this.offset,
          start: []
        };
        if (this.type === "doc-start")
          doc.start.push(this.sourceToken);
        this.stack.push(doc);
        return;
      }
    }
    yield {
      type: "error",
      offset: this.offset,
      message: `Unexpected ${this.type} token in YAML stream`,
      source: this.source
    };
  }
  *document(doc) {
    if (doc.value)
      return yield* this.lineEnd(doc);
    switch (this.type) {
      case "doc-start": {
        if (includesNonEmpty(doc.start)) {
          yield* this.pop();
          yield* this.step();
        } else
          doc.start.push(this.sourceToken);
        return;
      }
      case "anchor":
      case "tag":
      case "space":
      case "comment":
      case "newline":
        doc.start.push(this.sourceToken);
        return;
    }
    const bv = this.startBlockValue(doc);
    if (bv)
      this.stack.push(bv);
    else {
      yield {
        type: "error",
        offset: this.offset,
        message: `Unexpected ${this.type} token in YAML document`,
        source: this.source
      };
    }
  }
  *scalar(scalar) {
    if (this.type === "map-value-ind") {
      const prev = getPrevProps(this.peek(2));
      const start = getFirstKeyStartProps(prev);
      let sep;
      if (scalar.end) {
        sep = scalar.end;
        sep.push(this.sourceToken);
        delete scalar.end;
      } else
        sep = [this.sourceToken];
      const map2 = {
        type: "block-map",
        offset: scalar.offset,
        indent: scalar.indent,
        items: [{ start, key: scalar, sep }]
      };
      this.onKeyLine = true;
      this.stack[this.stack.length - 1] = map2;
    } else
      yield* this.lineEnd(scalar);
  }
  *blockScalar(scalar) {
    switch (this.type) {
      case "space":
      case "comment":
      case "newline":
        scalar.props.push(this.sourceToken);
        return;
      case "scalar":
        scalar.source = this.source;
        this.atNewLine = true;
        this.indent = 0;
        if (this.onNewLine) {
          let nl = this.source.indexOf("\n") + 1;
          while (nl !== 0) {
            this.onNewLine(this.offset + nl);
            nl = this.source.indexOf("\n", nl) + 1;
          }
        }
        yield* this.pop();
        break;
      default:
        yield* this.pop();
        yield* this.step();
    }
  }
  *blockMap(map2) {
    var _a;
    const it = map2.items[map2.items.length - 1];
    switch (this.type) {
      case "newline":
        this.onKeyLine = false;
        if (it.value) {
          const end = "end" in it.value ? it.value.end : void 0;
          const last = Array.isArray(end) ? end[end.length - 1] : void 0;
          if ((last === null || last === void 0 ? void 0 : last.type) === "comment")
            end === null || end === void 0 ? void 0 : end.push(this.sourceToken);
          else
            map2.items.push({ start: [this.sourceToken] });
        } else if (it.sep)
          it.sep.push(this.sourceToken);
        else
          it.start.push(this.sourceToken);
        return;
      case "space":
      case "comment":
        if (it.value)
          map2.items.push({ start: [this.sourceToken] });
        else if (it.sep)
          it.sep.push(this.sourceToken);
        else {
          if (this.atIndentedComment(it.start, map2.indent)) {
            const prev = map2.items[map2.items.length - 2];
            const end = (_a = prev === null || prev === void 0 ? void 0 : prev.value) === null || _a === void 0 ? void 0 : _a.end;
            if (Array.isArray(end)) {
              Array.prototype.push.apply(end, it.start);
              end.push(this.sourceToken);
              map2.items.pop();
              return;
            }
          }
          it.start.push(this.sourceToken);
        }
        return;
    }
    if (this.indent >= map2.indent) {
      const atNextItem = !this.onKeyLine && this.indent === map2.indent && (it.sep || includesNonEmpty(it.start));
      switch (this.type) {
        case "anchor":
        case "tag":
          if (atNextItem || it.value) {
            map2.items.push({ start: [this.sourceToken] });
            this.onKeyLine = true;
          } else if (it.sep)
            it.sep.push(this.sourceToken);
          else
            it.start.push(this.sourceToken);
          return;
        case "explicit-key-ind":
          if (!it.sep && !includesToken(it.start, "explicit-key-ind"))
            it.start.push(this.sourceToken);
          else if (atNextItem || it.value)
            map2.items.push({ start: [this.sourceToken] });
          else
            this.stack.push({
              type: "block-map",
              offset: this.offset,
              indent: this.indent,
              items: [{ start: [this.sourceToken] }]
            });
          this.onKeyLine = true;
          return;
        case "map-value-ind":
          if (!it.sep)
            Object.assign(it, { key: null, sep: [this.sourceToken] });
          else if (it.value || atNextItem && !includesToken(it.start, "explicit-key-ind"))
            map2.items.push({ start: [], key: null, sep: [this.sourceToken] });
          else if (includesToken(it.sep, "map-value-ind"))
            this.stack.push({
              type: "block-map",
              offset: this.offset,
              indent: this.indent,
              items: [{ start: [], key: null, sep: [this.sourceToken] }]
            });
          else if (includesToken(it.start, "explicit-key-ind") && isFlowToken(it.key) && !includesToken(it.sep, "newline")) {
            const start = getFirstKeyStartProps(it.start);
            const key = it.key;
            const sep = it.sep;
            sep.push(this.sourceToken);
            delete it.key, delete it.sep;
            this.stack.push({
              type: "block-map",
              offset: this.offset,
              indent: this.indent,
              items: [{ start, key, sep }]
            });
          } else
            it.sep.push(this.sourceToken);
          this.onKeyLine = true;
          return;
        case "alias":
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar": {
          const fs = this.flowScalar(this.type);
          if (atNextItem || it.value) {
            map2.items.push({ start: [], key: fs, sep: [] });
            this.onKeyLine = true;
          } else if (it.sep) {
            this.stack.push(fs);
          } else {
            Object.assign(it, { key: fs, sep: [] });
            this.onKeyLine = true;
          }
          return;
        }
        default: {
          const bv = this.startBlockValue(map2);
          if (bv) {
            if (atNextItem && bv.type !== "block-seq" && includesToken(it.start, "explicit-key-ind"))
              map2.items.push({ start: [] });
            this.stack.push(bv);
            return;
          }
        }
      }
    }
    yield* this.pop();
    yield* this.step();
  }
  *blockSequence(seq2) {
    var _a;
    const it = seq2.items[seq2.items.length - 1];
    switch (this.type) {
      case "newline":
        if (it.value) {
          const end = "end" in it.value ? it.value.end : void 0;
          const last = Array.isArray(end) ? end[end.length - 1] : void 0;
          if ((last === null || last === void 0 ? void 0 : last.type) === "comment")
            end === null || end === void 0 ? void 0 : end.push(this.sourceToken);
          else
            seq2.items.push({ start: [this.sourceToken] });
        } else
          it.start.push(this.sourceToken);
        return;
      case "space":
      case "comment":
        if (it.value)
          seq2.items.push({ start: [this.sourceToken] });
        else {
          if (this.atIndentedComment(it.start, seq2.indent)) {
            const prev = seq2.items[seq2.items.length - 2];
            const end = (_a = prev === null || prev === void 0 ? void 0 : prev.value) === null || _a === void 0 ? void 0 : _a.end;
            if (Array.isArray(end)) {
              Array.prototype.push.apply(end, it.start);
              end.push(this.sourceToken);
              seq2.items.pop();
              return;
            }
          }
          it.start.push(this.sourceToken);
        }
        return;
      case "anchor":
      case "tag":
        if (it.value || this.indent <= seq2.indent)
          break;
        it.start.push(this.sourceToken);
        return;
      case "seq-item-ind":
        if (this.indent !== seq2.indent)
          break;
        if (it.value || includesToken(it.start, "seq-item-ind"))
          seq2.items.push({ start: [this.sourceToken] });
        else
          it.start.push(this.sourceToken);
        return;
    }
    if (this.indent > seq2.indent) {
      const bv = this.startBlockValue(seq2);
      if (bv) {
        this.stack.push(bv);
        return;
      }
    }
    yield* this.pop();
    yield* this.step();
  }
  *flowCollection(fc) {
    const it = fc.items[fc.items.length - 1];
    if (this.type === "flow-error-end") {
      let top;
      do {
        yield* this.pop();
        top = this.peek(1);
      } while (top && top.type === "flow-collection");
    } else if (fc.end.length === 0) {
      switch (this.type) {
        case "comma":
        case "explicit-key-ind":
          if (!it || it.sep)
            fc.items.push({ start: [this.sourceToken] });
          else
            it.start.push(this.sourceToken);
          return;
        case "map-value-ind":
          if (!it || it.value)
            fc.items.push({ start: [], key: null, sep: [this.sourceToken] });
          else if (it.sep)
            it.sep.push(this.sourceToken);
          else
            Object.assign(it, { key: null, sep: [this.sourceToken] });
          return;
        case "space":
        case "comment":
        case "newline":
        case "anchor":
        case "tag":
          if (!it || it.value)
            fc.items.push({ start: [this.sourceToken] });
          else if (it.sep)
            it.sep.push(this.sourceToken);
          else
            it.start.push(this.sourceToken);
          return;
        case "alias":
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar": {
          const fs = this.flowScalar(this.type);
          if (!it || it.value)
            fc.items.push({ start: [], key: fs, sep: [] });
          else if (it.sep)
            this.stack.push(fs);
          else
            Object.assign(it, { key: fs, sep: [] });
          return;
        }
        case "flow-map-end":
        case "flow-seq-end":
          fc.end.push(this.sourceToken);
          return;
      }
      const bv = this.startBlockValue(fc);
      if (bv)
        this.stack.push(bv);
      else {
        yield* this.pop();
        yield* this.step();
      }
    } else {
      const parent = this.peek(2);
      if (parent.type === "block-map" && (this.type === "map-value-ind" || this.type === "newline" && !parent.items[parent.items.length - 1].sep)) {
        yield* this.pop();
        yield* this.step();
      } else if (this.type === "map-value-ind" && parent.type !== "flow-collection") {
        const prev = getPrevProps(parent);
        const start = getFirstKeyStartProps(prev);
        fixFlowSeqItems(fc);
        const sep = fc.end.splice(1, fc.end.length);
        sep.push(this.sourceToken);
        const map2 = {
          type: "block-map",
          offset: fc.offset,
          indent: fc.indent,
          items: [{ start, key: fc, sep }]
        };
        this.onKeyLine = true;
        this.stack[this.stack.length - 1] = map2;
      } else {
        yield* this.lineEnd(fc);
      }
    }
  }
  flowScalar(type) {
    if (this.onNewLine) {
      let nl = this.source.indexOf("\n") + 1;
      while (nl !== 0) {
        this.onNewLine(this.offset + nl);
        nl = this.source.indexOf("\n", nl) + 1;
      }
    }
    return {
      type,
      offset: this.offset,
      indent: this.indent,
      source: this.source
    };
  }
  startBlockValue(parent) {
    switch (this.type) {
      case "alias":
      case "scalar":
      case "single-quoted-scalar":
      case "double-quoted-scalar":
        return this.flowScalar(this.type);
      case "block-scalar-header":
        return {
          type: "block-scalar",
          offset: this.offset,
          indent: this.indent,
          props: [this.sourceToken],
          source: ""
        };
      case "flow-map-start":
      case "flow-seq-start":
        return {
          type: "flow-collection",
          offset: this.offset,
          indent: this.indent,
          start: this.sourceToken,
          items: [],
          end: []
        };
      case "seq-item-ind":
        return {
          type: "block-seq",
          offset: this.offset,
          indent: this.indent,
          items: [{ start: [this.sourceToken] }]
        };
      case "explicit-key-ind": {
        this.onKeyLine = true;
        const prev = getPrevProps(parent);
        const start = getFirstKeyStartProps(prev);
        start.push(this.sourceToken);
        return {
          type: "block-map",
          offset: this.offset,
          indent: this.indent,
          items: [{ start }]
        };
      }
      case "map-value-ind": {
        this.onKeyLine = true;
        const prev = getPrevProps(parent);
        const start = getFirstKeyStartProps(prev);
        return {
          type: "block-map",
          offset: this.offset,
          indent: this.indent,
          items: [{ start, key: null, sep: [this.sourceToken] }]
        };
      }
    }
    return null;
  }
  atIndentedComment(start, indent) {
    if (this.type !== "comment")
      return false;
    if (this.indent <= indent)
      return false;
    return start.every((st) => st.type === "newline" || st.type === "space");
  }
  *documentEnd(docEnd) {
    if (this.type !== "doc-mode") {
      if (docEnd.end)
        docEnd.end.push(this.sourceToken);
      else
        docEnd.end = [this.sourceToken];
      if (this.type === "newline")
        yield* this.pop();
    }
  }
  *lineEnd(token) {
    switch (this.type) {
      case "comma":
      case "doc-start":
      case "doc-end":
      case "flow-seq-end":
      case "flow-map-end":
      case "map-value-ind":
        yield* this.pop();
        yield* this.step();
        break;
      case "newline":
        this.onKeyLine = false;
      case "space":
      case "comment":
      default:
        if (token.end)
          token.end.push(this.sourceToken);
        else
          token.end = [this.sourceToken];
        if (this.type === "newline")
          yield* this.pop();
    }
  }
};

// node_modules/yaml/browser/dist/public-api.js
function parseOptions(options) {
  const prettyErrors = options.prettyErrors !== false;
  const lineCounter = options.lineCounter || prettyErrors && new LineCounter() || null;
  return { lineCounter, prettyErrors };
}
function parseDocument(source, options = {}) {
  const { lineCounter, prettyErrors } = parseOptions(options);
  const parser = new Parser(lineCounter === null || lineCounter === void 0 ? void 0 : lineCounter.addNewLine);
  const composer = new Composer(options);
  let doc = null;
  for (const _doc of composer.compose(parser.parse(source), true, source.length)) {
    if (!doc)
      doc = _doc;
    else if (doc.options.logLevel !== "silent") {
      doc.errors.push(new YAMLParseError(_doc.range.slice(0, 2), "MULTIPLE_DOCS", "Source contains multiple documents; please use YAML.parseAllDocuments()"));
      break;
    }
  }
  if (prettyErrors && lineCounter) {
    doc.errors.forEach(prettifyError(source, lineCounter));
    doc.warnings.forEach(prettifyError(source, lineCounter));
  }
  return doc;
}

// tagrenamer/File.ts
var File = class {
  constructor(app2, filename, tagPositions, hasFrontMatter2) {
    this.app = app2;
    this.filename = filename;
    this.basename = filename.split("/").pop();
    this.tagPositions = tagPositions;
    this.hasFrontMatter = !!hasFrontMatter2;
  }
  /** @param {Replacement} replace */
  async renamed(replace) {
    const file = this.app.vault.getAbstractFileByPath(this.filename);
    const original = await this.app.vault.read(file);
    let text = original;
    if (this.hasFrontMatter) {
      text = this.replaceInFrontMatter(text, replace);
    }
    if (text !== original) {
      await this.app.vault.modify(file, text);
      return true;
    }
  }
  /** @param {Replacement} replace */
  replaceInFrontMatter(text, replace) {
    const [empty, frontMatter] = text.split(/^---\r?$\n?/m, 2);
    if (empty.trim() !== "" || !frontMatter.trim() || !frontMatter.endsWith("\n"))
      return text;
    const parsed = parseDocument(frontMatter, { keepSourceTokens: true });
    if (parsed.errors.length) {
      const error = `YAML issue with ${this.filename}: ${parsed.errors[0]}`;
      console.error(error);
      new import_obsidian.Notice(error + "; skipping frontmatter");
      return;
    }
    let changed = false, json = parsed.toJSON();
    function setInNode(node, value, afterKey = false) {
      cst_exports.setScalarValue(node.srcToken, value, { afterKey });
      changed = true;
      node.value = value;
    }
    function processField(prop, isAlias2) {
      const node = parsed.get(prop, true);
      if (!node)
        return;
      const field = json[prop];
      if (!field || !field.length)
        return;
      if (typeof field === "string") {
        const parts = field.split(isAlias2 ? /(^\s+|\s*,\s*|\s+$)/ : /([\s,]+)/);
        const after = replace.inArray(parts, true, isAlias2).join("");
        if (field != after)
          setInNode(node, after, true);
      } else if (Array.isArray(field)) {
        replace.inArray(field, false, isAlias2).forEach((v, i) => {
          if (field[i] !== v)
            setInNode(node.get(i, true), v);
        });
      }
    }
    for (const { key: { value: prop } } of parsed.contents.items) {
      if (/^tags?$/i.test(prop)) {
        processField(prop, false);
      } else if (/^alias(es)?$/i.test(prop)) {
        processField(prop, true);
      }
    }
    return changed ? text.replace(frontMatter, cst_exports.stringify(parsed.contents.srcToken)) : text;
  }
};

// tagrenamer/renaming.ts
function hasFrontMatter(file) {
  let { frontmatter } = app.metadataCache.getFileCache(file) || {};
  return frontmatter != null;
}
function hasTags(file) {
  let { frontmatter } = app.metadataCache.getFileCache(file) || {};
  const fmtags = (0, import_obsidian2.parseFrontMatterTags)(frontmatter) || [];
  const aliasTags = ((0, import_obsidian2.parseFrontMatterAliases)(frontmatter) || []).filter(Tag.isTag);
  return fmtags.length || aliasTags.length ? true : false;
}
async function renameTag(file, tagName, newName) {
  const oldTag = new Tag(tagName), newTag = new Tag(newName), replace = new Replacement(oldTag, newTag);
  const target = await findTargets(oldTag, file);
  if (!target) {
    return false;
  }
  await target.renamed(replace);
  return true;
}
async function findTargets(tag2, file) {
  let { frontmatter, tags } = app.metadataCache.getFileCache(file) || {};
  const fmtags = ((0, import_obsidian2.parseFrontMatterTags)(frontmatter) || []).filter(tag2.matches);
  const aliasTags = ((0, import_obsidian2.parseFrontMatterAliases)(frontmatter) || []).filter(Tag.isTag).filter(tag2.matches);
  if (fmtags.length || aliasTags.length) {
    return new File(app, file.path, tags, fmtags.length + aliasTags.length);
  }
  return null;
}
function renameBlogTitle(app2, path, view) {
  let moment2 = require_moment();
  const dateYYYYMMDD = moment2().format("YYYYMMDD");
  let renamedPath = "";
  if (path.match(/^.\/Blog \d\d\d\d\d\d\d\d/)) {
    return Promise.resolve();
  } else if (path.match(/^.\/blog \d\d\d\d\d\d\d\d/)) {
    new import_obsidian2.Notice("start with blog with date, renaming blog to Blog");
    renamedPath = path.replace(/^(.\/)blog /, `$1Blog `);
    return renameFile(app2, view.file, renamedPath);
  } else if (path.match(/^.\/Blog /)) {
    new import_obsidian2.Notice("starts with Blog but no date, adding date");
    renamedPath = path.replace(/^(.\/Blog )/, `$1${dateYYYYMMDD} `);
    return renameFile(app2, view.file, renamedPath);
  } else if (path.match(/^.\/blog /)) {
    new import_obsidian2.Notice("starts with blog but no date, adding date");
    renamedPath = path.replace(/^(.\/)blog /, `$1Blog ${dateYYYYMMDD} `);
    return renameFile(app2, view.file, renamedPath);
  } else {
    new import_obsidian2.Notice("starts without blog, adding Blog + date");
    renamedPath = path.replace(/^(.\/)/, `$1Blog ${dateYYYYMMDD} `);
    return renameFile(app2, view.file, renamedPath);
  }
}
async function renameFile(app2, file, newPath) {
  app2.fileManager.renameFile(file, newPath);
}

// updateNoteTypeModal.ts
var ALL_TYPES = [
  {
    type: "a/n/n",
    description: "N Current Task"
  },
  {
    type: "a/w/n",
    description: "W Current Task"
  },
  {
    type: "a/n/l",
    description: "N Later Task"
  },
  {
    type: "a/w/l",
    description: "W Later Task"
  },
  {
    type: "a/n/p",
    description: "N Permanent Task"
  },
  {
    type: "a/w/p",
    description: "W Permanent Task"
  },
  {
    type: "b/n/s",
    description: "Zettelkasten - Source notes (like books / video / thoughts / conversation)"
  },
  {
    type: "b/n/c",
    description: "Zettelkasten - Cards (With your own thought)"
  },
  {
    type: "c/t/d",
    description: "Threads post draft"
  },
  {
    type: "c/b/d",
    description: "Blog post draft"
  },
  {
    type: "b/n/u",
    description: "Zettelkasten - Unprocessed material like an inbox"
  },
  {
    type: "b/n/m",
    description: "Zettelkasten - MOC Notes for a small topic"
  },
  {
    type: "b/n/z",
    description: "Zettelkasten - Slip box (mainly on thought and the one I am interested)"
  },
  {
    type: "b/n/i",
    description: "Index Notes for self framework"
  },
  {
    type: "b/n/w",
    description: "Wiki Notes for a messy wiki topic"
  },
  {
    type: "b/n/v",
    description: "Zettelkasten - Voice script (Deprecated?)"
  },
  {
    type: "b/n/r",
    description: "Zettelkasten - Reference (Deprecated?)"
  },
  {
    type: "b/n/p",
    description: "Placeholder Notes (Deprecated?)"
  },
  {
    type: "b/a/p",
    description: "Area of Responsibility - Primary"
  },
  {
    type: "b/a/s",
    description: "Area of Responsibility - Secondary"
  },
  {
    type: "c/b/i",
    description: "Blog post content completed but awaiting upload image"
  },
  {
    type: "c/b/r",
    description: "Blog post ready to publish"
  },
  {
    type: "c/b/p",
    description: "Blog post published"
  },
  {
    type: "c/b/i",
    description: "Blog post series index"
  },
  {
    type: "c/b/a",
    description: "Blog post abandoned"
  },
  {
    type: "c/b/o",
    description: "Blog post outlined (Deprecated?)"
  },
  {
    type: "c/b/f",
    description: "Blog post fine tuned (Deprecated?)"
  },
  {
    type: "c/t/r",
    description: "Threads post ready to post"
  },
  {
    type: "c/t/t",
    description: "Threads post threads published"
  },
  {
    type: "c/t/p",
    description: "Threads post published"
  },
  {
    type: "c/t/i",
    description: "Threads post series index"
  },
  {
    type: "c/t/a",
    description: "Threads post abandoned"
  },
  {
    type: "c/x/d",
    description: "Twitter post drafting"
  },
  {
    type: "c/x/r",
    description: "Twitter post ready to publish"
  },
  {
    type: "c/x/p",
    description: "Twitter post published"
  },
  {
    type: "a/n/w",
    description: "N Waiting Task"
  },
  {
    type: "a/n/d",
    description: "N Done Task"
  },
  {
    type: "a/n/a",
    description: "N Archive Task"
  },
  {
    type: "a/w/w",
    description: "W Waiting Task"
  },
  {
    type: "a/w/d",
    description: "W Done Task"
  },
  {
    type: "a/w/a",
    description: "W Archive Task"
  }
];
var UpdateNoteTypeModal = class extends import_obsidian3.FuzzySuggestModal {
  constructor(app2, editor, file) {
    super(app2);
    this.editor = editor;
    this.file = file;
  }
  getItems() {
    return ALL_TYPES;
  }
  getItemText(noteType) {
    return noteType.type;
  }
  // Renders each suggestion item.
  renderSuggestion(choosenNoteTypeMatch, el) {
    const noteType = choosenNoteTypeMatch.item;
    el.createEl("div", { text: noteType.type });
    el.createEl("small", { text: noteType.description });
  }
  containsType(line) {
    return ALL_TYPES.filter((noteType) => line.contains(noteType.type)).length > 0;
  }
  addFrontMatterWithTag(value) {
    const cursor = this.editor.getCursor();
    const oldLine = cursor.line;
    const oldCh = cursor.ch;
    const addText = `---
tags: ${value}
---

${this.editor.getValue()}`;
    this.editor.setValue(addText);
    cursor.line = oldLine + 4;
    cursor.ch = oldCh;
    this.editor.setCursor(cursor);
  }
  addTagAssumingHasFrontMatter(value) {
    const cursor = this.editor.getCursor();
    const oldLine = cursor.line;
    const oldCh = cursor.ch;
    let firstLineIndex = 0;
    const lineCount = this.editor.lineCount();
    for (let i = 0; i < lineCount; i++) {
      if (this.editor.getLine(i).trim() == "---".trim()) {
        firstLineIndex = i;
        break;
      }
    }
    if (firstLineIndex == lineCount) {
      new import_obsidian3.Notice("Something wrong here");
      return;
    }
    let text = "";
    for (let i = 0; i <= firstLineIndex; i++) {
      text = text + this.editor.getLine(i) + "\n";
    }
    text = text + `tags: ${value}
`;
    for (let i = firstLineIndex + 1; i <= this.editor.lineCount(); i++) {
      text = text + this.editor.getLine(i) + "\n";
    }
    this.editor.setValue(text);
    cursor.line = oldLine + (oldLine <= firstLineIndex ? 0 : 1);
    cursor.ch = oldCh;
    this.editor.setCursor(cursor);
  }
  // Perform action on the selected suggestion.
  onChooseItem(choosenNoteType, evt) {
    if (!hasFrontMatter(this.file)) {
      this.addFrontMatterWithTag(choosenNoteType.type);
    } else {
      if (hasTags(this.file)) {
        ALL_TYPES.forEach((t) => {
          renameTag(this.file, t.type, choosenNoteType.type);
        });
      } else {
        this.addTagAssumingHasFrontMatter(choosenNoteType.type);
      }
    }
  }
};

// main.ts
var import_obsidian23 = require("obsidian");

// addCommentTagModal.ts
var import_obsidian4 = require("obsidian");
var ALL_TYPES2 = [
  {
    type: "d/question",
    description: "Question"
  },
  {
    type: "d/answer",
    description: "Answer"
  },
  {
    type: "d/solves",
    description: "Solves some problem"
  },
  {
    type: "d/ref",
    description: "Reference"
  },
  {
    type: "d/selfthink",
    description: "Self think"
  },
  {
    type: "d/notsure",
    description: "Not sure"
  },
  {
    type: "d/a1\u23F9\uFE0F",
    description: "A1 - my experience"
  },
  {
    type: "d/a2\u23FA\uFE0F",
    description: "A2 - future action"
  },
  {
    type: "d/c\u{1F504}",
    description: "Context"
  },
  {
    type: "d/w\u23EA",
    description: "Idea Compass - West - What are similar / supporting idea?"
  },
  {
    type: "d/n\u23EB",
    description: "Idea Compass - North - Where does this idea come from?"
  },
  {
    type: "d/s\u23EC",
    description: "Idea Compass - South - Where does the idea lead to?"
  },
  {
    type: "d/toMerge",
    description: "TODO - To Merge with another note"
  },
  {
    type: "d/toMove",
    description: "TODO - To Merge with another note"
  },
  {
    type: "d/toSplit",
    description: "ToDO - To Split to multiple note"
  },
  {
    type: "d/toCard",
    description: "TODO - To Write card"
  }
];
var AddFootnoteTagModal = class extends import_obsidian4.FuzzySuggestModal {
  constructor(app2, editor) {
    super(app2);
    this.editor = editor;
  }
  getItems() {
    return ALL_TYPES2;
  }
  getItemText(noteType) {
    return noteType.type;
  }
  static removeTag(line) {
    ALL_TYPES2.forEach((noteType) => line = line.replace(`#${noteType.type} `, ""));
    return line;
  }
  // Renders each suggestion item.
  renderSuggestion(choosenNoteTypeMatch, el) {
    const noteType = choosenNoteTypeMatch.item;
    el.createEl("div", { text: noteType.type });
    el.createEl("small", { text: noteType.description });
  }
  containsType(line) {
    return ALL_TYPES2.filter((noteType) => line.contains(noteType.type)).length > 0;
  }
  // Perform action on the selected suggestion.
  onChooseItem(choosenNoteType, evt) {
    const selection = this.editor.getSelection();
    const replacedStr = `#${choosenNoteType.type} `;
    if (selection.length != 0) {
      this.editor.replaceSelection(replacedStr);
    } else {
      const cursor = this.editor.getCursor();
      this.editor.replaceRange(replacedStr, cursor);
      cursor.ch = cursor.ch + replacedStr.length;
      this.editor.setCursor(cursor);
    }
  }
};

// addTaskTagModal.ts
var import_obsidian5 = require("obsidian");
var ALL_TYPES3 = [
  {
    type: "n",
    cursor: "c",
    description: "N Cursor"
  },
  {
    type: "n",
    cursor: "b",
    description: "N Beginning of line"
  },
  {
    type: "n",
    cursor: "e",
    description: "N End of line"
  },
  {
    type: "w",
    cursor: "c",
    description: "W Cursor"
  },
  {
    type: "w",
    cursor: "b",
    description: "W Beginning of line"
  },
  {
    type: "w",
    cursor: "e",
    description: "W End of line"
  }
];
var AddTaskTagModal = class extends import_obsidian5.FuzzySuggestModal {
  constructor(app2, editor, taskType) {
    super(app2);
    this.editor = editor;
    this.taskType = taskType;
  }
  getItems() {
    return ALL_TYPES3;
  }
  getItemText(noteType) {
    return noteType.type + noteType.cursor;
  }
  // Renders each suggestion item.
  renderSuggestion(choosenNoteTypeMatch, el) {
    const noteType = choosenNoteTypeMatch.item;
    el.createEl("div", { text: noteType.type + " " + noteType.cursor });
    el.createEl("small", { text: noteType.description });
  }
  containsType(line) {
    return ALL_TYPES3.filter((noteType) => line.contains(noteType.type)).length > 0;
  }
  // Perform action on the selected suggestion.
  onChooseItem(choosenNoteType, evt) {
    const cursor = this.editor.getCursor();
    const line = this.editor.getLine(cursor.line);
    if (choosenNoteType.cursor == "c") {
      this.editor.replaceRange(`${line.charAt(cursor.ch - 1) != " " ? " " : ""}#${choosenNoteType.type}${this.taskType} `, cursor);
      cursor.ch = cursor.ch + 4 + (line.charAt(cursor.ch - 1) != " " ? 1 : 0);
      this.editor.setCursor(cursor);
    } else if (choosenNoteType.cursor == "b") {
      let modifiedLine = line;
      if (/^\t*- /.test(line)) {
        modifiedLine = line.replace(/^(\t*- )/, `$1#${choosenNoteType.type}${this.taskType} `);
      } else if (/^\t*\d+\. /.test(line)) {
        modifiedLine = line.replace(/^(\t*\d+\. )/, `$1${choosenNoteType.type}${this.taskType} `);
      } else {
        modifiedLine = line.replace(/^/, `#${choosenNoteType.type}${this.taskType} `);
      }
      this.editor.setLine(cursor.line, modifiedLine);
      cursor.ch = cursor.ch + 4;
      this.editor.setCursor(cursor);
    } else if (choosenNoteType.cursor == "e") {
      let modifiedLine = line.replace(/$/, ` #${choosenNoteType.type}${this.taskType}`);
      this.editor.setLine(cursor.line, modifiedLine);
      cursor.ch = cursor.ch;
      this.editor.setCursor(cursor);
    }
  }
};

// ThreadsToImagesModal.ts
var import_obsidian6 = require("obsidian");
var ALL_TYPES4 = [
  {
    type: "first-page",
    description: "first page"
  },
  {
    type: "with-header",
    description: "with header"
  },
  {
    type: "without-header",
    description: "without header"
  },
  {
    type: "custom-font-size",
    description: "custom font size"
  }
];
var ThreadsToImagesModal = class extends import_obsidian6.FuzzySuggestModal {
  constructor(app2, threadSegment) {
    super(app2);
    this.threadSegment = threadSegment;
  }
  getItems() {
    return ALL_TYPES4;
  }
  getItemText(noteType) {
    return noteType.type;
  }
  // Renders each suggestion item.
  renderSuggestion(choosenNoteTypeMatch, el) {
    const noteType = choosenNoteTypeMatch.item;
    el.createEl("div", { text: noteType.type });
    el.createEl("small", { text: noteType.description });
  }
  containsType(line) {
    return ALL_TYPES4.filter((noteType) => line.contains(noteType.type)).length > 0;
  }
  // Perform action on the selected suggestion.
  onChooseItem(choosenNoteType, evt) {
    let param = choosenNoteType.type;
    let s = this.threadSegment.toString();
    navigator.clipboard.writeText(this.threadSegment.toString()).then(function() {
      new import_obsidian6.Notice(`Copied
\`\`\`
${s}\`\`\`
to clipboard!`);
      window.open(`shortcuts://run-shortcut?name=Threads%20to%20image&input=text&text=${param}&x-success=obsidian://&x-cancel=obsidian://&x-error=obsidian://`);
    }, function(error) {
      new import_obsidian6.Notice(`error when copy to clipboard!`);
    });
  }
};

// copyOrMoveToNewNoteModal.ts
var import_obsidian7 = require("obsidian");
var ALL_TYPES5 = [
  {
    type: "copy",
    description: "Copy"
  },
  {
    type: "move",
    description: "Move"
  }
];
var CopyOrMoveToNewNoteModal = class extends import_obsidian7.FuzzySuggestModal {
  constructor(app2, editor) {
    super(app2);
    this.editor = editor;
    this.setPlaceholder(`Copy or move selection to new note?`);
  }
  getItems() {
    return ALL_TYPES5;
  }
  getItemText(noteType) {
    return noteType.type;
  }
  // Renders each suggestion item.
  renderSuggestion(choosenNoteTypeMatch, el) {
    const noteType = choosenNoteTypeMatch.item;
    el.createEl("div", { text: noteType.type });
    el.createEl("small", { text: noteType.description });
  }
  containsType(line) {
    return ALL_TYPES5.filter((noteType) => line.contains(noteType.type)).length > 0;
  }
  // Perform action on the selected suggestion.
  async onChooseItem(choosenOperation, evt) {
    const selection = this.editor.getSelection();
    const line = this.editor.getCursor().line;
    const textToCopyOrMove = selection.length == 0 ? this.editor.getLine(line) : selection;
    const newFileName = "I/United Push.md";
    await this.createOrAppendFile(newFileName, textToCopyOrMove);
    if (choosenOperation.type == "move") {
      if (selection.length != 0) {
        this.editor.replaceSelection("");
      } else {
        let content = "";
        for (let i = 0; i < this.editor.lineCount(); i++) {
          if (i != line) {
            content += this.editor.getLine(i) + "\n";
          }
        }
        this.editor.setValue(content);
      }
    }
    const { vault } = this.app;
    const { workspace } = this.app;
    const mode = this.app.vault.getConfig("defaultViewMode");
    const leaf = workspace.getLeaf(false);
    await leaf.openFile(vault.getAbstractFileByPath(newFileName), { active: true });
  }
  async createOrAppendFile(filePath, note2) {
    const { vault } = this.app;
    const fileExists = await vault.adapter.exists(filePath);
    if (fileExists) {
      await this.appendFile(vault, filePath, note2);
    } else {
      await vault.create(filePath, "---\ntag: b/n/s\n---\n\n" + note2);
    }
    return filePath;
  }
  async appendFile(vault, filePath, note2) {
    let existingContent = await vault.adapter.read(filePath);
    if (existingContent.length > 0) {
      existingContent = existingContent + "\r\r";
    }
    await vault.adapter.write(filePath, existingContent + note2);
  }
};

// clipboardPasteModal.ts
var import_obsidian8 = require("obsidian");
var ClipboardPasteModal = class extends import_obsidian8.FuzzySuggestModal {
  constructor(app2, editor, clipboardContent) {
    super(app2);
    this.editor = editor;
    this.clipboardContent = clipboardContent;
    this.setPlaceholder(`Which clipboard content do you want to paste?`);
  }
  getItems() {
    return this.clipboardContent.slice().reverse();
  }
  getItemText(item) {
    return item;
  }
  // Renders each suggestion item.
  renderSuggestion(i, el) {
    const item = i.item;
    el.createEl("div", { text: "\u2022 " + item.replace(/\n/gm, "").substring(0, 100) });
  }
  // Perform action on the selected suggestion.
  onChooseItem(selectedContent, evt) {
    const index = this.clipboardContent.indexOf(selectedContent, 0);
    if (index > -1) {
      this.clipboardContent.remove(selectedContent);
    }
    this.clipboardContent.push(selectedContent);
    const selection = this.editor.getSelection();
    const replacedStr = selectedContent;
    if (selection.length != 0) {
      this.editor.replaceSelection(replacedStr);
    } else {
      const cursor = this.editor.getCursor();
      this.editor.replaceRange(replacedStr, cursor);
      cursor.ch = cursor.ch + replacedStr.length;
      this.editor.setCursor(cursor);
    }
  }
};

// openPlaygroundModal.ts
var import_obsidian9 = require("obsidian");
var OpenPlaygroundModal = class extends import_obsidian9.FuzzySuggestModal {
  constructor(app2) {
    super(app2);
    this.removeExistingContent = "Remove playground content";
    this.notRemoveExistingContent = "Not remove existing playground content";
    this.playgroundMd = "I/Playground.md";
    this.options = [this.removeExistingContent, this.notRemoveExistingContent];
  }
  getItems() {
    return this.options.reverse();
  }
  getItemText(item) {
    return item;
  }
  // Renders each suggestion item.
  renderSuggestion(i, el) {
    const item = i.item;
    el.createEl("div", { text: item });
  }
  // Perform action on the selected suggestion.
  async onChooseItem(selectedContent, evt) {
    const choosenOption = selectedContent;
    const { vault } = this.app;
    const { workspace } = this.app;
    const leaf = workspace.getLeaf(false);
    Promise.resolve().then(() => {
      if (vault.getAbstractFileByPath(this.playgroundMd) == null) {
        return vault.create(this.playgroundMd, "");
      }
      return vault.getAbstractFileByPath(this.playgroundMd);
    }).then((tFile) => {
      if (this.removeExistingContent === choosenOption) {
        return vault.modify(tFile, "");
      }
      return Promise.resolve();
    }).then(() => {
      return leaf.openFile(vault.getAbstractFileByPath(this.playgroundMd), { active: true });
    });
  }
};

// threadsToBlogModal.ts
var import_obsidian10 = require("obsidian");
var ThreadsToBlogModal = class extends import_obsidian10.FuzzySuggestModal {
  constructor(app2, editor, view) {
    super(app2);
    this.toNewNote = "To New Note";
    this.toClipboard = "To Clipboard";
    this.options = [this.toNewNote, this.toClipboard];
    this.editor = editor;
    this.view = view;
    this.setPlaceholder(`Putting Threads content to Blog notes. Which option do you want to proceed?`);
  }
  getItems() {
    return this.options;
  }
  getItemText(item) {
    return item;
  }
  // Renders each suggestion item.
  renderSuggestion(i, el) {
    const item = i.item;
    el.createEl("div", { text: item });
  }
  // Perform action on the selected suggestion.
  onChooseItem(selectedContent, evt) {
    const choosenOption = selectedContent;
    const lineCount = this.editor.lineCount();
    let tagLineNumber = null;
    let metadataLineCount = 0;
    let text = "";
    for (let i = 0; i < lineCount; i++) {
      let line = this.editor.getLine(i);
      if (!line.trim().startsWith("%%") || !line.trim().endsWith("%%")) {
        let modifiedLine = line.replace("\u{1F9F5} ", "# ").replace("\u3010", "").replace("\u3011", "").replace("\u{1F447}", "");
        if (modifiedLine == "---") {
          metadataLineCount++;
          if (metadataLineCount > 2) {
            if (metadataLineCount == 3) {
              modifiedLine = modifiedLine.replace("---", "");
            } else if (metadataLineCount == 4) {
              modifiedLine = modifiedLine.replace("---", "<!--more-->\n\n**\u76EE\u9304\uFF1A**\n\n* Table of Content\n{:toc}\n\n## .");
            } else {
              modifiedLine = modifiedLine.replace("---", "## .");
            }
          }
        }
        if (metadataLineCount == 1 || metadataLineCount == 2) {
          modifiedLine = modifiedLine.replace("c/t/p", "c/b/d");
          modifiedLine = modifiedLine.replace("c/t/t", "c/b/d");
          modifiedLine = modifiedLine.replace("c/t/r", "c/b/d");
        }
        if (/^!\[.*\]\(.*\)/.test(modifiedLine.trim())) {
          if (!modifiedLine.contains("https://roulesophy.github.io")) {
            modifiedLine = modifiedLine.replace(/!\[([^\[\]\(\)]+)\]\(([^\[\]\(\)]+)\)/g, "$2");
          }
        }
        text = text + modifiedLine + "\n";
      }
    }
    text += `

---

#nl generate summary for meta description below:



`;
    text += `---

## References:

- Thread post 1: [[${this.view.file.basename}]]
- Blog link: 
`;
    const { vault } = this.app;
    if (this.toNewNote === choosenOption) {
      const { vault: vault2 } = this.app;
      const path = this.view.file.path;
      const newPath = path.match(/.\/Threads \d\d\d\d\d\d\d\d/) ? path.replace(/(.\/)Threads \d\d\d\d\d\d\d\d/, "$1Blog ") : path.replace(/(.\/)/, "$1Blog ");
      const { workspace } = this.app;
      const leaf = workspace.getLeaf(false);
      Promise.resolve().then(() => {
        return vault2.adapter.exists(newPath);
      }).then((fileExists) => {
        if (fileExists) {
          new import_obsidian10.Notice(`Will not proceed. Blog post "${newPath}" already exist.`);
          return Promise.reject("Blog post exist");
        }
        return vault2.create(newPath, text);
      }).then(
        (tFile) => {
          return leaf.openFile(tFile, { active: true });
        },
        (rejectReason) => {
        }
      );
    }
    if (this.toClipboard === choosenOption) {
      navigator.clipboard.writeText(text).then(function() {
        new import_obsidian10.Notice(`Copied blog content to clipboard!`);
      }, function(error) {
        new import_obsidian10.Notice(`error when copy to clipboard!`);
      });
    }
  }
};

// clipboardRemovalModal.ts
var import_obsidian11 = require("obsidian");
var ClipboardRemovalModal = class extends import_obsidian11.FuzzySuggestModal {
  constructor(app2, editor, clipboardContent) {
    super(app2);
    this.REMOVE_ALL = "REMOVE ALL";
    this.editor = editor;
    this.clipboardContent = clipboardContent;
    this.setPlaceholder(`Which clipboard content do you want to remove?`);
  }
  getItems() {
    return [...[this.REMOVE_ALL], ...this.clipboardContent.slice().reverse()];
  }
  getItemText(item) {
    return item;
  }
  // Renders each suggestion item.
  renderSuggestion(i, el) {
    const item = i.item;
    el.createEl("div", { text: "\u2022 " + item.replace(/\n/gm, "").substring(0, 100) });
  }
  // Perform action on the selected suggestion.
  onChooseItem(selectedContent, evt) {
    if (selectedContent === this.REMOVE_ALL) {
      new import_obsidian11.Notice("haha");
      while (this.clipboardContent.length > 0) {
        this.clipboardContent.pop();
      }
    } else {
      const index = this.clipboardContent.indexOf(selectedContent, 0);
      if (index > -1) {
        this.clipboardContent.splice(index, 1);
      }
    }
  }
};

// tagSearchModal.ts
var import_obsidian13 = require("obsidian");

// selfutil/getAllNoteTags.ts
var import_obsidian12 = require("obsidian");
function getAllNoteTags(app2) {
  return getAllTagsWithFilter(app2, (tag2) => /^#[a-z]\/[a-z]\/[a-z]$/.test(tag2));
}
function getAllTagsWithFilter(app2, filter) {
  var _a;
  const files = app2.vault.getMarkdownFiles();
  const items = [];
  for (const file of files) {
    const cache = app2.metadataCache.getCache(file.path);
    if (cache === null) {
      continue;
    }
    (_a = (0, import_obsidian12.getAllTags)(cache)) == null ? void 0 : _a.forEach((tag2) => {
      if (filter == null || filter(tag2)) {
        const layerOfTag = getLayersOfTag(tag2);
        for (const layer of layerOfTag) {
          if (!items.includes(layer)) {
            items.push(layer);
          }
        }
      }
    });
  }
  return items.sort((a, b) => a.localeCompare(b));
}
function getLayersOfTag(tag2) {
  const layers = [];
  const tagSplit = tag2.split("/");
  let tagLayer = tagSplit[0];
  layers.push(tagLayer);
  for (const tagPart of tagSplit.slice(1, tagSplit.length)) {
    tagLayer += "/" + tagPart;
    layers.push(tagLayer);
  }
  return layers;
}

// tagSearchModal.ts
var TagSearchModal = class extends import_obsidian13.FuzzySuggestModal {
  constructor(app2, search) {
    super(app2);
    this.app = app2;
    this.search = search;
    this.search = search;
  }
  getItems() {
    return getAllTagsWithFilter(this.app);
  }
  getItemText(item) {
    return item;
  }
  onChooseItem(item, evt) {
    const defaultTagSearchString = `tag:${item}`;
    this.search.openGlobalSearch(defaultTagSearchString);
  }
};

// main.ts
var import_obsidian24 = require("obsidian");
var import_moment = __toESM(require_moment());

// addTextToNotesFromSpecificTagModal.ts
var import_obsidian16 = require("obsidian");

// selfutil/addlinktonotes.ts
var import_obsidian14 = require("obsidian");
function addTextToNotes(textToAdd, toPath, app2, insertFromBeginning) {
  const vault = this.app.vault;
  const workspace = this.app.workspace;
  const leaf = workspace.getLeaf(false);
  const tFile = vault.getAbstractFileByPath(toPath);
  const link = textToAdd;
  Promise.resolve().then(() => {
    return leaf.openFile(tFile, { active: true });
  }).then(() => {
    const markdownView = app2.workspace.getActiveViewOfType(import_obsidian14.MarkdownView);
    const editor = markdownView == null ? void 0 : markdownView.editor;
    const value = markdownView == null ? void 0 : markdownView.getViewData();
    if (markdownView == null || editor == null || value == null) {
      const errorReason = `editor or value ${toPath} not exist. Aborting...`;
      return Promise.reject(errorReason);
    }
    if (value.includes(link)) {
      const errorReason = `Link ${link} already exists in ${toPath}!`;
      new import_obsidian14.Notice(errorReason);
    } else {
      const newValue = insertFromBeginning ? getNoteValueInsertingTextFromStartOfNotes(value, link) : getNoteValueInsertingTextFromEndOfNotes(value, link);
      markdownView.setViewData(newValue, false);
      if (insertFromBeginning) {
        const frontMatterRegex = /^(---\n[\s\S]*?\n---\n)/gm;
        if (frontMatterRegex.test(value)) {
          editor.setCursor({ line: getLineAfterFrontMatter(value), ch: 0 });
        } else {
          editor.setCursor({ line: 0, ch: 0 });
        }
      } else {
        editor.setCursor({ line: editor.lineCount() - 1, ch: 0 });
      }
      new import_obsidian14.Notice(`Added link to ${insertFromBeginning ? "beginning" : "end"} of ${toPath}!`);
    }
    return Promise.resolve();
  }).catch((reason) => {
    new import_obsidian14.Notice(reason);
  });
}
function getLineAfterFrontMatter(value) {
  const values = value.split("\n");
  let fmCount = 0;
  const lineNum = values.length;
  for (let i = 0; i < lineNum; i++) {
    if (values[i] === "---") {
      fmCount++;
    }
    if (fmCount == 2) {
      return Math.min(i + 1, lineNum - 1);
    }
  }
  return lineNum - 1;
}
function getNoteValueInsertingTextFromStartOfNotes(value, text) {
  const frontMatterRegex = /^(---\n[\s\S]*?\n---\n)/gm;
  if (frontMatterRegex.test(value)) {
    return value.replace(frontMatterRegex, "$1" + text + "\n");
  } else {
    return text + "\n" + value;
  }
}
function getNoteValueInsertingTextFromEndOfNotes(value, text) {
  return value + "\n" + text;
}

// selfutil/findNotesFromTag.ts
var import_obsidian15 = require("obsidian");
function filesWhereTagIsUsed(findTag) {
  const filesList = [];
  for (const filePath of locationsWhereTagIsUsed(findTag)) {
    if (!filesList.includes(filePath)) {
      filesList.push(filePath);
    }
  }
  return filesList.sort((a, b) => a.localeCompare(b));
}
function locationsWhereTagIsUsed(findTag) {
  const oApp = app;
  const results = [];
  for (const file of oApp.vault.getMarkdownFiles()) {
    const cache = oApp.metadataCache.getFileCache(file);
    if (cache != null && cache.tags) {
      for (const tag2 of cache.tags) {
        if (findTag === tag2.tag) {
          results.push(file.path);
        }
      }
    }
    if (cache != null && cache.frontmatter) {
      const fmtags = ((0, import_obsidian15.parseFrontMatterTags)(cache.frontmatter) || []).filter((tag2) => findTag == tag2 || tag2.startsWith(findTag + "/"));
      if (fmtags.length) {
        results.push(file.path);
      }
      const fmtags2 = ((0, import_obsidian15.parseFrontMatterAliases)(cache.frontmatter) || []).filter((tag2) => findTag == tag2 || tag2.startsWith(findTag + "/"));
      if (fmtags2.length) {
        results.push(file.path);
      }
    }
  }
  return results;
}

// addTextToNotesFromSpecificTagModal.ts
var BACK_TO_SELECT_TAG = "Back to select tag";
var AddTextToNotesFromSpecificTagModal = class extends import_obsidian16.FuzzySuggestModal {
  constructor(app2, linkToAdd, tagToFind, description, insertFromBeginning, postAction) {
    super(app2);
    this.linkToAdd = linkToAdd;
    this.tagToFind = tagToFind;
    this.insertFromBeginning = insertFromBeginning;
    this.description = description;
    this.postAction = postAction;
    this.setPlaceholder(`Which notes with tag ${tagToFind} do you want to ${description} to?`);
    this.setInstructions([
      {
        command: "",
        purpose: `Which notes with tag ${tagToFind} do you want to ${description} to?`
      }
    ]);
  }
  getItems() {
    return [...[BACK_TO_SELECT_TAG], ...filesWhereTagIsUsed(this.tagToFind)];
  }
  getItemText(path) {
    return path;
  }
  // Renders each suggestion item.
  renderSuggestion(path, el) {
    const pathItem = path.item;
    el.createEl("div", { text: pathItem });
  }
  // Perform action on the selected suggestion.
  onChooseItem(path, evt) {
    if (BACK_TO_SELECT_TAG == path) {
      new AddTextToNotesModal(this.app, this.linkToAdd, this.description, this.insertFromBeginning, this.postAction).open();
    } else {
      addTextToNotes(this.linkToAdd, path, this.app, this.insertFromBeginning);
      this.postAction();
    }
  }
};

// addTextToNotesModal.ts
var import_obsidian17 = require("obsidian");

// selfutil/getRecentNotes.ts
function getRecentNotes(app2, limit) {
  const recentViewedNotes = app2.workspace.getLastOpenFiles();
  return recentViewedNotes.slice(0, Math.min(limit, recentViewedNotes.length));
}
function getAllNotes(app2) {
  const files = app2.vault.getMarkdownFiles();
  const allNotes = files.map((file) => file.path);
  return allNotes;
}

// addTextToNotesModal.ts
var AddTextToNotesModal = class extends import_obsidian17.FuzzySuggestModal {
  constructor(app2, linkToAdd, description, insertFromBeginning, postAction) {
    super(app2);
    this.linkToAdd = linkToAdd;
    this.description = description;
    this.insertFromBeginning = insertFromBeginning;
    this.postAction = postAction;
    this.setPlaceholder(`Which notes with tags do you want to ${description} to?`);
    this.setInstructions([
      {
        command: "",
        purpose: `Which notes with tags do you want to ${description} to?`
      }
    ]);
  }
  getItems() {
    const l = [...["I/Inbox.md"], ...getRecentNotes(this.app, 7), ...getAllNoteTags(this.app).map((s) => s.replace(/^#/, "@")), ...getAllNotes(this.app)];
    return l.filter((item, index) => l.indexOf(item) === index);
  }
  getItemText(value) {
    return value;
  }
  // Renders each suggestion item.
  renderSuggestion(value, el) {
    const item = value.item;
    el.createEl("div", { text: item });
  }
  // Perform action on the selected suggestion.
  async onChooseItem(choosenValue, evt) {
    if (choosenValue.startsWith("@")) {
      new AddTextToNotesFromSpecificTagModal(this.app, this.linkToAdd, choosenValue.replace(/^@/, "#"), this.description, this.insertFromBeginning, this.postAction).open();
    } else {
      addTextToNotes(this.linkToAdd, choosenValue, this.app, this.insertFromBeginning);
      this.postAction();
    }
  }
};

// navigateToNoteFromSpecificTagModal.ts
var import_obsidian18 = require("obsidian");
var BACK_TO_SELECT_TAG2 = "Back to select tag";
var NavigateToNoteFromSpecificTagModal = class extends import_obsidian18.FuzzySuggestModal {
  constructor(app2, tagToFind) {
    super(app2);
    this.tagToFind = tagToFind;
    this.setPlaceholder(`Which notes with tag ${tagToFind} do you want to navigate to?`);
    this.setInstructions([
      {
        command: "",
        purpose: `Which notes with tag ${tagToFind} do you want to navigate to?`
      }
    ]);
  }
  getItems() {
    return [...[BACK_TO_SELECT_TAG2], ...filesWhereTagIsUsed(this.tagToFind)];
  }
  getItemText(path) {
    return path;
  }
  // Renders each suggestion item.
  renderSuggestion(path, el) {
    const pathItem = path.item;
    el.createEl("div", { text: pathItem });
  }
  // Perform action on the selected suggestion.
  onChooseItem(path, evt) {
    if (BACK_TO_SELECT_TAG2 == path) {
      new NavigateToNoteFromTagModal(this.app).open();
    } else {
      const { vault, workspace } = this.app;
      const leaf = workspace.getLeaf(false);
      Promise.resolve().then(() => {
        return leaf.openFile(vault.getAbstractFileByPath(path), { active: true });
      });
    }
  }
};

// navigateToNoteFromTagModal.ts
var import_obsidian19 = require("obsidian");
var note = "note";
var tag = "tag";
var heading = "heading";
var NavigateToNoteFromTagModal = class extends import_obsidian19.FuzzySuggestModal {
  constructor(app2) {
    super(app2);
    this.setPlaceholder(`Which notes with tags do you want to navigate to?`);
    this.setInstructions([
      {
        command: "",
        purpose: "Which notes with tags do you want to navigate to?"
      }
    ]);
  }
  getItems() {
    const allNotes = getAllNotes(this.app);
    let headings = [];
    allNotes.forEach((n) => {
      const file = this.app.vault.getAbstractFileByPath(n);
      const fileCache = this.app.metadataCache.getFileCache(file);
      if (!fileCache) {
        return;
      }
      if (!fileCache.headings) {
        return;
      }
      fileCache.headings.forEach((h) => {
        headings.push({ note: n, heading: h.heading, level: h.level });
      });
    });
    return [
      ...getRecentNotes(this.app, 7).map((n) => {
        return { search: n, secondary: "", type: note };
      }),
      ...getAllTagsWithFilter(this.app).map((n) => {
        return { search: n.replace(/^#/, "@"), secondary: "", type: tag };
      }),
      ...allNotes.map((n) => {
        return { search: n, secondary: "", type: note };
      }),
      ...headings.map((h) => {
        return { search: "#".repeat(h.level) + " " + h.heading, secondary: h.note, type: heading };
      })
    ];
  }
  getItemText(value) {
    return value.search;
  }
  // Renders each suggestion item.
  renderSuggestion(value, el) {
    const item = value.item;
    el.createEl("div", { text: item.search });
    el.createEl("small", { text: item.type + " " + item.secondary });
  }
  // Perform action on the selected suggestion.
  async onChooseItem(choosenValue, evt) {
    if (choosenValue.type == tag) {
      new NavigateToNoteFromSpecificTagModal(this.app, choosenValue.search.replace("@", "#")).open();
    } else if (choosenValue.type == note) {
      const { vault, workspace } = this.app;
      const leaf = workspace.getLeaf(false);
      Promise.resolve().then(() => {
        return leaf.openFile(vault.getAbstractFileByPath(choosenValue.search), { active: true });
      });
    } else if (choosenValue.type == heading) {
      const { vault, workspace } = this.app;
      const leaf = workspace.getLeaf(false);
      Promise.resolve().then(() => {
        return leaf.openFile(vault.getAbstractFileByPath(choosenValue.secondary), { active: true });
      }).then(() => {
        const markdownView = app.workspace.getActiveViewOfType(import_obsidian19.MarkdownView);
        const editor = markdownView == null ? void 0 : markdownView.editor;
        if (markdownView == null || editor == null) {
          const errorReason = `editor or value ${choosenValue.secondary} not exist. Aborting...`;
          return Promise.reject(errorReason);
        }
        const totalLineNum = editor.lineCount();
        for (let i = 0; i < totalLineNum; i++) {
          const line = editor.getLine(i);
          if (line == choosenValue.search) {
            editor.setCursor({ line: i, ch: 0 });
            editor.scrollIntoView({ from: { line: i, ch: 0 }, to: { line: i, ch: 0 } }, true);
            return;
          }
        }
      });
    }
  }
};

// selfutil/extractSelection.ts
function exportCurrentSelection(editor) {
  let text = "";
  const listSelections = editor.listSelections();
  listSelections.forEach((listSelection) => {
    const a = listSelection.head.line;
    const b = listSelection.anchor.line;
    const fromLineNum = b > a ? a : b;
    const toLineNum = b > a ? b : a;
    for (let i = fromLineNum; i <= toLineNum; i++) {
      const line = editor.getLine(i);
      text += line + "\n";
    }
  });
  return text.replace(/\n$/, "");
}
function getCurrentSelectionLineNumber(editor) {
  let text = "";
  let fromLineNum = 0;
  let fromCh = 0;
  let toLineNum = 0;
  let toCh = 0;
  const listSelections = editor.listSelections();
  listSelections.forEach((listSelection) => {
    const a = listSelection.head.line;
    const ach = listSelection.head.ch;
    const b = listSelection.anchor.line;
    const bch = listSelection.anchor.ch;
    fromLineNum = b > a ? a : b;
    fromCh = b > a ? ach : bch;
    toLineNum = b > a ? b : a;
    toCh = b > a ? bch : ach;
  });
  return { fromLineNum, fromCh, toLineNum, toCh };
}

// twmigration/twMigrateTools.ts
var skipFrontMatterField = [
  "freetimetask: ",
  "expectedtime: ",
  "mode: ",
  "days: ",
  "showheaderfooter: ",
  "showstate: ",
  "sortsubpagefilter: ",
  "throughttree: ",
  "urgent: ",
  "displayas: ",
  "startdate: ",
  "readwritemode: ",
  "showChandlerNow: ",
  "deepwork: ",
  "expectedtime: ",
  "parsedate: ",
  "tidscope: ",
  "inserttodoaction: ",
  "optional: ",
  "replaceto: ",
  "backuptiddler: ",
  "deadline: ",
  "caption: ",
  "collection: ",
  "library: ",
  "library_version: ",
  "dummy: ",
  "tidName: ",
  "chronicledate: ",
  "eventdate: ",
  "dailyhighlight: ",
  "displaycardmode: ",
  "displaymode: ",
  "numcol: ",
  "dateyyyymmdd: ",
  "graphdisplaymode: ",
  "maxdepth: ",
  "journaldate: ",
  "thisBillDate: ",
  "lastBillDate: ",
  "roottiddler: ",
  "year: ",
  "to: ",
  "tidtemplate: ",
  "tiddlername: ",
  "theme: ",
  "tagvalue: ",
  "subtasknum: ",
  "removetagvalue: ",
  "recurringeventstartdate: ",
  "recurringeventenddate: ",
  "pluginname: ",
  "pid: ",
  "macroname: ",
  "limit: ",
  "keyword: ",
  "keywordtmp: ",
  "from: ",
  "deprecatereason: ",
  "deepwo: ",
  "color: ",
  "row: ",
  "col: ",
  "bookmarked: ",
  "blockingreminderdate: ",
  "backup: "
];
function replaceTWUselessValue(value) {
  return value.replace("## > References\n\n* \n\n", "").replace("## > Goal and Reason\n\n* \n\n", "").replace("## > Deliverable Spec\n\n* \n\n", "").replace("## > Conditon of done\n\n* \n\n", "").replace("## > Step\n\n* \n\n", "").replace("## > Progress\n\n* \n\n", "").replace("## > Results\n\n* \n\n", "").replace("## > Experience\n\n* \n\n", "").replace("## > References\n\n* \n\n", "").replace("## > Results, Steps and Exp\n\n* \n\n", "").replace("## > Checklist\n\n[ ] \n\n", "").replace(/\n\n\n+/, "\n\n");
}
function shouldSkipFrontMatter(line) {
  for (let i = 0; i < skipFrontMatterField.length; i++) {
    if (line.startsWith(skipFrontMatterField[i])) {
      return true;
    }
  }
  return false;
}
function getParentLine(value) {
  const values = value.split("\n");
  for (let i = 0; i < values.length; i++) {
    const lineContent = values[i];
    if (/^parent\d+: /.test(lineContent) || /^\t+- parent\d+: /.test(lineContent)) {
      return i;
    }
  }
  return 0;
}
function tidyUpFrontMatteronEditor(editor) {
  const value = editor.getValue();
  const modifiedValue = tidyUpFrontMatterOnValue(value);
  editor.setValue(modifiedValue);
}
function tidyUpFrontMatterOnValue(value) {
  const values = value.split("\n");
  const lineCount = values.length;
  let fm = "";
  let c = "";
  let text = "";
  let h3Count = 0;
  let content = "";
  for (let i = 0; i < lineCount; i++) {
    const line = values[i];
    if (h3Count == 0) {
      content += line + "\n";
    } else if (h3Count == 1) {
      if (/^list: /.test(line)) {
      } else {
        fm += line + "\n";
      }
    }
    if (h3Count >= 2) {
      c += line + "\n";
    }
    if (line === "---") {
      h3Count++;
    }
  }
  text += content;
  if (fm.length > 0) {
    text += fm;
  }
  text += c;
  return text.replace(/^---\n---\n/m, "").replace(/\n$/, "");
}

// selfutil/removeContentFromCursor.ts
function removeContentFromStartOfNoteToCursor(editor) {
  const cursor = editor.getCursor();
  const line = cursor.line;
  const ch = cursor.ch;
  const lineContent = editor.getLine(line);
  let newContent = lineContent.substring(ch);
  for (let i = line + 1; i < editor.lineCount(); i++) {
    newContent += "\n" + editor.getLine(i);
  }
  editor.setValue(newContent);
  cursor.line = 0;
  cursor.ch = 0;
  editor.setCursor(cursor);
}
function removeContentFromCursorToEndOfNote(editor) {
  const cursor = editor.getCursor();
  const line = cursor.line;
  const ch = cursor.ch;
  const lineContent = editor.getLine(line);
  let newContent = "";
  for (let i = 0; i < line; i++) {
    newContent += editor.getLine(i) + "\n";
  }
  newContent += lineContent.substring(0, ch);
  editor.setValue(newContent);
  cursor.line = line;
  cursor.ch = ch;
  editor.setCursor(cursor);
}
function removeContentLeftSameLine(editor) {
  const cursor = editor.getCursor();
  const line = cursor.line;
  const ch = cursor.ch;
  const lineContent = editor.getLine(line);
  editor.setLine(line, lineContent.substring(ch));
  cursor.ch = 0;
  editor.setCursor(cursor);
}
function removeContentRightSameLine(editor) {
  const cursor = editor.getCursor();
  const line = cursor.line;
  const ch = cursor.ch;
  const lineContent = editor.getLine(line);
  editor.setLine(line, lineContent.substring(0, ch));
  cursor.ch = editor.getLine(line).length;
  editor.setCursor(cursor);
}

// removeContentFromCursorModal.ts
var import_obsidian20 = require("obsidian");
var RemoveContentFromCursorModal = class extends import_obsidian20.FuzzySuggestModal {
  constructor(app2, editor) {
    super(app2);
    this.removeContentLeftSameLine = "Remove content left same line";
    this.removeContentRightSameLine = "Remove content right same line";
    this.removeContentFromStartOfNoteToCursor = "Remove content from start of note to cursor";
    this.removeContentFromCursorToEndOfNote = "Remove content from cursor to end of note";
    this.options = [this.removeContentLeftSameLine, this.removeContentRightSameLine, this.removeContentFromStartOfNoteToCursor, this.removeContentFromCursorToEndOfNote];
    this.editor = editor;
  }
  getItems() {
    return this.options;
  }
  getItemText(item) {
    return item;
  }
  // Renders each suggestion item.
  renderSuggestion(i, el) {
    const item = i.item;
    el.createEl("div", { text: item });
  }
  // Perform action on the selected suggestion.
  async onChooseItem(selectedContent, evt) {
    const choosenOption = selectedContent;
    if (choosenOption === this.removeContentLeftSameLine) {
      removeContentLeftSameLine(this.editor);
    } else if (choosenOption === this.removeContentRightSameLine) {
      removeContentRightSameLine(this.editor);
    } else if (choosenOption === this.removeContentFromStartOfNoteToCursor) {
      removeContentFromStartOfNoteToCursor(this.editor);
    } else if (choosenOption === this.removeContentFromCursorToEndOfNote) {
      removeContentFromCursorToEndOfNote(this.editor);
    }
  }
};

// findReplaceModal.ts
var import_obsidian21 = require("obsidian");
var FindReplaceModal = class extends import_obsidian21.FuzzySuggestModal {
  constructor(app2) {
    super(app2);
    this.find = "find";
    this.replace = "replace";
    this.options = [this.find, this.replace];
  }
  getItems() {
    return this.options;
  }
  getItemText(item) {
    return item;
  }
  // Renders each suggestion item.
  renderSuggestion(i, el) {
    const item = i.item;
    el.createEl("div", { text: item });
  }
  // Perform action on the selected suggestion.
  async onChooseItem(selectedContent, evt) {
    const choosenOption = selectedContent;
    if (choosenOption === this.find) {
      this.app.commands.executeCommandById("editor:open-search");
    } else {
      this.app.commands.executeCommandById("obsidian-regex-replace:obsidian-regex-replace");
    }
  }
};

// queryOrphanNotesByTagModal.ts
var import_obsidian22 = require("obsidian");
var QueryOrphanNotesByTagModal = class extends import_obsidian22.FuzzySuggestModal {
  constructor(app2, editor, view) {
    super(app2);
    this.setPlaceholder(`Which notes with tags do you want to search orphan?`);
    this.setInstructions([
      {
        command: "",
        purpose: `Which notes with tags do you want to search orphan?`
      }
    ]);
    this.editor = editor;
    this.view = view;
  }
  getItems() {
    const l = [...getAllNoteTags(this.app).map((s) => s.replace(/^#/, "@"))];
    return l.filter((item, index) => l.indexOf(item) === index);
  }
  getItemText(value) {
    return value;
  }
  // Renders each suggestion item.
  renderSuggestion(value, el) {
    const item = value.item;
    el.createEl("div", { text: item });
  }
  // Perform action on the selected suggestion.
  async onChooseItem(choosenValue, evt) {
    console.log(this.view.file.path);
    const queryMd = "I/Self Query.md";
    if (this.view.file.path === queryMd) {
      new import_obsidian22.Notice("Checking... may need some time");
      const tag2 = choosenValue.replace(/^@/, "#");
      const filePaths = filesWhereTagIsUsed(tag2);
      let result = "## Orphan notes for tag `" + tag2 + "`\n";
      for (const filePath of filePaths) {
        console.log(`Checking backlinks for ${filePath}`);
        const tFile = this.app.vault.getAbstractFileByPath(filePath);
        const backlinks = this.app.metadataCache.getBacklinksForFile(tFile);
        console.log(backlinks);
        console.log(backlinks.data);
        if (!backlinks || !backlinks.data || Object.keys(backlinks.data).length === 0) {
          console.log(`No backlinks for ${tFile.path}`);
          result += "\n- [[" + tFile.basename + "]]";
        } else {
          delete backlinks.data[queryMd];
          if (Object.keys(backlinks.data).length === 0) {
            console.log(`No backlinks for ${tFile.path}`);
            result += "\n- [[" + tFile.basename + "]]";
          } else {
            console.log(`Has backlinks for ${tFile.path}`);
          }
        }
      }
      this.editor.setValue(result);
      new import_obsidian22.Notice("Updated orphan");
    } else {
      new import_obsidian22.Notice("Please go to '" + queryMd + "' to run this action");
    }
  }
};

// main.ts
var DEFAULT_SETTINGS = {
  mySetting: "default"
};
var clipboardHistory = [];
var MyPlugin = class extends import_obsidian23.Plugin {
  async onload() {
    await this.loadSettings();
    if (navigator.clipboard) {
      document.addEventListener("copy", (event) => {
        var _a;
        const copiedText = (_a = event.clipboardData) == null ? void 0 : _a.getData("text/plain");
        if (copiedText != null) {
          this.addToClipboardHistory(copiedText);
        }
      });
      document.addEventListener("cut", (event) => {
        var _a;
        const copiedText = (_a = event.clipboardData) == null ? void 0 : _a.getData("text/plain");
        if (copiedText != null) {
          this.addToClipboardHistory(copiedText);
        }
      });
    } else {
      console.log("Clipboard API is not supported in this browser.");
    }
    ["n", "l", "w", "d", "a", "1", "2", "3", "4", "5", "6", "7"].forEach((t) => {
      this.addActionIcon(t);
      this.addActionCommand(t);
    });
    ["t", "m", "e"].forEach((t) => {
      this.addActionIcon(t);
      this.addFollowUpCommand(t);
    });
    ["n", "w"].forEach((t) => {
      this.addNewLaterActionIcon(t);
      this.addNewLaterAction(t);
    });
    this.addCommand({
      id: "obsidian-remove-clipboard-content",
      name: "RC Obsidian Remove Clipboard Content",
      icon: "obsidian-remove-clipboard-content",
      editorCallback: (editor, view) => {
        new ClipboardRemovalModal(this.app, editor, clipboardHistory).open();
      }
    });
    this.addObsidianIcon("auto-correct", "AC");
    this.addCommand({
      id: "auto-correct",
      name: "Auto Correct AC",
      icon: "auto-correct",
      editorCallback: (editor, view) => {
        const value = editor.getValue();
        let modifiedValue = value.replace(/10分/g, "\u5341\u5206").replace(/裏/g, "\u88E1").replace(/大佬/g, "\u5927\u8166");
        modifiedValue = modifiedValue.replace(/([a-zA-Z0-9])([\u4E00-\u9FFF])/g, "$1 $2").replace(/([\u4E00-\u9FFF])([a-zA-Z0-9])/g, "$1 $2");
        editor.setValue(modifiedValue);
      }
    });
    this.addObsidianIcon("find-broken-link", "BL");
    this.addCommand({
      id: "find-broken-link",
      name: "Find Broken Link BL",
      icon: "find-broken-link",
      editorCallback: (editor, view) => {
        if (view.file.path !== "I/Broken Link.md") {
          const cursor = editor.getCursor();
          const line = cursor.line;
          const lineContent = editor.getLine(line);
          if (/\[\[.*[:?\/\\<>].*\]\]/.test(lineContent)) {
            new import_obsidian23.Notice("Trying to fix broken line in current line: " + lineContent);
            editor.setLine(
              line,
              lineContent.replace(/:/g, "_").replace(/\?/g, "_").replace(/\//g, "_").replace(/\\/g, "_").replace(/</g, "_").replace(/>/g, "_").replace(/^(parent\d+)_ /, "$1: ").replace(/^(title\d+)_ /, "$1: ")
            );
          } else {
            const unresolvedLinks2 = this.app.metadataCache.unresolvedLinks;
            const brokenLinkRecord = unresolvedLinks2[view.file.path];
            if (brokenLinkRecord == null) {
              new import_obsidian23.Notice("No broken link found in this file");
              return;
            }
            const brokenLinks = Object.keys(brokenLinkRecord);
            if (brokenLinks == null || brokenLinks.length == 0) {
              new import_obsidian23.Notice("No broken link found in this file");
              return;
            }
            for (let i = line + 1; i < editor.lineCount(); i++) {
              const lineContent2 = editor.getLine(i);
              for (let b = 0; b < brokenLinks.length; b++) {
                const brokenLink = brokenLinks[b];
                if (lineContent2.contains("[[" + brokenLink + "]]")) {
                  editor.setCursor({ line: i, ch: 0 });
                  editor.scrollIntoView({ from: { line: i, ch: 0 }, to: { line: i, ch: 0 } }, true);
                  new import_obsidian23.Notice("Navigated to next Broken link starting from cursor");
                  return;
                }
              }
            }
            new import_obsidian23.Notice("No broken link found after cursor line in this file");
          }
          return;
        }
        let count = 0;
        let result = "";
        const unresolvedLinks = this.app.metadataCache.unresolvedLinks;
        for (const [key, value] of Object.entries(unresolvedLinks)) {
          let v = "";
          for (const [k1, v1] of Object.entries(value)) {
            v += k1 + ":" + v1 + ", ";
          }
          v = v.replace(/, $/, "");
          if (v !== "") {
            console.log(key + " -> [" + v + "]");
            result += "- [[" + key.replace(/\.md$/, "") + "]]";
            result += "\n";
            for (const [k2, v2] of Object.entries(value)) {
              result += "	- " + k2.replace(/\.md$/, "");
              result += "\n";
            }
            count++;
          }
        }
        editor.setValue(result);
        new import_obsidian23.Notice("Updated broken link. count=" + count);
      },
      hotkeys: [
        {
          modifiers: [`Ctrl`, `Meta`, `Shift`],
          key: `5`
        },
        {
          modifiers: [`Ctrl`, `Alt`, `Shift`],
          key: `5`
        }
      ]
    });
    this.addCommand({
      id: "open-tag-search",
      name: "Open tag search",
      icon: "hash",
      callback: () => {
        const searchPlugin = this.app.internalPlugins.getPluginById("global-search");
        const search = searchPlugin && searchPlugin.instance;
        if (searchPlugin && searchPlugin.instance) {
          new TagSearchModal(this.app, search).open();
        } else {
          new import_obsidian23.Notice("Please enable the search core plugin!");
        }
      },
      hotkeys: [
        {
          modifiers: [`Ctrl`, `Meta`, `Shift`],
          key: `s`
        },
        {
          modifiers: [`Ctrl`, `Alt`, `Shift`],
          key: `s`
        }
      ]
    });
    this.addCommand({
      id: "open-tag-search",
      name: "Open tag search",
      icon: "hash",
      callback: () => {
        const searchPlugin = this.app.internalPlugins.getPluginById("global-search");
        const search = searchPlugin && searchPlugin.instance;
        if (searchPlugin && searchPlugin.instance) {
          new TagSearchModal(this.app, search).open();
        } else {
          new import_obsidian23.Notice("Please enable the search core plugin!");
        }
      },
      hotkeys: [
        {
          modifiers: [`Ctrl`, `Meta`, `Shift`],
          key: `s`
        },
        {
          modifiers: [`Ctrl`, `Alt`, `Shift`],
          key: `s`
        }
      ]
    });
    this.addCommand({
      id: "self-query",
      name: "Self Query",
      editorCallback: (editor, view) => {
        new QueryOrphanNotesByTagModal(this.app, editor, view).open();
      }
    });
    this.addObsidianIcon("obsidian-paste", "\u2318V");
    this.addCommand({
      id: "obsidian-paste",
      name: "Obsidian Paste",
      icon: "obsidian-paste",
      editorCallback: (editor, view) => {
        new ClipboardPasteModal(this.app, editor, clipboardHistory).open();
      },
      hotkeys: [
        {
          modifiers: [`Meta`, `Shift`],
          key: `v`
        }
      ]
    });
    this.addObsidianIcon("update-note-type-icon", "NT");
    this.addCommand({
      id: "update-note-type",
      name: "Update Note Type",
      icon: `update-note-type-icon`,
      editorCallback: (editor, view) => {
        new UpdateNoteTypeModal(this.app, editor, view.file).open();
      },
      hotkeys: [
        {
          modifiers: [`Ctrl`, `Meta`, `Shift`],
          key: `c`
        },
        {
          modifiers: [`Ctrl`, `Alt`, `Shift`],
          key: `c`
        }
      ]
    });
    this.addCommand({
      id: "open-recent-days-schedule-with-updated-schedule",
      name: "OR Open Recent Days Updated Schedule",
      icon: "open-recent-day-schedule-icon",
      callback: async () => {
        const { vault } = this.app;
        const scheduleNoteWithoutMd = "D/Scheduling";
        const scheduleNote = `${scheduleNoteWithoutMd}.md`;
        if (vault.getAbstractFileByPath(scheduleNote) == null) {
          await vault.create(scheduleNote, "");
        }
        let noteContent = "";
        Array.from(Array(7).keys()).forEach((i) => noteContent += this.getQueryDateString(i, scheduleNoteWithoutMd));
        vault.modify(vault.getAbstractFileByPath(scheduleNote), noteContent);
        this.addActionNoteContent(vault, "D", "Query W now actions", "Weekly Schedule W", "w");
        this.addActionNoteContent(vault, "D", "Query N now actions", "Weekly Schedule N", "n");
        this.add3DaysActionNoteContent(vault);
        new import_obsidian23.Notice("Updated schedule");
        const { workspace } = this.app;
        const dashboardCanvas = "D/Query Schedule and Actions next 3 days.md";
        const mode = this.app.vault.getConfig("defaultViewMode");
        const leaf = workspace.getLeaf(false);
        await leaf.openFile(vault.getAbstractFileByPath(dashboardCanvas), {
          active: true
          /* mode */
        });
      }
    });
    this.addObsidianIcon("update-scheduling-icon", "US");
    this.addCommand({
      id: "update-scheduling",
      name: "Update Scheduling",
      icon: "update-scheduling-icon",
      callback: async () => {
        const { vault } = this.app;
        const scheduleNoteWithoutMd = "D/Scheduling";
        const scheduleNote = `${scheduleNoteWithoutMd}.md`;
        if (vault.getAbstractFileByPath(scheduleNote) == null) {
          await vault.create(scheduleNote, "");
        }
        let noteContent = "";
        Array.from(Array(7).keys()).forEach((i) => noteContent += this.getQueryDateString(i, scheduleNoteWithoutMd));
        vault.modify(vault.getAbstractFileByPath(scheduleNote), noteContent);
        this.addActionNoteContent(vault, "D", "Query W now actions", "Weekly Schedule W", "w");
        this.addActionNoteContent(vault, "D", "Query N now actions", "Weekly Schedule N", "n");
        this.add3DaysActionNoteContent(vault);
        new import_obsidian23.Notice("Updated schedule");
      }
      /*,
      hotkeys: [
      	{
      		modifiers: [`Ctrl`, `Meta`, `Shift`],
      		key: `u`,
      	},
      	{
      		modifiers: [`Ctrl`, `Alt`, `Shift`],
      		key: `u`,
      	},
      ]*/
    });
    this.addObsidianIcon("open-recent-day-schedule-icon", "OR");
    this.addCommand({
      id: "open-recent-days-schedule",
      name: "Open Recent Days Schedule",
      icon: "open-recent-day-schedule-icon",
      callback: async () => {
        const { vault, workspace } = this.app;
        const dashboardCanvas = "D/Query Schedule and Actions next 3 days.md";
        const leaf = workspace.getLeaf(false);
        await leaf.openFile(vault.getAbstractFileByPath(dashboardCanvas), { active: true });
      }
    });
    this.addObsidianIcon("open-inbox-icon", "OI");
    this.addCommand({
      id: "open-inbox",
      name: "OI Open Inbox",
      icon: "open-inbox-icon",
      callback: async () => {
        const { vault, workspace } = this.app;
        const inboxMd = "I/Inbox.md";
        const leaf = workspace.getLeaf(false);
        await leaf.openFile(vault.getAbstractFileByPath(inboxMd), { active: true });
      }
    });
    this.addObsidianIcon("open-playground-icon", "OP");
    this.addCommand({
      id: "open-playground",
      name: "OP Open Playground",
      icon: "open-playground-icon",
      callback: async () => {
        new OpenPlaygroundModal(this.app).open();
      },
      hotkeys: [
        {
          modifiers: [`Ctrl`, `Meta`, `Shift`],
          key: `p`
        },
        {
          modifiers: [`Ctrl`, `Alt`, `Shift`],
          key: `p`
        }
      ]
    });
    this.addObsidianIcon("open-braindump-icon", "OB");
    this.addCommand({
      id: "open-braindump",
      name: "OB Open BrainDump",
      icon: "open-braindump-icon",
      callback: async () => {
        const { vault, workspace } = this.app;
        const inboxMd = "I/Brain Dump.md";
        const leaf = workspace.getLeaf(false);
        await leaf.openFile(vault.getAbstractFileByPath(inboxMd), { active: true });
      }
    });
    this.addObsidianIcon("format-all-notes-custom", "FA");
    this.addCommand({
      id: "format-all-notes-custom",
      name: "FA Format All Notes (Custom usage)",
      icon: `format-all-notes-custom`,
      callback: async () => {
        const vault = this.app.vault;
        let startCount = 0;
        let finishedCount = 0;
        const files = vault.getMarkdownFiles();
        new import_obsidian23.Notice("all=" + files.length);
        console.log("all=" + files.length);
        for (const file of files) {
          console.log("s: " + startCount);
          vault.read(file).then((content) => {
            const modifiedValue = tidyUpFrontMatterOnValue(content);
            return vault.modify(file, modifiedValue);
          }).then(() => {
            console.log("f: " + finishedCount);
            finishedCount++;
            if (finishedCount == files.length) {
              console.log("finished");
              new import_obsidian23.Notice("finished");
            }
          });
          startCount++;
        }
      },
      hotkeys: [
        {
          modifiers: [`Ctrl`, `Meta`, `Shift`],
          key: `1`
        },
        {
          modifiers: [`Ctrl`, `Alt`, `Shift`],
          key: `1`
        }
      ]
    });
    this.addObsidianIcon("tw-fix-broken-link", ":_");
    this.addCommand({
      id: "tw-fix-broken-link",
      name: "BL Fix TW Broken Link",
      icon: `tw-fix-broken-link`,
      editorCallback: (editor, view) => {
        const cursor = editor.getCursor();
        const line = cursor.line;
        const lineContent = editor.getLine(line);
        editor.setLine(
          line,
          lineContent.replace(/:/g, "_").replace(/\?/g, "_").replace(/\//g, "_").replace(/</g, "_").replace(/>/g, "_").replace(/^(parent\d+)_ /, "$1: ").replace(/^(title\d+)_ /, "$1: ")
        );
      }
      /*,
      hotkeys: [
      	{
      		modifiers: [`Ctrl`, `Meta`, `Shift`],
      		key: `5`,
      	},
      	{
      		modifiers: [`Ctrl`, `Alt`, `Shift`],
      		key: `5`,
      	},
      ]*/
    });
    this.addObsidianIcon("format-notes-custom", "FN");
    this.addCommand({
      id: "format-notes-custom",
      name: "FN Format Notes (Custom usage)",
      icon: `format-notes-custom`,
      editorCallback: (editor, view) => {
        tidyUpFrontMatteronEditor(editor);
      },
      hotkeys: [
        {
          modifiers: [`Ctrl`, `Meta`, `Shift`],
          key: `2`
        },
        {
          modifiers: [`Ctrl`, `Alt`, `Shift`],
          key: `2`
        }
      ]
    });
    this.addObsidianIcon("tw-get-parent-link", "[]");
    this.addCommand({
      id: "tw-get-parent-link",
      name: "tw-get-parent-link",
      icon: `tw-get-parent-link`,
      editorCallback: (editor, view) => {
        const cursor = editor.getCursor();
        const line = cursor.line;
        const ch = cursor.ch;
        const lineContent = editor.getLine(line);
        if (/^parent\d+: /.test(lineContent) || /^\t+- parent\d+: /.test(lineContent)) {
          const parentLink = lineContent.replace(/^parent\d+: /, "").replace(/^\t+- parent\d+: /, "").replace(/"/g, "").replace(/\[\[/, "").replace(/\]\]/, "");
          navigator.clipboard.writeText(parentLink).then(() => {
            if (line == 0) {
              editor.setValue("");
            } else {
              const previousLine = editor.getLine(line - 1);
              editor.replaceRange("", { line: line - 1, ch: previousLine.length }, { line, ch: lineContent.length });
            }
            editor.setValue(editor.getValue().replace(/^---\n+---\n/, "---\ntags: b/n/c\n---\n").replace(/\n$/, ""));
            editor.setCursor({ line, ch: ch > editor.getLine(line).length ? editor.getLine(line).length : ch });
            new import_obsidian23.Notice("Copied to clipboard: " + parentLink);
          });
        }
      },
      hotkeys: [
        {
          modifiers: [`Ctrl`, `Meta`, `Shift`],
          key: `y`
        },
        {
          modifiers: [`Ctrl`, `Alt`, `Shift`],
          key: `y`
        }
      ]
    });
    this.addObsidianIcon("tw-tidy-list-note", "==");
    this.addCommand({
      id: "tw-tidy-list-note",
      name: "TL == TW Tidy List Note",
      icon: `tw-tidy-list-note`,
      editorCallback: (editor, view) => {
        editor.setValue(replaceTWUselessValue(editor.getValue()));
        const lineCount = editor.lineCount();
        let fm = "";
        let c = "";
        let text = "";
        let h3Count = 0;
        let content = "";
        let taskTag = "";
        for (let i = 0; i < lineCount; i++) {
          const line = editor.getLine(i);
          if (h3Count == 0) {
            if (line.length != 0 && !/^\t*- ```$/.test(line)) {
              const modifiedLine = line.contains("[[") && line.contains("]]") ? line : line.replace(view.file.basename + " _ ", "").replace(/(\t*- )#+ > /, "$1").replace(/(\t+- )#+ /, "$1");
              content += modifiedLine + "\n";
            }
          } else if (h3Count == 1) {
            if (line.startsWith("title: ") || line.startsWith("list: ")) {
              fm += line + "\n";
            } else if (line.length != 0 && !/^\t*- ```$/.test(line)) {
              const modifiedLine = line.contains("[[") && line.contains("]]") ? line : line.replace(view.file.basename + " _ ", "").replace(/(\t*- )#+ > /, "$1").replace(/(\t+- )#+ /, "$1");
              fm += modifiedLine + "\n";
            }
          }
          if (h3Count >= 2) {
            if (line.length != 0 && !/^\t*- ```$/.test(line)) {
              const modifiedLine = line.contains("[[") && line.contains("]]") ? line : line.replace(view.file.basename + " _ ", "").replace(/(\t*- )#+ > /, "$1").replace(/(\t+- )#+ /, "$1");
              c += modifiedLine + "\n";
            }
          }
          if (line === "---") {
            h3Count++;
            if (h3Count == 2) {
              fm += "\n";
            }
          }
        }
        text += content;
        if (fm.length > 0) {
          text += fm;
        }
        text += c;
        text = text.replace(/^---\n+---\n/m, "---\ntags: b/n/c\n---\n").replace(/\n$/, "");
        editor.setValue(text);
      },
      hotkeys: [
        {
          modifiers: [`Ctrl`, `Meta`, `Shift`],
          key: `6`
        },
        {
          modifiers: [`Ctrl`, `Alt`, `Shift`],
          key: `6`
        }
      ]
    });
    this.addObsidianIcon("tw-task", "--");
    this.addCommand({
      id: "tw-task",
      name: "TT -- TW Task",
      icon: `tw-task`,
      editorCallback: (editor, view) => {
        editor.setValue(replaceTWUselessValue(editor.getValue()));
        const lineCount = editor.lineCount();
        let fm = "";
        let c = "";
        let text = "";
        let h3Count = 0;
        let content = "";
        let taskTag = "";
        for (let i = 0; i < lineCount; i++) {
          const line = editor.getLine(i);
          if (h3Count == 0) {
            content += line + "\n";
          } else if (h3Count == 1) {
            if (line.startsWith("title: ")) {
            } else if (line.startsWith("tagsss: ")) {
              taskTag = "a/";
              if (/ N /.test(line) || / N$/.test(line)) {
                taskTag += "n/";
              }
              if (/ W /.test(line) || / W$/.test(line)) {
                taskTag += "w/";
              }
              if (/ now /.test(line) || / now$/.test(line)) {
                taskTag += "n";
              }
              if (/ later /.test(line) || / later$/.test(line)) {
                taskTag += "l";
              }
              if (/ waiting /.test(line) || / waiting$/.test(line)) {
                taskTag += "w";
              }
              if (/ done /.test(line) || / done$/.test(line)) {
                taskTag += "d";
              }
              if (/ archive /.test(line) || / archine$/.test(line)) {
                taskTag += "a";
              }
              if (taskTag.length == 5) {
                fm += "tags: " + taskTag + "\n";
              } else {
                new import_obsidian23.Notice("error on setting action tag");
                fm += line + "\n";
              }
            } else {
              fm += line + "\n";
            }
          }
          if (h3Count >= 2) {
            let modifiedLine = line;
            c += modifiedLine + "\n";
          }
          if (line === "---") {
            h3Count++;
          }
        }
        text += content;
        if (fm.length > 0) {
          text += fm;
        }
        text += c;
        text = text.replace(/^---\n+---\n/m, "---\ntags: b/n/c\n---\n").replace(/\n$/, "");
        editor.setValue(text);
        editor.setCursor({ line: getParentLine(text), ch: 0 });
        app.vault.rename(view.file, "C/" + view.file.name);
      },
      hotkeys: [
        {
          modifiers: [`Ctrl`, `Meta`, `Shift`],
          key: `7`
        },
        {
          modifiers: [`Ctrl`, `Alt`, `Shift`],
          key: `7`
        }
      ]
    });
    this.addObsidianIcon("note-to-tree-list", "**");
    this.addCommand({
      id: "note-to-tree-list",
      name: "NT Note to Tree List",
      icon: `note-to-tree-list`,
      editorCallback: (editor, view) => {
        const checkboxMap = /* @__PURE__ */ new Map();
        const lineCount = editor.lineCount();
        if (editor.getValue().startsWith("- " + view.file.basename + "\n")) {
          const filename = view.file.basename;
          let text = "";
          for (let i = 0; i < lineCount; i++) {
            const line = editor.getLine(i);
            if (line.trim().length != 0) {
              if (!/^\t*- $/.test(line) && !/^\t*\d+\. $/.test(line)) {
                let modLine = line;
                if (!modLine.contains("[[") && !modLine.contains("]]")) {
                  modLine = line.replace(`${filename} _ `, "");
                }
                if (line !== `- ${view.file.basename}` && /^- /.test(line)) {
                  modLine = "	" + modLine;
                }
                text += modLine + "\n";
              }
            }
          }
          text = text.replace(/\n$/m, "");
          editor.setValue(text);
          editor.setCursor({ line: getParentLine(text), ch: 0 });
        } else {
          editor.setValue(replaceTWUselessValue(editor.getValue()));
          let text = "- ";
          let h3Count = 0;
          let actionTag = "";
          let content = "";
          for (let i = 0; i < lineCount; i++) {
            const line = editor.getLine(i);
            if (h3Count == 0) {
              if (line.trim().length != 0 && line != "---") {
                let modifiedLine = line;
                for (let i2 = 0; i2 < 9; i2++) {
                  modifiedLine = modifiedLine.replace(/^    /, "	");
                }
                modifiedLine = modifiedLine.replace(/^(\t*)\*\s/, "$1- ");
                modifiedLine = /^\t*- /.test(modifiedLine) || /^\t*\d+\. /.test(modifiedLine) ? "	" + modifiedLine : "	- " + modifiedLine;
                content += "\n" + modifiedLine;
              }
            } else if (h3Count == 1) {
              if (line === "---" || shouldSkipFrontMatter(line) || line.startsWith("title: ")) {
              } else if (line.startsWith("tagsss: ")) {
                if (/ N /.test(line) || / N$/.test(line)) {
                  actionTag = "n";
                }
                if (/ W /.test(line) || / W$/.test(line)) {
                  actionTag = "w";
                }
                if (/ now /.test(line) || / now$/.test(line)) {
                  actionTag += "n";
                }
                if (/ later /.test(line) || / later$/.test(line)) {
                  actionTag += "l";
                }
                if (/ waiting /.test(line) || / waiting$/.test(line)) {
                  actionTag += "w";
                }
                if (/ done /.test(line) || / done$/.test(line)) {
                  actionTag += "d";
                }
                if (/ archive /.test(line) || / archine$/.test(line)) {
                  actionTag += "w";
                }
                if (actionTag.length == 2) {
                  actionTag = "#" + actionTag + " ";
                } else if (actionTag.length == 1) {
                  new import_obsidian23.Notice("error on setting action tag");
                }
              } else if (line.startsWith("checkboxbytime_")) {
                const keyValueArray = line.split(":").map((item) => item.trim());
                if (keyValueArray.length === 2) {
                  const key = keyValueArray[0];
                  const value = keyValueArray[1];
                  const splitArray = key.split("_");
                  const modifiedKey = `<<checkboxByTime "${splitArray[1]}">>`;
                  checkboxMap.set(modifiedKey, value === "open" ? "[x]" : "[ ]");
                }
              } else {
                if (line.trim().length != 0) {
                  let modifiedLine = line;
                  for (let i2 = 0; i2 < 9; i2++) {
                    modifiedLine = modifiedLine.replace(/^    /, "	");
                  }
                  modifiedLine = modifiedLine.replace(/^(\t*)\*\s/, "$1- ");
                  modifiedLine = /^\t*- /.test(modifiedLine) || /^\t*\d+\. /.test(modifiedLine) ? "	" + modifiedLine : "	- " + modifiedLine;
                  content += "\n" + modifiedLine;
                }
              }
            }
            if (h3Count >= 2 && line.trim().length != 0) {
              let modifiedLine = line === "[ ] " ? "" : line;
              if (modifiedLine.trim().length != 0) {
                for (let i2 = 0; i2 < 9; i2++) {
                  modifiedLine = modifiedLine.replace(/^    /, "	");
                }
                modifiedLine = modifiedLine.replace(/^(\t*)\*\s/, "$1- ");
                modifiedLine = /^\t*- /.test(modifiedLine) || /^\t*\d+\. /.test(modifiedLine) ? "	" + modifiedLine : "	- " + modifiedLine;
                for (const [key, value] of checkboxMap) {
                  modifiedLine = modifiedLine.replace(new RegExp(key, "g"), value);
                }
                modifiedLine = modifiedLine.replace(/<<checkboxByTime "[A-Za-z0-9_]+">>/g, "[ ]");
                text += "\n" + modifiedLine;
              }
            }
            if (line === "---") {
              let beforeH3 = h3Count;
              h3Count++;
              if (beforeH3 == 1 && h3Count == 2) {
                text += actionTag + view.file.basename;
              }
            }
          }
          if (h3Count < 2) {
            text += view.file.basename;
          }
          text += content;
          editor.setValue(text);
          editor.setCursor({ line: getParentLine(text), ch: 0 });
        }
      },
      hotkeys: [
        {
          modifiers: [`Ctrl`, `Meta`, `Shift`],
          key: `8`
        },
        {
          modifiers: [`Ctrl`, `Alt`, `Shift`],
          key: `8`
        }
      ]
    });
    this.addCommand({
      id: "remove-content-from-cursor",
      name: "Remove content from cursor",
      icon: `axe`,
      editorCallback: (editor, view) => {
        new RemoveContentFromCursorModal(this.app, editor).open();
      },
      hotkeys: [
        {
          modifiers: [`Ctrl`, `Meta`, `Shift`],
          key: `x`
        },
        {
          modifiers: [`Ctrl`, `Alt`, `Shift`],
          key: `x`
        }
      ]
    });
    this.addCommand({
      id: "remove-content-left",
      name: "Remove content left same line",
      icon: `arrow-left-circle`,
      editorCallback: (editor, view) => {
        removeContentLeftSameLine(editor);
      }
    });
    this.addCommand({
      id: "remove-content-right",
      name: "Remove content right same line",
      icon: `arrow-right-circle`,
      editorCallback: (editor, view) => {
        removeContentLeftSameLine(editor);
      }
    });
    this.addCommand({
      id: "remove-content-top-left",
      name: "Remove content from start of note to cursor",
      icon: `arrow-up-circle`,
      editorCallback: (editor, view) => {
        removeContentFromStartOfNoteToCursor(editor);
      }
    });
    this.addCommand({
      id: "remove-content-bottom-right",
      name: "Remove content from cursor to end of note",
      icon: `arrow-down-circle`,
      editorCallback: (editor, view) => {
        removeContentFromCursorToEndOfNote(editor);
      }
    });
    this.addObsidianIcon("threads-to-blog-icon", "TB");
    this.addCommand({
      id: "threads-to-blog",
      name: "TB Threads as pre Blog format to Clipboard",
      icon: `threads-to-blog-icon`,
      editorCallback: (editor, view) => {
        new ThreadsToBlogModal(this.app, editor, view).open();
      }
    });
    this.addObsidianIcon("add-comment-tag-icon", "CT");
    this.addCommand({
      id: "add-comment-tag",
      name: "CT Add Comment Tag",
      icon: `add-comment-tag-icon`,
      editorCallback: (editor, view) => {
        new AddFootnoteTagModal(this.app, editor).open();
      },
      hotkeys: [
        {
          modifiers: [`Ctrl`, `Meta`, `Shift`],
          key: `z`
        },
        {
          modifiers: [`Ctrl`, `Alt`, `Shift`],
          key: `z`
        }
      ]
    });
    this.addObsidianIcon("action-tag-count-icon", "CA");
    this.addCommand({
      id: "action-tag-count-icon",
      name: "CA Count Action Tag",
      icon: `action-tag-count-icon`,
      editorCallback: (editor, view) => {
        const tags = ["nn", "nl", "nw", "n1", "n2", "n3", "n4", "n5", "n6", "n7", "wn", "wl", "ww", "w1", "w2", "w3", "w4", "w5", "w6", "w7"];
        const matches = [];
        const lineNum = editor.lineCount();
        for (let i = 0; i < lineNum; i++) {
          const line = editor.getLine(i);
          const match = tags.some((tag2) => new RegExp(`#${tag2} `, "g").test(line) || new RegExp(` #${tag2}`, "g").test(line));
          if (match) {
            matches.push(`Line ${i}:
${line.trim()}`);
          }
        }
        const trimmedAndJoinedString = matches.join("\n\n");
        const tasks = matches.length > 0 ? `
Tasks:

${trimmedAndJoinedString}` : ``;
        new import_obsidian23.Notice(`There are ${matches.length} outstanding actions in this notes${tasks}`);
      }
    });
    this.addObsidianIcon("toggle-n-w-task", "#=");
    this.addCommand({
      id: `toggle-n-w-task`,
      name: `Toggle N W Task`,
      icon: `toggle-n-w-task`,
      editorCallback: (editor, view) => {
        console.log(editor.getSelection());
        const cursor = editor.getCursor();
        const lineNumber = editor.getCursor().line;
        const line = editor.getLine(lineNumber);
        if (line.match(/ a\/w\/./)) {
          const replacedLine = line.replace(/ a\/w\/(.)/, ` a/n/$1`);
          editor.setLine(lineNumber, replacedLine);
          editor.setCursor(cursor);
        } else if (line.match(/ a\/n\/./)) {
          const replacedLine = line.replace(/ a\/n\/(.)/, ` a/w/$1`);
          editor.setLine(lineNumber, replacedLine);
          editor.setCursor(cursor);
        } else if (line.match(/#w. /)) {
          const replacedLine = line.replace(/#w(.) /, `#n$1 `);
          editor.setLine(lineNumber, replacedLine);
          editor.setCursor(cursor);
        } else if (line.match(/#n. /)) {
          const replacedLine = line.replace(/#n(.) /, `#w$1 `);
          editor.setLine(lineNumber, replacedLine);
          editor.setCursor(cursor);
        } else if (line.match(/ #w./)) {
          const replacedLine = line.replace(/ #w(.)/, ` #n$1`);
          editor.setLine(lineNumber, replacedLine);
          editor.setCursor(cursor);
        } else if (line.match(/ #n./)) {
          const replacedLine = line.replace(/ #n(.)/, ` #w$1`);
          editor.setLine(lineNumber, replacedLine);
          editor.setCursor(cursor);
        }
      },
      hotkeys: [
        {
          modifiers: [`Ctrl`, `Meta`, `Shift`],
          key: `=`
        },
        {
          modifiers: [`Ctrl`, `Alt`, `Shift`],
          key: `=`
        }
      ]
    });
    this.addCommand({
      id: "cursor-go-to-start-of-line",
      name: "Cursor go to start of line",
      icon: `arrow-big-left`,
      editorCallback: (editor, view) => {
        const cursor = editor.getCursor();
        cursor.ch = 0;
        editor.setCursor(cursor);
      }
    });
    this.addCommand({
      id: "cursor-go-to-end-of-line",
      name: "Cursor go to end of line",
      icon: `arrow-big-right`,
      editorCallback: (editor, view) => {
        const cursor = editor.getCursor();
        const lineNum = cursor.line;
        const line = editor.getLine(lineNum);
        const length = line.length;
        cursor.ch = length;
        editor.setCursor(cursor);
      }
    });
    this.addObsidianIcon("event-to-fantastical-icon", "FE");
    this.addCommand({
      id: "add-fantastical-event",
      name: "FE Add Fantastical Event",
      icon: `event-to-fantastical-icon`,
      editorCallback: (editor, view) => {
        let text = "";
        const vault = this.app.vault;
        const listSelections = editor.listSelections();
        const processLine = async (line, i) => {
          if (/^- \d\d\d\d-\d\d-\d\d \d\d:\d\d /.test(line)) {
            const modifiedLine = line.replace(/^- /, `- #tm `);
            editor.setLine(i, modifiedLine);
            text += line + "\n";
            const lineToAdd = "-" + line.replace(/-/g, "");
            const path = line.replace(/^- (\d\d\d\d)-(\d\d)-.*/, "J/$1-M$2.md");
            let tFile = vault.getAbstractFileByPath(path);
            if (tFile == null) {
              tFile = await vault.create(path, lineToAdd);
            } else {
              const tFileOriginalValue = await vault.read(tFile);
              await vault.modify(tFile, tFileOriginalValue + "\n" + lineToAdd);
            }
          }
        };
        const processSelections = async () => {
          for (const listSelection of listSelections) {
            const a = listSelection.head.line;
            const b = listSelection.anchor.line;
            const fromLineNum = b > a ? a : b;
            const toLineNum = b > a ? b : a;
            for (let i = fromLineNum; i <= toLineNum; i++) {
              const line = editor.getLine(i);
              await processLine(line, i);
            }
          }
        };
        processSelections().then(() => {
          if (text.length !== 0) {
            text = encodeURI(text);
            window.open(`shortcuts://run-shortcut?name=Add%20Obsidian%20Inbox%20Event%20via%20Fantastical&input=text&text=${text}&x-success=obsidian://&x-cancel=obsidian://&x-error=obsidian://`);
          }
        });
      }
    });
    this.addCommand({
      id: "grep-title-as-link-to-clipboard",
      name: "Grep Title as link to clipboard",
      icon: `clipboard-list`,
      editorCallback: async (editor, view) => {
        const title = view.file.basename;
        const titleAsLink = `[[${title}]]`;
        try {
          this.addToClipboardHistory(titleAsLink);
          await navigator.clipboard.writeText(titleAsLink);
          new import_obsidian23.Notice(`Copied title "${title}" as link to clipboard!`);
        } catch (error) {
          new import_obsidian23.Notice(`Error occurred when copying to clipboard: ${error}`);
        }
      },
      hotkeys: [
        {
          modifiers: [`Meta`, `Shift`],
          key: `l`
        },
        {
          modifiers: [`Ctrl`, `Shift`],
          key: `l`
        }
      ]
    });
    this.addObsidianIcon("move-current-selection-to-beginning-of-notes", "<<");
    this.addCommand({
      id: "move-current-selection-to-beginning-of-notes",
      name: "MB << Move current selection to beginning of notes",
      icon: `move-current-selection-to-beginning-of-notes`,
      editorCallback: (editor, view) => {
        let selection = exportCurrentSelection(editor);
        if (/^    +- /m.test(selection) || /^- /m.test(selection) || /^# /m.test(selection) || /^` /m.test(selection) || /^> /m.test(selection) || /^\d+\. /m.test(selection)) {
        } else {
          selection = "- " + selection;
        }
        let newContent = "";
        const selectionRange = getCurrentSelectionLineNumber(editor);
        for (let i = 0; i < editor.lineCount(); i++) {
          if (i < selectionRange.fromLineNum || i > selectionRange.toLineNum) {
            newContent = newContent + editor.getLine(i) + "\n";
          }
        }
        new AddTextToNotesModal(this.app, selection, "move the selected text", true, () => editor.setValue(newContent.replace(/\n$/m, ""))).open();
      },
      hotkeys: [
        {
          modifiers: [`Ctrl`, `Meta`, `Shift`],
          key: `,`
        },
        {
          modifiers: [`Ctrl`, `Alt`, `Shift`],
          key: `,`
        }
      ]
    });
    this.addObsidianIcon("move-current-selection-to-end-of-notes", ">>");
    this.addCommand({
      id: "move-current-selection-to-end-of-notes",
      name: "ME >> Move current selection to beginning of notes",
      icon: `move-current-selection-to-end-of-notes`,
      editorCallback: (editor, view) => {
        let selection = exportCurrentSelection(editor);
        if (/^    +- /m.test(selection) || /^- /m.test(selection) || /^# /m.test(selection) || /^` /m.test(selection) || /^> /m.test(selection) || /^\d+\. /m.test(selection)) {
        } else {
          selection = "- " + selection;
        }
        let newContent = "";
        const selectionRange = getCurrentSelectionLineNumber(editor);
        for (let i = 0; i < editor.lineCount(); i++) {
          if (i < selectionRange.fromLineNum || i > selectionRange.toLineNum) {
            newContent = newContent + editor.getLine(i) + "\n";
          }
        }
        new AddTextToNotesModal(this.app, selection, "move the selected text", false, () => editor.setValue(newContent.replace(/\n$/m, ""))).open();
      },
      hotkeys: [
        {
          modifiers: [`Ctrl`, `Meta`, `Shift`],
          key: `.`
        },
        {
          modifiers: [`Ctrl`, `Alt`, `Shift`],
          key: `.`
        }
      ]
    });
    this.addObsidianIcon("add-current-selection-to-beginning-of-notes", "((");
    this.addCommand({
      id: "add-current-selection-to-beginning-of-notes",
      name: "SB (( Add current selection to beginning of notes",
      icon: `add-current-selection-to-beginning-of-notes`,
      editorCallback: (editor, view) => {
        let selection = exportCurrentSelection(editor);
        if (/^    +- /m.test(selection) || /^- /m.test(selection) || /^# /m.test(selection) || /^` /m.test(selection) || /^> /m.test(selection) || /^\d+\. /m.test(selection)) {
        } else {
          selection = "- " + selection;
        }
        new AddTextToNotesModal(this.app, selection, "add the selected text", true, () => {
        }).open();
      },
      hotkeys: [
        {
          modifiers: [`Ctrl`, `Meta`, `Shift`],
          key: `9`
        },
        {
          modifiers: [`Ctrl`, `Alt`, `Shift`],
          key: `9`
        }
      ]
    });
    this.addObsidianIcon("add-current-selection-to-end-of-notes", "))");
    this.addCommand({
      id: "add-current-selection-to-end-of-notes",
      name: "SE )) Add current selection to end of notes",
      icon: `add-current-selection-to-end-of-notes`,
      editorCallback: (editor, view) => {
        let selection = exportCurrentSelection(editor);
        if (/^    +- /m.test(selection) || /^- /m.test(selection) || /^# /m.test(selection) || /^` /m.test(selection) || /^> /m.test(selection) || /^\d+\. /m.test(selection)) {
        } else {
          selection = "- " + selection;
        }
        new AddTextToNotesModal(this.app, selection, "add the selected text", false, () => {
        }).open();
      },
      hotkeys: [
        {
          modifiers: [`Ctrl`, `Meta`, `Shift`],
          key: `0`
        },
        {
          modifiers: [`Ctrl`, `Alt`, `Shift`],
          key: `0`
        }
      ]
    });
    this.addObsidianIcon("add-current-link-to-beginning-of-notes", "[[");
    this.addCommand({
      id: "add-current-link-to-beginning-of-notes",
      name: "LB [[ Add current link to beginning of notes",
      icon: `add-current-link-to-beginning-of-notes`,
      editorCallback: (editor, view) => {
        const link = "- [[" + view.file.basename + "]]";
        new AddTextToNotesModal(this.app, link, "add the current note link", true, () => {
        }).open();
      },
      hotkeys: [
        {
          modifiers: [`Ctrl`, `Meta`, `Shift`],
          key: `[`
        },
        {
          modifiers: [`Ctrl`, `Alt`, `Shift`],
          key: `[`
        }
      ]
    });
    this.addObsidianIcon("add-current-link-to-end-of-notes", "]]");
    this.addCommand({
      id: "add-current-link-to-end-of-notes",
      name: "LE ]] Add current link to end-of-notes",
      icon: `add-current-link-to-end-of-notes`,
      editorCallback: (editor, view) => {
        const link = "- [[" + view.file.basename + "]]";
        new AddTextToNotesModal(this.app, link, "add the current note link", false, () => {
        }).open();
      },
      hotkeys: [
        {
          modifiers: [`Ctrl`, `Meta`, `Shift`],
          key: `]`
        },
        {
          modifiers: [`Ctrl`, `Alt`, `Shift`],
          key: `]`
        }
      ]
    });
    this.addCommand({
      id: "quick-navigate-to-notes",
      name: "NN Quick Navigate to Notes",
      icon: `aperture`,
      callback: async () => {
        new NavigateToNoteFromTagModal(this.app).open();
      },
      hotkeys: [
        {
          modifiers: [`Ctrl`, `Meta`, `Shift`],
          key: `;`
        },
        {
          modifiers: [`Ctrl`, `Alt`, `Shift`],
          key: `;`
        }
      ]
    });
    this.addObsidianIcon("threads-to-twitter", "TX");
    this.addCommand({
      id: "threads-to-twitter",
      name: "TT TX Threads to Twitter",
      icon: `threads-to-twitter`,
      editorCallback: (editor, view) => {
        const { vault } = this.app;
        const v = editor.getValue();
        const path = view.file.path;
        if (!path.match(/.\/Threads \d\d\d\d\d\d\d\d/)) {
          new import_obsidian23.Notice(`Will not proceed. It is not a threads post.`);
          return;
        }
        const newPath = path.replace(/(.\/)Threads /, "$1Twitter ");
        const { workspace } = this.app;
        const leaf = workspace.getLeaf(false);
        Promise.resolve().then(() => {
          return vault.adapter.exists(newPath);
        }).then((fileExists) => {
          if (fileExists) {
            new import_obsidian23.Notice(`Will not proceed. Twitter post already exist.`);
            return Promise.reject("Twitter post already exist");
          }
          return vault.create(newPath, v);
        }).then((tFile) => {
          return leaf.openFile(tFile, { active: true });
        }, (reason) => {
        }).then(() => {
          new import_obsidian23.Notice(`Created and opened Twitter notes!`);
        });
      }
    });
    this.addObsidianIcon("blog-to-clipboard-icon", "BJ");
    this.addCommand({
      id: "blog-to-clipboard",
      name: "BJ Blog content to clipboard",
      icon: `blog-to-clipboard-icon`,
      editorCallback: async (editor, view) => {
        const v = editor.getValue();
        if (v.includes("#nn") || v.includes("#nl") || v.includes("#nw") || v.includes("#wn") || v.includes("#wl") || v.includes("#ww")) {
          new import_obsidian23.Notice(`Will not proceed. As there are unfinished action tag.`);
          return;
        }
        if (!v.includes("<!--more-->")) {
          try {
            await navigator.clipboard.writeText("<!--more-->");
            new import_obsidian23.Notice(`Require "<!--more-->" as excerpt separator before posting.
"<!--more-->" already in clipboard`);
          } catch (error) {
            new import_obsidian23.Notice(`Require "<!--more-->" as excerpt separator before posting.
"<!--more-->" cannot be copied to clipboard`);
          }
          return;
        }
        const path = view.file.path;
        let line = editor.lineCount();
        let text = "";
        let numLineFirstContent = 0;
        let frontMatterLineCount = 0;
        for (let i = 0; i < line; i++) {
          if (frontMatterLineCount == 2) {
            numLineFirstContent = i;
            break;
          }
          if (editor.getLine(i) == "---") {
            frontMatterLineCount++;
          }
        }
        for (let i = 0; i < line; i++) {
          if (editor.getLine(numLineFirstContent).trim() == "") {
            numLineFirstContent++;
          } else {
            break;
          }
        }
        Array.from(Array(line - numLineFirstContent).keys()).forEach((i) => {
          const line2 = editor.getLine(i + numLineFirstContent);
          text = text + line2 + "\n";
        });
        text = text.replace(/\n---\n\n#nd generate summary for meta description below:\n[^\n]*\n([^\n]*)\n[^\n]*\n---\n/, "\n<!-- Meta Summary -->\n<!--\n$1\n-->\n");
        text = text.replace(/## References\:([\n]*.*)*$/, "");
        const app2 = this.app;
        const beforeTagCBR = "c/b/r";
        const beforeTagCBD = "c/b/d";
        const beforeTagCBI = "c/b/i";
        const afterTag = "c/b/p";
        try {
          await navigator.clipboard.writeText(text);
          new import_obsidian23.Notice(`Copied blog content to clipboard!`);
          const foundTagFromCBR = await renameTag(view.file, beforeTagCBR, afterTag);
          if (foundTagFromCBR) {
            new import_obsidian23.Notice(`Update notes type from tag="${beforeTagCBR}" to tag="${afterTag}!`);
          }
          const foundTagFromCBI = await renameTag(view.file, beforeTagCBI, afterTag);
          if (foundTagFromCBI) {
            new import_obsidian23.Notice(`Update notes type from tag="${foundTagFromCBI}" to tag="${afterTag}!`);
          }
          const foundTagFromCBD = await renameTag(view.file, beforeTagCBD, afterTag);
          if (foundTagFromCBD) {
            new import_obsidian23.Notice(`Update notes type from tag="${beforeTagCBD}" to tag="${afterTag}!`);
          }
          await renameBlogTitle(app2, path, view);
          window.open(`shortcuts://run-shortcut?name=Jekyll%20blog&x-cancel=obsidian://&x-error=obsidian://`);
        } catch (error) {
          new import_obsidian23.Notice(`Error occurred during the operation: ${error}`);
        }
      }
    });
    this.addObsidianIcon("generate-chatgpt-prompt", "GP");
    this.addCommand({
      id: "generate-chatgpt-prompt",
      name: "GP Generate ChatGPT Prompt",
      icon: `generate-chatgpt-prompt`,
      editorCallback: async (editor, view) => {
        let line = editor.lineCount();
        let text = "\u3010" + view.file.basename + "\u3011\n\n";
        let numLineFirstContent = 0;
        let frontMatterLineCount = 0;
        for (let i = 0; i < line; i++) {
          if (frontMatterLineCount == 2) {
            numLineFirstContent = i;
            break;
          }
          if (editor.getLine(i) == "---") {
            frontMatterLineCount++;
          }
        }
        for (let i = 0; i < line; i++) {
          if (editor.getLine(numLineFirstContent).trim() == "") {
            numLineFirstContent++;
          } else {
            break;
          }
        }
        Array.from(Array(line - numLineFirstContent).keys()).forEach((i) => {
          const line2 = editor.getLine(i + numLineFirstContent);
          if (!line2.startsWith("%%") && !line2.endsWith("%%")) {
            text = text + line2 + "\n";
          }
        });
        text = text.replace(/## References\:([\n]*.*)*$/, "");
        navigator.clipboard.writeText(text).then(function() {
          new import_obsidian23.Notice(`Copied content to clipboard for generating prompt!`);
          window.open(`shortcuts://run-shortcut?name=Generate%20ChatGPT%20Prompt&x-success=obsidian://&x-cancel=obsidian://&x-error=obsidian://`);
        }, function(error) {
          new import_obsidian23.Notice(`error when copy to clipboard!`);
        });
      }
    });
    this.addObsidianIcon("threads-to-clipboard-icon", "TC");
    this.addCommand({
      id: "threads-to-clipboard",
      name: "TC Threads content to clipboard",
      icon: `threads-to-clipboard-icon`,
      editorCallback: (editor, view) => {
        const value = editor.getValue();
        const text = this.getThreadsSegment(editor);
        const beforeTag = "c/t/r";
        const afterTag = "c/t/t";
        navigator.clipboard.writeText(text).then(function() {
          return renameTag(view.file, beforeTag, afterTag);
        }, function(error) {
          new import_obsidian23.Notice(`error when copy to clipboard!`);
        }).then((foundTag) => {
          if (foundTag) {
            new import_obsidian23.Notice(`Update notes type from tag="${beforeTag}" to tag="${afterTag}!
Copied thread content to clipboard!`);
          } else {
            new import_obsidian23.Notice(`Tag "${beforeTag}" not found
Copied thread content to clipboard!`);
          }
        });
      }
    });
    this.addObsidianIcon("twitter-to-chatgpt", "XG");
    this.addCommand({
      id: "twitter-to-chatgpt",
      name: "XG Twitter to ChatGPT",
      icon: `twitter-to-chatgpt`,
      editorCallback: (editor, view) => {
        const value = editor.getValue();
        if (!view.file.basename.contains("Twitter")) {
          new import_obsidian23.Notice("Note name not contains 'Twitter', did not copy from thread note?");
          return;
        }
        let content = this.convertThreadsContentToPOE(editor);
        let numTweet = Math.ceil(content.length / 110);
        let prompt = `\u60A8\u662F\u793E\u4EA4\u5A92\u9AD4\u5167\u5BB9\u64B0\u5BEB\u5E2B\u3002\u5C07\u4E0B\u5217\u5167\u5BB9\u8F49\u70BA\u4E0D\u8D85\u904E${numTweet}\u689D\u7684\u63A8\u7279\u4E32\uFF0C\u4EE5\u7E41\u9AD4\u4E2D\u6587\u5448\u73FE\u3002\u4FDD\u7559\u6A19\u984C\uFF0C\u4E26\u5C07\u6A19\u984C\u5408\u4F75\u5230\u7B2C\u4E00\u689D\u63A8\u6587\u4E2D\uFF0C\u6A19\u984C\u548C\u7B2C\u4E00\u689D\u63A8\u6587\u4E4B\u9593\u52A0\u5169\u500B\u63DB\u884C\u3002\u6BCF\u689D\u63A8\u6587\u8981\u8D85\u904E100\u5B57\u4F46\u4E0D\u8D85\u904E140\u5B57\u3002\u5167\u5BB9\u4E0D\u7C21\u5316\uFF0C\u4E0D\u65B0\u589E\u672A\u63D0\u53CA\u8CC7\u8A0A\u3002\u4FDD\u7559\u539F\u6587\u4F8B\u5B50\uFF0C\u4E0D\u52A0\u6A19\u7C64\u3002\u63A8\u6587\u4E2D\u4E0D\u52A0\u6578\u5B57\u3002\u6BCF\u689D\u63A8\u6587\u5F8C\u52A0\u5169\u500B\u63DB\u884C\u53CA\u4E09\u500B\u77ED\u5283\u7DDA\u548C\u53E6\u4E00\u500B\u63DB\u884C\u3002\u82F1\u6587\u548C\u4E2D\u6587\u4E4B\u9593\u52A0\u7A7A\u683C\u3002\u82E5\u539F\u6587\u6709\u7DB2\u5740\uFF0C\u4FDD\u7559\u7DB2\u5740\uFF0C\u4E0D\u7528Markdown\u683C\u5F0F\uFF0C\u4E26\u5728\u7DB2\u5740\u524D\u52A0\u5169\u500B\u63DB\u884C\u3002`;
        prompt = prompt + "\n\n" + content;
        prompt = prompt.replace(/▍/g, "");
        prompt = prompt.replace(/】\n+https\:\/\/github.com[^\n]+\n/m, "\u3011\n");
        prompt = prompt.replace(/\*\*/gm, "");
        navigator.clipboard.writeText(prompt).then(function() {
          let line = editor.lineCount();
          let numLineFirstContent = 0;
          let frontMatterLineCount = 0;
          for (let i = 0; i < line; i++) {
            if (frontMatterLineCount == 2) {
              numLineFirstContent = i;
              break;
            }
            if (editor.getLine(i) == "---") {
              frontMatterLineCount++;
            }
          }
          for (let i = 0; i < line; i++) {
            if (editor.getLine(numLineFirstContent).trim() == "") {
              numLineFirstContent++;
            } else {
              break;
            }
          }
          let text = "";
          Array.from(Array(numLineFirstContent).keys()).forEach((i) => {
            const line2 = editor.getLine(i);
            text = text + line2 + "\n";
          });
          editor.setValue(text);
          renameTag(view.file, "c/t/d", "c/x/d");
          renameTag(view.file, "c/t/r", "c/x/d");
          renameTag(view.file, "c/t/t", "c/x/d");
          renameTag(view.file, "c/t/p", "c/x/d");
          const cursor = editor.getCursor();
          cursor.line = editor.lineCount() - 1;
          cursor.ch = 0;
          editor.setCursor(cursor);
          new import_obsidian23.Notice("copied to clipboard, please open chatgpt to paste");
        }, function(error) {
          new import_obsidian23.Notice(`error when copy to clipboard!`);
        });
      }
    });
    this.addObsidianIcon("chatgpt-to-twitter", "GX");
    this.addCommand({
      id: "chatgpt-to-twitter",
      name: "GX ChatGPT to Twitter",
      icon: `chatgpt-to-twitter`,
      editorCallback: (editor, view) => {
        if (!editor.getValue().contains("c/x/d")) {
          new import_obsidian23.Notice("Note type not c/x/d, do the action in wrong note?");
          return;
        }
        const isSuccess = this.convertChatGPTToTwitterFormat(editor);
        if (isSuccess) {
          renameTag(view.file, "c/x/d", "c/x/r");
        }
      }
    });
    this.addObsidianIcon("reverse-twitter-number-icon", "RT");
    this.addCommand({
      id: "reverse-twitter-numbering",
      name: "RT Reverse Twitter Numbering",
      icon: `reverse-twitter-number-icon`,
      editorCallback: (editor, view) => {
        if (!editor.getValue().contains("c/x/r") && !editor.getValue().contains("c/x/p")) {
          new import_obsidian23.Notice("Note type not c/x/r nor c/x/p, do the action in wrong note?");
          return;
        }
        this.reverseTwitterNumbering(editor);
        renameTag(view.file, "c/x/p", "c/x/d");
        renameTag(view.file, "c/x/r", "c/x/d");
      }
    });
    this.addObsidianIcon("threads-as-facebook-post-to-clipboard-icon", "FC");
    this.addCommand({
      id: "threads-as-facebook-post-to-clipboard",
      name: "FC Threads as Facebook post format to Clipboard",
      icon: `threads-as-facebook-post-to-clipboard-icon`,
      editorCallback: (editor, view) => {
        const value = editor.getValue();
        const text = this.convertThreadsContentToFormatForFacebookApp(editor);
        const beforeTag = "c/t/t";
        const afterTag = "c/t/p";
        navigator.clipboard.writeText(text).then(function() {
          return renameTag(view.file, beforeTag, afterTag);
        }, function(error) {
          new import_obsidian23.Notice(`error when copy to clipboard!`);
        }).then((foundTag) => {
          if (foundTag) {
            new import_obsidian23.Notice(`Update notes type from tag="${beforeTag}" to tag="${afterTag}!
Copied fb content to clipboard!`);
          } else {
            new import_obsidian23.Notice(`Tag "${beforeTag}" not found
Copied fb content to clipboard!`);
          }
        });
      }
    });
    this.addObsidianIcon("threads-block-to-image", "TI");
    this.addCommand({
      id: "threads-block-to-image",
      name: "TI Threads segment to image",
      icon: `threads-block-to-image`,
      editorCallback: (editor, view) => {
        const threadSegment = this.getThreadSegment(editor);
        new ThreadsToImagesModal(this.app, threadSegment).open();
      }
    });
    this.addObsidianIcon("chatgpt-generate-image", "GI");
    this.addCommand({
      id: "chatgpt-generate-image",
      name: "GI ChatGPT image",
      icon: `chatgpt-generate-image`,
      editorCallback: (editor, view) => {
        window.open("shortcuts://run-shortcut?name=ChatGPT%20Generate%20Image&x-success=obsidian://&x-cancel=obsidian://&x-error=obsidian://");
      }
    });
    this.addObsidianIcon("twitter-segment-to-clipboard", "XC");
    this.addCommand({
      id: "twitter-segment-to-clipboard",
      name: "XC Twitter segment to clipboard",
      icon: `twitter-segment-to-clipboard`,
      editorCallback: (editor, view) => {
        const threadSegment = this.getTwitterSegment(editor);
        const beforeTag = "c/x/r";
        const afterTag = "c/x/p";
        navigator.clipboard.writeText(threadSegment).then(function() {
          return renameTag(view.file, beforeTag, afterTag);
        }, function(error) {
          new import_obsidian23.Notice(`error when copy to clipboard!`);
        }).then((foundTag) => {
          if (foundTag) {
            new import_obsidian23.Notice(`Update notes type from tag="${beforeTag}" to tag="${afterTag}!
Copied
\`\`\`
${threadSegment}\`\`\`
to clipboard!`);
          } else {
            new import_obsidian23.Notice(`Tag "${beforeTag}" not found
Copied
\`\`\`
${threadSegment}\`\`\`
to clipboard!`);
          }
        });
      }
    });
    this.addObsidianIcon("segment-to-clipboard", "SC");
    this.addCommand({
      id: "segment-to-clipboard",
      name: "SC Segment to clipboard",
      icon: `segment-to-clipboard`,
      editorCallback: (editor, view) => {
        const threadSegment = this.getSegment(editor);
        this.addToClipboardHistory(threadSegment);
        navigator.clipboard.writeText(threadSegment).then(function() {
          new import_obsidian23.Notice(`Copied
\`\`\`
${threadSegment}\`\`\`
to clipboard!`);
        }, function(error) {
          new import_obsidian23.Notice(`error when copy to clipboard!`);
        });
      }
    });
    this.addCommand({
      id: "n-find-replace",
      name: "Find or Replace",
      icon: `file-search`,
      editorCallback: (editor, view) => {
        new FindReplaceModal(this.app).open();
      }
    });
    this.addCommand({
      id: "toggle-bullet-number-list",
      name: "Toggle Bullet Number List",
      icon: `bullet-list`,
      editorCallback: (editor, view) => {
        const cursor = editor.getCursor();
        const ch = cursor.ch;
        const line = cursor.line;
        const lineContent = editor.getLine(line);
        const previousLineContent = line == 0 ? "" : editor.getLine(line - 1);
        if (/^(> )*\s*- /.test(lineContent)) {
          let n = "1.";
          const a = previousLineContent.match(/^\t*(\d+)\. /);
          if (a) {
            const nextN = parseInt(a[0]) + 1;
            n = nextN.toString() + ".";
          }
          const replacedLineContent = lineContent.replace(/^((> )*)(\s*)- /, "$1$3" + n + " ");
          editor.setLine(line, replacedLineContent);
          cursor.ch = cursor.ch + n.length - 1;
          editor.setCursor(cursor);
        } else if (/^(> )*\s*[\d]+\. /.test(lineContent)) {
          const n = lineContent.replace(/^((> )*)(\s*)([\d]+\. ).*/, "$4");
          const replacedLineContent = lineContent.replace(/^((> )*)(\s*)[\d]+\. /, "$1$3");
          editor.setLine(line, replacedLineContent);
          cursor.ch = cursor.ch - n.length > 0 ? cursor.ch - n.length : 0;
          editor.setCursor(cursor);
        } else {
          const replacedLineContent = lineContent.replace(/^((> )*)(\s*)/, "$1$3- ");
          editor.setLine(line, replacedLineContent);
          cursor.ch = cursor.ch + 2;
          editor.setCursor(cursor);
        }
      },
      hotkeys: [
        {
          modifiers: [`Ctrl`, `Meta`, `Shift`],
          key: `-`
        },
        {
          modifiers: [`Ctrl`, `Alt`, `Shift`],
          key: `-`
        }
      ]
    });
    this.addCommand({
      id: "copy-or-move-to-new-note",
      name: "Copy or Move to new note CMN",
      icon: `airplay`,
      editorCallback: async (editor, view) => {
        new CopyOrMoveToNewNoteModal(this.app, editor).open();
      }
    });
    this.addCommand({
      id: "editor-copy-line-to-clipboard",
      name: "Editor Copy Line to Clipboard",
      icon: `align-vertical-space-around`,
      editorCallback: (editor, view) => {
        const selection = exportCurrentSelection(editor);
        const copyContent = selection.contains("\n") ? selection : selection.replace(/^\t*- /, "").replace(/^\t*\d+\. /, "");
        this.addToClipboardHistory(copyContent);
        navigator.clipboard.writeText(copyContent).then(function() {
          new import_obsidian23.Notice(`Copied content
\`\`\`
${copyContent}
\`\`\`
to clipboard!`);
        }, function(error) {
          new import_obsidian23.Notice(`error when copy to clipboard!`);
        });
      },
      hotkeys: [
        {
          modifiers: [`Ctrl`, `Meta`, `Shift`],
          key: "/"
        },
        {
          modifiers: [`Ctrl`, `Alt`, `Shift`],
          key: "/"
        }
      ]
    });
    this.addCommand({
      id: "editor-cut-line-to-clipboard",
      name: "Editor Cut Line to Clipboard",
      icon: `align-vertical-justify-center`,
      editorCallback: (editor, view) => {
        const selection = exportCurrentSelection(editor);
        const cursor = editor.getCursor();
        const copyContent = selection.contains("\n") ? selection : selection.replace(/^\t*- /, "").replace(/^\t*\d+\. /, "");
        let newContent = "";
        const selectionRange = getCurrentSelectionLineNumber(editor);
        for (let i = 0; i < editor.lineCount(); i++) {
          if (i < selectionRange.fromLineNum || i > selectionRange.toLineNum) {
            newContent = newContent + editor.getLine(i) + "\n";
          }
        }
        this.addToClipboardHistory(copyContent);
        navigator.clipboard.writeText(copyContent).then(function() {
          new import_obsidian23.Notice(`Copied content
\`\`\`
${copyContent}
\`\`\`
to clipboard!`);
        }, function(error) {
          new import_obsidian23.Notice(`error when copy to clipboard!`);
        });
        editor.setValue(newContent);
        cursor.line = selectionRange.fromLineNum;
        if (editor.getLine(selectionRange.fromLineNum).length < selectionRange.fromCh) {
          cursor.ch = editor.getLine(selectionRange.fromLineNum).length;
        }
        editor.setCursor(cursor);
      },
      hotkeys: [
        {
          modifiers: [`Ctrl`, `Meta`, `Shift`],
          key: "\\"
        },
        {
          modifiers: [`Ctrl`, `Alt`, `Shift`],
          key: "\\"
        }
      ]
    });
    this.addCommand({
      id: "editor-indent-line",
      name: "Editor Indent Selection",
      icon: `right-arrow-with-tail`,
      editorCallback: (editor, view) => {
        const listSelections = editor.listSelections();
        listSelections.forEach((listSelection) => {
          const a = listSelection.head.line;
          const b = listSelection.anchor.line;
          const fromLineNum = b > a ? a : b;
          const toLineNum = b > a ? b : a;
          for (let i = fromLineNum; i <= toLineNum; i++) {
            const line = editor.getLine(i);
            editor.setLine(i, line.replace(/^/, "	"));
          }
        });
        let lss = [];
        listSelections.forEach((ls) => {
          const head = ls.head;
          head.ch = head.ch + 1;
          const anchor = ls.anchor;
          anchor.ch = anchor.ch + 1;
          const newLs = { anchor, head };
          lss.push(newLs);
        });
        editor.setSelections(lss);
      }
    });
    this.addCommand({
      id: "editor-outdent-line",
      name: "Editor Outdent Selection",
      icon: `left-arrow-with-tail`,
      editorCallback: (editor, view) => {
        const listSelections = editor.listSelections();
        listSelections.forEach((listSelection) => {
          const a = listSelection.head.line;
          const b = listSelection.anchor.line;
          const fromLineNum = b > a ? a : b;
          const toLineNum = b > a ? b : a;
          for (let i = fromLineNum; i <= toLineNum; i++) {
            const line = editor.getLine(i);
            editor.setLine(i, line.replace(/^\t/, ""));
          }
        });
        let lss = [];
        listSelections.forEach((ls) => {
          const head = ls.head;
          head.ch = head.ch + 1;
          const anchor = ls.anchor;
          anchor.ch = anchor.ch + 1;
          const newLs = { anchor, head };
          lss.push(newLs);
        });
        editor.setSelections(lss);
      }
    });
    this.addSettingTab(new SampleSettingTab(this.app, this));
  }
  convertChatGPTToTwitterFormat(editor) {
    let line = editor.lineCount();
    let numLineFirstContent = 0;
    let frontMatterLineCount = 0;
    for (let i = 0; i < line; i++) {
      if (frontMatterLineCount == 2) {
        numLineFirstContent = i;
        break;
      }
      if (editor.getLine(i) == "---") {
        frontMatterLineCount++;
      }
    }
    for (let i = 0; i < line; i++) {
      if (editor.getLine(numLineFirstContent).trim() == "") {
        numLineFirstContent++;
      } else {
        break;
      }
    }
    let totalTweetCount = 1;
    Array.from(Array(line - numLineFirstContent).keys()).forEach((i) => {
      const line2 = editor.getLine(i + numLineFirstContent);
      let modifiedLine = line2.replace(/^____+/, "---").replace(/^----+/, "---");
      editor.setLine(i + numLineFirstContent, modifiedLine);
      if (modifiedLine == "---") {
        totalTweetCount = totalTweetCount + 1;
      }
    });
    let numTweet = 1;
    let readyToAddTweetCount = true;
    let text = "";
    Array.from(Array(numLineFirstContent).keys()).forEach((i) => {
      const line2 = editor.getLine(i);
      text = text + line2 + "\n";
    });
    Array.from(Array(line - numLineFirstContent).keys()).forEach((i) => {
      const line2 = editor.getLine(i + numLineFirstContent);
      let modifiedLine = line2;
      if (line2 == "---") {
        readyToAddTweetCount = true;
        numTweet = numTweet + 1;
      } else if (line2 != "" && readyToAddTweetCount) {
        if (!/^\d+\/\d+.*/.test(line2)) {
          modifiedLine = `${numTweet}/${totalTweetCount} ${line2}`;
        }
        readyToAddTweetCount = false;
      }
      text = text + modifiedLine + "\n";
    });
    text = text.replace("\u258D", "");
    const tweets = text.split("---");
    for (let i = 0; i < tweets.length; i++) {
      const tweet = tweets[i].replace(/(https:|http:|www\.)\S*/gm, "").replace(/^\n+/m, "").replace(/\n+$/m, "");
      if (tweet.length > 140) {
        new import_obsidian23.Notice("```\n" + tweet + "\n```\n\nexceed 140 characters. Probably cannot post in twitter. Please refine the tweet. Aborting");
        return false;
      }
    }
    editor.setValue(text);
    const cursor = editor.getCursor();
    cursor.line = editor.lineCount() - 1;
    editor.setCursor(cursor);
    return true;
  }
  reverseTwitterNumbering(editor) {
    let line = editor.lineCount();
    let numLineFirstContent = 0;
    let frontMatterLineCount = 0;
    for (let i = 0; i < line; i++) {
      if (frontMatterLineCount == 2) {
        numLineFirstContent = i;
        break;
      }
      if (editor.getLine(i) == "---") {
        frontMatterLineCount++;
      }
    }
    for (let i = 0; i < line; i++) {
      if (editor.getLine(numLineFirstContent).trim() == "") {
        numLineFirstContent++;
      } else {
        break;
      }
    }
    let text = "";
    Array.from(Array(numLineFirstContent).keys()).forEach((i) => {
      const line2 = editor.getLine(i);
      text = text + line2 + "\n";
    });
    Array.from(Array(line - numLineFirstContent).keys()).forEach((i) => {
      const line2 = editor.getLine(i + numLineFirstContent);
      const modifiedLine = line2.replace(/^\d+\/\d+ /, "");
      text = text + modifiedLine + "\n";
    });
    editor.setValue(text);
    const cursor = editor.getCursor();
    cursor.line = editor.lineCount() - 1;
    editor.setCursor(cursor);
  }
  convertThreadsContentToFormatForThreadsApp(editor) {
    let result = this.convertThreadsContentToLightPostFormat(editor, "\u{1F9F5}", "\n\n\n");
    result = result.replace(/https\:\/\/github.com[^\n]+\n\n\n/m, "");
    return result;
  }
  convertThreadsContentToFormatForFacebookApp(editor) {
    return this.convertThreadsContentToLightPostFormat(editor, "", "\n\n\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\n\n", (a) => a.replace("\u{1F447}", ""));
  }
  convertThreadsContentToPOE(editor) {
    return this.convertThreadsContentToLightPostFormat(editor, "", "\n\n---\n\n", (a) => a.replace("\u{1F447}", ""));
  }
  /*
  	addTaskToPutIntoCardInThreadsContent(editor: Editor) {
  		let line = editor.lineCount();
  
  		let frontMatterLineCount = 0
  		let text = "";
  		for (let i = 0; i < line; i++) {
  			if (editor.getLine(i) == "---") {
  				frontMatterLineCount++
  			}
  			const line = editor.getLine(i);
  			
  			//if (frontMatterLineCount > 2 && line == "---") {
  			//	text = text + "%% #nm to zk %%\n\n"
  			//}
  			text = text + line + "\n"
  		}
  
  		editor.setValue(text);
  	}
  */
  convertThreadsContentToLightPostFormat(editor, headerIcon, paragraphSeparator, additionReplaceFn = (a) => a) {
    let line = editor.lineCount();
    let numLineFirstContent = 0;
    let frontMatterLineCount = 0;
    for (let i = 0; i < line; i++) {
      if (frontMatterLineCount == 2) {
        numLineFirstContent = i;
        break;
      }
      if (editor.getLine(i) == "---") {
        frontMatterLineCount++;
      }
    }
    for (let i = 0; i < line; i++) {
      if (editor.getLine(numLineFirstContent).trim() == "") {
        numLineFirstContent++;
      } else {
        break;
      }
    }
    let text = "";
    let newConsecutiveLineCount = 0;
    Array.from(Array(line - numLineFirstContent).keys()).forEach((i) => {
      const line2 = editor.getLine(i + numLineFirstContent);
      if (!line2.trim().startsWith("%%") || !line2.trim().endsWith("%%")) {
        if (line2 == "---") {
          newConsecutiveLineCount = 0;
        }
        if (line2 == "") {
          newConsecutiveLineCount++;
        } else {
          newConsecutiveLineCount = 0;
        }
        if (line2 == "" && newConsecutiveLineCount > 1) {
        } else {
          let modifiedLine = line2 == "---" ? "" : line2;
          modifiedLine = modifiedLine.replace(/^		- /g, "\u3000\u3000\u3000\u3000\u2022 ").replace(/^	- /g, "\u3000\u3000\u2022 ").replace(/^- /, "\u2022 ");
          modifiedLine = modifiedLine.replace(/^\[([^\[\]\(\)]+)\]\([^\[\]\(\)]+\)/g, "$1").replace(/[^!]\[([^\[\]\(\)]+)\]\([^\[\]\(\)]+\)/g, "$1");
          modifiedLine = modifiedLine.replace(/!\[([^\[\]\(\)]+)\]\(([^\[\]\(\)]+)\)/g, "$2");
          modifiedLine = modifiedLine.replace(/\*\*/gm, "");
          text = text + modifiedLine + "\n";
        }
      }
    });
    text = text.replace(/🧵[ ]+(.*)/g, headerIcon + "\u3010$1\u3011");
    text = additionReplaceFn(text);
    text = text.replace(/[\n\r]{3,}/gm, `${paragraphSeparator}\u258D`);
    text = text.replace("\n\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\n\n\u258D\n", "");
    let text2 = "";
    text.split("\n").forEach((line2) => {
      var l = "";
      if (line2.endsWith("\u3002") || line2.endsWith("\uFF1A") || line2.endsWith("\uFF5E") || line2.endsWith("\uFF01") || line2.startsWith("\u258Dhttp") || line2.startsWith("\u258D#") || line2 == "\u258D") {
        l = line2.replace(/^▍/gm, "");
      } else {
        l = line2;
      }
      text2 = text2 + l + "\n";
    });
    text2 = text2.replace("\n\n\n\n", "");
    text2 = text2.replace("\n\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\n\n\n", "");
    text2 = text2.replace(/\n\n## Opinion from ChatGPT\:([\n]*.*)*$/, "");
    text2 = text2.replace(/## References\:([\n]*.*)*$/, "");
    text2 = text2.replace(/\n+$/, "");
    return text2;
  }
  getThreadSegment(editor) {
    let cursor = editor.getCursor();
    let line = cursor.line;
    let above = line;
    let below = line;
    while (above >= 0) {
      let l = editor.getLine(above);
      if (l == "---") {
        break;
      }
      above--;
    }
    if (editor.getLine(above) == "---") {
      above++;
    }
    while (true) {
      if (editor.getLine(above) == "") {
        above++;
      } else {
        break;
      }
    }
    while (below < editor.lineCount()) {
      let l = editor.getLine(below);
      if (l == "---") {
        break;
      }
      below++;
    }
    if (editor.getLine(below) == "---") {
      below--;
    }
    while (true) {
      if (editor.getLine(below) == "") {
        below--;
      } else {
        break;
      }
    }
    let text = "";
    Array.from(Array(below - above + 1).keys()).forEach((i) => {
      const line2 = editor.getLine(i + above);
      if (!line2.trim().startsWith("%%") || !line2.trim().endsWith("%%")) {
        let modifiedLine = editor.getLine(i + above);
        modifiedLine = modifiedLine.replace(/^\[([^\[\]\(\)]+)\]\([^\[\]\(\)]+\)/g, "$1").replace(/[^!]\[([^\[\]\(\)]+)\]\([^\[\]\(\)]+\)/g, "$1");
        text = text + modifiedLine + "\n";
      }
    });
    text = text.replace(/\n+$/, "");
    return text;
  }
  getSegment(editor) {
    let cursor = editor.getCursor();
    let line = cursor.line;
    let above = line;
    let below = line;
    while (above >= 0) {
      let l = editor.getLine(above);
      if (l == "---") {
        break;
      }
      above--;
    }
    if (editor.getLine(above) == "---") {
      above++;
    }
    while (true) {
      if (editor.getLine(above) == "") {
        above++;
      } else {
        break;
      }
    }
    while (below < editor.lineCount()) {
      let l = editor.getLine(below);
      if (l == "---") {
        break;
      }
      below++;
    }
    if (editor.getLine(below) == "---") {
      below--;
    }
    while (true) {
      if (editor.getLine(below) == "") {
        below--;
      } else {
        break;
      }
    }
    let text = "";
    Array.from(Array(below - above + 1).keys()).forEach((i) => {
      const line2 = editor.getLine(i + above);
      text = text + line2 + "\n";
    });
    text = text.replace(/\n+$/, "");
    return text;
  }
  getTwitterSegment(editor) {
    let cursor = editor.getCursor();
    let line = cursor.line;
    let above = line;
    let below = line;
    while (above >= 0) {
      let l = editor.getLine(above);
      if (l == "---") {
        break;
      }
      above--;
    }
    if (editor.getLine(above) == "---") {
      above++;
    }
    while (true) {
      if (editor.getLine(above) == "") {
        above++;
      } else {
        break;
      }
    }
    while (below < editor.lineCount()) {
      let l = editor.getLine(below);
      if (l == "---") {
        break;
      }
      below++;
    }
    if (editor.getLine(below) == "---") {
      below--;
    }
    while (true) {
      if (editor.getLine(below) == "") {
        below--;
      } else {
        break;
      }
    }
    let text = "";
    Array.from(Array(below - above + 1).keys()).forEach((i) => {
      const line2 = editor.getLine(i + above);
      if (!line2.trim().startsWith("%%") || !line2.trim().endsWith("%%")) {
        let modifiedLine = editor.getLine(i + above);
        if (!/\d+\/\d+ *【.*】/.test(modifiedLine)) {
          modifiedLine = modifiedLine.replace(/^\[([^\[\]\(\)]+)\]\([^\[\]\(\)]+\)/g, "$1").replace(/[^!]\[([^\[\]\(\)]+)\]\([^\[\]\(\)]+\)/g, "$1").replace(/https[^\n]+\.jpeg/g, "").replace(/？([^】」\n])/g, "\uFF1F\n\n$1").replace(/。([^】」\n])/g, "\u3002\n\n$1").replace(/！([^】」\n])/g, "\uFF01\n\n$1").replace(/～([^】」\n])/g, "\uFF5E\n\n$1").replace(/^\s+$/, "");
        }
        text = text + modifiedLine + "\n";
      }
    });
    text = text.replace(/\n+$/, "");
    return text;
  }
  getThreadsSegment(editor) {
    let cursor = editor.getCursor();
    let line = cursor.line;
    let above = line;
    let below = line;
    while (above >= 0) {
      let l = editor.getLine(above);
      if (l == "---") {
        break;
      }
      above--;
    }
    if (editor.getLine(above) == "---") {
      above++;
    }
    while (true) {
      if (editor.getLine(above) == "") {
        above++;
      } else {
        break;
      }
    }
    while (below < editor.lineCount()) {
      let l = editor.getLine(below);
      if (l == "---") {
        break;
      }
      below++;
    }
    if (editor.getLine(below) == "---") {
      below--;
    }
    while (true) {
      if (editor.getLine(below) == "") {
        below--;
      } else {
        break;
      }
    }
    let text = "";
    Array.from(Array(below - above + 1).keys()).forEach((i) => {
      const line2 = editor.getLine(i + above);
      if (!line2.trim().startsWith("%%") || !line2.trim().endsWith("%%")) {
        let modifiedLine = editor.getLine(i + above);
        if (!/\d+\/\d+ *【.*】/.test(modifiedLine)) {
          modifiedLine = modifiedLine.replace(/🧵[ ]+(.*)/g, "\u3010$1\u3011").replace(/^\[([^\[\]\(\)]+)\]\([^\[\]\(\)]+\)/g, "$1").replace(/[^!]\[([^\[\]\(\)]+)\]\([^\[\]\(\)]+\)/g, "$1").replace(/!\[.*\]\(https[^\n]+\.jpeg\)/g, "").replace(/https[^\n]+\.jpeg/g, "").replace(/？([^】」\n])/g, "\uFF1F\n\n$1").replace(/。([^】」\n])/g, "\u3002\n\n$1").replace(/！([^】」\n])/g, "\uFF01\n\n$1").replace(/～([^】」\n])/g, "\uFF5E\n\n$1").replace(/^\s+$/, "");
        }
        text = text + modifiedLine + "\n";
      }
    });
    text = text.replace(/\n+$/, "");
    return text;
  }
  async add3DaysActionNoteContent(vault) {
    const scheduleNoteWithoutMd = "D/Query Schedule and Actions next 3 days";
    const scheduleNote = `${scheduleNoteWithoutMd}.md`;
    if (vault.getAbstractFileByPath(scheduleNote) == null) {
      await vault.create(scheduleNote, "");
    }
    let noteContent = "[[Query Schedule and Actions next 3 days]]\n";
    const excludeNotes = [scheduleNoteWithoutMd, "D/Scheduling"];
    Array.from(Array(3).keys()).forEach((i) => noteContent += this.getQueryDateAndActionString(i, excludeNotes));
    const otherDays = this.getQueryActionsThisWeek(3);
    noteContent = noteContent + `## nn / wn
\`\`\`query
tag:#nn OR tag:#wn${otherDays}
\`\`\`

## tt
\`\`\`query
tag:#tt
\`\`\`

`;
    noteContent = noteContent + this.getQueryFutureDaysThisWeek("Future Dates", 3, 6, excludeNotes);
    noteContent = noteContent + this.getQueryNext2MonthString(excludeNotes);
    noteContent = noteContent + this.getQueryFutureDaysThisWeek("Past Dates", -7, -1, excludeNotes);
    vault.modify(vault.getAbstractFileByPath(scheduleNote), noteContent);
  }
  async addActionNoteContent(vault, folderName, noteTitleWithoutMd, scheduleNoteTitleWithoutMd, nOrW) {
    const nowActionNoteWithoutMd = `${folderName}/${noteTitleWithoutMd}`;
    const nowActionNote = `${nowActionNoteWithoutMd}.md`;
    if (vault.getAbstractFileByPath(nowActionNote) == null) {
      await vault.create(nowActionNote, "");
    }
    let nowActionNoteContent = "";
    Array.from(Array(2).keys()).forEach((i) => nowActionNoteContent += this.getQueryActionString(i, nOrW));
    nowActionNoteContent += `\`\`\`query
tag:#${nOrW}t
\`\`\`
`;
    nowActionNoteContent += `\`\`\`query
`;
    Array.from(Array(5).keys()).forEach((i) => nowActionNoteContent += this.getQueryWeekDay(i + 2, nOrW));
    nowActionNoteContent += `tag:#${nOrW}n
\`\`\`
`;
    nowActionNoteContent += `Scheduling: [[${scheduleNoteTitleWithoutMd}]]
`;
    nowActionNoteContent += `[[${noteTitleWithoutMd}]]
`;
    vault.modify(vault.getAbstractFileByPath(nowActionNote), nowActionNoteContent);
  }
  getQueryDateAndActionString(addDay, excludeNotes) {
    const dateMoment = (0, import_moment.default)().add(addDay, "d");
    const dateYYYYMMDD = dateMoment.format("YYYYMMDD");
    const dateEachYYDD = "\\d\\d\\d\\d" + dateMoment.format("MMDD");
    const dateEachDD = "\\d\\d\\d\\d\\d\\d" + dateMoment.format("DD");
    const dayOfWeek = dateMoment.format("E");
    const dayOfWeekLong = dateMoment.format("ddd");
    const excludeNoteStr = excludeNotes.map((excludeNote) => `-path:"${excludeNote}" `).join("");
    return `## ${dateYYYYMMDD} ${dayOfWeekLong}
\`\`\`query
(" ${dateYYYYMMDD}" OR "${dateYYYYMMDD} " OR ${dateEachYYDD} OR ${dateEachDD} OR tag:#n${dayOfWeek} OR tag:#w${dayOfWeek}) ${excludeNoteStr}-block:(query)
\`\`\`

`;
  }
  getQueryActionsThisWeek(excludeNumDays) {
    let excludes = [];
    let includes = [1, 2, 3, 4, 5, 6, 7];
    Array.from(Array(excludeNumDays).keys()).forEach((i) => {
      const dateMoment = (0, import_moment.default)().add(i, "d");
      const dayOfWeek = parseInt(dateMoment.format("E"));
      excludes.push(dayOfWeek);
    });
    let aaa = includes.filter((i) => {
      for (const e of excludes) {
        if (e == i) {
          return false;
        }
      }
      return true;
    });
    let output = "";
    aaa.forEach((i) => output += ` OR tag:#n${i} OR tag:#w${i}`);
    return output;
  }
  getQueryFutureDaysThisWeek(header, from, to, excludeNotes) {
    let includes = [];
    for (let i = from; i <= to; i++) {
      let dateMoment = (0, import_moment.default)().add(i, "d");
      includes.push(dateMoment);
    }
    let output = `## ${header}
\`\`\`query
(`;
    includes.forEach((i) => {
      const dateYYYYMMDD = i.format("YYYYMMDD");
      const dateEachYYDD = "\\d\\d\\d\\d" + i.format("MMDD");
      const dateEachDD = "\\d\\d\\d\\d\\d\\d" + i.format("DD");
      output += `" ${dateYYYYMMDD}" OR "${dateYYYYMMDD} " OR ${dateEachYYDD} OR ${dateEachDD} OR `;
    });
    output = output.replace(/ OR $/, "");
    output += ")";
    const excludeNoteStr = excludeNotes.map((excludeNote) => `-path:"${excludeNote}" `).join("");
    output += ` ${excludeNoteStr}-block:(query)`;
    output += `
\`\`\`

`;
    return output;
  }
  getQueryNext2MonthString(excludeNotes) {
    const currentMonthYYYYMM = (0, import_moment.default)().format("YYYYMM");
    const dateMoment = (0, import_moment.default)().add(1, "M");
    const nextMonthYYYYMM = dateMoment.format("YYYYMM");
    const excludeNoteStr = excludeNotes.map((excludeNote) => `-path:"${excludeNote}" `).join("");
    return `## ${currentMonthYYYYMM} and ${nextMonthYYYYMM}
\`\`\`query
(${currentMonthYYYYMM}\\d\\d OR ${nextMonthYYYYMM}\\d\\d ${excludeNoteStr}-path:"D/Scheduling" -block:(query)
\`\`\`

`;
  }
  getQueryDateString(addDay, excludeNote) {
    const dateMoment = (0, import_moment.default)().add(addDay, "d");
    const dateYYYYMMDD = dateMoment.format("YYYYMMDD");
    const dateEachYYDD = "\\d\\d\\d\\d" + dateMoment.format("MMDD");
    const dateEachDD = "\\d\\d\\d\\d\\d\\d" + dateMoment.format("DD");
    return `${dateYYYYMMDD}
\`\`\`query
(${dateYYYYMMDD} OR ${dateEachYYDD} OR ${dateEachDD}) -path:"${excludeNote}" -block:(query)
\`\`\`
`;
  }
  getQueryActionString(addDay, actionType) {
    const dateMoment = (0, import_moment.default)().add(addDay, "d");
    const dayOfWeek = dateMoment.format("E");
    return `\`\`\`query
tag:#${actionType}${dayOfWeek}
\`\`\`
`;
  }
  getQueryWeekDay(addDay, actionType) {
    const dateMoment = (0, import_moment.default)().add(addDay, "d");
    const dayOfWeek = dateMoment.format("E");
    return `tag:#${actionType}${dayOfWeek} OR `;
  }
  addNewLaterActionIcon(t) {
    this.addObsidianIcon(`${t}l-icon-new`, `${t}l`);
  }
  addActionIcon(t) {
    this.addObsidianIcon(`${t}-icon`, `#${t}`);
  }
  addObsidianIcon(iconName, iconText) {
    const svg = `<text stroke='#000' transform='matrix(2.79167 0 0 2.12663 -34.0417 -25.2084)' xml:space='preserve' text-anchor='start' font-family='monospace' font-size='24' y='44' x='19' stroke-width='0' fill='currentColor'>${iconText}</text>`;
    (0, import_obsidian24.addIcon)(iconName, svg);
  }
  addNewLaterAction(t) {
    this.addCommand({
      id: `add-new-${t}-later-action`,
      name: `Add ${t}l task`,
      icon: `${t}l-icon-new`,
      editorCallback: (editor, view) => {
        const cursor = editor.getCursor();
        editor.replaceRange(`#${t}l `, cursor);
        cursor.ch = cursor.ch + 4;
        editor.setCursor(cursor);
      }
      /*,
      hotkeys: [
      	{
      		modifiers: [`Ctrl`, `Meta`, `Shift`],
      		key: t == 'n' ? '1' : '2'
      	},
      	{
      		modifiers: [`Ctrl`, `Alt`, `Shift`],
      		key: t == 'n' ? '1' : '2'
      	}
      ]*/
    });
  }
  addActionCommand(t) {
    this.addCommand({
      id: `to-w${t}-n${t}`,
      name: `To w${t} or n${t}`,
      icon: `${t}-icon`,
      editorCallback: (editor, view) => {
        console.log(editor.getSelection());
        const cursor = editor.getCursor();
        const lineNumber = editor.getCursor().line;
        const line = editor.getLine(lineNumber);
        const replacedLine = line.replace(/ a\/w\/./, ` a/w/${t}`).replace(/ a\/n\/./, ` a/n/${t}`).replace(/#w. /, `#w${t} `).replace(/#n. /, `#n${t} `).replace(/#w.$/, `#w${t}`).replace(/#n.$/, `#n${t}`);
        if (line.contains(`#n${t} `) || line.contains(`#w${t} `)) {
          const nt = `#n${t} `;
          const wt = `#w${t} `;
          const replaceLineToRemoveTag = line.replace(`#n${t} `, ``).replace(`#w${t} `, ``);
          editor.setLine(lineNumber, replaceLineToRemoveTag);
          const ntIndex = line.indexOf(nt);
          const wtIndex = line.indexOf(wt);
          const index = ntIndex == -1 ? wtIndex : ntIndex;
          const newCh = cursor.ch <= index ? cursor.ch : cursor.ch >= index + 4 ? cursor.ch - 4 : index;
          cursor.ch = newCh;
          editor.setCursor(cursor);
        } else if (line.contains(` #n${t}`) || line.contains(` #w${t}`)) {
          const nt = `#n${t} `;
          const wt = `#w${t} `;
          const replaceLineToRemoveTag = line.replace(` #n${t}`, ``).replace(` #w${t}`, ``);
          editor.setLine(lineNumber, replaceLineToRemoveTag);
          const ntIndex = line.indexOf(nt);
          const wtIndex = line.indexOf(wt);
          const index = ntIndex == -1 ? wtIndex : ntIndex;
          const newCh = cursor.ch <= index ? cursor.ch : cursor.ch >= index + 4 ? cursor.ch - 4 : index;
          cursor.ch = newCh;
          editor.setCursor(cursor);
        } else if (line.contains(` a/n/${t}`) || line.contains(` a/w/${t}`)) {
        } else if (replacedLine == line) {
          new AddTaskTagModal(this.app, editor, t).open();
        } else {
          editor.setLine(lineNumber, replacedLine);
          editor.setCursor(cursor);
        }
      },
      hotkeys: [
        {
          modifiers: this.is1To7(t) ? [`Ctrl`, `Meta`] : [`Ctrl`, `Meta`, `Shift`],
          key: `${t}`
        },
        {
          modifiers: this.is1To7(t) ? [`Ctrl`, `Alt`] : [`Ctrl`, `Alt`, `Shift`],
          key: `${t}`
        }
      ]
    });
  }
  addFollowUpCommand(t) {
    let name = "";
    if (t === "t") {
      name = "To Try";
    } else if (t === "e") {
      name = "To Explore";
    } else if (t === "m") {
      name = "To Move";
    }
    this.addCommand({
      id: `to-t${t}`,
      name: `To t${t} ${name}`,
      icon: `${t}-icon`,
      editorCallback: (editor, view) => {
        console.log(editor.getSelection());
        const cursor = editor.getCursor();
        const lineNumber = editor.getCursor().line;
        const line = editor.getLine(lineNumber);
        const replacedLine = line.replace(/#t. /, `#t${t} `).replace(/#t.$/, `#t${t}`);
        if (line.contains(`#t${t} `)) {
          const tt = `#t${t} `;
          const replaceLineToRemoveTag = line.replace(`#t${t} `, ``);
          editor.setLine(lineNumber, replaceLineToRemoveTag);
          const ttIndex = line.indexOf(tt);
          const index = ttIndex;
          const newCh = cursor.ch <= index ? cursor.ch : cursor.ch >= index + 4 ? cursor.ch - 4 : index;
          cursor.ch = newCh;
          editor.setCursor(cursor);
        } else if (line.contains(` #t${t}`)) {
          const tt = `#t${t} `;
          const replaceLineToRemoveTag = line.replace(` #t${t}`, ``);
          editor.setLine(lineNumber, replaceLineToRemoveTag);
          const ttIndex = line.indexOf(tt);
          const index = ttIndex;
          const newCh = cursor.ch <= index ? cursor.ch : cursor.ch >= index + 4 ? cursor.ch - 4 : index;
          cursor.ch = newCh;
          editor.setCursor(cursor);
        } else if (replacedLine == line) {
          const cursor2 = editor.getCursor();
          const line2 = editor.getLine(cursor2.line);
          editor.replaceRange(`${line2.charAt(cursor2.ch - 1) != " " ? " " : ""}#t${t} `, cursor2);
          cursor2.ch = cursor2.ch + 4 + (line2.charAt(cursor2.ch - 1) != " " ? 1 : 0);
          editor.setCursor(cursor2);
        } else {
          editor.setLine(lineNumber, replacedLine);
          editor.setCursor(cursor);
        }
      },
      hotkeys: [
        {
          modifiers: [`Ctrl`, `Meta`, `Shift`],
          key: `${t}`
        },
        {
          modifiers: [`Ctrl`, `Alt`, `Shift`],
          key: `${t}`
        }
      ]
    });
  }
  is1To7(t) {
    if (t == "1" || t == "2" || t == "3" || t == "4" || t == "5" || t == "6" || t == "7") {
      return true;
    } else {
      return false;
    }
  }
  addToClipboardHistory(content) {
    const index = clipboardHistory.indexOf(content, 0);
    if (index > -1) {
      clipboardHistory.splice(index, 1);
    }
    if (content.length > 0) {
      clipboardHistory.push(content);
    }
  }
  onunload() {
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
var SampleSettingTab = class extends import_obsidian23.PluginSettingTab {
  constructor(app2, plugin) {
    super(app2, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Settings for my awesome plugin." });
    new import_obsidian23.Setting(containerEl).setName("Setting #1").setDesc("It's a secret").addText((text) => text.setPlaceholder("Enter your secret").setValue(this.plugin.settings.mySetting).onChange(async (value) => {
      console.log("Secret: " + value);
      this.plugin.settings.mySetting = value;
      await this.plugin.saveSettings();
    }));
  }
};
/*! Bundled license information:

moment/moment.js:
  (*! moment.js *)
  (*! version : 2.29.1 *)
  (*! authors : Tim Wood, Iskren Chernev, Moment.js contributors *)
  (*! license : MIT *)
  (*! momentjs.com *)
*/
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsibm9kZV9tb2R1bGVzL21vbWVudC9tb21lbnQuanMiLCAibWFpbi50cyIsICJ1cGRhdGVOb3RlVHlwZU1vZGFsLnRzIiwgInRhZ3JlbmFtZXIvcmVuYW1pbmcudHMiLCAidGFncmVuYW1lci9UYWcudHMiLCAidGFncmVuYW1lci9GaWxlLnRzIiwgIm5vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9ub2Rlcy9Ob2RlLmpzIiwgIm5vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC92aXNpdC5qcyIsICJub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3QvZG9jL2RpcmVjdGl2ZXMuanMiLCAibm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L2RvYy9hbmNob3JzLmpzIiwgIm5vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9ub2Rlcy9BbGlhcy5qcyIsICJub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3Qvbm9kZXMvdG9KUy5qcyIsICJub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3Qvbm9kZXMvU2NhbGFyLmpzIiwgIm5vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9kb2MvY3JlYXRlTm9kZS5qcyIsICJub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3Qvbm9kZXMvQ29sbGVjdGlvbi5qcyIsICJub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3Qvc3RyaW5naWZ5L3N0cmluZ2lmeUNvbW1lbnQuanMiLCAibm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L3N0cmluZ2lmeS9mb2xkRmxvd0xpbmVzLmpzIiwgIm5vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9zdHJpbmdpZnkvc3RyaW5naWZ5U3RyaW5nLmpzIiwgIm5vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9zdHJpbmdpZnkvc3RyaW5naWZ5LmpzIiwgIm5vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9zdHJpbmdpZnkvc3RyaW5naWZ5UGFpci5qcyIsICJub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3QvbG9nLmpzIiwgIm5vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9ub2Rlcy9hZGRQYWlyVG9KU01hcC5qcyIsICJub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3Qvbm9kZXMvUGFpci5qcyIsICJub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3Qvb3B0aW9ucy5qcyIsICJub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3Qvc3RyaW5naWZ5L3N0cmluZ2lmeUNvbGxlY3Rpb24uanMiLCAibm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L25vZGVzL1lBTUxNYXAuanMiLCAibm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L3NjaGVtYS9jb21tb24vbWFwLmpzIiwgIm5vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9ub2Rlcy9ZQU1MU2VxLmpzIiwgIm5vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9zY2hlbWEvY29tbW9uL3NlcS5qcyIsICJub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3Qvc2NoZW1hL2NvbW1vbi9zdHJpbmcuanMiLCAibm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L3NjaGVtYS9jb21tb24vbnVsbC5qcyIsICJub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3Qvc2NoZW1hL2NvcmUvYm9vbC5qcyIsICJub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3Qvc3RyaW5naWZ5L3N0cmluZ2lmeU51bWJlci5qcyIsICJub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3Qvc2NoZW1hL2NvcmUvZmxvYXQuanMiLCAibm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L3NjaGVtYS9jb3JlL2ludC5qcyIsICJub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3Qvc2NoZW1hL2NvcmUvc2NoZW1hLmpzIiwgIm5vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9zY2hlbWEvanNvbi9zY2hlbWEuanMiLCAibm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L3NjaGVtYS95YW1sLTEuMS9iaW5hcnkuanMiLCAibm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L3NjaGVtYS95YW1sLTEuMS9wYWlycy5qcyIsICJub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3Qvc2NoZW1hL3lhbWwtMS4xL29tYXAuanMiLCAibm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L3NjaGVtYS95YW1sLTEuMS9ib29sLmpzIiwgIm5vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9zY2hlbWEveWFtbC0xLjEvZmxvYXQuanMiLCAibm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L3NjaGVtYS95YW1sLTEuMS9pbnQuanMiLCAibm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L3NjaGVtYS95YW1sLTEuMS9zZXQuanMiLCAibm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L3NjaGVtYS95YW1sLTEuMS90aW1lc3RhbXAuanMiLCAibm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L3NjaGVtYS95YW1sLTEuMS9zY2hlbWEuanMiLCAibm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L3NjaGVtYS90YWdzLmpzIiwgIm5vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9zY2hlbWEvU2NoZW1hLmpzIiwgIm5vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9zdHJpbmdpZnkvc3RyaW5naWZ5RG9jdW1lbnQuanMiLCAibm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L2RvYy9hcHBseVJldml2ZXIuanMiLCAibm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L2RvYy9Eb2N1bWVudC5qcyIsICJub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3QvZXJyb3JzLmpzIiwgIm5vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9jb21wb3NlL3Jlc29sdmUtcHJvcHMuanMiLCAibm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L2NvbXBvc2UvdXRpbC1jb250YWlucy1uZXdsaW5lLmpzIiwgIm5vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9jb21wb3NlL3V0aWwtZmxvdy1pbmRlbnQtY2hlY2suanMiLCAibm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L2NvbXBvc2UvdXRpbC1tYXAtaW5jbHVkZXMuanMiLCAibm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L2NvbXBvc2UvcmVzb2x2ZS1ibG9jay1tYXAuanMiLCAibm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L2NvbXBvc2UvcmVzb2x2ZS1ibG9jay1zZXEuanMiLCAibm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L2NvbXBvc2UvcmVzb2x2ZS1lbmQuanMiLCAibm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L2NvbXBvc2UvcmVzb2x2ZS1mbG93LWNvbGxlY3Rpb24uanMiLCAibm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L2NvbXBvc2UvY29tcG9zZS1jb2xsZWN0aW9uLmpzIiwgIm5vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9jb21wb3NlL3Jlc29sdmUtYmxvY2stc2NhbGFyLmpzIiwgIm5vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9jb21wb3NlL3Jlc29sdmUtZmxvdy1zY2FsYXIuanMiLCAibm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L2NvbXBvc2UvY29tcG9zZS1zY2FsYXIuanMiLCAibm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L2NvbXBvc2UvdXRpbC1lbXB0eS1zY2FsYXItcG9zaXRpb24uanMiLCAibm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L2NvbXBvc2UvY29tcG9zZS1ub2RlLmpzIiwgIm5vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9jb21wb3NlL2NvbXBvc2UtZG9jLmpzIiwgIm5vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9jb21wb3NlL2NvbXBvc2VyLmpzIiwgIm5vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9wYXJzZS9jc3QuanMiLCAibm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L3BhcnNlL2NzdC1zY2FsYXIuanMiLCAibm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L3BhcnNlL2NzdC1zdHJpbmdpZnkuanMiLCAibm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L3BhcnNlL2NzdC12aXNpdC5qcyIsICJub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3QvcGFyc2UvbGV4ZXIuanMiLCAibm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L3BhcnNlL2xpbmUtY291bnRlci5qcyIsICJub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3QvcGFyc2UvcGFyc2VyLmpzIiwgIm5vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9wdWJsaWMtYXBpLmpzIiwgImFkZENvbW1lbnRUYWdNb2RhbC50cyIsICJhZGRUYXNrVGFnTW9kYWwudHMiLCAiVGhyZWFkc1RvSW1hZ2VzTW9kYWwudHMiLCAiY29weU9yTW92ZVRvTmV3Tm90ZU1vZGFsLnRzIiwgImNsaXBib2FyZFBhc3RlTW9kYWwudHMiLCAib3BlblBsYXlncm91bmRNb2RhbC50cyIsICJ0aHJlYWRzVG9CbG9nTW9kYWwudHMiLCAiY2xpcGJvYXJkUmVtb3ZhbE1vZGFsLnRzIiwgInRhZ1NlYXJjaE1vZGFsLnRzIiwgInNlbGZ1dGlsL2dldEFsbE5vdGVUYWdzLnRzIiwgImFkZFRleHRUb05vdGVzRnJvbVNwZWNpZmljVGFnTW9kYWwudHMiLCAic2VsZnV0aWwvYWRkbGlua3Rvbm90ZXMudHMiLCAic2VsZnV0aWwvZmluZE5vdGVzRnJvbVRhZy50cyIsICJhZGRUZXh0VG9Ob3Rlc01vZGFsLnRzIiwgInNlbGZ1dGlsL2dldFJlY2VudE5vdGVzLnRzIiwgIm5hdmlnYXRlVG9Ob3RlRnJvbVNwZWNpZmljVGFnTW9kYWwudHMiLCAibmF2aWdhdGVUb05vdGVGcm9tVGFnTW9kYWwudHMiLCAic2VsZnV0aWwvZXh0cmFjdFNlbGVjdGlvbi50cyIsICJ0d21pZ3JhdGlvbi90d01pZ3JhdGVUb29scy50cyIsICJzZWxmdXRpbC9yZW1vdmVDb250ZW50RnJvbUN1cnNvci50cyIsICJyZW1vdmVDb250ZW50RnJvbUN1cnNvck1vZGFsLnRzIiwgImZpbmRSZXBsYWNlTW9kYWwudHMiLCAicXVlcnlPcnBoYW5Ob3Rlc0J5VGFnTW9kYWwudHMiXSwKICAic291cmNlc0NvbnRlbnQiOiBbIi8vISBtb21lbnQuanNcbi8vISB2ZXJzaW9uIDogMi4yOS4xXG4vLyEgYXV0aG9ycyA6IFRpbSBXb29kLCBJc2tyZW4gQ2hlcm5ldiwgTW9tZW50LmpzIGNvbnRyaWJ1dG9yc1xuLy8hIGxpY2Vuc2UgOiBNSVRcbi8vISBtb21lbnRqcy5jb21cblxuOyhmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCkgOlxuICAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShmYWN0b3J5KSA6XG4gICAgZ2xvYmFsLm1vbWVudCA9IGZhY3RvcnkoKVxufSh0aGlzLCAoZnVuY3Rpb24gKCkgeyAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgaG9va0NhbGxiYWNrO1xuXG4gICAgZnVuY3Rpb24gaG9va3MoKSB7XG4gICAgICAgIHJldHVybiBob29rQ2FsbGJhY2suYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICAvLyBUaGlzIGlzIGRvbmUgdG8gcmVnaXN0ZXIgdGhlIG1ldGhvZCBjYWxsZWQgd2l0aCBtb21lbnQoKVxuICAgIC8vIHdpdGhvdXQgY3JlYXRpbmcgY2lyY3VsYXIgZGVwZW5kZW5jaWVzLlxuICAgIGZ1bmN0aW9uIHNldEhvb2tDYWxsYmFjayhjYWxsYmFjaykge1xuICAgICAgICBob29rQ2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0FycmF5KGlucHV0KSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBpbnB1dCBpbnN0YW5jZW9mIEFycmF5IHx8XG4gICAgICAgICAgICBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaW5wdXQpID09PSAnW29iamVjdCBBcnJheV0nXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNPYmplY3QoaW5wdXQpIHtcbiAgICAgICAgLy8gSUU4IHdpbGwgdHJlYXQgdW5kZWZpbmVkIGFuZCBudWxsIGFzIG9iamVjdCBpZiBpdCB3YXNuJ3QgZm9yXG4gICAgICAgIC8vIGlucHV0ICE9IG51bGxcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIGlucHV0ICE9IG51bGwgJiZcbiAgICAgICAgICAgIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpbnB1dCkgPT09ICdbb2JqZWN0IE9iamVjdF0nXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFzT3duUHJvcChhLCBiKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYSwgYik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNPYmplY3RFbXB0eShvYmopIHtcbiAgICAgICAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKSB7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMob2JqKS5sZW5ndGggPT09IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgaztcbiAgICAgICAgICAgIGZvciAoayBpbiBvYmopIHtcbiAgICAgICAgICAgICAgICBpZiAoaGFzT3duUHJvcChvYmosIGspKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzVW5kZWZpbmVkKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBpbnB1dCA9PT0gdm9pZCAwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzTnVtYmVyKGlucHV0KSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICB0eXBlb2YgaW5wdXQgPT09ICdudW1iZXInIHx8XG4gICAgICAgICAgICBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaW5wdXQpID09PSAnW29iamVjdCBOdW1iZXJdJ1xuICAgICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzRGF0ZShpbnB1dCkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgaW5wdXQgaW5zdGFuY2VvZiBEYXRlIHx8XG4gICAgICAgICAgICBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaW5wdXQpID09PSAnW29iamVjdCBEYXRlXSdcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYXAoYXJyLCBmbikge1xuICAgICAgICB2YXIgcmVzID0gW10sXG4gICAgICAgICAgICBpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICByZXMucHVzaChmbihhcnJbaV0sIGkpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGV4dGVuZChhLCBiKSB7XG4gICAgICAgIGZvciAodmFyIGkgaW4gYikge1xuICAgICAgICAgICAgaWYgKGhhc093blByb3AoYiwgaSkpIHtcbiAgICAgICAgICAgICAgICBhW2ldID0gYltpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoYXNPd25Qcm9wKGIsICd0b1N0cmluZycpKSB7XG4gICAgICAgICAgICBhLnRvU3RyaW5nID0gYi50b1N0cmluZztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoYXNPd25Qcm9wKGIsICd2YWx1ZU9mJykpIHtcbiAgICAgICAgICAgIGEudmFsdWVPZiA9IGIudmFsdWVPZjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZVVUQyhpbnB1dCwgZm9ybWF0LCBsb2NhbGUsIHN0cmljdCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlTG9jYWxPclVUQyhpbnB1dCwgZm9ybWF0LCBsb2NhbGUsIHN0cmljdCwgdHJ1ZSkudXRjKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGVmYXVsdFBhcnNpbmdGbGFncygpIHtcbiAgICAgICAgLy8gV2UgbmVlZCB0byBkZWVwIGNsb25lIHRoaXMgb2JqZWN0LlxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZW1wdHk6IGZhbHNlLFxuICAgICAgICAgICAgdW51c2VkVG9rZW5zOiBbXSxcbiAgICAgICAgICAgIHVudXNlZElucHV0OiBbXSxcbiAgICAgICAgICAgIG92ZXJmbG93OiAtMixcbiAgICAgICAgICAgIGNoYXJzTGVmdE92ZXI6IDAsXG4gICAgICAgICAgICBudWxsSW5wdXQ6IGZhbHNlLFxuICAgICAgICAgICAgaW52YWxpZEVyYTogbnVsbCxcbiAgICAgICAgICAgIGludmFsaWRNb250aDogbnVsbCxcbiAgICAgICAgICAgIGludmFsaWRGb3JtYXQ6IGZhbHNlLFxuICAgICAgICAgICAgdXNlckludmFsaWRhdGVkOiBmYWxzZSxcbiAgICAgICAgICAgIGlzbzogZmFsc2UsXG4gICAgICAgICAgICBwYXJzZWREYXRlUGFydHM6IFtdLFxuICAgICAgICAgICAgZXJhOiBudWxsLFxuICAgICAgICAgICAgbWVyaWRpZW06IG51bGwsXG4gICAgICAgICAgICByZmMyODIyOiBmYWxzZSxcbiAgICAgICAgICAgIHdlZWtkYXlNaXNtYXRjaDogZmFsc2UsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0UGFyc2luZ0ZsYWdzKG0pIHtcbiAgICAgICAgaWYgKG0uX3BmID09IG51bGwpIHtcbiAgICAgICAgICAgIG0uX3BmID0gZGVmYXVsdFBhcnNpbmdGbGFncygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtLl9wZjtcbiAgICB9XG5cbiAgICB2YXIgc29tZTtcbiAgICBpZiAoQXJyYXkucHJvdG90eXBlLnNvbWUpIHtcbiAgICAgICAgc29tZSA9IEFycmF5LnByb3RvdHlwZS5zb21lO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHNvbWUgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgICAgICAgICB2YXIgdCA9IE9iamVjdCh0aGlzKSxcbiAgICAgICAgICAgICAgICBsZW4gPSB0Lmxlbmd0aCA+Pj4gMCxcbiAgICAgICAgICAgICAgICBpO1xuXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoaSBpbiB0ICYmIGZ1bi5jYWxsKHRoaXMsIHRbaV0sIGksIHQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzVmFsaWQobSkge1xuICAgICAgICBpZiAobS5faXNWYWxpZCA9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgZmxhZ3MgPSBnZXRQYXJzaW5nRmxhZ3MobSksXG4gICAgICAgICAgICAgICAgcGFyc2VkUGFydHMgPSBzb21lLmNhbGwoZmxhZ3MucGFyc2VkRGF0ZVBhcnRzLCBmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaSAhPSBudWxsO1xuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIGlzTm93VmFsaWQgPVxuICAgICAgICAgICAgICAgICAgICAhaXNOYU4obS5fZC5nZXRUaW1lKCkpICYmXG4gICAgICAgICAgICAgICAgICAgIGZsYWdzLm92ZXJmbG93IDwgMCAmJlxuICAgICAgICAgICAgICAgICAgICAhZmxhZ3MuZW1wdHkgJiZcbiAgICAgICAgICAgICAgICAgICAgIWZsYWdzLmludmFsaWRFcmEgJiZcbiAgICAgICAgICAgICAgICAgICAgIWZsYWdzLmludmFsaWRNb250aCAmJlxuICAgICAgICAgICAgICAgICAgICAhZmxhZ3MuaW52YWxpZFdlZWtkYXkgJiZcbiAgICAgICAgICAgICAgICAgICAgIWZsYWdzLndlZWtkYXlNaXNtYXRjaCAmJlxuICAgICAgICAgICAgICAgICAgICAhZmxhZ3MubnVsbElucHV0ICYmXG4gICAgICAgICAgICAgICAgICAgICFmbGFncy5pbnZhbGlkRm9ybWF0ICYmXG4gICAgICAgICAgICAgICAgICAgICFmbGFncy51c2VySW52YWxpZGF0ZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgKCFmbGFncy5tZXJpZGllbSB8fCAoZmxhZ3MubWVyaWRpZW0gJiYgcGFyc2VkUGFydHMpKTtcblxuICAgICAgICAgICAgaWYgKG0uX3N0cmljdCkge1xuICAgICAgICAgICAgICAgIGlzTm93VmFsaWQgPVxuICAgICAgICAgICAgICAgICAgICBpc05vd1ZhbGlkICYmXG4gICAgICAgICAgICAgICAgICAgIGZsYWdzLmNoYXJzTGVmdE92ZXIgPT09IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgZmxhZ3MudW51c2VkVG9rZW5zLmxlbmd0aCA9PT0gMCAmJlxuICAgICAgICAgICAgICAgICAgICBmbGFncy5iaWdIb3VyID09PSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChPYmplY3QuaXNGcm96ZW4gPT0gbnVsbCB8fCAhT2JqZWN0LmlzRnJvemVuKG0pKSB7XG4gICAgICAgICAgICAgICAgbS5faXNWYWxpZCA9IGlzTm93VmFsaWQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBpc05vd1ZhbGlkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtLl9pc1ZhbGlkO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUludmFsaWQoZmxhZ3MpIHtcbiAgICAgICAgdmFyIG0gPSBjcmVhdGVVVEMoTmFOKTtcbiAgICAgICAgaWYgKGZsYWdzICE9IG51bGwpIHtcbiAgICAgICAgICAgIGV4dGVuZChnZXRQYXJzaW5nRmxhZ3MobSksIGZsYWdzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhtKS51c2VySW52YWxpZGF0ZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG07XG4gICAgfVxuXG4gICAgLy8gUGx1Z2lucyB0aGF0IGFkZCBwcm9wZXJ0aWVzIHNob3VsZCBhbHNvIGFkZCB0aGUga2V5IGhlcmUgKG51bGwgdmFsdWUpLFxuICAgIC8vIHNvIHdlIGNhbiBwcm9wZXJseSBjbG9uZSBvdXJzZWx2ZXMuXG4gICAgdmFyIG1vbWVudFByb3BlcnRpZXMgPSAoaG9va3MubW9tZW50UHJvcGVydGllcyA9IFtdKSxcbiAgICAgICAgdXBkYXRlSW5Qcm9ncmVzcyA9IGZhbHNlO1xuXG4gICAgZnVuY3Rpb24gY29weUNvbmZpZyh0bywgZnJvbSkge1xuICAgICAgICB2YXIgaSwgcHJvcCwgdmFsO1xuXG4gICAgICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5faXNBTW9tZW50T2JqZWN0KSkge1xuICAgICAgICAgICAgdG8uX2lzQU1vbWVudE9iamVjdCA9IGZyb20uX2lzQU1vbWVudE9iamVjdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX2kpKSB7XG4gICAgICAgICAgICB0by5faSA9IGZyb20uX2k7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9mKSkge1xuICAgICAgICAgICAgdG8uX2YgPSBmcm9tLl9mO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5fbCkpIHtcbiAgICAgICAgICAgIHRvLl9sID0gZnJvbS5fbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX3N0cmljdCkpIHtcbiAgICAgICAgICAgIHRvLl9zdHJpY3QgPSBmcm9tLl9zdHJpY3Q7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl90em0pKSB7XG4gICAgICAgICAgICB0by5fdHptID0gZnJvbS5fdHptO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5faXNVVEMpKSB7XG4gICAgICAgICAgICB0by5faXNVVEMgPSBmcm9tLl9pc1VUQztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX29mZnNldCkpIHtcbiAgICAgICAgICAgIHRvLl9vZmZzZXQgPSBmcm9tLl9vZmZzZXQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9wZikpIHtcbiAgICAgICAgICAgIHRvLl9wZiA9IGdldFBhcnNpbmdGbGFncyhmcm9tKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX2xvY2FsZSkpIHtcbiAgICAgICAgICAgIHRvLl9sb2NhbGUgPSBmcm9tLl9sb2NhbGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobW9tZW50UHJvcGVydGllcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbW9tZW50UHJvcGVydGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHByb3AgPSBtb21lbnRQcm9wZXJ0aWVzW2ldO1xuICAgICAgICAgICAgICAgIHZhbCA9IGZyb21bcHJvcF07XG4gICAgICAgICAgICAgICAgaWYgKCFpc1VuZGVmaW5lZCh2YWwpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvW3Byb3BdID0gdmFsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0bztcbiAgICB9XG5cbiAgICAvLyBNb21lbnQgcHJvdG90eXBlIG9iamVjdFxuICAgIGZ1bmN0aW9uIE1vbWVudChjb25maWcpIHtcbiAgICAgICAgY29weUNvbmZpZyh0aGlzLCBjb25maWcpO1xuICAgICAgICB0aGlzLl9kID0gbmV3IERhdGUoY29uZmlnLl9kICE9IG51bGwgPyBjb25maWcuX2QuZ2V0VGltZSgpIDogTmFOKTtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgdGhpcy5fZCA9IG5ldyBEYXRlKE5hTik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUHJldmVudCBpbmZpbml0ZSBsb29wIGluIGNhc2UgdXBkYXRlT2Zmc2V0IGNyZWF0ZXMgbmV3IG1vbWVudFxuICAgICAgICAvLyBvYmplY3RzLlxuICAgICAgICBpZiAodXBkYXRlSW5Qcm9ncmVzcyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHVwZGF0ZUluUHJvZ3Jlc3MgPSB0cnVlO1xuICAgICAgICAgICAgaG9va3MudXBkYXRlT2Zmc2V0KHRoaXMpO1xuICAgICAgICAgICAgdXBkYXRlSW5Qcm9ncmVzcyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNNb21lbnQob2JqKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBvYmogaW5zdGFuY2VvZiBNb21lbnQgfHwgKG9iaiAhPSBudWxsICYmIG9iai5faXNBTW9tZW50T2JqZWN0ICE9IG51bGwpXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gd2Fybihtc2cpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgaG9va3Muc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmdzID09PSBmYWxzZSAmJlxuICAgICAgICAgICAgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICBjb25zb2xlLndhcm5cbiAgICAgICAgKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ0RlcHJlY2F0aW9uIHdhcm5pbmc6ICcgKyBtc2cpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGVwcmVjYXRlKG1zZywgZm4pIHtcbiAgICAgICAgdmFyIGZpcnN0VGltZSA9IHRydWU7XG5cbiAgICAgICAgcmV0dXJuIGV4dGVuZChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoaG9va3MuZGVwcmVjYXRpb25IYW5kbGVyICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBob29rcy5kZXByZWNhdGlvbkhhbmRsZXIobnVsbCwgbXNnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmaXJzdFRpbWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXJncyA9IFtdLFxuICAgICAgICAgICAgICAgICAgICBhcmcsXG4gICAgICAgICAgICAgICAgICAgIGksXG4gICAgICAgICAgICAgICAgICAgIGtleTtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGFyZyA9ICcnO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGFyZ3VtZW50c1tpXSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZyArPSAnXFxuWycgKyBpICsgJ10gJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoa2V5IGluIGFyZ3VtZW50c1swXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wKGFyZ3VtZW50c1swXSwga2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmcgKz0ga2V5ICsgJzogJyArIGFyZ3VtZW50c1swXVtrZXldICsgJywgJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmcgPSBhcmcuc2xpY2UoMCwgLTIpOyAvLyBSZW1vdmUgdHJhaWxpbmcgY29tbWEgYW5kIHNwYWNlXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmcgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYXJncy5wdXNoKGFyZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAgICAgICAgIG1zZyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnXFxuQXJndW1lbnRzOiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3MpLmpvaW4oJycpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdcXG4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBFcnJvcigpLnN0YWNrXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBmaXJzdFRpbWUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9LCBmbik7XG4gICAgfVxuXG4gICAgdmFyIGRlcHJlY2F0aW9ucyA9IHt9O1xuXG4gICAgZnVuY3Rpb24gZGVwcmVjYXRlU2ltcGxlKG5hbWUsIG1zZykge1xuICAgICAgICBpZiAoaG9va3MuZGVwcmVjYXRpb25IYW5kbGVyICE9IG51bGwpIHtcbiAgICAgICAgICAgIGhvb2tzLmRlcHJlY2F0aW9uSGFuZGxlcihuYW1lLCBtc2cpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZGVwcmVjYXRpb25zW25hbWVdKSB7XG4gICAgICAgICAgICB3YXJuKG1zZyk7XG4gICAgICAgICAgICBkZXByZWNhdGlvbnNbbmFtZV0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaG9va3Muc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmdzID0gZmFsc2U7XG4gICAgaG9va3MuZGVwcmVjYXRpb25IYW5kbGVyID0gbnVsbDtcblxuICAgIGZ1bmN0aW9uIGlzRnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICh0eXBlb2YgRnVuY3Rpb24gIT09ICd1bmRlZmluZWQnICYmIGlucHV0IGluc3RhbmNlb2YgRnVuY3Rpb24pIHx8XG4gICAgICAgICAgICBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaW5wdXQpID09PSAnW29iamVjdCBGdW5jdGlvbl0nXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0KGNvbmZpZykge1xuICAgICAgICB2YXIgcHJvcCwgaTtcbiAgICAgICAgZm9yIChpIGluIGNvbmZpZykge1xuICAgICAgICAgICAgaWYgKGhhc093blByb3AoY29uZmlnLCBpKSkge1xuICAgICAgICAgICAgICAgIHByb3AgPSBjb25maWdbaV07XG4gICAgICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24ocHJvcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpc1tpXSA9IHByb3A7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpc1snXycgKyBpXSA9IHByb3A7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NvbmZpZyA9IGNvbmZpZztcbiAgICAgICAgLy8gTGVuaWVudCBvcmRpbmFsIHBhcnNpbmcgYWNjZXB0cyBqdXN0IGEgbnVtYmVyIGluIGFkZGl0aW9uIHRvXG4gICAgICAgIC8vIG51bWJlciArIChwb3NzaWJseSkgc3R1ZmYgY29taW5nIGZyb20gX2RheU9mTW9udGhPcmRpbmFsUGFyc2UuXG4gICAgICAgIC8vIFRPRE86IFJlbW92ZSBcIm9yZGluYWxQYXJzZVwiIGZhbGxiYWNrIGluIG5leHQgbWFqb3IgcmVsZWFzZS5cbiAgICAgICAgdGhpcy5fZGF5T2ZNb250aE9yZGluYWxQYXJzZUxlbmllbnQgPSBuZXcgUmVnRXhwKFxuICAgICAgICAgICAgKHRoaXMuX2RheU9mTW9udGhPcmRpbmFsUGFyc2Uuc291cmNlIHx8IHRoaXMuX29yZGluYWxQYXJzZS5zb3VyY2UpICtcbiAgICAgICAgICAgICAgICAnfCcgK1xuICAgICAgICAgICAgICAgIC9cXGR7MSwyfS8uc291cmNlXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWVyZ2VDb25maWdzKHBhcmVudENvbmZpZywgY2hpbGRDb25maWcpIHtcbiAgICAgICAgdmFyIHJlcyA9IGV4dGVuZCh7fSwgcGFyZW50Q29uZmlnKSxcbiAgICAgICAgICAgIHByb3A7XG4gICAgICAgIGZvciAocHJvcCBpbiBjaGlsZENvbmZpZykge1xuICAgICAgICAgICAgaWYgKGhhc093blByb3AoY2hpbGRDb25maWcsIHByb3ApKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzT2JqZWN0KHBhcmVudENvbmZpZ1twcm9wXSkgJiYgaXNPYmplY3QoY2hpbGRDb25maWdbcHJvcF0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc1twcm9wXSA9IHt9O1xuICAgICAgICAgICAgICAgICAgICBleHRlbmQocmVzW3Byb3BdLCBwYXJlbnRDb25maWdbcHJvcF0pO1xuICAgICAgICAgICAgICAgICAgICBleHRlbmQocmVzW3Byb3BdLCBjaGlsZENvbmZpZ1twcm9wXSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjaGlsZENvbmZpZ1twcm9wXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc1twcm9wXSA9IGNoaWxkQ29uZmlnW3Byb3BdO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSByZXNbcHJvcF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAocHJvcCBpbiBwYXJlbnRDb25maWcpIHtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBoYXNPd25Qcm9wKHBhcmVudENvbmZpZywgcHJvcCkgJiZcbiAgICAgICAgICAgICAgICAhaGFzT3duUHJvcChjaGlsZENvbmZpZywgcHJvcCkgJiZcbiAgICAgICAgICAgICAgICBpc09iamVjdChwYXJlbnRDb25maWdbcHJvcF0pXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAvLyBtYWtlIHN1cmUgY2hhbmdlcyB0byBwcm9wZXJ0aWVzIGRvbid0IG1vZGlmeSBwYXJlbnQgY29uZmlnXG4gICAgICAgICAgICAgICAgcmVzW3Byb3BdID0gZXh0ZW5kKHt9LCByZXNbcHJvcF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gTG9jYWxlKGNvbmZpZykge1xuICAgICAgICBpZiAoY29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0KGNvbmZpZyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIga2V5cztcblxuICAgIGlmIChPYmplY3Qua2V5cykge1xuICAgICAgICBrZXlzID0gT2JqZWN0LmtleXM7XG4gICAgfSBlbHNlIHtcbiAgICAgICAga2V5cyA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgIHZhciBpLFxuICAgICAgICAgICAgICAgIHJlcyA9IFtdO1xuICAgICAgICAgICAgZm9yIChpIGluIG9iaikge1xuICAgICAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wKG9iaiwgaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzLnB1c2goaSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdENhbGVuZGFyID0ge1xuICAgICAgICBzYW1lRGF5OiAnW1RvZGF5IGF0XSBMVCcsXG4gICAgICAgIG5leHREYXk6ICdbVG9tb3Jyb3cgYXRdIExUJyxcbiAgICAgICAgbmV4dFdlZWs6ICdkZGRkIFthdF0gTFQnLFxuICAgICAgICBsYXN0RGF5OiAnW1llc3RlcmRheSBhdF0gTFQnLFxuICAgICAgICBsYXN0V2VlazogJ1tMYXN0XSBkZGRkIFthdF0gTFQnLFxuICAgICAgICBzYW1lRWxzZTogJ0wnLFxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBjYWxlbmRhcihrZXksIG1vbSwgbm93KSB7XG4gICAgICAgIHZhciBvdXRwdXQgPSB0aGlzLl9jYWxlbmRhcltrZXldIHx8IHRoaXMuX2NhbGVuZGFyWydzYW1lRWxzZSddO1xuICAgICAgICByZXR1cm4gaXNGdW5jdGlvbihvdXRwdXQpID8gb3V0cHV0LmNhbGwobW9tLCBub3cpIDogb3V0cHV0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHplcm9GaWxsKG51bWJlciwgdGFyZ2V0TGVuZ3RoLCBmb3JjZVNpZ24pIHtcbiAgICAgICAgdmFyIGFic051bWJlciA9ICcnICsgTWF0aC5hYnMobnVtYmVyKSxcbiAgICAgICAgICAgIHplcm9zVG9GaWxsID0gdGFyZ2V0TGVuZ3RoIC0gYWJzTnVtYmVyLmxlbmd0aCxcbiAgICAgICAgICAgIHNpZ24gPSBudW1iZXIgPj0gMDtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIChzaWduID8gKGZvcmNlU2lnbiA/ICcrJyA6ICcnKSA6ICctJykgK1xuICAgICAgICAgICAgTWF0aC5wb3coMTAsIE1hdGgubWF4KDAsIHplcm9zVG9GaWxsKSkudG9TdHJpbmcoKS5zdWJzdHIoMSkgK1xuICAgICAgICAgICAgYWJzTnVtYmVyXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgdmFyIGZvcm1hdHRpbmdUb2tlbnMgPSAvKFxcW1teXFxbXSpcXF0pfChcXFxcKT8oW0hoXW1tKHNzKT98TW98TU0/TT9NP3xEb3xERERvfEREP0Q/RD98ZGRkP2Q/fGRvP3x3W298d10/fFdbb3xXXT98UW8/fE57MSw1fXxZWVlZWVl8WVlZWVl8WVlZWXxZWXx5ezIsNH18eW8/fGdnKGdnZz8pP3xHRyhHR0c/KT98ZXxFfGF8QXxoaD98SEg/fGtrP3xtbT98c3M/fFN7MSw5fXx4fFh8eno/fFpaP3wuKS9nLFxuICAgICAgICBsb2NhbEZvcm1hdHRpbmdUb2tlbnMgPSAvKFxcW1teXFxbXSpcXF0pfChcXFxcKT8oTFRTfExUfExMP0w/TD98bHsxLDR9KS9nLFxuICAgICAgICBmb3JtYXRGdW5jdGlvbnMgPSB7fSxcbiAgICAgICAgZm9ybWF0VG9rZW5GdW5jdGlvbnMgPSB7fTtcblxuICAgIC8vIHRva2VuOiAgICAnTSdcbiAgICAvLyBwYWRkZWQ6ICAgWydNTScsIDJdXG4gICAgLy8gb3JkaW5hbDogICdNbydcbiAgICAvLyBjYWxsYmFjazogZnVuY3Rpb24gKCkgeyB0aGlzLm1vbnRoKCkgKyAxIH1cbiAgICBmdW5jdGlvbiBhZGRGb3JtYXRUb2tlbih0b2tlbiwgcGFkZGVkLCBvcmRpbmFsLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgZnVuYyA9IGNhbGxiYWNrO1xuICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgZnVuYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1tjYWxsYmFja10oKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRva2VuKSB7XG4gICAgICAgICAgICBmb3JtYXRUb2tlbkZ1bmN0aW9uc1t0b2tlbl0gPSBmdW5jO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYWRkZWQpIHtcbiAgICAgICAgICAgIGZvcm1hdFRva2VuRnVuY3Rpb25zW3BhZGRlZFswXV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHplcm9GaWxsKGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKSwgcGFkZGVkWzFdLCBwYWRkZWRbMl0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3JkaW5hbCkge1xuICAgICAgICAgICAgZm9ybWF0VG9rZW5GdW5jdGlvbnNbb3JkaW5hbF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLm9yZGluYWwoXG4gICAgICAgICAgICAgICAgICAgIGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKSxcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlbW92ZUZvcm1hdHRpbmdUb2tlbnMoaW5wdXQpIHtcbiAgICAgICAgaWYgKGlucHV0Lm1hdGNoKC9cXFtbXFxzXFxTXS8pKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQucmVwbGFjZSgvXlxcW3xcXF0kL2csICcnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5wdXQucmVwbGFjZSgvXFxcXC9nLCAnJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFrZUZvcm1hdEZ1bmN0aW9uKGZvcm1hdCkge1xuICAgICAgICB2YXIgYXJyYXkgPSBmb3JtYXQubWF0Y2goZm9ybWF0dGluZ1Rva2VucyksXG4gICAgICAgICAgICBpLFxuICAgICAgICAgICAgbGVuZ3RoO1xuXG4gICAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoZm9ybWF0VG9rZW5GdW5jdGlvbnNbYXJyYXlbaV1dKSB7XG4gICAgICAgICAgICAgICAgYXJyYXlbaV0gPSBmb3JtYXRUb2tlbkZ1bmN0aW9uc1thcnJheVtpXV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFycmF5W2ldID0gcmVtb3ZlRm9ybWF0dGluZ1Rva2VucyhhcnJheVtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG1vbSkge1xuICAgICAgICAgICAgdmFyIG91dHB1dCA9ICcnLFxuICAgICAgICAgICAgICAgIGk7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQgKz0gaXNGdW5jdGlvbihhcnJheVtpXSlcbiAgICAgICAgICAgICAgICAgICAgPyBhcnJheVtpXS5jYWxsKG1vbSwgZm9ybWF0KVxuICAgICAgICAgICAgICAgICAgICA6IGFycmF5W2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBmb3JtYXQgZGF0ZSB1c2luZyBuYXRpdmUgZGF0ZSBvYmplY3RcbiAgICBmdW5jdGlvbiBmb3JtYXRNb21lbnQobSwgZm9ybWF0KSB7XG4gICAgICAgIGlmICghbS5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBtLmxvY2FsZURhdGEoKS5pbnZhbGlkRGF0ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9ybWF0ID0gZXhwYW5kRm9ybWF0KGZvcm1hdCwgbS5sb2NhbGVEYXRhKCkpO1xuICAgICAgICBmb3JtYXRGdW5jdGlvbnNbZm9ybWF0XSA9XG4gICAgICAgICAgICBmb3JtYXRGdW5jdGlvbnNbZm9ybWF0XSB8fCBtYWtlRm9ybWF0RnVuY3Rpb24oZm9ybWF0KTtcblxuICAgICAgICByZXR1cm4gZm9ybWF0RnVuY3Rpb25zW2Zvcm1hdF0obSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXhwYW5kRm9ybWF0KGZvcm1hdCwgbG9jYWxlKSB7XG4gICAgICAgIHZhciBpID0gNTtcblxuICAgICAgICBmdW5jdGlvbiByZXBsYWNlTG9uZ0RhdGVGb3JtYXRUb2tlbnMoaW5wdXQpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbGUubG9uZ0RhdGVGb3JtYXQoaW5wdXQpIHx8IGlucHV0O1xuICAgICAgICB9XG5cbiAgICAgICAgbG9jYWxGb3JtYXR0aW5nVG9rZW5zLmxhc3RJbmRleCA9IDA7XG4gICAgICAgIHdoaWxlIChpID49IDAgJiYgbG9jYWxGb3JtYXR0aW5nVG9rZW5zLnRlc3QoZm9ybWF0KSkge1xuICAgICAgICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UoXG4gICAgICAgICAgICAgICAgbG9jYWxGb3JtYXR0aW5nVG9rZW5zLFxuICAgICAgICAgICAgICAgIHJlcGxhY2VMb25nRGF0ZUZvcm1hdFRva2Vuc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGxvY2FsRm9ybWF0dGluZ1Rva2Vucy5sYXN0SW5kZXggPSAwO1xuICAgICAgICAgICAgaSAtPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZvcm1hdDtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdExvbmdEYXRlRm9ybWF0ID0ge1xuICAgICAgICBMVFM6ICdoOm1tOnNzIEEnLFxuICAgICAgICBMVDogJ2g6bW0gQScsXG4gICAgICAgIEw6ICdNTS9ERC9ZWVlZJyxcbiAgICAgICAgTEw6ICdNTU1NIEQsIFlZWVknLFxuICAgICAgICBMTEw6ICdNTU1NIEQsIFlZWVkgaDptbSBBJyxcbiAgICAgICAgTExMTDogJ2RkZGQsIE1NTU0gRCwgWVlZWSBoOm1tIEEnLFxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBsb25nRGF0ZUZvcm1hdChrZXkpIHtcbiAgICAgICAgdmFyIGZvcm1hdCA9IHRoaXMuX2xvbmdEYXRlRm9ybWF0W2tleV0sXG4gICAgICAgICAgICBmb3JtYXRVcHBlciA9IHRoaXMuX2xvbmdEYXRlRm9ybWF0W2tleS50b1VwcGVyQ2FzZSgpXTtcblxuICAgICAgICBpZiAoZm9ybWF0IHx8ICFmb3JtYXRVcHBlcikge1xuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2xvbmdEYXRlRm9ybWF0W2tleV0gPSBmb3JtYXRVcHBlclxuICAgICAgICAgICAgLm1hdGNoKGZvcm1hdHRpbmdUb2tlbnMpXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uICh0b2spIHtcbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgIHRvayA9PT0gJ01NTU0nIHx8XG4gICAgICAgICAgICAgICAgICAgIHRvayA9PT0gJ01NJyB8fFxuICAgICAgICAgICAgICAgICAgICB0b2sgPT09ICdERCcgfHxcbiAgICAgICAgICAgICAgICAgICAgdG9rID09PSAnZGRkZCdcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRvay5zbGljZSgxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRvaztcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuam9pbignJyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvbmdEYXRlRm9ybWF0W2tleV07XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRJbnZhbGlkRGF0ZSA9ICdJbnZhbGlkIGRhdGUnO1xuXG4gICAgZnVuY3Rpb24gaW52YWxpZERhdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnZhbGlkRGF0ZTtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdE9yZGluYWwgPSAnJWQnLFxuICAgICAgICBkZWZhdWx0RGF5T2ZNb250aE9yZGluYWxQYXJzZSA9IC9cXGR7MSwyfS87XG5cbiAgICBmdW5jdGlvbiBvcmRpbmFsKG51bWJlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5fb3JkaW5hbC5yZXBsYWNlKCclZCcsIG51bWJlcik7XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRSZWxhdGl2ZVRpbWUgPSB7XG4gICAgICAgIGZ1dHVyZTogJ2luICVzJyxcbiAgICAgICAgcGFzdDogJyVzIGFnbycsXG4gICAgICAgIHM6ICdhIGZldyBzZWNvbmRzJyxcbiAgICAgICAgc3M6ICclZCBzZWNvbmRzJyxcbiAgICAgICAgbTogJ2EgbWludXRlJyxcbiAgICAgICAgbW06ICclZCBtaW51dGVzJyxcbiAgICAgICAgaDogJ2FuIGhvdXInLFxuICAgICAgICBoaDogJyVkIGhvdXJzJyxcbiAgICAgICAgZDogJ2EgZGF5JyxcbiAgICAgICAgZGQ6ICclZCBkYXlzJyxcbiAgICAgICAgdzogJ2Egd2VlaycsXG4gICAgICAgIHd3OiAnJWQgd2Vla3MnLFxuICAgICAgICBNOiAnYSBtb250aCcsXG4gICAgICAgIE1NOiAnJWQgbW9udGhzJyxcbiAgICAgICAgeTogJ2EgeWVhcicsXG4gICAgICAgIHl5OiAnJWQgeWVhcnMnLFxuICAgIH07XG5cbiAgICBmdW5jdGlvbiByZWxhdGl2ZVRpbWUobnVtYmVyLCB3aXRob3V0U3VmZml4LCBzdHJpbmcsIGlzRnV0dXJlKSB7XG4gICAgICAgIHZhciBvdXRwdXQgPSB0aGlzLl9yZWxhdGl2ZVRpbWVbc3RyaW5nXTtcbiAgICAgICAgcmV0dXJuIGlzRnVuY3Rpb24ob3V0cHV0KVxuICAgICAgICAgICAgPyBvdXRwdXQobnVtYmVyLCB3aXRob3V0U3VmZml4LCBzdHJpbmcsIGlzRnV0dXJlKVxuICAgICAgICAgICAgOiBvdXRwdXQucmVwbGFjZSgvJWQvaSwgbnVtYmVyKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXN0RnV0dXJlKGRpZmYsIG91dHB1dCkge1xuICAgICAgICB2YXIgZm9ybWF0ID0gdGhpcy5fcmVsYXRpdmVUaW1lW2RpZmYgPiAwID8gJ2Z1dHVyZScgOiAncGFzdCddO1xuICAgICAgICByZXR1cm4gaXNGdW5jdGlvbihmb3JtYXQpID8gZm9ybWF0KG91dHB1dCkgOiBmb3JtYXQucmVwbGFjZSgvJXMvaSwgb3V0cHV0KTtcbiAgICB9XG5cbiAgICB2YXIgYWxpYXNlcyA9IHt9O1xuXG4gICAgZnVuY3Rpb24gYWRkVW5pdEFsaWFzKHVuaXQsIHNob3J0aGFuZCkge1xuICAgICAgICB2YXIgbG93ZXJDYXNlID0gdW5pdC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBhbGlhc2VzW2xvd2VyQ2FzZV0gPSBhbGlhc2VzW2xvd2VyQ2FzZSArICdzJ10gPSBhbGlhc2VzW3Nob3J0aGFuZF0gPSB1bml0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZVVuaXRzKHVuaXRzKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdW5pdHMgPT09ICdzdHJpbmcnXG4gICAgICAgICAgICA/IGFsaWFzZXNbdW5pdHNdIHx8IGFsaWFzZXNbdW5pdHMudG9Mb3dlckNhc2UoKV1cbiAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZU9iamVjdFVuaXRzKGlucHV0T2JqZWN0KSB7XG4gICAgICAgIHZhciBub3JtYWxpemVkSW5wdXQgPSB7fSxcbiAgICAgICAgICAgIG5vcm1hbGl6ZWRQcm9wLFxuICAgICAgICAgICAgcHJvcDtcblxuICAgICAgICBmb3IgKHByb3AgaW4gaW5wdXRPYmplY3QpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wKGlucHV0T2JqZWN0LCBwcm9wKSkge1xuICAgICAgICAgICAgICAgIG5vcm1hbGl6ZWRQcm9wID0gbm9ybWFsaXplVW5pdHMocHJvcCk7XG4gICAgICAgICAgICAgICAgaWYgKG5vcm1hbGl6ZWRQcm9wKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vcm1hbGl6ZWRJbnB1dFtub3JtYWxpemVkUHJvcF0gPSBpbnB1dE9iamVjdFtwcm9wXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbm9ybWFsaXplZElucHV0O1xuICAgIH1cblxuICAgIHZhciBwcmlvcml0aWVzID0ge307XG5cbiAgICBmdW5jdGlvbiBhZGRVbml0UHJpb3JpdHkodW5pdCwgcHJpb3JpdHkpIHtcbiAgICAgICAgcHJpb3JpdGllc1t1bml0XSA9IHByaW9yaXR5O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFByaW9yaXRpemVkVW5pdHModW5pdHNPYmopIHtcbiAgICAgICAgdmFyIHVuaXRzID0gW10sXG4gICAgICAgICAgICB1O1xuICAgICAgICBmb3IgKHUgaW4gdW5pdHNPYmopIHtcbiAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wKHVuaXRzT2JqLCB1KSkge1xuICAgICAgICAgICAgICAgIHVuaXRzLnB1c2goeyB1bml0OiB1LCBwcmlvcml0eTogcHJpb3JpdGllc1t1XSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB1bml0cy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gYS5wcmlvcml0eSAtIGIucHJpb3JpdHk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdW5pdHM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNMZWFwWWVhcih5ZWFyKSB7XG4gICAgICAgIHJldHVybiAoeWVhciAlIDQgPT09IDAgJiYgeWVhciAlIDEwMCAhPT0gMCkgfHwgeWVhciAlIDQwMCA9PT0gMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhYnNGbG9vcihudW1iZXIpIHtcbiAgICAgICAgaWYgKG51bWJlciA8IDApIHtcbiAgICAgICAgICAgIC8vIC0wIC0+IDBcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmNlaWwobnVtYmVyKSB8fCAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IobnVtYmVyKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvSW50KGFyZ3VtZW50Rm9yQ29lcmNpb24pIHtcbiAgICAgICAgdmFyIGNvZXJjZWROdW1iZXIgPSArYXJndW1lbnRGb3JDb2VyY2lvbixcbiAgICAgICAgICAgIHZhbHVlID0gMDtcblxuICAgICAgICBpZiAoY29lcmNlZE51bWJlciAhPT0gMCAmJiBpc0Zpbml0ZShjb2VyY2VkTnVtYmVyKSkge1xuICAgICAgICAgICAgdmFsdWUgPSBhYnNGbG9vcihjb2VyY2VkTnVtYmVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYWtlR2V0U2V0KHVuaXQsIGtlZXBUaW1lKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgc2V0JDEodGhpcywgdW5pdCwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIGhvb2tzLnVwZGF0ZU9mZnNldCh0aGlzLCBrZWVwVGltZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZXQodGhpcywgdW5pdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0KG1vbSwgdW5pdCkge1xuICAgICAgICByZXR1cm4gbW9tLmlzVmFsaWQoKVxuICAgICAgICAgICAgPyBtb20uX2RbJ2dldCcgKyAobW9tLl9pc1VUQyA/ICdVVEMnIDogJycpICsgdW5pdF0oKVxuICAgICAgICAgICAgOiBOYU47XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0JDEobW9tLCB1bml0LCB2YWx1ZSkge1xuICAgICAgICBpZiAobW9tLmlzVmFsaWQoKSAmJiAhaXNOYU4odmFsdWUpKSB7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgdW5pdCA9PT0gJ0Z1bGxZZWFyJyAmJlxuICAgICAgICAgICAgICAgIGlzTGVhcFllYXIobW9tLnllYXIoKSkgJiZcbiAgICAgICAgICAgICAgICBtb20ubW9udGgoKSA9PT0gMSAmJlxuICAgICAgICAgICAgICAgIG1vbS5kYXRlKCkgPT09IDI5XG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHRvSW50KHZhbHVlKTtcbiAgICAgICAgICAgICAgICBtb20uX2RbJ3NldCcgKyAobW9tLl9pc1VUQyA/ICdVVEMnIDogJycpICsgdW5pdF0oXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBtb20ubW9udGgoKSxcbiAgICAgICAgICAgICAgICAgICAgZGF5c0luTW9udGgodmFsdWUsIG1vbS5tb250aCgpKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG1vbS5fZFsnc2V0JyArIChtb20uX2lzVVRDID8gJ1VUQycgOiAnJykgKyB1bml0XSh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICBmdW5jdGlvbiBzdHJpbmdHZXQodW5pdHMpIHtcbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKHRoaXNbdW5pdHNdKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXNbdW5pdHNdKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc3RyaW5nU2V0KHVuaXRzLCB2YWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mIHVuaXRzID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgdW5pdHMgPSBub3JtYWxpemVPYmplY3RVbml0cyh1bml0cyk7XG4gICAgICAgICAgICB2YXIgcHJpb3JpdGl6ZWQgPSBnZXRQcmlvcml0aXplZFVuaXRzKHVuaXRzKSxcbiAgICAgICAgICAgICAgICBpO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHByaW9yaXRpemVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpc1twcmlvcml0aXplZFtpXS51bml0XSh1bml0c1twcmlvcml0aXplZFtpXS51bml0XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcbiAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKHRoaXNbdW5pdHNdKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzW3VuaXRzXSh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdmFyIG1hdGNoMSA9IC9cXGQvLCAvLyAgICAgICAwIC0gOVxuICAgICAgICBtYXRjaDIgPSAvXFxkXFxkLywgLy8gICAgICAwMCAtIDk5XG4gICAgICAgIG1hdGNoMyA9IC9cXGR7M30vLCAvLyAgICAgMDAwIC0gOTk5XG4gICAgICAgIG1hdGNoNCA9IC9cXGR7NH0vLCAvLyAgICAwMDAwIC0gOTk5OVxuICAgICAgICBtYXRjaDYgPSAvWystXT9cXGR7Nn0vLCAvLyAtOTk5OTk5IC0gOTk5OTk5XG4gICAgICAgIG1hdGNoMXRvMiA9IC9cXGRcXGQ/LywgLy8gICAgICAgMCAtIDk5XG4gICAgICAgIG1hdGNoM3RvNCA9IC9cXGRcXGRcXGRcXGQ/LywgLy8gICAgIDk5OSAtIDk5OTlcbiAgICAgICAgbWF0Y2g1dG82ID0gL1xcZFxcZFxcZFxcZFxcZFxcZD8vLCAvLyAgIDk5OTk5IC0gOTk5OTk5XG4gICAgICAgIG1hdGNoMXRvMyA9IC9cXGR7MSwzfS8sIC8vICAgICAgIDAgLSA5OTlcbiAgICAgICAgbWF0Y2gxdG80ID0gL1xcZHsxLDR9LywgLy8gICAgICAgMCAtIDk5OTlcbiAgICAgICAgbWF0Y2gxdG82ID0gL1srLV0/XFxkezEsNn0vLCAvLyAtOTk5OTk5IC0gOTk5OTk5XG4gICAgICAgIG1hdGNoVW5zaWduZWQgPSAvXFxkKy8sIC8vICAgICAgIDAgLSBpbmZcbiAgICAgICAgbWF0Y2hTaWduZWQgPSAvWystXT9cXGQrLywgLy8gICAgLWluZiAtIGluZlxuICAgICAgICBtYXRjaE9mZnNldCA9IC9afFsrLV1cXGRcXGQ6P1xcZFxcZC9naSwgLy8gKzAwOjAwIC0wMDowMCArMDAwMCAtMDAwMCBvciBaXG4gICAgICAgIG1hdGNoU2hvcnRPZmZzZXQgPSAvWnxbKy1dXFxkXFxkKD86Oj9cXGRcXGQpPy9naSwgLy8gKzAwIC0wMCArMDA6MDAgLTAwOjAwICswMDAwIC0wMDAwIG9yIFpcbiAgICAgICAgbWF0Y2hUaW1lc3RhbXAgPSAvWystXT9cXGQrKFxcLlxcZHsxLDN9KT8vLCAvLyAxMjM0NTY3ODkgMTIzNDU2Nzg5LjEyM1xuICAgICAgICAvLyBhbnkgd29yZCAob3IgdHdvKSBjaGFyYWN0ZXJzIG9yIG51bWJlcnMgaW5jbHVkaW5nIHR3by90aHJlZSB3b3JkIG1vbnRoIGluIGFyYWJpYy5cbiAgICAgICAgLy8gaW5jbHVkZXMgc2NvdHRpc2ggZ2FlbGljIHR3byB3b3JkIGFuZCBoeXBoZW5hdGVkIG1vbnRoc1xuICAgICAgICBtYXRjaFdvcmQgPSAvWzAtOV17MCwyNTZ9WydhLXpcXHUwMEEwLVxcdTA1RkZcXHUwNzAwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGMDdcXHVGRjEwLVxcdUZGRUZdezEsMjU2fXxbXFx1MDYwMC1cXHUwNkZGXFwvXXsxLDI1Nn0oXFxzKj9bXFx1MDYwMC1cXHUwNkZGXXsxLDI1Nn0pezEsMn0vaSxcbiAgICAgICAgcmVnZXhlcztcblxuICAgIHJlZ2V4ZXMgPSB7fTtcblxuICAgIGZ1bmN0aW9uIGFkZFJlZ2V4VG9rZW4odG9rZW4sIHJlZ2V4LCBzdHJpY3RSZWdleCkge1xuICAgICAgICByZWdleGVzW3Rva2VuXSA9IGlzRnVuY3Rpb24ocmVnZXgpXG4gICAgICAgICAgICA/IHJlZ2V4XG4gICAgICAgICAgICA6IGZ1bmN0aW9uIChpc1N0cmljdCwgbG9jYWxlRGF0YSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGlzU3RyaWN0ICYmIHN0cmljdFJlZ2V4ID8gc3RyaWN0UmVnZXggOiByZWdleDtcbiAgICAgICAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRQYXJzZVJlZ2V4Rm9yVG9rZW4odG9rZW4sIGNvbmZpZykge1xuICAgICAgICBpZiAoIWhhc093blByb3AocmVnZXhlcywgdG9rZW4pKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cCh1bmVzY2FwZUZvcm1hdCh0b2tlbikpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlZ2V4ZXNbdG9rZW5dKGNvbmZpZy5fc3RyaWN0LCBjb25maWcuX2xvY2FsZSk7XG4gICAgfVxuXG4gICAgLy8gQ29kZSBmcm9tIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMzU2MTQ5My9pcy10aGVyZS1hLXJlZ2V4cC1lc2NhcGUtZnVuY3Rpb24taW4tamF2YXNjcmlwdFxuICAgIGZ1bmN0aW9uIHVuZXNjYXBlRm9ybWF0KHMpIHtcbiAgICAgICAgcmV0dXJuIHJlZ2V4RXNjYXBlKFxuICAgICAgICAgICAgc1xuICAgICAgICAgICAgICAgIC5yZXBsYWNlKCdcXFxcJywgJycpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFwoXFxbKXxcXFxcKFxcXSl8XFxbKFteXFxdXFxbXSopXFxdfFxcXFwoLikvZywgZnVuY3Rpb24gKFxuICAgICAgICAgICAgICAgICAgICBtYXRjaGVkLFxuICAgICAgICAgICAgICAgICAgICBwMSxcbiAgICAgICAgICAgICAgICAgICAgcDIsXG4gICAgICAgICAgICAgICAgICAgIHAzLFxuICAgICAgICAgICAgICAgICAgICBwNFxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcDEgfHwgcDIgfHwgcDMgfHwgcDQ7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZWdleEVzY2FwZShzKSB7XG4gICAgICAgIHJldHVybiBzLnJlcGxhY2UoL1stXFwvXFxcXF4kKis/LigpfFtcXF17fV0vZywgJ1xcXFwkJicpO1xuICAgIH1cblxuICAgIHZhciB0b2tlbnMgPSB7fTtcblxuICAgIGZ1bmN0aW9uIGFkZFBhcnNlVG9rZW4odG9rZW4sIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBpLFxuICAgICAgICAgICAgZnVuYyA9IGNhbGxiYWNrO1xuICAgICAgICBpZiAodHlwZW9mIHRva2VuID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdG9rZW4gPSBbdG9rZW5dO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc051bWJlcihjYWxsYmFjaykpIHtcbiAgICAgICAgICAgIGZ1bmMgPSBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgICAgICAgICAgICAgYXJyYXlbY2FsbGJhY2tdID0gdG9JbnQoaW5wdXQpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdG9rZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRva2Vuc1t0b2tlbltpXV0gPSBmdW5jO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkV2Vla1BhcnNlVG9rZW4odG9rZW4sIGNhbGxiYWNrKSB7XG4gICAgICAgIGFkZFBhcnNlVG9rZW4odG9rZW4sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZywgdG9rZW4pIHtcbiAgICAgICAgICAgIGNvbmZpZy5fdyA9IGNvbmZpZy5fdyB8fCB7fTtcbiAgICAgICAgICAgIGNhbGxiYWNrKGlucHV0LCBjb25maWcuX3csIGNvbmZpZywgdG9rZW4pO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRUaW1lVG9BcnJheUZyb21Ub2tlbih0b2tlbiwgaW5wdXQsIGNvbmZpZykge1xuICAgICAgICBpZiAoaW5wdXQgIT0gbnVsbCAmJiBoYXNPd25Qcm9wKHRva2VucywgdG9rZW4pKSB7XG4gICAgICAgICAgICB0b2tlbnNbdG9rZW5dKGlucHV0LCBjb25maWcuX2EsIGNvbmZpZywgdG9rZW4pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIFlFQVIgPSAwLFxuICAgICAgICBNT05USCA9IDEsXG4gICAgICAgIERBVEUgPSAyLFxuICAgICAgICBIT1VSID0gMyxcbiAgICAgICAgTUlOVVRFID0gNCxcbiAgICAgICAgU0VDT05EID0gNSxcbiAgICAgICAgTUlMTElTRUNPTkQgPSA2LFxuICAgICAgICBXRUVLID0gNyxcbiAgICAgICAgV0VFS0RBWSA9IDg7XG5cbiAgICBmdW5jdGlvbiBtb2QobiwgeCkge1xuICAgICAgICByZXR1cm4gKChuICUgeCkgKyB4KSAlIHg7XG4gICAgfVxuXG4gICAgdmFyIGluZGV4T2Y7XG5cbiAgICBpZiAoQXJyYXkucHJvdG90eXBlLmluZGV4T2YpIHtcbiAgICAgICAgaW5kZXhPZiA9IEFycmF5LnByb3RvdHlwZS5pbmRleE9mO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGluZGV4T2YgPSBmdW5jdGlvbiAobykge1xuICAgICAgICAgICAgLy8gSSBrbm93XG4gICAgICAgICAgICB2YXIgaTtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXNbaV0gPT09IG8pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRheXNJbk1vbnRoKHllYXIsIG1vbnRoKSB7XG4gICAgICAgIGlmIChpc05hTih5ZWFyKSB8fCBpc05hTihtb250aCkpIHtcbiAgICAgICAgICAgIHJldHVybiBOYU47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1vZE1vbnRoID0gbW9kKG1vbnRoLCAxMik7XG4gICAgICAgIHllYXIgKz0gKG1vbnRoIC0gbW9kTW9udGgpIC8gMTI7XG4gICAgICAgIHJldHVybiBtb2RNb250aCA9PT0gMVxuICAgICAgICAgICAgPyBpc0xlYXBZZWFyKHllYXIpXG4gICAgICAgICAgICAgICAgPyAyOVxuICAgICAgICAgICAgICAgIDogMjhcbiAgICAgICAgICAgIDogMzEgLSAoKG1vZE1vbnRoICUgNykgJSAyKTtcbiAgICB9XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbignTScsIFsnTU0nLCAyXSwgJ01vJywgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb250aCgpICsgMTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdNTU0nLCAwLCAwLCBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5tb250aHNTaG9ydCh0aGlzLCBmb3JtYXQpO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ01NTU0nLCAwLCAwLCBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5tb250aHModGhpcywgZm9ybWF0KTtcbiAgICB9KTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygnbW9udGgnLCAnTScpO1xuXG4gICAgLy8gUFJJT1JJVFlcblxuICAgIGFkZFVuaXRQcmlvcml0eSgnbW9udGgnLCA4KTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ00nLCBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ01NJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ01NTScsIGZ1bmN0aW9uIChpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGUubW9udGhzU2hvcnRSZWdleChpc1N0cmljdCk7XG4gICAgfSk7XG4gICAgYWRkUmVnZXhUb2tlbignTU1NTScsIGZ1bmN0aW9uIChpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGUubW9udGhzUmVnZXgoaXNTdHJpY3QpO1xuICAgIH0pO1xuXG4gICAgYWRkUGFyc2VUb2tlbihbJ00nLCAnTU0nXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSkge1xuICAgICAgICBhcnJheVtNT05USF0gPSB0b0ludChpbnB1dCkgLSAxO1xuICAgIH0pO1xuXG4gICAgYWRkUGFyc2VUb2tlbihbJ01NTScsICdNTU1NJ10sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZywgdG9rZW4pIHtcbiAgICAgICAgdmFyIG1vbnRoID0gY29uZmlnLl9sb2NhbGUubW9udGhzUGFyc2UoaW5wdXQsIHRva2VuLCBjb25maWcuX3N0cmljdCk7XG4gICAgICAgIC8vIGlmIHdlIGRpZG4ndCBmaW5kIGEgbW9udGggbmFtZSwgbWFyayB0aGUgZGF0ZSBhcyBpbnZhbGlkLlxuICAgICAgICBpZiAobW9udGggIT0gbnVsbCkge1xuICAgICAgICAgICAgYXJyYXlbTU9OVEhdID0gbW9udGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5pbnZhbGlkTW9udGggPSBpbnB1dDtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gTE9DQUxFU1xuXG4gICAgdmFyIGRlZmF1bHRMb2NhbGVNb250aHMgPSAnSmFudWFyeV9GZWJydWFyeV9NYXJjaF9BcHJpbF9NYXlfSnVuZV9KdWx5X0F1Z3VzdF9TZXB0ZW1iZXJfT2N0b2Jlcl9Ob3ZlbWJlcl9EZWNlbWJlcicuc3BsaXQoXG4gICAgICAgICAgICAnXydcbiAgICAgICAgKSxcbiAgICAgICAgZGVmYXVsdExvY2FsZU1vbnRoc1Nob3J0ID0gJ0phbl9GZWJfTWFyX0Fwcl9NYXlfSnVuX0p1bF9BdWdfU2VwX09jdF9Ob3ZfRGVjJy5zcGxpdChcbiAgICAgICAgICAgICdfJ1xuICAgICAgICApLFxuICAgICAgICBNT05USFNfSU5fRk9STUFUID0gL0Rbb0RdPyhcXFtbXlxcW1xcXV0qXFxdfFxccykrTU1NTT8vLFxuICAgICAgICBkZWZhdWx0TW9udGhzU2hvcnRSZWdleCA9IG1hdGNoV29yZCxcbiAgICAgICAgZGVmYXVsdE1vbnRoc1JlZ2V4ID0gbWF0Y2hXb3JkO1xuXG4gICAgZnVuY3Rpb24gbG9jYWxlTW9udGhzKG0sIGZvcm1hdCkge1xuICAgICAgICBpZiAoIW0pIHtcbiAgICAgICAgICAgIHJldHVybiBpc0FycmF5KHRoaXMuX21vbnRocylcbiAgICAgICAgICAgICAgICA/IHRoaXMuX21vbnRoc1xuICAgICAgICAgICAgICAgIDogdGhpcy5fbW9udGhzWydzdGFuZGFsb25lJ107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlzQXJyYXkodGhpcy5fbW9udGhzKVxuICAgICAgICAgICAgPyB0aGlzLl9tb250aHNbbS5tb250aCgpXVxuICAgICAgICAgICAgOiB0aGlzLl9tb250aHNbXG4gICAgICAgICAgICAgICAgICAodGhpcy5fbW9udGhzLmlzRm9ybWF0IHx8IE1PTlRIU19JTl9GT1JNQVQpLnRlc3QoZm9ybWF0KVxuICAgICAgICAgICAgICAgICAgICAgID8gJ2Zvcm1hdCdcbiAgICAgICAgICAgICAgICAgICAgICA6ICdzdGFuZGFsb25lJ1xuICAgICAgICAgICAgICBdW20ubW9udGgoKV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9jYWxlTW9udGhzU2hvcnQobSwgZm9ybWF0KSB7XG4gICAgICAgIGlmICghbSkge1xuICAgICAgICAgICAgcmV0dXJuIGlzQXJyYXkodGhpcy5fbW9udGhzU2hvcnQpXG4gICAgICAgICAgICAgICAgPyB0aGlzLl9tb250aHNTaG9ydFxuICAgICAgICAgICAgICAgIDogdGhpcy5fbW9udGhzU2hvcnRbJ3N0YW5kYWxvbmUnXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXNBcnJheSh0aGlzLl9tb250aHNTaG9ydClcbiAgICAgICAgICAgID8gdGhpcy5fbW9udGhzU2hvcnRbbS5tb250aCgpXVxuICAgICAgICAgICAgOiB0aGlzLl9tb250aHNTaG9ydFtcbiAgICAgICAgICAgICAgICAgIE1PTlRIU19JTl9GT1JNQVQudGVzdChmb3JtYXQpID8gJ2Zvcm1hdCcgOiAnc3RhbmRhbG9uZSdcbiAgICAgICAgICAgICAgXVttLm1vbnRoKCldO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhbmRsZVN0cmljdFBhcnNlKG1vbnRoTmFtZSwgZm9ybWF0LCBzdHJpY3QpIHtcbiAgICAgICAgdmFyIGksXG4gICAgICAgICAgICBpaSxcbiAgICAgICAgICAgIG1vbSxcbiAgICAgICAgICAgIGxsYyA9IG1vbnRoTmFtZS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAoIXRoaXMuX21vbnRoc1BhcnNlKSB7XG4gICAgICAgICAgICAvLyB0aGlzIGlzIG5vdCB1c2VkXG4gICAgICAgICAgICB0aGlzLl9tb250aHNQYXJzZSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fbG9uZ01vbnRoc1BhcnNlID0gW107XG4gICAgICAgICAgICB0aGlzLl9zaG9ydE1vbnRoc1BhcnNlID0gW107XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMTI7ICsraSkge1xuICAgICAgICAgICAgICAgIG1vbSA9IGNyZWF0ZVVUQyhbMjAwMCwgaV0pO1xuICAgICAgICAgICAgICAgIHRoaXMuX3Nob3J0TW9udGhzUGFyc2VbaV0gPSB0aGlzLm1vbnRoc1Nob3J0KFxuICAgICAgICAgICAgICAgICAgICBtb20sXG4gICAgICAgICAgICAgICAgICAgICcnXG4gICAgICAgICAgICAgICAgKS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2xvbmdNb250aHNQYXJzZVtpXSA9IHRoaXMubW9udGhzKG1vbSwgJycpLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RyaWN0KSB7XG4gICAgICAgICAgICBpZiAoZm9ybWF0ID09PSAnTU1NJykge1xuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3Nob3J0TW9udGhzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fbG9uZ01vbnRoc1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoZm9ybWF0ID09PSAnTU1NJykge1xuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3Nob3J0TW9udGhzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX2xvbmdNb250aHNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9sb25nTW9udGhzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3Nob3J0TW9udGhzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvY2FsZU1vbnRoc1BhcnNlKG1vbnRoTmFtZSwgZm9ybWF0LCBzdHJpY3QpIHtcbiAgICAgICAgdmFyIGksIG1vbSwgcmVnZXg7XG5cbiAgICAgICAgaWYgKHRoaXMuX21vbnRoc1BhcnNlRXhhY3QpIHtcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGVTdHJpY3RQYXJzZS5jYWxsKHRoaXMsIG1vbnRoTmFtZSwgZm9ybWF0LCBzdHJpY3QpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLl9tb250aHNQYXJzZSkge1xuICAgICAgICAgICAgdGhpcy5fbW9udGhzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX2xvbmdNb250aHNQYXJzZSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fc2hvcnRNb250aHNQYXJzZSA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVE9ETzogYWRkIHNvcnRpbmdcbiAgICAgICAgLy8gU29ydGluZyBtYWtlcyBzdXJlIGlmIG9uZSBtb250aCAob3IgYWJicikgaXMgYSBwcmVmaXggb2YgYW5vdGhlclxuICAgICAgICAvLyBzZWUgc29ydGluZyBpbiBjb21wdXRlTW9udGhzUGFyc2VcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDEyOyBpKyspIHtcbiAgICAgICAgICAgIC8vIG1ha2UgdGhlIHJlZ2V4IGlmIHdlIGRvbid0IGhhdmUgaXQgYWxyZWFkeVxuICAgICAgICAgICAgbW9tID0gY3JlYXRlVVRDKFsyMDAwLCBpXSk7XG4gICAgICAgICAgICBpZiAoc3RyaWN0ICYmICF0aGlzLl9sb25nTW9udGhzUGFyc2VbaV0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9sb25nTW9udGhzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKFxuICAgICAgICAgICAgICAgICAgICAnXicgKyB0aGlzLm1vbnRocyhtb20sICcnKS5yZXBsYWNlKCcuJywgJycpICsgJyQnLFxuICAgICAgICAgICAgICAgICAgICAnaSdcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHRoaXMuX3Nob3J0TW9udGhzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKFxuICAgICAgICAgICAgICAgICAgICAnXicgKyB0aGlzLm1vbnRoc1Nob3J0KG1vbSwgJycpLnJlcGxhY2UoJy4nLCAnJykgKyAnJCcsXG4gICAgICAgICAgICAgICAgICAgICdpJ1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXN0cmljdCAmJiAhdGhpcy5fbW9udGhzUGFyc2VbaV0pIHtcbiAgICAgICAgICAgICAgICByZWdleCA9XG4gICAgICAgICAgICAgICAgICAgICdeJyArIHRoaXMubW9udGhzKG1vbSwgJycpICsgJ3xeJyArIHRoaXMubW9udGhzU2hvcnQobW9tLCAnJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fbW9udGhzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKHJlZ2V4LnJlcGxhY2UoJy4nLCAnJyksICdpJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB0ZXN0IHRoZSByZWdleFxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIHN0cmljdCAmJlxuICAgICAgICAgICAgICAgIGZvcm1hdCA9PT0gJ01NTU0nICYmXG4gICAgICAgICAgICAgICAgdGhpcy5fbG9uZ01vbnRoc1BhcnNlW2ldLnRlc3QobW9udGhOYW1lKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgICAgIHN0cmljdCAmJlxuICAgICAgICAgICAgICAgIGZvcm1hdCA9PT0gJ01NTScgJiZcbiAgICAgICAgICAgICAgICB0aGlzLl9zaG9ydE1vbnRoc1BhcnNlW2ldLnRlc3QobW9udGhOYW1lKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFzdHJpY3QgJiYgdGhpcy5fbW9udGhzUGFyc2VbaV0udGVzdChtb250aE5hbWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICBmdW5jdGlvbiBzZXRNb250aChtb20sIHZhbHVlKSB7XG4gICAgICAgIHZhciBkYXlPZk1vbnRoO1xuXG4gICAgICAgIGlmICghbW9tLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgLy8gTm8gb3BcbiAgICAgICAgICAgIHJldHVybiBtb207XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgaWYgKC9eXFxkKyQvLnRlc3QodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB0b0ludCh2YWx1ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gbW9tLmxvY2FsZURhdGEoKS5tb250aHNQYXJzZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogQW5vdGhlciBzaWxlbnQgZmFpbHVyZT9cbiAgICAgICAgICAgICAgICBpZiAoIWlzTnVtYmVyKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbW9tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGRheU9mTW9udGggPSBNYXRoLm1pbihtb20uZGF0ZSgpLCBkYXlzSW5Nb250aChtb20ueWVhcigpLCB2YWx1ZSkpO1xuICAgICAgICBtb20uX2RbJ3NldCcgKyAobW9tLl9pc1VUQyA/ICdVVEMnIDogJycpICsgJ01vbnRoJ10odmFsdWUsIGRheU9mTW9udGgpO1xuICAgICAgICByZXR1cm4gbW9tO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFNldE1vbnRoKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBzZXRNb250aCh0aGlzLCB2YWx1ZSk7XG4gICAgICAgICAgICBob29rcy51cGRhdGVPZmZzZXQodGhpcywgdHJ1ZSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBnZXQodGhpcywgJ01vbnRoJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXREYXlzSW5Nb250aCgpIHtcbiAgICAgICAgcmV0dXJuIGRheXNJbk1vbnRoKHRoaXMueWVhcigpLCB0aGlzLm1vbnRoKCkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1vbnRoc1Nob3J0UmVnZXgoaXNTdHJpY3QpIHtcbiAgICAgICAgaWYgKHRoaXMuX21vbnRoc1BhcnNlRXhhY3QpIHtcbiAgICAgICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX21vbnRoc1JlZ2V4JykpIHtcbiAgICAgICAgICAgICAgICBjb21wdXRlTW9udGhzUGFyc2UuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1N0cmljdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9tb250aHNTaG9ydFN0cmljdFJlZ2V4O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzU2hvcnRSZWdleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX21vbnRoc1Nob3J0UmVnZXgnKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX21vbnRoc1Nob3J0UmVnZXggPSBkZWZhdWx0TW9udGhzU2hvcnRSZWdleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9tb250aHNTaG9ydFN0cmljdFJlZ2V4ICYmIGlzU3RyaWN0XG4gICAgICAgICAgICAgICAgPyB0aGlzLl9tb250aHNTaG9ydFN0cmljdFJlZ2V4XG4gICAgICAgICAgICAgICAgOiB0aGlzLl9tb250aHNTaG9ydFJlZ2V4O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbW9udGhzUmVnZXgoaXNTdHJpY3QpIHtcbiAgICAgICAgaWYgKHRoaXMuX21vbnRoc1BhcnNlRXhhY3QpIHtcbiAgICAgICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX21vbnRoc1JlZ2V4JykpIHtcbiAgICAgICAgICAgICAgICBjb21wdXRlTW9udGhzUGFyc2UuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1N0cmljdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9tb250aHNTdHJpY3RSZWdleDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21vbnRoc1JlZ2V4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfbW9udGhzUmVnZXgnKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX21vbnRoc1JlZ2V4ID0gZGVmYXVsdE1vbnRoc1JlZ2V4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21vbnRoc1N0cmljdFJlZ2V4ICYmIGlzU3RyaWN0XG4gICAgICAgICAgICAgICAgPyB0aGlzLl9tb250aHNTdHJpY3RSZWdleFxuICAgICAgICAgICAgICAgIDogdGhpcy5fbW9udGhzUmVnZXg7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb21wdXRlTW9udGhzUGFyc2UoKSB7XG4gICAgICAgIGZ1bmN0aW9uIGNtcExlblJldihhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gYi5sZW5ndGggLSBhLmxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzaG9ydFBpZWNlcyA9IFtdLFxuICAgICAgICAgICAgbG9uZ1BpZWNlcyA9IFtdLFxuICAgICAgICAgICAgbWl4ZWRQaWVjZXMgPSBbXSxcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICBtb207XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCAxMjsgaSsrKSB7XG4gICAgICAgICAgICAvLyBtYWtlIHRoZSByZWdleCBpZiB3ZSBkb24ndCBoYXZlIGl0IGFscmVhZHlcbiAgICAgICAgICAgIG1vbSA9IGNyZWF0ZVVUQyhbMjAwMCwgaV0pO1xuICAgICAgICAgICAgc2hvcnRQaWVjZXMucHVzaCh0aGlzLm1vbnRoc1Nob3J0KG1vbSwgJycpKTtcbiAgICAgICAgICAgIGxvbmdQaWVjZXMucHVzaCh0aGlzLm1vbnRocyhtb20sICcnKSk7XG4gICAgICAgICAgICBtaXhlZFBpZWNlcy5wdXNoKHRoaXMubW9udGhzKG1vbSwgJycpKTtcbiAgICAgICAgICAgIG1peGVkUGllY2VzLnB1c2godGhpcy5tb250aHNTaG9ydChtb20sICcnKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU29ydGluZyBtYWtlcyBzdXJlIGlmIG9uZSBtb250aCAob3IgYWJicikgaXMgYSBwcmVmaXggb2YgYW5vdGhlciBpdFxuICAgICAgICAvLyB3aWxsIG1hdGNoIHRoZSBsb25nZXIgcGllY2UuXG4gICAgICAgIHNob3J0UGllY2VzLnNvcnQoY21wTGVuUmV2KTtcbiAgICAgICAgbG9uZ1BpZWNlcy5zb3J0KGNtcExlblJldik7XG4gICAgICAgIG1peGVkUGllY2VzLnNvcnQoY21wTGVuUmV2KTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDEyOyBpKyspIHtcbiAgICAgICAgICAgIHNob3J0UGllY2VzW2ldID0gcmVnZXhFc2NhcGUoc2hvcnRQaWVjZXNbaV0pO1xuICAgICAgICAgICAgbG9uZ1BpZWNlc1tpXSA9IHJlZ2V4RXNjYXBlKGxvbmdQaWVjZXNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCAyNDsgaSsrKSB7XG4gICAgICAgICAgICBtaXhlZFBpZWNlc1tpXSA9IHJlZ2V4RXNjYXBlKG1peGVkUGllY2VzW2ldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX21vbnRoc1JlZ2V4ID0gbmV3IFJlZ0V4cCgnXignICsgbWl4ZWRQaWVjZXMuam9pbignfCcpICsgJyknLCAnaScpO1xuICAgICAgICB0aGlzLl9tb250aHNTaG9ydFJlZ2V4ID0gdGhpcy5fbW9udGhzUmVnZXg7XG4gICAgICAgIHRoaXMuX21vbnRoc1N0cmljdFJlZ2V4ID0gbmV3IFJlZ0V4cChcbiAgICAgICAgICAgICdeKCcgKyBsb25nUGllY2VzLmpvaW4oJ3wnKSArICcpJyxcbiAgICAgICAgICAgICdpJ1xuICAgICAgICApO1xuICAgICAgICB0aGlzLl9tb250aHNTaG9ydFN0cmljdFJlZ2V4ID0gbmV3IFJlZ0V4cChcbiAgICAgICAgICAgICdeKCcgKyBzaG9ydFBpZWNlcy5qb2luKCd8JykgKyAnKScsXG4gICAgICAgICAgICAnaSdcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbignWScsIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHkgPSB0aGlzLnllYXIoKTtcbiAgICAgICAgcmV0dXJuIHkgPD0gOTk5OSA/IHplcm9GaWxsKHksIDQpIDogJysnICsgeTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnWVknLCAyXSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy55ZWFyKCkgJSAxMDA7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1lZWVknLCA0XSwgMCwgJ3llYXInKTtcbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1lZWVlZJywgNV0sIDAsICd5ZWFyJyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydZWVlZWVknLCA2LCB0cnVlXSwgMCwgJ3llYXInKTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygneWVhcicsICd5Jyk7XG5cbiAgICAvLyBQUklPUklUSUVTXG5cbiAgICBhZGRVbml0UHJpb3JpdHkoJ3llYXInLCAxKTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ1knLCBtYXRjaFNpZ25lZCk7XG4gICAgYWRkUmVnZXhUb2tlbignWVknLCBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgYWRkUmVnZXhUb2tlbignWVlZWScsIG1hdGNoMXRvNCwgbWF0Y2g0KTtcbiAgICBhZGRSZWdleFRva2VuKCdZWVlZWScsIG1hdGNoMXRvNiwgbWF0Y2g2KTtcbiAgICBhZGRSZWdleFRva2VuKCdZWVlZWVknLCBtYXRjaDF0bzYsIG1hdGNoNik7XG5cbiAgICBhZGRQYXJzZVRva2VuKFsnWVlZWVknLCAnWVlZWVlZJ10sIFlFQVIpO1xuICAgIGFkZFBhcnNlVG9rZW4oJ1lZWVknLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgICAgIGFycmF5W1lFQVJdID1cbiAgICAgICAgICAgIGlucHV0Lmxlbmd0aCA9PT0gMiA/IGhvb2tzLnBhcnNlVHdvRGlnaXRZZWFyKGlucHV0KSA6IHRvSW50KGlucHV0KTtcbiAgICB9KTtcbiAgICBhZGRQYXJzZVRva2VuKCdZWScsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICAgICAgYXJyYXlbWUVBUl0gPSBob29rcy5wYXJzZVR3b0RpZ2l0WWVhcihpbnB1dCk7XG4gICAgfSk7XG4gICAgYWRkUGFyc2VUb2tlbignWScsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICAgICAgYXJyYXlbWUVBUl0gPSBwYXJzZUludChpbnB1dCwgMTApO1xuICAgIH0pO1xuXG4gICAgLy8gSEVMUEVSU1xuXG4gICAgZnVuY3Rpb24gZGF5c0luWWVhcih5ZWFyKSB7XG4gICAgICAgIHJldHVybiBpc0xlYXBZZWFyKHllYXIpID8gMzY2IDogMzY1O1xuICAgIH1cblxuICAgIC8vIEhPT0tTXG5cbiAgICBob29rcy5wYXJzZVR3b0RpZ2l0WWVhciA9IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICByZXR1cm4gdG9JbnQoaW5wdXQpICsgKHRvSW50KGlucHV0KSA+IDY4ID8gMTkwMCA6IDIwMDApO1xuICAgIH07XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICB2YXIgZ2V0U2V0WWVhciA9IG1ha2VHZXRTZXQoJ0Z1bGxZZWFyJywgdHJ1ZSk7XG5cbiAgICBmdW5jdGlvbiBnZXRJc0xlYXBZZWFyKCkge1xuICAgICAgICByZXR1cm4gaXNMZWFwWWVhcih0aGlzLnllYXIoKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlRGF0ZSh5LCBtLCBkLCBoLCBNLCBzLCBtcykge1xuICAgICAgICAvLyBjYW4ndCBqdXN0IGFwcGx5KCkgdG8gY3JlYXRlIGEgZGF0ZTpcbiAgICAgICAgLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xLzE4MTM0OFxuICAgICAgICB2YXIgZGF0ZTtcbiAgICAgICAgLy8gdGhlIGRhdGUgY29uc3RydWN0b3IgcmVtYXBzIHllYXJzIDAtOTkgdG8gMTkwMC0xOTk5XG4gICAgICAgIGlmICh5IDwgMTAwICYmIHkgPj0gMCkge1xuICAgICAgICAgICAgLy8gcHJlc2VydmUgbGVhcCB5ZWFycyB1c2luZyBhIGZ1bGwgNDAwIHllYXIgY3ljbGUsIHRoZW4gcmVzZXRcbiAgICAgICAgICAgIGRhdGUgPSBuZXcgRGF0ZSh5ICsgNDAwLCBtLCBkLCBoLCBNLCBzLCBtcyk7XG4gICAgICAgICAgICBpZiAoaXNGaW5pdGUoZGF0ZS5nZXRGdWxsWWVhcigpKSkge1xuICAgICAgICAgICAgICAgIGRhdGUuc2V0RnVsbFllYXIoeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkYXRlID0gbmV3IERhdGUoeSwgbSwgZCwgaCwgTSwgcywgbXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRhdGU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlVVRDRGF0ZSh5KSB7XG4gICAgICAgIHZhciBkYXRlLCBhcmdzO1xuICAgICAgICAvLyB0aGUgRGF0ZS5VVEMgZnVuY3Rpb24gcmVtYXBzIHllYXJzIDAtOTkgdG8gMTkwMC0xOTk5XG4gICAgICAgIGlmICh5IDwgMTAwICYmIHkgPj0gMCkge1xuICAgICAgICAgICAgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAvLyBwcmVzZXJ2ZSBsZWFwIHllYXJzIHVzaW5nIGEgZnVsbCA0MDAgeWVhciBjeWNsZSwgdGhlbiByZXNldFxuICAgICAgICAgICAgYXJnc1swXSA9IHkgKyA0MDA7XG4gICAgICAgICAgICBkYXRlID0gbmV3IERhdGUoRGF0ZS5VVEMuYXBwbHkobnVsbCwgYXJncykpO1xuICAgICAgICAgICAgaWYgKGlzRmluaXRlKGRhdGUuZ2V0VVRDRnVsbFllYXIoKSkpIHtcbiAgICAgICAgICAgICAgICBkYXRlLnNldFVUQ0Z1bGxZZWFyKHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGF0ZSA9IG5ldyBEYXRlKERhdGUuVVRDLmFwcGx5KG51bGwsIGFyZ3VtZW50cykpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRhdGU7XG4gICAgfVxuXG4gICAgLy8gc3RhcnQtb2YtZmlyc3Qtd2VlayAtIHN0YXJ0LW9mLXllYXJcbiAgICBmdW5jdGlvbiBmaXJzdFdlZWtPZmZzZXQoeWVhciwgZG93LCBkb3kpIHtcbiAgICAgICAgdmFyIC8vIGZpcnN0LXdlZWsgZGF5IC0tIHdoaWNoIGphbnVhcnkgaXMgYWx3YXlzIGluIHRoZSBmaXJzdCB3ZWVrICg0IGZvciBpc28sIDEgZm9yIG90aGVyKVxuICAgICAgICAgICAgZndkID0gNyArIGRvdyAtIGRveSxcbiAgICAgICAgICAgIC8vIGZpcnN0LXdlZWsgZGF5IGxvY2FsIHdlZWtkYXkgLS0gd2hpY2ggbG9jYWwgd2Vla2RheSBpcyBmd2RcbiAgICAgICAgICAgIGZ3ZGx3ID0gKDcgKyBjcmVhdGVVVENEYXRlKHllYXIsIDAsIGZ3ZCkuZ2V0VVRDRGF5KCkgLSBkb3cpICUgNztcblxuICAgICAgICByZXR1cm4gLWZ3ZGx3ICsgZndkIC0gMTtcbiAgICB9XG5cbiAgICAvLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JU09fd2Vla19kYXRlI0NhbGN1bGF0aW5nX2FfZGF0ZV9naXZlbl90aGVfeWVhci4yQ193ZWVrX251bWJlcl9hbmRfd2Vla2RheVxuICAgIGZ1bmN0aW9uIGRheU9mWWVhckZyb21XZWVrcyh5ZWFyLCB3ZWVrLCB3ZWVrZGF5LCBkb3csIGRveSkge1xuICAgICAgICB2YXIgbG9jYWxXZWVrZGF5ID0gKDcgKyB3ZWVrZGF5IC0gZG93KSAlIDcsXG4gICAgICAgICAgICB3ZWVrT2Zmc2V0ID0gZmlyc3RXZWVrT2Zmc2V0KHllYXIsIGRvdywgZG95KSxcbiAgICAgICAgICAgIGRheU9mWWVhciA9IDEgKyA3ICogKHdlZWsgLSAxKSArIGxvY2FsV2Vla2RheSArIHdlZWtPZmZzZXQsXG4gICAgICAgICAgICByZXNZZWFyLFxuICAgICAgICAgICAgcmVzRGF5T2ZZZWFyO1xuXG4gICAgICAgIGlmIChkYXlPZlllYXIgPD0gMCkge1xuICAgICAgICAgICAgcmVzWWVhciA9IHllYXIgLSAxO1xuICAgICAgICAgICAgcmVzRGF5T2ZZZWFyID0gZGF5c0luWWVhcihyZXNZZWFyKSArIGRheU9mWWVhcjtcbiAgICAgICAgfSBlbHNlIGlmIChkYXlPZlllYXIgPiBkYXlzSW5ZZWFyKHllYXIpKSB7XG4gICAgICAgICAgICByZXNZZWFyID0geWVhciArIDE7XG4gICAgICAgICAgICByZXNEYXlPZlllYXIgPSBkYXlPZlllYXIgLSBkYXlzSW5ZZWFyKHllYXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzWWVhciA9IHllYXI7XG4gICAgICAgICAgICByZXNEYXlPZlllYXIgPSBkYXlPZlllYXI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeWVhcjogcmVzWWVhcixcbiAgICAgICAgICAgIGRheU9mWWVhcjogcmVzRGF5T2ZZZWFyLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHdlZWtPZlllYXIobW9tLCBkb3csIGRveSkge1xuICAgICAgICB2YXIgd2Vla09mZnNldCA9IGZpcnN0V2Vla09mZnNldChtb20ueWVhcigpLCBkb3csIGRveSksXG4gICAgICAgICAgICB3ZWVrID0gTWF0aC5mbG9vcigobW9tLmRheU9mWWVhcigpIC0gd2Vla09mZnNldCAtIDEpIC8gNykgKyAxLFxuICAgICAgICAgICAgcmVzV2VlayxcbiAgICAgICAgICAgIHJlc1llYXI7XG5cbiAgICAgICAgaWYgKHdlZWsgPCAxKSB7XG4gICAgICAgICAgICByZXNZZWFyID0gbW9tLnllYXIoKSAtIDE7XG4gICAgICAgICAgICByZXNXZWVrID0gd2VlayArIHdlZWtzSW5ZZWFyKHJlc1llYXIsIGRvdywgZG95KTtcbiAgICAgICAgfSBlbHNlIGlmICh3ZWVrID4gd2Vla3NJblllYXIobW9tLnllYXIoKSwgZG93LCBkb3kpKSB7XG4gICAgICAgICAgICByZXNXZWVrID0gd2VlayAtIHdlZWtzSW5ZZWFyKG1vbS55ZWFyKCksIGRvdywgZG95KTtcbiAgICAgICAgICAgIHJlc1llYXIgPSBtb20ueWVhcigpICsgMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc1llYXIgPSBtb20ueWVhcigpO1xuICAgICAgICAgICAgcmVzV2VlayA9IHdlZWs7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgd2VlazogcmVzV2VlayxcbiAgICAgICAgICAgIHllYXI6IHJlc1llYXIsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gd2Vla3NJblllYXIoeWVhciwgZG93LCBkb3kpIHtcbiAgICAgICAgdmFyIHdlZWtPZmZzZXQgPSBmaXJzdFdlZWtPZmZzZXQoeWVhciwgZG93LCBkb3kpLFxuICAgICAgICAgICAgd2Vla09mZnNldE5leHQgPSBmaXJzdFdlZWtPZmZzZXQoeWVhciArIDEsIGRvdywgZG95KTtcbiAgICAgICAgcmV0dXJuIChkYXlzSW5ZZWFyKHllYXIpIC0gd2Vla09mZnNldCArIHdlZWtPZmZzZXROZXh0KSAvIDc7XG4gICAgfVxuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ3cnLCBbJ3d3JywgMl0sICd3bycsICd3ZWVrJyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oJ1cnLCBbJ1dXJywgMl0sICdXbycsICdpc29XZWVrJyk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ3dlZWsnLCAndycpO1xuICAgIGFkZFVuaXRBbGlhcygnaXNvV2VlaycsICdXJyk7XG5cbiAgICAvLyBQUklPUklUSUVTXG5cbiAgICBhZGRVbml0UHJpb3JpdHkoJ3dlZWsnLCA1KTtcbiAgICBhZGRVbml0UHJpb3JpdHkoJ2lzb1dlZWsnLCA1KTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ3cnLCBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ3d3JywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1cnLCBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1dXJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuXG4gICAgYWRkV2Vla1BhcnNlVG9rZW4oWyd3JywgJ3d3JywgJ1cnLCAnV1cnXSwgZnVuY3Rpb24gKFxuICAgICAgICBpbnB1dCxcbiAgICAgICAgd2VlayxcbiAgICAgICAgY29uZmlnLFxuICAgICAgICB0b2tlblxuICAgICkge1xuICAgICAgICB3ZWVrW3Rva2VuLnN1YnN0cigwLCAxKV0gPSB0b0ludChpbnB1dCk7XG4gICAgfSk7XG5cbiAgICAvLyBIRUxQRVJTXG5cbiAgICAvLyBMT0NBTEVTXG5cbiAgICBmdW5jdGlvbiBsb2NhbGVXZWVrKG1vbSkge1xuICAgICAgICByZXR1cm4gd2Vla09mWWVhcihtb20sIHRoaXMuX3dlZWsuZG93LCB0aGlzLl93ZWVrLmRveSkud2VlaztcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdExvY2FsZVdlZWsgPSB7XG4gICAgICAgIGRvdzogMCwgLy8gU3VuZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAgICAgIGRveTogNiwgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gNnRoIGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBsb2NhbGVGaXJzdERheU9mV2VlaygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWsuZG93O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvY2FsZUZpcnN0RGF5T2ZZZWFyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd2Vlay5kb3k7XG4gICAgfVxuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgZnVuY3Rpb24gZ2V0U2V0V2VlayhpbnB1dCkge1xuICAgICAgICB2YXIgd2VlayA9IHRoaXMubG9jYWxlRGF0YSgpLndlZWsodGhpcyk7XG4gICAgICAgIHJldHVybiBpbnB1dCA9PSBudWxsID8gd2VlayA6IHRoaXMuYWRkKChpbnB1dCAtIHdlZWspICogNywgJ2QnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTZXRJU09XZWVrKGlucHV0KSB7XG4gICAgICAgIHZhciB3ZWVrID0gd2Vla09mWWVhcih0aGlzLCAxLCA0KS53ZWVrO1xuICAgICAgICByZXR1cm4gaW5wdXQgPT0gbnVsbCA/IHdlZWsgOiB0aGlzLmFkZCgoaW5wdXQgLSB3ZWVrKSAqIDcsICdkJyk7XG4gICAgfVxuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ2QnLCAwLCAnZG8nLCAnZGF5Jyk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignZGQnLCAwLCAwLCBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS53ZWVrZGF5c01pbih0aGlzLCBmb3JtYXQpO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ2RkZCcsIDAsIDAsIGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLndlZWtkYXlzU2hvcnQodGhpcywgZm9ybWF0KTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdkZGRkJywgMCwgMCwgZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkud2Vla2RheXModGhpcywgZm9ybWF0KTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdlJywgMCwgMCwgJ3dlZWtkYXknKTtcbiAgICBhZGRGb3JtYXRUb2tlbignRScsIDAsIDAsICdpc29XZWVrZGF5Jyk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ2RheScsICdkJyk7XG4gICAgYWRkVW5pdEFsaWFzKCd3ZWVrZGF5JywgJ2UnKTtcbiAgICBhZGRVbml0QWxpYXMoJ2lzb1dlZWtkYXknLCAnRScpO1xuXG4gICAgLy8gUFJJT1JJVFlcbiAgICBhZGRVbml0UHJpb3JpdHkoJ2RheScsIDExKTtcbiAgICBhZGRVbml0UHJpb3JpdHkoJ3dlZWtkYXknLCAxMSk7XG4gICAgYWRkVW5pdFByaW9yaXR5KCdpc29XZWVrZGF5JywgMTEpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignZCcsIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignZScsIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignRScsIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignZGQnLCBmdW5jdGlvbiAoaXNTdHJpY3QsIGxvY2FsZSkge1xuICAgICAgICByZXR1cm4gbG9jYWxlLndlZWtkYXlzTWluUmVnZXgoaXNTdHJpY3QpO1xuICAgIH0pO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2RkZCcsIGZ1bmN0aW9uIChpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGUud2Vla2RheXNTaG9ydFJlZ2V4KGlzU3RyaWN0KTtcbiAgICB9KTtcbiAgICBhZGRSZWdleFRva2VuKCdkZGRkJywgZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZS53ZWVrZGF5c1JlZ2V4KGlzU3RyaWN0KTtcbiAgICB9KTtcblxuICAgIGFkZFdlZWtQYXJzZVRva2VuKFsnZGQnLCAnZGRkJywgJ2RkZGQnXSwgZnVuY3Rpb24gKGlucHV0LCB3ZWVrLCBjb25maWcsIHRva2VuKSB7XG4gICAgICAgIHZhciB3ZWVrZGF5ID0gY29uZmlnLl9sb2NhbGUud2Vla2RheXNQYXJzZShpbnB1dCwgdG9rZW4sIGNvbmZpZy5fc3RyaWN0KTtcbiAgICAgICAgLy8gaWYgd2UgZGlkbid0IGdldCBhIHdlZWtkYXkgbmFtZSwgbWFyayB0aGUgZGF0ZSBhcyBpbnZhbGlkXG4gICAgICAgIGlmICh3ZWVrZGF5ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHdlZWsuZCA9IHdlZWtkYXk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5pbnZhbGlkV2Vla2RheSA9IGlucHV0O1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBhZGRXZWVrUGFyc2VUb2tlbihbJ2QnLCAnZScsICdFJ10sIGZ1bmN0aW9uIChpbnB1dCwgd2VlaywgY29uZmlnLCB0b2tlbikge1xuICAgICAgICB3ZWVrW3Rva2VuXSA9IHRvSW50KGlucHV0KTtcbiAgICB9KTtcblxuICAgIC8vIEhFTFBFUlNcblxuICAgIGZ1bmN0aW9uIHBhcnNlV2Vla2RheShpbnB1dCwgbG9jYWxlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzTmFOKGlucHV0KSkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KGlucHV0LCAxMCk7XG4gICAgICAgIH1cblxuICAgICAgICBpbnB1dCA9IGxvY2FsZS53ZWVrZGF5c1BhcnNlKGlucHV0KTtcbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlSXNvV2Vla2RheShpbnB1dCwgbG9jYWxlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxlLndlZWtkYXlzUGFyc2UoaW5wdXQpICUgNyB8fCA3O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpc05hTihpbnB1dCkgPyBudWxsIDogaW5wdXQ7XG4gICAgfVxuXG4gICAgLy8gTE9DQUxFU1xuICAgIGZ1bmN0aW9uIHNoaWZ0V2Vla2RheXMod3MsIG4pIHtcbiAgICAgICAgcmV0dXJuIHdzLnNsaWNlKG4sIDcpLmNvbmNhdCh3cy5zbGljZSgwLCBuKSk7XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRMb2NhbGVXZWVrZGF5cyA9ICdTdW5kYXlfTW9uZGF5X1R1ZXNkYXlfV2VkbmVzZGF5X1RodXJzZGF5X0ZyaWRheV9TYXR1cmRheScuc3BsaXQoXG4gICAgICAgICAgICAnXydcbiAgICAgICAgKSxcbiAgICAgICAgZGVmYXVsdExvY2FsZVdlZWtkYXlzU2hvcnQgPSAnU3VuX01vbl9UdWVfV2VkX1RodV9GcmlfU2F0Jy5zcGxpdCgnXycpLFxuICAgICAgICBkZWZhdWx0TG9jYWxlV2Vla2RheXNNaW4gPSAnU3VfTW9fVHVfV2VfVGhfRnJfU2EnLnNwbGl0KCdfJyksXG4gICAgICAgIGRlZmF1bHRXZWVrZGF5c1JlZ2V4ID0gbWF0Y2hXb3JkLFxuICAgICAgICBkZWZhdWx0V2Vla2RheXNTaG9ydFJlZ2V4ID0gbWF0Y2hXb3JkLFxuICAgICAgICBkZWZhdWx0V2Vla2RheXNNaW5SZWdleCA9IG1hdGNoV29yZDtcblxuICAgIGZ1bmN0aW9uIGxvY2FsZVdlZWtkYXlzKG0sIGZvcm1hdCkge1xuICAgICAgICB2YXIgd2Vla2RheXMgPSBpc0FycmF5KHRoaXMuX3dlZWtkYXlzKVxuICAgICAgICAgICAgPyB0aGlzLl93ZWVrZGF5c1xuICAgICAgICAgICAgOiB0aGlzLl93ZWVrZGF5c1tcbiAgICAgICAgICAgICAgICAgIG0gJiYgbSAhPT0gdHJ1ZSAmJiB0aGlzLl93ZWVrZGF5cy5pc0Zvcm1hdC50ZXN0KGZvcm1hdClcbiAgICAgICAgICAgICAgICAgICAgICA/ICdmb3JtYXQnXG4gICAgICAgICAgICAgICAgICAgICAgOiAnc3RhbmRhbG9uZSdcbiAgICAgICAgICAgICAgXTtcbiAgICAgICAgcmV0dXJuIG0gPT09IHRydWVcbiAgICAgICAgICAgID8gc2hpZnRXZWVrZGF5cyh3ZWVrZGF5cywgdGhpcy5fd2Vlay5kb3cpXG4gICAgICAgICAgICA6IG1cbiAgICAgICAgICAgID8gd2Vla2RheXNbbS5kYXkoKV1cbiAgICAgICAgICAgIDogd2Vla2RheXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9jYWxlV2Vla2RheXNTaG9ydChtKSB7XG4gICAgICAgIHJldHVybiBtID09PSB0cnVlXG4gICAgICAgICAgICA/IHNoaWZ0V2Vla2RheXModGhpcy5fd2Vla2RheXNTaG9ydCwgdGhpcy5fd2Vlay5kb3cpXG4gICAgICAgICAgICA6IG1cbiAgICAgICAgICAgID8gdGhpcy5fd2Vla2RheXNTaG9ydFttLmRheSgpXVxuICAgICAgICAgICAgOiB0aGlzLl93ZWVrZGF5c1Nob3J0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvY2FsZVdlZWtkYXlzTWluKG0pIHtcbiAgICAgICAgcmV0dXJuIG0gPT09IHRydWVcbiAgICAgICAgICAgID8gc2hpZnRXZWVrZGF5cyh0aGlzLl93ZWVrZGF5c01pbiwgdGhpcy5fd2Vlay5kb3cpXG4gICAgICAgICAgICA6IG1cbiAgICAgICAgICAgID8gdGhpcy5fd2Vla2RheXNNaW5bbS5kYXkoKV1cbiAgICAgICAgICAgIDogdGhpcy5fd2Vla2RheXNNaW47XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFuZGxlU3RyaWN0UGFyc2UkMSh3ZWVrZGF5TmFtZSwgZm9ybWF0LCBzdHJpY3QpIHtcbiAgICAgICAgdmFyIGksXG4gICAgICAgICAgICBpaSxcbiAgICAgICAgICAgIG1vbSxcbiAgICAgICAgICAgIGxsYyA9IHdlZWtkYXlOYW1lLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmICghdGhpcy5fd2Vla2RheXNQYXJzZSkge1xuICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNQYXJzZSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlID0gW107XG4gICAgICAgICAgICB0aGlzLl9taW5XZWVrZGF5c1BhcnNlID0gW107XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCA3OyArK2kpIHtcbiAgICAgICAgICAgICAgICBtb20gPSBjcmVhdGVVVEMoWzIwMDAsIDFdKS5kYXkoaSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fbWluV2Vla2RheXNQYXJzZVtpXSA9IHRoaXMud2Vla2RheXNNaW4oXG4gICAgICAgICAgICAgICAgICAgIG1vbSxcbiAgICAgICAgICAgICAgICAgICAgJydcbiAgICAgICAgICAgICAgICApLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlW2ldID0gdGhpcy53ZWVrZGF5c1Nob3J0KFxuICAgICAgICAgICAgICAgICAgICBtb20sXG4gICAgICAgICAgICAgICAgICAgICcnXG4gICAgICAgICAgICAgICAgKS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzUGFyc2VbaV0gPSB0aGlzLndlZWtkYXlzKG1vbSwgJycpLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RyaWN0KSB7XG4gICAgICAgICAgICBpZiAoZm9ybWF0ID09PSAnZGRkZCcpIHtcbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl93ZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGZvcm1hdCA9PT0gJ2RkZCcpIHtcbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fbWluV2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGZvcm1hdCA9PT0gJ2RkZGQnKSB7XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fd2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICBpZiAoaWkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIGlmIChpaSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9taW5XZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGZvcm1hdCA9PT0gJ2RkZCcpIHtcbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3dlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX21pbldlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fbWluV2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICBpZiAoaWkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fd2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICBpZiAoaWkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb2NhbGVXZWVrZGF5c1BhcnNlKHdlZWtkYXlOYW1lLCBmb3JtYXQsIHN0cmljdCkge1xuICAgICAgICB2YXIgaSwgbW9tLCByZWdleDtcblxuICAgICAgICBpZiAodGhpcy5fd2Vla2RheXNQYXJzZUV4YWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlU3RyaWN0UGFyc2UkMS5jYWxsKHRoaXMsIHdlZWtkYXlOYW1lLCBmb3JtYXQsIHN0cmljdCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuX3dlZWtkYXlzUGFyc2UpIHtcbiAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX21pbldlZWtkYXlzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fZnVsbFdlZWtkYXlzUGFyc2UgPSBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCA3OyBpKyspIHtcbiAgICAgICAgICAgIC8vIG1ha2UgdGhlIHJlZ2V4IGlmIHdlIGRvbid0IGhhdmUgaXQgYWxyZWFkeVxuXG4gICAgICAgICAgICBtb20gPSBjcmVhdGVVVEMoWzIwMDAsIDFdKS5kYXkoaSk7XG4gICAgICAgICAgICBpZiAoc3RyaWN0ICYmICF0aGlzLl9mdWxsV2Vla2RheXNQYXJzZVtpXSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2Z1bGxXZWVrZGF5c1BhcnNlW2ldID0gbmV3IFJlZ0V4cChcbiAgICAgICAgICAgICAgICAgICAgJ14nICsgdGhpcy53ZWVrZGF5cyhtb20sICcnKS5yZXBsYWNlKCcuJywgJ1xcXFwuPycpICsgJyQnLFxuICAgICAgICAgICAgICAgICAgICAnaSdcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZVtpXSA9IG5ldyBSZWdFeHAoXG4gICAgICAgICAgICAgICAgICAgICdeJyArIHRoaXMud2Vla2RheXNTaG9ydChtb20sICcnKS5yZXBsYWNlKCcuJywgJ1xcXFwuPycpICsgJyQnLFxuICAgICAgICAgICAgICAgICAgICAnaSdcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHRoaXMuX21pbldlZWtkYXlzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKFxuICAgICAgICAgICAgICAgICAgICAnXicgKyB0aGlzLndlZWtkYXlzTWluKG1vbSwgJycpLnJlcGxhY2UoJy4nLCAnXFxcXC4/JykgKyAnJCcsXG4gICAgICAgICAgICAgICAgICAgICdpJ1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMuX3dlZWtkYXlzUGFyc2VbaV0pIHtcbiAgICAgICAgICAgICAgICByZWdleCA9XG4gICAgICAgICAgICAgICAgICAgICdeJyArXG4gICAgICAgICAgICAgICAgICAgIHRoaXMud2Vla2RheXMobW9tLCAnJykgK1xuICAgICAgICAgICAgICAgICAgICAnfF4nICtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy53ZWVrZGF5c1Nob3J0KG1vbSwgJycpICtcbiAgICAgICAgICAgICAgICAgICAgJ3xeJyArXG4gICAgICAgICAgICAgICAgICAgIHRoaXMud2Vla2RheXNNaW4obW9tLCAnJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNQYXJzZVtpXSA9IG5ldyBSZWdFeHAocmVnZXgucmVwbGFjZSgnLicsICcnKSwgJ2knKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHRlc3QgdGhlIHJlZ2V4XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgc3RyaWN0ICYmXG4gICAgICAgICAgICAgICAgZm9ybWF0ID09PSAnZGRkZCcgJiZcbiAgICAgICAgICAgICAgICB0aGlzLl9mdWxsV2Vla2RheXNQYXJzZVtpXS50ZXN0KHdlZWtkYXlOYW1lKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgICAgIHN0cmljdCAmJlxuICAgICAgICAgICAgICAgIGZvcm1hdCA9PT0gJ2RkZCcgJiZcbiAgICAgICAgICAgICAgICB0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2VbaV0udGVzdCh3ZWVrZGF5TmFtZSlcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgICAgICBzdHJpY3QgJiZcbiAgICAgICAgICAgICAgICBmb3JtYXQgPT09ICdkZCcgJiZcbiAgICAgICAgICAgICAgICB0aGlzLl9taW5XZWVrZGF5c1BhcnNlW2ldLnRlc3Qod2Vla2RheU5hbWUpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIXN0cmljdCAmJiB0aGlzLl93ZWVrZGF5c1BhcnNlW2ldLnRlc3Qod2Vla2RheU5hbWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICBmdW5jdGlvbiBnZXRTZXREYXlPZldlZWsoaW5wdXQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0ICE9IG51bGwgPyB0aGlzIDogTmFOO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkYXkgPSB0aGlzLl9pc1VUQyA/IHRoaXMuX2QuZ2V0VVRDRGF5KCkgOiB0aGlzLl9kLmdldERheSgpO1xuICAgICAgICBpZiAoaW5wdXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgaW5wdXQgPSBwYXJzZVdlZWtkYXkoaW5wdXQsIHRoaXMubG9jYWxlRGF0YSgpKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZChpbnB1dCAtIGRheSwgJ2QnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBkYXk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTZXRMb2NhbGVEYXlPZldlZWsoaW5wdXQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0ICE9IG51bGwgPyB0aGlzIDogTmFOO1xuICAgICAgICB9XG4gICAgICAgIHZhciB3ZWVrZGF5ID0gKHRoaXMuZGF5KCkgKyA3IC0gdGhpcy5sb2NhbGVEYXRhKCkuX3dlZWsuZG93KSAlIDc7XG4gICAgICAgIHJldHVybiBpbnB1dCA9PSBudWxsID8gd2Vla2RheSA6IHRoaXMuYWRkKGlucHV0IC0gd2Vla2RheSwgJ2QnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTZXRJU09EYXlPZldlZWsoaW5wdXQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0ICE9IG51bGwgPyB0aGlzIDogTmFOO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYmVoYXZlcyB0aGUgc2FtZSBhcyBtb21lbnQjZGF5IGV4Y2VwdFxuICAgICAgICAvLyBhcyBhIGdldHRlciwgcmV0dXJucyA3IGluc3RlYWQgb2YgMCAoMS03IHJhbmdlIGluc3RlYWQgb2YgMC02KVxuICAgICAgICAvLyBhcyBhIHNldHRlciwgc3VuZGF5IHNob3VsZCBiZWxvbmcgdG8gdGhlIHByZXZpb3VzIHdlZWsuXG5cbiAgICAgICAgaWYgKGlucHV0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHZhciB3ZWVrZGF5ID0gcGFyc2VJc29XZWVrZGF5KGlucHV0LCB0aGlzLmxvY2FsZURhdGEoKSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXkodGhpcy5kYXkoKSAlIDcgPyB3ZWVrZGF5IDogd2Vla2RheSAtIDcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF5KCkgfHwgNztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHdlZWtkYXlzUmVnZXgoaXNTdHJpY3QpIHtcbiAgICAgICAgaWYgKHRoaXMuX3dlZWtkYXlzUGFyc2VFeGFjdCkge1xuICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfd2Vla2RheXNSZWdleCcpKSB7XG4gICAgICAgICAgICAgICAgY29tcHV0ZVdlZWtkYXlzUGFyc2UuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1N0cmljdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c1N0cmljdFJlZ2V4O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNSZWdleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX3dlZWtkYXlzUmVnZXgnKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzUmVnZXggPSBkZWZhdWx0V2Vla2RheXNSZWdleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c1N0cmljdFJlZ2V4ICYmIGlzU3RyaWN0XG4gICAgICAgICAgICAgICAgPyB0aGlzLl93ZWVrZGF5c1N0cmljdFJlZ2V4XG4gICAgICAgICAgICAgICAgOiB0aGlzLl93ZWVrZGF5c1JlZ2V4O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gd2Vla2RheXNTaG9ydFJlZ2V4KGlzU3RyaWN0KSB7XG4gICAgICAgIGlmICh0aGlzLl93ZWVrZGF5c1BhcnNlRXhhY3QpIHtcbiAgICAgICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX3dlZWtkYXlzUmVnZXgnKSkge1xuICAgICAgICAgICAgICAgIGNvbXB1dGVXZWVrZGF5c1BhcnNlLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNTdHJpY3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNTaG9ydFN0cmljdFJlZ2V4O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNTaG9ydFJlZ2V4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfd2Vla2RheXNTaG9ydFJlZ2V4JykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1Nob3J0UmVnZXggPSBkZWZhdWx0V2Vla2RheXNTaG9ydFJlZ2V4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzU2hvcnRTdHJpY3RSZWdleCAmJiBpc1N0cmljdFxuICAgICAgICAgICAgICAgID8gdGhpcy5fd2Vla2RheXNTaG9ydFN0cmljdFJlZ2V4XG4gICAgICAgICAgICAgICAgOiB0aGlzLl93ZWVrZGF5c1Nob3J0UmVnZXg7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB3ZWVrZGF5c01pblJlZ2V4KGlzU3RyaWN0KSB7XG4gICAgICAgIGlmICh0aGlzLl93ZWVrZGF5c1BhcnNlRXhhY3QpIHtcbiAgICAgICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX3dlZWtkYXlzUmVnZXgnKSkge1xuICAgICAgICAgICAgICAgIGNvbXB1dGVXZWVrZGF5c1BhcnNlLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNTdHJpY3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNNaW5TdHJpY3RSZWdleDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzTWluUmVnZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ193ZWVrZGF5c01pblJlZ2V4JykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl93ZWVrZGF5c01pblJlZ2V4ID0gZGVmYXVsdFdlZWtkYXlzTWluUmVnZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNNaW5TdHJpY3RSZWdleCAmJiBpc1N0cmljdFxuICAgICAgICAgICAgICAgID8gdGhpcy5fd2Vla2RheXNNaW5TdHJpY3RSZWdleFxuICAgICAgICAgICAgICAgIDogdGhpcy5fd2Vla2RheXNNaW5SZWdleDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbXB1dGVXZWVrZGF5c1BhcnNlKCkge1xuICAgICAgICBmdW5jdGlvbiBjbXBMZW5SZXYoYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIGIubGVuZ3RoIC0gYS5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbWluUGllY2VzID0gW10sXG4gICAgICAgICAgICBzaG9ydFBpZWNlcyA9IFtdLFxuICAgICAgICAgICAgbG9uZ1BpZWNlcyA9IFtdLFxuICAgICAgICAgICAgbWl4ZWRQaWVjZXMgPSBbXSxcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICBtb20sXG4gICAgICAgICAgICBtaW5wLFxuICAgICAgICAgICAgc2hvcnRwLFxuICAgICAgICAgICAgbG9uZ3A7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCA3OyBpKyspIHtcbiAgICAgICAgICAgIC8vIG1ha2UgdGhlIHJlZ2V4IGlmIHdlIGRvbid0IGhhdmUgaXQgYWxyZWFkeVxuICAgICAgICAgICAgbW9tID0gY3JlYXRlVVRDKFsyMDAwLCAxXSkuZGF5KGkpO1xuICAgICAgICAgICAgbWlucCA9IHJlZ2V4RXNjYXBlKHRoaXMud2Vla2RheXNNaW4obW9tLCAnJykpO1xuICAgICAgICAgICAgc2hvcnRwID0gcmVnZXhFc2NhcGUodGhpcy53ZWVrZGF5c1Nob3J0KG1vbSwgJycpKTtcbiAgICAgICAgICAgIGxvbmdwID0gcmVnZXhFc2NhcGUodGhpcy53ZWVrZGF5cyhtb20sICcnKSk7XG4gICAgICAgICAgICBtaW5QaWVjZXMucHVzaChtaW5wKTtcbiAgICAgICAgICAgIHNob3J0UGllY2VzLnB1c2goc2hvcnRwKTtcbiAgICAgICAgICAgIGxvbmdQaWVjZXMucHVzaChsb25ncCk7XG4gICAgICAgICAgICBtaXhlZFBpZWNlcy5wdXNoKG1pbnApO1xuICAgICAgICAgICAgbWl4ZWRQaWVjZXMucHVzaChzaG9ydHApO1xuICAgICAgICAgICAgbWl4ZWRQaWVjZXMucHVzaChsb25ncCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU29ydGluZyBtYWtlcyBzdXJlIGlmIG9uZSB3ZWVrZGF5IChvciBhYmJyKSBpcyBhIHByZWZpeCBvZiBhbm90aGVyIGl0XG4gICAgICAgIC8vIHdpbGwgbWF0Y2ggdGhlIGxvbmdlciBwaWVjZS5cbiAgICAgICAgbWluUGllY2VzLnNvcnQoY21wTGVuUmV2KTtcbiAgICAgICAgc2hvcnRQaWVjZXMuc29ydChjbXBMZW5SZXYpO1xuICAgICAgICBsb25nUGllY2VzLnNvcnQoY21wTGVuUmV2KTtcbiAgICAgICAgbWl4ZWRQaWVjZXMuc29ydChjbXBMZW5SZXYpO1xuXG4gICAgICAgIHRoaXMuX3dlZWtkYXlzUmVnZXggPSBuZXcgUmVnRXhwKCdeKCcgKyBtaXhlZFBpZWNlcy5qb2luKCd8JykgKyAnKScsICdpJyk7XG4gICAgICAgIHRoaXMuX3dlZWtkYXlzU2hvcnRSZWdleCA9IHRoaXMuX3dlZWtkYXlzUmVnZXg7XG4gICAgICAgIHRoaXMuX3dlZWtkYXlzTWluUmVnZXggPSB0aGlzLl93ZWVrZGF5c1JlZ2V4O1xuXG4gICAgICAgIHRoaXMuX3dlZWtkYXlzU3RyaWN0UmVnZXggPSBuZXcgUmVnRXhwKFxuICAgICAgICAgICAgJ14oJyArIGxvbmdQaWVjZXMuam9pbignfCcpICsgJyknLFxuICAgICAgICAgICAgJ2knXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuX3dlZWtkYXlzU2hvcnRTdHJpY3RSZWdleCA9IG5ldyBSZWdFeHAoXG4gICAgICAgICAgICAnXignICsgc2hvcnRQaWVjZXMuam9pbignfCcpICsgJyknLFxuICAgICAgICAgICAgJ2knXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuX3dlZWtkYXlzTWluU3RyaWN0UmVnZXggPSBuZXcgUmVnRXhwKFxuICAgICAgICAgICAgJ14oJyArIG1pblBpZWNlcy5qb2luKCd8JykgKyAnKScsXG4gICAgICAgICAgICAnaSdcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBmdW5jdGlvbiBoRm9ybWF0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ob3VycygpICUgMTIgfHwgMTI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24ga0Zvcm1hdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaG91cnMoKSB8fCAyNDtcbiAgICB9XG5cbiAgICBhZGRGb3JtYXRUb2tlbignSCcsIFsnSEgnLCAyXSwgMCwgJ2hvdXInKTtcbiAgICBhZGRGb3JtYXRUb2tlbignaCcsIFsnaGgnLCAyXSwgMCwgaEZvcm1hdCk7XG4gICAgYWRkRm9ybWF0VG9rZW4oJ2snLCBbJ2trJywgMl0sIDAsIGtGb3JtYXQpO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ2htbScsIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICcnICsgaEZvcm1hdC5hcHBseSh0aGlzKSArIHplcm9GaWxsKHRoaXMubWludXRlcygpLCAyKTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdobW1zcycsIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICcnICtcbiAgICAgICAgICAgIGhGb3JtYXQuYXBwbHkodGhpcykgK1xuICAgICAgICAgICAgemVyb0ZpbGwodGhpcy5taW51dGVzKCksIDIpICtcbiAgICAgICAgICAgIHplcm9GaWxsKHRoaXMuc2Vjb25kcygpLCAyKVxuICAgICAgICApO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ0htbScsIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICcnICsgdGhpcy5ob3VycygpICsgemVyb0ZpbGwodGhpcy5taW51dGVzKCksIDIpO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ0htbXNzJywgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgJycgK1xuICAgICAgICAgICAgdGhpcy5ob3VycygpICtcbiAgICAgICAgICAgIHplcm9GaWxsKHRoaXMubWludXRlcygpLCAyKSArXG4gICAgICAgICAgICB6ZXJvRmlsbCh0aGlzLnNlY29uZHMoKSwgMilcbiAgICAgICAgKTtcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIG1lcmlkaWVtKHRva2VuLCBsb3dlcmNhc2UpIHtcbiAgICAgICAgYWRkRm9ybWF0VG9rZW4odG9rZW4sIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5tZXJpZGllbShcbiAgICAgICAgICAgICAgICB0aGlzLmhvdXJzKCksXG4gICAgICAgICAgICAgICAgdGhpcy5taW51dGVzKCksXG4gICAgICAgICAgICAgICAgbG93ZXJjYXNlXG4gICAgICAgICAgICApO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBtZXJpZGllbSgnYScsIHRydWUpO1xuICAgIG1lcmlkaWVtKCdBJywgZmFsc2UpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCdob3VyJywgJ2gnKTtcblxuICAgIC8vIFBSSU9SSVRZXG4gICAgYWRkVW5pdFByaW9yaXR5KCdob3VyJywgMTMpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgZnVuY3Rpb24gbWF0Y2hNZXJpZGllbShpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGUuX21lcmlkaWVtUGFyc2U7XG4gICAgfVxuXG4gICAgYWRkUmVnZXhUb2tlbignYScsIG1hdGNoTWVyaWRpZW0pO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0EnLCBtYXRjaE1lcmlkaWVtKTtcbiAgICBhZGRSZWdleFRva2VuKCdIJywgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdoJywgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdrJywgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdISCcsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdoaCcsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdraycsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ2htbScsIG1hdGNoM3RvNCk7XG4gICAgYWRkUmVnZXhUb2tlbignaG1tc3MnLCBtYXRjaDV0bzYpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0htbScsIG1hdGNoM3RvNCk7XG4gICAgYWRkUmVnZXhUb2tlbignSG1tc3MnLCBtYXRjaDV0bzYpO1xuXG4gICAgYWRkUGFyc2VUb2tlbihbJ0gnLCAnSEgnXSwgSE9VUik7XG4gICAgYWRkUGFyc2VUb2tlbihbJ2snLCAna2snXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIHZhciBrSW5wdXQgPSB0b0ludChpbnB1dCk7XG4gICAgICAgIGFycmF5W0hPVVJdID0ga0lucHV0ID09PSAyNCA/IDAgOiBrSW5wdXQ7XG4gICAgfSk7XG4gICAgYWRkUGFyc2VUb2tlbihbJ2EnLCAnQSddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgY29uZmlnLl9pc1BtID0gY29uZmlnLl9sb2NhbGUuaXNQTShpbnB1dCk7XG4gICAgICAgIGNvbmZpZy5fbWVyaWRpZW0gPSBpbnB1dDtcbiAgICB9KTtcbiAgICBhZGRQYXJzZVRva2VuKFsnaCcsICdoaCddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgYXJyYXlbSE9VUl0gPSB0b0ludChpbnB1dCk7XG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmJpZ0hvdXIgPSB0cnVlO1xuICAgIH0pO1xuICAgIGFkZFBhcnNlVG9rZW4oJ2htbScsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICB2YXIgcG9zID0gaW5wdXQubGVuZ3RoIC0gMjtcbiAgICAgICAgYXJyYXlbSE9VUl0gPSB0b0ludChpbnB1dC5zdWJzdHIoMCwgcG9zKSk7XG4gICAgICAgIGFycmF5W01JTlVURV0gPSB0b0ludChpbnB1dC5zdWJzdHIocG9zKSk7XG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmJpZ0hvdXIgPSB0cnVlO1xuICAgIH0pO1xuICAgIGFkZFBhcnNlVG9rZW4oJ2htbXNzJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIHZhciBwb3MxID0gaW5wdXQubGVuZ3RoIC0gNCxcbiAgICAgICAgICAgIHBvczIgPSBpbnB1dC5sZW5ndGggLSAyO1xuICAgICAgICBhcnJheVtIT1VSXSA9IHRvSW50KGlucHV0LnN1YnN0cigwLCBwb3MxKSk7XG4gICAgICAgIGFycmF5W01JTlVURV0gPSB0b0ludChpbnB1dC5zdWJzdHIocG9zMSwgMikpO1xuICAgICAgICBhcnJheVtTRUNPTkRdID0gdG9JbnQoaW5wdXQuc3Vic3RyKHBvczIpKTtcbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuYmlnSG91ciA9IHRydWU7XG4gICAgfSk7XG4gICAgYWRkUGFyc2VUb2tlbignSG1tJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIHZhciBwb3MgPSBpbnB1dC5sZW5ndGggLSAyO1xuICAgICAgICBhcnJheVtIT1VSXSA9IHRvSW50KGlucHV0LnN1YnN0cigwLCBwb3MpKTtcbiAgICAgICAgYXJyYXlbTUlOVVRFXSA9IHRvSW50KGlucHV0LnN1YnN0cihwb3MpKTtcbiAgICB9KTtcbiAgICBhZGRQYXJzZVRva2VuKCdIbW1zcycsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICB2YXIgcG9zMSA9IGlucHV0Lmxlbmd0aCAtIDQsXG4gICAgICAgICAgICBwb3MyID0gaW5wdXQubGVuZ3RoIC0gMjtcbiAgICAgICAgYXJyYXlbSE9VUl0gPSB0b0ludChpbnB1dC5zdWJzdHIoMCwgcG9zMSkpO1xuICAgICAgICBhcnJheVtNSU5VVEVdID0gdG9JbnQoaW5wdXQuc3Vic3RyKHBvczEsIDIpKTtcbiAgICAgICAgYXJyYXlbU0VDT05EXSA9IHRvSW50KGlucHV0LnN1YnN0cihwb3MyKSk7XG4gICAgfSk7XG5cbiAgICAvLyBMT0NBTEVTXG5cbiAgICBmdW5jdGlvbiBsb2NhbGVJc1BNKGlucHV0KSB7XG4gICAgICAgIC8vIElFOCBRdWlya3MgTW9kZSAmIElFNyBTdGFuZGFyZHMgTW9kZSBkbyBub3QgYWxsb3cgYWNjZXNzaW5nIHN0cmluZ3MgbGlrZSBhcnJheXNcbiAgICAgICAgLy8gVXNpbmcgY2hhckF0IHNob3VsZCBiZSBtb3JlIGNvbXBhdGlibGUuXG4gICAgICAgIHJldHVybiAoaW5wdXQgKyAnJykudG9Mb3dlckNhc2UoKS5jaGFyQXQoMCkgPT09ICdwJztcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdExvY2FsZU1lcmlkaWVtUGFyc2UgPSAvW2FwXVxcLj9tP1xcLj8vaSxcbiAgICAgICAgLy8gU2V0dGluZyB0aGUgaG91ciBzaG91bGQga2VlcCB0aGUgdGltZSwgYmVjYXVzZSB0aGUgdXNlciBleHBsaWNpdGx5XG4gICAgICAgIC8vIHNwZWNpZmllZCB3aGljaCBob3VyIHRoZXkgd2FudC4gU28gdHJ5aW5nIHRvIG1haW50YWluIHRoZSBzYW1lIGhvdXIgKGluXG4gICAgICAgIC8vIGEgbmV3IHRpbWV6b25lKSBtYWtlcyBzZW5zZS4gQWRkaW5nL3N1YnRyYWN0aW5nIGhvdXJzIGRvZXMgbm90IGZvbGxvd1xuICAgICAgICAvLyB0aGlzIHJ1bGUuXG4gICAgICAgIGdldFNldEhvdXIgPSBtYWtlR2V0U2V0KCdIb3VycycsIHRydWUpO1xuXG4gICAgZnVuY3Rpb24gbG9jYWxlTWVyaWRpZW0oaG91cnMsIG1pbnV0ZXMsIGlzTG93ZXIpIHtcbiAgICAgICAgaWYgKGhvdXJzID4gMTEpIHtcbiAgICAgICAgICAgIHJldHVybiBpc0xvd2VyID8gJ3BtJyA6ICdQTSc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gaXNMb3dlciA/ICdhbScgOiAnQU0nO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGJhc2VDb25maWcgPSB7XG4gICAgICAgIGNhbGVuZGFyOiBkZWZhdWx0Q2FsZW5kYXIsXG4gICAgICAgIGxvbmdEYXRlRm9ybWF0OiBkZWZhdWx0TG9uZ0RhdGVGb3JtYXQsXG4gICAgICAgIGludmFsaWREYXRlOiBkZWZhdWx0SW52YWxpZERhdGUsXG4gICAgICAgIG9yZGluYWw6IGRlZmF1bHRPcmRpbmFsLFxuICAgICAgICBkYXlPZk1vbnRoT3JkaW5hbFBhcnNlOiBkZWZhdWx0RGF5T2ZNb250aE9yZGluYWxQYXJzZSxcbiAgICAgICAgcmVsYXRpdmVUaW1lOiBkZWZhdWx0UmVsYXRpdmVUaW1lLFxuXG4gICAgICAgIG1vbnRoczogZGVmYXVsdExvY2FsZU1vbnRocyxcbiAgICAgICAgbW9udGhzU2hvcnQ6IGRlZmF1bHRMb2NhbGVNb250aHNTaG9ydCxcblxuICAgICAgICB3ZWVrOiBkZWZhdWx0TG9jYWxlV2VlayxcblxuICAgICAgICB3ZWVrZGF5czogZGVmYXVsdExvY2FsZVdlZWtkYXlzLFxuICAgICAgICB3ZWVrZGF5c01pbjogZGVmYXVsdExvY2FsZVdlZWtkYXlzTWluLFxuICAgICAgICB3ZWVrZGF5c1Nob3J0OiBkZWZhdWx0TG9jYWxlV2Vla2RheXNTaG9ydCxcblxuICAgICAgICBtZXJpZGllbVBhcnNlOiBkZWZhdWx0TG9jYWxlTWVyaWRpZW1QYXJzZSxcbiAgICB9O1xuXG4gICAgLy8gaW50ZXJuYWwgc3RvcmFnZSBmb3IgbG9jYWxlIGNvbmZpZyBmaWxlc1xuICAgIHZhciBsb2NhbGVzID0ge30sXG4gICAgICAgIGxvY2FsZUZhbWlsaWVzID0ge30sXG4gICAgICAgIGdsb2JhbExvY2FsZTtcblxuICAgIGZ1bmN0aW9uIGNvbW1vblByZWZpeChhcnIxLCBhcnIyKSB7XG4gICAgICAgIHZhciBpLFxuICAgICAgICAgICAgbWlubCA9IE1hdGgubWluKGFycjEubGVuZ3RoLCBhcnIyLmxlbmd0aCk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBtaW5sOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGlmIChhcnIxW2ldICE9PSBhcnIyW2ldKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1pbmw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbm9ybWFsaXplTG9jYWxlKGtleSkge1xuICAgICAgICByZXR1cm4ga2V5ID8ga2V5LnRvTG93ZXJDYXNlKCkucmVwbGFjZSgnXycsICctJykgOiBrZXk7XG4gICAgfVxuXG4gICAgLy8gcGljayB0aGUgbG9jYWxlIGZyb20gdGhlIGFycmF5XG4gICAgLy8gdHJ5IFsnZW4tYXUnLCAnZW4tZ2InXSBhcyAnZW4tYXUnLCAnZW4tZ2InLCAnZW4nLCBhcyBpbiBtb3ZlIHRocm91Z2ggdGhlIGxpc3QgdHJ5aW5nIGVhY2hcbiAgICAvLyBzdWJzdHJpbmcgZnJvbSBtb3N0IHNwZWNpZmljIHRvIGxlYXN0LCBidXQgbW92ZSB0byB0aGUgbmV4dCBhcnJheSBpdGVtIGlmIGl0J3MgYSBtb3JlIHNwZWNpZmljIHZhcmlhbnQgdGhhbiB0aGUgY3VycmVudCByb290XG4gICAgZnVuY3Rpb24gY2hvb3NlTG9jYWxlKG5hbWVzKSB7XG4gICAgICAgIHZhciBpID0gMCxcbiAgICAgICAgICAgIGosXG4gICAgICAgICAgICBuZXh0LFxuICAgICAgICAgICAgbG9jYWxlLFxuICAgICAgICAgICAgc3BsaXQ7XG5cbiAgICAgICAgd2hpbGUgKGkgPCBuYW1lcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHNwbGl0ID0gbm9ybWFsaXplTG9jYWxlKG5hbWVzW2ldKS5zcGxpdCgnLScpO1xuICAgICAgICAgICAgaiA9IHNwbGl0Lmxlbmd0aDtcbiAgICAgICAgICAgIG5leHQgPSBub3JtYWxpemVMb2NhbGUobmFtZXNbaSArIDFdKTtcbiAgICAgICAgICAgIG5leHQgPSBuZXh0ID8gbmV4dC5zcGxpdCgnLScpIDogbnVsbDtcbiAgICAgICAgICAgIHdoaWxlIChqID4gMCkge1xuICAgICAgICAgICAgICAgIGxvY2FsZSA9IGxvYWRMb2NhbGUoc3BsaXQuc2xpY2UoMCwgaikuam9pbignLScpKTtcbiAgICAgICAgICAgICAgICBpZiAobG9jYWxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBsb2NhbGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgbmV4dCAmJlxuICAgICAgICAgICAgICAgICAgICBuZXh0Lmxlbmd0aCA+PSBqICYmXG4gICAgICAgICAgICAgICAgICAgIGNvbW1vblByZWZpeChzcGxpdCwgbmV4dCkgPj0gaiAtIDFcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgLy90aGUgbmV4dCBhcnJheSBpdGVtIGlzIGJldHRlciB0aGFuIGEgc2hhbGxvd2VyIHN1YnN0cmluZyBvZiB0aGlzIG9uZVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgai0tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBnbG9iYWxMb2NhbGU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9hZExvY2FsZShuYW1lKSB7XG4gICAgICAgIHZhciBvbGRMb2NhbGUgPSBudWxsLFxuICAgICAgICAgICAgYWxpYXNlZFJlcXVpcmU7XG4gICAgICAgIC8vIFRPRE86IEZpbmQgYSBiZXR0ZXIgd2F5IHRvIHJlZ2lzdGVyIGFuZCBsb2FkIGFsbCB0aGUgbG9jYWxlcyBpbiBOb2RlXG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIGxvY2FsZXNbbmFtZV0gPT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgIG1vZHVsZSAmJlxuICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHNcbiAgICAgICAgKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIG9sZExvY2FsZSA9IGdsb2JhbExvY2FsZS5fYWJicjtcbiAgICAgICAgICAgICAgICBhbGlhc2VkUmVxdWlyZSA9IHJlcXVpcmU7XG4gICAgICAgICAgICAgICAgYWxpYXNlZFJlcXVpcmUoJy4vbG9jYWxlLycgKyBuYW1lKTtcbiAgICAgICAgICAgICAgICBnZXRTZXRHbG9iYWxMb2NhbGUob2xkTG9jYWxlKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAvLyBtYXJrIGFzIG5vdCBmb3VuZCB0byBhdm9pZCByZXBlYXRpbmcgZXhwZW5zaXZlIGZpbGUgcmVxdWlyZSBjYWxsIGNhdXNpbmcgaGlnaCBDUFVcbiAgICAgICAgICAgICAgICAvLyB3aGVuIHRyeWluZyB0byBmaW5kIGVuLVVTLCBlbl9VUywgZW4tdXMgZm9yIGV2ZXJ5IGZvcm1hdCBjYWxsXG4gICAgICAgICAgICAgICAgbG9jYWxlc1tuYW1lXSA9IG51bGw7IC8vIG51bGwgbWVhbnMgbm90IGZvdW5kXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxvY2FsZXNbbmFtZV07XG4gICAgfVxuXG4gICAgLy8gVGhpcyBmdW5jdGlvbiB3aWxsIGxvYWQgbG9jYWxlIGFuZCB0aGVuIHNldCB0aGUgZ2xvYmFsIGxvY2FsZS4gIElmXG4gICAgLy8gbm8gYXJndW1lbnRzIGFyZSBwYXNzZWQgaW4sIGl0IHdpbGwgc2ltcGx5IHJldHVybiB0aGUgY3VycmVudCBnbG9iYWxcbiAgICAvLyBsb2NhbGUga2V5LlxuICAgIGZ1bmN0aW9uIGdldFNldEdsb2JhbExvY2FsZShrZXksIHZhbHVlcykge1xuICAgICAgICB2YXIgZGF0YTtcbiAgICAgICAgaWYgKGtleSkge1xuICAgICAgICAgICAgaWYgKGlzVW5kZWZpbmVkKHZhbHVlcykpIHtcbiAgICAgICAgICAgICAgICBkYXRhID0gZ2V0TG9jYWxlKGtleSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRhdGEgPSBkZWZpbmVMb2NhbGUoa2V5LCB2YWx1ZXMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgICAgICAgIC8vIG1vbWVudC5kdXJhdGlvbi5fbG9jYWxlID0gbW9tZW50Ll9sb2NhbGUgPSBkYXRhO1xuICAgICAgICAgICAgICAgIGdsb2JhbExvY2FsZSA9IGRhdGE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiYgY29uc29sZS53YXJuKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vd2FybiB1c2VyIGlmIGFyZ3VtZW50cyBhcmUgcGFzc2VkIGJ1dCB0aGUgbG9jYWxlIGNvdWxkIG5vdCBiZSBzZXRcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0xvY2FsZSAnICsga2V5ICsgJyBub3QgZm91bmQuIERpZCB5b3UgZm9yZ2V0IHRvIGxvYWQgaXQ/J1xuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBnbG9iYWxMb2NhbGUuX2FiYnI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGVmaW5lTG9jYWxlKG5hbWUsIGNvbmZpZykge1xuICAgICAgICBpZiAoY29uZmlnICE9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgbG9jYWxlLFxuICAgICAgICAgICAgICAgIHBhcmVudENvbmZpZyA9IGJhc2VDb25maWc7XG4gICAgICAgICAgICBjb25maWcuYWJiciA9IG5hbWU7XG4gICAgICAgICAgICBpZiAobG9jYWxlc1tuYW1lXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZGVwcmVjYXRlU2ltcGxlKFxuICAgICAgICAgICAgICAgICAgICAnZGVmaW5lTG9jYWxlT3ZlcnJpZGUnLFxuICAgICAgICAgICAgICAgICAgICAndXNlIG1vbWVudC51cGRhdGVMb2NhbGUobG9jYWxlTmFtZSwgY29uZmlnKSB0byBjaGFuZ2UgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnYW4gZXhpc3RpbmcgbG9jYWxlLiBtb21lbnQuZGVmaW5lTG9jYWxlKGxvY2FsZU5hbWUsICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2NvbmZpZykgc2hvdWxkIG9ubHkgYmUgdXNlZCBmb3IgY3JlYXRpbmcgYSBuZXcgbG9jYWxlICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ1NlZSBodHRwOi8vbW9tZW50anMuY29tL2d1aWRlcy8jL3dhcm5pbmdzL2RlZmluZS1sb2NhbGUvIGZvciBtb3JlIGluZm8uJ1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgcGFyZW50Q29uZmlnID0gbG9jYWxlc1tuYW1lXS5fY29uZmlnO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjb25maWcucGFyZW50TG9jYWxlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAobG9jYWxlc1tjb25maWcucGFyZW50TG9jYWxlXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmVudENvbmZpZyA9IGxvY2FsZXNbY29uZmlnLnBhcmVudExvY2FsZV0uX2NvbmZpZztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsb2NhbGUgPSBsb2FkTG9jYWxlKGNvbmZpZy5wYXJlbnRMb2NhbGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobG9jYWxlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudENvbmZpZyA9IGxvY2FsZS5fY29uZmlnO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFsb2NhbGVGYW1pbGllc1tjb25maWcucGFyZW50TG9jYWxlXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsZUZhbWlsaWVzW2NvbmZpZy5wYXJlbnRMb2NhbGVdID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhbGVGYW1pbGllc1tjb25maWcucGFyZW50TG9jYWxlXS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZzogY29uZmlnLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvY2FsZXNbbmFtZV0gPSBuZXcgTG9jYWxlKG1lcmdlQ29uZmlncyhwYXJlbnRDb25maWcsIGNvbmZpZykpO1xuXG4gICAgICAgICAgICBpZiAobG9jYWxlRmFtaWxpZXNbbmFtZV0pIHtcbiAgICAgICAgICAgICAgICBsb2NhbGVGYW1pbGllc1tuYW1lXS5mb3JFYWNoKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICAgICAgICAgIGRlZmluZUxvY2FsZSh4Lm5hbWUsIHguY29uZmlnKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gYmFja3dhcmRzIGNvbXBhdCBmb3Igbm93OiBhbHNvIHNldCB0aGUgbG9jYWxlXG4gICAgICAgICAgICAvLyBtYWtlIHN1cmUgd2Ugc2V0IHRoZSBsb2NhbGUgQUZURVIgYWxsIGNoaWxkIGxvY2FsZXMgaGF2ZSBiZWVuXG4gICAgICAgICAgICAvLyBjcmVhdGVkLCBzbyB3ZSB3b24ndCBlbmQgdXAgd2l0aCB0aGUgY2hpbGQgbG9jYWxlIHNldC5cbiAgICAgICAgICAgIGdldFNldEdsb2JhbExvY2FsZShuYW1lKTtcblxuICAgICAgICAgICAgcmV0dXJuIGxvY2FsZXNbbmFtZV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyB1c2VmdWwgZm9yIHRlc3RpbmdcbiAgICAgICAgICAgIGRlbGV0ZSBsb2NhbGVzW25hbWVdO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1cGRhdGVMb2NhbGUobmFtZSwgY29uZmlnKSB7XG4gICAgICAgIGlmIChjb25maWcgIT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIGxvY2FsZSxcbiAgICAgICAgICAgICAgICB0bXBMb2NhbGUsXG4gICAgICAgICAgICAgICAgcGFyZW50Q29uZmlnID0gYmFzZUNvbmZpZztcblxuICAgICAgICAgICAgaWYgKGxvY2FsZXNbbmFtZV0gIT0gbnVsbCAmJiBsb2NhbGVzW25hbWVdLnBhcmVudExvY2FsZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIGV4aXN0aW5nIGNoaWxkIGxvY2FsZSBpbi1wbGFjZSB0byBhdm9pZCBtZW1vcnktbGVha3NcbiAgICAgICAgICAgICAgICBsb2NhbGVzW25hbWVdLnNldChtZXJnZUNvbmZpZ3MobG9jYWxlc1tuYW1lXS5fY29uZmlnLCBjb25maWcpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gTUVSR0VcbiAgICAgICAgICAgICAgICB0bXBMb2NhbGUgPSBsb2FkTG9jYWxlKG5hbWUpO1xuICAgICAgICAgICAgICAgIGlmICh0bXBMb2NhbGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnRDb25maWcgPSB0bXBMb2NhbGUuX2NvbmZpZztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uZmlnID0gbWVyZ2VDb25maWdzKHBhcmVudENvbmZpZywgY29uZmlnKTtcbiAgICAgICAgICAgICAgICBpZiAodG1wTG9jYWxlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdXBkYXRlTG9jYWxlIGlzIGNhbGxlZCBmb3IgY3JlYXRpbmcgYSBuZXcgbG9jYWxlXG4gICAgICAgICAgICAgICAgICAgIC8vIFNldCBhYmJyIHNvIGl0IHdpbGwgaGF2ZSBhIG5hbWUgKGdldHRlcnMgcmV0dXJuXG4gICAgICAgICAgICAgICAgICAgIC8vIHVuZGVmaW5lZCBvdGhlcndpc2UpLlxuICAgICAgICAgICAgICAgICAgICBjb25maWcuYWJiciA9IG5hbWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxvY2FsZSA9IG5ldyBMb2NhbGUoY29uZmlnKTtcbiAgICAgICAgICAgICAgICBsb2NhbGUucGFyZW50TG9jYWxlID0gbG9jYWxlc1tuYW1lXTtcbiAgICAgICAgICAgICAgICBsb2NhbGVzW25hbWVdID0gbG9jYWxlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBiYWNrd2FyZHMgY29tcGF0IGZvciBub3c6IGFsc28gc2V0IHRoZSBsb2NhbGVcbiAgICAgICAgICAgIGdldFNldEdsb2JhbExvY2FsZShuYW1lKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHBhc3MgbnVsbCBmb3IgY29uZmlnIHRvIHVudXBkYXRlLCB1c2VmdWwgZm9yIHRlc3RzXG4gICAgICAgICAgICBpZiAobG9jYWxlc1tuYW1lXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxvY2FsZXNbbmFtZV0ucGFyZW50TG9jYWxlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxlc1tuYW1lXSA9IGxvY2FsZXNbbmFtZV0ucGFyZW50TG9jYWxlO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmFtZSA9PT0gZ2V0U2V0R2xvYmFsTG9jYWxlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldFNldEdsb2JhbExvY2FsZShuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobG9jYWxlc1tuYW1lXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBsb2NhbGVzW25hbWVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbG9jYWxlc1tuYW1lXTtcbiAgICB9XG5cbiAgICAvLyByZXR1cm5zIGxvY2FsZSBkYXRhXG4gICAgZnVuY3Rpb24gZ2V0TG9jYWxlKGtleSkge1xuICAgICAgICB2YXIgbG9jYWxlO1xuXG4gICAgICAgIGlmIChrZXkgJiYga2V5Ll9sb2NhbGUgJiYga2V5Ll9sb2NhbGUuX2FiYnIpIHtcbiAgICAgICAgICAgIGtleSA9IGtleS5fbG9jYWxlLl9hYmJyO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFrZXkpIHtcbiAgICAgICAgICAgIHJldHVybiBnbG9iYWxMb2NhbGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzQXJyYXkoa2V5KSkge1xuICAgICAgICAgICAgLy9zaG9ydC1jaXJjdWl0IGV2ZXJ5dGhpbmcgZWxzZVxuICAgICAgICAgICAgbG9jYWxlID0gbG9hZExvY2FsZShrZXkpO1xuICAgICAgICAgICAgaWYgKGxvY2FsZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBsb2NhbGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBrZXkgPSBba2V5XTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjaG9vc2VMb2NhbGUoa2V5KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaXN0TG9jYWxlcygpIHtcbiAgICAgICAgcmV0dXJuIGtleXMobG9jYWxlcyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2hlY2tPdmVyZmxvdyhtKSB7XG4gICAgICAgIHZhciBvdmVyZmxvdyxcbiAgICAgICAgICAgIGEgPSBtLl9hO1xuXG4gICAgICAgIGlmIChhICYmIGdldFBhcnNpbmdGbGFncyhtKS5vdmVyZmxvdyA9PT0gLTIpIHtcbiAgICAgICAgICAgIG92ZXJmbG93ID1cbiAgICAgICAgICAgICAgICBhW01PTlRIXSA8IDAgfHwgYVtNT05USF0gPiAxMVxuICAgICAgICAgICAgICAgICAgICA/IE1PTlRIXG4gICAgICAgICAgICAgICAgICAgIDogYVtEQVRFXSA8IDEgfHwgYVtEQVRFXSA+IGRheXNJbk1vbnRoKGFbWUVBUl0sIGFbTU9OVEhdKVxuICAgICAgICAgICAgICAgICAgICA/IERBVEVcbiAgICAgICAgICAgICAgICAgICAgOiBhW0hPVVJdIDwgMCB8fFxuICAgICAgICAgICAgICAgICAgICAgIGFbSE9VUl0gPiAyNCB8fFxuICAgICAgICAgICAgICAgICAgICAgIChhW0hPVVJdID09PSAyNCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAoYVtNSU5VVEVdICE9PSAwIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhW1NFQ09ORF0gIT09IDAgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFbTUlMTElTRUNPTkRdICE9PSAwKSlcbiAgICAgICAgICAgICAgICAgICAgPyBIT1VSXG4gICAgICAgICAgICAgICAgICAgIDogYVtNSU5VVEVdIDwgMCB8fCBhW01JTlVURV0gPiA1OVxuICAgICAgICAgICAgICAgICAgICA/IE1JTlVURVxuICAgICAgICAgICAgICAgICAgICA6IGFbU0VDT05EXSA8IDAgfHwgYVtTRUNPTkRdID4gNTlcbiAgICAgICAgICAgICAgICAgICAgPyBTRUNPTkRcbiAgICAgICAgICAgICAgICAgICAgOiBhW01JTExJU0VDT05EXSA8IDAgfHwgYVtNSUxMSVNFQ09ORF0gPiA5OTlcbiAgICAgICAgICAgICAgICAgICAgPyBNSUxMSVNFQ09ORFxuICAgICAgICAgICAgICAgICAgICA6IC0xO1xuXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKG0pLl9vdmVyZmxvd0RheU9mWWVhciAmJlxuICAgICAgICAgICAgICAgIChvdmVyZmxvdyA8IFlFQVIgfHwgb3ZlcmZsb3cgPiBEQVRFKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgb3ZlcmZsb3cgPSBEQVRFO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdldFBhcnNpbmdGbGFncyhtKS5fb3ZlcmZsb3dXZWVrcyAmJiBvdmVyZmxvdyA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBvdmVyZmxvdyA9IFdFRUs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZ2V0UGFyc2luZ0ZsYWdzKG0pLl9vdmVyZmxvd1dlZWtkYXkgJiYgb3ZlcmZsb3cgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgb3ZlcmZsb3cgPSBXRUVLREFZO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MobSkub3ZlcmZsb3cgPSBvdmVyZmxvdztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtO1xuICAgIH1cblxuICAgIC8vIGlzbyA4NjAxIHJlZ2V4XG4gICAgLy8gMDAwMC0wMC0wMCAwMDAwLVcwMCBvciAwMDAwLVcwMC0wICsgVCArIDAwIG9yIDAwOjAwIG9yIDAwOjAwOjAwIG9yIDAwOjAwOjAwLjAwMCArICswMDowMCBvciArMDAwMCBvciArMDApXG4gICAgdmFyIGV4dGVuZGVkSXNvUmVnZXggPSAvXlxccyooKD86WystXVxcZHs2fXxcXGR7NH0pLSg/OlxcZFxcZC1cXGRcXGR8V1xcZFxcZC1cXGR8V1xcZFxcZHxcXGRcXGRcXGR8XFxkXFxkKSkoPzooVHwgKShcXGRcXGQoPzo6XFxkXFxkKD86OlxcZFxcZCg/OlsuLF1cXGQrKT8pPyk/KShbKy1dXFxkXFxkKD86Oj9cXGRcXGQpP3xcXHMqWik/KT8kLyxcbiAgICAgICAgYmFzaWNJc29SZWdleCA9IC9eXFxzKigoPzpbKy1dXFxkezZ9fFxcZHs0fSkoPzpcXGRcXGRcXGRcXGR8V1xcZFxcZFxcZHxXXFxkXFxkfFxcZFxcZFxcZHxcXGRcXGR8KSkoPzooVHwgKShcXGRcXGQoPzpcXGRcXGQoPzpcXGRcXGQoPzpbLixdXFxkKyk/KT8pPykoWystXVxcZFxcZCg/Ojo/XFxkXFxkKT98XFxzKlopPyk/JC8sXG4gICAgICAgIHR6UmVnZXggPSAvWnxbKy1dXFxkXFxkKD86Oj9cXGRcXGQpPy8sXG4gICAgICAgIGlzb0RhdGVzID0gW1xuICAgICAgICAgICAgWydZWVlZWVktTU0tREQnLCAvWystXVxcZHs2fS1cXGRcXGQtXFxkXFxkL10sXG4gICAgICAgICAgICBbJ1lZWVktTU0tREQnLCAvXFxkezR9LVxcZFxcZC1cXGRcXGQvXSxcbiAgICAgICAgICAgIFsnR0dHRy1bV11XVy1FJywgL1xcZHs0fS1XXFxkXFxkLVxcZC9dLFxuICAgICAgICAgICAgWydHR0dHLVtXXVdXJywgL1xcZHs0fS1XXFxkXFxkLywgZmFsc2VdLFxuICAgICAgICAgICAgWydZWVlZLURERCcsIC9cXGR7NH0tXFxkezN9L10sXG4gICAgICAgICAgICBbJ1lZWVktTU0nLCAvXFxkezR9LVxcZFxcZC8sIGZhbHNlXSxcbiAgICAgICAgICAgIFsnWVlZWVlZTU1ERCcsIC9bKy1dXFxkezEwfS9dLFxuICAgICAgICAgICAgWydZWVlZTU1ERCcsIC9cXGR7OH0vXSxcbiAgICAgICAgICAgIFsnR0dHR1tXXVdXRScsIC9cXGR7NH1XXFxkezN9L10sXG4gICAgICAgICAgICBbJ0dHR0dbV11XVycsIC9cXGR7NH1XXFxkezJ9LywgZmFsc2VdLFxuICAgICAgICAgICAgWydZWVlZREREJywgL1xcZHs3fS9dLFxuICAgICAgICAgICAgWydZWVlZTU0nLCAvXFxkezZ9LywgZmFsc2VdLFxuICAgICAgICAgICAgWydZWVlZJywgL1xcZHs0fS8sIGZhbHNlXSxcbiAgICAgICAgXSxcbiAgICAgICAgLy8gaXNvIHRpbWUgZm9ybWF0cyBhbmQgcmVnZXhlc1xuICAgICAgICBpc29UaW1lcyA9IFtcbiAgICAgICAgICAgIFsnSEg6bW06c3MuU1NTUycsIC9cXGRcXGQ6XFxkXFxkOlxcZFxcZFxcLlxcZCsvXSxcbiAgICAgICAgICAgIFsnSEg6bW06c3MsU1NTUycsIC9cXGRcXGQ6XFxkXFxkOlxcZFxcZCxcXGQrL10sXG4gICAgICAgICAgICBbJ0hIOm1tOnNzJywgL1xcZFxcZDpcXGRcXGQ6XFxkXFxkL10sXG4gICAgICAgICAgICBbJ0hIOm1tJywgL1xcZFxcZDpcXGRcXGQvXSxcbiAgICAgICAgICAgIFsnSEhtbXNzLlNTU1MnLCAvXFxkXFxkXFxkXFxkXFxkXFxkXFwuXFxkKy9dLFxuICAgICAgICAgICAgWydISG1tc3MsU1NTUycsIC9cXGRcXGRcXGRcXGRcXGRcXGQsXFxkKy9dLFxuICAgICAgICAgICAgWydISG1tc3MnLCAvXFxkXFxkXFxkXFxkXFxkXFxkL10sXG4gICAgICAgICAgICBbJ0hIbW0nLCAvXFxkXFxkXFxkXFxkL10sXG4gICAgICAgICAgICBbJ0hIJywgL1xcZFxcZC9dLFxuICAgICAgICBdLFxuICAgICAgICBhc3BOZXRKc29uUmVnZXggPSAvXlxcLz9EYXRlXFwoKC0/XFxkKykvaSxcbiAgICAgICAgLy8gUkZDIDI4MjIgcmVnZXg6IEZvciBkZXRhaWxzIHNlZSBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMjgyMiNzZWN0aW9uLTMuM1xuICAgICAgICByZmMyODIyID0gL14oPzooTW9ufFR1ZXxXZWR8VGh1fEZyaXxTYXR8U3VuKSw/XFxzKT8oXFxkezEsMn0pXFxzKEphbnxGZWJ8TWFyfEFwcnxNYXl8SnVufEp1bHxBdWd8U2VwfE9jdHxOb3Z8RGVjKVxccyhcXGR7Miw0fSlcXHMoXFxkXFxkKTooXFxkXFxkKSg/OjooXFxkXFxkKSk/XFxzKD86KFVUfEdNVHxbRUNNUF1bU0RdVCl8KFtael0pfChbKy1dXFxkezR9KSkkLyxcbiAgICAgICAgb2JzT2Zmc2V0cyA9IHtcbiAgICAgICAgICAgIFVUOiAwLFxuICAgICAgICAgICAgR01UOiAwLFxuICAgICAgICAgICAgRURUOiAtNCAqIDYwLFxuICAgICAgICAgICAgRVNUOiAtNSAqIDYwLFxuICAgICAgICAgICAgQ0RUOiAtNSAqIDYwLFxuICAgICAgICAgICAgQ1NUOiAtNiAqIDYwLFxuICAgICAgICAgICAgTURUOiAtNiAqIDYwLFxuICAgICAgICAgICAgTVNUOiAtNyAqIDYwLFxuICAgICAgICAgICAgUERUOiAtNyAqIDYwLFxuICAgICAgICAgICAgUFNUOiAtOCAqIDYwLFxuICAgICAgICB9O1xuXG4gICAgLy8gZGF0ZSBmcm9tIGlzbyBmb3JtYXRcbiAgICBmdW5jdGlvbiBjb25maWdGcm9tSVNPKGNvbmZpZykge1xuICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgIGwsXG4gICAgICAgICAgICBzdHJpbmcgPSBjb25maWcuX2ksXG4gICAgICAgICAgICBtYXRjaCA9IGV4dGVuZGVkSXNvUmVnZXguZXhlYyhzdHJpbmcpIHx8IGJhc2ljSXNvUmVnZXguZXhlYyhzdHJpbmcpLFxuICAgICAgICAgICAgYWxsb3dUaW1lLFxuICAgICAgICAgICAgZGF0ZUZvcm1hdCxcbiAgICAgICAgICAgIHRpbWVGb3JtYXQsXG4gICAgICAgICAgICB0ekZvcm1hdDtcblxuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmlzbyA9IHRydWU7XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGwgPSBpc29EYXRlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNvRGF0ZXNbaV1bMV0uZXhlYyhtYXRjaFsxXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0ZUZvcm1hdCA9IGlzb0RhdGVzW2ldWzBdO1xuICAgICAgICAgICAgICAgICAgICBhbGxvd1RpbWUgPSBpc29EYXRlc1tpXVsyXSAhPT0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkYXRlRm9ybWF0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb25maWcuX2lzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWF0Y2hbM10pIHtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBsID0gaXNvVGltZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc29UaW1lc1tpXVsxXS5leGVjKG1hdGNoWzNdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWF0Y2hbMl0gc2hvdWxkIGJlICdUJyBvciBzcGFjZVxuICAgICAgICAgICAgICAgICAgICAgICAgdGltZUZvcm1hdCA9IChtYXRjaFsyXSB8fCAnICcpICsgaXNvVGltZXNbaV1bMF07XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGltZUZvcm1hdCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZy5faXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFhbGxvd1RpbWUgJiYgdGltZUZvcm1hdCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29uZmlnLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1hdGNoWzRdKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR6UmVnZXguZXhlYyhtYXRjaFs0XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdHpGb3JtYXQgPSAnWic7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25maWcuX2YgPSBkYXRlRm9ybWF0ICsgKHRpbWVGb3JtYXQgfHwgJycpICsgKHR6Rm9ybWF0IHx8ICcnKTtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21TdHJpbmdBbmRGb3JtYXQoY29uZmlnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbmZpZy5faXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXh0cmFjdEZyb21SRkMyODIyU3RyaW5ncyhcbiAgICAgICAgeWVhclN0cixcbiAgICAgICAgbW9udGhTdHIsXG4gICAgICAgIGRheVN0cixcbiAgICAgICAgaG91clN0cixcbiAgICAgICAgbWludXRlU3RyLFxuICAgICAgICBzZWNvbmRTdHJcbiAgICApIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtcbiAgICAgICAgICAgIHVudHJ1bmNhdGVZZWFyKHllYXJTdHIpLFxuICAgICAgICAgICAgZGVmYXVsdExvY2FsZU1vbnRoc1Nob3J0LmluZGV4T2YobW9udGhTdHIpLFxuICAgICAgICAgICAgcGFyc2VJbnQoZGF5U3RyLCAxMCksXG4gICAgICAgICAgICBwYXJzZUludChob3VyU3RyLCAxMCksXG4gICAgICAgICAgICBwYXJzZUludChtaW51dGVTdHIsIDEwKSxcbiAgICAgICAgXTtcblxuICAgICAgICBpZiAoc2Vjb25kU3RyKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChwYXJzZUludChzZWNvbmRTdHIsIDEwKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVudHJ1bmNhdGVZZWFyKHllYXJTdHIpIHtcbiAgICAgICAgdmFyIHllYXIgPSBwYXJzZUludCh5ZWFyU3RyLCAxMCk7XG4gICAgICAgIGlmICh5ZWFyIDw9IDQ5KSB7XG4gICAgICAgICAgICByZXR1cm4gMjAwMCArIHllYXI7XG4gICAgICAgIH0gZWxzZSBpZiAoeWVhciA8PSA5OTkpIHtcbiAgICAgICAgICAgIHJldHVybiAxOTAwICsgeWVhcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geWVhcjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcmVwcm9jZXNzUkZDMjgyMihzKSB7XG4gICAgICAgIC8vIFJlbW92ZSBjb21tZW50cyBhbmQgZm9sZGluZyB3aGl0ZXNwYWNlIGFuZCByZXBsYWNlIG11bHRpcGxlLXNwYWNlcyB3aXRoIGEgc2luZ2xlIHNwYWNlXG4gICAgICAgIHJldHVybiBzXG4gICAgICAgICAgICAucmVwbGFjZSgvXFwoW14pXSpcXCl8W1xcblxcdF0vZywgJyAnKVxuICAgICAgICAgICAgLnJlcGxhY2UoLyhcXHNcXHMrKS9nLCAnICcpXG4gICAgICAgICAgICAucmVwbGFjZSgvXlxcc1xccyovLCAnJylcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXHNcXHMqJC8sICcnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjaGVja1dlZWtkYXkod2Vla2RheVN0ciwgcGFyc2VkSW5wdXQsIGNvbmZpZykge1xuICAgICAgICBpZiAod2Vla2RheVN0cikge1xuICAgICAgICAgICAgLy8gVE9ETzogUmVwbGFjZSB0aGUgdmFuaWxsYSBKUyBEYXRlIG9iamVjdCB3aXRoIGFuIGluZGVwZW5kZW50IGRheS1vZi13ZWVrIGNoZWNrLlxuICAgICAgICAgICAgdmFyIHdlZWtkYXlQcm92aWRlZCA9IGRlZmF1bHRMb2NhbGVXZWVrZGF5c1Nob3J0LmluZGV4T2Yod2Vla2RheVN0ciksXG4gICAgICAgICAgICAgICAgd2Vla2RheUFjdHVhbCA9IG5ldyBEYXRlKFxuICAgICAgICAgICAgICAgICAgICBwYXJzZWRJbnB1dFswXSxcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VkSW5wdXRbMV0sXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZElucHV0WzJdXG4gICAgICAgICAgICAgICAgKS5nZXREYXkoKTtcbiAgICAgICAgICAgIGlmICh3ZWVrZGF5UHJvdmlkZWQgIT09IHdlZWtkYXlBY3R1YWwpIHtcbiAgICAgICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS53ZWVrZGF5TWlzbWF0Y2ggPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNvbmZpZy5faXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjYWxjdWxhdGVPZmZzZXQob2JzT2Zmc2V0LCBtaWxpdGFyeU9mZnNldCwgbnVtT2Zmc2V0KSB7XG4gICAgICAgIGlmIChvYnNPZmZzZXQpIHtcbiAgICAgICAgICAgIHJldHVybiBvYnNPZmZzZXRzW29ic09mZnNldF07XG4gICAgICAgIH0gZWxzZSBpZiAobWlsaXRhcnlPZmZzZXQpIHtcbiAgICAgICAgICAgIC8vIHRoZSBvbmx5IGFsbG93ZWQgbWlsaXRhcnkgdHogaXMgWlxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgaG0gPSBwYXJzZUludChudW1PZmZzZXQsIDEwKSxcbiAgICAgICAgICAgICAgICBtID0gaG0gJSAxMDAsXG4gICAgICAgICAgICAgICAgaCA9IChobSAtIG0pIC8gMTAwO1xuICAgICAgICAgICAgcmV0dXJuIGggKiA2MCArIG07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBkYXRlIGFuZCB0aW1lIGZyb20gcmVmIDI4MjIgZm9ybWF0XG4gICAgZnVuY3Rpb24gY29uZmlnRnJvbVJGQzI4MjIoY29uZmlnKSB7XG4gICAgICAgIHZhciBtYXRjaCA9IHJmYzI4MjIuZXhlYyhwcmVwcm9jZXNzUkZDMjgyMihjb25maWcuX2kpKSxcbiAgICAgICAgICAgIHBhcnNlZEFycmF5O1xuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIHBhcnNlZEFycmF5ID0gZXh0cmFjdEZyb21SRkMyODIyU3RyaW5ncyhcbiAgICAgICAgICAgICAgICBtYXRjaFs0XSxcbiAgICAgICAgICAgICAgICBtYXRjaFszXSxcbiAgICAgICAgICAgICAgICBtYXRjaFsyXSxcbiAgICAgICAgICAgICAgICBtYXRjaFs1XSxcbiAgICAgICAgICAgICAgICBtYXRjaFs2XSxcbiAgICAgICAgICAgICAgICBtYXRjaFs3XVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmICghY2hlY2tXZWVrZGF5KG1hdGNoWzFdLCBwYXJzZWRBcnJheSwgY29uZmlnKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uZmlnLl9hID0gcGFyc2VkQXJyYXk7XG4gICAgICAgICAgICBjb25maWcuX3R6bSA9IGNhbGN1bGF0ZU9mZnNldChtYXRjaFs4XSwgbWF0Y2hbOV0sIG1hdGNoWzEwXSk7XG5cbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IGNyZWF0ZVVUQ0RhdGUuYXBwbHkobnVsbCwgY29uZmlnLl9hKTtcbiAgICAgICAgICAgIGNvbmZpZy5fZC5zZXRVVENNaW51dGVzKGNvbmZpZy5fZC5nZXRVVENNaW51dGVzKCkgLSBjb25maWcuX3R6bSk7XG5cbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLnJmYzI4MjIgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uZmlnLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBkYXRlIGZyb20gMSkgQVNQLk5FVCwgMikgSVNPLCAzKSBSRkMgMjgyMiBmb3JtYXRzLCBvciA0KSBvcHRpb25hbCBmYWxsYmFjayBpZiBwYXJzaW5nIGlzbid0IHN0cmljdFxuICAgIGZ1bmN0aW9uIGNvbmZpZ0Zyb21TdHJpbmcoY29uZmlnKSB7XG4gICAgICAgIHZhciBtYXRjaGVkID0gYXNwTmV0SnNvblJlZ2V4LmV4ZWMoY29uZmlnLl9pKTtcbiAgICAgICAgaWYgKG1hdGNoZWQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKCttYXRjaGVkWzFdKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbmZpZ0Zyb21JU08oY29uZmlnKTtcbiAgICAgICAgaWYgKGNvbmZpZy5faXNWYWxpZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBjb25maWcuX2lzVmFsaWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25maWdGcm9tUkZDMjgyMihjb25maWcpO1xuICAgICAgICBpZiAoY29uZmlnLl9pc1ZhbGlkID09PSBmYWxzZSkge1xuICAgICAgICAgICAgZGVsZXRlIGNvbmZpZy5faXNWYWxpZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb25maWcuX3N0cmljdCkge1xuICAgICAgICAgICAgY29uZmlnLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBGaW5hbCBhdHRlbXB0LCB1c2UgSW5wdXQgRmFsbGJhY2tcbiAgICAgICAgICAgIGhvb2tzLmNyZWF0ZUZyb21JbnB1dEZhbGxiYWNrKGNvbmZpZyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBob29rcy5jcmVhdGVGcm9tSW5wdXRGYWxsYmFjayA9IGRlcHJlY2F0ZShcbiAgICAgICAgJ3ZhbHVlIHByb3ZpZGVkIGlzIG5vdCBpbiBhIHJlY29nbml6ZWQgUkZDMjgyMiBvciBJU08gZm9ybWF0LiBtb21lbnQgY29uc3RydWN0aW9uIGZhbGxzIGJhY2sgdG8ganMgRGF0ZSgpLCAnICtcbiAgICAgICAgICAgICd3aGljaCBpcyBub3QgcmVsaWFibGUgYWNyb3NzIGFsbCBicm93c2VycyBhbmQgdmVyc2lvbnMuIE5vbiBSRkMyODIyL0lTTyBkYXRlIGZvcm1hdHMgYXJlICcgK1xuICAgICAgICAgICAgJ2Rpc2NvdXJhZ2VkLiBQbGVhc2UgcmVmZXIgdG8gaHR0cDovL21vbWVudGpzLmNvbS9ndWlkZXMvIy93YXJuaW5ncy9qcy1kYXRlLyBmb3IgbW9yZSBpbmZvLicsXG4gICAgICAgIGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKGNvbmZpZy5faSArIChjb25maWcuX3VzZVVUQyA/ICcgVVRDJyA6ICcnKSk7XG4gICAgICAgIH1cbiAgICApO1xuXG4gICAgLy8gUGljayB0aGUgZmlyc3QgZGVmaW5lZCBvZiB0d28gb3IgdGhyZWUgYXJndW1lbnRzLlxuICAgIGZ1bmN0aW9uIGRlZmF1bHRzKGEsIGIsIGMpIHtcbiAgICAgICAgaWYgKGEgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGIgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3VycmVudERhdGVBcnJheShjb25maWcpIHtcbiAgICAgICAgLy8gaG9va3MgaXMgYWN0dWFsbHkgdGhlIGV4cG9ydGVkIG1vbWVudCBvYmplY3RcbiAgICAgICAgdmFyIG5vd1ZhbHVlID0gbmV3IERhdGUoaG9va3Mubm93KCkpO1xuICAgICAgICBpZiAoY29uZmlnLl91c2VVVEMpIHtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgbm93VmFsdWUuZ2V0VVRDRnVsbFllYXIoKSxcbiAgICAgICAgICAgICAgICBub3dWYWx1ZS5nZXRVVENNb250aCgpLFxuICAgICAgICAgICAgICAgIG5vd1ZhbHVlLmdldFVUQ0RhdGUoKSxcbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtub3dWYWx1ZS5nZXRGdWxsWWVhcigpLCBub3dWYWx1ZS5nZXRNb250aCgpLCBub3dWYWx1ZS5nZXREYXRlKCldO1xuICAgIH1cblxuICAgIC8vIGNvbnZlcnQgYW4gYXJyYXkgdG8gYSBkYXRlLlxuICAgIC8vIHRoZSBhcnJheSBzaG91bGQgbWlycm9yIHRoZSBwYXJhbWV0ZXJzIGJlbG93XG4gICAgLy8gbm90ZTogYWxsIHZhbHVlcyBwYXN0IHRoZSB5ZWFyIGFyZSBvcHRpb25hbCBhbmQgd2lsbCBkZWZhdWx0IHRvIHRoZSBsb3dlc3QgcG9zc2libGUgdmFsdWUuXG4gICAgLy8gW3llYXIsIG1vbnRoLCBkYXkgLCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmRdXG4gICAgZnVuY3Rpb24gY29uZmlnRnJvbUFycmF5KGNvbmZpZykge1xuICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgIGRhdGUsXG4gICAgICAgICAgICBpbnB1dCA9IFtdLFxuICAgICAgICAgICAgY3VycmVudERhdGUsXG4gICAgICAgICAgICBleHBlY3RlZFdlZWtkYXksXG4gICAgICAgICAgICB5ZWFyVG9Vc2U7XG5cbiAgICAgICAgaWYgKGNvbmZpZy5fZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY3VycmVudERhdGUgPSBjdXJyZW50RGF0ZUFycmF5KGNvbmZpZyk7XG5cbiAgICAgICAgLy9jb21wdXRlIGRheSBvZiB0aGUgeWVhciBmcm9tIHdlZWtzIGFuZCB3ZWVrZGF5c1xuICAgICAgICBpZiAoY29uZmlnLl93ICYmIGNvbmZpZy5fYVtEQVRFXSA9PSBudWxsICYmIGNvbmZpZy5fYVtNT05USF0gPT0gbnVsbCkge1xuICAgICAgICAgICAgZGF5T2ZZZWFyRnJvbVdlZWtJbmZvKGNvbmZpZyk7XG4gICAgICAgIH1cblxuICAgICAgICAvL2lmIHRoZSBkYXkgb2YgdGhlIHllYXIgaXMgc2V0LCBmaWd1cmUgb3V0IHdoYXQgaXQgaXNcbiAgICAgICAgaWYgKGNvbmZpZy5fZGF5T2ZZZWFyICE9IG51bGwpIHtcbiAgICAgICAgICAgIHllYXJUb1VzZSA9IGRlZmF1bHRzKGNvbmZpZy5fYVtZRUFSXSwgY3VycmVudERhdGVbWUVBUl0pO1xuXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgY29uZmlnLl9kYXlPZlllYXIgPiBkYXlzSW5ZZWFyKHllYXJUb1VzZSkgfHxcbiAgICAgICAgICAgICAgICBjb25maWcuX2RheU9mWWVhciA9PT0gMFxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuX292ZXJmbG93RGF5T2ZZZWFyID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZGF0ZSA9IGNyZWF0ZVVUQ0RhdGUoeWVhclRvVXNlLCAwLCBjb25maWcuX2RheU9mWWVhcik7XG4gICAgICAgICAgICBjb25maWcuX2FbTU9OVEhdID0gZGF0ZS5nZXRVVENNb250aCgpO1xuICAgICAgICAgICAgY29uZmlnLl9hW0RBVEVdID0gZGF0ZS5nZXRVVENEYXRlKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZWZhdWx0IHRvIGN1cnJlbnQgZGF0ZS5cbiAgICAgICAgLy8gKiBpZiBubyB5ZWFyLCBtb250aCwgZGF5IG9mIG1vbnRoIGFyZSBnaXZlbiwgZGVmYXVsdCB0byB0b2RheVxuICAgICAgICAvLyAqIGlmIGRheSBvZiBtb250aCBpcyBnaXZlbiwgZGVmYXVsdCBtb250aCBhbmQgeWVhclxuICAgICAgICAvLyAqIGlmIG1vbnRoIGlzIGdpdmVuLCBkZWZhdWx0IG9ubHkgeWVhclxuICAgICAgICAvLyAqIGlmIHllYXIgaXMgZ2l2ZW4sIGRvbid0IGRlZmF1bHQgYW55dGhpbmdcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDMgJiYgY29uZmlnLl9hW2ldID09IG51bGw7ICsraSkge1xuICAgICAgICAgICAgY29uZmlnLl9hW2ldID0gaW5wdXRbaV0gPSBjdXJyZW50RGF0ZVtpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFplcm8gb3V0IHdoYXRldmVyIHdhcyBub3QgZGVmYXVsdGVkLCBpbmNsdWRpbmcgdGltZVxuICAgICAgICBmb3IgKDsgaSA8IDc7IGkrKykge1xuICAgICAgICAgICAgY29uZmlnLl9hW2ldID0gaW5wdXRbaV0gPVxuICAgICAgICAgICAgICAgIGNvbmZpZy5fYVtpXSA9PSBudWxsID8gKGkgPT09IDIgPyAxIDogMCkgOiBjb25maWcuX2FbaV07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDaGVjayBmb3IgMjQ6MDA6MDAuMDAwXG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIGNvbmZpZy5fYVtIT1VSXSA9PT0gMjQgJiZcbiAgICAgICAgICAgIGNvbmZpZy5fYVtNSU5VVEVdID09PSAwICYmXG4gICAgICAgICAgICBjb25maWcuX2FbU0VDT05EXSA9PT0gMCAmJlxuICAgICAgICAgICAgY29uZmlnLl9hW01JTExJU0VDT05EXSA9PT0gMFxuICAgICAgICApIHtcbiAgICAgICAgICAgIGNvbmZpZy5fbmV4dERheSA9IHRydWU7XG4gICAgICAgICAgICBjb25maWcuX2FbSE9VUl0gPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uZmlnLl9kID0gKGNvbmZpZy5fdXNlVVRDID8gY3JlYXRlVVRDRGF0ZSA6IGNyZWF0ZURhdGUpLmFwcGx5KFxuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgIGlucHV0XG4gICAgICAgICk7XG4gICAgICAgIGV4cGVjdGVkV2Vla2RheSA9IGNvbmZpZy5fdXNlVVRDXG4gICAgICAgICAgICA/IGNvbmZpZy5fZC5nZXRVVENEYXkoKVxuICAgICAgICAgICAgOiBjb25maWcuX2QuZ2V0RGF5KCk7XG5cbiAgICAgICAgLy8gQXBwbHkgdGltZXpvbmUgb2Zmc2V0IGZyb20gaW5wdXQuIFRoZSBhY3R1YWwgdXRjT2Zmc2V0IGNhbiBiZSBjaGFuZ2VkXG4gICAgICAgIC8vIHdpdGggcGFyc2Vab25lLlxuICAgICAgICBpZiAoY29uZmlnLl90em0gIT0gbnVsbCkge1xuICAgICAgICAgICAgY29uZmlnLl9kLnNldFVUQ01pbnV0ZXMoY29uZmlnLl9kLmdldFVUQ01pbnV0ZXMoKSAtIGNvbmZpZy5fdHptKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb25maWcuX25leHREYXkpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fYVtIT1VSXSA9IDI0O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY2hlY2sgZm9yIG1pc21hdGNoaW5nIGRheSBvZiB3ZWVrXG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIGNvbmZpZy5fdyAmJlxuICAgICAgICAgICAgdHlwZW9mIGNvbmZpZy5fdy5kICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgY29uZmlnLl93LmQgIT09IGV4cGVjdGVkV2Vla2RheVxuICAgICAgICApIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLndlZWtkYXlNaXNtYXRjaCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkYXlPZlllYXJGcm9tV2Vla0luZm8oY29uZmlnKSB7XG4gICAgICAgIHZhciB3LCB3ZWVrWWVhciwgd2Vlaywgd2Vla2RheSwgZG93LCBkb3ksIHRlbXAsIHdlZWtkYXlPdmVyZmxvdywgY3VyV2VlaztcblxuICAgICAgICB3ID0gY29uZmlnLl93O1xuICAgICAgICBpZiAody5HRyAhPSBudWxsIHx8IHcuVyAhPSBudWxsIHx8IHcuRSAhPSBudWxsKSB7XG4gICAgICAgICAgICBkb3cgPSAxO1xuICAgICAgICAgICAgZG95ID0gNDtcblxuICAgICAgICAgICAgLy8gVE9ETzogV2UgbmVlZCB0byB0YWtlIHRoZSBjdXJyZW50IGlzb1dlZWtZZWFyLCBidXQgdGhhdCBkZXBlbmRzIG9uXG4gICAgICAgICAgICAvLyBob3cgd2UgaW50ZXJwcmV0IG5vdyAobG9jYWwsIHV0YywgZml4ZWQgb2Zmc2V0KS4gU28gY3JlYXRlXG4gICAgICAgICAgICAvLyBhIG5vdyB2ZXJzaW9uIG9mIGN1cnJlbnQgY29uZmlnICh0YWtlIGxvY2FsL3V0Yy9vZmZzZXQgZmxhZ3MsIGFuZFxuICAgICAgICAgICAgLy8gY3JlYXRlIG5vdykuXG4gICAgICAgICAgICB3ZWVrWWVhciA9IGRlZmF1bHRzKFxuICAgICAgICAgICAgICAgIHcuR0csXG4gICAgICAgICAgICAgICAgY29uZmlnLl9hW1lFQVJdLFxuICAgICAgICAgICAgICAgIHdlZWtPZlllYXIoY3JlYXRlTG9jYWwoKSwgMSwgNCkueWVhclxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHdlZWsgPSBkZWZhdWx0cyh3LlcsIDEpO1xuICAgICAgICAgICAgd2Vla2RheSA9IGRlZmF1bHRzKHcuRSwgMSk7XG4gICAgICAgICAgICBpZiAod2Vla2RheSA8IDEgfHwgd2Vla2RheSA+IDcpIHtcbiAgICAgICAgICAgICAgICB3ZWVrZGF5T3ZlcmZsb3cgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZG93ID0gY29uZmlnLl9sb2NhbGUuX3dlZWsuZG93O1xuICAgICAgICAgICAgZG95ID0gY29uZmlnLl9sb2NhbGUuX3dlZWsuZG95O1xuXG4gICAgICAgICAgICBjdXJXZWVrID0gd2Vla09mWWVhcihjcmVhdGVMb2NhbCgpLCBkb3csIGRveSk7XG5cbiAgICAgICAgICAgIHdlZWtZZWFyID0gZGVmYXVsdHMody5nZywgY29uZmlnLl9hW1lFQVJdLCBjdXJXZWVrLnllYXIpO1xuXG4gICAgICAgICAgICAvLyBEZWZhdWx0IHRvIGN1cnJlbnQgd2Vlay5cbiAgICAgICAgICAgIHdlZWsgPSBkZWZhdWx0cyh3LncsIGN1cldlZWsud2Vlayk7XG5cbiAgICAgICAgICAgIGlmICh3LmQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIHdlZWtkYXkgLS0gbG93IGRheSBudW1iZXJzIGFyZSBjb25zaWRlcmVkIG5leHQgd2Vla1xuICAgICAgICAgICAgICAgIHdlZWtkYXkgPSB3LmQ7XG4gICAgICAgICAgICAgICAgaWYgKHdlZWtkYXkgPCAwIHx8IHdlZWtkYXkgPiA2KSB7XG4gICAgICAgICAgICAgICAgICAgIHdlZWtkYXlPdmVyZmxvdyA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICh3LmUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIGxvY2FsIHdlZWtkYXkgLS0gY291bnRpbmcgc3RhcnRzIGZyb20gYmVnaW5uaW5nIG9mIHdlZWtcbiAgICAgICAgICAgICAgICB3ZWVrZGF5ID0gdy5lICsgZG93O1xuICAgICAgICAgICAgICAgIGlmICh3LmUgPCAwIHx8IHcuZSA+IDYpIHtcbiAgICAgICAgICAgICAgICAgICAgd2Vla2RheU92ZXJmbG93ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGRlZmF1bHQgdG8gYmVnaW5uaW5nIG9mIHdlZWtcbiAgICAgICAgICAgICAgICB3ZWVrZGF5ID0gZG93O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh3ZWVrIDwgMSB8fCB3ZWVrID4gd2Vla3NJblllYXIod2Vla1llYXIsIGRvdywgZG95KSkge1xuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuX292ZXJmbG93V2Vla3MgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKHdlZWtkYXlPdmVyZmxvdyAhPSBudWxsKSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5fb3ZlcmZsb3dXZWVrZGF5ID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRlbXAgPSBkYXlPZlllYXJGcm9tV2Vla3Mod2Vla1llYXIsIHdlZWssIHdlZWtkYXksIGRvdywgZG95KTtcbiAgICAgICAgICAgIGNvbmZpZy5fYVtZRUFSXSA9IHRlbXAueWVhcjtcbiAgICAgICAgICAgIGNvbmZpZy5fZGF5T2ZZZWFyID0gdGVtcC5kYXlPZlllYXI7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBjb25zdGFudCB0aGF0IHJlZmVycyB0byB0aGUgSVNPIHN0YW5kYXJkXG4gICAgaG9va3MuSVNPXzg2MDEgPSBmdW5jdGlvbiAoKSB7fTtcblxuICAgIC8vIGNvbnN0YW50IHRoYXQgcmVmZXJzIHRvIHRoZSBSRkMgMjgyMiBmb3JtXG4gICAgaG9va3MuUkZDXzI4MjIgPSBmdW5jdGlvbiAoKSB7fTtcblxuICAgIC8vIGRhdGUgZnJvbSBzdHJpbmcgYW5kIGZvcm1hdCBzdHJpbmdcbiAgICBmdW5jdGlvbiBjb25maWdGcm9tU3RyaW5nQW5kRm9ybWF0KGNvbmZpZykge1xuICAgICAgICAvLyBUT0RPOiBNb3ZlIHRoaXMgdG8gYW5vdGhlciBwYXJ0IG9mIHRoZSBjcmVhdGlvbiBmbG93IHRvIHByZXZlbnQgY2lyY3VsYXIgZGVwc1xuICAgICAgICBpZiAoY29uZmlnLl9mID09PSBob29rcy5JU09fODYwMSkge1xuICAgICAgICAgICAgY29uZmlnRnJvbUlTTyhjb25maWcpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb25maWcuX2YgPT09IGhvb2tzLlJGQ18yODIyKSB7XG4gICAgICAgICAgICBjb25maWdGcm9tUkZDMjgyMihjb25maWcpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbmZpZy5fYSA9IFtdO1xuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5lbXB0eSA9IHRydWU7XG5cbiAgICAgICAgLy8gVGhpcyBhcnJheSBpcyB1c2VkIHRvIG1ha2UgYSBEYXRlLCBlaXRoZXIgd2l0aCBgbmV3IERhdGVgIG9yIGBEYXRlLlVUQ2BcbiAgICAgICAgdmFyIHN0cmluZyA9ICcnICsgY29uZmlnLl9pLFxuICAgICAgICAgICAgaSxcbiAgICAgICAgICAgIHBhcnNlZElucHV0LFxuICAgICAgICAgICAgdG9rZW5zLFxuICAgICAgICAgICAgdG9rZW4sXG4gICAgICAgICAgICBza2lwcGVkLFxuICAgICAgICAgICAgc3RyaW5nTGVuZ3RoID0gc3RyaW5nLmxlbmd0aCxcbiAgICAgICAgICAgIHRvdGFsUGFyc2VkSW5wdXRMZW5ndGggPSAwLFxuICAgICAgICAgICAgZXJhO1xuXG4gICAgICAgIHRva2VucyA9XG4gICAgICAgICAgICBleHBhbmRGb3JtYXQoY29uZmlnLl9mLCBjb25maWcuX2xvY2FsZSkubWF0Y2goZm9ybWF0dGluZ1Rva2VucykgfHwgW107XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdG9rZW4gPSB0b2tlbnNbaV07XG4gICAgICAgICAgICBwYXJzZWRJbnB1dCA9IChzdHJpbmcubWF0Y2goZ2V0UGFyc2VSZWdleEZvclRva2VuKHRva2VuLCBjb25maWcpKSB8fFxuICAgICAgICAgICAgICAgIFtdKVswXTtcbiAgICAgICAgICAgIGlmIChwYXJzZWRJbnB1dCkge1xuICAgICAgICAgICAgICAgIHNraXBwZWQgPSBzdHJpbmcuc3Vic3RyKDAsIHN0cmluZy5pbmRleE9mKHBhcnNlZElucHV0KSk7XG4gICAgICAgICAgICAgICAgaWYgKHNraXBwZWQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS51bnVzZWRJbnB1dC5wdXNoKHNraXBwZWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdHJpbmcgPSBzdHJpbmcuc2xpY2UoXG4gICAgICAgICAgICAgICAgICAgIHN0cmluZy5pbmRleE9mKHBhcnNlZElucHV0KSArIHBhcnNlZElucHV0Lmxlbmd0aFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgdG90YWxQYXJzZWRJbnB1dExlbmd0aCArPSBwYXJzZWRJbnB1dC5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBkb24ndCBwYXJzZSBpZiBpdCdzIG5vdCBhIGtub3duIHRva2VuXG4gICAgICAgICAgICBpZiAoZm9ybWF0VG9rZW5GdW5jdGlvbnNbdG9rZW5dKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlZElucHV0KSB7XG4gICAgICAgICAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmVtcHR5ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykudW51c2VkVG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhZGRUaW1lVG9BcnJheUZyb21Ub2tlbih0b2tlbiwgcGFyc2VkSW5wdXQsIGNvbmZpZyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNvbmZpZy5fc3RyaWN0ICYmICFwYXJzZWRJbnB1dCkge1xuICAgICAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLnVudXNlZFRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFkZCByZW1haW5pbmcgdW5wYXJzZWQgaW5wdXQgbGVuZ3RoIHRvIHRoZSBzdHJpbmdcbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuY2hhcnNMZWZ0T3ZlciA9XG4gICAgICAgICAgICBzdHJpbmdMZW5ndGggLSB0b3RhbFBhcnNlZElucHV0TGVuZ3RoO1xuICAgICAgICBpZiAoc3RyaW5nLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLnVudXNlZElucHV0LnB1c2goc3RyaW5nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNsZWFyIF8xMmggZmxhZyBpZiBob3VyIGlzIDw9IDEyXG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIGNvbmZpZy5fYVtIT1VSXSA8PSAxMiAmJlxuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuYmlnSG91ciA9PT0gdHJ1ZSAmJlxuICAgICAgICAgICAgY29uZmlnLl9hW0hPVVJdID4gMFxuICAgICAgICApIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmJpZ0hvdXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5wYXJzZWREYXRlUGFydHMgPSBjb25maWcuX2Euc2xpY2UoMCk7XG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLm1lcmlkaWVtID0gY29uZmlnLl9tZXJpZGllbTtcbiAgICAgICAgLy8gaGFuZGxlIG1lcmlkaWVtXG4gICAgICAgIGNvbmZpZy5fYVtIT1VSXSA9IG1lcmlkaWVtRml4V3JhcChcbiAgICAgICAgICAgIGNvbmZpZy5fbG9jYWxlLFxuICAgICAgICAgICAgY29uZmlnLl9hW0hPVVJdLFxuICAgICAgICAgICAgY29uZmlnLl9tZXJpZGllbVxuICAgICAgICApO1xuXG4gICAgICAgIC8vIGhhbmRsZSBlcmFcbiAgICAgICAgZXJhID0gZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuZXJhO1xuICAgICAgICBpZiAoZXJhICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25maWcuX2FbWUVBUl0gPSBjb25maWcuX2xvY2FsZS5lcmFzQ29udmVydFllYXIoZXJhLCBjb25maWcuX2FbWUVBUl0pO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uZmlnRnJvbUFycmF5KGNvbmZpZyk7XG4gICAgICAgIGNoZWNrT3ZlcmZsb3coY29uZmlnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtZXJpZGllbUZpeFdyYXAobG9jYWxlLCBob3VyLCBtZXJpZGllbSkge1xuICAgICAgICB2YXIgaXNQbTtcblxuICAgICAgICBpZiAobWVyaWRpZW0gPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gbm90aGluZyB0byBkb1xuICAgICAgICAgICAgcmV0dXJuIGhvdXI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxvY2FsZS5tZXJpZGllbUhvdXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsZS5tZXJpZGllbUhvdXIoaG91ciwgbWVyaWRpZW0pO1xuICAgICAgICB9IGVsc2UgaWYgKGxvY2FsZS5pc1BNICE9IG51bGwpIHtcbiAgICAgICAgICAgIC8vIEZhbGxiYWNrXG4gICAgICAgICAgICBpc1BtID0gbG9jYWxlLmlzUE0obWVyaWRpZW0pO1xuICAgICAgICAgICAgaWYgKGlzUG0gJiYgaG91ciA8IDEyKSB7XG4gICAgICAgICAgICAgICAgaG91ciArPSAxMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaXNQbSAmJiBob3VyID09PSAxMikge1xuICAgICAgICAgICAgICAgIGhvdXIgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGhvdXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyB0aGlzIGlzIG5vdCBzdXBwb3NlZCB0byBoYXBwZW5cbiAgICAgICAgICAgIHJldHVybiBob3VyO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gZGF0ZSBmcm9tIHN0cmluZyBhbmQgYXJyYXkgb2YgZm9ybWF0IHN0cmluZ3NcbiAgICBmdW5jdGlvbiBjb25maWdGcm9tU3RyaW5nQW5kQXJyYXkoY29uZmlnKSB7XG4gICAgICAgIHZhciB0ZW1wQ29uZmlnLFxuICAgICAgICAgICAgYmVzdE1vbWVudCxcbiAgICAgICAgICAgIHNjb3JlVG9CZWF0LFxuICAgICAgICAgICAgaSxcbiAgICAgICAgICAgIGN1cnJlbnRTY29yZSxcbiAgICAgICAgICAgIHZhbGlkRm9ybWF0Rm91bmQsXG4gICAgICAgICAgICBiZXN0Rm9ybWF0SXNWYWxpZCA9IGZhbHNlO1xuXG4gICAgICAgIGlmIChjb25maWcuX2YubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5pbnZhbGlkRm9ybWF0ID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKE5hTik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY29uZmlnLl9mLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjdXJyZW50U2NvcmUgPSAwO1xuICAgICAgICAgICAgdmFsaWRGb3JtYXRGb3VuZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGVtcENvbmZpZyA9IGNvcHlDb25maWcoe30sIGNvbmZpZyk7XG4gICAgICAgICAgICBpZiAoY29uZmlnLl91c2VVVEMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRlbXBDb25maWcuX3VzZVVUQyA9IGNvbmZpZy5fdXNlVVRDO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGVtcENvbmZpZy5fZiA9IGNvbmZpZy5fZltpXTtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21TdHJpbmdBbmRGb3JtYXQodGVtcENvbmZpZyk7XG5cbiAgICAgICAgICAgIGlmIChpc1ZhbGlkKHRlbXBDb25maWcpKSB7XG4gICAgICAgICAgICAgICAgdmFsaWRGb3JtYXRGb3VuZCA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGlmIHRoZXJlIGlzIGFueSBpbnB1dCB0aGF0IHdhcyBub3QgcGFyc2VkIGFkZCBhIHBlbmFsdHkgZm9yIHRoYXQgZm9ybWF0XG4gICAgICAgICAgICBjdXJyZW50U2NvcmUgKz0gZ2V0UGFyc2luZ0ZsYWdzKHRlbXBDb25maWcpLmNoYXJzTGVmdE92ZXI7XG5cbiAgICAgICAgICAgIC8vb3IgdG9rZW5zXG4gICAgICAgICAgICBjdXJyZW50U2NvcmUgKz0gZ2V0UGFyc2luZ0ZsYWdzKHRlbXBDb25maWcpLnVudXNlZFRva2Vucy5sZW5ndGggKiAxMDtcblxuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKHRlbXBDb25maWcpLnNjb3JlID0gY3VycmVudFNjb3JlO1xuXG4gICAgICAgICAgICBpZiAoIWJlc3RGb3JtYXRJc1ZhbGlkKSB7XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICBzY29yZVRvQmVhdCA9PSBudWxsIHx8XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTY29yZSA8IHNjb3JlVG9CZWF0IHx8XG4gICAgICAgICAgICAgICAgICAgIHZhbGlkRm9ybWF0Rm91bmRcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgc2NvcmVUb0JlYXQgPSBjdXJyZW50U2NvcmU7XG4gICAgICAgICAgICAgICAgICAgIGJlc3RNb21lbnQgPSB0ZW1wQ29uZmlnO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsaWRGb3JtYXRGb3VuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYmVzdEZvcm1hdElzVmFsaWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudFNjb3JlIDwgc2NvcmVUb0JlYXQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2NvcmVUb0JlYXQgPSBjdXJyZW50U2NvcmU7XG4gICAgICAgICAgICAgICAgICAgIGJlc3RNb21lbnQgPSB0ZW1wQ29uZmlnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGV4dGVuZChjb25maWcsIGJlc3RNb21lbnQgfHwgdGVtcENvbmZpZyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29uZmlnRnJvbU9iamVjdChjb25maWcpIHtcbiAgICAgICAgaWYgKGNvbmZpZy5fZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGkgPSBub3JtYWxpemVPYmplY3RVbml0cyhjb25maWcuX2kpLFxuICAgICAgICAgICAgZGF5T3JEYXRlID0gaS5kYXkgPT09IHVuZGVmaW5lZCA/IGkuZGF0ZSA6IGkuZGF5O1xuICAgICAgICBjb25maWcuX2EgPSBtYXAoXG4gICAgICAgICAgICBbaS55ZWFyLCBpLm1vbnRoLCBkYXlPckRhdGUsIGkuaG91ciwgaS5taW51dGUsIGkuc2Vjb25kLCBpLm1pbGxpc2Vjb25kXSxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqICYmIHBhcnNlSW50KG9iaiwgMTApO1xuICAgICAgICAgICAgfVxuICAgICAgICApO1xuXG4gICAgICAgIGNvbmZpZ0Zyb21BcnJheShjb25maWcpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUZyb21Db25maWcoY29uZmlnKSB7XG4gICAgICAgIHZhciByZXMgPSBuZXcgTW9tZW50KGNoZWNrT3ZlcmZsb3cocHJlcGFyZUNvbmZpZyhjb25maWcpKSk7XG4gICAgICAgIGlmIChyZXMuX25leHREYXkpIHtcbiAgICAgICAgICAgIC8vIEFkZGluZyBpcyBzbWFydCBlbm91Z2ggYXJvdW5kIERTVFxuICAgICAgICAgICAgcmVzLmFkZCgxLCAnZCcpO1xuICAgICAgICAgICAgcmVzLl9uZXh0RGF5ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcmVwYXJlQ29uZmlnKGNvbmZpZykge1xuICAgICAgICB2YXIgaW5wdXQgPSBjb25maWcuX2ksXG4gICAgICAgICAgICBmb3JtYXQgPSBjb25maWcuX2Y7XG5cbiAgICAgICAgY29uZmlnLl9sb2NhbGUgPSBjb25maWcuX2xvY2FsZSB8fCBnZXRMb2NhbGUoY29uZmlnLl9sKTtcblxuICAgICAgICBpZiAoaW5wdXQgPT09IG51bGwgfHwgKGZvcm1hdCA9PT0gdW5kZWZpbmVkICYmIGlucHV0ID09PSAnJykpIHtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVJbnZhbGlkKHsgbnVsbElucHV0OiB0cnVlIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGNvbmZpZy5faSA9IGlucHV0ID0gY29uZmlnLl9sb2NhbGUucHJlcGFyc2UoaW5wdXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzTW9tZW50KGlucHV0KSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBNb21lbnQoY2hlY2tPdmVyZmxvdyhpbnB1dCkpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzRGF0ZShpbnB1dCkpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IGlucHV0O1xuICAgICAgICB9IGVsc2UgaWYgKGlzQXJyYXkoZm9ybWF0KSkge1xuICAgICAgICAgICAgY29uZmlnRnJvbVN0cmluZ0FuZEFycmF5KGNvbmZpZyk7XG4gICAgICAgIH0gZWxzZSBpZiAoZm9ybWF0KSB7XG4gICAgICAgICAgICBjb25maWdGcm9tU3RyaW5nQW5kRm9ybWF0KGNvbmZpZyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25maWdGcm9tSW5wdXQoY29uZmlnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNWYWxpZChjb25maWcpKSB7XG4gICAgICAgICAgICBjb25maWcuX2QgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvbmZpZztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb25maWdGcm9tSW5wdXQoY29uZmlnKSB7XG4gICAgICAgIHZhciBpbnB1dCA9IGNvbmZpZy5faTtcbiAgICAgICAgaWYgKGlzVW5kZWZpbmVkKGlucHV0KSkge1xuICAgICAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUoaG9va3Mubm93KCkpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzRGF0ZShpbnB1dCkpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKGlucHV0LnZhbHVlT2YoKSk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgY29uZmlnRnJvbVN0cmluZyhjb25maWcpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzQXJyYXkoaW5wdXQpKSB7XG4gICAgICAgICAgICBjb25maWcuX2EgPSBtYXAoaW5wdXQuc2xpY2UoMCksIGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQob2JqLCAxMCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21BcnJheShjb25maWcpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KGlucHV0KSkge1xuICAgICAgICAgICAgY29uZmlnRnJvbU9iamVjdChjb25maWcpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzTnVtYmVyKGlucHV0KSkge1xuICAgICAgICAgICAgLy8gZnJvbSBtaWxsaXNlY29uZHNcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKGlucHV0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGhvb2tzLmNyZWF0ZUZyb21JbnB1dEZhbGxiYWNrKGNvbmZpZyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVMb2NhbE9yVVRDKGlucHV0LCBmb3JtYXQsIGxvY2FsZSwgc3RyaWN0LCBpc1VUQykge1xuICAgICAgICB2YXIgYyA9IHt9O1xuXG4gICAgICAgIGlmIChmb3JtYXQgPT09IHRydWUgfHwgZm9ybWF0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgc3RyaWN0ID0gZm9ybWF0O1xuICAgICAgICAgICAgZm9ybWF0ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxvY2FsZSA9PT0gdHJ1ZSB8fCBsb2NhbGUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBzdHJpY3QgPSBsb2NhbGU7XG4gICAgICAgICAgICBsb2NhbGUgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoXG4gICAgICAgICAgICAoaXNPYmplY3QoaW5wdXQpICYmIGlzT2JqZWN0RW1wdHkoaW5wdXQpKSB8fFxuICAgICAgICAgICAgKGlzQXJyYXkoaW5wdXQpICYmIGlucHV0Lmxlbmd0aCA9PT0gMClcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBpbnB1dCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICAvLyBvYmplY3QgY29uc3RydWN0aW9uIG11c3QgYmUgZG9uZSB0aGlzIHdheS5cbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21vbWVudC9tb21lbnQvaXNzdWVzLzE0MjNcbiAgICAgICAgYy5faXNBTW9tZW50T2JqZWN0ID0gdHJ1ZTtcbiAgICAgICAgYy5fdXNlVVRDID0gYy5faXNVVEMgPSBpc1VUQztcbiAgICAgICAgYy5fbCA9IGxvY2FsZTtcbiAgICAgICAgYy5faSA9IGlucHV0O1xuICAgICAgICBjLl9mID0gZm9ybWF0O1xuICAgICAgICBjLl9zdHJpY3QgPSBzdHJpY3Q7XG5cbiAgICAgICAgcmV0dXJuIGNyZWF0ZUZyb21Db25maWcoYyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlTG9jYWwoaW5wdXQsIGZvcm1hdCwgbG9jYWxlLCBzdHJpY3QpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUxvY2FsT3JVVEMoaW5wdXQsIGZvcm1hdCwgbG9jYWxlLCBzdHJpY3QsIGZhbHNlKTtcbiAgICB9XG5cbiAgICB2YXIgcHJvdG90eXBlTWluID0gZGVwcmVjYXRlKFxuICAgICAgICAgICAgJ21vbWVudCgpLm1pbiBpcyBkZXByZWNhdGVkLCB1c2UgbW9tZW50Lm1heCBpbnN0ZWFkLiBodHRwOi8vbW9tZW50anMuY29tL2d1aWRlcy8jL3dhcm5pbmdzL21pbi1tYXgvJyxcbiAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgb3RoZXIgPSBjcmVhdGVMb2NhbC5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzVmFsaWQoKSAmJiBvdGhlci5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG90aGVyIDwgdGhpcyA/IHRoaXMgOiBvdGhlcjtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlSW52YWxpZCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgKSxcbiAgICAgICAgcHJvdG90eXBlTWF4ID0gZGVwcmVjYXRlKFxuICAgICAgICAgICAgJ21vbWVudCgpLm1heCBpcyBkZXByZWNhdGVkLCB1c2UgbW9tZW50Lm1pbiBpbnN0ZWFkLiBodHRwOi8vbW9tZW50anMuY29tL2d1aWRlcy8jL3dhcm5pbmdzL21pbi1tYXgvJyxcbiAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgb3RoZXIgPSBjcmVhdGVMb2NhbC5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzVmFsaWQoKSAmJiBvdGhlci5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG90aGVyID4gdGhpcyA/IHRoaXMgOiBvdGhlcjtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlSW52YWxpZCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgKTtcblxuICAgIC8vIFBpY2sgYSBtb21lbnQgbSBmcm9tIG1vbWVudHMgc28gdGhhdCBtW2ZuXShvdGhlcikgaXMgdHJ1ZSBmb3IgYWxsXG4gICAgLy8gb3RoZXIuIFRoaXMgcmVsaWVzIG9uIHRoZSBmdW5jdGlvbiBmbiB0byBiZSB0cmFuc2l0aXZlLlxuICAgIC8vXG4gICAgLy8gbW9tZW50cyBzaG91bGQgZWl0aGVyIGJlIGFuIGFycmF5IG9mIG1vbWVudCBvYmplY3RzIG9yIGFuIGFycmF5LCB3aG9zZVxuICAgIC8vIGZpcnN0IGVsZW1lbnQgaXMgYW4gYXJyYXkgb2YgbW9tZW50IG9iamVjdHMuXG4gICAgZnVuY3Rpb24gcGlja0J5KGZuLCBtb21lbnRzKSB7XG4gICAgICAgIHZhciByZXMsIGk7XG4gICAgICAgIGlmIChtb21lbnRzLmxlbmd0aCA9PT0gMSAmJiBpc0FycmF5KG1vbWVudHNbMF0pKSB7XG4gICAgICAgICAgICBtb21lbnRzID0gbW9tZW50c1swXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW1vbWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlTG9jYWwoKTtcbiAgICAgICAgfVxuICAgICAgICByZXMgPSBtb21lbnRzWzBdO1xuICAgICAgICBmb3IgKGkgPSAxOyBpIDwgbW9tZW50cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgaWYgKCFtb21lbnRzW2ldLmlzVmFsaWQoKSB8fCBtb21lbnRzW2ldW2ZuXShyZXMpKSB7XG4gICAgICAgICAgICAgICAgcmVzID0gbW9tZW50c1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIC8vIFRPRE86IFVzZSBbXS5zb3J0IGluc3RlYWQ/XG4gICAgZnVuY3Rpb24gbWluKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcblxuICAgICAgICByZXR1cm4gcGlja0J5KCdpc0JlZm9yZScsIGFyZ3MpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1heCgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG5cbiAgICAgICAgcmV0dXJuIHBpY2tCeSgnaXNBZnRlcicsIGFyZ3MpO1xuICAgIH1cblxuICAgIHZhciBub3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBEYXRlLm5vdyA/IERhdGUubm93KCkgOiArbmV3IERhdGUoKTtcbiAgICB9O1xuXG4gICAgdmFyIG9yZGVyaW5nID0gW1xuICAgICAgICAneWVhcicsXG4gICAgICAgICdxdWFydGVyJyxcbiAgICAgICAgJ21vbnRoJyxcbiAgICAgICAgJ3dlZWsnLFxuICAgICAgICAnZGF5JyxcbiAgICAgICAgJ2hvdXInLFxuICAgICAgICAnbWludXRlJyxcbiAgICAgICAgJ3NlY29uZCcsXG4gICAgICAgICdtaWxsaXNlY29uZCcsXG4gICAgXTtcblxuICAgIGZ1bmN0aW9uIGlzRHVyYXRpb25WYWxpZChtKSB7XG4gICAgICAgIHZhciBrZXksXG4gICAgICAgICAgICB1bml0SGFzRGVjaW1hbCA9IGZhbHNlLFxuICAgICAgICAgICAgaTtcbiAgICAgICAgZm9yIChrZXkgaW4gbSkge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIGhhc093blByb3AobSwga2V5KSAmJlxuICAgICAgICAgICAgICAgICEoXG4gICAgICAgICAgICAgICAgICAgIGluZGV4T2YuY2FsbChvcmRlcmluZywga2V5KSAhPT0gLTEgJiZcbiAgICAgICAgICAgICAgICAgICAgKG1ba2V5XSA9PSBudWxsIHx8ICFpc05hTihtW2tleV0pKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBvcmRlcmluZy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgaWYgKG1bb3JkZXJpbmdbaV1dKSB7XG4gICAgICAgICAgICAgICAgaWYgKHVuaXRIYXNEZWNpbWFsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gb25seSBhbGxvdyBub24taW50ZWdlcnMgZm9yIHNtYWxsZXN0IHVuaXRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlRmxvYXQobVtvcmRlcmluZ1tpXV0pICE9PSB0b0ludChtW29yZGVyaW5nW2ldXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdW5pdEhhc0RlY2ltYWwgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzVmFsaWQkMSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzVmFsaWQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlSW52YWxpZCQxKCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlRHVyYXRpb24oTmFOKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBEdXJhdGlvbihkdXJhdGlvbikge1xuICAgICAgICB2YXIgbm9ybWFsaXplZElucHV0ID0gbm9ybWFsaXplT2JqZWN0VW5pdHMoZHVyYXRpb24pLFxuICAgICAgICAgICAgeWVhcnMgPSBub3JtYWxpemVkSW5wdXQueWVhciB8fCAwLFxuICAgICAgICAgICAgcXVhcnRlcnMgPSBub3JtYWxpemVkSW5wdXQucXVhcnRlciB8fCAwLFxuICAgICAgICAgICAgbW9udGhzID0gbm9ybWFsaXplZElucHV0Lm1vbnRoIHx8IDAsXG4gICAgICAgICAgICB3ZWVrcyA9IG5vcm1hbGl6ZWRJbnB1dC53ZWVrIHx8IG5vcm1hbGl6ZWRJbnB1dC5pc29XZWVrIHx8IDAsXG4gICAgICAgICAgICBkYXlzID0gbm9ybWFsaXplZElucHV0LmRheSB8fCAwLFxuICAgICAgICAgICAgaG91cnMgPSBub3JtYWxpemVkSW5wdXQuaG91ciB8fCAwLFxuICAgICAgICAgICAgbWludXRlcyA9IG5vcm1hbGl6ZWRJbnB1dC5taW51dGUgfHwgMCxcbiAgICAgICAgICAgIHNlY29uZHMgPSBub3JtYWxpemVkSW5wdXQuc2Vjb25kIHx8IDAsXG4gICAgICAgICAgICBtaWxsaXNlY29uZHMgPSBub3JtYWxpemVkSW5wdXQubWlsbGlzZWNvbmQgfHwgMDtcblxuICAgICAgICB0aGlzLl9pc1ZhbGlkID0gaXNEdXJhdGlvblZhbGlkKG5vcm1hbGl6ZWRJbnB1dCk7XG5cbiAgICAgICAgLy8gcmVwcmVzZW50YXRpb24gZm9yIGRhdGVBZGRSZW1vdmVcbiAgICAgICAgdGhpcy5fbWlsbGlzZWNvbmRzID1cbiAgICAgICAgICAgICttaWxsaXNlY29uZHMgK1xuICAgICAgICAgICAgc2Vjb25kcyAqIDFlMyArIC8vIDEwMDBcbiAgICAgICAgICAgIG1pbnV0ZXMgKiA2ZTQgKyAvLyAxMDAwICogNjBcbiAgICAgICAgICAgIGhvdXJzICogMTAwMCAqIDYwICogNjA7IC8vdXNpbmcgMTAwMCAqIDYwICogNjAgaW5zdGVhZCBvZiAzNmU1IHRvIGF2b2lkIGZsb2F0aW5nIHBvaW50IHJvdW5kaW5nIGVycm9ycyBodHRwczovL2dpdGh1Yi5jb20vbW9tZW50L21vbWVudC9pc3N1ZXMvMjk3OFxuICAgICAgICAvLyBCZWNhdXNlIG9mIGRhdGVBZGRSZW1vdmUgdHJlYXRzIDI0IGhvdXJzIGFzIGRpZmZlcmVudCBmcm9tIGFcbiAgICAgICAgLy8gZGF5IHdoZW4gd29ya2luZyBhcm91bmQgRFNULCB3ZSBuZWVkIHRvIHN0b3JlIHRoZW0gc2VwYXJhdGVseVxuICAgICAgICB0aGlzLl9kYXlzID0gK2RheXMgKyB3ZWVrcyAqIDc7XG4gICAgICAgIC8vIEl0IGlzIGltcG9zc2libGUgdG8gdHJhbnNsYXRlIG1vbnRocyBpbnRvIGRheXMgd2l0aG91dCBrbm93aW5nXG4gICAgICAgIC8vIHdoaWNoIG1vbnRocyB5b3UgYXJlIGFyZSB0YWxraW5nIGFib3V0LCBzbyB3ZSBoYXZlIHRvIHN0b3JlXG4gICAgICAgIC8vIGl0IHNlcGFyYXRlbHkuXG4gICAgICAgIHRoaXMuX21vbnRocyA9ICttb250aHMgKyBxdWFydGVycyAqIDMgKyB5ZWFycyAqIDEyO1xuXG4gICAgICAgIHRoaXMuX2RhdGEgPSB7fTtcblxuICAgICAgICB0aGlzLl9sb2NhbGUgPSBnZXRMb2NhbGUoKTtcblxuICAgICAgICB0aGlzLl9idWJibGUoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0R1cmF0aW9uKG9iaikge1xuICAgICAgICByZXR1cm4gb2JqIGluc3RhbmNlb2YgRHVyYXRpb247XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWJzUm91bmQobnVtYmVyKSB7XG4gICAgICAgIGlmIChudW1iZXIgPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5yb3VuZCgtMSAqIG51bWJlcikgKiAtMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLnJvdW5kKG51bWJlcik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBjb21wYXJlIHR3byBhcnJheXMsIHJldHVybiB0aGUgbnVtYmVyIG9mIGRpZmZlcmVuY2VzXG4gICAgZnVuY3Rpb24gY29tcGFyZUFycmF5cyhhcnJheTEsIGFycmF5MiwgZG9udENvbnZlcnQpIHtcbiAgICAgICAgdmFyIGxlbiA9IE1hdGgubWluKGFycmF5MS5sZW5ndGgsIGFycmF5Mi5sZW5ndGgpLFxuICAgICAgICAgICAgbGVuZ3RoRGlmZiA9IE1hdGguYWJzKGFycmF5MS5sZW5ndGggLSBhcnJheTIubGVuZ3RoKSxcbiAgICAgICAgICAgIGRpZmZzID0gMCxcbiAgICAgICAgICAgIGk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIChkb250Q29udmVydCAmJiBhcnJheTFbaV0gIT09IGFycmF5MltpXSkgfHxcbiAgICAgICAgICAgICAgICAoIWRvbnRDb252ZXJ0ICYmIHRvSW50KGFycmF5MVtpXSkgIT09IHRvSW50KGFycmF5MltpXSkpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBkaWZmcysrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkaWZmcyArIGxlbmd0aERpZmY7XG4gICAgfVxuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgZnVuY3Rpb24gb2Zmc2V0KHRva2VuLCBzZXBhcmF0b3IpIHtcbiAgICAgICAgYWRkRm9ybWF0VG9rZW4odG9rZW4sIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSB0aGlzLnV0Y09mZnNldCgpLFxuICAgICAgICAgICAgICAgIHNpZ24gPSAnKyc7XG4gICAgICAgICAgICBpZiAob2Zmc2V0IDwgMCkge1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IC1vZmZzZXQ7XG4gICAgICAgICAgICAgICAgc2lnbiA9ICctJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgc2lnbiArXG4gICAgICAgICAgICAgICAgemVyb0ZpbGwofn4ob2Zmc2V0IC8gNjApLCAyKSArXG4gICAgICAgICAgICAgICAgc2VwYXJhdG9yICtcbiAgICAgICAgICAgICAgICB6ZXJvRmlsbCh+fm9mZnNldCAlIDYwLCAyKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgb2Zmc2V0KCdaJywgJzonKTtcbiAgICBvZmZzZXQoJ1paJywgJycpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignWicsIG1hdGNoU2hvcnRPZmZzZXQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1paJywgbWF0Y2hTaG9ydE9mZnNldCk7XG4gICAgYWRkUGFyc2VUb2tlbihbJ1onLCAnWlonXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIGNvbmZpZy5fdXNlVVRDID0gdHJ1ZTtcbiAgICAgICAgY29uZmlnLl90em0gPSBvZmZzZXRGcm9tU3RyaW5nKG1hdGNoU2hvcnRPZmZzZXQsIGlucHV0KTtcbiAgICB9KTtcblxuICAgIC8vIEhFTFBFUlNcblxuICAgIC8vIHRpbWV6b25lIGNodW5rZXJcbiAgICAvLyAnKzEwOjAwJyA+IFsnMTAnLCAgJzAwJ11cbiAgICAvLyAnLTE1MzAnICA+IFsnLTE1JywgJzMwJ11cbiAgICB2YXIgY2h1bmtPZmZzZXQgPSAvKFtcXCtcXC1dfFxcZFxcZCkvZ2k7XG5cbiAgICBmdW5jdGlvbiBvZmZzZXRGcm9tU3RyaW5nKG1hdGNoZXIsIHN0cmluZykge1xuICAgICAgICB2YXIgbWF0Y2hlcyA9IChzdHJpbmcgfHwgJycpLm1hdGNoKG1hdGNoZXIpLFxuICAgICAgICAgICAgY2h1bmssXG4gICAgICAgICAgICBwYXJ0cyxcbiAgICAgICAgICAgIG1pbnV0ZXM7XG5cbiAgICAgICAgaWYgKG1hdGNoZXMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgY2h1bmsgPSBtYXRjaGVzW21hdGNoZXMubGVuZ3RoIC0gMV0gfHwgW107XG4gICAgICAgIHBhcnRzID0gKGNodW5rICsgJycpLm1hdGNoKGNodW5rT2Zmc2V0KSB8fCBbJy0nLCAwLCAwXTtcbiAgICAgICAgbWludXRlcyA9ICsocGFydHNbMV0gKiA2MCkgKyB0b0ludChwYXJ0c1syXSk7XG5cbiAgICAgICAgcmV0dXJuIG1pbnV0ZXMgPT09IDAgPyAwIDogcGFydHNbMF0gPT09ICcrJyA/IG1pbnV0ZXMgOiAtbWludXRlcztcbiAgICB9XG5cbiAgICAvLyBSZXR1cm4gYSBtb21lbnQgZnJvbSBpbnB1dCwgdGhhdCBpcyBsb2NhbC91dGMvem9uZSBlcXVpdmFsZW50IHRvIG1vZGVsLlxuICAgIGZ1bmN0aW9uIGNsb25lV2l0aE9mZnNldChpbnB1dCwgbW9kZWwpIHtcbiAgICAgICAgdmFyIHJlcywgZGlmZjtcbiAgICAgICAgaWYgKG1vZGVsLl9pc1VUQykge1xuICAgICAgICAgICAgcmVzID0gbW9kZWwuY2xvbmUoKTtcbiAgICAgICAgICAgIGRpZmYgPVxuICAgICAgICAgICAgICAgIChpc01vbWVudChpbnB1dCkgfHwgaXNEYXRlKGlucHV0KVxuICAgICAgICAgICAgICAgICAgICA/IGlucHV0LnZhbHVlT2YoKVxuICAgICAgICAgICAgICAgICAgICA6IGNyZWF0ZUxvY2FsKGlucHV0KS52YWx1ZU9mKCkpIC0gcmVzLnZhbHVlT2YoKTtcbiAgICAgICAgICAgIC8vIFVzZSBsb3ctbGV2ZWwgYXBpLCBiZWNhdXNlIHRoaXMgZm4gaXMgbG93LWxldmVsIGFwaS5cbiAgICAgICAgICAgIHJlcy5fZC5zZXRUaW1lKHJlcy5fZC52YWx1ZU9mKCkgKyBkaWZmKTtcbiAgICAgICAgICAgIGhvb2tzLnVwZGF0ZU9mZnNldChyZXMsIGZhbHNlKTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlTG9jYWwoaW5wdXQpLmxvY2FsKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXREYXRlT2Zmc2V0KG0pIHtcbiAgICAgICAgLy8gT24gRmlyZWZveC4yNCBEYXRlI2dldFRpbWV6b25lT2Zmc2V0IHJldHVybnMgYSBmbG9hdGluZyBwb2ludC5cbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21vbWVudC9tb21lbnQvcHVsbC8xODcxXG4gICAgICAgIHJldHVybiAtTWF0aC5yb3VuZChtLl9kLmdldFRpbWV6b25lT2Zmc2V0KCkpO1xuICAgIH1cblxuICAgIC8vIEhPT0tTXG5cbiAgICAvLyBUaGlzIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIHdoZW5ldmVyIGEgbW9tZW50IGlzIG11dGF0ZWQuXG4gICAgLy8gSXQgaXMgaW50ZW5kZWQgdG8ga2VlcCB0aGUgb2Zmc2V0IGluIHN5bmMgd2l0aCB0aGUgdGltZXpvbmUuXG4gICAgaG9va3MudXBkYXRlT2Zmc2V0ID0gZnVuY3Rpb24gKCkge307XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICAvLyBrZWVwTG9jYWxUaW1lID0gdHJ1ZSBtZWFucyBvbmx5IGNoYW5nZSB0aGUgdGltZXpvbmUsIHdpdGhvdXRcbiAgICAvLyBhZmZlY3RpbmcgdGhlIGxvY2FsIGhvdXIuIFNvIDU6MzE6MjYgKzAzMDAgLS1bdXRjT2Zmc2V0KDIsIHRydWUpXS0tPlxuICAgIC8vIDU6MzE6MjYgKzAyMDAgSXQgaXMgcG9zc2libGUgdGhhdCA1OjMxOjI2IGRvZXNuJ3QgZXhpc3Qgd2l0aCBvZmZzZXRcbiAgICAvLyArMDIwMCwgc28gd2UgYWRqdXN0IHRoZSB0aW1lIGFzIG5lZWRlZCwgdG8gYmUgdmFsaWQuXG4gICAgLy9cbiAgICAvLyBLZWVwaW5nIHRoZSB0aW1lIGFjdHVhbGx5IGFkZHMvc3VidHJhY3RzIChvbmUgaG91cilcbiAgICAvLyBmcm9tIHRoZSBhY3R1YWwgcmVwcmVzZW50ZWQgdGltZS4gVGhhdCBpcyB3aHkgd2UgY2FsbCB1cGRhdGVPZmZzZXRcbiAgICAvLyBhIHNlY29uZCB0aW1lLiBJbiBjYXNlIGl0IHdhbnRzIHVzIHRvIGNoYW5nZSB0aGUgb2Zmc2V0IGFnYWluXG4gICAgLy8gX2NoYW5nZUluUHJvZ3Jlc3MgPT0gdHJ1ZSBjYXNlLCB0aGVuIHdlIGhhdmUgdG8gYWRqdXN0LCBiZWNhdXNlXG4gICAgLy8gdGhlcmUgaXMgbm8gc3VjaCB0aW1lIGluIHRoZSBnaXZlbiB0aW1lem9uZS5cbiAgICBmdW5jdGlvbiBnZXRTZXRPZmZzZXQoaW5wdXQsIGtlZXBMb2NhbFRpbWUsIGtlZXBNaW51dGVzKSB7XG4gICAgICAgIHZhciBvZmZzZXQgPSB0aGlzLl9vZmZzZXQgfHwgMCxcbiAgICAgICAgICAgIGxvY2FsQWRqdXN0O1xuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQgIT0gbnVsbCA/IHRoaXMgOiBOYU47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlucHV0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgaW5wdXQgPSBvZmZzZXRGcm9tU3RyaW5nKG1hdGNoU2hvcnRPZmZzZXQsIGlucHV0KTtcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChNYXRoLmFicyhpbnB1dCkgPCAxNiAmJiAha2VlcE1pbnV0ZXMpIHtcbiAgICAgICAgICAgICAgICBpbnB1dCA9IGlucHV0ICogNjA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2lzVVRDICYmIGtlZXBMb2NhbFRpbWUpIHtcbiAgICAgICAgICAgICAgICBsb2NhbEFkanVzdCA9IGdldERhdGVPZmZzZXQodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9vZmZzZXQgPSBpbnB1dDtcbiAgICAgICAgICAgIHRoaXMuX2lzVVRDID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChsb2NhbEFkanVzdCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGQobG9jYWxBZGp1c3QsICdtJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob2Zmc2V0ICE9PSBpbnB1dCkge1xuICAgICAgICAgICAgICAgIGlmICgha2VlcExvY2FsVGltZSB8fCB0aGlzLl9jaGFuZ2VJblByb2dyZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZFN1YnRyYWN0KFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNyZWF0ZUR1cmF0aW9uKGlucHV0IC0gb2Zmc2V0LCAnbScpLFxuICAgICAgICAgICAgICAgICAgICAgICAgMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICghdGhpcy5fY2hhbmdlSW5Qcm9ncmVzcykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jaGFuZ2VJblByb2dyZXNzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgaG9va3MudXBkYXRlT2Zmc2V0KHRoaXMsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jaGFuZ2VJblByb2dyZXNzID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pc1VUQyA/IG9mZnNldCA6IGdldERhdGVPZmZzZXQodGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTZXRab25lKGlucHV0LCBrZWVwTG9jYWxUaW1lKSB7XG4gICAgICAgIGlmIChpbnB1dCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGlucHV0ICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGlucHV0ID0gLWlucHV0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnV0Y09mZnNldChpbnB1dCwga2VlcExvY2FsVGltZSk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIC10aGlzLnV0Y09mZnNldCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0T2Zmc2V0VG9VVEMoa2VlcExvY2FsVGltZSkge1xuICAgICAgICByZXR1cm4gdGhpcy51dGNPZmZzZXQoMCwga2VlcExvY2FsVGltZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0T2Zmc2V0VG9Mb2NhbChrZWVwTG9jYWxUaW1lKSB7XG4gICAgICAgIGlmICh0aGlzLl9pc1VUQykge1xuICAgICAgICAgICAgdGhpcy51dGNPZmZzZXQoMCwga2VlcExvY2FsVGltZSk7XG4gICAgICAgICAgICB0aGlzLl9pc1VUQyA9IGZhbHNlO1xuXG4gICAgICAgICAgICBpZiAoa2VlcExvY2FsVGltZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3VidHJhY3QoZ2V0RGF0ZU9mZnNldCh0aGlzKSwgJ20nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRPZmZzZXRUb1BhcnNlZE9mZnNldCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3R6bSAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnV0Y09mZnNldCh0aGlzLl90em0sIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdGhpcy5faSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHZhciB0Wm9uZSA9IG9mZnNldEZyb21TdHJpbmcobWF0Y2hPZmZzZXQsIHRoaXMuX2kpO1xuICAgICAgICAgICAgaWYgKHRab25lICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnV0Y09mZnNldCh0Wm9uZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMudXRjT2Zmc2V0KDAsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhc0FsaWduZWRIb3VyT2Zmc2V0KGlucHV0KSB7XG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpbnB1dCA9IGlucHV0ID8gY3JlYXRlTG9jYWwoaW5wdXQpLnV0Y09mZnNldCgpIDogMDtcblxuICAgICAgICByZXR1cm4gKHRoaXMudXRjT2Zmc2V0KCkgLSBpbnB1dCkgJSA2MCA9PT0gMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0RheWxpZ2h0U2F2aW5nVGltZSgpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHRoaXMudXRjT2Zmc2V0KCkgPiB0aGlzLmNsb25lKCkubW9udGgoMCkudXRjT2Zmc2V0KCkgfHxcbiAgICAgICAgICAgIHRoaXMudXRjT2Zmc2V0KCkgPiB0aGlzLmNsb25lKCkubW9udGgoNSkudXRjT2Zmc2V0KClcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0RheWxpZ2h0U2F2aW5nVGltZVNoaWZ0ZWQoKSB7XG4gICAgICAgIGlmICghaXNVbmRlZmluZWQodGhpcy5faXNEU1RTaGlmdGVkKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2lzRFNUU2hpZnRlZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjID0ge30sXG4gICAgICAgICAgICBvdGhlcjtcblxuICAgICAgICBjb3B5Q29uZmlnKGMsIHRoaXMpO1xuICAgICAgICBjID0gcHJlcGFyZUNvbmZpZyhjKTtcblxuICAgICAgICBpZiAoYy5fYSkge1xuICAgICAgICAgICAgb3RoZXIgPSBjLl9pc1VUQyA/IGNyZWF0ZVVUQyhjLl9hKSA6IGNyZWF0ZUxvY2FsKGMuX2EpO1xuICAgICAgICAgICAgdGhpcy5faXNEU1RTaGlmdGVkID1cbiAgICAgICAgICAgICAgICB0aGlzLmlzVmFsaWQoKSAmJiBjb21wYXJlQXJyYXlzKGMuX2EsIG90aGVyLnRvQXJyYXkoKSkgPiAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5faXNEU1RTaGlmdGVkID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5faXNEU1RTaGlmdGVkO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzTG9jYWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzVmFsaWQoKSA/ICF0aGlzLl9pc1VUQyA6IGZhbHNlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzVXRjT2Zmc2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc1ZhbGlkKCkgPyB0aGlzLl9pc1VUQyA6IGZhbHNlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzVXRjKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc1ZhbGlkKCkgPyB0aGlzLl9pc1VUQyAmJiB0aGlzLl9vZmZzZXQgPT09IDAgOiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBBU1AuTkVUIGpzb24gZGF0ZSBmb3JtYXQgcmVnZXhcbiAgICB2YXIgYXNwTmV0UmVnZXggPSAvXigtfFxcKyk/KD86KFxcZCopWy4gXSk/KFxcZCspOihcXGQrKSg/OjooXFxkKykoXFwuXFxkKik/KT8kLyxcbiAgICAgICAgLy8gZnJvbSBodHRwOi8vZG9jcy5jbG9zdXJlLWxpYnJhcnkuZ29vZ2xlY29kZS5jb20vZ2l0L2Nsb3N1cmVfZ29vZ19kYXRlX2RhdGUuanMuc291cmNlLmh0bWxcbiAgICAgICAgLy8gc29tZXdoYXQgbW9yZSBpbiBsaW5lIHdpdGggNC40LjMuMiAyMDA0IHNwZWMsIGJ1dCBhbGxvd3MgZGVjaW1hbCBhbnl3aGVyZVxuICAgICAgICAvLyBhbmQgZnVydGhlciBtb2RpZmllZCB0byBhbGxvdyBmb3Igc3RyaW5ncyBjb250YWluaW5nIGJvdGggd2VlayBhbmQgZGF5XG4gICAgICAgIGlzb1JlZ2V4ID0gL14oLXxcXCspP1AoPzooWy0rXT9bMC05LC5dKilZKT8oPzooWy0rXT9bMC05LC5dKilNKT8oPzooWy0rXT9bMC05LC5dKilXKT8oPzooWy0rXT9bMC05LC5dKilEKT8oPzpUKD86KFstK10/WzAtOSwuXSopSCk/KD86KFstK10/WzAtOSwuXSopTSk/KD86KFstK10/WzAtOSwuXSopUyk/KT8kLztcblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUR1cmF0aW9uKGlucHV0LCBrZXkpIHtcbiAgICAgICAgdmFyIGR1cmF0aW9uID0gaW5wdXQsXG4gICAgICAgICAgICAvLyBtYXRjaGluZyBhZ2FpbnN0IHJlZ2V4cCBpcyBleHBlbnNpdmUsIGRvIGl0IG9uIGRlbWFuZFxuICAgICAgICAgICAgbWF0Y2ggPSBudWxsLFxuICAgICAgICAgICAgc2lnbixcbiAgICAgICAgICAgIHJldCxcbiAgICAgICAgICAgIGRpZmZSZXM7XG5cbiAgICAgICAgaWYgKGlzRHVyYXRpb24oaW5wdXQpKSB7XG4gICAgICAgICAgICBkdXJhdGlvbiA9IHtcbiAgICAgICAgICAgICAgICBtczogaW5wdXQuX21pbGxpc2Vjb25kcyxcbiAgICAgICAgICAgICAgICBkOiBpbnB1dC5fZGF5cyxcbiAgICAgICAgICAgICAgICBNOiBpbnB1dC5fbW9udGhzLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmIChpc051bWJlcihpbnB1dCkgfHwgIWlzTmFOKCtpbnB1dCkpIHtcbiAgICAgICAgICAgIGR1cmF0aW9uID0ge307XG4gICAgICAgICAgICBpZiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgZHVyYXRpb25ba2V5XSA9ICtpbnB1dDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZHVyYXRpb24ubWlsbGlzZWNvbmRzID0gK2lucHV0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKChtYXRjaCA9IGFzcE5ldFJlZ2V4LmV4ZWMoaW5wdXQpKSkge1xuICAgICAgICAgICAgc2lnbiA9IG1hdGNoWzFdID09PSAnLScgPyAtMSA6IDE7XG4gICAgICAgICAgICBkdXJhdGlvbiA9IHtcbiAgICAgICAgICAgICAgICB5OiAwLFxuICAgICAgICAgICAgICAgIGQ6IHRvSW50KG1hdGNoW0RBVEVdKSAqIHNpZ24sXG4gICAgICAgICAgICAgICAgaDogdG9JbnQobWF0Y2hbSE9VUl0pICogc2lnbixcbiAgICAgICAgICAgICAgICBtOiB0b0ludChtYXRjaFtNSU5VVEVdKSAqIHNpZ24sXG4gICAgICAgICAgICAgICAgczogdG9JbnQobWF0Y2hbU0VDT05EXSkgKiBzaWduLFxuICAgICAgICAgICAgICAgIG1zOiB0b0ludChhYnNSb3VuZChtYXRjaFtNSUxMSVNFQ09ORF0gKiAxMDAwKSkgKiBzaWduLCAvLyB0aGUgbWlsbGlzZWNvbmQgZGVjaW1hbCBwb2ludCBpcyBpbmNsdWRlZCBpbiB0aGUgbWF0Y2hcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAoKG1hdGNoID0gaXNvUmVnZXguZXhlYyhpbnB1dCkpKSB7XG4gICAgICAgICAgICBzaWduID0gbWF0Y2hbMV0gPT09ICctJyA/IC0xIDogMTtcbiAgICAgICAgICAgIGR1cmF0aW9uID0ge1xuICAgICAgICAgICAgICAgIHk6IHBhcnNlSXNvKG1hdGNoWzJdLCBzaWduKSxcbiAgICAgICAgICAgICAgICBNOiBwYXJzZUlzbyhtYXRjaFszXSwgc2lnbiksXG4gICAgICAgICAgICAgICAgdzogcGFyc2VJc28obWF0Y2hbNF0sIHNpZ24pLFxuICAgICAgICAgICAgICAgIGQ6IHBhcnNlSXNvKG1hdGNoWzVdLCBzaWduKSxcbiAgICAgICAgICAgICAgICBoOiBwYXJzZUlzbyhtYXRjaFs2XSwgc2lnbiksXG4gICAgICAgICAgICAgICAgbTogcGFyc2VJc28obWF0Y2hbN10sIHNpZ24pLFxuICAgICAgICAgICAgICAgIHM6IHBhcnNlSXNvKG1hdGNoWzhdLCBzaWduKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAoZHVyYXRpb24gPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gY2hlY2tzIGZvciBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgZHVyYXRpb24gPSB7fTtcbiAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgIHR5cGVvZiBkdXJhdGlvbiA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgICgnZnJvbScgaW4gZHVyYXRpb24gfHwgJ3RvJyBpbiBkdXJhdGlvbilcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBkaWZmUmVzID0gbW9tZW50c0RpZmZlcmVuY2UoXG4gICAgICAgICAgICAgICAgY3JlYXRlTG9jYWwoZHVyYXRpb24uZnJvbSksXG4gICAgICAgICAgICAgICAgY3JlYXRlTG9jYWwoZHVyYXRpb24udG8pXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBkdXJhdGlvbiA9IHt9O1xuICAgICAgICAgICAgZHVyYXRpb24ubXMgPSBkaWZmUmVzLm1pbGxpc2Vjb25kcztcbiAgICAgICAgICAgIGR1cmF0aW9uLk0gPSBkaWZmUmVzLm1vbnRocztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldCA9IG5ldyBEdXJhdGlvbihkdXJhdGlvbik7XG5cbiAgICAgICAgaWYgKGlzRHVyYXRpb24oaW5wdXQpICYmIGhhc093blByb3AoaW5wdXQsICdfbG9jYWxlJykpIHtcbiAgICAgICAgICAgIHJldC5fbG9jYWxlID0gaW5wdXQuX2xvY2FsZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0R1cmF0aW9uKGlucHV0KSAmJiBoYXNPd25Qcm9wKGlucHV0LCAnX2lzVmFsaWQnKSkge1xuICAgICAgICAgICAgcmV0Ll9pc1ZhbGlkID0gaW5wdXQuX2lzVmFsaWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cblxuICAgIGNyZWF0ZUR1cmF0aW9uLmZuID0gRHVyYXRpb24ucHJvdG90eXBlO1xuICAgIGNyZWF0ZUR1cmF0aW9uLmludmFsaWQgPSBjcmVhdGVJbnZhbGlkJDE7XG5cbiAgICBmdW5jdGlvbiBwYXJzZUlzbyhpbnAsIHNpZ24pIHtcbiAgICAgICAgLy8gV2UnZCBub3JtYWxseSB1c2Ugfn5pbnAgZm9yIHRoaXMsIGJ1dCB1bmZvcnR1bmF0ZWx5IGl0IGFsc29cbiAgICAgICAgLy8gY29udmVydHMgZmxvYXRzIHRvIGludHMuXG4gICAgICAgIC8vIGlucCBtYXkgYmUgdW5kZWZpbmVkLCBzbyBjYXJlZnVsIGNhbGxpbmcgcmVwbGFjZSBvbiBpdC5cbiAgICAgICAgdmFyIHJlcyA9IGlucCAmJiBwYXJzZUZsb2F0KGlucC5yZXBsYWNlKCcsJywgJy4nKSk7XG4gICAgICAgIC8vIGFwcGx5IHNpZ24gd2hpbGUgd2UncmUgYXQgaXRcbiAgICAgICAgcmV0dXJuIChpc05hTihyZXMpID8gMCA6IHJlcykgKiBzaWduO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBvc2l0aXZlTW9tZW50c0RpZmZlcmVuY2UoYmFzZSwgb3RoZXIpIHtcbiAgICAgICAgdmFyIHJlcyA9IHt9O1xuXG4gICAgICAgIHJlcy5tb250aHMgPVxuICAgICAgICAgICAgb3RoZXIubW9udGgoKSAtIGJhc2UubW9udGgoKSArIChvdGhlci55ZWFyKCkgLSBiYXNlLnllYXIoKSkgKiAxMjtcbiAgICAgICAgaWYgKGJhc2UuY2xvbmUoKS5hZGQocmVzLm1vbnRocywgJ00nKS5pc0FmdGVyKG90aGVyKSkge1xuICAgICAgICAgICAgLS1yZXMubW9udGhzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzLm1pbGxpc2Vjb25kcyA9ICtvdGhlciAtICtiYXNlLmNsb25lKCkuYWRkKHJlcy5tb250aHMsICdNJyk7XG5cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtb21lbnRzRGlmZmVyZW5jZShiYXNlLCBvdGhlcikge1xuICAgICAgICB2YXIgcmVzO1xuICAgICAgICBpZiAoIShiYXNlLmlzVmFsaWQoKSAmJiBvdGhlci5pc1ZhbGlkKCkpKSB7XG4gICAgICAgICAgICByZXR1cm4geyBtaWxsaXNlY29uZHM6IDAsIG1vbnRoczogMCB9O1xuICAgICAgICB9XG5cbiAgICAgICAgb3RoZXIgPSBjbG9uZVdpdGhPZmZzZXQob3RoZXIsIGJhc2UpO1xuICAgICAgICBpZiAoYmFzZS5pc0JlZm9yZShvdGhlcikpIHtcbiAgICAgICAgICAgIHJlcyA9IHBvc2l0aXZlTW9tZW50c0RpZmZlcmVuY2UoYmFzZSwgb3RoZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzID0gcG9zaXRpdmVNb21lbnRzRGlmZmVyZW5jZShvdGhlciwgYmFzZSk7XG4gICAgICAgICAgICByZXMubWlsbGlzZWNvbmRzID0gLXJlcy5taWxsaXNlY29uZHM7XG4gICAgICAgICAgICByZXMubW9udGhzID0gLXJlcy5tb250aHM7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIC8vIFRPRE86IHJlbW92ZSAnbmFtZScgYXJnIGFmdGVyIGRlcHJlY2F0aW9uIGlzIHJlbW92ZWRcbiAgICBmdW5jdGlvbiBjcmVhdGVBZGRlcihkaXJlY3Rpb24sIG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2YWwsIHBlcmlvZCkge1xuICAgICAgICAgICAgdmFyIGR1ciwgdG1wO1xuICAgICAgICAgICAgLy9pbnZlcnQgdGhlIGFyZ3VtZW50cywgYnV0IGNvbXBsYWluIGFib3V0IGl0XG4gICAgICAgICAgICBpZiAocGVyaW9kICE9PSBudWxsICYmICFpc05hTigrcGVyaW9kKSkge1xuICAgICAgICAgICAgICAgIGRlcHJlY2F0ZVNpbXBsZShcbiAgICAgICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgJ21vbWVudCgpLicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSArXG4gICAgICAgICAgICAgICAgICAgICAgICAnKHBlcmlvZCwgbnVtYmVyKSBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIG1vbWVudCgpLicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSArXG4gICAgICAgICAgICAgICAgICAgICAgICAnKG51bWJlciwgcGVyaW9kKS4gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnU2VlIGh0dHA6Ly9tb21lbnRqcy5jb20vZ3VpZGVzLyMvd2FybmluZ3MvYWRkLWludmVydGVkLXBhcmFtLyBmb3IgbW9yZSBpbmZvLidcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHRtcCA9IHZhbDtcbiAgICAgICAgICAgICAgICB2YWwgPSBwZXJpb2Q7XG4gICAgICAgICAgICAgICAgcGVyaW9kID0gdG1wO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkdXIgPSBjcmVhdGVEdXJhdGlvbih2YWwsIHBlcmlvZCk7XG4gICAgICAgICAgICBhZGRTdWJ0cmFjdCh0aGlzLCBkdXIsIGRpcmVjdGlvbik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRTdWJ0cmFjdChtb20sIGR1cmF0aW9uLCBpc0FkZGluZywgdXBkYXRlT2Zmc2V0KSB7XG4gICAgICAgIHZhciBtaWxsaXNlY29uZHMgPSBkdXJhdGlvbi5fbWlsbGlzZWNvbmRzLFxuICAgICAgICAgICAgZGF5cyA9IGFic1JvdW5kKGR1cmF0aW9uLl9kYXlzKSxcbiAgICAgICAgICAgIG1vbnRocyA9IGFic1JvdW5kKGR1cmF0aW9uLl9tb250aHMpO1xuXG4gICAgICAgIGlmICghbW9tLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgLy8gTm8gb3BcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHVwZGF0ZU9mZnNldCA9IHVwZGF0ZU9mZnNldCA9PSBudWxsID8gdHJ1ZSA6IHVwZGF0ZU9mZnNldDtcblxuICAgICAgICBpZiAobW9udGhzKSB7XG4gICAgICAgICAgICBzZXRNb250aChtb20sIGdldChtb20sICdNb250aCcpICsgbW9udGhzICogaXNBZGRpbmcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXlzKSB7XG4gICAgICAgICAgICBzZXQkMShtb20sICdEYXRlJywgZ2V0KG1vbSwgJ0RhdGUnKSArIGRheXMgKiBpc0FkZGluZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1pbGxpc2Vjb25kcykge1xuICAgICAgICAgICAgbW9tLl9kLnNldFRpbWUobW9tLl9kLnZhbHVlT2YoKSArIG1pbGxpc2Vjb25kcyAqIGlzQWRkaW5nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodXBkYXRlT2Zmc2V0KSB7XG4gICAgICAgICAgICBob29rcy51cGRhdGVPZmZzZXQobW9tLCBkYXlzIHx8IG1vbnRocyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgYWRkID0gY3JlYXRlQWRkZXIoMSwgJ2FkZCcpLFxuICAgICAgICBzdWJ0cmFjdCA9IGNyZWF0ZUFkZGVyKC0xLCAnc3VidHJhY3QnKTtcblxuICAgIGZ1bmN0aW9uIGlzU3RyaW5nKGlucHV0KSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnIHx8IGlucHV0IGluc3RhbmNlb2YgU3RyaW5nO1xuICAgIH1cblxuICAgIC8vIHR5cGUgTW9tZW50SW5wdXQgPSBNb21lbnQgfCBEYXRlIHwgc3RyaW5nIHwgbnVtYmVyIHwgKG51bWJlciB8IHN0cmluZylbXSB8IE1vbWVudElucHV0T2JqZWN0IHwgdm9pZDsgLy8gbnVsbCB8IHVuZGVmaW5lZFxuICAgIGZ1bmN0aW9uIGlzTW9tZW50SW5wdXQoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIGlzTW9tZW50KGlucHV0KSB8fFxuICAgICAgICAgICAgaXNEYXRlKGlucHV0KSB8fFxuICAgICAgICAgICAgaXNTdHJpbmcoaW5wdXQpIHx8XG4gICAgICAgICAgICBpc051bWJlcihpbnB1dCkgfHxcbiAgICAgICAgICAgIGlzTnVtYmVyT3JTdHJpbmdBcnJheShpbnB1dCkgfHxcbiAgICAgICAgICAgIGlzTW9tZW50SW5wdXRPYmplY3QoaW5wdXQpIHx8XG4gICAgICAgICAgICBpbnB1dCA9PT0gbnVsbCB8fFxuICAgICAgICAgICAgaW5wdXQgPT09IHVuZGVmaW5lZFxuICAgICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzTW9tZW50SW5wdXRPYmplY3QoaW5wdXQpIHtcbiAgICAgICAgdmFyIG9iamVjdFRlc3QgPSBpc09iamVjdChpbnB1dCkgJiYgIWlzT2JqZWN0RW1wdHkoaW5wdXQpLFxuICAgICAgICAgICAgcHJvcGVydHlUZXN0ID0gZmFsc2UsXG4gICAgICAgICAgICBwcm9wZXJ0aWVzID0gW1xuICAgICAgICAgICAgICAgICd5ZWFycycsXG4gICAgICAgICAgICAgICAgJ3llYXInLFxuICAgICAgICAgICAgICAgICd5JyxcbiAgICAgICAgICAgICAgICAnbW9udGhzJyxcbiAgICAgICAgICAgICAgICAnbW9udGgnLFxuICAgICAgICAgICAgICAgICdNJyxcbiAgICAgICAgICAgICAgICAnZGF5cycsXG4gICAgICAgICAgICAgICAgJ2RheScsXG4gICAgICAgICAgICAgICAgJ2QnLFxuICAgICAgICAgICAgICAgICdkYXRlcycsXG4gICAgICAgICAgICAgICAgJ2RhdGUnLFxuICAgICAgICAgICAgICAgICdEJyxcbiAgICAgICAgICAgICAgICAnaG91cnMnLFxuICAgICAgICAgICAgICAgICdob3VyJyxcbiAgICAgICAgICAgICAgICAnaCcsXG4gICAgICAgICAgICAgICAgJ21pbnV0ZXMnLFxuICAgICAgICAgICAgICAgICdtaW51dGUnLFxuICAgICAgICAgICAgICAgICdtJyxcbiAgICAgICAgICAgICAgICAnc2Vjb25kcycsXG4gICAgICAgICAgICAgICAgJ3NlY29uZCcsXG4gICAgICAgICAgICAgICAgJ3MnLFxuICAgICAgICAgICAgICAgICdtaWxsaXNlY29uZHMnLFxuICAgICAgICAgICAgICAgICdtaWxsaXNlY29uZCcsXG4gICAgICAgICAgICAgICAgJ21zJyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBpLFxuICAgICAgICAgICAgcHJvcGVydHk7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHByb3BlcnRpZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIHByb3BlcnR5ID0gcHJvcGVydGllc1tpXTtcbiAgICAgICAgICAgIHByb3BlcnR5VGVzdCA9IHByb3BlcnR5VGVzdCB8fCBoYXNPd25Qcm9wKGlucHV0LCBwcm9wZXJ0eSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb2JqZWN0VGVzdCAmJiBwcm9wZXJ0eVRlc3Q7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNOdW1iZXJPclN0cmluZ0FycmF5KGlucHV0KSB7XG4gICAgICAgIHZhciBhcnJheVRlc3QgPSBpc0FycmF5KGlucHV0KSxcbiAgICAgICAgICAgIGRhdGFUeXBlVGVzdCA9IGZhbHNlO1xuICAgICAgICBpZiAoYXJyYXlUZXN0KSB7XG4gICAgICAgICAgICBkYXRhVHlwZVRlc3QgPVxuICAgICAgICAgICAgICAgIGlucHV0LmZpbHRlcihmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gIWlzTnVtYmVyKGl0ZW0pICYmIGlzU3RyaW5nKGlucHV0KTtcbiAgICAgICAgICAgICAgICB9KS5sZW5ndGggPT09IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFycmF5VGVzdCAmJiBkYXRhVHlwZVRlc3Q7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNDYWxlbmRhclNwZWMoaW5wdXQpIHtcbiAgICAgICAgdmFyIG9iamVjdFRlc3QgPSBpc09iamVjdChpbnB1dCkgJiYgIWlzT2JqZWN0RW1wdHkoaW5wdXQpLFxuICAgICAgICAgICAgcHJvcGVydHlUZXN0ID0gZmFsc2UsXG4gICAgICAgICAgICBwcm9wZXJ0aWVzID0gW1xuICAgICAgICAgICAgICAgICdzYW1lRGF5JyxcbiAgICAgICAgICAgICAgICAnbmV4dERheScsXG4gICAgICAgICAgICAgICAgJ2xhc3REYXknLFxuICAgICAgICAgICAgICAgICduZXh0V2VlaycsXG4gICAgICAgICAgICAgICAgJ2xhc3RXZWVrJyxcbiAgICAgICAgICAgICAgICAnc2FtZUVsc2UnLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICBwcm9wZXJ0eTtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcHJvcGVydGllcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgcHJvcGVydHkgPSBwcm9wZXJ0aWVzW2ldO1xuICAgICAgICAgICAgcHJvcGVydHlUZXN0ID0gcHJvcGVydHlUZXN0IHx8IGhhc093blByb3AoaW5wdXQsIHByb3BlcnR5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvYmplY3RUZXN0ICYmIHByb3BlcnR5VGVzdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRDYWxlbmRhckZvcm1hdChteU1vbWVudCwgbm93KSB7XG4gICAgICAgIHZhciBkaWZmID0gbXlNb21lbnQuZGlmZihub3csICdkYXlzJywgdHJ1ZSk7XG4gICAgICAgIHJldHVybiBkaWZmIDwgLTZcbiAgICAgICAgICAgID8gJ3NhbWVFbHNlJ1xuICAgICAgICAgICAgOiBkaWZmIDwgLTFcbiAgICAgICAgICAgID8gJ2xhc3RXZWVrJ1xuICAgICAgICAgICAgOiBkaWZmIDwgMFxuICAgICAgICAgICAgPyAnbGFzdERheSdcbiAgICAgICAgICAgIDogZGlmZiA8IDFcbiAgICAgICAgICAgID8gJ3NhbWVEYXknXG4gICAgICAgICAgICA6IGRpZmYgPCAyXG4gICAgICAgICAgICA/ICduZXh0RGF5J1xuICAgICAgICAgICAgOiBkaWZmIDwgN1xuICAgICAgICAgICAgPyAnbmV4dFdlZWsnXG4gICAgICAgICAgICA6ICdzYW1lRWxzZSc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2FsZW5kYXIkMSh0aW1lLCBmb3JtYXRzKSB7XG4gICAgICAgIC8vIFN1cHBvcnQgZm9yIHNpbmdsZSBwYXJhbWV0ZXIsIGZvcm1hdHMgb25seSBvdmVybG9hZCB0byB0aGUgY2FsZW5kYXIgZnVuY3Rpb25cbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIGlmICghYXJndW1lbnRzWzBdKSB7XG4gICAgICAgICAgICAgICAgdGltZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBmb3JtYXRzID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpc01vbWVudElucHV0KGFyZ3VtZW50c1swXSkpIHtcbiAgICAgICAgICAgICAgICB0aW1lID0gYXJndW1lbnRzWzBdO1xuICAgICAgICAgICAgICAgIGZvcm1hdHMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzQ2FsZW5kYXJTcGVjKGFyZ3VtZW50c1swXSkpIHtcbiAgICAgICAgICAgICAgICBmb3JtYXRzID0gYXJndW1lbnRzWzBdO1xuICAgICAgICAgICAgICAgIHRpbWUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2Ugd2FudCB0byBjb21wYXJlIHRoZSBzdGFydCBvZiB0b2RheSwgdnMgdGhpcy5cbiAgICAgICAgLy8gR2V0dGluZyBzdGFydC1vZi10b2RheSBkZXBlbmRzIG9uIHdoZXRoZXIgd2UncmUgbG9jYWwvdXRjL29mZnNldCBvciBub3QuXG4gICAgICAgIHZhciBub3cgPSB0aW1lIHx8IGNyZWF0ZUxvY2FsKCksXG4gICAgICAgICAgICBzb2QgPSBjbG9uZVdpdGhPZmZzZXQobm93LCB0aGlzKS5zdGFydE9mKCdkYXknKSxcbiAgICAgICAgICAgIGZvcm1hdCA9IGhvb2tzLmNhbGVuZGFyRm9ybWF0KHRoaXMsIHNvZCkgfHwgJ3NhbWVFbHNlJyxcbiAgICAgICAgICAgIG91dHB1dCA9XG4gICAgICAgICAgICAgICAgZm9ybWF0cyAmJlxuICAgICAgICAgICAgICAgIChpc0Z1bmN0aW9uKGZvcm1hdHNbZm9ybWF0XSlcbiAgICAgICAgICAgICAgICAgICAgPyBmb3JtYXRzW2Zvcm1hdF0uY2FsbCh0aGlzLCBub3cpXG4gICAgICAgICAgICAgICAgICAgIDogZm9ybWF0c1tmb3JtYXRdKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5mb3JtYXQoXG4gICAgICAgICAgICBvdXRwdXQgfHwgdGhpcy5sb2NhbGVEYXRhKCkuY2FsZW5kYXIoZm9ybWF0LCB0aGlzLCBjcmVhdGVMb2NhbChub3cpKVxuICAgICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsb25lKCkge1xuICAgICAgICByZXR1cm4gbmV3IE1vbWVudCh0aGlzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0FmdGVyKGlucHV0LCB1bml0cykge1xuICAgICAgICB2YXIgbG9jYWxJbnB1dCA9IGlzTW9tZW50KGlucHV0KSA/IGlucHV0IDogY3JlYXRlTG9jYWwoaW5wdXQpO1xuICAgICAgICBpZiAoISh0aGlzLmlzVmFsaWQoKSAmJiBsb2NhbElucHV0LmlzVmFsaWQoKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKSB8fCAnbWlsbGlzZWNvbmQnO1xuICAgICAgICBpZiAodW5pdHMgPT09ICdtaWxsaXNlY29uZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlT2YoKSA+IGxvY2FsSW5wdXQudmFsdWVPZigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsSW5wdXQudmFsdWVPZigpIDwgdGhpcy5jbG9uZSgpLnN0YXJ0T2YodW5pdHMpLnZhbHVlT2YoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzQmVmb3JlKGlucHV0LCB1bml0cykge1xuICAgICAgICB2YXIgbG9jYWxJbnB1dCA9IGlzTW9tZW50KGlucHV0KSA/IGlucHV0IDogY3JlYXRlTG9jYWwoaW5wdXQpO1xuICAgICAgICBpZiAoISh0aGlzLmlzVmFsaWQoKSAmJiBsb2NhbElucHV0LmlzVmFsaWQoKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKSB8fCAnbWlsbGlzZWNvbmQnO1xuICAgICAgICBpZiAodW5pdHMgPT09ICdtaWxsaXNlY29uZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlT2YoKSA8IGxvY2FsSW5wdXQudmFsdWVPZigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5lbmRPZih1bml0cykudmFsdWVPZigpIDwgbG9jYWxJbnB1dC52YWx1ZU9mKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0JldHdlZW4oZnJvbSwgdG8sIHVuaXRzLCBpbmNsdXNpdml0eSkge1xuICAgICAgICB2YXIgbG9jYWxGcm9tID0gaXNNb21lbnQoZnJvbSkgPyBmcm9tIDogY3JlYXRlTG9jYWwoZnJvbSksXG4gICAgICAgICAgICBsb2NhbFRvID0gaXNNb21lbnQodG8pID8gdG8gOiBjcmVhdGVMb2NhbCh0byk7XG4gICAgICAgIGlmICghKHRoaXMuaXNWYWxpZCgpICYmIGxvY2FsRnJvbS5pc1ZhbGlkKCkgJiYgbG9jYWxUby5pc1ZhbGlkKCkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaW5jbHVzaXZpdHkgPSBpbmNsdXNpdml0eSB8fCAnKCknO1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgKGluY2x1c2l2aXR5WzBdID09PSAnKCdcbiAgICAgICAgICAgICAgICA/IHRoaXMuaXNBZnRlcihsb2NhbEZyb20sIHVuaXRzKVxuICAgICAgICAgICAgICAgIDogIXRoaXMuaXNCZWZvcmUobG9jYWxGcm9tLCB1bml0cykpICYmXG4gICAgICAgICAgICAoaW5jbHVzaXZpdHlbMV0gPT09ICcpJ1xuICAgICAgICAgICAgICAgID8gdGhpcy5pc0JlZm9yZShsb2NhbFRvLCB1bml0cylcbiAgICAgICAgICAgICAgICA6ICF0aGlzLmlzQWZ0ZXIobG9jYWxUbywgdW5pdHMpKVxuICAgICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzU2FtZShpbnB1dCwgdW5pdHMpIHtcbiAgICAgICAgdmFyIGxvY2FsSW5wdXQgPSBpc01vbWVudChpbnB1dCkgPyBpbnB1dCA6IGNyZWF0ZUxvY2FsKGlucHV0KSxcbiAgICAgICAgICAgIGlucHV0TXM7XG4gICAgICAgIGlmICghKHRoaXMuaXNWYWxpZCgpICYmIGxvY2FsSW5wdXQuaXNWYWxpZCgpKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpIHx8ICdtaWxsaXNlY29uZCc7XG4gICAgICAgIGlmICh1bml0cyA9PT0gJ21pbGxpc2Vjb25kJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVPZigpID09PSBsb2NhbElucHV0LnZhbHVlT2YoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlucHV0TXMgPSBsb2NhbElucHV0LnZhbHVlT2YoKTtcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgdGhpcy5jbG9uZSgpLnN0YXJ0T2YodW5pdHMpLnZhbHVlT2YoKSA8PSBpbnB1dE1zICYmXG4gICAgICAgICAgICAgICAgaW5wdXRNcyA8PSB0aGlzLmNsb25lKCkuZW5kT2YodW5pdHMpLnZhbHVlT2YoKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzU2FtZU9yQWZ0ZXIoaW5wdXQsIHVuaXRzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzU2FtZShpbnB1dCwgdW5pdHMpIHx8IHRoaXMuaXNBZnRlcihpbnB1dCwgdW5pdHMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzU2FtZU9yQmVmb3JlKGlucHV0LCB1bml0cykge1xuICAgICAgICByZXR1cm4gdGhpcy5pc1NhbWUoaW5wdXQsIHVuaXRzKSB8fCB0aGlzLmlzQmVmb3JlKGlucHV0LCB1bml0cyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGlmZihpbnB1dCwgdW5pdHMsIGFzRmxvYXQpIHtcbiAgICAgICAgdmFyIHRoYXQsIHpvbmVEZWx0YSwgb3V0cHV0O1xuXG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBOYU47XG4gICAgICAgIH1cblxuICAgICAgICB0aGF0ID0gY2xvbmVXaXRoT2Zmc2V0KGlucHV0LCB0aGlzKTtcblxuICAgICAgICBpZiAoIXRoYXQuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgICB9XG5cbiAgICAgICAgem9uZURlbHRhID0gKHRoYXQudXRjT2Zmc2V0KCkgLSB0aGlzLnV0Y09mZnNldCgpKSAqIDZlNDtcblxuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcblxuICAgICAgICBzd2l0Y2ggKHVuaXRzKSB7XG4gICAgICAgICAgICBjYXNlICd5ZWFyJzpcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSBtb250aERpZmYodGhpcywgdGhhdCkgLyAxMjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ21vbnRoJzpcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSBtb250aERpZmYodGhpcywgdGhhdCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdxdWFydGVyJzpcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSBtb250aERpZmYodGhpcywgdGhhdCkgLyAzO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnc2Vjb25kJzpcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSAodGhpcyAtIHRoYXQpIC8gMWUzO1xuICAgICAgICAgICAgICAgIGJyZWFrOyAvLyAxMDAwXG4gICAgICAgICAgICBjYXNlICdtaW51dGUnOlxuICAgICAgICAgICAgICAgIG91dHB1dCA9ICh0aGlzIC0gdGhhdCkgLyA2ZTQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7IC8vIDEwMDAgKiA2MFxuICAgICAgICAgICAgY2FzZSAnaG91cic6XG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gKHRoaXMgLSB0aGF0KSAvIDM2ZTU7XG4gICAgICAgICAgICAgICAgYnJlYWs7IC8vIDEwMDAgKiA2MCAqIDYwXG4gICAgICAgICAgICBjYXNlICdkYXknOlxuICAgICAgICAgICAgICAgIG91dHB1dCA9ICh0aGlzIC0gdGhhdCAtIHpvbmVEZWx0YSkgLyA4NjRlNTtcbiAgICAgICAgICAgICAgICBicmVhazsgLy8gMTAwMCAqIDYwICogNjAgKiAyNCwgbmVnYXRlIGRzdFxuICAgICAgICAgICAgY2FzZSAnd2Vlayc6XG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gKHRoaXMgLSB0aGF0IC0gem9uZURlbHRhKSAvIDYwNDhlNTtcbiAgICAgICAgICAgICAgICBicmVhazsgLy8gMTAwMCAqIDYwICogNjAgKiAyNCAqIDcsIG5lZ2F0ZSBkc3RcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gdGhpcyAtIHRoYXQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXNGbG9hdCA/IG91dHB1dCA6IGFic0Zsb29yKG91dHB1dCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbW9udGhEaWZmKGEsIGIpIHtcbiAgICAgICAgaWYgKGEuZGF0ZSgpIDwgYi5kYXRlKCkpIHtcbiAgICAgICAgICAgIC8vIGVuZC1vZi1tb250aCBjYWxjdWxhdGlvbnMgd29yayBjb3JyZWN0IHdoZW4gdGhlIHN0YXJ0IG1vbnRoIGhhcyBtb3JlXG4gICAgICAgICAgICAvLyBkYXlzIHRoYW4gdGhlIGVuZCBtb250aC5cbiAgICAgICAgICAgIHJldHVybiAtbW9udGhEaWZmKGIsIGEpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGRpZmZlcmVuY2UgaW4gbW9udGhzXG4gICAgICAgIHZhciB3aG9sZU1vbnRoRGlmZiA9IChiLnllYXIoKSAtIGEueWVhcigpKSAqIDEyICsgKGIubW9udGgoKSAtIGEubW9udGgoKSksXG4gICAgICAgICAgICAvLyBiIGlzIGluIChhbmNob3IgLSAxIG1vbnRoLCBhbmNob3IgKyAxIG1vbnRoKVxuICAgICAgICAgICAgYW5jaG9yID0gYS5jbG9uZSgpLmFkZCh3aG9sZU1vbnRoRGlmZiwgJ21vbnRocycpLFxuICAgICAgICAgICAgYW5jaG9yMixcbiAgICAgICAgICAgIGFkanVzdDtcblxuICAgICAgICBpZiAoYiAtIGFuY2hvciA8IDApIHtcbiAgICAgICAgICAgIGFuY2hvcjIgPSBhLmNsb25lKCkuYWRkKHdob2xlTW9udGhEaWZmIC0gMSwgJ21vbnRocycpO1xuICAgICAgICAgICAgLy8gbGluZWFyIGFjcm9zcyB0aGUgbW9udGhcbiAgICAgICAgICAgIGFkanVzdCA9IChiIC0gYW5jaG9yKSAvIChhbmNob3IgLSBhbmNob3IyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFuY2hvcjIgPSBhLmNsb25lKCkuYWRkKHdob2xlTW9udGhEaWZmICsgMSwgJ21vbnRocycpO1xuICAgICAgICAgICAgLy8gbGluZWFyIGFjcm9zcyB0aGUgbW9udGhcbiAgICAgICAgICAgIGFkanVzdCA9IChiIC0gYW5jaG9yKSAvIChhbmNob3IyIC0gYW5jaG9yKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vY2hlY2sgZm9yIG5lZ2F0aXZlIHplcm8sIHJldHVybiB6ZXJvIGlmIG5lZ2F0aXZlIHplcm9cbiAgICAgICAgcmV0dXJuIC0od2hvbGVNb250aERpZmYgKyBhZGp1c3QpIHx8IDA7XG4gICAgfVxuXG4gICAgaG9va3MuZGVmYXVsdEZvcm1hdCA9ICdZWVlZLU1NLUREVEhIOm1tOnNzWic7XG4gICAgaG9va3MuZGVmYXVsdEZvcm1hdFV0YyA9ICdZWVlZLU1NLUREVEhIOm1tOnNzW1pdJztcblxuICAgIGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmxvY2FsZSgnZW4nKS5mb3JtYXQoJ2RkZCBNTU0gREQgWVlZWSBISDptbTpzcyBbR01UXVpaJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9JU09TdHJpbmcoa2VlcE9mZnNldCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdXRjID0ga2VlcE9mZnNldCAhPT0gdHJ1ZSxcbiAgICAgICAgICAgIG0gPSB1dGMgPyB0aGlzLmNsb25lKCkudXRjKCkgOiB0aGlzO1xuICAgICAgICBpZiAobS55ZWFyKCkgPCAwIHx8IG0ueWVhcigpID4gOTk5OSkge1xuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdE1vbWVudChcbiAgICAgICAgICAgICAgICBtLFxuICAgICAgICAgICAgICAgIHV0Y1xuICAgICAgICAgICAgICAgICAgICA/ICdZWVlZWVktTU0tRERbVF1ISDptbTpzcy5TU1NbWl0nXG4gICAgICAgICAgICAgICAgICAgIDogJ1lZWVlZWS1NTS1ERFtUXUhIOm1tOnNzLlNTU1onXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKERhdGUucHJvdG90eXBlLnRvSVNPU3RyaW5nKSkge1xuICAgICAgICAgICAgLy8gbmF0aXZlIGltcGxlbWVudGF0aW9uIGlzIH41MHggZmFzdGVyLCB1c2UgaXQgd2hlbiB3ZSBjYW5cbiAgICAgICAgICAgIGlmICh1dGMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50b0RhdGUoKS50b0lTT1N0cmluZygpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IERhdGUodGhpcy52YWx1ZU9mKCkgKyB0aGlzLnV0Y09mZnNldCgpICogNjAgKiAxMDAwKVxuICAgICAgICAgICAgICAgICAgICAudG9JU09TdHJpbmcoKVxuICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgnWicsIGZvcm1hdE1vbWVudChtLCAnWicpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm9ybWF0TW9tZW50KFxuICAgICAgICAgICAgbSxcbiAgICAgICAgICAgIHV0YyA/ICdZWVlZLU1NLUREW1RdSEg6bW06c3MuU1NTW1pdJyA6ICdZWVlZLU1NLUREW1RdSEg6bW06c3MuU1NTWidcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSBodW1hbiByZWFkYWJsZSByZXByZXNlbnRhdGlvbiBvZiBhIG1vbWVudCB0aGF0IGNhblxuICAgICAqIGFsc28gYmUgZXZhbHVhdGVkIHRvIGdldCBhIG5ldyBtb21lbnQgd2hpY2ggaXMgdGhlIHNhbWVcbiAgICAgKlxuICAgICAqIEBsaW5rIGh0dHBzOi8vbm9kZWpzLm9yZy9kaXN0L2xhdGVzdC9kb2NzL2FwaS91dGlsLmh0bWwjdXRpbF9jdXN0b21faW5zcGVjdF9mdW5jdGlvbl9vbl9vYmplY3RzXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5zcGVjdCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuICdtb21lbnQuaW52YWxpZCgvKiAnICsgdGhpcy5faSArICcgKi8pJztcbiAgICAgICAgfVxuICAgICAgICB2YXIgZnVuYyA9ICdtb21lbnQnLFxuICAgICAgICAgICAgem9uZSA9ICcnLFxuICAgICAgICAgICAgcHJlZml4LFxuICAgICAgICAgICAgeWVhcixcbiAgICAgICAgICAgIGRhdGV0aW1lLFxuICAgICAgICAgICAgc3VmZml4O1xuICAgICAgICBpZiAoIXRoaXMuaXNMb2NhbCgpKSB7XG4gICAgICAgICAgICBmdW5jID0gdGhpcy51dGNPZmZzZXQoKSA9PT0gMCA/ICdtb21lbnQudXRjJyA6ICdtb21lbnQucGFyc2Vab25lJztcbiAgICAgICAgICAgIHpvbmUgPSAnWic7XG4gICAgICAgIH1cbiAgICAgICAgcHJlZml4ID0gJ1snICsgZnVuYyArICcoXCJdJztcbiAgICAgICAgeWVhciA9IDAgPD0gdGhpcy55ZWFyKCkgJiYgdGhpcy55ZWFyKCkgPD0gOTk5OSA/ICdZWVlZJyA6ICdZWVlZWVknO1xuICAgICAgICBkYXRldGltZSA9ICctTU0tRERbVF1ISDptbTpzcy5TU1MnO1xuICAgICAgICBzdWZmaXggPSB6b25lICsgJ1tcIildJztcblxuICAgICAgICByZXR1cm4gdGhpcy5mb3JtYXQocHJlZml4ICsgeWVhciArIGRhdGV0aW1lICsgc3VmZml4KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmb3JtYXQoaW5wdXRTdHJpbmcpIHtcbiAgICAgICAgaWYgKCFpbnB1dFN0cmluZykge1xuICAgICAgICAgICAgaW5wdXRTdHJpbmcgPSB0aGlzLmlzVXRjKClcbiAgICAgICAgICAgICAgICA/IGhvb2tzLmRlZmF1bHRGb3JtYXRVdGNcbiAgICAgICAgICAgICAgICA6IGhvb2tzLmRlZmF1bHRGb3JtYXQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG91dHB1dCA9IGZvcm1hdE1vbWVudCh0aGlzLCBpbnB1dFN0cmluZyk7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5wb3N0Zm9ybWF0KG91dHB1dCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZnJvbSh0aW1lLCB3aXRob3V0U3VmZml4KSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIHRoaXMuaXNWYWxpZCgpICYmXG4gICAgICAgICAgICAoKGlzTW9tZW50KHRpbWUpICYmIHRpbWUuaXNWYWxpZCgpKSB8fCBjcmVhdGVMb2NhbCh0aW1lKS5pc1ZhbGlkKCkpXG4gICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUR1cmF0aW9uKHsgdG86IHRoaXMsIGZyb206IHRpbWUgfSlcbiAgICAgICAgICAgICAgICAubG9jYWxlKHRoaXMubG9jYWxlKCkpXG4gICAgICAgICAgICAgICAgLmh1bWFuaXplKCF3aXRob3V0U3VmZml4KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5pbnZhbGlkRGF0ZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZnJvbU5vdyh3aXRob3V0U3VmZml4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZyb20oY3JlYXRlTG9jYWwoKSwgd2l0aG91dFN1ZmZpeCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG8odGltZSwgd2l0aG91dFN1ZmZpeCkge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgICB0aGlzLmlzVmFsaWQoKSAmJlxuICAgICAgICAgICAgKChpc01vbWVudCh0aW1lKSAmJiB0aW1lLmlzVmFsaWQoKSkgfHwgY3JlYXRlTG9jYWwodGltZSkuaXNWYWxpZCgpKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVEdXJhdGlvbih7IGZyb206IHRoaXMsIHRvOiB0aW1lIH0pXG4gICAgICAgICAgICAgICAgLmxvY2FsZSh0aGlzLmxvY2FsZSgpKVxuICAgICAgICAgICAgICAgIC5odW1hbml6ZSghd2l0aG91dFN1ZmZpeCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkuaW52YWxpZERhdGUoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvTm93KHdpdGhvdXRTdWZmaXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG8oY3JlYXRlTG9jYWwoKSwgd2l0aG91dFN1ZmZpeCk7XG4gICAgfVxuXG4gICAgLy8gSWYgcGFzc2VkIGEgbG9jYWxlIGtleSwgaXQgd2lsbCBzZXQgdGhlIGxvY2FsZSBmb3IgdGhpc1xuICAgIC8vIGluc3RhbmNlLiAgT3RoZXJ3aXNlLCBpdCB3aWxsIHJldHVybiB0aGUgbG9jYWxlIGNvbmZpZ3VyYXRpb25cbiAgICAvLyB2YXJpYWJsZXMgZm9yIHRoaXMgaW5zdGFuY2UuXG4gICAgZnVuY3Rpb24gbG9jYWxlKGtleSkge1xuICAgICAgICB2YXIgbmV3TG9jYWxlRGF0YTtcblxuICAgICAgICBpZiAoa2V5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9sb2NhbGUuX2FiYnI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXdMb2NhbGVEYXRhID0gZ2V0TG9jYWxlKGtleSk7XG4gICAgICAgICAgICBpZiAobmV3TG9jYWxlRGF0YSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbG9jYWxlID0gbmV3TG9jYWxlRGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGxhbmcgPSBkZXByZWNhdGUoXG4gICAgICAgICdtb21lbnQoKS5sYW5nKCkgaXMgZGVwcmVjYXRlZC4gSW5zdGVhZCwgdXNlIG1vbWVudCgpLmxvY2FsZURhdGEoKSB0byBnZXQgdGhlIGxhbmd1YWdlIGNvbmZpZ3VyYXRpb24uIFVzZSBtb21lbnQoKS5sb2NhbGUoKSB0byBjaGFuZ2UgbGFuZ3VhZ2VzLicsXG4gICAgICAgIGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIGlmIChrZXkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICApO1xuXG4gICAgZnVuY3Rpb24gbG9jYWxlRGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvY2FsZTtcbiAgICB9XG5cbiAgICB2YXIgTVNfUEVSX1NFQ09ORCA9IDEwMDAsXG4gICAgICAgIE1TX1BFUl9NSU5VVEUgPSA2MCAqIE1TX1BFUl9TRUNPTkQsXG4gICAgICAgIE1TX1BFUl9IT1VSID0gNjAgKiBNU19QRVJfTUlOVVRFLFxuICAgICAgICBNU19QRVJfNDAwX1lFQVJTID0gKDM2NSAqIDQwMCArIDk3KSAqIDI0ICogTVNfUEVSX0hPVVI7XG5cbiAgICAvLyBhY3R1YWwgbW9kdWxvIC0gaGFuZGxlcyBuZWdhdGl2ZSBudW1iZXJzIChmb3IgZGF0ZXMgYmVmb3JlIDE5NzApOlxuICAgIGZ1bmN0aW9uIG1vZCQxKGRpdmlkZW5kLCBkaXZpc29yKSB7XG4gICAgICAgIHJldHVybiAoKGRpdmlkZW5kICUgZGl2aXNvcikgKyBkaXZpc29yKSAlIGRpdmlzb3I7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9jYWxTdGFydE9mRGF0ZSh5LCBtLCBkKSB7XG4gICAgICAgIC8vIHRoZSBkYXRlIGNvbnN0cnVjdG9yIHJlbWFwcyB5ZWFycyAwLTk5IHRvIDE5MDAtMTk5OVxuICAgICAgICBpZiAoeSA8IDEwMCAmJiB5ID49IDApIHtcbiAgICAgICAgICAgIC8vIHByZXNlcnZlIGxlYXAgeWVhcnMgdXNpbmcgYSBmdWxsIDQwMCB5ZWFyIGN5Y2xlLCB0aGVuIHJlc2V0XG4gICAgICAgICAgICByZXR1cm4gbmV3IERhdGUoeSArIDQwMCwgbSwgZCkgLSBNU19QRVJfNDAwX1lFQVJTO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHksIG0sIGQpLnZhbHVlT2YoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHV0Y1N0YXJ0T2ZEYXRlKHksIG0sIGQpIHtcbiAgICAgICAgLy8gRGF0ZS5VVEMgcmVtYXBzIHllYXJzIDAtOTkgdG8gMTkwMC0xOTk5XG4gICAgICAgIGlmICh5IDwgMTAwICYmIHkgPj0gMCkge1xuICAgICAgICAgICAgLy8gcHJlc2VydmUgbGVhcCB5ZWFycyB1c2luZyBhIGZ1bGwgNDAwIHllYXIgY3ljbGUsIHRoZW4gcmVzZXRcbiAgICAgICAgICAgIHJldHVybiBEYXRlLlVUQyh5ICsgNDAwLCBtLCBkKSAtIE1TX1BFUl80MDBfWUVBUlM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gRGF0ZS5VVEMoeSwgbSwgZCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzdGFydE9mKHVuaXRzKSB7XG4gICAgICAgIHZhciB0aW1lLCBzdGFydE9mRGF0ZTtcbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG4gICAgICAgIGlmICh1bml0cyA9PT0gdW5kZWZpbmVkIHx8IHVuaXRzID09PSAnbWlsbGlzZWNvbmQnIHx8ICF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICBzdGFydE9mRGF0ZSA9IHRoaXMuX2lzVVRDID8gdXRjU3RhcnRPZkRhdGUgOiBsb2NhbFN0YXJ0T2ZEYXRlO1xuXG4gICAgICAgIHN3aXRjaCAodW5pdHMpIHtcbiAgICAgICAgICAgIGNhc2UgJ3llYXInOlxuICAgICAgICAgICAgICAgIHRpbWUgPSBzdGFydE9mRGF0ZSh0aGlzLnllYXIoKSwgMCwgMSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdxdWFydGVyJzpcbiAgICAgICAgICAgICAgICB0aW1lID0gc3RhcnRPZkRhdGUoXG4gICAgICAgICAgICAgICAgICAgIHRoaXMueWVhcigpLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1vbnRoKCkgLSAodGhpcy5tb250aCgpICUgMyksXG4gICAgICAgICAgICAgICAgICAgIDFcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbW9udGgnOlxuICAgICAgICAgICAgICAgIHRpbWUgPSBzdGFydE9mRGF0ZSh0aGlzLnllYXIoKSwgdGhpcy5tb250aCgpLCAxKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3dlZWsnOlxuICAgICAgICAgICAgICAgIHRpbWUgPSBzdGFydE9mRGF0ZShcbiAgICAgICAgICAgICAgICAgICAgdGhpcy55ZWFyKCksXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubW9udGgoKSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kYXRlKCkgLSB0aGlzLndlZWtkYXkoKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdpc29XZWVrJzpcbiAgICAgICAgICAgICAgICB0aW1lID0gc3RhcnRPZkRhdGUoXG4gICAgICAgICAgICAgICAgICAgIHRoaXMueWVhcigpLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1vbnRoKCksXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGF0ZSgpIC0gKHRoaXMuaXNvV2Vla2RheSgpIC0gMSlcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnZGF5JzpcbiAgICAgICAgICAgIGNhc2UgJ2RhdGUnOlxuICAgICAgICAgICAgICAgIHRpbWUgPSBzdGFydE9mRGF0ZSh0aGlzLnllYXIoKSwgdGhpcy5tb250aCgpLCB0aGlzLmRhdGUoKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdob3VyJzpcbiAgICAgICAgICAgICAgICB0aW1lID0gdGhpcy5fZC52YWx1ZU9mKCk7XG4gICAgICAgICAgICAgICAgdGltZSAtPSBtb2QkMShcbiAgICAgICAgICAgICAgICAgICAgdGltZSArICh0aGlzLl9pc1VUQyA/IDAgOiB0aGlzLnV0Y09mZnNldCgpICogTVNfUEVSX01JTlVURSksXG4gICAgICAgICAgICAgICAgICAgIE1TX1BFUl9IT1VSXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgICAgICAgICAgICAgdGltZSA9IHRoaXMuX2QudmFsdWVPZigpO1xuICAgICAgICAgICAgICAgIHRpbWUgLT0gbW9kJDEodGltZSwgTVNfUEVSX01JTlVURSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdzZWNvbmQnOlxuICAgICAgICAgICAgICAgIHRpbWUgPSB0aGlzLl9kLnZhbHVlT2YoKTtcbiAgICAgICAgICAgICAgICB0aW1lIC09IG1vZCQxKHRpbWUsIE1TX1BFUl9TRUNPTkQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fZC5zZXRUaW1lKHRpbWUpO1xuICAgICAgICBob29rcy51cGRhdGVPZmZzZXQodGhpcywgdHJ1ZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVuZE9mKHVuaXRzKSB7XG4gICAgICAgIHZhciB0aW1lLCBzdGFydE9mRGF0ZTtcbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG4gICAgICAgIGlmICh1bml0cyA9PT0gdW5kZWZpbmVkIHx8IHVuaXRzID09PSAnbWlsbGlzZWNvbmQnIHx8ICF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICBzdGFydE9mRGF0ZSA9IHRoaXMuX2lzVVRDID8gdXRjU3RhcnRPZkRhdGUgOiBsb2NhbFN0YXJ0T2ZEYXRlO1xuXG4gICAgICAgIHN3aXRjaCAodW5pdHMpIHtcbiAgICAgICAgICAgIGNhc2UgJ3llYXInOlxuICAgICAgICAgICAgICAgIHRpbWUgPSBzdGFydE9mRGF0ZSh0aGlzLnllYXIoKSArIDEsIDAsIDEpIC0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3F1YXJ0ZXInOlxuICAgICAgICAgICAgICAgIHRpbWUgPVxuICAgICAgICAgICAgICAgICAgICBzdGFydE9mRGF0ZShcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMueWVhcigpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tb250aCgpIC0gKHRoaXMubW9udGgoKSAlIDMpICsgMyxcbiAgICAgICAgICAgICAgICAgICAgICAgIDFcbiAgICAgICAgICAgICAgICAgICAgKSAtIDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdtb250aCc6XG4gICAgICAgICAgICAgICAgdGltZSA9IHN0YXJ0T2ZEYXRlKHRoaXMueWVhcigpLCB0aGlzLm1vbnRoKCkgKyAxLCAxKSAtIDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICd3ZWVrJzpcbiAgICAgICAgICAgICAgICB0aW1lID1cbiAgICAgICAgICAgICAgICAgICAgc3RhcnRPZkRhdGUoXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnllYXIoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubW9udGgoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGF0ZSgpIC0gdGhpcy53ZWVrZGF5KCkgKyA3XG4gICAgICAgICAgICAgICAgICAgICkgLSAxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnaXNvV2Vlayc6XG4gICAgICAgICAgICAgICAgdGltZSA9XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0T2ZEYXRlKFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy55ZWFyKCksXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1vbnRoKCksXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRhdGUoKSAtICh0aGlzLmlzb1dlZWtkYXkoKSAtIDEpICsgN1xuICAgICAgICAgICAgICAgICAgICApIC0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2RheSc6XG4gICAgICAgICAgICBjYXNlICdkYXRlJzpcbiAgICAgICAgICAgICAgICB0aW1lID0gc3RhcnRPZkRhdGUodGhpcy55ZWFyKCksIHRoaXMubW9udGgoKSwgdGhpcy5kYXRlKCkgKyAxKSAtIDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdob3VyJzpcbiAgICAgICAgICAgICAgICB0aW1lID0gdGhpcy5fZC52YWx1ZU9mKCk7XG4gICAgICAgICAgICAgICAgdGltZSArPVxuICAgICAgICAgICAgICAgICAgICBNU19QRVJfSE9VUiAtXG4gICAgICAgICAgICAgICAgICAgIG1vZCQxKFxuICAgICAgICAgICAgICAgICAgICAgICAgdGltZSArICh0aGlzLl9pc1VUQyA/IDAgOiB0aGlzLnV0Y09mZnNldCgpICogTVNfUEVSX01JTlVURSksXG4gICAgICAgICAgICAgICAgICAgICAgICBNU19QRVJfSE9VUlxuICAgICAgICAgICAgICAgICAgICApIC1cbiAgICAgICAgICAgICAgICAgICAgMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgICAgICAgICAgICAgdGltZSA9IHRoaXMuX2QudmFsdWVPZigpO1xuICAgICAgICAgICAgICAgIHRpbWUgKz0gTVNfUEVSX01JTlVURSAtIG1vZCQxKHRpbWUsIE1TX1BFUl9NSU5VVEUpIC0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgICAgICAgICAgICAgdGltZSA9IHRoaXMuX2QudmFsdWVPZigpO1xuICAgICAgICAgICAgICAgIHRpbWUgKz0gTVNfUEVSX1NFQ09ORCAtIG1vZCQxKHRpbWUsIE1TX1BFUl9TRUNPTkQpIC0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2Quc2V0VGltZSh0aW1lKTtcbiAgICAgICAgaG9va3MudXBkYXRlT2Zmc2V0KHRoaXMsIHRydWUpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2YWx1ZU9mKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZC52YWx1ZU9mKCkgLSAodGhpcy5fb2Zmc2V0IHx8IDApICogNjAwMDA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdW5peCgpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IodGhpcy52YWx1ZU9mKCkgLyAxMDAwKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b0RhdGUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZSh0aGlzLnZhbHVlT2YoKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9BcnJheSgpIHtcbiAgICAgICAgdmFyIG0gPSB0aGlzO1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgbS55ZWFyKCksXG4gICAgICAgICAgICBtLm1vbnRoKCksXG4gICAgICAgICAgICBtLmRhdGUoKSxcbiAgICAgICAgICAgIG0uaG91cigpLFxuICAgICAgICAgICAgbS5taW51dGUoKSxcbiAgICAgICAgICAgIG0uc2Vjb25kKCksXG4gICAgICAgICAgICBtLm1pbGxpc2Vjb25kKCksXG4gICAgICAgIF07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9PYmplY3QoKSB7XG4gICAgICAgIHZhciBtID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHllYXJzOiBtLnllYXIoKSxcbiAgICAgICAgICAgIG1vbnRoczogbS5tb250aCgpLFxuICAgICAgICAgICAgZGF0ZTogbS5kYXRlKCksXG4gICAgICAgICAgICBob3VyczogbS5ob3VycygpLFxuICAgICAgICAgICAgbWludXRlczogbS5taW51dGVzKCksXG4gICAgICAgICAgICBzZWNvbmRzOiBtLnNlY29uZHMoKSxcbiAgICAgICAgICAgIG1pbGxpc2Vjb25kczogbS5taWxsaXNlY29uZHMoKSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICAgIC8vIG5ldyBEYXRlKE5hTikudG9KU09OKCkgPT09IG51bGxcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNWYWxpZCgpID8gdGhpcy50b0lTT1N0cmluZygpIDogbnVsbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1ZhbGlkJDIoKSB7XG4gICAgICAgIHJldHVybiBpc1ZhbGlkKHRoaXMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNpbmdGbGFncygpIHtcbiAgICAgICAgcmV0dXJuIGV4dGVuZCh7fSwgZ2V0UGFyc2luZ0ZsYWdzKHRoaXMpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnZhbGlkQXQoKSB7XG4gICAgICAgIHJldHVybiBnZXRQYXJzaW5nRmxhZ3ModGhpcykub3ZlcmZsb3c7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRpb25EYXRhKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaW5wdXQ6IHRoaXMuX2ksXG4gICAgICAgICAgICBmb3JtYXQ6IHRoaXMuX2YsXG4gICAgICAgICAgICBsb2NhbGU6IHRoaXMuX2xvY2FsZSxcbiAgICAgICAgICAgIGlzVVRDOiB0aGlzLl9pc1VUQyxcbiAgICAgICAgICAgIHN0cmljdDogdGhpcy5fc3RyaWN0LFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGFkZEZvcm1hdFRva2VuKCdOJywgMCwgMCwgJ2VyYUFiYnInKTtcbiAgICBhZGRGb3JtYXRUb2tlbignTk4nLCAwLCAwLCAnZXJhQWJicicpO1xuICAgIGFkZEZvcm1hdFRva2VuKCdOTk4nLCAwLCAwLCAnZXJhQWJicicpO1xuICAgIGFkZEZvcm1hdFRva2VuKCdOTk5OJywgMCwgMCwgJ2VyYU5hbWUnKTtcbiAgICBhZGRGb3JtYXRUb2tlbignTk5OTk4nLCAwLCAwLCAnZXJhTmFycm93Jyk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbigneScsIFsneScsIDFdLCAneW8nLCAnZXJhWWVhcicpO1xuICAgIGFkZEZvcm1hdFRva2VuKCd5JywgWyd5eScsIDJdLCAwLCAnZXJhWWVhcicpO1xuICAgIGFkZEZvcm1hdFRva2VuKCd5JywgWyd5eXknLCAzXSwgMCwgJ2VyYVllYXInKTtcbiAgICBhZGRGb3JtYXRUb2tlbigneScsIFsneXl5eScsIDRdLCAwLCAnZXJhWWVhcicpO1xuXG4gICAgYWRkUmVnZXhUb2tlbignTicsIG1hdGNoRXJhQWJicik7XG4gICAgYWRkUmVnZXhUb2tlbignTk4nLCBtYXRjaEVyYUFiYnIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ05OTicsIG1hdGNoRXJhQWJicik7XG4gICAgYWRkUmVnZXhUb2tlbignTk5OTicsIG1hdGNoRXJhTmFtZSk7XG4gICAgYWRkUmVnZXhUb2tlbignTk5OTk4nLCBtYXRjaEVyYU5hcnJvdyk7XG5cbiAgICBhZGRQYXJzZVRva2VuKFsnTicsICdOTicsICdOTk4nLCAnTk5OTicsICdOTk5OTiddLCBmdW5jdGlvbiAoXG4gICAgICAgIGlucHV0LFxuICAgICAgICBhcnJheSxcbiAgICAgICAgY29uZmlnLFxuICAgICAgICB0b2tlblxuICAgICkge1xuICAgICAgICB2YXIgZXJhID0gY29uZmlnLl9sb2NhbGUuZXJhc1BhcnNlKGlucHV0LCB0b2tlbiwgY29uZmlnLl9zdHJpY3QpO1xuICAgICAgICBpZiAoZXJhKSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5lcmEgPSBlcmE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5pbnZhbGlkRXJhID0gaW5wdXQ7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ3knLCBtYXRjaFVuc2lnbmVkKTtcbiAgICBhZGRSZWdleFRva2VuKCd5eScsIG1hdGNoVW5zaWduZWQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ3l5eScsIG1hdGNoVW5zaWduZWQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ3l5eXknLCBtYXRjaFVuc2lnbmVkKTtcbiAgICBhZGRSZWdleFRva2VuKCd5bycsIG1hdGNoRXJhWWVhck9yZGluYWwpO1xuXG4gICAgYWRkUGFyc2VUb2tlbihbJ3knLCAneXknLCAneXl5JywgJ3l5eXknXSwgWUVBUik7XG4gICAgYWRkUGFyc2VUb2tlbihbJ3lvJ10sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZywgdG9rZW4pIHtcbiAgICAgICAgdmFyIG1hdGNoO1xuICAgICAgICBpZiAoY29uZmlnLl9sb2NhbGUuX2VyYVllYXJPcmRpbmFsUmVnZXgpIHtcbiAgICAgICAgICAgIG1hdGNoID0gaW5wdXQubWF0Y2goY29uZmlnLl9sb2NhbGUuX2VyYVllYXJPcmRpbmFsUmVnZXgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbmZpZy5fbG9jYWxlLmVyYVllYXJPcmRpbmFsUGFyc2UpIHtcbiAgICAgICAgICAgIGFycmF5W1lFQVJdID0gY29uZmlnLl9sb2NhbGUuZXJhWWVhck9yZGluYWxQYXJzZShpbnB1dCwgbWF0Y2gpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXJyYXlbWUVBUl0gPSBwYXJzZUludChpbnB1dCwgMTApO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBsb2NhbGVFcmFzKG0sIGZvcm1hdCkge1xuICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgIGwsXG4gICAgICAgICAgICBkYXRlLFxuICAgICAgICAgICAgZXJhcyA9IHRoaXMuX2VyYXMgfHwgZ2V0TG9jYWxlKCdlbicpLl9lcmFzO1xuICAgICAgICBmb3IgKGkgPSAwLCBsID0gZXJhcy5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIGVyYXNbaV0uc2luY2UpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgICAgICAvLyB0cnVuY2F0ZSB0aW1lXG4gICAgICAgICAgICAgICAgICAgIGRhdGUgPSBob29rcyhlcmFzW2ldLnNpbmNlKS5zdGFydE9mKCdkYXknKTtcbiAgICAgICAgICAgICAgICAgICAgZXJhc1tpXS5zaW5jZSA9IGRhdGUudmFsdWVPZigpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc3dpdGNoICh0eXBlb2YgZXJhc1tpXS51bnRpbCkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgICAgICAgICAgICAgICAgIGVyYXNbaV0udW50aWwgPSArSW5maW5pdHk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICAgICAgICAgIC8vIHRydW5jYXRlIHRpbWVcbiAgICAgICAgICAgICAgICAgICAgZGF0ZSA9IGhvb2tzKGVyYXNbaV0udW50aWwpLnN0YXJ0T2YoJ2RheScpLnZhbHVlT2YoKTtcbiAgICAgICAgICAgICAgICAgICAgZXJhc1tpXS51bnRpbCA9IGRhdGUudmFsdWVPZigpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXJhcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb2NhbGVFcmFzUGFyc2UoZXJhTmFtZSwgZm9ybWF0LCBzdHJpY3QpIHtcbiAgICAgICAgdmFyIGksXG4gICAgICAgICAgICBsLFxuICAgICAgICAgICAgZXJhcyA9IHRoaXMuZXJhcygpLFxuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIGFiYnIsXG4gICAgICAgICAgICBuYXJyb3c7XG4gICAgICAgIGVyYU5hbWUgPSBlcmFOYW1lLnRvVXBwZXJDYXNlKCk7XG5cbiAgICAgICAgZm9yIChpID0gMCwgbCA9IGVyYXMubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgICAgICAgICBuYW1lID0gZXJhc1tpXS5uYW1lLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICBhYmJyID0gZXJhc1tpXS5hYmJyLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICBuYXJyb3cgPSBlcmFzW2ldLm5hcnJvdy50b1VwcGVyQ2FzZSgpO1xuXG4gICAgICAgICAgICBpZiAoc3RyaWN0KSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChmb3JtYXQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnTic6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ05OJzpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnTk5OJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhYmJyID09PSBlcmFOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVyYXNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICBjYXNlICdOTk5OJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuYW1lID09PSBlcmFOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVyYXNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICBjYXNlICdOTk5OTic6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmFycm93ID09PSBlcmFOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVyYXNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKFtuYW1lLCBhYmJyLCBuYXJyb3ddLmluZGV4T2YoZXJhTmFtZSkgPj0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlcmFzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9jYWxlRXJhc0NvbnZlcnRZZWFyKGVyYSwgeWVhcikge1xuICAgICAgICB2YXIgZGlyID0gZXJhLnNpbmNlIDw9IGVyYS51bnRpbCA/ICsxIDogLTE7XG4gICAgICAgIGlmICh5ZWFyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBob29rcyhlcmEuc2luY2UpLnllYXIoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBob29rcyhlcmEuc2luY2UpLnllYXIoKSArICh5ZWFyIC0gZXJhLm9mZnNldCkgKiBkaXI7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRFcmFOYW1lKCkge1xuICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgIGwsXG4gICAgICAgICAgICB2YWwsXG4gICAgICAgICAgICBlcmFzID0gdGhpcy5sb2NhbGVEYXRhKCkuZXJhcygpO1xuICAgICAgICBmb3IgKGkgPSAwLCBsID0gZXJhcy5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgICAgIC8vIHRydW5jYXRlIHRpbWVcbiAgICAgICAgICAgIHZhbCA9IHRoaXMuY2xvbmUoKS5zdGFydE9mKCdkYXknKS52YWx1ZU9mKCk7XG5cbiAgICAgICAgICAgIGlmIChlcmFzW2ldLnNpbmNlIDw9IHZhbCAmJiB2YWwgPD0gZXJhc1tpXS51bnRpbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlcmFzW2ldLm5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXJhc1tpXS51bnRpbCA8PSB2YWwgJiYgdmFsIDw9IGVyYXNbaV0uc2luY2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXJhc1tpXS5uYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldEVyYU5hcnJvdygpIHtcbiAgICAgICAgdmFyIGksXG4gICAgICAgICAgICBsLFxuICAgICAgICAgICAgdmFsLFxuICAgICAgICAgICAgZXJhcyA9IHRoaXMubG9jYWxlRGF0YSgpLmVyYXMoKTtcbiAgICAgICAgZm9yIChpID0gMCwgbCA9IGVyYXMubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgICAgICAgICAvLyB0cnVuY2F0ZSB0aW1lXG4gICAgICAgICAgICB2YWwgPSB0aGlzLmNsb25lKCkuc3RhcnRPZignZGF5JykudmFsdWVPZigpO1xuXG4gICAgICAgICAgICBpZiAoZXJhc1tpXS5zaW5jZSA8PSB2YWwgJiYgdmFsIDw9IGVyYXNbaV0udW50aWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXJhc1tpXS5uYXJyb3c7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXJhc1tpXS51bnRpbCA8PSB2YWwgJiYgdmFsIDw9IGVyYXNbaV0uc2luY2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXJhc1tpXS5uYXJyb3c7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0RXJhQWJicigpIHtcbiAgICAgICAgdmFyIGksXG4gICAgICAgICAgICBsLFxuICAgICAgICAgICAgdmFsLFxuICAgICAgICAgICAgZXJhcyA9IHRoaXMubG9jYWxlRGF0YSgpLmVyYXMoKTtcbiAgICAgICAgZm9yIChpID0gMCwgbCA9IGVyYXMubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgICAgICAgICAvLyB0cnVuY2F0ZSB0aW1lXG4gICAgICAgICAgICB2YWwgPSB0aGlzLmNsb25lKCkuc3RhcnRPZignZGF5JykudmFsdWVPZigpO1xuXG4gICAgICAgICAgICBpZiAoZXJhc1tpXS5zaW5jZSA8PSB2YWwgJiYgdmFsIDw9IGVyYXNbaV0udW50aWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXJhc1tpXS5hYmJyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVyYXNbaV0udW50aWwgPD0gdmFsICYmIHZhbCA8PSBlcmFzW2ldLnNpbmNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVyYXNbaV0uYWJicjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRFcmFZZWFyKCkge1xuICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgIGwsXG4gICAgICAgICAgICBkaXIsXG4gICAgICAgICAgICB2YWwsXG4gICAgICAgICAgICBlcmFzID0gdGhpcy5sb2NhbGVEYXRhKCkuZXJhcygpO1xuICAgICAgICBmb3IgKGkgPSAwLCBsID0gZXJhcy5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgICAgIGRpciA9IGVyYXNbaV0uc2luY2UgPD0gZXJhc1tpXS51bnRpbCA/ICsxIDogLTE7XG5cbiAgICAgICAgICAgIC8vIHRydW5jYXRlIHRpbWVcbiAgICAgICAgICAgIHZhbCA9IHRoaXMuY2xvbmUoKS5zdGFydE9mKCdkYXknKS52YWx1ZU9mKCk7XG5cbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAoZXJhc1tpXS5zaW5jZSA8PSB2YWwgJiYgdmFsIDw9IGVyYXNbaV0udW50aWwpIHx8XG4gICAgICAgICAgICAgICAgKGVyYXNbaV0udW50aWwgPD0gdmFsICYmIHZhbCA8PSBlcmFzW2ldLnNpbmNlKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAgICAgKHRoaXMueWVhcigpIC0gaG9va3MoZXJhc1tpXS5zaW5jZSkueWVhcigpKSAqIGRpciArXG4gICAgICAgICAgICAgICAgICAgIGVyYXNbaV0ub2Zmc2V0XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLnllYXIoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlcmFzTmFtZVJlZ2V4KGlzU3RyaWN0KSB7XG4gICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX2VyYXNOYW1lUmVnZXgnKSkge1xuICAgICAgICAgICAgY29tcHV0ZUVyYXNQYXJzZS5jYWxsKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpc1N0cmljdCA/IHRoaXMuX2VyYXNOYW1lUmVnZXggOiB0aGlzLl9lcmFzUmVnZXg7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXJhc0FiYnJSZWdleChpc1N0cmljdCkge1xuICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ19lcmFzQWJiclJlZ2V4JykpIHtcbiAgICAgICAgICAgIGNvbXB1dGVFcmFzUGFyc2UuY2FsbCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXNTdHJpY3QgPyB0aGlzLl9lcmFzQWJiclJlZ2V4IDogdGhpcy5fZXJhc1JlZ2V4O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVyYXNOYXJyb3dSZWdleChpc1N0cmljdCkge1xuICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ19lcmFzTmFycm93UmVnZXgnKSkge1xuICAgICAgICAgICAgY29tcHV0ZUVyYXNQYXJzZS5jYWxsKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpc1N0cmljdCA/IHRoaXMuX2VyYXNOYXJyb3dSZWdleCA6IHRoaXMuX2VyYXNSZWdleDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYXRjaEVyYUFiYnIoaXNTdHJpY3QsIGxvY2FsZSkge1xuICAgICAgICByZXR1cm4gbG9jYWxlLmVyYXNBYmJyUmVnZXgoaXNTdHJpY3QpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1hdGNoRXJhTmFtZShpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGUuZXJhc05hbWVSZWdleChpc1N0cmljdCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWF0Y2hFcmFOYXJyb3coaXNTdHJpY3QsIGxvY2FsZSkge1xuICAgICAgICByZXR1cm4gbG9jYWxlLmVyYXNOYXJyb3dSZWdleChpc1N0cmljdCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWF0Y2hFcmFZZWFyT3JkaW5hbChpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGUuX2VyYVllYXJPcmRpbmFsUmVnZXggfHwgbWF0Y2hVbnNpZ25lZDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb21wdXRlRXJhc1BhcnNlKCkge1xuICAgICAgICB2YXIgYWJiclBpZWNlcyA9IFtdLFxuICAgICAgICAgICAgbmFtZVBpZWNlcyA9IFtdLFxuICAgICAgICAgICAgbmFycm93UGllY2VzID0gW10sXG4gICAgICAgICAgICBtaXhlZFBpZWNlcyA9IFtdLFxuICAgICAgICAgICAgaSxcbiAgICAgICAgICAgIGwsXG4gICAgICAgICAgICBlcmFzID0gdGhpcy5lcmFzKCk7XG5cbiAgICAgICAgZm9yIChpID0gMCwgbCA9IGVyYXMubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgICAgICAgICBuYW1lUGllY2VzLnB1c2gocmVnZXhFc2NhcGUoZXJhc1tpXS5uYW1lKSk7XG4gICAgICAgICAgICBhYmJyUGllY2VzLnB1c2gocmVnZXhFc2NhcGUoZXJhc1tpXS5hYmJyKSk7XG4gICAgICAgICAgICBuYXJyb3dQaWVjZXMucHVzaChyZWdleEVzY2FwZShlcmFzW2ldLm5hcnJvdykpO1xuXG4gICAgICAgICAgICBtaXhlZFBpZWNlcy5wdXNoKHJlZ2V4RXNjYXBlKGVyYXNbaV0ubmFtZSkpO1xuICAgICAgICAgICAgbWl4ZWRQaWVjZXMucHVzaChyZWdleEVzY2FwZShlcmFzW2ldLmFiYnIpKTtcbiAgICAgICAgICAgIG1peGVkUGllY2VzLnB1c2gocmVnZXhFc2NhcGUoZXJhc1tpXS5uYXJyb3cpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2VyYXNSZWdleCA9IG5ldyBSZWdFeHAoJ14oJyArIG1peGVkUGllY2VzLmpvaW4oJ3wnKSArICcpJywgJ2knKTtcbiAgICAgICAgdGhpcy5fZXJhc05hbWVSZWdleCA9IG5ldyBSZWdFeHAoJ14oJyArIG5hbWVQaWVjZXMuam9pbignfCcpICsgJyknLCAnaScpO1xuICAgICAgICB0aGlzLl9lcmFzQWJiclJlZ2V4ID0gbmV3IFJlZ0V4cCgnXignICsgYWJiclBpZWNlcy5qb2luKCd8JykgKyAnKScsICdpJyk7XG4gICAgICAgIHRoaXMuX2VyYXNOYXJyb3dSZWdleCA9IG5ldyBSZWdFeHAoXG4gICAgICAgICAgICAnXignICsgbmFycm93UGllY2VzLmpvaW4oJ3wnKSArICcpJyxcbiAgICAgICAgICAgICdpJ1xuICAgICAgICApO1xuICAgIH1cblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnZ2cnLCAyXSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy53ZWVrWWVhcigpICUgMTAwO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydHRycsIDJdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzb1dlZWtZZWFyKCkgJSAxMDA7XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBhZGRXZWVrWWVhckZvcm1hdFRva2VuKHRva2VuLCBnZXR0ZXIpIHtcbiAgICAgICAgYWRkRm9ybWF0VG9rZW4oMCwgW3Rva2VuLCB0b2tlbi5sZW5ndGhdLCAwLCBnZXR0ZXIpO1xuICAgIH1cblxuICAgIGFkZFdlZWtZZWFyRm9ybWF0VG9rZW4oJ2dnZ2cnLCAnd2Vla1llYXInKTtcbiAgICBhZGRXZWVrWWVhckZvcm1hdFRva2VuKCdnZ2dnZycsICd3ZWVrWWVhcicpO1xuICAgIGFkZFdlZWtZZWFyRm9ybWF0VG9rZW4oJ0dHR0cnLCAnaXNvV2Vla1llYXInKTtcbiAgICBhZGRXZWVrWWVhckZvcm1hdFRva2VuKCdHR0dHRycsICdpc29XZWVrWWVhcicpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCd3ZWVrWWVhcicsICdnZycpO1xuICAgIGFkZFVuaXRBbGlhcygnaXNvV2Vla1llYXInLCAnR0cnKTtcblxuICAgIC8vIFBSSU9SSVRZXG5cbiAgICBhZGRVbml0UHJpb3JpdHkoJ3dlZWtZZWFyJywgMSk7XG4gICAgYWRkVW5pdFByaW9yaXR5KCdpc29XZWVrWWVhcicsIDEpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignRycsIG1hdGNoU2lnbmVkKTtcbiAgICBhZGRSZWdleFRva2VuKCdnJywgbWF0Y2hTaWduZWQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0dHJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2dnJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0dHR0cnLCBtYXRjaDF0bzQsIG1hdGNoNCk7XG4gICAgYWRkUmVnZXhUb2tlbignZ2dnZycsIG1hdGNoMXRvNCwgbWF0Y2g0KTtcbiAgICBhZGRSZWdleFRva2VuKCdHR0dHRycsIG1hdGNoMXRvNiwgbWF0Y2g2KTtcbiAgICBhZGRSZWdleFRva2VuKCdnZ2dnZycsIG1hdGNoMXRvNiwgbWF0Y2g2KTtcblxuICAgIGFkZFdlZWtQYXJzZVRva2VuKFsnZ2dnZycsICdnZ2dnZycsICdHR0dHJywgJ0dHR0dHJ10sIGZ1bmN0aW9uIChcbiAgICAgICAgaW5wdXQsXG4gICAgICAgIHdlZWssXG4gICAgICAgIGNvbmZpZyxcbiAgICAgICAgdG9rZW5cbiAgICApIHtcbiAgICAgICAgd2Vla1t0b2tlbi5zdWJzdHIoMCwgMildID0gdG9JbnQoaW5wdXQpO1xuICAgIH0pO1xuXG4gICAgYWRkV2Vla1BhcnNlVG9rZW4oWydnZycsICdHRyddLCBmdW5jdGlvbiAoaW5wdXQsIHdlZWssIGNvbmZpZywgdG9rZW4pIHtcbiAgICAgICAgd2Vla1t0b2tlbl0gPSBob29rcy5wYXJzZVR3b0RpZ2l0WWVhcihpbnB1dCk7XG4gICAgfSk7XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICBmdW5jdGlvbiBnZXRTZXRXZWVrWWVhcihpbnB1dCkge1xuICAgICAgICByZXR1cm4gZ2V0U2V0V2Vla1llYXJIZWxwZXIuY2FsbChcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgIHRoaXMud2VlaygpLFxuICAgICAgICAgICAgdGhpcy53ZWVrZGF5KCksXG4gICAgICAgICAgICB0aGlzLmxvY2FsZURhdGEoKS5fd2Vlay5kb3csXG4gICAgICAgICAgICB0aGlzLmxvY2FsZURhdGEoKS5fd2Vlay5kb3lcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTZXRJU09XZWVrWWVhcihpbnB1dCkge1xuICAgICAgICByZXR1cm4gZ2V0U2V0V2Vla1llYXJIZWxwZXIuY2FsbChcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgIHRoaXMuaXNvV2VlaygpLFxuICAgICAgICAgICAgdGhpcy5pc29XZWVrZGF5KCksXG4gICAgICAgICAgICAxLFxuICAgICAgICAgICAgNFxuICAgICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldElTT1dlZWtzSW5ZZWFyKCkge1xuICAgICAgICByZXR1cm4gd2Vla3NJblllYXIodGhpcy55ZWFyKCksIDEsIDQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldElTT1dlZWtzSW5JU09XZWVrWWVhcigpIHtcbiAgICAgICAgcmV0dXJuIHdlZWtzSW5ZZWFyKHRoaXMuaXNvV2Vla1llYXIoKSwgMSwgNCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0V2Vla3NJblllYXIoKSB7XG4gICAgICAgIHZhciB3ZWVrSW5mbyA9IHRoaXMubG9jYWxlRGF0YSgpLl93ZWVrO1xuICAgICAgICByZXR1cm4gd2Vla3NJblllYXIodGhpcy55ZWFyKCksIHdlZWtJbmZvLmRvdywgd2Vla0luZm8uZG95KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRXZWVrc0luV2Vla1llYXIoKSB7XG4gICAgICAgIHZhciB3ZWVrSW5mbyA9IHRoaXMubG9jYWxlRGF0YSgpLl93ZWVrO1xuICAgICAgICByZXR1cm4gd2Vla3NJblllYXIodGhpcy53ZWVrWWVhcigpLCB3ZWVrSW5mby5kb3csIHdlZWtJbmZvLmRveSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U2V0V2Vla1llYXJIZWxwZXIoaW5wdXQsIHdlZWssIHdlZWtkYXksIGRvdywgZG95KSB7XG4gICAgICAgIHZhciB3ZWVrc1RhcmdldDtcbiAgICAgICAgaWYgKGlucHV0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB3ZWVrT2ZZZWFyKHRoaXMsIGRvdywgZG95KS55ZWFyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd2Vla3NUYXJnZXQgPSB3ZWVrc0luWWVhcihpbnB1dCwgZG93LCBkb3kpO1xuICAgICAgICAgICAgaWYgKHdlZWsgPiB3ZWVrc1RhcmdldCkge1xuICAgICAgICAgICAgICAgIHdlZWsgPSB3ZWVrc1RhcmdldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzZXRXZWVrQWxsLmNhbGwodGhpcywgaW5wdXQsIHdlZWssIHdlZWtkYXksIGRvdywgZG95KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldFdlZWtBbGwod2Vla1llYXIsIHdlZWssIHdlZWtkYXksIGRvdywgZG95KSB7XG4gICAgICAgIHZhciBkYXlPZlllYXJEYXRhID0gZGF5T2ZZZWFyRnJvbVdlZWtzKHdlZWtZZWFyLCB3ZWVrLCB3ZWVrZGF5LCBkb3csIGRveSksXG4gICAgICAgICAgICBkYXRlID0gY3JlYXRlVVRDRGF0ZShkYXlPZlllYXJEYXRhLnllYXIsIDAsIGRheU9mWWVhckRhdGEuZGF5T2ZZZWFyKTtcblxuICAgICAgICB0aGlzLnllYXIoZGF0ZS5nZXRVVENGdWxsWWVhcigpKTtcbiAgICAgICAgdGhpcy5tb250aChkYXRlLmdldFVUQ01vbnRoKCkpO1xuICAgICAgICB0aGlzLmRhdGUoZGF0ZS5nZXRVVENEYXRlKCkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbignUScsIDAsICdRbycsICdxdWFydGVyJyk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ3F1YXJ0ZXInLCAnUScpO1xuXG4gICAgLy8gUFJJT1JJVFlcblxuICAgIGFkZFVuaXRQcmlvcml0eSgncXVhcnRlcicsIDcpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignUScsIG1hdGNoMSk7XG4gICAgYWRkUGFyc2VUb2tlbignUScsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICAgICAgYXJyYXlbTU9OVEhdID0gKHRvSW50KGlucHV0KSAtIDEpICogMztcbiAgICB9KTtcblxuICAgIC8vIE1PTUVOVFNcblxuICAgIGZ1bmN0aW9uIGdldFNldFF1YXJ0ZXIoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0ID09IG51bGxcbiAgICAgICAgICAgID8gTWF0aC5jZWlsKCh0aGlzLm1vbnRoKCkgKyAxKSAvIDMpXG4gICAgICAgICAgICA6IHRoaXMubW9udGgoKGlucHV0IC0gMSkgKiAzICsgKHRoaXMubW9udGgoKSAlIDMpKTtcbiAgICB9XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbignRCcsIFsnREQnLCAyXSwgJ0RvJywgJ2RhdGUnKTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygnZGF0ZScsICdEJyk7XG5cbiAgICAvLyBQUklPUklUWVxuICAgIGFkZFVuaXRQcmlvcml0eSgnZGF0ZScsIDkpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignRCcsIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignREQnLCBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgYWRkUmVnZXhUb2tlbignRG8nLCBmdW5jdGlvbiAoaXNTdHJpY3QsIGxvY2FsZSkge1xuICAgICAgICAvLyBUT0RPOiBSZW1vdmUgXCJvcmRpbmFsUGFyc2VcIiBmYWxsYmFjayBpbiBuZXh0IG1ham9yIHJlbGVhc2UuXG4gICAgICAgIHJldHVybiBpc1N0cmljdFxuICAgICAgICAgICAgPyBsb2NhbGUuX2RheU9mTW9udGhPcmRpbmFsUGFyc2UgfHwgbG9jYWxlLl9vcmRpbmFsUGFyc2VcbiAgICAgICAgICAgIDogbG9jYWxlLl9kYXlPZk1vbnRoT3JkaW5hbFBhcnNlTGVuaWVudDtcbiAgICB9KTtcblxuICAgIGFkZFBhcnNlVG9rZW4oWydEJywgJ0REJ10sIERBVEUpO1xuICAgIGFkZFBhcnNlVG9rZW4oJ0RvJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSkge1xuICAgICAgICBhcnJheVtEQVRFXSA9IHRvSW50KGlucHV0Lm1hdGNoKG1hdGNoMXRvMilbMF0pO1xuICAgIH0pO1xuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgdmFyIGdldFNldERheU9mTW9udGggPSBtYWtlR2V0U2V0KCdEYXRlJywgdHJ1ZSk7XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbignREREJywgWydEREREJywgM10sICdERERvJywgJ2RheU9mWWVhcicpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCdkYXlPZlllYXInLCAnREREJyk7XG5cbiAgICAvLyBQUklPUklUWVxuICAgIGFkZFVuaXRQcmlvcml0eSgnZGF5T2ZZZWFyJywgNCk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdEREQnLCBtYXRjaDF0bzMpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0REREQnLCBtYXRjaDMpO1xuICAgIGFkZFBhcnNlVG9rZW4oWydEREQnLCAnRERERCddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgY29uZmlnLl9kYXlPZlllYXIgPSB0b0ludChpbnB1dCk7XG4gICAgfSk7XG5cbiAgICAvLyBIRUxQRVJTXG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICBmdW5jdGlvbiBnZXRTZXREYXlPZlllYXIoaW5wdXQpIHtcbiAgICAgICAgdmFyIGRheU9mWWVhciA9XG4gICAgICAgICAgICBNYXRoLnJvdW5kKFxuICAgICAgICAgICAgICAgICh0aGlzLmNsb25lKCkuc3RhcnRPZignZGF5JykgLSB0aGlzLmNsb25lKCkuc3RhcnRPZigneWVhcicpKSAvIDg2NGU1XG4gICAgICAgICAgICApICsgMTtcbiAgICAgICAgcmV0dXJuIGlucHV0ID09IG51bGwgPyBkYXlPZlllYXIgOiB0aGlzLmFkZChpbnB1dCAtIGRheU9mWWVhciwgJ2QnKTtcbiAgICB9XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbignbScsIFsnbW0nLCAyXSwgMCwgJ21pbnV0ZScpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCdtaW51dGUnLCAnbScpO1xuXG4gICAgLy8gUFJJT1JJVFlcblxuICAgIGFkZFVuaXRQcmlvcml0eSgnbWludXRlJywgMTQpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignbScsIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignbW0nLCBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgYWRkUGFyc2VUb2tlbihbJ20nLCAnbW0nXSwgTUlOVVRFKTtcblxuICAgIC8vIE1PTUVOVFNcblxuICAgIHZhciBnZXRTZXRNaW51dGUgPSBtYWtlR2V0U2V0KCdNaW51dGVzJywgZmFsc2UpO1xuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ3MnLCBbJ3NzJywgMl0sIDAsICdzZWNvbmQnKTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygnc2Vjb25kJywgJ3MnKTtcblxuICAgIC8vIFBSSU9SSVRZXG5cbiAgICBhZGRVbml0UHJpb3JpdHkoJ3NlY29uZCcsIDE1KTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ3MnLCBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ3NzJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgIGFkZFBhcnNlVG9rZW4oWydzJywgJ3NzJ10sIFNFQ09ORCk7XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICB2YXIgZ2V0U2V0U2Vjb25kID0gbWFrZUdldFNldCgnU2Vjb25kcycsIGZhbHNlKTtcblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCdTJywgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gfn4odGhpcy5taWxsaXNlY29uZCgpIC8gMTAwKTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnU1MnLCAyXSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gfn4odGhpcy5taWxsaXNlY29uZCgpIC8gMTApO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTU1MnLCAzXSwgMCwgJ21pbGxpc2Vjb25kJyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTJywgNF0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmQoKSAqIDEwO1xuICAgIH0pO1xuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnU1NTU1MnLCA1XSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZCgpICogMTAwO1xuICAgIH0pO1xuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnU1NTU1NTJywgNl0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmQoKSAqIDEwMDA7XG4gICAgfSk7XG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTU1NTJywgN10sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmQoKSAqIDEwMDAwO1xuICAgIH0pO1xuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnU1NTU1NTU1MnLCA4XSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZCgpICogMTAwMDAwO1xuICAgIH0pO1xuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnU1NTU1NTU1NTJywgOV0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmQoKSAqIDEwMDAwMDA7XG4gICAgfSk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ21pbGxpc2Vjb25kJywgJ21zJyk7XG5cbiAgICAvLyBQUklPUklUWVxuXG4gICAgYWRkVW5pdFByaW9yaXR5KCdtaWxsaXNlY29uZCcsIDE2KTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ1MnLCBtYXRjaDF0bzMsIG1hdGNoMSk7XG4gICAgYWRkUmVnZXhUb2tlbignU1MnLCBtYXRjaDF0bzMsIG1hdGNoMik7XG4gICAgYWRkUmVnZXhUb2tlbignU1NTJywgbWF0Y2gxdG8zLCBtYXRjaDMpO1xuXG4gICAgdmFyIHRva2VuLCBnZXRTZXRNaWxsaXNlY29uZDtcbiAgICBmb3IgKHRva2VuID0gJ1NTU1MnOyB0b2tlbi5sZW5ndGggPD0gOTsgdG9rZW4gKz0gJ1MnKSB7XG4gICAgICAgIGFkZFJlZ2V4VG9rZW4odG9rZW4sIG1hdGNoVW5zaWduZWQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlTXMoaW5wdXQsIGFycmF5KSB7XG4gICAgICAgIGFycmF5W01JTExJU0VDT05EXSA9IHRvSW50KCgnMC4nICsgaW5wdXQpICogMTAwMCk7XG4gICAgfVxuXG4gICAgZm9yICh0b2tlbiA9ICdTJzsgdG9rZW4ubGVuZ3RoIDw9IDk7IHRva2VuICs9ICdTJykge1xuICAgICAgICBhZGRQYXJzZVRva2VuKHRva2VuLCBwYXJzZU1zKTtcbiAgICB9XG5cbiAgICBnZXRTZXRNaWxsaXNlY29uZCA9IG1ha2VHZXRTZXQoJ01pbGxpc2Vjb25kcycsIGZhbHNlKTtcblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCd6JywgMCwgMCwgJ3pvbmVBYmJyJyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oJ3p6JywgMCwgMCwgJ3pvbmVOYW1lJyk7XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICBmdW5jdGlvbiBnZXRab25lQWJicigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzVVRDID8gJ1VUQycgOiAnJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRab25lTmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzVVRDID8gJ0Nvb3JkaW5hdGVkIFVuaXZlcnNhbCBUaW1lJyA6ICcnO1xuICAgIH1cblxuICAgIHZhciBwcm90byA9IE1vbWVudC5wcm90b3R5cGU7XG5cbiAgICBwcm90by5hZGQgPSBhZGQ7XG4gICAgcHJvdG8uY2FsZW5kYXIgPSBjYWxlbmRhciQxO1xuICAgIHByb3RvLmNsb25lID0gY2xvbmU7XG4gICAgcHJvdG8uZGlmZiA9IGRpZmY7XG4gICAgcHJvdG8uZW5kT2YgPSBlbmRPZjtcbiAgICBwcm90by5mb3JtYXQgPSBmb3JtYXQ7XG4gICAgcHJvdG8uZnJvbSA9IGZyb207XG4gICAgcHJvdG8uZnJvbU5vdyA9IGZyb21Ob3c7XG4gICAgcHJvdG8udG8gPSB0bztcbiAgICBwcm90by50b05vdyA9IHRvTm93O1xuICAgIHByb3RvLmdldCA9IHN0cmluZ0dldDtcbiAgICBwcm90by5pbnZhbGlkQXQgPSBpbnZhbGlkQXQ7XG4gICAgcHJvdG8uaXNBZnRlciA9IGlzQWZ0ZXI7XG4gICAgcHJvdG8uaXNCZWZvcmUgPSBpc0JlZm9yZTtcbiAgICBwcm90by5pc0JldHdlZW4gPSBpc0JldHdlZW47XG4gICAgcHJvdG8uaXNTYW1lID0gaXNTYW1lO1xuICAgIHByb3RvLmlzU2FtZU9yQWZ0ZXIgPSBpc1NhbWVPckFmdGVyO1xuICAgIHByb3RvLmlzU2FtZU9yQmVmb3JlID0gaXNTYW1lT3JCZWZvcmU7XG4gICAgcHJvdG8uaXNWYWxpZCA9IGlzVmFsaWQkMjtcbiAgICBwcm90by5sYW5nID0gbGFuZztcbiAgICBwcm90by5sb2NhbGUgPSBsb2NhbGU7XG4gICAgcHJvdG8ubG9jYWxlRGF0YSA9IGxvY2FsZURhdGE7XG4gICAgcHJvdG8ubWF4ID0gcHJvdG90eXBlTWF4O1xuICAgIHByb3RvLm1pbiA9IHByb3RvdHlwZU1pbjtcbiAgICBwcm90by5wYXJzaW5nRmxhZ3MgPSBwYXJzaW5nRmxhZ3M7XG4gICAgcHJvdG8uc2V0ID0gc3RyaW5nU2V0O1xuICAgIHByb3RvLnN0YXJ0T2YgPSBzdGFydE9mO1xuICAgIHByb3RvLnN1YnRyYWN0ID0gc3VidHJhY3Q7XG4gICAgcHJvdG8udG9BcnJheSA9IHRvQXJyYXk7XG4gICAgcHJvdG8udG9PYmplY3QgPSB0b09iamVjdDtcbiAgICBwcm90by50b0RhdGUgPSB0b0RhdGU7XG4gICAgcHJvdG8udG9JU09TdHJpbmcgPSB0b0lTT1N0cmluZztcbiAgICBwcm90by5pbnNwZWN0ID0gaW5zcGVjdDtcbiAgICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLmZvciAhPSBudWxsKSB7XG4gICAgICAgIHByb3RvW1N5bWJvbC5mb3IoJ25vZGVqcy51dGlsLmluc3BlY3QuY3VzdG9tJyldID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICdNb21lbnQ8JyArIHRoaXMuZm9ybWF0KCkgKyAnPic7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHByb3RvLnRvSlNPTiA9IHRvSlNPTjtcbiAgICBwcm90by50b1N0cmluZyA9IHRvU3RyaW5nO1xuICAgIHByb3RvLnVuaXggPSB1bml4O1xuICAgIHByb3RvLnZhbHVlT2YgPSB2YWx1ZU9mO1xuICAgIHByb3RvLmNyZWF0aW9uRGF0YSA9IGNyZWF0aW9uRGF0YTtcbiAgICBwcm90by5lcmFOYW1lID0gZ2V0RXJhTmFtZTtcbiAgICBwcm90by5lcmFOYXJyb3cgPSBnZXRFcmFOYXJyb3c7XG4gICAgcHJvdG8uZXJhQWJiciA9IGdldEVyYUFiYnI7XG4gICAgcHJvdG8uZXJhWWVhciA9IGdldEVyYVllYXI7XG4gICAgcHJvdG8ueWVhciA9IGdldFNldFllYXI7XG4gICAgcHJvdG8uaXNMZWFwWWVhciA9IGdldElzTGVhcFllYXI7XG4gICAgcHJvdG8ud2Vla1llYXIgPSBnZXRTZXRXZWVrWWVhcjtcbiAgICBwcm90by5pc29XZWVrWWVhciA9IGdldFNldElTT1dlZWtZZWFyO1xuICAgIHByb3RvLnF1YXJ0ZXIgPSBwcm90by5xdWFydGVycyA9IGdldFNldFF1YXJ0ZXI7XG4gICAgcHJvdG8ubW9udGggPSBnZXRTZXRNb250aDtcbiAgICBwcm90by5kYXlzSW5Nb250aCA9IGdldERheXNJbk1vbnRoO1xuICAgIHByb3RvLndlZWsgPSBwcm90by53ZWVrcyA9IGdldFNldFdlZWs7XG4gICAgcHJvdG8uaXNvV2VlayA9IHByb3RvLmlzb1dlZWtzID0gZ2V0U2V0SVNPV2VlaztcbiAgICBwcm90by53ZWVrc0luWWVhciA9IGdldFdlZWtzSW5ZZWFyO1xuICAgIHByb3RvLndlZWtzSW5XZWVrWWVhciA9IGdldFdlZWtzSW5XZWVrWWVhcjtcbiAgICBwcm90by5pc29XZWVrc0luWWVhciA9IGdldElTT1dlZWtzSW5ZZWFyO1xuICAgIHByb3RvLmlzb1dlZWtzSW5JU09XZWVrWWVhciA9IGdldElTT1dlZWtzSW5JU09XZWVrWWVhcjtcbiAgICBwcm90by5kYXRlID0gZ2V0U2V0RGF5T2ZNb250aDtcbiAgICBwcm90by5kYXkgPSBwcm90by5kYXlzID0gZ2V0U2V0RGF5T2ZXZWVrO1xuICAgIHByb3RvLndlZWtkYXkgPSBnZXRTZXRMb2NhbGVEYXlPZldlZWs7XG4gICAgcHJvdG8uaXNvV2Vla2RheSA9IGdldFNldElTT0RheU9mV2VlaztcbiAgICBwcm90by5kYXlPZlllYXIgPSBnZXRTZXREYXlPZlllYXI7XG4gICAgcHJvdG8uaG91ciA9IHByb3RvLmhvdXJzID0gZ2V0U2V0SG91cjtcbiAgICBwcm90by5taW51dGUgPSBwcm90by5taW51dGVzID0gZ2V0U2V0TWludXRlO1xuICAgIHByb3RvLnNlY29uZCA9IHByb3RvLnNlY29uZHMgPSBnZXRTZXRTZWNvbmQ7XG4gICAgcHJvdG8ubWlsbGlzZWNvbmQgPSBwcm90by5taWxsaXNlY29uZHMgPSBnZXRTZXRNaWxsaXNlY29uZDtcbiAgICBwcm90by51dGNPZmZzZXQgPSBnZXRTZXRPZmZzZXQ7XG4gICAgcHJvdG8udXRjID0gc2V0T2Zmc2V0VG9VVEM7XG4gICAgcHJvdG8ubG9jYWwgPSBzZXRPZmZzZXRUb0xvY2FsO1xuICAgIHByb3RvLnBhcnNlWm9uZSA9IHNldE9mZnNldFRvUGFyc2VkT2Zmc2V0O1xuICAgIHByb3RvLmhhc0FsaWduZWRIb3VyT2Zmc2V0ID0gaGFzQWxpZ25lZEhvdXJPZmZzZXQ7XG4gICAgcHJvdG8uaXNEU1QgPSBpc0RheWxpZ2h0U2F2aW5nVGltZTtcbiAgICBwcm90by5pc0xvY2FsID0gaXNMb2NhbDtcbiAgICBwcm90by5pc1V0Y09mZnNldCA9IGlzVXRjT2Zmc2V0O1xuICAgIHByb3RvLmlzVXRjID0gaXNVdGM7XG4gICAgcHJvdG8uaXNVVEMgPSBpc1V0YztcbiAgICBwcm90by56b25lQWJiciA9IGdldFpvbmVBYmJyO1xuICAgIHByb3RvLnpvbmVOYW1lID0gZ2V0Wm9uZU5hbWU7XG4gICAgcHJvdG8uZGF0ZXMgPSBkZXByZWNhdGUoXG4gICAgICAgICdkYXRlcyBhY2Nlc3NvciBpcyBkZXByZWNhdGVkLiBVc2UgZGF0ZSBpbnN0ZWFkLicsXG4gICAgICAgIGdldFNldERheU9mTW9udGhcbiAgICApO1xuICAgIHByb3RvLm1vbnRocyA9IGRlcHJlY2F0ZShcbiAgICAgICAgJ21vbnRocyBhY2Nlc3NvciBpcyBkZXByZWNhdGVkLiBVc2UgbW9udGggaW5zdGVhZCcsXG4gICAgICAgIGdldFNldE1vbnRoXG4gICAgKTtcbiAgICBwcm90by55ZWFycyA9IGRlcHJlY2F0ZShcbiAgICAgICAgJ3llYXJzIGFjY2Vzc29yIGlzIGRlcHJlY2F0ZWQuIFVzZSB5ZWFyIGluc3RlYWQnLFxuICAgICAgICBnZXRTZXRZZWFyXG4gICAgKTtcbiAgICBwcm90by56b25lID0gZGVwcmVjYXRlKFxuICAgICAgICAnbW9tZW50KCkuem9uZSBpcyBkZXByZWNhdGVkLCB1c2UgbW9tZW50KCkudXRjT2Zmc2V0IGluc3RlYWQuIGh0dHA6Ly9tb21lbnRqcy5jb20vZ3VpZGVzLyMvd2FybmluZ3Mvem9uZS8nLFxuICAgICAgICBnZXRTZXRab25lXG4gICAgKTtcbiAgICBwcm90by5pc0RTVFNoaWZ0ZWQgPSBkZXByZWNhdGUoXG4gICAgICAgICdpc0RTVFNoaWZ0ZWQgaXMgZGVwcmVjYXRlZC4gU2VlIGh0dHA6Ly9tb21lbnRqcy5jb20vZ3VpZGVzLyMvd2FybmluZ3MvZHN0LXNoaWZ0ZWQvIGZvciBtb3JlIGluZm9ybWF0aW9uJyxcbiAgICAgICAgaXNEYXlsaWdodFNhdmluZ1RpbWVTaGlmdGVkXG4gICAgKTtcblxuICAgIGZ1bmN0aW9uIGNyZWF0ZVVuaXgoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUxvY2FsKGlucHV0ICogMTAwMCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlSW5ab25lKCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlTG9jYWwuYXBwbHkobnVsbCwgYXJndW1lbnRzKS5wYXJzZVpvbmUoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcmVQYXJzZVBvc3RGb3JtYXQoc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgfVxuXG4gICAgdmFyIHByb3RvJDEgPSBMb2NhbGUucHJvdG90eXBlO1xuXG4gICAgcHJvdG8kMS5jYWxlbmRhciA9IGNhbGVuZGFyO1xuICAgIHByb3RvJDEubG9uZ0RhdGVGb3JtYXQgPSBsb25nRGF0ZUZvcm1hdDtcbiAgICBwcm90byQxLmludmFsaWREYXRlID0gaW52YWxpZERhdGU7XG4gICAgcHJvdG8kMS5vcmRpbmFsID0gb3JkaW5hbDtcbiAgICBwcm90byQxLnByZXBhcnNlID0gcHJlUGFyc2VQb3N0Rm9ybWF0O1xuICAgIHByb3RvJDEucG9zdGZvcm1hdCA9IHByZVBhcnNlUG9zdEZvcm1hdDtcbiAgICBwcm90byQxLnJlbGF0aXZlVGltZSA9IHJlbGF0aXZlVGltZTtcbiAgICBwcm90byQxLnBhc3RGdXR1cmUgPSBwYXN0RnV0dXJlO1xuICAgIHByb3RvJDEuc2V0ID0gc2V0O1xuICAgIHByb3RvJDEuZXJhcyA9IGxvY2FsZUVyYXM7XG4gICAgcHJvdG8kMS5lcmFzUGFyc2UgPSBsb2NhbGVFcmFzUGFyc2U7XG4gICAgcHJvdG8kMS5lcmFzQ29udmVydFllYXIgPSBsb2NhbGVFcmFzQ29udmVydFllYXI7XG4gICAgcHJvdG8kMS5lcmFzQWJiclJlZ2V4ID0gZXJhc0FiYnJSZWdleDtcbiAgICBwcm90byQxLmVyYXNOYW1lUmVnZXggPSBlcmFzTmFtZVJlZ2V4O1xuICAgIHByb3RvJDEuZXJhc05hcnJvd1JlZ2V4ID0gZXJhc05hcnJvd1JlZ2V4O1xuXG4gICAgcHJvdG8kMS5tb250aHMgPSBsb2NhbGVNb250aHM7XG4gICAgcHJvdG8kMS5tb250aHNTaG9ydCA9IGxvY2FsZU1vbnRoc1Nob3J0O1xuICAgIHByb3RvJDEubW9udGhzUGFyc2UgPSBsb2NhbGVNb250aHNQYXJzZTtcbiAgICBwcm90byQxLm1vbnRoc1JlZ2V4ID0gbW9udGhzUmVnZXg7XG4gICAgcHJvdG8kMS5tb250aHNTaG9ydFJlZ2V4ID0gbW9udGhzU2hvcnRSZWdleDtcbiAgICBwcm90byQxLndlZWsgPSBsb2NhbGVXZWVrO1xuICAgIHByb3RvJDEuZmlyc3REYXlPZlllYXIgPSBsb2NhbGVGaXJzdERheU9mWWVhcjtcbiAgICBwcm90byQxLmZpcnN0RGF5T2ZXZWVrID0gbG9jYWxlRmlyc3REYXlPZldlZWs7XG5cbiAgICBwcm90byQxLndlZWtkYXlzID0gbG9jYWxlV2Vla2RheXM7XG4gICAgcHJvdG8kMS53ZWVrZGF5c01pbiA9IGxvY2FsZVdlZWtkYXlzTWluO1xuICAgIHByb3RvJDEud2Vla2RheXNTaG9ydCA9IGxvY2FsZVdlZWtkYXlzU2hvcnQ7XG4gICAgcHJvdG8kMS53ZWVrZGF5c1BhcnNlID0gbG9jYWxlV2Vla2RheXNQYXJzZTtcblxuICAgIHByb3RvJDEud2Vla2RheXNSZWdleCA9IHdlZWtkYXlzUmVnZXg7XG4gICAgcHJvdG8kMS53ZWVrZGF5c1Nob3J0UmVnZXggPSB3ZWVrZGF5c1Nob3J0UmVnZXg7XG4gICAgcHJvdG8kMS53ZWVrZGF5c01pblJlZ2V4ID0gd2Vla2RheXNNaW5SZWdleDtcblxuICAgIHByb3RvJDEuaXNQTSA9IGxvY2FsZUlzUE07XG4gICAgcHJvdG8kMS5tZXJpZGllbSA9IGxvY2FsZU1lcmlkaWVtO1xuXG4gICAgZnVuY3Rpb24gZ2V0JDEoZm9ybWF0LCBpbmRleCwgZmllbGQsIHNldHRlcikge1xuICAgICAgICB2YXIgbG9jYWxlID0gZ2V0TG9jYWxlKCksXG4gICAgICAgICAgICB1dGMgPSBjcmVhdGVVVEMoKS5zZXQoc2V0dGVyLCBpbmRleCk7XG4gICAgICAgIHJldHVybiBsb2NhbGVbZmllbGRdKHV0YywgZm9ybWF0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaXN0TW9udGhzSW1wbChmb3JtYXQsIGluZGV4LCBmaWVsZCkge1xuICAgICAgICBpZiAoaXNOdW1iZXIoZm9ybWF0KSkge1xuICAgICAgICAgICAgaW5kZXggPSBmb3JtYXQ7XG4gICAgICAgICAgICBmb3JtYXQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBmb3JtYXQgPSBmb3JtYXQgfHwgJyc7XG5cbiAgICAgICAgaWYgKGluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXQkMShmb3JtYXQsIGluZGV4LCBmaWVsZCwgJ21vbnRoJyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgIG91dCA9IFtdO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMTI7IGkrKykge1xuICAgICAgICAgICAgb3V0W2ldID0gZ2V0JDEoZm9ybWF0LCBpLCBmaWVsZCwgJ21vbnRoJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG5cbiAgICAvLyAoKVxuICAgIC8vICg1KVxuICAgIC8vIChmbXQsIDUpXG4gICAgLy8gKGZtdClcbiAgICAvLyAodHJ1ZSlcbiAgICAvLyAodHJ1ZSwgNSlcbiAgICAvLyAodHJ1ZSwgZm10LCA1KVxuICAgIC8vICh0cnVlLCBmbXQpXG4gICAgZnVuY3Rpb24gbGlzdFdlZWtkYXlzSW1wbChsb2NhbGVTb3J0ZWQsIGZvcm1hdCwgaW5kZXgsIGZpZWxkKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbG9jYWxlU29ydGVkID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgIGlmIChpc051bWJlcihmb3JtYXQpKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBmb3JtYXQ7XG4gICAgICAgICAgICAgICAgZm9ybWF0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3JtYXQgPSBmb3JtYXQgfHwgJyc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3JtYXQgPSBsb2NhbGVTb3J0ZWQ7XG4gICAgICAgICAgICBpbmRleCA9IGZvcm1hdDtcbiAgICAgICAgICAgIGxvY2FsZVNvcnRlZCA9IGZhbHNlO1xuXG4gICAgICAgICAgICBpZiAoaXNOdW1iZXIoZm9ybWF0KSkge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gZm9ybWF0O1xuICAgICAgICAgICAgICAgIGZvcm1hdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9ybWF0ID0gZm9ybWF0IHx8ICcnO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxvY2FsZSA9IGdldExvY2FsZSgpLFxuICAgICAgICAgICAgc2hpZnQgPSBsb2NhbGVTb3J0ZWQgPyBsb2NhbGUuX3dlZWsuZG93IDogMCxcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICBvdXQgPSBbXTtcblxuICAgICAgICBpZiAoaW5kZXggIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGdldCQxKGZvcm1hdCwgKGluZGV4ICsgc2hpZnQpICUgNywgZmllbGQsICdkYXknKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCA3OyBpKyspIHtcbiAgICAgICAgICAgIG91dFtpXSA9IGdldCQxKGZvcm1hdCwgKGkgKyBzaGlmdCkgJSA3LCBmaWVsZCwgJ2RheScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGlzdE1vbnRocyhmb3JtYXQsIGluZGV4KSB7XG4gICAgICAgIHJldHVybiBsaXN0TW9udGhzSW1wbChmb3JtYXQsIGluZGV4LCAnbW9udGhzJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGlzdE1vbnRoc1Nob3J0KGZvcm1hdCwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGxpc3RNb250aHNJbXBsKGZvcm1hdCwgaW5kZXgsICdtb250aHNTaG9ydCcpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpc3RXZWVrZGF5cyhsb2NhbGVTb3J0ZWQsIGZvcm1hdCwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGxpc3RXZWVrZGF5c0ltcGwobG9jYWxlU29ydGVkLCBmb3JtYXQsIGluZGV4LCAnd2Vla2RheXMnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaXN0V2Vla2RheXNTaG9ydChsb2NhbGVTb3J0ZWQsIGZvcm1hdCwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGxpc3RXZWVrZGF5c0ltcGwobG9jYWxlU29ydGVkLCBmb3JtYXQsIGluZGV4LCAnd2Vla2RheXNTaG9ydCcpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpc3RXZWVrZGF5c01pbihsb2NhbGVTb3J0ZWQsIGZvcm1hdCwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGxpc3RXZWVrZGF5c0ltcGwobG9jYWxlU29ydGVkLCBmb3JtYXQsIGluZGV4LCAnd2Vla2RheXNNaW4nKTtcbiAgICB9XG5cbiAgICBnZXRTZXRHbG9iYWxMb2NhbGUoJ2VuJywge1xuICAgICAgICBlcmFzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc2luY2U6ICcwMDAxLTAxLTAxJyxcbiAgICAgICAgICAgICAgICB1bnRpbDogK0luZmluaXR5LFxuICAgICAgICAgICAgICAgIG9mZnNldDogMSxcbiAgICAgICAgICAgICAgICBuYW1lOiAnQW5ubyBEb21pbmknLFxuICAgICAgICAgICAgICAgIG5hcnJvdzogJ0FEJyxcbiAgICAgICAgICAgICAgICBhYmJyOiAnQUQnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzaW5jZTogJzAwMDAtMTItMzEnLFxuICAgICAgICAgICAgICAgIHVudGlsOiAtSW5maW5pdHksXG4gICAgICAgICAgICAgICAgb2Zmc2V0OiAxLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdCZWZvcmUgQ2hyaXN0JyxcbiAgICAgICAgICAgICAgICBuYXJyb3c6ICdCQycsXG4gICAgICAgICAgICAgICAgYWJicjogJ0JDJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0sXG4gICAgICAgIGRheU9mTW9udGhPcmRpbmFsUGFyc2U6IC9cXGR7MSwyfSh0aHxzdHxuZHxyZCkvLFxuICAgICAgICBvcmRpbmFsOiBmdW5jdGlvbiAobnVtYmVyKSB7XG4gICAgICAgICAgICB2YXIgYiA9IG51bWJlciAlIDEwLFxuICAgICAgICAgICAgICAgIG91dHB1dCA9XG4gICAgICAgICAgICAgICAgICAgIHRvSW50KChudW1iZXIgJSAxMDApIC8gMTApID09PSAxXG4gICAgICAgICAgICAgICAgICAgICAgICA/ICd0aCdcbiAgICAgICAgICAgICAgICAgICAgICAgIDogYiA9PT0gMVxuICAgICAgICAgICAgICAgICAgICAgICAgPyAnc3QnXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGIgPT09IDJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gJ25kJ1xuICAgICAgICAgICAgICAgICAgICAgICAgOiBiID09PSAzXG4gICAgICAgICAgICAgICAgICAgICAgICA/ICdyZCdcbiAgICAgICAgICAgICAgICAgICAgICAgIDogJ3RoJztcbiAgICAgICAgICAgIHJldHVybiBudW1iZXIgKyBvdXRwdXQ7XG4gICAgICAgIH0sXG4gICAgfSk7XG5cbiAgICAvLyBTaWRlIGVmZmVjdCBpbXBvcnRzXG5cbiAgICBob29rcy5sYW5nID0gZGVwcmVjYXRlKFxuICAgICAgICAnbW9tZW50LmxhbmcgaXMgZGVwcmVjYXRlZC4gVXNlIG1vbWVudC5sb2NhbGUgaW5zdGVhZC4nLFxuICAgICAgICBnZXRTZXRHbG9iYWxMb2NhbGVcbiAgICApO1xuICAgIGhvb2tzLmxhbmdEYXRhID0gZGVwcmVjYXRlKFxuICAgICAgICAnbW9tZW50LmxhbmdEYXRhIGlzIGRlcHJlY2F0ZWQuIFVzZSBtb21lbnQubG9jYWxlRGF0YSBpbnN0ZWFkLicsXG4gICAgICAgIGdldExvY2FsZVxuICAgICk7XG5cbiAgICB2YXIgbWF0aEFicyA9IE1hdGguYWJzO1xuXG4gICAgZnVuY3Rpb24gYWJzKCkge1xuICAgICAgICB2YXIgZGF0YSA9IHRoaXMuX2RhdGE7XG5cbiAgICAgICAgdGhpcy5fbWlsbGlzZWNvbmRzID0gbWF0aEFicyh0aGlzLl9taWxsaXNlY29uZHMpO1xuICAgICAgICB0aGlzLl9kYXlzID0gbWF0aEFicyh0aGlzLl9kYXlzKTtcbiAgICAgICAgdGhpcy5fbW9udGhzID0gbWF0aEFicyh0aGlzLl9tb250aHMpO1xuXG4gICAgICAgIGRhdGEubWlsbGlzZWNvbmRzID0gbWF0aEFicyhkYXRhLm1pbGxpc2Vjb25kcyk7XG4gICAgICAgIGRhdGEuc2Vjb25kcyA9IG1hdGhBYnMoZGF0YS5zZWNvbmRzKTtcbiAgICAgICAgZGF0YS5taW51dGVzID0gbWF0aEFicyhkYXRhLm1pbnV0ZXMpO1xuICAgICAgICBkYXRhLmhvdXJzID0gbWF0aEFicyhkYXRhLmhvdXJzKTtcbiAgICAgICAgZGF0YS5tb250aHMgPSBtYXRoQWJzKGRhdGEubW9udGhzKTtcbiAgICAgICAgZGF0YS55ZWFycyA9IG1hdGhBYnMoZGF0YS55ZWFycyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkU3VidHJhY3QkMShkdXJhdGlvbiwgaW5wdXQsIHZhbHVlLCBkaXJlY3Rpb24pIHtcbiAgICAgICAgdmFyIG90aGVyID0gY3JlYXRlRHVyYXRpb24oaW5wdXQsIHZhbHVlKTtcblxuICAgICAgICBkdXJhdGlvbi5fbWlsbGlzZWNvbmRzICs9IGRpcmVjdGlvbiAqIG90aGVyLl9taWxsaXNlY29uZHM7XG4gICAgICAgIGR1cmF0aW9uLl9kYXlzICs9IGRpcmVjdGlvbiAqIG90aGVyLl9kYXlzO1xuICAgICAgICBkdXJhdGlvbi5fbW9udGhzICs9IGRpcmVjdGlvbiAqIG90aGVyLl9tb250aHM7XG5cbiAgICAgICAgcmV0dXJuIGR1cmF0aW9uLl9idWJibGUoKTtcbiAgICB9XG5cbiAgICAvLyBzdXBwb3J0cyBvbmx5IDIuMC1zdHlsZSBhZGQoMSwgJ3MnKSBvciBhZGQoZHVyYXRpb24pXG4gICAgZnVuY3Rpb24gYWRkJDEoaW5wdXQsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBhZGRTdWJ0cmFjdCQxKHRoaXMsIGlucHV0LCB2YWx1ZSwgMSk7XG4gICAgfVxuXG4gICAgLy8gc3VwcG9ydHMgb25seSAyLjAtc3R5bGUgc3VidHJhY3QoMSwgJ3MnKSBvciBzdWJ0cmFjdChkdXJhdGlvbilcbiAgICBmdW5jdGlvbiBzdWJ0cmFjdCQxKGlucHV0LCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gYWRkU3VidHJhY3QkMSh0aGlzLCBpbnB1dCwgdmFsdWUsIC0xKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhYnNDZWlsKG51bWJlcikge1xuICAgICAgICBpZiAobnVtYmVyIDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IobnVtYmVyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmNlaWwobnVtYmVyKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGJ1YmJsZSgpIHtcbiAgICAgICAgdmFyIG1pbGxpc2Vjb25kcyA9IHRoaXMuX21pbGxpc2Vjb25kcyxcbiAgICAgICAgICAgIGRheXMgPSB0aGlzLl9kYXlzLFxuICAgICAgICAgICAgbW9udGhzID0gdGhpcy5fbW9udGhzLFxuICAgICAgICAgICAgZGF0YSA9IHRoaXMuX2RhdGEsXG4gICAgICAgICAgICBzZWNvbmRzLFxuICAgICAgICAgICAgbWludXRlcyxcbiAgICAgICAgICAgIGhvdXJzLFxuICAgICAgICAgICAgeWVhcnMsXG4gICAgICAgICAgICBtb250aHNGcm9tRGF5cztcblxuICAgICAgICAvLyBpZiB3ZSBoYXZlIGEgbWl4IG9mIHBvc2l0aXZlIGFuZCBuZWdhdGl2ZSB2YWx1ZXMsIGJ1YmJsZSBkb3duIGZpcnN0XG4gICAgICAgIC8vIGNoZWNrOiBodHRwczovL2dpdGh1Yi5jb20vbW9tZW50L21vbWVudC9pc3N1ZXMvMjE2NlxuICAgICAgICBpZiAoXG4gICAgICAgICAgICAhKFxuICAgICAgICAgICAgICAgIChtaWxsaXNlY29uZHMgPj0gMCAmJiBkYXlzID49IDAgJiYgbW9udGhzID49IDApIHx8XG4gICAgICAgICAgICAgICAgKG1pbGxpc2Vjb25kcyA8PSAwICYmIGRheXMgPD0gMCAmJiBtb250aHMgPD0gMClcbiAgICAgICAgICAgIClcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBtaWxsaXNlY29uZHMgKz0gYWJzQ2VpbChtb250aHNUb0RheXMobW9udGhzKSArIGRheXMpICogODY0ZTU7XG4gICAgICAgICAgICBkYXlzID0gMDtcbiAgICAgICAgICAgIG1vbnRocyA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUaGUgZm9sbG93aW5nIGNvZGUgYnViYmxlcyB1cCB2YWx1ZXMsIHNlZSB0aGUgdGVzdHMgZm9yXG4gICAgICAgIC8vIGV4YW1wbGVzIG9mIHdoYXQgdGhhdCBtZWFucy5cbiAgICAgICAgZGF0YS5taWxsaXNlY29uZHMgPSBtaWxsaXNlY29uZHMgJSAxMDAwO1xuXG4gICAgICAgIHNlY29uZHMgPSBhYnNGbG9vcihtaWxsaXNlY29uZHMgLyAxMDAwKTtcbiAgICAgICAgZGF0YS5zZWNvbmRzID0gc2Vjb25kcyAlIDYwO1xuXG4gICAgICAgIG1pbnV0ZXMgPSBhYnNGbG9vcihzZWNvbmRzIC8gNjApO1xuICAgICAgICBkYXRhLm1pbnV0ZXMgPSBtaW51dGVzICUgNjA7XG5cbiAgICAgICAgaG91cnMgPSBhYnNGbG9vcihtaW51dGVzIC8gNjApO1xuICAgICAgICBkYXRhLmhvdXJzID0gaG91cnMgJSAyNDtcblxuICAgICAgICBkYXlzICs9IGFic0Zsb29yKGhvdXJzIC8gMjQpO1xuXG4gICAgICAgIC8vIGNvbnZlcnQgZGF5cyB0byBtb250aHNcbiAgICAgICAgbW9udGhzRnJvbURheXMgPSBhYnNGbG9vcihkYXlzVG9Nb250aHMoZGF5cykpO1xuICAgICAgICBtb250aHMgKz0gbW9udGhzRnJvbURheXM7XG4gICAgICAgIGRheXMgLT0gYWJzQ2VpbChtb250aHNUb0RheXMobW9udGhzRnJvbURheXMpKTtcblxuICAgICAgICAvLyAxMiBtb250aHMgLT4gMSB5ZWFyXG4gICAgICAgIHllYXJzID0gYWJzRmxvb3IobW9udGhzIC8gMTIpO1xuICAgICAgICBtb250aHMgJT0gMTI7XG5cbiAgICAgICAgZGF0YS5kYXlzID0gZGF5cztcbiAgICAgICAgZGF0YS5tb250aHMgPSBtb250aHM7XG4gICAgICAgIGRhdGEueWVhcnMgPSB5ZWFycztcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkYXlzVG9Nb250aHMoZGF5cykge1xuICAgICAgICAvLyA0MDAgeWVhcnMgaGF2ZSAxNDYwOTcgZGF5cyAodGFraW5nIGludG8gYWNjb3VudCBsZWFwIHllYXIgcnVsZXMpXG4gICAgICAgIC8vIDQwMCB5ZWFycyBoYXZlIDEyIG1vbnRocyA9PT0gNDgwMFxuICAgICAgICByZXR1cm4gKGRheXMgKiA0ODAwKSAvIDE0NjA5NztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtb250aHNUb0RheXMobW9udGhzKSB7XG4gICAgICAgIC8vIHRoZSByZXZlcnNlIG9mIGRheXNUb01vbnRoc1xuICAgICAgICByZXR1cm4gKG1vbnRocyAqIDE0NjA5NykgLyA0ODAwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFzKHVuaXRzKSB7XG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBOYU47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRheXMsXG4gICAgICAgICAgICBtb250aHMsXG4gICAgICAgICAgICBtaWxsaXNlY29uZHMgPSB0aGlzLl9taWxsaXNlY29uZHM7XG5cbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG5cbiAgICAgICAgaWYgKHVuaXRzID09PSAnbW9udGgnIHx8IHVuaXRzID09PSAncXVhcnRlcicgfHwgdW5pdHMgPT09ICd5ZWFyJykge1xuICAgICAgICAgICAgZGF5cyA9IHRoaXMuX2RheXMgKyBtaWxsaXNlY29uZHMgLyA4NjRlNTtcbiAgICAgICAgICAgIG1vbnRocyA9IHRoaXMuX21vbnRocyArIGRheXNUb01vbnRocyhkYXlzKTtcbiAgICAgICAgICAgIHN3aXRjaCAodW5pdHMpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdtb250aCc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtb250aHM7XG4gICAgICAgICAgICAgICAgY2FzZSAncXVhcnRlcic6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtb250aHMgLyAzO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3llYXInOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbW9udGhzIC8gMTI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBoYW5kbGUgbWlsbGlzZWNvbmRzIHNlcGFyYXRlbHkgYmVjYXVzZSBvZiBmbG9hdGluZyBwb2ludCBtYXRoIGVycm9ycyAoaXNzdWUgIzE4NjcpXG4gICAgICAgICAgICBkYXlzID0gdGhpcy5fZGF5cyArIE1hdGgucm91bmQobW9udGhzVG9EYXlzKHRoaXMuX21vbnRocykpO1xuICAgICAgICAgICAgc3dpdGNoICh1bml0cykge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3dlZWsnOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF5cyAvIDcgKyBtaWxsaXNlY29uZHMgLyA2MDQ4ZTU7XG4gICAgICAgICAgICAgICAgY2FzZSAnZGF5JzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRheXMgKyBtaWxsaXNlY29uZHMgLyA4NjRlNTtcbiAgICAgICAgICAgICAgICBjYXNlICdob3VyJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRheXMgKiAyNCArIG1pbGxpc2Vjb25kcyAvIDM2ZTU7XG4gICAgICAgICAgICAgICAgY2FzZSAnbWludXRlJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRheXMgKiAxNDQwICsgbWlsbGlzZWNvbmRzIC8gNmU0O1xuICAgICAgICAgICAgICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXlzICogODY0MDAgKyBtaWxsaXNlY29uZHMgLyAxMDAwO1xuICAgICAgICAgICAgICAgIC8vIE1hdGguZmxvb3IgcHJldmVudHMgZmxvYXRpbmcgcG9pbnQgbWF0aCBlcnJvcnMgaGVyZVxuICAgICAgICAgICAgICAgIGNhc2UgJ21pbGxpc2Vjb25kJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IoZGF5cyAqIDg2NGU1KSArIG1pbGxpc2Vjb25kcztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gdW5pdCAnICsgdW5pdHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gVE9ETzogVXNlIHRoaXMuYXMoJ21zJyk/XG4gICAgZnVuY3Rpb24gdmFsdWVPZiQxKCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICB0aGlzLl9taWxsaXNlY29uZHMgK1xuICAgICAgICAgICAgdGhpcy5fZGF5cyAqIDg2NGU1ICtcbiAgICAgICAgICAgICh0aGlzLl9tb250aHMgJSAxMikgKiAyNTkyZTYgK1xuICAgICAgICAgICAgdG9JbnQodGhpcy5fbW9udGhzIC8gMTIpICogMzE1MzZlNlxuICAgICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1ha2VBcyhhbGlhcykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXMoYWxpYXMpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHZhciBhc01pbGxpc2Vjb25kcyA9IG1ha2VBcygnbXMnKSxcbiAgICAgICAgYXNTZWNvbmRzID0gbWFrZUFzKCdzJyksXG4gICAgICAgIGFzTWludXRlcyA9IG1ha2VBcygnbScpLFxuICAgICAgICBhc0hvdXJzID0gbWFrZUFzKCdoJyksXG4gICAgICAgIGFzRGF5cyA9IG1ha2VBcygnZCcpLFxuICAgICAgICBhc1dlZWtzID0gbWFrZUFzKCd3JyksXG4gICAgICAgIGFzTW9udGhzID0gbWFrZUFzKCdNJyksXG4gICAgICAgIGFzUXVhcnRlcnMgPSBtYWtlQXMoJ1EnKSxcbiAgICAgICAgYXNZZWFycyA9IG1ha2VBcygneScpO1xuXG4gICAgZnVuY3Rpb24gY2xvbmUkMSgpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUR1cmF0aW9uKHRoaXMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldCQyKHVuaXRzKSB7XG4gICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xuICAgICAgICByZXR1cm4gdGhpcy5pc1ZhbGlkKCkgPyB0aGlzW3VuaXRzICsgJ3MnXSgpIDogTmFOO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1ha2VHZXR0ZXIobmFtZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXNWYWxpZCgpID8gdGhpcy5fZGF0YVtuYW1lXSA6IE5hTjtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgbWlsbGlzZWNvbmRzID0gbWFrZUdldHRlcignbWlsbGlzZWNvbmRzJyksXG4gICAgICAgIHNlY29uZHMgPSBtYWtlR2V0dGVyKCdzZWNvbmRzJyksXG4gICAgICAgIG1pbnV0ZXMgPSBtYWtlR2V0dGVyKCdtaW51dGVzJyksXG4gICAgICAgIGhvdXJzID0gbWFrZUdldHRlcignaG91cnMnKSxcbiAgICAgICAgZGF5cyA9IG1ha2VHZXR0ZXIoJ2RheXMnKSxcbiAgICAgICAgbW9udGhzID0gbWFrZUdldHRlcignbW9udGhzJyksXG4gICAgICAgIHllYXJzID0gbWFrZUdldHRlcigneWVhcnMnKTtcblxuICAgIGZ1bmN0aW9uIHdlZWtzKCkge1xuICAgICAgICByZXR1cm4gYWJzRmxvb3IodGhpcy5kYXlzKCkgLyA3KTtcbiAgICB9XG5cbiAgICB2YXIgcm91bmQgPSBNYXRoLnJvdW5kLFxuICAgICAgICB0aHJlc2hvbGRzID0ge1xuICAgICAgICAgICAgc3M6IDQ0LCAvLyBhIGZldyBzZWNvbmRzIHRvIHNlY29uZHNcbiAgICAgICAgICAgIHM6IDQ1LCAvLyBzZWNvbmRzIHRvIG1pbnV0ZVxuICAgICAgICAgICAgbTogNDUsIC8vIG1pbnV0ZXMgdG8gaG91clxuICAgICAgICAgICAgaDogMjIsIC8vIGhvdXJzIHRvIGRheVxuICAgICAgICAgICAgZDogMjYsIC8vIGRheXMgdG8gbW9udGgvd2Vla1xuICAgICAgICAgICAgdzogbnVsbCwgLy8gd2Vla3MgdG8gbW9udGhcbiAgICAgICAgICAgIE06IDExLCAvLyBtb250aHMgdG8geWVhclxuICAgICAgICB9O1xuXG4gICAgLy8gaGVscGVyIGZ1bmN0aW9uIGZvciBtb21lbnQuZm4uZnJvbSwgbW9tZW50LmZuLmZyb21Ob3csIGFuZCBtb21lbnQuZHVyYXRpb24uZm4uaHVtYW5pemVcbiAgICBmdW5jdGlvbiBzdWJzdGl0dXRlVGltZUFnbyhzdHJpbmcsIG51bWJlciwgd2l0aG91dFN1ZmZpeCwgaXNGdXR1cmUsIGxvY2FsZSkge1xuICAgICAgICByZXR1cm4gbG9jYWxlLnJlbGF0aXZlVGltZShudW1iZXIgfHwgMSwgISF3aXRob3V0U3VmZml4LCBzdHJpbmcsIGlzRnV0dXJlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZWxhdGl2ZVRpbWUkMShwb3NOZWdEdXJhdGlvbiwgd2l0aG91dFN1ZmZpeCwgdGhyZXNob2xkcywgbG9jYWxlKSB7XG4gICAgICAgIHZhciBkdXJhdGlvbiA9IGNyZWF0ZUR1cmF0aW9uKHBvc05lZ0R1cmF0aW9uKS5hYnMoKSxcbiAgICAgICAgICAgIHNlY29uZHMgPSByb3VuZChkdXJhdGlvbi5hcygncycpKSxcbiAgICAgICAgICAgIG1pbnV0ZXMgPSByb3VuZChkdXJhdGlvbi5hcygnbScpKSxcbiAgICAgICAgICAgIGhvdXJzID0gcm91bmQoZHVyYXRpb24uYXMoJ2gnKSksXG4gICAgICAgICAgICBkYXlzID0gcm91bmQoZHVyYXRpb24uYXMoJ2QnKSksXG4gICAgICAgICAgICBtb250aHMgPSByb3VuZChkdXJhdGlvbi5hcygnTScpKSxcbiAgICAgICAgICAgIHdlZWtzID0gcm91bmQoZHVyYXRpb24uYXMoJ3cnKSksXG4gICAgICAgICAgICB5ZWFycyA9IHJvdW5kKGR1cmF0aW9uLmFzKCd5JykpLFxuICAgICAgICAgICAgYSA9XG4gICAgICAgICAgICAgICAgKHNlY29uZHMgPD0gdGhyZXNob2xkcy5zcyAmJiBbJ3MnLCBzZWNvbmRzXSkgfHxcbiAgICAgICAgICAgICAgICAoc2Vjb25kcyA8IHRocmVzaG9sZHMucyAmJiBbJ3NzJywgc2Vjb25kc10pIHx8XG4gICAgICAgICAgICAgICAgKG1pbnV0ZXMgPD0gMSAmJiBbJ20nXSkgfHxcbiAgICAgICAgICAgICAgICAobWludXRlcyA8IHRocmVzaG9sZHMubSAmJiBbJ21tJywgbWludXRlc10pIHx8XG4gICAgICAgICAgICAgICAgKGhvdXJzIDw9IDEgJiYgWydoJ10pIHx8XG4gICAgICAgICAgICAgICAgKGhvdXJzIDwgdGhyZXNob2xkcy5oICYmIFsnaGgnLCBob3Vyc10pIHx8XG4gICAgICAgICAgICAgICAgKGRheXMgPD0gMSAmJiBbJ2QnXSkgfHxcbiAgICAgICAgICAgICAgICAoZGF5cyA8IHRocmVzaG9sZHMuZCAmJiBbJ2RkJywgZGF5c10pO1xuXG4gICAgICAgIGlmICh0aHJlc2hvbGRzLncgIT0gbnVsbCkge1xuICAgICAgICAgICAgYSA9XG4gICAgICAgICAgICAgICAgYSB8fFxuICAgICAgICAgICAgICAgICh3ZWVrcyA8PSAxICYmIFsndyddKSB8fFxuICAgICAgICAgICAgICAgICh3ZWVrcyA8IHRocmVzaG9sZHMudyAmJiBbJ3d3Jywgd2Vla3NdKTtcbiAgICAgICAgfVxuICAgICAgICBhID0gYSB8fFxuICAgICAgICAgICAgKG1vbnRocyA8PSAxICYmIFsnTSddKSB8fFxuICAgICAgICAgICAgKG1vbnRocyA8IHRocmVzaG9sZHMuTSAmJiBbJ01NJywgbW9udGhzXSkgfHxcbiAgICAgICAgICAgICh5ZWFycyA8PSAxICYmIFsneSddKSB8fCBbJ3l5JywgeWVhcnNdO1xuXG4gICAgICAgIGFbMl0gPSB3aXRob3V0U3VmZml4O1xuICAgICAgICBhWzNdID0gK3Bvc05lZ0R1cmF0aW9uID4gMDtcbiAgICAgICAgYVs0XSA9IGxvY2FsZTtcbiAgICAgICAgcmV0dXJuIHN1YnN0aXR1dGVUaW1lQWdvLmFwcGx5KG51bGwsIGEpO1xuICAgIH1cblxuICAgIC8vIFRoaXMgZnVuY3Rpb24gYWxsb3dzIHlvdSB0byBzZXQgdGhlIHJvdW5kaW5nIGZ1bmN0aW9uIGZvciByZWxhdGl2ZSB0aW1lIHN0cmluZ3NcbiAgICBmdW5jdGlvbiBnZXRTZXRSZWxhdGl2ZVRpbWVSb3VuZGluZyhyb3VuZGluZ0Z1bmN0aW9uKSB7XG4gICAgICAgIGlmIChyb3VuZGluZ0Z1bmN0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiByb3VuZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHJvdW5kaW5nRnVuY3Rpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJvdW5kID0gcm91bmRpbmdGdW5jdGlvbjtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBUaGlzIGZ1bmN0aW9uIGFsbG93cyB5b3UgdG8gc2V0IGEgdGhyZXNob2xkIGZvciByZWxhdGl2ZSB0aW1lIHN0cmluZ3NcbiAgICBmdW5jdGlvbiBnZXRTZXRSZWxhdGl2ZVRpbWVUaHJlc2hvbGQodGhyZXNob2xkLCBsaW1pdCkge1xuICAgICAgICBpZiAodGhyZXNob2xkc1t0aHJlc2hvbGRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGltaXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRocmVzaG9sZHNbdGhyZXNob2xkXTtcbiAgICAgICAgfVxuICAgICAgICB0aHJlc2hvbGRzW3RocmVzaG9sZF0gPSBsaW1pdDtcbiAgICAgICAgaWYgKHRocmVzaG9sZCA9PT0gJ3MnKSB7XG4gICAgICAgICAgICB0aHJlc2hvbGRzLnNzID0gbGltaXQgLSAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGh1bWFuaXplKGFyZ1dpdGhTdWZmaXgsIGFyZ1RocmVzaG9sZHMpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLmludmFsaWREYXRlKCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgd2l0aFN1ZmZpeCA9IGZhbHNlLFxuICAgICAgICAgICAgdGggPSB0aHJlc2hvbGRzLFxuICAgICAgICAgICAgbG9jYWxlLFxuICAgICAgICAgICAgb3V0cHV0O1xuXG4gICAgICAgIGlmICh0eXBlb2YgYXJnV2l0aFN1ZmZpeCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGFyZ1RocmVzaG9sZHMgPSBhcmdXaXRoU3VmZml4O1xuICAgICAgICAgICAgYXJnV2l0aFN1ZmZpeCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgYXJnV2l0aFN1ZmZpeCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICB3aXRoU3VmZml4ID0gYXJnV2l0aFN1ZmZpeDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGFyZ1RocmVzaG9sZHMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICB0aCA9IE9iamVjdC5hc3NpZ24oe30sIHRocmVzaG9sZHMsIGFyZ1RocmVzaG9sZHMpO1xuICAgICAgICAgICAgaWYgKGFyZ1RocmVzaG9sZHMucyAhPSBudWxsICYmIGFyZ1RocmVzaG9sZHMuc3MgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoLnNzID0gYXJnVGhyZXNob2xkcy5zIC0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGxvY2FsZSA9IHRoaXMubG9jYWxlRGF0YSgpO1xuICAgICAgICBvdXRwdXQgPSByZWxhdGl2ZVRpbWUkMSh0aGlzLCAhd2l0aFN1ZmZpeCwgdGgsIGxvY2FsZSk7XG5cbiAgICAgICAgaWYgKHdpdGhTdWZmaXgpIHtcbiAgICAgICAgICAgIG91dHB1dCA9IGxvY2FsZS5wYXN0RnV0dXJlKCt0aGlzLCBvdXRwdXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGxvY2FsZS5wb3N0Zm9ybWF0KG91dHB1dCk7XG4gICAgfVxuXG4gICAgdmFyIGFicyQxID0gTWF0aC5hYnM7XG5cbiAgICBmdW5jdGlvbiBzaWduKHgpIHtcbiAgICAgICAgcmV0dXJuICh4ID4gMCkgLSAoeCA8IDApIHx8ICt4O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvSVNPU3RyaW5nJDEoKSB7XG4gICAgICAgIC8vIGZvciBJU08gc3RyaW5ncyB3ZSBkbyBub3QgdXNlIHRoZSBub3JtYWwgYnViYmxpbmcgcnVsZXM6XG4gICAgICAgIC8vICAqIG1pbGxpc2Vjb25kcyBidWJibGUgdXAgdW50aWwgdGhleSBiZWNvbWUgaG91cnNcbiAgICAgICAgLy8gICogZGF5cyBkbyBub3QgYnViYmxlIGF0IGFsbFxuICAgICAgICAvLyAgKiBtb250aHMgYnViYmxlIHVwIHVudGlsIHRoZXkgYmVjb21lIHllYXJzXG4gICAgICAgIC8vIFRoaXMgaXMgYmVjYXVzZSB0aGVyZSBpcyBubyBjb250ZXh0LWZyZWUgY29udmVyc2lvbiBiZXR3ZWVuIGhvdXJzIGFuZCBkYXlzXG4gICAgICAgIC8vICh0aGluayBvZiBjbG9jayBjaGFuZ2VzKVxuICAgICAgICAvLyBhbmQgYWxzbyBub3QgYmV0d2VlbiBkYXlzIGFuZCBtb250aHMgKDI4LTMxIGRheXMgcGVyIG1vbnRoKVxuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkuaW52YWxpZERhdGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzZWNvbmRzID0gYWJzJDEodGhpcy5fbWlsbGlzZWNvbmRzKSAvIDEwMDAsXG4gICAgICAgICAgICBkYXlzID0gYWJzJDEodGhpcy5fZGF5cyksXG4gICAgICAgICAgICBtb250aHMgPSBhYnMkMSh0aGlzLl9tb250aHMpLFxuICAgICAgICAgICAgbWludXRlcyxcbiAgICAgICAgICAgIGhvdXJzLFxuICAgICAgICAgICAgeWVhcnMsXG4gICAgICAgICAgICBzLFxuICAgICAgICAgICAgdG90YWwgPSB0aGlzLmFzU2Vjb25kcygpLFxuICAgICAgICAgICAgdG90YWxTaWduLFxuICAgICAgICAgICAgeW1TaWduLFxuICAgICAgICAgICAgZGF5c1NpZ24sXG4gICAgICAgICAgICBobXNTaWduO1xuXG4gICAgICAgIGlmICghdG90YWwpIHtcbiAgICAgICAgICAgIC8vIHRoaXMgaXMgdGhlIHNhbWUgYXMgQyMncyAoTm9kYSkgYW5kIHB5dGhvbiAoaXNvZGF0ZSkuLi5cbiAgICAgICAgICAgIC8vIGJ1dCBub3Qgb3RoZXIgSlMgKGdvb2cuZGF0ZSlcbiAgICAgICAgICAgIHJldHVybiAnUDBEJztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIDM2MDAgc2Vjb25kcyAtPiA2MCBtaW51dGVzIC0+IDEgaG91clxuICAgICAgICBtaW51dGVzID0gYWJzRmxvb3Ioc2Vjb25kcyAvIDYwKTtcbiAgICAgICAgaG91cnMgPSBhYnNGbG9vcihtaW51dGVzIC8gNjApO1xuICAgICAgICBzZWNvbmRzICU9IDYwO1xuICAgICAgICBtaW51dGVzICU9IDYwO1xuXG4gICAgICAgIC8vIDEyIG1vbnRocyAtPiAxIHllYXJcbiAgICAgICAgeWVhcnMgPSBhYnNGbG9vcihtb250aHMgLyAxMik7XG4gICAgICAgIG1vbnRocyAlPSAxMjtcblxuICAgICAgICAvLyBpbnNwaXJlZCBieSBodHRwczovL2dpdGh1Yi5jb20vZG9yZGlsbGUvbW9tZW50LWlzb2R1cmF0aW9uL2Jsb2IvbWFzdGVyL21vbWVudC5pc29kdXJhdGlvbi5qc1xuICAgICAgICBzID0gc2Vjb25kcyA/IHNlY29uZHMudG9GaXhlZCgzKS5yZXBsYWNlKC9cXC4/MCskLywgJycpIDogJyc7XG5cbiAgICAgICAgdG90YWxTaWduID0gdG90YWwgPCAwID8gJy0nIDogJyc7XG4gICAgICAgIHltU2lnbiA9IHNpZ24odGhpcy5fbW9udGhzKSAhPT0gc2lnbih0b3RhbCkgPyAnLScgOiAnJztcbiAgICAgICAgZGF5c1NpZ24gPSBzaWduKHRoaXMuX2RheXMpICE9PSBzaWduKHRvdGFsKSA/ICctJyA6ICcnO1xuICAgICAgICBobXNTaWduID0gc2lnbih0aGlzLl9taWxsaXNlY29uZHMpICE9PSBzaWduKHRvdGFsKSA/ICctJyA6ICcnO1xuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICB0b3RhbFNpZ24gK1xuICAgICAgICAgICAgJ1AnICtcbiAgICAgICAgICAgICh5ZWFycyA/IHltU2lnbiArIHllYXJzICsgJ1knIDogJycpICtcbiAgICAgICAgICAgIChtb250aHMgPyB5bVNpZ24gKyBtb250aHMgKyAnTScgOiAnJykgK1xuICAgICAgICAgICAgKGRheXMgPyBkYXlzU2lnbiArIGRheXMgKyAnRCcgOiAnJykgK1xuICAgICAgICAgICAgKGhvdXJzIHx8IG1pbnV0ZXMgfHwgc2Vjb25kcyA/ICdUJyA6ICcnKSArXG4gICAgICAgICAgICAoaG91cnMgPyBobXNTaWduICsgaG91cnMgKyAnSCcgOiAnJykgK1xuICAgICAgICAgICAgKG1pbnV0ZXMgPyBobXNTaWduICsgbWludXRlcyArICdNJyA6ICcnKSArXG4gICAgICAgICAgICAoc2Vjb25kcyA/IGhtc1NpZ24gKyBzICsgJ1MnIDogJycpXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgdmFyIHByb3RvJDIgPSBEdXJhdGlvbi5wcm90b3R5cGU7XG5cbiAgICBwcm90byQyLmlzVmFsaWQgPSBpc1ZhbGlkJDE7XG4gICAgcHJvdG8kMi5hYnMgPSBhYnM7XG4gICAgcHJvdG8kMi5hZGQgPSBhZGQkMTtcbiAgICBwcm90byQyLnN1YnRyYWN0ID0gc3VidHJhY3QkMTtcbiAgICBwcm90byQyLmFzID0gYXM7XG4gICAgcHJvdG8kMi5hc01pbGxpc2Vjb25kcyA9IGFzTWlsbGlzZWNvbmRzO1xuICAgIHByb3RvJDIuYXNTZWNvbmRzID0gYXNTZWNvbmRzO1xuICAgIHByb3RvJDIuYXNNaW51dGVzID0gYXNNaW51dGVzO1xuICAgIHByb3RvJDIuYXNIb3VycyA9IGFzSG91cnM7XG4gICAgcHJvdG8kMi5hc0RheXMgPSBhc0RheXM7XG4gICAgcHJvdG8kMi5hc1dlZWtzID0gYXNXZWVrcztcbiAgICBwcm90byQyLmFzTW9udGhzID0gYXNNb250aHM7XG4gICAgcHJvdG8kMi5hc1F1YXJ0ZXJzID0gYXNRdWFydGVycztcbiAgICBwcm90byQyLmFzWWVhcnMgPSBhc1llYXJzO1xuICAgIHByb3RvJDIudmFsdWVPZiA9IHZhbHVlT2YkMTtcbiAgICBwcm90byQyLl9idWJibGUgPSBidWJibGU7XG4gICAgcHJvdG8kMi5jbG9uZSA9IGNsb25lJDE7XG4gICAgcHJvdG8kMi5nZXQgPSBnZXQkMjtcbiAgICBwcm90byQyLm1pbGxpc2Vjb25kcyA9IG1pbGxpc2Vjb25kcztcbiAgICBwcm90byQyLnNlY29uZHMgPSBzZWNvbmRzO1xuICAgIHByb3RvJDIubWludXRlcyA9IG1pbnV0ZXM7XG4gICAgcHJvdG8kMi5ob3VycyA9IGhvdXJzO1xuICAgIHByb3RvJDIuZGF5cyA9IGRheXM7XG4gICAgcHJvdG8kMi53ZWVrcyA9IHdlZWtzO1xuICAgIHByb3RvJDIubW9udGhzID0gbW9udGhzO1xuICAgIHByb3RvJDIueWVhcnMgPSB5ZWFycztcbiAgICBwcm90byQyLmh1bWFuaXplID0gaHVtYW5pemU7XG4gICAgcHJvdG8kMi50b0lTT1N0cmluZyA9IHRvSVNPU3RyaW5nJDE7XG4gICAgcHJvdG8kMi50b1N0cmluZyA9IHRvSVNPU3RyaW5nJDE7XG4gICAgcHJvdG8kMi50b0pTT04gPSB0b0lTT1N0cmluZyQxO1xuICAgIHByb3RvJDIubG9jYWxlID0gbG9jYWxlO1xuICAgIHByb3RvJDIubG9jYWxlRGF0YSA9IGxvY2FsZURhdGE7XG5cbiAgICBwcm90byQyLnRvSXNvU3RyaW5nID0gZGVwcmVjYXRlKFxuICAgICAgICAndG9Jc29TdHJpbmcoKSBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIHRvSVNPU3RyaW5nKCkgaW5zdGVhZCAobm90aWNlIHRoZSBjYXBpdGFscyknLFxuICAgICAgICB0b0lTT1N0cmluZyQxXG4gICAgKTtcbiAgICBwcm90byQyLmxhbmcgPSBsYW5nO1xuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ1gnLCAwLCAwLCAndW5peCcpO1xuICAgIGFkZEZvcm1hdFRva2VuKCd4JywgMCwgMCwgJ3ZhbHVlT2YnKTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ3gnLCBtYXRjaFNpZ25lZCk7XG4gICAgYWRkUmVnZXhUb2tlbignWCcsIG1hdGNoVGltZXN0YW1wKTtcbiAgICBhZGRQYXJzZVRva2VuKCdYJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKHBhcnNlRmxvYXQoaW5wdXQpICogMTAwMCk7XG4gICAgfSk7XG4gICAgYWRkUGFyc2VUb2tlbigneCcsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZSh0b0ludChpbnB1dCkpO1xuICAgIH0pO1xuXG4gICAgLy8hIG1vbWVudC5qc1xuXG4gICAgaG9va3MudmVyc2lvbiA9ICcyLjI5LjEnO1xuXG4gICAgc2V0SG9va0NhbGxiYWNrKGNyZWF0ZUxvY2FsKTtcblxuICAgIGhvb2tzLmZuID0gcHJvdG87XG4gICAgaG9va3MubWluID0gbWluO1xuICAgIGhvb2tzLm1heCA9IG1heDtcbiAgICBob29rcy5ub3cgPSBub3c7XG4gICAgaG9va3MudXRjID0gY3JlYXRlVVRDO1xuICAgIGhvb2tzLnVuaXggPSBjcmVhdGVVbml4O1xuICAgIGhvb2tzLm1vbnRocyA9IGxpc3RNb250aHM7XG4gICAgaG9va3MuaXNEYXRlID0gaXNEYXRlO1xuICAgIGhvb2tzLmxvY2FsZSA9IGdldFNldEdsb2JhbExvY2FsZTtcbiAgICBob29rcy5pbnZhbGlkID0gY3JlYXRlSW52YWxpZDtcbiAgICBob29rcy5kdXJhdGlvbiA9IGNyZWF0ZUR1cmF0aW9uO1xuICAgIGhvb2tzLmlzTW9tZW50ID0gaXNNb21lbnQ7XG4gICAgaG9va3Mud2Vla2RheXMgPSBsaXN0V2Vla2RheXM7XG4gICAgaG9va3MucGFyc2Vab25lID0gY3JlYXRlSW5ab25lO1xuICAgIGhvb2tzLmxvY2FsZURhdGEgPSBnZXRMb2NhbGU7XG4gICAgaG9va3MuaXNEdXJhdGlvbiA9IGlzRHVyYXRpb247XG4gICAgaG9va3MubW9udGhzU2hvcnQgPSBsaXN0TW9udGhzU2hvcnQ7XG4gICAgaG9va3Mud2Vla2RheXNNaW4gPSBsaXN0V2Vla2RheXNNaW47XG4gICAgaG9va3MuZGVmaW5lTG9jYWxlID0gZGVmaW5lTG9jYWxlO1xuICAgIGhvb2tzLnVwZGF0ZUxvY2FsZSA9IHVwZGF0ZUxvY2FsZTtcbiAgICBob29rcy5sb2NhbGVzID0gbGlzdExvY2FsZXM7XG4gICAgaG9va3Mud2Vla2RheXNTaG9ydCA9IGxpc3RXZWVrZGF5c1Nob3J0O1xuICAgIGhvb2tzLm5vcm1hbGl6ZVVuaXRzID0gbm9ybWFsaXplVW5pdHM7XG4gICAgaG9va3MucmVsYXRpdmVUaW1lUm91bmRpbmcgPSBnZXRTZXRSZWxhdGl2ZVRpbWVSb3VuZGluZztcbiAgICBob29rcy5yZWxhdGl2ZVRpbWVUaHJlc2hvbGQgPSBnZXRTZXRSZWxhdGl2ZVRpbWVUaHJlc2hvbGQ7XG4gICAgaG9va3MuY2FsZW5kYXJGb3JtYXQgPSBnZXRDYWxlbmRhckZvcm1hdDtcbiAgICBob29rcy5wcm90b3R5cGUgPSBwcm90bztcblxuICAgIC8vIGN1cnJlbnRseSBIVE1MNSBpbnB1dCB0eXBlIG9ubHkgc3VwcG9ydHMgMjQtaG91ciBmb3JtYXRzXG4gICAgaG9va3MuSFRNTDVfRk1UID0ge1xuICAgICAgICBEQVRFVElNRV9MT0NBTDogJ1lZWVktTU0tRERUSEg6bW0nLCAvLyA8aW5wdXQgdHlwZT1cImRhdGV0aW1lLWxvY2FsXCIgLz5cbiAgICAgICAgREFURVRJTUVfTE9DQUxfU0VDT05EUzogJ1lZWVktTU0tRERUSEg6bW06c3MnLCAvLyA8aW5wdXQgdHlwZT1cImRhdGV0aW1lLWxvY2FsXCIgc3RlcD1cIjFcIiAvPlxuICAgICAgICBEQVRFVElNRV9MT0NBTF9NUzogJ1lZWVktTU0tRERUSEg6bW06c3MuU1NTJywgLy8gPGlucHV0IHR5cGU9XCJkYXRldGltZS1sb2NhbFwiIHN0ZXA9XCIwLjAwMVwiIC8+XG4gICAgICAgIERBVEU6ICdZWVlZLU1NLUREJywgLy8gPGlucHV0IHR5cGU9XCJkYXRlXCIgLz5cbiAgICAgICAgVElNRTogJ0hIOm1tJywgLy8gPGlucHV0IHR5cGU9XCJ0aW1lXCIgLz5cbiAgICAgICAgVElNRV9TRUNPTkRTOiAnSEg6bW06c3MnLCAvLyA8aW5wdXQgdHlwZT1cInRpbWVcIiBzdGVwPVwiMVwiIC8+XG4gICAgICAgIFRJTUVfTVM6ICdISDptbTpzcy5TU1MnLCAvLyA8aW5wdXQgdHlwZT1cInRpbWVcIiBzdGVwPVwiMC4wMDFcIiAvPlxuICAgICAgICBXRUVLOiAnR0dHRy1bV11XVycsIC8vIDxpbnB1dCB0eXBlPVwid2Vla1wiIC8+XG4gICAgICAgIE1PTlRIOiAnWVlZWS1NTScsIC8vIDxpbnB1dCB0eXBlPVwibW9udGhcIiAvPlxuICAgIH07XG5cbiAgICByZXR1cm4gaG9va3M7XG5cbn0pKSk7XG4iLCAiaW1wb3J0IHsgVXBkYXRlTm90ZVR5cGVNb2RhbCB9IGZyb20gJ3VwZGF0ZU5vdGVUeXBlTW9kYWwnO1xuaW1wb3J0IHsgQXBwLCBFZGl0b3IsIE1hcmtkb3duVmlldywgTm90aWNlLCBQbHVnaW4sIFBsdWdpblNldHRpbmdUYWIsIFNldHRpbmcsIFRGaWxlLCBWYXVsdCwgRWRpdG9yU2VsZWN0aW9uLCBXb3Jrc3BhY2UgfSBmcm9tICdvYnNpZGlhbic7XG5pbXBvcnQgeyBBZGRGb290bm90ZVRhZ01vZGFsIH0gZnJvbSAnYWRkQ29tbWVudFRhZ01vZGFsJztcbmltcG9ydCB7IEFkZFRhc2tUYWdNb2RhbCB9IGZyb20gJ2FkZFRhc2tUYWdNb2RhbCc7XG5pbXBvcnQgeyByZW5hbWVCbG9nVGl0bGUsIHJlbmFtZVRhZyB9IGZyb20gJ3RhZ3JlbmFtZXIvcmVuYW1pbmcnO1xuaW1wb3J0IHsgVGhyZWFkc1RvSW1hZ2VzTW9kYWwgfSBmcm9tICdUaHJlYWRzVG9JbWFnZXNNb2RhbCc7XG5pbXBvcnQgeyBDb3B5T3JNb3ZlVG9OZXdOb3RlTW9kYWwgfSBmcm9tICdjb3B5T3JNb3ZlVG9OZXdOb3RlTW9kYWwnO1xuaW1wb3J0IHsgQ2xpcGJvYXJkUGFzdGVNb2RhbCB9IGZyb20gJ2NsaXBib2FyZFBhc3RlTW9kYWwnO1xuaW1wb3J0IHsgT3BlblBsYXlncm91bmRNb2RhbCB9IGZyb20gJ29wZW5QbGF5Z3JvdW5kTW9kYWwnO1xuaW1wb3J0IHsgVGhyZWFkc1RvQmxvZ01vZGFsIH0gZnJvbSAndGhyZWFkc1RvQmxvZ01vZGFsJztcbmltcG9ydCB7IENsaXBib2FyZFJlbW92YWxNb2RhbCB9IGZyb20gJ2NsaXBib2FyZFJlbW92YWxNb2RhbCc7XG5pbXBvcnQgeyBUYWdTZWFyY2hNb2RhbCB9IGZyb20gJ3RhZ1NlYXJjaE1vZGFsJztcbmltcG9ydCB7IGFkZEljb24gfSBmcm9tICdvYnNpZGlhbic7XG5pbXBvcnQgbW9tZW50IGZyb20gJ21vbWVudCc7XG5pbXBvcnQgeyBBZGRUZXh0VG9Ob3Rlc01vZGFsIH0gZnJvbSAnYWRkVGV4dFRvTm90ZXNNb2RhbCc7XG5pbXBvcnQgeyBOYXZpZ2F0ZVRvTm90ZUZyb21UYWdNb2RhbCB9IGZyb20gJ25hdmlnYXRlVG9Ob3RlRnJvbVRhZ01vZGFsJztcbmltcG9ydCB7IFNlbGVjdGlvblJhbmdlLCBleHBvcnRDdXJyZW50U2VsZWN0aW9uLCBnZXRDdXJyZW50U2VsZWN0aW9uTGluZU51bWJlciB9IGZyb20gJ3NlbGZ1dGlsL2V4dHJhY3RTZWxlY3Rpb24nO1xuaW1wb3J0IHsgZ2V0UGFyZW50TGluZSwgcmVwbGFjZVRXVXNlbGVzc1ZhbHVlLCBzaG91bGRTa2lwRnJvbnRNYXR0ZXIsIHRpZHlVcEZyb250TWF0dGVyT25WYWx1ZSwgdGlkeVVwRnJvbnRNYXR0ZXJvbkVkaXRvciB9IGZyb20gJ3R3bWlncmF0aW9uL3R3TWlncmF0ZVRvb2xzJztcbmltcG9ydCB7IHJlbW92ZUNvbnRlbnRGcm9tQ3Vyc29yVG9FbmRPZk5vdGUsIHJlbW92ZUNvbnRlbnRGcm9tU3RhcnRPZk5vdGVUb0N1cnNvciwgcmVtb3ZlQ29udGVudExlZnRTYW1lTGluZSB9IGZyb20gJ3NlbGZ1dGlsL3JlbW92ZUNvbnRlbnRGcm9tQ3Vyc29yJztcbmltcG9ydCB7IFJlbW92ZUNvbnRlbnRGcm9tQ3Vyc29yTW9kYWwgfSBmcm9tICdyZW1vdmVDb250ZW50RnJvbUN1cnNvck1vZGFsJztcbmltcG9ydCB7IEZpbmRSZXBsYWNlTW9kYWwgfSBmcm9tICdmaW5kUmVwbGFjZU1vZGFsJztcbmltcG9ydCB7IFF1ZXJ5T3JwaGFuTm90ZXNCeVRhZ01vZGFsIH0gZnJvbSAncXVlcnlPcnBoYW5Ob3Rlc0J5VGFnTW9kYWwnO1xuXG4vLyBSZW1lbWJlciB0byByZW5hbWUgdGhlc2UgY2xhc3NlcyBhbmQgaW50ZXJmYWNlcyFcblxuaW50ZXJmYWNlIE15UGx1Z2luU2V0dGluZ3Mge1xuXHRteVNldHRpbmc6IHN0cmluZztcbn1cblxuY29uc3QgREVGQVVMVF9TRVRUSU5HUzogTXlQbHVnaW5TZXR0aW5ncyA9IHtcblx0bXlTZXR0aW5nOiAnZGVmYXVsdCdcbn1cblxuY29uc3QgY2xpcGJvYXJkSGlzdG9yeTogc3RyaW5nW10gPSBbXVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNeVBsdWdpbiBleHRlbmRzIFBsdWdpbiB7XG5cdHNldHRpbmdzOiBNeVBsdWdpblNldHRpbmdzO1xuXHR2aWV3OiBNYXJrZG93blZpZXc7XG5cblx0YXN5bmMgb25sb2FkKCkge1xuXHRcdGF3YWl0IHRoaXMubG9hZFNldHRpbmdzKCk7XG5cblx0XHQvKlxuXHRcdC8vZnVuY3Rpb24gZGlzcGxheU5vdGVJbkxlZnRWaWV3KGFwcDogQXBwLCBub3RlUGF0aDogc3RyaW5nKSB7XG5cdFx0XHRjb25zb2xlLmxvZyhcIj09PTFcIilcblx0XHRcdC8vY29uc3QgdmlldyA9IG5ldyBNYXJrZG93blZpZXcodGhpcy5hcHAud29ya3NwYWNlLmdldExlYWYoKSk7XG5cdFx0XHQvL2NvbnNvbGUubG9nKFwiPT09MlwiKVxuXHRcdFx0Ly92aWV3LnNldEVwaGVtZXJhbFN0YXRlKHsgcGF0aDogXCJJL0luYm94Lm1kXCIgfSk7XG5cdFx0XHQvL2NvbnNvbGUubG9nKFwiPT09M1wiKVxuXHRcdFx0Ly9hcHAud29ya3NwYWNlLmdldExlYWYoKS5zZXRWaWV3U3RhdGUoeyB0eXBlOiBcIm1hcmtkb3duXCIsIHN0YXRlOiB2aWV3LmdldFN0YXRlKCkgfSk7XG5cdFx0XHQvL2NvbnNvbGUubG9nKFwiPT09NFwiKVxuXG5cdFx0XHRcblx0XHRcdHRoaXMucmVnaXN0ZXJWaWV3KFxuXHRcdFx0XHRcImluYm94XCIsXG5cdFx0XHRcdChsZWFmKSA9PiB7XG5cdFx0XHRcdFx0dGhpcy52aWV3ID0gbmV3IE1hcmtkb3duVmlldyhsZWFmKVxuXHRcdFx0XHRcdHRoaXMudmlldy5zZXRFcGhlbWVyYWxTdGF0ZSh7IHBhdGg6IFwiSS9JbmJveC5tZFwiIH0pO1xuXHRcdFx0XHRcdGNvbnN0IHN0YXRlID0gdGhpcy52aWV3LmdldFN0YXRlKClcblx0XHRcdFx0XHRzdGF0ZS5waW5uZWQgPSB0cnVlXG5cdFx0XHRcdFx0bGVhZi5zZXRWaWV3U3RhdGUoeyB0eXBlOiBcIm1hcmtkb3duXCIsIHN0YXRlOiBzdGF0ZSB9KTtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcy52aWV3XG5cdFx0XHRcdH0sXG5cdFx0XHQgICk7XG5cdFx0ICAvL31cblxuXHRcdCAgY29uc29sZS5sb2coXCI9PT0yXCIpXG5cblx0XHQgIHRoaXMuYWRkQ29tbWFuZCh7XG5cdFx0XHRpZDogJ3JlY2VudC1maWxlcy1vcGVuJyxcblx0XHRcdG5hbWU6ICdPcGVuIFhYWCcsXG5cdFx0XHRjYWxsYmFjazogYXN5bmMgKCkgPT4ge1xuXHRcdFx0ICBsZXQgW2xlYWZdID0gdGhpcy5hcHAud29ya3NwYWNlLmdldExlYXZlc09mVHlwZShcblx0XHRcdFx0XCJpbmJveFwiLFxuXHRcdFx0ICApO1xuXHRcdFx0ICBpZiAoIWxlYWYpIHtcblx0XHRcdFx0bGVhZiA9IHRoaXMuYXBwLndvcmtzcGFjZS5nZXRMZWZ0TGVhZihmYWxzZSk7XG5cdFx0XHRcdGF3YWl0IGxlYWYuc2V0Vmlld1N0YXRlKHsgdHlwZTogXCJpbmJveFwiIH0pO1xuXHRcdFx0ICB9XG5cdCAgXG5cdFx0XHQgIHRoaXMuYXBwLndvcmtzcGFjZS5yZXZlYWxMZWFmKGxlYWYpO1xuXHRcdFx0fSxcblx0XHQgIH0pO1xuXG5cdFx0ICBjb25zb2xlLmxvZyhcIj09PTNcIilcblx0XHQgICovXG5cdFx0ICBcblxuXHRcdGlmIChuYXZpZ2F0b3IuY2xpcGJvYXJkKSB7XG5cdFx0XHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdjb3B5JywgKGV2ZW50OiBDbGlwYm9hcmRFdmVudCkgPT4ge1xuXHRcdFx0XHRjb25zdCBjb3BpZWRUZXh0ID0gZXZlbnQuY2xpcGJvYXJkRGF0YT8uZ2V0RGF0YSgndGV4dC9wbGFpbicpO1xuXHRcdFx0XHRpZiAoY29waWVkVGV4dCAhPSBudWxsKSB7XG5cdFx0XHRcdFx0dGhpcy5hZGRUb0NsaXBib2FyZEhpc3RvcnkoY29waWVkVGV4dClcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0XHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdjdXQnLCAoZXZlbnQ6IENsaXBib2FyZEV2ZW50KSA9PiB7XG5cdFx0XHRcdGNvbnN0IGNvcGllZFRleHQgPSBldmVudC5jbGlwYm9hcmREYXRhPy5nZXREYXRhKCd0ZXh0L3BsYWluJyk7XG5cdFx0XHRcdGlmIChjb3BpZWRUZXh0ICE9IG51bGwpIHtcblx0XHRcdFx0XHR0aGlzLmFkZFRvQ2xpcGJvYXJkSGlzdG9yeShjb3BpZWRUZXh0KVxuXHRcdFx0XHR9XG5cdFx0XHQgIH0pO1xuXHRcdCAgfSBlbHNlIHtcblx0XHRcdGNvbnNvbGUubG9nKCdDbGlwYm9hcmQgQVBJIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBicm93c2VyLicpO1xuXHRcdCAgfVxuXG5cdFx0WyduJywgJ2wnLCAndycsICdkJywgJ2EnLCAnMScsICcyJywgJzMnLCAnNCcsICc1JywgJzYnLCAnNyddLmZvckVhY2godCA9PiB7XG5cdFx0XHR0aGlzLmFkZEFjdGlvbkljb24odCk7XG5cdFx0XHR0aGlzLmFkZEFjdGlvbkNvbW1hbmQodCk7XG5cdFx0fSk7XG5cblx0XHRbJ3QnLCAnbScsICdlJ10uZm9yRWFjaCh0ID0+IHtcblx0XHRcdHRoaXMuYWRkQWN0aW9uSWNvbih0KTtcblx0XHRcdHRoaXMuYWRkRm9sbG93VXBDb21tYW5kKHQpO1xuXHRcdH0pO1xuXG5cdFx0WyduJywgJ3cnXS5mb3JFYWNoKHQgPT4ge1xuXHRcdFx0dGhpcy5hZGROZXdMYXRlckFjdGlvbkljb24odCk7XG5cdFx0XHR0aGlzLmFkZE5ld0xhdGVyQWN0aW9uKHQpO1xuXHRcdH0pO1xuXG5cdFx0dGhpcy5hZGRDb21tYW5kKHtcblx0XHRcdGlkOiBcIm9ic2lkaWFuLXJlbW92ZS1jbGlwYm9hcmQtY29udGVudFwiLFxuXHRcdFx0bmFtZTogXCJSQyBPYnNpZGlhbiBSZW1vdmUgQ2xpcGJvYXJkIENvbnRlbnRcIixcblx0XHRcdGljb246IFwib2JzaWRpYW4tcmVtb3ZlLWNsaXBib2FyZC1jb250ZW50XCIsXG5cdFx0XHRlZGl0b3JDYWxsYmFjazogKGVkaXRvcjogRWRpdG9yLCB2aWV3OiBNYXJrZG93blZpZXcpID0+IHtcblx0XHRcdFx0bmV3IENsaXBib2FyZFJlbW92YWxNb2RhbCh0aGlzLmFwcCwgZWRpdG9yLCBjbGlwYm9hcmRIaXN0b3J5KS5vcGVuKCk7XHRcdFxuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0Lypcblx0XHR0aGlzLmFkZE9ic2lkaWFuSWNvbignb2JzaWRpYW4tY29weScsICdcdTIzMThDJyk7XG5cdFx0dGhpcy5hZGRDb21tYW5kKHtcblx0XHRcdGlkOiBcIm9ic2lkaWFuLWNvcHlcIixcblx0XHRcdG5hbWU6IFwiT2JzaWRpYW4gQ29weVwiLFxuXHRcdFx0aWNvbjogXCJvYnNpZGlhbi1jb3B5XCIsXG5cdFx0XHRlZGl0b3JDYWxsYmFjazogKGVkaXRvcjogRWRpdG9yLCB2aWV3OiBNYXJrZG93blZpZXcpID0+IHtcblx0XHRcdFx0bGV0IGNvbnRlbnQgPSBlZGl0b3IuZ2V0U2VsZWN0aW9uKCkudG9TdHJpbmcoKVxuXHRcdFx0XHRpZiAoY29udGVudC5sZW5ndGggPT0gMCkge1xuXHRcdFx0XHRcdGNvbnRlbnQgPSBlZGl0b3IuZ2V0TGluZShlZGl0b3IuZ2V0Q3Vyc29yKCkubGluZSlcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLmFkZFRvQ2xpcGJvYXJkSGlzdG9yeShjb250ZW50KTtcblx0XHRcdFx0bmV3IE5vdGljZShcImBgYFxcblwiICsgY29udGVudCArIFwiXFxuYGBgXFxuaXMgY29waWVkIHRvIGNsaXBib2FyZCFcIilcblx0XHRcdH0sXG5cdFx0XHRob3RrZXlzOiBbXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRtb2RpZmllcnM6IFtgTWV0YWAsIGBTaGlmdGBdLFxuXHRcdFx0XHRcdGtleTogYGNgLFxuXHRcdFx0XHR9XG5cdFx0XHRdXG5cdFx0fSk7XG5cdFx0Ki9cblxuXHRcdC8qXG5cdFx0dGhpcy5hZGRPYnNpZGlhbkljb24oJ29ic2lkaWFuLWN1dCcsICdcdTIzMThYJyk7XG5cdFx0dGhpcy5hZGRDb21tYW5kKHtcblx0XHRcdGlkOiBcIm9ic2lkaWFuLWN1dFwiLFxuXHRcdFx0bmFtZTogXCJPYnNpZGlhbiBDdXRcIixcblx0XHRcdGljb246IFwib2JzaWRpYW4tY3V0XCIsXG5cdFx0XHRlZGl0b3JDYWxsYmFjazogKGVkaXRvcjogRWRpdG9yLCB2aWV3OiBNYXJrZG93blZpZXcpID0+IHtcblx0XHRcdFx0bGV0IGNvbnRlbnQgPSBlZGl0b3IuZ2V0U2VsZWN0aW9uKCkudG9TdHJpbmcoKVxuXHRcdFx0XHRpZiAoY29udGVudC5sZW5ndGggPT0gMCkge1xuXHRcdFx0XHRcdGNvbnRlbnQgPSBlZGl0b3IuZ2V0TGluZShlZGl0b3IuZ2V0Q3Vyc29yKCkubGluZSlcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLmFkZFRvQ2xpcGJvYXJkSGlzdG9yeShjb250ZW50KTtcblx0XHRcdFx0ZWRpdG9yLnJlcGxhY2VTZWxlY3Rpb24oXCJcIilcblx0XHRcdFx0bmV3IE5vdGljZShcImBgYFxcblwiICsgY29udGVudCArIFwiXFxuYGBgXFxuaXMgY3V0IHRvIGNsaXBib2FyZCFcIilcblx0XHRcdH0sXG5cdFx0XHRob3RrZXlzOiBbXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRtb2RpZmllcnM6IFtgTWV0YWAsIGBTaGlmdGBdLFxuXHRcdFx0XHRcdGtleTogYHhgLFxuXHRcdFx0XHR9XG5cdFx0XHRdXG5cdFx0fSk7XG5cdCovXG5cblx0dGhpcy5hZGRPYnNpZGlhbkljb24oJ2F1dG8tY29ycmVjdCcsICdBQycpO1xuXHR0aGlzLmFkZENvbW1hbmQoe1xuXHRcdGlkOiBcImF1dG8tY29ycmVjdFwiLFxuXHRcdG5hbWU6IFwiQXV0byBDb3JyZWN0IEFDXCIsXG5cdFx0aWNvbjogXCJhdXRvLWNvcnJlY3RcIixcblx0XHRlZGl0b3JDYWxsYmFjazogKGVkaXRvcjogRWRpdG9yLCB2aWV3OiBNYXJrZG93blZpZXcpID0+IHtcblx0XHRcdGNvbnN0IHZhbHVlID0gZWRpdG9yLmdldFZhbHVlKClcblx0XHRcdGxldCBtb2RpZmllZFZhbHVlID0gdmFsdWVcblx0XHRcdC5yZXBsYWNlKC8xMFx1NTIwNi9nLCBcIlx1NTM0MVx1NTIwNlwiKVxuXHRcdFx0LnJlcGxhY2UoL1x1ODhDRi9nLCBcIlx1ODhFMVwiKVxuXHRcdFx0LnJlcGxhY2UoL1x1NTkyN1x1NEY2Qy9nLCBcIlx1NTkyN1x1ODE2NlwiKVxuXG5cdFx0XHQvLyB0aGVuIGFkZCBzcGFjZXMgYmV0d2VlbiBlbmdsaXNoIGFuZCBjaGluZXNlIGlmIG5vIHNwYWNlXG5cdFx0XHRtb2RpZmllZFZhbHVlID0gbW9kaWZpZWRWYWx1ZVxuXHRcdFx0LnJlcGxhY2UoLyhbYS16QS1aMC05XSkoW1xcdTRFMDAtXFx1OUZGRl0pL2csIFwiJDEgJDJcIilcblx0XHRcdC5yZXBsYWNlKC8oW1xcdTRFMDAtXFx1OUZGRl0pKFthLXpBLVowLTldKS9nLCBcIiQxICQyXCIpXG5cdFx0XHRlZGl0b3Iuc2V0VmFsdWUobW9kaWZpZWRWYWx1ZSlcblx0XHR9XG5cdH0pO1xuXG5cdHRoaXMuYWRkT2JzaWRpYW5JY29uKCdmaW5kLWJyb2tlbi1saW5rJywgJ0JMJyk7XG5cdHRoaXMuYWRkQ29tbWFuZCh7XG5cdFx0aWQ6IFwiZmluZC1icm9rZW4tbGlua1wiLFxuXHRcdG5hbWU6IFwiRmluZCBCcm9rZW4gTGluayBCTFwiLFxuXHRcdGljb246IFwiZmluZC1icm9rZW4tbGlua1wiLFxuXHRcdGVkaXRvckNhbGxiYWNrOiAoZWRpdG9yOiBFZGl0b3IsIHZpZXc6IE1hcmtkb3duVmlldykgPT4ge1xuXHRcdFx0aWYgKHZpZXcuZmlsZS5wYXRoICE9PSBcIkkvQnJva2VuIExpbmsubWRcIikge1xuXHRcdFx0XHRcblx0XHRcdFx0Y29uc3QgY3Vyc29yID0gZWRpdG9yLmdldEN1cnNvcigpXG5cdFx0XHRcdGNvbnN0IGxpbmUgPSBjdXJzb3IubGluZVxuXHRcdFx0XHRjb25zdCBsaW5lQ29udGVudCA9IGVkaXRvci5nZXRMaW5lKGxpbmUpXG5cblx0XHRcdFx0Ly8gaWYgbGluZSBjb250ZW50IGhhcyBbWyBhbmQgXV0gIGFuZCA6ID8gLyA8ID4gaW4gYmV0d2VlbiwgcmVwbGFjZSB0aGVtIHRvIF9cblx0XHRcdFx0aWYgKC9cXFtcXFsuKls6P1xcL1xcXFw8Pl0uKlxcXVxcXS8udGVzdChsaW5lQ29udGVudCkpIHtcblx0XHRcdFx0XHRuZXcgTm90aWNlKFwiVHJ5aW5nIHRvIGZpeCBicm9rZW4gbGluZSBpbiBjdXJyZW50IGxpbmU6IFwiICsgbGluZUNvbnRlbnQpXG5cdFx0XHRcdFx0Ly8gcmVwbGFjZSBhbGwgOiB0byBfIGFuZCByZXBsYWNlIGFsbCA/IHRvIF8gYW5kIHJlcGxhY2UgYWxsIC8gdG8gXyBhbmQgcmVwbGFjZSBhbGwgLiB0byBfXG5cdFx0XHRcdFx0ZWRpdG9yLnNldExpbmUobGluZSwgbGluZUNvbnRlbnQucmVwbGFjZSgvOi9nLCBcIl9cIikucmVwbGFjZSgvXFw/L2csIFwiX1wiKS5yZXBsYWNlKC9cXC8vZywgXCJfXCIpLnJlcGxhY2UoL1xcXFwvZywgXCJfXCIpLnJlcGxhY2UoLzwvZywgXCJfXCIpLnJlcGxhY2UoLz4vZywgXCJfXCIpXG5cdFx0XHRcdFx0LnJlcGxhY2UoL14ocGFyZW50XFxkKylfIC8sIFwiJDE6IFwiKVxuXHRcdFx0XHRcdC5yZXBsYWNlKC9eKHRpdGxlXFxkKylfIC8sIFwiJDE6IFwiKVxuXHRcdFx0XHRcdClcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyBmaW5kIG5leHQgYnJva2VuIGxpbmtcblx0XHRcdFx0XHRjb25zdCB1bnJlc29sdmVkTGlua3M6IFJlY29yZDxzdHJpbmcsIFJlY29yZDxzdHJpbmcsIG51bWJlcj4+ID0gdGhpcy5hcHAubWV0YWRhdGFDYWNoZS51bnJlc29sdmVkTGlua3M7XG5cdFx0XHRcdFx0Y29uc3QgYnJva2VuTGlua1JlY29yZDogUmVjb3JkPHN0cmluZywgbnVtYmVyPiA9IHVucmVzb2x2ZWRMaW5rc1t2aWV3LmZpbGUucGF0aF1cblx0XHRcdFx0XHRpZiAoYnJva2VuTGlua1JlY29yZCA9PSBudWxsKSB7XG5cdFx0XHRcdFx0XHRuZXcgTm90aWNlKFwiTm8gYnJva2VuIGxpbmsgZm91bmQgaW4gdGhpcyBmaWxlXCIpXHRcblx0XHRcdFx0XHRcdHJldHVyblxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjb25zdCBicm9rZW5MaW5rcyA9IE9iamVjdC5rZXlzKGJyb2tlbkxpbmtSZWNvcmQpXG5cdFx0XHRcdFx0aWYgKGJyb2tlbkxpbmtzID09IG51bGwgfHwgYnJva2VuTGlua3MubGVuZ3RoID09IDApIHtcblx0XHRcdFx0XHRcdG5ldyBOb3RpY2UoXCJObyBicm9rZW4gbGluayBmb3VuZCBpbiB0aGlzIGZpbGVcIilcdFxuXHRcdFx0XHRcdFx0cmV0dXJuXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGZvciAobGV0IGkgPSBsaW5lICsgMTsgaSA8IGVkaXRvci5saW5lQ291bnQoKTsgaSsrKSB7XG5cdFx0XHRcdFx0XHRjb25zdCBsaW5lQ29udGVudCA9IGVkaXRvci5nZXRMaW5lKGkpXG5cdFx0XHRcdFx0XHRmb3IgKGxldCBiID0gMDsgYiA8IGJyb2tlbkxpbmtzLmxlbmd0aDsgYisrKSB7XG5cdFx0XHRcdFx0XHRcdGNvbnN0IGJyb2tlbkxpbmsgPSBicm9rZW5MaW5rc1tiXVxuXHRcdFx0XHRcdFx0XHRpZiAobGluZUNvbnRlbnQuY29udGFpbnMoXCJbW1wiICsgYnJva2VuTGluayArIFwiXV1cIikpIHtcblx0XHRcdFx0XHRcdFx0XHRlZGl0b3Iuc2V0Q3Vyc29yKHtsaW5lOiBpLCBjaDogMH0pXG5cdFx0XHRcdFx0XHRcdFx0ZWRpdG9yLnNjcm9sbEludG9WaWV3KHtmcm9tOiB7bGluZTogaSwgY2g6IDB9LCB0bzoge2xpbmU6IGksIGNoOiAwfX0sIHRydWUpXG5cdFx0XHRcdFx0XHRcdFx0bmV3IE5vdGljZShcIk5hdmlnYXRlZCB0byBuZXh0IEJyb2tlbiBsaW5rIHN0YXJ0aW5nIGZyb20gY3Vyc29yXCIpXG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0bmV3IE5vdGljZShcIk5vIGJyb2tlbiBsaW5rIGZvdW5kIGFmdGVyIGN1cnNvciBsaW5lIGluIHRoaXMgZmlsZVwiKVx0XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuXG5cdFx0XHR9XG5cdFx0XHRsZXQgY291bnQgPSAwXG5cdFx0XHRsZXQgcmVzdWx0ID0gXCJcIlxuXHRcdFx0Y29uc3QgdW5yZXNvbHZlZExpbmtzOiBSZWNvcmQ8c3RyaW5nLCBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+PiA9IHRoaXMuYXBwLm1ldGFkYXRhQ2FjaGUudW5yZXNvbHZlZExpbmtzO1x0XG5cdFx0XHQvLyB0aGVuIGxvb3AgdGhlIHJlY29yZCBkYXRhIGluIGNvbnNvbGVcblx0XHRcdGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHVucmVzb2x2ZWRMaW5rcykpIHtcblx0XHRcdFx0bGV0IHYgPSAnJ1xuXHRcdFx0XHRmb3IgKGNvbnN0IFtrMSwgdjFdIG9mIE9iamVjdC5lbnRyaWVzKHZhbHVlKSkge1xuXHRcdFx0XHRcdHYgKz0gazEgKyBcIjpcIiArIHYxICsgXCIsIFwiXG5cdFx0XHRcdH1cblx0XHRcdFx0diA9IHYucmVwbGFjZSgvLCAkLywgXCJcIilcblx0XHRcdFx0aWYgKHYgIT09IFwiXCIpIHtcblx0XHRcdFx0XHRjb25zb2xlLmxvZyhrZXkgKyAnIC0+IFsnICsgdiArICddJylcblx0XHRcdFx0XHRyZXN1bHQgKz0gXCItIFtbXCIgKyBrZXkucmVwbGFjZSgvXFwubWQkLyxcIlwiKSArICddXScvLyA6IFsnICsgdiArICddJ1xuXHRcdFx0XHRcdHJlc3VsdCArPSBcIlxcblwiXG5cdFx0XHRcdFx0Zm9yIChjb25zdCBbazIsIHYyXSBvZiBPYmplY3QuZW50cmllcyh2YWx1ZSkpIHtcblx0XHRcdFx0XHRcdHJlc3VsdCArPSBcIlxcdC0gXCIgKyBrMi5yZXBsYWNlKC9cXC5tZCQvLFwiXCIpICsgJydcblx0XHRcdFx0XHRcdHJlc3VsdCArPSBcIlxcblwiXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGNvdW50Kytcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0ZWRpdG9yLnNldFZhbHVlKHJlc3VsdClcblx0XHRcdG5ldyBOb3RpY2UoXCJVcGRhdGVkIGJyb2tlbiBsaW5rLiBjb3VudD1cIiArIGNvdW50KVxuXHRcdFx0Lypcblx0XHRcdG5hdmlnYXRvci5jbGlwYm9hcmQud3JpdGVUZXh0KHJlc3VsdCkudGhlbigoKSA9PiB7XG5cdFx0XHRcdG5ldyBOb3RpY2UoXCJjb3VudD1cIiArIGNvdW50KVxuXHRcdFx0XHRuZXcgTm90aWNlKFwiY29waWVkIHJlc3VsdCB0byBjbGlwYm9hcmQhXCIpXG5cdFx0XHR9KVxuXHRcdFx0Ki9cblx0XHR9LFxuXHRcdGhvdGtleXM6IFtcblx0XHRcdHtcblx0XHRcdFx0bW9kaWZpZXJzOiBbYEN0cmxgLCBgTWV0YWAsIGBTaGlmdGBdLFxuXHRcdFx0XHRrZXk6IGA1YCxcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG1vZGlmaWVyczogW2BDdHJsYCwgYEFsdGAsIGBTaGlmdGBdLFxuXHRcdFx0XHRrZXk6IGA1YCxcblx0XHRcdH0sXG5cdFx0XVxuXHR9KTtcblxuXHRcdFx0dGhpcy5hZGRDb21tYW5kKHtcblx0XHRcdGlkOiBcIm9wZW4tdGFnLXNlYXJjaFwiLFxuXHRcdFx0bmFtZTogXCJPcGVuIHRhZyBzZWFyY2hcIixcblx0XHRcdGljb246IFwiaGFzaFwiLFxuXHRcdFx0Y2FsbGJhY2s6ICgpID0+IHtcblx0XHRcdFx0LyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSAqL1xuXHRcdFx0XHRjb25zdCBzZWFyY2hQbHVnaW4gPSAoXG5cdFx0XHRcdFx0dGhpcy5hcHAgYXMgYW55XG5cdFx0XHRcdCkuaW50ZXJuYWxQbHVnaW5zLmdldFBsdWdpbkJ5SWQoXCJnbG9iYWwtc2VhcmNoXCIpO1xuXHRcdFx0XHQvKiBlc2xpbnQtZW5hYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnkgKi9cblx0XHRcdFx0Y29uc3Qgc2VhcmNoID0gc2VhcmNoUGx1Z2luICYmIHNlYXJjaFBsdWdpbi5pbnN0YW5jZTtcblxuXHRcdFx0XHRpZiAoc2VhcmNoUGx1Z2luICYmIHNlYXJjaFBsdWdpbi5pbnN0YW5jZSkge1xuXHRcdFx0XHRcdG5ldyBUYWdTZWFyY2hNb2RhbCh0aGlzLmFwcCwgc2VhcmNoKS5vcGVuKCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0bmV3IE5vdGljZShcIlBsZWFzZSBlbmFibGUgdGhlIHNlYXJjaCBjb3JlIHBsdWdpbiFcIik7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRob3RrZXlzOiBbXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRtb2RpZmllcnM6IFtgQ3RybGAsIGBNZXRhYCwgYFNoaWZ0YF0sXG5cdFx0XHRcdFx0a2V5OiBgc2AsXG5cdFx0XHRcdH0sXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRtb2RpZmllcnM6IFtgQ3RybGAsIGBBbHRgLCBgU2hpZnRgXSxcblx0XHRcdFx0XHRrZXk6IGBzYCxcblx0XHRcdFx0fSxcblx0XHRcdF1cblx0XHR9KTtcblxuXHRcdHRoaXMuYWRkQ29tbWFuZCh7XG5cdFx0XHRpZDogXCJvcGVuLXRhZy1zZWFyY2hcIixcblx0XHRcdG5hbWU6IFwiT3BlbiB0YWcgc2VhcmNoXCIsXG5cdFx0XHRpY29uOiBcImhhc2hcIixcblx0XHRcdGNhbGxiYWNrOiAoKSA9PiB7XG5cdFx0XHRcdC8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnkgKi9cblx0XHRcdFx0Y29uc3Qgc2VhcmNoUGx1Z2luID0gKFxuXHRcdFx0XHRcdHRoaXMuYXBwIGFzIGFueVxuXHRcdFx0XHQpLmludGVybmFsUGx1Z2lucy5nZXRQbHVnaW5CeUlkKFwiZ2xvYmFsLXNlYXJjaFwiKTtcblx0XHRcdFx0LyogZXNsaW50LWVuYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55ICovXG5cdFx0XHRcdGNvbnN0IHNlYXJjaCA9IHNlYXJjaFBsdWdpbiAmJiBzZWFyY2hQbHVnaW4uaW5zdGFuY2U7XG5cblx0XHRcdFx0aWYgKHNlYXJjaFBsdWdpbiAmJiBzZWFyY2hQbHVnaW4uaW5zdGFuY2UpIHtcblx0XHRcdFx0XHRuZXcgVGFnU2VhcmNoTW9kYWwodGhpcy5hcHAsIHNlYXJjaCkub3BlbigpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdG5ldyBOb3RpY2UoXCJQbGVhc2UgZW5hYmxlIHRoZSBzZWFyY2ggY29yZSBwbHVnaW4hXCIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0aG90a2V5czogW1xuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bW9kaWZpZXJzOiBbYEN0cmxgLCBgTWV0YWAsIGBTaGlmdGBdLFxuXHRcdFx0XHRcdGtleTogYHNgLFxuXHRcdFx0XHR9LFxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bW9kaWZpZXJzOiBbYEN0cmxgLCBgQWx0YCwgYFNoaWZ0YF0sXG5cdFx0XHRcdFx0a2V5OiBgc2AsXG5cdFx0XHRcdH0sXG5cdFx0XHRdXG5cdFx0fSk7XG5cblx0XHRcblx0XHR0aGlzLmFkZENvbW1hbmQoe1xuXHRcdFx0aWQ6IFwic2VsZi1xdWVyeVwiLFxuXHRcdFx0bmFtZTogXCJTZWxmIFF1ZXJ5XCIsXG5cdFx0XHRlZGl0b3JDYWxsYmFjazogKGVkaXRvcjogRWRpdG9yLCB2aWV3OiBNYXJrZG93blZpZXcpID0+IHtcblx0XHRcdFx0bmV3IFF1ZXJ5T3JwaGFuTm90ZXNCeVRhZ01vZGFsKHRoaXMuYXBwLCBlZGl0b3IsIHZpZXcpLm9wZW4oKVxuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0dGhpcy5hZGRPYnNpZGlhbkljb24oJ29ic2lkaWFuLXBhc3RlJywgJ1x1MjMxOFYnKTtcblx0XHR0aGlzLmFkZENvbW1hbmQoe1xuXHRcdFx0aWQ6IFwib2JzaWRpYW4tcGFzdGVcIixcblx0XHRcdG5hbWU6IFwiT2JzaWRpYW4gUGFzdGVcIixcblx0XHRcdGljb246IFwib2JzaWRpYW4tcGFzdGVcIixcblx0XHRcdGVkaXRvckNhbGxiYWNrOiAoZWRpdG9yOiBFZGl0b3IsIHZpZXc6IE1hcmtkb3duVmlldykgPT4ge1xuXHRcdFx0XHRuZXcgQ2xpcGJvYXJkUGFzdGVNb2RhbCh0aGlzLmFwcCwgZWRpdG9yLCBjbGlwYm9hcmRIaXN0b3J5KS5vcGVuKCk7XHRcdFxuXHRcdFx0fSxcblx0XHRcdGhvdGtleXM6IFtcblx0XHRcdFx0e1xuXHRcdFx0XHRcdG1vZGlmaWVyczogW2BNZXRhYCwgYFNoaWZ0YF0sXG5cdFx0XHRcdFx0a2V5OiBgdmAsXG5cdFx0XHRcdH1cblx0XHRcdF1cblx0XHR9KTtcblxuXHRcdHRoaXMuYWRkT2JzaWRpYW5JY29uKCd1cGRhdGUtbm90ZS10eXBlLWljb24nLCAnTlQnKTtcblx0XHR0aGlzLmFkZENvbW1hbmQoe1xuXHRcdFx0aWQ6IFwidXBkYXRlLW5vdGUtdHlwZVwiLFxuXHRcdFx0bmFtZTogXCJVcGRhdGUgTm90ZSBUeXBlXCIsXG5cdFx0XHRpY29uOiBgdXBkYXRlLW5vdGUtdHlwZS1pY29uYCxcblx0XHRcdGVkaXRvckNhbGxiYWNrOiAoZWRpdG9yOiBFZGl0b3IsIHZpZXc6IE1hcmtkb3duVmlldykgPT4ge1xuXHRcdFx0ICBuZXcgVXBkYXRlTm90ZVR5cGVNb2RhbCh0aGlzLmFwcCwgZWRpdG9yLCB2aWV3LmZpbGUpLm9wZW4oKTtcblx0XHRcdH0sXG5cdFx0XHRob3RrZXlzOiBbXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRtb2RpZmllcnM6IFtgQ3RybGAsIGBNZXRhYCwgYFNoaWZ0YF0sXG5cdFx0XHRcdFx0a2V5OiBgY2AsXG5cdFx0XHRcdH0sXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRtb2RpZmllcnM6IFtgQ3RybGAsIGBBbHRgLCBgU2hpZnRgXSxcblx0XHRcdFx0XHRrZXk6IGBjYCxcblx0XHRcdFx0fSxcblx0XHRcdF1cblx0XHR9KTtcblxuXG5cdFx0Ly8gY29tYmluZWQgdmVyc2lvblxuXHRcdC8vdGhpcy51cGRhdGVTY2hlZHVsaW5nSWNvbigpXG5cdFx0dGhpcy5hZGRDb21tYW5kKHtcblx0XHRcdGlkOiBcIm9wZW4tcmVjZW50LWRheXMtc2NoZWR1bGUtd2l0aC11cGRhdGVkLXNjaGVkdWxlXCIsXG5cdFx0XHRuYW1lOiBcIk9SIE9wZW4gUmVjZW50IERheXMgVXBkYXRlZCBTY2hlZHVsZVwiLFxuXHRcdFx0aWNvbjogXCJvcGVuLXJlY2VudC1kYXktc2NoZWR1bGUtaWNvblwiLFxuXHRcdFx0Y2FsbGJhY2s6IGFzeW5jICgpID0+IHtcblx0XHRcdFx0Ly8gdXBkYXRlIHNjaGVkdWxpbmcgcGFydFxuXHRcdFx0XHRjb25zdCB7IHZhdWx0IH0gPSB0aGlzLmFwcDtcblx0XHRcdFx0Y29uc3Qgc2NoZWR1bGVOb3RlV2l0aG91dE1kID0gXCJEL1NjaGVkdWxpbmdcIlxuXHRcdFx0XHRjb25zdCBzY2hlZHVsZU5vdGUgPSBgJHtzY2hlZHVsZU5vdGVXaXRob3V0TWR9Lm1kYFx0XHRcdFx0XG5cdFx0XHRcdGlmICh2YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgoc2NoZWR1bGVOb3RlKSA9PSBudWxsKSB7XG5cdFx0XHRcdFx0YXdhaXQgdmF1bHQuY3JlYXRlKHNjaGVkdWxlTm90ZSwgXCJcIik7XG5cdFx0XHRcdH1cblx0XHRcdFx0bGV0IG5vdGVDb250ZW50ID0gJydcblx0XHRcdFx0QXJyYXkuZnJvbShBcnJheSg3KS5rZXlzKCkpLmZvckVhY2goaSA9PiBub3RlQ29udGVudCArPSB0aGlzLmdldFF1ZXJ5RGF0ZVN0cmluZyhpLCBzY2hlZHVsZU5vdGVXaXRob3V0TWQpKTtcblx0XHRcdFx0dmF1bHQubW9kaWZ5KHZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aChzY2hlZHVsZU5vdGUpIGFzIFRGaWxlLCBub3RlQ29udGVudCk7XG5cblx0XHRcdFx0dGhpcy5hZGRBY3Rpb25Ob3RlQ29udGVudCh2YXVsdCwgXCJEXCIsIFwiUXVlcnkgVyBub3cgYWN0aW9uc1wiLCBcIldlZWtseSBTY2hlZHVsZSBXXCIsIFwid1wiKVxuXHRcdFx0XHR0aGlzLmFkZEFjdGlvbk5vdGVDb250ZW50KHZhdWx0LCBcIkRcIiwgXCJRdWVyeSBOIG5vdyBhY3Rpb25zXCIsIFwiV2Vla2x5IFNjaGVkdWxlIE5cIiwgXCJuXCIpXG5cdFx0XHRcdHRoaXMuYWRkM0RheXNBY3Rpb25Ob3RlQ29udGVudCh2YXVsdCk7XG5cdFx0XHRcdG5ldyBOb3RpY2UoXCJVcGRhdGVkIHNjaGVkdWxlXCIpO1xuXG5cdFx0XHRcdC8vIG9wZW4gc2NoZWR1bGUgcGFydFxuXHRcdFx0XHRjb25zdCB7IHdvcmtzcGFjZSB9ID0gdGhpcy5hcHA7XG5cdFx0XHRcdGNvbnN0IGRhc2hib2FyZENhbnZhcyA9IFwiRC9RdWVyeSBTY2hlZHVsZSBhbmQgQWN0aW9ucyBuZXh0IDMgZGF5cy5tZFwiXG5cdFx0XHRcdGNvbnN0IG1vZGUgPSAodGhpcy5hcHAudmF1bHQgYXMgYW55KS5nZXRDb25maWcoXCJkZWZhdWx0Vmlld01vZGVcIik7XG5cdFx0XHRcdGNvbnN0IGxlYWYgPSB3b3Jrc3BhY2UuZ2V0TGVhZihmYWxzZSk7XG5cdFx0XHRcdGF3YWl0IGxlYWYub3BlbkZpbGUodmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKGRhc2hib2FyZENhbnZhcykgYXMgVEZpbGUsIHsgYWN0aXZlIDogdHJ1ZSwvKiBtb2RlICovfSk7XG5cdFx0XHR9XG5cdFx0fSlcblxuXHRcdHRoaXMuYWRkT2JzaWRpYW5JY29uKCd1cGRhdGUtc2NoZWR1bGluZy1pY29uJywgJ1VTJyk7XG5cdFx0dGhpcy5hZGRDb21tYW5kKHtcblx0XHRcdGlkOiBcInVwZGF0ZS1zY2hlZHVsaW5nXCIsXG5cdFx0XHRuYW1lOiBcIlVwZGF0ZSBTY2hlZHVsaW5nXCIsXG5cdFx0XHRpY29uOiBcInVwZGF0ZS1zY2hlZHVsaW5nLWljb25cIixcblx0XHRcdGNhbGxiYWNrOiBhc3luYyAoKSA9PiB7XG5cdFx0XHRcdGNvbnN0IHsgdmF1bHQgfSA9IHRoaXMuYXBwO1xuXHRcdFx0XHRjb25zdCBzY2hlZHVsZU5vdGVXaXRob3V0TWQgPSBcIkQvU2NoZWR1bGluZ1wiXG5cdFx0XHRcdGNvbnN0IHNjaGVkdWxlTm90ZSA9IGAke3NjaGVkdWxlTm90ZVdpdGhvdXRNZH0ubWRgXHRcdFx0XHRcblx0XHRcdFx0aWYgKHZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aChzY2hlZHVsZU5vdGUpID09IG51bGwpIHtcblx0XHRcdFx0XHRhd2FpdCB2YXVsdC5jcmVhdGUoc2NoZWR1bGVOb3RlLCBcIlwiKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRsZXQgbm90ZUNvbnRlbnQgPSAnJ1xuXHRcdFx0XHRBcnJheS5mcm9tKEFycmF5KDcpLmtleXMoKSkuZm9yRWFjaChpID0+IG5vdGVDb250ZW50ICs9IHRoaXMuZ2V0UXVlcnlEYXRlU3RyaW5nKGksIHNjaGVkdWxlTm90ZVdpdGhvdXRNZCkpO1xuXHRcdFx0XHR2YXVsdC5tb2RpZnkodmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKHNjaGVkdWxlTm90ZSkgYXMgVEZpbGUsIG5vdGVDb250ZW50KTtcblxuXHRcdFx0XHR0aGlzLmFkZEFjdGlvbk5vdGVDb250ZW50KHZhdWx0LCBcIkRcIiwgXCJRdWVyeSBXIG5vdyBhY3Rpb25zXCIsIFwiV2Vla2x5IFNjaGVkdWxlIFdcIiwgXCJ3XCIpXG5cdFx0XHRcdHRoaXMuYWRkQWN0aW9uTm90ZUNvbnRlbnQodmF1bHQsIFwiRFwiLCBcIlF1ZXJ5IE4gbm93IGFjdGlvbnNcIiwgXCJXZWVrbHkgU2NoZWR1bGUgTlwiLCBcIm5cIilcblx0XHRcdFx0dGhpcy5hZGQzRGF5c0FjdGlvbk5vdGVDb250ZW50KHZhdWx0KTtcblx0XHRcdFx0bmV3IE5vdGljZShcIlVwZGF0ZWQgc2NoZWR1bGVcIik7XG5cdFx0XHR9LyosXG5cdFx0XHRob3RrZXlzOiBbXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRtb2RpZmllcnM6IFtgQ3RybGAsIGBNZXRhYCwgYFNoaWZ0YF0sXG5cdFx0XHRcdFx0a2V5OiBgdWAsXG5cdFx0XHRcdH0sXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRtb2RpZmllcnM6IFtgQ3RybGAsIGBBbHRgLCBgU2hpZnRgXSxcblx0XHRcdFx0XHRrZXk6IGB1YCxcblx0XHRcdFx0fSxcblx0XHRcdF0qL1xuXHRcdH0pXG5cblx0XHQvKlxuXHRcdHRoaXMuYWRkT2JzaWRpYW5JY29uKCdvcGVuLWRhc2hib2FyZC1pY29uJywgJ09EJyk7XG5cdFx0dGhpcy5hZGRDb21tYW5kKHtcblx0XHRcdGlkOiBcIm9wZW4tZGFzaGJvYXJkXCIsXG5cdFx0XHRuYW1lOiBcIk9wZW4gRGFzaGJvYXJkXCIsXG5cdFx0XHRpY29uOiBcIm9wZW4tZGFzaGJvYXJkLWljb25cIixcblx0XHRcdGNhbGxiYWNrOiBhc3luYyAoKSA9PiB7XG5cdFx0XHRcdGNvbnN0IHsgdmF1bHQgfSA9IHRoaXMuYXBwO1xuXHRcdFx0XHRjb25zdCB7IHdvcmtzcGFjZSB9ID0gdGhpcy5hcHA7XG5cdFx0XHRcdGNvbnN0IGRhc2hib2FyZENhbnZhcyA9IFwiRC9EYXNoYm9hcmQuY2FudmFzXCJcblx0XHRcdFx0Y29uc3QgbW9kZSA9ICh0aGlzLmFwcC52YXVsdCBhcyBhbnkpLmdldENvbmZpZyhcImRlZmF1bHRWaWV3TW9kZVwiKTtcblx0XHRcdFx0Y29uc3QgbGVhZiA9IHdvcmtzcGFjZS5nZXRMZWFmKGZhbHNlKTtcblx0XHRcdFx0YXdhaXQgbGVhZi5vcGVuRmlsZSh2YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgoZGFzaGJvYXJkQ2FudmFzKSBhcyBURmlsZSwgeyBhY3RpdmUgOiB0cnVlfSk7XG5cdFx0XHR9LFxuXHRcdH0pXG5cdFx0Ki9cblxuXHRcdHRoaXMuYWRkT2JzaWRpYW5JY29uKCdvcGVuLXJlY2VudC1kYXktc2NoZWR1bGUtaWNvbicsICdPUicpO1xuXHRcdHRoaXMuYWRkQ29tbWFuZCh7XG5cdFx0XHRpZDogXCJvcGVuLXJlY2VudC1kYXlzLXNjaGVkdWxlXCIsXG5cdFx0XHRuYW1lOiBcIk9wZW4gUmVjZW50IERheXMgU2NoZWR1bGVcIixcblx0XHRcdGljb246IFwib3Blbi1yZWNlbnQtZGF5LXNjaGVkdWxlLWljb25cIixcblx0XHRcdGNhbGxiYWNrOiBhc3luYyAoKSA9PiB7XG5cdFx0XHRcdGNvbnN0IHsgdmF1bHQsIHdvcmtzcGFjZSB9ID0gdGhpcy5hcHA7XG5cdFx0XHRcdGNvbnN0IGRhc2hib2FyZENhbnZhcyA9IFwiRC9RdWVyeSBTY2hlZHVsZSBhbmQgQWN0aW9ucyBuZXh0IDMgZGF5cy5tZFwiXG5cdFx0XHRcdGNvbnN0IGxlYWYgPSB3b3Jrc3BhY2UuZ2V0TGVhZihmYWxzZSk7XG5cdFx0XHRcdGF3YWl0IGxlYWYub3BlbkZpbGUodmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKGRhc2hib2FyZENhbnZhcykgYXMgVEZpbGUsIHsgYWN0aXZlIDogdHJ1ZSB9KTtcblx0XHRcdH0sXG5cdFx0fSlcblxuXHRcdHRoaXMuYWRkT2JzaWRpYW5JY29uKCdvcGVuLWluYm94LWljb24nLCAnT0knKTtcblx0XHR0aGlzLmFkZENvbW1hbmQoe1xuXHRcdFx0aWQ6IFwib3Blbi1pbmJveFwiLFxuXHRcdFx0bmFtZTogXCJPSSBPcGVuIEluYm94XCIsXG5cdFx0XHRpY29uOiBcIm9wZW4taW5ib3gtaWNvblwiLFxuXHRcdFx0Y2FsbGJhY2s6IGFzeW5jICgpID0+IHtcblx0XHRcdFx0Y29uc3QgeyB2YXVsdCwgd29ya3NwYWNlIH0gPSB0aGlzLmFwcDtcblx0XHRcdFx0Y29uc3QgaW5ib3hNZCA9IFwiSS9JbmJveC5tZFwiXG5cdFx0XHRcdGNvbnN0IGxlYWYgPSB3b3Jrc3BhY2UuZ2V0TGVhZihmYWxzZSk7XG5cdFx0XHRcdGF3YWl0IGxlYWYub3BlbkZpbGUodmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKGluYm94TWQpIGFzIFRGaWxlLCB7IGFjdGl2ZSA6IHRydWUgfSk7XG5cdFx0XHR9LFxuXHRcdH0pXG5cblx0XHR0aGlzLmFkZE9ic2lkaWFuSWNvbignb3Blbi1wbGF5Z3JvdW5kLWljb24nLCAnT1AnKTtcblx0XHR0aGlzLmFkZENvbW1hbmQoe1xuXHRcdFx0aWQ6IFwib3Blbi1wbGF5Z3JvdW5kXCIsXG5cdFx0XHRuYW1lOiBcIk9QIE9wZW4gUGxheWdyb3VuZFwiLFxuXHRcdFx0aWNvbjogXCJvcGVuLXBsYXlncm91bmQtaWNvblwiLFxuXHRcdFx0Y2FsbGJhY2s6IGFzeW5jICgpID0+IHtcblx0XHRcdFx0bmV3IE9wZW5QbGF5Z3JvdW5kTW9kYWwodGhpcy5hcHApLm9wZW4oKVxuXHRcdFx0fSxcblx0XHRcdGhvdGtleXM6IFtcblx0XHRcdFx0e1xuXHRcdFx0XHRcdG1vZGlmaWVyczogW2BDdHJsYCwgYE1ldGFgLCBgU2hpZnRgXSxcblx0XHRcdFx0XHRrZXk6IGBwYCxcblx0XHRcdFx0fSxcblx0XHRcdFx0e1xuXHRcdFx0XHRcdG1vZGlmaWVyczogW2BDdHJsYCwgYEFsdGAsIGBTaGlmdGBdLFxuXHRcdFx0XHRcdGtleTogYHBgLFxuXHRcdFx0XHR9LFxuXHRcdFx0XVxuXHRcdH0pXG5cblx0XHR0aGlzLmFkZE9ic2lkaWFuSWNvbignb3Blbi1icmFpbmR1bXAtaWNvbicsICdPQicpO1xuXHRcdHRoaXMuYWRkQ29tbWFuZCh7XG5cdFx0XHRpZDogXCJvcGVuLWJyYWluZHVtcFwiLFxuXHRcdFx0bmFtZTogXCJPQiBPcGVuIEJyYWluRHVtcFwiLFxuXHRcdFx0aWNvbjogXCJvcGVuLWJyYWluZHVtcC1pY29uXCIsXG5cdFx0XHRjYWxsYmFjazogYXN5bmMgKCkgPT4ge1xuXHRcdFx0XHRjb25zdCB7IHZhdWx0LCB3b3Jrc3BhY2UgfSA9IHRoaXMuYXBwO1xuXHRcdFx0XHRjb25zdCBpbmJveE1kID0gXCJJL0JyYWluIER1bXAubWRcIlxuXHRcdFx0XHRjb25zdCBsZWFmID0gd29ya3NwYWNlLmdldExlYWYoZmFsc2UpO1xuXHRcdFx0XHRhd2FpdCBsZWFmLm9wZW5GaWxlKHZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aChpbmJveE1kKSBhcyBURmlsZSwgeyBhY3RpdmUgOiB0cnVlIH0pO1xuXHRcdFx0fSxcblx0XHR9KVxuXG5cdFx0Lypcblx0XHR0aGlzLmFkZENvbW1hbmQoe1xuXHRcdFx0aWQ6IFwib3Blbi1hY3Rpb25zXCIsXG5cdFx0XHRuYW1lOiBcIk9wZW4gQWN0aW9uc1wiLFxuXHRcdFx0aWNvbjogYGFwZXJ0dXJlYCxcblx0XHRcdGVkaXRvckNhbGxiYWNrOiAoZWRpdG9yOiBFZGl0b3IsIHZpZXc6IE1hcmtkb3duVmlldykgPT4ge1xuXHRcdFx0ICBuZXcgT3BlbkFjdGlvbnNNb2RhbCh0aGlzLmFwcCkub3BlbigpO1xuXHRcdFx0fSxcblx0XHRcdGhvdGtleXM6IFtcblx0XHRcdFx0e1xuXHRcdFx0XHRcdG1vZGlmaWVyczogW2BDdHJsYCwgYE1ldGFgLCBgU2hpZnRgXSxcblx0XHRcdFx0XHRrZXk6IGB4YCxcblx0XHRcdFx0fSxcblx0XHRcdFx0e1xuXHRcdFx0XHRcdG1vZGlmaWVyczogW2BDdHJsYCwgYEFsdGAsIGBTaGlmdGBdLFxuXHRcdFx0XHRcdGtleTogYHhgLFxuXHRcdFx0XHR9LFxuXHRcdFx0XVxuXHRcdH0pO1xuXHRcdCovXG5cblx0XHQvLyBUT0RPIHJlbW92ZSBhZnRlciBUVyBtaWdyYXRlIGZpbmlzaFxuXHRcdHRoaXMuYWRkT2JzaWRpYW5JY29uKCdmb3JtYXQtYWxsLW5vdGVzLWN1c3RvbScsICdGQScpO1xuXHRcdHRoaXMuYWRkQ29tbWFuZCh7XG5cdFx0XHRpZDogXCJmb3JtYXQtYWxsLW5vdGVzLWN1c3RvbVwiLFxuXHRcdFx0bmFtZTogXCJGQSBGb3JtYXQgQWxsIE5vdGVzIChDdXN0b20gdXNhZ2UpXCIsXG5cdFx0XHRpY29uOiBgZm9ybWF0LWFsbC1ub3Rlcy1jdXN0b21gLFxuXHRcdFx0Y2FsbGJhY2s6IGFzeW5jICgpID0+IHtcblx0XHRcdFx0Y29uc3QgdmF1bHQ6IFZhdWx0ID0gdGhpcy5hcHAudmF1bHQ7XG5cdFx0XHRcdFxuXHRcdFx0XHRsZXQgc3RhcnRDb3VudCA9IDBcblx0XHRcdFx0bGV0IGZpbmlzaGVkQ291bnQgPSAwXG5cdFx0XHRcdGNvbnN0IGZpbGVzID0gdmF1bHQuZ2V0TWFya2Rvd25GaWxlcygpXG5cdFx0XHRcdG5ldyBOb3RpY2UoXCJhbGw9XCIgKyBmaWxlcy5sZW5ndGgpXG5cdFx0XHRcdGNvbnNvbGUubG9nKFwiYWxsPVwiICsgZmlsZXMubGVuZ3RoKVxuXHRcdFx0XHRmb3IgKGNvbnN0IGZpbGUgb2YgZmlsZXMpIHtcblx0XHRcdFx0XHQvLyBub3RlIHRoYXQgc3RpbGwgYXN5bmNcblx0XHRcdFx0XHRjb25zb2xlLmxvZyhcInM6IFwiICsgc3RhcnRDb3VudClcblx0XHRcdFx0XHR2YXVsdC5yZWFkKGZpbGUpLnRoZW4oKGNvbnRlbnQpID0+IHtcblx0XHRcdFx0XHRcdGNvbnN0IG1vZGlmaWVkVmFsdWUgPSB0aWR5VXBGcm9udE1hdHRlck9uVmFsdWUoY29udGVudClcblx0XHRcdFx0XHRcdHJldHVybiB2YXVsdC5tb2RpZnkoZmlsZSwgbW9kaWZpZWRWYWx1ZSk7XG5cdFx0XHRcdFx0fSkudGhlbigoKSA9PiB7XG5cdFx0XHRcdFx0XHRjb25zb2xlLmxvZyhcImY6IFwiICsgZmluaXNoZWRDb3VudClcblx0XHRcdFx0XHRcdGZpbmlzaGVkQ291bnQrK1xuXHRcdFx0XHRcdFx0aWYgKGZpbmlzaGVkQ291bnQgPT0gZmlsZXMubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRcdGNvbnNvbGUubG9nKFwiZmluaXNoZWRcIilcblx0XHRcdFx0XHRcdFx0bmV3IE5vdGljZShcImZpbmlzaGVkXCIpXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSlcblx0XHRcdFx0XHRzdGFydENvdW50Kytcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGhvdGtleXM6IFtcblx0XHRcdFx0e1xuXHRcdFx0XHRcdG1vZGlmaWVyczogW2BDdHJsYCwgYE1ldGFgLCBgU2hpZnRgXSxcblx0XHRcdFx0XHRrZXk6IGAxYCxcblx0XHRcdFx0fSxcblx0XHRcdFx0e1xuXHRcdFx0XHRcdG1vZGlmaWVyczogW2BDdHJsYCwgYEFsdGAsIGBTaGlmdGBdLFxuXHRcdFx0XHRcdGtleTogYDFgLFxuXHRcdFx0XHR9LFxuXHRcdFx0XVxuXHRcdH0pO1xuXG5cdFx0Ly8gVE9ETyByZW1vdmUgYWZ0ZXIgVFcgbWlncmF0ZSBmaW5pc2hcblx0XHR0aGlzLmFkZE9ic2lkaWFuSWNvbigndHctZml4LWJyb2tlbi1saW5rJywgJzpfJyk7XG5cdFx0dGhpcy5hZGRDb21tYW5kKHtcblx0XHRcdGlkOiBcInR3LWZpeC1icm9rZW4tbGlua1wiLFxuXHRcdFx0bmFtZTogXCJCTCBGaXggVFcgQnJva2VuIExpbmtcIixcblx0XHRcdGljb246IGB0dy1maXgtYnJva2VuLWxpbmtgLFxuXHRcdFx0ZWRpdG9yQ2FsbGJhY2s6IChlZGl0b3I6IEVkaXRvciwgdmlldzogTWFya2Rvd25WaWV3KSA9PiB7XG5cdFx0XHRcdGNvbnN0IGN1cnNvciA9IGVkaXRvci5nZXRDdXJzb3IoKVxuXHRcdFx0XHRjb25zdCBsaW5lID0gY3Vyc29yLmxpbmVcblx0XHRcdFx0Y29uc3QgbGluZUNvbnRlbnQgPSBlZGl0b3IuZ2V0TGluZShsaW5lKVxuXHRcdFx0XHQvLyByZXBsYWNlIGFsbCA6IHRvIF8gYW5kIHJlcGxhY2UgYWxsID8gdG8gXyBhbmQgcmVwbGFjZSBhbGwgLyB0byBfIGFuZCByZXBsYWNlIGFsbCAuIHRvIF9cblx0XHRcdFx0ZWRpdG9yLnNldExpbmUobGluZSwgbGluZUNvbnRlbnQucmVwbGFjZSgvOi9nLCBcIl9cIikucmVwbGFjZSgvXFw/L2csIFwiX1wiKS5yZXBsYWNlKC9cXC8vZywgXCJfXCIpLnJlcGxhY2UoLzwvZywgXCJfXCIpLnJlcGxhY2UoLz4vZywgXCJfXCIpXG5cdFx0XHRcdC5yZXBsYWNlKC9eKHBhcmVudFxcZCspXyAvLCBcIiQxOiBcIilcblx0XHRcdFx0LnJlcGxhY2UoL14odGl0bGVcXGQrKV8gLywgXCIkMTogXCIpXG5cdFx0XHRcdClcblx0XHRcdH0vKixcblx0XHRcdGhvdGtleXM6IFtcblx0XHRcdFx0e1xuXHRcdFx0XHRcdG1vZGlmaWVyczogW2BDdHJsYCwgYE1ldGFgLCBgU2hpZnRgXSxcblx0XHRcdFx0XHRrZXk6IGA1YCxcblx0XHRcdFx0fSxcblx0XHRcdFx0e1xuXHRcdFx0XHRcdG1vZGlmaWVyczogW2BDdHJsYCwgYEFsdGAsIGBTaGlmdGBdLFxuXHRcdFx0XHRcdGtleTogYDVgLFxuXHRcdFx0XHR9LFxuXHRcdFx0XSovXG5cdFx0fSk7XG5cblx0XHQvLyBUT0RPIHJlbW92ZSBhZnRlciBUVyBtaWdyYXRlIGZpbmlzaFxuXHRcdHRoaXMuYWRkT2JzaWRpYW5JY29uKCdmb3JtYXQtbm90ZXMtY3VzdG9tJywgJ0ZOJyk7XG5cdFx0dGhpcy5hZGRDb21tYW5kKHtcblx0XHRcdGlkOiBcImZvcm1hdC1ub3Rlcy1jdXN0b21cIixcblx0XHRcdG5hbWU6IFwiRk4gRm9ybWF0IE5vdGVzIChDdXN0b20gdXNhZ2UpXCIsXG5cdFx0XHRpY29uOiBgZm9ybWF0LW5vdGVzLWN1c3RvbWAsXG5cdFx0XHRlZGl0b3JDYWxsYmFjazogKGVkaXRvcjogRWRpdG9yLCB2aWV3OiBNYXJrZG93blZpZXcpID0+IHtcblx0XHRcdFx0dGlkeVVwRnJvbnRNYXR0ZXJvbkVkaXRvcihlZGl0b3IpXG5cdFx0XHR9LFxuXHRcdFx0aG90a2V5czogW1xuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bW9kaWZpZXJzOiBbYEN0cmxgLCBgTWV0YWAsIGBTaGlmdGBdLFxuXHRcdFx0XHRcdGtleTogYDJgLFxuXHRcdFx0XHR9LFxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bW9kaWZpZXJzOiBbYEN0cmxgLCBgQWx0YCwgYFNoaWZ0YF0sXG5cdFx0XHRcdFx0a2V5OiBgMmAsXG5cdFx0XHRcdH0sXG5cdFx0XHRdXG5cdFx0fSk7XG5cbi8vIFRPRE8gcmVtb3ZlIGFmdGVyIFRXIG1pZ3JhdGUgZmluaXNoXG50aGlzLmFkZE9ic2lkaWFuSWNvbigndHctZ2V0LXBhcmVudC1saW5rJywgJ1tdJyk7XG50aGlzLmFkZENvbW1hbmQoe1xuXHRpZDogXCJ0dy1nZXQtcGFyZW50LWxpbmtcIixcblx0bmFtZTogXCJ0dy1nZXQtcGFyZW50LWxpbmtcIixcblx0aWNvbjogYHR3LWdldC1wYXJlbnQtbGlua2AsXG5cdGVkaXRvckNhbGxiYWNrOiAoZWRpdG9yOiBFZGl0b3IsIHZpZXc6IE1hcmtkb3duVmlldykgPT4ge1xuXHRcdC8vIGV4YW1wbGUgY3Vyc29yIGxpbmUgaXMgZWl0aGVyIG9uZSBvZiBmb2xsb3dpbmc6XG5cdFx0Ly8gcGFyZW50MTogXCJbW0lUSVZJVEkgXyBBU1ggVHJhZGluZ11dXCJcblx0XHQvLyAtIHBhcmVudDE6IFwiW1tJVElWSVRJIF8gQVNYIFRyYWRpbmddXVwiXG5cdFx0Ly8gZ29hbCBpcyB0byBjb3B5IFwiSVRJVklUSSBfIEFTWCBUcmFkaW5nXCIgdG8gY2xpcGJvYXJkIGFuZCByZW1vdmUgdGhpcyBsaW5lXG5cdFx0Y29uc3QgY3Vyc29yID0gZWRpdG9yLmdldEN1cnNvcigpXG5cdFx0Y29uc3QgbGluZSA9IGN1cnNvci5saW5lXG5cdFx0Y29uc3QgY2ggPSBjdXJzb3IuY2hcblx0XHRjb25zdCBsaW5lQ29udGVudCA9IGVkaXRvci5nZXRMaW5lKGxpbmUpXG5cdFx0aWYgKC9ecGFyZW50XFxkKzogLy50ZXN0KGxpbmVDb250ZW50KSB8fCAvXlxcdCstIHBhcmVudFxcZCs6IC8udGVzdChsaW5lQ29udGVudCkpIHtcblx0XHRcdGNvbnN0IHBhcmVudExpbmsgPSBsaW5lQ29udGVudC5yZXBsYWNlKC9ecGFyZW50XFxkKzogLywgXCJcIikucmVwbGFjZSgvXlxcdCstIHBhcmVudFxcZCs6IC8sIFwiXCIpLnJlcGxhY2UoL1wiL2csIFwiXCIpLnJlcGxhY2UoL1xcW1xcWy8sIFwiXCIpLnJlcGxhY2UoL1xcXVxcXS8sIFwiXCIpXG5cdFx0XHRuYXZpZ2F0b3IuY2xpcGJvYXJkLndyaXRlVGV4dChwYXJlbnRMaW5rKS50aGVuKCgpID0+IHtcblx0XHRcdFx0aWYgKGxpbmUgPT0gMCkge1xuXHRcdFx0XHRcdGVkaXRvci5zZXRWYWx1ZShcIlwiKVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGNvbnN0IHByZXZpb3VzTGluZSA9IGVkaXRvci5nZXRMaW5lKGxpbmUtMSlcblx0XHRcdFx0XHRlZGl0b3IucmVwbGFjZVJhbmdlKFwiXCIsIHtsaW5lOiBsaW5lLTEsIGNoOiBwcmV2aW91c0xpbmUubGVuZ3RofSwge2xpbmU6IGxpbmUsIGNoOiBsaW5lQ29udGVudC5sZW5ndGh9KVxuXHRcdFx0XHR9XG5cdFx0XHRcdGVkaXRvci5zZXRWYWx1ZShlZGl0b3IuZ2V0VmFsdWUoKS5yZXBsYWNlKC9eLS0tXFxuKy0tLVxcbi8sIFwiLS0tXFxudGFnczogYi9uL2NcXG4tLS1cXG5cIikucmVwbGFjZSgvXFxuJC8sIFwiXCIpKVxuXHRcdFx0XHRlZGl0b3Iuc2V0Q3Vyc29yKHtsaW5lOiBsaW5lLCBjaDogY2ggPiBlZGl0b3IuZ2V0TGluZShsaW5lKS5sZW5ndGggPyBlZGl0b3IuZ2V0TGluZShsaW5lKS5sZW5ndGggOiBjaH0pXG5cdFx0XHRcdG5ldyBOb3RpY2UoXCJDb3BpZWQgdG8gY2xpcGJvYXJkOiBcIiArIHBhcmVudExpbmspXG5cdFx0XHR9KVxuXHRcdH1cblx0fSxcblx0aG90a2V5czogW1xuXHRcdHtcblx0XHRcdG1vZGlmaWVyczogW2BDdHJsYCwgYE1ldGFgLCBgU2hpZnRgXSxcblx0XHRcdGtleTogYHlgLFxuXHRcdH0sXG5cdFx0e1xuXHRcdFx0bW9kaWZpZXJzOiBbYEN0cmxgLCBgQWx0YCwgYFNoaWZ0YF0sXG5cdFx0XHRrZXk6IGB5YCxcblx0XHR9LFxuXHRdXG59KTtcblxuLy8gVE9ETyByZW1vdmUgYWZ0ZXIgVFcgbWlncmF0ZSBmaW5pc2hcbnRoaXMuYWRkT2JzaWRpYW5JY29uKCd0dy10aWR5LWxpc3Qtbm90ZScsICc9PScpO1xudGhpcy5hZGRDb21tYW5kKHtcblx0aWQ6IFwidHctdGlkeS1saXN0LW5vdGVcIixcblx0bmFtZTogXCJUTCA9PSBUVyBUaWR5IExpc3QgTm90ZVwiLFxuXHRpY29uOiBgdHctdGlkeS1saXN0LW5vdGVgLFxuXHRlZGl0b3JDYWxsYmFjazogKGVkaXRvcjogRWRpdG9yLCB2aWV3OiBNYXJrZG93blZpZXcpID0+IHtcblx0XHRlZGl0b3Iuc2V0VmFsdWUocmVwbGFjZVRXVXNlbGVzc1ZhbHVlKGVkaXRvci5nZXRWYWx1ZSgpKSlcblx0XHRjb25zdCBsaW5lQ291bnQgPSBlZGl0b3IubGluZUNvdW50KClcblx0XHRsZXQgZm0gPSBcIlwiXG5cdFx0bGV0IGMgPSBcIlwiXG5cdFx0bGV0IHRleHQgPSBcIlwiXG5cdFx0bGV0IGgzQ291bnQgPSAwO1xuXHRcdGxldCBjb250ZW50ID0gXCJcIlxuXHRcdGxldCB0YXNrVGFnID0gXCJcIlxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbGluZUNvdW50OyBpKyspIHtcblx0XHRcdGNvbnN0IGxpbmUgPSBlZGl0b3IuZ2V0TGluZShpKVxuXHRcdFx0aWYgKGgzQ291bnQgPT0gMCkge1xuXHRcdFx0XHRpZiAobGluZS5sZW5ndGggIT0gMCAmJiAhL15cXHQqLSBgYGAkLy50ZXN0KGxpbmUpKSB7XG5cdFx0XHRcdFx0Y29uc3QgbW9kaWZpZWRMaW5lID0gbGluZS5jb250YWlucyhcIltbXCIpICYmIGxpbmUuY29udGFpbnMoXCJdXVwiKSBcblx0XHRcdCAgICAgICAgICAgID8gbGluZVxuXHRcdFx0XHRcdFx0OiBsaW5lLnJlcGxhY2Uodmlldy5maWxlLmJhc2VuYW1lICsgXCIgXyBcIiwgXCJcIikucmVwbGFjZSgvKFxcdCotICkjKyA+IC8sIFwiJDFcIikucmVwbGFjZSgvKFxcdCstICkjKyAvLCBcIiQxXCIpXG5cdFx0XHRcdFx0XHQvLyBcdC0gIyMgPiBjc3RhdHVzIGFuZCB0eHN0YXQgPSAwXG5cdFx0XHRcdFx0Y29udGVudCArPSAobW9kaWZpZWRMaW5lICsgXCJcXG5cIilcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmIChoM0NvdW50ID09IDEpIHtcblx0XHRcdFx0aWYgKGxpbmUuc3RhcnRzV2l0aChcInRpdGxlOiBcIikgfHwgbGluZS5zdGFydHNXaXRoKFwibGlzdDogXCIpKSB7XG5cdFx0XHRcdFx0Zm0gKz0gKGxpbmUgKyBcIlxcblwiKVxuXHRcdFx0XHR9IGVsc2UgaWYgKGxpbmUubGVuZ3RoICE9IDAgJiYgIS9eXFx0Ki0gYGBgJC8udGVzdChsaW5lKSkgeyBcblx0XHRcdFx0XHRjb25zdCBtb2RpZmllZExpbmUgPSBsaW5lLmNvbnRhaW5zKFwiW1tcIikgJiYgbGluZS5jb250YWlucyhcIl1dXCIpIFxuXHRcdFx0XHRcdFx0PyBsaW5lXG5cdFx0XHRcdFx0XHQ6IGxpbmUucmVwbGFjZSh2aWV3LmZpbGUuYmFzZW5hbWUgKyBcIiBfIFwiLCBcIlwiKS5yZXBsYWNlKC8oXFx0Ki0gKSMrID4gLywgXCIkMVwiKS5yZXBsYWNlKC8oXFx0Ky0gKSMrIC8sIFwiJDFcIilcblx0XHRcdFx0XHRmbSArPSAobW9kaWZpZWRMaW5lICsgXCJcXG5cIilcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKGgzQ291bnQgPj0gMikge1xuXHRcdFx0XHRpZiAobGluZS5sZW5ndGggIT0gMCAmJiAhL15cXHQqLSBgYGAkLy50ZXN0KGxpbmUpKSB7XG5cdFx0XHRcdFx0Y29uc3QgbW9kaWZpZWRMaW5lID0gbGluZS5jb250YWlucyhcIltbXCIpICYmIGxpbmUuY29udGFpbnMoXCJdXVwiKSBcblx0XHRcdFx0XHRcdD8gbGluZVxuXHRcdFx0XHRcdFx0OiBsaW5lLnJlcGxhY2Uodmlldy5maWxlLmJhc2VuYW1lICsgXCIgXyBcIiwgXCJcIikucmVwbGFjZSgvKFxcdCotICkjKyA+IC8sIFwiJDFcIikucmVwbGFjZSgvKFxcdCstICkjKyAvLCBcIiQxXCIpXG5cdFx0XHRcdFx0YyArPSAobW9kaWZpZWRMaW5lICsgXCJcXG5cIilcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKGxpbmUgPT09IFwiLS0tXCIpIHtcblx0XHRcdFx0aDNDb3VudCsrO1xuXHRcdFx0XHRpZiAoaDNDb3VudCA9PSAyKSB7XG5cdFx0XHRcdFx0Zm0gKz0gXCJcXG5cIlxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSBcblx0XHR0ZXh0ICs9IGNvbnRlbnRcblx0XHRpZiAoZm0ubGVuZ3RoID4gMCkge1xuXHRcdFx0dGV4dCArPSBmbVxuXHRcdH1cblx0XHR0ZXh0ICs9IGNcblx0XHR0ZXh0ID0gdGV4dC5yZXBsYWNlKC9eLS0tXFxuKy0tLVxcbi9tLCBcIi0tLVxcbnRhZ3M6IGIvbi9jXFxuLS0tXFxuXCIpLnJlcGxhY2UoL1xcbiQvLCBcIlwiKVxuXHRcdGVkaXRvci5zZXRWYWx1ZSh0ZXh0KVxuXHR9LFxuXHRob3RrZXlzOiBbXG5cdFx0e1xuXHRcdFx0bW9kaWZpZXJzOiBbYEN0cmxgLCBgTWV0YWAsIGBTaGlmdGBdLFxuXHRcdFx0a2V5OiBgNmAsXG5cdFx0fSxcblx0XHR7XG5cdFx0XHRtb2RpZmllcnM6IFtgQ3RybGAsIGBBbHRgLCBgU2hpZnRgXSxcblx0XHRcdGtleTogYDZgLFxuXHRcdH0sXG5cdF1cbn0pO1xuXG4vLyBUT0RPIHJlbW92ZSBhZnRlciBUVyBtaWdyYXRlIGZpbmlzaFxudGhpcy5hZGRPYnNpZGlhbkljb24oJ3R3LXRhc2snLCAnLS0nKTtcbnRoaXMuYWRkQ29tbWFuZCh7XG5cdGlkOiBcInR3LXRhc2tcIixcblx0bmFtZTogXCJUVCAtLSBUVyBUYXNrXCIsXG5cdGljb246IGB0dy10YXNrYCxcblx0ZWRpdG9yQ2FsbGJhY2s6IChlZGl0b3I6IEVkaXRvciwgdmlldzogTWFya2Rvd25WaWV3KSA9PiB7XG5cdFx0ZWRpdG9yLnNldFZhbHVlKHJlcGxhY2VUV1VzZWxlc3NWYWx1ZShlZGl0b3IuZ2V0VmFsdWUoKSkpXG5cdFx0Y29uc3QgbGluZUNvdW50ID0gZWRpdG9yLmxpbmVDb3VudCgpXG5cdFx0bGV0IGZtID0gXCJcIlxuXHRcdGxldCBjID0gXCJcIlxuXHRcdGxldCB0ZXh0ID0gXCJcIlxuXHRcdGxldCBoM0NvdW50ID0gMDtcblx0XHRsZXQgY29udGVudCA9IFwiXCJcblx0XHRsZXQgdGFza1RhZyA9IFwiXCJcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGxpbmVDb3VudDsgaSsrKSB7XG5cdFx0XHRjb25zdCBsaW5lID0gZWRpdG9yLmdldExpbmUoaSlcblx0XHRcdGlmIChoM0NvdW50ID09IDApIHtcblx0XHRcdFx0Y29udGVudCArPSAobGluZSArIFwiXFxuXCIpXG5cdFx0XHR9IGVsc2UgaWYgKGgzQ291bnQgPT0gMSkge1xuXHRcdFx0XHRpZiAobGluZS5zdGFydHNXaXRoKFwidGl0bGU6IFwiKSkge1xuXHRcdFx0XHRcdC8vIGRvIG5vdGhpbmdcblx0XHRcdFx0fSBlbHNlIGlmIChsaW5lLnN0YXJ0c1dpdGgoXCJ0YWdzc3M6IFwiKSkge1xuXHRcdFx0XHRcdHRhc2tUYWcgPSBcImEvXCJcblx0XHRcdFx0XHRpZiAoLyBOIC8udGVzdChsaW5lKSB8fCAvIE4kLy50ZXN0KGxpbmUpKSB7XG5cdFx0XHRcdFx0XHR0YXNrVGFnICs9IFwibi9cIlxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoLyBXIC8udGVzdChsaW5lKSB8fCAvIFckLy50ZXN0KGxpbmUpKSB7XG5cdFx0XHRcdFx0XHR0YXNrVGFnICs9IFwidy9cIlxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoLyBub3cgLy50ZXN0KGxpbmUpIHx8IC8gbm93JC8udGVzdChsaW5lKSkge1xuXHRcdFx0XHRcdFx0dGFza1RhZyArPSBcIm5cIlxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoLyBsYXRlciAvLnRlc3QobGluZSkgfHwgLyBsYXRlciQvLnRlc3QobGluZSkpIHtcblx0XHRcdFx0XHRcdHRhc2tUYWcgKz0gXCJsXCJcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKC8gd2FpdGluZyAvLnRlc3QobGluZSkgfHwgLyB3YWl0aW5nJC8udGVzdChsaW5lKSkge1xuXHRcdFx0XHRcdFx0dGFza1RhZyArPSBcIndcIlxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoLyBkb25lIC8udGVzdChsaW5lKSB8fCAvIGRvbmUkLy50ZXN0KGxpbmUpKSB7XG5cdFx0XHRcdFx0XHR0YXNrVGFnICs9IFwiZFwiXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICgvIGFyY2hpdmUgLy50ZXN0KGxpbmUpIHx8IC8gYXJjaGluZSQvLnRlc3QobGluZSkpIHtcblx0XHRcdFx0XHRcdHRhc2tUYWcgKz0gXCJhXCJcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKHRhc2tUYWcubGVuZ3RoID09IDUpIHtcblx0XHRcdFx0XHRcdGZtICs9IChcInRhZ3M6IFwiICsgdGFza1RhZyArIFwiXFxuXCIpXG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdG5ldyBOb3RpY2UoXCJlcnJvciBvbiBzZXR0aW5nIGFjdGlvbiB0YWdcIilcblx0XHRcdFx0XHRcdGZtICs9IChsaW5lICsgXCJcXG5cIilcblx0XHRcdFx0XHR9XHRcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRmbSArPSAobGluZSArIFwiXFxuXCIpXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmIChoM0NvdW50ID49IDIpIHtcblx0XHRcdFx0bGV0IG1vZGlmaWVkTGluZSA9IGxpbmVcblx0XHRcdFx0YyArPSAobW9kaWZpZWRMaW5lICsgXCJcXG5cIilcblx0XHRcdH1cblx0XHRcdGlmIChsaW5lID09PSBcIi0tLVwiKSB7XG5cdFx0XHRcdGgzQ291bnQrKztcblx0XHRcdH1cblx0XHR9IFxuXHRcdHRleHQgKz0gY29udGVudFxuXHRcdGlmIChmbS5sZW5ndGggPiAwKSB7XG5cdFx0XHR0ZXh0ICs9IGZtXG5cdFx0fVxuXHRcdHRleHQgKz0gY1xuXHRcdHRleHQgPSB0ZXh0LnJlcGxhY2UoL14tLS1cXG4rLS0tXFxuL20sIFwiLS0tXFxudGFnczogYi9uL2NcXG4tLS1cXG5cIikucmVwbGFjZSgvXFxuJC8sIFwiXCIpXG5cdFx0ZWRpdG9yLnNldFZhbHVlKHRleHQpXG5cdFx0ZWRpdG9yLnNldEN1cnNvcih7bGluZTogZ2V0UGFyZW50TGluZSh0ZXh0KSwgY2g6IDB9KVxuXHRcdGFwcC52YXVsdC5yZW5hbWUodmlldy5maWxlLCBcIkMvXCIgKyB2aWV3LmZpbGUubmFtZSlcblx0fSxcblx0aG90a2V5czogW1xuXHRcdHtcblx0XHRcdG1vZGlmaWVyczogW2BDdHJsYCwgYE1ldGFgLCBgU2hpZnRgXSxcblx0XHRcdGtleTogYDdgLFxuXHRcdH0sXG5cdFx0e1xuXHRcdFx0bW9kaWZpZXJzOiBbYEN0cmxgLCBgQWx0YCwgYFNoaWZ0YF0sXG5cdFx0XHRrZXk6IGA3YCxcblx0XHR9LFxuXHRdXG59KTtcblxuXG4vKlxuXHRcdC8vIFRPRE8gcmVtb3ZlIGFmdGVyIFRXIG1pZ3JhdGUgZmluaXNoXG5cdFx0dGhpcy5hZGRPYnNpZGlhbkljb24oJ3R3LWNoZWNrYm94JywgJ1tdJyk7XG5cdFx0dGhpcy5hZGRDb21tYW5kKHtcblx0XHRcdGlkOiBcInR3LWNoZWNrYm94XCIsXG5cdFx0XHRuYW1lOiBcIkNCIFRXIENoZWNrYm94XCIsXG5cdFx0XHRpY29uOiBgdHctY2hlY2tib3hgLFxuXHRcdFx0ZWRpdG9yQ2FsbGJhY2s6IChlZGl0b3I6IEVkaXRvciwgdmlldzogTWFya2Rvd25WaWV3KSA9PiB7XG5cdFx0XHRcdGNvbnN0IGNoZWNrYm94TWFwID0gbmV3IE1hcDxzdHJpbmcsIHN0cmluZz4oKTtcblx0XHRcdFx0Y29uc3QgbGluZUNvdW50ID0gZWRpdG9yLmxpbmVDb3VudCgpXG5cblx0XHRcdFx0bGV0IGZtID0gXCJcIlxuXHRcdFx0XHRsZXQgYyA9IFwiXCJcblx0XHRcdFx0bGV0IHRleHQgPSBcIlwiXG5cdFx0XHRcdGxldCBoM0NvdW50ID0gMDtcblx0XHRcdFx0bGV0IGNvbnRlbnQgPSBcIlwiXG5cdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbGluZUNvdW50OyBpKyspIHtcblx0XHRcdFx0XHRjb25zdCBsaW5lID0gZWRpdG9yLmdldExpbmUoaSlcblx0XHRcdFx0XHRpZiAoaDNDb3VudCA9PSAwKSB7XG5cdFx0XHRcdFx0XHRjb250ZW50ICs9IChsaW5lICsgXCJcXG5cIilcblx0XHRcdFx0XHR9IGVsc2UgaWYgKGgzQ291bnQgPT0gMSkge1xuXHRcdFx0XHRcdFx0aWYgKGxpbmUuc3RhcnRzV2l0aChcImNoZWNrYm94Ynl0aW1lX1wiKSkge1xuXHRcdFx0XHRcdFx0XHRjb25zdCBrZXlWYWx1ZUFycmF5ID0gbGluZS5zcGxpdChcIjpcIikubWFwKGl0ZW0gPT4gaXRlbS50cmltKCkpO1xuXHRcdFx0XHRcdFx0XHRpZiAoa2V5VmFsdWVBcnJheS5sZW5ndGggPT09IDIpIHtcblx0XHRcdFx0XHRcdFx0XHRjb25zdCBrZXkgPSBrZXlWYWx1ZUFycmF5WzBdO1xuXHRcdFx0XHRcdFx0XHRcdGNvbnN0IHZhbHVlID0ga2V5VmFsdWVBcnJheVsxXTtcblxuXHRcdFx0XHRcdFx0XHRcdGNvbnN0IHNwbGl0QXJyYXkgPSBrZXkuc3BsaXQoXCJfXCIpO1xuXHRcdFx0XHRcdFx0XHRcdGNvbnN0IG1vZGlmaWVkS2V5ID0gYDw8Y2hlY2tib3hCeVRpbWUgXCIke3NwbGl0QXJyYXlbMV19XCI+PmA7XG5cblx0XHRcdFx0XHRcdFx0XHRjaGVja2JveE1hcC5zZXQobW9kaWZpZWRLZXksIHZhbHVlID09PSBcIm9wZW5cIiA/IFwiW3hdXCIgOiBcIlsgXVwiKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0Zm0gKz0gKGxpbmUgKyBcIlxcblwiKVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoaDNDb3VudCA+PSAyKSB7XG5cdFx0XHRcdFx0XHRsZXQgbW9kaWZpZWRMaW5lID0gbGluZVxuXG5cdFx0XHRcdFx0XHRmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBjaGVja2JveE1hcCkge1xuXHRcdFx0XHRcdFx0XHRtb2RpZmllZExpbmUgPSBtb2RpZmllZExpbmUucmVwbGFjZShuZXcgUmVnRXhwKGtleSwgXCJnXCIpLCB2YWx1ZSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRtb2RpZmllZExpbmUgPSBtb2RpZmllZExpbmUucmVwbGFjZSgvPDxjaGVja2JveEJ5VGltZSBcIltBLVphLXowLTlfXStcIj4+L2csIFwiWyBdXCIpXG5cblx0XHRcdFx0XHRcdGMgKz0gKG1vZGlmaWVkTGluZSArIFwiXFxuXCIpXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChsaW5lID09PSBcIi0tLVwiKSB7XG5cdFx0XHRcdFx0XHRoM0NvdW50Kys7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IFxuXHRcdFx0XHR0ZXh0ICs9IGNvbnRlbnRcblx0XHRcdFx0aWYgKGZtLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0XHR0ZXh0ICs9IGZtXG5cdFx0XHRcdFx0Ly90ZXh0ICs9IFwiLS0tXFxuXCIgKyBmbSArIFwiLS0tXFxuXCJcblx0XHRcdFx0fVxuXHRcdFx0XHR0ZXh0ICs9IGNcblx0XHRcdFx0XG5cdFx0XHRcdGVkaXRvci5zZXRWYWx1ZSh0ZXh0LnJlcGxhY2UoL1xcbiQvLCBcIlwiKSlcblx0XHRcdH0sXG5cdFx0XHRob3RrZXlzOiBbXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRtb2RpZmllcnM6IFtgQ3RybGAsIGBNZXRhYCwgYFNoaWZ0YF0sXG5cdFx0XHRcdFx0a2V5OiBgN2AsXG5cdFx0XHRcdH0sXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRtb2RpZmllcnM6IFtgQ3RybGAsIGBBbHRgLCBgU2hpZnRgXSxcblx0XHRcdFx0XHRrZXk6IGA3YCxcblx0XHRcdFx0fSxcblx0XHRcdF1cblx0XHR9KTtcbiovXG5cblx0XHQvLyBUT0RPIHJlbW92ZSBhZnRlciBUVyBtaWdyYXRlIGZpbmlzaFxuXHRcdHRoaXMuYWRkT2JzaWRpYW5JY29uKCdub3RlLXRvLXRyZWUtbGlzdCcsICcqKicpO1xuXHRcdHRoaXMuYWRkQ29tbWFuZCh7XG5cdFx0XHRpZDogXCJub3RlLXRvLXRyZWUtbGlzdFwiLFxuXHRcdFx0bmFtZTogXCJOVCBOb3RlIHRvIFRyZWUgTGlzdFwiLFxuXHRcdFx0aWNvbjogYG5vdGUtdG8tdHJlZS1saXN0YCxcblx0XHRcdGVkaXRvckNhbGxiYWNrOiAoZWRpdG9yOiBFZGl0b3IsIHZpZXc6IE1hcmtkb3duVmlldykgPT4ge1xuXHRcdFx0XHRjb25zdCBjaGVja2JveE1hcCA9IG5ldyBNYXA8c3RyaW5nLCBzdHJpbmc+KCk7XG5cdFx0XHRcdGNvbnN0IGxpbmVDb3VudCA9IGVkaXRvci5saW5lQ291bnQoKVxuXHRcdFx0XHRpZiAoZWRpdG9yLmdldFZhbHVlKCkuc3RhcnRzV2l0aChcIi0gXCIgKyB2aWV3LmZpbGUuYmFzZW5hbWUgKyBcIlxcblwiKSkge1xuXHRcdFx0XHRcdC8vIGFscmVhZHkgdGlkeSBvbmNlLCBoZXJlIG9ubHkgc2hvdWxkIHJlbW92ZSBlbXB0eSBsaW5lIGFuZCByZW1vdmUgZHVwbGljYXRlIGxpc3QgbmFtZSAodHcgaGllcmFyY2h5KVxuXHRcdFx0XHRcdGNvbnN0IGZpbGVuYW1lID0gdmlldy5maWxlLmJhc2VuYW1lXG5cdFx0XHRcdFx0bGV0IHRleHQgPSBcIlwiXG5cdFx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lQ291bnQ7IGkrKykge1xuXHRcdFx0XHRcdFx0Y29uc3QgbGluZSA9IGVkaXRvci5nZXRMaW5lKGkpXG5cdFx0XHRcdFx0XHRpZiAobGluZS50cmltKCkubGVuZ3RoICE9IDApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCEvXlxcdCotICQvLnRlc3QobGluZSkgJiYgIS9eXFx0KlxcZCtcXC4gJC8udGVzdChsaW5lKSkgeyAvLyBlbXB0eSBsaXN0IGl0ZW1cblx0XHRcdFx0XHRcdFx0XHRsZXQgbW9kTGluZSA9IGxpbmVcblx0XHRcdFx0XHRcdFx0XHRpZiAoIW1vZExpbmUuY29udGFpbnMoXCJbW1wiKSAmJiAhbW9kTGluZS5jb250YWlucyhcIl1dXCIpKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRtb2RMaW5lID0gbGluZS5yZXBsYWNlKGAke2ZpbGVuYW1lfSBfIGAsIFwiXCIpIC8vIHByZXZlbnQgcmVwbGFjZSBsaW5rXG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdGlmIChsaW5lICE9PSBgLSAke3ZpZXcuZmlsZS5iYXNlbmFtZX1gICYmIC9eLSAvLnRlc3QobGluZSkpe1xuXHRcdFx0XHRcdFx0XHRcdFx0bW9kTGluZSA9IFwiXFx0XCIgKyBtb2RMaW5lXG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdHRleHQgKz0gbW9kTGluZSArIFwiXFxuXCJcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0ZXh0ID0gdGV4dC5yZXBsYWNlKC9cXG4kL20sIFwiXCIpXG5cdFx0XHRcdFx0ZWRpdG9yLnNldFZhbHVlKHRleHQpXG5cdFx0XHRcdFx0ZWRpdG9yLnNldEN1cnNvcih7bGluZTogZ2V0UGFyZW50TGluZSh0ZXh0KSwgY2g6IDB9KVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGVkaXRvci5zZXRWYWx1ZShyZXBsYWNlVFdVc2VsZXNzVmFsdWUoZWRpdG9yLmdldFZhbHVlKCkpKVxuXHRcdFx0XHRcdGxldCB0ZXh0ID0gXCItIFwiXG5cdFx0XHRcdFx0bGV0IGgzQ291bnQgPSAwO1xuXHRcdFx0XHRcdGxldCBhY3Rpb25UYWcgPSBcIlwiXG5cdFx0XHRcdFx0bGV0IGNvbnRlbnQgPSBcIlwiXG5cdFx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lQ291bnQ7IGkrKykge1xuXHRcdFx0XHRcdFx0Y29uc3QgbGluZSA9IGVkaXRvci5nZXRMaW5lKGkpXG5cdFx0XHRcdFx0XHRpZiAoaDNDb3VudCA9PSAwKSB7XG5cdFx0XHRcdFx0XHRcdGlmIChsaW5lLnRyaW0oKS5sZW5ndGggIT0gMCAmJiBsaW5lICE9IFwiLS0tXCIpIHtcblx0XHRcdFx0XHRcdFx0XHRsZXQgbW9kaWZpZWRMaW5lID0gbGluZVxuXHRcdFx0XHRcdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgOTsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRtb2RpZmllZExpbmUgPSBtb2RpZmllZExpbmUucmVwbGFjZSgvXiAgICAvLCBcIlxcdFwiKVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRtb2RpZmllZExpbmUgPSBtb2RpZmllZExpbmUucmVwbGFjZSgvXihcXHQqKVxcKlxccy8sIFwiJDEtIFwiKVxuXHRcdFx0XHRcdFx0XHRcdG1vZGlmaWVkTGluZSA9ICgvXlxcdCotIC8udGVzdChtb2RpZmllZExpbmUpIHx8IC9eXFx0KlxcZCtcXC4gLy50ZXN0KG1vZGlmaWVkTGluZSkpID8gKFwiXFx0XCIgKyBtb2RpZmllZExpbmUpIDogKFwiXFx0LSBcIiArIG1vZGlmaWVkTGluZSlcblx0XHRcdFx0XHRcdFx0XHRjb250ZW50ICs9IFwiXFxuXCIgKyBtb2RpZmllZExpbmVcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSBlbHNlIGlmIChoM0NvdW50ID09IDEpIHtcblx0XHRcdFx0XHRcdFx0aWYgKGxpbmUgPT09IFwiLS0tXCIgfHwgc2hvdWxkU2tpcEZyb250TWF0dGVyKGxpbmUpIHx8IGxpbmUuc3RhcnRzV2l0aChcInRpdGxlOiBcIikpIHtcblx0XHRcdFx0XHRcdFx0XHQvLyBkbyBub3RoaW5nXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAobGluZS5zdGFydHNXaXRoKFwidGFnc3NzOiBcIikpIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAoLyBOIC8udGVzdChsaW5lKSB8fCAvIE4kLy50ZXN0KGxpbmUpKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRhY3Rpb25UYWcgPSBcIm5cIlxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRpZiAoLyBXIC8udGVzdChsaW5lKSB8fCAvIFckLy50ZXN0KGxpbmUpKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRhY3Rpb25UYWcgPSBcIndcIlxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRpZiAoLyBub3cgLy50ZXN0KGxpbmUpIHx8IC8gbm93JC8udGVzdChsaW5lKSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0YWN0aW9uVGFnICs9IFwiblwiXG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdGlmICgvIGxhdGVyIC8udGVzdChsaW5lKSB8fCAvIGxhdGVyJC8udGVzdChsaW5lKSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0YWN0aW9uVGFnICs9IFwibFwiXG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdGlmICgvIHdhaXRpbmcgLy50ZXN0KGxpbmUpIHx8IC8gd2FpdGluZyQvLnRlc3QobGluZSkpIHtcblx0XHRcdFx0XHRcdFx0XHRcdGFjdGlvblRhZyArPSBcIndcIlxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRpZiAoLyBkb25lIC8udGVzdChsaW5lKSB8fCAvIGRvbmUkLy50ZXN0KGxpbmUpKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRhY3Rpb25UYWcgKz0gXCJkXCJcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0aWYgKC8gYXJjaGl2ZSAvLnRlc3QobGluZSkgfHwgLyBhcmNoaW5lJC8udGVzdChsaW5lKSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0YWN0aW9uVGFnICs9IFwid1wiXG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdGlmIChhY3Rpb25UYWcubGVuZ3RoID09IDIpIHtcblx0XHRcdFx0XHRcdFx0XHRcdGFjdGlvblRhZyA9IFwiI1wiICsgYWN0aW9uVGFnICsgXCIgXCJcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKGFjdGlvblRhZy5sZW5ndGggPT0gMSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0bmV3IE5vdGljZShcImVycm9yIG9uIHNldHRpbmcgYWN0aW9uIHRhZ1wiKVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmIChsaW5lLnN0YXJ0c1dpdGgoXCJjaGVja2JveGJ5dGltZV9cIikpIHtcblx0XHRcdFx0XHRcdFx0XHRjb25zdCBrZXlWYWx1ZUFycmF5ID0gbGluZS5zcGxpdChcIjpcIikubWFwKGl0ZW0gPT4gaXRlbS50cmltKCkpO1xuXHRcdFx0XHRcdFx0XHRcdGlmIChrZXlWYWx1ZUFycmF5Lmxlbmd0aCA9PT0gMikge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y29uc3Qga2V5ID0ga2V5VmFsdWVBcnJheVswXTtcblx0XHRcdFx0XHRcdFx0XHRcdGNvbnN0IHZhbHVlID0ga2V5VmFsdWVBcnJheVsxXTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0Y29uc3Qgc3BsaXRBcnJheSA9IGtleS5zcGxpdChcIl9cIik7XG5cdFx0XHRcdFx0XHRcdFx0XHRjb25zdCBtb2RpZmllZEtleSA9IGA8PGNoZWNrYm94QnlUaW1lIFwiJHtzcGxpdEFycmF5WzFdfVwiPj5gO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRjaGVja2JveE1hcC5zZXQobW9kaWZpZWRLZXksIHZhbHVlID09PSBcIm9wZW5cIiA/IFwiW3hdXCIgOiBcIlsgXVwiKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKGxpbmUudHJpbSgpLmxlbmd0aCAhPSAwKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRsZXQgbW9kaWZpZWRMaW5lID0gbGluZVxuXHRcdFx0XHRcdFx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCA5OyBpKyspIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0bW9kaWZpZWRMaW5lID0gbW9kaWZpZWRMaW5lLnJlcGxhY2UoL14gICAgLywgXCJcXHRcIilcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdG1vZGlmaWVkTGluZSA9IG1vZGlmaWVkTGluZS5yZXBsYWNlKC9eKFxcdCopXFwqXFxzLywgXCIkMS0gXCIpXG5cdFx0XHRcdFx0XHRcdFx0XHRtb2RpZmllZExpbmUgPSAoL15cXHQqLSAvLnRlc3QobW9kaWZpZWRMaW5lKSB8fCAvXlxcdCpcXGQrXFwuIC8udGVzdChtb2RpZmllZExpbmUpKSA/IChcIlxcdFwiICsgbW9kaWZpZWRMaW5lKSA6IChcIlxcdC0gXCIgKyBtb2RpZmllZExpbmUpXG5cdFx0XHRcdFx0XHRcdFx0XHRjb250ZW50ICs9IFwiXFxuXCIgKyBtb2RpZmllZExpbmVcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmIChoM0NvdW50ID49IDIgJiYgbGluZS50cmltKCkubGVuZ3RoICE9IDApIHtcblx0XHRcdFx0XHRcdFx0bGV0IG1vZGlmaWVkTGluZSA9IChsaW5lID09PSBcIlsgXSBcIikgPyBcIlwiIDogbGluZVxuXHRcdFx0XHRcdFx0XHRpZiAobW9kaWZpZWRMaW5lLnRyaW0oKS5sZW5ndGggIT0gMCkge1xuXHRcdFx0XHRcdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgOTsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRtb2RpZmllZExpbmUgPSBtb2RpZmllZExpbmUucmVwbGFjZSgvXiAgICAvLCBcIlxcdFwiKVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRtb2RpZmllZExpbmUgPSBtb2RpZmllZExpbmUucmVwbGFjZSgvXihcXHQqKVxcKlxccy8sIFwiJDEtIFwiKVxuXHRcdFx0XHRcdFx0XHRcdG1vZGlmaWVkTGluZSA9ICgvXlxcdCotIC8udGVzdChtb2RpZmllZExpbmUpIHx8IC9eXFx0KlxcZCtcXC4gLy50ZXN0KG1vZGlmaWVkTGluZSkpID8gKFwiXFx0XCIgKyBtb2RpZmllZExpbmUpIDogKFwiXFx0LSBcIiArIG1vZGlmaWVkTGluZSlcblx0XHRcdFx0XHRcdFx0XHQvLyBtb2RpZmllZExpbmUgPSBsaW5lID09PSBcIi0tLVwiID8gXCItLS1cIiA6IG1vZGlmaWVkTGluZVxuXG5cdFx0XHRcdFx0XHRcdFx0Zm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgY2hlY2tib3hNYXApIHtcblx0XHRcdFx0XHRcdFx0XHRcdG1vZGlmaWVkTGluZSA9IG1vZGlmaWVkTGluZS5yZXBsYWNlKG5ldyBSZWdFeHAoa2V5LCBcImdcIiksIHZhbHVlKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0bW9kaWZpZWRMaW5lID0gbW9kaWZpZWRMaW5lLnJlcGxhY2UoLzw8Y2hlY2tib3hCeVRpbWUgXCJbQS1aYS16MC05X10rXCI+Pi9nLCBcIlsgXVwiKVxuXG5cdFx0XHRcdFx0XHRcdFx0dGV4dCArPSAoXCJcXG5cIiArIG1vZGlmaWVkTGluZSlcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKGxpbmUgPT09IFwiLS0tXCIpIHtcblx0XHRcdFx0XHRcdFx0bGV0IGJlZm9yZUgzID0gaDNDb3VudFxuXHRcdFx0XHRcdFx0XHRoM0NvdW50Kys7XG5cdFx0XHRcdFx0XHRcdGlmIChiZWZvcmVIMyA9PSAxICYmIGgzQ291bnQgPT0gMikge1xuXHRcdFx0XHRcdFx0XHRcdHRleHQgKz0gYWN0aW9uVGFnICsgdmlldy5maWxlLmJhc2VuYW1lXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKGgzQ291bnQgPCAyKSB7IC8vIG5vIGZyb250bWF0dGVyXG5cdFx0XHRcdFx0XHR0ZXh0ICs9IHZpZXcuZmlsZS5iYXNlbmFtZVxuXHRcdFx0XHRcdH0gXG5cdFx0XHRcdFx0dGV4dCArPSBjb250ZW50XG5cdFx0XHRcdFx0ZWRpdG9yLnNldFZhbHVlKHRleHQpXG5cdFx0XHRcdFx0ZWRpdG9yLnNldEN1cnNvcih7bGluZTogZ2V0UGFyZW50TGluZSh0ZXh0KSwgY2g6IDB9KVxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0aG90a2V5czogW1xuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bW9kaWZpZXJzOiBbYEN0cmxgLCBgTWV0YWAsIGBTaGlmdGBdLFxuXHRcdFx0XHRcdGtleTogYDhgLFxuXHRcdFx0XHR9LFxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bW9kaWZpZXJzOiBbYEN0cmxgLCBgQWx0YCwgYFNoaWZ0YF0sXG5cdFx0XHRcdFx0a2V5OiBgOGAsXG5cdFx0XHRcdH0sXG5cdFx0XHRdXG5cdFx0fSk7XG5cblx0XHR0aGlzLmFkZENvbW1hbmQoe1xuXHRcdFx0aWQ6IFwicmVtb3ZlLWNvbnRlbnQtZnJvbS1jdXJzb3JcIixcblx0XHRcdG5hbWU6IFwiUmVtb3ZlIGNvbnRlbnQgZnJvbSBjdXJzb3JcIixcblx0XHRcdGljb246IGBheGVgLFxuXHRcdFx0ZWRpdG9yQ2FsbGJhY2s6IChlZGl0b3I6IEVkaXRvciwgdmlldzogTWFya2Rvd25WaWV3KSA9PiB7XG5cdFx0XHRcdG5ldyBSZW1vdmVDb250ZW50RnJvbUN1cnNvck1vZGFsKHRoaXMuYXBwLCBlZGl0b3IpLm9wZW4oKVxuXHRcdFx0fSxcblx0XHRcdGhvdGtleXM6IFtcblx0XHRcdFx0e1xuXHRcdFx0XHRcdG1vZGlmaWVyczogW2BDdHJsYCwgYE1ldGFgLCBgU2hpZnRgXSxcblx0XHRcdFx0XHRrZXk6IGB4YCxcblx0XHRcdFx0fSxcblx0XHRcdFx0e1xuXHRcdFx0XHRcdG1vZGlmaWVyczogW2BDdHJsYCwgYEFsdGAsIGBTaGlmdGBdLFxuXHRcdFx0XHRcdGtleTogYHhgLFxuXHRcdFx0XHR9LFxuXHRcdFx0XVxuXHRcdH0pO1xuXHRcdFxuXHRcdHRoaXMuYWRkQ29tbWFuZCh7XG5cdFx0XHRpZDogXCJyZW1vdmUtY29udGVudC1sZWZ0XCIsXG5cdFx0XHRuYW1lOiBcIlJlbW92ZSBjb250ZW50IGxlZnQgc2FtZSBsaW5lXCIsXG5cdFx0XHRpY29uOiBgYXJyb3ctbGVmdC1jaXJjbGVgLFxuXHRcdFx0ZWRpdG9yQ2FsbGJhY2s6IChlZGl0b3I6IEVkaXRvciwgdmlldzogTWFya2Rvd25WaWV3KSA9PiB7XG5cdFx0XHRcdHJlbW92ZUNvbnRlbnRMZWZ0U2FtZUxpbmUoZWRpdG9yKVxuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0dGhpcy5hZGRDb21tYW5kKHtcblx0XHRcdGlkOiBcInJlbW92ZS1jb250ZW50LXJpZ2h0XCIsXG5cdFx0XHRuYW1lOiBcIlJlbW92ZSBjb250ZW50IHJpZ2h0IHNhbWUgbGluZVwiLFxuXHRcdFx0aWNvbjogYGFycm93LXJpZ2h0LWNpcmNsZWAsXG5cdFx0XHRlZGl0b3JDYWxsYmFjazogKGVkaXRvcjogRWRpdG9yLCB2aWV3OiBNYXJrZG93blZpZXcpID0+IHtcblx0XHRcdFx0cmVtb3ZlQ29udGVudExlZnRTYW1lTGluZShlZGl0b3IpXG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHR0aGlzLmFkZENvbW1hbmQoe1xuXHRcdFx0aWQ6IFwicmVtb3ZlLWNvbnRlbnQtdG9wLWxlZnRcIixcblx0XHRcdG5hbWU6IFwiUmVtb3ZlIGNvbnRlbnQgZnJvbSBzdGFydCBvZiBub3RlIHRvIGN1cnNvclwiLFxuXHRcdFx0aWNvbjogYGFycm93LXVwLWNpcmNsZWAsXG5cdFx0XHRlZGl0b3JDYWxsYmFjazogKGVkaXRvcjogRWRpdG9yLCB2aWV3OiBNYXJrZG93blZpZXcpID0+IHtcblx0XHRcdFx0cmVtb3ZlQ29udGVudEZyb21TdGFydE9mTm90ZVRvQ3Vyc29yKGVkaXRvcilcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdHRoaXMuYWRkQ29tbWFuZCh7XG5cdFx0XHRpZDogXCJyZW1vdmUtY29udGVudC1ib3R0b20tcmlnaHRcIixcblx0XHRcdG5hbWU6IFwiUmVtb3ZlIGNvbnRlbnQgZnJvbSBjdXJzb3IgdG8gZW5kIG9mIG5vdGVcIixcblx0XHRcdGljb246IGBhcnJvdy1kb3duLWNpcmNsZWAsXG5cdFx0XHRlZGl0b3JDYWxsYmFjazogKGVkaXRvcjogRWRpdG9yLCB2aWV3OiBNYXJrZG93blZpZXcpID0+IHtcblx0XHRcdFx0cmVtb3ZlQ29udGVudEZyb21DdXJzb3JUb0VuZE9mTm90ZShlZGl0b3IpXG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHR0aGlzLmFkZE9ic2lkaWFuSWNvbigndGhyZWFkcy10by1ibG9nLWljb24nLCAnVEInKTtcblx0XHR0aGlzLmFkZENvbW1hbmQoe1xuXHRcdFx0aWQ6IFwidGhyZWFkcy10by1ibG9nXCIsXG5cdFx0XHRuYW1lOiBcIlRCIFRocmVhZHMgYXMgcHJlIEJsb2cgZm9ybWF0IHRvIENsaXBib2FyZFwiLFxuXHRcdFx0aWNvbjogYHRocmVhZHMtdG8tYmxvZy1pY29uYCxcblx0XHRcdGVkaXRvckNhbGxiYWNrOiAoZWRpdG9yOiBFZGl0b3IsIHZpZXc6IE1hcmtkb3duVmlldykgPT4ge1xuXHRcdFx0XHRuZXcgVGhyZWFkc1RvQmxvZ01vZGFsKHRoaXMuYXBwLCBlZGl0b3IsIHZpZXcpLm9wZW4oKVxuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0Lypcblx0XHR0aGlzLmFkZE9ic2lkaWFuSWNvbignY2hhdGdwdC1wcm9tcHQtZm9yLWdlbmVyYXRpbmctc3VtbWFyeS10by1jbGlwYm9hcmQnLCAnR1MnKTtcblx0XHR0aGlzLmFkZENvbW1hbmQoe1xuXHRcdFx0aWQ6IFwiY2hhdGdwdC1wcm9tcHQtZm9yLWdlbmVyYXRpbmctc3VtbWFyeS10by1jbGlwYm9hcmRcIixcblx0XHRcdG5hbWU6IFwiR1MgQ2hhdEdQVCBwcm9tcHQgZm9yIGdlbmVyYXRpbmcgc3VtbWFyeSB0byBjbGlwYm9hcmRcIixcblx0XHRcdGljb246IGBjaGF0Z3B0LXByb21wdC1mb3ItZ2VuZXJhdGluZy1zdW1tYXJ5LXRvLWNsaXBib2FyZGAsXG5cdFx0XHRlZGl0b3JDYWxsYmFjazogKGVkaXRvcjogRWRpdG9yLCB2aWV3OiBNYXJrZG93blZpZXcpID0+IHtcblx0XHRcdFx0Y29uc3QgcHJvbXB0ID0gXCJcdThBQ0JcdTVDMDdcdTRFRTVcdTRFMEJcdTc2ODRcdTY1ODdcdTdBRTBcdTdCQzBcdTkzMDRcdTdFMkVcdTc3RURcdTYyMTBcdTdEMDQxNTBcdTVCNTdcdTc2ODRcdTRFMkRcdTY1ODdcdTY0NThcdTg5ODFcdUZGMENcdTc4QkFcdTRGRERcdTY0NThcdTg5ODFcdTUxNjdcdTVCQjlcdTdDQkVcdTcxNDlcdTRFMTRcdTdBODFcdTUxRkFcdTkxQ0RcdTlFREVcdTMwMDJcdTRGNjBcdTk3MDBcdTg5ODFcdTZDRThcdTYxMEZcdTRFRTVcdTRFMEJcdTVFN0VcdTlFREVcdUZGMUFcXG5cIiArXG5cdFx0XHRcdFx0XHRcdCAgIFwiXFxuXCIgK1xuXHRcdFx0XHRcdFx0XHQgICBcIjEuIFx1NUMwN1x1OTU3N1x1N0JDN1x1NTkyN1x1OEFENlx1N0UyRVx1NzdFRFx1RkYwQ1x1NTNFQVx1NEZERFx1NzU1OVx1NjcwMFx1OTFDRFx1ODk4MVx1NzY4NFx1OEEwQVx1NjA2Rlx1NTQ4Q1x1NEUzQlx1OTg0Q1x1MzAwMlxcblwiICtcblx0XHRcdFx0XHRcdFx0ICAgXCIyLiBcdTUzQkJcdTk2NjRcdTk3NUVcdTVGQzVcdTg5ODFcdTc2ODRcdThBNzNcdTdEMzBcdThBMEFcdTYwNkZcdUZGMENcdTRFMjZcdTkwN0ZcdTUxNERcdTRGN0ZcdTc1MjhcdTkwNEVcdTY1QkNcdTdFNDFcdTg5MDdcdTYyMTZcdTRFMERcdTVGQzVcdTg5ODFcdTc2ODRcdThBOUVcdThBMDBcdTMwMDJcXG5cIiArXG5cdFx0XHRcdFx0XHRcdCAgIFwiMy4gXHU0RkREXHU3NTU5XHU2NTg3XHU3QUUwXHU0RTJEXHU2NzAwXHU5MUNEXHU4OTgxXHU3Njg0XHU0RTNCXHU5ODRDXHU1NDhDXHU4QTBBXHU2MDZGXHVGRjBDXHU0RTI2XHU3OEJBXHU0RkREXHU5MDE5XHU0RTlCXHU4QTBBXHU2MDZGXHU1NzI4XHU2NDU4XHU4OTgxXHU0RTJEXHU2RTA1XHU2OTVBXHU1NzMwXHU4ODY4XHU5MDU0XHU1MUZBXHU0Rjg2XHUzMDAyXFxuXCIgK1xuXHRcdFx0XHRcdFx0XHQgICBcIjQuIFx1NEY3Rlx1NzUyOFx1N0NCRVx1NzE0OVx1NEUxNFx1NzZGNFx1NjNBNVx1NzY4NFx1OEE5RVx1OEEwMFx1RkYwQ1x1NEVFNVx1NTQzOFx1NUYxNVx1NEVCQVx1NzY4NFx1NjVCOVx1NUYwRlx1ODg2OFx1OTA1NFx1NEY1Q1x1ODAwNVx1NUMwN1x1NTcyOFx1NjU4N1x1N0FFMFx1NEUyRFx1NkRGMVx1NTE2NVx1NTIwNlx1NEVBQlx1OTAxOVx1NEU5Qlx1NEUzQlx1OTg0Q1x1NzY4NFx1NjEwRlx1NTcxNlx1MzAwMlxcblwiICtcblx0XHRcdFx0XHRcdFx0ICAgXCI1LiBcdTRGN0ZcdTc1MjhcdTMwMENcdTYyMTFcdTMwMERcdTRGODZcdTYzMDdcdTdBMzFcdTMwMENcdTRGNUNcdTgwMDVcdTMwMERcdUZGMENcdTMwMENcdTRGNjBcdTMwMERcdTRGODZcdTYzMDdcdTdBMzFcdThCODBcdTgwMDVcdTMwMDJcXG5cIiArXG5cdFx0XHRcdFx0XHRcdCAgIFwiXFxuXCIgK1xuXHRcdFx0XHRcdFx0XHQgICBcIlx1NTE3N1x1OUFENFx1NEY4Nlx1OEFBQVx1RkYwQ1x1NEY2MFx1OTcwMFx1ODk4MVx1NzhCQVx1NEZERFx1NEVFNVx1NEUwQlx1OTFDRFx1OUVERVx1OEEwQVx1NjA2Rlx1ODhBQlx1NTMwNVx1NTQyQlx1NTE3Nlx1NEUyRFx1RkYxQVxcblwiICtcblx0XHRcdFx0XHRcdFx0ICAgXCIxLiBcdTY1ODdcdTdBRTBcdTc2ODRcdTRFM0JcdTg5ODFcdTRFM0JcdTk4NENcdTYyMTZcdTkxQ0RcdTlFREVcdThBMEVcdThBRDZcdTMwMDJcXG5cIiArXG5cdFx0XHRcdFx0XHRcdCAgIFwiMi4gXHU0RjVDXHU4MDA1XHU2M0QwXHU1MUZBXHU3Njg0XHU1RUZBXHU4QjcwXHUzMDAxXHU3QjU2XHU3NTY1XHU2MjE2XHU5MUNEXHU4OTgxXHU4OUMwXHU5RURFXHUzMDAyXFxuXCIgK1xuXHRcdFx0XHRcdFx0XHQgICBcIjMuIFx1OTAxOVx1NEU5Qlx1NUVGQVx1OEI3MFx1NjIxNlx1N0I1Nlx1NzU2NVx1NzY4NFx1NTE3N1x1OUFENFx1NjU0OFx1NzZDQVx1NjIxNlx1N0Q1MFx1Njc5Q1x1MzAwMlxcblwiICtcblx0XHRcdFx0XHRcdFx0ICAgXCJcXG5cIiArXG5cdFx0XHRcdFx0XHRcdCAgIFwiXHU2NzAwXHU1RjhDXHVGRjBDXHU0RUU1XHU1NDM4XHU1RjE1XHU0RTI2XHU5RjEzXHU1MkY1XHU4QjgwXHU4MDA1XHU5MDMyXHU4ODRDXHU0RTBCXHU0RTAwXHU2QjY1XHU4ODRDXHU1MkQ1XHU3Njg0XHU2NUI5XHU1RjBGXHU3REU4XHU1QkVCXHU2NDU4XHU4OTgxXHVGRjBDXHU0RTI2XHU4ODY4XHU5MDU0XHU1MUZBXHU2NTg3XHU3QUUwXHU0RTJEXHU2NkY0XHU1OTFBXHU2REYxXHU1MTY1XHU3Njg0XHU1MTY3XHU1QkI5XHU3QjQ5XHU1Rjg1XHU4QjgwXHU4MDA1XHU1M0JCXHU2M0EyXHU3RDIyXHUzMDAyXFxuXCIgK1xuXHRcdFx0XHRcdFx0XHQgICBcIlx1OEFDQlx1NUJFQlx1NTFGQTNcdTUwMEJcdTcyNDhcdTY3MkNcdTMwMDJcXG5cXG5cIiArIGVkaXRvci5nZXRWYWx1ZSgpO1xuXG5cdFx0XHRcdG5hdmlnYXRvci5jbGlwYm9hcmQud3JpdGVUZXh0KHByb21wdCkudGhlbihmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0bmV3IE5vdGljZShgQ29waWVkIHByb21wdCBmb3IgZ2VuZXJhdGUgc3VtbWFyeSB0byBjbGlwYm9hcmQhYCk7XG5cdFx0XHRcdH0sIGZ1bmN0aW9uIChlcnJvcikge1xuXHRcdFx0XHRcdG5ldyBOb3RpY2UoYGVycm9yIHdoZW4gY29weSB0byBjbGlwYm9hcmQhYCk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdCovXG5cblx0XHR0aGlzLmFkZE9ic2lkaWFuSWNvbignYWRkLWNvbW1lbnQtdGFnLWljb24nLCAnQ1QnKTtcblx0XHR0aGlzLmFkZENvbW1hbmQoe1xuXHRcdFx0aWQ6IFwiYWRkLWNvbW1lbnQtdGFnXCIsXG5cdFx0XHRuYW1lOiBcIkNUIEFkZCBDb21tZW50IFRhZ1wiLFxuXHRcdFx0aWNvbjogYGFkZC1jb21tZW50LXRhZy1pY29uYCxcblx0XHRcdGVkaXRvckNhbGxiYWNrOiAoZWRpdG9yOiBFZGl0b3IsIHZpZXc6IE1hcmtkb3duVmlldykgPT4ge1xuXHRcdFx0ICBuZXcgQWRkRm9vdG5vdGVUYWdNb2RhbCh0aGlzLmFwcCwgZWRpdG9yKS5vcGVuKCk7XG5cdFx0XHR9LFxuXHRcdFx0aG90a2V5czogW1xuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bW9kaWZpZXJzOiBbYEN0cmxgLCBgTWV0YWAsIGBTaGlmdGBdLFxuXHRcdFx0XHRcdGtleTogYHpgLFxuXHRcdFx0XHR9LFxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bW9kaWZpZXJzOiBbYEN0cmxgLCBgQWx0YCwgYFNoaWZ0YF0sXG5cdFx0XHRcdFx0a2V5OiBgemAsXG5cdFx0XHRcdH0sXG5cdFx0XHRdXG5cdFx0fSk7XG5cblx0XHR0aGlzLmFkZE9ic2lkaWFuSWNvbignYWN0aW9uLXRhZy1jb3VudC1pY29uJywgJ0NBJyk7XG5cdFx0dGhpcy5hZGRDb21tYW5kKHtcblx0XHRcdGlkOiBcImFjdGlvbi10YWctY291bnQtaWNvblwiLFxuXHRcdFx0bmFtZTogXCJDQSBDb3VudCBBY3Rpb24gVGFnXCIsXG5cdFx0XHRpY29uOiBgYWN0aW9uLXRhZy1jb3VudC1pY29uYCxcblx0XHRcdGVkaXRvckNhbGxiYWNrOiAoZWRpdG9yOiBFZGl0b3IsIHZpZXc6IE1hcmtkb3duVmlldykgPT4ge1xuXHRcdFx0XHRjb25zdCB0YWdzID0gW1wibm5cIiwgXCJubFwiLCBcIm53XCIsIFwibjFcIiwgXCJuMlwiLCBcIm4zXCIsIFwibjRcIiwgXCJuNVwiLCBcIm42XCIsIFwibjdcIiwgXCJ3blwiLCBcIndsXCIsIFwid3dcIiwgXCJ3MVwiLCBcIncyXCIsIFwidzNcIiwgXCJ3NFwiLCBcInc1XCIsIFwidzZcIiwgXCJ3N1wiXTtcblx0XHRcdFx0Y29uc3QgbWF0Y2hlczogc3RyaW5nW10gPSBbXTtcblx0XHRcdFx0Y29uc3QgbGluZU51bSA9IGVkaXRvci5saW5lQ291bnQoKTtcblx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lTnVtOyBpKyspIHtcblx0XHRcdFx0XHRjb25zdCBsaW5lID0gZWRpdG9yLmdldExpbmUoaSlcblx0XHRcdFx0XHRjb25zdCBtYXRjaCA9IHRhZ3Muc29tZSh0YWcgPT4gbmV3IFJlZ0V4cChgIyR7dGFnfSBgLCBcImdcIikudGVzdChsaW5lKSB8fCBuZXcgUmVnRXhwKGAgIyR7dGFnfWAsIFwiZ1wiKS50ZXN0KGxpbmUpKTtcblx0XHRcdFx0XHRpZiAobWF0Y2gpIHtcblx0XHRcdFx0XHRcdG1hdGNoZXMucHVzaChgTGluZSAke2l9OlxcbiR7bGluZS50cmltKCl9YCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGNvbnN0IHRyaW1tZWRBbmRKb2luZWRTdHJpbmc6IHN0cmluZyA9IG1hdGNoZXMuam9pbihcIlxcblxcblwiKTtcblx0XHRcdFx0Y29uc3QgdGFza3MgPSBtYXRjaGVzLmxlbmd0aCA+IDAgPyBgXFxuVGFza3M6XFxuXFxuJHt0cmltbWVkQW5kSm9pbmVkU3RyaW5nfWAgOiBgYFxuXHRcdFx0XHRuZXcgTm90aWNlKGBUaGVyZSBhcmUgJHttYXRjaGVzLmxlbmd0aH0gb3V0c3RhbmRpbmcgYWN0aW9ucyBpbiB0aGlzIG5vdGVzJHt0YXNrc31gKTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdHRoaXMuYWRkT2JzaWRpYW5JY29uKCd0b2dnbGUtbi13LXRhc2snLCAnIz0nKTtcblx0XHR0aGlzLmFkZENvbW1hbmQoe1xuXHRcdFx0aWQ6IGB0b2dnbGUtbi13LXRhc2tgLFxuXHRcdFx0bmFtZTogYFRvZ2dsZSBOIFcgVGFza2AsXG5cdFx0XHRpY29uOiBgdG9nZ2xlLW4tdy10YXNrYCxcblx0XHRcdGVkaXRvckNhbGxiYWNrOiAoZWRpdG9yOiBFZGl0b3IsIHZpZXc6IE1hcmtkb3duVmlldykgPT4ge1xuXHRcdFx0XHRjb25zb2xlLmxvZyhlZGl0b3IuZ2V0U2VsZWN0aW9uKCkpO1xuXHRcdFx0XHRjb25zdCBjdXJzb3IgPSBlZGl0b3IuZ2V0Q3Vyc29yKCk7XG5cdFx0XHRcdGNvbnN0IGxpbmVOdW1iZXIgPSBlZGl0b3IuZ2V0Q3Vyc29yKCkubGluZTtcblx0XHRcdFx0Y29uc3QgbGluZSA9IGVkaXRvci5nZXRMaW5lKGxpbmVOdW1iZXIpO1xuXHRcdFx0XHRpZiAobGluZS5tYXRjaCgvIGFcXC93XFwvLi8pKSB7XG5cdFx0XHRcdFx0Y29uc3QgcmVwbGFjZWRMaW5lID0gbGluZS5yZXBsYWNlKC8gYVxcL3dcXC8oLikvLCBgIGEvbi8kMWApXG5cdFx0XHRcdFx0ZWRpdG9yLnNldExpbmUobGluZU51bWJlciwgcmVwbGFjZWRMaW5lKTtcblx0XHRcdFx0XHRlZGl0b3Iuc2V0Q3Vyc29yKGN1cnNvcilcblx0XHRcdFx0fSBlbHNlIGlmIChsaW5lLm1hdGNoKC8gYVxcL25cXC8uLykpIHtcblx0XHRcdFx0XHRjb25zdCByZXBsYWNlZExpbmUgPSBsaW5lLnJlcGxhY2UoLyBhXFwvblxcLyguKS8sIGAgYS93LyQxYClcblx0XHRcdFx0XHRlZGl0b3Iuc2V0TGluZShsaW5lTnVtYmVyLCByZXBsYWNlZExpbmUpO1xuXHRcdFx0XHRcdGVkaXRvci5zZXRDdXJzb3IoY3Vyc29yKVxuXHRcdFx0XHR9IGVsc2UgaWYgKGxpbmUubWF0Y2goLyN3LiAvKSkge1xuXHRcdFx0XHRcdGNvbnN0IHJlcGxhY2VkTGluZSA9IGxpbmUucmVwbGFjZSgvI3coLikgLywgYCNuJDEgYClcblx0XHRcdFx0XHRlZGl0b3Iuc2V0TGluZShsaW5lTnVtYmVyLCByZXBsYWNlZExpbmUpO1xuXHRcdFx0XHRcdGVkaXRvci5zZXRDdXJzb3IoY3Vyc29yKVxuXHRcdFx0XHR9IGVsc2UgaWYgKGxpbmUubWF0Y2goLyNuLiAvKSkge1xuXHRcdFx0XHRcdGNvbnN0IHJlcGxhY2VkTGluZSA9IGxpbmUucmVwbGFjZSgvI24oLikgLywgYCN3JDEgYClcblx0XHRcdFx0XHRlZGl0b3Iuc2V0TGluZShsaW5lTnVtYmVyLCByZXBsYWNlZExpbmUpO1xuXHRcdFx0XHRcdGVkaXRvci5zZXRDdXJzb3IoY3Vyc29yKVxuXHRcdFx0XHR9IGVsc2UgaWYgKGxpbmUubWF0Y2goLyAjdy4vKSkge1xuXHRcdFx0XHRcdGNvbnN0IHJlcGxhY2VkTGluZSA9IGxpbmUucmVwbGFjZSgvICN3KC4pLywgYCAjbiQxYClcblx0XHRcdFx0XHRlZGl0b3Iuc2V0TGluZShsaW5lTnVtYmVyLCByZXBsYWNlZExpbmUpO1xuXHRcdFx0XHRcdGVkaXRvci5zZXRDdXJzb3IoY3Vyc29yKVxuXHRcdFx0XHR9IGVsc2UgaWYgKGxpbmUubWF0Y2goLyAjbi4vKSkge1xuXHRcdFx0XHRcdGNvbnN0IHJlcGxhY2VkTGluZSA9IGxpbmUucmVwbGFjZSgvICNuKC4pLywgYCAjdyQxYClcblx0XHRcdFx0XHRlZGl0b3Iuc2V0TGluZShsaW5lTnVtYmVyLCByZXBsYWNlZExpbmUpO1xuXHRcdFx0XHRcdGVkaXRvci5zZXRDdXJzb3IoY3Vyc29yKVxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0aG90a2V5czogW1xuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bW9kaWZpZXJzOiBbYEN0cmxgLCBgTWV0YWAsIGBTaGlmdGBdLFxuXHRcdFx0XHRcdGtleTogYD1gLFxuXHRcdFx0XHR9LFxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bW9kaWZpZXJzOiBbYEN0cmxgLCBgQWx0YCwgYFNoaWZ0YF0sXG5cdFx0XHRcdFx0a2V5OiBgPWAsXG5cdFx0XHRcdH1cblx0XHRcdF1cblx0XHR9KTtcblxuXHRcdC8qXG5cdFx0dGhpcy5hZGRPYnNpZGlhbkljb24oJ3JlbW92ZS1hY3Rpb24taWNvbicsICctIycpO1xuXHRcdHRoaXMuYWRkQ29tbWFuZCh7XG5cdFx0XHRpZDogXCJyZW1vdmUtYWN0aW9uXCIsXG5cdFx0XHRuYW1lOiBcIlJlbW92ZSBhY3Rpb25cIixcblx0XHRcdGljb246IGByZW1vdmUtYWN0aW9uLWljb25gLFxuXHRcdFx0ZWRpdG9yQ2FsbGJhY2s6IChlZGl0b3I6IEVkaXRvciwgdmlldzogTWFya2Rvd25WaWV3KSA9PiB7XG5cdFx0XHRcdGNvbnN0IGN1cnNvciA9IGVkaXRvci5nZXRDdXJzb3IoKTtcblx0XHRcdFx0Y29uc3QgbGluZU51bWJlciA9IGVkaXRvci5nZXRDdXJzb3IoKS5saW5lO1xuXHRcdFx0XHRjb25zdCBsaW5lID0gZWRpdG9yLmdldExpbmUobGluZU51bWJlcik7XG5cdFx0XHRcdGxldCByZXBsYWNlZExpbmUgPSBsaW5lLnJlcGxhY2UoJyNubiAnLCAnJylcblx0XHRcdFx0ICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKCcjbmwgJywgJycpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCAucmVwbGFjZSgnI253ICcsICcnKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQgLnJlcGxhY2UoJyNuZCAnLCAnJylcblx0XHRcdFx0XHRcdFx0XHRcdFx0IC5yZXBsYWNlKCcjbmEgJywgJycpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCAucmVwbGFjZSgnI250ICcsICcnKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQgLnJlcGxhY2UoJyNuMSAnLCAnJylcblx0XHRcdFx0XHRcdFx0XHRcdFx0IC5yZXBsYWNlKCcjbjIgJywgJycpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCAucmVwbGFjZSgnI24zICcsICcnKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQgLnJlcGxhY2UoJyNuNCAnLCAnJylcblx0XHRcdFx0XHRcdFx0XHRcdFx0IC5yZXBsYWNlKCcjbjUgJywgJycpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCAucmVwbGFjZSgnI242ICcsICcnKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQgLnJlcGxhY2UoJyNuNyAnLCAnJylcblx0XHRcdFx0XHRcdFx0XHRcdFx0IC5yZXBsYWNlKCcjd24gJywgJycpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCAucmVwbGFjZSgnI3dsICcsICcnKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQgLnJlcGxhY2UoJyN3dyAnLCAnJylcblx0XHRcdFx0XHRcdFx0XHRcdFx0IC5yZXBsYWNlKCcjd2QgJywgJycpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCAucmVwbGFjZSgnI3dhICcsICcnKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQgLnJlcGxhY2UoJyN3dCAnLCAnJylcblx0XHRcdFx0XHRcdFx0XHRcdFx0IC5yZXBsYWNlKCcjdzEgJywgJycpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCAucmVwbGFjZSgnI3cyICcsICcnKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQgLnJlcGxhY2UoJyN3MyAnLCAnJylcblx0XHRcdFx0XHRcdFx0XHRcdFx0IC5yZXBsYWNlKCcjdzQgJywgJycpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCAucmVwbGFjZSgnI3c1ICcsICcnKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQgLnJlcGxhY2UoJyN3NiAnLCAnJylcblx0XHRcdFx0XHRcdFx0XHRcdFx0IC5yZXBsYWNlKCcjdzcgJywgJycpXG5cdFx0XHRcdHJlcGxhY2VkTGluZSA9IEFkZEZvb3Rub3RlVGFnTW9kYWwucmVtb3ZlVGFnKHJlcGxhY2VkTGluZSlcblx0XHRcdFx0ZWRpdG9yLnNldExpbmUobGluZU51bWJlciwgcmVwbGFjZWRMaW5lKTtcblx0XHRcdFx0ZWRpdG9yLnNldEN1cnNvcihjdXJzb3IpO1xuXHRcdFx0fSxcblx0XHRcdGhvdGtleXM6IFtcblx0XHRcdFx0e1xuXHRcdFx0XHRcdG1vZGlmaWVyczogW2BDdHJsYCwgYE1ldGFgLCBgU2hpZnRgXSxcblx0XHRcdFx0XHRrZXk6IGB4YCxcblx0XHRcdFx0fSxcblx0XHRcdFx0e1xuXHRcdFx0XHRcdG1vZGlmaWVyczogW2BDdHJsYCwgYEFsdGAsIGBTaGlmdGBdLFxuXHRcdFx0XHRcdGtleTogYHhgLFxuXHRcdFx0XHR9XG5cdFx0XHRdXG5cdFx0fSk7XG5cdFx0Ki9cblxuXHRcdHRoaXMuYWRkQ29tbWFuZCh7XG5cdFx0XHRpZDogXCJjdXJzb3ItZ28tdG8tc3RhcnQtb2YtbGluZVwiLFxuXHRcdFx0bmFtZTogXCJDdXJzb3IgZ28gdG8gc3RhcnQgb2YgbGluZVwiLFxuXHRcdFx0aWNvbjogYGFycm93LWJpZy1sZWZ0YCxcblx0XHRcdGVkaXRvckNhbGxiYWNrOiAoZWRpdG9yOiBFZGl0b3IsIHZpZXc6IE1hcmtkb3duVmlldykgPT4ge1xuXHRcdFx0XHRjb25zdCBjdXJzb3IgPSBlZGl0b3IuZ2V0Q3Vyc29yKCk7XG5cdFx0XHRcdGN1cnNvci5jaCA9IDA7XG5cdFx0XHRcdGVkaXRvci5zZXRDdXJzb3IoY3Vyc29yKTtcblx0XHRcdH0sXG5cdFx0fSk7XG5cblx0XHR0aGlzLmFkZENvbW1hbmQoe1xuXHRcdFx0aWQ6IFwiY3Vyc29yLWdvLXRvLWVuZC1vZi1saW5lXCIsXG5cdFx0XHRuYW1lOiBcIkN1cnNvciBnbyB0byBlbmQgb2YgbGluZVwiLFxuXHRcdFx0aWNvbjogYGFycm93LWJpZy1yaWdodGAsXG5cdFx0XHRlZGl0b3JDYWxsYmFjazogKGVkaXRvcjogRWRpdG9yLCB2aWV3OiBNYXJrZG93blZpZXcpID0+IHtcblx0XHRcdFx0Y29uc3QgY3Vyc29yID0gZWRpdG9yLmdldEN1cnNvcigpO1xuXHRcdFx0XHRjb25zdCBsaW5lTnVtID0gY3Vyc29yLmxpbmU7XG5cdFx0XHRcdGNvbnN0IGxpbmUgPSBlZGl0b3IuZ2V0TGluZShsaW5lTnVtKTtcblx0XHRcdFx0Y29uc3QgbGVuZ3RoID0gbGluZS5sZW5ndGg7XG5cdFx0XHRcdGN1cnNvci5jaCA9IGxlbmd0aDtcblx0XHRcdFx0ZWRpdG9yLnNldEN1cnNvcihjdXJzb3IpO1xuXHRcdFx0fSxcblx0XHR9KTtcblxuXHRcdHRoaXMuYWRkT2JzaWRpYW5JY29uKCdldmVudC10by1mYW50YXN0aWNhbC1pY29uJywgJ0ZFJyk7XG5cdFx0dGhpcy5hZGRDb21tYW5kKHtcblx0XHRcdGlkOiBcImFkZC1mYW50YXN0aWNhbC1ldmVudFwiLFxuXHRcdFx0bmFtZTogXCJGRSBBZGQgRmFudGFzdGljYWwgRXZlbnRcIixcblx0XHRcdGljb246IGBldmVudC10by1mYW50YXN0aWNhbC1pY29uYCxcblx0XHRcdGVkaXRvckNhbGxiYWNrOiAoZWRpdG9yOiBFZGl0b3IsIHZpZXc6IE1hcmtkb3duVmlldykgPT4ge1xuXHRcdFx0XHRsZXQgdGV4dCA9IFwiXCI7XG5cdFx0XHRcdGNvbnN0IHZhdWx0OiBWYXVsdCA9IHRoaXMuYXBwLnZhdWx0O1xuXHRcdFx0XHRjb25zdCBsaXN0U2VsZWN0aW9uczogRWRpdG9yU2VsZWN0aW9uW10gPSBlZGl0b3IubGlzdFNlbGVjdGlvbnMoKTtcblx0XHRcdCAgXG5cdFx0XHRcdGNvbnN0IHByb2Nlc3NMaW5lID0gYXN5bmMgKGxpbmU6IHN0cmluZywgaTogbnVtYmVyKSA9PiB7XG5cdFx0XHRcdFx0Ly8gdG8gbW9kaWZ5IGxpbmUgYWRkIHRtICh0byBtb3ZlKSB0YWcgYW5kIGFkZCB0byBjb3JyZXNwb25kaW5nIGpvdXJuYWwgbm90ZVxuXHRcdFx0XHQgIGlmICgvXi0gXFxkXFxkXFxkXFxkLVxcZFxcZC1cXGRcXGQgXFxkXFxkOlxcZFxcZCAvLnRlc3QobGluZSkpIHtcblx0XHRcdFx0XHRjb25zdCBtb2RpZmllZExpbmUgPSBsaW5lLnJlcGxhY2UoL14tIC8sIGAtICN0bSBgKTtcblx0XHRcdFx0XHRlZGl0b3Iuc2V0TGluZShpLCBtb2RpZmllZExpbmUpO1xuXHRcdFx0XHRcdHRleHQgKz0gbGluZSArIFwiXFxuXCI7XG5cdFx0XHQgIFxuXHRcdFx0XHRcdGNvbnN0IGxpbmVUb0FkZCA9ICctJyArIGxpbmUucmVwbGFjZSgvLS9nLCAnJyk7XG5cdFx0XHRcdFx0Y29uc3QgcGF0aCA9IGxpbmUucmVwbGFjZSgvXi0gKFxcZFxcZFxcZFxcZCktKFxcZFxcZCktLiovLCBcIkovJDEtTSQyLm1kXCIpO1xuXHRcdFx0ICBcblx0XHRcdFx0XHRsZXQgdEZpbGUgPSB2YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgocGF0aCk7XG5cdFx0XHRcdFx0aWYgKHRGaWxlID09IG51bGwpIHtcblx0XHRcdFx0XHQgIHRGaWxlID0gYXdhaXQgdmF1bHQuY3JlYXRlKHBhdGgsIGxpbmVUb0FkZCk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQgIGNvbnN0IHRGaWxlT3JpZ2luYWxWYWx1ZSA9IGF3YWl0IHZhdWx0LnJlYWQodEZpbGUgYXMgVEZpbGUpO1xuXHRcdFx0XHRcdCAgYXdhaXQgdmF1bHQubW9kaWZ5KHRGaWxlIGFzIFRGaWxlLCB0RmlsZU9yaWdpbmFsVmFsdWUgKyBcIlxcblwiICsgbGluZVRvQWRkKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdCAgfVxuXHRcdFx0XHR9O1xuXHRcdFx0ICBcblx0XHRcdFx0Y29uc3QgcHJvY2Vzc1NlbGVjdGlvbnMgPSBhc3luYyAoKSA9PiB7XG5cdFx0XHRcdCAgZm9yIChjb25zdCBsaXN0U2VsZWN0aW9uIG9mIGxpc3RTZWxlY3Rpb25zKSB7XG5cdFx0XHRcdFx0Y29uc3QgYSA9IGxpc3RTZWxlY3Rpb24uaGVhZC5saW5lO1xuXHRcdFx0XHRcdGNvbnN0IGIgPSBsaXN0U2VsZWN0aW9uLmFuY2hvci5saW5lO1xuXHRcdFx0XHRcdGNvbnN0IGZyb21MaW5lTnVtID0gYiA+IGEgPyBhIDogYjtcblx0XHRcdFx0XHRjb25zdCB0b0xpbmVOdW0gPSBiID4gYSA/IGIgOiBhO1xuXHRcdFx0ICBcblx0XHRcdFx0XHRmb3IgKGxldCBpID0gZnJvbUxpbmVOdW07IGkgPD0gdG9MaW5lTnVtOyBpKyspIHtcblx0XHRcdFx0XHQgIGNvbnN0IGxpbmUgPSBlZGl0b3IuZ2V0TGluZShpKTtcblx0XHRcdFx0XHQgIGF3YWl0IHByb2Nlc3NMaW5lKGxpbmUsIGkpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0ICB9XG5cdFx0XHRcdH07XG5cdFx0XHQgIFxuXHRcdFx0XHRwcm9jZXNzU2VsZWN0aW9ucygpLnRoZW4oKCkgPT4ge1xuXHRcdFx0XHQgIGlmICh0ZXh0Lmxlbmd0aCAhPT0gMCkge1xuXHRcdFx0XHRcdHRleHQgPSBlbmNvZGVVUkkodGV4dCk7XG5cdFx0XHRcdFx0d2luZG93Lm9wZW4oYHNob3J0Y3V0czovL3J1bi1zaG9ydGN1dD9uYW1lPUFkZCUyME9ic2lkaWFuJTIwSW5ib3glMjBFdmVudCUyMHZpYSUyMEZhbnRhc3RpY2FsJmlucHV0PXRleHQmdGV4dD0ke3RleHR9Jngtc3VjY2Vzcz1vYnNpZGlhbjovLyZ4LWNhbmNlbD1vYnNpZGlhbjovLyZ4LWVycm9yPW9ic2lkaWFuOi8vYCk7XG5cdFx0XHRcdCAgfVxuXHRcdFx0XHR9KTtcblx0XHRcdCAgfSxcblx0XHRcdCAgXG5cdFx0XHRcblx0XHR9KTtcblxuXHRcdC8qXG5cdFx0dGhpcy5hZGRDb21tYW5kKHtcblx0XHRcdGlkOiBcInJlbW92ZS1maXJzdC10YWItZnJvbS1zZWxlY3RlZC1saW5lc1wiLFxuXHRcdFx0bmFtZTogXCJSZW1vdmUgZmlyc3QgdGFiIGZyb20gc2VsZWN0ZWQgbGluZXNcIixcblx0XHRcdGVkaXRvckNhbGxiYWNrOiAoZWRpdG9yOiBFZGl0b3IsIHZpZXc6IE1hcmtkb3duVmlldykgPT4ge1xuXHRcdFx0XHRjb25zdCBsaXN0U2VsZWN0aW9ucyA9IGVkaXRvci5saXN0U2VsZWN0aW9ucygpO1xuXHRcdFx0XHRsaXN0U2VsZWN0aW9ucy5mb3JFYWNoKGxpc3RTZWxlY3Rpb24gPT4ge1xuXHRcdFx0XHRcdGNvbnN0IGZyb21MaW5lTnVtID0gbGlzdFNlbGVjdGlvbi5oZWFkLmxpbmVcblx0XHRcdFx0XHRjb25zdCB0b0xpbmVOdW0gPSBsaXN0U2VsZWN0aW9uLmFuY2hvci5saW5lXG5cdFx0XHRcdFx0Zm9yIChsZXQgaSA9IGZyb21MaW5lTnVtOyBpIDw9IHRvTGluZU51bTsgaSsrKSB7XG5cdFx0XHRcdFx0XHRjb25zdCBsaW5lID0gZWRpdG9yLmdldExpbmUoaSlcblx0XHRcdFx0XHRcdGNvbnN0IG1vZGlmaWVkTGluZSA9IGxpbmUucmVwbGFjZSgvXFx0LywgJycpXG5cdFx0XHRcdFx0XHRlZGl0b3Iuc2V0TGluZShpLCBtb2RpZmllZExpbmUpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSlcblx0XHRcdH0sXG5cdFx0fSk7XG5cdFx0Ki9cblxuXHRcdHRoaXMuYWRkQ29tbWFuZCh7XG5cdFx0XHRpZDogXCJncmVwLXRpdGxlLWFzLWxpbmstdG8tY2xpcGJvYXJkXCIsXG5cdFx0XHRuYW1lOiBcIkdyZXAgVGl0bGUgYXMgbGluayB0byBjbGlwYm9hcmRcIixcblx0XHRcdGljb246IGBjbGlwYm9hcmQtbGlzdGAsXG5cdFx0XHRlZGl0b3JDYWxsYmFjazogYXN5bmMgKGVkaXRvcjogRWRpdG9yLCB2aWV3OiBNYXJrZG93blZpZXcpID0+IHtcblx0XHRcdFx0Y29uc3QgdGl0bGUgPSB2aWV3LmZpbGUuYmFzZW5hbWU7XG5cdFx0XHRcdGNvbnN0IHRpdGxlQXNMaW5rID0gYFtbJHt0aXRsZX1dXWA7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0dGhpcy5hZGRUb0NsaXBib2FyZEhpc3RvcnkodGl0bGVBc0xpbmspO1xuXHRcdFx0XHRcdGF3YWl0IG5hdmlnYXRvci5jbGlwYm9hcmQud3JpdGVUZXh0KHRpdGxlQXNMaW5rKTtcblx0XHRcdFx0XHRuZXcgTm90aWNlKGBDb3BpZWQgdGl0bGUgXCIke3RpdGxlfVwiIGFzIGxpbmsgdG8gY2xpcGJvYXJkIWApO1xuXHRcdFx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0XHRcdG5ldyBOb3RpY2UoYEVycm9yIG9jY3VycmVkIHdoZW4gY29weWluZyB0byBjbGlwYm9hcmQ6ICR7ZXJyb3J9YCk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRob3RrZXlzOiBbXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRtb2RpZmllcnM6IFtgTWV0YWAsIGBTaGlmdGBdLFxuXHRcdFx0XHRcdGtleTogYGxgLFxuXHRcdFx0XHR9LFxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bW9kaWZpZXJzOiBbYEN0cmxgLCBgU2hpZnRgXSxcblx0XHRcdFx0XHRrZXk6IGBsYCxcblx0XHRcdFx0fVxuXHRcdFx0XVxuXHRcdH0pO1xuXG5cdFx0dGhpcy5hZGRPYnNpZGlhbkljb24oJ21vdmUtY3VycmVudC1zZWxlY3Rpb24tdG8tYmVnaW5uaW5nLW9mLW5vdGVzJywgJzw8Jyk7XG5cdFx0dGhpcy5hZGRDb21tYW5kKHtcblx0XHRcdGlkOiBcIm1vdmUtY3VycmVudC1zZWxlY3Rpb24tdG8tYmVnaW5uaW5nLW9mLW5vdGVzXCIsXG5cdFx0XHRuYW1lOiBcIk1CIDw8IE1vdmUgY3VycmVudCBzZWxlY3Rpb24gdG8gYmVnaW5uaW5nIG9mIG5vdGVzXCIsXG5cdFx0XHRpY29uOiBgbW92ZS1jdXJyZW50LXNlbGVjdGlvbi10by1iZWdpbm5pbmctb2Ytbm90ZXNgLFxuXHRcdFx0ZWRpdG9yQ2FsbGJhY2s6IChlZGl0b3I6IEVkaXRvciwgdmlldzogTWFya2Rvd25WaWV3KSA9PiB7XG5cdFx0XHRcdGxldCBzZWxlY3Rpb24gPSBleHBvcnRDdXJyZW50U2VsZWN0aW9uKGVkaXRvcilcblx0XHRcdFx0aWYgKC9eICAgICstIC9tLnRlc3Qoc2VsZWN0aW9uKVxuXHRcdFx0XHQgIHx8IC9eLSAvbS50ZXN0KHNlbGVjdGlvbilcblx0XHRcdFx0ICB8fCAvXiMgL20udGVzdChzZWxlY3Rpb24pXG5cdFx0XHRcdCAgfHwgL15gIC9tLnRlc3Qoc2VsZWN0aW9uKVxuXHRcdFx0XHQgIHx8IC9ePiAvbS50ZXN0KHNlbGVjdGlvbilcblx0XHRcdFx0ICB8fCAvXlxcZCtcXC4gL20udGVzdChzZWxlY3Rpb24pXG5cdFx0XHRcdCAgKVxuXHRcdFx0XHR7XG5cdFx0XHRcdC8vIGRvIG5vdGhpbmdcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRzZWxlY3Rpb24gPSBcIi0gXCIgKyBzZWxlY3Rpb25cblx0XHRcdFx0fVxuXHRcdFx0XHRsZXQgbmV3Q29udGVudCA9ICcnXG5cdFx0XHRcdGNvbnN0IHNlbGVjdGlvblJhbmdlOiBTZWxlY3Rpb25SYW5nZSA9IGdldEN1cnJlbnRTZWxlY3Rpb25MaW5lTnVtYmVyKGVkaXRvcilcblx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBlZGl0b3IubGluZUNvdW50KCk7IGkrKykge1xuXHRcdFx0XHRcdGlmIChpIDwgc2VsZWN0aW9uUmFuZ2UuZnJvbUxpbmVOdW0gfHwgaSA+IHNlbGVjdGlvblJhbmdlLnRvTGluZU51bSkge1xuXHRcdFx0XHRcdFx0bmV3Q29udGVudCA9IG5ld0NvbnRlbnQgKyBlZGl0b3IuZ2V0TGluZShpKSArIFwiXFxuXCJcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHRcdG5ldyBBZGRUZXh0VG9Ob3Rlc01vZGFsKHRoaXMuYXBwLCBzZWxlY3Rpb24sIFwibW92ZSB0aGUgc2VsZWN0ZWQgdGV4dFwiLCB0cnVlLCAoKSA9PiBlZGl0b3Iuc2V0VmFsdWUobmV3Q29udGVudC5yZXBsYWNlKC9cXG4kL20sIFwiXCIpKSkub3BlbigpXG5cdFx0XHR9LFxuXHRcdFx0aG90a2V5czogW1xuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bW9kaWZpZXJzOiBbYEN0cmxgLCBgTWV0YWAsIGBTaGlmdGBdLFxuXHRcdFx0XHRcdGtleTogYCxgLFxuXHRcdFx0XHR9LFxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bW9kaWZpZXJzOiBbYEN0cmxgLCBgQWx0YCwgYFNoaWZ0YF0sXG5cdFx0XHRcdFx0a2V5OiBgLGAsXG5cdFx0XHRcdH0sXG5cdFx0XHRdXG5cdFx0fSlcblxuXHRcdHRoaXMuYWRkT2JzaWRpYW5JY29uKCdtb3ZlLWN1cnJlbnQtc2VsZWN0aW9uLXRvLWVuZC1vZi1ub3RlcycsICc+PicpO1xuXHRcdHRoaXMuYWRkQ29tbWFuZCh7XG5cdFx0XHRpZDogXCJtb3ZlLWN1cnJlbnQtc2VsZWN0aW9uLXRvLWVuZC1vZi1ub3Rlc1wiLFxuXHRcdFx0bmFtZTogXCJNRSA+PiBNb3ZlIGN1cnJlbnQgc2VsZWN0aW9uIHRvIGJlZ2lubmluZyBvZiBub3Rlc1wiLFxuXHRcdFx0aWNvbjogYG1vdmUtY3VycmVudC1zZWxlY3Rpb24tdG8tZW5kLW9mLW5vdGVzYCxcblx0XHRcdGVkaXRvckNhbGxiYWNrOiAoZWRpdG9yOiBFZGl0b3IsIHZpZXc6IE1hcmtkb3duVmlldykgPT4ge1xuXHRcdFx0XHRsZXQgc2VsZWN0aW9uID0gZXhwb3J0Q3VycmVudFNlbGVjdGlvbihlZGl0b3IpXG5cdFx0XHRcdGlmICgvXiAgICArLSAvbS50ZXN0KHNlbGVjdGlvbilcblx0XHRcdFx0ICB8fCAvXi0gL20udGVzdChzZWxlY3Rpb24pXG5cdFx0XHRcdCAgfHwgL14jIC9tLnRlc3Qoc2VsZWN0aW9uKVxuXHRcdFx0XHQgIHx8IC9eYCAvbS50ZXN0KHNlbGVjdGlvbilcblx0XHRcdFx0ICB8fCAvXj4gL20udGVzdChzZWxlY3Rpb24pXG5cdFx0XHRcdCAgfHwgL15cXGQrXFwuIC9tLnRlc3Qoc2VsZWN0aW9uKVxuXHRcdFx0XHQgIClcblx0XHRcdFx0e1xuXHRcdFx0XHQvLyBkbyBub3RoaW5nXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0c2VsZWN0aW9uID0gXCItIFwiICsgc2VsZWN0aW9uXG5cdFx0XHRcdH1cblx0XHRcdFx0bGV0IG5ld0NvbnRlbnQgPSAnJ1xuXHRcdFx0XHRjb25zdCBzZWxlY3Rpb25SYW5nZTogU2VsZWN0aW9uUmFuZ2UgPSBnZXRDdXJyZW50U2VsZWN0aW9uTGluZU51bWJlcihlZGl0b3IpXG5cdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgZWRpdG9yLmxpbmVDb3VudCgpOyBpKyspIHtcblx0XHRcdFx0XHRpZiAoaSA8IHNlbGVjdGlvblJhbmdlLmZyb21MaW5lTnVtIHx8IGkgPiBzZWxlY3Rpb25SYW5nZS50b0xpbmVOdW0pIHtcblx0XHRcdFx0XHRcdG5ld0NvbnRlbnQgPSBuZXdDb250ZW50ICsgZWRpdG9yLmdldExpbmUoaSkgKyBcIlxcblwiXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0XHRuZXcgQWRkVGV4dFRvTm90ZXNNb2RhbCh0aGlzLmFwcCwgc2VsZWN0aW9uLCBcIm1vdmUgdGhlIHNlbGVjdGVkIHRleHRcIiwgZmFsc2UsICgpID0+IGVkaXRvci5zZXRWYWx1ZShuZXdDb250ZW50LnJlcGxhY2UoL1xcbiQvbSwgXCJcIikpKS5vcGVuKClcblx0XHRcdH0sXG5cdFx0XHRob3RrZXlzOiBbXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRtb2RpZmllcnM6IFtgQ3RybGAsIGBNZXRhYCwgYFNoaWZ0YF0sXG5cdFx0XHRcdFx0a2V5OiBgLmAsXG5cdFx0XHRcdH0sXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRtb2RpZmllcnM6IFtgQ3RybGAsIGBBbHRgLCBgU2hpZnRgXSxcblx0XHRcdFx0XHRrZXk6IGAuYCxcblx0XHRcdFx0fSxcblx0XHRcdF1cblx0XHR9KVxuXG5cdFx0dGhpcy5hZGRPYnNpZGlhbkljb24oJ2FkZC1jdXJyZW50LXNlbGVjdGlvbi10by1iZWdpbm5pbmctb2Ytbm90ZXMnLCAnKCgnKTtcblx0XHR0aGlzLmFkZENvbW1hbmQoe1xuXHRcdFx0aWQ6IFwiYWRkLWN1cnJlbnQtc2VsZWN0aW9uLXRvLWJlZ2lubmluZy1vZi1ub3Rlc1wiLFxuXHRcdFx0bmFtZTogXCJTQiAoKCBBZGQgY3VycmVudCBzZWxlY3Rpb24gdG8gYmVnaW5uaW5nIG9mIG5vdGVzXCIsXG5cdFx0XHRpY29uOiBgYWRkLWN1cnJlbnQtc2VsZWN0aW9uLXRvLWJlZ2lubmluZy1vZi1ub3Rlc2AsXG5cdFx0XHRlZGl0b3JDYWxsYmFjazogKGVkaXRvcjogRWRpdG9yLCB2aWV3OiBNYXJrZG93blZpZXcpID0+IHtcblx0XHRcdFx0bGV0IHNlbGVjdGlvbiA9IGV4cG9ydEN1cnJlbnRTZWxlY3Rpb24oZWRpdG9yKVxuXHRcdFx0XHRpZiAoL14gICAgKy0gL20udGVzdChzZWxlY3Rpb24pXG5cdFx0XHRcdCAgfHwgL14tIC9tLnRlc3Qoc2VsZWN0aW9uKVxuXHRcdFx0XHQgIHx8IC9eIyAvbS50ZXN0KHNlbGVjdGlvbilcblx0XHRcdFx0ICB8fCAvXmAgL20udGVzdChzZWxlY3Rpb24pXG5cdFx0XHRcdCAgfHwgL14+IC9tLnRlc3Qoc2VsZWN0aW9uKVxuXHRcdFx0XHQgIHx8IC9eXFxkK1xcLiAvbS50ZXN0KHNlbGVjdGlvbilcblx0XHRcdFx0ICApIHtcblx0XHRcdFx0XHQvLyBkbyBub3RoaW5nXG5cdFx0XHRcdCAgfSBlbHNlIHtcblx0XHRcdFx0XHRzZWxlY3Rpb24gPSBcIi0gXCIgKyBzZWxlY3Rpb25cblx0XHRcdFx0ICB9XG5cdFx0XHRcdG5ldyBBZGRUZXh0VG9Ob3Rlc01vZGFsKHRoaXMuYXBwLCBzZWxlY3Rpb24sIFwiYWRkIHRoZSBzZWxlY3RlZCB0ZXh0XCIsIHRydWUsICgpID0+IHt9KS5vcGVuKClcblx0XHRcdH0sXG5cdFx0XHRob3RrZXlzOiBbXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRtb2RpZmllcnM6IFtgQ3RybGAsIGBNZXRhYCwgYFNoaWZ0YF0sXG5cdFx0XHRcdFx0a2V5OiBgOWAsXG5cdFx0XHRcdH0sXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRtb2RpZmllcnM6IFtgQ3RybGAsIGBBbHRgLCBgU2hpZnRgXSxcblx0XHRcdFx0XHRrZXk6IGA5YCxcblx0XHRcdFx0fSxcblx0XHRcdF1cblx0XHR9KVxuXG5cdFx0dGhpcy5hZGRPYnNpZGlhbkljb24oJ2FkZC1jdXJyZW50LXNlbGVjdGlvbi10by1lbmQtb2Ytbm90ZXMnLCAnKSknKTtcblx0XHR0aGlzLmFkZENvbW1hbmQoe1xuXHRcdFx0aWQ6IFwiYWRkLWN1cnJlbnQtc2VsZWN0aW9uLXRvLWVuZC1vZi1ub3Rlc1wiLFxuXHRcdFx0bmFtZTogXCJTRSApKSBBZGQgY3VycmVudCBzZWxlY3Rpb24gdG8gZW5kIG9mIG5vdGVzXCIsXG5cdFx0XHRpY29uOiBgYWRkLWN1cnJlbnQtc2VsZWN0aW9uLXRvLWVuZC1vZi1ub3Rlc2AsXG5cdFx0XHRlZGl0b3JDYWxsYmFjazogKGVkaXRvcjogRWRpdG9yLCB2aWV3OiBNYXJrZG93blZpZXcpID0+IHtcblx0XHRcdFx0bGV0IHNlbGVjdGlvbiA9IGV4cG9ydEN1cnJlbnRTZWxlY3Rpb24oZWRpdG9yKVxuXHRcdFx0XHRpZiAoL14gICAgKy0gL20udGVzdChzZWxlY3Rpb24pXG5cdFx0XHRcdCAgfHwgL14tIC9tLnRlc3Qoc2VsZWN0aW9uKVxuXHRcdFx0XHQgIHx8IC9eIyAvbS50ZXN0KHNlbGVjdGlvbilcblx0XHRcdFx0ICB8fCAvXmAgL20udGVzdChzZWxlY3Rpb24pXG5cdFx0XHRcdCAgfHwgL14+IC9tLnRlc3Qoc2VsZWN0aW9uKVxuXHRcdFx0XHQgIHx8IC9eXFxkK1xcLiAvbS50ZXN0KHNlbGVjdGlvbilcblx0XHRcdFx0ICApIHtcblx0XHRcdFx0XHQvLyBkbyBub3RoaW5nXG5cdFx0XHRcdCAgfSBlbHNlIHtcblx0XHRcdFx0XHRzZWxlY3Rpb24gPSBcIi0gXCIgKyBzZWxlY3Rpb25cblx0XHRcdFx0ICB9XG5cdFx0XHRcdG5ldyBBZGRUZXh0VG9Ob3Rlc01vZGFsKHRoaXMuYXBwLCBzZWxlY3Rpb24sIFwiYWRkIHRoZSBzZWxlY3RlZCB0ZXh0XCIsIGZhbHNlLCAoKSA9PiB7fSkub3BlbigpXG5cdFx0XHR9LFxuXHRcdFx0aG90a2V5czogW1xuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bW9kaWZpZXJzOiBbYEN0cmxgLCBgTWV0YWAsIGBTaGlmdGBdLFxuXHRcdFx0XHRcdGtleTogYDBgLFxuXHRcdFx0XHR9LFxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bW9kaWZpZXJzOiBbYEN0cmxgLCBgQWx0YCwgYFNoaWZ0YF0sXG5cdFx0XHRcdFx0a2V5OiBgMGAsXG5cdFx0XHRcdH0sXG5cdFx0XHRdXG5cdFx0fSlcblxuXHRcdHRoaXMuYWRkT2JzaWRpYW5JY29uKCdhZGQtY3VycmVudC1saW5rLXRvLWJlZ2lubmluZy1vZi1ub3RlcycsICdbWycpO1xuXHRcdHRoaXMuYWRkQ29tbWFuZCh7XG5cdFx0XHRpZDogXCJhZGQtY3VycmVudC1saW5rLXRvLWJlZ2lubmluZy1vZi1ub3Rlc1wiLFxuXHRcdFx0bmFtZTogXCJMQiBbWyBBZGQgY3VycmVudCBsaW5rIHRvIGJlZ2lubmluZyBvZiBub3Rlc1wiLFxuXHRcdFx0aWNvbjogYGFkZC1jdXJyZW50LWxpbmstdG8tYmVnaW5uaW5nLW9mLW5vdGVzYCxcblx0XHRcdGVkaXRvckNhbGxiYWNrOiAoZWRpdG9yOiBFZGl0b3IsIHZpZXc6IE1hcmtkb3duVmlldykgPT4ge1xuXHRcdFx0XHRjb25zdCBsaW5rID0gXCItIFtbXCIgKyB2aWV3LmZpbGUuYmFzZW5hbWUgKyBcIl1dXCI7XG5cdFx0XHRcdG5ldyBBZGRUZXh0VG9Ob3Rlc01vZGFsKHRoaXMuYXBwLCBsaW5rLCBcImFkZCB0aGUgY3VycmVudCBub3RlIGxpbmtcIiwgdHJ1ZSwgKCkgPT4ge30pLm9wZW4oKVxuXHRcdFx0fSxcblx0XHRcdGhvdGtleXM6IFtcblx0XHRcdFx0e1xuXHRcdFx0XHRcdG1vZGlmaWVyczogW2BDdHJsYCwgYE1ldGFgLCBgU2hpZnRgXSxcblx0XHRcdFx0XHRrZXk6IGBbYCxcblx0XHRcdFx0fSxcblx0XHRcdFx0e1xuXHRcdFx0XHRcdG1vZGlmaWVyczogW2BDdHJsYCwgYEFsdGAsIGBTaGlmdGBdLFxuXHRcdFx0XHRcdGtleTogYFtgLFxuXHRcdFx0XHR9LFxuXHRcdFx0XVxuXHRcdH0pXG5cblx0XHR0aGlzLmFkZE9ic2lkaWFuSWNvbignYWRkLWN1cnJlbnQtbGluay10by1lbmQtb2Ytbm90ZXMnLCAnXV0nKTtcblx0XHR0aGlzLmFkZENvbW1hbmQoe1xuXHRcdFx0aWQ6IFwiYWRkLWN1cnJlbnQtbGluay10by1lbmQtb2Ytbm90ZXNcIixcblx0XHRcdG5hbWU6IFwiTEUgXV0gQWRkIGN1cnJlbnQgbGluayB0byBlbmQtb2Ytbm90ZXNcIixcblx0XHRcdGljb246IGBhZGQtY3VycmVudC1saW5rLXRvLWVuZC1vZi1ub3Rlc2AsXG5cdFx0XHRlZGl0b3JDYWxsYmFjazogKGVkaXRvcjogRWRpdG9yLCB2aWV3OiBNYXJrZG93blZpZXcpID0+IHtcblx0XHRcdFx0Y29uc3QgbGluayA9IFwiLSBbW1wiICsgdmlldy5maWxlLmJhc2VuYW1lICsgXCJdXVwiO1xuXHRcdFx0XHRuZXcgQWRkVGV4dFRvTm90ZXNNb2RhbCh0aGlzLmFwcCwgbGluaywgXCJhZGQgdGhlIGN1cnJlbnQgbm90ZSBsaW5rXCIsIGZhbHNlLCAoKSA9PiB7fSkub3BlbigpXG5cdFx0XHR9LFxuXHRcdFx0aG90a2V5czogW1xuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bW9kaWZpZXJzOiBbYEN0cmxgLCBgTWV0YWAsIGBTaGlmdGBdLFxuXHRcdFx0XHRcdGtleTogYF1gLFxuXHRcdFx0XHR9LFxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bW9kaWZpZXJzOiBbYEN0cmxgLCBgQWx0YCwgYFNoaWZ0YF0sXG5cdFx0XHRcdFx0a2V5OiBgXWAsXG5cdFx0XHRcdH0sXG5cdFx0XHRdXG5cdFx0fSlcblxuXHRcdHRoaXMuYWRkQ29tbWFuZCh7XG5cdFx0XHRpZDogXCJxdWljay1uYXZpZ2F0ZS10by1ub3Rlc1wiLFxuXHRcdFx0bmFtZTogXCJOTiBRdWljayBOYXZpZ2F0ZSB0byBOb3Rlc1wiLFxuXHRcdFx0aWNvbjogYGFwZXJ0dXJlYCxcblx0XHRcdGNhbGxiYWNrOiBhc3luYyAoKSA9PiB7XG5cdFx0XHRcdG5ldyBOYXZpZ2F0ZVRvTm90ZUZyb21UYWdNb2RhbCh0aGlzLmFwcCkub3BlbigpXG5cdFx0XHR9LFxuXHRcdFx0aG90a2V5czogW1xuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bW9kaWZpZXJzOiBbYEN0cmxgLCBgTWV0YWAsIGBTaGlmdGBdLFxuXHRcdFx0XHRcdGtleTogYDtgLFxuXHRcdFx0XHR9LFxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bW9kaWZpZXJzOiBbYEN0cmxgLCBgQWx0YCwgYFNoaWZ0YF0sXG5cdFx0XHRcdFx0a2V5OiBgO2AsXG5cdFx0XHRcdH0sXG5cdFx0XHRdXG5cdFx0fSlcblxuXHRcdHRoaXMuYWRkT2JzaWRpYW5JY29uKCd0aHJlYWRzLXRvLXR3aXR0ZXInLCAnVFgnKTtcblx0XHR0aGlzLmFkZENvbW1hbmQoe1xuXHRcdFx0aWQ6IFwidGhyZWFkcy10by10d2l0dGVyXCIsXG5cdFx0XHRuYW1lOiBcIlRUIFRYIFRocmVhZHMgdG8gVHdpdHRlclwiLFxuXHRcdFx0aWNvbjogYHRocmVhZHMtdG8tdHdpdHRlcmAsXG5cdFx0XHRlZGl0b3JDYWxsYmFjazogKGVkaXRvcjogRWRpdG9yLCB2aWV3OiBNYXJrZG93blZpZXcpID0+IHtcblx0XHRcdFx0Y29uc3QgeyB2YXVsdCB9ID0gdGhpcy5hcHA7XG5cdFx0XHRcdGNvbnN0IHYgPSBlZGl0b3IuZ2V0VmFsdWUoKVxuXHRcdFx0XHRjb25zdCBwYXRoID0gdmlldy5maWxlLnBhdGhcblx0XHRcdFx0aWYgKCFwYXRoLm1hdGNoKC8uXFwvVGhyZWFkcyBcXGRcXGRcXGRcXGRcXGRcXGRcXGRcXGQvKSkge1xuXHRcdFx0XHRcdG5ldyBOb3RpY2UoYFdpbGwgbm90IHByb2NlZWQuIEl0IGlzIG5vdCBhIHRocmVhZHMgcG9zdC5gKTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0Y29uc3QgbmV3UGF0aCA9IHBhdGgucmVwbGFjZSgvKC5cXC8pVGhyZWFkcyAvLCBcIiQxVHdpdHRlciBcIilcblxuXHRcdFx0XHRjb25zdCB7IHdvcmtzcGFjZSB9ID0gdGhpcy5hcHA7XG5cdFx0XHRcdGNvbnN0IGxlYWYgPSB3b3Jrc3BhY2UuZ2V0TGVhZihmYWxzZSk7XG5cdFx0XHRcdFByb21pc2UucmVzb2x2ZSgpXG5cdFx0XHRcdC50aGVuKCgpID0+IHtcblx0XHRcdFx0XHRyZXR1cm4gdmF1bHQuYWRhcHRlci5leGlzdHMobmV3UGF0aCk7XG5cdFx0XHRcdH0pXG5cdFx0XHRcdC50aGVuKChmaWxlRXhpc3RzKSA9PiB7XG5cdFx0XHRcdFx0aWYgKGZpbGVFeGlzdHMpIHtcblx0XHRcdFx0XHRcdG5ldyBOb3RpY2UoYFdpbGwgbm90IHByb2NlZWQuIFR3aXR0ZXIgcG9zdCBhbHJlYWR5IGV4aXN0LmApO1xuXHRcdFx0XHRcdFx0cmV0dXJuIFByb21pc2UucmVqZWN0KFwiVHdpdHRlciBwb3N0IGFscmVhZHkgZXhpc3RcIilcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHZhdWx0LmNyZWF0ZShuZXdQYXRoLCB2KTtcblx0XHRcdFx0fSlcblx0XHRcdFx0LnRoZW4oKHRGaWxlKSA9PiB7XG5cdFx0XHRcdFx0cmV0dXJuIGxlYWYub3BlbkZpbGUodEZpbGUsIHsgYWN0aXZlIDogdHJ1ZX0pO1xuXHRcdFx0XHR9LCByZWFzb24gPT4ge30pXG5cdFx0XHRcdC50aGVuKCgpID0+IHtcblx0XHRcdFx0XHRuZXcgTm90aWNlKGBDcmVhdGVkIGFuZCBvcGVuZWQgVHdpdHRlciBub3RlcyFgKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fSlcblxuXHRcdHRoaXMuYWRkT2JzaWRpYW5JY29uKCdibG9nLXRvLWNsaXBib2FyZC1pY29uJywgJ0JKJyk7XG5cdFx0dGhpcy5hZGRDb21tYW5kKHtcblx0XHRcdGlkOiBcImJsb2ctdG8tY2xpcGJvYXJkXCIsXG5cdFx0XHRuYW1lOiBcIkJKIEJsb2cgY29udGVudCB0byBjbGlwYm9hcmRcIixcblx0XHRcdGljb246IGBibG9nLXRvLWNsaXBib2FyZC1pY29uYCxcblx0XHRcdGVkaXRvckNhbGxiYWNrOiBhc3luYyAoZWRpdG9yOiBFZGl0b3IsIHZpZXc6IE1hcmtkb3duVmlldykgPT4ge1xuXHRcdFx0XHRjb25zdCB2ID0gZWRpdG9yLmdldFZhbHVlKCk7XG5cdFx0XHRcdGlmICh2LmluY2x1ZGVzKFwiI25uXCIpIHx8IHYuaW5jbHVkZXMoXCIjbmxcIikgfHwgdi5pbmNsdWRlcyhcIiNud1wiKSB8fCB2LmluY2x1ZGVzKFwiI3duXCIpIHx8IHYuaW5jbHVkZXMoXCIjd2xcIikgfHwgdi5pbmNsdWRlcyhcIiN3d1wiKSkge1xuXHRcdFx0XHRcdG5ldyBOb3RpY2UoYFdpbGwgbm90IHByb2NlZWQuIEFzIHRoZXJlIGFyZSB1bmZpbmlzaGVkIGFjdGlvbiB0YWcuYCk7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICghdi5pbmNsdWRlcyhcIjwhLS1tb3JlLS0+XCIpKSB7XG5cdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdGF3YWl0IG5hdmlnYXRvci5jbGlwYm9hcmQud3JpdGVUZXh0KFwiPCEtLW1vcmUtLT5cIik7XG5cdFx0XHRcdFx0XHRuZXcgTm90aWNlKGBSZXF1aXJlIFwiPCEtLW1vcmUtLT5cIiBhcyBleGNlcnB0IHNlcGFyYXRvciBiZWZvcmUgcG9zdGluZy5cXG5cIjwhLS1tb3JlLS0+XCIgYWxyZWFkeSBpbiBjbGlwYm9hcmRgKTtcblx0XHRcdFx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0XHRcdFx0bmV3IE5vdGljZShgUmVxdWlyZSBcIjwhLS1tb3JlLS0+XCIgYXMgZXhjZXJwdCBzZXBhcmF0b3IgYmVmb3JlIHBvc3RpbmcuXFxuXCI8IS0tbW9yZS0tPlwiIGNhbm5vdCBiZSBjb3BpZWQgdG8gY2xpcGJvYXJkYCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNvbnN0IHBhdGggPSB2aWV3LmZpbGUucGF0aDtcblx0XHRcdFx0bGV0IGxpbmUgPSBlZGl0b3IubGluZUNvdW50KCk7XG5cdFx0XHRcdGxldCB0ZXh0ID0gXCJcIjtcblx0XHRcdFx0bGV0IG51bUxpbmVGaXJzdENvbnRlbnQgPSAwO1xuXHRcdFx0XHRsZXQgZnJvbnRNYXR0ZXJMaW5lQ291bnQgPSAwO1xuXHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGxpbmU7IGkrKykge1xuXHRcdFx0XHRcdGlmIChmcm9udE1hdHRlckxpbmVDb3VudCA9PSAyKSB7XG5cdFx0XHRcdFx0XHRudW1MaW5lRmlyc3RDb250ZW50ID0gaTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoZWRpdG9yLmdldExpbmUoaSkgPT0gXCItLS1cIikge1xuXHRcdFx0XHRcdFx0ZnJvbnRNYXR0ZXJMaW5lQ291bnQrKztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lOyBpKyspIHtcblx0XHRcdFx0XHRpZiAoZWRpdG9yLmdldExpbmUobnVtTGluZUZpcnN0Q29udGVudCkudHJpbSgpID09IFwiXCIpIHtcblx0XHRcdFx0XHRcdG51bUxpbmVGaXJzdENvbnRlbnQrKztcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0QXJyYXkuZnJvbShBcnJheShsaW5lIC0gbnVtTGluZUZpcnN0Q29udGVudCkua2V5cygpKS5mb3JFYWNoKGkgPT4ge1xuXHRcdFx0XHRcdGNvbnN0IGxpbmUgPSBlZGl0b3IuZ2V0TGluZShpICsgbnVtTGluZUZpcnN0Q29udGVudCk7XG5cdFx0XHRcdFx0dGV4dCA9IHRleHQgKyBsaW5lICsgXCJcXG5cIjtcblx0XHRcdFx0fSk7XG5cdFx0XHRcdHRleHQgPSB0ZXh0LnJlcGxhY2UoL1xcbi0tLVxcblxcbiNuZCBnZW5lcmF0ZSBzdW1tYXJ5IGZvciBtZXRhIGRlc2NyaXB0aW9uIGJlbG93OlxcblteXFxuXSpcXG4oW15cXG5dKilcXG5bXlxcbl0qXFxuLS0tXFxuLywgXCJcXG48IS0tIE1ldGEgU3VtbWFyeSAtLT5cXG48IS0tXFxuJDFcXG4tLT5cXG5cIik7XG5cdFx0XHRcdHRleHQgPSB0ZXh0LnJlcGxhY2UoLyMjIFJlZmVyZW5jZXNcXDooW1xcbl0qLiopKiQvLCBcIlwiKTtcblxuXHRcdFx0XHRjb25zdCBhcHAgPSB0aGlzLmFwcDtcblx0XHRcdFx0Y29uc3QgYmVmb3JlVGFnQ0JSID0gXCJjL2IvclwiO1xuXHRcdFx0XHRjb25zdCBiZWZvcmVUYWdDQkQgPSBcImMvYi9kXCI7XG5cdFx0XHRcdGNvbnN0IGJlZm9yZVRhZ0NCSSA9IFwiYy9iL2lcIjtcblx0XHRcdFx0Y29uc3QgYWZ0ZXJUYWcgPSBcImMvYi9wXCI7XG5cblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRhd2FpdCBuYXZpZ2F0b3IuY2xpcGJvYXJkLndyaXRlVGV4dCh0ZXh0KTtcblx0XHRcdFx0XHRuZXcgTm90aWNlKGBDb3BpZWQgYmxvZyBjb250ZW50IHRvIGNsaXBib2FyZCFgKTtcblx0XHRcdFx0XHRjb25zdCBmb3VuZFRhZ0Zyb21DQlIgPSBhd2FpdCByZW5hbWVUYWcodmlldy5maWxlLCBiZWZvcmVUYWdDQlIsIGFmdGVyVGFnKTtcblx0XHRcdFx0XHRpZiAoZm91bmRUYWdGcm9tQ0JSKSB7XG5cdFx0XHRcdFx0XHRuZXcgTm90aWNlKGBVcGRhdGUgbm90ZXMgdHlwZSBmcm9tIHRhZz1cIiR7YmVmb3JlVGFnQ0JSfVwiIHRvIHRhZz1cIiR7YWZ0ZXJUYWd9IWApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjb25zdCBmb3VuZFRhZ0Zyb21DQkkgPSBhd2FpdCByZW5hbWVUYWcodmlldy5maWxlLCBiZWZvcmVUYWdDQkksIGFmdGVyVGFnKTtcblx0XHRcdFx0XHRpZiAoZm91bmRUYWdGcm9tQ0JJKSB7XG5cdFx0XHRcdFx0XHRuZXcgTm90aWNlKGBVcGRhdGUgbm90ZXMgdHlwZSBmcm9tIHRhZz1cIiR7Zm91bmRUYWdGcm9tQ0JJfVwiIHRvIHRhZz1cIiR7YWZ0ZXJUYWd9IWApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjb25zdCBmb3VuZFRhZ0Zyb21DQkQgPSBhd2FpdCByZW5hbWVUYWcodmlldy5maWxlLCBiZWZvcmVUYWdDQkQsIGFmdGVyVGFnKTtcblx0XHRcdFx0XHRpZiAoZm91bmRUYWdGcm9tQ0JEKSB7XG5cdFx0XHRcdFx0XHRuZXcgTm90aWNlKGBVcGRhdGUgbm90ZXMgdHlwZSBmcm9tIHRhZz1cIiR7YmVmb3JlVGFnQ0JEfVwiIHRvIHRhZz1cIiR7YWZ0ZXJUYWd9IWApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRhd2FpdCByZW5hbWVCbG9nVGl0bGUoYXBwLCBwYXRoLCB2aWV3KTtcblx0XHRcdFx0XHR3aW5kb3cub3Blbihgc2hvcnRjdXRzOi8vcnVuLXNob3J0Y3V0P25hbWU9SmVreWxsJTIwYmxvZyZ4LWNhbmNlbD1vYnNpZGlhbjovLyZ4LWVycm9yPW9ic2lkaWFuOi8vYCk7XG5cdFx0XHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRcdFx0bmV3IE5vdGljZShgRXJyb3Igb2NjdXJyZWQgZHVyaW5nIHRoZSBvcGVyYXRpb246ICR7ZXJyb3J9YCk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0fSk7XG5cblx0XHR0aGlzLmFkZE9ic2lkaWFuSWNvbignZ2VuZXJhdGUtY2hhdGdwdC1wcm9tcHQnLCAnR1AnKTtcblx0XHR0aGlzLmFkZENvbW1hbmQoe1xuXHRcdFx0aWQ6IFwiZ2VuZXJhdGUtY2hhdGdwdC1wcm9tcHRcIixcblx0XHRcdG5hbWU6IFwiR1AgR2VuZXJhdGUgQ2hhdEdQVCBQcm9tcHRcIixcblx0XHRcdGljb246IGBnZW5lcmF0ZS1jaGF0Z3B0LXByb21wdGAsXG5cdFx0XHRlZGl0b3JDYWxsYmFjazogYXN5bmMgKGVkaXRvcjogRWRpdG9yLCB2aWV3OiBNYXJrZG93blZpZXcpID0+IHtcblx0XHRcdFx0bGV0IGxpbmUgPSBlZGl0b3IubGluZUNvdW50KCk7XG5cblx0XHRcdFx0bGV0IHRleHQgPSBcIlx1MzAxMFwiICsgdmlldy5maWxlLmJhc2VuYW1lICsgXCJcdTMwMTFcXG5cXG5cIjtcblx0XHRcdFx0bGV0IG51bUxpbmVGaXJzdENvbnRlbnQgPSAwXG5cdFx0XHRcdGxldCBmcm9udE1hdHRlckxpbmVDb3VudCA9IDBcblx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lOyBpKyspIHtcblx0XHRcdFx0XHRpZiAoZnJvbnRNYXR0ZXJMaW5lQ291bnQgPT0gMikge1xuXHRcdFx0XHRcdFx0bnVtTGluZUZpcnN0Q29udGVudCA9IGk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKGVkaXRvci5nZXRMaW5lKGkpID09IFwiLS0tXCIpIHtcblx0XHRcdFx0XHRcdGZyb250TWF0dGVyTGluZUNvdW50Kytcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lOyBpKyspIHtcblx0XHRcdFx0XHRpZiAoZWRpdG9yLmdldExpbmUobnVtTGluZUZpcnN0Q29udGVudCkudHJpbSgpID09IFwiXCIpIHtcblx0XHRcdFx0XHRcdG51bUxpbmVGaXJzdENvbnRlbnQrKztcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0QXJyYXkuZnJvbShBcnJheShsaW5lIC0gbnVtTGluZUZpcnN0Q29udGVudCkua2V5cygpKS5mb3JFYWNoKGkgPT4ge1xuXHRcdFx0XHRcdGNvbnN0IGxpbmUgPSBlZGl0b3IuZ2V0TGluZShpICsgbnVtTGluZUZpcnN0Q29udGVudCk7XG5cdFx0XHRcdFx0aWYgKCFsaW5lLnN0YXJ0c1dpdGgoXCIlJVwiKSAmJiAhbGluZS5lbmRzV2l0aChcIiUlXCIpKSB7XG5cdFx0XHRcdFx0XHR0ZXh0ID0gdGV4dCArIGxpbmUgKyBcIlxcblwiXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdFx0XG5cdFx0XHRcdHRleHQgPSB0ZXh0LnJlcGxhY2UoLyMjIFJlZmVyZW5jZXNcXDooW1xcbl0qLiopKiQvLCBcIlwiKVxuXHRcdFx0XHRcblx0XHRcdFx0bmF2aWdhdG9yLmNsaXBib2FyZC53cml0ZVRleHQodGV4dCkudGhlbihmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0bmV3IE5vdGljZShgQ29waWVkIGNvbnRlbnQgdG8gY2xpcGJvYXJkIGZvciBnZW5lcmF0aW5nIHByb21wdCFgKTtcblx0XHRcdFx0XHR3aW5kb3cub3Blbihgc2hvcnRjdXRzOi8vcnVuLXNob3J0Y3V0P25hbWU9R2VuZXJhdGUlMjBDaGF0R1BUJTIwUHJvbXB0Jngtc3VjY2Vzcz1vYnNpZGlhbjovLyZ4LWNhbmNlbD1vYnNpZGlhbjovLyZ4LWVycm9yPW9ic2lkaWFuOi8vYCk7XG5cdFx0XHRcdH0sIGZ1bmN0aW9uIChlcnJvcikge1xuXHRcdFx0XHRcdG5ldyBOb3RpY2UoYGVycm9yIHdoZW4gY29weSB0byBjbGlwYm9hcmQhYCk7ICAgXG5cdFx0XHRcdH0pOyAgIFxuXHRcdFx0fSwgICBcblx0XHR9KTsgICBcbiAgIFxuXHRcdHRoaXMuYWRkT2JzaWRpYW5JY29uKCd0aHJlYWRzLXRvLWNsaXBib2FyZC1pY29uJywgJ1RDJyk7ICAgXG5cdFx0dGhpcy5hZGRDb21tYW5kKHsgICBcblx0XHRcdGlkOiBcInRocmVhZHMtdG8tY2xpcGJvYXJkXCIsICAgXG5cdFx0XHRuYW1lOiBcIlRDIFRocmVhZHMgY29udGVudCB0byBjbGlwYm9hcmRcIiwgICBcblx0XHRcdGljb246IGB0aHJlYWRzLXRvLWNsaXBib2FyZC1pY29uYCxcblx0XHRcdGVkaXRvckNhbGxiYWNrOiAoZWRpdG9yOiBFZGl0b3IsIHZpZXc6IE1hcmtkb3duVmlldykgPT4geyAgIFxuXHRcdFx0XHRjb25zdCB2YWx1ZSA9IGVkaXRvci5nZXRWYWx1ZSgpXG5cdFx0XHRcdC8vaWYgKCF2YWx1ZS5jb250YWlucyhcIiUlICN0bSB0byB6ayAlJVwiKSAmJiAhdmFsdWUuY29udGFpbnMoXCIlJSAjbmQgdG8gemsgJSVcIikpIHtcblx0XHRcdFx0Ly9cdHRoaXMuYWRkVGFza1RvUHV0SW50b0NhcmRJblRocmVhZHNDb250ZW50KGVkaXRvcilcblx0XHRcdFx0Ly99XG5cdFx0XHRcdC8vIGNvbnN0IHRleHQgPSB0aGlzLmNvbnZlcnRUaHJlYWRzQ29udGVudFRvRm9ybWF0Rm9yVGhyZWFkc0FwcChlZGl0b3IpXG5cdFx0XHRcdGNvbnN0IHRleHQgPSB0aGlzLmdldFRocmVhZHNTZWdtZW50KGVkaXRvcilcblx0XHRcdFx0Y29uc3QgYmVmb3JlVGFnID0gXCJjL3QvclwiXG5cdFx0XHRcdGNvbnN0IGFmdGVyVGFnID0gXCJjL3QvdFwiXG5cdFx0XHRcblx0XHRcdFx0bmF2aWdhdG9yLmNsaXBib2FyZC53cml0ZVRleHQodGV4dClcblx0XHRcdFx0LnRoZW4oZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdHJldHVybiByZW5hbWVUYWcodmlldy5maWxlLCBiZWZvcmVUYWcsIGFmdGVyVGFnKVxuXHRcdFx0XHR9LCBmdW5jdGlvbiAoZXJyb3IpIHtcblx0XHRcdFx0XHRuZXcgTm90aWNlKGBlcnJvciB3aGVuIGNvcHkgdG8gY2xpcGJvYXJkIWApO1xuXHRcdFx0XHR9KVxuXHRcdFx0XHQudGhlbigoZm91bmRUYWcpID0+IHtcblx0XHRcdFx0XHRpZiAoZm91bmRUYWcpIHtcblx0XHRcdFx0XHRcdG5ldyBOb3RpY2UoYFVwZGF0ZSBub3RlcyB0eXBlIGZyb20gdGFnPVwiJHtiZWZvcmVUYWd9XCIgdG8gdGFnPVwiJHthZnRlclRhZ30hXFxuQ29waWVkIHRocmVhZCBjb250ZW50IHRvIGNsaXBib2FyZCFgKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0bmV3IE5vdGljZShgVGFnIFwiJHtiZWZvcmVUYWd9XCIgbm90IGZvdW5kXFxuQ29waWVkIHRocmVhZCBjb250ZW50IHRvIGNsaXBib2FyZCFgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSxcblx0XHR9KTtcblxuXHRcdHRoaXMuYWRkT2JzaWRpYW5JY29uKCd0d2l0dGVyLXRvLWNoYXRncHQnLCAnWEcnKTtcblx0XHR0aGlzLmFkZENvbW1hbmQoe1xuXHRcdFx0aWQ6IFwidHdpdHRlci10by1jaGF0Z3B0XCIsXG5cdFx0XHRuYW1lOiBcIlhHIFR3aXR0ZXIgdG8gQ2hhdEdQVFwiLFxuXHRcdFx0aWNvbjogYHR3aXR0ZXItdG8tY2hhdGdwdGAsXG5cdFx0XHRlZGl0b3JDYWxsYmFjazogKGVkaXRvcjogRWRpdG9yLCB2aWV3OiBNYXJrZG93blZpZXcpID0+IHtcblx0XHRcdFx0Y29uc3QgdmFsdWUgPSBlZGl0b3IuZ2V0VmFsdWUoKVxuXG5cdFx0XHRcdGlmICghdmlldy5maWxlLmJhc2VuYW1lLmNvbnRhaW5zKFwiVHdpdHRlclwiKSkge1xuXHRcdFx0XHRcdG5ldyBOb3RpY2UoXCJOb3RlIG5hbWUgbm90IGNvbnRhaW5zICdUd2l0dGVyJywgZGlkIG5vdCBjb3B5IGZyb20gdGhyZWFkIG5vdGU/XCIpXG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0XHRsZXQgY29udGVudCA9IHRoaXMuY29udmVydFRocmVhZHNDb250ZW50VG9QT0UoZWRpdG9yKVxuXHRcdFx0XHRsZXQgbnVtVHdlZXQgPSBNYXRoLmNlaWwoY29udGVudC5sZW5ndGggLyAxMTApXG5cdFx0XHRcdGxldCBwcm9tcHQgPSBgXHU2MEE4XHU2NjJGXHU3OTNFXHU0RUE0XHU1QTkyXHU5QUQ0XHU1MTY3XHU1QkI5XHU2NEIwXHU1QkVCXHU1RTJCXHUzMDAyXHU1QzA3XHU0RTBCXHU1MjE3XHU1MTY3XHU1QkI5XHU4RjQ5XHU3MEJBXHU0RTBEXHU4RDg1XHU5MDRFJHtudW1Ud2VldH1cdTY4OURcdTc2ODRcdTYzQThcdTcyNzlcdTRFMzJcdUZGMENcdTRFRTVcdTdFNDFcdTlBRDRcdTRFMkRcdTY1ODdcdTU0NDhcdTczRkVcdTMwMDJcdTRGRERcdTc1NTlcdTZBMTlcdTk4NENcdUZGMENcdTRFMjZcdTVDMDdcdTZBMTlcdTk4NENcdTU0MDhcdTRGNzVcdTUyMzBcdTdCMkNcdTRFMDBcdTY4OURcdTYzQThcdTY1ODdcdTRFMkRcdUZGMENcdTZBMTlcdTk4NENcdTU0OENcdTdCMkNcdTRFMDBcdTY4OURcdTYzQThcdTY1ODdcdTRFNEJcdTk1OTNcdTUyQTBcdTUxNjlcdTUwMEJcdTYzREJcdTg4NENcdTMwMDJcdTZCQ0ZcdTY4OURcdTYzQThcdTY1ODdcdTg5ODFcdThEODVcdTkwNEUxMDBcdTVCNTdcdTRGNDZcdTRFMERcdThEODVcdTkwNEUxNDBcdTVCNTdcdTMwMDJcdTUxNjdcdTVCQjlcdTRFMERcdTdDMjFcdTUzMTZcdUZGMENcdTRFMERcdTY1QjBcdTU4OUVcdTY3MkFcdTYzRDBcdTUzQ0FcdThDQzdcdThBMEFcdTMwMDJcdTRGRERcdTc1NTlcdTUzOUZcdTY1ODdcdTRGOEJcdTVCNTBcdUZGMENcdTRFMERcdTUyQTBcdTZBMTlcdTdDNjRcdTMwMDJcdTYzQThcdTY1ODdcdTRFMkRcdTRFMERcdTUyQTBcdTY1NzhcdTVCNTdcdTMwMDJcdTZCQ0ZcdTY4OURcdTYzQThcdTY1ODdcdTVGOENcdTUyQTBcdTUxNjlcdTUwMEJcdTYzREJcdTg4NENcdTUzQ0FcdTRFMDlcdTUwMEJcdTc3RURcdTUyODNcdTdEREFcdTU0OENcdTUzRTZcdTRFMDBcdTUwMEJcdTYzREJcdTg4NENcdTMwMDJcdTgyRjFcdTY1ODdcdTU0OENcdTRFMkRcdTY1ODdcdTRFNEJcdTk1OTNcdTUyQTBcdTdBN0FcdTY4M0NcdTMwMDJcdTgyRTVcdTUzOUZcdTY1ODdcdTY3MDlcdTdEQjJcdTU3NDBcdUZGMENcdTRGRERcdTc1NTlcdTdEQjJcdTU3NDBcdUZGMENcdTRFMERcdTc1MjhNYXJrZG93blx1NjgzQ1x1NUYwRlx1RkYwQ1x1NEUyNlx1NTcyOFx1N0RCMlx1NTc0MFx1NTI0RFx1NTJBMFx1NTE2OVx1NTAwQlx1NjNEQlx1ODg0Q1x1MzAwMmBcblxuXHRcdFx0XHQvL2xldCBwcm9tcHQgPSBgWW91IGFyZSBhIHNvY2lhbCBtZWRpYSBjb250ZW50IGNvcHl3cml0ZXIuIENvbnZlcnQgdGhlIGZvbGxvd2luZyBjb250ZW50IHRvIHR3aXR0ZXIgdGhyZWFkcyBsZXNzIHRoYW4gJHtudW1Ud2VldH0gdHdlZXQgaW4gdHJhZGl0aW9uYWwgQ2hpbmVzZS4gUHJlc2VydmUgdGhlIHRpdGxlLiBNZXJnZSB0aXRsZSB3aXRoIHRoZSBmaXJzdCB0d2VldCB3aGlsZSBhZGQgMiBuZXdsaW5lIGNoYXJhY3RlcnMgYmV0d2VlbiB0aXRsZSBhbmQgZmlyc3QgdHdlZXQuIEV2ZXJ5IHR3ZWV0IGhhcyB0byBvdmVyIDEwMCBidXQgbGVzcyB0aGFuIDE0MCBDaGluZXNlIGNoYXJhY3RlcnMuIERvIG5vdCBzaW1wbGlmeSB0aGUgY29udGVudC4gRG8gbm90IGFkZCBhbnkgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiB3aGljaCBpcyBub3QgbWVudGlvbmVkIGZyb20gdGhlIG9yaWdpbmFsIGNvbnRlbnQuIFByZXNlcnZlIHRoZSBleGFtcGxlIGZyb20gdGhlIGNvbnRlbnQuIE5vIG5lZWQgdG8gYWRkIGFueSB0YWdzIHRvIHRoZSB0d2VldC4gRG8gbm90IGhhdmUgYW55IG51bWJlciBpbiBlYWNoIHR3ZWV0LiBFYWNoIHR3ZWV0IHNlcGFyYXRlZCBieSAyIG5ld2xpbmUgYW5kIDMgXCItXCIgY2hhcmFjdGVycyBhbmQgYW5vdGhlciBuZXdsaW5lLiBBZGQgYSBzcGFjZSBjaGFyYWN0ZXIgYmV0d2VlbiBlYWNoIEVuZ2xpc2ggY2hhcmFjdGVyIGFuZCBDaGluZXNlIGNoYXJhY3Rlci4gSWYgdGhlIG9yaWdpbmFsIGNvbnRlbnQgY29udGFpbnMgYW55IFVSTCwgcHJlc2VydmUgdGhlIFVSTCBpbiB0aGUgdHdlZXQgd2l0aG91dCB1c2luZyBhbnkgTWFya2Rvd24gZm9ybWF0IGZvciB0aGUgVVJMIHdoaWxlIGFkZCAyIG5ld2xpbmUgY2hhcmFjdGVyIGJlZm9yZSB0aGUgVVJMLmBcblxuXHRcdFx0XHQvL2xldCBwcm9tcHQgPSBgQ29udmVydCB0aGUgZm9sbG93aW5nIGNvbnRlbnQgdG8gdHdpdHRlciB0aHJlYWRzIGxlc3MgdGhhbiAke251bVR3ZWV0fSB0d2VldCBpbiB0cmFkaXRpb25hbCBDaGluZXNlLiBQcmVzZXJ2ZSB0aGUgdGl0bGUuIERvIG5vdCBhZGQgYW55IGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gd2hpY2ggaXMgbm90IG1lbnRpb25lZCBmcm9tIHRoZSBvcmlnaW5hbCBjb250ZW50LiBObyBuZWVkIHRvIGFkZCBhbnkgdGFncyB0byB0aGUgdHdlZXQuIERvIG5vdCBoYXZlIGFueSBudW1iZXIgaW4gZWFjaCB0d2VldC4gRWFjaCB0d2VldCBzZXBhcmF0ZWQgYnkgbmV3bGluZSBjaGFyYWN0ZXIgYW5kIDMgXCItXCIgY2hhcmFjdGVycyBhbmQgYW5vdGhlciBuZXdsaW5lIGNoYXJhY3Rlci5gXG5cdFx0XHRcdHByb21wdCA9IHByb21wdCArIFwiXFxuXFxuXCIgKyBjb250ZW50XG5cdFx0XHRcdHByb21wdCA9IHByb21wdC5yZXBsYWNlKC9cdTI1OEQvZywgXCJcIilcblx0XHRcdFx0cHJvbXB0ID0gcHJvbXB0LnJlcGxhY2UoL1x1MzAxMVxcbitodHRwc1xcOlxcL1xcL2dpdGh1Yi5jb21bXlxcbl0rXFxuL20sIFwiXHUzMDExXFxuXCIpXG5cdFx0XHRcdHByb21wdCA9IHByb21wdC5yZXBsYWNlKC9cXCpcXCovZ20sIFwiXCIpXG5cdFx0XHRcdC8vcHJvbXB0ID0gcHJvbXB0LnJlcGxhY2UoLyFcXFtcXFMqXFxdXFwoKChodHRwczp8aHR0cDp8d3d3XFwuKVxcUyopXFwpL2dtLCBcIiQxXCIpXG5cblx0XHRcdFx0bmF2aWdhdG9yLmNsaXBib2FyZC53cml0ZVRleHQocHJvbXB0KS50aGVuKGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0XHRcdGxldCBsaW5lID0gZWRpdG9yLmxpbmVDb3VudCgpO1xuXG5cdFx0XHRcdFx0bGV0IG51bUxpbmVGaXJzdENvbnRlbnQgPSAwXG5cdFx0XHRcdFx0bGV0IGZyb250TWF0dGVyTGluZUNvdW50ID0gMFxuXHRcdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbGluZTsgaSsrKSB7XG5cdFx0XHRcdFx0XHRpZiAoZnJvbnRNYXR0ZXJMaW5lQ291bnQgPT0gMikge1xuXHRcdFx0XHRcdFx0XHRudW1MaW5lRmlyc3RDb250ZW50ID0gaTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAoZWRpdG9yLmdldExpbmUoaSkgPT0gXCItLS1cIikge1xuXHRcdFx0XHRcdFx0XHRmcm9udE1hdHRlckxpbmVDb3VudCsrXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbGluZTsgaSsrKSB7XG5cdFx0XHRcdFx0XHRpZiAoZWRpdG9yLmdldExpbmUobnVtTGluZUZpcnN0Q29udGVudCkudHJpbSgpID09IFwiXCIpIHtcblx0XHRcdFx0XHRcdFx0bnVtTGluZUZpcnN0Q29udGVudCsrO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0bGV0IHRleHQgPSBcIlwiO1xuXHRcdFx0XHRcdEFycmF5LmZyb20oQXJyYXkobnVtTGluZUZpcnN0Q29udGVudCkua2V5cygpKS5mb3JFYWNoKGkgPT4ge1xuXHRcdFx0XHRcdFx0Y29uc3QgbGluZSA9IGVkaXRvci5nZXRMaW5lKGkpO1xuXHRcdFx0XHRcdFx0dGV4dCA9IHRleHQgKyBsaW5lICsgXCJcXG5cIlxuXHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0ZWRpdG9yLnNldFZhbHVlKHRleHQpXG5cblx0XHRcdFx0XHRyZW5hbWVUYWcodmlldy5maWxlLCBcImMvdC9kXCIsIFwiYy94L2RcIilcblx0XHRcdFx0XHRyZW5hbWVUYWcodmlldy5maWxlLCBcImMvdC9yXCIsIFwiYy94L2RcIilcblx0XHRcdFx0XHRyZW5hbWVUYWcodmlldy5maWxlLCBcImMvdC90XCIsIFwiYy94L2RcIilcblx0XHRcdFx0XHRyZW5hbWVUYWcodmlldy5maWxlLCBcImMvdC9wXCIsIFwiYy94L2RcIilcblxuXHRcdFx0XHRcdGNvbnN0IGN1cnNvciA9IGVkaXRvci5nZXRDdXJzb3IoKVxuXHRcdFx0XHRcdGN1cnNvci5saW5lID0gZWRpdG9yLmxpbmVDb3VudCgpIC0gMVxuXHRcdFx0XHRcdGN1cnNvci5jaCA9IDBcblx0XHRcdFx0XHRlZGl0b3Iuc2V0Q3Vyc29yKGN1cnNvcilcblxuXHRcdFx0XHRcdG5ldyBOb3RpY2UoXCJjb3BpZWQgdG8gY2xpcGJvYXJkLCBwbGVhc2Ugb3BlbiBjaGF0Z3B0IHRvIHBhc3RlXCIpXG5cdFx0XHRcdH0sIGZ1bmN0aW9uIChlcnJvcikge1xuXHRcdFx0XHRcdG5ldyBOb3RpY2UoYGVycm9yIHdoZW4gY29weSB0byBjbGlwYm9hcmQhYCk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSxcblx0XHR9KTtcblxuXHRcdHRoaXMuYWRkT2JzaWRpYW5JY29uKCdjaGF0Z3B0LXRvLXR3aXR0ZXInLCAnR1gnKTtcblx0XHR0aGlzLmFkZENvbW1hbmQoe1xuXHRcdFx0aWQ6IFwiY2hhdGdwdC10by10d2l0dGVyXCIsXG5cdFx0XHRuYW1lOiBcIkdYIENoYXRHUFQgdG8gVHdpdHRlclwiLFxuXHRcdFx0aWNvbjogYGNoYXRncHQtdG8tdHdpdHRlcmAsXG5cdFx0XHRlZGl0b3JDYWxsYmFjazogKGVkaXRvcjogRWRpdG9yLCB2aWV3OiBNYXJrZG93blZpZXcpID0+IHtcblx0XHRcdFx0aWYgKCFlZGl0b3IuZ2V0VmFsdWUoKS5jb250YWlucyhcImMveC9kXCIpKSB7XG5cdFx0XHRcdFx0bmV3IE5vdGljZShcIk5vdGUgdHlwZSBub3QgYy94L2QsIGRvIHRoZSBhY3Rpb24gaW4gd3Jvbmcgbm90ZT9cIilcblx0XHRcdFx0XHRyZXR1cm5cblx0XHRcdFx0fVxuXHRcdFx0XHRjb25zdCBpc1N1Y2Nlc3MgPSB0aGlzLmNvbnZlcnRDaGF0R1BUVG9Ud2l0dGVyRm9ybWF0KGVkaXRvcilcblx0XHRcdFx0aWYgKGlzU3VjY2Vzcylcblx0XHRcdFx0e1xuXHRcdFx0XHRcdHJlbmFtZVRhZyh2aWV3LmZpbGUsIFwiYy94L2RcIiwgXCJjL3gvclwiKVxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdH0pO1xuXG5cdFx0dGhpcy5hZGRPYnNpZGlhbkljb24oJ3JldmVyc2UtdHdpdHRlci1udW1iZXItaWNvbicsICdSVCcpO1xuXHRcdHRoaXMuYWRkQ29tbWFuZCh7XG5cdFx0XHRpZDogXCJyZXZlcnNlLXR3aXR0ZXItbnVtYmVyaW5nXCIsXG5cdFx0XHRuYW1lOiBcIlJUIFJldmVyc2UgVHdpdHRlciBOdW1iZXJpbmdcIixcblx0XHRcdGljb246IGByZXZlcnNlLXR3aXR0ZXItbnVtYmVyLWljb25gLFxuXHRcdFx0ZWRpdG9yQ2FsbGJhY2s6IChlZGl0b3I6IEVkaXRvciwgdmlldzogTWFya2Rvd25WaWV3KSA9PiB7XG5cdFx0XHRcdGlmICghZWRpdG9yLmdldFZhbHVlKCkuY29udGFpbnMoXCJjL3gvclwiKSAmJiAhZWRpdG9yLmdldFZhbHVlKCkuY29udGFpbnMoXCJjL3gvcFwiKSkge1xuXHRcdFx0XHRcdG5ldyBOb3RpY2UoXCJOb3RlIHR5cGUgbm90IGMveC9yIG5vciBjL3gvcCwgZG8gdGhlIGFjdGlvbiBpbiB3cm9uZyBub3RlP1wiKVxuXHRcdFx0XHRcdHJldHVyblxuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMucmV2ZXJzZVR3aXR0ZXJOdW1iZXJpbmcoZWRpdG9yKVxuXHRcdFx0XHRyZW5hbWVUYWcodmlldy5maWxlLCBcImMveC9wXCIsIFwiYy94L2RcIilcblx0XHRcdFx0cmVuYW1lVGFnKHZpZXcuZmlsZSwgXCJjL3gvclwiLCBcImMveC9kXCIpXG5cdFx0XHR9LFxuXHRcdH0pO1xuXG5cdFx0dGhpcy5hZGRPYnNpZGlhbkljb24oJ3RocmVhZHMtYXMtZmFjZWJvb2stcG9zdC10by1jbGlwYm9hcmQtaWNvbicsICdGQycpO1xuXHRcdHRoaXMuYWRkQ29tbWFuZCh7XG5cdFx0XHRpZDogXCJ0aHJlYWRzLWFzLWZhY2Vib29rLXBvc3QtdG8tY2xpcGJvYXJkXCIsXG5cdFx0XHRuYW1lOiBcIkZDIFRocmVhZHMgYXMgRmFjZWJvb2sgcG9zdCBmb3JtYXQgdG8gQ2xpcGJvYXJkXCIsXG5cdFx0XHRpY29uOiBgdGhyZWFkcy1hcy1mYWNlYm9vay1wb3N0LXRvLWNsaXBib2FyZC1pY29uYCxcblx0XHRcdGVkaXRvckNhbGxiYWNrOiAoZWRpdG9yOiBFZGl0b3IsIHZpZXc6IE1hcmtkb3duVmlldykgPT4ge1xuXHRcdFx0XHRjb25zdCB2YWx1ZSA9IGVkaXRvci5nZXRWYWx1ZSgpXG5cdFx0XHRcdC8vaWYgKCF2YWx1ZS5jb250YWlucyhcIiUlICNubSB0byB6ayAlJVwiKSAmJiAhdmFsdWUuY29udGFpbnMoXCIlJSAjbmQgdG8gemsgJSVcIikpIHtcblx0XHRcdFx0Ly9cdHRoaXMuYWRkVGFza1RvUHV0SW50b0NhcmRJblRocmVhZHNDb250ZW50KGVkaXRvcilcblx0XHRcdFx0Ly99XG5cdFx0XHRcdGNvbnN0IHRleHQgPSB0aGlzLmNvbnZlcnRUaHJlYWRzQ29udGVudFRvRm9ybWF0Rm9yRmFjZWJvb2tBcHAoZWRpdG9yKVxuXHRcdFx0XG5cdFx0XHRcdGNvbnN0IGJlZm9yZVRhZyA9IFwiYy90L3RcIlxuXHRcdFx0XHRjb25zdCBhZnRlclRhZyA9IFwiYy90L3BcIlxuXHRcdFx0XG5cdFx0XHRcdG5hdmlnYXRvci5jbGlwYm9hcmQud3JpdGVUZXh0KHRleHQpXG5cdFx0XHRcdC50aGVuKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRyZXR1cm4gcmVuYW1lVGFnKHZpZXcuZmlsZSwgYmVmb3JlVGFnLCBhZnRlclRhZylcblx0XHRcdFx0fSwgZnVuY3Rpb24gKGVycm9yKSB7XG5cdFx0XHRcdFx0bmV3IE5vdGljZShgZXJyb3Igd2hlbiBjb3B5IHRvIGNsaXBib2FyZCFgKTtcblx0XHRcdFx0fSlcblx0XHRcdFx0LnRoZW4oKGZvdW5kVGFnKSA9PiB7XG5cdFx0XHRcdFx0aWYgKGZvdW5kVGFnKSB7XG5cdFx0XHRcdFx0XHRuZXcgTm90aWNlKGBVcGRhdGUgbm90ZXMgdHlwZSBmcm9tIHRhZz1cIiR7YmVmb3JlVGFnfVwiIHRvIHRhZz1cIiR7YWZ0ZXJUYWd9IVxcbkNvcGllZCBmYiBjb250ZW50IHRvIGNsaXBib2FyZCFgKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0bmV3IE5vdGljZShgVGFnIFwiJHtiZWZvcmVUYWd9XCIgbm90IGZvdW5kXFxuQ29waWVkIGZiIGNvbnRlbnQgdG8gY2xpcGJvYXJkIWApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHR9LFxuXHRcdH0pO1xuXG5cdFx0dGhpcy5hZGRPYnNpZGlhbkljb24oJ3RocmVhZHMtYmxvY2stdG8taW1hZ2UnLCAnVEknKTtcblx0XHR0aGlzLmFkZENvbW1hbmQoe1xuXHRcdFx0aWQ6IFwidGhyZWFkcy1ibG9jay10by1pbWFnZVwiLFxuXHRcdFx0bmFtZTogXCJUSSBUaHJlYWRzIHNlZ21lbnQgdG8gaW1hZ2VcIixcblx0XHRcdGljb246IGB0aHJlYWRzLWJsb2NrLXRvLWltYWdlYCxcblx0XHRcdGVkaXRvckNhbGxiYWNrOiAoZWRpdG9yOiBFZGl0b3IsIHZpZXc6IE1hcmtkb3duVmlldykgPT4ge1xuXHRcdFx0XHRjb25zdCB0aHJlYWRTZWdtZW50ID0gdGhpcy5nZXRUaHJlYWRTZWdtZW50KGVkaXRvcilcblx0XHRcdFx0bmV3IFRocmVhZHNUb0ltYWdlc01vZGFsKHRoaXMuYXBwLCB0aHJlYWRTZWdtZW50KS5vcGVuKClcblx0XHRcdH0sXG5cdFx0fSk7XG5cblx0XHR0aGlzLmFkZE9ic2lkaWFuSWNvbignY2hhdGdwdC1nZW5lcmF0ZS1pbWFnZScsICdHSScpO1xuXHRcdHRoaXMuYWRkQ29tbWFuZCh7XG5cdFx0XHRpZDogXCJjaGF0Z3B0LWdlbmVyYXRlLWltYWdlXCIsXG5cdFx0XHRuYW1lOiBcIkdJIENoYXRHUFQgaW1hZ2VcIixcblx0XHRcdGljb246IGBjaGF0Z3B0LWdlbmVyYXRlLWltYWdlYCxcblx0XHRcdGVkaXRvckNhbGxiYWNrOiAoZWRpdG9yOiBFZGl0b3IsIHZpZXc6IE1hcmtkb3duVmlldykgPT4ge1xuXHRcdFx0XHR3aW5kb3cub3Blbignc2hvcnRjdXRzOi8vcnVuLXNob3J0Y3V0P25hbWU9Q2hhdEdQVCUyMEdlbmVyYXRlJTIwSW1hZ2UmeC1zdWNjZXNzPW9ic2lkaWFuOi8vJngtY2FuY2VsPW9ic2lkaWFuOi8vJngtZXJyb3I9b2JzaWRpYW46Ly8nKTtcblx0XHRcdH0sXG5cdFx0fSk7XG5cblx0XHQvKlxuXHRcdHRoaXMuYWRkT2JzaWRpYW5JY29uKCd0aHJlYWRzLXNlZ21lbnQtdG8tY2xpcGJvYXJkJywgJ1NDJyk7XG5cdFx0dGhpcy5hZGRDb21tYW5kKHtcblx0XHRcdGlkOiBcInRocmVhZHMtc2VnbWVudC10by1jbGlwYm9hcmRcIixcblx0XHRcdG5hbWU6IFwiVGhyZWFkcyBzZWdtZW50IHRvIGNsaXBib2FyZFwiLFxuXHRcdFx0aWNvbjogYHRocmVhZHMtc2VnbWVudC10by1jbGlwYm9hcmRgLFxuXHRcdFx0ZWRpdG9yQ2FsbGJhY2s6IChlZGl0b3I6IEVkaXRvciwgdmlldzogTWFya2Rvd25WaWV3KSA9PiB7XG5cdFx0XHRcdGNvbnN0IHRocmVhZFNlZ21lbnQgPSB0aGlzLmdldFRocmVhZFNlZ21lbnQoZWRpdG9yKVxuXHRcdFx0XHRjb25zdCBiZWZvcmVUYWcgPSBcImMveC9yXCJcblx0XHRcdFx0Y29uc3QgYWZ0ZXJUYWcgPSBcImMveC9wXCJcblx0XHRcdFx0bmF2aWdhdG9yLmNsaXBib2FyZC53cml0ZVRleHQodGhyZWFkU2VnbWVudClcblx0XHRcdFx0LnRoZW4oZnVuY3Rpb24gKCkge1x0XG5cdFx0XHRcdFx0cmV0dXJuIHJlbmFtZVRhZyh2aWV3LmZpbGUsIGJlZm9yZVRhZywgYWZ0ZXJUYWcpXG5cdFx0XHRcdH0sIGZ1bmN0aW9uIChlcnJvcikge1xuXHRcdFx0XHRcdG5ldyBOb3RpY2UoYGVycm9yIHdoZW4gY29weSB0byBjbGlwYm9hcmQhYCk7XG5cdFx0XHRcdH0pXG5cdFx0XHRcdC50aGVuKChmb3VuZFRhZykgPT4ge1xuXHRcdFx0XHRcdGlmIChmb3VuZFRhZykge1xuXHRcdFx0XHRcdFx0bmV3IE5vdGljZShgVXBkYXRlIG5vdGVzIHR5cGUgZnJvbSB0YWc9XCIke2JlZm9yZVRhZ31cIiB0byB0YWc9XCIke2FmdGVyVGFnfSFcXG5Db3BpZWRcXG5cXGBcXGBcXGBcXG4ke3RocmVhZFNlZ21lbnR9XFxgXFxgXFxgXFxudG8gY2xpcGJvYXJkIWApO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRuZXcgTm90aWNlKGBUYWcgXCIke2JlZm9yZVRhZ31cIiBub3QgZm91bmRcXG5Db3BpZWRcXG5cXGBcXGBcXGBcXG4ke3RocmVhZFNlZ21lbnR9XFxgXFxgXFxgXFxudG8gY2xpcGJvYXJkIWApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHR9LFxuXHRcdH0pO1xuXHRcdCovXG5cblx0XHR0aGlzLmFkZE9ic2lkaWFuSWNvbigndHdpdHRlci1zZWdtZW50LXRvLWNsaXBib2FyZCcsICdYQycpO1xuXHRcdHRoaXMuYWRkQ29tbWFuZCh7XG5cdFx0XHRpZDogXCJ0d2l0dGVyLXNlZ21lbnQtdG8tY2xpcGJvYXJkXCIsXG5cdFx0XHRuYW1lOiBcIlhDIFR3aXR0ZXIgc2VnbWVudCB0byBjbGlwYm9hcmRcIixcblx0XHRcdGljb246IGB0d2l0dGVyLXNlZ21lbnQtdG8tY2xpcGJvYXJkYCxcblx0XHRcdGVkaXRvckNhbGxiYWNrOiAoZWRpdG9yOiBFZGl0b3IsIHZpZXc6IE1hcmtkb3duVmlldykgPT4ge1xuXHRcdFx0XHRjb25zdCB0aHJlYWRTZWdtZW50ID0gdGhpcy5nZXRUd2l0dGVyU2VnbWVudChlZGl0b3IpXG5cdFx0XHRcdGNvbnN0IGJlZm9yZVRhZyA9IFwiYy94L3JcIlxuXHRcdFx0XHRjb25zdCBhZnRlclRhZyA9IFwiYy94L3BcIlxuXHRcdFx0XHRuYXZpZ2F0b3IuY2xpcGJvYXJkLndyaXRlVGV4dCh0aHJlYWRTZWdtZW50KVxuXHRcdFx0XHQudGhlbihmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHJlbmFtZVRhZyh2aWV3LmZpbGUsIGJlZm9yZVRhZywgYWZ0ZXJUYWcpXG5cdFx0XHRcdH0sIGZ1bmN0aW9uIChlcnJvcikge1xuXHRcdFx0XHRcdG5ldyBOb3RpY2UoYGVycm9yIHdoZW4gY29weSB0byBjbGlwYm9hcmQhYCk7XG5cdFx0XHRcdH0pXG5cdFx0XHRcdC50aGVuKGZvdW5kVGFnID0+IHtcblx0XHRcdFx0XHRpZiAoZm91bmRUYWcpIHtcblx0XHRcdFx0XHRcdG5ldyBOb3RpY2UoYFVwZGF0ZSBub3RlcyB0eXBlIGZyb20gdGFnPVwiJHtiZWZvcmVUYWd9XCIgdG8gdGFnPVwiJHthZnRlclRhZ30hXFxuQ29waWVkXFxuXFxgXFxgXFxgXFxuJHt0aHJlYWRTZWdtZW50fVxcYFxcYFxcYFxcbnRvIGNsaXBib2FyZCFgKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0bmV3IE5vdGljZShgVGFnIFwiJHtiZWZvcmVUYWd9XCIgbm90IGZvdW5kXFxuQ29waWVkXFxuXFxgXFxgXFxgXFxuJHt0aHJlYWRTZWdtZW50fVxcYFxcYFxcYFxcbnRvIGNsaXBib2FyZCFgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSxcblx0XHR9KTtcblxuXHRcdHRoaXMuYWRkT2JzaWRpYW5JY29uKCdzZWdtZW50LXRvLWNsaXBib2FyZCcsICdTQycpO1xuXHRcdHRoaXMuYWRkQ29tbWFuZCh7XG5cdFx0XHRpZDogXCJzZWdtZW50LXRvLWNsaXBib2FyZFwiLFxuXHRcdFx0bmFtZTogXCJTQyBTZWdtZW50IHRvIGNsaXBib2FyZFwiLFxuXHRcdFx0aWNvbjogYHNlZ21lbnQtdG8tY2xpcGJvYXJkYCxcblx0XHRcdGVkaXRvckNhbGxiYWNrOiAoZWRpdG9yOiBFZGl0b3IsIHZpZXc6IE1hcmtkb3duVmlldykgPT4ge1xuXHRcdFx0XHRjb25zdCB0aHJlYWRTZWdtZW50ID0gdGhpcy5nZXRTZWdtZW50KGVkaXRvcilcblx0XHRcdFx0dGhpcy5hZGRUb0NsaXBib2FyZEhpc3RvcnkodGhyZWFkU2VnbWVudClcblx0XHRcdFx0bmF2aWdhdG9yLmNsaXBib2FyZC53cml0ZVRleHQodGhyZWFkU2VnbWVudClcblx0XHRcdFx0LnRoZW4oZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdG5ldyBOb3RpY2UoYENvcGllZFxcblxcYFxcYFxcYFxcbiR7dGhyZWFkU2VnbWVudH1cXGBcXGBcXGBcXG50byBjbGlwYm9hcmQhYCk7XG5cdFx0XHRcdH0sIGZ1bmN0aW9uIChlcnJvcikge1xuXHRcdFx0XHRcdG5ldyBOb3RpY2UoYGVycm9yIHdoZW4gY29weSB0byBjbGlwYm9hcmQhYCk7XG5cdFx0XHRcdH0pXG5cdFx0XHR9LFxuXHRcdH0pO1xuXG5cdFx0dGhpcy5hZGRDb21tYW5kKHtcblx0XHRcdGlkOiBcIm4tZmluZC1yZXBsYWNlXCIsXG5cdFx0XHRuYW1lOiBcIkZpbmQgb3IgUmVwbGFjZVwiLFxuXHRcdFx0aWNvbjogYGZpbGUtc2VhcmNoYCxcblx0XHRcdGVkaXRvckNhbGxiYWNrOiAoZWRpdG9yOiBFZGl0b3IsIHZpZXc6IE1hcmtkb3duVmlldykgPT4ge1xuXHRcdFx0XHRuZXcgRmluZFJlcGxhY2VNb2RhbCh0aGlzLmFwcCkub3BlbigpXG5cdFx0XHR9LFxuXHRcdH0pO1xuXG5cblx0XHQvKlxuXHRcdHRoaXMuYWRkT2JzaWRpYW5JY29uKCduLXByZXZpb3VzLXRhYicsICdUPCcpO1xuXHRcdHRoaXMuYWRkQ29tbWFuZCh7XG5cdFx0XHRpZDogXCJuLXByZXZpb3VzLXRhYlwiLFxuXHRcdFx0bmFtZTogXCJQcmV2aW91cyB0YWJcIixcblx0XHRcdGljb246IGBuLXByZXZpb3VzLXRhYmAsXG5cdFx0XHRlZGl0b3JDYWxsYmFjazogKGVkaXRvcjogRWRpdG9yLCB2aWV3OiBNYXJrZG93blZpZXcpID0+IHtcblx0XHRcdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1jYWxsXG5cdFx0XHRcdC8vY29uc29sZS5sb2codGhpcy5hcHAuY29tbWFuZHMuY29tbWFuZHMpXG5cdFx0XHRcdHRoaXMuYXBwLmNvbW1hbmRzLmV4ZWN1dGVDb21tYW5kQnlJZChcIndvcmtzcGFjZTpwcmV2aW91cy10YWJcIilcblx0XHRcdH0sXG5cdFx0fSk7XG5cblx0XHR0aGlzLmFkZE9ic2lkaWFuSWNvbignbi1uZXh0LXRhYicsICdUPicpO1xuXHRcdHRoaXMuYWRkQ29tbWFuZCh7XG5cdFx0XHRpZDogXCJuLW5leHQtdGFiXCIsXG5cdFx0XHRuYW1lOiBcIk5leHQgdGFiXCIsXG5cdFx0XHRpY29uOiBgbi1uZXh0LXRhYmAsXG5cdFx0XHRlZGl0b3JDYWxsYmFjazogKGVkaXRvcjogRWRpdG9yLCB2aWV3OiBNYXJrZG93blZpZXcpID0+IHtcblx0XHRcdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1jYWxsXG5cdFx0XHRcdC8vY29uc29sZS5sb2codGhpcy5hcHAuY29tbWFuZHMuY29tbWFuZHMpXG5cdFx0XHRcdHRoaXMuYXBwLmNvbW1hbmRzLmV4ZWN1dGVDb21tYW5kQnlJZChcIndvcmtzcGFjZTpuZXh0LXRhYlwiKVxuXHRcdFx0fSxcblx0XHR9KTtcblx0XHQqL1xuXG5cdFx0dGhpcy5hZGRDb21tYW5kKHtcblx0XHRcdGlkOiBcInRvZ2dsZS1idWxsZXQtbnVtYmVyLWxpc3RcIixcblx0XHRcdG5hbWU6IFwiVG9nZ2xlIEJ1bGxldCBOdW1iZXIgTGlzdFwiLFxuXHRcdFx0aWNvbjogYGJ1bGxldC1saXN0YCxcblx0XHRcdGVkaXRvckNhbGxiYWNrOiAoZWRpdG9yOiBFZGl0b3IsIHZpZXc6IE1hcmtkb3duVmlldykgPT4ge1xuXHRcdFx0XHRjb25zdCBjdXJzb3IgPSBlZGl0b3IuZ2V0Q3Vyc29yKClcblx0XHRcdFx0Y29uc3QgY2ggPSBjdXJzb3IuY2hcblx0XHRcdFx0Y29uc3QgbGluZSA9IGN1cnNvci5saW5lXG5cdFx0XHRcdGNvbnN0IGxpbmVDb250ZW50ID0gZWRpdG9yLmdldExpbmUobGluZSlcblx0XHRcdFx0Y29uc3QgcHJldmlvdXNMaW5lQ29udGVudCA9IGxpbmUgPT0gMCA/IFwiXCIgOiBlZGl0b3IuZ2V0TGluZShsaW5lIC0gMSlcblxuXHRcdFx0XHRpZiAoL14oPiApKlxccyotIC8udGVzdChsaW5lQ29udGVudCkpIHsgLy8gYnVsbGV0IGxpc3QgY2FzZVxuXHRcdFx0XHRcdC8vIHRvZ2dsZSB0byBudW1iZXIgbGlzdFxuXHRcdFx0XHRcdGxldCBuID0gXCIxLlwiXG5cdFx0XHRcdFx0Y29uc3QgYSA9IHByZXZpb3VzTGluZUNvbnRlbnQubWF0Y2goL15cXHQqKFxcZCspXFwuIC8pXG5cdFx0XHRcdFx0aWYgKGEpIHtcblx0XHRcdFx0XHRcdGNvbnN0IG5leHROID0gcGFyc2VJbnQoYVswXSkgKyAxXG5cdFx0XHRcdFx0XHRuID0gbmV4dE4udG9TdHJpbmcoKSArIFwiLlwiXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGNvbnN0IHJlcGxhY2VkTGluZUNvbnRlbnQgPSBsaW5lQ29udGVudC5yZXBsYWNlKC9eKCg+ICkqKShcXHMqKS0gLywgXCIkMSQzXCIgKyBuICsgXCIgXCIpXG5cdFx0XHRcdFx0ZWRpdG9yLnNldExpbmUobGluZSwgcmVwbGFjZWRMaW5lQ29udGVudClcblx0XHRcdFx0XHRjdXJzb3IuY2ggPSBjdXJzb3IuY2ggKyBuLmxlbmd0aCAtIDFcblx0XHRcdFx0XHRlZGl0b3Iuc2V0Q3Vyc29yKGN1cnNvcilcblx0XHRcdFx0fSBlbHNlIGlmICgvXig+ICkqXFxzKltcXGRdK1xcLiAvLnRlc3QobGluZUNvbnRlbnQpKSB7IC8vIG51bWJlciBsaXN0IGNhc2Vcblx0XHRcdFx0XHQvLyB0b2dnbGUgdG8gbm9uIGxpc3Rcblx0XHRcdFx0XHRjb25zdCBuID0gbGluZUNvbnRlbnQucmVwbGFjZSgvXigoPiApKikoXFxzKikoW1xcZF0rXFwuICkuKi8sIFwiJDRcIilcblx0XHRcdFx0XHRjb25zdCByZXBsYWNlZExpbmVDb250ZW50ID0gbGluZUNvbnRlbnQucmVwbGFjZSgvXigoPiApKikoXFxzKilbXFxkXStcXC4gLywgXCIkMSQzXCIpXG5cdFx0XHRcdFx0ZWRpdG9yLnNldExpbmUobGluZSwgcmVwbGFjZWRMaW5lQ29udGVudClcblx0XHRcdFx0XHRjdXJzb3IuY2ggPSAoY3Vyc29yLmNoIC0gbi5sZW5ndGgpID4gMCA/IChjdXJzb3IuY2ggLSBuLmxlbmd0aCkgOiAwXG5cdFx0XHRcdFx0ZWRpdG9yLnNldEN1cnNvcihjdXJzb3IpXG5cdFx0XHRcdH0gZWxzZSB7IC8vIG5vIGxpc3Rcblx0XHRcdFx0XHQvLyB0b2dnbGUgdG8gYnVsbGV0IGxpc3Rcblx0XHRcdFx0XHRjb25zdCByZXBsYWNlZExpbmVDb250ZW50ID0gbGluZUNvbnRlbnQucmVwbGFjZSgvXigoPiApKikoXFxzKikvLCBcIiQxJDMtIFwiKVxuXHRcdFx0XHRcdGVkaXRvci5zZXRMaW5lKGxpbmUsIHJlcGxhY2VkTGluZUNvbnRlbnQpXG5cdFx0XHRcdFx0Y3Vyc29yLmNoID0gY3Vyc29yLmNoICsgMlxuXHRcdFx0XHRcdGVkaXRvci5zZXRDdXJzb3IoY3Vyc29yKVxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0aG90a2V5czogW1xuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bW9kaWZpZXJzOiBbYEN0cmxgLCBgTWV0YWAsIGBTaGlmdGBdLFxuXHRcdFx0XHRcdGtleTogYC1gLFxuXHRcdFx0XHR9LFxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bW9kaWZpZXJzOiBbYEN0cmxgLCBgQWx0YCwgYFNoaWZ0YF0sXG5cdFx0XHRcdFx0a2V5OiBgLWAsXG5cdFx0XHRcdH0sXG5cdFx0XHRdXG5cdFx0fSk7XG5cblx0XHR0aGlzLmFkZENvbW1hbmQoe1xuXHRcdFx0aWQ6ICdjb3B5LW9yLW1vdmUtdG8tbmV3LW5vdGUnLFxuXHRcdFx0bmFtZTogJ0NvcHkgb3IgTW92ZSB0byBuZXcgbm90ZSBDTU4nLFxuXHRcdFx0aWNvbjogYGFpcnBsYXlgLFxuXHRcdFx0ZWRpdG9yQ2FsbGJhY2s6IGFzeW5jIChlZGl0b3I6IEVkaXRvciwgdmlldzogTWFya2Rvd25WaWV3KSA9PiB7XG5cdFx0XHRcdG5ldyBDb3B5T3JNb3ZlVG9OZXdOb3RlTW9kYWwodGhpcy5hcHAsIGVkaXRvcikub3BlbigpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0dGhpcy5hZGRDb21tYW5kKHtcblx0XHRcdGlkOiBcImVkaXRvci1jb3B5LWxpbmUtdG8tY2xpcGJvYXJkXCIsXG5cdFx0XHRuYW1lOiBcIkVkaXRvciBDb3B5IExpbmUgdG8gQ2xpcGJvYXJkXCIsXG5cdFx0XHRpY29uOiBgYWxpZ24tdmVydGljYWwtc3BhY2UtYXJvdW5kYCxcblx0XHRcdGVkaXRvckNhbGxiYWNrOiAoZWRpdG9yOiBFZGl0b3IsIHZpZXc6IE1hcmtkb3duVmlldykgPT4ge1xuXHRcdFx0XHRjb25zdCBzZWxlY3Rpb24gPSBleHBvcnRDdXJyZW50U2VsZWN0aW9uKGVkaXRvcik7XG5cdFx0XHRcdGNvbnN0IGNvcHlDb250ZW50ID0gc2VsZWN0aW9uLmNvbnRhaW5zKFwiXFxuXCIpXG5cdFx0XHRcdFx0XHRcdFx0XHQ/IHNlbGVjdGlvblxuXHRcdFx0XHRcdFx0XHRcdFx0OiBzZWxlY3Rpb24ucmVwbGFjZSgvXlxcdCotIC8sICcnKS5yZXBsYWNlKC9eXFx0KlxcZCtcXC4gLywgJycpXG5cdFx0XHRcdHRoaXMuYWRkVG9DbGlwYm9hcmRIaXN0b3J5KGNvcHlDb250ZW50KTtcblx0XHRcdFx0bmF2aWdhdG9yLmNsaXBib2FyZC53cml0ZVRleHQoY29weUNvbnRlbnQpLnRoZW4oZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdG5ldyBOb3RpY2UoYENvcGllZCBjb250ZW50XFxuXFxgXFxgXFxgXFxuJHtjb3B5Q29udGVudH1cXG5cXGBcXGBcXGBcXG50byBjbGlwYm9hcmQhYCk7XG5cdFx0XHRcdH0sIGZ1bmN0aW9uIChlcnJvcikge1xuXHRcdFx0XHRcdG5ldyBOb3RpY2UoYGVycm9yIHdoZW4gY29weSB0byBjbGlwYm9hcmQhYCk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSxcblx0XHRcdGhvdGtleXM6IFtcblx0XHRcdFx0e1xuXHRcdFx0XHRcdG1vZGlmaWVyczogW2BDdHJsYCwgYE1ldGFgLCBgU2hpZnRgXSxcblx0XHRcdFx0XHRrZXk6IFwiL1wiLFxuXHRcdFx0XHR9LFxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bW9kaWZpZXJzOiBbYEN0cmxgLCBgQWx0YCwgYFNoaWZ0YF0sXG5cdFx0XHRcdFx0a2V5OiBcIi9cIixcblx0XHRcdFx0fSxcblx0XHRcdF1cblx0XHR9KVxuXG5cdFx0dGhpcy5hZGRDb21tYW5kKHtcblx0XHRcdGlkOiBcImVkaXRvci1jdXQtbGluZS10by1jbGlwYm9hcmRcIixcblx0XHRcdG5hbWU6IFwiRWRpdG9yIEN1dCBMaW5lIHRvIENsaXBib2FyZFwiLFxuXHRcdFx0aWNvbjogYGFsaWduLXZlcnRpY2FsLWp1c3RpZnktY2VudGVyYCxcblx0XHRcdGVkaXRvckNhbGxiYWNrOiAoZWRpdG9yOiBFZGl0b3IsIHZpZXc6IE1hcmtkb3duVmlldykgPT4ge1xuXHRcdFx0XHRjb25zdCBzZWxlY3Rpb24gPSBleHBvcnRDdXJyZW50U2VsZWN0aW9uKGVkaXRvcik7XG5cdFx0XHRcdGNvbnN0IGN1cnNvciA9IGVkaXRvci5nZXRDdXJzb3IoKVxuXHRcdFx0XHRjb25zdCBjb3B5Q29udGVudCA9IHNlbGVjdGlvbi5jb250YWlucyhcIlxcblwiKVxuXHRcdFx0XHRcdFx0XHRcdFx0PyBzZWxlY3Rpb25cblx0XHRcdFx0XHRcdFx0XHRcdDogc2VsZWN0aW9uLnJlcGxhY2UoL15cXHQqLSAvLCAnJykucmVwbGFjZSgvXlxcdCpcXGQrXFwuIC8sICcnKVxuXHRcdFx0XHRsZXQgbmV3Q29udGVudCA9ICcnXG5cdFx0XHRcdGNvbnN0IHNlbGVjdGlvblJhbmdlOiBTZWxlY3Rpb25SYW5nZSA9IGdldEN1cnJlbnRTZWxlY3Rpb25MaW5lTnVtYmVyKGVkaXRvcilcblx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBlZGl0b3IubGluZUNvdW50KCk7IGkrKykge1xuXHRcdFx0XHRcdGlmIChpIDwgc2VsZWN0aW9uUmFuZ2UuZnJvbUxpbmVOdW0gfHwgaSA+IHNlbGVjdGlvblJhbmdlLnRvTGluZU51bSkge1xuXHRcdFx0XHRcdFx0bmV3Q29udGVudCA9IG5ld0NvbnRlbnQgKyBlZGl0b3IuZ2V0TGluZShpKSArIFwiXFxuXCJcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5hZGRUb0NsaXBib2FyZEhpc3RvcnkoY29weUNvbnRlbnQpO1xuXHRcdFx0XHRuYXZpZ2F0b3IuY2xpcGJvYXJkLndyaXRlVGV4dChjb3B5Q29udGVudCkudGhlbihmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0bmV3IE5vdGljZShgQ29waWVkIGNvbnRlbnRcXG5cXGBcXGBcXGBcXG4ke2NvcHlDb250ZW50fVxcblxcYFxcYFxcYFxcbnRvIGNsaXBib2FyZCFgKTtcblx0XHRcdFx0fSwgZnVuY3Rpb24gKGVycm9yKSB7XG5cdFx0XHRcdFx0bmV3IE5vdGljZShgZXJyb3Igd2hlbiBjb3B5IHRvIGNsaXBib2FyZCFgKTtcblx0XHRcdFx0fSk7XG5cdFx0XHRcdGVkaXRvci5zZXRWYWx1ZShuZXdDb250ZW50KVxuXHRcdFx0XHRjdXJzb3IubGluZSA9IHNlbGVjdGlvblJhbmdlLmZyb21MaW5lTnVtXG5cdFx0XHRcdGlmIChlZGl0b3IuZ2V0TGluZShzZWxlY3Rpb25SYW5nZS5mcm9tTGluZU51bSkubGVuZ3RoIDwgc2VsZWN0aW9uUmFuZ2UuZnJvbUNoKSB7XG5cdFx0XHRcdFx0Y3Vyc29yLmNoID0gZWRpdG9yLmdldExpbmUoc2VsZWN0aW9uUmFuZ2UuZnJvbUxpbmVOdW0pLmxlbmd0aFxuXHRcdFx0XHR9XG5cdFx0XHRcdGVkaXRvci5zZXRDdXJzb3IoY3Vyc29yKVxuXHRcdFx0fSxcblx0XHRcdGhvdGtleXM6IFtcblx0XHRcdFx0e1xuXHRcdFx0XHRcdG1vZGlmaWVyczogW2BDdHJsYCwgYE1ldGFgLCBgU2hpZnRgXSxcblx0XHRcdFx0XHRrZXk6IFwiXFxcXFwiLFxuXHRcdFx0XHR9LFxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bW9kaWZpZXJzOiBbYEN0cmxgLCBgQWx0YCwgYFNoaWZ0YF0sXG5cdFx0XHRcdFx0a2V5OiBcIlxcXFxcIixcblx0XHRcdFx0fSxcblx0XHRcdF1cblx0XHR9KVxuXG5cdFx0dGhpcy5hZGRDb21tYW5kKHtcblx0XHRcdGlkOiBcImVkaXRvci1pbmRlbnQtbGluZVwiLFxuXHRcdFx0bmFtZTogXCJFZGl0b3IgSW5kZW50IFNlbGVjdGlvblwiLFxuXHRcdFx0aWNvbjogYHJpZ2h0LWFycm93LXdpdGgtdGFpbGAsXG5cdFx0XHRlZGl0b3JDYWxsYmFjazogKGVkaXRvcjogRWRpdG9yLCB2aWV3OiBNYXJrZG93blZpZXcpID0+IHtcblx0XHRcdFx0Y29uc3QgbGlzdFNlbGVjdGlvbnMgOiBFZGl0b3JTZWxlY3Rpb25bXSA9IGVkaXRvci5saXN0U2VsZWN0aW9ucygpXG5cdFx0XHRcdGxpc3RTZWxlY3Rpb25zLmZvckVhY2gobGlzdFNlbGVjdGlvbiA9PiB7XG5cdFx0XHRcdFx0Y29uc3QgYSA9IGxpc3RTZWxlY3Rpb24uaGVhZC5saW5lXG5cdFx0XHRcdFx0Y29uc3QgYiA9IGxpc3RTZWxlY3Rpb24uYW5jaG9yLmxpbmVcblx0XHRcdFx0XHRjb25zdCBmcm9tTGluZU51bSA9IGIgPiBhID8gYSA6IGJcblx0XHRcdFx0XHRjb25zdCB0b0xpbmVOdW0gPSBiID4gYSA/IGIgOiBhXG5cdFx0XHRcdFx0Zm9yIChsZXQgaSA9IGZyb21MaW5lTnVtOyBpIDw9IHRvTGluZU51bTsgaSsrKSB7XG5cdFx0XHRcdFx0XHRjb25zdCBsaW5lID0gZWRpdG9yLmdldExpbmUoaSlcblx0XHRcdFx0XHRcdGVkaXRvci5zZXRMaW5lKGksIGxpbmUucmVwbGFjZSgvXi8sIFwiXFx0XCIpKVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSlcblx0XHRcdFx0bGV0IGxzcyA6IEVkaXRvclNlbGVjdGlvbltdID0gW11cblx0XHRcdFx0bGlzdFNlbGVjdGlvbnMuZm9yRWFjaChscyA9PiB7XG5cdFx0XHRcdFx0Y29uc3QgaGVhZCA9IGxzLmhlYWRcblx0XHRcdFx0XHRoZWFkLmNoID0gaGVhZC5jaCArIDFcblx0XHRcdFx0XHRjb25zdCBhbmNob3IgPSBscy5hbmNob3Jcblx0XHRcdFx0XHRhbmNob3IuY2ggPSBhbmNob3IuY2ggKyAxXG5cdFx0XHRcdFx0Y29uc3QgbmV3THM6IEVkaXRvclNlbGVjdGlvbiA9IHthbmNob3IsIGhlYWR9XG5cdFx0XHRcdFx0bHNzLnB1c2gobmV3THMpXG5cdFx0XHRcdH0pXG5cdFx0XHRcdGVkaXRvci5zZXRTZWxlY3Rpb25zKGxzcylcblx0XHRcdH1cblx0XHR9KVxuXG5cdFx0dGhpcy5hZGRDb21tYW5kKHtcblx0XHRcdGlkOiBcImVkaXRvci1vdXRkZW50LWxpbmVcIixcblx0XHRcdG5hbWU6IFwiRWRpdG9yIE91dGRlbnQgU2VsZWN0aW9uXCIsXG5cdFx0XHRpY29uOiBgbGVmdC1hcnJvdy13aXRoLXRhaWxgLFxuXHRcdFx0ZWRpdG9yQ2FsbGJhY2s6IChlZGl0b3I6IEVkaXRvciwgdmlldzogTWFya2Rvd25WaWV3KSA9PiB7XG5cdFx0XHRcdGNvbnN0IGxpc3RTZWxlY3Rpb25zIDogRWRpdG9yU2VsZWN0aW9uW10gPSBlZGl0b3IubGlzdFNlbGVjdGlvbnMoKVxuXHRcdFx0XHRsaXN0U2VsZWN0aW9ucy5mb3JFYWNoKGxpc3RTZWxlY3Rpb24gPT4ge1xuXHRcdFx0XHRcdGNvbnN0IGEgPSBsaXN0U2VsZWN0aW9uLmhlYWQubGluZVxuXHRcdFx0XHRcdGNvbnN0IGIgPSBsaXN0U2VsZWN0aW9uLmFuY2hvci5saW5lXG5cdFx0XHRcdFx0Y29uc3QgZnJvbUxpbmVOdW0gPSBiID4gYSA/IGEgOiBiXG5cdFx0XHRcdFx0Y29uc3QgdG9MaW5lTnVtID0gYiA+IGEgPyBiIDogYVxuXHRcdFx0XHRcdGZvciAobGV0IGkgPSBmcm9tTGluZU51bTsgaSA8PSB0b0xpbmVOdW07IGkrKykge1xuXHRcdFx0XHRcdFx0Y29uc3QgbGluZSA9IGVkaXRvci5nZXRMaW5lKGkpXG5cdFx0XHRcdFx0XHRlZGl0b3Iuc2V0TGluZShpLCBsaW5lLnJlcGxhY2UoL15cXHQvLCBcIlwiKSlcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pXG5cdFx0XHRcdGxldCBsc3MgOiBFZGl0b3JTZWxlY3Rpb25bXSA9IFtdXG5cdFx0XHRcdGxpc3RTZWxlY3Rpb25zLmZvckVhY2gobHMgPT4ge1xuXHRcdFx0XHRcdGNvbnN0IGhlYWQgPSBscy5oZWFkXG5cdFx0XHRcdFx0aGVhZC5jaCA9IGhlYWQuY2ggKyAxXG5cdFx0XHRcdFx0Y29uc3QgYW5jaG9yID0gbHMuYW5jaG9yXG5cdFx0XHRcdFx0YW5jaG9yLmNoID0gYW5jaG9yLmNoICsgMVxuXHRcdFx0XHRcdGNvbnN0IG5ld0xzOiBFZGl0b3JTZWxlY3Rpb24gPSB7YW5jaG9yLCBoZWFkfVxuXHRcdFx0XHRcdGxzcy5wdXNoKG5ld0xzKVxuXHRcdFx0XHR9KVxuXHRcdFx0XHRlZGl0b3Iuc2V0U2VsZWN0aW9ucyhsc3MpXG5cdFx0XHR9XG5cdFx0fSlcblxuXG5cdFx0Ly8gVGhpcyBhZGRzIGEgc2V0dGluZ3MgdGFiIHNvIHRoZSB1c2VyIGNhbiBjb25maWd1cmUgdmFyaW91cyBhc3BlY3RzIG9mIHRoZSBwbHVnaW5cblx0XHR0aGlzLmFkZFNldHRpbmdUYWIobmV3IFNhbXBsZVNldHRpbmdUYWIodGhpcy5hcHAsIHRoaXMpKTtcblx0fVxuXG5cdGNvbnZlcnRDaGF0R1BUVG9Ud2l0dGVyRm9ybWF0KGVkaXRvcjogRWRpdG9yKSA6IGJvb2xlYW4geyAvLyB0cnVlIG1lYW5zIHN1Y2Nlc3Ncblx0XHRsZXQgbGluZSA9IGVkaXRvci5saW5lQ291bnQoKTtcblxuXHRcdGxldCBudW1MaW5lRmlyc3RDb250ZW50ID0gMFxuXHRcdGxldCBmcm9udE1hdHRlckxpbmVDb3VudCA9IDBcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGxpbmU7IGkrKykge1xuXHRcdFx0aWYgKGZyb250TWF0dGVyTGluZUNvdW50ID09IDIpIHtcblx0XHRcdFx0bnVtTGluZUZpcnN0Q29udGVudCA9IGk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGVkaXRvci5nZXRMaW5lKGkpID09IFwiLS0tXCIpIHtcblx0XHRcdFx0ZnJvbnRNYXR0ZXJMaW5lQ291bnQrK1xuXHRcdFx0fVxuXHRcdH1cblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGxpbmU7IGkrKykge1xuXHRcdFx0aWYgKGVkaXRvci5nZXRMaW5lKG51bUxpbmVGaXJzdENvbnRlbnQpLnRyaW0oKSA9PSBcIlwiKSB7XG5cdFx0XHRcdG51bUxpbmVGaXJzdENvbnRlbnQrKztcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGxldCB0b3RhbFR3ZWV0Q291bnQgPSAxXG5cblx0XHRBcnJheS5mcm9tKEFycmF5KGxpbmUgLSBudW1MaW5lRmlyc3RDb250ZW50KS5rZXlzKCkpLmZvckVhY2goaSA9PiB7XG5cdFx0XHRjb25zdCBsaW5lID0gZWRpdG9yLmdldExpbmUoaSArIG51bUxpbmVGaXJzdENvbnRlbnQpO1xuXHRcdFx0bGV0IG1vZGlmaWVkTGluZSA9IGxpbmUucmVwbGFjZSgvXl9fX18rLywgXCItLS1cIikucmVwbGFjZSgvXi0tLS0rLywgXCItLS1cIilcblx0XHRcdGVkaXRvci5zZXRMaW5lKGkgKyBudW1MaW5lRmlyc3RDb250ZW50LCBtb2RpZmllZExpbmUpXG5cdFx0XHRpZiAobW9kaWZpZWRMaW5lID09IFwiLS0tXCIpIHtcblx0XHRcdFx0dG90YWxUd2VldENvdW50ID0gdG90YWxUd2VldENvdW50ICsgMVxuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0bGV0IG51bVR3ZWV0ID0gMVxuXHRcdGxldCByZWFkeVRvQWRkVHdlZXRDb3VudCA9IHRydWVcblxuXHRcdGxldCB0ZXh0ID0gXCJcIjtcblx0XHRBcnJheS5mcm9tKEFycmF5KG51bUxpbmVGaXJzdENvbnRlbnQpLmtleXMoKSkuZm9yRWFjaChpID0+IHtcblx0XHRcdGNvbnN0IGxpbmUgPSBlZGl0b3IuZ2V0TGluZShpKTtcblx0XHRcdHRleHQgPSB0ZXh0ICsgbGluZSArIFwiXFxuXCJcblx0XHR9KVxuXG5cdFx0QXJyYXkuZnJvbShBcnJheShsaW5lIC0gbnVtTGluZUZpcnN0Q29udGVudCkua2V5cygpKS5mb3JFYWNoKGkgPT4ge1xuXHRcdFx0Y29uc3QgbGluZSA9IGVkaXRvci5nZXRMaW5lKGkgKyBudW1MaW5lRmlyc3RDb250ZW50KTtcblx0XHRcdGxldCBtb2RpZmllZExpbmUgPSBsaW5lO1xuXHRcdFx0aWYgKGxpbmUgPT0gXCItLS1cIikge1xuXHRcdFx0XHRyZWFkeVRvQWRkVHdlZXRDb3VudCA9IHRydWVcblx0XHRcdFx0bnVtVHdlZXQgPSBudW1Ud2VldCArIDFcblx0XHRcdH0gZWxzZSBpZiAobGluZSAhPSBcIlwiICYmIHJlYWR5VG9BZGRUd2VldENvdW50KSB7XG5cdFx0XHRcdGlmICghL15cXGQrXFwvXFxkKy4qLy50ZXN0KGxpbmUpKSB7XG5cdFx0XHRcdFx0bW9kaWZpZWRMaW5lID0gYCR7bnVtVHdlZXR9LyR7dG90YWxUd2VldENvdW50fSAke2xpbmV9YFxuXHRcdFx0XHR9XG5cdFx0XHRcdHJlYWR5VG9BZGRUd2VldENvdW50ID0gZmFsc2Vcblx0XHRcdH1cblx0XHRcdHRleHQgPSB0ZXh0ICsgbW9kaWZpZWRMaW5lICsgXCJcXG5cIlxuXHRcdH0pO1xuXG5cdFx0dGV4dCA9IHRleHQucmVwbGFjZShcIlx1MjU4RFwiLCBcIlwiKVxuXG5cdFx0Ly8gc2hvdWxkIEkgYWRkIGNoZWNrIHNlZ21lbnQ/XG5cdFx0Y29uc3QgdHdlZXRzID0gdGV4dC5zcGxpdChcIi0tLVwiKVxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgdHdlZXRzLmxlbmd0aDsgaSsrKVxuXHRcdHtcblx0XHRcdGNvbnN0IHR3ZWV0ID0gdHdlZXRzW2ldLnJlcGxhY2UoLyhodHRwczp8aHR0cDp8d3d3XFwuKVxcUyovZ20sIFwiXCIpLnJlcGxhY2UoL15cXG4rL20sIFwiXCIpLnJlcGxhY2UoL1xcbiskL20sIFwiXCIpXG5cdFx0XHRpZiAodHdlZXQubGVuZ3RoID4gMTQwKVxuXHRcdFx0e1xuXHRcdFx0XHRuZXcgTm90aWNlKFwiYGBgXFxuXCIgKyB0d2VldCArIFwiXFxuYGBgXFxuXFxuZXhjZWVkIDE0MCBjaGFyYWN0ZXJzLiBQcm9iYWJseSBjYW5ub3QgcG9zdCBpbiB0d2l0dGVyLiBQbGVhc2UgcmVmaW5lIHRoZSB0d2VldC4gQWJvcnRpbmdcIilcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGVkaXRvci5zZXRWYWx1ZSh0ZXh0KVxuXHRcdGNvbnN0IGN1cnNvciA9IGVkaXRvci5nZXRDdXJzb3IoKVxuXHRcdGN1cnNvci5saW5lID0gZWRpdG9yLmxpbmVDb3VudCgpIC0gMVxuXHRcdGVkaXRvci5zZXRDdXJzb3IoY3Vyc29yKVxuXHRcdHJldHVybiB0cnVlXG5cdH1cblxuXHRyZXZlcnNlVHdpdHRlck51bWJlcmluZyhlZGl0b3I6IEVkaXRvcikge1xuXHRcdGxldCBsaW5lID0gZWRpdG9yLmxpbmVDb3VudCgpO1xuXG5cdFx0bGV0IG51bUxpbmVGaXJzdENvbnRlbnQgPSAwXG5cdFx0bGV0IGZyb250TWF0dGVyTGluZUNvdW50ID0gMFxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbGluZTsgaSsrKSB7XG5cdFx0XHRpZiAoZnJvbnRNYXR0ZXJMaW5lQ291bnQgPT0gMikge1xuXHRcdFx0XHRudW1MaW5lRmlyc3RDb250ZW50ID0gaTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRpZiAoZWRpdG9yLmdldExpbmUoaSkgPT0gXCItLS1cIikge1xuXHRcdFx0XHRmcm9udE1hdHRlckxpbmVDb3VudCsrXG5cdFx0XHR9XG5cdFx0fVxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbGluZTsgaSsrKSB7XG5cdFx0XHRpZiAoZWRpdG9yLmdldExpbmUobnVtTGluZUZpcnN0Q29udGVudCkudHJpbSgpID09IFwiXCIpIHtcblx0XHRcdFx0bnVtTGluZUZpcnN0Q29udGVudCsrO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0bGV0IHRleHQgPSBcIlwiO1xuXHRcdEFycmF5LmZyb20oQXJyYXkobnVtTGluZUZpcnN0Q29udGVudCkua2V5cygpKS5mb3JFYWNoKGkgPT4ge1xuXHRcdFx0Y29uc3QgbGluZSA9IGVkaXRvci5nZXRMaW5lKGkpO1xuXHRcdFx0dGV4dCA9IHRleHQgKyBsaW5lICsgXCJcXG5cIlxuXHRcdH0pXG5cblx0XHRBcnJheS5mcm9tKEFycmF5KGxpbmUgLSBudW1MaW5lRmlyc3RDb250ZW50KS5rZXlzKCkpLmZvckVhY2goaSA9PiB7XG5cdFx0XHRjb25zdCBsaW5lID0gZWRpdG9yLmdldExpbmUoaSArIG51bUxpbmVGaXJzdENvbnRlbnQpO1xuXHRcdFx0Y29uc3QgbW9kaWZpZWRMaW5lID0gbGluZS5yZXBsYWNlKC9eXFxkK1xcL1xcZCsgLywgXCJcIilcblx0XHRcdHRleHQgPSB0ZXh0ICsgbW9kaWZpZWRMaW5lICsgXCJcXG5cIlxuXHRcdH0pO1xuXG5cdFx0ZWRpdG9yLnNldFZhbHVlKHRleHQpXG5cdFx0Y29uc3QgY3Vyc29yID0gZWRpdG9yLmdldEN1cnNvcigpXG5cdFx0Y3Vyc29yLmxpbmUgPSBlZGl0b3IubGluZUNvdW50KCkgLSAxXG5cdFx0ZWRpdG9yLnNldEN1cnNvcihjdXJzb3IpXG5cdH1cblxuXG5cdGNvbnZlcnRUaHJlYWRzQ29udGVudFRvRm9ybWF0Rm9yVGhyZWFkc0FwcChlZGl0b3I6IEVkaXRvcikgOiBzdHJpbmcge1xuXHRcdGxldCByZXN1bHQgPSB0aGlzLmNvbnZlcnRUaHJlYWRzQ29udGVudFRvTGlnaHRQb3N0Rm9ybWF0KGVkaXRvciwgXCJcdUQ4M0VcdURERjVcIiwgXCJcXG5cXG5cXG5cIilcblx0XHRyZXN1bHQgPSByZXN1bHQucmVwbGFjZSgvaHR0cHNcXDpcXC9cXC9naXRodWIuY29tW15cXG5dK1xcblxcblxcbi9tLCBcIlwiKVxuXHRcdHJldHVybiByZXN1bHRcblx0fVxuXG5cdGNvbnZlcnRUaHJlYWRzQ29udGVudFRvRm9ybWF0Rm9yRmFjZWJvb2tBcHAoZWRpdG9yOiBFZGl0b3IpIDogc3RyaW5nIHtcblx0XHRyZXR1cm4gdGhpcy5jb252ZXJ0VGhyZWFkc0NvbnRlbnRUb0xpZ2h0UG9zdEZvcm1hdChlZGl0b3IsIFwiXCIsIFwiXFxuXFxuXHUxMTczXHUxMTczXHUxMTczXHUxMTczXHUxMTczXHUxMTczXHUxMTczXHUxMTczXHUxMTczXHUxMTczXHUxMTczXHUxMTczXHUxMTczXHUxMTczXHUxMTczXHUxMTczXHUxMTczXHUxMTczXHUxMTczXHUxMTczXHUxMTczXHUxMTczXFxuXFxuXCIsIChhKSA9PiBhLnJlcGxhY2UoXCJcdUQ4M0RcdURDNDdcIiwgXCJcIikpXG5cdH1cblxuXHRjb252ZXJ0VGhyZWFkc0NvbnRlbnRUb1BPRShlZGl0b3I6IEVkaXRvcikgOiBzdHJpbmcge1xuXHRcdHJldHVybiB0aGlzLmNvbnZlcnRUaHJlYWRzQ29udGVudFRvTGlnaHRQb3N0Rm9ybWF0KGVkaXRvciwgXCJcIiwgXCJcXG5cXG4tLS1cXG5cXG5cIiwgKGEpID0+IGEucmVwbGFjZShcIlx1RDgzRFx1REM0N1wiLCBcIlwiKSlcblx0fVxuXG4vKlxuXHRhZGRUYXNrVG9QdXRJbnRvQ2FyZEluVGhyZWFkc0NvbnRlbnQoZWRpdG9yOiBFZGl0b3IpIHtcblx0XHRsZXQgbGluZSA9IGVkaXRvci5saW5lQ291bnQoKTtcblxuXHRcdGxldCBmcm9udE1hdHRlckxpbmVDb3VudCA9IDBcblx0XHRsZXQgdGV4dCA9IFwiXCI7XG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lOyBpKyspIHtcblx0XHRcdGlmIChlZGl0b3IuZ2V0TGluZShpKSA9PSBcIi0tLVwiKSB7XG5cdFx0XHRcdGZyb250TWF0dGVyTGluZUNvdW50Kytcblx0XHRcdH1cblx0XHRcdGNvbnN0IGxpbmUgPSBlZGl0b3IuZ2V0TGluZShpKTtcblx0XHRcdFxuXHRcdFx0Ly9pZiAoZnJvbnRNYXR0ZXJMaW5lQ291bnQgPiAyICYmIGxpbmUgPT0gXCItLS1cIikge1xuXHRcdFx0Ly9cdHRleHQgPSB0ZXh0ICsgXCIlJSAjbm0gdG8gemsgJSVcXG5cXG5cIlxuXHRcdFx0Ly99XG5cdFx0XHR0ZXh0ID0gdGV4dCArIGxpbmUgKyBcIlxcblwiXG5cdFx0fVxuXG5cdFx0ZWRpdG9yLnNldFZhbHVlKHRleHQpO1xuXHR9XG4qL1xuXG5cdGNvbnZlcnRUaHJlYWRzQ29udGVudFRvTGlnaHRQb3N0Rm9ybWF0KGVkaXRvcjogRWRpdG9yLCBoZWFkZXJJY29uOiBzdHJpbmcsIHBhcmFncmFwaFNlcGFyYXRvcjogc3RyaW5nXG5cdFx0LCBhZGRpdGlvblJlcGxhY2VGbjogKGE6IHN0cmluZykgPT4gc3RyaW5nID0gKGEpID0+IGEpIDogc3RyaW5nIHtcblx0XHRsZXQgbGluZSA9IGVkaXRvci5saW5lQ291bnQoKTtcblxuXHRcdGxldCBudW1MaW5lRmlyc3RDb250ZW50ID0gMFxuXHRcdGxldCBmcm9udE1hdHRlckxpbmVDb3VudCA9IDBcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGxpbmU7IGkrKykge1xuXHRcdFx0aWYgKGZyb250TWF0dGVyTGluZUNvdW50ID09IDIpIHtcblx0XHRcdFx0bnVtTGluZUZpcnN0Q29udGVudCA9IGk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGVkaXRvci5nZXRMaW5lKGkpID09IFwiLS0tXCIpIHtcblx0XHRcdFx0ZnJvbnRNYXR0ZXJMaW5lQ291bnQrK1xuXHRcdFx0fVxuXHRcdH1cblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGxpbmU7IGkrKykge1xuXHRcdFx0aWYgKGVkaXRvci5nZXRMaW5lKG51bUxpbmVGaXJzdENvbnRlbnQpLnRyaW0oKSA9PSBcIlwiKSB7XG5cdFx0XHRcdG51bUxpbmVGaXJzdENvbnRlbnQrKztcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGxldCB0ZXh0ID0gXCJcIjtcblx0XHRsZXQgbmV3Q29uc2VjdXRpdmVMaW5lQ291bnQgPSAwO1xuXHRcdEFycmF5LmZyb20oQXJyYXkobGluZSAtIG51bUxpbmVGaXJzdENvbnRlbnQpLmtleXMoKSkuZm9yRWFjaChpID0+IHtcblx0XHRcdGNvbnN0IGxpbmUgPSBlZGl0b3IuZ2V0TGluZShpICsgbnVtTGluZUZpcnN0Q29udGVudCk7XG5cdFx0XHRpZiAoIWxpbmUudHJpbSgpLnN0YXJ0c1dpdGgoXCIlJVwiKSB8fCAhbGluZS50cmltKCkuZW5kc1dpdGgoXCIlJVwiKSkge1xuXHRcdFx0XHRpZiAobGluZSA9PSBcIi0tLVwiKSB7XG5cdFx0XHRcdFx0bmV3Q29uc2VjdXRpdmVMaW5lQ291bnQgPSAwO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChsaW5lID09IFwiXCIpIHtcblx0XHRcdFx0XHRuZXdDb25zZWN1dGl2ZUxpbmVDb3VudCsrO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdG5ld0NvbnNlY3V0aXZlTGluZUNvdW50ID0gMDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAobGluZSA9PSBcIlwiICYmIG5ld0NvbnNlY3V0aXZlTGluZUNvdW50ID4gMSkge1xuXHRcdFx0XHRcdC8vIGRvIG5vdGhpbmdcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRsZXQgbW9kaWZpZWRMaW5lID0gbGluZSA9PSBcIi0tLVwiID8gXCJcIiA6IGxpbmVcblx0XHRcdFx0XHRtb2RpZmllZExpbmUgPSBtb2RpZmllZExpbmUucmVwbGFjZSgvXlx0XHQtIC9nLCBcIlx1MzAwMFx1MzAwMFx1MzAwMFx1MzAwMFx1MjAyMiBcIikucmVwbGFjZSgvXlx0LSAvZywgXCJcdTMwMDBcdTMwMDBcdTIwMjIgXCIpLnJlcGxhY2UoL14tIC8sIFwiXHUyMDIyIFwiKTtcblx0XHRcdFx0XHRtb2RpZmllZExpbmUgPSBtb2RpZmllZExpbmUucmVwbGFjZSgvXlxcWyhbXlxcW1xcXVxcKFxcKV0rKVxcXVxcKFteXFxbXFxdXFwoXFwpXStcXCkvZywgXCIkMVwiKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC5yZXBsYWNlKC9bXiFdXFxbKFteXFxbXFxdXFwoXFwpXSspXFxdXFwoW15cXFtcXF1cXChcXCldK1xcKS9nLCBcIiQxXCIpXG5cdFx0XHRcdFx0bW9kaWZpZWRMaW5lID0gbW9kaWZpZWRMaW5lLnJlcGxhY2UoLyFcXFsoW15cXFtcXF1cXChcXCldKylcXF1cXCgoW15cXFtcXF1cXChcXCldKylcXCkvZywgXCIkMlwiKVxuXHRcdFx0XHRcdG1vZGlmaWVkTGluZSA9IG1vZGlmaWVkTGluZS5yZXBsYWNlKC9cXCpcXCovZ20sIFwiXCIpXG5cdFx0XHRcdFx0dGV4dCA9IHRleHQgKyBtb2RpZmllZExpbmUgKyBcIlxcblwiXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KTtcblx0XHRcblx0XHR0ZXh0ID0gdGV4dC5yZXBsYWNlKC9cdUQ4M0VcdURERjVbIF0rKC4qKS9nLCBoZWFkZXJJY29uICsgXCJcdTMwMTAkMVx1MzAxMVwiKVxuXHRcdHRleHQgPSBhZGRpdGlvblJlcGxhY2VGbih0ZXh0KVxuXHRcdC8vIHRleHQgPSB0ZXh0LnJlcGxhY2UoL15cdFx0LSAvZywgXCJcdTMwMDBcdTMwMDBcdTIwMjIgXCIpLnJlcGxhY2UoL15cdC0gL2csIFwiXHUzMDAwXHUyMDIyIFwiKS5yZXBsYWNlKC9eLSAvLCBcIlx1MjAyMiBcIik7XG5cdFx0Ly90ZXh0ID0gdGV4dC5yZXBsYWNlKC9bXFxuXFxyXXszLH0oW15cXG5cXHJdK1x1MzAwMltcXG5cXHJdKS9nbSwgYCR7cGFyYWdyYXBoU2VwYXJhdG9yfSQxYCk7XG5cdFx0Ly90ZXh0ID0gdGV4dC5yZXBsYWNlKC9bXFxuXFxyXXszLH0oW15cXG5cXHJdK1x1RkYxQVtcXG5cXHJdKS9nbSwgYCR7cGFyYWdyYXBoU2VwYXJhdG9yfSQxYCk7XG5cdFx0Ly90ZXh0ID0gdGV4dC5yZXBsYWNlKC9bXFxuXFxyXXszLH0oaHR0cFteXFxuXFxyXStbXFxuXFxyXSkvZ20sIGAke3BhcmFncmFwaFNlcGFyYXRvcn0kMWApO1xuXHRcdHRleHQgPSB0ZXh0LnJlcGxhY2UoL1tcXG5cXHJdezMsfS9nbSwgYCR7cGFyYWdyYXBoU2VwYXJhdG9yfVx1MjU4RGApO1xuXG5cdFx0dGV4dCA9IHRleHQucmVwbGFjZShcIlxcblx1MTE3M1x1MTE3M1x1MTE3M1x1MTE3M1x1MTE3M1x1MTE3M1x1MTE3M1x1MTE3M1x1MTE3M1x1MTE3M1x1MTE3M1x1MTE3M1x1MTE3M1x1MTE3M1x1MTE3M1x1MTE3M1x1MTE3M1x1MTE3M1x1MTE3M1x1MTE3M1x1MTE3M1x1MTE3M1xcblxcblx1MjU4RFxcblwiLCBcIlwiKSAvLyByZW1vdmUgZW1wdHkgbGluZVxuXG5cdFx0bGV0IHRleHQyID0gXCJcIlxuXG5cdFx0dGV4dC5zcGxpdChcIlxcblwiKS5mb3JFYWNoKGxpbmUgPT4ge1xuXHRcdFx0dmFyIGwgPSBcIlwiXG5cblx0XHRcdGlmIChsaW5lLmVuZHNXaXRoKFwiXHUzMDAyXCIpIHx8IGxpbmUuZW5kc1dpdGgoXCJcdUZGMUFcIikgfHwgbGluZS5lbmRzV2l0aChcIlx1RkY1RVwiKSB8fCBsaW5lLmVuZHNXaXRoKFwiXHVGRjAxXCIpIHx8IGxpbmUuc3RhcnRzV2l0aChcIlx1MjU4RGh0dHBcIikgfHwgbGluZS5zdGFydHNXaXRoKFwiXHUyNThEI1wiKSB8fCBsaW5lID09IFwiXHUyNThEXCIpIHtcblx0XHRcdFx0bCA9IGxpbmUucmVwbGFjZSgvXlx1MjU4RC9nbSwgXCJcIilcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGwgPSBsaW5lXG5cdFx0XHR9XG5cdFx0XHR0ZXh0MiA9IHRleHQyICsgbCArIFwiXFxuXCJcblx0XHR9KVxuXG5cdFx0dGV4dDIgPSB0ZXh0Mi5yZXBsYWNlKFwiXFxuXFxuXFxuXFxuXCIsIFwiXCIpIC8vIHJlbW92ZSBlbXB0eSBsaW5lXG5cdFx0dGV4dDIgPSB0ZXh0Mi5yZXBsYWNlKFwiXFxuXHUxMTczXHUxMTczXHUxMTczXHUxMTczXHUxMTczXHUxMTczXHUxMTczXHUxMTczXHUxMTczXHUxMTczXHUxMTczXHUxMTczXHUxMTczXHUxMTczXHUxMTczXHUxMTczXHUxMTczXHUxMTczXHUxMTczXHUxMTczXHUxMTczXHUxMTczXFxuXFxuXFxuXCIsIFwiXCIpIC8vIHJlbW92ZSBlbXB0eSBsaW5lXG5cdFx0dGV4dDIgPSB0ZXh0Mi5yZXBsYWNlKC9cXG5cXG4jIyBPcGluaW9uIGZyb20gQ2hhdEdQVFxcOihbXFxuXSouKikqJC8sIFwiXCIpXG5cdFx0dGV4dDIgPSB0ZXh0Mi5yZXBsYWNlKC8jIyBSZWZlcmVuY2VzXFw6KFtcXG5dKi4qKSokLywgXCJcIik7XG5cdFx0dGV4dDIgPSB0ZXh0Mi5yZXBsYWNlKC9cXG4rJC8sIFwiXCIpXG5cblx0XHRyZXR1cm4gdGV4dDJcblx0fVxuXG5cdGdldFRocmVhZFNlZ21lbnQoZWRpdG9yOiBFZGl0b3IpIDogc3RyaW5nIHtcblx0XHRsZXQgY3Vyc29yID0gZWRpdG9yLmdldEN1cnNvcigpO1xuXHRcdGxldCBsaW5lID0gY3Vyc29yLmxpbmU7XG5cdFx0bGV0IGFib3ZlID0gbGluZTtcblx0XHRsZXQgYmVsb3cgPSBsaW5lO1xuXHRcdC8vIGZpcnN0IGdldCBhYm92ZVxuXHRcdFxuXHRcdHdoaWxlIChhYm92ZSA+PSAwKSB7XG5cdFx0XHRsZXQgbCA9IGVkaXRvci5nZXRMaW5lKGFib3ZlKTtcblx0XHRcdGlmIChsID09ICctLS0nKSB7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0YWJvdmUtLTtcblx0XHR9XG5cdFx0aWYgKGVkaXRvci5nZXRMaW5lKGFib3ZlKSA9PSAnLS0tJykge1xuXHRcdFx0YWJvdmUrKztcblx0XHR9XG5cdFx0d2hpbGUodHJ1ZSkge1xuXHRcdFx0aWYgKGVkaXRvci5nZXRMaW5lKGFib3ZlKSA9PSAnJykge1xuXHRcdFx0XHRhYm92ZSsrO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gdGhlbiBnZXQgYmVsb3dcblx0XHR3aGlsZSAoYmVsb3cgPCBlZGl0b3IubGluZUNvdW50KCkpIHtcblx0XHRcdGxldCBsID0gZWRpdG9yLmdldExpbmUoYmVsb3cpO1xuXHRcdFx0aWYgKGwgPT0gJy0tLScpIHtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRiZWxvdysrO1xuXHRcdH1cblx0XHRpZiAoZWRpdG9yLmdldExpbmUoYmVsb3cpID09ICctLS0nKSB7XG5cdFx0XHRiZWxvdy0tO1xuXHRcdH1cblxuXHRcdHdoaWxlKHRydWUpIHtcblx0XHRcdGlmIChlZGl0b3IuZ2V0TGluZShiZWxvdykgPT0gJycpIHtcblx0XHRcdFx0YmVsb3ctLTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIHRoZW4gcHV0IHRoZW0gdG8gbGluZVxuXG5cdFx0bGV0IHRleHQgPSBcIlwiO1xuXHRcdEFycmF5LmZyb20oQXJyYXkoYmVsb3cgLSBhYm92ZSArIDEpLmtleXMoKSkuZm9yRWFjaChpID0+IHtcblx0XHRcdGNvbnN0IGxpbmUgPSBlZGl0b3IuZ2V0TGluZShpICsgYWJvdmUpXG5cdFx0XHRpZiAoIWxpbmUudHJpbSgpLnN0YXJ0c1dpdGgoXCIlJVwiKSB8fCAhbGluZS50cmltKCkuZW5kc1dpdGgoXCIlJVwiKSkge1xuXHRcdFx0XHRsZXQgbW9kaWZpZWRMaW5lID0gZWRpdG9yLmdldExpbmUoaSArIGFib3ZlKVxuXHRcdFx0XHRtb2RpZmllZExpbmUgPSBtb2RpZmllZExpbmUucmVwbGFjZSgvXlxcWyhbXlxcW1xcXVxcKFxcKV0rKVxcXVxcKFteXFxbXFxdXFwoXFwpXStcXCkvZywgXCIkMVwiKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQgICAucmVwbGFjZSgvW14hXVxcWyhbXlxcW1xcXVxcKFxcKV0rKVxcXVxcKFteXFxbXFxdXFwoXFwpXStcXCkvZywgXCIkMVwiKVxuXHRcdFx0XHR0ZXh0ID0gdGV4dCArIG1vZGlmaWVkTGluZSArIFwiXFxuXCJcblx0XHRcdH1cblx0XHR9KVxuXHRcdHRleHQgPSB0ZXh0LnJlcGxhY2UoL1xcbiskLywgXCJcIilcblx0XHRyZXR1cm4gdGV4dFxuXHR9XG5cblx0Z2V0U2VnbWVudChlZGl0b3I6IEVkaXRvcikgOiBzdHJpbmcge1xuXHRcdGxldCBjdXJzb3IgPSBlZGl0b3IuZ2V0Q3Vyc29yKCk7XG5cdFx0bGV0IGxpbmUgPSBjdXJzb3IubGluZTtcblx0XHRsZXQgYWJvdmUgPSBsaW5lO1xuXHRcdGxldCBiZWxvdyA9IGxpbmU7XG5cdFx0Ly8gZmlyc3QgZ2V0IGFib3ZlXG5cdFx0XG5cdFx0d2hpbGUgKGFib3ZlID49IDApIHtcblx0XHRcdGxldCBsID0gZWRpdG9yLmdldExpbmUoYWJvdmUpO1xuXHRcdFx0aWYgKGwgPT0gJy0tLScpIHtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRhYm92ZS0tO1xuXHRcdH1cblx0XHRpZiAoZWRpdG9yLmdldExpbmUoYWJvdmUpID09ICctLS0nKSB7XG5cdFx0XHRhYm92ZSsrO1xuXHRcdH1cblx0XHR3aGlsZSh0cnVlKSB7XG5cdFx0XHRpZiAoZWRpdG9yLmdldExpbmUoYWJvdmUpID09ICcnKSB7XG5cdFx0XHRcdGFib3ZlKys7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyB0aGVuIGdldCBiZWxvd1xuXHRcdHdoaWxlIChiZWxvdyA8IGVkaXRvci5saW5lQ291bnQoKSkge1xuXHRcdFx0bGV0IGwgPSBlZGl0b3IuZ2V0TGluZShiZWxvdyk7XG5cdFx0XHRpZiAobCA9PSAnLS0tJykge1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdGJlbG93Kys7XG5cdFx0fVxuXHRcdGlmIChlZGl0b3IuZ2V0TGluZShiZWxvdykgPT0gJy0tLScpIHtcblx0XHRcdGJlbG93LS07XG5cdFx0fVxuXG5cdFx0d2hpbGUodHJ1ZSkge1xuXHRcdFx0aWYgKGVkaXRvci5nZXRMaW5lKGJlbG93KSA9PSAnJykge1xuXHRcdFx0XHRiZWxvdy0tO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gdGhlbiBwdXQgdGhlbSB0byBsaW5lXG5cblx0XHRsZXQgdGV4dCA9IFwiXCI7XG5cdFx0QXJyYXkuZnJvbShBcnJheShiZWxvdyAtIGFib3ZlICsgMSkua2V5cygpKS5mb3JFYWNoKGkgPT4ge1xuXHRcdFx0Y29uc3QgbGluZSA9IGVkaXRvci5nZXRMaW5lKGkgKyBhYm92ZSlcblx0XHRcdHRleHQgPSB0ZXh0ICsgbGluZSArIFwiXFxuXCJcblx0XHR9KVxuXHRcdHRleHQgPSB0ZXh0LnJlcGxhY2UoL1xcbiskLywgXCJcIilcblx0XHRyZXR1cm4gdGV4dFxuXHR9XG5cblx0Z2V0VHdpdHRlclNlZ21lbnQoZWRpdG9yOiBFZGl0b3IpIDogc3RyaW5nIHtcblx0XHRsZXQgY3Vyc29yID0gZWRpdG9yLmdldEN1cnNvcigpO1xuXHRcdGxldCBsaW5lID0gY3Vyc29yLmxpbmU7XG5cdFx0bGV0IGFib3ZlID0gbGluZTtcblx0XHRsZXQgYmVsb3cgPSBsaW5lO1xuXHRcdC8vIGZpcnN0IGdldCBhYm92ZVxuXHRcdFxuXHRcdHdoaWxlIChhYm92ZSA+PSAwKSB7XG5cdFx0XHRsZXQgbCA9IGVkaXRvci5nZXRMaW5lKGFib3ZlKTtcblx0XHRcdGlmIChsID09ICctLS0nKSB7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0YWJvdmUtLTtcblx0XHR9XG5cdFx0aWYgKGVkaXRvci5nZXRMaW5lKGFib3ZlKSA9PSAnLS0tJykge1xuXHRcdFx0YWJvdmUrKztcblx0XHR9XG5cdFx0d2hpbGUodHJ1ZSkge1xuXHRcdFx0aWYgKGVkaXRvci5nZXRMaW5lKGFib3ZlKSA9PSAnJykge1xuXHRcdFx0XHRhYm92ZSsrO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gdGhlbiBnZXQgYmVsb3dcblx0XHR3aGlsZSAoYmVsb3cgPCBlZGl0b3IubGluZUNvdW50KCkpIHtcblx0XHRcdGxldCBsID0gZWRpdG9yLmdldExpbmUoYmVsb3cpO1xuXHRcdFx0aWYgKGwgPT0gJy0tLScpIHtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRiZWxvdysrO1xuXHRcdH1cblx0XHRpZiAoZWRpdG9yLmdldExpbmUoYmVsb3cpID09ICctLS0nKSB7XG5cdFx0XHRiZWxvdy0tO1xuXHRcdH1cblxuXHRcdHdoaWxlKHRydWUpIHtcblx0XHRcdGlmIChlZGl0b3IuZ2V0TGluZShiZWxvdykgPT0gJycpIHtcblx0XHRcdFx0YmVsb3ctLTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIHRoZW4gcHV0IHRoZW0gdG8gbGluZVxuXG5cdFx0bGV0IHRleHQgPSBcIlwiO1xuXHRcdEFycmF5LmZyb20oQXJyYXkoYmVsb3cgLSBhYm92ZSArIDEpLmtleXMoKSkuZm9yRWFjaChpID0+IHtcblx0XHRcdGNvbnN0IGxpbmUgPSBlZGl0b3IuZ2V0TGluZShpICsgYWJvdmUpXG5cdFx0XHRpZiAoIWxpbmUudHJpbSgpLnN0YXJ0c1dpdGgoXCIlJVwiKSB8fCAhbGluZS50cmltKCkuZW5kc1dpdGgoXCIlJVwiKSkge1xuXHRcdFx0XHRsZXQgbW9kaWZpZWRMaW5lID0gZWRpdG9yLmdldExpbmUoaSArIGFib3ZlKVxuXHRcdFx0XHRpZiAoIS9cXGQrXFwvXFxkKyAqXHUzMDEwLipcdTMwMTEvLnRlc3QobW9kaWZpZWRMaW5lKSkge1xuXHRcdFx0XHRcdG1vZGlmaWVkTGluZSA9IG1vZGlmaWVkTGluZS5yZXBsYWNlKC9eXFxbKFteXFxbXFxdXFwoXFwpXSspXFxdXFwoW15cXFtcXF1cXChcXCldK1xcKS9nLCBcIiQxXCIpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0LnJlcGxhY2UoL1teIV1cXFsoW15cXFtcXF1cXChcXCldKylcXF1cXChbXlxcW1xcXVxcKFxcKV0rXFwpL2csIFwiJDFcIilcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQucmVwbGFjZSgvaHR0cHNbXlxcbl0rXFwuanBlZy9nLCBcIlwiKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC5yZXBsYWNlKC9cdUZGMUYoW15cdTMwMTFcdTMwMERcXG5dKS9nLCBcIlx1RkYxRlxcblxcbiQxXCIpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0LnJlcGxhY2UoL1x1MzAwMihbXlx1MzAxMVx1MzAwRFxcbl0pL2csIFwiXHUzMDAyXFxuXFxuJDFcIilcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQucmVwbGFjZSgvXHVGRjAxKFteXHUzMDExXHUzMDBEXFxuXSkvZywgXCJcdUZGMDFcXG5cXG4kMVwiKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC5yZXBsYWNlKC9cdUZGNUUoW15cdTMwMTFcdTMwMERcXG5dKS9nLCBcIlx1RkY1RVxcblxcbiQxXCIpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0LnJlcGxhY2UoL15cXHMrJC8sIFwiXCIpXG5cdFx0XHRcdH1cblx0XHRcdFx0dGV4dCA9IHRleHQgKyBtb2RpZmllZExpbmUgKyBcIlxcblwiXG5cdFx0XHR9XG5cdFx0fSlcblx0XHR0ZXh0ID0gdGV4dC5yZXBsYWNlKC9cXG4rJC8sIFwiXCIpXG5cdFx0cmV0dXJuIHRleHRcblx0fVxuXG5cdGdldFRocmVhZHNTZWdtZW50KGVkaXRvcjogRWRpdG9yKSA6IHN0cmluZyB7XG5cdFx0bGV0IGN1cnNvciA9IGVkaXRvci5nZXRDdXJzb3IoKTtcblx0XHRsZXQgbGluZSA9IGN1cnNvci5saW5lO1xuXHRcdGxldCBhYm92ZSA9IGxpbmU7XG5cdFx0bGV0IGJlbG93ID0gbGluZTtcblx0XHQvLyBmaXJzdCBnZXQgYWJvdmVcblx0XHRcblx0XHR3aGlsZSAoYWJvdmUgPj0gMCkge1xuXHRcdFx0bGV0IGwgPSBlZGl0b3IuZ2V0TGluZShhYm92ZSk7XG5cdFx0XHRpZiAobCA9PSAnLS0tJykge1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdGFib3ZlLS07XG5cdFx0fVxuXHRcdGlmIChlZGl0b3IuZ2V0TGluZShhYm92ZSkgPT0gJy0tLScpIHtcblx0XHRcdGFib3ZlKys7XG5cdFx0fVxuXHRcdHdoaWxlKHRydWUpIHtcblx0XHRcdGlmIChlZGl0b3IuZ2V0TGluZShhYm92ZSkgPT0gJycpIHtcblx0XHRcdFx0YWJvdmUrKztcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIHRoZW4gZ2V0IGJlbG93XG5cdFx0d2hpbGUgKGJlbG93IDwgZWRpdG9yLmxpbmVDb3VudCgpKSB7XG5cdFx0XHRsZXQgbCA9IGVkaXRvci5nZXRMaW5lKGJlbG93KTtcblx0XHRcdGlmIChsID09ICctLS0nKSB7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0YmVsb3crKztcblx0XHR9XG5cdFx0aWYgKGVkaXRvci5nZXRMaW5lKGJlbG93KSA9PSAnLS0tJykge1xuXHRcdFx0YmVsb3ctLTtcblx0XHR9XG5cblx0XHR3aGlsZSh0cnVlKSB7XG5cdFx0XHRpZiAoZWRpdG9yLmdldExpbmUoYmVsb3cpID09ICcnKSB7XG5cdFx0XHRcdGJlbG93LS07XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyB0aGVuIHB1dCB0aGVtIHRvIGxpbmVcblxuXHRcdGxldCB0ZXh0ID0gXCJcIjtcblx0XHRBcnJheS5mcm9tKEFycmF5KGJlbG93IC0gYWJvdmUgKyAxKS5rZXlzKCkpLmZvckVhY2goaSA9PiB7XG5cdFx0XHRjb25zdCBsaW5lID0gZWRpdG9yLmdldExpbmUoaSArIGFib3ZlKVxuXHRcdFx0aWYgKCFsaW5lLnRyaW0oKS5zdGFydHNXaXRoKFwiJSVcIikgfHwgIWxpbmUudHJpbSgpLmVuZHNXaXRoKFwiJSVcIikpIHtcblx0XHRcdFx0bGV0IG1vZGlmaWVkTGluZSA9IGVkaXRvci5nZXRMaW5lKGkgKyBhYm92ZSlcblx0XHRcdFx0aWYgKCEvXFxkK1xcL1xcZCsgKlx1MzAxMC4qXHUzMDExLy50ZXN0KG1vZGlmaWVkTGluZSkpIHtcblx0XHRcdFx0XHRtb2RpZmllZExpbmUgPSBtb2RpZmllZExpbmUucmVwbGFjZSgvXHVEODNFXHVEREY1WyBdKyguKikvZywgXCJcdTMwMTAkMVx1MzAxMVwiKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC5yZXBsYWNlKC9eXFxbKFteXFxbXFxdXFwoXFwpXSspXFxdXFwoW15cXFtcXF1cXChcXCldK1xcKS9nLCBcIiQxXCIpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0LnJlcGxhY2UoL1teIV1cXFsoW15cXFtcXF1cXChcXCldKylcXF1cXChbXlxcW1xcXVxcKFxcKV0rXFwpL2csIFwiJDFcIilcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQucmVwbGFjZSgvIVxcWy4qXFxdXFwoaHR0cHNbXlxcbl0rXFwuanBlZ1xcKS9nLCBcIlwiKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC5yZXBsYWNlKC9odHRwc1teXFxuXStcXC5qcGVnL2csIFwiXCIpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0LnJlcGxhY2UoL1x1RkYxRihbXlx1MzAxMVx1MzAwRFxcbl0pL2csIFwiXHVGRjFGXFxuXFxuJDFcIilcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQucmVwbGFjZSgvXHUzMDAyKFteXHUzMDExXHUzMDBEXFxuXSkvZywgXCJcdTMwMDJcXG5cXG4kMVwiKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC5yZXBsYWNlKC9cdUZGMDEoW15cdTMwMTFcdTMwMERcXG5dKS9nLCBcIlx1RkYwMVxcblxcbiQxXCIpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0LnJlcGxhY2UoL1x1RkY1RShbXlx1MzAxMVx1MzAwRFxcbl0pL2csIFwiXHVGRjVFXFxuXFxuJDFcIilcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQucmVwbGFjZSgvXlxccyskLywgXCJcIilcblx0XHRcdFx0fVxuXHRcdFx0XHR0ZXh0ID0gdGV4dCArIG1vZGlmaWVkTGluZSArIFwiXFxuXCJcblx0XHRcdH1cblx0XHR9KVxuXHRcdHRleHQgPSB0ZXh0LnJlcGxhY2UoL1xcbiskLywgXCJcIilcblx0XHRyZXR1cm4gdGV4dFxuXHR9XG5cblxuXHRhc3luYyBhZGQzRGF5c0FjdGlvbk5vdGVDb250ZW50KHZhdWx0OiBWYXVsdCkge1xuXHRcdGNvbnN0IHNjaGVkdWxlTm90ZVdpdGhvdXRNZCA9IFwiRC9RdWVyeSBTY2hlZHVsZSBhbmQgQWN0aW9ucyBuZXh0IDMgZGF5c1wiXG5cdFx0Y29uc3Qgc2NoZWR1bGVOb3RlID0gYCR7c2NoZWR1bGVOb3RlV2l0aG91dE1kfS5tZGBcdFx0XHRcdFxuXHRcdGlmICh2YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgoc2NoZWR1bGVOb3RlKSA9PSBudWxsKSB7XG5cdFx0XHRhd2FpdCB2YXVsdC5jcmVhdGUoc2NoZWR1bGVOb3RlLCBcIlwiKTtcblx0XHR9XG5cdFx0bGV0IG5vdGVDb250ZW50ID0gJ1tbUXVlcnkgU2NoZWR1bGUgYW5kIEFjdGlvbnMgbmV4dCAzIGRheXNdXVxcbidcblx0XHRjb25zdCBleGNsdWRlTm90ZXMgPSBbc2NoZWR1bGVOb3RlV2l0aG91dE1kLCBcIkQvU2NoZWR1bGluZ1wiXTtcblx0XHRBcnJheS5mcm9tKEFycmF5KDMpLmtleXMoKSkuZm9yRWFjaChpID0+IG5vdGVDb250ZW50ICs9IHRoaXMuZ2V0UXVlcnlEYXRlQW5kQWN0aW9uU3RyaW5nKGksIGV4Y2x1ZGVOb3RlcykpO1xuXHRcdGNvbnN0IG90aGVyRGF5cyA9IHRoaXMuZ2V0UXVlcnlBY3Rpb25zVGhpc1dlZWsoMyk7XG5cdFx0bm90ZUNvbnRlbnQgPSBub3RlQ29udGVudCArIGAjIyBubiAvIHduXFxuXFxgXFxgXFxgcXVlcnlcXG50YWc6I25uIE9SIHRhZzojd24ke290aGVyRGF5c31cXG5cXGBcXGBcXGBcXG5cXG4jIyB0dFxcblxcYFxcYFxcYHF1ZXJ5XFxudGFnOiN0dFxcblxcYFxcYFxcYFxcblxcbmBcblx0XHRub3RlQ29udGVudCA9IG5vdGVDb250ZW50ICsgdGhpcy5nZXRRdWVyeUZ1dHVyZURheXNUaGlzV2VlayhcIkZ1dHVyZSBEYXRlc1wiLCAzLCA2LCBleGNsdWRlTm90ZXMpXG5cdFx0bm90ZUNvbnRlbnQgPSBub3RlQ29udGVudCArIHRoaXMuZ2V0UXVlcnlOZXh0Mk1vbnRoU3RyaW5nKGV4Y2x1ZGVOb3Rlcylcblx0XHRub3RlQ29udGVudCA9IG5vdGVDb250ZW50ICsgdGhpcy5nZXRRdWVyeUZ1dHVyZURheXNUaGlzV2VlayhcIlBhc3QgRGF0ZXNcIiwgLTcsIC0xLCBleGNsdWRlTm90ZXMpXG5cdFx0Ly8gbm90ZUNvbnRlbnQgPSBub3RlQ29udGVudCArIGBcXG5cXG5bW1F1ZXJ5IFNjaGVkdWxlIGFuZCBBY3Rpb25zIG5leHQgMyBkYXlzXV1gXG5cdFx0dmF1bHQubW9kaWZ5KHZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aChzY2hlZHVsZU5vdGUpIGFzIFRGaWxlLCBub3RlQ29udGVudCk7XG5cdH1cblxuXHRhc3luYyBhZGRBY3Rpb25Ob3RlQ29udGVudCh2YXVsdDogVmF1bHQsIGZvbGRlck5hbWU6IFN0cmluZywgbm90ZVRpdGxlV2l0aG91dE1kOiBTdHJpbmcsIHNjaGVkdWxlTm90ZVRpdGxlV2l0aG91dE1kOiBTdHJpbmcsIG5Pclc6IFN0cmluZykge1xuXHRcdGNvbnN0IG5vd0FjdGlvbk5vdGVXaXRob3V0TWQgPSBgJHtmb2xkZXJOYW1lfS8ke25vdGVUaXRsZVdpdGhvdXRNZH1gXG5cdFx0Y29uc3Qgbm93QWN0aW9uTm90ZSA9IGAke25vd0FjdGlvbk5vdGVXaXRob3V0TWR9Lm1kYFx0XHRcdFx0XG5cdFx0aWYgKHZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aChub3dBY3Rpb25Ob3RlKSA9PSBudWxsKSB7XG5cdFx0XHRhd2FpdCB2YXVsdC5jcmVhdGUobm93QWN0aW9uTm90ZSwgXCJcIik7XG5cdFx0fVxuXHRcdGxldCBub3dBY3Rpb25Ob3RlQ29udGVudCA9ICcnXG5cdFx0QXJyYXkuZnJvbShBcnJheSgyKS5rZXlzKCkpLmZvckVhY2goaSA9PiBub3dBY3Rpb25Ob3RlQ29udGVudCArPSB0aGlzLmdldFF1ZXJ5QWN0aW9uU3RyaW5nKGksIG5PclcpKTtcblx0XHRub3dBY3Rpb25Ob3RlQ29udGVudCArPSBgXFxgXFxgXFxgcXVlcnlcXG50YWc6IyR7bk9yV310XFxuXFxgXFxgXFxgXFxuYFxuXHRcdG5vd0FjdGlvbk5vdGVDb250ZW50ICs9IGBcXGBcXGBcXGBxdWVyeVxcbmBcblx0XHRBcnJheS5mcm9tKEFycmF5KDUpLmtleXMoKSkuZm9yRWFjaChpID0+IG5vd0FjdGlvbk5vdGVDb250ZW50ICs9IHRoaXMuZ2V0UXVlcnlXZWVrRGF5KGkgKyAyLCBuT3JXKSk7XG5cdFx0bm93QWN0aW9uTm90ZUNvbnRlbnQgKz0gYHRhZzojJHtuT3JXfW5cXG5cXGBcXGBcXGBcXG5gXG5cdFx0bm93QWN0aW9uTm90ZUNvbnRlbnQgKz0gYFNjaGVkdWxpbmc6IFtbJHtzY2hlZHVsZU5vdGVUaXRsZVdpdGhvdXRNZH1dXVxcbmBcblx0XHRub3dBY3Rpb25Ob3RlQ29udGVudCArPSBgW1ske25vdGVUaXRsZVdpdGhvdXRNZH1dXVxcbmBcblxuXHRcdHZhdWx0Lm1vZGlmeSh2YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgobm93QWN0aW9uTm90ZSkgYXMgVEZpbGUsIG5vd0FjdGlvbk5vdGVDb250ZW50KTtcblx0fVxuXG5cdGdldFF1ZXJ5RGF0ZUFuZEFjdGlvblN0cmluZyhhZGREYXk6IG51bWJlciwgZXhjbHVkZU5vdGVzOiBTdHJpbmdbXSk6IHN0cmluZyB7XG5cdFx0Y29uc3QgZGF0ZU1vbWVudCA9IG1vbWVudCgpLmFkZChhZGREYXksICdkJyk7XG5cdFx0Y29uc3QgZGF0ZVlZWVlNTUREID0gZGF0ZU1vbWVudC5mb3JtYXQoJ1lZWVlNTUREJyk7XG5cdFx0Y29uc3QgZGF0ZUVhY2hZWUREID0gJ1xcXFxkXFxcXGRcXFxcZFxcXFxkJyArIGRhdGVNb21lbnQuZm9ybWF0KCdNTUREJyk7XG5cdFx0Y29uc3QgZGF0ZUVhY2hERCA9ICdcXFxcZFxcXFxkXFxcXGRcXFxcZFxcXFxkXFxcXGQnICsgZGF0ZU1vbWVudC5mb3JtYXQoJ0REJyk7XG5cdFx0Y29uc3QgZGF5T2ZXZWVrID0gZGF0ZU1vbWVudC5mb3JtYXQoJ0UnKTtcblx0XHRjb25zdCBkYXlPZldlZWtMb25nID0gZGF0ZU1vbWVudC5mb3JtYXQoJ2RkZCcpO1xuXHRcdGNvbnN0IGV4Y2x1ZGVOb3RlU3RyID0gZXhjbHVkZU5vdGVzLm1hcChleGNsdWRlTm90ZSA9PiBgLXBhdGg6XCIke2V4Y2x1ZGVOb3RlfVwiIGApLmpvaW4oXCJcIilcblx0XHRyZXR1cm4gYCMjICR7ZGF0ZVlZWVlNTUREfSAke2RheU9mV2Vla0xvbmd9XFxuXFxgXFxgXFxgcXVlcnlcXG4oXCIgJHtkYXRlWVlZWU1NRER9XCIgT1IgXCIke2RhdGVZWVlZTU1ERH0gXCIgT1IgJHtkYXRlRWFjaFlZRER9IE9SICR7ZGF0ZUVhY2hERH0gT1IgdGFnOiNuJHtkYXlPZldlZWt9IE9SIHRhZzojdyR7ZGF5T2ZXZWVrfSkgJHtleGNsdWRlTm90ZVN0cn0tYmxvY2s6KHF1ZXJ5KVxcblxcYFxcYFxcYFxcblxcbmBcblx0fVxuXG5cdGdldFF1ZXJ5QWN0aW9uc1RoaXNXZWVrKGV4Y2x1ZGVOdW1EYXlzOiBOdW1iZXIpOiBzdHJpbmcge1xuXHRcdGxldCBleGNsdWRlcyA6IG51bWJlcltdID0gW11cblx0XHRsZXQgaW5jbHVkZXMgOiBudW1iZXJbXSA9IFsxLCAyLCAzLCA0LCA1LCA2LCA3XVxuXHRcdFxuXHRcdEFycmF5LmZyb20oQXJyYXkoZXhjbHVkZU51bURheXMpLmtleXMoKSkuZm9yRWFjaChpID0+IHtcblx0XHRcdGNvbnN0IGRhdGVNb21lbnQgPSBtb21lbnQoKS5hZGQoaSwgJ2QnKTtcblx0XHRcdGNvbnN0IGRheU9mV2VlayA9IHBhcnNlSW50KGRhdGVNb21lbnQuZm9ybWF0KCdFJykpO1xuXHRcdFx0ZXhjbHVkZXMucHVzaChkYXlPZldlZWspXG5cdFx0fSlcblx0XHRsZXQgYWFhID0gaW5jbHVkZXMuZmlsdGVyKGkgPT4ge1xuXHRcdFx0Zm9yIChjb25zdCBlIG9mIGV4Y2x1ZGVzKVxuXHRcdFx0e1xuXHRcdFx0XHRpZiAoZSA9PSBpKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB0cnVlXG5cdFx0fSlcblx0XHRsZXQgb3V0cHV0ID0gXCJcIlxuXHRcdGFhYS5mb3JFYWNoKGkgPT4gb3V0cHV0ICs9IGAgT1IgdGFnOiNuJHtpfSBPUiB0YWc6I3cke2l9YClcblx0XHRyZXR1cm4gb3V0cHV0XG5cdH1cblxuXHRnZXRRdWVyeUZ1dHVyZURheXNUaGlzV2VlayhoZWFkZXI6IFN0cmluZywgZnJvbTogbnVtYmVyLCB0bzogbnVtYmVyLCBleGNsdWRlTm90ZXM6IFN0cmluZ1tdKTogc3RyaW5nIHtcblx0XHRsZXQgaW5jbHVkZXMgPSBbXVxuXHRcdGZvciAobGV0IGkgPSBmcm9tOyBpIDw9IHRvOyBpKyspIHtcblx0XHRcdGxldCBkYXRlTW9tZW50ID0gbW9tZW50KCkuYWRkKGksICdkJyk7XG5cdFx0XHRpbmNsdWRlcy5wdXNoKGRhdGVNb21lbnQpXG5cdFx0fVxuXHRcdGxldCBvdXRwdXQgPSBgIyMgJHtoZWFkZXJ9XFxuXFxgXFxgXFxgcXVlcnlcXG4oYFxuXHRcdGluY2x1ZGVzLmZvckVhY2goaSA9PiB7XG5cdFx0XHRjb25zdCBkYXRlWVlZWU1NREQgPSBpLmZvcm1hdCgnWVlZWU1NREQnKTtcblx0XHRcdGNvbnN0IGRhdGVFYWNoWVlERCA9ICdcXFxcZFxcXFxkXFxcXGRcXFxcZCcgKyBpLmZvcm1hdCgnTU1ERCcpO1xuXHRcdFx0Y29uc3QgZGF0ZUVhY2hERCA9ICdcXFxcZFxcXFxkXFxcXGRcXFxcZFxcXFxkXFxcXGQnICsgaS5mb3JtYXQoJ0REJyk7XG5cdFx0XHRvdXRwdXQgKz0gYFwiICR7ZGF0ZVlZWVlNTUREfVwiIE9SIFwiJHtkYXRlWVlZWU1NRER9IFwiIE9SICR7ZGF0ZUVhY2hZWUREfSBPUiAke2RhdGVFYWNoRER9IE9SIGBcblx0XHR9KVxuXHRcdG91dHB1dCA9IG91dHB1dC5yZXBsYWNlKC8gT1IgJC8sIFwiXCIpXG5cdFx0b3V0cHV0ICs9IFwiKVwiXG5cdFx0Y29uc3QgZXhjbHVkZU5vdGVTdHIgPSBleGNsdWRlTm90ZXMubWFwKGV4Y2x1ZGVOb3RlID0+IGAtcGF0aDpcIiR7ZXhjbHVkZU5vdGV9XCIgYCkuam9pbihcIlwiKVxuXHRcdG91dHB1dCArPSBgICR7ZXhjbHVkZU5vdGVTdHJ9LWJsb2NrOihxdWVyeSlgXG5cdFx0b3V0cHV0ICs9IGBcXG5cXGBcXGBcXGBcXG5cXG5gXG5cdFx0cmV0dXJuIG91dHB1dFxuXHR9XG5cblx0Z2V0UXVlcnlOZXh0Mk1vbnRoU3RyaW5nKGV4Y2x1ZGVOb3RlczogU3RyaW5nW10pOiBzdHJpbmcge1xuXHRcdGNvbnN0IGN1cnJlbnRNb250aFlZWVlNTSA9IG1vbWVudCgpLmZvcm1hdCgnWVlZWU1NJyk7XG5cdFx0Y29uc3QgZGF0ZU1vbWVudCA9IG1vbWVudCgpLmFkZCgxLCAnTScpO1xuXHRcdGNvbnN0IG5leHRNb250aFlZWVlNTSA9IGRhdGVNb21lbnQuZm9ybWF0KCdZWVlZTU0nKTtcblx0XHRjb25zdCBleGNsdWRlTm90ZVN0ciA9IGV4Y2x1ZGVOb3Rlcy5tYXAoZXhjbHVkZU5vdGUgPT4gYC1wYXRoOlwiJHtleGNsdWRlTm90ZX1cIiBgKS5qb2luKFwiXCIpXG5cdFx0cmV0dXJuIGAjIyAke2N1cnJlbnRNb250aFlZWVlNTX0gYW5kICR7bmV4dE1vbnRoWVlZWU1NfVxcblxcYFxcYFxcYHF1ZXJ5XFxuKCR7Y3VycmVudE1vbnRoWVlZWU1NfVxcXFxkXFxcXGQgT1IgJHtuZXh0TW9udGhZWVlZTU19XFxcXGRcXFxcZCAke2V4Y2x1ZGVOb3RlU3RyfS1wYXRoOlwiRC9TY2hlZHVsaW5nXCIgLWJsb2NrOihxdWVyeSlcXG5cXGBcXGBcXGBcXG5cXG5gXG5cdH1cblxuXHRnZXRRdWVyeURhdGVTdHJpbmcoYWRkRGF5OiBudW1iZXIsIGV4Y2x1ZGVOb3RlOiBTdHJpbmcpOiBzdHJpbmcge1xuXHRcdGNvbnN0IGRhdGVNb21lbnQgPSBtb21lbnQoKS5hZGQoYWRkRGF5LCAnZCcpO1xuXHRcdGNvbnN0IGRhdGVZWVlZTU1ERCA9IGRhdGVNb21lbnQuZm9ybWF0KCdZWVlZTU1ERCcpO1xuXHRcdGNvbnN0IGRhdGVFYWNoWVlERCA9ICdcXFxcZFxcXFxkXFxcXGRcXFxcZCcgKyBkYXRlTW9tZW50LmZvcm1hdCgnTU1ERCcpO1xuXHRcdGNvbnN0IGRhdGVFYWNoREQgPSAnXFxcXGRcXFxcZFxcXFxkXFxcXGRcXFxcZFxcXFxkJyArIGRhdGVNb21lbnQuZm9ybWF0KCdERCcpO1xuXHRcdHJldHVybiBgJHtkYXRlWVlZWU1NRER9XFxuXFxgXFxgXFxgcXVlcnlcXG4oJHtkYXRlWVlZWU1NRER9IE9SICR7ZGF0ZUVhY2hZWUREfSBPUiAke2RhdGVFYWNoRER9KSAtcGF0aDpcIiR7ZXhjbHVkZU5vdGV9XCIgLWJsb2NrOihxdWVyeSlcXG5cXGBcXGBcXGBcXG5gXG5cdH1cblxuXHRnZXRRdWVyeUFjdGlvblN0cmluZyhhZGREYXk6IG51bWJlciwgYWN0aW9uVHlwZTogU3RyaW5nKTogc3RyaW5nIHtcblx0XHRjb25zdCBkYXRlTW9tZW50ID0gbW9tZW50KCkuYWRkKGFkZERheSwgJ2QnKTtcblx0XHRjb25zdCBkYXlPZldlZWsgPSBkYXRlTW9tZW50LmZvcm1hdCgnRScpO1xuXHRcdHJldHVybiBgXFxgXFxgXFxgcXVlcnlcXG50YWc6IyR7YWN0aW9uVHlwZX0ke2RheU9mV2Vla31cXG5cXGBcXGBcXGBcXG5gXG5cdH1cblxuXHRnZXRRdWVyeVdlZWtEYXkoYWRkRGF5OiBudW1iZXIsIGFjdGlvblR5cGU6IFN0cmluZyk6IHN0cmluZyB7XG5cdFx0Y29uc3QgZGF0ZU1vbWVudCA9IG1vbWVudCgpLmFkZChhZGREYXksICdkJyk7XG5cdFx0Y29uc3QgZGF5T2ZXZWVrID0gZGF0ZU1vbWVudC5mb3JtYXQoJ0UnKTtcblx0XHRyZXR1cm4gYHRhZzojJHthY3Rpb25UeXBlfSR7ZGF5T2ZXZWVrfSBPUiBgXG5cdH1cblx0ICBcblx0YWRkTmV3TGF0ZXJBY3Rpb25JY29uKHQ6IHN0cmluZykge1xuXHRcdHRoaXMuYWRkT2JzaWRpYW5JY29uKGAke3R9bC1pY29uLW5ld2AsIGAke3R9bGApO1xuXHR9XG5cdCAgXG5cdGFkZEFjdGlvbkljb24odDogc3RyaW5nKSB7XG5cdFx0dGhpcy5hZGRPYnNpZGlhbkljb24oYCR7dH0taWNvbmAsIGAjJHt0fWApO1xuXHR9XG5cblx0YWRkT2JzaWRpYW5JY29uKGljb25OYW1lOiBzdHJpbmcsIGljb25UZXh0OiBzdHJpbmcpIHtcblx0XHRjb25zdCBzdmcgPSBgPHRleHQgc3Ryb2tlPScjMDAwJyB0cmFuc2Zvcm09J21hdHJpeCgyLjc5MTY3IDAgMCAyLjEyNjYzIC0zNC4wNDE3IC0yNS4yMDg0KScgeG1sOnNwYWNlPSdwcmVzZXJ2ZScgdGV4dC1hbmNob3I9J3N0YXJ0JyBmb250LWZhbWlseT0nbW9ub3NwYWNlJyBmb250LXNpemU9JzI0JyB5PSc0NCcgeD0nMTknIHN0cm9rZS13aWR0aD0nMCcgZmlsbD0nY3VycmVudENvbG9yJz4ke2ljb25UZXh0fTwvdGV4dD5gO1xuXHRcdGFkZEljb24oaWNvbk5hbWUsIHN2Zyk7XG5cdH1cblxuXHRhZGROZXdMYXRlckFjdGlvbih0OiBzdHJpbmcpIHtcblx0XHR0aGlzLmFkZENvbW1hbmQoe1xuXHRcdFx0aWQ6IGBhZGQtbmV3LSR7dH0tbGF0ZXItYWN0aW9uYCxcblx0XHRcdG5hbWU6IGBBZGQgJHt0fWwgdGFza2AsXG5cdFx0XHRpY29uOiBgJHt0fWwtaWNvbi1uZXdgLFxuXHRcdFx0ZWRpdG9yQ2FsbGJhY2s6IChlZGl0b3I6IEVkaXRvciwgdmlldzogTWFya2Rvd25WaWV3KSA9PiB7XG5cdFx0XHRcdGNvbnN0IGN1cnNvciA9IGVkaXRvci5nZXRDdXJzb3IoKTtcblx0XHRcdFx0ZWRpdG9yLnJlcGxhY2VSYW5nZShgIyR7dH1sIGAsIGN1cnNvcik7XG5cdFx0XHRcdGN1cnNvci5jaCA9IGN1cnNvci5jaCArIDQ7XG5cdFx0XHRcdGVkaXRvci5zZXRDdXJzb3IoY3Vyc29yKTtcblx0XHRcdH0vKixcblx0XHRcdGhvdGtleXM6IFtcblx0XHRcdFx0e1xuXHRcdFx0XHRcdG1vZGlmaWVyczogW2BDdHJsYCwgYE1ldGFgLCBgU2hpZnRgXSxcblx0XHRcdFx0XHRrZXk6IHQgPT0gJ24nID8gJzEnIDogJzInXG5cdFx0XHRcdH0sXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRtb2RpZmllcnM6IFtgQ3RybGAsIGBBbHRgLCBgU2hpZnRgXSxcblx0XHRcdFx0XHRrZXk6IHQgPT0gJ24nID8gJzEnIDogJzInXG5cdFx0XHRcdH1cblx0XHRcdF0qL1xuXHRcdH0pO1xuXHR9XG5cblx0YWRkQWN0aW9uQ29tbWFuZCh0OiBzdHJpbmcpIHtcblx0XHR0aGlzLmFkZENvbW1hbmQoe1xuXHRcdFx0aWQ6IGB0by13JHt0fS1uJHt0fWAsXG5cdFx0XHRuYW1lOiBgVG8gdyR7dH0gb3IgbiR7dH1gLFxuXHRcdFx0aWNvbjogYCR7dH0taWNvbmAsXG5cdFx0XHRlZGl0b3JDYWxsYmFjazogKGVkaXRvcjogRWRpdG9yLCB2aWV3OiBNYXJrZG93blZpZXcpID0+IHtcblx0XHRcdFx0Y29uc29sZS5sb2coZWRpdG9yLmdldFNlbGVjdGlvbigpKTtcblx0XHRcdFx0Y29uc3QgY3Vyc29yID0gZWRpdG9yLmdldEN1cnNvcigpO1xuXHRcdFx0XHRjb25zdCBsaW5lTnVtYmVyID0gZWRpdG9yLmdldEN1cnNvcigpLmxpbmU7XG5cdFx0XHRcdGNvbnN0IGxpbmUgPSBlZGl0b3IuZ2V0TGluZShsaW5lTnVtYmVyKTtcblx0XHRcdFx0Y29uc3QgcmVwbGFjZWRMaW5lID0gbGluZS5yZXBsYWNlKC8gYVxcL3dcXC8uLywgYCBhL3cvJHt0fWApXG5cdFx0XHRcdCAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvIGFcXC9uXFwvLi8sIGAgYS9uLyR7dH1gKVxuXHRcdFx0XHRcdFx0XHRcdCBcdCBcdCAucmVwbGFjZSgvI3cuIC8sIGAjdyR7dH0gYClcblx0XHRcdFx0XHRcdFx0XHRcdFx0IC5yZXBsYWNlKC8jbi4gLywgYCNuJHt0fSBgKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQgLnJlcGxhY2UoLyN3LiQvLCBgI3cke3R9YClcblx0XHRcdFx0XHRcdFx0XHRcdFx0IC5yZXBsYWNlKC8jbi4kLywgYCNuJHt0fWApXG5cdFx0XHRcdGlmIChsaW5lLmNvbnRhaW5zKGAjbiR7dH0gYCkgfHwgbGluZS5jb250YWlucyhgI3cke3R9IGApKSB7XG5cdFx0XHRcdFx0Y29uc3QgbnQgPSBgI24ke3R9IGBcblx0XHRcdFx0XHRjb25zdCB3dCA9IGAjdyR7dH0gYFxuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGNvbnN0IHJlcGxhY2VMaW5lVG9SZW1vdmVUYWcgPSBsaW5lLnJlcGxhY2UoYCNuJHt0fSBgLCBgYCkucmVwbGFjZShgI3cke3R9IGAsIGBgKVxuXHRcdFx0XHRcdGVkaXRvci5zZXRMaW5lKGxpbmVOdW1iZXIsIHJlcGxhY2VMaW5lVG9SZW1vdmVUYWcpO1xuXHRcdFx0XHRcdC8vIGxldHMgc2F5IFwiI250IFwiIGlzIGF0IDMgKGNoYXIgZm9yICMpXG5cdFx0XHRcdFx0Ly8gaWYgY2ggPD0gMyBubyBuZWVkIHRvIHVwZGF0ZVxuXHRcdFx0XHRcdC8vIGlmIGNoID49IDcgdGhlbiBuZWVkIHRvIC00XG5cdFx0XHRcdFx0Ly8gZWxzZSBjaCA9PSAzXG5cdFx0XHRcdFx0Y29uc3QgbnRJbmRleCA9IGxpbmUuaW5kZXhPZihudClcblx0XHRcdFx0XHRjb25zdCB3dEluZGV4ID0gbGluZS5pbmRleE9mKHd0KVxuXHRcdFx0XHRcdGNvbnN0IGluZGV4ID0gbnRJbmRleCA9PSAtMSA/IHd0SW5kZXggOiBudEluZGV4XG5cdFx0XHRcdFx0Y29uc3QgbmV3Q2ggPSBjdXJzb3IuY2ggPD0gaW5kZXggPyBjdXJzb3IuY2ggOiAoY3Vyc29yLmNoID49IGluZGV4ICsgNCA/IGN1cnNvci5jaCAtIDQgOiBpbmRleClcblx0XHRcdFx0XHRjdXJzb3IuY2ggPSBuZXdDaFxuXHRcdFx0XHRcdGVkaXRvci5zZXRDdXJzb3IoY3Vyc29yKTtcblx0XHRcdFx0fSBlbHNlIGlmIChsaW5lLmNvbnRhaW5zKGAgI24ke3R9YCkgfHwgbGluZS5jb250YWlucyhgICN3JHt0fWApKSB7XG5cdFx0XHRcdFx0Y29uc3QgbnQgPSBgI24ke3R9IGBcblx0XHRcdFx0XHRjb25zdCB3dCA9IGAjdyR7dH0gYFxuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGNvbnN0IHJlcGxhY2VMaW5lVG9SZW1vdmVUYWcgPSBsaW5lLnJlcGxhY2UoYCAjbiR7dH1gLCBgYCkucmVwbGFjZShgICN3JHt0fWAsIGBgKVxuXHRcdFx0XHRcdGVkaXRvci5zZXRMaW5lKGxpbmVOdW1iZXIsIHJlcGxhY2VMaW5lVG9SZW1vdmVUYWcpO1xuXHRcdFx0XHRcdC8vIGxldHMgc2F5IFwiI250IFwiIGlzIGF0IDMgKGNoYXIgZm9yICMpXG5cdFx0XHRcdFx0Ly8gaWYgY2ggPD0gMyBubyBuZWVkIHRvIHVwZGF0ZVxuXHRcdFx0XHRcdC8vIGlmIGNoID49IDcgdGhlbiBuZWVkIHRvIC00XG5cdFx0XHRcdFx0Ly8gZWxzZSBjaCA9PSAzXG5cdFx0XHRcdFx0Y29uc3QgbnRJbmRleCA9IGxpbmUuaW5kZXhPZihudClcblx0XHRcdFx0XHRjb25zdCB3dEluZGV4ID0gbGluZS5pbmRleE9mKHd0KVxuXHRcdFx0XHRcdGNvbnN0IGluZGV4ID0gbnRJbmRleCA9PSAtMSA/IHd0SW5kZXggOiBudEluZGV4XG5cdFx0XHRcdFx0Y29uc3QgbmV3Q2ggPSBjdXJzb3IuY2ggPD0gaW5kZXggPyBjdXJzb3IuY2ggOiAoY3Vyc29yLmNoID49IGluZGV4ICsgNCA/IGN1cnNvci5jaCAtIDQgOiBpbmRleClcblx0XHRcdFx0XHRjdXJzb3IuY2ggPSBuZXdDaFxuXHRcdFx0XHRcdGVkaXRvci5zZXRDdXJzb3IoY3Vyc29yKTtcblx0XHRcdFx0fSBlbHNlIGlmIChsaW5lLmNvbnRhaW5zKGAgYS9uLyR7dH1gKSB8fCBsaW5lLmNvbnRhaW5zKGAgYS93LyR7dH1gKSkge1xuXHRcdFx0XHRcdC8vIGRvIG5vdGhpbmdcblx0XHRcdFx0fSBlbHNlIGlmIChyZXBsYWNlZExpbmUgPT0gbGluZSkgeyAvLyBubyB0YWcsIHRvIGFkZCB0YWdcblx0XHRcdFx0XHRuZXcgQWRkVGFza1RhZ01vZGFsKHRoaXMuYXBwLCBlZGl0b3IsIHQpLm9wZW4oKTtcblx0XHRcdFx0fSBlbHNlIHtcdFx0XHQgXG5cdFx0XHRcdFx0ZWRpdG9yLnNldExpbmUobGluZU51bWJlciwgcmVwbGFjZWRMaW5lKTtcblx0XHRcdFx0XHRlZGl0b3Iuc2V0Q3Vyc29yKGN1cnNvcik7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRob3RrZXlzOiBbXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRtb2RpZmllcnM6IHRoaXMuaXMxVG83KHQpID8gW2BDdHJsYCwgYE1ldGFgXSA6IFtgQ3RybGAsIGBNZXRhYCwgYFNoaWZ0YF0sXG5cdFx0XHRcdFx0a2V5OiBgJHt0fWAsXG5cdFx0XHRcdH0sXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRtb2RpZmllcnM6IHRoaXMuaXMxVG83KHQpID8gW2BDdHJsYCwgYEFsdGBdIDogW2BDdHJsYCwgYEFsdGAsIGBTaGlmdGBdLFxuXHRcdFx0XHRcdGtleTogYCR7dH1gLFxuXHRcdFx0XHR9XG5cdFx0XHRdXG5cdFx0fSk7XG5cdH1cblxuXHRhZGRGb2xsb3dVcENvbW1hbmQodDogc3RyaW5nKSB7XG5cdFx0bGV0IG5hbWUgPSBcIlwiXG5cdFx0aWYgKHQgPT09ICd0Jykge1xuXHRcdFx0bmFtZSA9ICdUbyBUcnknXG5cdFx0fSBlbHNlIGlmICh0ID09PSAnZScpIHtcblx0XHRcdG5hbWUgPSAnVG8gRXhwbG9yZSdcblx0XHR9IGVsc2UgaWYgKHQgPT09ICdtJykge1xuXHRcdFx0bmFtZSA9ICdUbyBNb3ZlJ1xuXHRcdH1cblx0XHR0aGlzLmFkZENvbW1hbmQoe1xuXHRcdFx0aWQ6IGB0by10JHt0fWAsXG5cdFx0XHRuYW1lOiBgVG8gdCR7dH0gJHtuYW1lfWAsXG5cdFx0XHRpY29uOiBgJHt0fS1pY29uYCxcblx0XHRcdGVkaXRvckNhbGxiYWNrOiAoZWRpdG9yOiBFZGl0b3IsIHZpZXc6IE1hcmtkb3duVmlldykgPT4ge1xuXHRcdFx0XHRjb25zb2xlLmxvZyhlZGl0b3IuZ2V0U2VsZWN0aW9uKCkpO1xuXHRcdFx0XHRjb25zdCBjdXJzb3IgPSBlZGl0b3IuZ2V0Q3Vyc29yKCk7XG5cdFx0XHRcdGNvbnN0IGxpbmVOdW1iZXIgPSBlZGl0b3IuZ2V0Q3Vyc29yKCkubGluZTtcblx0XHRcdFx0Y29uc3QgbGluZSA9IGVkaXRvci5nZXRMaW5lKGxpbmVOdW1iZXIpO1xuXHRcdFx0XHRjb25zdCByZXBsYWNlZExpbmUgPSBsaW5lLnJlcGxhY2UoLyN0LiAvLCBgI3Qke3R9IGApXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCAucmVwbGFjZSgvI3QuJC8sIGAjdCR7dH1gKVxuXHRcdFx0XHRpZiAobGluZS5jb250YWlucyhgI3Qke3R9IGApKSB7XG5cdFx0XHRcdFx0Y29uc3QgdHQgPSBgI3Qke3R9IGBcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRjb25zdCByZXBsYWNlTGluZVRvUmVtb3ZlVGFnID0gbGluZS5yZXBsYWNlKGAjdCR7dH0gYCwgYGApXG5cdFx0XHRcdFx0ZWRpdG9yLnNldExpbmUobGluZU51bWJlciwgcmVwbGFjZUxpbmVUb1JlbW92ZVRhZyk7XG5cdFx0XHRcdFx0Ly8gbGV0cyBzYXkgXCIjdHQgXCIgaXMgYXQgMyAoY2hhciBmb3IgIylcblx0XHRcdFx0XHQvLyBpZiBjaCA8PSAzIG5vIG5lZWQgdG8gdXBkYXRlXG5cdFx0XHRcdFx0Ly8gaWYgY2ggPj0gNyB0aGVuIG5lZWQgdG8gLTRcblx0XHRcdFx0XHQvLyBlbHNlIGNoID09IDNcblx0XHRcdFx0XHRjb25zdCB0dEluZGV4ID0gbGluZS5pbmRleE9mKHR0KVxuXHRcdFx0XHRcdGNvbnN0IGluZGV4ID0gdHRJbmRleFxuXHRcdFx0XHRcdGNvbnN0IG5ld0NoID0gY3Vyc29yLmNoIDw9IGluZGV4ID8gY3Vyc29yLmNoIDogKGN1cnNvci5jaCA+PSBpbmRleCArIDQgPyBjdXJzb3IuY2ggLSA0IDogaW5kZXgpXG5cdFx0XHRcdFx0Y3Vyc29yLmNoID0gbmV3Q2hcblx0XHRcdFx0XHRlZGl0b3Iuc2V0Q3Vyc29yKGN1cnNvcik7XG5cdFx0XHRcdH0gZWxzZSBpZiAobGluZS5jb250YWlucyhgICN0JHt0fWApKSB7XG5cdFx0XHRcdFx0Y29uc3QgdHQgPSBgI3Qke3R9IGBcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRjb25zdCByZXBsYWNlTGluZVRvUmVtb3ZlVGFnID0gbGluZS5yZXBsYWNlKGAgI3Qke3R9YCwgYGApXG5cdFx0XHRcdFx0ZWRpdG9yLnNldExpbmUobGluZU51bWJlciwgcmVwbGFjZUxpbmVUb1JlbW92ZVRhZyk7XG5cdFx0XHRcdFx0Ly8gbGV0cyBzYXkgXCIjdHQgXCIgaXMgYXQgMyAoY2hhciBmb3IgIylcblx0XHRcdFx0XHQvLyBpZiBjaCA8PSAzIG5vIG5lZWQgdG8gdXBkYXRlXG5cdFx0XHRcdFx0Ly8gaWYgY2ggPj0gNyB0aGVuIG5lZWQgdG8gLTRcblx0XHRcdFx0XHQvLyBlbHNlIGNoID09IDNcblx0XHRcdFx0XHRjb25zdCB0dEluZGV4ID0gbGluZS5pbmRleE9mKHR0KVxuXHRcdFx0XHRcdGNvbnN0IGluZGV4ID0gdHRJbmRleFxuXHRcdFx0XHRcdGNvbnN0IG5ld0NoID0gY3Vyc29yLmNoIDw9IGluZGV4ID8gY3Vyc29yLmNoIDogKGN1cnNvci5jaCA+PSBpbmRleCArIDQgPyBjdXJzb3IuY2ggLSA0IDogaW5kZXgpXG5cdFx0XHRcdFx0Y3Vyc29yLmNoID0gbmV3Q2hcblx0XHRcdFx0XHRlZGl0b3Iuc2V0Q3Vyc29yKGN1cnNvcik7XG5cdFx0XHRcdH0gZWxzZSBpZiAocmVwbGFjZWRMaW5lID09IGxpbmUpIHsgLy8gbm8gdGFnLCB0byBhZGQgdGFnXG5cdFx0XHRcdFx0Y29uc3QgY3Vyc29yID0gZWRpdG9yLmdldEN1cnNvcigpXG5cdFx0XHRcdFx0Y29uc3QgbGluZSA9IGVkaXRvci5nZXRMaW5lKGN1cnNvci5saW5lKTtcblx0XHRcdFx0XHRlZGl0b3IucmVwbGFjZVJhbmdlKGAke2xpbmUuY2hhckF0KGN1cnNvci5jaCAtIDEpICE9ICcgJyA/ICcgJyA6IFwiXCJ9I3Qke3R9IGAsIGN1cnNvcik7ICBcblx0XHRcdFx0XHRjdXJzb3IuY2ggPSBjdXJzb3IuY2ggKyA0ICsgKGxpbmUuY2hhckF0KGN1cnNvci5jaCAtIDEpICE9ICcgJyA/IDEgOiAwKTtcblx0XHRcdFx0XHRlZGl0b3Iuc2V0Q3Vyc29yKGN1cnNvcik7XG5cdFx0XHRcdH0gZWxzZSB7XHRcdFx0IFxuXHRcdFx0XHRcdGVkaXRvci5zZXRMaW5lKGxpbmVOdW1iZXIsIHJlcGxhY2VkTGluZSk7XG5cdFx0XHRcdFx0ZWRpdG9yLnNldEN1cnNvcihjdXJzb3IpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0aG90a2V5czogW1xuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bW9kaWZpZXJzOiBbYEN0cmxgLCBgTWV0YWAsIGBTaGlmdGBdLFxuXHRcdFx0XHRcdGtleTogYCR7dH1gLFxuXHRcdFx0XHR9LFxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bW9kaWZpZXJzOiBbYEN0cmxgLCBgQWx0YCwgYFNoaWZ0YF0sXG5cdFx0XHRcdFx0a2V5OiBgJHt0fWAsXG5cdFx0XHRcdH1cblx0XHRcdF1cblx0XHR9KTtcblx0fVxuXG5cblx0aXMxVG83KHQ6IHN0cmluZykgOiBib29sZWFuIHtcblx0XHRpZiAodCA9PSBcIjFcIiB8fCB0ID09IFwiMlwiIHx8IHQgPT0gXCIzXCIgfHwgdCA9PSBcIjRcIiB8fCB0ID09IFwiNVwiIHx8IHQgPT0gXCI2XCIgfHwgdCA9PSBcIjdcIikge1xuXHRcdFx0cmV0dXJuIHRydWVcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIGZhbHNlXG5cdFx0fVxuXHR9XG5cblx0YWRkVG9DbGlwYm9hcmRIaXN0b3J5KGNvbnRlbnQ6IHN0cmluZykge1xuXHRcdGNvbnN0IGluZGV4ID0gY2xpcGJvYXJkSGlzdG9yeS5pbmRleE9mKGNvbnRlbnQsIDApO1xuXHRcdGlmIChpbmRleCA+IC0xKSB7XG5cdFx0XHRjbGlwYm9hcmRIaXN0b3J5LnNwbGljZShpbmRleCwgMSk7XG5cdFx0fVxuXHRcdGlmIChjb250ZW50Lmxlbmd0aCA+IDApIHtcblx0XHRcdGNsaXBib2FyZEhpc3RvcnkucHVzaChjb250ZW50KTtcblx0XHR9XG5cdH1cblxuXHRvbnVubG9hZCgpIHtcblxuXHR9XG5cblx0YXN5bmMgbG9hZFNldHRpbmdzKCkge1xuXHRcdHRoaXMuc2V0dGluZ3MgPSBPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUX1NFVFRJTkdTLCBhd2FpdCB0aGlzLmxvYWREYXRhKCkpO1xuXHR9XG5cblx0YXN5bmMgc2F2ZVNldHRpbmdzKCkge1xuXHRcdGF3YWl0IHRoaXMuc2F2ZURhdGEodGhpcy5zZXR0aW5ncyk7XG5cdH1cbn1cblxuY2xhc3MgU2FtcGxlU2V0dGluZ1RhYiBleHRlbmRzIFBsdWdpblNldHRpbmdUYWIge1xuXHRwbHVnaW46IE15UGx1Z2luO1xuXG5cdGNvbnN0cnVjdG9yKGFwcDogQXBwLCBwbHVnaW46IE15UGx1Z2luKSB7XG5cdFx0c3VwZXIoYXBwLCBwbHVnaW4pO1xuXHRcdHRoaXMucGx1Z2luID0gcGx1Z2luO1xuXHR9XG5cblx0ZGlzcGxheSgpOiB2b2lkIHtcblx0XHRjb25zdCB7Y29udGFpbmVyRWx9ID0gdGhpcztcblxuXHRcdGNvbnRhaW5lckVsLmVtcHR5KCk7XG5cblx0XHRjb250YWluZXJFbC5jcmVhdGVFbCgnaDInLCB7dGV4dDogJ1NldHRpbmdzIGZvciBteSBhd2Vzb21lIHBsdWdpbi4nfSk7XG5cblx0XHRuZXcgU2V0dGluZyhjb250YWluZXJFbClcblx0XHRcdC5zZXROYW1lKCdTZXR0aW5nICMxJylcblx0XHRcdC5zZXREZXNjKCdJdFxcJ3MgYSBzZWNyZXQnKVxuXHRcdFx0LmFkZFRleHQodGV4dCA9PiB0ZXh0XG5cdFx0XHRcdC5zZXRQbGFjZWhvbGRlcignRW50ZXIgeW91ciBzZWNyZXQnKVxuXHRcdFx0XHQuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MubXlTZXR0aW5nKVxuXHRcdFx0XHQub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG5cdFx0XHRcdFx0Y29uc29sZS5sb2coJ1NlY3JldDogJyArIHZhbHVlKTtcblx0XHRcdFx0XHR0aGlzLnBsdWdpbi5zZXR0aW5ncy5teVNldHRpbmcgPSB2YWx1ZTtcblx0XHRcdFx0XHRhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcblx0XHRcdFx0fSkpO1xuXHR9XG59XG5cblxuIiwgImltcG9ydCB7IEFwcCwgRWRpdG9yLCBGdXp6eVN1Z2dlc3RNb2RhbCwgRnV6enlNYXRjaCwgVEZpbGUsIE5vdGljZSB9IGZyb20gXCJvYnNpZGlhblwiO1xuaW1wb3J0IHsgaGFzRnJvbnRNYXR0ZXIsIGhhc1RhZ3MsIHJlbmFtZVRhZyB9IGZyb20gXCJ0YWdyZW5hbWVyL3JlbmFtaW5nXCI7XG5pbXBvcnQge0ZpbGV9IGZyb20gXCJ0YWdyZW5hbWVyL0ZpbGVcIjtcblxuaW50ZXJmYWNlIE5vdGVUeXBlIHtcbiAgdHlwZTogc3RyaW5nO1xuICBkZXNjcmlwdGlvbjogc3RyaW5nO1xufVxuXG5jb25zdCBBTExfVFlQRVMgPSBbXG4gIHtcbiAgICB0eXBlOiBcImEvbi9uXCIsXG4gICAgZGVzY3JpcHRpb246IFwiTiBDdXJyZW50IFRhc2tcIixcbiAgfSxcbiAge1xuICAgIHR5cGU6IFwiYS93L25cIixcbiAgICBkZXNjcmlwdGlvbjogXCJXIEN1cnJlbnQgVGFza1wiLFxuICB9LFxuICB7XG4gICAgdHlwZTogXCJhL24vbFwiLFxuICAgIGRlc2NyaXB0aW9uOiBcIk4gTGF0ZXIgVGFza1wiLFxuICB9LFxuICB7XG4gICAgdHlwZTogXCJhL3cvbFwiLFxuICAgIGRlc2NyaXB0aW9uOiBcIlcgTGF0ZXIgVGFza1wiLFxuICB9LFxuICB7XG4gICAgdHlwZTogXCJhL24vcFwiLFxuICAgIGRlc2NyaXB0aW9uOiBcIk4gUGVybWFuZW50IFRhc2tcIixcbiAgfSxcbiAge1xuICAgIHR5cGU6IFwiYS93L3BcIixcbiAgICBkZXNjcmlwdGlvbjogXCJXIFBlcm1hbmVudCBUYXNrXCIsXG4gIH0sXG4gIHtcbiAgICB0eXBlOiBcImIvbi9zXCIsXG4gICAgZGVzY3JpcHRpb246IFwiWmV0dGVsa2FzdGVuIC0gU291cmNlIG5vdGVzIChsaWtlIGJvb2tzIC8gdmlkZW8gLyB0aG91Z2h0cyAvIGNvbnZlcnNhdGlvbilcIixcbiAgfSxcbiAge1xuICAgIHR5cGU6IFwiYi9uL2NcIixcbiAgICBkZXNjcmlwdGlvbjogXCJaZXR0ZWxrYXN0ZW4gLSBDYXJkcyAoV2l0aCB5b3VyIG93biB0aG91Z2h0KVwiLFxuICB9LFxuICB7XG4gICAgdHlwZTogXCJjL3QvZFwiLFxuICAgIGRlc2NyaXB0aW9uOiBcIlRocmVhZHMgcG9zdCBkcmFmdFwiLFxuICB9LFxuICB7XG4gICAgdHlwZTogXCJjL2IvZFwiLFxuICAgIGRlc2NyaXB0aW9uOiBcIkJsb2cgcG9zdCBkcmFmdFwiLFxuICB9LFxuICB7XG4gICAgdHlwZTogXCJiL24vdVwiLFxuICAgIGRlc2NyaXB0aW9uOiBcIlpldHRlbGthc3RlbiAtIFVucHJvY2Vzc2VkIG1hdGVyaWFsIGxpa2UgYW4gaW5ib3hcIixcbiAgfSxcbiAge1xuICAgIHR5cGU6IFwiYi9uL21cIixcbiAgICBkZXNjcmlwdGlvbjogXCJaZXR0ZWxrYXN0ZW4gLSBNT0MgTm90ZXMgZm9yIGEgc21hbGwgdG9waWNcIixcbiAgfSxcbiAge1xuICAgIHR5cGU6IFwiYi9uL3pcIixcbiAgICBkZXNjcmlwdGlvbjogXCJaZXR0ZWxrYXN0ZW4gLSBTbGlwIGJveCAobWFpbmx5IG9uIHRob3VnaHQgYW5kIHRoZSBvbmUgSSBhbSBpbnRlcmVzdGVkKVwiLFxuICB9LFxuICB7XG4gICAgdHlwZTogXCJiL24vaVwiLFxuICAgIGRlc2NyaXB0aW9uOiBcIkluZGV4IE5vdGVzIGZvciBzZWxmIGZyYW1ld29ya1wiLFxuICB9LFxuICB7XG4gICAgdHlwZTogXCJiL24vd1wiLFxuICAgIGRlc2NyaXB0aW9uOiBcIldpa2kgTm90ZXMgZm9yIGEgbWVzc3kgd2lraSB0b3BpY1wiLFxuICB9LFxuICB7XG4gICAgdHlwZTogXCJiL24vdlwiLFxuICAgIGRlc2NyaXB0aW9uOiBcIlpldHRlbGthc3RlbiAtIFZvaWNlIHNjcmlwdCAoRGVwcmVjYXRlZD8pXCIsXG4gIH0sXG4gIHtcbiAgICB0eXBlOiBcImIvbi9yXCIsXG4gICAgZGVzY3JpcHRpb246IFwiWmV0dGVsa2FzdGVuIC0gUmVmZXJlbmNlIChEZXByZWNhdGVkPylcIixcbiAgfSxcbiAge1xuICAgIHR5cGU6IFwiYi9uL3BcIixcbiAgICBkZXNjcmlwdGlvbjogXCJQbGFjZWhvbGRlciBOb3RlcyAoRGVwcmVjYXRlZD8pXCIsXG4gIH0sXG4gIHtcbiAgICB0eXBlOiBcImIvYS9wXCIsXG4gICAgZGVzY3JpcHRpb246IFwiQXJlYSBvZiBSZXNwb25zaWJpbGl0eSAtIFByaW1hcnlcIixcbiAgfSxcbiAge1xuICAgIHR5cGU6IFwiYi9hL3NcIixcbiAgICBkZXNjcmlwdGlvbjogXCJBcmVhIG9mIFJlc3BvbnNpYmlsaXR5IC0gU2Vjb25kYXJ5XCIsXG4gIH0sXG4gIHtcbiAgICB0eXBlOiBcImMvYi9pXCIsXG4gICAgZGVzY3JpcHRpb246IFwiQmxvZyBwb3N0IGNvbnRlbnQgY29tcGxldGVkIGJ1dCBhd2FpdGluZyB1cGxvYWQgaW1hZ2VcIixcbiAgfSxcbiAge1xuICAgIHR5cGU6IFwiYy9iL3JcIixcbiAgICBkZXNjcmlwdGlvbjogXCJCbG9nIHBvc3QgcmVhZHkgdG8gcHVibGlzaFwiLFxuICB9LFxuICB7XG4gICAgdHlwZTogXCJjL2IvcFwiLFxuICAgIGRlc2NyaXB0aW9uOiBcIkJsb2cgcG9zdCBwdWJsaXNoZWRcIixcbiAgfSxcbiAge1xuICAgIHR5cGU6IFwiYy9iL2lcIixcbiAgICBkZXNjcmlwdGlvbjogXCJCbG9nIHBvc3Qgc2VyaWVzIGluZGV4XCIsXG4gIH0sXG4gIHtcbiAgICB0eXBlOiBcImMvYi9hXCIsXG4gICAgZGVzY3JpcHRpb246IFwiQmxvZyBwb3N0IGFiYW5kb25lZFwiLFxuICB9LFxuICB7XG4gICAgdHlwZTogXCJjL2Ivb1wiLFxuICAgIGRlc2NyaXB0aW9uOiBcIkJsb2cgcG9zdCBvdXRsaW5lZCAoRGVwcmVjYXRlZD8pXCIsXG4gIH0sXG4gIHtcbiAgICB0eXBlOiBcImMvYi9mXCIsXG4gICAgZGVzY3JpcHRpb246IFwiQmxvZyBwb3N0IGZpbmUgdHVuZWQgKERlcHJlY2F0ZWQ/KVwiLFxuICB9LFxuICB7XG4gICAgdHlwZTogXCJjL3QvclwiLFxuICAgIGRlc2NyaXB0aW9uOiBcIlRocmVhZHMgcG9zdCByZWFkeSB0byBwb3N0XCIsXG4gIH0sXG4gIHtcbiAgICB0eXBlOiBcImMvdC90XCIsXG4gICAgZGVzY3JpcHRpb246IFwiVGhyZWFkcyBwb3N0IHRocmVhZHMgcHVibGlzaGVkXCIsXG4gIH0sXG4gIHtcbiAgICB0eXBlOiBcImMvdC9wXCIsXG4gICAgZGVzY3JpcHRpb246IFwiVGhyZWFkcyBwb3N0IHB1Ymxpc2hlZFwiLFxuICB9LFxuICB7XG4gICAgdHlwZTogXCJjL3QvaVwiLFxuICAgIGRlc2NyaXB0aW9uOiBcIlRocmVhZHMgcG9zdCBzZXJpZXMgaW5kZXhcIixcbiAgfSxcbiAge1xuICAgIHR5cGU6IFwiYy90L2FcIixcbiAgICBkZXNjcmlwdGlvbjogXCJUaHJlYWRzIHBvc3QgYWJhbmRvbmVkXCIsXG4gIH0sXG4gIHtcbiAgICB0eXBlOiBcImMveC9kXCIsXG4gICAgZGVzY3JpcHRpb246IFwiVHdpdHRlciBwb3N0IGRyYWZ0aW5nXCIsXG4gIH0sXG4gIHtcbiAgICB0eXBlOiBcImMveC9yXCIsXG4gICAgZGVzY3JpcHRpb246IFwiVHdpdHRlciBwb3N0IHJlYWR5IHRvIHB1Ymxpc2hcIixcbiAgfSxcbiAge1xuICAgIHR5cGU6IFwiYy94L3BcIixcbiAgICBkZXNjcmlwdGlvbjogXCJUd2l0dGVyIHBvc3QgcHVibGlzaGVkXCIsXG4gIH0sXG4gIHtcbiAgICB0eXBlOiBcImEvbi93XCIsXG4gICAgZGVzY3JpcHRpb246IFwiTiBXYWl0aW5nIFRhc2tcIixcbiAgfSxcbiAge1xuICAgIHR5cGU6IFwiYS9uL2RcIixcbiAgICBkZXNjcmlwdGlvbjogXCJOIERvbmUgVGFza1wiLFxuICB9LFxuICB7XG4gICAgdHlwZTogXCJhL24vYVwiLFxuICAgIGRlc2NyaXB0aW9uOiBcIk4gQXJjaGl2ZSBUYXNrXCIsXG4gIH0sXG4gIHtcbiAgICB0eXBlOiBcImEvdy93XCIsXG4gICAgZGVzY3JpcHRpb246IFwiVyBXYWl0aW5nIFRhc2tcIixcbiAgfSxcbiAge1xuICAgIHR5cGU6IFwiYS93L2RcIixcbiAgICBkZXNjcmlwdGlvbjogXCJXIERvbmUgVGFza1wiLFxuICB9LFxuICB7XG4gICAgdHlwZTogXCJhL3cvYVwiLFxuICAgIGRlc2NyaXB0aW9uOiBcIlcgQXJjaGl2ZSBUYXNrXCIsXG4gIH0sXG5dO1xuXG5leHBvcnQgY2xhc3MgVXBkYXRlTm90ZVR5cGVNb2RhbCBleHRlbmRzIEZ1enp5U3VnZ2VzdE1vZGFsPE5vdGVUeXBlPiB7XG5cbiAgZWRpdG9yOiBFZGl0b3JcbiAgZmlsZTogVEZpbGVcblxuICBjb25zdHJ1Y3RvcihhcHA6IEFwcCwgZWRpdG9yOiBFZGl0b3IsIGZpbGU6IFRGaWxlKVxuICB7XG4gICAgc3VwZXIoYXBwKVxuICAgIHRoaXMuZWRpdG9yID0gZWRpdG9yXG4gICAgdGhpcy5maWxlID0gZmlsZVxuICB9XG5cbiAgZ2V0SXRlbXMoKTogTm90ZVR5cGVbXSB7XG4gICAgcmV0dXJuIEFMTF9UWVBFUztcbiAgfVxuXG4gIGdldEl0ZW1UZXh0KG5vdGVUeXBlOiBOb3RlVHlwZSk6IHN0cmluZyB7XG4gICAgcmV0dXJuIG5vdGVUeXBlLnR5cGU7XG4gIH1cblxuICAvLyBSZW5kZXJzIGVhY2ggc3VnZ2VzdGlvbiBpdGVtLlxuICByZW5kZXJTdWdnZXN0aW9uKGNob29zZW5Ob3RlVHlwZU1hdGNoOiBGdXp6eU1hdGNoPE5vdGVUeXBlPiwgZWw6IEhUTUxFbGVtZW50KSB7XG4gICAgY29uc3Qgbm90ZVR5cGUgPSBjaG9vc2VuTm90ZVR5cGVNYXRjaC5pdGVtXG4gICAgZWwuY3JlYXRlRWwoXCJkaXZcIiwgeyB0ZXh0OiBub3RlVHlwZS50eXBlIH0pO1xuICAgIGVsLmNyZWF0ZUVsKFwic21hbGxcIiwgeyB0ZXh0OiBub3RlVHlwZS5kZXNjcmlwdGlvbiB9KTtcbiAgfVxuXG4gIGNvbnRhaW5zVHlwZShsaW5lOiBTdHJpbmcpIDogQm9vbGVhbiB7XG4gICAgcmV0dXJuIEFMTF9UWVBFUy5maWx0ZXIoKG5vdGVUeXBlKSA9PiBsaW5lLmNvbnRhaW5zKG5vdGVUeXBlLnR5cGUpKS5sZW5ndGggPiAwXG4gIH1cblxuICBhZGRGcm9udE1hdHRlcldpdGhUYWcodmFsdWU6IHN0cmluZykge1xuICAgIGNvbnN0IGN1cnNvciA9IHRoaXMuZWRpdG9yLmdldEN1cnNvcigpXG4gICAgY29uc3Qgb2xkTGluZSA9IGN1cnNvci5saW5lXG4gICAgY29uc3Qgb2xkQ2ggPSBjdXJzb3IuY2hcbiAgICBjb25zdCBhZGRUZXh0ID0gYC0tLVxcbnRhZ3M6ICR7dmFsdWV9XFxuLS0tXFxuXFxuJHt0aGlzLmVkaXRvci5nZXRWYWx1ZSgpfWBcbiAgICB0aGlzLmVkaXRvci5zZXRWYWx1ZShhZGRUZXh0KVxuICAgIGN1cnNvci5saW5lID0gb2xkTGluZSArIDRcbiAgICBjdXJzb3IuY2ggPSBvbGRDaFxuICAgIHRoaXMuZWRpdG9yLnNldEN1cnNvcihjdXJzb3IpXG4gIH1cblxuICBhZGRUYWdBc3N1bWluZ0hhc0Zyb250TWF0dGVyKHZhbHVlOiBzdHJpbmcpIHtcbiAgICBjb25zdCBjdXJzb3IgPSB0aGlzLmVkaXRvci5nZXRDdXJzb3IoKVxuICAgIGNvbnN0IG9sZExpbmUgPSBjdXJzb3IubGluZVxuICAgIGNvbnN0IG9sZENoID0gY3Vyc29yLmNoXG5cbiAgICBsZXQgZmlyc3RMaW5lSW5kZXggPSAwO1xuICAgIGNvbnN0IGxpbmVDb3VudCA9IHRoaXMuZWRpdG9yLmxpbmVDb3VudCgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZUNvdW50OyBpKyspIHtcbiAgICAgIGlmICh0aGlzLmVkaXRvci5nZXRMaW5lKGkpLnRyaW0oKSA9PSBcIi0tLVwiLnRyaW0oKSkge1xuICAgICAgICBmaXJzdExpbmVJbmRleCA9IGk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZmlyc3RMaW5lSW5kZXggPT0gbGluZUNvdW50KSB7XG4gICAgICBuZXcgTm90aWNlKFwiU29tZXRoaW5nIHdyb25nIGhlcmVcIilcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IHRleHQgPSBcIlwiXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gZmlyc3RMaW5lSW5kZXg7IGkrKykge1xuICAgICAgdGV4dCA9IHRleHQgKyB0aGlzLmVkaXRvci5nZXRMaW5lKGkpICsgXCJcXG5cIjtcbiAgICB9XG4gICAgdGV4dCA9IHRleHQgKyBgdGFnczogJHt2YWx1ZX1cXG5gXG4gICAgZm9yIChsZXQgaSA9IGZpcnN0TGluZUluZGV4ICsgMTsgaSA8PSB0aGlzLmVkaXRvci5saW5lQ291bnQoKTsgaSsrKSB7XG4gICAgICB0ZXh0ID0gdGV4dCArIHRoaXMuZWRpdG9yLmdldExpbmUoaSkgKyBcIlxcblwiO1xuICAgIH1cblxuICAgIHRoaXMuZWRpdG9yLnNldFZhbHVlKHRleHQpXG4gICAgY3Vyc29yLmxpbmUgPSBvbGRMaW5lICsgKG9sZExpbmUgPD0gZmlyc3RMaW5lSW5kZXggPyAwIDogMSlcbiAgICBjdXJzb3IuY2ggPSBvbGRDaFxuICAgIHRoaXMuZWRpdG9yLnNldEN1cnNvcihjdXJzb3IpXG4gIH1cblxuICAvLyBQZXJmb3JtIGFjdGlvbiBvbiB0aGUgc2VsZWN0ZWQgc3VnZ2VzdGlvbi5cbiAgb25DaG9vc2VJdGVtKGNob29zZW5Ob3RlVHlwZTogTm90ZVR5cGUsIGV2dDogTW91c2VFdmVudCB8IEtleWJvYXJkRXZlbnQpIHtcbiAgICBpZiAoIWhhc0Zyb250TWF0dGVyKHRoaXMuZmlsZSkpIHtcbiAgICAgIHRoaXMuYWRkRnJvbnRNYXR0ZXJXaXRoVGFnKGNob29zZW5Ob3RlVHlwZS50eXBlKVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaGFzVGFncyh0aGlzLmZpbGUpKVxuICAgICAge1xuICAgICAgICBBTExfVFlQRVMuZm9yRWFjaCh0ID0+IHtcbiAgICAgICAgICByZW5hbWVUYWcodGhpcy5maWxlLCB0LnR5cGUsIGNob29zZW5Ob3RlVHlwZS50eXBlKVxuICAgICAgICAgIH0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBuZXcgTm90aWNlKFwiYWRkaW5nIHRhZyB0b2RvXCIpXG4gICAgICAgIC8vIG5ldyBGaWxlKGFwcCwgdGhpcy5maWxlLnBhdGgsIG51bGwsIDApLnJlcGxhY2VJbkZyb250TWF0dGVyO1xuXG4gICAgICAgIC8vIFRPRE8gYWRkIHRhZ3NcbiAgICAgICAgdGhpcy5hZGRUYWdBc3N1bWluZ0hhc0Zyb250TWF0dGVyKGNob29zZW5Ob3RlVHlwZS50eXBlKVxuICAgICAgfVxuICAgIH1cbiAgfVxufSIsICJpbXBvcnQge0FwcCwgTWFya2Rvd25WaWV3LCBOb3RpY2UsIFRBYnN0cmFjdEZpbGUsIFRGaWxlLCBwYXJzZUZyb250TWF0dGVyQWxpYXNlcywgcGFyc2VGcm9udE1hdHRlclRhZ3N9IGZyb20gXCJvYnNpZGlhblwiO1xuaW1wb3J0IHtUYWcsIFJlcGxhY2VtZW50fSBmcm9tIFwiLi9UYWdcIjtcbmltcG9ydCB7RmlsZX0gZnJvbSBcIi4vRmlsZVwiO1xuXG5leHBvcnQgZnVuY3Rpb24gaGFzRnJvbnRNYXR0ZXIoZmlsZTogVEZpbGUpIDogYm9vbGVhbiB7XG4gICAgbGV0IHsgZnJvbnRtYXR0ZXIgfSA9IGFwcC5tZXRhZGF0YUNhY2hlLmdldEZpbGVDYWNoZShmaWxlKSB8fCB7fTtcbiAgICByZXR1cm4gZnJvbnRtYXR0ZXIgIT0gbnVsbFxufVxuXG5leHBvcnQgZnVuY3Rpb24gaGFzVGFncyhmaWxlOiBURmlsZSkgOiBib29sZWFuIHtcbiAgICBsZXQgeyBmcm9udG1hdHRlciB9ID0gYXBwLm1ldGFkYXRhQ2FjaGUuZ2V0RmlsZUNhY2hlKGZpbGUpIHx8IHt9O1xuICAgIGNvbnN0IGZtdGFncyA9IChwYXJzZUZyb250TWF0dGVyVGFncyhmcm9udG1hdHRlcikgfHwgW10pO1xuICAgIGNvbnN0IGFsaWFzVGFncyA9IChwYXJzZUZyb250TWF0dGVyQWxpYXNlcyhmcm9udG1hdHRlcikgfHwgW10pLmZpbHRlcihUYWcuaXNUYWcpO1xuICAgIHJldHVybiAoZm10YWdzLmxlbmd0aCB8fCBhbGlhc1RhZ3MubGVuZ3RoKSA/IHRydWUgOiBmYWxzZVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmVuYW1lVGFnKGZpbGU6IFRGaWxlLCB0YWdOYW1lOiBzdHJpbmcsIG5ld05hbWU6c3RyaW5nKSA6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIGNvbnN0XG4gICAgICAgIG9sZFRhZyAgPSBuZXcgVGFnKHRhZ05hbWUpLFxuICAgICAgICBuZXdUYWcgID0gbmV3IFRhZyhuZXdOYW1lKSxcbiAgICAgICAgcmVwbGFjZSA9IG5ldyBSZXBsYWNlbWVudChvbGRUYWcsIG5ld1RhZylcblxuICAgIGNvbnN0IHRhcmdldCA9IGF3YWl0IGZpbmRUYXJnZXRzKG9sZFRhZywgZmlsZSk7XG4gICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBhd2FpdCB0YXJnZXQucmVuYW1lZChyZXBsYWNlKVxuICAgIHJldHVybiB0cnVlXG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBmaW5kVGFyZ2V0cyh0YWc6IFRhZywgZmlsZTogVEZpbGUpIHtcbiAgICBsZXQgeyBmcm9udG1hdHRlciwgdGFncyB9ID0gYXBwLm1ldGFkYXRhQ2FjaGUuZ2V0RmlsZUNhY2hlKGZpbGUpIHx8IHt9O1xuICAgIGNvbnN0IGZtdGFncyA9IChwYXJzZUZyb250TWF0dGVyVGFncyhmcm9udG1hdHRlcikgfHwgW10pLmZpbHRlcih0YWcubWF0Y2hlcyk7XG4gICAgY29uc3QgYWxpYXNUYWdzID0gKHBhcnNlRnJvbnRNYXR0ZXJBbGlhc2VzKGZyb250bWF0dGVyKSB8fCBbXSkuZmlsdGVyKFRhZy5pc1RhZykuZmlsdGVyKHRhZy5tYXRjaGVzKTtcbiAgICBpZiAoZm10YWdzLmxlbmd0aCB8fCBhbGlhc1RhZ3MubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBuZXcgRmlsZShhcHAsIGZpbGUucGF0aCwgdGFncywgZm10YWdzLmxlbmd0aCArIGFsaWFzVGFncy5sZW5ndGgpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlbmFtZUJsb2dUaXRsZShhcHAgOiBBcHAsIHBhdGg6IHN0cmluZywgdmlldzogTWFya2Rvd25WaWV3KSA6IFByb21pc2U8dm9pZD4ge1xuICAgIGxldCBtb21lbnQgPSByZXF1aXJlKCdtb21lbnQnKTtcbiAgICBjb25zdCBkYXRlWVlZWU1NREQgPSBtb21lbnQoKS5mb3JtYXQoJ1lZWVlNTUREJyk7XG4gICAgbGV0IHJlbmFtZWRQYXRoID0gXCJcIlxuICAgIGlmIChwYXRoLm1hdGNoKC9eLlxcL0Jsb2cgXFxkXFxkXFxkXFxkXFxkXFxkXFxkXFxkLykpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG4gICAgfSBlbHNlIGlmIChwYXRoLm1hdGNoKC9eLlxcL2Jsb2cgXFxkXFxkXFxkXFxkXFxkXFxkXFxkXFxkLykpIHtcbiAgICAgICAgbmV3IE5vdGljZShcInN0YXJ0IHdpdGggYmxvZyB3aXRoIGRhdGUsIHJlbmFtaW5nIGJsb2cgdG8gQmxvZ1wiKVxuICAgICAgICByZW5hbWVkUGF0aCA9IHBhdGgucmVwbGFjZSgvXiguXFwvKWJsb2cgLywgYCQxQmxvZyBgKVxuICAgICAgICByZXR1cm4gcmVuYW1lRmlsZShhcHAsIHZpZXcuZmlsZSwgcmVuYW1lZFBhdGgpO1xuICAgIH0gZWxzZSBpZiAocGF0aC5tYXRjaCgvXi5cXC9CbG9nIC8pKSB7XG4gICAgICAgIG5ldyBOb3RpY2UoXCJzdGFydHMgd2l0aCBCbG9nIGJ1dCBubyBkYXRlLCBhZGRpbmcgZGF0ZVwiKVxuICAgICAgICByZW5hbWVkUGF0aCA9IHBhdGgucmVwbGFjZSgvXiguXFwvQmxvZyApLywgYCQxJHtkYXRlWVlZWU1NRER9IGApXG4gICAgICAgIHJldHVybiByZW5hbWVGaWxlKGFwcCwgdmlldy5maWxlLCByZW5hbWVkUGF0aCk7XG4gICAgfSBlbHNlIGlmIChwYXRoLm1hdGNoKC9eLlxcL2Jsb2cgLykpIHtcbiAgICAgICAgbmV3IE5vdGljZShcInN0YXJ0cyB3aXRoIGJsb2cgYnV0IG5vIGRhdGUsIGFkZGluZyBkYXRlXCIpXG4gICAgICAgIHJlbmFtZWRQYXRoID0gcGF0aC5yZXBsYWNlKC9eKC5cXC8pYmxvZyAvLCBgJDFCbG9nICR7ZGF0ZVlZWVlNTUREfSBgKVxuICAgICAgICByZXR1cm4gcmVuYW1lRmlsZShhcHAsIHZpZXcuZmlsZSwgcmVuYW1lZFBhdGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG5ldyBOb3RpY2UoXCJzdGFydHMgd2l0aG91dCBibG9nLCBhZGRpbmcgQmxvZyArIGRhdGVcIilcbiAgICAgICAgcmVuYW1lZFBhdGggPSBwYXRoLnJlcGxhY2UoL14oLlxcLykvLCBgJDFCbG9nICR7ZGF0ZVlZWVlNTUREfSBgKVxuICAgICAgICByZXR1cm4gcmVuYW1lRmlsZShhcHAsIHZpZXcuZmlsZSwgcmVuYW1lZFBhdGgpO1xuICAgIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gcmVuYW1lRmlsZShhcHAgOiBBcHAsIGZpbGUgOiBUQWJzdHJhY3RGaWxlLCBuZXdQYXRoOiBzdHJpbmcpIHtcbiAgICBhcHAuZmlsZU1hbmFnZXIucmVuYW1lRmlsZShmaWxlLCBuZXdQYXRoKVxufVxuXG5cbiIsICJjb25zdCB0YWdCb2R5ID0gL14jW15cXHUyMDAwLVxcdTIwNkZcXHUyRTAwLVxcdTJFN0YnIVwiIyQlJigpKissLjo7PD0+P0BeYHt8fX5cXFtcXF1cXFxcXFxzXSskLztcblxuZXhwb3J0IGNsYXNzIFRhZyB7XG4gICAgdGFnOiBhbnk7XG4gICAgY2Fub25pY2FsX3ByZWZpeDogc3RyaW5nO1xuICAgIGNhbm9uaWNhbDogc3RyaW5nO1xuICAgIG5hbWU6IGFueTtcbiAgICBtYXRjaGVzOiAodGV4dDogYW55KSA9PiBhbnk7XG4gICAgY29uc3RydWN0b3IobmFtZTogYW55KSB7XG4gICAgICAgIGNvbnN0XG4gICAgICAgICAgICBoYXNoZWQgPSB0aGlzLnRhZyA9IFRhZy50b1RhZyhuYW1lKSxcbiAgICAgICAgICAgIGNhbm9uaWNhbCA9IHRoaXMuY2Fub25pY2FsID0gaGFzaGVkLnRvTG93ZXJDYXNlKCksXG4gICAgICAgICAgICBjYW5vbmljYWxfcHJlZml4ID0gdGhpcy5jYW5vbmljYWxfcHJlZml4ID0gY2Fub25pY2FsICsgXCIvXCI7XG4gICAgICAgIHRoaXMubmFtZSA9IGhhc2hlZC5zbGljZSgxKTtcbiAgICAgICAgdGhpcy5tYXRjaGVzID0gZnVuY3Rpb24gKHRleHQpIHtcbiAgICAgICAgICAgIHRleHQgPSB0ZXh0LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICByZXR1cm4gdGV4dCA9PSBjYW5vbmljYWwgfHwgdGV4dC5zdGFydHNXaXRoKGNhbm9uaWNhbF9wcmVmaXgpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICB0b1N0cmluZygpIHsgcmV0dXJuIHRoaXMudGFnOyB9XG5cbiAgICBzdGF0aWMgaXNUYWcoczogc3RyaW5nKSB7IHJldHVybiB0YWdCb2R5LnRlc3Qocyk7IH1cblxuICAgIHN0YXRpYyB0b1RhZyhuYW1lOiBzdHJpbmcpIHtcbiAgICAgICAgd2hpbGUgKG5hbWUuc3RhcnRzV2l0aChcIiMjXCIpKSBuYW1lID0gbmFtZS5zbGljZSgxKTtcbiAgICAgICAgcmV0dXJuIG5hbWUuc3RhcnRzV2l0aChcIiNcIikgPyBuYW1lIDogXCIjXCIrbmFtZTtcbiAgICB9XG5cbiAgICBzdGF0aWMgY2Fub25pY2FsKG5hbWU6IGFueSkge1xuICAgICAgICByZXR1cm4gVGFnLnRvVGFnKG5hbWUpLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxufVxuXG5leHBvcnQgY2xhc3MgUmVwbGFjZW1lbnQge1xuICAgIGluU3RyaW5nOiAodGV4dDogYW55LCBwb3M/OiBudW1iZXIpID0+IGFueTtcbiAgICBpbkFycmF5OiAodGFnczogYW55LCBza2lwT2RkOiBhbnksIGlzQWxpYXM6IGFueSkgPT4gYW55O1xuICAgIHdpbGxNZXJnZVRhZ3M6ICh0YWdOYW1lczogYW55KSA9PiBUYWdbXSB8IHVuZGVmaW5lZDtcblxuICAgIGNvbnN0cnVjdG9yKGZyb21UYWc6IFRhZywgdG9UYWc6IFRhZykge1xuICAgICAgICBjb25zdCBjYWNoZSA9ICBPYmplY3QuYXNzaWduKFxuICAgICAgICAgICAgT2JqZWN0LmNyZWF0ZShudWxsKSwge1xuICAgICAgICAgICAgICAgIFtmcm9tVGFnLnRhZ106ICB0b1RhZy50YWcsXG4gICAgICAgICAgICAgICAgW2Zyb21UYWcubmFtZV06IHRvVGFnLm5hbWUsXG4gICAgICAgICAgICB9XG4gICAgICAgICk7XG5cbiAgICAgICAgdGhpcy5pblN0cmluZyA9IGZ1bmN0aW9uKHRleHQsIHBvcyA9IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0ZXh0LnNsaWNlKDAsIHBvcykgKyB0b1RhZy50YWcgKyB0ZXh0LnNsaWNlKHBvcyArIGZyb21UYWcudGFnLmxlbmd0aCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmluQXJyYXkgPSAodGFncywgc2tpcE9kZCwgaXNBbGlhcykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRhZ3MubWFwKCh0OiBzdHJpbmcsIGk6IG51bWJlcikgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChza2lwT2RkICYmIChpICYgMSkpIHJldHVybiB0OyAgIC8vIGxlYXZlIG9kZCBlbnRyaWVzIChzZXBhcmF0b3JzKSBhbG9uZVxuICAgICAgICAgICAgICAgIC8vIE9ic2lkaWFuIGFsbG93cyBzcGFjZXMgYXMgc2VwYXJhdG9ycyB3aXRoaW4gYXJyYXkgZWxlbWVudHNcbiAgICAgICAgICAgICAgICBpZiAoIXQpIHJldHVybiB0O1xuICAgICAgICAgICAgICAgIC8vIFNraXAgbm9uLXRhZyBwYXJ0c1xuICAgICAgICAgICAgICAgIGlmIChpc0FsaWFzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdC5zdGFydHNXaXRoKFwiI1wiKSB8fCAhVGFnLmlzVGFnKHQpKSByZXR1cm4gdDtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKC9bICxcXG5dLy50ZXN0KHQpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHJldHVybiB0aGlzLmluQXJyYXkodC5zcGxpdCgvKFssIFxcbl0rKS8pLCB0cnVlKS5qb2luKFwiXCIpOyAvLyBub3Qgc3VyZVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pbkFycmF5KHQuc3BsaXQoLyhbLCBcXG5dKykvKSwgdHJ1ZSwgaXNBbGlhcykuam9pbihcIlwiKTsgLy8gbm90IHN1cmVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNhY2hlW3RdKSByZXR1cm4gY2FjaGVbdF07XG4gICAgICAgICAgICAgICAgY29uc3QgbGMgPSB0LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgaWYgKGNhY2hlW2xjXSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FjaGVbdF0gPSBjYWNoZVtsY107XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChsYy5zdGFydHNXaXRoKGZyb21UYWcuY2Fub25pY2FsX3ByZWZpeCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhY2hlW3RdID0gY2FjaGVbbGNdID0gdGhpcy5pblN0cmluZyh0KTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKChcIiNcIiArIGxjKS5zdGFydHNXaXRoKGZyb21UYWcuY2Fub25pY2FsX3ByZWZpeCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhY2hlW3RdID0gY2FjaGVbbGNdID0gdGhpcy5pblN0cmluZyhcIiNcIiArIHQpLnNsaWNlKDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gY2FjaGVbdF0gPSBjYWNoZVtsY10gPSB0O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy53aWxsTWVyZ2VUYWdzID0gZnVuY3Rpb24gKHRhZ05hbWVzKSB7XG4gICAgICAgICAgICAvLyBSZW5hbWluZyB0byBjaGFuZ2UgY2FzZSBkb2Vzbid0IGxvc2UgaW5mbywgc28gaWdub3JlIGl0XG4gICAgICAgICAgICBpZiAoZnJvbVRhZy5jYW5vbmljYWwgPT09IHRvVGFnLmNhbm9uaWNhbCkgcmV0dXJuO1xuXG4gICAgICAgICAgICBjb25zdCBleGlzdGluZyA9IG5ldyBTZXQodGFnTmFtZXMubWFwKChzOiBzdHJpbmcpID0+IHMudG9Mb3dlckNhc2UoKSkpO1xuXG4gICAgICAgICAgICBmb3IgKGNvbnN0IHRhZ05hbWUgb2YgdGFnTmFtZXMuZmlsdGVyKGZyb21UYWcubWF0Y2hlcykpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGFuZ2VkID0gdGhpcy5pblN0cmluZyh0YWdOYW1lKTtcbiAgICAgICAgICAgICAgICBpZiAoZXhpc3RpbmcuaGFzKGNoYW5nZWQudG9Mb3dlckNhc2UoKSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbbmV3IFRhZyh0YWdOYW1lKSwgbmV3IFRhZyhjaGFuZ2VkKV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuICAgIH1cbn1cblxuXG4iLCAiaW1wb3J0IHsgTm90aWNlIH0gZnJvbSBcIm9ic2lkaWFuXCI7XG5pbXBvcnQgeyBDU1QsIHBhcnNlRG9jdW1lbnQgfSBmcm9tIFwieWFtbFwiO1xuaW1wb3J0IHsgUmVwbGFjZW1lbnQgfSBmcm9tIFwiLi9UYWdcIjtcblxuZXhwb3J0IGNsYXNzIEZpbGUge1xuICAgIGFwcDogYW55O1xuICAgIGZpbGVuYW1lOiBhbnk7XG4gICAgYmFzZW5hbWU6IGFueTtcbiAgICB0YWdQb3NpdGlvbnM6IGFueTtcbiAgICBoYXNGcm9udE1hdHRlcjogYm9vbGVhbjtcblxuICAgIGNvbnN0cnVjdG9yKGFwcDogYW55LCBmaWxlbmFtZTogc3RyaW5nLCB0YWdQb3NpdGlvbnM6IGFueSwgaGFzRnJvbnRNYXR0ZXI6IG51bWJlcikge1xuICAgICAgICB0aGlzLmFwcCA9IGFwcDtcbiAgICAgICAgdGhpcy5maWxlbmFtZSA9IGZpbGVuYW1lO1xuICAgICAgICB0aGlzLmJhc2VuYW1lID0gZmlsZW5hbWUuc3BsaXQoXCIvXCIpLnBvcCgpO1xuICAgICAgICB0aGlzLnRhZ1Bvc2l0aW9ucyA9IHRhZ1Bvc2l0aW9ucztcbiAgICAgICAgdGhpcy5oYXNGcm9udE1hdHRlciA9ICEhaGFzRnJvbnRNYXR0ZXI7XG4gICAgfVxuXG4gICAgLyoqIEBwYXJhbSB7UmVwbGFjZW1lbnR9IHJlcGxhY2UgKi9cbiAgICBhc3luYyByZW5hbWVkKHJlcGxhY2UgOiBSZXBsYWNlbWVudCkge1xuICAgICAgICBjb25zdCBmaWxlID0gdGhpcy5hcHAudmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKHRoaXMuZmlsZW5hbWUpO1xuICAgICAgICBjb25zdCBvcmlnaW5hbCA9IGF3YWl0IHRoaXMuYXBwLnZhdWx0LnJlYWQoZmlsZSk7XG4gICAgICAgIGxldCB0ZXh0ID0gb3JpZ2luYWw7XG5cbiAgICAgICAgaWYgKHRoaXMuaGFzRnJvbnRNYXR0ZXIpIHtcbiAgICAgICAgICAgIHRleHQgPSB0aGlzLnJlcGxhY2VJbkZyb250TWF0dGVyKHRleHQsIHJlcGxhY2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRleHQgIT09IG9yaWdpbmFsKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmFwcC52YXVsdC5tb2RpZnkoZmlsZSwgdGV4dCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKiBAcGFyYW0ge1JlcGxhY2VtZW50fSByZXBsYWNlICovXG4gICAgcmVwbGFjZUluRnJvbnRNYXR0ZXIodGV4dDogeyBzcGxpdDogKGFyZzA6IFJlZ0V4cCwgYXJnMTogbnVtYmVyKSA9PiBbYW55LCBhbnldOyByZXBsYWNlOiAoYXJnMDogYW55LCBhcmcxOiBhbnkpID0+IGFueTsgfSwgcmVwbGFjZTogeyBpbkFycmF5OiAoYXJnMDogYW55W10sIGFyZzE6IGJvb2xlYW4sIGFyZzI6IGFueSkgPT4gYW55W107IH0pIHtcbiAgICAgICAgY29uc3QgW2VtcHR5LCBmcm9udE1hdHRlcl0gPSB0ZXh0LnNwbGl0KC9eLS0tXFxyPyRcXG4/L20sIDIpO1xuXG4gICAgICAgIC8vIENoZWNrIGZvciB2YWxpZCwgbm9uLWVtcHR5LCBwcm9wZXJseSB0ZXJtaW5hdGVkIGZyb250IG1hdHRlclxuICAgICAgICBpZiAoZW1wdHkudHJpbSgpICE9PSBcIlwiIHx8ICFmcm9udE1hdHRlci50cmltKCkgfHwgIWZyb250TWF0dGVyLmVuZHNXaXRoKFwiXFxuXCIpKVxuICAgICAgICAgICAgcmV0dXJuIHRleHQ7XG5cbiAgICAgICAgY29uc3QgcGFyc2VkID0gcGFyc2VEb2N1bWVudChmcm9udE1hdHRlciwge2tlZXBTb3VyY2VUb2tlbnM6IHRydWV9KTtcbiAgICAgICAgaWYgKHBhcnNlZC5lcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCBlcnJvciA9IGBZQU1MIGlzc3VlIHdpdGggJHt0aGlzLmZpbGVuYW1lfTogJHtwYXJzZWQuZXJyb3JzWzBdfWA7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yKTsgbmV3IE5vdGljZShlcnJvciArIFwiOyBza2lwcGluZyBmcm9udG1hdHRlclwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBjaGFuZ2VkID0gZmFsc2UsIGpzb24gPSBwYXJzZWQudG9KU09OKCk7XG5cbiAgICAgICAgZnVuY3Rpb24gc2V0SW5Ob2RlKG5vZGU6IHsgc3JjVG9rZW46IGFueTsgdmFsdWU6IGFueTsgfSwgdmFsdWU6IGFueSwgYWZ0ZXJLZXk9ZmFsc2UpIHtcbiAgICAgICAgICAgIENTVC5zZXRTY2FsYXJWYWx1ZShub2RlLnNyY1Rva2VuLCB2YWx1ZSwge2FmdGVyS2V5fSk7XG4gICAgICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIG5vZGUudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHByb2Nlc3NGaWVsZChwcm9wOiBzdHJpbmcgfCBudW1iZXIsIGlzQWxpYXM6IGJvb2xlYW4pIHtcbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBwYXJzZWQuZ2V0KHByb3AsIHRydWUpO1xuICAgICAgICAgICAgaWYgKCFub2RlKSByZXR1cm47XG4gICAgICAgICAgICBjb25zdCBmaWVsZCA9IGpzb25bcHJvcF07XG4gICAgICAgICAgICBpZiAoIWZpZWxkIHx8ICFmaWVsZC5sZW5ndGgpIHJldHVybjtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZmllbGQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJ0cyA9IGZpZWxkLnNwbGl0KGlzQWxpYXMgPyAvKF5cXHMrfFxccyosXFxzKnxcXHMrJCkvIDogLyhbXFxzLF0rKS8pO1xuICAgICAgICAgICAgICAgIGNvbnN0IGFmdGVyID0gcmVwbGFjZS5pbkFycmF5KHBhcnRzLCB0cnVlLCBpc0FsaWFzKS5qb2luKFwiXCIpO1xuICAgICAgICAgICAgICAgIGlmIChmaWVsZCAhPSBhZnRlcikgc2V0SW5Ob2RlKG5vZGUsIGFmdGVyLCB0cnVlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShmaWVsZCkpIHtcbiAgICAgICAgICAgICAgICByZXBsYWNlLmluQXJyYXkoZmllbGQsIGZhbHNlLCBpc0FsaWFzKS5mb3JFYWNoKCh2OiBhbnksIGk6IG51bWJlcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmllbGRbaV0gIT09IHYpIHNldEluTm9kZShub2RlLmdldChpLCB0cnVlKSwgdilcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoY29uc3Qge2tleToge3ZhbHVlOnByb3B9fSBvZiBwYXJzZWQuY29udGVudHMuaXRlbXMpIHtcbiAgICAgICAgICAgIGlmICgvXnRhZ3M/JC9pLnRlc3QocHJvcCkpIHtcbiAgICAgICAgICAgICAgICBwcm9jZXNzRmllbGQocHJvcCwgZmFsc2UpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICgvXmFsaWFzKGVzKT8kL2kudGVzdChwcm9wKSkge1xuICAgICAgICAgICAgICAgIHByb2Nlc3NGaWVsZChwcm9wLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2hhbmdlZCA/IHRleHQucmVwbGFjZShmcm9udE1hdHRlciwgQ1NULnN0cmluZ2lmeShwYXJzZWQuY29udGVudHMuc3JjVG9rZW4pKSA6IHRleHQ7XG4gICAgfVxufVxuIiwgImNvbnN0IEFMSUFTID0gU3ltYm9sLmZvcigneWFtbC5hbGlhcycpO1xuY29uc3QgRE9DID0gU3ltYm9sLmZvcigneWFtbC5kb2N1bWVudCcpO1xuY29uc3QgTUFQID0gU3ltYm9sLmZvcigneWFtbC5tYXAnKTtcbmNvbnN0IFBBSVIgPSBTeW1ib2wuZm9yKCd5YW1sLnBhaXInKTtcbmNvbnN0IFNDQUxBUiA9IFN5bWJvbC5mb3IoJ3lhbWwuc2NhbGFyJyk7XG5jb25zdCBTRVEgPSBTeW1ib2wuZm9yKCd5YW1sLnNlcScpO1xuY29uc3QgTk9ERV9UWVBFID0gU3ltYm9sLmZvcigneWFtbC5ub2RlLnR5cGUnKTtcbmNvbnN0IGlzQWxpYXMgPSAobm9kZSkgPT4gISFub2RlICYmIHR5cGVvZiBub2RlID09PSAnb2JqZWN0JyAmJiBub2RlW05PREVfVFlQRV0gPT09IEFMSUFTO1xuY29uc3QgaXNEb2N1bWVudCA9IChub2RlKSA9PiAhIW5vZGUgJiYgdHlwZW9mIG5vZGUgPT09ICdvYmplY3QnICYmIG5vZGVbTk9ERV9UWVBFXSA9PT0gRE9DO1xuY29uc3QgaXNNYXAgPSAobm9kZSkgPT4gISFub2RlICYmIHR5cGVvZiBub2RlID09PSAnb2JqZWN0JyAmJiBub2RlW05PREVfVFlQRV0gPT09IE1BUDtcbmNvbnN0IGlzUGFpciA9IChub2RlKSA9PiAhIW5vZGUgJiYgdHlwZW9mIG5vZGUgPT09ICdvYmplY3QnICYmIG5vZGVbTk9ERV9UWVBFXSA9PT0gUEFJUjtcbmNvbnN0IGlzU2NhbGFyID0gKG5vZGUpID0+ICEhbm9kZSAmJiB0eXBlb2Ygbm9kZSA9PT0gJ29iamVjdCcgJiYgbm9kZVtOT0RFX1RZUEVdID09PSBTQ0FMQVI7XG5jb25zdCBpc1NlcSA9IChub2RlKSA9PiAhIW5vZGUgJiYgdHlwZW9mIG5vZGUgPT09ICdvYmplY3QnICYmIG5vZGVbTk9ERV9UWVBFXSA9PT0gU0VRO1xuZnVuY3Rpb24gaXNDb2xsZWN0aW9uKG5vZGUpIHtcbiAgICBpZiAobm9kZSAmJiB0eXBlb2Ygbm9kZSA9PT0gJ29iamVjdCcpXG4gICAgICAgIHN3aXRjaCAobm9kZVtOT0RFX1RZUEVdKSB7XG4gICAgICAgICAgICBjYXNlIE1BUDpcbiAgICAgICAgICAgIGNhc2UgU0VROlxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gaXNOb2RlKG5vZGUpIHtcbiAgICBpZiAobm9kZSAmJiB0eXBlb2Ygbm9kZSA9PT0gJ29iamVjdCcpXG4gICAgICAgIHN3aXRjaCAobm9kZVtOT0RFX1RZUEVdKSB7XG4gICAgICAgICAgICBjYXNlIEFMSUFTOlxuICAgICAgICAgICAgY2FzZSBNQVA6XG4gICAgICAgICAgICBjYXNlIFNDQUxBUjpcbiAgICAgICAgICAgIGNhc2UgU0VROlxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuY29uc3QgaGFzQW5jaG9yID0gKG5vZGUpID0+IChpc1NjYWxhcihub2RlKSB8fCBpc0NvbGxlY3Rpb24obm9kZSkpICYmICEhbm9kZS5hbmNob3I7XG5jbGFzcyBOb2RlQmFzZSB7XG4gICAgY29uc3RydWN0b3IodHlwZSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgTk9ERV9UWVBFLCB7IHZhbHVlOiB0eXBlIH0pO1xuICAgIH1cbiAgICAvKiogQ3JlYXRlIGEgY29weSBvZiB0aGlzIG5vZGUuICAqL1xuICAgIGNsb25lKCkge1xuICAgICAgICBjb25zdCBjb3B5ID0gT2JqZWN0LmNyZWF0ZShPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcyksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHRoaXMpKTtcbiAgICAgICAgaWYgKHRoaXMucmFuZ2UpXG4gICAgICAgICAgICBjb3B5LnJhbmdlID0gdGhpcy5yYW5nZS5zbGljZSgpO1xuICAgICAgICByZXR1cm4gY29weTtcbiAgICB9XG59XG5cbmV4cG9ydCB7IEFMSUFTLCBET0MsIE1BUCwgTk9ERV9UWVBFLCBOb2RlQmFzZSwgUEFJUiwgU0NBTEFSLCBTRVEsIGhhc0FuY2hvciwgaXNBbGlhcywgaXNDb2xsZWN0aW9uLCBpc0RvY3VtZW50LCBpc01hcCwgaXNOb2RlLCBpc1BhaXIsIGlzU2NhbGFyLCBpc1NlcSB9O1xuIiwgImltcG9ydCB7IGlzRG9jdW1lbnQsIGlzTWFwLCBpc1NlcSwgaXNQYWlyLCBpc1NjYWxhciwgaXNBbGlhcywgaXNOb2RlLCBpc0NvbGxlY3Rpb24gfSBmcm9tICcuL25vZGVzL05vZGUuanMnO1xuXG5jb25zdCBCUkVBSyA9IFN5bWJvbCgnYnJlYWsgdmlzaXQnKTtcbmNvbnN0IFNLSVAgPSBTeW1ib2woJ3NraXAgY2hpbGRyZW4nKTtcbmNvbnN0IFJFTU9WRSA9IFN5bWJvbCgncmVtb3ZlIG5vZGUnKTtcbi8qKlxuICogQXBwbHkgYSB2aXNpdG9yIHRvIGFuIEFTVCBub2RlIG9yIGRvY3VtZW50LlxuICpcbiAqIFdhbGtzIHRocm91Z2ggdGhlIHRyZWUgKGRlcHRoLWZpcnN0KSBzdGFydGluZyBmcm9tIGBub2RlYCwgY2FsbGluZyBhXG4gKiBgdmlzaXRvcmAgZnVuY3Rpb24gd2l0aCB0aHJlZSBhcmd1bWVudHM6XG4gKiAgIC0gYGtleWA6IEZvciBzZXF1ZW5jZSB2YWx1ZXMgYW5kIG1hcCBgUGFpcmAsIHRoZSBub2RlJ3MgaW5kZXggaW4gdGhlXG4gKiAgICAgY29sbGVjdGlvbi4gV2l0aGluIGEgYFBhaXJgLCBgJ2tleSdgIG9yIGAndmFsdWUnYCwgY29ycmVzcG9uZGluZ2x5LlxuICogICAgIGBudWxsYCBmb3IgdGhlIHJvb3Qgbm9kZS5cbiAqICAgLSBgbm9kZWA6IFRoZSBjdXJyZW50IG5vZGUuXG4gKiAgIC0gYHBhdGhgOiBUaGUgYW5jZXN0cnkgb2YgdGhlIGN1cnJlbnQgbm9kZS5cbiAqXG4gKiBUaGUgcmV0dXJuIHZhbHVlIG9mIHRoZSB2aXNpdG9yIG1heSBiZSB1c2VkIHRvIGNvbnRyb2wgdGhlIHRyYXZlcnNhbDpcbiAqICAgLSBgdW5kZWZpbmVkYCAoZGVmYXVsdCk6IERvIG5vdGhpbmcgYW5kIGNvbnRpbnVlXG4gKiAgIC0gYHZpc2l0LlNLSVBgOiBEbyBub3QgdmlzaXQgdGhlIGNoaWxkcmVuIG9mIHRoaXMgbm9kZSwgY29udGludWUgd2l0aCBuZXh0XG4gKiAgICAgc2libGluZ1xuICogICAtIGB2aXNpdC5CUkVBS2A6IFRlcm1pbmF0ZSB0cmF2ZXJzYWwgY29tcGxldGVseVxuICogICAtIGB2aXNpdC5SRU1PVkVgOiBSZW1vdmUgdGhlIGN1cnJlbnQgbm9kZSwgdGhlbiBjb250aW51ZSB3aXRoIHRoZSBuZXh0IG9uZVxuICogICAtIGBOb2RlYDogUmVwbGFjZSB0aGUgY3VycmVudCBub2RlLCB0aGVuIGNvbnRpbnVlIGJ5IHZpc2l0aW5nIGl0XG4gKiAgIC0gYG51bWJlcmA6IFdoaWxlIGl0ZXJhdGluZyB0aGUgaXRlbXMgb2YgYSBzZXF1ZW5jZSBvciBtYXAsIHNldCB0aGUgaW5kZXhcbiAqICAgICBvZiB0aGUgbmV4dCBzdGVwLiBUaGlzIGlzIHVzZWZ1bCBlc3BlY2lhbGx5IGlmIHRoZSBpbmRleCBvZiB0aGUgY3VycmVudFxuICogICAgIG5vZGUgaGFzIGNoYW5nZWQuXG4gKlxuICogSWYgYHZpc2l0b3JgIGlzIGEgc2luZ2xlIGZ1bmN0aW9uLCBpdCB3aWxsIGJlIGNhbGxlZCB3aXRoIGFsbCB2YWx1ZXNcbiAqIGVuY291bnRlcmVkIGluIHRoZSB0cmVlLCBpbmNsdWRpbmcgZS5nLiBgbnVsbGAgdmFsdWVzLiBBbHRlcm5hdGl2ZWx5LFxuICogc2VwYXJhdGUgdmlzaXRvciBmdW5jdGlvbnMgbWF5IGJlIGRlZmluZWQgZm9yIGVhY2ggYE1hcGAsIGBQYWlyYCwgYFNlcWAsXG4gKiBgQWxpYXNgIGFuZCBgU2NhbGFyYCBub2RlLiBUbyBkZWZpbmUgdGhlIHNhbWUgdmlzaXRvciBmdW5jdGlvbiBmb3IgbW9yZSB0aGFuXG4gKiBvbmUgbm9kZSB0eXBlLCB1c2UgdGhlIGBDb2xsZWN0aW9uYCAobWFwIGFuZCBzZXEpLCBgVmFsdWVgIChtYXAsIHNlcSAmIHNjYWxhcilcbiAqIGFuZCBgTm9kZWAgKGFsaWFzLCBtYXAsIHNlcSAmIHNjYWxhcikgdGFyZ2V0cy4gT2YgYWxsIHRoZXNlLCBvbmx5IHRoZSBtb3N0XG4gKiBzcGVjaWZpYyBkZWZpbmVkIG9uZSB3aWxsIGJlIHVzZWQgZm9yIGVhY2ggbm9kZS5cbiAqL1xuZnVuY3Rpb24gdmlzaXQobm9kZSwgdmlzaXRvcikge1xuICAgIGlmICh0eXBlb2YgdmlzaXRvciA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgKHZpc2l0b3IuQ29sbGVjdGlvbiB8fCB2aXNpdG9yLk5vZGUgfHwgdmlzaXRvci5WYWx1ZSkpIHtcbiAgICAgICAgdmlzaXRvciA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgQWxpYXM6IHZpc2l0b3IuTm9kZSxcbiAgICAgICAgICAgIE1hcDogdmlzaXRvci5Ob2RlLFxuICAgICAgICAgICAgU2NhbGFyOiB2aXNpdG9yLk5vZGUsXG4gICAgICAgICAgICBTZXE6IHZpc2l0b3IuTm9kZVxuICAgICAgICB9LCB2aXNpdG9yLlZhbHVlICYmIHtcbiAgICAgICAgICAgIE1hcDogdmlzaXRvci5WYWx1ZSxcbiAgICAgICAgICAgIFNjYWxhcjogdmlzaXRvci5WYWx1ZSxcbiAgICAgICAgICAgIFNlcTogdmlzaXRvci5WYWx1ZVxuICAgICAgICB9LCB2aXNpdG9yLkNvbGxlY3Rpb24gJiYge1xuICAgICAgICAgICAgTWFwOiB2aXNpdG9yLkNvbGxlY3Rpb24sXG4gICAgICAgICAgICBTZXE6IHZpc2l0b3IuQ29sbGVjdGlvblxuICAgICAgICB9LCB2aXNpdG9yKTtcbiAgICB9XG4gICAgaWYgKGlzRG9jdW1lbnQobm9kZSkpIHtcbiAgICAgICAgY29uc3QgY2QgPSBfdmlzaXQobnVsbCwgbm9kZS5jb250ZW50cywgdmlzaXRvciwgT2JqZWN0LmZyZWV6ZShbbm9kZV0pKTtcbiAgICAgICAgaWYgKGNkID09PSBSRU1PVkUpXG4gICAgICAgICAgICBub2RlLmNvbnRlbnRzID0gbnVsbDtcbiAgICB9XG4gICAgZWxzZVxuICAgICAgICBfdmlzaXQobnVsbCwgbm9kZSwgdmlzaXRvciwgT2JqZWN0LmZyZWV6ZShbXSkpO1xufVxuLy8gV2l0aG91dCB0aGUgYGFzIHN5bWJvbGAgY2FzdHMsIFRTIGRlY2xhcmVzIHRoZXNlIGluIHRoZSBgdmlzaXRgXG4vLyBuYW1lc3BhY2UgdXNpbmcgYHZhcmAsIGJ1dCB0aGVuIGNvbXBsYWlucyBhYm91dCB0aGF0IGJlY2F1c2Vcbi8vIGB1bmlxdWUgc3ltYm9sYCBtdXN0IGJlIGBjb25zdGAuXG4vKiogVGVybWluYXRlIHZpc2l0IHRyYXZlcnNhbCBjb21wbGV0ZWx5ICovXG52aXNpdC5CUkVBSyA9IEJSRUFLO1xuLyoqIERvIG5vdCB2aXNpdCB0aGUgY2hpbGRyZW4gb2YgdGhlIGN1cnJlbnQgbm9kZSAqL1xudmlzaXQuU0tJUCA9IFNLSVA7XG4vKiogUmVtb3ZlIHRoZSBjdXJyZW50IG5vZGUgKi9cbnZpc2l0LlJFTU9WRSA9IFJFTU9WRTtcbmZ1bmN0aW9uIF92aXNpdChrZXksIG5vZGUsIHZpc2l0b3IsIHBhdGgpIHtcbiAgICBsZXQgY3RybCA9IHVuZGVmaW5lZDtcbiAgICBpZiAodHlwZW9mIHZpc2l0b3IgPT09ICdmdW5jdGlvbicpXG4gICAgICAgIGN0cmwgPSB2aXNpdG9yKGtleSwgbm9kZSwgcGF0aCk7XG4gICAgZWxzZSBpZiAoaXNNYXAobm9kZSkpIHtcbiAgICAgICAgaWYgKHZpc2l0b3IuTWFwKVxuICAgICAgICAgICAgY3RybCA9IHZpc2l0b3IuTWFwKGtleSwgbm9kZSwgcGF0aCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzU2VxKG5vZGUpKSB7XG4gICAgICAgIGlmICh2aXNpdG9yLlNlcSlcbiAgICAgICAgICAgIGN0cmwgPSB2aXNpdG9yLlNlcShrZXksIG5vZGUsIHBhdGgpO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc1BhaXIobm9kZSkpIHtcbiAgICAgICAgaWYgKHZpc2l0b3IuUGFpcilcbiAgICAgICAgICAgIGN0cmwgPSB2aXNpdG9yLlBhaXIoa2V5LCBub2RlLCBwYXRoKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNTY2FsYXIobm9kZSkpIHtcbiAgICAgICAgaWYgKHZpc2l0b3IuU2NhbGFyKVxuICAgICAgICAgICAgY3RybCA9IHZpc2l0b3IuU2NhbGFyKGtleSwgbm9kZSwgcGF0aCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzQWxpYXMobm9kZSkpIHtcbiAgICAgICAgaWYgKHZpc2l0b3IuQWxpYXMpXG4gICAgICAgICAgICBjdHJsID0gdmlzaXRvci5BbGlhcyhrZXksIG5vZGUsIHBhdGgpO1xuICAgIH1cbiAgICBpZiAoaXNOb2RlKGN0cmwpIHx8IGlzUGFpcihjdHJsKSkge1xuICAgICAgICBjb25zdCBwYXJlbnQgPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV07XG4gICAgICAgIGlmIChpc0NvbGxlY3Rpb24ocGFyZW50KSkge1xuICAgICAgICAgICAgcGFyZW50Lml0ZW1zW2tleV0gPSBjdHJsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzUGFpcihwYXJlbnQpKSB7XG4gICAgICAgICAgICBpZiAoa2V5ID09PSAna2V5JylcbiAgICAgICAgICAgICAgICBwYXJlbnQua2V5ID0gY3RybDtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBwYXJlbnQudmFsdWUgPSBjdHJsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzRG9jdW1lbnQocGFyZW50KSkge1xuICAgICAgICAgICAgcGFyZW50LmNvbnRlbnRzID0gY3RybDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHB0ID0gaXNBbGlhcyhwYXJlbnQpID8gJ2FsaWFzJyA6ICdzY2FsYXInO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgcmVwbGFjZSBub2RlIHdpdGggJHtwdH0gcGFyZW50YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF92aXNpdChrZXksIGN0cmwsIHZpc2l0b3IsIHBhdGgpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGN0cmwgIT09ICdzeW1ib2wnKSB7XG4gICAgICAgIGlmIChpc0NvbGxlY3Rpb24obm9kZSkpIHtcbiAgICAgICAgICAgIHBhdGggPSBPYmplY3QuZnJlZXplKHBhdGguY29uY2F0KG5vZGUpKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5pdGVtcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNpID0gX3Zpc2l0KGksIG5vZGUuaXRlbXNbaV0sIHZpc2l0b3IsIHBhdGgpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY2kgPT09ICdudW1iZXInKVxuICAgICAgICAgICAgICAgICAgICBpID0gY2kgLSAxO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNpID09PSBCUkVBSylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEJSRUFLO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNpID09PSBSRU1PVkUpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5pdGVtcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIGkgLT0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNQYWlyKG5vZGUpKSB7XG4gICAgICAgICAgICBwYXRoID0gT2JqZWN0LmZyZWV6ZShwYXRoLmNvbmNhdChub2RlKSk7XG4gICAgICAgICAgICBjb25zdCBjayA9IF92aXNpdCgna2V5Jywgbm9kZS5rZXksIHZpc2l0b3IsIHBhdGgpO1xuICAgICAgICAgICAgaWYgKGNrID09PSBCUkVBSylcbiAgICAgICAgICAgICAgICByZXR1cm4gQlJFQUs7XG4gICAgICAgICAgICBlbHNlIGlmIChjayA9PT0gUkVNT1ZFKVxuICAgICAgICAgICAgICAgIG5vZGUua2V5ID0gbnVsbDtcbiAgICAgICAgICAgIGNvbnN0IGN2ID0gX3Zpc2l0KCd2YWx1ZScsIG5vZGUudmFsdWUsIHZpc2l0b3IsIHBhdGgpO1xuICAgICAgICAgICAgaWYgKGN2ID09PSBCUkVBSylcbiAgICAgICAgICAgICAgICByZXR1cm4gQlJFQUs7XG4gICAgICAgICAgICBlbHNlIGlmIChjdiA9PT0gUkVNT1ZFKVxuICAgICAgICAgICAgICAgIG5vZGUudmFsdWUgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjdHJsO1xufVxuXG5leHBvcnQgeyB2aXNpdCB9O1xuIiwgImltcG9ydCB7IGlzTm9kZSB9IGZyb20gJy4uL25vZGVzL05vZGUuanMnO1xuaW1wb3J0IHsgdmlzaXQgfSBmcm9tICcuLi92aXNpdC5qcyc7XG5cbmNvbnN0IGVzY2FwZUNoYXJzID0ge1xuICAgICchJzogJyUyMScsXG4gICAgJywnOiAnJTJDJyxcbiAgICAnWyc6ICclNUInLFxuICAgICddJzogJyU1RCcsXG4gICAgJ3snOiAnJTdCJyxcbiAgICAnfSc6ICclN0QnXG59O1xuY29uc3QgZXNjYXBlVGFnTmFtZSA9ICh0bikgPT4gdG4ucmVwbGFjZSgvWyEsW1xcXXt9XS9nLCBjaCA9PiBlc2NhcGVDaGFyc1tjaF0pO1xuY2xhc3MgRGlyZWN0aXZlcyB7XG4gICAgY29uc3RydWN0b3IoeWFtbCwgdGFncykge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGRpcmVjdGl2ZXMtZW5kL2RvYy1zdGFydCBtYXJrZXIgYC0tLWAuIElmIGBudWxsYCwgYSBtYXJrZXIgbWF5IHN0aWxsIGJlXG4gICAgICAgICAqIGluY2x1ZGVkIGluIHRoZSBkb2N1bWVudCdzIHN0cmluZ2lmaWVkIHJlcHJlc2VudGF0aW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5tYXJrZXIgPSBudWxsO1xuICAgICAgICB0aGlzLnlhbWwgPSBPYmplY3QuYXNzaWduKHt9LCBEaXJlY3RpdmVzLmRlZmF1bHRZYW1sLCB5YW1sKTtcbiAgICAgICAgdGhpcy50YWdzID0gT2JqZWN0LmFzc2lnbih7fSwgRGlyZWN0aXZlcy5kZWZhdWx0VGFncywgdGFncyk7XG4gICAgfVxuICAgIGNsb25lKCkge1xuICAgICAgICBjb25zdCBjb3B5ID0gbmV3IERpcmVjdGl2ZXModGhpcy55YW1sLCB0aGlzLnRhZ3MpO1xuICAgICAgICBjb3B5Lm1hcmtlciA9IHRoaXMubWFya2VyO1xuICAgICAgICByZXR1cm4gY29weTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRHVyaW5nIHBhcnNpbmcsIGdldCBhIERpcmVjdGl2ZXMgaW5zdGFuY2UgZm9yIHRoZSBjdXJyZW50IGRvY3VtZW50IGFuZFxuICAgICAqIHVwZGF0ZSB0aGUgc3RyZWFtIHN0YXRlIGFjY29yZGluZyB0byB0aGUgY3VycmVudCB2ZXJzaW9uJ3Mgc3BlYy5cbiAgICAgKi9cbiAgICBhdERvY3VtZW50KCkge1xuICAgICAgICBjb25zdCByZXMgPSBuZXcgRGlyZWN0aXZlcyh0aGlzLnlhbWwsIHRoaXMudGFncyk7XG4gICAgICAgIHN3aXRjaCAodGhpcy55YW1sLnZlcnNpb24pIHtcbiAgICAgICAgICAgIGNhc2UgJzEuMSc6XG4gICAgICAgICAgICAgICAgdGhpcy5hdE5leHREb2N1bWVudCA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICcxLjInOlxuICAgICAgICAgICAgICAgIHRoaXMuYXROZXh0RG9jdW1lbnQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLnlhbWwgPSB7XG4gICAgICAgICAgICAgICAgICAgIGV4cGxpY2l0OiBEaXJlY3RpdmVzLmRlZmF1bHRZYW1sLmV4cGxpY2l0LFxuICAgICAgICAgICAgICAgICAgICB2ZXJzaW9uOiAnMS4yJ1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdGhpcy50YWdzID0gT2JqZWN0LmFzc2lnbih7fSwgRGlyZWN0aXZlcy5kZWZhdWx0VGFncyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIG9uRXJyb3IgLSBNYXkgYmUgY2FsbGVkIGV2ZW4gaWYgdGhlIGFjdGlvbiB3YXMgc3VjY2Vzc2Z1bFxuICAgICAqIEByZXR1cm5zIGB0cnVlYCBvbiBzdWNjZXNzXG4gICAgICovXG4gICAgYWRkKGxpbmUsIG9uRXJyb3IpIHtcbiAgICAgICAgaWYgKHRoaXMuYXROZXh0RG9jdW1lbnQpIHtcbiAgICAgICAgICAgIHRoaXMueWFtbCA9IHsgZXhwbGljaXQ6IERpcmVjdGl2ZXMuZGVmYXVsdFlhbWwuZXhwbGljaXQsIHZlcnNpb246ICcxLjEnIH07XG4gICAgICAgICAgICB0aGlzLnRhZ3MgPSBPYmplY3QuYXNzaWduKHt9LCBEaXJlY3RpdmVzLmRlZmF1bHRUYWdzKTtcbiAgICAgICAgICAgIHRoaXMuYXROZXh0RG9jdW1lbnQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJ0cyA9IGxpbmUudHJpbSgpLnNwbGl0KC9bIFxcdF0rLyk7XG4gICAgICAgIGNvbnN0IG5hbWUgPSBwYXJ0cy5zaGlmdCgpO1xuICAgICAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgICAgICAgIGNhc2UgJyVUQUcnOiB7XG4gICAgICAgICAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCAhPT0gMikge1xuICAgICAgICAgICAgICAgICAgICBvbkVycm9yKDAsICclVEFHIGRpcmVjdGl2ZSBzaG91bGQgY29udGFpbiBleGFjdGx5IHR3byBwYXJ0cycpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocGFydHMubGVuZ3RoIDwgMilcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgW2hhbmRsZSwgcHJlZml4XSA9IHBhcnRzO1xuICAgICAgICAgICAgICAgIHRoaXMudGFnc1toYW5kbGVdID0gcHJlZml4O1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnJVlBTUwnOiB7XG4gICAgICAgICAgICAgICAgdGhpcy55YW1sLmV4cGxpY2l0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAocGFydHMubGVuZ3RoIDwgMSkge1xuICAgICAgICAgICAgICAgICAgICBvbkVycm9yKDAsICclWUFNTCBkaXJlY3RpdmUgc2hvdWxkIGNvbnRhaW4gZXhhY3RseSBvbmUgcGFydCcpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IFt2ZXJzaW9uXSA9IHBhcnRzO1xuICAgICAgICAgICAgICAgIGlmICh2ZXJzaW9uID09PSAnMS4xJyB8fCB2ZXJzaW9uID09PSAnMS4yJykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnlhbWwudmVyc2lvbiA9IHZlcnNpb247XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgb25FcnJvcig2LCBgVW5zdXBwb3J0ZWQgWUFNTCB2ZXJzaW9uICR7dmVyc2lvbn1gLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgb25FcnJvcigwLCBgVW5rbm93biBkaXJlY3RpdmUgJHtuYW1lfWAsIHRydWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXNvbHZlcyBhIHRhZywgbWF0Y2hpbmcgaGFuZGxlcyB0byB0aG9zZSBkZWZpbmVkIGluICVUQUcgZGlyZWN0aXZlcy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFJlc29sdmVkIHRhZywgd2hpY2ggbWF5IGFsc28gYmUgdGhlIG5vbi1zcGVjaWZpYyB0YWcgYCchJ2Agb3IgYVxuICAgICAqICAgYCchbG9jYWwnYCB0YWcsIG9yIGBudWxsYCBpZiB1bnJlc29sdmFibGUuXG4gICAgICovXG4gICAgdGFnTmFtZShzb3VyY2UsIG9uRXJyb3IpIHtcbiAgICAgICAgaWYgKHNvdXJjZSA9PT0gJyEnKVxuICAgICAgICAgICAgcmV0dXJuICchJzsgLy8gbm9uLXNwZWNpZmljIHRhZ1xuICAgICAgICBpZiAoc291cmNlWzBdICE9PSAnIScpIHtcbiAgICAgICAgICAgIG9uRXJyb3IoYE5vdCBhIHZhbGlkIHRhZzogJHtzb3VyY2V9YCk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc291cmNlWzFdID09PSAnPCcpIHtcbiAgICAgICAgICAgIGNvbnN0IHZlcmJhdGltID0gc291cmNlLnNsaWNlKDIsIC0xKTtcbiAgICAgICAgICAgIGlmICh2ZXJiYXRpbSA9PT0gJyEnIHx8IHZlcmJhdGltID09PSAnISEnKSB7XG4gICAgICAgICAgICAgICAgb25FcnJvcihgVmVyYmF0aW0gdGFncyBhcmVuJ3QgcmVzb2x2ZWQsIHNvICR7c291cmNlfSBpcyBpbnZhbGlkLmApO1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNvdXJjZVtzb3VyY2UubGVuZ3RoIC0gMV0gIT09ICc+JylcbiAgICAgICAgICAgICAgICBvbkVycm9yKCdWZXJiYXRpbSB0YWdzIG11c3QgZW5kIHdpdGggYSA+Jyk7XG4gICAgICAgICAgICByZXR1cm4gdmVyYmF0aW07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgWywgaGFuZGxlLCBzdWZmaXhdID0gc291cmNlLm1hdGNoKC9eKC4qISkoW14hXSopJC8pO1xuICAgICAgICBpZiAoIXN1ZmZpeClcbiAgICAgICAgICAgIG9uRXJyb3IoYFRoZSAke3NvdXJjZX0gdGFnIGhhcyBubyBzdWZmaXhgKTtcbiAgICAgICAgY29uc3QgcHJlZml4ID0gdGhpcy50YWdzW2hhbmRsZV07XG4gICAgICAgIGlmIChwcmVmaXgpXG4gICAgICAgICAgICByZXR1cm4gcHJlZml4ICsgZGVjb2RlVVJJQ29tcG9uZW50KHN1ZmZpeCk7XG4gICAgICAgIGlmIChoYW5kbGUgPT09ICchJylcbiAgICAgICAgICAgIHJldHVybiBzb3VyY2U7IC8vIGxvY2FsIHRhZ1xuICAgICAgICBvbkVycm9yKGBDb3VsZCBub3QgcmVzb2x2ZSB0YWc6ICR7c291cmNlfWApO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2l2ZW4gYSBmdWxseSByZXNvbHZlZCB0YWcsIHJldHVybnMgaXRzIHByaW50YWJsZSBzdHJpbmcgZm9ybSxcbiAgICAgKiB0YWtpbmcgaW50byBhY2NvdW50IGN1cnJlbnQgdGFnIHByZWZpeGVzIGFuZCBkZWZhdWx0cy5cbiAgICAgKi9cbiAgICB0YWdTdHJpbmcodGFnKSB7XG4gICAgICAgIGZvciAoY29uc3QgW2hhbmRsZSwgcHJlZml4XSBvZiBPYmplY3QuZW50cmllcyh0aGlzLnRhZ3MpKSB7XG4gICAgICAgICAgICBpZiAodGFnLnN0YXJ0c1dpdGgocHJlZml4KSlcbiAgICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlICsgZXNjYXBlVGFnTmFtZSh0YWcuc3Vic3RyaW5nKHByZWZpeC5sZW5ndGgpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGFnWzBdID09PSAnIScgPyB0YWcgOiBgITwke3RhZ30+YDtcbiAgICB9XG4gICAgdG9TdHJpbmcoZG9jKSB7XG4gICAgICAgIGNvbnN0IGxpbmVzID0gdGhpcy55YW1sLmV4cGxpY2l0XG4gICAgICAgICAgICA/IFtgJVlBTUwgJHt0aGlzLnlhbWwudmVyc2lvbiB8fCAnMS4yJ31gXVxuICAgICAgICAgICAgOiBbXTtcbiAgICAgICAgY29uc3QgdGFnRW50cmllcyA9IE9iamVjdC5lbnRyaWVzKHRoaXMudGFncyk7XG4gICAgICAgIGxldCB0YWdOYW1lcztcbiAgICAgICAgaWYgKGRvYyAmJiB0YWdFbnRyaWVzLmxlbmd0aCA+IDAgJiYgaXNOb2RlKGRvYy5jb250ZW50cykpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZ3MgPSB7fTtcbiAgICAgICAgICAgIHZpc2l0KGRvYy5jb250ZW50cywgKF9rZXksIG5vZGUpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoaXNOb2RlKG5vZGUpICYmIG5vZGUudGFnKVxuICAgICAgICAgICAgICAgICAgICB0YWdzW25vZGUudGFnXSA9IHRydWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRhZ05hbWVzID0gT2JqZWN0LmtleXModGFncyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGFnTmFtZXMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBbaGFuZGxlLCBwcmVmaXhdIG9mIHRhZ0VudHJpZXMpIHtcbiAgICAgICAgICAgIGlmIChoYW5kbGUgPT09ICchIScgJiYgcHJlZml4ID09PSAndGFnOnlhbWwub3JnLDIwMDI6JylcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGlmICghZG9jIHx8IHRhZ05hbWVzLnNvbWUodG4gPT4gdG4uc3RhcnRzV2l0aChwcmVmaXgpKSlcbiAgICAgICAgICAgICAgICBsaW5lcy5wdXNoKGAlVEFHICR7aGFuZGxlfSAke3ByZWZpeH1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGluZXMuam9pbignXFxuJyk7XG4gICAgfVxufVxuRGlyZWN0aXZlcy5kZWZhdWx0WWFtbCA9IHsgZXhwbGljaXQ6IGZhbHNlLCB2ZXJzaW9uOiAnMS4yJyB9O1xuRGlyZWN0aXZlcy5kZWZhdWx0VGFncyA9IHsgJyEhJzogJ3RhZzp5YW1sLm9yZywyMDAyOicgfTtcblxuZXhwb3J0IHsgRGlyZWN0aXZlcyB9O1xuIiwgImltcG9ydCB7IGlzU2NhbGFyLCBpc0NvbGxlY3Rpb24gfSBmcm9tICcuLi9ub2Rlcy9Ob2RlLmpzJztcbmltcG9ydCB7IHZpc2l0IH0gZnJvbSAnLi4vdmlzaXQuanMnO1xuXG4vKipcbiAqIFZlcmlmeSB0aGF0IHRoZSBpbnB1dCBzdHJpbmcgaXMgYSB2YWxpZCBhbmNob3IuXG4gKlxuICogV2lsbCB0aHJvdyBvbiBlcnJvcnMuXG4gKi9cbmZ1bmN0aW9uIGFuY2hvcklzVmFsaWQoYW5jaG9yKSB7XG4gICAgaWYgKC9bXFx4MDAtXFx4MTlcXHMsW1xcXXt9XS8udGVzdChhbmNob3IpKSB7XG4gICAgICAgIGNvbnN0IHNhID0gSlNPTi5zdHJpbmdpZnkoYW5jaG9yKTtcbiAgICAgICAgY29uc3QgbXNnID0gYEFuY2hvciBtdXN0IG5vdCBjb250YWluIHdoaXRlc3BhY2Ugb3IgY29udHJvbCBjaGFyYWN0ZXJzOiAke3NhfWA7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGFuY2hvck5hbWVzKHJvb3QpIHtcbiAgICBjb25zdCBhbmNob3JzID0gbmV3IFNldCgpO1xuICAgIHZpc2l0KHJvb3QsIHtcbiAgICAgICAgVmFsdWUoX2tleSwgbm9kZSkge1xuICAgICAgICAgICAgaWYgKG5vZGUuYW5jaG9yKVxuICAgICAgICAgICAgICAgIGFuY2hvcnMuYWRkKG5vZGUuYW5jaG9yKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBhbmNob3JzO1xufVxuLyoqIEZpbmQgYSBuZXcgYW5jaG9yIG5hbWUgd2l0aCB0aGUgZ2l2ZW4gYHByZWZpeGAgYW5kIGEgb25lLWluZGV4ZWQgc3VmZml4LiAqL1xuZnVuY3Rpb24gZmluZE5ld0FuY2hvcihwcmVmaXgsIGV4Y2x1ZGUpIHtcbiAgICBmb3IgKGxldCBpID0gMTsgdHJ1ZTsgKytpKSB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSBgJHtwcmVmaXh9JHtpfWA7XG4gICAgICAgIGlmICghZXhjbHVkZS5oYXMobmFtZSkpXG4gICAgICAgICAgICByZXR1cm4gbmFtZTtcbiAgICB9XG59XG5mdW5jdGlvbiBjcmVhdGVOb2RlQW5jaG9ycyhkb2MsIHByZWZpeCkge1xuICAgIGNvbnN0IGFsaWFzT2JqZWN0cyA9IFtdO1xuICAgIGNvbnN0IHNvdXJjZU9iamVjdHMgPSBuZXcgTWFwKCk7XG4gICAgbGV0IHByZXZBbmNob3JzID0gbnVsbDtcbiAgICByZXR1cm4ge1xuICAgICAgICBvbkFuY2hvcihzb3VyY2UpIHtcbiAgICAgICAgICAgIGFsaWFzT2JqZWN0cy5wdXNoKHNvdXJjZSk7XG4gICAgICAgICAgICBpZiAoIXByZXZBbmNob3JzKVxuICAgICAgICAgICAgICAgIHByZXZBbmNob3JzID0gYW5jaG9yTmFtZXMoZG9jKTtcbiAgICAgICAgICAgIGNvbnN0IGFuY2hvciA9IGZpbmROZXdBbmNob3IocHJlZml4LCBwcmV2QW5jaG9ycyk7XG4gICAgICAgICAgICBwcmV2QW5jaG9ycy5hZGQoYW5jaG9yKTtcbiAgICAgICAgICAgIHJldHVybiBhbmNob3I7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaXRoIGNpcmN1bGFyIHJlZmVyZW5jZXMsIHRoZSBzb3VyY2Ugbm9kZSBpcyBvbmx5IHJlc29sdmVkIGFmdGVyIGFsbFxuICAgICAgICAgKiBvZiBpdHMgY2hpbGQgbm9kZXMgYXJlLiBUaGlzIGlzIHdoeSBhbmNob3JzIGFyZSBzZXQgb25seSBhZnRlciBhbGwgb2ZcbiAgICAgICAgICogdGhlIG5vZGVzIGhhdmUgYmVlbiBjcmVhdGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgc2V0QW5jaG9ycygpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3Qgc291cmNlIG9mIGFsaWFzT2JqZWN0cykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlZiA9IHNvdXJjZU9iamVjdHMuZ2V0KHNvdXJjZSk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiByZWYgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICAgICAgICAgIHJlZi5hbmNob3IgJiZcbiAgICAgICAgICAgICAgICAgICAgKGlzU2NhbGFyKHJlZi5ub2RlKSB8fCBpc0NvbGxlY3Rpb24ocmVmLm5vZGUpKSkge1xuICAgICAgICAgICAgICAgICAgICByZWYubm9kZS5hbmNob3IgPSByZWYuYW5jaG9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoJ0ZhaWxlZCB0byByZXNvbHZlIHJlcGVhdGVkIG9iamVjdCAodGhpcyBzaG91bGQgbm90IGhhcHBlbiknKTtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3Iuc291cmNlID0gc291cmNlO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHNvdXJjZU9iamVjdHNcbiAgICB9O1xufVxuXG5leHBvcnQgeyBhbmNob3JJc1ZhbGlkLCBhbmNob3JOYW1lcywgY3JlYXRlTm9kZUFuY2hvcnMsIGZpbmROZXdBbmNob3IgfTtcbiIsICJpbXBvcnQgeyBhbmNob3JJc1ZhbGlkIH0gZnJvbSAnLi4vZG9jL2FuY2hvcnMuanMnO1xuaW1wb3J0IHsgdmlzaXQgfSBmcm9tICcuLi92aXNpdC5qcyc7XG5pbXBvcnQgeyBOb2RlQmFzZSwgQUxJQVMsIGlzQWxpYXMsIGlzQ29sbGVjdGlvbiwgaXNQYWlyIH0gZnJvbSAnLi9Ob2RlLmpzJztcblxuY2xhc3MgQWxpYXMgZXh0ZW5kcyBOb2RlQmFzZSB7XG4gICAgY29uc3RydWN0b3Ioc291cmNlKSB7XG4gICAgICAgIHN1cGVyKEFMSUFTKTtcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAndGFnJywge1xuICAgICAgICAgICAgc2V0KCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQWxpYXMgbm9kZXMgY2Fubm90IGhhdmUgdGFncycpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVzb2x2ZSB0aGUgdmFsdWUgb2YgdGhpcyBhbGlhcyB3aXRoaW4gYGRvY2AsIGZpbmRpbmcgdGhlIGxhc3RcbiAgICAgKiBpbnN0YW5jZSBvZiB0aGUgYHNvdXJjZWAgYW5jaG9yIGJlZm9yZSB0aGlzIG5vZGUuXG4gICAgICovXG4gICAgcmVzb2x2ZShkb2MpIHtcbiAgICAgICAgbGV0IGZvdW5kID0gdW5kZWZpbmVkO1xuICAgICAgICB2aXNpdChkb2MsIHtcbiAgICAgICAgICAgIE5vZGU6IChfa2V5LCBub2RlKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUgPT09IHRoaXMpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2aXNpdC5CUkVBSztcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5hbmNob3IgPT09IHRoaXMuc291cmNlKVxuICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IG5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZm91bmQ7XG4gICAgfVxuICAgIHRvSlNPTihfYXJnLCBjdHgpIHtcbiAgICAgICAgaWYgKCFjdHgpXG4gICAgICAgICAgICByZXR1cm4geyBzb3VyY2U6IHRoaXMuc291cmNlIH07XG4gICAgICAgIGNvbnN0IHsgYW5jaG9ycywgZG9jLCBtYXhBbGlhc0NvdW50IH0gPSBjdHg7XG4gICAgICAgIGNvbnN0IHNvdXJjZSA9IHRoaXMucmVzb2x2ZShkb2MpO1xuICAgICAgICBpZiAoIXNvdXJjZSkge1xuICAgICAgICAgICAgY29uc3QgbXNnID0gYFVucmVzb2x2ZWQgYWxpYXMgKHRoZSBhbmNob3IgbXVzdCBiZSBzZXQgYmVmb3JlIHRoZSBhbGlhcyk6ICR7dGhpcy5zb3VyY2V9YDtcbiAgICAgICAgICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihtc2cpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRhdGEgPSBhbmNob3JzLmdldChzb3VyY2UpO1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKCFkYXRhIHx8IGRhdGEucmVzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IG1zZyA9ICdUaGlzIHNob3VsZCBub3QgaGFwcGVuOiBBbGlhcyBhbmNob3Igd2FzIG5vdCByZXNvbHZlZD8nO1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKG1zZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1heEFsaWFzQ291bnQgPj0gMCkge1xuICAgICAgICAgICAgZGF0YS5jb3VudCArPSAxO1xuICAgICAgICAgICAgaWYgKGRhdGEuYWxpYXNDb3VudCA9PT0gMClcbiAgICAgICAgICAgICAgICBkYXRhLmFsaWFzQ291bnQgPSBnZXRBbGlhc0NvdW50KGRvYywgc291cmNlLCBhbmNob3JzKTtcbiAgICAgICAgICAgIGlmIChkYXRhLmNvdW50ICogZGF0YS5hbGlhc0NvdW50ID4gbWF4QWxpYXNDb3VudCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1zZyA9ICdFeGNlc3NpdmUgYWxpYXMgY291bnQgaW5kaWNhdGVzIGEgcmVzb3VyY2UgZXhoYXVzdGlvbiBhdHRhY2snO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihtc2cpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRhLnJlcztcbiAgICB9XG4gICAgdG9TdHJpbmcoY3R4LCBfb25Db21tZW50LCBfb25DaG9tcEtlZXApIHtcbiAgICAgICAgY29uc3Qgc3JjID0gYCoke3RoaXMuc291cmNlfWA7XG4gICAgICAgIGlmIChjdHgpIHtcbiAgICAgICAgICAgIGFuY2hvcklzVmFsaWQodGhpcy5zb3VyY2UpO1xuICAgICAgICAgICAgaWYgKGN0eC5vcHRpb25zLnZlcmlmeUFsaWFzT3JkZXIgJiYgIWN0eC5hbmNob3JzLmhhcyh0aGlzLnNvdXJjZSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtc2cgPSBgVW5yZXNvbHZlZCBhbGlhcyAodGhlIGFuY2hvciBtdXN0IGJlIHNldCBiZWZvcmUgdGhlIGFsaWFzKTogJHt0aGlzLnNvdXJjZX1gO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGN0eC5pbXBsaWNpdEtleSlcbiAgICAgICAgICAgICAgICByZXR1cm4gYCR7c3JjfSBgO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzcmM7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0QWxpYXNDb3VudChkb2MsIG5vZGUsIGFuY2hvcnMpIHtcbiAgICBpZiAoaXNBbGlhcyhub2RlKSkge1xuICAgICAgICBjb25zdCBzb3VyY2UgPSBub2RlLnJlc29sdmUoZG9jKTtcbiAgICAgICAgY29uc3QgYW5jaG9yID0gYW5jaG9ycyAmJiBzb3VyY2UgJiYgYW5jaG9ycy5nZXQoc291cmNlKTtcbiAgICAgICAgcmV0dXJuIGFuY2hvciA/IGFuY2hvci5jb3VudCAqIGFuY2hvci5hbGlhc0NvdW50IDogMDtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNDb2xsZWN0aW9uKG5vZGUpKSB7XG4gICAgICAgIGxldCBjb3VudCA9IDA7XG4gICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBub2RlLml0ZW1zKSB7XG4gICAgICAgICAgICBjb25zdCBjID0gZ2V0QWxpYXNDb3VudChkb2MsIGl0ZW0sIGFuY2hvcnMpO1xuICAgICAgICAgICAgaWYgKGMgPiBjb3VudClcbiAgICAgICAgICAgICAgICBjb3VudCA9IGM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvdW50O1xuICAgIH1cbiAgICBlbHNlIGlmIChpc1BhaXIobm9kZSkpIHtcbiAgICAgICAgY29uc3Qga2MgPSBnZXRBbGlhc0NvdW50KGRvYywgbm9kZS5rZXksIGFuY2hvcnMpO1xuICAgICAgICBjb25zdCB2YyA9IGdldEFsaWFzQ291bnQoZG9jLCBub2RlLnZhbHVlLCBhbmNob3JzKTtcbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KGtjLCB2Yyk7XG4gICAgfVxuICAgIHJldHVybiAxO1xufVxuXG5leHBvcnQgeyBBbGlhcyB9O1xuIiwgImltcG9ydCB7IGhhc0FuY2hvciB9IGZyb20gJy4vTm9kZS5qcyc7XG5cbi8qKlxuICogUmVjdXJzaXZlbHkgY29udmVydCBhbnkgbm9kZSBvciBpdHMgY29udGVudHMgdG8gbmF0aXZlIEphdmFTY3JpcHRcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgaW5wdXQgdmFsdWVcbiAqIEBwYXJhbSBhcmcgLSBJZiBgdmFsdWVgIGRlZmluZXMgYSBgdG9KU09OKClgIG1ldGhvZCwgdXNlIHRoaXNcbiAqICAgYXMgaXRzIGZpcnN0IGFyZ3VtZW50XG4gKiBAcGFyYW0gY3R4IC0gQ29udmVyc2lvbiBjb250ZXh0LCBvcmlnaW5hbGx5IHNldCBpbiBEb2N1bWVudCN0b0pTKCkuIElmXG4gKiAgIGB7IGtlZXA6IHRydWUgfWAgaXMgbm90IHNldCwgb3V0cHV0IHNob3VsZCBiZSBzdWl0YWJsZSBmb3IgSlNPTlxuICogICBzdHJpbmdpZmljYXRpb24uXG4gKi9cbmZ1bmN0aW9uIHRvSlModmFsdWUsIGFyZywgY3R4KSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKVxuICAgICAgICByZXR1cm4gdmFsdWUubWFwKCh2LCBpKSA9PiB0b0pTKHYsIFN0cmluZyhpKSwgY3R4KSk7XG4gICAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZS50b0pTT04gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgaWYgKCFjdHggfHwgIWhhc0FuY2hvcih2YWx1ZSkpXG4gICAgICAgICAgICByZXR1cm4gdmFsdWUudG9KU09OKGFyZywgY3R4KTtcbiAgICAgICAgY29uc3QgZGF0YSA9IHsgYWxpYXNDb3VudDogMCwgY291bnQ6IDEsIHJlczogdW5kZWZpbmVkIH07XG4gICAgICAgIGN0eC5hbmNob3JzLnNldCh2YWx1ZSwgZGF0YSk7XG4gICAgICAgIGN0eC5vbkNyZWF0ZSA9IHJlcyA9PiB7XG4gICAgICAgICAgICBkYXRhLnJlcyA9IHJlcztcbiAgICAgICAgICAgIGRlbGV0ZSBjdHgub25DcmVhdGU7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlcyA9IHZhbHVlLnRvSlNPTihhcmcsIGN0eCk7XG4gICAgICAgIGlmIChjdHgub25DcmVhdGUpXG4gICAgICAgICAgICBjdHgub25DcmVhdGUocmVzKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2JpZ2ludCcgJiYgIShjdHggJiYgY3R4LmtlZXApKVxuICAgICAgICByZXR1cm4gTnVtYmVyKHZhbHVlKTtcbiAgICByZXR1cm4gdmFsdWU7XG59XG5cbmV4cG9ydCB7IHRvSlMgfTtcbiIsICJpbXBvcnQgeyBOb2RlQmFzZSwgU0NBTEFSIH0gZnJvbSAnLi9Ob2RlLmpzJztcbmltcG9ydCB7IHRvSlMgfSBmcm9tICcuL3RvSlMuanMnO1xuXG5jb25zdCBpc1NjYWxhclZhbHVlID0gKHZhbHVlKSA9PiAhdmFsdWUgfHwgKHR5cGVvZiB2YWx1ZSAhPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnKTtcbmNsYXNzIFNjYWxhciBleHRlbmRzIE5vZGVCYXNlIHtcbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZSkge1xuICAgICAgICBzdXBlcihTQ0FMQVIpO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIHRvSlNPTihhcmcsIGN0eCkge1xuICAgICAgICByZXR1cm4gY3R4ICYmIGN0eC5rZWVwID8gdGhpcy52YWx1ZSA6IHRvSlModGhpcy52YWx1ZSwgYXJnLCBjdHgpO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIFN0cmluZyh0aGlzLnZhbHVlKTtcbiAgICB9XG59XG5TY2FsYXIuQkxPQ0tfRk9MREVEID0gJ0JMT0NLX0ZPTERFRCc7XG5TY2FsYXIuQkxPQ0tfTElURVJBTCA9ICdCTE9DS19MSVRFUkFMJztcblNjYWxhci5QTEFJTiA9ICdQTEFJTic7XG5TY2FsYXIuUVVPVEVfRE9VQkxFID0gJ1FVT1RFX0RPVUJMRSc7XG5TY2FsYXIuUVVPVEVfU0lOR0xFID0gJ1FVT1RFX1NJTkdMRSc7XG5cbmV4cG9ydCB7IFNjYWxhciwgaXNTY2FsYXJWYWx1ZSB9O1xuIiwgImltcG9ydCB7IEFsaWFzIH0gZnJvbSAnLi4vbm9kZXMvQWxpYXMuanMnO1xuaW1wb3J0IHsgaXNOb2RlLCBpc1BhaXIsIE1BUCwgU0VRLCBpc0RvY3VtZW50IH0gZnJvbSAnLi4vbm9kZXMvTm9kZS5qcyc7XG5pbXBvcnQgeyBTY2FsYXIgfSBmcm9tICcuLi9ub2Rlcy9TY2FsYXIuanMnO1xuXG5jb25zdCBkZWZhdWx0VGFnUHJlZml4ID0gJ3RhZzp5YW1sLm9yZywyMDAyOic7XG5mdW5jdGlvbiBmaW5kVGFnT2JqZWN0KHZhbHVlLCB0YWdOYW1lLCB0YWdzKSB7XG4gICAgaWYgKHRhZ05hbWUpIHtcbiAgICAgICAgY29uc3QgbWF0Y2ggPSB0YWdzLmZpbHRlcih0ID0+IHQudGFnID09PSB0YWdOYW1lKTtcbiAgICAgICAgY29uc3QgdGFnT2JqID0gbWF0Y2guZmluZCh0ID0+ICF0LmZvcm1hdCkgfHwgbWF0Y2hbMF07XG4gICAgICAgIGlmICghdGFnT2JqKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUYWcgJHt0YWdOYW1lfSBub3QgZm91bmRgKTtcbiAgICAgICAgcmV0dXJuIHRhZ09iajtcbiAgICB9XG4gICAgcmV0dXJuIHRhZ3MuZmluZCh0ID0+IHQuaWRlbnRpZnkgJiYgdC5pZGVudGlmeSh2YWx1ZSkgJiYgIXQuZm9ybWF0KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZU5vZGUodmFsdWUsIHRhZ05hbWUsIGN0eCkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgaWYgKGlzRG9jdW1lbnQodmFsdWUpKVxuICAgICAgICB2YWx1ZSA9IHZhbHVlLmNvbnRlbnRzO1xuICAgIGlmIChpc05vZGUodmFsdWUpKVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgaWYgKGlzUGFpcih2YWx1ZSkpIHtcbiAgICAgICAgY29uc3QgbWFwID0gKF9iID0gKF9hID0gY3R4LnNjaGVtYVtNQVBdKS5jcmVhdGVOb2RlKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSwgY3R4LnNjaGVtYSwgbnVsbCwgY3R4KTtcbiAgICAgICAgbWFwLml0ZW1zLnB1c2godmFsdWUpO1xuICAgICAgICByZXR1cm4gbWFwO1xuICAgIH1cbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBTdHJpbmcgfHxcbiAgICAgICAgdmFsdWUgaW5zdGFuY2VvZiBOdW1iZXIgfHxcbiAgICAgICAgdmFsdWUgaW5zdGFuY2VvZiBCb29sZWFuIHx8XG4gICAgICAgICh0eXBlb2YgQmlnSW50ID09PSAnZnVuY3Rpb24nICYmIHZhbHVlIGluc3RhbmNlb2YgQmlnSW50KSAvLyBub3Qgc3VwcG9ydGVkIGV2ZXJ5d2hlcmVcbiAgICApIHtcbiAgICAgICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zZXJpYWxpemVqc29ucHJvcGVydHlcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS52YWx1ZU9mKCk7XG4gICAgfVxuICAgIGNvbnN0IHsgYWxpYXNEdXBsaWNhdGVPYmplY3RzLCBvbkFuY2hvciwgb25UYWdPYmosIHNjaGVtYSwgc291cmNlT2JqZWN0cyB9ID0gY3R4O1xuICAgIC8vIERldGVjdCBkdXBsaWNhdGUgcmVmZXJlbmNlcyB0byB0aGUgc2FtZSBvYmplY3QgJiB1c2UgQWxpYXMgbm9kZXMgZm9yIGFsbFxuICAgIC8vIGFmdGVyIGZpcnN0LiBUaGUgYHJlZmAgd3JhcHBlciBhbGxvd3MgZm9yIGNpcmN1bGFyIHJlZmVyZW5jZXMgdG8gcmVzb2x2ZS5cbiAgICBsZXQgcmVmID0gdW5kZWZpbmVkO1xuICAgIGlmIChhbGlhc0R1cGxpY2F0ZU9iamVjdHMgJiYgdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgICAgICByZWYgPSBzb3VyY2VPYmplY3RzLmdldCh2YWx1ZSk7XG4gICAgICAgIGlmIChyZWYpIHtcbiAgICAgICAgICAgIGlmICghcmVmLmFuY2hvcilcbiAgICAgICAgICAgICAgICByZWYuYW5jaG9yID0gb25BbmNob3IodmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBBbGlhcyhyZWYuYW5jaG9yKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlZiA9IHsgYW5jaG9yOiBudWxsLCBub2RlOiBudWxsIH07XG4gICAgICAgICAgICBzb3VyY2VPYmplY3RzLnNldCh2YWx1ZSwgcmVmKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAodGFnTmFtZSAmJiB0YWdOYW1lLnN0YXJ0c1dpdGgoJyEhJykpXG4gICAgICAgIHRhZ05hbWUgPSBkZWZhdWx0VGFnUHJlZml4ICsgdGFnTmFtZS5zbGljZSgyKTtcbiAgICBsZXQgdGFnT2JqID0gZmluZFRhZ09iamVjdCh2YWx1ZSwgdGFnTmFtZSwgc2NoZW1hLnRhZ3MpO1xuICAgIGlmICghdGFnT2JqKSB7XG4gICAgICAgIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUudG9KU09OID09PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS50b0pTT04oKTtcbiAgICAgICAgaWYgKCF2YWx1ZSB8fCB0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBjb25zdCBub2RlID0gbmV3IFNjYWxhcih2YWx1ZSk7XG4gICAgICAgICAgICBpZiAocmVmKVxuICAgICAgICAgICAgICAgIHJlZi5ub2RlID0gbm9kZTtcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICB9XG4gICAgICAgIHRhZ09iaiA9XG4gICAgICAgICAgICB2YWx1ZSBpbnN0YW5jZW9mIE1hcFxuICAgICAgICAgICAgICAgID8gc2NoZW1hW01BUF1cbiAgICAgICAgICAgICAgICA6IFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QodmFsdWUpXG4gICAgICAgICAgICAgICAgICAgID8gc2NoZW1hW1NFUV1cbiAgICAgICAgICAgICAgICAgICAgOiBzY2hlbWFbTUFQXTtcbiAgICB9XG4gICAgaWYgKG9uVGFnT2JqKSB7XG4gICAgICAgIG9uVGFnT2JqKHRhZ09iaik7XG4gICAgICAgIGRlbGV0ZSBjdHgub25UYWdPYmo7XG4gICAgfVxuICAgIGNvbnN0IG5vZGUgPSAodGFnT2JqID09PSBudWxsIHx8IHRhZ09iaiA9PT0gdm9pZCAwID8gdm9pZCAwIDogdGFnT2JqLmNyZWF0ZU5vZGUpXG4gICAgICAgID8gdGFnT2JqLmNyZWF0ZU5vZGUoY3R4LnNjaGVtYSwgdmFsdWUsIGN0eClcbiAgICAgICAgOiBuZXcgU2NhbGFyKHZhbHVlKTtcbiAgICBpZiAodGFnTmFtZSlcbiAgICAgICAgbm9kZS50YWcgPSB0YWdOYW1lO1xuICAgIGlmIChyZWYpXG4gICAgICAgIHJlZi5ub2RlID0gbm9kZTtcbiAgICByZXR1cm4gbm9kZTtcbn1cblxuZXhwb3J0IHsgY3JlYXRlTm9kZSB9O1xuIiwgImltcG9ydCB7IGNyZWF0ZU5vZGUgfSBmcm9tICcuLi9kb2MvY3JlYXRlTm9kZS5qcyc7XG5pbXBvcnQgeyBOb2RlQmFzZSwgaXNOb2RlLCBpc1BhaXIsIGlzQ29sbGVjdGlvbiwgaXNTY2FsYXIgfSBmcm9tICcuL05vZGUuanMnO1xuXG5mdW5jdGlvbiBjb2xsZWN0aW9uRnJvbVBhdGgoc2NoZW1hLCBwYXRoLCB2YWx1ZSkge1xuICAgIGxldCB2ID0gdmFsdWU7XG4gICAgZm9yIChsZXQgaSA9IHBhdGgubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgY29uc3QgayA9IHBhdGhbaV07XG4gICAgICAgIGlmICh0eXBlb2YgayA9PT0gJ251bWJlcicgJiYgTnVtYmVyLmlzSW50ZWdlcihrKSAmJiBrID49IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGEgPSBbXTtcbiAgICAgICAgICAgIGFba10gPSB2O1xuICAgICAgICAgICAgdiA9IGE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2ID0gbmV3IE1hcChbW2ssIHZdXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZU5vZGUodiwgdW5kZWZpbmVkLCB7XG4gICAgICAgIGFsaWFzRHVwbGljYXRlT2JqZWN0czogZmFsc2UsXG4gICAgICAgIGtlZXBVbmRlZmluZWQ6IGZhbHNlLFxuICAgICAgICBvbkFuY2hvcjogKCkgPT4ge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIHNob3VsZCBub3QgaGFwcGVuLCBwbGVhc2UgcmVwb3J0IGEgYnVnLicpO1xuICAgICAgICB9LFxuICAgICAgICBzY2hlbWEsXG4gICAgICAgIHNvdXJjZU9iamVjdHM6IG5ldyBNYXAoKVxuICAgIH0pO1xufVxuLy8gbnVsbCwgdW5kZWZpbmVkLCBvciBhbiBlbXB0eSBub24tc3RyaW5nIGl0ZXJhYmxlIChlLmcuIFtdKVxuY29uc3QgaXNFbXB0eVBhdGggPSAocGF0aCkgPT4gcGF0aCA9PSBudWxsIHx8XG4gICAgKHR5cGVvZiBwYXRoID09PSAnb2JqZWN0JyAmJiAhIXBhdGhbU3ltYm9sLml0ZXJhdG9yXSgpLm5leHQoKS5kb25lKTtcbmNsYXNzIENvbGxlY3Rpb24gZXh0ZW5kcyBOb2RlQmFzZSB7XG4gICAgY29uc3RydWN0b3IodHlwZSwgc2NoZW1hKSB7XG4gICAgICAgIHN1cGVyKHR5cGUpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3NjaGVtYScsIHtcbiAgICAgICAgICAgIHZhbHVlOiBzY2hlbWEsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBjb3B5IG9mIHRoaXMgY29sbGVjdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzY2hlbWEgLSBJZiBkZWZpbmVkLCBvdmVyd3JpdGVzIHRoZSBvcmlnaW5hbCdzIHNjaGVtYVxuICAgICAqL1xuICAgIGNsb25lKHNjaGVtYSkge1xuICAgICAgICBjb25zdCBjb3B5ID0gT2JqZWN0LmNyZWF0ZShPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcyksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHRoaXMpKTtcbiAgICAgICAgaWYgKHNjaGVtYSlcbiAgICAgICAgICAgIGNvcHkuc2NoZW1hID0gc2NoZW1hO1xuICAgICAgICBjb3B5Lml0ZW1zID0gY29weS5pdGVtcy5tYXAoaXQgPT4gaXNOb2RlKGl0KSB8fCBpc1BhaXIoaXQpID8gaXQuY2xvbmUoc2NoZW1hKSA6IGl0KTtcbiAgICAgICAgaWYgKHRoaXMucmFuZ2UpXG4gICAgICAgICAgICBjb3B5LnJhbmdlID0gdGhpcy5yYW5nZS5zbGljZSgpO1xuICAgICAgICByZXR1cm4gY29weTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBhIHZhbHVlIHRvIHRoZSBjb2xsZWN0aW9uLiBGb3IgYCEhbWFwYCBhbmQgYCEhb21hcGAgdGhlIHZhbHVlIG11c3RcbiAgICAgKiBiZSBhIFBhaXIgaW5zdGFuY2Ugb3IgYSBgeyBrZXksIHZhbHVlIH1gIG9iamVjdCwgd2hpY2ggbWF5IG5vdCBoYXZlIGEga2V5XG4gICAgICogdGhhdCBhbHJlYWR5IGV4aXN0cyBpbiB0aGUgbWFwLlxuICAgICAqL1xuICAgIGFkZEluKHBhdGgsIHZhbHVlKSB7XG4gICAgICAgIGlmIChpc0VtcHR5UGF0aChwYXRoKSlcbiAgICAgICAgICAgIHRoaXMuYWRkKHZhbHVlKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBba2V5LCAuLi5yZXN0XSA9IHBhdGg7XG4gICAgICAgICAgICBjb25zdCBub2RlID0gdGhpcy5nZXQoa2V5LCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChpc0NvbGxlY3Rpb24obm9kZSkpXG4gICAgICAgICAgICAgICAgbm9kZS5hZGRJbihyZXN0LCB2YWx1ZSk7XG4gICAgICAgICAgICBlbHNlIGlmIChub2RlID09PSB1bmRlZmluZWQgJiYgdGhpcy5zY2hlbWEpXG4gICAgICAgICAgICAgICAgdGhpcy5zZXQoa2V5LCBjb2xsZWN0aW9uRnJvbVBhdGgodGhpcy5zY2hlbWEsIHJlc3QsIHZhbHVlKSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBZQU1MIGNvbGxlY3Rpb24gYXQgJHtrZXl9LiBSZW1haW5pbmcgcGF0aDogJHtyZXN0fWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYSB2YWx1ZSBmcm9tIHRoZSBjb2xsZWN0aW9uLlxuICAgICAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgaXRlbSB3YXMgZm91bmQgYW5kIHJlbW92ZWQuXG4gICAgICovXG4gICAgZGVsZXRlSW4ocGF0aCkge1xuICAgICAgICBjb25zdCBba2V5LCAuLi5yZXN0XSA9IHBhdGg7XG4gICAgICAgIGlmIChyZXN0Lmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRlbGV0ZShrZXkpO1xuICAgICAgICBjb25zdCBub2RlID0gdGhpcy5nZXQoa2V5LCB0cnVlKTtcbiAgICAgICAgaWYgKGlzQ29sbGVjdGlvbihub2RlKSlcbiAgICAgICAgICAgIHJldHVybiBub2RlLmRlbGV0ZUluKHJlc3QpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIFlBTUwgY29sbGVjdGlvbiBhdCAke2tleX0uIFJlbWFpbmluZyBwYXRoOiAke3Jlc3R9YCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgaXRlbSBhdCBga2V5YCwgb3IgYHVuZGVmaW5lZGAgaWYgbm90IGZvdW5kLiBCeSBkZWZhdWx0IHVud3JhcHNcbiAgICAgKiBzY2FsYXIgdmFsdWVzIGZyb20gdGhlaXIgc3Vycm91bmRpbmcgbm9kZTsgdG8gZGlzYWJsZSBzZXQgYGtlZXBTY2FsYXJgIHRvXG4gICAgICogYHRydWVgIChjb2xsZWN0aW9ucyBhcmUgYWx3YXlzIHJldHVybmVkIGludGFjdCkuXG4gICAgICovXG4gICAgZ2V0SW4ocGF0aCwga2VlcFNjYWxhcikge1xuICAgICAgICBjb25zdCBba2V5LCAuLi5yZXN0XSA9IHBhdGg7XG4gICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLmdldChrZXksIHRydWUpO1xuICAgICAgICBpZiAocmVzdC5sZW5ndGggPT09IDApXG4gICAgICAgICAgICByZXR1cm4gIWtlZXBTY2FsYXIgJiYgaXNTY2FsYXIobm9kZSkgPyBub2RlLnZhbHVlIDogbm9kZTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIGlzQ29sbGVjdGlvbihub2RlKSA/IG5vZGUuZ2V0SW4ocmVzdCwga2VlcFNjYWxhcikgOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGhhc0FsbE51bGxWYWx1ZXMoYWxsb3dTY2FsYXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXRlbXMuZXZlcnkobm9kZSA9PiB7XG4gICAgICAgICAgICBpZiAoIWlzUGFpcihub2RlKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBjb25zdCBuID0gbm9kZS52YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiAobiA9PSBudWxsIHx8XG4gICAgICAgICAgICAgICAgKGFsbG93U2NhbGFyICYmXG4gICAgICAgICAgICAgICAgICAgIGlzU2NhbGFyKG4pICYmXG4gICAgICAgICAgICAgICAgICAgIG4udmFsdWUgPT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgICAgICAhbi5jb21tZW50QmVmb3JlICYmXG4gICAgICAgICAgICAgICAgICAgICFuLmNvbW1lbnQgJiZcbiAgICAgICAgICAgICAgICAgICAgIW4udGFnKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGhlIGNvbGxlY3Rpb24gaW5jbHVkZXMgYSB2YWx1ZSB3aXRoIHRoZSBrZXkgYGtleWAuXG4gICAgICovXG4gICAgaGFzSW4ocGF0aCkge1xuICAgICAgICBjb25zdCBba2V5LCAuLi5yZXN0XSA9IHBhdGg7XG4gICAgICAgIGlmIChyZXN0Lmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmhhcyhrZXkpO1xuICAgICAgICBjb25zdCBub2RlID0gdGhpcy5nZXQoa2V5LCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIGlzQ29sbGVjdGlvbihub2RlKSA/IG5vZGUuaGFzSW4ocmVzdCkgOiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyBhIHZhbHVlIGluIHRoaXMgY29sbGVjdGlvbi4gRm9yIGAhIXNldGAsIGB2YWx1ZWAgbmVlZHMgdG8gYmUgYVxuICAgICAqIGJvb2xlYW4gdG8gYWRkL3JlbW92ZSB0aGUgaXRlbSBmcm9tIHRoZSBzZXQuXG4gICAgICovXG4gICAgc2V0SW4ocGF0aCwgdmFsdWUpIHtcbiAgICAgICAgY29uc3QgW2tleSwgLi4ucmVzdF0gPSBwYXRoO1xuICAgICAgICBpZiAocmVzdC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuZ2V0KGtleSwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAoaXNDb2xsZWN0aW9uKG5vZGUpKVxuICAgICAgICAgICAgICAgIG5vZGUuc2V0SW4ocmVzdCwgdmFsdWUpO1xuICAgICAgICAgICAgZWxzZSBpZiAobm9kZSA9PT0gdW5kZWZpbmVkICYmIHRoaXMuc2NoZW1hKVxuICAgICAgICAgICAgICAgIHRoaXMuc2V0KGtleSwgY29sbGVjdGlvbkZyb21QYXRoKHRoaXMuc2NoZW1hLCByZXN0LCB2YWx1ZSkpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgWUFNTCBjb2xsZWN0aW9uIGF0ICR7a2V5fS4gUmVtYWluaW5nIHBhdGg6ICR7cmVzdH1gKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbkNvbGxlY3Rpb24ubWF4Rmxvd1N0cmluZ1NpbmdsZUxpbmVMZW5ndGggPSA2MDtcblxuZXhwb3J0IHsgQ29sbGVjdGlvbiwgY29sbGVjdGlvbkZyb21QYXRoLCBpc0VtcHR5UGF0aCB9O1xuIiwgIi8qKlxuICogU3RyaW5naWZpZXMgYSBjb21tZW50LlxuICpcbiAqIEVtcHR5IGNvbW1lbnQgbGluZXMgYXJlIGxlZnQgZW1wdHksXG4gKiBsaW5lcyBjb25zaXN0aW5nIG9mIGEgc2luZ2xlIHNwYWNlIGFyZSByZXBsYWNlZCBieSBgI2AsXG4gKiBhbmQgYWxsIG90aGVyIGxpbmVzIGFyZSBwcmVmaXhlZCB3aXRoIGEgYCNgLlxuICovXG5jb25zdCBzdHJpbmdpZnlDb21tZW50ID0gKHN0cikgPT4gc3RyLnJlcGxhY2UoL14oPyEkKSg/OiAkKT8vZ20sICcjJyk7XG5mdW5jdGlvbiBpbmRlbnRDb21tZW50KGNvbW1lbnQsIGluZGVudCkge1xuICAgIGlmICgvXlxcbiskLy50ZXN0KGNvbW1lbnQpKVxuICAgICAgICByZXR1cm4gY29tbWVudC5zdWJzdHJpbmcoMSk7XG4gICAgcmV0dXJuIGluZGVudCA/IGNvbW1lbnQucmVwbGFjZSgvXig/ISAqJCkvZ20sIGluZGVudCkgOiBjb21tZW50O1xufVxuY29uc3QgbGluZUNvbW1lbnQgPSAoc3RyLCBpbmRlbnQsIGNvbW1lbnQpID0+IGNvbW1lbnQuaW5jbHVkZXMoJ1xcbicpXG4gICAgPyAnXFxuJyArIGluZGVudENvbW1lbnQoY29tbWVudCwgaW5kZW50KVxuICAgIDogKHN0ci5lbmRzV2l0aCgnICcpID8gJycgOiAnICcpICsgY29tbWVudDtcblxuZXhwb3J0IHsgaW5kZW50Q29tbWVudCwgbGluZUNvbW1lbnQsIHN0cmluZ2lmeUNvbW1lbnQgfTtcbiIsICJjb25zdCBGT0xEX0ZMT1cgPSAnZmxvdyc7XG5jb25zdCBGT0xEX0JMT0NLID0gJ2Jsb2NrJztcbmNvbnN0IEZPTERfUVVPVEVEID0gJ3F1b3RlZCc7XG4vKipcbiAqIFRyaWVzIHRvIGtlZXAgaW5wdXQgYXQgdXAgdG8gYGxpbmVXaWR0aGAgY2hhcmFjdGVycywgc3BsaXR0aW5nIG9ubHkgb24gc3BhY2VzXG4gKiBub3QgZm9sbG93ZWQgYnkgbmV3bGluZXMgb3Igc3BhY2VzIHVubGVzcyBgbW9kZWAgaXMgYCdxdW90ZWQnYC4gTGluZXMgYXJlXG4gKiB0ZXJtaW5hdGVkIHdpdGggYFxcbmAgYW5kIHN0YXJ0ZWQgd2l0aCBgaW5kZW50YC5cbiAqL1xuZnVuY3Rpb24gZm9sZEZsb3dMaW5lcyh0ZXh0LCBpbmRlbnQsIG1vZGUgPSAnZmxvdycsIHsgaW5kZW50QXRTdGFydCwgbGluZVdpZHRoID0gODAsIG1pbkNvbnRlbnRXaWR0aCA9IDIwLCBvbkZvbGQsIG9uT3ZlcmZsb3cgfSA9IHt9KSB7XG4gICAgaWYgKCFsaW5lV2lkdGggfHwgbGluZVdpZHRoIDwgMClcbiAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgY29uc3QgZW5kU3RlcCA9IE1hdGgubWF4KDEgKyBtaW5Db250ZW50V2lkdGgsIDEgKyBsaW5lV2lkdGggLSBpbmRlbnQubGVuZ3RoKTtcbiAgICBpZiAodGV4dC5sZW5ndGggPD0gZW5kU3RlcClcbiAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgY29uc3QgZm9sZHMgPSBbXTtcbiAgICBjb25zdCBlc2NhcGVkRm9sZHMgPSB7fTtcbiAgICBsZXQgZW5kID0gbGluZVdpZHRoIC0gaW5kZW50Lmxlbmd0aDtcbiAgICBpZiAodHlwZW9mIGluZGVudEF0U3RhcnQgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGlmIChpbmRlbnRBdFN0YXJ0ID4gbGluZVdpZHRoIC0gTWF0aC5tYXgoMiwgbWluQ29udGVudFdpZHRoKSlcbiAgICAgICAgICAgIGZvbGRzLnB1c2goMCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGVuZCA9IGxpbmVXaWR0aCAtIGluZGVudEF0U3RhcnQ7XG4gICAgfVxuICAgIGxldCBzcGxpdCA9IHVuZGVmaW5lZDtcbiAgICBsZXQgcHJldiA9IHVuZGVmaW5lZDtcbiAgICBsZXQgb3ZlcmZsb3cgPSBmYWxzZTtcbiAgICBsZXQgaSA9IC0xO1xuICAgIGxldCBlc2NTdGFydCA9IC0xO1xuICAgIGxldCBlc2NFbmQgPSAtMTtcbiAgICBpZiAobW9kZSA9PT0gRk9MRF9CTE9DSykge1xuICAgICAgICBpID0gY29uc3VtZU1vcmVJbmRlbnRlZExpbmVzKHRleHQsIGkpO1xuICAgICAgICBpZiAoaSAhPT0gLTEpXG4gICAgICAgICAgICBlbmQgPSBpICsgZW5kU3RlcDtcbiAgICB9XG4gICAgZm9yIChsZXQgY2g7IChjaCA9IHRleHRbKGkgKz0gMSldKTspIHtcbiAgICAgICAgaWYgKG1vZGUgPT09IEZPTERfUVVPVEVEICYmIGNoID09PSAnXFxcXCcpIHtcbiAgICAgICAgICAgIGVzY1N0YXJ0ID0gaTtcbiAgICAgICAgICAgIHN3aXRjaCAodGV4dFtpICsgMV0pIHtcbiAgICAgICAgICAgICAgICBjYXNlICd4JzpcbiAgICAgICAgICAgICAgICAgICAgaSArPSAzO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICd1JzpcbiAgICAgICAgICAgICAgICAgICAgaSArPSA1O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdVJzpcbiAgICAgICAgICAgICAgICAgICAgaSArPSA5O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBpICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlc2NFbmQgPSBpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaCA9PT0gJ1xcbicpIHtcbiAgICAgICAgICAgIGlmIChtb2RlID09PSBGT0xEX0JMT0NLKVxuICAgICAgICAgICAgICAgIGkgPSBjb25zdW1lTW9yZUluZGVudGVkTGluZXModGV4dCwgaSk7XG4gICAgICAgICAgICBlbmQgPSBpICsgZW5kU3RlcDtcbiAgICAgICAgICAgIHNwbGl0ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGNoID09PSAnICcgJiZcbiAgICAgICAgICAgICAgICBwcmV2ICYmXG4gICAgICAgICAgICAgICAgcHJldiAhPT0gJyAnICYmXG4gICAgICAgICAgICAgICAgcHJldiAhPT0gJ1xcbicgJiZcbiAgICAgICAgICAgICAgICBwcmV2ICE9PSAnXFx0Jykge1xuICAgICAgICAgICAgICAgIC8vIHNwYWNlIHN1cnJvdW5kZWQgYnkgbm9uLXNwYWNlIGNhbiBiZSByZXBsYWNlZCB3aXRoIG5ld2xpbmUgKyBpbmRlbnRcbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0ID0gdGV4dFtpICsgMV07XG4gICAgICAgICAgICAgICAgaWYgKG5leHQgJiYgbmV4dCAhPT0gJyAnICYmIG5leHQgIT09ICdcXG4nICYmIG5leHQgIT09ICdcXHQnKVxuICAgICAgICAgICAgICAgICAgICBzcGxpdCA9IGk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaSA+PSBlbmQpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3BsaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9sZHMucHVzaChzcGxpdCk7XG4gICAgICAgICAgICAgICAgICAgIGVuZCA9IHNwbGl0ICsgZW5kU3RlcDtcbiAgICAgICAgICAgICAgICAgICAgc3BsaXQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1vZGUgPT09IEZPTERfUVVPVEVEKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHdoaXRlLXNwYWNlIGNvbGxlY3RlZCBhdCBlbmQgbWF5IHN0cmV0Y2ggcGFzdCBsaW5lV2lkdGhcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHByZXYgPT09ICcgJyB8fCBwcmV2ID09PSAnXFx0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJldiA9IGNoO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2ggPSB0ZXh0WyhpICs9IDEpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJmbG93ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBBY2NvdW50IGZvciBuZXdsaW5lIGVzY2FwZSwgYnV0IGRvbid0IGJyZWFrIHByZWNlZGluZyBlc2NhcGVcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaiA9IGkgPiBlc2NFbmQgKyAxID8gaSAtIDIgOiBlc2NTdGFydCAtIDE7XG4gICAgICAgICAgICAgICAgICAgIC8vIEJhaWwgb3V0IGlmIGxpbmVXaWR0aCAmIG1pbkNvbnRlbnRXaWR0aCBhcmUgc2hvcnRlciB0aGFuIGFuIGVzY2FwZSBzdHJpbmdcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVzY2FwZWRGb2xkc1tqXSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0ZXh0O1xuICAgICAgICAgICAgICAgICAgICBmb2xkcy5wdXNoKGopO1xuICAgICAgICAgICAgICAgICAgICBlc2NhcGVkRm9sZHNbal0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBlbmQgPSBqICsgZW5kU3RlcDtcbiAgICAgICAgICAgICAgICAgICAgc3BsaXQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBvdmVyZmxvdyA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHByZXYgPSBjaDtcbiAgICB9XG4gICAgaWYgKG92ZXJmbG93ICYmIG9uT3ZlcmZsb3cpXG4gICAgICAgIG9uT3ZlcmZsb3coKTtcbiAgICBpZiAoZm9sZHMubGVuZ3RoID09PSAwKVxuICAgICAgICByZXR1cm4gdGV4dDtcbiAgICBpZiAob25Gb2xkKVxuICAgICAgICBvbkZvbGQoKTtcbiAgICBsZXQgcmVzID0gdGV4dC5zbGljZSgwLCBmb2xkc1swXSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmb2xkcy5sZW5ndGg7ICsraSkge1xuICAgICAgICBjb25zdCBmb2xkID0gZm9sZHNbaV07XG4gICAgICAgIGNvbnN0IGVuZCA9IGZvbGRzW2kgKyAxXSB8fCB0ZXh0Lmxlbmd0aDtcbiAgICAgICAgaWYgKGZvbGQgPT09IDApXG4gICAgICAgICAgICByZXMgPSBgXFxuJHtpbmRlbnR9JHt0ZXh0LnNsaWNlKDAsIGVuZCl9YDtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAobW9kZSA9PT0gRk9MRF9RVU9URUQgJiYgZXNjYXBlZEZvbGRzW2ZvbGRdKVxuICAgICAgICAgICAgICAgIHJlcyArPSBgJHt0ZXh0W2ZvbGRdfVxcXFxgO1xuICAgICAgICAgICAgcmVzICs9IGBcXG4ke2luZGVudH0ke3RleHQuc2xpY2UoZm9sZCArIDEsIGVuZCl9YDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuLyoqXG4gKiBQcmVzdW1lcyBgaSArIDFgIGlzIGF0IHRoZSBzdGFydCBvZiBhIGxpbmVcbiAqIEByZXR1cm5zIGluZGV4IG9mIGxhc3QgbmV3bGluZSBpbiBtb3JlLWluZGVudGVkIGJsb2NrXG4gKi9cbmZ1bmN0aW9uIGNvbnN1bWVNb3JlSW5kZW50ZWRMaW5lcyh0ZXh0LCBpKSB7XG4gICAgbGV0IGNoID0gdGV4dFtpICsgMV07XG4gICAgd2hpbGUgKGNoID09PSAnICcgfHwgY2ggPT09ICdcXHQnKSB7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIGNoID0gdGV4dFsoaSArPSAxKV07XG4gICAgICAgIH0gd2hpbGUgKGNoICYmIGNoICE9PSAnXFxuJyk7XG4gICAgICAgIGNoID0gdGV4dFtpICsgMV07XG4gICAgfVxuICAgIHJldHVybiBpO1xufVxuXG5leHBvcnQgeyBGT0xEX0JMT0NLLCBGT0xEX0ZMT1csIEZPTERfUVVPVEVELCBmb2xkRmxvd0xpbmVzIH07XG4iLCAiaW1wb3J0IHsgU2NhbGFyIH0gZnJvbSAnLi4vbm9kZXMvU2NhbGFyLmpzJztcbmltcG9ydCB7IGZvbGRGbG93TGluZXMsIEZPTERfUVVPVEVELCBGT0xEX0ZMT1csIEZPTERfQkxPQ0sgfSBmcm9tICcuL2ZvbGRGbG93TGluZXMuanMnO1xuXG5jb25zdCBnZXRGb2xkT3B0aW9ucyA9IChjdHgpID0+ICh7XG4gICAgaW5kZW50QXRTdGFydDogY3R4LmluZGVudEF0U3RhcnQsXG4gICAgbGluZVdpZHRoOiBjdHgub3B0aW9ucy5saW5lV2lkdGgsXG4gICAgbWluQ29udGVudFdpZHRoOiBjdHgub3B0aW9ucy5taW5Db250ZW50V2lkdGhcbn0pO1xuLy8gQWxzbyBjaGVja3MgZm9yIGxpbmVzIHN0YXJ0aW5nIHdpdGggJSwgYXMgcGFyc2luZyB0aGUgb3V0cHV0IGFzIFlBTUwgMS4xIHdpbGxcbi8vIHByZXN1bWUgdGhhdCdzIHN0YXJ0aW5nIGEgbmV3IGRvY3VtZW50LlxuY29uc3QgY29udGFpbnNEb2N1bWVudE1hcmtlciA9IChzdHIpID0+IC9eKCV8LS0tfFxcLlxcLlxcLikvbS50ZXN0KHN0cik7XG5mdW5jdGlvbiBsaW5lTGVuZ3RoT3ZlckxpbWl0KHN0ciwgbGluZVdpZHRoLCBpbmRlbnRMZW5ndGgpIHtcbiAgICBpZiAoIWxpbmVXaWR0aCB8fCBsaW5lV2lkdGggPCAwKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgY29uc3QgbGltaXQgPSBsaW5lV2lkdGggLSBpbmRlbnRMZW5ndGg7XG4gICAgY29uc3Qgc3RyTGVuID0gc3RyLmxlbmd0aDtcbiAgICBpZiAoc3RyTGVuIDw9IGxpbWl0KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgZm9yIChsZXQgaSA9IDAsIHN0YXJ0ID0gMDsgaSA8IHN0ckxlbjsgKytpKSB7XG4gICAgICAgIGlmIChzdHJbaV0gPT09ICdcXG4nKSB7XG4gICAgICAgICAgICBpZiAoaSAtIHN0YXJ0ID4gbGltaXQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBzdGFydCA9IGkgKyAxO1xuICAgICAgICAgICAgaWYgKHN0ckxlbiAtIHN0YXJ0IDw9IGxpbWl0KVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGRvdWJsZVF1b3RlZFN0cmluZyh2YWx1ZSwgY3R4KSB7XG4gICAgY29uc3QganNvbiA9IEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcbiAgICBpZiAoY3R4Lm9wdGlvbnMuZG91YmxlUXVvdGVkQXNKU09OKVxuICAgICAgICByZXR1cm4ganNvbjtcbiAgICBjb25zdCB7IGltcGxpY2l0S2V5IH0gPSBjdHg7XG4gICAgY29uc3QgbWluTXVsdGlMaW5lTGVuZ3RoID0gY3R4Lm9wdGlvbnMuZG91YmxlUXVvdGVkTWluTXVsdGlMaW5lTGVuZ3RoO1xuICAgIGNvbnN0IGluZGVudCA9IGN0eC5pbmRlbnQgfHwgKGNvbnRhaW5zRG9jdW1lbnRNYXJrZXIodmFsdWUpID8gJyAgJyA6ICcnKTtcbiAgICBsZXQgc3RyID0gJyc7XG4gICAgbGV0IHN0YXJ0ID0gMDtcbiAgICBmb3IgKGxldCBpID0gMCwgY2ggPSBqc29uW2ldOyBjaDsgY2ggPSBqc29uWysraV0pIHtcbiAgICAgICAgaWYgKGNoID09PSAnICcgJiYganNvbltpICsgMV0gPT09ICdcXFxcJyAmJiBqc29uW2kgKyAyXSA9PT0gJ24nKSB7XG4gICAgICAgICAgICAvLyBzcGFjZSBiZWZvcmUgbmV3bGluZSBuZWVkcyB0byBiZSBlc2NhcGVkIHRvIG5vdCBiZSBmb2xkZWRcbiAgICAgICAgICAgIHN0ciArPSBqc29uLnNsaWNlKHN0YXJ0LCBpKSArICdcXFxcICc7XG4gICAgICAgICAgICBpICs9IDE7XG4gICAgICAgICAgICBzdGFydCA9IGk7XG4gICAgICAgICAgICBjaCA9ICdcXFxcJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2ggPT09ICdcXFxcJylcbiAgICAgICAgICAgIHN3aXRjaCAoanNvbltpICsgMV0pIHtcbiAgICAgICAgICAgICAgICBjYXNlICd1JzpcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9IGpzb24uc2xpY2Uoc3RhcnQsIGkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY29kZSA9IGpzb24uc3Vic3RyKGkgKyAyLCA0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoY29kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJzAwMDAnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gJ1xcXFwwJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnMDAwNyc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSAnXFxcXGEnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICcwMDBiJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9ICdcXFxcdic7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJzAwMWInOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gJ1xcXFxlJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnMDA4NSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSAnXFxcXE4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICcwMGEwJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9ICdcXFxcXyc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJzIwMjgnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gJ1xcXFxMJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnMjAyOSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSAnXFxcXFAnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29kZS5zdWJzdHIoMCwgMikgPT09ICcwMCcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gJ1xcXFx4JyArIGNvZGUuc3Vic3RyKDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0ganNvbi5zdWJzdHIoaSwgNik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpICs9IDU7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydCA9IGkgKyAxO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ24nOlxuICAgICAgICAgICAgICAgICAgICBpZiAoaW1wbGljaXRLZXkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIGpzb25baSArIDJdID09PSAnXCInIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBqc29uLmxlbmd0aCA8IG1pbk11bHRpTGluZUxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaSArPSAxO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZm9sZGluZyB3aWxsIGVhdCBmaXJzdCBuZXdsaW5lXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0ganNvbi5zbGljZShzdGFydCwgaSkgKyAnXFxuXFxuJztcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChqc29uW2kgKyAyXSA9PT0gJ1xcXFwnICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAganNvbltpICsgM10gPT09ICduJyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpzb25baSArIDRdICE9PSAnXCInKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9ICdcXG4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgKz0gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSBpbmRlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzcGFjZSBhZnRlciBuZXdsaW5lIG5lZWRzIHRvIGJlIGVzY2FwZWQgdG8gbm90IGJlIGZvbGRlZFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGpzb25baSArIDJdID09PSAnICcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9ICdcXFxcJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gaSArIDE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaSArPSAxO1xuICAgICAgICAgICAgfVxuICAgIH1cbiAgICBzdHIgPSBzdGFydCA/IHN0ciArIGpzb24uc2xpY2Uoc3RhcnQpIDoganNvbjtcbiAgICByZXR1cm4gaW1wbGljaXRLZXlcbiAgICAgICAgPyBzdHJcbiAgICAgICAgOiBmb2xkRmxvd0xpbmVzKHN0ciwgaW5kZW50LCBGT0xEX1FVT1RFRCwgZ2V0Rm9sZE9wdGlvbnMoY3R4KSk7XG59XG5mdW5jdGlvbiBzaW5nbGVRdW90ZWRTdHJpbmcodmFsdWUsIGN0eCkge1xuICAgIGlmIChjdHgub3B0aW9ucy5zaW5nbGVRdW90ZSA9PT0gZmFsc2UgfHxcbiAgICAgICAgKGN0eC5pbXBsaWNpdEtleSAmJiB2YWx1ZS5pbmNsdWRlcygnXFxuJykpIHx8XG4gICAgICAgIC9bIFxcdF1cXG58XFxuWyBcXHRdLy50ZXN0KHZhbHVlKSAvLyBzaW5nbGUgcXVvdGVkIHN0cmluZyBjYW4ndCBoYXZlIGxlYWRpbmcgb3IgdHJhaWxpbmcgd2hpdGVzcGFjZSBhcm91bmQgbmV3bGluZVxuICAgIClcbiAgICAgICAgcmV0dXJuIGRvdWJsZVF1b3RlZFN0cmluZyh2YWx1ZSwgY3R4KTtcbiAgICBjb25zdCBpbmRlbnQgPSBjdHguaW5kZW50IHx8IChjb250YWluc0RvY3VtZW50TWFya2VyKHZhbHVlKSA/ICcgICcgOiAnJyk7XG4gICAgY29uc3QgcmVzID0gXCInXCIgKyB2YWx1ZS5yZXBsYWNlKC8nL2csIFwiJydcIikucmVwbGFjZSgvXFxuKy9nLCBgJCZcXG4ke2luZGVudH1gKSArIFwiJ1wiO1xuICAgIHJldHVybiBjdHguaW1wbGljaXRLZXlcbiAgICAgICAgPyByZXNcbiAgICAgICAgOiBmb2xkRmxvd0xpbmVzKHJlcywgaW5kZW50LCBGT0xEX0ZMT1csIGdldEZvbGRPcHRpb25zKGN0eCkpO1xufVxuZnVuY3Rpb24gcXVvdGVkU3RyaW5nKHZhbHVlLCBjdHgpIHtcbiAgICBjb25zdCB7IHNpbmdsZVF1b3RlIH0gPSBjdHgub3B0aW9ucztcbiAgICBsZXQgcXM7XG4gICAgaWYgKHNpbmdsZVF1b3RlID09PSBmYWxzZSlcbiAgICAgICAgcXMgPSBkb3VibGVRdW90ZWRTdHJpbmc7XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IGhhc0RvdWJsZSA9IHZhbHVlLmluY2x1ZGVzKCdcIicpO1xuICAgICAgICBjb25zdCBoYXNTaW5nbGUgPSB2YWx1ZS5pbmNsdWRlcyhcIidcIik7XG4gICAgICAgIGlmIChoYXNEb3VibGUgJiYgIWhhc1NpbmdsZSlcbiAgICAgICAgICAgIHFzID0gc2luZ2xlUXVvdGVkU3RyaW5nO1xuICAgICAgICBlbHNlIGlmIChoYXNTaW5nbGUgJiYgIWhhc0RvdWJsZSlcbiAgICAgICAgICAgIHFzID0gZG91YmxlUXVvdGVkU3RyaW5nO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBxcyA9IHNpbmdsZVF1b3RlID8gc2luZ2xlUXVvdGVkU3RyaW5nIDogZG91YmxlUXVvdGVkU3RyaW5nO1xuICAgIH1cbiAgICByZXR1cm4gcXModmFsdWUsIGN0eCk7XG59XG5mdW5jdGlvbiBibG9ja1N0cmluZyh7IGNvbW1lbnQsIHR5cGUsIHZhbHVlIH0sIGN0eCwgb25Db21tZW50LCBvbkNob21wS2VlcCkge1xuICAgIGNvbnN0IHsgYmxvY2tRdW90ZSwgY29tbWVudFN0cmluZywgbGluZVdpZHRoIH0gPSBjdHgub3B0aW9ucztcbiAgICAvLyAxLiBCbG9jayBjYW4ndCBlbmQgaW4gd2hpdGVzcGFjZSB1bmxlc3MgdGhlIGxhc3QgbGluZSBpcyBub24tZW1wdHkuXG4gICAgLy8gMi4gU3RyaW5ncyBjb25zaXN0aW5nIG9mIG9ubHkgd2hpdGVzcGFjZSBhcmUgYmVzdCByZW5kZXJlZCBleHBsaWNpdGx5LlxuICAgIGlmICghYmxvY2tRdW90ZSB8fCAvXFxuW1xcdCBdKyQvLnRlc3QodmFsdWUpIHx8IC9eXFxzKiQvLnRlc3QodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBxdW90ZWRTdHJpbmcodmFsdWUsIGN0eCk7XG4gICAgfVxuICAgIGNvbnN0IGluZGVudCA9IGN0eC5pbmRlbnQgfHxcbiAgICAgICAgKGN0eC5mb3JjZUJsb2NrSW5kZW50IHx8IGNvbnRhaW5zRG9jdW1lbnRNYXJrZXIodmFsdWUpID8gJyAgJyA6ICcnKTtcbiAgICBjb25zdCBsaXRlcmFsID0gYmxvY2tRdW90ZSA9PT0gJ2xpdGVyYWwnXG4gICAgICAgID8gdHJ1ZVxuICAgICAgICA6IGJsb2NrUXVvdGUgPT09ICdmb2xkZWQnIHx8IHR5cGUgPT09IFNjYWxhci5CTE9DS19GT0xERURcbiAgICAgICAgICAgID8gZmFsc2VcbiAgICAgICAgICAgIDogdHlwZSA9PT0gU2NhbGFyLkJMT0NLX0xJVEVSQUxcbiAgICAgICAgICAgICAgICA/IHRydWVcbiAgICAgICAgICAgICAgICA6ICFsaW5lTGVuZ3RoT3ZlckxpbWl0KHZhbHVlLCBsaW5lV2lkdGgsIGluZGVudC5sZW5ndGgpO1xuICAgIGlmICghdmFsdWUpXG4gICAgICAgIHJldHVybiBsaXRlcmFsID8gJ3xcXG4nIDogJz5cXG4nO1xuICAgIC8vIGRldGVybWluZSBjaG9tcGluZyBmcm9tIHdoaXRlc3BhY2UgYXQgdmFsdWUgZW5kXG4gICAgbGV0IGNob21wO1xuICAgIGxldCBlbmRTdGFydDtcbiAgICBmb3IgKGVuZFN0YXJ0ID0gdmFsdWUubGVuZ3RoOyBlbmRTdGFydCA+IDA7IC0tZW5kU3RhcnQpIHtcbiAgICAgICAgY29uc3QgY2ggPSB2YWx1ZVtlbmRTdGFydCAtIDFdO1xuICAgICAgICBpZiAoY2ggIT09ICdcXG4nICYmIGNoICE9PSAnXFx0JyAmJiBjaCAhPT0gJyAnKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGxldCBlbmQgPSB2YWx1ZS5zdWJzdHJpbmcoZW5kU3RhcnQpO1xuICAgIGNvbnN0IGVuZE5sUG9zID0gZW5kLmluZGV4T2YoJ1xcbicpO1xuICAgIGlmIChlbmRObFBvcyA9PT0gLTEpIHtcbiAgICAgICAgY2hvbXAgPSAnLSc7IC8vIHN0cmlwXG4gICAgfVxuICAgIGVsc2UgaWYgKHZhbHVlID09PSBlbmQgfHwgZW5kTmxQb3MgIT09IGVuZC5sZW5ndGggLSAxKSB7XG4gICAgICAgIGNob21wID0gJysnOyAvLyBrZWVwXG4gICAgICAgIGlmIChvbkNob21wS2VlcClcbiAgICAgICAgICAgIG9uQ2hvbXBLZWVwKCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjaG9tcCA9ICcnOyAvLyBjbGlwXG4gICAgfVxuICAgIGlmIChlbmQpIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5zbGljZSgwLCAtZW5kLmxlbmd0aCk7XG4gICAgICAgIGlmIChlbmRbZW5kLmxlbmd0aCAtIDFdID09PSAnXFxuJylcbiAgICAgICAgICAgIGVuZCA9IGVuZC5zbGljZSgwLCAtMSk7XG4gICAgICAgIGVuZCA9IGVuZC5yZXBsYWNlKC9cXG4rKD8hXFxufCQpL2csIGAkJiR7aW5kZW50fWApO1xuICAgIH1cbiAgICAvLyBkZXRlcm1pbmUgaW5kZW50IGluZGljYXRvciBmcm9tIHdoaXRlc3BhY2UgYXQgdmFsdWUgc3RhcnRcbiAgICBsZXQgc3RhcnRXaXRoU3BhY2UgPSBmYWxzZTtcbiAgICBsZXQgc3RhcnRFbmQ7XG4gICAgbGV0IHN0YXJ0TmxQb3MgPSAtMTtcbiAgICBmb3IgKHN0YXJ0RW5kID0gMDsgc3RhcnRFbmQgPCB2YWx1ZS5sZW5ndGg7ICsrc3RhcnRFbmQpIHtcbiAgICAgICAgY29uc3QgY2ggPSB2YWx1ZVtzdGFydEVuZF07XG4gICAgICAgIGlmIChjaCA9PT0gJyAnKVxuICAgICAgICAgICAgc3RhcnRXaXRoU3BhY2UgPSB0cnVlO1xuICAgICAgICBlbHNlIGlmIChjaCA9PT0gJ1xcbicpXG4gICAgICAgICAgICBzdGFydE5sUG9zID0gc3RhcnRFbmQ7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBsZXQgc3RhcnQgPSB2YWx1ZS5zdWJzdHJpbmcoMCwgc3RhcnRObFBvcyA8IHN0YXJ0RW5kID8gc3RhcnRObFBvcyArIDEgOiBzdGFydEVuZCk7XG4gICAgaWYgKHN0YXJ0KSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUuc3Vic3RyaW5nKHN0YXJ0Lmxlbmd0aCk7XG4gICAgICAgIHN0YXJ0ID0gc3RhcnQucmVwbGFjZSgvXFxuKy9nLCBgJCYke2luZGVudH1gKTtcbiAgICB9XG4gICAgY29uc3QgaW5kZW50U2l6ZSA9IGluZGVudCA/ICcyJyA6ICcxJzsgLy8gcm9vdCBpcyBhdCAtMVxuICAgIGxldCBoZWFkZXIgPSAobGl0ZXJhbCA/ICd8JyA6ICc+JykgKyAoc3RhcnRXaXRoU3BhY2UgPyBpbmRlbnRTaXplIDogJycpICsgY2hvbXA7XG4gICAgaWYgKGNvbW1lbnQpIHtcbiAgICAgICAgaGVhZGVyICs9ICcgJyArIGNvbW1lbnRTdHJpbmcoY29tbWVudC5yZXBsYWNlKC8gP1tcXHJcXG5dKy9nLCAnICcpKTtcbiAgICAgICAgaWYgKG9uQ29tbWVudClcbiAgICAgICAgICAgIG9uQ29tbWVudCgpO1xuICAgIH1cbiAgICBpZiAobGl0ZXJhbCkge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL1xcbisvZywgYCQmJHtpbmRlbnR9YCk7XG4gICAgICAgIHJldHVybiBgJHtoZWFkZXJ9XFxuJHtpbmRlbnR9JHtzdGFydH0ke3ZhbHVlfSR7ZW5kfWA7XG4gICAgfVxuICAgIHZhbHVlID0gdmFsdWVcbiAgICAgICAgLnJlcGxhY2UoL1xcbisvZywgJ1xcbiQmJylcbiAgICAgICAgLnJlcGxhY2UoLyg/Ol58XFxuKShbXFx0IF0uKikoPzooW1xcblxcdCBdKilcXG4oPyFbXFxuXFx0IF0pKT8vZywgJyQxJDInKSAvLyBtb3JlLWluZGVudGVkIGxpbmVzIGFyZW4ndCBmb2xkZWRcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgXiBtb3JlLWluZC4gXiBlbXB0eSAgICAgXiBjYXB0dXJlIG5leHQgZW1wdHkgbGluZXMgb25seSBhdCBlbmQgb2YgaW5kZW50XG4gICAgICAgIC5yZXBsYWNlKC9cXG4rL2csIGAkJiR7aW5kZW50fWApO1xuICAgIGNvbnN0IGJvZHkgPSBmb2xkRmxvd0xpbmVzKGAke3N0YXJ0fSR7dmFsdWV9JHtlbmR9YCwgaW5kZW50LCBGT0xEX0JMT0NLLCBnZXRGb2xkT3B0aW9ucyhjdHgpKTtcbiAgICByZXR1cm4gYCR7aGVhZGVyfVxcbiR7aW5kZW50fSR7Ym9keX1gO1xufVxuZnVuY3Rpb24gcGxhaW5TdHJpbmcoaXRlbSwgY3R4LCBvbkNvbW1lbnQsIG9uQ2hvbXBLZWVwKSB7XG4gICAgY29uc3QgeyB0eXBlLCB2YWx1ZSB9ID0gaXRlbTtcbiAgICBjb25zdCB7IGFjdHVhbFN0cmluZywgaW1wbGljaXRLZXksIGluZGVudCwgaW5GbG93IH0gPSBjdHg7XG4gICAgaWYgKChpbXBsaWNpdEtleSAmJiAvW1xcbltcXF17fSxdLy50ZXN0KHZhbHVlKSkgfHxcbiAgICAgICAgKGluRmxvdyAmJiAvW1tcXF17fSxdLy50ZXN0KHZhbHVlKSkpIHtcbiAgICAgICAgcmV0dXJuIHF1b3RlZFN0cmluZyh2YWx1ZSwgY3R4KTtcbiAgICB9XG4gICAgaWYgKCF2YWx1ZSB8fFxuICAgICAgICAvXltcXG5cXHQgLFtcXF17fSMmKiF8PidcIiVAYF18Xls/LV0kfF5bPy1dWyBcXHRdfFtcXG46XVsgXFx0XXxbIFxcdF1cXG58W1xcblxcdCBdI3xbXFxuXFx0IDpdJC8udGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgLy8gbm90IGFsbG93ZWQ6XG4gICAgICAgIC8vIC0gZW1wdHkgc3RyaW5nLCAnLScgb3IgJz8nXG4gICAgICAgIC8vIC0gc3RhcnQgd2l0aCBhbiBpbmRpY2F0b3IgY2hhcmFjdGVyIChleGNlcHQgWz86LV0pIG9yIC9bPy1dIC9cbiAgICAgICAgLy8gLSAnXFxuICcsICc6ICcgb3IgJyBcXG4nIGFueXdoZXJlXG4gICAgICAgIC8vIC0gJyMnIG5vdCBwcmVjZWRlZCBieSBhIG5vbi1zcGFjZSBjaGFyXG4gICAgICAgIC8vIC0gZW5kIHdpdGggJyAnIG9yICc6J1xuICAgICAgICByZXR1cm4gaW1wbGljaXRLZXkgfHwgaW5GbG93IHx8IHZhbHVlLmluZGV4T2YoJ1xcbicpID09PSAtMVxuICAgICAgICAgICAgPyBxdW90ZWRTdHJpbmcodmFsdWUsIGN0eClcbiAgICAgICAgICAgIDogYmxvY2tTdHJpbmcoaXRlbSwgY3R4LCBvbkNvbW1lbnQsIG9uQ2hvbXBLZWVwKTtcbiAgICB9XG4gICAgaWYgKCFpbXBsaWNpdEtleSAmJlxuICAgICAgICAhaW5GbG93ICYmXG4gICAgICAgIHR5cGUgIT09IFNjYWxhci5QTEFJTiAmJlxuICAgICAgICB2YWx1ZS5pbmRleE9mKCdcXG4nKSAhPT0gLTEpIHtcbiAgICAgICAgLy8gV2hlcmUgYWxsb3dlZCAmIHR5cGUgbm90IHNldCBleHBsaWNpdGx5LCBwcmVmZXIgYmxvY2sgc3R5bGUgZm9yIG11bHRpbGluZSBzdHJpbmdzXG4gICAgICAgIHJldHVybiBibG9ja1N0cmluZyhpdGVtLCBjdHgsIG9uQ29tbWVudCwgb25DaG9tcEtlZXApO1xuICAgIH1cbiAgICBpZiAoaW5kZW50ID09PSAnJyAmJiBjb250YWluc0RvY3VtZW50TWFya2VyKHZhbHVlKSkge1xuICAgICAgICBjdHguZm9yY2VCbG9ja0luZGVudCA9IHRydWU7XG4gICAgICAgIHJldHVybiBibG9ja1N0cmluZyhpdGVtLCBjdHgsIG9uQ29tbWVudCwgb25DaG9tcEtlZXApO1xuICAgIH1cbiAgICBjb25zdCBzdHIgPSB2YWx1ZS5yZXBsYWNlKC9cXG4rL2csIGAkJlxcbiR7aW5kZW50fWApO1xuICAgIC8vIFZlcmlmeSB0aGF0IG91dHB1dCB3aWxsIGJlIHBhcnNlZCBhcyBhIHN0cmluZywgYXMgZS5nLiBwbGFpbiBudW1iZXJzIGFuZFxuICAgIC8vIGJvb2xlYW5zIGdldCBwYXJzZWQgd2l0aCB0aG9zZSB0eXBlcyBpbiB2MS4yIChlLmcuICc0MicsICd0cnVlJyAmICcwLjllLTMnKSxcbiAgICAvLyBhbmQgb3RoZXJzIGluIHYxLjEuXG4gICAgaWYgKGFjdHVhbFN0cmluZykge1xuICAgICAgICBjb25zdCB0ZXN0ID0gKHRhZykgPT4geyB2YXIgX2E7IHJldHVybiB0YWcuZGVmYXVsdCAmJiB0YWcudGFnICE9PSAndGFnOnlhbWwub3JnLDIwMDI6c3RyJyAmJiAoKF9hID0gdGFnLnRlc3QpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50ZXN0KHN0cikpOyB9O1xuICAgICAgICBjb25zdCB7IGNvbXBhdCwgdGFncyB9ID0gY3R4LmRvYy5zY2hlbWE7XG4gICAgICAgIGlmICh0YWdzLnNvbWUodGVzdCkgfHwgKGNvbXBhdCA9PT0gbnVsbCB8fCBjb21wYXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbXBhdC5zb21lKHRlc3QpKSlcbiAgICAgICAgICAgIHJldHVybiBxdW90ZWRTdHJpbmcodmFsdWUsIGN0eCk7XG4gICAgfVxuICAgIHJldHVybiBpbXBsaWNpdEtleVxuICAgICAgICA/IHN0clxuICAgICAgICA6IGZvbGRGbG93TGluZXMoc3RyLCBpbmRlbnQsIEZPTERfRkxPVywgZ2V0Rm9sZE9wdGlvbnMoY3R4KSk7XG59XG5mdW5jdGlvbiBzdHJpbmdpZnlTdHJpbmcoaXRlbSwgY3R4LCBvbkNvbW1lbnQsIG9uQ2hvbXBLZWVwKSB7XG4gICAgY29uc3QgeyBpbXBsaWNpdEtleSwgaW5GbG93IH0gPSBjdHg7XG4gICAgY29uc3Qgc3MgPSB0eXBlb2YgaXRlbS52YWx1ZSA9PT0gJ3N0cmluZydcbiAgICAgICAgPyBpdGVtXG4gICAgICAgIDogT2JqZWN0LmFzc2lnbih7fSwgaXRlbSwgeyB2YWx1ZTogU3RyaW5nKGl0ZW0udmFsdWUpIH0pO1xuICAgIGxldCB7IHR5cGUgfSA9IGl0ZW07XG4gICAgaWYgKHR5cGUgIT09IFNjYWxhci5RVU9URV9ET1VCTEUpIHtcbiAgICAgICAgLy8gZm9yY2UgZG91YmxlIHF1b3RlcyBvbiBjb250cm9sIGNoYXJhY3RlcnMgJiB1bnBhaXJlZCBzdXJyb2dhdGVzXG4gICAgICAgIGlmICgvW1xceDAwLVxceDA4XFx4MGItXFx4MWZcXHg3Zi1cXHg5ZlxcdXtEODAwfS1cXHV7REZGRn1dL3UudGVzdChzcy52YWx1ZSkpXG4gICAgICAgICAgICB0eXBlID0gU2NhbGFyLlFVT1RFX0RPVUJMRTtcbiAgICB9XG4gICAgY29uc3QgX3N0cmluZ2lmeSA9IChfdHlwZSkgPT4ge1xuICAgICAgICBzd2l0Y2ggKF90eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFNjYWxhci5CTE9DS19GT0xERUQ6XG4gICAgICAgICAgICBjYXNlIFNjYWxhci5CTE9DS19MSVRFUkFMOlxuICAgICAgICAgICAgICAgIHJldHVybiBpbXBsaWNpdEtleSB8fCBpbkZsb3dcbiAgICAgICAgICAgICAgICAgICAgPyBxdW90ZWRTdHJpbmcoc3MudmFsdWUsIGN0eCkgLy8gYmxvY2tzIGFyZSBub3QgdmFsaWQgaW5zaWRlIGZsb3cgY29udGFpbmVyc1xuICAgICAgICAgICAgICAgICAgICA6IGJsb2NrU3RyaW5nKHNzLCBjdHgsIG9uQ29tbWVudCwgb25DaG9tcEtlZXApO1xuICAgICAgICAgICAgY2FzZSBTY2FsYXIuUVVPVEVfRE9VQkxFOlxuICAgICAgICAgICAgICAgIHJldHVybiBkb3VibGVRdW90ZWRTdHJpbmcoc3MudmFsdWUsIGN0eCk7XG4gICAgICAgICAgICBjYXNlIFNjYWxhci5RVU9URV9TSU5HTEU6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNpbmdsZVF1b3RlZFN0cmluZyhzcy52YWx1ZSwgY3R4KTtcbiAgICAgICAgICAgIGNhc2UgU2NhbGFyLlBMQUlOOlxuICAgICAgICAgICAgICAgIHJldHVybiBwbGFpblN0cmluZyhzcywgY3R4LCBvbkNvbW1lbnQsIG9uQ2hvbXBLZWVwKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGxldCByZXMgPSBfc3RyaW5naWZ5KHR5cGUpO1xuICAgIGlmIChyZXMgPT09IG51bGwpIHtcbiAgICAgICAgY29uc3QgeyBkZWZhdWx0S2V5VHlwZSwgZGVmYXVsdFN0cmluZ1R5cGUgfSA9IGN0eC5vcHRpb25zO1xuICAgICAgICBjb25zdCB0ID0gKGltcGxpY2l0S2V5ICYmIGRlZmF1bHRLZXlUeXBlKSB8fCBkZWZhdWx0U3RyaW5nVHlwZTtcbiAgICAgICAgcmVzID0gX3N0cmluZ2lmeSh0KTtcbiAgICAgICAgaWYgKHJlcyA9PT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgZGVmYXVsdCBzdHJpbmcgdHlwZSAke3R9YCk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5cbmV4cG9ydCB7IHN0cmluZ2lmeVN0cmluZyB9O1xuIiwgImltcG9ydCB7IGFuY2hvcklzVmFsaWQgfSBmcm9tICcuLi9kb2MvYW5jaG9ycy5qcyc7XG5pbXBvcnQgeyBpc1BhaXIsIGlzQWxpYXMsIGlzTm9kZSwgaXNTY2FsYXIsIGlzQ29sbGVjdGlvbiB9IGZyb20gJy4uL25vZGVzL05vZGUuanMnO1xuaW1wb3J0IHsgc3RyaW5naWZ5Q29tbWVudCB9IGZyb20gJy4vc3RyaW5naWZ5Q29tbWVudC5qcyc7XG5pbXBvcnQgeyBzdHJpbmdpZnlTdHJpbmcgfSBmcm9tICcuL3N0cmluZ2lmeVN0cmluZy5qcyc7XG5cbmZ1bmN0aW9uIGNyZWF0ZVN0cmluZ2lmeUNvbnRleHQoZG9jLCBvcHRpb25zKSB7XG4gICAgY29uc3Qgb3B0ID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgIGJsb2NrUXVvdGU6IHRydWUsXG4gICAgICAgIGNvbW1lbnRTdHJpbmc6IHN0cmluZ2lmeUNvbW1lbnQsXG4gICAgICAgIGRlZmF1bHRLZXlUeXBlOiBudWxsLFxuICAgICAgICBkZWZhdWx0U3RyaW5nVHlwZTogJ1BMQUlOJyxcbiAgICAgICAgZGlyZWN0aXZlczogbnVsbCxcbiAgICAgICAgZG91YmxlUXVvdGVkQXNKU09OOiBmYWxzZSxcbiAgICAgICAgZG91YmxlUXVvdGVkTWluTXVsdGlMaW5lTGVuZ3RoOiA0MCxcbiAgICAgICAgZmFsc2VTdHI6ICdmYWxzZScsXG4gICAgICAgIGluZGVudFNlcTogdHJ1ZSxcbiAgICAgICAgbGluZVdpZHRoOiA4MCxcbiAgICAgICAgbWluQ29udGVudFdpZHRoOiAyMCxcbiAgICAgICAgbnVsbFN0cjogJ251bGwnLFxuICAgICAgICBzaW1wbGVLZXlzOiBmYWxzZSxcbiAgICAgICAgc2luZ2xlUXVvdGU6IG51bGwsXG4gICAgICAgIHRydWVTdHI6ICd0cnVlJyxcbiAgICAgICAgdmVyaWZ5QWxpYXNPcmRlcjogdHJ1ZVxuICAgIH0sIGRvYy5zY2hlbWEudG9TdHJpbmdPcHRpb25zLCBvcHRpb25zKTtcbiAgICBsZXQgaW5GbG93O1xuICAgIHN3aXRjaCAob3B0LmNvbGxlY3Rpb25TdHlsZSkge1xuICAgICAgICBjYXNlICdibG9jayc6XG4gICAgICAgICAgICBpbkZsb3cgPSBmYWxzZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdmbG93JzpcbiAgICAgICAgICAgIGluRmxvdyA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGluRmxvdyA9IG51bGw7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGFuY2hvcnM6IG5ldyBTZXQoKSxcbiAgICAgICAgZG9jLFxuICAgICAgICBpbmRlbnQ6ICcnLFxuICAgICAgICBpbmRlbnRTdGVwOiB0eXBlb2Ygb3B0LmluZGVudCA9PT0gJ251bWJlcicgPyAnICcucmVwZWF0KG9wdC5pbmRlbnQpIDogJyAgJyxcbiAgICAgICAgaW5GbG93LFxuICAgICAgICBvcHRpb25zOiBvcHRcbiAgICB9O1xufVxuZnVuY3Rpb24gZ2V0VGFnT2JqZWN0KHRhZ3MsIGl0ZW0pIHtcbiAgICBpZiAoaXRlbS50YWcpIHtcbiAgICAgICAgY29uc3QgbWF0Y2ggPSB0YWdzLmZpbHRlcih0ID0+IHQudGFnID09PSBpdGVtLnRhZyk7XG4gICAgICAgIGlmIChtYXRjaC5sZW5ndGggPiAwKVxuICAgICAgICAgICAgcmV0dXJuIG1hdGNoLmZpbmQodCA9PiB0LmZvcm1hdCA9PT0gaXRlbS5mb3JtYXQpIHx8IG1hdGNoWzBdO1xuICAgIH1cbiAgICBsZXQgdGFnT2JqID0gdW5kZWZpbmVkO1xuICAgIGxldCBvYmo7XG4gICAgaWYgKGlzU2NhbGFyKGl0ZW0pKSB7XG4gICAgICAgIG9iaiA9IGl0ZW0udmFsdWU7XG4gICAgICAgIGNvbnN0IG1hdGNoID0gdGFncy5maWx0ZXIodCA9PiB0LmlkZW50aWZ5ICYmIHQuaWRlbnRpZnkob2JqKSk7XG4gICAgICAgIHRhZ09iaiA9XG4gICAgICAgICAgICBtYXRjaC5maW5kKHQgPT4gdC5mb3JtYXQgPT09IGl0ZW0uZm9ybWF0KSB8fCBtYXRjaC5maW5kKHQgPT4gIXQuZm9ybWF0KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIG9iaiA9IGl0ZW07XG4gICAgICAgIHRhZ09iaiA9IHRhZ3MuZmluZCh0ID0+IHQubm9kZUNsYXNzICYmIG9iaiBpbnN0YW5jZW9mIHQubm9kZUNsYXNzKTtcbiAgICB9XG4gICAgaWYgKCF0YWdPYmopIHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBjb25zdCBuYW1lID0gb2JqICYmIG9iai5jb25zdHJ1Y3RvciA/IG9iai5jb25zdHJ1Y3Rvci5uYW1lIDogdHlwZW9mIG9iajtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUYWcgbm90IHJlc29sdmVkIGZvciAke25hbWV9IHZhbHVlYCk7XG4gICAgfVxuICAgIHJldHVybiB0YWdPYmo7XG59XG4vLyBuZWVkcyB0byBiZSBjYWxsZWQgYmVmb3JlIHZhbHVlIHN0cmluZ2lmaWVyIHRvIGFsbG93IGZvciBjaXJjdWxhciBhbmNob3IgcmVmc1xuZnVuY3Rpb24gc3RyaW5naWZ5UHJvcHMobm9kZSwgdGFnT2JqLCB7IGFuY2hvcnMsIGRvYyB9KSB7XG4gICAgaWYgKCFkb2MuZGlyZWN0aXZlcylcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIGNvbnN0IHByb3BzID0gW107XG4gICAgY29uc3QgYW5jaG9yID0gKGlzU2NhbGFyKG5vZGUpIHx8IGlzQ29sbGVjdGlvbihub2RlKSkgJiYgbm9kZS5hbmNob3I7XG4gICAgaWYgKGFuY2hvciAmJiBhbmNob3JJc1ZhbGlkKGFuY2hvcikpIHtcbiAgICAgICAgYW5jaG9ycy5hZGQoYW5jaG9yKTtcbiAgICAgICAgcHJvcHMucHVzaChgJiR7YW5jaG9yfWApO1xuICAgIH1cbiAgICBjb25zdCB0YWcgPSBub2RlLnRhZyB8fCAodGFnT2JqLmRlZmF1bHQgPyBudWxsIDogdGFnT2JqLnRhZyk7XG4gICAgaWYgKHRhZylcbiAgICAgICAgcHJvcHMucHVzaChkb2MuZGlyZWN0aXZlcy50YWdTdHJpbmcodGFnKSk7XG4gICAgcmV0dXJuIHByb3BzLmpvaW4oJyAnKTtcbn1cbmZ1bmN0aW9uIHN0cmluZ2lmeShpdGVtLCBjdHgsIG9uQ29tbWVudCwgb25DaG9tcEtlZXApIHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKGlzUGFpcihpdGVtKSlcbiAgICAgICAgcmV0dXJuIGl0ZW0udG9TdHJpbmcoY3R4LCBvbkNvbW1lbnQsIG9uQ2hvbXBLZWVwKTtcbiAgICBpZiAoaXNBbGlhcyhpdGVtKSkge1xuICAgICAgICBpZiAoY3R4LmRvYy5kaXJlY3RpdmVzKVxuICAgICAgICAgICAgcmV0dXJuIGl0ZW0udG9TdHJpbmcoY3R4KTtcbiAgICAgICAgaWYgKChfYSA9IGN0eC5yZXNvbHZlZEFsaWFzZXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5oYXMoaXRlbSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYENhbm5vdCBzdHJpbmdpZnkgY2lyY3VsYXIgc3RydWN0dXJlIHdpdGhvdXQgYWxpYXMgbm9kZXNgKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChjdHgucmVzb2x2ZWRBbGlhc2VzKVxuICAgICAgICAgICAgICAgIGN0eC5yZXNvbHZlZEFsaWFzZXMuYWRkKGl0ZW0pO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGN0eC5yZXNvbHZlZEFsaWFzZXMgPSBuZXcgU2V0KFtpdGVtXSk7XG4gICAgICAgICAgICBpdGVtID0gaXRlbS5yZXNvbHZlKGN0eC5kb2MpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxldCB0YWdPYmogPSB1bmRlZmluZWQ7XG4gICAgY29uc3Qgbm9kZSA9IGlzTm9kZShpdGVtKVxuICAgICAgICA/IGl0ZW1cbiAgICAgICAgOiBjdHguZG9jLmNyZWF0ZU5vZGUoaXRlbSwgeyBvblRhZ09iajogbyA9PiAodGFnT2JqID0gbykgfSk7XG4gICAgaWYgKCF0YWdPYmopXG4gICAgICAgIHRhZ09iaiA9IGdldFRhZ09iamVjdChjdHguZG9jLnNjaGVtYS50YWdzLCBub2RlKTtcbiAgICBjb25zdCBwcm9wcyA9IHN0cmluZ2lmeVByb3BzKG5vZGUsIHRhZ09iaiwgY3R4KTtcbiAgICBpZiAocHJvcHMubGVuZ3RoID4gMClcbiAgICAgICAgY3R4LmluZGVudEF0U3RhcnQgPSAoY3R4LmluZGVudEF0U3RhcnQgfHwgMCkgKyBwcm9wcy5sZW5ndGggKyAxO1xuICAgIGNvbnN0IHN0ciA9IHR5cGVvZiB0YWdPYmouc3RyaW5naWZ5ID09PSAnZnVuY3Rpb24nXG4gICAgICAgID8gdGFnT2JqLnN0cmluZ2lmeShub2RlLCBjdHgsIG9uQ29tbWVudCwgb25DaG9tcEtlZXApXG4gICAgICAgIDogaXNTY2FsYXIobm9kZSlcbiAgICAgICAgICAgID8gc3RyaW5naWZ5U3RyaW5nKG5vZGUsIGN0eCwgb25Db21tZW50LCBvbkNob21wS2VlcClcbiAgICAgICAgICAgIDogbm9kZS50b1N0cmluZyhjdHgsIG9uQ29tbWVudCwgb25DaG9tcEtlZXApO1xuICAgIGlmICghcHJvcHMpXG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgcmV0dXJuIGlzU2NhbGFyKG5vZGUpIHx8IHN0clswXSA9PT0gJ3snIHx8IHN0clswXSA9PT0gJ1snXG4gICAgICAgID8gYCR7cHJvcHN9ICR7c3RyfWBcbiAgICAgICAgOiBgJHtwcm9wc31cXG4ke2N0eC5pbmRlbnR9JHtzdHJ9YDtcbn1cblxuZXhwb3J0IHsgY3JlYXRlU3RyaW5naWZ5Q29udGV4dCwgc3RyaW5naWZ5IH07XG4iLCAiaW1wb3J0IHsgaXNDb2xsZWN0aW9uLCBpc05vZGUsIGlzU2NhbGFyLCBpc1NlcSB9IGZyb20gJy4uL25vZGVzL05vZGUuanMnO1xuaW1wb3J0IHsgU2NhbGFyIH0gZnJvbSAnLi4vbm9kZXMvU2NhbGFyLmpzJztcbmltcG9ydCB7IHN0cmluZ2lmeSB9IGZyb20gJy4vc3RyaW5naWZ5LmpzJztcbmltcG9ydCB7IGxpbmVDb21tZW50LCBpbmRlbnRDb21tZW50IH0gZnJvbSAnLi9zdHJpbmdpZnlDb21tZW50LmpzJztcblxuZnVuY3Rpb24gc3RyaW5naWZ5UGFpcih7IGtleSwgdmFsdWUgfSwgY3R4LCBvbkNvbW1lbnQsIG9uQ2hvbXBLZWVwKSB7XG4gICAgY29uc3QgeyBhbGxOdWxsVmFsdWVzLCBkb2MsIGluZGVudCwgaW5kZW50U3RlcCwgb3B0aW9uczogeyBjb21tZW50U3RyaW5nLCBpbmRlbnRTZXEsIHNpbXBsZUtleXMgfSB9ID0gY3R4O1xuICAgIGxldCBrZXlDb21tZW50ID0gKGlzTm9kZShrZXkpICYmIGtleS5jb21tZW50KSB8fCBudWxsO1xuICAgIGlmIChzaW1wbGVLZXlzKSB7XG4gICAgICAgIGlmIChrZXlDb21tZW50KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dpdGggc2ltcGxlIGtleXMsIGtleSBub2RlcyBjYW5ub3QgaGF2ZSBjb21tZW50cycpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0NvbGxlY3Rpb24oa2V5KSkge1xuICAgICAgICAgICAgY29uc3QgbXNnID0gJ1dpdGggc2ltcGxlIGtleXMsIGNvbGxlY3Rpb24gY2Fubm90IGJlIHVzZWQgYXMgYSBrZXkgdmFsdWUnO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IGV4cGxpY2l0S2V5ID0gIXNpbXBsZUtleXMgJiZcbiAgICAgICAgKCFrZXkgfHxcbiAgICAgICAgICAgIChrZXlDb21tZW50ICYmIHZhbHVlID09IG51bGwgJiYgIWN0eC5pbkZsb3cpIHx8XG4gICAgICAgICAgICBpc0NvbGxlY3Rpb24oa2V5KSB8fFxuICAgICAgICAgICAgKGlzU2NhbGFyKGtleSlcbiAgICAgICAgICAgICAgICA/IGtleS50eXBlID09PSBTY2FsYXIuQkxPQ0tfRk9MREVEIHx8IGtleS50eXBlID09PSBTY2FsYXIuQkxPQ0tfTElURVJBTFxuICAgICAgICAgICAgICAgIDogdHlwZW9mIGtleSA9PT0gJ29iamVjdCcpKTtcbiAgICBjdHggPSBPYmplY3QuYXNzaWduKHt9LCBjdHgsIHtcbiAgICAgICAgYWxsTnVsbFZhbHVlczogZmFsc2UsXG4gICAgICAgIGltcGxpY2l0S2V5OiAhZXhwbGljaXRLZXkgJiYgKHNpbXBsZUtleXMgfHwgIWFsbE51bGxWYWx1ZXMpLFxuICAgICAgICBpbmRlbnQ6IGluZGVudCArIGluZGVudFN0ZXBcbiAgICB9KTtcbiAgICBsZXQga2V5Q29tbWVudERvbmUgPSBmYWxzZTtcbiAgICBsZXQgY2hvbXBLZWVwID0gZmFsc2U7XG4gICAgbGV0IHN0ciA9IHN0cmluZ2lmeShrZXksIGN0eCwgKCkgPT4gKGtleUNvbW1lbnREb25lID0gdHJ1ZSksICgpID0+IChjaG9tcEtlZXAgPSB0cnVlKSk7XG4gICAgaWYgKCFleHBsaWNpdEtleSAmJiAhY3R4LmluRmxvdyAmJiBzdHIubGVuZ3RoID4gMTAyNCkge1xuICAgICAgICBpZiAoc2ltcGxlS2V5cylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignV2l0aCBzaW1wbGUga2V5cywgc2luZ2xlIGxpbmUgc2NhbGFyIG11c3Qgbm90IHNwYW4gbW9yZSB0aGFuIDEwMjQgY2hhcmFjdGVycycpO1xuICAgICAgICBleHBsaWNpdEtleSA9IHRydWU7XG4gICAgfVxuICAgIGlmIChjdHguaW5GbG93KSB7XG4gICAgICAgIGlmIChhbGxOdWxsVmFsdWVzIHx8IHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChrZXlDb21tZW50RG9uZSAmJiBvbkNvbW1lbnQpXG4gICAgICAgICAgICAgICAgb25Db21tZW50KCk7XG4gICAgICAgICAgICByZXR1cm4gZXhwbGljaXRLZXkgPyBgPyAke3N0cn1gIDogc3RyO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKChhbGxOdWxsVmFsdWVzICYmICFzaW1wbGVLZXlzKSB8fCAodmFsdWUgPT0gbnVsbCAmJiBleHBsaWNpdEtleSkpIHtcbiAgICAgICAgc3RyID0gYD8gJHtzdHJ9YDtcbiAgICAgICAgaWYgKGtleUNvbW1lbnQgJiYgIWtleUNvbW1lbnREb25lKSB7XG4gICAgICAgICAgICBzdHIgKz0gbGluZUNvbW1lbnQoc3RyLCBjdHguaW5kZW50LCBjb21tZW50U3RyaW5nKGtleUNvbW1lbnQpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjaG9tcEtlZXAgJiYgb25DaG9tcEtlZXApXG4gICAgICAgICAgICBvbkNob21wS2VlcCgpO1xuICAgICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgICBpZiAoa2V5Q29tbWVudERvbmUpXG4gICAgICAgIGtleUNvbW1lbnQgPSBudWxsO1xuICAgIGlmIChleHBsaWNpdEtleSkge1xuICAgICAgICBpZiAoa2V5Q29tbWVudClcbiAgICAgICAgICAgIHN0ciArPSBsaW5lQ29tbWVudChzdHIsIGN0eC5pbmRlbnQsIGNvbW1lbnRTdHJpbmcoa2V5Q29tbWVudCkpO1xuICAgICAgICBzdHIgPSBgPyAke3N0cn1cXG4ke2luZGVudH06YDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHN0ciA9IGAke3N0cn06YDtcbiAgICAgICAgaWYgKGtleUNvbW1lbnQpXG4gICAgICAgICAgICBzdHIgKz0gbGluZUNvbW1lbnQoc3RyLCBjdHguaW5kZW50LCBjb21tZW50U3RyaW5nKGtleUNvbW1lbnQpKTtcbiAgICB9XG4gICAgbGV0IHZjYiA9ICcnO1xuICAgIGxldCB2YWx1ZUNvbW1lbnQgPSBudWxsO1xuICAgIGlmIChpc05vZGUodmFsdWUpKSB7XG4gICAgICAgIGlmICh2YWx1ZS5zcGFjZUJlZm9yZSlcbiAgICAgICAgICAgIHZjYiA9ICdcXG4nO1xuICAgICAgICBpZiAodmFsdWUuY29tbWVudEJlZm9yZSkge1xuICAgICAgICAgICAgY29uc3QgY3MgPSBjb21tZW50U3RyaW5nKHZhbHVlLmNvbW1lbnRCZWZvcmUpO1xuICAgICAgICAgICAgdmNiICs9IGBcXG4ke2luZGVudENvbW1lbnQoY3MsIGN0eC5pbmRlbnQpfWA7XG4gICAgICAgIH1cbiAgICAgICAgdmFsdWVDb21tZW50ID0gdmFsdWUuY29tbWVudDtcbiAgICB9XG4gICAgZWxzZSBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgICAgICB2YWx1ZSA9IGRvYy5jcmVhdGVOb2RlKHZhbHVlKTtcbiAgICB9XG4gICAgY3R4LmltcGxpY2l0S2V5ID0gZmFsc2U7XG4gICAgaWYgKCFleHBsaWNpdEtleSAmJiAha2V5Q29tbWVudCAmJiBpc1NjYWxhcih2YWx1ZSkpXG4gICAgICAgIGN0eC5pbmRlbnRBdFN0YXJ0ID0gc3RyLmxlbmd0aCArIDE7XG4gICAgY2hvbXBLZWVwID0gZmFsc2U7XG4gICAgaWYgKCFpbmRlbnRTZXEgJiZcbiAgICAgICAgaW5kZW50U3RlcC5sZW5ndGggPj0gMiAmJlxuICAgICAgICAhY3R4LmluRmxvdyAmJlxuICAgICAgICAhZXhwbGljaXRLZXkgJiZcbiAgICAgICAgaXNTZXEodmFsdWUpICYmXG4gICAgICAgICF2YWx1ZS5mbG93ICYmXG4gICAgICAgICF2YWx1ZS50YWcgJiZcbiAgICAgICAgIXZhbHVlLmFuY2hvcikge1xuICAgICAgICAvLyBJZiBpbmRlbnRTZXEgPT09IGZhbHNlLCBjb25zaWRlciAnLSAnIGFzIHBhcnQgb2YgaW5kZW50YXRpb24gd2hlcmUgcG9zc2libGVcbiAgICAgICAgY3R4LmluZGVudCA9IGN0eC5pbmRlbnQuc3Vic3RyKDIpO1xuICAgIH1cbiAgICBsZXQgdmFsdWVDb21tZW50RG9uZSA9IGZhbHNlO1xuICAgIGNvbnN0IHZhbHVlU3RyID0gc3RyaW5naWZ5KHZhbHVlLCBjdHgsICgpID0+ICh2YWx1ZUNvbW1lbnREb25lID0gdHJ1ZSksICgpID0+IChjaG9tcEtlZXAgPSB0cnVlKSk7XG4gICAgbGV0IHdzID0gJyAnO1xuICAgIGlmICh2Y2IgfHwga2V5Q29tbWVudCkge1xuICAgICAgICB3cyA9IHZhbHVlU3RyID09PSAnJyAmJiAhY3R4LmluRmxvdyA/IHZjYiA6IGAke3ZjYn1cXG4ke2N0eC5pbmRlbnR9YDtcbiAgICB9XG4gICAgZWxzZSBpZiAoIWV4cGxpY2l0S2V5ICYmIGlzQ29sbGVjdGlvbih2YWx1ZSkpIHtcbiAgICAgICAgY29uc3QgZmxvdyA9IHZhbHVlU3RyWzBdID09PSAnWycgfHwgdmFsdWVTdHJbMF0gPT09ICd7JztcbiAgICAgICAgaWYgKCFmbG93IHx8IHZhbHVlU3RyLmluY2x1ZGVzKCdcXG4nKSlcbiAgICAgICAgICAgIHdzID0gYFxcbiR7Y3R4LmluZGVudH1gO1xuICAgIH1cbiAgICBlbHNlIGlmICh2YWx1ZVN0ciA9PT0gJycgfHwgdmFsdWVTdHJbMF0gPT09ICdcXG4nKVxuICAgICAgICB3cyA9ICcnO1xuICAgIHN0ciArPSB3cyArIHZhbHVlU3RyO1xuICAgIGlmIChjdHguaW5GbG93KSB7XG4gICAgICAgIGlmICh2YWx1ZUNvbW1lbnREb25lICYmIG9uQ29tbWVudClcbiAgICAgICAgICAgIG9uQ29tbWVudCgpO1xuICAgIH1cbiAgICBlbHNlIGlmICh2YWx1ZUNvbW1lbnQgJiYgIXZhbHVlQ29tbWVudERvbmUpIHtcbiAgICAgICAgc3RyICs9IGxpbmVDb21tZW50KHN0ciwgY3R4LmluZGVudCwgY29tbWVudFN0cmluZyh2YWx1ZUNvbW1lbnQpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoY2hvbXBLZWVwICYmIG9uQ2hvbXBLZWVwKSB7XG4gICAgICAgIG9uQ2hvbXBLZWVwKCk7XG4gICAgfVxuICAgIHJldHVybiBzdHI7XG59XG5cbmV4cG9ydCB7IHN0cmluZ2lmeVBhaXIgfTtcbiIsICJmdW5jdGlvbiBkZWJ1Zyhsb2dMZXZlbCwgLi4ubWVzc2FnZXMpIHtcbiAgICBpZiAobG9nTGV2ZWwgPT09ICdkZWJ1ZycpXG4gICAgICAgIGNvbnNvbGUubG9nKC4uLm1lc3NhZ2VzKTtcbn1cbmZ1bmN0aW9uIHdhcm4obG9nTGV2ZWwsIHdhcm5pbmcpIHtcbiAgICBpZiAobG9nTGV2ZWwgPT09ICdkZWJ1ZycgfHwgbG9nTGV2ZWwgPT09ICd3YXJuJykge1xuICAgICAgICBpZiAodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHByb2Nlc3MuZW1pdFdhcm5pbmcpXG4gICAgICAgICAgICBwcm9jZXNzLmVtaXRXYXJuaW5nKHdhcm5pbmcpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBjb25zb2xlLndhcm4od2FybmluZyk7XG4gICAgfVxufVxuXG5leHBvcnQgeyBkZWJ1Zywgd2FybiB9O1xuIiwgImltcG9ydCB7IHdhcm4gfSBmcm9tICcuLi9sb2cuanMnO1xuaW1wb3J0IHsgY3JlYXRlU3RyaW5naWZ5Q29udGV4dCB9IGZyb20gJy4uL3N0cmluZ2lmeS9zdHJpbmdpZnkuanMnO1xuaW1wb3J0IHsgaXNBbGlhcywgaXNTZXEsIGlzU2NhbGFyLCBpc01hcCwgaXNOb2RlIH0gZnJvbSAnLi9Ob2RlLmpzJztcbmltcG9ydCB7IFNjYWxhciB9IGZyb20gJy4vU2NhbGFyLmpzJztcbmltcG9ydCB7IHRvSlMgfSBmcm9tICcuL3RvSlMuanMnO1xuXG5jb25zdCBNRVJHRV9LRVkgPSAnPDwnO1xuZnVuY3Rpb24gYWRkUGFpclRvSlNNYXAoY3R4LCBtYXAsIHsga2V5LCB2YWx1ZSB9KSB7XG4gICAgaWYgKGN0eCAmJiBjdHguZG9jLnNjaGVtYS5tZXJnZSAmJiBpc01lcmdlS2V5KGtleSkpIHtcbiAgICAgICAgdmFsdWUgPSBpc0FsaWFzKHZhbHVlKSA/IHZhbHVlLnJlc29sdmUoY3R4LmRvYykgOiB2YWx1ZTtcbiAgICAgICAgaWYgKGlzU2VxKHZhbHVlKSlcbiAgICAgICAgICAgIGZvciAoY29uc3QgaXQgb2YgdmFsdWUuaXRlbXMpXG4gICAgICAgICAgICAgICAgbWVyZ2VUb0pTTWFwKGN0eCwgbWFwLCBpdCk7XG4gICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKVxuICAgICAgICAgICAgZm9yIChjb25zdCBpdCBvZiB2YWx1ZSlcbiAgICAgICAgICAgICAgICBtZXJnZVRvSlNNYXAoY3R4LCBtYXAsIGl0KTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgbWVyZ2VUb0pTTWFwKGN0eCwgbWFwLCB2YWx1ZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBqc0tleSA9IHRvSlMoa2V5LCAnJywgY3R4KTtcbiAgICAgICAgaWYgKG1hcCBpbnN0YW5jZW9mIE1hcCkge1xuICAgICAgICAgICAgbWFwLnNldChqc0tleSwgdG9KUyh2YWx1ZSwganNLZXksIGN0eCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG1hcCBpbnN0YW5jZW9mIFNldCkge1xuICAgICAgICAgICAgbWFwLmFkZChqc0tleSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBzdHJpbmdLZXkgPSBzdHJpbmdpZnlLZXkoa2V5LCBqc0tleSwgY3R4KTtcbiAgICAgICAgICAgIGNvbnN0IGpzVmFsdWUgPSB0b0pTKHZhbHVlLCBzdHJpbmdLZXksIGN0eCk7XG4gICAgICAgICAgICBpZiAoc3RyaW5nS2V5IGluIG1hcClcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobWFwLCBzdHJpbmdLZXksIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGpzVmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBtYXBbc3RyaW5nS2V5XSA9IGpzVmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1hcDtcbn1cbmNvbnN0IGlzTWVyZ2VLZXkgPSAoa2V5KSA9PiBrZXkgPT09IE1FUkdFX0tFWSB8fFxuICAgIChpc1NjYWxhcihrZXkpICYmXG4gICAgICAgIGtleS52YWx1ZSA9PT0gTUVSR0VfS0VZICYmXG4gICAgICAgICgha2V5LnR5cGUgfHwga2V5LnR5cGUgPT09IFNjYWxhci5QTEFJTikpO1xuLy8gSWYgdGhlIHZhbHVlIGFzc29jaWF0ZWQgd2l0aCBhIG1lcmdlIGtleSBpcyBhIHNpbmdsZSBtYXBwaW5nIG5vZGUsIGVhY2ggb2Zcbi8vIGl0cyBrZXkvdmFsdWUgcGFpcnMgaXMgaW5zZXJ0ZWQgaW50byB0aGUgY3VycmVudCBtYXBwaW5nLCB1bmxlc3MgdGhlIGtleVxuLy8gYWxyZWFkeSBleGlzdHMgaW4gaXQuIElmIHRoZSB2YWx1ZSBhc3NvY2lhdGVkIHdpdGggdGhlIG1lcmdlIGtleSBpcyBhXG4vLyBzZXF1ZW5jZSwgdGhlbiB0aGlzIHNlcXVlbmNlIGlzIGV4cGVjdGVkIHRvIGNvbnRhaW4gbWFwcGluZyBub2RlcyBhbmQgZWFjaFxuLy8gb2YgdGhlc2Ugbm9kZXMgaXMgbWVyZ2VkIGluIHR1cm4gYWNjb3JkaW5nIHRvIGl0cyBvcmRlciBpbiB0aGUgc2VxdWVuY2UuXG4vLyBLZXlzIGluIG1hcHBpbmcgbm9kZXMgZWFybGllciBpbiB0aGUgc2VxdWVuY2Ugb3ZlcnJpZGUga2V5cyBzcGVjaWZpZWQgaW5cbi8vIGxhdGVyIG1hcHBpbmcgbm9kZXMuIC0tIGh0dHA6Ly95YW1sLm9yZy90eXBlL21lcmdlLmh0bWxcbmZ1bmN0aW9uIG1lcmdlVG9KU01hcChjdHgsIG1hcCwgdmFsdWUpIHtcbiAgICBjb25zdCBzb3VyY2UgPSBjdHggJiYgaXNBbGlhcyh2YWx1ZSkgPyB2YWx1ZS5yZXNvbHZlKGN0eC5kb2MpIDogdmFsdWU7XG4gICAgaWYgKCFpc01hcChzb3VyY2UpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01lcmdlIHNvdXJjZXMgbXVzdCBiZSBtYXBzIG9yIG1hcCBhbGlhc2VzJyk7XG4gICAgY29uc3Qgc3JjTWFwID0gc291cmNlLnRvSlNPTihudWxsLCBjdHgsIE1hcCk7XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2Ygc3JjTWFwKSB7XG4gICAgICAgIGlmIChtYXAgaW5zdGFuY2VvZiBNYXApIHtcbiAgICAgICAgICAgIGlmICghbWFwLmhhcyhrZXkpKVxuICAgICAgICAgICAgICAgIG1hcC5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobWFwIGluc3RhbmNlb2YgU2V0KSB7XG4gICAgICAgICAgICBtYXAuYWRkKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtYXAsIGtleSkpIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtYXAsIGtleSwge1xuICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWFwO1xufVxuZnVuY3Rpb24gc3RyaW5naWZ5S2V5KGtleSwganNLZXksIGN0eCkge1xuICAgIGlmIChqc0tleSA9PT0gbnVsbClcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIGlmICh0eXBlb2YganNLZXkgIT09ICdvYmplY3QnKVxuICAgICAgICByZXR1cm4gU3RyaW5nKGpzS2V5KTtcbiAgICBpZiAoaXNOb2RlKGtleSkgJiYgY3R4ICYmIGN0eC5kb2MpIHtcbiAgICAgICAgY29uc3Qgc3RyQ3R4ID0gY3JlYXRlU3RyaW5naWZ5Q29udGV4dChjdHguZG9jLCB7fSk7XG4gICAgICAgIHN0ckN0eC5hbmNob3JzID0gbmV3IFNldCgpO1xuICAgICAgICBmb3IgKGNvbnN0IG5vZGUgb2YgY3R4LmFuY2hvcnMua2V5cygpKVxuICAgICAgICAgICAgc3RyQ3R4LmFuY2hvcnMuYWRkKG5vZGUuYW5jaG9yKTtcbiAgICAgICAgc3RyQ3R4LmluRmxvdyA9IHRydWU7XG4gICAgICAgIHN0ckN0eC5pblN0cmluZ2lmeUtleSA9IHRydWU7XG4gICAgICAgIGNvbnN0IHN0cktleSA9IGtleS50b1N0cmluZyhzdHJDdHgpO1xuICAgICAgICBpZiAoIWN0eC5tYXBLZXlXYXJuZWQpIHtcbiAgICAgICAgICAgIGxldCBqc29uU3RyID0gSlNPTi5zdHJpbmdpZnkoc3RyS2V5KTtcbiAgICAgICAgICAgIGlmIChqc29uU3RyLmxlbmd0aCA+IDQwKVxuICAgICAgICAgICAgICAgIGpzb25TdHIgPSBqc29uU3RyLnN1YnN0cmluZygwLCAzNikgKyAnLi4uXCInO1xuICAgICAgICAgICAgd2FybihjdHguZG9jLm9wdGlvbnMubG9nTGV2ZWwsIGBLZXlzIHdpdGggY29sbGVjdGlvbiB2YWx1ZXMgd2lsbCBiZSBzdHJpbmdpZmllZCBkdWUgdG8gSlMgT2JqZWN0IHJlc3RyaWN0aW9uczogJHtqc29uU3RyfS4gU2V0IG1hcEFzTWFwOiB0cnVlIHRvIHVzZSBvYmplY3Qga2V5cy5gKTtcbiAgICAgICAgICAgIGN0eC5tYXBLZXlXYXJuZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHJLZXk7XG4gICAgfVxuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShqc0tleSk7XG59XG5cbmV4cG9ydCB7IGFkZFBhaXJUb0pTTWFwIH07XG4iLCAiaW1wb3J0IHsgY3JlYXRlTm9kZSB9IGZyb20gJy4uL2RvYy9jcmVhdGVOb2RlLmpzJztcbmltcG9ydCB7IHN0cmluZ2lmeVBhaXIgfSBmcm9tICcuLi9zdHJpbmdpZnkvc3RyaW5naWZ5UGFpci5qcyc7XG5pbXBvcnQgeyBhZGRQYWlyVG9KU01hcCB9IGZyb20gJy4vYWRkUGFpclRvSlNNYXAuanMnO1xuaW1wb3J0IHsgTk9ERV9UWVBFLCBQQUlSLCBpc05vZGUgfSBmcm9tICcuL05vZGUuanMnO1xuXG5mdW5jdGlvbiBjcmVhdGVQYWlyKGtleSwgdmFsdWUsIGN0eCkge1xuICAgIGNvbnN0IGsgPSBjcmVhdGVOb2RlKGtleSwgdW5kZWZpbmVkLCBjdHgpO1xuICAgIGNvbnN0IHYgPSBjcmVhdGVOb2RlKHZhbHVlLCB1bmRlZmluZWQsIGN0eCk7XG4gICAgcmV0dXJuIG5ldyBQYWlyKGssIHYpO1xufVxuY2xhc3MgUGFpciB7XG4gICAgY29uc3RydWN0b3Ioa2V5LCB2YWx1ZSA9IG51bGwpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIE5PREVfVFlQRSwgeyB2YWx1ZTogUEFJUiB9KTtcbiAgICAgICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gICAgY2xvbmUoc2NoZW1hKSB7XG4gICAgICAgIGxldCB7IGtleSwgdmFsdWUgfSA9IHRoaXM7XG4gICAgICAgIGlmIChpc05vZGUoa2V5KSlcbiAgICAgICAgICAgIGtleSA9IGtleS5jbG9uZShzY2hlbWEpO1xuICAgICAgICBpZiAoaXNOb2RlKHZhbHVlKSlcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuY2xvbmUoc2NoZW1hKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQYWlyKGtleSwgdmFsdWUpO1xuICAgIH1cbiAgICB0b0pTT04oXywgY3R4KSB7XG4gICAgICAgIGNvbnN0IHBhaXIgPSBjdHggJiYgY3R4Lm1hcEFzTWFwID8gbmV3IE1hcCgpIDoge307XG4gICAgICAgIHJldHVybiBhZGRQYWlyVG9KU01hcChjdHgsIHBhaXIsIHRoaXMpO1xuICAgIH1cbiAgICB0b1N0cmluZyhjdHgsIG9uQ29tbWVudCwgb25DaG9tcEtlZXApIHtcbiAgICAgICAgcmV0dXJuIGN0eCAmJiBjdHguZG9jXG4gICAgICAgICAgICA/IHN0cmluZ2lmeVBhaXIodGhpcywgY3R4LCBvbkNvbW1lbnQsIG9uQ2hvbXBLZWVwKVxuICAgICAgICAgICAgOiBKU09OLnN0cmluZ2lmeSh0aGlzKTtcbiAgICB9XG59XG5cbmV4cG9ydCB7IFBhaXIsIGNyZWF0ZVBhaXIgfTtcbiIsICIvKipcbiAqIGB5YW1sYCBkZWZpbmVzIGRvY3VtZW50LXNwZWNpZmljIG9wdGlvbnMgaW4gdGhyZWUgcGxhY2VzOiBhcyBhbiBhcmd1bWVudCBvZlxuICogcGFyc2UsIGNyZWF0ZSBhbmQgc3RyaW5naWZ5IGNhbGxzLCBpbiB0aGUgdmFsdWVzIG9mIGBZQU1MLmRlZmF1bHRPcHRpb25zYCxcbiAqIGFuZCBpbiB0aGUgdmVyc2lvbi1kZXBlbmRlbnQgYFlBTUwuRG9jdW1lbnQuZGVmYXVsdHNgIG9iamVjdC4gVmFsdWVzIHNldCBpblxuICogYFlBTUwuZGVmYXVsdE9wdGlvbnNgIG92ZXJyaWRlIHZlcnNpb24tZGVwZW5kZW50IGRlZmF1bHRzLCBhbmQgYXJndW1lbnRcbiAqIG9wdGlvbnMgb3ZlcnJpZGUgYm90aC5cbiAqL1xuY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgaW50QXNCaWdJbnQ6IGZhbHNlLFxuICAgIGtlZXBTb3VyY2VUb2tlbnM6IGZhbHNlLFxuICAgIGxvZ0xldmVsOiAnd2FybicsXG4gICAgcHJldHR5RXJyb3JzOiB0cnVlLFxuICAgIHN0cmljdDogdHJ1ZSxcbiAgICB1bmlxdWVLZXlzOiB0cnVlLFxuICAgIHZlcnNpb246ICcxLjInXG59O1xuXG5leHBvcnQgeyBkZWZhdWx0T3B0aW9ucyB9O1xuIiwgImltcG9ydCB7IENvbGxlY3Rpb24gfSBmcm9tICcuLi9ub2Rlcy9Db2xsZWN0aW9uLmpzJztcbmltcG9ydCB7IGlzTm9kZSwgaXNQYWlyIH0gZnJvbSAnLi4vbm9kZXMvTm9kZS5qcyc7XG5pbXBvcnQgeyBzdHJpbmdpZnkgfSBmcm9tICcuL3N0cmluZ2lmeS5qcyc7XG5pbXBvcnQgeyBsaW5lQ29tbWVudCwgaW5kZW50Q29tbWVudCB9IGZyb20gJy4vc3RyaW5naWZ5Q29tbWVudC5qcyc7XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeUNvbGxlY3Rpb24oY29sbGVjdGlvbiwgY3R4LCBvcHRpb25zKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IGZsb3cgPSAoX2EgPSBjdHguaW5GbG93KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBjb2xsZWN0aW9uLmZsb3c7XG4gICAgY29uc3Qgc3RyaW5naWZ5ID0gZmxvdyA/IHN0cmluZ2lmeUZsb3dDb2xsZWN0aW9uIDogc3RyaW5naWZ5QmxvY2tDb2xsZWN0aW9uO1xuICAgIHJldHVybiBzdHJpbmdpZnkoY29sbGVjdGlvbiwgY3R4LCBvcHRpb25zKTtcbn1cbmZ1bmN0aW9uIHN0cmluZ2lmeUJsb2NrQ29sbGVjdGlvbih7IGNvbW1lbnQsIGl0ZW1zIH0sIGN0eCwgeyBibG9ja0l0ZW1QcmVmaXgsIGZsb3dDaGFycywgaXRlbUluZGVudCwgb25DaG9tcEtlZXAsIG9uQ29tbWVudCB9KSB7XG4gICAgY29uc3QgeyBpbmRlbnQsIG9wdGlvbnM6IHsgY29tbWVudFN0cmluZyB9IH0gPSBjdHg7XG4gICAgY29uc3QgaXRlbUN0eCA9IE9iamVjdC5hc3NpZ24oe30sIGN0eCwgeyBpbmRlbnQ6IGl0ZW1JbmRlbnQsIHR5cGU6IG51bGwgfSk7XG4gICAgbGV0IGNob21wS2VlcCA9IGZhbHNlOyAvLyBmbGFnIGZvciB0aGUgcHJlY2VkaW5nIG5vZGUncyBzdGF0dXNcbiAgICBjb25zdCBsaW5lcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29uc3QgaXRlbSA9IGl0ZW1zW2ldO1xuICAgICAgICBsZXQgY29tbWVudCA9IG51bGw7XG4gICAgICAgIGlmIChpc05vZGUoaXRlbSkpIHtcbiAgICAgICAgICAgIGlmICghY2hvbXBLZWVwICYmIGl0ZW0uc3BhY2VCZWZvcmUpXG4gICAgICAgICAgICAgICAgbGluZXMucHVzaCgnJyk7XG4gICAgICAgICAgICBhZGRDb21tZW50QmVmb3JlKGN0eCwgbGluZXMsIGl0ZW0uY29tbWVudEJlZm9yZSwgY2hvbXBLZWVwKTtcbiAgICAgICAgICAgIGlmIChpdGVtLmNvbW1lbnQpXG4gICAgICAgICAgICAgICAgY29tbWVudCA9IGl0ZW0uY29tbWVudDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc1BhaXIoaXRlbSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGlrID0gaXNOb2RlKGl0ZW0ua2V5KSA/IGl0ZW0ua2V5IDogbnVsbDtcbiAgICAgICAgICAgIGlmIChpaykge1xuICAgICAgICAgICAgICAgIGlmICghY2hvbXBLZWVwICYmIGlrLnNwYWNlQmVmb3JlKVxuICAgICAgICAgICAgICAgICAgICBsaW5lcy5wdXNoKCcnKTtcbiAgICAgICAgICAgICAgICBhZGRDb21tZW50QmVmb3JlKGN0eCwgbGluZXMsIGlrLmNvbW1lbnRCZWZvcmUsIGNob21wS2VlcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2hvbXBLZWVwID0gZmFsc2U7XG4gICAgICAgIGxldCBzdHIgPSBzdHJpbmdpZnkoaXRlbSwgaXRlbUN0eCwgKCkgPT4gKGNvbW1lbnQgPSBudWxsKSwgKCkgPT4gKGNob21wS2VlcCA9IHRydWUpKTtcbiAgICAgICAgaWYgKGNvbW1lbnQpXG4gICAgICAgICAgICBzdHIgKz0gbGluZUNvbW1lbnQoc3RyLCBpdGVtSW5kZW50LCBjb21tZW50U3RyaW5nKGNvbW1lbnQpKTtcbiAgICAgICAgaWYgKGNob21wS2VlcCAmJiBjb21tZW50KVxuICAgICAgICAgICAgY2hvbXBLZWVwID0gZmFsc2U7XG4gICAgICAgIGxpbmVzLnB1c2goYmxvY2tJdGVtUHJlZml4ICsgc3RyKTtcbiAgICB9XG4gICAgbGV0IHN0cjtcbiAgICBpZiAobGluZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHN0ciA9IGZsb3dDaGFycy5zdGFydCArIGZsb3dDaGFycy5lbmQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBzdHIgPSBsaW5lc1swXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBsaW5lcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgY29uc3QgbGluZSA9IGxpbmVzW2ldO1xuICAgICAgICAgICAgc3RyICs9IGxpbmUgPyBgXFxuJHtpbmRlbnR9JHtsaW5lfWAgOiAnXFxuJztcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoY29tbWVudCkge1xuICAgICAgICBzdHIgKz0gJ1xcbicgKyBpbmRlbnRDb21tZW50KGNvbW1lbnRTdHJpbmcoY29tbWVudCksIGluZGVudCk7XG4gICAgICAgIGlmIChvbkNvbW1lbnQpXG4gICAgICAgICAgICBvbkNvbW1lbnQoKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoY2hvbXBLZWVwICYmIG9uQ2hvbXBLZWVwKVxuICAgICAgICBvbkNob21wS2VlcCgpO1xuICAgIHJldHVybiBzdHI7XG59XG5mdW5jdGlvbiBzdHJpbmdpZnlGbG93Q29sbGVjdGlvbih7IGNvbW1lbnQsIGl0ZW1zIH0sIGN0eCwgeyBmbG93Q2hhcnMsIGl0ZW1JbmRlbnQsIG9uQ29tbWVudCB9KSB7XG4gICAgY29uc3QgeyBpbmRlbnQsIGluZGVudFN0ZXAsIG9wdGlvbnM6IHsgY29tbWVudFN0cmluZyB9IH0gPSBjdHg7XG4gICAgaXRlbUluZGVudCArPSBpbmRlbnRTdGVwO1xuICAgIGNvbnN0IGl0ZW1DdHggPSBPYmplY3QuYXNzaWduKHt9LCBjdHgsIHtcbiAgICAgICAgaW5kZW50OiBpdGVtSW5kZW50LFxuICAgICAgICBpbkZsb3c6IHRydWUsXG4gICAgICAgIHR5cGU6IG51bGxcbiAgICB9KTtcbiAgICBsZXQgcmVxTmV3bGluZSA9IGZhbHNlO1xuICAgIGxldCBsaW5lc0F0VmFsdWUgPSAwO1xuICAgIGNvbnN0IGxpbmVzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7ICsraSkge1xuICAgICAgICBjb25zdCBpdGVtID0gaXRlbXNbaV07XG4gICAgICAgIGxldCBjb21tZW50ID0gbnVsbDtcbiAgICAgICAgaWYgKGlzTm9kZShpdGVtKSkge1xuICAgICAgICAgICAgaWYgKGl0ZW0uc3BhY2VCZWZvcmUpXG4gICAgICAgICAgICAgICAgbGluZXMucHVzaCgnJyk7XG4gICAgICAgICAgICBhZGRDb21tZW50QmVmb3JlKGN0eCwgbGluZXMsIGl0ZW0uY29tbWVudEJlZm9yZSwgZmFsc2UpO1xuICAgICAgICAgICAgaWYgKGl0ZW0uY29tbWVudClcbiAgICAgICAgICAgICAgICBjb21tZW50ID0gaXRlbS5jb21tZW50O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzUGFpcihpdGVtKSkge1xuICAgICAgICAgICAgY29uc3QgaWsgPSBpc05vZGUoaXRlbS5rZXkpID8gaXRlbS5rZXkgOiBudWxsO1xuICAgICAgICAgICAgaWYgKGlrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlrLnNwYWNlQmVmb3JlKVxuICAgICAgICAgICAgICAgICAgICBsaW5lcy5wdXNoKCcnKTtcbiAgICAgICAgICAgICAgICBhZGRDb21tZW50QmVmb3JlKGN0eCwgbGluZXMsIGlrLmNvbW1lbnRCZWZvcmUsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICBpZiAoaWsuY29tbWVudClcbiAgICAgICAgICAgICAgICAgICAgcmVxTmV3bGluZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBpdiA9IGlzTm9kZShpdGVtLnZhbHVlKSA/IGl0ZW0udmFsdWUgOiBudWxsO1xuICAgICAgICAgICAgaWYgKGl2KSB7XG4gICAgICAgICAgICAgICAgaWYgKGl2LmNvbW1lbnQpXG4gICAgICAgICAgICAgICAgICAgIGNvbW1lbnQgPSBpdi5jb21tZW50O1xuICAgICAgICAgICAgICAgIGlmIChpdi5jb21tZW50QmVmb3JlKVxuICAgICAgICAgICAgICAgICAgICByZXFOZXdsaW5lID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGl0ZW0udmFsdWUgPT0gbnVsbCAmJiBpayAmJiBpay5jb21tZW50KSB7XG4gICAgICAgICAgICAgICAgY29tbWVudCA9IGlrLmNvbW1lbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbW1lbnQpXG4gICAgICAgICAgICByZXFOZXdsaW5lID0gdHJ1ZTtcbiAgICAgICAgbGV0IHN0ciA9IHN0cmluZ2lmeShpdGVtLCBpdGVtQ3R4LCAoKSA9PiAoY29tbWVudCA9IG51bGwpKTtcbiAgICAgICAgaWYgKGkgPCBpdGVtcy5sZW5ndGggLSAxKVxuICAgICAgICAgICAgc3RyICs9ICcsJztcbiAgICAgICAgaWYgKGNvbW1lbnQpXG4gICAgICAgICAgICBzdHIgKz0gbGluZUNvbW1lbnQoc3RyLCBpdGVtSW5kZW50LCBjb21tZW50U3RyaW5nKGNvbW1lbnQpKTtcbiAgICAgICAgaWYgKCFyZXFOZXdsaW5lICYmIChsaW5lcy5sZW5ndGggPiBsaW5lc0F0VmFsdWUgfHwgc3RyLmluY2x1ZGVzKCdcXG4nKSkpXG4gICAgICAgICAgICByZXFOZXdsaW5lID0gdHJ1ZTtcbiAgICAgICAgbGluZXMucHVzaChzdHIpO1xuICAgICAgICBsaW5lc0F0VmFsdWUgPSBsaW5lcy5sZW5ndGg7XG4gICAgfVxuICAgIGxldCBzdHI7XG4gICAgY29uc3QgeyBzdGFydCwgZW5kIH0gPSBmbG93Q2hhcnM7XG4gICAgaWYgKGxpbmVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBzdHIgPSBzdGFydCArIGVuZDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmICghcmVxTmV3bGluZSkge1xuICAgICAgICAgICAgY29uc3QgbGVuID0gbGluZXMucmVkdWNlKChzdW0sIGxpbmUpID0+IHN1bSArIGxpbmUubGVuZ3RoICsgMiwgMik7XG4gICAgICAgICAgICByZXFOZXdsaW5lID0gbGVuID4gQ29sbGVjdGlvbi5tYXhGbG93U3RyaW5nU2luZ2xlTGluZUxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVxTmV3bGluZSkge1xuICAgICAgICAgICAgc3RyID0gc3RhcnQ7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGxpbmUgb2YgbGluZXMpXG4gICAgICAgICAgICAgICAgc3RyICs9IGxpbmUgPyBgXFxuJHtpbmRlbnRTdGVwfSR7aW5kZW50fSR7bGluZX1gIDogJ1xcbic7XG4gICAgICAgICAgICBzdHIgKz0gYFxcbiR7aW5kZW50fSR7ZW5kfWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdHIgPSBgJHtzdGFydH0gJHtsaW5lcy5qb2luKCcgJyl9ICR7ZW5kfWA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNvbW1lbnQpIHtcbiAgICAgICAgc3RyICs9IGxpbmVDb21tZW50KHN0ciwgY29tbWVudFN0cmluZyhjb21tZW50KSwgaW5kZW50KTtcbiAgICAgICAgaWYgKG9uQ29tbWVudClcbiAgICAgICAgICAgIG9uQ29tbWVudCgpO1xuICAgIH1cbiAgICByZXR1cm4gc3RyO1xufVxuZnVuY3Rpb24gYWRkQ29tbWVudEJlZm9yZSh7IGluZGVudCwgb3B0aW9uczogeyBjb21tZW50U3RyaW5nIH0gfSwgbGluZXMsIGNvbW1lbnQsIGNob21wS2VlcCkge1xuICAgIGlmIChjb21tZW50ICYmIGNob21wS2VlcClcbiAgICAgICAgY29tbWVudCA9IGNvbW1lbnQucmVwbGFjZSgvXlxcbisvLCAnJyk7XG4gICAgaWYgKGNvbW1lbnQpIHtcbiAgICAgICAgY29uc3QgaWMgPSBpbmRlbnRDb21tZW50KGNvbW1lbnRTdHJpbmcoY29tbWVudCksIGluZGVudCk7XG4gICAgICAgIGxpbmVzLnB1c2goaWMudHJpbVN0YXJ0KCkpOyAvLyBBdm9pZCBkb3VibGUgaW5kZW50IG9uIGZpcnN0IGxpbmVcbiAgICB9XG59XG5cbmV4cG9ydCB7IHN0cmluZ2lmeUNvbGxlY3Rpb24gfTtcbiIsICJpbXBvcnQgeyBzdHJpbmdpZnlDb2xsZWN0aW9uIH0gZnJvbSAnLi4vc3RyaW5naWZ5L3N0cmluZ2lmeUNvbGxlY3Rpb24uanMnO1xuaW1wb3J0IHsgYWRkUGFpclRvSlNNYXAgfSBmcm9tICcuL2FkZFBhaXJUb0pTTWFwLmpzJztcbmltcG9ydCB7IENvbGxlY3Rpb24gfSBmcm9tICcuL0NvbGxlY3Rpb24uanMnO1xuaW1wb3J0IHsgaXNQYWlyLCBpc1NjYWxhciwgTUFQIH0gZnJvbSAnLi9Ob2RlLmpzJztcbmltcG9ydCB7IFBhaXIgfSBmcm9tICcuL1BhaXIuanMnO1xuaW1wb3J0IHsgaXNTY2FsYXJWYWx1ZSB9IGZyb20gJy4vU2NhbGFyLmpzJztcblxuZnVuY3Rpb24gZmluZFBhaXIoaXRlbXMsIGtleSkge1xuICAgIGNvbnN0IGsgPSBpc1NjYWxhcihrZXkpID8ga2V5LnZhbHVlIDoga2V5O1xuICAgIGZvciAoY29uc3QgaXQgb2YgaXRlbXMpIHtcbiAgICAgICAgaWYgKGlzUGFpcihpdCkpIHtcbiAgICAgICAgICAgIGlmIChpdC5rZXkgPT09IGtleSB8fCBpdC5rZXkgPT09IGspXG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0O1xuICAgICAgICAgICAgaWYgKGlzU2NhbGFyKGl0LmtleSkgJiYgaXQua2V5LnZhbHVlID09PSBrKVxuICAgICAgICAgICAgICAgIHJldHVybiBpdDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuY2xhc3MgWUFNTE1hcCBleHRlbmRzIENvbGxlY3Rpb24ge1xuICAgIGNvbnN0cnVjdG9yKHNjaGVtYSkge1xuICAgICAgICBzdXBlcihNQVAsIHNjaGVtYSk7XG4gICAgICAgIHRoaXMuaXRlbXMgPSBbXTtcbiAgICB9XG4gICAgc3RhdGljIGdldCB0YWdOYW1lKCkge1xuICAgICAgICByZXR1cm4gJ3RhZzp5YW1sLm9yZywyMDAyOm1hcCc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYSB2YWx1ZSB0byB0aGUgY29sbGVjdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvdmVyd3JpdGUgLSBJZiBub3Qgc2V0IGB0cnVlYCwgdXNpbmcgYSBrZXkgdGhhdCBpcyBhbHJlYWR5IGluIHRoZVxuICAgICAqICAgY29sbGVjdGlvbiB3aWxsIHRocm93LiBPdGhlcndpc2UsIG92ZXJ3cml0ZXMgdGhlIHByZXZpb3VzIHZhbHVlLlxuICAgICAqL1xuICAgIGFkZChwYWlyLCBvdmVyd3JpdGUpIHtcbiAgICAgICAgbGV0IF9wYWlyO1xuICAgICAgICBpZiAoaXNQYWlyKHBhaXIpKVxuICAgICAgICAgICAgX3BhaXIgPSBwYWlyO1xuICAgICAgICBlbHNlIGlmICghcGFpciB8fCB0eXBlb2YgcGFpciAhPT0gJ29iamVjdCcgfHwgISgna2V5JyBpbiBwYWlyKSkge1xuICAgICAgICAgICAgLy8gSW4gVHlwZVNjcmlwdCwgdGhpcyBuZXZlciBoYXBwZW5zLlxuICAgICAgICAgICAgX3BhaXIgPSBuZXcgUGFpcihwYWlyLCBwYWlyLnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICBfcGFpciA9IG5ldyBQYWlyKHBhaXIua2V5LCBwYWlyLnZhbHVlKTtcbiAgICAgICAgY29uc3QgcHJldiA9IGZpbmRQYWlyKHRoaXMuaXRlbXMsIF9wYWlyLmtleSk7XG4gICAgICAgIGNvbnN0IHNvcnRFbnRyaWVzID0gdGhpcy5zY2hlbWEgJiYgdGhpcy5zY2hlbWEuc29ydE1hcEVudHJpZXM7XG4gICAgICAgIGlmIChwcmV2KSB7XG4gICAgICAgICAgICBpZiAoIW92ZXJ3cml0ZSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEtleSAke19wYWlyLmtleX0gYWxyZWFkeSBzZXRgKTtcbiAgICAgICAgICAgIC8vIEZvciBzY2FsYXJzLCBrZWVwIHRoZSBvbGQgbm9kZSAmIGl0cyBjb21tZW50cyBhbmQgYW5jaG9yc1xuICAgICAgICAgICAgaWYgKGlzU2NhbGFyKHByZXYudmFsdWUpICYmIGlzU2NhbGFyVmFsdWUoX3BhaXIudmFsdWUpKVxuICAgICAgICAgICAgICAgIHByZXYudmFsdWUudmFsdWUgPSBfcGFpci52YWx1ZTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBwcmV2LnZhbHVlID0gX3BhaXIudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc29ydEVudHJpZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGkgPSB0aGlzLml0ZW1zLmZpbmRJbmRleChpdGVtID0+IHNvcnRFbnRyaWVzKF9wYWlyLCBpdGVtKSA8IDApO1xuICAgICAgICAgICAgaWYgKGkgPT09IC0xKVxuICAgICAgICAgICAgICAgIHRoaXMuaXRlbXMucHVzaChfcGFpcik7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhpcy5pdGVtcy5zcGxpY2UoaSwgMCwgX3BhaXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5pdGVtcy5wdXNoKF9wYWlyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkZWxldGUoa2V5KSB7XG4gICAgICAgIGNvbnN0IGl0ID0gZmluZFBhaXIodGhpcy5pdGVtcywga2V5KTtcbiAgICAgICAgaWYgKCFpdClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgY29uc3QgZGVsID0gdGhpcy5pdGVtcy5zcGxpY2UodGhpcy5pdGVtcy5pbmRleE9mKGl0KSwgMSk7XG4gICAgICAgIHJldHVybiBkZWwubGVuZ3RoID4gMDtcbiAgICB9XG4gICAgZ2V0KGtleSwga2VlcFNjYWxhcikge1xuICAgICAgICBjb25zdCBpdCA9IGZpbmRQYWlyKHRoaXMuaXRlbXMsIGtleSk7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBpdCAmJiBpdC52YWx1ZTtcbiAgICAgICAgcmV0dXJuICFrZWVwU2NhbGFyICYmIGlzU2NhbGFyKG5vZGUpID8gbm9kZS52YWx1ZSA6IG5vZGU7XG4gICAgfVxuICAgIGhhcyhrZXkpIHtcbiAgICAgICAgcmV0dXJuICEhZmluZFBhaXIodGhpcy5pdGVtcywga2V5KTtcbiAgICB9XG4gICAgc2V0KGtleSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5hZGQobmV3IFBhaXIoa2V5LCB2YWx1ZSksIHRydWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gY3R4IC0gQ29udmVyc2lvbiBjb250ZXh0LCBvcmlnaW5hbGx5IHNldCBpbiBEb2N1bWVudCN0b0pTKClcbiAgICAgKiBAcGFyYW0ge0NsYXNzfSBUeXBlIC0gSWYgc2V0LCBmb3JjZXMgdGhlIHJldHVybmVkIGNvbGxlY3Rpb24gdHlwZVxuICAgICAqIEByZXR1cm5zIEluc3RhbmNlIG9mIFR5cGUsIE1hcCwgb3IgT2JqZWN0XG4gICAgICovXG4gICAgdG9KU09OKF8sIGN0eCwgVHlwZSkge1xuICAgICAgICBjb25zdCBtYXAgPSBUeXBlID8gbmV3IFR5cGUoKSA6IGN0eCAmJiBjdHgubWFwQXNNYXAgPyBuZXcgTWFwKCkgOiB7fTtcbiAgICAgICAgaWYgKGN0eCAmJiBjdHgub25DcmVhdGUpXG4gICAgICAgICAgICBjdHgub25DcmVhdGUobWFwKTtcbiAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIHRoaXMuaXRlbXMpXG4gICAgICAgICAgICBhZGRQYWlyVG9KU01hcChjdHgsIG1hcCwgaXRlbSk7XG4gICAgICAgIHJldHVybiBtYXA7XG4gICAgfVxuICAgIHRvU3RyaW5nKGN0eCwgb25Db21tZW50LCBvbkNob21wS2VlcCkge1xuICAgICAgICBpZiAoIWN0eClcbiAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzKTtcbiAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIHRoaXMuaXRlbXMpIHtcbiAgICAgICAgICAgIGlmICghaXNQYWlyKGl0ZW0pKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTWFwIGl0ZW1zIG11c3QgYWxsIGJlIHBhaXJzOyBmb3VuZCAke0pTT04uc3RyaW5naWZ5KGl0ZW0pfSBpbnN0ZWFkYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjdHguYWxsTnVsbFZhbHVlcyAmJiB0aGlzLmhhc0FsbE51bGxWYWx1ZXMoZmFsc2UpKVxuICAgICAgICAgICAgY3R4ID0gT2JqZWN0LmFzc2lnbih7fSwgY3R4LCB7IGFsbE51bGxWYWx1ZXM6IHRydWUgfSk7XG4gICAgICAgIHJldHVybiBzdHJpbmdpZnlDb2xsZWN0aW9uKHRoaXMsIGN0eCwge1xuICAgICAgICAgICAgYmxvY2tJdGVtUHJlZml4OiAnJyxcbiAgICAgICAgICAgIGZsb3dDaGFyczogeyBzdGFydDogJ3snLCBlbmQ6ICd9JyB9LFxuICAgICAgICAgICAgaXRlbUluZGVudDogY3R4LmluZGVudCB8fCAnJyxcbiAgICAgICAgICAgIG9uQ2hvbXBLZWVwLFxuICAgICAgICAgICAgb25Db21tZW50XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuZXhwb3J0IHsgWUFNTE1hcCwgZmluZFBhaXIgfTtcbiIsICJpbXBvcnQgeyBpc01hcCB9IGZyb20gJy4uLy4uL25vZGVzL05vZGUuanMnO1xuaW1wb3J0IHsgY3JlYXRlUGFpciB9IGZyb20gJy4uLy4uL25vZGVzL1BhaXIuanMnO1xuaW1wb3J0IHsgWUFNTE1hcCB9IGZyb20gJy4uLy4uL25vZGVzL1lBTUxNYXAuanMnO1xuXG5mdW5jdGlvbiBjcmVhdGVNYXAoc2NoZW1hLCBvYmosIGN0eCkge1xuICAgIGNvbnN0IHsga2VlcFVuZGVmaW5lZCwgcmVwbGFjZXIgfSA9IGN0eDtcbiAgICBjb25zdCBtYXAgPSBuZXcgWUFNTE1hcChzY2hlbWEpO1xuICAgIGNvbnN0IGFkZCA9IChrZXksIHZhbHVlKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgcmVwbGFjZXIgPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICB2YWx1ZSA9IHJlcGxhY2VyLmNhbGwob2JqLCBrZXksIHZhbHVlKTtcbiAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShyZXBsYWNlcikgJiYgIXJlcGxhY2VyLmluY2x1ZGVzKGtleSkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkIHx8IGtlZXBVbmRlZmluZWQpXG4gICAgICAgICAgICBtYXAuaXRlbXMucHVzaChjcmVhdGVQYWlyKGtleSwgdmFsdWUsIGN0eCkpO1xuICAgIH07XG4gICAgaWYgKG9iaiBpbnN0YW5jZW9mIE1hcCkge1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBvYmopXG4gICAgICAgICAgICBhZGQoa2V5LCB2YWx1ZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKG9iaiAmJiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0Jykge1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhvYmopKVxuICAgICAgICAgICAgYWRkKGtleSwgb2JqW2tleV0pO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHNjaGVtYS5zb3J0TWFwRW50cmllcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBtYXAuaXRlbXMuc29ydChzY2hlbWEuc29ydE1hcEVudHJpZXMpO1xuICAgIH1cbiAgICByZXR1cm4gbWFwO1xufVxuY29uc3QgbWFwID0ge1xuICAgIGNvbGxlY3Rpb246ICdtYXAnLFxuICAgIGNyZWF0ZU5vZGU6IGNyZWF0ZU1hcCxcbiAgICBkZWZhdWx0OiB0cnVlLFxuICAgIG5vZGVDbGFzczogWUFNTE1hcCxcbiAgICB0YWc6ICd0YWc6eWFtbC5vcmcsMjAwMjptYXAnLFxuICAgIHJlc29sdmUobWFwLCBvbkVycm9yKSB7XG4gICAgICAgIGlmICghaXNNYXAobWFwKSlcbiAgICAgICAgICAgIG9uRXJyb3IoJ0V4cGVjdGVkIGEgbWFwcGluZyBmb3IgdGhpcyB0YWcnKTtcbiAgICAgICAgcmV0dXJuIG1hcDtcbiAgICB9XG59O1xuXG5leHBvcnQgeyBtYXAgfTtcbiIsICJpbXBvcnQgeyBzdHJpbmdpZnlDb2xsZWN0aW9uIH0gZnJvbSAnLi4vc3RyaW5naWZ5L3N0cmluZ2lmeUNvbGxlY3Rpb24uanMnO1xuaW1wb3J0IHsgQ29sbGVjdGlvbiB9IGZyb20gJy4vQ29sbGVjdGlvbi5qcyc7XG5pbXBvcnQgeyBTRVEsIGlzU2NhbGFyIH0gZnJvbSAnLi9Ob2RlLmpzJztcbmltcG9ydCB7IGlzU2NhbGFyVmFsdWUgfSBmcm9tICcuL1NjYWxhci5qcyc7XG5pbXBvcnQgeyB0b0pTIH0gZnJvbSAnLi90b0pTLmpzJztcblxuY2xhc3MgWUFNTFNlcSBleHRlbmRzIENvbGxlY3Rpb24ge1xuICAgIGNvbnN0cnVjdG9yKHNjaGVtYSkge1xuICAgICAgICBzdXBlcihTRVEsIHNjaGVtYSk7XG4gICAgICAgIHRoaXMuaXRlbXMgPSBbXTtcbiAgICB9XG4gICAgc3RhdGljIGdldCB0YWdOYW1lKCkge1xuICAgICAgICByZXR1cm4gJ3RhZzp5YW1sLm9yZywyMDAyOnNlcSc7XG4gICAgfVxuICAgIGFkZCh2YWx1ZSkge1xuICAgICAgICB0aGlzLml0ZW1zLnB1c2godmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGEgdmFsdWUgZnJvbSB0aGUgY29sbGVjdGlvbi5cbiAgICAgKlxuICAgICAqIGBrZXlgIG11c3QgY29udGFpbiBhIHJlcHJlc2VudGF0aW9uIG9mIGFuIGludGVnZXIgZm9yIHRoaXMgdG8gc3VjY2VlZC5cbiAgICAgKiBJdCBtYXkgYmUgd3JhcHBlZCBpbiBhIGBTY2FsYXJgLlxuICAgICAqXG4gICAgICogQHJldHVybnMgYHRydWVgIGlmIHRoZSBpdGVtIHdhcyBmb3VuZCBhbmQgcmVtb3ZlZC5cbiAgICAgKi9cbiAgICBkZWxldGUoa2V5KSB7XG4gICAgICAgIGNvbnN0IGlkeCA9IGFzSXRlbUluZGV4KGtleSk7XG4gICAgICAgIGlmICh0eXBlb2YgaWR4ICE9PSAnbnVtYmVyJylcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgY29uc3QgZGVsID0gdGhpcy5pdGVtcy5zcGxpY2UoaWR4LCAxKTtcbiAgICAgICAgcmV0dXJuIGRlbC5sZW5ndGggPiAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGl0ZW0gYXQgYGtleWAsIG9yIGB1bmRlZmluZWRgIGlmIG5vdCBmb3VuZC4gQnkgZGVmYXVsdCB1bndyYXBzXG4gICAgICogc2NhbGFyIHZhbHVlcyBmcm9tIHRoZWlyIHN1cnJvdW5kaW5nIG5vZGU7IHRvIGRpc2FibGUgc2V0IGBrZWVwU2NhbGFyYCB0b1xuICAgICAqIGB0cnVlYCAoY29sbGVjdGlvbnMgYXJlIGFsd2F5cyByZXR1cm5lZCBpbnRhY3QpLlxuICAgICAqXG4gICAgICogYGtleWAgbXVzdCBjb250YWluIGEgcmVwcmVzZW50YXRpb24gb2YgYW4gaW50ZWdlciBmb3IgdGhpcyB0byBzdWNjZWVkLlxuICAgICAqIEl0IG1heSBiZSB3cmFwcGVkIGluIGEgYFNjYWxhcmAuXG4gICAgICovXG4gICAgZ2V0KGtleSwga2VlcFNjYWxhcikge1xuICAgICAgICBjb25zdCBpZHggPSBhc0l0ZW1JbmRleChrZXkpO1xuICAgICAgICBpZiAodHlwZW9mIGlkeCAhPT0gJ251bWJlcicpXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCBpdCA9IHRoaXMuaXRlbXNbaWR4XTtcbiAgICAgICAgcmV0dXJuICFrZWVwU2NhbGFyICYmIGlzU2NhbGFyKGl0KSA/IGl0LnZhbHVlIDogaXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGUgY29sbGVjdGlvbiBpbmNsdWRlcyBhIHZhbHVlIHdpdGggdGhlIGtleSBga2V5YC5cbiAgICAgKlxuICAgICAqIGBrZXlgIG11c3QgY29udGFpbiBhIHJlcHJlc2VudGF0aW9uIG9mIGFuIGludGVnZXIgZm9yIHRoaXMgdG8gc3VjY2VlZC5cbiAgICAgKiBJdCBtYXkgYmUgd3JhcHBlZCBpbiBhIGBTY2FsYXJgLlxuICAgICAqL1xuICAgIGhhcyhrZXkpIHtcbiAgICAgICAgY29uc3QgaWR4ID0gYXNJdGVtSW5kZXgoa2V5KTtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBpZHggPT09ICdudW1iZXInICYmIGlkeCA8IHRoaXMuaXRlbXMubGVuZ3RoO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIGEgdmFsdWUgaW4gdGhpcyBjb2xsZWN0aW9uLiBGb3IgYCEhc2V0YCwgYHZhbHVlYCBuZWVkcyB0byBiZSBhXG4gICAgICogYm9vbGVhbiB0byBhZGQvcmVtb3ZlIHRoZSBpdGVtIGZyb20gdGhlIHNldC5cbiAgICAgKlxuICAgICAqIElmIGBrZXlgIGRvZXMgbm90IGNvbnRhaW4gYSByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnRlZ2VyLCB0aGlzIHdpbGwgdGhyb3cuXG4gICAgICogSXQgbWF5IGJlIHdyYXBwZWQgaW4gYSBgU2NhbGFyYC5cbiAgICAgKi9cbiAgICBzZXQoa2V5LCB2YWx1ZSkge1xuICAgICAgICBjb25zdCBpZHggPSBhc0l0ZW1JbmRleChrZXkpO1xuICAgICAgICBpZiAodHlwZW9mIGlkeCAhPT0gJ251bWJlcicpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIGEgdmFsaWQgaW5kZXgsIG5vdCAke2tleX0uYCk7XG4gICAgICAgIGNvbnN0IHByZXYgPSB0aGlzLml0ZW1zW2lkeF07XG4gICAgICAgIGlmIChpc1NjYWxhcihwcmV2KSAmJiBpc1NjYWxhclZhbHVlKHZhbHVlKSlcbiAgICAgICAgICAgIHByZXYudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy5pdGVtc1tpZHhdID0gdmFsdWU7XG4gICAgfVxuICAgIHRvSlNPTihfLCBjdHgpIHtcbiAgICAgICAgY29uc3Qgc2VxID0gW107XG4gICAgICAgIGlmIChjdHggJiYgY3R4Lm9uQ3JlYXRlKVxuICAgICAgICAgICAgY3R4Lm9uQ3JlYXRlKHNlcSk7XG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIHRoaXMuaXRlbXMpXG4gICAgICAgICAgICBzZXEucHVzaCh0b0pTKGl0ZW0sIFN0cmluZyhpKyspLCBjdHgpKTtcbiAgICAgICAgcmV0dXJuIHNlcTtcbiAgICB9XG4gICAgdG9TdHJpbmcoY3R4LCBvbkNvbW1lbnQsIG9uQ2hvbXBLZWVwKSB7XG4gICAgICAgIGlmICghY3R4KVxuICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMpO1xuICAgICAgICByZXR1cm4gc3RyaW5naWZ5Q29sbGVjdGlvbih0aGlzLCBjdHgsIHtcbiAgICAgICAgICAgIGJsb2NrSXRlbVByZWZpeDogJy0gJyxcbiAgICAgICAgICAgIGZsb3dDaGFyczogeyBzdGFydDogJ1snLCBlbmQ6ICddJyB9LFxuICAgICAgICAgICAgaXRlbUluZGVudDogKGN0eC5pbmRlbnQgfHwgJycpICsgJyAgJyxcbiAgICAgICAgICAgIG9uQ2hvbXBLZWVwLFxuICAgICAgICAgICAgb25Db21tZW50XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGFzSXRlbUluZGV4KGtleSkge1xuICAgIGxldCBpZHggPSBpc1NjYWxhcihrZXkpID8ga2V5LnZhbHVlIDoga2V5O1xuICAgIGlmIChpZHggJiYgdHlwZW9mIGlkeCA9PT0gJ3N0cmluZycpXG4gICAgICAgIGlkeCA9IE51bWJlcihpZHgpO1xuICAgIHJldHVybiB0eXBlb2YgaWR4ID09PSAnbnVtYmVyJyAmJiBOdW1iZXIuaXNJbnRlZ2VyKGlkeCkgJiYgaWR4ID49IDBcbiAgICAgICAgPyBpZHhcbiAgICAgICAgOiBudWxsO1xufVxuXG5leHBvcnQgeyBZQU1MU2VxIH07XG4iLCAiaW1wb3J0IHsgY3JlYXRlTm9kZSB9IGZyb20gJy4uLy4uL2RvYy9jcmVhdGVOb2RlLmpzJztcbmltcG9ydCB7IGlzU2VxIH0gZnJvbSAnLi4vLi4vbm9kZXMvTm9kZS5qcyc7XG5pbXBvcnQgeyBZQU1MU2VxIH0gZnJvbSAnLi4vLi4vbm9kZXMvWUFNTFNlcS5qcyc7XG5cbmZ1bmN0aW9uIGNyZWF0ZVNlcShzY2hlbWEsIG9iaiwgY3R4KSB7XG4gICAgY29uc3QgeyByZXBsYWNlciB9ID0gY3R4O1xuICAgIGNvbnN0IHNlcSA9IG5ldyBZQU1MU2VxKHNjaGVtYSk7XG4gICAgaWYgKG9iaiAmJiBTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KG9iaikpIHtcbiAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICBmb3IgKGxldCBpdCBvZiBvYmopIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcmVwbGFjZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBvYmogaW5zdGFuY2VvZiBTZXQgPyBpdCA6IFN0cmluZyhpKyspO1xuICAgICAgICAgICAgICAgIGl0ID0gcmVwbGFjZXIuY2FsbChvYmosIGtleSwgaXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VxLml0ZW1zLnB1c2goY3JlYXRlTm9kZShpdCwgdW5kZWZpbmVkLCBjdHgpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2VxO1xufVxuY29uc3Qgc2VxID0ge1xuICAgIGNvbGxlY3Rpb246ICdzZXEnLFxuICAgIGNyZWF0ZU5vZGU6IGNyZWF0ZVNlcSxcbiAgICBkZWZhdWx0OiB0cnVlLFxuICAgIG5vZGVDbGFzczogWUFNTFNlcSxcbiAgICB0YWc6ICd0YWc6eWFtbC5vcmcsMjAwMjpzZXEnLFxuICAgIHJlc29sdmUoc2VxLCBvbkVycm9yKSB7XG4gICAgICAgIGlmICghaXNTZXEoc2VxKSlcbiAgICAgICAgICAgIG9uRXJyb3IoJ0V4cGVjdGVkIGEgc2VxdWVuY2UgZm9yIHRoaXMgdGFnJyk7XG4gICAgICAgIHJldHVybiBzZXE7XG4gICAgfVxufTtcblxuZXhwb3J0IHsgc2VxIH07XG4iLCAiaW1wb3J0IHsgc3RyaW5naWZ5U3RyaW5nIH0gZnJvbSAnLi4vLi4vc3RyaW5naWZ5L3N0cmluZ2lmeVN0cmluZy5qcyc7XG5cbmNvbnN0IHN0cmluZyA9IHtcbiAgICBpZGVudGlmeTogdmFsdWUgPT4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyxcbiAgICBkZWZhdWx0OiB0cnVlLFxuICAgIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOnN0cicsXG4gICAgcmVzb2x2ZTogc3RyID0+IHN0cixcbiAgICBzdHJpbmdpZnkoaXRlbSwgY3R4LCBvbkNvbW1lbnQsIG9uQ2hvbXBLZWVwKSB7XG4gICAgICAgIGN0eCA9IE9iamVjdC5hc3NpZ24oeyBhY3R1YWxTdHJpbmc6IHRydWUgfSwgY3R4KTtcbiAgICAgICAgcmV0dXJuIHN0cmluZ2lmeVN0cmluZyhpdGVtLCBjdHgsIG9uQ29tbWVudCwgb25DaG9tcEtlZXApO1xuICAgIH1cbn07XG5cbmV4cG9ydCB7IHN0cmluZyB9O1xuIiwgImltcG9ydCB7IFNjYWxhciB9IGZyb20gJy4uLy4uL25vZGVzL1NjYWxhci5qcyc7XG5cbmNvbnN0IG51bGxUYWcgPSB7XG4gICAgaWRlbnRpZnk6IHZhbHVlID0+IHZhbHVlID09IG51bGwsXG4gICAgY3JlYXRlTm9kZTogKCkgPT4gbmV3IFNjYWxhcihudWxsKSxcbiAgICBkZWZhdWx0OiB0cnVlLFxuICAgIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOm51bGwnLFxuICAgIHRlc3Q6IC9eKD86fnxbTm5ddWxsfE5VTEwpPyQvLFxuICAgIHJlc29sdmU6ICgpID0+IG5ldyBTY2FsYXIobnVsbCksXG4gICAgc3RyaW5naWZ5OiAoeyBzb3VyY2UgfSwgY3R4KSA9PiBzb3VyY2UgJiYgbnVsbFRhZy50ZXN0LnRlc3Qoc291cmNlKSA/IHNvdXJjZSA6IGN0eC5vcHRpb25zLm51bGxTdHJcbn07XG5cbmV4cG9ydCB7IG51bGxUYWcgfTtcbiIsICJpbXBvcnQgeyBTY2FsYXIgfSBmcm9tICcuLi8uLi9ub2Rlcy9TY2FsYXIuanMnO1xuXG5jb25zdCBib29sVGFnID0ge1xuICAgIGlkZW50aWZ5OiB2YWx1ZSA9PiB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJyxcbiAgICBkZWZhdWx0OiB0cnVlLFxuICAgIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOmJvb2wnLFxuICAgIHRlc3Q6IC9eKD86W1R0XXJ1ZXxUUlVFfFtGZl1hbHNlfEZBTFNFKSQvLFxuICAgIHJlc29sdmU6IHN0ciA9PiBuZXcgU2NhbGFyKHN0clswXSA9PT0gJ3QnIHx8IHN0clswXSA9PT0gJ1QnKSxcbiAgICBzdHJpbmdpZnkoeyBzb3VyY2UsIHZhbHVlIH0sIGN0eCkge1xuICAgICAgICBpZiAoc291cmNlICYmIGJvb2xUYWcudGVzdC50ZXN0KHNvdXJjZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHN2ID0gc291cmNlWzBdID09PSAndCcgfHwgc291cmNlWzBdID09PSAnVCc7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IHN2KVxuICAgICAgICAgICAgICAgIHJldHVybiBzb3VyY2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlID8gY3R4Lm9wdGlvbnMudHJ1ZVN0ciA6IGN0eC5vcHRpb25zLmZhbHNlU3RyO1xuICAgIH1cbn07XG5cbmV4cG9ydCB7IGJvb2xUYWcgfTtcbiIsICJmdW5jdGlvbiBzdHJpbmdpZnlOdW1iZXIoeyBmb3JtYXQsIG1pbkZyYWN0aW9uRGlnaXRzLCB0YWcsIHZhbHVlIH0pIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnYmlnaW50JylcbiAgICAgICAgcmV0dXJuIFN0cmluZyh2YWx1ZSk7XG4gICAgY29uc3QgbnVtID0gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyA/IHZhbHVlIDogTnVtYmVyKHZhbHVlKTtcbiAgICBpZiAoIWlzRmluaXRlKG51bSkpXG4gICAgICAgIHJldHVybiBpc05hTihudW0pID8gJy5uYW4nIDogbnVtIDwgMCA/ICctLmluZicgOiAnLmluZic7XG4gICAgbGV0IG4gPSBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG4gICAgaWYgKCFmb3JtYXQgJiZcbiAgICAgICAgbWluRnJhY3Rpb25EaWdpdHMgJiZcbiAgICAgICAgKCF0YWcgfHwgdGFnID09PSAndGFnOnlhbWwub3JnLDIwMDI6ZmxvYXQnKSAmJlxuICAgICAgICAvXlxcZC8udGVzdChuKSkge1xuICAgICAgICBsZXQgaSA9IG4uaW5kZXhPZignLicpO1xuICAgICAgICBpZiAoaSA8IDApIHtcbiAgICAgICAgICAgIGkgPSBuLmxlbmd0aDtcbiAgICAgICAgICAgIG4gKz0gJy4nO1xuICAgICAgICB9XG4gICAgICAgIGxldCBkID0gbWluRnJhY3Rpb25EaWdpdHMgLSAobi5sZW5ndGggLSBpIC0gMSk7XG4gICAgICAgIHdoaWxlIChkLS0gPiAwKVxuICAgICAgICAgICAgbiArPSAnMCc7XG4gICAgfVxuICAgIHJldHVybiBuO1xufVxuXG5leHBvcnQgeyBzdHJpbmdpZnlOdW1iZXIgfTtcbiIsICJpbXBvcnQgeyBTY2FsYXIgfSBmcm9tICcuLi8uLi9ub2Rlcy9TY2FsYXIuanMnO1xuaW1wb3J0IHsgc3RyaW5naWZ5TnVtYmVyIH0gZnJvbSAnLi4vLi4vc3RyaW5naWZ5L3N0cmluZ2lmeU51bWJlci5qcyc7XG5cbmNvbnN0IGZsb2F0TmFOID0ge1xuICAgIGlkZW50aWZ5OiB2YWx1ZSA9PiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInLFxuICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6ZmxvYXQnLFxuICAgIHRlc3Q6IC9eKD86Wy0rXT9cXC4oPzppbmZ8SW5mfElORnxuYW58TmFOfE5BTikpJC8sXG4gICAgcmVzb2x2ZTogc3RyID0+IHN0ci5zbGljZSgtMykudG9Mb3dlckNhc2UoKSA9PT0gJ25hbidcbiAgICAgICAgPyBOYU5cbiAgICAgICAgOiBzdHJbMF0gPT09ICctJ1xuICAgICAgICAgICAgPyBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFlcbiAgICAgICAgICAgIDogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLFxuICAgIHN0cmluZ2lmeTogc3RyaW5naWZ5TnVtYmVyXG59O1xuY29uc3QgZmxvYXRFeHAgPSB7XG4gICAgaWRlbnRpZnk6IHZhbHVlID0+IHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicsXG4gICAgZGVmYXVsdDogdHJ1ZSxcbiAgICB0YWc6ICd0YWc6eWFtbC5vcmcsMjAwMjpmbG9hdCcsXG4gICAgZm9ybWF0OiAnRVhQJyxcbiAgICB0ZXN0OiAvXlstK10/KD86XFwuWzAtOV0rfFswLTldKyg/OlxcLlswLTldKik/KVtlRV1bLStdP1swLTldKyQvLFxuICAgIHJlc29sdmU6IHN0ciA9PiBwYXJzZUZsb2F0KHN0ciksXG4gICAgc3RyaW5naWZ5KG5vZGUpIHtcbiAgICAgICAgY29uc3QgbnVtID0gTnVtYmVyKG5vZGUudmFsdWUpO1xuICAgICAgICByZXR1cm4gaXNGaW5pdGUobnVtKSA/IG51bS50b0V4cG9uZW50aWFsKCkgOiBzdHJpbmdpZnlOdW1iZXIobm9kZSk7XG4gICAgfVxufTtcbmNvbnN0IGZsb2F0ID0ge1xuICAgIGlkZW50aWZ5OiB2YWx1ZSA9PiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInLFxuICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6ZmxvYXQnLFxuICAgIHRlc3Q6IC9eWy0rXT8oPzpcXC5bMC05XSt8WzAtOV0rXFwuWzAtOV0qKSQvLFxuICAgIHJlc29sdmUoc3RyKSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBuZXcgU2NhbGFyKHBhcnNlRmxvYXQoc3RyKSk7XG4gICAgICAgIGNvbnN0IGRvdCA9IHN0ci5pbmRleE9mKCcuJyk7XG4gICAgICAgIGlmIChkb3QgIT09IC0xICYmIHN0cltzdHIubGVuZ3RoIC0gMV0gPT09ICcwJylcbiAgICAgICAgICAgIG5vZGUubWluRnJhY3Rpb25EaWdpdHMgPSBzdHIubGVuZ3RoIC0gZG90IC0gMTtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfSxcbiAgICBzdHJpbmdpZnk6IHN0cmluZ2lmeU51bWJlclxufTtcblxuZXhwb3J0IHsgZmxvYXQsIGZsb2F0RXhwLCBmbG9hdE5hTiB9O1xuIiwgImltcG9ydCB7IHN0cmluZ2lmeU51bWJlciB9IGZyb20gJy4uLy4uL3N0cmluZ2lmeS9zdHJpbmdpZnlOdW1iZXIuanMnO1xuXG5jb25zdCBpbnRJZGVudGlmeSA9ICh2YWx1ZSkgPT4gdHlwZW9mIHZhbHVlID09PSAnYmlnaW50JyB8fCBOdW1iZXIuaXNJbnRlZ2VyKHZhbHVlKTtcbmNvbnN0IGludFJlc29sdmUgPSAoc3RyLCBvZmZzZXQsIHJhZGl4LCB7IGludEFzQmlnSW50IH0pID0+IChpbnRBc0JpZ0ludCA/IEJpZ0ludChzdHIpIDogcGFyc2VJbnQoc3RyLnN1YnN0cmluZyhvZmZzZXQpLCByYWRpeCkpO1xuZnVuY3Rpb24gaW50U3RyaW5naWZ5KG5vZGUsIHJhZGl4LCBwcmVmaXgpIHtcbiAgICBjb25zdCB7IHZhbHVlIH0gPSBub2RlO1xuICAgIGlmIChpbnRJZGVudGlmeSh2YWx1ZSkgJiYgdmFsdWUgPj0gMClcbiAgICAgICAgcmV0dXJuIHByZWZpeCArIHZhbHVlLnRvU3RyaW5nKHJhZGl4KTtcbiAgICByZXR1cm4gc3RyaW5naWZ5TnVtYmVyKG5vZGUpO1xufVxuY29uc3QgaW50T2N0ID0ge1xuICAgIGlkZW50aWZ5OiB2YWx1ZSA9PiBpbnRJZGVudGlmeSh2YWx1ZSkgJiYgdmFsdWUgPj0gMCxcbiAgICBkZWZhdWx0OiB0cnVlLFxuICAgIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOmludCcsXG4gICAgZm9ybWF0OiAnT0NUJyxcbiAgICB0ZXN0OiAvXjBvWzAtN10rJC8sXG4gICAgcmVzb2x2ZTogKHN0ciwgX29uRXJyb3IsIG9wdCkgPT4gaW50UmVzb2x2ZShzdHIsIDIsIDgsIG9wdCksXG4gICAgc3RyaW5naWZ5OiBub2RlID0+IGludFN0cmluZ2lmeShub2RlLCA4LCAnMG8nKVxufTtcbmNvbnN0IGludCA9IHtcbiAgICBpZGVudGlmeTogaW50SWRlbnRpZnksXG4gICAgZGVmYXVsdDogdHJ1ZSxcbiAgICB0YWc6ICd0YWc6eWFtbC5vcmcsMjAwMjppbnQnLFxuICAgIHRlc3Q6IC9eWy0rXT9bMC05XSskLyxcbiAgICByZXNvbHZlOiAoc3RyLCBfb25FcnJvciwgb3B0KSA9PiBpbnRSZXNvbHZlKHN0ciwgMCwgMTAsIG9wdCksXG4gICAgc3RyaW5naWZ5OiBzdHJpbmdpZnlOdW1iZXJcbn07XG5jb25zdCBpbnRIZXggPSB7XG4gICAgaWRlbnRpZnk6IHZhbHVlID0+IGludElkZW50aWZ5KHZhbHVlKSAmJiB2YWx1ZSA+PSAwLFxuICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6aW50JyxcbiAgICBmb3JtYXQ6ICdIRVgnLFxuICAgIHRlc3Q6IC9eMHhbMC05YS1mQS1GXSskLyxcbiAgICByZXNvbHZlOiAoc3RyLCBfb25FcnJvciwgb3B0KSA9PiBpbnRSZXNvbHZlKHN0ciwgMiwgMTYsIG9wdCksXG4gICAgc3RyaW5naWZ5OiBub2RlID0+IGludFN0cmluZ2lmeShub2RlLCAxNiwgJzB4Jylcbn07XG5cbmV4cG9ydCB7IGludCwgaW50SGV4LCBpbnRPY3QgfTtcbiIsICJpbXBvcnQgeyBtYXAgfSBmcm9tICcuLi9jb21tb24vbWFwLmpzJztcbmltcG9ydCB7IG51bGxUYWcgfSBmcm9tICcuLi9jb21tb24vbnVsbC5qcyc7XG5pbXBvcnQgeyBzZXEgfSBmcm9tICcuLi9jb21tb24vc2VxLmpzJztcbmltcG9ydCB7IHN0cmluZyB9IGZyb20gJy4uL2NvbW1vbi9zdHJpbmcuanMnO1xuaW1wb3J0IHsgYm9vbFRhZyB9IGZyb20gJy4vYm9vbC5qcyc7XG5pbXBvcnQgeyBmbG9hdE5hTiwgZmxvYXRFeHAsIGZsb2F0IH0gZnJvbSAnLi9mbG9hdC5qcyc7XG5pbXBvcnQgeyBpbnRPY3QsIGludCwgaW50SGV4IH0gZnJvbSAnLi9pbnQuanMnO1xuXG5jb25zdCBzY2hlbWEgPSBbXG4gICAgbWFwLFxuICAgIHNlcSxcbiAgICBzdHJpbmcsXG4gICAgbnVsbFRhZyxcbiAgICBib29sVGFnLFxuICAgIGludE9jdCxcbiAgICBpbnQsXG4gICAgaW50SGV4LFxuICAgIGZsb2F0TmFOLFxuICAgIGZsb2F0RXhwLFxuICAgIGZsb2F0XG5dO1xuXG5leHBvcnQgeyBzY2hlbWEgfTtcbiIsICJpbXBvcnQgeyBTY2FsYXIgfSBmcm9tICcuLi8uLi9ub2Rlcy9TY2FsYXIuanMnO1xuaW1wb3J0IHsgbWFwIH0gZnJvbSAnLi4vY29tbW9uL21hcC5qcyc7XG5pbXBvcnQgeyBzZXEgfSBmcm9tICcuLi9jb21tb24vc2VxLmpzJztcblxuZnVuY3Rpb24gaW50SWRlbnRpZnkodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnYmlnaW50JyB8fCBOdW1iZXIuaXNJbnRlZ2VyKHZhbHVlKTtcbn1cbmNvbnN0IHN0cmluZ2lmeUpTT04gPSAoeyB2YWx1ZSB9KSA9PiBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG5jb25zdCBqc29uU2NhbGFycyA9IFtcbiAgICB7XG4gICAgICAgIGlkZW50aWZ5OiB2YWx1ZSA9PiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnLFxuICAgICAgICBkZWZhdWx0OiB0cnVlLFxuICAgICAgICB0YWc6ICd0YWc6eWFtbC5vcmcsMjAwMjpzdHInLFxuICAgICAgICByZXNvbHZlOiBzdHIgPT4gc3RyLFxuICAgICAgICBzdHJpbmdpZnk6IHN0cmluZ2lmeUpTT05cbiAgICB9LFxuICAgIHtcbiAgICAgICAgaWRlbnRpZnk6IHZhbHVlID0+IHZhbHVlID09IG51bGwsXG4gICAgICAgIGNyZWF0ZU5vZGU6ICgpID0+IG5ldyBTY2FsYXIobnVsbCksXG4gICAgICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgICAgIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOm51bGwnLFxuICAgICAgICB0ZXN0OiAvXm51bGwkLyxcbiAgICAgICAgcmVzb2x2ZTogKCkgPT4gbnVsbCxcbiAgICAgICAgc3RyaW5naWZ5OiBzdHJpbmdpZnlKU09OXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGlkZW50aWZ5OiB2YWx1ZSA9PiB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJyxcbiAgICAgICAgZGVmYXVsdDogdHJ1ZSxcbiAgICAgICAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6Ym9vbCcsXG4gICAgICAgIHRlc3Q6IC9edHJ1ZXxmYWxzZSQvLFxuICAgICAgICByZXNvbHZlOiBzdHIgPT4gc3RyID09PSAndHJ1ZScsXG4gICAgICAgIHN0cmluZ2lmeTogc3RyaW5naWZ5SlNPTlxuICAgIH0sXG4gICAge1xuICAgICAgICBpZGVudGlmeTogaW50SWRlbnRpZnksXG4gICAgICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgICAgIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOmludCcsXG4gICAgICAgIHRlc3Q6IC9eLT8oPzowfFsxLTldWzAtOV0qKSQvLFxuICAgICAgICByZXNvbHZlOiAoc3RyLCBfb25FcnJvciwgeyBpbnRBc0JpZ0ludCB9KSA9PiBpbnRBc0JpZ0ludCA/IEJpZ0ludChzdHIpIDogcGFyc2VJbnQoc3RyLCAxMCksXG4gICAgICAgIHN0cmluZ2lmeTogKHsgdmFsdWUgfSkgPT4gaW50SWRlbnRpZnkodmFsdWUpID8gdmFsdWUudG9TdHJpbmcoKSA6IEpTT04uc3RyaW5naWZ5KHZhbHVlKVxuICAgIH0sXG4gICAge1xuICAgICAgICBpZGVudGlmeTogdmFsdWUgPT4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyxcbiAgICAgICAgZGVmYXVsdDogdHJ1ZSxcbiAgICAgICAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6ZmxvYXQnLFxuICAgICAgICB0ZXN0OiAvXi0/KD86MHxbMS05XVswLTldKikoPzpcXC5bMC05XSopPyg/OltlRV1bLStdP1swLTldKyk/JC8sXG4gICAgICAgIHJlc29sdmU6IHN0ciA9PiBwYXJzZUZsb2F0KHN0ciksXG4gICAgICAgIHN0cmluZ2lmeTogc3RyaW5naWZ5SlNPTlxuICAgIH1cbl07XG5jb25zdCBqc29uRXJyb3IgPSB7XG4gICAgZGVmYXVsdDogdHJ1ZSxcbiAgICB0YWc6ICcnLFxuICAgIHRlc3Q6IC9eLyxcbiAgICByZXNvbHZlKHN0ciwgb25FcnJvcikge1xuICAgICAgICBvbkVycm9yKGBVbnJlc29sdmVkIHBsYWluIHNjYWxhciAke0pTT04uc3RyaW5naWZ5KHN0cil9YCk7XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgfVxufTtcbmNvbnN0IHNjaGVtYSA9IFttYXAsIHNlcV0uY29uY2F0KGpzb25TY2FsYXJzLCBqc29uRXJyb3IpO1xuXG5leHBvcnQgeyBzY2hlbWEgfTtcbiIsICJpbXBvcnQgeyBTY2FsYXIgfSBmcm9tICcuLi8uLi9ub2Rlcy9TY2FsYXIuanMnO1xuaW1wb3J0IHsgc3RyaW5naWZ5U3RyaW5nIH0gZnJvbSAnLi4vLi4vc3RyaW5naWZ5L3N0cmluZ2lmeVN0cmluZy5qcyc7XG5cbmNvbnN0IGJpbmFyeSA9IHtcbiAgICBpZGVudGlmeTogdmFsdWUgPT4gdmFsdWUgaW5zdGFuY2VvZiBVaW50OEFycmF5LFxuICAgIGRlZmF1bHQ6IGZhbHNlLFxuICAgIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOmJpbmFyeScsXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIEJ1ZmZlciBpbiBub2RlIGFuZCBhbiBVaW50OEFycmF5IGluIGJyb3dzZXJzXG4gICAgICpcbiAgICAgKiBUbyB1c2UgdGhlIHJlc3VsdGluZyBidWZmZXIgYXMgYW4gaW1hZ2UsIHlvdSdsbCB3YW50IHRvIGRvIHNvbWV0aGluZyBsaWtlOlxuICAgICAqXG4gICAgICogICBjb25zdCBibG9iID0gbmV3IEJsb2IoW2J1ZmZlcl0sIHsgdHlwZTogJ2ltYWdlL2pwZWcnIH0pXG4gICAgICogICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjcGhvdG8nKS5zcmMgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpXG4gICAgICovXG4gICAgcmVzb2x2ZShzcmMsIG9uRXJyb3IpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBCdWZmZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybiBCdWZmZXIuZnJvbShzcmMsICdiYXNlNjQnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgYXRvYiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgLy8gT24gSUUgMTEsIGF0b2IoKSBjYW4ndCBoYW5kbGUgbmV3bGluZXNcbiAgICAgICAgICAgIGNvbnN0IHN0ciA9IGF0b2Ioc3JjLnJlcGxhY2UoL1tcXG5cXHJdL2csICcnKSk7XG4gICAgICAgICAgICBjb25zdCBidWZmZXIgPSBuZXcgVWludDhBcnJheShzdHIubGVuZ3RoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgIGJ1ZmZlcltpXSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICAgICAgcmV0dXJuIGJ1ZmZlcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9uRXJyb3IoJ1RoaXMgZW52aXJvbm1lbnQgZG9lcyBub3Qgc3VwcG9ydCByZWFkaW5nIGJpbmFyeSB0YWdzOyBlaXRoZXIgQnVmZmVyIG9yIGF0b2IgaXMgcmVxdWlyZWQnKTtcbiAgICAgICAgICAgIHJldHVybiBzcmM7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHN0cmluZ2lmeSh7IGNvbW1lbnQsIHR5cGUsIHZhbHVlIH0sIGN0eCwgb25Db21tZW50LCBvbkNob21wS2VlcCkge1xuICAgICAgICBjb25zdCBidWYgPSB2YWx1ZTsgLy8gY2hlY2tlZCBlYXJsaWVyIGJ5IGJpbmFyeS5pZGVudGlmeSgpXG4gICAgICAgIGxldCBzdHI7XG4gICAgICAgIGlmICh0eXBlb2YgQnVmZmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBzdHIgPVxuICAgICAgICAgICAgICAgIGJ1ZiBpbnN0YW5jZW9mIEJ1ZmZlclxuICAgICAgICAgICAgICAgICAgICA/IGJ1Zi50b1N0cmluZygnYmFzZTY0JylcbiAgICAgICAgICAgICAgICAgICAgOiBCdWZmZXIuZnJvbShidWYuYnVmZmVyKS50b1N0cmluZygnYmFzZTY0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGJ0b2EgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGxldCBzID0gJyc7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ1Zi5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICBzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKTtcbiAgICAgICAgICAgIHN0ciA9IGJ0b2Eocyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgZW52aXJvbm1lbnQgZG9lcyBub3Qgc3VwcG9ydCB3cml0aW5nIGJpbmFyeSB0YWdzOyBlaXRoZXIgQnVmZmVyIG9yIGJ0b2EgaXMgcmVxdWlyZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXR5cGUpXG4gICAgICAgICAgICB0eXBlID0gU2NhbGFyLkJMT0NLX0xJVEVSQUw7XG4gICAgICAgIGlmICh0eXBlICE9PSBTY2FsYXIuUVVPVEVfRE9VQkxFKSB7XG4gICAgICAgICAgICBjb25zdCBsaW5lV2lkdGggPSBNYXRoLm1heChjdHgub3B0aW9ucy5saW5lV2lkdGggLSBjdHguaW5kZW50Lmxlbmd0aCwgY3R4Lm9wdGlvbnMubWluQ29udGVudFdpZHRoKTtcbiAgICAgICAgICAgIGNvbnN0IG4gPSBNYXRoLmNlaWwoc3RyLmxlbmd0aCAvIGxpbmVXaWR0aCk7XG4gICAgICAgICAgICBjb25zdCBsaW5lcyA9IG5ldyBBcnJheShuKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBvID0gMDsgaSA8IG47ICsraSwgbyArPSBsaW5lV2lkdGgpIHtcbiAgICAgICAgICAgICAgICBsaW5lc1tpXSA9IHN0ci5zdWJzdHIobywgbGluZVdpZHRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0ciA9IGxpbmVzLmpvaW4odHlwZSA9PT0gU2NhbGFyLkJMT0NLX0xJVEVSQUwgPyAnXFxuJyA6ICcgJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0cmluZ2lmeVN0cmluZyh7IGNvbW1lbnQsIHR5cGUsIHZhbHVlOiBzdHIgfSwgY3R4LCBvbkNvbW1lbnQsIG9uQ2hvbXBLZWVwKTtcbiAgICB9XG59O1xuXG5leHBvcnQgeyBiaW5hcnkgfTtcbiIsICJpbXBvcnQgeyBpc1NlcSwgaXNQYWlyLCBpc01hcCB9IGZyb20gJy4uLy4uL25vZGVzL05vZGUuanMnO1xuaW1wb3J0IHsgUGFpciwgY3JlYXRlUGFpciB9IGZyb20gJy4uLy4uL25vZGVzL1BhaXIuanMnO1xuaW1wb3J0IHsgU2NhbGFyIH0gZnJvbSAnLi4vLi4vbm9kZXMvU2NhbGFyLmpzJztcbmltcG9ydCB7IFlBTUxTZXEgfSBmcm9tICcuLi8uLi9ub2Rlcy9ZQU1MU2VxLmpzJztcblxuZnVuY3Rpb24gcmVzb2x2ZVBhaXJzKHNlcSwgb25FcnJvcikge1xuICAgIGlmIChpc1NlcShzZXEpKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2VxLml0ZW1zLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBsZXQgaXRlbSA9IHNlcS5pdGVtc1tpXTtcbiAgICAgICAgICAgIGlmIChpc1BhaXIoaXRlbSkpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBlbHNlIGlmIChpc01hcChpdGVtKSkge1xuICAgICAgICAgICAgICAgIGlmIChpdGVtLml0ZW1zLmxlbmd0aCA+IDEpXG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3IoJ0VhY2ggcGFpciBtdXN0IGhhdmUgaXRzIG93biBzZXF1ZW5jZSBpbmRpY2F0b3InKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwYWlyID0gaXRlbS5pdGVtc1swXSB8fCBuZXcgUGFpcihuZXcgU2NhbGFyKG51bGwpKTtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbS5jb21tZW50QmVmb3JlKVxuICAgICAgICAgICAgICAgICAgICBwYWlyLmtleS5jb21tZW50QmVmb3JlID0gcGFpci5rZXkuY29tbWVudEJlZm9yZVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBgJHtpdGVtLmNvbW1lbnRCZWZvcmV9XFxuJHtwYWlyLmtleS5jb21tZW50QmVmb3JlfWBcbiAgICAgICAgICAgICAgICAgICAgICAgIDogaXRlbS5jb21tZW50QmVmb3JlO1xuICAgICAgICAgICAgICAgIGlmIChpdGVtLmNvbW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY24gPSBwYWlyLnZhbHVlIHx8IHBhaXIua2V5O1xuICAgICAgICAgICAgICAgICAgICBjbi5jb21tZW50ID0gY24uY29tbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgPyBgJHtpdGVtLmNvbW1lbnR9XFxuJHtjbi5jb21tZW50fWBcbiAgICAgICAgICAgICAgICAgICAgICAgIDogaXRlbS5jb21tZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpdGVtID0gcGFpcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlcS5pdGVtc1tpXSA9IGlzUGFpcihpdGVtKSA/IGl0ZW0gOiBuZXcgUGFpcihpdGVtKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlXG4gICAgICAgIG9uRXJyb3IoJ0V4cGVjdGVkIGEgc2VxdWVuY2UgZm9yIHRoaXMgdGFnJyk7XG4gICAgcmV0dXJuIHNlcTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVBhaXJzKHNjaGVtYSwgaXRlcmFibGUsIGN0eCkge1xuICAgIGNvbnN0IHsgcmVwbGFjZXIgfSA9IGN0eDtcbiAgICBjb25zdCBwYWlycyA9IG5ldyBZQU1MU2VxKHNjaGVtYSk7XG4gICAgcGFpcnMudGFnID0gJ3RhZzp5YW1sLm9yZywyMDAyOnBhaXJzJztcbiAgICBsZXQgaSA9IDA7XG4gICAgaWYgKGl0ZXJhYmxlICYmIFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoaXRlcmFibGUpKVxuICAgICAgICBmb3IgKGxldCBpdCBvZiBpdGVyYWJsZSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiByZXBsYWNlciA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgICAgICBpdCA9IHJlcGxhY2VyLmNhbGwoaXRlcmFibGUsIFN0cmluZyhpKyspLCBpdCk7XG4gICAgICAgICAgICBsZXQga2V5LCB2YWx1ZTtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGl0KSkge1xuICAgICAgICAgICAgICAgIGlmIChpdC5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAga2V5ID0gaXRbMF07XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gaXRbMV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgRXhwZWN0ZWQgW2tleSwgdmFsdWVdIHR1cGxlOiAke2l0fWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXQgJiYgaXQgaW5zdGFuY2VvZiBPYmplY3QpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoaXQpO1xuICAgICAgICAgICAgICAgIGlmIChrZXlzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICBrZXkgPSBrZXlzWzBdO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGl0W2tleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgRXhwZWN0ZWQgeyBrZXk6IHZhbHVlIH0gdHVwbGU6ICR7aXR9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBrZXkgPSBpdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhaXJzLml0ZW1zLnB1c2goY3JlYXRlUGFpcihrZXksIHZhbHVlLCBjdHgpKTtcbiAgICAgICAgfVxuICAgIHJldHVybiBwYWlycztcbn1cbmNvbnN0IHBhaXJzID0ge1xuICAgIGNvbGxlY3Rpb246ICdzZXEnLFxuICAgIGRlZmF1bHQ6IGZhbHNlLFxuICAgIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOnBhaXJzJyxcbiAgICByZXNvbHZlOiByZXNvbHZlUGFpcnMsXG4gICAgY3JlYXRlTm9kZTogY3JlYXRlUGFpcnNcbn07XG5cbmV4cG9ydCB7IGNyZWF0ZVBhaXJzLCBwYWlycywgcmVzb2x2ZVBhaXJzIH07XG4iLCAiaW1wb3J0IHsgWUFNTFNlcSB9IGZyb20gJy4uLy4uL25vZGVzL1lBTUxTZXEuanMnO1xuaW1wb3J0IHsgdG9KUyB9IGZyb20gJy4uLy4uL25vZGVzL3RvSlMuanMnO1xuaW1wb3J0IHsgaXNTY2FsYXIsIGlzUGFpciB9IGZyb20gJy4uLy4uL25vZGVzL05vZGUuanMnO1xuaW1wb3J0IHsgWUFNTE1hcCB9IGZyb20gJy4uLy4uL25vZGVzL1lBTUxNYXAuanMnO1xuaW1wb3J0IHsgcmVzb2x2ZVBhaXJzLCBjcmVhdGVQYWlycyB9IGZyb20gJy4vcGFpcnMuanMnO1xuXG5jbGFzcyBZQU1MT01hcCBleHRlbmRzIFlBTUxTZXEge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmFkZCA9IFlBTUxNYXAucHJvdG90eXBlLmFkZC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmRlbGV0ZSA9IFlBTUxNYXAucHJvdG90eXBlLmRlbGV0ZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmdldCA9IFlBTUxNYXAucHJvdG90eXBlLmdldC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmhhcyA9IFlBTUxNYXAucHJvdG90eXBlLmhhcy5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnNldCA9IFlBTUxNYXAucHJvdG90eXBlLnNldC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnRhZyA9IFlBTUxPTWFwLnRhZztcbiAgICB9XG4gICAgLyoqXG4gICAgICogSWYgYGN0eGAgaXMgZ2l2ZW4sIHRoZSByZXR1cm4gdHlwZSBpcyBhY3R1YWxseSBgTWFwPHVua25vd24sIHVua25vd24+YCxcbiAgICAgKiBidXQgVHlwZVNjcmlwdCB3b24ndCBhbGxvdyB3aWRlbmluZyB0aGUgc2lnbmF0dXJlIG9mIGEgY2hpbGQgbWV0aG9kLlxuICAgICAqL1xuICAgIHRvSlNPTihfLCBjdHgpIHtcbiAgICAgICAgaWYgKCFjdHgpXG4gICAgICAgICAgICByZXR1cm4gc3VwZXIudG9KU09OKF8pO1xuICAgICAgICBjb25zdCBtYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIGlmIChjdHggJiYgY3R4Lm9uQ3JlYXRlKVxuICAgICAgICAgICAgY3R4Lm9uQ3JlYXRlKG1hcCk7XG4gICAgICAgIGZvciAoY29uc3QgcGFpciBvZiB0aGlzLml0ZW1zKSB7XG4gICAgICAgICAgICBsZXQga2V5LCB2YWx1ZTtcbiAgICAgICAgICAgIGlmIChpc1BhaXIocGFpcikpIHtcbiAgICAgICAgICAgICAgICBrZXkgPSB0b0pTKHBhaXIua2V5LCAnJywgY3R4KTtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHRvSlMocGFpci52YWx1ZSwga2V5LCBjdHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAga2V5ID0gdG9KUyhwYWlyLCAnJywgY3R4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYXAuaGFzKGtleSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdPcmRlcmVkIG1hcHMgbXVzdCBub3QgaW5jbHVkZSBkdXBsaWNhdGUga2V5cycpO1xuICAgICAgICAgICAgbWFwLnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWFwO1xuICAgIH1cbn1cbllBTUxPTWFwLnRhZyA9ICd0YWc6eWFtbC5vcmcsMjAwMjpvbWFwJztcbmNvbnN0IG9tYXAgPSB7XG4gICAgY29sbGVjdGlvbjogJ3NlcScsXG4gICAgaWRlbnRpZnk6IHZhbHVlID0+IHZhbHVlIGluc3RhbmNlb2YgTWFwLFxuICAgIG5vZGVDbGFzczogWUFNTE9NYXAsXG4gICAgZGVmYXVsdDogZmFsc2UsXG4gICAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6b21hcCcsXG4gICAgcmVzb2x2ZShzZXEsIG9uRXJyb3IpIHtcbiAgICAgICAgY29uc3QgcGFpcnMgPSByZXNvbHZlUGFpcnMoc2VxLCBvbkVycm9yKTtcbiAgICAgICAgY29uc3Qgc2VlbktleXMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCB7IGtleSB9IG9mIHBhaXJzLml0ZW1zKSB7XG4gICAgICAgICAgICBpZiAoaXNTY2FsYXIoa2V5KSkge1xuICAgICAgICAgICAgICAgIGlmIChzZWVuS2V5cy5pbmNsdWRlcyhrZXkudmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3IoYE9yZGVyZWQgbWFwcyBtdXN0IG5vdCBpbmNsdWRlIGR1cGxpY2F0ZSBrZXlzOiAke2tleS52YWx1ZX1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNlZW5LZXlzLnB1c2goa2V5LnZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24obmV3IFlBTUxPTWFwKCksIHBhaXJzKTtcbiAgICB9LFxuICAgIGNyZWF0ZU5vZGUoc2NoZW1hLCBpdGVyYWJsZSwgY3R4KSB7XG4gICAgICAgIGNvbnN0IHBhaXJzID0gY3JlYXRlUGFpcnMoc2NoZW1hLCBpdGVyYWJsZSwgY3R4KTtcbiAgICAgICAgY29uc3Qgb21hcCA9IG5ldyBZQU1MT01hcCgpO1xuICAgICAgICBvbWFwLml0ZW1zID0gcGFpcnMuaXRlbXM7XG4gICAgICAgIHJldHVybiBvbWFwO1xuICAgIH1cbn07XG5cbmV4cG9ydCB7IFlBTUxPTWFwLCBvbWFwIH07XG4iLCAiaW1wb3J0IHsgU2NhbGFyIH0gZnJvbSAnLi4vLi4vbm9kZXMvU2NhbGFyLmpzJztcblxuZnVuY3Rpb24gYm9vbFN0cmluZ2lmeSh7IHZhbHVlLCBzb3VyY2UgfSwgY3R4KSB7XG4gICAgY29uc3QgYm9vbE9iaiA9IHZhbHVlID8gdHJ1ZVRhZyA6IGZhbHNlVGFnO1xuICAgIGlmIChzb3VyY2UgJiYgYm9vbE9iai50ZXN0LnRlc3Qoc291cmNlKSlcbiAgICAgICAgcmV0dXJuIHNvdXJjZTtcbiAgICByZXR1cm4gdmFsdWUgPyBjdHgub3B0aW9ucy50cnVlU3RyIDogY3R4Lm9wdGlvbnMuZmFsc2VTdHI7XG59XG5jb25zdCB0cnVlVGFnID0ge1xuICAgIGlkZW50aWZ5OiB2YWx1ZSA9PiB2YWx1ZSA9PT0gdHJ1ZSxcbiAgICBkZWZhdWx0OiB0cnVlLFxuICAgIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOmJvb2wnLFxuICAgIHRlc3Q6IC9eKD86WXx5fFtZeV1lc3xZRVN8W1R0XXJ1ZXxUUlVFfFtPb11ufE9OKSQvLFxuICAgIHJlc29sdmU6ICgpID0+IG5ldyBTY2FsYXIodHJ1ZSksXG4gICAgc3RyaW5naWZ5OiBib29sU3RyaW5naWZ5XG59O1xuY29uc3QgZmFsc2VUYWcgPSB7XG4gICAgaWRlbnRpZnk6IHZhbHVlID0+IHZhbHVlID09PSBmYWxzZSxcbiAgICBkZWZhdWx0OiB0cnVlLFxuICAgIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOmJvb2wnLFxuICAgIHRlc3Q6IC9eKD86TnxufFtObl1vfE5PfFtGZl1hbHNlfEZBTFNFfFtPb11mZnxPRkYpJC9pLFxuICAgIHJlc29sdmU6ICgpID0+IG5ldyBTY2FsYXIoZmFsc2UpLFxuICAgIHN0cmluZ2lmeTogYm9vbFN0cmluZ2lmeVxufTtcblxuZXhwb3J0IHsgZmFsc2VUYWcsIHRydWVUYWcgfTtcbiIsICJpbXBvcnQgeyBTY2FsYXIgfSBmcm9tICcuLi8uLi9ub2Rlcy9TY2FsYXIuanMnO1xuaW1wb3J0IHsgc3RyaW5naWZ5TnVtYmVyIH0gZnJvbSAnLi4vLi4vc3RyaW5naWZ5L3N0cmluZ2lmeU51bWJlci5qcyc7XG5cbmNvbnN0IGZsb2F0TmFOID0ge1xuICAgIGlkZW50aWZ5OiB2YWx1ZSA9PiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInLFxuICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6ZmxvYXQnLFxuICAgIHRlc3Q6IC9eWy0rXT9cXC4oPzppbmZ8SW5mfElORnxuYW58TmFOfE5BTikkLyxcbiAgICByZXNvbHZlOiAoc3RyKSA9PiBzdHIuc2xpY2UoLTMpLnRvTG93ZXJDYXNlKCkgPT09ICduYW4nXG4gICAgICAgID8gTmFOXG4gICAgICAgIDogc3RyWzBdID09PSAnLSdcbiAgICAgICAgICAgID8gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZXG4gICAgICAgICAgICA6IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSxcbiAgICBzdHJpbmdpZnk6IHN0cmluZ2lmeU51bWJlclxufTtcbmNvbnN0IGZsb2F0RXhwID0ge1xuICAgIGlkZW50aWZ5OiB2YWx1ZSA9PiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInLFxuICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6ZmxvYXQnLFxuICAgIGZvcm1hdDogJ0VYUCcsXG4gICAgdGVzdDogL15bLStdPyg/OlswLTldWzAtOV9dKik/KD86XFwuWzAtOV9dKik/W2VFXVstK10/WzAtOV0rJC8sXG4gICAgcmVzb2x2ZTogKHN0cikgPT4gcGFyc2VGbG9hdChzdHIucmVwbGFjZSgvXy9nLCAnJykpLFxuICAgIHN0cmluZ2lmeShub2RlKSB7XG4gICAgICAgIGNvbnN0IG51bSA9IE51bWJlcihub2RlLnZhbHVlKTtcbiAgICAgICAgcmV0dXJuIGlzRmluaXRlKG51bSkgPyBudW0udG9FeHBvbmVudGlhbCgpIDogc3RyaW5naWZ5TnVtYmVyKG5vZGUpO1xuICAgIH1cbn07XG5jb25zdCBmbG9hdCA9IHtcbiAgICBpZGVudGlmeTogdmFsdWUgPT4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyxcbiAgICBkZWZhdWx0OiB0cnVlLFxuICAgIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOmZsb2F0JyxcbiAgICB0ZXN0OiAvXlstK10/KD86WzAtOV1bMC05X10qKT9cXC5bMC05X10qJC8sXG4gICAgcmVzb2x2ZShzdHIpIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IG5ldyBTY2FsYXIocGFyc2VGbG9hdChzdHIucmVwbGFjZSgvXy9nLCAnJykpKTtcbiAgICAgICAgY29uc3QgZG90ID0gc3RyLmluZGV4T2YoJy4nKTtcbiAgICAgICAgaWYgKGRvdCAhPT0gLTEpIHtcbiAgICAgICAgICAgIGNvbnN0IGYgPSBzdHIuc3Vic3RyaW5nKGRvdCArIDEpLnJlcGxhY2UoL18vZywgJycpO1xuICAgICAgICAgICAgaWYgKGZbZi5sZW5ndGggLSAxXSA9PT0gJzAnKVxuICAgICAgICAgICAgICAgIG5vZGUubWluRnJhY3Rpb25EaWdpdHMgPSBmLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9LFxuICAgIHN0cmluZ2lmeTogc3RyaW5naWZ5TnVtYmVyXG59O1xuXG5leHBvcnQgeyBmbG9hdCwgZmxvYXRFeHAsIGZsb2F0TmFOIH07XG4iLCAiaW1wb3J0IHsgc3RyaW5naWZ5TnVtYmVyIH0gZnJvbSAnLi4vLi4vc3RyaW5naWZ5L3N0cmluZ2lmeU51bWJlci5qcyc7XG5cbmNvbnN0IGludElkZW50aWZ5ID0gKHZhbHVlKSA9PiB0eXBlb2YgdmFsdWUgPT09ICdiaWdpbnQnIHx8IE51bWJlci5pc0ludGVnZXIodmFsdWUpO1xuZnVuY3Rpb24gaW50UmVzb2x2ZShzdHIsIG9mZnNldCwgcmFkaXgsIHsgaW50QXNCaWdJbnQgfSkge1xuICAgIGNvbnN0IHNpZ24gPSBzdHJbMF07XG4gICAgaWYgKHNpZ24gPT09ICctJyB8fCBzaWduID09PSAnKycpXG4gICAgICAgIG9mZnNldCArPSAxO1xuICAgIHN0ciA9IHN0ci5zdWJzdHJpbmcob2Zmc2V0KS5yZXBsYWNlKC9fL2csICcnKTtcbiAgICBpZiAoaW50QXNCaWdJbnQpIHtcbiAgICAgICAgc3dpdGNoIChyYWRpeCkge1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIHN0ciA9IGAwYiR7c3RyfWA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgc3RyID0gYDBvJHtzdHJ9YDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMTY6XG4gICAgICAgICAgICAgICAgc3RyID0gYDB4JHtzdHJ9YDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuID0gQmlnSW50KHN0cik7XG4gICAgICAgIHJldHVybiBzaWduID09PSAnLScgPyBCaWdJbnQoLTEpICogbiA6IG47XG4gICAgfVxuICAgIGNvbnN0IG4gPSBwYXJzZUludChzdHIsIHJhZGl4KTtcbiAgICByZXR1cm4gc2lnbiA9PT0gJy0nID8gLTEgKiBuIDogbjtcbn1cbmZ1bmN0aW9uIGludFN0cmluZ2lmeShub2RlLCByYWRpeCwgcHJlZml4KSB7XG4gICAgY29uc3QgeyB2YWx1ZSB9ID0gbm9kZTtcbiAgICBpZiAoaW50SWRlbnRpZnkodmFsdWUpKSB7XG4gICAgICAgIGNvbnN0IHN0ciA9IHZhbHVlLnRvU3RyaW5nKHJhZGl4KTtcbiAgICAgICAgcmV0dXJuIHZhbHVlIDwgMCA/ICctJyArIHByZWZpeCArIHN0ci5zdWJzdHIoMSkgOiBwcmVmaXggKyBzdHI7XG4gICAgfVxuICAgIHJldHVybiBzdHJpbmdpZnlOdW1iZXIobm9kZSk7XG59XG5jb25zdCBpbnRCaW4gPSB7XG4gICAgaWRlbnRpZnk6IGludElkZW50aWZ5LFxuICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6aW50JyxcbiAgICBmb3JtYXQ6ICdCSU4nLFxuICAgIHRlc3Q6IC9eWy0rXT8wYlswLTFfXSskLyxcbiAgICByZXNvbHZlOiAoc3RyLCBfb25FcnJvciwgb3B0KSA9PiBpbnRSZXNvbHZlKHN0ciwgMiwgMiwgb3B0KSxcbiAgICBzdHJpbmdpZnk6IG5vZGUgPT4gaW50U3RyaW5naWZ5KG5vZGUsIDIsICcwYicpXG59O1xuY29uc3QgaW50T2N0ID0ge1xuICAgIGlkZW50aWZ5OiBpbnRJZGVudGlmeSxcbiAgICBkZWZhdWx0OiB0cnVlLFxuICAgIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOmludCcsXG4gICAgZm9ybWF0OiAnT0NUJyxcbiAgICB0ZXN0OiAvXlstK10/MFswLTdfXSskLyxcbiAgICByZXNvbHZlOiAoc3RyLCBfb25FcnJvciwgb3B0KSA9PiBpbnRSZXNvbHZlKHN0ciwgMSwgOCwgb3B0KSxcbiAgICBzdHJpbmdpZnk6IG5vZGUgPT4gaW50U3RyaW5naWZ5KG5vZGUsIDgsICcwJylcbn07XG5jb25zdCBpbnQgPSB7XG4gICAgaWRlbnRpZnk6IGludElkZW50aWZ5LFxuICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6aW50JyxcbiAgICB0ZXN0OiAvXlstK10/WzAtOV1bMC05X10qJC8sXG4gICAgcmVzb2x2ZTogKHN0ciwgX29uRXJyb3IsIG9wdCkgPT4gaW50UmVzb2x2ZShzdHIsIDAsIDEwLCBvcHQpLFxuICAgIHN0cmluZ2lmeTogc3RyaW5naWZ5TnVtYmVyXG59O1xuY29uc3QgaW50SGV4ID0ge1xuICAgIGlkZW50aWZ5OiBpbnRJZGVudGlmeSxcbiAgICBkZWZhdWx0OiB0cnVlLFxuICAgIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOmludCcsXG4gICAgZm9ybWF0OiAnSEVYJyxcbiAgICB0ZXN0OiAvXlstK10/MHhbMC05YS1mQS1GX10rJC8sXG4gICAgcmVzb2x2ZTogKHN0ciwgX29uRXJyb3IsIG9wdCkgPT4gaW50UmVzb2x2ZShzdHIsIDIsIDE2LCBvcHQpLFxuICAgIHN0cmluZ2lmeTogbm9kZSA9PiBpbnRTdHJpbmdpZnkobm9kZSwgMTYsICcweCcpXG59O1xuXG5leHBvcnQgeyBpbnQsIGludEJpbiwgaW50SGV4LCBpbnRPY3QgfTtcbiIsICJpbXBvcnQgeyBpc01hcCwgaXNQYWlyLCBpc1NjYWxhciB9IGZyb20gJy4uLy4uL25vZGVzL05vZGUuanMnO1xuaW1wb3J0IHsgY3JlYXRlUGFpciwgUGFpciB9IGZyb20gJy4uLy4uL25vZGVzL1BhaXIuanMnO1xuaW1wb3J0IHsgWUFNTE1hcCwgZmluZFBhaXIgfSBmcm9tICcuLi8uLi9ub2Rlcy9ZQU1MTWFwLmpzJztcblxuY2xhc3MgWUFNTFNldCBleHRlbmRzIFlBTUxNYXAge1xuICAgIGNvbnN0cnVjdG9yKHNjaGVtYSkge1xuICAgICAgICBzdXBlcihzY2hlbWEpO1xuICAgICAgICB0aGlzLnRhZyA9IFlBTUxTZXQudGFnO1xuICAgIH1cbiAgICBhZGQoa2V5KSB7XG4gICAgICAgIGxldCBwYWlyO1xuICAgICAgICBpZiAoaXNQYWlyKGtleSkpXG4gICAgICAgICAgICBwYWlyID0ga2V5O1xuICAgICAgICBlbHNlIGlmICh0eXBlb2Yga2V5ID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgJ2tleScgaW4ga2V5ICYmXG4gICAgICAgICAgICAndmFsdWUnIGluIGtleSAmJlxuICAgICAgICAgICAga2V5LnZhbHVlID09PSBudWxsKVxuICAgICAgICAgICAgcGFpciA9IG5ldyBQYWlyKGtleS5rZXksIG51bGwpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBwYWlyID0gbmV3IFBhaXIoa2V5LCBudWxsKTtcbiAgICAgICAgY29uc3QgcHJldiA9IGZpbmRQYWlyKHRoaXMuaXRlbXMsIHBhaXIua2V5KTtcbiAgICAgICAgaWYgKCFwcmV2KVxuICAgICAgICAgICAgdGhpcy5pdGVtcy5wdXNoKHBhaXIpO1xuICAgIH1cbiAgICBnZXQoa2V5LCBrZWVwUGFpcikge1xuICAgICAgICBjb25zdCBwYWlyID0gZmluZFBhaXIodGhpcy5pdGVtcywga2V5KTtcbiAgICAgICAgcmV0dXJuICFrZWVwUGFpciAmJiBpc1BhaXIocGFpcilcbiAgICAgICAgICAgID8gaXNTY2FsYXIocGFpci5rZXkpXG4gICAgICAgICAgICAgICAgPyBwYWlyLmtleS52YWx1ZVxuICAgICAgICAgICAgICAgIDogcGFpci5rZXlcbiAgICAgICAgICAgIDogcGFpcjtcbiAgICB9XG4gICAgc2V0KGtleSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ2Jvb2xlYW4nKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBib29sZWFuIHZhbHVlIGZvciBzZXQoa2V5LCB2YWx1ZSkgaW4gYSBZQU1MIHNldCwgbm90ICR7dHlwZW9mIHZhbHVlfWApO1xuICAgICAgICBjb25zdCBwcmV2ID0gZmluZFBhaXIodGhpcy5pdGVtcywga2V5KTtcbiAgICAgICAgaWYgKHByZXYgJiYgIXZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLml0ZW1zLnNwbGljZSh0aGlzLml0ZW1zLmluZGV4T2YocHJldiksIDEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFwcmV2ICYmIHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLml0ZW1zLnB1c2gobmV3IFBhaXIoa2V5KSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdG9KU09OKF8sIGN0eCkge1xuICAgICAgICByZXR1cm4gc3VwZXIudG9KU09OKF8sIGN0eCwgU2V0KTtcbiAgICB9XG4gICAgdG9TdHJpbmcoY3R4LCBvbkNvbW1lbnQsIG9uQ2hvbXBLZWVwKSB7XG4gICAgICAgIGlmICghY3R4KVxuICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMpO1xuICAgICAgICBpZiAodGhpcy5oYXNBbGxOdWxsVmFsdWVzKHRydWUpKVxuICAgICAgICAgICAgcmV0dXJuIHN1cGVyLnRvU3RyaW5nKE9iamVjdC5hc3NpZ24oe30sIGN0eCwgeyBhbGxOdWxsVmFsdWVzOiB0cnVlIH0pLCBvbkNvbW1lbnQsIG9uQ2hvbXBLZWVwKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTZXQgaXRlbXMgbXVzdCBhbGwgaGF2ZSBudWxsIHZhbHVlcycpO1xuICAgIH1cbn1cbllBTUxTZXQudGFnID0gJ3RhZzp5YW1sLm9yZywyMDAyOnNldCc7XG5jb25zdCBzZXQgPSB7XG4gICAgY29sbGVjdGlvbjogJ21hcCcsXG4gICAgaWRlbnRpZnk6IHZhbHVlID0+IHZhbHVlIGluc3RhbmNlb2YgU2V0LFxuICAgIG5vZGVDbGFzczogWUFNTFNldCxcbiAgICBkZWZhdWx0OiBmYWxzZSxcbiAgICB0YWc6ICd0YWc6eWFtbC5vcmcsMjAwMjpzZXQnLFxuICAgIHJlc29sdmUobWFwLCBvbkVycm9yKSB7XG4gICAgICAgIGlmIChpc01hcChtYXApKSB7XG4gICAgICAgICAgICBpZiAobWFwLmhhc0FsbE51bGxWYWx1ZXModHJ1ZSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24obmV3IFlBTUxTZXQoKSwgbWFwKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBvbkVycm9yKCdTZXQgaXRlbXMgbXVzdCBhbGwgaGF2ZSBudWxsIHZhbHVlcycpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIG9uRXJyb3IoJ0V4cGVjdGVkIGEgbWFwcGluZyBmb3IgdGhpcyB0YWcnKTtcbiAgICAgICAgcmV0dXJuIG1hcDtcbiAgICB9LFxuICAgIGNyZWF0ZU5vZGUoc2NoZW1hLCBpdGVyYWJsZSwgY3R4KSB7XG4gICAgICAgIGNvbnN0IHsgcmVwbGFjZXIgfSA9IGN0eDtcbiAgICAgICAgY29uc3Qgc2V0ID0gbmV3IFlBTUxTZXQoc2NoZW1hKTtcbiAgICAgICAgaWYgKGl0ZXJhYmxlICYmIFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoaXRlcmFibGUpKVxuICAgICAgICAgICAgZm9yIChsZXQgdmFsdWUgb2YgaXRlcmFibGUpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHJlcGxhY2VyID09PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHJlcGxhY2VyLmNhbGwoaXRlcmFibGUsIHZhbHVlLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgc2V0Lml0ZW1zLnB1c2goY3JlYXRlUGFpcih2YWx1ZSwgbnVsbCwgY3R4KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZXQ7XG4gICAgfVxufTtcblxuZXhwb3J0IHsgWUFNTFNldCwgc2V0IH07XG4iLCAiaW1wb3J0IHsgc3RyaW5naWZ5TnVtYmVyIH0gZnJvbSAnLi4vLi4vc3RyaW5naWZ5L3N0cmluZ2lmeU51bWJlci5qcyc7XG5cbi8qKiBJbnRlcm5hbCB0eXBlcyBoYW5kbGUgYmlnaW50IGFzIG51bWJlciwgYmVjYXVzZSBUUyBjYW4ndCBmaWd1cmUgaXQgb3V0LiAqL1xuZnVuY3Rpb24gcGFyc2VTZXhhZ2VzaW1hbChzdHIsIGFzQmlnSW50KSB7XG4gICAgY29uc3Qgc2lnbiA9IHN0clswXTtcbiAgICBjb25zdCBwYXJ0cyA9IHNpZ24gPT09ICctJyB8fCBzaWduID09PSAnKycgPyBzdHIuc3Vic3RyaW5nKDEpIDogc3RyO1xuICAgIGNvbnN0IG51bSA9IChuKSA9PiBhc0JpZ0ludCA/IEJpZ0ludChuKSA6IE51bWJlcihuKTtcbiAgICBjb25zdCByZXMgPSBwYXJ0c1xuICAgICAgICAucmVwbGFjZSgvXy9nLCAnJylcbiAgICAgICAgLnNwbGl0KCc6JylcbiAgICAgICAgLnJlZHVjZSgocmVzLCBwKSA9PiByZXMgKiBudW0oNjApICsgbnVtKHApLCBudW0oMCkpO1xuICAgIHJldHVybiAoc2lnbiA9PT0gJy0nID8gbnVtKC0xKSAqIHJlcyA6IHJlcyk7XG59XG4vKipcbiAqIGhoaGg6bW06c3Muc3NzXG4gKlxuICogSW50ZXJuYWwgdHlwZXMgaGFuZGxlIGJpZ2ludCBhcyBudW1iZXIsIGJlY2F1c2UgVFMgY2FuJ3QgZmlndXJlIGl0IG91dC5cbiAqL1xuZnVuY3Rpb24gc3RyaW5naWZ5U2V4YWdlc2ltYWwobm9kZSkge1xuICAgIGxldCB7IHZhbHVlIH0gPSBub2RlO1xuICAgIGxldCBudW0gPSAobikgPT4gbjtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnYmlnaW50JylcbiAgICAgICAgbnVtID0gbiA9PiBCaWdJbnQobik7XG4gICAgZWxzZSBpZiAoaXNOYU4odmFsdWUpIHx8ICFpc0Zpbml0ZSh2YWx1ZSkpXG4gICAgICAgIHJldHVybiBzdHJpbmdpZnlOdW1iZXIobm9kZSk7XG4gICAgbGV0IHNpZ24gPSAnJztcbiAgICBpZiAodmFsdWUgPCAwKSB7XG4gICAgICAgIHNpZ24gPSAnLSc7XG4gICAgICAgIHZhbHVlICo9IG51bSgtMSk7XG4gICAgfVxuICAgIGNvbnN0IF82MCA9IG51bSg2MCk7XG4gICAgY29uc3QgcGFydHMgPSBbdmFsdWUgJSBfNjBdOyAvLyBzZWNvbmRzLCBpbmNsdWRpbmcgbXNcbiAgICBpZiAodmFsdWUgPCA2MCkge1xuICAgICAgICBwYXJ0cy51bnNoaWZ0KDApOyAvLyBhdCBsZWFzdCBvbmUgOiBpcyByZXF1aXJlZFxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmFsdWUgPSAodmFsdWUgLSBwYXJ0c1swXSkgLyBfNjA7XG4gICAgICAgIHBhcnRzLnVuc2hpZnQodmFsdWUgJSBfNjApOyAvLyBtaW51dGVzXG4gICAgICAgIGlmICh2YWx1ZSA+PSA2MCkge1xuICAgICAgICAgICAgdmFsdWUgPSAodmFsdWUgLSBwYXJ0c1swXSkgLyBfNjA7XG4gICAgICAgICAgICBwYXJ0cy51bnNoaWZ0KHZhbHVlKTsgLy8gaG91cnNcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gKHNpZ24gK1xuICAgICAgICBwYXJ0c1xuICAgICAgICAgICAgLm1hcChuID0+IChuIDwgMTAgPyAnMCcgKyBTdHJpbmcobikgOiBTdHJpbmcobikpKVxuICAgICAgICAgICAgLmpvaW4oJzonKVxuICAgICAgICAgICAgLnJlcGxhY2UoLzAwMDAwMFxcZCokLywgJycpIC8vICUgNjAgbWF5IGludHJvZHVjZSBlcnJvclxuICAgICk7XG59XG5jb25zdCBpbnRUaW1lID0ge1xuICAgIGlkZW50aWZ5OiB2YWx1ZSA9PiB0eXBlb2YgdmFsdWUgPT09ICdiaWdpbnQnIHx8IE51bWJlci5pc0ludGVnZXIodmFsdWUpLFxuICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6aW50JyxcbiAgICBmb3JtYXQ6ICdUSU1FJyxcbiAgICB0ZXN0OiAvXlstK10/WzAtOV1bMC05X10qKD86OlswLTVdP1swLTldKSskLyxcbiAgICByZXNvbHZlOiAoc3RyLCBfb25FcnJvciwgeyBpbnRBc0JpZ0ludCB9KSA9PiBwYXJzZVNleGFnZXNpbWFsKHN0ciwgaW50QXNCaWdJbnQpLFxuICAgIHN0cmluZ2lmeTogc3RyaW5naWZ5U2V4YWdlc2ltYWxcbn07XG5jb25zdCBmbG9hdFRpbWUgPSB7XG4gICAgaWRlbnRpZnk6IHZhbHVlID0+IHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicsXG4gICAgZGVmYXVsdDogdHJ1ZSxcbiAgICB0YWc6ICd0YWc6eWFtbC5vcmcsMjAwMjpmbG9hdCcsXG4gICAgZm9ybWF0OiAnVElNRScsXG4gICAgdGVzdDogL15bLStdP1swLTldWzAtOV9dKig/OjpbMC01XT9bMC05XSkrXFwuWzAtOV9dKiQvLFxuICAgIHJlc29sdmU6IHN0ciA9PiBwYXJzZVNleGFnZXNpbWFsKHN0ciwgZmFsc2UpLFxuICAgIHN0cmluZ2lmeTogc3RyaW5naWZ5U2V4YWdlc2ltYWxcbn07XG5jb25zdCB0aW1lc3RhbXAgPSB7XG4gICAgaWRlbnRpZnk6IHZhbHVlID0+IHZhbHVlIGluc3RhbmNlb2YgRGF0ZSxcbiAgICBkZWZhdWx0OiB0cnVlLFxuICAgIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOnRpbWVzdGFtcCcsXG4gICAgLy8gSWYgdGhlIHRpbWUgem9uZSBpcyBvbWl0dGVkLCB0aGUgdGltZXN0YW1wIGlzIGFzc3VtZWQgdG8gYmUgc3BlY2lmaWVkIGluIFVUQy4gVGhlIHRpbWUgcGFydFxuICAgIC8vIG1heSBiZSBvbWl0dGVkIGFsdG9nZXRoZXIsIHJlc3VsdGluZyBpbiBhIGRhdGUgZm9ybWF0LiBJbiBzdWNoIGEgY2FzZSwgdGhlIHRpbWUgcGFydCBpc1xuICAgIC8vIGFzc3VtZWQgdG8gYmUgMDA6MDA6MDBaIChzdGFydCBvZiBkYXksIFVUQykuXG4gICAgdGVzdDogUmVnRXhwKCdeKFswLTldezR9KS0oWzAtOV17MSwyfSktKFswLTldezEsMn0pJyArIC8vIFlZWVktTW0tRGRcbiAgICAgICAgJyg/OicgKyAvLyB0aW1lIGlzIG9wdGlvbmFsXG4gICAgICAgICcoPzp0fFR8WyBcXFxcdF0rKScgKyAvLyB0IHwgVCB8IHdoaXRlc3BhY2VcbiAgICAgICAgJyhbMC05XXsxLDJ9KTooWzAtOV17MSwyfSk6KFswLTldezEsMn0oXFxcXC5bMC05XSspPyknICsgLy8gSGg6TW06U3MoLnNzKT9cbiAgICAgICAgJyg/OlsgXFxcXHRdKihafFstK11bMDEyXT9bMC05XSg/OjpbMC05XXsyfSk/KSk/JyArIC8vIFogfCArNSB8IC0wMzozMFxuICAgICAgICAnKT8kJyksXG4gICAgcmVzb2x2ZShzdHIpIHtcbiAgICAgICAgY29uc3QgbWF0Y2ggPSBzdHIubWF0Y2godGltZXN0YW1wLnRlc3QpO1xuICAgICAgICBpZiAoIW1hdGNoKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCchIXRpbWVzdGFtcCBleHBlY3RzIGEgZGF0ZSwgc3RhcnRpbmcgd2l0aCB5eXl5LW1tLWRkJyk7XG4gICAgICAgIGNvbnN0IFssIHllYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbnV0ZSwgc2Vjb25kXSA9IG1hdGNoLm1hcChOdW1iZXIpO1xuICAgICAgICBjb25zdCBtaWxsaXNlYyA9IG1hdGNoWzddID8gTnVtYmVyKChtYXRjaFs3XSArICcwMCcpLnN1YnN0cigxLCAzKSkgOiAwO1xuICAgICAgICBsZXQgZGF0ZSA9IERhdGUuVVRDKHllYXIsIG1vbnRoIC0gMSwgZGF5LCBob3VyIHx8IDAsIG1pbnV0ZSB8fCAwLCBzZWNvbmQgfHwgMCwgbWlsbGlzZWMpO1xuICAgICAgICBjb25zdCB0eiA9IG1hdGNoWzhdO1xuICAgICAgICBpZiAodHogJiYgdHogIT09ICdaJykge1xuICAgICAgICAgICAgbGV0IGQgPSBwYXJzZVNleGFnZXNpbWFsKHR6LCBmYWxzZSk7XG4gICAgICAgICAgICBpZiAoTWF0aC5hYnMoZCkgPCAzMClcbiAgICAgICAgICAgICAgICBkICo9IDYwO1xuICAgICAgICAgICAgZGF0ZSAtPSA2MDAwMCAqIGQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKGRhdGUpO1xuICAgIH0sXG4gICAgc3RyaW5naWZ5OiAoeyB2YWx1ZSB9KSA9PiB2YWx1ZS50b0lTT1N0cmluZygpLnJlcGxhY2UoLygoVDAwOjAwKT86MDApP1xcLjAwMFokLywgJycpXG59O1xuXG5leHBvcnQgeyBmbG9hdFRpbWUsIGludFRpbWUsIHRpbWVzdGFtcCB9O1xuIiwgImltcG9ydCB7IG1hcCB9IGZyb20gJy4uL2NvbW1vbi9tYXAuanMnO1xuaW1wb3J0IHsgbnVsbFRhZyB9IGZyb20gJy4uL2NvbW1vbi9udWxsLmpzJztcbmltcG9ydCB7IHNlcSB9IGZyb20gJy4uL2NvbW1vbi9zZXEuanMnO1xuaW1wb3J0IHsgc3RyaW5nIH0gZnJvbSAnLi4vY29tbW9uL3N0cmluZy5qcyc7XG5pbXBvcnQgeyBiaW5hcnkgfSBmcm9tICcuL2JpbmFyeS5qcyc7XG5pbXBvcnQgeyB0cnVlVGFnLCBmYWxzZVRhZyB9IGZyb20gJy4vYm9vbC5qcyc7XG5pbXBvcnQgeyBmbG9hdE5hTiwgZmxvYXRFeHAsIGZsb2F0IH0gZnJvbSAnLi9mbG9hdC5qcyc7XG5pbXBvcnQgeyBpbnRCaW4sIGludE9jdCwgaW50LCBpbnRIZXggfSBmcm9tICcuL2ludC5qcyc7XG5pbXBvcnQgeyBvbWFwIH0gZnJvbSAnLi9vbWFwLmpzJztcbmltcG9ydCB7IHBhaXJzIH0gZnJvbSAnLi9wYWlycy5qcyc7XG5pbXBvcnQgeyBzZXQgfSBmcm9tICcuL3NldC5qcyc7XG5pbXBvcnQgeyBpbnRUaW1lLCBmbG9hdFRpbWUsIHRpbWVzdGFtcCB9IGZyb20gJy4vdGltZXN0YW1wLmpzJztcblxuY29uc3Qgc2NoZW1hID0gW1xuICAgIG1hcCxcbiAgICBzZXEsXG4gICAgc3RyaW5nLFxuICAgIG51bGxUYWcsXG4gICAgdHJ1ZVRhZyxcbiAgICBmYWxzZVRhZyxcbiAgICBpbnRCaW4sXG4gICAgaW50T2N0LFxuICAgIGludCxcbiAgICBpbnRIZXgsXG4gICAgZmxvYXROYU4sXG4gICAgZmxvYXRFeHAsXG4gICAgZmxvYXQsXG4gICAgYmluYXJ5LFxuICAgIG9tYXAsXG4gICAgcGFpcnMsXG4gICAgc2V0LFxuICAgIGludFRpbWUsXG4gICAgZmxvYXRUaW1lLFxuICAgIHRpbWVzdGFtcFxuXTtcblxuZXhwb3J0IHsgc2NoZW1hIH07XG4iLCAiaW1wb3J0IHsgbWFwIH0gZnJvbSAnLi9jb21tb24vbWFwLmpzJztcbmltcG9ydCB7IG51bGxUYWcgfSBmcm9tICcuL2NvbW1vbi9udWxsLmpzJztcbmltcG9ydCB7IHNlcSB9IGZyb20gJy4vY29tbW9uL3NlcS5qcyc7XG5pbXBvcnQgeyBzdHJpbmcgfSBmcm9tICcuL2NvbW1vbi9zdHJpbmcuanMnO1xuaW1wb3J0IHsgYm9vbFRhZyB9IGZyb20gJy4vY29yZS9ib29sLmpzJztcbmltcG9ydCB7IGZsb2F0LCBmbG9hdEV4cCwgZmxvYXROYU4gfSBmcm9tICcuL2NvcmUvZmxvYXQuanMnO1xuaW1wb3J0IHsgaW50LCBpbnRIZXgsIGludE9jdCB9IGZyb20gJy4vY29yZS9pbnQuanMnO1xuaW1wb3J0IHsgc2NoZW1hIH0gZnJvbSAnLi9jb3JlL3NjaGVtYS5qcyc7XG5pbXBvcnQgeyBzY2hlbWEgYXMgc2NoZW1hJDEgfSBmcm9tICcuL2pzb24vc2NoZW1hLmpzJztcbmltcG9ydCB7IGJpbmFyeSB9IGZyb20gJy4veWFtbC0xLjEvYmluYXJ5LmpzJztcbmltcG9ydCB7IG9tYXAgfSBmcm9tICcuL3lhbWwtMS4xL29tYXAuanMnO1xuaW1wb3J0IHsgcGFpcnMgfSBmcm9tICcuL3lhbWwtMS4xL3BhaXJzLmpzJztcbmltcG9ydCB7IHNjaGVtYSBhcyBzY2hlbWEkMiB9IGZyb20gJy4veWFtbC0xLjEvc2NoZW1hLmpzJztcbmltcG9ydCB7IHNldCB9IGZyb20gJy4veWFtbC0xLjEvc2V0LmpzJztcbmltcG9ydCB7IGZsb2F0VGltZSwgaW50VGltZSwgdGltZXN0YW1wIH0gZnJvbSAnLi95YW1sLTEuMS90aW1lc3RhbXAuanMnO1xuXG5jb25zdCBzY2hlbWFzID0gbmV3IE1hcChbXG4gICAgWydjb3JlJywgc2NoZW1hXSxcbiAgICBbJ2ZhaWxzYWZlJywgW21hcCwgc2VxLCBzdHJpbmddXSxcbiAgICBbJ2pzb24nLCBzY2hlbWEkMV0sXG4gICAgWyd5YW1sMTEnLCBzY2hlbWEkMl0sXG4gICAgWyd5YW1sLTEuMScsIHNjaGVtYSQyXVxuXSk7XG5jb25zdCB0YWdzQnlOYW1lID0ge1xuICAgIGJpbmFyeSxcbiAgICBib29sOiBib29sVGFnLFxuICAgIGZsb2F0LFxuICAgIGZsb2F0RXhwLFxuICAgIGZsb2F0TmFOLFxuICAgIGZsb2F0VGltZSxcbiAgICBpbnQsXG4gICAgaW50SGV4LFxuICAgIGludE9jdCxcbiAgICBpbnRUaW1lLFxuICAgIG1hcCxcbiAgICBudWxsOiBudWxsVGFnLFxuICAgIG9tYXAsXG4gICAgcGFpcnMsXG4gICAgc2VxLFxuICAgIHNldCxcbiAgICB0aW1lc3RhbXBcbn07XG5jb25zdCBjb3JlS25vd25UYWdzID0ge1xuICAgICd0YWc6eWFtbC5vcmcsMjAwMjpiaW5hcnknOiBiaW5hcnksXG4gICAgJ3RhZzp5YW1sLm9yZywyMDAyOm9tYXAnOiBvbWFwLFxuICAgICd0YWc6eWFtbC5vcmcsMjAwMjpwYWlycyc6IHBhaXJzLFxuICAgICd0YWc6eWFtbC5vcmcsMjAwMjpzZXQnOiBzZXQsXG4gICAgJ3RhZzp5YW1sLm9yZywyMDAyOnRpbWVzdGFtcCc6IHRpbWVzdGFtcFxufTtcbmZ1bmN0aW9uIGdldFRhZ3MoY3VzdG9tVGFncywgc2NoZW1hTmFtZSkge1xuICAgIGxldCB0YWdzID0gc2NoZW1hcy5nZXQoc2NoZW1hTmFtZSk7XG4gICAgaWYgKCF0YWdzKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGN1c3RvbVRhZ3MpKVxuICAgICAgICAgICAgdGFncyA9IFtdO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGtleXMgPSBBcnJheS5mcm9tKHNjaGVtYXMua2V5cygpKVxuICAgICAgICAgICAgICAgIC5maWx0ZXIoa2V5ID0+IGtleSAhPT0gJ3lhbWwxMScpXG4gICAgICAgICAgICAgICAgLm1hcChrZXkgPT4gSlNPTi5zdHJpbmdpZnkoa2V5KSlcbiAgICAgICAgICAgICAgICAuam9pbignLCAnKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBzY2hlbWEgXCIke3NjaGVtYU5hbWV9XCI7IHVzZSBvbmUgb2YgJHtrZXlzfSBvciBkZWZpbmUgY3VzdG9tVGFncyBhcnJheWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KGN1c3RvbVRhZ3MpKSB7XG4gICAgICAgIGZvciAoY29uc3QgdGFnIG9mIGN1c3RvbVRhZ3MpXG4gICAgICAgICAgICB0YWdzID0gdGFncy5jb25jYXQodGFnKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGN1c3RvbVRhZ3MgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGFncyA9IGN1c3RvbVRhZ3ModGFncy5zbGljZSgpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRhZ3MubWFwKHRhZyA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgdGFnICE9PSAnc3RyaW5nJylcbiAgICAgICAgICAgIHJldHVybiB0YWc7XG4gICAgICAgIGNvbnN0IHRhZ09iaiA9IHRhZ3NCeU5hbWVbdGFnXTtcbiAgICAgICAgaWYgKHRhZ09iailcbiAgICAgICAgICAgIHJldHVybiB0YWdPYmo7XG4gICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyh0YWdzQnlOYW1lKVxuICAgICAgICAgICAgLm1hcChrZXkgPT4gSlNPTi5zdHJpbmdpZnkoa2V5KSlcbiAgICAgICAgICAgIC5qb2luKCcsICcpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gY3VzdG9tIHRhZyBcIiR7dGFnfVwiOyB1c2Ugb25lIG9mICR7a2V5c31gKTtcbiAgICB9KTtcbn1cblxuZXhwb3J0IHsgY29yZUtub3duVGFncywgZ2V0VGFncyB9O1xuIiwgImltcG9ydCB7IE1BUCwgU0NBTEFSLCBTRVEgfSBmcm9tICcuLi9ub2Rlcy9Ob2RlLmpzJztcbmltcG9ydCB7IG1hcCB9IGZyb20gJy4vY29tbW9uL21hcC5qcyc7XG5pbXBvcnQgeyBzZXEgfSBmcm9tICcuL2NvbW1vbi9zZXEuanMnO1xuaW1wb3J0IHsgc3RyaW5nIH0gZnJvbSAnLi9jb21tb24vc3RyaW5nLmpzJztcbmltcG9ydCB7IGdldFRhZ3MsIGNvcmVLbm93blRhZ3MgfSBmcm9tICcuL3RhZ3MuanMnO1xuXG5jb25zdCBzb3J0TWFwRW50cmllc0J5S2V5ID0gKGEsIGIpID0+IGEua2V5IDwgYi5rZXkgPyAtMSA6IGEua2V5ID4gYi5rZXkgPyAxIDogMDtcbmNsYXNzIFNjaGVtYSB7XG4gICAgY29uc3RydWN0b3IoeyBjb21wYXQsIGN1c3RvbVRhZ3MsIG1lcmdlLCByZXNvbHZlS25vd25UYWdzLCBzY2hlbWEsIHNvcnRNYXBFbnRyaWVzLCB0b1N0cmluZ0RlZmF1bHRzIH0pIHtcbiAgICAgICAgdGhpcy5jb21wYXQgPSBBcnJheS5pc0FycmF5KGNvbXBhdClcbiAgICAgICAgICAgID8gZ2V0VGFncyhjb21wYXQsICdjb21wYXQnKVxuICAgICAgICAgICAgOiBjb21wYXRcbiAgICAgICAgICAgICAgICA/IGdldFRhZ3MobnVsbCwgY29tcGF0KVxuICAgICAgICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgdGhpcy5tZXJnZSA9ICEhbWVyZ2U7XG4gICAgICAgIHRoaXMubmFtZSA9ICh0eXBlb2Ygc2NoZW1hID09PSAnc3RyaW5nJyAmJiBzY2hlbWEpIHx8ICdjb3JlJztcbiAgICAgICAgdGhpcy5rbm93blRhZ3MgPSByZXNvbHZlS25vd25UYWdzID8gY29yZUtub3duVGFncyA6IHt9O1xuICAgICAgICB0aGlzLnRhZ3MgPSBnZXRUYWdzKGN1c3RvbVRhZ3MsIHRoaXMubmFtZSk7XG4gICAgICAgIHRoaXMudG9TdHJpbmdPcHRpb25zID0gdG9TdHJpbmdEZWZhdWx0cyB8fCBudWxsO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgTUFQLCB7IHZhbHVlOiBtYXAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBTQ0FMQVIsIHsgdmFsdWU6IHN0cmluZyB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFNFUSwgeyB2YWx1ZTogc2VxIH0pO1xuICAgICAgICAvLyBVc2VkIGJ5IGNyZWF0ZU1hcCgpXG4gICAgICAgIHRoaXMuc29ydE1hcEVudHJpZXMgPVxuICAgICAgICAgICAgc29ydE1hcEVudHJpZXMgPT09IHRydWUgPyBzb3J0TWFwRW50cmllc0J5S2V5IDogc29ydE1hcEVudHJpZXMgfHwgbnVsbDtcbiAgICB9XG4gICAgY2xvbmUoKSB7XG4gICAgICAgIGNvbnN0IGNvcHkgPSBPYmplY3QuY3JlYXRlKFNjaGVtYS5wcm90b3R5cGUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHRoaXMpKTtcbiAgICAgICAgY29weS50YWdzID0gdGhpcy50YWdzLnNsaWNlKCk7XG4gICAgICAgIHJldHVybiBjb3B5O1xuICAgIH1cbn1cblxuZXhwb3J0IHsgU2NoZW1hIH07XG4iLCAiaW1wb3J0IHsgaXNOb2RlIH0gZnJvbSAnLi4vbm9kZXMvTm9kZS5qcyc7XG5pbXBvcnQgeyBjcmVhdGVTdHJpbmdpZnlDb250ZXh0LCBzdHJpbmdpZnkgfSBmcm9tICcuL3N0cmluZ2lmeS5qcyc7XG5pbXBvcnQgeyBpbmRlbnRDb21tZW50LCBsaW5lQ29tbWVudCB9IGZyb20gJy4vc3RyaW5naWZ5Q29tbWVudC5qcyc7XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeURvY3VtZW50KGRvYywgb3B0aW9ucykge1xuICAgIGNvbnN0IGxpbmVzID0gW107XG4gICAgbGV0IGhhc0RpcmVjdGl2ZXMgPSBvcHRpb25zLmRpcmVjdGl2ZXMgPT09IHRydWU7XG4gICAgaWYgKG9wdGlvbnMuZGlyZWN0aXZlcyAhPT0gZmFsc2UgJiYgZG9jLmRpcmVjdGl2ZXMpIHtcbiAgICAgICAgY29uc3QgZGlyID0gZG9jLmRpcmVjdGl2ZXMudG9TdHJpbmcoZG9jKTtcbiAgICAgICAgaWYgKGRpcikge1xuICAgICAgICAgICAgbGluZXMucHVzaChkaXIpO1xuICAgICAgICAgICAgaGFzRGlyZWN0aXZlcyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZG9jLmRpcmVjdGl2ZXMubWFya2VyKVxuICAgICAgICAgICAgaGFzRGlyZWN0aXZlcyA9IHRydWU7XG4gICAgfVxuICAgIGlmIChoYXNEaXJlY3RpdmVzKVxuICAgICAgICBsaW5lcy5wdXNoKCctLS0nKTtcbiAgICBjb25zdCBjdHggPSBjcmVhdGVTdHJpbmdpZnlDb250ZXh0KGRvYywgb3B0aW9ucyk7XG4gICAgY29uc3QgeyBjb21tZW50U3RyaW5nIH0gPSBjdHgub3B0aW9ucztcbiAgICBpZiAoZG9jLmNvbW1lbnRCZWZvcmUpIHtcbiAgICAgICAgaWYgKGxpbmVzLmxlbmd0aCAhPT0gMSlcbiAgICAgICAgICAgIGxpbmVzLnVuc2hpZnQoJycpO1xuICAgICAgICBjb25zdCBjcyA9IGNvbW1lbnRTdHJpbmcoZG9jLmNvbW1lbnRCZWZvcmUpO1xuICAgICAgICBsaW5lcy51bnNoaWZ0KGluZGVudENvbW1lbnQoY3MsICcnKSk7XG4gICAgfVxuICAgIGxldCBjaG9tcEtlZXAgPSBmYWxzZTtcbiAgICBsZXQgY29udGVudENvbW1lbnQgPSBudWxsO1xuICAgIGlmIChkb2MuY29udGVudHMpIHtcbiAgICAgICAgaWYgKGlzTm9kZShkb2MuY29udGVudHMpKSB7XG4gICAgICAgICAgICBpZiAoZG9jLmNvbnRlbnRzLnNwYWNlQmVmb3JlICYmIGhhc0RpcmVjdGl2ZXMpXG4gICAgICAgICAgICAgICAgbGluZXMucHVzaCgnJyk7XG4gICAgICAgICAgICBpZiAoZG9jLmNvbnRlbnRzLmNvbW1lbnRCZWZvcmUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjcyA9IGNvbW1lbnRTdHJpbmcoZG9jLmNvbnRlbnRzLmNvbW1lbnRCZWZvcmUpO1xuICAgICAgICAgICAgICAgIGxpbmVzLnB1c2goaW5kZW50Q29tbWVudChjcywgJycpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHRvcC1sZXZlbCBibG9jayBzY2FsYXJzIG5lZWQgdG8gYmUgaW5kZW50ZWQgaWYgZm9sbG93ZWQgYnkgYSBjb21tZW50XG4gICAgICAgICAgICBjdHguZm9yY2VCbG9ja0luZGVudCA9ICEhZG9jLmNvbW1lbnQ7XG4gICAgICAgICAgICBjb250ZW50Q29tbWVudCA9IGRvYy5jb250ZW50cy5jb21tZW50O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9uQ2hvbXBLZWVwID0gY29udGVudENvbW1lbnQgPyB1bmRlZmluZWQgOiAoKSA9PiAoY2hvbXBLZWVwID0gdHJ1ZSk7XG4gICAgICAgIGxldCBib2R5ID0gc3RyaW5naWZ5KGRvYy5jb250ZW50cywgY3R4LCAoKSA9PiAoY29udGVudENvbW1lbnQgPSBudWxsKSwgb25DaG9tcEtlZXApO1xuICAgICAgICBpZiAoY29udGVudENvbW1lbnQpXG4gICAgICAgICAgICBib2R5ICs9IGxpbmVDb21tZW50KGJvZHksICcnLCBjb21tZW50U3RyaW5nKGNvbnRlbnRDb21tZW50KSk7XG4gICAgICAgIGlmICgoYm9keVswXSA9PT0gJ3wnIHx8IGJvZHlbMF0gPT09ICc+JykgJiZcbiAgICAgICAgICAgIGxpbmVzW2xpbmVzLmxlbmd0aCAtIDFdID09PSAnLS0tJykge1xuICAgICAgICAgICAgLy8gVG9wLWxldmVsIGJsb2NrIHNjYWxhcnMgd2l0aCBhIHByZWNlZGluZyBkb2MgbWFya2VyIG91Z2h0IHRvIHVzZSB0aGVcbiAgICAgICAgICAgIC8vIHNhbWUgbGluZSBmb3IgdGhlaXIgaGVhZGVyLlxuICAgICAgICAgICAgbGluZXNbbGluZXMubGVuZ3RoIC0gMV0gPSBgLS0tICR7Ym9keX1gO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGxpbmVzLnB1c2goYm9keSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBsaW5lcy5wdXNoKHN0cmluZ2lmeShkb2MuY29udGVudHMsIGN0eCkpO1xuICAgIH1cbiAgICBsZXQgZGMgPSBkb2MuY29tbWVudDtcbiAgICBpZiAoZGMgJiYgY2hvbXBLZWVwKVxuICAgICAgICBkYyA9IGRjLnJlcGxhY2UoL15cXG4rLywgJycpO1xuICAgIGlmIChkYykge1xuICAgICAgICBpZiAoKCFjaG9tcEtlZXAgfHwgY29udGVudENvbW1lbnQpICYmIGxpbmVzW2xpbmVzLmxlbmd0aCAtIDFdICE9PSAnJylcbiAgICAgICAgICAgIGxpbmVzLnB1c2goJycpO1xuICAgICAgICBsaW5lcy5wdXNoKGluZGVudENvbW1lbnQoY29tbWVudFN0cmluZyhkYyksICcnKSk7XG4gICAgfVxuICAgIHJldHVybiBsaW5lcy5qb2luKCdcXG4nKSArICdcXG4nO1xufVxuXG5leHBvcnQgeyBzdHJpbmdpZnlEb2N1bWVudCB9O1xuIiwgIi8qKlxuICogQXBwbGllcyB0aGUgSlNPTi5wYXJzZSByZXZpdmVyIGFsZ29yaXRobSBhcyBkZWZpbmVkIGluIHRoZSBFQ01BLTI2MiBzcGVjLFxuICogaW4gc2VjdGlvbiAyNC41LjEuMSBcIlJ1bnRpbWUgU2VtYW50aWNzOiBJbnRlcm5hbGl6ZUpTT05Qcm9wZXJ0eVwiIG9mIHRoZVxuICogMjAyMSBlZGl0aW9uOiBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWpzb24ucGFyc2VcbiAqXG4gKiBJbmNsdWRlcyBleHRlbnNpb25zIGZvciBoYW5kbGluZyBNYXAgYW5kIFNldCBvYmplY3RzLlxuICovXG5mdW5jdGlvbiBhcHBseVJldml2ZXIocmV2aXZlciwgb2JqLCBrZXksIHZhbCkge1xuICAgIGlmICh2YWwgJiYgdHlwZW9mIHZhbCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHZhbC5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHYwID0gdmFsW2ldO1xuICAgICAgICAgICAgICAgIGNvbnN0IHYxID0gYXBwbHlSZXZpdmVyKHJldml2ZXIsIHZhbCwgU3RyaW5nKGkpLCB2MCk7XG4gICAgICAgICAgICAgICAgaWYgKHYxID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB2YWxbaV07XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodjEgIT09IHYwKVxuICAgICAgICAgICAgICAgICAgICB2YWxbaV0gPSB2MTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2YWwgaW5zdGFuY2VvZiBNYXApIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgayBvZiBBcnJheS5mcm9tKHZhbC5rZXlzKCkpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdjAgPSB2YWwuZ2V0KGspO1xuICAgICAgICAgICAgICAgIGNvbnN0IHYxID0gYXBwbHlSZXZpdmVyKHJldml2ZXIsIHZhbCwgaywgdjApO1xuICAgICAgICAgICAgICAgIGlmICh2MSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgICAgICB2YWwuZGVsZXRlKGspO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHYxICE9PSB2MClcbiAgICAgICAgICAgICAgICAgICAgdmFsLnNldChrLCB2MSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmFsIGluc3RhbmNlb2YgU2V0KSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHYwIG9mIEFycmF5LmZyb20odmFsKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHYxID0gYXBwbHlSZXZpdmVyKHJldml2ZXIsIHZhbCwgdjAsIHYwKTtcbiAgICAgICAgICAgICAgICBpZiAodjEgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICAgICAgdmFsLmRlbGV0ZSh2MCk7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodjEgIT09IHYwKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbC5kZWxldGUodjApO1xuICAgICAgICAgICAgICAgICAgICB2YWwuYWRkKHYxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtrLCB2MF0gb2YgT2JqZWN0LmVudHJpZXModmFsKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHYxID0gYXBwbHlSZXZpdmVyKHJldml2ZXIsIHZhbCwgaywgdjApO1xuICAgICAgICAgICAgICAgIGlmICh2MSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdmFsW2tdO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHYxICE9PSB2MClcbiAgICAgICAgICAgICAgICAgICAgdmFsW2tdID0gdjE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJldml2ZXIuY2FsbChvYmosIGtleSwgdmFsKTtcbn1cblxuZXhwb3J0IHsgYXBwbHlSZXZpdmVyIH07XG4iLCAiaW1wb3J0IHsgQWxpYXMgfSBmcm9tICcuLi9ub2Rlcy9BbGlhcy5qcyc7XG5pbXBvcnQgeyBpc0VtcHR5UGF0aCwgY29sbGVjdGlvbkZyb21QYXRoIH0gZnJvbSAnLi4vbm9kZXMvQ29sbGVjdGlvbi5qcyc7XG5pbXBvcnQgeyBOT0RFX1RZUEUsIERPQywgaXNOb2RlLCBpc0NvbGxlY3Rpb24sIGlzU2NhbGFyIH0gZnJvbSAnLi4vbm9kZXMvTm9kZS5qcyc7XG5pbXBvcnQgeyBQYWlyIH0gZnJvbSAnLi4vbm9kZXMvUGFpci5qcyc7XG5pbXBvcnQgeyB0b0pTIH0gZnJvbSAnLi4vbm9kZXMvdG9KUy5qcyc7XG5pbXBvcnQgeyBkZWZhdWx0T3B0aW9ucyB9IGZyb20gJy4uL29wdGlvbnMuanMnO1xuaW1wb3J0IHsgU2NoZW1hIH0gZnJvbSAnLi4vc2NoZW1hL1NjaGVtYS5qcyc7XG5pbXBvcnQgeyBzdHJpbmdpZnkgfSBmcm9tICcuLi9zdHJpbmdpZnkvc3RyaW5naWZ5LmpzJztcbmltcG9ydCB7IHN0cmluZ2lmeURvY3VtZW50IH0gZnJvbSAnLi4vc3RyaW5naWZ5L3N0cmluZ2lmeURvY3VtZW50LmpzJztcbmltcG9ydCB7IGFuY2hvck5hbWVzLCBmaW5kTmV3QW5jaG9yLCBjcmVhdGVOb2RlQW5jaG9ycyB9IGZyb20gJy4vYW5jaG9ycy5qcyc7XG5pbXBvcnQgeyBhcHBseVJldml2ZXIgfSBmcm9tICcuL2FwcGx5UmV2aXZlci5qcyc7XG5pbXBvcnQgeyBjcmVhdGVOb2RlIH0gZnJvbSAnLi9jcmVhdGVOb2RlLmpzJztcbmltcG9ydCB7IERpcmVjdGl2ZXMgfSBmcm9tICcuL2RpcmVjdGl2ZXMuanMnO1xuXG5jbGFzcyBEb2N1bWVudCB7XG4gICAgY29uc3RydWN0b3IodmFsdWUsIHJlcGxhY2VyLCBvcHRpb25zKSB7XG4gICAgICAgIC8qKiBBIGNvbW1lbnQgYmVmb3JlIHRoaXMgRG9jdW1lbnQgKi9cbiAgICAgICAgdGhpcy5jb21tZW50QmVmb3JlID0gbnVsbDtcbiAgICAgICAgLyoqIEEgY29tbWVudCBpbW1lZGlhdGVseSBhZnRlciB0aGlzIERvY3VtZW50ICovXG4gICAgICAgIHRoaXMuY29tbWVudCA9IG51bGw7XG4gICAgICAgIC8qKiBFcnJvcnMgZW5jb3VudGVyZWQgZHVyaW5nIHBhcnNpbmcuICovXG4gICAgICAgIHRoaXMuZXJyb3JzID0gW107XG4gICAgICAgIC8qKiBXYXJuaW5ncyBlbmNvdW50ZXJlZCBkdXJpbmcgcGFyc2luZy4gKi9cbiAgICAgICAgdGhpcy53YXJuaW5ncyA9IFtdO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgTk9ERV9UWVBFLCB7IHZhbHVlOiBET0MgfSk7XG4gICAgICAgIGxldCBfcmVwbGFjZXIgPSBudWxsO1xuICAgICAgICBpZiAodHlwZW9mIHJlcGxhY2VyID09PSAnZnVuY3Rpb24nIHx8IEFycmF5LmlzQXJyYXkocmVwbGFjZXIpKSB7XG4gICAgICAgICAgICBfcmVwbGFjZXIgPSByZXBsYWNlcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvcHRpb25zID09PSB1bmRlZmluZWQgJiYgcmVwbGFjZXIpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSByZXBsYWNlcjtcbiAgICAgICAgICAgIHJlcGxhY2VyID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9wdCA9IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRPcHRpb25zLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0O1xuICAgICAgICBsZXQgeyB2ZXJzaW9uIH0gPSBvcHQ7XG4gICAgICAgIGlmIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZGlyZWN0aXZlcykge1xuICAgICAgICAgICAgdGhpcy5kaXJlY3RpdmVzID0gb3B0aW9ucy5kaXJlY3RpdmVzLmF0RG9jdW1lbnQoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmRpcmVjdGl2ZXMueWFtbC5leHBsaWNpdClcbiAgICAgICAgICAgICAgICB2ZXJzaW9uID0gdGhpcy5kaXJlY3RpdmVzLnlhbWwudmVyc2lvbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLmRpcmVjdGl2ZXMgPSBuZXcgRGlyZWN0aXZlcyh7IHZlcnNpb24gfSk7XG4gICAgICAgIHRoaXMuc2V0U2NoZW1hKHZlcnNpb24sIG9wdGlvbnMpO1xuICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHRoaXMuY29udGVudHMgPSBudWxsO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY29udGVudHMgPSB0aGlzLmNyZWF0ZU5vZGUodmFsdWUsIF9yZXBsYWNlciwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgZGVlcCBjb3B5IG9mIHRoaXMgRG9jdW1lbnQgYW5kIGl0cyBjb250ZW50cy5cbiAgICAgKlxuICAgICAqIEN1c3RvbSBOb2RlIHZhbHVlcyB0aGF0IGluaGVyaXQgZnJvbSBgT2JqZWN0YCBzdGlsbCByZWZlciB0byB0aGVpciBvcmlnaW5hbCBpbnN0YW5jZXMuXG4gICAgICovXG4gICAgY2xvbmUoKSB7XG4gICAgICAgIGNvbnN0IGNvcHkgPSBPYmplY3QuY3JlYXRlKERvY3VtZW50LnByb3RvdHlwZSwge1xuICAgICAgICAgICAgW05PREVfVFlQRV06IHsgdmFsdWU6IERPQyB9XG4gICAgICAgIH0pO1xuICAgICAgICBjb3B5LmNvbW1lbnRCZWZvcmUgPSB0aGlzLmNvbW1lbnRCZWZvcmU7XG4gICAgICAgIGNvcHkuY29tbWVudCA9IHRoaXMuY29tbWVudDtcbiAgICAgICAgY29weS5lcnJvcnMgPSB0aGlzLmVycm9ycy5zbGljZSgpO1xuICAgICAgICBjb3B5Lndhcm5pbmdzID0gdGhpcy53YXJuaW5ncy5zbGljZSgpO1xuICAgICAgICBjb3B5Lm9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLm9wdGlvbnMpO1xuICAgICAgICBpZiAodGhpcy5kaXJlY3RpdmVzKVxuICAgICAgICAgICAgY29weS5kaXJlY3RpdmVzID0gdGhpcy5kaXJlY3RpdmVzLmNsb25lKCk7XG4gICAgICAgIGNvcHkuc2NoZW1hID0gdGhpcy5zY2hlbWEuY2xvbmUoKTtcbiAgICAgICAgY29weS5jb250ZW50cyA9IGlzTm9kZSh0aGlzLmNvbnRlbnRzKVxuICAgICAgICAgICAgPyB0aGlzLmNvbnRlbnRzLmNsb25lKGNvcHkuc2NoZW1hKVxuICAgICAgICAgICAgOiB0aGlzLmNvbnRlbnRzO1xuICAgICAgICBpZiAodGhpcy5yYW5nZSlcbiAgICAgICAgICAgIGNvcHkucmFuZ2UgPSB0aGlzLnJhbmdlLnNsaWNlKCk7XG4gICAgICAgIHJldHVybiBjb3B5O1xuICAgIH1cbiAgICAvKiogQWRkcyBhIHZhbHVlIHRvIHRoZSBkb2N1bWVudC4gKi9cbiAgICBhZGQodmFsdWUpIHtcbiAgICAgICAgaWYgKGFzc2VydENvbGxlY3Rpb24odGhpcy5jb250ZW50cykpXG4gICAgICAgICAgICB0aGlzLmNvbnRlbnRzLmFkZCh2YWx1ZSk7XG4gICAgfVxuICAgIC8qKiBBZGRzIGEgdmFsdWUgdG8gdGhlIGRvY3VtZW50LiAqL1xuICAgIGFkZEluKHBhdGgsIHZhbHVlKSB7XG4gICAgICAgIGlmIChhc3NlcnRDb2xsZWN0aW9uKHRoaXMuY29udGVudHMpKVxuICAgICAgICAgICAgdGhpcy5jb250ZW50cy5hZGRJbihwYXRoLCB2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBgQWxpYXNgIG5vZGUsIGVuc3VyaW5nIHRoYXQgdGhlIHRhcmdldCBgbm9kZWAgaGFzIHRoZSByZXF1aXJlZCBhbmNob3IuXG4gICAgICpcbiAgICAgKiBJZiBgbm9kZWAgYWxyZWFkeSBoYXMgYW4gYW5jaG9yLCBgbmFtZWAgaXMgaWdub3JlZC5cbiAgICAgKiBPdGhlcndpc2UsIHRoZSBgbm9kZS5hbmNob3JgIHZhbHVlIHdpbGwgYmUgc2V0IHRvIGBuYW1lYCxcbiAgICAgKiBvciBpZiBhbiBhbmNob3Igd2l0aCB0aGF0IG5hbWUgaXMgYWxyZWFkeSBwcmVzZW50IGluIHRoZSBkb2N1bWVudCxcbiAgICAgKiBgbmFtZWAgd2lsbCBiZSB1c2VkIGFzIGEgcHJlZml4IGZvciBhIG5ldyB1bmlxdWUgYW5jaG9yLlxuICAgICAqIElmIGBuYW1lYCBpcyB1bmRlZmluZWQsIHRoZSBnZW5lcmF0ZWQgYW5jaG9yIHdpbGwgdXNlICdhJyBhcyBhIHByZWZpeC5cbiAgICAgKi9cbiAgICBjcmVhdGVBbGlhcyhub2RlLCBuYW1lKSB7XG4gICAgICAgIGlmICghbm9kZS5hbmNob3IpIHtcbiAgICAgICAgICAgIGNvbnN0IHByZXYgPSBhbmNob3JOYW1lcyh0aGlzKTtcbiAgICAgICAgICAgIG5vZGUuYW5jaG9yID1cbiAgICAgICAgICAgICAgICAhbmFtZSB8fCBwcmV2LmhhcyhuYW1lKSA/IGZpbmROZXdBbmNob3IobmFtZSB8fCAnYScsIHByZXYpIDogbmFtZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEFsaWFzKG5vZGUuYW5jaG9yKTtcbiAgICB9XG4gICAgY3JlYXRlTm9kZSh2YWx1ZSwgcmVwbGFjZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgbGV0IF9yZXBsYWNlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHR5cGVvZiByZXBsYWNlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdmFsdWUgPSByZXBsYWNlci5jYWxsKHsgJyc6IHZhbHVlIH0sICcnLCB2YWx1ZSk7XG4gICAgICAgICAgICBfcmVwbGFjZXIgPSByZXBsYWNlcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHJlcGxhY2VyKSkge1xuICAgICAgICAgICAgY29uc3Qga2V5VG9TdHIgPSAodikgPT4gdHlwZW9mIHYgPT09ICdudW1iZXInIHx8IHYgaW5zdGFuY2VvZiBTdHJpbmcgfHwgdiBpbnN0YW5jZW9mIE51bWJlcjtcbiAgICAgICAgICAgIGNvbnN0IGFzU3RyID0gcmVwbGFjZXIuZmlsdGVyKGtleVRvU3RyKS5tYXAoU3RyaW5nKTtcbiAgICAgICAgICAgIGlmIChhc1N0ci5sZW5ndGggPiAwKVxuICAgICAgICAgICAgICAgIHJlcGxhY2VyID0gcmVwbGFjZXIuY29uY2F0KGFzU3RyKTtcbiAgICAgICAgICAgIF9yZXBsYWNlciA9IHJlcGxhY2VyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9wdGlvbnMgPT09IHVuZGVmaW5lZCAmJiByZXBsYWNlcikge1xuICAgICAgICAgICAgb3B0aW9ucyA9IHJlcGxhY2VyO1xuICAgICAgICAgICAgcmVwbGFjZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBhbGlhc0R1cGxpY2F0ZU9iamVjdHMsIGFuY2hvclByZWZpeCwgZmxvdywga2VlcFVuZGVmaW5lZCwgb25UYWdPYmosIHRhZyB9ID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgY29uc3QgeyBvbkFuY2hvciwgc2V0QW5jaG9ycywgc291cmNlT2JqZWN0cyB9ID0gY3JlYXRlTm9kZUFuY2hvcnModGhpcywgYW5jaG9yUHJlZml4IHx8ICdhJyk7XG4gICAgICAgIGNvbnN0IGN0eCA9IHtcbiAgICAgICAgICAgIGFsaWFzRHVwbGljYXRlT2JqZWN0czogYWxpYXNEdXBsaWNhdGVPYmplY3RzICE9PSBudWxsICYmIGFsaWFzRHVwbGljYXRlT2JqZWN0cyAhPT0gdm9pZCAwID8gYWxpYXNEdXBsaWNhdGVPYmplY3RzIDogdHJ1ZSxcbiAgICAgICAgICAgIGtlZXBVbmRlZmluZWQ6IGtlZXBVbmRlZmluZWQgIT09IG51bGwgJiYga2VlcFVuZGVmaW5lZCAhPT0gdm9pZCAwID8ga2VlcFVuZGVmaW5lZCA6IGZhbHNlLFxuICAgICAgICAgICAgb25BbmNob3IsXG4gICAgICAgICAgICBvblRhZ09iaixcbiAgICAgICAgICAgIHJlcGxhY2VyOiBfcmVwbGFjZXIsXG4gICAgICAgICAgICBzY2hlbWE6IHRoaXMuc2NoZW1hLFxuICAgICAgICAgICAgc291cmNlT2JqZWN0c1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBub2RlID0gY3JlYXRlTm9kZSh2YWx1ZSwgdGFnLCBjdHgpO1xuICAgICAgICBpZiAoZmxvdyAmJiBpc0NvbGxlY3Rpb24obm9kZSkpXG4gICAgICAgICAgICBub2RlLmZsb3cgPSB0cnVlO1xuICAgICAgICBzZXRBbmNob3JzKCk7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IGEga2V5IGFuZCBhIHZhbHVlIGludG8gYSBgUGFpcmAgdXNpbmcgdGhlIGN1cnJlbnQgc2NoZW1hLFxuICAgICAqIHJlY3Vyc2l2ZWx5IHdyYXBwaW5nIGFsbCB2YWx1ZXMgYXMgYFNjYWxhcmAgb3IgYENvbGxlY3Rpb25gIG5vZGVzLlxuICAgICAqL1xuICAgIGNyZWF0ZVBhaXIoa2V5LCB2YWx1ZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IGsgPSB0aGlzLmNyZWF0ZU5vZGUoa2V5LCBudWxsLCBvcHRpb25zKTtcbiAgICAgICAgY29uc3QgdiA9IHRoaXMuY3JlYXRlTm9kZSh2YWx1ZSwgbnVsbCwgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBuZXcgUGFpcihrLCB2KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhIHZhbHVlIGZyb20gdGhlIGRvY3VtZW50LlxuICAgICAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgaXRlbSB3YXMgZm91bmQgYW5kIHJlbW92ZWQuXG4gICAgICovXG4gICAgZGVsZXRlKGtleSkge1xuICAgICAgICByZXR1cm4gYXNzZXJ0Q29sbGVjdGlvbih0aGlzLmNvbnRlbnRzKSA/IHRoaXMuY29udGVudHMuZGVsZXRlKGtleSkgOiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhIHZhbHVlIGZyb20gdGhlIGRvY3VtZW50LlxuICAgICAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgaXRlbSB3YXMgZm91bmQgYW5kIHJlbW92ZWQuXG4gICAgICovXG4gICAgZGVsZXRlSW4ocGF0aCkge1xuICAgICAgICBpZiAoaXNFbXB0eVBhdGgocGF0aCkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbnRlbnRzID09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5jb250ZW50cyA9IG51bGw7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXNzZXJ0Q29sbGVjdGlvbih0aGlzLmNvbnRlbnRzKVxuICAgICAgICAgICAgPyB0aGlzLmNvbnRlbnRzLmRlbGV0ZUluKHBhdGgpXG4gICAgICAgICAgICA6IGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGl0ZW0gYXQgYGtleWAsIG9yIGB1bmRlZmluZWRgIGlmIG5vdCBmb3VuZC4gQnkgZGVmYXVsdCB1bndyYXBzXG4gICAgICogc2NhbGFyIHZhbHVlcyBmcm9tIHRoZWlyIHN1cnJvdW5kaW5nIG5vZGU7IHRvIGRpc2FibGUgc2V0IGBrZWVwU2NhbGFyYCB0b1xuICAgICAqIGB0cnVlYCAoY29sbGVjdGlvbnMgYXJlIGFsd2F5cyByZXR1cm5lZCBpbnRhY3QpLlxuICAgICAqL1xuICAgIGdldChrZXksIGtlZXBTY2FsYXIpIHtcbiAgICAgICAgcmV0dXJuIGlzQ29sbGVjdGlvbih0aGlzLmNvbnRlbnRzKVxuICAgICAgICAgICAgPyB0aGlzLmNvbnRlbnRzLmdldChrZXksIGtlZXBTY2FsYXIpXG4gICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBpdGVtIGF0IGBwYXRoYCwgb3IgYHVuZGVmaW5lZGAgaWYgbm90IGZvdW5kLiBCeSBkZWZhdWx0IHVud3JhcHNcbiAgICAgKiBzY2FsYXIgdmFsdWVzIGZyb20gdGhlaXIgc3Vycm91bmRpbmcgbm9kZTsgdG8gZGlzYWJsZSBzZXQgYGtlZXBTY2FsYXJgIHRvXG4gICAgICogYHRydWVgIChjb2xsZWN0aW9ucyBhcmUgYWx3YXlzIHJldHVybmVkIGludGFjdCkuXG4gICAgICovXG4gICAgZ2V0SW4ocGF0aCwga2VlcFNjYWxhcikge1xuICAgICAgICBpZiAoaXNFbXB0eVBhdGgocGF0aCkpXG4gICAgICAgICAgICByZXR1cm4gIWtlZXBTY2FsYXIgJiYgaXNTY2FsYXIodGhpcy5jb250ZW50cylcbiAgICAgICAgICAgICAgICA/IHRoaXMuY29udGVudHMudmFsdWVcbiAgICAgICAgICAgICAgICA6IHRoaXMuY29udGVudHM7XG4gICAgICAgIHJldHVybiBpc0NvbGxlY3Rpb24odGhpcy5jb250ZW50cylcbiAgICAgICAgICAgID8gdGhpcy5jb250ZW50cy5nZXRJbihwYXRoLCBrZWVwU2NhbGFyKVxuICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGUgZG9jdW1lbnQgaW5jbHVkZXMgYSB2YWx1ZSB3aXRoIHRoZSBrZXkgYGtleWAuXG4gICAgICovXG4gICAgaGFzKGtleSkge1xuICAgICAgICByZXR1cm4gaXNDb2xsZWN0aW9uKHRoaXMuY29udGVudHMpID8gdGhpcy5jb250ZW50cy5oYXMoa2V5KSA6IGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGhlIGRvY3VtZW50IGluY2x1ZGVzIGEgdmFsdWUgYXQgYHBhdGhgLlxuICAgICAqL1xuICAgIGhhc0luKHBhdGgpIHtcbiAgICAgICAgaWYgKGlzRW1wdHlQYXRoKHBhdGgpKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udGVudHMgIT09IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIGlzQ29sbGVjdGlvbih0aGlzLmNvbnRlbnRzKSA/IHRoaXMuY29udGVudHMuaGFzSW4ocGF0aCkgOiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyBhIHZhbHVlIGluIHRoaXMgZG9jdW1lbnQuIEZvciBgISFzZXRgLCBgdmFsdWVgIG5lZWRzIHRvIGJlIGFcbiAgICAgKiBib29sZWFuIHRvIGFkZC9yZW1vdmUgdGhlIGl0ZW0gZnJvbSB0aGUgc2V0LlxuICAgICAqL1xuICAgIHNldChrZXksIHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbnRlbnRzID09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuY29udGVudHMgPSBjb2xsZWN0aW9uRnJvbVBhdGgodGhpcy5zY2hlbWEsIFtrZXldLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYXNzZXJ0Q29sbGVjdGlvbih0aGlzLmNvbnRlbnRzKSkge1xuICAgICAgICAgICAgdGhpcy5jb250ZW50cy5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyBhIHZhbHVlIGluIHRoaXMgZG9jdW1lbnQuIEZvciBgISFzZXRgLCBgdmFsdWVgIG5lZWRzIHRvIGJlIGFcbiAgICAgKiBib29sZWFuIHRvIGFkZC9yZW1vdmUgdGhlIGl0ZW0gZnJvbSB0aGUgc2V0LlxuICAgICAqL1xuICAgIHNldEluKHBhdGgsIHZhbHVlKSB7XG4gICAgICAgIGlmIChpc0VtcHR5UGF0aChwYXRoKSlcbiAgICAgICAgICAgIHRoaXMuY29udGVudHMgPSB2YWx1ZTtcbiAgICAgICAgZWxzZSBpZiAodGhpcy5jb250ZW50cyA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRlbnRzID0gY29sbGVjdGlvbkZyb21QYXRoKHRoaXMuc2NoZW1hLCBBcnJheS5mcm9tKHBhdGgpLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYXNzZXJ0Q29sbGVjdGlvbih0aGlzLmNvbnRlbnRzKSkge1xuICAgICAgICAgICAgdGhpcy5jb250ZW50cy5zZXRJbihwYXRoLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hhbmdlIHRoZSBZQU1MIHZlcnNpb24gYW5kIHNjaGVtYSB1c2VkIGJ5IHRoZSBkb2N1bWVudC5cbiAgICAgKiBBIGBudWxsYCB2ZXJzaW9uIGRpc2FibGVzIHN1cHBvcnQgZm9yIGRpcmVjdGl2ZXMsIGV4cGxpY2l0IHRhZ3MsIGFuY2hvcnMsIGFuZCBhbGlhc2VzLlxuICAgICAqIEl0IGFsc28gcmVxdWlyZXMgdGhlIGBzY2hlbWFgIG9wdGlvbiB0byBiZSBnaXZlbiBhcyBhIGBTY2hlbWFgIGluc3RhbmNlIHZhbHVlLlxuICAgICAqXG4gICAgICogT3ZlcnJpZGVzIGFsbCBwcmV2aW91c2x5IHNldCBzY2hlbWEgb3B0aW9ucy5cbiAgICAgKi9cbiAgICBzZXRTY2hlbWEodmVyc2lvbiwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmVyc2lvbiA9PT0gJ251bWJlcicpXG4gICAgICAgICAgICB2ZXJzaW9uID0gU3RyaW5nKHZlcnNpb24pO1xuICAgICAgICBsZXQgb3B0O1xuICAgICAgICBzd2l0Y2ggKHZlcnNpb24pIHtcbiAgICAgICAgICAgIGNhc2UgJzEuMSc6XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZGlyZWN0aXZlcylcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXJlY3RpdmVzLnlhbWwudmVyc2lvbiA9ICcxLjEnO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXJlY3RpdmVzID0gbmV3IERpcmVjdGl2ZXMoeyB2ZXJzaW9uOiAnMS4xJyB9KTtcbiAgICAgICAgICAgICAgICBvcHQgPSB7IG1lcmdlOiB0cnVlLCByZXNvbHZlS25vd25UYWdzOiBmYWxzZSwgc2NoZW1hOiAneWFtbC0xLjEnIH07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICcxLjInOlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmRpcmVjdGl2ZXMpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlyZWN0aXZlcy55YW1sLnZlcnNpb24gPSAnMS4yJztcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlyZWN0aXZlcyA9IG5ldyBEaXJlY3RpdmVzKHsgdmVyc2lvbjogJzEuMicgfSk7XG4gICAgICAgICAgICAgICAgb3B0ID0geyBtZXJnZTogZmFsc2UsIHJlc29sdmVLbm93blRhZ3M6IHRydWUsIHNjaGVtYTogJ2NvcmUnIH07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIG51bGw6XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZGlyZWN0aXZlcylcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuZGlyZWN0aXZlcztcbiAgICAgICAgICAgICAgICBvcHQgPSBudWxsO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN2ID0gSlNPTi5zdHJpbmdpZnkodmVyc2lvbik7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCAnMS4xJywgJzEuMicgb3IgbnVsbCBhcyBmaXJzdCBhcmd1bWVudCwgYnV0IGZvdW5kOiAke3N2fWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIE5vdCB1c2luZyBgaW5zdGFuY2VvZiBTY2hlbWFgIHRvIGFsbG93IGZvciBkdWNrIHR5cGluZ1xuICAgICAgICBpZiAob3B0aW9ucy5zY2hlbWEgaW5zdGFuY2VvZiBPYmplY3QpXG4gICAgICAgICAgICB0aGlzLnNjaGVtYSA9IG9wdGlvbnMuc2NoZW1hO1xuICAgICAgICBlbHNlIGlmIChvcHQpXG4gICAgICAgICAgICB0aGlzLnNjaGVtYSA9IG5ldyBTY2hlbWEoT2JqZWN0LmFzc2lnbihvcHQsIG9wdGlvbnMpKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBXaXRoIGEgbnVsbCBZQU1MIHZlcnNpb24sIHRoZSB7IHNjaGVtYTogU2NoZW1hIH0gb3B0aW9uIGlzIHJlcXVpcmVkYCk7XG4gICAgfVxuICAgIC8vIGpzb24gJiBqc29uQXJnIGFyZSBvbmx5IHVzZWQgZnJvbSB0b0pTT04oKVxuICAgIHRvSlMoeyBqc29uLCBqc29uQXJnLCBtYXBBc01hcCwgbWF4QWxpYXNDb3VudCwgb25BbmNob3IsIHJldml2ZXIgfSA9IHt9KSB7XG4gICAgICAgIGNvbnN0IGN0eCA9IHtcbiAgICAgICAgICAgIGFuY2hvcnM6IG5ldyBNYXAoKSxcbiAgICAgICAgICAgIGRvYzogdGhpcyxcbiAgICAgICAgICAgIGtlZXA6ICFqc29uLFxuICAgICAgICAgICAgbWFwQXNNYXA6IG1hcEFzTWFwID09PSB0cnVlLFxuICAgICAgICAgICAgbWFwS2V5V2FybmVkOiBmYWxzZSxcbiAgICAgICAgICAgIG1heEFsaWFzQ291bnQ6IHR5cGVvZiBtYXhBbGlhc0NvdW50ID09PSAnbnVtYmVyJyA/IG1heEFsaWFzQ291bnQgOiAxMDAsXG4gICAgICAgICAgICBzdHJpbmdpZnlcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcmVzID0gdG9KUyh0aGlzLmNvbnRlbnRzLCBqc29uQXJnIHx8ICcnLCBjdHgpO1xuICAgICAgICBpZiAodHlwZW9mIG9uQW5jaG9yID09PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgZm9yIChjb25zdCB7IGNvdW50LCByZXMgfSBvZiBjdHguYW5jaG9ycy52YWx1ZXMoKSlcbiAgICAgICAgICAgICAgICBvbkFuY2hvcihyZXMsIGNvdW50KTtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiByZXZpdmVyID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgICA/IGFwcGx5UmV2aXZlcihyZXZpdmVyLCB7ICcnOiByZXMgfSwgJycsIHJlcylcbiAgICAgICAgICAgIDogcmVzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIEpTT04gcmVwcmVzZW50YXRpb24gb2YgdGhlIGRvY3VtZW50IGBjb250ZW50c2AuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ganNvbkFyZyBVc2VkIGJ5IGBKU09OLnN0cmluZ2lmeWAgdG8gaW5kaWNhdGUgdGhlIGFycmF5IGluZGV4IG9yXG4gICAgICogICBwcm9wZXJ0eSBuYW1lLlxuICAgICAqL1xuICAgIHRvSlNPTihqc29uQXJnLCBvbkFuY2hvcikge1xuICAgICAgICByZXR1cm4gdGhpcy50b0pTKHsganNvbjogdHJ1ZSwganNvbkFyZywgbWFwQXNNYXA6IGZhbHNlLCBvbkFuY2hvciB9KTtcbiAgICB9XG4gICAgLyoqIEEgWUFNTCByZXByZXNlbnRhdGlvbiBvZiB0aGUgZG9jdW1lbnQuICovXG4gICAgdG9TdHJpbmcob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGlmICh0aGlzLmVycm9ycy5sZW5ndGggPiAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEb2N1bWVudCB3aXRoIGVycm9ycyBjYW5ub3QgYmUgc3RyaW5naWZpZWQnKTtcbiAgICAgICAgaWYgKCdpbmRlbnQnIGluIG9wdGlvbnMgJiZcbiAgICAgICAgICAgICghTnVtYmVyLmlzSW50ZWdlcihvcHRpb25zLmluZGVudCkgfHwgTnVtYmVyKG9wdGlvbnMuaW5kZW50KSA8PSAwKSkge1xuICAgICAgICAgICAgY29uc3QgcyA9IEpTT04uc3RyaW5naWZ5KG9wdGlvbnMuaW5kZW50KTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgXCJpbmRlbnRcIiBvcHRpb24gbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXIsIG5vdCAke3N9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0cmluZ2lmeURvY3VtZW50KHRoaXMsIG9wdGlvbnMpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGFzc2VydENvbGxlY3Rpb24oY29udGVudHMpIHtcbiAgICBpZiAoaXNDb2xsZWN0aW9uKGNvbnRlbnRzKSlcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBhIFlBTUwgY29sbGVjdGlvbiBhcyBkb2N1bWVudCBjb250ZW50cycpO1xufVxuXG5leHBvcnQgeyBEb2N1bWVudCB9O1xuIiwgImNsYXNzIFlBTUxFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihuYW1lLCBwb3MsIGNvZGUsIG1lc3NhZ2UpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5jb2RlID0gY29kZTtcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICAgICAgdGhpcy5wb3MgPSBwb3M7XG4gICAgfVxufVxuY2xhc3MgWUFNTFBhcnNlRXJyb3IgZXh0ZW5kcyBZQU1MRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHBvcywgY29kZSwgbWVzc2FnZSkge1xuICAgICAgICBzdXBlcignWUFNTFBhcnNlRXJyb3InLCBwb3MsIGNvZGUsIG1lc3NhZ2UpO1xuICAgIH1cbn1cbmNsYXNzIFlBTUxXYXJuaW5nIGV4dGVuZHMgWUFNTEVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcihwb3MsIGNvZGUsIG1lc3NhZ2UpIHtcbiAgICAgICAgc3VwZXIoJ1lBTUxXYXJuaW5nJywgcG9zLCBjb2RlLCBtZXNzYWdlKTtcbiAgICB9XG59XG5jb25zdCBwcmV0dGlmeUVycm9yID0gKHNyYywgbGMpID0+IChlcnJvcikgPT4ge1xuICAgIGlmIChlcnJvci5wb3NbMF0gPT09IC0xKVxuICAgICAgICByZXR1cm47XG4gICAgZXJyb3IubGluZVBvcyA9IGVycm9yLnBvcy5tYXAocG9zID0+IGxjLmxpbmVQb3MocG9zKSk7XG4gICAgY29uc3QgeyBsaW5lLCBjb2wgfSA9IGVycm9yLmxpbmVQb3NbMF07XG4gICAgZXJyb3IubWVzc2FnZSArPSBgIGF0IGxpbmUgJHtsaW5lfSwgY29sdW1uICR7Y29sfWA7XG4gICAgbGV0IGNpID0gY29sIC0gMTtcbiAgICBsZXQgbGluZVN0ciA9IHNyY1xuICAgICAgICAuc3Vic3RyaW5nKGxjLmxpbmVTdGFydHNbbGluZSAtIDFdLCBsYy5saW5lU3RhcnRzW2xpbmVdKVxuICAgICAgICAucmVwbGFjZSgvW1xcblxccl0rJC8sICcnKTtcbiAgICAvLyBUcmltIHRvIG1heCA4MCBjaGFycywga2VlcGluZyBjb2wgcG9zaXRpb24gbmVhciB0aGUgbWlkZGxlXG4gICAgaWYgKGNpID49IDYwICYmIGxpbmVTdHIubGVuZ3RoID4gODApIHtcbiAgICAgICAgY29uc3QgdHJpbVN0YXJ0ID0gTWF0aC5taW4oY2kgLSAzOSwgbGluZVN0ci5sZW5ndGggLSA3OSk7XG4gICAgICAgIGxpbmVTdHIgPSAnXHUyMDI2JyArIGxpbmVTdHIuc3Vic3RyaW5nKHRyaW1TdGFydCk7XG4gICAgICAgIGNpIC09IHRyaW1TdGFydCAtIDE7XG4gICAgfVxuICAgIGlmIChsaW5lU3RyLmxlbmd0aCA+IDgwKVxuICAgICAgICBsaW5lU3RyID0gbGluZVN0ci5zdWJzdHJpbmcoMCwgNzkpICsgJ1x1MjAyNic7XG4gICAgLy8gSW5jbHVkZSBwcmV2aW91cyBsaW5lIGluIGNvbnRleHQgaWYgcG9pbnRpbmcgYXQgbGluZSBzdGFydFxuICAgIGlmIChsaW5lID4gMSAmJiAvXiAqJC8udGVzdChsaW5lU3RyLnN1YnN0cmluZygwLCBjaSkpKSB7XG4gICAgICAgIC8vIFJlZ2V4cCB3b24ndCBtYXRjaCBpZiBzdGFydCBpcyB0cmltbWVkXG4gICAgICAgIGxldCBwcmV2ID0gc3JjLnN1YnN0cmluZyhsYy5saW5lU3RhcnRzW2xpbmUgLSAyXSwgbGMubGluZVN0YXJ0c1tsaW5lIC0gMV0pO1xuICAgICAgICBpZiAocHJldi5sZW5ndGggPiA4MClcbiAgICAgICAgICAgIHByZXYgPSBwcmV2LnN1YnN0cmluZygwLCA3OSkgKyAnXHUyMDI2XFxuJztcbiAgICAgICAgbGluZVN0ciA9IHByZXYgKyBsaW5lU3RyO1xuICAgIH1cbiAgICBpZiAoL1teIF0vLnRlc3QobGluZVN0cikpIHtcbiAgICAgICAgbGV0IGNvdW50ID0gMTtcbiAgICAgICAgY29uc3QgZW5kID0gZXJyb3IubGluZVBvc1sxXTtcbiAgICAgICAgaWYgKGVuZCAmJiBlbmQubGluZSA9PT0gbGluZSAmJiBlbmQuY29sID4gY29sKSB7XG4gICAgICAgICAgICBjb3VudCA9IE1hdGgubWluKGVuZC5jb2wgLSBjb2wsIDgwIC0gY2kpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBvaW50ZXIgPSAnICcucmVwZWF0KGNpKSArICdeJy5yZXBlYXQoY291bnQpO1xuICAgICAgICBlcnJvci5tZXNzYWdlICs9IGA6XFxuXFxuJHtsaW5lU3RyfVxcbiR7cG9pbnRlcn1cXG5gO1xuICAgIH1cbn07XG5cbmV4cG9ydCB7IFlBTUxFcnJvciwgWUFNTFBhcnNlRXJyb3IsIFlBTUxXYXJuaW5nLCBwcmV0dGlmeUVycm9yIH07XG4iLCAiZnVuY3Rpb24gcmVzb2x2ZVByb3BzKHRva2VucywgeyBmbG93LCBpbmRpY2F0b3IsIG5leHQsIG9mZnNldCwgb25FcnJvciwgc3RhcnRPbk5ld2xpbmUgfSkge1xuICAgIGxldCBzcGFjZUJlZm9yZSA9IGZhbHNlO1xuICAgIGxldCBhdE5ld2xpbmUgPSBzdGFydE9uTmV3bGluZTtcbiAgICBsZXQgaGFzU3BhY2UgPSBzdGFydE9uTmV3bGluZTtcbiAgICBsZXQgY29tbWVudCA9ICcnO1xuICAgIGxldCBjb21tZW50U2VwID0gJyc7XG4gICAgbGV0IGhhc05ld2xpbmUgPSBmYWxzZTtcbiAgICBsZXQgcmVxU3BhY2UgPSBmYWxzZTtcbiAgICBsZXQgYW5jaG9yID0gbnVsbDtcbiAgICBsZXQgdGFnID0gbnVsbDtcbiAgICBsZXQgY29tbWEgPSBudWxsO1xuICAgIGxldCBmb3VuZCA9IG51bGw7XG4gICAgbGV0IHN0YXJ0ID0gbnVsbDtcbiAgICBmb3IgKGNvbnN0IHRva2VuIG9mIHRva2Vucykge1xuICAgICAgICBpZiAocmVxU3BhY2UpIHtcbiAgICAgICAgICAgIGlmICh0b2tlbi50eXBlICE9PSAnc3BhY2UnICYmXG4gICAgICAgICAgICAgICAgdG9rZW4udHlwZSAhPT0gJ25ld2xpbmUnICYmXG4gICAgICAgICAgICAgICAgdG9rZW4udHlwZSAhPT0gJ2NvbW1hJylcbiAgICAgICAgICAgICAgICBvbkVycm9yKHRva2VuLm9mZnNldCwgJ01JU1NJTkdfQ0hBUicsICdUYWdzIGFuZCBhbmNob3JzIG11c3QgYmUgc2VwYXJhdGVkIGZyb20gdGhlIG5leHQgdG9rZW4gYnkgd2hpdGUgc3BhY2UnKTtcbiAgICAgICAgICAgIHJlcVNwYWNlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoICh0b2tlbi50eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdzcGFjZSc6XG4gICAgICAgICAgICAgICAgLy8gQXQgdGhlIGRvYyBsZXZlbCwgdGFicyBhdCBsaW5lIHN0YXJ0IG1heSBiZSBwYXJzZWRcbiAgICAgICAgICAgICAgICAvLyBhcyBsZWFkaW5nIHdoaXRlIHNwYWNlIHJhdGhlciB0aGFuIGluZGVudGF0aW9uLlxuICAgICAgICAgICAgICAgIC8vIEluIGEgZmxvdyBjb2xsZWN0aW9uLCBvbmx5IHRoZSBwYXJzZXIgaGFuZGxlcyBpbmRlbnQuXG4gICAgICAgICAgICAgICAgaWYgKCFmbG93ICYmXG4gICAgICAgICAgICAgICAgICAgIGF0TmV3bGluZSAmJlxuICAgICAgICAgICAgICAgICAgICBpbmRpY2F0b3IgIT09ICdkb2Mtc3RhcnQnICYmXG4gICAgICAgICAgICAgICAgICAgIHRva2VuLnNvdXJjZVswXSA9PT0gJ1xcdCcpXG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3IodG9rZW4sICdUQUJfQVNfSU5ERU5UJywgJ1RhYnMgYXJlIG5vdCBhbGxvd2VkIGFzIGluZGVudGF0aW9uJyk7XG4gICAgICAgICAgICAgICAgaGFzU3BhY2UgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnY29tbWVudCc6IHtcbiAgICAgICAgICAgICAgICBpZiAoIWhhc1NwYWNlKVxuICAgICAgICAgICAgICAgICAgICBvbkVycm9yKHRva2VuLCAnTUlTU0lOR19DSEFSJywgJ0NvbW1lbnRzIG11c3QgYmUgc2VwYXJhdGVkIGZyb20gb3RoZXIgdG9rZW5zIGJ5IHdoaXRlIHNwYWNlIGNoYXJhY3RlcnMnKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjYiA9IHRva2VuLnNvdXJjZS5zdWJzdHJpbmcoMSkgfHwgJyAnO1xuICAgICAgICAgICAgICAgIGlmICghY29tbWVudClcbiAgICAgICAgICAgICAgICAgICAgY29tbWVudCA9IGNiO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgY29tbWVudCArPSBjb21tZW50U2VwICsgY2I7XG4gICAgICAgICAgICAgICAgY29tbWVudFNlcCA9ICcnO1xuICAgICAgICAgICAgICAgIGF0TmV3bGluZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnbmV3bGluZSc6XG4gICAgICAgICAgICAgICAgaWYgKGF0TmV3bGluZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29tbWVudClcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1lbnQgKz0gdG9rZW4uc291cmNlO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBzcGFjZUJlZm9yZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgY29tbWVudFNlcCArPSB0b2tlbi5zb3VyY2U7XG4gICAgICAgICAgICAgICAgYXROZXdsaW5lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBoYXNOZXdsaW5lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBoYXNTcGFjZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdhbmNob3InOlxuICAgICAgICAgICAgICAgIGlmIChhbmNob3IpXG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3IodG9rZW4sICdNVUxUSVBMRV9BTkNIT1JTJywgJ0Egbm9kZSBjYW4gaGF2ZSBhdCBtb3N0IG9uZSBhbmNob3InKTtcbiAgICAgICAgICAgICAgICBhbmNob3IgPSB0b2tlbjtcbiAgICAgICAgICAgICAgICBpZiAoc3RhcnQgPT09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gdG9rZW4ub2Zmc2V0O1xuICAgICAgICAgICAgICAgIGF0TmV3bGluZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGhhc1NwYWNlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcmVxU3BhY2UgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAndGFnJzoge1xuICAgICAgICAgICAgICAgIGlmICh0YWcpXG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3IodG9rZW4sICdNVUxUSVBMRV9UQUdTJywgJ0Egbm9kZSBjYW4gaGF2ZSBhdCBtb3N0IG9uZSB0YWcnKTtcbiAgICAgICAgICAgICAgICB0YWcgPSB0b2tlbjtcbiAgICAgICAgICAgICAgICBpZiAoc3RhcnQgPT09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gdG9rZW4ub2Zmc2V0O1xuICAgICAgICAgICAgICAgIGF0TmV3bGluZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGhhc1NwYWNlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcmVxU3BhY2UgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBpbmRpY2F0b3I6XG4gICAgICAgICAgICAgICAgLy8gQ291bGQgaGVyZSBoYW5kbGUgcHJlY2VkaW5nIGNvbW1lbnRzIGRpZmZlcmVudGx5XG4gICAgICAgICAgICAgICAgaWYgKGFuY2hvciB8fCB0YWcpXG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3IodG9rZW4sICdCQURfUFJPUF9PUkRFUicsIGBBbmNob3JzIGFuZCB0YWdzIG11c3QgYmUgYWZ0ZXIgdGhlICR7dG9rZW4uc291cmNlfSBpbmRpY2F0b3JgKTtcbiAgICAgICAgICAgICAgICBpZiAoZm91bmQpXG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3IodG9rZW4sICdVTkVYUEVDVEVEX1RPS0VOJywgYFVuZXhwZWN0ZWQgJHt0b2tlbi5zb3VyY2V9IGluICR7ZmxvdyB8fCAnY29sbGVjdGlvbid9YCk7XG4gICAgICAgICAgICAgICAgZm91bmQgPSB0b2tlbjtcbiAgICAgICAgICAgICAgICBhdE5ld2xpbmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBoYXNTcGFjZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnY29tbWEnOlxuICAgICAgICAgICAgICAgIGlmIChmbG93KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb21tYSlcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uRXJyb3IodG9rZW4sICdVTkVYUEVDVEVEX1RPS0VOJywgYFVuZXhwZWN0ZWQgLCBpbiAke2Zsb3d9YCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbW1hID0gdG9rZW47XG4gICAgICAgICAgICAgICAgICAgIGF0TmV3bGluZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBoYXNTcGFjZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBlbHNlIGZhbGx0aHJvdWdoXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIG9uRXJyb3IodG9rZW4sICdVTkVYUEVDVEVEX1RPS0VOJywgYFVuZXhwZWN0ZWQgJHt0b2tlbi50eXBlfSB0b2tlbmApO1xuICAgICAgICAgICAgICAgIGF0TmV3bGluZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGhhc1NwYWNlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgbGFzdCA9IHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV07XG4gICAgY29uc3QgZW5kID0gbGFzdCA/IGxhc3Qub2Zmc2V0ICsgbGFzdC5zb3VyY2UubGVuZ3RoIDogb2Zmc2V0O1xuICAgIGlmIChyZXFTcGFjZSAmJlxuICAgICAgICBuZXh0ICYmXG4gICAgICAgIG5leHQudHlwZSAhPT0gJ3NwYWNlJyAmJlxuICAgICAgICBuZXh0LnR5cGUgIT09ICduZXdsaW5lJyAmJlxuICAgICAgICBuZXh0LnR5cGUgIT09ICdjb21tYScgJiZcbiAgICAgICAgKG5leHQudHlwZSAhPT0gJ3NjYWxhcicgfHwgbmV4dC5zb3VyY2UgIT09ICcnKSlcbiAgICAgICAgb25FcnJvcihuZXh0Lm9mZnNldCwgJ01JU1NJTkdfQ0hBUicsICdUYWdzIGFuZCBhbmNob3JzIG11c3QgYmUgc2VwYXJhdGVkIGZyb20gdGhlIG5leHQgdG9rZW4gYnkgd2hpdGUgc3BhY2UnKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBjb21tYSxcbiAgICAgICAgZm91bmQsXG4gICAgICAgIHNwYWNlQmVmb3JlLFxuICAgICAgICBjb21tZW50LFxuICAgICAgICBoYXNOZXdsaW5lLFxuICAgICAgICBhbmNob3IsXG4gICAgICAgIHRhZyxcbiAgICAgICAgZW5kLFxuICAgICAgICBzdGFydDogc3RhcnQgIT09IG51bGwgJiYgc3RhcnQgIT09IHZvaWQgMCA/IHN0YXJ0IDogZW5kXG4gICAgfTtcbn1cblxuZXhwb3J0IHsgcmVzb2x2ZVByb3BzIH07XG4iLCAiZnVuY3Rpb24gY29udGFpbnNOZXdsaW5lKGtleSkge1xuICAgIGlmICgha2V5KVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBzd2l0Y2ggKGtleS50eXBlKSB7XG4gICAgICAgIGNhc2UgJ2FsaWFzJzpcbiAgICAgICAgY2FzZSAnc2NhbGFyJzpcbiAgICAgICAgY2FzZSAnZG91YmxlLXF1b3RlZC1zY2FsYXInOlxuICAgICAgICBjYXNlICdzaW5nbGUtcXVvdGVkLXNjYWxhcic6XG4gICAgICAgICAgICBpZiAoa2V5LnNvdXJjZS5pbmNsdWRlcygnXFxuJykpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBpZiAoa2V5LmVuZClcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHN0IG9mIGtleS5lbmQpXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdC50eXBlID09PSAnbmV3bGluZScpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgY2FzZSAnZmxvdy1jb2xsZWN0aW9uJzpcbiAgICAgICAgICAgIGZvciAoY29uc3QgaXQgb2Yga2V5Lml0ZW1zKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBzdCBvZiBpdC5zdGFydClcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0LnR5cGUgPT09ICduZXdsaW5lJylcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIGlmIChpdC5zZXApXG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3Qgc3Qgb2YgaXQuc2VwKVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0LnR5cGUgPT09ICduZXdsaW5lJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAoY29udGFpbnNOZXdsaW5lKGl0LmtleSkgfHwgY29udGFpbnNOZXdsaW5lKGl0LnZhbHVlKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59XG5cbmV4cG9ydCB7IGNvbnRhaW5zTmV3bGluZSB9O1xuIiwgImltcG9ydCB7IGNvbnRhaW5zTmV3bGluZSB9IGZyb20gJy4vdXRpbC1jb250YWlucy1uZXdsaW5lLmpzJztcblxuZnVuY3Rpb24gZmxvd0luZGVudENoZWNrKGluZGVudCwgZmMsIG9uRXJyb3IpIHtcbiAgICBpZiAoKGZjID09PSBudWxsIHx8IGZjID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmYy50eXBlKSA9PT0gJ2Zsb3ctY29sbGVjdGlvbicpIHtcbiAgICAgICAgY29uc3QgZW5kID0gZmMuZW5kWzBdO1xuICAgICAgICBpZiAoZW5kLmluZGVudCA9PT0gaW5kZW50ICYmXG4gICAgICAgICAgICAoZW5kLnNvdXJjZSA9PT0gJ10nIHx8IGVuZC5zb3VyY2UgPT09ICd9JykgJiZcbiAgICAgICAgICAgIGNvbnRhaW5zTmV3bGluZShmYykpIHtcbiAgICAgICAgICAgIGNvbnN0IG1zZyA9ICdGbG93IGVuZCBpbmRpY2F0b3Igc2hvdWxkIGJlIG1vcmUgaW5kZW50ZWQgdGhhbiBwYXJlbnQnO1xuICAgICAgICAgICAgb25FcnJvcihlbmQsICdCQURfSU5ERU5UJywgbXNnLCB0cnVlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IHsgZmxvd0luZGVudENoZWNrIH07XG4iLCAiaW1wb3J0IHsgaXNTY2FsYXIgfSBmcm9tICcuLi9ub2Rlcy9Ob2RlLmpzJztcblxuZnVuY3Rpb24gbWFwSW5jbHVkZXMoY3R4LCBpdGVtcywgc2VhcmNoKSB7XG4gICAgY29uc3QgeyB1bmlxdWVLZXlzIH0gPSBjdHgub3B0aW9ucztcbiAgICBpZiAodW5pcXVlS2V5cyA9PT0gZmFsc2UpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCBpc0VxdWFsID0gdHlwZW9mIHVuaXF1ZUtleXMgPT09ICdmdW5jdGlvbidcbiAgICAgICAgPyB1bmlxdWVLZXlzXG4gICAgICAgIDogKGEsIGIpID0+IGEgPT09IGIgfHxcbiAgICAgICAgICAgIChpc1NjYWxhcihhKSAmJlxuICAgICAgICAgICAgICAgIGlzU2NhbGFyKGIpICYmXG4gICAgICAgICAgICAgICAgYS52YWx1ZSA9PT0gYi52YWx1ZSAmJlxuICAgICAgICAgICAgICAgICEoYS52YWx1ZSA9PT0gJzw8JyAmJiBjdHguc2NoZW1hLm1lcmdlKSk7XG4gICAgcmV0dXJuIGl0ZW1zLnNvbWUocGFpciA9PiBpc0VxdWFsKHBhaXIua2V5LCBzZWFyY2gpKTtcbn1cblxuZXhwb3J0IHsgbWFwSW5jbHVkZXMgfTtcbiIsICJpbXBvcnQgeyBQYWlyIH0gZnJvbSAnLi4vbm9kZXMvUGFpci5qcyc7XG5pbXBvcnQgeyBZQU1MTWFwIH0gZnJvbSAnLi4vbm9kZXMvWUFNTE1hcC5qcyc7XG5pbXBvcnQgeyByZXNvbHZlUHJvcHMgfSBmcm9tICcuL3Jlc29sdmUtcHJvcHMuanMnO1xuaW1wb3J0IHsgY29udGFpbnNOZXdsaW5lIH0gZnJvbSAnLi91dGlsLWNvbnRhaW5zLW5ld2xpbmUuanMnO1xuaW1wb3J0IHsgZmxvd0luZGVudENoZWNrIH0gZnJvbSAnLi91dGlsLWZsb3ctaW5kZW50LWNoZWNrLmpzJztcbmltcG9ydCB7IG1hcEluY2x1ZGVzIH0gZnJvbSAnLi91dGlsLW1hcC1pbmNsdWRlcy5qcyc7XG5cbmNvbnN0IHN0YXJ0Q29sTXNnID0gJ0FsbCBtYXBwaW5nIGl0ZW1zIG11c3Qgc3RhcnQgYXQgdGhlIHNhbWUgY29sdW1uJztcbmZ1bmN0aW9uIHJlc29sdmVCbG9ja01hcCh7IGNvbXBvc2VOb2RlLCBjb21wb3NlRW1wdHlOb2RlIH0sIGN0eCwgYm0sIG9uRXJyb3IpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgbWFwID0gbmV3IFlBTUxNYXAoY3R4LnNjaGVtYSk7XG4gICAgaWYgKGN0eC5hdFJvb3QpXG4gICAgICAgIGN0eC5hdFJvb3QgPSBmYWxzZTtcbiAgICBsZXQgb2Zmc2V0ID0gYm0ub2Zmc2V0O1xuICAgIGZvciAoY29uc3QgY29sbEl0ZW0gb2YgYm0uaXRlbXMpIHtcbiAgICAgICAgY29uc3QgeyBzdGFydCwga2V5LCBzZXAsIHZhbHVlIH0gPSBjb2xsSXRlbTtcbiAgICAgICAgLy8ga2V5IHByb3BlcnRpZXNcbiAgICAgICAgY29uc3Qga2V5UHJvcHMgPSByZXNvbHZlUHJvcHMoc3RhcnQsIHtcbiAgICAgICAgICAgIGluZGljYXRvcjogJ2V4cGxpY2l0LWtleS1pbmQnLFxuICAgICAgICAgICAgbmV4dDoga2V5IHx8IChzZXAgPT09IG51bGwgfHwgc2VwID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzZXBbMF0pLFxuICAgICAgICAgICAgb2Zmc2V0LFxuICAgICAgICAgICAgb25FcnJvcixcbiAgICAgICAgICAgIHN0YXJ0T25OZXdsaW5lOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBpbXBsaWNpdEtleSA9ICFrZXlQcm9wcy5mb3VuZDtcbiAgICAgICAgaWYgKGltcGxpY2l0S2V5KSB7XG4gICAgICAgICAgICBpZiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgaWYgKGtleS50eXBlID09PSAnYmxvY2stc2VxJylcbiAgICAgICAgICAgICAgICAgICAgb25FcnJvcihvZmZzZXQsICdCTE9DS19BU19JTVBMSUNJVF9LRVknLCAnQSBibG9jayBzZXF1ZW5jZSBtYXkgbm90IGJlIHVzZWQgYXMgYW4gaW1wbGljaXQgbWFwIGtleScpO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCdpbmRlbnQnIGluIGtleSAmJiBrZXkuaW5kZW50ICE9PSBibS5pbmRlbnQpXG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3Iob2Zmc2V0LCAnQkFEX0lOREVOVCcsIHN0YXJ0Q29sTXNnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgha2V5UHJvcHMuYW5jaG9yICYmICFrZXlQcm9wcy50YWcgJiYgIXNlcCkge1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IGFzc2VydCBiZWluZyBhdCBsYXN0IGl0ZW0/XG4gICAgICAgICAgICAgICAgaWYgKGtleVByb3BzLmNvbW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hcC5jb21tZW50KVxuICAgICAgICAgICAgICAgICAgICAgICAgbWFwLmNvbW1lbnQgKz0gJ1xcbicgKyBrZXlQcm9wcy5jb21tZW50O1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXAuY29tbWVudCA9IGtleVByb3BzLmNvbW1lbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCgoX2EgPSBrZXlQcm9wcy5mb3VuZCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmluZGVudCkgIT09IGJtLmluZGVudClcbiAgICAgICAgICAgIG9uRXJyb3Iob2Zmc2V0LCAnQkFEX0lOREVOVCcsIHN0YXJ0Q29sTXNnKTtcbiAgICAgICAgaWYgKGltcGxpY2l0S2V5ICYmIGNvbnRhaW5zTmV3bGluZShrZXkpKVxuICAgICAgICAgICAgb25FcnJvcihrZXksIC8vIGNoZWNrZWQgYnkgY29udGFpbnNOZXdsaW5lKClcbiAgICAgICAgICAgICdNVUxUSUxJTkVfSU1QTElDSVRfS0VZJywgJ0ltcGxpY2l0IGtleXMgbmVlZCB0byBiZSBvbiBhIHNpbmdsZSBsaW5lJyk7XG4gICAgICAgIC8vIGtleSB2YWx1ZVxuICAgICAgICBjb25zdCBrZXlTdGFydCA9IGtleVByb3BzLmVuZDtcbiAgICAgICAgY29uc3Qga2V5Tm9kZSA9IGtleVxuICAgICAgICAgICAgPyBjb21wb3NlTm9kZShjdHgsIGtleSwga2V5UHJvcHMsIG9uRXJyb3IpXG4gICAgICAgICAgICA6IGNvbXBvc2VFbXB0eU5vZGUoY3R4LCBrZXlTdGFydCwgc3RhcnQsIG51bGwsIGtleVByb3BzLCBvbkVycm9yKTtcbiAgICAgICAgaWYgKGN0eC5zY2hlbWEuY29tcGF0KVxuICAgICAgICAgICAgZmxvd0luZGVudENoZWNrKGJtLmluZGVudCwga2V5LCBvbkVycm9yKTtcbiAgICAgICAgaWYgKG1hcEluY2x1ZGVzKGN0eCwgbWFwLml0ZW1zLCBrZXlOb2RlKSlcbiAgICAgICAgICAgIG9uRXJyb3Ioa2V5U3RhcnQsICdEVVBMSUNBVEVfS0VZJywgJ01hcCBrZXlzIG11c3QgYmUgdW5pcXVlJyk7XG4gICAgICAgIC8vIHZhbHVlIHByb3BlcnRpZXNcbiAgICAgICAgY29uc3QgdmFsdWVQcm9wcyA9IHJlc29sdmVQcm9wcyhzZXAgfHwgW10sIHtcbiAgICAgICAgICAgIGluZGljYXRvcjogJ21hcC12YWx1ZS1pbmQnLFxuICAgICAgICAgICAgbmV4dDogdmFsdWUsXG4gICAgICAgICAgICBvZmZzZXQ6IGtleU5vZGUucmFuZ2VbMl0sXG4gICAgICAgICAgICBvbkVycm9yLFxuICAgICAgICAgICAgc3RhcnRPbk5ld2xpbmU6ICFrZXkgfHwga2V5LnR5cGUgPT09ICdibG9jay1zY2FsYXInXG4gICAgICAgIH0pO1xuICAgICAgICBvZmZzZXQgPSB2YWx1ZVByb3BzLmVuZDtcbiAgICAgICAgaWYgKHZhbHVlUHJvcHMuZm91bmQpIHtcbiAgICAgICAgICAgIGlmIChpbXBsaWNpdEtleSkge1xuICAgICAgICAgICAgICAgIGlmICgodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHZhbHVlLnR5cGUpID09PSAnYmxvY2stbWFwJyAmJiAhdmFsdWVQcm9wcy5oYXNOZXdsaW5lKVxuICAgICAgICAgICAgICAgICAgICBvbkVycm9yKG9mZnNldCwgJ0JMT0NLX0FTX0lNUExJQ0lUX0tFWScsICdOZXN0ZWQgbWFwcGluZ3MgYXJlIG5vdCBhbGxvd2VkIGluIGNvbXBhY3QgbWFwcGluZ3MnKTtcbiAgICAgICAgICAgICAgICBpZiAoY3R4Lm9wdGlvbnMuc3RyaWN0ICYmXG4gICAgICAgICAgICAgICAgICAgIGtleVByb3BzLnN0YXJ0IDwgdmFsdWVQcm9wcy5mb3VuZC5vZmZzZXQgLSAxMDI0KVxuICAgICAgICAgICAgICAgICAgICBvbkVycm9yKGtleU5vZGUucmFuZ2UsICdLRVlfT1ZFUl8xMDI0X0NIQVJTJywgJ1RoZSA6IGluZGljYXRvciBtdXN0IGJlIGF0IG1vc3QgMTAyNCBjaGFycyBhZnRlciB0aGUgc3RhcnQgb2YgYW4gaW1wbGljaXQgYmxvY2sgbWFwcGluZyBrZXknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHZhbHVlIHZhbHVlXG4gICAgICAgICAgICBjb25zdCB2YWx1ZU5vZGUgPSB2YWx1ZVxuICAgICAgICAgICAgICAgID8gY29tcG9zZU5vZGUoY3R4LCB2YWx1ZSwgdmFsdWVQcm9wcywgb25FcnJvcilcbiAgICAgICAgICAgICAgICA6IGNvbXBvc2VFbXB0eU5vZGUoY3R4LCBvZmZzZXQsIHNlcCwgbnVsbCwgdmFsdWVQcm9wcywgb25FcnJvcik7XG4gICAgICAgICAgICBpZiAoY3R4LnNjaGVtYS5jb21wYXQpXG4gICAgICAgICAgICAgICAgZmxvd0luZGVudENoZWNrKGJtLmluZGVudCwgdmFsdWUsIG9uRXJyb3IpO1xuICAgICAgICAgICAgb2Zmc2V0ID0gdmFsdWVOb2RlLnJhbmdlWzJdO1xuICAgICAgICAgICAgY29uc3QgcGFpciA9IG5ldyBQYWlyKGtleU5vZGUsIHZhbHVlTm9kZSk7XG4gICAgICAgICAgICBpZiAoY3R4Lm9wdGlvbnMua2VlcFNvdXJjZVRva2VucylcbiAgICAgICAgICAgICAgICBwYWlyLnNyY1Rva2VuID0gY29sbEl0ZW07XG4gICAgICAgICAgICBtYXAuaXRlbXMucHVzaChwYWlyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGtleSB3aXRoIG5vIHZhbHVlXG4gICAgICAgICAgICBpZiAoaW1wbGljaXRLZXkpXG4gICAgICAgICAgICAgICAgb25FcnJvcihrZXlOb2RlLnJhbmdlLCAnTUlTU0lOR19DSEFSJywgJ0ltcGxpY2l0IG1hcCBrZXlzIG5lZWQgdG8gYmUgZm9sbG93ZWQgYnkgbWFwIHZhbHVlcycpO1xuICAgICAgICAgICAgaWYgKHZhbHVlUHJvcHMuY29tbWVudCkge1xuICAgICAgICAgICAgICAgIGlmIChrZXlOb2RlLmNvbW1lbnQpXG4gICAgICAgICAgICAgICAgICAgIGtleU5vZGUuY29tbWVudCArPSAnXFxuJyArIHZhbHVlUHJvcHMuY29tbWVudDtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGtleU5vZGUuY29tbWVudCA9IHZhbHVlUHJvcHMuY29tbWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHBhaXIgPSBuZXcgUGFpcihrZXlOb2RlKTtcbiAgICAgICAgICAgIGlmIChjdHgub3B0aW9ucy5rZWVwU291cmNlVG9rZW5zKVxuICAgICAgICAgICAgICAgIHBhaXIuc3JjVG9rZW4gPSBjb2xsSXRlbTtcbiAgICAgICAgICAgIG1hcC5pdGVtcy5wdXNoKHBhaXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG1hcC5yYW5nZSA9IFtibS5vZmZzZXQsIG9mZnNldCwgb2Zmc2V0XTtcbiAgICByZXR1cm4gbWFwO1xufVxuXG5leHBvcnQgeyByZXNvbHZlQmxvY2tNYXAgfTtcbiIsICJpbXBvcnQgeyBZQU1MU2VxIH0gZnJvbSAnLi4vbm9kZXMvWUFNTFNlcS5qcyc7XG5pbXBvcnQgeyByZXNvbHZlUHJvcHMgfSBmcm9tICcuL3Jlc29sdmUtcHJvcHMuanMnO1xuaW1wb3J0IHsgZmxvd0luZGVudENoZWNrIH0gZnJvbSAnLi91dGlsLWZsb3ctaW5kZW50LWNoZWNrLmpzJztcblxuZnVuY3Rpb24gcmVzb2x2ZUJsb2NrU2VxKHsgY29tcG9zZU5vZGUsIGNvbXBvc2VFbXB0eU5vZGUgfSwgY3R4LCBicywgb25FcnJvcikge1xuICAgIGNvbnN0IHNlcSA9IG5ldyBZQU1MU2VxKGN0eC5zY2hlbWEpO1xuICAgIGlmIChjdHguYXRSb290KVxuICAgICAgICBjdHguYXRSb290ID0gZmFsc2U7XG4gICAgbGV0IG9mZnNldCA9IGJzLm9mZnNldDtcbiAgICBmb3IgKGNvbnN0IHsgc3RhcnQsIHZhbHVlIH0gb2YgYnMuaXRlbXMpIHtcbiAgICAgICAgY29uc3QgcHJvcHMgPSByZXNvbHZlUHJvcHMoc3RhcnQsIHtcbiAgICAgICAgICAgIGluZGljYXRvcjogJ3NlcS1pdGVtLWluZCcsXG4gICAgICAgICAgICBuZXh0OiB2YWx1ZSxcbiAgICAgICAgICAgIG9mZnNldCxcbiAgICAgICAgICAgIG9uRXJyb3IsXG4gICAgICAgICAgICBzdGFydE9uTmV3bGluZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgb2Zmc2V0ID0gcHJvcHMuZW5kO1xuICAgICAgICBpZiAoIXByb3BzLmZvdW5kKSB7XG4gICAgICAgICAgICBpZiAocHJvcHMuYW5jaG9yIHx8IHByb3BzLnRhZyB8fCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAmJiB2YWx1ZS50eXBlID09PSAnYmxvY2stc2VxJylcbiAgICAgICAgICAgICAgICAgICAgb25FcnJvcihvZmZzZXQsICdCQURfSU5ERU5UJywgJ0FsbCBzZXF1ZW5jZSBpdGVtcyBtdXN0IHN0YXJ0IGF0IHRoZSBzYW1lIGNvbHVtbicpO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgb25FcnJvcihvZmZzZXQsICdNSVNTSU5HX0NIQVInLCAnU2VxdWVuY2UgaXRlbSB3aXRob3V0IC0gaW5kaWNhdG9yJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBhc3NlcnQgYmVpbmcgYXQgbGFzdCBpdGVtP1xuICAgICAgICAgICAgICAgIGlmIChwcm9wcy5jb21tZW50KVxuICAgICAgICAgICAgICAgICAgICBzZXEuY29tbWVudCA9IHByb3BzLmNvbW1lbnQ7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgbm9kZSA9IHZhbHVlXG4gICAgICAgICAgICA/IGNvbXBvc2VOb2RlKGN0eCwgdmFsdWUsIHByb3BzLCBvbkVycm9yKVxuICAgICAgICAgICAgOiBjb21wb3NlRW1wdHlOb2RlKGN0eCwgb2Zmc2V0LCBzdGFydCwgbnVsbCwgcHJvcHMsIG9uRXJyb3IpO1xuICAgICAgICBpZiAoY3R4LnNjaGVtYS5jb21wYXQpXG4gICAgICAgICAgICBmbG93SW5kZW50Q2hlY2soYnMuaW5kZW50LCB2YWx1ZSwgb25FcnJvcik7XG4gICAgICAgIG9mZnNldCA9IG5vZGUucmFuZ2VbMl07XG4gICAgICAgIHNlcS5pdGVtcy5wdXNoKG5vZGUpO1xuICAgIH1cbiAgICBzZXEucmFuZ2UgPSBbYnMub2Zmc2V0LCBvZmZzZXQsIG9mZnNldF07XG4gICAgcmV0dXJuIHNlcTtcbn1cblxuZXhwb3J0IHsgcmVzb2x2ZUJsb2NrU2VxIH07XG4iLCAiZnVuY3Rpb24gcmVzb2x2ZUVuZChlbmQsIG9mZnNldCwgcmVxU3BhY2UsIG9uRXJyb3IpIHtcbiAgICBsZXQgY29tbWVudCA9ICcnO1xuICAgIGlmIChlbmQpIHtcbiAgICAgICAgbGV0IGhhc1NwYWNlID0gZmFsc2U7XG4gICAgICAgIGxldCBzZXAgPSAnJztcbiAgICAgICAgZm9yIChjb25zdCB0b2tlbiBvZiBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgc291cmNlLCB0eXBlIH0gPSB0b2tlbjtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3NwYWNlJzpcbiAgICAgICAgICAgICAgICAgICAgaGFzU3BhY2UgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdjb21tZW50Jzoge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVxU3BhY2UgJiYgIWhhc1NwYWNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgb25FcnJvcih0b2tlbiwgJ01JU1NJTkdfQ0hBUicsICdDb21tZW50cyBtdXN0IGJlIHNlcGFyYXRlZCBmcm9tIG90aGVyIHRva2VucyBieSB3aGl0ZSBzcGFjZSBjaGFyYWN0ZXJzJyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNiID0gc291cmNlLnN1YnN0cmluZygxKSB8fCAnICc7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY29tbWVudClcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1lbnQgPSBjYjtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgY29tbWVudCArPSBzZXAgKyBjYjtcbiAgICAgICAgICAgICAgICAgICAgc2VwID0gJyc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlICduZXdsaW5lJzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbW1lbnQpXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXAgKz0gc291cmNlO1xuICAgICAgICAgICAgICAgICAgICBoYXNTcGFjZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3IodG9rZW4sICdVTkVYUEVDVEVEX1RPS0VOJywgYFVuZXhwZWN0ZWQgJHt0eXBlfSBhdCBub2RlIGVuZGApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2Zmc2V0ICs9IHNvdXJjZS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgY29tbWVudCwgb2Zmc2V0IH07XG59XG5cbmV4cG9ydCB7IHJlc29sdmVFbmQgfTtcbiIsICJpbXBvcnQgeyBpc1BhaXIgfSBmcm9tICcuLi9ub2Rlcy9Ob2RlLmpzJztcbmltcG9ydCB7IFBhaXIgfSBmcm9tICcuLi9ub2Rlcy9QYWlyLmpzJztcbmltcG9ydCB7IFlBTUxNYXAgfSBmcm9tICcuLi9ub2Rlcy9ZQU1MTWFwLmpzJztcbmltcG9ydCB7IFlBTUxTZXEgfSBmcm9tICcuLi9ub2Rlcy9ZQU1MU2VxLmpzJztcbmltcG9ydCB7IHJlc29sdmVFbmQgfSBmcm9tICcuL3Jlc29sdmUtZW5kLmpzJztcbmltcG9ydCB7IHJlc29sdmVQcm9wcyB9IGZyb20gJy4vcmVzb2x2ZS1wcm9wcy5qcyc7XG5pbXBvcnQgeyBjb250YWluc05ld2xpbmUgfSBmcm9tICcuL3V0aWwtY29udGFpbnMtbmV3bGluZS5qcyc7XG5pbXBvcnQgeyBtYXBJbmNsdWRlcyB9IGZyb20gJy4vdXRpbC1tYXAtaW5jbHVkZXMuanMnO1xuXG5jb25zdCBibG9ja01zZyA9ICdCbG9jayBjb2xsZWN0aW9ucyBhcmUgbm90IGFsbG93ZWQgd2l0aGluIGZsb3cgY29sbGVjdGlvbnMnO1xuY29uc3QgaXNCbG9jayA9ICh0b2tlbikgPT4gdG9rZW4gJiYgKHRva2VuLnR5cGUgPT09ICdibG9jay1tYXAnIHx8IHRva2VuLnR5cGUgPT09ICdibG9jay1zZXEnKTtcbmZ1bmN0aW9uIHJlc29sdmVGbG93Q29sbGVjdGlvbih7IGNvbXBvc2VOb2RlLCBjb21wb3NlRW1wdHlOb2RlIH0sIGN0eCwgZmMsIG9uRXJyb3IpIHtcbiAgICBjb25zdCBpc01hcCA9IGZjLnN0YXJ0LnNvdXJjZSA9PT0gJ3snO1xuICAgIGNvbnN0IGZjTmFtZSA9IGlzTWFwID8gJ2Zsb3cgbWFwJyA6ICdmbG93IHNlcXVlbmNlJztcbiAgICBjb25zdCBjb2xsID0gaXNNYXBcbiAgICAgICAgPyBuZXcgWUFNTE1hcChjdHguc2NoZW1hKVxuICAgICAgICA6IG5ldyBZQU1MU2VxKGN0eC5zY2hlbWEpO1xuICAgIGNvbGwuZmxvdyA9IHRydWU7XG4gICAgY29uc3QgYXRSb290ID0gY3R4LmF0Um9vdDtcbiAgICBpZiAoYXRSb290KVxuICAgICAgICBjdHguYXRSb290ID0gZmFsc2U7XG4gICAgbGV0IG9mZnNldCA9IGZjLm9mZnNldCArIGZjLnN0YXJ0LnNvdXJjZS5sZW5ndGg7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmYy5pdGVtcy5sZW5ndGg7ICsraSkge1xuICAgICAgICBjb25zdCBjb2xsSXRlbSA9IGZjLml0ZW1zW2ldO1xuICAgICAgICBjb25zdCB7IHN0YXJ0LCBrZXksIHNlcCwgdmFsdWUgfSA9IGNvbGxJdGVtO1xuICAgICAgICBjb25zdCBwcm9wcyA9IHJlc29sdmVQcm9wcyhzdGFydCwge1xuICAgICAgICAgICAgZmxvdzogZmNOYW1lLFxuICAgICAgICAgICAgaW5kaWNhdG9yOiAnZXhwbGljaXQta2V5LWluZCcsXG4gICAgICAgICAgICBuZXh0OiBrZXkgfHwgKHNlcCA9PT0gbnVsbCB8fCBzZXAgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNlcFswXSksXG4gICAgICAgICAgICBvZmZzZXQsXG4gICAgICAgICAgICBvbkVycm9yLFxuICAgICAgICAgICAgc3RhcnRPbk5ld2xpbmU6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIXByb3BzLmZvdW5kKSB7XG4gICAgICAgICAgICBpZiAoIXByb3BzLmFuY2hvciAmJiAhcHJvcHMudGFnICYmICFzZXAgJiYgIXZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgPT09IDAgJiYgcHJvcHMuY29tbWEpXG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3IocHJvcHMuY29tbWEsICdVTkVYUEVDVEVEX1RPS0VOJywgYFVuZXhwZWN0ZWQgLCBpbiAke2ZjTmFtZX1gKTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpIDwgZmMuaXRlbXMubGVuZ3RoIC0gMSlcbiAgICAgICAgICAgICAgICAgICAgb25FcnJvcihwcm9wcy5zdGFydCwgJ1VORVhQRUNURURfVE9LRU4nLCBgVW5leHBlY3RlZCBlbXB0eSBpdGVtIGluICR7ZmNOYW1lfWApO1xuICAgICAgICAgICAgICAgIGlmIChwcm9wcy5jb21tZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb2xsLmNvbW1lbnQpXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xsLmNvbW1lbnQgKz0gJ1xcbicgKyBwcm9wcy5jb21tZW50O1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xsLmNvbW1lbnQgPSBwcm9wcy5jb21tZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvZmZzZXQgPSBwcm9wcy5lbmQ7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWlzTWFwICYmIGN0eC5vcHRpb25zLnN0cmljdCAmJiBjb250YWluc05ld2xpbmUoa2V5KSlcbiAgICAgICAgICAgICAgICBvbkVycm9yKGtleSwgLy8gY2hlY2tlZCBieSBjb250YWluc05ld2xpbmUoKVxuICAgICAgICAgICAgICAgICdNVUxUSUxJTkVfSU1QTElDSVRfS0VZJywgJ0ltcGxpY2l0IGtleXMgb2YgZmxvdyBzZXF1ZW5jZSBwYWlycyBuZWVkIHRvIGJlIG9uIGEgc2luZ2xlIGxpbmUnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgICAgaWYgKHByb3BzLmNvbW1hKVxuICAgICAgICAgICAgICAgIG9uRXJyb3IocHJvcHMuY29tbWEsICdVTkVYUEVDVEVEX1RPS0VOJywgYFVuZXhwZWN0ZWQgLCBpbiAke2ZjTmFtZX1gKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICghcHJvcHMuY29tbWEpXG4gICAgICAgICAgICAgICAgb25FcnJvcihwcm9wcy5zdGFydCwgJ01JU1NJTkdfQ0hBUicsIGBNaXNzaW5nICwgYmV0d2VlbiAke2ZjTmFtZX0gaXRlbXNgKTtcbiAgICAgICAgICAgIGlmIChwcm9wcy5jb21tZW50KSB7XG4gICAgICAgICAgICAgICAgbGV0IHByZXZJdGVtQ29tbWVudCA9ICcnO1xuICAgICAgICAgICAgICAgIGxvb3A6IGZvciAoY29uc3Qgc3Qgb2Ygc3RhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChzdC50eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdjb21tYSc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdzcGFjZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdjb21tZW50JzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmV2SXRlbUNvbW1lbnQgPSBzdC5zb3VyY2Uuc3Vic3RyaW5nKDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIGxvb3A7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIGxvb3A7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHByZXZJdGVtQ29tbWVudCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcHJldiA9IGNvbGwuaXRlbXNbY29sbC5pdGVtcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzUGFpcihwcmV2KSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXYgPSBwcmV2LnZhbHVlIHx8IHByZXYua2V5O1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJldi5jb21tZW50KVxuICAgICAgICAgICAgICAgICAgICAgICAgcHJldi5jb21tZW50ICs9ICdcXG4nICsgcHJldkl0ZW1Db21tZW50O1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2LmNvbW1lbnQgPSBwcmV2SXRlbUNvbW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgIHByb3BzLmNvbW1lbnQgPSBwcm9wcy5jb21tZW50LnN1YnN0cmluZyhwcmV2SXRlbUNvbW1lbnQubGVuZ3RoICsgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghaXNNYXAgJiYgIXNlcCAmJiAhcHJvcHMuZm91bmQpIHtcbiAgICAgICAgICAgIC8vIGl0ZW0gaXMgYSB2YWx1ZSBpbiBhIHNlcVxuICAgICAgICAgICAgLy8gXHUyMTkyIGtleSAmIHNlcCBhcmUgZW1wdHksIHN0YXJ0IGRvZXMgbm90IGluY2x1ZGUgPyBvciA6XG4gICAgICAgICAgICBjb25zdCB2YWx1ZU5vZGUgPSB2YWx1ZVxuICAgICAgICAgICAgICAgID8gY29tcG9zZU5vZGUoY3R4LCB2YWx1ZSwgcHJvcHMsIG9uRXJyb3IpXG4gICAgICAgICAgICAgICAgOiBjb21wb3NlRW1wdHlOb2RlKGN0eCwgcHJvcHMuZW5kLCBzZXAsIG51bGwsIHByb3BzLCBvbkVycm9yKTtcbiAgICAgICAgICAgIGNvbGwuaXRlbXMucHVzaCh2YWx1ZU5vZGUpO1xuICAgICAgICAgICAgb2Zmc2V0ID0gdmFsdWVOb2RlLnJhbmdlWzJdO1xuICAgICAgICAgICAgaWYgKGlzQmxvY2sodmFsdWUpKVxuICAgICAgICAgICAgICAgIG9uRXJyb3IodmFsdWVOb2RlLnJhbmdlLCAnQkxPQ0tfSU5fRkxPVycsIGJsb2NrTXNnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGl0ZW0gaXMgYSBrZXkrdmFsdWUgcGFpclxuICAgICAgICAgICAgLy8ga2V5IHZhbHVlXG4gICAgICAgICAgICBjb25zdCBrZXlTdGFydCA9IHByb3BzLmVuZDtcbiAgICAgICAgICAgIGNvbnN0IGtleU5vZGUgPSBrZXlcbiAgICAgICAgICAgICAgICA/IGNvbXBvc2VOb2RlKGN0eCwga2V5LCBwcm9wcywgb25FcnJvcilcbiAgICAgICAgICAgICAgICA6IGNvbXBvc2VFbXB0eU5vZGUoY3R4LCBrZXlTdGFydCwgc3RhcnQsIG51bGwsIHByb3BzLCBvbkVycm9yKTtcbiAgICAgICAgICAgIGlmIChpc0Jsb2NrKGtleSkpXG4gICAgICAgICAgICAgICAgb25FcnJvcihrZXlOb2RlLnJhbmdlLCAnQkxPQ0tfSU5fRkxPVycsIGJsb2NrTXNnKTtcbiAgICAgICAgICAgIC8vIHZhbHVlIHByb3BlcnRpZXNcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlUHJvcHMgPSByZXNvbHZlUHJvcHMoc2VwIHx8IFtdLCB7XG4gICAgICAgICAgICAgICAgZmxvdzogZmNOYW1lLFxuICAgICAgICAgICAgICAgIGluZGljYXRvcjogJ21hcC12YWx1ZS1pbmQnLFxuICAgICAgICAgICAgICAgIG5leHQ6IHZhbHVlLFxuICAgICAgICAgICAgICAgIG9mZnNldDoga2V5Tm9kZS5yYW5nZVsyXSxcbiAgICAgICAgICAgICAgICBvbkVycm9yLFxuICAgICAgICAgICAgICAgIHN0YXJ0T25OZXdsaW5lOiBmYWxzZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAodmFsdWVQcm9wcy5mb3VuZCkge1xuICAgICAgICAgICAgICAgIGlmICghaXNNYXAgJiYgIXByb3BzLmZvdW5kICYmIGN0eC5vcHRpb25zLnN0cmljdCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VwKVxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBzdCBvZiBzZXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3QgPT09IHZhbHVlUHJvcHMuZm91bmQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdC50eXBlID09PSAnbmV3bGluZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25FcnJvcihzdCwgJ01VTFRJTElORV9JTVBMSUNJVF9LRVknLCAnSW1wbGljaXQga2V5cyBvZiBmbG93IHNlcXVlbmNlIHBhaXJzIG5lZWQgdG8gYmUgb24gYSBzaW5nbGUgbGluZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9wcy5zdGFydCA8IHZhbHVlUHJvcHMuZm91bmQub2Zmc2V0IC0gMTAyNClcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uRXJyb3IodmFsdWVQcm9wcy5mb3VuZCwgJ0tFWV9PVkVSXzEwMjRfQ0hBUlMnLCAnVGhlIDogaW5kaWNhdG9yIG11c3QgYmUgYXQgbW9zdCAxMDI0IGNoYXJzIGFmdGVyIHRoZSBzdGFydCBvZiBhbiBpbXBsaWNpdCBmbG93IHNlcXVlbmNlIGtleScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCdzb3VyY2UnIGluIHZhbHVlICYmIHZhbHVlLnNvdXJjZSAmJiB2YWx1ZS5zb3VyY2VbMF0gPT09ICc6JylcbiAgICAgICAgICAgICAgICAgICAgb25FcnJvcih2YWx1ZSwgJ01JU1NJTkdfQ0hBUicsIGBNaXNzaW5nIHNwYWNlIGFmdGVyIDogaW4gJHtmY05hbWV9YCk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBvbkVycm9yKHZhbHVlUHJvcHMuc3RhcnQsICdNSVNTSU5HX0NIQVInLCBgTWlzc2luZyAsIG9yIDogYmV0d2VlbiAke2ZjTmFtZX0gaXRlbXNgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHZhbHVlIHZhbHVlXG4gICAgICAgICAgICBjb25zdCB2YWx1ZU5vZGUgPSB2YWx1ZVxuICAgICAgICAgICAgICAgID8gY29tcG9zZU5vZGUoY3R4LCB2YWx1ZSwgdmFsdWVQcm9wcywgb25FcnJvcilcbiAgICAgICAgICAgICAgICA6IHZhbHVlUHJvcHMuZm91bmRcbiAgICAgICAgICAgICAgICAgICAgPyBjb21wb3NlRW1wdHlOb2RlKGN0eCwgdmFsdWVQcm9wcy5lbmQsIHNlcCwgbnVsbCwgdmFsdWVQcm9wcywgb25FcnJvcilcbiAgICAgICAgICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICAgICAgaWYgKHZhbHVlTm9kZSkge1xuICAgICAgICAgICAgICAgIGlmIChpc0Jsb2NrKHZhbHVlKSlcbiAgICAgICAgICAgICAgICAgICAgb25FcnJvcih2YWx1ZU5vZGUucmFuZ2UsICdCTE9DS19JTl9GTE9XJywgYmxvY2tNc2cpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWVQcm9wcy5jb21tZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKGtleU5vZGUuY29tbWVudClcbiAgICAgICAgICAgICAgICAgICAga2V5Tm9kZS5jb21tZW50ICs9ICdcXG4nICsgdmFsdWVQcm9wcy5jb21tZW50O1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAga2V5Tm9kZS5jb21tZW50ID0gdmFsdWVQcm9wcy5jb21tZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcGFpciA9IG5ldyBQYWlyKGtleU5vZGUsIHZhbHVlTm9kZSk7XG4gICAgICAgICAgICBpZiAoY3R4Lm9wdGlvbnMua2VlcFNvdXJjZVRva2VucylcbiAgICAgICAgICAgICAgICBwYWlyLnNyY1Rva2VuID0gY29sbEl0ZW07XG4gICAgICAgICAgICBpZiAoaXNNYXApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXAgPSBjb2xsO1xuICAgICAgICAgICAgICAgIGlmIChtYXBJbmNsdWRlcyhjdHgsIG1hcC5pdGVtcywga2V5Tm9kZSkpXG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3Ioa2V5U3RhcnQsICdEVVBMSUNBVEVfS0VZJywgJ01hcCBrZXlzIG11c3QgYmUgdW5pcXVlJyk7XG4gICAgICAgICAgICAgICAgbWFwLml0ZW1zLnB1c2gocGFpcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXAgPSBuZXcgWUFNTE1hcChjdHguc2NoZW1hKTtcbiAgICAgICAgICAgICAgICBtYXAuZmxvdyA9IHRydWU7XG4gICAgICAgICAgICAgICAgbWFwLml0ZW1zLnB1c2gocGFpcik7XG4gICAgICAgICAgICAgICAgY29sbC5pdGVtcy5wdXNoKG1hcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvZmZzZXQgPSB2YWx1ZU5vZGUgPyB2YWx1ZU5vZGUucmFuZ2VbMl0gOiB2YWx1ZVByb3BzLmVuZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBleHBlY3RlZEVuZCA9IGlzTWFwID8gJ30nIDogJ10nO1xuICAgIGNvbnN0IFtjZSwgLi4uZWVdID0gZmMuZW5kO1xuICAgIGxldCBjZVBvcyA9IG9mZnNldDtcbiAgICBpZiAoY2UgJiYgY2Uuc291cmNlID09PSBleHBlY3RlZEVuZClcbiAgICAgICAgY2VQb3MgPSBjZS5vZmZzZXQgKyBjZS5zb3VyY2UubGVuZ3RoO1xuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBuYW1lID0gZmNOYW1lWzBdLnRvVXBwZXJDYXNlKCkgKyBmY05hbWUuc3Vic3RyaW5nKDEpO1xuICAgICAgICBjb25zdCBtc2cgPSBhdFJvb3RcbiAgICAgICAgICAgID8gYCR7bmFtZX0gbXVzdCBlbmQgd2l0aCBhICR7ZXhwZWN0ZWRFbmR9YFxuICAgICAgICAgICAgOiBgJHtuYW1lfSBpbiBibG9jayBjb2xsZWN0aW9uIG11c3QgYmUgc3VmZmljaWVudGx5IGluZGVudGVkIGFuZCBlbmQgd2l0aCBhICR7ZXhwZWN0ZWRFbmR9YDtcbiAgICAgICAgb25FcnJvcihvZmZzZXQsIGF0Um9vdCA/ICdNSVNTSU5HX0NIQVInIDogJ0JBRF9JTkRFTlQnLCBtc2cpO1xuICAgICAgICBpZiAoY2UgJiYgY2Uuc291cmNlLmxlbmd0aCAhPT0gMSlcbiAgICAgICAgICAgIGVlLnVuc2hpZnQoY2UpO1xuICAgIH1cbiAgICBpZiAoZWUubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCBlbmQgPSByZXNvbHZlRW5kKGVlLCBjZVBvcywgY3R4Lm9wdGlvbnMuc3RyaWN0LCBvbkVycm9yKTtcbiAgICAgICAgaWYgKGVuZC5jb21tZW50KSB7XG4gICAgICAgICAgICBpZiAoY29sbC5jb21tZW50KVxuICAgICAgICAgICAgICAgIGNvbGwuY29tbWVudCArPSAnXFxuJyArIGVuZC5jb21tZW50O1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGNvbGwuY29tbWVudCA9IGVuZC5jb21tZW50O1xuICAgICAgICB9XG4gICAgICAgIGNvbGwucmFuZ2UgPSBbZmMub2Zmc2V0LCBjZVBvcywgZW5kLm9mZnNldF07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb2xsLnJhbmdlID0gW2ZjLm9mZnNldCwgY2VQb3MsIGNlUG9zXTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbGw7XG59XG5cbmV4cG9ydCB7IHJlc29sdmVGbG93Q29sbGVjdGlvbiB9O1xuIiwgImltcG9ydCB7IGlzTm9kZSwgaXNNYXAgfSBmcm9tICcuLi9ub2Rlcy9Ob2RlLmpzJztcbmltcG9ydCB7IFNjYWxhciB9IGZyb20gJy4uL25vZGVzL1NjYWxhci5qcyc7XG5pbXBvcnQgeyByZXNvbHZlQmxvY2tNYXAgfSBmcm9tICcuL3Jlc29sdmUtYmxvY2stbWFwLmpzJztcbmltcG9ydCB7IHJlc29sdmVCbG9ja1NlcSB9IGZyb20gJy4vcmVzb2x2ZS1ibG9jay1zZXEuanMnO1xuaW1wb3J0IHsgcmVzb2x2ZUZsb3dDb2xsZWN0aW9uIH0gZnJvbSAnLi9yZXNvbHZlLWZsb3ctY29sbGVjdGlvbi5qcyc7XG5cbmZ1bmN0aW9uIGNvbXBvc2VDb2xsZWN0aW9uKENOLCBjdHgsIHRva2VuLCB0YWdUb2tlbiwgb25FcnJvcikge1xuICAgIGxldCBjb2xsO1xuICAgIHN3aXRjaCAodG9rZW4udHlwZSkge1xuICAgICAgICBjYXNlICdibG9jay1tYXAnOiB7XG4gICAgICAgICAgICBjb2xsID0gcmVzb2x2ZUJsb2NrTWFwKENOLCBjdHgsIHRva2VuLCBvbkVycm9yKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ2Jsb2NrLXNlcSc6IHtcbiAgICAgICAgICAgIGNvbGwgPSByZXNvbHZlQmxvY2tTZXEoQ04sIGN0eCwgdG9rZW4sIG9uRXJyb3IpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnZmxvdy1jb2xsZWN0aW9uJzoge1xuICAgICAgICAgICAgY29sbCA9IHJlc29sdmVGbG93Q29sbGVjdGlvbihDTiwgY3R4LCB0b2tlbiwgb25FcnJvcik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXRhZ1Rva2VuKVxuICAgICAgICByZXR1cm4gY29sbDtcbiAgICBjb25zdCB0YWdOYW1lID0gY3R4LmRpcmVjdGl2ZXMudGFnTmFtZSh0YWdUb2tlbi5zb3VyY2UsIG1zZyA9PiBvbkVycm9yKHRhZ1Rva2VuLCAnVEFHX1JFU09MVkVfRkFJTEVEJywgbXNnKSk7XG4gICAgaWYgKCF0YWdOYW1lKVxuICAgICAgICByZXR1cm4gY29sbDtcbiAgICAvLyBDYXN0IG5lZWRlZCBkdWUgdG86IGh0dHBzOi8vZ2l0aHViLmNvbS9NaWNyb3NvZnQvVHlwZVNjcmlwdC9pc3N1ZXMvMzg0MVxuICAgIGNvbnN0IENvbGwgPSBjb2xsLmNvbnN0cnVjdG9yO1xuICAgIGlmICh0YWdOYW1lID09PSAnIScgfHwgdGFnTmFtZSA9PT0gQ29sbC50YWdOYW1lKSB7XG4gICAgICAgIGNvbGwudGFnID0gQ29sbC50YWdOYW1lO1xuICAgICAgICByZXR1cm4gY29sbDtcbiAgICB9XG4gICAgY29uc3QgZXhwVHlwZSA9IGlzTWFwKGNvbGwpID8gJ21hcCcgOiAnc2VxJztcbiAgICBsZXQgdGFnID0gY3R4LnNjaGVtYS50YWdzLmZpbmQodCA9PiB0LmNvbGxlY3Rpb24gPT09IGV4cFR5cGUgJiYgdC50YWcgPT09IHRhZ05hbWUpO1xuICAgIGlmICghdGFnKSB7XG4gICAgICAgIGNvbnN0IGt0ID0gY3R4LnNjaGVtYS5rbm93blRhZ3NbdGFnTmFtZV07XG4gICAgICAgIGlmIChrdCAmJiBrdC5jb2xsZWN0aW9uID09PSBleHBUeXBlKSB7XG4gICAgICAgICAgICBjdHguc2NoZW1hLnRhZ3MucHVzaChPYmplY3QuYXNzaWduKHt9LCBrdCwgeyBkZWZhdWx0OiBmYWxzZSB9KSk7XG4gICAgICAgICAgICB0YWcgPSBrdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9uRXJyb3IodGFnVG9rZW4sICdUQUdfUkVTT0xWRV9GQUlMRUQnLCBgVW5yZXNvbHZlZCB0YWc6ICR7dGFnTmFtZX1gLCB0cnVlKTtcbiAgICAgICAgICAgIGNvbGwudGFnID0gdGFnTmFtZTtcbiAgICAgICAgICAgIHJldHVybiBjb2xsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHJlcyA9IHRhZy5yZXNvbHZlKGNvbGwsIG1zZyA9PiBvbkVycm9yKHRhZ1Rva2VuLCAnVEFHX1JFU09MVkVfRkFJTEVEJywgbXNnKSwgY3R4Lm9wdGlvbnMpO1xuICAgIGNvbnN0IG5vZGUgPSBpc05vZGUocmVzKVxuICAgICAgICA/IHJlc1xuICAgICAgICA6IG5ldyBTY2FsYXIocmVzKTtcbiAgICBub2RlLnJhbmdlID0gY29sbC5yYW5nZTtcbiAgICBub2RlLnRhZyA9IHRhZ05hbWU7XG4gICAgaWYgKHRhZyA9PT0gbnVsbCB8fCB0YWcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRhZy5mb3JtYXQpXG4gICAgICAgIG5vZGUuZm9ybWF0ID0gdGFnLmZvcm1hdDtcbiAgICByZXR1cm4gbm9kZTtcbn1cblxuZXhwb3J0IHsgY29tcG9zZUNvbGxlY3Rpb24gfTtcbiIsICJpbXBvcnQgeyBTY2FsYXIgfSBmcm9tICcuLi9ub2Rlcy9TY2FsYXIuanMnO1xuXG5mdW5jdGlvbiByZXNvbHZlQmxvY2tTY2FsYXIoc2NhbGFyLCBzdHJpY3QsIG9uRXJyb3IpIHtcbiAgICBjb25zdCBzdGFydCA9IHNjYWxhci5vZmZzZXQ7XG4gICAgY29uc3QgaGVhZGVyID0gcGFyc2VCbG9ja1NjYWxhckhlYWRlcihzY2FsYXIsIHN0cmljdCwgb25FcnJvcik7XG4gICAgaWYgKCFoZWFkZXIpXG4gICAgICAgIHJldHVybiB7IHZhbHVlOiAnJywgdHlwZTogbnVsbCwgY29tbWVudDogJycsIHJhbmdlOiBbc3RhcnQsIHN0YXJ0LCBzdGFydF0gfTtcbiAgICBjb25zdCB0eXBlID0gaGVhZGVyLm1vZGUgPT09ICc+JyA/IFNjYWxhci5CTE9DS19GT0xERUQgOiBTY2FsYXIuQkxPQ0tfTElURVJBTDtcbiAgICBjb25zdCBsaW5lcyA9IHNjYWxhci5zb3VyY2UgPyBzcGxpdExpbmVzKHNjYWxhci5zb3VyY2UpIDogW107XG4gICAgLy8gZGV0ZXJtaW5lIHRoZSBlbmQgb2YgY29udGVudCAmIHN0YXJ0IG9mIGNob21waW5nXG4gICAgbGV0IGNob21wU3RhcnQgPSBsaW5lcy5sZW5ndGg7XG4gICAgZm9yIChsZXQgaSA9IGxpbmVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIGNvbnN0IGNvbnRlbnQgPSBsaW5lc1tpXVsxXTtcbiAgICAgICAgaWYgKGNvbnRlbnQgPT09ICcnIHx8IGNvbnRlbnQgPT09ICdcXHInKVxuICAgICAgICAgICAgY2hvbXBTdGFydCA9IGk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICAvLyBzaG9ydGN1dCBmb3IgZW1wdHkgY29udGVudHNcbiAgICBpZiAoIXNjYWxhci5zb3VyY2UgfHwgY2hvbXBTdGFydCA9PT0gMCkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGhlYWRlci5jaG9tcCA9PT0gJysnID8gJ1xcbicucmVwZWF0KE1hdGgubWF4KDAsIGxpbmVzLmxlbmd0aCAtIDEpKSA6ICcnO1xuICAgICAgICBsZXQgZW5kID0gc3RhcnQgKyBoZWFkZXIubGVuZ3RoO1xuICAgICAgICBpZiAoc2NhbGFyLnNvdXJjZSlcbiAgICAgICAgICAgIGVuZCArPSBzY2FsYXIuc291cmNlLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHsgdmFsdWUsIHR5cGUsIGNvbW1lbnQ6IGhlYWRlci5jb21tZW50LCByYW5nZTogW3N0YXJ0LCBlbmQsIGVuZF0gfTtcbiAgICB9XG4gICAgLy8gZmluZCB0aGUgaW5kZW50YXRpb24gbGV2ZWwgdG8gdHJpbSBmcm9tIHN0YXJ0XG4gICAgbGV0IHRyaW1JbmRlbnQgPSBzY2FsYXIuaW5kZW50ICsgaGVhZGVyLmluZGVudDtcbiAgICBsZXQgb2Zmc2V0ID0gc2NhbGFyLm9mZnNldCArIGhlYWRlci5sZW5ndGg7XG4gICAgbGV0IGNvbnRlbnRTdGFydCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaG9tcFN0YXJ0OyArK2kpIHtcbiAgICAgICAgY29uc3QgW2luZGVudCwgY29udGVudF0gPSBsaW5lc1tpXTtcbiAgICAgICAgaWYgKGNvbnRlbnQgPT09ICcnIHx8IGNvbnRlbnQgPT09ICdcXHInKSB7XG4gICAgICAgICAgICBpZiAoaGVhZGVyLmluZGVudCA9PT0gMCAmJiBpbmRlbnQubGVuZ3RoID4gdHJpbUluZGVudClcbiAgICAgICAgICAgICAgICB0cmltSW5kZW50ID0gaW5kZW50Lmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChpbmRlbnQubGVuZ3RoIDwgdHJpbUluZGVudCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSAnQmxvY2sgc2NhbGFycyB3aXRoIG1vcmUtaW5kZW50ZWQgbGVhZGluZyBlbXB0eSBsaW5lcyBtdXN0IHVzZSBhbiBleHBsaWNpdCBpbmRlbnRhdGlvbiBpbmRpY2F0b3InO1xuICAgICAgICAgICAgICAgIG9uRXJyb3Iob2Zmc2V0ICsgaW5kZW50Lmxlbmd0aCwgJ01JU1NJTkdfQ0hBUicsIG1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGhlYWRlci5pbmRlbnQgPT09IDApXG4gICAgICAgICAgICAgICAgdHJpbUluZGVudCA9IGluZGVudC5sZW5ndGg7XG4gICAgICAgICAgICBjb250ZW50U3RhcnQgPSBpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgb2Zmc2V0ICs9IGluZGVudC5sZW5ndGggKyBjb250ZW50Lmxlbmd0aCArIDE7XG4gICAgfVxuICAgIGxldCB2YWx1ZSA9ICcnO1xuICAgIGxldCBzZXAgPSAnJztcbiAgICBsZXQgcHJldk1vcmVJbmRlbnRlZCA9IGZhbHNlO1xuICAgIC8vIGxlYWRpbmcgd2hpdGVzcGFjZSBpcyBrZXB0IGludGFjdFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29udGVudFN0YXJ0OyArK2kpXG4gICAgICAgIHZhbHVlICs9IGxpbmVzW2ldWzBdLnNsaWNlKHRyaW1JbmRlbnQpICsgJ1xcbic7XG4gICAgZm9yIChsZXQgaSA9IGNvbnRlbnRTdGFydDsgaSA8IGNob21wU3RhcnQ7ICsraSkge1xuICAgICAgICBsZXQgW2luZGVudCwgY29udGVudF0gPSBsaW5lc1tpXTtcbiAgICAgICAgb2Zmc2V0ICs9IGluZGVudC5sZW5ndGggKyBjb250ZW50Lmxlbmd0aCArIDE7XG4gICAgICAgIGNvbnN0IGNybGYgPSBjb250ZW50W2NvbnRlbnQubGVuZ3RoIC0gMV0gPT09ICdcXHInO1xuICAgICAgICBpZiAoY3JsZilcbiAgICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50LnNsaWNlKDAsIC0xKTtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmIGFscmVhZHkgY2F1Z2h0IGluIGxleGVyICovXG4gICAgICAgIGlmIChjb250ZW50ICYmIGluZGVudC5sZW5ndGggPCB0cmltSW5kZW50KSB7XG4gICAgICAgICAgICBjb25zdCBzcmMgPSBoZWFkZXIuaW5kZW50XG4gICAgICAgICAgICAgICAgPyAnZXhwbGljaXQgaW5kZW50YXRpb24gaW5kaWNhdG9yJ1xuICAgICAgICAgICAgICAgIDogJ2ZpcnN0IGxpbmUnO1xuICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IGBCbG9jayBzY2FsYXIgbGluZXMgbXVzdCBub3QgYmUgbGVzcyBpbmRlbnRlZCB0aGFuIHRoZWlyICR7c3JjfWA7XG4gICAgICAgICAgICBvbkVycm9yKG9mZnNldCAtIGNvbnRlbnQubGVuZ3RoIC0gKGNybGYgPyAyIDogMSksICdCQURfSU5ERU5UJywgbWVzc2FnZSk7XG4gICAgICAgICAgICBpbmRlbnQgPSAnJztcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZSA9PT0gU2NhbGFyLkJMT0NLX0xJVEVSQUwpIHtcbiAgICAgICAgICAgIHZhbHVlICs9IHNlcCArIGluZGVudC5zbGljZSh0cmltSW5kZW50KSArIGNvbnRlbnQ7XG4gICAgICAgICAgICBzZXAgPSAnXFxuJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpbmRlbnQubGVuZ3RoID4gdHJpbUluZGVudCB8fCBjb250ZW50WzBdID09PSAnXFx0Jykge1xuICAgICAgICAgICAgLy8gbW9yZS1pbmRlbnRlZCBjb250ZW50IHdpdGhpbiBhIGZvbGRlZCBibG9ja1xuICAgICAgICAgICAgaWYgKHNlcCA9PT0gJyAnKVxuICAgICAgICAgICAgICAgIHNlcCA9ICdcXG4nO1xuICAgICAgICAgICAgZWxzZSBpZiAoIXByZXZNb3JlSW5kZW50ZWQgJiYgc2VwID09PSAnXFxuJylcbiAgICAgICAgICAgICAgICBzZXAgPSAnXFxuXFxuJztcbiAgICAgICAgICAgIHZhbHVlICs9IHNlcCArIGluZGVudC5zbGljZSh0cmltSW5kZW50KSArIGNvbnRlbnQ7XG4gICAgICAgICAgICBzZXAgPSAnXFxuJztcbiAgICAgICAgICAgIHByZXZNb3JlSW5kZW50ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvbnRlbnQgPT09ICcnKSB7XG4gICAgICAgICAgICAvLyBlbXB0eSBsaW5lXG4gICAgICAgICAgICBpZiAoc2VwID09PSAnXFxuJylcbiAgICAgICAgICAgICAgICB2YWx1ZSArPSAnXFxuJztcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBzZXAgPSAnXFxuJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhbHVlICs9IHNlcCArIGNvbnRlbnQ7XG4gICAgICAgICAgICBzZXAgPSAnICc7XG4gICAgICAgICAgICBwcmV2TW9yZUluZGVudGVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3dpdGNoIChoZWFkZXIuY2hvbXApIHtcbiAgICAgICAgY2FzZSAnLSc6XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnKyc6XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gY2hvbXBTdGFydDsgaSA8IGxpbmVzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgIHZhbHVlICs9ICdcXG4nICsgbGluZXNbaV1bMF0uc2xpY2UodHJpbUluZGVudCk7XG4gICAgICAgICAgICBpZiAodmFsdWVbdmFsdWUubGVuZ3RoIC0gMV0gIT09ICdcXG4nKVxuICAgICAgICAgICAgICAgIHZhbHVlICs9ICdcXG4nO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB2YWx1ZSArPSAnXFxuJztcbiAgICB9XG4gICAgY29uc3QgZW5kID0gc3RhcnQgKyBoZWFkZXIubGVuZ3RoICsgc2NhbGFyLnNvdXJjZS5sZW5ndGg7XG4gICAgcmV0dXJuIHsgdmFsdWUsIHR5cGUsIGNvbW1lbnQ6IGhlYWRlci5jb21tZW50LCByYW5nZTogW3N0YXJ0LCBlbmQsIGVuZF0gfTtcbn1cbmZ1bmN0aW9uIHBhcnNlQmxvY2tTY2FsYXJIZWFkZXIoeyBvZmZzZXQsIHByb3BzIH0sIHN0cmljdCwgb25FcnJvcikge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiBzaG91bGQgbm90IGhhcHBlbiAqL1xuICAgIGlmIChwcm9wc1swXS50eXBlICE9PSAnYmxvY2stc2NhbGFyLWhlYWRlcicpIHtcbiAgICAgICAgb25FcnJvcihwcm9wc1swXSwgJ0lNUE9TU0lCTEUnLCAnQmxvY2sgc2NhbGFyIGhlYWRlciBub3QgZm91bmQnKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHsgc291cmNlIH0gPSBwcm9wc1swXTtcbiAgICBjb25zdCBtb2RlID0gc291cmNlWzBdO1xuICAgIGxldCBpbmRlbnQgPSAwO1xuICAgIGxldCBjaG9tcCA9ICcnO1xuICAgIGxldCBlcnJvciA9IC0xO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgc291cmNlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IGNoID0gc291cmNlW2ldO1xuICAgICAgICBpZiAoIWNob21wICYmIChjaCA9PT0gJy0nIHx8IGNoID09PSAnKycpKVxuICAgICAgICAgICAgY2hvbXAgPSBjaDtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBuID0gTnVtYmVyKGNoKTtcbiAgICAgICAgICAgIGlmICghaW5kZW50ICYmIG4pXG4gICAgICAgICAgICAgICAgaW5kZW50ID0gbjtcbiAgICAgICAgICAgIGVsc2UgaWYgKGVycm9yID09PSAtMSlcbiAgICAgICAgICAgICAgICBlcnJvciA9IG9mZnNldCArIGk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGVycm9yICE9PSAtMSlcbiAgICAgICAgb25FcnJvcihlcnJvciwgJ1VORVhQRUNURURfVE9LRU4nLCBgQmxvY2sgc2NhbGFyIGhlYWRlciBpbmNsdWRlcyBleHRyYSBjaGFyYWN0ZXJzOiAke3NvdXJjZX1gKTtcbiAgICBsZXQgaGFzU3BhY2UgPSBmYWxzZTtcbiAgICBsZXQgY29tbWVudCA9ICcnO1xuICAgIGxldCBsZW5ndGggPSBzb3VyY2UubGVuZ3RoO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgcHJvcHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29uc3QgdG9rZW4gPSBwcm9wc1tpXTtcbiAgICAgICAgc3dpdGNoICh0b2tlbi50eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdzcGFjZSc6XG4gICAgICAgICAgICAgICAgaGFzU3BhY2UgPSB0cnVlO1xuICAgICAgICAgICAgLy8gZmFsbHRocm91Z2hcbiAgICAgICAgICAgIGNhc2UgJ25ld2xpbmUnOlxuICAgICAgICAgICAgICAgIGxlbmd0aCArPSB0b2tlbi5zb3VyY2UubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnY29tbWVudCc6XG4gICAgICAgICAgICAgICAgaWYgKHN0cmljdCAmJiAhaGFzU3BhY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9ICdDb21tZW50cyBtdXN0IGJlIHNlcGFyYXRlZCBmcm9tIG90aGVyIHRva2VucyBieSB3aGl0ZSBzcGFjZSBjaGFyYWN0ZXJzJztcbiAgICAgICAgICAgICAgICAgICAgb25FcnJvcih0b2tlbiwgJ01JU1NJTkdfQ0hBUicsIG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZW5ndGggKz0gdG9rZW4uc291cmNlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBjb21tZW50ID0gdG9rZW4uc291cmNlLnN1YnN0cmluZygxKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2Vycm9yJzpcbiAgICAgICAgICAgICAgICBvbkVycm9yKHRva2VuLCAnVU5FWFBFQ1RFRF9UT0tFTicsIHRva2VuLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIGxlbmd0aCArPSB0b2tlbi5zb3VyY2UubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgc2hvdWxkIG5vdCBoYXBwZW4gKi9cbiAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gYFVuZXhwZWN0ZWQgdG9rZW4gaW4gYmxvY2sgc2NhbGFyIGhlYWRlcjogJHt0b2tlbi50eXBlfWA7XG4gICAgICAgICAgICAgICAgb25FcnJvcih0b2tlbiwgJ1VORVhQRUNURURfVE9LRU4nLCBtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0cyA9IHRva2VuLnNvdXJjZTtcbiAgICAgICAgICAgICAgICBpZiAodHMgJiYgdHlwZW9mIHRzID09PSAnc3RyaW5nJylcbiAgICAgICAgICAgICAgICAgICAgbGVuZ3RoICs9IHRzLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBtb2RlLCBpbmRlbnQsIGNob21wLCBjb21tZW50LCBsZW5ndGggfTtcbn1cbi8qKiBAcmV0dXJucyBBcnJheSBvZiBsaW5lcyBzcGxpdCB1cCBhcyBgW2luZGVudCwgY29udGVudF1gICovXG5mdW5jdGlvbiBzcGxpdExpbmVzKHNvdXJjZSkge1xuICAgIGNvbnN0IHNwbGl0ID0gc291cmNlLnNwbGl0KC9cXG4oICopLyk7XG4gICAgY29uc3QgZmlyc3QgPSBzcGxpdFswXTtcbiAgICBjb25zdCBtID0gZmlyc3QubWF0Y2goL14oICopLyk7XG4gICAgY29uc3QgbGluZTAgPSBtICYmIG1bMV0gPyBbbVsxXSwgZmlyc3Quc2xpY2UobVsxXS5sZW5ndGgpXSA6IFsnJywgZmlyc3RdO1xuICAgIGNvbnN0IGxpbmVzID0gW2xpbmUwXTtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IHNwbGl0Lmxlbmd0aDsgaSArPSAyKVxuICAgICAgICBsaW5lcy5wdXNoKFtzcGxpdFtpXSwgc3BsaXRbaSArIDFdXSk7XG4gICAgcmV0dXJuIGxpbmVzO1xufVxuXG5leHBvcnQgeyByZXNvbHZlQmxvY2tTY2FsYXIgfTtcbiIsICJpbXBvcnQgeyBTY2FsYXIgfSBmcm9tICcuLi9ub2Rlcy9TY2FsYXIuanMnO1xuaW1wb3J0IHsgcmVzb2x2ZUVuZCB9IGZyb20gJy4vcmVzb2x2ZS1lbmQuanMnO1xuXG5mdW5jdGlvbiByZXNvbHZlRmxvd1NjYWxhcihzY2FsYXIsIHN0cmljdCwgb25FcnJvcikge1xuICAgIGNvbnN0IHsgb2Zmc2V0LCB0eXBlLCBzb3VyY2UsIGVuZCB9ID0gc2NhbGFyO1xuICAgIGxldCBfdHlwZTtcbiAgICBsZXQgdmFsdWU7XG4gICAgY29uc3QgX29uRXJyb3IgPSAocmVsLCBjb2RlLCBtc2cpID0+IG9uRXJyb3Iob2Zmc2V0ICsgcmVsLCBjb2RlLCBtc2cpO1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlICdzY2FsYXInOlxuICAgICAgICAgICAgX3R5cGUgPSBTY2FsYXIuUExBSU47XG4gICAgICAgICAgICB2YWx1ZSA9IHBsYWluVmFsdWUoc291cmNlLCBfb25FcnJvcik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnc2luZ2xlLXF1b3RlZC1zY2FsYXInOlxuICAgICAgICAgICAgX3R5cGUgPSBTY2FsYXIuUVVPVEVfU0lOR0xFO1xuICAgICAgICAgICAgdmFsdWUgPSBzaW5nbGVRdW90ZWRWYWx1ZShzb3VyY2UsIF9vbkVycm9yKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdkb3VibGUtcXVvdGVkLXNjYWxhcic6XG4gICAgICAgICAgICBfdHlwZSA9IFNjYWxhci5RVU9URV9ET1VCTEU7XG4gICAgICAgICAgICB2YWx1ZSA9IGRvdWJsZVF1b3RlZFZhbHVlKHNvdXJjZSwgX29uRXJyb3IpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0IHNob3VsZCBub3QgaGFwcGVuICovXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBvbkVycm9yKHNjYWxhciwgJ1VORVhQRUNURURfVE9LRU4nLCBgRXhwZWN0ZWQgYSBmbG93IHNjYWxhciB2YWx1ZSwgYnV0IGZvdW5kOiAke3R5cGV9YCk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHZhbHVlOiAnJyxcbiAgICAgICAgICAgICAgICB0eXBlOiBudWxsLFxuICAgICAgICAgICAgICAgIGNvbW1lbnQ6ICcnLFxuICAgICAgICAgICAgICAgIHJhbmdlOiBbb2Zmc2V0LCBvZmZzZXQgKyBzb3VyY2UubGVuZ3RoLCBvZmZzZXQgKyBzb3VyY2UubGVuZ3RoXVxuICAgICAgICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgdmFsdWVFbmQgPSBvZmZzZXQgKyBzb3VyY2UubGVuZ3RoO1xuICAgIGNvbnN0IHJlID0gcmVzb2x2ZUVuZChlbmQsIHZhbHVlRW5kLCBzdHJpY3QsIG9uRXJyb3IpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlLFxuICAgICAgICB0eXBlOiBfdHlwZSxcbiAgICAgICAgY29tbWVudDogcmUuY29tbWVudCxcbiAgICAgICAgcmFuZ2U6IFtvZmZzZXQsIHZhbHVlRW5kLCByZS5vZmZzZXRdXG4gICAgfTtcbn1cbmZ1bmN0aW9uIHBsYWluVmFsdWUoc291cmNlLCBvbkVycm9yKSB7XG4gICAgbGV0IGJhZENoYXIgPSAnJztcbiAgICBzd2l0Y2ggKHNvdXJjZVswXSkge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCBzaG91bGQgbm90IGhhcHBlbiAqL1xuICAgICAgICBjYXNlICdcXHQnOlxuICAgICAgICAgICAgYmFkQ2hhciA9ICdhIHRhYiBjaGFyYWN0ZXInO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJywnOlxuICAgICAgICAgICAgYmFkQ2hhciA9ICdmbG93IGluZGljYXRvciBjaGFyYWN0ZXIgLCc7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnJSc6XG4gICAgICAgICAgICBiYWRDaGFyID0gJ2RpcmVjdGl2ZSBpbmRpY2F0b3IgY2hhcmFjdGVyICUnO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3wnOlxuICAgICAgICBjYXNlICc+Jzoge1xuICAgICAgICAgICAgYmFkQ2hhciA9IGBibG9jayBzY2FsYXIgaW5kaWNhdG9yICR7c291cmNlWzBdfWA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdAJzpcbiAgICAgICAgY2FzZSAnYCc6IHtcbiAgICAgICAgICAgIGJhZENoYXIgPSBgcmVzZXJ2ZWQgY2hhcmFjdGVyICR7c291cmNlWzBdfWA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoYmFkQ2hhcilcbiAgICAgICAgb25FcnJvcigwLCAnQkFEX1NDQUxBUl9TVEFSVCcsIGBQbGFpbiB2YWx1ZSBjYW5ub3Qgc3RhcnQgd2l0aCAke2JhZENoYXJ9YCk7XG4gICAgcmV0dXJuIGZvbGRMaW5lcyhzb3VyY2UpO1xufVxuZnVuY3Rpb24gc2luZ2xlUXVvdGVkVmFsdWUoc291cmNlLCBvbkVycm9yKSB7XG4gICAgaWYgKHNvdXJjZVtzb3VyY2UubGVuZ3RoIC0gMV0gIT09IFwiJ1wiIHx8IHNvdXJjZS5sZW5ndGggPT09IDEpXG4gICAgICAgIG9uRXJyb3Ioc291cmNlLmxlbmd0aCwgJ01JU1NJTkdfQ0hBUicsIFwiTWlzc2luZyBjbG9zaW5nICdxdW90ZVwiKTtcbiAgICByZXR1cm4gZm9sZExpbmVzKHNvdXJjZS5zbGljZSgxLCAtMSkpLnJlcGxhY2UoLycnL2csIFwiJ1wiKTtcbn1cbmZ1bmN0aW9uIGZvbGRMaW5lcyhzb3VyY2UpIHtcbiAgICAvKipcbiAgICAgKiBUaGUgbmVnYXRpdmUgbG9va2JlaGluZCBoZXJlIGFuZCBpbiB0aGUgYHJlYCBSZWdFeHAgaXMgdG9cbiAgICAgKiBwcmV2ZW50IGNhdXNpbmcgYSBwb2x5bm9taWFsIHNlYXJjaCB0aW1lIGluIGNlcnRhaW4gY2FzZXMuXG4gICAgICpcbiAgICAgKiBUaGUgdHJ5LWNhdGNoIGlzIGZvciBTYWZhcmksIHdoaWNoIGRvZXNuJ3Qgc3VwcG9ydCB0aGlzIHlldDpcbiAgICAgKiBodHRwczovL2Nhbml1c2UuY29tL2pzLXJlZ2V4cC1sb29rYmVoaW5kXG4gICAgICovXG4gICAgbGV0IGZpcnN0LCBsaW5lO1xuICAgIHRyeSB7XG4gICAgICAgIGZpcnN0ID0gbmV3IFJlZ0V4cCgnKC4qPykoPzwhWyBcXHRdKVsgXFx0XSpcXHI/XFxuJywgJ3N5Jyk7XG4gICAgICAgIGxpbmUgPSBuZXcgUmVnRXhwKCdbIFxcdF0qKC4qPykoPzooPzwhWyBcXHRdKVsgXFx0XSopP1xccj9cXG4nLCAnc3knKTtcbiAgICB9XG4gICAgY2F0Y2ggKF8pIHtcbiAgICAgICAgZmlyc3QgPSAvKC4qPylbIFxcdF0qXFxyP1xcbi9zeTtcbiAgICAgICAgbGluZSA9IC9bIFxcdF0qKC4qPylbIFxcdF0qXFxyP1xcbi9zeTtcbiAgICB9XG4gICAgbGV0IG1hdGNoID0gZmlyc3QuZXhlYyhzb3VyY2UpO1xuICAgIGlmICghbWF0Y2gpXG4gICAgICAgIHJldHVybiBzb3VyY2U7XG4gICAgbGV0IHJlcyA9IG1hdGNoWzFdO1xuICAgIGxldCBzZXAgPSAnICc7XG4gICAgbGV0IHBvcyA9IGZpcnN0Lmxhc3RJbmRleDtcbiAgICBsaW5lLmxhc3RJbmRleCA9IHBvcztcbiAgICB3aGlsZSAoKG1hdGNoID0gbGluZS5leGVjKHNvdXJjZSkpKSB7XG4gICAgICAgIGlmIChtYXRjaFsxXSA9PT0gJycpIHtcbiAgICAgICAgICAgIGlmIChzZXAgPT09ICdcXG4nKVxuICAgICAgICAgICAgICAgIHJlcyArPSBzZXA7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgc2VwID0gJ1xcbic7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXMgKz0gc2VwICsgbWF0Y2hbMV07XG4gICAgICAgICAgICBzZXAgPSAnICc7XG4gICAgICAgIH1cbiAgICAgICAgcG9zID0gbGluZS5sYXN0SW5kZXg7XG4gICAgfVxuICAgIGNvbnN0IGxhc3QgPSAvWyBcXHRdKiguKikvc3k7XG4gICAgbGFzdC5sYXN0SW5kZXggPSBwb3M7XG4gICAgbWF0Y2ggPSBsYXN0LmV4ZWMoc291cmNlKTtcbiAgICByZXR1cm4gcmVzICsgc2VwICsgKChtYXRjaCAmJiBtYXRjaFsxXSkgfHwgJycpO1xufVxuZnVuY3Rpb24gZG91YmxlUXVvdGVkVmFsdWUoc291cmNlLCBvbkVycm9yKSB7XG4gICAgbGV0IHJlcyA9ICcnO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgc291cmNlLmxlbmd0aCAtIDE7ICsraSkge1xuICAgICAgICBjb25zdCBjaCA9IHNvdXJjZVtpXTtcbiAgICAgICAgaWYgKGNoID09PSAnXFxyJyAmJiBzb3VyY2VbaSArIDFdID09PSAnXFxuJylcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBpZiAoY2ggPT09ICdcXG4nKSB7XG4gICAgICAgICAgICBjb25zdCB7IGZvbGQsIG9mZnNldCB9ID0gZm9sZE5ld2xpbmUoc291cmNlLCBpKTtcbiAgICAgICAgICAgIHJlcyArPSBmb2xkO1xuICAgICAgICAgICAgaSA9IG9mZnNldDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjaCA9PT0gJ1xcXFwnKSB7XG4gICAgICAgICAgICBsZXQgbmV4dCA9IHNvdXJjZVsrK2ldO1xuICAgICAgICAgICAgY29uc3QgY2MgPSBlc2NhcGVDb2Rlc1tuZXh0XTtcbiAgICAgICAgICAgIGlmIChjYylcbiAgICAgICAgICAgICAgICByZXMgKz0gY2M7XG4gICAgICAgICAgICBlbHNlIGlmIChuZXh0ID09PSAnXFxuJykge1xuICAgICAgICAgICAgICAgIC8vIHNraXAgZXNjYXBlZCBuZXdsaW5lcywgYnV0IHN0aWxsIHRyaW0gdGhlIGZvbGxvd2luZyBsaW5lXG4gICAgICAgICAgICAgICAgbmV4dCA9IHNvdXJjZVtpICsgMV07XG4gICAgICAgICAgICAgICAgd2hpbGUgKG5leHQgPT09ICcgJyB8fCBuZXh0ID09PSAnXFx0JylcbiAgICAgICAgICAgICAgICAgICAgbmV4dCA9IHNvdXJjZVsrK2kgKyAxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG5leHQgPT09ICdcXHInICYmIHNvdXJjZVtpICsgMV0gPT09ICdcXG4nKSB7XG4gICAgICAgICAgICAgICAgLy8gc2tpcCBlc2NhcGVkIENSTEYgbmV3bGluZXMsIGJ1dCBzdGlsbCB0cmltIHRoZSBmb2xsb3dpbmcgbGluZVxuICAgICAgICAgICAgICAgIG5leHQgPSBzb3VyY2VbKytpICsgMV07XG4gICAgICAgICAgICAgICAgd2hpbGUgKG5leHQgPT09ICcgJyB8fCBuZXh0ID09PSAnXFx0JylcbiAgICAgICAgICAgICAgICAgICAgbmV4dCA9IHNvdXJjZVsrK2kgKyAxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG5leHQgPT09ICd4JyB8fCBuZXh0ID09PSAndScgfHwgbmV4dCA9PT0gJ1UnKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0geyB4OiAyLCB1OiA0LCBVOiA4IH1bbmV4dF07XG4gICAgICAgICAgICAgICAgcmVzICs9IHBhcnNlQ2hhckNvZGUoc291cmNlLCBpICsgMSwgbGVuZ3RoLCBvbkVycm9yKTtcbiAgICAgICAgICAgICAgICBpICs9IGxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJhdyA9IHNvdXJjZS5zdWJzdHIoaSAtIDEsIDIpO1xuICAgICAgICAgICAgICAgIG9uRXJyb3IoaSAtIDEsICdCQURfRFFfRVNDQVBFJywgYEludmFsaWQgZXNjYXBlIHNlcXVlbmNlICR7cmF3fWApO1xuICAgICAgICAgICAgICAgIHJlcyArPSByYXc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2ggPT09ICcgJyB8fCBjaCA9PT0gJ1xcdCcpIHtcbiAgICAgICAgICAgIC8vIHRyaW0gdHJhaWxpbmcgd2hpdGVzcGFjZVxuICAgICAgICAgICAgY29uc3Qgd3NTdGFydCA9IGk7XG4gICAgICAgICAgICBsZXQgbmV4dCA9IHNvdXJjZVtpICsgMV07XG4gICAgICAgICAgICB3aGlsZSAobmV4dCA9PT0gJyAnIHx8IG5leHQgPT09ICdcXHQnKVxuICAgICAgICAgICAgICAgIG5leHQgPSBzb3VyY2VbKytpICsgMV07XG4gICAgICAgICAgICBpZiAobmV4dCAhPT0gJ1xcbicgJiYgIShuZXh0ID09PSAnXFxyJyAmJiBzb3VyY2VbaSArIDJdID09PSAnXFxuJykpXG4gICAgICAgICAgICAgICAgcmVzICs9IGkgPiB3c1N0YXJ0ID8gc291cmNlLnNsaWNlKHdzU3RhcnQsIGkgKyAxKSA6IGNoO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzICs9IGNoO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChzb3VyY2Vbc291cmNlLmxlbmd0aCAtIDFdICE9PSAnXCInIHx8IHNvdXJjZS5sZW5ndGggPT09IDEpXG4gICAgICAgIG9uRXJyb3Ioc291cmNlLmxlbmd0aCwgJ01JU1NJTkdfQ0hBUicsICdNaXNzaW5nIGNsb3NpbmcgXCJxdW90ZScpO1xuICAgIHJldHVybiByZXM7XG59XG4vKipcbiAqIEZvbGQgYSBzaW5nbGUgbmV3bGluZSBpbnRvIGEgc3BhY2UsIG11bHRpcGxlIG5ld2xpbmVzIHRvIE4gLSAxIG5ld2xpbmVzLlxuICogUHJlc3VtZXMgYHNvdXJjZVtvZmZzZXRdID09PSAnXFxuJ2BcbiAqL1xuZnVuY3Rpb24gZm9sZE5ld2xpbmUoc291cmNlLCBvZmZzZXQpIHtcbiAgICBsZXQgZm9sZCA9ICcnO1xuICAgIGxldCBjaCA9IHNvdXJjZVtvZmZzZXQgKyAxXTtcbiAgICB3aGlsZSAoY2ggPT09ICcgJyB8fCBjaCA9PT0gJ1xcdCcgfHwgY2ggPT09ICdcXG4nIHx8IGNoID09PSAnXFxyJykge1xuICAgICAgICBpZiAoY2ggPT09ICdcXHInICYmIHNvdXJjZVtvZmZzZXQgKyAyXSAhPT0gJ1xcbicpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgaWYgKGNoID09PSAnXFxuJylcbiAgICAgICAgICAgIGZvbGQgKz0gJ1xcbic7XG4gICAgICAgIG9mZnNldCArPSAxO1xuICAgICAgICBjaCA9IHNvdXJjZVtvZmZzZXQgKyAxXTtcbiAgICB9XG4gICAgaWYgKCFmb2xkKVxuICAgICAgICBmb2xkID0gJyAnO1xuICAgIHJldHVybiB7IGZvbGQsIG9mZnNldCB9O1xufVxuY29uc3QgZXNjYXBlQ29kZXMgPSB7XG4gICAgJzAnOiAnXFwwJyxcbiAgICBhOiAnXFx4MDcnLFxuICAgIGI6ICdcXGInLFxuICAgIGU6ICdcXHgxYicsXG4gICAgZjogJ1xcZicsXG4gICAgbjogJ1xcbicsXG4gICAgcjogJ1xccicsXG4gICAgdDogJ1xcdCcsXG4gICAgdjogJ1xcdicsXG4gICAgTjogJ1xcdTAwODUnLFxuICAgIF86ICdcXHUwMGEwJyxcbiAgICBMOiAnXFx1MjAyOCcsXG4gICAgUDogJ1xcdTIwMjknLFxuICAgICcgJzogJyAnLFxuICAgICdcIic6ICdcIicsXG4gICAgJy8nOiAnLycsXG4gICAgJ1xcXFwnOiAnXFxcXCcsXG4gICAgJ1xcdCc6ICdcXHQnXG59O1xuZnVuY3Rpb24gcGFyc2VDaGFyQ29kZShzb3VyY2UsIG9mZnNldCwgbGVuZ3RoLCBvbkVycm9yKSB7XG4gICAgY29uc3QgY2MgPSBzb3VyY2Uuc3Vic3RyKG9mZnNldCwgbGVuZ3RoKTtcbiAgICBjb25zdCBvayA9IGNjLmxlbmd0aCA9PT0gbGVuZ3RoICYmIC9eWzAtOWEtZkEtRl0rJC8udGVzdChjYyk7XG4gICAgY29uc3QgY29kZSA9IG9rID8gcGFyc2VJbnQoY2MsIDE2KSA6IE5hTjtcbiAgICBpZiAoaXNOYU4oY29kZSkpIHtcbiAgICAgICAgY29uc3QgcmF3ID0gc291cmNlLnN1YnN0cihvZmZzZXQgLSAyLCBsZW5ndGggKyAyKTtcbiAgICAgICAgb25FcnJvcihvZmZzZXQgLSAyLCAnQkFEX0RRX0VTQ0FQRScsIGBJbnZhbGlkIGVzY2FwZSBzZXF1ZW5jZSAke3Jhd31gKTtcbiAgICAgICAgcmV0dXJuIHJhdztcbiAgICB9XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ29kZVBvaW50KGNvZGUpO1xufVxuXG5leHBvcnQgeyByZXNvbHZlRmxvd1NjYWxhciB9O1xuIiwgImltcG9ydCB7IFNDQUxBUiwgaXNTY2FsYXIgfSBmcm9tICcuLi9ub2Rlcy9Ob2RlLmpzJztcbmltcG9ydCB7IFNjYWxhciB9IGZyb20gJy4uL25vZGVzL1NjYWxhci5qcyc7XG5pbXBvcnQgeyByZXNvbHZlQmxvY2tTY2FsYXIgfSBmcm9tICcuL3Jlc29sdmUtYmxvY2stc2NhbGFyLmpzJztcbmltcG9ydCB7IHJlc29sdmVGbG93U2NhbGFyIH0gZnJvbSAnLi9yZXNvbHZlLWZsb3ctc2NhbGFyLmpzJztcblxuZnVuY3Rpb24gY29tcG9zZVNjYWxhcihjdHgsIHRva2VuLCB0YWdUb2tlbiwgb25FcnJvcikge1xuICAgIGNvbnN0IHsgdmFsdWUsIHR5cGUsIGNvbW1lbnQsIHJhbmdlIH0gPSB0b2tlbi50eXBlID09PSAnYmxvY2stc2NhbGFyJ1xuICAgICAgICA/IHJlc29sdmVCbG9ja1NjYWxhcih0b2tlbiwgY3R4Lm9wdGlvbnMuc3RyaWN0LCBvbkVycm9yKVxuICAgICAgICA6IHJlc29sdmVGbG93U2NhbGFyKHRva2VuLCBjdHgub3B0aW9ucy5zdHJpY3QsIG9uRXJyb3IpO1xuICAgIGNvbnN0IHRhZ05hbWUgPSB0YWdUb2tlblxuICAgICAgICA/IGN0eC5kaXJlY3RpdmVzLnRhZ05hbWUodGFnVG9rZW4uc291cmNlLCBtc2cgPT4gb25FcnJvcih0YWdUb2tlbiwgJ1RBR19SRVNPTFZFX0ZBSUxFRCcsIG1zZykpXG4gICAgICAgIDogbnVsbDtcbiAgICBjb25zdCB0YWcgPSB0YWdUb2tlbiAmJiB0YWdOYW1lXG4gICAgICAgID8gZmluZFNjYWxhclRhZ0J5TmFtZShjdHguc2NoZW1hLCB2YWx1ZSwgdGFnTmFtZSwgdGFnVG9rZW4sIG9uRXJyb3IpXG4gICAgICAgIDogdG9rZW4udHlwZSA9PT0gJ3NjYWxhcidcbiAgICAgICAgICAgID8gZmluZFNjYWxhclRhZ0J5VGVzdChjdHgsIHZhbHVlLCB0b2tlbiwgb25FcnJvcilcbiAgICAgICAgICAgIDogY3R4LnNjaGVtYVtTQ0FMQVJdO1xuICAgIGxldCBzY2FsYXI7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzID0gdGFnLnJlc29sdmUodmFsdWUsIG1zZyA9PiBvbkVycm9yKHRhZ1Rva2VuIHx8IHRva2VuLCAnVEFHX1JFU09MVkVfRkFJTEVEJywgbXNnKSwgY3R4Lm9wdGlvbnMpO1xuICAgICAgICBzY2FsYXIgPSBpc1NjYWxhcihyZXMpID8gcmVzIDogbmV3IFNjYWxhcihyZXMpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc3QgbXNnID0gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpO1xuICAgICAgICBvbkVycm9yKHRhZ1Rva2VuIHx8IHRva2VuLCAnVEFHX1JFU09MVkVfRkFJTEVEJywgbXNnKTtcbiAgICAgICAgc2NhbGFyID0gbmV3IFNjYWxhcih2YWx1ZSk7XG4gICAgfVxuICAgIHNjYWxhci5yYW5nZSA9IHJhbmdlO1xuICAgIHNjYWxhci5zb3VyY2UgPSB2YWx1ZTtcbiAgICBpZiAodHlwZSlcbiAgICAgICAgc2NhbGFyLnR5cGUgPSB0eXBlO1xuICAgIGlmICh0YWdOYW1lKVxuICAgICAgICBzY2FsYXIudGFnID0gdGFnTmFtZTtcbiAgICBpZiAodGFnLmZvcm1hdClcbiAgICAgICAgc2NhbGFyLmZvcm1hdCA9IHRhZy5mb3JtYXQ7XG4gICAgaWYgKGNvbW1lbnQpXG4gICAgICAgIHNjYWxhci5jb21tZW50ID0gY29tbWVudDtcbiAgICByZXR1cm4gc2NhbGFyO1xufVxuZnVuY3Rpb24gZmluZFNjYWxhclRhZ0J5TmFtZShzY2hlbWEsIHZhbHVlLCB0YWdOYW1lLCB0YWdUb2tlbiwgb25FcnJvcikge1xuICAgIHZhciBfYTtcbiAgICBpZiAodGFnTmFtZSA9PT0gJyEnKVxuICAgICAgICByZXR1cm4gc2NoZW1hW1NDQUxBUl07IC8vIG5vbi1zcGVjaWZpYyB0YWdcbiAgICBjb25zdCBtYXRjaFdpdGhUZXN0ID0gW107XG4gICAgZm9yIChjb25zdCB0YWcgb2Ygc2NoZW1hLnRhZ3MpIHtcbiAgICAgICAgaWYgKCF0YWcuY29sbGVjdGlvbiAmJiB0YWcudGFnID09PSB0YWdOYW1lKSB7XG4gICAgICAgICAgICBpZiAodGFnLmRlZmF1bHQgJiYgdGFnLnRlc3QpXG4gICAgICAgICAgICAgICAgbWF0Y2hXaXRoVGVzdC5wdXNoKHRhZyk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhZztcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IHRhZyBvZiBtYXRjaFdpdGhUZXN0KVxuICAgICAgICBpZiAoKF9hID0gdGFnLnRlc3QpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50ZXN0KHZhbHVlKSlcbiAgICAgICAgICAgIHJldHVybiB0YWc7XG4gICAgY29uc3Qga3QgPSBzY2hlbWEua25vd25UYWdzW3RhZ05hbWVdO1xuICAgIGlmIChrdCAmJiAha3QuY29sbGVjdGlvbikge1xuICAgICAgICAvLyBFbnN1cmUgdGhhdCB0aGUga25vd24gdGFnIGlzIGF2YWlsYWJsZSBmb3Igc3RyaW5naWZ5aW5nLFxuICAgICAgICAvLyBidXQgZG9lcyBub3QgZ2V0IHVzZWQgYnkgZGVmYXVsdC5cbiAgICAgICAgc2NoZW1hLnRhZ3MucHVzaChPYmplY3QuYXNzaWduKHt9LCBrdCwgeyBkZWZhdWx0OiBmYWxzZSwgdGVzdDogdW5kZWZpbmVkIH0pKTtcbiAgICAgICAgcmV0dXJuIGt0O1xuICAgIH1cbiAgICBvbkVycm9yKHRhZ1Rva2VuLCAnVEFHX1JFU09MVkVfRkFJTEVEJywgYFVucmVzb2x2ZWQgdGFnOiAke3RhZ05hbWV9YCwgdGFnTmFtZSAhPT0gJ3RhZzp5YW1sLm9yZywyMDAyOnN0cicpO1xuICAgIHJldHVybiBzY2hlbWFbU0NBTEFSXTtcbn1cbmZ1bmN0aW9uIGZpbmRTY2FsYXJUYWdCeVRlc3QoeyBkaXJlY3RpdmVzLCBzY2hlbWEgfSwgdmFsdWUsIHRva2VuLCBvbkVycm9yKSB7XG4gICAgY29uc3QgdGFnID0gc2NoZW1hLnRhZ3MuZmluZCh0YWcgPT4geyB2YXIgX2E7IHJldHVybiB0YWcuZGVmYXVsdCAmJiAoKF9hID0gdGFnLnRlc3QpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50ZXN0KHZhbHVlKSk7IH0pIHx8IHNjaGVtYVtTQ0FMQVJdO1xuICAgIGlmIChzY2hlbWEuY29tcGF0KSB7XG4gICAgICAgIGNvbnN0IGNvbXBhdCA9IHNjaGVtYS5jb21wYXQuZmluZCh0YWcgPT4geyB2YXIgX2E7IHJldHVybiB0YWcuZGVmYXVsdCAmJiAoKF9hID0gdGFnLnRlc3QpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50ZXN0KHZhbHVlKSk7IH0pIHx8XG4gICAgICAgICAgICBzY2hlbWFbU0NBTEFSXTtcbiAgICAgICAgaWYgKHRhZy50YWcgIT09IGNvbXBhdC50YWcpIHtcbiAgICAgICAgICAgIGNvbnN0IHRzID0gZGlyZWN0aXZlcy50YWdTdHJpbmcodGFnLnRhZyk7XG4gICAgICAgICAgICBjb25zdCBjcyA9IGRpcmVjdGl2ZXMudGFnU3RyaW5nKGNvbXBhdC50YWcpO1xuICAgICAgICAgICAgY29uc3QgbXNnID0gYFZhbHVlIG1heSBiZSBwYXJzZWQgYXMgZWl0aGVyICR7dHN9IG9yICR7Y3N9YDtcbiAgICAgICAgICAgIG9uRXJyb3IodG9rZW4sICdUQUdfUkVTT0xWRV9GQUlMRUQnLCBtc2csIHRydWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0YWc7XG59XG5cbmV4cG9ydCB7IGNvbXBvc2VTY2FsYXIgfTtcbiIsICJmdW5jdGlvbiBlbXB0eVNjYWxhclBvc2l0aW9uKG9mZnNldCwgYmVmb3JlLCBwb3MpIHtcbiAgICBpZiAoYmVmb3JlKSB7XG4gICAgICAgIGlmIChwb3MgPT09IG51bGwpXG4gICAgICAgICAgICBwb3MgPSBiZWZvcmUubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBpID0gcG9zIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgICAgIGxldCBzdCA9IGJlZm9yZVtpXTtcbiAgICAgICAgICAgIHN3aXRjaCAoc3QudHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3NwYWNlJzpcbiAgICAgICAgICAgICAgICBjYXNlICdjb21tZW50JzpcbiAgICAgICAgICAgICAgICBjYXNlICduZXdsaW5lJzpcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0IC09IHN0LnNvdXJjZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVGVjaG5pY2FsbHksIGFuIGVtcHR5IHNjYWxhciBpcyBpbW1lZGlhdGVseSBhZnRlciB0aGUgbGFzdCBub24tZW1wdHlcbiAgICAgICAgICAgIC8vIG5vZGUsIGJ1dCBpdCdzIG1vcmUgdXNlZnVsIHRvIHBsYWNlIGl0IGFmdGVyIGFueSB3aGl0ZXNwYWNlLlxuICAgICAgICAgICAgc3QgPSBiZWZvcmVbKytpXTtcbiAgICAgICAgICAgIHdoaWxlICgoc3QgPT09IG51bGwgfHwgc3QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHN0LnR5cGUpID09PSAnc3BhY2UnKSB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ICs9IHN0LnNvdXJjZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgc3QgPSBiZWZvcmVbKytpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvZmZzZXQ7XG59XG5cbmV4cG9ydCB7IGVtcHR5U2NhbGFyUG9zaXRpb24gfTtcbiIsICJpbXBvcnQgeyBBbGlhcyB9IGZyb20gJy4uL25vZGVzL0FsaWFzLmpzJztcbmltcG9ydCB7IGNvbXBvc2VDb2xsZWN0aW9uIH0gZnJvbSAnLi9jb21wb3NlLWNvbGxlY3Rpb24uanMnO1xuaW1wb3J0IHsgY29tcG9zZVNjYWxhciB9IGZyb20gJy4vY29tcG9zZS1zY2FsYXIuanMnO1xuaW1wb3J0IHsgcmVzb2x2ZUVuZCB9IGZyb20gJy4vcmVzb2x2ZS1lbmQuanMnO1xuaW1wb3J0IHsgZW1wdHlTY2FsYXJQb3NpdGlvbiB9IGZyb20gJy4vdXRpbC1lbXB0eS1zY2FsYXItcG9zaXRpb24uanMnO1xuXG5jb25zdCBDTiA9IHsgY29tcG9zZU5vZGUsIGNvbXBvc2VFbXB0eU5vZGUgfTtcbmZ1bmN0aW9uIGNvbXBvc2VOb2RlKGN0eCwgdG9rZW4sIHByb3BzLCBvbkVycm9yKSB7XG4gICAgY29uc3QgeyBzcGFjZUJlZm9yZSwgY29tbWVudCwgYW5jaG9yLCB0YWcgfSA9IHByb3BzO1xuICAgIGxldCBub2RlO1xuICAgIHN3aXRjaCAodG9rZW4udHlwZSkge1xuICAgICAgICBjYXNlICdhbGlhcyc6XG4gICAgICAgICAgICBub2RlID0gY29tcG9zZUFsaWFzKGN0eCwgdG9rZW4sIG9uRXJyb3IpO1xuICAgICAgICAgICAgaWYgKGFuY2hvciB8fCB0YWcpXG4gICAgICAgICAgICAgICAgb25FcnJvcih0b2tlbiwgJ0FMSUFTX1BST1BTJywgJ0FuIGFsaWFzIG5vZGUgbXVzdCBub3Qgc3BlY2lmeSBhbnkgcHJvcGVydGllcycpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3NjYWxhcic6XG4gICAgICAgIGNhc2UgJ3NpbmdsZS1xdW90ZWQtc2NhbGFyJzpcbiAgICAgICAgY2FzZSAnZG91YmxlLXF1b3RlZC1zY2FsYXInOlxuICAgICAgICBjYXNlICdibG9jay1zY2FsYXInOlxuICAgICAgICAgICAgbm9kZSA9IGNvbXBvc2VTY2FsYXIoY3R4LCB0b2tlbiwgdGFnLCBvbkVycm9yKTtcbiAgICAgICAgICAgIGlmIChhbmNob3IpXG4gICAgICAgICAgICAgICAgbm9kZS5hbmNob3IgPSBhbmNob3Iuc291cmNlLnN1YnN0cmluZygxKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdibG9jay1tYXAnOlxuICAgICAgICBjYXNlICdibG9jay1zZXEnOlxuICAgICAgICBjYXNlICdmbG93LWNvbGxlY3Rpb24nOlxuICAgICAgICAgICAgbm9kZSA9IGNvbXBvc2VDb2xsZWN0aW9uKENOLCBjdHgsIHRva2VuLCB0YWcsIG9uRXJyb3IpO1xuICAgICAgICAgICAgaWYgKGFuY2hvcilcbiAgICAgICAgICAgICAgICBub2RlLmFuY2hvciA9IGFuY2hvci5zb3VyY2Uuc3Vic3RyaW5nKDEpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBjb25zb2xlLmxvZyh0b2tlbik7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVuIHRva2VuIHR5cGU6ICR7dG9rZW4udHlwZX1gKTtcbiAgICB9XG4gICAgaWYgKGFuY2hvciAmJiBub2RlLmFuY2hvciA9PT0gJycpXG4gICAgICAgIG9uRXJyb3IoYW5jaG9yLCAnQkFEX0FMSUFTJywgJ0FuY2hvciBjYW5ub3QgYmUgYW4gZW1wdHkgc3RyaW5nJyk7XG4gICAgaWYgKHNwYWNlQmVmb3JlKVxuICAgICAgICBub2RlLnNwYWNlQmVmb3JlID0gdHJ1ZTtcbiAgICBpZiAoY29tbWVudCkge1xuICAgICAgICBpZiAodG9rZW4udHlwZSA9PT0gJ3NjYWxhcicgJiYgdG9rZW4uc291cmNlID09PSAnJylcbiAgICAgICAgICAgIG5vZGUuY29tbWVudCA9IGNvbW1lbnQ7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIG5vZGUuY29tbWVudEJlZm9yZSA9IGNvbW1lbnQ7XG4gICAgfVxuICAgIGlmIChjdHgub3B0aW9ucy5rZWVwU291cmNlVG9rZW5zKVxuICAgICAgICBub2RlLnNyY1Rva2VuID0gdG9rZW47XG4gICAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiBjb21wb3NlRW1wdHlOb2RlKGN0eCwgb2Zmc2V0LCBiZWZvcmUsIHBvcywgeyBzcGFjZUJlZm9yZSwgY29tbWVudCwgYW5jaG9yLCB0YWcgfSwgb25FcnJvcikge1xuICAgIGNvbnN0IHRva2VuID0ge1xuICAgICAgICB0eXBlOiAnc2NhbGFyJyxcbiAgICAgICAgb2Zmc2V0OiBlbXB0eVNjYWxhclBvc2l0aW9uKG9mZnNldCwgYmVmb3JlLCBwb3MpLFxuICAgICAgICBpbmRlbnQ6IC0xLFxuICAgICAgICBzb3VyY2U6ICcnXG4gICAgfTtcbiAgICBjb25zdCBub2RlID0gY29tcG9zZVNjYWxhcihjdHgsIHRva2VuLCB0YWcsIG9uRXJyb3IpO1xuICAgIGlmIChhbmNob3IpIHtcbiAgICAgICAgbm9kZS5hbmNob3IgPSBhbmNob3Iuc291cmNlLnN1YnN0cmluZygxKTtcbiAgICAgICAgaWYgKG5vZGUuYW5jaG9yID09PSAnJylcbiAgICAgICAgICAgIG9uRXJyb3IoYW5jaG9yLCAnQkFEX0FMSUFTJywgJ0FuY2hvciBjYW5ub3QgYmUgYW4gZW1wdHkgc3RyaW5nJyk7XG4gICAgfVxuICAgIGlmIChzcGFjZUJlZm9yZSlcbiAgICAgICAgbm9kZS5zcGFjZUJlZm9yZSA9IHRydWU7XG4gICAgaWYgKGNvbW1lbnQpXG4gICAgICAgIG5vZGUuY29tbWVudCA9IGNvbW1lbnQ7XG4gICAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiBjb21wb3NlQWxpYXMoeyBvcHRpb25zIH0sIHsgb2Zmc2V0LCBzb3VyY2UsIGVuZCB9LCBvbkVycm9yKSB7XG4gICAgY29uc3QgYWxpYXMgPSBuZXcgQWxpYXMoc291cmNlLnN1YnN0cmluZygxKSk7XG4gICAgaWYgKGFsaWFzLnNvdXJjZSA9PT0gJycpXG4gICAgICAgIG9uRXJyb3Iob2Zmc2V0LCAnQkFEX0FMSUFTJywgJ0FsaWFzIGNhbm5vdCBiZSBhbiBlbXB0eSBzdHJpbmcnKTtcbiAgICBjb25zdCB2YWx1ZUVuZCA9IG9mZnNldCArIHNvdXJjZS5sZW5ndGg7XG4gICAgY29uc3QgcmUgPSByZXNvbHZlRW5kKGVuZCwgdmFsdWVFbmQsIG9wdGlvbnMuc3RyaWN0LCBvbkVycm9yKTtcbiAgICBhbGlhcy5yYW5nZSA9IFtvZmZzZXQsIHZhbHVlRW5kLCByZS5vZmZzZXRdO1xuICAgIGlmIChyZS5jb21tZW50KVxuICAgICAgICBhbGlhcy5jb21tZW50ID0gcmUuY29tbWVudDtcbiAgICByZXR1cm4gYWxpYXM7XG59XG5cbmV4cG9ydCB7IGNvbXBvc2VFbXB0eU5vZGUsIGNvbXBvc2VOb2RlIH07XG4iLCAiaW1wb3J0IHsgRG9jdW1lbnQgfSBmcm9tICcuLi9kb2MvRG9jdW1lbnQuanMnO1xuaW1wb3J0IHsgY29tcG9zZU5vZGUsIGNvbXBvc2VFbXB0eU5vZGUgfSBmcm9tICcuL2NvbXBvc2Utbm9kZS5qcyc7XG5pbXBvcnQgeyByZXNvbHZlRW5kIH0gZnJvbSAnLi9yZXNvbHZlLWVuZC5qcyc7XG5pbXBvcnQgeyByZXNvbHZlUHJvcHMgfSBmcm9tICcuL3Jlc29sdmUtcHJvcHMuanMnO1xuXG5mdW5jdGlvbiBjb21wb3NlRG9jKG9wdGlvbnMsIGRpcmVjdGl2ZXMsIHsgb2Zmc2V0LCBzdGFydCwgdmFsdWUsIGVuZCB9LCBvbkVycm9yKSB7XG4gICAgY29uc3Qgb3B0cyA9IE9iamVjdC5hc3NpZ24oeyBkaXJlY3RpdmVzIH0sIG9wdGlvbnMpO1xuICAgIGNvbnN0IGRvYyA9IG5ldyBEb2N1bWVudCh1bmRlZmluZWQsIG9wdHMpO1xuICAgIGNvbnN0IGN0eCA9IHtcbiAgICAgICAgYXRSb290OiB0cnVlLFxuICAgICAgICBkaXJlY3RpdmVzOiBkb2MuZGlyZWN0aXZlcyxcbiAgICAgICAgb3B0aW9uczogZG9jLm9wdGlvbnMsXG4gICAgICAgIHNjaGVtYTogZG9jLnNjaGVtYVxuICAgIH07XG4gICAgY29uc3QgcHJvcHMgPSByZXNvbHZlUHJvcHMoc3RhcnQsIHtcbiAgICAgICAgaW5kaWNhdG9yOiAnZG9jLXN0YXJ0JyxcbiAgICAgICAgbmV4dDogdmFsdWUgfHwgKGVuZCA9PT0gbnVsbCB8fCBlbmQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVuZFswXSksXG4gICAgICAgIG9mZnNldCxcbiAgICAgICAgb25FcnJvcixcbiAgICAgICAgc3RhcnRPbk5ld2xpbmU6IHRydWVcbiAgICB9KTtcbiAgICBpZiAocHJvcHMuZm91bmQpIHtcbiAgICAgICAgZG9jLmRpcmVjdGl2ZXMubWFya2VyID0gdHJ1ZTtcbiAgICAgICAgaWYgKHZhbHVlICYmXG4gICAgICAgICAgICAodmFsdWUudHlwZSA9PT0gJ2Jsb2NrLW1hcCcgfHwgdmFsdWUudHlwZSA9PT0gJ2Jsb2NrLXNlcScpICYmXG4gICAgICAgICAgICAhcHJvcHMuaGFzTmV3bGluZSlcbiAgICAgICAgICAgIG9uRXJyb3IocHJvcHMuZW5kLCAnTUlTU0lOR19DSEFSJywgJ0Jsb2NrIGNvbGxlY3Rpb24gY2Fubm90IHN0YXJ0IG9uIHNhbWUgbGluZSB3aXRoIGRpcmVjdGl2ZXMtZW5kIG1hcmtlcicpO1xuICAgIH1cbiAgICBkb2MuY29udGVudHMgPSB2YWx1ZVxuICAgICAgICA/IGNvbXBvc2VOb2RlKGN0eCwgdmFsdWUsIHByb3BzLCBvbkVycm9yKVxuICAgICAgICA6IGNvbXBvc2VFbXB0eU5vZGUoY3R4LCBwcm9wcy5lbmQsIHN0YXJ0LCBudWxsLCBwcm9wcywgb25FcnJvcik7XG4gICAgY29uc3QgY29udGVudEVuZCA9IGRvYy5jb250ZW50cy5yYW5nZVsyXTtcbiAgICBjb25zdCByZSA9IHJlc29sdmVFbmQoZW5kLCBjb250ZW50RW5kLCBmYWxzZSwgb25FcnJvcik7XG4gICAgaWYgKHJlLmNvbW1lbnQpXG4gICAgICAgIGRvYy5jb21tZW50ID0gcmUuY29tbWVudDtcbiAgICBkb2MucmFuZ2UgPSBbb2Zmc2V0LCBjb250ZW50RW5kLCByZS5vZmZzZXRdO1xuICAgIHJldHVybiBkb2M7XG59XG5cbmV4cG9ydCB7IGNvbXBvc2VEb2MgfTtcbiIsICJpbXBvcnQgeyBEaXJlY3RpdmVzIH0gZnJvbSAnLi4vZG9jL2RpcmVjdGl2ZXMuanMnO1xuaW1wb3J0IHsgRG9jdW1lbnQgfSBmcm9tICcuLi9kb2MvRG9jdW1lbnQuanMnO1xuaW1wb3J0IHsgWUFNTFdhcm5pbmcsIFlBTUxQYXJzZUVycm9yIH0gZnJvbSAnLi4vZXJyb3JzLmpzJztcbmltcG9ydCB7IGlzQ29sbGVjdGlvbiwgaXNQYWlyIH0gZnJvbSAnLi4vbm9kZXMvTm9kZS5qcyc7XG5pbXBvcnQgeyBkZWZhdWx0T3B0aW9ucyB9IGZyb20gJy4uL29wdGlvbnMuanMnO1xuaW1wb3J0IHsgY29tcG9zZURvYyB9IGZyb20gJy4vY29tcG9zZS1kb2MuanMnO1xuaW1wb3J0IHsgcmVzb2x2ZUVuZCB9IGZyb20gJy4vcmVzb2x2ZS1lbmQuanMnO1xuXG5mdW5jdGlvbiBnZXRFcnJvclBvcyhzcmMpIHtcbiAgICBpZiAodHlwZW9mIHNyYyA9PT0gJ251bWJlcicpXG4gICAgICAgIHJldHVybiBbc3JjLCBzcmMgKyAxXTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShzcmMpKVxuICAgICAgICByZXR1cm4gc3JjLmxlbmd0aCA9PT0gMiA/IHNyYyA6IFtzcmNbMF0sIHNyY1sxXV07XG4gICAgY29uc3QgeyBvZmZzZXQsIHNvdXJjZSB9ID0gc3JjO1xuICAgIHJldHVybiBbb2Zmc2V0LCBvZmZzZXQgKyAodHlwZW9mIHNvdXJjZSA9PT0gJ3N0cmluZycgPyBzb3VyY2UubGVuZ3RoIDogMSldO1xufVxuZnVuY3Rpb24gcGFyc2VQcmVsdWRlKHByZWx1ZGUpIHtcbiAgICB2YXIgX2E7XG4gICAgbGV0IGNvbW1lbnQgPSAnJztcbiAgICBsZXQgYXRDb21tZW50ID0gZmFsc2U7XG4gICAgbGV0IGFmdGVyRW1wdHlMaW5lID0gZmFsc2U7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcmVsdWRlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IHNvdXJjZSA9IHByZWx1ZGVbaV07XG4gICAgICAgIHN3aXRjaCAoc291cmNlWzBdKSB7XG4gICAgICAgICAgICBjYXNlICcjJzpcbiAgICAgICAgICAgICAgICBjb21tZW50ICs9XG4gICAgICAgICAgICAgICAgICAgIChjb21tZW50ID09PSAnJyA/ICcnIDogYWZ0ZXJFbXB0eUxpbmUgPyAnXFxuXFxuJyA6ICdcXG4nKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAoc291cmNlLnN1YnN0cmluZygxKSB8fCAnICcpO1xuICAgICAgICAgICAgICAgIGF0Q29tbWVudCA9IHRydWU7XG4gICAgICAgICAgICAgICAgYWZ0ZXJFbXB0eUxpbmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJyUnOlxuICAgICAgICAgICAgICAgIGlmICgoKF9hID0gcHJlbHVkZVtpICsgMV0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVswXSkgIT09ICcjJylcbiAgICAgICAgICAgICAgICAgICAgaSArPSAxO1xuICAgICAgICAgICAgICAgIGF0Q29tbWVudCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAvLyBUaGlzIG1heSBiZSB3cm9uZyBhZnRlciBkb2MtZW5kLCBidXQgaW4gdGhhdCBjYXNlIGl0IGRvZXNuJ3QgbWF0dGVyXG4gICAgICAgICAgICAgICAgaWYgKCFhdENvbW1lbnQpXG4gICAgICAgICAgICAgICAgICAgIGFmdGVyRW1wdHlMaW5lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBhdENvbW1lbnQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBjb21tZW50LCBhZnRlckVtcHR5TGluZSB9O1xufVxuLyoqXG4gKiBDb21wb3NlIGEgc3RyZWFtIG9mIENTVCBub2RlcyBpbnRvIGEgc3RyZWFtIG9mIFlBTUwgRG9jdW1lbnRzLlxuICpcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBDb21wb3NlciwgUGFyc2VyIH0gZnJvbSAneWFtbCdcbiAqXG4gKiBjb25zdCBzcmM6IHN0cmluZyA9IC4uLlxuICogY29uc3QgdG9rZW5zID0gbmV3IFBhcnNlcigpLnBhcnNlKHNyYylcbiAqIGNvbnN0IGRvY3MgPSBuZXcgQ29tcG9zZXIoKS5jb21wb3NlKHRva2VucylcbiAqIGBgYFxuICovXG5jbGFzcyBDb21wb3NlciB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHRoaXMuZG9jID0gbnVsbDtcbiAgICAgICAgdGhpcy5hdERpcmVjdGl2ZXMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5wcmVsdWRlID0gW107XG4gICAgICAgIHRoaXMuZXJyb3JzID0gW107XG4gICAgICAgIHRoaXMud2FybmluZ3MgPSBbXTtcbiAgICAgICAgdGhpcy5vbkVycm9yID0gKHNvdXJjZSwgY29kZSwgbWVzc2FnZSwgd2FybmluZykgPT4ge1xuICAgICAgICAgICAgY29uc3QgcG9zID0gZ2V0RXJyb3JQb3Moc291cmNlKTtcbiAgICAgICAgICAgIGlmICh3YXJuaW5nKVxuICAgICAgICAgICAgICAgIHRoaXMud2FybmluZ3MucHVzaChuZXcgWUFNTFdhcm5pbmcocG9zLCBjb2RlLCBtZXNzYWdlKSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhpcy5lcnJvcnMucHVzaChuZXcgWUFNTFBhcnNlRXJyb3IocG9zLCBjb2RlLCBtZXNzYWdlKSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZGlyZWN0aXZlcyA9IG5ldyBEaXJlY3RpdmVzKHtcbiAgICAgICAgICAgIHZlcnNpb246IG9wdGlvbnMudmVyc2lvbiB8fCBkZWZhdWx0T3B0aW9ucy52ZXJzaW9uXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIH1cbiAgICBkZWNvcmF0ZShkb2MsIGFmdGVyRG9jKSB7XG4gICAgICAgIGNvbnN0IHsgY29tbWVudCwgYWZ0ZXJFbXB0eUxpbmUgfSA9IHBhcnNlUHJlbHVkZSh0aGlzLnByZWx1ZGUpO1xuICAgICAgICAvL2NvbnNvbGUubG9nKHsgZGM6IGRvYy5jb21tZW50LCBwcmVsdWRlLCBjb21tZW50IH0pXG4gICAgICAgIGlmIChjb21tZW50KSB7XG4gICAgICAgICAgICBjb25zdCBkYyA9IGRvYy5jb250ZW50cztcbiAgICAgICAgICAgIGlmIChhZnRlckRvYykge1xuICAgICAgICAgICAgICAgIGRvYy5jb21tZW50ID0gZG9jLmNvbW1lbnQgPyBgJHtkb2MuY29tbWVudH1cXG4ke2NvbW1lbnR9YCA6IGNvbW1lbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChhZnRlckVtcHR5TGluZSB8fCBkb2MuZGlyZWN0aXZlcy5tYXJrZXIgfHwgIWRjKSB7XG4gICAgICAgICAgICAgICAgZG9jLmNvbW1lbnRCZWZvcmUgPSBjb21tZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNDb2xsZWN0aW9uKGRjKSAmJiAhZGMuZmxvdyAmJiBkYy5pdGVtcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgbGV0IGl0ID0gZGMuaXRlbXNbMF07XG4gICAgICAgICAgICAgICAgaWYgKGlzUGFpcihpdCkpXG4gICAgICAgICAgICAgICAgICAgIGl0ID0gaXQua2V5O1xuICAgICAgICAgICAgICAgIGNvbnN0IGNiID0gaXQuY29tbWVudEJlZm9yZTtcbiAgICAgICAgICAgICAgICBpdC5jb21tZW50QmVmb3JlID0gY2IgPyBgJHtjb21tZW50fVxcbiR7Y2J9YCA6IGNvbW1lbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjYiA9IGRjLmNvbW1lbnRCZWZvcmU7XG4gICAgICAgICAgICAgICAgZGMuY29tbWVudEJlZm9yZSA9IGNiID8gYCR7Y29tbWVudH1cXG4ke2NifWAgOiBjb21tZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChhZnRlckRvYykge1xuICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkoZG9jLmVycm9ycywgdGhpcy5lcnJvcnMpO1xuICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkoZG9jLndhcm5pbmdzLCB0aGlzLndhcm5pbmdzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRvYy5lcnJvcnMgPSB0aGlzLmVycm9ycztcbiAgICAgICAgICAgIGRvYy53YXJuaW5ncyA9IHRoaXMud2FybmluZ3M7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wcmVsdWRlID0gW107XG4gICAgICAgIHRoaXMuZXJyb3JzID0gW107XG4gICAgICAgIHRoaXMud2FybmluZ3MgPSBbXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3VycmVudCBzdHJlYW0gc3RhdHVzIGluZm9ybWF0aW9uLlxuICAgICAqXG4gICAgICogTW9zdGx5IHVzZWZ1bCBhdCB0aGUgZW5kIG9mIGlucHV0IGZvciBhbiBlbXB0eSBzdHJlYW0uXG4gICAgICovXG4gICAgc3RyZWFtSW5mbygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvbW1lbnQ6IHBhcnNlUHJlbHVkZSh0aGlzLnByZWx1ZGUpLmNvbW1lbnQsXG4gICAgICAgICAgICBkaXJlY3RpdmVzOiB0aGlzLmRpcmVjdGl2ZXMsXG4gICAgICAgICAgICBlcnJvcnM6IHRoaXMuZXJyb3JzLFxuICAgICAgICAgICAgd2FybmluZ3M6IHRoaXMud2FybmluZ3NcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29tcG9zZSB0b2tlbnMgaW50byBkb2N1bWVudHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZm9yY2VEb2MgLSBJZiB0aGUgc3RyZWFtIGNvbnRhaW5zIG5vIGRvY3VtZW50LCBzdGlsbCBlbWl0IGEgZmluYWwgZG9jdW1lbnQgaW5jbHVkaW5nIGFueSBjb21tZW50cyBhbmQgZGlyZWN0aXZlcyB0aGF0IHdvdWxkIGJlIGFwcGxpZWQgdG8gYSBzdWJzZXF1ZW50IGRvY3VtZW50LlxuICAgICAqIEBwYXJhbSBlbmRPZmZzZXQgLSBTaG91bGQgYmUgc2V0IGlmIGBmb3JjZURvY2AgaXMgYWxzbyBzZXQsIHRvIHNldCB0aGUgZG9jdW1lbnQgcmFuZ2UgZW5kIGFuZCB0byBpbmRpY2F0ZSBlcnJvcnMgY29ycmVjdGx5LlxuICAgICAqL1xuICAgICpjb21wb3NlKHRva2VucywgZm9yY2VEb2MgPSBmYWxzZSwgZW5kT2Zmc2V0ID0gLTEpIHtcbiAgICAgICAgZm9yIChjb25zdCB0b2tlbiBvZiB0b2tlbnMpXG4gICAgICAgICAgICB5aWVsZCogdGhpcy5uZXh0KHRva2VuKTtcbiAgICAgICAgeWllbGQqIHRoaXMuZW5kKGZvcmNlRG9jLCBlbmRPZmZzZXQpO1xuICAgIH1cbiAgICAvKiogQWR2YW5jZSB0aGUgY29tcG9zZXIgYnkgb25lIENTVCB0b2tlbi4gKi9cbiAgICAqbmV4dCh0b2tlbikge1xuICAgICAgICBzd2l0Y2ggKHRva2VuLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2RpcmVjdGl2ZSc6XG4gICAgICAgICAgICAgICAgdGhpcy5kaXJlY3RpdmVzLmFkZCh0b2tlbi5zb3VyY2UsIChvZmZzZXQsIG1lc3NhZ2UsIHdhcm5pbmcpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcG9zID0gZ2V0RXJyb3JQb3ModG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICBwb3NbMF0gKz0gb2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uRXJyb3IocG9zLCAnQkFEX0RJUkVDVElWRScsIG1lc3NhZ2UsIHdhcm5pbmcpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMucHJlbHVkZS5wdXNoKHRva2VuLnNvdXJjZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5hdERpcmVjdGl2ZXMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnZG9jdW1lbnQnOiB7XG4gICAgICAgICAgICAgICAgY29uc3QgZG9jID0gY29tcG9zZURvYyh0aGlzLm9wdGlvbnMsIHRoaXMuZGlyZWN0aXZlcywgdG9rZW4sIHRoaXMub25FcnJvcik7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYXREaXJlY3RpdmVzICYmICFkb2MuZGlyZWN0aXZlcy5tYXJrZXIpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25FcnJvcih0b2tlbiwgJ01JU1NJTkdfQ0hBUicsICdNaXNzaW5nIGRpcmVjdGl2ZXMtZW5kIGluZGljYXRvciBsaW5lJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWNvcmF0ZShkb2MsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5kb2MpXG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMuZG9jO1xuICAgICAgICAgICAgICAgIHRoaXMuZG9jID0gZG9jO1xuICAgICAgICAgICAgICAgIHRoaXMuYXREaXJlY3RpdmVzID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdieXRlLW9yZGVyLW1hcmsnOlxuICAgICAgICAgICAgY2FzZSAnc3BhY2UnOlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnY29tbWVudCc6XG4gICAgICAgICAgICBjYXNlICduZXdsaW5lJzpcbiAgICAgICAgICAgICAgICB0aGlzLnByZWx1ZGUucHVzaCh0b2tlbi5zb3VyY2UpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnZXJyb3InOiB7XG4gICAgICAgICAgICAgICAgY29uc3QgbXNnID0gdG9rZW4uc291cmNlXG4gICAgICAgICAgICAgICAgICAgID8gYCR7dG9rZW4ubWVzc2FnZX06ICR7SlNPTi5zdHJpbmdpZnkodG9rZW4uc291cmNlKX1gXG4gICAgICAgICAgICAgICAgICAgIDogdG9rZW4ubWVzc2FnZTtcbiAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBZQU1MUGFyc2VFcnJvcihnZXRFcnJvclBvcyh0b2tlbiksICdVTkVYUEVDVEVEX1RPS0VOJywgbXNnKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5hdERpcmVjdGl2ZXMgfHwgIXRoaXMuZG9jKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVycm9ycy5wdXNoKGVycm9yKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZG9jLmVycm9ycy5wdXNoKGVycm9yKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ2RvYy1lbmQnOiB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmRvYykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtc2cgPSAnVW5leHBlY3RlZCBkb2MtZW5kIHdpdGhvdXQgcHJlY2VkaW5nIGRvY3VtZW50JztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lcnJvcnMucHVzaChuZXcgWUFNTFBhcnNlRXJyb3IoZ2V0RXJyb3JQb3ModG9rZW4pLCAnVU5FWFBFQ1RFRF9UT0tFTicsIG1zZykpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgZW5kID0gcmVzb2x2ZUVuZCh0b2tlbi5lbmQsIHRva2VuLm9mZnNldCArIHRva2VuLnNvdXJjZS5sZW5ndGgsIHRoaXMuZG9jLm9wdGlvbnMuc3RyaWN0LCB0aGlzLm9uRXJyb3IpO1xuICAgICAgICAgICAgICAgIHRoaXMuZGVjb3JhdGUodGhpcy5kb2MsIHRydWUpO1xuICAgICAgICAgICAgICAgIGlmIChlbmQuY29tbWVudCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkYyA9IHRoaXMuZG9jLmNvbW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZG9jLmNvbW1lbnQgPSBkYyA/IGAke2RjfVxcbiR7ZW5kLmNvbW1lbnR9YCA6IGVuZC5jb21tZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmRvYy5yYW5nZVsyXSA9IGVuZC5vZmZzZXQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRoaXMuZXJyb3JzLnB1c2gobmV3IFlBTUxQYXJzZUVycm9yKGdldEVycm9yUG9zKHRva2VuKSwgJ1VORVhQRUNURURfVE9LRU4nLCBgVW5zdXBwb3J0ZWQgdG9rZW4gJHt0b2tlbi50eXBlfWApKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsIGF0IGVuZCBvZiBpbnB1dCB0byB5aWVsZCBhbnkgcmVtYWluaW5nIGRvY3VtZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIGZvcmNlRG9jIC0gSWYgdGhlIHN0cmVhbSBjb250YWlucyBubyBkb2N1bWVudCwgc3RpbGwgZW1pdCBhIGZpbmFsIGRvY3VtZW50IGluY2x1ZGluZyBhbnkgY29tbWVudHMgYW5kIGRpcmVjdGl2ZXMgdGhhdCB3b3VsZCBiZSBhcHBsaWVkIHRvIGEgc3Vic2VxdWVudCBkb2N1bWVudC5cbiAgICAgKiBAcGFyYW0gZW5kT2Zmc2V0IC0gU2hvdWxkIGJlIHNldCBpZiBgZm9yY2VEb2NgIGlzIGFsc28gc2V0LCB0byBzZXQgdGhlIGRvY3VtZW50IHJhbmdlIGVuZCBhbmQgdG8gaW5kaWNhdGUgZXJyb3JzIGNvcnJlY3RseS5cbiAgICAgKi9cbiAgICAqZW5kKGZvcmNlRG9jID0gZmFsc2UsIGVuZE9mZnNldCA9IC0xKSB7XG4gICAgICAgIGlmICh0aGlzLmRvYykge1xuICAgICAgICAgICAgdGhpcy5kZWNvcmF0ZSh0aGlzLmRvYywgdHJ1ZSk7XG4gICAgICAgICAgICB5aWVsZCB0aGlzLmRvYztcbiAgICAgICAgICAgIHRoaXMuZG9jID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChmb3JjZURvYykge1xuICAgICAgICAgICAgY29uc3Qgb3B0cyA9IE9iamVjdC5hc3NpZ24oeyBkaXJlY3RpdmVzOiB0aGlzLmRpcmVjdGl2ZXMgfSwgdGhpcy5vcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGRvYyA9IG5ldyBEb2N1bWVudCh1bmRlZmluZWQsIG9wdHMpO1xuICAgICAgICAgICAgaWYgKHRoaXMuYXREaXJlY3RpdmVzKVxuICAgICAgICAgICAgICAgIHRoaXMub25FcnJvcihlbmRPZmZzZXQsICdNSVNTSU5HX0NIQVInLCAnTWlzc2luZyBkaXJlY3RpdmVzLWVuZCBpbmRpY2F0b3IgbGluZScpO1xuICAgICAgICAgICAgZG9jLnJhbmdlID0gWzAsIGVuZE9mZnNldCwgZW5kT2Zmc2V0XTtcbiAgICAgICAgICAgIHRoaXMuZGVjb3JhdGUoZG9jLCBmYWxzZSk7XG4gICAgICAgICAgICB5aWVsZCBkb2M7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCB7IENvbXBvc2VyIH07XG4iLCAiZXhwb3J0IHsgY3JlYXRlU2NhbGFyVG9rZW4sIHJlc29sdmVBc1NjYWxhciwgc2V0U2NhbGFyVmFsdWUgfSBmcm9tICcuL2NzdC1zY2FsYXIuanMnO1xuZXhwb3J0IHsgc3RyaW5naWZ5IH0gZnJvbSAnLi9jc3Qtc3RyaW5naWZ5LmpzJztcbmV4cG9ydCB7IHZpc2l0IH0gZnJvbSAnLi9jc3QtdmlzaXQuanMnO1xuXG4vKiogVGhlIGJ5dGUgb3JkZXIgbWFyayAqL1xuY29uc3QgQk9NID0gJ1xcdXtGRUZGfSc7XG4vKiogU3RhcnQgb2YgZG9jLW1vZGUgKi9cbmNvbnN0IERPQ1VNRU5UID0gJ1xceDAyJzsgLy8gQzA6IFN0YXJ0IG9mIFRleHRcbi8qKiBVbmV4cGVjdGVkIGVuZCBvZiBmbG93LW1vZGUgKi9cbmNvbnN0IEZMT1dfRU5EID0gJ1xceDE4JzsgLy8gQzA6IENhbmNlbFxuLyoqIE5leHQgdG9rZW4gaXMgYSBzY2FsYXIgdmFsdWUgKi9cbmNvbnN0IFNDQUxBUiA9ICdcXHgxZic7IC8vIEMwOiBVbml0IFNlcGFyYXRvclxuLyoqIEByZXR1cm5zIGB0cnVlYCBpZiBgdG9rZW5gIGlzIGEgZmxvdyBvciBibG9jayBjb2xsZWN0aW9uICovXG5jb25zdCBpc0NvbGxlY3Rpb24gPSAodG9rZW4pID0+ICEhdG9rZW4gJiYgJ2l0ZW1zJyBpbiB0b2tlbjtcbi8qKiBAcmV0dXJucyBgdHJ1ZWAgaWYgYHRva2VuYCBpcyBhIGZsb3cgb3IgYmxvY2sgc2NhbGFyOyBub3QgYW4gYWxpYXMgKi9cbmNvbnN0IGlzU2NhbGFyID0gKHRva2VuKSA9PiAhIXRva2VuICYmXG4gICAgKHRva2VuLnR5cGUgPT09ICdzY2FsYXInIHx8XG4gICAgICAgIHRva2VuLnR5cGUgPT09ICdzaW5nbGUtcXVvdGVkLXNjYWxhcicgfHxcbiAgICAgICAgdG9rZW4udHlwZSA9PT0gJ2RvdWJsZS1xdW90ZWQtc2NhbGFyJyB8fFxuICAgICAgICB0b2tlbi50eXBlID09PSAnYmxvY2stc2NhbGFyJyk7XG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuLyoqIEdldCBhIHByaW50YWJsZSByZXByZXNlbnRhdGlvbiBvZiBhIGxleGVyIHRva2VuICovXG5mdW5jdGlvbiBwcmV0dHlUb2tlbih0b2tlbikge1xuICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgICAgY2FzZSBCT006XG4gICAgICAgICAgICByZXR1cm4gJzxCT00+JztcbiAgICAgICAgY2FzZSBET0NVTUVOVDpcbiAgICAgICAgICAgIHJldHVybiAnPERPQz4nO1xuICAgICAgICBjYXNlIEZMT1dfRU5EOlxuICAgICAgICAgICAgcmV0dXJuICc8RkxPV19FTkQ+JztcbiAgICAgICAgY2FzZSBTQ0FMQVI6XG4gICAgICAgICAgICByZXR1cm4gJzxTQ0FMQVI+JztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh0b2tlbik7XG4gICAgfVxufVxuLyoqIElkZW50aWZ5IHRoZSB0eXBlIG9mIGEgbGV4ZXIgdG9rZW4uIE1heSByZXR1cm4gYG51bGxgIGZvciB1bmtub3duIHRva2Vucy4gKi9cbmZ1bmN0aW9uIHRva2VuVHlwZShzb3VyY2UpIHtcbiAgICBzd2l0Y2ggKHNvdXJjZSkge1xuICAgICAgICBjYXNlIEJPTTpcbiAgICAgICAgICAgIHJldHVybiAnYnl0ZS1vcmRlci1tYXJrJztcbiAgICAgICAgY2FzZSBET0NVTUVOVDpcbiAgICAgICAgICAgIHJldHVybiAnZG9jLW1vZGUnO1xuICAgICAgICBjYXNlIEZMT1dfRU5EOlxuICAgICAgICAgICAgcmV0dXJuICdmbG93LWVycm9yLWVuZCc7XG4gICAgICAgIGNhc2UgU0NBTEFSOlxuICAgICAgICAgICAgcmV0dXJuICdzY2FsYXInO1xuICAgICAgICBjYXNlICctLS0nOlxuICAgICAgICAgICAgcmV0dXJuICdkb2Mtc3RhcnQnO1xuICAgICAgICBjYXNlICcuLi4nOlxuICAgICAgICAgICAgcmV0dXJuICdkb2MtZW5kJztcbiAgICAgICAgY2FzZSAnJzpcbiAgICAgICAgY2FzZSAnXFxuJzpcbiAgICAgICAgY2FzZSAnXFxyXFxuJzpcbiAgICAgICAgICAgIHJldHVybiAnbmV3bGluZSc7XG4gICAgICAgIGNhc2UgJy0nOlxuICAgICAgICAgICAgcmV0dXJuICdzZXEtaXRlbS1pbmQnO1xuICAgICAgICBjYXNlICc/JzpcbiAgICAgICAgICAgIHJldHVybiAnZXhwbGljaXQta2V5LWluZCc7XG4gICAgICAgIGNhc2UgJzonOlxuICAgICAgICAgICAgcmV0dXJuICdtYXAtdmFsdWUtaW5kJztcbiAgICAgICAgY2FzZSAneyc6XG4gICAgICAgICAgICByZXR1cm4gJ2Zsb3ctbWFwLXN0YXJ0JztcbiAgICAgICAgY2FzZSAnfSc6XG4gICAgICAgICAgICByZXR1cm4gJ2Zsb3ctbWFwLWVuZCc7XG4gICAgICAgIGNhc2UgJ1snOlxuICAgICAgICAgICAgcmV0dXJuICdmbG93LXNlcS1zdGFydCc7XG4gICAgICAgIGNhc2UgJ10nOlxuICAgICAgICAgICAgcmV0dXJuICdmbG93LXNlcS1lbmQnO1xuICAgICAgICBjYXNlICcsJzpcbiAgICAgICAgICAgIHJldHVybiAnY29tbWEnO1xuICAgIH1cbiAgICBzd2l0Y2ggKHNvdXJjZVswXSkge1xuICAgICAgICBjYXNlICcgJzpcbiAgICAgICAgY2FzZSAnXFx0JzpcbiAgICAgICAgICAgIHJldHVybiAnc3BhY2UnO1xuICAgICAgICBjYXNlICcjJzpcbiAgICAgICAgICAgIHJldHVybiAnY29tbWVudCc7XG4gICAgICAgIGNhc2UgJyUnOlxuICAgICAgICAgICAgcmV0dXJuICdkaXJlY3RpdmUtbGluZSc7XG4gICAgICAgIGNhc2UgJyonOlxuICAgICAgICAgICAgcmV0dXJuICdhbGlhcyc7XG4gICAgICAgIGNhc2UgJyYnOlxuICAgICAgICAgICAgcmV0dXJuICdhbmNob3InO1xuICAgICAgICBjYXNlICchJzpcbiAgICAgICAgICAgIHJldHVybiAndGFnJztcbiAgICAgICAgY2FzZSBcIidcIjpcbiAgICAgICAgICAgIHJldHVybiAnc2luZ2xlLXF1b3RlZC1zY2FsYXInO1xuICAgICAgICBjYXNlICdcIic6XG4gICAgICAgICAgICByZXR1cm4gJ2RvdWJsZS1xdW90ZWQtc2NhbGFyJztcbiAgICAgICAgY2FzZSAnfCc6XG4gICAgICAgIGNhc2UgJz4nOlxuICAgICAgICAgICAgcmV0dXJuICdibG9jay1zY2FsYXItaGVhZGVyJztcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5cbmV4cG9ydCB7IEJPTSwgRE9DVU1FTlQsIEZMT1dfRU5ELCBTQ0FMQVIsIGlzQ29sbGVjdGlvbiwgaXNTY2FsYXIsIHByZXR0eVRva2VuLCB0b2tlblR5cGUgfTtcbiIsICJpbXBvcnQgeyByZXNvbHZlQmxvY2tTY2FsYXIgfSBmcm9tICcuLi9jb21wb3NlL3Jlc29sdmUtYmxvY2stc2NhbGFyLmpzJztcbmltcG9ydCB7IHJlc29sdmVGbG93U2NhbGFyIH0gZnJvbSAnLi4vY29tcG9zZS9yZXNvbHZlLWZsb3ctc2NhbGFyLmpzJztcbmltcG9ydCB7IFlBTUxQYXJzZUVycm9yIH0gZnJvbSAnLi4vZXJyb3JzLmpzJztcbmltcG9ydCB7IHN0cmluZ2lmeVN0cmluZyB9IGZyb20gJy4uL3N0cmluZ2lmeS9zdHJpbmdpZnlTdHJpbmcuanMnO1xuXG5mdW5jdGlvbiByZXNvbHZlQXNTY2FsYXIodG9rZW4sIHN0cmljdCA9IHRydWUsIG9uRXJyb3IpIHtcbiAgICBpZiAodG9rZW4pIHtcbiAgICAgICAgY29uc3QgX29uRXJyb3IgPSAocG9zLCBjb2RlLCBtZXNzYWdlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBvZmZzZXQgPSB0eXBlb2YgcG9zID09PSAnbnVtYmVyJyA/IHBvcyA6IEFycmF5LmlzQXJyYXkocG9zKSA/IHBvc1swXSA6IHBvcy5vZmZzZXQ7XG4gICAgICAgICAgICBpZiAob25FcnJvcilcbiAgICAgICAgICAgICAgICBvbkVycm9yKG9mZnNldCwgY29kZSwgbWVzc2FnZSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFlBTUxQYXJzZUVycm9yKFtvZmZzZXQsIG9mZnNldCArIDFdLCBjb2RlLCBtZXNzYWdlKTtcbiAgICAgICAgfTtcbiAgICAgICAgc3dpdGNoICh0b2tlbi50eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdzY2FsYXInOlxuICAgICAgICAgICAgY2FzZSAnc2luZ2xlLXF1b3RlZC1zY2FsYXInOlxuICAgICAgICAgICAgY2FzZSAnZG91YmxlLXF1b3RlZC1zY2FsYXInOlxuICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlRmxvd1NjYWxhcih0b2tlbiwgc3RyaWN0LCBfb25FcnJvcik7XG4gICAgICAgICAgICBjYXNlICdibG9jay1zY2FsYXInOlxuICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlQmxvY2tTY2FsYXIodG9rZW4sIHN0cmljdCwgX29uRXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgc2NhbGFyIHRva2VuIHdpdGggYHZhbHVlYFxuICpcbiAqIFZhbHVlcyB0aGF0IHJlcHJlc2VudCBhbiBhY3R1YWwgc3RyaW5nIGJ1dCBtYXkgYmUgcGFyc2VkIGFzIGEgZGlmZmVyZW50IHR5cGUgc2hvdWxkIHVzZSBhIGB0eXBlYCBvdGhlciB0aGFuIGAnUExBSU4nYCxcbiAqIGFzIHRoaXMgZnVuY3Rpb24gZG9lcyBub3Qgc3VwcG9ydCBhbnkgc2NoZW1hIG9wZXJhdGlvbnMgYW5kIHdvbid0IGNoZWNrIGZvciBzdWNoIGNvbmZsaWN0cy5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgVGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgdmFsdWUsIHdoaWNoIHdpbGwgaGF2ZSBpdHMgY29udGVudCBwcm9wZXJseSBpbmRlbnRlZC5cbiAqIEBwYXJhbSBjb250ZXh0LmVuZCBDb21tZW50cyBhbmQgd2hpdGVzcGFjZSBhZnRlciB0aGUgZW5kIG9mIHRoZSB2YWx1ZSwgb3IgYWZ0ZXIgdGhlIGJsb2NrIHNjYWxhciBoZWFkZXIuIElmIHVuZGVmaW5lZCwgYSBuZXdsaW5lIHdpbGwgYmUgYWRkZWQuXG4gKiBAcGFyYW0gY29udGV4dC5pbXBsaWNpdEtleSBCZWluZyB3aXRoaW4gYW4gaW1wbGljaXQga2V5IG1heSBhZmZlY3QgdGhlIHJlc29sdmVkIHR5cGUgb2YgdGhlIHRva2VuJ3MgdmFsdWUuXG4gKiBAcGFyYW0gY29udGV4dC5pbmRlbnQgVGhlIGluZGVudCBsZXZlbCBvZiB0aGUgdG9rZW4uXG4gKiBAcGFyYW0gY29udGV4dC5pbkZsb3cgSXMgdGhpcyBzY2FsYXIgd2l0aGluIGEgZmxvdyBjb2xsZWN0aW9uPyBUaGlzIG1heSBhZmZlY3QgdGhlIHJlc29sdmVkIHR5cGUgb2YgdGhlIHRva2VuJ3MgdmFsdWUuXG4gKiBAcGFyYW0gY29udGV4dC5vZmZzZXQgVGhlIG9mZnNldCBwb3NpdGlvbiBvZiB0aGUgdG9rZW4uXG4gKiBAcGFyYW0gY29udGV4dC50eXBlIFRoZSBwcmVmZXJyZWQgdHlwZSBvZiB0aGUgc2NhbGFyIHRva2VuLiBJZiB1bmRlZmluZWQsIHRoZSBwcmV2aW91cyB0eXBlIG9mIHRoZSBgdG9rZW5gIHdpbGwgYmUgdXNlZCwgZGVmYXVsdGluZyB0byBgJ1BMQUlOJ2AuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVNjYWxhclRva2VuKHZhbHVlLCBjb250ZXh0KSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHsgaW1wbGljaXRLZXkgPSBmYWxzZSwgaW5kZW50LCBpbkZsb3cgPSBmYWxzZSwgb2Zmc2V0ID0gLTEsIHR5cGUgPSAnUExBSU4nIH0gPSBjb250ZXh0O1xuICAgIGNvbnN0IHNvdXJjZSA9IHN0cmluZ2lmeVN0cmluZyh7IHR5cGUsIHZhbHVlIH0sIHtcbiAgICAgICAgaW1wbGljaXRLZXksXG4gICAgICAgIGluZGVudDogaW5kZW50ID4gMCA/ICcgJy5yZXBlYXQoaW5kZW50KSA6ICcnLFxuICAgICAgICBpbkZsb3csXG4gICAgICAgIG9wdGlvbnM6IHsgYmxvY2tRdW90ZTogdHJ1ZSwgbGluZVdpZHRoOiAtMSB9XG4gICAgfSk7XG4gICAgY29uc3QgZW5kID0gKF9hID0gY29udGV4dC5lbmQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFtcbiAgICAgICAgeyB0eXBlOiAnbmV3bGluZScsIG9mZnNldDogLTEsIGluZGVudCwgc291cmNlOiAnXFxuJyB9XG4gICAgXTtcbiAgICBzd2l0Y2ggKHNvdXJjZVswXSkge1xuICAgICAgICBjYXNlICd8JzpcbiAgICAgICAgY2FzZSAnPic6IHtcbiAgICAgICAgICAgIGNvbnN0IGhlID0gc291cmNlLmluZGV4T2YoJ1xcbicpO1xuICAgICAgICAgICAgY29uc3QgaGVhZCA9IHNvdXJjZS5zdWJzdHJpbmcoMCwgaGUpO1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IHNvdXJjZS5zdWJzdHJpbmcoaGUgKyAxKSArICdcXG4nO1xuICAgICAgICAgICAgY29uc3QgcHJvcHMgPSBbXG4gICAgICAgICAgICAgICAgeyB0eXBlOiAnYmxvY2stc2NhbGFyLWhlYWRlcicsIG9mZnNldCwgaW5kZW50LCBzb3VyY2U6IGhlYWQgfVxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIGlmICghYWRkRW5kdG9CbG9ja1Byb3BzKHByb3BzLCBlbmQpKVxuICAgICAgICAgICAgICAgIHByb3BzLnB1c2goeyB0eXBlOiAnbmV3bGluZScsIG9mZnNldDogLTEsIGluZGVudCwgc291cmNlOiAnXFxuJyB9KTtcbiAgICAgICAgICAgIHJldHVybiB7IHR5cGU6ICdibG9jay1zY2FsYXInLCBvZmZzZXQsIGluZGVudCwgcHJvcHMsIHNvdXJjZTogYm9keSB9O1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ1wiJzpcbiAgICAgICAgICAgIHJldHVybiB7IHR5cGU6ICdkb3VibGUtcXVvdGVkLXNjYWxhcicsIG9mZnNldCwgaW5kZW50LCBzb3VyY2UsIGVuZCB9O1xuICAgICAgICBjYXNlIFwiJ1wiOlxuICAgICAgICAgICAgcmV0dXJuIHsgdHlwZTogJ3NpbmdsZS1xdW90ZWQtc2NhbGFyJywgb2Zmc2V0LCBpbmRlbnQsIHNvdXJjZSwgZW5kIH07XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4geyB0eXBlOiAnc2NhbGFyJywgb2Zmc2V0LCBpbmRlbnQsIHNvdXJjZSwgZW5kIH07XG4gICAgfVxufVxuLyoqXG4gKiBTZXQgdGhlIHZhbHVlIG9mIGB0b2tlbmAgdG8gdGhlIGdpdmVuIHN0cmluZyBgdmFsdWVgLCBvdmVyd3JpdGluZyBhbnkgcHJldmlvdXMgY29udGVudHMgYW5kIHR5cGUgdGhhdCBpdCBtYXkgaGF2ZS5cbiAqXG4gKiBCZXN0IGVmZm9ydHMgYXJlIG1hZGUgdG8gcmV0YWluIGFueSBjb21tZW50cyBwcmV2aW91c2x5IGFzc29jaWF0ZWQgd2l0aCB0aGUgYHRva2VuYCxcbiAqIHRob3VnaCBhbGwgY29udGVudHMgd2l0aGluIGEgY29sbGVjdGlvbidzIGBpdGVtc2Agd2lsbCBiZSBvdmVyd3JpdHRlbi5cbiAqXG4gKiBWYWx1ZXMgdGhhdCByZXByZXNlbnQgYW4gYWN0dWFsIHN0cmluZyBidXQgbWF5IGJlIHBhcnNlZCBhcyBhIGRpZmZlcmVudCB0eXBlIHNob3VsZCB1c2UgYSBgdHlwZWAgb3RoZXIgdGhhbiBgJ1BMQUlOJ2AsXG4gKiBhcyB0aGlzIGZ1bmN0aW9uIGRvZXMgbm90IHN1cHBvcnQgYW55IHNjaGVtYSBvcGVyYXRpb25zIGFuZCB3b24ndCBjaGVjayBmb3Igc3VjaCBjb25mbGljdHMuXG4gKlxuICogQHBhcmFtIHRva2VuIEFueSB0b2tlbi4gSWYgaXQgZG9lcyBub3QgaW5jbHVkZSBhbiBgaW5kZW50YCB2YWx1ZSwgdGhlIHZhbHVlIHdpbGwgYmUgc3RyaW5naWZpZWQgYXMgaWYgaXQgd2VyZSBhbiBpbXBsaWNpdCBrZXkuXG4gKiBAcGFyYW0gdmFsdWUgVGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgdmFsdWUsIHdoaWNoIHdpbGwgaGF2ZSBpdHMgY29udGVudCBwcm9wZXJseSBpbmRlbnRlZC5cbiAqIEBwYXJhbSBjb250ZXh0LmFmdGVyS2V5IEluIG1vc3QgY2FzZXMsIHZhbHVlcyBhZnRlciBhIGtleSBzaG91bGQgaGF2ZSBhbiBhZGRpdGlvbmFsIGxldmVsIG9mIGluZGVudGF0aW9uLlxuICogQHBhcmFtIGNvbnRleHQuaW1wbGljaXRLZXkgQmVpbmcgd2l0aGluIGFuIGltcGxpY2l0IGtleSBtYXkgYWZmZWN0IHRoZSByZXNvbHZlZCB0eXBlIG9mIHRoZSB0b2tlbidzIHZhbHVlLlxuICogQHBhcmFtIGNvbnRleHQuaW5GbG93IEJlaW5nIHdpdGhpbiBhIGZsb3cgY29sbGVjdGlvbiBtYXkgYWZmZWN0IHRoZSByZXNvbHZlZCB0eXBlIG9mIHRoZSB0b2tlbidzIHZhbHVlLlxuICogQHBhcmFtIGNvbnRleHQudHlwZSBUaGUgcHJlZmVycmVkIHR5cGUgb2YgdGhlIHNjYWxhciB0b2tlbi4gSWYgdW5kZWZpbmVkLCB0aGUgcHJldmlvdXMgdHlwZSBvZiB0aGUgYHRva2VuYCB3aWxsIGJlIHVzZWQsIGRlZmF1bHRpbmcgdG8gYCdQTEFJTidgLlxuICovXG5mdW5jdGlvbiBzZXRTY2FsYXJWYWx1ZSh0b2tlbiwgdmFsdWUsIGNvbnRleHQgPSB7fSkge1xuICAgIGxldCB7IGFmdGVyS2V5ID0gZmFsc2UsIGltcGxpY2l0S2V5ID0gZmFsc2UsIGluRmxvdyA9IGZhbHNlLCB0eXBlIH0gPSBjb250ZXh0O1xuICAgIGxldCBpbmRlbnQgPSAnaW5kZW50JyBpbiB0b2tlbiA/IHRva2VuLmluZGVudCA6IG51bGw7XG4gICAgaWYgKGFmdGVyS2V5ICYmIHR5cGVvZiBpbmRlbnQgPT09ICdudW1iZXInKVxuICAgICAgICBpbmRlbnQgKz0gMjtcbiAgICBpZiAoIXR5cGUpXG4gICAgICAgIHN3aXRjaCAodG9rZW4udHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnc2luZ2xlLXF1b3RlZC1zY2FsYXInOlxuICAgICAgICAgICAgICAgIHR5cGUgPSAnUVVPVEVfU0lOR0xFJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2RvdWJsZS1xdW90ZWQtc2NhbGFyJzpcbiAgICAgICAgICAgICAgICB0eXBlID0gJ1FVT1RFX0RPVUJMRSc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdibG9jay1zY2FsYXInOiB7XG4gICAgICAgICAgICAgICAgY29uc3QgaGVhZGVyID0gdG9rZW4ucHJvcHNbMF07XG4gICAgICAgICAgICAgICAgaWYgKGhlYWRlci50eXBlICE9PSAnYmxvY2stc2NhbGFyLWhlYWRlcicpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBibG9jayBzY2FsYXIgaGVhZGVyJyk7XG4gICAgICAgICAgICAgICAgdHlwZSA9IGhlYWRlci5zb3VyY2VbMF0gPT09ICc+JyA/ICdCTE9DS19GT0xERUQnIDogJ0JMT0NLX0xJVEVSQUwnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0eXBlID0gJ1BMQUlOJztcbiAgICAgICAgfVxuICAgIGNvbnN0IHNvdXJjZSA9IHN0cmluZ2lmeVN0cmluZyh7IHR5cGUsIHZhbHVlIH0sIHtcbiAgICAgICAgaW1wbGljaXRLZXk6IGltcGxpY2l0S2V5IHx8IGluZGVudCA9PT0gbnVsbCxcbiAgICAgICAgaW5kZW50OiBpbmRlbnQgIT09IG51bGwgJiYgaW5kZW50ID4gMCA/ICcgJy5yZXBlYXQoaW5kZW50KSA6ICcnLFxuICAgICAgICBpbkZsb3csXG4gICAgICAgIG9wdGlvbnM6IHsgYmxvY2tRdW90ZTogdHJ1ZSwgbGluZVdpZHRoOiAtMSB9XG4gICAgfSk7XG4gICAgc3dpdGNoIChzb3VyY2VbMF0pIHtcbiAgICAgICAgY2FzZSAnfCc6XG4gICAgICAgIGNhc2UgJz4nOlxuICAgICAgICAgICAgc2V0QmxvY2tTY2FsYXJWYWx1ZSh0b2tlbiwgc291cmNlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdcIic6XG4gICAgICAgICAgICBzZXRGbG93U2NhbGFyVmFsdWUodG9rZW4sIHNvdXJjZSwgJ2RvdWJsZS1xdW90ZWQtc2NhbGFyJyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIidcIjpcbiAgICAgICAgICAgIHNldEZsb3dTY2FsYXJWYWx1ZSh0b2tlbiwgc291cmNlLCAnc2luZ2xlLXF1b3RlZC1zY2FsYXInKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgc2V0Rmxvd1NjYWxhclZhbHVlKHRva2VuLCBzb3VyY2UsICdzY2FsYXInKTtcbiAgICB9XG59XG5mdW5jdGlvbiBzZXRCbG9ja1NjYWxhclZhbHVlKHRva2VuLCBzb3VyY2UpIHtcbiAgICBjb25zdCBoZSA9IHNvdXJjZS5pbmRleE9mKCdcXG4nKTtcbiAgICBjb25zdCBoZWFkID0gc291cmNlLnN1YnN0cmluZygwLCBoZSk7XG4gICAgY29uc3QgYm9keSA9IHNvdXJjZS5zdWJzdHJpbmcoaGUgKyAxKSArICdcXG4nO1xuICAgIGlmICh0b2tlbi50eXBlID09PSAnYmxvY2stc2NhbGFyJykge1xuICAgICAgICBjb25zdCBoZWFkZXIgPSB0b2tlbi5wcm9wc1swXTtcbiAgICAgICAgaWYgKGhlYWRlci50eXBlICE9PSAnYmxvY2stc2NhbGFyLWhlYWRlcicpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYmxvY2sgc2NhbGFyIGhlYWRlcicpO1xuICAgICAgICBoZWFkZXIuc291cmNlID0gaGVhZDtcbiAgICAgICAgdG9rZW4uc291cmNlID0gYm9keTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IHsgb2Zmc2V0IH0gPSB0b2tlbjtcbiAgICAgICAgY29uc3QgaW5kZW50ID0gJ2luZGVudCcgaW4gdG9rZW4gPyB0b2tlbi5pbmRlbnQgOiAtMTtcbiAgICAgICAgY29uc3QgcHJvcHMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6ICdibG9jay1zY2FsYXItaGVhZGVyJywgb2Zmc2V0LCBpbmRlbnQsIHNvdXJjZTogaGVhZCB9XG4gICAgICAgIF07XG4gICAgICAgIGlmICghYWRkRW5kdG9CbG9ja1Byb3BzKHByb3BzLCAnZW5kJyBpbiB0b2tlbiA/IHRva2VuLmVuZCA6IHVuZGVmaW5lZCkpXG4gICAgICAgICAgICBwcm9wcy5wdXNoKHsgdHlwZTogJ25ld2xpbmUnLCBvZmZzZXQ6IC0xLCBpbmRlbnQsIHNvdXJjZTogJ1xcbicgfSk7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHRva2VuKSlcbiAgICAgICAgICAgIGlmIChrZXkgIT09ICd0eXBlJyAmJiBrZXkgIT09ICdvZmZzZXQnKVxuICAgICAgICAgICAgICAgIGRlbGV0ZSB0b2tlbltrZXldO1xuICAgICAgICBPYmplY3QuYXNzaWduKHRva2VuLCB7IHR5cGU6ICdibG9jay1zY2FsYXInLCBpbmRlbnQsIHByb3BzLCBzb3VyY2U6IGJvZHkgfSk7XG4gICAgfVxufVxuLyoqIEByZXR1cm5zIGB0cnVlYCBpZiBsYXN0IHRva2VuIGlzIGEgbmV3bGluZSAqL1xuZnVuY3Rpb24gYWRkRW5kdG9CbG9ja1Byb3BzKHByb3BzLCBlbmQpIHtcbiAgICBpZiAoZW5kKVxuICAgICAgICBmb3IgKGNvbnN0IHN0IG9mIGVuZClcbiAgICAgICAgICAgIHN3aXRjaCAoc3QudHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3NwYWNlJzpcbiAgICAgICAgICAgICAgICBjYXNlICdjb21tZW50JzpcbiAgICAgICAgICAgICAgICAgICAgcHJvcHMucHVzaChzdCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ25ld2xpbmUnOlxuICAgICAgICAgICAgICAgICAgICBwcm9wcy5wdXNoKHN0KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gc2V0Rmxvd1NjYWxhclZhbHVlKHRva2VuLCBzb3VyY2UsIHR5cGUpIHtcbiAgICBzd2l0Y2ggKHRva2VuLnR5cGUpIHtcbiAgICAgICAgY2FzZSAnc2NhbGFyJzpcbiAgICAgICAgY2FzZSAnZG91YmxlLXF1b3RlZC1zY2FsYXInOlxuICAgICAgICBjYXNlICdzaW5nbGUtcXVvdGVkLXNjYWxhcic6XG4gICAgICAgICAgICB0b2tlbi50eXBlID0gdHlwZTtcbiAgICAgICAgICAgIHRva2VuLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdibG9jay1zY2FsYXInOiB7XG4gICAgICAgICAgICBjb25zdCBlbmQgPSB0b2tlbi5wcm9wcy5zbGljZSgxKTtcbiAgICAgICAgICAgIGxldCBvYSA9IHNvdXJjZS5sZW5ndGg7XG4gICAgICAgICAgICBpZiAodG9rZW4ucHJvcHNbMF0udHlwZSA9PT0gJ2Jsb2NrLXNjYWxhci1oZWFkZXInKVxuICAgICAgICAgICAgICAgIG9hIC09IHRva2VuLnByb3BzWzBdLnNvdXJjZS5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHRvayBvZiBlbmQpXG4gICAgICAgICAgICAgICAgdG9rLm9mZnNldCArPSBvYTtcbiAgICAgICAgICAgIGRlbGV0ZSB0b2tlbi5wcm9wcztcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odG9rZW4sIHsgdHlwZSwgc291cmNlLCBlbmQgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdibG9jay1tYXAnOlxuICAgICAgICBjYXNlICdibG9jay1zZXEnOiB7XG4gICAgICAgICAgICBjb25zdCBvZmZzZXQgPSB0b2tlbi5vZmZzZXQgKyBzb3VyY2UubGVuZ3RoO1xuICAgICAgICAgICAgY29uc3QgbmwgPSB7IHR5cGU6ICduZXdsaW5lJywgb2Zmc2V0LCBpbmRlbnQ6IHRva2VuLmluZGVudCwgc291cmNlOiAnXFxuJyB9O1xuICAgICAgICAgICAgZGVsZXRlIHRva2VuLml0ZW1zO1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0b2tlbiwgeyB0eXBlLCBzb3VyY2UsIGVuZDogW25sXSB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgIGNvbnN0IGluZGVudCA9ICdpbmRlbnQnIGluIHRva2VuID8gdG9rZW4uaW5kZW50IDogLTE7XG4gICAgICAgICAgICBjb25zdCBlbmQgPSAnZW5kJyBpbiB0b2tlbiAmJiBBcnJheS5pc0FycmF5KHRva2VuLmVuZClcbiAgICAgICAgICAgICAgICA/IHRva2VuLmVuZC5maWx0ZXIoc3QgPT4gc3QudHlwZSA9PT0gJ3NwYWNlJyB8fFxuICAgICAgICAgICAgICAgICAgICBzdC50eXBlID09PSAnY29tbWVudCcgfHxcbiAgICAgICAgICAgICAgICAgICAgc3QudHlwZSA9PT0gJ25ld2xpbmUnKVxuICAgICAgICAgICAgICAgIDogW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyh0b2tlbikpXG4gICAgICAgICAgICAgICAgaWYgKGtleSAhPT0gJ3R5cGUnICYmIGtleSAhPT0gJ29mZnNldCcpXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0b2tlbltrZXldO1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0b2tlbiwgeyB0eXBlLCBpbmRlbnQsIHNvdXJjZSwgZW5kIH0pO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgeyBjcmVhdGVTY2FsYXJUb2tlbiwgcmVzb2x2ZUFzU2NhbGFyLCBzZXRTY2FsYXJWYWx1ZSB9O1xuIiwgIi8qKlxuICogU3RyaW5naWZ5IGEgQ1NUIGRvY3VtZW50LCB0b2tlbiwgb3IgY29sbGVjdGlvbiBpdGVtXG4gKlxuICogRmFpciB3YXJuaW5nOiBUaGlzIGFwcGxpZXMgbm8gdmFsaWRhdGlvbiB3aGF0c29ldmVyLCBhbmRcbiAqIHNpbXBseSBjb25jYXRlbmF0ZXMgdGhlIHNvdXJjZXMgaW4gdGhlaXIgbG9naWNhbCBvcmRlci5cbiAqL1xuY29uc3Qgc3RyaW5naWZ5ID0gKGNzdCkgPT4gJ3R5cGUnIGluIGNzdCA/IHN0cmluZ2lmeVRva2VuKGNzdCkgOiBzdHJpbmdpZnlJdGVtKGNzdCk7XG5mdW5jdGlvbiBzdHJpbmdpZnlUb2tlbih0b2tlbikge1xuICAgIHN3aXRjaCAodG9rZW4udHlwZSkge1xuICAgICAgICBjYXNlICdibG9jay1zY2FsYXInOiB7XG4gICAgICAgICAgICBsZXQgcmVzID0gJyc7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHRvayBvZiB0b2tlbi5wcm9wcylcbiAgICAgICAgICAgICAgICByZXMgKz0gc3RyaW5naWZ5VG9rZW4odG9rKTtcbiAgICAgICAgICAgIHJldHVybiByZXMgKyB0b2tlbi5zb3VyY2U7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnYmxvY2stbWFwJzpcbiAgICAgICAgY2FzZSAnYmxvY2stc2VxJzoge1xuICAgICAgICAgICAgbGV0IHJlcyA9ICcnO1xuICAgICAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIHRva2VuLml0ZW1zKVxuICAgICAgICAgICAgICAgIHJlcyArPSBzdHJpbmdpZnlJdGVtKGl0ZW0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdmbG93LWNvbGxlY3Rpb24nOiB7XG4gICAgICAgICAgICBsZXQgcmVzID0gdG9rZW4uc3RhcnQuc291cmNlO1xuICAgICAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIHRva2VuLml0ZW1zKVxuICAgICAgICAgICAgICAgIHJlcyArPSBzdHJpbmdpZnlJdGVtKGl0ZW0pO1xuICAgICAgICAgICAgZm9yIChjb25zdCBzdCBvZiB0b2tlbi5lbmQpXG4gICAgICAgICAgICAgICAgcmVzICs9IHN0LnNvdXJjZTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnZG9jdW1lbnQnOiB7XG4gICAgICAgICAgICBsZXQgcmVzID0gc3RyaW5naWZ5SXRlbSh0b2tlbik7XG4gICAgICAgICAgICBpZiAodG9rZW4uZW5kKVxuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qgc3Qgb2YgdG9rZW4uZW5kKVxuICAgICAgICAgICAgICAgICAgICByZXMgKz0gc3Quc291cmNlO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICBsZXQgcmVzID0gdG9rZW4uc291cmNlO1xuICAgICAgICAgICAgaWYgKCdlbmQnIGluIHRva2VuICYmIHRva2VuLmVuZClcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHN0IG9mIHRva2VuLmVuZClcbiAgICAgICAgICAgICAgICAgICAgcmVzICs9IHN0LnNvdXJjZTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBzdHJpbmdpZnlJdGVtKHsgc3RhcnQsIGtleSwgc2VwLCB2YWx1ZSB9KSB7XG4gICAgbGV0IHJlcyA9ICcnO1xuICAgIGZvciAoY29uc3Qgc3Qgb2Ygc3RhcnQpXG4gICAgICAgIHJlcyArPSBzdC5zb3VyY2U7XG4gICAgaWYgKGtleSlcbiAgICAgICAgcmVzICs9IHN0cmluZ2lmeVRva2VuKGtleSk7XG4gICAgaWYgKHNlcClcbiAgICAgICAgZm9yIChjb25zdCBzdCBvZiBzZXApXG4gICAgICAgICAgICByZXMgKz0gc3Quc291cmNlO1xuICAgIGlmICh2YWx1ZSlcbiAgICAgICAgcmVzICs9IHN0cmluZ2lmeVRva2VuKHZhbHVlKTtcbiAgICByZXR1cm4gcmVzO1xufVxuXG5leHBvcnQgeyBzdHJpbmdpZnkgfTtcbiIsICJjb25zdCBCUkVBSyA9IFN5bWJvbCgnYnJlYWsgdmlzaXQnKTtcbmNvbnN0IFNLSVAgPSBTeW1ib2woJ3NraXAgY2hpbGRyZW4nKTtcbmNvbnN0IFJFTU9WRSA9IFN5bWJvbCgncmVtb3ZlIGl0ZW0nKTtcbi8qKlxuICogQXBwbHkgYSB2aXNpdG9yIHRvIGEgQ1NUIGRvY3VtZW50IG9yIGl0ZW0uXG4gKlxuICogV2Fsa3MgdGhyb3VnaCB0aGUgdHJlZSAoZGVwdGgtZmlyc3QpIHN0YXJ0aW5nIGZyb20gdGhlIHJvb3QsIGNhbGxpbmcgYVxuICogYHZpc2l0b3JgIGZ1bmN0aW9uIHdpdGggdHdvIGFyZ3VtZW50cyB3aGVuIGVudGVyaW5nIGVhY2ggaXRlbTpcbiAqICAgLSBgaXRlbWA6IFRoZSBjdXJyZW50IGl0ZW0sIHdoaWNoIGluY2x1ZGVkIHRoZSBmb2xsb3dpbmcgbWVtYmVyczpcbiAqICAgICAtIGBzdGFydDogU291cmNlVG9rZW5bXWAgXHUyMDEzIFNvdXJjZSB0b2tlbnMgYmVmb3JlIHRoZSBrZXkgb3IgdmFsdWUsXG4gKiAgICAgICBwb3NzaWJseSBpbmNsdWRpbmcgaXRzIGFuY2hvciBvciB0YWcuXG4gKiAgICAgLSBga2V5PzogVG9rZW4gfCBudWxsYCBcdTIwMTMgU2V0IGZvciBwYWlyIHZhbHVlcy4gTWF5IHRoZW4gYmUgYG51bGxgLCBpZlxuICogICAgICAgdGhlIGtleSBiZWZvcmUgdGhlIGA6YCBzZXBhcmF0b3IgaXMgZW1wdHkuXG4gKiAgICAgLSBgc2VwPzogU291cmNlVG9rZW5bXWAgXHUyMDEzIFNvdXJjZSB0b2tlbnMgYmV0d2VlbiB0aGUga2V5IGFuZCB0aGUgdmFsdWUsXG4gKiAgICAgICB3aGljaCBzaG91bGQgaW5jbHVkZSB0aGUgYDpgIG1hcCB2YWx1ZSBpbmRpY2F0b3IgaWYgYHZhbHVlYCBpcyBzZXQuXG4gKiAgICAgLSBgdmFsdWU/OiBUb2tlbmAgXHUyMDEzIFRoZSB2YWx1ZSBvZiBhIHNlcXVlbmNlIGl0ZW0sIG9yIG9mIGEgbWFwIHBhaXIuXG4gKiAgIC0gYHBhdGhgOiBUaGUgc3RlcHMgZnJvbSB0aGUgcm9vdCB0byB0aGUgY3VycmVudCBub2RlLCBhcyBhbiBhcnJheSBvZlxuICogICAgIGBbJ2tleScgfCAndmFsdWUnLCBudW1iZXJdYCB0dXBsZXMuXG4gKlxuICogVGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgdmlzaXRvciBtYXkgYmUgdXNlZCB0byBjb250cm9sIHRoZSB0cmF2ZXJzYWw6XG4gKiAgIC0gYHVuZGVmaW5lZGAgKGRlZmF1bHQpOiBEbyBub3RoaW5nIGFuZCBjb250aW51ZVxuICogICAtIGB2aXNpdC5TS0lQYDogRG8gbm90IHZpc2l0IHRoZSBjaGlsZHJlbiBvZiB0aGlzIHRva2VuLCBjb250aW51ZSB3aXRoXG4gKiAgICAgIG5leHQgc2libGluZ1xuICogICAtIGB2aXNpdC5CUkVBS2A6IFRlcm1pbmF0ZSB0cmF2ZXJzYWwgY29tcGxldGVseVxuICogICAtIGB2aXNpdC5SRU1PVkVgOiBSZW1vdmUgdGhlIGN1cnJlbnQgaXRlbSwgdGhlbiBjb250aW51ZSB3aXRoIHRoZSBuZXh0IG9uZVxuICogICAtIGBudW1iZXJgOiBTZXQgdGhlIGluZGV4IG9mIHRoZSBuZXh0IHN0ZXAuIFRoaXMgaXMgdXNlZnVsIGVzcGVjaWFsbHkgaWZcbiAqICAgICB0aGUgaW5kZXggb2YgdGhlIGN1cnJlbnQgdG9rZW4gaGFzIGNoYW5nZWQuXG4gKiAgIC0gYGZ1bmN0aW9uYDogRGVmaW5lIHRoZSBuZXh0IHZpc2l0b3IgZm9yIHRoaXMgaXRlbS4gQWZ0ZXIgdGhlIG9yaWdpbmFsXG4gKiAgICAgdmlzaXRvciBpcyBjYWxsZWQgb24gaXRlbSBlbnRyeSwgbmV4dCB2aXNpdG9ycyBhcmUgY2FsbGVkIGFmdGVyIGhhbmRsaW5nXG4gKiAgICAgYSBub24tZW1wdHkgYGtleWAgYW5kIHdoZW4gZXhpdGluZyB0aGUgaXRlbS5cbiAqL1xuZnVuY3Rpb24gdmlzaXQoY3N0LCB2aXNpdG9yKSB7XG4gICAgaWYgKCd0eXBlJyBpbiBjc3QgJiYgY3N0LnR5cGUgPT09ICdkb2N1bWVudCcpXG4gICAgICAgIGNzdCA9IHsgc3RhcnQ6IGNzdC5zdGFydCwgdmFsdWU6IGNzdC52YWx1ZSB9O1xuICAgIF92aXNpdChPYmplY3QuZnJlZXplKFtdKSwgY3N0LCB2aXNpdG9yKTtcbn1cbi8vIFdpdGhvdXQgdGhlIGBhcyBzeW1ib2xgIGNhc3RzLCBUUyBkZWNsYXJlcyB0aGVzZSBpbiB0aGUgYHZpc2l0YFxuLy8gbmFtZXNwYWNlIHVzaW5nIGB2YXJgLCBidXQgdGhlbiBjb21wbGFpbnMgYWJvdXQgdGhhdCBiZWNhdXNlXG4vLyBgdW5pcXVlIHN5bWJvbGAgbXVzdCBiZSBgY29uc3RgLlxuLyoqIFRlcm1pbmF0ZSB2aXNpdCB0cmF2ZXJzYWwgY29tcGxldGVseSAqL1xudmlzaXQuQlJFQUsgPSBCUkVBSztcbi8qKiBEbyBub3QgdmlzaXQgdGhlIGNoaWxkcmVuIG9mIHRoZSBjdXJyZW50IGl0ZW0gKi9cbnZpc2l0LlNLSVAgPSBTS0lQO1xuLyoqIFJlbW92ZSB0aGUgY3VycmVudCBpdGVtICovXG52aXNpdC5SRU1PVkUgPSBSRU1PVkU7XG4vKiogRmluZCB0aGUgaXRlbSBhdCBgcGF0aGAgZnJvbSBgY3N0YCBhcyB0aGUgcm9vdCAqL1xudmlzaXQuaXRlbUF0UGF0aCA9IChjc3QsIHBhdGgpID0+IHtcbiAgICBsZXQgaXRlbSA9IGNzdDtcbiAgICBmb3IgKGNvbnN0IFtmaWVsZCwgaW5kZXhdIG9mIHBhdGgpIHtcbiAgICAgICAgY29uc3QgdG9rID0gaXRlbSAmJiBpdGVtW2ZpZWxkXTtcbiAgICAgICAgaWYgKHRvayAmJiAnaXRlbXMnIGluIHRvaykge1xuICAgICAgICAgICAgaXRlbSA9IHRvay5pdGVtc1tpbmRleF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIGl0ZW07XG59O1xuLyoqXG4gKiBHZXQgdGhlIGltbWVkaWF0ZSBwYXJlbnQgY29sbGVjdGlvbiBvZiB0aGUgaXRlbSBhdCBgcGF0aGAgZnJvbSBgY3N0YCBhcyB0aGUgcm9vdC5cbiAqXG4gKiBUaHJvd3MgYW4gZXJyb3IgaWYgdGhlIGNvbGxlY3Rpb24gaXMgbm90IGZvdW5kLCB3aGljaCBzaG91bGQgbmV2ZXIgaGFwcGVuIGlmIHRoZSBpdGVtIGl0c2VsZiBleGlzdHMuXG4gKi9cbnZpc2l0LnBhcmVudENvbGxlY3Rpb24gPSAoY3N0LCBwYXRoKSA9PiB7XG4gICAgY29uc3QgcGFyZW50ID0gdmlzaXQuaXRlbUF0UGF0aChjc3QsIHBhdGguc2xpY2UoMCwgLTEpKTtcbiAgICBjb25zdCBmaWVsZCA9IHBhdGhbcGF0aC5sZW5ndGggLSAxXVswXTtcbiAgICBjb25zdCBjb2xsID0gcGFyZW50ICYmIHBhcmVudFtmaWVsZF07XG4gICAgaWYgKGNvbGwgJiYgJ2l0ZW1zJyBpbiBjb2xsKVxuICAgICAgICByZXR1cm4gY29sbDtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1BhcmVudCBjb2xsZWN0aW9uIG5vdCBmb3VuZCcpO1xufTtcbmZ1bmN0aW9uIF92aXNpdChwYXRoLCBpdGVtLCB2aXNpdG9yKSB7XG4gICAgbGV0IGN0cmwgPSB2aXNpdG9yKGl0ZW0sIHBhdGgpO1xuICAgIGlmICh0eXBlb2YgY3RybCA9PT0gJ3N5bWJvbCcpXG4gICAgICAgIHJldHVybiBjdHJsO1xuICAgIGZvciAoY29uc3QgZmllbGQgb2YgWydrZXknLCAndmFsdWUnXSkge1xuICAgICAgICBjb25zdCB0b2tlbiA9IGl0ZW1bZmllbGRdO1xuICAgICAgICBpZiAodG9rZW4gJiYgJ2l0ZW1zJyBpbiB0b2tlbikge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b2tlbi5pdGVtcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNpID0gX3Zpc2l0KE9iamVjdC5mcmVlemUocGF0aC5jb25jYXQoW1tmaWVsZCwgaV1dKSksIHRva2VuLml0ZW1zW2ldLCB2aXNpdG9yKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNpID09PSAnbnVtYmVyJylcbiAgICAgICAgICAgICAgICAgICAgaSA9IGNpIC0gMTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjaSA9PT0gQlJFQUspXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBCUkVBSztcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjaSA9PT0gUkVNT1ZFKSB7XG4gICAgICAgICAgICAgICAgICAgIHRva2VuLml0ZW1zLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgaSAtPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgY3RybCA9PT0gJ2Z1bmN0aW9uJyAmJiBmaWVsZCA9PT0gJ2tleScpXG4gICAgICAgICAgICAgICAgY3RybCA9IGN0cmwoaXRlbSwgcGF0aCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHR5cGVvZiBjdHJsID09PSAnZnVuY3Rpb24nID8gY3RybChpdGVtLCBwYXRoKSA6IGN0cmw7XG59XG5cbmV4cG9ydCB7IHZpc2l0IH07XG4iLCAiaW1wb3J0IHsgQk9NLCBET0NVTUVOVCwgRkxPV19FTkQsIFNDQUxBUiB9IGZyb20gJy4vY3N0LmpzJztcblxuLypcblNUQVJUIC0+IHN0cmVhbVxuXG5zdHJlYW1cbiAgZGlyZWN0aXZlIC0+IGxpbmUtZW5kIC0+IHN0cmVhbVxuICBpbmRlbnQgKyBsaW5lLWVuZCAtPiBzdHJlYW1cbiAgW2Vsc2VdIC0+IGxpbmUtc3RhcnRcblxubGluZS1lbmRcbiAgY29tbWVudCAtPiBsaW5lLWVuZFxuICBuZXdsaW5lIC0+IC5cbiAgaW5wdXQtZW5kIC0+IEVORFxuXG5saW5lLXN0YXJ0XG4gIGRvYy1zdGFydCAtPiBkb2NcbiAgZG9jLWVuZCAtPiBzdHJlYW1cbiAgW2Vsc2VdIC0+IGluZGVudCAtPiBibG9jay1zdGFydFxuXG5ibG9jay1zdGFydFxuICBzZXEtaXRlbS1zdGFydCAtPiBibG9jay1zdGFydFxuICBleHBsaWNpdC1rZXktc3RhcnQgLT4gYmxvY2stc3RhcnRcbiAgbWFwLXZhbHVlLXN0YXJ0IC0+IGJsb2NrLXN0YXJ0XG4gIFtlbHNlXSAtPiBkb2NcblxuZG9jXG4gIGxpbmUtZW5kIC0+IGxpbmUtc3RhcnRcbiAgc3BhY2VzIC0+IGRvY1xuICBhbmNob3IgLT4gZG9jXG4gIHRhZyAtPiBkb2NcbiAgZmxvdy1zdGFydCAtPiBmbG93IC0+IGRvY1xuICBmbG93LWVuZCAtPiBlcnJvciAtPiBkb2NcbiAgc2VxLWl0ZW0tc3RhcnQgLT4gZXJyb3IgLT4gZG9jXG4gIGV4cGxpY2l0LWtleS1zdGFydCAtPiBlcnJvciAtPiBkb2NcbiAgbWFwLXZhbHVlLXN0YXJ0IC0+IGRvY1xuICBhbGlhcyAtPiBkb2NcbiAgcXVvdGUtc3RhcnQgLT4gcXVvdGVkLXNjYWxhciAtPiBkb2NcbiAgYmxvY2stc2NhbGFyLWhlYWRlciAtPiBsaW5lLWVuZCAtPiBibG9jay1zY2FsYXIobWluKSAtPiBsaW5lLXN0YXJ0XG4gIFtlbHNlXSAtPiBwbGFpbi1zY2FsYXIoZmFsc2UsIG1pbikgLT4gZG9jXG5cbmZsb3dcbiAgbGluZS1lbmQgLT4gZmxvd1xuICBzcGFjZXMgLT4gZmxvd1xuICBhbmNob3IgLT4gZmxvd1xuICB0YWcgLT4gZmxvd1xuICBmbG93LXN0YXJ0IC0+IGZsb3cgLT4gZmxvd1xuICBmbG93LWVuZCAtPiAuXG4gIHNlcS1pdGVtLXN0YXJ0IC0+IGVycm9yIC0+IGZsb3dcbiAgZXhwbGljaXQta2V5LXN0YXJ0IC0+IGZsb3dcbiAgbWFwLXZhbHVlLXN0YXJ0IC0+IGZsb3dcbiAgYWxpYXMgLT4gZmxvd1xuICBxdW90ZS1zdGFydCAtPiBxdW90ZWQtc2NhbGFyIC0+IGZsb3dcbiAgY29tbWEgLT4gZmxvd1xuICBbZWxzZV0gLT4gcGxhaW4tc2NhbGFyKHRydWUsIDApIC0+IGZsb3dcblxucXVvdGVkLXNjYWxhclxuICBxdW90ZS1lbmQgLT4gLlxuICBbZWxzZV0gLT4gcXVvdGVkLXNjYWxhclxuXG5ibG9jay1zY2FsYXIobWluKVxuICBuZXdsaW5lICsgcGVlayhpbmRlbnQgPCBtaW4pIC0+IC5cbiAgW2Vsc2VdIC0+IGJsb2NrLXNjYWxhcihtaW4pXG5cbnBsYWluLXNjYWxhcihpcy1mbG93LCBtaW4pXG4gIHNjYWxhci1lbmQoaXMtZmxvdykgLT4gLlxuICBwZWVrKG5ld2xpbmUgKyAoaW5kZW50IDwgbWluKSkgLT4gLlxuICBbZWxzZV0gLT4gcGxhaW4tc2NhbGFyKG1pbilcbiovXG5mdW5jdGlvbiBpc0VtcHR5KGNoKSB7XG4gICAgc3dpdGNoIChjaCkge1xuICAgICAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgICAgY2FzZSAnICc6XG4gICAgICAgIGNhc2UgJ1xcbic6XG4gICAgICAgIGNhc2UgJ1xccic6XG4gICAgICAgIGNhc2UgJ1xcdCc6XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5jb25zdCBoZXhEaWdpdHMgPSAnMDEyMzQ1Njc4OUFCQ0RFRmFiY2RlZicuc3BsaXQoJycpO1xuY29uc3QgdGFnQ2hhcnMgPSBcIjAxMjM0NTY3ODlBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6LSM7Lz86QCY9KyRfLiF+KicoKVwiLnNwbGl0KCcnKTtcbmNvbnN0IGludmFsaWRGbG93U2NhbGFyQ2hhcnMgPSAnLFtde30nLnNwbGl0KCcnKTtcbmNvbnN0IGludmFsaWRBbmNob3JDaGFycyA9ICcgLFtde31cXG5cXHJcXHQnLnNwbGl0KCcnKTtcbmNvbnN0IGlzTm90QW5jaG9yQ2hhciA9IChjaCkgPT4gIWNoIHx8IGludmFsaWRBbmNob3JDaGFycy5pbmNsdWRlcyhjaCk7XG4vKipcbiAqIFNwbGl0cyBhbiBpbnB1dCBzdHJpbmcgaW50byBsZXhpY2FsIHRva2VucywgaS5lLiBzbWFsbGVyIHN0cmluZ3MgdGhhdCBhcmVcbiAqIGVhc2lseSBpZGVudGlmaWFibGUgYnkgYHRva2Vucy50b2tlblR5cGUoKWAuXG4gKlxuICogTGV4aW5nIHN0YXJ0cyBhbHdheXMgaW4gYSBcInN0cmVhbVwiIGNvbnRleHQuIEluY29tcGxldGUgaW5wdXQgbWF5IGJlIGJ1ZmZlcmVkXG4gKiB1bnRpbCBhIGNvbXBsZXRlIHRva2VuIGNhbiBiZSBlbWl0dGVkLlxuICpcbiAqIEluIGFkZGl0aW9uIHRvIHNsaWNlcyBvZiB0aGUgb3JpZ2luYWwgaW5wdXQsIHRoZSBmb2xsb3dpbmcgY29udHJvbCBjaGFyYWN0ZXJzXG4gKiBtYXkgYWxzbyBiZSBlbWl0dGVkOlxuICpcbiAqIC0gYFxceDAyYCAoU3RhcnQgb2YgVGV4dCk6IEEgZG9jdW1lbnQgc3RhcnRzIHdpdGggdGhlIG5leHQgdG9rZW5cbiAqIC0gYFxceDE4YCAoQ2FuY2VsKTogVW5leHBlY3RlZCBlbmQgb2YgZmxvdy1tb2RlIChpbmRpY2F0ZXMgYW4gZXJyb3IpXG4gKiAtIGBcXHgxZmAgKFVuaXQgU2VwYXJhdG9yKTogTmV4dCB0b2tlbiBpcyBhIHNjYWxhciB2YWx1ZVxuICogLSBgXFx1e0ZFRkZ9YCAoQnl0ZSBvcmRlciBtYXJrKTogRW1pdHRlZCBzZXBhcmF0ZWx5IG91dHNpZGUgZG9jdW1lbnRzXG4gKi9cbmNsYXNzIExleGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZsYWcgaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBlbmQgb2YgdGhlIGN1cnJlbnQgYnVmZmVyIG1hcmtzIHRoZSBlbmQgb2ZcbiAgICAgICAgICogYWxsIGlucHV0XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmF0RW5kID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFeHBsaWNpdCBpbmRlbnQgc2V0IGluIGJsb2NrIHNjYWxhciBoZWFkZXIsIGFzIGFuIG9mZnNldCBmcm9tIHRoZSBjdXJyZW50XG4gICAgICAgICAqIG1pbmltdW0gaW5kZW50LCBzbyBlLmcuIHNldCB0byAxIGZyb20gYSBoZWFkZXIgYHwyK2AuIFNldCB0byAtMSBpZiBub3RcbiAgICAgICAgICogZXhwbGljaXRseSBzZXQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmJsb2NrU2NhbGFySW5kZW50ID0gLTE7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBCbG9jayBzY2FsYXJzIHRoYXQgaW5jbHVkZSBhICsgKGtlZXApIGNob21waW5nIGluZGljYXRvciBpbiB0aGVpciBoZWFkZXJcbiAgICAgICAgICogaW5jbHVkZSB0cmFpbGluZyBlbXB0eSBsaW5lcywgd2hpY2ggYXJlIG90aGVyd2lzZSBleGNsdWRlZCBmcm9tIHRoZVxuICAgICAgICAgKiBzY2FsYXIncyBjb250ZW50cy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYmxvY2tTY2FsYXJLZWVwID0gZmFsc2U7XG4gICAgICAgIC8qKiBDdXJyZW50IGlucHV0ICovXG4gICAgICAgIHRoaXMuYnVmZmVyID0gJyc7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGbGFnIG5vdGluZyB3aGV0aGVyIHRoZSBtYXAgdmFsdWUgaW5kaWNhdG9yIDogY2FuIGltbWVkaWF0ZWx5IGZvbGxvdyB0aGlzXG4gICAgICAgICAqIG5vZGUgd2l0aGluIGEgZmxvdyBjb250ZXh0LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5mbG93S2V5ID0gZmFsc2U7XG4gICAgICAgIC8qKiBDb3VudCBvZiBzdXJyb3VuZGluZyBmbG93IGNvbGxlY3Rpb24gbGV2ZWxzLiAqL1xuICAgICAgICB0aGlzLmZsb3dMZXZlbCA9IDA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNaW5pbXVtIGxldmVsIG9mIGluZGVudGF0aW9uIHJlcXVpcmVkIGZvciBuZXh0IGxpbmVzIHRvIGJlIHBhcnNlZCBhcyBhXG4gICAgICAgICAqIHBhcnQgb2YgdGhlIGN1cnJlbnQgc2NhbGFyIHZhbHVlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pbmRlbnROZXh0ID0gMDtcbiAgICAgICAgLyoqIEluZGVudGF0aW9uIGxldmVsIG9mIHRoZSBjdXJyZW50IGxpbmUuICovXG4gICAgICAgIHRoaXMuaW5kZW50VmFsdWUgPSAwO1xuICAgICAgICAvKiogUG9zaXRpb24gb2YgdGhlIG5leHQgXFxuIGNoYXJhY3Rlci4gKi9cbiAgICAgICAgdGhpcy5saW5lRW5kUG9zID0gbnVsbDtcbiAgICAgICAgLyoqIFN0b3JlcyB0aGUgc3RhdGUgb2YgdGhlIGxleGVyIGlmIHJlYWNoaW5nIHRoZSBlbmQgb2YgaW5jcG9tcGxldGUgaW5wdXQgKi9cbiAgICAgICAgdGhpcy5uZXh0ID0gbnVsbDtcbiAgICAgICAgLyoqIEEgcG9pbnRlciB0byBgYnVmZmVyYDsgdGhlIGN1cnJlbnQgcG9zaXRpb24gb2YgdGhlIGxleGVyLiAqL1xuICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlIFlBTUwgdG9rZW5zIGZyb20gdGhlIGBzb3VyY2VgIHN0cmluZy4gSWYgYGluY29tcGxldGVgLFxuICAgICAqIGEgcGFydCBvZiB0aGUgbGFzdCBsaW5lIG1heSBiZSBsZWZ0IGFzIGEgYnVmZmVyIGZvciB0aGUgbmV4dCBjYWxsLlxuICAgICAqXG4gICAgICogQHJldHVybnMgQSBnZW5lcmF0b3Igb2YgbGV4aWNhbCB0b2tlbnNcbiAgICAgKi9cbiAgICAqbGV4KHNvdXJjZSwgaW5jb21wbGV0ZSA9IGZhbHNlKSB7XG4gICAgICAgIGlmIChzb3VyY2UpIHtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyID0gdGhpcy5idWZmZXIgPyB0aGlzLmJ1ZmZlciArIHNvdXJjZSA6IHNvdXJjZTtcbiAgICAgICAgICAgIHRoaXMubGluZUVuZFBvcyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hdEVuZCA9ICFpbmNvbXBsZXRlO1xuICAgICAgICBsZXQgbmV4dCA9IHRoaXMubmV4dCB8fCAnc3RyZWFtJztcbiAgICAgICAgd2hpbGUgKG5leHQgJiYgKGluY29tcGxldGUgfHwgdGhpcy5oYXNDaGFycygxKSkpXG4gICAgICAgICAgICBuZXh0ID0geWllbGQqIHRoaXMucGFyc2VOZXh0KG5leHQpO1xuICAgIH1cbiAgICBhdExpbmVFbmQoKSB7XG4gICAgICAgIGxldCBpID0gdGhpcy5wb3M7XG4gICAgICAgIGxldCBjaCA9IHRoaXMuYnVmZmVyW2ldO1xuICAgICAgICB3aGlsZSAoY2ggPT09ICcgJyB8fCBjaCA9PT0gJ1xcdCcpXG4gICAgICAgICAgICBjaCA9IHRoaXMuYnVmZmVyWysraV07XG4gICAgICAgIGlmICghY2ggfHwgY2ggPT09ICcjJyB8fCBjaCA9PT0gJ1xcbicpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKGNoID09PSAnXFxyJylcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJ1ZmZlcltpICsgMV0gPT09ICdcXG4nO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNoYXJBdChuKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJ1ZmZlclt0aGlzLnBvcyArIG5dO1xuICAgIH1cbiAgICBjb250aW51ZVNjYWxhcihvZmZzZXQpIHtcbiAgICAgICAgbGV0IGNoID0gdGhpcy5idWZmZXJbb2Zmc2V0XTtcbiAgICAgICAgaWYgKHRoaXMuaW5kZW50TmV4dCA+IDApIHtcbiAgICAgICAgICAgIGxldCBpbmRlbnQgPSAwO1xuICAgICAgICAgICAgd2hpbGUgKGNoID09PSAnICcpXG4gICAgICAgICAgICAgICAgY2ggPSB0aGlzLmJ1ZmZlclsrK2luZGVudCArIG9mZnNldF07XG4gICAgICAgICAgICBpZiAoY2ggPT09ICdcXHInKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dCA9IHRoaXMuYnVmZmVyW2luZGVudCArIG9mZnNldCArIDFdO1xuICAgICAgICAgICAgICAgIGlmIChuZXh0ID09PSAnXFxuJyB8fCAoIW5leHQgJiYgIXRoaXMuYXRFbmQpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2Zmc2V0ICsgaW5kZW50ICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjaCA9PT0gJ1xcbicgfHwgaW5kZW50ID49IHRoaXMuaW5kZW50TmV4dCB8fCAoIWNoICYmICF0aGlzLmF0RW5kKVxuICAgICAgICAgICAgICAgID8gb2Zmc2V0ICsgaW5kZW50XG4gICAgICAgICAgICAgICAgOiAtMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2ggPT09ICctJyB8fCBjaCA9PT0gJy4nKSB7XG4gICAgICAgICAgICBjb25zdCBkdCA9IHRoaXMuYnVmZmVyLnN1YnN0cihvZmZzZXQsIDMpO1xuICAgICAgICAgICAgaWYgKChkdCA9PT0gJy0tLScgfHwgZHQgPT09ICcuLi4nKSAmJiBpc0VtcHR5KHRoaXMuYnVmZmVyW29mZnNldCArIDNdKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9mZnNldDtcbiAgICB9XG4gICAgZ2V0TGluZSgpIHtcbiAgICAgICAgbGV0IGVuZCA9IHRoaXMubGluZUVuZFBvcztcbiAgICAgICAgaWYgKHR5cGVvZiBlbmQgIT09ICdudW1iZXInIHx8IChlbmQgIT09IC0xICYmIGVuZCA8IHRoaXMucG9zKSkge1xuICAgICAgICAgICAgZW5kID0gdGhpcy5idWZmZXIuaW5kZXhPZignXFxuJywgdGhpcy5wb3MpO1xuICAgICAgICAgICAgdGhpcy5saW5lRW5kUG9zID0gZW5kO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbmQgPT09IC0xKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXRFbmQgPyB0aGlzLmJ1ZmZlci5zdWJzdHJpbmcodGhpcy5wb3MpIDogbnVsbDtcbiAgICAgICAgaWYgKHRoaXMuYnVmZmVyW2VuZCAtIDFdID09PSAnXFxyJylcbiAgICAgICAgICAgIGVuZCAtPSAxO1xuICAgICAgICByZXR1cm4gdGhpcy5idWZmZXIuc3Vic3RyaW5nKHRoaXMucG9zLCBlbmQpO1xuICAgIH1cbiAgICBoYXNDaGFycyhuKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBvcyArIG4gPD0gdGhpcy5idWZmZXIubGVuZ3RoO1xuICAgIH1cbiAgICBzZXROZXh0KHN0YXRlKSB7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gdGhpcy5idWZmZXIuc3Vic3RyaW5nKHRoaXMucG9zKTtcbiAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgICAgICB0aGlzLmxpbmVFbmRQb3MgPSBudWxsO1xuICAgICAgICB0aGlzLm5leHQgPSBzdGF0ZTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHBlZWsobikge1xuICAgICAgICByZXR1cm4gdGhpcy5idWZmZXIuc3Vic3RyKHRoaXMucG9zLCBuKTtcbiAgICB9XG4gICAgKnBhcnNlTmV4dChuZXh0KSB7XG4gICAgICAgIHN3aXRjaCAobmV4dCkge1xuICAgICAgICAgICAgY2FzZSAnc3RyZWFtJzpcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQqIHRoaXMucGFyc2VTdHJlYW0oKTtcbiAgICAgICAgICAgIGNhc2UgJ2xpbmUtc3RhcnQnOlxuICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCogdGhpcy5wYXJzZUxpbmVTdGFydCgpO1xuICAgICAgICAgICAgY2FzZSAnYmxvY2stc3RhcnQnOlxuICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCogdGhpcy5wYXJzZUJsb2NrU3RhcnQoKTtcbiAgICAgICAgICAgIGNhc2UgJ2RvYyc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkKiB0aGlzLnBhcnNlRG9jdW1lbnQoKTtcbiAgICAgICAgICAgIGNhc2UgJ2Zsb3cnOlxuICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCogdGhpcy5wYXJzZUZsb3dDb2xsZWN0aW9uKCk7XG4gICAgICAgICAgICBjYXNlICdxdW90ZWQtc2NhbGFyJzpcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQqIHRoaXMucGFyc2VRdW90ZWRTY2FsYXIoKTtcbiAgICAgICAgICAgIGNhc2UgJ2Jsb2NrLXNjYWxhcic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkKiB0aGlzLnBhcnNlQmxvY2tTY2FsYXIoKTtcbiAgICAgICAgICAgIGNhc2UgJ3BsYWluLXNjYWxhcic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkKiB0aGlzLnBhcnNlUGxhaW5TY2FsYXIoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAqcGFyc2VTdHJlYW0oKSB7XG4gICAgICAgIGxldCBsaW5lID0gdGhpcy5nZXRMaW5lKCk7XG4gICAgICAgIGlmIChsaW5lID09PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0TmV4dCgnc3RyZWFtJyk7XG4gICAgICAgIGlmIChsaW5lWzBdID09PSBCT00pIHtcbiAgICAgICAgICAgIHlpZWxkKiB0aGlzLnB1c2hDb3VudCgxKTtcbiAgICAgICAgICAgIGxpbmUgPSBsaW5lLnN1YnN0cmluZygxKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGluZVswXSA9PT0gJyUnKSB7XG4gICAgICAgICAgICBsZXQgZGlyRW5kID0gbGluZS5sZW5ndGg7XG4gICAgICAgICAgICBjb25zdCBjcyA9IGxpbmUuaW5kZXhPZignIycpO1xuICAgICAgICAgICAgaWYgKGNzICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoID0gbGluZVtjcyAtIDFdO1xuICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJyAnIHx8IGNoID09PSAnXFx0JylcbiAgICAgICAgICAgICAgICAgICAgZGlyRW5kID0gY3MgLSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaCA9IGxpbmVbZGlyRW5kIC0gMV07XG4gICAgICAgICAgICAgICAgaWYgKGNoID09PSAnICcgfHwgY2ggPT09ICdcXHQnKVxuICAgICAgICAgICAgICAgICAgICBkaXJFbmQgLT0gMTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbiA9ICh5aWVsZCogdGhpcy5wdXNoQ291bnQoZGlyRW5kKSkgKyAoeWllbGQqIHRoaXMucHVzaFNwYWNlcyh0cnVlKSk7XG4gICAgICAgICAgICB5aWVsZCogdGhpcy5wdXNoQ291bnQobGluZS5sZW5ndGggLSBuKTsgLy8gcG9zc2libGUgY29tbWVudFxuICAgICAgICAgICAgdGhpcy5wdXNoTmV3bGluZSgpO1xuICAgICAgICAgICAgcmV0dXJuICdzdHJlYW0nO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmF0TGluZUVuZCgpKSB7XG4gICAgICAgICAgICBjb25zdCBzcCA9IHlpZWxkKiB0aGlzLnB1c2hTcGFjZXModHJ1ZSk7XG4gICAgICAgICAgICB5aWVsZCogdGhpcy5wdXNoQ291bnQobGluZS5sZW5ndGggLSBzcCk7XG4gICAgICAgICAgICB5aWVsZCogdGhpcy5wdXNoTmV3bGluZSgpO1xuICAgICAgICAgICAgcmV0dXJuICdzdHJlYW0nO1xuICAgICAgICB9XG4gICAgICAgIHlpZWxkIERPQ1VNRU5UO1xuICAgICAgICByZXR1cm4geWllbGQqIHRoaXMucGFyc2VMaW5lU3RhcnQoKTtcbiAgICB9XG4gICAgKnBhcnNlTGluZVN0YXJ0KCkge1xuICAgICAgICBjb25zdCBjaCA9IHRoaXMuY2hhckF0KDApO1xuICAgICAgICBpZiAoIWNoICYmICF0aGlzLmF0RW5kKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0TmV4dCgnbGluZS1zdGFydCcpO1xuICAgICAgICBpZiAoY2ggPT09ICctJyB8fCBjaCA9PT0gJy4nKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuYXRFbmQgJiYgIXRoaXMuaGFzQ2hhcnMoNCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0TmV4dCgnbGluZS1zdGFydCcpO1xuICAgICAgICAgICAgY29uc3QgcyA9IHRoaXMucGVlaygzKTtcbiAgICAgICAgICAgIGlmIChzID09PSAnLS0tJyAmJiBpc0VtcHR5KHRoaXMuY2hhckF0KDMpKSkge1xuICAgICAgICAgICAgICAgIHlpZWxkKiB0aGlzLnB1c2hDb3VudCgzKTtcbiAgICAgICAgICAgICAgICB0aGlzLmluZGVudFZhbHVlID0gMDtcbiAgICAgICAgICAgICAgICB0aGlzLmluZGVudE5leHQgPSAwO1xuICAgICAgICAgICAgICAgIHJldHVybiAnZG9jJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHMgPT09ICcuLi4nICYmIGlzRW1wdHkodGhpcy5jaGFyQXQoMykpKSB7XG4gICAgICAgICAgICAgICAgeWllbGQqIHRoaXMucHVzaENvdW50KDMpO1xuICAgICAgICAgICAgICAgIHJldHVybiAnc3RyZWFtJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmluZGVudFZhbHVlID0geWllbGQqIHRoaXMucHVzaFNwYWNlcyhmYWxzZSk7XG4gICAgICAgIGlmICh0aGlzLmluZGVudE5leHQgPiB0aGlzLmluZGVudFZhbHVlICYmICFpc0VtcHR5KHRoaXMuY2hhckF0KDEpKSlcbiAgICAgICAgICAgIHRoaXMuaW5kZW50TmV4dCA9IHRoaXMuaW5kZW50VmFsdWU7XG4gICAgICAgIHJldHVybiB5aWVsZCogdGhpcy5wYXJzZUJsb2NrU3RhcnQoKTtcbiAgICB9XG4gICAgKnBhcnNlQmxvY2tTdGFydCgpIHtcbiAgICAgICAgY29uc3QgW2NoMCwgY2gxXSA9IHRoaXMucGVlaygyKTtcbiAgICAgICAgaWYgKCFjaDEgJiYgIXRoaXMuYXRFbmQpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZXROZXh0KCdibG9jay1zdGFydCcpO1xuICAgICAgICBpZiAoKGNoMCA9PT0gJy0nIHx8IGNoMCA9PT0gJz8nIHx8IGNoMCA9PT0gJzonKSAmJiBpc0VtcHR5KGNoMSkpIHtcbiAgICAgICAgICAgIGNvbnN0IG4gPSAoeWllbGQqIHRoaXMucHVzaENvdW50KDEpKSArICh5aWVsZCogdGhpcy5wdXNoU3BhY2VzKHRydWUpKTtcbiAgICAgICAgICAgIHRoaXMuaW5kZW50TmV4dCA9IHRoaXMuaW5kZW50VmFsdWUgKyAxO1xuICAgICAgICAgICAgdGhpcy5pbmRlbnRWYWx1ZSArPSBuO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkKiB0aGlzLnBhcnNlQmxvY2tTdGFydCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnZG9jJztcbiAgICB9XG4gICAgKnBhcnNlRG9jdW1lbnQoKSB7XG4gICAgICAgIHlpZWxkKiB0aGlzLnB1c2hTcGFjZXModHJ1ZSk7XG4gICAgICAgIGNvbnN0IGxpbmUgPSB0aGlzLmdldExpbmUoKTtcbiAgICAgICAgaWYgKGxpbmUgPT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZXROZXh0KCdkb2MnKTtcbiAgICAgICAgbGV0IG4gPSB5aWVsZCogdGhpcy5wdXNoSW5kaWNhdG9ycygpO1xuICAgICAgICBzd2l0Y2ggKGxpbmVbbl0pIHtcbiAgICAgICAgICAgIGNhc2UgJyMnOlxuICAgICAgICAgICAgICAgIHlpZWxkKiB0aGlzLnB1c2hDb3VudChsaW5lLmxlbmd0aCAtIG4pO1xuICAgICAgICAgICAgLy8gZmFsbHRocm91Z2hcbiAgICAgICAgICAgIGNhc2UgdW5kZWZpbmVkOlxuICAgICAgICAgICAgICAgIHlpZWxkKiB0aGlzLnB1c2hOZXdsaW5lKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkKiB0aGlzLnBhcnNlTGluZVN0YXJ0KCk7XG4gICAgICAgICAgICBjYXNlICd7JzpcbiAgICAgICAgICAgIGNhc2UgJ1snOlxuICAgICAgICAgICAgICAgIHlpZWxkKiB0aGlzLnB1c2hDb3VudCgxKTtcbiAgICAgICAgICAgICAgICB0aGlzLmZsb3dLZXkgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLmZsb3dMZXZlbCA9IDE7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdmbG93JztcbiAgICAgICAgICAgIGNhc2UgJ30nOlxuICAgICAgICAgICAgY2FzZSAnXSc6XG4gICAgICAgICAgICAgICAgLy8gdGhpcyBpcyBhbiBlcnJvclxuICAgICAgICAgICAgICAgIHlpZWxkKiB0aGlzLnB1c2hDb3VudCgxKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2RvYyc7XG4gICAgICAgICAgICBjYXNlICcqJzpcbiAgICAgICAgICAgICAgICB5aWVsZCogdGhpcy5wdXNoVW50aWwoaXNOb3RBbmNob3JDaGFyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2RvYyc7XG4gICAgICAgICAgICBjYXNlICdcIic6XG4gICAgICAgICAgICBjYXNlIFwiJ1wiOlxuICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCogdGhpcy5wYXJzZVF1b3RlZFNjYWxhcigpO1xuICAgICAgICAgICAgY2FzZSAnfCc6XG4gICAgICAgICAgICBjYXNlICc+JzpcbiAgICAgICAgICAgICAgICBuICs9IHlpZWxkKiB0aGlzLnBhcnNlQmxvY2tTY2FsYXJIZWFkZXIoKTtcbiAgICAgICAgICAgICAgICBuICs9IHlpZWxkKiB0aGlzLnB1c2hTcGFjZXModHJ1ZSk7XG4gICAgICAgICAgICAgICAgeWllbGQqIHRoaXMucHVzaENvdW50KGxpbmUubGVuZ3RoIC0gbik7XG4gICAgICAgICAgICAgICAgeWllbGQqIHRoaXMucHVzaE5ld2xpbmUoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQqIHRoaXMucGFyc2VCbG9ja1NjYWxhcigpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQqIHRoaXMucGFyc2VQbGFpblNjYWxhcigpO1xuICAgICAgICB9XG4gICAgfVxuICAgICpwYXJzZUZsb3dDb2xsZWN0aW9uKCkge1xuICAgICAgICBsZXQgbmwsIHNwO1xuICAgICAgICBsZXQgaW5kZW50ID0gLTE7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIG5sID0geWllbGQqIHRoaXMucHVzaE5ld2xpbmUoKTtcbiAgICAgICAgICAgIHNwID0geWllbGQqIHRoaXMucHVzaFNwYWNlcyh0cnVlKTtcbiAgICAgICAgICAgIGlmIChubCA+IDApXG4gICAgICAgICAgICAgICAgdGhpcy5pbmRlbnRWYWx1ZSA9IGluZGVudCA9IHNwO1xuICAgICAgICB9IHdoaWxlIChubCArIHNwID4gMCk7XG4gICAgICAgIGNvbnN0IGxpbmUgPSB0aGlzLmdldExpbmUoKTtcbiAgICAgICAgaWYgKGxpbmUgPT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZXROZXh0KCdmbG93Jyk7XG4gICAgICAgIGlmICgoaW5kZW50ICE9PSAtMSAmJiBpbmRlbnQgPCB0aGlzLmluZGVudE5leHQgJiYgbGluZVswXSAhPT0gJyMnKSB8fFxuICAgICAgICAgICAgKGluZGVudCA9PT0gMCAmJlxuICAgICAgICAgICAgICAgIChsaW5lLnN0YXJ0c1dpdGgoJy0tLScpIHx8IGxpbmUuc3RhcnRzV2l0aCgnLi4uJykpICYmXG4gICAgICAgICAgICAgICAgaXNFbXB0eShsaW5lWzNdKSkpIHtcbiAgICAgICAgICAgIC8vIEFsbG93aW5nIGZvciB0aGUgdGVybWluYWwgXSBvciB9IGF0IHRoZSBzYW1lIChyYXRoZXIgdGhhbiBncmVhdGVyKVxuICAgICAgICAgICAgLy8gaW5kZW50IGxldmVsIGFzIHRoZSBpbml0aWFsIFsgb3IgeyBpcyB0ZWNobmljYWxseSBpbnZhbGlkLCBidXRcbiAgICAgICAgICAgIC8vIGZhaWxpbmcgaGVyZSB3b3VsZCBiZSBzdXJwcmlzaW5nIHRvIHVzZXJzLlxuICAgICAgICAgICAgY29uc3QgYXRGbG93RW5kTWFya2VyID0gaW5kZW50ID09PSB0aGlzLmluZGVudE5leHQgLSAxICYmXG4gICAgICAgICAgICAgICAgdGhpcy5mbG93TGV2ZWwgPT09IDEgJiZcbiAgICAgICAgICAgICAgICAobGluZVswXSA9PT0gJ10nIHx8IGxpbmVbMF0gPT09ICd9Jyk7XG4gICAgICAgICAgICBpZiAoIWF0Rmxvd0VuZE1hcmtlcikge1xuICAgICAgICAgICAgICAgIC8vIHRoaXMgaXMgYW4gZXJyb3JcbiAgICAgICAgICAgICAgICB0aGlzLmZsb3dMZXZlbCA9IDA7XG4gICAgICAgICAgICAgICAgeWllbGQgRkxPV19FTkQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkKiB0aGlzLnBhcnNlTGluZVN0YXJ0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG4gPSAwO1xuICAgICAgICB3aGlsZSAobGluZVtuXSA9PT0gJywnKSB7XG4gICAgICAgICAgICBuICs9IHlpZWxkKiB0aGlzLnB1c2hDb3VudCgxKTtcbiAgICAgICAgICAgIG4gKz0geWllbGQqIHRoaXMucHVzaFNwYWNlcyh0cnVlKTtcbiAgICAgICAgICAgIHRoaXMuZmxvd0tleSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIG4gKz0geWllbGQqIHRoaXMucHVzaEluZGljYXRvcnMoKTtcbiAgICAgICAgc3dpdGNoIChsaW5lW25dKSB7XG4gICAgICAgICAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2Zsb3cnO1xuICAgICAgICAgICAgY2FzZSAnIyc6XG4gICAgICAgICAgICAgICAgeWllbGQqIHRoaXMucHVzaENvdW50KGxpbmUubGVuZ3RoIC0gbik7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdmbG93JztcbiAgICAgICAgICAgIGNhc2UgJ3snOlxuICAgICAgICAgICAgY2FzZSAnWyc6XG4gICAgICAgICAgICAgICAgeWllbGQqIHRoaXMucHVzaENvdW50KDEpO1xuICAgICAgICAgICAgICAgIHRoaXMuZmxvd0tleSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMuZmxvd0xldmVsICs9IDE7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdmbG93JztcbiAgICAgICAgICAgIGNhc2UgJ30nOlxuICAgICAgICAgICAgY2FzZSAnXSc6XG4gICAgICAgICAgICAgICAgeWllbGQqIHRoaXMucHVzaENvdW50KDEpO1xuICAgICAgICAgICAgICAgIHRoaXMuZmxvd0tleSA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5mbG93TGV2ZWwgLT0gMTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5mbG93TGV2ZWwgPyAnZmxvdycgOiAnZG9jJztcbiAgICAgICAgICAgIGNhc2UgJyonOlxuICAgICAgICAgICAgICAgIHlpZWxkKiB0aGlzLnB1c2hVbnRpbChpc05vdEFuY2hvckNoYXIpO1xuICAgICAgICAgICAgICAgIHJldHVybiAnZmxvdyc7XG4gICAgICAgICAgICBjYXNlICdcIic6XG4gICAgICAgICAgICBjYXNlIFwiJ1wiOlxuICAgICAgICAgICAgICAgIHRoaXMuZmxvd0tleSA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkKiB0aGlzLnBhcnNlUXVvdGVkU2NhbGFyKCk7XG4gICAgICAgICAgICBjYXNlICc6Jzoge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5leHQgPSB0aGlzLmNoYXJBdCgxKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5mbG93S2V5IHx8IGlzRW1wdHkobmV4dCkgfHwgbmV4dCA9PT0gJywnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmxvd0tleSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCogdGhpcy5wdXNoQ291bnQoMSk7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkKiB0aGlzLnB1c2hTcGFjZXModHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnZmxvdyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZmFsbHRocm91Z2hcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhpcy5mbG93S2V5ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkKiB0aGlzLnBhcnNlUGxhaW5TY2FsYXIoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAqcGFyc2VRdW90ZWRTY2FsYXIoKSB7XG4gICAgICAgIGNvbnN0IHF1b3RlID0gdGhpcy5jaGFyQXQoMCk7XG4gICAgICAgIGxldCBlbmQgPSB0aGlzLmJ1ZmZlci5pbmRleE9mKHF1b3RlLCB0aGlzLnBvcyArIDEpO1xuICAgICAgICBpZiAocXVvdGUgPT09IFwiJ1wiKSB7XG4gICAgICAgICAgICB3aGlsZSAoZW5kICE9PSAtMSAmJiB0aGlzLmJ1ZmZlcltlbmQgKyAxXSA9PT0gXCInXCIpXG4gICAgICAgICAgICAgICAgZW5kID0gdGhpcy5idWZmZXIuaW5kZXhPZihcIidcIiwgZW5kICsgMik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBkb3VibGUtcXVvdGVcbiAgICAgICAgICAgIHdoaWxlIChlbmQgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgbGV0IG4gPSAwO1xuICAgICAgICAgICAgICAgIHdoaWxlICh0aGlzLmJ1ZmZlcltlbmQgLSAxIC0gbl0gPT09ICdcXFxcJylcbiAgICAgICAgICAgICAgICAgICAgbiArPSAxO1xuICAgICAgICAgICAgICAgIGlmIChuICUgMiA9PT0gMClcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZW5kID0gdGhpcy5idWZmZXIuaW5kZXhPZignXCInLCBlbmQgKyAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBPbmx5IGxvb2tpbmcgZm9yIG5ld2xpbmVzIHdpdGhpbiB0aGUgcXVvdGVzXG4gICAgICAgIGNvbnN0IHFiID0gdGhpcy5idWZmZXIuc3Vic3RyaW5nKDAsIGVuZCk7XG4gICAgICAgIGxldCBubCA9IHFiLmluZGV4T2YoJ1xcbicsIHRoaXMucG9zKTtcbiAgICAgICAgaWYgKG5sICE9PSAtMSkge1xuICAgICAgICAgICAgd2hpbGUgKG5sICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNzID0gdGhpcy5jb250aW51ZVNjYWxhcihubCArIDEpO1xuICAgICAgICAgICAgICAgIGlmIChjcyA9PT0gLTEpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIG5sID0gcWIuaW5kZXhPZignXFxuJywgY3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5sICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIC8vIHRoaXMgaXMgYW4gZXJyb3IgY2F1c2VkIGJ5IGFuIHVuZXhwZWN0ZWQgdW5pbmRlbnRcbiAgICAgICAgICAgICAgICBlbmQgPSBubCAtIChxYltubCAtIDFdID09PSAnXFxyJyA/IDIgOiAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZW5kID09PSAtMSkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmF0RW5kKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNldE5leHQoJ3F1b3RlZC1zY2FsYXInKTtcbiAgICAgICAgICAgIGVuZCA9IHRoaXMuYnVmZmVyLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICB5aWVsZCogdGhpcy5wdXNoVG9JbmRleChlbmQgKyAxLCBmYWxzZSk7XG4gICAgICAgIHJldHVybiB0aGlzLmZsb3dMZXZlbCA/ICdmbG93JyA6ICdkb2MnO1xuICAgIH1cbiAgICAqcGFyc2VCbG9ja1NjYWxhckhlYWRlcigpIHtcbiAgICAgICAgdGhpcy5ibG9ja1NjYWxhckluZGVudCA9IC0xO1xuICAgICAgICB0aGlzLmJsb2NrU2NhbGFyS2VlcCA9IGZhbHNlO1xuICAgICAgICBsZXQgaSA9IHRoaXMucG9zO1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgY29uc3QgY2ggPSB0aGlzLmJ1ZmZlclsrK2ldO1xuICAgICAgICAgICAgaWYgKGNoID09PSAnKycpXG4gICAgICAgICAgICAgICAgdGhpcy5ibG9ja1NjYWxhcktlZXAgPSB0cnVlO1xuICAgICAgICAgICAgZWxzZSBpZiAoY2ggPiAnMCcgJiYgY2ggPD0gJzknKVxuICAgICAgICAgICAgICAgIHRoaXMuYmxvY2tTY2FsYXJJbmRlbnQgPSBOdW1iZXIoY2gpIC0gMTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGNoICE9PSAnLScpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHlpZWxkKiB0aGlzLnB1c2hVbnRpbChjaCA9PiBpc0VtcHR5KGNoKSB8fCBjaCA9PT0gJyMnKTtcbiAgICB9XG4gICAgKnBhcnNlQmxvY2tTY2FsYXIoKSB7XG4gICAgICAgIGxldCBubCA9IHRoaXMucG9zIC0gMTsgLy8gbWF5IGJlIC0xIGlmIHRoaXMucG9zID09PSAwXG4gICAgICAgIGxldCBpbmRlbnQgPSAwO1xuICAgICAgICBsZXQgY2g7XG4gICAgICAgIGxvb3A6IGZvciAobGV0IGkgPSB0aGlzLnBvczsgKGNoID0gdGhpcy5idWZmZXJbaV0pOyArK2kpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoY2gpIHtcbiAgICAgICAgICAgICAgICBjYXNlICcgJzpcbiAgICAgICAgICAgICAgICAgICAgaW5kZW50ICs9IDE7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ1xcbic6XG4gICAgICAgICAgICAgICAgICAgIG5sID0gaTtcbiAgICAgICAgICAgICAgICAgICAgaW5kZW50ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnXFxyJzoge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXh0ID0gdGhpcy5idWZmZXJbaSArIDFdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW5leHQgJiYgIXRoaXMuYXRFbmQpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zZXROZXh0KCdibG9jay1zY2FsYXInKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5leHQgPT09ICdcXG4nKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfSAvLyBmYWxsdGhyb3VnaFxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrIGxvb3A7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjaCAmJiAhdGhpcy5hdEVuZClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNldE5leHQoJ2Jsb2NrLXNjYWxhcicpO1xuICAgICAgICBpZiAoaW5kZW50ID49IHRoaXMuaW5kZW50TmV4dCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuYmxvY2tTY2FsYXJJbmRlbnQgPT09IC0xKVxuICAgICAgICAgICAgICAgIHRoaXMuaW5kZW50TmV4dCA9IGluZGVudDtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aGlzLmluZGVudE5leHQgKz0gdGhpcy5ibG9ja1NjYWxhckluZGVudDtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjcyA9IHRoaXMuY29udGludWVTY2FsYXIobmwgKyAxKTtcbiAgICAgICAgICAgICAgICBpZiAoY3MgPT09IC0xKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBubCA9IHRoaXMuYnVmZmVyLmluZGV4T2YoJ1xcbicsIGNzKTtcbiAgICAgICAgICAgIH0gd2hpbGUgKG5sICE9PSAtMSk7XG4gICAgICAgICAgICBpZiAobmwgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmF0RW5kKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zZXROZXh0KCdibG9jay1zY2FsYXInKTtcbiAgICAgICAgICAgICAgICBubCA9IHRoaXMuYnVmZmVyLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuYmxvY2tTY2FsYXJLZWVwKSB7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgbGV0IGkgPSBubCAtIDE7XG4gICAgICAgICAgICAgICAgbGV0IGNoID0gdGhpcy5idWZmZXJbaV07XG4gICAgICAgICAgICAgICAgaWYgKGNoID09PSAnXFxyJylcbiAgICAgICAgICAgICAgICAgICAgY2ggPSB0aGlzLmJ1ZmZlclstLWldO1xuICAgICAgICAgICAgICAgIHdoaWxlIChjaCA9PT0gJyAnIHx8IGNoID09PSAnXFx0JylcbiAgICAgICAgICAgICAgICAgICAgY2ggPSB0aGlzLmJ1ZmZlclstLWldO1xuICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJ1xcbicgJiYgaSA+PSB0aGlzLnBvcylcbiAgICAgICAgICAgICAgICAgICAgbmwgPSBpO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9IHdoaWxlICh0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICB5aWVsZCBTQ0FMQVI7XG4gICAgICAgIHlpZWxkKiB0aGlzLnB1c2hUb0luZGV4KG5sICsgMSwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiB5aWVsZCogdGhpcy5wYXJzZUxpbmVTdGFydCgpO1xuICAgIH1cbiAgICAqcGFyc2VQbGFpblNjYWxhcigpIHtcbiAgICAgICAgY29uc3QgaW5GbG93ID0gdGhpcy5mbG93TGV2ZWwgPiAwO1xuICAgICAgICBsZXQgZW5kID0gdGhpcy5wb3MgLSAxO1xuICAgICAgICBsZXQgaSA9IHRoaXMucG9zIC0gMTtcbiAgICAgICAgbGV0IGNoO1xuICAgICAgICB3aGlsZSAoKGNoID0gdGhpcy5idWZmZXJbKytpXSkpIHtcbiAgICAgICAgICAgIGlmIChjaCA9PT0gJzonKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dCA9IHRoaXMuYnVmZmVyW2kgKyAxXTtcbiAgICAgICAgICAgICAgICBpZiAoaXNFbXB0eShuZXh0KSB8fCAoaW5GbG93ICYmIG5leHQgPT09ICcsJykpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGVuZCA9IGk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc0VtcHR5KGNoKSkge1xuICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gdGhpcy5idWZmZXJbaSArIDFdO1xuICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJ1xccicpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5leHQgPT09ICdcXG4nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpICs9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaCA9ICdcXG4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCA9IHRoaXMuYnVmZmVyW2kgKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmQgPSBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobmV4dCA9PT0gJyMnIHx8IChpbkZsb3cgJiYgaW52YWxpZEZsb3dTY2FsYXJDaGFycy5pbmNsdWRlcyhuZXh0KSkpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJ1xcbicpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY3MgPSB0aGlzLmNvbnRpbnVlU2NhbGFyKGkgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNzID09PSAtMSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBpID0gTWF0aC5tYXgoaSwgY3MgLSAyKTsgLy8gdG8gYWR2YW5jZSwgYnV0IHN0aWxsIGFjY291bnQgZm9yICcgIydcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5GbG93ICYmIGludmFsaWRGbG93U2NhbGFyQ2hhcnMuaW5jbHVkZXMoY2gpKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBlbmQgPSBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghY2ggJiYgIXRoaXMuYXRFbmQpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZXROZXh0KCdwbGFpbi1zY2FsYXInKTtcbiAgICAgICAgeWllbGQgU0NBTEFSO1xuICAgICAgICB5aWVsZCogdGhpcy5wdXNoVG9JbmRleChlbmQgKyAxLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIGluRmxvdyA/ICdmbG93JyA6ICdkb2MnO1xuICAgIH1cbiAgICAqcHVzaENvdW50KG4pIHtcbiAgICAgICAgaWYgKG4gPiAwKSB7XG4gICAgICAgICAgICB5aWVsZCB0aGlzLmJ1ZmZlci5zdWJzdHIodGhpcy5wb3MsIG4pO1xuICAgICAgICAgICAgdGhpcy5wb3MgKz0gbjtcbiAgICAgICAgICAgIHJldHVybiBuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICAqcHVzaFRvSW5kZXgoaSwgYWxsb3dFbXB0eSkge1xuICAgICAgICBjb25zdCBzID0gdGhpcy5idWZmZXIuc2xpY2UodGhpcy5wb3MsIGkpO1xuICAgICAgICBpZiAocykge1xuICAgICAgICAgICAgeWllbGQgcztcbiAgICAgICAgICAgIHRoaXMucG9zICs9IHMubGVuZ3RoO1xuICAgICAgICAgICAgcmV0dXJuIHMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFsbG93RW1wdHkpXG4gICAgICAgICAgICB5aWVsZCAnJztcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgICpwdXNoSW5kaWNhdG9ycygpIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLmNoYXJBdCgwKSkge1xuICAgICAgICAgICAgY2FzZSAnISc6XG4gICAgICAgICAgICAgICAgcmV0dXJuICgoeWllbGQqIHRoaXMucHVzaFRhZygpKSArXG4gICAgICAgICAgICAgICAgICAgICh5aWVsZCogdGhpcy5wdXNoU3BhY2VzKHRydWUpKSArXG4gICAgICAgICAgICAgICAgICAgICh5aWVsZCogdGhpcy5wdXNoSW5kaWNhdG9ycygpKSk7XG4gICAgICAgICAgICBjYXNlICcmJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gKCh5aWVsZCogdGhpcy5wdXNoVW50aWwoaXNOb3RBbmNob3JDaGFyKSkgK1xuICAgICAgICAgICAgICAgICAgICAoeWllbGQqIHRoaXMucHVzaFNwYWNlcyh0cnVlKSkgK1xuICAgICAgICAgICAgICAgICAgICAoeWllbGQqIHRoaXMucHVzaEluZGljYXRvcnMoKSkpO1xuICAgICAgICAgICAgY2FzZSAnOic6XG4gICAgICAgICAgICBjYXNlICc/JzogLy8gdGhpcyBpcyBhbiBlcnJvciBvdXRzaWRlIGZsb3cgY29sbGVjdGlvbnNcbiAgICAgICAgICAgIGNhc2UgJy0nOiAvLyB0aGlzIGlzIGFuIGVycm9yXG4gICAgICAgICAgICAgICAgaWYgKGlzRW1wdHkodGhpcy5jaGFyQXQoMSkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmZsb3dMZXZlbCA9PT0gMClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW5kZW50TmV4dCA9IHRoaXMuaW5kZW50VmFsdWUgKyAxO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLmZsb3dLZXkpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZsb3dLZXkgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgoeWllbGQqIHRoaXMucHVzaENvdW50KDEpKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAoeWllbGQqIHRoaXMucHVzaFNwYWNlcyh0cnVlKSkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgKHlpZWxkKiB0aGlzLnB1c2hJbmRpY2F0b3JzKCkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgICpwdXNoVGFnKCkge1xuICAgICAgICBpZiAodGhpcy5jaGFyQXQoMSkgPT09ICc8Jykge1xuICAgICAgICAgICAgbGV0IGkgPSB0aGlzLnBvcyArIDI7XG4gICAgICAgICAgICBsZXQgY2ggPSB0aGlzLmJ1ZmZlcltpXTtcbiAgICAgICAgICAgIHdoaWxlICghaXNFbXB0eShjaCkgJiYgY2ggIT09ICc+JylcbiAgICAgICAgICAgICAgICBjaCA9IHRoaXMuYnVmZmVyWysraV07XG4gICAgICAgICAgICByZXR1cm4geWllbGQqIHRoaXMucHVzaFRvSW5kZXgoY2ggPT09ICc+JyA/IGkgKyAxIDogaSwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IGkgPSB0aGlzLnBvcyArIDE7XG4gICAgICAgICAgICBsZXQgY2ggPSB0aGlzLmJ1ZmZlcltpXTtcbiAgICAgICAgICAgIHdoaWxlIChjaCkge1xuICAgICAgICAgICAgICAgIGlmICh0YWdDaGFycy5pbmNsdWRlcyhjaCkpXG4gICAgICAgICAgICAgICAgICAgIGNoID0gdGhpcy5idWZmZXJbKytpXTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjaCA9PT0gJyUnICYmXG4gICAgICAgICAgICAgICAgICAgIGhleERpZ2l0cy5pbmNsdWRlcyh0aGlzLmJ1ZmZlcltpICsgMV0pICYmXG4gICAgICAgICAgICAgICAgICAgIGhleERpZ2l0cy5pbmNsdWRlcyh0aGlzLmJ1ZmZlcltpICsgMl0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoID0gdGhpcy5idWZmZXJbKGkgKz0gMyldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHlpZWxkKiB0aGlzLnB1c2hUb0luZGV4KGksIGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAqcHVzaE5ld2xpbmUoKSB7XG4gICAgICAgIGNvbnN0IGNoID0gdGhpcy5idWZmZXJbdGhpcy5wb3NdO1xuICAgICAgICBpZiAoY2ggPT09ICdcXG4nKVxuICAgICAgICAgICAgcmV0dXJuIHlpZWxkKiB0aGlzLnB1c2hDb3VudCgxKTtcbiAgICAgICAgZWxzZSBpZiAoY2ggPT09ICdcXHInICYmIHRoaXMuY2hhckF0KDEpID09PSAnXFxuJylcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCogdGhpcy5wdXNoQ291bnQoMik7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICAqcHVzaFNwYWNlcyhhbGxvd1RhYnMpIHtcbiAgICAgICAgbGV0IGkgPSB0aGlzLnBvcyAtIDE7XG4gICAgICAgIGxldCBjaDtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgY2ggPSB0aGlzLmJ1ZmZlclsrK2ldO1xuICAgICAgICB9IHdoaWxlIChjaCA9PT0gJyAnIHx8IChhbGxvd1RhYnMgJiYgY2ggPT09ICdcXHQnKSk7XG4gICAgICAgIGNvbnN0IG4gPSBpIC0gdGhpcy5wb3M7XG4gICAgICAgIGlmIChuID4gMCkge1xuICAgICAgICAgICAgeWllbGQgdGhpcy5idWZmZXIuc3Vic3RyKHRoaXMucG9zLCBuKTtcbiAgICAgICAgICAgIHRoaXMucG9zID0gaTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbjtcbiAgICB9XG4gICAgKnB1c2hVbnRpbCh0ZXN0KSB7XG4gICAgICAgIGxldCBpID0gdGhpcy5wb3M7XG4gICAgICAgIGxldCBjaCA9IHRoaXMuYnVmZmVyW2ldO1xuICAgICAgICB3aGlsZSAoIXRlc3QoY2gpKVxuICAgICAgICAgICAgY2ggPSB0aGlzLmJ1ZmZlclsrK2ldO1xuICAgICAgICByZXR1cm4geWllbGQqIHRoaXMucHVzaFRvSW5kZXgoaSwgZmFsc2UpO1xuICAgIH1cbn1cblxuZXhwb3J0IHsgTGV4ZXIgfTtcbiIsICIvKipcbiAqIFRyYWNrcyBuZXdsaW5lcyBkdXJpbmcgcGFyc2luZyBpbiBvcmRlciB0byBwcm92aWRlIGFuIGVmZmljaWVudCBBUEkgZm9yXG4gKiBkZXRlcm1pbmluZyB0aGUgb25lLWluZGV4ZWQgYHsgbGluZSwgY29sIH1gIHBvc2l0aW9uIGZvciBhbnkgb2Zmc2V0XG4gKiB3aXRoaW4gdGhlIGlucHV0LlxuICovXG5jbGFzcyBMaW5lQ291bnRlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMubGluZVN0YXJ0cyA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgICogU2hvdWxkIGJlIGNhbGxlZCBpbiBhc2NlbmRpbmcgb3JkZXIuIE90aGVyd2lzZSwgY2FsbFxuICAgICAgICAgKiBgbGluZUNvdW50ZXIubGluZVN0YXJ0cy5zb3J0KClgIGJlZm9yZSBjYWxsaW5nIGBsaW5lUG9zKClgLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hZGROZXdMaW5lID0gKG9mZnNldCkgPT4gdGhpcy5saW5lU3RhcnRzLnB1c2gob2Zmc2V0KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFBlcmZvcm1zIGEgYmluYXJ5IHNlYXJjaCBhbmQgcmV0dXJucyB0aGUgMS1pbmRleGVkIHsgbGluZSwgY29sIH1cbiAgICAgICAgICogcG9zaXRpb24gb2YgYG9mZnNldGAuIElmIGBsaW5lID09PSAwYCwgYGFkZE5ld0xpbmVgIGhhcyBuZXZlciBiZWVuXG4gICAgICAgICAqIGNhbGxlZCBvciBgb2Zmc2V0YCBpcyBiZWZvcmUgdGhlIGZpcnN0IGtub3duIG5ld2xpbmUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmxpbmVQb3MgPSAob2Zmc2V0KSA9PiB7XG4gICAgICAgICAgICBsZXQgbG93ID0gMDtcbiAgICAgICAgICAgIGxldCBoaWdoID0gdGhpcy5saW5lU3RhcnRzLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlIChsb3cgPCBoaWdoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWlkID0gKGxvdyArIGhpZ2gpID4+IDE7IC8vIE1hdGguZmxvb3IoKGxvdyArIGhpZ2gpIC8gMilcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5saW5lU3RhcnRzW21pZF0gPCBvZmZzZXQpXG4gICAgICAgICAgICAgICAgICAgIGxvdyA9IG1pZCArIDE7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBoaWdoID0gbWlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMubGluZVN0YXJ0c1tsb3ddID09PSBvZmZzZXQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgbGluZTogbG93ICsgMSwgY29sOiAxIH07XG4gICAgICAgICAgICBpZiAobG93ID09PSAwKVxuICAgICAgICAgICAgICAgIHJldHVybiB7IGxpbmU6IDAsIGNvbDogb2Zmc2V0IH07XG4gICAgICAgICAgICBjb25zdCBzdGFydCA9IHRoaXMubGluZVN0YXJ0c1tsb3cgLSAxXTtcbiAgICAgICAgICAgIHJldHVybiB7IGxpbmU6IGxvdywgY29sOiBvZmZzZXQgLSBzdGFydCArIDEgfTtcbiAgICAgICAgfTtcbiAgICB9XG59XG5cbmV4cG9ydCB7IExpbmVDb3VudGVyIH07XG4iLCAiaW1wb3J0IHsgdG9rZW5UeXBlIH0gZnJvbSAnLi9jc3QuanMnO1xuaW1wb3J0IHsgTGV4ZXIgfSBmcm9tICcuL2xleGVyLmpzJztcblxuZnVuY3Rpb24gaW5jbHVkZXNUb2tlbihsaXN0LCB0eXBlKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKVxuICAgICAgICBpZiAobGlzdFtpXS50eXBlID09PSB0eXBlKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gaW5jbHVkZXNOb25FbXB0eShsaXN0KSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHN3aXRjaCAobGlzdFtpXS50eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdzcGFjZSc6XG4gICAgICAgICAgICBjYXNlICdjb21tZW50JzpcbiAgICAgICAgICAgIGNhc2UgJ25ld2xpbmUnOlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBpc0Zsb3dUb2tlbih0b2tlbikge1xuICAgIHN3aXRjaCAodG9rZW4gPT09IG51bGwgfHwgdG9rZW4gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRva2VuLnR5cGUpIHtcbiAgICAgICAgY2FzZSAnYWxpYXMnOlxuICAgICAgICBjYXNlICdzY2FsYXInOlxuICAgICAgICBjYXNlICdzaW5nbGUtcXVvdGVkLXNjYWxhcic6XG4gICAgICAgIGNhc2UgJ2RvdWJsZS1xdW90ZWQtc2NhbGFyJzpcbiAgICAgICAgY2FzZSAnZmxvdy1jb2xsZWN0aW9uJzpcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldFByZXZQcm9wcyhwYXJlbnQpIHtcbiAgICBzd2l0Y2ggKHBhcmVudC50eXBlKSB7XG4gICAgICAgIGNhc2UgJ2RvY3VtZW50JzpcbiAgICAgICAgICAgIHJldHVybiBwYXJlbnQuc3RhcnQ7XG4gICAgICAgIGNhc2UgJ2Jsb2NrLW1hcCc6IHtcbiAgICAgICAgICAgIGNvbnN0IGl0ID0gcGFyZW50Lml0ZW1zW3BhcmVudC5pdGVtcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIHJldHVybiBpdC5zZXAgfHwgaXQuc3RhcnQ7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnYmxvY2stc2VxJzpcbiAgICAgICAgICAgIHJldHVybiBwYXJlbnQuaXRlbXNbcGFyZW50Lml0ZW1zLmxlbmd0aCAtIDFdLnN0YXJ0O1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCBzaG91bGQgbm90IGhhcHBlbiAqL1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbn1cbi8qKiBOb3RlOiBNYXkgbW9kaWZ5IGlucHV0IGFycmF5ICovXG5mdW5jdGlvbiBnZXRGaXJzdEtleVN0YXJ0UHJvcHMocHJldikge1xuICAgIHZhciBfYTtcbiAgICBpZiAocHJldi5sZW5ndGggPT09IDApXG4gICAgICAgIHJldHVybiBbXTtcbiAgICBsZXQgaSA9IHByZXYubGVuZ3RoO1xuICAgIGxvb3A6IHdoaWxlICgtLWkgPj0gMCkge1xuICAgICAgICBzd2l0Y2ggKHByZXZbaV0udHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnZG9jLXN0YXJ0JzpcbiAgICAgICAgICAgIGNhc2UgJ2V4cGxpY2l0LWtleS1pbmQnOlxuICAgICAgICAgICAgY2FzZSAnbWFwLXZhbHVlLWluZCc6XG4gICAgICAgICAgICBjYXNlICdzZXEtaXRlbS1pbmQnOlxuICAgICAgICAgICAgY2FzZSAnbmV3bGluZSc6XG4gICAgICAgICAgICAgICAgYnJlYWsgbG9vcDtcbiAgICAgICAgfVxuICAgIH1cbiAgICB3aGlsZSAoKChfYSA9IHByZXZbKytpXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnR5cGUpID09PSAnc3BhY2UnKSB7XG4gICAgICAgIC8qIGxvb3AgKi9cbiAgICB9XG4gICAgcmV0dXJuIHByZXYuc3BsaWNlKGksIHByZXYubGVuZ3RoKTtcbn1cbmZ1bmN0aW9uIGZpeEZsb3dTZXFJdGVtcyhmYykge1xuICAgIGlmIChmYy5zdGFydC50eXBlID09PSAnZmxvdy1zZXEtc3RhcnQnKSB7XG4gICAgICAgIGZvciAoY29uc3QgaXQgb2YgZmMuaXRlbXMpIHtcbiAgICAgICAgICAgIGlmIChpdC5zZXAgJiZcbiAgICAgICAgICAgICAgICAhaXQudmFsdWUgJiZcbiAgICAgICAgICAgICAgICAhaW5jbHVkZXNUb2tlbihpdC5zdGFydCwgJ2V4cGxpY2l0LWtleS1pbmQnKSAmJlxuICAgICAgICAgICAgICAgICFpbmNsdWRlc1Rva2VuKGl0LnNlcCwgJ21hcC12YWx1ZS1pbmQnKSkge1xuICAgICAgICAgICAgICAgIGlmIChpdC5rZXkpXG4gICAgICAgICAgICAgICAgICAgIGl0LnZhbHVlID0gaXQua2V5O1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBpdC5rZXk7XG4gICAgICAgICAgICAgICAgaWYgKGlzRmxvd1Rva2VuKGl0LnZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXQudmFsdWUuZW5kKVxuICAgICAgICAgICAgICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkoaXQudmFsdWUuZW5kLCBpdC5zZXApO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBpdC52YWx1ZS5lbmQgPSBpdC5zZXA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkoaXQuc3RhcnQsIGl0LnNlcCk7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGl0LnNlcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogQSBZQU1MIGNvbmNyZXRlIHN5bnRheCB0cmVlIChDU1QpIHBhcnNlclxuICpcbiAqIGBgYHRzXG4gKiBjb25zdCBzcmM6IHN0cmluZyA9IC4uLlxuICogZm9yIChjb25zdCB0b2tlbiBvZiBuZXcgUGFyc2VyKCkucGFyc2Uoc3JjKSkge1xuICogICAvLyB0b2tlbjogVG9rZW5cbiAqIH1cbiAqIGBgYFxuICpcbiAqIFRvIHVzZSB0aGUgcGFyc2VyIHdpdGggYSB1c2VyLXByb3ZpZGVkIGxleGVyOlxuICpcbiAqIGBgYHRzXG4gKiBmdW5jdGlvbiogcGFyc2Uoc291cmNlOiBzdHJpbmcsIGxleGVyOiBMZXhlcikge1xuICogICBjb25zdCBwYXJzZXIgPSBuZXcgUGFyc2VyKClcbiAqICAgZm9yIChjb25zdCBsZXhlbWUgb2YgbGV4ZXIubGV4KHNvdXJjZSkpXG4gKiAgICAgeWllbGQqIHBhcnNlci5uZXh0KGxleGVtZSlcbiAqICAgeWllbGQqIHBhcnNlci5lbmQoKVxuICogfVxuICpcbiAqIGNvbnN0IHNyYzogc3RyaW5nID0gLi4uXG4gKiBjb25zdCBsZXhlciA9IG5ldyBMZXhlcigpXG4gKiBmb3IgKGNvbnN0IHRva2VuIG9mIHBhcnNlKHNyYywgbGV4ZXIpKSB7XG4gKiAgIC8vIHRva2VuOiBUb2tlblxuICogfVxuICogYGBgXG4gKi9cbmNsYXNzIFBhcnNlciB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIG9uTmV3TGluZSAtIElmIGRlZmluZWQsIGNhbGxlZCBzZXBhcmF0ZWx5IHdpdGggdGhlIHN0YXJ0IHBvc2l0aW9uIG9mXG4gICAgICogICBlYWNoIG5ldyBsaW5lIChpbiBgcGFyc2UoKWAsIGluY2x1ZGluZyB0aGUgc3RhcnQgb2YgaW5wdXQpLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG9uTmV3TGluZSkge1xuICAgICAgICAvKiogSWYgdHJ1ZSwgc3BhY2UgYW5kIHNlcXVlbmNlIGluZGljYXRvcnMgY291bnQgYXMgaW5kZW50YXRpb24gKi9cbiAgICAgICAgdGhpcy5hdE5ld0xpbmUgPSB0cnVlO1xuICAgICAgICAvKiogSWYgdHJ1ZSwgbmV4dCB0b2tlbiBpcyBhIHNjYWxhciB2YWx1ZSAqL1xuICAgICAgICB0aGlzLmF0U2NhbGFyID0gZmFsc2U7XG4gICAgICAgIC8qKiBDdXJyZW50IGluZGVudGF0aW9uIGxldmVsICovXG4gICAgICAgIHRoaXMuaW5kZW50ID0gMDtcbiAgICAgICAgLyoqIEN1cnJlbnQgb2Zmc2V0IHNpbmNlIHRoZSBzdGFydCBvZiBwYXJzaW5nICovXG4gICAgICAgIHRoaXMub2Zmc2V0ID0gMDtcbiAgICAgICAgLyoqIE9uIHRoZSBzYW1lIGxpbmUgd2l0aCBhIGJsb2NrIG1hcCBrZXkgKi9cbiAgICAgICAgdGhpcy5vbktleUxpbmUgPSBmYWxzZTtcbiAgICAgICAgLyoqIFRvcCBpbmRpY2F0ZXMgdGhlIG5vZGUgdGhhdCdzIGN1cnJlbnRseSBiZWluZyBidWlsdCAqL1xuICAgICAgICB0aGlzLnN0YWNrID0gW107XG4gICAgICAgIC8qKiBUaGUgc291cmNlIG9mIHRoZSBjdXJyZW50IHRva2VuLCBzZXQgaW4gcGFyc2UoKSAqL1xuICAgICAgICB0aGlzLnNvdXJjZSA9ICcnO1xuICAgICAgICAvKiogVGhlIHR5cGUgb2YgdGhlIGN1cnJlbnQgdG9rZW4sIHNldCBpbiBwYXJzZSgpICovXG4gICAgICAgIHRoaXMudHlwZSA9ICcnO1xuICAgICAgICAvLyBNdXN0IGJlIGRlZmluZWQgYWZ0ZXIgYG5leHQoKWBcbiAgICAgICAgdGhpcy5sZXhlciA9IG5ldyBMZXhlcigpO1xuICAgICAgICB0aGlzLm9uTmV3TGluZSA9IG9uTmV3TGluZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGFyc2UgYHNvdXJjZWAgYXMgYSBZQU1MIHN0cmVhbS5cbiAgICAgKiBJZiBgaW5jb21wbGV0ZWAsIGEgcGFydCBvZiB0aGUgbGFzdCBsaW5lIG1heSBiZSBsZWZ0IGFzIGEgYnVmZmVyIGZvciB0aGUgbmV4dCBjYWxsLlxuICAgICAqXG4gICAgICogRXJyb3JzIGFyZSBub3QgdGhyb3duLCBidXQgeWllbGRlZCBhcyBgeyB0eXBlOiAnZXJyb3InLCBtZXNzYWdlIH1gIHRva2Vucy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEEgZ2VuZXJhdG9yIG9mIHRva2VucyByZXByZXNlbnRpbmcgZWFjaCBkaXJlY3RpdmUsIGRvY3VtZW50LCBhbmQgb3RoZXIgc3RydWN0dXJlLlxuICAgICAqL1xuICAgICpwYXJzZShzb3VyY2UsIGluY29tcGxldGUgPSBmYWxzZSkge1xuICAgICAgICBpZiAodGhpcy5vbk5ld0xpbmUgJiYgdGhpcy5vZmZzZXQgPT09IDApXG4gICAgICAgICAgICB0aGlzLm9uTmV3TGluZSgwKTtcbiAgICAgICAgZm9yIChjb25zdCBsZXhlbWUgb2YgdGhpcy5sZXhlci5sZXgoc291cmNlLCBpbmNvbXBsZXRlKSlcbiAgICAgICAgICAgIHlpZWxkKiB0aGlzLm5leHQobGV4ZW1lKTtcbiAgICAgICAgaWYgKCFpbmNvbXBsZXRlKVxuICAgICAgICAgICAgeWllbGQqIHRoaXMuZW5kKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkdmFuY2UgdGhlIHBhcnNlciBieSB0aGUgYHNvdXJjZWAgb2Ygb25lIGxleGljYWwgdG9rZW4uXG4gICAgICovXG4gICAgKm5leHQoc291cmNlKSB7XG4gICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgICBpZiAodGhpcy5hdFNjYWxhcikge1xuICAgICAgICAgICAgdGhpcy5hdFNjYWxhciA9IGZhbHNlO1xuICAgICAgICAgICAgeWllbGQqIHRoaXMuc3RlcCgpO1xuICAgICAgICAgICAgdGhpcy5vZmZzZXQgKz0gc291cmNlLmxlbmd0aDtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0eXBlID0gdG9rZW5UeXBlKHNvdXJjZSk7XG4gICAgICAgIGlmICghdHlwZSkge1xuICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IGBOb3QgYSBZQU1MIHRva2VuOiAke3NvdXJjZX1gO1xuICAgICAgICAgICAgeWllbGQqIHRoaXMucG9wKHsgdHlwZTogJ2Vycm9yJywgb2Zmc2V0OiB0aGlzLm9mZnNldCwgbWVzc2FnZSwgc291cmNlIH0pO1xuICAgICAgICAgICAgdGhpcy5vZmZzZXQgKz0gc291cmNlLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlID09PSAnc2NhbGFyJykge1xuICAgICAgICAgICAgdGhpcy5hdE5ld0xpbmUgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuYXRTY2FsYXIgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy50eXBlID0gJ3NjYWxhcic7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICAgICAgeWllbGQqIHRoaXMuc3RlcCgpO1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnbmV3bGluZSc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXROZXdMaW5lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmRlbnQgPSAwO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5vbk5ld0xpbmUpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9uTmV3TGluZSh0aGlzLm9mZnNldCArIHNvdXJjZS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdzcGFjZSc6XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmF0TmV3TGluZSAmJiBzb3VyY2VbMF0gPT09ICcgJylcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW5kZW50ICs9IHNvdXJjZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2V4cGxpY2l0LWtleS1pbmQnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ21hcC12YWx1ZS1pbmQnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ3NlcS1pdGVtLWluZCc6XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmF0TmV3TGluZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW5kZW50ICs9IHNvdXJjZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2RvYy1tb2RlJzpcbiAgICAgICAgICAgICAgICBjYXNlICdmbG93LWVycm9yLWVuZCc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmF0TmV3TGluZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5vZmZzZXQgKz0gc291cmNlLmxlbmd0aDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiogQ2FsbCBhdCBlbmQgb2YgaW5wdXQgdG8gcHVzaCBvdXQgYW55IHJlbWFpbmluZyBjb25zdHJ1Y3Rpb25zICovXG4gICAgKmVuZCgpIHtcbiAgICAgICAgd2hpbGUgKHRoaXMuc3RhY2subGVuZ3RoID4gMClcbiAgICAgICAgICAgIHlpZWxkKiB0aGlzLnBvcCgpO1xuICAgIH1cbiAgICBnZXQgc291cmNlVG9rZW4oKSB7XG4gICAgICAgIGNvbnN0IHN0ID0ge1xuICAgICAgICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgICAgICAgb2Zmc2V0OiB0aGlzLm9mZnNldCxcbiAgICAgICAgICAgIGluZGVudDogdGhpcy5pbmRlbnQsXG4gICAgICAgICAgICBzb3VyY2U6IHRoaXMuc291cmNlXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBzdDtcbiAgICB9XG4gICAgKnN0ZXAoKSB7XG4gICAgICAgIGNvbnN0IHRvcCA9IHRoaXMucGVlaygxKTtcbiAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gJ2RvYy1lbmQnICYmICghdG9wIHx8IHRvcC50eXBlICE9PSAnZG9jLWVuZCcpKSB7XG4gICAgICAgICAgICB3aGlsZSAodGhpcy5zdGFjay5sZW5ndGggPiAwKVxuICAgICAgICAgICAgICAgIHlpZWxkKiB0aGlzLnBvcCgpO1xuICAgICAgICAgICAgdGhpcy5zdGFjay5wdXNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnZG9jLWVuZCcsXG4gICAgICAgICAgICAgICAgb2Zmc2V0OiB0aGlzLm9mZnNldCxcbiAgICAgICAgICAgICAgICBzb3VyY2U6IHRoaXMuc291cmNlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRvcClcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCogdGhpcy5zdHJlYW0oKTtcbiAgICAgICAgc3dpdGNoICh0b3AudHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnZG9jdW1lbnQnOlxuICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCogdGhpcy5kb2N1bWVudCh0b3ApO1xuICAgICAgICAgICAgY2FzZSAnYWxpYXMnOlxuICAgICAgICAgICAgY2FzZSAnc2NhbGFyJzpcbiAgICAgICAgICAgIGNhc2UgJ3NpbmdsZS1xdW90ZWQtc2NhbGFyJzpcbiAgICAgICAgICAgIGNhc2UgJ2RvdWJsZS1xdW90ZWQtc2NhbGFyJzpcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQqIHRoaXMuc2NhbGFyKHRvcCk7XG4gICAgICAgICAgICBjYXNlICdibG9jay1zY2FsYXInOlxuICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCogdGhpcy5ibG9ja1NjYWxhcih0b3ApO1xuICAgICAgICAgICAgY2FzZSAnYmxvY2stbWFwJzpcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQqIHRoaXMuYmxvY2tNYXAodG9wKTtcbiAgICAgICAgICAgIGNhc2UgJ2Jsb2NrLXNlcSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkKiB0aGlzLmJsb2NrU2VxdWVuY2UodG9wKTtcbiAgICAgICAgICAgIGNhc2UgJ2Zsb3ctY29sbGVjdGlvbic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkKiB0aGlzLmZsb3dDb2xsZWN0aW9uKHRvcCk7XG4gICAgICAgICAgICBjYXNlICdkb2MtZW5kJzpcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQqIHRoaXMuZG9jdW1lbnRFbmQodG9wKTtcbiAgICAgICAgfVxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCBzaG91bGQgbm90IGhhcHBlbiAqL1xuICAgICAgICB5aWVsZCogdGhpcy5wb3AoKTtcbiAgICB9XG4gICAgcGVlayhuKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gbl07XG4gICAgfVxuICAgICpwb3AoZXJyb3IpIHtcbiAgICAgICAgY29uc3QgdG9rZW4gPSBlcnJvciB8fCB0aGlzLnN0YWNrLnBvcCgpO1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgc2hvdWxkIG5vdCBoYXBwZW4gKi9cbiAgICAgICAgaWYgKCF0b2tlbikge1xuICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9ICdUcmllZCB0byBwb3AgYW4gZW1wdHkgc3RhY2snO1xuICAgICAgICAgICAgeWllbGQgeyB0eXBlOiAnZXJyb3InLCBvZmZzZXQ6IHRoaXMub2Zmc2V0LCBzb3VyY2U6ICcnLCBtZXNzYWdlIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5zdGFjay5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHlpZWxkIHRva2VuO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgdG9wID0gdGhpcy5wZWVrKDEpO1xuICAgICAgICAgICAgaWYgKHRva2VuLnR5cGUgPT09ICdibG9jay1zY2FsYXInKSB7XG4gICAgICAgICAgICAgICAgLy8gQmxvY2sgc2NhbGFycyB1c2UgdGhlaXIgcGFyZW50IHJhdGhlciB0aGFuIGhlYWRlciBpbmRlbnRcbiAgICAgICAgICAgICAgICB0b2tlbi5pbmRlbnQgPSAnaW5kZW50JyBpbiB0b3AgPyB0b3AuaW5kZW50IDogMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRva2VuLnR5cGUgPT09ICdmbG93LWNvbGxlY3Rpb24nICYmIHRvcC50eXBlID09PSAnZG9jdW1lbnQnKSB7XG4gICAgICAgICAgICAgICAgLy8gSWdub3JlIGFsbCBpbmRlbnQgZm9yIHRvcC1sZXZlbCBmbG93IGNvbGxlY3Rpb25zXG4gICAgICAgICAgICAgICAgdG9rZW4uaW5kZW50ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0b2tlbi50eXBlID09PSAnZmxvdy1jb2xsZWN0aW9uJylcbiAgICAgICAgICAgICAgICBmaXhGbG93U2VxSXRlbXModG9rZW4pO1xuICAgICAgICAgICAgc3dpdGNoICh0b3AudHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2RvY3VtZW50JzpcbiAgICAgICAgICAgICAgICAgICAgdG9wLnZhbHVlID0gdG9rZW47XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2Jsb2NrLXNjYWxhcic6XG4gICAgICAgICAgICAgICAgICAgIHRvcC5wcm9wcy5wdXNoKHRva2VuKTsgLy8gZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnYmxvY2stbWFwJzoge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpdCA9IHRvcC5pdGVtc1t0b3AuaXRlbXMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChpdC52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9wLml0ZW1zLnB1c2goeyBzdGFydDogW10sIGtleTogdG9rZW4sIHNlcDogW10gfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9uS2V5TGluZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaXQuc2VwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdC52YWx1ZSA9IHRva2VuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihpdCwgeyBrZXk6IHRva2VuLCBzZXA6IFtdIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vbktleUxpbmUgPSAhaW5jbHVkZXNUb2tlbihpdC5zdGFydCwgJ2V4cGxpY2l0LWtleS1pbmQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAnYmxvY2stc2VxJzoge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpdCA9IHRvcC5pdGVtc1t0b3AuaXRlbXMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChpdC52YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvcC5pdGVtcy5wdXNoKHsgc3RhcnQ6IFtdLCB2YWx1ZTogdG9rZW4gfSk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0LnZhbHVlID0gdG9rZW47XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlICdmbG93LWNvbGxlY3Rpb24nOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGl0ID0gdG9wLml0ZW1zW3RvcC5pdGVtcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpdCB8fCBpdC52YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvcC5pdGVtcy5wdXNoKHsgc3RhcnQ6IFtdLCBrZXk6IHRva2VuLCBzZXA6IFtdIH0pO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpdC5zZXApXG4gICAgICAgICAgICAgICAgICAgICAgICBpdC52YWx1ZSA9IHRva2VuO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKGl0LCB7IGtleTogdG9rZW4sIHNlcDogW10gfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgc2hvdWxkIG5vdCBoYXBwZW4gKi9cbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB5aWVsZCogdGhpcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQqIHRoaXMucG9wKHRva2VuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgodG9wLnR5cGUgPT09ICdkb2N1bWVudCcgfHxcbiAgICAgICAgICAgICAgICB0b3AudHlwZSA9PT0gJ2Jsb2NrLW1hcCcgfHxcbiAgICAgICAgICAgICAgICB0b3AudHlwZSA9PT0gJ2Jsb2NrLXNlcScpICYmXG4gICAgICAgICAgICAgICAgKHRva2VuLnR5cGUgPT09ICdibG9jay1tYXAnIHx8IHRva2VuLnR5cGUgPT09ICdibG9jay1zZXEnKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxhc3QgPSB0b2tlbi5pdGVtc1t0b2tlbi5pdGVtcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICBpZiAobGFzdCAmJlxuICAgICAgICAgICAgICAgICAgICAhbGFzdC5zZXAgJiZcbiAgICAgICAgICAgICAgICAgICAgIWxhc3QudmFsdWUgJiZcbiAgICAgICAgICAgICAgICAgICAgbGFzdC5zdGFydC5sZW5ndGggPiAwICYmXG4gICAgICAgICAgICAgICAgICAgICFpbmNsdWRlc05vbkVtcHR5KGxhc3Quc3RhcnQpICYmXG4gICAgICAgICAgICAgICAgICAgICh0b2tlbi5pbmRlbnQgPT09IDAgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3Quc3RhcnQuZXZlcnkoc3QgPT4gc3QudHlwZSAhPT0gJ2NvbW1lbnQnIHx8IHN0LmluZGVudCA8IHRva2VuLmluZGVudCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0b3AudHlwZSA9PT0gJ2RvY3VtZW50JylcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvcC5lbmQgPSBsYXN0LnN0YXJ0O1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICB0b3AuaXRlbXMucHVzaCh7IHN0YXJ0OiBsYXN0LnN0YXJ0IH0pO1xuICAgICAgICAgICAgICAgICAgICB0b2tlbi5pdGVtcy5zcGxpY2UoLTEsIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAqc3RyZWFtKCkge1xuICAgICAgICBzd2l0Y2ggKHRoaXMudHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnZGlyZWN0aXZlLWxpbmUnOlxuICAgICAgICAgICAgICAgIHlpZWxkIHsgdHlwZTogJ2RpcmVjdGl2ZScsIG9mZnNldDogdGhpcy5vZmZzZXQsIHNvdXJjZTogdGhpcy5zb3VyY2UgfTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjYXNlICdieXRlLW9yZGVyLW1hcmsnOlxuICAgICAgICAgICAgY2FzZSAnc3BhY2UnOlxuICAgICAgICAgICAgY2FzZSAnY29tbWVudCc6XG4gICAgICAgICAgICBjYXNlICduZXdsaW5lJzpcbiAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLnNvdXJjZVRva2VuO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNhc2UgJ2RvYy1tb2RlJzpcbiAgICAgICAgICAgIGNhc2UgJ2RvYy1zdGFydCc6IHtcbiAgICAgICAgICAgICAgICBjb25zdCBkb2MgPSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdkb2N1bWVudCcsXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldDogdGhpcy5vZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBbXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gJ2RvYy1zdGFydCcpXG4gICAgICAgICAgICAgICAgICAgIGRvYy5zdGFydC5wdXNoKHRoaXMuc291cmNlVG9rZW4pO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhY2sucHVzaChkb2MpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB5aWVsZCB7XG4gICAgICAgICAgICB0eXBlOiAnZXJyb3InLFxuICAgICAgICAgICAgb2Zmc2V0OiB0aGlzLm9mZnNldCxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGBVbmV4cGVjdGVkICR7dGhpcy50eXBlfSB0b2tlbiBpbiBZQU1MIHN0cmVhbWAsXG4gICAgICAgICAgICBzb3VyY2U6IHRoaXMuc291cmNlXG4gICAgICAgIH07XG4gICAgfVxuICAgICpkb2N1bWVudChkb2MpIHtcbiAgICAgICAgaWYgKGRvYy52YWx1ZSlcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCogdGhpcy5saW5lRW5kKGRvYyk7XG4gICAgICAgIHN3aXRjaCAodGhpcy50eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdkb2Mtc3RhcnQnOiB7XG4gICAgICAgICAgICAgICAgaWYgKGluY2x1ZGVzTm9uRW1wdHkoZG9jLnN0YXJ0KSkge1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCogdGhpcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQqIHRoaXMuc3RlcCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGRvYy5zdGFydC5wdXNoKHRoaXMuc291cmNlVG9rZW4pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ2FuY2hvcic6XG4gICAgICAgICAgICBjYXNlICd0YWcnOlxuICAgICAgICAgICAgY2FzZSAnc3BhY2UnOlxuICAgICAgICAgICAgY2FzZSAnY29tbWVudCc6XG4gICAgICAgICAgICBjYXNlICduZXdsaW5lJzpcbiAgICAgICAgICAgICAgICBkb2Muc3RhcnQucHVzaCh0aGlzLnNvdXJjZVRva2VuKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYnYgPSB0aGlzLnN0YXJ0QmxvY2tWYWx1ZShkb2MpO1xuICAgICAgICBpZiAoYnYpXG4gICAgICAgICAgICB0aGlzLnN0YWNrLnB1c2goYnYpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHlpZWxkIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnZXJyb3InLFxuICAgICAgICAgICAgICAgIG9mZnNldDogdGhpcy5vZmZzZXQsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogYFVuZXhwZWN0ZWQgJHt0aGlzLnR5cGV9IHRva2VuIGluIFlBTUwgZG9jdW1lbnRgLFxuICAgICAgICAgICAgICAgIHNvdXJjZTogdGhpcy5zb3VyY2VcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgKnNjYWxhcihzY2FsYXIpIHtcbiAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gJ21hcC12YWx1ZS1pbmQnKSB7XG4gICAgICAgICAgICBjb25zdCBwcmV2ID0gZ2V0UHJldlByb3BzKHRoaXMucGVlaygyKSk7XG4gICAgICAgICAgICBjb25zdCBzdGFydCA9IGdldEZpcnN0S2V5U3RhcnRQcm9wcyhwcmV2KTtcbiAgICAgICAgICAgIGxldCBzZXA7XG4gICAgICAgICAgICBpZiAoc2NhbGFyLmVuZCkge1xuICAgICAgICAgICAgICAgIHNlcCA9IHNjYWxhci5lbmQ7XG4gICAgICAgICAgICAgICAgc2VwLnB1c2godGhpcy5zb3VyY2VUb2tlbik7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHNjYWxhci5lbmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgc2VwID0gW3RoaXMuc291cmNlVG9rZW5dO1xuICAgICAgICAgICAgY29uc3QgbWFwID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdibG9jay1tYXAnLFxuICAgICAgICAgICAgICAgIG9mZnNldDogc2NhbGFyLm9mZnNldCxcbiAgICAgICAgICAgICAgICBpbmRlbnQ6IHNjYWxhci5pbmRlbnQsXG4gICAgICAgICAgICAgICAgaXRlbXM6IFt7IHN0YXJ0LCBrZXk6IHNjYWxhciwgc2VwIH1dXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5vbktleUxpbmUgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdID0gbWFwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHlpZWxkKiB0aGlzLmxpbmVFbmQoc2NhbGFyKTtcbiAgICB9XG4gICAgKmJsb2NrU2NhbGFyKHNjYWxhcikge1xuICAgICAgICBzd2l0Y2ggKHRoaXMudHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnc3BhY2UnOlxuICAgICAgICAgICAgY2FzZSAnY29tbWVudCc6XG4gICAgICAgICAgICBjYXNlICduZXdsaW5lJzpcbiAgICAgICAgICAgICAgICBzY2FsYXIucHJvcHMucHVzaCh0aGlzLnNvdXJjZVRva2VuKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjYXNlICdzY2FsYXInOlxuICAgICAgICAgICAgICAgIHNjYWxhci5zb3VyY2UgPSB0aGlzLnNvdXJjZTtcbiAgICAgICAgICAgICAgICAvLyBibG9jay1zY2FsYXIgc291cmNlIGluY2x1ZGVzIHRyYWlsaW5nIG5ld2xpbmVcbiAgICAgICAgICAgICAgICB0aGlzLmF0TmV3TGluZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5pbmRlbnQgPSAwO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9uTmV3TGluZSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbmwgPSB0aGlzLnNvdXJjZS5pbmRleE9mKCdcXG4nKSArIDE7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChubCAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vbk5ld0xpbmUodGhpcy5vZmZzZXQgKyBubCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBubCA9IHRoaXMuc291cmNlLmluZGV4T2YoJ1xcbicsIG5sKSArIDE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgeWllbGQqIHRoaXMucG9wKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCBzaG91bGQgbm90IGhhcHBlbiAqL1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB5aWVsZCogdGhpcy5wb3AoKTtcbiAgICAgICAgICAgICAgICB5aWVsZCogdGhpcy5zdGVwKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgKmJsb2NrTWFwKG1hcCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IGl0ID0gbWFwLml0ZW1zW21hcC5pdGVtcy5sZW5ndGggLSAxXTtcbiAgICAgICAgLy8gaXQuc2VwIGlzIHRydWUtaXNoIGlmIHBhaXIgYWxyZWFkeSBoYXMga2V5IG9yIDogc2VwYXJhdG9yXG4gICAgICAgIHN3aXRjaCAodGhpcy50eXBlKSB7XG4gICAgICAgICAgICBjYXNlICduZXdsaW5lJzpcbiAgICAgICAgICAgICAgICB0aGlzLm9uS2V5TGluZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGlmIChpdC52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlbmQgPSAnZW5kJyBpbiBpdC52YWx1ZSA/IGl0LnZhbHVlLmVuZCA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGFzdCA9IEFycmF5LmlzQXJyYXkoZW5kKSA/IGVuZFtlbmQubGVuZ3RoIC0gMV0gOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICgobGFzdCA9PT0gbnVsbCB8fCBsYXN0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsYXN0LnR5cGUpID09PSAnY29tbWVudCcpXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmQgPT09IG51bGwgfHwgZW5kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlbmQucHVzaCh0aGlzLnNvdXJjZVRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgbWFwLml0ZW1zLnB1c2goeyBzdGFydDogW3RoaXMuc291cmNlVG9rZW5dIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpdC5zZXApXG4gICAgICAgICAgICAgICAgICAgIGl0LnNlcC5wdXNoKHRoaXMuc291cmNlVG9rZW4pO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgaXQuc3RhcnQucHVzaCh0aGlzLnNvdXJjZVRva2VuKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjYXNlICdzcGFjZSc6XG4gICAgICAgICAgICBjYXNlICdjb21tZW50JzpcbiAgICAgICAgICAgICAgICBpZiAoaXQudmFsdWUpXG4gICAgICAgICAgICAgICAgICAgIG1hcC5pdGVtcy5wdXNoKHsgc3RhcnQ6IFt0aGlzLnNvdXJjZVRva2VuXSB9KTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpdC5zZXApXG4gICAgICAgICAgICAgICAgICAgIGl0LnNlcC5wdXNoKHRoaXMuc291cmNlVG9rZW4pO1xuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5hdEluZGVudGVkQ29tbWVudChpdC5zdGFydCwgbWFwLmluZGVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHByZXYgPSBtYXAuaXRlbXNbbWFwLml0ZW1zLmxlbmd0aCAtIDJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZW5kID0gKF9hID0gcHJldiA9PT0gbnVsbCB8fCBwcmV2ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwcmV2LnZhbHVlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZW5kO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZW5kKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGVuZCwgaXQuc3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZC5wdXNoKHRoaXMuc291cmNlVG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcC5pdGVtcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaXQuc3RhcnQucHVzaCh0aGlzLnNvdXJjZVRva2VuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmluZGVudCA+PSBtYXAuaW5kZW50KSB7XG4gICAgICAgICAgICBjb25zdCBhdE5leHRJdGVtID0gIXRoaXMub25LZXlMaW5lICYmXG4gICAgICAgICAgICAgICAgdGhpcy5pbmRlbnQgPT09IG1hcC5pbmRlbnQgJiZcbiAgICAgICAgICAgICAgICAoaXQuc2VwIHx8IGluY2x1ZGVzTm9uRW1wdHkoaXQuc3RhcnQpKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy50eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnYW5jaG9yJzpcbiAgICAgICAgICAgICAgICBjYXNlICd0YWcnOlxuICAgICAgICAgICAgICAgICAgICBpZiAoYXROZXh0SXRlbSB8fCBpdC52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFwLml0ZW1zLnB1c2goeyBzdGFydDogW3RoaXMuc291cmNlVG9rZW5dIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vbktleUxpbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGl0LnNlcClcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0LnNlcC5wdXNoKHRoaXMuc291cmNlVG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBpdC5zdGFydC5wdXNoKHRoaXMuc291cmNlVG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgY2FzZSAnZXhwbGljaXQta2V5LWluZCc6XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXQuc2VwICYmICFpbmNsdWRlc1Rva2VuKGl0LnN0YXJ0LCAnZXhwbGljaXQta2V5LWluZCcpKVxuICAgICAgICAgICAgICAgICAgICAgICAgaXQuc3RhcnQucHVzaCh0aGlzLnNvdXJjZVRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoYXROZXh0SXRlbSB8fCBpdC52YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcC5pdGVtcy5wdXNoKHsgc3RhcnQ6IFt0aGlzLnNvdXJjZVRva2VuXSB9KTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGFjay5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnYmxvY2stbWFwJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IHRoaXMub2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGVudDogdGhpcy5pbmRlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbXM6IFt7IHN0YXJ0OiBbdGhpcy5zb3VyY2VUb2tlbl0gfV1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uS2V5TGluZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBjYXNlICdtYXAtdmFsdWUtaW5kJzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpdC5zZXApXG4gICAgICAgICAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKGl0LCB7IGtleTogbnVsbCwgc2VwOiBbdGhpcy5zb3VyY2VUb2tlbl0gfSk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGl0LnZhbHVlIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAoYXROZXh0SXRlbSAmJiAhaW5jbHVkZXNUb2tlbihpdC5zdGFydCwgJ2V4cGxpY2l0LWtleS1pbmQnKSkpXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXAuaXRlbXMucHVzaCh7IHN0YXJ0OiBbXSwga2V5OiBudWxsLCBzZXA6IFt0aGlzLnNvdXJjZVRva2VuXSB9KTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaW5jbHVkZXNUb2tlbihpdC5zZXAsICdtYXAtdmFsdWUtaW5kJykpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YWNrLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdibG9jay1tYXAnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldDogdGhpcy5vZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZW50OiB0aGlzLmluZGVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtczogW3sgc3RhcnQ6IFtdLCBrZXk6IG51bGwsIHNlcDogW3RoaXMuc291cmNlVG9rZW5dIH1dXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaW5jbHVkZXNUb2tlbihpdC5zdGFydCwgJ2V4cGxpY2l0LWtleS1pbmQnKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgaXNGbG93VG9rZW4oaXQua2V5KSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgIWluY2x1ZGVzVG9rZW4oaXQuc2VwLCAnbmV3bGluZScpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzdGFydCA9IGdldEZpcnN0S2V5U3RhcnRQcm9wcyhpdC5zdGFydCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBpdC5rZXk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzZXAgPSBpdC5zZXA7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXAucHVzaCh0aGlzLnNvdXJjZVRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmUgdHlwZSBndWFyZCBpcyB3cm9uZyBoZXJlXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgaXQua2V5LCBkZWxldGUgaXQuc2VwO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGFjay5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnYmxvY2stbWFwJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IHRoaXMub2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGVudDogdGhpcy5pbmRlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbXM6IFt7IHN0YXJ0LCBrZXksIHNlcCB9XVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgaXQuc2VwLnB1c2godGhpcy5zb3VyY2VUb2tlbik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25LZXlMaW5lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2FsaWFzJzpcbiAgICAgICAgICAgICAgICBjYXNlICdzY2FsYXInOlxuICAgICAgICAgICAgICAgIGNhc2UgJ3NpbmdsZS1xdW90ZWQtc2NhbGFyJzpcbiAgICAgICAgICAgICAgICBjYXNlICdkb3VibGUtcXVvdGVkLXNjYWxhcic6IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZnMgPSB0aGlzLmZsb3dTY2FsYXIodGhpcy50eXBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGF0TmV4dEl0ZW0gfHwgaXQudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcC5pdGVtcy5wdXNoKHsgc3RhcnQ6IFtdLCBrZXk6IGZzLCBzZXA6IFtdIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vbktleUxpbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGl0LnNlcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGFjay5wdXNoKGZzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oaXQsIHsga2V5OiBmcywgc2VwOiBbXSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub25LZXlMaW5lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYnYgPSB0aGlzLnN0YXJ0QmxvY2tWYWx1ZShtYXApO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYnYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhdE5leHRJdGVtICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnYudHlwZSAhPT0gJ2Jsb2NrLXNlcScgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmNsdWRlc1Rva2VuKGl0LnN0YXJ0LCAnZXhwbGljaXQta2V5LWluZCcpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcC5pdGVtcy5wdXNoKHsgc3RhcnQ6IFtdIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGFjay5wdXNoKGJ2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB5aWVsZCogdGhpcy5wb3AoKTtcbiAgICAgICAgeWllbGQqIHRoaXMuc3RlcCgpO1xuICAgIH1cbiAgICAqYmxvY2tTZXF1ZW5jZShzZXEpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBpdCA9IHNlcS5pdGVtc1tzZXEuaXRlbXMubGVuZ3RoIC0gMV07XG4gICAgICAgIHN3aXRjaCAodGhpcy50eXBlKSB7XG4gICAgICAgICAgICBjYXNlICduZXdsaW5lJzpcbiAgICAgICAgICAgICAgICBpZiAoaXQudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZW5kID0gJ2VuZCcgaW4gaXQudmFsdWUgPyBpdC52YWx1ZS5lbmQgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxhc3QgPSBBcnJheS5pc0FycmF5KGVuZCkgPyBlbmRbZW5kLmxlbmd0aCAtIDFdIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICBpZiAoKGxhc3QgPT09IG51bGwgfHwgbGFzdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGFzdC50eXBlKSA9PT0gJ2NvbW1lbnQnKVxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kID09PSBudWxsIHx8IGVuZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogZW5kLnB1c2godGhpcy5zb3VyY2VUb2tlbik7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcS5pdGVtcy5wdXNoKHsgc3RhcnQ6IFt0aGlzLnNvdXJjZVRva2VuXSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBpdC5zdGFydC5wdXNoKHRoaXMuc291cmNlVG9rZW4pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNhc2UgJ3NwYWNlJzpcbiAgICAgICAgICAgIGNhc2UgJ2NvbW1lbnQnOlxuICAgICAgICAgICAgICAgIGlmIChpdC52YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgc2VxLml0ZW1zLnB1c2goeyBzdGFydDogW3RoaXMuc291cmNlVG9rZW5dIH0pO1xuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5hdEluZGVudGVkQ29tbWVudChpdC5zdGFydCwgc2VxLmluZGVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHByZXYgPSBzZXEuaXRlbXNbc2VxLml0ZW1zLmxlbmd0aCAtIDJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZW5kID0gKF9hID0gcHJldiA9PT0gbnVsbCB8fCBwcmV2ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwcmV2LnZhbHVlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZW5kO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZW5kKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGVuZCwgaXQuc3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZC5wdXNoKHRoaXMuc291cmNlVG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlcS5pdGVtcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaXQuc3RhcnQucHVzaCh0aGlzLnNvdXJjZVRva2VuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY2FzZSAnYW5jaG9yJzpcbiAgICAgICAgICAgIGNhc2UgJ3RhZyc6XG4gICAgICAgICAgICAgICAgaWYgKGl0LnZhbHVlIHx8IHRoaXMuaW5kZW50IDw9IHNlcS5pbmRlbnQpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGl0LnN0YXJ0LnB1c2godGhpcy5zb3VyY2VUb2tlbik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY2FzZSAnc2VxLWl0ZW0taW5kJzpcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pbmRlbnQgIT09IHNlcS5pbmRlbnQpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGlmIChpdC52YWx1ZSB8fCBpbmNsdWRlc1Rva2VuKGl0LnN0YXJ0LCAnc2VxLWl0ZW0taW5kJykpXG4gICAgICAgICAgICAgICAgICAgIHNlcS5pdGVtcy5wdXNoKHsgc3RhcnQ6IFt0aGlzLnNvdXJjZVRva2VuXSB9KTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGl0LnN0YXJ0LnB1c2godGhpcy5zb3VyY2VUb2tlbik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmluZGVudCA+IHNlcS5pbmRlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IGJ2ID0gdGhpcy5zdGFydEJsb2NrVmFsdWUoc2VxKTtcbiAgICAgICAgICAgIGlmIChidikge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhY2sucHVzaChidik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHlpZWxkKiB0aGlzLnBvcCgpO1xuICAgICAgICB5aWVsZCogdGhpcy5zdGVwKCk7XG4gICAgfVxuICAgICpmbG93Q29sbGVjdGlvbihmYykge1xuICAgICAgICBjb25zdCBpdCA9IGZjLml0ZW1zW2ZjLml0ZW1zLmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAodGhpcy50eXBlID09PSAnZmxvdy1lcnJvci1lbmQnKSB7XG4gICAgICAgICAgICBsZXQgdG9wO1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIHlpZWxkKiB0aGlzLnBvcCgpO1xuICAgICAgICAgICAgICAgIHRvcCA9IHRoaXMucGVlaygxKTtcbiAgICAgICAgICAgIH0gd2hpbGUgKHRvcCAmJiB0b3AudHlwZSA9PT0gJ2Zsb3ctY29sbGVjdGlvbicpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGZjLmVuZC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy50eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnY29tbWEnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2V4cGxpY2l0LWtleS1pbmQnOlxuICAgICAgICAgICAgICAgICAgICBpZiAoIWl0IHx8IGl0LnNlcClcbiAgICAgICAgICAgICAgICAgICAgICAgIGZjLml0ZW1zLnB1c2goeyBzdGFydDogW3RoaXMuc291cmNlVG9rZW5dIH0pO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBpdC5zdGFydC5wdXNoKHRoaXMuc291cmNlVG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgY2FzZSAnbWFwLXZhbHVlLWluZCc6XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXQgfHwgaXQudmFsdWUpXG4gICAgICAgICAgICAgICAgICAgICAgICBmYy5pdGVtcy5wdXNoKHsgc3RhcnQ6IFtdLCBrZXk6IG51bGwsIHNlcDogW3RoaXMuc291cmNlVG9rZW5dIH0pO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpdC5zZXApXG4gICAgICAgICAgICAgICAgICAgICAgICBpdC5zZXAucHVzaCh0aGlzLnNvdXJjZVRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihpdCwgeyBrZXk6IG51bGwsIHNlcDogW3RoaXMuc291cmNlVG9rZW5dIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgY2FzZSAnc3BhY2UnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2NvbW1lbnQnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ25ld2xpbmUnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2FuY2hvcic6XG4gICAgICAgICAgICAgICAgY2FzZSAndGFnJzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpdCB8fCBpdC52YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGZjLml0ZW1zLnB1c2goeyBzdGFydDogW3RoaXMuc291cmNlVG9rZW5dIH0pO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpdC5zZXApXG4gICAgICAgICAgICAgICAgICAgICAgICBpdC5zZXAucHVzaCh0aGlzLnNvdXJjZVRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgaXQuc3RhcnQucHVzaCh0aGlzLnNvdXJjZVRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2FsaWFzJzpcbiAgICAgICAgICAgICAgICBjYXNlICdzY2FsYXInOlxuICAgICAgICAgICAgICAgIGNhc2UgJ3NpbmdsZS1xdW90ZWQtc2NhbGFyJzpcbiAgICAgICAgICAgICAgICBjYXNlICdkb3VibGUtcXVvdGVkLXNjYWxhcic6IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZnMgPSB0aGlzLmZsb3dTY2FsYXIodGhpcy50eXBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpdCB8fCBpdC52YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGZjLml0ZW1zLnB1c2goeyBzdGFydDogW10sIGtleTogZnMsIHNlcDogW10gfSk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGl0LnNlcClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhY2sucHVzaChmcyk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oaXQsIHsga2V5OiBmcywgc2VwOiBbXSB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlICdmbG93LW1hcC1lbmQnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2Zsb3ctc2VxLWVuZCc6XG4gICAgICAgICAgICAgICAgICAgIGZjLmVuZC5wdXNoKHRoaXMuc291cmNlVG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBidiA9IHRoaXMuc3RhcnRCbG9ja1ZhbHVlKGZjKTtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlIHNob3VsZCBub3QgaGFwcGVuICovXG4gICAgICAgICAgICBpZiAoYnYpXG4gICAgICAgICAgICAgICAgdGhpcy5zdGFjay5wdXNoKGJ2KTtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHlpZWxkKiB0aGlzLnBvcCgpO1xuICAgICAgICAgICAgICAgIHlpZWxkKiB0aGlzLnN0ZXAoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcmVudCA9IHRoaXMucGVlaygyKTtcbiAgICAgICAgICAgIGlmIChwYXJlbnQudHlwZSA9PT0gJ2Jsb2NrLW1hcCcgJiZcbiAgICAgICAgICAgICAgICAodGhpcy50eXBlID09PSAnbWFwLXZhbHVlLWluZCcgfHxcbiAgICAgICAgICAgICAgICAgICAgKHRoaXMudHlwZSA9PT0gJ25ld2xpbmUnICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAhcGFyZW50Lml0ZW1zW3BhcmVudC5pdGVtcy5sZW5ndGggLSAxXS5zZXApKSkge1xuICAgICAgICAgICAgICAgIHlpZWxkKiB0aGlzLnBvcCgpO1xuICAgICAgICAgICAgICAgIHlpZWxkKiB0aGlzLnN0ZXAoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMudHlwZSA9PT0gJ21hcC12YWx1ZS1pbmQnICYmXG4gICAgICAgICAgICAgICAgcGFyZW50LnR5cGUgIT09ICdmbG93LWNvbGxlY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJldiA9IGdldFByZXZQcm9wcyhwYXJlbnQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gZ2V0Rmlyc3RLZXlTdGFydFByb3BzKHByZXYpO1xuICAgICAgICAgICAgICAgIGZpeEZsb3dTZXFJdGVtcyhmYyk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2VwID0gZmMuZW5kLnNwbGljZSgxLCBmYy5lbmQubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBzZXAucHVzaCh0aGlzLnNvdXJjZVRva2VuKTtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXAgPSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdibG9jay1tYXAnLFxuICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IGZjLm9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgaW5kZW50OiBmYy5pbmRlbnQsXG4gICAgICAgICAgICAgICAgICAgIGl0ZW1zOiBbeyBzdGFydCwga2V5OiBmYywgc2VwIH1dXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0aGlzLm9uS2V5TGluZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdID0gbWFwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgeWllbGQqIHRoaXMubGluZUVuZChmYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZmxvd1NjYWxhcih0eXBlKSB7XG4gICAgICAgIGlmICh0aGlzLm9uTmV3TGluZSkge1xuICAgICAgICAgICAgbGV0IG5sID0gdGhpcy5zb3VyY2UuaW5kZXhPZignXFxuJykgKyAxO1xuICAgICAgICAgICAgd2hpbGUgKG5sICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vbk5ld0xpbmUodGhpcy5vZmZzZXQgKyBubCk7XG4gICAgICAgICAgICAgICAgbmwgPSB0aGlzLnNvdXJjZS5pbmRleE9mKCdcXG4nLCBubCkgKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgb2Zmc2V0OiB0aGlzLm9mZnNldCxcbiAgICAgICAgICAgIGluZGVudDogdGhpcy5pbmRlbnQsXG4gICAgICAgICAgICBzb3VyY2U6IHRoaXMuc291cmNlXG4gICAgICAgIH07XG4gICAgfVxuICAgIHN0YXJ0QmxvY2tWYWx1ZShwYXJlbnQpIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2FsaWFzJzpcbiAgICAgICAgICAgIGNhc2UgJ3NjYWxhcic6XG4gICAgICAgICAgICBjYXNlICdzaW5nbGUtcXVvdGVkLXNjYWxhcic6XG4gICAgICAgICAgICBjYXNlICdkb3VibGUtcXVvdGVkLXNjYWxhcic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmxvd1NjYWxhcih0aGlzLnR5cGUpO1xuICAgICAgICAgICAgY2FzZSAnYmxvY2stc2NhbGFyLWhlYWRlcic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2Jsb2NrLXNjYWxhcicsXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldDogdGhpcy5vZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgIGluZGVudDogdGhpcy5pbmRlbnQsXG4gICAgICAgICAgICAgICAgICAgIHByb3BzOiBbdGhpcy5zb3VyY2VUb2tlbl0sXG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZTogJydcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgY2FzZSAnZmxvdy1tYXAtc3RhcnQnOlxuICAgICAgICAgICAgY2FzZSAnZmxvdy1zZXEtc3RhcnQnOlxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdmbG93LWNvbGxlY3Rpb24nLFxuICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IHRoaXMub2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICBpbmRlbnQ6IHRoaXMuaW5kZW50LFxuICAgICAgICAgICAgICAgICAgICBzdGFydDogdGhpcy5zb3VyY2VUb2tlbixcbiAgICAgICAgICAgICAgICAgICAgaXRlbXM6IFtdLFxuICAgICAgICAgICAgICAgICAgICBlbmQ6IFtdXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNhc2UgJ3NlcS1pdGVtLWluZCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2Jsb2NrLXNlcScsXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldDogdGhpcy5vZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgIGluZGVudDogdGhpcy5pbmRlbnQsXG4gICAgICAgICAgICAgICAgICAgIGl0ZW1zOiBbeyBzdGFydDogW3RoaXMuc291cmNlVG9rZW5dIH1dXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNhc2UgJ2V4cGxpY2l0LWtleS1pbmQnOiB7XG4gICAgICAgICAgICAgICAgdGhpcy5vbktleUxpbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNvbnN0IHByZXYgPSBnZXRQcmV2UHJvcHMocGFyZW50KTtcbiAgICAgICAgICAgICAgICBjb25zdCBzdGFydCA9IGdldEZpcnN0S2V5U3RhcnRQcm9wcyhwcmV2KTtcbiAgICAgICAgICAgICAgICBzdGFydC5wdXNoKHRoaXMuc291cmNlVG9rZW4pO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdibG9jay1tYXAnLFxuICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IHRoaXMub2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICBpbmRlbnQ6IHRoaXMuaW5kZW50LFxuICAgICAgICAgICAgICAgICAgICBpdGVtczogW3sgc3RhcnQgfV1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnbWFwLXZhbHVlLWluZCc6IHtcbiAgICAgICAgICAgICAgICB0aGlzLm9uS2V5TGluZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJldiA9IGdldFByZXZQcm9wcyhwYXJlbnQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gZ2V0Rmlyc3RLZXlTdGFydFByb3BzKHByZXYpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdibG9jay1tYXAnLFxuICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IHRoaXMub2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICBpbmRlbnQ6IHRoaXMuaW5kZW50LFxuICAgICAgICAgICAgICAgICAgICBpdGVtczogW3sgc3RhcnQsIGtleTogbnVsbCwgc2VwOiBbdGhpcy5zb3VyY2VUb2tlbl0gfV1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBhdEluZGVudGVkQ29tbWVudChzdGFydCwgaW5kZW50KSB7XG4gICAgICAgIGlmICh0aGlzLnR5cGUgIT09ICdjb21tZW50JylcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuaW5kZW50IDw9IGluZGVudClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHN0YXJ0LmV2ZXJ5KHN0ID0+IHN0LnR5cGUgPT09ICduZXdsaW5lJyB8fCBzdC50eXBlID09PSAnc3BhY2UnKTtcbiAgICB9XG4gICAgKmRvY3VtZW50RW5kKGRvY0VuZCkge1xuICAgICAgICBpZiAodGhpcy50eXBlICE9PSAnZG9jLW1vZGUnKSB7XG4gICAgICAgICAgICBpZiAoZG9jRW5kLmVuZClcbiAgICAgICAgICAgICAgICBkb2NFbmQuZW5kLnB1c2godGhpcy5zb3VyY2VUb2tlbik7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgZG9jRW5kLmVuZCA9IFt0aGlzLnNvdXJjZVRva2VuXTtcbiAgICAgICAgICAgIGlmICh0aGlzLnR5cGUgPT09ICduZXdsaW5lJylcbiAgICAgICAgICAgICAgICB5aWVsZCogdGhpcy5wb3AoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAqbGluZUVuZCh0b2tlbikge1xuICAgICAgICBzd2l0Y2ggKHRoaXMudHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnY29tbWEnOlxuICAgICAgICAgICAgY2FzZSAnZG9jLXN0YXJ0JzpcbiAgICAgICAgICAgIGNhc2UgJ2RvYy1lbmQnOlxuICAgICAgICAgICAgY2FzZSAnZmxvdy1zZXEtZW5kJzpcbiAgICAgICAgICAgIGNhc2UgJ2Zsb3ctbWFwLWVuZCc6XG4gICAgICAgICAgICBjYXNlICdtYXAtdmFsdWUtaW5kJzpcbiAgICAgICAgICAgICAgICB5aWVsZCogdGhpcy5wb3AoKTtcbiAgICAgICAgICAgICAgICB5aWVsZCogdGhpcy5zdGVwKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICduZXdsaW5lJzpcbiAgICAgICAgICAgICAgICB0aGlzLm9uS2V5TGluZSA9IGZhbHNlO1xuICAgICAgICAgICAgLy8gZmFsbHRocm91Z2hcbiAgICAgICAgICAgIGNhc2UgJ3NwYWNlJzpcbiAgICAgICAgICAgIGNhc2UgJ2NvbW1lbnQnOlxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAvLyBhbGwgb3RoZXIgdmFsdWVzIGFyZSBlcnJvcnNcbiAgICAgICAgICAgICAgICBpZiAodG9rZW4uZW5kKVxuICAgICAgICAgICAgICAgICAgICB0b2tlbi5lbmQucHVzaCh0aGlzLnNvdXJjZVRva2VuKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHRva2VuLmVuZCA9IFt0aGlzLnNvdXJjZVRva2VuXTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy50eXBlID09PSAnbmV3bGluZScpXG4gICAgICAgICAgICAgICAgICAgIHlpZWxkKiB0aGlzLnBvcCgpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgeyBQYXJzZXIgfTtcbiIsICJpbXBvcnQgeyBDb21wb3NlciB9IGZyb20gJy4vY29tcG9zZS9jb21wb3Nlci5qcyc7XG5pbXBvcnQgeyBEb2N1bWVudCB9IGZyb20gJy4vZG9jL0RvY3VtZW50LmpzJztcbmltcG9ydCB7IHByZXR0aWZ5RXJyb3IsIFlBTUxQYXJzZUVycm9yIH0gZnJvbSAnLi9lcnJvcnMuanMnO1xuaW1wb3J0IHsgd2FybiB9IGZyb20gJy4vbG9nLmpzJztcbmltcG9ydCB7IExpbmVDb3VudGVyIH0gZnJvbSAnLi9wYXJzZS9saW5lLWNvdW50ZXIuanMnO1xuaW1wb3J0IHsgUGFyc2VyIH0gZnJvbSAnLi9wYXJzZS9wYXJzZXIuanMnO1xuXG5mdW5jdGlvbiBwYXJzZU9wdGlvbnMob3B0aW9ucykge1xuICAgIGNvbnN0IHByZXR0eUVycm9ycyA9IG9wdGlvbnMucHJldHR5RXJyb3JzICE9PSBmYWxzZTtcbiAgICBjb25zdCBsaW5lQ291bnRlciA9IG9wdGlvbnMubGluZUNvdW50ZXIgfHwgKHByZXR0eUVycm9ycyAmJiBuZXcgTGluZUNvdW50ZXIoKSkgfHwgbnVsbDtcbiAgICByZXR1cm4geyBsaW5lQ291bnRlciwgcHJldHR5RXJyb3JzIH07XG59XG4vKipcbiAqIFBhcnNlIHRoZSBpbnB1dCBhcyBhIHN0cmVhbSBvZiBZQU1MIGRvY3VtZW50cy5cbiAqXG4gKiBEb2N1bWVudHMgc2hvdWxkIGJlIHNlcGFyYXRlZCBmcm9tIGVhY2ggb3RoZXIgYnkgYC4uLmAgb3IgYC0tLWAgbWFya2VyIGxpbmVzLlxuICpcbiAqIEByZXR1cm5zIElmIGFuIGVtcHR5IGBkb2NzYCBhcnJheSBpcyByZXR1cm5lZCwgaXQgd2lsbCBiZSBvZiB0eXBlXG4gKiAgIEVtcHR5U3RyZWFtIGFuZCBjb250YWluIGFkZGl0aW9uYWwgc3RyZWFtIGluZm9ybWF0aW9uLiBJblxuICogICBUeXBlU2NyaXB0LCB5b3Ugc2hvdWxkIHVzZSBgJ2VtcHR5JyBpbiBkb2NzYCBhcyBhIHR5cGUgZ3VhcmQgZm9yIGl0LlxuICovXG5mdW5jdGlvbiBwYXJzZUFsbERvY3VtZW50cyhzb3VyY2UsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgbGluZUNvdW50ZXIsIHByZXR0eUVycm9ycyB9ID0gcGFyc2VPcHRpb25zKG9wdGlvbnMpO1xuICAgIGNvbnN0IHBhcnNlciA9IG5ldyBQYXJzZXIobGluZUNvdW50ZXIgPT09IG51bGwgfHwgbGluZUNvdW50ZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxpbmVDb3VudGVyLmFkZE5ld0xpbmUpO1xuICAgIGNvbnN0IGNvbXBvc2VyID0gbmV3IENvbXBvc2VyKG9wdGlvbnMpO1xuICAgIGNvbnN0IGRvY3MgPSBBcnJheS5mcm9tKGNvbXBvc2VyLmNvbXBvc2UocGFyc2VyLnBhcnNlKHNvdXJjZSkpKTtcbiAgICBpZiAocHJldHR5RXJyb3JzICYmIGxpbmVDb3VudGVyKVxuICAgICAgICBmb3IgKGNvbnN0IGRvYyBvZiBkb2NzKSB7XG4gICAgICAgICAgICBkb2MuZXJyb3JzLmZvckVhY2gocHJldHRpZnlFcnJvcihzb3VyY2UsIGxpbmVDb3VudGVyKSk7XG4gICAgICAgICAgICBkb2Mud2FybmluZ3MuZm9yRWFjaChwcmV0dGlmeUVycm9yKHNvdXJjZSwgbGluZUNvdW50ZXIpKTtcbiAgICAgICAgfVxuICAgIGlmIChkb2NzLmxlbmd0aCA+IDApXG4gICAgICAgIHJldHVybiBkb2NzO1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKFtdLCB7IGVtcHR5OiB0cnVlIH0sIGNvbXBvc2VyLnN0cmVhbUluZm8oKSk7XG59XG4vKiogUGFyc2UgYW4gaW5wdXQgc3RyaW5nIGludG8gYSBzaW5nbGUgWUFNTC5Eb2N1bWVudCAqL1xuZnVuY3Rpb24gcGFyc2VEb2N1bWVudChzb3VyY2UsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgbGluZUNvdW50ZXIsIHByZXR0eUVycm9ycyB9ID0gcGFyc2VPcHRpb25zKG9wdGlvbnMpO1xuICAgIGNvbnN0IHBhcnNlciA9IG5ldyBQYXJzZXIobGluZUNvdW50ZXIgPT09IG51bGwgfHwgbGluZUNvdW50ZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxpbmVDb3VudGVyLmFkZE5ld0xpbmUpO1xuICAgIGNvbnN0IGNvbXBvc2VyID0gbmV3IENvbXBvc2VyKG9wdGlvbnMpO1xuICAgIC8vIGBkb2NgIGlzIGFsd2F5cyBzZXQgYnkgY29tcG9zZS5lbmQodHJ1ZSkgYXQgdGhlIHZlcnkgbGF0ZXN0XG4gICAgbGV0IGRvYyA9IG51bGw7XG4gICAgZm9yIChjb25zdCBfZG9jIG9mIGNvbXBvc2VyLmNvbXBvc2UocGFyc2VyLnBhcnNlKHNvdXJjZSksIHRydWUsIHNvdXJjZS5sZW5ndGgpKSB7XG4gICAgICAgIGlmICghZG9jKVxuICAgICAgICAgICAgZG9jID0gX2RvYztcbiAgICAgICAgZWxzZSBpZiAoZG9jLm9wdGlvbnMubG9nTGV2ZWwgIT09ICdzaWxlbnQnKSB7XG4gICAgICAgICAgICBkb2MuZXJyb3JzLnB1c2gobmV3IFlBTUxQYXJzZUVycm9yKF9kb2MucmFuZ2Uuc2xpY2UoMCwgMiksICdNVUxUSVBMRV9ET0NTJywgJ1NvdXJjZSBjb250YWlucyBtdWx0aXBsZSBkb2N1bWVudHM7IHBsZWFzZSB1c2UgWUFNTC5wYXJzZUFsbERvY3VtZW50cygpJykpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHByZXR0eUVycm9ycyAmJiBsaW5lQ291bnRlcikge1xuICAgICAgICBkb2MuZXJyb3JzLmZvckVhY2gocHJldHRpZnlFcnJvcihzb3VyY2UsIGxpbmVDb3VudGVyKSk7XG4gICAgICAgIGRvYy53YXJuaW5ncy5mb3JFYWNoKHByZXR0aWZ5RXJyb3Ioc291cmNlLCBsaW5lQ291bnRlcikpO1xuICAgIH1cbiAgICByZXR1cm4gZG9jO1xufVxuZnVuY3Rpb24gcGFyc2Uoc3JjLCByZXZpdmVyLCBvcHRpb25zKSB7XG4gICAgbGV0IF9yZXZpdmVyID0gdW5kZWZpbmVkO1xuICAgIGlmICh0eXBlb2YgcmV2aXZlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBfcmV2aXZlciA9IHJldml2ZXI7XG4gICAgfVxuICAgIGVsc2UgaWYgKG9wdGlvbnMgPT09IHVuZGVmaW5lZCAmJiByZXZpdmVyICYmIHR5cGVvZiByZXZpdmVyID09PSAnb2JqZWN0Jykge1xuICAgICAgICBvcHRpb25zID0gcmV2aXZlcjtcbiAgICB9XG4gICAgY29uc3QgZG9jID0gcGFyc2VEb2N1bWVudChzcmMsIG9wdGlvbnMpO1xuICAgIGlmICghZG9jKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBkb2Mud2FybmluZ3MuZm9yRWFjaCh3YXJuaW5nID0+IHdhcm4oZG9jLm9wdGlvbnMubG9nTGV2ZWwsIHdhcm5pbmcpKTtcbiAgICBpZiAoZG9jLmVycm9ycy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGlmIChkb2Mub3B0aW9ucy5sb2dMZXZlbCAhPT0gJ3NpbGVudCcpXG4gICAgICAgICAgICB0aHJvdyBkb2MuZXJyb3JzWzBdO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBkb2MuZXJyb3JzID0gW107XG4gICAgfVxuICAgIHJldHVybiBkb2MudG9KUyhPYmplY3QuYXNzaWduKHsgcmV2aXZlcjogX3Jldml2ZXIgfSwgb3B0aW9ucykpO1xufVxuZnVuY3Rpb24gc3RyaW5naWZ5KHZhbHVlLCByZXBsYWNlciwgb3B0aW9ucykge1xuICAgIGxldCBfcmVwbGFjZXIgPSBudWxsO1xuICAgIGlmICh0eXBlb2YgcmVwbGFjZXIgPT09ICdmdW5jdGlvbicgfHwgQXJyYXkuaXNBcnJheShyZXBsYWNlcikpIHtcbiAgICAgICAgX3JlcGxhY2VyID0gcmVwbGFjZXI7XG4gICAgfVxuICAgIGVsc2UgaWYgKG9wdGlvbnMgPT09IHVuZGVmaW5lZCAmJiByZXBsYWNlcikge1xuICAgICAgICBvcHRpb25zID0gcmVwbGFjZXI7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ3N0cmluZycpXG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zLmxlbmd0aDtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGNvbnN0IGluZGVudCA9IE1hdGgucm91bmQob3B0aW9ucyk7XG4gICAgICAgIG9wdGlvbnMgPSBpbmRlbnQgPCAxID8gdW5kZWZpbmVkIDogaW5kZW50ID4gOCA/IHsgaW5kZW50OiA4IH0gOiB7IGluZGVudCB9O1xuICAgIH1cbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCB7IGtlZXBVbmRlZmluZWQgfSA9IG9wdGlvbnMgfHwgcmVwbGFjZXIgfHwge307XG4gICAgICAgIGlmICgha2VlcFVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiBuZXcgRG9jdW1lbnQodmFsdWUsIF9yZXBsYWNlciwgb3B0aW9ucykudG9TdHJpbmcob3B0aW9ucyk7XG59XG5cbmV4cG9ydCB7IHBhcnNlLCBwYXJzZUFsbERvY3VtZW50cywgcGFyc2VEb2N1bWVudCwgc3RyaW5naWZ5IH07XG4iLCAiaW1wb3J0IHsgQXBwLCBFZGl0b3IsIEZ1enp5U3VnZ2VzdE1vZGFsLCBGdXp6eU1hdGNoIH0gZnJvbSBcIm9ic2lkaWFuXCI7XG5cbmludGVyZmFjZSBGb290bm90ZVR5cGUge1xuICB0eXBlOiBzdHJpbmc7XG4gIGRlc2NyaXB0aW9uOiBzdHJpbmc7XG59XG5cbmNvbnN0IEFMTF9UWVBFUyA9IFtcbiAge1xuICAgIHR5cGU6IFwiZC9xdWVzdGlvblwiLFxuICAgIGRlc2NyaXB0aW9uOiBcIlF1ZXN0aW9uXCJcbiAgfSxcbiAge1xuICAgIHR5cGU6IFwiZC9hbnN3ZXJcIixcbiAgICBkZXNjcmlwdGlvbjogXCJBbnN3ZXJcIlxuICB9LFxuICB7XG4gICAgdHlwZTogXCJkL3NvbHZlc1wiLFxuICAgIGRlc2NyaXB0aW9uOiBcIlNvbHZlcyBzb21lIHByb2JsZW1cIlxuICB9LFxuICB7XG4gICAgdHlwZTogXCJkL3JlZlwiLFxuICAgIGRlc2NyaXB0aW9uOiBcIlJlZmVyZW5jZVwiXG4gIH0sXG4gIHtcbiAgICB0eXBlOiBcImQvc2VsZnRoaW5rXCIsXG4gICAgZGVzY3JpcHRpb246IFwiU2VsZiB0aGlua1wiXG4gIH0sXG4gIHtcbiAgICB0eXBlOiBcImQvbm90c3VyZVwiLFxuICAgIGRlc2NyaXB0aW9uOiBcIk5vdCBzdXJlXCJcbiAgfSxcbiAge1xuICAgIHR5cGU6IFwiZC9hMVx1MjNGOVx1RkUwRlwiLFxuICAgIGRlc2NyaXB0aW9uOiBcIkExIC0gbXkgZXhwZXJpZW5jZVwiXG4gIH0sXG4gIHtcbiAgICB0eXBlOiBcImQvYTJcdTIzRkFcdUZFMEZcIixcbiAgICBkZXNjcmlwdGlvbjogXCJBMiAtIGZ1dHVyZSBhY3Rpb25cIlxuICB9LFxuICB7XG4gICAgdHlwZTogXCJkL2NcdUQ4M0RcdUREMDRcIixcbiAgICBkZXNjcmlwdGlvbjogXCJDb250ZXh0XCJcbiAgfSxcbiAge1xuICAgIHR5cGU6IFwiZC93XHUyM0VBXCIsXG4gICAgZGVzY3JpcHRpb246IFwiSWRlYSBDb21wYXNzIC0gV2VzdCAtIFdoYXQgYXJlIHNpbWlsYXIgLyBzdXBwb3J0aW5nIGlkZWE/XCJcbiAgfSxcbiAge1xuICAgIHR5cGU6IFwiZC9uXHUyM0VCXCIsXG4gICAgZGVzY3JpcHRpb246IFwiSWRlYSBDb21wYXNzIC0gTm9ydGggLSBXaGVyZSBkb2VzIHRoaXMgaWRlYSBjb21lIGZyb20/XCJcbiAgfSxcbiAge1xuICAgIHR5cGU6IFwiZC9zXHUyM0VDXCIsXG4gICAgZGVzY3JpcHRpb246IFwiSWRlYSBDb21wYXNzIC0gU291dGggLSBXaGVyZSBkb2VzIHRoZSBpZGVhIGxlYWQgdG8/XCJcbiAgfSxcbiAge1xuICAgIHR5cGU6IFwiZC90b01lcmdlXCIsXG4gICAgZGVzY3JpcHRpb246IFwiVE9ETyAtIFRvIE1lcmdlIHdpdGggYW5vdGhlciBub3RlXCJcbiAgfSxcbiAge1xuICAgIHR5cGU6IFwiZC90b01vdmVcIixcbiAgICBkZXNjcmlwdGlvbjogXCJUT0RPIC0gVG8gTWVyZ2Ugd2l0aCBhbm90aGVyIG5vdGVcIlxuICB9LFxuICB7XG4gICAgdHlwZTogXCJkL3RvU3BsaXRcIixcbiAgICBkZXNjcmlwdGlvbjogXCJUb0RPIC0gVG8gU3BsaXQgdG8gbXVsdGlwbGUgbm90ZVwiXG4gIH0sXG4gIHtcbiAgICB0eXBlOiBcImQvdG9DYXJkXCIsXG4gICAgZGVzY3JpcHRpb246IFwiVE9ETyAtIFRvIFdyaXRlIGNhcmRcIlxuICB9LFxuXTtcblxuZXhwb3J0IGNsYXNzIEFkZEZvb3Rub3RlVGFnTW9kYWwgZXh0ZW5kcyBGdXp6eVN1Z2dlc3RNb2RhbDxGb290bm90ZVR5cGU+IHtcblxuICBlZGl0b3I6IEVkaXRvclxuXG4gIGNvbnN0cnVjdG9yKGFwcDogQXBwLCBlZGl0b3I6IEVkaXRvcilcbiAge1xuICAgIHN1cGVyKGFwcClcbiAgICB0aGlzLmVkaXRvciA9IGVkaXRvclxuICB9XG5cbiAgZ2V0SXRlbXMoKTogRm9vdG5vdGVUeXBlW10ge1xuICAgIHJldHVybiBBTExfVFlQRVM7XG4gIH1cblxuICBnZXRJdGVtVGV4dChub3RlVHlwZTogRm9vdG5vdGVUeXBlKTogc3RyaW5nIHtcbiAgICByZXR1cm4gbm90ZVR5cGUudHlwZTtcbiAgfVxuXG4gIHN0YXRpYyByZW1vdmVUYWcobGluZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgICBBTExfVFlQRVMuZm9yRWFjaCgobm90ZVR5cGUpID0+IGxpbmUgPSBsaW5lLnJlcGxhY2UoYCMke25vdGVUeXBlLnR5cGV9IGAsICcnKSlcbiAgICByZXR1cm4gbGluZVxuICB9XG5cbiAgLy8gUmVuZGVycyBlYWNoIHN1Z2dlc3Rpb24gaXRlbS5cbiAgcmVuZGVyU3VnZ2VzdGlvbihjaG9vc2VuTm90ZVR5cGVNYXRjaDogRnV6enlNYXRjaDxGb290bm90ZVR5cGU+LCBlbDogSFRNTEVsZW1lbnQpIHtcbiAgICBjb25zdCBub3RlVHlwZSA9IGNob29zZW5Ob3RlVHlwZU1hdGNoLml0ZW1cbiAgICBlbC5jcmVhdGVFbChcImRpdlwiLCB7IHRleHQ6IG5vdGVUeXBlLnR5cGUgfSk7XG4gICAgZWwuY3JlYXRlRWwoXCJzbWFsbFwiLCB7IHRleHQ6IG5vdGVUeXBlLmRlc2NyaXB0aW9uIH0pO1xuICB9XG5cbiAgY29udGFpbnNUeXBlKGxpbmU6IFN0cmluZykgOiBCb29sZWFuIHtcbiAgICByZXR1cm4gQUxMX1RZUEVTLmZpbHRlcigobm90ZVR5cGUpID0+IGxpbmUuY29udGFpbnMobm90ZVR5cGUudHlwZSkpLmxlbmd0aCA+IDBcbiAgfVxuXG4gIC8vIFBlcmZvcm0gYWN0aW9uIG9uIHRoZSBzZWxlY3RlZCBzdWdnZXN0aW9uLlxuICBvbkNob29zZUl0ZW0oY2hvb3Nlbk5vdGVUeXBlOiBGb290bm90ZVR5cGUsIGV2dDogTW91c2VFdmVudCB8IEtleWJvYXJkRXZlbnQpIHtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSB0aGlzLmVkaXRvci5nZXRTZWxlY3Rpb24oKVxuICAgIGNvbnN0IHJlcGxhY2VkU3RyID0gYCMke2Nob29zZW5Ob3RlVHlwZS50eXBlfSBgXG4gICAgaWYgKHNlbGVjdGlvbi5sZW5ndGggIT0gMCkge1xuICAgICAgICB0aGlzLmVkaXRvci5yZXBsYWNlU2VsZWN0aW9uKHJlcGxhY2VkU3RyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBjdXJzb3IgPSB0aGlzLmVkaXRvci5nZXRDdXJzb3IoKTtcbiAgICAgICAgdGhpcy5lZGl0b3IucmVwbGFjZVJhbmdlKHJlcGxhY2VkU3RyLCBjdXJzb3IpO1xuICAgICAgICBjdXJzb3IuY2ggPSBjdXJzb3IuY2ggKyByZXBsYWNlZFN0ci5sZW5ndGg7XG4gICAgICAgIHRoaXMuZWRpdG9yLnNldEN1cnNvcihjdXJzb3IpO1xuICAgIH1cbiAgfVxufSIsICJpbXBvcnQgeyBBcHAsIEVkaXRvciwgRnV6enlTdWdnZXN0TW9kYWwsIEZ1enp5TWF0Y2ggfSBmcm9tIFwib2JzaWRpYW5cIjtcblxuaW50ZXJmYWNlIENvbW1lbnRUeXBlIHtcbiAgdHlwZTogc3RyaW5nO1xuICBjdXJzb3I6IHN0cmluZztcbiAgZGVzY3JpcHRpb246IHN0cmluZztcbn1cblxuY29uc3QgQUxMX1RZUEVTID0gW1xuICB7XG4gICAgdHlwZTogXCJuXCIsXG4gICAgY3Vyc29yOiBcImNcIixcbiAgICBkZXNjcmlwdGlvbjogXCJOIEN1cnNvclwiXG4gIH0sXG4gIHtcbiAgICB0eXBlOiBcIm5cIixcbiAgICBjdXJzb3I6IFwiYlwiLFxuICAgIGRlc2NyaXB0aW9uOiBcIk4gQmVnaW5uaW5nIG9mIGxpbmVcIlxuICB9LFxuICB7XG4gICAgdHlwZTogXCJuXCIsXG4gICAgY3Vyc29yOiBcImVcIixcbiAgICBkZXNjcmlwdGlvbjogXCJOIEVuZCBvZiBsaW5lXCJcbiAgfSxcbiAge1xuICAgIHR5cGU6IFwid1wiLFxuICAgIGN1cnNvcjogXCJjXCIsXG4gICAgZGVzY3JpcHRpb246IFwiVyBDdXJzb3JcIlxuICB9LFxuICB7XG4gICAgdHlwZTogXCJ3XCIsXG4gICAgY3Vyc29yOiBcImJcIixcbiAgICBkZXNjcmlwdGlvbjogXCJXIEJlZ2lubmluZyBvZiBsaW5lXCJcbiAgfSxcbiAge1xuICAgIHR5cGU6IFwid1wiLFxuICAgIGN1cnNvcjogXCJlXCIsXG4gICAgZGVzY3JpcHRpb246IFwiVyBFbmQgb2YgbGluZVwiXG4gIH1cbl07XG5cbmV4cG9ydCBjbGFzcyBBZGRUYXNrVGFnTW9kYWwgZXh0ZW5kcyBGdXp6eVN1Z2dlc3RNb2RhbDxDb21tZW50VHlwZT4ge1xuXG4gIGVkaXRvcjogRWRpdG9yXG4gIHRhc2tUeXBlOiBTdHJpbmdcblxuICBjb25zdHJ1Y3RvcihhcHA6IEFwcCwgZWRpdG9yOiBFZGl0b3IsIHRhc2tUeXBlOiBTdHJpbmcpXG4gIHtcbiAgICBzdXBlcihhcHApXG4gICAgdGhpcy5lZGl0b3IgPSBlZGl0b3JcbiAgICB0aGlzLnRhc2tUeXBlID0gdGFza1R5cGVcbiAgfVxuXG4gIGdldEl0ZW1zKCk6IENvbW1lbnRUeXBlW10ge1xuICAgIHJldHVybiBBTExfVFlQRVM7XG4gIH1cblxuICBnZXRJdGVtVGV4dChub3RlVHlwZTogQ29tbWVudFR5cGUpOiBzdHJpbmcge1xuICAgIHJldHVybiBub3RlVHlwZS50eXBlICsgbm90ZVR5cGUuY3Vyc29yO1xuICB9XG5cbiAgLy8gUmVuZGVycyBlYWNoIHN1Z2dlc3Rpb24gaXRlbS5cbiAgcmVuZGVyU3VnZ2VzdGlvbihjaG9vc2VuTm90ZVR5cGVNYXRjaDogRnV6enlNYXRjaDxDb21tZW50VHlwZT4sIGVsOiBIVE1MRWxlbWVudCkge1xuICAgIGNvbnN0IG5vdGVUeXBlID0gY2hvb3Nlbk5vdGVUeXBlTWF0Y2guaXRlbVxuICAgIGVsLmNyZWF0ZUVsKFwiZGl2XCIsIHsgdGV4dDogbm90ZVR5cGUudHlwZSArIFwiIFwiICsgbm90ZVR5cGUuY3Vyc29yIH0pO1xuICAgIGVsLmNyZWF0ZUVsKFwic21hbGxcIiwgeyB0ZXh0OiBub3RlVHlwZS5kZXNjcmlwdGlvbiB9KTtcbiAgfVxuXG4gIGNvbnRhaW5zVHlwZShsaW5lOiBTdHJpbmcpIDogQm9vbGVhbiB7XG4gICAgcmV0dXJuIEFMTF9UWVBFUy5maWx0ZXIoKG5vdGVUeXBlKSA9PiBsaW5lLmNvbnRhaW5zKG5vdGVUeXBlLnR5cGUpKS5sZW5ndGggPiAwXG4gIH1cblxuICAvLyBQZXJmb3JtIGFjdGlvbiBvbiB0aGUgc2VsZWN0ZWQgc3VnZ2VzdGlvbi5cbiAgb25DaG9vc2VJdGVtKGNob29zZW5Ob3RlVHlwZTogQ29tbWVudFR5cGUsIGV2dDogTW91c2VFdmVudCB8IEtleWJvYXJkRXZlbnQpIHtcbiAgICBjb25zdCBjdXJzb3IgPSB0aGlzLmVkaXRvci5nZXRDdXJzb3IoKVxuICAgIGNvbnN0IGxpbmUgPSB0aGlzLmVkaXRvci5nZXRMaW5lKGN1cnNvci5saW5lKTtcbiAgICBcbiAgICBpZiAoY2hvb3Nlbk5vdGVUeXBlLmN1cnNvciA9PSBcImNcIikge1xuICAgICAgdGhpcy5lZGl0b3IucmVwbGFjZVJhbmdlKGAke2xpbmUuY2hhckF0KGN1cnNvci5jaCAtIDEpICE9ICcgJyA/ICcgJyA6IFwiXCJ9IyR7Y2hvb3Nlbk5vdGVUeXBlLnR5cGV9JHt0aGlzLnRhc2tUeXBlfSBgLCBjdXJzb3IpOyAgXG4gICAgICBjdXJzb3IuY2ggPSBjdXJzb3IuY2ggKyA0ICsgKGxpbmUuY2hhckF0KGN1cnNvci5jaCAtIDEpICE9ICcgJyA/IDEgOiAwKTtcblx0XHQgIHRoaXMuZWRpdG9yLnNldEN1cnNvcihjdXJzb3IpO1xuICAgIH0gZWxzZSBpZiAoY2hvb3Nlbk5vdGVUeXBlLmN1cnNvciA9PSBcImJcIikge1xuICAgICAgbGV0IG1vZGlmaWVkTGluZSA9IGxpbmU7XG4gICAgICBpZiAoL15cXHQqLSAvLnRlc3QobGluZSkpIHtcbiAgICAgICAgbW9kaWZpZWRMaW5lID0gbGluZS5yZXBsYWNlKC9eKFxcdCotICkvLCBgJDEjJHtjaG9vc2VuTm90ZVR5cGUudHlwZX0ke3RoaXMudGFza1R5cGV9IGApO1xuICAgICAgfSBlbHNlIGlmICgvXlxcdCpcXGQrXFwuIC8udGVzdChsaW5lKSkge1xuICAgICAgICBtb2RpZmllZExpbmUgPSBsaW5lLnJlcGxhY2UoL14oXFx0KlxcZCtcXC4gKS8sIGAkMSR7Y2hvb3Nlbk5vdGVUeXBlLnR5cGV9JHt0aGlzLnRhc2tUeXBlfSBgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1vZGlmaWVkTGluZSA9IGxpbmUucmVwbGFjZSgvXi8sIGAjJHtjaG9vc2VuTm90ZVR5cGUudHlwZX0ke3RoaXMudGFza1R5cGV9IGApO1xuICAgICAgfVxuICAgICAgdGhpcy5lZGl0b3Iuc2V0TGluZShjdXJzb3IubGluZSwgbW9kaWZpZWRMaW5lKTtcbiAgICAgIGN1cnNvci5jaCA9IGN1cnNvci5jaCArIDQ7XG5cdFx0ICB0aGlzLmVkaXRvci5zZXRDdXJzb3IoY3Vyc29yKTtcbiAgICB9IGVsc2UgaWYgKGNob29zZW5Ob3RlVHlwZS5jdXJzb3IgPT0gXCJlXCIpIHtcbiAgICAgIGxldCBtb2RpZmllZExpbmUgPSBsaW5lLnJlcGxhY2UoLyQvLCBgICMke2Nob29zZW5Ob3RlVHlwZS50eXBlfSR7dGhpcy50YXNrVHlwZX1gKTtcbiAgICAgIHRoaXMuZWRpdG9yLnNldExpbmUoY3Vyc29yLmxpbmUsIG1vZGlmaWVkTGluZSk7XG4gICAgICBjdXJzb3IuY2ggPSBjdXJzb3IuY2g7XG5cdFx0ICB0aGlzLmVkaXRvci5zZXRDdXJzb3IoY3Vyc29yKTtcbiAgICB9XG4gICAgXG4gIH1cbn0iLCAiaW1wb3J0IHsgQXBwLCBFZGl0b3IsIEZ1enp5U3VnZ2VzdE1vZGFsLCBGdXp6eU1hdGNoLCBOb3RpY2UgfSBmcm9tIFwib2JzaWRpYW5cIjtcblxuaW50ZXJmYWNlIENvbW1lbnRUeXBlIHtcbiAgdHlwZTogc3RyaW5nO1xuICBkZXNjcmlwdGlvbjogc3RyaW5nO1xufVxuXG5jb25zdCBBTExfVFlQRVMgPSBbXG4gIHtcbiAgICB0eXBlOiBcImZpcnN0LXBhZ2VcIixcbiAgICBkZXNjcmlwdGlvbjogXCJmaXJzdCBwYWdlXCJcbiAgfSxcbiAge1xuICAgIHR5cGU6IFwid2l0aC1oZWFkZXJcIixcbiAgICBkZXNjcmlwdGlvbjogXCJ3aXRoIGhlYWRlclwiXG4gIH0sXG4gIHtcbiAgICB0eXBlOiBcIndpdGhvdXQtaGVhZGVyXCIsXG4gICAgZGVzY3JpcHRpb246IFwid2l0aG91dCBoZWFkZXJcIlxuICB9LFxuICB7XG4gICAgdHlwZTogXCJjdXN0b20tZm9udC1zaXplXCIsXG4gICAgZGVzY3JpcHRpb246IFwiY3VzdG9tIGZvbnQgc2l6ZVwiXG4gIH0sXG5dO1xuXG5leHBvcnQgY2xhc3MgVGhyZWFkc1RvSW1hZ2VzTW9kYWwgZXh0ZW5kcyBGdXp6eVN1Z2dlc3RNb2RhbDxDb21tZW50VHlwZT4ge1xuXG4gIHRocmVhZFNlZ21lbnQ6IFN0cmluZ1xuXG4gIGNvbnN0cnVjdG9yKGFwcDogQXBwLCB0aHJlYWRTZWdtZW50OiBTdHJpbmcpXG4gIHtcbiAgICBzdXBlcihhcHApXG4gICAgdGhpcy50aHJlYWRTZWdtZW50ID0gdGhyZWFkU2VnbWVudFxuICB9XG5cbiAgZ2V0SXRlbXMoKTogQ29tbWVudFR5cGVbXSB7XG4gICAgcmV0dXJuIEFMTF9UWVBFUztcbiAgfVxuXG4gIGdldEl0ZW1UZXh0KG5vdGVUeXBlOiBDb21tZW50VHlwZSk6IHN0cmluZyB7XG4gICAgcmV0dXJuIG5vdGVUeXBlLnR5cGU7XG4gIH1cblxuICAvLyBSZW5kZXJzIGVhY2ggc3VnZ2VzdGlvbiBpdGVtLlxuICByZW5kZXJTdWdnZXN0aW9uKGNob29zZW5Ob3RlVHlwZU1hdGNoOiBGdXp6eU1hdGNoPENvbW1lbnRUeXBlPiwgZWw6IEhUTUxFbGVtZW50KSB7XG4gICAgY29uc3Qgbm90ZVR5cGUgPSBjaG9vc2VuTm90ZVR5cGVNYXRjaC5pdGVtXG4gICAgZWwuY3JlYXRlRWwoXCJkaXZcIiwgeyB0ZXh0OiBub3RlVHlwZS50eXBlIH0pO1xuICAgIGVsLmNyZWF0ZUVsKFwic21hbGxcIiwgeyB0ZXh0OiBub3RlVHlwZS5kZXNjcmlwdGlvbiB9KTtcbiAgfVxuXG4gIGNvbnRhaW5zVHlwZShsaW5lOiBTdHJpbmcpIDogQm9vbGVhbiB7XG4gICAgcmV0dXJuIEFMTF9UWVBFUy5maWx0ZXIoKG5vdGVUeXBlKSA9PiBsaW5lLmNvbnRhaW5zKG5vdGVUeXBlLnR5cGUpKS5sZW5ndGggPiAwXG4gIH1cblxuICAvLyBQZXJmb3JtIGFjdGlvbiBvbiB0aGUgc2VsZWN0ZWQgc3VnZ2VzdGlvbi5cbiAgb25DaG9vc2VJdGVtKGNob29zZW5Ob3RlVHlwZTogQ29tbWVudFR5cGUsIGV2dDogTW91c2VFdmVudCB8IEtleWJvYXJkRXZlbnQpIHtcbiAgICBsZXQgcGFyYW0gPSBjaG9vc2VuTm90ZVR5cGUudHlwZVxuICAgIGxldCBzID0gdGhpcy50aHJlYWRTZWdtZW50LnRvU3RyaW5nKClcbiAgICBuYXZpZ2F0b3IuY2xpcGJvYXJkLndyaXRlVGV4dCh0aGlzLnRocmVhZFNlZ21lbnQudG9TdHJpbmcoKSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIG5ldyBOb3RpY2UoYENvcGllZFxcblxcYFxcYFxcYFxcbiR7c31cXGBcXGBcXGBcXG50byBjbGlwYm9hcmQhYCk7XG4gICAgICAgIHdpbmRvdy5vcGVuKGBzaG9ydGN1dHM6Ly9ydW4tc2hvcnRjdXQ/bmFtZT1UaHJlYWRzJTIwdG8lMjBpbWFnZSZpbnB1dD10ZXh0JnRleHQ9JHtwYXJhbX0meC1zdWNjZXNzPW9ic2lkaWFuOi8vJngtY2FuY2VsPW9ic2lkaWFuOi8vJngtZXJyb3I9b2JzaWRpYW46Ly9gKTtcbiAgICB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgbmV3IE5vdGljZShgZXJyb3Igd2hlbiBjb3B5IHRvIGNsaXBib2FyZCFgKTtcbiAgICB9KTtcbiAgfVxufSIsICJpbXBvcnQgeyBBcHAsIEVkaXRvciwgRnV6enlTdWdnZXN0TW9kYWwsIEZ1enp5TWF0Y2gsIFRGaWxlLCBWYXVsdCB9IGZyb20gXCJvYnNpZGlhblwiO1xuXG5pbnRlcmZhY2UgQ29weU9yTW92ZSB7XG4gIHR5cGU6IHN0cmluZztcbiAgZGVzY3JpcHRpb246IHN0cmluZztcbn1cblxuY29uc3QgQUxMX1RZUEVTID0gW1xuICB7XG4gICAgdHlwZTogXCJjb3B5XCIsXG4gICAgZGVzY3JpcHRpb246IFwiQ29weVwiXG4gIH0sXG4gIHtcbiAgICB0eXBlOiBcIm1vdmVcIixcbiAgICBkZXNjcmlwdGlvbjogXCJNb3ZlXCJcbiAgfSxcbl07XG5cbmV4cG9ydCBjbGFzcyBDb3B5T3JNb3ZlVG9OZXdOb3RlTW9kYWwgZXh0ZW5kcyBGdXp6eVN1Z2dlc3RNb2RhbDxDb3B5T3JNb3ZlPiB7XG5cbiAgZWRpdG9yOiBFZGl0b3JcbiAgdGFza1R5cGU6IFN0cmluZ1xuXG4gIGNvbnN0cnVjdG9yKGFwcDogQXBwLCBlZGl0b3I6IEVkaXRvcilcbiAge1xuICAgIHN1cGVyKGFwcClcbiAgICB0aGlzLmVkaXRvciA9IGVkaXRvclxuICAgIHRoaXMuc2V0UGxhY2Vob2xkZXIoYENvcHkgb3IgbW92ZSBzZWxlY3Rpb24gdG8gbmV3IG5vdGU/YClcbiAgfVxuXG4gIGdldEl0ZW1zKCk6IENvcHlPck1vdmVbXSB7XG4gICAgcmV0dXJuIEFMTF9UWVBFUztcbiAgfVxuXG4gIGdldEl0ZW1UZXh0KG5vdGVUeXBlOiBDb3B5T3JNb3ZlKTogc3RyaW5nIHtcbiAgICByZXR1cm4gbm90ZVR5cGUudHlwZTtcbiAgfVxuXG4gIC8vIFJlbmRlcnMgZWFjaCBzdWdnZXN0aW9uIGl0ZW0uXG4gIHJlbmRlclN1Z2dlc3Rpb24oY2hvb3Nlbk5vdGVUeXBlTWF0Y2g6IEZ1enp5TWF0Y2g8Q29weU9yTW92ZT4sIGVsOiBIVE1MRWxlbWVudCkge1xuICAgIGNvbnN0IG5vdGVUeXBlID0gY2hvb3Nlbk5vdGVUeXBlTWF0Y2guaXRlbVxuICAgIGVsLmNyZWF0ZUVsKFwiZGl2XCIsIHsgdGV4dDogbm90ZVR5cGUudHlwZSB9KTtcbiAgICBlbC5jcmVhdGVFbChcInNtYWxsXCIsIHsgdGV4dDogbm90ZVR5cGUuZGVzY3JpcHRpb24gfSk7XG4gIH1cblxuICBjb250YWluc1R5cGUobGluZTogU3RyaW5nKSA6IEJvb2xlYW4ge1xuICAgIHJldHVybiBBTExfVFlQRVMuZmlsdGVyKChub3RlVHlwZSkgPT4gbGluZS5jb250YWlucyhub3RlVHlwZS50eXBlKSkubGVuZ3RoID4gMFxuICB9XG5cbiAgLy8gUGVyZm9ybSBhY3Rpb24gb24gdGhlIHNlbGVjdGVkIHN1Z2dlc3Rpb24uXG4gIGFzeW5jIG9uQ2hvb3NlSXRlbShjaG9vc2VuT3BlcmF0aW9uOiBDb3B5T3JNb3ZlLCBldnQ6IE1vdXNlRXZlbnQgfCBLZXlib2FyZEV2ZW50KSB7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gdGhpcy5lZGl0b3IuZ2V0U2VsZWN0aW9uKClcbiAgICBjb25zdCBsaW5lID0gdGhpcy5lZGl0b3IuZ2V0Q3Vyc29yKCkubGluZVxuICAgIGNvbnN0IHRleHRUb0NvcHlPck1vdmUgPSAoc2VsZWN0aW9uLmxlbmd0aCA9PSAwKVxuICAgICAgICAgICAgICAgID8gdGhpcy5lZGl0b3IuZ2V0TGluZShsaW5lKVxuICAgICAgICAgICAgICAgIDogc2VsZWN0aW9uXG4gICAgXG4gICAgY29uc3QgbmV3RmlsZU5hbWUgPSBcIkkvVW5pdGVkIFB1c2gubWRcIlxuICAgIGF3YWl0IHRoaXMuY3JlYXRlT3JBcHBlbmRGaWxlKG5ld0ZpbGVOYW1lLCB0ZXh0VG9Db3B5T3JNb3ZlKVxuXG4gICAgaWYgKGNob29zZW5PcGVyYXRpb24udHlwZSA9PSBcIm1vdmVcIikge1xuICAgICAgaWYgKHNlbGVjdGlvbi5sZW5ndGggIT0gMCkge1xuICAgICAgICB0aGlzLmVkaXRvci5yZXBsYWNlU2VsZWN0aW9uKFwiXCIpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgY29udGVudCA9IFwiXCJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmVkaXRvci5saW5lQ291bnQoKTsgaSsrKSB7XG4gICAgICAgICAgaWYgKGkgIT0gbGluZSkge1xuICAgICAgICAgICAgY29udGVudCArPSB0aGlzLmVkaXRvci5nZXRMaW5lKGkpICsgXCJcXG5cIlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVkaXRvci5zZXRWYWx1ZShjb250ZW50KVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHsgdmF1bHQgfSA9IHRoaXMuYXBwO1xuICAgIGNvbnN0IHsgd29ya3NwYWNlIH0gPSB0aGlzLmFwcDtcbiAgICBjb25zdCBtb2RlID0gKHRoaXMuYXBwLnZhdWx0IGFzIGFueSkuZ2V0Q29uZmlnKFwiZGVmYXVsdFZpZXdNb2RlXCIpO1xuICAgIGNvbnN0IGxlYWYgPSB3b3Jrc3BhY2UuZ2V0TGVhZihmYWxzZSk7XG4gICAgYXdhaXQgbGVhZi5vcGVuRmlsZSh2YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgobmV3RmlsZU5hbWUpIGFzIFRGaWxlLCB7IGFjdGl2ZSA6IHRydWUsfSk7XG4gIH1cblxuICBhc3luYyBjcmVhdGVPckFwcGVuZEZpbGUoZmlsZVBhdGg6IHN0cmluZywgbm90ZTogc3RyaW5nKSB7XG5cdFx0Ly9JZiBmaWxlcyBleGlzdHMgdGhlbiBhcHBlbmQgY29uZW50IHRvIGV4aXN0aW5nIGZpbGVcblx0XHRjb25zdCB7IHZhdWx0IH0gPSB0aGlzLmFwcDtcblx0XHRjb25zdCBmaWxlRXhpc3RzID0gYXdhaXQgdmF1bHQuYWRhcHRlci5leGlzdHMoZmlsZVBhdGgpO1xuXHRcdGlmKGZpbGVFeGlzdHMpe1xuXHRcdFx0YXdhaXQgdGhpcy5hcHBlbmRGaWxlKHZhdWx0LCBmaWxlUGF0aCwgbm90ZSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGF3YWl0IHZhdWx0LmNyZWF0ZShmaWxlUGF0aCwgXCItLS1cXG50YWc6IGIvbi9zXFxuLS0tXFxuXFxuXCIgKyBub3RlKTtcblx0XHR9XG5cdFx0cmV0dXJuIGZpbGVQYXRoO1xuXHR9XG5cbiAgICBhc3luYyBhcHBlbmRGaWxlKHZhdWx0OiBWYXVsdCwgZmlsZVBhdGg6IHN0cmluZywgbm90ZTogc3RyaW5nKSB7XG5cdFx0bGV0IGV4aXN0aW5nQ29udGVudCA9IGF3YWl0IHZhdWx0LmFkYXB0ZXIucmVhZChmaWxlUGF0aCk7XG5cdFx0aWYoZXhpc3RpbmdDb250ZW50Lmxlbmd0aCA+IDApIHtcblx0XHQgIGV4aXN0aW5nQ29udGVudCA9IGV4aXN0aW5nQ29udGVudCArICdcXHJcXHInO1xuXHRcdH1cblx0XHRhd2FpdCB2YXVsdC5hZGFwdGVyLndyaXRlKGZpbGVQYXRoLCBleGlzdGluZ0NvbnRlbnQgKyBub3RlKTtcblx0ICB9XG59IiwgImltcG9ydCB7IEFwcCwgRWRpdG9yLCBGdXp6eVN1Z2dlc3RNb2RhbCwgRnV6enlNYXRjaCB9IGZyb20gXCJvYnNpZGlhblwiO1xuXG5leHBvcnQgY2xhc3MgQ2xpcGJvYXJkUGFzdGVNb2RhbCBleHRlbmRzIEZ1enp5U3VnZ2VzdE1vZGFsPHN0cmluZz4ge1xuXG4gIGVkaXRvcjogRWRpdG9yXG5cbiAgY2xpcGJvYXJkQ29udGVudDogc3RyaW5nW11cblxuICBjb25zdHJ1Y3RvcihhcHA6IEFwcCwgZWRpdG9yOiBFZGl0b3IsIGNsaXBib2FyZENvbnRlbnQ6IHN0cmluZ1tdKVxuICB7XG4gICAgc3VwZXIoYXBwKVxuICAgIHRoaXMuZWRpdG9yID0gZWRpdG9yXG4gICAgdGhpcy5jbGlwYm9hcmRDb250ZW50ID0gY2xpcGJvYXJkQ29udGVudFxuICAgIHRoaXMuc2V0UGxhY2Vob2xkZXIoYFdoaWNoIGNsaXBib2FyZCBjb250ZW50IGRvIHlvdSB3YW50IHRvIHBhc3RlP2ApXG4gIH1cblxuICBnZXRJdGVtcygpOiBzdHJpbmdbXSB7XG4gICAgcmV0dXJuIHRoaXMuY2xpcGJvYXJkQ29udGVudC5zbGljZSgpLnJldmVyc2UoKTtcbiAgfVxuXG4gIGdldEl0ZW1UZXh0KGl0ZW06IHN0cmluZyk6IHN0cmluZyB7XG4gICAgcmV0dXJuIGl0ZW07XG4gIH1cblxuICAvLyBSZW5kZXJzIGVhY2ggc3VnZ2VzdGlvbiBpdGVtLlxuICByZW5kZXJTdWdnZXN0aW9uKGk6IEZ1enp5TWF0Y2g8c3RyaW5nPiwgZWw6IEhUTUxFbGVtZW50KSB7XG4gICAgY29uc3QgaXRlbSA9IGkuaXRlbVxuICAgIC8vZWwuY3JlYXRlRWwoXCJkaXZcIiwgeyB0ZXh0OiBpdGVtIH0pO1xuICAgIGVsLmNyZWF0ZUVsKFwiZGl2XCIsIHsgdGV4dDogXCJcdTIwMjIgXCIgKyBpdGVtLnJlcGxhY2UoL1xcbi9nbSwgXCJcIikuc3Vic3RyaW5nKDAsIDEwMCkgfSk7XG4gIH1cblxuICAvLyBQZXJmb3JtIGFjdGlvbiBvbiB0aGUgc2VsZWN0ZWQgc3VnZ2VzdGlvbi5cbiAgb25DaG9vc2VJdGVtKHNlbGVjdGVkQ29udGVudDogc3RyaW5nLCBldnQ6IE1vdXNlRXZlbnQgfCBLZXlib2FyZEV2ZW50KSB7XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLmNsaXBib2FyZENvbnRlbnQuaW5kZXhPZihzZWxlY3RlZENvbnRlbnQsIDApO1xuICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICB0aGlzLmNsaXBib2FyZENvbnRlbnQucmVtb3ZlKHNlbGVjdGVkQ29udGVudCk7XG4gICAgfVxuICAgIHRoaXMuY2xpcGJvYXJkQ29udGVudC5wdXNoKHNlbGVjdGVkQ29udGVudCk7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gdGhpcy5lZGl0b3IuZ2V0U2VsZWN0aW9uKClcbiAgICBjb25zdCByZXBsYWNlZFN0ciA9IHNlbGVjdGVkQ29udGVudFxuICAgIGlmIChzZWxlY3Rpb24ubGVuZ3RoICE9IDApIHtcbiAgICAgICAgdGhpcy5lZGl0b3IucmVwbGFjZVNlbGVjdGlvbihyZXBsYWNlZFN0cik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgY3Vyc29yID0gdGhpcy5lZGl0b3IuZ2V0Q3Vyc29yKCk7XG4gICAgICAgIHRoaXMuZWRpdG9yLnJlcGxhY2VSYW5nZShyZXBsYWNlZFN0ciwgY3Vyc29yKTtcbiAgICAgICAgY3Vyc29yLmNoID0gY3Vyc29yLmNoICsgcmVwbGFjZWRTdHIubGVuZ3RoO1xuICAgICAgICB0aGlzLmVkaXRvci5zZXRDdXJzb3IoY3Vyc29yKTtcbiAgICB9XG4gIH1cbn0iLCAiaW1wb3J0IHsgQXBwLCBFZGl0b3IsIEZ1enp5U3VnZ2VzdE1vZGFsLCBGdXp6eU1hdGNoLCBURmlsZSB9IGZyb20gXCJvYnNpZGlhblwiO1xuXG5leHBvcnQgY2xhc3MgT3BlblBsYXlncm91bmRNb2RhbCBleHRlbmRzIEZ1enp5U3VnZ2VzdE1vZGFsPHN0cmluZz4ge1xuXG4gIHJlbW92ZUV4aXN0aW5nQ29udGVudCA6IHN0cmluZyA9IFwiUmVtb3ZlIHBsYXlncm91bmQgY29udGVudFwiXG4gIG5vdFJlbW92ZUV4aXN0aW5nQ29udGVudDogc3RyaW5nID0gXCJOb3QgcmVtb3ZlIGV4aXN0aW5nIHBsYXlncm91bmQgY29udGVudFwiXG4gIHBsYXlncm91bmRNZDogc3RyaW5nID0gXCJJL1BsYXlncm91bmQubWRcIlxuICBvcHRpb25zOiBzdHJpbmdbXSA9IFt0aGlzLnJlbW92ZUV4aXN0aW5nQ29udGVudCwgdGhpcy5ub3RSZW1vdmVFeGlzdGluZ0NvbnRlbnRdXG5cbiAgY29uc3RydWN0b3IoYXBwOiBBcHApXG4gIHtcbiAgICBzdXBlcihhcHApXG4gIH1cblxuICBnZXRJdGVtcygpOiBzdHJpbmdbXSB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy5yZXZlcnNlKCk7XG4gIH1cblxuICBnZXRJdGVtVGV4dChpdGVtOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIHJldHVybiBpdGVtO1xuICB9XG5cbiAgLy8gUmVuZGVycyBlYWNoIHN1Z2dlc3Rpb24gaXRlbS5cbiAgcmVuZGVyU3VnZ2VzdGlvbihpOiBGdXp6eU1hdGNoPHN0cmluZz4sIGVsOiBIVE1MRWxlbWVudCkge1xuICAgIGNvbnN0IGl0ZW0gPSBpLml0ZW1cbiAgICBlbC5jcmVhdGVFbChcImRpdlwiLCB7IHRleHQ6IGl0ZW0gfSk7XG4gIH1cblxuICAvLyBQZXJmb3JtIGFjdGlvbiBvbiB0aGUgc2VsZWN0ZWQgc3VnZ2VzdGlvbi5cbiAgYXN5bmMgb25DaG9vc2VJdGVtKHNlbGVjdGVkQ29udGVudDogc3RyaW5nLCBldnQ6IE1vdXNlRXZlbnQgfCBLZXlib2FyZEV2ZW50KSB7XG4gICAgY29uc3QgY2hvb3Nlbk9wdGlvbiA9IHNlbGVjdGVkQ29udGVudFxuXG4gICAgY29uc3QgeyB2YXVsdCB9ID0gdGhpcy5hcHA7XG4gICAgY29uc3QgeyB3b3Jrc3BhY2UgfSA9IHRoaXMuYXBwO1xuICAgIGNvbnN0IGxlYWYgPSB3b3Jrc3BhY2UuZ2V0TGVhZihmYWxzZSk7XG5cbiAgICBQcm9taXNlLnJlc29sdmUoKVxuICAgIC50aGVuKCgpID0+IHtcbiAgICAgIGlmICh2YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgodGhpcy5wbGF5Z3JvdW5kTWQpID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHZhdWx0LmNyZWF0ZSh0aGlzLnBsYXlncm91bmRNZCwgXCJcIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKHRoaXMucGxheWdyb3VuZE1kKVxuICAgIH0pXG4gICAgLnRoZW4oKHRGaWxlKSA9PiB7XG4gICAgICBpZiAodGhpcy5yZW1vdmVFeGlzdGluZ0NvbnRlbnQgPT09IGNob29zZW5PcHRpb24pIHtcbiAgICAgICAgcmV0dXJuIHZhdWx0Lm1vZGlmeSh0RmlsZSBhcyBURmlsZSwgXCJcIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKClcbiAgICB9KVxuICAgIC50aGVuKCgpID0+IHtcbiAgICAgIHJldHVybiBsZWFmLm9wZW5GaWxlKHZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aCh0aGlzLnBsYXlncm91bmRNZCkgYXMgVEZpbGUsIHsgYWN0aXZlIDogdHJ1ZX0pO1xuICAgIH0pXG4gIH1cbn0iLCAiaW1wb3J0IHsgQXBwLCBFZGl0b3IsIEZ1enp5U3VnZ2VzdE1vZGFsLCBGdXp6eU1hdGNoLCBURmlsZSwgTm90aWNlLCBNYXJrZG93blZpZXcgfSBmcm9tIFwib2JzaWRpYW5cIjtcblxuZXhwb3J0IGNsYXNzIFRocmVhZHNUb0Jsb2dNb2RhbCBleHRlbmRzIEZ1enp5U3VnZ2VzdE1vZGFsPHN0cmluZz4ge1xuXG4gIHRvTmV3Tm90ZSA6IHN0cmluZyA9IFwiVG8gTmV3IE5vdGVcIlxuICB0b0NsaXBib2FyZDogc3RyaW5nID0gXCJUbyBDbGlwYm9hcmRcIlxuICBvcHRpb25zOiBzdHJpbmdbXSA9IFt0aGlzLnRvTmV3Tm90ZSwgdGhpcy50b0NsaXBib2FyZF1cbiAgZWRpdG9yOiBFZGl0b3JcbiAgdmlldzogTWFya2Rvd25WaWV3XG5cbiAgY29uc3RydWN0b3IoYXBwOiBBcHAsIGVkaXRvcjogRWRpdG9yLCB2aWV3OiBNYXJrZG93blZpZXcpXG4gIHtcbiAgICBzdXBlcihhcHApXG4gICAgdGhpcy5lZGl0b3IgPSBlZGl0b3JcbiAgICB0aGlzLnZpZXcgPSB2aWV3XG4gICAgdGhpcy5zZXRQbGFjZWhvbGRlcihgUHV0dGluZyBUaHJlYWRzIGNvbnRlbnQgdG8gQmxvZyBub3Rlcy4gV2hpY2ggb3B0aW9uIGRvIHlvdSB3YW50IHRvIHByb2NlZWQ/YClcbiAgfVxuXG4gIGdldEl0ZW1zKCk6IHN0cmluZ1tdIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zO1xuICB9XG5cbiAgZ2V0SXRlbVRleHQoaXRlbTogc3RyaW5nKTogc3RyaW5nIHtcbiAgICByZXR1cm4gaXRlbTtcbiAgfVxuXG4gIC8vIFJlbmRlcnMgZWFjaCBzdWdnZXN0aW9uIGl0ZW0uXG4gIHJlbmRlclN1Z2dlc3Rpb24oaTogRnV6enlNYXRjaDxzdHJpbmc+LCBlbDogSFRNTEVsZW1lbnQpIHtcbiAgICBjb25zdCBpdGVtID0gaS5pdGVtXG4gICAgZWwuY3JlYXRlRWwoXCJkaXZcIiwgeyB0ZXh0OiBpdGVtIH0pO1xuICB9XG5cbiAgLy8gUGVyZm9ybSBhY3Rpb24gb24gdGhlIHNlbGVjdGVkIHN1Z2dlc3Rpb24uXG4gIG9uQ2hvb3NlSXRlbShzZWxlY3RlZENvbnRlbnQ6IHN0cmluZywgZXZ0OiBNb3VzZUV2ZW50IHwgS2V5Ym9hcmRFdmVudCkge1xuICAgIGNvbnN0IGNob29zZW5PcHRpb24gPSBzZWxlY3RlZENvbnRlbnRcblxuICAgIGNvbnN0IGxpbmVDb3VudCA9IHRoaXMuZWRpdG9yLmxpbmVDb3VudCgpO1xuICAgIGxldCB0YWdMaW5lTnVtYmVyID0gbnVsbDtcbiAgICBsZXQgbWV0YWRhdGFMaW5lQ291bnQgPSAwO1xuICAgIGxldCB0ZXh0ID0gXCJcIlxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZUNvdW50OyBpKyspIHtcbiAgICAgIGxldCBsaW5lID0gdGhpcy5lZGl0b3IuZ2V0TGluZShpKTtcbiAgICAgIGlmICghbGluZS50cmltKCkuc3RhcnRzV2l0aChcIiUlXCIpIHx8ICFsaW5lLnRyaW0oKS5lbmRzV2l0aChcIiUlXCIpKSB7XG4gICAgICAgIGxldCBtb2RpZmllZExpbmUgPSBsaW5lLnJlcGxhY2UoJ1x1RDgzRVx1RERGNSAnLCAnIyAnKS5yZXBsYWNlKCdcdTMwMTAnLCAnJykucmVwbGFjZSgnXHUzMDExJywgJycpLnJlcGxhY2UoJ1x1RDgzRFx1REM0NycsICcnKVxuICAgICAgICBpZiAobW9kaWZpZWRMaW5lID09ICctLS0nKSB7XG4gICAgICAgICAgbWV0YWRhdGFMaW5lQ291bnQrK1xuICAgICAgICAgIGlmIChtZXRhZGF0YUxpbmVDb3VudCA+IDIpIHtcbiAgICAgICAgICAgIGlmIChtZXRhZGF0YUxpbmVDb3VudCA9PSAzKSB7XG4gICAgICAgICAgICAgIG1vZGlmaWVkTGluZSA9IG1vZGlmaWVkTGluZS5yZXBsYWNlKCctLS0nLCAnJylcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobWV0YWRhdGFMaW5lQ291bnQgPT0gNCkge1xuICAgICAgICAgICAgICBtb2RpZmllZExpbmUgPSBtb2RpZmllZExpbmUucmVwbGFjZSgnLS0tJywgJzwhLS1tb3JlLS0+XFxuXFxuKipcdTc2RUVcdTkzMDRcdUZGMUEqKlxcblxcbiogVGFibGUgb2YgQ29udGVudFxcbns6dG9jfVxcblxcbiMjIC4nKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbW9kaWZpZWRMaW5lID0gbW9kaWZpZWRMaW5lLnJlcGxhY2UoJy0tLScsICcjIyAuJylcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobWV0YWRhdGFMaW5lQ291bnQgPT0gMSB8fCBtZXRhZGF0YUxpbmVDb3VudCA9PSAyKSB7XG4gICAgICAgICAgbW9kaWZpZWRMaW5lID0gbW9kaWZpZWRMaW5lLnJlcGxhY2UoXCJjL3QvcFwiLCBcImMvYi9kXCIpXG4gICAgICAgICAgbW9kaWZpZWRMaW5lID0gbW9kaWZpZWRMaW5lLnJlcGxhY2UoXCJjL3QvdFwiLCBcImMvYi9kXCIpXG4gICAgICAgICAgbW9kaWZpZWRMaW5lID0gbW9kaWZpZWRMaW5lLnJlcGxhY2UoXCJjL3QvclwiLCBcImMvYi9kXCIpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoL14hXFxbLipcXF1cXCguKlxcKS8udGVzdChtb2RpZmllZExpbmUudHJpbSgpKSkge1xuICAgICAgICAgIGlmICghbW9kaWZpZWRMaW5lLmNvbnRhaW5zKFwiaHR0cHM6Ly9yb3VsZXNvcGh5LmdpdGh1Yi5pb1wiKSkge1xuICAgICAgICAgICAgbW9kaWZpZWRMaW5lID0gbW9kaWZpZWRMaW5lLnJlcGxhY2UoLyFcXFsoW15cXFtcXF1cXChcXCldKylcXF1cXCgoW15cXFtcXF1cXChcXCldKylcXCkvZywgXCIkMlwiKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0ZXh0ID0gdGV4dCArIG1vZGlmaWVkTGluZSArIFwiXFxuXCI7XG4gICAgICB9XG4gICAgfVxuICAgIHRleHQgKz0gYFxcblxcbi0tLVxcblxcbiNubCBnZW5lcmF0ZSBzdW1tYXJ5IGZvciBtZXRhIGRlc2NyaXB0aW9uIGJlbG93OlxcblxcblxcblxcbmBcbiAgICB0ZXh0ICs9IGAtLS1cXG5cXG4jIyBSZWZlcmVuY2VzOlxcblxcbi0gVGhyZWFkIHBvc3QgMTogW1ske3RoaXMudmlldy5maWxlLmJhc2VuYW1lfV1dXFxuLSBCbG9nIGxpbms6IFxcbmBcblxuICAgIGNvbnN0IHsgdmF1bHQgfSA9IHRoaXMuYXBwO1xuXG4gICAgaWYgKHRoaXMudG9OZXdOb3RlID09PSBjaG9vc2VuT3B0aW9uKSB7XG4gICAgICBjb25zdCB7IHZhdWx0IH0gPSB0aGlzLmFwcDtcbiAgICAgIGNvbnN0IHBhdGggPSB0aGlzLnZpZXcuZmlsZS5wYXRoXG4gICAgICBjb25zdCBuZXdQYXRoID0gcGF0aC5tYXRjaCgvLlxcL1RocmVhZHMgXFxkXFxkXFxkXFxkXFxkXFxkXFxkXFxkLylcbiAgICAgICAgICAgICAgICAgICAgICA/IHBhdGgucmVwbGFjZSgvKC5cXC8pVGhyZWFkcyBcXGRcXGRcXGRcXGRcXGRcXGRcXGRcXGQvLCBcIiQxQmxvZyBcIilcbiAgICAgICAgICAgICAgICAgICAgICA6IHBhdGgucmVwbGFjZSgvKC5cXC8pLywgXCIkMUJsb2cgXCIpXG5cbiAgICAgIGNvbnN0IHsgd29ya3NwYWNlIH0gPSB0aGlzLmFwcDtcbiAgICAgIGNvbnN0IGxlYWYgPSB3b3Jrc3BhY2UuZ2V0TGVhZihmYWxzZSk7XG4gICAgICBQcm9taXNlLnJlc29sdmUoKVxuICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICByZXR1cm4gdmF1bHQuYWRhcHRlci5leGlzdHMobmV3UGF0aCk7XG4gICAgICB9KVxuICAgICAgLnRoZW4oKGZpbGVFeGlzdHMpID0+IHtcbiAgICAgICAgaWYgKGZpbGVFeGlzdHMpIHtcbiAgICAgICAgICBuZXcgTm90aWNlKGBXaWxsIG5vdCBwcm9jZWVkLiBCbG9nIHBvc3QgXCIke25ld1BhdGh9XCIgYWxyZWFkeSBleGlzdC5gKTtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoXCJCbG9nIHBvc3QgZXhpc3RcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhdWx0LmNyZWF0ZShuZXdQYXRoLCB0ZXh0KTtcbiAgICAgIH0pXG4gICAgICAudGhlbigodEZpbGUpID0+IHtcbiAgICAgICAgcmV0dXJuIGxlYWYub3BlbkZpbGUodEZpbGUsIHsgYWN0aXZlIDogdHJ1ZX0pO1xuICAgICAgfSxcbiAgICAgIChyZWplY3RSZWFzb24pID0+IHt9KVxuICAgIH1cbiAgICBpZiAodGhpcy50b0NsaXBib2FyZCA9PT0gY2hvb3Nlbk9wdGlvbikge1xuICAgICAgbmF2aWdhdG9yLmNsaXBib2FyZC53cml0ZVRleHQodGV4dCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIG5ldyBOb3RpY2UoYENvcGllZCBibG9nIGNvbnRlbnQgdG8gY2xpcGJvYXJkIWApO1xuICAgICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgIG5ldyBOb3RpY2UoYGVycm9yIHdoZW4gY29weSB0byBjbGlwYm9hcmQhYCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn0iLCAiaW1wb3J0IHsgQXBwLCBFZGl0b3IsIEZ1enp5U3VnZ2VzdE1vZGFsLCBGdXp6eU1hdGNoLCBOb3RpY2UgfSBmcm9tIFwib2JzaWRpYW5cIjtcblxuZXhwb3J0IGNsYXNzIENsaXBib2FyZFJlbW92YWxNb2RhbCBleHRlbmRzIEZ1enp5U3VnZ2VzdE1vZGFsPHN0cmluZz4ge1xuXG4gIGVkaXRvcjogRWRpdG9yXG5cbiAgY2xpcGJvYXJkQ29udGVudDogc3RyaW5nW11cblxuICBSRU1PVkVfQUxMIDogc3RyaW5nID0gXCJSRU1PVkUgQUxMXCJcblxuICBjb25zdHJ1Y3RvcihhcHA6IEFwcCwgZWRpdG9yOiBFZGl0b3IsIGNsaXBib2FyZENvbnRlbnQ6IHN0cmluZ1tdKVxuICB7XG4gICAgc3VwZXIoYXBwKVxuICAgIHRoaXMuZWRpdG9yID0gZWRpdG9yXG4gICAgdGhpcy5jbGlwYm9hcmRDb250ZW50ID0gY2xpcGJvYXJkQ29udGVudFxuICAgIHRoaXMuc2V0UGxhY2Vob2xkZXIoYFdoaWNoIGNsaXBib2FyZCBjb250ZW50IGRvIHlvdSB3YW50IHRvIHJlbW92ZT9gKVxuICB9XG5cbiAgZ2V0SXRlbXMoKTogc3RyaW5nW10ge1xuICAgIHJldHVybiBbLi4uW3RoaXMuUkVNT1ZFX0FMTF0sIC4uLnRoaXMuY2xpcGJvYXJkQ29udGVudC5zbGljZSgpLnJldmVyc2UoKV07XG4gIH1cblxuICBnZXRJdGVtVGV4dChpdGVtOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIHJldHVybiBpdGVtO1xuICB9XG5cbiAgLy8gUmVuZGVycyBlYWNoIHN1Z2dlc3Rpb24gaXRlbS5cbiAgcmVuZGVyU3VnZ2VzdGlvbihpOiBGdXp6eU1hdGNoPHN0cmluZz4sIGVsOiBIVE1MRWxlbWVudCkge1xuICAgIGNvbnN0IGl0ZW0gPSBpLml0ZW1cbiAgICAvL2VsLmNyZWF0ZUVsKFwiZGl2XCIsIHsgdGV4dDogaXRlbSB9KTtcbiAgICBlbC5jcmVhdGVFbChcImRpdlwiLCB7IHRleHQ6IFwiXHUyMDIyIFwiICsgaXRlbS5yZXBsYWNlKC9cXG4vZ20sIFwiXCIpLnN1YnN0cmluZygwLCAxMDApIH0pO1xuICB9XG5cbiAgLy8gUGVyZm9ybSBhY3Rpb24gb24gdGhlIHNlbGVjdGVkIHN1Z2dlc3Rpb24uXG4gIG9uQ2hvb3NlSXRlbShzZWxlY3RlZENvbnRlbnQ6IHN0cmluZywgZXZ0OiBNb3VzZUV2ZW50IHwgS2V5Ym9hcmRFdmVudCkge1xuICAgIGlmIChzZWxlY3RlZENvbnRlbnQgPT09IHRoaXMuUkVNT1ZFX0FMTCkge1xuICAgICAgbmV3IE5vdGljZShcImhhaGFcIilcbiAgICAgIHdoaWxlKHRoaXMuY2xpcGJvYXJkQ29udGVudC5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRoaXMuY2xpcGJvYXJkQ29udGVudC5wb3AoKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgaW5kZXggPSB0aGlzLmNsaXBib2FyZENvbnRlbnQuaW5kZXhPZihzZWxlY3RlZENvbnRlbnQsIDApO1xuICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgdGhpcy5jbGlwYm9hcmRDb250ZW50LnNwbGljZShpbmRleCwgMSk7XG4gICAgICB9ICBcbiAgICB9XG4gIH1cbn0iLCAiaW1wb3J0IHsgQXBwLCBGdXp6eVN1Z2dlc3RNb2RhbCB9IGZyb20gXCJvYnNpZGlhblwiO1xuaW1wb3J0IHsgZ2V0QWxsVGFnc1dpdGhGaWx0ZXIgfSBmcm9tIFwic2VsZnV0aWwvZ2V0QWxsTm90ZVRhZ3NcIjtcblxuaW50ZXJmYWNlIFNlYXJjaCB7XG5cdG9wZW5HbG9iYWxTZWFyY2goXzogc3RyaW5nKTogdm9pZDtcblx0Z2V0R2xvYmFsU2VhcmNoUXVlcnkoKTogc3RyaW5nO1xufVxuXG5leHBvcnQgY2xhc3MgVGFnU2VhcmNoTW9kYWwgZXh0ZW5kcyBGdXp6eVN1Z2dlc3RNb2RhbDxzdHJpbmc+IHtcblx0Y29uc3RydWN0b3IocHVibGljIGFwcDogQXBwLCBwcml2YXRlIHNlYXJjaDogU2VhcmNoKSB7XG5cdFx0c3VwZXIoYXBwKTtcblx0XHR0aGlzLnNlYXJjaCA9IHNlYXJjaDtcblx0fVxuXG5cdGdldEl0ZW1zKCk6IHN0cmluZ1tdIHtcblx0XHRyZXR1cm4gZ2V0QWxsVGFnc1dpdGhGaWx0ZXIodGhpcy5hcHApO1xuXHR9XG5cblx0Z2V0SXRlbVRleHQoaXRlbTogc3RyaW5nKTogc3RyaW5nIHtcblx0XHRyZXR1cm4gaXRlbTtcblx0fVxuXG5cdG9uQ2hvb3NlSXRlbShpdGVtOiBzdHJpbmcsIGV2dDogTW91c2VFdmVudCB8IEtleWJvYXJkRXZlbnQpOiB2b2lkIHtcblx0XHRjb25zdCBkZWZhdWx0VGFnU2VhcmNoU3RyaW5nID0gYHRhZzoke2l0ZW19YDtcbiAgICAgICAgdGhpcy5zZWFyY2gub3Blbkdsb2JhbFNlYXJjaChkZWZhdWx0VGFnU2VhcmNoU3RyaW5nKTtcblx0fVxuXG59IiwgImltcG9ydCB7IEFwcCwgZ2V0QWxsVGFncyB9IGZyb20gXCJvYnNpZGlhblwiO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0QWxsTm90ZVRhZ3MoYXBwOiBBcHApIHtcbiAgICByZXR1cm4gZ2V0QWxsVGFnc1dpdGhGaWx0ZXIoYXBwLCAodGFnKSA9PiAvXiNbYS16XVxcL1thLXpdXFwvW2Etel0kLy50ZXN0KHRhZykpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRBbGxUYWdzV2l0aEZpbHRlcihhcHA6IEFwcCwgZmlsdGVyPzogKHRhZzogc3RyaW5nKSA9PiBib29sZWFuIHwgbnVsbCkge1xuICAgIGNvbnN0IGZpbGVzID0gYXBwLnZhdWx0LmdldE1hcmtkb3duRmlsZXMoKTtcbiAgICBjb25zdCBpdGVtczogc3RyaW5nW10gPSBbXTtcbiAgICBmb3IgKGNvbnN0IGZpbGUgb2YgZmlsZXMpIHtcbiAgICAgICAgY29uc3QgY2FjaGUgPSBhcHAubWV0YWRhdGFDYWNoZS5nZXRDYWNoZShmaWxlLnBhdGgpO1xuICAgICAgICBpZiAoY2FjaGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGdldEFsbFRhZ3MoY2FjaGUpPy5mb3JFYWNoKCh0YWcpID0+IHtcbiAgICAgICAgICAgIGlmIChmaWx0ZXIgPT0gbnVsbCB8fCBmaWx0ZXIodGFnKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxheWVyT2ZUYWc6IHN0cmluZ1tdID0gZ2V0TGF5ZXJzT2ZUYWcodGFnKVxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgbGF5ZXIgb2YgbGF5ZXJPZlRhZykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWl0ZW1zLmluY2x1ZGVzKGxheWVyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbXMucHVzaChsYXllcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gaXRlbXMuc29ydCgoYTogc3RyaW5nLCBiOiBzdHJpbmcpID0+IGEubG9jYWxlQ29tcGFyZShiKSk7XG59XG5cbmZ1bmN0aW9uIGdldExheWVyc09mVGFnKHRhZzogc3RyaW5nKTogc3RyaW5nW10ge1xuICAgIC8vIHByb3ZpZGUgYSB0YWcgd2l0aCAjenp6L2JiYi9jY2MsIHJldHVybiBbI3p6eiwgI3p6ei9iYmIsICN6enovYmJiL2NjY11cbiAgICAvLyBpZiB0YWcgd2l0aG91dCAvIChlLmcuICN6enopLCByZXR1cm4gWyN6enpdXG4gICAgY29uc3QgbGF5ZXJzOiBzdHJpbmdbXSA9IFtdXG4gICAgY29uc3QgdGFnU3BsaXQgPSB0YWcuc3BsaXQoXCIvXCIpXG4gICAgbGV0IHRhZ0xheWVyID0gdGFnU3BsaXRbMF1cbiAgICBsYXllcnMucHVzaCh0YWdMYXllcilcbiAgICBmb3IgKGNvbnN0IHRhZ1BhcnQgb2YgdGFnU3BsaXQuc2xpY2UoMSwgdGFnU3BsaXQubGVuZ3RoKSkge1xuICAgICAgICB0YWdMYXllciArPSBcIi9cIiArIHRhZ1BhcnRcbiAgICAgICAgbGF5ZXJzLnB1c2godGFnTGF5ZXIpXG4gICAgfVxuICAgIHJldHVybiBsYXllcnNcbn0iLCAiaW1wb3J0IHsgQWRkVGV4dFRvTm90ZXNNb2RhbCB9IGZyb20gXCJhZGRUZXh0VG9Ob3Rlc01vZGFsXCJcbmltcG9ydCB7IEFwcCwgRnV6enlTdWdnZXN0TW9kYWwsIEZ1enp5TWF0Y2ggfSBmcm9tIFwib2JzaWRpYW5cIlxuaW1wb3J0IHsgYWRkVGV4dFRvTm90ZXMgfSBmcm9tIFwic2VsZnV0aWwvYWRkbGlua3Rvbm90ZXNcIlxuaW1wb3J0IHsgZmlsZXNXaGVyZVRhZ0lzVXNlZCB9IGZyb20gXCJzZWxmdXRpbC9maW5kTm90ZXNGcm9tVGFnXCJcblxuY29uc3QgQkFDS19UT19TRUxFQ1RfVEFHID0gXCJCYWNrIHRvIHNlbGVjdCB0YWdcIlxuXG5leHBvcnQgY2xhc3MgQWRkVGV4dFRvTm90ZXNGcm9tU3BlY2lmaWNUYWdNb2RhbCBleHRlbmRzIEZ1enp5U3VnZ2VzdE1vZGFsPHN0cmluZz4ge1xuXG4gIGxpbmtUb0FkZDogc3RyaW5nXG5cbiAgdGFnVG9GaW5kOiBzdHJpbmdcblxuICBkZXNjcmlwdGlvbjogc3RyaW5nXG5cbiAgaW5zZXJ0RnJvbUJlZ2lubmluZzogYm9vbGVhblxuXG4gIHBvc3RBY3Rpb246ICgpID0+IHZvaWRcblxuICBjb25zdHJ1Y3RvcihhcHA6IEFwcCwgbGlua1RvQWRkOiBzdHJpbmcsIHRhZ1RvRmluZDogc3RyaW5nLCBkZXNjcmlwdGlvbjogc3RyaW5nLCBpbnNlcnRGcm9tQmVnaW5uaW5nOiBib29sZWFuLCBwb3N0QWN0aW9uOiAoKSA9PiB2b2lkKVxuICB7XG4gICAgc3VwZXIoYXBwKVxuICAgIHRoaXMubGlua1RvQWRkID0gbGlua1RvQWRkXG4gICAgdGhpcy50YWdUb0ZpbmQgPSB0YWdUb0ZpbmRcbiAgICB0aGlzLmluc2VydEZyb21CZWdpbm5pbmcgPSBpbnNlcnRGcm9tQmVnaW5uaW5nXG4gICAgdGhpcy5kZXNjcmlwdGlvbiA9IGRlc2NyaXB0aW9uXG4gICAgdGhpcy5wb3N0QWN0aW9uID0gcG9zdEFjdGlvblxuICAgIHRoaXMuc2V0UGxhY2Vob2xkZXIoYFdoaWNoIG5vdGVzIHdpdGggdGFnICR7dGFnVG9GaW5kfSBkbyB5b3Ugd2FudCB0byAke2Rlc2NyaXB0aW9ufSB0bz9gKVxuICAgIHRoaXMuc2V0SW5zdHJ1Y3Rpb25zKFtcbiAgICAgIHtcbiAgICAgICAgY29tbWFuZDogXCJcIixcbiAgICAgICAgcHVycG9zZTogYFdoaWNoIG5vdGVzIHdpdGggdGFnICR7dGFnVG9GaW5kfSBkbyB5b3Ugd2FudCB0byAke2Rlc2NyaXB0aW9ufSB0bz9gXG4gICAgICB9XG4gICAgXSk7XG4gIH1cblxuICBnZXRJdGVtcygpOiBzdHJpbmdbXSB7XG4gICAgcmV0dXJuIFsuLi5bQkFDS19UT19TRUxFQ1RfVEFHXSwgLi4uZmlsZXNXaGVyZVRhZ0lzVXNlZCh0aGlzLnRhZ1RvRmluZCldO1xuICB9XG5cbiAgZ2V0SXRlbVRleHQocGF0aDogc3RyaW5nKTogc3RyaW5nIHtcbiAgICByZXR1cm4gcGF0aDtcbiAgfVxuXG4gIC8vIFJlbmRlcnMgZWFjaCBzdWdnZXN0aW9uIGl0ZW0uXG4gIHJlbmRlclN1Z2dlc3Rpb24ocGF0aDogRnV6enlNYXRjaDxzdHJpbmc+LCBlbDogSFRNTEVsZW1lbnQpIHtcbiAgICBjb25zdCBwYXRoSXRlbTogc3RyaW5nID0gcGF0aC5pdGVtXG4gICAgZWwuY3JlYXRlRWwoXCJkaXZcIiwgeyB0ZXh0OiBwYXRoSXRlbSB9KTtcbiAgfVxuXG4gIC8vIFBlcmZvcm0gYWN0aW9uIG9uIHRoZSBzZWxlY3RlZCBzdWdnZXN0aW9uLlxuICBvbkNob29zZUl0ZW0ocGF0aDogc3RyaW5nLCBldnQ6IE1vdXNlRXZlbnQgfCBLZXlib2FyZEV2ZW50KSB7XG4gICAgaWYgKEJBQ0tfVE9fU0VMRUNUX1RBRyA9PSBwYXRoKSB7XG4gICAgICBuZXcgQWRkVGV4dFRvTm90ZXNNb2RhbCh0aGlzLmFwcCwgdGhpcy5saW5rVG9BZGQsIHRoaXMuZGVzY3JpcHRpb24sIHRoaXMuaW5zZXJ0RnJvbUJlZ2lubmluZywgdGhpcy5wb3N0QWN0aW9uKS5vcGVuKClcbiAgICB9IGVsc2Uge1xuICAgICAgYWRkVGV4dFRvTm90ZXModGhpcy5saW5rVG9BZGQsIHBhdGgsIHRoaXMuYXBwLCB0aGlzLmluc2VydEZyb21CZWdpbm5pbmcpXG4gICAgICB0aGlzLnBvc3RBY3Rpb24oKVxuICAgIH1cbiAgfVxufSIsICJpbXBvcnQgeyBBcHAsIEVkaXRvciwgTWFya2Rvd25WaWV3LCBOb3RpY2UsIFRGaWxlLCBUZXh0RmlsZVZpZXcsIFZhdWx0LCBXb3Jrc3BhY2UgfSBmcm9tIFwib2JzaWRpYW5cIlxuXG5leHBvcnQgZnVuY3Rpb24gYWRkVGV4dFRvTm90ZXModGV4dFRvQWRkOiBzdHJpbmcsIHRvUGF0aDogc3RyaW5nLCBhcHA6IEFwcCwgaW5zZXJ0RnJvbUJlZ2lubmluZzogYm9vbGVhbikge1xuICAgIGNvbnN0IHZhdWx0OiBWYXVsdCA9IHRoaXMuYXBwLnZhdWx0O1xuICAgIGNvbnN0IHdvcmtzcGFjZTogV29ya3NwYWNlID0gdGhpcy5hcHAud29ya3NwYWNlXG4gICAgY29uc3QgbGVhZiA9IHdvcmtzcGFjZS5nZXRMZWFmKGZhbHNlKTtcbiAgICBjb25zdCB0RmlsZTogVEZpbGUgPSB2YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgodG9QYXRoKSBhcyBURmlsZVxuICAgIGNvbnN0IGxpbmsgPSB0ZXh0VG9BZGRcbiAgICBQcm9taXNlLnJlc29sdmUoKVxuICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgcmV0dXJuIGxlYWYub3BlbkZpbGUodEZpbGUsIHsgYWN0aXZlOiB0cnVlIH0pO1xuICAgIH0pXG4gICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAvL2NvbnN0IGVkaXRvciA9IGFwcC53b3Jrc3BhY2UuZ2V0QWN0aXZlVmlld09mVHlwZShUZXh0RmlsZVZpZXcpO1xuICAgICAgICBjb25zdCBtYXJrZG93blZpZXcgPSBhcHAud29ya3NwYWNlLmdldEFjdGl2ZVZpZXdPZlR5cGUoTWFya2Rvd25WaWV3KTtcbiAgICAgICAgY29uc3QgZWRpdG9yID0gbWFya2Rvd25WaWV3Py5lZGl0b3JcbiAgICAgICAgY29uc3QgdmFsdWUgPSBtYXJrZG93blZpZXc/LmdldFZpZXdEYXRhKClcbiAgICAgICAgaWYgKG1hcmtkb3duVmlldyA9PSBudWxsIHx8IGVkaXRvciA9PSBudWxsIHx8IHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yUmVhc29uID0gYGVkaXRvciBvciB2YWx1ZSAke3RvUGF0aH0gbm90IGV4aXN0LiBBYm9ydGluZy4uLmBcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvclJlYXNvbilcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYgKHZhbHVlLmluY2x1ZGVzKGxpbmspKSB7XG4gICAgICAgICAgICBjb25zdCBlcnJvclJlYXNvbiA9IGBMaW5rICR7bGlua30gYWxyZWFkeSBleGlzdHMgaW4gJHt0b1BhdGh9IWBcbiAgICAgICAgICAgIG5ldyBOb3RpY2UoZXJyb3JSZWFzb24pXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBuZXdWYWx1ZSA9IGluc2VydEZyb21CZWdpbm5pbmcgPyBcbiAgICAgICAgICAgIGdldE5vdGVWYWx1ZUluc2VydGluZ1RleHRGcm9tU3RhcnRPZk5vdGVzKHZhbHVlLCBsaW5rKSA6IFxuICAgICAgICAgICAgZ2V0Tm90ZVZhbHVlSW5zZXJ0aW5nVGV4dEZyb21FbmRPZk5vdGVzKHZhbHVlLCBsaW5rKVxuICAgICAgICAgICAgbWFya2Rvd25WaWV3LnNldFZpZXdEYXRhKG5ld1ZhbHVlLCBmYWxzZSlcbiAgICAgICAgICAgIGlmIChpbnNlcnRGcm9tQmVnaW5uaW5nKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZnJvbnRNYXR0ZXJSZWdleCA9IC9eKC0tLVxcbltcXHNcXFNdKj9cXG4tLS1cXG4pL2dtXG4gICAgICAgICAgICAgICAgaWYgKGZyb250TWF0dGVyUmVnZXgudGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZWRpdG9yLnNldEN1cnNvcih7IGxpbmU6IGdldExpbmVBZnRlckZyb250TWF0dGVyKHZhbHVlKSwgY2g6IDAgfSkgXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZWRpdG9yLnNldEN1cnNvcih7IGxpbmU6IDAsIGNoOiAwIH0pXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBlZGl0b3Iuc2V0Q3Vyc29yKHsgbGluZTogZWRpdG9yLmxpbmVDb3VudCgpIC0gMSwgY2g6IDAgfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5ldyBOb3RpY2UoYEFkZGVkIGxpbmsgdG8gJHtpbnNlcnRGcm9tQmVnaW5uaW5nID8gXCJiZWdpbm5pbmdcIiA6IFwiZW5kXCJ9IG9mICR7dG9QYXRofSFgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKClcbiAgICB9KVxuICAgIC5jYXRjaCgocmVhc29uKSA9PiB7IFxuICAgICAgICBuZXcgTm90aWNlKHJlYXNvbilcbiAgICB9KVxuICAgIC8qIHRoaXMgdmVyc2lvbiBjYW5ub3QgcmVkbywgY2FuIHJlbW92ZSBpZiBhYm92ZVxuICAgIFByb21pc2UucmVzb2x2ZSgpXG4gICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB2YXVsdC5yZWFkKHRGaWxlKVxuICAgICAgICB9LCByZWFzb24gPT4geyBuZXcgTm90aWNlKFwiRXJyb3Igb2NjdXJyZWQgd2hlbiByZWFkaW5nIFwiICsgdG9QYXRoKSB9KVxuICAgICAgICAudGhlbigodmFsdWUpID0+IHtcbiAgICAgICAgICAgIGlmICh2YWx1ZS5pbmNsdWRlcyhsaW5rKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yUmVhc29uID0gYExpbmsgJHtsaW5rVG9BZGR9IGFscmVhZHkgZXhpc3RzIGluICR7dG9QYXRofSFgXG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yUmVhc29uKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbmV3VmFsdWUgPSBpbnNlcnRGcm9tQmVnaW5uaW5nID8gXG4gICAgICAgICAgICAgICAgZ2V0Tm90ZVZhbHVlSW5zZXJ0aW5nTm90ZUxpbmtGcm9tU3RhcnRPZk5vdGVzKHZhbHVlLCBsaW5rKSA6IFxuICAgICAgICAgICAgICAgIGdldE5vdGVWYWx1ZUluc2VydGluZ05vdGVMaW5rRnJvbUVuZE9mTm90ZXModmFsdWUsIGxpbmspXG4gICAgICAgICAgICByZXR1cm4gdmF1bHQubW9kaWZ5KHRGaWxlLCBuZXdWYWx1ZSlcbiAgICAgICAgfSlcbiAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgbmV3IE5vdGljZShgQWRkZWQgbGluayB0byAke2luc2VydEZyb21CZWdpbm5pbmcgPyBcImJlZ2lubmluZ1wiIDogXCJlbmRcIn0gb2YgJHt0b1BhdGh9IWApO1xuICAgICAgICAgICAgY29uc3QgbGVhZiA9IHdvcmtzcGFjZS5nZXRMZWFmKGZhbHNlKTtcbiAgICAgICAgICAgIHJldHVybiBsZWFmLm9wZW5GaWxlKHRGaWxlLCB7IGFjdGl2ZTogdHJ1ZSB9KTtcbiAgICAgICAgfSwgKHJlYXNvbikgPT4geyBcbiAgICAgICAgICAgIG5ldyBOb3RpY2UocmVhc29uKSBcbiAgICAgICAgICAgIGNvbnN0IGxlYWYgPSB3b3Jrc3BhY2UuZ2V0TGVhZihmYWxzZSk7XG4gICAgICAgICAgICByZXR1cm4gbGVhZi5vcGVuRmlsZSh0RmlsZSwgeyBhY3RpdmU6IHRydWUgfSk7XG4gICAgICAgIH0pXG4gICAgICAgICovXG59XG5cbmZ1bmN0aW9uIGdldExpbmVBZnRlckZyb250TWF0dGVyKHZhbHVlOiBzdHJpbmcpIHtcbiAgICBjb25zdCB2YWx1ZXMgPSB2YWx1ZS5zcGxpdChcIlxcblwiKVxuICAgIGxldCBmbUNvdW50ID0gMFxuICAgIGNvbnN0IGxpbmVOdW0gPSB2YWx1ZXMubGVuZ3RoXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lTnVtOyBpKyspIHtcbiAgICAgICAgaWYgKHZhbHVlc1tpXSA9PT0gXCItLS1cIikge1xuICAgICAgICAgICAgZm1Db3VudCsrXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZtQ291bnQgPT0gMikge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGgubWluKGkgKyAxLCBsaW5lTnVtIC0gMSlcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbGluZU51bSAtIDFcbn1cblxuZnVuY3Rpb24gZ2V0Tm90ZVZhbHVlSW5zZXJ0aW5nVGV4dEZyb21TdGFydE9mTm90ZXModmFsdWU6IHN0cmluZywgdGV4dDogc3RyaW5nKSB7XG4gICAgY29uc3QgZnJvbnRNYXR0ZXJSZWdleCA9IC9eKC0tLVxcbltcXHNcXFNdKj9cXG4tLS1cXG4pL2dtXG4gICAgLy8gL14tLS1cXG4oLiopKlxcbi0tLVxcbi9cbiAgICBpZiAoZnJvbnRNYXR0ZXJSZWdleC50ZXN0KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdmFsdWUucmVwbGFjZShmcm9udE1hdHRlclJlZ2V4LCBcIiQxXCIgKyB0ZXh0ICsgXCJcXG5cIilcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGV4dCArIFwiXFxuXCIgKyB2YWx1ZVxuICAgIH1cbn1cblxuZnVuY3Rpb24gZ2V0Tm90ZVZhbHVlSW5zZXJ0aW5nVGV4dEZyb21FbmRPZk5vdGVzKHZhbHVlOiBzdHJpbmcsIHRleHQ6IHN0cmluZykge1xuICAgIHJldHVybiB2YWx1ZSArIFwiXFxuXCIgKyB0ZXh0XG59IiwgImltcG9ydCB7IEFwcCwgQ2FjaGVkTWV0YWRhdGEsIHBhcnNlRnJvbnRNYXR0ZXJBbGlhc2VzLCBwYXJzZUZyb250TWF0dGVyVGFncyB9IGZyb20gXCJvYnNpZGlhblwiO1xuXG5leHBvcnQgZnVuY3Rpb24gZmlsZXNXaGVyZVRhZ0lzVXNlZChmaW5kVGFnOiBzdHJpbmcpOiBzdHJpbmdbXSB7XG4gICAgY29uc3QgZmlsZXNMaXN0OiBzdHJpbmdbXSA9IFtdO1xuICAgIGZvciAoY29uc3QgZmlsZVBhdGggb2YgbG9jYXRpb25zV2hlcmVUYWdJc1VzZWQoZmluZFRhZykpIHtcbiAgICAgICAgaWYgKCFmaWxlc0xpc3QuaW5jbHVkZXMoZmlsZVBhdGgpKSB7XG4gICAgICAgICAgICBmaWxlc0xpc3QucHVzaChmaWxlUGF0aClcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmlsZXNMaXN0LnNvcnQoKGE6IHN0cmluZywgYjogc3RyaW5nKSA9PiBhLmxvY2FsZUNvbXBhcmUoYikpO1xufVxuXG4vLyByZXR1cm4gYXJyYXkgb2YgZmlsZSBwYXRoXG5mdW5jdGlvbiBsb2NhdGlvbnNXaGVyZVRhZ0lzVXNlZChmaW5kVGFnOiBzdHJpbmcpOiBBcnJheTxzdHJpbmc+IHtcbiAgICBjb25zdCBvQXBwOiBBcHAgPSBhcHA7XG4gICAgY29uc3QgcmVzdWx0czogc3RyaW5nW10gPSBbXTtcblxuICAgIGZvciAoY29uc3QgZmlsZSBvZiBvQXBwLnZhdWx0LmdldE1hcmtkb3duRmlsZXMoKSkge1xuICAgICAgICBjb25zdCBjYWNoZTogQ2FjaGVkTWV0YWRhdGEgfCBudWxsID0gb0FwcC5tZXRhZGF0YUNhY2hlLmdldEZpbGVDYWNoZShmaWxlKTtcbiAgICAgICAgaWYgKGNhY2hlICE9IG51bGwgJiYgY2FjaGUudGFncykge1xuICAgICAgICAgICAgZm9yIChjb25zdCB0YWcgb2YgY2FjaGUudGFncykge1xuICAgICAgICAgICAgICAgIGlmIChmaW5kVGFnID09PSB0YWcudGFnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChmaWxlLnBhdGgpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjYWNoZSAhPSBudWxsICYmIGNhY2hlLmZyb250bWF0dGVyKSB7XG4gICAgICAgICAgICBjb25zdCBmbXRhZ3MgPSAocGFyc2VGcm9udE1hdHRlclRhZ3MoY2FjaGUuZnJvbnRtYXR0ZXIpIHx8IFtdKS5maWx0ZXIodGFnID0+IGZpbmRUYWcgPT0gdGFnIHx8IHRhZy5zdGFydHNXaXRoKGZpbmRUYWcgKyBcIi9cIikpO1xuICAgICAgICAgICAgaWYgKGZtdGFncy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goZmlsZS5wYXRoKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZm10YWdzMiA9IChwYXJzZUZyb250TWF0dGVyQWxpYXNlcyhjYWNoZS5mcm9udG1hdHRlcikgfHwgW10pLmZpbHRlcih0YWcgPT4gZmluZFRhZyA9PSB0YWcgfHwgdGFnLnN0YXJ0c1dpdGgoZmluZFRhZyArIFwiL1wiKSk7XG4gICAgICAgICAgICBpZiAoZm10YWdzMi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goZmlsZS5wYXRoKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRzXG59IiwgImltcG9ydCB7IEFkZFRleHRUb05vdGVzRnJvbVNwZWNpZmljVGFnTW9kYWwgfSBmcm9tIFwiYWRkVGV4dFRvTm90ZXNGcm9tU3BlY2lmaWNUYWdNb2RhbFwiO1xuaW1wb3J0IHsgQXBwLCBGdXp6eVN1Z2dlc3RNb2RhbCwgRnV6enlNYXRjaCwgZ2V0QWxsVGFncyB9IGZyb20gXCJvYnNpZGlhblwiO1xuaW1wb3J0IHsgYWRkVGV4dFRvTm90ZXMgfSBmcm9tIFwic2VsZnV0aWwvYWRkbGlua3Rvbm90ZXNcIjtcbmltcG9ydCB7IGdldEFsbE5vdGVUYWdzIH0gZnJvbSBcInNlbGZ1dGlsL2dldEFsbE5vdGVUYWdzXCI7XG5pbXBvcnQgeyBnZXRBbGxOb3RlcywgZ2V0UmVjZW50Tm90ZXMgfSBmcm9tIFwic2VsZnV0aWwvZ2V0UmVjZW50Tm90ZXNcIjtcblxuZXhwb3J0IGNsYXNzIEFkZFRleHRUb05vdGVzTW9kYWwgZXh0ZW5kcyBGdXp6eVN1Z2dlc3RNb2RhbDxzdHJpbmc+IHtcblxuICBsaW5rVG9BZGQ6IHN0cmluZ1xuICB0YXNrVHlwZTogU3RyaW5nXG4gIGRlc2NyaXB0aW9uOiBzdHJpbmdcbiAgaW5zZXJ0RnJvbUJlZ2lubmluZzogYm9vbGVhblxuICBwb3N0QWN0aW9uOiAoKSA9PiB2b2lkXG5cbiAgY29uc3RydWN0b3IoYXBwOiBBcHAsIGxpbmtUb0FkZDogc3RyaW5nLCBkZXNjcmlwdGlvbjogc3RyaW5nLCBpbnNlcnRGcm9tQmVnaW5uaW5nOiBib29sZWFuLCBwb3N0QWN0aW9uOiAoKSA9PiB2b2lkKVxuICB7XG4gICAgc3VwZXIoYXBwKVxuICAgIHRoaXMubGlua1RvQWRkID0gbGlua1RvQWRkXG4gICAgdGhpcy5kZXNjcmlwdGlvbiA9IGRlc2NyaXB0aW9uXG4gICAgdGhpcy5pbnNlcnRGcm9tQmVnaW5uaW5nID0gaW5zZXJ0RnJvbUJlZ2lubmluZ1xuICAgIHRoaXMucG9zdEFjdGlvbiA9IHBvc3RBY3Rpb25cbiAgICB0aGlzLnNldFBsYWNlaG9sZGVyKGBXaGljaCBub3RlcyB3aXRoIHRhZ3MgZG8geW91IHdhbnQgdG8gJHtkZXNjcmlwdGlvbn0gdG8/YClcbiAgICB0aGlzLnNldEluc3RydWN0aW9ucyhbXG4gICAgICB7XG4gICAgICAgIGNvbW1hbmQ6IFwiXCIsXG4gICAgICAgIHB1cnBvc2U6IGBXaGljaCBub3RlcyB3aXRoIHRhZ3MgZG8geW91IHdhbnQgdG8gJHtkZXNjcmlwdGlvbn0gdG8/YFxuICAgICAgfVxuICAgIF0pO1xuICB9XG5cbiAgZ2V0SXRlbXMoKSA6IHN0cmluZ1tdIHtcblx0XHRjb25zdCBsID0gWy4uLlsnSS9JbmJveC5tZCddLCAuLi5nZXRSZWNlbnROb3Rlcyh0aGlzLmFwcCwgNyksIC4uLmdldEFsbE5vdGVUYWdzKHRoaXMuYXBwKS5tYXAocyA9PiBzLnJlcGxhY2UoL14jLywgXCJAXCIpKSwgLi4uZ2V0QWxsTm90ZXModGhpcy5hcHApXTtcbiAgICAvLyByZW1vdmUgZHVwbGljYXRlIGZvciBsXG4gICAgcmV0dXJuIGwuZmlsdGVyKChpdGVtLCBpbmRleCkgPT4gbC5pbmRleE9mKGl0ZW0pID09PSBpbmRleCk7XG4gIH1cblxuICBnZXRJdGVtVGV4dCh2YWx1ZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICAvLyBSZW5kZXJzIGVhY2ggc3VnZ2VzdGlvbiBpdGVtLlxuICByZW5kZXJTdWdnZXN0aW9uKHZhbHVlOiBGdXp6eU1hdGNoPHN0cmluZz4sIGVsOiBIVE1MRWxlbWVudCkge1xuICAgIGNvbnN0IGl0ZW0gPSB2YWx1ZS5pdGVtXG4gICAgZWwuY3JlYXRlRWwoXCJkaXZcIiwgeyB0ZXh0OiBpdGVtIH0pXG4gIH1cblxuICAvLyBQZXJmb3JtIGFjdGlvbiBvbiB0aGUgc2VsZWN0ZWQgc3VnZ2VzdGlvbi5cbiAgYXN5bmMgb25DaG9vc2VJdGVtKGNob29zZW5WYWx1ZTogc3RyaW5nLCBldnQ6IE1vdXNlRXZlbnQgfCBLZXlib2FyZEV2ZW50KSB7XG4gICAgaWYgKGNob29zZW5WYWx1ZS5zdGFydHNXaXRoKFwiQFwiKSkge1xuICAgICAgbmV3IEFkZFRleHRUb05vdGVzRnJvbVNwZWNpZmljVGFnTW9kYWwodGhpcy5hcHAsIHRoaXMubGlua1RvQWRkLCBjaG9vc2VuVmFsdWUucmVwbGFjZSgvXkAvLCBcIiNcIiksIHRoaXMuZGVzY3JpcHRpb24sIHRoaXMuaW5zZXJ0RnJvbUJlZ2lubmluZywgdGhpcy5wb3N0QWN0aW9uKS5vcGVuKClcbiAgICB9IGVsc2Uge1xuICAgICAgYWRkVGV4dFRvTm90ZXModGhpcy5saW5rVG9BZGQsIGNob29zZW5WYWx1ZSwgdGhpcy5hcHAsIHRoaXMuaW5zZXJ0RnJvbUJlZ2lubmluZylcbiAgICAgIHRoaXMucG9zdEFjdGlvbigpXG4gICAgfVxuICB9XG59IiwgImltcG9ydCB7IEFwcCB9IGZyb20gXCJvYnNpZGlhblwiO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0UmVjZW50Tm90ZXMoYXBwOiBBcHAsIGxpbWl0OiBudW1iZXIpOiBzdHJpbmdbXSB7XG4gIGNvbnN0IHJlY2VudFZpZXdlZE5vdGVzID0gYXBwLndvcmtzcGFjZS5nZXRMYXN0T3BlbkZpbGVzKCk7XG4gIHJldHVybiByZWNlbnRWaWV3ZWROb3Rlcy5zbGljZSgwLCBNYXRoLm1pbihsaW1pdCwgcmVjZW50Vmlld2VkTm90ZXMubGVuZ3RoKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRBbGxOb3RlcyhhcHA6IEFwcCk6IHN0cmluZ1tdIHtcbiAgY29uc3QgZmlsZXMgPSBhcHAudmF1bHQuZ2V0TWFya2Rvd25GaWxlcygpO1xuICBjb25zdCBhbGxOb3RlcyA9IGZpbGVzLm1hcCgoZmlsZSkgPT4gZmlsZS5wYXRoKTtcbiAgcmV0dXJuIGFsbE5vdGVzO1xufVxuXG4iLCAiaW1wb3J0IHsgTmF2aWdhdGVUb05vdGVGcm9tVGFnTW9kYWwgfSBmcm9tIFwibmF2aWdhdGVUb05vdGVGcm9tVGFnTW9kYWxcIlxuaW1wb3J0IHsgQXBwLCBGdXp6eVN1Z2dlc3RNb2RhbCwgRnV6enlNYXRjaCwgTm90aWNlLCBDYWNoZWRNZXRhZGF0YSwgcGFyc2VGcm9udE1hdHRlclRhZ3MsIHBhcnNlRnJvbnRNYXR0ZXJBbGlhc2VzLCBURmlsZSB9IGZyb20gXCJvYnNpZGlhblwiXG5pbXBvcnQgeyBmaWxlc1doZXJlVGFnSXNVc2VkIH0gZnJvbSBcInNlbGZ1dGlsL2ZpbmROb3Rlc0Zyb21UYWdcIlxuXG5jb25zdCBCQUNLX1RPX1NFTEVDVF9UQUcgPSBcIkJhY2sgdG8gc2VsZWN0IHRhZ1wiXG5cbmV4cG9ydCBjbGFzcyBOYXZpZ2F0ZVRvTm90ZUZyb21TcGVjaWZpY1RhZ01vZGFsIGV4dGVuZHMgRnV6enlTdWdnZXN0TW9kYWw8c3RyaW5nPiB7XG5cbiAgdGFnVG9GaW5kOiBzdHJpbmdcblxuICBjb25zdHJ1Y3RvcihhcHA6IEFwcCwgdGFnVG9GaW5kOiBzdHJpbmcpXG4gIHtcbiAgICBzdXBlcihhcHApXG4gICAgdGhpcy50YWdUb0ZpbmQgPSB0YWdUb0ZpbmRcbiAgICB0aGlzLnNldFBsYWNlaG9sZGVyKGBXaGljaCBub3RlcyB3aXRoIHRhZyAke3RhZ1RvRmluZH0gZG8geW91IHdhbnQgdG8gbmF2aWdhdGUgdG8/YClcbiAgICB0aGlzLnNldEluc3RydWN0aW9ucyhbXG4gICAgICB7XG4gICAgICAgIGNvbW1hbmQ6IFwiXCIsXG4gICAgICAgIHB1cnBvc2U6IGBXaGljaCBub3RlcyB3aXRoIHRhZyAke3RhZ1RvRmluZH0gZG8geW91IHdhbnQgdG8gbmF2aWdhdGUgdG8/YFxuICAgICAgfVxuICAgIF0pO1xuICB9XG5cblxuICBnZXRJdGVtcygpOiBzdHJpbmdbXSB7XG4gICAgcmV0dXJuIFsuLi5bQkFDS19UT19TRUxFQ1RfVEFHXSwgLi4uZmlsZXNXaGVyZVRhZ0lzVXNlZCh0aGlzLnRhZ1RvRmluZCldO1xuICB9XG5cbiAgZ2V0SXRlbVRleHQocGF0aDogc3RyaW5nKTogc3RyaW5nIHtcbiAgICByZXR1cm4gcGF0aDtcbiAgfVxuXG4gIC8vIFJlbmRlcnMgZWFjaCBzdWdnZXN0aW9uIGl0ZW0uXG4gIHJlbmRlclN1Z2dlc3Rpb24ocGF0aDogRnV6enlNYXRjaDxzdHJpbmc+LCBlbDogSFRNTEVsZW1lbnQpIHtcbiAgICBjb25zdCBwYXRoSXRlbTogc3RyaW5nID0gcGF0aC5pdGVtXG4gICAgZWwuY3JlYXRlRWwoXCJkaXZcIiwgeyB0ZXh0OiBwYXRoSXRlbSB9KTtcbiAgfVxuXG4gIC8vIFBlcmZvcm0gYWN0aW9uIG9uIHRoZSBzZWxlY3RlZCBzdWdnZXN0aW9uLlxuICBvbkNob29zZUl0ZW0ocGF0aDogc3RyaW5nLCBldnQ6IE1vdXNlRXZlbnQgfCBLZXlib2FyZEV2ZW50KSB7XG4gICAgaWYgKEJBQ0tfVE9fU0VMRUNUX1RBRyA9PSBwYXRoKSB7XG4gICAgICBuZXcgTmF2aWdhdGVUb05vdGVGcm9tVGFnTW9kYWwodGhpcy5hcHApLm9wZW4oKVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB7IHZhdWx0LCB3b3Jrc3BhY2UgfSA9IHRoaXMuYXBwO1xuICAgICAgY29uc3QgbGVhZiA9IHdvcmtzcGFjZS5nZXRMZWFmKGZhbHNlKTtcbiAgICAgIFByb21pc2UucmVzb2x2ZSgpXG4gICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIGxlYWYub3BlbkZpbGUodmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKHBhdGgpIGFzIFRGaWxlLCB7IGFjdGl2ZSA6IHRydWUgfSk7XG4gICAgICB9KVxuICB9XG4gIH1cbn0iLCAiaW1wb3J0IHsgTmF2aWdhdGVUb05vdGVGcm9tU3BlY2lmaWNUYWdNb2RhbCB9IGZyb20gXCJuYXZpZ2F0ZVRvTm90ZUZyb21TcGVjaWZpY1RhZ01vZGFsXCI7XG5pbXBvcnQgeyBBcHAsIEZ1enp5U3VnZ2VzdE1vZGFsLCBGdXp6eU1hdGNoLCBnZXRBbGxUYWdzLCBURmlsZSwgTm90aWNlLCBNYXJrZG93blZpZXcgfSBmcm9tIFwib2JzaWRpYW5cIjtcbmltcG9ydCB7IGdldEFsbFRhZ3NXaXRoRmlsdGVyIH0gZnJvbSBcInNlbGZ1dGlsL2dldEFsbE5vdGVUYWdzXCI7XG5pbXBvcnQgeyBnZXRBbGxOb3RlcywgZ2V0UmVjZW50Tm90ZXMgfSBmcm9tIFwic2VsZnV0aWwvZ2V0UmVjZW50Tm90ZXNcIjtcblxuaW50ZXJmYWNlIE5vdGUge1xuICBzZWFyY2g6IHN0cmluZyxcbiAgc2Vjb25kYXJ5OiBzdHJpbmdcbiAgdHlwZTogc3RyaW5nXG59XG5cbmludGVyZmFjZSBIZWFkaW5nIHtcbiAgbm90ZTogc3RyaW5nLFxuICBoZWFkaW5nOiBzdHJpbmcsXG4gIGxldmVsOiBudW1iZXJcbn1cblxuY29uc3Qgbm90ZSA9IFwibm90ZVwiXG5jb25zdCB0YWcgPSBcInRhZ1wiXG5jb25zdCBoZWFkaW5nID0gXCJoZWFkaW5nXCJcblxuZXhwb3J0IGNsYXNzIE5hdmlnYXRlVG9Ob3RlRnJvbVRhZ01vZGFsIGV4dGVuZHMgRnV6enlTdWdnZXN0TW9kYWw8Tm90ZT4ge1xuXG4gIHRhc2tUeXBlOiBOb3RlXG5cbiAgY29uc3RydWN0b3IoYXBwOiBBcHApXG4gIHtcbiAgICBzdXBlcihhcHApXG4gICAgdGhpcy5zZXRQbGFjZWhvbGRlcihgV2hpY2ggbm90ZXMgd2l0aCB0YWdzIGRvIHlvdSB3YW50IHRvIG5hdmlnYXRlIHRvP2ApXG4gICAgdGhpcy5zZXRJbnN0cnVjdGlvbnMoW1xuICAgICAge1xuICAgICAgICBjb21tYW5kOiBcIlwiLFxuICAgICAgICBwdXJwb3NlOiBcIldoaWNoIG5vdGVzIHdpdGggdGFncyBkbyB5b3Ugd2FudCB0byBuYXZpZ2F0ZSB0bz9cIlxuICAgICAgfVxuICAgIF0pO1xuICB9XG5cbiAgZ2V0SXRlbXMoKSA6IE5vdGVbXSB7XG4gICAgY29uc3QgYWxsTm90ZXMgPSBnZXRBbGxOb3Rlcyh0aGlzLmFwcClcbiAgICBsZXQgaGVhZGluZ3M6IEhlYWRpbmdbXSA9IFtdXG4gICAgYWxsTm90ZXMuZm9yRWFjaChuID0+IHtcbiAgICAgIGNvbnN0IGZpbGUgPSB0aGlzLmFwcC52YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgobikgYXMgVEZpbGVcbiAgICAgIGNvbnN0IGZpbGVDYWNoZSA9IHRoaXMuYXBwLm1ldGFkYXRhQ2FjaGUuZ2V0RmlsZUNhY2hlKGZpbGUpXG4gICAgICBpZiAoIWZpbGVDYWNoZSkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIGlmICghZmlsZUNhY2hlLmhlYWRpbmdzKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgZmlsZUNhY2hlLmhlYWRpbmdzLmZvckVhY2goaCA9PiB7XG4gICAgICAgIGhlYWRpbmdzLnB1c2goe25vdGU6IG4sIGhlYWRpbmc6IGguaGVhZGluZywgbGV2ZWw6IGgubGV2ZWx9KVxuICAgICAgfSlcbiAgICB9KVxuXHRcdHJldHVybiBbXG4gICAgICAuLi5nZXRSZWNlbnROb3Rlcyh0aGlzLmFwcCwgNykubWFwKG4gPT4ge1xuICAgICAgICByZXR1cm4ge3NlYXJjaDogbiwgc2Vjb25kYXJ5OiBcIlwiLCB0eXBlOiBub3RlfVxuICAgICAgfSksXG4gICAgICAuLi5nZXRBbGxUYWdzV2l0aEZpbHRlcih0aGlzLmFwcCkubWFwKG4gPT4ge1xuICAgICAgICByZXR1cm4ge3NlYXJjaDogbi5yZXBsYWNlKC9eIy8sIFwiQFwiKSwgc2Vjb25kYXJ5OiBcIlwiLCB0eXBlOiB0YWd9XG4gICAgICB9KSxcbiAgICAgIC4uLmFsbE5vdGVzLm1hcChuID0+IHtcbiAgICAgICAgcmV0dXJuIHtzZWFyY2g6IG4sIHNlY29uZGFyeTogXCJcIiwgdHlwZTogbm90ZX1cbiAgICAgIH0pLFxuICAgICAgLi4uaGVhZGluZ3MubWFwKGggPT4ge1xuICAgICAgICByZXR1cm4ge3NlYXJjaDogJyMnLnJlcGVhdChoLmxldmVsKSArIFwiIFwiICsgaC5oZWFkaW5nLCBzZWNvbmRhcnk6IGgubm90ZSwgdHlwZTogaGVhZGluZ31cbiAgICAgIH0pXG4gICAgXTtcbiAgfVxuXG4gIGdldEl0ZW1UZXh0KHZhbHVlOiBOb3RlKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdmFsdWUuc2VhcmNoO1xuICB9XG5cbiAgLy8gUmVuZGVycyBlYWNoIHN1Z2dlc3Rpb24gaXRlbS5cbiAgcmVuZGVyU3VnZ2VzdGlvbih2YWx1ZTogRnV6enlNYXRjaDxOb3RlPiwgZWw6IEhUTUxFbGVtZW50KSB7XG4gICAgY29uc3QgaXRlbSA9IHZhbHVlLml0ZW1cbiAgICBlbC5jcmVhdGVFbChcImRpdlwiLCB7IHRleHQ6IGl0ZW0uc2VhcmNoIH0pO1xuICAgIGVsLmNyZWF0ZUVsKFwic21hbGxcIiwgeyB0ZXh0OiBpdGVtLnR5cGUgKyBcIiBcIiArIGl0ZW0uc2Vjb25kYXJ5IH0pO1xuICB9XG5cbiAgLy8gUGVyZm9ybSBhY3Rpb24gb24gdGhlIHNlbGVjdGVkIHN1Z2dlc3Rpb24uXG4gIGFzeW5jIG9uQ2hvb3NlSXRlbShjaG9vc2VuVmFsdWU6IE5vdGUsIGV2dDogTW91c2VFdmVudCB8IEtleWJvYXJkRXZlbnQpIHtcbiAgICBpZiAoY2hvb3NlblZhbHVlLnR5cGUgPT0gdGFnKSB7XG4gICAgICBuZXcgTmF2aWdhdGVUb05vdGVGcm9tU3BlY2lmaWNUYWdNb2RhbCh0aGlzLmFwcCwgY2hvb3NlblZhbHVlLnNlYXJjaC5yZXBsYWNlKFwiQFwiLCBcIiNcIikpLm9wZW4oKVxuICAgIH0gZWxzZSBpZiAoY2hvb3NlblZhbHVlLnR5cGUgPT0gbm90ZSkge1xuICAgICAgY29uc3QgeyB2YXVsdCwgd29ya3NwYWNlIH0gPSB0aGlzLmFwcDtcbiAgICAgIGNvbnN0IGxlYWYgPSB3b3Jrc3BhY2UuZ2V0TGVhZihmYWxzZSk7XG4gICAgICBQcm9taXNlLnJlc29sdmUoKVxuICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgIHJldHVybiBsZWFmLm9wZW5GaWxlKHZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aChjaG9vc2VuVmFsdWUuc2VhcmNoKSBhcyBURmlsZSwgeyBhY3RpdmUgOiB0cnVlIH0pO1xuICAgICAgfSlcbiAgICB9IGVsc2UgaWYgKGNob29zZW5WYWx1ZS50eXBlID09IGhlYWRpbmcpIHtcbiAgICAgIGNvbnN0IHsgdmF1bHQsIHdvcmtzcGFjZSB9ID0gdGhpcy5hcHA7XG4gICAgICBjb25zdCBsZWFmID0gd29ya3NwYWNlLmdldExlYWYoZmFsc2UpO1xuICAgICAgUHJvbWlzZS5yZXNvbHZlKClcbiAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICByZXR1cm4gbGVhZi5vcGVuRmlsZSh2YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgoY2hvb3NlblZhbHVlLnNlY29uZGFyeSkgYXMgVEZpbGUsIHsgYWN0aXZlIDogdHJ1ZSB9KTtcbiAgICAgIH0pXG4gICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgIGNvbnN0IG1hcmtkb3duVmlldyA9IGFwcC53b3Jrc3BhY2UuZ2V0QWN0aXZlVmlld09mVHlwZShNYXJrZG93blZpZXcpO1xuICAgICAgICBjb25zdCBlZGl0b3IgPSBtYXJrZG93blZpZXc/LmVkaXRvclxuICAgICAgICBpZiAobWFya2Rvd25WaWV3ID09IG51bGwgfHwgZWRpdG9yID09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yUmVhc29uID0gYGVkaXRvciBvciB2YWx1ZSAke2Nob29zZW5WYWx1ZS5zZWNvbmRhcnl9IG5vdCBleGlzdC4gQWJvcnRpbmcuLi5gXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3JSZWFzb24pXG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdG90YWxMaW5lTnVtID0gZWRpdG9yLmxpbmVDb3VudCgpXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdG90YWxMaW5lTnVtOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBsaW5lID0gZWRpdG9yLmdldExpbmUoaSlcbiAgICAgICAgICBpZiAobGluZSA9PSBjaG9vc2VuVmFsdWUuc2VhcmNoKSB7XG4gICAgICAgICAgICBlZGl0b3Iuc2V0Q3Vyc29yKHtsaW5lOiBpLCBjaDogMH0pXG4gICAgICAgICAgICAvLyBzY3JvbGwgdGhlIHZpZXcgdG8gdGhlIGN1cnNvclxuICAgICAgICAgICAgZWRpdG9yLnNjcm9sbEludG9WaWV3KHtmcm9tOiB7bGluZTogaSwgY2g6IDB9LCB0bzoge2xpbmU6IGksIGNoOiAwfX0sIHRydWUpXG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICB9XG59IiwgImltcG9ydCB7IEVkaXRvciwgRWRpdG9yU2VsZWN0aW9uIH0gZnJvbSBcIm9ic2lkaWFuXCJcblxuZXhwb3J0IGZ1bmN0aW9uIGV4cG9ydEN1cnJlbnRTZWxlY3Rpb24oZWRpdG9yOiBFZGl0b3IpOiBzdHJpbmcge1xuICAgIGxldCB0ZXh0ID0gXCJcIlxuICAgIGNvbnN0IGxpc3RTZWxlY3Rpb25zOiBFZGl0b3JTZWxlY3Rpb25bXSA9IGVkaXRvci5saXN0U2VsZWN0aW9ucygpXG4gICAgbGlzdFNlbGVjdGlvbnMuZm9yRWFjaChsaXN0U2VsZWN0aW9uID0+IHtcbiAgICAgICAgY29uc3QgYSA9IGxpc3RTZWxlY3Rpb24uaGVhZC5saW5lXG4gICAgICAgIGNvbnN0IGIgPSBsaXN0U2VsZWN0aW9uLmFuY2hvci5saW5lXG4gICAgICAgIGNvbnN0IGZyb21MaW5lTnVtID0gYiA+IGEgPyBhIDogYlxuICAgICAgICBjb25zdCB0b0xpbmVOdW0gPSBiID4gYSA/IGIgOiBhXG4gICAgICAgIGZvciAobGV0IGkgPSBmcm9tTGluZU51bTsgaSA8PSB0b0xpbmVOdW07IGkrKykge1xuICAgICAgICAgICAgY29uc3QgbGluZSA9IGVkaXRvci5nZXRMaW5lKGkpXG4gICAgICAgICAgICB0ZXh0ICs9IGxpbmUgKyBcIlxcblwiXG4gICAgICAgIH1cbiAgICB9KVxuICAgIHJldHVybiB0ZXh0LnJlcGxhY2UoL1xcbiQvLCBcIlwiKVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFNlbGVjdGlvblJhbmdlIHtcbiAgICBmcm9tTGluZU51bTogbnVtYmVyXG4gICAgZnJvbUNoOiBudW1iZXJcbiAgICB0b0xpbmVOdW06IG51bWJlclxuICAgIHRvQ2g6IG51bWJlclxufVxuXG4vLyBhc3N1bWUgMSBzZWxlY3Rpb25cbmV4cG9ydCBmdW5jdGlvbiBnZXRDdXJyZW50U2VsZWN0aW9uTGluZU51bWJlcihlZGl0b3I6IEVkaXRvcik6IFNlbGVjdGlvblJhbmdlIHtcbiAgICBsZXQgdGV4dCA9IFwiXCJcbiAgICBsZXQgZnJvbUxpbmVOdW0gPSAwXG4gICAgbGV0IGZyb21DaCA9IDBcbiAgICBsZXQgdG9MaW5lTnVtID0gMFxuICAgIGxldCB0b0NoID0gMFxuICAgIGNvbnN0IGxpc3RTZWxlY3Rpb25zOiBFZGl0b3JTZWxlY3Rpb25bXSA9IGVkaXRvci5saXN0U2VsZWN0aW9ucygpXG4gICAgbGlzdFNlbGVjdGlvbnMuZm9yRWFjaChsaXN0U2VsZWN0aW9uID0+IHtcbiAgICAgICAgY29uc3QgYSA9IGxpc3RTZWxlY3Rpb24uaGVhZC5saW5lXG4gICAgICAgIGNvbnN0IGFjaCA9IGxpc3RTZWxlY3Rpb24uaGVhZC5jaFxuICAgICAgICBjb25zdCBiID0gbGlzdFNlbGVjdGlvbi5hbmNob3IubGluZVxuICAgICAgICBjb25zdCBiY2ggPSBsaXN0U2VsZWN0aW9uLmFuY2hvci5jaFxuICAgICAgICBmcm9tTGluZU51bSA9IGIgPiBhID8gYSA6IGJcbiAgICAgICAgZnJvbUNoID0gYiA+IGEgPyBhY2ggOiBiY2hcbiAgICAgICAgdG9MaW5lTnVtID0gYiA+IGEgPyBiIDogYVxuICAgICAgICB0b0NoID0gYiA+IGEgPyBiY2ggOiBhY2hcbiAgICB9KVxuICAgIHJldHVybiB7IGZyb21MaW5lTnVtLCBmcm9tQ2gsIHRvTGluZU51bSwgdG9DaCB9XG59IiwgImltcG9ydCB7IEVkaXRvciB9IGZyb20gXCJvYnNpZGlhblwiXG5cbmNvbnN0IHNraXBGcm9udE1hdHRlckZpZWxkOiBzdHJpbmdbXSA9IFtcblx0XCJmcmVldGltZXRhc2s6IFwiLFxuXHRcImV4cGVjdGVkdGltZTogXCIsXG5cdFwibW9kZTogXCIsXG5cdFwiZGF5czogXCIsXG5cdFwic2hvd2hlYWRlcmZvb3RlcjogXCIsXG5cdFwic2hvd3N0YXRlOiBcIixcblx0XCJzb3J0c3VicGFnZWZpbHRlcjogXCIsXG5cdFwidGhyb3VnaHR0cmVlOiBcIixcblx0XCJ1cmdlbnQ6IFwiLFxuXHRcImRpc3BsYXlhczogXCIsXG5cdFwic3RhcnRkYXRlOiBcIixcblx0XCJyZWFkd3JpdGVtb2RlOiBcIixcblx0XCJzaG93Q2hhbmRsZXJOb3c6IFwiLFxuXHRcImRlZXB3b3JrOiBcIixcblx0XCJleHBlY3RlZHRpbWU6IFwiLFxuXHRcInBhcnNlZGF0ZTogXCIsXG5cdFwidGlkc2NvcGU6IFwiLFxuXHRcImluc2VydHRvZG9hY3Rpb246IFwiLFxuXHRcIm9wdGlvbmFsOiBcIixcblx0XCJyZXBsYWNldG86IFwiLFxuXHRcImJhY2t1cHRpZGRsZXI6IFwiLFxuXHRcImRlYWRsaW5lOiBcIixcblx0XCJjYXB0aW9uOiBcIixcblx0XCJjb2xsZWN0aW9uOiBcIixcblx0XCJsaWJyYXJ5OiBcIixcblx0XCJsaWJyYXJ5X3ZlcnNpb246IFwiLFxuXHRcImR1bW15OiBcIixcblx0XCJ0aWROYW1lOiBcIixcblx0XCJjaHJvbmljbGVkYXRlOiBcIixcblx0XCJldmVudGRhdGU6IFwiLFxuXHRcImRhaWx5aGlnaGxpZ2h0OiBcIixcblx0XCJkaXNwbGF5Y2FyZG1vZGU6IFwiLFxuXHRcImRpc3BsYXltb2RlOiBcIixcblx0XCJudW1jb2w6IFwiLFxuXHRcImRhdGV5eXl5bW1kZDogXCIsXG5cdFwiZ3JhcGhkaXNwbGF5bW9kZTogXCIsXG5cdFwibWF4ZGVwdGg6IFwiLFxuXHRcImpvdXJuYWxkYXRlOiBcIixcblx0XCJ0aGlzQmlsbERhdGU6IFwiLFxuXHRcImxhc3RCaWxsRGF0ZTogXCIsXG5cdFwicm9vdHRpZGRsZXI6IFwiLFxuXHRcInllYXI6IFwiLFxuXHRcInRvOiBcIixcblx0XCJ0aWR0ZW1wbGF0ZTogXCIsXG5cdFwidGlkZGxlcm5hbWU6IFwiLFxuXHRcInRoZW1lOiBcIixcblx0XCJ0YWd2YWx1ZTogXCIsXG5cdFwic3VidGFza251bTogXCIsXG5cdFwicmVtb3ZldGFndmFsdWU6IFwiLFxuXHRcInJlY3VycmluZ2V2ZW50c3RhcnRkYXRlOiBcIixcblx0XCJyZWN1cnJpbmdldmVudGVuZGRhdGU6IFwiLFxuXHRcInBsdWdpbm5hbWU6IFwiLFxuXHRcInBpZDogXCIsXG5cdFwibWFjcm9uYW1lOiBcIixcblx0XCJsaW1pdDogXCIsXG5cdFwia2V5d29yZDogXCIsXG5cdFwia2V5d29yZHRtcDogXCIsXG5cdFwiZnJvbTogXCIsXG5cdFwiZGVwcmVjYXRlcmVhc29uOiBcIixcblx0XCJkZWVwd286IFwiLFxuXHRcImNvbG9yOiBcIixcblx0XCJyb3c6IFwiLFxuXHRcImNvbDogXCIsXG5cdFwiYm9va21hcmtlZDogXCIsXG5cdFwiYmxvY2tpbmdyZW1pbmRlcmRhdGU6IFwiLFxuXHRcImJhY2t1cDogXCJcbl1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlcGxhY2VUV1VzZWxlc3NWYWx1ZSh2YWx1ZTogc3RyaW5nKSA6IHN0cmluZyB7XG4gICAgcmV0dXJuIHZhbHVlXG4gICAgICAgIC5yZXBsYWNlKFwiIyMgPiBSZWZlcmVuY2VzXFxuXFxuKiBcXG5cXG5cIiwgXCJcIilcbiAgICAgICAgLnJlcGxhY2UoXCIjIyA+IEdvYWwgYW5kIFJlYXNvblxcblxcbiogXFxuXFxuXCIsIFwiXCIpXG4gICAgICAgIC5yZXBsYWNlKFwiIyMgPiBEZWxpdmVyYWJsZSBTcGVjXFxuXFxuKiBcXG5cXG5cIiwgXCJcIilcbiAgICAgICAgLnJlcGxhY2UoXCIjIyA+IENvbmRpdG9uIG9mIGRvbmVcXG5cXG4qIFxcblxcblwiLCBcIlwiKVxuICAgICAgICAucmVwbGFjZShcIiMjID4gU3RlcFxcblxcbiogXFxuXFxuXCIsIFwiXCIpXG4gICAgICAgIC5yZXBsYWNlKFwiIyMgPiBQcm9ncmVzc1xcblxcbiogXFxuXFxuXCIsIFwiXCIpXG4gICAgICAgIC5yZXBsYWNlKFwiIyMgPiBSZXN1bHRzXFxuXFxuKiBcXG5cXG5cIiwgXCJcIilcbiAgICAgICAgLnJlcGxhY2UoXCIjIyA+IEV4cGVyaWVuY2VcXG5cXG4qIFxcblxcblwiLCBcIlwiKVxuICAgICAgICAucmVwbGFjZShcIiMjID4gUmVmZXJlbmNlc1xcblxcbiogXFxuXFxuXCIsIFwiXCIpXG4gICAgICAgIC5yZXBsYWNlKFwiIyMgPiBSZXN1bHRzLCBTdGVwcyBhbmQgRXhwXFxuXFxuKiBcXG5cXG5cIiwgXCJcIilcbiAgICAgICAgLnJlcGxhY2UoXCIjIyA+IENoZWNrbGlzdFxcblxcblsgXSBcXG5cXG5cIiwgXCJcIilcbiAgICAgICAgLnJlcGxhY2UoL1xcblxcblxcbisvLCBcIlxcblxcblwiKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gc2hvdWxkU2tpcEZyb250TWF0dGVyKGxpbmU6IHN0cmluZykgOiBib29sZWFuIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNraXBGcm9udE1hdHRlckZpZWxkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChsaW5lLnN0YXJ0c1dpdGgoc2tpcEZyb250TWF0dGVyRmllbGRbaV0pKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0UGFyZW50TGluZSh2YWx1ZTogc3RyaW5nKSB7XG4gICAgY29uc3QgdmFsdWVzID0gdmFsdWUuc3BsaXQoXCJcXG5cIilcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBsaW5lQ29udGVudCA9IHZhbHVlc1tpXVxuICAgICAgICBpZiAoL15wYXJlbnRcXGQrOiAvLnRlc3QobGluZUNvbnRlbnQpIHx8IC9eXFx0Ky0gcGFyZW50XFxkKzogLy50ZXN0KGxpbmVDb250ZW50KSkge1xuICAgICAgICAgICAgcmV0dXJuIGlcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gMFxufVxuXG5leHBvcnQgZnVuY3Rpb25cdHRpZHlVcEZyb250TWF0dGVyb25FZGl0b3IoZWRpdG9yOiBFZGl0b3IpIHtcbiAgICBjb25zdCB2YWx1ZSA9IGVkaXRvci5nZXRWYWx1ZSgpXG4gICAgY29uc3QgbW9kaWZpZWRWYWx1ZSA9IHRpZHlVcEZyb250TWF0dGVyT25WYWx1ZSh2YWx1ZSlcbiAgICBlZGl0b3Iuc2V0VmFsdWUobW9kaWZpZWRWYWx1ZSlcbn1cblxuLypcbmV4cG9ydCBmdW5jdGlvblx0dGlkeVVwRnJvbnRNYXR0ZXJPblZhbHVlKHZhbHVlOiBTdHJpbmcpIHtcbiAgICBjb25zdCB2YWx1ZXM6IHN0cmluZ1tdID0gdmFsdWUuc3BsaXQoXCJcXG5cIilcbiAgICBjb25zdCBsaW5lQ291bnQgPSB2YWx1ZXMubGVuZ3RoXG5cbiAgICBsZXQgZm0gPSBcIlwiXG4gICAgbGV0IGMgPSBcIlwiXG4gICAgbGV0IHRleHQgPSBcIlwiXG4gICAgbGV0IGgzQ291bnQgPSAwO1xuICAgIGxldCBjb250ZW50ID0gXCJcIlxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZUNvdW50OyBpKyspIHtcbiAgICAgICAgY29uc3QgbGluZSA9IHZhbHVlc1tpXVxuICAgICAgICBpZiAoaDNDb3VudCA9PSAwKSB7XG4gICAgICAgICAgICBjb250ZW50ICs9IChsaW5lICsgXCJcXG5cIilcbiAgICAgICAgfSBlbHNlIGlmIChoM0NvdW50ID09IDEpIHtcbiAgICAgICAgICAgIGlmIChzaG91bGRTa2lwRnJvbnRNYXR0ZXIobGluZSkpIHtcbiAgICAgICAgICAgICAgICAvLyBkbyBub3RoaW5nXG4gICAgICAgICAgICB9IGVsc2UgaWYgKC9ecGFyZW50XFxkKzogLy50ZXN0KGxpbmUpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbW9kaWZpZWRMaW5lID0gbGluZS5yZXBsYWNlKC9cXC8vZywgXCJfXCIpLnJlcGxhY2UoL1xcPy9nLCBcIl9cIikucmVwbGFjZSgvOi9nLCBcIl9cIikucmVwbGFjZSgvXihwYXJlbnRcXGQrKV8gLywgXCIkMTogXCIpXG4gICAgICAgICAgICAgICAgZm0gKz0gKG1vZGlmaWVkTGluZSArIFwiXFxuXCIpXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGxpbmUuc3RhcnRzV2l0aChcInRpdGxlOiBcIikpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtb2RpZmllZExpbmUgPSBsaW5lLnJlcGxhY2UoLzovZywgXCJfXCIpLnJlcGxhY2UoL150aXRsZV8gLywgXCJ0aXRsZTogXCIpLnJlcGxhY2UoL1xcLy9nLCBcIl9cIikucmVwbGFjZSgvXFw/L2csIFwiX1wiKVxuICAgICAgICAgICAgICAgIGZtICs9IChtb2RpZmllZExpbmUgKyBcIlxcblwiKVxuICAgICAgICAgICAgfSBlbHNlIGlmIChsaW5lID09PSBcInRhZ3M6IFtleGNhbGlkcmF3XVwiKXtcbiAgICAgICAgICAgICAgICBmbSArPSAobGluZSArIFwiXFxuXCIpXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGxpbmUuc3RhcnRzV2l0aChcInRhZ3NzczogXCIpIHx8IGxpbmUuc3RhcnRzV2l0aChcInRhZ3M6IFwiKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJyYWNrZXRQYXR0ZXJuID0gL1xcW1xcWy4qP1xcXVxcXS9nO1xuXG4gICAgICAgICAgICAgICAgLy8gRmluZCBhbGwgYnJhY2tldGVkIGl0ZW1zXG4gICAgICAgICAgICAgICAgY29uc3QgYnJhY2tldGVkSXRlbXMgPSBsaW5lLm1hdGNoKGJyYWNrZXRQYXR0ZXJuKSB8fCBbXTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgYnJhY2tldGVkIGl0ZW1zIGZyb20gdGhlIGlucHV0IHN0cmluZyB0byBkZWFsIHdpdGggdGhlIHJlbWFpbmluZ1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlbWFpbmluZ1N0cmluZyA9IGxpbmUucmVwbGFjZShicmFja2V0UGF0dGVybiwgJycpLnRyaW0oKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyBTcGxpdCB0aGUgcmVtYWluaW5nIHN0cmluZyBieSBzcGFjZXMgdG8gZ2V0IHRoZSBpbmRpdmlkdWFsIHdvcmRzXG4gICAgICAgICAgICAgICAgY29uc3QgcmVtYWluaW5nSXRlbXMgPSByZW1haW5pbmdTdHJpbmcuc3BsaXQoL1xccysvKS5maWx0ZXIoaXRlbSA9PiBpdGVtKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyBDb21iaW5lIHRoZSBicmFja2V0ZWQgaXRlbXMgYW5kIHRoZSBpbmRpdmlkdWFsIHdvcmRzIGludG8gb25lIGFycmF5XG4gICAgICAgICAgICAgICAgY29uc3QgZm10YWdzc3MgPSBbLi4uYnJhY2tldGVkSXRlbXMsIC4uLnJlbWFpbmluZ0l0ZW1zXTtcblxuICAgICAgICAgICAgICAgIGxldCBwYXJlbnQgOiBzdHJpbmdbXSA9IFtdXG4gICAgICAgICAgICAgICAgbGV0IHRhZ3NzcyA6IHN0cmluZ1tdID0gW11cbiAgICAgICAgICAgICAgICBsZXQgc2tpcHMgOiBzdHJpbmdbXT0gW11cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBmbXRhZ3Nzcy5mb3JFYWNoKHRhZyA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRhZyA9IHRhZy50cmltKClcbiAgICAgICAgICAgICAgICAgICAgLy8gW1tldmVudCBuXV0gLyBbW2V2ZW50IHddXSAvIHJlZ2V4IG9mIFtbMjAyMjA3MTcgSm91cm5hbCAoV2VlayAyOCBTdW4pXV06IHB1dCBpbiBza2lwc1xuICAgICAgICAgICAgICAgICAgICAvLyBbWzIwMjIwNzIxIEpvdXJuYWwgKFdlZWsgMjkgVGh1KV1dXG4gICAgICAgICAgICAgICAgICAgIGlmICh0YWcgPT09IFwiW1suSGVhZGVyIFNob3J0Y3V0XV1cIiB8fCB0YWcgPT09IFwiW1suQ3VycmVudCBQcm9qZWN0XV1cIiB8fCB0YWcgPT09IFwiY29uY2VwdFwiIHx8IHRhZyA9PT0gXCJzcGFjZVwiIHx8IHRhZyA9PT0gXCJwcm9ibGVtXCIgfHwgdGFnID09PSBcInRhZ3NzczpcIiB8fCB0YWcgPT09IFwidGFnczpcIiB8fCB0YWcgPT09IFwiW1tldmVudCBuXV1cIiB8fCB0YWcgPT09IFwiW1tldmVudCB3XV1cIlxuICAgICAgICAgICAgICAgICAgICAgICAgfHwgL1xcW1xcW1xcZHs4fSBKb3VybmFsIFxcKFdlZWsgXFxkKyBbQS1aYS16XXszfVxcKVxcXVxcXS8udGVzdCh0YWcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBza2lwcy5wdXNoKHRhZylcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0YWcgPT09IFwicGVybXRhc2tcIiB8fCBcdHRhZyA9PT0gXCJOXCIgfHwgdGFnID09PSBcIldcIiB8fCB0YWcgPT09IFwibm93XCIgfHwgdGFnID09PSBcImxhdGVyXCIgfHwgdGFnID09PSBcIndhaXRpbmdcIiB8fCB0YWcgPT09IFwiZG9uZVwiIHx8IHRhZyA9PT0gXCJhcmNoaXZlXCIgfHwgdGFnID09PSBcImFjdGlvblwiIHx8IHRhZyA9PT0gXCJ0YXNrXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhZ3Nzcy5wdXNoKHRhZy5yZXBsYWNlKFwiW1tcIiwgXCJcIikucmVwbGFjZShcIl1dXCIsIFwiXCIpKVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRhZyA9PT0gXCJwcmVibG9nXCIgfHwgdGFnID09PSBcInByZXByZWJsb2dcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50LnB1c2goXCJbW0Jsb2cgXyBQb3N0XV1cIilcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudC5wdXNoKHRhZylcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLy9uZXcgTm90aWNlKHNraXBzLmpvaW4oXCJcXG5cIikpXG4gICAgICAgICAgICAgICAgbGV0IG1vZGlmaWVkTGluZSA9IFwiXCJcbiAgICAgICAgICAgICAgICBpZiAodGFnc3NzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbW9kaWZpZWRMaW5lICs9IFwidGFnc3NzOiBcIiArIHRhZ3Nzcy5qb2luKFwiIFwiKSArIFwiXFxuXCJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IHBhcmVudENvdW50ID0gMVxuICAgICAgICAgICAgICAgIGlmIChwYXJlbnQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB1bmlxdWVQYXJlbnQgPSBBcnJheS5mcm9tKG5ldyBTZXQocGFyZW50KSk7XG4gICAgICAgICAgICAgICAgICAgIHVuaXF1ZVBhcmVudC5mb3JFYWNoKHAgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHAuc3RhcnRzV2l0aChcIltbXCIpICYmIHAuZW5kc1dpdGgoXCJdXVwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZGlmaWVkTGluZSArPSBcInBhcmVudFwiICsgcGFyZW50Q291bnQgKyBcIjogXFxcIlwiICsgcC5yZXBsYWNlKFwiOlwiLCBcIl9cIikgKyBcIlxcXCJcXG5cIlxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2RpZmllZExpbmUgKz0gXCJwYXJlbnRcIiArIHBhcmVudENvdW50ICsgXCI6IFxcXCJbW1wiICsgcC5yZXBsYWNlKFwiOlwiLCBcIl9cIikgKyBcIl1dXFxcIlxcblwiXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRDb3VudCsrXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZtICs9IG1vZGlmaWVkTGluZVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmbSArPSAobGluZSArIFwiXFxuXCIpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGgzQ291bnQgPj0gMikge1xuICAgICAgICAgICAgYyArPSAobGluZSArIFwiXFxuXCIpXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxpbmUgPT09IFwiLS0tXCIpIHtcbiAgICAgICAgICAgIGgzQ291bnQrKztcbiAgICAgICAgfVxuICAgIH0gXG4gICAgdGV4dCArPSBjb250ZW50XG4gICAgaWYgKGZtLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGV4dCArPSBmbVxuICAgIH1cbiAgICB0ZXh0ICs9IGNcbiAgICBcbiAgICByZXR1cm4gdGV4dC5yZXBsYWNlKC9eLS0tXFxuLS0tXFxuL20sIFwiXCIpLnJlcGxhY2UoL1xcbiQvLCBcIlwiKVxufVxuKi9cblxuZXhwb3J0IGZ1bmN0aW9uXHR0aWR5VXBGcm9udE1hdHRlck9uVmFsdWUodmFsdWU6IFN0cmluZykge1xuICAgIGNvbnN0IHZhbHVlczogc3RyaW5nW10gPSB2YWx1ZS5zcGxpdChcIlxcblwiKVxuICAgIGNvbnN0IGxpbmVDb3VudCA9IHZhbHVlcy5sZW5ndGhcblxuICAgIGxldCBmbSA9IFwiXCJcbiAgICBsZXQgYyA9IFwiXCJcbiAgICBsZXQgdGV4dCA9IFwiXCJcbiAgICBsZXQgaDNDb3VudCA9IDA7XG4gICAgbGV0IGNvbnRlbnQgPSBcIlwiXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lQ291bnQ7IGkrKykge1xuICAgICAgICBjb25zdCBsaW5lID0gdmFsdWVzW2ldXG4gICAgICAgIGlmIChoM0NvdW50ID09IDApIHtcbiAgICAgICAgICAgIGNvbnRlbnQgKz0gKGxpbmUgKyBcIlxcblwiKVxuICAgICAgICB9IGVsc2UgaWYgKGgzQ291bnQgPT0gMSkge1xuICAgICAgICAgICAgaWYgKC9ebGlzdDogLy50ZXN0KGxpbmUpKSB7XG4gICAgICAgICAgICAgICAgLy8gcmVtb3ZlIGxpc3QgZmllbGRcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZm0gKz0gKGxpbmUgKyBcIlxcblwiKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLypcbiAgICAgICAgICAgIGlmICgvXnRhZzogW2EtY11cXC9bYS16XVxcL1thLXpdJC8udGVzdChsaW5lKSkge1xuICAgICAgICAgICAgICAgIGZtICs9IChsaW5lLnJlcGxhY2UoL150YWc6IC8sIFwidGFnczogXCIpICsgXCJcXG5cIilcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZm0gKz0gKGxpbmUgKyBcIlxcblwiKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKi9cbiAgICAgICAgfVxuICAgICAgICBpZiAoaDNDb3VudCA+PSAyKSB7XG4gICAgICAgICAgICBjICs9IChsaW5lICsgXCJcXG5cIilcbiAgICAgICAgfVxuICAgICAgICBpZiAobGluZSA9PT0gXCItLS1cIikge1xuICAgICAgICAgICAgaDNDb3VudCsrO1xuICAgICAgICB9XG4gICAgfSBcbiAgICB0ZXh0ICs9IGNvbnRlbnRcbiAgICBpZiAoZm0ubGVuZ3RoID4gMCkge1xuICAgICAgICB0ZXh0ICs9IGZtXG4gICAgfVxuICAgIHRleHQgKz0gY1xuICAgIFxuICAgIHJldHVybiB0ZXh0LnJlcGxhY2UoL14tLS1cXG4tLS1cXG4vbSwgXCJcIikucmVwbGFjZSgvXFxuJC8sIFwiXCIpXG59IiwgImltcG9ydCB7IEVkaXRvciB9IGZyb20gXCJvYnNpZGlhblwiXG5cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVDb250ZW50RnJvbVN0YXJ0T2ZOb3RlVG9DdXJzb3IoZWRpdG9yOiBFZGl0b3IpIHtcbiAgICBjb25zdCBjdXJzb3IgPSBlZGl0b3IuZ2V0Q3Vyc29yKClcbiAgICBjb25zdCBsaW5lID0gY3Vyc29yLmxpbmVcbiAgICBjb25zdCBjaCA9IGN1cnNvci5jaFxuICAgIGNvbnN0IGxpbmVDb250ZW50ID0gZWRpdG9yLmdldExpbmUobGluZSlcbiAgICAvLyByZW1vdmUgY29udGVudCBmcm9tIGZpcnN0IGNoYXJhY3RlciB0byBjaCBjaGFyYWN0ZXIgb2YgbGluZUNvbnRlbnRcbiAgICBsZXQgbmV3Q29udGVudCA9IGxpbmVDb250ZW50LnN1YnN0cmluZyhjaClcbiAgICBmb3IgKGxldCBpID0gbGluZSArIDE7IGkgPCBlZGl0b3IubGluZUNvdW50KCk7IGkrKykge1xuICAgICAgICBuZXdDb250ZW50ICs9IFwiXFxuXCIgKyBlZGl0b3IuZ2V0TGluZShpKVxuICAgIH1cbiAgICBlZGl0b3Iuc2V0VmFsdWUobmV3Q29udGVudClcbiAgICBjdXJzb3IubGluZSA9IDBcbiAgICBjdXJzb3IuY2ggPSAwXG4gICAgZWRpdG9yLnNldEN1cnNvcihjdXJzb3IpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVDb250ZW50RnJvbUN1cnNvclRvRW5kT2ZOb3RlKGVkaXRvcjogRWRpdG9yKSB7XG4gICAgY29uc3QgY3Vyc29yID0gZWRpdG9yLmdldEN1cnNvcigpXG4gICAgY29uc3QgbGluZSA9IGN1cnNvci5saW5lXG4gICAgY29uc3QgY2ggPSBjdXJzb3IuY2hcbiAgICBjb25zdCBsaW5lQ29udGVudCA9IGVkaXRvci5nZXRMaW5lKGxpbmUpXG4gICAgbGV0IG5ld0NvbnRlbnQgPSBcIlwiXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lOyBpKyspIHtcbiAgICAgICAgbmV3Q29udGVudCArPSBlZGl0b3IuZ2V0TGluZShpKSArIFwiXFxuXCJcbiAgICB9XG4gICAgbmV3Q29udGVudCArPSBsaW5lQ29udGVudC5zdWJzdHJpbmcoMCwgY2gpXG4gICAgZWRpdG9yLnNldFZhbHVlKG5ld0NvbnRlbnQpXG4gICAgY3Vyc29yLmxpbmUgPSBsaW5lXG4gICAgY3Vyc29yLmNoID0gY2hcbiAgICBlZGl0b3Iuc2V0Q3Vyc29yKGN1cnNvcilcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZUNvbnRlbnRMZWZ0U2FtZUxpbmUoZWRpdG9yOiBFZGl0b3IpIHtcbiAgICBjb25zdCBjdXJzb3IgPSBlZGl0b3IuZ2V0Q3Vyc29yKClcbiAgICBjb25zdCBsaW5lID0gY3Vyc29yLmxpbmVcbiAgICBjb25zdCBjaCA9IGN1cnNvci5jaFxuICAgIGNvbnN0IGxpbmVDb250ZW50ID0gZWRpdG9yLmdldExpbmUobGluZSlcbiAgICAvLyByZW1vdmUgY29udGVudCBmcm9tIGZpcnN0IGNoYXJhY3RlciB0byBjaCBjaGFyYWN0ZXIgb2YgbGluZUNvbnRlbnRcbiAgICBlZGl0b3Iuc2V0TGluZShsaW5lLCBsaW5lQ29udGVudC5zdWJzdHJpbmcoY2gpKVxuICAgIGN1cnNvci5jaCA9IDBcbiAgICBlZGl0b3Iuc2V0Q3Vyc29yKGN1cnNvcilcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZUNvbnRlbnRSaWdodFNhbWVMaW5lKGVkaXRvcjogRWRpdG9yKSB7XG4gICAgY29uc3QgY3Vyc29yID0gZWRpdG9yLmdldEN1cnNvcigpXG4gICAgY29uc3QgbGluZSA9IGN1cnNvci5saW5lXG4gICAgY29uc3QgY2ggPSBjdXJzb3IuY2hcbiAgICBjb25zdCBsaW5lQ29udGVudCA9IGVkaXRvci5nZXRMaW5lKGxpbmUpXG4gICAgLy8gcmVtb3ZlIGNvbnRlbnQgZnJvbSBjaCBjaGFyYWN0ZXIgdG8gZW5kIG9mIGxpbmVDb250ZW50XG4gICAgZWRpdG9yLnNldExpbmUobGluZSwgbGluZUNvbnRlbnQuc3Vic3RyaW5nKDAsIGNoKSlcbiAgICBjdXJzb3IuY2ggPSBlZGl0b3IuZ2V0TGluZShsaW5lKS5sZW5ndGhcbiAgICBlZGl0b3Iuc2V0Q3Vyc29yKGN1cnNvcilcbn0iLCAiaW1wb3J0IHsgQXBwLCBFZGl0b3IsIEZ1enp5U3VnZ2VzdE1vZGFsLCBGdXp6eU1hdGNoLCBURmlsZSB9IGZyb20gXCJvYnNpZGlhblwiO1xuaW1wb3J0IHsgcmVtb3ZlQ29udGVudEZyb21DdXJzb3JUb0VuZE9mTm90ZSwgcmVtb3ZlQ29udGVudEZyb21TdGFydE9mTm90ZVRvQ3Vyc29yLCByZW1vdmVDb250ZW50TGVmdFNhbWVMaW5lLCByZW1vdmVDb250ZW50UmlnaHRTYW1lTGluZSB9IGZyb20gXCJzZWxmdXRpbC9yZW1vdmVDb250ZW50RnJvbUN1cnNvclwiO1xuXG5leHBvcnQgY2xhc3MgUmVtb3ZlQ29udGVudEZyb21DdXJzb3JNb2RhbCBleHRlbmRzIEZ1enp5U3VnZ2VzdE1vZGFsPHN0cmluZz4ge1xuXG4gIHJlbW92ZUNvbnRlbnRMZWZ0U2FtZUxpbmUgOiBzdHJpbmcgPSBcIlJlbW92ZSBjb250ZW50IGxlZnQgc2FtZSBsaW5lXCJcbiAgcmVtb3ZlQ29udGVudFJpZ2h0U2FtZUxpbmUgOiBzdHJpbmcgPSBcIlJlbW92ZSBjb250ZW50IHJpZ2h0IHNhbWUgbGluZVwiXG4gIHJlbW92ZUNvbnRlbnRGcm9tU3RhcnRPZk5vdGVUb0N1cnNvcjogc3RyaW5nID0gXCJSZW1vdmUgY29udGVudCBmcm9tIHN0YXJ0IG9mIG5vdGUgdG8gY3Vyc29yXCJcbiAgcmVtb3ZlQ29udGVudEZyb21DdXJzb3JUb0VuZE9mTm90ZTogc3RyaW5nID0gXCJSZW1vdmUgY29udGVudCBmcm9tIGN1cnNvciB0byBlbmQgb2Ygbm90ZVwiXG5cbiAgb3B0aW9uczogc3RyaW5nW10gPSBbdGhpcy5yZW1vdmVDb250ZW50TGVmdFNhbWVMaW5lLCB0aGlzLnJlbW92ZUNvbnRlbnRSaWdodFNhbWVMaW5lLCB0aGlzLnJlbW92ZUNvbnRlbnRGcm9tU3RhcnRPZk5vdGVUb0N1cnNvciwgdGhpcy5yZW1vdmVDb250ZW50RnJvbUN1cnNvclRvRW5kT2ZOb3RlXVxuICBlZGl0b3I6IEVkaXRvcjtcblxuICBjb25zdHJ1Y3RvcihhcHA6IEFwcCwgZWRpdG9yOiBFZGl0b3IpXG4gIHtcbiAgICBzdXBlcihhcHApXG4gICAgdGhpcy5lZGl0b3IgPSBlZGl0b3JcbiAgfVxuXG4gIGdldEl0ZW1zKCk6IHN0cmluZ1tdIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zO1xuICB9XG5cbiAgZ2V0SXRlbVRleHQoaXRlbTogc3RyaW5nKTogc3RyaW5nIHtcbiAgICByZXR1cm4gaXRlbTtcbiAgfVxuXG4gIC8vIFJlbmRlcnMgZWFjaCBzdWdnZXN0aW9uIGl0ZW0uXG4gIHJlbmRlclN1Z2dlc3Rpb24oaTogRnV6enlNYXRjaDxzdHJpbmc+LCBlbDogSFRNTEVsZW1lbnQpIHtcbiAgICBjb25zdCBpdGVtID0gaS5pdGVtXG4gICAgZWwuY3JlYXRlRWwoXCJkaXZcIiwgeyB0ZXh0OiBpdGVtIH0pO1xuICB9XG5cbiAgLy8gUGVyZm9ybSBhY3Rpb24gb24gdGhlIHNlbGVjdGVkIHN1Z2dlc3Rpb24uXG4gIGFzeW5jIG9uQ2hvb3NlSXRlbShzZWxlY3RlZENvbnRlbnQ6IHN0cmluZywgZXZ0OiBNb3VzZUV2ZW50IHwgS2V5Ym9hcmRFdmVudCkge1xuICAgIGNvbnN0IGNob29zZW5PcHRpb24gPSBzZWxlY3RlZENvbnRlbnRcbiAgICBpZiAoY2hvb3Nlbk9wdGlvbiA9PT0gdGhpcy5yZW1vdmVDb250ZW50TGVmdFNhbWVMaW5lKSB7XG4gICAgICByZW1vdmVDb250ZW50TGVmdFNhbWVMaW5lKHRoaXMuZWRpdG9yKVxuICAgIH0gZWxzZSBpZiAoY2hvb3Nlbk9wdGlvbiA9PT0gdGhpcy5yZW1vdmVDb250ZW50UmlnaHRTYW1lTGluZSkge1xuICAgICAgcmVtb3ZlQ29udGVudFJpZ2h0U2FtZUxpbmUodGhpcy5lZGl0b3IpXG4gICAgfSBlbHNlIGlmIChjaG9vc2VuT3B0aW9uID09PSB0aGlzLnJlbW92ZUNvbnRlbnRGcm9tU3RhcnRPZk5vdGVUb0N1cnNvcikge1xuICAgICAgcmVtb3ZlQ29udGVudEZyb21TdGFydE9mTm90ZVRvQ3Vyc29yKHRoaXMuZWRpdG9yKVxuICAgIH0gZWxzZSBpZiAoY2hvb3Nlbk9wdGlvbiA9PT0gdGhpcy5yZW1vdmVDb250ZW50RnJvbUN1cnNvclRvRW5kT2ZOb3RlKSB7XG4gICAgICByZW1vdmVDb250ZW50RnJvbUN1cnNvclRvRW5kT2ZOb3RlKHRoaXMuZWRpdG9yKVxuICAgIH1cbiAgfVxufSIsICJpbXBvcnQgeyBBcHAsIEVkaXRvciwgRnV6enlTdWdnZXN0TW9kYWwsIEZ1enp5TWF0Y2gsIFRGaWxlIH0gZnJvbSBcIm9ic2lkaWFuXCI7XG5cbmV4cG9ydCBjbGFzcyBGaW5kUmVwbGFjZU1vZGFsIGV4dGVuZHMgRnV6enlTdWdnZXN0TW9kYWw8c3RyaW5nPiB7XG5cbiAgZmluZCA6IHN0cmluZyA9IFwiZmluZFwiXG4gIHJlcGxhY2U6IHN0cmluZyA9IFwicmVwbGFjZVwiXG4gIG9wdGlvbnM6IHN0cmluZ1tdID0gW3RoaXMuZmluZCwgdGhpcy5yZXBsYWNlXVxuXG4gIGNvbnN0cnVjdG9yKGFwcDogQXBwKVxuICB7XG4gICAgc3VwZXIoYXBwKVxuICB9XG5cbiAgZ2V0SXRlbXMoKTogc3RyaW5nW10ge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnM7XG4gIH1cblxuICBnZXRJdGVtVGV4dChpdGVtOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIHJldHVybiBpdGVtO1xuICB9XG5cbiAgLy8gUmVuZGVycyBlYWNoIHN1Z2dlc3Rpb24gaXRlbS5cbiAgcmVuZGVyU3VnZ2VzdGlvbihpOiBGdXp6eU1hdGNoPHN0cmluZz4sIGVsOiBIVE1MRWxlbWVudCkge1xuICAgIGNvbnN0IGl0ZW0gPSBpLml0ZW1cbiAgICBlbC5jcmVhdGVFbChcImRpdlwiLCB7IHRleHQ6IGl0ZW0gfSk7XG4gIH1cblxuICAvLyBQZXJmb3JtIGFjdGlvbiBvbiB0aGUgc2VsZWN0ZWQgc3VnZ2VzdGlvbi5cbiAgYXN5bmMgb25DaG9vc2VJdGVtKHNlbGVjdGVkQ29udGVudDogc3RyaW5nLCBldnQ6IE1vdXNlRXZlbnQgfCBLZXlib2FyZEV2ZW50KSB7XG4gICAgY29uc3QgY2hvb3Nlbk9wdGlvbiA9IHNlbGVjdGVkQ29udGVudFxuICAgIGlmIChjaG9vc2VuT3B0aW9uID09PSB0aGlzLmZpbmQpXG4gICAge1xuICAgICAgLy8gQHRzLWlnbm9yZVxuXHRcdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1jYWxsXG5cdFx0XHRcdHRoaXMuYXBwLmNvbW1hbmRzLmV4ZWN1dGVDb21tYW5kQnlJZChcImVkaXRvcjpvcGVuLXNlYXJjaFwiKVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBAdHMtaWdub3JlXG5cdFx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWNhbGxcblx0XHRcdFx0dGhpcy5hcHAuY29tbWFuZHMuZXhlY3V0ZUNvbW1hbmRCeUlkKFwib2JzaWRpYW4tcmVnZXgtcmVwbGFjZTpvYnNpZGlhbi1yZWdleC1yZXBsYWNlXCIpXG4gICAgfVxuICB9XG59IiwgImltcG9ydCB7IEFkZFRleHRUb05vdGVzRnJvbVNwZWNpZmljVGFnTW9kYWwgfSBmcm9tIFwiYWRkVGV4dFRvTm90ZXNGcm9tU3BlY2lmaWNUYWdNb2RhbFwiO1xuaW1wb3J0IHsgQXBwLCBGdXp6eVN1Z2dlc3RNb2RhbCwgRnV6enlNYXRjaCwgZ2V0QWxsVGFncywgVEZpbGUsIEVkaXRvciwgTWFya2Rvd25WaWV3LCBOb3RpY2UgfSBmcm9tIFwib2JzaWRpYW5cIjtcbmltcG9ydCB7IGFkZFRleHRUb05vdGVzIH0gZnJvbSBcInNlbGZ1dGlsL2FkZGxpbmt0b25vdGVzXCI7XG5pbXBvcnQgeyBmaWxlc1doZXJlVGFnSXNVc2VkIH0gZnJvbSBcInNlbGZ1dGlsL2ZpbmROb3Rlc0Zyb21UYWdcIjtcbmltcG9ydCB7IGdldEFsbE5vdGVUYWdzIH0gZnJvbSBcInNlbGZ1dGlsL2dldEFsbE5vdGVUYWdzXCI7XG5pbXBvcnQgeyBnZXRBbGxOb3RlcywgZ2V0UmVjZW50Tm90ZXMgfSBmcm9tIFwic2VsZnV0aWwvZ2V0UmVjZW50Tm90ZXNcIjtcblxuZXhwb3J0IGNsYXNzIFF1ZXJ5T3JwaGFuTm90ZXNCeVRhZ01vZGFsIGV4dGVuZHMgRnV6enlTdWdnZXN0TW9kYWw8c3RyaW5nPiB7XG5cbiAgZWRpdG9yOiBFZGl0b3JcbiAgdmlldzogTWFya2Rvd25WaWV3XG5cbiAgY29uc3RydWN0b3IoYXBwOiBBcHAsIGVkaXRvcjogRWRpdG9yLCB2aWV3OiBNYXJrZG93blZpZXcpXG4gIHtcbiAgICBzdXBlcihhcHApXG4gICAgdGhpcy5zZXRQbGFjZWhvbGRlcihgV2hpY2ggbm90ZXMgd2l0aCB0YWdzIGRvIHlvdSB3YW50IHRvIHNlYXJjaCBvcnBoYW4/YClcbiAgICB0aGlzLnNldEluc3RydWN0aW9ucyhbXG4gICAgICB7XG4gICAgICAgIGNvbW1hbmQ6IFwiXCIsXG4gICAgICAgIHB1cnBvc2U6IGBXaGljaCBub3RlcyB3aXRoIHRhZ3MgZG8geW91IHdhbnQgdG8gc2VhcmNoIG9ycGhhbj9gXG4gICAgICB9XG4gICAgXSk7XG4gICAgdGhpcy5lZGl0b3IgPSBlZGl0b3JcbiAgICB0aGlzLnZpZXcgPSB2aWV3XG4gIH1cblxuICBnZXRJdGVtcygpIDogc3RyaW5nW10ge1xuXHRcdGNvbnN0IGwgPSBbLi4uZ2V0QWxsTm90ZVRhZ3ModGhpcy5hcHApLm1hcChzID0+IHMucmVwbGFjZSgvXiMvLCBcIkBcIikpXTtcbiAgICAvLyByZW1vdmUgZHVwbGljYXRlIGZvciBsXG4gICAgcmV0dXJuIGwuZmlsdGVyKChpdGVtLCBpbmRleCkgPT4gbC5pbmRleE9mKGl0ZW0pID09PSBpbmRleCk7XG4gIH1cblxuICBnZXRJdGVtVGV4dCh2YWx1ZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICAvLyBSZW5kZXJzIGVhY2ggc3VnZ2VzdGlvbiBpdGVtLlxuICByZW5kZXJTdWdnZXN0aW9uKHZhbHVlOiBGdXp6eU1hdGNoPHN0cmluZz4sIGVsOiBIVE1MRWxlbWVudCkge1xuICAgIGNvbnN0IGl0ZW0gPSB2YWx1ZS5pdGVtXG4gICAgZWwuY3JlYXRlRWwoXCJkaXZcIiwgeyB0ZXh0OiBpdGVtIH0pXG4gIH1cblxuICAvLyBQZXJmb3JtIGFjdGlvbiBvbiB0aGUgc2VsZWN0ZWQgc3VnZ2VzdGlvbi5cbiAgYXN5bmMgb25DaG9vc2VJdGVtKGNob29zZW5WYWx1ZTogc3RyaW5nLCBldnQ6IE1vdXNlRXZlbnQgfCBLZXlib2FyZEV2ZW50KSB7XG4gICAgY29uc29sZS5sb2codGhpcy52aWV3LmZpbGUucGF0aClcbiAgICBjb25zdCBxdWVyeU1kID0gXCJJL1NlbGYgUXVlcnkubWRcIlxuICAgIGlmICh0aGlzLnZpZXcuZmlsZS5wYXRoID09PSBxdWVyeU1kKSB7XG4gICAgICBuZXcgTm90aWNlKFwiQ2hlY2tpbmcuLi4gbWF5IG5lZWQgc29tZSB0aW1lXCIpXG4gICAgICBjb25zdCB0YWcgPSAgY2hvb3NlblZhbHVlLnJlcGxhY2UoL15ALywgXCIjXCIpXG4gICAgICBjb25zdCBmaWxlUGF0aHMgPSBmaWxlc1doZXJlVGFnSXNVc2VkKHRhZylcbiAgICAgIGxldCByZXN1bHQgPSBcIiMjIE9ycGhhbiBub3RlcyBmb3IgdGFnIGBcIiArIHRhZyArIFwiYFxcblwiXG4gICAgICBmb3IgKGNvbnN0IGZpbGVQYXRoIG9mIGZpbGVQYXRocykge1xuICAgICAgICBjb25zb2xlLmxvZyhgQ2hlY2tpbmcgYmFja2xpbmtzIGZvciAke2ZpbGVQYXRofWApXG4gICAgICAgIGNvbnN0IHRGaWxlOiBURmlsZSA9IHRoaXMuYXBwLnZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aChmaWxlUGF0aCkgYXMgVEZpbGVcbiAgICAgICAgY29uc3QgYmFja2xpbmtzID0gdGhpcy5hcHAubWV0YWRhdGFDYWNoZS5nZXRCYWNrbGlua3NGb3JGaWxlKHRGaWxlKVxuICAgICAgICBjb25zb2xlLmxvZyhiYWNrbGlua3MpXG4gICAgICAgIGNvbnNvbGUubG9nKGJhY2tsaW5rcy5kYXRhKVxuICAgICAgICBpZiAoIWJhY2tsaW5rcyB8fCAhYmFja2xpbmtzLmRhdGEgfHwgT2JqZWN0LmtleXMoYmFja2xpbmtzLmRhdGEpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKGBObyBiYWNrbGlua3MgZm9yICR7dEZpbGUucGF0aH1gKVxuICAgICAgICAgIHJlc3VsdCArPSBcIlxcblwiICsgXCItIFtbXCIgKyB0RmlsZS5iYXNlbmFtZSArIFwiXV1cIlxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHJlbW92ZSBrZXkgXCJhYWFcIiBmcm9tIGJhY2tsaW5rcy5kYXRhXG4gICAgICAgICAgZGVsZXRlIGJhY2tsaW5rcy5kYXRhW3F1ZXJ5TWRdXG4gICAgICAgICAgaWYgKE9iamVjdC5rZXlzKGJhY2tsaW5rcy5kYXRhKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBObyBiYWNrbGlua3MgZm9yICR7dEZpbGUucGF0aH1gKVxuICAgICAgICAgICAgcmVzdWx0ICs9IFwiXFxuXCIgKyBcIi0gW1tcIiArIHRGaWxlLmJhc2VuYW1lICsgXCJdXVwiXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBIYXMgYmFja2xpbmtzIGZvciAke3RGaWxlLnBhdGh9YClcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuZWRpdG9yLnNldFZhbHVlKHJlc3VsdClcbiAgICAgIG5ldyBOb3RpY2UoXCJVcGRhdGVkIG9ycGhhblwiKVxuICAgIH0gZWxzZSB7XG4gICAgICBuZXcgTm90aWNlKFwiUGxlYXNlIGdvIHRvICdcIiArIHF1ZXJ5TWQgKyBcIicgdG8gcnVuIHRoaXMgYWN0aW9uXCIpXG4gICAgfVxuICAgIFxuICAgIFxuICB9IFxufSJdLAogICJtYXBwaW5ncyI6ICI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUFBLDJDQUFBQSxTQUFBO0FBTUMsS0FBQyxTQUFVLFFBQVEsU0FBUztBQUN6QixhQUFPLFlBQVksWUFBWSxPQUFPQSxZQUFXLGNBQWNBLFFBQU8sVUFBVSxRQUFRLElBQ3hGLE9BQU8sV0FBVyxjQUFjLE9BQU8sTUFBTSxPQUFPLE9BQU8sSUFDM0QsT0FBTyxTQUFTLFFBQVE7QUFBQSxJQUM1QixHQUFFLFNBQU8sV0FBWTtBQUFFO0FBRW5CLFVBQUk7QUFFSixlQUFTLFFBQVE7QUFDYixlQUFPLGFBQWEsTUFBTSxNQUFNLFNBQVM7QUFBQSxNQUM3QztBQUlBLGVBQVMsZ0JBQWdCLFVBQVU7QUFDL0IsdUJBQWU7QUFBQSxNQUNuQjtBQUVBLGVBQVMsUUFBUSxPQUFPO0FBQ3BCLGVBQ0ksaUJBQWlCLFNBQ2pCLE9BQU8sVUFBVSxTQUFTLEtBQUssS0FBSyxNQUFNO0FBQUEsTUFFbEQ7QUFFQSxlQUFTLFNBQVMsT0FBTztBQUdyQixlQUNJLFNBQVMsUUFDVCxPQUFPLFVBQVUsU0FBUyxLQUFLLEtBQUssTUFBTTtBQUFBLE1BRWxEO0FBRUEsZUFBUyxXQUFXLEdBQUcsR0FBRztBQUN0QixlQUFPLE9BQU8sVUFBVSxlQUFlLEtBQUssR0FBRyxDQUFDO0FBQUEsTUFDcEQ7QUFFQSxlQUFTLGNBQWMsS0FBSztBQUN4QixZQUFJLE9BQU8scUJBQXFCO0FBQzVCLGlCQUFPLE9BQU8sb0JBQW9CLEdBQUcsRUFBRSxXQUFXO0FBQUEsUUFDdEQsT0FBTztBQUNILGNBQUk7QUFDSixlQUFLLEtBQUssS0FBSztBQUNYLGdCQUFJLFdBQVcsS0FBSyxDQUFDLEdBQUc7QUFDcEIscUJBQU87QUFBQSxZQUNYO0FBQUEsVUFDSjtBQUNBLGlCQUFPO0FBQUEsUUFDWDtBQUFBLE1BQ0o7QUFFQSxlQUFTLFlBQVksT0FBTztBQUN4QixlQUFPLFVBQVU7QUFBQSxNQUNyQjtBQUVBLGVBQVMsU0FBUyxPQUFPO0FBQ3JCLGVBQ0ksT0FBTyxVQUFVLFlBQ2pCLE9BQU8sVUFBVSxTQUFTLEtBQUssS0FBSyxNQUFNO0FBQUEsTUFFbEQ7QUFFQSxlQUFTLE9BQU8sT0FBTztBQUNuQixlQUNJLGlCQUFpQixRQUNqQixPQUFPLFVBQVUsU0FBUyxLQUFLLEtBQUssTUFBTTtBQUFBLE1BRWxEO0FBRUEsZUFBU0MsS0FBSSxLQUFLLElBQUk7QUFDbEIsWUFBSSxNQUFNLENBQUMsR0FDUDtBQUNKLGFBQUssSUFBSSxHQUFHLElBQUksSUFBSSxRQUFRLEVBQUUsR0FBRztBQUM3QixjQUFJLEtBQUssR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7QUFBQSxRQUMxQjtBQUNBLGVBQU87QUFBQSxNQUNYO0FBRUEsZUFBUyxPQUFPLEdBQUcsR0FBRztBQUNsQixpQkFBUyxLQUFLLEdBQUc7QUFDYixjQUFJLFdBQVcsR0FBRyxDQUFDLEdBQUc7QUFDbEIsY0FBRSxDQUFDLElBQUksRUFBRSxDQUFDO0FBQUEsVUFDZDtBQUFBLFFBQ0o7QUFFQSxZQUFJLFdBQVcsR0FBRyxVQUFVLEdBQUc7QUFDM0IsWUFBRSxXQUFXLEVBQUU7QUFBQSxRQUNuQjtBQUVBLFlBQUksV0FBVyxHQUFHLFNBQVMsR0FBRztBQUMxQixZQUFFLFVBQVUsRUFBRTtBQUFBLFFBQ2xCO0FBRUEsZUFBTztBQUFBLE1BQ1g7QUFFQSxlQUFTLFVBQVUsT0FBT0MsU0FBUUMsU0FBUSxRQUFRO0FBQzlDLGVBQU8saUJBQWlCLE9BQU9ELFNBQVFDLFNBQVEsUUFBUSxJQUFJLEVBQUUsSUFBSTtBQUFBLE1BQ3JFO0FBRUEsZUFBUyxzQkFBc0I7QUFFM0IsZUFBTztBQUFBLFVBQ0gsT0FBTztBQUFBLFVBQ1AsY0FBYyxDQUFDO0FBQUEsVUFDZixhQUFhLENBQUM7QUFBQSxVQUNkLFVBQVU7QUFBQSxVQUNWLGVBQWU7QUFBQSxVQUNmLFdBQVc7QUFBQSxVQUNYLFlBQVk7QUFBQSxVQUNaLGNBQWM7QUFBQSxVQUNkLGVBQWU7QUFBQSxVQUNmLGlCQUFpQjtBQUFBLFVBQ2pCLEtBQUs7QUFBQSxVQUNMLGlCQUFpQixDQUFDO0FBQUEsVUFDbEIsS0FBSztBQUFBLFVBQ0wsVUFBVTtBQUFBLFVBQ1YsU0FBUztBQUFBLFVBQ1QsaUJBQWlCO0FBQUEsUUFDckI7QUFBQSxNQUNKO0FBRUEsZUFBUyxnQkFBZ0IsR0FBRztBQUN4QixZQUFJLEVBQUUsT0FBTyxNQUFNO0FBQ2YsWUFBRSxNQUFNLG9CQUFvQjtBQUFBLFFBQ2hDO0FBQ0EsZUFBTyxFQUFFO0FBQUEsTUFDYjtBQUVBLFVBQUk7QUFDSixVQUFJLE1BQU0sVUFBVSxNQUFNO0FBQ3RCLGVBQU8sTUFBTSxVQUFVO0FBQUEsTUFDM0IsT0FBTztBQUNILGVBQU8sU0FBVSxLQUFLO0FBQ2xCLGNBQUksSUFBSSxPQUFPLElBQUksR0FDZixNQUFNLEVBQUUsV0FBVyxHQUNuQjtBQUVKLGVBQUssSUFBSSxHQUFHLElBQUksS0FBSyxLQUFLO0FBQ3RCLGdCQUFJLEtBQUssS0FBSyxJQUFJLEtBQUssTUFBTSxFQUFFLENBQUMsR0FBRyxHQUFHLENBQUMsR0FBRztBQUN0QyxxQkFBTztBQUFBLFlBQ1g7QUFBQSxVQUNKO0FBRUEsaUJBQU87QUFBQSxRQUNYO0FBQUEsTUFDSjtBQUVBLGVBQVMsUUFBUSxHQUFHO0FBQ2hCLFlBQUksRUFBRSxZQUFZLE1BQU07QUFDcEIsY0FBSSxRQUFRLGdCQUFnQixDQUFDLEdBQ3pCLGNBQWMsS0FBSyxLQUFLLE1BQU0saUJBQWlCLFNBQVUsR0FBRztBQUN4RCxtQkFBTyxLQUFLO0FBQUEsVUFDaEIsQ0FBQyxHQUNELGFBQ0ksQ0FBQyxNQUFNLEVBQUUsR0FBRyxRQUFRLENBQUMsS0FDckIsTUFBTSxXQUFXLEtBQ2pCLENBQUMsTUFBTSxTQUNQLENBQUMsTUFBTSxjQUNQLENBQUMsTUFBTSxnQkFDUCxDQUFDLE1BQU0sa0JBQ1AsQ0FBQyxNQUFNLG1CQUNQLENBQUMsTUFBTSxhQUNQLENBQUMsTUFBTSxpQkFDUCxDQUFDLE1BQU0sb0JBQ04sQ0FBQyxNQUFNLFlBQWEsTUFBTSxZQUFZO0FBRS9DLGNBQUksRUFBRSxTQUFTO0FBQ1gseUJBQ0ksY0FDQSxNQUFNLGtCQUFrQixLQUN4QixNQUFNLGFBQWEsV0FBVyxLQUM5QixNQUFNLFlBQVk7QUFBQSxVQUMxQjtBQUVBLGNBQUksT0FBTyxZQUFZLFFBQVEsQ0FBQyxPQUFPLFNBQVMsQ0FBQyxHQUFHO0FBQ2hELGNBQUUsV0FBVztBQUFBLFVBQ2pCLE9BQU87QUFDSCxtQkFBTztBQUFBLFVBQ1g7QUFBQSxRQUNKO0FBQ0EsZUFBTyxFQUFFO0FBQUEsTUFDYjtBQUVBLGVBQVMsY0FBYyxPQUFPO0FBQzFCLFlBQUksSUFBSSxVQUFVLEdBQUc7QUFDckIsWUFBSSxTQUFTLE1BQU07QUFDZixpQkFBTyxnQkFBZ0IsQ0FBQyxHQUFHLEtBQUs7QUFBQSxRQUNwQyxPQUFPO0FBQ0gsMEJBQWdCLENBQUMsRUFBRSxrQkFBa0I7QUFBQSxRQUN6QztBQUVBLGVBQU87QUFBQSxNQUNYO0FBSUEsVUFBSSxtQkFBb0IsTUFBTSxtQkFBbUIsQ0FBQyxHQUM5QyxtQkFBbUI7QUFFdkIsZUFBUyxXQUFXQyxLQUFJQyxPQUFNO0FBQzFCLFlBQUksR0FBRyxNQUFNO0FBRWIsWUFBSSxDQUFDLFlBQVlBLE1BQUssZ0JBQWdCLEdBQUc7QUFDckMsVUFBQUQsSUFBRyxtQkFBbUJDLE1BQUs7QUFBQSxRQUMvQjtBQUNBLFlBQUksQ0FBQyxZQUFZQSxNQUFLLEVBQUUsR0FBRztBQUN2QixVQUFBRCxJQUFHLEtBQUtDLE1BQUs7QUFBQSxRQUNqQjtBQUNBLFlBQUksQ0FBQyxZQUFZQSxNQUFLLEVBQUUsR0FBRztBQUN2QixVQUFBRCxJQUFHLEtBQUtDLE1BQUs7QUFBQSxRQUNqQjtBQUNBLFlBQUksQ0FBQyxZQUFZQSxNQUFLLEVBQUUsR0FBRztBQUN2QixVQUFBRCxJQUFHLEtBQUtDLE1BQUs7QUFBQSxRQUNqQjtBQUNBLFlBQUksQ0FBQyxZQUFZQSxNQUFLLE9BQU8sR0FBRztBQUM1QixVQUFBRCxJQUFHLFVBQVVDLE1BQUs7QUFBQSxRQUN0QjtBQUNBLFlBQUksQ0FBQyxZQUFZQSxNQUFLLElBQUksR0FBRztBQUN6QixVQUFBRCxJQUFHLE9BQU9DLE1BQUs7QUFBQSxRQUNuQjtBQUNBLFlBQUksQ0FBQyxZQUFZQSxNQUFLLE1BQU0sR0FBRztBQUMzQixVQUFBRCxJQUFHLFNBQVNDLE1BQUs7QUFBQSxRQUNyQjtBQUNBLFlBQUksQ0FBQyxZQUFZQSxNQUFLLE9BQU8sR0FBRztBQUM1QixVQUFBRCxJQUFHLFVBQVVDLE1BQUs7QUFBQSxRQUN0QjtBQUNBLFlBQUksQ0FBQyxZQUFZQSxNQUFLLEdBQUcsR0FBRztBQUN4QixVQUFBRCxJQUFHLE1BQU0sZ0JBQWdCQyxLQUFJO0FBQUEsUUFDakM7QUFDQSxZQUFJLENBQUMsWUFBWUEsTUFBSyxPQUFPLEdBQUc7QUFDNUIsVUFBQUQsSUFBRyxVQUFVQyxNQUFLO0FBQUEsUUFDdEI7QUFFQSxZQUFJLGlCQUFpQixTQUFTLEdBQUc7QUFDN0IsZUFBSyxJQUFJLEdBQUcsSUFBSSxpQkFBaUIsUUFBUSxLQUFLO0FBQzFDLG1CQUFPLGlCQUFpQixDQUFDO0FBQ3pCLGtCQUFNQSxNQUFLLElBQUk7QUFDZixnQkFBSSxDQUFDLFlBQVksR0FBRyxHQUFHO0FBQ25CLGNBQUFELElBQUcsSUFBSSxJQUFJO0FBQUEsWUFDZjtBQUFBLFVBQ0o7QUFBQSxRQUNKO0FBRUEsZUFBT0E7QUFBQSxNQUNYO0FBR0EsZUFBUyxPQUFPLFFBQVE7QUFDcEIsbUJBQVcsTUFBTSxNQUFNO0FBQ3ZCLGFBQUssS0FBSyxJQUFJLEtBQUssT0FBTyxNQUFNLE9BQU8sT0FBTyxHQUFHLFFBQVEsSUFBSSxHQUFHO0FBQ2hFLFlBQUksQ0FBQyxLQUFLLFFBQVEsR0FBRztBQUNqQixlQUFLLEtBQUssSUFBSSxLQUFLLEdBQUc7QUFBQSxRQUMxQjtBQUdBLFlBQUkscUJBQXFCLE9BQU87QUFDNUIsNkJBQW1CO0FBQ25CLGdCQUFNLGFBQWEsSUFBSTtBQUN2Qiw2QkFBbUI7QUFBQSxRQUN2QjtBQUFBLE1BQ0o7QUFFQSxlQUFTLFNBQVMsS0FBSztBQUNuQixlQUNJLGVBQWUsVUFBVyxPQUFPLFFBQVEsSUFBSSxvQkFBb0I7QUFBQSxNQUV6RTtBQUVBLGVBQVNFLE1BQUssS0FBSztBQUNmLFlBQ0ksTUFBTSxnQ0FBZ0MsU0FDdEMsT0FBTyxZQUFZLGVBQ25CLFFBQVEsTUFDVjtBQUNFLGtCQUFRLEtBQUssMEJBQTBCLEdBQUc7QUFBQSxRQUM5QztBQUFBLE1BQ0o7QUFFQSxlQUFTLFVBQVUsS0FBSyxJQUFJO0FBQ3hCLFlBQUksWUFBWTtBQUVoQixlQUFPLE9BQU8sV0FBWTtBQUN0QixjQUFJLE1BQU0sc0JBQXNCLE1BQU07QUFDbEMsa0JBQU0sbUJBQW1CLE1BQU0sR0FBRztBQUFBLFVBQ3RDO0FBQ0EsY0FBSSxXQUFXO0FBQ1gsZ0JBQUksT0FBTyxDQUFDLEdBQ1IsS0FDQSxHQUNBO0FBQ0osaUJBQUssSUFBSSxHQUFHLElBQUksVUFBVSxRQUFRLEtBQUs7QUFDbkMsb0JBQU07QUFDTixrQkFBSSxPQUFPLFVBQVUsQ0FBQyxNQUFNLFVBQVU7QUFDbEMsdUJBQU8sUUFBUSxJQUFJO0FBQ25CLHFCQUFLLE9BQU8sVUFBVSxDQUFDLEdBQUc7QUFDdEIsc0JBQUksV0FBVyxVQUFVLENBQUMsR0FBRyxHQUFHLEdBQUc7QUFDL0IsMkJBQU8sTUFBTSxPQUFPLFVBQVUsQ0FBQyxFQUFFLEdBQUcsSUFBSTtBQUFBLGtCQUM1QztBQUFBLGdCQUNKO0FBQ0Esc0JBQU0sSUFBSSxNQUFNLEdBQUcsRUFBRTtBQUFBLGNBQ3pCLE9BQU87QUFDSCxzQkFBTSxVQUFVLENBQUM7QUFBQSxjQUNyQjtBQUNBLG1CQUFLLEtBQUssR0FBRztBQUFBLFlBQ2pCO0FBQ0EsWUFBQUE7QUFBQSxjQUNJLE1BQ0ksa0JBQ0EsTUFBTSxVQUFVLE1BQU0sS0FBSyxJQUFJLEVBQUUsS0FBSyxFQUFFLElBQ3hDLE9BQ0EsSUFBSSxNQUFNLEVBQUU7QUFBQSxZQUNwQjtBQUNBLHdCQUFZO0FBQUEsVUFDaEI7QUFDQSxpQkFBTyxHQUFHLE1BQU0sTUFBTSxTQUFTO0FBQUEsUUFDbkMsR0FBRyxFQUFFO0FBQUEsTUFDVDtBQUVBLFVBQUksZUFBZSxDQUFDO0FBRXBCLGVBQVMsZ0JBQWdCLE1BQU0sS0FBSztBQUNoQyxZQUFJLE1BQU0sc0JBQXNCLE1BQU07QUFDbEMsZ0JBQU0sbUJBQW1CLE1BQU0sR0FBRztBQUFBLFFBQ3RDO0FBQ0EsWUFBSSxDQUFDLGFBQWEsSUFBSSxHQUFHO0FBQ3JCLFVBQUFBLE1BQUssR0FBRztBQUNSLHVCQUFhLElBQUksSUFBSTtBQUFBLFFBQ3pCO0FBQUEsTUFDSjtBQUVBLFlBQU0sOEJBQThCO0FBQ3BDLFlBQU0scUJBQXFCO0FBRTNCLGVBQVMsV0FBVyxPQUFPO0FBQ3ZCLGVBQ0ssT0FBTyxhQUFhLGVBQWUsaUJBQWlCLFlBQ3JELE9BQU8sVUFBVSxTQUFTLEtBQUssS0FBSyxNQUFNO0FBQUEsTUFFbEQ7QUFFQSxlQUFTQyxLQUFJLFFBQVE7QUFDakIsWUFBSSxNQUFNO0FBQ1YsYUFBSyxLQUFLLFFBQVE7QUFDZCxjQUFJLFdBQVcsUUFBUSxDQUFDLEdBQUc7QUFDdkIsbUJBQU8sT0FBTyxDQUFDO0FBQ2YsZ0JBQUksV0FBVyxJQUFJLEdBQUc7QUFDbEIsbUJBQUssQ0FBQyxJQUFJO0FBQUEsWUFDZCxPQUFPO0FBQ0gsbUJBQUssTUFBTSxDQUFDLElBQUk7QUFBQSxZQUNwQjtBQUFBLFVBQ0o7QUFBQSxRQUNKO0FBQ0EsYUFBSyxVQUFVO0FBSWYsYUFBSyxpQ0FBaUMsSUFBSTtBQUFBLFdBQ3JDLEtBQUssd0JBQXdCLFVBQVUsS0FBSyxjQUFjLFVBQ3ZELE1BQ0EsVUFBVTtBQUFBLFFBQ2xCO0FBQUEsTUFDSjtBQUVBLGVBQVMsYUFBYSxjQUFjLGFBQWE7QUFDN0MsWUFBSSxNQUFNLE9BQU8sQ0FBQyxHQUFHLFlBQVksR0FDN0I7QUFDSixhQUFLLFFBQVEsYUFBYTtBQUN0QixjQUFJLFdBQVcsYUFBYSxJQUFJLEdBQUc7QUFDL0IsZ0JBQUksU0FBUyxhQUFhLElBQUksQ0FBQyxLQUFLLFNBQVMsWUFBWSxJQUFJLENBQUMsR0FBRztBQUM3RCxrQkFBSSxJQUFJLElBQUksQ0FBQztBQUNiLHFCQUFPLElBQUksSUFBSSxHQUFHLGFBQWEsSUFBSSxDQUFDO0FBQ3BDLHFCQUFPLElBQUksSUFBSSxHQUFHLFlBQVksSUFBSSxDQUFDO0FBQUEsWUFDdkMsV0FBVyxZQUFZLElBQUksS0FBSyxNQUFNO0FBQ2xDLGtCQUFJLElBQUksSUFBSSxZQUFZLElBQUk7QUFBQSxZQUNoQyxPQUFPO0FBQ0gscUJBQU8sSUFBSSxJQUFJO0FBQUEsWUFDbkI7QUFBQSxVQUNKO0FBQUEsUUFDSjtBQUNBLGFBQUssUUFBUSxjQUFjO0FBQ3ZCLGNBQ0ksV0FBVyxjQUFjLElBQUksS0FDN0IsQ0FBQyxXQUFXLGFBQWEsSUFBSSxLQUM3QixTQUFTLGFBQWEsSUFBSSxDQUFDLEdBQzdCO0FBRUUsZ0JBQUksSUFBSSxJQUFJLE9BQU8sQ0FBQyxHQUFHLElBQUksSUFBSSxDQUFDO0FBQUEsVUFDcEM7QUFBQSxRQUNKO0FBQ0EsZUFBTztBQUFBLE1BQ1g7QUFFQSxlQUFTLE9BQU8sUUFBUTtBQUNwQixZQUFJLFVBQVUsTUFBTTtBQUNoQixlQUFLLElBQUksTUFBTTtBQUFBLFFBQ25CO0FBQUEsTUFDSjtBQUVBLFVBQUk7QUFFSixVQUFJLE9BQU8sTUFBTTtBQUNiLGVBQU8sT0FBTztBQUFBLE1BQ2xCLE9BQU87QUFDSCxlQUFPLFNBQVUsS0FBSztBQUNsQixjQUFJLEdBQ0EsTUFBTSxDQUFDO0FBQ1gsZUFBSyxLQUFLLEtBQUs7QUFDWCxnQkFBSSxXQUFXLEtBQUssQ0FBQyxHQUFHO0FBQ3BCLGtCQUFJLEtBQUssQ0FBQztBQUFBLFlBQ2Q7QUFBQSxVQUNKO0FBQ0EsaUJBQU87QUFBQSxRQUNYO0FBQUEsTUFDSjtBQUVBLFVBQUksa0JBQWtCO0FBQUEsUUFDbEIsU0FBUztBQUFBLFFBQ1QsU0FBUztBQUFBLFFBQ1QsVUFBVTtBQUFBLFFBQ1YsU0FBUztBQUFBLFFBQ1QsVUFBVTtBQUFBLFFBQ1YsVUFBVTtBQUFBLE1BQ2Q7QUFFQSxlQUFTLFNBQVMsS0FBSyxLQUFLQyxNQUFLO0FBQzdCLFlBQUksU0FBUyxLQUFLLFVBQVUsR0FBRyxLQUFLLEtBQUssVUFBVSxVQUFVO0FBQzdELGVBQU8sV0FBVyxNQUFNLElBQUksT0FBTyxLQUFLLEtBQUtBLElBQUcsSUFBSTtBQUFBLE1BQ3hEO0FBRUEsZUFBUyxTQUFTLFFBQVEsY0FBYyxXQUFXO0FBQy9DLFlBQUksWUFBWSxLQUFLLEtBQUssSUFBSSxNQUFNLEdBQ2hDLGNBQWMsZUFBZSxVQUFVLFFBQ3ZDQyxRQUFPLFVBQVU7QUFDckIsZ0JBQ0tBLFFBQVEsWUFBWSxNQUFNLEtBQU0sT0FDakMsS0FBSyxJQUFJLElBQUksS0FBSyxJQUFJLEdBQUcsV0FBVyxDQUFDLEVBQUUsU0FBUyxFQUFFLE9BQU8sQ0FBQyxJQUMxRDtBQUFBLE1BRVI7QUFFQSxVQUFJLG1CQUFtQiwwTUFDbkIsd0JBQXdCLDhDQUN4QixrQkFBa0IsQ0FBQyxHQUNuQix1QkFBdUIsQ0FBQztBQU01QixlQUFTLGVBQWVDLFFBQU8sUUFBUUMsVUFBUyxVQUFVO0FBQ3RELFlBQUksT0FBTztBQUNYLFlBQUksT0FBTyxhQUFhLFVBQVU7QUFDOUIsaUJBQU8sV0FBWTtBQUNmLG1CQUFPLEtBQUssUUFBUSxFQUFFO0FBQUEsVUFDMUI7QUFBQSxRQUNKO0FBQ0EsWUFBSUQsUUFBTztBQUNQLCtCQUFxQkEsTUFBSyxJQUFJO0FBQUEsUUFDbEM7QUFDQSxZQUFJLFFBQVE7QUFDUiwrQkFBcUIsT0FBTyxDQUFDLENBQUMsSUFBSSxXQUFZO0FBQzFDLG1CQUFPLFNBQVMsS0FBSyxNQUFNLE1BQU0sU0FBUyxHQUFHLE9BQU8sQ0FBQyxHQUFHLE9BQU8sQ0FBQyxDQUFDO0FBQUEsVUFDckU7QUFBQSxRQUNKO0FBQ0EsWUFBSUMsVUFBUztBQUNULCtCQUFxQkEsUUFBTyxJQUFJLFdBQVk7QUFDeEMsbUJBQU8sS0FBSyxXQUFXLEVBQUU7QUFBQSxjQUNyQixLQUFLLE1BQU0sTUFBTSxTQUFTO0FBQUEsY0FDMUJEO0FBQUEsWUFDSjtBQUFBLFVBQ0o7QUFBQSxRQUNKO0FBQUEsTUFDSjtBQUVBLGVBQVMsdUJBQXVCLE9BQU87QUFDbkMsWUFBSSxNQUFNLE1BQU0sVUFBVSxHQUFHO0FBQ3pCLGlCQUFPLE1BQU0sUUFBUSxZQUFZLEVBQUU7QUFBQSxRQUN2QztBQUNBLGVBQU8sTUFBTSxRQUFRLE9BQU8sRUFBRTtBQUFBLE1BQ2xDO0FBRUEsZUFBUyxtQkFBbUJSLFNBQVE7QUFDaEMsWUFBSSxRQUFRQSxRQUFPLE1BQU0sZ0JBQWdCLEdBQ3JDLEdBQ0E7QUFFSixhQUFLLElBQUksR0FBRyxTQUFTLE1BQU0sUUFBUSxJQUFJLFFBQVEsS0FBSztBQUNoRCxjQUFJLHFCQUFxQixNQUFNLENBQUMsQ0FBQyxHQUFHO0FBQ2hDLGtCQUFNLENBQUMsSUFBSSxxQkFBcUIsTUFBTSxDQUFDLENBQUM7QUFBQSxVQUM1QyxPQUFPO0FBQ0gsa0JBQU0sQ0FBQyxJQUFJLHVCQUF1QixNQUFNLENBQUMsQ0FBQztBQUFBLFVBQzlDO0FBQUEsUUFDSjtBQUVBLGVBQU8sU0FBVSxLQUFLO0FBQ2xCLGNBQUksU0FBUyxJQUNUVTtBQUNKLGVBQUtBLEtBQUksR0FBR0EsS0FBSSxRQUFRQSxNQUFLO0FBQ3pCLHNCQUFVLFdBQVcsTUFBTUEsRUFBQyxDQUFDLElBQ3ZCLE1BQU1BLEVBQUMsRUFBRSxLQUFLLEtBQUtWLE9BQU0sSUFDekIsTUFBTVUsRUFBQztBQUFBLFVBQ2pCO0FBQ0EsaUJBQU87QUFBQSxRQUNYO0FBQUEsTUFDSjtBQUdBLGVBQVMsYUFBYSxHQUFHVixTQUFRO0FBQzdCLFlBQUksQ0FBQyxFQUFFLFFBQVEsR0FBRztBQUNkLGlCQUFPLEVBQUUsV0FBVyxFQUFFLFlBQVk7QUFBQSxRQUN0QztBQUVBLFFBQUFBLFVBQVMsYUFBYUEsU0FBUSxFQUFFLFdBQVcsQ0FBQztBQUM1Qyx3QkFBZ0JBLE9BQU0sSUFDbEIsZ0JBQWdCQSxPQUFNLEtBQUssbUJBQW1CQSxPQUFNO0FBRXhELGVBQU8sZ0JBQWdCQSxPQUFNLEVBQUUsQ0FBQztBQUFBLE1BQ3BDO0FBRUEsZUFBUyxhQUFhQSxTQUFRQyxTQUFRO0FBQ2xDLFlBQUksSUFBSTtBQUVSLGlCQUFTLDRCQUE0QixPQUFPO0FBQ3hDLGlCQUFPQSxRQUFPLGVBQWUsS0FBSyxLQUFLO0FBQUEsUUFDM0M7QUFFQSw4QkFBc0IsWUFBWTtBQUNsQyxlQUFPLEtBQUssS0FBSyxzQkFBc0IsS0FBS0QsT0FBTSxHQUFHO0FBQ2pELFVBQUFBLFVBQVNBLFFBQU87QUFBQSxZQUNaO0FBQUEsWUFDQTtBQUFBLFVBQ0o7QUFDQSxnQ0FBc0IsWUFBWTtBQUNsQyxlQUFLO0FBQUEsUUFDVDtBQUVBLGVBQU9BO0FBQUEsTUFDWDtBQUVBLFVBQUksd0JBQXdCO0FBQUEsUUFDeEIsS0FBSztBQUFBLFFBQ0wsSUFBSTtBQUFBLFFBQ0osR0FBRztBQUFBLFFBQ0gsSUFBSTtBQUFBLFFBQ0osS0FBSztBQUFBLFFBQ0wsTUFBTTtBQUFBLE1BQ1Y7QUFFQSxlQUFTLGVBQWUsS0FBSztBQUN6QixZQUFJQSxVQUFTLEtBQUssZ0JBQWdCLEdBQUcsR0FDakMsY0FBYyxLQUFLLGdCQUFnQixJQUFJLFlBQVksQ0FBQztBQUV4RCxZQUFJQSxXQUFVLENBQUMsYUFBYTtBQUN4QixpQkFBT0E7QUFBQSxRQUNYO0FBRUEsYUFBSyxnQkFBZ0IsR0FBRyxJQUFJLFlBQ3ZCLE1BQU0sZ0JBQWdCLEVBQ3RCLElBQUksU0FBVSxLQUFLO0FBQ2hCLGNBQ0ksUUFBUSxVQUNSLFFBQVEsUUFDUixRQUFRLFFBQ1IsUUFBUSxRQUNWO0FBQ0UsbUJBQU8sSUFBSSxNQUFNLENBQUM7QUFBQSxVQUN0QjtBQUNBLGlCQUFPO0FBQUEsUUFDWCxDQUFDLEVBQ0EsS0FBSyxFQUFFO0FBRVosZUFBTyxLQUFLLGdCQUFnQixHQUFHO0FBQUEsTUFDbkM7QUFFQSxVQUFJLHFCQUFxQjtBQUV6QixlQUFTLGNBQWM7QUFDbkIsZUFBTyxLQUFLO0FBQUEsTUFDaEI7QUFFQSxVQUFJLGlCQUFpQixNQUNqQixnQ0FBZ0M7QUFFcEMsZUFBUyxRQUFRLFFBQVE7QUFDckIsZUFBTyxLQUFLLFNBQVMsUUFBUSxNQUFNLE1BQU07QUFBQSxNQUM3QztBQUVBLFVBQUksc0JBQXNCO0FBQUEsUUFDdEIsUUFBUTtBQUFBLFFBQ1IsTUFBTTtBQUFBLFFBQ04sR0FBRztBQUFBLFFBQ0gsSUFBSTtBQUFBLFFBQ0osR0FBRztBQUFBLFFBQ0gsSUFBSTtBQUFBLFFBQ0osR0FBRztBQUFBLFFBQ0gsSUFBSTtBQUFBLFFBQ0osR0FBRztBQUFBLFFBQ0gsSUFBSTtBQUFBLFFBQ0osR0FBRztBQUFBLFFBQ0gsSUFBSTtBQUFBLFFBQ0osR0FBRztBQUFBLFFBQ0gsSUFBSTtBQUFBLFFBQ0osR0FBRztBQUFBLFFBQ0gsSUFBSTtBQUFBLE1BQ1I7QUFFQSxlQUFTLGFBQWEsUUFBUSxlQUFlVyxTQUFRLFVBQVU7QUFDM0QsWUFBSSxTQUFTLEtBQUssY0FBY0EsT0FBTTtBQUN0QyxlQUFPLFdBQVcsTUFBTSxJQUNsQixPQUFPLFFBQVEsZUFBZUEsU0FBUSxRQUFRLElBQzlDLE9BQU8sUUFBUSxPQUFPLE1BQU07QUFBQSxNQUN0QztBQUVBLGVBQVMsV0FBV0MsT0FBTSxRQUFRO0FBQzlCLFlBQUlaLFVBQVMsS0FBSyxjQUFjWSxRQUFPLElBQUksV0FBVyxNQUFNO0FBQzVELGVBQU8sV0FBV1osT0FBTSxJQUFJQSxRQUFPLE1BQU0sSUFBSUEsUUFBTyxRQUFRLE9BQU8sTUFBTTtBQUFBLE1BQzdFO0FBRUEsVUFBSSxVQUFVLENBQUM7QUFFZixlQUFTLGFBQWEsTUFBTSxXQUFXO0FBQ25DLFlBQUksWUFBWSxLQUFLLFlBQVk7QUFDakMsZ0JBQVEsU0FBUyxJQUFJLFFBQVEsWUFBWSxHQUFHLElBQUksUUFBUSxTQUFTLElBQUk7QUFBQSxNQUN6RTtBQUVBLGVBQVMsZUFBZSxPQUFPO0FBQzNCLGVBQU8sT0FBTyxVQUFVLFdBQ2xCLFFBQVEsS0FBSyxLQUFLLFFBQVEsTUFBTSxZQUFZLENBQUMsSUFDN0M7QUFBQSxNQUNWO0FBRUEsZUFBUyxxQkFBcUIsYUFBYTtBQUN2QyxZQUFJLGtCQUFrQixDQUFDLEdBQ25CLGdCQUNBO0FBRUosYUFBSyxRQUFRLGFBQWE7QUFDdEIsY0FBSSxXQUFXLGFBQWEsSUFBSSxHQUFHO0FBQy9CLDZCQUFpQixlQUFlLElBQUk7QUFDcEMsZ0JBQUksZ0JBQWdCO0FBQ2hCLDhCQUFnQixjQUFjLElBQUksWUFBWSxJQUFJO0FBQUEsWUFDdEQ7QUFBQSxVQUNKO0FBQUEsUUFDSjtBQUVBLGVBQU87QUFBQSxNQUNYO0FBRUEsVUFBSSxhQUFhLENBQUM7QUFFbEIsZUFBUyxnQkFBZ0IsTUFBTSxVQUFVO0FBQ3JDLG1CQUFXLElBQUksSUFBSTtBQUFBLE1BQ3ZCO0FBRUEsZUFBUyxvQkFBb0IsVUFBVTtBQUNuQyxZQUFJLFFBQVEsQ0FBQyxHQUNUO0FBQ0osYUFBSyxLQUFLLFVBQVU7QUFDaEIsY0FBSSxXQUFXLFVBQVUsQ0FBQyxHQUFHO0FBQ3pCLGtCQUFNLEtBQUssRUFBRSxNQUFNLEdBQUcsVUFBVSxXQUFXLENBQUMsRUFBRSxDQUFDO0FBQUEsVUFDbkQ7QUFBQSxRQUNKO0FBQ0EsY0FBTSxLQUFLLFNBQVUsR0FBRyxHQUFHO0FBQ3ZCLGlCQUFPLEVBQUUsV0FBVyxFQUFFO0FBQUEsUUFDMUIsQ0FBQztBQUNELGVBQU87QUFBQSxNQUNYO0FBRUEsZUFBUyxXQUFXLE1BQU07QUFDdEIsZUFBUSxPQUFPLE1BQU0sS0FBSyxPQUFPLFFBQVEsS0FBTSxPQUFPLFFBQVE7QUFBQSxNQUNsRTtBQUVBLGVBQVMsU0FBUyxRQUFRO0FBQ3RCLFlBQUksU0FBUyxHQUFHO0FBRVosaUJBQU8sS0FBSyxLQUFLLE1BQU0sS0FBSztBQUFBLFFBQ2hDLE9BQU87QUFDSCxpQkFBTyxLQUFLLE1BQU0sTUFBTTtBQUFBLFFBQzVCO0FBQUEsTUFDSjtBQUVBLGVBQVMsTUFBTSxxQkFBcUI7QUFDaEMsWUFBSSxnQkFBZ0IsQ0FBQyxxQkFDakIsUUFBUTtBQUVaLFlBQUksa0JBQWtCLEtBQUssU0FBUyxhQUFhLEdBQUc7QUFDaEQsa0JBQVEsU0FBUyxhQUFhO0FBQUEsUUFDbEM7QUFFQSxlQUFPO0FBQUEsTUFDWDtBQUVBLGVBQVMsV0FBVyxNQUFNLFVBQVU7QUFDaEMsZUFBTyxTQUFVLE9BQU87QUFDcEIsY0FBSSxTQUFTLE1BQU07QUFDZixrQkFBTSxNQUFNLE1BQU0sS0FBSztBQUN2QixrQkFBTSxhQUFhLE1BQU0sUUFBUTtBQUNqQyxtQkFBTztBQUFBLFVBQ1gsT0FBTztBQUNILG1CQUFPLElBQUksTUFBTSxJQUFJO0FBQUEsVUFDekI7QUFBQSxRQUNKO0FBQUEsTUFDSjtBQUVBLGVBQVMsSUFBSSxLQUFLLE1BQU07QUFDcEIsZUFBTyxJQUFJLFFBQVEsSUFDYixJQUFJLEdBQUcsU0FBUyxJQUFJLFNBQVMsUUFBUSxNQUFNLElBQUksRUFBRSxJQUNqRDtBQUFBLE1BQ1Y7QUFFQSxlQUFTLE1BQU0sS0FBSyxNQUFNLE9BQU87QUFDN0IsWUFBSSxJQUFJLFFBQVEsS0FBSyxDQUFDLE1BQU0sS0FBSyxHQUFHO0FBQ2hDLGNBQ0ksU0FBUyxjQUNULFdBQVcsSUFBSSxLQUFLLENBQUMsS0FDckIsSUFBSSxNQUFNLE1BQU0sS0FDaEIsSUFBSSxLQUFLLE1BQU0sSUFDakI7QUFDRSxvQkFBUSxNQUFNLEtBQUs7QUFDbkIsZ0JBQUksR0FBRyxTQUFTLElBQUksU0FBUyxRQUFRLE1BQU0sSUFBSTtBQUFBLGNBQzNDO0FBQUEsY0FDQSxJQUFJLE1BQU07QUFBQSxjQUNWLFlBQVksT0FBTyxJQUFJLE1BQU0sQ0FBQztBQUFBLFlBQ2xDO0FBQUEsVUFDSixPQUFPO0FBQ0gsZ0JBQUksR0FBRyxTQUFTLElBQUksU0FBUyxRQUFRLE1BQU0sSUFBSSxFQUFFLEtBQUs7QUFBQSxVQUMxRDtBQUFBLFFBQ0o7QUFBQSxNQUNKO0FBSUEsZUFBUyxVQUFVLE9BQU87QUFDdEIsZ0JBQVEsZUFBZSxLQUFLO0FBQzVCLFlBQUksV0FBVyxLQUFLLEtBQUssQ0FBQyxHQUFHO0FBQ3pCLGlCQUFPLEtBQUssS0FBSyxFQUFFO0FBQUEsUUFDdkI7QUFDQSxlQUFPO0FBQUEsTUFDWDtBQUVBLGVBQVMsVUFBVSxPQUFPLE9BQU87QUFDN0IsWUFBSSxPQUFPLFVBQVUsVUFBVTtBQUMzQixrQkFBUSxxQkFBcUIsS0FBSztBQUNsQyxjQUFJLGNBQWMsb0JBQW9CLEtBQUssR0FDdkM7QUFDSixlQUFLLElBQUksR0FBRyxJQUFJLFlBQVksUUFBUSxLQUFLO0FBQ3JDLGlCQUFLLFlBQVksQ0FBQyxFQUFFLElBQUksRUFBRSxNQUFNLFlBQVksQ0FBQyxFQUFFLElBQUksQ0FBQztBQUFBLFVBQ3hEO0FBQUEsUUFDSixPQUFPO0FBQ0gsa0JBQVEsZUFBZSxLQUFLO0FBQzVCLGNBQUksV0FBVyxLQUFLLEtBQUssQ0FBQyxHQUFHO0FBQ3pCLG1CQUFPLEtBQUssS0FBSyxFQUFFLEtBQUs7QUFBQSxVQUM1QjtBQUFBLFFBQ0o7QUFDQSxlQUFPO0FBQUEsTUFDWDtBQUVBLFVBQUksU0FBUyxNQUNULFNBQVMsUUFDVCxTQUFTLFNBQ1QsU0FBUyxTQUNULFNBQVMsY0FDVCxZQUFZLFNBQ1osWUFBWSxhQUNaLFlBQVksaUJBQ1osWUFBWSxXQUNaLFlBQVksV0FDWixZQUFZLGdCQUNaLGdCQUFnQixPQUNoQixjQUFjLFlBQ2QsY0FBYyxzQkFDZCxtQkFBbUIsMkJBQ25CLGlCQUFpQix3QkFHakIsWUFBWSx5SkFDWjtBQUVKLGdCQUFVLENBQUM7QUFFWCxlQUFTLGNBQWNRLFFBQU8sT0FBTyxhQUFhO0FBQzlDLGdCQUFRQSxNQUFLLElBQUksV0FBVyxLQUFLLElBQzNCLFFBQ0EsU0FBVSxVQUFVSyxhQUFZO0FBQzVCLGlCQUFPLFlBQVksY0FBYyxjQUFjO0FBQUEsUUFDbkQ7QUFBQSxNQUNWO0FBRUEsZUFBUyxzQkFBc0JMLFFBQU8sUUFBUTtBQUMxQyxZQUFJLENBQUMsV0FBVyxTQUFTQSxNQUFLLEdBQUc7QUFDN0IsaUJBQU8sSUFBSSxPQUFPLGVBQWVBLE1BQUssQ0FBQztBQUFBLFFBQzNDO0FBRUEsZUFBTyxRQUFRQSxNQUFLLEVBQUUsT0FBTyxTQUFTLE9BQU8sT0FBTztBQUFBLE1BQ3hEO0FBR0EsZUFBUyxlQUFlLEdBQUc7QUFDdkIsZUFBTztBQUFBLFVBQ0gsRUFDSyxRQUFRLE1BQU0sRUFBRSxFQUNoQixRQUFRLHVDQUF1QyxTQUM1QyxTQUNBLElBQ0EsSUFDQSxJQUNBLElBQ0Y7QUFDRSxtQkFBTyxNQUFNLE1BQU0sTUFBTTtBQUFBLFVBQzdCLENBQUM7QUFBQSxRQUNUO0FBQUEsTUFDSjtBQUVBLGVBQVMsWUFBWSxHQUFHO0FBQ3BCLGVBQU8sRUFBRSxRQUFRLDBCQUEwQixNQUFNO0FBQUEsTUFDckQ7QUFFQSxVQUFJLFNBQVMsQ0FBQztBQUVkLGVBQVMsY0FBY0EsUUFBTyxVQUFVO0FBQ3BDLFlBQUksR0FDQSxPQUFPO0FBQ1gsWUFBSSxPQUFPQSxXQUFVLFVBQVU7QUFDM0IsVUFBQUEsU0FBUSxDQUFDQSxNQUFLO0FBQUEsUUFDbEI7QUFDQSxZQUFJLFNBQVMsUUFBUSxHQUFHO0FBQ3BCLGlCQUFPLFNBQVUsT0FBTyxPQUFPO0FBQzNCLGtCQUFNLFFBQVEsSUFBSSxNQUFNLEtBQUs7QUFBQSxVQUNqQztBQUFBLFFBQ0o7QUFDQSxhQUFLLElBQUksR0FBRyxJQUFJQSxPQUFNLFFBQVEsS0FBSztBQUMvQixpQkFBT0EsT0FBTSxDQUFDLENBQUMsSUFBSTtBQUFBLFFBQ3ZCO0FBQUEsTUFDSjtBQUVBLGVBQVMsa0JBQWtCQSxRQUFPLFVBQVU7QUFDeEMsc0JBQWNBLFFBQU8sU0FBVSxPQUFPLE9BQU8sUUFBUUEsUUFBTztBQUN4RCxpQkFBTyxLQUFLLE9BQU8sTUFBTSxDQUFDO0FBQzFCLG1CQUFTLE9BQU8sT0FBTyxJQUFJLFFBQVFBLE1BQUs7QUFBQSxRQUM1QyxDQUFDO0FBQUEsTUFDTDtBQUVBLGVBQVMsd0JBQXdCQSxRQUFPLE9BQU8sUUFBUTtBQUNuRCxZQUFJLFNBQVMsUUFBUSxXQUFXLFFBQVFBLE1BQUssR0FBRztBQUM1QyxpQkFBT0EsTUFBSyxFQUFFLE9BQU8sT0FBTyxJQUFJLFFBQVFBLE1BQUs7QUFBQSxRQUNqRDtBQUFBLE1BQ0o7QUFFQSxVQUFJLE9BQU8sR0FDUCxRQUFRLEdBQ1IsT0FBTyxHQUNQLE9BQU8sR0FDUCxTQUFTLEdBQ1QsU0FBUyxHQUNULGNBQWMsR0FDZCxPQUFPLEdBQ1AsVUFBVTtBQUVkLGVBQVMsSUFBSSxHQUFHLEdBQUc7QUFDZixnQkFBUyxJQUFJLElBQUssS0FBSztBQUFBLE1BQzNCO0FBRUEsVUFBSTtBQUVKLFVBQUksTUFBTSxVQUFVLFNBQVM7QUFDekIsa0JBQVUsTUFBTSxVQUFVO0FBQUEsTUFDOUIsT0FBTztBQUNILGtCQUFVLFNBQVUsR0FBRztBQUVuQixjQUFJO0FBQ0osZUFBSyxJQUFJLEdBQUcsSUFBSSxLQUFLLFFBQVEsRUFBRSxHQUFHO0FBQzlCLGdCQUFJLEtBQUssQ0FBQyxNQUFNLEdBQUc7QUFDZixxQkFBTztBQUFBLFlBQ1g7QUFBQSxVQUNKO0FBQ0EsaUJBQU87QUFBQSxRQUNYO0FBQUEsTUFDSjtBQUVBLGVBQVMsWUFBWSxNQUFNLE9BQU87QUFDOUIsWUFBSSxNQUFNLElBQUksS0FBSyxNQUFNLEtBQUssR0FBRztBQUM3QixpQkFBTztBQUFBLFFBQ1g7QUFDQSxZQUFJLFdBQVcsSUFBSSxPQUFPLEVBQUU7QUFDNUIsaUJBQVMsUUFBUSxZQUFZO0FBQzdCLGVBQU8sYUFBYSxJQUNkLFdBQVcsSUFBSSxJQUNYLEtBQ0EsS0FDSixLQUFPLFdBQVcsSUFBSztBQUFBLE1BQ2pDO0FBSUEscUJBQWUsS0FBSyxDQUFDLE1BQU0sQ0FBQyxHQUFHLE1BQU0sV0FBWTtBQUM3QyxlQUFPLEtBQUssTUFBTSxJQUFJO0FBQUEsTUFDMUIsQ0FBQztBQUVELHFCQUFlLE9BQU8sR0FBRyxHQUFHLFNBQVVSLFNBQVE7QUFDMUMsZUFBTyxLQUFLLFdBQVcsRUFBRSxZQUFZLE1BQU1BLE9BQU07QUFBQSxNQUNyRCxDQUFDO0FBRUQscUJBQWUsUUFBUSxHQUFHLEdBQUcsU0FBVUEsU0FBUTtBQUMzQyxlQUFPLEtBQUssV0FBVyxFQUFFLE9BQU8sTUFBTUEsT0FBTTtBQUFBLE1BQ2hELENBQUM7QUFJRCxtQkFBYSxTQUFTLEdBQUc7QUFJekIsc0JBQWdCLFNBQVMsQ0FBQztBQUkxQixvQkFBYyxLQUFLLFNBQVM7QUFDNUIsb0JBQWMsTUFBTSxXQUFXLE1BQU07QUFDckMsb0JBQWMsT0FBTyxTQUFVLFVBQVVDLFNBQVE7QUFDN0MsZUFBT0EsUUFBTyxpQkFBaUIsUUFBUTtBQUFBLE1BQzNDLENBQUM7QUFDRCxvQkFBYyxRQUFRLFNBQVUsVUFBVUEsU0FBUTtBQUM5QyxlQUFPQSxRQUFPLFlBQVksUUFBUTtBQUFBLE1BQ3RDLENBQUM7QUFFRCxvQkFBYyxDQUFDLEtBQUssSUFBSSxHQUFHLFNBQVUsT0FBTyxPQUFPO0FBQy9DLGNBQU0sS0FBSyxJQUFJLE1BQU0sS0FBSyxJQUFJO0FBQUEsTUFDbEMsQ0FBQztBQUVELG9CQUFjLENBQUMsT0FBTyxNQUFNLEdBQUcsU0FBVSxPQUFPLE9BQU8sUUFBUU8sUUFBTztBQUNsRSxZQUFJLFFBQVEsT0FBTyxRQUFRLFlBQVksT0FBT0EsUUFBTyxPQUFPLE9BQU87QUFFbkUsWUFBSSxTQUFTLE1BQU07QUFDZixnQkFBTSxLQUFLLElBQUk7QUFBQSxRQUNuQixPQUFPO0FBQ0gsMEJBQWdCLE1BQU0sRUFBRSxlQUFlO0FBQUEsUUFDM0M7QUFBQSxNQUNKLENBQUM7QUFJRCxVQUFJLHNCQUFzQix3RkFBd0Y7QUFBQSxRQUMxRztBQUFBLE1BQ0osR0FDQSwyQkFBMkIsa0RBQWtEO0FBQUEsUUFDekU7QUFBQSxNQUNKLEdBQ0EsbUJBQW1CLGlDQUNuQiwwQkFBMEIsV0FDMUIscUJBQXFCO0FBRXpCLGVBQVMsYUFBYSxHQUFHUixTQUFRO0FBQzdCLFlBQUksQ0FBQyxHQUFHO0FBQ0osaUJBQU8sUUFBUSxLQUFLLE9BQU8sSUFDckIsS0FBSyxVQUNMLEtBQUssUUFBUSxZQUFZO0FBQUEsUUFDbkM7QUFDQSxlQUFPLFFBQVEsS0FBSyxPQUFPLElBQ3JCLEtBQUssUUFBUSxFQUFFLE1BQU0sQ0FBQyxJQUN0QixLQUFLLFNBQ0EsS0FBSyxRQUFRLFlBQVksa0JBQWtCLEtBQUtBLE9BQU0sSUFDakQsV0FDQSxZQUNWLEVBQUUsRUFBRSxNQUFNLENBQUM7QUFBQSxNQUNyQjtBQUVBLGVBQVMsa0JBQWtCLEdBQUdBLFNBQVE7QUFDbEMsWUFBSSxDQUFDLEdBQUc7QUFDSixpQkFBTyxRQUFRLEtBQUssWUFBWSxJQUMxQixLQUFLLGVBQ0wsS0FBSyxhQUFhLFlBQVk7QUFBQSxRQUN4QztBQUNBLGVBQU8sUUFBUSxLQUFLLFlBQVksSUFDMUIsS0FBSyxhQUFhLEVBQUUsTUFBTSxDQUFDLElBQzNCLEtBQUssYUFDRCxpQkFBaUIsS0FBS0EsT0FBTSxJQUFJLFdBQVcsWUFDL0MsRUFBRSxFQUFFLE1BQU0sQ0FBQztBQUFBLE1BQ3JCO0FBRUEsZUFBUyxrQkFBa0IsV0FBV0EsU0FBUSxRQUFRO0FBQ2xELFlBQUksR0FDQSxJQUNBLEtBQ0EsTUFBTSxVQUFVLGtCQUFrQjtBQUN0QyxZQUFJLENBQUMsS0FBSyxjQUFjO0FBRXBCLGVBQUssZUFBZSxDQUFDO0FBQ3JCLGVBQUssbUJBQW1CLENBQUM7QUFDekIsZUFBSyxvQkFBb0IsQ0FBQztBQUMxQixlQUFLLElBQUksR0FBRyxJQUFJLElBQUksRUFBRSxHQUFHO0FBQ3JCLGtCQUFNLFVBQVUsQ0FBQyxLQUFNLENBQUMsQ0FBQztBQUN6QixpQkFBSyxrQkFBa0IsQ0FBQyxJQUFJLEtBQUs7QUFBQSxjQUM3QjtBQUFBLGNBQ0E7QUFBQSxZQUNKLEVBQUUsa0JBQWtCO0FBQ3BCLGlCQUFLLGlCQUFpQixDQUFDLElBQUksS0FBSyxPQUFPLEtBQUssRUFBRSxFQUFFLGtCQUFrQjtBQUFBLFVBQ3RFO0FBQUEsUUFDSjtBQUVBLFlBQUksUUFBUTtBQUNSLGNBQUlBLFlBQVcsT0FBTztBQUNsQixpQkFBSyxRQUFRLEtBQUssS0FBSyxtQkFBbUIsR0FBRztBQUM3QyxtQkFBTyxPQUFPLEtBQUssS0FBSztBQUFBLFVBQzVCLE9BQU87QUFDSCxpQkFBSyxRQUFRLEtBQUssS0FBSyxrQkFBa0IsR0FBRztBQUM1QyxtQkFBTyxPQUFPLEtBQUssS0FBSztBQUFBLFVBQzVCO0FBQUEsUUFDSixPQUFPO0FBQ0gsY0FBSUEsWUFBVyxPQUFPO0FBQ2xCLGlCQUFLLFFBQVEsS0FBSyxLQUFLLG1CQUFtQixHQUFHO0FBQzdDLGdCQUFJLE9BQU8sSUFBSTtBQUNYLHFCQUFPO0FBQUEsWUFDWDtBQUNBLGlCQUFLLFFBQVEsS0FBSyxLQUFLLGtCQUFrQixHQUFHO0FBQzVDLG1CQUFPLE9BQU8sS0FBSyxLQUFLO0FBQUEsVUFDNUIsT0FBTztBQUNILGlCQUFLLFFBQVEsS0FBSyxLQUFLLGtCQUFrQixHQUFHO0FBQzVDLGdCQUFJLE9BQU8sSUFBSTtBQUNYLHFCQUFPO0FBQUEsWUFDWDtBQUNBLGlCQUFLLFFBQVEsS0FBSyxLQUFLLG1CQUFtQixHQUFHO0FBQzdDLG1CQUFPLE9BQU8sS0FBSyxLQUFLO0FBQUEsVUFDNUI7QUFBQSxRQUNKO0FBQUEsTUFDSjtBQUVBLGVBQVMsa0JBQWtCLFdBQVdBLFNBQVEsUUFBUTtBQUNsRCxZQUFJLEdBQUcsS0FBSztBQUVaLFlBQUksS0FBSyxtQkFBbUI7QUFDeEIsaUJBQU8sa0JBQWtCLEtBQUssTUFBTSxXQUFXQSxTQUFRLE1BQU07QUFBQSxRQUNqRTtBQUVBLFlBQUksQ0FBQyxLQUFLLGNBQWM7QUFDcEIsZUFBSyxlQUFlLENBQUM7QUFDckIsZUFBSyxtQkFBbUIsQ0FBQztBQUN6QixlQUFLLG9CQUFvQixDQUFDO0FBQUEsUUFDOUI7QUFLQSxhQUFLLElBQUksR0FBRyxJQUFJLElBQUksS0FBSztBQUVyQixnQkFBTSxVQUFVLENBQUMsS0FBTSxDQUFDLENBQUM7QUFDekIsY0FBSSxVQUFVLENBQUMsS0FBSyxpQkFBaUIsQ0FBQyxHQUFHO0FBQ3JDLGlCQUFLLGlCQUFpQixDQUFDLElBQUksSUFBSTtBQUFBLGNBQzNCLE1BQU0sS0FBSyxPQUFPLEtBQUssRUFBRSxFQUFFLFFBQVEsS0FBSyxFQUFFLElBQUk7QUFBQSxjQUM5QztBQUFBLFlBQ0o7QUFDQSxpQkFBSyxrQkFBa0IsQ0FBQyxJQUFJLElBQUk7QUFBQSxjQUM1QixNQUFNLEtBQUssWUFBWSxLQUFLLEVBQUUsRUFBRSxRQUFRLEtBQUssRUFBRSxJQUFJO0FBQUEsY0FDbkQ7QUFBQSxZQUNKO0FBQUEsVUFDSjtBQUNBLGNBQUksQ0FBQyxVQUFVLENBQUMsS0FBSyxhQUFhLENBQUMsR0FBRztBQUNsQyxvQkFDSSxNQUFNLEtBQUssT0FBTyxLQUFLLEVBQUUsSUFBSSxPQUFPLEtBQUssWUFBWSxLQUFLLEVBQUU7QUFDaEUsaUJBQUssYUFBYSxDQUFDLElBQUksSUFBSSxPQUFPLE1BQU0sUUFBUSxLQUFLLEVBQUUsR0FBRyxHQUFHO0FBQUEsVUFDakU7QUFFQSxjQUNJLFVBQ0FBLFlBQVcsVUFDWCxLQUFLLGlCQUFpQixDQUFDLEVBQUUsS0FBSyxTQUFTLEdBQ3pDO0FBQ0UsbUJBQU87QUFBQSxVQUNYLFdBQ0ksVUFDQUEsWUFBVyxTQUNYLEtBQUssa0JBQWtCLENBQUMsRUFBRSxLQUFLLFNBQVMsR0FDMUM7QUFDRSxtQkFBTztBQUFBLFVBQ1gsV0FBVyxDQUFDLFVBQVUsS0FBSyxhQUFhLENBQUMsRUFBRSxLQUFLLFNBQVMsR0FBRztBQUN4RCxtQkFBTztBQUFBLFVBQ1g7QUFBQSxRQUNKO0FBQUEsTUFDSjtBQUlBLGVBQVMsU0FBUyxLQUFLLE9BQU87QUFDMUIsWUFBSTtBQUVKLFlBQUksQ0FBQyxJQUFJLFFBQVEsR0FBRztBQUVoQixpQkFBTztBQUFBLFFBQ1g7QUFFQSxZQUFJLE9BQU8sVUFBVSxVQUFVO0FBQzNCLGNBQUksUUFBUSxLQUFLLEtBQUssR0FBRztBQUNyQixvQkFBUSxNQUFNLEtBQUs7QUFBQSxVQUN2QixPQUFPO0FBQ0gsb0JBQVEsSUFBSSxXQUFXLEVBQUUsWUFBWSxLQUFLO0FBRTFDLGdCQUFJLENBQUMsU0FBUyxLQUFLLEdBQUc7QUFDbEIscUJBQU87QUFBQSxZQUNYO0FBQUEsVUFDSjtBQUFBLFFBQ0o7QUFFQSxxQkFBYSxLQUFLLElBQUksSUFBSSxLQUFLLEdBQUcsWUFBWSxJQUFJLEtBQUssR0FBRyxLQUFLLENBQUM7QUFDaEUsWUFBSSxHQUFHLFNBQVMsSUFBSSxTQUFTLFFBQVEsTUFBTSxPQUFPLEVBQUUsT0FBTyxVQUFVO0FBQ3JFLGVBQU87QUFBQSxNQUNYO0FBRUEsZUFBUyxZQUFZLE9BQU87QUFDeEIsWUFBSSxTQUFTLE1BQU07QUFDZixtQkFBUyxNQUFNLEtBQUs7QUFDcEIsZ0JBQU0sYUFBYSxNQUFNLElBQUk7QUFDN0IsaUJBQU87QUFBQSxRQUNYLE9BQU87QUFDSCxpQkFBTyxJQUFJLE1BQU0sT0FBTztBQUFBLFFBQzVCO0FBQUEsTUFDSjtBQUVBLGVBQVMsaUJBQWlCO0FBQ3RCLGVBQU8sWUFBWSxLQUFLLEtBQUssR0FBRyxLQUFLLE1BQU0sQ0FBQztBQUFBLE1BQ2hEO0FBRUEsZUFBUyxpQkFBaUIsVUFBVTtBQUNoQyxZQUFJLEtBQUssbUJBQW1CO0FBQ3hCLGNBQUksQ0FBQyxXQUFXLE1BQU0sY0FBYyxHQUFHO0FBQ25DLCtCQUFtQixLQUFLLElBQUk7QUFBQSxVQUNoQztBQUNBLGNBQUksVUFBVTtBQUNWLG1CQUFPLEtBQUs7QUFBQSxVQUNoQixPQUFPO0FBQ0gsbUJBQU8sS0FBSztBQUFBLFVBQ2hCO0FBQUEsUUFDSixPQUFPO0FBQ0gsY0FBSSxDQUFDLFdBQVcsTUFBTSxtQkFBbUIsR0FBRztBQUN4QyxpQkFBSyxvQkFBb0I7QUFBQSxVQUM3QjtBQUNBLGlCQUFPLEtBQUssMkJBQTJCLFdBQ2pDLEtBQUssMEJBQ0wsS0FBSztBQUFBLFFBQ2Y7QUFBQSxNQUNKO0FBRUEsZUFBUyxZQUFZLFVBQVU7QUFDM0IsWUFBSSxLQUFLLG1CQUFtQjtBQUN4QixjQUFJLENBQUMsV0FBVyxNQUFNLGNBQWMsR0FBRztBQUNuQywrQkFBbUIsS0FBSyxJQUFJO0FBQUEsVUFDaEM7QUFDQSxjQUFJLFVBQVU7QUFDVixtQkFBTyxLQUFLO0FBQUEsVUFDaEIsT0FBTztBQUNILG1CQUFPLEtBQUs7QUFBQSxVQUNoQjtBQUFBLFFBQ0osT0FBTztBQUNILGNBQUksQ0FBQyxXQUFXLE1BQU0sY0FBYyxHQUFHO0FBQ25DLGlCQUFLLGVBQWU7QUFBQSxVQUN4QjtBQUNBLGlCQUFPLEtBQUssc0JBQXNCLFdBQzVCLEtBQUsscUJBQ0wsS0FBSztBQUFBLFFBQ2Y7QUFBQSxNQUNKO0FBRUEsZUFBUyxxQkFBcUI7QUFDMUIsaUJBQVMsVUFBVSxHQUFHLEdBQUc7QUFDckIsaUJBQU8sRUFBRSxTQUFTLEVBQUU7QUFBQSxRQUN4QjtBQUVBLFlBQUksY0FBYyxDQUFDLEdBQ2YsYUFBYSxDQUFDLEdBQ2QsY0FBYyxDQUFDLEdBQ2YsR0FDQTtBQUNKLGFBQUssSUFBSSxHQUFHLElBQUksSUFBSSxLQUFLO0FBRXJCLGdCQUFNLFVBQVUsQ0FBQyxLQUFNLENBQUMsQ0FBQztBQUN6QixzQkFBWSxLQUFLLEtBQUssWUFBWSxLQUFLLEVBQUUsQ0FBQztBQUMxQyxxQkFBVyxLQUFLLEtBQUssT0FBTyxLQUFLLEVBQUUsQ0FBQztBQUNwQyxzQkFBWSxLQUFLLEtBQUssT0FBTyxLQUFLLEVBQUUsQ0FBQztBQUNyQyxzQkFBWSxLQUFLLEtBQUssWUFBWSxLQUFLLEVBQUUsQ0FBQztBQUFBLFFBQzlDO0FBR0Esb0JBQVksS0FBSyxTQUFTO0FBQzFCLG1CQUFXLEtBQUssU0FBUztBQUN6QixvQkFBWSxLQUFLLFNBQVM7QUFDMUIsYUFBSyxJQUFJLEdBQUcsSUFBSSxJQUFJLEtBQUs7QUFDckIsc0JBQVksQ0FBQyxJQUFJLFlBQVksWUFBWSxDQUFDLENBQUM7QUFDM0MscUJBQVcsQ0FBQyxJQUFJLFlBQVksV0FBVyxDQUFDLENBQUM7QUFBQSxRQUM3QztBQUNBLGFBQUssSUFBSSxHQUFHLElBQUksSUFBSSxLQUFLO0FBQ3JCLHNCQUFZLENBQUMsSUFBSSxZQUFZLFlBQVksQ0FBQyxDQUFDO0FBQUEsUUFDL0M7QUFFQSxhQUFLLGVBQWUsSUFBSSxPQUFPLE9BQU8sWUFBWSxLQUFLLEdBQUcsSUFBSSxLQUFLLEdBQUc7QUFDdEUsYUFBSyxvQkFBb0IsS0FBSztBQUM5QixhQUFLLHFCQUFxQixJQUFJO0FBQUEsVUFDMUIsT0FBTyxXQUFXLEtBQUssR0FBRyxJQUFJO0FBQUEsVUFDOUI7QUFBQSxRQUNKO0FBQ0EsYUFBSywwQkFBMEIsSUFBSTtBQUFBLFVBQy9CLE9BQU8sWUFBWSxLQUFLLEdBQUcsSUFBSTtBQUFBLFVBQy9CO0FBQUEsUUFDSjtBQUFBLE1BQ0o7QUFJQSxxQkFBZSxLQUFLLEdBQUcsR0FBRyxXQUFZO0FBQ2xDLFlBQUksSUFBSSxLQUFLLEtBQUs7QUFDbEIsZUFBTyxLQUFLLE9BQU8sU0FBUyxHQUFHLENBQUMsSUFBSSxNQUFNO0FBQUEsTUFDOUMsQ0FBQztBQUVELHFCQUFlLEdBQUcsQ0FBQyxNQUFNLENBQUMsR0FBRyxHQUFHLFdBQVk7QUFDeEMsZUFBTyxLQUFLLEtBQUssSUFBSTtBQUFBLE1BQ3pCLENBQUM7QUFFRCxxQkFBZSxHQUFHLENBQUMsUUFBUSxDQUFDLEdBQUcsR0FBRyxNQUFNO0FBQ3hDLHFCQUFlLEdBQUcsQ0FBQyxTQUFTLENBQUMsR0FBRyxHQUFHLE1BQU07QUFDekMscUJBQWUsR0FBRyxDQUFDLFVBQVUsR0FBRyxJQUFJLEdBQUcsR0FBRyxNQUFNO0FBSWhELG1CQUFhLFFBQVEsR0FBRztBQUl4QixzQkFBZ0IsUUFBUSxDQUFDO0FBSXpCLG9CQUFjLEtBQUssV0FBVztBQUM5QixvQkFBYyxNQUFNLFdBQVcsTUFBTTtBQUNyQyxvQkFBYyxRQUFRLFdBQVcsTUFBTTtBQUN2QyxvQkFBYyxTQUFTLFdBQVcsTUFBTTtBQUN4QyxvQkFBYyxVQUFVLFdBQVcsTUFBTTtBQUV6QyxvQkFBYyxDQUFDLFNBQVMsUUFBUSxHQUFHLElBQUk7QUFDdkMsb0JBQWMsUUFBUSxTQUFVLE9BQU8sT0FBTztBQUMxQyxjQUFNLElBQUksSUFDTixNQUFNLFdBQVcsSUFBSSxNQUFNLGtCQUFrQixLQUFLLElBQUksTUFBTSxLQUFLO0FBQUEsTUFDekUsQ0FBQztBQUNELG9CQUFjLE1BQU0sU0FBVSxPQUFPLE9BQU87QUFDeEMsY0FBTSxJQUFJLElBQUksTUFBTSxrQkFBa0IsS0FBSztBQUFBLE1BQy9DLENBQUM7QUFDRCxvQkFBYyxLQUFLLFNBQVUsT0FBTyxPQUFPO0FBQ3ZDLGNBQU0sSUFBSSxJQUFJLFNBQVMsT0FBTyxFQUFFO0FBQUEsTUFDcEMsQ0FBQztBQUlELGVBQVMsV0FBVyxNQUFNO0FBQ3RCLGVBQU8sV0FBVyxJQUFJLElBQUksTUFBTTtBQUFBLE1BQ3BDO0FBSUEsWUFBTSxvQkFBb0IsU0FBVSxPQUFPO0FBQ3ZDLGVBQU8sTUFBTSxLQUFLLEtBQUssTUFBTSxLQUFLLElBQUksS0FBSyxPQUFPO0FBQUEsTUFDdEQ7QUFJQSxVQUFJLGFBQWEsV0FBVyxZQUFZLElBQUk7QUFFNUMsZUFBUyxnQkFBZ0I7QUFDckIsZUFBTyxXQUFXLEtBQUssS0FBSyxDQUFDO0FBQUEsTUFDakM7QUFFQSxlQUFTLFdBQVcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsSUFBSTtBQUd0QyxZQUFJO0FBRUosWUFBSSxJQUFJLE9BQU8sS0FBSyxHQUFHO0FBRW5CLGlCQUFPLElBQUksS0FBSyxJQUFJLEtBQUssR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEVBQUU7QUFDMUMsY0FBSSxTQUFTLEtBQUssWUFBWSxDQUFDLEdBQUc7QUFDOUIsaUJBQUssWUFBWSxDQUFDO0FBQUEsVUFDdEI7QUFBQSxRQUNKLE9BQU87QUFDSCxpQkFBTyxJQUFJLEtBQUssR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsRUFBRTtBQUFBLFFBQ3hDO0FBRUEsZUFBTztBQUFBLE1BQ1g7QUFFQSxlQUFTLGNBQWMsR0FBRztBQUN0QixZQUFJLE1BQU07QUFFVixZQUFJLElBQUksT0FBTyxLQUFLLEdBQUc7QUFDbkIsaUJBQU8sTUFBTSxVQUFVLE1BQU0sS0FBSyxTQUFTO0FBRTNDLGVBQUssQ0FBQyxJQUFJLElBQUk7QUFDZCxpQkFBTyxJQUFJLEtBQUssS0FBSyxJQUFJLE1BQU0sTUFBTSxJQUFJLENBQUM7QUFDMUMsY0FBSSxTQUFTLEtBQUssZUFBZSxDQUFDLEdBQUc7QUFDakMsaUJBQUssZUFBZSxDQUFDO0FBQUEsVUFDekI7QUFBQSxRQUNKLE9BQU87QUFDSCxpQkFBTyxJQUFJLEtBQUssS0FBSyxJQUFJLE1BQU0sTUFBTSxTQUFTLENBQUM7QUFBQSxRQUNuRDtBQUVBLGVBQU87QUFBQSxNQUNYO0FBR0EsZUFBUyxnQkFBZ0IsTUFBTSxLQUFLLEtBQUs7QUFDckMsWUFDSSxNQUFNLElBQUksTUFBTSxLQUVoQixTQUFTLElBQUksY0FBYyxNQUFNLEdBQUcsR0FBRyxFQUFFLFVBQVUsSUFBSSxPQUFPO0FBRWxFLGVBQU8sQ0FBQyxRQUFRLE1BQU07QUFBQSxNQUMxQjtBQUdBLGVBQVMsbUJBQW1CLE1BQU0sTUFBTSxTQUFTLEtBQUssS0FBSztBQUN2RCxZQUFJLGdCQUFnQixJQUFJLFVBQVUsT0FBTyxHQUNyQyxhQUFhLGdCQUFnQixNQUFNLEtBQUssR0FBRyxHQUMzQyxZQUFZLElBQUksS0FBSyxPQUFPLEtBQUssZUFBZSxZQUNoRCxTQUNBO0FBRUosWUFBSSxhQUFhLEdBQUc7QUFDaEIsb0JBQVUsT0FBTztBQUNqQix5QkFBZSxXQUFXLE9BQU8sSUFBSTtBQUFBLFFBQ3pDLFdBQVcsWUFBWSxXQUFXLElBQUksR0FBRztBQUNyQyxvQkFBVSxPQUFPO0FBQ2pCLHlCQUFlLFlBQVksV0FBVyxJQUFJO0FBQUEsUUFDOUMsT0FBTztBQUNILG9CQUFVO0FBQ1YseUJBQWU7QUFBQSxRQUNuQjtBQUVBLGVBQU87QUFBQSxVQUNILE1BQU07QUFBQSxVQUNOLFdBQVc7QUFBQSxRQUNmO0FBQUEsTUFDSjtBQUVBLGVBQVMsV0FBVyxLQUFLLEtBQUssS0FBSztBQUMvQixZQUFJLGFBQWEsZ0JBQWdCLElBQUksS0FBSyxHQUFHLEtBQUssR0FBRyxHQUNqRCxPQUFPLEtBQUssT0FBTyxJQUFJLFVBQVUsSUFBSSxhQUFhLEtBQUssQ0FBQyxJQUFJLEdBQzVELFNBQ0E7QUFFSixZQUFJLE9BQU8sR0FBRztBQUNWLG9CQUFVLElBQUksS0FBSyxJQUFJO0FBQ3ZCLG9CQUFVLE9BQU8sWUFBWSxTQUFTLEtBQUssR0FBRztBQUFBLFFBQ2xELFdBQVcsT0FBTyxZQUFZLElBQUksS0FBSyxHQUFHLEtBQUssR0FBRyxHQUFHO0FBQ2pELG9CQUFVLE9BQU8sWUFBWSxJQUFJLEtBQUssR0FBRyxLQUFLLEdBQUc7QUFDakQsb0JBQVUsSUFBSSxLQUFLLElBQUk7QUFBQSxRQUMzQixPQUFPO0FBQ0gsb0JBQVUsSUFBSSxLQUFLO0FBQ25CLG9CQUFVO0FBQUEsUUFDZDtBQUVBLGVBQU87QUFBQSxVQUNILE1BQU07QUFBQSxVQUNOLE1BQU07QUFBQSxRQUNWO0FBQUEsTUFDSjtBQUVBLGVBQVMsWUFBWSxNQUFNLEtBQUssS0FBSztBQUNqQyxZQUFJLGFBQWEsZ0JBQWdCLE1BQU0sS0FBSyxHQUFHLEdBQzNDLGlCQUFpQixnQkFBZ0IsT0FBTyxHQUFHLEtBQUssR0FBRztBQUN2RCxnQkFBUSxXQUFXLElBQUksSUFBSSxhQUFhLGtCQUFrQjtBQUFBLE1BQzlEO0FBSUEscUJBQWUsS0FBSyxDQUFDLE1BQU0sQ0FBQyxHQUFHLE1BQU0sTUFBTTtBQUMzQyxxQkFBZSxLQUFLLENBQUMsTUFBTSxDQUFDLEdBQUcsTUFBTSxTQUFTO0FBSTlDLG1CQUFhLFFBQVEsR0FBRztBQUN4QixtQkFBYSxXQUFXLEdBQUc7QUFJM0Isc0JBQWdCLFFBQVEsQ0FBQztBQUN6QixzQkFBZ0IsV0FBVyxDQUFDO0FBSTVCLG9CQUFjLEtBQUssU0FBUztBQUM1QixvQkFBYyxNQUFNLFdBQVcsTUFBTTtBQUNyQyxvQkFBYyxLQUFLLFNBQVM7QUFDNUIsb0JBQWMsTUFBTSxXQUFXLE1BQU07QUFFckMsd0JBQWtCLENBQUMsS0FBSyxNQUFNLEtBQUssSUFBSSxHQUFHLFNBQ3RDLE9BQ0EsTUFDQSxRQUNBUSxRQUNGO0FBQ0UsYUFBS0EsT0FBTSxPQUFPLEdBQUcsQ0FBQyxDQUFDLElBQUksTUFBTSxLQUFLO0FBQUEsTUFDMUMsQ0FBQztBQU1ELGVBQVMsV0FBVyxLQUFLO0FBQ3JCLGVBQU8sV0FBVyxLQUFLLEtBQUssTUFBTSxLQUFLLEtBQUssTUFBTSxHQUFHLEVBQUU7QUFBQSxNQUMzRDtBQUVBLFVBQUksb0JBQW9CO0FBQUEsUUFDcEIsS0FBSztBQUFBO0FBQUEsUUFDTCxLQUFLO0FBQUE7QUFBQSxNQUNUO0FBRUEsZUFBUyx1QkFBdUI7QUFDNUIsZUFBTyxLQUFLLE1BQU07QUFBQSxNQUN0QjtBQUVBLGVBQVMsdUJBQXVCO0FBQzVCLGVBQU8sS0FBSyxNQUFNO0FBQUEsTUFDdEI7QUFJQSxlQUFTLFdBQVcsT0FBTztBQUN2QixZQUFJLE9BQU8sS0FBSyxXQUFXLEVBQUUsS0FBSyxJQUFJO0FBQ3RDLGVBQU8sU0FBUyxPQUFPLE9BQU8sS0FBSyxLQUFLLFFBQVEsUUFBUSxHQUFHLEdBQUc7QUFBQSxNQUNsRTtBQUVBLGVBQVMsY0FBYyxPQUFPO0FBQzFCLFlBQUksT0FBTyxXQUFXLE1BQU0sR0FBRyxDQUFDLEVBQUU7QUFDbEMsZUFBTyxTQUFTLE9BQU8sT0FBTyxLQUFLLEtBQUssUUFBUSxRQUFRLEdBQUcsR0FBRztBQUFBLE1BQ2xFO0FBSUEscUJBQWUsS0FBSyxHQUFHLE1BQU0sS0FBSztBQUVsQyxxQkFBZSxNQUFNLEdBQUcsR0FBRyxTQUFVUixTQUFRO0FBQ3pDLGVBQU8sS0FBSyxXQUFXLEVBQUUsWUFBWSxNQUFNQSxPQUFNO0FBQUEsTUFDckQsQ0FBQztBQUVELHFCQUFlLE9BQU8sR0FBRyxHQUFHLFNBQVVBLFNBQVE7QUFDMUMsZUFBTyxLQUFLLFdBQVcsRUFBRSxjQUFjLE1BQU1BLE9BQU07QUFBQSxNQUN2RCxDQUFDO0FBRUQscUJBQWUsUUFBUSxHQUFHLEdBQUcsU0FBVUEsU0FBUTtBQUMzQyxlQUFPLEtBQUssV0FBVyxFQUFFLFNBQVMsTUFBTUEsT0FBTTtBQUFBLE1BQ2xELENBQUM7QUFFRCxxQkFBZSxLQUFLLEdBQUcsR0FBRyxTQUFTO0FBQ25DLHFCQUFlLEtBQUssR0FBRyxHQUFHLFlBQVk7QUFJdEMsbUJBQWEsT0FBTyxHQUFHO0FBQ3ZCLG1CQUFhLFdBQVcsR0FBRztBQUMzQixtQkFBYSxjQUFjLEdBQUc7QUFHOUIsc0JBQWdCLE9BQU8sRUFBRTtBQUN6QixzQkFBZ0IsV0FBVyxFQUFFO0FBQzdCLHNCQUFnQixjQUFjLEVBQUU7QUFJaEMsb0JBQWMsS0FBSyxTQUFTO0FBQzVCLG9CQUFjLEtBQUssU0FBUztBQUM1QixvQkFBYyxLQUFLLFNBQVM7QUFDNUIsb0JBQWMsTUFBTSxTQUFVLFVBQVVDLFNBQVE7QUFDNUMsZUFBT0EsUUFBTyxpQkFBaUIsUUFBUTtBQUFBLE1BQzNDLENBQUM7QUFDRCxvQkFBYyxPQUFPLFNBQVUsVUFBVUEsU0FBUTtBQUM3QyxlQUFPQSxRQUFPLG1CQUFtQixRQUFRO0FBQUEsTUFDN0MsQ0FBQztBQUNELG9CQUFjLFFBQVEsU0FBVSxVQUFVQSxTQUFRO0FBQzlDLGVBQU9BLFFBQU8sY0FBYyxRQUFRO0FBQUEsTUFDeEMsQ0FBQztBQUVELHdCQUFrQixDQUFDLE1BQU0sT0FBTyxNQUFNLEdBQUcsU0FBVSxPQUFPLE1BQU0sUUFBUU8sUUFBTztBQUMzRSxZQUFJLFVBQVUsT0FBTyxRQUFRLGNBQWMsT0FBT0EsUUFBTyxPQUFPLE9BQU87QUFFdkUsWUFBSSxXQUFXLE1BQU07QUFDakIsZUFBSyxJQUFJO0FBQUEsUUFDYixPQUFPO0FBQ0gsMEJBQWdCLE1BQU0sRUFBRSxpQkFBaUI7QUFBQSxRQUM3QztBQUFBLE1BQ0osQ0FBQztBQUVELHdCQUFrQixDQUFDLEtBQUssS0FBSyxHQUFHLEdBQUcsU0FBVSxPQUFPLE1BQU0sUUFBUUEsUUFBTztBQUNyRSxhQUFLQSxNQUFLLElBQUksTUFBTSxLQUFLO0FBQUEsTUFDN0IsQ0FBQztBQUlELGVBQVMsYUFBYSxPQUFPUCxTQUFRO0FBQ2pDLFlBQUksT0FBTyxVQUFVLFVBQVU7QUFDM0IsaUJBQU87QUFBQSxRQUNYO0FBRUEsWUFBSSxDQUFDLE1BQU0sS0FBSyxHQUFHO0FBQ2YsaUJBQU8sU0FBUyxPQUFPLEVBQUU7QUFBQSxRQUM3QjtBQUVBLGdCQUFRQSxRQUFPLGNBQWMsS0FBSztBQUNsQyxZQUFJLE9BQU8sVUFBVSxVQUFVO0FBQzNCLGlCQUFPO0FBQUEsUUFDWDtBQUVBLGVBQU87QUFBQSxNQUNYO0FBRUEsZUFBUyxnQkFBZ0IsT0FBT0EsU0FBUTtBQUNwQyxZQUFJLE9BQU8sVUFBVSxVQUFVO0FBQzNCLGlCQUFPQSxRQUFPLGNBQWMsS0FBSyxJQUFJLEtBQUs7QUFBQSxRQUM5QztBQUNBLGVBQU8sTUFBTSxLQUFLLElBQUksT0FBTztBQUFBLE1BQ2pDO0FBR0EsZUFBUyxjQUFjLElBQUksR0FBRztBQUMxQixlQUFPLEdBQUcsTUFBTSxHQUFHLENBQUMsRUFBRSxPQUFPLEdBQUcsTUFBTSxHQUFHLENBQUMsQ0FBQztBQUFBLE1BQy9DO0FBRUEsVUFBSSx3QkFBd0IsMkRBQTJEO0FBQUEsUUFDL0U7QUFBQSxNQUNKLEdBQ0EsNkJBQTZCLDhCQUE4QixNQUFNLEdBQUcsR0FDcEUsMkJBQTJCLHVCQUF1QixNQUFNLEdBQUcsR0FDM0QsdUJBQXVCLFdBQ3ZCLDRCQUE0QixXQUM1QiwwQkFBMEI7QUFFOUIsZUFBUyxlQUFlLEdBQUdELFNBQVE7QUFDL0IsWUFBSSxXQUFXLFFBQVEsS0FBSyxTQUFTLElBQy9CLEtBQUssWUFDTCxLQUFLLFVBQ0QsS0FBSyxNQUFNLFFBQVEsS0FBSyxVQUFVLFNBQVMsS0FBS0EsT0FBTSxJQUNoRCxXQUNBLFlBQ1Y7QUFDTixlQUFPLE1BQU0sT0FDUCxjQUFjLFVBQVUsS0FBSyxNQUFNLEdBQUcsSUFDdEMsSUFDQSxTQUFTLEVBQUUsSUFBSSxDQUFDLElBQ2hCO0FBQUEsTUFDVjtBQUVBLGVBQVMsb0JBQW9CLEdBQUc7QUFDNUIsZUFBTyxNQUFNLE9BQ1AsY0FBYyxLQUFLLGdCQUFnQixLQUFLLE1BQU0sR0FBRyxJQUNqRCxJQUNBLEtBQUssZUFBZSxFQUFFLElBQUksQ0FBQyxJQUMzQixLQUFLO0FBQUEsTUFDZjtBQUVBLGVBQVMsa0JBQWtCLEdBQUc7QUFDMUIsZUFBTyxNQUFNLE9BQ1AsY0FBYyxLQUFLLGNBQWMsS0FBSyxNQUFNLEdBQUcsSUFDL0MsSUFDQSxLQUFLLGFBQWEsRUFBRSxJQUFJLENBQUMsSUFDekIsS0FBSztBQUFBLE1BQ2Y7QUFFQSxlQUFTLG9CQUFvQixhQUFhQSxTQUFRLFFBQVE7QUFDdEQsWUFBSSxHQUNBLElBQ0EsS0FDQSxNQUFNLFlBQVksa0JBQWtCO0FBQ3hDLFlBQUksQ0FBQyxLQUFLLGdCQUFnQjtBQUN0QixlQUFLLGlCQUFpQixDQUFDO0FBQ3ZCLGVBQUssc0JBQXNCLENBQUM7QUFDNUIsZUFBSyxvQkFBb0IsQ0FBQztBQUUxQixlQUFLLElBQUksR0FBRyxJQUFJLEdBQUcsRUFBRSxHQUFHO0FBQ3BCLGtCQUFNLFVBQVUsQ0FBQyxLQUFNLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQztBQUNoQyxpQkFBSyxrQkFBa0IsQ0FBQyxJQUFJLEtBQUs7QUFBQSxjQUM3QjtBQUFBLGNBQ0E7QUFBQSxZQUNKLEVBQUUsa0JBQWtCO0FBQ3BCLGlCQUFLLG9CQUFvQixDQUFDLElBQUksS0FBSztBQUFBLGNBQy9CO0FBQUEsY0FDQTtBQUFBLFlBQ0osRUFBRSxrQkFBa0I7QUFDcEIsaUJBQUssZUFBZSxDQUFDLElBQUksS0FBSyxTQUFTLEtBQUssRUFBRSxFQUFFLGtCQUFrQjtBQUFBLFVBQ3RFO0FBQUEsUUFDSjtBQUVBLFlBQUksUUFBUTtBQUNSLGNBQUlBLFlBQVcsUUFBUTtBQUNuQixpQkFBSyxRQUFRLEtBQUssS0FBSyxnQkFBZ0IsR0FBRztBQUMxQyxtQkFBTyxPQUFPLEtBQUssS0FBSztBQUFBLFVBQzVCLFdBQVdBLFlBQVcsT0FBTztBQUN6QixpQkFBSyxRQUFRLEtBQUssS0FBSyxxQkFBcUIsR0FBRztBQUMvQyxtQkFBTyxPQUFPLEtBQUssS0FBSztBQUFBLFVBQzVCLE9BQU87QUFDSCxpQkFBSyxRQUFRLEtBQUssS0FBSyxtQkFBbUIsR0FBRztBQUM3QyxtQkFBTyxPQUFPLEtBQUssS0FBSztBQUFBLFVBQzVCO0FBQUEsUUFDSixPQUFPO0FBQ0gsY0FBSUEsWUFBVyxRQUFRO0FBQ25CLGlCQUFLLFFBQVEsS0FBSyxLQUFLLGdCQUFnQixHQUFHO0FBQzFDLGdCQUFJLE9BQU8sSUFBSTtBQUNYLHFCQUFPO0FBQUEsWUFDWDtBQUNBLGlCQUFLLFFBQVEsS0FBSyxLQUFLLHFCQUFxQixHQUFHO0FBQy9DLGdCQUFJLE9BQU8sSUFBSTtBQUNYLHFCQUFPO0FBQUEsWUFDWDtBQUNBLGlCQUFLLFFBQVEsS0FBSyxLQUFLLG1CQUFtQixHQUFHO0FBQzdDLG1CQUFPLE9BQU8sS0FBSyxLQUFLO0FBQUEsVUFDNUIsV0FBV0EsWUFBVyxPQUFPO0FBQ3pCLGlCQUFLLFFBQVEsS0FBSyxLQUFLLHFCQUFxQixHQUFHO0FBQy9DLGdCQUFJLE9BQU8sSUFBSTtBQUNYLHFCQUFPO0FBQUEsWUFDWDtBQUNBLGlCQUFLLFFBQVEsS0FBSyxLQUFLLGdCQUFnQixHQUFHO0FBQzFDLGdCQUFJLE9BQU8sSUFBSTtBQUNYLHFCQUFPO0FBQUEsWUFDWDtBQUNBLGlCQUFLLFFBQVEsS0FBSyxLQUFLLG1CQUFtQixHQUFHO0FBQzdDLG1CQUFPLE9BQU8sS0FBSyxLQUFLO0FBQUEsVUFDNUIsT0FBTztBQUNILGlCQUFLLFFBQVEsS0FBSyxLQUFLLG1CQUFtQixHQUFHO0FBQzdDLGdCQUFJLE9BQU8sSUFBSTtBQUNYLHFCQUFPO0FBQUEsWUFDWDtBQUNBLGlCQUFLLFFBQVEsS0FBSyxLQUFLLGdCQUFnQixHQUFHO0FBQzFDLGdCQUFJLE9BQU8sSUFBSTtBQUNYLHFCQUFPO0FBQUEsWUFDWDtBQUNBLGlCQUFLLFFBQVEsS0FBSyxLQUFLLHFCQUFxQixHQUFHO0FBQy9DLG1CQUFPLE9BQU8sS0FBSyxLQUFLO0FBQUEsVUFDNUI7QUFBQSxRQUNKO0FBQUEsTUFDSjtBQUVBLGVBQVMsb0JBQW9CLGFBQWFBLFNBQVEsUUFBUTtBQUN0RCxZQUFJLEdBQUcsS0FBSztBQUVaLFlBQUksS0FBSyxxQkFBcUI7QUFDMUIsaUJBQU8sb0JBQW9CLEtBQUssTUFBTSxhQUFhQSxTQUFRLE1BQU07QUFBQSxRQUNyRTtBQUVBLFlBQUksQ0FBQyxLQUFLLGdCQUFnQjtBQUN0QixlQUFLLGlCQUFpQixDQUFDO0FBQ3ZCLGVBQUssb0JBQW9CLENBQUM7QUFDMUIsZUFBSyxzQkFBc0IsQ0FBQztBQUM1QixlQUFLLHFCQUFxQixDQUFDO0FBQUEsUUFDL0I7QUFFQSxhQUFLLElBQUksR0FBRyxJQUFJLEdBQUcsS0FBSztBQUdwQixnQkFBTSxVQUFVLENBQUMsS0FBTSxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUM7QUFDaEMsY0FBSSxVQUFVLENBQUMsS0FBSyxtQkFBbUIsQ0FBQyxHQUFHO0FBQ3ZDLGlCQUFLLG1CQUFtQixDQUFDLElBQUksSUFBSTtBQUFBLGNBQzdCLE1BQU0sS0FBSyxTQUFTLEtBQUssRUFBRSxFQUFFLFFBQVEsS0FBSyxNQUFNLElBQUk7QUFBQSxjQUNwRDtBQUFBLFlBQ0o7QUFDQSxpQkFBSyxvQkFBb0IsQ0FBQyxJQUFJLElBQUk7QUFBQSxjQUM5QixNQUFNLEtBQUssY0FBYyxLQUFLLEVBQUUsRUFBRSxRQUFRLEtBQUssTUFBTSxJQUFJO0FBQUEsY0FDekQ7QUFBQSxZQUNKO0FBQ0EsaUJBQUssa0JBQWtCLENBQUMsSUFBSSxJQUFJO0FBQUEsY0FDNUIsTUFBTSxLQUFLLFlBQVksS0FBSyxFQUFFLEVBQUUsUUFBUSxLQUFLLE1BQU0sSUFBSTtBQUFBLGNBQ3ZEO0FBQUEsWUFDSjtBQUFBLFVBQ0o7QUFDQSxjQUFJLENBQUMsS0FBSyxlQUFlLENBQUMsR0FBRztBQUN6QixvQkFDSSxNQUNBLEtBQUssU0FBUyxLQUFLLEVBQUUsSUFDckIsT0FDQSxLQUFLLGNBQWMsS0FBSyxFQUFFLElBQzFCLE9BQ0EsS0FBSyxZQUFZLEtBQUssRUFBRTtBQUM1QixpQkFBSyxlQUFlLENBQUMsSUFBSSxJQUFJLE9BQU8sTUFBTSxRQUFRLEtBQUssRUFBRSxHQUFHLEdBQUc7QUFBQSxVQUNuRTtBQUVBLGNBQ0ksVUFDQUEsWUFBVyxVQUNYLEtBQUssbUJBQW1CLENBQUMsRUFBRSxLQUFLLFdBQVcsR0FDN0M7QUFDRSxtQkFBTztBQUFBLFVBQ1gsV0FDSSxVQUNBQSxZQUFXLFNBQ1gsS0FBSyxvQkFBb0IsQ0FBQyxFQUFFLEtBQUssV0FBVyxHQUM5QztBQUNFLG1CQUFPO0FBQUEsVUFDWCxXQUNJLFVBQ0FBLFlBQVcsUUFDWCxLQUFLLGtCQUFrQixDQUFDLEVBQUUsS0FBSyxXQUFXLEdBQzVDO0FBQ0UsbUJBQU87QUFBQSxVQUNYLFdBQVcsQ0FBQyxVQUFVLEtBQUssZUFBZSxDQUFDLEVBQUUsS0FBSyxXQUFXLEdBQUc7QUFDNUQsbUJBQU87QUFBQSxVQUNYO0FBQUEsUUFDSjtBQUFBLE1BQ0o7QUFJQSxlQUFTLGdCQUFnQixPQUFPO0FBQzVCLFlBQUksQ0FBQyxLQUFLLFFBQVEsR0FBRztBQUNqQixpQkFBTyxTQUFTLE9BQU8sT0FBTztBQUFBLFFBQ2xDO0FBQ0EsWUFBSSxNQUFNLEtBQUssU0FBUyxLQUFLLEdBQUcsVUFBVSxJQUFJLEtBQUssR0FBRyxPQUFPO0FBQzdELFlBQUksU0FBUyxNQUFNO0FBQ2Ysa0JBQVEsYUFBYSxPQUFPLEtBQUssV0FBVyxDQUFDO0FBQzdDLGlCQUFPLEtBQUssSUFBSSxRQUFRLEtBQUssR0FBRztBQUFBLFFBQ3BDLE9BQU87QUFDSCxpQkFBTztBQUFBLFFBQ1g7QUFBQSxNQUNKO0FBRUEsZUFBUyxzQkFBc0IsT0FBTztBQUNsQyxZQUFJLENBQUMsS0FBSyxRQUFRLEdBQUc7QUFDakIsaUJBQU8sU0FBUyxPQUFPLE9BQU87QUFBQSxRQUNsQztBQUNBLFlBQUksV0FBVyxLQUFLLElBQUksSUFBSSxJQUFJLEtBQUssV0FBVyxFQUFFLE1BQU0sT0FBTztBQUMvRCxlQUFPLFNBQVMsT0FBTyxVQUFVLEtBQUssSUFBSSxRQUFRLFNBQVMsR0FBRztBQUFBLE1BQ2xFO0FBRUEsZUFBUyxtQkFBbUIsT0FBTztBQUMvQixZQUFJLENBQUMsS0FBSyxRQUFRLEdBQUc7QUFDakIsaUJBQU8sU0FBUyxPQUFPLE9BQU87QUFBQSxRQUNsQztBQU1BLFlBQUksU0FBUyxNQUFNO0FBQ2YsY0FBSSxVQUFVLGdCQUFnQixPQUFPLEtBQUssV0FBVyxDQUFDO0FBQ3RELGlCQUFPLEtBQUssSUFBSSxLQUFLLElBQUksSUFBSSxJQUFJLFVBQVUsVUFBVSxDQUFDO0FBQUEsUUFDMUQsT0FBTztBQUNILGlCQUFPLEtBQUssSUFBSSxLQUFLO0FBQUEsUUFDekI7QUFBQSxNQUNKO0FBRUEsZUFBUyxjQUFjLFVBQVU7QUFDN0IsWUFBSSxLQUFLLHFCQUFxQjtBQUMxQixjQUFJLENBQUMsV0FBVyxNQUFNLGdCQUFnQixHQUFHO0FBQ3JDLGlDQUFxQixLQUFLLElBQUk7QUFBQSxVQUNsQztBQUNBLGNBQUksVUFBVTtBQUNWLG1CQUFPLEtBQUs7QUFBQSxVQUNoQixPQUFPO0FBQ0gsbUJBQU8sS0FBSztBQUFBLFVBQ2hCO0FBQUEsUUFDSixPQUFPO0FBQ0gsY0FBSSxDQUFDLFdBQVcsTUFBTSxnQkFBZ0IsR0FBRztBQUNyQyxpQkFBSyxpQkFBaUI7QUFBQSxVQUMxQjtBQUNBLGlCQUFPLEtBQUssd0JBQXdCLFdBQzlCLEtBQUssdUJBQ0wsS0FBSztBQUFBLFFBQ2Y7QUFBQSxNQUNKO0FBRUEsZUFBUyxtQkFBbUIsVUFBVTtBQUNsQyxZQUFJLEtBQUsscUJBQXFCO0FBQzFCLGNBQUksQ0FBQyxXQUFXLE1BQU0sZ0JBQWdCLEdBQUc7QUFDckMsaUNBQXFCLEtBQUssSUFBSTtBQUFBLFVBQ2xDO0FBQ0EsY0FBSSxVQUFVO0FBQ1YsbUJBQU8sS0FBSztBQUFBLFVBQ2hCLE9BQU87QUFDSCxtQkFBTyxLQUFLO0FBQUEsVUFDaEI7QUFBQSxRQUNKLE9BQU87QUFDSCxjQUFJLENBQUMsV0FBVyxNQUFNLHFCQUFxQixHQUFHO0FBQzFDLGlCQUFLLHNCQUFzQjtBQUFBLFVBQy9CO0FBQ0EsaUJBQU8sS0FBSyw2QkFBNkIsV0FDbkMsS0FBSyw0QkFDTCxLQUFLO0FBQUEsUUFDZjtBQUFBLE1BQ0o7QUFFQSxlQUFTLGlCQUFpQixVQUFVO0FBQ2hDLFlBQUksS0FBSyxxQkFBcUI7QUFDMUIsY0FBSSxDQUFDLFdBQVcsTUFBTSxnQkFBZ0IsR0FBRztBQUNyQyxpQ0FBcUIsS0FBSyxJQUFJO0FBQUEsVUFDbEM7QUFDQSxjQUFJLFVBQVU7QUFDVixtQkFBTyxLQUFLO0FBQUEsVUFDaEIsT0FBTztBQUNILG1CQUFPLEtBQUs7QUFBQSxVQUNoQjtBQUFBLFFBQ0osT0FBTztBQUNILGNBQUksQ0FBQyxXQUFXLE1BQU0sbUJBQW1CLEdBQUc7QUFDeEMsaUJBQUssb0JBQW9CO0FBQUEsVUFDN0I7QUFDQSxpQkFBTyxLQUFLLDJCQUEyQixXQUNqQyxLQUFLLDBCQUNMLEtBQUs7QUFBQSxRQUNmO0FBQUEsTUFDSjtBQUVBLGVBQVMsdUJBQXVCO0FBQzVCLGlCQUFTLFVBQVUsR0FBRyxHQUFHO0FBQ3JCLGlCQUFPLEVBQUUsU0FBUyxFQUFFO0FBQUEsUUFDeEI7QUFFQSxZQUFJLFlBQVksQ0FBQyxHQUNiLGNBQWMsQ0FBQyxHQUNmLGFBQWEsQ0FBQyxHQUNkLGNBQWMsQ0FBQyxHQUNmLEdBQ0EsS0FDQSxNQUNBLFFBQ0E7QUFDSixhQUFLLElBQUksR0FBRyxJQUFJLEdBQUcsS0FBSztBQUVwQixnQkFBTSxVQUFVLENBQUMsS0FBTSxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUM7QUFDaEMsaUJBQU8sWUFBWSxLQUFLLFlBQVksS0FBSyxFQUFFLENBQUM7QUFDNUMsbUJBQVMsWUFBWSxLQUFLLGNBQWMsS0FBSyxFQUFFLENBQUM7QUFDaEQsa0JBQVEsWUFBWSxLQUFLLFNBQVMsS0FBSyxFQUFFLENBQUM7QUFDMUMsb0JBQVUsS0FBSyxJQUFJO0FBQ25CLHNCQUFZLEtBQUssTUFBTTtBQUN2QixxQkFBVyxLQUFLLEtBQUs7QUFDckIsc0JBQVksS0FBSyxJQUFJO0FBQ3JCLHNCQUFZLEtBQUssTUFBTTtBQUN2QixzQkFBWSxLQUFLLEtBQUs7QUFBQSxRQUMxQjtBQUdBLGtCQUFVLEtBQUssU0FBUztBQUN4QixvQkFBWSxLQUFLLFNBQVM7QUFDMUIsbUJBQVcsS0FBSyxTQUFTO0FBQ3pCLG9CQUFZLEtBQUssU0FBUztBQUUxQixhQUFLLGlCQUFpQixJQUFJLE9BQU8sT0FBTyxZQUFZLEtBQUssR0FBRyxJQUFJLEtBQUssR0FBRztBQUN4RSxhQUFLLHNCQUFzQixLQUFLO0FBQ2hDLGFBQUssb0JBQW9CLEtBQUs7QUFFOUIsYUFBSyx1QkFBdUIsSUFBSTtBQUFBLFVBQzVCLE9BQU8sV0FBVyxLQUFLLEdBQUcsSUFBSTtBQUFBLFVBQzlCO0FBQUEsUUFDSjtBQUNBLGFBQUssNEJBQTRCLElBQUk7QUFBQSxVQUNqQyxPQUFPLFlBQVksS0FBSyxHQUFHLElBQUk7QUFBQSxVQUMvQjtBQUFBLFFBQ0o7QUFDQSxhQUFLLDBCQUEwQixJQUFJO0FBQUEsVUFDL0IsT0FBTyxVQUFVLEtBQUssR0FBRyxJQUFJO0FBQUEsVUFDN0I7QUFBQSxRQUNKO0FBQUEsTUFDSjtBQUlBLGVBQVMsVUFBVTtBQUNmLGVBQU8sS0FBSyxNQUFNLElBQUksTUFBTTtBQUFBLE1BQ2hDO0FBRUEsZUFBUyxVQUFVO0FBQ2YsZUFBTyxLQUFLLE1BQU0sS0FBSztBQUFBLE1BQzNCO0FBRUEscUJBQWUsS0FBSyxDQUFDLE1BQU0sQ0FBQyxHQUFHLEdBQUcsTUFBTTtBQUN4QyxxQkFBZSxLQUFLLENBQUMsTUFBTSxDQUFDLEdBQUcsR0FBRyxPQUFPO0FBQ3pDLHFCQUFlLEtBQUssQ0FBQyxNQUFNLENBQUMsR0FBRyxHQUFHLE9BQU87QUFFekMscUJBQWUsT0FBTyxHQUFHLEdBQUcsV0FBWTtBQUNwQyxlQUFPLEtBQUssUUFBUSxNQUFNLElBQUksSUFBSSxTQUFTLEtBQUssUUFBUSxHQUFHLENBQUM7QUFBQSxNQUNoRSxDQUFDO0FBRUQscUJBQWUsU0FBUyxHQUFHLEdBQUcsV0FBWTtBQUN0QyxlQUNJLEtBQ0EsUUFBUSxNQUFNLElBQUksSUFDbEIsU0FBUyxLQUFLLFFBQVEsR0FBRyxDQUFDLElBQzFCLFNBQVMsS0FBSyxRQUFRLEdBQUcsQ0FBQztBQUFBLE1BRWxDLENBQUM7QUFFRCxxQkFBZSxPQUFPLEdBQUcsR0FBRyxXQUFZO0FBQ3BDLGVBQU8sS0FBSyxLQUFLLE1BQU0sSUFBSSxTQUFTLEtBQUssUUFBUSxHQUFHLENBQUM7QUFBQSxNQUN6RCxDQUFDO0FBRUQscUJBQWUsU0FBUyxHQUFHLEdBQUcsV0FBWTtBQUN0QyxlQUNJLEtBQ0EsS0FBSyxNQUFNLElBQ1gsU0FBUyxLQUFLLFFBQVEsR0FBRyxDQUFDLElBQzFCLFNBQVMsS0FBSyxRQUFRLEdBQUcsQ0FBQztBQUFBLE1BRWxDLENBQUM7QUFFRCxlQUFTLFNBQVNRLFFBQU8sV0FBVztBQUNoQyx1QkFBZUEsUUFBTyxHQUFHLEdBQUcsV0FBWTtBQUNwQyxpQkFBTyxLQUFLLFdBQVcsRUFBRTtBQUFBLFlBQ3JCLEtBQUssTUFBTTtBQUFBLFlBQ1gsS0FBSyxRQUFRO0FBQUEsWUFDYjtBQUFBLFVBQ0o7QUFBQSxRQUNKLENBQUM7QUFBQSxNQUNMO0FBRUEsZUFBUyxLQUFLLElBQUk7QUFDbEIsZUFBUyxLQUFLLEtBQUs7QUFJbkIsbUJBQWEsUUFBUSxHQUFHO0FBR3hCLHNCQUFnQixRQUFRLEVBQUU7QUFJMUIsZUFBUyxjQUFjLFVBQVVQLFNBQVE7QUFDckMsZUFBT0EsUUFBTztBQUFBLE1BQ2xCO0FBRUEsb0JBQWMsS0FBSyxhQUFhO0FBQ2hDLG9CQUFjLEtBQUssYUFBYTtBQUNoQyxvQkFBYyxLQUFLLFNBQVM7QUFDNUIsb0JBQWMsS0FBSyxTQUFTO0FBQzVCLG9CQUFjLEtBQUssU0FBUztBQUM1QixvQkFBYyxNQUFNLFdBQVcsTUFBTTtBQUNyQyxvQkFBYyxNQUFNLFdBQVcsTUFBTTtBQUNyQyxvQkFBYyxNQUFNLFdBQVcsTUFBTTtBQUVyQyxvQkFBYyxPQUFPLFNBQVM7QUFDOUIsb0JBQWMsU0FBUyxTQUFTO0FBQ2hDLG9CQUFjLE9BQU8sU0FBUztBQUM5QixvQkFBYyxTQUFTLFNBQVM7QUFFaEMsb0JBQWMsQ0FBQyxLQUFLLElBQUksR0FBRyxJQUFJO0FBQy9CLG9CQUFjLENBQUMsS0FBSyxJQUFJLEdBQUcsU0FBVSxPQUFPLE9BQU8sUUFBUTtBQUN2RCxZQUFJLFNBQVMsTUFBTSxLQUFLO0FBQ3hCLGNBQU0sSUFBSSxJQUFJLFdBQVcsS0FBSyxJQUFJO0FBQUEsTUFDdEMsQ0FBQztBQUNELG9CQUFjLENBQUMsS0FBSyxHQUFHLEdBQUcsU0FBVSxPQUFPLE9BQU8sUUFBUTtBQUN0RCxlQUFPLFFBQVEsT0FBTyxRQUFRLEtBQUssS0FBSztBQUN4QyxlQUFPLFlBQVk7QUFBQSxNQUN2QixDQUFDO0FBQ0Qsb0JBQWMsQ0FBQyxLQUFLLElBQUksR0FBRyxTQUFVLE9BQU8sT0FBTyxRQUFRO0FBQ3ZELGNBQU0sSUFBSSxJQUFJLE1BQU0sS0FBSztBQUN6Qix3QkFBZ0IsTUFBTSxFQUFFLFVBQVU7QUFBQSxNQUN0QyxDQUFDO0FBQ0Qsb0JBQWMsT0FBTyxTQUFVLE9BQU8sT0FBTyxRQUFRO0FBQ2pELFlBQUksTUFBTSxNQUFNLFNBQVM7QUFDekIsY0FBTSxJQUFJLElBQUksTUFBTSxNQUFNLE9BQU8sR0FBRyxHQUFHLENBQUM7QUFDeEMsY0FBTSxNQUFNLElBQUksTUFBTSxNQUFNLE9BQU8sR0FBRyxDQUFDO0FBQ3ZDLHdCQUFnQixNQUFNLEVBQUUsVUFBVTtBQUFBLE1BQ3RDLENBQUM7QUFDRCxvQkFBYyxTQUFTLFNBQVUsT0FBTyxPQUFPLFFBQVE7QUFDbkQsWUFBSSxPQUFPLE1BQU0sU0FBUyxHQUN0QixPQUFPLE1BQU0sU0FBUztBQUMxQixjQUFNLElBQUksSUFBSSxNQUFNLE1BQU0sT0FBTyxHQUFHLElBQUksQ0FBQztBQUN6QyxjQUFNLE1BQU0sSUFBSSxNQUFNLE1BQU0sT0FBTyxNQUFNLENBQUMsQ0FBQztBQUMzQyxjQUFNLE1BQU0sSUFBSSxNQUFNLE1BQU0sT0FBTyxJQUFJLENBQUM7QUFDeEMsd0JBQWdCLE1BQU0sRUFBRSxVQUFVO0FBQUEsTUFDdEMsQ0FBQztBQUNELG9CQUFjLE9BQU8sU0FBVSxPQUFPLE9BQU8sUUFBUTtBQUNqRCxZQUFJLE1BQU0sTUFBTSxTQUFTO0FBQ3pCLGNBQU0sSUFBSSxJQUFJLE1BQU0sTUFBTSxPQUFPLEdBQUcsR0FBRyxDQUFDO0FBQ3hDLGNBQU0sTUFBTSxJQUFJLE1BQU0sTUFBTSxPQUFPLEdBQUcsQ0FBQztBQUFBLE1BQzNDLENBQUM7QUFDRCxvQkFBYyxTQUFTLFNBQVUsT0FBTyxPQUFPLFFBQVE7QUFDbkQsWUFBSSxPQUFPLE1BQU0sU0FBUyxHQUN0QixPQUFPLE1BQU0sU0FBUztBQUMxQixjQUFNLElBQUksSUFBSSxNQUFNLE1BQU0sT0FBTyxHQUFHLElBQUksQ0FBQztBQUN6QyxjQUFNLE1BQU0sSUFBSSxNQUFNLE1BQU0sT0FBTyxNQUFNLENBQUMsQ0FBQztBQUMzQyxjQUFNLE1BQU0sSUFBSSxNQUFNLE1BQU0sT0FBTyxJQUFJLENBQUM7QUFBQSxNQUM1QyxDQUFDO0FBSUQsZUFBUyxXQUFXLE9BQU87QUFHdkIsZ0JBQVEsUUFBUSxJQUFJLFlBQVksRUFBRSxPQUFPLENBQUMsTUFBTTtBQUFBLE1BQ3BEO0FBRUEsVUFBSSw2QkFBNkIsaUJBSzdCLGFBQWEsV0FBVyxTQUFTLElBQUk7QUFFekMsZUFBUyxlQUFlYSxRQUFPQyxVQUFTLFNBQVM7QUFDN0MsWUFBSUQsU0FBUSxJQUFJO0FBQ1osaUJBQU8sVUFBVSxPQUFPO0FBQUEsUUFDNUIsT0FBTztBQUNILGlCQUFPLFVBQVUsT0FBTztBQUFBLFFBQzVCO0FBQUEsTUFDSjtBQUVBLFVBQUksYUFBYTtBQUFBLFFBQ2IsVUFBVTtBQUFBLFFBQ1YsZ0JBQWdCO0FBQUEsUUFDaEIsYUFBYTtBQUFBLFFBQ2IsU0FBUztBQUFBLFFBQ1Qsd0JBQXdCO0FBQUEsUUFDeEIsY0FBYztBQUFBLFFBRWQsUUFBUTtBQUFBLFFBQ1IsYUFBYTtBQUFBLFFBRWIsTUFBTTtBQUFBLFFBRU4sVUFBVTtBQUFBLFFBQ1YsYUFBYTtBQUFBLFFBQ2IsZUFBZTtBQUFBLFFBRWYsZUFBZTtBQUFBLE1BQ25CO0FBR0EsVUFBSSxVQUFVLENBQUMsR0FDWCxpQkFBaUIsQ0FBQyxHQUNsQjtBQUVKLGVBQVMsYUFBYSxNQUFNLE1BQU07QUFDOUIsWUFBSSxHQUNBLE9BQU8sS0FBSyxJQUFJLEtBQUssUUFBUSxLQUFLLE1BQU07QUFDNUMsYUFBSyxJQUFJLEdBQUcsSUFBSSxNQUFNLEtBQUssR0FBRztBQUMxQixjQUFJLEtBQUssQ0FBQyxNQUFNLEtBQUssQ0FBQyxHQUFHO0FBQ3JCLG1CQUFPO0FBQUEsVUFDWDtBQUFBLFFBQ0o7QUFDQSxlQUFPO0FBQUEsTUFDWDtBQUVBLGVBQVMsZ0JBQWdCLEtBQUs7QUFDMUIsZUFBTyxNQUFNLElBQUksWUFBWSxFQUFFLFFBQVEsS0FBSyxHQUFHLElBQUk7QUFBQSxNQUN2RDtBQUtBLGVBQVMsYUFBYSxPQUFPO0FBQ3pCLFlBQUksSUFBSSxHQUNKLEdBQ0EsTUFDQWIsU0FDQTtBQUVKLGVBQU8sSUFBSSxNQUFNLFFBQVE7QUFDckIsa0JBQVEsZ0JBQWdCLE1BQU0sQ0FBQyxDQUFDLEVBQUUsTUFBTSxHQUFHO0FBQzNDLGNBQUksTUFBTTtBQUNWLGlCQUFPLGdCQUFnQixNQUFNLElBQUksQ0FBQyxDQUFDO0FBQ25DLGlCQUFPLE9BQU8sS0FBSyxNQUFNLEdBQUcsSUFBSTtBQUNoQyxpQkFBTyxJQUFJLEdBQUc7QUFDVixZQUFBQSxVQUFTLFdBQVcsTUFBTSxNQUFNLEdBQUcsQ0FBQyxFQUFFLEtBQUssR0FBRyxDQUFDO0FBQy9DLGdCQUFJQSxTQUFRO0FBQ1IscUJBQU9BO0FBQUEsWUFDWDtBQUNBLGdCQUNJLFFBQ0EsS0FBSyxVQUFVLEtBQ2YsYUFBYSxPQUFPLElBQUksS0FBSyxJQUFJLEdBQ25DO0FBRUU7QUFBQSxZQUNKO0FBQ0E7QUFBQSxVQUNKO0FBQ0E7QUFBQSxRQUNKO0FBQ0EsZUFBTztBQUFBLE1BQ1g7QUFFQSxlQUFTLFdBQVcsTUFBTTtBQUN0QixZQUFJLFlBQVksTUFDWjtBQUVKLFlBQ0ksUUFBUSxJQUFJLE1BQU0sVUFDbEIsT0FBT0gsWUFBVyxlQUNsQkEsV0FDQUEsUUFBTyxTQUNUO0FBQ0UsY0FBSTtBQUNBLHdCQUFZLGFBQWE7QUFDekIsNkJBQWlCO0FBQ2pCLDJCQUFlLGNBQWMsSUFBSTtBQUNqQywrQkFBbUIsU0FBUztBQUFBLFVBQ2hDLFNBQVMsR0FBUDtBQUdFLG9CQUFRLElBQUksSUFBSTtBQUFBLFVBQ3BCO0FBQUEsUUFDSjtBQUNBLGVBQU8sUUFBUSxJQUFJO0FBQUEsTUFDdkI7QUFLQSxlQUFTLG1CQUFtQixLQUFLLFFBQVE7QUFDckMsWUFBSTtBQUNKLFlBQUksS0FBSztBQUNMLGNBQUksWUFBWSxNQUFNLEdBQUc7QUFDckIsbUJBQU8sVUFBVSxHQUFHO0FBQUEsVUFDeEIsT0FBTztBQUNILG1CQUFPLGFBQWEsS0FBSyxNQUFNO0FBQUEsVUFDbkM7QUFFQSxjQUFJLE1BQU07QUFFTiwyQkFBZTtBQUFBLFVBQ25CLE9BQU87QUFDSCxnQkFBSSxPQUFPLFlBQVksZUFBZSxRQUFRLE1BQU07QUFFaEQsc0JBQVE7QUFBQSxnQkFDSixZQUFZLE1BQU07QUFBQSxjQUN0QjtBQUFBLFlBQ0o7QUFBQSxVQUNKO0FBQUEsUUFDSjtBQUVBLGVBQU8sYUFBYTtBQUFBLE1BQ3hCO0FBRUEsZUFBUyxhQUFhLE1BQU0sUUFBUTtBQUNoQyxZQUFJLFdBQVcsTUFBTTtBQUNqQixjQUFJRyxTQUNBLGVBQWU7QUFDbkIsaUJBQU8sT0FBTztBQUNkLGNBQUksUUFBUSxJQUFJLEtBQUssTUFBTTtBQUN2QjtBQUFBLGNBQ0k7QUFBQSxjQUNBO0FBQUEsWUFJSjtBQUNBLDJCQUFlLFFBQVEsSUFBSSxFQUFFO0FBQUEsVUFDakMsV0FBVyxPQUFPLGdCQUFnQixNQUFNO0FBQ3BDLGdCQUFJLFFBQVEsT0FBTyxZQUFZLEtBQUssTUFBTTtBQUN0Qyw2QkFBZSxRQUFRLE9BQU8sWUFBWSxFQUFFO0FBQUEsWUFDaEQsT0FBTztBQUNILGNBQUFBLFVBQVMsV0FBVyxPQUFPLFlBQVk7QUFDdkMsa0JBQUlBLFdBQVUsTUFBTTtBQUNoQiwrQkFBZUEsUUFBTztBQUFBLGNBQzFCLE9BQU87QUFDSCxvQkFBSSxDQUFDLGVBQWUsT0FBTyxZQUFZLEdBQUc7QUFDdEMsaUNBQWUsT0FBTyxZQUFZLElBQUksQ0FBQztBQUFBLGdCQUMzQztBQUNBLCtCQUFlLE9BQU8sWUFBWSxFQUFFLEtBQUs7QUFBQSxrQkFDckM7QUFBQSxrQkFDQTtBQUFBLGdCQUNKLENBQUM7QUFDRCx1QkFBTztBQUFBLGNBQ1g7QUFBQSxZQUNKO0FBQUEsVUFDSjtBQUNBLGtCQUFRLElBQUksSUFBSSxJQUFJLE9BQU8sYUFBYSxjQUFjLE1BQU0sQ0FBQztBQUU3RCxjQUFJLGVBQWUsSUFBSSxHQUFHO0FBQ3RCLDJCQUFlLElBQUksRUFBRSxRQUFRLFNBQVUsR0FBRztBQUN0QywyQkFBYSxFQUFFLE1BQU0sRUFBRSxNQUFNO0FBQUEsWUFDakMsQ0FBQztBQUFBLFVBQ0w7QUFLQSw2QkFBbUIsSUFBSTtBQUV2QixpQkFBTyxRQUFRLElBQUk7QUFBQSxRQUN2QixPQUFPO0FBRUgsaUJBQU8sUUFBUSxJQUFJO0FBQ25CLGlCQUFPO0FBQUEsUUFDWDtBQUFBLE1BQ0o7QUFFQSxlQUFTLGFBQWEsTUFBTSxRQUFRO0FBQ2hDLFlBQUksVUFBVSxNQUFNO0FBQ2hCLGNBQUlBLFNBQ0EsV0FDQSxlQUFlO0FBRW5CLGNBQUksUUFBUSxJQUFJLEtBQUssUUFBUSxRQUFRLElBQUksRUFBRSxnQkFBZ0IsTUFBTTtBQUU3RCxvQkFBUSxJQUFJLEVBQUUsSUFBSSxhQUFhLFFBQVEsSUFBSSxFQUFFLFNBQVMsTUFBTSxDQUFDO0FBQUEsVUFDakUsT0FBTztBQUVILHdCQUFZLFdBQVcsSUFBSTtBQUMzQixnQkFBSSxhQUFhLE1BQU07QUFDbkIsNkJBQWUsVUFBVTtBQUFBLFlBQzdCO0FBQ0EscUJBQVMsYUFBYSxjQUFjLE1BQU07QUFDMUMsZ0JBQUksYUFBYSxNQUFNO0FBSW5CLHFCQUFPLE9BQU87QUFBQSxZQUNsQjtBQUNBLFlBQUFBLFVBQVMsSUFBSSxPQUFPLE1BQU07QUFDMUIsWUFBQUEsUUFBTyxlQUFlLFFBQVEsSUFBSTtBQUNsQyxvQkFBUSxJQUFJLElBQUlBO0FBQUEsVUFDcEI7QUFHQSw2QkFBbUIsSUFBSTtBQUFBLFFBQzNCLE9BQU87QUFFSCxjQUFJLFFBQVEsSUFBSSxLQUFLLE1BQU07QUFDdkIsZ0JBQUksUUFBUSxJQUFJLEVBQUUsZ0JBQWdCLE1BQU07QUFDcEMsc0JBQVEsSUFBSSxJQUFJLFFBQVEsSUFBSSxFQUFFO0FBQzlCLGtCQUFJLFNBQVMsbUJBQW1CLEdBQUc7QUFDL0IsbUNBQW1CLElBQUk7QUFBQSxjQUMzQjtBQUFBLFlBQ0osV0FBVyxRQUFRLElBQUksS0FBSyxNQUFNO0FBQzlCLHFCQUFPLFFBQVEsSUFBSTtBQUFBLFlBQ3ZCO0FBQUEsVUFDSjtBQUFBLFFBQ0o7QUFDQSxlQUFPLFFBQVEsSUFBSTtBQUFBLE1BQ3ZCO0FBR0EsZUFBUyxVQUFVLEtBQUs7QUFDcEIsWUFBSUE7QUFFSixZQUFJLE9BQU8sSUFBSSxXQUFXLElBQUksUUFBUSxPQUFPO0FBQ3pDLGdCQUFNLElBQUksUUFBUTtBQUFBLFFBQ3RCO0FBRUEsWUFBSSxDQUFDLEtBQUs7QUFDTixpQkFBTztBQUFBLFFBQ1g7QUFFQSxZQUFJLENBQUMsUUFBUSxHQUFHLEdBQUc7QUFFZixVQUFBQSxVQUFTLFdBQVcsR0FBRztBQUN2QixjQUFJQSxTQUFRO0FBQ1IsbUJBQU9BO0FBQUEsVUFDWDtBQUNBLGdCQUFNLENBQUMsR0FBRztBQUFBLFFBQ2Q7QUFFQSxlQUFPLGFBQWEsR0FBRztBQUFBLE1BQzNCO0FBRUEsZUFBUyxjQUFjO0FBQ25CLGVBQU8sS0FBSyxPQUFPO0FBQUEsTUFDdkI7QUFFQSxlQUFTLGNBQWMsR0FBRztBQUN0QixZQUFJLFVBQ0EsSUFBSSxFQUFFO0FBRVYsWUFBSSxLQUFLLGdCQUFnQixDQUFDLEVBQUUsYUFBYSxJQUFJO0FBQ3pDLHFCQUNJLEVBQUUsS0FBSyxJQUFJLEtBQUssRUFBRSxLQUFLLElBQUksS0FDckIsUUFDQSxFQUFFLElBQUksSUFBSSxLQUFLLEVBQUUsSUFBSSxJQUFJLFlBQVksRUFBRSxJQUFJLEdBQUcsRUFBRSxLQUFLLENBQUMsSUFDdEQsT0FDQSxFQUFFLElBQUksSUFBSSxLQUNWLEVBQUUsSUFBSSxJQUFJLE1BQ1QsRUFBRSxJQUFJLE1BQU0sT0FDUixFQUFFLE1BQU0sTUFBTSxLQUNYLEVBQUUsTUFBTSxNQUFNLEtBQ2QsRUFBRSxXQUFXLE1BQU0sS0FDM0IsT0FDQSxFQUFFLE1BQU0sSUFBSSxLQUFLLEVBQUUsTUFBTSxJQUFJLEtBQzdCLFNBQ0EsRUFBRSxNQUFNLElBQUksS0FBSyxFQUFFLE1BQU0sSUFBSSxLQUM3QixTQUNBLEVBQUUsV0FBVyxJQUFJLEtBQUssRUFBRSxXQUFXLElBQUksTUFDdkMsY0FDQTtBQUVWLGNBQ0ksZ0JBQWdCLENBQUMsRUFBRSx1QkFDbEIsV0FBVyxRQUFRLFdBQVcsT0FDakM7QUFDRSx1QkFBVztBQUFBLFVBQ2Y7QUFDQSxjQUFJLGdCQUFnQixDQUFDLEVBQUUsa0JBQWtCLGFBQWEsSUFBSTtBQUN0RCx1QkFBVztBQUFBLFVBQ2Y7QUFDQSxjQUFJLGdCQUFnQixDQUFDLEVBQUUsb0JBQW9CLGFBQWEsSUFBSTtBQUN4RCx1QkFBVztBQUFBLFVBQ2Y7QUFFQSwwQkFBZ0IsQ0FBQyxFQUFFLFdBQVc7QUFBQSxRQUNsQztBQUVBLGVBQU87QUFBQSxNQUNYO0FBSUEsVUFBSSxtQkFBbUIsa0pBQ25CLGdCQUFnQiw4SUFDaEIsVUFBVSx5QkFDVixXQUFXO0FBQUEsUUFDUCxDQUFDLGdCQUFnQixxQkFBcUI7QUFBQSxRQUN0QyxDQUFDLGNBQWMsaUJBQWlCO0FBQUEsUUFDaEMsQ0FBQyxnQkFBZ0IsZ0JBQWdCO0FBQUEsUUFDakMsQ0FBQyxjQUFjLGVBQWUsS0FBSztBQUFBLFFBQ25DLENBQUMsWUFBWSxhQUFhO0FBQUEsUUFDMUIsQ0FBQyxXQUFXLGNBQWMsS0FBSztBQUFBLFFBQy9CLENBQUMsY0FBYyxZQUFZO0FBQUEsUUFDM0IsQ0FBQyxZQUFZLE9BQU87QUFBQSxRQUNwQixDQUFDLGNBQWMsYUFBYTtBQUFBLFFBQzVCLENBQUMsYUFBYSxlQUFlLEtBQUs7QUFBQSxRQUNsQyxDQUFDLFdBQVcsT0FBTztBQUFBLFFBQ25CLENBQUMsVUFBVSxTQUFTLEtBQUs7QUFBQSxRQUN6QixDQUFDLFFBQVEsU0FBUyxLQUFLO0FBQUEsTUFDM0IsR0FFQSxXQUFXO0FBQUEsUUFDUCxDQUFDLGlCQUFpQixxQkFBcUI7QUFBQSxRQUN2QyxDQUFDLGlCQUFpQixvQkFBb0I7QUFBQSxRQUN0QyxDQUFDLFlBQVksZ0JBQWdCO0FBQUEsUUFDN0IsQ0FBQyxTQUFTLFdBQVc7QUFBQSxRQUNyQixDQUFDLGVBQWUsbUJBQW1CO0FBQUEsUUFDbkMsQ0FBQyxlQUFlLGtCQUFrQjtBQUFBLFFBQ2xDLENBQUMsVUFBVSxjQUFjO0FBQUEsUUFDekIsQ0FBQyxRQUFRLFVBQVU7QUFBQSxRQUNuQixDQUFDLE1BQU0sTUFBTTtBQUFBLE1BQ2pCLEdBQ0Esa0JBQWtCLHNCQUVsQixVQUFVLDJMQUNWLGFBQWE7QUFBQSxRQUNULElBQUk7QUFBQSxRQUNKLEtBQUs7QUFBQSxRQUNMLEtBQUssS0FBSztBQUFBLFFBQ1YsS0FBSyxLQUFLO0FBQUEsUUFDVixLQUFLLEtBQUs7QUFBQSxRQUNWLEtBQUssS0FBSztBQUFBLFFBQ1YsS0FBSyxLQUFLO0FBQUEsUUFDVixLQUFLLEtBQUs7QUFBQSxRQUNWLEtBQUssS0FBSztBQUFBLFFBQ1YsS0FBSyxLQUFLO0FBQUEsTUFDZDtBQUdKLGVBQVMsY0FBYyxRQUFRO0FBQzNCLFlBQUksR0FDQSxHQUNBVSxVQUFTLE9BQU8sSUFDaEIsUUFBUSxpQkFBaUIsS0FBS0EsT0FBTSxLQUFLLGNBQWMsS0FBS0EsT0FBTSxHQUNsRSxXQUNBLFlBQ0EsWUFDQTtBQUVKLFlBQUksT0FBTztBQUNQLDBCQUFnQixNQUFNLEVBQUUsTUFBTTtBQUU5QixlQUFLLElBQUksR0FBRyxJQUFJLFNBQVMsUUFBUSxJQUFJLEdBQUcsS0FBSztBQUN6QyxnQkFBSSxTQUFTLENBQUMsRUFBRSxDQUFDLEVBQUUsS0FBSyxNQUFNLENBQUMsQ0FBQyxHQUFHO0FBQy9CLDJCQUFhLFNBQVMsQ0FBQyxFQUFFLENBQUM7QUFDMUIsMEJBQVksU0FBUyxDQUFDLEVBQUUsQ0FBQyxNQUFNO0FBQy9CO0FBQUEsWUFDSjtBQUFBLFVBQ0o7QUFDQSxjQUFJLGNBQWMsTUFBTTtBQUNwQixtQkFBTyxXQUFXO0FBQ2xCO0FBQUEsVUFDSjtBQUNBLGNBQUksTUFBTSxDQUFDLEdBQUc7QUFDVixpQkFBSyxJQUFJLEdBQUcsSUFBSSxTQUFTLFFBQVEsSUFBSSxHQUFHLEtBQUs7QUFDekMsa0JBQUksU0FBUyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEtBQUssTUFBTSxDQUFDLENBQUMsR0FBRztBQUUvQiw4QkFBYyxNQUFNLENBQUMsS0FBSyxPQUFPLFNBQVMsQ0FBQyxFQUFFLENBQUM7QUFDOUM7QUFBQSxjQUNKO0FBQUEsWUFDSjtBQUNBLGdCQUFJLGNBQWMsTUFBTTtBQUNwQixxQkFBTyxXQUFXO0FBQ2xCO0FBQUEsWUFDSjtBQUFBLFVBQ0o7QUFDQSxjQUFJLENBQUMsYUFBYSxjQUFjLE1BQU07QUFDbEMsbUJBQU8sV0FBVztBQUNsQjtBQUFBLFVBQ0o7QUFDQSxjQUFJLE1BQU0sQ0FBQyxHQUFHO0FBQ1YsZ0JBQUksUUFBUSxLQUFLLE1BQU0sQ0FBQyxDQUFDLEdBQUc7QUFDeEIseUJBQVc7QUFBQSxZQUNmLE9BQU87QUFDSCxxQkFBTyxXQUFXO0FBQ2xCO0FBQUEsWUFDSjtBQUFBLFVBQ0o7QUFDQSxpQkFBTyxLQUFLLGNBQWMsY0FBYyxPQUFPLFlBQVk7QUFDM0Qsb0NBQTBCLE1BQU07QUFBQSxRQUNwQyxPQUFPO0FBQ0gsaUJBQU8sV0FBVztBQUFBLFFBQ3RCO0FBQUEsTUFDSjtBQUVBLGVBQVMsMEJBQ0wsU0FDQSxVQUNBLFFBQ0EsU0FDQSxXQUNBLFdBQ0Y7QUFDRSxZQUFJLFNBQVM7QUFBQSxVQUNULGVBQWUsT0FBTztBQUFBLFVBQ3RCLHlCQUF5QixRQUFRLFFBQVE7QUFBQSxVQUN6QyxTQUFTLFFBQVEsRUFBRTtBQUFBLFVBQ25CLFNBQVMsU0FBUyxFQUFFO0FBQUEsVUFDcEIsU0FBUyxXQUFXLEVBQUU7QUFBQSxRQUMxQjtBQUVBLFlBQUksV0FBVztBQUNYLGlCQUFPLEtBQUssU0FBUyxXQUFXLEVBQUUsQ0FBQztBQUFBLFFBQ3ZDO0FBRUEsZUFBTztBQUFBLE1BQ1g7QUFFQSxlQUFTLGVBQWUsU0FBUztBQUM3QixZQUFJLE9BQU8sU0FBUyxTQUFTLEVBQUU7QUFDL0IsWUFBSSxRQUFRLElBQUk7QUFDWixpQkFBTyxNQUFPO0FBQUEsUUFDbEIsV0FBVyxRQUFRLEtBQUs7QUFDcEIsaUJBQU8sT0FBTztBQUFBLFFBQ2xCO0FBQ0EsZUFBTztBQUFBLE1BQ1g7QUFFQSxlQUFTLGtCQUFrQixHQUFHO0FBRTFCLGVBQU8sRUFDRixRQUFRLHFCQUFxQixHQUFHLEVBQ2hDLFFBQVEsWUFBWSxHQUFHLEVBQ3ZCLFFBQVEsVUFBVSxFQUFFLEVBQ3BCLFFBQVEsVUFBVSxFQUFFO0FBQUEsTUFDN0I7QUFFQSxlQUFTLGFBQWEsWUFBWSxhQUFhLFFBQVE7QUFDbkQsWUFBSSxZQUFZO0FBRVosY0FBSSxrQkFBa0IsMkJBQTJCLFFBQVEsVUFBVSxHQUMvRCxnQkFBZ0IsSUFBSTtBQUFBLFlBQ2hCLFlBQVksQ0FBQztBQUFBLFlBQ2IsWUFBWSxDQUFDO0FBQUEsWUFDYixZQUFZLENBQUM7QUFBQSxVQUNqQixFQUFFLE9BQU87QUFDYixjQUFJLG9CQUFvQixlQUFlO0FBQ25DLDRCQUFnQixNQUFNLEVBQUUsa0JBQWtCO0FBQzFDLG1CQUFPLFdBQVc7QUFDbEIsbUJBQU87QUFBQSxVQUNYO0FBQUEsUUFDSjtBQUNBLGVBQU87QUFBQSxNQUNYO0FBRUEsZUFBUyxnQkFBZ0IsV0FBVyxnQkFBZ0IsV0FBVztBQUMzRCxZQUFJLFdBQVc7QUFDWCxpQkFBTyxXQUFXLFNBQVM7QUFBQSxRQUMvQixXQUFXLGdCQUFnQjtBQUV2QixpQkFBTztBQUFBLFFBQ1gsT0FBTztBQUNILGNBQUksS0FBSyxTQUFTLFdBQVcsRUFBRSxHQUMzQixJQUFJLEtBQUssS0FDVCxLQUFLLEtBQUssS0FBSztBQUNuQixpQkFBTyxJQUFJLEtBQUs7QUFBQSxRQUNwQjtBQUFBLE1BQ0o7QUFHQSxlQUFTLGtCQUFrQixRQUFRO0FBQy9CLFlBQUksUUFBUSxRQUFRLEtBQUssa0JBQWtCLE9BQU8sRUFBRSxDQUFDLEdBQ2pEO0FBQ0osWUFBSSxPQUFPO0FBQ1Asd0JBQWM7QUFBQSxZQUNWLE1BQU0sQ0FBQztBQUFBLFlBQ1AsTUFBTSxDQUFDO0FBQUEsWUFDUCxNQUFNLENBQUM7QUFBQSxZQUNQLE1BQU0sQ0FBQztBQUFBLFlBQ1AsTUFBTSxDQUFDO0FBQUEsWUFDUCxNQUFNLENBQUM7QUFBQSxVQUNYO0FBQ0EsY0FBSSxDQUFDLGFBQWEsTUFBTSxDQUFDLEdBQUcsYUFBYSxNQUFNLEdBQUc7QUFDOUM7QUFBQSxVQUNKO0FBRUEsaUJBQU8sS0FBSztBQUNaLGlCQUFPLE9BQU8sZ0JBQWdCLE1BQU0sQ0FBQyxHQUFHLE1BQU0sQ0FBQyxHQUFHLE1BQU0sRUFBRSxDQUFDO0FBRTNELGlCQUFPLEtBQUssY0FBYyxNQUFNLE1BQU0sT0FBTyxFQUFFO0FBQy9DLGlCQUFPLEdBQUcsY0FBYyxPQUFPLEdBQUcsY0FBYyxJQUFJLE9BQU8sSUFBSTtBQUUvRCwwQkFBZ0IsTUFBTSxFQUFFLFVBQVU7QUFBQSxRQUN0QyxPQUFPO0FBQ0gsaUJBQU8sV0FBVztBQUFBLFFBQ3RCO0FBQUEsTUFDSjtBQUdBLGVBQVMsaUJBQWlCLFFBQVE7QUFDOUIsWUFBSSxVQUFVLGdCQUFnQixLQUFLLE9BQU8sRUFBRTtBQUM1QyxZQUFJLFlBQVksTUFBTTtBQUNsQixpQkFBTyxLQUFLLElBQUksS0FBSyxDQUFDLFFBQVEsQ0FBQyxDQUFDO0FBQ2hDO0FBQUEsUUFDSjtBQUVBLHNCQUFjLE1BQU07QUFDcEIsWUFBSSxPQUFPLGFBQWEsT0FBTztBQUMzQixpQkFBTyxPQUFPO0FBQUEsUUFDbEIsT0FBTztBQUNIO0FBQUEsUUFDSjtBQUVBLDBCQUFrQixNQUFNO0FBQ3hCLFlBQUksT0FBTyxhQUFhLE9BQU87QUFDM0IsaUJBQU8sT0FBTztBQUFBLFFBQ2xCLE9BQU87QUFDSDtBQUFBLFFBQ0o7QUFFQSxZQUFJLE9BQU8sU0FBUztBQUNoQixpQkFBTyxXQUFXO0FBQUEsUUFDdEIsT0FBTztBQUVILGdCQUFNLHdCQUF3QixNQUFNO0FBQUEsUUFDeEM7QUFBQSxNQUNKO0FBRUEsWUFBTSwwQkFBMEI7QUFBQSxRQUM1QjtBQUFBLFFBR0EsU0FBVSxRQUFRO0FBQ2QsaUJBQU8sS0FBSyxJQUFJLEtBQUssT0FBTyxNQUFNLE9BQU8sVUFBVSxTQUFTLEdBQUc7QUFBQSxRQUNuRTtBQUFBLE1BQ0o7QUFHQSxlQUFTLFNBQVMsR0FBRyxHQUFHLEdBQUc7QUFDdkIsWUFBSSxLQUFLLE1BQU07QUFDWCxpQkFBTztBQUFBLFFBQ1g7QUFDQSxZQUFJLEtBQUssTUFBTTtBQUNYLGlCQUFPO0FBQUEsUUFDWDtBQUNBLGVBQU87QUFBQSxNQUNYO0FBRUEsZUFBUyxpQkFBaUIsUUFBUTtBQUU5QixZQUFJLFdBQVcsSUFBSSxLQUFLLE1BQU0sSUFBSSxDQUFDO0FBQ25DLFlBQUksT0FBTyxTQUFTO0FBQ2hCLGlCQUFPO0FBQUEsWUFDSCxTQUFTLGVBQWU7QUFBQSxZQUN4QixTQUFTLFlBQVk7QUFBQSxZQUNyQixTQUFTLFdBQVc7QUFBQSxVQUN4QjtBQUFBLFFBQ0o7QUFDQSxlQUFPLENBQUMsU0FBUyxZQUFZLEdBQUcsU0FBUyxTQUFTLEdBQUcsU0FBUyxRQUFRLENBQUM7QUFBQSxNQUMzRTtBQU1BLGVBQVMsZ0JBQWdCLFFBQVE7QUFDN0IsWUFBSSxHQUNBLE1BQ0EsUUFBUSxDQUFDLEdBQ1QsYUFDQSxpQkFDQTtBQUVKLFlBQUksT0FBTyxJQUFJO0FBQ1g7QUFBQSxRQUNKO0FBRUEsc0JBQWMsaUJBQWlCLE1BQU07QUFHckMsWUFBSSxPQUFPLE1BQU0sT0FBTyxHQUFHLElBQUksS0FBSyxRQUFRLE9BQU8sR0FBRyxLQUFLLEtBQUssTUFBTTtBQUNsRSxnQ0FBc0IsTUFBTTtBQUFBLFFBQ2hDO0FBR0EsWUFBSSxPQUFPLGNBQWMsTUFBTTtBQUMzQixzQkFBWSxTQUFTLE9BQU8sR0FBRyxJQUFJLEdBQUcsWUFBWSxJQUFJLENBQUM7QUFFdkQsY0FDSSxPQUFPLGFBQWEsV0FBVyxTQUFTLEtBQ3hDLE9BQU8sZUFBZSxHQUN4QjtBQUNFLDRCQUFnQixNQUFNLEVBQUUscUJBQXFCO0FBQUEsVUFDakQ7QUFFQSxpQkFBTyxjQUFjLFdBQVcsR0FBRyxPQUFPLFVBQVU7QUFDcEQsaUJBQU8sR0FBRyxLQUFLLElBQUksS0FBSyxZQUFZO0FBQ3BDLGlCQUFPLEdBQUcsSUFBSSxJQUFJLEtBQUssV0FBVztBQUFBLFFBQ3RDO0FBT0EsYUFBSyxJQUFJLEdBQUcsSUFBSSxLQUFLLE9BQU8sR0FBRyxDQUFDLEtBQUssTUFBTSxFQUFFLEdBQUc7QUFDNUMsaUJBQU8sR0FBRyxDQUFDLElBQUksTUFBTSxDQUFDLElBQUksWUFBWSxDQUFDO0FBQUEsUUFDM0M7QUFHQSxlQUFPLElBQUksR0FBRyxLQUFLO0FBQ2YsaUJBQU8sR0FBRyxDQUFDLElBQUksTUFBTSxDQUFDLElBQ2xCLE9BQU8sR0FBRyxDQUFDLEtBQUssT0FBUSxNQUFNLElBQUksSUFBSSxJQUFLLE9BQU8sR0FBRyxDQUFDO0FBQUEsUUFDOUQ7QUFHQSxZQUNJLE9BQU8sR0FBRyxJQUFJLE1BQU0sTUFDcEIsT0FBTyxHQUFHLE1BQU0sTUFBTSxLQUN0QixPQUFPLEdBQUcsTUFBTSxNQUFNLEtBQ3RCLE9BQU8sR0FBRyxXQUFXLE1BQU0sR0FDN0I7QUFDRSxpQkFBTyxXQUFXO0FBQ2xCLGlCQUFPLEdBQUcsSUFBSSxJQUFJO0FBQUEsUUFDdEI7QUFFQSxlQUFPLE1BQU0sT0FBTyxVQUFVLGdCQUFnQixZQUFZO0FBQUEsVUFDdEQ7QUFBQSxVQUNBO0FBQUEsUUFDSjtBQUNBLDBCQUFrQixPQUFPLFVBQ25CLE9BQU8sR0FBRyxVQUFVLElBQ3BCLE9BQU8sR0FBRyxPQUFPO0FBSXZCLFlBQUksT0FBTyxRQUFRLE1BQU07QUFDckIsaUJBQU8sR0FBRyxjQUFjLE9BQU8sR0FBRyxjQUFjLElBQUksT0FBTyxJQUFJO0FBQUEsUUFDbkU7QUFFQSxZQUFJLE9BQU8sVUFBVTtBQUNqQixpQkFBTyxHQUFHLElBQUksSUFBSTtBQUFBLFFBQ3RCO0FBR0EsWUFDSSxPQUFPLE1BQ1AsT0FBTyxPQUFPLEdBQUcsTUFBTSxlQUN2QixPQUFPLEdBQUcsTUFBTSxpQkFDbEI7QUFDRSwwQkFBZ0IsTUFBTSxFQUFFLGtCQUFrQjtBQUFBLFFBQzlDO0FBQUEsTUFDSjtBQUVBLGVBQVMsc0JBQXNCLFFBQVE7QUFDbkMsWUFBSSxHQUFHLFVBQVUsTUFBTSxTQUFTLEtBQUssS0FBSyxNQUFNLGlCQUFpQjtBQUVqRSxZQUFJLE9BQU87QUFDWCxZQUFJLEVBQUUsTUFBTSxRQUFRLEVBQUUsS0FBSyxRQUFRLEVBQUUsS0FBSyxNQUFNO0FBQzVDLGdCQUFNO0FBQ04sZ0JBQU07QUFNTixxQkFBVztBQUFBLFlBQ1AsRUFBRTtBQUFBLFlBQ0YsT0FBTyxHQUFHLElBQUk7QUFBQSxZQUNkLFdBQVcsWUFBWSxHQUFHLEdBQUcsQ0FBQyxFQUFFO0FBQUEsVUFDcEM7QUFDQSxpQkFBTyxTQUFTLEVBQUUsR0FBRyxDQUFDO0FBQ3RCLG9CQUFVLFNBQVMsRUFBRSxHQUFHLENBQUM7QUFDekIsY0FBSSxVQUFVLEtBQUssVUFBVSxHQUFHO0FBQzVCLDhCQUFrQjtBQUFBLFVBQ3RCO0FBQUEsUUFDSixPQUFPO0FBQ0gsZ0JBQU0sT0FBTyxRQUFRLE1BQU07QUFDM0IsZ0JBQU0sT0FBTyxRQUFRLE1BQU07QUFFM0Isb0JBQVUsV0FBVyxZQUFZLEdBQUcsS0FBSyxHQUFHO0FBRTVDLHFCQUFXLFNBQVMsRUFBRSxJQUFJLE9BQU8sR0FBRyxJQUFJLEdBQUcsUUFBUSxJQUFJO0FBR3ZELGlCQUFPLFNBQVMsRUFBRSxHQUFHLFFBQVEsSUFBSTtBQUVqQyxjQUFJLEVBQUUsS0FBSyxNQUFNO0FBRWIsc0JBQVUsRUFBRTtBQUNaLGdCQUFJLFVBQVUsS0FBSyxVQUFVLEdBQUc7QUFDNUIsZ0NBQWtCO0FBQUEsWUFDdEI7QUFBQSxVQUNKLFdBQVcsRUFBRSxLQUFLLE1BQU07QUFFcEIsc0JBQVUsRUFBRSxJQUFJO0FBQ2hCLGdCQUFJLEVBQUUsSUFBSSxLQUFLLEVBQUUsSUFBSSxHQUFHO0FBQ3BCLGdDQUFrQjtBQUFBLFlBQ3RCO0FBQUEsVUFDSixPQUFPO0FBRUgsc0JBQVU7QUFBQSxVQUNkO0FBQUEsUUFDSjtBQUNBLFlBQUksT0FBTyxLQUFLLE9BQU8sWUFBWSxVQUFVLEtBQUssR0FBRyxHQUFHO0FBQ3BELDBCQUFnQixNQUFNLEVBQUUsaUJBQWlCO0FBQUEsUUFDN0MsV0FBVyxtQkFBbUIsTUFBTTtBQUNoQywwQkFBZ0IsTUFBTSxFQUFFLG1CQUFtQjtBQUFBLFFBQy9DLE9BQU87QUFDSCxpQkFBTyxtQkFBbUIsVUFBVSxNQUFNLFNBQVMsS0FBSyxHQUFHO0FBQzNELGlCQUFPLEdBQUcsSUFBSSxJQUFJLEtBQUs7QUFDdkIsaUJBQU8sYUFBYSxLQUFLO0FBQUEsUUFDN0I7QUFBQSxNQUNKO0FBR0EsWUFBTSxXQUFXLFdBQVk7QUFBQSxNQUFDO0FBRzlCLFlBQU0sV0FBVyxXQUFZO0FBQUEsTUFBQztBQUc5QixlQUFTLDBCQUEwQixRQUFRO0FBRXZDLFlBQUksT0FBTyxPQUFPLE1BQU0sVUFBVTtBQUM5Qix3QkFBYyxNQUFNO0FBQ3BCO0FBQUEsUUFDSjtBQUNBLFlBQUksT0FBTyxPQUFPLE1BQU0sVUFBVTtBQUM5Qiw0QkFBa0IsTUFBTTtBQUN4QjtBQUFBLFFBQ0o7QUFDQSxlQUFPLEtBQUssQ0FBQztBQUNiLHdCQUFnQixNQUFNLEVBQUUsUUFBUTtBQUdoQyxZQUFJQSxVQUFTLEtBQUssT0FBTyxJQUNyQixHQUNBLGFBQ0FLLFNBQ0FSLFFBQ0EsU0FDQSxlQUFlRyxRQUFPLFFBQ3RCLHlCQUF5QixHQUN6QjtBQUVKLFFBQUFLLFVBQ0ksYUFBYSxPQUFPLElBQUksT0FBTyxPQUFPLEVBQUUsTUFBTSxnQkFBZ0IsS0FBSyxDQUFDO0FBRXhFLGFBQUssSUFBSSxHQUFHLElBQUlBLFFBQU8sUUFBUSxLQUFLO0FBQ2hDLFVBQUFSLFNBQVFRLFFBQU8sQ0FBQztBQUNoQix5QkFBZUwsUUFBTyxNQUFNLHNCQUFzQkgsUUFBTyxNQUFNLENBQUMsS0FDNUQsQ0FBQyxHQUFHLENBQUM7QUFDVCxjQUFJLGFBQWE7QUFDYixzQkFBVUcsUUFBTyxPQUFPLEdBQUdBLFFBQU8sUUFBUSxXQUFXLENBQUM7QUFDdEQsZ0JBQUksUUFBUSxTQUFTLEdBQUc7QUFDcEIsOEJBQWdCLE1BQU0sRUFBRSxZQUFZLEtBQUssT0FBTztBQUFBLFlBQ3BEO0FBQ0EsWUFBQUEsVUFBU0EsUUFBTztBQUFBLGNBQ1pBLFFBQU8sUUFBUSxXQUFXLElBQUksWUFBWTtBQUFBLFlBQzlDO0FBQ0Esc0NBQTBCLFlBQVk7QUFBQSxVQUMxQztBQUVBLGNBQUkscUJBQXFCSCxNQUFLLEdBQUc7QUFDN0IsZ0JBQUksYUFBYTtBQUNiLDhCQUFnQixNQUFNLEVBQUUsUUFBUTtBQUFBLFlBQ3BDLE9BQU87QUFDSCw4QkFBZ0IsTUFBTSxFQUFFLGFBQWEsS0FBS0EsTUFBSztBQUFBLFlBQ25EO0FBQ0Esb0NBQXdCQSxRQUFPLGFBQWEsTUFBTTtBQUFBLFVBQ3RELFdBQVcsT0FBTyxXQUFXLENBQUMsYUFBYTtBQUN2Qyw0QkFBZ0IsTUFBTSxFQUFFLGFBQWEsS0FBS0EsTUFBSztBQUFBLFVBQ25EO0FBQUEsUUFDSjtBQUdBLHdCQUFnQixNQUFNLEVBQUUsZ0JBQ3BCLGVBQWU7QUFDbkIsWUFBSUcsUUFBTyxTQUFTLEdBQUc7QUFDbkIsMEJBQWdCLE1BQU0sRUFBRSxZQUFZLEtBQUtBLE9BQU07QUFBQSxRQUNuRDtBQUdBLFlBQ0ksT0FBTyxHQUFHLElBQUksS0FBSyxNQUNuQixnQkFBZ0IsTUFBTSxFQUFFLFlBQVksUUFDcEMsT0FBTyxHQUFHLElBQUksSUFBSSxHQUNwQjtBQUNFLDBCQUFnQixNQUFNLEVBQUUsVUFBVTtBQUFBLFFBQ3RDO0FBRUEsd0JBQWdCLE1BQU0sRUFBRSxrQkFBa0IsT0FBTyxHQUFHLE1BQU0sQ0FBQztBQUMzRCx3QkFBZ0IsTUFBTSxFQUFFLFdBQVcsT0FBTztBQUUxQyxlQUFPLEdBQUcsSUFBSSxJQUFJO0FBQUEsVUFDZCxPQUFPO0FBQUEsVUFDUCxPQUFPLEdBQUcsSUFBSTtBQUFBLFVBQ2QsT0FBTztBQUFBLFFBQ1g7QUFHQSxjQUFNLGdCQUFnQixNQUFNLEVBQUU7QUFDOUIsWUFBSSxRQUFRLE1BQU07QUFDZCxpQkFBTyxHQUFHLElBQUksSUFBSSxPQUFPLFFBQVEsZ0JBQWdCLEtBQUssT0FBTyxHQUFHLElBQUksQ0FBQztBQUFBLFFBQ3pFO0FBRUEsd0JBQWdCLE1BQU07QUFDdEIsc0JBQWMsTUFBTTtBQUFBLE1BQ3hCO0FBRUEsZUFBUyxnQkFBZ0JWLFNBQVEsTUFBTWdCLFdBQVU7QUFDN0MsWUFBSTtBQUVKLFlBQUlBLGFBQVksTUFBTTtBQUVsQixpQkFBTztBQUFBLFFBQ1g7QUFDQSxZQUFJaEIsUUFBTyxnQkFBZ0IsTUFBTTtBQUM3QixpQkFBT0EsUUFBTyxhQUFhLE1BQU1nQixTQUFRO0FBQUEsUUFDN0MsV0FBV2hCLFFBQU8sUUFBUSxNQUFNO0FBRTVCLGlCQUFPQSxRQUFPLEtBQUtnQixTQUFRO0FBQzNCLGNBQUksUUFBUSxPQUFPLElBQUk7QUFDbkIsb0JBQVE7QUFBQSxVQUNaO0FBQ0EsY0FBSSxDQUFDLFFBQVEsU0FBUyxJQUFJO0FBQ3RCLG1CQUFPO0FBQUEsVUFDWDtBQUNBLGlCQUFPO0FBQUEsUUFDWCxPQUFPO0FBRUgsaUJBQU87QUFBQSxRQUNYO0FBQUEsTUFDSjtBQUdBLGVBQVMseUJBQXlCLFFBQVE7QUFDdEMsWUFBSSxZQUNBLFlBQ0EsYUFDQSxHQUNBLGNBQ0Esa0JBQ0Esb0JBQW9CO0FBRXhCLFlBQUksT0FBTyxHQUFHLFdBQVcsR0FBRztBQUN4QiwwQkFBZ0IsTUFBTSxFQUFFLGdCQUFnQjtBQUN4QyxpQkFBTyxLQUFLLElBQUksS0FBSyxHQUFHO0FBQ3hCO0FBQUEsUUFDSjtBQUVBLGFBQUssSUFBSSxHQUFHLElBQUksT0FBTyxHQUFHLFFBQVEsS0FBSztBQUNuQyx5QkFBZTtBQUNmLDZCQUFtQjtBQUNuQix1QkFBYSxXQUFXLENBQUMsR0FBRyxNQUFNO0FBQ2xDLGNBQUksT0FBTyxXQUFXLE1BQU07QUFDeEIsdUJBQVcsVUFBVSxPQUFPO0FBQUEsVUFDaEM7QUFDQSxxQkFBVyxLQUFLLE9BQU8sR0FBRyxDQUFDO0FBQzNCLG9DQUEwQixVQUFVO0FBRXBDLGNBQUksUUFBUSxVQUFVLEdBQUc7QUFDckIsK0JBQW1CO0FBQUEsVUFDdkI7QUFHQSwwQkFBZ0IsZ0JBQWdCLFVBQVUsRUFBRTtBQUc1QywwQkFBZ0IsZ0JBQWdCLFVBQVUsRUFBRSxhQUFhLFNBQVM7QUFFbEUsMEJBQWdCLFVBQVUsRUFBRSxRQUFRO0FBRXBDLGNBQUksQ0FBQyxtQkFBbUI7QUFDcEIsZ0JBQ0ksZUFBZSxRQUNmLGVBQWUsZUFDZixrQkFDRjtBQUNFLDRCQUFjO0FBQ2QsMkJBQWE7QUFDYixrQkFBSSxrQkFBa0I7QUFDbEIsb0NBQW9CO0FBQUEsY0FDeEI7QUFBQSxZQUNKO0FBQUEsVUFDSixPQUFPO0FBQ0gsZ0JBQUksZUFBZSxhQUFhO0FBQzVCLDRCQUFjO0FBQ2QsMkJBQWE7QUFBQSxZQUNqQjtBQUFBLFVBQ0o7QUFBQSxRQUNKO0FBRUEsZUFBTyxRQUFRLGNBQWMsVUFBVTtBQUFBLE1BQzNDO0FBRUEsZUFBUyxpQkFBaUIsUUFBUTtBQUM5QixZQUFJLE9BQU8sSUFBSTtBQUNYO0FBQUEsUUFDSjtBQUVBLFlBQUksSUFBSSxxQkFBcUIsT0FBTyxFQUFFLEdBQ2xDLFlBQVksRUFBRSxRQUFRLFNBQVksRUFBRSxPQUFPLEVBQUU7QUFDakQsZUFBTyxLQUFLbEI7QUFBQSxVQUNSLENBQUMsRUFBRSxNQUFNLEVBQUUsT0FBTyxXQUFXLEVBQUUsTUFBTSxFQUFFLFFBQVEsRUFBRSxRQUFRLEVBQUUsV0FBVztBQUFBLFVBQ3RFLFNBQVUsS0FBSztBQUNYLG1CQUFPLE9BQU8sU0FBUyxLQUFLLEVBQUU7QUFBQSxVQUNsQztBQUFBLFFBQ0o7QUFFQSx3QkFBZ0IsTUFBTTtBQUFBLE1BQzFCO0FBRUEsZUFBUyxpQkFBaUIsUUFBUTtBQUM5QixZQUFJLE1BQU0sSUFBSSxPQUFPLGNBQWMsY0FBYyxNQUFNLENBQUMsQ0FBQztBQUN6RCxZQUFJLElBQUksVUFBVTtBQUVkLGNBQUksSUFBSSxHQUFHLEdBQUc7QUFDZCxjQUFJLFdBQVc7QUFBQSxRQUNuQjtBQUVBLGVBQU87QUFBQSxNQUNYO0FBRUEsZUFBUyxjQUFjLFFBQVE7QUFDM0IsWUFBSSxRQUFRLE9BQU8sSUFDZkMsVUFBUyxPQUFPO0FBRXBCLGVBQU8sVUFBVSxPQUFPLFdBQVcsVUFBVSxPQUFPLEVBQUU7QUFFdEQsWUFBSSxVQUFVLFFBQVNBLFlBQVcsVUFBYSxVQUFVLElBQUs7QUFDMUQsaUJBQU8sY0FBYyxFQUFFLFdBQVcsS0FBSyxDQUFDO0FBQUEsUUFDNUM7QUFFQSxZQUFJLE9BQU8sVUFBVSxVQUFVO0FBQzNCLGlCQUFPLEtBQUssUUFBUSxPQUFPLFFBQVEsU0FBUyxLQUFLO0FBQUEsUUFDckQ7QUFFQSxZQUFJLFNBQVMsS0FBSyxHQUFHO0FBQ2pCLGlCQUFPLElBQUksT0FBTyxjQUFjLEtBQUssQ0FBQztBQUFBLFFBQzFDLFdBQVcsT0FBTyxLQUFLLEdBQUc7QUFDdEIsaUJBQU8sS0FBSztBQUFBLFFBQ2hCLFdBQVcsUUFBUUEsT0FBTSxHQUFHO0FBQ3hCLG1DQUF5QixNQUFNO0FBQUEsUUFDbkMsV0FBV0EsU0FBUTtBQUNmLG9DQUEwQixNQUFNO0FBQUEsUUFDcEMsT0FBTztBQUNILDBCQUFnQixNQUFNO0FBQUEsUUFDMUI7QUFFQSxZQUFJLENBQUMsUUFBUSxNQUFNLEdBQUc7QUFDbEIsaUJBQU8sS0FBSztBQUFBLFFBQ2hCO0FBRUEsZUFBTztBQUFBLE1BQ1g7QUFFQSxlQUFTLGdCQUFnQixRQUFRO0FBQzdCLFlBQUksUUFBUSxPQUFPO0FBQ25CLFlBQUksWUFBWSxLQUFLLEdBQUc7QUFDcEIsaUJBQU8sS0FBSyxJQUFJLEtBQUssTUFBTSxJQUFJLENBQUM7QUFBQSxRQUNwQyxXQUFXLE9BQU8sS0FBSyxHQUFHO0FBQ3RCLGlCQUFPLEtBQUssSUFBSSxLQUFLLE1BQU0sUUFBUSxDQUFDO0FBQUEsUUFDeEMsV0FBVyxPQUFPLFVBQVUsVUFBVTtBQUNsQywyQkFBaUIsTUFBTTtBQUFBLFFBQzNCLFdBQVcsUUFBUSxLQUFLLEdBQUc7QUFDdkIsaUJBQU8sS0FBS0QsS0FBSSxNQUFNLE1BQU0sQ0FBQyxHQUFHLFNBQVUsS0FBSztBQUMzQyxtQkFBTyxTQUFTLEtBQUssRUFBRTtBQUFBLFVBQzNCLENBQUM7QUFDRCwwQkFBZ0IsTUFBTTtBQUFBLFFBQzFCLFdBQVcsU0FBUyxLQUFLLEdBQUc7QUFDeEIsMkJBQWlCLE1BQU07QUFBQSxRQUMzQixXQUFXLFNBQVMsS0FBSyxHQUFHO0FBRXhCLGlCQUFPLEtBQUssSUFBSSxLQUFLLEtBQUs7QUFBQSxRQUM5QixPQUFPO0FBQ0gsZ0JBQU0sd0JBQXdCLE1BQU07QUFBQSxRQUN4QztBQUFBLE1BQ0o7QUFFQSxlQUFTLGlCQUFpQixPQUFPQyxTQUFRQyxTQUFRLFFBQVEsT0FBTztBQUM1RCxZQUFJLElBQUksQ0FBQztBQUVULFlBQUlELFlBQVcsUUFBUUEsWUFBVyxPQUFPO0FBQ3JDLG1CQUFTQTtBQUNULFVBQUFBLFVBQVM7QUFBQSxRQUNiO0FBRUEsWUFBSUMsWUFBVyxRQUFRQSxZQUFXLE9BQU87QUFDckMsbUJBQVNBO0FBQ1QsVUFBQUEsVUFBUztBQUFBLFFBQ2I7QUFFQSxZQUNLLFNBQVMsS0FBSyxLQUFLLGNBQWMsS0FBSyxLQUN0QyxRQUFRLEtBQUssS0FBSyxNQUFNLFdBQVcsR0FDdEM7QUFDRSxrQkFBUTtBQUFBLFFBQ1o7QUFHQSxVQUFFLG1CQUFtQjtBQUNyQixVQUFFLFVBQVUsRUFBRSxTQUFTO0FBQ3ZCLFVBQUUsS0FBS0E7QUFDUCxVQUFFLEtBQUs7QUFDUCxVQUFFLEtBQUtEO0FBQ1AsVUFBRSxVQUFVO0FBRVosZUFBTyxpQkFBaUIsQ0FBQztBQUFBLE1BQzdCO0FBRUEsZUFBUyxZQUFZLE9BQU9BLFNBQVFDLFNBQVEsUUFBUTtBQUNoRCxlQUFPLGlCQUFpQixPQUFPRCxTQUFRQyxTQUFRLFFBQVEsS0FBSztBQUFBLE1BQ2hFO0FBRUEsVUFBSSxlQUFlO0FBQUEsUUFDWDtBQUFBLFFBQ0EsV0FBWTtBQUNSLGNBQUksUUFBUSxZQUFZLE1BQU0sTUFBTSxTQUFTO0FBQzdDLGNBQUksS0FBSyxRQUFRLEtBQUssTUFBTSxRQUFRLEdBQUc7QUFDbkMsbUJBQU8sUUFBUSxPQUFPLE9BQU87QUFBQSxVQUNqQyxPQUFPO0FBQ0gsbUJBQU8sY0FBYztBQUFBLFVBQ3pCO0FBQUEsUUFDSjtBQUFBLE1BQ0osR0FDQSxlQUFlO0FBQUEsUUFDWDtBQUFBLFFBQ0EsV0FBWTtBQUNSLGNBQUksUUFBUSxZQUFZLE1BQU0sTUFBTSxTQUFTO0FBQzdDLGNBQUksS0FBSyxRQUFRLEtBQUssTUFBTSxRQUFRLEdBQUc7QUFDbkMsbUJBQU8sUUFBUSxPQUFPLE9BQU87QUFBQSxVQUNqQyxPQUFPO0FBQ0gsbUJBQU8sY0FBYztBQUFBLFVBQ3pCO0FBQUEsUUFDSjtBQUFBLE1BQ0o7QUFPSixlQUFTLE9BQU8sSUFBSSxTQUFTO0FBQ3pCLFlBQUksS0FBSztBQUNULFlBQUksUUFBUSxXQUFXLEtBQUssUUFBUSxRQUFRLENBQUMsQ0FBQyxHQUFHO0FBQzdDLG9CQUFVLFFBQVEsQ0FBQztBQUFBLFFBQ3ZCO0FBQ0EsWUFBSSxDQUFDLFFBQVEsUUFBUTtBQUNqQixpQkFBTyxZQUFZO0FBQUEsUUFDdkI7QUFDQSxjQUFNLFFBQVEsQ0FBQztBQUNmLGFBQUssSUFBSSxHQUFHLElBQUksUUFBUSxRQUFRLEVBQUUsR0FBRztBQUNqQyxjQUFJLENBQUMsUUFBUSxDQUFDLEVBQUUsUUFBUSxLQUFLLFFBQVEsQ0FBQyxFQUFFLEVBQUUsRUFBRSxHQUFHLEdBQUc7QUFDOUMsa0JBQU0sUUFBUSxDQUFDO0FBQUEsVUFDbkI7QUFBQSxRQUNKO0FBQ0EsZUFBTztBQUFBLE1BQ1g7QUFHQSxlQUFTLE1BQU07QUFDWCxZQUFJLE9BQU8sQ0FBQyxFQUFFLE1BQU0sS0FBSyxXQUFXLENBQUM7QUFFckMsZUFBTyxPQUFPLFlBQVksSUFBSTtBQUFBLE1BQ2xDO0FBRUEsZUFBUyxNQUFNO0FBQ1gsWUFBSSxPQUFPLENBQUMsRUFBRSxNQUFNLEtBQUssV0FBVyxDQUFDO0FBRXJDLGVBQU8sT0FBTyxXQUFXLElBQUk7QUFBQSxNQUNqQztBQUVBLFVBQUksTUFBTSxXQUFZO0FBQ2xCLGVBQU8sS0FBSyxNQUFNLEtBQUssSUFBSSxJQUFJLENBQUMsSUFBSSxLQUFLO0FBQUEsTUFDN0M7QUFFQSxVQUFJLFdBQVc7QUFBQSxRQUNYO0FBQUEsUUFDQTtBQUFBLFFBQ0E7QUFBQSxRQUNBO0FBQUEsUUFDQTtBQUFBLFFBQ0E7QUFBQSxRQUNBO0FBQUEsUUFDQTtBQUFBLFFBQ0E7QUFBQSxNQUNKO0FBRUEsZUFBUyxnQkFBZ0IsR0FBRztBQUN4QixZQUFJLEtBQ0EsaUJBQWlCLE9BQ2pCO0FBQ0osYUFBSyxPQUFPLEdBQUc7QUFDWCxjQUNJLFdBQVcsR0FBRyxHQUFHLEtBQ2pCLEVBQ0ksUUFBUSxLQUFLLFVBQVUsR0FBRyxNQUFNLE9BQy9CLEVBQUUsR0FBRyxLQUFLLFFBQVEsQ0FBQyxNQUFNLEVBQUUsR0FBRyxDQUFDLEtBRXRDO0FBQ0UsbUJBQU87QUFBQSxVQUNYO0FBQUEsUUFDSjtBQUVBLGFBQUssSUFBSSxHQUFHLElBQUksU0FBUyxRQUFRLEVBQUUsR0FBRztBQUNsQyxjQUFJLEVBQUUsU0FBUyxDQUFDLENBQUMsR0FBRztBQUNoQixnQkFBSSxnQkFBZ0I7QUFDaEIscUJBQU87QUFBQSxZQUNYO0FBQ0EsZ0JBQUksV0FBVyxFQUFFLFNBQVMsQ0FBQyxDQUFDLENBQUMsTUFBTSxNQUFNLEVBQUUsU0FBUyxDQUFDLENBQUMsQ0FBQyxHQUFHO0FBQ3RELCtCQUFpQjtBQUFBLFlBQ3JCO0FBQUEsVUFDSjtBQUFBLFFBQ0o7QUFFQSxlQUFPO0FBQUEsTUFDWDtBQUVBLGVBQVMsWUFBWTtBQUNqQixlQUFPLEtBQUs7QUFBQSxNQUNoQjtBQUVBLGVBQVMsa0JBQWtCO0FBQ3ZCLGVBQU8sZUFBZSxHQUFHO0FBQUEsTUFDN0I7QUFFQSxlQUFTLFNBQVMsVUFBVTtBQUN4QixZQUFJLGtCQUFrQixxQkFBcUIsUUFBUSxHQUMvQ2lCLFNBQVEsZ0JBQWdCLFFBQVEsR0FDaEMsV0FBVyxnQkFBZ0IsV0FBVyxHQUN0Q0MsVUFBUyxnQkFBZ0IsU0FBUyxHQUNsQ0MsU0FBUSxnQkFBZ0IsUUFBUSxnQkFBZ0IsV0FBVyxHQUMzREMsUUFBTyxnQkFBZ0IsT0FBTyxHQUM5QlAsU0FBUSxnQkFBZ0IsUUFBUSxHQUNoQ0MsV0FBVSxnQkFBZ0IsVUFBVSxHQUNwQ08sV0FBVSxnQkFBZ0IsVUFBVSxHQUNwQ0MsZ0JBQWUsZ0JBQWdCLGVBQWU7QUFFbEQsYUFBSyxXQUFXLGdCQUFnQixlQUFlO0FBRy9DLGFBQUssZ0JBQ0QsQ0FBQ0EsZ0JBQ0RELFdBQVU7QUFBQSxRQUNWUCxXQUFVO0FBQUEsUUFDVkQsU0FBUSxNQUFPLEtBQUs7QUFHeEIsYUFBSyxRQUFRLENBQUNPLFFBQU9ELFNBQVE7QUFJN0IsYUFBSyxVQUFVLENBQUNELFVBQVMsV0FBVyxJQUFJRCxTQUFRO0FBRWhELGFBQUssUUFBUSxDQUFDO0FBRWQsYUFBSyxVQUFVLFVBQVU7QUFFekIsYUFBSyxRQUFRO0FBQUEsTUFDakI7QUFFQSxlQUFTLFdBQVcsS0FBSztBQUNyQixlQUFPLGVBQWU7QUFBQSxNQUMxQjtBQUVBLGVBQVMsU0FBUyxRQUFRO0FBQ3RCLFlBQUksU0FBUyxHQUFHO0FBQ1osaUJBQU8sS0FBSyxNQUFNLEtBQUssTUFBTSxJQUFJO0FBQUEsUUFDckMsT0FBTztBQUNILGlCQUFPLEtBQUssTUFBTSxNQUFNO0FBQUEsUUFDNUI7QUFBQSxNQUNKO0FBR0EsZUFBUyxjQUFjLFFBQVEsUUFBUSxhQUFhO0FBQ2hELFlBQUksTUFBTSxLQUFLLElBQUksT0FBTyxRQUFRLE9BQU8sTUFBTSxHQUMzQyxhQUFhLEtBQUssSUFBSSxPQUFPLFNBQVMsT0FBTyxNQUFNLEdBQ25ELFFBQVEsR0FDUjtBQUNKLGFBQUssSUFBSSxHQUFHLElBQUksS0FBSyxLQUFLO0FBQ3RCLGNBQ0ssZUFBZSxPQUFPLENBQUMsTUFBTSxPQUFPLENBQUMsS0FDckMsQ0FBQyxlQUFlLE1BQU0sT0FBTyxDQUFDLENBQUMsTUFBTSxNQUFNLE9BQU8sQ0FBQyxDQUFDLEdBQ3ZEO0FBQ0U7QUFBQSxVQUNKO0FBQUEsUUFDSjtBQUNBLGVBQU8sUUFBUTtBQUFBLE1BQ25CO0FBSUEsZUFBUyxPQUFPVixRQUFPLFdBQVc7QUFDOUIsdUJBQWVBLFFBQU8sR0FBRyxHQUFHLFdBQVk7QUFDcEMsY0FBSWdCLFVBQVMsS0FBSyxVQUFVLEdBQ3hCakIsUUFBTztBQUNYLGNBQUlpQixVQUFTLEdBQUc7QUFDWixZQUFBQSxVQUFTLENBQUNBO0FBQ1YsWUFBQWpCLFFBQU87QUFBQSxVQUNYO0FBQ0EsaUJBQ0lBLFFBQ0EsU0FBUyxDQUFDLEVBQUVpQixVQUFTLEtBQUssQ0FBQyxJQUMzQixZQUNBLFNBQVMsQ0FBQyxDQUFDQSxVQUFTLElBQUksQ0FBQztBQUFBLFFBRWpDLENBQUM7QUFBQSxNQUNMO0FBRUEsYUFBTyxLQUFLLEdBQUc7QUFDZixhQUFPLE1BQU0sRUFBRTtBQUlmLG9CQUFjLEtBQUssZ0JBQWdCO0FBQ25DLG9CQUFjLE1BQU0sZ0JBQWdCO0FBQ3BDLG9CQUFjLENBQUMsS0FBSyxJQUFJLEdBQUcsU0FBVSxPQUFPLE9BQU8sUUFBUTtBQUN2RCxlQUFPLFVBQVU7QUFDakIsZUFBTyxPQUFPLGlCQUFpQixrQkFBa0IsS0FBSztBQUFBLE1BQzFELENBQUM7QUFPRCxVQUFJLGNBQWM7QUFFbEIsZUFBUyxpQkFBaUIsU0FBU2IsU0FBUTtBQUN2QyxZQUFJLFdBQVdBLFdBQVUsSUFBSSxNQUFNLE9BQU8sR0FDdEMsT0FDQSxPQUNBSTtBQUVKLFlBQUksWUFBWSxNQUFNO0FBQ2xCLGlCQUFPO0FBQUEsUUFDWDtBQUVBLGdCQUFRLFFBQVEsUUFBUSxTQUFTLENBQUMsS0FBSyxDQUFDO0FBQ3hDLGlCQUFTLFFBQVEsSUFBSSxNQUFNLFdBQVcsS0FBSyxDQUFDLEtBQUssR0FBRyxDQUFDO0FBQ3JELFFBQUFBLFdBQVUsRUFBRSxNQUFNLENBQUMsSUFBSSxNQUFNLE1BQU0sTUFBTSxDQUFDLENBQUM7QUFFM0MsZUFBT0EsYUFBWSxJQUFJLElBQUksTUFBTSxDQUFDLE1BQU0sTUFBTUEsV0FBVSxDQUFDQTtBQUFBLE1BQzdEO0FBR0EsZUFBUyxnQkFBZ0IsT0FBTyxPQUFPO0FBQ25DLFlBQUksS0FBS0g7QUFDVCxZQUFJLE1BQU0sUUFBUTtBQUNkLGdCQUFNLE1BQU0sTUFBTTtBQUNsQixVQUFBQSxTQUNLLFNBQVMsS0FBSyxLQUFLLE9BQU8sS0FBSyxJQUMxQixNQUFNLFFBQVEsSUFDZCxZQUFZLEtBQUssRUFBRSxRQUFRLEtBQUssSUFBSSxRQUFRO0FBRXRELGNBQUksR0FBRyxRQUFRLElBQUksR0FBRyxRQUFRLElBQUlBLEtBQUk7QUFDdEMsZ0JBQU0sYUFBYSxLQUFLLEtBQUs7QUFDN0IsaUJBQU87QUFBQSxRQUNYLE9BQU87QUFDSCxpQkFBTyxZQUFZLEtBQUssRUFBRSxNQUFNO0FBQUEsUUFDcEM7QUFBQSxNQUNKO0FBRUEsZUFBUyxjQUFjLEdBQUc7QUFHdEIsZUFBTyxDQUFDLEtBQUssTUFBTSxFQUFFLEdBQUcsa0JBQWtCLENBQUM7QUFBQSxNQUMvQztBQU1BLFlBQU0sZUFBZSxXQUFZO0FBQUEsTUFBQztBQWNsQyxlQUFTLGFBQWEsT0FBTyxlQUFlLGFBQWE7QUFDckQsWUFBSVksVUFBUyxLQUFLLFdBQVcsR0FDekI7QUFDSixZQUFJLENBQUMsS0FBSyxRQUFRLEdBQUc7QUFDakIsaUJBQU8sU0FBUyxPQUFPLE9BQU87QUFBQSxRQUNsQztBQUNBLFlBQUksU0FBUyxNQUFNO0FBQ2YsY0FBSSxPQUFPLFVBQVUsVUFBVTtBQUMzQixvQkFBUSxpQkFBaUIsa0JBQWtCLEtBQUs7QUFDaEQsZ0JBQUksVUFBVSxNQUFNO0FBQ2hCLHFCQUFPO0FBQUEsWUFDWDtBQUFBLFVBQ0osV0FBVyxLQUFLLElBQUksS0FBSyxJQUFJLE1BQU0sQ0FBQyxhQUFhO0FBQzdDLG9CQUFRLFFBQVE7QUFBQSxVQUNwQjtBQUNBLGNBQUksQ0FBQyxLQUFLLFVBQVUsZUFBZTtBQUMvQiwwQkFBYyxjQUFjLElBQUk7QUFBQSxVQUNwQztBQUNBLGVBQUssVUFBVTtBQUNmLGVBQUssU0FBUztBQUNkLGNBQUksZUFBZSxNQUFNO0FBQ3JCLGlCQUFLLElBQUksYUFBYSxHQUFHO0FBQUEsVUFDN0I7QUFDQSxjQUFJQSxZQUFXLE9BQU87QUFDbEIsZ0JBQUksQ0FBQyxpQkFBaUIsS0FBSyxtQkFBbUI7QUFDMUM7QUFBQSxnQkFDSTtBQUFBLGdCQUNBLGVBQWUsUUFBUUEsU0FBUSxHQUFHO0FBQUEsZ0JBQ2xDO0FBQUEsZ0JBQ0E7QUFBQSxjQUNKO0FBQUEsWUFDSixXQUFXLENBQUMsS0FBSyxtQkFBbUI7QUFDaEMsbUJBQUssb0JBQW9CO0FBQ3pCLG9CQUFNLGFBQWEsTUFBTSxJQUFJO0FBQzdCLG1CQUFLLG9CQUFvQjtBQUFBLFlBQzdCO0FBQUEsVUFDSjtBQUNBLGlCQUFPO0FBQUEsUUFDWCxPQUFPO0FBQ0gsaUJBQU8sS0FBSyxTQUFTQSxVQUFTLGNBQWMsSUFBSTtBQUFBLFFBQ3BEO0FBQUEsTUFDSjtBQUVBLGVBQVMsV0FBVyxPQUFPLGVBQWU7QUFDdEMsWUFBSSxTQUFTLE1BQU07QUFDZixjQUFJLE9BQU8sVUFBVSxVQUFVO0FBQzNCLG9CQUFRLENBQUM7QUFBQSxVQUNiO0FBRUEsZUFBSyxVQUFVLE9BQU8sYUFBYTtBQUVuQyxpQkFBTztBQUFBLFFBQ1gsT0FBTztBQUNILGlCQUFPLENBQUMsS0FBSyxVQUFVO0FBQUEsUUFDM0I7QUFBQSxNQUNKO0FBRUEsZUFBUyxlQUFlLGVBQWU7QUFDbkMsZUFBTyxLQUFLLFVBQVUsR0FBRyxhQUFhO0FBQUEsTUFDMUM7QUFFQSxlQUFTLGlCQUFpQixlQUFlO0FBQ3JDLFlBQUksS0FBSyxRQUFRO0FBQ2IsZUFBSyxVQUFVLEdBQUcsYUFBYTtBQUMvQixlQUFLLFNBQVM7QUFFZCxjQUFJLGVBQWU7QUFDZixpQkFBSyxTQUFTLGNBQWMsSUFBSSxHQUFHLEdBQUc7QUFBQSxVQUMxQztBQUFBLFFBQ0o7QUFDQSxlQUFPO0FBQUEsTUFDWDtBQUVBLGVBQVMsMEJBQTBCO0FBQy9CLFlBQUksS0FBSyxRQUFRLE1BQU07QUFDbkIsZUFBSyxVQUFVLEtBQUssTUFBTSxPQUFPLElBQUk7QUFBQSxRQUN6QyxXQUFXLE9BQU8sS0FBSyxPQUFPLFVBQVU7QUFDcEMsY0FBSSxRQUFRLGlCQUFpQixhQUFhLEtBQUssRUFBRTtBQUNqRCxjQUFJLFNBQVMsTUFBTTtBQUNmLGlCQUFLLFVBQVUsS0FBSztBQUFBLFVBQ3hCLE9BQU87QUFDSCxpQkFBSyxVQUFVLEdBQUcsSUFBSTtBQUFBLFVBQzFCO0FBQUEsUUFDSjtBQUNBLGVBQU87QUFBQSxNQUNYO0FBRUEsZUFBUyxxQkFBcUIsT0FBTztBQUNqQyxZQUFJLENBQUMsS0FBSyxRQUFRLEdBQUc7QUFDakIsaUJBQU87QUFBQSxRQUNYO0FBQ0EsZ0JBQVEsUUFBUSxZQUFZLEtBQUssRUFBRSxVQUFVLElBQUk7QUFFakQsZ0JBQVEsS0FBSyxVQUFVLElBQUksU0FBUyxPQUFPO0FBQUEsTUFDL0M7QUFFQSxlQUFTLHVCQUF1QjtBQUM1QixlQUNJLEtBQUssVUFBVSxJQUFJLEtBQUssTUFBTSxFQUFFLE1BQU0sQ0FBQyxFQUFFLFVBQVUsS0FDbkQsS0FBSyxVQUFVLElBQUksS0FBSyxNQUFNLEVBQUUsTUFBTSxDQUFDLEVBQUUsVUFBVTtBQUFBLE1BRTNEO0FBRUEsZUFBUyw4QkFBOEI7QUFDbkMsWUFBSSxDQUFDLFlBQVksS0FBSyxhQUFhLEdBQUc7QUFDbEMsaUJBQU8sS0FBSztBQUFBLFFBQ2hCO0FBRUEsWUFBSSxJQUFJLENBQUMsR0FDTDtBQUVKLG1CQUFXLEdBQUcsSUFBSTtBQUNsQixZQUFJLGNBQWMsQ0FBQztBQUVuQixZQUFJLEVBQUUsSUFBSTtBQUNOLGtCQUFRLEVBQUUsU0FBUyxVQUFVLEVBQUUsRUFBRSxJQUFJLFlBQVksRUFBRSxFQUFFO0FBQ3JELGVBQUssZ0JBQ0QsS0FBSyxRQUFRLEtBQUssY0FBYyxFQUFFLElBQUksTUFBTSxRQUFRLENBQUMsSUFBSTtBQUFBLFFBQ2pFLE9BQU87QUFDSCxlQUFLLGdCQUFnQjtBQUFBLFFBQ3pCO0FBRUEsZUFBTyxLQUFLO0FBQUEsTUFDaEI7QUFFQSxlQUFTLFVBQVU7QUFDZixlQUFPLEtBQUssUUFBUSxJQUFJLENBQUMsS0FBSyxTQUFTO0FBQUEsTUFDM0M7QUFFQSxlQUFTLGNBQWM7QUFDbkIsZUFBTyxLQUFLLFFBQVEsSUFBSSxLQUFLLFNBQVM7QUFBQSxNQUMxQztBQUVBLGVBQVMsUUFBUTtBQUNiLGVBQU8sS0FBSyxRQUFRLElBQUksS0FBSyxVQUFVLEtBQUssWUFBWSxJQUFJO0FBQUEsTUFDaEU7QUFHQSxVQUFJLGNBQWMseURBSWQsV0FBVztBQUVmLGVBQVMsZUFBZSxPQUFPLEtBQUs7QUFDaEMsWUFBSSxXQUFXLE9BRVgsUUFBUSxNQUNSakIsT0FDQSxLQUNBO0FBRUosWUFBSSxXQUFXLEtBQUssR0FBRztBQUNuQixxQkFBVztBQUFBLFlBQ1AsSUFBSSxNQUFNO0FBQUEsWUFDVixHQUFHLE1BQU07QUFBQSxZQUNULEdBQUcsTUFBTTtBQUFBLFVBQ2I7QUFBQSxRQUNKLFdBQVcsU0FBUyxLQUFLLEtBQUssQ0FBQyxNQUFNLENBQUMsS0FBSyxHQUFHO0FBQzFDLHFCQUFXLENBQUM7QUFDWixjQUFJLEtBQUs7QUFDTCxxQkFBUyxHQUFHLElBQUksQ0FBQztBQUFBLFVBQ3JCLE9BQU87QUFDSCxxQkFBUyxlQUFlLENBQUM7QUFBQSxVQUM3QjtBQUFBLFFBQ0osV0FBWSxRQUFRLFlBQVksS0FBSyxLQUFLLEdBQUk7QUFDMUMsVUFBQUEsUUFBTyxNQUFNLENBQUMsTUFBTSxNQUFNLEtBQUs7QUFDL0IscUJBQVc7QUFBQSxZQUNQLEdBQUc7QUFBQSxZQUNILEdBQUcsTUFBTSxNQUFNLElBQUksQ0FBQyxJQUFJQTtBQUFBLFlBQ3hCLEdBQUcsTUFBTSxNQUFNLElBQUksQ0FBQyxJQUFJQTtBQUFBLFlBQ3hCLEdBQUcsTUFBTSxNQUFNLE1BQU0sQ0FBQyxJQUFJQTtBQUFBLFlBQzFCLEdBQUcsTUFBTSxNQUFNLE1BQU0sQ0FBQyxJQUFJQTtBQUFBLFlBQzFCLElBQUksTUFBTSxTQUFTLE1BQU0sV0FBVyxJQUFJLEdBQUksQ0FBQyxJQUFJQTtBQUFBO0FBQUEsVUFDckQ7QUFBQSxRQUNKLFdBQVksUUFBUSxTQUFTLEtBQUssS0FBSyxHQUFJO0FBQ3ZDLFVBQUFBLFFBQU8sTUFBTSxDQUFDLE1BQU0sTUFBTSxLQUFLO0FBQy9CLHFCQUFXO0FBQUEsWUFDUCxHQUFHLFNBQVMsTUFBTSxDQUFDLEdBQUdBLEtBQUk7QUFBQSxZQUMxQixHQUFHLFNBQVMsTUFBTSxDQUFDLEdBQUdBLEtBQUk7QUFBQSxZQUMxQixHQUFHLFNBQVMsTUFBTSxDQUFDLEdBQUdBLEtBQUk7QUFBQSxZQUMxQixHQUFHLFNBQVMsTUFBTSxDQUFDLEdBQUdBLEtBQUk7QUFBQSxZQUMxQixHQUFHLFNBQVMsTUFBTSxDQUFDLEdBQUdBLEtBQUk7QUFBQSxZQUMxQixHQUFHLFNBQVMsTUFBTSxDQUFDLEdBQUdBLEtBQUk7QUFBQSxZQUMxQixHQUFHLFNBQVMsTUFBTSxDQUFDLEdBQUdBLEtBQUk7QUFBQSxVQUM5QjtBQUFBLFFBQ0osV0FBVyxZQUFZLE1BQU07QUFFekIscUJBQVcsQ0FBQztBQUFBLFFBQ2hCLFdBQ0ksT0FBTyxhQUFhLGFBQ25CLFVBQVUsWUFBWSxRQUFRLFdBQ2pDO0FBQ0Usb0JBQVU7QUFBQSxZQUNOLFlBQVksU0FBUyxJQUFJO0FBQUEsWUFDekIsWUFBWSxTQUFTLEVBQUU7QUFBQSxVQUMzQjtBQUVBLHFCQUFXLENBQUM7QUFDWixtQkFBUyxLQUFLLFFBQVE7QUFDdEIsbUJBQVMsSUFBSSxRQUFRO0FBQUEsUUFDekI7QUFFQSxjQUFNLElBQUksU0FBUyxRQUFRO0FBRTNCLFlBQUksV0FBVyxLQUFLLEtBQUssV0FBVyxPQUFPLFNBQVMsR0FBRztBQUNuRCxjQUFJLFVBQVUsTUFBTTtBQUFBLFFBQ3hCO0FBRUEsWUFBSSxXQUFXLEtBQUssS0FBSyxXQUFXLE9BQU8sVUFBVSxHQUFHO0FBQ3BELGNBQUksV0FBVyxNQUFNO0FBQUEsUUFDekI7QUFFQSxlQUFPO0FBQUEsTUFDWDtBQUVBLHFCQUFlLEtBQUssU0FBUztBQUM3QixxQkFBZSxVQUFVO0FBRXpCLGVBQVMsU0FBUyxLQUFLQSxPQUFNO0FBSXpCLFlBQUksTUFBTSxPQUFPLFdBQVcsSUFBSSxRQUFRLEtBQUssR0FBRyxDQUFDO0FBRWpELGdCQUFRLE1BQU0sR0FBRyxJQUFJLElBQUksT0FBT0E7QUFBQSxNQUNwQztBQUVBLGVBQVMsMEJBQTBCLE1BQU0sT0FBTztBQUM1QyxZQUFJLE1BQU0sQ0FBQztBQUVYLFlBQUksU0FDQSxNQUFNLE1BQU0sSUFBSSxLQUFLLE1BQU0sS0FBSyxNQUFNLEtBQUssSUFBSSxLQUFLLEtBQUssS0FBSztBQUNsRSxZQUFJLEtBQUssTUFBTSxFQUFFLElBQUksSUFBSSxRQUFRLEdBQUcsRUFBRSxRQUFRLEtBQUssR0FBRztBQUNsRCxZQUFFLElBQUk7QUFBQSxRQUNWO0FBRUEsWUFBSSxlQUFlLENBQUMsUUFBUSxDQUFDLEtBQUssTUFBTSxFQUFFLElBQUksSUFBSSxRQUFRLEdBQUc7QUFFN0QsZUFBTztBQUFBLE1BQ1g7QUFFQSxlQUFTLGtCQUFrQixNQUFNLE9BQU87QUFDcEMsWUFBSTtBQUNKLFlBQUksRUFBRSxLQUFLLFFBQVEsS0FBSyxNQUFNLFFBQVEsSUFBSTtBQUN0QyxpQkFBTyxFQUFFLGNBQWMsR0FBRyxRQUFRLEVBQUU7QUFBQSxRQUN4QztBQUVBLGdCQUFRLGdCQUFnQixPQUFPLElBQUk7QUFDbkMsWUFBSSxLQUFLLFNBQVMsS0FBSyxHQUFHO0FBQ3RCLGdCQUFNLDBCQUEwQixNQUFNLEtBQUs7QUFBQSxRQUMvQyxPQUFPO0FBQ0gsZ0JBQU0sMEJBQTBCLE9BQU8sSUFBSTtBQUMzQyxjQUFJLGVBQWUsQ0FBQyxJQUFJO0FBQ3hCLGNBQUksU0FBUyxDQUFDLElBQUk7QUFBQSxRQUN0QjtBQUVBLGVBQU87QUFBQSxNQUNYO0FBR0EsZUFBUyxZQUFZLFdBQVcsTUFBTTtBQUNsQyxlQUFPLFNBQVUsS0FBSyxRQUFRO0FBQzFCLGNBQUksS0FBSztBQUVULGNBQUksV0FBVyxRQUFRLENBQUMsTUFBTSxDQUFDLE1BQU0sR0FBRztBQUNwQztBQUFBLGNBQ0k7QUFBQSxjQUNBLGNBQ0ksT0FDQSx5REFDQSxPQUNBO0FBQUEsWUFFUjtBQUNBLGtCQUFNO0FBQ04sa0JBQU07QUFDTixxQkFBUztBQUFBLFVBQ2I7QUFFQSxnQkFBTSxlQUFlLEtBQUssTUFBTTtBQUNoQyxzQkFBWSxNQUFNLEtBQUssU0FBUztBQUNoQyxpQkFBTztBQUFBLFFBQ1g7QUFBQSxNQUNKO0FBRUEsZUFBUyxZQUFZLEtBQUssVUFBVSxVQUFVLGNBQWM7QUFDeEQsWUFBSWdCLGdCQUFlLFNBQVMsZUFDeEJGLFFBQU8sU0FBUyxTQUFTLEtBQUssR0FDOUJGLFVBQVMsU0FBUyxTQUFTLE9BQU87QUFFdEMsWUFBSSxDQUFDLElBQUksUUFBUSxHQUFHO0FBRWhCO0FBQUEsUUFDSjtBQUVBLHVCQUFlLGdCQUFnQixPQUFPLE9BQU87QUFFN0MsWUFBSUEsU0FBUTtBQUNSLG1CQUFTLEtBQUssSUFBSSxLQUFLLE9BQU8sSUFBSUEsVUFBUyxRQUFRO0FBQUEsUUFDdkQ7QUFDQSxZQUFJRSxPQUFNO0FBQ04sZ0JBQU0sS0FBSyxRQUFRLElBQUksS0FBSyxNQUFNLElBQUlBLFFBQU8sUUFBUTtBQUFBLFFBQ3pEO0FBQ0EsWUFBSUUsZUFBYztBQUNkLGNBQUksR0FBRyxRQUFRLElBQUksR0FBRyxRQUFRLElBQUlBLGdCQUFlLFFBQVE7QUFBQSxRQUM3RDtBQUNBLFlBQUksY0FBYztBQUNkLGdCQUFNLGFBQWEsS0FBS0YsU0FBUUYsT0FBTTtBQUFBLFFBQzFDO0FBQUEsTUFDSjtBQUVBLFVBQUksTUFBTSxZQUFZLEdBQUcsS0FBSyxHQUMxQixXQUFXLFlBQVksSUFBSSxVQUFVO0FBRXpDLGVBQVMsU0FBUyxPQUFPO0FBQ3JCLGVBQU8sT0FBTyxVQUFVLFlBQVksaUJBQWlCO0FBQUEsTUFDekQ7QUFHQSxlQUFTLGNBQWMsT0FBTztBQUMxQixlQUNJLFNBQVMsS0FBSyxLQUNkLE9BQU8sS0FBSyxLQUNaLFNBQVMsS0FBSyxLQUNkLFNBQVMsS0FBSyxLQUNkLHNCQUFzQixLQUFLLEtBQzNCLG9CQUFvQixLQUFLLEtBQ3pCLFVBQVUsUUFDVixVQUFVO0FBQUEsTUFFbEI7QUFFQSxlQUFTLG9CQUFvQixPQUFPO0FBQ2hDLFlBQUksYUFBYSxTQUFTLEtBQUssS0FBSyxDQUFDLGNBQWMsS0FBSyxHQUNwRCxlQUFlLE9BQ2YsYUFBYTtBQUFBLFVBQ1Q7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFFBQ0osR0FDQSxHQUNBO0FBRUosYUFBSyxJQUFJLEdBQUcsSUFBSSxXQUFXLFFBQVEsS0FBSyxHQUFHO0FBQ3ZDLHFCQUFXLFdBQVcsQ0FBQztBQUN2Qix5QkFBZSxnQkFBZ0IsV0FBVyxPQUFPLFFBQVE7QUFBQSxRQUM3RDtBQUVBLGVBQU8sY0FBYztBQUFBLE1BQ3pCO0FBRUEsZUFBUyxzQkFBc0IsT0FBTztBQUNsQyxZQUFJLFlBQVksUUFBUSxLQUFLLEdBQ3pCLGVBQWU7QUFDbkIsWUFBSSxXQUFXO0FBQ1gseUJBQ0ksTUFBTSxPQUFPLFNBQVUsTUFBTTtBQUN6QixtQkFBTyxDQUFDLFNBQVMsSUFBSSxLQUFLLFNBQVMsS0FBSztBQUFBLFVBQzVDLENBQUMsRUFBRSxXQUFXO0FBQUEsUUFDdEI7QUFDQSxlQUFPLGFBQWE7QUFBQSxNQUN4QjtBQUVBLGVBQVMsZUFBZSxPQUFPO0FBQzNCLFlBQUksYUFBYSxTQUFTLEtBQUssS0FBSyxDQUFDLGNBQWMsS0FBSyxHQUNwRCxlQUFlLE9BQ2YsYUFBYTtBQUFBLFVBQ1Q7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFFBQ0osR0FDQSxHQUNBO0FBRUosYUFBSyxJQUFJLEdBQUcsSUFBSSxXQUFXLFFBQVEsS0FBSyxHQUFHO0FBQ3ZDLHFCQUFXLFdBQVcsQ0FBQztBQUN2Qix5QkFBZSxnQkFBZ0IsV0FBVyxPQUFPLFFBQVE7QUFBQSxRQUM3RDtBQUVBLGVBQU8sY0FBYztBQUFBLE1BQ3pCO0FBRUEsZUFBUyxrQkFBa0IsVUFBVWIsTUFBSztBQUN0QyxZQUFJTSxRQUFPLFNBQVMsS0FBS04sTUFBSyxRQUFRLElBQUk7QUFDMUMsZUFBT00sUUFBTyxLQUNSLGFBQ0FBLFFBQU8sS0FDUCxhQUNBQSxRQUFPLElBQ1AsWUFDQUEsUUFBTyxJQUNQLFlBQ0FBLFFBQU8sSUFDUCxZQUNBQSxRQUFPLElBQ1AsYUFDQTtBQUFBLE1BQ1Y7QUFFQSxlQUFTLFdBQVcsTUFBTSxTQUFTO0FBRS9CLFlBQUksVUFBVSxXQUFXLEdBQUc7QUFDeEIsY0FBSSxDQUFDLFVBQVUsQ0FBQyxHQUFHO0FBQ2YsbUJBQU87QUFDUCxzQkFBVTtBQUFBLFVBQ2QsV0FBVyxjQUFjLFVBQVUsQ0FBQyxDQUFDLEdBQUc7QUFDcEMsbUJBQU8sVUFBVSxDQUFDO0FBQ2xCLHNCQUFVO0FBQUEsVUFDZCxXQUFXLGVBQWUsVUFBVSxDQUFDLENBQUMsR0FBRztBQUNyQyxzQkFBVSxVQUFVLENBQUM7QUFDckIsbUJBQU87QUFBQSxVQUNYO0FBQUEsUUFDSjtBQUdBLFlBQUlOLE9BQU0sUUFBUSxZQUFZLEdBQzFCLE1BQU0sZ0JBQWdCQSxNQUFLLElBQUksRUFBRSxRQUFRLEtBQUssR0FDOUNOLFVBQVMsTUFBTSxlQUFlLE1BQU0sR0FBRyxLQUFLLFlBQzVDLFNBQ0ksWUFDQyxXQUFXLFFBQVFBLE9BQU0sQ0FBQyxJQUNyQixRQUFRQSxPQUFNLEVBQUUsS0FBSyxNQUFNTSxJQUFHLElBQzlCLFFBQVFOLE9BQU07QUFFNUIsZUFBTyxLQUFLO0FBQUEsVUFDUixVQUFVLEtBQUssV0FBVyxFQUFFLFNBQVNBLFNBQVEsTUFBTSxZQUFZTSxJQUFHLENBQUM7QUFBQSxRQUN2RTtBQUFBLE1BQ0o7QUFFQSxlQUFTLFFBQVE7QUFDYixlQUFPLElBQUksT0FBTyxJQUFJO0FBQUEsTUFDMUI7QUFFQSxlQUFTLFFBQVEsT0FBTyxPQUFPO0FBQzNCLFlBQUksYUFBYSxTQUFTLEtBQUssSUFBSSxRQUFRLFlBQVksS0FBSztBQUM1RCxZQUFJLEVBQUUsS0FBSyxRQUFRLEtBQUssV0FBVyxRQUFRLElBQUk7QUFDM0MsaUJBQU87QUFBQSxRQUNYO0FBQ0EsZ0JBQVEsZUFBZSxLQUFLLEtBQUs7QUFDakMsWUFBSSxVQUFVLGVBQWU7QUFDekIsaUJBQU8sS0FBSyxRQUFRLElBQUksV0FBVyxRQUFRO0FBQUEsUUFDL0MsT0FBTztBQUNILGlCQUFPLFdBQVcsUUFBUSxJQUFJLEtBQUssTUFBTSxFQUFFLFFBQVEsS0FBSyxFQUFFLFFBQVE7QUFBQSxRQUN0RTtBQUFBLE1BQ0o7QUFFQSxlQUFTLFNBQVMsT0FBTyxPQUFPO0FBQzVCLFlBQUksYUFBYSxTQUFTLEtBQUssSUFBSSxRQUFRLFlBQVksS0FBSztBQUM1RCxZQUFJLEVBQUUsS0FBSyxRQUFRLEtBQUssV0FBVyxRQUFRLElBQUk7QUFDM0MsaUJBQU87QUFBQSxRQUNYO0FBQ0EsZ0JBQVEsZUFBZSxLQUFLLEtBQUs7QUFDakMsWUFBSSxVQUFVLGVBQWU7QUFDekIsaUJBQU8sS0FBSyxRQUFRLElBQUksV0FBVyxRQUFRO0FBQUEsUUFDL0MsT0FBTztBQUNILGlCQUFPLEtBQUssTUFBTSxFQUFFLE1BQU0sS0FBSyxFQUFFLFFBQVEsSUFBSSxXQUFXLFFBQVE7QUFBQSxRQUNwRTtBQUFBLE1BQ0o7QUFFQSxlQUFTLFVBQVVILE9BQU1ELEtBQUksT0FBTyxhQUFhO0FBQzdDLFlBQUksWUFBWSxTQUFTQyxLQUFJLElBQUlBLFFBQU8sWUFBWUEsS0FBSSxHQUNwRCxVQUFVLFNBQVNELEdBQUUsSUFBSUEsTUFBSyxZQUFZQSxHQUFFO0FBQ2hELFlBQUksRUFBRSxLQUFLLFFBQVEsS0FBSyxVQUFVLFFBQVEsS0FBSyxRQUFRLFFBQVEsSUFBSTtBQUMvRCxpQkFBTztBQUFBLFFBQ1g7QUFDQSxzQkFBYyxlQUFlO0FBQzdCLGdCQUNLLFlBQVksQ0FBQyxNQUFNLE1BQ2QsS0FBSyxRQUFRLFdBQVcsS0FBSyxJQUM3QixDQUFDLEtBQUssU0FBUyxXQUFXLEtBQUssT0FDcEMsWUFBWSxDQUFDLE1BQU0sTUFDZCxLQUFLLFNBQVMsU0FBUyxLQUFLLElBQzVCLENBQUMsS0FBSyxRQUFRLFNBQVMsS0FBSztBQUFBLE1BRTFDO0FBRUEsZUFBUyxPQUFPLE9BQU8sT0FBTztBQUMxQixZQUFJLGFBQWEsU0FBUyxLQUFLLElBQUksUUFBUSxZQUFZLEtBQUssR0FDeEQ7QUFDSixZQUFJLEVBQUUsS0FBSyxRQUFRLEtBQUssV0FBVyxRQUFRLElBQUk7QUFDM0MsaUJBQU87QUFBQSxRQUNYO0FBQ0EsZ0JBQVEsZUFBZSxLQUFLLEtBQUs7QUFDakMsWUFBSSxVQUFVLGVBQWU7QUFDekIsaUJBQU8sS0FBSyxRQUFRLE1BQU0sV0FBVyxRQUFRO0FBQUEsUUFDakQsT0FBTztBQUNILG9CQUFVLFdBQVcsUUFBUTtBQUM3QixpQkFDSSxLQUFLLE1BQU0sRUFBRSxRQUFRLEtBQUssRUFBRSxRQUFRLEtBQUssV0FDekMsV0FBVyxLQUFLLE1BQU0sRUFBRSxNQUFNLEtBQUssRUFBRSxRQUFRO0FBQUEsUUFFckQ7QUFBQSxNQUNKO0FBRUEsZUFBUyxjQUFjLE9BQU8sT0FBTztBQUNqQyxlQUFPLEtBQUssT0FBTyxPQUFPLEtBQUssS0FBSyxLQUFLLFFBQVEsT0FBTyxLQUFLO0FBQUEsTUFDakU7QUFFQSxlQUFTLGVBQWUsT0FBTyxPQUFPO0FBQ2xDLGVBQU8sS0FBSyxPQUFPLE9BQU8sS0FBSyxLQUFLLEtBQUssU0FBUyxPQUFPLEtBQUs7QUFBQSxNQUNsRTtBQUVBLGVBQVMsS0FBSyxPQUFPLE9BQU8sU0FBUztBQUNqQyxZQUFJLE1BQU0sV0FBVztBQUVyQixZQUFJLENBQUMsS0FBSyxRQUFRLEdBQUc7QUFDakIsaUJBQU87QUFBQSxRQUNYO0FBRUEsZUFBTyxnQkFBZ0IsT0FBTyxJQUFJO0FBRWxDLFlBQUksQ0FBQyxLQUFLLFFBQVEsR0FBRztBQUNqQixpQkFBTztBQUFBLFFBQ1g7QUFFQSxxQkFBYSxLQUFLLFVBQVUsSUFBSSxLQUFLLFVBQVUsS0FBSztBQUVwRCxnQkFBUSxlQUFlLEtBQUs7QUFFNUIsZ0JBQVEsT0FBTztBQUFBLFVBQ1gsS0FBSztBQUNELHFCQUFTLFVBQVUsTUFBTSxJQUFJLElBQUk7QUFDakM7QUFBQSxVQUNKLEtBQUs7QUFDRCxxQkFBUyxVQUFVLE1BQU0sSUFBSTtBQUM3QjtBQUFBLFVBQ0osS0FBSztBQUNELHFCQUFTLFVBQVUsTUFBTSxJQUFJLElBQUk7QUFDakM7QUFBQSxVQUNKLEtBQUs7QUFDRCxzQkFBVSxPQUFPLFFBQVE7QUFDekI7QUFBQSxVQUNKLEtBQUs7QUFDRCxzQkFBVSxPQUFPLFFBQVE7QUFDekI7QUFBQSxVQUNKLEtBQUs7QUFDRCxzQkFBVSxPQUFPLFFBQVE7QUFDekI7QUFBQSxVQUNKLEtBQUs7QUFDRCxzQkFBVSxPQUFPLE9BQU8sYUFBYTtBQUNyQztBQUFBLFVBQ0osS0FBSztBQUNELHNCQUFVLE9BQU8sT0FBTyxhQUFhO0FBQ3JDO0FBQUEsVUFDSjtBQUNJLHFCQUFTLE9BQU87QUFBQSxRQUN4QjtBQUVBLGVBQU8sVUFBVSxTQUFTLFNBQVMsTUFBTTtBQUFBLE1BQzdDO0FBRUEsZUFBUyxVQUFVLEdBQUcsR0FBRztBQUNyQixZQUFJLEVBQUUsS0FBSyxJQUFJLEVBQUUsS0FBSyxHQUFHO0FBR3JCLGlCQUFPLENBQUMsVUFBVSxHQUFHLENBQUM7QUFBQSxRQUMxQjtBQUVBLFlBQUksa0JBQWtCLEVBQUUsS0FBSyxJQUFJLEVBQUUsS0FBSyxLQUFLLE1BQU0sRUFBRSxNQUFNLElBQUksRUFBRSxNQUFNLElBRW5FLFNBQVMsRUFBRSxNQUFNLEVBQUUsSUFBSSxnQkFBZ0IsUUFBUSxHQUMvQyxTQUNBO0FBRUosWUFBSSxJQUFJLFNBQVMsR0FBRztBQUNoQixvQkFBVSxFQUFFLE1BQU0sRUFBRSxJQUFJLGlCQUFpQixHQUFHLFFBQVE7QUFFcEQsb0JBQVUsSUFBSSxXQUFXLFNBQVM7QUFBQSxRQUN0QyxPQUFPO0FBQ0gsb0JBQVUsRUFBRSxNQUFNLEVBQUUsSUFBSSxpQkFBaUIsR0FBRyxRQUFRO0FBRXBELG9CQUFVLElBQUksV0FBVyxVQUFVO0FBQUEsUUFDdkM7QUFHQSxlQUFPLEVBQUUsaUJBQWlCLFdBQVc7QUFBQSxNQUN6QztBQUVBLFlBQU0sZ0JBQWdCO0FBQ3RCLFlBQU0sbUJBQW1CO0FBRXpCLGVBQVMsV0FBVztBQUNoQixlQUFPLEtBQUssTUFBTSxFQUFFLE9BQU8sSUFBSSxFQUFFLE9BQU8sa0NBQWtDO0FBQUEsTUFDOUU7QUFFQSxlQUFTLFlBQVksWUFBWTtBQUM3QixZQUFJLENBQUMsS0FBSyxRQUFRLEdBQUc7QUFDakIsaUJBQU87QUFBQSxRQUNYO0FBQ0EsWUFBSSxNQUFNLGVBQWUsTUFDckIsSUFBSSxNQUFNLEtBQUssTUFBTSxFQUFFLElBQUksSUFBSTtBQUNuQyxZQUFJLEVBQUUsS0FBSyxJQUFJLEtBQUssRUFBRSxLQUFLLElBQUksTUFBTTtBQUNqQyxpQkFBTztBQUFBLFlBQ0g7QUFBQSxZQUNBLE1BQ00sbUNBQ0E7QUFBQSxVQUNWO0FBQUEsUUFDSjtBQUNBLFlBQUksV0FBVyxLQUFLLFVBQVUsV0FBVyxHQUFHO0FBRXhDLGNBQUksS0FBSztBQUNMLG1CQUFPLEtBQUssT0FBTyxFQUFFLFlBQVk7QUFBQSxVQUNyQyxPQUFPO0FBQ0gsbUJBQU8sSUFBSSxLQUFLLEtBQUssUUFBUSxJQUFJLEtBQUssVUFBVSxJQUFJLEtBQUssR0FBSSxFQUN4RCxZQUFZLEVBQ1osUUFBUSxLQUFLLGFBQWEsR0FBRyxHQUFHLENBQUM7QUFBQSxVQUMxQztBQUFBLFFBQ0o7QUFDQSxlQUFPO0FBQUEsVUFDSDtBQUFBLFVBQ0EsTUFBTSxpQ0FBaUM7QUFBQSxRQUMzQztBQUFBLE1BQ0o7QUFRQSxlQUFTLFVBQVU7QUFDZixZQUFJLENBQUMsS0FBSyxRQUFRLEdBQUc7QUFDakIsaUJBQU8sdUJBQXVCLEtBQUssS0FBSztBQUFBLFFBQzVDO0FBQ0EsWUFBSSxPQUFPLFVBQ1AsT0FBTyxJQUNQLFFBQ0EsTUFDQSxVQUNBO0FBQ0osWUFBSSxDQUFDLEtBQUssUUFBUSxHQUFHO0FBQ2pCLGlCQUFPLEtBQUssVUFBVSxNQUFNLElBQUksZUFBZTtBQUMvQyxpQkFBTztBQUFBLFFBQ1g7QUFDQSxpQkFBUyxNQUFNLE9BQU87QUFDdEIsZUFBTyxLQUFLLEtBQUssS0FBSyxLQUFLLEtBQUssS0FBSyxLQUFLLE9BQU8sU0FBUztBQUMxRCxtQkFBVztBQUNYLGlCQUFTLE9BQU87QUFFaEIsZUFBTyxLQUFLLE9BQU8sU0FBUyxPQUFPLFdBQVcsTUFBTTtBQUFBLE1BQ3hEO0FBRUEsZUFBUyxPQUFPLGFBQWE7QUFDekIsWUFBSSxDQUFDLGFBQWE7QUFDZCx3QkFBYyxLQUFLLE1BQU0sSUFDbkIsTUFBTSxtQkFDTixNQUFNO0FBQUEsUUFDaEI7QUFDQSxZQUFJLFNBQVMsYUFBYSxNQUFNLFdBQVc7QUFDM0MsZUFBTyxLQUFLLFdBQVcsRUFBRSxXQUFXLE1BQU07QUFBQSxNQUM5QztBQUVBLGVBQVMsS0FBSyxNQUFNLGVBQWU7QUFDL0IsWUFDSSxLQUFLLFFBQVEsTUFDWCxTQUFTLElBQUksS0FBSyxLQUFLLFFBQVEsS0FBTSxZQUFZLElBQUksRUFBRSxRQUFRLElBQ25FO0FBQ0UsaUJBQU8sZUFBZSxFQUFFLElBQUksTUFBTSxNQUFNLEtBQUssQ0FBQyxFQUN6QyxPQUFPLEtBQUssT0FBTyxDQUFDLEVBQ3BCLFNBQVMsQ0FBQyxhQUFhO0FBQUEsUUFDaEMsT0FBTztBQUNILGlCQUFPLEtBQUssV0FBVyxFQUFFLFlBQVk7QUFBQSxRQUN6QztBQUFBLE1BQ0o7QUFFQSxlQUFTLFFBQVEsZUFBZTtBQUM1QixlQUFPLEtBQUssS0FBSyxZQUFZLEdBQUcsYUFBYTtBQUFBLE1BQ2pEO0FBRUEsZUFBUyxHQUFHLE1BQU0sZUFBZTtBQUM3QixZQUNJLEtBQUssUUFBUSxNQUNYLFNBQVMsSUFBSSxLQUFLLEtBQUssUUFBUSxLQUFNLFlBQVksSUFBSSxFQUFFLFFBQVEsSUFDbkU7QUFDRSxpQkFBTyxlQUFlLEVBQUUsTUFBTSxNQUFNLElBQUksS0FBSyxDQUFDLEVBQ3pDLE9BQU8sS0FBSyxPQUFPLENBQUMsRUFDcEIsU0FBUyxDQUFDLGFBQWE7QUFBQSxRQUNoQyxPQUFPO0FBQ0gsaUJBQU8sS0FBSyxXQUFXLEVBQUUsWUFBWTtBQUFBLFFBQ3pDO0FBQUEsTUFDSjtBQUVBLGVBQVMsTUFBTSxlQUFlO0FBQzFCLGVBQU8sS0FBSyxHQUFHLFlBQVksR0FBRyxhQUFhO0FBQUEsTUFDL0M7QUFLQSxlQUFTLE9BQU8sS0FBSztBQUNqQixZQUFJO0FBRUosWUFBSSxRQUFRLFFBQVc7QUFDbkIsaUJBQU8sS0FBSyxRQUFRO0FBQUEsUUFDeEIsT0FBTztBQUNILDBCQUFnQixVQUFVLEdBQUc7QUFDN0IsY0FBSSxpQkFBaUIsTUFBTTtBQUN2QixpQkFBSyxVQUFVO0FBQUEsVUFDbkI7QUFDQSxpQkFBTztBQUFBLFFBQ1g7QUFBQSxNQUNKO0FBRUEsVUFBSSxPQUFPO0FBQUEsUUFDUDtBQUFBLFFBQ0EsU0FBVSxLQUFLO0FBQ1gsY0FBSSxRQUFRLFFBQVc7QUFDbkIsbUJBQU8sS0FBSyxXQUFXO0FBQUEsVUFDM0IsT0FBTztBQUNILG1CQUFPLEtBQUssT0FBTyxHQUFHO0FBQUEsVUFDMUI7QUFBQSxRQUNKO0FBQUEsTUFDSjtBQUVBLGVBQVMsYUFBYTtBQUNsQixlQUFPLEtBQUs7QUFBQSxNQUNoQjtBQUVBLFVBQUksZ0JBQWdCLEtBQ2hCLGdCQUFnQixLQUFLLGVBQ3JCLGNBQWMsS0FBSyxlQUNuQixvQkFBb0IsTUFBTSxNQUFNLE1BQU0sS0FBSztBQUcvQyxlQUFTLE1BQU0sVUFBVSxTQUFTO0FBQzlCLGdCQUFTLFdBQVcsVUFBVyxXQUFXO0FBQUEsTUFDOUM7QUFFQSxlQUFTLGlCQUFpQixHQUFHLEdBQUcsR0FBRztBQUUvQixZQUFJLElBQUksT0FBTyxLQUFLLEdBQUc7QUFFbkIsaUJBQU8sSUFBSSxLQUFLLElBQUksS0FBSyxHQUFHLENBQUMsSUFBSTtBQUFBLFFBQ3JDLE9BQU87QUFDSCxpQkFBTyxJQUFJLEtBQUssR0FBRyxHQUFHLENBQUMsRUFBRSxRQUFRO0FBQUEsUUFDckM7QUFBQSxNQUNKO0FBRUEsZUFBUyxlQUFlLEdBQUcsR0FBRyxHQUFHO0FBRTdCLFlBQUksSUFBSSxPQUFPLEtBQUssR0FBRztBQUVuQixpQkFBTyxLQUFLLElBQUksSUFBSSxLQUFLLEdBQUcsQ0FBQyxJQUFJO0FBQUEsUUFDckMsT0FBTztBQUNILGlCQUFPLEtBQUssSUFBSSxHQUFHLEdBQUcsQ0FBQztBQUFBLFFBQzNCO0FBQUEsTUFDSjtBQUVBLGVBQVMsUUFBUSxPQUFPO0FBQ3BCLFlBQUksTUFBTTtBQUNWLGdCQUFRLGVBQWUsS0FBSztBQUM1QixZQUFJLFVBQVUsVUFBYSxVQUFVLGlCQUFpQixDQUFDLEtBQUssUUFBUSxHQUFHO0FBQ25FLGlCQUFPO0FBQUEsUUFDWDtBQUVBLHNCQUFjLEtBQUssU0FBUyxpQkFBaUI7QUFFN0MsZ0JBQVEsT0FBTztBQUFBLFVBQ1gsS0FBSztBQUNELG1CQUFPLFlBQVksS0FBSyxLQUFLLEdBQUcsR0FBRyxDQUFDO0FBQ3BDO0FBQUEsVUFDSixLQUFLO0FBQ0QsbUJBQU87QUFBQSxjQUNILEtBQUssS0FBSztBQUFBLGNBQ1YsS0FBSyxNQUFNLElBQUssS0FBSyxNQUFNLElBQUk7QUFBQSxjQUMvQjtBQUFBLFlBQ0o7QUFDQTtBQUFBLFVBQ0osS0FBSztBQUNELG1CQUFPLFlBQVksS0FBSyxLQUFLLEdBQUcsS0FBSyxNQUFNLEdBQUcsQ0FBQztBQUMvQztBQUFBLFVBQ0osS0FBSztBQUNELG1CQUFPO0FBQUEsY0FDSCxLQUFLLEtBQUs7QUFBQSxjQUNWLEtBQUssTUFBTTtBQUFBLGNBQ1gsS0FBSyxLQUFLLElBQUksS0FBSyxRQUFRO0FBQUEsWUFDL0I7QUFDQTtBQUFBLFVBQ0osS0FBSztBQUNELG1CQUFPO0FBQUEsY0FDSCxLQUFLLEtBQUs7QUFBQSxjQUNWLEtBQUssTUFBTTtBQUFBLGNBQ1gsS0FBSyxLQUFLLEtBQUssS0FBSyxXQUFXLElBQUk7QUFBQSxZQUN2QztBQUNBO0FBQUEsVUFDSixLQUFLO0FBQUEsVUFDTCxLQUFLO0FBQ0QsbUJBQU8sWUFBWSxLQUFLLEtBQUssR0FBRyxLQUFLLE1BQU0sR0FBRyxLQUFLLEtBQUssQ0FBQztBQUN6RDtBQUFBLFVBQ0osS0FBSztBQUNELG1CQUFPLEtBQUssR0FBRyxRQUFRO0FBQ3ZCLG9CQUFRO0FBQUEsY0FDSixRQUFRLEtBQUssU0FBUyxJQUFJLEtBQUssVUFBVSxJQUFJO0FBQUEsY0FDN0M7QUFBQSxZQUNKO0FBQ0E7QUFBQSxVQUNKLEtBQUs7QUFDRCxtQkFBTyxLQUFLLEdBQUcsUUFBUTtBQUN2QixvQkFBUSxNQUFNLE1BQU0sYUFBYTtBQUNqQztBQUFBLFVBQ0osS0FBSztBQUNELG1CQUFPLEtBQUssR0FBRyxRQUFRO0FBQ3ZCLG9CQUFRLE1BQU0sTUFBTSxhQUFhO0FBQ2pDO0FBQUEsUUFDUjtBQUVBLGFBQUssR0FBRyxRQUFRLElBQUk7QUFDcEIsY0FBTSxhQUFhLE1BQU0sSUFBSTtBQUM3QixlQUFPO0FBQUEsTUFDWDtBQUVBLGVBQVMsTUFBTSxPQUFPO0FBQ2xCLFlBQUksTUFBTTtBQUNWLGdCQUFRLGVBQWUsS0FBSztBQUM1QixZQUFJLFVBQVUsVUFBYSxVQUFVLGlCQUFpQixDQUFDLEtBQUssUUFBUSxHQUFHO0FBQ25FLGlCQUFPO0FBQUEsUUFDWDtBQUVBLHNCQUFjLEtBQUssU0FBUyxpQkFBaUI7QUFFN0MsZ0JBQVEsT0FBTztBQUFBLFVBQ1gsS0FBSztBQUNELG1CQUFPLFlBQVksS0FBSyxLQUFLLElBQUksR0FBRyxHQUFHLENBQUMsSUFBSTtBQUM1QztBQUFBLFVBQ0osS0FBSztBQUNELG1CQUNJO0FBQUEsY0FDSSxLQUFLLEtBQUs7QUFBQSxjQUNWLEtBQUssTUFBTSxJQUFLLEtBQUssTUFBTSxJQUFJLElBQUs7QUFBQSxjQUNwQztBQUFBLFlBQ0osSUFBSTtBQUNSO0FBQUEsVUFDSixLQUFLO0FBQ0QsbUJBQU8sWUFBWSxLQUFLLEtBQUssR0FBRyxLQUFLLE1BQU0sSUFBSSxHQUFHLENBQUMsSUFBSTtBQUN2RDtBQUFBLFVBQ0osS0FBSztBQUNELG1CQUNJO0FBQUEsY0FDSSxLQUFLLEtBQUs7QUFBQSxjQUNWLEtBQUssTUFBTTtBQUFBLGNBQ1gsS0FBSyxLQUFLLElBQUksS0FBSyxRQUFRLElBQUk7QUFBQSxZQUNuQyxJQUFJO0FBQ1I7QUFBQSxVQUNKLEtBQUs7QUFDRCxtQkFDSTtBQUFBLGNBQ0ksS0FBSyxLQUFLO0FBQUEsY0FDVixLQUFLLE1BQU07QUFBQSxjQUNYLEtBQUssS0FBSyxLQUFLLEtBQUssV0FBVyxJQUFJLEtBQUs7QUFBQSxZQUM1QyxJQUFJO0FBQ1I7QUFBQSxVQUNKLEtBQUs7QUFBQSxVQUNMLEtBQUs7QUFDRCxtQkFBTyxZQUFZLEtBQUssS0FBSyxHQUFHLEtBQUssTUFBTSxHQUFHLEtBQUssS0FBSyxJQUFJLENBQUMsSUFBSTtBQUNqRTtBQUFBLFVBQ0osS0FBSztBQUNELG1CQUFPLEtBQUssR0FBRyxRQUFRO0FBQ3ZCLG9CQUNJLGNBQ0E7QUFBQSxjQUNJLFFBQVEsS0FBSyxTQUFTLElBQUksS0FBSyxVQUFVLElBQUk7QUFBQSxjQUM3QztBQUFBLFlBQ0osSUFDQTtBQUNKO0FBQUEsVUFDSixLQUFLO0FBQ0QsbUJBQU8sS0FBSyxHQUFHLFFBQVE7QUFDdkIsb0JBQVEsZ0JBQWdCLE1BQU0sTUFBTSxhQUFhLElBQUk7QUFDckQ7QUFBQSxVQUNKLEtBQUs7QUFDRCxtQkFBTyxLQUFLLEdBQUcsUUFBUTtBQUN2QixvQkFBUSxnQkFBZ0IsTUFBTSxNQUFNLGFBQWEsSUFBSTtBQUNyRDtBQUFBLFFBQ1I7QUFFQSxhQUFLLEdBQUcsUUFBUSxJQUFJO0FBQ3BCLGNBQU0sYUFBYSxNQUFNLElBQUk7QUFDN0IsZUFBTztBQUFBLE1BQ1g7QUFFQSxlQUFTLFVBQVU7QUFDZixlQUFPLEtBQUssR0FBRyxRQUFRLEtBQUssS0FBSyxXQUFXLEtBQUs7QUFBQSxNQUNyRDtBQUVBLGVBQVMsT0FBTztBQUNaLGVBQU8sS0FBSyxNQUFNLEtBQUssUUFBUSxJQUFJLEdBQUk7QUFBQSxNQUMzQztBQUVBLGVBQVMsU0FBUztBQUNkLGVBQU8sSUFBSSxLQUFLLEtBQUssUUFBUSxDQUFDO0FBQUEsTUFDbEM7QUFFQSxlQUFTLFVBQVU7QUFDZixZQUFJLElBQUk7QUFDUixlQUFPO0FBQUEsVUFDSCxFQUFFLEtBQUs7QUFBQSxVQUNQLEVBQUUsTUFBTTtBQUFBLFVBQ1IsRUFBRSxLQUFLO0FBQUEsVUFDUCxFQUFFLEtBQUs7QUFBQSxVQUNQLEVBQUUsT0FBTztBQUFBLFVBQ1QsRUFBRSxPQUFPO0FBQUEsVUFDVCxFQUFFLFlBQVk7QUFBQSxRQUNsQjtBQUFBLE1BQ0o7QUFFQSxlQUFTLFdBQVc7QUFDaEIsWUFBSSxJQUFJO0FBQ1IsZUFBTztBQUFBLFVBQ0gsT0FBTyxFQUFFLEtBQUs7QUFBQSxVQUNkLFFBQVEsRUFBRSxNQUFNO0FBQUEsVUFDaEIsTUFBTSxFQUFFLEtBQUs7QUFBQSxVQUNiLE9BQU8sRUFBRSxNQUFNO0FBQUEsVUFDZixTQUFTLEVBQUUsUUFBUTtBQUFBLFVBQ25CLFNBQVMsRUFBRSxRQUFRO0FBQUEsVUFDbkIsY0FBYyxFQUFFLGFBQWE7QUFBQSxRQUNqQztBQUFBLE1BQ0o7QUFFQSxlQUFTLFNBQVM7QUFFZCxlQUFPLEtBQUssUUFBUSxJQUFJLEtBQUssWUFBWSxJQUFJO0FBQUEsTUFDakQ7QUFFQSxlQUFTLFlBQVk7QUFDakIsZUFBTyxRQUFRLElBQUk7QUFBQSxNQUN2QjtBQUVBLGVBQVMsZUFBZTtBQUNwQixlQUFPLE9BQU8sQ0FBQyxHQUFHLGdCQUFnQixJQUFJLENBQUM7QUFBQSxNQUMzQztBQUVBLGVBQVMsWUFBWTtBQUNqQixlQUFPLGdCQUFnQixJQUFJLEVBQUU7QUFBQSxNQUNqQztBQUVBLGVBQVMsZUFBZTtBQUNwQixlQUFPO0FBQUEsVUFDSCxPQUFPLEtBQUs7QUFBQSxVQUNaLFFBQVEsS0FBSztBQUFBLFVBQ2IsUUFBUSxLQUFLO0FBQUEsVUFDYixPQUFPLEtBQUs7QUFBQSxVQUNaLFFBQVEsS0FBSztBQUFBLFFBQ2pCO0FBQUEsTUFDSjtBQUVBLHFCQUFlLEtBQUssR0FBRyxHQUFHLFNBQVM7QUFDbkMscUJBQWUsTUFBTSxHQUFHLEdBQUcsU0FBUztBQUNwQyxxQkFBZSxPQUFPLEdBQUcsR0FBRyxTQUFTO0FBQ3JDLHFCQUFlLFFBQVEsR0FBRyxHQUFHLFNBQVM7QUFDdEMscUJBQWUsU0FBUyxHQUFHLEdBQUcsV0FBVztBQUV6QyxxQkFBZSxLQUFLLENBQUMsS0FBSyxDQUFDLEdBQUcsTUFBTSxTQUFTO0FBQzdDLHFCQUFlLEtBQUssQ0FBQyxNQUFNLENBQUMsR0FBRyxHQUFHLFNBQVM7QUFDM0MscUJBQWUsS0FBSyxDQUFDLE9BQU8sQ0FBQyxHQUFHLEdBQUcsU0FBUztBQUM1QyxxQkFBZSxLQUFLLENBQUMsUUFBUSxDQUFDLEdBQUcsR0FBRyxTQUFTO0FBRTdDLG9CQUFjLEtBQUssWUFBWTtBQUMvQixvQkFBYyxNQUFNLFlBQVk7QUFDaEMsb0JBQWMsT0FBTyxZQUFZO0FBQ2pDLG9CQUFjLFFBQVEsWUFBWTtBQUNsQyxvQkFBYyxTQUFTLGNBQWM7QUFFckMsb0JBQWMsQ0FBQyxLQUFLLE1BQU0sT0FBTyxRQUFRLE9BQU8sR0FBRyxTQUMvQyxPQUNBLE9BQ0EsUUFDQU0sUUFDRjtBQUNFLFlBQUksTUFBTSxPQUFPLFFBQVEsVUFBVSxPQUFPQSxRQUFPLE9BQU8sT0FBTztBQUMvRCxZQUFJLEtBQUs7QUFDTCwwQkFBZ0IsTUFBTSxFQUFFLE1BQU07QUFBQSxRQUNsQyxPQUFPO0FBQ0gsMEJBQWdCLE1BQU0sRUFBRSxhQUFhO0FBQUEsUUFDekM7QUFBQSxNQUNKLENBQUM7QUFFRCxvQkFBYyxLQUFLLGFBQWE7QUFDaEMsb0JBQWMsTUFBTSxhQUFhO0FBQ2pDLG9CQUFjLE9BQU8sYUFBYTtBQUNsQyxvQkFBYyxRQUFRLGFBQWE7QUFDbkMsb0JBQWMsTUFBTSxtQkFBbUI7QUFFdkMsb0JBQWMsQ0FBQyxLQUFLLE1BQU0sT0FBTyxNQUFNLEdBQUcsSUFBSTtBQUM5QyxvQkFBYyxDQUFDLElBQUksR0FBRyxTQUFVLE9BQU8sT0FBTyxRQUFRQSxRQUFPO0FBQ3pELFlBQUk7QUFDSixZQUFJLE9BQU8sUUFBUSxzQkFBc0I7QUFDckMsa0JBQVEsTUFBTSxNQUFNLE9BQU8sUUFBUSxvQkFBb0I7QUFBQSxRQUMzRDtBQUVBLFlBQUksT0FBTyxRQUFRLHFCQUFxQjtBQUNwQyxnQkFBTSxJQUFJLElBQUksT0FBTyxRQUFRLG9CQUFvQixPQUFPLEtBQUs7QUFBQSxRQUNqRSxPQUFPO0FBQ0gsZ0JBQU0sSUFBSSxJQUFJLFNBQVMsT0FBTyxFQUFFO0FBQUEsUUFDcEM7QUFBQSxNQUNKLENBQUM7QUFFRCxlQUFTLFdBQVcsR0FBR1IsU0FBUTtBQUMzQixZQUFJLEdBQ0EsR0FDQSxNQUNBLE9BQU8sS0FBSyxTQUFTLFVBQVUsSUFBSSxFQUFFO0FBQ3pDLGFBQUssSUFBSSxHQUFHLElBQUksS0FBSyxRQUFRLElBQUksR0FBRyxFQUFFLEdBQUc7QUFDckMsa0JBQVEsT0FBTyxLQUFLLENBQUMsRUFBRSxPQUFPO0FBQUEsWUFDMUIsS0FBSztBQUVELHFCQUFPLE1BQU0sS0FBSyxDQUFDLEVBQUUsS0FBSyxFQUFFLFFBQVEsS0FBSztBQUN6QyxtQkFBSyxDQUFDLEVBQUUsUUFBUSxLQUFLLFFBQVE7QUFDN0I7QUFBQSxVQUNSO0FBRUEsa0JBQVEsT0FBTyxLQUFLLENBQUMsRUFBRSxPQUFPO0FBQUEsWUFDMUIsS0FBSztBQUNELG1CQUFLLENBQUMsRUFBRSxRQUFRO0FBQ2hCO0FBQUEsWUFDSixLQUFLO0FBRUQscUJBQU8sTUFBTSxLQUFLLENBQUMsRUFBRSxLQUFLLEVBQUUsUUFBUSxLQUFLLEVBQUUsUUFBUTtBQUNuRCxtQkFBSyxDQUFDLEVBQUUsUUFBUSxLQUFLLFFBQVE7QUFDN0I7QUFBQSxVQUNSO0FBQUEsUUFDSjtBQUNBLGVBQU87QUFBQSxNQUNYO0FBRUEsZUFBUyxnQkFBZ0IsU0FBU0EsU0FBUSxRQUFRO0FBQzlDLFlBQUksR0FDQSxHQUNBLE9BQU8sS0FBSyxLQUFLLEdBQ2pCLE1BQ0EsTUFDQTtBQUNKLGtCQUFVLFFBQVEsWUFBWTtBQUU5QixhQUFLLElBQUksR0FBRyxJQUFJLEtBQUssUUFBUSxJQUFJLEdBQUcsRUFBRSxHQUFHO0FBQ3JDLGlCQUFPLEtBQUssQ0FBQyxFQUFFLEtBQUssWUFBWTtBQUNoQyxpQkFBTyxLQUFLLENBQUMsRUFBRSxLQUFLLFlBQVk7QUFDaEMsbUJBQVMsS0FBSyxDQUFDLEVBQUUsT0FBTyxZQUFZO0FBRXBDLGNBQUksUUFBUTtBQUNSLG9CQUFRQSxTQUFRO0FBQUEsY0FDWixLQUFLO0FBQUEsY0FDTCxLQUFLO0FBQUEsY0FDTCxLQUFLO0FBQ0Qsb0JBQUksU0FBUyxTQUFTO0FBQ2xCLHlCQUFPLEtBQUssQ0FBQztBQUFBLGdCQUNqQjtBQUNBO0FBQUEsY0FFSixLQUFLO0FBQ0Qsb0JBQUksU0FBUyxTQUFTO0FBQ2xCLHlCQUFPLEtBQUssQ0FBQztBQUFBLGdCQUNqQjtBQUNBO0FBQUEsY0FFSixLQUFLO0FBQ0Qsb0JBQUksV0FBVyxTQUFTO0FBQ3BCLHlCQUFPLEtBQUssQ0FBQztBQUFBLGdCQUNqQjtBQUNBO0FBQUEsWUFDUjtBQUFBLFVBQ0osV0FBVyxDQUFDLE1BQU0sTUFBTSxNQUFNLEVBQUUsUUFBUSxPQUFPLEtBQUssR0FBRztBQUNuRCxtQkFBTyxLQUFLLENBQUM7QUFBQSxVQUNqQjtBQUFBLFFBQ0o7QUFBQSxNQUNKO0FBRUEsZUFBUyxzQkFBc0IsS0FBSyxNQUFNO0FBQ3RDLFlBQUksTUFBTSxJQUFJLFNBQVMsSUFBSSxRQUFRLElBQUs7QUFDeEMsWUFBSSxTQUFTLFFBQVc7QUFDcEIsaUJBQU8sTUFBTSxJQUFJLEtBQUssRUFBRSxLQUFLO0FBQUEsUUFDakMsT0FBTztBQUNILGlCQUFPLE1BQU0sSUFBSSxLQUFLLEVBQUUsS0FBSyxLQUFLLE9BQU8sSUFBSSxVQUFVO0FBQUEsUUFDM0Q7QUFBQSxNQUNKO0FBRUEsZUFBUyxhQUFhO0FBQ2xCLFlBQUksR0FDQSxHQUNBLEtBQ0EsT0FBTyxLQUFLLFdBQVcsRUFBRSxLQUFLO0FBQ2xDLGFBQUssSUFBSSxHQUFHLElBQUksS0FBSyxRQUFRLElBQUksR0FBRyxFQUFFLEdBQUc7QUFFckMsZ0JBQU0sS0FBSyxNQUFNLEVBQUUsUUFBUSxLQUFLLEVBQUUsUUFBUTtBQUUxQyxjQUFJLEtBQUssQ0FBQyxFQUFFLFNBQVMsT0FBTyxPQUFPLEtBQUssQ0FBQyxFQUFFLE9BQU87QUFDOUMsbUJBQU8sS0FBSyxDQUFDLEVBQUU7QUFBQSxVQUNuQjtBQUNBLGNBQUksS0FBSyxDQUFDLEVBQUUsU0FBUyxPQUFPLE9BQU8sS0FBSyxDQUFDLEVBQUUsT0FBTztBQUM5QyxtQkFBTyxLQUFLLENBQUMsRUFBRTtBQUFBLFVBQ25CO0FBQUEsUUFDSjtBQUVBLGVBQU87QUFBQSxNQUNYO0FBRUEsZUFBUyxlQUFlO0FBQ3BCLFlBQUksR0FDQSxHQUNBLEtBQ0EsT0FBTyxLQUFLLFdBQVcsRUFBRSxLQUFLO0FBQ2xDLGFBQUssSUFBSSxHQUFHLElBQUksS0FBSyxRQUFRLElBQUksR0FBRyxFQUFFLEdBQUc7QUFFckMsZ0JBQU0sS0FBSyxNQUFNLEVBQUUsUUFBUSxLQUFLLEVBQUUsUUFBUTtBQUUxQyxjQUFJLEtBQUssQ0FBQyxFQUFFLFNBQVMsT0FBTyxPQUFPLEtBQUssQ0FBQyxFQUFFLE9BQU87QUFDOUMsbUJBQU8sS0FBSyxDQUFDLEVBQUU7QUFBQSxVQUNuQjtBQUNBLGNBQUksS0FBSyxDQUFDLEVBQUUsU0FBUyxPQUFPLE9BQU8sS0FBSyxDQUFDLEVBQUUsT0FBTztBQUM5QyxtQkFBTyxLQUFLLENBQUMsRUFBRTtBQUFBLFVBQ25CO0FBQUEsUUFDSjtBQUVBLGVBQU87QUFBQSxNQUNYO0FBRUEsZUFBUyxhQUFhO0FBQ2xCLFlBQUksR0FDQSxHQUNBLEtBQ0EsT0FBTyxLQUFLLFdBQVcsRUFBRSxLQUFLO0FBQ2xDLGFBQUssSUFBSSxHQUFHLElBQUksS0FBSyxRQUFRLElBQUksR0FBRyxFQUFFLEdBQUc7QUFFckMsZ0JBQU0sS0FBSyxNQUFNLEVBQUUsUUFBUSxLQUFLLEVBQUUsUUFBUTtBQUUxQyxjQUFJLEtBQUssQ0FBQyxFQUFFLFNBQVMsT0FBTyxPQUFPLEtBQUssQ0FBQyxFQUFFLE9BQU87QUFDOUMsbUJBQU8sS0FBSyxDQUFDLEVBQUU7QUFBQSxVQUNuQjtBQUNBLGNBQUksS0FBSyxDQUFDLEVBQUUsU0FBUyxPQUFPLE9BQU8sS0FBSyxDQUFDLEVBQUUsT0FBTztBQUM5QyxtQkFBTyxLQUFLLENBQUMsRUFBRTtBQUFBLFVBQ25CO0FBQUEsUUFDSjtBQUVBLGVBQU87QUFBQSxNQUNYO0FBRUEsZUFBUyxhQUFhO0FBQ2xCLFlBQUksR0FDQSxHQUNBLEtBQ0EsS0FDQSxPQUFPLEtBQUssV0FBVyxFQUFFLEtBQUs7QUFDbEMsYUFBSyxJQUFJLEdBQUcsSUFBSSxLQUFLLFFBQVEsSUFBSSxHQUFHLEVBQUUsR0FBRztBQUNyQyxnQkFBTSxLQUFLLENBQUMsRUFBRSxTQUFTLEtBQUssQ0FBQyxFQUFFLFFBQVEsSUFBSztBQUc1QyxnQkFBTSxLQUFLLE1BQU0sRUFBRSxRQUFRLEtBQUssRUFBRSxRQUFRO0FBRTFDLGNBQ0ssS0FBSyxDQUFDLEVBQUUsU0FBUyxPQUFPLE9BQU8sS0FBSyxDQUFDLEVBQUUsU0FDdkMsS0FBSyxDQUFDLEVBQUUsU0FBUyxPQUFPLE9BQU8sS0FBSyxDQUFDLEVBQUUsT0FDMUM7QUFDRSxvQkFDSyxLQUFLLEtBQUssSUFBSSxNQUFNLEtBQUssQ0FBQyxFQUFFLEtBQUssRUFBRSxLQUFLLEtBQUssTUFDOUMsS0FBSyxDQUFDLEVBQUU7QUFBQSxVQUVoQjtBQUFBLFFBQ0o7QUFFQSxlQUFPLEtBQUssS0FBSztBQUFBLE1BQ3JCO0FBRUEsZUFBUyxjQUFjLFVBQVU7QUFDN0IsWUFBSSxDQUFDLFdBQVcsTUFBTSxnQkFBZ0IsR0FBRztBQUNyQywyQkFBaUIsS0FBSyxJQUFJO0FBQUEsUUFDOUI7QUFDQSxlQUFPLFdBQVcsS0FBSyxpQkFBaUIsS0FBSztBQUFBLE1BQ2pEO0FBRUEsZUFBUyxjQUFjLFVBQVU7QUFDN0IsWUFBSSxDQUFDLFdBQVcsTUFBTSxnQkFBZ0IsR0FBRztBQUNyQywyQkFBaUIsS0FBSyxJQUFJO0FBQUEsUUFDOUI7QUFDQSxlQUFPLFdBQVcsS0FBSyxpQkFBaUIsS0FBSztBQUFBLE1BQ2pEO0FBRUEsZUFBUyxnQkFBZ0IsVUFBVTtBQUMvQixZQUFJLENBQUMsV0FBVyxNQUFNLGtCQUFrQixHQUFHO0FBQ3ZDLDJCQUFpQixLQUFLLElBQUk7QUFBQSxRQUM5QjtBQUNBLGVBQU8sV0FBVyxLQUFLLG1CQUFtQixLQUFLO0FBQUEsTUFDbkQ7QUFFQSxlQUFTLGFBQWEsVUFBVUMsU0FBUTtBQUNwQyxlQUFPQSxRQUFPLGNBQWMsUUFBUTtBQUFBLE1BQ3hDO0FBRUEsZUFBUyxhQUFhLFVBQVVBLFNBQVE7QUFDcEMsZUFBT0EsUUFBTyxjQUFjLFFBQVE7QUFBQSxNQUN4QztBQUVBLGVBQVMsZUFBZSxVQUFVQSxTQUFRO0FBQ3RDLGVBQU9BLFFBQU8sZ0JBQWdCLFFBQVE7QUFBQSxNQUMxQztBQUVBLGVBQVMsb0JBQW9CLFVBQVVBLFNBQVE7QUFDM0MsZUFBT0EsUUFBTyx3QkFBd0I7QUFBQSxNQUMxQztBQUVBLGVBQVMsbUJBQW1CO0FBQ3hCLFlBQUksYUFBYSxDQUFDLEdBQ2QsYUFBYSxDQUFDLEdBQ2QsZUFBZSxDQUFDLEdBQ2hCLGNBQWMsQ0FBQyxHQUNmLEdBQ0EsR0FDQSxPQUFPLEtBQUssS0FBSztBQUVyQixhQUFLLElBQUksR0FBRyxJQUFJLEtBQUssUUFBUSxJQUFJLEdBQUcsRUFBRSxHQUFHO0FBQ3JDLHFCQUFXLEtBQUssWUFBWSxLQUFLLENBQUMsRUFBRSxJQUFJLENBQUM7QUFDekMscUJBQVcsS0FBSyxZQUFZLEtBQUssQ0FBQyxFQUFFLElBQUksQ0FBQztBQUN6Qyx1QkFBYSxLQUFLLFlBQVksS0FBSyxDQUFDLEVBQUUsTUFBTSxDQUFDO0FBRTdDLHNCQUFZLEtBQUssWUFBWSxLQUFLLENBQUMsRUFBRSxJQUFJLENBQUM7QUFDMUMsc0JBQVksS0FBSyxZQUFZLEtBQUssQ0FBQyxFQUFFLElBQUksQ0FBQztBQUMxQyxzQkFBWSxLQUFLLFlBQVksS0FBSyxDQUFDLEVBQUUsTUFBTSxDQUFDO0FBQUEsUUFDaEQ7QUFFQSxhQUFLLGFBQWEsSUFBSSxPQUFPLE9BQU8sWUFBWSxLQUFLLEdBQUcsSUFBSSxLQUFLLEdBQUc7QUFDcEUsYUFBSyxpQkFBaUIsSUFBSSxPQUFPLE9BQU8sV0FBVyxLQUFLLEdBQUcsSUFBSSxLQUFLLEdBQUc7QUFDdkUsYUFBSyxpQkFBaUIsSUFBSSxPQUFPLE9BQU8sV0FBVyxLQUFLLEdBQUcsSUFBSSxLQUFLLEdBQUc7QUFDdkUsYUFBSyxtQkFBbUIsSUFBSTtBQUFBLFVBQ3hCLE9BQU8sYUFBYSxLQUFLLEdBQUcsSUFBSTtBQUFBLFVBQ2hDO0FBQUEsUUFDSjtBQUFBLE1BQ0o7QUFJQSxxQkFBZSxHQUFHLENBQUMsTUFBTSxDQUFDLEdBQUcsR0FBRyxXQUFZO0FBQ3hDLGVBQU8sS0FBSyxTQUFTLElBQUk7QUFBQSxNQUM3QixDQUFDO0FBRUQscUJBQWUsR0FBRyxDQUFDLE1BQU0sQ0FBQyxHQUFHLEdBQUcsV0FBWTtBQUN4QyxlQUFPLEtBQUssWUFBWSxJQUFJO0FBQUEsTUFDaEMsQ0FBQztBQUVELGVBQVMsdUJBQXVCTyxRQUFPLFFBQVE7QUFDM0MsdUJBQWUsR0FBRyxDQUFDQSxRQUFPQSxPQUFNLE1BQU0sR0FBRyxHQUFHLE1BQU07QUFBQSxNQUN0RDtBQUVBLDZCQUF1QixRQUFRLFVBQVU7QUFDekMsNkJBQXVCLFNBQVMsVUFBVTtBQUMxQyw2QkFBdUIsUUFBUSxhQUFhO0FBQzVDLDZCQUF1QixTQUFTLGFBQWE7QUFJN0MsbUJBQWEsWUFBWSxJQUFJO0FBQzdCLG1CQUFhLGVBQWUsSUFBSTtBQUloQyxzQkFBZ0IsWUFBWSxDQUFDO0FBQzdCLHNCQUFnQixlQUFlLENBQUM7QUFJaEMsb0JBQWMsS0FBSyxXQUFXO0FBQzlCLG9CQUFjLEtBQUssV0FBVztBQUM5QixvQkFBYyxNQUFNLFdBQVcsTUFBTTtBQUNyQyxvQkFBYyxNQUFNLFdBQVcsTUFBTTtBQUNyQyxvQkFBYyxRQUFRLFdBQVcsTUFBTTtBQUN2QyxvQkFBYyxRQUFRLFdBQVcsTUFBTTtBQUN2QyxvQkFBYyxTQUFTLFdBQVcsTUFBTTtBQUN4QyxvQkFBYyxTQUFTLFdBQVcsTUFBTTtBQUV4Qyx3QkFBa0IsQ0FBQyxRQUFRLFNBQVMsUUFBUSxPQUFPLEdBQUcsU0FDbEQsT0FDQSxNQUNBLFFBQ0FBLFFBQ0Y7QUFDRSxhQUFLQSxPQUFNLE9BQU8sR0FBRyxDQUFDLENBQUMsSUFBSSxNQUFNLEtBQUs7QUFBQSxNQUMxQyxDQUFDO0FBRUQsd0JBQWtCLENBQUMsTUFBTSxJQUFJLEdBQUcsU0FBVSxPQUFPLE1BQU0sUUFBUUEsUUFBTztBQUNsRSxhQUFLQSxNQUFLLElBQUksTUFBTSxrQkFBa0IsS0FBSztBQUFBLE1BQy9DLENBQUM7QUFJRCxlQUFTLGVBQWUsT0FBTztBQUMzQixlQUFPLHFCQUFxQjtBQUFBLFVBQ3hCO0FBQUEsVUFDQTtBQUFBLFVBQ0EsS0FBSyxLQUFLO0FBQUEsVUFDVixLQUFLLFFBQVE7QUFBQSxVQUNiLEtBQUssV0FBVyxFQUFFLE1BQU07QUFBQSxVQUN4QixLQUFLLFdBQVcsRUFBRSxNQUFNO0FBQUEsUUFDNUI7QUFBQSxNQUNKO0FBRUEsZUFBUyxrQkFBa0IsT0FBTztBQUM5QixlQUFPLHFCQUFxQjtBQUFBLFVBQ3hCO0FBQUEsVUFDQTtBQUFBLFVBQ0EsS0FBSyxRQUFRO0FBQUEsVUFDYixLQUFLLFdBQVc7QUFBQSxVQUNoQjtBQUFBLFVBQ0E7QUFBQSxRQUNKO0FBQUEsTUFDSjtBQUVBLGVBQVMsb0JBQW9CO0FBQ3pCLGVBQU8sWUFBWSxLQUFLLEtBQUssR0FBRyxHQUFHLENBQUM7QUFBQSxNQUN4QztBQUVBLGVBQVMsMkJBQTJCO0FBQ2hDLGVBQU8sWUFBWSxLQUFLLFlBQVksR0FBRyxHQUFHLENBQUM7QUFBQSxNQUMvQztBQUVBLGVBQVMsaUJBQWlCO0FBQ3RCLFlBQUksV0FBVyxLQUFLLFdBQVcsRUFBRTtBQUNqQyxlQUFPLFlBQVksS0FBSyxLQUFLLEdBQUcsU0FBUyxLQUFLLFNBQVMsR0FBRztBQUFBLE1BQzlEO0FBRUEsZUFBUyxxQkFBcUI7QUFDMUIsWUFBSSxXQUFXLEtBQUssV0FBVyxFQUFFO0FBQ2pDLGVBQU8sWUFBWSxLQUFLLFNBQVMsR0FBRyxTQUFTLEtBQUssU0FBUyxHQUFHO0FBQUEsTUFDbEU7QUFFQSxlQUFTLHFCQUFxQixPQUFPLE1BQU0sU0FBUyxLQUFLLEtBQUs7QUFDMUQsWUFBSTtBQUNKLFlBQUksU0FBUyxNQUFNO0FBQ2YsaUJBQU8sV0FBVyxNQUFNLEtBQUssR0FBRyxFQUFFO0FBQUEsUUFDdEMsT0FBTztBQUNILHdCQUFjLFlBQVksT0FBTyxLQUFLLEdBQUc7QUFDekMsY0FBSSxPQUFPLGFBQWE7QUFDcEIsbUJBQU87QUFBQSxVQUNYO0FBQ0EsaUJBQU8sV0FBVyxLQUFLLE1BQU0sT0FBTyxNQUFNLFNBQVMsS0FBSyxHQUFHO0FBQUEsUUFDL0Q7QUFBQSxNQUNKO0FBRUEsZUFBUyxXQUFXLFVBQVUsTUFBTSxTQUFTLEtBQUssS0FBSztBQUNuRCxZQUFJLGdCQUFnQixtQkFBbUIsVUFBVSxNQUFNLFNBQVMsS0FBSyxHQUFHLEdBQ3BFLE9BQU8sY0FBYyxjQUFjLE1BQU0sR0FBRyxjQUFjLFNBQVM7QUFFdkUsYUFBSyxLQUFLLEtBQUssZUFBZSxDQUFDO0FBQy9CLGFBQUssTUFBTSxLQUFLLFlBQVksQ0FBQztBQUM3QixhQUFLLEtBQUssS0FBSyxXQUFXLENBQUM7QUFDM0IsZUFBTztBQUFBLE1BQ1g7QUFJQSxxQkFBZSxLQUFLLEdBQUcsTUFBTSxTQUFTO0FBSXRDLG1CQUFhLFdBQVcsR0FBRztBQUkzQixzQkFBZ0IsV0FBVyxDQUFDO0FBSTVCLG9CQUFjLEtBQUssTUFBTTtBQUN6QixvQkFBYyxLQUFLLFNBQVUsT0FBTyxPQUFPO0FBQ3ZDLGNBQU0sS0FBSyxLQUFLLE1BQU0sS0FBSyxJQUFJLEtBQUs7QUFBQSxNQUN4QyxDQUFDO0FBSUQsZUFBUyxjQUFjLE9BQU87QUFDMUIsZUFBTyxTQUFTLE9BQ1YsS0FBSyxNQUFNLEtBQUssTUFBTSxJQUFJLEtBQUssQ0FBQyxJQUNoQyxLQUFLLE9BQU8sUUFBUSxLQUFLLElBQUssS0FBSyxNQUFNLElBQUksQ0FBRTtBQUFBLE1BQ3pEO0FBSUEscUJBQWUsS0FBSyxDQUFDLE1BQU0sQ0FBQyxHQUFHLE1BQU0sTUFBTTtBQUkzQyxtQkFBYSxRQUFRLEdBQUc7QUFHeEIsc0JBQWdCLFFBQVEsQ0FBQztBQUl6QixvQkFBYyxLQUFLLFNBQVM7QUFDNUIsb0JBQWMsTUFBTSxXQUFXLE1BQU07QUFDckMsb0JBQWMsTUFBTSxTQUFVLFVBQVVQLFNBQVE7QUFFNUMsZUFBTyxXQUNEQSxRQUFPLDJCQUEyQkEsUUFBTyxnQkFDekNBLFFBQU87QUFBQSxNQUNqQixDQUFDO0FBRUQsb0JBQWMsQ0FBQyxLQUFLLElBQUksR0FBRyxJQUFJO0FBQy9CLG9CQUFjLE1BQU0sU0FBVSxPQUFPLE9BQU87QUFDeEMsY0FBTSxJQUFJLElBQUksTUFBTSxNQUFNLE1BQU0sU0FBUyxFQUFFLENBQUMsQ0FBQztBQUFBLE1BQ2pELENBQUM7QUFJRCxVQUFJLG1CQUFtQixXQUFXLFFBQVEsSUFBSTtBQUk5QyxxQkFBZSxPQUFPLENBQUMsUUFBUSxDQUFDLEdBQUcsUUFBUSxXQUFXO0FBSXRELG1CQUFhLGFBQWEsS0FBSztBQUcvQixzQkFBZ0IsYUFBYSxDQUFDO0FBSTlCLG9CQUFjLE9BQU8sU0FBUztBQUM5QixvQkFBYyxRQUFRLE1BQU07QUFDNUIsb0JBQWMsQ0FBQyxPQUFPLE1BQU0sR0FBRyxTQUFVLE9BQU8sT0FBTyxRQUFRO0FBQzNELGVBQU8sYUFBYSxNQUFNLEtBQUs7QUFBQSxNQUNuQyxDQUFDO0FBTUQsZUFBUyxnQkFBZ0IsT0FBTztBQUM1QixZQUFJLFlBQ0EsS0FBSztBQUFBLFdBQ0EsS0FBSyxNQUFNLEVBQUUsUUFBUSxLQUFLLElBQUksS0FBSyxNQUFNLEVBQUUsUUFBUSxNQUFNLEtBQUs7QUFBQSxRQUNuRSxJQUFJO0FBQ1IsZUFBTyxTQUFTLE9BQU8sWUFBWSxLQUFLLElBQUksUUFBUSxXQUFXLEdBQUc7QUFBQSxNQUN0RTtBQUlBLHFCQUFlLEtBQUssQ0FBQyxNQUFNLENBQUMsR0FBRyxHQUFHLFFBQVE7QUFJMUMsbUJBQWEsVUFBVSxHQUFHO0FBSTFCLHNCQUFnQixVQUFVLEVBQUU7QUFJNUIsb0JBQWMsS0FBSyxTQUFTO0FBQzVCLG9CQUFjLE1BQU0sV0FBVyxNQUFNO0FBQ3JDLG9CQUFjLENBQUMsS0FBSyxJQUFJLEdBQUcsTUFBTTtBQUlqQyxVQUFJLGVBQWUsV0FBVyxXQUFXLEtBQUs7QUFJOUMscUJBQWUsS0FBSyxDQUFDLE1BQU0sQ0FBQyxHQUFHLEdBQUcsUUFBUTtBQUkxQyxtQkFBYSxVQUFVLEdBQUc7QUFJMUIsc0JBQWdCLFVBQVUsRUFBRTtBQUk1QixvQkFBYyxLQUFLLFNBQVM7QUFDNUIsb0JBQWMsTUFBTSxXQUFXLE1BQU07QUFDckMsb0JBQWMsQ0FBQyxLQUFLLElBQUksR0FBRyxNQUFNO0FBSWpDLFVBQUksZUFBZSxXQUFXLFdBQVcsS0FBSztBQUk5QyxxQkFBZSxLQUFLLEdBQUcsR0FBRyxXQUFZO0FBQ2xDLGVBQU8sQ0FBQyxFQUFFLEtBQUssWUFBWSxJQUFJO0FBQUEsTUFDbkMsQ0FBQztBQUVELHFCQUFlLEdBQUcsQ0FBQyxNQUFNLENBQUMsR0FBRyxHQUFHLFdBQVk7QUFDeEMsZUFBTyxDQUFDLEVBQUUsS0FBSyxZQUFZLElBQUk7QUFBQSxNQUNuQyxDQUFDO0FBRUQscUJBQWUsR0FBRyxDQUFDLE9BQU8sQ0FBQyxHQUFHLEdBQUcsYUFBYTtBQUM5QyxxQkFBZSxHQUFHLENBQUMsUUFBUSxDQUFDLEdBQUcsR0FBRyxXQUFZO0FBQzFDLGVBQU8sS0FBSyxZQUFZLElBQUk7QUFBQSxNQUNoQyxDQUFDO0FBQ0QscUJBQWUsR0FBRyxDQUFDLFNBQVMsQ0FBQyxHQUFHLEdBQUcsV0FBWTtBQUMzQyxlQUFPLEtBQUssWUFBWSxJQUFJO0FBQUEsTUFDaEMsQ0FBQztBQUNELHFCQUFlLEdBQUcsQ0FBQyxVQUFVLENBQUMsR0FBRyxHQUFHLFdBQVk7QUFDNUMsZUFBTyxLQUFLLFlBQVksSUFBSTtBQUFBLE1BQ2hDLENBQUM7QUFDRCxxQkFBZSxHQUFHLENBQUMsV0FBVyxDQUFDLEdBQUcsR0FBRyxXQUFZO0FBQzdDLGVBQU8sS0FBSyxZQUFZLElBQUk7QUFBQSxNQUNoQyxDQUFDO0FBQ0QscUJBQWUsR0FBRyxDQUFDLFlBQVksQ0FBQyxHQUFHLEdBQUcsV0FBWTtBQUM5QyxlQUFPLEtBQUssWUFBWSxJQUFJO0FBQUEsTUFDaEMsQ0FBQztBQUNELHFCQUFlLEdBQUcsQ0FBQyxhQUFhLENBQUMsR0FBRyxHQUFHLFdBQVk7QUFDL0MsZUFBTyxLQUFLLFlBQVksSUFBSTtBQUFBLE1BQ2hDLENBQUM7QUFJRCxtQkFBYSxlQUFlLElBQUk7QUFJaEMsc0JBQWdCLGVBQWUsRUFBRTtBQUlqQyxvQkFBYyxLQUFLLFdBQVcsTUFBTTtBQUNwQyxvQkFBYyxNQUFNLFdBQVcsTUFBTTtBQUNyQyxvQkFBYyxPQUFPLFdBQVcsTUFBTTtBQUV0QyxVQUFJLE9BQU87QUFDWCxXQUFLLFFBQVEsUUFBUSxNQUFNLFVBQVUsR0FBRyxTQUFTLEtBQUs7QUFDbEQsc0JBQWMsT0FBTyxhQUFhO0FBQUEsTUFDdEM7QUFFQSxlQUFTLFFBQVEsT0FBTyxPQUFPO0FBQzNCLGNBQU0sV0FBVyxJQUFJLE9BQU8sT0FBTyxTQUFTLEdBQUk7QUFBQSxNQUNwRDtBQUVBLFdBQUssUUFBUSxLQUFLLE1BQU0sVUFBVSxHQUFHLFNBQVMsS0FBSztBQUMvQyxzQkFBYyxPQUFPLE9BQU87QUFBQSxNQUNoQztBQUVBLDBCQUFvQixXQUFXLGdCQUFnQixLQUFLO0FBSXBELHFCQUFlLEtBQUssR0FBRyxHQUFHLFVBQVU7QUFDcEMscUJBQWUsTUFBTSxHQUFHLEdBQUcsVUFBVTtBQUlyQyxlQUFTLGNBQWM7QUFDbkIsZUFBTyxLQUFLLFNBQVMsUUFBUTtBQUFBLE1BQ2pDO0FBRUEsZUFBUyxjQUFjO0FBQ25CLGVBQU8sS0FBSyxTQUFTLCtCQUErQjtBQUFBLE1BQ3hEO0FBRUEsVUFBSSxRQUFRLE9BQU87QUFFbkIsWUFBTSxNQUFNO0FBQ1osWUFBTSxXQUFXO0FBQ2pCLFlBQU0sUUFBUTtBQUNkLFlBQU0sT0FBTztBQUNiLFlBQU0sUUFBUTtBQUNkLFlBQU0sU0FBUztBQUNmLFlBQU0sT0FBTztBQUNiLFlBQU0sVUFBVTtBQUNoQixZQUFNLEtBQUs7QUFDWCxZQUFNLFFBQVE7QUFDZCxZQUFNLE1BQU07QUFDWixZQUFNLFlBQVk7QUFDbEIsWUFBTSxVQUFVO0FBQ2hCLFlBQU0sV0FBVztBQUNqQixZQUFNLFlBQVk7QUFDbEIsWUFBTSxTQUFTO0FBQ2YsWUFBTSxnQkFBZ0I7QUFDdEIsWUFBTSxpQkFBaUI7QUFDdkIsWUFBTSxVQUFVO0FBQ2hCLFlBQU0sT0FBTztBQUNiLFlBQU0sU0FBUztBQUNmLFlBQU0sYUFBYTtBQUNuQixZQUFNLE1BQU07QUFDWixZQUFNLE1BQU07QUFDWixZQUFNLGVBQWU7QUFDckIsWUFBTSxNQUFNO0FBQ1osWUFBTSxVQUFVO0FBQ2hCLFlBQU0sV0FBVztBQUNqQixZQUFNLFVBQVU7QUFDaEIsWUFBTSxXQUFXO0FBQ2pCLFlBQU0sU0FBUztBQUNmLFlBQU0sY0FBYztBQUNwQixZQUFNLFVBQVU7QUFDaEIsVUFBSSxPQUFPLFdBQVcsZUFBZSxPQUFPLE9BQU8sTUFBTTtBQUNyRCxjQUFNLE9BQU8sSUFBSSw0QkFBNEIsQ0FBQyxJQUFJLFdBQVk7QUFDMUQsaUJBQU8sWUFBWSxLQUFLLE9BQU8sSUFBSTtBQUFBLFFBQ3ZDO0FBQUEsTUFDSjtBQUNBLFlBQU0sU0FBUztBQUNmLFlBQU0sV0FBVztBQUNqQixZQUFNLE9BQU87QUFDYixZQUFNLFVBQVU7QUFDaEIsWUFBTSxlQUFlO0FBQ3JCLFlBQU0sVUFBVTtBQUNoQixZQUFNLFlBQVk7QUFDbEIsWUFBTSxVQUFVO0FBQ2hCLFlBQU0sVUFBVTtBQUNoQixZQUFNLE9BQU87QUFDYixZQUFNLGFBQWE7QUFDbkIsWUFBTSxXQUFXO0FBQ2pCLFlBQU0sY0FBYztBQUNwQixZQUFNLFVBQVUsTUFBTSxXQUFXO0FBQ2pDLFlBQU0sUUFBUTtBQUNkLFlBQU0sY0FBYztBQUNwQixZQUFNLE9BQU8sTUFBTSxRQUFRO0FBQzNCLFlBQU0sVUFBVSxNQUFNLFdBQVc7QUFDakMsWUFBTSxjQUFjO0FBQ3BCLFlBQU0sa0JBQWtCO0FBQ3hCLFlBQU0saUJBQWlCO0FBQ3ZCLFlBQU0sd0JBQXdCO0FBQzlCLFlBQU0sT0FBTztBQUNiLFlBQU0sTUFBTSxNQUFNLE9BQU87QUFDekIsWUFBTSxVQUFVO0FBQ2hCLFlBQU0sYUFBYTtBQUNuQixZQUFNLFlBQVk7QUFDbEIsWUFBTSxPQUFPLE1BQU0sUUFBUTtBQUMzQixZQUFNLFNBQVMsTUFBTSxVQUFVO0FBQy9CLFlBQU0sU0FBUyxNQUFNLFVBQVU7QUFDL0IsWUFBTSxjQUFjLE1BQU0sZUFBZTtBQUN6QyxZQUFNLFlBQVk7QUFDbEIsWUFBTSxNQUFNO0FBQ1osWUFBTSxRQUFRO0FBQ2QsWUFBTSxZQUFZO0FBQ2xCLFlBQU0sdUJBQXVCO0FBQzdCLFlBQU0sUUFBUTtBQUNkLFlBQU0sVUFBVTtBQUNoQixZQUFNLGNBQWM7QUFDcEIsWUFBTSxRQUFRO0FBQ2QsWUFBTSxRQUFRO0FBQ2QsWUFBTSxXQUFXO0FBQ2pCLFlBQU0sV0FBVztBQUNqQixZQUFNLFFBQVE7QUFBQSxRQUNWO0FBQUEsUUFDQTtBQUFBLE1BQ0o7QUFDQSxZQUFNLFNBQVM7QUFBQSxRQUNYO0FBQUEsUUFDQTtBQUFBLE1BQ0o7QUFDQSxZQUFNLFFBQVE7QUFBQSxRQUNWO0FBQUEsUUFDQTtBQUFBLE1BQ0o7QUFDQSxZQUFNLE9BQU87QUFBQSxRQUNUO0FBQUEsUUFDQTtBQUFBLE1BQ0o7QUFDQSxZQUFNLGVBQWU7QUFBQSxRQUNqQjtBQUFBLFFBQ0E7QUFBQSxNQUNKO0FBRUEsZUFBUyxXQUFXLE9BQU87QUFDdkIsZUFBTyxZQUFZLFFBQVEsR0FBSTtBQUFBLE1BQ25DO0FBRUEsZUFBUyxlQUFlO0FBQ3BCLGVBQU8sWUFBWSxNQUFNLE1BQU0sU0FBUyxFQUFFLFVBQVU7QUFBQSxNQUN4RDtBQUVBLGVBQVMsbUJBQW1CVSxTQUFRO0FBQ2hDLGVBQU9BO0FBQUEsTUFDWDtBQUVBLFVBQUksVUFBVSxPQUFPO0FBRXJCLGNBQVEsV0FBVztBQUNuQixjQUFRLGlCQUFpQjtBQUN6QixjQUFRLGNBQWM7QUFDdEIsY0FBUSxVQUFVO0FBQ2xCLGNBQVEsV0FBVztBQUNuQixjQUFRLGFBQWE7QUFDckIsY0FBUSxlQUFlO0FBQ3ZCLGNBQVEsYUFBYTtBQUNyQixjQUFRLE1BQU1OO0FBQ2QsY0FBUSxPQUFPO0FBQ2YsY0FBUSxZQUFZO0FBQ3BCLGNBQVEsa0JBQWtCO0FBQzFCLGNBQVEsZ0JBQWdCO0FBQ3hCLGNBQVEsZ0JBQWdCO0FBQ3hCLGNBQVEsa0JBQWtCO0FBRTFCLGNBQVEsU0FBUztBQUNqQixjQUFRLGNBQWM7QUFDdEIsY0FBUSxjQUFjO0FBQ3RCLGNBQVEsY0FBYztBQUN0QixjQUFRLG1CQUFtQjtBQUMzQixjQUFRLE9BQU87QUFDZixjQUFRLGlCQUFpQjtBQUN6QixjQUFRLGlCQUFpQjtBQUV6QixjQUFRLFdBQVc7QUFDbkIsY0FBUSxjQUFjO0FBQ3RCLGNBQVEsZ0JBQWdCO0FBQ3hCLGNBQVEsZ0JBQWdCO0FBRXhCLGNBQVEsZ0JBQWdCO0FBQ3hCLGNBQVEscUJBQXFCO0FBQzdCLGNBQVEsbUJBQW1CO0FBRTNCLGNBQVEsT0FBTztBQUNmLGNBQVEsV0FBVztBQUVuQixlQUFTLE1BQU1MLFNBQVEsT0FBTyxPQUFPLFFBQVE7QUFDekMsWUFBSUMsVUFBUyxVQUFVLEdBQ25CLE1BQU0sVUFBVSxFQUFFLElBQUksUUFBUSxLQUFLO0FBQ3ZDLGVBQU9BLFFBQU8sS0FBSyxFQUFFLEtBQUtELE9BQU07QUFBQSxNQUNwQztBQUVBLGVBQVMsZUFBZUEsU0FBUSxPQUFPLE9BQU87QUFDMUMsWUFBSSxTQUFTQSxPQUFNLEdBQUc7QUFDbEIsa0JBQVFBO0FBQ1IsVUFBQUEsVUFBUztBQUFBLFFBQ2I7QUFFQSxRQUFBQSxVQUFTQSxXQUFVO0FBRW5CLFlBQUksU0FBUyxNQUFNO0FBQ2YsaUJBQU8sTUFBTUEsU0FBUSxPQUFPLE9BQU8sT0FBTztBQUFBLFFBQzlDO0FBRUEsWUFBSSxHQUNBLE1BQU0sQ0FBQztBQUNYLGFBQUssSUFBSSxHQUFHLElBQUksSUFBSSxLQUFLO0FBQ3JCLGNBQUksQ0FBQyxJQUFJLE1BQU1BLFNBQVEsR0FBRyxPQUFPLE9BQU87QUFBQSxRQUM1QztBQUNBLGVBQU87QUFBQSxNQUNYO0FBVUEsZUFBUyxpQkFBaUIsY0FBY0EsU0FBUSxPQUFPLE9BQU87QUFDMUQsWUFBSSxPQUFPLGlCQUFpQixXQUFXO0FBQ25DLGNBQUksU0FBU0EsT0FBTSxHQUFHO0FBQ2xCLG9CQUFRQTtBQUNSLFlBQUFBLFVBQVM7QUFBQSxVQUNiO0FBRUEsVUFBQUEsVUFBU0EsV0FBVTtBQUFBLFFBQ3ZCLE9BQU87QUFDSCxVQUFBQSxVQUFTO0FBQ1Qsa0JBQVFBO0FBQ1IseUJBQWU7QUFFZixjQUFJLFNBQVNBLE9BQU0sR0FBRztBQUNsQixvQkFBUUE7QUFDUixZQUFBQSxVQUFTO0FBQUEsVUFDYjtBQUVBLFVBQUFBLFVBQVNBLFdBQVU7QUFBQSxRQUN2QjtBQUVBLFlBQUlDLFVBQVMsVUFBVSxHQUNuQixRQUFRLGVBQWVBLFFBQU8sTUFBTSxNQUFNLEdBQzFDLEdBQ0EsTUFBTSxDQUFDO0FBRVgsWUFBSSxTQUFTLE1BQU07QUFDZixpQkFBTyxNQUFNRCxVQUFTLFFBQVEsU0FBUyxHQUFHLE9BQU8sS0FBSztBQUFBLFFBQzFEO0FBRUEsYUFBSyxJQUFJLEdBQUcsSUFBSSxHQUFHLEtBQUs7QUFDcEIsY0FBSSxDQUFDLElBQUksTUFBTUEsVUFBUyxJQUFJLFNBQVMsR0FBRyxPQUFPLEtBQUs7QUFBQSxRQUN4RDtBQUNBLGVBQU87QUFBQSxNQUNYO0FBRUEsZUFBUyxXQUFXQSxTQUFRLE9BQU87QUFDL0IsZUFBTyxlQUFlQSxTQUFRLE9BQU8sUUFBUTtBQUFBLE1BQ2pEO0FBRUEsZUFBUyxnQkFBZ0JBLFNBQVEsT0FBTztBQUNwQyxlQUFPLGVBQWVBLFNBQVEsT0FBTyxhQUFhO0FBQUEsTUFDdEQ7QUFFQSxlQUFTLGFBQWEsY0FBY0EsU0FBUSxPQUFPO0FBQy9DLGVBQU8saUJBQWlCLGNBQWNBLFNBQVEsT0FBTyxVQUFVO0FBQUEsTUFDbkU7QUFFQSxlQUFTLGtCQUFrQixjQUFjQSxTQUFRLE9BQU87QUFDcEQsZUFBTyxpQkFBaUIsY0FBY0EsU0FBUSxPQUFPLGVBQWU7QUFBQSxNQUN4RTtBQUVBLGVBQVMsZ0JBQWdCLGNBQWNBLFNBQVEsT0FBTztBQUNsRCxlQUFPLGlCQUFpQixjQUFjQSxTQUFRLE9BQU8sYUFBYTtBQUFBLE1BQ3RFO0FBRUEseUJBQW1CLE1BQU07QUFBQSxRQUNyQixNQUFNO0FBQUEsVUFDRjtBQUFBLFlBQ0ksT0FBTztBQUFBLFlBQ1AsT0FBTztBQUFBLFlBQ1AsUUFBUTtBQUFBLFlBQ1IsTUFBTTtBQUFBLFlBQ04sUUFBUTtBQUFBLFlBQ1IsTUFBTTtBQUFBLFVBQ1Y7QUFBQSxVQUNBO0FBQUEsWUFDSSxPQUFPO0FBQUEsWUFDUCxPQUFPO0FBQUEsWUFDUCxRQUFRO0FBQUEsWUFDUixNQUFNO0FBQUEsWUFDTixRQUFRO0FBQUEsWUFDUixNQUFNO0FBQUEsVUFDVjtBQUFBLFFBQ0o7QUFBQSxRQUNBLHdCQUF3QjtBQUFBLFFBQ3hCLFNBQVMsU0FBVSxRQUFRO0FBQ3ZCLGNBQUksSUFBSSxTQUFTLElBQ2IsU0FDSSxNQUFPLFNBQVMsTUFBTyxFQUFFLE1BQU0sSUFDekIsT0FDQSxNQUFNLElBQ04sT0FDQSxNQUFNLElBQ04sT0FDQSxNQUFNLElBQ04sT0FDQTtBQUNkLGlCQUFPLFNBQVM7QUFBQSxRQUNwQjtBQUFBLE1BQ0osQ0FBQztBQUlELFlBQU0sT0FBTztBQUFBLFFBQ1Q7QUFBQSxRQUNBO0FBQUEsTUFDSjtBQUNBLFlBQU0sV0FBVztBQUFBLFFBQ2I7QUFBQSxRQUNBO0FBQUEsTUFDSjtBQUVBLFVBQUksVUFBVSxLQUFLO0FBRW5CLGVBQVMsTUFBTTtBQUNYLFlBQUksT0FBTyxLQUFLO0FBRWhCLGFBQUssZ0JBQWdCLFFBQVEsS0FBSyxhQUFhO0FBQy9DLGFBQUssUUFBUSxRQUFRLEtBQUssS0FBSztBQUMvQixhQUFLLFVBQVUsUUFBUSxLQUFLLE9BQU87QUFFbkMsYUFBSyxlQUFlLFFBQVEsS0FBSyxZQUFZO0FBQzdDLGFBQUssVUFBVSxRQUFRLEtBQUssT0FBTztBQUNuQyxhQUFLLFVBQVUsUUFBUSxLQUFLLE9BQU87QUFDbkMsYUFBSyxRQUFRLFFBQVEsS0FBSyxLQUFLO0FBQy9CLGFBQUssU0FBUyxRQUFRLEtBQUssTUFBTTtBQUNqQyxhQUFLLFFBQVEsUUFBUSxLQUFLLEtBQUs7QUFFL0IsZUFBTztBQUFBLE1BQ1g7QUFFQSxlQUFTLGNBQWMsVUFBVSxPQUFPLE9BQU8sV0FBVztBQUN0RCxZQUFJLFFBQVEsZUFBZSxPQUFPLEtBQUs7QUFFdkMsaUJBQVMsaUJBQWlCLFlBQVksTUFBTTtBQUM1QyxpQkFBUyxTQUFTLFlBQVksTUFBTTtBQUNwQyxpQkFBUyxXQUFXLFlBQVksTUFBTTtBQUV0QyxlQUFPLFNBQVMsUUFBUTtBQUFBLE1BQzVCO0FBR0EsZUFBUyxNQUFNLE9BQU8sT0FBTztBQUN6QixlQUFPLGNBQWMsTUFBTSxPQUFPLE9BQU8sQ0FBQztBQUFBLE1BQzlDO0FBR0EsZUFBUyxXQUFXLE9BQU8sT0FBTztBQUM5QixlQUFPLGNBQWMsTUFBTSxPQUFPLE9BQU8sRUFBRTtBQUFBLE1BQy9DO0FBRUEsZUFBUyxRQUFRLFFBQVE7QUFDckIsWUFBSSxTQUFTLEdBQUc7QUFDWixpQkFBTyxLQUFLLE1BQU0sTUFBTTtBQUFBLFFBQzVCLE9BQU87QUFDSCxpQkFBTyxLQUFLLEtBQUssTUFBTTtBQUFBLFFBQzNCO0FBQUEsTUFDSjtBQUVBLGVBQVMsU0FBUztBQUNkLFlBQUl1QixnQkFBZSxLQUFLLGVBQ3BCRixRQUFPLEtBQUssT0FDWkYsVUFBUyxLQUFLLFNBQ2QsT0FBTyxLQUFLLE9BQ1pHLFVBQ0FQLFVBQ0FELFFBQ0FJLFFBQ0E7QUFJSixZQUNJLEVBQ0tLLGlCQUFnQixLQUFLRixTQUFRLEtBQUtGLFdBQVUsS0FDNUNJLGlCQUFnQixLQUFLRixTQUFRLEtBQUtGLFdBQVUsSUFFbkQ7QUFDRSxVQUFBSSxpQkFBZ0IsUUFBUSxhQUFhSixPQUFNLElBQUlFLEtBQUksSUFBSTtBQUN2RCxVQUFBQSxRQUFPO0FBQ1AsVUFBQUYsVUFBUztBQUFBLFFBQ2I7QUFJQSxhQUFLLGVBQWVJLGdCQUFlO0FBRW5DLFFBQUFELFdBQVUsU0FBU0MsZ0JBQWUsR0FBSTtBQUN0QyxhQUFLLFVBQVVELFdBQVU7QUFFekIsUUFBQVAsV0FBVSxTQUFTTyxXQUFVLEVBQUU7QUFDL0IsYUFBSyxVQUFVUCxXQUFVO0FBRXpCLFFBQUFELFNBQVEsU0FBU0MsV0FBVSxFQUFFO0FBQzdCLGFBQUssUUFBUUQsU0FBUTtBQUVyQixRQUFBTyxTQUFRLFNBQVNQLFNBQVEsRUFBRTtBQUczQix5QkFBaUIsU0FBUyxhQUFhTyxLQUFJLENBQUM7QUFDNUMsUUFBQUYsV0FBVTtBQUNWLFFBQUFFLFNBQVEsUUFBUSxhQUFhLGNBQWMsQ0FBQztBQUc1QyxRQUFBSCxTQUFRLFNBQVNDLFVBQVMsRUFBRTtBQUM1QixRQUFBQSxXQUFVO0FBRVYsYUFBSyxPQUFPRTtBQUNaLGFBQUssU0FBU0Y7QUFDZCxhQUFLLFFBQVFEO0FBRWIsZUFBTztBQUFBLE1BQ1g7QUFFQSxlQUFTLGFBQWFHLE9BQU07QUFHeEIsZUFBUUEsUUFBTyxPQUFRO0FBQUEsTUFDM0I7QUFFQSxlQUFTLGFBQWFGLFNBQVE7QUFFMUIsZUFBUUEsVUFBUyxTQUFVO0FBQUEsTUFDL0I7QUFFQSxlQUFTLEdBQUcsT0FBTztBQUNmLFlBQUksQ0FBQyxLQUFLLFFBQVEsR0FBRztBQUNqQixpQkFBTztBQUFBLFFBQ1g7QUFDQSxZQUFJRSxPQUNBRixTQUNBSSxnQkFBZSxLQUFLO0FBRXhCLGdCQUFRLGVBQWUsS0FBSztBQUU1QixZQUFJLFVBQVUsV0FBVyxVQUFVLGFBQWEsVUFBVSxRQUFRO0FBQzlELFVBQUFGLFFBQU8sS0FBSyxRQUFRRSxnQkFBZTtBQUNuQyxVQUFBSixVQUFTLEtBQUssVUFBVSxhQUFhRSxLQUFJO0FBQ3pDLGtCQUFRLE9BQU87QUFBQSxZQUNYLEtBQUs7QUFDRCxxQkFBT0Y7QUFBQSxZQUNYLEtBQUs7QUFDRCxxQkFBT0EsVUFBUztBQUFBLFlBQ3BCLEtBQUs7QUFDRCxxQkFBT0EsVUFBUztBQUFBLFVBQ3hCO0FBQUEsUUFDSixPQUFPO0FBRUgsVUFBQUUsUUFBTyxLQUFLLFFBQVEsS0FBSyxNQUFNLGFBQWEsS0FBSyxPQUFPLENBQUM7QUFDekQsa0JBQVEsT0FBTztBQUFBLFlBQ1gsS0FBSztBQUNELHFCQUFPQSxRQUFPLElBQUlFLGdCQUFlO0FBQUEsWUFDckMsS0FBSztBQUNELHFCQUFPRixRQUFPRSxnQkFBZTtBQUFBLFlBQ2pDLEtBQUs7QUFDRCxxQkFBT0YsUUFBTyxLQUFLRSxnQkFBZTtBQUFBLFlBQ3RDLEtBQUs7QUFDRCxxQkFBT0YsUUFBTyxPQUFPRSxnQkFBZTtBQUFBLFlBQ3hDLEtBQUs7QUFDRCxxQkFBT0YsUUFBTyxRQUFRRSxnQkFBZTtBQUFBLFlBRXpDLEtBQUs7QUFDRCxxQkFBTyxLQUFLLE1BQU1GLFFBQU8sS0FBSyxJQUFJRTtBQUFBLFlBQ3RDO0FBQ0ksb0JBQU0sSUFBSSxNQUFNLGtCQUFrQixLQUFLO0FBQUEsVUFDL0M7QUFBQSxRQUNKO0FBQUEsTUFDSjtBQUdBLGVBQVMsWUFBWTtBQUNqQixZQUFJLENBQUMsS0FBSyxRQUFRLEdBQUc7QUFDakIsaUJBQU87QUFBQSxRQUNYO0FBQ0EsZUFDSSxLQUFLLGdCQUNMLEtBQUssUUFBUSxRQUNaLEtBQUssVUFBVSxLQUFNLFNBQ3RCLE1BQU0sS0FBSyxVQUFVLEVBQUUsSUFBSTtBQUFBLE1BRW5DO0FBRUEsZUFBUyxPQUFPLE9BQU87QUFDbkIsZUFBTyxXQUFZO0FBQ2YsaUJBQU8sS0FBSyxHQUFHLEtBQUs7QUFBQSxRQUN4QjtBQUFBLE1BQ0o7QUFFQSxVQUFJLGlCQUFpQixPQUFPLElBQUksR0FDNUIsWUFBWSxPQUFPLEdBQUcsR0FDdEIsWUFBWSxPQUFPLEdBQUcsR0FDdEIsVUFBVSxPQUFPLEdBQUcsR0FDcEIsU0FBUyxPQUFPLEdBQUcsR0FDbkIsVUFBVSxPQUFPLEdBQUcsR0FDcEIsV0FBVyxPQUFPLEdBQUcsR0FDckIsYUFBYSxPQUFPLEdBQUcsR0FDdkIsVUFBVSxPQUFPLEdBQUc7QUFFeEIsZUFBUyxVQUFVO0FBQ2YsZUFBTyxlQUFlLElBQUk7QUFBQSxNQUM5QjtBQUVBLGVBQVMsTUFBTSxPQUFPO0FBQ2xCLGdCQUFRLGVBQWUsS0FBSztBQUM1QixlQUFPLEtBQUssUUFBUSxJQUFJLEtBQUssUUFBUSxHQUFHLEVBQUUsSUFBSTtBQUFBLE1BQ2xEO0FBRUEsZUFBUyxXQUFXLE1BQU07QUFDdEIsZUFBTyxXQUFZO0FBQ2YsaUJBQU8sS0FBSyxRQUFRLElBQUksS0FBSyxNQUFNLElBQUksSUFBSTtBQUFBLFFBQy9DO0FBQUEsTUFDSjtBQUVBLFVBQUksZUFBZSxXQUFXLGNBQWMsR0FDeEMsVUFBVSxXQUFXLFNBQVMsR0FDOUIsVUFBVSxXQUFXLFNBQVMsR0FDOUIsUUFBUSxXQUFXLE9BQU8sR0FDMUIsT0FBTyxXQUFXLE1BQU0sR0FDeEIsU0FBUyxXQUFXLFFBQVEsR0FDNUIsUUFBUSxXQUFXLE9BQU87QUFFOUIsZUFBUyxRQUFRO0FBQ2IsZUFBTyxTQUFTLEtBQUssS0FBSyxJQUFJLENBQUM7QUFBQSxNQUNuQztBQUVBLFVBQUksUUFBUSxLQUFLLE9BQ2IsYUFBYTtBQUFBLFFBQ1QsSUFBSTtBQUFBO0FBQUEsUUFDSixHQUFHO0FBQUE7QUFBQSxRQUNILEdBQUc7QUFBQTtBQUFBLFFBQ0gsR0FBRztBQUFBO0FBQUEsUUFDSCxHQUFHO0FBQUE7QUFBQSxRQUNILEdBQUc7QUFBQTtBQUFBLFFBQ0gsR0FBRztBQUFBO0FBQUEsTUFDUDtBQUdKLGVBQVMsa0JBQWtCWixTQUFRLFFBQVEsZUFBZSxVQUFVVixTQUFRO0FBQ3hFLGVBQU9BLFFBQU8sYUFBYSxVQUFVLEdBQUcsQ0FBQyxDQUFDLGVBQWVVLFNBQVEsUUFBUTtBQUFBLE1BQzdFO0FBRUEsZUFBUyxlQUFlLGdCQUFnQixlQUFlYyxhQUFZeEIsU0FBUTtBQUN2RSxZQUFJLFdBQVcsZUFBZSxjQUFjLEVBQUUsSUFBSSxHQUM5Q3FCLFdBQVUsTUFBTSxTQUFTLEdBQUcsR0FBRyxDQUFDLEdBQ2hDUCxXQUFVLE1BQU0sU0FBUyxHQUFHLEdBQUcsQ0FBQyxHQUNoQ0QsU0FBUSxNQUFNLFNBQVMsR0FBRyxHQUFHLENBQUMsR0FDOUJPLFFBQU8sTUFBTSxTQUFTLEdBQUcsR0FBRyxDQUFDLEdBQzdCRixVQUFTLE1BQU0sU0FBUyxHQUFHLEdBQUcsQ0FBQyxHQUMvQkMsU0FBUSxNQUFNLFNBQVMsR0FBRyxHQUFHLENBQUMsR0FDOUJGLFNBQVEsTUFBTSxTQUFTLEdBQUcsR0FBRyxDQUFDLEdBQzlCLElBQ0tJLFlBQVdHLFlBQVcsTUFBTSxDQUFDLEtBQUtILFFBQU8sS0FDekNBLFdBQVVHLFlBQVcsS0FBSyxDQUFDLE1BQU1ILFFBQU8sS0FDeENQLFlBQVcsS0FBSyxDQUFDLEdBQUcsS0FDcEJBLFdBQVVVLFlBQVcsS0FBSyxDQUFDLE1BQU1WLFFBQU8sS0FDeENELFVBQVMsS0FBSyxDQUFDLEdBQUcsS0FDbEJBLFNBQVFXLFlBQVcsS0FBSyxDQUFDLE1BQU1YLE1BQUssS0FDcENPLFNBQVEsS0FBSyxDQUFDLEdBQUcsS0FDakJBLFFBQU9JLFlBQVcsS0FBSyxDQUFDLE1BQU1KLEtBQUk7QUFFM0MsWUFBSUksWUFBVyxLQUFLLE1BQU07QUFDdEIsY0FDSSxLQUNDTCxVQUFTLEtBQUssQ0FBQyxHQUFHLEtBQ2xCQSxTQUFRSyxZQUFXLEtBQUssQ0FBQyxNQUFNTCxNQUFLO0FBQUEsUUFDN0M7QUFDQSxZQUFJLEtBQ0NELFdBQVUsS0FBSyxDQUFDLEdBQUcsS0FDbkJBLFVBQVNNLFlBQVcsS0FBSyxDQUFDLE1BQU1OLE9BQU0sS0FDdENELFVBQVMsS0FBSyxDQUFDLEdBQUcsS0FBTSxDQUFDLE1BQU1BLE1BQUs7QUFFekMsVUFBRSxDQUFDLElBQUk7QUFDUCxVQUFFLENBQUMsSUFBSSxDQUFDLGlCQUFpQjtBQUN6QixVQUFFLENBQUMsSUFBSWpCO0FBQ1AsZUFBTyxrQkFBa0IsTUFBTSxNQUFNLENBQUM7QUFBQSxNQUMxQztBQUdBLGVBQVMsMkJBQTJCLGtCQUFrQjtBQUNsRCxZQUFJLHFCQUFxQixRQUFXO0FBQ2hDLGlCQUFPO0FBQUEsUUFDWDtBQUNBLFlBQUksT0FBTyxxQkFBcUIsWUFBWTtBQUN4QyxrQkFBUTtBQUNSLGlCQUFPO0FBQUEsUUFDWDtBQUNBLGVBQU87QUFBQSxNQUNYO0FBR0EsZUFBUyw0QkFBNEIsV0FBVyxPQUFPO0FBQ25ELFlBQUksV0FBVyxTQUFTLE1BQU0sUUFBVztBQUNyQyxpQkFBTztBQUFBLFFBQ1g7QUFDQSxZQUFJLFVBQVUsUUFBVztBQUNyQixpQkFBTyxXQUFXLFNBQVM7QUFBQSxRQUMvQjtBQUNBLG1CQUFXLFNBQVMsSUFBSTtBQUN4QixZQUFJLGNBQWMsS0FBSztBQUNuQixxQkFBVyxLQUFLLFFBQVE7QUFBQSxRQUM1QjtBQUNBLGVBQU87QUFBQSxNQUNYO0FBRUEsZUFBUyxTQUFTLGVBQWUsZUFBZTtBQUM1QyxZQUFJLENBQUMsS0FBSyxRQUFRLEdBQUc7QUFDakIsaUJBQU8sS0FBSyxXQUFXLEVBQUUsWUFBWTtBQUFBLFFBQ3pDO0FBRUEsWUFBSSxhQUFhLE9BQ2IsS0FBSyxZQUNMQSxTQUNBO0FBRUosWUFBSSxPQUFPLGtCQUFrQixVQUFVO0FBQ25DLDBCQUFnQjtBQUNoQiwwQkFBZ0I7QUFBQSxRQUNwQjtBQUNBLFlBQUksT0FBTyxrQkFBa0IsV0FBVztBQUNwQyx1QkFBYTtBQUFBLFFBQ2pCO0FBQ0EsWUFBSSxPQUFPLGtCQUFrQixVQUFVO0FBQ25DLGVBQUssT0FBTyxPQUFPLENBQUMsR0FBRyxZQUFZLGFBQWE7QUFDaEQsY0FBSSxjQUFjLEtBQUssUUFBUSxjQUFjLE1BQU0sTUFBTTtBQUNyRCxlQUFHLEtBQUssY0FBYyxJQUFJO0FBQUEsVUFDOUI7QUFBQSxRQUNKO0FBRUEsUUFBQUEsVUFBUyxLQUFLLFdBQVc7QUFDekIsaUJBQVMsZUFBZSxNQUFNLENBQUMsWUFBWSxJQUFJQSxPQUFNO0FBRXJELFlBQUksWUFBWTtBQUNaLG1CQUFTQSxRQUFPLFdBQVcsQ0FBQyxNQUFNLE1BQU07QUFBQSxRQUM1QztBQUVBLGVBQU9BLFFBQU8sV0FBVyxNQUFNO0FBQUEsTUFDbkM7QUFFQSxVQUFJLFFBQVEsS0FBSztBQUVqQixlQUFTLEtBQUssR0FBRztBQUNiLGdCQUFRLElBQUksTUFBTSxJQUFJLE1BQU0sQ0FBQztBQUFBLE1BQ2pDO0FBRUEsZUFBUyxnQkFBZ0I7QUFRckIsWUFBSSxDQUFDLEtBQUssUUFBUSxHQUFHO0FBQ2pCLGlCQUFPLEtBQUssV0FBVyxFQUFFLFlBQVk7QUFBQSxRQUN6QztBQUVBLFlBQUlxQixXQUFVLE1BQU0sS0FBSyxhQUFhLElBQUksS0FDdENELFFBQU8sTUFBTSxLQUFLLEtBQUssR0FDdkJGLFVBQVMsTUFBTSxLQUFLLE9BQU8sR0FDM0JKLFVBQ0FELFFBQ0FJLFFBQ0EsR0FDQSxRQUFRLEtBQUssVUFBVSxHQUN2QixXQUNBLFFBQ0EsVUFDQTtBQUVKLFlBQUksQ0FBQyxPQUFPO0FBR1IsaUJBQU87QUFBQSxRQUNYO0FBR0EsUUFBQUgsV0FBVSxTQUFTTyxXQUFVLEVBQUU7QUFDL0IsUUFBQVIsU0FBUSxTQUFTQyxXQUFVLEVBQUU7QUFDN0IsUUFBQU8sWUFBVztBQUNYLFFBQUFQLFlBQVc7QUFHWCxRQUFBRyxTQUFRLFNBQVNDLFVBQVMsRUFBRTtBQUM1QixRQUFBQSxXQUFVO0FBR1YsWUFBSUcsV0FBVUEsU0FBUSxRQUFRLENBQUMsRUFBRSxRQUFRLFVBQVUsRUFBRSxJQUFJO0FBRXpELG9CQUFZLFFBQVEsSUFBSSxNQUFNO0FBQzlCLGlCQUFTLEtBQUssS0FBSyxPQUFPLE1BQU0sS0FBSyxLQUFLLElBQUksTUFBTTtBQUNwRCxtQkFBVyxLQUFLLEtBQUssS0FBSyxNQUFNLEtBQUssS0FBSyxJQUFJLE1BQU07QUFDcEQsa0JBQVUsS0FBSyxLQUFLLGFBQWEsTUFBTSxLQUFLLEtBQUssSUFBSSxNQUFNO0FBRTNELGVBQ0ksWUFDQSxPQUNDSixTQUFRLFNBQVNBLFNBQVEsTUFBTSxPQUMvQkMsVUFBUyxTQUFTQSxVQUFTLE1BQU0sT0FDakNFLFFBQU8sV0FBV0EsUUFBTyxNQUFNLE9BQy9CUCxVQUFTQyxZQUFXTyxXQUFVLE1BQU0sT0FDcENSLFNBQVEsVUFBVUEsU0FBUSxNQUFNLE9BQ2hDQyxXQUFVLFVBQVVBLFdBQVUsTUFBTSxPQUNwQ08sV0FBVSxVQUFVLElBQUksTUFBTTtBQUFBLE1BRXZDO0FBRUEsVUFBSSxVQUFVLFNBQVM7QUFFdkIsY0FBUSxVQUFVO0FBQ2xCLGNBQVEsTUFBTTtBQUNkLGNBQVEsTUFBTTtBQUNkLGNBQVEsV0FBVztBQUNuQixjQUFRLEtBQUs7QUFDYixjQUFRLGlCQUFpQjtBQUN6QixjQUFRLFlBQVk7QUFDcEIsY0FBUSxZQUFZO0FBQ3BCLGNBQVEsVUFBVTtBQUNsQixjQUFRLFNBQVM7QUFDakIsY0FBUSxVQUFVO0FBQ2xCLGNBQVEsV0FBVztBQUNuQixjQUFRLGFBQWE7QUFDckIsY0FBUSxVQUFVO0FBQ2xCLGNBQVEsVUFBVTtBQUNsQixjQUFRLFVBQVU7QUFDbEIsY0FBUSxRQUFRO0FBQ2hCLGNBQVEsTUFBTTtBQUNkLGNBQVEsZUFBZTtBQUN2QixjQUFRLFVBQVU7QUFDbEIsY0FBUSxVQUFVO0FBQ2xCLGNBQVEsUUFBUTtBQUNoQixjQUFRLE9BQU87QUFDZixjQUFRLFFBQVE7QUFDaEIsY0FBUSxTQUFTO0FBQ2pCLGNBQVEsUUFBUTtBQUNoQixjQUFRLFdBQVc7QUFDbkIsY0FBUSxjQUFjO0FBQ3RCLGNBQVEsV0FBVztBQUNuQixjQUFRLFNBQVM7QUFDakIsY0FBUSxTQUFTO0FBQ2pCLGNBQVEsYUFBYTtBQUVyQixjQUFRLGNBQWM7QUFBQSxRQUNsQjtBQUFBLFFBQ0E7QUFBQSxNQUNKO0FBQ0EsY0FBUSxPQUFPO0FBSWYscUJBQWUsS0FBSyxHQUFHLEdBQUcsTUFBTTtBQUNoQyxxQkFBZSxLQUFLLEdBQUcsR0FBRyxTQUFTO0FBSW5DLG9CQUFjLEtBQUssV0FBVztBQUM5QixvQkFBYyxLQUFLLGNBQWM7QUFDakMsb0JBQWMsS0FBSyxTQUFVLE9BQU8sT0FBTyxRQUFRO0FBQy9DLGVBQU8sS0FBSyxJQUFJLEtBQUssV0FBVyxLQUFLLElBQUksR0FBSTtBQUFBLE1BQ2pELENBQUM7QUFDRCxvQkFBYyxLQUFLLFNBQVUsT0FBTyxPQUFPLFFBQVE7QUFDL0MsZUFBTyxLQUFLLElBQUksS0FBSyxNQUFNLEtBQUssQ0FBQztBQUFBLE1BQ3JDLENBQUM7QUFJRCxZQUFNLFVBQVU7QUFFaEIsc0JBQWdCLFdBQVc7QUFFM0IsWUFBTSxLQUFLO0FBQ1gsWUFBTSxNQUFNO0FBQ1osWUFBTSxNQUFNO0FBQ1osWUFBTSxNQUFNO0FBQ1osWUFBTSxNQUFNO0FBQ1osWUFBTSxPQUFPO0FBQ2IsWUFBTSxTQUFTO0FBQ2YsWUFBTSxTQUFTO0FBQ2YsWUFBTSxTQUFTO0FBQ2YsWUFBTSxVQUFVO0FBQ2hCLFlBQU0sV0FBVztBQUNqQixZQUFNLFdBQVc7QUFDakIsWUFBTSxXQUFXO0FBQ2pCLFlBQU0sWUFBWTtBQUNsQixZQUFNLGFBQWE7QUFDbkIsWUFBTSxhQUFhO0FBQ25CLFlBQU0sY0FBYztBQUNwQixZQUFNLGNBQWM7QUFDcEIsWUFBTSxlQUFlO0FBQ3JCLFlBQU0sZUFBZTtBQUNyQixZQUFNLFVBQVU7QUFDaEIsWUFBTSxnQkFBZ0I7QUFDdEIsWUFBTSxpQkFBaUI7QUFDdkIsWUFBTSx1QkFBdUI7QUFDN0IsWUFBTSx3QkFBd0I7QUFDOUIsWUFBTSxpQkFBaUI7QUFDdkIsWUFBTSxZQUFZO0FBR2xCLFlBQU0sWUFBWTtBQUFBLFFBQ2QsZ0JBQWdCO0FBQUE7QUFBQSxRQUNoQix3QkFBd0I7QUFBQTtBQUFBLFFBQ3hCLG1CQUFtQjtBQUFBO0FBQUEsUUFDbkIsTUFBTTtBQUFBO0FBQUEsUUFDTixNQUFNO0FBQUE7QUFBQSxRQUNOLGNBQWM7QUFBQTtBQUFBLFFBQ2QsU0FBUztBQUFBO0FBQUEsUUFDVCxNQUFNO0FBQUE7QUFBQSxRQUNOLE9BQU87QUFBQTtBQUFBLE1BQ1g7QUFFQSxhQUFPO0FBQUEsSUFFWCxDQUFFO0FBQUE7QUFBQTs7O0FDcmlMRjtBQUFBO0FBQUE7QUFBQTtBQUFBOzs7QUNBQSxJQUFBSSxtQkFBMEU7OztBQ0ExRSxJQUFBQyxtQkFBNkc7OztBQ0E3RyxJQUFNLFVBQVU7QUFFVCxJQUFNLE1BQU4sTUFBVTtBQUFBLEVBTWIsWUFBWSxNQUFXO0FBQ25CLFVBQ0ksU0FBUyxLQUFLLE1BQU0sSUFBSSxNQUFNLElBQUksR0FDbEMsWUFBWSxLQUFLLFlBQVksT0FBTyxZQUFZLEdBQ2hELG1CQUFtQixLQUFLLG1CQUFtQixZQUFZO0FBQzNELFNBQUssT0FBTyxPQUFPLE1BQU0sQ0FBQztBQUMxQixTQUFLLFVBQVUsU0FBVSxNQUFNO0FBQzNCLGFBQU8sS0FBSyxZQUFZO0FBQ3hCLGFBQU8sUUFBUSxhQUFhLEtBQUssV0FBVyxnQkFBZ0I7QUFBQSxJQUNoRTtBQUFBLEVBQ0o7QUFBQSxFQUNBLFdBQVc7QUFBRSxXQUFPLEtBQUs7QUFBQSxFQUFLO0FBQUEsRUFFOUIsT0FBTyxNQUFNLEdBQVc7QUFBRSxXQUFPLFFBQVEsS0FBSyxDQUFDO0FBQUEsRUFBRztBQUFBLEVBRWxELE9BQU8sTUFBTSxNQUFjO0FBQ3ZCLFdBQU8sS0FBSyxXQUFXLElBQUk7QUFBRyxhQUFPLEtBQUssTUFBTSxDQUFDO0FBQ2pELFdBQU8sS0FBSyxXQUFXLEdBQUcsSUFBSSxPQUFPLE1BQUk7QUFBQSxFQUM3QztBQUFBLEVBRUEsT0FBTyxVQUFVLE1BQVc7QUFDeEIsV0FBTyxJQUFJLE1BQU0sSUFBSSxFQUFFLFlBQVk7QUFBQSxFQUN2QztBQUNKO0FBRU8sSUFBTSxjQUFOLE1BQWtCO0FBQUEsRUFLckIsWUFBWSxTQUFjLE9BQVk7QUFDbEMsVUFBTSxRQUFTLE9BQU87QUFBQSxNQUNsQix1QkFBTyxPQUFPLElBQUk7QUFBQSxNQUFHO0FBQUEsUUFDakIsQ0FBQyxRQUFRLEdBQUcsR0FBSSxNQUFNO0FBQUEsUUFDdEIsQ0FBQyxRQUFRLElBQUksR0FBRyxNQUFNO0FBQUEsTUFDMUI7QUFBQSxJQUNKO0FBRUEsU0FBSyxXQUFXLFNBQVMsTUFBTSxNQUFNLEdBQUc7QUFDcEMsYUFBTyxLQUFLLE1BQU0sR0FBRyxHQUFHLElBQUksTUFBTSxNQUFNLEtBQUssTUFBTSxNQUFNLFFBQVEsSUFBSSxNQUFNO0FBQUEsSUFDL0U7QUFFQSxTQUFLLFVBQVUsQ0FBQyxNQUFNLFNBQVNDLGFBQVk7QUFDdkMsYUFBTyxLQUFLLElBQUksQ0FBQyxHQUFXLE1BQWM7QUFDdEMsWUFBSSxXQUFZLElBQUk7QUFBSSxpQkFBTztBQUUvQixZQUFJLENBQUM7QUFBRyxpQkFBTztBQUVmLFlBQUlBLFVBQVM7QUFDVCxjQUFJLENBQUMsRUFBRSxXQUFXLEdBQUcsS0FBSyxDQUFDLElBQUksTUFBTSxDQUFDO0FBQUcsbUJBQU87QUFBQSxRQUNwRCxXQUFXLFNBQVMsS0FBSyxDQUFDLEdBQUc7QUFFekIsaUJBQU8sS0FBSyxRQUFRLEVBQUUsTUFBTSxXQUFXLEdBQUcsTUFBTUEsUUFBTyxFQUFFLEtBQUssRUFBRTtBQUFBLFFBQ3BFO0FBQ0EsWUFBSSxNQUFNLENBQUM7QUFBRyxpQkFBTyxNQUFNLENBQUM7QUFDNUIsY0FBTSxLQUFLLEVBQUUsWUFBWTtBQUN6QixZQUFJLE1BQU0sRUFBRSxHQUFHO0FBQ1gsaUJBQU8sTUFBTSxDQUFDLElBQUksTUFBTSxFQUFFO0FBQUEsUUFDOUIsV0FBVyxHQUFHLFdBQVcsUUFBUSxnQkFBZ0IsR0FBRztBQUNoRCxpQkFBTyxNQUFNLENBQUMsSUFBSSxNQUFNLEVBQUUsSUFBSSxLQUFLLFNBQVMsQ0FBQztBQUFBLFFBQ2pELFlBQVksTUFBTSxJQUFJLFdBQVcsUUFBUSxnQkFBZ0IsR0FBRztBQUN4RCxpQkFBTyxNQUFNLENBQUMsSUFBSSxNQUFNLEVBQUUsSUFBSSxLQUFLLFNBQVMsTUFBTSxDQUFDLEVBQUUsTUFBTSxDQUFDO0FBQUEsUUFDaEU7QUFDQSxlQUFPLE1BQU0sQ0FBQyxJQUFJLE1BQU0sRUFBRSxJQUFJO0FBQUEsTUFDbEMsQ0FBQztBQUFBLElBQ0w7QUFFQSxTQUFLLGdCQUFnQixTQUFVLFVBQVU7QUFFckMsVUFBSSxRQUFRLGNBQWMsTUFBTTtBQUFXO0FBRTNDLFlBQU0sV0FBVyxJQUFJLElBQUksU0FBUyxJQUFJLENBQUMsTUFBYyxFQUFFLFlBQVksQ0FBQyxDQUFDO0FBRXJFLGlCQUFXLFdBQVcsU0FBUyxPQUFPLFFBQVEsT0FBTyxHQUFHO0FBQ3BELGNBQU0sVUFBVSxLQUFLLFNBQVMsT0FBTztBQUNyQyxZQUFJLFNBQVMsSUFBSSxRQUFRLFlBQVksQ0FBQztBQUNsQyxpQkFBTyxDQUFDLElBQUksSUFBSSxPQUFPLEdBQUcsSUFBSSxJQUFJLE9BQU8sQ0FBQztBQUFBLE1BQ2xEO0FBQUEsSUFFSjtBQUFBLEVBQ0o7QUFDSjs7O0FDekZBLHNCQUF1Qjs7O0FDQXZCLElBQU0sUUFBUSxPQUFPLElBQUksWUFBWTtBQUNyQyxJQUFNLE1BQU0sT0FBTyxJQUFJLGVBQWU7QUFDdEMsSUFBTSxNQUFNLE9BQU8sSUFBSSxVQUFVO0FBQ2pDLElBQU0sT0FBTyxPQUFPLElBQUksV0FBVztBQUNuQyxJQUFNLFNBQVMsT0FBTyxJQUFJLGFBQWE7QUFDdkMsSUFBTSxNQUFNLE9BQU8sSUFBSSxVQUFVO0FBQ2pDLElBQU0sWUFBWSxPQUFPLElBQUksZ0JBQWdCO0FBQzdDLElBQU0sVUFBVSxDQUFDLFNBQVMsQ0FBQyxDQUFDLFFBQVEsT0FBTyxTQUFTLFlBQVksS0FBSyxTQUFTLE1BQU07QUFDcEYsSUFBTSxhQUFhLENBQUMsU0FBUyxDQUFDLENBQUMsUUFBUSxPQUFPLFNBQVMsWUFBWSxLQUFLLFNBQVMsTUFBTTtBQUN2RixJQUFNLFFBQVEsQ0FBQyxTQUFTLENBQUMsQ0FBQyxRQUFRLE9BQU8sU0FBUyxZQUFZLEtBQUssU0FBUyxNQUFNO0FBQ2xGLElBQU0sU0FBUyxDQUFDLFNBQVMsQ0FBQyxDQUFDLFFBQVEsT0FBTyxTQUFTLFlBQVksS0FBSyxTQUFTLE1BQU07QUFDbkYsSUFBTSxXQUFXLENBQUMsU0FBUyxDQUFDLENBQUMsUUFBUSxPQUFPLFNBQVMsWUFBWSxLQUFLLFNBQVMsTUFBTTtBQUNyRixJQUFNLFFBQVEsQ0FBQyxTQUFTLENBQUMsQ0FBQyxRQUFRLE9BQU8sU0FBUyxZQUFZLEtBQUssU0FBUyxNQUFNO0FBQ2xGLFNBQVMsYUFBYSxNQUFNO0FBQ3hCLE1BQUksUUFBUSxPQUFPLFNBQVM7QUFDeEIsWUFBUSxLQUFLLFNBQVMsR0FBRztBQUFBLE1BQ3JCLEtBQUs7QUFBQSxNQUNMLEtBQUs7QUFDRCxlQUFPO0FBQUEsSUFDZjtBQUNKLFNBQU87QUFDWDtBQUNBLFNBQVMsT0FBTyxNQUFNO0FBQ2xCLE1BQUksUUFBUSxPQUFPLFNBQVM7QUFDeEIsWUFBUSxLQUFLLFNBQVMsR0FBRztBQUFBLE1BQ3JCLEtBQUs7QUFBQSxNQUNMLEtBQUs7QUFBQSxNQUNMLEtBQUs7QUFBQSxNQUNMLEtBQUs7QUFDRCxlQUFPO0FBQUEsSUFDZjtBQUNKLFNBQU87QUFDWDtBQUNBLElBQU0sWUFBWSxDQUFDLFVBQVUsU0FBUyxJQUFJLEtBQUssYUFBYSxJQUFJLE1BQU0sQ0FBQyxDQUFDLEtBQUs7QUFDN0UsSUFBTSxXQUFOLE1BQWU7QUFBQSxFQUNYLFlBQVksTUFBTTtBQUNkLFdBQU8sZUFBZSxNQUFNLFdBQVcsRUFBRSxPQUFPLEtBQUssQ0FBQztBQUFBLEVBQzFEO0FBQUE7QUFBQSxFQUVBLFFBQVE7QUFDSixVQUFNLE9BQU8sT0FBTyxPQUFPLE9BQU8sZUFBZSxJQUFJLEdBQUcsT0FBTywwQkFBMEIsSUFBSSxDQUFDO0FBQzlGLFFBQUksS0FBSztBQUNMLFdBQUssUUFBUSxLQUFLLE1BQU0sTUFBTTtBQUNsQyxXQUFPO0FBQUEsRUFDWDtBQUNKOzs7QUMzQ0EsSUFBTSxRQUFRLE9BQU8sYUFBYTtBQUNsQyxJQUFNLE9BQU8sT0FBTyxlQUFlO0FBQ25DLElBQU0sU0FBUyxPQUFPLGFBQWE7QUErQm5DLFNBQVMsTUFBTSxNQUFNLFNBQVM7QUFDMUIsTUFBSSxPQUFPLFlBQVksYUFDbEIsUUFBUSxjQUFjLFFBQVEsUUFBUSxRQUFRLFFBQVE7QUFDdkQsY0FBVSxPQUFPLE9BQU87QUFBQSxNQUNwQixPQUFPLFFBQVE7QUFBQSxNQUNmLEtBQUssUUFBUTtBQUFBLE1BQ2IsUUFBUSxRQUFRO0FBQUEsTUFDaEIsS0FBSyxRQUFRO0FBQUEsSUFDakIsR0FBRyxRQUFRLFNBQVM7QUFBQSxNQUNoQixLQUFLLFFBQVE7QUFBQSxNQUNiLFFBQVEsUUFBUTtBQUFBLE1BQ2hCLEtBQUssUUFBUTtBQUFBLElBQ2pCLEdBQUcsUUFBUSxjQUFjO0FBQUEsTUFDckIsS0FBSyxRQUFRO0FBQUEsTUFDYixLQUFLLFFBQVE7QUFBQSxJQUNqQixHQUFHLE9BQU87QUFBQSxFQUNkO0FBQ0EsTUFBSSxXQUFXLElBQUksR0FBRztBQUNsQixVQUFNLEtBQUssT0FBTyxNQUFNLEtBQUssVUFBVSxTQUFTLE9BQU8sT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDO0FBQ3JFLFFBQUksT0FBTztBQUNQLFdBQUssV0FBVztBQUFBLEVBQ3hCO0FBRUksV0FBTyxNQUFNLE1BQU0sU0FBUyxPQUFPLE9BQU8sQ0FBQyxDQUFDLENBQUM7QUFDckQ7QUFLQSxNQUFNLFFBQVE7QUFFZCxNQUFNLE9BQU87QUFFYixNQUFNLFNBQVM7QUFDZixTQUFTLE9BQU8sS0FBSyxNQUFNLFNBQVMsTUFBTTtBQUN0QyxNQUFJLE9BQU87QUFDWCxNQUFJLE9BQU8sWUFBWTtBQUNuQixXQUFPLFFBQVEsS0FBSyxNQUFNLElBQUk7QUFBQSxXQUN6QixNQUFNLElBQUksR0FBRztBQUNsQixRQUFJLFFBQVE7QUFDUixhQUFPLFFBQVEsSUFBSSxLQUFLLE1BQU0sSUFBSTtBQUFBLEVBQzFDLFdBQ1MsTUFBTSxJQUFJLEdBQUc7QUFDbEIsUUFBSSxRQUFRO0FBQ1IsYUFBTyxRQUFRLElBQUksS0FBSyxNQUFNLElBQUk7QUFBQSxFQUMxQyxXQUNTLE9BQU8sSUFBSSxHQUFHO0FBQ25CLFFBQUksUUFBUTtBQUNSLGFBQU8sUUFBUSxLQUFLLEtBQUssTUFBTSxJQUFJO0FBQUEsRUFDM0MsV0FDUyxTQUFTLElBQUksR0FBRztBQUNyQixRQUFJLFFBQVE7QUFDUixhQUFPLFFBQVEsT0FBTyxLQUFLLE1BQU0sSUFBSTtBQUFBLEVBQzdDLFdBQ1MsUUFBUSxJQUFJLEdBQUc7QUFDcEIsUUFBSSxRQUFRO0FBQ1IsYUFBTyxRQUFRLE1BQU0sS0FBSyxNQUFNLElBQUk7QUFBQSxFQUM1QztBQUNBLE1BQUksT0FBTyxJQUFJLEtBQUssT0FBTyxJQUFJLEdBQUc7QUFDOUIsVUFBTSxTQUFTLEtBQUssS0FBSyxTQUFTLENBQUM7QUFDbkMsUUFBSSxhQUFhLE1BQU0sR0FBRztBQUN0QixhQUFPLE1BQU0sR0FBRyxJQUFJO0FBQUEsSUFDeEIsV0FDUyxPQUFPLE1BQU0sR0FBRztBQUNyQixVQUFJLFFBQVE7QUFDUixlQUFPLE1BQU07QUFBQTtBQUViLGVBQU8sUUFBUTtBQUFBLElBQ3ZCLFdBQ1MsV0FBVyxNQUFNLEdBQUc7QUFDekIsYUFBTyxXQUFXO0FBQUEsSUFDdEIsT0FDSztBQUNELFlBQU0sS0FBSyxRQUFRLE1BQU0sSUFBSSxVQUFVO0FBQ3ZDLFlBQU0sSUFBSSxNQUFNLDRCQUE0QixXQUFXO0FBQUEsSUFDM0Q7QUFDQSxXQUFPLE9BQU8sS0FBSyxNQUFNLFNBQVMsSUFBSTtBQUFBLEVBQzFDO0FBQ0EsTUFBSSxPQUFPLFNBQVMsVUFBVTtBQUMxQixRQUFJLGFBQWEsSUFBSSxHQUFHO0FBQ3BCLGFBQU8sT0FBTyxPQUFPLEtBQUssT0FBTyxJQUFJLENBQUM7QUFDdEMsZUFBUyxJQUFJLEdBQUcsSUFBSSxLQUFLLE1BQU0sUUFBUSxFQUFFLEdBQUc7QUFDeEMsY0FBTSxLQUFLLE9BQU8sR0FBRyxLQUFLLE1BQU0sQ0FBQyxHQUFHLFNBQVMsSUFBSTtBQUNqRCxZQUFJLE9BQU8sT0FBTztBQUNkLGNBQUksS0FBSztBQUFBLGlCQUNKLE9BQU87QUFDWixpQkFBTztBQUFBLGlCQUNGLE9BQU8sUUFBUTtBQUNwQixlQUFLLE1BQU0sT0FBTyxHQUFHLENBQUM7QUFDdEIsZUFBSztBQUFBLFFBQ1Q7QUFBQSxNQUNKO0FBQUEsSUFDSixXQUNTLE9BQU8sSUFBSSxHQUFHO0FBQ25CLGFBQU8sT0FBTyxPQUFPLEtBQUssT0FBTyxJQUFJLENBQUM7QUFDdEMsWUFBTSxLQUFLLE9BQU8sT0FBTyxLQUFLLEtBQUssU0FBUyxJQUFJO0FBQ2hELFVBQUksT0FBTztBQUNQLGVBQU87QUFBQSxlQUNGLE9BQU87QUFDWixhQUFLLE1BQU07QUFDZixZQUFNLEtBQUssT0FBTyxTQUFTLEtBQUssT0FBTyxTQUFTLElBQUk7QUFDcEQsVUFBSSxPQUFPO0FBQ1AsZUFBTztBQUFBLGVBQ0YsT0FBTztBQUNaLGFBQUssUUFBUTtBQUFBLElBQ3JCO0FBQUEsRUFDSjtBQUNBLFNBQU87QUFDWDs7O0FDNUlBLElBQU0sY0FBYztBQUFBLEVBQ2hCLEtBQUs7QUFBQSxFQUNMLEtBQUs7QUFBQSxFQUNMLEtBQUs7QUFBQSxFQUNMLEtBQUs7QUFBQSxFQUNMLEtBQUs7QUFBQSxFQUNMLEtBQUs7QUFDVDtBQUNBLElBQU0sZ0JBQWdCLENBQUMsT0FBTyxHQUFHLFFBQVEsY0FBYyxRQUFNLFlBQVksRUFBRSxDQUFDO0FBQzVFLElBQU0sYUFBTixNQUFpQjtBQUFBLEVBQ2IsWUFBWSxNQUFNLE1BQU07QUFLcEIsU0FBSyxTQUFTO0FBQ2QsU0FBSyxPQUFPLE9BQU8sT0FBTyxDQUFDLEdBQUcsV0FBVyxhQUFhLElBQUk7QUFDMUQsU0FBSyxPQUFPLE9BQU8sT0FBTyxDQUFDLEdBQUcsV0FBVyxhQUFhLElBQUk7QUFBQSxFQUM5RDtBQUFBLEVBQ0EsUUFBUTtBQUNKLFVBQU0sT0FBTyxJQUFJLFdBQVcsS0FBSyxNQUFNLEtBQUssSUFBSTtBQUNoRCxTQUFLLFNBQVMsS0FBSztBQUNuQixXQUFPO0FBQUEsRUFDWDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFLQSxhQUFhO0FBQ1QsVUFBTSxNQUFNLElBQUksV0FBVyxLQUFLLE1BQU0sS0FBSyxJQUFJO0FBQy9DLFlBQVEsS0FBSyxLQUFLLFNBQVM7QUFBQSxNQUN2QixLQUFLO0FBQ0QsYUFBSyxpQkFBaUI7QUFDdEI7QUFBQSxNQUNKLEtBQUs7QUFDRCxhQUFLLGlCQUFpQjtBQUN0QixhQUFLLE9BQU87QUFBQSxVQUNSLFVBQVUsV0FBVyxZQUFZO0FBQUEsVUFDakMsU0FBUztBQUFBLFFBQ2I7QUFDQSxhQUFLLE9BQU8sT0FBTyxPQUFPLENBQUMsR0FBRyxXQUFXLFdBQVc7QUFDcEQ7QUFBQSxJQUNSO0FBQ0EsV0FBTztBQUFBLEVBQ1g7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBS0EsSUFBSSxNQUFNLFNBQVM7QUFDZixRQUFJLEtBQUssZ0JBQWdCO0FBQ3JCLFdBQUssT0FBTyxFQUFFLFVBQVUsV0FBVyxZQUFZLFVBQVUsU0FBUyxNQUFNO0FBQ3hFLFdBQUssT0FBTyxPQUFPLE9BQU8sQ0FBQyxHQUFHLFdBQVcsV0FBVztBQUNwRCxXQUFLLGlCQUFpQjtBQUFBLElBQzFCO0FBQ0EsVUFBTSxRQUFRLEtBQUssS0FBSyxFQUFFLE1BQU0sUUFBUTtBQUN4QyxVQUFNLE9BQU8sTUFBTSxNQUFNO0FBQ3pCLFlBQVEsTUFBTTtBQUFBLE1BQ1YsS0FBSyxRQUFRO0FBQ1QsWUFBSSxNQUFNLFdBQVcsR0FBRztBQUNwQixrQkFBUSxHQUFHLGlEQUFpRDtBQUM1RCxjQUFJLE1BQU0sU0FBUztBQUNmLG1CQUFPO0FBQUEsUUFDZjtBQUNBLGNBQU0sQ0FBQyxRQUFRLE1BQU0sSUFBSTtBQUN6QixhQUFLLEtBQUssTUFBTSxJQUFJO0FBQ3BCLGVBQU87QUFBQSxNQUNYO0FBQUEsTUFDQSxLQUFLLFNBQVM7QUFDVixhQUFLLEtBQUssV0FBVztBQUNyQixZQUFJLE1BQU0sU0FBUyxHQUFHO0FBQ2xCLGtCQUFRLEdBQUcsaURBQWlEO0FBQzVELGlCQUFPO0FBQUEsUUFDWDtBQUNBLGNBQU0sQ0FBQyxPQUFPLElBQUk7QUFDbEIsWUFBSSxZQUFZLFNBQVMsWUFBWSxPQUFPO0FBQ3hDLGVBQUssS0FBSyxVQUFVO0FBQ3BCLGlCQUFPO0FBQUEsUUFDWCxPQUNLO0FBQ0Qsa0JBQVEsR0FBRyw0QkFBNEIsV0FBVyxJQUFJO0FBQ3RELGlCQUFPO0FBQUEsUUFDWDtBQUFBLE1BQ0o7QUFBQSxNQUNBO0FBQ0ksZ0JBQVEsR0FBRyxxQkFBcUIsUUFBUSxJQUFJO0FBQzVDLGVBQU87QUFBQSxJQUNmO0FBQUEsRUFDSjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBT0EsUUFBUSxRQUFRLFNBQVM7QUFDckIsUUFBSSxXQUFXO0FBQ1gsYUFBTztBQUNYLFFBQUksT0FBTyxDQUFDLE1BQU0sS0FBSztBQUNuQixjQUFRLG9CQUFvQixRQUFRO0FBQ3BDLGFBQU87QUFBQSxJQUNYO0FBQ0EsUUFBSSxPQUFPLENBQUMsTUFBTSxLQUFLO0FBQ25CLFlBQU0sV0FBVyxPQUFPLE1BQU0sR0FBRyxFQUFFO0FBQ25DLFVBQUksYUFBYSxPQUFPLGFBQWEsTUFBTTtBQUN2QyxnQkFBUSxxQ0FBcUMsb0JBQW9CO0FBQ2pFLGVBQU87QUFBQSxNQUNYO0FBQ0EsVUFBSSxPQUFPLE9BQU8sU0FBUyxDQUFDLE1BQU07QUFDOUIsZ0JBQVEsaUNBQWlDO0FBQzdDLGFBQU87QUFBQSxJQUNYO0FBQ0EsVUFBTSxDQUFDLEVBQUUsUUFBUSxNQUFNLElBQUksT0FBTyxNQUFNLGdCQUFnQjtBQUN4RCxRQUFJLENBQUM7QUFDRCxjQUFRLE9BQU8sMEJBQTBCO0FBQzdDLFVBQU0sU0FBUyxLQUFLLEtBQUssTUFBTTtBQUMvQixRQUFJO0FBQ0EsYUFBTyxTQUFTLG1CQUFtQixNQUFNO0FBQzdDLFFBQUksV0FBVztBQUNYLGFBQU87QUFDWCxZQUFRLDBCQUEwQixRQUFRO0FBQzFDLFdBQU87QUFBQSxFQUNYO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQUtBLFVBQVVDLE1BQUs7QUFDWCxlQUFXLENBQUMsUUFBUSxNQUFNLEtBQUssT0FBTyxRQUFRLEtBQUssSUFBSSxHQUFHO0FBQ3RELFVBQUlBLEtBQUksV0FBVyxNQUFNO0FBQ3JCLGVBQU8sU0FBUyxjQUFjQSxLQUFJLFVBQVUsT0FBTyxNQUFNLENBQUM7QUFBQSxJQUNsRTtBQUNBLFdBQU9BLEtBQUksQ0FBQyxNQUFNLE1BQU1BLE9BQU0sS0FBS0E7QUFBQSxFQUN2QztBQUFBLEVBQ0EsU0FBUyxLQUFLO0FBQ1YsVUFBTSxRQUFRLEtBQUssS0FBSyxXQUNsQixDQUFDLFNBQVMsS0FBSyxLQUFLLFdBQVcsT0FBTyxJQUN0QyxDQUFDO0FBQ1AsVUFBTSxhQUFhLE9BQU8sUUFBUSxLQUFLLElBQUk7QUFDM0MsUUFBSTtBQUNKLFFBQUksT0FBTyxXQUFXLFNBQVMsS0FBSyxPQUFPLElBQUksUUFBUSxHQUFHO0FBQ3RELFlBQU0sT0FBTyxDQUFDO0FBQ2QsWUFBTSxJQUFJLFVBQVUsQ0FBQyxNQUFNLFNBQVM7QUFDaEMsWUFBSSxPQUFPLElBQUksS0FBSyxLQUFLO0FBQ3JCLGVBQUssS0FBSyxHQUFHLElBQUk7QUFBQSxNQUN6QixDQUFDO0FBQ0QsaUJBQVcsT0FBTyxLQUFLLElBQUk7QUFBQSxJQUMvQjtBQUVJLGlCQUFXLENBQUM7QUFDaEIsZUFBVyxDQUFDLFFBQVEsTUFBTSxLQUFLLFlBQVk7QUFDdkMsVUFBSSxXQUFXLFFBQVEsV0FBVztBQUM5QjtBQUNKLFVBQUksQ0FBQyxPQUFPLFNBQVMsS0FBSyxRQUFNLEdBQUcsV0FBVyxNQUFNLENBQUM7QUFDakQsY0FBTSxLQUFLLFFBQVEsVUFBVSxRQUFRO0FBQUEsSUFDN0M7QUFDQSxXQUFPLE1BQU0sS0FBSyxJQUFJO0FBQUEsRUFDMUI7QUFDSjtBQUNBLFdBQVcsY0FBYyxFQUFFLFVBQVUsT0FBTyxTQUFTLE1BQU07QUFDM0QsV0FBVyxjQUFjLEVBQUUsTUFBTSxxQkFBcUI7OztBQzNKdEQsU0FBUyxjQUFjLFFBQVE7QUFDM0IsTUFBSSxzQkFBc0IsS0FBSyxNQUFNLEdBQUc7QUFDcEMsVUFBTSxLQUFLLEtBQUssVUFBVSxNQUFNO0FBQ2hDLFVBQU0sTUFBTSw2REFBNkQ7QUFDekUsVUFBTSxJQUFJLE1BQU0sR0FBRztBQUFBLEVBQ3ZCO0FBQ0EsU0FBTztBQUNYO0FBQ0EsU0FBUyxZQUFZLE1BQU07QUFDdkIsUUFBTSxVQUFVLG9CQUFJLElBQUk7QUFDeEIsUUFBTSxNQUFNO0FBQUEsSUFDUixNQUFNLE1BQU0sTUFBTTtBQUNkLFVBQUksS0FBSztBQUNMLGdCQUFRLElBQUksS0FBSyxNQUFNO0FBQUEsSUFDL0I7QUFBQSxFQUNKLENBQUM7QUFDRCxTQUFPO0FBQ1g7QUFFQSxTQUFTLGNBQWMsUUFBUSxTQUFTO0FBQ3BDLFdBQVMsSUFBSSxHQUFHLE1BQU0sRUFBRSxHQUFHO0FBQ3ZCLFVBQU0sT0FBTyxHQUFHLFNBQVM7QUFDekIsUUFBSSxDQUFDLFFBQVEsSUFBSSxJQUFJO0FBQ2pCLGFBQU87QUFBQSxFQUNmO0FBQ0o7QUFDQSxTQUFTLGtCQUFrQixLQUFLLFFBQVE7QUFDcEMsUUFBTSxlQUFlLENBQUM7QUFDdEIsUUFBTSxnQkFBZ0Isb0JBQUksSUFBSTtBQUM5QixNQUFJLGNBQWM7QUFDbEIsU0FBTztBQUFBLElBQ0gsU0FBUyxRQUFRO0FBQ2IsbUJBQWEsS0FBSyxNQUFNO0FBQ3hCLFVBQUksQ0FBQztBQUNELHNCQUFjLFlBQVksR0FBRztBQUNqQyxZQUFNLFNBQVMsY0FBYyxRQUFRLFdBQVc7QUFDaEQsa0JBQVksSUFBSSxNQUFNO0FBQ3RCLGFBQU87QUFBQSxJQUNYO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBTUEsYUFBYTtBQUNULGlCQUFXLFVBQVUsY0FBYztBQUMvQixjQUFNLE1BQU0sY0FBYyxJQUFJLE1BQU07QUFDcEMsWUFBSSxPQUFPLFFBQVEsWUFDZixJQUFJLFdBQ0gsU0FBUyxJQUFJLElBQUksS0FBSyxhQUFhLElBQUksSUFBSSxJQUFJO0FBQ2hELGNBQUksS0FBSyxTQUFTLElBQUk7QUFBQSxRQUMxQixPQUNLO0FBQ0QsZ0JBQU0sUUFBUSxJQUFJLE1BQU0sNERBQTREO0FBQ3BGLGdCQUFNLFNBQVM7QUFDZixnQkFBTTtBQUFBLFFBQ1Y7QUFBQSxNQUNKO0FBQUEsSUFDSjtBQUFBLElBQ0E7QUFBQSxFQUNKO0FBQ0o7OztBQ2pFQSxJQUFNLFFBQU4sY0FBb0IsU0FBUztBQUFBLEVBQ3pCLFlBQVksUUFBUTtBQUNoQixVQUFNLEtBQUs7QUFDWCxTQUFLLFNBQVM7QUFDZCxXQUFPLGVBQWUsTUFBTSxPQUFPO0FBQUEsTUFDL0IsTUFBTTtBQUNGLGNBQU0sSUFBSSxNQUFNLDhCQUE4QjtBQUFBLE1BQ2xEO0FBQUEsSUFDSixDQUFDO0FBQUEsRUFDTDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFLQSxRQUFRLEtBQUs7QUFDVCxRQUFJLFFBQVE7QUFDWixVQUFNLEtBQUs7QUFBQSxNQUNQLE1BQU0sQ0FBQyxNQUFNLFNBQVM7QUFDbEIsWUFBSSxTQUFTO0FBQ1QsaUJBQU8sTUFBTTtBQUNqQixZQUFJLEtBQUssV0FBVyxLQUFLO0FBQ3JCLGtCQUFRO0FBQUEsTUFDaEI7QUFBQSxJQUNKLENBQUM7QUFDRCxXQUFPO0FBQUEsRUFDWDtBQUFBLEVBQ0EsT0FBTyxNQUFNLEtBQUs7QUFDZCxRQUFJLENBQUM7QUFDRCxhQUFPLEVBQUUsUUFBUSxLQUFLLE9BQU87QUFDakMsVUFBTSxFQUFFLFNBQVMsS0FBSyxjQUFjLElBQUk7QUFDeEMsVUFBTSxTQUFTLEtBQUssUUFBUSxHQUFHO0FBQy9CLFFBQUksQ0FBQyxRQUFRO0FBQ1QsWUFBTSxNQUFNLCtEQUErRCxLQUFLO0FBQ2hGLFlBQU0sSUFBSSxlQUFlLEdBQUc7QUFBQSxJQUNoQztBQUNBLFVBQU0sT0FBTyxRQUFRLElBQUksTUFBTTtBQUUvQixRQUFJLENBQUMsUUFBUSxLQUFLLFFBQVEsUUFBVztBQUNqQyxZQUFNLE1BQU07QUFDWixZQUFNLElBQUksZUFBZSxHQUFHO0FBQUEsSUFDaEM7QUFDQSxRQUFJLGlCQUFpQixHQUFHO0FBQ3BCLFdBQUssU0FBUztBQUNkLFVBQUksS0FBSyxlQUFlO0FBQ3BCLGFBQUssYUFBYSxjQUFjLEtBQUssUUFBUSxPQUFPO0FBQ3hELFVBQUksS0FBSyxRQUFRLEtBQUssYUFBYSxlQUFlO0FBQzlDLGNBQU0sTUFBTTtBQUNaLGNBQU0sSUFBSSxlQUFlLEdBQUc7QUFBQSxNQUNoQztBQUFBLElBQ0o7QUFDQSxXQUFPLEtBQUs7QUFBQSxFQUNoQjtBQUFBLEVBQ0EsU0FBUyxLQUFLLFlBQVksY0FBYztBQUNwQyxVQUFNLE1BQU0sSUFBSSxLQUFLO0FBQ3JCLFFBQUksS0FBSztBQUNMLG9CQUFjLEtBQUssTUFBTTtBQUN6QixVQUFJLElBQUksUUFBUSxvQkFBb0IsQ0FBQyxJQUFJLFFBQVEsSUFBSSxLQUFLLE1BQU0sR0FBRztBQUMvRCxjQUFNLE1BQU0sK0RBQStELEtBQUs7QUFDaEYsY0FBTSxJQUFJLE1BQU0sR0FBRztBQUFBLE1BQ3ZCO0FBQ0EsVUFBSSxJQUFJO0FBQ0osZUFBTyxHQUFHO0FBQUEsSUFDbEI7QUFDQSxXQUFPO0FBQUEsRUFDWDtBQUNKO0FBQ0EsU0FBUyxjQUFjLEtBQUssTUFBTSxTQUFTO0FBQ3ZDLE1BQUksUUFBUSxJQUFJLEdBQUc7QUFDZixVQUFNLFNBQVMsS0FBSyxRQUFRLEdBQUc7QUFDL0IsVUFBTSxTQUFTLFdBQVcsVUFBVSxRQUFRLElBQUksTUFBTTtBQUN0RCxXQUFPLFNBQVMsT0FBTyxRQUFRLE9BQU8sYUFBYTtBQUFBLEVBQ3ZELFdBQ1MsYUFBYSxJQUFJLEdBQUc7QUFDekIsUUFBSSxRQUFRO0FBQ1osZUFBVyxRQUFRLEtBQUssT0FBTztBQUMzQixZQUFNLElBQUksY0FBYyxLQUFLLE1BQU0sT0FBTztBQUMxQyxVQUFJLElBQUk7QUFDSixnQkFBUTtBQUFBLElBQ2hCO0FBQ0EsV0FBTztBQUFBLEVBQ1gsV0FDUyxPQUFPLElBQUksR0FBRztBQUNuQixVQUFNLEtBQUssY0FBYyxLQUFLLEtBQUssS0FBSyxPQUFPO0FBQy9DLFVBQU0sS0FBSyxjQUFjLEtBQUssS0FBSyxPQUFPLE9BQU87QUFDakQsV0FBTyxLQUFLLElBQUksSUFBSSxFQUFFO0FBQUEsRUFDMUI7QUFDQSxTQUFPO0FBQ1g7OztBQy9FQSxTQUFTLEtBQUssT0FBTyxLQUFLLEtBQUs7QUFDM0IsTUFBSSxNQUFNLFFBQVEsS0FBSztBQUNuQixXQUFPLE1BQU0sSUFBSSxDQUFDLEdBQUcsTUFBTSxLQUFLLEdBQUcsT0FBTyxDQUFDLEdBQUcsR0FBRyxDQUFDO0FBQ3RELE1BQUksU0FBUyxPQUFPLE1BQU0sV0FBVyxZQUFZO0FBQzdDLFFBQUksQ0FBQyxPQUFPLENBQUMsVUFBVSxLQUFLO0FBQ3hCLGFBQU8sTUFBTSxPQUFPLEtBQUssR0FBRztBQUNoQyxVQUFNLE9BQU8sRUFBRSxZQUFZLEdBQUcsT0FBTyxHQUFHLEtBQUssT0FBVTtBQUN2RCxRQUFJLFFBQVEsSUFBSSxPQUFPLElBQUk7QUFDM0IsUUFBSSxXQUFXLENBQUFDLFNBQU87QUFDbEIsV0FBSyxNQUFNQTtBQUNYLGFBQU8sSUFBSTtBQUFBLElBQ2Y7QUFDQSxVQUFNLE1BQU0sTUFBTSxPQUFPLEtBQUssR0FBRztBQUNqQyxRQUFJLElBQUk7QUFDSixVQUFJLFNBQVMsR0FBRztBQUNwQixXQUFPO0FBQUEsRUFDWDtBQUNBLE1BQUksT0FBTyxVQUFVLFlBQVksRUFBRSxPQUFPLElBQUk7QUFDMUMsV0FBTyxPQUFPLEtBQUs7QUFDdkIsU0FBTztBQUNYOzs7QUM3QkEsSUFBTSxnQkFBZ0IsQ0FBQyxVQUFVLENBQUMsU0FBVSxPQUFPLFVBQVUsY0FBYyxPQUFPLFVBQVU7QUFDNUYsSUFBTSxTQUFOLGNBQXFCLFNBQVM7QUFBQSxFQUMxQixZQUFZLE9BQU87QUFDZixVQUFNLE1BQU07QUFDWixTQUFLLFFBQVE7QUFBQSxFQUNqQjtBQUFBLEVBQ0EsT0FBTyxLQUFLLEtBQUs7QUFDYixXQUFPLE9BQU8sSUFBSSxPQUFPLEtBQUssUUFBUSxLQUFLLEtBQUssT0FBTyxLQUFLLEdBQUc7QUFBQSxFQUNuRTtBQUFBLEVBQ0EsV0FBVztBQUNQLFdBQU8sT0FBTyxLQUFLLEtBQUs7QUFBQSxFQUM1QjtBQUNKO0FBQ0EsT0FBTyxlQUFlO0FBQ3RCLE9BQU8sZ0JBQWdCO0FBQ3ZCLE9BQU8sUUFBUTtBQUNmLE9BQU8sZUFBZTtBQUN0QixPQUFPLGVBQWU7OztBQ2hCdEIsSUFBTSxtQkFBbUI7QUFDekIsU0FBUyxjQUFjLE9BQU8sU0FBUyxNQUFNO0FBQ3pDLE1BQUksU0FBUztBQUNULFVBQU0sUUFBUSxLQUFLLE9BQU8sT0FBSyxFQUFFLFFBQVEsT0FBTztBQUNoRCxVQUFNLFNBQVMsTUFBTSxLQUFLLE9BQUssQ0FBQyxFQUFFLE1BQU0sS0FBSyxNQUFNLENBQUM7QUFDcEQsUUFBSSxDQUFDO0FBQ0QsWUFBTSxJQUFJLE1BQU0sT0FBTyxtQkFBbUI7QUFDOUMsV0FBTztBQUFBLEVBQ1g7QUFDQSxTQUFPLEtBQUssS0FBSyxPQUFLLEVBQUUsWUFBWSxFQUFFLFNBQVMsS0FBSyxLQUFLLENBQUMsRUFBRSxNQUFNO0FBQ3RFO0FBQ0EsU0FBUyxXQUFXLE9BQU8sU0FBUyxLQUFLO0FBQ3JDLE1BQUksSUFBSTtBQUNSLE1BQUksV0FBVyxLQUFLO0FBQ2hCLFlBQVEsTUFBTTtBQUNsQixNQUFJLE9BQU8sS0FBSztBQUNaLFdBQU87QUFDWCxNQUFJLE9BQU8sS0FBSyxHQUFHO0FBQ2YsVUFBTUMsUUFBTyxNQUFNLEtBQUssSUFBSSxPQUFPLEdBQUcsR0FBRyxnQkFBZ0IsUUFBUSxPQUFPLFNBQVMsU0FBUyxHQUFHLEtBQUssSUFBSSxJQUFJLFFBQVEsTUFBTSxHQUFHO0FBQzNILElBQUFBLEtBQUksTUFBTSxLQUFLLEtBQUs7QUFDcEIsV0FBT0E7QUFBQSxFQUNYO0FBQ0EsTUFBSSxpQkFBaUIsVUFDakIsaUJBQWlCLFVBQ2pCLGlCQUFpQixXQUNoQixPQUFPLFdBQVcsY0FBYyxpQkFBaUIsUUFDcEQ7QUFFRSxZQUFRLE1BQU0sUUFBUTtBQUFBLEVBQzFCO0FBQ0EsUUFBTSxFQUFFLHVCQUF1QixVQUFVLFVBQVUsUUFBQUMsU0FBUSxjQUFjLElBQUk7QUFHN0UsTUFBSSxNQUFNO0FBQ1YsTUFBSSx5QkFBeUIsU0FBUyxPQUFPLFVBQVUsVUFBVTtBQUM3RCxVQUFNLGNBQWMsSUFBSSxLQUFLO0FBQzdCLFFBQUksS0FBSztBQUNMLFVBQUksQ0FBQyxJQUFJO0FBQ0wsWUFBSSxTQUFTLFNBQVMsS0FBSztBQUMvQixhQUFPLElBQUksTUFBTSxJQUFJLE1BQU07QUFBQSxJQUMvQixPQUNLO0FBQ0QsWUFBTSxFQUFFLFFBQVEsTUFBTSxNQUFNLEtBQUs7QUFDakMsb0JBQWMsSUFBSSxPQUFPLEdBQUc7QUFBQSxJQUNoQztBQUFBLEVBQ0o7QUFDQSxNQUFJLFdBQVcsUUFBUSxXQUFXLElBQUk7QUFDbEMsY0FBVSxtQkFBbUIsUUFBUSxNQUFNLENBQUM7QUFDaEQsTUFBSSxTQUFTLGNBQWMsT0FBTyxTQUFTQSxRQUFPLElBQUk7QUFDdEQsTUFBSSxDQUFDLFFBQVE7QUFDVCxRQUFJLFNBQVMsT0FBTyxNQUFNLFdBQVc7QUFDakMsY0FBUSxNQUFNLE9BQU87QUFDekIsUUFBSSxDQUFDLFNBQVMsT0FBTyxVQUFVLFVBQVU7QUFDckMsWUFBTUMsUUFBTyxJQUFJLE9BQU8sS0FBSztBQUM3QixVQUFJO0FBQ0EsWUFBSSxPQUFPQTtBQUNmLGFBQU9BO0FBQUEsSUFDWDtBQUNBLGFBQ0ksaUJBQWlCLE1BQ1hELFFBQU8sR0FBRyxJQUNWLE9BQU8sWUFBWSxPQUFPLEtBQUssSUFDM0JBLFFBQU8sR0FBRyxJQUNWQSxRQUFPLEdBQUc7QUFBQSxFQUM1QjtBQUNBLE1BQUksVUFBVTtBQUNWLGFBQVMsTUFBTTtBQUNmLFdBQU8sSUFBSTtBQUFBLEVBQ2Y7QUFDQSxRQUFNLFFBQVEsV0FBVyxRQUFRLFdBQVcsU0FBUyxTQUFTLE9BQU8sY0FDL0QsT0FBTyxXQUFXLElBQUksUUFBUSxPQUFPLEdBQUcsSUFDeEMsSUFBSSxPQUFPLEtBQUs7QUFDdEIsTUFBSTtBQUNBLFNBQUssTUFBTTtBQUNmLE1BQUk7QUFDQSxRQUFJLE9BQU87QUFDZixTQUFPO0FBQ1g7OztBQzlFQSxTQUFTLG1CQUFtQkUsU0FBUSxNQUFNLE9BQU87QUFDN0MsTUFBSSxJQUFJO0FBQ1IsV0FBUyxJQUFJLEtBQUssU0FBUyxHQUFHLEtBQUssR0FBRyxFQUFFLEdBQUc7QUFDdkMsVUFBTSxJQUFJLEtBQUssQ0FBQztBQUNoQixRQUFJLE9BQU8sTUFBTSxZQUFZLE9BQU8sVUFBVSxDQUFDLEtBQUssS0FBSyxHQUFHO0FBQ3hELFlBQU0sSUFBSSxDQUFDO0FBQ1gsUUFBRSxDQUFDLElBQUk7QUFDUCxVQUFJO0FBQUEsSUFDUixPQUNLO0FBQ0QsVUFBSSxvQkFBSSxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO0FBQUEsSUFDeEI7QUFBQSxFQUNKO0FBQ0EsU0FBTyxXQUFXLEdBQUcsUUFBVztBQUFBLElBQzVCLHVCQUF1QjtBQUFBLElBQ3ZCLGVBQWU7QUFBQSxJQUNmLFVBQVUsTUFBTTtBQUNaLFlBQU0sSUFBSSxNQUFNLDhDQUE4QztBQUFBLElBQ2xFO0FBQUEsSUFDQSxRQUFBQTtBQUFBLElBQ0EsZUFBZSxvQkFBSSxJQUFJO0FBQUEsRUFDM0IsQ0FBQztBQUNMO0FBRUEsSUFBTSxjQUFjLENBQUMsU0FBUyxRQUFRLFFBQ2pDLE9BQU8sU0FBUyxZQUFZLENBQUMsQ0FBQyxLQUFLLE9BQU8sUUFBUSxFQUFFLEVBQUUsS0FBSyxFQUFFO0FBQ2xFLElBQU0sYUFBTixjQUF5QixTQUFTO0FBQUEsRUFDOUIsWUFBWSxNQUFNQSxTQUFRO0FBQ3RCLFVBQU0sSUFBSTtBQUNWLFdBQU8sZUFBZSxNQUFNLFVBQVU7QUFBQSxNQUNsQyxPQUFPQTtBQUFBLE1BQ1AsY0FBYztBQUFBLE1BQ2QsWUFBWTtBQUFBLE1BQ1osVUFBVTtBQUFBLElBQ2QsQ0FBQztBQUFBLEVBQ0w7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFNQSxNQUFNQSxTQUFRO0FBQ1YsVUFBTSxPQUFPLE9BQU8sT0FBTyxPQUFPLGVBQWUsSUFBSSxHQUFHLE9BQU8sMEJBQTBCLElBQUksQ0FBQztBQUM5RixRQUFJQTtBQUNBLFdBQUssU0FBU0E7QUFDbEIsU0FBSyxRQUFRLEtBQUssTUFBTSxJQUFJLFFBQU0sT0FBTyxFQUFFLEtBQUssT0FBTyxFQUFFLElBQUksR0FBRyxNQUFNQSxPQUFNLElBQUksRUFBRTtBQUNsRixRQUFJLEtBQUs7QUFDTCxXQUFLLFFBQVEsS0FBSyxNQUFNLE1BQU07QUFDbEMsV0FBTztBQUFBLEVBQ1g7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFNQSxNQUFNLE1BQU0sT0FBTztBQUNmLFFBQUksWUFBWSxJQUFJO0FBQ2hCLFdBQUssSUFBSSxLQUFLO0FBQUEsU0FDYjtBQUNELFlBQU0sQ0FBQyxLQUFLLEdBQUcsSUFBSSxJQUFJO0FBQ3ZCLFlBQU0sT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJO0FBQy9CLFVBQUksYUFBYSxJQUFJO0FBQ2pCLGFBQUssTUFBTSxNQUFNLEtBQUs7QUFBQSxlQUNqQixTQUFTLFVBQWEsS0FBSztBQUNoQyxhQUFLLElBQUksS0FBSyxtQkFBbUIsS0FBSyxRQUFRLE1BQU0sS0FBSyxDQUFDO0FBQUE7QUFFMUQsY0FBTSxJQUFJLE1BQU0sK0JBQStCLHdCQUF3QixNQUFNO0FBQUEsSUFDckY7QUFBQSxFQUNKO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQUtBLFNBQVMsTUFBTTtBQUNYLFVBQU0sQ0FBQyxLQUFLLEdBQUcsSUFBSSxJQUFJO0FBQ3ZCLFFBQUksS0FBSyxXQUFXO0FBQ2hCLGFBQU8sS0FBSyxPQUFPLEdBQUc7QUFDMUIsVUFBTSxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUk7QUFDL0IsUUFBSSxhQUFhLElBQUk7QUFDakIsYUFBTyxLQUFLLFNBQVMsSUFBSTtBQUFBO0FBRXpCLFlBQU0sSUFBSSxNQUFNLCtCQUErQix3QkFBd0IsTUFBTTtBQUFBLEVBQ3JGO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBTUEsTUFBTSxNQUFNLFlBQVk7QUFDcEIsVUFBTSxDQUFDLEtBQUssR0FBRyxJQUFJLElBQUk7QUFDdkIsVUFBTSxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUk7QUFDL0IsUUFBSSxLQUFLLFdBQVc7QUFDaEIsYUFBTyxDQUFDLGNBQWMsU0FBUyxJQUFJLElBQUksS0FBSyxRQUFRO0FBQUE7QUFFcEQsYUFBTyxhQUFhLElBQUksSUFBSSxLQUFLLE1BQU0sTUFBTSxVQUFVLElBQUk7QUFBQSxFQUNuRTtBQUFBLEVBQ0EsaUJBQWlCLGFBQWE7QUFDMUIsV0FBTyxLQUFLLE1BQU0sTUFBTSxVQUFRO0FBQzVCLFVBQUksQ0FBQyxPQUFPLElBQUk7QUFDWixlQUFPO0FBQ1gsWUFBTSxJQUFJLEtBQUs7QUFDZixhQUFRLEtBQUssUUFDUixlQUNHLFNBQVMsQ0FBQyxLQUNWLEVBQUUsU0FBUyxRQUNYLENBQUMsRUFBRSxpQkFDSCxDQUFDLEVBQUUsV0FDSCxDQUFDLEVBQUU7QUFBQSxJQUNmLENBQUM7QUFBQSxFQUNMO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJQSxNQUFNLE1BQU07QUFDUixVQUFNLENBQUMsS0FBSyxHQUFHLElBQUksSUFBSTtBQUN2QixRQUFJLEtBQUssV0FBVztBQUNoQixhQUFPLEtBQUssSUFBSSxHQUFHO0FBQ3ZCLFVBQU0sT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJO0FBQy9CLFdBQU8sYUFBYSxJQUFJLElBQUksS0FBSyxNQUFNLElBQUksSUFBSTtBQUFBLEVBQ25EO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQUtBLE1BQU0sTUFBTSxPQUFPO0FBQ2YsVUFBTSxDQUFDLEtBQUssR0FBRyxJQUFJLElBQUk7QUFDdkIsUUFBSSxLQUFLLFdBQVcsR0FBRztBQUNuQixXQUFLLElBQUksS0FBSyxLQUFLO0FBQUEsSUFDdkIsT0FDSztBQUNELFlBQU0sT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJO0FBQy9CLFVBQUksYUFBYSxJQUFJO0FBQ2pCLGFBQUssTUFBTSxNQUFNLEtBQUs7QUFBQSxlQUNqQixTQUFTLFVBQWEsS0FBSztBQUNoQyxhQUFLLElBQUksS0FBSyxtQkFBbUIsS0FBSyxRQUFRLE1BQU0sS0FBSyxDQUFDO0FBQUE7QUFFMUQsY0FBTSxJQUFJLE1BQU0sK0JBQStCLHdCQUF3QixNQUFNO0FBQUEsSUFDckY7QUFBQSxFQUNKO0FBQ0o7QUFDQSxXQUFXLGdDQUFnQzs7O0FDeEkzQyxJQUFNLG1CQUFtQixDQUFDLFFBQVEsSUFBSSxRQUFRLG1CQUFtQixHQUFHO0FBQ3BFLFNBQVMsY0FBYyxTQUFTLFFBQVE7QUFDcEMsTUFBSSxRQUFRLEtBQUssT0FBTztBQUNwQixXQUFPLFFBQVEsVUFBVSxDQUFDO0FBQzlCLFNBQU8sU0FBUyxRQUFRLFFBQVEsY0FBYyxNQUFNLElBQUk7QUFDNUQ7QUFDQSxJQUFNLGNBQWMsQ0FBQyxLQUFLLFFBQVEsWUFBWSxRQUFRLFNBQVMsSUFBSSxJQUM3RCxPQUFPLGNBQWMsU0FBUyxNQUFNLEtBQ25DLElBQUksU0FBUyxHQUFHLElBQUksS0FBSyxPQUFPOzs7QUNmdkMsSUFBTSxZQUFZO0FBQ2xCLElBQU0sYUFBYTtBQUNuQixJQUFNLGNBQWM7QUFNcEIsU0FBUyxjQUFjLE1BQU0sUUFBUSxPQUFPLFFBQVEsRUFBRSxlQUFlLFlBQVksSUFBSSxrQkFBa0IsSUFBSSxRQUFRLFdBQVcsSUFBSSxDQUFDLEdBQUc7QUFDbEksTUFBSSxDQUFDLGFBQWEsWUFBWTtBQUMxQixXQUFPO0FBQ1gsUUFBTSxVQUFVLEtBQUssSUFBSSxJQUFJLGlCQUFpQixJQUFJLFlBQVksT0FBTyxNQUFNO0FBQzNFLE1BQUksS0FBSyxVQUFVO0FBQ2YsV0FBTztBQUNYLFFBQU0sUUFBUSxDQUFDO0FBQ2YsUUFBTSxlQUFlLENBQUM7QUFDdEIsTUFBSSxNQUFNLFlBQVksT0FBTztBQUM3QixNQUFJLE9BQU8sa0JBQWtCLFVBQVU7QUFDbkMsUUFBSSxnQkFBZ0IsWUFBWSxLQUFLLElBQUksR0FBRyxlQUFlO0FBQ3ZELFlBQU0sS0FBSyxDQUFDO0FBQUE7QUFFWixZQUFNLFlBQVk7QUFBQSxFQUMxQjtBQUNBLE1BQUksUUFBUTtBQUNaLE1BQUksT0FBTztBQUNYLE1BQUksV0FBVztBQUNmLE1BQUksSUFBSTtBQUNSLE1BQUksV0FBVztBQUNmLE1BQUksU0FBUztBQUNiLE1BQUksU0FBUyxZQUFZO0FBQ3JCLFFBQUkseUJBQXlCLE1BQU0sQ0FBQztBQUNwQyxRQUFJLE1BQU07QUFDTixZQUFNLElBQUk7QUFBQSxFQUNsQjtBQUNBLFdBQVMsSUFBSyxLQUFLLEtBQU0sS0FBSyxDQUFFLEtBQUs7QUFDakMsUUFBSSxTQUFTLGVBQWUsT0FBTyxNQUFNO0FBQ3JDLGlCQUFXO0FBQ1gsY0FBUSxLQUFLLElBQUksQ0FBQyxHQUFHO0FBQUEsUUFDakIsS0FBSztBQUNELGVBQUs7QUFDTDtBQUFBLFFBQ0osS0FBSztBQUNELGVBQUs7QUFDTDtBQUFBLFFBQ0osS0FBSztBQUNELGVBQUs7QUFDTDtBQUFBLFFBQ0o7QUFDSSxlQUFLO0FBQUEsTUFDYjtBQUNBLGVBQVM7QUFBQSxJQUNiO0FBQ0EsUUFBSSxPQUFPLE1BQU07QUFDYixVQUFJLFNBQVM7QUFDVCxZQUFJLHlCQUF5QixNQUFNLENBQUM7QUFDeEMsWUFBTSxJQUFJO0FBQ1YsY0FBUTtBQUFBLElBQ1osT0FDSztBQUNELFVBQUksT0FBTyxPQUNQLFFBQ0EsU0FBUyxPQUNULFNBQVMsUUFDVCxTQUFTLEtBQU07QUFFZixjQUFNLE9BQU8sS0FBSyxJQUFJLENBQUM7QUFDdkIsWUFBSSxRQUFRLFNBQVMsT0FBTyxTQUFTLFFBQVEsU0FBUztBQUNsRCxrQkFBUTtBQUFBLE1BQ2hCO0FBQ0EsVUFBSSxLQUFLLEtBQUs7QUFDVixZQUFJLE9BQU87QUFDUCxnQkFBTSxLQUFLLEtBQUs7QUFDaEIsZ0JBQU0sUUFBUTtBQUNkLGtCQUFRO0FBQUEsUUFDWixXQUNTLFNBQVMsYUFBYTtBQUUzQixpQkFBTyxTQUFTLE9BQU8sU0FBUyxLQUFNO0FBQ2xDLG1CQUFPO0FBQ1AsaUJBQUssS0FBTSxLQUFLLENBQUU7QUFDbEIsdUJBQVc7QUFBQSxVQUNmO0FBRUEsZ0JBQU0sSUFBSSxJQUFJLFNBQVMsSUFBSSxJQUFJLElBQUksV0FBVztBQUU5QyxjQUFJLGFBQWEsQ0FBQztBQUNkLG1CQUFPO0FBQ1gsZ0JBQU0sS0FBSyxDQUFDO0FBQ1osdUJBQWEsQ0FBQyxJQUFJO0FBQ2xCLGdCQUFNLElBQUk7QUFDVixrQkFBUTtBQUFBLFFBQ1osT0FDSztBQUNELHFCQUFXO0FBQUEsUUFDZjtBQUFBLE1BQ0o7QUFBQSxJQUNKO0FBQ0EsV0FBTztBQUFBLEVBQ1g7QUFDQSxNQUFJLFlBQVk7QUFDWixlQUFXO0FBQ2YsTUFBSSxNQUFNLFdBQVc7QUFDakIsV0FBTztBQUNYLE1BQUk7QUFDQSxXQUFPO0FBQ1gsTUFBSSxNQUFNLEtBQUssTUFBTSxHQUFHLE1BQU0sQ0FBQyxDQUFDO0FBQ2hDLFdBQVNDLEtBQUksR0FBR0EsS0FBSSxNQUFNLFFBQVEsRUFBRUEsSUFBRztBQUNuQyxVQUFNLE9BQU8sTUFBTUEsRUFBQztBQUNwQixVQUFNQyxPQUFNLE1BQU1ELEtBQUksQ0FBQyxLQUFLLEtBQUs7QUFDakMsUUFBSSxTQUFTO0FBQ1QsWUFBTTtBQUFBLEVBQUssU0FBUyxLQUFLLE1BQU0sR0FBR0MsSUFBRztBQUFBLFNBQ3BDO0FBQ0QsVUFBSSxTQUFTLGVBQWUsYUFBYSxJQUFJO0FBQ3pDLGVBQU8sR0FBRyxLQUFLLElBQUk7QUFDdkIsYUFBTztBQUFBLEVBQUssU0FBUyxLQUFLLE1BQU0sT0FBTyxHQUFHQSxJQUFHO0FBQUEsSUFDakQ7QUFBQSxFQUNKO0FBQ0EsU0FBTztBQUNYO0FBS0EsU0FBUyx5QkFBeUIsTUFBTSxHQUFHO0FBQ3ZDLE1BQUksS0FBSyxLQUFLLElBQUksQ0FBQztBQUNuQixTQUFPLE9BQU8sT0FBTyxPQUFPLEtBQU07QUFDOUIsT0FBRztBQUNDLFdBQUssS0FBTSxLQUFLLENBQUU7QUFBQSxJQUN0QixTQUFTLE1BQU0sT0FBTztBQUN0QixTQUFLLEtBQUssSUFBSSxDQUFDO0FBQUEsRUFDbkI7QUFDQSxTQUFPO0FBQ1g7OztBQ2pJQSxJQUFNLGlCQUFpQixDQUFDLFNBQVM7QUFBQSxFQUM3QixlQUFlLElBQUk7QUFBQSxFQUNuQixXQUFXLElBQUksUUFBUTtBQUFBLEVBQ3ZCLGlCQUFpQixJQUFJLFFBQVE7QUFDakM7QUFHQSxJQUFNLHlCQUF5QixDQUFDLFFBQVEsbUJBQW1CLEtBQUssR0FBRztBQUNuRSxTQUFTLG9CQUFvQixLQUFLLFdBQVcsY0FBYztBQUN2RCxNQUFJLENBQUMsYUFBYSxZQUFZO0FBQzFCLFdBQU87QUFDWCxRQUFNLFFBQVEsWUFBWTtBQUMxQixRQUFNLFNBQVMsSUFBSTtBQUNuQixNQUFJLFVBQVU7QUFDVixXQUFPO0FBQ1gsV0FBUyxJQUFJLEdBQUcsUUFBUSxHQUFHLElBQUksUUFBUSxFQUFFLEdBQUc7QUFDeEMsUUFBSSxJQUFJLENBQUMsTUFBTSxNQUFNO0FBQ2pCLFVBQUksSUFBSSxRQUFRO0FBQ1osZUFBTztBQUNYLGNBQVEsSUFBSTtBQUNaLFVBQUksU0FBUyxTQUFTO0FBQ2xCLGVBQU87QUFBQSxJQUNmO0FBQUEsRUFDSjtBQUNBLFNBQU87QUFDWDtBQUNBLFNBQVMsbUJBQW1CLE9BQU8sS0FBSztBQUNwQyxRQUFNLE9BQU8sS0FBSyxVQUFVLEtBQUs7QUFDakMsTUFBSSxJQUFJLFFBQVE7QUFDWixXQUFPO0FBQ1gsUUFBTSxFQUFFLFlBQVksSUFBSTtBQUN4QixRQUFNLHFCQUFxQixJQUFJLFFBQVE7QUFDdkMsUUFBTSxTQUFTLElBQUksV0FBVyx1QkFBdUIsS0FBSyxJQUFJLE9BQU87QUFDckUsTUFBSSxNQUFNO0FBQ1YsTUFBSSxRQUFRO0FBQ1osV0FBUyxJQUFJLEdBQUcsS0FBSyxLQUFLLENBQUMsR0FBRyxJQUFJLEtBQUssS0FBSyxFQUFFLENBQUMsR0FBRztBQUM5QyxRQUFJLE9BQU8sT0FBTyxLQUFLLElBQUksQ0FBQyxNQUFNLFFBQVEsS0FBSyxJQUFJLENBQUMsTUFBTSxLQUFLO0FBRTNELGFBQU8sS0FBSyxNQUFNLE9BQU8sQ0FBQyxJQUFJO0FBQzlCLFdBQUs7QUFDTCxjQUFRO0FBQ1IsV0FBSztBQUFBLElBQ1Q7QUFDQSxRQUFJLE9BQU87QUFDUCxjQUFRLEtBQUssSUFBSSxDQUFDLEdBQUc7QUFBQSxRQUNqQixLQUFLO0FBQ0Q7QUFDSSxtQkFBTyxLQUFLLE1BQU0sT0FBTyxDQUFDO0FBQzFCLGtCQUFNLE9BQU8sS0FBSyxPQUFPLElBQUksR0FBRyxDQUFDO0FBQ2pDLG9CQUFRLE1BQU07QUFBQSxjQUNWLEtBQUs7QUFDRCx1QkFBTztBQUNQO0FBQUEsY0FDSixLQUFLO0FBQ0QsdUJBQU87QUFDUDtBQUFBLGNBQ0osS0FBSztBQUNELHVCQUFPO0FBQ1A7QUFBQSxjQUNKLEtBQUs7QUFDRCx1QkFBTztBQUNQO0FBQUEsY0FDSixLQUFLO0FBQ0QsdUJBQU87QUFDUDtBQUFBLGNBQ0osS0FBSztBQUNELHVCQUFPO0FBQ1A7QUFBQSxjQUNKLEtBQUs7QUFDRCx1QkFBTztBQUNQO0FBQUEsY0FDSixLQUFLO0FBQ0QsdUJBQU87QUFDUDtBQUFBLGNBQ0o7QUFDSSxvQkFBSSxLQUFLLE9BQU8sR0FBRyxDQUFDLE1BQU07QUFDdEIseUJBQU8sUUFBUSxLQUFLLE9BQU8sQ0FBQztBQUFBO0FBRTVCLHlCQUFPLEtBQUssT0FBTyxHQUFHLENBQUM7QUFBQSxZQUNuQztBQUNBLGlCQUFLO0FBQ0wsb0JBQVEsSUFBSTtBQUFBLFVBQ2hCO0FBQ0E7QUFBQSxRQUNKLEtBQUs7QUFDRCxjQUFJLGVBQ0EsS0FBSyxJQUFJLENBQUMsTUFBTSxPQUNoQixLQUFLLFNBQVMsb0JBQW9CO0FBQ2xDLGlCQUFLO0FBQUEsVUFDVCxPQUNLO0FBRUQsbUJBQU8sS0FBSyxNQUFNLE9BQU8sQ0FBQyxJQUFJO0FBQzlCLG1CQUFPLEtBQUssSUFBSSxDQUFDLE1BQU0sUUFDbkIsS0FBSyxJQUFJLENBQUMsTUFBTSxPQUNoQixLQUFLLElBQUksQ0FBQyxNQUFNLEtBQUs7QUFDckIscUJBQU87QUFDUCxtQkFBSztBQUFBLFlBQ1Q7QUFDQSxtQkFBTztBQUVQLGdCQUFJLEtBQUssSUFBSSxDQUFDLE1BQU07QUFDaEIscUJBQU87QUFDWCxpQkFBSztBQUNMLG9CQUFRLElBQUk7QUFBQSxVQUNoQjtBQUNBO0FBQUEsUUFDSjtBQUNJLGVBQUs7QUFBQSxNQUNiO0FBQUEsRUFDUjtBQUNBLFFBQU0sUUFBUSxNQUFNLEtBQUssTUFBTSxLQUFLLElBQUk7QUFDeEMsU0FBTyxjQUNELE1BQ0EsY0FBYyxLQUFLLFFBQVEsYUFBYSxlQUFlLEdBQUcsQ0FBQztBQUNyRTtBQUNBLFNBQVMsbUJBQW1CLE9BQU8sS0FBSztBQUNwQyxNQUFJLElBQUksUUFBUSxnQkFBZ0IsU0FDM0IsSUFBSSxlQUFlLE1BQU0sU0FBUyxJQUFJLEtBQ3ZDLGtCQUFrQixLQUFLLEtBQUs7QUFFNUIsV0FBTyxtQkFBbUIsT0FBTyxHQUFHO0FBQ3hDLFFBQU0sU0FBUyxJQUFJLFdBQVcsdUJBQXVCLEtBQUssSUFBSSxPQUFPO0FBQ3JFLFFBQU0sTUFBTSxNQUFNLE1BQU0sUUFBUSxNQUFNLElBQUksRUFBRSxRQUFRLFFBQVE7QUFBQSxFQUFPLFFBQVEsSUFBSTtBQUMvRSxTQUFPLElBQUksY0FDTCxNQUNBLGNBQWMsS0FBSyxRQUFRLFdBQVcsZUFBZSxHQUFHLENBQUM7QUFDbkU7QUFDQSxTQUFTLGFBQWEsT0FBTyxLQUFLO0FBQzlCLFFBQU0sRUFBRSxZQUFZLElBQUksSUFBSTtBQUM1QixNQUFJO0FBQ0osTUFBSSxnQkFBZ0I7QUFDaEIsU0FBSztBQUFBLE9BQ0o7QUFDRCxVQUFNLFlBQVksTUFBTSxTQUFTLEdBQUc7QUFDcEMsVUFBTSxZQUFZLE1BQU0sU0FBUyxHQUFHO0FBQ3BDLFFBQUksYUFBYSxDQUFDO0FBQ2QsV0FBSztBQUFBLGFBQ0EsYUFBYSxDQUFDO0FBQ25CLFdBQUs7QUFBQTtBQUVMLFdBQUssY0FBYyxxQkFBcUI7QUFBQSxFQUNoRDtBQUNBLFNBQU8sR0FBRyxPQUFPLEdBQUc7QUFDeEI7QUFDQSxTQUFTLFlBQVksRUFBRSxTQUFTLE1BQU0sTUFBTSxHQUFHLEtBQUssV0FBVyxhQUFhO0FBQ3hFLFFBQU0sRUFBRSxZQUFZLGVBQWUsVUFBVSxJQUFJLElBQUk7QUFHckQsTUFBSSxDQUFDLGNBQWMsWUFBWSxLQUFLLEtBQUssS0FBSyxRQUFRLEtBQUssS0FBSyxHQUFHO0FBQy9ELFdBQU8sYUFBYSxPQUFPLEdBQUc7QUFBQSxFQUNsQztBQUNBLFFBQU0sU0FBUyxJQUFJLFdBQ2QsSUFBSSxvQkFBb0IsdUJBQXVCLEtBQUssSUFBSSxPQUFPO0FBQ3BFLFFBQU0sVUFBVSxlQUFlLFlBQ3pCLE9BQ0EsZUFBZSxZQUFZLFNBQVMsT0FBTyxlQUN2QyxRQUNBLFNBQVMsT0FBTyxnQkFDWixPQUNBLENBQUMsb0JBQW9CLE9BQU8sV0FBVyxPQUFPLE1BQU07QUFDbEUsTUFBSSxDQUFDO0FBQ0QsV0FBTyxVQUFVLFFBQVE7QUFFN0IsTUFBSTtBQUNKLE1BQUk7QUFDSixPQUFLLFdBQVcsTUFBTSxRQUFRLFdBQVcsR0FBRyxFQUFFLFVBQVU7QUFDcEQsVUFBTSxLQUFLLE1BQU0sV0FBVyxDQUFDO0FBQzdCLFFBQUksT0FBTyxRQUFRLE9BQU8sT0FBUSxPQUFPO0FBQ3JDO0FBQUEsRUFDUjtBQUNBLE1BQUksTUFBTSxNQUFNLFVBQVUsUUFBUTtBQUNsQyxRQUFNLFdBQVcsSUFBSSxRQUFRLElBQUk7QUFDakMsTUFBSSxhQUFhLElBQUk7QUFDakIsWUFBUTtBQUFBLEVBQ1osV0FDUyxVQUFVLE9BQU8sYUFBYSxJQUFJLFNBQVMsR0FBRztBQUNuRCxZQUFRO0FBQ1IsUUFBSTtBQUNBLGtCQUFZO0FBQUEsRUFDcEIsT0FDSztBQUNELFlBQVE7QUFBQSxFQUNaO0FBQ0EsTUFBSSxLQUFLO0FBQ0wsWUFBUSxNQUFNLE1BQU0sR0FBRyxDQUFDLElBQUksTUFBTTtBQUNsQyxRQUFJLElBQUksSUFBSSxTQUFTLENBQUMsTUFBTTtBQUN4QixZQUFNLElBQUksTUFBTSxHQUFHLEVBQUU7QUFDekIsVUFBTSxJQUFJLFFBQVEsZ0JBQWdCLEtBQUssUUFBUTtBQUFBLEVBQ25EO0FBRUEsTUFBSSxpQkFBaUI7QUFDckIsTUFBSTtBQUNKLE1BQUksYUFBYTtBQUNqQixPQUFLLFdBQVcsR0FBRyxXQUFXLE1BQU0sUUFBUSxFQUFFLFVBQVU7QUFDcEQsVUFBTSxLQUFLLE1BQU0sUUFBUTtBQUN6QixRQUFJLE9BQU87QUFDUCx1QkFBaUI7QUFBQSxhQUNaLE9BQU87QUFDWixtQkFBYTtBQUFBO0FBRWI7QUFBQSxFQUNSO0FBQ0EsTUFBSSxRQUFRLE1BQU0sVUFBVSxHQUFHLGFBQWEsV0FBVyxhQUFhLElBQUksUUFBUTtBQUNoRixNQUFJLE9BQU87QUFDUCxZQUFRLE1BQU0sVUFBVSxNQUFNLE1BQU07QUFDcEMsWUFBUSxNQUFNLFFBQVEsUUFBUSxLQUFLLFFBQVE7QUFBQSxFQUMvQztBQUNBLFFBQU0sYUFBYSxTQUFTLE1BQU07QUFDbEMsTUFBSSxVQUFVLFVBQVUsTUFBTSxRQUFRLGlCQUFpQixhQUFhLE1BQU07QUFDMUUsTUFBSSxTQUFTO0FBQ1QsY0FBVSxNQUFNLGNBQWMsUUFBUSxRQUFRLGNBQWMsR0FBRyxDQUFDO0FBQ2hFLFFBQUk7QUFDQSxnQkFBVTtBQUFBLEVBQ2xCO0FBQ0EsTUFBSSxTQUFTO0FBQ1QsWUFBUSxNQUFNLFFBQVEsUUFBUSxLQUFLLFFBQVE7QUFDM0MsV0FBTyxHQUFHO0FBQUEsRUFBVyxTQUFTLFFBQVEsUUFBUTtBQUFBLEVBQ2xEO0FBQ0EsVUFBUSxNQUNILFFBQVEsUUFBUSxNQUFNLEVBQ3RCLFFBQVEsa0RBQWtELE1BQU0sRUFFaEUsUUFBUSxRQUFRLEtBQUssUUFBUTtBQUNsQyxRQUFNLE9BQU8sY0FBYyxHQUFHLFFBQVEsUUFBUSxPQUFPLFFBQVEsWUFBWSxlQUFlLEdBQUcsQ0FBQztBQUM1RixTQUFPLEdBQUc7QUFBQSxFQUFXLFNBQVM7QUFDbEM7QUFDQSxTQUFTLFlBQVksTUFBTSxLQUFLLFdBQVcsYUFBYTtBQUNwRCxRQUFNLEVBQUUsTUFBTSxNQUFNLElBQUk7QUFDeEIsUUFBTSxFQUFFLGNBQWMsYUFBYSxRQUFRLE9BQU8sSUFBSTtBQUN0RCxNQUFLLGVBQWUsYUFBYSxLQUFLLEtBQUssS0FDdEMsVUFBVSxXQUFXLEtBQUssS0FBSyxHQUFJO0FBQ3BDLFdBQU8sYUFBYSxPQUFPLEdBQUc7QUFBQSxFQUNsQztBQUNBLE1BQUksQ0FBQyxTQUNELG9GQUFvRixLQUFLLEtBQUssR0FBRztBQU9qRyxXQUFPLGVBQWUsVUFBVSxNQUFNLFFBQVEsSUFBSSxNQUFNLEtBQ2xELGFBQWEsT0FBTyxHQUFHLElBQ3ZCLFlBQVksTUFBTSxLQUFLLFdBQVcsV0FBVztBQUFBLEVBQ3ZEO0FBQ0EsTUFBSSxDQUFDLGVBQ0QsQ0FBQyxVQUNELFNBQVMsT0FBTyxTQUNoQixNQUFNLFFBQVEsSUFBSSxNQUFNLElBQUk7QUFFNUIsV0FBTyxZQUFZLE1BQU0sS0FBSyxXQUFXLFdBQVc7QUFBQSxFQUN4RDtBQUNBLE1BQUksV0FBVyxNQUFNLHVCQUF1QixLQUFLLEdBQUc7QUFDaEQsUUFBSSxtQkFBbUI7QUFDdkIsV0FBTyxZQUFZLE1BQU0sS0FBSyxXQUFXLFdBQVc7QUFBQSxFQUN4RDtBQUNBLFFBQU0sTUFBTSxNQUFNLFFBQVEsUUFBUTtBQUFBLEVBQU8sUUFBUTtBQUlqRCxNQUFJLGNBQWM7QUFDZCxVQUFNLE9BQU8sQ0FBQ0MsU0FBUTtBQUFFLFVBQUk7QUFBSSxhQUFPQSxLQUFJLFdBQVdBLEtBQUksUUFBUSw2QkFBNkIsS0FBS0EsS0FBSSxVQUFVLFFBQVEsT0FBTyxTQUFTLFNBQVMsR0FBRyxLQUFLLEdBQUc7QUFBQSxJQUFJO0FBQ2xLLFVBQU0sRUFBRSxRQUFRLEtBQUssSUFBSSxJQUFJLElBQUk7QUFDakMsUUFBSSxLQUFLLEtBQUssSUFBSSxNQUFNLFdBQVcsUUFBUSxXQUFXLFNBQVMsU0FBUyxPQUFPLEtBQUssSUFBSTtBQUNwRixhQUFPLGFBQWEsT0FBTyxHQUFHO0FBQUEsRUFDdEM7QUFDQSxTQUFPLGNBQ0QsTUFDQSxjQUFjLEtBQUssUUFBUSxXQUFXLGVBQWUsR0FBRyxDQUFDO0FBQ25FO0FBQ0EsU0FBUyxnQkFBZ0IsTUFBTSxLQUFLLFdBQVcsYUFBYTtBQUN4RCxRQUFNLEVBQUUsYUFBYSxPQUFPLElBQUk7QUFDaEMsUUFBTSxLQUFLLE9BQU8sS0FBSyxVQUFVLFdBQzNCLE9BQ0EsT0FBTyxPQUFPLENBQUMsR0FBRyxNQUFNLEVBQUUsT0FBTyxPQUFPLEtBQUssS0FBSyxFQUFFLENBQUM7QUFDM0QsTUFBSSxFQUFFLEtBQUssSUFBSTtBQUNmLE1BQUksU0FBUyxPQUFPLGNBQWM7QUFFOUIsUUFBSSxrREFBa0QsS0FBSyxHQUFHLEtBQUs7QUFDL0QsYUFBTyxPQUFPO0FBQUEsRUFDdEI7QUFDQSxRQUFNLGFBQWEsQ0FBQyxVQUFVO0FBQzFCLFlBQVEsT0FBTztBQUFBLE1BQ1gsS0FBSyxPQUFPO0FBQUEsTUFDWixLQUFLLE9BQU87QUFDUixlQUFPLGVBQWUsU0FDaEIsYUFBYSxHQUFHLE9BQU8sR0FBRyxJQUMxQixZQUFZLElBQUksS0FBSyxXQUFXLFdBQVc7QUFBQSxNQUNyRCxLQUFLLE9BQU87QUFDUixlQUFPLG1CQUFtQixHQUFHLE9BQU8sR0FBRztBQUFBLE1BQzNDLEtBQUssT0FBTztBQUNSLGVBQU8sbUJBQW1CLEdBQUcsT0FBTyxHQUFHO0FBQUEsTUFDM0MsS0FBSyxPQUFPO0FBQ1IsZUFBTyxZQUFZLElBQUksS0FBSyxXQUFXLFdBQVc7QUFBQSxNQUN0RDtBQUNJLGVBQU87QUFBQSxJQUNmO0FBQUEsRUFDSjtBQUNBLE1BQUksTUFBTSxXQUFXLElBQUk7QUFDekIsTUFBSSxRQUFRLE1BQU07QUFDZCxVQUFNLEVBQUUsZ0JBQWdCLGtCQUFrQixJQUFJLElBQUk7QUFDbEQsVUFBTSxJQUFLLGVBQWUsa0JBQW1CO0FBQzdDLFVBQU0sV0FBVyxDQUFDO0FBQ2xCLFFBQUksUUFBUTtBQUNSLFlBQU0sSUFBSSxNQUFNLG1DQUFtQyxHQUFHO0FBQUEsRUFDOUQ7QUFDQSxTQUFPO0FBQ1g7OztBQ2xUQSxTQUFTLHVCQUF1QixLQUFLLFNBQVM7QUFDMUMsUUFBTSxNQUFNLE9BQU8sT0FBTztBQUFBLElBQ3RCLFlBQVk7QUFBQSxJQUNaLGVBQWU7QUFBQSxJQUNmLGdCQUFnQjtBQUFBLElBQ2hCLG1CQUFtQjtBQUFBLElBQ25CLFlBQVk7QUFBQSxJQUNaLG9CQUFvQjtBQUFBLElBQ3BCLGdDQUFnQztBQUFBLElBQ2hDLFVBQVU7QUFBQSxJQUNWLFdBQVc7QUFBQSxJQUNYLFdBQVc7QUFBQSxJQUNYLGlCQUFpQjtBQUFBLElBQ2pCLFNBQVM7QUFBQSxJQUNULFlBQVk7QUFBQSxJQUNaLGFBQWE7QUFBQSxJQUNiLFNBQVM7QUFBQSxJQUNULGtCQUFrQjtBQUFBLEVBQ3RCLEdBQUcsSUFBSSxPQUFPLGlCQUFpQixPQUFPO0FBQ3RDLE1BQUk7QUFDSixVQUFRLElBQUksaUJBQWlCO0FBQUEsSUFDekIsS0FBSztBQUNELGVBQVM7QUFDVDtBQUFBLElBQ0osS0FBSztBQUNELGVBQVM7QUFDVDtBQUFBLElBQ0o7QUFDSSxlQUFTO0FBQUEsRUFDakI7QUFDQSxTQUFPO0FBQUEsSUFDSCxTQUFTLG9CQUFJLElBQUk7QUFBQSxJQUNqQjtBQUFBLElBQ0EsUUFBUTtBQUFBLElBQ1IsWUFBWSxPQUFPLElBQUksV0FBVyxXQUFXLElBQUksT0FBTyxJQUFJLE1BQU0sSUFBSTtBQUFBLElBQ3RFO0FBQUEsSUFDQSxTQUFTO0FBQUEsRUFDYjtBQUNKO0FBQ0EsU0FBUyxhQUFhLE1BQU0sTUFBTTtBQUM5QixNQUFJLEtBQUssS0FBSztBQUNWLFVBQU0sUUFBUSxLQUFLLE9BQU8sT0FBSyxFQUFFLFFBQVEsS0FBSyxHQUFHO0FBQ2pELFFBQUksTUFBTSxTQUFTO0FBQ2YsYUFBTyxNQUFNLEtBQUssT0FBSyxFQUFFLFdBQVcsS0FBSyxNQUFNLEtBQUssTUFBTSxDQUFDO0FBQUEsRUFDbkU7QUFDQSxNQUFJLFNBQVM7QUFDYixNQUFJO0FBQ0osTUFBSSxTQUFTLElBQUksR0FBRztBQUNoQixVQUFNLEtBQUs7QUFDWCxVQUFNLFFBQVEsS0FBSyxPQUFPLE9BQUssRUFBRSxZQUFZLEVBQUUsU0FBUyxHQUFHLENBQUM7QUFDNUQsYUFDSSxNQUFNLEtBQUssT0FBSyxFQUFFLFdBQVcsS0FBSyxNQUFNLEtBQUssTUFBTSxLQUFLLE9BQUssQ0FBQyxFQUFFLE1BQU07QUFBQSxFQUM5RSxPQUNLO0FBQ0QsVUFBTTtBQUNOLGFBQVMsS0FBSyxLQUFLLE9BQUssRUFBRSxhQUFhLGVBQWUsRUFBRSxTQUFTO0FBQUEsRUFDckU7QUFDQSxNQUFJLENBQUMsUUFBUTtBQUVULFVBQU0sT0FBTyxPQUFPLElBQUksY0FBYyxJQUFJLFlBQVksT0FBTyxPQUFPO0FBQ3BFLFVBQU0sSUFBSSxNQUFNLHdCQUF3QixZQUFZO0FBQUEsRUFDeEQ7QUFDQSxTQUFPO0FBQ1g7QUFFQSxTQUFTLGVBQWUsTUFBTSxRQUFRLEVBQUUsU0FBUyxJQUFJLEdBQUc7QUFDcEQsTUFBSSxDQUFDLElBQUk7QUFDTCxXQUFPO0FBQ1gsUUFBTSxRQUFRLENBQUM7QUFDZixRQUFNLFVBQVUsU0FBUyxJQUFJLEtBQUssYUFBYSxJQUFJLE1BQU0sS0FBSztBQUM5RCxNQUFJLFVBQVUsY0FBYyxNQUFNLEdBQUc7QUFDakMsWUFBUSxJQUFJLE1BQU07QUFDbEIsVUFBTSxLQUFLLElBQUksUUFBUTtBQUFBLEVBQzNCO0FBQ0EsUUFBTUMsT0FBTSxLQUFLLFFBQVEsT0FBTyxVQUFVLE9BQU8sT0FBTztBQUN4RCxNQUFJQTtBQUNBLFVBQU0sS0FBSyxJQUFJLFdBQVcsVUFBVUEsSUFBRyxDQUFDO0FBQzVDLFNBQU8sTUFBTSxLQUFLLEdBQUc7QUFDekI7QUFDQSxTQUFTLFVBQVUsTUFBTSxLQUFLLFdBQVcsYUFBYTtBQUNsRCxNQUFJO0FBQ0osTUFBSSxPQUFPLElBQUk7QUFDWCxXQUFPLEtBQUssU0FBUyxLQUFLLFdBQVcsV0FBVztBQUNwRCxNQUFJLFFBQVEsSUFBSSxHQUFHO0FBQ2YsUUFBSSxJQUFJLElBQUk7QUFDUixhQUFPLEtBQUssU0FBUyxHQUFHO0FBQzVCLFNBQUssS0FBSyxJQUFJLHFCQUFxQixRQUFRLE9BQU8sU0FBUyxTQUFTLEdBQUcsSUFBSSxJQUFJLEdBQUc7QUFDOUUsWUFBTSxJQUFJLFVBQVUseURBQXlEO0FBQUEsSUFDakYsT0FDSztBQUNELFVBQUksSUFBSTtBQUNKLFlBQUksZ0JBQWdCLElBQUksSUFBSTtBQUFBO0FBRTVCLFlBQUksa0JBQWtCLG9CQUFJLElBQUksQ0FBQyxJQUFJLENBQUM7QUFDeEMsYUFBTyxLQUFLLFFBQVEsSUFBSSxHQUFHO0FBQUEsSUFDL0I7QUFBQSxFQUNKO0FBQ0EsTUFBSSxTQUFTO0FBQ2IsUUFBTSxPQUFPLE9BQU8sSUFBSSxJQUNsQixPQUNBLElBQUksSUFBSSxXQUFXLE1BQU0sRUFBRSxVQUFVLE9BQU0sU0FBUyxFQUFHLENBQUM7QUFDOUQsTUFBSSxDQUFDO0FBQ0QsYUFBUyxhQUFhLElBQUksSUFBSSxPQUFPLE1BQU0sSUFBSTtBQUNuRCxRQUFNLFFBQVEsZUFBZSxNQUFNLFFBQVEsR0FBRztBQUM5QyxNQUFJLE1BQU0sU0FBUztBQUNmLFFBQUksaUJBQWlCLElBQUksaUJBQWlCLEtBQUssTUFBTSxTQUFTO0FBQ2xFLFFBQU0sTUFBTSxPQUFPLE9BQU8sY0FBYyxhQUNsQyxPQUFPLFVBQVUsTUFBTSxLQUFLLFdBQVcsV0FBVyxJQUNsRCxTQUFTLElBQUksSUFDVCxnQkFBZ0IsTUFBTSxLQUFLLFdBQVcsV0FBVyxJQUNqRCxLQUFLLFNBQVMsS0FBSyxXQUFXLFdBQVc7QUFDbkQsTUFBSSxDQUFDO0FBQ0QsV0FBTztBQUNYLFNBQU8sU0FBUyxJQUFJLEtBQUssSUFBSSxDQUFDLE1BQU0sT0FBTyxJQUFJLENBQUMsTUFBTSxNQUNoRCxHQUFHLFNBQVMsUUFDWixHQUFHO0FBQUEsRUFBVSxJQUFJLFNBQVM7QUFDcEM7OztBQ3BIQSxTQUFTLGNBQWMsRUFBRSxLQUFLLE1BQU0sR0FBRyxLQUFLLFdBQVcsYUFBYTtBQUNoRSxRQUFNLEVBQUUsZUFBZSxLQUFLLFFBQVEsWUFBWSxTQUFTLEVBQUUsZUFBZSxXQUFXLFdBQVcsRUFBRSxJQUFJO0FBQ3RHLE1BQUksYUFBYyxPQUFPLEdBQUcsS0FBSyxJQUFJLFdBQVk7QUFDakQsTUFBSSxZQUFZO0FBQ1osUUFBSSxZQUFZO0FBQ1osWUFBTSxJQUFJLE1BQU0sa0RBQWtEO0FBQUEsSUFDdEU7QUFDQSxRQUFJLGFBQWEsR0FBRyxHQUFHO0FBQ25CLFlBQU0sTUFBTTtBQUNaLFlBQU0sSUFBSSxNQUFNLEdBQUc7QUFBQSxJQUN2QjtBQUFBLEVBQ0o7QUFDQSxNQUFJLGNBQWMsQ0FBQyxlQUNkLENBQUMsT0FDRyxjQUFjLFNBQVMsUUFBUSxDQUFDLElBQUksVUFDckMsYUFBYSxHQUFHLE1BQ2YsU0FBUyxHQUFHLElBQ1AsSUFBSSxTQUFTLE9BQU8sZ0JBQWdCLElBQUksU0FBUyxPQUFPLGdCQUN4RCxPQUFPLFFBQVE7QUFDN0IsUUFBTSxPQUFPLE9BQU8sQ0FBQyxHQUFHLEtBQUs7QUFBQSxJQUN6QixlQUFlO0FBQUEsSUFDZixhQUFhLENBQUMsZ0JBQWdCLGNBQWMsQ0FBQztBQUFBLElBQzdDLFFBQVEsU0FBUztBQUFBLEVBQ3JCLENBQUM7QUFDRCxNQUFJLGlCQUFpQjtBQUNyQixNQUFJLFlBQVk7QUFDaEIsTUFBSSxNQUFNLFVBQVUsS0FBSyxLQUFLLE1BQU8saUJBQWlCLE1BQU8sTUFBTyxZQUFZLElBQUs7QUFDckYsTUFBSSxDQUFDLGVBQWUsQ0FBQyxJQUFJLFVBQVUsSUFBSSxTQUFTLE1BQU07QUFDbEQsUUFBSTtBQUNBLFlBQU0sSUFBSSxNQUFNLDhFQUE4RTtBQUNsRyxrQkFBYztBQUFBLEVBQ2xCO0FBQ0EsTUFBSSxJQUFJLFFBQVE7QUFDWixRQUFJLGlCQUFpQixTQUFTLE1BQU07QUFDaEMsVUFBSSxrQkFBa0I7QUFDbEIsa0JBQVU7QUFDZCxhQUFPLGNBQWMsS0FBSyxRQUFRO0FBQUEsSUFDdEM7QUFBQSxFQUNKLFdBQ1UsaUJBQWlCLENBQUMsY0FBZ0IsU0FBUyxRQUFRLGFBQWM7QUFDdkUsVUFBTSxLQUFLO0FBQ1gsUUFBSSxjQUFjLENBQUMsZ0JBQWdCO0FBQy9CLGFBQU8sWUFBWSxLQUFLLElBQUksUUFBUSxjQUFjLFVBQVUsQ0FBQztBQUFBLElBQ2pFLFdBQ1MsYUFBYTtBQUNsQixrQkFBWTtBQUNoQixXQUFPO0FBQUEsRUFDWDtBQUNBLE1BQUk7QUFDQSxpQkFBYTtBQUNqQixNQUFJLGFBQWE7QUFDYixRQUFJO0FBQ0EsYUFBTyxZQUFZLEtBQUssSUFBSSxRQUFRLGNBQWMsVUFBVSxDQUFDO0FBQ2pFLFVBQU0sS0FBSztBQUFBLEVBQVE7QUFBQSxFQUN2QixPQUNLO0FBQ0QsVUFBTSxHQUFHO0FBQ1QsUUFBSTtBQUNBLGFBQU8sWUFBWSxLQUFLLElBQUksUUFBUSxjQUFjLFVBQVUsQ0FBQztBQUFBLEVBQ3JFO0FBQ0EsTUFBSSxNQUFNO0FBQ1YsTUFBSSxlQUFlO0FBQ25CLE1BQUksT0FBTyxLQUFLLEdBQUc7QUFDZixRQUFJLE1BQU07QUFDTixZQUFNO0FBQ1YsUUFBSSxNQUFNLGVBQWU7QUFDckIsWUFBTSxLQUFLLGNBQWMsTUFBTSxhQUFhO0FBQzVDLGFBQU87QUFBQSxFQUFLLGNBQWMsSUFBSSxJQUFJLE1BQU07QUFBQSxJQUM1QztBQUNBLG1CQUFlLE1BQU07QUFBQSxFQUN6QixXQUNTLFNBQVMsT0FBTyxVQUFVLFVBQVU7QUFDekMsWUFBUSxJQUFJLFdBQVcsS0FBSztBQUFBLEVBQ2hDO0FBQ0EsTUFBSSxjQUFjO0FBQ2xCLE1BQUksQ0FBQyxlQUFlLENBQUMsY0FBYyxTQUFTLEtBQUs7QUFDN0MsUUFBSSxnQkFBZ0IsSUFBSSxTQUFTO0FBQ3JDLGNBQVk7QUFDWixNQUFJLENBQUMsYUFDRCxXQUFXLFVBQVUsS0FDckIsQ0FBQyxJQUFJLFVBQ0wsQ0FBQyxlQUNELE1BQU0sS0FBSyxLQUNYLENBQUMsTUFBTSxRQUNQLENBQUMsTUFBTSxPQUNQLENBQUMsTUFBTSxRQUFRO0FBRWYsUUFBSSxTQUFTLElBQUksT0FBTyxPQUFPLENBQUM7QUFBQSxFQUNwQztBQUNBLE1BQUksbUJBQW1CO0FBQ3ZCLFFBQU0sV0FBVyxVQUFVLE9BQU8sS0FBSyxNQUFPLG1CQUFtQixNQUFPLE1BQU8sWUFBWSxJQUFLO0FBQ2hHLE1BQUksS0FBSztBQUNULE1BQUksT0FBTyxZQUFZO0FBQ25CLFNBQUssYUFBYSxNQUFNLENBQUMsSUFBSSxTQUFTLE1BQU0sR0FBRztBQUFBLEVBQVEsSUFBSTtBQUFBLEVBQy9ELFdBQ1MsQ0FBQyxlQUFlLGFBQWEsS0FBSyxHQUFHO0FBQzFDLFVBQU0sT0FBTyxTQUFTLENBQUMsTUFBTSxPQUFPLFNBQVMsQ0FBQyxNQUFNO0FBQ3BELFFBQUksQ0FBQyxRQUFRLFNBQVMsU0FBUyxJQUFJO0FBQy9CLFdBQUs7QUFBQSxFQUFLLElBQUk7QUFBQSxFQUN0QixXQUNTLGFBQWEsTUFBTSxTQUFTLENBQUMsTUFBTTtBQUN4QyxTQUFLO0FBQ1QsU0FBTyxLQUFLO0FBQ1osTUFBSSxJQUFJLFFBQVE7QUFDWixRQUFJLG9CQUFvQjtBQUNwQixnQkFBVTtBQUFBLEVBQ2xCLFdBQ1MsZ0JBQWdCLENBQUMsa0JBQWtCO0FBQ3hDLFdBQU8sWUFBWSxLQUFLLElBQUksUUFBUSxjQUFjLFlBQVksQ0FBQztBQUFBLEVBQ25FLFdBQ1MsYUFBYSxhQUFhO0FBQy9CLGdCQUFZO0FBQUEsRUFDaEI7QUFDQSxTQUFPO0FBQ1g7OztBQ25IQSxTQUFTLEtBQUssVUFBVSxTQUFTO0FBQzdCLE1BQUksYUFBYSxXQUFXLGFBQWEsUUFBUTtBQUM3QyxRQUFJLE9BQU8sWUFBWSxlQUFlLFFBQVE7QUFDMUMsY0FBUSxZQUFZLE9BQU87QUFBQTtBQUUzQixjQUFRLEtBQUssT0FBTztBQUFBLEVBQzVCO0FBQ0o7OztBQ0xBLElBQU0sWUFBWTtBQUNsQixTQUFTLGVBQWUsS0FBS0MsTUFBSyxFQUFFLEtBQUssTUFBTSxHQUFHO0FBQzlDLE1BQUksT0FBTyxJQUFJLElBQUksT0FBTyxTQUFTLFdBQVcsR0FBRyxHQUFHO0FBQ2hELFlBQVEsUUFBUSxLQUFLLElBQUksTUFBTSxRQUFRLElBQUksR0FBRyxJQUFJO0FBQ2xELFFBQUksTUFBTSxLQUFLO0FBQ1gsaUJBQVcsTUFBTSxNQUFNO0FBQ25CLHFCQUFhLEtBQUtBLE1BQUssRUFBRTtBQUFBLGFBQ3hCLE1BQU0sUUFBUSxLQUFLO0FBQ3hCLGlCQUFXLE1BQU07QUFDYixxQkFBYSxLQUFLQSxNQUFLLEVBQUU7QUFBQTtBQUU3QixtQkFBYSxLQUFLQSxNQUFLLEtBQUs7QUFBQSxFQUNwQyxPQUNLO0FBQ0QsVUFBTSxRQUFRLEtBQUssS0FBSyxJQUFJLEdBQUc7QUFDL0IsUUFBSUEsZ0JBQWUsS0FBSztBQUNwQixNQUFBQSxLQUFJLElBQUksT0FBTyxLQUFLLE9BQU8sT0FBTyxHQUFHLENBQUM7QUFBQSxJQUMxQyxXQUNTQSxnQkFBZSxLQUFLO0FBQ3pCLE1BQUFBLEtBQUksSUFBSSxLQUFLO0FBQUEsSUFDakIsT0FDSztBQUNELFlBQU0sWUFBWSxhQUFhLEtBQUssT0FBTyxHQUFHO0FBQzlDLFlBQU0sVUFBVSxLQUFLLE9BQU8sV0FBVyxHQUFHO0FBQzFDLFVBQUksYUFBYUE7QUFDYixlQUFPLGVBQWVBLE1BQUssV0FBVztBQUFBLFVBQ2xDLE9BQU87QUFBQSxVQUNQLFVBQVU7QUFBQSxVQUNWLFlBQVk7QUFBQSxVQUNaLGNBQWM7QUFBQSxRQUNsQixDQUFDO0FBQUE7QUFFRCxRQUFBQSxLQUFJLFNBQVMsSUFBSTtBQUFBLElBQ3pCO0FBQUEsRUFDSjtBQUNBLFNBQU9BO0FBQ1g7QUFDQSxJQUFNLGFBQWEsQ0FBQyxRQUFRLFFBQVEsYUFDL0IsU0FBUyxHQUFHLEtBQ1QsSUFBSSxVQUFVLGNBQ2IsQ0FBQyxJQUFJLFFBQVEsSUFBSSxTQUFTLE9BQU87QUFRMUMsU0FBUyxhQUFhLEtBQUtBLE1BQUssT0FBTztBQUNuQyxRQUFNLFNBQVMsT0FBTyxRQUFRLEtBQUssSUFBSSxNQUFNLFFBQVEsSUFBSSxHQUFHLElBQUk7QUFDaEUsTUFBSSxDQUFDLE1BQU0sTUFBTTtBQUNiLFVBQU0sSUFBSSxNQUFNLDJDQUEyQztBQUMvRCxRQUFNLFNBQVMsT0FBTyxPQUFPLE1BQU0sS0FBSyxHQUFHO0FBQzNDLGFBQVcsQ0FBQyxLQUFLQyxNQUFLLEtBQUssUUFBUTtBQUMvQixRQUFJRCxnQkFBZSxLQUFLO0FBQ3BCLFVBQUksQ0FBQ0EsS0FBSSxJQUFJLEdBQUc7QUFDWixRQUFBQSxLQUFJLElBQUksS0FBS0MsTUFBSztBQUFBLElBQzFCLFdBQ1NELGdCQUFlLEtBQUs7QUFDekIsTUFBQUEsS0FBSSxJQUFJLEdBQUc7QUFBQSxJQUNmLFdBQ1MsQ0FBQyxPQUFPLFVBQVUsZUFBZSxLQUFLQSxNQUFLLEdBQUcsR0FBRztBQUN0RCxhQUFPLGVBQWVBLE1BQUssS0FBSztBQUFBLFFBQzVCLE9BQUFDO0FBQUEsUUFDQSxVQUFVO0FBQUEsUUFDVixZQUFZO0FBQUEsUUFDWixjQUFjO0FBQUEsTUFDbEIsQ0FBQztBQUFBLElBQ0w7QUFBQSxFQUNKO0FBQ0EsU0FBT0Q7QUFDWDtBQUNBLFNBQVMsYUFBYSxLQUFLLE9BQU8sS0FBSztBQUNuQyxNQUFJLFVBQVU7QUFDVixXQUFPO0FBQ1gsTUFBSSxPQUFPLFVBQVU7QUFDakIsV0FBTyxPQUFPLEtBQUs7QUFDdkIsTUFBSSxPQUFPLEdBQUcsS0FBSyxPQUFPLElBQUksS0FBSztBQUMvQixVQUFNLFNBQVMsdUJBQXVCLElBQUksS0FBSyxDQUFDLENBQUM7QUFDakQsV0FBTyxVQUFVLG9CQUFJLElBQUk7QUFDekIsZUFBVyxRQUFRLElBQUksUUFBUSxLQUFLO0FBQ2hDLGFBQU8sUUFBUSxJQUFJLEtBQUssTUFBTTtBQUNsQyxXQUFPLFNBQVM7QUFDaEIsV0FBTyxpQkFBaUI7QUFDeEIsVUFBTSxTQUFTLElBQUksU0FBUyxNQUFNO0FBQ2xDLFFBQUksQ0FBQyxJQUFJLGNBQWM7QUFDbkIsVUFBSSxVQUFVLEtBQUssVUFBVSxNQUFNO0FBQ25DLFVBQUksUUFBUSxTQUFTO0FBQ2pCLGtCQUFVLFFBQVEsVUFBVSxHQUFHLEVBQUUsSUFBSTtBQUN6QyxXQUFLLElBQUksSUFBSSxRQUFRLFVBQVUsa0ZBQWtGLGlEQUFpRDtBQUNsSyxVQUFJLGVBQWU7QUFBQSxJQUN2QjtBQUNBLFdBQU87QUFBQSxFQUNYO0FBQ0EsU0FBTyxLQUFLLFVBQVUsS0FBSztBQUMvQjs7O0FDaEdBLFNBQVMsV0FBVyxLQUFLLE9BQU8sS0FBSztBQUNqQyxRQUFNLElBQUksV0FBVyxLQUFLLFFBQVcsR0FBRztBQUN4QyxRQUFNLElBQUksV0FBVyxPQUFPLFFBQVcsR0FBRztBQUMxQyxTQUFPLElBQUksS0FBSyxHQUFHLENBQUM7QUFDeEI7QUFDQSxJQUFNLE9BQU4sTUFBVztBQUFBLEVBQ1AsWUFBWSxLQUFLLFFBQVEsTUFBTTtBQUMzQixXQUFPLGVBQWUsTUFBTSxXQUFXLEVBQUUsT0FBTyxLQUFLLENBQUM7QUFDdEQsU0FBSyxNQUFNO0FBQ1gsU0FBSyxRQUFRO0FBQUEsRUFDakI7QUFBQSxFQUNBLE1BQU1FLFNBQVE7QUFDVixRQUFJLEVBQUUsS0FBSyxNQUFNLElBQUk7QUFDckIsUUFBSSxPQUFPLEdBQUc7QUFDVixZQUFNLElBQUksTUFBTUEsT0FBTTtBQUMxQixRQUFJLE9BQU8sS0FBSztBQUNaLGNBQVEsTUFBTSxNQUFNQSxPQUFNO0FBQzlCLFdBQU8sSUFBSSxLQUFLLEtBQUssS0FBSztBQUFBLEVBQzlCO0FBQUEsRUFDQSxPQUFPLEdBQUcsS0FBSztBQUNYLFVBQU0sT0FBTyxPQUFPLElBQUksV0FBVyxvQkFBSSxJQUFJLElBQUksQ0FBQztBQUNoRCxXQUFPLGVBQWUsS0FBSyxNQUFNLElBQUk7QUFBQSxFQUN6QztBQUFBLEVBQ0EsU0FBUyxLQUFLLFdBQVcsYUFBYTtBQUNsQyxXQUFPLE9BQU8sSUFBSSxNQUNaLGNBQWMsTUFBTSxLQUFLLFdBQVcsV0FBVyxJQUMvQyxLQUFLLFVBQVUsSUFBSTtBQUFBLEVBQzdCO0FBQ0o7OztBQzFCQSxJQUFNLGlCQUFpQjtBQUFBLEVBQ25CLGFBQWE7QUFBQSxFQUNiLGtCQUFrQjtBQUFBLEVBQ2xCLFVBQVU7QUFBQSxFQUNWLGNBQWM7QUFBQSxFQUNkLFFBQVE7QUFBQSxFQUNSLFlBQVk7QUFBQSxFQUNaLFNBQVM7QUFDYjs7O0FDVkEsU0FBUyxvQkFBb0IsWUFBWSxLQUFLLFNBQVM7QUFDbkQsTUFBSTtBQUNKLFFBQU0sUUFBUSxLQUFLLElBQUksWUFBWSxRQUFRLE9BQU8sU0FBUyxLQUFLLFdBQVc7QUFDM0UsUUFBTUMsYUFBWSxPQUFPLDBCQUEwQjtBQUNuRCxTQUFPQSxXQUFVLFlBQVksS0FBSyxPQUFPO0FBQzdDO0FBQ0EsU0FBUyx5QkFBeUIsRUFBRSxTQUFTLE1BQU0sR0FBRyxLQUFLLEVBQUUsaUJBQWlCLFdBQVcsWUFBWSxhQUFhLFVBQVUsR0FBRztBQUMzSCxRQUFNLEVBQUUsUUFBUSxTQUFTLEVBQUUsY0FBYyxFQUFFLElBQUk7QUFDL0MsUUFBTSxVQUFVLE9BQU8sT0FBTyxDQUFDLEdBQUcsS0FBSyxFQUFFLFFBQVEsWUFBWSxNQUFNLEtBQUssQ0FBQztBQUN6RSxNQUFJLFlBQVk7QUFDaEIsUUFBTSxRQUFRLENBQUM7QUFDZixXQUFTLElBQUksR0FBRyxJQUFJLE1BQU0sUUFBUSxFQUFFLEdBQUc7QUFDbkMsVUFBTSxPQUFPLE1BQU0sQ0FBQztBQUNwQixRQUFJQyxXQUFVO0FBQ2QsUUFBSSxPQUFPLElBQUksR0FBRztBQUNkLFVBQUksQ0FBQyxhQUFhLEtBQUs7QUFDbkIsY0FBTSxLQUFLLEVBQUU7QUFDakIsdUJBQWlCLEtBQUssT0FBTyxLQUFLLGVBQWUsU0FBUztBQUMxRCxVQUFJLEtBQUs7QUFDTCxRQUFBQSxXQUFVLEtBQUs7QUFBQSxJQUN2QixXQUNTLE9BQU8sSUFBSSxHQUFHO0FBQ25CLFlBQU0sS0FBSyxPQUFPLEtBQUssR0FBRyxJQUFJLEtBQUssTUFBTTtBQUN6QyxVQUFJLElBQUk7QUFDSixZQUFJLENBQUMsYUFBYSxHQUFHO0FBQ2pCLGdCQUFNLEtBQUssRUFBRTtBQUNqQix5QkFBaUIsS0FBSyxPQUFPLEdBQUcsZUFBZSxTQUFTO0FBQUEsTUFDNUQ7QUFBQSxJQUNKO0FBQ0EsZ0JBQVk7QUFDWixRQUFJQyxPQUFNLFVBQVUsTUFBTSxTQUFTLE1BQU9ELFdBQVUsTUFBTyxNQUFPLFlBQVksSUFBSztBQUNuRixRQUFJQTtBQUNBLE1BQUFDLFFBQU8sWUFBWUEsTUFBSyxZQUFZLGNBQWNELFFBQU8sQ0FBQztBQUM5RCxRQUFJLGFBQWFBO0FBQ2Isa0JBQVk7QUFDaEIsVUFBTSxLQUFLLGtCQUFrQkMsSUFBRztBQUFBLEVBQ3BDO0FBQ0EsTUFBSTtBQUNKLE1BQUksTUFBTSxXQUFXLEdBQUc7QUFDcEIsVUFBTSxVQUFVLFFBQVEsVUFBVTtBQUFBLEVBQ3RDLE9BQ0s7QUFDRCxVQUFNLE1BQU0sQ0FBQztBQUNiLGFBQVMsSUFBSSxHQUFHLElBQUksTUFBTSxRQUFRLEVBQUUsR0FBRztBQUNuQyxZQUFNLE9BQU8sTUFBTSxDQUFDO0FBQ3BCLGFBQU8sT0FBTztBQUFBLEVBQUssU0FBUyxTQUFTO0FBQUEsSUFDekM7QUFBQSxFQUNKO0FBQ0EsTUFBSSxTQUFTO0FBQ1QsV0FBTyxPQUFPLGNBQWMsY0FBYyxPQUFPLEdBQUcsTUFBTTtBQUMxRCxRQUFJO0FBQ0EsZ0JBQVU7QUFBQSxFQUNsQixXQUNTLGFBQWE7QUFDbEIsZ0JBQVk7QUFDaEIsU0FBTztBQUNYO0FBQ0EsU0FBUyx3QkFBd0IsRUFBRSxTQUFTLE1BQU0sR0FBRyxLQUFLLEVBQUUsV0FBVyxZQUFZLFVBQVUsR0FBRztBQUM1RixRQUFNLEVBQUUsUUFBUSxZQUFZLFNBQVMsRUFBRSxjQUFjLEVBQUUsSUFBSTtBQUMzRCxnQkFBYztBQUNkLFFBQU0sVUFBVSxPQUFPLE9BQU8sQ0FBQyxHQUFHLEtBQUs7QUFBQSxJQUNuQyxRQUFRO0FBQUEsSUFDUixRQUFRO0FBQUEsSUFDUixNQUFNO0FBQUEsRUFDVixDQUFDO0FBQ0QsTUFBSSxhQUFhO0FBQ2pCLE1BQUksZUFBZTtBQUNuQixRQUFNLFFBQVEsQ0FBQztBQUNmLFdBQVMsSUFBSSxHQUFHLElBQUksTUFBTSxRQUFRLEVBQUUsR0FBRztBQUNuQyxVQUFNLE9BQU8sTUFBTSxDQUFDO0FBQ3BCLFFBQUlELFdBQVU7QUFDZCxRQUFJLE9BQU8sSUFBSSxHQUFHO0FBQ2QsVUFBSSxLQUFLO0FBQ0wsY0FBTSxLQUFLLEVBQUU7QUFDakIsdUJBQWlCLEtBQUssT0FBTyxLQUFLLGVBQWUsS0FBSztBQUN0RCxVQUFJLEtBQUs7QUFDTCxRQUFBQSxXQUFVLEtBQUs7QUFBQSxJQUN2QixXQUNTLE9BQU8sSUFBSSxHQUFHO0FBQ25CLFlBQU0sS0FBSyxPQUFPLEtBQUssR0FBRyxJQUFJLEtBQUssTUFBTTtBQUN6QyxVQUFJLElBQUk7QUFDSixZQUFJLEdBQUc7QUFDSCxnQkFBTSxLQUFLLEVBQUU7QUFDakIseUJBQWlCLEtBQUssT0FBTyxHQUFHLGVBQWUsS0FBSztBQUNwRCxZQUFJLEdBQUc7QUFDSCx1QkFBYTtBQUFBLE1BQ3JCO0FBQ0EsWUFBTSxLQUFLLE9BQU8sS0FBSyxLQUFLLElBQUksS0FBSyxRQUFRO0FBQzdDLFVBQUksSUFBSTtBQUNKLFlBQUksR0FBRztBQUNILFVBQUFBLFdBQVUsR0FBRztBQUNqQixZQUFJLEdBQUc7QUFDSCx1QkFBYTtBQUFBLE1BQ3JCLFdBQ1MsS0FBSyxTQUFTLFFBQVEsTUFBTSxHQUFHLFNBQVM7QUFDN0MsUUFBQUEsV0FBVSxHQUFHO0FBQUEsTUFDakI7QUFBQSxJQUNKO0FBQ0EsUUFBSUE7QUFDQSxtQkFBYTtBQUNqQixRQUFJQyxPQUFNLFVBQVUsTUFBTSxTQUFTLE1BQU9ELFdBQVUsSUFBSztBQUN6RCxRQUFJLElBQUksTUFBTSxTQUFTO0FBQ25CLE1BQUFDLFFBQU87QUFDWCxRQUFJRDtBQUNBLE1BQUFDLFFBQU8sWUFBWUEsTUFBSyxZQUFZLGNBQWNELFFBQU8sQ0FBQztBQUM5RCxRQUFJLENBQUMsZUFBZSxNQUFNLFNBQVMsZ0JBQWdCQyxLQUFJLFNBQVMsSUFBSTtBQUNoRSxtQkFBYTtBQUNqQixVQUFNLEtBQUtBLElBQUc7QUFDZCxtQkFBZSxNQUFNO0FBQUEsRUFDekI7QUFDQSxNQUFJO0FBQ0osUUFBTSxFQUFFLE9BQU8sSUFBSSxJQUFJO0FBQ3ZCLE1BQUksTUFBTSxXQUFXLEdBQUc7QUFDcEIsVUFBTSxRQUFRO0FBQUEsRUFDbEIsT0FDSztBQUNELFFBQUksQ0FBQyxZQUFZO0FBQ2IsWUFBTSxNQUFNLE1BQU0sT0FBTyxDQUFDLEtBQUssU0FBUyxNQUFNLEtBQUssU0FBUyxHQUFHLENBQUM7QUFDaEUsbUJBQWEsTUFBTSxXQUFXO0FBQUEsSUFDbEM7QUFDQSxRQUFJLFlBQVk7QUFDWixZQUFNO0FBQ04saUJBQVcsUUFBUTtBQUNmLGVBQU8sT0FBTztBQUFBLEVBQUssYUFBYSxTQUFTLFNBQVM7QUFDdEQsYUFBTztBQUFBLEVBQUssU0FBUztBQUFBLElBQ3pCLE9BQ0s7QUFDRCxZQUFNLEdBQUcsU0FBUyxNQUFNLEtBQUssR0FBRyxLQUFLO0FBQUEsSUFDekM7QUFBQSxFQUNKO0FBQ0EsTUFBSSxTQUFTO0FBQ1QsV0FBTyxZQUFZLEtBQUssY0FBYyxPQUFPLEdBQUcsTUFBTTtBQUN0RCxRQUFJO0FBQ0EsZ0JBQVU7QUFBQSxFQUNsQjtBQUNBLFNBQU87QUFDWDtBQUNBLFNBQVMsaUJBQWlCLEVBQUUsUUFBUSxTQUFTLEVBQUUsY0FBYyxFQUFFLEdBQUcsT0FBTyxTQUFTLFdBQVc7QUFDekYsTUFBSSxXQUFXO0FBQ1gsY0FBVSxRQUFRLFFBQVEsUUFBUSxFQUFFO0FBQ3hDLE1BQUksU0FBUztBQUNULFVBQU0sS0FBSyxjQUFjLGNBQWMsT0FBTyxHQUFHLE1BQU07QUFDdkQsVUFBTSxLQUFLLEdBQUcsVUFBVSxDQUFDO0FBQUEsRUFDN0I7QUFDSjs7O0FDOUlBLFNBQVMsU0FBUyxPQUFPLEtBQUs7QUFDMUIsUUFBTSxJQUFJLFNBQVMsR0FBRyxJQUFJLElBQUksUUFBUTtBQUN0QyxhQUFXLE1BQU0sT0FBTztBQUNwQixRQUFJLE9BQU8sRUFBRSxHQUFHO0FBQ1osVUFBSSxHQUFHLFFBQVEsT0FBTyxHQUFHLFFBQVE7QUFDN0IsZUFBTztBQUNYLFVBQUksU0FBUyxHQUFHLEdBQUcsS0FBSyxHQUFHLElBQUksVUFBVTtBQUNyQyxlQUFPO0FBQUEsSUFDZjtBQUFBLEVBQ0o7QUFDQSxTQUFPO0FBQ1g7QUFDQSxJQUFNLFVBQU4sY0FBc0IsV0FBVztBQUFBLEVBQzdCLFlBQVlDLFNBQVE7QUFDaEIsVUFBTSxLQUFLQSxPQUFNO0FBQ2pCLFNBQUssUUFBUSxDQUFDO0FBQUEsRUFDbEI7QUFBQSxFQUNBLFdBQVcsVUFBVTtBQUNqQixXQUFPO0FBQUEsRUFDWDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBT0EsSUFBSSxNQUFNLFdBQVc7QUFDakIsUUFBSTtBQUNKLFFBQUksT0FBTyxJQUFJO0FBQ1gsY0FBUTtBQUFBLGFBQ0gsQ0FBQyxRQUFRLE9BQU8sU0FBUyxZQUFZLEVBQUUsU0FBUyxPQUFPO0FBRTVELGNBQVEsSUFBSSxLQUFLLE1BQU0sS0FBSyxLQUFLO0FBQUEsSUFDckM7QUFFSSxjQUFRLElBQUksS0FBSyxLQUFLLEtBQUssS0FBSyxLQUFLO0FBQ3pDLFVBQU0sT0FBTyxTQUFTLEtBQUssT0FBTyxNQUFNLEdBQUc7QUFDM0MsVUFBTSxjQUFjLEtBQUssVUFBVSxLQUFLLE9BQU87QUFDL0MsUUFBSSxNQUFNO0FBQ04sVUFBSSxDQUFDO0FBQ0QsY0FBTSxJQUFJLE1BQU0sT0FBTyxNQUFNLGlCQUFpQjtBQUVsRCxVQUFJLFNBQVMsS0FBSyxLQUFLLEtBQUssY0FBYyxNQUFNLEtBQUs7QUFDakQsYUFBSyxNQUFNLFFBQVEsTUFBTTtBQUFBO0FBRXpCLGFBQUssUUFBUSxNQUFNO0FBQUEsSUFDM0IsV0FDUyxhQUFhO0FBQ2xCLFlBQU0sSUFBSSxLQUFLLE1BQU0sVUFBVSxVQUFRLFlBQVksT0FBTyxJQUFJLElBQUksQ0FBQztBQUNuRSxVQUFJLE1BQU07QUFDTixhQUFLLE1BQU0sS0FBSyxLQUFLO0FBQUE7QUFFckIsYUFBSyxNQUFNLE9BQU8sR0FBRyxHQUFHLEtBQUs7QUFBQSxJQUNyQyxPQUNLO0FBQ0QsV0FBSyxNQUFNLEtBQUssS0FBSztBQUFBLElBQ3pCO0FBQUEsRUFDSjtBQUFBLEVBQ0EsT0FBTyxLQUFLO0FBQ1IsVUFBTSxLQUFLLFNBQVMsS0FBSyxPQUFPLEdBQUc7QUFDbkMsUUFBSSxDQUFDO0FBQ0QsYUFBTztBQUNYLFVBQU0sTUFBTSxLQUFLLE1BQU0sT0FBTyxLQUFLLE1BQU0sUUFBUSxFQUFFLEdBQUcsQ0FBQztBQUN2RCxXQUFPLElBQUksU0FBUztBQUFBLEVBQ3hCO0FBQUEsRUFDQSxJQUFJLEtBQUssWUFBWTtBQUNqQixVQUFNLEtBQUssU0FBUyxLQUFLLE9BQU8sR0FBRztBQUNuQyxVQUFNLE9BQU8sTUFBTSxHQUFHO0FBQ3RCLFdBQU8sQ0FBQyxjQUFjLFNBQVMsSUFBSSxJQUFJLEtBQUssUUFBUTtBQUFBLEVBQ3hEO0FBQUEsRUFDQSxJQUFJLEtBQUs7QUFDTCxXQUFPLENBQUMsQ0FBQyxTQUFTLEtBQUssT0FBTyxHQUFHO0FBQUEsRUFDckM7QUFBQSxFQUNBLElBQUksS0FBSyxPQUFPO0FBQ1osU0FBSyxJQUFJLElBQUksS0FBSyxLQUFLLEtBQUssR0FBRyxJQUFJO0FBQUEsRUFDdkM7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFNQSxPQUFPLEdBQUcsS0FBSyxNQUFNO0FBQ2pCLFVBQU1DLE9BQU0sT0FBTyxJQUFJLEtBQUssSUFBSSxPQUFPLElBQUksV0FBVyxvQkFBSSxJQUFJLElBQUksQ0FBQztBQUNuRSxRQUFJLE9BQU8sSUFBSTtBQUNYLFVBQUksU0FBU0EsSUFBRztBQUNwQixlQUFXLFFBQVEsS0FBSztBQUNwQixxQkFBZSxLQUFLQSxNQUFLLElBQUk7QUFDakMsV0FBT0E7QUFBQSxFQUNYO0FBQUEsRUFDQSxTQUFTLEtBQUssV0FBVyxhQUFhO0FBQ2xDLFFBQUksQ0FBQztBQUNELGFBQU8sS0FBSyxVQUFVLElBQUk7QUFDOUIsZUFBVyxRQUFRLEtBQUssT0FBTztBQUMzQixVQUFJLENBQUMsT0FBTyxJQUFJO0FBQ1osY0FBTSxJQUFJLE1BQU0sc0NBQXNDLEtBQUssVUFBVSxJQUFJLFdBQVc7QUFBQSxJQUM1RjtBQUNBLFFBQUksQ0FBQyxJQUFJLGlCQUFpQixLQUFLLGlCQUFpQixLQUFLO0FBQ2pELFlBQU0sT0FBTyxPQUFPLENBQUMsR0FBRyxLQUFLLEVBQUUsZUFBZSxLQUFLLENBQUM7QUFDeEQsV0FBTyxvQkFBb0IsTUFBTSxLQUFLO0FBQUEsTUFDbEMsaUJBQWlCO0FBQUEsTUFDakIsV0FBVyxFQUFFLE9BQU8sS0FBSyxLQUFLLElBQUk7QUFBQSxNQUNsQyxZQUFZLElBQUksVUFBVTtBQUFBLE1BQzFCO0FBQUEsTUFDQTtBQUFBLElBQ0osQ0FBQztBQUFBLEVBQ0w7QUFDSjs7O0FDN0dBLFNBQVMsVUFBVUMsU0FBUSxLQUFLLEtBQUs7QUFDakMsUUFBTSxFQUFFLGVBQWUsU0FBUyxJQUFJO0FBQ3BDLFFBQU1DLE9BQU0sSUFBSSxRQUFRRCxPQUFNO0FBQzlCLFFBQU0sTUFBTSxDQUFDLEtBQUssVUFBVTtBQUN4QixRQUFJLE9BQU8sYUFBYTtBQUNwQixjQUFRLFNBQVMsS0FBSyxLQUFLLEtBQUssS0FBSztBQUFBLGFBQ2hDLE1BQU0sUUFBUSxRQUFRLEtBQUssQ0FBQyxTQUFTLFNBQVMsR0FBRztBQUN0RDtBQUNKLFFBQUksVUFBVSxVQUFhO0FBQ3ZCLE1BQUFDLEtBQUksTUFBTSxLQUFLLFdBQVcsS0FBSyxPQUFPLEdBQUcsQ0FBQztBQUFBLEVBQ2xEO0FBQ0EsTUFBSSxlQUFlLEtBQUs7QUFDcEIsZUFBVyxDQUFDLEtBQUssS0FBSyxLQUFLO0FBQ3ZCLFVBQUksS0FBSyxLQUFLO0FBQUEsRUFDdEIsV0FDUyxPQUFPLE9BQU8sUUFBUSxVQUFVO0FBQ3JDLGVBQVcsT0FBTyxPQUFPLEtBQUssR0FBRztBQUM3QixVQUFJLEtBQUssSUFBSSxHQUFHLENBQUM7QUFBQSxFQUN6QjtBQUNBLE1BQUksT0FBT0QsUUFBTyxtQkFBbUIsWUFBWTtBQUM3QyxJQUFBQyxLQUFJLE1BQU0sS0FBS0QsUUFBTyxjQUFjO0FBQUEsRUFDeEM7QUFDQSxTQUFPQztBQUNYO0FBQ0EsSUFBTSxNQUFNO0FBQUEsRUFDUixZQUFZO0FBQUEsRUFDWixZQUFZO0FBQUEsRUFDWixTQUFTO0FBQUEsRUFDVCxXQUFXO0FBQUEsRUFDWCxLQUFLO0FBQUEsRUFDTCxRQUFRQSxNQUFLLFNBQVM7QUFDbEIsUUFBSSxDQUFDLE1BQU1BLElBQUc7QUFDVixjQUFRLGlDQUFpQztBQUM3QyxXQUFPQTtBQUFBLEVBQ1g7QUFDSjs7O0FDakNBLElBQU0sVUFBTixjQUFzQixXQUFXO0FBQUEsRUFDN0IsWUFBWUMsU0FBUTtBQUNoQixVQUFNLEtBQUtBLE9BQU07QUFDakIsU0FBSyxRQUFRLENBQUM7QUFBQSxFQUNsQjtBQUFBLEVBQ0EsV0FBVyxVQUFVO0FBQ2pCLFdBQU87QUFBQSxFQUNYO0FBQUEsRUFDQSxJQUFJLE9BQU87QUFDUCxTQUFLLE1BQU0sS0FBSyxLQUFLO0FBQUEsRUFDekI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFTQSxPQUFPLEtBQUs7QUFDUixVQUFNLE1BQU0sWUFBWSxHQUFHO0FBQzNCLFFBQUksT0FBTyxRQUFRO0FBQ2YsYUFBTztBQUNYLFVBQU0sTUFBTSxLQUFLLE1BQU0sT0FBTyxLQUFLLENBQUM7QUFDcEMsV0FBTyxJQUFJLFNBQVM7QUFBQSxFQUN4QjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQVNBLElBQUksS0FBSyxZQUFZO0FBQ2pCLFVBQU0sTUFBTSxZQUFZLEdBQUc7QUFDM0IsUUFBSSxPQUFPLFFBQVE7QUFDZixhQUFPO0FBQ1gsVUFBTSxLQUFLLEtBQUssTUFBTSxHQUFHO0FBQ3pCLFdBQU8sQ0FBQyxjQUFjLFNBQVMsRUFBRSxJQUFJLEdBQUcsUUFBUTtBQUFBLEVBQ3BEO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFPQSxJQUFJLEtBQUs7QUFDTCxVQUFNLE1BQU0sWUFBWSxHQUFHO0FBQzNCLFdBQU8sT0FBTyxRQUFRLFlBQVksTUFBTSxLQUFLLE1BQU07QUFBQSxFQUN2RDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFRQSxJQUFJLEtBQUssT0FBTztBQUNaLFVBQU0sTUFBTSxZQUFZLEdBQUc7QUFDM0IsUUFBSSxPQUFPLFFBQVE7QUFDZixZQUFNLElBQUksTUFBTSwrQkFBK0IsTUFBTTtBQUN6RCxVQUFNLE9BQU8sS0FBSyxNQUFNLEdBQUc7QUFDM0IsUUFBSSxTQUFTLElBQUksS0FBSyxjQUFjLEtBQUs7QUFDckMsV0FBSyxRQUFRO0FBQUE7QUFFYixXQUFLLE1BQU0sR0FBRyxJQUFJO0FBQUEsRUFDMUI7QUFBQSxFQUNBLE9BQU8sR0FBRyxLQUFLO0FBQ1gsVUFBTUMsT0FBTSxDQUFDO0FBQ2IsUUFBSSxPQUFPLElBQUk7QUFDWCxVQUFJLFNBQVNBLElBQUc7QUFDcEIsUUFBSSxJQUFJO0FBQ1IsZUFBVyxRQUFRLEtBQUs7QUFDcEIsTUFBQUEsS0FBSSxLQUFLLEtBQUssTUFBTSxPQUFPLEdBQUcsR0FBRyxHQUFHLENBQUM7QUFDekMsV0FBT0E7QUFBQSxFQUNYO0FBQUEsRUFDQSxTQUFTLEtBQUssV0FBVyxhQUFhO0FBQ2xDLFFBQUksQ0FBQztBQUNELGFBQU8sS0FBSyxVQUFVLElBQUk7QUFDOUIsV0FBTyxvQkFBb0IsTUFBTSxLQUFLO0FBQUEsTUFDbEMsaUJBQWlCO0FBQUEsTUFDakIsV0FBVyxFQUFFLE9BQU8sS0FBSyxLQUFLLElBQUk7QUFBQSxNQUNsQyxhQUFhLElBQUksVUFBVSxNQUFNO0FBQUEsTUFDakM7QUFBQSxNQUNBO0FBQUEsSUFDSixDQUFDO0FBQUEsRUFDTDtBQUNKO0FBQ0EsU0FBUyxZQUFZLEtBQUs7QUFDdEIsTUFBSSxNQUFNLFNBQVMsR0FBRyxJQUFJLElBQUksUUFBUTtBQUN0QyxNQUFJLE9BQU8sT0FBTyxRQUFRO0FBQ3RCLFVBQU0sT0FBTyxHQUFHO0FBQ3BCLFNBQU8sT0FBTyxRQUFRLFlBQVksT0FBTyxVQUFVLEdBQUcsS0FBSyxPQUFPLElBQzVELE1BQ0E7QUFDVjs7O0FDbEdBLFNBQVMsVUFBVUMsU0FBUSxLQUFLLEtBQUs7QUFDakMsUUFBTSxFQUFFLFNBQVMsSUFBSTtBQUNyQixRQUFNQyxPQUFNLElBQUksUUFBUUQsT0FBTTtBQUM5QixNQUFJLE9BQU8sT0FBTyxZQUFZLE9BQU8sR0FBRyxHQUFHO0FBQ3ZDLFFBQUksSUFBSTtBQUNSLGFBQVMsTUFBTSxLQUFLO0FBQ2hCLFVBQUksT0FBTyxhQUFhLFlBQVk7QUFDaEMsY0FBTSxNQUFNLGVBQWUsTUFBTSxLQUFLLE9BQU8sR0FBRztBQUNoRCxhQUFLLFNBQVMsS0FBSyxLQUFLLEtBQUssRUFBRTtBQUFBLE1BQ25DO0FBQ0EsTUFBQUMsS0FBSSxNQUFNLEtBQUssV0FBVyxJQUFJLFFBQVcsR0FBRyxDQUFDO0FBQUEsSUFDakQ7QUFBQSxFQUNKO0FBQ0EsU0FBT0E7QUFDWDtBQUNBLElBQU0sTUFBTTtBQUFBLEVBQ1IsWUFBWTtBQUFBLEVBQ1osWUFBWTtBQUFBLEVBQ1osU0FBUztBQUFBLEVBQ1QsV0FBVztBQUFBLEVBQ1gsS0FBSztBQUFBLEVBQ0wsUUFBUUEsTUFBSyxTQUFTO0FBQ2xCLFFBQUksQ0FBQyxNQUFNQSxJQUFHO0FBQ1YsY0FBUSxrQ0FBa0M7QUFDOUMsV0FBT0E7QUFBQSxFQUNYO0FBQ0o7OztBQzVCQSxJQUFNLFNBQVM7QUFBQSxFQUNYLFVBQVUsV0FBUyxPQUFPLFVBQVU7QUFBQSxFQUNwQyxTQUFTO0FBQUEsRUFDVCxLQUFLO0FBQUEsRUFDTCxTQUFTLFNBQU87QUFBQSxFQUNoQixVQUFVLE1BQU0sS0FBSyxXQUFXLGFBQWE7QUFDekMsVUFBTSxPQUFPLE9BQU8sRUFBRSxjQUFjLEtBQUssR0FBRyxHQUFHO0FBQy9DLFdBQU8sZ0JBQWdCLE1BQU0sS0FBSyxXQUFXLFdBQVc7QUFBQSxFQUM1RDtBQUNKOzs7QUNUQSxJQUFNLFVBQVU7QUFBQSxFQUNaLFVBQVUsV0FBUyxTQUFTO0FBQUEsRUFDNUIsWUFBWSxNQUFNLElBQUksT0FBTyxJQUFJO0FBQUEsRUFDakMsU0FBUztBQUFBLEVBQ1QsS0FBSztBQUFBLEVBQ0wsTUFBTTtBQUFBLEVBQ04sU0FBUyxNQUFNLElBQUksT0FBTyxJQUFJO0FBQUEsRUFDOUIsV0FBVyxDQUFDLEVBQUUsT0FBTyxHQUFHLFFBQVEsVUFBVSxRQUFRLEtBQUssS0FBSyxNQUFNLElBQUksU0FBUyxJQUFJLFFBQVE7QUFDL0Y7OztBQ1JBLElBQU0sVUFBVTtBQUFBLEVBQ1osVUFBVSxXQUFTLE9BQU8sVUFBVTtBQUFBLEVBQ3BDLFNBQVM7QUFBQSxFQUNULEtBQUs7QUFBQSxFQUNMLE1BQU07QUFBQSxFQUNOLFNBQVMsU0FBTyxJQUFJLE9BQU8sSUFBSSxDQUFDLE1BQU0sT0FBTyxJQUFJLENBQUMsTUFBTSxHQUFHO0FBQUEsRUFDM0QsVUFBVSxFQUFFLFFBQVEsTUFBTSxHQUFHLEtBQUs7QUFDOUIsUUFBSSxVQUFVLFFBQVEsS0FBSyxLQUFLLE1BQU0sR0FBRztBQUNyQyxZQUFNLEtBQUssT0FBTyxDQUFDLE1BQU0sT0FBTyxPQUFPLENBQUMsTUFBTTtBQUM5QyxVQUFJLFVBQVU7QUFDVixlQUFPO0FBQUEsSUFDZjtBQUNBLFdBQU8sUUFBUSxJQUFJLFFBQVEsVUFBVSxJQUFJLFFBQVE7QUFBQSxFQUNyRDtBQUNKOzs7QUNoQkEsU0FBUyxnQkFBZ0IsRUFBRSxRQUFRLG1CQUFtQixLQUFBQyxNQUFLLE1BQU0sR0FBRztBQUNoRSxNQUFJLE9BQU8sVUFBVTtBQUNqQixXQUFPLE9BQU8sS0FBSztBQUN2QixRQUFNLE1BQU0sT0FBTyxVQUFVLFdBQVcsUUFBUSxPQUFPLEtBQUs7QUFDNUQsTUFBSSxDQUFDLFNBQVMsR0FBRztBQUNiLFdBQU8sTUFBTSxHQUFHLElBQUksU0FBUyxNQUFNLElBQUksVUFBVTtBQUNyRCxNQUFJLElBQUksS0FBSyxVQUFVLEtBQUs7QUFDNUIsTUFBSSxDQUFDLFVBQ0Qsc0JBQ0MsQ0FBQ0EsUUFBT0EsU0FBUSw4QkFDakIsTUFBTSxLQUFLLENBQUMsR0FBRztBQUNmLFFBQUksSUFBSSxFQUFFLFFBQVEsR0FBRztBQUNyQixRQUFJLElBQUksR0FBRztBQUNQLFVBQUksRUFBRTtBQUNOLFdBQUs7QUFBQSxJQUNUO0FBQ0EsUUFBSSxJQUFJLHFCQUFxQixFQUFFLFNBQVMsSUFBSTtBQUM1QyxXQUFPLE1BQU07QUFDVCxXQUFLO0FBQUEsRUFDYjtBQUNBLFNBQU87QUFDWDs7O0FDbEJBLElBQU0sV0FBVztBQUFBLEVBQ2IsVUFBVSxXQUFTLE9BQU8sVUFBVTtBQUFBLEVBQ3BDLFNBQVM7QUFBQSxFQUNULEtBQUs7QUFBQSxFQUNMLE1BQU07QUFBQSxFQUNOLFNBQVMsU0FBTyxJQUFJLE1BQU0sRUFBRSxFQUFFLFlBQVksTUFBTSxRQUMxQyxNQUNBLElBQUksQ0FBQyxNQUFNLE1BQ1AsT0FBTyxvQkFDUCxPQUFPO0FBQUEsRUFDakIsV0FBVztBQUNmO0FBQ0EsSUFBTSxXQUFXO0FBQUEsRUFDYixVQUFVLFdBQVMsT0FBTyxVQUFVO0FBQUEsRUFDcEMsU0FBUztBQUFBLEVBQ1QsS0FBSztBQUFBLEVBQ0wsUUFBUTtBQUFBLEVBQ1IsTUFBTTtBQUFBLEVBQ04sU0FBUyxTQUFPLFdBQVcsR0FBRztBQUFBLEVBQzlCLFVBQVUsTUFBTTtBQUNaLFVBQU0sTUFBTSxPQUFPLEtBQUssS0FBSztBQUM3QixXQUFPLFNBQVMsR0FBRyxJQUFJLElBQUksY0FBYyxJQUFJLGdCQUFnQixJQUFJO0FBQUEsRUFDckU7QUFDSjtBQUNBLElBQU0sUUFBUTtBQUFBLEVBQ1YsVUFBVSxXQUFTLE9BQU8sVUFBVTtBQUFBLEVBQ3BDLFNBQVM7QUFBQSxFQUNULEtBQUs7QUFBQSxFQUNMLE1BQU07QUFBQSxFQUNOLFFBQVEsS0FBSztBQUNULFVBQU0sT0FBTyxJQUFJLE9BQU8sV0FBVyxHQUFHLENBQUM7QUFDdkMsVUFBTSxNQUFNLElBQUksUUFBUSxHQUFHO0FBQzNCLFFBQUksUUFBUSxNQUFNLElBQUksSUFBSSxTQUFTLENBQUMsTUFBTTtBQUN0QyxXQUFLLG9CQUFvQixJQUFJLFNBQVMsTUFBTTtBQUNoRCxXQUFPO0FBQUEsRUFDWDtBQUFBLEVBQ0EsV0FBVztBQUNmOzs7QUN0Q0EsSUFBTSxjQUFjLENBQUMsVUFBVSxPQUFPLFVBQVUsWUFBWSxPQUFPLFVBQVUsS0FBSztBQUNsRixJQUFNLGFBQWEsQ0FBQyxLQUFLLFFBQVEsT0FBTyxFQUFFLFlBQVksTUFBTyxjQUFjLE9BQU8sR0FBRyxJQUFJLFNBQVMsSUFBSSxVQUFVLE1BQU0sR0FBRyxLQUFLO0FBQzlILFNBQVMsYUFBYSxNQUFNLE9BQU8sUUFBUTtBQUN2QyxRQUFNLEVBQUUsTUFBTSxJQUFJO0FBQ2xCLE1BQUksWUFBWSxLQUFLLEtBQUssU0FBUztBQUMvQixXQUFPLFNBQVMsTUFBTSxTQUFTLEtBQUs7QUFDeEMsU0FBTyxnQkFBZ0IsSUFBSTtBQUMvQjtBQUNBLElBQU0sU0FBUztBQUFBLEVBQ1gsVUFBVSxXQUFTLFlBQVksS0FBSyxLQUFLLFNBQVM7QUFBQSxFQUNsRCxTQUFTO0FBQUEsRUFDVCxLQUFLO0FBQUEsRUFDTCxRQUFRO0FBQUEsRUFDUixNQUFNO0FBQUEsRUFDTixTQUFTLENBQUMsS0FBSyxVQUFVLFFBQVEsV0FBVyxLQUFLLEdBQUcsR0FBRyxHQUFHO0FBQUEsRUFDMUQsV0FBVyxVQUFRLGFBQWEsTUFBTSxHQUFHLElBQUk7QUFDakQ7QUFDQSxJQUFNLE1BQU07QUFBQSxFQUNSLFVBQVU7QUFBQSxFQUNWLFNBQVM7QUFBQSxFQUNULEtBQUs7QUFBQSxFQUNMLE1BQU07QUFBQSxFQUNOLFNBQVMsQ0FBQyxLQUFLLFVBQVUsUUFBUSxXQUFXLEtBQUssR0FBRyxJQUFJLEdBQUc7QUFBQSxFQUMzRCxXQUFXO0FBQ2Y7QUFDQSxJQUFNLFNBQVM7QUFBQSxFQUNYLFVBQVUsV0FBUyxZQUFZLEtBQUssS0FBSyxTQUFTO0FBQUEsRUFDbEQsU0FBUztBQUFBLEVBQ1QsS0FBSztBQUFBLEVBQ0wsUUFBUTtBQUFBLEVBQ1IsTUFBTTtBQUFBLEVBQ04sU0FBUyxDQUFDLEtBQUssVUFBVSxRQUFRLFdBQVcsS0FBSyxHQUFHLElBQUksR0FBRztBQUFBLEVBQzNELFdBQVcsVUFBUSxhQUFhLE1BQU0sSUFBSSxJQUFJO0FBQ2xEOzs7QUMzQkEsSUFBTSxTQUFTO0FBQUEsRUFDWDtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFDSjs7O0FDaEJBLFNBQVNDLGFBQVksT0FBTztBQUN4QixTQUFPLE9BQU8sVUFBVSxZQUFZLE9BQU8sVUFBVSxLQUFLO0FBQzlEO0FBQ0EsSUFBTSxnQkFBZ0IsQ0FBQyxFQUFFLE1BQU0sTUFBTSxLQUFLLFVBQVUsS0FBSztBQUN6RCxJQUFNLGNBQWM7QUFBQSxFQUNoQjtBQUFBLElBQ0ksVUFBVSxXQUFTLE9BQU8sVUFBVTtBQUFBLElBQ3BDLFNBQVM7QUFBQSxJQUNULEtBQUs7QUFBQSxJQUNMLFNBQVMsU0FBTztBQUFBLElBQ2hCLFdBQVc7QUFBQSxFQUNmO0FBQUEsRUFDQTtBQUFBLElBQ0ksVUFBVSxXQUFTLFNBQVM7QUFBQSxJQUM1QixZQUFZLE1BQU0sSUFBSSxPQUFPLElBQUk7QUFBQSxJQUNqQyxTQUFTO0FBQUEsSUFDVCxLQUFLO0FBQUEsSUFDTCxNQUFNO0FBQUEsSUFDTixTQUFTLE1BQU07QUFBQSxJQUNmLFdBQVc7QUFBQSxFQUNmO0FBQUEsRUFDQTtBQUFBLElBQ0ksVUFBVSxXQUFTLE9BQU8sVUFBVTtBQUFBLElBQ3BDLFNBQVM7QUFBQSxJQUNULEtBQUs7QUFBQSxJQUNMLE1BQU07QUFBQSxJQUNOLFNBQVMsU0FBTyxRQUFRO0FBQUEsSUFDeEIsV0FBVztBQUFBLEVBQ2Y7QUFBQSxFQUNBO0FBQUEsSUFDSSxVQUFVQTtBQUFBLElBQ1YsU0FBUztBQUFBLElBQ1QsS0FBSztBQUFBLElBQ0wsTUFBTTtBQUFBLElBQ04sU0FBUyxDQUFDLEtBQUssVUFBVSxFQUFFLFlBQVksTUFBTSxjQUFjLE9BQU8sR0FBRyxJQUFJLFNBQVMsS0FBSyxFQUFFO0FBQUEsSUFDekYsV0FBVyxDQUFDLEVBQUUsTUFBTSxNQUFNQSxhQUFZLEtBQUssSUFBSSxNQUFNLFNBQVMsSUFBSSxLQUFLLFVBQVUsS0FBSztBQUFBLEVBQzFGO0FBQUEsRUFDQTtBQUFBLElBQ0ksVUFBVSxXQUFTLE9BQU8sVUFBVTtBQUFBLElBQ3BDLFNBQVM7QUFBQSxJQUNULEtBQUs7QUFBQSxJQUNMLE1BQU07QUFBQSxJQUNOLFNBQVMsU0FBTyxXQUFXLEdBQUc7QUFBQSxJQUM5QixXQUFXO0FBQUEsRUFDZjtBQUNKO0FBQ0EsSUFBTSxZQUFZO0FBQUEsRUFDZCxTQUFTO0FBQUEsRUFDVCxLQUFLO0FBQUEsRUFDTCxNQUFNO0FBQUEsRUFDTixRQUFRLEtBQUssU0FBUztBQUNsQixZQUFRLDJCQUEyQixLQUFLLFVBQVUsR0FBRyxHQUFHO0FBQ3hELFdBQU87QUFBQSxFQUNYO0FBQ0o7QUFDQSxJQUFNQyxVQUFTLENBQUMsS0FBSyxHQUFHLEVBQUUsT0FBTyxhQUFhLFNBQVM7OztBQ3hEdkQsSUFBTSxTQUFTO0FBQUEsRUFDWCxVQUFVLFdBQVMsaUJBQWlCO0FBQUEsRUFDcEMsU0FBUztBQUFBLEVBQ1QsS0FBSztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQVNMLFFBQVEsS0FBSyxTQUFTO0FBQ2xCLFFBQUksT0FBTyxXQUFXLFlBQVk7QUFDOUIsYUFBTyxPQUFPLEtBQUssS0FBSyxRQUFRO0FBQUEsSUFDcEMsV0FDUyxPQUFPLFNBQVMsWUFBWTtBQUVqQyxZQUFNLE1BQU0sS0FBSyxJQUFJLFFBQVEsV0FBVyxFQUFFLENBQUM7QUFDM0MsWUFBTSxTQUFTLElBQUksV0FBVyxJQUFJLE1BQU07QUFDeEMsZUFBUyxJQUFJLEdBQUcsSUFBSSxJQUFJLFFBQVEsRUFBRTtBQUM5QixlQUFPLENBQUMsSUFBSSxJQUFJLFdBQVcsQ0FBQztBQUNoQyxhQUFPO0FBQUEsSUFDWCxPQUNLO0FBQ0QsY0FBUSwwRkFBMEY7QUFDbEcsYUFBTztBQUFBLElBQ1g7QUFBQSxFQUNKO0FBQUEsRUFDQSxVQUFVLEVBQUUsU0FBUyxNQUFNLE1BQU0sR0FBRyxLQUFLLFdBQVcsYUFBYTtBQUM3RCxVQUFNLE1BQU07QUFDWixRQUFJO0FBQ0osUUFBSSxPQUFPLFdBQVcsWUFBWTtBQUM5QixZQUNJLGVBQWUsU0FDVCxJQUFJLFNBQVMsUUFBUSxJQUNyQixPQUFPLEtBQUssSUFBSSxNQUFNLEVBQUUsU0FBUyxRQUFRO0FBQUEsSUFDdkQsV0FDUyxPQUFPLFNBQVMsWUFBWTtBQUNqQyxVQUFJLElBQUk7QUFDUixlQUFTLElBQUksR0FBRyxJQUFJLElBQUksUUFBUSxFQUFFO0FBQzlCLGFBQUssT0FBTyxhQUFhLElBQUksQ0FBQyxDQUFDO0FBQ25DLFlBQU0sS0FBSyxDQUFDO0FBQUEsSUFDaEIsT0FDSztBQUNELFlBQU0sSUFBSSxNQUFNLDBGQUEwRjtBQUFBLElBQzlHO0FBQ0EsUUFBSSxDQUFDO0FBQ0QsYUFBTyxPQUFPO0FBQ2xCLFFBQUksU0FBUyxPQUFPLGNBQWM7QUFDOUIsWUFBTSxZQUFZLEtBQUssSUFBSSxJQUFJLFFBQVEsWUFBWSxJQUFJLE9BQU8sUUFBUSxJQUFJLFFBQVEsZUFBZTtBQUNqRyxZQUFNLElBQUksS0FBSyxLQUFLLElBQUksU0FBUyxTQUFTO0FBQzFDLFlBQU0sUUFBUSxJQUFJLE1BQU0sQ0FBQztBQUN6QixlQUFTLElBQUksR0FBRyxJQUFJLEdBQUcsSUFBSSxHQUFHLEVBQUUsR0FBRyxLQUFLLFdBQVc7QUFDL0MsY0FBTSxDQUFDLElBQUksSUFBSSxPQUFPLEdBQUcsU0FBUztBQUFBLE1BQ3RDO0FBQ0EsWUFBTSxNQUFNLEtBQUssU0FBUyxPQUFPLGdCQUFnQixPQUFPLEdBQUc7QUFBQSxJQUMvRDtBQUNBLFdBQU8sZ0JBQWdCLEVBQUUsU0FBUyxNQUFNLE9BQU8sSUFBSSxHQUFHLEtBQUssV0FBVyxXQUFXO0FBQUEsRUFDckY7QUFDSjs7O0FDMURBLFNBQVMsYUFBYUMsTUFBSyxTQUFTO0FBQ2hDLE1BQUksTUFBTUEsSUFBRyxHQUFHO0FBQ1osYUFBUyxJQUFJLEdBQUcsSUFBSUEsS0FBSSxNQUFNLFFBQVEsRUFBRSxHQUFHO0FBQ3ZDLFVBQUksT0FBT0EsS0FBSSxNQUFNLENBQUM7QUFDdEIsVUFBSSxPQUFPLElBQUk7QUFDWDtBQUFBLGVBQ0ssTUFBTSxJQUFJLEdBQUc7QUFDbEIsWUFBSSxLQUFLLE1BQU0sU0FBUztBQUNwQixrQkFBUSxnREFBZ0Q7QUFDNUQsY0FBTSxPQUFPLEtBQUssTUFBTSxDQUFDLEtBQUssSUFBSSxLQUFLLElBQUksT0FBTyxJQUFJLENBQUM7QUFDdkQsWUFBSSxLQUFLO0FBQ0wsZUFBSyxJQUFJLGdCQUFnQixLQUFLLElBQUksZ0JBQzVCLEdBQUcsS0FBSztBQUFBLEVBQWtCLEtBQUssSUFBSSxrQkFDbkMsS0FBSztBQUNmLFlBQUksS0FBSyxTQUFTO0FBQ2QsZ0JBQU0sS0FBSyxLQUFLLFNBQVMsS0FBSztBQUM5QixhQUFHLFVBQVUsR0FBRyxVQUNWLEdBQUcsS0FBSztBQUFBLEVBQVksR0FBRyxZQUN2QixLQUFLO0FBQUEsUUFDZjtBQUNBLGVBQU87QUFBQSxNQUNYO0FBQ0EsTUFBQUEsS0FBSSxNQUFNLENBQUMsSUFBSSxPQUFPLElBQUksSUFBSSxPQUFPLElBQUksS0FBSyxJQUFJO0FBQUEsSUFDdEQ7QUFBQSxFQUNKO0FBRUksWUFBUSxrQ0FBa0M7QUFDOUMsU0FBT0E7QUFDWDtBQUNBLFNBQVMsWUFBWUMsU0FBUSxVQUFVLEtBQUs7QUFDeEMsUUFBTSxFQUFFLFNBQVMsSUFBSTtBQUNyQixRQUFNQyxTQUFRLElBQUksUUFBUUQsT0FBTTtBQUNoQyxFQUFBQyxPQUFNLE1BQU07QUFDWixNQUFJLElBQUk7QUFDUixNQUFJLFlBQVksT0FBTyxZQUFZLE9BQU8sUUFBUTtBQUM5QyxhQUFTLE1BQU0sVUFBVTtBQUNyQixVQUFJLE9BQU8sYUFBYTtBQUNwQixhQUFLLFNBQVMsS0FBSyxVQUFVLE9BQU8sR0FBRyxHQUFHLEVBQUU7QUFDaEQsVUFBSSxLQUFLO0FBQ1QsVUFBSSxNQUFNLFFBQVEsRUFBRSxHQUFHO0FBQ25CLFlBQUksR0FBRyxXQUFXLEdBQUc7QUFDakIsZ0JBQU0sR0FBRyxDQUFDO0FBQ1Ysa0JBQVEsR0FBRyxDQUFDO0FBQUEsUUFDaEI7QUFFSSxnQkFBTSxJQUFJLFVBQVUsZ0NBQWdDLElBQUk7QUFBQSxNQUNoRSxXQUNTLE1BQU0sY0FBYyxRQUFRO0FBQ2pDLGNBQU0sT0FBTyxPQUFPLEtBQUssRUFBRTtBQUMzQixZQUFJLEtBQUssV0FBVyxHQUFHO0FBQ25CLGdCQUFNLEtBQUssQ0FBQztBQUNaLGtCQUFRLEdBQUcsR0FBRztBQUFBLFFBQ2xCO0FBRUksZ0JBQU0sSUFBSSxVQUFVLGtDQUFrQyxJQUFJO0FBQUEsTUFDbEUsT0FDSztBQUNELGNBQU07QUFBQSxNQUNWO0FBQ0EsTUFBQUEsT0FBTSxNQUFNLEtBQUssV0FBVyxLQUFLLE9BQU8sR0FBRyxDQUFDO0FBQUEsSUFDaEQ7QUFDSixTQUFPQTtBQUNYO0FBQ0EsSUFBTSxRQUFRO0FBQUEsRUFDVixZQUFZO0FBQUEsRUFDWixTQUFTO0FBQUEsRUFDVCxLQUFLO0FBQUEsRUFDTCxTQUFTO0FBQUEsRUFDVCxZQUFZO0FBQ2hCOzs7QUNwRUEsSUFBTSxXQUFOLGNBQXVCLFFBQVE7QUFBQSxFQUMzQixjQUFjO0FBQ1YsVUFBTTtBQUNOLFNBQUssTUFBTSxRQUFRLFVBQVUsSUFBSSxLQUFLLElBQUk7QUFDMUMsU0FBSyxTQUFTLFFBQVEsVUFBVSxPQUFPLEtBQUssSUFBSTtBQUNoRCxTQUFLLE1BQU0sUUFBUSxVQUFVLElBQUksS0FBSyxJQUFJO0FBQzFDLFNBQUssTUFBTSxRQUFRLFVBQVUsSUFBSSxLQUFLLElBQUk7QUFDMUMsU0FBSyxNQUFNLFFBQVEsVUFBVSxJQUFJLEtBQUssSUFBSTtBQUMxQyxTQUFLLE1BQU0sU0FBUztBQUFBLEVBQ3hCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQUtBLE9BQU8sR0FBRyxLQUFLO0FBQ1gsUUFBSSxDQUFDO0FBQ0QsYUFBTyxNQUFNLE9BQU8sQ0FBQztBQUN6QixVQUFNQyxPQUFNLG9CQUFJLElBQUk7QUFDcEIsUUFBSSxPQUFPLElBQUk7QUFDWCxVQUFJLFNBQVNBLElBQUc7QUFDcEIsZUFBVyxRQUFRLEtBQUssT0FBTztBQUMzQixVQUFJLEtBQUs7QUFDVCxVQUFJLE9BQU8sSUFBSSxHQUFHO0FBQ2QsY0FBTSxLQUFLLEtBQUssS0FBSyxJQUFJLEdBQUc7QUFDNUIsZ0JBQVEsS0FBSyxLQUFLLE9BQU8sS0FBSyxHQUFHO0FBQUEsTUFDckMsT0FDSztBQUNELGNBQU0sS0FBSyxNQUFNLElBQUksR0FBRztBQUFBLE1BQzVCO0FBQ0EsVUFBSUEsS0FBSSxJQUFJLEdBQUc7QUFDWCxjQUFNLElBQUksTUFBTSw4Q0FBOEM7QUFDbEUsTUFBQUEsS0FBSSxJQUFJLEtBQUssS0FBSztBQUFBLElBQ3RCO0FBQ0EsV0FBT0E7QUFBQSxFQUNYO0FBQ0o7QUFDQSxTQUFTLE1BQU07QUFDZixJQUFNLE9BQU87QUFBQSxFQUNULFlBQVk7QUFBQSxFQUNaLFVBQVUsV0FBUyxpQkFBaUI7QUFBQSxFQUNwQyxXQUFXO0FBQUEsRUFDWCxTQUFTO0FBQUEsRUFDVCxLQUFLO0FBQUEsRUFDTCxRQUFRQyxNQUFLLFNBQVM7QUFDbEIsVUFBTUMsU0FBUSxhQUFhRCxNQUFLLE9BQU87QUFDdkMsVUFBTSxXQUFXLENBQUM7QUFDbEIsZUFBVyxFQUFFLElBQUksS0FBS0MsT0FBTSxPQUFPO0FBQy9CLFVBQUksU0FBUyxHQUFHLEdBQUc7QUFDZixZQUFJLFNBQVMsU0FBUyxJQUFJLEtBQUssR0FBRztBQUM5QixrQkFBUSxpREFBaUQsSUFBSSxPQUFPO0FBQUEsUUFDeEUsT0FDSztBQUNELG1CQUFTLEtBQUssSUFBSSxLQUFLO0FBQUEsUUFDM0I7QUFBQSxNQUNKO0FBQUEsSUFDSjtBQUNBLFdBQU8sT0FBTyxPQUFPLElBQUksU0FBUyxHQUFHQSxNQUFLO0FBQUEsRUFDOUM7QUFBQSxFQUNBLFdBQVdDLFNBQVEsVUFBVSxLQUFLO0FBQzlCLFVBQU1ELFNBQVEsWUFBWUMsU0FBUSxVQUFVLEdBQUc7QUFDL0MsVUFBTUMsUUFBTyxJQUFJLFNBQVM7QUFDMUIsSUFBQUEsTUFBSyxRQUFRRixPQUFNO0FBQ25CLFdBQU9FO0FBQUEsRUFDWDtBQUNKOzs7QUNwRUEsU0FBUyxjQUFjLEVBQUUsT0FBTyxPQUFPLEdBQUcsS0FBSztBQUMzQyxRQUFNLFVBQVUsUUFBUSxVQUFVO0FBQ2xDLE1BQUksVUFBVSxRQUFRLEtBQUssS0FBSyxNQUFNO0FBQ2xDLFdBQU87QUFDWCxTQUFPLFFBQVEsSUFBSSxRQUFRLFVBQVUsSUFBSSxRQUFRO0FBQ3JEO0FBQ0EsSUFBTSxVQUFVO0FBQUEsRUFDWixVQUFVLFdBQVMsVUFBVTtBQUFBLEVBQzdCLFNBQVM7QUFBQSxFQUNULEtBQUs7QUFBQSxFQUNMLE1BQU07QUFBQSxFQUNOLFNBQVMsTUFBTSxJQUFJLE9BQU8sSUFBSTtBQUFBLEVBQzlCLFdBQVc7QUFDZjtBQUNBLElBQU0sV0FBVztBQUFBLEVBQ2IsVUFBVSxXQUFTLFVBQVU7QUFBQSxFQUM3QixTQUFTO0FBQUEsRUFDVCxLQUFLO0FBQUEsRUFDTCxNQUFNO0FBQUEsRUFDTixTQUFTLE1BQU0sSUFBSSxPQUFPLEtBQUs7QUFBQSxFQUMvQixXQUFXO0FBQ2Y7OztBQ3BCQSxJQUFNQyxZQUFXO0FBQUEsRUFDYixVQUFVLFdBQVMsT0FBTyxVQUFVO0FBQUEsRUFDcEMsU0FBUztBQUFBLEVBQ1QsS0FBSztBQUFBLEVBQ0wsTUFBTTtBQUFBLEVBQ04sU0FBUyxDQUFDLFFBQVEsSUFBSSxNQUFNLEVBQUUsRUFBRSxZQUFZLE1BQU0sUUFDNUMsTUFDQSxJQUFJLENBQUMsTUFBTSxNQUNQLE9BQU8sb0JBQ1AsT0FBTztBQUFBLEVBQ2pCLFdBQVc7QUFDZjtBQUNBLElBQU1DLFlBQVc7QUFBQSxFQUNiLFVBQVUsV0FBUyxPQUFPLFVBQVU7QUFBQSxFQUNwQyxTQUFTO0FBQUEsRUFDVCxLQUFLO0FBQUEsRUFDTCxRQUFRO0FBQUEsRUFDUixNQUFNO0FBQUEsRUFDTixTQUFTLENBQUMsUUFBUSxXQUFXLElBQUksUUFBUSxNQUFNLEVBQUUsQ0FBQztBQUFBLEVBQ2xELFVBQVUsTUFBTTtBQUNaLFVBQU0sTUFBTSxPQUFPLEtBQUssS0FBSztBQUM3QixXQUFPLFNBQVMsR0FBRyxJQUFJLElBQUksY0FBYyxJQUFJLGdCQUFnQixJQUFJO0FBQUEsRUFDckU7QUFDSjtBQUNBLElBQU1DLFNBQVE7QUFBQSxFQUNWLFVBQVUsV0FBUyxPQUFPLFVBQVU7QUFBQSxFQUNwQyxTQUFTO0FBQUEsRUFDVCxLQUFLO0FBQUEsRUFDTCxNQUFNO0FBQUEsRUFDTixRQUFRLEtBQUs7QUFDVCxVQUFNLE9BQU8sSUFBSSxPQUFPLFdBQVcsSUFBSSxRQUFRLE1BQU0sRUFBRSxDQUFDLENBQUM7QUFDekQsVUFBTSxNQUFNLElBQUksUUFBUSxHQUFHO0FBQzNCLFFBQUksUUFBUSxJQUFJO0FBQ1osWUFBTSxJQUFJLElBQUksVUFBVSxNQUFNLENBQUMsRUFBRSxRQUFRLE1BQU0sRUFBRTtBQUNqRCxVQUFJLEVBQUUsRUFBRSxTQUFTLENBQUMsTUFBTTtBQUNwQixhQUFLLG9CQUFvQixFQUFFO0FBQUEsSUFDbkM7QUFDQSxXQUFPO0FBQUEsRUFDWDtBQUFBLEVBQ0EsV0FBVztBQUNmOzs7QUN6Q0EsSUFBTUMsZUFBYyxDQUFDLFVBQVUsT0FBTyxVQUFVLFlBQVksT0FBTyxVQUFVLEtBQUs7QUFDbEYsU0FBU0MsWUFBVyxLQUFLLFFBQVEsT0FBTyxFQUFFLFlBQVksR0FBRztBQUNyRCxRQUFNLE9BQU8sSUFBSSxDQUFDO0FBQ2xCLE1BQUksU0FBUyxPQUFPLFNBQVM7QUFDekIsY0FBVTtBQUNkLFFBQU0sSUFBSSxVQUFVLE1BQU0sRUFBRSxRQUFRLE1BQU0sRUFBRTtBQUM1QyxNQUFJLGFBQWE7QUFDYixZQUFRLE9BQU87QUFBQSxNQUNYLEtBQUs7QUFDRCxjQUFNLEtBQUs7QUFDWDtBQUFBLE1BQ0osS0FBSztBQUNELGNBQU0sS0FBSztBQUNYO0FBQUEsTUFDSixLQUFLO0FBQ0QsY0FBTSxLQUFLO0FBQ1g7QUFBQSxJQUNSO0FBQ0EsVUFBTUMsS0FBSSxPQUFPLEdBQUc7QUFDcEIsV0FBTyxTQUFTLE1BQU0sT0FBTyxFQUFFLElBQUlBLEtBQUlBO0FBQUEsRUFDM0M7QUFDQSxRQUFNLElBQUksU0FBUyxLQUFLLEtBQUs7QUFDN0IsU0FBTyxTQUFTLE1BQU0sS0FBSyxJQUFJO0FBQ25DO0FBQ0EsU0FBU0MsY0FBYSxNQUFNLE9BQU8sUUFBUTtBQUN2QyxRQUFNLEVBQUUsTUFBTSxJQUFJO0FBQ2xCLE1BQUlILGFBQVksS0FBSyxHQUFHO0FBQ3BCLFVBQU0sTUFBTSxNQUFNLFNBQVMsS0FBSztBQUNoQyxXQUFPLFFBQVEsSUFBSSxNQUFNLFNBQVMsSUFBSSxPQUFPLENBQUMsSUFBSSxTQUFTO0FBQUEsRUFDL0Q7QUFDQSxTQUFPLGdCQUFnQixJQUFJO0FBQy9CO0FBQ0EsSUFBTSxTQUFTO0FBQUEsRUFDWCxVQUFVQTtBQUFBLEVBQ1YsU0FBUztBQUFBLEVBQ1QsS0FBSztBQUFBLEVBQ0wsUUFBUTtBQUFBLEVBQ1IsTUFBTTtBQUFBLEVBQ04sU0FBUyxDQUFDLEtBQUssVUFBVSxRQUFRQyxZQUFXLEtBQUssR0FBRyxHQUFHLEdBQUc7QUFBQSxFQUMxRCxXQUFXLFVBQVFFLGNBQWEsTUFBTSxHQUFHLElBQUk7QUFDakQ7QUFDQSxJQUFNQyxVQUFTO0FBQUEsRUFDWCxVQUFVSjtBQUFBLEVBQ1YsU0FBUztBQUFBLEVBQ1QsS0FBSztBQUFBLEVBQ0wsUUFBUTtBQUFBLEVBQ1IsTUFBTTtBQUFBLEVBQ04sU0FBUyxDQUFDLEtBQUssVUFBVSxRQUFRQyxZQUFXLEtBQUssR0FBRyxHQUFHLEdBQUc7QUFBQSxFQUMxRCxXQUFXLFVBQVFFLGNBQWEsTUFBTSxHQUFHLEdBQUc7QUFDaEQ7QUFDQSxJQUFNRSxPQUFNO0FBQUEsRUFDUixVQUFVTDtBQUFBLEVBQ1YsU0FBUztBQUFBLEVBQ1QsS0FBSztBQUFBLEVBQ0wsTUFBTTtBQUFBLEVBQ04sU0FBUyxDQUFDLEtBQUssVUFBVSxRQUFRQyxZQUFXLEtBQUssR0FBRyxJQUFJLEdBQUc7QUFBQSxFQUMzRCxXQUFXO0FBQ2Y7QUFDQSxJQUFNSyxVQUFTO0FBQUEsRUFDWCxVQUFVTjtBQUFBLEVBQ1YsU0FBUztBQUFBLEVBQ1QsS0FBSztBQUFBLEVBQ0wsUUFBUTtBQUFBLEVBQ1IsTUFBTTtBQUFBLEVBQ04sU0FBUyxDQUFDLEtBQUssVUFBVSxRQUFRQyxZQUFXLEtBQUssR0FBRyxJQUFJLEdBQUc7QUFBQSxFQUMzRCxXQUFXLFVBQVFFLGNBQWEsTUFBTSxJQUFJLElBQUk7QUFDbEQ7OztBQ2hFQSxJQUFNLFVBQU4sY0FBc0IsUUFBUTtBQUFBLEVBQzFCLFlBQVlJLFNBQVE7QUFDaEIsVUFBTUEsT0FBTTtBQUNaLFNBQUssTUFBTSxRQUFRO0FBQUEsRUFDdkI7QUFBQSxFQUNBLElBQUksS0FBSztBQUNMLFFBQUk7QUFDSixRQUFJLE9BQU8sR0FBRztBQUNWLGFBQU87QUFBQSxhQUNGLE9BQU8sUUFBUSxZQUNwQixTQUFTLE9BQ1QsV0FBVyxPQUNYLElBQUksVUFBVTtBQUNkLGFBQU8sSUFBSSxLQUFLLElBQUksS0FBSyxJQUFJO0FBQUE7QUFFN0IsYUFBTyxJQUFJLEtBQUssS0FBSyxJQUFJO0FBQzdCLFVBQU0sT0FBTyxTQUFTLEtBQUssT0FBTyxLQUFLLEdBQUc7QUFDMUMsUUFBSSxDQUFDO0FBQ0QsV0FBSyxNQUFNLEtBQUssSUFBSTtBQUFBLEVBQzVCO0FBQUEsRUFDQSxJQUFJLEtBQUssVUFBVTtBQUNmLFVBQU0sT0FBTyxTQUFTLEtBQUssT0FBTyxHQUFHO0FBQ3JDLFdBQU8sQ0FBQyxZQUFZLE9BQU8sSUFBSSxJQUN6QixTQUFTLEtBQUssR0FBRyxJQUNiLEtBQUssSUFBSSxRQUNULEtBQUssTUFDVDtBQUFBLEVBQ1Y7QUFBQSxFQUNBLElBQUksS0FBSyxPQUFPO0FBQ1osUUFBSSxPQUFPLFVBQVU7QUFDakIsWUFBTSxJQUFJLE1BQU0saUVBQWlFLE9BQU8sT0FBTztBQUNuRyxVQUFNLE9BQU8sU0FBUyxLQUFLLE9BQU8sR0FBRztBQUNyQyxRQUFJLFFBQVEsQ0FBQyxPQUFPO0FBQ2hCLFdBQUssTUFBTSxPQUFPLEtBQUssTUFBTSxRQUFRLElBQUksR0FBRyxDQUFDO0FBQUEsSUFDakQsV0FDUyxDQUFDLFFBQVEsT0FBTztBQUNyQixXQUFLLE1BQU0sS0FBSyxJQUFJLEtBQUssR0FBRyxDQUFDO0FBQUEsSUFDakM7QUFBQSxFQUNKO0FBQUEsRUFDQSxPQUFPLEdBQUcsS0FBSztBQUNYLFdBQU8sTUFBTSxPQUFPLEdBQUcsS0FBSyxHQUFHO0FBQUEsRUFDbkM7QUFBQSxFQUNBLFNBQVMsS0FBSyxXQUFXLGFBQWE7QUFDbEMsUUFBSSxDQUFDO0FBQ0QsYUFBTyxLQUFLLFVBQVUsSUFBSTtBQUM5QixRQUFJLEtBQUssaUJBQWlCLElBQUk7QUFDMUIsYUFBTyxNQUFNLFNBQVMsT0FBTyxPQUFPLENBQUMsR0FBRyxLQUFLLEVBQUUsZUFBZSxLQUFLLENBQUMsR0FBRyxXQUFXLFdBQVc7QUFBQTtBQUU3RixZQUFNLElBQUksTUFBTSxxQ0FBcUM7QUFBQSxFQUM3RDtBQUNKO0FBQ0EsUUFBUSxNQUFNO0FBQ2QsSUFBTSxNQUFNO0FBQUEsRUFDUixZQUFZO0FBQUEsRUFDWixVQUFVLFdBQVMsaUJBQWlCO0FBQUEsRUFDcEMsV0FBVztBQUFBLEVBQ1gsU0FBUztBQUFBLEVBQ1QsS0FBSztBQUFBLEVBQ0wsUUFBUUMsTUFBSyxTQUFTO0FBQ2xCLFFBQUksTUFBTUEsSUFBRyxHQUFHO0FBQ1osVUFBSUEsS0FBSSxpQkFBaUIsSUFBSTtBQUN6QixlQUFPLE9BQU8sT0FBTyxJQUFJLFFBQVEsR0FBR0EsSUFBRztBQUFBO0FBRXZDLGdCQUFRLHFDQUFxQztBQUFBLElBQ3JEO0FBRUksY0FBUSxpQ0FBaUM7QUFDN0MsV0FBT0E7QUFBQSxFQUNYO0FBQUEsRUFDQSxXQUFXRCxTQUFRLFVBQVUsS0FBSztBQUM5QixVQUFNLEVBQUUsU0FBUyxJQUFJO0FBQ3JCLFVBQU1FLE9BQU0sSUFBSSxRQUFRRixPQUFNO0FBQzlCLFFBQUksWUFBWSxPQUFPLFlBQVksT0FBTyxRQUFRO0FBQzlDLGVBQVMsU0FBUyxVQUFVO0FBQ3hCLFlBQUksT0FBTyxhQUFhO0FBQ3BCLGtCQUFRLFNBQVMsS0FBSyxVQUFVLE9BQU8sS0FBSztBQUNoRCxRQUFBRSxLQUFJLE1BQU0sS0FBSyxXQUFXLE9BQU8sTUFBTSxHQUFHLENBQUM7QUFBQSxNQUMvQztBQUNKLFdBQU9BO0FBQUEsRUFDWDtBQUNKOzs7QUNqRkEsU0FBUyxpQkFBaUIsS0FBSyxVQUFVO0FBQ3JDLFFBQU0sT0FBTyxJQUFJLENBQUM7QUFDbEIsUUFBTSxRQUFRLFNBQVMsT0FBTyxTQUFTLE1BQU0sSUFBSSxVQUFVLENBQUMsSUFBSTtBQUNoRSxRQUFNLE1BQU0sQ0FBQyxNQUFNLFdBQVcsT0FBTyxDQUFDLElBQUksT0FBTyxDQUFDO0FBQ2xELFFBQU0sTUFBTSxNQUNQLFFBQVEsTUFBTSxFQUFFLEVBQ2hCLE1BQU0sR0FBRyxFQUNULE9BQU8sQ0FBQ0MsTUFBSyxNQUFNQSxPQUFNLElBQUksRUFBRSxJQUFJLElBQUksQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDO0FBQ3RELFNBQVEsU0FBUyxNQUFNLElBQUksRUFBRSxJQUFJLE1BQU07QUFDM0M7QUFNQSxTQUFTLHFCQUFxQixNQUFNO0FBQ2hDLE1BQUksRUFBRSxNQUFNLElBQUk7QUFDaEIsTUFBSSxNQUFNLENBQUMsTUFBTTtBQUNqQixNQUFJLE9BQU8sVUFBVTtBQUNqQixVQUFNLE9BQUssT0FBTyxDQUFDO0FBQUEsV0FDZCxNQUFNLEtBQUssS0FBSyxDQUFDLFNBQVMsS0FBSztBQUNwQyxXQUFPLGdCQUFnQixJQUFJO0FBQy9CLE1BQUksT0FBTztBQUNYLE1BQUksUUFBUSxHQUFHO0FBQ1gsV0FBTztBQUNQLGFBQVMsSUFBSSxFQUFFO0FBQUEsRUFDbkI7QUFDQSxRQUFNLE1BQU0sSUFBSSxFQUFFO0FBQ2xCLFFBQU0sUUFBUSxDQUFDLFFBQVEsR0FBRztBQUMxQixNQUFJLFFBQVEsSUFBSTtBQUNaLFVBQU0sUUFBUSxDQUFDO0FBQUEsRUFDbkIsT0FDSztBQUNELGFBQVMsUUFBUSxNQUFNLENBQUMsS0FBSztBQUM3QixVQUFNLFFBQVEsUUFBUSxHQUFHO0FBQ3pCLFFBQUksU0FBUyxJQUFJO0FBQ2IsZUFBUyxRQUFRLE1BQU0sQ0FBQyxLQUFLO0FBQzdCLFlBQU0sUUFBUSxLQUFLO0FBQUEsSUFDdkI7QUFBQSxFQUNKO0FBQ0EsU0FBUSxPQUNKLE1BQ0ssSUFBSSxPQUFNLElBQUksS0FBSyxNQUFNLE9BQU8sQ0FBQyxJQUFJLE9BQU8sQ0FBQyxDQUFFLEVBQy9DLEtBQUssR0FBRyxFQUNSLFFBQVEsY0FBYyxFQUFFO0FBRXJDO0FBQ0EsSUFBTSxVQUFVO0FBQUEsRUFDWixVQUFVLFdBQVMsT0FBTyxVQUFVLFlBQVksT0FBTyxVQUFVLEtBQUs7QUFBQSxFQUN0RSxTQUFTO0FBQUEsRUFDVCxLQUFLO0FBQUEsRUFDTCxRQUFRO0FBQUEsRUFDUixNQUFNO0FBQUEsRUFDTixTQUFTLENBQUMsS0FBSyxVQUFVLEVBQUUsWUFBWSxNQUFNLGlCQUFpQixLQUFLLFdBQVc7QUFBQSxFQUM5RSxXQUFXO0FBQ2Y7QUFDQSxJQUFNLFlBQVk7QUFBQSxFQUNkLFVBQVUsV0FBUyxPQUFPLFVBQVU7QUFBQSxFQUNwQyxTQUFTO0FBQUEsRUFDVCxLQUFLO0FBQUEsRUFDTCxRQUFRO0FBQUEsRUFDUixNQUFNO0FBQUEsRUFDTixTQUFTLFNBQU8saUJBQWlCLEtBQUssS0FBSztBQUFBLEVBQzNDLFdBQVc7QUFDZjtBQUNBLElBQU0sWUFBWTtBQUFBLEVBQ2QsVUFBVSxXQUFTLGlCQUFpQjtBQUFBLEVBQ3BDLFNBQVM7QUFBQSxFQUNULEtBQUs7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQUlMLE1BQU0sT0FBTywySkFLSjtBQUFBLEVBQ1QsUUFBUSxLQUFLO0FBQ1QsVUFBTSxRQUFRLElBQUksTUFBTSxVQUFVLElBQUk7QUFDdEMsUUFBSSxDQUFDO0FBQ0QsWUFBTSxJQUFJLE1BQU0sc0RBQXNEO0FBQzFFLFVBQU0sQ0FBQyxFQUFFLE1BQU0sT0FBTyxLQUFLLE1BQU0sUUFBUSxNQUFNLElBQUksTUFBTSxJQUFJLE1BQU07QUFDbkUsVUFBTSxXQUFXLE1BQU0sQ0FBQyxJQUFJLFFBQVEsTUFBTSxDQUFDLElBQUksTUFBTSxPQUFPLEdBQUcsQ0FBQyxDQUFDLElBQUk7QUFDckUsUUFBSSxPQUFPLEtBQUssSUFBSSxNQUFNLFFBQVEsR0FBRyxLQUFLLFFBQVEsR0FBRyxVQUFVLEdBQUcsVUFBVSxHQUFHLFFBQVE7QUFDdkYsVUFBTSxLQUFLLE1BQU0sQ0FBQztBQUNsQixRQUFJLE1BQU0sT0FBTyxLQUFLO0FBQ2xCLFVBQUksSUFBSSxpQkFBaUIsSUFBSSxLQUFLO0FBQ2xDLFVBQUksS0FBSyxJQUFJLENBQUMsSUFBSTtBQUNkLGFBQUs7QUFDVCxjQUFRLE1BQVE7QUFBQSxJQUNwQjtBQUNBLFdBQU8sSUFBSSxLQUFLLElBQUk7QUFBQSxFQUN4QjtBQUFBLEVBQ0EsV0FBVyxDQUFDLEVBQUUsTUFBTSxNQUFNLE1BQU0sWUFBWSxFQUFFLFFBQVEsMEJBQTBCLEVBQUU7QUFDdEY7OztBQ3JGQSxJQUFNQyxVQUFTO0FBQUEsRUFDWDtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0FDO0FBQUEsRUFDQUM7QUFBQSxFQUNBQztBQUFBLEVBQ0FDO0FBQUEsRUFDQUM7QUFBQSxFQUNBQztBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFDSjs7O0FDbEJBLElBQU0sVUFBVSxvQkFBSSxJQUFJO0FBQUEsRUFDcEIsQ0FBQyxRQUFRLE1BQU07QUFBQSxFQUNmLENBQUMsWUFBWSxDQUFDLEtBQUssS0FBSyxNQUFNLENBQUM7QUFBQSxFQUMvQixDQUFDLFFBQVFDLE9BQVE7QUFBQSxFQUNqQixDQUFDLFVBQVVBLE9BQVE7QUFBQSxFQUNuQixDQUFDLFlBQVlBLE9BQVE7QUFDekIsQ0FBQztBQUNELElBQU0sYUFBYTtBQUFBLEVBQ2Y7QUFBQSxFQUNBLE1BQU07QUFBQSxFQUNOO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBLE1BQU07QUFBQSxFQUNOO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUNKO0FBQ0EsSUFBTSxnQkFBZ0I7QUFBQSxFQUNsQiw0QkFBNEI7QUFBQSxFQUM1QiwwQkFBMEI7QUFBQSxFQUMxQiwyQkFBMkI7QUFBQSxFQUMzQix5QkFBeUI7QUFBQSxFQUN6QiwrQkFBK0I7QUFDbkM7QUFDQSxTQUFTLFFBQVEsWUFBWSxZQUFZO0FBQ3JDLE1BQUksT0FBTyxRQUFRLElBQUksVUFBVTtBQUNqQyxNQUFJLENBQUMsTUFBTTtBQUNQLFFBQUksTUFBTSxRQUFRLFVBQVU7QUFDeEIsYUFBTyxDQUFDO0FBQUEsU0FDUDtBQUNELFlBQU0sT0FBTyxNQUFNLEtBQUssUUFBUSxLQUFLLENBQUMsRUFDakMsT0FBTyxTQUFPLFFBQVEsUUFBUSxFQUM5QixJQUFJLFNBQU8sS0FBSyxVQUFVLEdBQUcsQ0FBQyxFQUM5QixLQUFLLElBQUk7QUFDZCxZQUFNLElBQUksTUFBTSxtQkFBbUIsMkJBQTJCLGlDQUFpQztBQUFBLElBQ25HO0FBQUEsRUFDSjtBQUNBLE1BQUksTUFBTSxRQUFRLFVBQVUsR0FBRztBQUMzQixlQUFXQyxRQUFPO0FBQ2QsYUFBTyxLQUFLLE9BQU9BLElBQUc7QUFBQSxFQUM5QixXQUNTLE9BQU8sZUFBZSxZQUFZO0FBQ3ZDLFdBQU8sV0FBVyxLQUFLLE1BQU0sQ0FBQztBQUFBLEVBQ2xDO0FBQ0EsU0FBTyxLQUFLLElBQUksQ0FBQUEsU0FBTztBQUNuQixRQUFJLE9BQU9BLFNBQVE7QUFDZixhQUFPQTtBQUNYLFVBQU0sU0FBUyxXQUFXQSxJQUFHO0FBQzdCLFFBQUk7QUFDQSxhQUFPO0FBQ1gsVUFBTSxPQUFPLE9BQU8sS0FBSyxVQUFVLEVBQzlCLElBQUksU0FBTyxLQUFLLFVBQVUsR0FBRyxDQUFDLEVBQzlCLEtBQUssSUFBSTtBQUNkLFVBQU0sSUFBSSxNQUFNLHVCQUF1QkEscUJBQW9CLE1BQU07QUFBQSxFQUNyRSxDQUFDO0FBQ0w7OztBQzFFQSxJQUFNLHNCQUFzQixDQUFDLEdBQUcsTUFBTSxFQUFFLE1BQU0sRUFBRSxNQUFNLEtBQUssRUFBRSxNQUFNLEVBQUUsTUFBTSxJQUFJO0FBQy9FLElBQU0sU0FBTixNQUFhO0FBQUEsRUFDVCxZQUFZLEVBQUUsUUFBUSxZQUFZLE9BQU8sa0JBQWtCLFFBQUFDLFNBQVEsZ0JBQWdCLGlCQUFpQixHQUFHO0FBQ25HLFNBQUssU0FBUyxNQUFNLFFBQVEsTUFBTSxJQUM1QixRQUFRLFFBQVEsUUFBUSxJQUN4QixTQUNJLFFBQVEsTUFBTSxNQUFNLElBQ3BCO0FBQ1YsU0FBSyxRQUFRLENBQUMsQ0FBQztBQUNmLFNBQUssT0FBUSxPQUFPQSxZQUFXLFlBQVlBLFdBQVc7QUFDdEQsU0FBSyxZQUFZLG1CQUFtQixnQkFBZ0IsQ0FBQztBQUNyRCxTQUFLLE9BQU8sUUFBUSxZQUFZLEtBQUssSUFBSTtBQUN6QyxTQUFLLGtCQUFrQixvQkFBb0I7QUFDM0MsV0FBTyxlQUFlLE1BQU0sS0FBSyxFQUFFLE9BQU8sSUFBSSxDQUFDO0FBQy9DLFdBQU8sZUFBZSxNQUFNLFFBQVEsRUFBRSxPQUFPLE9BQU8sQ0FBQztBQUNyRCxXQUFPLGVBQWUsTUFBTSxLQUFLLEVBQUUsT0FBTyxJQUFJLENBQUM7QUFFL0MsU0FBSyxpQkFDRCxtQkFBbUIsT0FBTyxzQkFBc0Isa0JBQWtCO0FBQUEsRUFDMUU7QUFBQSxFQUNBLFFBQVE7QUFDSixVQUFNLE9BQU8sT0FBTyxPQUFPLE9BQU8sV0FBVyxPQUFPLDBCQUEwQixJQUFJLENBQUM7QUFDbkYsU0FBSyxPQUFPLEtBQUssS0FBSyxNQUFNO0FBQzVCLFdBQU87QUFBQSxFQUNYO0FBQ0o7OztBQzNCQSxTQUFTLGtCQUFrQixLQUFLLFNBQVM7QUFDckMsUUFBTSxRQUFRLENBQUM7QUFDZixNQUFJLGdCQUFnQixRQUFRLGVBQWU7QUFDM0MsTUFBSSxRQUFRLGVBQWUsU0FBUyxJQUFJLFlBQVk7QUFDaEQsVUFBTSxNQUFNLElBQUksV0FBVyxTQUFTLEdBQUc7QUFDdkMsUUFBSSxLQUFLO0FBQ0wsWUFBTSxLQUFLLEdBQUc7QUFDZCxzQkFBZ0I7QUFBQSxJQUNwQixXQUNTLElBQUksV0FBVztBQUNwQixzQkFBZ0I7QUFBQSxFQUN4QjtBQUNBLE1BQUk7QUFDQSxVQUFNLEtBQUssS0FBSztBQUNwQixRQUFNLE1BQU0sdUJBQXVCLEtBQUssT0FBTztBQUMvQyxRQUFNLEVBQUUsY0FBYyxJQUFJLElBQUk7QUFDOUIsTUFBSSxJQUFJLGVBQWU7QUFDbkIsUUFBSSxNQUFNLFdBQVc7QUFDakIsWUFBTSxRQUFRLEVBQUU7QUFDcEIsVUFBTSxLQUFLLGNBQWMsSUFBSSxhQUFhO0FBQzFDLFVBQU0sUUFBUSxjQUFjLElBQUksRUFBRSxDQUFDO0FBQUEsRUFDdkM7QUFDQSxNQUFJLFlBQVk7QUFDaEIsTUFBSSxpQkFBaUI7QUFDckIsTUFBSSxJQUFJLFVBQVU7QUFDZCxRQUFJLE9BQU8sSUFBSSxRQUFRLEdBQUc7QUFDdEIsVUFBSSxJQUFJLFNBQVMsZUFBZTtBQUM1QixjQUFNLEtBQUssRUFBRTtBQUNqQixVQUFJLElBQUksU0FBUyxlQUFlO0FBQzVCLGNBQU0sS0FBSyxjQUFjLElBQUksU0FBUyxhQUFhO0FBQ25ELGNBQU0sS0FBSyxjQUFjLElBQUksRUFBRSxDQUFDO0FBQUEsTUFDcEM7QUFFQSxVQUFJLG1CQUFtQixDQUFDLENBQUMsSUFBSTtBQUM3Qix1QkFBaUIsSUFBSSxTQUFTO0FBQUEsSUFDbEM7QUFDQSxVQUFNLGNBQWMsaUJBQWlCLFNBQVksTUFBTyxZQUFZO0FBQ3BFLFFBQUksT0FBTyxVQUFVLElBQUksVUFBVSxLQUFLLE1BQU8saUJBQWlCLE1BQU8sV0FBVztBQUNsRixRQUFJO0FBQ0EsY0FBUSxZQUFZLE1BQU0sSUFBSSxjQUFjLGNBQWMsQ0FBQztBQUMvRCxTQUFLLEtBQUssQ0FBQyxNQUFNLE9BQU8sS0FBSyxDQUFDLE1BQU0sUUFDaEMsTUFBTSxNQUFNLFNBQVMsQ0FBQyxNQUFNLE9BQU87QUFHbkMsWUFBTSxNQUFNLFNBQVMsQ0FBQyxJQUFJLE9BQU87QUFBQSxJQUNyQztBQUVJLFlBQU0sS0FBSyxJQUFJO0FBQUEsRUFDdkIsT0FDSztBQUNELFVBQU0sS0FBSyxVQUFVLElBQUksVUFBVSxHQUFHLENBQUM7QUFBQSxFQUMzQztBQUNBLE1BQUksS0FBSyxJQUFJO0FBQ2IsTUFBSSxNQUFNO0FBQ04sU0FBSyxHQUFHLFFBQVEsUUFBUSxFQUFFO0FBQzlCLE1BQUksSUFBSTtBQUNKLFNBQUssQ0FBQyxhQUFhLG1CQUFtQixNQUFNLE1BQU0sU0FBUyxDQUFDLE1BQU07QUFDOUQsWUFBTSxLQUFLLEVBQUU7QUFDakIsVUFBTSxLQUFLLGNBQWMsY0FBYyxFQUFFLEdBQUcsRUFBRSxDQUFDO0FBQUEsRUFDbkQ7QUFDQSxTQUFPLE1BQU0sS0FBSyxJQUFJLElBQUk7QUFDOUI7OztBQzFEQSxTQUFTLGFBQWEsU0FBUyxLQUFLLEtBQUssS0FBSztBQUMxQyxNQUFJLE9BQU8sT0FBTyxRQUFRLFVBQVU7QUFDaEMsUUFBSSxNQUFNLFFBQVEsR0FBRyxHQUFHO0FBQ3BCLGVBQVMsSUFBSSxHQUFHLE1BQU0sSUFBSSxRQUFRLElBQUksS0FBSyxFQUFFLEdBQUc7QUFDNUMsY0FBTSxLQUFLLElBQUksQ0FBQztBQUNoQixjQUFNLEtBQUssYUFBYSxTQUFTLEtBQUssT0FBTyxDQUFDLEdBQUcsRUFBRTtBQUNuRCxZQUFJLE9BQU87QUFDUCxpQkFBTyxJQUFJLENBQUM7QUFBQSxpQkFDUCxPQUFPO0FBQ1osY0FBSSxDQUFDLElBQUk7QUFBQSxNQUNqQjtBQUFBLElBQ0osV0FDUyxlQUFlLEtBQUs7QUFDekIsaUJBQVcsS0FBSyxNQUFNLEtBQUssSUFBSSxLQUFLLENBQUMsR0FBRztBQUNwQyxjQUFNLEtBQUssSUFBSSxJQUFJLENBQUM7QUFDcEIsY0FBTSxLQUFLLGFBQWEsU0FBUyxLQUFLLEdBQUcsRUFBRTtBQUMzQyxZQUFJLE9BQU87QUFDUCxjQUFJLE9BQU8sQ0FBQztBQUFBLGlCQUNQLE9BQU87QUFDWixjQUFJLElBQUksR0FBRyxFQUFFO0FBQUEsTUFDckI7QUFBQSxJQUNKLFdBQ1MsZUFBZSxLQUFLO0FBQ3pCLGlCQUFXLE1BQU0sTUFBTSxLQUFLLEdBQUcsR0FBRztBQUM5QixjQUFNLEtBQUssYUFBYSxTQUFTLEtBQUssSUFBSSxFQUFFO0FBQzVDLFlBQUksT0FBTztBQUNQLGNBQUksT0FBTyxFQUFFO0FBQUEsaUJBQ1IsT0FBTyxJQUFJO0FBQ2hCLGNBQUksT0FBTyxFQUFFO0FBQ2IsY0FBSSxJQUFJLEVBQUU7QUFBQSxRQUNkO0FBQUEsTUFDSjtBQUFBLElBQ0osT0FDSztBQUNELGlCQUFXLENBQUMsR0FBRyxFQUFFLEtBQUssT0FBTyxRQUFRLEdBQUcsR0FBRztBQUN2QyxjQUFNLEtBQUssYUFBYSxTQUFTLEtBQUssR0FBRyxFQUFFO0FBQzNDLFlBQUksT0FBTztBQUNQLGlCQUFPLElBQUksQ0FBQztBQUFBLGlCQUNQLE9BQU87QUFDWixjQUFJLENBQUMsSUFBSTtBQUFBLE1BQ2pCO0FBQUEsSUFDSjtBQUFBLEVBQ0o7QUFDQSxTQUFPLFFBQVEsS0FBSyxLQUFLLEtBQUssR0FBRztBQUNyQzs7O0FDckNBLElBQU0sV0FBTixNQUFlO0FBQUEsRUFDWCxZQUFZLE9BQU8sVUFBVSxTQUFTO0FBRWxDLFNBQUssZ0JBQWdCO0FBRXJCLFNBQUssVUFBVTtBQUVmLFNBQUssU0FBUyxDQUFDO0FBRWYsU0FBSyxXQUFXLENBQUM7QUFDakIsV0FBTyxlQUFlLE1BQU0sV0FBVyxFQUFFLE9BQU8sSUFBSSxDQUFDO0FBQ3JELFFBQUksWUFBWTtBQUNoQixRQUFJLE9BQU8sYUFBYSxjQUFjLE1BQU0sUUFBUSxRQUFRLEdBQUc7QUFDM0Qsa0JBQVk7QUFBQSxJQUNoQixXQUNTLFlBQVksVUFBYSxVQUFVO0FBQ3hDLGdCQUFVO0FBQ1YsaUJBQVc7QUFBQSxJQUNmO0FBQ0EsVUFBTSxNQUFNLE9BQU8sT0FBTyxDQUFDLEdBQUcsZ0JBQWdCLE9BQU87QUFDckQsU0FBSyxVQUFVO0FBQ2YsUUFBSSxFQUFFLFFBQVEsSUFBSTtBQUNsQixRQUFJLFlBQVksUUFBUSxZQUFZLFNBQVMsU0FBUyxRQUFRLFlBQVk7QUFDdEUsV0FBSyxhQUFhLFFBQVEsV0FBVyxXQUFXO0FBQ2hELFVBQUksS0FBSyxXQUFXLEtBQUs7QUFDckIsa0JBQVUsS0FBSyxXQUFXLEtBQUs7QUFBQSxJQUN2QztBQUVJLFdBQUssYUFBYSxJQUFJLFdBQVcsRUFBRSxRQUFRLENBQUM7QUFDaEQsU0FBSyxVQUFVLFNBQVMsT0FBTztBQUMvQixRQUFJLFVBQVU7QUFDVixXQUFLLFdBQVc7QUFBQSxTQUNmO0FBQ0QsV0FBSyxXQUFXLEtBQUssV0FBVyxPQUFPLFdBQVcsT0FBTztBQUFBLElBQzdEO0FBQUEsRUFDSjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQU1BLFFBQVE7QUFDSixVQUFNLE9BQU8sT0FBTyxPQUFPLFNBQVMsV0FBVztBQUFBLE1BQzNDLENBQUMsU0FBUyxHQUFHLEVBQUUsT0FBTyxJQUFJO0FBQUEsSUFDOUIsQ0FBQztBQUNELFNBQUssZ0JBQWdCLEtBQUs7QUFDMUIsU0FBSyxVQUFVLEtBQUs7QUFDcEIsU0FBSyxTQUFTLEtBQUssT0FBTyxNQUFNO0FBQ2hDLFNBQUssV0FBVyxLQUFLLFNBQVMsTUFBTTtBQUNwQyxTQUFLLFVBQVUsT0FBTyxPQUFPLENBQUMsR0FBRyxLQUFLLE9BQU87QUFDN0MsUUFBSSxLQUFLO0FBQ0wsV0FBSyxhQUFhLEtBQUssV0FBVyxNQUFNO0FBQzVDLFNBQUssU0FBUyxLQUFLLE9BQU8sTUFBTTtBQUNoQyxTQUFLLFdBQVcsT0FBTyxLQUFLLFFBQVEsSUFDOUIsS0FBSyxTQUFTLE1BQU0sS0FBSyxNQUFNLElBQy9CLEtBQUs7QUFDWCxRQUFJLEtBQUs7QUFDTCxXQUFLLFFBQVEsS0FBSyxNQUFNLE1BQU07QUFDbEMsV0FBTztBQUFBLEVBQ1g7QUFBQTtBQUFBLEVBRUEsSUFBSSxPQUFPO0FBQ1AsUUFBSSxpQkFBaUIsS0FBSyxRQUFRO0FBQzlCLFdBQUssU0FBUyxJQUFJLEtBQUs7QUFBQSxFQUMvQjtBQUFBO0FBQUEsRUFFQSxNQUFNLE1BQU0sT0FBTztBQUNmLFFBQUksaUJBQWlCLEtBQUssUUFBUTtBQUM5QixXQUFLLFNBQVMsTUFBTSxNQUFNLEtBQUs7QUFBQSxFQUN2QztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBVUEsWUFBWSxNQUFNLE1BQU07QUFDcEIsUUFBSSxDQUFDLEtBQUssUUFBUTtBQUNkLFlBQU0sT0FBTyxZQUFZLElBQUk7QUFDN0IsV0FBSyxTQUNELENBQUMsUUFBUSxLQUFLLElBQUksSUFBSSxJQUFJLGNBQWMsUUFBUSxLQUFLLElBQUksSUFBSTtBQUFBLElBQ3JFO0FBQ0EsV0FBTyxJQUFJLE1BQU0sS0FBSyxNQUFNO0FBQUEsRUFDaEM7QUFBQSxFQUNBLFdBQVcsT0FBTyxVQUFVLFNBQVM7QUFDakMsUUFBSSxZQUFZO0FBQ2hCLFFBQUksT0FBTyxhQUFhLFlBQVk7QUFDaEMsY0FBUSxTQUFTLEtBQUssRUFBRSxJQUFJLE1BQU0sR0FBRyxJQUFJLEtBQUs7QUFDOUMsa0JBQVk7QUFBQSxJQUNoQixXQUNTLE1BQU0sUUFBUSxRQUFRLEdBQUc7QUFDOUIsWUFBTSxXQUFXLENBQUMsTUFBTSxPQUFPLE1BQU0sWUFBWSxhQUFhLFVBQVUsYUFBYTtBQUNyRixZQUFNLFFBQVEsU0FBUyxPQUFPLFFBQVEsRUFBRSxJQUFJLE1BQU07QUFDbEQsVUFBSSxNQUFNLFNBQVM7QUFDZixtQkFBVyxTQUFTLE9BQU8sS0FBSztBQUNwQyxrQkFBWTtBQUFBLElBQ2hCLFdBQ1MsWUFBWSxVQUFhLFVBQVU7QUFDeEMsZ0JBQVU7QUFDVixpQkFBVztBQUFBLElBQ2Y7QUFDQSxVQUFNLEVBQUUsdUJBQXVCLGNBQWMsTUFBTSxlQUFlLFVBQVUsS0FBQUMsS0FBSSxJQUFJLFdBQVcsQ0FBQztBQUNoRyxVQUFNLEVBQUUsVUFBVSxZQUFZLGNBQWMsSUFBSSxrQkFBa0IsTUFBTSxnQkFBZ0IsR0FBRztBQUMzRixVQUFNLE1BQU07QUFBQSxNQUNSLHVCQUF1QiwwQkFBMEIsUUFBUSwwQkFBMEIsU0FBUyx3QkFBd0I7QUFBQSxNQUNwSCxlQUFlLGtCQUFrQixRQUFRLGtCQUFrQixTQUFTLGdCQUFnQjtBQUFBLE1BQ3BGO0FBQUEsTUFDQTtBQUFBLE1BQ0EsVUFBVTtBQUFBLE1BQ1YsUUFBUSxLQUFLO0FBQUEsTUFDYjtBQUFBLElBQ0o7QUFDQSxVQUFNLE9BQU8sV0FBVyxPQUFPQSxNQUFLLEdBQUc7QUFDdkMsUUFBSSxRQUFRLGFBQWEsSUFBSTtBQUN6QixXQUFLLE9BQU87QUFDaEIsZUFBVztBQUNYLFdBQU87QUFBQSxFQUNYO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQUtBLFdBQVcsS0FBSyxPQUFPLFVBQVUsQ0FBQyxHQUFHO0FBQ2pDLFVBQU0sSUFBSSxLQUFLLFdBQVcsS0FBSyxNQUFNLE9BQU87QUFDNUMsVUFBTSxJQUFJLEtBQUssV0FBVyxPQUFPLE1BQU0sT0FBTztBQUM5QyxXQUFPLElBQUksS0FBSyxHQUFHLENBQUM7QUFBQSxFQUN4QjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFLQSxPQUFPLEtBQUs7QUFDUixXQUFPLGlCQUFpQixLQUFLLFFBQVEsSUFBSSxLQUFLLFNBQVMsT0FBTyxHQUFHLElBQUk7QUFBQSxFQUN6RTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFLQSxTQUFTLE1BQU07QUFDWCxRQUFJLFlBQVksSUFBSSxHQUFHO0FBQ25CLFVBQUksS0FBSyxZQUFZO0FBQ2pCLGVBQU87QUFDWCxXQUFLLFdBQVc7QUFDaEIsYUFBTztBQUFBLElBQ1g7QUFDQSxXQUFPLGlCQUFpQixLQUFLLFFBQVEsSUFDL0IsS0FBSyxTQUFTLFNBQVMsSUFBSSxJQUMzQjtBQUFBLEVBQ1Y7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFNQSxJQUFJLEtBQUssWUFBWTtBQUNqQixXQUFPLGFBQWEsS0FBSyxRQUFRLElBQzNCLEtBQUssU0FBUyxJQUFJLEtBQUssVUFBVSxJQUNqQztBQUFBLEVBQ1Y7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFNQSxNQUFNLE1BQU0sWUFBWTtBQUNwQixRQUFJLFlBQVksSUFBSTtBQUNoQixhQUFPLENBQUMsY0FBYyxTQUFTLEtBQUssUUFBUSxJQUN0QyxLQUFLLFNBQVMsUUFDZCxLQUFLO0FBQ2YsV0FBTyxhQUFhLEtBQUssUUFBUSxJQUMzQixLQUFLLFNBQVMsTUFBTSxNQUFNLFVBQVUsSUFDcEM7QUFBQSxFQUNWO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJQSxJQUFJLEtBQUs7QUFDTCxXQUFPLGFBQWEsS0FBSyxRQUFRLElBQUksS0FBSyxTQUFTLElBQUksR0FBRyxJQUFJO0FBQUEsRUFDbEU7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQUlBLE1BQU0sTUFBTTtBQUNSLFFBQUksWUFBWSxJQUFJO0FBQ2hCLGFBQU8sS0FBSyxhQUFhO0FBQzdCLFdBQU8sYUFBYSxLQUFLLFFBQVEsSUFBSSxLQUFLLFNBQVMsTUFBTSxJQUFJLElBQUk7QUFBQSxFQUNyRTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFLQSxJQUFJLEtBQUssT0FBTztBQUNaLFFBQUksS0FBSyxZQUFZLE1BQU07QUFDdkIsV0FBSyxXQUFXLG1CQUFtQixLQUFLLFFBQVEsQ0FBQyxHQUFHLEdBQUcsS0FBSztBQUFBLElBQ2hFLFdBQ1MsaUJBQWlCLEtBQUssUUFBUSxHQUFHO0FBQ3RDLFdBQUssU0FBUyxJQUFJLEtBQUssS0FBSztBQUFBLElBQ2hDO0FBQUEsRUFDSjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFLQSxNQUFNLE1BQU0sT0FBTztBQUNmLFFBQUksWUFBWSxJQUFJO0FBQ2hCLFdBQUssV0FBVztBQUFBLGFBQ1gsS0FBSyxZQUFZLE1BQU07QUFDNUIsV0FBSyxXQUFXLG1CQUFtQixLQUFLLFFBQVEsTUFBTSxLQUFLLElBQUksR0FBRyxLQUFLO0FBQUEsSUFDM0UsV0FDUyxpQkFBaUIsS0FBSyxRQUFRLEdBQUc7QUFDdEMsV0FBSyxTQUFTLE1BQU0sTUFBTSxLQUFLO0FBQUEsSUFDbkM7QUFBQSxFQUNKO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQVFBLFVBQVUsU0FBUyxVQUFVLENBQUMsR0FBRztBQUM3QixRQUFJLE9BQU8sWUFBWTtBQUNuQixnQkFBVSxPQUFPLE9BQU87QUFDNUIsUUFBSTtBQUNKLFlBQVEsU0FBUztBQUFBLE1BQ2IsS0FBSztBQUNELFlBQUksS0FBSztBQUNMLGVBQUssV0FBVyxLQUFLLFVBQVU7QUFBQTtBQUUvQixlQUFLLGFBQWEsSUFBSSxXQUFXLEVBQUUsU0FBUyxNQUFNLENBQUM7QUFDdkQsY0FBTSxFQUFFLE9BQU8sTUFBTSxrQkFBa0IsT0FBTyxRQUFRLFdBQVc7QUFDakU7QUFBQSxNQUNKLEtBQUs7QUFDRCxZQUFJLEtBQUs7QUFDTCxlQUFLLFdBQVcsS0FBSyxVQUFVO0FBQUE7QUFFL0IsZUFBSyxhQUFhLElBQUksV0FBVyxFQUFFLFNBQVMsTUFBTSxDQUFDO0FBQ3ZELGNBQU0sRUFBRSxPQUFPLE9BQU8sa0JBQWtCLE1BQU0sUUFBUSxPQUFPO0FBQzdEO0FBQUEsTUFDSixLQUFLO0FBQ0QsWUFBSSxLQUFLO0FBQ0wsaUJBQU8sS0FBSztBQUNoQixjQUFNO0FBQ047QUFBQSxNQUNKLFNBQVM7QUFDTCxjQUFNLEtBQUssS0FBSyxVQUFVLE9BQU87QUFDakMsY0FBTSxJQUFJLE1BQU0sK0RBQStELElBQUk7QUFBQSxNQUN2RjtBQUFBLElBQ0o7QUFFQSxRQUFJLFFBQVEsa0JBQWtCO0FBQzFCLFdBQUssU0FBUyxRQUFRO0FBQUEsYUFDakI7QUFDTCxXQUFLLFNBQVMsSUFBSSxPQUFPLE9BQU8sT0FBTyxLQUFLLE9BQU8sQ0FBQztBQUFBO0FBRXBELFlBQU0sSUFBSSxNQUFNLHFFQUFxRTtBQUFBLEVBQzdGO0FBQUE7QUFBQSxFQUVBLEtBQUssRUFBRSxNQUFNLFNBQVMsVUFBVSxlQUFlLFVBQVUsUUFBUSxJQUFJLENBQUMsR0FBRztBQUNyRSxVQUFNLE1BQU07QUFBQSxNQUNSLFNBQVMsb0JBQUksSUFBSTtBQUFBLE1BQ2pCLEtBQUs7QUFBQSxNQUNMLE1BQU0sQ0FBQztBQUFBLE1BQ1AsVUFBVSxhQUFhO0FBQUEsTUFDdkIsY0FBYztBQUFBLE1BQ2QsZUFBZSxPQUFPLGtCQUFrQixXQUFXLGdCQUFnQjtBQUFBLE1BQ25FO0FBQUEsSUFDSjtBQUNBLFVBQU0sTUFBTSxLQUFLLEtBQUssVUFBVSxXQUFXLElBQUksR0FBRztBQUNsRCxRQUFJLE9BQU8sYUFBYTtBQUNwQixpQkFBVyxFQUFFLE9BQU8sS0FBQUMsS0FBSSxLQUFLLElBQUksUUFBUSxPQUFPO0FBQzVDLGlCQUFTQSxNQUFLLEtBQUs7QUFDM0IsV0FBTyxPQUFPLFlBQVksYUFDcEIsYUFBYSxTQUFTLEVBQUUsSUFBSSxJQUFJLEdBQUcsSUFBSSxHQUFHLElBQzFDO0FBQUEsRUFDVjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBT0EsT0FBTyxTQUFTLFVBQVU7QUFDdEIsV0FBTyxLQUFLLEtBQUssRUFBRSxNQUFNLE1BQU0sU0FBUyxVQUFVLE9BQU8sU0FBUyxDQUFDO0FBQUEsRUFDdkU7QUFBQTtBQUFBLEVBRUEsU0FBUyxVQUFVLENBQUMsR0FBRztBQUNuQixRQUFJLEtBQUssT0FBTyxTQUFTO0FBQ3JCLFlBQU0sSUFBSSxNQUFNLDRDQUE0QztBQUNoRSxRQUFJLFlBQVksWUFDWCxDQUFDLE9BQU8sVUFBVSxRQUFRLE1BQU0sS0FBSyxPQUFPLFFBQVEsTUFBTSxLQUFLLElBQUk7QUFDcEUsWUFBTSxJQUFJLEtBQUssVUFBVSxRQUFRLE1BQU07QUFDdkMsWUFBTSxJQUFJLE1BQU0sbURBQW1ELEdBQUc7QUFBQSxJQUMxRTtBQUNBLFdBQU8sa0JBQWtCLE1BQU0sT0FBTztBQUFBLEVBQzFDO0FBQ0o7QUFDQSxTQUFTLGlCQUFpQixVQUFVO0FBQ2hDLE1BQUksYUFBYSxRQUFRO0FBQ3JCLFdBQU87QUFDWCxRQUFNLElBQUksTUFBTSxpREFBaUQ7QUFDckU7OztBQzlUQSxJQUFNLFlBQU4sY0FBd0IsTUFBTTtBQUFBLEVBQzFCLFlBQVksTUFBTSxLQUFLLE1BQU0sU0FBUztBQUNsQyxVQUFNO0FBQ04sU0FBSyxPQUFPO0FBQ1osU0FBSyxPQUFPO0FBQ1osU0FBSyxVQUFVO0FBQ2YsU0FBSyxNQUFNO0FBQUEsRUFDZjtBQUNKO0FBQ0EsSUFBTSxpQkFBTixjQUE2QixVQUFVO0FBQUEsRUFDbkMsWUFBWSxLQUFLLE1BQU0sU0FBUztBQUM1QixVQUFNLGtCQUFrQixLQUFLLE1BQU0sT0FBTztBQUFBLEVBQzlDO0FBQ0o7QUFDQSxJQUFNLGNBQU4sY0FBMEIsVUFBVTtBQUFBLEVBQ2hDLFlBQVksS0FBSyxNQUFNLFNBQVM7QUFDNUIsVUFBTSxlQUFlLEtBQUssTUFBTSxPQUFPO0FBQUEsRUFDM0M7QUFDSjtBQUNBLElBQU0sZ0JBQWdCLENBQUMsS0FBSyxPQUFPLENBQUMsVUFBVTtBQUMxQyxNQUFJLE1BQU0sSUFBSSxDQUFDLE1BQU07QUFDakI7QUFDSixRQUFNLFVBQVUsTUFBTSxJQUFJLElBQUksU0FBTyxHQUFHLFFBQVEsR0FBRyxDQUFDO0FBQ3BELFFBQU0sRUFBRSxNQUFNLElBQUksSUFBSSxNQUFNLFFBQVEsQ0FBQztBQUNyQyxRQUFNLFdBQVcsWUFBWSxnQkFBZ0I7QUFDN0MsTUFBSSxLQUFLLE1BQU07QUFDZixNQUFJLFVBQVUsSUFDVCxVQUFVLEdBQUcsV0FBVyxPQUFPLENBQUMsR0FBRyxHQUFHLFdBQVcsSUFBSSxDQUFDLEVBQ3RELFFBQVEsWUFBWSxFQUFFO0FBRTNCLE1BQUksTUFBTSxNQUFNLFFBQVEsU0FBUyxJQUFJO0FBQ2pDLFVBQU0sWUFBWSxLQUFLLElBQUksS0FBSyxJQUFJLFFBQVEsU0FBUyxFQUFFO0FBQ3ZELGNBQVUsV0FBTSxRQUFRLFVBQVUsU0FBUztBQUMzQyxVQUFNLFlBQVk7QUFBQSxFQUN0QjtBQUNBLE1BQUksUUFBUSxTQUFTO0FBQ2pCLGNBQVUsUUFBUSxVQUFVLEdBQUcsRUFBRSxJQUFJO0FBRXpDLE1BQUksT0FBTyxLQUFLLE9BQU8sS0FBSyxRQUFRLFVBQVUsR0FBRyxFQUFFLENBQUMsR0FBRztBQUVuRCxRQUFJLE9BQU8sSUFBSSxVQUFVLEdBQUcsV0FBVyxPQUFPLENBQUMsR0FBRyxHQUFHLFdBQVcsT0FBTyxDQUFDLENBQUM7QUFDekUsUUFBSSxLQUFLLFNBQVM7QUFDZCxhQUFPLEtBQUssVUFBVSxHQUFHLEVBQUUsSUFBSTtBQUNuQyxjQUFVLE9BQU87QUFBQSxFQUNyQjtBQUNBLE1BQUksT0FBTyxLQUFLLE9BQU8sR0FBRztBQUN0QixRQUFJLFFBQVE7QUFDWixVQUFNLE1BQU0sTUFBTSxRQUFRLENBQUM7QUFDM0IsUUFBSSxPQUFPLElBQUksU0FBUyxRQUFRLElBQUksTUFBTSxLQUFLO0FBQzNDLGNBQVEsS0FBSyxJQUFJLElBQUksTUFBTSxLQUFLLEtBQUssRUFBRTtBQUFBLElBQzNDO0FBQ0EsVUFBTSxVQUFVLElBQUksT0FBTyxFQUFFLElBQUksSUFBSSxPQUFPLEtBQUs7QUFDakQsVUFBTSxXQUFXO0FBQUE7QUFBQSxFQUFRO0FBQUEsRUFBWTtBQUFBO0FBQUEsRUFDekM7QUFDSjs7O0FDdERBLFNBQVMsYUFBYSxRQUFRLEVBQUUsTUFBTSxXQUFXLE1BQU0sUUFBUSxTQUFTLGVBQWUsR0FBRztBQUN0RixNQUFJLGNBQWM7QUFDbEIsTUFBSSxZQUFZO0FBQ2hCLE1BQUksV0FBVztBQUNmLE1BQUksVUFBVTtBQUNkLE1BQUksYUFBYTtBQUNqQixNQUFJLGFBQWE7QUFDakIsTUFBSSxXQUFXO0FBQ2YsTUFBSSxTQUFTO0FBQ2IsTUFBSUMsT0FBTTtBQUNWLE1BQUksUUFBUTtBQUNaLE1BQUksUUFBUTtBQUNaLE1BQUksUUFBUTtBQUNaLGFBQVcsU0FBUyxRQUFRO0FBQ3hCLFFBQUksVUFBVTtBQUNWLFVBQUksTUFBTSxTQUFTLFdBQ2YsTUFBTSxTQUFTLGFBQ2YsTUFBTSxTQUFTO0FBQ2YsZ0JBQVEsTUFBTSxRQUFRLGdCQUFnQix1RUFBdUU7QUFDakgsaUJBQVc7QUFBQSxJQUNmO0FBQ0EsWUFBUSxNQUFNLE1BQU07QUFBQSxNQUNoQixLQUFLO0FBSUQsWUFBSSxDQUFDLFFBQ0QsYUFDQSxjQUFjLGVBQ2QsTUFBTSxPQUFPLENBQUMsTUFBTTtBQUNwQixrQkFBUSxPQUFPLGlCQUFpQixxQ0FBcUM7QUFDekUsbUJBQVc7QUFDWDtBQUFBLE1BQ0osS0FBSyxXQUFXO0FBQ1osWUFBSSxDQUFDO0FBQ0Qsa0JBQVEsT0FBTyxnQkFBZ0Isd0VBQXdFO0FBQzNHLGNBQU0sS0FBSyxNQUFNLE9BQU8sVUFBVSxDQUFDLEtBQUs7QUFDeEMsWUFBSSxDQUFDO0FBQ0Qsb0JBQVU7QUFBQTtBQUVWLHFCQUFXLGFBQWE7QUFDNUIscUJBQWE7QUFDYixvQkFBWTtBQUNaO0FBQUEsTUFDSjtBQUFBLE1BQ0EsS0FBSztBQUNELFlBQUksV0FBVztBQUNYLGNBQUk7QUFDQSx1QkFBVyxNQUFNO0FBQUE7QUFFakIsMEJBQWM7QUFBQSxRQUN0QjtBQUVJLHdCQUFjLE1BQU07QUFDeEIsb0JBQVk7QUFDWixxQkFBYTtBQUNiLG1CQUFXO0FBQ1g7QUFBQSxNQUNKLEtBQUs7QUFDRCxZQUFJO0FBQ0Esa0JBQVEsT0FBTyxvQkFBb0Isb0NBQW9DO0FBQzNFLGlCQUFTO0FBQ1QsWUFBSSxVQUFVO0FBQ1Ysa0JBQVEsTUFBTTtBQUNsQixvQkFBWTtBQUNaLG1CQUFXO0FBQ1gsbUJBQVc7QUFDWDtBQUFBLE1BQ0osS0FBSyxPQUFPO0FBQ1IsWUFBSUE7QUFDQSxrQkFBUSxPQUFPLGlCQUFpQixpQ0FBaUM7QUFDckUsUUFBQUEsT0FBTTtBQUNOLFlBQUksVUFBVTtBQUNWLGtCQUFRLE1BQU07QUFDbEIsb0JBQVk7QUFDWixtQkFBVztBQUNYLG1CQUFXO0FBQ1g7QUFBQSxNQUNKO0FBQUEsTUFDQSxLQUFLO0FBRUQsWUFBSSxVQUFVQTtBQUNWLGtCQUFRLE9BQU8sa0JBQWtCLHNDQUFzQyxNQUFNLGtCQUFrQjtBQUNuRyxZQUFJO0FBQ0Esa0JBQVEsT0FBTyxvQkFBb0IsY0FBYyxNQUFNLGFBQWEsUUFBUSxjQUFjO0FBQzlGLGdCQUFRO0FBQ1Isb0JBQVk7QUFDWixtQkFBVztBQUNYO0FBQUEsTUFDSixLQUFLO0FBQ0QsWUFBSSxNQUFNO0FBQ04sY0FBSTtBQUNBLG9CQUFRLE9BQU8sb0JBQW9CLG1CQUFtQixNQUFNO0FBQ2hFLGtCQUFRO0FBQ1Isc0JBQVk7QUFDWixxQkFBVztBQUNYO0FBQUEsUUFDSjtBQUFBLE1BRUo7QUFDSSxnQkFBUSxPQUFPLG9CQUFvQixjQUFjLE1BQU0sWUFBWTtBQUNuRSxvQkFBWTtBQUNaLG1CQUFXO0FBQUEsSUFDbkI7QUFBQSxFQUNKO0FBQ0EsUUFBTSxPQUFPLE9BQU8sT0FBTyxTQUFTLENBQUM7QUFDckMsUUFBTSxNQUFNLE9BQU8sS0FBSyxTQUFTLEtBQUssT0FBTyxTQUFTO0FBQ3RELE1BQUksWUFDQSxRQUNBLEtBQUssU0FBUyxXQUNkLEtBQUssU0FBUyxhQUNkLEtBQUssU0FBUyxZQUNiLEtBQUssU0FBUyxZQUFZLEtBQUssV0FBVztBQUMzQyxZQUFRLEtBQUssUUFBUSxnQkFBZ0IsdUVBQXVFO0FBQ2hILFNBQU87QUFBQSxJQUNIO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxJQUNBLEtBQUFBO0FBQUEsSUFDQTtBQUFBLElBQ0EsT0FBTyxVQUFVLFFBQVEsVUFBVSxTQUFTLFFBQVE7QUFBQSxFQUN4RDtBQUNKOzs7QUM3SEEsU0FBUyxnQkFBZ0IsS0FBSztBQUMxQixNQUFJLENBQUM7QUFDRCxXQUFPO0FBQ1gsVUFBUSxJQUFJLE1BQU07QUFBQSxJQUNkLEtBQUs7QUFBQSxJQUNMLEtBQUs7QUFBQSxJQUNMLEtBQUs7QUFBQSxJQUNMLEtBQUs7QUFDRCxVQUFJLElBQUksT0FBTyxTQUFTLElBQUk7QUFDeEIsZUFBTztBQUNYLFVBQUksSUFBSTtBQUNKLG1CQUFXLE1BQU0sSUFBSTtBQUNqQixjQUFJLEdBQUcsU0FBUztBQUNaLG1CQUFPO0FBQUE7QUFDbkIsYUFBTztBQUFBLElBQ1gsS0FBSztBQUNELGlCQUFXLE1BQU0sSUFBSSxPQUFPO0FBQ3hCLG1CQUFXLE1BQU0sR0FBRztBQUNoQixjQUFJLEdBQUcsU0FBUztBQUNaLG1CQUFPO0FBQ2YsWUFBSSxHQUFHO0FBQ0gscUJBQVcsTUFBTSxHQUFHO0FBQ2hCLGdCQUFJLEdBQUcsU0FBUztBQUNaLHFCQUFPO0FBQUE7QUFDbkIsWUFBSSxnQkFBZ0IsR0FBRyxHQUFHLEtBQUssZ0JBQWdCLEdBQUcsS0FBSztBQUNuRCxpQkFBTztBQUFBLE1BQ2Y7QUFDQSxhQUFPO0FBQUEsSUFDWDtBQUNJLGFBQU87QUFBQSxFQUNmO0FBQ0o7OztBQzdCQSxTQUFTLGdCQUFnQixRQUFRLElBQUksU0FBUztBQUMxQyxPQUFLLE9BQU8sUUFBUSxPQUFPLFNBQVMsU0FBUyxHQUFHLFVBQVUsbUJBQW1CO0FBQ3pFLFVBQU0sTUFBTSxHQUFHLElBQUksQ0FBQztBQUNwQixRQUFJLElBQUksV0FBVyxXQUNkLElBQUksV0FBVyxPQUFPLElBQUksV0FBVyxRQUN0QyxnQkFBZ0IsRUFBRSxHQUFHO0FBQ3JCLFlBQU0sTUFBTTtBQUNaLGNBQVEsS0FBSyxjQUFjLEtBQUssSUFBSTtBQUFBLElBQ3hDO0FBQUEsRUFDSjtBQUNKOzs7QUNWQSxTQUFTLFlBQVksS0FBSyxPQUFPLFFBQVE7QUFDckMsUUFBTSxFQUFFLFdBQVcsSUFBSSxJQUFJO0FBQzNCLE1BQUksZUFBZTtBQUNmLFdBQU87QUFDWCxRQUFNLFVBQVUsT0FBTyxlQUFlLGFBQ2hDLGFBQ0EsQ0FBQyxHQUFHLE1BQU0sTUFBTSxLQUNiLFNBQVMsQ0FBQyxLQUNQLFNBQVMsQ0FBQyxLQUNWLEVBQUUsVUFBVSxFQUFFLFNBQ2QsRUFBRSxFQUFFLFVBQVUsUUFBUSxJQUFJLE9BQU87QUFDN0MsU0FBTyxNQUFNLEtBQUssVUFBUSxRQUFRLEtBQUssS0FBSyxNQUFNLENBQUM7QUFDdkQ7OztBQ1BBLElBQU0sY0FBYztBQUNwQixTQUFTLGdCQUFnQixFQUFFLGFBQUFDLGNBQWEsa0JBQUFDLGtCQUFpQixHQUFHLEtBQUssSUFBSSxTQUFTO0FBQzFFLE1BQUk7QUFDSixRQUFNQyxPQUFNLElBQUksUUFBUSxJQUFJLE1BQU07QUFDbEMsTUFBSSxJQUFJO0FBQ0osUUFBSSxTQUFTO0FBQ2pCLE1BQUksU0FBUyxHQUFHO0FBQ2hCLGFBQVcsWUFBWSxHQUFHLE9BQU87QUFDN0IsVUFBTSxFQUFFLE9BQU8sS0FBSyxLQUFLLE1BQU0sSUFBSTtBQUVuQyxVQUFNLFdBQVcsYUFBYSxPQUFPO0FBQUEsTUFDakMsV0FBVztBQUFBLE1BQ1gsTUFBTSxRQUFRLFFBQVEsUUFBUSxRQUFRLFNBQVMsU0FBUyxJQUFJLENBQUM7QUFBQSxNQUM3RDtBQUFBLE1BQ0E7QUFBQSxNQUNBLGdCQUFnQjtBQUFBLElBQ3BCLENBQUM7QUFDRCxVQUFNLGNBQWMsQ0FBQyxTQUFTO0FBQzlCLFFBQUksYUFBYTtBQUNiLFVBQUksS0FBSztBQUNMLFlBQUksSUFBSSxTQUFTO0FBQ2Isa0JBQVEsUUFBUSx5QkFBeUIseURBQXlEO0FBQUEsaUJBQzdGLFlBQVksT0FBTyxJQUFJLFdBQVcsR0FBRztBQUMxQyxrQkFBUSxRQUFRLGNBQWMsV0FBVztBQUFBLE1BQ2pEO0FBQ0EsVUFBSSxDQUFDLFNBQVMsVUFBVSxDQUFDLFNBQVMsT0FBTyxDQUFDLEtBQUs7QUFFM0MsWUFBSSxTQUFTLFNBQVM7QUFDbEIsY0FBSUEsS0FBSTtBQUNKLFlBQUFBLEtBQUksV0FBVyxPQUFPLFNBQVM7QUFBQTtBQUUvQixZQUFBQSxLQUFJLFVBQVUsU0FBUztBQUFBLFFBQy9CO0FBQ0E7QUFBQSxNQUNKO0FBQUEsSUFDSixhQUNXLEtBQUssU0FBUyxXQUFXLFFBQVEsT0FBTyxTQUFTLFNBQVMsR0FBRyxZQUFZLEdBQUc7QUFDbkYsY0FBUSxRQUFRLGNBQWMsV0FBVztBQUM3QyxRQUFJLGVBQWUsZ0JBQWdCLEdBQUc7QUFDbEM7QUFBQSxRQUFRO0FBQUE7QUFBQSxRQUNSO0FBQUEsUUFBMEI7QUFBQSxNQUEyQztBQUV6RSxVQUFNLFdBQVcsU0FBUztBQUMxQixVQUFNLFVBQVUsTUFDVkYsYUFBWSxLQUFLLEtBQUssVUFBVSxPQUFPLElBQ3ZDQyxrQkFBaUIsS0FBSyxVQUFVLE9BQU8sTUFBTSxVQUFVLE9BQU87QUFDcEUsUUFBSSxJQUFJLE9BQU87QUFDWCxzQkFBZ0IsR0FBRyxRQUFRLEtBQUssT0FBTztBQUMzQyxRQUFJLFlBQVksS0FBS0MsS0FBSSxPQUFPLE9BQU87QUFDbkMsY0FBUSxVQUFVLGlCQUFpQix5QkFBeUI7QUFFaEUsVUFBTSxhQUFhLGFBQWEsT0FBTyxDQUFDLEdBQUc7QUFBQSxNQUN2QyxXQUFXO0FBQUEsTUFDWCxNQUFNO0FBQUEsTUFDTixRQUFRLFFBQVEsTUFBTSxDQUFDO0FBQUEsTUFDdkI7QUFBQSxNQUNBLGdCQUFnQixDQUFDLE9BQU8sSUFBSSxTQUFTO0FBQUEsSUFDekMsQ0FBQztBQUNELGFBQVMsV0FBVztBQUNwQixRQUFJLFdBQVcsT0FBTztBQUNsQixVQUFJLGFBQWE7QUFDYixhQUFLLFVBQVUsUUFBUSxVQUFVLFNBQVMsU0FBUyxNQUFNLFVBQVUsZUFBZSxDQUFDLFdBQVc7QUFDMUYsa0JBQVEsUUFBUSx5QkFBeUIscURBQXFEO0FBQ2xHLFlBQUksSUFBSSxRQUFRLFVBQ1osU0FBUyxRQUFRLFdBQVcsTUFBTSxTQUFTO0FBQzNDLGtCQUFRLFFBQVEsT0FBTyx1QkFBdUIsNkZBQTZGO0FBQUEsTUFDbko7QUFFQSxZQUFNLFlBQVksUUFDWkYsYUFBWSxLQUFLLE9BQU8sWUFBWSxPQUFPLElBQzNDQyxrQkFBaUIsS0FBSyxRQUFRLEtBQUssTUFBTSxZQUFZLE9BQU87QUFDbEUsVUFBSSxJQUFJLE9BQU87QUFDWCx3QkFBZ0IsR0FBRyxRQUFRLE9BQU8sT0FBTztBQUM3QyxlQUFTLFVBQVUsTUFBTSxDQUFDO0FBQzFCLFlBQU0sT0FBTyxJQUFJLEtBQUssU0FBUyxTQUFTO0FBQ3hDLFVBQUksSUFBSSxRQUFRO0FBQ1osYUFBSyxXQUFXO0FBQ3BCLE1BQUFDLEtBQUksTUFBTSxLQUFLLElBQUk7QUFBQSxJQUN2QixPQUNLO0FBRUQsVUFBSTtBQUNBLGdCQUFRLFFBQVEsT0FBTyxnQkFBZ0IscURBQXFEO0FBQ2hHLFVBQUksV0FBVyxTQUFTO0FBQ3BCLFlBQUksUUFBUTtBQUNSLGtCQUFRLFdBQVcsT0FBTyxXQUFXO0FBQUE7QUFFckMsa0JBQVEsVUFBVSxXQUFXO0FBQUEsTUFDckM7QUFDQSxZQUFNLE9BQU8sSUFBSSxLQUFLLE9BQU87QUFDN0IsVUFBSSxJQUFJLFFBQVE7QUFDWixhQUFLLFdBQVc7QUFDcEIsTUFBQUEsS0FBSSxNQUFNLEtBQUssSUFBSTtBQUFBLElBQ3ZCO0FBQUEsRUFDSjtBQUNBLEVBQUFBLEtBQUksUUFBUSxDQUFDLEdBQUcsUUFBUSxRQUFRLE1BQU07QUFDdEMsU0FBT0E7QUFDWDs7O0FDcEdBLFNBQVMsZ0JBQWdCLEVBQUUsYUFBQUMsY0FBYSxrQkFBQUMsa0JBQWlCLEdBQUcsS0FBSyxJQUFJLFNBQVM7QUFDMUUsUUFBTUMsT0FBTSxJQUFJLFFBQVEsSUFBSSxNQUFNO0FBQ2xDLE1BQUksSUFBSTtBQUNKLFFBQUksU0FBUztBQUNqQixNQUFJLFNBQVMsR0FBRztBQUNoQixhQUFXLEVBQUUsT0FBTyxNQUFNLEtBQUssR0FBRyxPQUFPO0FBQ3JDLFVBQU0sUUFBUSxhQUFhLE9BQU87QUFBQSxNQUM5QixXQUFXO0FBQUEsTUFDWCxNQUFNO0FBQUEsTUFDTjtBQUFBLE1BQ0E7QUFBQSxNQUNBLGdCQUFnQjtBQUFBLElBQ3BCLENBQUM7QUFDRCxhQUFTLE1BQU07QUFDZixRQUFJLENBQUMsTUFBTSxPQUFPO0FBQ2QsVUFBSSxNQUFNLFVBQVUsTUFBTSxPQUFPLE9BQU87QUFDcEMsWUFBSSxTQUFTLE1BQU0sU0FBUztBQUN4QixrQkFBUSxRQUFRLGNBQWMsa0RBQWtEO0FBQUE7QUFFaEYsa0JBQVEsUUFBUSxnQkFBZ0IsbUNBQW1DO0FBQUEsTUFDM0UsT0FDSztBQUVELFlBQUksTUFBTTtBQUNOLFVBQUFBLEtBQUksVUFBVSxNQUFNO0FBQ3hCO0FBQUEsTUFDSjtBQUFBLElBQ0o7QUFDQSxVQUFNLE9BQU8sUUFDUEYsYUFBWSxLQUFLLE9BQU8sT0FBTyxPQUFPLElBQ3RDQyxrQkFBaUIsS0FBSyxRQUFRLE9BQU8sTUFBTSxPQUFPLE9BQU87QUFDL0QsUUFBSSxJQUFJLE9BQU87QUFDWCxzQkFBZ0IsR0FBRyxRQUFRLE9BQU8sT0FBTztBQUM3QyxhQUFTLEtBQUssTUFBTSxDQUFDO0FBQ3JCLElBQUFDLEtBQUksTUFBTSxLQUFLLElBQUk7QUFBQSxFQUN2QjtBQUNBLEVBQUFBLEtBQUksUUFBUSxDQUFDLEdBQUcsUUFBUSxRQUFRLE1BQU07QUFDdEMsU0FBT0E7QUFDWDs7O0FDMUNBLFNBQVMsV0FBVyxLQUFLLFFBQVEsVUFBVSxTQUFTO0FBQ2hELE1BQUksVUFBVTtBQUNkLE1BQUksS0FBSztBQUNMLFFBQUksV0FBVztBQUNmLFFBQUksTUFBTTtBQUNWLGVBQVcsU0FBUyxLQUFLO0FBQ3JCLFlBQU0sRUFBRSxRQUFRLEtBQUssSUFBSTtBQUN6QixjQUFRLE1BQU07QUFBQSxRQUNWLEtBQUs7QUFDRCxxQkFBVztBQUNYO0FBQUEsUUFDSixLQUFLLFdBQVc7QUFDWixjQUFJLFlBQVksQ0FBQztBQUNiLG9CQUFRLE9BQU8sZ0JBQWdCLHdFQUF3RTtBQUMzRyxnQkFBTSxLQUFLLE9BQU8sVUFBVSxDQUFDLEtBQUs7QUFDbEMsY0FBSSxDQUFDO0FBQ0Qsc0JBQVU7QUFBQTtBQUVWLHVCQUFXLE1BQU07QUFDckIsZ0JBQU07QUFDTjtBQUFBLFFBQ0o7QUFBQSxRQUNBLEtBQUs7QUFDRCxjQUFJO0FBQ0EsbUJBQU87QUFDWCxxQkFBVztBQUNYO0FBQUEsUUFDSjtBQUNJLGtCQUFRLE9BQU8sb0JBQW9CLGNBQWMsa0JBQWtCO0FBQUEsTUFDM0U7QUFDQSxnQkFBVSxPQUFPO0FBQUEsSUFDckI7QUFBQSxFQUNKO0FBQ0EsU0FBTyxFQUFFLFNBQVMsT0FBTztBQUM3Qjs7O0FDekJBLElBQU0sV0FBVztBQUNqQixJQUFNLFVBQVUsQ0FBQyxVQUFVLFVBQVUsTUFBTSxTQUFTLGVBQWUsTUFBTSxTQUFTO0FBQ2xGLFNBQVMsc0JBQXNCLEVBQUUsYUFBQUMsY0FBYSxrQkFBQUMsa0JBQWlCLEdBQUcsS0FBSyxJQUFJLFNBQVM7QUFDaEYsUUFBTUMsU0FBUSxHQUFHLE1BQU0sV0FBVztBQUNsQyxRQUFNLFNBQVNBLFNBQVEsYUFBYTtBQUNwQyxRQUFNLE9BQU9BLFNBQ1AsSUFBSSxRQUFRLElBQUksTUFBTSxJQUN0QixJQUFJLFFBQVEsSUFBSSxNQUFNO0FBQzVCLE9BQUssT0FBTztBQUNaLFFBQU0sU0FBUyxJQUFJO0FBQ25CLE1BQUk7QUFDQSxRQUFJLFNBQVM7QUFDakIsTUFBSSxTQUFTLEdBQUcsU0FBUyxHQUFHLE1BQU0sT0FBTztBQUN6QyxXQUFTLElBQUksR0FBRyxJQUFJLEdBQUcsTUFBTSxRQUFRLEVBQUUsR0FBRztBQUN0QyxVQUFNLFdBQVcsR0FBRyxNQUFNLENBQUM7QUFDM0IsVUFBTSxFQUFFLE9BQU8sS0FBSyxLQUFLLE1BQU0sSUFBSTtBQUNuQyxVQUFNLFFBQVEsYUFBYSxPQUFPO0FBQUEsTUFDOUIsTUFBTTtBQUFBLE1BQ04sV0FBVztBQUFBLE1BQ1gsTUFBTSxRQUFRLFFBQVEsUUFBUSxRQUFRLFNBQVMsU0FBUyxJQUFJLENBQUM7QUFBQSxNQUM3RDtBQUFBLE1BQ0E7QUFBQSxNQUNBLGdCQUFnQjtBQUFBLElBQ3BCLENBQUM7QUFDRCxRQUFJLENBQUMsTUFBTSxPQUFPO0FBQ2QsVUFBSSxDQUFDLE1BQU0sVUFBVSxDQUFDLE1BQU0sT0FBTyxDQUFDLE9BQU8sQ0FBQyxPQUFPO0FBQy9DLFlBQUksTUFBTSxLQUFLLE1BQU07QUFDakIsa0JBQVEsTUFBTSxPQUFPLG9CQUFvQixtQkFBbUIsUUFBUTtBQUFBLGlCQUMvRCxJQUFJLEdBQUcsTUFBTSxTQUFTO0FBQzNCLGtCQUFRLE1BQU0sT0FBTyxvQkFBb0IsNEJBQTRCLFFBQVE7QUFDakYsWUFBSSxNQUFNLFNBQVM7QUFDZixjQUFJLEtBQUs7QUFDTCxpQkFBSyxXQUFXLE9BQU8sTUFBTTtBQUFBO0FBRTdCLGlCQUFLLFVBQVUsTUFBTTtBQUFBLFFBQzdCO0FBQ0EsaUJBQVMsTUFBTTtBQUNmO0FBQUEsTUFDSjtBQUNBLFVBQUksQ0FBQ0EsVUFBUyxJQUFJLFFBQVEsVUFBVSxnQkFBZ0IsR0FBRztBQUNuRDtBQUFBLFVBQVE7QUFBQTtBQUFBLFVBQ1I7QUFBQSxVQUEwQjtBQUFBLFFBQWtFO0FBQUEsSUFDcEc7QUFDQSxRQUFJLE1BQU0sR0FBRztBQUNULFVBQUksTUFBTTtBQUNOLGdCQUFRLE1BQU0sT0FBTyxvQkFBb0IsbUJBQW1CLFFBQVE7QUFBQSxJQUM1RSxPQUNLO0FBQ0QsVUFBSSxDQUFDLE1BQU07QUFDUCxnQkFBUSxNQUFNLE9BQU8sZ0JBQWdCLHFCQUFxQixjQUFjO0FBQzVFLFVBQUksTUFBTSxTQUFTO0FBQ2YsWUFBSSxrQkFBa0I7QUFDdEI7QUFBTSxxQkFBVyxNQUFNLE9BQU87QUFDMUIsb0JBQVEsR0FBRyxNQUFNO0FBQUEsY0FDYixLQUFLO0FBQUEsY0FDTCxLQUFLO0FBQ0Q7QUFBQSxjQUNKLEtBQUs7QUFDRCxrQ0FBa0IsR0FBRyxPQUFPLFVBQVUsQ0FBQztBQUN2QyxzQkFBTTtBQUFBLGNBQ1Y7QUFDSSxzQkFBTTtBQUFBLFlBQ2Q7QUFBQSxVQUNKO0FBQ0EsWUFBSSxpQkFBaUI7QUFDakIsY0FBSSxPQUFPLEtBQUssTUFBTSxLQUFLLE1BQU0sU0FBUyxDQUFDO0FBQzNDLGNBQUksT0FBTyxJQUFJO0FBQ1gsbUJBQU8sS0FBSyxTQUFTLEtBQUs7QUFDOUIsY0FBSSxLQUFLO0FBQ0wsaUJBQUssV0FBVyxPQUFPO0FBQUE7QUFFdkIsaUJBQUssVUFBVTtBQUNuQixnQkFBTSxVQUFVLE1BQU0sUUFBUSxVQUFVLGdCQUFnQixTQUFTLENBQUM7QUFBQSxRQUN0RTtBQUFBLE1BQ0o7QUFBQSxJQUNKO0FBQ0EsUUFBSSxDQUFDQSxVQUFTLENBQUMsT0FBTyxDQUFDLE1BQU0sT0FBTztBQUdoQyxZQUFNLFlBQVksUUFDWkYsYUFBWSxLQUFLLE9BQU8sT0FBTyxPQUFPLElBQ3RDQyxrQkFBaUIsS0FBSyxNQUFNLEtBQUssS0FBSyxNQUFNLE9BQU8sT0FBTztBQUNoRSxXQUFLLE1BQU0sS0FBSyxTQUFTO0FBQ3pCLGVBQVMsVUFBVSxNQUFNLENBQUM7QUFDMUIsVUFBSSxRQUFRLEtBQUs7QUFDYixnQkFBUSxVQUFVLE9BQU8saUJBQWlCLFFBQVE7QUFBQSxJQUMxRCxPQUNLO0FBR0QsWUFBTSxXQUFXLE1BQU07QUFDdkIsWUFBTSxVQUFVLE1BQ1ZELGFBQVksS0FBSyxLQUFLLE9BQU8sT0FBTyxJQUNwQ0Msa0JBQWlCLEtBQUssVUFBVSxPQUFPLE1BQU0sT0FBTyxPQUFPO0FBQ2pFLFVBQUksUUFBUSxHQUFHO0FBQ1gsZ0JBQVEsUUFBUSxPQUFPLGlCQUFpQixRQUFRO0FBRXBELFlBQU0sYUFBYSxhQUFhLE9BQU8sQ0FBQyxHQUFHO0FBQUEsUUFDdkMsTUFBTTtBQUFBLFFBQ04sV0FBVztBQUFBLFFBQ1gsTUFBTTtBQUFBLFFBQ04sUUFBUSxRQUFRLE1BQU0sQ0FBQztBQUFBLFFBQ3ZCO0FBQUEsUUFDQSxnQkFBZ0I7QUFBQSxNQUNwQixDQUFDO0FBQ0QsVUFBSSxXQUFXLE9BQU87QUFDbEIsWUFBSSxDQUFDQyxVQUFTLENBQUMsTUFBTSxTQUFTLElBQUksUUFBUSxRQUFRO0FBQzlDLGNBQUk7QUFDQSx1QkFBVyxNQUFNLEtBQUs7QUFDbEIsa0JBQUksT0FBTyxXQUFXO0FBQ2xCO0FBQ0osa0JBQUksR0FBRyxTQUFTLFdBQVc7QUFDdkIsd0JBQVEsSUFBSSwwQkFBMEIsa0VBQWtFO0FBQ3hHO0FBQUEsY0FDSjtBQUFBLFlBQ0o7QUFDSixjQUFJLE1BQU0sUUFBUSxXQUFXLE1BQU0sU0FBUztBQUN4QyxvQkFBUSxXQUFXLE9BQU8sdUJBQXVCLDZGQUE2RjtBQUFBLFFBQ3RKO0FBQUEsTUFDSixXQUNTLE9BQU87QUFDWixZQUFJLFlBQVksU0FBUyxNQUFNLFVBQVUsTUFBTSxPQUFPLENBQUMsTUFBTTtBQUN6RCxrQkFBUSxPQUFPLGdCQUFnQiw0QkFBNEIsUUFBUTtBQUFBO0FBRW5FLGtCQUFRLFdBQVcsT0FBTyxnQkFBZ0IsMEJBQTBCLGNBQWM7QUFBQSxNQUMxRjtBQUVBLFlBQU0sWUFBWSxRQUNaRixhQUFZLEtBQUssT0FBTyxZQUFZLE9BQU8sSUFDM0MsV0FBVyxRQUNQQyxrQkFBaUIsS0FBSyxXQUFXLEtBQUssS0FBSyxNQUFNLFlBQVksT0FBTyxJQUNwRTtBQUNWLFVBQUksV0FBVztBQUNYLFlBQUksUUFBUSxLQUFLO0FBQ2Isa0JBQVEsVUFBVSxPQUFPLGlCQUFpQixRQUFRO0FBQUEsTUFDMUQsV0FDUyxXQUFXLFNBQVM7QUFDekIsWUFBSSxRQUFRO0FBQ1Isa0JBQVEsV0FBVyxPQUFPLFdBQVc7QUFBQTtBQUVyQyxrQkFBUSxVQUFVLFdBQVc7QUFBQSxNQUNyQztBQUNBLFlBQU0sT0FBTyxJQUFJLEtBQUssU0FBUyxTQUFTO0FBQ3hDLFVBQUksSUFBSSxRQUFRO0FBQ1osYUFBSyxXQUFXO0FBQ3BCLFVBQUlDLFFBQU87QUFDUCxjQUFNQyxPQUFNO0FBQ1osWUFBSSxZQUFZLEtBQUtBLEtBQUksT0FBTyxPQUFPO0FBQ25DLGtCQUFRLFVBQVUsaUJBQWlCLHlCQUF5QjtBQUNoRSxRQUFBQSxLQUFJLE1BQU0sS0FBSyxJQUFJO0FBQUEsTUFDdkIsT0FDSztBQUNELGNBQU1BLE9BQU0sSUFBSSxRQUFRLElBQUksTUFBTTtBQUNsQyxRQUFBQSxLQUFJLE9BQU87QUFDWCxRQUFBQSxLQUFJLE1BQU0sS0FBSyxJQUFJO0FBQ25CLGFBQUssTUFBTSxLQUFLQSxJQUFHO0FBQUEsTUFDdkI7QUFDQSxlQUFTLFlBQVksVUFBVSxNQUFNLENBQUMsSUFBSSxXQUFXO0FBQUEsSUFDekQ7QUFBQSxFQUNKO0FBQ0EsUUFBTSxjQUFjRCxTQUFRLE1BQU07QUFDbEMsUUFBTSxDQUFDLElBQUksR0FBRyxFQUFFLElBQUksR0FBRztBQUN2QixNQUFJLFFBQVE7QUFDWixNQUFJLE1BQU0sR0FBRyxXQUFXO0FBQ3BCLFlBQVEsR0FBRyxTQUFTLEdBQUcsT0FBTztBQUFBLE9BQzdCO0FBQ0QsVUFBTSxPQUFPLE9BQU8sQ0FBQyxFQUFFLFlBQVksSUFBSSxPQUFPLFVBQVUsQ0FBQztBQUN6RCxVQUFNLE1BQU0sU0FDTixHQUFHLHdCQUF3QixnQkFDM0IsR0FBRyx5RUFBeUU7QUFDbEYsWUFBUSxRQUFRLFNBQVMsaUJBQWlCLGNBQWMsR0FBRztBQUMzRCxRQUFJLE1BQU0sR0FBRyxPQUFPLFdBQVc7QUFDM0IsU0FBRyxRQUFRLEVBQUU7QUFBQSxFQUNyQjtBQUNBLE1BQUksR0FBRyxTQUFTLEdBQUc7QUFDZixVQUFNLE1BQU0sV0FBVyxJQUFJLE9BQU8sSUFBSSxRQUFRLFFBQVEsT0FBTztBQUM3RCxRQUFJLElBQUksU0FBUztBQUNiLFVBQUksS0FBSztBQUNMLGFBQUssV0FBVyxPQUFPLElBQUk7QUFBQTtBQUUzQixhQUFLLFVBQVUsSUFBSTtBQUFBLElBQzNCO0FBQ0EsU0FBSyxRQUFRLENBQUMsR0FBRyxRQUFRLE9BQU8sSUFBSSxNQUFNO0FBQUEsRUFDOUMsT0FDSztBQUNELFNBQUssUUFBUSxDQUFDLEdBQUcsUUFBUSxPQUFPLEtBQUs7QUFBQSxFQUN6QztBQUNBLFNBQU87QUFDWDs7O0FDL0xBLFNBQVMsa0JBQWtCRSxLQUFJLEtBQUssT0FBTyxVQUFVLFNBQVM7QUFDMUQsTUFBSTtBQUNKLFVBQVEsTUFBTSxNQUFNO0FBQUEsSUFDaEIsS0FBSyxhQUFhO0FBQ2QsYUFBTyxnQkFBZ0JBLEtBQUksS0FBSyxPQUFPLE9BQU87QUFDOUM7QUFBQSxJQUNKO0FBQUEsSUFDQSxLQUFLLGFBQWE7QUFDZCxhQUFPLGdCQUFnQkEsS0FBSSxLQUFLLE9BQU8sT0FBTztBQUM5QztBQUFBLElBQ0o7QUFBQSxJQUNBLEtBQUssbUJBQW1CO0FBQ3BCLGFBQU8sc0JBQXNCQSxLQUFJLEtBQUssT0FBTyxPQUFPO0FBQ3BEO0FBQUEsSUFDSjtBQUFBLEVBQ0o7QUFDQSxNQUFJLENBQUM7QUFDRCxXQUFPO0FBQ1gsUUFBTSxVQUFVLElBQUksV0FBVyxRQUFRLFNBQVMsUUFBUSxTQUFPLFFBQVEsVUFBVSxzQkFBc0IsR0FBRyxDQUFDO0FBQzNHLE1BQUksQ0FBQztBQUNELFdBQU87QUFFWCxRQUFNLE9BQU8sS0FBSztBQUNsQixNQUFJLFlBQVksT0FBTyxZQUFZLEtBQUssU0FBUztBQUM3QyxTQUFLLE1BQU0sS0FBSztBQUNoQixXQUFPO0FBQUEsRUFDWDtBQUNBLFFBQU0sVUFBVSxNQUFNLElBQUksSUFBSSxRQUFRO0FBQ3RDLE1BQUlDLE9BQU0sSUFBSSxPQUFPLEtBQUssS0FBSyxPQUFLLEVBQUUsZUFBZSxXQUFXLEVBQUUsUUFBUSxPQUFPO0FBQ2pGLE1BQUksQ0FBQ0EsTUFBSztBQUNOLFVBQU0sS0FBSyxJQUFJLE9BQU8sVUFBVSxPQUFPO0FBQ3ZDLFFBQUksTUFBTSxHQUFHLGVBQWUsU0FBUztBQUNqQyxVQUFJLE9BQU8sS0FBSyxLQUFLLE9BQU8sT0FBTyxDQUFDLEdBQUcsSUFBSSxFQUFFLFNBQVMsTUFBTSxDQUFDLENBQUM7QUFDOUQsTUFBQUEsT0FBTTtBQUFBLElBQ1YsT0FDSztBQUNELGNBQVEsVUFBVSxzQkFBc0IsbUJBQW1CLFdBQVcsSUFBSTtBQUMxRSxXQUFLLE1BQU07QUFDWCxhQUFPO0FBQUEsSUFDWDtBQUFBLEVBQ0o7QUFDQSxRQUFNLE1BQU1BLEtBQUksUUFBUSxNQUFNLFNBQU8sUUFBUSxVQUFVLHNCQUFzQixHQUFHLEdBQUcsSUFBSSxPQUFPO0FBQzlGLFFBQU0sT0FBTyxPQUFPLEdBQUcsSUFDakIsTUFDQSxJQUFJLE9BQU8sR0FBRztBQUNwQixPQUFLLFFBQVEsS0FBSztBQUNsQixPQUFLLE1BQU07QUFDWCxNQUFJQSxTQUFRLFFBQVFBLFNBQVEsU0FBUyxTQUFTQSxLQUFJO0FBQzlDLFNBQUssU0FBU0EsS0FBSTtBQUN0QixTQUFPO0FBQ1g7OztBQ3REQSxTQUFTLG1CQUFtQixRQUFRLFFBQVEsU0FBUztBQUNqRCxRQUFNLFFBQVEsT0FBTztBQUNyQixRQUFNLFNBQVMsdUJBQXVCLFFBQVEsUUFBUSxPQUFPO0FBQzdELE1BQUksQ0FBQztBQUNELFdBQU8sRUFBRSxPQUFPLElBQUksTUFBTSxNQUFNLFNBQVMsSUFBSSxPQUFPLENBQUMsT0FBTyxPQUFPLEtBQUssRUFBRTtBQUM5RSxRQUFNLE9BQU8sT0FBTyxTQUFTLE1BQU0sT0FBTyxlQUFlLE9BQU87QUFDaEUsUUFBTSxRQUFRLE9BQU8sU0FBUyxXQUFXLE9BQU8sTUFBTSxJQUFJLENBQUM7QUFFM0QsTUFBSSxhQUFhLE1BQU07QUFDdkIsV0FBUyxJQUFJLE1BQU0sU0FBUyxHQUFHLEtBQUssR0FBRyxFQUFFLEdBQUc7QUFDeEMsVUFBTSxVQUFVLE1BQU0sQ0FBQyxFQUFFLENBQUM7QUFDMUIsUUFBSSxZQUFZLE1BQU0sWUFBWTtBQUM5QixtQkFBYTtBQUFBO0FBRWI7QUFBQSxFQUNSO0FBRUEsTUFBSSxDQUFDLE9BQU8sVUFBVSxlQUFlLEdBQUc7QUFDcEMsVUFBTUMsU0FBUSxPQUFPLFVBQVUsTUFBTSxLQUFLLE9BQU8sS0FBSyxJQUFJLEdBQUcsTUFBTSxTQUFTLENBQUMsQ0FBQyxJQUFJO0FBQ2xGLFFBQUlDLE9BQU0sUUFBUSxPQUFPO0FBQ3pCLFFBQUksT0FBTztBQUNQLE1BQUFBLFFBQU8sT0FBTyxPQUFPO0FBQ3pCLFdBQU8sRUFBRSxPQUFBRCxRQUFPLE1BQU0sU0FBUyxPQUFPLFNBQVMsT0FBTyxDQUFDLE9BQU9DLE1BQUtBLElBQUcsRUFBRTtBQUFBLEVBQzVFO0FBRUEsTUFBSSxhQUFhLE9BQU8sU0FBUyxPQUFPO0FBQ3hDLE1BQUksU0FBUyxPQUFPLFNBQVMsT0FBTztBQUNwQyxNQUFJLGVBQWU7QUFDbkIsV0FBUyxJQUFJLEdBQUcsSUFBSSxZQUFZLEVBQUUsR0FBRztBQUNqQyxVQUFNLENBQUMsUUFBUSxPQUFPLElBQUksTUFBTSxDQUFDO0FBQ2pDLFFBQUksWUFBWSxNQUFNLFlBQVksTUFBTTtBQUNwQyxVQUFJLE9BQU8sV0FBVyxLQUFLLE9BQU8sU0FBUztBQUN2QyxxQkFBYSxPQUFPO0FBQUEsSUFDNUIsT0FDSztBQUNELFVBQUksT0FBTyxTQUFTLFlBQVk7QUFDNUIsY0FBTSxVQUFVO0FBQ2hCLGdCQUFRLFNBQVMsT0FBTyxRQUFRLGdCQUFnQixPQUFPO0FBQUEsTUFDM0Q7QUFDQSxVQUFJLE9BQU8sV0FBVztBQUNsQixxQkFBYSxPQUFPO0FBQ3hCLHFCQUFlO0FBQ2Y7QUFBQSxJQUNKO0FBQ0EsY0FBVSxPQUFPLFNBQVMsUUFBUSxTQUFTO0FBQUEsRUFDL0M7QUFDQSxNQUFJLFFBQVE7QUFDWixNQUFJLE1BQU07QUFDVixNQUFJLG1CQUFtQjtBQUV2QixXQUFTLElBQUksR0FBRyxJQUFJLGNBQWMsRUFBRTtBQUNoQyxhQUFTLE1BQU0sQ0FBQyxFQUFFLENBQUMsRUFBRSxNQUFNLFVBQVUsSUFBSTtBQUM3QyxXQUFTLElBQUksY0FBYyxJQUFJLFlBQVksRUFBRSxHQUFHO0FBQzVDLFFBQUksQ0FBQyxRQUFRLE9BQU8sSUFBSSxNQUFNLENBQUM7QUFDL0IsY0FBVSxPQUFPLFNBQVMsUUFBUSxTQUFTO0FBQzNDLFVBQU0sT0FBTyxRQUFRLFFBQVEsU0FBUyxDQUFDLE1BQU07QUFDN0MsUUFBSTtBQUNBLGdCQUFVLFFBQVEsTUFBTSxHQUFHLEVBQUU7QUFFakMsUUFBSSxXQUFXLE9BQU8sU0FBUyxZQUFZO0FBQ3ZDLFlBQU0sTUFBTSxPQUFPLFNBQ2IsbUNBQ0E7QUFDTixZQUFNLFVBQVUsMkRBQTJEO0FBQzNFLGNBQVEsU0FBUyxRQUFRLFVBQVUsT0FBTyxJQUFJLElBQUksY0FBYyxPQUFPO0FBQ3ZFLGVBQVM7QUFBQSxJQUNiO0FBQ0EsUUFBSSxTQUFTLE9BQU8sZUFBZTtBQUMvQixlQUFTLE1BQU0sT0FBTyxNQUFNLFVBQVUsSUFBSTtBQUMxQyxZQUFNO0FBQUEsSUFDVixXQUNTLE9BQU8sU0FBUyxjQUFjLFFBQVEsQ0FBQyxNQUFNLEtBQU07QUFFeEQsVUFBSSxRQUFRO0FBQ1IsY0FBTTtBQUFBLGVBQ0QsQ0FBQyxvQkFBb0IsUUFBUTtBQUNsQyxjQUFNO0FBQ1YsZUFBUyxNQUFNLE9BQU8sTUFBTSxVQUFVLElBQUk7QUFDMUMsWUFBTTtBQUNOLHlCQUFtQjtBQUFBLElBQ3ZCLFdBQ1MsWUFBWSxJQUFJO0FBRXJCLFVBQUksUUFBUTtBQUNSLGlCQUFTO0FBQUE7QUFFVCxjQUFNO0FBQUEsSUFDZCxPQUNLO0FBQ0QsZUFBUyxNQUFNO0FBQ2YsWUFBTTtBQUNOLHlCQUFtQjtBQUFBLElBQ3ZCO0FBQUEsRUFDSjtBQUNBLFVBQVEsT0FBTyxPQUFPO0FBQUEsSUFDbEIsS0FBSztBQUNEO0FBQUEsSUFDSixLQUFLO0FBQ0QsZUFBUyxJQUFJLFlBQVksSUFBSSxNQUFNLFFBQVEsRUFBRTtBQUN6QyxpQkFBUyxPQUFPLE1BQU0sQ0FBQyxFQUFFLENBQUMsRUFBRSxNQUFNLFVBQVU7QUFDaEQsVUFBSSxNQUFNLE1BQU0sU0FBUyxDQUFDLE1BQU07QUFDNUIsaUJBQVM7QUFDYjtBQUFBLElBQ0o7QUFDSSxlQUFTO0FBQUEsRUFDakI7QUFDQSxRQUFNLE1BQU0sUUFBUSxPQUFPLFNBQVMsT0FBTyxPQUFPO0FBQ2xELFNBQU8sRUFBRSxPQUFPLE1BQU0sU0FBUyxPQUFPLFNBQVMsT0FBTyxDQUFDLE9BQU8sS0FBSyxHQUFHLEVBQUU7QUFDNUU7QUFDQSxTQUFTLHVCQUF1QixFQUFFLFFBQVEsTUFBTSxHQUFHLFFBQVEsU0FBUztBQUVoRSxNQUFJLE1BQU0sQ0FBQyxFQUFFLFNBQVMsdUJBQXVCO0FBQ3pDLFlBQVEsTUFBTSxDQUFDLEdBQUcsY0FBYywrQkFBK0I7QUFDL0QsV0FBTztBQUFBLEVBQ1g7QUFDQSxRQUFNLEVBQUUsT0FBTyxJQUFJLE1BQU0sQ0FBQztBQUMxQixRQUFNLE9BQU8sT0FBTyxDQUFDO0FBQ3JCLE1BQUksU0FBUztBQUNiLE1BQUksUUFBUTtBQUNaLE1BQUksUUFBUTtBQUNaLFdBQVMsSUFBSSxHQUFHLElBQUksT0FBTyxRQUFRLEVBQUUsR0FBRztBQUNwQyxVQUFNLEtBQUssT0FBTyxDQUFDO0FBQ25CLFFBQUksQ0FBQyxVQUFVLE9BQU8sT0FBTyxPQUFPO0FBQ2hDLGNBQVE7QUFBQSxTQUNQO0FBQ0QsWUFBTSxJQUFJLE9BQU8sRUFBRTtBQUNuQixVQUFJLENBQUMsVUFBVTtBQUNYLGlCQUFTO0FBQUEsZUFDSixVQUFVO0FBQ2YsZ0JBQVEsU0FBUztBQUFBLElBQ3pCO0FBQUEsRUFDSjtBQUNBLE1BQUksVUFBVTtBQUNWLFlBQVEsT0FBTyxvQkFBb0Isa0RBQWtELFFBQVE7QUFDakcsTUFBSSxXQUFXO0FBQ2YsTUFBSSxVQUFVO0FBQ2QsTUFBSSxTQUFTLE9BQU87QUFDcEIsV0FBUyxJQUFJLEdBQUcsSUFBSSxNQUFNLFFBQVEsRUFBRSxHQUFHO0FBQ25DLFVBQU0sUUFBUSxNQUFNLENBQUM7QUFDckIsWUFBUSxNQUFNLE1BQU07QUFBQSxNQUNoQixLQUFLO0FBQ0QsbUJBQVc7QUFBQSxNQUVmLEtBQUs7QUFDRCxrQkFBVSxNQUFNLE9BQU87QUFDdkI7QUFBQSxNQUNKLEtBQUs7QUFDRCxZQUFJLFVBQVUsQ0FBQyxVQUFVO0FBQ3JCLGdCQUFNLFVBQVU7QUFDaEIsa0JBQVEsT0FBTyxnQkFBZ0IsT0FBTztBQUFBLFFBQzFDO0FBQ0Esa0JBQVUsTUFBTSxPQUFPO0FBQ3ZCLGtCQUFVLE1BQU0sT0FBTyxVQUFVLENBQUM7QUFDbEM7QUFBQSxNQUNKLEtBQUs7QUFDRCxnQkFBUSxPQUFPLG9CQUFvQixNQUFNLE9BQU87QUFDaEQsa0JBQVUsTUFBTSxPQUFPO0FBQ3ZCO0FBQUEsTUFFSixTQUFTO0FBQ0wsY0FBTSxVQUFVLDRDQUE0QyxNQUFNO0FBQ2xFLGdCQUFRLE9BQU8sb0JBQW9CLE9BQU87QUFDMUMsY0FBTSxLQUFLLE1BQU07QUFDakIsWUFBSSxNQUFNLE9BQU8sT0FBTztBQUNwQixvQkFBVSxHQUFHO0FBQUEsTUFDckI7QUFBQSxJQUNKO0FBQUEsRUFDSjtBQUNBLFNBQU8sRUFBRSxNQUFNLFFBQVEsT0FBTyxTQUFTLE9BQU87QUFDbEQ7QUFFQSxTQUFTLFdBQVcsUUFBUTtBQUN4QixRQUFNLFFBQVEsT0FBTyxNQUFNLFFBQVE7QUFDbkMsUUFBTSxRQUFRLE1BQU0sQ0FBQztBQUNyQixRQUFNLElBQUksTUFBTSxNQUFNLE9BQU87QUFDN0IsUUFBTSxRQUFRLEtBQUssRUFBRSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsR0FBRyxNQUFNLE1BQU0sRUFBRSxDQUFDLEVBQUUsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLEtBQUs7QUFDdkUsUUFBTSxRQUFRLENBQUMsS0FBSztBQUNwQixXQUFTLElBQUksR0FBRyxJQUFJLE1BQU0sUUFBUSxLQUFLO0FBQ25DLFVBQU0sS0FBSyxDQUFDLE1BQU0sQ0FBQyxHQUFHLE1BQU0sSUFBSSxDQUFDLENBQUMsQ0FBQztBQUN2QyxTQUFPO0FBQ1g7OztBQ25MQSxTQUFTLGtCQUFrQixRQUFRLFFBQVEsU0FBUztBQUNoRCxRQUFNLEVBQUUsUUFBUSxNQUFNLFFBQVEsSUFBSSxJQUFJO0FBQ3RDLE1BQUk7QUFDSixNQUFJO0FBQ0osUUFBTSxXQUFXLENBQUMsS0FBSyxNQUFNLFFBQVEsUUFBUSxTQUFTLEtBQUssTUFBTSxHQUFHO0FBQ3BFLFVBQVEsTUFBTTtBQUFBLElBQ1YsS0FBSztBQUNELGNBQVEsT0FBTztBQUNmLGNBQVEsV0FBVyxRQUFRLFFBQVE7QUFDbkM7QUFBQSxJQUNKLEtBQUs7QUFDRCxjQUFRLE9BQU87QUFDZixjQUFRLGtCQUFrQixRQUFRLFFBQVE7QUFDMUM7QUFBQSxJQUNKLEtBQUs7QUFDRCxjQUFRLE9BQU87QUFDZixjQUFRLGtCQUFrQixRQUFRLFFBQVE7QUFDMUM7QUFBQSxJQUVKO0FBQ0ksY0FBUSxRQUFRLG9CQUFvQiw0Q0FBNEMsTUFBTTtBQUN0RixhQUFPO0FBQUEsUUFDSCxPQUFPO0FBQUEsUUFDUCxNQUFNO0FBQUEsUUFDTixTQUFTO0FBQUEsUUFDVCxPQUFPLENBQUMsUUFBUSxTQUFTLE9BQU8sUUFBUSxTQUFTLE9BQU8sTUFBTTtBQUFBLE1BQ2xFO0FBQUEsRUFDUjtBQUNBLFFBQU0sV0FBVyxTQUFTLE9BQU87QUFDakMsUUFBTSxLQUFLLFdBQVcsS0FBSyxVQUFVLFFBQVEsT0FBTztBQUNwRCxTQUFPO0FBQUEsSUFDSDtBQUFBLElBQ0EsTUFBTTtBQUFBLElBQ04sU0FBUyxHQUFHO0FBQUEsSUFDWixPQUFPLENBQUMsUUFBUSxVQUFVLEdBQUcsTUFBTTtBQUFBLEVBQ3ZDO0FBQ0o7QUFDQSxTQUFTLFdBQVcsUUFBUSxTQUFTO0FBQ2pDLE1BQUksVUFBVTtBQUNkLFVBQVEsT0FBTyxDQUFDLEdBQUc7QUFBQSxJQUVmLEtBQUs7QUFDRCxnQkFBVTtBQUNWO0FBQUEsSUFDSixLQUFLO0FBQ0QsZ0JBQVU7QUFDVjtBQUFBLElBQ0osS0FBSztBQUNELGdCQUFVO0FBQ1Y7QUFBQSxJQUNKLEtBQUs7QUFBQSxJQUNMLEtBQUssS0FBSztBQUNOLGdCQUFVLDBCQUEwQixPQUFPLENBQUM7QUFDNUM7QUFBQSxJQUNKO0FBQUEsSUFDQSxLQUFLO0FBQUEsSUFDTCxLQUFLLEtBQUs7QUFDTixnQkFBVSxzQkFBc0IsT0FBTyxDQUFDO0FBQ3hDO0FBQUEsSUFDSjtBQUFBLEVBQ0o7QUFDQSxNQUFJO0FBQ0EsWUFBUSxHQUFHLG9CQUFvQixpQ0FBaUMsU0FBUztBQUM3RSxTQUFPLFVBQVUsTUFBTTtBQUMzQjtBQUNBLFNBQVMsa0JBQWtCLFFBQVEsU0FBUztBQUN4QyxNQUFJLE9BQU8sT0FBTyxTQUFTLENBQUMsTUFBTSxPQUFPLE9BQU8sV0FBVztBQUN2RCxZQUFRLE9BQU8sUUFBUSxnQkFBZ0Isd0JBQXdCO0FBQ25FLFNBQU8sVUFBVSxPQUFPLE1BQU0sR0FBRyxFQUFFLENBQUMsRUFBRSxRQUFRLE9BQU8sR0FBRztBQUM1RDtBQUNBLFNBQVMsVUFBVSxRQUFRO0FBUXZCLE1BQUksT0FBTztBQUNYLE1BQUk7QUFDQSxZQUFRLElBQUksT0FBTyw0QkFBOEIsSUFBSTtBQUNyRCxXQUFPLElBQUksT0FBTyxzQ0FBeUMsSUFBSTtBQUFBLEVBQ25FLFNBQ08sR0FBUDtBQUNJLFlBQVE7QUFDUixXQUFPO0FBQUEsRUFDWDtBQUNBLE1BQUksUUFBUSxNQUFNLEtBQUssTUFBTTtBQUM3QixNQUFJLENBQUM7QUFDRCxXQUFPO0FBQ1gsTUFBSSxNQUFNLE1BQU0sQ0FBQztBQUNqQixNQUFJLE1BQU07QUFDVixNQUFJLE1BQU0sTUFBTTtBQUNoQixPQUFLLFlBQVk7QUFDakIsU0FBUSxRQUFRLEtBQUssS0FBSyxNQUFNLEdBQUk7QUFDaEMsUUFBSSxNQUFNLENBQUMsTUFBTSxJQUFJO0FBQ2pCLFVBQUksUUFBUTtBQUNSLGVBQU87QUFBQTtBQUVQLGNBQU07QUFBQSxJQUNkLE9BQ0s7QUFDRCxhQUFPLE1BQU0sTUFBTSxDQUFDO0FBQ3BCLFlBQU07QUFBQSxJQUNWO0FBQ0EsVUFBTSxLQUFLO0FBQUEsRUFDZjtBQUNBLFFBQU0sT0FBTztBQUNiLE9BQUssWUFBWTtBQUNqQixVQUFRLEtBQUssS0FBSyxNQUFNO0FBQ3hCLFNBQU8sTUFBTSxPQUFRLFNBQVMsTUFBTSxDQUFDLEtBQU07QUFDL0M7QUFDQSxTQUFTLGtCQUFrQixRQUFRLFNBQVM7QUFDeEMsTUFBSSxNQUFNO0FBQ1YsV0FBUyxJQUFJLEdBQUcsSUFBSSxPQUFPLFNBQVMsR0FBRyxFQUFFLEdBQUc7QUFDeEMsVUFBTSxLQUFLLE9BQU8sQ0FBQztBQUNuQixRQUFJLE9BQU8sUUFBUSxPQUFPLElBQUksQ0FBQyxNQUFNO0FBQ2pDO0FBQ0osUUFBSSxPQUFPLE1BQU07QUFDYixZQUFNLEVBQUUsTUFBTSxPQUFPLElBQUksWUFBWSxRQUFRLENBQUM7QUFDOUMsYUFBTztBQUNQLFVBQUk7QUFBQSxJQUNSLFdBQ1MsT0FBTyxNQUFNO0FBQ2xCLFVBQUksT0FBTyxPQUFPLEVBQUUsQ0FBQztBQUNyQixZQUFNLEtBQUssWUFBWSxJQUFJO0FBQzNCLFVBQUk7QUFDQSxlQUFPO0FBQUEsZUFDRixTQUFTLE1BQU07QUFFcEIsZUFBTyxPQUFPLElBQUksQ0FBQztBQUNuQixlQUFPLFNBQVMsT0FBTyxTQUFTO0FBQzVCLGlCQUFPLE9BQU8sRUFBRSxJQUFJLENBQUM7QUFBQSxNQUM3QixXQUNTLFNBQVMsUUFBUSxPQUFPLElBQUksQ0FBQyxNQUFNLE1BQU07QUFFOUMsZUFBTyxPQUFPLEVBQUUsSUFBSSxDQUFDO0FBQ3JCLGVBQU8sU0FBUyxPQUFPLFNBQVM7QUFDNUIsaUJBQU8sT0FBTyxFQUFFLElBQUksQ0FBQztBQUFBLE1BQzdCLFdBQ1MsU0FBUyxPQUFPLFNBQVMsT0FBTyxTQUFTLEtBQUs7QUFDbkQsY0FBTSxTQUFTLEVBQUUsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEVBQUUsRUFBRSxJQUFJO0FBQ3hDLGVBQU8sY0FBYyxRQUFRLElBQUksR0FBRyxRQUFRLE9BQU87QUFDbkQsYUFBSztBQUFBLE1BQ1QsT0FDSztBQUNELGNBQU0sTUFBTSxPQUFPLE9BQU8sSUFBSSxHQUFHLENBQUM7QUFDbEMsZ0JBQVEsSUFBSSxHQUFHLGlCQUFpQiwyQkFBMkIsS0FBSztBQUNoRSxlQUFPO0FBQUEsTUFDWDtBQUFBLElBQ0osV0FDUyxPQUFPLE9BQU8sT0FBTyxLQUFNO0FBRWhDLFlBQU0sVUFBVTtBQUNoQixVQUFJLE9BQU8sT0FBTyxJQUFJLENBQUM7QUFDdkIsYUFBTyxTQUFTLE9BQU8sU0FBUztBQUM1QixlQUFPLE9BQU8sRUFBRSxJQUFJLENBQUM7QUFDekIsVUFBSSxTQUFTLFFBQVEsRUFBRSxTQUFTLFFBQVEsT0FBTyxJQUFJLENBQUMsTUFBTTtBQUN0RCxlQUFPLElBQUksVUFBVSxPQUFPLE1BQU0sU0FBUyxJQUFJLENBQUMsSUFBSTtBQUFBLElBQzVELE9BQ0s7QUFDRCxhQUFPO0FBQUEsSUFDWDtBQUFBLEVBQ0o7QUFDQSxNQUFJLE9BQU8sT0FBTyxTQUFTLENBQUMsTUFBTSxPQUFPLE9BQU8sV0FBVztBQUN2RCxZQUFRLE9BQU8sUUFBUSxnQkFBZ0Isd0JBQXdCO0FBQ25FLFNBQU87QUFDWDtBQUtBLFNBQVMsWUFBWSxRQUFRLFFBQVE7QUFDakMsTUFBSSxPQUFPO0FBQ1gsTUFBSSxLQUFLLE9BQU8sU0FBUyxDQUFDO0FBQzFCLFNBQU8sT0FBTyxPQUFPLE9BQU8sT0FBUSxPQUFPLFFBQVEsT0FBTyxNQUFNO0FBQzVELFFBQUksT0FBTyxRQUFRLE9BQU8sU0FBUyxDQUFDLE1BQU07QUFDdEM7QUFDSixRQUFJLE9BQU87QUFDUCxjQUFRO0FBQ1osY0FBVTtBQUNWLFNBQUssT0FBTyxTQUFTLENBQUM7QUFBQSxFQUMxQjtBQUNBLE1BQUksQ0FBQztBQUNELFdBQU87QUFDWCxTQUFPLEVBQUUsTUFBTSxPQUFPO0FBQzFCO0FBQ0EsSUFBTSxjQUFjO0FBQUEsRUFDaEIsS0FBSztBQUFBLEVBQ0wsR0FBRztBQUFBLEVBQ0gsR0FBRztBQUFBLEVBQ0gsR0FBRztBQUFBLEVBQ0gsR0FBRztBQUFBLEVBQ0gsR0FBRztBQUFBLEVBQ0gsR0FBRztBQUFBLEVBQ0gsR0FBRztBQUFBLEVBQ0gsR0FBRztBQUFBLEVBQ0gsR0FBRztBQUFBLEVBQ0gsR0FBRztBQUFBLEVBQ0gsR0FBRztBQUFBLEVBQ0gsR0FBRztBQUFBLEVBQ0gsS0FBSztBQUFBLEVBQ0wsS0FBSztBQUFBLEVBQ0wsS0FBSztBQUFBLEVBQ0wsTUFBTTtBQUFBLEVBQ04sS0FBTTtBQUNWO0FBQ0EsU0FBUyxjQUFjLFFBQVEsUUFBUSxRQUFRLFNBQVM7QUFDcEQsUUFBTSxLQUFLLE9BQU8sT0FBTyxRQUFRLE1BQU07QUFDdkMsUUFBTSxLQUFLLEdBQUcsV0FBVyxVQUFVLGlCQUFpQixLQUFLLEVBQUU7QUFDM0QsUUFBTSxPQUFPLEtBQUssU0FBUyxJQUFJLEVBQUUsSUFBSTtBQUNyQyxNQUFJLE1BQU0sSUFBSSxHQUFHO0FBQ2IsVUFBTSxNQUFNLE9BQU8sT0FBTyxTQUFTLEdBQUcsU0FBUyxDQUFDO0FBQ2hELFlBQVEsU0FBUyxHQUFHLGlCQUFpQiwyQkFBMkIsS0FBSztBQUNyRSxXQUFPO0FBQUEsRUFDWDtBQUNBLFNBQU8sT0FBTyxjQUFjLElBQUk7QUFDcEM7OztBQ3ZOQSxTQUFTLGNBQWMsS0FBSyxPQUFPLFVBQVUsU0FBUztBQUNsRCxRQUFNLEVBQUUsT0FBTyxNQUFNLFNBQVMsTUFBTSxJQUFJLE1BQU0sU0FBUyxpQkFDakQsbUJBQW1CLE9BQU8sSUFBSSxRQUFRLFFBQVEsT0FBTyxJQUNyRCxrQkFBa0IsT0FBTyxJQUFJLFFBQVEsUUFBUSxPQUFPO0FBQzFELFFBQU0sVUFBVSxXQUNWLElBQUksV0FBVyxRQUFRLFNBQVMsUUFBUSxTQUFPLFFBQVEsVUFBVSxzQkFBc0IsR0FBRyxDQUFDLElBQzNGO0FBQ04sUUFBTUMsT0FBTSxZQUFZLFVBQ2xCLG9CQUFvQixJQUFJLFFBQVEsT0FBTyxTQUFTLFVBQVUsT0FBTyxJQUNqRSxNQUFNLFNBQVMsV0FDWCxvQkFBb0IsS0FBSyxPQUFPLE9BQU8sT0FBTyxJQUM5QyxJQUFJLE9BQU8sTUFBTTtBQUMzQixNQUFJO0FBQ0osTUFBSTtBQUNBLFVBQU0sTUFBTUEsS0FBSSxRQUFRLE9BQU8sU0FBTyxRQUFRLFlBQVksT0FBTyxzQkFBc0IsR0FBRyxHQUFHLElBQUksT0FBTztBQUN4RyxhQUFTLFNBQVMsR0FBRyxJQUFJLE1BQU0sSUFBSSxPQUFPLEdBQUc7QUFBQSxFQUNqRCxTQUNPLE9BQVA7QUFDSSxVQUFNLE1BQU0saUJBQWlCLFFBQVEsTUFBTSxVQUFVLE9BQU8sS0FBSztBQUNqRSxZQUFRLFlBQVksT0FBTyxzQkFBc0IsR0FBRztBQUNwRCxhQUFTLElBQUksT0FBTyxLQUFLO0FBQUEsRUFDN0I7QUFDQSxTQUFPLFFBQVE7QUFDZixTQUFPLFNBQVM7QUFDaEIsTUFBSTtBQUNBLFdBQU8sT0FBTztBQUNsQixNQUFJO0FBQ0EsV0FBTyxNQUFNO0FBQ2pCLE1BQUlBLEtBQUk7QUFDSixXQUFPLFNBQVNBLEtBQUk7QUFDeEIsTUFBSTtBQUNBLFdBQU8sVUFBVTtBQUNyQixTQUFPO0FBQ1g7QUFDQSxTQUFTLG9CQUFvQkMsU0FBUSxPQUFPLFNBQVMsVUFBVSxTQUFTO0FBQ3BFLE1BQUk7QUFDSixNQUFJLFlBQVk7QUFDWixXQUFPQSxRQUFPLE1BQU07QUFDeEIsUUFBTSxnQkFBZ0IsQ0FBQztBQUN2QixhQUFXRCxRQUFPQyxRQUFPLE1BQU07QUFDM0IsUUFBSSxDQUFDRCxLQUFJLGNBQWNBLEtBQUksUUFBUSxTQUFTO0FBQ3hDLFVBQUlBLEtBQUksV0FBV0EsS0FBSTtBQUNuQixzQkFBYyxLQUFLQSxJQUFHO0FBQUE7QUFFdEIsZUFBT0E7QUFBQSxJQUNmO0FBQUEsRUFDSjtBQUNBLGFBQVdBLFFBQU87QUFDZCxTQUFLLEtBQUtBLEtBQUksVUFBVSxRQUFRLE9BQU8sU0FBUyxTQUFTLEdBQUcsS0FBSyxLQUFLO0FBQ2xFLGFBQU9BO0FBQ2YsUUFBTSxLQUFLQyxRQUFPLFVBQVUsT0FBTztBQUNuQyxNQUFJLE1BQU0sQ0FBQyxHQUFHLFlBQVk7QUFHdEIsSUFBQUEsUUFBTyxLQUFLLEtBQUssT0FBTyxPQUFPLENBQUMsR0FBRyxJQUFJLEVBQUUsU0FBUyxPQUFPLE1BQU0sT0FBVSxDQUFDLENBQUM7QUFDM0UsV0FBTztBQUFBLEVBQ1g7QUFDQSxVQUFRLFVBQVUsc0JBQXNCLG1CQUFtQixXQUFXLFlBQVksdUJBQXVCO0FBQ3pHLFNBQU9BLFFBQU8sTUFBTTtBQUN4QjtBQUNBLFNBQVMsb0JBQW9CLEVBQUUsWUFBWSxRQUFBQSxRQUFPLEdBQUcsT0FBTyxPQUFPLFNBQVM7QUFDeEUsUUFBTUQsT0FBTUMsUUFBTyxLQUFLLEtBQUssQ0FBQUQsU0FBTztBQUFFLFFBQUk7QUFBSSxXQUFPQSxLQUFJLGFBQWEsS0FBS0EsS0FBSSxVQUFVLFFBQVEsT0FBTyxTQUFTLFNBQVMsR0FBRyxLQUFLLEtBQUs7QUFBQSxFQUFJLENBQUMsS0FBS0MsUUFBTyxNQUFNO0FBQzlKLE1BQUlBLFFBQU8sUUFBUTtBQUNmLFVBQU0sU0FBU0EsUUFBTyxPQUFPLEtBQUssQ0FBQUQsU0FBTztBQUFFLFVBQUk7QUFBSSxhQUFPQSxLQUFJLGFBQWEsS0FBS0EsS0FBSSxVQUFVLFFBQVEsT0FBTyxTQUFTLFNBQVMsR0FBRyxLQUFLLEtBQUs7QUFBQSxJQUFJLENBQUMsS0FDN0lDLFFBQU8sTUFBTTtBQUNqQixRQUFJRCxLQUFJLFFBQVEsT0FBTyxLQUFLO0FBQ3hCLFlBQU0sS0FBSyxXQUFXLFVBQVVBLEtBQUksR0FBRztBQUN2QyxZQUFNLEtBQUssV0FBVyxVQUFVLE9BQU8sR0FBRztBQUMxQyxZQUFNLE1BQU0saUNBQWlDLFNBQVM7QUFDdEQsY0FBUSxPQUFPLHNCQUFzQixLQUFLLElBQUk7QUFBQSxJQUNsRDtBQUFBLEVBQ0o7QUFDQSxTQUFPQTtBQUNYOzs7QUM5RUEsU0FBUyxvQkFBb0IsUUFBUSxRQUFRLEtBQUs7QUFDOUMsTUFBSSxRQUFRO0FBQ1IsUUFBSSxRQUFRO0FBQ1IsWUFBTSxPQUFPO0FBQ2pCLGFBQVMsSUFBSSxNQUFNLEdBQUcsS0FBSyxHQUFHLEVBQUUsR0FBRztBQUMvQixVQUFJLEtBQUssT0FBTyxDQUFDO0FBQ2pCLGNBQVEsR0FBRyxNQUFNO0FBQUEsUUFDYixLQUFLO0FBQUEsUUFDTCxLQUFLO0FBQUEsUUFDTCxLQUFLO0FBQ0Qsb0JBQVUsR0FBRyxPQUFPO0FBQ3BCO0FBQUEsTUFDUjtBQUdBLFdBQUssT0FBTyxFQUFFLENBQUM7QUFDZixjQUFRLE9BQU8sUUFBUSxPQUFPLFNBQVMsU0FBUyxHQUFHLFVBQVUsU0FBUztBQUNsRSxrQkFBVSxHQUFHLE9BQU87QUFDcEIsYUFBSyxPQUFPLEVBQUUsQ0FBQztBQUFBLE1BQ25CO0FBQ0E7QUFBQSxJQUNKO0FBQUEsRUFDSjtBQUNBLFNBQU87QUFDWDs7O0FDbEJBLElBQU0sS0FBSyxFQUFFLGFBQWEsaUJBQWlCO0FBQzNDLFNBQVMsWUFBWSxLQUFLLE9BQU8sT0FBTyxTQUFTO0FBQzdDLFFBQU0sRUFBRSxhQUFhLFNBQVMsUUFBUSxLQUFBRSxLQUFJLElBQUk7QUFDOUMsTUFBSTtBQUNKLFVBQVEsTUFBTSxNQUFNO0FBQUEsSUFDaEIsS0FBSztBQUNELGFBQU8sYUFBYSxLQUFLLE9BQU8sT0FBTztBQUN2QyxVQUFJLFVBQVVBO0FBQ1YsZ0JBQVEsT0FBTyxlQUFlLCtDQUErQztBQUNqRjtBQUFBLElBQ0osS0FBSztBQUFBLElBQ0wsS0FBSztBQUFBLElBQ0wsS0FBSztBQUFBLElBQ0wsS0FBSztBQUNELGFBQU8sY0FBYyxLQUFLLE9BQU9BLE1BQUssT0FBTztBQUM3QyxVQUFJO0FBQ0EsYUFBSyxTQUFTLE9BQU8sT0FBTyxVQUFVLENBQUM7QUFDM0M7QUFBQSxJQUNKLEtBQUs7QUFBQSxJQUNMLEtBQUs7QUFBQSxJQUNMLEtBQUs7QUFDRCxhQUFPLGtCQUFrQixJQUFJLEtBQUssT0FBT0EsTUFBSyxPQUFPO0FBQ3JELFVBQUk7QUFDQSxhQUFLLFNBQVMsT0FBTyxPQUFPLFVBQVUsQ0FBQztBQUMzQztBQUFBLElBQ0o7QUFDSSxjQUFRLElBQUksS0FBSztBQUNqQixZQUFNLElBQUksTUFBTSwyQkFBMkIsTUFBTSxNQUFNO0FBQUEsRUFDL0Q7QUFDQSxNQUFJLFVBQVUsS0FBSyxXQUFXO0FBQzFCLFlBQVEsUUFBUSxhQUFhLGtDQUFrQztBQUNuRSxNQUFJO0FBQ0EsU0FBSyxjQUFjO0FBQ3ZCLE1BQUksU0FBUztBQUNULFFBQUksTUFBTSxTQUFTLFlBQVksTUFBTSxXQUFXO0FBQzVDLFdBQUssVUFBVTtBQUFBO0FBRWYsV0FBSyxnQkFBZ0I7QUFBQSxFQUM3QjtBQUNBLE1BQUksSUFBSSxRQUFRO0FBQ1osU0FBSyxXQUFXO0FBQ3BCLFNBQU87QUFDWDtBQUNBLFNBQVMsaUJBQWlCLEtBQUssUUFBUSxRQUFRLEtBQUssRUFBRSxhQUFhLFNBQVMsUUFBUSxLQUFBQSxLQUFJLEdBQUcsU0FBUztBQUNoRyxRQUFNLFFBQVE7QUFBQSxJQUNWLE1BQU07QUFBQSxJQUNOLFFBQVEsb0JBQW9CLFFBQVEsUUFBUSxHQUFHO0FBQUEsSUFDL0MsUUFBUTtBQUFBLElBQ1IsUUFBUTtBQUFBLEVBQ1o7QUFDQSxRQUFNLE9BQU8sY0FBYyxLQUFLLE9BQU9BLE1BQUssT0FBTztBQUNuRCxNQUFJLFFBQVE7QUFDUixTQUFLLFNBQVMsT0FBTyxPQUFPLFVBQVUsQ0FBQztBQUN2QyxRQUFJLEtBQUssV0FBVztBQUNoQixjQUFRLFFBQVEsYUFBYSxrQ0FBa0M7QUFBQSxFQUN2RTtBQUNBLE1BQUk7QUFDQSxTQUFLLGNBQWM7QUFDdkIsTUFBSTtBQUNBLFNBQUssVUFBVTtBQUNuQixTQUFPO0FBQ1g7QUFDQSxTQUFTLGFBQWEsRUFBRSxRQUFRLEdBQUcsRUFBRSxRQUFRLFFBQVEsSUFBSSxHQUFHLFNBQVM7QUFDakUsUUFBTSxRQUFRLElBQUksTUFBTSxPQUFPLFVBQVUsQ0FBQyxDQUFDO0FBQzNDLE1BQUksTUFBTSxXQUFXO0FBQ2pCLFlBQVEsUUFBUSxhQUFhLGlDQUFpQztBQUNsRSxRQUFNLFdBQVcsU0FBUyxPQUFPO0FBQ2pDLFFBQU0sS0FBSyxXQUFXLEtBQUssVUFBVSxRQUFRLFFBQVEsT0FBTztBQUM1RCxRQUFNLFFBQVEsQ0FBQyxRQUFRLFVBQVUsR0FBRyxNQUFNO0FBQzFDLE1BQUksR0FBRztBQUNILFVBQU0sVUFBVSxHQUFHO0FBQ3ZCLFNBQU87QUFDWDs7O0FDekVBLFNBQVMsV0FBVyxTQUFTLFlBQVksRUFBRSxRQUFRLE9BQU8sT0FBTyxJQUFJLEdBQUcsU0FBUztBQUM3RSxRQUFNLE9BQU8sT0FBTyxPQUFPLEVBQUUsV0FBVyxHQUFHLE9BQU87QUFDbEQsUUFBTSxNQUFNLElBQUksU0FBUyxRQUFXLElBQUk7QUFDeEMsUUFBTSxNQUFNO0FBQUEsSUFDUixRQUFRO0FBQUEsSUFDUixZQUFZLElBQUk7QUFBQSxJQUNoQixTQUFTLElBQUk7QUFBQSxJQUNiLFFBQVEsSUFBSTtBQUFBLEVBQ2hCO0FBQ0EsUUFBTSxRQUFRLGFBQWEsT0FBTztBQUFBLElBQzlCLFdBQVc7QUFBQSxJQUNYLE1BQU0sVUFBVSxRQUFRLFFBQVEsUUFBUSxTQUFTLFNBQVMsSUFBSSxDQUFDO0FBQUEsSUFDL0Q7QUFBQSxJQUNBO0FBQUEsSUFDQSxnQkFBZ0I7QUFBQSxFQUNwQixDQUFDO0FBQ0QsTUFBSSxNQUFNLE9BQU87QUFDYixRQUFJLFdBQVcsU0FBUztBQUN4QixRQUFJLFVBQ0MsTUFBTSxTQUFTLGVBQWUsTUFBTSxTQUFTLGdCQUM5QyxDQUFDLE1BQU07QUFDUCxjQUFRLE1BQU0sS0FBSyxnQkFBZ0IsdUVBQXVFO0FBQUEsRUFDbEg7QUFDQSxNQUFJLFdBQVcsUUFDVCxZQUFZLEtBQUssT0FBTyxPQUFPLE9BQU8sSUFDdEMsaUJBQWlCLEtBQUssTUFBTSxLQUFLLE9BQU8sTUFBTSxPQUFPLE9BQU87QUFDbEUsUUFBTSxhQUFhLElBQUksU0FBUyxNQUFNLENBQUM7QUFDdkMsUUFBTSxLQUFLLFdBQVcsS0FBSyxZQUFZLE9BQU8sT0FBTztBQUNyRCxNQUFJLEdBQUc7QUFDSCxRQUFJLFVBQVUsR0FBRztBQUNyQixNQUFJLFFBQVEsQ0FBQyxRQUFRLFlBQVksR0FBRyxNQUFNO0FBQzFDLFNBQU87QUFDWDs7O0FDN0JBLFNBQVMsWUFBWSxLQUFLO0FBQ3RCLE1BQUksT0FBTyxRQUFRO0FBQ2YsV0FBTyxDQUFDLEtBQUssTUFBTSxDQUFDO0FBQ3hCLE1BQUksTUFBTSxRQUFRLEdBQUc7QUFDakIsV0FBTyxJQUFJLFdBQVcsSUFBSSxNQUFNLENBQUMsSUFBSSxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUM7QUFDbkQsUUFBTSxFQUFFLFFBQVEsT0FBTyxJQUFJO0FBQzNCLFNBQU8sQ0FBQyxRQUFRLFVBQVUsT0FBTyxXQUFXLFdBQVcsT0FBTyxTQUFTLEVBQUU7QUFDN0U7QUFDQSxTQUFTLGFBQWEsU0FBUztBQUMzQixNQUFJO0FBQ0osTUFBSSxVQUFVO0FBQ2QsTUFBSSxZQUFZO0FBQ2hCLE1BQUksaUJBQWlCO0FBQ3JCLFdBQVMsSUFBSSxHQUFHLElBQUksUUFBUSxRQUFRLEVBQUUsR0FBRztBQUNyQyxVQUFNLFNBQVMsUUFBUSxDQUFDO0FBQ3hCLFlBQVEsT0FBTyxDQUFDLEdBQUc7QUFBQSxNQUNmLEtBQUs7QUFDRCxvQkFDSyxZQUFZLEtBQUssS0FBSyxpQkFBaUIsU0FBUyxTQUM1QyxPQUFPLFVBQVUsQ0FBQyxLQUFLO0FBQ2hDLG9CQUFZO0FBQ1oseUJBQWlCO0FBQ2pCO0FBQUEsTUFDSixLQUFLO0FBQ0QsY0FBTSxLQUFLLFFBQVEsSUFBSSxDQUFDLE9BQU8sUUFBUSxPQUFPLFNBQVMsU0FBUyxHQUFHLENBQUMsT0FBTztBQUN2RSxlQUFLO0FBQ1Qsb0JBQVk7QUFDWjtBQUFBLE1BQ0o7QUFFSSxZQUFJLENBQUM7QUFDRCwyQkFBaUI7QUFDckIsb0JBQVk7QUFBQSxJQUNwQjtBQUFBLEVBQ0o7QUFDQSxTQUFPLEVBQUUsU0FBUyxlQUFlO0FBQ3JDO0FBWUEsSUFBTSxXQUFOLE1BQWU7QUFBQSxFQUNYLFlBQVksVUFBVSxDQUFDLEdBQUc7QUFDdEIsU0FBSyxNQUFNO0FBQ1gsU0FBSyxlQUFlO0FBQ3BCLFNBQUssVUFBVSxDQUFDO0FBQ2hCLFNBQUssU0FBUyxDQUFDO0FBQ2YsU0FBSyxXQUFXLENBQUM7QUFDakIsU0FBSyxVQUFVLENBQUMsUUFBUSxNQUFNLFNBQVMsWUFBWTtBQUMvQyxZQUFNLE1BQU0sWUFBWSxNQUFNO0FBQzlCLFVBQUk7QUFDQSxhQUFLLFNBQVMsS0FBSyxJQUFJLFlBQVksS0FBSyxNQUFNLE9BQU8sQ0FBQztBQUFBO0FBRXRELGFBQUssT0FBTyxLQUFLLElBQUksZUFBZSxLQUFLLE1BQU0sT0FBTyxDQUFDO0FBQUEsSUFDL0Q7QUFDQSxTQUFLLGFBQWEsSUFBSSxXQUFXO0FBQUEsTUFDN0IsU0FBUyxRQUFRLFdBQVcsZUFBZTtBQUFBLElBQy9DLENBQUM7QUFDRCxTQUFLLFVBQVU7QUFBQSxFQUNuQjtBQUFBLEVBQ0EsU0FBUyxLQUFLLFVBQVU7QUFDcEIsVUFBTSxFQUFFLFNBQVMsZUFBZSxJQUFJLGFBQWEsS0FBSyxPQUFPO0FBRTdELFFBQUksU0FBUztBQUNULFlBQU0sS0FBSyxJQUFJO0FBQ2YsVUFBSSxVQUFVO0FBQ1YsWUFBSSxVQUFVLElBQUksVUFBVSxHQUFHLElBQUk7QUFBQSxFQUFZLFlBQVk7QUFBQSxNQUMvRCxXQUNTLGtCQUFrQixJQUFJLFdBQVcsVUFBVSxDQUFDLElBQUk7QUFDckQsWUFBSSxnQkFBZ0I7QUFBQSxNQUN4QixXQUNTLGFBQWEsRUFBRSxLQUFLLENBQUMsR0FBRyxRQUFRLEdBQUcsTUFBTSxTQUFTLEdBQUc7QUFDMUQsWUFBSSxLQUFLLEdBQUcsTUFBTSxDQUFDO0FBQ25CLFlBQUksT0FBTyxFQUFFO0FBQ1QsZUFBSyxHQUFHO0FBQ1osY0FBTSxLQUFLLEdBQUc7QUFDZCxXQUFHLGdCQUFnQixLQUFLLEdBQUc7QUFBQSxFQUFZLE9BQU87QUFBQSxNQUNsRCxPQUNLO0FBQ0QsY0FBTSxLQUFLLEdBQUc7QUFDZCxXQUFHLGdCQUFnQixLQUFLLEdBQUc7QUFBQSxFQUFZLE9BQU87QUFBQSxNQUNsRDtBQUFBLElBQ0o7QUFDQSxRQUFJLFVBQVU7QUFDVixZQUFNLFVBQVUsS0FBSyxNQUFNLElBQUksUUFBUSxLQUFLLE1BQU07QUFDbEQsWUFBTSxVQUFVLEtBQUssTUFBTSxJQUFJLFVBQVUsS0FBSyxRQUFRO0FBQUEsSUFDMUQsT0FDSztBQUNELFVBQUksU0FBUyxLQUFLO0FBQ2xCLFVBQUksV0FBVyxLQUFLO0FBQUEsSUFDeEI7QUFDQSxTQUFLLFVBQVUsQ0FBQztBQUNoQixTQUFLLFNBQVMsQ0FBQztBQUNmLFNBQUssV0FBVyxDQUFDO0FBQUEsRUFDckI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFNQSxhQUFhO0FBQ1QsV0FBTztBQUFBLE1BQ0gsU0FBUyxhQUFhLEtBQUssT0FBTyxFQUFFO0FBQUEsTUFDcEMsWUFBWSxLQUFLO0FBQUEsTUFDakIsUUFBUSxLQUFLO0FBQUEsTUFDYixVQUFVLEtBQUs7QUFBQSxJQUNuQjtBQUFBLEVBQ0o7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQU9BLENBQUMsUUFBUSxRQUFRLFdBQVcsT0FBTyxZQUFZLElBQUk7QUFDL0MsZUFBVyxTQUFTO0FBQ2hCLGFBQU8sS0FBSyxLQUFLLEtBQUs7QUFDMUIsV0FBTyxLQUFLLElBQUksVUFBVSxTQUFTO0FBQUEsRUFDdkM7QUFBQTtBQUFBLEVBRUEsQ0FBQyxLQUFLLE9BQU87QUFDVCxZQUFRLE1BQU0sTUFBTTtBQUFBLE1BQ2hCLEtBQUs7QUFDRCxhQUFLLFdBQVcsSUFBSSxNQUFNLFFBQVEsQ0FBQyxRQUFRLFNBQVMsWUFBWTtBQUM1RCxnQkFBTSxNQUFNLFlBQVksS0FBSztBQUM3QixjQUFJLENBQUMsS0FBSztBQUNWLGVBQUssUUFBUSxLQUFLLGlCQUFpQixTQUFTLE9BQU87QUFBQSxRQUN2RCxDQUFDO0FBQ0QsYUFBSyxRQUFRLEtBQUssTUFBTSxNQUFNO0FBQzlCLGFBQUssZUFBZTtBQUNwQjtBQUFBLE1BQ0osS0FBSyxZQUFZO0FBQ2IsY0FBTSxNQUFNLFdBQVcsS0FBSyxTQUFTLEtBQUssWUFBWSxPQUFPLEtBQUssT0FBTztBQUN6RSxZQUFJLEtBQUssZ0JBQWdCLENBQUMsSUFBSSxXQUFXO0FBQ3JDLGVBQUssUUFBUSxPQUFPLGdCQUFnQix1Q0FBdUM7QUFDL0UsYUFBSyxTQUFTLEtBQUssS0FBSztBQUN4QixZQUFJLEtBQUs7QUFDTCxnQkFBTSxLQUFLO0FBQ2YsYUFBSyxNQUFNO0FBQ1gsYUFBSyxlQUFlO0FBQ3BCO0FBQUEsTUFDSjtBQUFBLE1BQ0EsS0FBSztBQUFBLE1BQ0wsS0FBSztBQUNEO0FBQUEsTUFDSixLQUFLO0FBQUEsTUFDTCxLQUFLO0FBQ0QsYUFBSyxRQUFRLEtBQUssTUFBTSxNQUFNO0FBQzlCO0FBQUEsTUFDSixLQUFLLFNBQVM7QUFDVixjQUFNLE1BQU0sTUFBTSxTQUNaLEdBQUcsTUFBTSxZQUFZLEtBQUssVUFBVSxNQUFNLE1BQU0sTUFDaEQsTUFBTTtBQUNaLGNBQU0sUUFBUSxJQUFJLGVBQWUsWUFBWSxLQUFLLEdBQUcsb0JBQW9CLEdBQUc7QUFDNUUsWUFBSSxLQUFLLGdCQUFnQixDQUFDLEtBQUs7QUFDM0IsZUFBSyxPQUFPLEtBQUssS0FBSztBQUFBO0FBRXRCLGVBQUssSUFBSSxPQUFPLEtBQUssS0FBSztBQUM5QjtBQUFBLE1BQ0o7QUFBQSxNQUNBLEtBQUssV0FBVztBQUNaLFlBQUksQ0FBQyxLQUFLLEtBQUs7QUFDWCxnQkFBTSxNQUFNO0FBQ1osZUFBSyxPQUFPLEtBQUssSUFBSSxlQUFlLFlBQVksS0FBSyxHQUFHLG9CQUFvQixHQUFHLENBQUM7QUFDaEY7QUFBQSxRQUNKO0FBQ0EsY0FBTSxNQUFNLFdBQVcsTUFBTSxLQUFLLE1BQU0sU0FBUyxNQUFNLE9BQU8sUUFBUSxLQUFLLElBQUksUUFBUSxRQUFRLEtBQUssT0FBTztBQUMzRyxhQUFLLFNBQVMsS0FBSyxLQUFLLElBQUk7QUFDNUIsWUFBSSxJQUFJLFNBQVM7QUFDYixnQkFBTSxLQUFLLEtBQUssSUFBSTtBQUNwQixlQUFLLElBQUksVUFBVSxLQUFLLEdBQUc7QUFBQSxFQUFPLElBQUksWUFBWSxJQUFJO0FBQUEsUUFDMUQ7QUFDQSxhQUFLLElBQUksTUFBTSxDQUFDLElBQUksSUFBSTtBQUN4QjtBQUFBLE1BQ0o7QUFBQSxNQUNBO0FBQ0ksYUFBSyxPQUFPLEtBQUssSUFBSSxlQUFlLFlBQVksS0FBSyxHQUFHLG9CQUFvQixxQkFBcUIsTUFBTSxNQUFNLENBQUM7QUFBQSxJQUN0SDtBQUFBLEVBQ0o7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQU9BLENBQUMsSUFBSSxXQUFXLE9BQU8sWUFBWSxJQUFJO0FBQ25DLFFBQUksS0FBSyxLQUFLO0FBQ1YsV0FBSyxTQUFTLEtBQUssS0FBSyxJQUFJO0FBQzVCLFlBQU0sS0FBSztBQUNYLFdBQUssTUFBTTtBQUFBLElBQ2YsV0FDUyxVQUFVO0FBQ2YsWUFBTSxPQUFPLE9BQU8sT0FBTyxFQUFFLFlBQVksS0FBSyxXQUFXLEdBQUcsS0FBSyxPQUFPO0FBQ3hFLFlBQU0sTUFBTSxJQUFJLFNBQVMsUUFBVyxJQUFJO0FBQ3hDLFVBQUksS0FBSztBQUNMLGFBQUssUUFBUSxXQUFXLGdCQUFnQix1Q0FBdUM7QUFDbkYsVUFBSSxRQUFRLENBQUMsR0FBRyxXQUFXLFNBQVM7QUFDcEMsV0FBSyxTQUFTLEtBQUssS0FBSztBQUN4QixZQUFNO0FBQUEsSUFDVjtBQUFBLEVBQ0o7QUFDSjs7O0FDeE5BO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxnQkFBQUM7QUFBQSxFQUFBO0FBQUEsc0JBQUFDO0FBQUEsRUFBQSxnQkFBQUM7QUFBQSxFQUFBO0FBQUE7QUFBQTtBQUFBLG1CQUFBQztBQUFBLEVBQUE7QUFBQSxlQUFBQztBQUFBOzs7QUNLQSxTQUFTLGdCQUFnQixPQUFPLFNBQVMsTUFBTSxTQUFTO0FBQ3BELE1BQUksT0FBTztBQUNQLFVBQU0sV0FBVyxDQUFDLEtBQUssTUFBTSxZQUFZO0FBQ3JDLFlBQU0sU0FBUyxPQUFPLFFBQVEsV0FBVyxNQUFNLE1BQU0sUUFBUSxHQUFHLElBQUksSUFBSSxDQUFDLElBQUksSUFBSTtBQUNqRixVQUFJO0FBQ0EsZ0JBQVEsUUFBUSxNQUFNLE9BQU87QUFBQTtBQUU3QixjQUFNLElBQUksZUFBZSxDQUFDLFFBQVEsU0FBUyxDQUFDLEdBQUcsTUFBTSxPQUFPO0FBQUEsSUFDcEU7QUFDQSxZQUFRLE1BQU0sTUFBTTtBQUFBLE1BQ2hCLEtBQUs7QUFBQSxNQUNMLEtBQUs7QUFBQSxNQUNMLEtBQUs7QUFDRCxlQUFPLGtCQUFrQixPQUFPLFFBQVEsUUFBUTtBQUFBLE1BQ3BELEtBQUs7QUFDRCxlQUFPLG1CQUFtQixPQUFPLFFBQVEsUUFBUTtBQUFBLElBQ3pEO0FBQUEsRUFDSjtBQUNBLFNBQU87QUFDWDtBQWVBLFNBQVMsa0JBQWtCLE9BQU8sU0FBUztBQUN2QyxNQUFJO0FBQ0osUUFBTSxFQUFFLGNBQWMsT0FBTyxRQUFRLFNBQVMsT0FBTyxTQUFTLElBQUksT0FBTyxRQUFRLElBQUk7QUFDckYsUUFBTSxTQUFTLGdCQUFnQixFQUFFLE1BQU0sTUFBTSxHQUFHO0FBQUEsSUFDNUM7QUFBQSxJQUNBLFFBQVEsU0FBUyxJQUFJLElBQUksT0FBTyxNQUFNLElBQUk7QUFBQSxJQUMxQztBQUFBLElBQ0EsU0FBUyxFQUFFLFlBQVksTUFBTSxXQUFXLEdBQUc7QUFBQSxFQUMvQyxDQUFDO0FBQ0QsUUFBTSxPQUFPLEtBQUssUUFBUSxTQUFTLFFBQVEsT0FBTyxTQUFTLEtBQUs7QUFBQSxJQUM1RCxFQUFFLE1BQU0sV0FBVyxRQUFRLElBQUksUUFBUSxRQUFRLEtBQUs7QUFBQSxFQUN4RDtBQUNBLFVBQVEsT0FBTyxDQUFDLEdBQUc7QUFBQSxJQUNmLEtBQUs7QUFBQSxJQUNMLEtBQUssS0FBSztBQUNOLFlBQU0sS0FBSyxPQUFPLFFBQVEsSUFBSTtBQUM5QixZQUFNLE9BQU8sT0FBTyxVQUFVLEdBQUcsRUFBRTtBQUNuQyxZQUFNLE9BQU8sT0FBTyxVQUFVLEtBQUssQ0FBQyxJQUFJO0FBQ3hDLFlBQU0sUUFBUTtBQUFBLFFBQ1YsRUFBRSxNQUFNLHVCQUF1QixRQUFRLFFBQVEsUUFBUSxLQUFLO0FBQUEsTUFDaEU7QUFDQSxVQUFJLENBQUMsbUJBQW1CLE9BQU8sR0FBRztBQUM5QixjQUFNLEtBQUssRUFBRSxNQUFNLFdBQVcsUUFBUSxJQUFJLFFBQVEsUUFBUSxLQUFLLENBQUM7QUFDcEUsYUFBTyxFQUFFLE1BQU0sZ0JBQWdCLFFBQVEsUUFBUSxPQUFPLFFBQVEsS0FBSztBQUFBLElBQ3ZFO0FBQUEsSUFDQSxLQUFLO0FBQ0QsYUFBTyxFQUFFLE1BQU0sd0JBQXdCLFFBQVEsUUFBUSxRQUFRLElBQUk7QUFBQSxJQUN2RSxLQUFLO0FBQ0QsYUFBTyxFQUFFLE1BQU0sd0JBQXdCLFFBQVEsUUFBUSxRQUFRLElBQUk7QUFBQSxJQUN2RTtBQUNJLGFBQU8sRUFBRSxNQUFNLFVBQVUsUUFBUSxRQUFRLFFBQVEsSUFBSTtBQUFBLEVBQzdEO0FBQ0o7QUFpQkEsU0FBUyxlQUFlLE9BQU8sT0FBTyxVQUFVLENBQUMsR0FBRztBQUNoRCxNQUFJLEVBQUUsV0FBVyxPQUFPLGNBQWMsT0FBTyxTQUFTLE9BQU8sS0FBSyxJQUFJO0FBQ3RFLE1BQUksU0FBUyxZQUFZLFFBQVEsTUFBTSxTQUFTO0FBQ2hELE1BQUksWUFBWSxPQUFPLFdBQVc7QUFDOUIsY0FBVTtBQUNkLE1BQUksQ0FBQztBQUNELFlBQVEsTUFBTSxNQUFNO0FBQUEsTUFDaEIsS0FBSztBQUNELGVBQU87QUFDUDtBQUFBLE1BQ0osS0FBSztBQUNELGVBQU87QUFDUDtBQUFBLE1BQ0osS0FBSyxnQkFBZ0I7QUFDakIsY0FBTSxTQUFTLE1BQU0sTUFBTSxDQUFDO0FBQzVCLFlBQUksT0FBTyxTQUFTO0FBQ2hCLGdCQUFNLElBQUksTUFBTSw2QkFBNkI7QUFDakQsZUFBTyxPQUFPLE9BQU8sQ0FBQyxNQUFNLE1BQU0saUJBQWlCO0FBQ25EO0FBQUEsTUFDSjtBQUFBLE1BQ0E7QUFDSSxlQUFPO0FBQUEsSUFDZjtBQUNKLFFBQU0sU0FBUyxnQkFBZ0IsRUFBRSxNQUFNLE1BQU0sR0FBRztBQUFBLElBQzVDLGFBQWEsZUFBZSxXQUFXO0FBQUEsSUFDdkMsUUFBUSxXQUFXLFFBQVEsU0FBUyxJQUFJLElBQUksT0FBTyxNQUFNLElBQUk7QUFBQSxJQUM3RDtBQUFBLElBQ0EsU0FBUyxFQUFFLFlBQVksTUFBTSxXQUFXLEdBQUc7QUFBQSxFQUMvQyxDQUFDO0FBQ0QsVUFBUSxPQUFPLENBQUMsR0FBRztBQUFBLElBQ2YsS0FBSztBQUFBLElBQ0wsS0FBSztBQUNELDBCQUFvQixPQUFPLE1BQU07QUFDakM7QUFBQSxJQUNKLEtBQUs7QUFDRCx5QkFBbUIsT0FBTyxRQUFRLHNCQUFzQjtBQUN4RDtBQUFBLElBQ0osS0FBSztBQUNELHlCQUFtQixPQUFPLFFBQVEsc0JBQXNCO0FBQ3hEO0FBQUEsSUFDSjtBQUNJLHlCQUFtQixPQUFPLFFBQVEsUUFBUTtBQUFBLEVBQ2xEO0FBQ0o7QUFDQSxTQUFTLG9CQUFvQixPQUFPLFFBQVE7QUFDeEMsUUFBTSxLQUFLLE9BQU8sUUFBUSxJQUFJO0FBQzlCLFFBQU0sT0FBTyxPQUFPLFVBQVUsR0FBRyxFQUFFO0FBQ25DLFFBQU0sT0FBTyxPQUFPLFVBQVUsS0FBSyxDQUFDLElBQUk7QUFDeEMsTUFBSSxNQUFNLFNBQVMsZ0JBQWdCO0FBQy9CLFVBQU0sU0FBUyxNQUFNLE1BQU0sQ0FBQztBQUM1QixRQUFJLE9BQU8sU0FBUztBQUNoQixZQUFNLElBQUksTUFBTSw2QkFBNkI7QUFDakQsV0FBTyxTQUFTO0FBQ2hCLFVBQU0sU0FBUztBQUFBLEVBQ25CLE9BQ0s7QUFDRCxVQUFNLEVBQUUsT0FBTyxJQUFJO0FBQ25CLFVBQU0sU0FBUyxZQUFZLFFBQVEsTUFBTSxTQUFTO0FBQ2xELFVBQU0sUUFBUTtBQUFBLE1BQ1YsRUFBRSxNQUFNLHVCQUF1QixRQUFRLFFBQVEsUUFBUSxLQUFLO0FBQUEsSUFDaEU7QUFDQSxRQUFJLENBQUMsbUJBQW1CLE9BQU8sU0FBUyxRQUFRLE1BQU0sTUFBTSxNQUFTO0FBQ2pFLFlBQU0sS0FBSyxFQUFFLE1BQU0sV0FBVyxRQUFRLElBQUksUUFBUSxRQUFRLEtBQUssQ0FBQztBQUNwRSxlQUFXLE9BQU8sT0FBTyxLQUFLLEtBQUs7QUFDL0IsVUFBSSxRQUFRLFVBQVUsUUFBUTtBQUMxQixlQUFPLE1BQU0sR0FBRztBQUN4QixXQUFPLE9BQU8sT0FBTyxFQUFFLE1BQU0sZ0JBQWdCLFFBQVEsT0FBTyxRQUFRLEtBQUssQ0FBQztBQUFBLEVBQzlFO0FBQ0o7QUFFQSxTQUFTLG1CQUFtQixPQUFPLEtBQUs7QUFDcEMsTUFBSTtBQUNBLGVBQVcsTUFBTTtBQUNiLGNBQVEsR0FBRyxNQUFNO0FBQUEsUUFDYixLQUFLO0FBQUEsUUFDTCxLQUFLO0FBQ0QsZ0JBQU0sS0FBSyxFQUFFO0FBQ2I7QUFBQSxRQUNKLEtBQUs7QUFDRCxnQkFBTSxLQUFLLEVBQUU7QUFDYixpQkFBTztBQUFBLE1BQ2Y7QUFDUixTQUFPO0FBQ1g7QUFDQSxTQUFTLG1CQUFtQixPQUFPLFFBQVEsTUFBTTtBQUM3QyxVQUFRLE1BQU0sTUFBTTtBQUFBLElBQ2hCLEtBQUs7QUFBQSxJQUNMLEtBQUs7QUFBQSxJQUNMLEtBQUs7QUFDRCxZQUFNLE9BQU87QUFDYixZQUFNLFNBQVM7QUFDZjtBQUFBLElBQ0osS0FBSyxnQkFBZ0I7QUFDakIsWUFBTSxNQUFNLE1BQU0sTUFBTSxNQUFNLENBQUM7QUFDL0IsVUFBSSxLQUFLLE9BQU87QUFDaEIsVUFBSSxNQUFNLE1BQU0sQ0FBQyxFQUFFLFNBQVM7QUFDeEIsY0FBTSxNQUFNLE1BQU0sQ0FBQyxFQUFFLE9BQU87QUFDaEMsaUJBQVcsT0FBTztBQUNkLFlBQUksVUFBVTtBQUNsQixhQUFPLE1BQU07QUFDYixhQUFPLE9BQU8sT0FBTyxFQUFFLE1BQU0sUUFBUSxJQUFJLENBQUM7QUFDMUM7QUFBQSxJQUNKO0FBQUEsSUFDQSxLQUFLO0FBQUEsSUFDTCxLQUFLLGFBQWE7QUFDZCxZQUFNLFNBQVMsTUFBTSxTQUFTLE9BQU87QUFDckMsWUFBTSxLQUFLLEVBQUUsTUFBTSxXQUFXLFFBQVEsUUFBUSxNQUFNLFFBQVEsUUFBUSxLQUFLO0FBQ3pFLGFBQU8sTUFBTTtBQUNiLGFBQU8sT0FBTyxPQUFPLEVBQUUsTUFBTSxRQUFRLEtBQUssQ0FBQyxFQUFFLEVBQUUsQ0FBQztBQUNoRDtBQUFBLElBQ0o7QUFBQSxJQUNBLFNBQVM7QUFDTCxZQUFNLFNBQVMsWUFBWSxRQUFRLE1BQU0sU0FBUztBQUNsRCxZQUFNLE1BQU0sU0FBUyxTQUFTLE1BQU0sUUFBUSxNQUFNLEdBQUcsSUFDL0MsTUFBTSxJQUFJLE9BQU8sUUFBTSxHQUFHLFNBQVMsV0FDakMsR0FBRyxTQUFTLGFBQ1osR0FBRyxTQUFTLFNBQVMsSUFDdkIsQ0FBQztBQUNQLGlCQUFXLE9BQU8sT0FBTyxLQUFLLEtBQUs7QUFDL0IsWUFBSSxRQUFRLFVBQVUsUUFBUTtBQUMxQixpQkFBTyxNQUFNLEdBQUc7QUFDeEIsYUFBTyxPQUFPLE9BQU8sRUFBRSxNQUFNLFFBQVEsUUFBUSxJQUFJLENBQUM7QUFBQSxJQUN0RDtBQUFBLEVBQ0o7QUFDSjs7O0FDOU1BLElBQU1DLGFBQVksQ0FBQyxRQUFRLFVBQVUsTUFBTSxlQUFlLEdBQUcsSUFBSSxjQUFjLEdBQUc7QUFDbEYsU0FBUyxlQUFlLE9BQU87QUFDM0IsVUFBUSxNQUFNLE1BQU07QUFBQSxJQUNoQixLQUFLLGdCQUFnQjtBQUNqQixVQUFJLE1BQU07QUFDVixpQkFBVyxPQUFPLE1BQU07QUFDcEIsZUFBTyxlQUFlLEdBQUc7QUFDN0IsYUFBTyxNQUFNLE1BQU07QUFBQSxJQUN2QjtBQUFBLElBQ0EsS0FBSztBQUFBLElBQ0wsS0FBSyxhQUFhO0FBQ2QsVUFBSSxNQUFNO0FBQ1YsaUJBQVcsUUFBUSxNQUFNO0FBQ3JCLGVBQU8sY0FBYyxJQUFJO0FBQzdCLGFBQU87QUFBQSxJQUNYO0FBQUEsSUFDQSxLQUFLLG1CQUFtQjtBQUNwQixVQUFJLE1BQU0sTUFBTSxNQUFNO0FBQ3RCLGlCQUFXLFFBQVEsTUFBTTtBQUNyQixlQUFPLGNBQWMsSUFBSTtBQUM3QixpQkFBVyxNQUFNLE1BQU07QUFDbkIsZUFBTyxHQUFHO0FBQ2QsYUFBTztBQUFBLElBQ1g7QUFBQSxJQUNBLEtBQUssWUFBWTtBQUNiLFVBQUksTUFBTSxjQUFjLEtBQUs7QUFDN0IsVUFBSSxNQUFNO0FBQ04sbUJBQVcsTUFBTSxNQUFNO0FBQ25CLGlCQUFPLEdBQUc7QUFDbEIsYUFBTztBQUFBLElBQ1g7QUFBQSxJQUNBLFNBQVM7QUFDTCxVQUFJLE1BQU0sTUFBTTtBQUNoQixVQUFJLFNBQVMsU0FBUyxNQUFNO0FBQ3hCLG1CQUFXLE1BQU0sTUFBTTtBQUNuQixpQkFBTyxHQUFHO0FBQ2xCLGFBQU87QUFBQSxJQUNYO0FBQUEsRUFDSjtBQUNKO0FBQ0EsU0FBUyxjQUFjLEVBQUUsT0FBTyxLQUFLLEtBQUssTUFBTSxHQUFHO0FBQy9DLE1BQUksTUFBTTtBQUNWLGFBQVcsTUFBTTtBQUNiLFdBQU8sR0FBRztBQUNkLE1BQUk7QUFDQSxXQUFPLGVBQWUsR0FBRztBQUM3QixNQUFJO0FBQ0EsZUFBVyxNQUFNO0FBQ2IsYUFBTyxHQUFHO0FBQ2xCLE1BQUk7QUFDQSxXQUFPLGVBQWUsS0FBSztBQUMvQixTQUFPO0FBQ1g7OztBQzFEQSxJQUFNQyxTQUFRLE9BQU8sYUFBYTtBQUNsQyxJQUFNQyxRQUFPLE9BQU8sZUFBZTtBQUNuQyxJQUFNQyxVQUFTLE9BQU8sYUFBYTtBQTZCbkMsU0FBU0MsT0FBTSxLQUFLLFNBQVM7QUFDekIsTUFBSSxVQUFVLE9BQU8sSUFBSSxTQUFTO0FBQzlCLFVBQU0sRUFBRSxPQUFPLElBQUksT0FBTyxPQUFPLElBQUksTUFBTTtBQUMvQyxFQUFBQyxRQUFPLE9BQU8sT0FBTyxDQUFDLENBQUMsR0FBRyxLQUFLLE9BQU87QUFDMUM7QUFLQUQsT0FBTSxRQUFRSDtBQUVkRyxPQUFNLE9BQU9GO0FBRWJFLE9BQU0sU0FBU0Q7QUFFZkMsT0FBTSxhQUFhLENBQUMsS0FBSyxTQUFTO0FBQzlCLE1BQUksT0FBTztBQUNYLGFBQVcsQ0FBQyxPQUFPLEtBQUssS0FBSyxNQUFNO0FBQy9CLFVBQU0sTUFBTSxRQUFRLEtBQUssS0FBSztBQUM5QixRQUFJLE9BQU8sV0FBVyxLQUFLO0FBQ3ZCLGFBQU8sSUFBSSxNQUFNLEtBQUs7QUFBQSxJQUMxQjtBQUVJLGFBQU87QUFBQSxFQUNmO0FBQ0EsU0FBTztBQUNYO0FBTUFBLE9BQU0sbUJBQW1CLENBQUMsS0FBSyxTQUFTO0FBQ3BDLFFBQU0sU0FBU0EsT0FBTSxXQUFXLEtBQUssS0FBSyxNQUFNLEdBQUcsRUFBRSxDQUFDO0FBQ3RELFFBQU0sUUFBUSxLQUFLLEtBQUssU0FBUyxDQUFDLEVBQUUsQ0FBQztBQUNyQyxRQUFNLE9BQU8sVUFBVSxPQUFPLEtBQUs7QUFDbkMsTUFBSSxRQUFRLFdBQVc7QUFDbkIsV0FBTztBQUNYLFFBQU0sSUFBSSxNQUFNLDZCQUE2QjtBQUNqRDtBQUNBLFNBQVNDLFFBQU8sTUFBTSxNQUFNLFNBQVM7QUFDakMsTUFBSSxPQUFPLFFBQVEsTUFBTSxJQUFJO0FBQzdCLE1BQUksT0FBTyxTQUFTO0FBQ2hCLFdBQU87QUFDWCxhQUFXLFNBQVMsQ0FBQyxPQUFPLE9BQU8sR0FBRztBQUNsQyxVQUFNLFFBQVEsS0FBSyxLQUFLO0FBQ3hCLFFBQUksU0FBUyxXQUFXLE9BQU87QUFDM0IsZUFBUyxJQUFJLEdBQUcsSUFBSSxNQUFNLE1BQU0sUUFBUSxFQUFFLEdBQUc7QUFDekMsY0FBTSxLQUFLQSxRQUFPLE9BQU8sT0FBTyxLQUFLLE9BQU8sQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLE1BQU0sTUFBTSxDQUFDLEdBQUcsT0FBTztBQUNuRixZQUFJLE9BQU8sT0FBTztBQUNkLGNBQUksS0FBSztBQUFBLGlCQUNKLE9BQU9KO0FBQ1osaUJBQU9BO0FBQUEsaUJBQ0YsT0FBT0UsU0FBUTtBQUNwQixnQkFBTSxNQUFNLE9BQU8sR0FBRyxDQUFDO0FBQ3ZCLGVBQUs7QUFBQSxRQUNUO0FBQUEsTUFDSjtBQUNBLFVBQUksT0FBTyxTQUFTLGNBQWMsVUFBVTtBQUN4QyxlQUFPLEtBQUssTUFBTSxJQUFJO0FBQUEsSUFDOUI7QUFBQSxFQUNKO0FBQ0EsU0FBTyxPQUFPLFNBQVMsYUFBYSxLQUFLLE1BQU0sSUFBSSxJQUFJO0FBQzNEOzs7QUh6RkEsSUFBTSxNQUFNO0FBRVosSUFBTSxXQUFXO0FBRWpCLElBQU0sV0FBVztBQUVqQixJQUFNRyxVQUFTO0FBRWYsSUFBTUMsZ0JBQWUsQ0FBQyxVQUFVLENBQUMsQ0FBQyxTQUFTLFdBQVc7QUFFdEQsSUFBTUMsWUFBVyxDQUFDLFVBQVUsQ0FBQyxDQUFDLFVBQ3pCLE1BQU0sU0FBUyxZQUNaLE1BQU0sU0FBUywwQkFDZixNQUFNLFNBQVMsMEJBQ2YsTUFBTSxTQUFTO0FBR3ZCLFNBQVMsWUFBWSxPQUFPO0FBQ3hCLFVBQVEsT0FBTztBQUFBLElBQ1gsS0FBSztBQUNELGFBQU87QUFBQSxJQUNYLEtBQUs7QUFDRCxhQUFPO0FBQUEsSUFDWCxLQUFLO0FBQ0QsYUFBTztBQUFBLElBQ1gsS0FBS0Y7QUFDRCxhQUFPO0FBQUEsSUFDWDtBQUNJLGFBQU8sS0FBSyxVQUFVLEtBQUs7QUFBQSxFQUNuQztBQUNKO0FBRUEsU0FBUyxVQUFVLFFBQVE7QUFDdkIsVUFBUSxRQUFRO0FBQUEsSUFDWixLQUFLO0FBQ0QsYUFBTztBQUFBLElBQ1gsS0FBSztBQUNELGFBQU87QUFBQSxJQUNYLEtBQUs7QUFDRCxhQUFPO0FBQUEsSUFDWCxLQUFLQTtBQUNELGFBQU87QUFBQSxJQUNYLEtBQUs7QUFDRCxhQUFPO0FBQUEsSUFDWCxLQUFLO0FBQ0QsYUFBTztBQUFBLElBQ1gsS0FBSztBQUFBLElBQ0wsS0FBSztBQUFBLElBQ0wsS0FBSztBQUNELGFBQU87QUFBQSxJQUNYLEtBQUs7QUFDRCxhQUFPO0FBQUEsSUFDWCxLQUFLO0FBQ0QsYUFBTztBQUFBLElBQ1gsS0FBSztBQUNELGFBQU87QUFBQSxJQUNYLEtBQUs7QUFDRCxhQUFPO0FBQUEsSUFDWCxLQUFLO0FBQ0QsYUFBTztBQUFBLElBQ1gsS0FBSztBQUNELGFBQU87QUFBQSxJQUNYLEtBQUs7QUFDRCxhQUFPO0FBQUEsSUFDWCxLQUFLO0FBQ0QsYUFBTztBQUFBLEVBQ2Y7QUFDQSxVQUFRLE9BQU8sQ0FBQyxHQUFHO0FBQUEsSUFDZixLQUFLO0FBQUEsSUFDTCxLQUFLO0FBQ0QsYUFBTztBQUFBLElBQ1gsS0FBSztBQUNELGFBQU87QUFBQSxJQUNYLEtBQUs7QUFDRCxhQUFPO0FBQUEsSUFDWCxLQUFLO0FBQ0QsYUFBTztBQUFBLElBQ1gsS0FBSztBQUNELGFBQU87QUFBQSxJQUNYLEtBQUs7QUFDRCxhQUFPO0FBQUEsSUFDWCxLQUFLO0FBQ0QsYUFBTztBQUFBLElBQ1gsS0FBSztBQUNELGFBQU87QUFBQSxJQUNYLEtBQUs7QUFBQSxJQUNMLEtBQUs7QUFDRCxhQUFPO0FBQUEsRUFDZjtBQUNBLFNBQU87QUFDWDs7O0FJMUJBLFNBQVMsUUFBUSxJQUFJO0FBQ2pCLFVBQVEsSUFBSTtBQUFBLElBQ1IsS0FBSztBQUFBLElBQ0wsS0FBSztBQUFBLElBQ0wsS0FBSztBQUFBLElBQ0wsS0FBSztBQUFBLElBQ0wsS0FBSztBQUNELGFBQU87QUFBQSxJQUNYO0FBQ0ksYUFBTztBQUFBLEVBQ2Y7QUFDSjtBQUNBLElBQU0sWUFBWSx5QkFBeUIsTUFBTSxFQUFFO0FBQ25ELElBQU0sV0FBVyxvRkFBb0YsTUFBTSxFQUFFO0FBQzdHLElBQU0seUJBQXlCLFFBQVEsTUFBTSxFQUFFO0FBQy9DLElBQU0scUJBQXFCLGNBQWUsTUFBTSxFQUFFO0FBQ2xELElBQU0sa0JBQWtCLENBQUMsT0FBTyxDQUFDLE1BQU0sbUJBQW1CLFNBQVMsRUFBRTtBQWdCckUsSUFBTSxRQUFOLE1BQVk7QUFBQSxFQUNSLGNBQWM7QUFLVixTQUFLLFFBQVE7QUFNYixTQUFLLG9CQUFvQjtBQU16QixTQUFLLGtCQUFrQjtBQUV2QixTQUFLLFNBQVM7QUFLZCxTQUFLLFVBQVU7QUFFZixTQUFLLFlBQVk7QUFLakIsU0FBSyxhQUFhO0FBRWxCLFNBQUssY0FBYztBQUVuQixTQUFLLGFBQWE7QUFFbEIsU0FBSyxPQUFPO0FBRVosU0FBSyxNQUFNO0FBQUEsRUFDZjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBT0EsQ0FBQyxJQUFJLFFBQVEsYUFBYSxPQUFPO0FBQzdCLFFBQUksUUFBUTtBQUNSLFdBQUssU0FBUyxLQUFLLFNBQVMsS0FBSyxTQUFTLFNBQVM7QUFDbkQsV0FBSyxhQUFhO0FBQUEsSUFDdEI7QUFDQSxTQUFLLFFBQVEsQ0FBQztBQUNkLFFBQUksT0FBTyxLQUFLLFFBQVE7QUFDeEIsV0FBTyxTQUFTLGNBQWMsS0FBSyxTQUFTLENBQUM7QUFDekMsYUFBTyxPQUFPLEtBQUssVUFBVSxJQUFJO0FBQUEsRUFDekM7QUFBQSxFQUNBLFlBQVk7QUFDUixRQUFJLElBQUksS0FBSztBQUNiLFFBQUksS0FBSyxLQUFLLE9BQU8sQ0FBQztBQUN0QixXQUFPLE9BQU8sT0FBTyxPQUFPO0FBQ3hCLFdBQUssS0FBSyxPQUFPLEVBQUUsQ0FBQztBQUN4QixRQUFJLENBQUMsTUFBTSxPQUFPLE9BQU8sT0FBTztBQUM1QixhQUFPO0FBQ1gsUUFBSSxPQUFPO0FBQ1AsYUFBTyxLQUFLLE9BQU8sSUFBSSxDQUFDLE1BQU07QUFDbEMsV0FBTztBQUFBLEVBQ1g7QUFBQSxFQUNBLE9BQU8sR0FBRztBQUNOLFdBQU8sS0FBSyxPQUFPLEtBQUssTUFBTSxDQUFDO0FBQUEsRUFDbkM7QUFBQSxFQUNBLGVBQWUsUUFBUTtBQUNuQixRQUFJLEtBQUssS0FBSyxPQUFPLE1BQU07QUFDM0IsUUFBSSxLQUFLLGFBQWEsR0FBRztBQUNyQixVQUFJLFNBQVM7QUFDYixhQUFPLE9BQU87QUFDVixhQUFLLEtBQUssT0FBTyxFQUFFLFNBQVMsTUFBTTtBQUN0QyxVQUFJLE9BQU8sTUFBTTtBQUNiLGNBQU0sT0FBTyxLQUFLLE9BQU8sU0FBUyxTQUFTLENBQUM7QUFDNUMsWUFBSSxTQUFTLFFBQVMsQ0FBQyxRQUFRLENBQUMsS0FBSztBQUNqQyxpQkFBTyxTQUFTLFNBQVM7QUFBQSxNQUNqQztBQUNBLGFBQU8sT0FBTyxRQUFRLFVBQVUsS0FBSyxjQUFlLENBQUMsTUFBTSxDQUFDLEtBQUssUUFDM0QsU0FBUyxTQUNUO0FBQUEsSUFDVjtBQUNBLFFBQUksT0FBTyxPQUFPLE9BQU8sS0FBSztBQUMxQixZQUFNLEtBQUssS0FBSyxPQUFPLE9BQU8sUUFBUSxDQUFDO0FBQ3ZDLFdBQUssT0FBTyxTQUFTLE9BQU8sVUFBVSxRQUFRLEtBQUssT0FBTyxTQUFTLENBQUMsQ0FBQztBQUNqRSxlQUFPO0FBQUEsSUFDZjtBQUNBLFdBQU87QUFBQSxFQUNYO0FBQUEsRUFDQSxVQUFVO0FBQ04sUUFBSSxNQUFNLEtBQUs7QUFDZixRQUFJLE9BQU8sUUFBUSxZQUFhLFFBQVEsTUFBTSxNQUFNLEtBQUssS0FBTTtBQUMzRCxZQUFNLEtBQUssT0FBTyxRQUFRLE1BQU0sS0FBSyxHQUFHO0FBQ3hDLFdBQUssYUFBYTtBQUFBLElBQ3RCO0FBQ0EsUUFBSSxRQUFRO0FBQ1IsYUFBTyxLQUFLLFFBQVEsS0FBSyxPQUFPLFVBQVUsS0FBSyxHQUFHLElBQUk7QUFDMUQsUUFBSSxLQUFLLE9BQU8sTUFBTSxDQUFDLE1BQU07QUFDekIsYUFBTztBQUNYLFdBQU8sS0FBSyxPQUFPLFVBQVUsS0FBSyxLQUFLLEdBQUc7QUFBQSxFQUM5QztBQUFBLEVBQ0EsU0FBUyxHQUFHO0FBQ1IsV0FBTyxLQUFLLE1BQU0sS0FBSyxLQUFLLE9BQU87QUFBQSxFQUN2QztBQUFBLEVBQ0EsUUFBUSxPQUFPO0FBQ1gsU0FBSyxTQUFTLEtBQUssT0FBTyxVQUFVLEtBQUssR0FBRztBQUM1QyxTQUFLLE1BQU07QUFDWCxTQUFLLGFBQWE7QUFDbEIsU0FBSyxPQUFPO0FBQ1osV0FBTztBQUFBLEVBQ1g7QUFBQSxFQUNBLEtBQUssR0FBRztBQUNKLFdBQU8sS0FBSyxPQUFPLE9BQU8sS0FBSyxLQUFLLENBQUM7QUFBQSxFQUN6QztBQUFBLEVBQ0EsQ0FBQyxVQUFVLE1BQU07QUFDYixZQUFRLE1BQU07QUFBQSxNQUNWLEtBQUs7QUFDRCxlQUFPLE9BQU8sS0FBSyxZQUFZO0FBQUEsTUFDbkMsS0FBSztBQUNELGVBQU8sT0FBTyxLQUFLLGVBQWU7QUFBQSxNQUN0QyxLQUFLO0FBQ0QsZUFBTyxPQUFPLEtBQUssZ0JBQWdCO0FBQUEsTUFDdkMsS0FBSztBQUNELGVBQU8sT0FBTyxLQUFLLGNBQWM7QUFBQSxNQUNyQyxLQUFLO0FBQ0QsZUFBTyxPQUFPLEtBQUssb0JBQW9CO0FBQUEsTUFDM0MsS0FBSztBQUNELGVBQU8sT0FBTyxLQUFLLGtCQUFrQjtBQUFBLE1BQ3pDLEtBQUs7QUFDRCxlQUFPLE9BQU8sS0FBSyxpQkFBaUI7QUFBQSxNQUN4QyxLQUFLO0FBQ0QsZUFBTyxPQUFPLEtBQUssaUJBQWlCO0FBQUEsSUFDNUM7QUFBQSxFQUNKO0FBQUEsRUFDQSxDQUFDLGNBQWM7QUFDWCxRQUFJLE9BQU8sS0FBSyxRQUFRO0FBQ3hCLFFBQUksU0FBUztBQUNULGFBQU8sS0FBSyxRQUFRLFFBQVE7QUFDaEMsUUFBSSxLQUFLLENBQUMsTUFBTSxLQUFLO0FBQ2pCLGFBQU8sS0FBSyxVQUFVLENBQUM7QUFDdkIsYUFBTyxLQUFLLFVBQVUsQ0FBQztBQUFBLElBQzNCO0FBQ0EsUUFBSSxLQUFLLENBQUMsTUFBTSxLQUFLO0FBQ2pCLFVBQUksU0FBUyxLQUFLO0FBQ2xCLFlBQU0sS0FBSyxLQUFLLFFBQVEsR0FBRztBQUMzQixVQUFJLE9BQU8sSUFBSTtBQUNYLGNBQU0sS0FBSyxLQUFLLEtBQUssQ0FBQztBQUN0QixZQUFJLE9BQU8sT0FBTyxPQUFPO0FBQ3JCLG1CQUFTLEtBQUs7QUFBQSxNQUN0QjtBQUNBLGFBQU8sTUFBTTtBQUNULGNBQU0sS0FBSyxLQUFLLFNBQVMsQ0FBQztBQUMxQixZQUFJLE9BQU8sT0FBTyxPQUFPO0FBQ3JCLG9CQUFVO0FBQUE7QUFFVjtBQUFBLE1BQ1I7QUFDQSxZQUFNLEtBQUssT0FBTyxLQUFLLFVBQVUsTUFBTSxNQUFNLE9BQU8sS0FBSyxXQUFXLElBQUk7QUFDeEUsYUFBTyxLQUFLLFVBQVUsS0FBSyxTQUFTLENBQUM7QUFDckMsV0FBSyxZQUFZO0FBQ2pCLGFBQU87QUFBQSxJQUNYO0FBQ0EsUUFBSSxLQUFLLFVBQVUsR0FBRztBQUNsQixZQUFNLEtBQUssT0FBTyxLQUFLLFdBQVcsSUFBSTtBQUN0QyxhQUFPLEtBQUssVUFBVSxLQUFLLFNBQVMsRUFBRTtBQUN0QyxhQUFPLEtBQUssWUFBWTtBQUN4QixhQUFPO0FBQUEsSUFDWDtBQUNBLFVBQU07QUFDTixXQUFPLE9BQU8sS0FBSyxlQUFlO0FBQUEsRUFDdEM7QUFBQSxFQUNBLENBQUMsaUJBQWlCO0FBQ2QsVUFBTSxLQUFLLEtBQUssT0FBTyxDQUFDO0FBQ3hCLFFBQUksQ0FBQyxNQUFNLENBQUMsS0FBSztBQUNiLGFBQU8sS0FBSyxRQUFRLFlBQVk7QUFDcEMsUUFBSSxPQUFPLE9BQU8sT0FBTyxLQUFLO0FBQzFCLFVBQUksQ0FBQyxLQUFLLFNBQVMsQ0FBQyxLQUFLLFNBQVMsQ0FBQztBQUMvQixlQUFPLEtBQUssUUFBUSxZQUFZO0FBQ3BDLFlBQU0sSUFBSSxLQUFLLEtBQUssQ0FBQztBQUNyQixVQUFJLE1BQU0sU0FBUyxRQUFRLEtBQUssT0FBTyxDQUFDLENBQUMsR0FBRztBQUN4QyxlQUFPLEtBQUssVUFBVSxDQUFDO0FBQ3ZCLGFBQUssY0FBYztBQUNuQixhQUFLLGFBQWE7QUFDbEIsZUFBTztBQUFBLE1BQ1gsV0FDUyxNQUFNLFNBQVMsUUFBUSxLQUFLLE9BQU8sQ0FBQyxDQUFDLEdBQUc7QUFDN0MsZUFBTyxLQUFLLFVBQVUsQ0FBQztBQUN2QixlQUFPO0FBQUEsTUFDWDtBQUFBLElBQ0o7QUFDQSxTQUFLLGNBQWMsT0FBTyxLQUFLLFdBQVcsS0FBSztBQUMvQyxRQUFJLEtBQUssYUFBYSxLQUFLLGVBQWUsQ0FBQyxRQUFRLEtBQUssT0FBTyxDQUFDLENBQUM7QUFDN0QsV0FBSyxhQUFhLEtBQUs7QUFDM0IsV0FBTyxPQUFPLEtBQUssZ0JBQWdCO0FBQUEsRUFDdkM7QUFBQSxFQUNBLENBQUMsa0JBQWtCO0FBQ2YsVUFBTSxDQUFDLEtBQUssR0FBRyxJQUFJLEtBQUssS0FBSyxDQUFDO0FBQzlCLFFBQUksQ0FBQyxPQUFPLENBQUMsS0FBSztBQUNkLGFBQU8sS0FBSyxRQUFRLGFBQWE7QUFDckMsU0FBSyxRQUFRLE9BQU8sUUFBUSxPQUFPLFFBQVEsUUFBUSxRQUFRLEdBQUcsR0FBRztBQUM3RCxZQUFNLEtBQUssT0FBTyxLQUFLLFVBQVUsQ0FBQyxNQUFNLE9BQU8sS0FBSyxXQUFXLElBQUk7QUFDbkUsV0FBSyxhQUFhLEtBQUssY0FBYztBQUNyQyxXQUFLLGVBQWU7QUFDcEIsYUFBTyxPQUFPLEtBQUssZ0JBQWdCO0FBQUEsSUFDdkM7QUFDQSxXQUFPO0FBQUEsRUFDWDtBQUFBLEVBQ0EsQ0FBQyxnQkFBZ0I7QUFDYixXQUFPLEtBQUssV0FBVyxJQUFJO0FBQzNCLFVBQU0sT0FBTyxLQUFLLFFBQVE7QUFDMUIsUUFBSSxTQUFTO0FBQ1QsYUFBTyxLQUFLLFFBQVEsS0FBSztBQUM3QixRQUFJLElBQUksT0FBTyxLQUFLLGVBQWU7QUFDbkMsWUFBUSxLQUFLLENBQUMsR0FBRztBQUFBLE1BQ2IsS0FBSztBQUNELGVBQU8sS0FBSyxVQUFVLEtBQUssU0FBUyxDQUFDO0FBQUEsTUFFekMsS0FBSztBQUNELGVBQU8sS0FBSyxZQUFZO0FBQ3hCLGVBQU8sT0FBTyxLQUFLLGVBQWU7QUFBQSxNQUN0QyxLQUFLO0FBQUEsTUFDTCxLQUFLO0FBQ0QsZUFBTyxLQUFLLFVBQVUsQ0FBQztBQUN2QixhQUFLLFVBQVU7QUFDZixhQUFLLFlBQVk7QUFDakIsZUFBTztBQUFBLE1BQ1gsS0FBSztBQUFBLE1BQ0wsS0FBSztBQUVELGVBQU8sS0FBSyxVQUFVLENBQUM7QUFDdkIsZUFBTztBQUFBLE1BQ1gsS0FBSztBQUNELGVBQU8sS0FBSyxVQUFVLGVBQWU7QUFDckMsZUFBTztBQUFBLE1BQ1gsS0FBSztBQUFBLE1BQ0wsS0FBSztBQUNELGVBQU8sT0FBTyxLQUFLLGtCQUFrQjtBQUFBLE1BQ3pDLEtBQUs7QUFBQSxNQUNMLEtBQUs7QUFDRCxhQUFLLE9BQU8sS0FBSyx1QkFBdUI7QUFDeEMsYUFBSyxPQUFPLEtBQUssV0FBVyxJQUFJO0FBQ2hDLGVBQU8sS0FBSyxVQUFVLEtBQUssU0FBUyxDQUFDO0FBQ3JDLGVBQU8sS0FBSyxZQUFZO0FBQ3hCLGVBQU8sT0FBTyxLQUFLLGlCQUFpQjtBQUFBLE1BQ3hDO0FBQ0ksZUFBTyxPQUFPLEtBQUssaUJBQWlCO0FBQUEsSUFDNUM7QUFBQSxFQUNKO0FBQUEsRUFDQSxDQUFDLHNCQUFzQjtBQUNuQixRQUFJLElBQUk7QUFDUixRQUFJLFNBQVM7QUFDYixPQUFHO0FBQ0MsV0FBSyxPQUFPLEtBQUssWUFBWTtBQUM3QixXQUFLLE9BQU8sS0FBSyxXQUFXLElBQUk7QUFDaEMsVUFBSSxLQUFLO0FBQ0wsYUFBSyxjQUFjLFNBQVM7QUFBQSxJQUNwQyxTQUFTLEtBQUssS0FBSztBQUNuQixVQUFNLE9BQU8sS0FBSyxRQUFRO0FBQzFCLFFBQUksU0FBUztBQUNULGFBQU8sS0FBSyxRQUFRLE1BQU07QUFDOUIsUUFBSyxXQUFXLE1BQU0sU0FBUyxLQUFLLGNBQWMsS0FBSyxDQUFDLE1BQU0sT0FDekQsV0FBVyxNQUNQLEtBQUssV0FBVyxLQUFLLEtBQUssS0FBSyxXQUFXLEtBQUssTUFDaEQsUUFBUSxLQUFLLENBQUMsQ0FBQyxHQUFJO0FBSXZCLFlBQU0sa0JBQWtCLFdBQVcsS0FBSyxhQUFhLEtBQ2pELEtBQUssY0FBYyxNQUNsQixLQUFLLENBQUMsTUFBTSxPQUFPLEtBQUssQ0FBQyxNQUFNO0FBQ3BDLFVBQUksQ0FBQyxpQkFBaUI7QUFFbEIsYUFBSyxZQUFZO0FBQ2pCLGNBQU07QUFDTixlQUFPLE9BQU8sS0FBSyxlQUFlO0FBQUEsTUFDdEM7QUFBQSxJQUNKO0FBQ0EsUUFBSSxJQUFJO0FBQ1IsV0FBTyxLQUFLLENBQUMsTUFBTSxLQUFLO0FBQ3BCLFdBQUssT0FBTyxLQUFLLFVBQVUsQ0FBQztBQUM1QixXQUFLLE9BQU8sS0FBSyxXQUFXLElBQUk7QUFDaEMsV0FBSyxVQUFVO0FBQUEsSUFDbkI7QUFDQSxTQUFLLE9BQU8sS0FBSyxlQUFlO0FBQ2hDLFlBQVEsS0FBSyxDQUFDLEdBQUc7QUFBQSxNQUNiLEtBQUs7QUFDRCxlQUFPO0FBQUEsTUFDWCxLQUFLO0FBQ0QsZUFBTyxLQUFLLFVBQVUsS0FBSyxTQUFTLENBQUM7QUFDckMsZUFBTztBQUFBLE1BQ1gsS0FBSztBQUFBLE1BQ0wsS0FBSztBQUNELGVBQU8sS0FBSyxVQUFVLENBQUM7QUFDdkIsYUFBSyxVQUFVO0FBQ2YsYUFBSyxhQUFhO0FBQ2xCLGVBQU87QUFBQSxNQUNYLEtBQUs7QUFBQSxNQUNMLEtBQUs7QUFDRCxlQUFPLEtBQUssVUFBVSxDQUFDO0FBQ3ZCLGFBQUssVUFBVTtBQUNmLGFBQUssYUFBYTtBQUNsQixlQUFPLEtBQUssWUFBWSxTQUFTO0FBQUEsTUFDckMsS0FBSztBQUNELGVBQU8sS0FBSyxVQUFVLGVBQWU7QUFDckMsZUFBTztBQUFBLE1BQ1gsS0FBSztBQUFBLE1BQ0wsS0FBSztBQUNELGFBQUssVUFBVTtBQUNmLGVBQU8sT0FBTyxLQUFLLGtCQUFrQjtBQUFBLE1BQ3pDLEtBQUssS0FBSztBQUNOLGNBQU0sT0FBTyxLQUFLLE9BQU8sQ0FBQztBQUMxQixZQUFJLEtBQUssV0FBVyxRQUFRLElBQUksS0FBSyxTQUFTLEtBQUs7QUFDL0MsZUFBSyxVQUFVO0FBQ2YsaUJBQU8sS0FBSyxVQUFVLENBQUM7QUFDdkIsaUJBQU8sS0FBSyxXQUFXLElBQUk7QUFDM0IsaUJBQU87QUFBQSxRQUNYO0FBQUEsTUFDSjtBQUFBLE1BRUE7QUFDSSxhQUFLLFVBQVU7QUFDZixlQUFPLE9BQU8sS0FBSyxpQkFBaUI7QUFBQSxJQUM1QztBQUFBLEVBQ0o7QUFBQSxFQUNBLENBQUMsb0JBQW9CO0FBQ2pCLFVBQU0sUUFBUSxLQUFLLE9BQU8sQ0FBQztBQUMzQixRQUFJLE1BQU0sS0FBSyxPQUFPLFFBQVEsT0FBTyxLQUFLLE1BQU0sQ0FBQztBQUNqRCxRQUFJLFVBQVUsS0FBSztBQUNmLGFBQU8sUUFBUSxNQUFNLEtBQUssT0FBTyxNQUFNLENBQUMsTUFBTTtBQUMxQyxjQUFNLEtBQUssT0FBTyxRQUFRLEtBQUssTUFBTSxDQUFDO0FBQUEsSUFDOUMsT0FDSztBQUVELGFBQU8sUUFBUSxJQUFJO0FBQ2YsWUFBSSxJQUFJO0FBQ1IsZUFBTyxLQUFLLE9BQU8sTUFBTSxJQUFJLENBQUMsTUFBTTtBQUNoQyxlQUFLO0FBQ1QsWUFBSSxJQUFJLE1BQU07QUFDVjtBQUNKLGNBQU0sS0FBSyxPQUFPLFFBQVEsS0FBSyxNQUFNLENBQUM7QUFBQSxNQUMxQztBQUFBLElBQ0o7QUFFQSxVQUFNLEtBQUssS0FBSyxPQUFPLFVBQVUsR0FBRyxHQUFHO0FBQ3ZDLFFBQUksS0FBSyxHQUFHLFFBQVEsTUFBTSxLQUFLLEdBQUc7QUFDbEMsUUFBSSxPQUFPLElBQUk7QUFDWCxhQUFPLE9BQU8sSUFBSTtBQUNkLGNBQU0sS0FBSyxLQUFLLGVBQWUsS0FBSyxDQUFDO0FBQ3JDLFlBQUksT0FBTztBQUNQO0FBQ0osYUFBSyxHQUFHLFFBQVEsTUFBTSxFQUFFO0FBQUEsTUFDNUI7QUFDQSxVQUFJLE9BQU8sSUFBSTtBQUVYLGNBQU0sTUFBTSxHQUFHLEtBQUssQ0FBQyxNQUFNLE9BQU8sSUFBSTtBQUFBLE1BQzFDO0FBQUEsSUFDSjtBQUNBLFFBQUksUUFBUSxJQUFJO0FBQ1osVUFBSSxDQUFDLEtBQUs7QUFDTixlQUFPLEtBQUssUUFBUSxlQUFlO0FBQ3ZDLFlBQU0sS0FBSyxPQUFPO0FBQUEsSUFDdEI7QUFDQSxXQUFPLEtBQUssWUFBWSxNQUFNLEdBQUcsS0FBSztBQUN0QyxXQUFPLEtBQUssWUFBWSxTQUFTO0FBQUEsRUFDckM7QUFBQSxFQUNBLENBQUMseUJBQXlCO0FBQ3RCLFNBQUssb0JBQW9CO0FBQ3pCLFNBQUssa0JBQWtCO0FBQ3ZCLFFBQUksSUFBSSxLQUFLO0FBQ2IsV0FBTyxNQUFNO0FBQ1QsWUFBTSxLQUFLLEtBQUssT0FBTyxFQUFFLENBQUM7QUFDMUIsVUFBSSxPQUFPO0FBQ1AsYUFBSyxrQkFBa0I7QUFBQSxlQUNsQixLQUFLLE9BQU8sTUFBTTtBQUN2QixhQUFLLG9CQUFvQixPQUFPLEVBQUUsSUFBSTtBQUFBLGVBQ2pDLE9BQU87QUFDWjtBQUFBLElBQ1I7QUFDQSxXQUFPLE9BQU8sS0FBSyxVQUFVLFFBQU0sUUFBUSxFQUFFLEtBQUssT0FBTyxHQUFHO0FBQUEsRUFDaEU7QUFBQSxFQUNBLENBQUMsbUJBQW1CO0FBQ2hCLFFBQUksS0FBSyxLQUFLLE1BQU07QUFDcEIsUUFBSSxTQUFTO0FBQ2IsUUFBSTtBQUNKO0FBQU0sZUFBUyxJQUFJLEtBQUssS0FBTSxLQUFLLEtBQUssT0FBTyxDQUFDLEdBQUksRUFBRSxHQUFHO0FBQ3JELGdCQUFRLElBQUk7QUFBQSxVQUNSLEtBQUs7QUFDRCxzQkFBVTtBQUNWO0FBQUEsVUFDSixLQUFLO0FBQ0QsaUJBQUs7QUFDTCxxQkFBUztBQUNUO0FBQUEsVUFDSixLQUFLLE1BQU07QUFDUCxrQkFBTSxPQUFPLEtBQUssT0FBTyxJQUFJLENBQUM7QUFDOUIsZ0JBQUksQ0FBQyxRQUFRLENBQUMsS0FBSztBQUNmLHFCQUFPLEtBQUssUUFBUSxjQUFjO0FBQ3RDLGdCQUFJLFNBQVM7QUFDVDtBQUFBLFVBQ1I7QUFBQSxVQUNBO0FBQ0ksa0JBQU07QUFBQSxRQUNkO0FBQUEsTUFDSjtBQUNBLFFBQUksQ0FBQyxNQUFNLENBQUMsS0FBSztBQUNiLGFBQU8sS0FBSyxRQUFRLGNBQWM7QUFDdEMsUUFBSSxVQUFVLEtBQUssWUFBWTtBQUMzQixVQUFJLEtBQUssc0JBQXNCO0FBQzNCLGFBQUssYUFBYTtBQUFBO0FBRWxCLGFBQUssY0FBYyxLQUFLO0FBQzVCLFNBQUc7QUFDQyxjQUFNLEtBQUssS0FBSyxlQUFlLEtBQUssQ0FBQztBQUNyQyxZQUFJLE9BQU87QUFDUDtBQUNKLGFBQUssS0FBSyxPQUFPLFFBQVEsTUFBTSxFQUFFO0FBQUEsTUFDckMsU0FBUyxPQUFPO0FBQ2hCLFVBQUksT0FBTyxJQUFJO0FBQ1gsWUFBSSxDQUFDLEtBQUs7QUFDTixpQkFBTyxLQUFLLFFBQVEsY0FBYztBQUN0QyxhQUFLLEtBQUssT0FBTztBQUFBLE1BQ3JCO0FBQUEsSUFDSjtBQUNBLFFBQUksQ0FBQyxLQUFLLGlCQUFpQjtBQUN2QixTQUFHO0FBQ0MsWUFBSSxJQUFJLEtBQUs7QUFDYixZQUFJRyxNQUFLLEtBQUssT0FBTyxDQUFDO0FBQ3RCLFlBQUlBLFFBQU87QUFDUCxVQUFBQSxNQUFLLEtBQUssT0FBTyxFQUFFLENBQUM7QUFDeEIsZUFBT0EsUUFBTyxPQUFPQSxRQUFPO0FBQ3hCLFVBQUFBLE1BQUssS0FBSyxPQUFPLEVBQUUsQ0FBQztBQUN4QixZQUFJQSxRQUFPLFFBQVEsS0FBSyxLQUFLO0FBQ3pCLGVBQUs7QUFBQTtBQUVMO0FBQUEsTUFDUixTQUFTO0FBQUEsSUFDYjtBQUNBLFVBQU1DO0FBQ04sV0FBTyxLQUFLLFlBQVksS0FBSyxHQUFHLElBQUk7QUFDcEMsV0FBTyxPQUFPLEtBQUssZUFBZTtBQUFBLEVBQ3RDO0FBQUEsRUFDQSxDQUFDLG1CQUFtQjtBQUNoQixVQUFNLFNBQVMsS0FBSyxZQUFZO0FBQ2hDLFFBQUksTUFBTSxLQUFLLE1BQU07QUFDckIsUUFBSSxJQUFJLEtBQUssTUFBTTtBQUNuQixRQUFJO0FBQ0osV0FBUSxLQUFLLEtBQUssT0FBTyxFQUFFLENBQUMsR0FBSTtBQUM1QixVQUFJLE9BQU8sS0FBSztBQUNaLGNBQU0sT0FBTyxLQUFLLE9BQU8sSUFBSSxDQUFDO0FBQzlCLFlBQUksUUFBUSxJQUFJLEtBQU0sVUFBVSxTQUFTO0FBQ3JDO0FBQ0osY0FBTTtBQUFBLE1BQ1YsV0FDUyxRQUFRLEVBQUUsR0FBRztBQUNsQixZQUFJLE9BQU8sS0FBSyxPQUFPLElBQUksQ0FBQztBQUM1QixZQUFJLE9BQU8sTUFBTTtBQUNiLGNBQUksU0FBUyxNQUFNO0FBQ2YsaUJBQUs7QUFDTCxpQkFBSztBQUNMLG1CQUFPLEtBQUssT0FBTyxJQUFJLENBQUM7QUFBQSxVQUM1QjtBQUVJLGtCQUFNO0FBQUEsUUFDZDtBQUNBLFlBQUksU0FBUyxPQUFRLFVBQVUsdUJBQXVCLFNBQVMsSUFBSTtBQUMvRDtBQUNKLFlBQUksT0FBTyxNQUFNO0FBQ2IsZ0JBQU0sS0FBSyxLQUFLLGVBQWUsSUFBSSxDQUFDO0FBQ3BDLGNBQUksT0FBTztBQUNQO0FBQ0osY0FBSSxLQUFLLElBQUksR0FBRyxLQUFLLENBQUM7QUFBQSxRQUMxQjtBQUFBLE1BQ0osT0FDSztBQUNELFlBQUksVUFBVSx1QkFBdUIsU0FBUyxFQUFFO0FBQzVDO0FBQ0osY0FBTTtBQUFBLE1BQ1Y7QUFBQSxJQUNKO0FBQ0EsUUFBSSxDQUFDLE1BQU0sQ0FBQyxLQUFLO0FBQ2IsYUFBTyxLQUFLLFFBQVEsY0FBYztBQUN0QyxVQUFNQTtBQUNOLFdBQU8sS0FBSyxZQUFZLE1BQU0sR0FBRyxJQUFJO0FBQ3JDLFdBQU8sU0FBUyxTQUFTO0FBQUEsRUFDN0I7QUFBQSxFQUNBLENBQUMsVUFBVSxHQUFHO0FBQ1YsUUFBSSxJQUFJLEdBQUc7QUFDUCxZQUFNLEtBQUssT0FBTyxPQUFPLEtBQUssS0FBSyxDQUFDO0FBQ3BDLFdBQUssT0FBTztBQUNaLGFBQU87QUFBQSxJQUNYO0FBQ0EsV0FBTztBQUFBLEVBQ1g7QUFBQSxFQUNBLENBQUMsWUFBWSxHQUFHLFlBQVk7QUFDeEIsVUFBTSxJQUFJLEtBQUssT0FBTyxNQUFNLEtBQUssS0FBSyxDQUFDO0FBQ3ZDLFFBQUksR0FBRztBQUNILFlBQU07QUFDTixXQUFLLE9BQU8sRUFBRTtBQUNkLGFBQU8sRUFBRTtBQUFBLElBQ2IsV0FDUztBQUNMLFlBQU07QUFDVixXQUFPO0FBQUEsRUFDWDtBQUFBLEVBQ0EsQ0FBQyxpQkFBaUI7QUFDZCxZQUFRLEtBQUssT0FBTyxDQUFDLEdBQUc7QUFBQSxNQUNwQixLQUFLO0FBQ0QsZ0JBQVMsT0FBTyxLQUFLLFFBQVEsTUFDeEIsT0FBTyxLQUFLLFdBQVcsSUFBSSxNQUMzQixPQUFPLEtBQUssZUFBZTtBQUFBLE1BQ3BDLEtBQUs7QUFDRCxnQkFBUyxPQUFPLEtBQUssVUFBVSxlQUFlLE1BQ3pDLE9BQU8sS0FBSyxXQUFXLElBQUksTUFDM0IsT0FBTyxLQUFLLGVBQWU7QUFBQSxNQUNwQyxLQUFLO0FBQUEsTUFDTCxLQUFLO0FBQUEsTUFDTCxLQUFLO0FBQ0QsWUFBSSxRQUFRLEtBQUssT0FBTyxDQUFDLENBQUMsR0FBRztBQUN6QixjQUFJLEtBQUssY0FBYztBQUNuQixpQkFBSyxhQUFhLEtBQUssY0FBYztBQUFBLG1CQUNoQyxLQUFLO0FBQ1YsaUJBQUssVUFBVTtBQUNuQixrQkFBUyxPQUFPLEtBQUssVUFBVSxDQUFDLE1BQzNCLE9BQU8sS0FBSyxXQUFXLElBQUksTUFDM0IsT0FBTyxLQUFLLGVBQWU7QUFBQSxRQUNwQztBQUFBLElBQ1I7QUFDQSxXQUFPO0FBQUEsRUFDWDtBQUFBLEVBQ0EsQ0FBQyxVQUFVO0FBQ1AsUUFBSSxLQUFLLE9BQU8sQ0FBQyxNQUFNLEtBQUs7QUFDeEIsVUFBSSxJQUFJLEtBQUssTUFBTTtBQUNuQixVQUFJLEtBQUssS0FBSyxPQUFPLENBQUM7QUFDdEIsYUFBTyxDQUFDLFFBQVEsRUFBRSxLQUFLLE9BQU87QUFDMUIsYUFBSyxLQUFLLE9BQU8sRUFBRSxDQUFDO0FBQ3hCLGFBQU8sT0FBTyxLQUFLLFlBQVksT0FBTyxNQUFNLElBQUksSUFBSSxHQUFHLEtBQUs7QUFBQSxJQUNoRSxPQUNLO0FBQ0QsVUFBSSxJQUFJLEtBQUssTUFBTTtBQUNuQixVQUFJLEtBQUssS0FBSyxPQUFPLENBQUM7QUFDdEIsYUFBTyxJQUFJO0FBQ1AsWUFBSSxTQUFTLFNBQVMsRUFBRTtBQUNwQixlQUFLLEtBQUssT0FBTyxFQUFFLENBQUM7QUFBQSxpQkFDZixPQUFPLE9BQ1osVUFBVSxTQUFTLEtBQUssT0FBTyxJQUFJLENBQUMsQ0FBQyxLQUNyQyxVQUFVLFNBQVMsS0FBSyxPQUFPLElBQUksQ0FBQyxDQUFDLEdBQUc7QUFDeEMsZUFBSyxLQUFLLE9BQVEsS0FBSyxDQUFFO0FBQUEsUUFDN0I7QUFFSTtBQUFBLE1BQ1I7QUFDQSxhQUFPLE9BQU8sS0FBSyxZQUFZLEdBQUcsS0FBSztBQUFBLElBQzNDO0FBQUEsRUFDSjtBQUFBLEVBQ0EsQ0FBQyxjQUFjO0FBQ1gsVUFBTSxLQUFLLEtBQUssT0FBTyxLQUFLLEdBQUc7QUFDL0IsUUFBSSxPQUFPO0FBQ1AsYUFBTyxPQUFPLEtBQUssVUFBVSxDQUFDO0FBQUEsYUFDekIsT0FBTyxRQUFRLEtBQUssT0FBTyxDQUFDLE1BQU07QUFDdkMsYUFBTyxPQUFPLEtBQUssVUFBVSxDQUFDO0FBQUE7QUFFOUIsYUFBTztBQUFBLEVBQ2Y7QUFBQSxFQUNBLENBQUMsV0FBVyxXQUFXO0FBQ25CLFFBQUksSUFBSSxLQUFLLE1BQU07QUFDbkIsUUFBSTtBQUNKLE9BQUc7QUFDQyxXQUFLLEtBQUssT0FBTyxFQUFFLENBQUM7QUFBQSxJQUN4QixTQUFTLE9BQU8sT0FBUSxhQUFhLE9BQU87QUFDNUMsVUFBTSxJQUFJLElBQUksS0FBSztBQUNuQixRQUFJLElBQUksR0FBRztBQUNQLFlBQU0sS0FBSyxPQUFPLE9BQU8sS0FBSyxLQUFLLENBQUM7QUFDcEMsV0FBSyxNQUFNO0FBQUEsSUFDZjtBQUNBLFdBQU87QUFBQSxFQUNYO0FBQUEsRUFDQSxDQUFDLFVBQVUsTUFBTTtBQUNiLFFBQUksSUFBSSxLQUFLO0FBQ2IsUUFBSSxLQUFLLEtBQUssT0FBTyxDQUFDO0FBQ3RCLFdBQU8sQ0FBQyxLQUFLLEVBQUU7QUFDWCxXQUFLLEtBQUssT0FBTyxFQUFFLENBQUM7QUFDeEIsV0FBTyxPQUFPLEtBQUssWUFBWSxHQUFHLEtBQUs7QUFBQSxFQUMzQztBQUNKOzs7QUM1cUJBLElBQU0sY0FBTixNQUFrQjtBQUFBLEVBQ2QsY0FBYztBQUNWLFNBQUssYUFBYSxDQUFDO0FBS25CLFNBQUssYUFBYSxDQUFDLFdBQVcsS0FBSyxXQUFXLEtBQUssTUFBTTtBQU16RCxTQUFLLFVBQVUsQ0FBQyxXQUFXO0FBQ3ZCLFVBQUksTUFBTTtBQUNWLFVBQUksT0FBTyxLQUFLLFdBQVc7QUFDM0IsYUFBTyxNQUFNLE1BQU07QUFDZixjQUFNLE1BQU8sTUFBTSxRQUFTO0FBQzVCLFlBQUksS0FBSyxXQUFXLEdBQUcsSUFBSTtBQUN2QixnQkFBTSxNQUFNO0FBQUE7QUFFWixpQkFBTztBQUFBLE1BQ2Y7QUFDQSxVQUFJLEtBQUssV0FBVyxHQUFHLE1BQU07QUFDekIsZUFBTyxFQUFFLE1BQU0sTUFBTSxHQUFHLEtBQUssRUFBRTtBQUNuQyxVQUFJLFFBQVE7QUFDUixlQUFPLEVBQUUsTUFBTSxHQUFHLEtBQUssT0FBTztBQUNsQyxZQUFNLFFBQVEsS0FBSyxXQUFXLE1BQU0sQ0FBQztBQUNyQyxhQUFPLEVBQUUsTUFBTSxLQUFLLEtBQUssU0FBUyxRQUFRLEVBQUU7QUFBQSxJQUNoRDtBQUFBLEVBQ0o7QUFDSjs7O0FDakNBLFNBQVMsY0FBYyxNQUFNLE1BQU07QUFDL0IsV0FBUyxJQUFJLEdBQUcsSUFBSSxLQUFLLFFBQVEsRUFBRTtBQUMvQixRQUFJLEtBQUssQ0FBQyxFQUFFLFNBQVM7QUFDakIsYUFBTztBQUNmLFNBQU87QUFDWDtBQUNBLFNBQVMsaUJBQWlCLE1BQU07QUFDNUIsV0FBUyxJQUFJLEdBQUcsSUFBSSxLQUFLLFFBQVEsRUFBRSxHQUFHO0FBQ2xDLFlBQVEsS0FBSyxDQUFDLEVBQUUsTUFBTTtBQUFBLE1BQ2xCLEtBQUs7QUFBQSxNQUNMLEtBQUs7QUFBQSxNQUNMLEtBQUs7QUFDRDtBQUFBLE1BQ0o7QUFDSSxlQUFPO0FBQUEsSUFDZjtBQUFBLEVBQ0o7QUFDQSxTQUFPO0FBQ1g7QUFDQSxTQUFTLFlBQVksT0FBTztBQUN4QixVQUFRLFVBQVUsUUFBUSxVQUFVLFNBQVMsU0FBUyxNQUFNLE1BQU07QUFBQSxJQUM5RCxLQUFLO0FBQUEsSUFDTCxLQUFLO0FBQUEsSUFDTCxLQUFLO0FBQUEsSUFDTCxLQUFLO0FBQUEsSUFDTCxLQUFLO0FBQ0QsYUFBTztBQUFBLElBQ1g7QUFDSSxhQUFPO0FBQUEsRUFDZjtBQUNKO0FBQ0EsU0FBUyxhQUFhLFFBQVE7QUFDMUIsVUFBUSxPQUFPLE1BQU07QUFBQSxJQUNqQixLQUFLO0FBQ0QsYUFBTyxPQUFPO0FBQUEsSUFDbEIsS0FBSyxhQUFhO0FBQ2QsWUFBTSxLQUFLLE9BQU8sTUFBTSxPQUFPLE1BQU0sU0FBUyxDQUFDO0FBQy9DLGFBQU8sR0FBRyxPQUFPLEdBQUc7QUFBQSxJQUN4QjtBQUFBLElBQ0EsS0FBSztBQUNELGFBQU8sT0FBTyxNQUFNLE9BQU8sTUFBTSxTQUFTLENBQUMsRUFBRTtBQUFBLElBRWpEO0FBQ0ksYUFBTyxDQUFDO0FBQUEsRUFDaEI7QUFDSjtBQUVBLFNBQVMsc0JBQXNCLE1BQU07QUFDakMsTUFBSTtBQUNKLE1BQUksS0FBSyxXQUFXO0FBQ2hCLFdBQU8sQ0FBQztBQUNaLE1BQUksSUFBSSxLQUFLO0FBQ2I7QUFBTSxXQUFPLEVBQUUsS0FBSyxHQUFHO0FBQ25CLGNBQVEsS0FBSyxDQUFDLEVBQUUsTUFBTTtBQUFBLFFBQ2xCLEtBQUs7QUFBQSxRQUNMLEtBQUs7QUFBQSxRQUNMLEtBQUs7QUFBQSxRQUNMLEtBQUs7QUFBQSxRQUNMLEtBQUs7QUFDRCxnQkFBTTtBQUFBLE1BQ2Q7QUFBQSxJQUNKO0FBQ0EsV0FBUyxLQUFLLEtBQUssRUFBRSxDQUFDLE9BQU8sUUFBUSxPQUFPLFNBQVMsU0FBUyxHQUFHLFVBQVUsU0FBUztBQUFBLEVBRXBGO0FBQ0EsU0FBTyxLQUFLLE9BQU8sR0FBRyxLQUFLLE1BQU07QUFDckM7QUFDQSxTQUFTLGdCQUFnQixJQUFJO0FBQ3pCLE1BQUksR0FBRyxNQUFNLFNBQVMsa0JBQWtCO0FBQ3BDLGVBQVcsTUFBTSxHQUFHLE9BQU87QUFDdkIsVUFBSSxHQUFHLE9BQ0gsQ0FBQyxHQUFHLFNBQ0osQ0FBQyxjQUFjLEdBQUcsT0FBTyxrQkFBa0IsS0FDM0MsQ0FBQyxjQUFjLEdBQUcsS0FBSyxlQUFlLEdBQUc7QUFDekMsWUFBSSxHQUFHO0FBQ0gsYUFBRyxRQUFRLEdBQUc7QUFDbEIsZUFBTyxHQUFHO0FBQ1YsWUFBSSxZQUFZLEdBQUcsS0FBSyxHQUFHO0FBQ3ZCLGNBQUksR0FBRyxNQUFNO0FBQ1Qsa0JBQU0sVUFBVSxLQUFLLE1BQU0sR0FBRyxNQUFNLEtBQUssR0FBRyxHQUFHO0FBQUE7QUFFL0MsZUFBRyxNQUFNLE1BQU0sR0FBRztBQUFBLFFBQzFCO0FBRUksZ0JBQU0sVUFBVSxLQUFLLE1BQU0sR0FBRyxPQUFPLEdBQUcsR0FBRztBQUMvQyxlQUFPLEdBQUc7QUFBQSxNQUNkO0FBQUEsSUFDSjtBQUFBLEVBQ0o7QUFDSjtBQTRCQSxJQUFNLFNBQU4sTUFBYTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFLVCxZQUFZLFdBQVc7QUFFbkIsU0FBSyxZQUFZO0FBRWpCLFNBQUssV0FBVztBQUVoQixTQUFLLFNBQVM7QUFFZCxTQUFLLFNBQVM7QUFFZCxTQUFLLFlBQVk7QUFFakIsU0FBSyxRQUFRLENBQUM7QUFFZCxTQUFLLFNBQVM7QUFFZCxTQUFLLE9BQU87QUFFWixTQUFLLFFBQVEsSUFBSSxNQUFNO0FBQ3ZCLFNBQUssWUFBWTtBQUFBLEVBQ3JCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBU0EsQ0FBQyxNQUFNLFFBQVEsYUFBYSxPQUFPO0FBQy9CLFFBQUksS0FBSyxhQUFhLEtBQUssV0FBVztBQUNsQyxXQUFLLFVBQVUsQ0FBQztBQUNwQixlQUFXLFVBQVUsS0FBSyxNQUFNLElBQUksUUFBUSxVQUFVO0FBQ2xELGFBQU8sS0FBSyxLQUFLLE1BQU07QUFDM0IsUUFBSSxDQUFDO0FBQ0QsYUFBTyxLQUFLLElBQUk7QUFBQSxFQUN4QjtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBSUEsQ0FBQyxLQUFLLFFBQVE7QUFDVixTQUFLLFNBQVM7QUFDZCxRQUFJLEtBQUssVUFBVTtBQUNmLFdBQUssV0FBVztBQUNoQixhQUFPLEtBQUssS0FBSztBQUNqQixXQUFLLFVBQVUsT0FBTztBQUN0QjtBQUFBLElBQ0o7QUFDQSxVQUFNLE9BQU8sVUFBVSxNQUFNO0FBQzdCLFFBQUksQ0FBQyxNQUFNO0FBQ1AsWUFBTSxVQUFVLHFCQUFxQjtBQUNyQyxhQUFPLEtBQUssSUFBSSxFQUFFLE1BQU0sU0FBUyxRQUFRLEtBQUssUUFBUSxTQUFTLE9BQU8sQ0FBQztBQUN2RSxXQUFLLFVBQVUsT0FBTztBQUFBLElBQzFCLFdBQ1MsU0FBUyxVQUFVO0FBQ3hCLFdBQUssWUFBWTtBQUNqQixXQUFLLFdBQVc7QUFDaEIsV0FBSyxPQUFPO0FBQUEsSUFDaEIsT0FDSztBQUNELFdBQUssT0FBTztBQUNaLGFBQU8sS0FBSyxLQUFLO0FBQ2pCLGNBQVEsTUFBTTtBQUFBLFFBQ1YsS0FBSztBQUNELGVBQUssWUFBWTtBQUNqQixlQUFLLFNBQVM7QUFDZCxjQUFJLEtBQUs7QUFDTCxpQkFBSyxVQUFVLEtBQUssU0FBUyxPQUFPLE1BQU07QUFDOUM7QUFBQSxRQUNKLEtBQUs7QUFDRCxjQUFJLEtBQUssYUFBYSxPQUFPLENBQUMsTUFBTTtBQUNoQyxpQkFBSyxVQUFVLE9BQU87QUFDMUI7QUFBQSxRQUNKLEtBQUs7QUFBQSxRQUNMLEtBQUs7QUFBQSxRQUNMLEtBQUs7QUFDRCxjQUFJLEtBQUs7QUFDTCxpQkFBSyxVQUFVLE9BQU87QUFDMUI7QUFBQSxRQUNKLEtBQUs7QUFBQSxRQUNMLEtBQUs7QUFDRDtBQUFBLFFBQ0o7QUFDSSxlQUFLLFlBQVk7QUFBQSxNQUN6QjtBQUNBLFdBQUssVUFBVSxPQUFPO0FBQUEsSUFDMUI7QUFBQSxFQUNKO0FBQUE7QUFBQSxFQUVBLENBQUMsTUFBTTtBQUNILFdBQU8sS0FBSyxNQUFNLFNBQVM7QUFDdkIsYUFBTyxLQUFLLElBQUk7QUFBQSxFQUN4QjtBQUFBLEVBQ0EsSUFBSSxjQUFjO0FBQ2QsVUFBTSxLQUFLO0FBQUEsTUFDUCxNQUFNLEtBQUs7QUFBQSxNQUNYLFFBQVEsS0FBSztBQUFBLE1BQ2IsUUFBUSxLQUFLO0FBQUEsTUFDYixRQUFRLEtBQUs7QUFBQSxJQUNqQjtBQUNBLFdBQU87QUFBQSxFQUNYO0FBQUEsRUFDQSxDQUFDLE9BQU87QUFDSixVQUFNLE1BQU0sS0FBSyxLQUFLLENBQUM7QUFDdkIsUUFBSSxLQUFLLFNBQVMsY0FBYyxDQUFDLE9BQU8sSUFBSSxTQUFTLFlBQVk7QUFDN0QsYUFBTyxLQUFLLE1BQU0sU0FBUztBQUN2QixlQUFPLEtBQUssSUFBSTtBQUNwQixXQUFLLE1BQU0sS0FBSztBQUFBLFFBQ1osTUFBTTtBQUFBLFFBQ04sUUFBUSxLQUFLO0FBQUEsUUFDYixRQUFRLEtBQUs7QUFBQSxNQUNqQixDQUFDO0FBQ0Q7QUFBQSxJQUNKO0FBQ0EsUUFBSSxDQUFDO0FBQ0QsYUFBTyxPQUFPLEtBQUssT0FBTztBQUM5QixZQUFRLElBQUksTUFBTTtBQUFBLE1BQ2QsS0FBSztBQUNELGVBQU8sT0FBTyxLQUFLLFNBQVMsR0FBRztBQUFBLE1BQ25DLEtBQUs7QUFBQSxNQUNMLEtBQUs7QUFBQSxNQUNMLEtBQUs7QUFBQSxNQUNMLEtBQUs7QUFDRCxlQUFPLE9BQU8sS0FBSyxPQUFPLEdBQUc7QUFBQSxNQUNqQyxLQUFLO0FBQ0QsZUFBTyxPQUFPLEtBQUssWUFBWSxHQUFHO0FBQUEsTUFDdEMsS0FBSztBQUNELGVBQU8sT0FBTyxLQUFLLFNBQVMsR0FBRztBQUFBLE1BQ25DLEtBQUs7QUFDRCxlQUFPLE9BQU8sS0FBSyxjQUFjLEdBQUc7QUFBQSxNQUN4QyxLQUFLO0FBQ0QsZUFBTyxPQUFPLEtBQUssZUFBZSxHQUFHO0FBQUEsTUFDekMsS0FBSztBQUNELGVBQU8sT0FBTyxLQUFLLFlBQVksR0FBRztBQUFBLElBQzFDO0FBRUEsV0FBTyxLQUFLLElBQUk7QUFBQSxFQUNwQjtBQUFBLEVBQ0EsS0FBSyxHQUFHO0FBQ0osV0FBTyxLQUFLLE1BQU0sS0FBSyxNQUFNLFNBQVMsQ0FBQztBQUFBLEVBQzNDO0FBQUEsRUFDQSxDQUFDLElBQUksT0FBTztBQUNSLFVBQU0sUUFBUSxTQUFTLEtBQUssTUFBTSxJQUFJO0FBRXRDLFFBQUksQ0FBQyxPQUFPO0FBQ1IsWUFBTSxVQUFVO0FBQ2hCLFlBQU0sRUFBRSxNQUFNLFNBQVMsUUFBUSxLQUFLLFFBQVEsUUFBUSxJQUFJLFFBQVE7QUFBQSxJQUNwRSxXQUNTLEtBQUssTUFBTSxXQUFXLEdBQUc7QUFDOUIsWUFBTTtBQUFBLElBQ1YsT0FDSztBQUNELFlBQU0sTUFBTSxLQUFLLEtBQUssQ0FBQztBQUN2QixVQUFJLE1BQU0sU0FBUyxnQkFBZ0I7QUFFL0IsY0FBTSxTQUFTLFlBQVksTUFBTSxJQUFJLFNBQVM7QUFBQSxNQUNsRCxXQUNTLE1BQU0sU0FBUyxxQkFBcUIsSUFBSSxTQUFTLFlBQVk7QUFFbEUsY0FBTSxTQUFTO0FBQUEsTUFDbkI7QUFDQSxVQUFJLE1BQU0sU0FBUztBQUNmLHdCQUFnQixLQUFLO0FBQ3pCLGNBQVEsSUFBSSxNQUFNO0FBQUEsUUFDZCxLQUFLO0FBQ0QsY0FBSSxRQUFRO0FBQ1o7QUFBQSxRQUNKLEtBQUs7QUFDRCxjQUFJLE1BQU0sS0FBSyxLQUFLO0FBQ3BCO0FBQUEsUUFDSixLQUFLLGFBQWE7QUFDZCxnQkFBTSxLQUFLLElBQUksTUFBTSxJQUFJLE1BQU0sU0FBUyxDQUFDO0FBQ3pDLGNBQUksR0FBRyxPQUFPO0FBQ1YsZ0JBQUksTUFBTSxLQUFLLEVBQUUsT0FBTyxDQUFDLEdBQUcsS0FBSyxPQUFPLEtBQUssQ0FBQyxFQUFFLENBQUM7QUFDakQsaUJBQUssWUFBWTtBQUNqQjtBQUFBLFVBQ0osV0FDUyxHQUFHLEtBQUs7QUFDYixlQUFHLFFBQVE7QUFBQSxVQUNmLE9BQ0s7QUFDRCxtQkFBTyxPQUFPLElBQUksRUFBRSxLQUFLLE9BQU8sS0FBSyxDQUFDLEVBQUUsQ0FBQztBQUN6QyxpQkFBSyxZQUFZLENBQUMsY0FBYyxHQUFHLE9BQU8sa0JBQWtCO0FBQzVEO0FBQUEsVUFDSjtBQUNBO0FBQUEsUUFDSjtBQUFBLFFBQ0EsS0FBSyxhQUFhO0FBQ2QsZ0JBQU0sS0FBSyxJQUFJLE1BQU0sSUFBSSxNQUFNLFNBQVMsQ0FBQztBQUN6QyxjQUFJLEdBQUc7QUFDSCxnQkFBSSxNQUFNLEtBQUssRUFBRSxPQUFPLENBQUMsR0FBRyxPQUFPLE1BQU0sQ0FBQztBQUFBO0FBRTFDLGVBQUcsUUFBUTtBQUNmO0FBQUEsUUFDSjtBQUFBLFFBQ0EsS0FBSyxtQkFBbUI7QUFDcEIsZ0JBQU0sS0FBSyxJQUFJLE1BQU0sSUFBSSxNQUFNLFNBQVMsQ0FBQztBQUN6QyxjQUFJLENBQUMsTUFBTSxHQUFHO0FBQ1YsZ0JBQUksTUFBTSxLQUFLLEVBQUUsT0FBTyxDQUFDLEdBQUcsS0FBSyxPQUFPLEtBQUssQ0FBQyxFQUFFLENBQUM7QUFBQSxtQkFDNUMsR0FBRztBQUNSLGVBQUcsUUFBUTtBQUFBO0FBRVgsbUJBQU8sT0FBTyxJQUFJLEVBQUUsS0FBSyxPQUFPLEtBQUssQ0FBQyxFQUFFLENBQUM7QUFDN0M7QUFBQSxRQUNKO0FBQUEsUUFFQTtBQUNJLGlCQUFPLEtBQUssSUFBSTtBQUNoQixpQkFBTyxLQUFLLElBQUksS0FBSztBQUFBLE1BQzdCO0FBQ0EsV0FBSyxJQUFJLFNBQVMsY0FDZCxJQUFJLFNBQVMsZUFDYixJQUFJLFNBQVMsaUJBQ1osTUFBTSxTQUFTLGVBQWUsTUFBTSxTQUFTLGNBQWM7QUFDNUQsY0FBTSxPQUFPLE1BQU0sTUFBTSxNQUFNLE1BQU0sU0FBUyxDQUFDO0FBQy9DLFlBQUksUUFDQSxDQUFDLEtBQUssT0FDTixDQUFDLEtBQUssU0FDTixLQUFLLE1BQU0sU0FBUyxLQUNwQixDQUFDLGlCQUFpQixLQUFLLEtBQUssTUFDM0IsTUFBTSxXQUFXLEtBQ2QsS0FBSyxNQUFNLE1BQU0sUUFBTSxHQUFHLFNBQVMsYUFBYSxHQUFHLFNBQVMsTUFBTSxNQUFNLElBQUk7QUFDaEYsY0FBSSxJQUFJLFNBQVM7QUFDYixnQkFBSSxNQUFNLEtBQUs7QUFBQTtBQUVmLGdCQUFJLE1BQU0sS0FBSyxFQUFFLE9BQU8sS0FBSyxNQUFNLENBQUM7QUFDeEMsZ0JBQU0sTUFBTSxPQUFPLElBQUksQ0FBQztBQUFBLFFBQzVCO0FBQUEsTUFDSjtBQUFBLElBQ0o7QUFBQSxFQUNKO0FBQUEsRUFDQSxDQUFDLFNBQVM7QUFDTixZQUFRLEtBQUssTUFBTTtBQUFBLE1BQ2YsS0FBSztBQUNELGNBQU0sRUFBRSxNQUFNLGFBQWEsUUFBUSxLQUFLLFFBQVEsUUFBUSxLQUFLLE9BQU87QUFDcEU7QUFBQSxNQUNKLEtBQUs7QUFBQSxNQUNMLEtBQUs7QUFBQSxNQUNMLEtBQUs7QUFBQSxNQUNMLEtBQUs7QUFDRCxjQUFNLEtBQUs7QUFDWDtBQUFBLE1BQ0osS0FBSztBQUFBLE1BQ0wsS0FBSyxhQUFhO0FBQ2QsY0FBTSxNQUFNO0FBQUEsVUFDUixNQUFNO0FBQUEsVUFDTixRQUFRLEtBQUs7QUFBQSxVQUNiLE9BQU8sQ0FBQztBQUFBLFFBQ1o7QUFDQSxZQUFJLEtBQUssU0FBUztBQUNkLGNBQUksTUFBTSxLQUFLLEtBQUssV0FBVztBQUNuQyxhQUFLLE1BQU0sS0FBSyxHQUFHO0FBQ25CO0FBQUEsTUFDSjtBQUFBLElBQ0o7QUFDQSxVQUFNO0FBQUEsTUFDRixNQUFNO0FBQUEsTUFDTixRQUFRLEtBQUs7QUFBQSxNQUNiLFNBQVMsY0FBYyxLQUFLO0FBQUEsTUFDNUIsUUFBUSxLQUFLO0FBQUEsSUFDakI7QUFBQSxFQUNKO0FBQUEsRUFDQSxDQUFDLFNBQVMsS0FBSztBQUNYLFFBQUksSUFBSTtBQUNKLGFBQU8sT0FBTyxLQUFLLFFBQVEsR0FBRztBQUNsQyxZQUFRLEtBQUssTUFBTTtBQUFBLE1BQ2YsS0FBSyxhQUFhO0FBQ2QsWUFBSSxpQkFBaUIsSUFBSSxLQUFLLEdBQUc7QUFDN0IsaUJBQU8sS0FBSyxJQUFJO0FBQ2hCLGlCQUFPLEtBQUssS0FBSztBQUFBLFFBQ3JCO0FBRUksY0FBSSxNQUFNLEtBQUssS0FBSyxXQUFXO0FBQ25DO0FBQUEsTUFDSjtBQUFBLE1BQ0EsS0FBSztBQUFBLE1BQ0wsS0FBSztBQUFBLE1BQ0wsS0FBSztBQUFBLE1BQ0wsS0FBSztBQUFBLE1BQ0wsS0FBSztBQUNELFlBQUksTUFBTSxLQUFLLEtBQUssV0FBVztBQUMvQjtBQUFBLElBQ1I7QUFDQSxVQUFNLEtBQUssS0FBSyxnQkFBZ0IsR0FBRztBQUNuQyxRQUFJO0FBQ0EsV0FBSyxNQUFNLEtBQUssRUFBRTtBQUFBLFNBQ2pCO0FBQ0QsWUFBTTtBQUFBLFFBQ0YsTUFBTTtBQUFBLFFBQ04sUUFBUSxLQUFLO0FBQUEsUUFDYixTQUFTLGNBQWMsS0FBSztBQUFBLFFBQzVCLFFBQVEsS0FBSztBQUFBLE1BQ2pCO0FBQUEsSUFDSjtBQUFBLEVBQ0o7QUFBQSxFQUNBLENBQUMsT0FBTyxRQUFRO0FBQ1osUUFBSSxLQUFLLFNBQVMsaUJBQWlCO0FBQy9CLFlBQU0sT0FBTyxhQUFhLEtBQUssS0FBSyxDQUFDLENBQUM7QUFDdEMsWUFBTSxRQUFRLHNCQUFzQixJQUFJO0FBQ3hDLFVBQUk7QUFDSixVQUFJLE9BQU8sS0FBSztBQUNaLGNBQU0sT0FBTztBQUNiLFlBQUksS0FBSyxLQUFLLFdBQVc7QUFDekIsZUFBTyxPQUFPO0FBQUEsTUFDbEI7QUFFSSxjQUFNLENBQUMsS0FBSyxXQUFXO0FBQzNCLFlBQU1DLE9BQU07QUFBQSxRQUNSLE1BQU07QUFBQSxRQUNOLFFBQVEsT0FBTztBQUFBLFFBQ2YsUUFBUSxPQUFPO0FBQUEsUUFDZixPQUFPLENBQUMsRUFBRSxPQUFPLEtBQUssUUFBUSxJQUFJLENBQUM7QUFBQSxNQUN2QztBQUNBLFdBQUssWUFBWTtBQUNqQixXQUFLLE1BQU0sS0FBSyxNQUFNLFNBQVMsQ0FBQyxJQUFJQTtBQUFBLElBQ3hDO0FBRUksYUFBTyxLQUFLLFFBQVEsTUFBTTtBQUFBLEVBQ2xDO0FBQUEsRUFDQSxDQUFDLFlBQVksUUFBUTtBQUNqQixZQUFRLEtBQUssTUFBTTtBQUFBLE1BQ2YsS0FBSztBQUFBLE1BQ0wsS0FBSztBQUFBLE1BQ0wsS0FBSztBQUNELGVBQU8sTUFBTSxLQUFLLEtBQUssV0FBVztBQUNsQztBQUFBLE1BQ0osS0FBSztBQUNELGVBQU8sU0FBUyxLQUFLO0FBRXJCLGFBQUssWUFBWTtBQUNqQixhQUFLLFNBQVM7QUFDZCxZQUFJLEtBQUssV0FBVztBQUNoQixjQUFJLEtBQUssS0FBSyxPQUFPLFFBQVEsSUFBSSxJQUFJO0FBQ3JDLGlCQUFPLE9BQU8sR0FBRztBQUNiLGlCQUFLLFVBQVUsS0FBSyxTQUFTLEVBQUU7QUFDL0IsaUJBQUssS0FBSyxPQUFPLFFBQVEsTUFBTSxFQUFFLElBQUk7QUFBQSxVQUN6QztBQUFBLFFBQ0o7QUFDQSxlQUFPLEtBQUssSUFBSTtBQUNoQjtBQUFBLE1BRUo7QUFDSSxlQUFPLEtBQUssSUFBSTtBQUNoQixlQUFPLEtBQUssS0FBSztBQUFBLElBQ3pCO0FBQUEsRUFDSjtBQUFBLEVBQ0EsQ0FBQyxTQUFTQSxNQUFLO0FBQ1gsUUFBSTtBQUNKLFVBQU0sS0FBS0EsS0FBSSxNQUFNQSxLQUFJLE1BQU0sU0FBUyxDQUFDO0FBRXpDLFlBQVEsS0FBSyxNQUFNO0FBQUEsTUFDZixLQUFLO0FBQ0QsYUFBSyxZQUFZO0FBQ2pCLFlBQUksR0FBRyxPQUFPO0FBQ1YsZ0JBQU0sTUFBTSxTQUFTLEdBQUcsUUFBUSxHQUFHLE1BQU0sTUFBTTtBQUMvQyxnQkFBTSxPQUFPLE1BQU0sUUFBUSxHQUFHLElBQUksSUFBSSxJQUFJLFNBQVMsQ0FBQyxJQUFJO0FBQ3hELGVBQUssU0FBUyxRQUFRLFNBQVMsU0FBUyxTQUFTLEtBQUssVUFBVTtBQUM1RCxvQkFBUSxRQUFRLFFBQVEsU0FBUyxTQUFTLElBQUksS0FBSyxLQUFLLFdBQVc7QUFBQTtBQUVuRSxZQUFBQSxLQUFJLE1BQU0sS0FBSyxFQUFFLE9BQU8sQ0FBQyxLQUFLLFdBQVcsRUFBRSxDQUFDO0FBQUEsUUFDcEQsV0FDUyxHQUFHO0FBQ1IsYUFBRyxJQUFJLEtBQUssS0FBSyxXQUFXO0FBQUE7QUFFNUIsYUFBRyxNQUFNLEtBQUssS0FBSyxXQUFXO0FBQ2xDO0FBQUEsTUFDSixLQUFLO0FBQUEsTUFDTCxLQUFLO0FBQ0QsWUFBSSxHQUFHO0FBQ0gsVUFBQUEsS0FBSSxNQUFNLEtBQUssRUFBRSxPQUFPLENBQUMsS0FBSyxXQUFXLEVBQUUsQ0FBQztBQUFBLGlCQUN2QyxHQUFHO0FBQ1IsYUFBRyxJQUFJLEtBQUssS0FBSyxXQUFXO0FBQUEsYUFDM0I7QUFDRCxjQUFJLEtBQUssa0JBQWtCLEdBQUcsT0FBT0EsS0FBSSxNQUFNLEdBQUc7QUFDOUMsa0JBQU0sT0FBT0EsS0FBSSxNQUFNQSxLQUFJLE1BQU0sU0FBUyxDQUFDO0FBQzNDLGtCQUFNLE9BQU8sS0FBSyxTQUFTLFFBQVEsU0FBUyxTQUFTLFNBQVMsS0FBSyxXQUFXLFFBQVEsT0FBTyxTQUFTLFNBQVMsR0FBRztBQUNsSCxnQkFBSSxNQUFNLFFBQVEsR0FBRyxHQUFHO0FBQ3BCLG9CQUFNLFVBQVUsS0FBSyxNQUFNLEtBQUssR0FBRyxLQUFLO0FBQ3hDLGtCQUFJLEtBQUssS0FBSyxXQUFXO0FBQ3pCLGNBQUFBLEtBQUksTUFBTSxJQUFJO0FBQ2Q7QUFBQSxZQUNKO0FBQUEsVUFDSjtBQUNBLGFBQUcsTUFBTSxLQUFLLEtBQUssV0FBVztBQUFBLFFBQ2xDO0FBQ0E7QUFBQSxJQUNSO0FBQ0EsUUFBSSxLQUFLLFVBQVVBLEtBQUksUUFBUTtBQUMzQixZQUFNLGFBQWEsQ0FBQyxLQUFLLGFBQ3JCLEtBQUssV0FBV0EsS0FBSSxXQUNuQixHQUFHLE9BQU8saUJBQWlCLEdBQUcsS0FBSztBQUN4QyxjQUFRLEtBQUssTUFBTTtBQUFBLFFBQ2YsS0FBSztBQUFBLFFBQ0wsS0FBSztBQUNELGNBQUksY0FBYyxHQUFHLE9BQU87QUFDeEIsWUFBQUEsS0FBSSxNQUFNLEtBQUssRUFBRSxPQUFPLENBQUMsS0FBSyxXQUFXLEVBQUUsQ0FBQztBQUM1QyxpQkFBSyxZQUFZO0FBQUEsVUFDckIsV0FDUyxHQUFHO0FBQ1IsZUFBRyxJQUFJLEtBQUssS0FBSyxXQUFXO0FBQUE7QUFFNUIsZUFBRyxNQUFNLEtBQUssS0FBSyxXQUFXO0FBQ2xDO0FBQUEsUUFDSixLQUFLO0FBQ0QsY0FBSSxDQUFDLEdBQUcsT0FBTyxDQUFDLGNBQWMsR0FBRyxPQUFPLGtCQUFrQjtBQUN0RCxlQUFHLE1BQU0sS0FBSyxLQUFLLFdBQVc7QUFBQSxtQkFDekIsY0FBYyxHQUFHO0FBQ3RCLFlBQUFBLEtBQUksTUFBTSxLQUFLLEVBQUUsT0FBTyxDQUFDLEtBQUssV0FBVyxFQUFFLENBQUM7QUFBQTtBQUU1QyxpQkFBSyxNQUFNLEtBQUs7QUFBQSxjQUNaLE1BQU07QUFBQSxjQUNOLFFBQVEsS0FBSztBQUFBLGNBQ2IsUUFBUSxLQUFLO0FBQUEsY0FDYixPQUFPLENBQUMsRUFBRSxPQUFPLENBQUMsS0FBSyxXQUFXLEVBQUUsQ0FBQztBQUFBLFlBQ3pDLENBQUM7QUFDTCxlQUFLLFlBQVk7QUFDakI7QUFBQSxRQUNKLEtBQUs7QUFDRCxjQUFJLENBQUMsR0FBRztBQUNKLG1CQUFPLE9BQU8sSUFBSSxFQUFFLEtBQUssTUFBTSxLQUFLLENBQUMsS0FBSyxXQUFXLEVBQUUsQ0FBQztBQUFBLG1CQUNuRCxHQUFHLFNBQ1AsY0FBYyxDQUFDLGNBQWMsR0FBRyxPQUFPLGtCQUFrQjtBQUMxRCxZQUFBQSxLQUFJLE1BQU0sS0FBSyxFQUFFLE9BQU8sQ0FBQyxHQUFHLEtBQUssTUFBTSxLQUFLLENBQUMsS0FBSyxXQUFXLEVBQUUsQ0FBQztBQUFBLG1CQUMzRCxjQUFjLEdBQUcsS0FBSyxlQUFlO0FBQzFDLGlCQUFLLE1BQU0sS0FBSztBQUFBLGNBQ1osTUFBTTtBQUFBLGNBQ04sUUFBUSxLQUFLO0FBQUEsY0FDYixRQUFRLEtBQUs7QUFBQSxjQUNiLE9BQU8sQ0FBQyxFQUFFLE9BQU8sQ0FBQyxHQUFHLEtBQUssTUFBTSxLQUFLLENBQUMsS0FBSyxXQUFXLEVBQUUsQ0FBQztBQUFBLFlBQzdELENBQUM7QUFBQSxtQkFDSSxjQUFjLEdBQUcsT0FBTyxrQkFBa0IsS0FDL0MsWUFBWSxHQUFHLEdBQUcsS0FDbEIsQ0FBQyxjQUFjLEdBQUcsS0FBSyxTQUFTLEdBQUc7QUFDbkMsa0JBQU0sUUFBUSxzQkFBc0IsR0FBRyxLQUFLO0FBQzVDLGtCQUFNLE1BQU0sR0FBRztBQUNmLGtCQUFNLE1BQU0sR0FBRztBQUNmLGdCQUFJLEtBQUssS0FBSyxXQUFXO0FBRXpCLG1CQUFPLEdBQUcsS0FBSyxPQUFPLEdBQUc7QUFDekIsaUJBQUssTUFBTSxLQUFLO0FBQUEsY0FDWixNQUFNO0FBQUEsY0FDTixRQUFRLEtBQUs7QUFBQSxjQUNiLFFBQVEsS0FBSztBQUFBLGNBQ2IsT0FBTyxDQUFDLEVBQUUsT0FBTyxLQUFLLElBQUksQ0FBQztBQUFBLFlBQy9CLENBQUM7QUFBQSxVQUNMO0FBRUksZUFBRyxJQUFJLEtBQUssS0FBSyxXQUFXO0FBQ2hDLGVBQUssWUFBWTtBQUNqQjtBQUFBLFFBQ0osS0FBSztBQUFBLFFBQ0wsS0FBSztBQUFBLFFBQ0wsS0FBSztBQUFBLFFBQ0wsS0FBSyx3QkFBd0I7QUFDekIsZ0JBQU0sS0FBSyxLQUFLLFdBQVcsS0FBSyxJQUFJO0FBQ3BDLGNBQUksY0FBYyxHQUFHLE9BQU87QUFDeEIsWUFBQUEsS0FBSSxNQUFNLEtBQUssRUFBRSxPQUFPLENBQUMsR0FBRyxLQUFLLElBQUksS0FBSyxDQUFDLEVBQUUsQ0FBQztBQUM5QyxpQkFBSyxZQUFZO0FBQUEsVUFDckIsV0FDUyxHQUFHLEtBQUs7QUFDYixpQkFBSyxNQUFNLEtBQUssRUFBRTtBQUFBLFVBQ3RCLE9BQ0s7QUFDRCxtQkFBTyxPQUFPLElBQUksRUFBRSxLQUFLLElBQUksS0FBSyxDQUFDLEVBQUUsQ0FBQztBQUN0QyxpQkFBSyxZQUFZO0FBQUEsVUFDckI7QUFDQTtBQUFBLFFBQ0o7QUFBQSxRQUNBLFNBQVM7QUFDTCxnQkFBTSxLQUFLLEtBQUssZ0JBQWdCQSxJQUFHO0FBQ25DLGNBQUksSUFBSTtBQUNKLGdCQUFJLGNBQ0EsR0FBRyxTQUFTLGVBQ1osY0FBYyxHQUFHLE9BQU8sa0JBQWtCO0FBQzFDLGNBQUFBLEtBQUksTUFBTSxLQUFLLEVBQUUsT0FBTyxDQUFDLEVBQUUsQ0FBQztBQUNoQyxpQkFBSyxNQUFNLEtBQUssRUFBRTtBQUNsQjtBQUFBLFVBQ0o7QUFBQSxRQUNKO0FBQUEsTUFDSjtBQUFBLElBQ0o7QUFDQSxXQUFPLEtBQUssSUFBSTtBQUNoQixXQUFPLEtBQUssS0FBSztBQUFBLEVBQ3JCO0FBQUEsRUFDQSxDQUFDLGNBQWNDLE1BQUs7QUFDaEIsUUFBSTtBQUNKLFVBQU0sS0FBS0EsS0FBSSxNQUFNQSxLQUFJLE1BQU0sU0FBUyxDQUFDO0FBQ3pDLFlBQVEsS0FBSyxNQUFNO0FBQUEsTUFDZixLQUFLO0FBQ0QsWUFBSSxHQUFHLE9BQU87QUFDVixnQkFBTSxNQUFNLFNBQVMsR0FBRyxRQUFRLEdBQUcsTUFBTSxNQUFNO0FBQy9DLGdCQUFNLE9BQU8sTUFBTSxRQUFRLEdBQUcsSUFBSSxJQUFJLElBQUksU0FBUyxDQUFDLElBQUk7QUFDeEQsZUFBSyxTQUFTLFFBQVEsU0FBUyxTQUFTLFNBQVMsS0FBSyxVQUFVO0FBQzVELG9CQUFRLFFBQVEsUUFBUSxTQUFTLFNBQVMsSUFBSSxLQUFLLEtBQUssV0FBVztBQUFBO0FBRW5FLFlBQUFBLEtBQUksTUFBTSxLQUFLLEVBQUUsT0FBTyxDQUFDLEtBQUssV0FBVyxFQUFFLENBQUM7QUFBQSxRQUNwRDtBQUVJLGFBQUcsTUFBTSxLQUFLLEtBQUssV0FBVztBQUNsQztBQUFBLE1BQ0osS0FBSztBQUFBLE1BQ0wsS0FBSztBQUNELFlBQUksR0FBRztBQUNILFVBQUFBLEtBQUksTUFBTSxLQUFLLEVBQUUsT0FBTyxDQUFDLEtBQUssV0FBVyxFQUFFLENBQUM7QUFBQSxhQUMzQztBQUNELGNBQUksS0FBSyxrQkFBa0IsR0FBRyxPQUFPQSxLQUFJLE1BQU0sR0FBRztBQUM5QyxrQkFBTSxPQUFPQSxLQUFJLE1BQU1BLEtBQUksTUFBTSxTQUFTLENBQUM7QUFDM0Msa0JBQU0sT0FBTyxLQUFLLFNBQVMsUUFBUSxTQUFTLFNBQVMsU0FBUyxLQUFLLFdBQVcsUUFBUSxPQUFPLFNBQVMsU0FBUyxHQUFHO0FBQ2xILGdCQUFJLE1BQU0sUUFBUSxHQUFHLEdBQUc7QUFDcEIsb0JBQU0sVUFBVSxLQUFLLE1BQU0sS0FBSyxHQUFHLEtBQUs7QUFDeEMsa0JBQUksS0FBSyxLQUFLLFdBQVc7QUFDekIsY0FBQUEsS0FBSSxNQUFNLElBQUk7QUFDZDtBQUFBLFlBQ0o7QUFBQSxVQUNKO0FBQ0EsYUFBRyxNQUFNLEtBQUssS0FBSyxXQUFXO0FBQUEsUUFDbEM7QUFDQTtBQUFBLE1BQ0osS0FBSztBQUFBLE1BQ0wsS0FBSztBQUNELFlBQUksR0FBRyxTQUFTLEtBQUssVUFBVUEsS0FBSTtBQUMvQjtBQUNKLFdBQUcsTUFBTSxLQUFLLEtBQUssV0FBVztBQUM5QjtBQUFBLE1BQ0osS0FBSztBQUNELFlBQUksS0FBSyxXQUFXQSxLQUFJO0FBQ3BCO0FBQ0osWUFBSSxHQUFHLFNBQVMsY0FBYyxHQUFHLE9BQU8sY0FBYztBQUNsRCxVQUFBQSxLQUFJLE1BQU0sS0FBSyxFQUFFLE9BQU8sQ0FBQyxLQUFLLFdBQVcsRUFBRSxDQUFDO0FBQUE7QUFFNUMsYUFBRyxNQUFNLEtBQUssS0FBSyxXQUFXO0FBQ2xDO0FBQUEsSUFDUjtBQUNBLFFBQUksS0FBSyxTQUFTQSxLQUFJLFFBQVE7QUFDMUIsWUFBTSxLQUFLLEtBQUssZ0JBQWdCQSxJQUFHO0FBQ25DLFVBQUksSUFBSTtBQUNKLGFBQUssTUFBTSxLQUFLLEVBQUU7QUFDbEI7QUFBQSxNQUNKO0FBQUEsSUFDSjtBQUNBLFdBQU8sS0FBSyxJQUFJO0FBQ2hCLFdBQU8sS0FBSyxLQUFLO0FBQUEsRUFDckI7QUFBQSxFQUNBLENBQUMsZUFBZSxJQUFJO0FBQ2hCLFVBQU0sS0FBSyxHQUFHLE1BQU0sR0FBRyxNQUFNLFNBQVMsQ0FBQztBQUN2QyxRQUFJLEtBQUssU0FBUyxrQkFBa0I7QUFDaEMsVUFBSTtBQUNKLFNBQUc7QUFDQyxlQUFPLEtBQUssSUFBSTtBQUNoQixjQUFNLEtBQUssS0FBSyxDQUFDO0FBQUEsTUFDckIsU0FBUyxPQUFPLElBQUksU0FBUztBQUFBLElBQ2pDLFdBQ1MsR0FBRyxJQUFJLFdBQVcsR0FBRztBQUMxQixjQUFRLEtBQUssTUFBTTtBQUFBLFFBQ2YsS0FBSztBQUFBLFFBQ0wsS0FBSztBQUNELGNBQUksQ0FBQyxNQUFNLEdBQUc7QUFDVixlQUFHLE1BQU0sS0FBSyxFQUFFLE9BQU8sQ0FBQyxLQUFLLFdBQVcsRUFBRSxDQUFDO0FBQUE7QUFFM0MsZUFBRyxNQUFNLEtBQUssS0FBSyxXQUFXO0FBQ2xDO0FBQUEsUUFDSixLQUFLO0FBQ0QsY0FBSSxDQUFDLE1BQU0sR0FBRztBQUNWLGVBQUcsTUFBTSxLQUFLLEVBQUUsT0FBTyxDQUFDLEdBQUcsS0FBSyxNQUFNLEtBQUssQ0FBQyxLQUFLLFdBQVcsRUFBRSxDQUFDO0FBQUEsbUJBQzFELEdBQUc7QUFDUixlQUFHLElBQUksS0FBSyxLQUFLLFdBQVc7QUFBQTtBQUU1QixtQkFBTyxPQUFPLElBQUksRUFBRSxLQUFLLE1BQU0sS0FBSyxDQUFDLEtBQUssV0FBVyxFQUFFLENBQUM7QUFDNUQ7QUFBQSxRQUNKLEtBQUs7QUFBQSxRQUNMLEtBQUs7QUFBQSxRQUNMLEtBQUs7QUFBQSxRQUNMLEtBQUs7QUFBQSxRQUNMLEtBQUs7QUFDRCxjQUFJLENBQUMsTUFBTSxHQUFHO0FBQ1YsZUFBRyxNQUFNLEtBQUssRUFBRSxPQUFPLENBQUMsS0FBSyxXQUFXLEVBQUUsQ0FBQztBQUFBLG1CQUN0QyxHQUFHO0FBQ1IsZUFBRyxJQUFJLEtBQUssS0FBSyxXQUFXO0FBQUE7QUFFNUIsZUFBRyxNQUFNLEtBQUssS0FBSyxXQUFXO0FBQ2xDO0FBQUEsUUFDSixLQUFLO0FBQUEsUUFDTCxLQUFLO0FBQUEsUUFDTCxLQUFLO0FBQUEsUUFDTCxLQUFLLHdCQUF3QjtBQUN6QixnQkFBTSxLQUFLLEtBQUssV0FBVyxLQUFLLElBQUk7QUFDcEMsY0FBSSxDQUFDLE1BQU0sR0FBRztBQUNWLGVBQUcsTUFBTSxLQUFLLEVBQUUsT0FBTyxDQUFDLEdBQUcsS0FBSyxJQUFJLEtBQUssQ0FBQyxFQUFFLENBQUM7QUFBQSxtQkFDeEMsR0FBRztBQUNSLGlCQUFLLE1BQU0sS0FBSyxFQUFFO0FBQUE7QUFFbEIsbUJBQU8sT0FBTyxJQUFJLEVBQUUsS0FBSyxJQUFJLEtBQUssQ0FBQyxFQUFFLENBQUM7QUFDMUM7QUFBQSxRQUNKO0FBQUEsUUFDQSxLQUFLO0FBQUEsUUFDTCxLQUFLO0FBQ0QsYUFBRyxJQUFJLEtBQUssS0FBSyxXQUFXO0FBQzVCO0FBQUEsTUFDUjtBQUNBLFlBQU0sS0FBSyxLQUFLLGdCQUFnQixFQUFFO0FBRWxDLFVBQUk7QUFDQSxhQUFLLE1BQU0sS0FBSyxFQUFFO0FBQUEsV0FDakI7QUFDRCxlQUFPLEtBQUssSUFBSTtBQUNoQixlQUFPLEtBQUssS0FBSztBQUFBLE1BQ3JCO0FBQUEsSUFDSixPQUNLO0FBQ0QsWUFBTSxTQUFTLEtBQUssS0FBSyxDQUFDO0FBQzFCLFVBQUksT0FBTyxTQUFTLGdCQUNmLEtBQUssU0FBUyxtQkFDVixLQUFLLFNBQVMsYUFDWCxDQUFDLE9BQU8sTUFBTSxPQUFPLE1BQU0sU0FBUyxDQUFDLEVBQUUsTUFBTztBQUN0RCxlQUFPLEtBQUssSUFBSTtBQUNoQixlQUFPLEtBQUssS0FBSztBQUFBLE1BQ3JCLFdBQ1MsS0FBSyxTQUFTLG1CQUNuQixPQUFPLFNBQVMsbUJBQW1CO0FBQ25DLGNBQU0sT0FBTyxhQUFhLE1BQU07QUFDaEMsY0FBTSxRQUFRLHNCQUFzQixJQUFJO0FBQ3hDLHdCQUFnQixFQUFFO0FBQ2xCLGNBQU0sTUFBTSxHQUFHLElBQUksT0FBTyxHQUFHLEdBQUcsSUFBSSxNQUFNO0FBQzFDLFlBQUksS0FBSyxLQUFLLFdBQVc7QUFDekIsY0FBTUQsT0FBTTtBQUFBLFVBQ1IsTUFBTTtBQUFBLFVBQ04sUUFBUSxHQUFHO0FBQUEsVUFDWCxRQUFRLEdBQUc7QUFBQSxVQUNYLE9BQU8sQ0FBQyxFQUFFLE9BQU8sS0FBSyxJQUFJLElBQUksQ0FBQztBQUFBLFFBQ25DO0FBQ0EsYUFBSyxZQUFZO0FBQ2pCLGFBQUssTUFBTSxLQUFLLE1BQU0sU0FBUyxDQUFDLElBQUlBO0FBQUEsTUFDeEMsT0FDSztBQUNELGVBQU8sS0FBSyxRQUFRLEVBQUU7QUFBQSxNQUMxQjtBQUFBLElBQ0o7QUFBQSxFQUNKO0FBQUEsRUFDQSxXQUFXLE1BQU07QUFDYixRQUFJLEtBQUssV0FBVztBQUNoQixVQUFJLEtBQUssS0FBSyxPQUFPLFFBQVEsSUFBSSxJQUFJO0FBQ3JDLGFBQU8sT0FBTyxHQUFHO0FBQ2IsYUFBSyxVQUFVLEtBQUssU0FBUyxFQUFFO0FBQy9CLGFBQUssS0FBSyxPQUFPLFFBQVEsTUFBTSxFQUFFLElBQUk7QUFBQSxNQUN6QztBQUFBLElBQ0o7QUFDQSxXQUFPO0FBQUEsTUFDSDtBQUFBLE1BQ0EsUUFBUSxLQUFLO0FBQUEsTUFDYixRQUFRLEtBQUs7QUFBQSxNQUNiLFFBQVEsS0FBSztBQUFBLElBQ2pCO0FBQUEsRUFDSjtBQUFBLEVBQ0EsZ0JBQWdCLFFBQVE7QUFDcEIsWUFBUSxLQUFLLE1BQU07QUFBQSxNQUNmLEtBQUs7QUFBQSxNQUNMLEtBQUs7QUFBQSxNQUNMLEtBQUs7QUFBQSxNQUNMLEtBQUs7QUFDRCxlQUFPLEtBQUssV0FBVyxLQUFLLElBQUk7QUFBQSxNQUNwQyxLQUFLO0FBQ0QsZUFBTztBQUFBLFVBQ0gsTUFBTTtBQUFBLFVBQ04sUUFBUSxLQUFLO0FBQUEsVUFDYixRQUFRLEtBQUs7QUFBQSxVQUNiLE9BQU8sQ0FBQyxLQUFLLFdBQVc7QUFBQSxVQUN4QixRQUFRO0FBQUEsUUFDWjtBQUFBLE1BQ0osS0FBSztBQUFBLE1BQ0wsS0FBSztBQUNELGVBQU87QUFBQSxVQUNILE1BQU07QUFBQSxVQUNOLFFBQVEsS0FBSztBQUFBLFVBQ2IsUUFBUSxLQUFLO0FBQUEsVUFDYixPQUFPLEtBQUs7QUFBQSxVQUNaLE9BQU8sQ0FBQztBQUFBLFVBQ1IsS0FBSyxDQUFDO0FBQUEsUUFDVjtBQUFBLE1BQ0osS0FBSztBQUNELGVBQU87QUFBQSxVQUNILE1BQU07QUFBQSxVQUNOLFFBQVEsS0FBSztBQUFBLFVBQ2IsUUFBUSxLQUFLO0FBQUEsVUFDYixPQUFPLENBQUMsRUFBRSxPQUFPLENBQUMsS0FBSyxXQUFXLEVBQUUsQ0FBQztBQUFBLFFBQ3pDO0FBQUEsTUFDSixLQUFLLG9CQUFvQjtBQUNyQixhQUFLLFlBQVk7QUFDakIsY0FBTSxPQUFPLGFBQWEsTUFBTTtBQUNoQyxjQUFNLFFBQVEsc0JBQXNCLElBQUk7QUFDeEMsY0FBTSxLQUFLLEtBQUssV0FBVztBQUMzQixlQUFPO0FBQUEsVUFDSCxNQUFNO0FBQUEsVUFDTixRQUFRLEtBQUs7QUFBQSxVQUNiLFFBQVEsS0FBSztBQUFBLFVBQ2IsT0FBTyxDQUFDLEVBQUUsTUFBTSxDQUFDO0FBQUEsUUFDckI7QUFBQSxNQUNKO0FBQUEsTUFDQSxLQUFLLGlCQUFpQjtBQUNsQixhQUFLLFlBQVk7QUFDakIsY0FBTSxPQUFPLGFBQWEsTUFBTTtBQUNoQyxjQUFNLFFBQVEsc0JBQXNCLElBQUk7QUFDeEMsZUFBTztBQUFBLFVBQ0gsTUFBTTtBQUFBLFVBQ04sUUFBUSxLQUFLO0FBQUEsVUFDYixRQUFRLEtBQUs7QUFBQSxVQUNiLE9BQU8sQ0FBQyxFQUFFLE9BQU8sS0FBSyxNQUFNLEtBQUssQ0FBQyxLQUFLLFdBQVcsRUFBRSxDQUFDO0FBQUEsUUFDekQ7QUFBQSxNQUNKO0FBQUEsSUFDSjtBQUNBLFdBQU87QUFBQSxFQUNYO0FBQUEsRUFDQSxrQkFBa0IsT0FBTyxRQUFRO0FBQzdCLFFBQUksS0FBSyxTQUFTO0FBQ2QsYUFBTztBQUNYLFFBQUksS0FBSyxVQUFVO0FBQ2YsYUFBTztBQUNYLFdBQU8sTUFBTSxNQUFNLFFBQU0sR0FBRyxTQUFTLGFBQWEsR0FBRyxTQUFTLE9BQU87QUFBQSxFQUN6RTtBQUFBLEVBQ0EsQ0FBQyxZQUFZLFFBQVE7QUFDakIsUUFBSSxLQUFLLFNBQVMsWUFBWTtBQUMxQixVQUFJLE9BQU87QUFDUCxlQUFPLElBQUksS0FBSyxLQUFLLFdBQVc7QUFBQTtBQUVoQyxlQUFPLE1BQU0sQ0FBQyxLQUFLLFdBQVc7QUFDbEMsVUFBSSxLQUFLLFNBQVM7QUFDZCxlQUFPLEtBQUssSUFBSTtBQUFBLElBQ3hCO0FBQUEsRUFDSjtBQUFBLEVBQ0EsQ0FBQyxRQUFRLE9BQU87QUFDWixZQUFRLEtBQUssTUFBTTtBQUFBLE1BQ2YsS0FBSztBQUFBLE1BQ0wsS0FBSztBQUFBLE1BQ0wsS0FBSztBQUFBLE1BQ0wsS0FBSztBQUFBLE1BQ0wsS0FBSztBQUFBLE1BQ0wsS0FBSztBQUNELGVBQU8sS0FBSyxJQUFJO0FBQ2hCLGVBQU8sS0FBSyxLQUFLO0FBQ2pCO0FBQUEsTUFDSixLQUFLO0FBQ0QsYUFBSyxZQUFZO0FBQUEsTUFFckIsS0FBSztBQUFBLE1BQ0wsS0FBSztBQUFBLE1BQ0w7QUFFSSxZQUFJLE1BQU07QUFDTixnQkFBTSxJQUFJLEtBQUssS0FBSyxXQUFXO0FBQUE7QUFFL0IsZ0JBQU0sTUFBTSxDQUFDLEtBQUssV0FBVztBQUNqQyxZQUFJLEtBQUssU0FBUztBQUNkLGlCQUFPLEtBQUssSUFBSTtBQUFBLElBQzVCO0FBQUEsRUFDSjtBQUNKOzs7QUN4MkJBLFNBQVMsYUFBYSxTQUFTO0FBQzNCLFFBQU0sZUFBZSxRQUFRLGlCQUFpQjtBQUM5QyxRQUFNLGNBQWMsUUFBUSxlQUFnQixnQkFBZ0IsSUFBSSxZQUFZLEtBQU07QUFDbEYsU0FBTyxFQUFFLGFBQWEsYUFBYTtBQUN2QztBQXlCQSxTQUFTLGNBQWMsUUFBUSxVQUFVLENBQUMsR0FBRztBQUN6QyxRQUFNLEVBQUUsYUFBYSxhQUFhLElBQUksYUFBYSxPQUFPO0FBQzFELFFBQU0sU0FBUyxJQUFJLE9BQU8sZ0JBQWdCLFFBQVEsZ0JBQWdCLFNBQVMsU0FBUyxZQUFZLFVBQVU7QUFDMUcsUUFBTSxXQUFXLElBQUksU0FBUyxPQUFPO0FBRXJDLE1BQUksTUFBTTtBQUNWLGFBQVcsUUFBUSxTQUFTLFFBQVEsT0FBTyxNQUFNLE1BQU0sR0FBRyxNQUFNLE9BQU8sTUFBTSxHQUFHO0FBQzVFLFFBQUksQ0FBQztBQUNELFlBQU07QUFBQSxhQUNELElBQUksUUFBUSxhQUFhLFVBQVU7QUFDeEMsVUFBSSxPQUFPLEtBQUssSUFBSSxlQUFlLEtBQUssTUFBTSxNQUFNLEdBQUcsQ0FBQyxHQUFHLGlCQUFpQix5RUFBeUUsQ0FBQztBQUN0SjtBQUFBLElBQ0o7QUFBQSxFQUNKO0FBQ0EsTUFBSSxnQkFBZ0IsYUFBYTtBQUM3QixRQUFJLE9BQU8sUUFBUSxjQUFjLFFBQVEsV0FBVyxDQUFDO0FBQ3JELFFBQUksU0FBUyxRQUFRLGNBQWMsUUFBUSxXQUFXLENBQUM7QUFBQSxFQUMzRDtBQUNBLFNBQU87QUFDWDs7O0F0RW5ETyxJQUFNLE9BQU4sTUFBVztBQUFBLEVBT2QsWUFBWUUsTUFBVSxVQUFrQixjQUFtQkMsaUJBQXdCO0FBQy9FLFNBQUssTUFBTUQ7QUFDWCxTQUFLLFdBQVc7QUFDaEIsU0FBSyxXQUFXLFNBQVMsTUFBTSxHQUFHLEVBQUUsSUFBSTtBQUN4QyxTQUFLLGVBQWU7QUFDcEIsU0FBSyxpQkFBaUIsQ0FBQyxDQUFDQztBQUFBLEVBQzVCO0FBQUE7QUFBQSxFQUdBLE1BQU0sUUFBUSxTQUF1QjtBQUNqQyxVQUFNLE9BQU8sS0FBSyxJQUFJLE1BQU0sc0JBQXNCLEtBQUssUUFBUTtBQUMvRCxVQUFNLFdBQVcsTUFBTSxLQUFLLElBQUksTUFBTSxLQUFLLElBQUk7QUFDL0MsUUFBSSxPQUFPO0FBRVgsUUFBSSxLQUFLLGdCQUFnQjtBQUNyQixhQUFPLEtBQUsscUJBQXFCLE1BQU0sT0FBTztBQUFBLElBQ2xEO0FBRUEsUUFBSSxTQUFTLFVBQVU7QUFDbkIsWUFBTSxLQUFLLElBQUksTUFBTSxPQUFPLE1BQU0sSUFBSTtBQUN0QyxhQUFPO0FBQUEsSUFDWDtBQUFBLEVBQ0o7QUFBQTtBQUFBLEVBR0EscUJBQXFCLE1BQXNHLFNBQXlFO0FBQ2hNLFVBQU0sQ0FBQyxPQUFPLFdBQVcsSUFBSSxLQUFLLE1BQU0sZ0JBQWdCLENBQUM7QUFHekQsUUFBSSxNQUFNLEtBQUssTUFBTSxNQUFNLENBQUMsWUFBWSxLQUFLLEtBQUssQ0FBQyxZQUFZLFNBQVMsSUFBSTtBQUN4RSxhQUFPO0FBRVgsVUFBTSxTQUFTLGNBQWMsYUFBYSxFQUFDLGtCQUFrQixLQUFJLENBQUM7QUFDbEUsUUFBSSxPQUFPLE9BQU8sUUFBUTtBQUN0QixZQUFNLFFBQVEsbUJBQW1CLEtBQUssYUFBYSxPQUFPLE9BQU8sQ0FBQztBQUNsRSxjQUFRLE1BQU0sS0FBSztBQUFHLFVBQUksdUJBQU8sUUFBUSx3QkFBd0I7QUFDakU7QUFBQSxJQUNKO0FBRUEsUUFBSSxVQUFVLE9BQU8sT0FBTyxPQUFPLE9BQU87QUFFMUMsYUFBUyxVQUFVLE1BQXNDLE9BQVksV0FBUyxPQUFPO0FBQ2pGLGtCQUFJLGVBQWUsS0FBSyxVQUFVLE9BQU8sRUFBQyxTQUFRLENBQUM7QUFDbkQsZ0JBQVU7QUFDVixXQUFLLFFBQVE7QUFBQSxJQUNqQjtBQUVBLGFBQVMsYUFBYSxNQUF1QkMsVUFBa0I7QUFDM0QsWUFBTSxPQUFPLE9BQU8sSUFBSSxNQUFNLElBQUk7QUFDbEMsVUFBSSxDQUFDO0FBQU07QUFDWCxZQUFNLFFBQVEsS0FBSyxJQUFJO0FBQ3ZCLFVBQUksQ0FBQyxTQUFTLENBQUMsTUFBTTtBQUFRO0FBQzdCLFVBQUksT0FBTyxVQUFVLFVBQVU7QUFDM0IsY0FBTSxRQUFRLE1BQU0sTUFBTUEsV0FBVSx3QkFBd0IsVUFBVTtBQUN0RSxjQUFNLFFBQVEsUUFBUSxRQUFRLE9BQU8sTUFBTUEsUUFBTyxFQUFFLEtBQUssRUFBRTtBQUMzRCxZQUFJLFNBQVM7QUFBTyxvQkFBVSxNQUFNLE9BQU8sSUFBSTtBQUFBLE1BQ25ELFdBQVcsTUFBTSxRQUFRLEtBQUssR0FBRztBQUM3QixnQkFBUSxRQUFRLE9BQU8sT0FBT0EsUUFBTyxFQUFFLFFBQVEsQ0FBQyxHQUFRLE1BQWM7QUFDbEUsY0FBSSxNQUFNLENBQUMsTUFBTTtBQUFHLHNCQUFVLEtBQUssSUFBSSxHQUFHLElBQUksR0FBRyxDQUFDO0FBQUEsUUFDdEQsQ0FBQztBQUFBLE1BQ0w7QUFBQSxJQUNKO0FBRUEsZUFBVyxFQUFDLEtBQUssRUFBQyxPQUFNLEtBQUksRUFBQyxLQUFLLE9BQU8sU0FBUyxPQUFPO0FBQ3JELFVBQUksV0FBVyxLQUFLLElBQUksR0FBRztBQUN2QixxQkFBYSxNQUFNLEtBQUs7QUFBQSxNQUM1QixXQUFXLGdCQUFnQixLQUFLLElBQUksR0FBRztBQUNuQyxxQkFBYSxNQUFNLElBQUk7QUFBQSxNQUMzQjtBQUFBLElBQ0o7QUFDQSxXQUFPLFVBQVUsS0FBSyxRQUFRLGFBQWEsWUFBSSxVQUFVLE9BQU8sU0FBUyxRQUFRLENBQUMsSUFBSTtBQUFBLEVBQzFGO0FBQ0o7OztBRi9FTyxTQUFTLGVBQWUsTUFBdUI7QUFDbEQsTUFBSSxFQUFFLFlBQVksSUFBSSxJQUFJLGNBQWMsYUFBYSxJQUFJLEtBQUssQ0FBQztBQUMvRCxTQUFPLGVBQWU7QUFDMUI7QUFFTyxTQUFTLFFBQVEsTUFBdUI7QUFDM0MsTUFBSSxFQUFFLFlBQVksSUFBSSxJQUFJLGNBQWMsYUFBYSxJQUFJLEtBQUssQ0FBQztBQUMvRCxRQUFNLGFBQVUsdUNBQXFCLFdBQVcsS0FBSyxDQUFDO0FBQ3RELFFBQU0saUJBQWEsMENBQXdCLFdBQVcsS0FBSyxDQUFDLEdBQUcsT0FBTyxJQUFJLEtBQUs7QUFDL0UsU0FBUSxPQUFPLFVBQVUsVUFBVSxTQUFVLE9BQU87QUFDeEQ7QUFFQSxlQUFzQixVQUFVLE1BQWEsU0FBaUIsU0FBbUM7QUFDN0YsUUFDSSxTQUFVLElBQUksSUFBSSxPQUFPLEdBQ3pCLFNBQVUsSUFBSSxJQUFJLE9BQU8sR0FDekIsVUFBVSxJQUFJLFlBQVksUUFBUSxNQUFNO0FBRTVDLFFBQU0sU0FBUyxNQUFNLFlBQVksUUFBUSxJQUFJO0FBQzdDLE1BQUksQ0FBQyxRQUFRO0FBQ1QsV0FBTztBQUFBLEVBQ1g7QUFDQSxRQUFNLE9BQU8sUUFBUSxPQUFPO0FBQzVCLFNBQU87QUFDWDtBQUVBLGVBQXNCLFlBQVlDLE1BQVUsTUFBYTtBQUNyRCxNQUFJLEVBQUUsYUFBYSxLQUFLLElBQUksSUFBSSxjQUFjLGFBQWEsSUFBSSxLQUFLLENBQUM7QUFDckUsUUFBTSxjQUFVLHVDQUFxQixXQUFXLEtBQUssQ0FBQyxHQUFHLE9BQU9BLEtBQUksT0FBTztBQUMzRSxRQUFNLGlCQUFhLDBDQUF3QixXQUFXLEtBQUssQ0FBQyxHQUFHLE9BQU8sSUFBSSxLQUFLLEVBQUUsT0FBT0EsS0FBSSxPQUFPO0FBQ25HLE1BQUksT0FBTyxVQUFVLFVBQVUsUUFBUTtBQUNuQyxXQUFPLElBQUksS0FBSyxLQUFLLEtBQUssTUFBTSxNQUFNLE9BQU8sU0FBUyxVQUFVLE1BQU07QUFBQSxFQUMxRTtBQUNBLFNBQU87QUFDWDtBQUVPLFNBQVMsZ0JBQWdCQyxNQUFXLE1BQWMsTUFBb0M7QUFDekYsTUFBSUMsVUFBUztBQUNiLFFBQU0sZUFBZUEsUUFBTyxFQUFFLE9BQU8sVUFBVTtBQUMvQyxNQUFJLGNBQWM7QUFDbEIsTUFBSSxLQUFLLE1BQU0sMkJBQTJCLEdBQUc7QUFDekMsV0FBTyxRQUFRLFFBQVE7QUFBQSxFQUMzQixXQUFXLEtBQUssTUFBTSwyQkFBMkIsR0FBRztBQUNoRCxRQUFJLHdCQUFPLGtEQUFrRDtBQUM3RCxrQkFBYyxLQUFLLFFBQVEsZUFBZSxTQUFTO0FBQ25ELFdBQU8sV0FBV0QsTUFBSyxLQUFLLE1BQU0sV0FBVztBQUFBLEVBQ2pELFdBQVcsS0FBSyxNQUFNLFdBQVcsR0FBRztBQUNoQyxRQUFJLHdCQUFPLDJDQUEyQztBQUN0RCxrQkFBYyxLQUFLLFFBQVEsZUFBZSxLQUFLLGVBQWU7QUFDOUQsV0FBTyxXQUFXQSxNQUFLLEtBQUssTUFBTSxXQUFXO0FBQUEsRUFDakQsV0FBVyxLQUFLLE1BQU0sV0FBVyxHQUFHO0FBQ2hDLFFBQUksd0JBQU8sMkNBQTJDO0FBQ3RELGtCQUFjLEtBQUssUUFBUSxlQUFlLFVBQVUsZUFBZTtBQUNuRSxXQUFPLFdBQVdBLE1BQUssS0FBSyxNQUFNLFdBQVc7QUFBQSxFQUNqRCxPQUFPO0FBQ0gsUUFBSSx3QkFBTyx5Q0FBeUM7QUFDcEQsa0JBQWMsS0FBSyxRQUFRLFVBQVUsVUFBVSxlQUFlO0FBQzlELFdBQU8sV0FBV0EsTUFBSyxLQUFLLE1BQU0sV0FBVztBQUFBLEVBQ2pEO0FBQ0o7QUFFQSxlQUFlLFdBQVdBLE1BQVcsTUFBc0IsU0FBaUI7QUFDeEUsRUFBQUEsS0FBSSxZQUFZLFdBQVcsTUFBTSxPQUFPO0FBQzVDOzs7QUQxREEsSUFBTSxZQUFZO0FBQUEsRUFDaEI7QUFBQSxJQUNFLE1BQU07QUFBQSxJQUNOLGFBQWE7QUFBQSxFQUNmO0FBQUEsRUFDQTtBQUFBLElBQ0UsTUFBTTtBQUFBLElBQ04sYUFBYTtBQUFBLEVBQ2Y7QUFBQSxFQUNBO0FBQUEsSUFDRSxNQUFNO0FBQUEsSUFDTixhQUFhO0FBQUEsRUFDZjtBQUFBLEVBQ0E7QUFBQSxJQUNFLE1BQU07QUFBQSxJQUNOLGFBQWE7QUFBQSxFQUNmO0FBQUEsRUFDQTtBQUFBLElBQ0UsTUFBTTtBQUFBLElBQ04sYUFBYTtBQUFBLEVBQ2Y7QUFBQSxFQUNBO0FBQUEsSUFDRSxNQUFNO0FBQUEsSUFDTixhQUFhO0FBQUEsRUFDZjtBQUFBLEVBQ0E7QUFBQSxJQUNFLE1BQU07QUFBQSxJQUNOLGFBQWE7QUFBQSxFQUNmO0FBQUEsRUFDQTtBQUFBLElBQ0UsTUFBTTtBQUFBLElBQ04sYUFBYTtBQUFBLEVBQ2Y7QUFBQSxFQUNBO0FBQUEsSUFDRSxNQUFNO0FBQUEsSUFDTixhQUFhO0FBQUEsRUFDZjtBQUFBLEVBQ0E7QUFBQSxJQUNFLE1BQU07QUFBQSxJQUNOLGFBQWE7QUFBQSxFQUNmO0FBQUEsRUFDQTtBQUFBLElBQ0UsTUFBTTtBQUFBLElBQ04sYUFBYTtBQUFBLEVBQ2Y7QUFBQSxFQUNBO0FBQUEsSUFDRSxNQUFNO0FBQUEsSUFDTixhQUFhO0FBQUEsRUFDZjtBQUFBLEVBQ0E7QUFBQSxJQUNFLE1BQU07QUFBQSxJQUNOLGFBQWE7QUFBQSxFQUNmO0FBQUEsRUFDQTtBQUFBLElBQ0UsTUFBTTtBQUFBLElBQ04sYUFBYTtBQUFBLEVBQ2Y7QUFBQSxFQUNBO0FBQUEsSUFDRSxNQUFNO0FBQUEsSUFDTixhQUFhO0FBQUEsRUFDZjtBQUFBLEVBQ0E7QUFBQSxJQUNFLE1BQU07QUFBQSxJQUNOLGFBQWE7QUFBQSxFQUNmO0FBQUEsRUFDQTtBQUFBLElBQ0UsTUFBTTtBQUFBLElBQ04sYUFBYTtBQUFBLEVBQ2Y7QUFBQSxFQUNBO0FBQUEsSUFDRSxNQUFNO0FBQUEsSUFDTixhQUFhO0FBQUEsRUFDZjtBQUFBLEVBQ0E7QUFBQSxJQUNFLE1BQU07QUFBQSxJQUNOLGFBQWE7QUFBQSxFQUNmO0FBQUEsRUFDQTtBQUFBLElBQ0UsTUFBTTtBQUFBLElBQ04sYUFBYTtBQUFBLEVBQ2Y7QUFBQSxFQUNBO0FBQUEsSUFDRSxNQUFNO0FBQUEsSUFDTixhQUFhO0FBQUEsRUFDZjtBQUFBLEVBQ0E7QUFBQSxJQUNFLE1BQU07QUFBQSxJQUNOLGFBQWE7QUFBQSxFQUNmO0FBQUEsRUFDQTtBQUFBLElBQ0UsTUFBTTtBQUFBLElBQ04sYUFBYTtBQUFBLEVBQ2Y7QUFBQSxFQUNBO0FBQUEsSUFDRSxNQUFNO0FBQUEsSUFDTixhQUFhO0FBQUEsRUFDZjtBQUFBLEVBQ0E7QUFBQSxJQUNFLE1BQU07QUFBQSxJQUNOLGFBQWE7QUFBQSxFQUNmO0FBQUEsRUFDQTtBQUFBLElBQ0UsTUFBTTtBQUFBLElBQ04sYUFBYTtBQUFBLEVBQ2Y7QUFBQSxFQUNBO0FBQUEsSUFDRSxNQUFNO0FBQUEsSUFDTixhQUFhO0FBQUEsRUFDZjtBQUFBLEVBQ0E7QUFBQSxJQUNFLE1BQU07QUFBQSxJQUNOLGFBQWE7QUFBQSxFQUNmO0FBQUEsRUFDQTtBQUFBLElBQ0UsTUFBTTtBQUFBLElBQ04sYUFBYTtBQUFBLEVBQ2Y7QUFBQSxFQUNBO0FBQUEsSUFDRSxNQUFNO0FBQUEsSUFDTixhQUFhO0FBQUEsRUFDZjtBQUFBLEVBQ0E7QUFBQSxJQUNFLE1BQU07QUFBQSxJQUNOLGFBQWE7QUFBQSxFQUNmO0FBQUEsRUFDQTtBQUFBLElBQ0UsTUFBTTtBQUFBLElBQ04sYUFBYTtBQUFBLEVBQ2Y7QUFBQSxFQUNBO0FBQUEsSUFDRSxNQUFNO0FBQUEsSUFDTixhQUFhO0FBQUEsRUFDZjtBQUFBLEVBQ0E7QUFBQSxJQUNFLE1BQU07QUFBQSxJQUNOLGFBQWE7QUFBQSxFQUNmO0FBQUEsRUFDQTtBQUFBLElBQ0UsTUFBTTtBQUFBLElBQ04sYUFBYTtBQUFBLEVBQ2Y7QUFBQSxFQUNBO0FBQUEsSUFDRSxNQUFNO0FBQUEsSUFDTixhQUFhO0FBQUEsRUFDZjtBQUFBLEVBQ0E7QUFBQSxJQUNFLE1BQU07QUFBQSxJQUNOLGFBQWE7QUFBQSxFQUNmO0FBQUEsRUFDQTtBQUFBLElBQ0UsTUFBTTtBQUFBLElBQ04sYUFBYTtBQUFBLEVBQ2Y7QUFBQSxFQUNBO0FBQUEsSUFDRSxNQUFNO0FBQUEsSUFDTixhQUFhO0FBQUEsRUFDZjtBQUFBLEVBQ0E7QUFBQSxJQUNFLE1BQU07QUFBQSxJQUNOLGFBQWE7QUFBQSxFQUNmO0FBQUEsRUFDQTtBQUFBLElBQ0UsTUFBTTtBQUFBLElBQ04sYUFBYTtBQUFBLEVBQ2Y7QUFDRjtB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QUFpQixRQUFRLFNBQVMsQ0FBQztBQUNqRCxRQUFJLFFBQVEsSUFBSTtBQUNmLHVCQUFpQixPQUFPLE9BQU8sQ0FBQztBQUFBLElBQ2pDO0FBQ0EsUUFBSSxRQUFRLFNBQVMsR0FBRztBQUN2Qix1QkFBaUIsS0FBSyxPQUFPO0FBQUEsSUFDOUI7QUFBQSxFQUNEO0FBQUEsRUFFQSxXQUFXO0FBQUEsRUFFWDtBQUFBLEVBRUEsTUFBTSxlQUFlO0FBQ3BCLFNBQUssV0FBVyxPQUFPLE9BQU8sQ0FBQyxHQUFHLGtCQUFrQixNQUFNLEtBQUssU0FBUyxDQUFDO0FBQUEsRUFDMUU7QUFBQSxFQUVBLE1BQU0sZUFBZTtBQUNwQixVQUFNLEtBQUssU0FBUyxLQUFLLFFBQVE7QUFBQSxFQUNsQztBQUNEO0FBRUEsSUFBTSxtQkFBTixjQUErQixtQ0FBaUI7QUFBQSxFQUcvQyxZQUFZRixNQUFVLFFBQWtCO0FBQ3ZDLFVBQU1BLE1BQUssTUFBTTtBQUNqQixTQUFLLFNBQVM7QUFBQSxFQUNmO0FBQUEsRUFFQSxVQUFnQjtBQUNmLFVBQU0sRUFBQyxZQUFXLElBQUk7QUFFdEIsZ0JBQVksTUFBTTtBQUVsQixnQkFBWSxTQUFTLE1BQU0sRUFBQyxNQUFNLGtDQUFpQyxDQUFDO0FBRXBFLFFBQUksMEJBQVEsV0FBVyxFQUNyQixRQUFRLFlBQVksRUFDcEIsUUFBUSxlQUFnQixFQUN4QixRQUFRLFVBQVEsS0FDZixlQUFlLG1CQUFtQixFQUNsQyxTQUFTLEtBQUssT0FBTyxTQUFTLFNBQVMsRUFDdkMsU0FBUyxPQUFPLFVBQVU7QUFDMUIsY0FBUSxJQUFJLGFBQWEsS0FBSztBQUM5QixXQUFLLE9BQU8sU0FBUyxZQUFZO0FBQ2pDLFlBQU0sS0FBSyxPQUFPLGFBQWE7QUFBQSxJQUNoQyxDQUFDLENBQUM7QUFBQSxFQUNMO0FBQ0Q7IiwKICAibmFtZXMiOiBbIm1vZHVsZSIsICJtYXAiLCAiZm9ybWF0IiwgImxvY2FsZSIsICJ0byIsICJmcm9tIiwgIndhcm4iLCAic2V0IiwgIm5vdyIsICJzaWduIiwgInRva2VuIiwgIm9yZGluYWwiLCAiaSIsICJzdHJpbmciLCAiZGlmZiIsICJsb2NhbGVEYXRhIiwgImhvdXJzIiwgIm1pbnV0ZXMiLCAidG9rZW5zIiwgIm1lcmlkaWVtIiwgInllYXJzIiwgIm1vbnRocyIsICJ3ZWVrcyIsICJkYXlzIiwgInNlY29uZHMiLCAibWlsbGlzZWNvbmRzIiwgIm9mZnNldCIsICJ0aHJlc2hvbGRzIiwgImltcG9ydF9vYnNpZGlhbiIsICJpbXBvcnRfb2JzaWRpYW4iLCAiaXNBbGlhcyIsICJ0YWciLCAicmVzIiwgIm1hcCIsICJzY2hlbWEiLCAibm9kZSIsICJzY2hlbWEiLCAiaSIsICJlbmQiLCAidGFnIiwgInRhZyIsICJtYXAiLCAidmFsdWUiLCAic2NoZW1hIiwgInN0cmluZ2lmeSIsICJjb21tZW50IiwgInN0ciIsICJzY2hlbWEiLCAibWFwIiwgInNjaGVtYSIsICJtYXAiLCAic2NoZW1hIiwgInNlcSIsICJzY2hlbWEiLCAic2VxIiwgInRhZyIsICJpbnRJZGVudGlmeSIsICJzY2hlbWEiLCAic2VxIiwgInNjaGVtYSIsICJwYWlycyIsICJtYXAiLCAic2VxIiwgInBhaXJzIiwgInNjaGVtYSIsICJvbWFwIiwgImZsb2F0TmFOIiwgImZsb2F0RXhwIiwgImZsb2F0IiwgImludElkZW50aWZ5IiwgImludFJlc29sdmUiLCAibiIsICJpbnRTdHJpbmdpZnkiLCAiaW50T2N0IiwgImludCIsICJpbnRIZXgiLCAic2NoZW1hIiwgIm1hcCIsICJzZXQiLCAicmVzIiwgInNjaGVtYSIsICJpbnRPY3QiLCAiaW50IiwgImludEhleCIsICJmbG9hdE5hTiIsICJmbG9hdEV4cCIsICJmbG9hdCIsICJzY2hlbWEiLCAidGFnIiwgInNjaGVtYSIsICJ0YWciLCAicmVzIiwgInRhZyIsICJjb21wb3NlTm9kZSIsICJjb21wb3NlRW1wdHlOb2RlIiwgIm1hcCIsICJjb21wb3NlTm9kZSIsICJjb21wb3NlRW1wdHlOb2RlIiwgInNlcSIsICJjb21wb3NlTm9kZSIsICJjb21wb3NlRW1wdHlOb2RlIiwgImlzTWFwIiwgIm1hcCIsICJDTiIsICJ0YWciLCAidmFsdWUiLCAiZW5kIiwgInRhZyIsICJzY2hlbWEiLCAidGFnIiwgIlNDQUxBUiIsICJpc0NvbGxlY3Rpb24iLCAiaXNTY2FsYXIiLCAic3RyaW5naWZ5IiwgInZpc2l0IiwgInN0cmluZ2lmeSIsICJCUkVBSyIsICJTS0lQIiwgIlJFTU9WRSIsICJ2aXNpdCIsICJfdmlzaXQiLCAiU0NBTEFSIiwgImlzQ29sbGVjdGlvbiIsICJpc1NjYWxhciIsICJjaCIsICJTQ0FMQVIiLCAibWFwIiwgInNlcSIsICJhcHAiLCAiaGFzRnJvbnRNYXR0ZXIiLCAiaXNBbGlhcyIsICJ0YWciLCAiYXBwIiwgIm1vbWVudCIsICJhcHAiLCAiaW1wb3J0X29ic2lkaWFuIiwgImltcG9ydF9vYnNpZGlhbiIsICJBTExfVFlQRVMiLCAiYXBwIiwgImltcG9ydF9vYnNpZGlhbiIsICJBTExfVFlQRVMiLCAiYXBwIiwgImltcG9ydF9vYnNpZGlhbiIsICJBTExfVFlQRVMiLCAiYXBwIiwgImltcG9ydF9vYnNpZGlhbiIsICJBTExfVFlQRVMiLCAiYXBwIiwgIm5vdGUiLCAiaW1wb3J0X29ic2lkaWFuIiwgImFwcCIsICJpbXBvcnRfb2JzaWRpYW4iLCAiYXBwIiwgImltcG9ydF9vYnNpZGlhbiIsICJhcHAiLCAidmF1bHQiLCAiaW1wb3J0X29ic2lkaWFuIiwgImFwcCIsICJpbXBvcnRfb2JzaWRpYW4iLCAiaW1wb3J0X29ic2lkaWFuIiwgImFwcCIsICJ0YWciLCAiYXBwIiwgImltcG9ydF9vYnNpZGlhbiIsICJpbXBvcnRfb2JzaWRpYW4iLCAiaW1wb3J0X29ic2lkaWFuIiwgImFwcCIsICJpbXBvcnRfb2JzaWRpYW4iLCAidGFnIiwgImFwcCIsICJpbXBvcnRfb2JzaWRpYW4iLCAiYXBwIiwgImFwcCIsICJpbXBvcnRfb2JzaWRpYW4iLCAiQkFDS19UT19TRUxFQ1RfVEFHIiwgImFwcCIsICJpbXBvcnRfb2JzaWRpYW4iLCAiYXBwIiwgImltcG9ydF9vYnNpZGlhbiIsICJhcHAiLCAiaW1wb3J0X29ic2lkaWFuIiwgImFwcCIsICJpbXBvcnRfb2JzaWRpYW4iLCAiYXBwIiwgInRhZyIsICJ1bnJlc29sdmVkTGlua3MiLCAibGluZUNvbnRlbnQiLCAiaSIsICJ0YWciLCAibGluZSIsICJhcHAiLCAibW9tZW50IiwgImN1cnNvciJdCn0K
