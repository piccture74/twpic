/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/moment/moment.js
var require_moment = __commonJS({
  "node_modules/moment/moment.js"(exports, module2) {
    (function(global, factory) {
      typeof exports === "object" && typeof module2 !== "undefined" ? module2.exports = factory() : typeof define === "function" && define.amd ? define(factory) : global.moment = factory();
    })(exports, function() {
      "use strict";
      var hookCallback;
      function hooks() {
        return hookCallback.apply(null, arguments);
      }
      function setHookCallback(callback) {
        hookCallback = callback;
      }
      function isArray(input) {
        return input instanceof Array || Object.prototype.toString.call(input) === "[object Array]";
      }
      function isObject(input) {
        return input != null && Object.prototype.toString.call(input) === "[object Object]";
      }
      function hasOwnProp(a, b) {
        return Object.prototype.hasOwnProperty.call(a, b);
      }
      function isObjectEmpty(obj) {
        if (Object.getOwnPropertyNames) {
          return Object.getOwnPropertyNames(obj).length === 0;
        } else {
          var k;
          for (k in obj) {
            if (hasOwnProp(obj, k)) {
              return false;
            }
          }
          return true;
        }
      }
      function isUndefined(input) {
        return input === void 0;
      }
      function isNumber(input) {
        return typeof input === "number" || Object.prototype.toString.call(input) === "[object Number]";
      }
      function isDate(input) {
        return input instanceof Date || Object.prototype.toString.call(input) === "[object Date]";
      }
      function map2(arr, fn) {
        var res = [], i;
        for (i = 0; i < arr.length; ++i) {
          res.push(fn(arr[i], i));
        }
        return res;
      }
      function extend(a, b) {
        for (var i in b) {
          if (hasOwnProp(b, i)) {
            a[i] = b[i];
          }
        }
        if (hasOwnProp(b, "toString")) {
          a.toString = b.toString;
        }
        if (hasOwnProp(b, "valueOf")) {
          a.valueOf = b.valueOf;
        }
        return a;
      }
      function createUTC(input, format2, locale2, strict) {
        return createLocalOrUTC(input, format2, locale2, strict, true).utc();
      }
      function defaultParsingFlags() {
        return {
          empty: false,
          unusedTokens: [],
          unusedInput: [],
          overflow: -2,
          charsLeftOver: 0,
          nullInput: false,
          invalidEra: null,
          invalidMonth: null,
          invalidFormat: false,
          userInvalidated: false,
          iso: false,
          parsedDateParts: [],
          era: null,
          meridiem: null,
          rfc2822: false,
          weekdayMismatch: false
        };
      }
      function getParsingFlags(m) {
        if (m._pf == null) {
          m._pf = defaultParsingFlags();
        }
        return m._pf;
      }
      var some;
      if (Array.prototype.some) {
        some = Array.prototype.some;
      } else {
        some = function(fun) {
          var t = Object(this), len = t.length >>> 0, i;
          for (i = 0; i < len; i++) {
            if (i in t && fun.call(this, t[i], i, t)) {
              return true;
            }
          }
          return false;
        };
      }
      function isValid(m) {
        if (m._isValid == null) {
          var flags = getParsingFlags(m), parsedParts = some.call(flags.parsedDateParts, function(i) {
            return i != null;
          }), isNowValid = !isNaN(m._d.getTime()) && flags.overflow < 0 && !flags.empty && !flags.invalidEra && !flags.invalidMonth && !flags.invalidWeekday && !flags.weekdayMismatch && !flags.nullInput && !flags.invalidFormat && !flags.userInvalidated && (!flags.meridiem || flags.meridiem && parsedParts);
          if (m._strict) {
            isNowValid = isNowValid && flags.charsLeftOver === 0 && flags.unusedTokens.length === 0 && flags.bigHour === void 0;
          }
          if (Object.isFrozen == null || !Object.isFrozen(m)) {
            m._isValid = isNowValid;
          } else {
            return isNowValid;
          }
        }
        return m._isValid;
      }
      function createInvalid(flags) {
        var m = createUTC(NaN);
        if (flags != null) {
          extend(getParsingFlags(m), flags);
        } else {
          getParsingFlags(m).userInvalidated = true;
        }
        return m;
      }
      var momentProperties = hooks.momentProperties = [], updateInProgress = false;
      function copyConfig(to2, from2) {
        var i, prop, val;
        if (!isUndefined(from2._isAMomentObject)) {
          to2._isAMomentObject = from2._isAMomentObject;
        }
        if (!isUndefined(from2._i)) {
          to2._i = from2._i;
        }
        if (!isUndefined(from2._f)) {
          to2._f = from2._f;
        }
        if (!isUndefined(from2._l)) {
          to2._l = from2._l;
        }
        if (!isUndefined(from2._strict)) {
          to2._strict = from2._strict;
        }
        if (!isUndefined(from2._tzm)) {
          to2._tzm = from2._tzm;
        }
        if (!isUndefined(from2._isUTC)) {
          to2._isUTC = from2._isUTC;
        }
        if (!isUndefined(from2._offset)) {
          to2._offset = from2._offset;
        }
        if (!isUndefined(from2._pf)) {
          to2._pf = getParsingFlags(from2);
        }
        if (!isUndefined(from2._locale)) {
          to2._locale = from2._locale;
        }
        if (momentProperties.length > 0) {
          for (i = 0; i < momentProperties.length; i++) {
            prop = momentProperties[i];
            val = from2[prop];
            if (!isUndefined(val)) {
              to2[prop] = val;
            }
          }
        }
        return to2;
      }
      function Moment(config) {
        copyConfig(this, config);
        this._d = new Date(config._d != null ? config._d.getTime() : NaN);
        if (!this.isValid()) {
          this._d = new Date(NaN);
        }
        if (updateInProgress === false) {
          updateInProgress = true;
          hooks.updateOffset(this);
          updateInProgress = false;
        }
      }
      function isMoment(obj) {
        return obj instanceof Moment || obj != null && obj._isAMomentObject != null;
      }
      function warn2(msg) {
        if (hooks.suppressDeprecationWarnings === false && typeof console !== "undefined" && console.warn) {
          console.warn("Deprecation warning: " + msg);
        }
      }
      function deprecate(msg, fn) {
        var firstTime = true;
        return extend(function() {
          if (hooks.deprecationHandler != null) {
            hooks.deprecationHandler(null, msg);
          }
          if (firstTime) {
            var args = [], arg, i, key;
            for (i = 0; i < arguments.length; i++) {
              arg = "";
              if (typeof arguments[i] === "object") {
                arg += "\n[" + i + "] ";
                for (key in arguments[0]) {
                  if (hasOwnProp(arguments[0], key)) {
                    arg += key + ": " + arguments[0][key] + ", ";
                  }
                }
                arg = arg.slice(0, -2);
              } else {
                arg = arguments[i];
              }
              args.push(arg);
            }
            warn2(
              msg + "\nArguments: " + Array.prototype.slice.call(args).join("") + "\n" + new Error().stack
            );
            firstTime = false;
          }
          return fn.apply(this, arguments);
        }, fn);
      }
      var deprecations = {};
      function deprecateSimple(name, msg) {
        if (hooks.deprecationHandler != null) {
          hooks.deprecationHandler(name, msg);
        }
        if (!deprecations[name]) {
          warn2(msg);
          deprecations[name] = true;
        }
      }
      hooks.suppressDeprecationWarnings = false;
      hooks.deprecationHandler = null;
      function isFunction(input) {
        return typeof Function !== "undefined" && input instanceof Function || Object.prototype.toString.call(input) === "[object Function]";
      }
      function set2(config) {
        var prop, i;
        for (i in config) {
          if (hasOwnProp(config, i)) {
            prop = config[i];
            if (isFunction(prop)) {
              this[i] = prop;
            } else {
              this["_" + i] = prop;
            }
          }
        }
        this._config = config;
        this._dayOfMonthOrdinalParseLenient = new RegExp(
          (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + "|" + /\d{1,2}/.source
        );
      }
      function mergeConfigs(parentConfig, childConfig) {
        var res = extend({}, parentConfig), prop;
        for (prop in childConfig) {
          if (hasOwnProp(childConfig, prop)) {
            if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
              res[prop] = {};
              extend(res[prop], parentConfig[prop]);
              extend(res[prop], childConfig[prop]);
            } else if (childConfig[prop] != null) {
              res[prop] = childConfig[prop];
            } else {
              delete res[prop];
            }
          }
        }
        for (prop in parentConfig) {
          if (hasOwnProp(parentConfig, prop) && !hasOwnProp(childConfig, prop) && isObject(parentConfig[prop])) {
            res[prop] = extend({}, res[prop]);
          }
        }
        return res;
      }
      function Locale(config) {
        if (config != null) {
          this.set(config);
        }
      }
      var keys;
      if (Object.keys) {
        keys = Object.keys;
      } else {
        keys = function(obj) {
          var i, res = [];
          for (i in obj) {
            if (hasOwnProp(obj, i)) {
              res.push(i);
            }
          }
          return res;
        };
      }
      var defaultCalendar = {
        sameDay: "[Today at] LT",
        nextDay: "[Tomorrow at] LT",
        nextWeek: "dddd [at] LT",
        lastDay: "[Yesterday at] LT",
        lastWeek: "[Last] dddd [at] LT",
        sameElse: "L"
      };
      function calendar(key, mom, now2) {
        var output = this._calendar[key] || this._calendar["sameElse"];
        return isFunction(output) ? output.call(mom, now2) : output;
      }
      function zeroFill(number, targetLength, forceSign) {
        var absNumber = "" + Math.abs(number), zerosToFill = targetLength - absNumber.length, sign2 = number >= 0;
        return (sign2 ? forceSign ? "+" : "" : "-") + Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
      }
      var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g, localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g, formatFunctions = {}, formatTokenFunctions = {};
      function addFormatToken(token2, padded, ordinal2, callback) {
        var func = callback;
        if (typeof callback === "string") {
          func = function() {
            return this[callback]();
          };
        }
        if (token2) {
          formatTokenFunctions[token2] = func;
        }
        if (padded) {
          formatTokenFunctions[padded[0]] = function() {
            return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
          };
        }
        if (ordinal2) {
          formatTokenFunctions[ordinal2] = function() {
            return this.localeData().ordinal(
              func.apply(this, arguments),
              token2
            );
          };
        }
      }
      function removeFormattingTokens(input) {
        if (input.match(/\[[\s\S]/)) {
          return input.replace(/^\[|\]$/g, "");
        }
        return input.replace(/\\/g, "");
      }
      function makeFormatFunction(format2) {
        var array = format2.match(formattingTokens), i, length;
        for (i = 0, length = array.length; i < length; i++) {
          if (formatTokenFunctions[array[i]]) {
            array[i] = formatTokenFunctions[array[i]];
          } else {
            array[i] = removeFormattingTokens(array[i]);
          }
        }
        return function(mom) {
          var output = "", i2;
          for (i2 = 0; i2 < length; i2++) {
            output += isFunction(array[i2]) ? array[i2].call(mom, format2) : array[i2];
          }
          return output;
        };
      }
      function formatMoment(m, format2) {
        if (!m.isValid()) {
          return m.localeData().invalidDate();
        }
        format2 = expandFormat(format2, m.localeData());
        formatFunctions[format2] = formatFunctions[format2] || makeFormatFunction(format2);
        return formatFunctions[format2](m);
      }
      function expandFormat(format2, locale2) {
        var i = 5;
        function replaceLongDateFormatTokens(input) {
          return locale2.longDateFormat(input) || input;
        }
        localFormattingTokens.lastIndex = 0;
        while (i >= 0 && localFormattingTokens.test(format2)) {
          format2 = format2.replace(
            localFormattingTokens,
            replaceLongDateFormatTokens
          );
          localFormattingTokens.lastIndex = 0;
          i -= 1;
        }
        return format2;
      }
      var defaultLongDateFormat = {
        LTS: "h:mm:ss A",
        LT: "h:mm A",
        L: "MM/DD/YYYY",
        LL: "MMMM D, YYYY",
        LLL: "MMMM D, YYYY h:mm A",
        LLLL: "dddd, MMMM D, YYYY h:mm A"
      };
      function longDateFormat(key) {
        var format2 = this._longDateFormat[key], formatUpper = this._longDateFormat[key.toUpperCase()];
        if (format2 || !formatUpper) {
          return format2;
        }
        this._longDateFormat[key] = formatUpper.match(formattingTokens).map(function(tok) {
          if (tok === "MMMM" || tok === "MM" || tok === "DD" || tok === "dddd") {
            return tok.slice(1);
          }
          return tok;
        }).join("");
        return this._longDateFormat[key];
      }
      var defaultInvalidDate = "Invalid date";
      function invalidDate() {
        return this._invalidDate;
      }
      var defaultOrdinal = "%d", defaultDayOfMonthOrdinalParse = /\d{1,2}/;
      function ordinal(number) {
        return this._ordinal.replace("%d", number);
      }
      var defaultRelativeTime = {
        future: "in %s",
        past: "%s ago",
        s: "a few seconds",
        ss: "%d seconds",
        m: "a minute",
        mm: "%d minutes",
        h: "an hour",
        hh: "%d hours",
        d: "a day",
        dd: "%d days",
        w: "a week",
        ww: "%d weeks",
        M: "a month",
        MM: "%d months",
        y: "a year",
        yy: "%d years"
      };
      function relativeTime(number, withoutSuffix, string2, isFuture) {
        var output = this._relativeTime[string2];
        return isFunction(output) ? output(number, withoutSuffix, string2, isFuture) : output.replace(/%d/i, number);
      }
      function pastFuture(diff2, output) {
        var format2 = this._relativeTime[diff2 > 0 ? "future" : "past"];
        return isFunction(format2) ? format2(output) : format2.replace(/%s/i, output);
      }
      var aliases = {};
      function addUnitAlias(unit, shorthand) {
        var lowerCase = unit.toLowerCase();
        aliases[lowerCase] = aliases[lowerCase + "s"] = aliases[shorthand] = unit;
      }
      function normalizeUnits(units) {
        return typeof units === "string" ? aliases[units] || aliases[units.toLowerCase()] : void 0;
      }
      function normalizeObjectUnits(inputObject) {
        var normalizedInput = {}, normalizedProp, prop;
        for (prop in inputObject) {
          if (hasOwnProp(inputObject, prop)) {
            normalizedProp = normalizeUnits(prop);
            if (normalizedProp) {
              normalizedInput[normalizedProp] = inputObject[prop];
            }
          }
        }
        return normalizedInput;
      }
      var priorities = {};
      function addUnitPriority(unit, priority) {
        priorities[unit] = priority;
      }
      function getPrioritizedUnits(unitsObj) {
        var units = [], u;
        for (u in unitsObj) {
          if (hasOwnProp(unitsObj, u)) {
            units.push({ unit: u, priority: priorities[u] });
          }
        }
        units.sort(function(a, b) {
          return a.priority - b.priority;
        });
        return units;
      }
      function isLeapYear(year) {
        return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
      }
      function absFloor(number) {
        if (number < 0) {
          return Math.ceil(number) || 0;
        } else {
          return Math.floor(number);
        }
      }
      function toInt(argumentForCoercion) {
        var coercedNumber = +argumentForCoercion, value = 0;
        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
          value = absFloor(coercedNumber);
        }
        return value;
      }
      function makeGetSet(unit, keepTime) {
        return function(value) {
          if (value != null) {
            set$1(this, unit, value);
            hooks.updateOffset(this, keepTime);
            return this;
          } else {
            return get(this, unit);
          }
        };
      }
      function get(mom, unit) {
        return mom.isValid() ? mom._d["get" + (mom._isUTC ? "UTC" : "") + unit]() : NaN;
      }
      function set$1(mom, unit, value) {
        if (mom.isValid() && !isNaN(value)) {
          if (unit === "FullYear" && isLeapYear(mom.year()) && mom.month() === 1 && mom.date() === 29) {
            value = toInt(value);
            mom._d["set" + (mom._isUTC ? "UTC" : "") + unit](
              value,
              mom.month(),
              daysInMonth(value, mom.month())
            );
          } else {
            mom._d["set" + (mom._isUTC ? "UTC" : "") + unit](value);
          }
        }
      }
      function stringGet(units) {
        units = normalizeUnits(units);
        if (isFunction(this[units])) {
          return this[units]();
        }
        return this;
      }
      function stringSet(units, value) {
        if (typeof units === "object") {
          units = normalizeObjectUnits(units);
          var prioritized = getPrioritizedUnits(units), i;
          for (i = 0; i < prioritized.length; i++) {
            this[prioritized[i].unit](units[prioritized[i].unit]);
          }
        } else {
          units = normalizeUnits(units);
          if (isFunction(this[units])) {
            return this[units](value);
          }
        }
        return this;
      }
      var match1 = /\d/, match2 = /\d\d/, match3 = /\d{3}/, match4 = /\d{4}/, match6 = /[+-]?\d{6}/, match1to2 = /\d\d?/, match3to4 = /\d\d\d\d?/, match5to6 = /\d\d\d\d\d\d?/, match1to3 = /\d{1,3}/, match1to4 = /\d{1,4}/, match1to6 = /[+-]?\d{1,6}/, matchUnsigned = /\d+/, matchSigned = /[+-]?\d+/, matchOffset = /Z|[+-]\d\d:?\d\d/gi, matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi, matchTimestamp = /[+-]?\d+(\.\d{1,3})?/, matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i, regexes;
      regexes = {};
      function addRegexToken(token2, regex, strictRegex) {
        regexes[token2] = isFunction(regex) ? regex : function(isStrict, localeData2) {
          return isStrict && strictRegex ? strictRegex : regex;
        };
      }
      function getParseRegexForToken(token2, config) {
        if (!hasOwnProp(regexes, token2)) {
          return new RegExp(unescapeFormat(token2));
        }
        return regexes[token2](config._strict, config._locale);
      }
      function unescapeFormat(s) {
        return regexEscape(
          s.replace("\\", "").replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function(matched, p1, p2, p3, p4) {
            return p1 || p2 || p3 || p4;
          })
        );
      }
      function regexEscape(s) {
        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
      }
      var tokens = {};
      function addParseToken(token2, callback) {
        var i, func = callback;
        if (typeof token2 === "string") {
          token2 = [token2];
        }
        if (isNumber(callback)) {
          func = function(input, array) {
            array[callback] = toInt(input);
          };
        }
        for (i = 0; i < token2.length; i++) {
          tokens[token2[i]] = func;
        }
      }
      function addWeekParseToken(token2, callback) {
        addParseToken(token2, function(input, array, config, token3) {
          config._w = config._w || {};
          callback(input, config._w, config, token3);
        });
      }
      function addTimeToArrayFromToken(token2, input, config) {
        if (input != null && hasOwnProp(tokens, token2)) {
          tokens[token2](input, config._a, config, token2);
        }
      }
      var YEAR = 0, MONTH = 1, DATE = 2, HOUR = 3, MINUTE = 4, SECOND = 5, MILLISECOND = 6, WEEK = 7, WEEKDAY = 8;
      function mod(n, x) {
        return (n % x + x) % x;
      }
      var indexOf;
      if (Array.prototype.indexOf) {
        indexOf = Array.prototype.indexOf;
      } else {
        indexOf = function(o) {
          var i;
          for (i = 0; i < this.length; ++i) {
            if (this[i] === o) {
              return i;
            }
          }
          return -1;
        };
      }
      function daysInMonth(year, month) {
        if (isNaN(year) || isNaN(month)) {
          return NaN;
        }
        var modMonth = mod(month, 12);
        year += (month - modMonth) / 12;
        return modMonth === 1 ? isLeapYear(year) ? 29 : 28 : 31 - modMonth % 7 % 2;
      }
      addFormatToken("M", ["MM", 2], "Mo", function() {
        return this.month() + 1;
      });
      addFormatToken("MMM", 0, 0, function(format2) {
        return this.localeData().monthsShort(this, format2);
      });
      addFormatToken("MMMM", 0, 0, function(format2) {
        return this.localeData().months(this, format2);
      });
      addUnitAlias("month", "M");
      addUnitPriority("month", 8);
      addRegexToken("M", match1to2);
      addRegexToken("MM", match1to2, match2);
      addRegexToken("MMM", function(isStrict, locale2) {
        return locale2.monthsShortRegex(isStrict);
      });
      addRegexToken("MMMM", function(isStrict, locale2) {
        return locale2.monthsRegex(isStrict);
      });
      addParseToken(["M", "MM"], function(input, array) {
        array[MONTH] = toInt(input) - 1;
      });
      addParseToken(["MMM", "MMMM"], function(input, array, config, token2) {
        var month = config._locale.monthsParse(input, token2, config._strict);
        if (month != null) {
          array[MONTH] = month;
        } else {
          getParsingFlags(config).invalidMonth = input;
        }
      });
      var defaultLocaleMonths = "January_February_March_April_May_June_July_August_September_October_November_December".split(
        "_"
      ), defaultLocaleMonthsShort = "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split(
        "_"
      ), MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/, defaultMonthsShortRegex = matchWord, defaultMonthsRegex = matchWord;
      function localeMonths(m, format2) {
        if (!m) {
          return isArray(this._months) ? this._months : this._months["standalone"];
        }
        return isArray(this._months) ? this._months[m.month()] : this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format2) ? "format" : "standalone"][m.month()];
      }
      function localeMonthsShort(m, format2) {
        if (!m) {
          return isArray(this._monthsShort) ? this._monthsShort : this._monthsShort["standalone"];
        }
        return isArray(this._monthsShort) ? this._monthsShort[m.month()] : this._monthsShort[MONTHS_IN_FORMAT.test(format2) ? "format" : "standalone"][m.month()];
      }
      function handleStrictParse(monthName, format2, strict) {
        var i, ii, mom, llc = monthName.toLocaleLowerCase();
        if (!this._monthsParse) {
          this._monthsParse = [];
          this._longMonthsParse = [];
          this._shortMonthsParse = [];
          for (i = 0; i < 12; ++i) {
            mom = createUTC([2e3, i]);
            this._shortMonthsParse[i] = this.monthsShort(
              mom,
              ""
            ).toLocaleLowerCase();
            this._longMonthsParse[i] = this.months(mom, "").toLocaleLowerCase();
          }
        }
        if (strict) {
          if (format2 === "MMM") {
            ii = indexOf.call(this._shortMonthsParse, llc);
            return ii !== -1 ? ii : null;
          } else {
            ii = indexOf.call(this._longMonthsParse, llc);
            return ii !== -1 ? ii : null;
          }
        } else {
          if (format2 === "MMM") {
            ii = indexOf.call(this._shortMonthsParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._longMonthsParse, llc);
            return ii !== -1 ? ii : null;
          } else {
            ii = indexOf.call(this._longMonthsParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._shortMonthsParse, llc);
            return ii !== -1 ? ii : null;
          }
        }
      }
      function localeMonthsParse(monthName, format2, strict) {
        var i, mom, regex;
        if (this._monthsParseExact) {
          return handleStrictParse.call(this, monthName, format2, strict);
        }
        if (!this._monthsParse) {
          this._monthsParse = [];
          this._longMonthsParse = [];
          this._shortMonthsParse = [];
        }
        for (i = 0; i < 12; i++) {
          mom = createUTC([2e3, i]);
          if (strict && !this._longMonthsParse[i]) {
            this._longMonthsParse[i] = new RegExp(
              "^" + this.months(mom, "").replace(".", "") + "$",
              "i"
            );
            this._shortMonthsParse[i] = new RegExp(
              "^" + this.monthsShort(mom, "").replace(".", "") + "$",
              "i"
            );
          }
          if (!strict && !this._monthsParse[i]) {
            regex = "^" + this.months(mom, "") + "|^" + this.monthsShort(mom, "");
            this._monthsParse[i] = new RegExp(regex.replace(".", ""), "i");
          }
          if (strict && format2 === "MMMM" && this._longMonthsParse[i].test(monthName)) {
            return i;
          } else if (strict && format2 === "MMM" && this._shortMonthsParse[i].test(monthName)) {
            return i;
          } else if (!strict && this._monthsParse[i].test(monthName)) {
            return i;
          }
        }
      }
      function setMonth(mom, value) {
        var dayOfMonth;
        if (!mom.isValid()) {
          return mom;
        }
        if (typeof value === "string") {
          if (/^\d+$/.test(value)) {
            value = toInt(value);
          } else {
            value = mom.localeData().monthsParse(value);
            if (!isNumber(value)) {
              return mom;
            }
          }
        }
        dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
        mom._d["set" + (mom._isUTC ? "UTC" : "") + "Month"](value, dayOfMonth);
        return mom;
      }
      function getSetMonth(value) {
        if (value != null) {
          setMonth(this, value);
          hooks.updateOffset(this, true);
          return this;
        } else {
          return get(this, "Month");
        }
      }
      function getDaysInMonth() {
        return daysInMonth(this.year(), this.month());
      }
      function monthsShortRegex(isStrict) {
        if (this._monthsParseExact) {
          if (!hasOwnProp(this, "_monthsRegex")) {
            computeMonthsParse.call(this);
          }
          if (isStrict) {
            return this._monthsShortStrictRegex;
          } else {
            return this._monthsShortRegex;
          }
        } else {
          if (!hasOwnProp(this, "_monthsShortRegex")) {
            this._monthsShortRegex = defaultMonthsShortRegex;
          }
          return this._monthsShortStrictRegex && isStrict ? this._monthsShortStrictRegex : this._monthsShortRegex;
        }
      }
      function monthsRegex(isStrict) {
        if (this._monthsParseExact) {
          if (!hasOwnProp(this, "_monthsRegex")) {
            computeMonthsParse.call(this);
          }
          if (isStrict) {
            return this._monthsStrictRegex;
          } else {
            return this._monthsRegex;
          }
        } else {
          if (!hasOwnProp(this, "_monthsRegex")) {
            this._monthsRegex = defaultMonthsRegex;
          }
          return this._monthsStrictRegex && isStrict ? this._monthsStrictRegex : this._monthsRegex;
        }
      }
      function computeMonthsParse() {
        function cmpLenRev(a, b) {
          return b.length - a.length;
        }
        var shortPieces = [], longPieces = [], mixedPieces = [], i, mom;
        for (i = 0; i < 12; i++) {
          mom = createUTC([2e3, i]);
          shortPieces.push(this.monthsShort(mom, ""));
          longPieces.push(this.months(mom, ""));
          mixedPieces.push(this.months(mom, ""));
          mixedPieces.push(this.monthsShort(mom, ""));
        }
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);
        for (i = 0; i < 12; i++) {
          shortPieces[i] = regexEscape(shortPieces[i]);
          longPieces[i] = regexEscape(longPieces[i]);
        }
        for (i = 0; i < 24; i++) {
          mixedPieces[i] = regexEscape(mixedPieces[i]);
        }
        this._monthsRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
        this._monthsShortRegex = this._monthsRegex;
        this._monthsStrictRegex = new RegExp(
          "^(" + longPieces.join("|") + ")",
          "i"
        );
        this._monthsShortStrictRegex = new RegExp(
          "^(" + shortPieces.join("|") + ")",
          "i"
        );
      }
      addFormatToken("Y", 0, 0, function() {
        var y = this.year();
        return y <= 9999 ? zeroFill(y, 4) : "+" + y;
      });
      addFormatToken(0, ["YY", 2], 0, function() {
        return this.year() % 100;
      });
      addFormatToken(0, ["YYYY", 4], 0, "year");
      addFormatToken(0, ["YYYYY", 5], 0, "year");
      addFormatToken(0, ["YYYYYY", 6, true], 0, "year");
      addUnitAlias("year", "y");
      addUnitPriority("year", 1);
      addRegexToken("Y", matchSigned);
      addRegexToken("YY", match1to2, match2);
      addRegexToken("YYYY", match1to4, match4);
      addRegexToken("YYYYY", match1to6, match6);
      addRegexToken("YYYYYY", match1to6, match6);
      addParseToken(["YYYYY", "YYYYYY"], YEAR);
      addParseToken("YYYY", function(input, array) {
        array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
      });
      addParseToken("YY", function(input, array) {
        array[YEAR] = hooks.parseTwoDigitYear(input);
      });
      addParseToken("Y", function(input, array) {
        array[YEAR] = parseInt(input, 10);
      });
      function daysInYear(year) {
        return isLeapYear(year) ? 366 : 365;
      }
      hooks.parseTwoDigitYear = function(input) {
        return toInt(input) + (toInt(input) > 68 ? 1900 : 2e3);
      };
      var getSetYear = makeGetSet("FullYear", true);
      function getIsLeapYear() {
        return isLeapYear(this.year());
      }
      function createDate(y, m, d, h, M, s, ms) {
        var date;
        if (y < 100 && y >= 0) {
          date = new Date(y + 400, m, d, h, M, s, ms);
          if (isFinite(date.getFullYear())) {
            date.setFullYear(y);
          }
        } else {
          date = new Date(y, m, d, h, M, s, ms);
        }
        return date;
      }
      function createUTCDate(y) {
        var date, args;
        if (y < 100 && y >= 0) {
          args = Array.prototype.slice.call(arguments);
          args[0] = y + 400;
          date = new Date(Date.UTC.apply(null, args));
          if (isFinite(date.getUTCFullYear())) {
            date.setUTCFullYear(y);
          }
        } else {
          date = new Date(Date.UTC.apply(null, arguments));
        }
        return date;
      }
      function firstWeekOffset(year, dow, doy) {
        var fwd = 7 + dow - doy, fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;
        return -fwdlw + fwd - 1;
      }
      function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
        var localWeekday = (7 + weekday - dow) % 7, weekOffset = firstWeekOffset(year, dow, doy), dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset, resYear, resDayOfYear;
        if (dayOfYear <= 0) {
          resYear = year - 1;
          resDayOfYear = daysInYear(resYear) + dayOfYear;
        } else if (dayOfYear > daysInYear(year)) {
          resYear = year + 1;
          resDayOfYear = dayOfYear - daysInYear(year);
        } else {
          resYear = year;
          resDayOfYear = dayOfYear;
        }
        return {
          year: resYear,
          dayOfYear: resDayOfYear
        };
      }
      function weekOfYear(mom, dow, doy) {
        var weekOffset = firstWeekOffset(mom.year(), dow, doy), week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1, resWeek, resYear;
        if (week < 1) {
          resYear = mom.year() - 1;
          resWeek = week + weeksInYear(resYear, dow, doy);
        } else if (week > weeksInYear(mom.year(), dow, doy)) {
          resWeek = week - weeksInYear(mom.year(), dow, doy);
          resYear = mom.year() + 1;
        } else {
          resYear = mom.year();
          resWeek = week;
        }
        return {
          week: resWeek,
          year: resYear
        };
      }
      function weeksInYear(year, dow, doy) {
        var weekOffset = firstWeekOffset(year, dow, doy), weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
        return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
      }
      addFormatToken("w", ["ww", 2], "wo", "week");
      addFormatToken("W", ["WW", 2], "Wo", "isoWeek");
      addUnitAlias("week", "w");
      addUnitAlias("isoWeek", "W");
      addUnitPriority("week", 5);
      addUnitPriority("isoWeek", 5);
      addRegexToken("w", match1to2);
      addRegexToken("ww", match1to2, match2);
      addRegexToken("W", match1to2);
      addRegexToken("WW", match1to2, match2);
      addWeekParseToken(["w", "ww", "W", "WW"], function(input, week, config, token2) {
        week[token2.substr(0, 1)] = toInt(input);
      });
      function localeWeek(mom) {
        return weekOfYear(mom, this._week.dow, this._week.doy).week;
      }
      var defaultLocaleWeek = {
        dow: 0,
        // Sunday is the first day of the week.
        doy: 6
        // The week that contains Jan 6th is the first week of the year.
      };
      function localeFirstDayOfWeek() {
        return this._week.dow;
      }
      function localeFirstDayOfYear() {
        return this._week.doy;
      }
      function getSetWeek(input) {
        var week = this.localeData().week(this);
        return input == null ? week : this.add((input - week) * 7, "d");
      }
      function getSetISOWeek(input) {
        var week = weekOfYear(this, 1, 4).week;
        return input == null ? week : this.add((input - week) * 7, "d");
      }
      addFormatToken("d", 0, "do", "day");
      addFormatToken("dd", 0, 0, function(format2) {
        return this.localeData().weekdaysMin(this, format2);
      });
      addFormatToken("ddd", 0, 0, function(format2) {
        return this.localeData().weekdaysShort(this, format2);
      });
      addFormatToken("dddd", 0, 0, function(format2) {
        return this.localeData().weekdays(this, format2);
      });
      addFormatToken("e", 0, 0, "weekday");
      addFormatToken("E", 0, 0, "isoWeekday");
      addUnitAlias("day", "d");
      addUnitAlias("weekday", "e");
      addUnitAlias("isoWeekday", "E");
      addUnitPriority("day", 11);
      addUnitPriority("weekday", 11);
      addUnitPriority("isoWeekday", 11);
      addRegexToken("d", match1to2);
      addRegexToken("e", match1to2);
      addRegexToken("E", match1to2);
      addRegexToken("dd", function(isStrict, locale2) {
        return locale2.weekdaysMinRegex(isStrict);
      });
      addRegexToken("ddd", function(isStrict, locale2) {
        return locale2.weekdaysShortRegex(isStrict);
      });
      addRegexToken("dddd", function(isStrict, locale2) {
        return locale2.weekdaysRegex(isStrict);
      });
      addWeekParseToken(["dd", "ddd", "dddd"], function(input, week, config, token2) {
        var weekday = config._locale.weekdaysParse(input, token2, config._strict);
        if (weekday != null) {
          week.d = weekday;
        } else {
          getParsingFlags(config).invalidWeekday = input;
        }
      });
      addWeekParseToken(["d", "e", "E"], function(input, week, config, token2) {
        week[token2] = toInt(input);
      });
      function parseWeekday(input, locale2) {
        if (typeof input !== "string") {
          return input;
        }
        if (!isNaN(input)) {
          return parseInt(input, 10);
        }
        input = locale2.weekdaysParse(input);
        if (typeof input === "number") {
          return input;
        }
        return null;
      }
      function parseIsoWeekday(input, locale2) {
        if (typeof input === "string") {
          return locale2.weekdaysParse(input) % 7 || 7;
        }
        return isNaN(input) ? null : input;
      }
      function shiftWeekdays(ws, n) {
        return ws.slice(n, 7).concat(ws.slice(0, n));
      }
      var defaultLocaleWeekdays = "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split(
        "_"
      ), defaultLocaleWeekdaysShort = "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"), defaultLocaleWeekdaysMin = "Su_Mo_Tu_We_Th_Fr_Sa".split("_"), defaultWeekdaysRegex = matchWord, defaultWeekdaysShortRegex = matchWord, defaultWeekdaysMinRegex = matchWord;
      function localeWeekdays(m, format2) {
        var weekdays = isArray(this._weekdays) ? this._weekdays : this._weekdays[m && m !== true && this._weekdays.isFormat.test(format2) ? "format" : "standalone"];
        return m === true ? shiftWeekdays(weekdays, this._week.dow) : m ? weekdays[m.day()] : weekdays;
      }
      function localeWeekdaysShort(m) {
        return m === true ? shiftWeekdays(this._weekdaysShort, this._week.dow) : m ? this._weekdaysShort[m.day()] : this._weekdaysShort;
      }
      function localeWeekdaysMin(m) {
        return m === true ? shiftWeekdays(this._weekdaysMin, this._week.dow) : m ? this._weekdaysMin[m.day()] : this._weekdaysMin;
      }
      function handleStrictParse$1(weekdayName, format2, strict) {
        var i, ii, mom, llc = weekdayName.toLocaleLowerCase();
        if (!this._weekdaysParse) {
          this._weekdaysParse = [];
          this._shortWeekdaysParse = [];
          this._minWeekdaysParse = [];
          for (i = 0; i < 7; ++i) {
            mom = createUTC([2e3, 1]).day(i);
            this._minWeekdaysParse[i] = this.weekdaysMin(
              mom,
              ""
            ).toLocaleLowerCase();
            this._shortWeekdaysParse[i] = this.weekdaysShort(
              mom,
              ""
            ).toLocaleLowerCase();
            this._weekdaysParse[i] = this.weekdays(mom, "").toLocaleLowerCase();
          }
        }
        if (strict) {
          if (format2 === "dddd") {
            ii = indexOf.call(this._weekdaysParse, llc);
            return ii !== -1 ? ii : null;
          } else if (format2 === "ddd") {
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          } else {
            ii = indexOf.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          }
        } else {
          if (format2 === "dddd") {
            ii = indexOf.call(this._weekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          } else if (format2 === "ddd") {
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._weekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          } else {
            ii = indexOf.call(this._minWeekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._weekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          }
        }
      }
      function localeWeekdaysParse(weekdayName, format2, strict) {
        var i, mom, regex;
        if (this._weekdaysParseExact) {
          return handleStrictParse$1.call(this, weekdayName, format2, strict);
        }
        if (!this._weekdaysParse) {
          this._weekdaysParse = [];
          this._minWeekdaysParse = [];
          this._shortWeekdaysParse = [];
          this._fullWeekdaysParse = [];
        }
        for (i = 0; i < 7; i++) {
          mom = createUTC([2e3, 1]).day(i);
          if (strict && !this._fullWeekdaysParse[i]) {
            this._fullWeekdaysParse[i] = new RegExp(
              "^" + this.weekdays(mom, "").replace(".", "\\.?") + "$",
              "i"
            );
            this._shortWeekdaysParse[i] = new RegExp(
              "^" + this.weekdaysShort(mom, "").replace(".", "\\.?") + "$",
              "i"
            );
            this._minWeekdaysParse[i] = new RegExp(
              "^" + this.weekdaysMin(mom, "").replace(".", "\\.?") + "$",
              "i"
            );
          }
          if (!this._weekdaysParse[i]) {
            regex = "^" + this.weekdays(mom, "") + "|^" + this.weekdaysShort(mom, "") + "|^" + this.weekdaysMin(mom, "");
            this._weekdaysParse[i] = new RegExp(regex.replace(".", ""), "i");
          }
          if (strict && format2 === "dddd" && this._fullWeekdaysParse[i].test(weekdayName)) {
            return i;
          } else if (strict && format2 === "ddd" && this._shortWeekdaysParse[i].test(weekdayName)) {
            return i;
          } else if (strict && format2 === "dd" && this._minWeekdaysParse[i].test(weekdayName)) {
            return i;
          } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
            return i;
          }
        }
      }
      function getSetDayOfWeek(input) {
        if (!this.isValid()) {
          return input != null ? this : NaN;
        }
        var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
        if (input != null) {
          input = parseWeekday(input, this.localeData());
          return this.add(input - day, "d");
        } else {
          return day;
        }
      }
      function getSetLocaleDayOfWeek(input) {
        if (!this.isValid()) {
          return input != null ? this : NaN;
        }
        var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
        return input == null ? weekday : this.add(input - weekday, "d");
      }
      function getSetISODayOfWeek(input) {
        if (!this.isValid()) {
          return input != null ? this : NaN;
        }
        if (input != null) {
          var weekday = parseIsoWeekday(input, this.localeData());
          return this.day(this.day() % 7 ? weekday : weekday - 7);
        } else {
          return this.day() || 7;
        }
      }
      function weekdaysRegex(isStrict) {
        if (this._weekdaysParseExact) {
          if (!hasOwnProp(this, "_weekdaysRegex")) {
            computeWeekdaysParse.call(this);
          }
          if (isStrict) {
            return this._weekdaysStrictRegex;
          } else {
            return this._weekdaysRegex;
          }
        } else {
          if (!hasOwnProp(this, "_weekdaysRegex")) {
            this._weekdaysRegex = defaultWeekdaysRegex;
          }
          return this._weekdaysStrictRegex && isStrict ? this._weekdaysStrictRegex : this._weekdaysRegex;
        }
      }
      function weekdaysShortRegex(isStrict) {
        if (this._weekdaysParseExact) {
          if (!hasOwnProp(this, "_weekdaysRegex")) {
            computeWeekdaysParse.call(this);
          }
          if (isStrict) {
            return this._weekdaysShortStrictRegex;
          } else {
            return this._weekdaysShortRegex;
          }
        } else {
          if (!hasOwnProp(this, "_weekdaysShortRegex")) {
            this._weekdaysShortRegex = defaultWeekdaysShortRegex;
          }
          return this._weekdaysShortStrictRegex && isStrict ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
        }
      }
      function weekdaysMinRegex(isStrict) {
        if (this._weekdaysParseExact) {
          if (!hasOwnProp(this, "_weekdaysRegex")) {
            computeWeekdaysParse.call(this);
          }
          if (isStrict) {
            return this._weekdaysMinStrictRegex;
          } else {
            return this._weekdaysMinRegex;
          }
        } else {
          if (!hasOwnProp(this, "_weekdaysMinRegex")) {
            this._weekdaysMinRegex = defaultWeekdaysMinRegex;
          }
          return this._weekdaysMinStrictRegex && isStrict ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
        }
      }
      function computeWeekdaysParse() {
        function cmpLenRev(a, b) {
          return b.length - a.length;
        }
        var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [], i, mom, minp, shortp, longp;
        for (i = 0; i < 7; i++) {
          mom = createUTC([2e3, 1]).day(i);
          minp = regexEscape(this.weekdaysMin(mom, ""));
          shortp = regexEscape(this.weekdaysShort(mom, ""));
          longp = regexEscape(this.weekdays(mom, ""));
          minPieces.push(minp);
          shortPieces.push(shortp);
          longPieces.push(longp);
          mixedPieces.push(minp);
          mixedPieces.push(shortp);
          mixedPieces.push(longp);
        }
        minPieces.sort(cmpLenRev);
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);
        this._weekdaysRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
        this._weekdaysShortRegex = this._weekdaysRegex;
        this._weekdaysMinRegex = this._weekdaysRegex;
        this._weekdaysStrictRegex = new RegExp(
          "^(" + longPieces.join("|") + ")",
          "i"
        );
        this._weekdaysShortStrictRegex = new RegExp(
          "^(" + shortPieces.join("|") + ")",
          "i"
        );
        this._weekdaysMinStrictRegex = new RegExp(
          "^(" + minPieces.join("|") + ")",
          "i"
        );
      }
      function hFormat() {
        return this.hours() % 12 || 12;
      }
      function kFormat() {
        return this.hours() || 24;
      }
      addFormatToken("H", ["HH", 2], 0, "hour");
      addFormatToken("h", ["hh", 2], 0, hFormat);
      addFormatToken("k", ["kk", 2], 0, kFormat);
      addFormatToken("hmm", 0, 0, function() {
        return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2);
      });
      addFormatToken("hmmss", 0, 0, function() {
        return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
      });
      addFormatToken("Hmm", 0, 0, function() {
        return "" + this.hours() + zeroFill(this.minutes(), 2);
      });
      addFormatToken("Hmmss", 0, 0, function() {
        return "" + this.hours() + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
      });
      function meridiem(token2, lowercase) {
        addFormatToken(token2, 0, 0, function() {
          return this.localeData().meridiem(
            this.hours(),
            this.minutes(),
            lowercase
          );
        });
      }
      meridiem("a", true);
      meridiem("A", false);
      addUnitAlias("hour", "h");
      addUnitPriority("hour", 13);
      function matchMeridiem(isStrict, locale2) {
        return locale2._meridiemParse;
      }
      addRegexToken("a", matchMeridiem);
      addRegexToken("A", matchMeridiem);
      addRegexToken("H", match1to2);
      addRegexToken("h", match1to2);
      addRegexToken("k", match1to2);
      addRegexToken("HH", match1to2, match2);
      addRegexToken("hh", match1to2, match2);
      addRegexToken("kk", match1to2, match2);
      addRegexToken("hmm", match3to4);
      addRegexToken("hmmss", match5to6);
      addRegexToken("Hmm", match3to4);
      addRegexToken("Hmmss", match5to6);
      addParseToken(["H", "HH"], HOUR);
      addParseToken(["k", "kk"], function(input, array, config) {
        var kInput = toInt(input);
        array[HOUR] = kInput === 24 ? 0 : kInput;
      });
      addParseToken(["a", "A"], function(input, array, config) {
        config._isPm = config._locale.isPM(input);
        config._meridiem = input;
      });
      addParseToken(["h", "hh"], function(input, array, config) {
        array[HOUR] = toInt(input);
        getParsingFlags(config).bigHour = true;
      });
      addParseToken("hmm", function(input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
        getParsingFlags(config).bigHour = true;
      });
      addParseToken("hmmss", function(input, array, config) {
        var pos1 = input.length - 4, pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
        getParsingFlags(config).bigHour = true;
      });
      addParseToken("Hmm", function(input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
      });
      addParseToken("Hmmss", function(input, array, config) {
        var pos1 = input.length - 4, pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
      });
      function localeIsPM(input) {
        return (input + "").toLowerCase().charAt(0) === "p";
      }
      var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i, getSetHour = makeGetSet("Hours", true);
      function localeMeridiem(hours2, minutes2, isLower) {
        if (hours2 > 11) {
          return isLower ? "pm" : "PM";
        } else {
          return isLower ? "am" : "AM";
        }
      }
      var baseConfig = {
        calendar: defaultCalendar,
        longDateFormat: defaultLongDateFormat,
        invalidDate: defaultInvalidDate,
        ordinal: defaultOrdinal,
        dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
        relativeTime: defaultRelativeTime,
        months: defaultLocaleMonths,
        monthsShort: defaultLocaleMonthsShort,
        week: defaultLocaleWeek,
        weekdays: defaultLocaleWeekdays,
        weekdaysMin: defaultLocaleWeekdaysMin,
        weekdaysShort: defaultLocaleWeekdaysShort,
        meridiemParse: defaultLocaleMeridiemParse
      };
      var locales = {}, localeFamilies = {}, globalLocale;
      function commonPrefix(arr1, arr2) {
        var i, minl = Math.min(arr1.length, arr2.length);
        for (i = 0; i < minl; i += 1) {
          if (arr1[i] !== arr2[i]) {
            return i;
          }
        }
        return minl;
      }
      function normalizeLocale(key) {
        return key ? key.toLowerCase().replace("_", "-") : key;
      }
      function chooseLocale(names) {
        var i = 0, j, next, locale2, split;
        while (i < names.length) {
          split = normalizeLocale(names[i]).split("-");
          j = split.length;
          next = normalizeLocale(names[i + 1]);
          next = next ? next.split("-") : null;
          while (j > 0) {
            locale2 = loadLocale(split.slice(0, j).join("-"));
            if (locale2) {
              return locale2;
            }
            if (next && next.length >= j && commonPrefix(split, next) >= j - 1) {
              break;
            }
            j--;
          }
          i++;
        }
        return globalLocale;
      }
      function loadLocale(name) {
        var oldLocale = null, aliasedRequire;
        if (locales[name] === void 0 && typeof module2 !== "undefined" && module2 && module2.exports) {
          try {
            oldLocale = globalLocale._abbr;
            aliasedRequire = require;
            aliasedRequire("./locale/" + name);
            getSetGlobalLocale(oldLocale);
          } catch (e) {
            locales[name] = null;
          }
        }
        return locales[name];
      }
      function getSetGlobalLocale(key, values) {
        var data;
        if (key) {
          if (isUndefined(values)) {
            data = getLocale(key);
          } else {
            data = defineLocale(key, values);
          }
          if (data) {
            globalLocale = data;
          } else {
            if (typeof console !== "undefined" && console.warn) {
              console.warn(
                "Locale " + key + " not found. Did you forget to load it?"
              );
            }
          }
        }
        return globalLocale._abbr;
      }
      function defineLocale(name, config) {
        if (config !== null) {
          var locale2, parentConfig = baseConfig;
          config.abbr = name;
          if (locales[name] != null) {
            deprecateSimple(
              "defineLocaleOverride",
              "use moment.updateLocale(localeName, config) to change an existing locale. moment.defineLocale(localeName, config) should only be used for creating a new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more info."
            );
            parentConfig = locales[name]._config;
          } else if (config.parentLocale != null) {
            if (locales[config.parentLocale] != null) {
              parentConfig = locales[config.parentLocale]._config;
            } else {
              locale2 = loadLocale(config.parentLocale);
              if (locale2 != null) {
                parentConfig = locale2._config;
              } else {
                if (!localeFamilies[config.parentLocale]) {
                  localeFamilies[config.parentLocale] = [];
                }
                localeFamilies[config.parentLocale].push({
                  name,
                  config
                });
                return null;
              }
            }
          }
          locales[name] = new Locale(mergeConfigs(parentConfig, config));
          if (localeFamilies[name]) {
            localeFamilies[name].forEach(function(x) {
              defineLocale(x.name, x.config);
            });
          }
          getSetGlobalLocale(name);
          return locales[name];
        } else {
          delete locales[name];
          return null;
        }
      }
      function updateLocale(name, config) {
        if (config != null) {
          var locale2, tmpLocale, parentConfig = baseConfig;
          if (locales[name] != null && locales[name].parentLocale != null) {
            locales[name].set(mergeConfigs(locales[name]._config, config));
          } else {
            tmpLocale = loadLocale(name);
            if (tmpLocale != null) {
              parentConfig = tmpLocale._config;
            }
            config = mergeConfigs(parentConfig, config);
            if (tmpLocale == null) {
              config.abbr = name;
            }
            locale2 = new Locale(config);
            locale2.parentLocale = locales[name];
            locales[name] = locale2;
          }
          getSetGlobalLocale(name);
        } else {
          if (locales[name] != null) {
            if (locales[name].parentLocale != null) {
              locales[name] = locales[name].parentLocale;
              if (name === getSetGlobalLocale()) {
                getSetGlobalLocale(name);
              }
            } else if (locales[name] != null) {
              delete locales[name];
            }
          }
        }
        return locales[name];
      }
      function getLocale(key) {
        var locale2;
        if (key && key._locale && key._locale._abbr) {
          key = key._locale._abbr;
        }
        if (!key) {
          return globalLocale;
        }
        if (!isArray(key)) {
          locale2 = loadLocale(key);
          if (locale2) {
            return locale2;
          }
          key = [key];
        }
        return chooseLocale(key);
      }
      function listLocales() {
        return keys(locales);
      }
      function checkOverflow(m) {
        var overflow, a = m._a;
        if (a && getParsingFlags(m).overflow === -2) {
          overflow = a[MONTH] < 0 || a[MONTH] > 11 ? MONTH : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH]) ? DATE : a[HOUR] < 0 || a[HOUR] > 24 || a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0) ? HOUR : a[MINUTE] < 0 || a[MINUTE] > 59 ? MINUTE : a[SECOND] < 0 || a[SECOND] > 59 ? SECOND : a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND : -1;
          if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
            overflow = DATE;
          }
          if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
            overflow = WEEK;
          }
          if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
            overflow = WEEKDAY;
          }
          getParsingFlags(m).overflow = overflow;
        }
        return m;
      }
      var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, tzRegex = /Z|[+-]\d\d(?::?\d\d)?/, isoDates = [
        ["YYYYYY-MM-DD", /[+-]\d{6}-\d\d-\d\d/],
        ["YYYY-MM-DD", /\d{4}-\d\d-\d\d/],
        ["GGGG-[W]WW-E", /\d{4}-W\d\d-\d/],
        ["GGGG-[W]WW", /\d{4}-W\d\d/, false],
        ["YYYY-DDD", /\d{4}-\d{3}/],
        ["YYYY-MM", /\d{4}-\d\d/, false],
        ["YYYYYYMMDD", /[+-]\d{10}/],
        ["YYYYMMDD", /\d{8}/],
        ["GGGG[W]WWE", /\d{4}W\d{3}/],
        ["GGGG[W]WW", /\d{4}W\d{2}/, false],
        ["YYYYDDD", /\d{7}/],
        ["YYYYMM", /\d{6}/, false],
        ["YYYY", /\d{4}/, false]
      ], isoTimes = [
        ["HH:mm:ss.SSSS", /\d\d:\d\d:\d\d\.\d+/],
        ["HH:mm:ss,SSSS", /\d\d:\d\d:\d\d,\d+/],
        ["HH:mm:ss", /\d\d:\d\d:\d\d/],
        ["HH:mm", /\d\d:\d\d/],
        ["HHmmss.SSSS", /\d\d\d\d\d\d\.\d+/],
        ["HHmmss,SSSS", /\d\d\d\d\d\d,\d+/],
        ["HHmmss", /\d\d\d\d\d\d/],
        ["HHmm", /\d\d\d\d/],
        ["HH", /\d\d/]
      ], aspNetJsonRegex = /^\/?Date\((-?\d+)/i, rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/, obsOffsets = {
        UT: 0,
        GMT: 0,
        EDT: -4 * 60,
        EST: -5 * 60,
        CDT: -5 * 60,
        CST: -6 * 60,
        MDT: -6 * 60,
        MST: -7 * 60,
        PDT: -7 * 60,
        PST: -8 * 60
      };
      function configFromISO(config) {
        var i, l, string2 = config._i, match = extendedIsoRegex.exec(string2) || basicIsoRegex.exec(string2), allowTime, dateFormat, timeFormat, tzFormat;
        if (match) {
          getParsingFlags(config).iso = true;
          for (i = 0, l = isoDates.length; i < l; i++) {
            if (isoDates[i][1].exec(match[1])) {
              dateFormat = isoDates[i][0];
              allowTime = isoDates[i][2] !== false;
              break;
            }
          }
          if (dateFormat == null) {
            config._isValid = false;
            return;
          }
          if (match[3]) {
            for (i = 0, l = isoTimes.length; i < l; i++) {
              if (isoTimes[i][1].exec(match[3])) {
                timeFormat = (match[2] || " ") + isoTimes[i][0];
                break;
              }
            }
            if (timeFormat == null) {
              config._isValid = false;
              return;
            }
          }
          if (!allowTime && timeFormat != null) {
            config._isValid = false;
            return;
          }
          if (match[4]) {
            if (tzRegex.exec(match[4])) {
              tzFormat = "Z";
            } else {
              config._isValid = false;
              return;
            }
          }
          config._f = dateFormat + (timeFormat || "") + (tzFormat || "");
          configFromStringAndFormat(config);
        } else {
          config._isValid = false;
        }
      }
      function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
        var result = [
          untruncateYear(yearStr),
          defaultLocaleMonthsShort.indexOf(monthStr),
          parseInt(dayStr, 10),
          parseInt(hourStr, 10),
          parseInt(minuteStr, 10)
        ];
        if (secondStr) {
          result.push(parseInt(secondStr, 10));
        }
        return result;
      }
      function untruncateYear(yearStr) {
        var year = parseInt(yearStr, 10);
        if (year <= 49) {
          return 2e3 + year;
        } else if (year <= 999) {
          return 1900 + year;
        }
        return year;
      }
      function preprocessRFC2822(s) {
        return s.replace(/\([^)]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").replace(/^\s\s*/, "").replace(/\s\s*$/, "");
      }
      function checkWeekday(weekdayStr, parsedInput, config) {
        if (weekdayStr) {
          var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr), weekdayActual = new Date(
            parsedInput[0],
            parsedInput[1],
            parsedInput[2]
          ).getDay();
          if (weekdayProvided !== weekdayActual) {
            getParsingFlags(config).weekdayMismatch = true;
            config._isValid = false;
            return false;
          }
        }
        return true;
      }
      function calculateOffset(obsOffset, militaryOffset, numOffset) {
        if (obsOffset) {
          return obsOffsets[obsOffset];
        } else if (militaryOffset) {
          return 0;
        } else {
          var hm = parseInt(numOffset, 10), m = hm % 100, h = (hm - m) / 100;
          return h * 60 + m;
        }
      }
      function configFromRFC2822(config) {
        var match = rfc2822.exec(preprocessRFC2822(config._i)), parsedArray;
        if (match) {
          parsedArray = extractFromRFC2822Strings(
            match[4],
            match[3],
            match[2],
            match[5],
            match[6],
            match[7]
          );
          if (!checkWeekday(match[1], parsedArray, config)) {
            return;
          }
          config._a = parsedArray;
          config._tzm = calculateOffset(match[8], match[9], match[10]);
          config._d = createUTCDate.apply(null, config._a);
          config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
          getParsingFlags(config).rfc2822 = true;
        } else {
          config._isValid = false;
        }
      }
      function configFromString(config) {
        var matched = aspNetJsonRegex.exec(config._i);
        if (matched !== null) {
          config._d = new Date(+matched[1]);
          return;
        }
        configFromISO(config);
        if (config._isValid === false) {
          delete config._isValid;
        } else {
          return;
        }
        configFromRFC2822(config);
        if (config._isValid === false) {
          delete config._isValid;
        } else {
          return;
        }
        if (config._strict) {
          config._isValid = false;
        } else {
          hooks.createFromInputFallback(config);
        }
      }
      hooks.createFromInputFallback = deprecate(
        "value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.",
        function(config) {
          config._d = new Date(config._i + (config._useUTC ? " UTC" : ""));
        }
      );
      function defaults(a, b, c) {
        if (a != null) {
          return a;
        }
        if (b != null) {
          return b;
        }
        return c;
      }
      function currentDateArray(config) {
        var nowValue = new Date(hooks.now());
        if (config._useUTC) {
          return [
            nowValue.getUTCFullYear(),
            nowValue.getUTCMonth(),
            nowValue.getUTCDate()
          ];
        }
        return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
      }
      function configFromArray(config) {
        var i, date, input = [], currentDate, expectedWeekday, yearToUse;
        if (config._d) {
          return;
        }
        currentDate = currentDateArray(config);
        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
          dayOfYearFromWeekInfo(config);
        }
        if (config._dayOfYear != null) {
          yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);
          if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {
            getParsingFlags(config)._overflowDayOfYear = true;
          }
          date = createUTCDate(yearToUse, 0, config._dayOfYear);
          config._a[MONTH] = date.getUTCMonth();
          config._a[DATE] = date.getUTCDate();
        }
        for (i = 0; i < 3 && config._a[i] == null; ++i) {
          config._a[i] = input[i] = currentDate[i];
        }
        for (; i < 7; i++) {
          config._a[i] = input[i] = config._a[i] == null ? i === 2 ? 1 : 0 : config._a[i];
        }
        if (config._a[HOUR] === 24 && config._a[MINUTE] === 0 && config._a[SECOND] === 0 && config._a[MILLISECOND] === 0) {
          config._nextDay = true;
          config._a[HOUR] = 0;
        }
        config._d = (config._useUTC ? createUTCDate : createDate).apply(
          null,
          input
        );
        expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay();
        if (config._tzm != null) {
          config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
        }
        if (config._nextDay) {
          config._a[HOUR] = 24;
        }
        if (config._w && typeof config._w.d !== "undefined" && config._w.d !== expectedWeekday) {
          getParsingFlags(config).weekdayMismatch = true;
        }
      }
      function dayOfYearFromWeekInfo(config) {
        var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow, curWeek;
        w = config._w;
        if (w.GG != null || w.W != null || w.E != null) {
          dow = 1;
          doy = 4;
          weekYear = defaults(
            w.GG,
            config._a[YEAR],
            weekOfYear(createLocal(), 1, 4).year
          );
          week = defaults(w.W, 1);
          weekday = defaults(w.E, 1);
          if (weekday < 1 || weekday > 7) {
            weekdayOverflow = true;
          }
        } else {
          dow = config._locale._week.dow;
          doy = config._locale._week.doy;
          curWeek = weekOfYear(createLocal(), dow, doy);
          weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);
          week = defaults(w.w, curWeek.week);
          if (w.d != null) {
            weekday = w.d;
            if (weekday < 0 || weekday > 6) {
              weekdayOverflow = true;
            }
          } else if (w.e != null) {
            weekday = w.e + dow;
            if (w.e < 0 || w.e > 6) {
              weekdayOverflow = true;
            }
          } else {
            weekday = dow;
          }
        }
        if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
          getParsingFlags(config)._overflowWeeks = true;
        } else if (weekdayOverflow != null) {
          getParsingFlags(config)._overflowWeekday = true;
        } else {
          temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
          config._a[YEAR] = temp.year;
          config._dayOfYear = temp.dayOfYear;
        }
      }
      hooks.ISO_8601 = function() {
      };
      hooks.RFC_2822 = function() {
      };
      function configFromStringAndFormat(config) {
        if (config._f === hooks.ISO_8601) {
          configFromISO(config);
          return;
        }
        if (config._f === hooks.RFC_2822) {
          configFromRFC2822(config);
          return;
        }
        config._a = [];
        getParsingFlags(config).empty = true;
        var string2 = "" + config._i, i, parsedInput, tokens2, token2, skipped, stringLength = string2.length, totalParsedInputLength = 0, era;
        tokens2 = expandFormat(config._f, config._locale).match(formattingTokens) || [];
        for (i = 0; i < tokens2.length; i++) {
          token2 = tokens2[i];
          parsedInput = (string2.match(getParseRegexForToken(token2, config)) || [])[0];
          if (parsedInput) {
            skipped = string2.substr(0, string2.indexOf(parsedInput));
            if (skipped.length > 0) {
              getParsingFlags(config).unusedInput.push(skipped);
            }
            string2 = string2.slice(
              string2.indexOf(parsedInput) + parsedInput.length
            );
            totalParsedInputLength += parsedInput.length;
          }
          if (formatTokenFunctions[token2]) {
            if (parsedInput) {
              getParsingFlags(config).empty = false;
            } else {
              getParsingFlags(config).unusedTokens.push(token2);
            }
            addTimeToArrayFromToken(token2, parsedInput, config);
          } else if (config._strict && !parsedInput) {
            getParsingFlags(config).unusedTokens.push(token2);
          }
        }
        getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
        if (string2.length > 0) {
          getParsingFlags(config).unusedInput.push(string2);
        }
        if (config._a[HOUR] <= 12 && getParsingFlags(config).bigHour === true && config._a[HOUR] > 0) {
          getParsingFlags(config).bigHour = void 0;
        }
        getParsingFlags(config).parsedDateParts = config._a.slice(0);
        getParsingFlags(config).meridiem = config._meridiem;
        config._a[HOUR] = meridiemFixWrap(
          config._locale,
          config._a[HOUR],
          config._meridiem
        );
        era = getParsingFlags(config).era;
        if (era !== null) {
          config._a[YEAR] = config._locale.erasConvertYear(era, config._a[YEAR]);
        }
        configFromArray(config);
        checkOverflow(config);
      }
      function meridiemFixWrap(locale2, hour, meridiem2) {
        var isPm;
        if (meridiem2 == null) {
          return hour;
        }
        if (locale2.meridiemHour != null) {
          return locale2.meridiemHour(hour, meridiem2);
        } else if (locale2.isPM != null) {
          isPm = locale2.isPM(meridiem2);
          if (isPm && hour < 12) {
            hour += 12;
          }
          if (!isPm && hour === 12) {
            hour = 0;
          }
          return hour;
        } else {
          return hour;
        }
      }
      function configFromStringAndArray(config) {
        var tempConfig, bestMoment, scoreToBeat, i, currentScore, validFormatFound, bestFormatIsValid = false;
        if (config._f.length === 0) {
          getParsingFlags(config).invalidFormat = true;
          config._d = new Date(NaN);
          return;
        }
        for (i = 0; i < config._f.length; i++) {
          currentScore = 0;
          validFormatFound = false;
          tempConfig = copyConfig({}, config);
          if (config._useUTC != null) {
            tempConfig._useUTC = config._useUTC;
          }
          tempConfig._f = config._f[i];
          configFromStringAndFormat(tempConfig);
          if (isValid(tempConfig)) {
            validFormatFound = true;
          }
          currentScore += getParsingFlags(tempConfig).charsLeftOver;
          currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;
          getParsingFlags(tempConfig).score = currentScore;
          if (!bestFormatIsValid) {
            if (scoreToBeat == null || currentScore < scoreToBeat || validFormatFound) {
              scoreToBeat = currentScore;
              bestMoment = tempConfig;
              if (validFormatFound) {
                bestFormatIsValid = true;
              }
            }
          } else {
            if (currentScore < scoreToBeat) {
              scoreToBeat = currentScore;
              bestMoment = tempConfig;
            }
          }
        }
        extend(config, bestMoment || tempConfig);
      }
      function configFromObject(config) {
        if (config._d) {
          return;
        }
        var i = normalizeObjectUnits(config._i), dayOrDate = i.day === void 0 ? i.date : i.day;
        config._a = map2(
          [i.year, i.month, dayOrDate, i.hour, i.minute, i.second, i.millisecond],
          function(obj) {
            return obj && parseInt(obj, 10);
          }
        );
        configFromArray(config);
      }
      function createFromConfig(config) {
        var res = new Moment(checkOverflow(prepareConfig(config)));
        if (res._nextDay) {
          res.add(1, "d");
          res._nextDay = void 0;
        }
        return res;
      }
      function prepareConfig(config) {
        var input = config._i, format2 = config._f;
        config._locale = config._locale || getLocale(config._l);
        if (input === null || format2 === void 0 && input === "") {
          return createInvalid({ nullInput: true });
        }
        if (typeof input === "string") {
          config._i = input = config._locale.preparse(input);
        }
        if (isMoment(input)) {
          return new Moment(checkOverflow(input));
        } else if (isDate(input)) {
          config._d = input;
        } else if (isArray(format2)) {
          configFromStringAndArray(config);
        } else if (format2) {
          configFromStringAndFormat(config);
        } else {
          configFromInput(config);
        }
        if (!isValid(config)) {
          config._d = null;
        }
        return config;
      }
      function configFromInput(config) {
        var input = config._i;
        if (isUndefined(input)) {
          config._d = new Date(hooks.now());
        } else if (isDate(input)) {
          config._d = new Date(input.valueOf());
        } else if (typeof input === "string") {
          configFromString(config);
        } else if (isArray(input)) {
          config._a = map2(input.slice(0), function(obj) {
            return parseInt(obj, 10);
          });
          configFromArray(config);
        } else if (isObject(input)) {
          configFromObject(config);
        } else if (isNumber(input)) {
          config._d = new Date(input);
        } else {
          hooks.createFromInputFallback(config);
        }
      }
      function createLocalOrUTC(input, format2, locale2, strict, isUTC) {
        var c = {};
        if (format2 === true || format2 === false) {
          strict = format2;
          format2 = void 0;
        }
        if (locale2 === true || locale2 === false) {
          strict = locale2;
          locale2 = void 0;
        }
        if (isObject(input) && isObjectEmpty(input) || isArray(input) && input.length === 0) {
          input = void 0;
        }
        c._isAMomentObject = true;
        c._useUTC = c._isUTC = isUTC;
        c._l = locale2;
        c._i = input;
        c._f = format2;
        c._strict = strict;
        return createFromConfig(c);
      }
      function createLocal(input, format2, locale2, strict) {
        return createLocalOrUTC(input, format2, locale2, strict, false);
      }
      var prototypeMin = deprecate(
        "moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/",
        function() {
          var other = createLocal.apply(null, arguments);
          if (this.isValid() && other.isValid()) {
            return other < this ? this : other;
          } else {
            return createInvalid();
          }
        }
      ), prototypeMax = deprecate(
        "moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/",
        function() {
          var other = createLocal.apply(null, arguments);
          if (this.isValid() && other.isValid()) {
            return other > this ? this : other;
          } else {
            return createInvalid();
          }
        }
      );
      function pickBy(fn, moments) {
        var res, i;
        if (moments.length === 1 && isArray(moments[0])) {
          moments = moments[0];
        }
        if (!moments.length) {
          return createLocal();
        }
        res = moments[0];
        for (i = 1; i < moments.length; ++i) {
          if (!moments[i].isValid() || moments[i][fn](res)) {
            res = moments[i];
          }
        }
        return res;
      }
      function min() {
        var args = [].slice.call(arguments, 0);
        return pickBy("isBefore", args);
      }
      function max() {
        var args = [].slice.call(arguments, 0);
        return pickBy("isAfter", args);
      }
      var now = function() {
        return Date.now ? Date.now() : +new Date();
      };
      var ordering = [
        "year",
        "quarter",
        "month",
        "week",
        "day",
        "hour",
        "minute",
        "second",
        "millisecond"
      ];
      function isDurationValid(m) {
        var key, unitHasDecimal = false, i;
        for (key in m) {
          if (hasOwnProp(m, key) && !(indexOf.call(ordering, key) !== -1 && (m[key] == null || !isNaN(m[key])))) {
            return false;
          }
        }
        for (i = 0; i < ordering.length; ++i) {
          if (m[ordering[i]]) {
            if (unitHasDecimal) {
              return false;
            }
            if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
              unitHasDecimal = true;
            }
          }
        }
        return true;
      }
      function isValid$1() {
        return this._isValid;
      }
      function createInvalid$1() {
        return createDuration(NaN);
      }
      function Duration(duration) {
        var normalizedInput = normalizeObjectUnits(duration), years2 = normalizedInput.year || 0, quarters = normalizedInput.quarter || 0, months2 = normalizedInput.month || 0, weeks2 = normalizedInput.week || normalizedInput.isoWeek || 0, days2 = normalizedInput.day || 0, hours2 = normalizedInput.hour || 0, minutes2 = normalizedInput.minute || 0, seconds2 = normalizedInput.second || 0, milliseconds2 = normalizedInput.millisecond || 0;
        this._isValid = isDurationValid(normalizedInput);
        this._milliseconds = +milliseconds2 + seconds2 * 1e3 + // 1000
        minutes2 * 6e4 + // 1000 * 60
        hours2 * 1e3 * 60 * 60;
        this._days = +days2 + weeks2 * 7;
        this._months = +months2 + quarters * 3 + years2 * 12;
        this._data = {};
        this._locale = getLocale();
        this._bubble();
      }
      function isDuration(obj) {
        return obj instanceof Duration;
      }
      function absRound(number) {
        if (number < 0) {
          return Math.round(-1 * number) * -1;
        } else {
          return Math.round(number);
        }
      }
      function compareArrays(array1, array2, dontConvert) {
        var len = Math.min(array1.length, array2.length), lengthDiff = Math.abs(array1.length - array2.length), diffs = 0, i;
        for (i = 0; i < len; i++) {
          if (dontConvert && array1[i] !== array2[i] || !dontConvert && toInt(array1[i]) !== toInt(array2[i])) {
            diffs++;
          }
        }
        return diffs + lengthDiff;
      }
      function offset(token2, separator) {
        addFormatToken(token2, 0, 0, function() {
          var offset2 = this.utcOffset(), sign2 = "+";
          if (offset2 < 0) {
            offset2 = -offset2;
            sign2 = "-";
          }
          return sign2 + zeroFill(~~(offset2 / 60), 2) + separator + zeroFill(~~offset2 % 60, 2);
        });
      }
      offset("Z", ":");
      offset("ZZ", "");
      addRegexToken("Z", matchShortOffset);
      addRegexToken("ZZ", matchShortOffset);
      addParseToken(["Z", "ZZ"], function(input, array, config) {
        config._useUTC = true;
        config._tzm = offsetFromString(matchShortOffset, input);
      });
      var chunkOffset = /([\+\-]|\d\d)/gi;
      function offsetFromString(matcher, string2) {
        var matches = (string2 || "").match(matcher), chunk, parts, minutes2;
        if (matches === null) {
          return null;
        }
        chunk = matches[matches.length - 1] || [];
        parts = (chunk + "").match(chunkOffset) || ["-", 0, 0];
        minutes2 = +(parts[1] * 60) + toInt(parts[2]);
        return minutes2 === 0 ? 0 : parts[0] === "+" ? minutes2 : -minutes2;
      }
      function cloneWithOffset(input, model) {
        var res, diff2;
        if (model._isUTC) {
          res = model.clone();
          diff2 = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
          res._d.setTime(res._d.valueOf() + diff2);
          hooks.updateOffset(res, false);
          return res;
        } else {
          return createLocal(input).local();
        }
      }
      function getDateOffset(m) {
        return -Math.round(m._d.getTimezoneOffset());
      }
      hooks.updateOffset = function() {
      };
      function getSetOffset(input, keepLocalTime, keepMinutes) {
        var offset2 = this._offset || 0, localAdjust;
        if (!this.isValid()) {
          return input != null ? this : NaN;
        }
        if (input != null) {
          if (typeof input === "string") {
            input = offsetFromString(matchShortOffset, input);
            if (input === null) {
              return this;
            }
          } else if (Math.abs(input) < 16 && !keepMinutes) {
            input = input * 60;
          }
          if (!this._isUTC && keepLocalTime) {
            localAdjust = getDateOffset(this);
          }
          this._offset = input;
          this._isUTC = true;
          if (localAdjust != null) {
            this.add(localAdjust, "m");
          }
          if (offset2 !== input) {
            if (!keepLocalTime || this._changeInProgress) {
              addSubtract(
                this,
                createDuration(input - offset2, "m"),
                1,
                false
              );
            } else if (!this._changeInProgress) {
              this._changeInProgress = true;
              hooks.updateOffset(this, true);
              this._changeInProgress = null;
            }
          }
          return this;
        } else {
          return this._isUTC ? offset2 : getDateOffset(this);
        }
      }
      function getSetZone(input, keepLocalTime) {
        if (input != null) {
          if (typeof input !== "string") {
            input = -input;
          }
          this.utcOffset(input, keepLocalTime);
          return this;
        } else {
          return -this.utcOffset();
        }
      }
      function setOffsetToUTC(keepLocalTime) {
        return this.utcOffset(0, keepLocalTime);
      }
      function setOffsetToLocal(keepLocalTime) {
        if (this._isUTC) {
          this.utcOffset(0, keepLocalTime);
          this._isUTC = false;
          if (keepLocalTime) {
            this.subtract(getDateOffset(this), "m");
          }
        }
        return this;
      }
      function setOffsetToParsedOffset() {
        if (this._tzm != null) {
          this.utcOffset(this._tzm, false, true);
        } else if (typeof this._i === "string") {
          var tZone = offsetFromString(matchOffset, this._i);
          if (tZone != null) {
            this.utcOffset(tZone);
          } else {
            this.utcOffset(0, true);
          }
        }
        return this;
      }
      function hasAlignedHourOffset(input) {
        if (!this.isValid()) {
          return false;
        }
        input = input ? createLocal(input).utcOffset() : 0;
        return (this.utcOffset() - input) % 60 === 0;
      }
      function isDaylightSavingTime() {
        return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();
      }
      function isDaylightSavingTimeShifted() {
        if (!isUndefined(this._isDSTShifted)) {
          return this._isDSTShifted;
        }
        var c = {}, other;
        copyConfig(c, this);
        c = prepareConfig(c);
        if (c._a) {
          other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
          this._isDSTShifted = this.isValid() && compareArrays(c._a, other.toArray()) > 0;
        } else {
          this._isDSTShifted = false;
        }
        return this._isDSTShifted;
      }
      function isLocal() {
        return this.isValid() ? !this._isUTC : false;
      }
      function isUtcOffset() {
        return this.isValid() ? this._isUTC : false;
      }
      function isUtc() {
        return this.isValid() ? this._isUTC && this._offset === 0 : false;
      }
      var aspNetRegex = /^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)?)?$/, isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
      function createDuration(input, key) {
        var duration = input, match = null, sign2, ret, diffRes;
        if (isDuration(input)) {
          duration = {
            ms: input._milliseconds,
            d: input._days,
            M: input._months
          };
        } else if (isNumber(input) || !isNaN(+input)) {
          duration = {};
          if (key) {
            duration[key] = +input;
          } else {
            duration.milliseconds = +input;
          }
        } else if (match = aspNetRegex.exec(input)) {
          sign2 = match[1] === "-" ? -1 : 1;
          duration = {
            y: 0,
            d: toInt(match[DATE]) * sign2,
            h: toInt(match[HOUR]) * sign2,
            m: toInt(match[MINUTE]) * sign2,
            s: toInt(match[SECOND]) * sign2,
            ms: toInt(absRound(match[MILLISECOND] * 1e3)) * sign2
            // the millisecond decimal point is included in the match
          };
        } else if (match = isoRegex.exec(input)) {
          sign2 = match[1] === "-" ? -1 : 1;
          duration = {
            y: parseIso(match[2], sign2),
            M: parseIso(match[3], sign2),
            w: parseIso(match[4], sign2),
            d: parseIso(match[5], sign2),
            h: parseIso(match[6], sign2),
            m: parseIso(match[7], sign2),
            s: parseIso(match[8], sign2)
          };
        } else if (duration == null) {
          duration = {};
        } else if (typeof duration === "object" && ("from" in duration || "to" in duration)) {
          diffRes = momentsDifference(
            createLocal(duration.from),
            createLocal(duration.to)
          );
          duration = {};
          duration.ms = diffRes.milliseconds;
          duration.M = diffRes.months;
        }
        ret = new Duration(duration);
        if (isDuration(input) && hasOwnProp(input, "_locale")) {
          ret._locale = input._locale;
        }
        if (isDuration(input) && hasOwnProp(input, "_isValid")) {
          ret._isValid = input._isValid;
        }
        return ret;
      }
      createDuration.fn = Duration.prototype;
      createDuration.invalid = createInvalid$1;
      function parseIso(inp, sign2) {
        var res = inp && parseFloat(inp.replace(",", "."));
        return (isNaN(res) ? 0 : res) * sign2;
      }
      function positiveMomentsDifference(base, other) {
        var res = {};
        res.months = other.month() - base.month() + (other.year() - base.year()) * 12;
        if (base.clone().add(res.months, "M").isAfter(other)) {
          --res.months;
        }
        res.milliseconds = +other - +base.clone().add(res.months, "M");
        return res;
      }
      function momentsDifference(base, other) {
        var res;
        if (!(base.isValid() && other.isValid())) {
          return { milliseconds: 0, months: 0 };
        }
        other = cloneWithOffset(other, base);
        if (base.isBefore(other)) {
          res = positiveMomentsDifference(base, other);
        } else {
          res = positiveMomentsDifference(other, base);
          res.milliseconds = -res.milliseconds;
          res.months = -res.months;
        }
        return res;
      }
      function createAdder(direction, name) {
        return function(val, period) {
          var dur, tmp;
          if (period !== null && !isNaN(+period)) {
            deprecateSimple(
              name,
              "moment()." + name + "(period, number) is deprecated. Please use moment()." + name + "(number, period). See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info."
            );
            tmp = val;
            val = period;
            period = tmp;
          }
          dur = createDuration(val, period);
          addSubtract(this, dur, direction);
          return this;
        };
      }
      function addSubtract(mom, duration, isAdding, updateOffset) {
        var milliseconds2 = duration._milliseconds, days2 = absRound(duration._days), months2 = absRound(duration._months);
        if (!mom.isValid()) {
          return;
        }
        updateOffset = updateOffset == null ? true : updateOffset;
        if (months2) {
          setMonth(mom, get(mom, "Month") + months2 * isAdding);
        }
        if (days2) {
          set$1(mom, "Date", get(mom, "Date") + days2 * isAdding);
        }
        if (milliseconds2) {
          mom._d.setTime(mom._d.valueOf() + milliseconds2 * isAdding);
        }
        if (updateOffset) {
          hooks.updateOffset(mom, days2 || months2);
        }
      }
      var add = createAdder(1, "add"), subtract = createAdder(-1, "subtract");
      function isString(input) {
        return typeof input === "string" || input instanceof String;
      }
      function isMomentInput(input) {
        return isMoment(input) || isDate(input) || isString(input) || isNumber(input) || isNumberOrStringArray(input) || isMomentInputObject(input) || input === null || input === void 0;
      }
      function isMomentInputObject(input) {
        var objectTest = isObject(input) && !isObjectEmpty(input), propertyTest = false, properties = [
          "years",
          "year",
          "y",
          "months",
          "month",
          "M",
          "days",
          "day",
          "d",
          "dates",
          "date",
          "D",
          "hours",
          "hour",
          "h",
          "minutes",
          "minute",
          "m",
          "seconds",
          "second",
          "s",
          "milliseconds",
          "millisecond",
          "ms"
        ], i, property;
        for (i = 0; i < properties.length; i += 1) {
          property = properties[i];
          propertyTest = propertyTest || hasOwnProp(input, property);
        }
        return objectTest && propertyTest;
      }
      function isNumberOrStringArray(input) {
        var arrayTest = isArray(input), dataTypeTest = false;
        if (arrayTest) {
          dataTypeTest = input.filter(function(item) {
            return !isNumber(item) && isString(input);
          }).length === 0;
        }
        return arrayTest && dataTypeTest;
      }
      function isCalendarSpec(input) {
        var objectTest = isObject(input) && !isObjectEmpty(input), propertyTest = false, properties = [
          "sameDay",
          "nextDay",
          "lastDay",
          "nextWeek",
          "lastWeek",
          "sameElse"
        ], i, property;
        for (i = 0; i < properties.length; i += 1) {
          property = properties[i];
          propertyTest = propertyTest || hasOwnProp(input, property);
        }
        return objectTest && propertyTest;
      }
      function getCalendarFormat(myMoment, now2) {
        var diff2 = myMoment.diff(now2, "days", true);
        return diff2 < -6 ? "sameElse" : diff2 < -1 ? "lastWeek" : diff2 < 0 ? "lastDay" : diff2 < 1 ? "sameDay" : diff2 < 2 ? "nextDay" : diff2 < 7 ? "nextWeek" : "sameElse";
      }
      function calendar$1(time, formats) {
        if (arguments.length === 1) {
          if (!arguments[0]) {
            time = void 0;
            formats = void 0;
          } else if (isMomentInput(arguments[0])) {
            time = arguments[0];
            formats = void 0;
          } else if (isCalendarSpec(arguments[0])) {
            formats = arguments[0];
            time = void 0;
          }
        }
        var now2 = time || createLocal(), sod = cloneWithOffset(now2, this).startOf("day"), format2 = hooks.calendarFormat(this, sod) || "sameElse", output = formats && (isFunction(formats[format2]) ? formats[format2].call(this, now2) : formats[format2]);
        return this.format(
          output || this.localeData().calendar(format2, this, createLocal(now2))
        );
      }
      function clone() {
        return new Moment(this);
      }
      function isAfter(input, units) {
        var localInput = isMoment(input) ? input : createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
          return false;
        }
        units = normalizeUnits(units) || "millisecond";
        if (units === "millisecond") {
          return this.valueOf() > localInput.valueOf();
        } else {
          return localInput.valueOf() < this.clone().startOf(units).valueOf();
        }
      }
      function isBefore(input, units) {
        var localInput = isMoment(input) ? input : createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
          return false;
        }
        units = normalizeUnits(units) || "millisecond";
        if (units === "millisecond") {
          return this.valueOf() < localInput.valueOf();
        } else {
          return this.clone().endOf(units).valueOf() < localInput.valueOf();
        }
      }
      function isBetween(from2, to2, units, inclusivity) {
        var localFrom = isMoment(from2) ? from2 : createLocal(from2), localTo = isMoment(to2) ? to2 : createLocal(to2);
        if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
          return false;
        }
        inclusivity = inclusivity || "()";
        return (inclusivity[0] === "(" ? this.isAfter(localFrom, units) : !this.isBefore(localFrom, units)) && (inclusivity[1] === ")" ? this.isBefore(localTo, units) : !this.isAfter(localTo, units));
      }
      function isSame(input, units) {
        var localInput = isMoment(input) ? input : createLocal(input), inputMs;
        if (!(this.isValid() && localInput.isValid())) {
          return false;
        }
        units = normalizeUnits(units) || "millisecond";
        if (units === "millisecond") {
          return this.valueOf() === localInput.valueOf();
        } else {
          inputMs = localInput.valueOf();
          return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
        }
      }
      function isSameOrAfter(input, units) {
        return this.isSame(input, units) || this.isAfter(input, units);
      }
      function isSameOrBefore(input, units) {
        return this.isSame(input, units) || this.isBefore(input, units);
      }
      function diff(input, units, asFloat) {
        var that, zoneDelta, output;
        if (!this.isValid()) {
          return NaN;
        }
        that = cloneWithOffset(input, this);
        if (!that.isValid()) {
          return NaN;
        }
        zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;
        units = normalizeUnits(units);
        switch (units) {
          case "year":
            output = monthDiff(this, that) / 12;
            break;
          case "month":
            output = monthDiff(this, that);
            break;
          case "quarter":
            output = monthDiff(this, that) / 3;
            break;
          case "second":
            output = (this - that) / 1e3;
            break;
          case "minute":
            output = (this - that) / 6e4;
            break;
          case "hour":
            output = (this - that) / 36e5;
            break;
          case "day":
            output = (this - that - zoneDelta) / 864e5;
            break;
          case "week":
            output = (this - that - zoneDelta) / 6048e5;
            break;
          default:
            output = this - that;
        }
        return asFloat ? output : absFloor(output);
      }
      function monthDiff(a, b) {
        if (a.date() < b.date()) {
          return -monthDiff(b, a);
        }
        var wholeMonthDiff = (b.year() - a.year()) * 12 + (b.month() - a.month()), anchor = a.clone().add(wholeMonthDiff, "months"), anchor2, adjust;
        if (b - anchor < 0) {
          anchor2 = a.clone().add(wholeMonthDiff - 1, "months");
          adjust = (b - anchor) / (anchor - anchor2);
        } else {
          anchor2 = a.clone().add(wholeMonthDiff + 1, "months");
          adjust = (b - anchor) / (anchor2 - anchor);
        }
        return -(wholeMonthDiff + adjust) || 0;
      }
      hooks.defaultFormat = "YYYY-MM-DDTHH:mm:ssZ";
      hooks.defaultFormatUtc = "YYYY-MM-DDTHH:mm:ss[Z]";
      function toString() {
        return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
      }
      function toISOString(keepOffset) {
        if (!this.isValid()) {
          return null;
        }
        var utc = keepOffset !== true, m = utc ? this.clone().utc() : this;
        if (m.year() < 0 || m.year() > 9999) {
          return formatMoment(
            m,
            utc ? "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYYYY-MM-DD[T]HH:mm:ss.SSSZ"
          );
        }
        if (isFunction(Date.prototype.toISOString)) {
          if (utc) {
            return this.toDate().toISOString();
          } else {
            return new Date(this.valueOf() + this.utcOffset() * 60 * 1e3).toISOString().replace("Z", formatMoment(m, "Z"));
          }
        }
        return formatMoment(
          m,
          utc ? "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYY-MM-DD[T]HH:mm:ss.SSSZ"
        );
      }
      function inspect() {
        if (!this.isValid()) {
          return "moment.invalid(/* " + this._i + " */)";
        }
        var func = "moment", zone = "", prefix, year, datetime, suffix;
        if (!this.isLocal()) {
          func = this.utcOffset() === 0 ? "moment.utc" : "moment.parseZone";
          zone = "Z";
        }
        prefix = "[" + func + '("]';
        year = 0 <= this.year() && this.year() <= 9999 ? "YYYY" : "YYYYYY";
        datetime = "-MM-DD[T]HH:mm:ss.SSS";
        suffix = zone + '[")]';
        return this.format(prefix + year + datetime + suffix);
      }
      function format(inputString) {
        if (!inputString) {
          inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
        }
        var output = formatMoment(this, inputString);
        return this.localeData().postformat(output);
      }
      function from(time, withoutSuffix) {
        if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
          return createDuration({ to: this, from: time }).locale(this.locale()).humanize(!withoutSuffix);
        } else {
          return this.localeData().invalidDate();
        }
      }
      function fromNow(withoutSuffix) {
        return this.from(createLocal(), withoutSuffix);
      }
      function to(time, withoutSuffix) {
        if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
          return createDuration({ from: this, to: time }).locale(this.locale()).humanize(!withoutSuffix);
        } else {
          return this.localeData().invalidDate();
        }
      }
      function toNow(withoutSuffix) {
        return this.to(createLocal(), withoutSuffix);
      }
      function locale(key) {
        var newLocaleData;
        if (key === void 0) {
          return this._locale._abbr;
        } else {
          newLocaleData = getLocale(key);
          if (newLocaleData != null) {
            this._locale = newLocaleData;
          }
          return this;
        }
      }
      var lang = deprecate(
        "moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.",
        function(key) {
          if (key === void 0) {
            return this.localeData();
          } else {
            return this.locale(key);
          }
        }
      );
      function localeData() {
        return this._locale;
      }
      var MS_PER_SECOND = 1e3, MS_PER_MINUTE = 60 * MS_PER_SECOND, MS_PER_HOUR = 60 * MS_PER_MINUTE, MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;
      function mod$1(dividend, divisor) {
        return (dividend % divisor + divisor) % divisor;
      }
      function localStartOfDate(y, m, d) {
        if (y < 100 && y >= 0) {
          return new Date(y + 400, m, d) - MS_PER_400_YEARS;
        } else {
          return new Date(y, m, d).valueOf();
        }
      }
      function utcStartOfDate(y, m, d) {
        if (y < 100 && y >= 0) {
          return Date.UTC(y + 400, m, d) - MS_PER_400_YEARS;
        } else {
          return Date.UTC(y, m, d);
        }
      }
      function startOf(units) {
        var time, startOfDate;
        units = normalizeUnits(units);
        if (units === void 0 || units === "millisecond" || !this.isValid()) {
          return this;
        }
        startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
        switch (units) {
          case "year":
            time = startOfDate(this.year(), 0, 1);
            break;
          case "quarter":
            time = startOfDate(
              this.year(),
              this.month() - this.month() % 3,
              1
            );
            break;
          case "month":
            time = startOfDate(this.year(), this.month(), 1);
            break;
          case "week":
            time = startOfDate(
              this.year(),
              this.month(),
              this.date() - this.weekday()
            );
            break;
          case "isoWeek":
            time = startOfDate(
              this.year(),
              this.month(),
              this.date() - (this.isoWeekday() - 1)
            );
            break;
          case "day":
          case "date":
            time = startOfDate(this.year(), this.month(), this.date());
            break;
          case "hour":
            time = this._d.valueOf();
            time -= mod$1(
              time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
              MS_PER_HOUR
            );
            break;
          case "minute":
            time = this._d.valueOf();
            time -= mod$1(time, MS_PER_MINUTE);
            break;
          case "second":
            time = this._d.valueOf();
            time -= mod$1(time, MS_PER_SECOND);
            break;
        }
        this._d.setTime(time);
        hooks.updateOffset(this, true);
        return this;
      }
      function endOf(units) {
        var time, startOfDate;
        units = normalizeUnits(units);
        if (units === void 0 || units === "millisecond" || !this.isValid()) {
          return this;
        }
        startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
        switch (units) {
          case "year":
            time = startOfDate(this.year() + 1, 0, 1) - 1;
            break;
          case "quarter":
            time = startOfDate(
              this.year(),
              this.month() - this.month() % 3 + 3,
              1
            ) - 1;
            break;
          case "month":
            time = startOfDate(this.year(), this.month() + 1, 1) - 1;
            break;
          case "week":
            time = startOfDate(
              this.year(),
              this.month(),
              this.date() - this.weekday() + 7
            ) - 1;
            break;
          case "isoWeek":
            time = startOfDate(
              this.year(),
              this.month(),
              this.date() - (this.isoWeekday() - 1) + 7
            ) - 1;
            break;
          case "day":
          case "date":
            time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
            break;
          case "hour":
            time = this._d.valueOf();
            time += MS_PER_HOUR - mod$1(
              time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
              MS_PER_HOUR
            ) - 1;
            break;
          case "minute":
            time = this._d.valueOf();
            time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
            break;
          case "second":
            time = this._d.valueOf();
            time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
            break;
        }
        this._d.setTime(time);
        hooks.updateOffset(this, true);
        return this;
      }
      function valueOf() {
        return this._d.valueOf() - (this._offset || 0) * 6e4;
      }
      function unix() {
        return Math.floor(this.valueOf() / 1e3);
      }
      function toDate() {
        return new Date(this.valueOf());
      }
      function toArray() {
        var m = this;
        return [
          m.year(),
          m.month(),
          m.date(),
          m.hour(),
          m.minute(),
          m.second(),
          m.millisecond()
        ];
      }
      function toObject() {
        var m = this;
        return {
          years: m.year(),
          months: m.month(),
          date: m.date(),
          hours: m.hours(),
          minutes: m.minutes(),
          seconds: m.seconds(),
          milliseconds: m.milliseconds()
        };
      }
      function toJSON() {
        return this.isValid() ? this.toISOString() : null;
      }
      function isValid$2() {
        return isValid(this);
      }
      function parsingFlags() {
        return extend({}, getParsingFlags(this));
      }
      function invalidAt() {
        return getParsingFlags(this).overflow;
      }
      function creationData() {
        return {
          input: this._i,
          format: this._f,
          locale: this._locale,
          isUTC: this._isUTC,
          strict: this._strict
        };
      }
      addFormatToken("N", 0, 0, "eraAbbr");
      addFormatToken("NN", 0, 0, "eraAbbr");
      addFormatToken("NNN", 0, 0, "eraAbbr");
      addFormatToken("NNNN", 0, 0, "eraName");
      addFormatToken("NNNNN", 0, 0, "eraNarrow");
      addFormatToken("y", ["y", 1], "yo", "eraYear");
      addFormatToken("y", ["yy", 2], 0, "eraYear");
      addFormatToken("y", ["yyy", 3], 0, "eraYear");
      addFormatToken("y", ["yyyy", 4], 0, "eraYear");
      addRegexToken("N", matchEraAbbr);
      addRegexToken("NN", matchEraAbbr);
      addRegexToken("NNN", matchEraAbbr);
      addRegexToken("NNNN", matchEraName);
      addRegexToken("NNNNN", matchEraNarrow);
      addParseToken(["N", "NN", "NNN", "NNNN", "NNNNN"], function(input, array, config, token2) {
        var era = config._locale.erasParse(input, token2, config._strict);
        if (era) {
          getParsingFlags(config).era = era;
        } else {
          getParsingFlags(config).invalidEra = input;
        }
      });
      addRegexToken("y", matchUnsigned);
      addRegexToken("yy", matchUnsigned);
      addRegexToken("yyy", matchUnsigned);
      addRegexToken("yyyy", matchUnsigned);
      addRegexToken("yo", matchEraYearOrdinal);
      addParseToken(["y", "yy", "yyy", "yyyy"], YEAR);
      addParseToken(["yo"], function(input, array, config, token2) {
        var match;
        if (config._locale._eraYearOrdinalRegex) {
          match = input.match(config._locale._eraYearOrdinalRegex);
        }
        if (config._locale.eraYearOrdinalParse) {
          array[YEAR] = config._locale.eraYearOrdinalParse(input, match);
        } else {
          array[YEAR] = parseInt(input, 10);
        }
      });
      function localeEras(m, format2) {
        var i, l, date, eras = this._eras || getLocale("en")._eras;
        for (i = 0, l = eras.length; i < l; ++i) {
          switch (typeof eras[i].since) {
            case "string":
              date = hooks(eras[i].since).startOf("day");
              eras[i].since = date.valueOf();
              break;
          }
          switch (typeof eras[i].until) {
            case "undefined":
              eras[i].until = Infinity;
              break;
            case "string":
              date = hooks(eras[i].until).startOf("day").valueOf();
              eras[i].until = date.valueOf();
              break;
          }
        }
        return eras;
      }
      function localeErasParse(eraName, format2, strict) {
        var i, l, eras = this.eras(), name, abbr, narrow;
        eraName = eraName.toUpperCase();
        for (i = 0, l = eras.length; i < l; ++i) {
          name = eras[i].name.toUpperCase();
          abbr = eras[i].abbr.toUpperCase();
          narrow = eras[i].narrow.toUpperCase();
          if (strict) {
            switch (format2) {
              case "N":
              case "NN":
              case "NNN":
                if (abbr === eraName) {
                  return eras[i];
                }
                break;
              case "NNNN":
                if (name === eraName) {
                  return eras[i];
                }
                break;
              case "NNNNN":
                if (narrow === eraName) {
                  return eras[i];
                }
                break;
            }
          } else if ([name, abbr, narrow].indexOf(eraName) >= 0) {
            return eras[i];
          }
        }
      }
      function localeErasConvertYear(era, year) {
        var dir = era.since <= era.until ? 1 : -1;
        if (year === void 0) {
          return hooks(era.since).year();
        } else {
          return hooks(era.since).year() + (year - era.offset) * dir;
        }
      }
      function getEraName() {
        var i, l, val, eras = this.localeData().eras();
        for (i = 0, l = eras.length; i < l; ++i) {
          val = this.clone().startOf("day").valueOf();
          if (eras[i].since <= val && val <= eras[i].until) {
            return eras[i].name;
          }
          if (eras[i].until <= val && val <= eras[i].since) {
            return eras[i].name;
          }
        }
        return "";
      }
      function getEraNarrow() {
        var i, l, val, eras = this.localeData().eras();
        for (i = 0, l = eras.length; i < l; ++i) {
          val = this.clone().startOf("day").valueOf();
          if (eras[i].since <= val && val <= eras[i].until) {
            return eras[i].narrow;
          }
          if (eras[i].until <= val && val <= eras[i].since) {
            return eras[i].narrow;
          }
        }
        return "";
      }
      function getEraAbbr() {
        var i, l, val, eras = this.localeData().eras();
        for (i = 0, l = eras.length; i < l; ++i) {
          val = this.clone().startOf("day").valueOf();
          if (eras[i].since <= val && val <= eras[i].until) {
            return eras[i].abbr;
          }
          if (eras[i].until <= val && val <= eras[i].since) {
            return eras[i].abbr;
          }
        }
        return "";
      }
      function getEraYear() {
        var i, l, dir, val, eras = this.localeData().eras();
        for (i = 0, l = eras.length; i < l; ++i) {
          dir = eras[i].since <= eras[i].until ? 1 : -1;
          val = this.clone().startOf("day").valueOf();
          if (eras[i].since <= val && val <= eras[i].until || eras[i].until <= val && val <= eras[i].since) {
            return (this.year() - hooks(eras[i].since).year()) * dir + eras[i].offset;
          }
        }
        return this.year();
      }
      function erasNameRegex(isStrict) {
        if (!hasOwnProp(this, "_erasNameRegex")) {
          computeErasParse.call(this);
        }
        return isStrict ? this._erasNameRegex : this._erasRegex;
      }
      function erasAbbrRegex(isStrict) {
        if (!hasOwnProp(this, "_erasAbbrRegex")) {
          computeErasParse.call(this);
        }
        return isStrict ? this._erasAbbrRegex : this._erasRegex;
      }
      function erasNarrowRegex(isStrict) {
        if (!hasOwnProp(this, "_erasNarrowRegex")) {
          computeErasParse.call(this);
        }
        return isStrict ? this._erasNarrowRegex : this._erasRegex;
      }
      function matchEraAbbr(isStrict, locale2) {
        return locale2.erasAbbrRegex(isStrict);
      }
      function matchEraName(isStrict, locale2) {
        return locale2.erasNameRegex(isStrict);
      }
      function matchEraNarrow(isStrict, locale2) {
        return locale2.erasNarrowRegex(isStrict);
      }
      function matchEraYearOrdinal(isStrict, locale2) {
        return locale2._eraYearOrdinalRegex || matchUnsigned;
      }
      function computeErasParse() {
        var abbrPieces = [], namePieces = [], narrowPieces = [], mixedPieces = [], i, l, eras = this.eras();
        for (i = 0, l = eras.length; i < l; ++i) {
          namePieces.push(regexEscape(eras[i].name));
          abbrPieces.push(regexEscape(eras[i].abbr));
          narrowPieces.push(regexEscape(eras[i].narrow));
          mixedPieces.push(regexEscape(eras[i].name));
          mixedPieces.push(regexEscape(eras[i].abbr));
          mixedPieces.push(regexEscape(eras[i].narrow));
        }
        this._erasRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
        this._erasNameRegex = new RegExp("^(" + namePieces.join("|") + ")", "i");
        this._erasAbbrRegex = new RegExp("^(" + abbrPieces.join("|") + ")", "i");
        this._erasNarrowRegex = new RegExp(
          "^(" + narrowPieces.join("|") + ")",
          "i"
        );
      }
      addFormatToken(0, ["gg", 2], 0, function() {
        return this.weekYear() % 100;
      });
      addFormatToken(0, ["GG", 2], 0, function() {
        return this.isoWeekYear() % 100;
      });
      function addWeekYearFormatToken(token2, getter) {
        addFormatToken(0, [token2, token2.length], 0, getter);
      }
      addWeekYearFormatToken("gggg", "weekYear");
      addWeekYearFormatToken("ggggg", "weekYear");
      addWeekYearFormatToken("GGGG", "isoWeekYear");
      addWeekYearFormatToken("GGGGG", "isoWeekYear");
      addUnitAlias("weekYear", "gg");
      addUnitAlias("isoWeekYear", "GG");
      addUnitPriority("weekYear", 1);
      addUnitPriority("isoWeekYear", 1);
      addRegexToken("G", matchSigned);
      addRegexToken("g", matchSigned);
      addRegexToken("GG", match1to2, match2);
      addRegexToken("gg", match1to2, match2);
      addRegexToken("GGGG", match1to4, match4);
      addRegexToken("gggg", match1to4, match4);
      addRegexToken("GGGGG", match1to6, match6);
      addRegexToken("ggggg", match1to6, match6);
      addWeekParseToken(["gggg", "ggggg", "GGGG", "GGGGG"], function(input, week, config, token2) {
        week[token2.substr(0, 2)] = toInt(input);
      });
      addWeekParseToken(["gg", "GG"], function(input, week, config, token2) {
        week[token2] = hooks.parseTwoDigitYear(input);
      });
      function getSetWeekYear(input) {
        return getSetWeekYearHelper.call(
          this,
          input,
          this.week(),
          this.weekday(),
          this.localeData()._week.dow,
          this.localeData()._week.doy
        );
      }
      function getSetISOWeekYear(input) {
        return getSetWeekYearHelper.call(
          this,
          input,
          this.isoWeek(),
          this.isoWeekday(),
          1,
          4
        );
      }
      function getISOWeeksInYear() {
        return weeksInYear(this.year(), 1, 4);
      }
      function getISOWeeksInISOWeekYear() {
        return weeksInYear(this.isoWeekYear(), 1, 4);
      }
      function getWeeksInYear() {
        var weekInfo = this.localeData()._week;
        return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
      }
      function getWeeksInWeekYear() {
        var weekInfo = this.localeData()._week;
        return weeksInYear(this.weekYear(), weekInfo.dow, weekInfo.doy);
      }
      function getSetWeekYearHelper(input, week, weekday, dow, doy) {
        var weeksTarget;
        if (input == null) {
          return weekOfYear(this, dow, doy).year;
        } else {
          weeksTarget = weeksInYear(input, dow, doy);
          if (week > weeksTarget) {
            week = weeksTarget;
          }
          return setWeekAll.call(this, input, week, weekday, dow, doy);
        }
      }
      function setWeekAll(weekYear, week, weekday, dow, doy) {
        var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy), date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);
        this.year(date.getUTCFullYear());
        this.month(date.getUTCMonth());
        this.date(date.getUTCDate());
        return this;
      }
      addFormatToken("Q", 0, "Qo", "quarter");
      addUnitAlias("quarter", "Q");
      addUnitPriority("quarter", 7);
      addRegexToken("Q", match1);
      addParseToken("Q", function(input, array) {
        array[MONTH] = (toInt(input) - 1) * 3;
      });
      function getSetQuarter(input) {
        return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
      }
      addFormatToken("D", ["DD", 2], "Do", "date");
      addUnitAlias("date", "D");
      addUnitPriority("date", 9);
      addRegexToken("D", match1to2);
      addRegexToken("DD", match1to2, match2);
      addRegexToken("Do", function(isStrict, locale2) {
        return isStrict ? locale2._dayOfMonthOrdinalParse || locale2._ordinalParse : locale2._dayOfMonthOrdinalParseLenient;
      });
      addParseToken(["D", "DD"], DATE);
      addParseToken("Do", function(input, array) {
        array[DATE] = toInt(input.match(match1to2)[0]);
      });
      var getSetDayOfMonth = makeGetSet("Date", true);
      addFormatToken("DDD", ["DDDD", 3], "DDDo", "dayOfYear");
      addUnitAlias("dayOfYear", "DDD");
      addUnitPriority("dayOfYear", 4);
      addRegexToken("DDD", match1to3);
      addRegexToken("DDDD", match3);
      addParseToken(["DDD", "DDDD"], function(input, array, config) {
        config._dayOfYear = toInt(input);
      });
      function getSetDayOfYear(input) {
        var dayOfYear = Math.round(
          (this.clone().startOf("day") - this.clone().startOf("year")) / 864e5
        ) + 1;
        return input == null ? dayOfYear : this.add(input - dayOfYear, "d");
      }
      addFormatToken("m", ["mm", 2], 0, "minute");
      addUnitAlias("minute", "m");
      addUnitPriority("minute", 14);
      addRegexToken("m", match1to2);
      addRegexToken("mm", match1to2, match2);
      addParseToken(["m", "mm"], MINUTE);
      var getSetMinute = makeGetSet("Minutes", false);
      addFormatToken("s", ["ss", 2], 0, "second");
      addUnitAlias("second", "s");
      addUnitPriority("second", 15);
      addRegexToken("s", match1to2);
      addRegexToken("ss", match1to2, match2);
      addParseToken(["s", "ss"], SECOND);
      var getSetSecond = makeGetSet("Seconds", false);
      addFormatToken("S", 0, 0, function() {
        return ~~(this.millisecond() / 100);
      });
      addFormatToken(0, ["SS", 2], 0, function() {
        return ~~(this.millisecond() / 10);
      });
      addFormatToken(0, ["SSS", 3], 0, "millisecond");
      addFormatToken(0, ["SSSS", 4], 0, function() {
        return this.millisecond() * 10;
      });
      addFormatToken(0, ["SSSSS", 5], 0, function() {
        return this.millisecond() * 100;
      });
      addFormatToken(0, ["SSSSSS", 6], 0, function() {
        return this.millisecond() * 1e3;
      });
      addFormatToken(0, ["SSSSSSS", 7], 0, function() {
        return this.millisecond() * 1e4;
      });
      addFormatToken(0, ["SSSSSSSS", 8], 0, function() {
        return this.millisecond() * 1e5;
      });
      addFormatToken(0, ["SSSSSSSSS", 9], 0, function() {
        return this.millisecond() * 1e6;
      });
      addUnitAlias("millisecond", "ms");
      addUnitPriority("millisecond", 16);
      addRegexToken("S", match1to3, match1);
      addRegexToken("SS", match1to3, match2);
      addRegexToken("SSS", match1to3, match3);
      var token, getSetMillisecond;
      for (token = "SSSS"; token.length <= 9; token += "S") {
        addRegexToken(token, matchUnsigned);
      }
      function parseMs(input, array) {
        array[MILLISECOND] = toInt(("0." + input) * 1e3);
      }
      for (token = "S"; token.length <= 9; token += "S") {
        addParseToken(token, parseMs);
      }
      getSetMillisecond = makeGetSet("Milliseconds", false);
      addFormatToken("z", 0, 0, "zoneAbbr");
      addFormatToken("zz", 0, 0, "zoneName");
      function getZoneAbbr() {
        return this._isUTC ? "UTC" : "";
      }
      function getZoneName() {
        return this._isUTC ? "Coordinated Universal Time" : "";
      }
      var proto = Moment.prototype;
      proto.add = add;
      proto.calendar = calendar$1;
      proto.clone = clone;
      proto.diff = diff;
      proto.endOf = endOf;
      proto.format = format;
      proto.from = from;
      proto.fromNow = fromNow;
      proto.to = to;
      proto.toNow = toNow;
      proto.get = stringGet;
      proto.invalidAt = invalidAt;
      proto.isAfter = isAfter;
      proto.isBefore = isBefore;
      proto.isBetween = isBetween;
      proto.isSame = isSame;
      proto.isSameOrAfter = isSameOrAfter;
      proto.isSameOrBefore = isSameOrBefore;
      proto.isValid = isValid$2;
      proto.lang = lang;
      proto.locale = locale;
      proto.localeData = localeData;
      proto.max = prototypeMax;
      proto.min = prototypeMin;
      proto.parsingFlags = parsingFlags;
      proto.set = stringSet;
      proto.startOf = startOf;
      proto.subtract = subtract;
      proto.toArray = toArray;
      proto.toObject = toObject;
      proto.toDate = toDate;
      proto.toISOString = toISOString;
      proto.inspect = inspect;
      if (typeof Symbol !== "undefined" && Symbol.for != null) {
        proto[Symbol.for("nodejs.util.inspect.custom")] = function() {
          return "Moment<" + this.format() + ">";
        };
      }
      proto.toJSON = toJSON;
      proto.toString = toString;
      proto.unix = unix;
      proto.valueOf = valueOf;
      proto.creationData = creationData;
      proto.eraName = getEraName;
      proto.eraNarrow = getEraNarrow;
      proto.eraAbbr = getEraAbbr;
      proto.eraYear = getEraYear;
      proto.year = getSetYear;
      proto.isLeapYear = getIsLeapYear;
      proto.weekYear = getSetWeekYear;
      proto.isoWeekYear = getSetISOWeekYear;
      proto.quarter = proto.quarters = getSetQuarter;
      proto.month = getSetMonth;
      proto.daysInMonth = getDaysInMonth;
      proto.week = proto.weeks = getSetWeek;
      proto.isoWeek = proto.isoWeeks = getSetISOWeek;
      proto.weeksInYear = getWeeksInYear;
      proto.weeksInWeekYear = getWeeksInWeekYear;
      proto.isoWeeksInYear = getISOWeeksInYear;
      proto.isoWeeksInISOWeekYear = getISOWeeksInISOWeekYear;
      proto.date = getSetDayOfMonth;
      proto.day = proto.days = getSetDayOfWeek;
      proto.weekday = getSetLocaleDayOfWeek;
      proto.isoWeekday = getSetISODayOfWeek;
      proto.dayOfYear = getSetDayOfYear;
      proto.hour = proto.hours = getSetHour;
      proto.minute = proto.minutes = getSetMinute;
      proto.second = proto.seconds = getSetSecond;
      proto.millisecond = proto.milliseconds = getSetMillisecond;
      proto.utcOffset = getSetOffset;
      proto.utc = setOffsetToUTC;
      proto.local = setOffsetToLocal;
      proto.parseZone = setOffsetToParsedOffset;
      proto.hasAlignedHourOffset = hasAlignedHourOffset;
      proto.isDST = isDaylightSavingTime;
      proto.isLocal = isLocal;
      proto.isUtcOffset = isUtcOffset;
      proto.isUtc = isUtc;
      proto.isUTC = isUtc;
      proto.zoneAbbr = getZoneAbbr;
      proto.zoneName = getZoneName;
      proto.dates = deprecate(
        "dates accessor is deprecated. Use date instead.",
        getSetDayOfMonth
      );
      proto.months = deprecate(
        "months accessor is deprecated. Use month instead",
        getSetMonth
      );
      proto.years = deprecate(
        "years accessor is deprecated. Use year instead",
        getSetYear
      );
      proto.zone = deprecate(
        "moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/",
        getSetZone
      );
      proto.isDSTShifted = deprecate(
        "isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information",
        isDaylightSavingTimeShifted
      );
      function createUnix(input) {
        return createLocal(input * 1e3);
      }
      function createInZone() {
        return createLocal.apply(null, arguments).parseZone();
      }
      function preParsePostFormat(string2) {
        return string2;
      }
      var proto$1 = Locale.prototype;
      proto$1.calendar = calendar;
      proto$1.longDateFormat = longDateFormat;
      proto$1.invalidDate = invalidDate;
      proto$1.ordinal = ordinal;
      proto$1.preparse = preParsePostFormat;
      proto$1.postformat = preParsePostFormat;
      proto$1.relativeTime = relativeTime;
      proto$1.pastFuture = pastFuture;
      proto$1.set = set2;
      proto$1.eras = localeEras;
      proto$1.erasParse = localeErasParse;
      proto$1.erasConvertYear = localeErasConvertYear;
      proto$1.erasAbbrRegex = erasAbbrRegex;
      proto$1.erasNameRegex = erasNameRegex;
      proto$1.erasNarrowRegex = erasNarrowRegex;
      proto$1.months = localeMonths;
      proto$1.monthsShort = localeMonthsShort;
      proto$1.monthsParse = localeMonthsParse;
      proto$1.monthsRegex = monthsRegex;
      proto$1.monthsShortRegex = monthsShortRegex;
      proto$1.week = localeWeek;
      proto$1.firstDayOfYear = localeFirstDayOfYear;
      proto$1.firstDayOfWeek = localeFirstDayOfWeek;
      proto$1.weekdays = localeWeekdays;
      proto$1.weekdaysMin = localeWeekdaysMin;
      proto$1.weekdaysShort = localeWeekdaysShort;
      proto$1.weekdaysParse = localeWeekdaysParse;
      proto$1.weekdaysRegex = weekdaysRegex;
      proto$1.weekdaysShortRegex = weekdaysShortRegex;
      proto$1.weekdaysMinRegex = weekdaysMinRegex;
      proto$1.isPM = localeIsPM;
      proto$1.meridiem = localeMeridiem;
      function get$1(format2, index, field, setter) {
        var locale2 = getLocale(), utc = createUTC().set(setter, index);
        return locale2[field](utc, format2);
      }
      function listMonthsImpl(format2, index, field) {
        if (isNumber(format2)) {
          index = format2;
          format2 = void 0;
        }
        format2 = format2 || "";
        if (index != null) {
          return get$1(format2, index, field, "month");
        }
        var i, out = [];
        for (i = 0; i < 12; i++) {
          out[i] = get$1(format2, i, field, "month");
        }
        return out;
      }
      function listWeekdaysImpl(localeSorted, format2, index, field) {
        if (typeof localeSorted === "boolean") {
          if (isNumber(format2)) {
            index = format2;
            format2 = void 0;
          }
          format2 = format2 || "";
        } else {
          format2 = localeSorted;
          index = format2;
          localeSorted = false;
          if (isNumber(format2)) {
            index = format2;
            format2 = void 0;
          }
          format2 = format2 || "";
        }
        var locale2 = getLocale(), shift = localeSorted ? locale2._week.dow : 0, i, out = [];
        if (index != null) {
          return get$1(format2, (index + shift) % 7, field, "day");
        }
        for (i = 0; i < 7; i++) {
          out[i] = get$1(format2, (i + shift) % 7, field, "day");
        }
        return out;
      }
      function listMonths(format2, index) {
        return listMonthsImpl(format2, index, "months");
      }
      function listMonthsShort(format2, index) {
        return listMonthsImpl(format2, index, "monthsShort");
      }
      function listWeekdays(localeSorted, format2, index) {
        return listWeekdaysImpl(localeSorted, format2, index, "weekdays");
      }
      function listWeekdaysShort(localeSorted, format2, index) {
        return listWeekdaysImpl(localeSorted, format2, index, "weekdaysShort");
      }
      function listWeekdaysMin(localeSorted, format2, index) {
        return listWeekdaysImpl(localeSorted, format2, index, "weekdaysMin");
      }
      getSetGlobalLocale("en", {
        eras: [
          {
            since: "0001-01-01",
            until: Infinity,
            offset: 1,
            name: "Anno Domini",
            narrow: "AD",
            abbr: "AD"
          },
          {
            since: "0000-12-31",
            until: -Infinity,
            offset: 1,
            name: "Before Christ",
            narrow: "BC",
            abbr: "BC"
          }
        ],
        dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
        ordinal: function(number) {
          var b = number % 10, output = toInt(number % 100 / 10) === 1 ? "th" : b === 1 ? "st" : b === 2 ? "nd" : b === 3 ? "rd" : "th";
          return number + output;
        }
      });
      hooks.lang = deprecate(
        "moment.lang is deprecated. Use moment.locale instead.",
        getSetGlobalLocale
      );
      hooks.langData = deprecate(
        "moment.langData is deprecated. Use moment.localeData instead.",
        getLocale
      );
      var mathAbs = Math.abs;
      function abs() {
        var data = this._data;
        this._milliseconds = mathAbs(this._milliseconds);
        this._days = mathAbs(this._days);
        this._months = mathAbs(this._months);
        data.milliseconds = mathAbs(data.milliseconds);
        data.seconds = mathAbs(data.seconds);
        data.minutes = mathAbs(data.minutes);
        data.hours = mathAbs(data.hours);
        data.months = mathAbs(data.months);
        data.years = mathAbs(data.years);
        return this;
      }
      function addSubtract$1(duration, input, value, direction) {
        var other = createDuration(input, value);
        duration._milliseconds += direction * other._milliseconds;
        duration._days += direction * other._days;
        duration._months += direction * other._months;
        return duration._bubble();
      }
      function add$1(input, value) {
        return addSubtract$1(this, input, value, 1);
      }
      function subtract$1(input, value) {
        return addSubtract$1(this, input, value, -1);
      }
      function absCeil(number) {
        if (number < 0) {
          return Math.floor(number);
        } else {
          return Math.ceil(number);
        }
      }
      function bubble() {
        var milliseconds2 = this._milliseconds, days2 = this._days, months2 = this._months, data = this._data, seconds2, minutes2, hours2, years2, monthsFromDays;
        if (!(milliseconds2 >= 0 && days2 >= 0 && months2 >= 0 || milliseconds2 <= 0 && days2 <= 0 && months2 <= 0)) {
          milliseconds2 += absCeil(monthsToDays(months2) + days2) * 864e5;
          days2 = 0;
          months2 = 0;
        }
        data.milliseconds = milliseconds2 % 1e3;
        seconds2 = absFloor(milliseconds2 / 1e3);
        data.seconds = seconds2 % 60;
        minutes2 = absFloor(seconds2 / 60);
        data.minutes = minutes2 % 60;
        hours2 = absFloor(minutes2 / 60);
        data.hours = hours2 % 24;
        days2 += absFloor(hours2 / 24);
        monthsFromDays = absFloor(daysToMonths(days2));
        months2 += monthsFromDays;
        days2 -= absCeil(monthsToDays(monthsFromDays));
        years2 = absFloor(months2 / 12);
        months2 %= 12;
        data.days = days2;
        data.months = months2;
        data.years = years2;
        return this;
      }
      function daysToMonths(days2) {
        return days2 * 4800 / 146097;
      }
      function monthsToDays(months2) {
        return months2 * 146097 / 4800;
      }
      function as(units) {
        if (!this.isValid()) {
          return NaN;
        }
        var days2, months2, milliseconds2 = this._milliseconds;
        units = normalizeUnits(units);
        if (units === "month" || units === "quarter" || units === "year") {
          days2 = this._days + milliseconds2 / 864e5;
          months2 = this._months + daysToMonths(days2);
          switch (units) {
            case "month":
              return months2;
            case "quarter":
              return months2 / 3;
            case "year":
              return months2 / 12;
          }
        } else {
          days2 = this._days + Math.round(monthsToDays(this._months));
          switch (units) {
            case "week":
              return days2 / 7 + milliseconds2 / 6048e5;
            case "day":
              return days2 + milliseconds2 / 864e5;
            case "hour":
              return days2 * 24 + milliseconds2 / 36e5;
            case "minute":
              return days2 * 1440 + milliseconds2 / 6e4;
            case "second":
              return days2 * 86400 + milliseconds2 / 1e3;
            case "millisecond":
              return Math.floor(days2 * 864e5) + milliseconds2;
            default:
              throw new Error("Unknown unit " + units);
          }
        }
      }
      function valueOf$1() {
        if (!this.isValid()) {
          return NaN;
        }
        return this._milliseconds + this._days * 864e5 + this._months % 12 * 2592e6 + toInt(this._months / 12) * 31536e6;
      }
      function makeAs(alias) {
        return function() {
          return this.as(alias);
        };
      }
      var asMilliseconds = makeAs("ms"), asSeconds = makeAs("s"), asMinutes = makeAs("m"), asHours = makeAs("h"), asDays = makeAs("d"), asWeeks = makeAs("w"), asMonths = makeAs("M"), asQuarters = makeAs("Q"), asYears = makeAs("y");
      function clone$1() {
        return createDuration(this);
      }
      function get$2(units) {
        units = normalizeUnits(units);
        return this.isValid() ? this[units + "s"]() : NaN;
      }
      function makeGetter(name) {
        return function() {
          return this.isValid() ? this._data[name] : NaN;
        };
      }
      var milliseconds = makeGetter("milliseconds"), seconds = makeGetter("seconds"), minutes = makeGetter("minutes"), hours = makeGetter("hours"), days = makeGetter("days"), months = makeGetter("months"), years = makeGetter("years");
      function weeks() {
        return absFloor(this.days() / 7);
      }
      var round = Math.round, thresholds = {
        ss: 44,
        // a few seconds to seconds
        s: 45,
        // seconds to minute
        m: 45,
        // minutes to hour
        h: 22,
        // hours to day
        d: 26,
        // days to month/week
        w: null,
        // weeks to month
        M: 11
        // months to year
      };
      function substituteTimeAgo(string2, number, withoutSuffix, isFuture, locale2) {
        return locale2.relativeTime(number || 1, !!withoutSuffix, string2, isFuture);
      }
      function relativeTime$1(posNegDuration, withoutSuffix, thresholds2, locale2) {
        var duration = createDuration(posNegDuration).abs(), seconds2 = round(duration.as("s")), minutes2 = round(duration.as("m")), hours2 = round(duration.as("h")), days2 = round(duration.as("d")), months2 = round(duration.as("M")), weeks2 = round(duration.as("w")), years2 = round(duration.as("y")), a = seconds2 <= thresholds2.ss && ["s", seconds2] || seconds2 < thresholds2.s && ["ss", seconds2] || minutes2 <= 1 && ["m"] || minutes2 < thresholds2.m && ["mm", minutes2] || hours2 <= 1 && ["h"] || hours2 < thresholds2.h && ["hh", hours2] || days2 <= 1 && ["d"] || days2 < thresholds2.d && ["dd", days2];
        if (thresholds2.w != null) {
          a = a || weeks2 <= 1 && ["w"] || weeks2 < thresholds2.w && ["ww", weeks2];
        }
        a = a || months2 <= 1 && ["M"] || months2 < thresholds2.M && ["MM", months2] || years2 <= 1 && ["y"] || ["yy", years2];
        a[2] = withoutSuffix;
        a[3] = +posNegDuration > 0;
        a[4] = locale2;
        return substituteTimeAgo.apply(null, a);
      }
      function getSetRelativeTimeRounding(roundingFunction) {
        if (roundingFunction === void 0) {
          return round;
        }
        if (typeof roundingFunction === "function") {
          round = roundingFunction;
          return true;
        }
        return false;
      }
      function getSetRelativeTimeThreshold(threshold, limit) {
        if (thresholds[threshold] === void 0) {
          return false;
        }
        if (limit === void 0) {
          return thresholds[threshold];
        }
        thresholds[threshold] = limit;
        if (threshold === "s") {
          thresholds.ss = limit - 1;
        }
        return true;
      }
      function humanize(argWithSuffix, argThresholds) {
        if (!this.isValid()) {
          return this.localeData().invalidDate();
        }
        var withSuffix = false, th = thresholds, locale2, output;
        if (typeof argWithSuffix === "object") {
          argThresholds = argWithSuffix;
          argWithSuffix = false;
        }
        if (typeof argWithSuffix === "boolean") {
          withSuffix = argWithSuffix;
        }
        if (typeof argThresholds === "object") {
          th = Object.assign({}, thresholds, argThresholds);
          if (argThresholds.s != null && argThresholds.ss == null) {
            th.ss = argThresholds.s - 1;
          }
        }
        locale2 = this.localeData();
        output = relativeTime$1(this, !withSuffix, th, locale2);
        if (withSuffix) {
          output = locale2.pastFuture(+this, output);
        }
        return locale2.postformat(output);
      }
      var abs$1 = Math.abs;
      function sign(x) {
        return (x > 0) - (x < 0) || +x;
      }
      function toISOString$1() {
        if (!this.isValid()) {
          return this.localeData().invalidDate();
        }
        var seconds2 = abs$1(this._milliseconds) / 1e3, days2 = abs$1(this._days), months2 = abs$1(this._months), minutes2, hours2, years2, s, total = this.asSeconds(), totalSign, ymSign, daysSign, hmsSign;
        if (!total) {
          return "P0D";
        }
        minutes2 = absFloor(seconds2 / 60);
        hours2 = absFloor(minutes2 / 60);
        seconds2 %= 60;
        minutes2 %= 60;
        years2 = absFloor(months2 / 12);
        months2 %= 12;
        s = seconds2 ? seconds2.toFixed(3).replace(/\.?0+$/, "") : "";
        totalSign = total < 0 ? "-" : "";
        ymSign = sign(this._months) !== sign(total) ? "-" : "";
        daysSign = sign(this._days) !== sign(total) ? "-" : "";
        hmsSign = sign(this._milliseconds) !== sign(total) ? "-" : "";
        return totalSign + "P" + (years2 ? ymSign + years2 + "Y" : "") + (months2 ? ymSign + months2 + "M" : "") + (days2 ? daysSign + days2 + "D" : "") + (hours2 || minutes2 || seconds2 ? "T" : "") + (hours2 ? hmsSign + hours2 + "H" : "") + (minutes2 ? hmsSign + minutes2 + "M" : "") + (seconds2 ? hmsSign + s + "S" : "");
      }
      var proto$2 = Duration.prototype;
      proto$2.isValid = isValid$1;
      proto$2.abs = abs;
      proto$2.add = add$1;
      proto$2.subtract = subtract$1;
      proto$2.as = as;
      proto$2.asMilliseconds = asMilliseconds;
      proto$2.asSeconds = asSeconds;
      proto$2.asMinutes = asMinutes;
      proto$2.asHours = asHours;
      proto$2.asDays = asDays;
      proto$2.asWeeks = asWeeks;
      proto$2.asMonths = asMonths;
      proto$2.asQuarters = asQuarters;
      proto$2.asYears = asYears;
      proto$2.valueOf = valueOf$1;
      proto$2._bubble = bubble;
      proto$2.clone = clone$1;
      proto$2.get = get$2;
      proto$2.milliseconds = milliseconds;
      proto$2.seconds = seconds;
      proto$2.minutes = minutes;
      proto$2.hours = hours;
      proto$2.days = days;
      proto$2.weeks = weeks;
      proto$2.months = months;
      proto$2.years = years;
      proto$2.humanize = humanize;
      proto$2.toISOString = toISOString$1;
      proto$2.toString = toISOString$1;
      proto$2.toJSON = toISOString$1;
      proto$2.locale = locale;
      proto$2.localeData = localeData;
      proto$2.toIsoString = deprecate(
        "toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)",
        toISOString$1
      );
      proto$2.lang = lang;
      addFormatToken("X", 0, 0, "unix");
      addFormatToken("x", 0, 0, "valueOf");
      addRegexToken("x", matchSigned);
      addRegexToken("X", matchTimestamp);
      addParseToken("X", function(input, array, config) {
        config._d = new Date(parseFloat(input) * 1e3);
      });
      addParseToken("x", function(input, array, config) {
        config._d = new Date(toInt(input));
      });
      hooks.version = "2.29.1";
      setHookCallback(createLocal);
      hooks.fn = proto;
      hooks.min = min;
      hooks.max = max;
      hooks.now = now;
      hooks.utc = createUTC;
      hooks.unix = createUnix;
      hooks.months = listMonths;
      hooks.isDate = isDate;
      hooks.locale = getSetGlobalLocale;
      hooks.invalid = createInvalid;
      hooks.duration = createDuration;
      hooks.isMoment = isMoment;
      hooks.weekdays = listWeekdays;
      hooks.parseZone = createInZone;
      hooks.localeData = getLocale;
      hooks.isDuration = isDuration;
      hooks.monthsShort = listMonthsShort;
      hooks.weekdaysMin = listWeekdaysMin;
      hooks.defineLocale = defineLocale;
      hooks.updateLocale = updateLocale;
      hooks.locales = listLocales;
      hooks.weekdaysShort = listWeekdaysShort;
      hooks.normalizeUnits = normalizeUnits;
      hooks.relativeTimeRounding = getSetRelativeTimeRounding;
      hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
      hooks.calendarFormat = getCalendarFormat;
      hooks.prototype = proto;
      hooks.HTML5_FMT = {
        DATETIME_LOCAL: "YYYY-MM-DDTHH:mm",
        // <input type="datetime-local" />
        DATETIME_LOCAL_SECONDS: "YYYY-MM-DDTHH:mm:ss",
        // <input type="datetime-local" step="1" />
        DATETIME_LOCAL_MS: "YYYY-MM-DDTHH:mm:ss.SSS",
        // <input type="datetime-local" step="0.001" />
        DATE: "YYYY-MM-DD",
        // <input type="date" />
        TIME: "HH:mm",
        // <input type="time" />
        TIME_SECONDS: "HH:mm:ss",
        // <input type="time" step="1" />
        TIME_MS: "HH:mm:ss.SSS",
        // <input type="time" step="0.001" />
        WEEK: "GGGG-[W]WW",
        // <input type="week" />
        MONTH: "YYYY-MM"
        // <input type="month" />
      };
      return hooks;
    });
  }
});

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => MyPlugin
});
module.exports = __toCommonJS(main_exports);

// updateNoteTypeModal.ts
var import_obsidian4 = require("obsidian");

// tagrenamer/renaming.ts
var import_obsidian2 = require("obsidian");

// tagrenamer/Tag.ts
var tagBody = /^#[^\u2000-\u206F\u2E00-\u2E7F'!"#$%&()*+,.:;<=>?@^`{|}~\[\]\\\s]+$/;
var Tag = class {
  constructor(name) {
    const hashed = this.tag = Tag.toTag(name), canonical = this.canonical = hashed.toLowerCase(), canonical_prefix = this.canonical_prefix = canonical + "/";
    this.name = hashed.slice(1);
    this.matches = function(text) {
      text = text.toLowerCase();
      return text == canonical || text.startsWith(canonical_prefix);
    };
  }
  toString() {
    return this.tag;
  }
  static isTag(s) {
    return tagBody.test(s);
  }
  static toTag(name) {
    while (name.startsWith("##"))
      name = name.slice(1);
    return name.startsWith("#") ? name : "#" + name;
  }
  static canonical(name) {
    return Tag.toTag(name).toLowerCase();
  }
};
var Replacement = class {
  constructor(fromTag, toTag) {
    const cache = Object.assign(
      /* @__PURE__ */ Object.create(null),
      {
        [fromTag.tag]: toTag.tag,
        [fromTag.name]: toTag.name
      }
    );
    this.inString = function(text, pos = 0) {
      return text.slice(0, pos) + toTag.tag + text.slice(pos + fromTag.tag.length);
    };
    this.inArray = (tags, skipOdd, isAlias2) => {
      return tags.map((t, i) => {
        if (skipOdd && i & 1)
          return t;
        if (!t)
          return t;
        if (isAlias2) {
          if (!t.startsWith("#") || !Tag.isTag(t))
            return t;
        } else if (/[ ,\n]/.test(t)) {
          return this.inArray(t.split(/([, \n]+)/), true, isAlias2).join("");
        }
        if (cache[t])
          return cache[t];
        const lc = t.toLowerCase();
        if (cache[lc]) {
          return cache[t] = cache[lc];
        } else if (lc.startsWith(fromTag.canonical_prefix)) {
          return cache[t] = cache[lc] = this.inString(t);
        } else if (("#" + lc).startsWith(fromTag.canonical_prefix)) {
          return cache[t] = cache[lc] = this.inString("#" + t).slice(1);
        }
        return cache[t] = cache[lc] = t;
      });
    };
    this.willMergeTags = function(tagNames) {
      if (fromTag.canonical === toTag.canonical)
        return;
      const existing = new Set(tagNames.map((s) => s.toLowerCase()));
      for (const tagName of tagNames.filter(fromTag.matches)) {
        const changed = this.inString(tagName);
        if (existing.has(changed.toLowerCase()))
          return [new Tag(tagName), new Tag(changed)];
      }
    };
  }
};

// tagrenamer/File.ts
var import_obsidian = require("obsidian");

// node_modules/yaml/browser/dist/nodes/Node.js
var ALIAS = Symbol.for("yaml.alias");
var DOC = Symbol.for("yaml.document");
var MAP = Symbol.for("yaml.map");
var PAIR = Symbol.for("yaml.pair");
var SCALAR = Symbol.for("yaml.scalar");
var SEQ = Symbol.for("yaml.seq");
var NODE_TYPE = Symbol.for("yaml.node.type");
var isAlias = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === ALIAS;
var isDocument = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === DOC;
var isMap = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === MAP;
var isPair = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === PAIR;
var isScalar = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === SCALAR;
var isSeq = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === SEQ;
function isCollection(node) {
  if (node && typeof node === "object")
    switch (node[NODE_TYPE]) {
      case MAP:
      case SEQ:
        return true;
    }
  return false;
}
function isNode(node) {
  if (node && typeof node === "object")
    switch (node[NODE_TYPE]) {
      case ALIAS:
      case MAP:
      case SCALAR:
      case SEQ:
        return true;
    }
  return false;
}
var hasAnchor = (node) => (isScalar(node) || isCollection(node)) && !!node.anchor;
var NodeBase = class {
  constructor(type) {
    Object.defineProperty(this, NODE_TYPE, { value: type });
  }
  /** Create a copy of this node.  */
  clone() {
    const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
    if (this.range)
      copy.range = this.range.slice();
    return copy;
  }
};

// node_modules/yaml/browser/dist/visit.js
var BREAK = Symbol("break visit");
var SKIP = Symbol("skip children");
var REMOVE = Symbol("remove node");
function visit(node, visitor) {
  if (typeof visitor === "object" && (visitor.Collection || visitor.Node || visitor.Value)) {
    visitor = Object.assign({
      Alias: visitor.Node,
      Map: visitor.Node,
      Scalar: visitor.Node,
      Seq: visitor.Node
    }, visitor.Value && {
      Map: visitor.Value,
      Scalar: visitor.Value,
      Seq: visitor.Value
    }, visitor.Collection && {
      Map: visitor.Collection,
      Seq: visitor.Collection
    }, visitor);
  }
  if (isDocument(node)) {
    const cd = _visit(null, node.contents, visitor, Object.freeze([node]));
    if (cd === REMOVE)
      node.contents = null;
  } else
    _visit(null, node, visitor, Object.freeze([]));
}
visit.BREAK = BREAK;
visit.SKIP = SKIP;
visit.REMOVE = REMOVE;
function _visit(key, node, visitor, path) {
  let ctrl = void 0;
  if (typeof visitor === "function")
    ctrl = visitor(key, node, path);
  else if (isMap(node)) {
    if (visitor.Map)
      ctrl = visitor.Map(key, node, path);
  } else if (isSeq(node)) {
    if (visitor.Seq)
      ctrl = visitor.Seq(key, node, path);
  } else if (isPair(node)) {
    if (visitor.Pair)
      ctrl = visitor.Pair(key, node, path);
  } else if (isScalar(node)) {
    if (visitor.Scalar)
      ctrl = visitor.Scalar(key, node, path);
  } else if (isAlias(node)) {
    if (visitor.Alias)
      ctrl = visitor.Alias(key, node, path);
  }
  if (isNode(ctrl) || isPair(ctrl)) {
    const parent = path[path.length - 1];
    if (isCollection(parent)) {
      parent.items[key] = ctrl;
    } else if (isPair(parent)) {
      if (key === "key")
        parent.key = ctrl;
      else
        parent.value = ctrl;
    } else if (isDocument(parent)) {
      parent.contents = ctrl;
    } else {
      const pt = isAlias(parent) ? "alias" : "scalar";
      throw new Error(`Cannot replace node with ${pt} parent`);
    }
    return _visit(key, ctrl, visitor, path);
  }
  if (typeof ctrl !== "symbol") {
    if (isCollection(node)) {
      path = Object.freeze(path.concat(node));
      for (let i = 0; i < node.items.length; ++i) {
        const ci = _visit(i, node.items[i], visitor, path);
        if (typeof ci === "number")
          i = ci - 1;
        else if (ci === BREAK)
          return BREAK;
        else if (ci === REMOVE) {
          node.items.splice(i, 1);
          i -= 1;
        }
      }
    } else if (isPair(node)) {
      path = Object.freeze(path.concat(node));
      const ck = _visit("key", node.key, visitor, path);
      if (ck === BREAK)
        return BREAK;
      else if (ck === REMOVE)
        node.key = null;
      const cv = _visit("value", node.value, visitor, path);
      if (cv === BREAK)
        return BREAK;
      else if (cv === REMOVE)
        node.value = null;
    }
  }
  return ctrl;
}

// node_modules/yaml/browser/dist/doc/directives.js
var escapeChars = {
  "!": "%21",
  ",": "%2C",
  "[": "%5B",
  "]": "%5D",
  "{": "%7B",
  "}": "%7D"
};
var escapeTagName = (tn) => tn.replace(/[!,[\]{}]/g, (ch) => escapeChars[ch]);
var Directives = class {
  constructor(yaml, tags) {
    this.marker = null;
    this.yaml = Object.assign({}, Directives.defaultYaml, yaml);
    this.tags = Object.assign({}, Directives.defaultTags, tags);
  }
  clone() {
    const copy = new Directives(this.yaml, this.tags);
    copy.marker = this.marker;
    return copy;
  }
  /**
   * During parsing, get a Directives instance for the current document and
   * update the stream state according to the current version's spec.
   */
  atDocument() {
    const res = new Directives(this.yaml, this.tags);
    switch (this.yaml.version) {
      case "1.1":
        this.atNextDocument = true;
        break;
      case "1.2":
        this.atNextDocument = false;
        this.yaml = {
          explicit: Directives.defaultYaml.explicit,
          version: "1.2"
        };
        this.tags = Object.assign({}, Directives.defaultTags);
        break;
    }
    return res;
  }
  /**
   * @param onError - May be called even if the action was successful
   * @returns `true` on success
   */
  add(line, onError) {
    if (this.atNextDocument) {
      this.yaml = { explicit: Directives.defaultYaml.explicit, version: "1.1" };
      this.tags = Object.assign({}, Directives.defaultTags);
      this.atNextDocument = false;
    }
    const parts = line.trim().split(/[ \t]+/);
    const name = parts.shift();
    switch (name) {
      case "%TAG": {
        if (parts.length !== 2) {
          onError(0, "%TAG directive should contain exactly two parts");
          if (parts.length < 2)
            return false;
        }
        const [handle, prefix] = parts;
        this.tags[handle] = prefix;
        return true;
      }
      case "%YAML": {
        this.yaml.explicit = true;
        if (parts.length < 1) {
          onError(0, "%YAML directive should contain exactly one part");
          return false;
        }
        const [version] = parts;
        if (version === "1.1" || version === "1.2") {
          this.yaml.version = version;
          return true;
        } else {
          onError(6, `Unsupported YAML version ${version}`, true);
          return false;
        }
      }
      default:
        onError(0, `Unknown directive ${name}`, true);
        return false;
    }
  }
  /**
   * Resolves a tag, matching handles to those defined in %TAG directives.
   *
   * @returns Resolved tag, which may also be the non-specific tag `'!'` or a
   *   `'!local'` tag, or `null` if unresolvable.
   */
  tagName(source, onError) {
    if (source === "!")
      return "!";
    if (source[0] !== "!") {
      onError(`Not a valid tag: ${source}`);
      return null;
    }
    if (source[1] === "<") {
      const verbatim = source.slice(2, -1);
      if (verbatim === "!" || verbatim === "!!") {
        onError(`Verbatim tags aren't resolved, so ${source} is invalid.`);
        return null;
      }
      if (source[source.length - 1] !== ">")
        onError("Verbatim tags must end with a >");
      return verbatim;
    }
    const [, handle, suffix] = source.match(/^(.*!)([^!]*)$/);
    if (!suffix)
      onError(`The ${source} tag has no suffix`);
    const prefix = this.tags[handle];
    if (prefix)
      return prefix + decodeURIComponent(suffix);
    if (handle === "!")
      return source;
    onError(`Could not resolve tag: ${source}`);
    return null;
  }
  /**
   * Given a fully resolved tag, returns its printable string form,
   * taking into account current tag prefixes and defaults.
   */
  tagString(tag2) {
    for (const [handle, prefix] of Object.entries(this.tags)) {
      if (tag2.startsWith(prefix))
        return handle + escapeTagName(tag2.substring(prefix.length));
    }
    return tag2[0] === "!" ? tag2 : `!<${tag2}>`;
  }
  toString(doc) {
    const lines = this.yaml.explicit ? [`%YAML ${this.yaml.version || "1.2"}`] : [];
    const tagEntries = Object.entries(this.tags);
    let tagNames;
    if (doc && tagEntries.length > 0 && isNode(doc.contents)) {
      const tags = {};
      visit(doc.contents, (_key, node) => {
        if (isNode(node) && node.tag)
          tags[node.tag] = true;
      });
      tagNames = Object.keys(tags);
    } else
      tagNames = [];
    for (const [handle, prefix] of tagEntries) {
      if (handle === "!!" && prefix === "tag:yaml.org,2002:")
        continue;
      if (!doc || tagNames.some((tn) => tn.startsWith(prefix)))
        lines.push(`%TAG ${handle} ${prefix}`);
    }
    return lines.join("\n");
  }
};
Directives.defaultYaml = { explicit: false, version: "1.2" };
Directives.defaultTags = { "!!": "tag:yaml.org,2002:" };

// node_modules/yaml/browser/dist/doc/anchors.js
function anchorIsValid(anchor) {
  if (/[\x00-\x19\s,[\]{}]/.test(anchor)) {
    const sa = JSON.stringify(anchor);
    const msg = `Anchor must not contain whitespace or control characters: ${sa}`;
    throw new Error(msg);
  }
  return true;
}
function anchorNames(root) {
  const anchors = /* @__PURE__ */ new Set();
  visit(root, {
    Value(_key, node) {
      if (node.anchor)
        anchors.add(node.anchor);
    }
  });
  return anchors;
}
function findNewAnchor(prefix, exclude) {
  for (let i = 1; true; ++i) {
    const name = `${prefix}${i}`;
    if (!exclude.has(name))
      return name;
  }
}
function createNodeAnchors(doc, prefix) {
  const aliasObjects = [];
  const sourceObjects = /* @__PURE__ */ new Map();
  let prevAnchors = null;
  return {
    onAnchor(source) {
      aliasObjects.push(source);
      if (!prevAnchors)
        prevAnchors = anchorNames(doc);
      const anchor = findNewAnchor(prefix, prevAnchors);
      prevAnchors.add(anchor);
      return anchor;
    },
    /**
     * With circular references, the source node is only resolved after all
     * of its child nodes are. This is why anchors are set only after all of
     * the nodes have been created.
     */
    setAnchors() {
      for (const source of aliasObjects) {
        const ref = sourceObjects.get(source);
        if (typeof ref === "object" && ref.anchor && (isScalar(ref.node) || isCollection(ref.node))) {
          ref.node.anchor = ref.anchor;
        } else {
          const error = new Error("Failed to resolve repeated object (this should not happen)");
          error.source = source;
          throw error;
        }
      }
    },
    sourceObjects
  };
}

// node_modules/yaml/browser/dist/nodes/Alias.js
var Alias = class extends NodeBase {
  constructor(source) {
    super(ALIAS);
    this.source = source;
    Object.defineProperty(this, "tag", {
      set() {
        throw new Error("Alias nodes cannot have tags");
      }
    });
  }
  /**
   * Resolve the value of this alias within `doc`, finding the last
   * instance of the `source` anchor before this node.
   */
  resolve(doc) {
    let found = void 0;
    visit(doc, {
      Node: (_key, node) => {
        if (node === this)
          return visit.BREAK;
        if (node.anchor === this.source)
          found = node;
      }
    });
    return found;
  }
  toJSON(_arg, ctx) {
    if (!ctx)
      return { source: this.source };
    const { anchors, doc, maxAliasCount } = ctx;
    const source = this.resolve(doc);
    if (!source) {
      const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
      throw new ReferenceError(msg);
    }
    const data = anchors.get(source);
    if (!data || data.res === void 0) {
      const msg = "This should not happen: Alias anchor was not resolved?";
      throw new ReferenceError(msg);
    }
    if (maxAliasCount >= 0) {
      data.count += 1;
      if (data.aliasCount === 0)
        data.aliasCount = getAliasCount(doc, source, anchors);
      if (data.count * data.aliasCount > maxAliasCount) {
        const msg = "Excessive alias count indicates a resource exhaustion attack";
        throw new ReferenceError(msg);
      }
    }
    return data.res;
  }
  toString(ctx, _onComment, _onChompKeep) {
    const src = `*${this.source}`;
    if (ctx) {
      anchorIsValid(this.source);
      if (ctx.options.verifyAliasOrder && !ctx.anchors.has(this.source)) {
        const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
        throw new Error(msg);
      }
      if (ctx.implicitKey)
        return `${src} `;
    }
    return src;
  }
};
function getAliasCount(doc, node, anchors) {
  if (isAlias(node)) {
    const source = node.resolve(doc);
    const anchor = anchors && source && anchors.get(source);
    return anchor ? anchor.count * anchor.aliasCount : 0;
  } else if (isCollection(node)) {
    let count = 0;
    for (const item of node.items) {
      const c = getAliasCount(doc, item, anchors);
      if (c > count)
        count = c;
    }
    return count;
  } else if (isPair(node)) {
    const kc = getAliasCount(doc, node.key, anchors);
    const vc = getAliasCount(doc, node.value, anchors);
    return Math.max(kc, vc);
  }
  return 1;
}

// node_modules/yaml/browser/dist/nodes/toJS.js
function toJS(value, arg, ctx) {
  if (Array.isArray(value))
    return value.map((v, i) => toJS(v, String(i), ctx));
  if (value && typeof value.toJSON === "function") {
    if (!ctx || !hasAnchor(value))
      return value.toJSON(arg, ctx);
    const data = { aliasCount: 0, count: 1, res: void 0 };
    ctx.anchors.set(value, data);
    ctx.onCreate = (res2) => {
      data.res = res2;
      delete ctx.onCreate;
    };
    const res = value.toJSON(arg, ctx);
    if (ctx.onCreate)
      ctx.onCreate(res);
    return res;
  }
  if (typeof value === "bigint" && !(ctx && ctx.keep))
    return Number(value);
  return value;
}

// node_modules/yaml/browser/dist/nodes/Scalar.js
var isScalarValue = (value) => !value || typeof value !== "function" && typeof value !== "object";
var Scalar = class extends NodeBase {
  constructor(value) {
    super(SCALAR);
    this.value = value;
  }
  toJSON(arg, ctx) {
    return ctx && ctx.keep ? this.value : toJS(this.value, arg, ctx);
  }
  toString() {
    return String(this.value);
  }
};
Scalar.BLOCK_FOLDED = "BLOCK_FOLDED";
Scalar.BLOCK_LITERAL = "BLOCK_LITERAL";
Scalar.PLAIN = "PLAIN";
Scalar.QUOTE_DOUBLE = "QUOTE_DOUBLE";
Scalar.QUOTE_SINGLE = "QUOTE_SINGLE";

// node_modules/yaml/browser/dist/doc/createNode.js
var defaultTagPrefix = "tag:yaml.org,2002:";
function findTagObject(value, tagName, tags) {
  if (tagName) {
    const match = tags.filter((t) => t.tag === tagName);
    const tagObj = match.find((t) => !t.format) || match[0];
    if (!tagObj)
      throw new Error(`Tag ${tagName} not found`);
    return tagObj;
  }
  return tags.find((t) => t.identify && t.identify(value) && !t.format);
}
function createNode(value, tagName, ctx) {
  var _a, _b;
  if (isDocument(value))
    value = value.contents;
  if (isNode(value))
    return value;
  if (isPair(value)) {
    const map2 = (_b = (_a = ctx.schema[MAP]).createNode) === null || _b === void 0 ? void 0 : _b.call(_a, ctx.schema, null, ctx);
    map2.items.push(value);
    return map2;
  }
  if (value instanceof String || value instanceof Number || value instanceof Boolean || typeof BigInt === "function" && value instanceof BigInt) {
    value = value.valueOf();
  }
  const { aliasDuplicateObjects, onAnchor, onTagObj, schema: schema4, sourceObjects } = ctx;
  let ref = void 0;
  if (aliasDuplicateObjects && value && typeof value === "object") {
    ref = sourceObjects.get(value);
    if (ref) {
      if (!ref.anchor)
        ref.anchor = onAnchor(value);
      return new Alias(ref.anchor);
    } else {
      ref = { anchor: null, node: null };
      sourceObjects.set(value, ref);
    }
  }
  if (tagName && tagName.startsWith("!!"))
    tagName = defaultTagPrefix + tagName.slice(2);
  let tagObj = findTagObject(value, tagName, schema4.tags);
  if (!tagObj) {
    if (value && typeof value.toJSON === "function")
      value = value.toJSON();
    if (!value || typeof value !== "object") {
      const node2 = new Scalar(value);
      if (ref)
        ref.node = node2;
      return node2;
    }
    tagObj = value instanceof Map ? schema4[MAP] : Symbol.iterator in Object(value) ? schema4[SEQ] : schema4[MAP];
  }
  if (onTagObj) {
    onTagObj(tagObj);
    delete ctx.onTagObj;
  }
  const node = (tagObj === null || tagObj === void 0 ? void 0 : tagObj.createNode) ? tagObj.createNode(ctx.schema, value, ctx) : new Scalar(value);
  if (tagName)
    node.tag = tagName;
  if (ref)
    ref.node = node;
  return node;
}

// node_modules/yaml/browser/dist/nodes/Collection.js
function collectionFromPath(schema4, path, value) {
  let v = value;
  for (let i = path.length - 1; i >= 0; --i) {
    const k = path[i];
    if (typeof k === "number" && Number.isInteger(k) && k >= 0) {
      const a = [];
      a[k] = v;
      v = a;
    } else {
      v = /* @__PURE__ */ new Map([[k, v]]);
    }
  }
  return createNode(v, void 0, {
    aliasDuplicateObjects: false,
    keepUndefined: false,
    onAnchor: () => {
      throw new Error("This should not happen, please report a bug.");
    },
    schema: schema4,
    sourceObjects: /* @__PURE__ */ new Map()
  });
}
var isEmptyPath = (path) => path == null || typeof path === "object" && !!path[Symbol.iterator]().next().done;
var Collection = class extends NodeBase {
  constructor(type, schema4) {
    super(type);
    Object.defineProperty(this, "schema", {
      value: schema4,
      configurable: true,
      enumerable: false,
      writable: true
    });
  }
  /**
   * Create a copy of this collection.
   *
   * @param schema - If defined, overwrites the original's schema
   */
  clone(schema4) {
    const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
    if (schema4)
      copy.schema = schema4;
    copy.items = copy.items.map((it) => isNode(it) || isPair(it) ? it.clone(schema4) : it);
    if (this.range)
      copy.range = this.range.slice();
    return copy;
  }
  /**
   * Adds a value to the collection. For `!!map` and `!!omap` the value must
   * be a Pair instance or a `{ key, value }` object, which may not have a key
   * that already exists in the map.
   */
  addIn(path, value) {
    if (isEmptyPath(path))
      this.add(value);
    else {
      const [key, ...rest] = path;
      const node = this.get(key, true);
      if (isCollection(node))
        node.addIn(rest, value);
      else if (node === void 0 && this.schema)
        this.set(key, collectionFromPath(this.schema, rest, value));
      else
        throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
    }
  }
  /**
   * Removes a value from the collection.
   * @returns `true` if the item was found and removed.
   */
  deleteIn(path) {
    const [key, ...rest] = path;
    if (rest.length === 0)
      return this.delete(key);
    const node = this.get(key, true);
    if (isCollection(node))
      return node.deleteIn(rest);
    else
      throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
  }
  /**
   * Returns item at `key`, or `undefined` if not found. By default unwraps
   * scalar values from their surrounding node; to disable set `keepScalar` to
   * `true` (collections are always returned intact).
   */
  getIn(path, keepScalar) {
    const [key, ...rest] = path;
    const node = this.get(key, true);
    if (rest.length === 0)
      return !keepScalar && isScalar(node) ? node.value : node;
    else
      return isCollection(node) ? node.getIn(rest, keepScalar) : void 0;
  }
  hasAllNullValues(allowScalar) {
    return this.items.every((node) => {
      if (!isPair(node))
        return false;
      const n = node.value;
      return n == null || allowScalar && isScalar(n) && n.value == null && !n.commentBefore && !n.comment && !n.tag;
    });
  }
  /**
   * Checks if the collection includes a value with the key `key`.
   */
  hasIn(path) {
    const [key, ...rest] = path;
    if (rest.length === 0)
      return this.has(key);
    const node = this.get(key, true);
    return isCollection(node) ? node.hasIn(rest) : false;
  }
  /**
   * Sets a value in this collection. For `!!set`, `value` needs to be a
   * boolean to add/remove the item from the set.
   */
  setIn(path, value) {
    const [key, ...rest] = path;
    if (rest.length === 0) {
      this.set(key, value);
    } else {
      const node = this.get(key, true);
      if (isCollection(node))
        node.setIn(rest, value);
      else if (node === void 0 && this.schema)
        this.set(key, collectionFromPath(this.schema, rest, value));
      else
        throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
    }
  }
};
Collection.maxFlowStringSingleLineLength = 60;

// node_modules/yaml/browser/dist/stringify/stringifyComment.js
var stringifyComment = (str) => str.replace(/^(?!$)(?: $)?/gm, "#");
function indentComment(comment, indent) {
  if (/^\n+$/.test(comment))
    return comment.substring(1);
  return indent ? comment.replace(/^(?! *$)/gm, indent) : comment;
}
var lineComment = (str, indent, comment) => comment.includes("\n") ? "\n" + indentComment(comment, indent) : (str.endsWith(" ") ? "" : " ") + comment;

// node_modules/yaml/browser/dist/stringify/foldFlowLines.js
var FOLD_FLOW = "flow";
var FOLD_BLOCK = "block";
var FOLD_QUOTED = "quoted";
function foldFlowLines(text, indent, mode = "flow", { indentAtStart, lineWidth = 80, minContentWidth = 20, onFold, onOverflow } = {}) {
  if (!lineWidth || lineWidth < 0)
    return text;
  const endStep = Math.max(1 + minContentWidth, 1 + lineWidth - indent.length);
  if (text.length <= endStep)
    return text;
  const folds = [];
  const escapedFolds = {};
  let end = lineWidth - indent.length;
  if (typeof indentAtStart === "number") {
    if (indentAtStart > lineWidth - Math.max(2, minContentWidth))
      folds.push(0);
    else
      end = lineWidth - indentAtStart;
  }
  let split = void 0;
  let prev = void 0;
  let overflow = false;
  let i = -1;
  let escStart = -1;
  let escEnd = -1;
  if (mode === FOLD_BLOCK) {
    i = consumeMoreIndentedLines(text, i);
    if (i !== -1)
      end = i + endStep;
  }
  for (let ch; ch = text[i += 1]; ) {
    if (mode === FOLD_QUOTED && ch === "\\") {
      escStart = i;
      switch (text[i + 1]) {
        case "x":
          i += 3;
          break;
        case "u":
          i += 5;
          break;
        case "U":
          i += 9;
          break;
        default:
          i += 1;
      }
      escEnd = i;
    }
    if (ch === "\n") {
      if (mode === FOLD_BLOCK)
        i = consumeMoreIndentedLines(text, i);
      end = i + endStep;
      split = void 0;
    } else {
      if (ch === " " && prev && prev !== " " && prev !== "\n" && prev !== "	") {
        const next = text[i + 1];
        if (next && next !== " " && next !== "\n" && next !== "	")
          split = i;
      }
      if (i >= end) {
        if (split) {
          folds.push(split);
          end = split + endStep;
          split = void 0;
        } else if (mode === FOLD_QUOTED) {
          while (prev === " " || prev === "	") {
            prev = ch;
            ch = text[i += 1];
            overflow = true;
          }
          const j = i > escEnd + 1 ? i - 2 : escStart - 1;
          if (escapedFolds[j])
            return text;
          folds.push(j);
          escapedFolds[j] = true;
          end = j + endStep;
          split = void 0;
        } else {
          overflow = true;
        }
      }
    }
    prev = ch;
  }
  if (overflow && onOverflow)
    onOverflow();
  if (folds.length === 0)
    return text;
  if (onFold)
    onFold();
  let res = text.slice(0, folds[0]);
  for (let i2 = 0; i2 < folds.length; ++i2) {
    const fold = folds[i2];
    const end2 = folds[i2 + 1] || text.length;
    if (fold === 0)
      res = `
${indent}${text.slice(0, end2)}`;
    else {
      if (mode === FOLD_QUOTED && escapedFolds[fold])
        res += `${text[fold]}\\`;
      res += `
${indent}${text.slice(fold + 1, end2)}`;
    }
  }
  return res;
}
function consumeMoreIndentedLines(text, i) {
  let ch = text[i + 1];
  while (ch === " " || ch === "	") {
    do {
      ch = text[i += 1];
    } while (ch && ch !== "\n");
    ch = text[i + 1];
  }
  return i;
}

// node_modules/yaml/browser/dist/stringify/stringifyString.js
var getFoldOptions = (ctx) => ({
  indentAtStart: ctx.indentAtStart,
  lineWidth: ctx.options.lineWidth,
  minContentWidth: ctx.options.minContentWidth
});
var containsDocumentMarker = (str) => /^(%|---|\.\.\.)/m.test(str);
function lineLengthOverLimit(str, lineWidth, indentLength) {
  if (!lineWidth || lineWidth < 0)
    return false;
  const limit = lineWidth - indentLength;
  const strLen = str.length;
  if (strLen <= limit)
    return false;
  for (let i = 0, start = 0; i < strLen; ++i) {
    if (str[i] === "\n") {
      if (i - start > limit)
        return true;
      start = i + 1;
      if (strLen - start <= limit)
        return false;
    }
  }
  return true;
}
function doubleQuotedString(value, ctx) {
  const json = JSON.stringify(value);
  if (ctx.options.doubleQuotedAsJSON)
    return json;
  const { implicitKey } = ctx;
  const minMultiLineLength = ctx.options.doubleQuotedMinMultiLineLength;
  const indent = ctx.indent || (containsDocumentMarker(value) ? "  " : "");
  let str = "";
  let start = 0;
  for (let i = 0, ch = json[i]; ch; ch = json[++i]) {
    if (ch === " " && json[i + 1] === "\\" && json[i + 2] === "n") {
      str += json.slice(start, i) + "\\ ";
      i += 1;
      start = i;
      ch = "\\";
    }
    if (ch === "\\")
      switch (json[i + 1]) {
        case "u":
          {
            str += json.slice(start, i);
            const code = json.substr(i + 2, 4);
            switch (code) {
              case "0000":
                str += "\\0";
                break;
              case "0007":
                str += "\\a";
                break;
              case "000b":
                str += "\\v";
                break;
              case "001b":
                str += "\\e";
                break;
              case "0085":
                str += "\\N";
                break;
              case "00a0":
                str += "\\_";
                break;
              case "2028":
                str += "\\L";
                break;
              case "2029":
                str += "\\P";
                break;
              default:
                if (code.substr(0, 2) === "00")
                  str += "\\x" + code.substr(2);
                else
                  str += json.substr(i, 6);
            }
            i += 5;
            start = i + 1;
          }
          break;
        case "n":
          if (implicitKey || json[i + 2] === '"' || json.length < minMultiLineLength) {
            i += 1;
          } else {
            str += json.slice(start, i) + "\n\n";
            while (json[i + 2] === "\\" && json[i + 3] === "n" && json[i + 4] !== '"') {
              str += "\n";
              i += 2;
            }
            str += indent;
            if (json[i + 2] === " ")
              str += "\\";
            i += 1;
            start = i + 1;
          }
          break;
        default:
          i += 1;
      }
  }
  str = start ? str + json.slice(start) : json;
  return implicitKey ? str : foldFlowLines(str, indent, FOLD_QUOTED, getFoldOptions(ctx));
}
function singleQuotedString(value, ctx) {
  if (ctx.options.singleQuote === false || ctx.implicitKey && value.includes("\n") || /[ \t]\n|\n[ \t]/.test(value))
    return doubleQuotedString(value, ctx);
  const indent = ctx.indent || (containsDocumentMarker(value) ? "  " : "");
  const res = "'" + value.replace(/'/g, "''").replace(/\n+/g, `$&
${indent}`) + "'";
  return ctx.implicitKey ? res : foldFlowLines(res, indent, FOLD_FLOW, getFoldOptions(ctx));
}
function quotedString(value, ctx) {
  const { singleQuote } = ctx.options;
  let qs;
  if (singleQuote === false)
    qs = doubleQuotedString;
  else {
    const hasDouble = value.includes('"');
    const hasSingle = value.includes("'");
    if (hasDouble && !hasSingle)
      qs = singleQuotedString;
    else if (hasSingle && !hasDouble)
      qs = doubleQuotedString;
    else
      qs = singleQuote ? singleQuotedString : doubleQuotedString;
  }
  return qs(value, ctx);
}
function blockString({ comment, type, value }, ctx, onComment, onChompKeep) {
  const { blockQuote, commentString, lineWidth } = ctx.options;
  if (!blockQuote || /\n[\t ]+$/.test(value) || /^\s*$/.test(value)) {
    return quotedString(value, ctx);
  }
  const indent = ctx.indent || (ctx.forceBlockIndent || containsDocumentMarker(value) ? "  " : "");
  const literal = blockQuote === "literal" ? true : blockQuote === "folded" || type === Scalar.BLOCK_FOLDED ? false : type === Scalar.BLOCK_LITERAL ? true : !lineLengthOverLimit(value, lineWidth, indent.length);
  if (!value)
    return literal ? "|\n" : ">\n";
  let chomp;
  let endStart;
  for (endStart = value.length; endStart > 0; --endStart) {
    const ch = value[endStart - 1];
    if (ch !== "\n" && ch !== "	" && ch !== " ")
      break;
  }
  let end = value.substring(endStart);
  const endNlPos = end.indexOf("\n");
  if (endNlPos === -1) {
    chomp = "-";
  } else if (value === end || endNlPos !== end.length - 1) {
    chomp = "+";
    if (onChompKeep)
      onChompKeep();
  } else {
    chomp = "";
  }
  if (end) {
    value = value.slice(0, -end.length);
    if (end[end.length - 1] === "\n")
      end = end.slice(0, -1);
    end = end.replace(/\n+(?!\n|$)/g, `$&${indent}`);
  }
  let startWithSpace = false;
  let startEnd;
  let startNlPos = -1;
  for (startEnd = 0; startEnd < value.length; ++startEnd) {
    const ch = value[startEnd];
    if (ch === " ")
      startWithSpace = true;
    else if (ch === "\n")
      startNlPos = startEnd;
    else
      break;
  }
  let start = value.substring(0, startNlPos < startEnd ? startNlPos + 1 : startEnd);
  if (start) {
    value = value.substring(start.length);
    start = start.replace(/\n+/g, `$&${indent}`);
  }
  const indentSize = indent ? "2" : "1";
  let header = (literal ? "|" : ">") + (startWithSpace ? indentSize : "") + chomp;
  if (comment) {
    header += " " + commentString(comment.replace(/ ?[\r\n]+/g, " "));
    if (onComment)
      onComment();
  }
  if (literal) {
    value = value.replace(/\n+/g, `$&${indent}`);
    return `${header}
${indent}${start}${value}${end}`;
  }
  value = value.replace(/\n+/g, "\n$&").replace(/(?:^|\n)([\t ].*)(?:([\n\t ]*)\n(?![\n\t ]))?/g, "$1$2").replace(/\n+/g, `$&${indent}`);
  const body = foldFlowLines(`${start}${value}${end}`, indent, FOLD_BLOCK, getFoldOptions(ctx));
  return `${header}
${indent}${body}`;
}
function plainString(item, ctx, onComment, onChompKeep) {
  const { type, value } = item;
  const { actualString, implicitKey, indent, inFlow } = ctx;
  if (implicitKey && /[\n[\]{},]/.test(value) || inFlow && /[[\]{},]/.test(value)) {
    return quotedString(value, ctx);
  }
  if (!value || /^[\n\t ,[\]{}#&*!|>'"%@`]|^[?-]$|^[?-][ \t]|[\n:][ \t]|[ \t]\n|[\n\t ]#|[\n\t :]$/.test(value)) {
    return implicitKey || inFlow || value.indexOf("\n") === -1 ? quotedString(value, ctx) : blockString(item, ctx, onComment, onChompKeep);
  }
  if (!implicitKey && !inFlow && type !== Scalar.PLAIN && value.indexOf("\n") !== -1) {
    return blockString(item, ctx, onComment, onChompKeep);
  }
  if (indent === "" && containsDocumentMarker(value)) {
    ctx.forceBlockIndent = true;
    return blockString(item, ctx, onComment, onChompKeep);
  }
  const str = value.replace(/\n+/g, `$&
${indent}`);
  if (actualString) {
    const test = (tag2) => {
      var _a;
      return tag2.default && tag2.tag !== "tag:yaml.org,2002:str" && ((_a = tag2.test) === null || _a === void 0 ? void 0 : _a.test(str));
    };
    const { compat, tags } = ctx.doc.schema;
    if (tags.some(test) || (compat === null || compat === void 0 ? void 0 : compat.some(test)))
      return quotedString(value, ctx);
  }
  return implicitKey ? str : foldFlowLines(str, indent, FOLD_FLOW, getFoldOptions(ctx));
}
function stringifyString(item, ctx, onComment, onChompKeep) {
  const { implicitKey, inFlow } = ctx;
  const ss = typeof item.value === "string" ? item : Object.assign({}, item, { value: String(item.value) });
  let { type } = item;
  if (type !== Scalar.QUOTE_DOUBLE) {
    if (/[\x00-\x08\x0b-\x1f\x7f-\x9f\u{D800}-\u{DFFF}]/u.test(ss.value))
      type = Scalar.QUOTE_DOUBLE;
  }
  const _stringify = (_type) => {
    switch (_type) {
      case Scalar.BLOCK_FOLDED:
      case Scalar.BLOCK_LITERAL:
        return implicitKey || inFlow ? quotedString(ss.value, ctx) : blockString(ss, ctx, onComment, onChompKeep);
      case Scalar.QUOTE_DOUBLE:
        return doubleQuotedString(ss.value, ctx);
      case Scalar.QUOTE_SINGLE:
        return singleQuotedString(ss.value, ctx);
      case Scalar.PLAIN:
        return plainString(ss, ctx, onComment, onChompKeep);
      default:
        return null;
    }
  };
  let res = _stringify(type);
  if (res === null) {
    const { defaultKeyType, defaultStringType } = ctx.options;
    const t = implicitKey && defaultKeyType || defaultStringType;
    res = _stringify(t);
    if (res === null)
      throw new Error(`Unsupported default string type ${t}`);
  }
  return res;
}

// node_modules/yaml/browser/dist/stringify/stringify.js
function createStringifyContext(doc, options) {
  const opt = Object.assign({
    blockQuote: true,
    commentString: stringifyComment,
    defaultKeyType: null,
    defaultStringType: "PLAIN",
    directives: null,
    doubleQuotedAsJSON: false,
    doubleQuotedMinMultiLineLength: 40,
    falseStr: "false",
    indentSeq: true,
    lineWidth: 80,
    minContentWidth: 20,
    nullStr: "null",
    simpleKeys: false,
    singleQuote: null,
    trueStr: "true",
    verifyAliasOrder: true
  }, doc.schema.toStringOptions, options);
  let inFlow;
  switch (opt.collectionStyle) {
    case "block":
      inFlow = false;
      break;
    case "flow":
      inFlow = true;
      break;
    default:
      inFlow = null;
  }
  return {
    anchors: /* @__PURE__ */ new Set(),
    doc,
    indent: "",
    indentStep: typeof opt.indent === "number" ? " ".repeat(opt.indent) : "  ",
    inFlow,
    options: opt
  };
}
function getTagObject(tags, item) {
  if (item.tag) {
    const match = tags.filter((t) => t.tag === item.tag);
    if (match.length > 0)
      return match.find((t) => t.format === item.format) || match[0];
  }
  let tagObj = void 0;
  let obj;
  if (isScalar(item)) {
    obj = item.value;
    const match = tags.filter((t) => t.identify && t.identify(obj));
    tagObj = match.find((t) => t.format === item.format) || match.find((t) => !t.format);
  } else {
    obj = item;
    tagObj = tags.find((t) => t.nodeClass && obj instanceof t.nodeClass);
  }
  if (!tagObj) {
    const name = obj && obj.constructor ? obj.constructor.name : typeof obj;
    throw new Error(`Tag not resolved for ${name} value`);
  }
  return tagObj;
}
function stringifyProps(node, tagObj, { anchors, doc }) {
  if (!doc.directives)
    return "";
  const props = [];
  const anchor = (isScalar(node) || isCollection(node)) && node.anchor;
  if (anchor && anchorIsValid(anchor)) {
    anchors.add(anchor);
    props.push(`&${anchor}`);
  }
  const tag2 = node.tag || (tagObj.default ? null : tagObj.tag);
  if (tag2)
    props.push(doc.directives.tagString(tag2));
  return props.join(" ");
}
function stringify(item, ctx, onComment, onChompKeep) {
  var _a;
  if (isPair(item))
    return item.toString(ctx, onComment, onChompKeep);
  if (isAlias(item)) {
    if (ctx.doc.directives)
      return item.toString(ctx);
    if ((_a = ctx.resolvedAliases) === null || _a === void 0 ? void 0 : _a.has(item)) {
      throw new TypeError(`Cannot stringify circular structure without alias nodes`);
    } else {
      if (ctx.resolvedAliases)
        ctx.resolvedAliases.add(item);
      else
        ctx.resolvedAliases = /* @__PURE__ */ new Set([item]);
      item = item.resolve(ctx.doc);
    }
  }
  let tagObj = void 0;
  const node = isNode(item) ? item : ctx.doc.createNode(item, { onTagObj: (o) => tagObj = o });
  if (!tagObj)
    tagObj = getTagObject(ctx.doc.schema.tags, node);
  const props = stringifyProps(node, tagObj, ctx);
  if (props.length > 0)
    ctx.indentAtStart = (ctx.indentAtStart || 0) + props.length + 1;
  const str = typeof tagObj.stringify === "function" ? tagObj.stringify(node, ctx, onComment, onChompKeep) : isScalar(node) ? stringifyString(node, ctx, onComment, onChompKeep) : node.toString(ctx, onComment, onChompKeep);
  if (!props)
    return str;
  return isScalar(node) || str[0] === "{" || str[0] === "[" ? `${props} ${str}` : `${props}
${ctx.indent}${str}`;
}

// node_modules/yaml/browser/dist/stringify/stringifyPair.js
function stringifyPair({ key, value }, ctx, onComment, onChompKeep) {
  const { allNullValues, doc, indent, indentStep, options: { commentString, indentSeq, simpleKeys } } = ctx;
  let keyComment = isNode(key) && key.comment || null;
  if (simpleKeys) {
    if (keyComment) {
      throw new Error("With simple keys, key nodes cannot have comments");
    }
    if (isCollection(key)) {
      const msg = "With simple keys, collection cannot be used as a key value";
      throw new Error(msg);
    }
  }
  let explicitKey = !simpleKeys && (!key || keyComment && value == null && !ctx.inFlow || isCollection(key) || (isScalar(key) ? key.type === Scalar.BLOCK_FOLDED || key.type === Scalar.BLOCK_LITERAL : typeof key === "object"));
  ctx = Object.assign({}, ctx, {
    allNullValues: false,
    implicitKey: !explicitKey && (simpleKeys || !allNullValues),
    indent: indent + indentStep
  });
  let keyCommentDone = false;
  let chompKeep = false;
  let str = stringify(key, ctx, () => keyCommentDone = true, () => chompKeep = true);
  if (!explicitKey && !ctx.inFlow && str.length > 1024) {
    if (simpleKeys)
      throw new Error("With simple keys, single line scalar must not span more than 1024 characters");
    explicitKey = true;
  }
  if (ctx.inFlow) {
    if (allNullValues || value == null) {
      if (keyCommentDone && onComment)
        onComment();
      return explicitKey ? `? ${str}` : str;
    }
  } else if (allNullValues && !simpleKeys || value == null && explicitKey) {
    str = `? ${str}`;
    if (keyComment && !keyCommentDone) {
      str += lineComment(str, ctx.indent, commentString(keyComment));
    } else if (chompKeep && onChompKeep)
      onChompKeep();
    return str;
  }
  if (keyCommentDone)
    keyComment = null;
  if (explicitKey) {
    if (keyComment)
      str += lineComment(str, ctx.indent, commentString(keyComment));
    str = `? ${str}
${indent}:`;
  } else {
    str = `${str}:`;
    if (keyComment)
      str += lineComment(str, ctx.indent, commentString(keyComment));
  }
  let vcb = "";
  let valueComment = null;
  if (isNode(value)) {
    if (value.spaceBefore)
      vcb = "\n";
    if (value.commentBefore) {
      const cs = commentString(value.commentBefore);
      vcb += `
${indentComment(cs, ctx.indent)}`;
    }
    valueComment = value.comment;
  } else if (value && typeof value === "object") {
    value = doc.createNode(value);
  }
  ctx.implicitKey = false;
  if (!explicitKey && !keyComment && isScalar(value))
    ctx.indentAtStart = str.length + 1;
  chompKeep = false;
  if (!indentSeq && indentStep.length >= 2 && !ctx.inFlow && !explicitKey && isSeq(value) && !value.flow && !value.tag && !value.anchor) {
    ctx.indent = ctx.indent.substr(2);
  }
  let valueCommentDone = false;
  const valueStr = stringify(value, ctx, () => valueCommentDone = true, () => chompKeep = true);
  let ws = " ";
  if (vcb || keyComment) {
    ws = valueStr === "" && !ctx.inFlow ? vcb : `${vcb}
${ctx.indent}`;
  } else if (!explicitKey && isCollection(value)) {
    const flow = valueStr[0] === "[" || valueStr[0] === "{";
    if (!flow || valueStr.includes("\n"))
      ws = `
${ctx.indent}`;
  } else if (valueStr === "" || valueStr[0] === "\n")
    ws = "";
  str += ws + valueStr;
  if (ctx.inFlow) {
    if (valueCommentDone && onComment)
      onComment();
  } else if (valueComment && !valueCommentDone) {
    str += lineComment(str, ctx.indent, commentString(valueComment));
  } else if (chompKeep && onChompKeep) {
    onChompKeep();
  }
  return str;
}

// node_modules/yaml/browser/dist/log.js
function warn(logLevel, warning) {
  if (logLevel === "debug" || logLevel === "warn") {
    if (typeof process !== "undefined" && process.emitWarning)
      process.emitWarning(warning);
    else
      console.warn(warning);
  }
}

// node_modules/yaml/browser/dist/nodes/addPairToJSMap.js
var MERGE_KEY = "<<";
function addPairToJSMap(ctx, map2, { key, value }) {
  if (ctx && ctx.doc.schema.merge && isMergeKey(key)) {
    value = isAlias(value) ? value.resolve(ctx.doc) : value;
    if (isSeq(value))
      for (const it of value.items)
        mergeToJSMap(ctx, map2, it);
    else if (Array.isArray(value))
      for (const it of value)
        mergeToJSMap(ctx, map2, it);
    else
      mergeToJSMap(ctx, map2, value);
  } else {
    const jsKey = toJS(key, "", ctx);
    if (map2 instanceof Map) {
      map2.set(jsKey, toJS(value, jsKey, ctx));
    } else if (map2 instanceof Set) {
      map2.add(jsKey);
    } else {
      const stringKey = stringifyKey(key, jsKey, ctx);
      const jsValue = toJS(value, stringKey, ctx);
      if (stringKey in map2)
        Object.defineProperty(map2, stringKey, {
          value: jsValue,
          writable: true,
          enumerable: true,
          configurable: true
        });
      else
        map2[stringKey] = jsValue;
    }
  }
  return map2;
}
var isMergeKey = (key) => key === MERGE_KEY || isScalar(key) && key.value === MERGE_KEY && (!key.type || key.type === Scalar.PLAIN);
function mergeToJSMap(ctx, map2, value) {
  const source = ctx && isAlias(value) ? value.resolve(ctx.doc) : value;
  if (!isMap(source))
    throw new Error("Merge sources must be maps or map aliases");
  const srcMap = source.toJSON(null, ctx, Map);
  for (const [key, value2] of srcMap) {
    if (map2 instanceof Map) {
      if (!map2.has(key))
        map2.set(key, value2);
    } else if (map2 instanceof Set) {
      map2.add(key);
    } else if (!Object.prototype.hasOwnProperty.call(map2, key)) {
      Object.defineProperty(map2, key, {
        value: value2,
        writable: true,
        enumerable: true,
        configurable: true
      });
    }
  }
  return map2;
}
function stringifyKey(key, jsKey, ctx) {
  if (jsKey === null)
    return "";
  if (typeof jsKey !== "object")
    return String(jsKey);
  if (isNode(key) && ctx && ctx.doc) {
    const strCtx = createStringifyContext(ctx.doc, {});
    strCtx.anchors = /* @__PURE__ */ new Set();
    for (const node of ctx.anchors.keys())
      strCtx.anchors.add(node.anchor);
    strCtx.inFlow = true;
    strCtx.inStringifyKey = true;
    const strKey = key.toString(strCtx);
    if (!ctx.mapKeyWarned) {
      let jsonStr = JSON.stringify(strKey);
      if (jsonStr.length > 40)
        jsonStr = jsonStr.substring(0, 36) + '..."';
      warn(ctx.doc.options.logLevel, `Keys with collection values will be stringified due to JS Object restrictions: ${jsonStr}. Set mapAsMap: true to use object keys.`);
      ctx.mapKeyWarned = true;
    }
    return strKey;
  }
  return JSON.stringify(jsKey);
}

// node_modules/yaml/browser/dist/nodes/Pair.js
function createPair(key, value, ctx) {
  const k = createNode(key, void 0, ctx);
  const v = createNode(value, void 0, ctx);
  return new Pair(k, v);
}
var Pair = class {
  constructor(key, value = null) {
    Object.defineProperty(this, NODE_TYPE, { value: PAIR });
    this.key = key;
    this.value = value;
  }
  clone(schema4) {
    let { key, value } = this;
    if (isNode(key))
      key = key.clone(schema4);
    if (isNode(value))
      value = value.clone(schema4);
    return new Pair(key, value);
  }
  toJSON(_, ctx) {
    const pair = ctx && ctx.mapAsMap ? /* @__PURE__ */ new Map() : {};
    return addPairToJSMap(ctx, pair, this);
  }
  toString(ctx, onComment, onChompKeep) {
    return ctx && ctx.doc ? stringifyPair(this, ctx, onComment, onChompKeep) : JSON.stringify(this);
  }
};

// node_modules/yaml/browser/dist/options.js
var defaultOptions = {
  intAsBigInt: false,
  keepSourceTokens: false,
  logLevel: "warn",
  prettyErrors: true,
  strict: true,
  uniqueKeys: true,
  version: "1.2"
};

// node_modules/yaml/browser/dist/stringify/stringifyCollection.js
function stringifyCollection(collection, ctx, options) {
  var _a;
  const flow = (_a = ctx.inFlow) !== null && _a !== void 0 ? _a : collection.flow;
  const stringify4 = flow ? stringifyFlowCollection : stringifyBlockCollection;
  return stringify4(collection, ctx, options);
}
function stringifyBlockCollection({ comment, items }, ctx, { blockItemPrefix, flowChars, itemIndent, onChompKeep, onComment }) {
  const { indent, options: { commentString } } = ctx;
  const itemCtx = Object.assign({}, ctx, { indent: itemIndent, type: null });
  let chompKeep = false;
  const lines = [];
  for (let i = 0; i < items.length; ++i) {
    const item = items[i];
    let comment2 = null;
    if (isNode(item)) {
      if (!chompKeep && item.spaceBefore)
        lines.push("");
      addCommentBefore(ctx, lines, item.commentBefore, chompKeep);
      if (item.comment)
        comment2 = item.comment;
    } else if (isPair(item)) {
      const ik = isNode(item.key) ? item.key : null;
      if (ik) {
        if (!chompKeep && ik.spaceBefore)
          lines.push("");
        addCommentBefore(ctx, lines, ik.commentBefore, chompKeep);
      }
    }
    chompKeep = false;
    let str2 = stringify(item, itemCtx, () => comment2 = null, () => chompKeep = true);
    if (comment2)
      str2 += lineComment(str2, itemIndent, commentString(comment2));
    if (chompKeep && comment2)
      chompKeep = false;
    lines.push(blockItemPrefix + str2);
  }
  let str;
  if (lines.length === 0) {
    str = flowChars.start + flowChars.end;
  } else {
    str = lines[0];
    for (let i = 1; i < lines.length; ++i) {
      const line = lines[i];
      str += line ? `
${indent}${line}` : "\n";
    }
  }
  if (comment) {
    str += "\n" + indentComment(commentString(comment), indent);
    if (onComment)
      onComment();
  } else if (chompKeep && onChompKeep)
    onChompKeep();
  return str;
}
function stringifyFlowCollection({ comment, items }, ctx, { flowChars, itemIndent, onComment }) {
  const { indent, indentStep, options: { commentString } } = ctx;
  itemIndent += indentStep;
  const itemCtx = Object.assign({}, ctx, {
    indent: itemIndent,
    inFlow: true,
    type: null
  });
  let reqNewline = false;
  let linesAtValue = 0;
  const lines = [];
  for (let i = 0; i < items.length; ++i) {
    const item = items[i];
    let comment2 = null;
    if (isNode(item)) {
      if (item.spaceBefore)
        lines.push("");
      addCommentBefore(ctx, lines, item.commentBefore, false);
      if (item.comment)
        comment2 = item.comment;
    } else if (isPair(item)) {
      const ik = isNode(item.key) ? item.key : null;
      if (ik) {
        if (ik.spaceBefore)
          lines.push("");
        addCommentBefore(ctx, lines, ik.commentBefore, false);
        if (ik.comment)
          reqNewline = true;
      }
      const iv = isNode(item.value) ? item.value : null;
      if (iv) {
        if (iv.comment)
          comment2 = iv.comment;
        if (iv.commentBefore)
          reqNewline = true;
      } else if (item.value == null && ik && ik.comment) {
        comment2 = ik.comment;
      }
    }
    if (comment2)
      reqNewline = true;
    let str2 = stringify(item, itemCtx, () => comment2 = null);
    if (i < items.length - 1)
      str2 += ",";
    if (comment2)
      str2 += lineComment(str2, itemIndent, commentString(comment2));
    if (!reqNewline && (lines.length > linesAtValue || str2.includes("\n")))
      reqNewline = true;
    lines.push(str2);
    linesAtValue = lines.length;
  }
  let str;
  const { start, end } = flowChars;
  if (lines.length === 0) {
    str = start + end;
  } else {
    if (!reqNewline) {
      const len = lines.reduce((sum, line) => sum + line.length + 2, 2);
      reqNewline = len > Collection.maxFlowStringSingleLineLength;
    }
    if (reqNewline) {
      str = start;
      for (const line of lines)
        str += line ? `
${indentStep}${indent}${line}` : "\n";
      str += `
${indent}${end}`;
    } else {
      str = `${start} ${lines.join(" ")} ${end}`;
    }
  }
  if (comment) {
    str += lineComment(str, commentString(comment), indent);
    if (onComment)
      onComment();
  }
  return str;
}
function addCommentBefore({ indent, options: { commentString } }, lines, comment, chompKeep) {
  if (comment && chompKeep)
    comment = comment.replace(/^\n+/, "");
  if (comment) {
    const ic = indentComment(commentString(comment), indent);
    lines.push(ic.trimStart());
  }
}

// node_modules/yaml/browser/dist/nodes/YAMLMap.js
function findPair(items, key) {
  const k = isScalar(key) ? key.value : key;
  for (const it of items) {
    if (isPair(it)) {
      if (it.key === key || it.key === k)
        return it;
      if (isScalar(it.key) && it.key.value === k)
        return it;
    }
  }
  return void 0;
}
var YAMLMap = class extends Collection {
  constructor(schema4) {
    super(MAP, schema4);
    this.items = [];
  }
  static get tagName() {
    return "tag:yaml.org,2002:map";
  }
  /**
   * Adds a value to the collection.
   *
   * @param overwrite - If not set `true`, using a key that is already in the
   *   collection will throw. Otherwise, overwrites the previous value.
   */
  add(pair, overwrite) {
    let _pair;
    if (isPair(pair))
      _pair = pair;
    else if (!pair || typeof pair !== "object" || !("key" in pair)) {
      _pair = new Pair(pair, pair.value);
    } else
      _pair = new Pair(pair.key, pair.value);
    const prev = findPair(this.items, _pair.key);
    const sortEntries = this.schema && this.schema.sortMapEntries;
    if (prev) {
      if (!overwrite)
        throw new Error(`Key ${_pair.key} already set`);
      if (isScalar(prev.value) && isScalarValue(_pair.value))
        prev.value.value = _pair.value;
      else
        prev.value = _pair.value;
    } else if (sortEntries) {
      const i = this.items.findIndex((item) => sortEntries(_pair, item) < 0);
      if (i === -1)
        this.items.push(_pair);
      else
        this.items.splice(i, 0, _pair);
    } else {
      this.items.push(_pair);
    }
  }
  delete(key) {
    const it = findPair(this.items, key);
    if (!it)
      return false;
    const del = this.items.splice(this.items.indexOf(it), 1);
    return del.length > 0;
  }
  get(key, keepScalar) {
    const it = findPair(this.items, key);
    const node = it && it.value;
    return !keepScalar && isScalar(node) ? node.value : node;
  }
  has(key) {
    return !!findPair(this.items, key);
  }
  set(key, value) {
    this.add(new Pair(key, value), true);
  }
  /**
   * @param ctx - Conversion context, originally set in Document#toJS()
   * @param {Class} Type - If set, forces the returned collection type
   * @returns Instance of Type, Map, or Object
   */
  toJSON(_, ctx, Type) {
    const map2 = Type ? new Type() : ctx && ctx.mapAsMap ? /* @__PURE__ */ new Map() : {};
    if (ctx && ctx.onCreate)
      ctx.onCreate(map2);
    for (const item of this.items)
      addPairToJSMap(ctx, map2, item);
    return map2;
  }
  toString(ctx, onComment, onChompKeep) {
    if (!ctx)
      return JSON.stringify(this);
    for (const item of this.items) {
      if (!isPair(item))
        throw new Error(`Map items must all be pairs; found ${JSON.stringify(item)} instead`);
    }
    if (!ctx.allNullValues && this.hasAllNullValues(false))
      ctx = Object.assign({}, ctx, { allNullValues: true });
    return stringifyCollection(this, ctx, {
      blockItemPrefix: "",
      flowChars: { start: "{", end: "}" },
      itemIndent: ctx.indent || "",
      onChompKeep,
      onComment
    });
  }
};

// node_modules/yaml/browser/dist/schema/common/map.js
function createMap(schema4, obj, ctx) {
  const { keepUndefined, replacer } = ctx;
  const map2 = new YAMLMap(schema4);
  const add = (key, value) => {
    if (typeof replacer === "function")
      value = replacer.call(obj, key, value);
    else if (Array.isArray(replacer) && !replacer.includes(key))
      return;
    if (value !== void 0 || keepUndefined)
      map2.items.push(createPair(key, value, ctx));
  };
  if (obj instanceof Map) {
    for (const [key, value] of obj)
      add(key, value);
  } else if (obj && typeof obj === "object") {
    for (const key of Object.keys(obj))
      add(key, obj[key]);
  }
  if (typeof schema4.sortMapEntries === "function") {
    map2.items.sort(schema4.sortMapEntries);
  }
  return map2;
}
var map = {
  collection: "map",
  createNode: createMap,
  default: true,
  nodeClass: YAMLMap,
  tag: "tag:yaml.org,2002:map",
  resolve(map2, onError) {
    if (!isMap(map2))
      onError("Expected a mapping for this tag");
    return map2;
  }
};

// node_modules/yaml/browser/dist/nodes/YAMLSeq.js
var YAMLSeq = class extends Collection {
  constructor(schema4) {
    super(SEQ, schema4);
    this.items = [];
  }
  static get tagName() {
    return "tag:yaml.org,2002:seq";
  }
  add(value) {
    this.items.push(value);
  }
  /**
   * Removes a value from the collection.
   *
   * `key` must contain a representation of an integer for this to succeed.
   * It may be wrapped in a `Scalar`.
   *
   * @returns `true` if the item was found and removed.
   */
  delete(key) {
    const idx = asItemIndex(key);
    if (typeof idx !== "number")
      return false;
    const del = this.items.splice(idx, 1);
    return del.length > 0;
  }
  /**
   * Returns item at `key`, or `undefined` if not found. By default unwraps
   * scalar values from their surrounding node; to disable set `keepScalar` to
   * `true` (collections are always returned intact).
   *
   * `key` must contain a representation of an integer for this to succeed.
   * It may be wrapped in a `Scalar`.
   */
  get(key, keepScalar) {
    const idx = asItemIndex(key);
    if (typeof idx !== "number")
      return void 0;
    const it = this.items[idx];
    return !keepScalar && isScalar(it) ? it.value : it;
  }
  /**
   * Checks if the collection includes a value with the key `key`.
   *
   * `key` must contain a representation of an integer for this to succeed.
   * It may be wrapped in a `Scalar`.
   */
  has(key) {
    const idx = asItemIndex(key);
    return typeof idx === "number" && idx < this.items.length;
  }
  /**
   * Sets a value in this collection. For `!!set`, `value` needs to be a
   * boolean to add/remove the item from the set.
   *
   * If `key` does not contain a representation of an integer, this will throw.
   * It may be wrapped in a `Scalar`.
   */
  set(key, value) {
    const idx = asItemIndex(key);
    if (typeof idx !== "number")
      throw new Error(`Expected a valid index, not ${key}.`);
    const prev = this.items[idx];
    if (isScalar(prev) && isScalarValue(value))
      prev.value = value;
    else
      this.items[idx] = value;
  }
  toJSON(_, ctx) {
    const seq2 = [];
    if (ctx && ctx.onCreate)
      ctx.onCreate(seq2);
    let i = 0;
    for (const item of this.items)
      seq2.push(toJS(item, String(i++), ctx));
    return seq2;
  }
  toString(ctx, onComment, onChompKeep) {
    if (!ctx)
      return JSON.stringify(this);
    return stringifyCollection(this, ctx, {
      blockItemPrefix: "- ",
      flowChars: { start: "[", end: "]" },
      itemIndent: (ctx.indent || "") + "  ",
      onChompKeep,
      onComment
    });
  }
};
function asItemIndex(key) {
  let idx = isScalar(key) ? key.value : key;
  if (idx && typeof idx === "string")
    idx = Number(idx);
  return typeof idx === "number" && Number.isInteger(idx) && idx >= 0 ? idx : null;
}

// node_modules/yaml/browser/dist/schema/common/seq.js
function createSeq(schema4, obj, ctx) {
  const { replacer } = ctx;
  const seq2 = new YAMLSeq(schema4);
  if (obj && Symbol.iterator in Object(obj)) {
    let i = 0;
    for (let it of obj) {
      if (typeof replacer === "function") {
        const key = obj instanceof Set ? it : String(i++);
        it = replacer.call(obj, key, it);
      }
      seq2.items.push(createNode(it, void 0, ctx));
    }
  }
  return seq2;
}
var seq = {
  collection: "seq",
  createNode: createSeq,
  default: true,
  nodeClass: YAMLSeq,
  tag: "tag:yaml.org,2002:seq",
  resolve(seq2, onError) {
    if (!isSeq(seq2))
      onError("Expected a sequence for this tag");
    return seq2;
  }
};

// node_modules/yaml/browser/dist/schema/common/string.js
var string = {
  identify: (value) => typeof value === "string",
  default: true,
  tag: "tag:yaml.org,2002:str",
  resolve: (str) => str,
  stringify(item, ctx, onComment, onChompKeep) {
    ctx = Object.assign({ actualString: true }, ctx);
    return stringifyString(item, ctx, onComment, onChompKeep);
  }
};

// node_modules/yaml/browser/dist/schema/common/null.js
var nullTag = {
  identify: (value) => value == null,
  createNode: () => new Scalar(null),
  default: true,
  tag: "tag:yaml.org,2002:null",
  test: /^(?:~|[Nn]ull|NULL)?$/,
  resolve: () => new Scalar(null),
  stringify: ({ source }, ctx) => source && nullTag.test.test(source) ? source : ctx.options.nullStr
};

// node_modules/yaml/browser/dist/schema/core/bool.js
var boolTag = {
  identify: (value) => typeof value === "boolean",
  default: true,
  tag: "tag:yaml.org,2002:bool",
  test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,
  resolve: (str) => new Scalar(str[0] === "t" || str[0] === "T"),
  stringify({ source, value }, ctx) {
    if (source && boolTag.test.test(source)) {
      const sv = source[0] === "t" || source[0] === "T";
      if (value === sv)
        return source;
    }
    return value ? ctx.options.trueStr : ctx.options.falseStr;
  }
};

// node_modules/yaml/browser/dist/stringify/stringifyNumber.js
function stringifyNumber({ format, minFractionDigits, tag: tag2, value }) {
  if (typeof value === "bigint")
    return String(value);
  const num = typeof value === "number" ? value : Number(value);
  if (!isFinite(num))
    return isNaN(num) ? ".nan" : num < 0 ? "-.inf" : ".inf";
  let n = JSON.stringify(value);
  if (!format && minFractionDigits && (!tag2 || tag2 === "tag:yaml.org,2002:float") && /^\d/.test(n)) {
    let i = n.indexOf(".");
    if (i < 0) {
      i = n.length;
      n += ".";
    }
    let d = minFractionDigits - (n.length - i - 1);
    while (d-- > 0)
      n += "0";
  }
  return n;
}

// node_modules/yaml/browser/dist/schema/core/float.js
var floatNaN = {
  identify: (value) => typeof value === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  test: /^(?:[-+]?\.(?:inf|Inf|INF|nan|NaN|NAN))$/,
  resolve: (str) => str.slice(-3).toLowerCase() === "nan" ? NaN : str[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
  stringify: stringifyNumber
};
var floatExp = {
  identify: (value) => typeof value === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  format: "EXP",
  test: /^[-+]?(?:\.[0-9]+|[0-9]+(?:\.[0-9]*)?)[eE][-+]?[0-9]+$/,
  resolve: (str) => parseFloat(str),
  stringify(node) {
    const num = Number(node.value);
    return isFinite(num) ? num.toExponential() : stringifyNumber(node);
  }
};
var float = {
  identify: (value) => typeof value === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  test: /^[-+]?(?:\.[0-9]+|[0-9]+\.[0-9]*)$/,
  resolve(str) {
    const node = new Scalar(parseFloat(str));
    const dot = str.indexOf(".");
    if (dot !== -1 && str[str.length - 1] === "0")
      node.minFractionDigits = str.length - dot - 1;
    return node;
  },
  stringify: stringifyNumber
};

// node_modules/yaml/browser/dist/schema/core/int.js
var intIdentify = (value) => typeof value === "bigint" || Number.isInteger(value);
var intResolve = (str, offset, radix, { intAsBigInt }) => intAsBigInt ? BigInt(str) : parseInt(str.substring(offset), radix);
function intStringify(node, radix, prefix) {
  const { value } = node;
  if (intIdentify(value) && value >= 0)
    return prefix + value.toString(radix);
  return stringifyNumber(node);
}
var intOct = {
  identify: (value) => intIdentify(value) && value >= 0,
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "OCT",
  test: /^0o[0-7]+$/,
  resolve: (str, _onError, opt) => intResolve(str, 2, 8, opt),
  stringify: (node) => intStringify(node, 8, "0o")
};
var int = {
  identify: intIdentify,
  default: true,
  tag: "tag:yaml.org,2002:int",
  test: /^[-+]?[0-9]+$/,
  resolve: (str, _onError, opt) => intResolve(str, 0, 10, opt),
  stringify: stringifyNumber
};
var intHex = {
  identify: (value) => intIdentify(value) && value >= 0,
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "HEX",
  test: /^0x[0-9a-fA-F]+$/,
  resolve: (str, _onError, opt) => intResolve(str, 2, 16, opt),
  stringify: (node) => intStringify(node, 16, "0x")
};

// node_modules/yaml/browser/dist/schema/core/schema.js
var schema = [
  map,
  seq,
  string,
  nullTag,
  boolTag,
  intOct,
  int,
  intHex,
  floatNaN,
  floatExp,
  float
];

// node_modules/yaml/browser/dist/schema/json/schema.js
function intIdentify2(value) {
  return typeof value === "bigint" || Number.isInteger(value);
}
var stringifyJSON = ({ value }) => JSON.stringify(value);
var jsonScalars = [
  {
    identify: (value) => typeof value === "string",
    default: true,
    tag: "tag:yaml.org,2002:str",
    resolve: (str) => str,
    stringify: stringifyJSON
  },
  {
    identify: (value) => value == null,
    createNode: () => new Scalar(null),
    default: true,
    tag: "tag:yaml.org,2002:null",
    test: /^null$/,
    resolve: () => null,
    stringify: stringifyJSON
  },
  {
    identify: (value) => typeof value === "boolean",
    default: true,
    tag: "tag:yaml.org,2002:bool",
    test: /^true|false$/,
    resolve: (str) => str === "true",
    stringify: stringifyJSON
  },
  {
    identify: intIdentify2,
    default: true,
    tag: "tag:yaml.org,2002:int",
    test: /^-?(?:0|[1-9][0-9]*)$/,
    resolve: (str, _onError, { intAsBigInt }) => intAsBigInt ? BigInt(str) : parseInt(str, 10),
    stringify: ({ value }) => intIdentify2(value) ? value.toString() : JSON.stringify(value)
  },
  {
    identify: (value) => typeof value === "number",
    default: true,
    tag: "tag:yaml.org,2002:float",
    test: /^-?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,
    resolve: (str) => parseFloat(str),
    stringify: stringifyJSON
  }
];
var jsonError = {
  default: true,
  tag: "",
  test: /^/,
  resolve(str, onError) {
    onError(`Unresolved plain scalar ${JSON.stringify(str)}`);
    return str;
  }
};
var schema2 = [map, seq].concat(jsonScalars, jsonError);

// node_modules/yaml/browser/dist/schema/yaml-1.1/binary.js
var binary = {
  identify: (value) => value instanceof Uint8Array,
  default: false,
  tag: "tag:yaml.org,2002:binary",
  /**
   * Returns a Buffer in node and an Uint8Array in browsers
   *
   * To use the resulting buffer as an image, you'll want to do something like:
   *
   *   const blob = new Blob([buffer], { type: 'image/jpeg' })
   *   document.querySelector('#photo').src = URL.createObjectURL(blob)
   */
  resolve(src, onError) {
    if (typeof Buffer === "function") {
      return Buffer.from(src, "base64");
    } else if (typeof atob === "function") {
      const str = atob(src.replace(/[\n\r]/g, ""));
      const buffer = new Uint8Array(str.length);
      for (let i = 0; i < str.length; ++i)
        buffer[i] = str.charCodeAt(i);
      return buffer;
    } else {
      onError("This environment does not support reading binary tags; either Buffer or atob is required");
      return src;
    }
  },
  stringify({ comment, type, value }, ctx, onComment, onChompKeep) {
    const buf = value;
    let str;
    if (typeof Buffer === "function") {
      str = buf instanceof Buffer ? buf.toString("base64") : Buffer.from(buf.buffer).toString("base64");
    } else if (typeof btoa === "function") {
      let s = "";
      for (let i = 0; i < buf.length; ++i)
        s += String.fromCharCode(buf[i]);
      str = btoa(s);
    } else {
      throw new Error("This environment does not support writing binary tags; either Buffer or btoa is required");
    }
    if (!type)
      type = Scalar.BLOCK_LITERAL;
    if (type !== Scalar.QUOTE_DOUBLE) {
      const lineWidth = Math.max(ctx.options.lineWidth - ctx.indent.length, ctx.options.minContentWidth);
      const n = Math.ceil(str.length / lineWidth);
      const lines = new Array(n);
      for (let i = 0, o = 0; i < n; ++i, o += lineWidth) {
        lines[i] = str.substr(o, lineWidth);
      }
      str = lines.join(type === Scalar.BLOCK_LITERAL ? "\n" : " ");
    }
    return stringifyString({ comment, type, value: str }, ctx, onComment, onChompKeep);
  }
};

// node_modules/yaml/browser/dist/schema/yaml-1.1/pairs.js
function resolvePairs(seq2, onError) {
  if (isSeq(seq2)) {
    for (let i = 0; i < seq2.items.length; ++i) {
      let item = seq2.items[i];
      if (isPair(item))
        continue;
      else if (isMap(item)) {
        if (item.items.length > 1)
          onError("Each pair must have its own sequence indicator");
        const pair = item.items[0] || new Pair(new Scalar(null));
        if (item.commentBefore)
          pair.key.commentBefore = pair.key.commentBefore ? `${item.commentBefore}
${pair.key.commentBefore}` : item.commentBefore;
        if (item.comment) {
          const cn = pair.value || pair.key;
          cn.comment = cn.comment ? `${item.comment}
${cn.comment}` : item.comment;
        }
        item = pair;
      }
      seq2.items[i] = isPair(item) ? item : new Pair(item);
    }
  } else
    onError("Expected a sequence for this tag");
  return seq2;
}
function createPairs(schema4, iterable, ctx) {
  const { replacer } = ctx;
  const pairs2 = new YAMLSeq(schema4);
  pairs2.tag = "tag:yaml.org,2002:pairs";
  let i = 0;
  if (iterable && Symbol.iterator in Object(iterable))
    for (let it of iterable) {
      if (typeof replacer === "function")
        it = replacer.call(iterable, String(i++), it);
      let key, value;
      if (Array.isArray(it)) {
        if (it.length === 2) {
          key = it[0];
          value = it[1];
        } else
          throw new TypeError(`Expected [key, value] tuple: ${it}`);
      } else if (it && it instanceof Object) {
        const keys = Object.keys(it);
        if (keys.length === 1) {
          key = keys[0];
          value = it[key];
        } else
          throw new TypeError(`Expected { key: value } tuple: ${it}`);
      } else {
        key = it;
      }
      pairs2.items.push(createPair(key, value, ctx));
    }
  return pairs2;
}
var pairs = {
  collection: "seq",
  default: false,
  tag: "tag:yaml.org,2002:pairs",
  resolve: resolvePairs,
  createNode: createPairs
};

// node_modules/yaml/browser/dist/schema/yaml-1.1/omap.js
var YAMLOMap = class extends YAMLSeq {
  constructor() {
    super();
    this.add = YAMLMap.prototype.add.bind(this);
    this.delete = YAMLMap.prototype.delete.bind(this);
    this.get = YAMLMap.prototype.get.bind(this);
    this.has = YAMLMap.prototype.has.bind(this);
    this.set = YAMLMap.prototype.set.bind(this);
    this.tag = YAMLOMap.tag;
  }
  /**
   * If `ctx` is given, the return type is actually `Map<unknown, unknown>`,
   * but TypeScript won't allow widening the signature of a child method.
   */
  toJSON(_, ctx) {
    if (!ctx)
      return super.toJSON(_);
    const map2 = /* @__PURE__ */ new Map();
    if (ctx && ctx.onCreate)
      ctx.onCreate(map2);
    for (const pair of this.items) {
      let key, value;
      if (isPair(pair)) {
        key = toJS(pair.key, "", ctx);
        value = toJS(pair.value, key, ctx);
      } else {
        key = toJS(pair, "", ctx);
      }
      if (map2.has(key))
        throw new Error("Ordered maps must not include duplicate keys");
      map2.set(key, value);
    }
    return map2;
  }
};
YAMLOMap.tag = "tag:yaml.org,2002:omap";
var omap = {
  collection: "seq",
  identify: (value) => value instanceof Map,
  nodeClass: YAMLOMap,
  default: false,
  tag: "tag:yaml.org,2002:omap",
  resolve(seq2, onError) {
    const pairs2 = resolvePairs(seq2, onError);
    const seenKeys = [];
    for (const { key } of pairs2.items) {
      if (isScalar(key)) {
        if (seenKeys.includes(key.value)) {
          onError(`Ordered maps must not include duplicate keys: ${key.value}`);
        } else {
          seenKeys.push(key.value);
        }
      }
    }
    return Object.assign(new YAMLOMap(), pairs2);
  },
  createNode(schema4, iterable, ctx) {
    const pairs2 = createPairs(schema4, iterable, ctx);
    const omap2 = new YAMLOMap();
    omap2.items = pairs2.items;
    return omap2;
  }
};

// node_modules/yaml/browser/dist/schema/yaml-1.1/bool.js
function boolStringify({ value, source }, ctx) {
  const boolObj = value ? trueTag : falseTag;
  if (source && boolObj.test.test(source))
    return source;
  return value ? ctx.options.trueStr : ctx.options.falseStr;
}
var trueTag = {
  identify: (value) => value === true,
  default: true,
  tag: "tag:yaml.org,2002:bool",
  test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,
  resolve: () => new Scalar(true),
  stringify: boolStringify
};
var falseTag = {
  identify: (value) => value === false,
  default: true,
  tag: "tag:yaml.org,2002:bool",
  test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/i,
  resolve: () => new Scalar(false),
  stringify: boolStringify
};

// node_modules/yaml/browser/dist/schema/yaml-1.1/float.js
var floatNaN2 = {
  identify: (value) => typeof value === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  test: /^[-+]?\.(?:inf|Inf|INF|nan|NaN|NAN)$/,
  resolve: (str) => str.slice(-3).toLowerCase() === "nan" ? NaN : str[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
  stringify: stringifyNumber
};
var floatExp2 = {
  identify: (value) => typeof value === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  format: "EXP",
  test: /^[-+]?(?:[0-9][0-9_]*)?(?:\.[0-9_]*)?[eE][-+]?[0-9]+$/,
  resolve: (str) => parseFloat(str.replace(/_/g, "")),
  stringify(node) {
    const num = Number(node.value);
    return isFinite(num) ? num.toExponential() : stringifyNumber(node);
  }
};
var float2 = {
  identify: (value) => typeof value === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  test: /^[-+]?(?:[0-9][0-9_]*)?\.[0-9_]*$/,
  resolve(str) {
    const node = new Scalar(parseFloat(str.replace(/_/g, "")));
    const dot = str.indexOf(".");
    if (dot !== -1) {
      const f = str.substring(dot + 1).replace(/_/g, "");
      if (f[f.length - 1] === "0")
        node.minFractionDigits = f.length;
    }
    return node;
  },
  stringify: stringifyNumber
};

// node_modules/yaml/browser/dist/schema/yaml-1.1/int.js
var intIdentify3 = (value) => typeof value === "bigint" || Number.isInteger(value);
function intResolve2(str, offset, radix, { intAsBigInt }) {
  const sign = str[0];
  if (sign === "-" || sign === "+")
    offset += 1;
  str = str.substring(offset).replace(/_/g, "");
  if (intAsBigInt) {
    switch (radix) {
      case 2:
        str = `0b${str}`;
        break;
      case 8:
        str = `0o${str}`;
        break;
      case 16:
        str = `0x${str}`;
        break;
    }
    const n2 = BigInt(str);
    return sign === "-" ? BigInt(-1) * n2 : n2;
  }
  const n = parseInt(str, radix);
  return sign === "-" ? -1 * n : n;
}
function intStringify2(node, radix, prefix) {
  const { value } = node;
  if (intIdentify3(value)) {
    const str = value.toString(radix);
    return value < 0 ? "-" + prefix + str.substr(1) : prefix + str;
  }
  return stringifyNumber(node);
}
var intBin = {
  identify: intIdentify3,
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "BIN",
  test: /^[-+]?0b[0-1_]+$/,
  resolve: (str, _onError, opt) => intResolve2(str, 2, 2, opt),
  stringify: (node) => intStringify2(node, 2, "0b")
};
var intOct2 = {
  identify: intIdentify3,
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "OCT",
  test: /^[-+]?0[0-7_]+$/,
  resolve: (str, _onError, opt) => intResolve2(str, 1, 8, opt),
  stringify: (node) => intStringify2(node, 8, "0")
};
var int2 = {
  identify: intIdentify3,
  default: true,
  tag: "tag:yaml.org,2002:int",
  test: /^[-+]?[0-9][0-9_]*$/,
  resolve: (str, _onError, opt) => intResolve2(str, 0, 10, opt),
  stringify: stringifyNumber
};
var intHex2 = {
  identify: intIdentify3,
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "HEX",
  test: /^[-+]?0x[0-9a-fA-F_]+$/,
  resolve: (str, _onError, opt) => intResolve2(str, 2, 16, opt),
  stringify: (node) => intStringify2(node, 16, "0x")
};

// node_modules/yaml/browser/dist/schema/yaml-1.1/set.js
var YAMLSet = class extends YAMLMap {
  constructor(schema4) {
    super(schema4);
    this.tag = YAMLSet.tag;
  }
  add(key) {
    let pair;
    if (isPair(key))
      pair = key;
    else if (typeof key === "object" && "key" in key && "value" in key && key.value === null)
      pair = new Pair(key.key, null);
    else
      pair = new Pair(key, null);
    const prev = findPair(this.items, pair.key);
    if (!prev)
      this.items.push(pair);
  }
  get(key, keepPair) {
    const pair = findPair(this.items, key);
    return !keepPair && isPair(pair) ? isScalar(pair.key) ? pair.key.value : pair.key : pair;
  }
  set(key, value) {
    if (typeof value !== "boolean")
      throw new Error(`Expected boolean value for set(key, value) in a YAML set, not ${typeof value}`);
    const prev = findPair(this.items, key);
    if (prev && !value) {
      this.items.splice(this.items.indexOf(prev), 1);
    } else if (!prev && value) {
      this.items.push(new Pair(key));
    }
  }
  toJSON(_, ctx) {
    return super.toJSON(_, ctx, Set);
  }
  toString(ctx, onComment, onChompKeep) {
    if (!ctx)
      return JSON.stringify(this);
    if (this.hasAllNullValues(true))
      return super.toString(Object.assign({}, ctx, { allNullValues: true }), onComment, onChompKeep);
    else
      throw new Error("Set items must all have null values");
  }
};
YAMLSet.tag = "tag:yaml.org,2002:set";
var set = {
  collection: "map",
  identify: (value) => value instanceof Set,
  nodeClass: YAMLSet,
  default: false,
  tag: "tag:yaml.org,2002:set",
  resolve(map2, onError) {
    if (isMap(map2)) {
      if (map2.hasAllNullValues(true))
        return Object.assign(new YAMLSet(), map2);
      else
        onError("Set items must all have null values");
    } else
      onError("Expected a mapping for this tag");
    return map2;
  },
  createNode(schema4, iterable, ctx) {
    const { replacer } = ctx;
    const set2 = new YAMLSet(schema4);
    if (iterable && Symbol.iterator in Object(iterable))
      for (let value of iterable) {
        if (typeof replacer === "function")
          value = replacer.call(iterable, value, value);
        set2.items.push(createPair(value, null, ctx));
      }
    return set2;
  }
};

// node_modules/yaml/browser/dist/schema/yaml-1.1/timestamp.js
function parseSexagesimal(str, asBigInt) {
  const sign = str[0];
  const parts = sign === "-" || sign === "+" ? str.substring(1) : str;
  const num = (n) => asBigInt ? BigInt(n) : Number(n);
  const res = parts.replace(/_/g, "").split(":").reduce((res2, p) => res2 * num(60) + num(p), num(0));
  return sign === "-" ? num(-1) * res : res;
}
function stringifySexagesimal(node) {
  let { value } = node;
  let num = (n) => n;
  if (typeof value === "bigint")
    num = (n) => BigInt(n);
  else if (isNaN(value) || !isFinite(value))
    return stringifyNumber(node);
  let sign = "";
  if (value < 0) {
    sign = "-";
    value *= num(-1);
  }
  const _60 = num(60);
  const parts = [value % _60];
  if (value < 60) {
    parts.unshift(0);
  } else {
    value = (value - parts[0]) / _60;
    parts.unshift(value % _60);
    if (value >= 60) {
      value = (value - parts[0]) / _60;
      parts.unshift(value);
    }
  }
  return sign + parts.map((n) => n < 10 ? "0" + String(n) : String(n)).join(":").replace(/000000\d*$/, "");
}
var intTime = {
  identify: (value) => typeof value === "bigint" || Number.isInteger(value),
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "TIME",
  test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+$/,
  resolve: (str, _onError, { intAsBigInt }) => parseSexagesimal(str, intAsBigInt),
  stringify: stringifySexagesimal
};
var floatTime = {
  identify: (value) => typeof value === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  format: "TIME",
  test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\.[0-9_]*$/,
  resolve: (str) => parseSexagesimal(str, false),
  stringify: stringifySexagesimal
};
var timestamp = {
  identify: (value) => value instanceof Date,
  default: true,
  tag: "tag:yaml.org,2002:timestamp",
  // If the time zone is omitted, the timestamp is assumed to be specified in UTC. The time part
  // may be omitted altogether, resulting in a date format. In such a case, the time part is
  // assumed to be 00:00:00Z (start of day, UTC).
  test: RegExp("^([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})(?:(?:t|T|[ \\t]+)([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\.[0-9]+)?)(?:[ \\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?)?$"),
  resolve(str) {
    const match = str.match(timestamp.test);
    if (!match)
      throw new Error("!!timestamp expects a date, starting with yyyy-mm-dd");
    const [, year, month, day, hour, minute, second] = match.map(Number);
    const millisec = match[7] ? Number((match[7] + "00").substr(1, 3)) : 0;
    let date = Date.UTC(year, month - 1, day, hour || 0, minute || 0, second || 0, millisec);
    const tz = match[8];
    if (tz && tz !== "Z") {
      let d = parseSexagesimal(tz, false);
      if (Math.abs(d) < 30)
        d *= 60;
      date -= 6e4 * d;
    }
    return new Date(date);
  },
  stringify: ({ value }) => value.toISOString().replace(/((T00:00)?:00)?\.000Z$/, "")
};

// node_modules/yaml/browser/dist/schema/yaml-1.1/schema.js
var schema3 = [
  map,
  seq,
  string,
  nullTag,
  trueTag,
  falseTag,
  intBin,
  intOct2,
  int2,
  intHex2,
  floatNaN2,
  floatExp2,
  float2,
  binary,
  omap,
  pairs,
  set,
  intTime,
  floatTime,
  timestamp
];

// node_modules/yaml/browser/dist/schema/tags.js
var schemas = /* @__PURE__ */ new Map([
  ["core", schema],
  ["failsafe", [map, seq, string]],
  ["json", schema2],
  ["yaml11", schema3],
  ["yaml-1.1", schema3]
]);
var tagsByName = {
  binary,
  bool: boolTag,
  float,
  floatExp,
  floatNaN,
  floatTime,
  int,
  intHex,
  intOct,
  intTime,
  map,
  null: nullTag,
  omap,
  pairs,
  seq,
  set,
  timestamp
};
var coreKnownTags = {
  "tag:yaml.org,2002:binary": binary,
  "tag:yaml.org,2002:omap": omap,
  "tag:yaml.org,2002:pairs": pairs,
  "tag:yaml.org,2002:set": set,
  "tag:yaml.org,2002:timestamp": timestamp
};
function getTags(customTags, schemaName) {
  let tags = schemas.get(schemaName);
  if (!tags) {
    if (Array.isArray(customTags))
      tags = [];
    else {
      const keys = Array.from(schemas.keys()).filter((key) => key !== "yaml11").map((key) => JSON.stringify(key)).join(", ");
      throw new Error(`Unknown schema "${schemaName}"; use one of ${keys} or define customTags array`);
    }
  }
  if (Array.isArray(customTags)) {
    for (const tag2 of customTags)
      tags = tags.concat(tag2);
  } else if (typeof customTags === "function") {
    tags = customTags(tags.slice());
  }
  return tags.map((tag2) => {
    if (typeof tag2 !== "string")
      return tag2;
    const tagObj = tagsByName[tag2];
    if (tagObj)
      return tagObj;
    const keys = Object.keys(tagsByName).map((key) => JSON.stringify(key)).join(", ");
    throw new Error(`Unknown custom tag "${tag2}"; use one of ${keys}`);
  });
}

// node_modules/yaml/browser/dist/schema/Schema.js
var sortMapEntriesByKey = (a, b) => a.key < b.key ? -1 : a.key > b.key ? 1 : 0;
var Schema = class {
  constructor({ compat, customTags, merge, resolveKnownTags, schema: schema4, sortMapEntries, toStringDefaults }) {
    this.compat = Array.isArray(compat) ? getTags(compat, "compat") : compat ? getTags(null, compat) : null;
    this.merge = !!merge;
    this.name = typeof schema4 === "string" && schema4 || "core";
    this.knownTags = resolveKnownTags ? coreKnownTags : {};
    this.tags = getTags(customTags, this.name);
    this.toStringOptions = toStringDefaults || null;
    Object.defineProperty(this, MAP, { value: map });
    Object.defineProperty(this, SCALAR, { value: string });
    Object.defineProperty(this, SEQ, { value: seq });
    this.sortMapEntries = sortMapEntries === true ? sortMapEntriesByKey : sortMapEntries || null;
  }
  clone() {
    const copy = Object.create(Schema.prototype, Object.getOwnPropertyDescriptors(this));
    copy.tags = this.tags.slice();
    return copy;
  }
};

// node_modules/yaml/browser/dist/stringify/stringifyDocument.js
function stringifyDocument(doc, options) {
  const lines = [];
  let hasDirectives = options.directives === true;
  if (options.directives !== false && doc.directives) {
    const dir = doc.directives.toString(doc);
    if (dir) {
      lines.push(dir);
      hasDirectives = true;
    } else if (doc.directives.marker)
      hasDirectives = true;
  }
  if (hasDirectives)
    lines.push("---");
  const ctx = createStringifyContext(doc, options);
  const { commentString } = ctx.options;
  if (doc.commentBefore) {
    if (lines.length !== 1)
      lines.unshift("");
    const cs = commentString(doc.commentBefore);
    lines.unshift(indentComment(cs, ""));
  }
  let chompKeep = false;
  let contentComment = null;
  if (doc.contents) {
    if (isNode(doc.contents)) {
      if (doc.contents.spaceBefore && hasDirectives)
        lines.push("");
      if (doc.contents.commentBefore) {
        const cs = commentString(doc.contents.commentBefore);
        lines.push(indentComment(cs, ""));
      }
      ctx.forceBlockIndent = !!doc.comment;
      contentComment = doc.contents.comment;
    }
    const onChompKeep = contentComment ? void 0 : () => chompKeep = true;
    let body = stringify(doc.contents, ctx, () => contentComment = null, onChompKeep);
    if (contentComment)
      body += lineComment(body, "", commentString(contentComment));
    if ((body[0] === "|" || body[0] === ">") && lines[lines.length - 1] === "---") {
      lines[lines.length - 1] = `--- ${body}`;
    } else
      lines.push(body);
  } else {
    lines.push(stringify(doc.contents, ctx));
  }
  let dc = doc.comment;
  if (dc && chompKeep)
    dc = dc.replace(/^\n+/, "");
  if (dc) {
    if ((!chompKeep || contentComment) && lines[lines.length - 1] !== "")
      lines.push("");
    lines.push(indentComment(commentString(dc), ""));
  }
  return lines.join("\n") + "\n";
}

// node_modules/yaml/browser/dist/doc/applyReviver.js
function applyReviver(reviver, obj, key, val) {
  if (val && typeof val === "object") {
    if (Array.isArray(val)) {
      for (let i = 0, len = val.length; i < len; ++i) {
        const v0 = val[i];
        const v1 = applyReviver(reviver, val, String(i), v0);
        if (v1 === void 0)
          delete val[i];
        else if (v1 !== v0)
          val[i] = v1;
      }
    } else if (val instanceof Map) {
      for (const k of Array.from(val.keys())) {
        const v0 = val.get(k);
        const v1 = applyReviver(reviver, val, k, v0);
        if (v1 === void 0)
          val.delete(k);
        else if (v1 !== v0)
          val.set(k, v1);
      }
    } else if (val instanceof Set) {
      for (const v0 of Array.from(val)) {
        const v1 = applyReviver(reviver, val, v0, v0);
        if (v1 === void 0)
          val.delete(v0);
        else if (v1 !== v0) {
          val.delete(v0);
          val.add(v1);
        }
      }
    } else {
      for (const [k, v0] of Object.entries(val)) {
        const v1 = applyReviver(reviver, val, k, v0);
        if (v1 === void 0)
          delete val[k];
        else if (v1 !== v0)
          val[k] = v1;
      }
    }
  }
  return reviver.call(obj, key, val);
}

// node_modules/yaml/browser/dist/doc/Document.js
var Document = class {
  constructor(value, replacer, options) {
    this.commentBefore = null;
    this.comment = null;
    this.errors = [];
    this.warnings = [];
    Object.defineProperty(this, NODE_TYPE, { value: DOC });
    let _replacer = null;
    if (typeof replacer === "function" || Array.isArray(replacer)) {
      _replacer = replacer;
    } else if (options === void 0 && replacer) {
      options = replacer;
      replacer = void 0;
    }
    const opt = Object.assign({}, defaultOptions, options);
    this.options = opt;
    let { version } = opt;
    if (options === null || options === void 0 ? void 0 : options.directives) {
      this.directives = options.directives.atDocument();
      if (this.directives.yaml.explicit)
        version = this.directives.yaml.version;
    } else
      this.directives = new Directives({ version });
    this.setSchema(version, options);
    if (value === void 0)
      this.contents = null;
    else {
      this.contents = this.createNode(value, _replacer, options);
    }
  }
  /**
   * Create a deep copy of this Document and its contents.
   *
   * Custom Node values that inherit from `Object` still refer to their original instances.
   */
  clone() {
    const copy = Object.create(Document.prototype, {
      [NODE_TYPE]: { value: DOC }
    });
    copy.commentBefore = this.commentBefore;
    copy.comment = this.comment;
    copy.errors = this.errors.slice();
    copy.warnings = this.warnings.slice();
    copy.options = Object.assign({}, this.options);
    if (this.directives)
      copy.directives = this.directives.clone();
    copy.schema = this.schema.clone();
    copy.contents = isNode(this.contents) ? this.contents.clone(copy.schema) : this.contents;
    if (this.range)
      copy.range = this.range.slice();
    return copy;
  }
  /** Adds a value to the document. */
  add(value) {
    if (assertCollection(this.contents))
      this.contents.add(value);
  }
  /** Adds a value to the document. */
  addIn(path, value) {
    if (assertCollection(this.contents))
      this.contents.addIn(path, value);
  }
  /**
   * Create a new `Alias` node, ensuring that the target `node` has the required anchor.
   *
   * If `node` already has an anchor, `name` is ignored.
   * Otherwise, the `node.anchor` value will be set to `name`,
   * or if an anchor with that name is already present in the document,
   * `name` will be used as a prefix for a new unique anchor.
   * If `name` is undefined, the generated anchor will use 'a' as a prefix.
   */
  createAlias(node, name) {
    if (!node.anchor) {
      const prev = anchorNames(this);
      node.anchor = !name || prev.has(name) ? findNewAnchor(name || "a", prev) : name;
    }
    return new Alias(node.anchor);
  }
  createNode(value, replacer, options) {
    let _replacer = void 0;
    if (typeof replacer === "function") {
      value = replacer.call({ "": value }, "", value);
      _replacer = replacer;
    } else if (Array.isArray(replacer)) {
      const keyToStr = (v) => typeof v === "number" || v instanceof String || v instanceof Number;
      const asStr = replacer.filter(keyToStr).map(String);
      if (asStr.length > 0)
        replacer = replacer.concat(asStr);
      _replacer = replacer;
    } else if (options === void 0 && replacer) {
      options = replacer;
      replacer = void 0;
    }
    const { aliasDuplicateObjects, anchorPrefix, flow, keepUndefined, onTagObj, tag: tag2 } = options || {};
    const { onAnchor, setAnchors, sourceObjects } = createNodeAnchors(this, anchorPrefix || "a");
    const ctx = {
      aliasDuplicateObjects: aliasDuplicateObjects !== null && aliasDuplicateObjects !== void 0 ? aliasDuplicateObjects : true,
      keepUndefined: keepUndefined !== null && keepUndefined !== void 0 ? keepUndefined : false,
      onAnchor,
      onTagObj,
      replacer: _replacer,
      schema: this.schema,
      sourceObjects
    };
    const node = createNode(value, tag2, ctx);
    if (flow && isCollection(node))
      node.flow = true;
    setAnchors();
    return node;
  }
  /**
   * Convert a key and a value into a `Pair` using the current schema,
   * recursively wrapping all values as `Scalar` or `Collection` nodes.
   */
  createPair(key, value, options = {}) {
    const k = this.createNode(key, null, options);
    const v = this.createNode(value, null, options);
    return new Pair(k, v);
  }
  /**
   * Removes a value from the document.
   * @returns `true` if the item was found and removed.
   */
  delete(key) {
    return assertCollection(this.contents) ? this.contents.delete(key) : false;
  }
  /**
   * Removes a value from the document.
   * @returns `true` if the item was found and removed.
   */
  deleteIn(path) {
    if (isEmptyPath(path)) {
      if (this.contents == null)
        return false;
      this.contents = null;
      return true;
    }
    return assertCollection(this.contents) ? this.contents.deleteIn(path) : false;
  }
  /**
   * Returns item at `key`, or `undefined` if not found. By default unwraps
   * scalar values from their surrounding node; to disable set `keepScalar` to
   * `true` (collections are always returned intact).
   */
  get(key, keepScalar) {
    return isCollection(this.contents) ? this.contents.get(key, keepScalar) : void 0;
  }
  /**
   * Returns item at `path`, or `undefined` if not found. By default unwraps
   * scalar values from their surrounding node; to disable set `keepScalar` to
   * `true` (collections are always returned intact).
   */
  getIn(path, keepScalar) {
    if (isEmptyPath(path))
      return !keepScalar && isScalar(this.contents) ? this.contents.value : this.contents;
    return isCollection(this.contents) ? this.contents.getIn(path, keepScalar) : void 0;
  }
  /**
   * Checks if the document includes a value with the key `key`.
   */
  has(key) {
    return isCollection(this.contents) ? this.contents.has(key) : false;
  }
  /**
   * Checks if the document includes a value at `path`.
   */
  hasIn(path) {
    if (isEmptyPath(path))
      return this.contents !== void 0;
    return isCollection(this.contents) ? this.contents.hasIn(path) : false;
  }
  /**
   * Sets a value in this document. For `!!set`, `value` needs to be a
   * boolean to add/remove the item from the set.
   */
  set(key, value) {
    if (this.contents == null) {
      this.contents = collectionFromPath(this.schema, [key], value);
    } else if (assertCollection(this.contents)) {
      this.contents.set(key, value);
    }
  }
  /**
   * Sets a value in this document. For `!!set`, `value` needs to be a
   * boolean to add/remove the item from the set.
   */
  setIn(path, value) {
    if (isEmptyPath(path))
      this.contents = value;
    else if (this.contents == null) {
      this.contents = collectionFromPath(this.schema, Array.from(path), value);
    } else if (assertCollection(this.contents)) {
      this.contents.setIn(path, value);
    }
  }
  /**
   * Change the YAML version and schema used by the document.
   * A `null` version disables support for directives, explicit tags, anchors, and aliases.
   * It also requires the `schema` option to be given as a `Schema` instance value.
   *
   * Overrides all previously set schema options.
   */
  setSchema(version, options = {}) {
    if (typeof version === "number")
      version = String(version);
    let opt;
    switch (version) {
      case "1.1":
        if (this.directives)
          this.directives.yaml.version = "1.1";
        else
          this.directives = new Directives({ version: "1.1" });
        opt = { merge: true, resolveKnownTags: false, schema: "yaml-1.1" };
        break;
      case "1.2":
        if (this.directives)
          this.directives.yaml.version = "1.2";
        else
          this.directives = new Directives({ version: "1.2" });
        opt = { merge: false, resolveKnownTags: true, schema: "core" };
        break;
      case null:
        if (this.directives)
          delete this.directives;
        opt = null;
        break;
      default: {
        const sv = JSON.stringify(version);
        throw new Error(`Expected '1.1', '1.2' or null as first argument, but found: ${sv}`);
      }
    }
    if (options.schema instanceof Object)
      this.schema = options.schema;
    else if (opt)
      this.schema = new Schema(Object.assign(opt, options));
    else
      throw new Error(`With a null YAML version, the { schema: Schema } option is required`);
  }
  // json & jsonArg are only used from toJSON()
  toJS({ json, jsonArg, mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {
    const ctx = {
      anchors: /* @__PURE__ */ new Map(),
      doc: this,
      keep: !json,
      mapAsMap: mapAsMap === true,
      mapKeyWarned: false,
      maxAliasCount: typeof maxAliasCount === "number" ? maxAliasCount : 100,
      stringify
    };
    const res = toJS(this.contents, jsonArg || "", ctx);
    if (typeof onAnchor === "function")
      for (const { count, res: res2 } of ctx.anchors.values())
        onAnchor(res2, count);
    return typeof reviver === "function" ? applyReviver(reviver, { "": res }, "", res) : res;
  }
  /**
   * A JSON representation of the document `contents`.
   *
   * @param jsonArg Used by `JSON.stringify` to indicate the array index or
   *   property name.
   */
  toJSON(jsonArg, onAnchor) {
    return this.toJS({ json: true, jsonArg, mapAsMap: false, onAnchor });
  }
  /** A YAML representation of the document. */
  toString(options = {}) {
    if (this.errors.length > 0)
      throw new Error("Document with errors cannot be stringified");
    if ("indent" in options && (!Number.isInteger(options.indent) || Number(options.indent) <= 0)) {
      const s = JSON.stringify(options.indent);
      throw new Error(`"indent" option must be a positive integer, not ${s}`);
    }
    return stringifyDocument(this, options);
  }
};
function assertCollection(contents) {
  if (isCollection(contents))
    return true;
  throw new Error("Expected a YAML collection as document contents");
}

// node_modules/yaml/browser/dist/errors.js
var YAMLError = class extends Error {
  constructor(name, pos, code, message) {
    super();
    this.name = name;
    this.code = code;
    this.message = message;
    this.pos = pos;
  }
};
var YAMLParseError = class extends YAMLError {
  constructor(pos, code, message) {
    super("YAMLParseError", pos, code, message);
  }
};
var YAMLWarning = class extends YAMLError {
  constructor(pos, code, message) {
    super("YAMLWarning", pos, code, message);
  }
};
var prettifyError = (src, lc) => (error) => {
  if (error.pos[0] === -1)
    return;
  error.linePos = error.pos.map((pos) => lc.linePos(pos));
  const { line, col } = error.linePos[0];
  error.message += ` at line ${line}, column ${col}`;
  let ci = col - 1;
  let lineStr = src.substring(lc.lineStarts[line - 1], lc.lineStarts[line]).replace(/[\n\r]+$/, "");
  if (ci >= 60 && lineStr.length > 80) {
    const trimStart = Math.min(ci - 39, lineStr.length - 79);
    lineStr = "\u2026" + lineStr.substring(trimStart);
    ci -= trimStart - 1;
  }
  if (lineStr.length > 80)
    lineStr = lineStr.substring(0, 79) + "\u2026";
  if (line > 1 && /^ *$/.test(lineStr.substring(0, ci))) {
    let prev = src.substring(lc.lineStarts[line - 2], lc.lineStarts[line - 1]);
    if (prev.length > 80)
      prev = prev.substring(0, 79) + "\u2026\n";
    lineStr = prev + lineStr;
  }
  if (/[^ ]/.test(lineStr)) {
    let count = 1;
    const end = error.linePos[1];
    if (end && end.line === line && end.col > col) {
      count = Math.min(end.col - col, 80 - ci);
    }
    const pointer = " ".repeat(ci) + "^".repeat(count);
    error.message += `:

${lineStr}
${pointer}
`;
  }
};

// node_modules/yaml/browser/dist/compose/resolve-props.js
function resolveProps(tokens, { flow, indicator, next, offset, onError, startOnNewline }) {
  let spaceBefore = false;
  let atNewline = startOnNewline;
  let hasSpace = startOnNewline;
  let comment = "";
  let commentSep = "";
  let hasNewline = false;
  let reqSpace = false;
  let anchor = null;
  let tag2 = null;
  let comma = null;
  let found = null;
  let start = null;
  for (const token of tokens) {
    if (reqSpace) {
      if (token.type !== "space" && token.type !== "newline" && token.type !== "comma")
        onError(token.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space");
      reqSpace = false;
    }
    switch (token.type) {
      case "space":
        if (!flow && atNewline && indicator !== "doc-start" && token.source[0] === "	")
          onError(token, "TAB_AS_INDENT", "Tabs are not allowed as indentation");
        hasSpace = true;
        break;
      case "comment": {
        if (!hasSpace)
          onError(token, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
        const cb = token.source.substring(1) || " ";
        if (!comment)
          comment = cb;
        else
          comment += commentSep + cb;
        commentSep = "";
        atNewline = false;
        break;
      }
      case "newline":
        if (atNewline) {
          if (comment)
            comment += token.source;
          else
            spaceBefore = true;
        } else
          commentSep += token.source;
        atNewline = true;
        hasNewline = true;
        hasSpace = true;
        break;
      case "anchor":
        if (anchor)
          onError(token, "MULTIPLE_ANCHORS", "A node can have at most one anchor");
        anchor = token;
        if (start === null)
          start = token.offset;
        atNewline = false;
        hasSpace = false;
        reqSpace = true;
        break;
      case "tag": {
        if (tag2)
          onError(token, "MULTIPLE_TAGS", "A node can have at most one tag");
        tag2 = token;
        if (start === null)
          start = token.offset;
        atNewline = false;
        hasSpace = false;
        reqSpace = true;
        break;
      }
      case indicator:
        if (anchor || tag2)
          onError(token, "BAD_PROP_ORDER", `Anchors and tags must be after the ${token.source} indicator`);
        if (found)
          onError(token, "UNEXPECTED_TOKEN", `Unexpected ${token.source} in ${flow || "collection"}`);
        found = token;
        atNewline = false;
        hasSpace = false;
        break;
      case "comma":
        if (flow) {
          if (comma)
            onError(token, "UNEXPECTED_TOKEN", `Unexpected , in ${flow}`);
          comma = token;
          atNewline = false;
          hasSpace = false;
          break;
        }
      default:
        onError(token, "UNEXPECTED_TOKEN", `Unexpected ${token.type} token`);
        atNewline = false;
        hasSpace = false;
    }
  }
  const last = tokens[tokens.length - 1];
  const end = last ? last.offset + last.source.length : offset;
  if (reqSpace && next && next.type !== "space" && next.type !== "newline" && next.type !== "comma" && (next.type !== "scalar" || next.source !== ""))
    onError(next.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space");
  return {
    comma,
    found,
    spaceBefore,
    comment,
    hasNewline,
    anchor,
    tag: tag2,
    end,
    start: start !== null && start !== void 0 ? start : end
  };
}

// node_modules/yaml/browser/dist/compose/util-contains-newline.js
function containsNewline(key) {
  if (!key)
    return null;
  switch (key.type) {
    case "alias":
    case "scalar":
    case "double-quoted-scalar":
    case "single-quoted-scalar":
      if (key.source.includes("\n"))
        return true;
      if (key.end) {
        for (const st of key.end)
          if (st.type === "newline")
            return true;
      }
      return false;
    case "flow-collection":
      for (const it of key.items) {
        for (const st of it.start)
          if (st.type === "newline")
            return true;
        if (it.sep) {
          for (const st of it.sep)
            if (st.type === "newline")
              return true;
        }
        if (containsNewline(it.key) || containsNewline(it.value))
          return true;
      }
      return false;
    default:
      return true;
  }
}

// node_modules/yaml/browser/dist/compose/util-flow-indent-check.js
function flowIndentCheck(indent, fc, onError) {
  if ((fc === null || fc === void 0 ? void 0 : fc.type) === "flow-collection") {
    const end = fc.end[0];
    if (end.indent === indent && (end.source === "]" || end.source === "}") && containsNewline(fc)) {
      const msg = "Flow end indicator should be more indented than parent";
      onError(end, "BAD_INDENT", msg, true);
    }
  }
}

// node_modules/yaml/browser/dist/compose/util-map-includes.js
function mapIncludes(ctx, items, search) {
  const { uniqueKeys } = ctx.options;
  if (uniqueKeys === false)
    return false;
  const isEqual = typeof uniqueKeys === "function" ? uniqueKeys : (a, b) => a === b || isScalar(a) && isScalar(b) && a.value === b.value && !(a.value === "<<" && ctx.schema.merge);
  return items.some((pair) => isEqual(pair.key, search));
}

// node_modules/yaml/browser/dist/compose/resolve-block-map.js
var startColMsg = "All mapping items must start at the same column";
function resolveBlockMap({ composeNode: composeNode2, composeEmptyNode: composeEmptyNode2 }, ctx, bm, onError) {
  var _a;
  const map2 = new YAMLMap(ctx.schema);
  if (ctx.atRoot)
    ctx.atRoot = false;
  let offset = bm.offset;
  for (const collItem of bm.items) {
    const { start, key, sep, value } = collItem;
    const keyProps = resolveProps(start, {
      indicator: "explicit-key-ind",
      next: key || (sep === null || sep === void 0 ? void 0 : sep[0]),
      offset,
      onError,
      startOnNewline: true
    });
    const implicitKey = !keyProps.found;
    if (implicitKey) {
      if (key) {
        if (key.type === "block-seq")
          onError(offset, "BLOCK_AS_IMPLICIT_KEY", "A block sequence may not be used as an implicit map key");
        else if ("indent" in key && key.indent !== bm.indent)
          onError(offset, "BAD_INDENT", startColMsg);
      }
      if (!keyProps.anchor && !keyProps.tag && !sep) {
        if (keyProps.comment) {
          if (map2.comment)
            map2.comment += "\n" + keyProps.comment;
          else
            map2.comment = keyProps.comment;
        }
        continue;
      }
    } else if (((_a = keyProps.found) === null || _a === void 0 ? void 0 : _a.indent) !== bm.indent)
      onError(offset, "BAD_INDENT", startColMsg);
    if (implicitKey && containsNewline(key))
      onError(
        key,
        // checked by containsNewline()
        "MULTILINE_IMPLICIT_KEY",
        "Implicit keys need to be on a single line"
      );
    const keyStart = keyProps.end;
    const keyNode = key ? composeNode2(ctx, key, keyProps, onError) : composeEmptyNode2(ctx, keyStart, start, null, keyProps, onError);
    if (ctx.schema.compat)
      flowIndentCheck(bm.indent, key, onError);
    if (mapIncludes(ctx, map2.items, keyNode))
      onError(keyStart, "DUPLICATE_KEY", "Map keys must be unique");
    const valueProps = resolveProps(sep || [], {
      indicator: "map-value-ind",
      next: value,
      offset: keyNode.range[2],
      onError,
      startOnNewline: !key || key.type === "block-scalar"
    });
    offset = valueProps.end;
    if (valueProps.found) {
      if (implicitKey) {
        if ((value === null || value === void 0 ? void 0 : value.type) === "block-map" && !valueProps.hasNewline)
          onError(offset, "BLOCK_AS_IMPLICIT_KEY", "Nested mappings are not allowed in compact mappings");
        if (ctx.options.strict && keyProps.start < valueProps.found.offset - 1024)
          onError(keyNode.range, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit block mapping key");
      }
      const valueNode = value ? composeNode2(ctx, value, valueProps, onError) : composeEmptyNode2(ctx, offset, sep, null, valueProps, onError);
      if (ctx.schema.compat)
        flowIndentCheck(bm.indent, value, onError);
      offset = valueNode.range[2];
      const pair = new Pair(keyNode, valueNode);
      if (ctx.options.keepSourceTokens)
        pair.srcToken = collItem;
      map2.items.push(pair);
    } else {
      if (implicitKey)
        onError(keyNode.range, "MISSING_CHAR", "Implicit map keys need to be followed by map values");
      if (valueProps.comment) {
        if (keyNode.comment)
          keyNode.comment += "\n" + valueProps.comment;
        else
          keyNode.comment = valueProps.comment;
      }
      const pair = new Pair(keyNode);
      if (ctx.options.keepSourceTokens)
        pair.srcToken = collItem;
      map2.items.push(pair);
    }
  }
  map2.range = [bm.offset, offset, offset];
  return map2;
}

// node_modules/yaml/browser/dist/compose/resolve-block-seq.js
function resolveBlockSeq({ composeNode: composeNode2, composeEmptyNode: composeEmptyNode2 }, ctx, bs, onError) {
  const seq2 = new YAMLSeq(ctx.schema);
  if (ctx.atRoot)
    ctx.atRoot = false;
  let offset = bs.offset;
  for (const { start, value } of bs.items) {
    const props = resolveProps(start, {
      indicator: "seq-item-ind",
      next: value,
      offset,
      onError,
      startOnNewline: true
    });
    offset = props.end;
    if (!props.found) {
      if (props.anchor || props.tag || value) {
        if (value && value.type === "block-seq")
          onError(offset, "BAD_INDENT", "All sequence items must start at the same column");
        else
          onError(offset, "MISSING_CHAR", "Sequence item without - indicator");
      } else {
        if (props.comment)
          seq2.comment = props.comment;
        continue;
      }
    }
    const node = value ? composeNode2(ctx, value, props, onError) : composeEmptyNode2(ctx, offset, start, null, props, onError);
    if (ctx.schema.compat)
      flowIndentCheck(bs.indent, value, onError);
    offset = node.range[2];
    seq2.items.push(node);
  }
  seq2.range = [bs.offset, offset, offset];
  return seq2;
}

// node_modules/yaml/browser/dist/compose/resolve-end.js
function resolveEnd(end, offset, reqSpace, onError) {
  let comment = "";
  if (end) {
    let hasSpace = false;
    let sep = "";
    for (const token of end) {
      const { source, type } = token;
      switch (type) {
        case "space":
          hasSpace = true;
          break;
        case "comment": {
          if (reqSpace && !hasSpace)
            onError(token, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
          const cb = source.substring(1) || " ";
          if (!comment)
            comment = cb;
          else
            comment += sep + cb;
          sep = "";
          break;
        }
        case "newline":
          if (comment)
            sep += source;
          hasSpace = true;
          break;
        default:
          onError(token, "UNEXPECTED_TOKEN", `Unexpected ${type} at node end`);
      }
      offset += source.length;
    }
  }
  return { comment, offset };
}

// node_modules/yaml/browser/dist/compose/resolve-flow-collection.js
var blockMsg = "Block collections are not allowed within flow collections";
var isBlock = (token) => token && (token.type === "block-map" || token.type === "block-seq");
function resolveFlowCollection({ composeNode: composeNode2, composeEmptyNode: composeEmptyNode2 }, ctx, fc, onError) {
  const isMap2 = fc.start.source === "{";
  const fcName = isMap2 ? "flow map" : "flow sequence";
  const coll = isMap2 ? new YAMLMap(ctx.schema) : new YAMLSeq(ctx.schema);
  coll.flow = true;
  const atRoot = ctx.atRoot;
  if (atRoot)
    ctx.atRoot = false;
  let offset = fc.offset + fc.start.source.length;
  for (let i = 0; i < fc.items.length; ++i) {
    const collItem = fc.items[i];
    const { start, key, sep, value } = collItem;
    const props = resolveProps(start, {
      flow: fcName,
      indicator: "explicit-key-ind",
      next: key || (sep === null || sep === void 0 ? void 0 : sep[0]),
      offset,
      onError,
      startOnNewline: false
    });
    if (!props.found) {
      if (!props.anchor && !props.tag && !sep && !value) {
        if (i === 0 && props.comma)
          onError(props.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${fcName}`);
        else if (i < fc.items.length - 1)
          onError(props.start, "UNEXPECTED_TOKEN", `Unexpected empty item in ${fcName}`);
        if (props.comment) {
          if (coll.comment)
            coll.comment += "\n" + props.comment;
          else
            coll.comment = props.comment;
        }
        offset = props.end;
        continue;
      }
      if (!isMap2 && ctx.options.strict && containsNewline(key))
        onError(
          key,
          // checked by containsNewline()
          "MULTILINE_IMPLICIT_KEY",
          "Implicit keys of flow sequence pairs need to be on a single line"
        );
    }
    if (i === 0) {
      if (props.comma)
        onError(props.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${fcName}`);
    } else {
      if (!props.comma)
        onError(props.start, "MISSING_CHAR", `Missing , between ${fcName} items`);
      if (props.comment) {
        let prevItemComment = "";
        loop:
          for (const st of start) {
            switch (st.type) {
              case "comma":
              case "space":
                break;
              case "comment":
                prevItemComment = st.source.substring(1);
                break loop;
              default:
                break loop;
            }
          }
        if (prevItemComment) {
          let prev = coll.items[coll.items.length - 1];
          if (isPair(prev))
            prev = prev.value || prev.key;
          if (prev.comment)
            prev.comment += "\n" + prevItemComment;
          else
            prev.comment = prevItemComment;
          props.comment = props.comment.substring(prevItemComment.length + 1);
        }
      }
    }
    if (!isMap2 && !sep && !props.found) {
      const valueNode = value ? composeNode2(ctx, value, props, onError) : composeEmptyNode2(ctx, props.end, sep, null, props, onError);
      coll.items.push(valueNode);
      offset = valueNode.range[2];
      if (isBlock(value))
        onError(valueNode.range, "BLOCK_IN_FLOW", blockMsg);
    } else {
      const keyStart = props.end;
      const keyNode = key ? composeNode2(ctx, key, props, onError) : composeEmptyNode2(ctx, keyStart, start, null, props, onError);
      if (isBlock(key))
        onError(keyNode.range, "BLOCK_IN_FLOW", blockMsg);
      const valueProps = resolveProps(sep || [], {
        flow: fcName,
        indicator: "map-value-ind",
        next: value,
        offset: keyNode.range[2],
        onError,
        startOnNewline: false
      });
      if (valueProps.found) {
        if (!isMap2 && !props.found && ctx.options.strict) {
          if (sep)
            for (const st of sep) {
              if (st === valueProps.found)
                break;
              if (st.type === "newline") {
                onError(st, "MULTILINE_IMPLICIT_KEY", "Implicit keys of flow sequence pairs need to be on a single line");
                break;
              }
            }
          if (props.start < valueProps.found.offset - 1024)
            onError(valueProps.found, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit flow sequence key");
        }
      } else if (value) {
        if ("source" in value && value.source && value.source[0] === ":")
          onError(value, "MISSING_CHAR", `Missing space after : in ${fcName}`);
        else
          onError(valueProps.start, "MISSING_CHAR", `Missing , or : between ${fcName} items`);
      }
      const valueNode = value ? composeNode2(ctx, value, valueProps, onError) : valueProps.found ? composeEmptyNode2(ctx, valueProps.end, sep, null, valueProps, onError) : null;
      if (valueNode) {
        if (isBlock(value))
          onError(valueNode.range, "BLOCK_IN_FLOW", blockMsg);
      } else if (valueProps.comment) {
        if (keyNode.comment)
          keyNode.comment += "\n" + valueProps.comment;
        else
          keyNode.comment = valueProps.comment;
      }
      const pair = new Pair(keyNode, valueNode);
      if (ctx.options.keepSourceTokens)
        pair.srcToken = collItem;
      if (isMap2) {
        const map2 = coll;
        if (mapIncludes(ctx, map2.items, keyNode))
          onError(keyStart, "DUPLICATE_KEY", "Map keys must be unique");
        map2.items.push(pair);
      } else {
        const map2 = new YAMLMap(ctx.schema);
        map2.flow = true;
        map2.items.push(pair);
        coll.items.push(map2);
      }
      offset = valueNode ? valueNode.range[2] : valueProps.end;
    }
  }
  const expectedEnd = isMap2 ? "}" : "]";
  const [ce, ...ee] = fc.end;
  let cePos = offset;
  if (ce && ce.source === expectedEnd)
    cePos = ce.offset + ce.source.length;
  else {
    const name = fcName[0].toUpperCase() + fcName.substring(1);
    const msg = atRoot ? `${name} must end with a ${expectedEnd}` : `${name} in block collection must be sufficiently indented and end with a ${expectedEnd}`;
    onError(offset, atRoot ? "MISSING_CHAR" : "BAD_INDENT", msg);
    if (ce && ce.source.length !== 1)
      ee.unshift(ce);
  }
  if (ee.length > 0) {
    const end = resolveEnd(ee, cePos, ctx.options.strict, onError);
    if (end.comment) {
      if (coll.comment)
        coll.comment += "\n" + end.comment;
      else
        coll.comment = end.comment;
    }
    coll.range = [fc.offset, cePos, end.offset];
  } else {
    coll.range = [fc.offset, cePos, cePos];
  }
  return coll;
}

// node_modules/yaml/browser/dist/compose/compose-collection.js
function composeCollection(CN2, ctx, token, tagToken, onError) {
  let coll;
  switch (token.type) {
    case "block-map": {
      coll = resolveBlockMap(CN2, ctx, token, onError);
      break;
    }
    case "block-seq": {
      coll = resolveBlockSeq(CN2, ctx, token, onError);
      break;
    }
    case "flow-collection": {
      coll = resolveFlowCollection(CN2, ctx, token, onError);
      break;
    }
  }
  if (!tagToken)
    return coll;
  const tagName = ctx.directives.tagName(tagToken.source, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg));
  if (!tagName)
    return coll;
  const Coll = coll.constructor;
  if (tagName === "!" || tagName === Coll.tagName) {
    coll.tag = Coll.tagName;
    return coll;
  }
  const expType = isMap(coll) ? "map" : "seq";
  let tag2 = ctx.schema.tags.find((t) => t.collection === expType && t.tag === tagName);
  if (!tag2) {
    const kt = ctx.schema.knownTags[tagName];
    if (kt && kt.collection === expType) {
      ctx.schema.tags.push(Object.assign({}, kt, { default: false }));
      tag2 = kt;
    } else {
      onError(tagToken, "TAG_RESOLVE_FAILED", `Unresolved tag: ${tagName}`, true);
      coll.tag = tagName;
      return coll;
    }
  }
  const res = tag2.resolve(coll, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg), ctx.options);
  const node = isNode(res) ? res : new Scalar(res);
  node.range = coll.range;
  node.tag = tagName;
  if (tag2 === null || tag2 === void 0 ? void 0 : tag2.format)
    node.format = tag2.format;
  return node;
}

// node_modules/yaml/browser/dist/compose/resolve-block-scalar.js
function resolveBlockScalar(scalar, strict, onError) {
  const start = scalar.offset;
  const header = parseBlockScalarHeader(scalar, strict, onError);
  if (!header)
    return { value: "", type: null, comment: "", range: [start, start, start] };
  const type = header.mode === ">" ? Scalar.BLOCK_FOLDED : Scalar.BLOCK_LITERAL;
  const lines = scalar.source ? splitLines(scalar.source) : [];
  let chompStart = lines.length;
  for (let i = lines.length - 1; i >= 0; --i) {
    const content = lines[i][1];
    if (content === "" || content === "\r")
      chompStart = i;
    else
      break;
  }
  if (!scalar.source || chompStart === 0) {
    const value2 = header.chomp === "+" ? "\n".repeat(Math.max(0, lines.length - 1)) : "";
    let end2 = start + header.length;
    if (scalar.source)
      end2 += scalar.source.length;
    return { value: value2, type, comment: header.comment, range: [start, end2, end2] };
  }
  let trimIndent = scalar.indent + header.indent;
  let offset = scalar.offset + header.length;
  let contentStart = 0;
  for (let i = 0; i < chompStart; ++i) {
    const [indent, content] = lines[i];
    if (content === "" || content === "\r") {
      if (header.indent === 0 && indent.length > trimIndent)
        trimIndent = indent.length;
    } else {
      if (indent.length < trimIndent) {
        const message = "Block scalars with more-indented leading empty lines must use an explicit indentation indicator";
        onError(offset + indent.length, "MISSING_CHAR", message);
      }
      if (header.indent === 0)
        trimIndent = indent.length;
      contentStart = i;
      break;
    }
    offset += indent.length + content.length + 1;
  }
  let value = "";
  let sep = "";
  let prevMoreIndented = false;
  for (let i = 0; i < contentStart; ++i)
    value += lines[i][0].slice(trimIndent) + "\n";
  for (let i = contentStart; i < chompStart; ++i) {
    let [indent, content] = lines[i];
    offset += indent.length + content.length + 1;
    const crlf = content[content.length - 1] === "\r";
    if (crlf)
      content = content.slice(0, -1);
    if (content && indent.length < trimIndent) {
      const src = header.indent ? "explicit indentation indicator" : "first line";
      const message = `Block scalar lines must not be less indented than their ${src}`;
      onError(offset - content.length - (crlf ? 2 : 1), "BAD_INDENT", message);
      indent = "";
    }
    if (type === Scalar.BLOCK_LITERAL) {
      value += sep + indent.slice(trimIndent) + content;
      sep = "\n";
    } else if (indent.length > trimIndent || content[0] === "	") {
      if (sep === " ")
        sep = "\n";
      else if (!prevMoreIndented && sep === "\n")
        sep = "\n\n";
      value += sep + indent.slice(trimIndent) + content;
      sep = "\n";
      prevMoreIndented = true;
    } else if (content === "") {
      if (sep === "\n")
        value += "\n";
      else
        sep = "\n";
    } else {
      value += sep + content;
      sep = " ";
      prevMoreIndented = false;
    }
  }
  switch (header.chomp) {
    case "-":
      break;
    case "+":
      for (let i = chompStart; i < lines.length; ++i)
        value += "\n" + lines[i][0].slice(trimIndent);
      if (value[value.length - 1] !== "\n")
        value += "\n";
      break;
    default:
      value += "\n";
  }
  const end = start + header.length + scalar.source.length;
  return { value, type, comment: header.comment, range: [start, end, end] };
}
function parseBlockScalarHeader({ offset, props }, strict, onError) {
  if (props[0].type !== "block-scalar-header") {
    onError(props[0], "IMPOSSIBLE", "Block scalar header not found");
    return null;
  }
  const { source } = props[0];
  const mode = source[0];
  let indent = 0;
  let chomp = "";
  let error = -1;
  for (let i = 1; i < source.length; ++i) {
    const ch = source[i];
    if (!chomp && (ch === "-" || ch === "+"))
      chomp = ch;
    else {
      const n = Number(ch);
      if (!indent && n)
        indent = n;
      else if (error === -1)
        error = offset + i;
    }
  }
  if (error !== -1)
    onError(error, "UNEXPECTED_TOKEN", `Block scalar header includes extra characters: ${source}`);
  let hasSpace = false;
  let comment = "";
  let length = source.length;
  for (let i = 1; i < props.length; ++i) {
    const token = props[i];
    switch (token.type) {
      case "space":
        hasSpace = true;
      case "newline":
        length += token.source.length;
        break;
      case "comment":
        if (strict && !hasSpace) {
          const message = "Comments must be separated from other tokens by white space characters";
          onError(token, "MISSING_CHAR", message);
        }
        length += token.source.length;
        comment = token.source.substring(1);
        break;
      case "error":
        onError(token, "UNEXPECTED_TOKEN", token.message);
        length += token.source.length;
        break;
      default: {
        const message = `Unexpected token in block scalar header: ${token.type}`;
        onError(token, "UNEXPECTED_TOKEN", message);
        const ts = token.source;
        if (ts && typeof ts === "string")
          length += ts.length;
      }
    }
  }
  return { mode, indent, chomp, comment, length };
}
function splitLines(source) {
  const split = source.split(/\n( *)/);
  const first = split[0];
  const m = first.match(/^( *)/);
  const line0 = m && m[1] ? [m[1], first.slice(m[1].length)] : ["", first];
  const lines = [line0];
  for (let i = 1; i < split.length; i += 2)
    lines.push([split[i], split[i + 1]]);
  return lines;
}

// node_modules/yaml/browser/dist/compose/resolve-flow-scalar.js
function resolveFlowScalar(scalar, strict, onError) {
  const { offset, type, source, end } = scalar;
  let _type;
  let value;
  const _onError = (rel, code, msg) => onError(offset + rel, code, msg);
  switch (type) {
    case "scalar":
      _type = Scalar.PLAIN;
      value = plainValue(source, _onError);
      break;
    case "single-quoted-scalar":
      _type = Scalar.QUOTE_SINGLE;
      value = singleQuotedValue(source, _onError);
      break;
    case "double-quoted-scalar":
      _type = Scalar.QUOTE_DOUBLE;
      value = doubleQuotedValue(source, _onError);
      break;
    default:
      onError(scalar, "UNEXPECTED_TOKEN", `Expected a flow scalar value, but found: ${type}`);
      return {
        value: "",
        type: null,
        comment: "",
        range: [offset, offset + source.length, offset + source.length]
      };
  }
  const valueEnd = offset + source.length;
  const re = resolveEnd(end, valueEnd, strict, onError);
  return {
    value,
    type: _type,
    comment: re.comment,
    range: [offset, valueEnd, re.offset]
  };
}
function plainValue(source, onError) {
  let badChar = "";
  switch (source[0]) {
    case "	":
      badChar = "a tab character";
      break;
    case ",":
      badChar = "flow indicator character ,";
      break;
    case "%":
      badChar = "directive indicator character %";
      break;
    case "|":
    case ">": {
      badChar = `block scalar indicator ${source[0]}`;
      break;
    }
    case "@":
    case "`": {
      badChar = `reserved character ${source[0]}`;
      break;
    }
  }
  if (badChar)
    onError(0, "BAD_SCALAR_START", `Plain value cannot start with ${badChar}`);
  return foldLines(source);
}
function singleQuotedValue(source, onError) {
  if (source[source.length - 1] !== "'" || source.length === 1)
    onError(source.length, "MISSING_CHAR", "Missing closing 'quote");
  return foldLines(source.slice(1, -1)).replace(/''/g, "'");
}
function foldLines(source) {
  let first, line;
  try {
    first = new RegExp("(.*?)(?<![ 	])[ 	]*\r?\n", "sy");
    line = new RegExp("[ 	]*(.*?)(?:(?<![ 	])[ 	]*)?\r?\n", "sy");
  } catch (_) {
    first = /(.*?)[ \t]*\r?\n/sy;
    line = /[ \t]*(.*?)[ \t]*\r?\n/sy;
  }
  let match = first.exec(source);
  if (!match)
    return source;
  let res = match[1];
  let sep = " ";
  let pos = first.lastIndex;
  line.lastIndex = pos;
  while (match = line.exec(source)) {
    if (match[1] === "") {
      if (sep === "\n")
        res += sep;
      else
        sep = "\n";
    } else {
      res += sep + match[1];
      sep = " ";
    }
    pos = line.lastIndex;
  }
  const last = /[ \t]*(.*)/sy;
  last.lastIndex = pos;
  match = last.exec(source);
  return res + sep + (match && match[1] || "");
}
function doubleQuotedValue(source, onError) {
  let res = "";
  for (let i = 1; i < source.length - 1; ++i) {
    const ch = source[i];
    if (ch === "\r" && source[i + 1] === "\n")
      continue;
    if (ch === "\n") {
      const { fold, offset } = foldNewline(source, i);
      res += fold;
      i = offset;
    } else if (ch === "\\") {
      let next = source[++i];
      const cc = escapeCodes[next];
      if (cc)
        res += cc;
      else if (next === "\n") {
        next = source[i + 1];
        while (next === " " || next === "	")
          next = source[++i + 1];
      } else if (next === "\r" && source[i + 1] === "\n") {
        next = source[++i + 1];
        while (next === " " || next === "	")
          next = source[++i + 1];
      } else if (next === "x" || next === "u" || next === "U") {
        const length = { x: 2, u: 4, U: 8 }[next];
        res += parseCharCode(source, i + 1, length, onError);
        i += length;
      } else {
        const raw = source.substr(i - 1, 2);
        onError(i - 1, "BAD_DQ_ESCAPE", `Invalid escape sequence ${raw}`);
        res += raw;
      }
    } else if (ch === " " || ch === "	") {
      const wsStart = i;
      let next = source[i + 1];
      while (next === " " || next === "	")
        next = source[++i + 1];
      if (next !== "\n" && !(next === "\r" && source[i + 2] === "\n"))
        res += i > wsStart ? source.slice(wsStart, i + 1) : ch;
    } else {
      res += ch;
    }
  }
  if (source[source.length - 1] !== '"' || source.length === 1)
    onError(source.length, "MISSING_CHAR", 'Missing closing "quote');
  return res;
}
function foldNewline(source, offset) {
  let fold = "";
  let ch = source[offset + 1];
  while (ch === " " || ch === "	" || ch === "\n" || ch === "\r") {
    if (ch === "\r" && source[offset + 2] !== "\n")
      break;
    if (ch === "\n")
      fold += "\n";
    offset += 1;
    ch = source[offset + 1];
  }
  if (!fold)
    fold = " ";
  return { fold, offset };
}
var escapeCodes = {
  "0": "\0",
  a: "\x07",
  b: "\b",
  e: "\x1B",
  f: "\f",
  n: "\n",
  r: "\r",
  t: "	",
  v: "\v",
  N: "\x85",
  _: "\xA0",
  L: "\u2028",
  P: "\u2029",
  " ": " ",
  '"': '"',
  "/": "/",
  "\\": "\\",
  "	": "	"
};
function parseCharCode(source, offset, length, onError) {
  const cc = source.substr(offset, length);
  const ok = cc.length === length && /^[0-9a-fA-F]+$/.test(cc);
  const code = ok ? parseInt(cc, 16) : NaN;
  if (isNaN(code)) {
    const raw = source.substr(offset - 2, length + 2);
    onError(offset - 2, "BAD_DQ_ESCAPE", `Invalid escape sequence ${raw}`);
    return raw;
  }
  return String.fromCodePoint(code);
}

// node_modules/yaml/browser/dist/compose/compose-scalar.js
function composeScalar(ctx, token, tagToken, onError) {
  const { value, type, comment, range } = token.type === "block-scalar" ? resolveBlockScalar(token, ctx.options.strict, onError) : resolveFlowScalar(token, ctx.options.strict, onError);
  const tagName = tagToken ? ctx.directives.tagName(tagToken.source, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg)) : null;
  const tag2 = tagToken && tagName ? findScalarTagByName(ctx.schema, value, tagName, tagToken, onError) : token.type === "scalar" ? findScalarTagByTest(ctx, value, token, onError) : ctx.schema[SCALAR];
  let scalar;
  try {
    const res = tag2.resolve(value, (msg) => onError(tagToken || token, "TAG_RESOLVE_FAILED", msg), ctx.options);
    scalar = isScalar(res) ? res : new Scalar(res);
  } catch (error) {
    const msg = error instanceof Error ? error.message : String(error);
    onError(tagToken || token, "TAG_RESOLVE_FAILED", msg);
    scalar = new Scalar(value);
  }
  scalar.range = range;
  scalar.source = value;
  if (type)
    scalar.type = type;
  if (tagName)
    scalar.tag = tagName;
  if (tag2.format)
    scalar.format = tag2.format;
  if (comment)
    scalar.comment = comment;
  return scalar;
}
function findScalarTagByName(schema4, value, tagName, tagToken, onError) {
  var _a;
  if (tagName === "!")
    return schema4[SCALAR];
  const matchWithTest = [];
  for (const tag2 of schema4.tags) {
    if (!tag2.collection && tag2.tag === tagName) {
      if (tag2.default && tag2.test)
        matchWithTest.push(tag2);
      else
        return tag2;
    }
  }
  for (const tag2 of matchWithTest)
    if ((_a = tag2.test) === null || _a === void 0 ? void 0 : _a.test(value))
      return tag2;
  const kt = schema4.knownTags[tagName];
  if (kt && !kt.collection) {
    schema4.tags.push(Object.assign({}, kt, { default: false, test: void 0 }));
    return kt;
  }
  onError(tagToken, "TAG_RESOLVE_FAILED", `Unresolved tag: ${tagName}`, tagName !== "tag:yaml.org,2002:str");
  return schema4[SCALAR];
}
function findScalarTagByTest({ directives, schema: schema4 }, value, token, onError) {
  const tag2 = schema4.tags.find((tag3) => {
    var _a;
    return tag3.default && ((_a = tag3.test) === null || _a === void 0 ? void 0 : _a.test(value));
  }) || schema4[SCALAR];
  if (schema4.compat) {
    const compat = schema4.compat.find((tag3) => {
      var _a;
      return tag3.default && ((_a = tag3.test) === null || _a === void 0 ? void 0 : _a.test(value));
    }) || schema4[SCALAR];
    if (tag2.tag !== compat.tag) {
      const ts = directives.tagString(tag2.tag);
      const cs = directives.tagString(compat.tag);
      const msg = `Value may be parsed as either ${ts} or ${cs}`;
      onError(token, "TAG_RESOLVE_FAILED", msg, true);
    }
  }
  return tag2;
}

// node_modules/yaml/browser/dist/compose/util-empty-scalar-position.js
function emptyScalarPosition(offset, before, pos) {
  if (before) {
    if (pos === null)
      pos = before.length;
    for (let i = pos - 1; i >= 0; --i) {
      let st = before[i];
      switch (st.type) {
        case "space":
        case "comment":
        case "newline":
          offset -= st.source.length;
          continue;
      }
      st = before[++i];
      while ((st === null || st === void 0 ? void 0 : st.type) === "space") {
        offset += st.source.length;
        st = before[++i];
      }
      break;
    }
  }
  return offset;
}

// node_modules/yaml/browser/dist/compose/compose-node.js
var CN = { composeNode, composeEmptyNode };
function composeNode(ctx, token, props, onError) {
  const { spaceBefore, comment, anchor, tag: tag2 } = props;
  let node;
  switch (token.type) {
    case "alias":
      node = composeAlias(ctx, token, onError);
      if (anchor || tag2)
        onError(token, "ALIAS_PROPS", "An alias node must not specify any properties");
      break;
    case "scalar":
    case "single-quoted-scalar":
    case "double-quoted-scalar":
    case "block-scalar":
      node = composeScalar(ctx, token, tag2, onError);
      if (anchor)
        node.anchor = anchor.source.substring(1);
      break;
    case "block-map":
    case "block-seq":
    case "flow-collection":
      node = composeCollection(CN, ctx, token, tag2, onError);
      if (anchor)
        node.anchor = anchor.source.substring(1);
      break;
    default:
      console.log(token);
      throw new Error(`Unsupporten token type: ${token.type}`);
  }
  if (anchor && node.anchor === "")
    onError(anchor, "BAD_ALIAS", "Anchor cannot be an empty string");
  if (spaceBefore)
    node.spaceBefore = true;
  if (comment) {
    if (token.type === "scalar" && token.source === "")
      node.comment = comment;
    else
      node.commentBefore = comment;
  }
  if (ctx.options.keepSourceTokens)
    node.srcToken = token;
  return node;
}
function composeEmptyNode(ctx, offset, before, pos, { spaceBefore, comment, anchor, tag: tag2 }, onError) {
  const token = {
    type: "scalar",
    offset: emptyScalarPosition(offset, before, pos),
    indent: -1,
    source: ""
  };
  const node = composeScalar(ctx, token, tag2, onError);
  if (anchor) {
    node.anchor = anchor.source.substring(1);
    if (node.anchor === "")
      onError(anchor, "BAD_ALIAS", "Anchor cannot be an empty string");
  }
  if (spaceBefore)
    node.spaceBefore = true;
  if (comment)
    node.comment = comment;
  return node;
}
function composeAlias({ options }, { offset, source, end }, onError) {
  const alias = new Alias(source.substring(1));
  if (alias.source === "")
    onError(offset, "BAD_ALIAS", "Alias cannot be an empty string");
  const valueEnd = offset + source.length;
  const re = resolveEnd(end, valueEnd, options.strict, onError);
  alias.range = [offset, valueEnd, re.offset];
  if (re.comment)
    alias.comment = re.comment;
  return alias;
}

// node_modules/yaml/browser/dist/compose/compose-doc.js
function composeDoc(options, directives, { offset, start, value, end }, onError) {
  const opts = Object.assign({ directives }, options);
  const doc = new Document(void 0, opts);
  const ctx = {
    atRoot: true,
    directives: doc.directives,
    options: doc.options,
    schema: doc.schema
  };
  const props = resolveProps(start, {
    indicator: "doc-start",
    next: value || (end === null || end === void 0 ? void 0 : end[0]),
    offset,
    onError,
    startOnNewline: true
  });
  if (props.found) {
    doc.directives.marker = true;
    if (value && (value.type === "block-map" || value.type === "block-seq") && !props.hasNewline)
      onError(props.end, "MISSING_CHAR", "Block collection cannot start on same line with directives-end marker");
  }
  doc.contents = value ? composeNode(ctx, value, props, onError) : composeEmptyNode(ctx, props.end, start, null, props, onError);
  const contentEnd = doc.contents.range[2];
  const re = resolveEnd(end, contentEnd, false, onError);
  if (re.comment)
    doc.comment = re.comment;
  doc.range = [offset, contentEnd, re.offset];
  return doc;
}

// node_modules/yaml/browser/dist/compose/composer.js
function getErrorPos(src) {
  if (typeof src === "number")
    return [src, src + 1];
  if (Array.isArray(src))
    return src.length === 2 ? src : [src[0], src[1]];
  const { offset, source } = src;
  return [offset, offset + (typeof source === "string" ? source.length : 1)];
}
function parsePrelude(prelude) {
  var _a;
  let comment = "";
  let atComment = false;
  let afterEmptyLine = false;
  for (let i = 0; i < prelude.length; ++i) {
    const source = prelude[i];
    switch (source[0]) {
      case "#":
        comment += (comment === "" ? "" : afterEmptyLine ? "\n\n" : "\n") + (source.substring(1) || " ");
        atComment = true;
        afterEmptyLine = false;
        break;
      case "%":
        if (((_a = prelude[i + 1]) === null || _a === void 0 ? void 0 : _a[0]) !== "#")
          i += 1;
        atComment = false;
        break;
      default:
        if (!atComment)
          afterEmptyLine = true;
        atComment = false;
    }
  }
  return { comment, afterEmptyLine };
}
var Composer = class {
  constructor(options = {}) {
    this.doc = null;
    this.atDirectives = false;
    this.prelude = [];
    this.errors = [];
    this.warnings = [];
    this.onError = (source, code, message, warning) => {
      const pos = getErrorPos(source);
      if (warning)
        this.warnings.push(new YAMLWarning(pos, code, message));
      else
        this.errors.push(new YAMLParseError(pos, code, message));
    };
    this.directives = new Directives({
      version: options.version || defaultOptions.version
    });
    this.options = options;
  }
  decorate(doc, afterDoc) {
    const { comment, afterEmptyLine } = parsePrelude(this.prelude);
    if (comment) {
      const dc = doc.contents;
      if (afterDoc) {
        doc.comment = doc.comment ? `${doc.comment}
${comment}` : comment;
      } else if (afterEmptyLine || doc.directives.marker || !dc) {
        doc.commentBefore = comment;
      } else if (isCollection(dc) && !dc.flow && dc.items.length > 0) {
        let it = dc.items[0];
        if (isPair(it))
          it = it.key;
        const cb = it.commentBefore;
        it.commentBefore = cb ? `${comment}
${cb}` : comment;
      } else {
        const cb = dc.commentBefore;
        dc.commentBefore = cb ? `${comment}
${cb}` : comment;
      }
    }
    if (afterDoc) {
      Array.prototype.push.apply(doc.errors, this.errors);
      Array.prototype.push.apply(doc.warnings, this.warnings);
    } else {
      doc.errors = this.errors;
      doc.warnings = this.warnings;
    }
    this.prelude = [];
    this.errors = [];
    this.warnings = [];
  }
  /**
   * Current stream status information.
   *
   * Mostly useful at the end of input for an empty stream.
   */
  streamInfo() {
    return {
      comment: parsePrelude(this.prelude).comment,
      directives: this.directives,
      errors: this.errors,
      warnings: this.warnings
    };
  }
  /**
   * Compose tokens into documents.
   *
   * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
   * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
   */
  *compose(tokens, forceDoc = false, endOffset = -1) {
    for (const token of tokens)
      yield* this.next(token);
    yield* this.end(forceDoc, endOffset);
  }
  /** Advance the composer by one CST token. */
  *next(token) {
    switch (token.type) {
      case "directive":
        this.directives.add(token.source, (offset, message, warning) => {
          const pos = getErrorPos(token);
          pos[0] += offset;
          this.onError(pos, "BAD_DIRECTIVE", message, warning);
        });
        this.prelude.push(token.source);
        this.atDirectives = true;
        break;
      case "document": {
        const doc = composeDoc(this.options, this.directives, token, this.onError);
        if (this.atDirectives && !doc.directives.marker)
          this.onError(token, "MISSING_CHAR", "Missing directives-end indicator line");
        this.decorate(doc, false);
        if (this.doc)
          yield this.doc;
        this.doc = doc;
        this.atDirectives = false;
        break;
      }
      case "byte-order-mark":
      case "space":
        break;
      case "comment":
      case "newline":
        this.prelude.push(token.source);
        break;
      case "error": {
        const msg = token.source ? `${token.message}: ${JSON.stringify(token.source)}` : token.message;
        const error = new YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", msg);
        if (this.atDirectives || !this.doc)
          this.errors.push(error);
        else
          this.doc.errors.push(error);
        break;
      }
      case "doc-end": {
        if (!this.doc) {
          const msg = "Unexpected doc-end without preceding document";
          this.errors.push(new YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", msg));
          break;
        }
        const end = resolveEnd(token.end, token.offset + token.source.length, this.doc.options.strict, this.onError);
        this.decorate(this.doc, true);
        if (end.comment) {
          const dc = this.doc.comment;
          this.doc.comment = dc ? `${dc}
${end.comment}` : end.comment;
        }
        this.doc.range[2] = end.offset;
        break;
      }
      default:
        this.errors.push(new YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", `Unsupported token ${token.type}`));
    }
  }
  /**
   * Call at end of input to yield any remaining document.
   *
   * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
   * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
   */
  *end(forceDoc = false, endOffset = -1) {
    if (this.doc) {
      this.decorate(this.doc, true);
      yield this.doc;
      this.doc = null;
    } else if (forceDoc) {
      const opts = Object.assign({ directives: this.directives }, this.options);
      const doc = new Document(void 0, opts);
      if (this.atDirectives)
        this.onError(endOffset, "MISSING_CHAR", "Missing directives-end indicator line");
      doc.range = [0, endOffset, endOffset];
      this.decorate(doc, false);
      yield doc;
    }
  }
};

// node_modules/yaml/browser/dist/parse/cst.js
var cst_exports = {};
__export(cst_exports, {
  BOM: () => BOM,
  DOCUMENT: () => DOCUMENT,
  FLOW_END: () => FLOW_END,
  SCALAR: () => SCALAR2,
  createScalarToken: () => createScalarToken,
  isCollection: () => isCollection2,
  isScalar: () => isScalar2,
  prettyToken: () => prettyToken,
  resolveAsScalar: () => resolveAsScalar,
  setScalarValue: () => setScalarValue,
  stringify: () => stringify2,
  tokenType: () => tokenType,
  visit: () => visit2
});

// node_modules/yaml/browser/dist/parse/cst-scalar.js
function resolveAsScalar(token, strict = true, onError) {
  if (token) {
    const _onError = (pos, code, message) => {
      const offset = typeof pos === "number" ? pos : Array.isArray(pos) ? pos[0] : pos.offset;
      if (onError)
        onError(offset, code, message);
      else
        throw new YAMLParseError([offset, offset + 1], code, message);
    };
    switch (token.type) {
      case "scalar":
      case "single-quoted-scalar":
      case "double-quoted-scalar":
        return resolveFlowScalar(token, strict, _onError);
      case "block-scalar":
        return resolveBlockScalar(token, strict, _onError);
    }
  }
  return null;
}
function createScalarToken(value, context) {
  var _a;
  const { implicitKey = false, indent, inFlow = false, offset = -1, type = "PLAIN" } = context;
  const source = stringifyString({ type, value }, {
    implicitKey,
    indent: indent > 0 ? " ".repeat(indent) : "",
    inFlow,
    options: { blockQuote: true, lineWidth: -1 }
  });
  const end = (_a = context.end) !== null && _a !== void 0 ? _a : [
    { type: "newline", offset: -1, indent, source: "\n" }
  ];
  switch (source[0]) {
    case "|":
    case ">": {
      const he = source.indexOf("\n");
      const head = source.substring(0, he);
      const body = source.substring(he + 1) + "\n";
      const props = [
        { type: "block-scalar-header", offset, indent, source: head }
      ];
      if (!addEndtoBlockProps(props, end))
        props.push({ type: "newline", offset: -1, indent, source: "\n" });
      return { type: "block-scalar", offset, indent, props, source: body };
    }
    case '"':
      return { type: "double-quoted-scalar", offset, indent, source, end };
    case "'":
      return { type: "single-quoted-scalar", offset, indent, source, end };
    default:
      return { type: "scalar", offset, indent, source, end };
  }
}
function setScalarValue(token, value, context = {}) {
  let { afterKey = false, implicitKey = false, inFlow = false, type } = context;
  let indent = "indent" in token ? token.indent : null;
  if (afterKey && typeof indent === "number")
    indent += 2;
  if (!type)
    switch (token.type) {
      case "single-quoted-scalar":
        type = "QUOTE_SINGLE";
        break;
      case "double-quoted-scalar":
        type = "QUOTE_DOUBLE";
        break;
      case "block-scalar": {
        const header = token.props[0];
        if (header.type !== "block-scalar-header")
          throw new Error("Invalid block scalar header");
        type = header.source[0] === ">" ? "BLOCK_FOLDED" : "BLOCK_LITERAL";
        break;
      }
      default:
        type = "PLAIN";
    }
  const source = stringifyString({ type, value }, {
    implicitKey: implicitKey || indent === null,
    indent: indent !== null && indent > 0 ? " ".repeat(indent) : "",
    inFlow,
    options: { blockQuote: true, lineWidth: -1 }
  });
  switch (source[0]) {
    case "|":
    case ">":
      setBlockScalarValue(token, source);
      break;
    case '"':
      setFlowScalarValue(token, source, "double-quoted-scalar");
      break;
    case "'":
      setFlowScalarValue(token, source, "single-quoted-scalar");
      break;
    default:
      setFlowScalarValue(token, source, "scalar");
  }
}
function setBlockScalarValue(token, source) {
  const he = source.indexOf("\n");
  const head = source.substring(0, he);
  const body = source.substring(he + 1) + "\n";
  if (token.type === "block-scalar") {
    const header = token.props[0];
    if (header.type !== "block-scalar-header")
      throw new Error("Invalid block scalar header");
    header.source = head;
    token.source = body;
  } else {
    const { offset } = token;
    const indent = "indent" in token ? token.indent : -1;
    const props = [
      { type: "block-scalar-header", offset, indent, source: head }
    ];
    if (!addEndtoBlockProps(props, "end" in token ? token.end : void 0))
      props.push({ type: "newline", offset: -1, indent, source: "\n" });
    for (const key of Object.keys(token))
      if (key !== "type" && key !== "offset")
        delete token[key];
    Object.assign(token, { type: "block-scalar", indent, props, source: body });
  }
}
function addEndtoBlockProps(props, end) {
  if (end)
    for (const st of end)
      switch (st.type) {
        case "space":
        case "comment":
          props.push(st);
          break;
        case "newline":
          props.push(st);
          return true;
      }
  return false;
}
function setFlowScalarValue(token, source, type) {
  switch (token.type) {
    case "scalar":
    case "double-quoted-scalar":
    case "single-quoted-scalar":
      token.type = type;
      token.source = source;
      break;
    case "block-scalar": {
      const end = token.props.slice(1);
      let oa = source.length;
      if (token.props[0].type === "block-scalar-header")
        oa -= token.props[0].source.length;
      for (const tok of end)
        tok.offset += oa;
      delete token.props;
      Object.assign(token, { type, source, end });
      break;
    }
    case "block-map":
    case "block-seq": {
      const offset = token.offset + source.length;
      const nl = { type: "newline", offset, indent: token.indent, source: "\n" };
      delete token.items;
      Object.assign(token, { type, source, end: [nl] });
      break;
    }
    default: {
      const indent = "indent" in token ? token.indent : -1;
      const end = "end" in token && Array.isArray(token.end) ? token.end.filter((st) => st.type === "space" || st.type === "comment" || st.type === "newline") : [];
      for (const key of Object.keys(token))
        if (key !== "type" && key !== "offset")
          delete token[key];
      Object.assign(token, { type, indent, source, end });
    }
  }
}

// node_modules/yaml/browser/dist/parse/cst-stringify.js
var stringify2 = (cst) => "type" in cst ? stringifyToken(cst) : stringifyItem(cst);
function stringifyToken(token) {
  switch (token.type) {
    case "block-scalar": {
      let res = "";
      for (const tok of token.props)
        res += stringifyToken(tok);
      return res + token.source;
    }
    case "block-map":
    case "block-seq": {
      let res = "";
      for (const item of token.items)
        res += stringifyItem(item);
      return res;
    }
    case "flow-collection": {
      let res = token.start.source;
      for (const item of token.items)
        res += stringifyItem(item);
      for (const st of token.end)
        res += st.source;
      return res;
    }
    case "document": {
      let res = stringifyItem(token);
      if (token.end)
        for (const st of token.end)
          res += st.source;
      return res;
    }
    default: {
      let res = token.source;
      if ("end" in token && token.end)
        for (const st of token.end)
          res += st.source;
      return res;
    }
  }
}
function stringifyItem({ start, key, sep, value }) {
  let res = "";
  for (const st of start)
    res += st.source;
  if (key)
    res += stringifyToken(key);
  if (sep)
    for (const st of sep)
      res += st.source;
  if (value)
    res += stringifyToken(value);
  return res;
}

// node_modules/yaml/browser/dist/parse/cst-visit.js
var BREAK2 = Symbol("break visit");
var SKIP2 = Symbol("skip children");
var REMOVE2 = Symbol("remove item");
function visit2(cst, visitor) {
  if ("type" in cst && cst.type === "document")
    cst = { start: cst.start, value: cst.value };
  _visit2(Object.freeze([]), cst, visitor);
}
visit2.BREAK = BREAK2;
visit2.SKIP = SKIP2;
visit2.REMOVE = REMOVE2;
visit2.itemAtPath = (cst, path) => {
  let item = cst;
  for (const [field, index] of path) {
    const tok = item && item[field];
    if (tok && "items" in tok) {
      item = tok.items[index];
    } else
      return void 0;
  }
  return item;
};
visit2.parentCollection = (cst, path) => {
  const parent = visit2.itemAtPath(cst, path.slice(0, -1));
  const field = path[path.length - 1][0];
  const coll = parent && parent[field];
  if (coll && "items" in coll)
    return coll;
  throw new Error("Parent collection not found");
};
function _visit2(path, item, visitor) {
  let ctrl = visitor(item, path);
  if (typeof ctrl === "symbol")
    return ctrl;
  for (const field of ["key", "value"]) {
    const token = item[field];
    if (token && "items" in token) {
      for (let i = 0; i < token.items.length; ++i) {
        const ci = _visit2(Object.freeze(path.concat([[field, i]])), token.items[i], visitor);
        if (typeof ci === "number")
          i = ci - 1;
        else if (ci === BREAK2)
          return BREAK2;
        else if (ci === REMOVE2) {
          token.items.splice(i, 1);
          i -= 1;
        }
      }
      if (typeof ctrl === "function" && field === "key")
        ctrl = ctrl(item, path);
    }
  }
  return typeof ctrl === "function" ? ctrl(item, path) : ctrl;
}

// node_modules/yaml/browser/dist/parse/cst.js
var BOM = "\uFEFF";
var DOCUMENT = "";
var FLOW_END = "";
var SCALAR2 = "";
var isCollection2 = (token) => !!token && "items" in token;
var isScalar2 = (token) => !!token && (token.type === "scalar" || token.type === "single-quoted-scalar" || token.type === "double-quoted-scalar" || token.type === "block-scalar");
function prettyToken(token) {
  switch (token) {
    case BOM:
      return "<BOM>";
    case DOCUMENT:
      return "<DOC>";
    case FLOW_END:
      return "<FLOW_END>";
    case SCALAR2:
      return "<SCALAR>";
    default:
      return JSON.stringify(token);
  }
}
function tokenType(source) {
  switch (source) {
    case BOM:
      return "byte-order-mark";
    case DOCUMENT:
      return "doc-mode";
    case FLOW_END:
      return "flow-error-end";
    case SCALAR2:
      return "scalar";
    case "---":
      return "doc-start";
    case "...":
      return "doc-end";
    case "":
    case "\n":
    case "\r\n":
      return "newline";
    case "-":
      return "seq-item-ind";
    case "?":
      return "explicit-key-ind";
    case ":":
      return "map-value-ind";
    case "{":
      return "flow-map-start";
    case "}":
      return "flow-map-end";
    case "[":
      return "flow-seq-start";
    case "]":
      return "flow-seq-end";
    case ",":
      return "comma";
  }
  switch (source[0]) {
    case " ":
    case "	":
      return "space";
    case "#":
      return "comment";
    case "%":
      return "directive-line";
    case "*":
      return "alias";
    case "&":
      return "anchor";
    case "!":
      return "tag";
    case "'":
      return "single-quoted-scalar";
    case '"':
      return "double-quoted-scalar";
    case "|":
    case ">":
      return "block-scalar-header";
  }
  return null;
}

// node_modules/yaml/browser/dist/parse/lexer.js
function isEmpty(ch) {
  switch (ch) {
    case void 0:
    case " ":
    case "\n":
    case "\r":
    case "	":
      return true;
    default:
      return false;
  }
}
var hexDigits = "0123456789ABCDEFabcdef".split("");
var tagChars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-#;/?:@&=+$_.!~*'()".split("");
var invalidFlowScalarChars = ",[]{}".split("");
var invalidAnchorChars = " ,[]{}\n\r	".split("");
var isNotAnchorChar = (ch) => !ch || invalidAnchorChars.includes(ch);
var Lexer = class {
  constructor() {
    this.atEnd = false;
    this.blockScalarIndent = -1;
    this.blockScalarKeep = false;
    this.buffer = "";
    this.flowKey = false;
    this.flowLevel = 0;
    this.indentNext = 0;
    this.indentValue = 0;
    this.lineEndPos = null;
    this.next = null;
    this.pos = 0;
  }
  /**
   * Generate YAML tokens from the `source` string. If `incomplete`,
   * a part of the last line may be left as a buffer for the next call.
   *
   * @returns A generator of lexical tokens
   */
  *lex(source, incomplete = false) {
    if (source) {
      this.buffer = this.buffer ? this.buffer + source : source;
      this.lineEndPos = null;
    }
    this.atEnd = !incomplete;
    let next = this.next || "stream";
    while (next && (incomplete || this.hasChars(1)))
      next = yield* this.parseNext(next);
  }
  atLineEnd() {
    let i = this.pos;
    let ch = this.buffer[i];
    while (ch === " " || ch === "	")
      ch = this.buffer[++i];
    if (!ch || ch === "#" || ch === "\n")
      return true;
    if (ch === "\r")
      return this.buffer[i + 1] === "\n";
    return false;
  }
  charAt(n) {
    return this.buffer[this.pos + n];
  }
  continueScalar(offset) {
    let ch = this.buffer[offset];
    if (this.indentNext > 0) {
      let indent = 0;
      while (ch === " ")
        ch = this.buffer[++indent + offset];
      if (ch === "\r") {
        const next = this.buffer[indent + offset + 1];
        if (next === "\n" || !next && !this.atEnd)
          return offset + indent + 1;
      }
      return ch === "\n" || indent >= this.indentNext || !ch && !this.atEnd ? offset + indent : -1;
    }
    if (ch === "-" || ch === ".") {
      const dt = this.buffer.substr(offset, 3);
      if ((dt === "---" || dt === "...") && isEmpty(this.buffer[offset + 3]))
        return -1;
    }
    return offset;
  }
  getLine() {
    let end = this.lineEndPos;
    if (typeof end !== "number" || end !== -1 && end < this.pos) {
      end = this.buffer.indexOf("\n", this.pos);
      this.lineEndPos = end;
    }
    if (end === -1)
      return this.atEnd ? this.buffer.substring(this.pos) : null;
    if (this.buffer[end - 1] === "\r")
      end -= 1;
    return this.buffer.substring(this.pos, end);
  }
  hasChars(n) {
    return this.pos + n <= this.buffer.length;
  }
  setNext(state) {
    this.buffer = this.buffer.substring(this.pos);
    this.pos = 0;
    this.lineEndPos = null;
    this.next = state;
    return null;
  }
  peek(n) {
    return this.buffer.substr(this.pos, n);
  }
  *parseNext(next) {
    switch (next) {
      case "stream":
        return yield* this.parseStream();
      case "line-start":
        return yield* this.parseLineStart();
      case "block-start":
        return yield* this.parseBlockStart();
      case "doc":
        return yield* this.parseDocument();
      case "flow":
        return yield* this.parseFlowCollection();
      case "quoted-scalar":
        return yield* this.parseQuotedScalar();
      case "block-scalar":
        return yield* this.parseBlockScalar();
      case "plain-scalar":
        return yield* this.parsePlainScalar();
    }
  }
  *parseStream() {
    let line = this.getLine();
    if (line === null)
      return this.setNext("stream");
    if (line[0] === BOM) {
      yield* this.pushCount(1);
      line = line.substring(1);
    }
    if (line[0] === "%") {
      let dirEnd = line.length;
      const cs = line.indexOf("#");
      if (cs !== -1) {
        const ch = line[cs - 1];
        if (ch === " " || ch === "	")
          dirEnd = cs - 1;
      }
      while (true) {
        const ch = line[dirEnd - 1];
        if (ch === " " || ch === "	")
          dirEnd -= 1;
        else
          break;
      }
      const n = (yield* this.pushCount(dirEnd)) + (yield* this.pushSpaces(true));
      yield* this.pushCount(line.length - n);
      this.pushNewline();
      return "stream";
    }
    if (this.atLineEnd()) {
      const sp = yield* this.pushSpaces(true);
      yield* this.pushCount(line.length - sp);
      yield* this.pushNewline();
      return "stream";
    }
    yield DOCUMENT;
    return yield* this.parseLineStart();
  }
  *parseLineStart() {
    const ch = this.charAt(0);
    if (!ch && !this.atEnd)
      return this.setNext("line-start");
    if (ch === "-" || ch === ".") {
      if (!this.atEnd && !this.hasChars(4))
        return this.setNext("line-start");
      const s = this.peek(3);
      if (s === "---" && isEmpty(this.charAt(3))) {
        yield* this.pushCount(3);
        this.indentValue = 0;
        this.indentNext = 0;
        return "doc";
      } else if (s === "..." && isEmpty(this.charAt(3))) {
        yield* this.pushCount(3);
        return "stream";
      }
    }
    this.indentValue = yield* this.pushSpaces(false);
    if (this.indentNext > this.indentValue && !isEmpty(this.charAt(1)))
      this.indentNext = this.indentValue;
    return yield* this.parseBlockStart();
  }
  *parseBlockStart() {
    const [ch0, ch1] = this.peek(2);
    if (!ch1 && !this.atEnd)
      return this.setNext("block-start");
    if ((ch0 === "-" || ch0 === "?" || ch0 === ":") && isEmpty(ch1)) {
      const n = (yield* this.pushCount(1)) + (yield* this.pushSpaces(true));
      this.indentNext = this.indentValue + 1;
      this.indentValue += n;
      return yield* this.parseBlockStart();
    }
    return "doc";
  }
  *parseDocument() {
    yield* this.pushSpaces(true);
    const line = this.getLine();
    if (line === null)
      return this.setNext("doc");
    let n = yield* this.pushIndicators();
    switch (line[n]) {
      case "#":
        yield* this.pushCount(line.length - n);
      case void 0:
        yield* this.pushNewline();
        return yield* this.parseLineStart();
      case "{":
      case "[":
        yield* this.pushCount(1);
        this.flowKey = false;
        this.flowLevel = 1;
        return "flow";
      case "}":
      case "]":
        yield* this.pushCount(1);
        return "doc";
      case "*":
        yield* this.pushUntil(isNotAnchorChar);
        return "doc";
      case '"':
      case "'":
        return yield* this.parseQuotedScalar();
      case "|":
      case ">":
        n += yield* this.parseBlockScalarHeader();
        n += yield* this.pushSpaces(true);
        yield* this.pushCount(line.length - n);
        yield* this.pushNewline();
        return yield* this.parseBlockScalar();
      default:
        return yield* this.parsePlainScalar();
    }
  }
  *parseFlowCollection() {
    let nl, sp;
    let indent = -1;
    do {
      nl = yield* this.pushNewline();
      sp = yield* this.pushSpaces(true);
      if (nl > 0)
        this.indentValue = indent = sp;
    } while (nl + sp > 0);
    const line = this.getLine();
    if (line === null)
      return this.setNext("flow");
    if (indent !== -1 && indent < this.indentNext && line[0] !== "#" || indent === 0 && (line.startsWith("---") || line.startsWith("...")) && isEmpty(line[3])) {
      const atFlowEndMarker = indent === this.indentNext - 1 && this.flowLevel === 1 && (line[0] === "]" || line[0] === "}");
      if (!atFlowEndMarker) {
        this.flowLevel = 0;
        yield FLOW_END;
        return yield* this.parseLineStart();
      }
    }
    let n = 0;
    while (line[n] === ",") {
      n += yield* this.pushCount(1);
      n += yield* this.pushSpaces(true);
      this.flowKey = false;
    }
    n += yield* this.pushIndicators();
    switch (line[n]) {
      case void 0:
        return "flow";
      case "#":
        yield* this.pushCount(line.length - n);
        return "flow";
      case "{":
      case "[":
        yield* this.pushCount(1);
        this.flowKey = false;
        this.flowLevel += 1;
        return "flow";
      case "}":
      case "]":
        yield* this.pushCount(1);
        this.flowKey = true;
        this.flowLevel -= 1;
        return this.flowLevel ? "flow" : "doc";
      case "*":
        yield* this.pushUntil(isNotAnchorChar);
        return "flow";
      case '"':
      case "'":
        this.flowKey = true;
        return yield* this.parseQuotedScalar();
      case ":": {
        const next = this.charAt(1);
        if (this.flowKey || isEmpty(next) || next === ",") {
          this.flowKey = false;
          yield* this.pushCount(1);
          yield* this.pushSpaces(true);
          return "flow";
        }
      }
      default:
        this.flowKey = false;
        return yield* this.parsePlainScalar();
    }
  }
  *parseQuotedScalar() {
    const quote = this.charAt(0);
    let end = this.buffer.indexOf(quote, this.pos + 1);
    if (quote === "'") {
      while (end !== -1 && this.buffer[end + 1] === "'")
        end = this.buffer.indexOf("'", end + 2);
    } else {
      while (end !== -1) {
        let n = 0;
        while (this.buffer[end - 1 - n] === "\\")
          n += 1;
        if (n % 2 === 0)
          break;
        end = this.buffer.indexOf('"', end + 1);
      }
    }
    const qb = this.buffer.substring(0, end);
    let nl = qb.indexOf("\n", this.pos);
    if (nl !== -1) {
      while (nl !== -1) {
        const cs = this.continueScalar(nl + 1);
        if (cs === -1)
          break;
        nl = qb.indexOf("\n", cs);
      }
      if (nl !== -1) {
        end = nl - (qb[nl - 1] === "\r" ? 2 : 1);
      }
    }
    if (end === -1) {
      if (!this.atEnd)
        return this.setNext("quoted-scalar");
      end = this.buffer.length;
    }
    yield* this.pushToIndex(end + 1, false);
    return this.flowLevel ? "flow" : "doc";
  }
  *parseBlockScalarHeader() {
    this.blockScalarIndent = -1;
    this.blockScalarKeep = false;
    let i = this.pos;
    while (true) {
      const ch = this.buffer[++i];
      if (ch === "+")
        this.blockScalarKeep = true;
      else if (ch > "0" && ch <= "9")
        this.blockScalarIndent = Number(ch) - 1;
      else if (ch !== "-")
        break;
    }
    return yield* this.pushUntil((ch) => isEmpty(ch) || ch === "#");
  }
  *parseBlockScalar() {
    let nl = this.pos - 1;
    let indent = 0;
    let ch;
    loop:
      for (let i = this.pos; ch = this.buffer[i]; ++i) {
        switch (ch) {
          case " ":
            indent += 1;
            break;
          case "\n":
            nl = i;
            indent = 0;
            break;
          case "\r": {
            const next = this.buffer[i + 1];
            if (!next && !this.atEnd)
              return this.setNext("block-scalar");
            if (next === "\n")
              break;
          }
          default:
            break loop;
        }
      }
    if (!ch && !this.atEnd)
      return this.setNext("block-scalar");
    if (indent >= this.indentNext) {
      if (this.blockScalarIndent === -1)
        this.indentNext = indent;
      else
        this.indentNext += this.blockScalarIndent;
      do {
        const cs = this.continueScalar(nl + 1);
        if (cs === -1)
          break;
        nl = this.buffer.indexOf("\n", cs);
      } while (nl !== -1);
      if (nl === -1) {
        if (!this.atEnd)
          return this.setNext("block-scalar");
        nl = this.buffer.length;
      }
    }
    if (!this.blockScalarKeep) {
      do {
        let i = nl - 1;
        let ch2 = this.buffer[i];
        if (ch2 === "\r")
          ch2 = this.buffer[--i];
        while (ch2 === " " || ch2 === "	")
          ch2 = this.buffer[--i];
        if (ch2 === "\n" && i >= this.pos)
          nl = i;
        else
          break;
      } while (true);
    }
    yield SCALAR2;
    yield* this.pushToIndex(nl + 1, true);
    return yield* this.parseLineStart();
  }
  *parsePlainScalar() {
    const inFlow = this.flowLevel > 0;
    let end = this.pos - 1;
    let i = this.pos - 1;
    let ch;
    while (ch = this.buffer[++i]) {
      if (ch === ":") {
        const next = this.buffer[i + 1];
        if (isEmpty(next) || inFlow && next === ",")
          break;
        end = i;
      } else if (isEmpty(ch)) {
        let next = this.buffer[i + 1];
        if (ch === "\r") {
          if (next === "\n") {
            i += 1;
            ch = "\n";
            next = this.buffer[i + 1];
          } else
            end = i;
        }
        if (next === "#" || inFlow && invalidFlowScalarChars.includes(next))
          break;
        if (ch === "\n") {
          const cs = this.continueScalar(i + 1);
          if (cs === -1)
            break;
          i = Math.max(i, cs - 2);
        }
      } else {
        if (inFlow && invalidFlowScalarChars.includes(ch))
          break;
        end = i;
      }
    }
    if (!ch && !this.atEnd)
      return this.setNext("plain-scalar");
    yield SCALAR2;
    yield* this.pushToIndex(end + 1, true);
    return inFlow ? "flow" : "doc";
  }
  *pushCount(n) {
    if (n > 0) {
      yield this.buffer.substr(this.pos, n);
      this.pos += n;
      return n;
    }
    return 0;
  }
  *pushToIndex(i, allowEmpty) {
    const s = this.buffer.slice(this.pos, i);
    if (s) {
      yield s;
      this.pos += s.length;
      return s.length;
    } else if (allowEmpty)
      yield "";
    return 0;
  }
  *pushIndicators() {
    switch (this.charAt(0)) {
      case "!":
        return (yield* this.pushTag()) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
      case "&":
        return (yield* this.pushUntil(isNotAnchorChar)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
      case ":":
      case "?":
      case "-":
        if (isEmpty(this.charAt(1))) {
          if (this.flowLevel === 0)
            this.indentNext = this.indentValue + 1;
          else if (this.flowKey)
            this.flowKey = false;
          return (yield* this.pushCount(1)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
        }
    }
    return 0;
  }
  *pushTag() {
    if (this.charAt(1) === "<") {
      let i = this.pos + 2;
      let ch = this.buffer[i];
      while (!isEmpty(ch) && ch !== ">")
        ch = this.buffer[++i];
      return yield* this.pushToIndex(ch === ">" ? i + 1 : i, false);
    } else {
      let i = this.pos + 1;
      let ch = this.buffer[i];
      while (ch) {
        if (tagChars.includes(ch))
          ch = this.buffer[++i];
        else if (ch === "%" && hexDigits.includes(this.buffer[i + 1]) && hexDigits.includes(this.buffer[i + 2])) {
          ch = this.buffer[i += 3];
        } else
          break;
      }
      return yield* this.pushToIndex(i, false);
    }
  }
  *pushNewline() {
    const ch = this.buffer[this.pos];
    if (ch === "\n")
      return yield* this.pushCount(1);
    else if (ch === "\r" && this.charAt(1) === "\n")
      return yield* this.pushCount(2);
    else
      return 0;
  }
  *pushSpaces(allowTabs) {
    let i = this.pos - 1;
    let ch;
    do {
      ch = this.buffer[++i];
    } while (ch === " " || allowTabs && ch === "	");
    const n = i - this.pos;
    if (n > 0) {
      yield this.buffer.substr(this.pos, n);
      this.pos = i;
    }
    return n;
  }
  *pushUntil(test) {
    let i = this.pos;
    let ch = this.buffer[i];
    while (!test(ch))
      ch = this.buffer[++i];
    return yield* this.pushToIndex(i, false);
  }
};

// node_modules/yaml/browser/dist/parse/line-counter.js
var LineCounter = class {
  constructor() {
    this.lineStarts = [];
    this.addNewLine = (offset) => this.lineStarts.push(offset);
    this.linePos = (offset) => {
      let low = 0;
      let high = this.lineStarts.length;
      while (low < high) {
        const mid = low + high >> 1;
        if (this.lineStarts[mid] < offset)
          low = mid + 1;
        else
          high = mid;
      }
      if (this.lineStarts[low] === offset)
        return { line: low + 1, col: 1 };
      if (low === 0)
        return { line: 0, col: offset };
      const start = this.lineStarts[low - 1];
      return { line: low, col: offset - start + 1 };
    };
  }
};

// node_modules/yaml/browser/dist/parse/parser.js
function includesToken(list, type) {
  for (let i = 0; i < list.length; ++i)
    if (list[i].type === type)
      return true;
  return false;
}
function includesNonEmpty(list) {
  for (let i = 0; i < list.length; ++i) {
    switch (list[i].type) {
      case "space":
      case "comment":
      case "newline":
        break;
      default:
        return true;
    }
  }
  return false;
}
function isFlowToken(token) {
  switch (token === null || token === void 0 ? void 0 : token.type) {
    case "alias":
    case "scalar":
    case "single-quoted-scalar":
    case "double-quoted-scalar":
    case "flow-collection":
      return true;
    default:
      return false;
  }
}
function getPrevProps(parent) {
  switch (parent.type) {
    case "document":
      return parent.start;
    case "block-map": {
      const it = parent.items[parent.items.length - 1];
      return it.sep || it.start;
    }
    case "block-seq":
      return parent.items[parent.items.length - 1].start;
    default:
      return [];
  }
}
function getFirstKeyStartProps(prev) {
  var _a;
  if (prev.length === 0)
    return [];
  let i = prev.length;
  loop:
    while (--i >= 0) {
      switch (prev[i].type) {
        case "doc-start":
        case "explicit-key-ind":
        case "map-value-ind":
        case "seq-item-ind":
        case "newline":
          break loop;
      }
    }
  while (((_a = prev[++i]) === null || _a === void 0 ? void 0 : _a.type) === "space") {
  }
  return prev.splice(i, prev.length);
}
function fixFlowSeqItems(fc) {
  if (fc.start.type === "flow-seq-start") {
    for (const it of fc.items) {
      if (it.sep && !it.value && !includesToken(it.start, "explicit-key-ind") && !includesToken(it.sep, "map-value-ind")) {
        if (it.key)
          it.value = it.key;
        delete it.key;
        if (isFlowToken(it.value)) {
          if (it.value.end)
            Array.prototype.push.apply(it.value.end, it.sep);
          else
            it.value.end = it.sep;
        } else
          Array.prototype.push.apply(it.start, it.sep);
        delete it.sep;
      }
    }
  }
}
var Parser = class {
  /**
   * @param onNewLine - If defined, called separately with the start position of
   *   each new line (in `parse()`, including the start of input).
   */
  constructor(onNewLine) {
    this.atNewLine = true;
    this.atScalar = false;
    this.indent = 0;
    this.offset = 0;
    this.onKeyLine = false;
    this.stack = [];
    this.source = "";
    this.type = "";
    this.lexer = new Lexer();
    this.onNewLine = onNewLine;
  }
  /**
   * Parse `source` as a YAML stream.
   * If `incomplete`, a part of the last line may be left as a buffer for the next call.
   *
   * Errors are not thrown, but yielded as `{ type: 'error', message }` tokens.
   *
   * @returns A generator of tokens representing each directive, document, and other structure.
   */
  *parse(source, incomplete = false) {
    if (this.onNewLine && this.offset === 0)
      this.onNewLine(0);
    for (const lexeme of this.lexer.lex(source, incomplete))
      yield* this.next(lexeme);
    if (!incomplete)
      yield* this.end();
  }
  /**
   * Advance the parser by the `source` of one lexical token.
   */
  *next(source) {
    this.source = source;
    if (this.atScalar) {
      this.atScalar = false;
      yield* this.step();
      this.offset += source.length;
      return;
    }
    const type = tokenType(source);
    if (!type) {
      const message = `Not a YAML token: ${source}`;
      yield* this.pop({ type: "error", offset: this.offset, message, source });
      this.offset += source.length;
    } else if (type === "scalar") {
      this.atNewLine = false;
      this.atScalar = true;
      this.type = "scalar";
    } else {
      this.type = type;
      yield* this.step();
      switch (type) {
        case "newline":
          this.atNewLine = true;
          this.indent = 0;
          if (this.onNewLine)
            this.onNewLine(this.offset + source.length);
          break;
        case "space":
          if (this.atNewLine && source[0] === " ")
            this.indent += source.length;
          break;
        case "explicit-key-ind":
        case "map-value-ind":
        case "seq-item-ind":
          if (this.atNewLine)
            this.indent += source.length;
          break;
        case "doc-mode":
        case "flow-error-end":
          return;
        default:
          this.atNewLine = false;
      }
      this.offset += source.length;
    }
  }
  /** Call at end of input to push out any remaining constructions */
  *end() {
    while (this.stack.length > 0)
      yield* this.pop();
  }
  get sourceToken() {
    const st = {
      type: this.type,
      offset: this.offset,
      indent: this.indent,
      source: this.source
    };
    return st;
  }
  *step() {
    const top = this.peek(1);
    if (this.type === "doc-end" && (!top || top.type !== "doc-end")) {
      while (this.stack.length > 0)
        yield* this.pop();
      this.stack.push({
        type: "doc-end",
        offset: this.offset,
        source: this.source
      });
      return;
    }
    if (!top)
      return yield* this.stream();
    switch (top.type) {
      case "document":
        return yield* this.document(top);
      case "alias":
      case "scalar":
      case "single-quoted-scalar":
      case "double-quoted-scalar":
        return yield* this.scalar(top);
      case "block-scalar":
        return yield* this.blockScalar(top);
      case "block-map":
        return yield* this.blockMap(top);
      case "block-seq":
        return yield* this.blockSequence(top);
      case "flow-collection":
        return yield* this.flowCollection(top);
      case "doc-end":
        return yield* this.documentEnd(top);
    }
    yield* this.pop();
  }
  peek(n) {
    return this.stack[this.stack.length - n];
  }
  *pop(error) {
    const token = error || this.stack.pop();
    if (!token) {
      const message = "Tried to pop an empty stack";
      yield { type: "error", offset: this.offset, source: "", message };
    } else if (this.stack.length === 0) {
      yield token;
    } else {
      const top = this.peek(1);
      if (token.type === "block-scalar") {
        token.indent = "indent" in top ? top.indent : 0;
      } else if (token.type === "flow-collection" && top.type === "document") {
        token.indent = 0;
      }
      if (token.type === "flow-collection")
        fixFlowSeqItems(token);
      switch (top.type) {
        case "document":
          top.value = token;
          break;
        case "block-scalar":
          top.props.push(token);
          break;
        case "block-map": {
          const it = top.items[top.items.length - 1];
          if (it.value) {
            top.items.push({ start: [], key: token, sep: [] });
            this.onKeyLine = true;
            return;
          } else if (it.sep) {
            it.value = token;
          } else {
            Object.assign(it, { key: token, sep: [] });
            this.onKeyLine = !includesToken(it.start, "explicit-key-ind");
            return;
          }
          break;
        }
        case "block-seq": {
          const it = top.items[top.items.length - 1];
          if (it.value)
            top.items.push({ start: [], value: token });
          else
            it.value = token;
          break;
        }
        case "flow-collection": {
          const it = top.items[top.items.length - 1];
          if (!it || it.value)
            top.items.push({ start: [], key: token, sep: [] });
          else if (it.sep)
            it.value = token;
          else
            Object.assign(it, { key: token, sep: [] });
          return;
        }
        default:
          yield* this.pop();
          yield* this.pop(token);
      }
      if ((top.type === "document" || top.type === "block-map" || top.type === "block-seq") && (token.type === "block-map" || token.type === "block-seq")) {
        const last = token.items[token.items.length - 1];
        if (last && !last.sep && !last.value && last.start.length > 0 && !includesNonEmpty(last.start) && (token.indent === 0 || last.start.every((st) => st.type !== "comment" || st.indent < token.indent))) {
          if (top.type === "document")
            top.end = last.start;
          else
            top.items.push({ start: last.start });
          token.items.splice(-1, 1);
        }
      }
    }
  }
  *stream() {
    switch (this.type) {
      case "directive-line":
        yield { type: "directive", offset: this.offset, source: this.source };
        return;
      case "byte-order-mark":
      case "space":
      case "comment":
      case "newline":
        yield this.sourceToken;
        return;
      case "doc-mode":
      case "doc-start": {
        const doc = {
          type: "document",
          offset: this.offset,
          start: []
        };
        if (this.type === "doc-start")
          doc.start.push(this.sourceToken);
        this.stack.push(doc);
        return;
      }
    }
    yield {
      type: "error",
      offset: this.offset,
      message: `Unexpected ${this.type} token in YAML stream`,
      source: this.source
    };
  }
  *document(doc) {
    if (doc.value)
      return yield* this.lineEnd(doc);
    switch (this.type) {
      case "doc-start": {
        if (includesNonEmpty(doc.start)) {
          yield* this.pop();
          yield* this.step();
        } else
          doc.start.push(this.sourceToken);
        return;
      }
      case "anchor":
      case "tag":
      case "space":
      case "comment":
      case "newline":
        doc.start.push(this.sourceToken);
        return;
    }
    const bv = this.startBlockValue(doc);
    if (bv)
      this.stack.push(bv);
    else {
      yield {
        type: "error",
        offset: this.offset,
        message: `Unexpected ${this.type} token in YAML document`,
        source: this.source
      };
    }
  }
  *scalar(scalar) {
    if (this.type === "map-value-ind") {
      const prev = getPrevProps(this.peek(2));
      const start = getFirstKeyStartProps(prev);
      let sep;
      if (scalar.end) {
        sep = scalar.end;
        sep.push(this.sourceToken);
        delete scalar.end;
      } else
        sep = [this.sourceToken];
      const map2 = {
        type: "block-map",
        offset: scalar.offset,
        indent: scalar.indent,
        items: [{ start, key: scalar, sep }]
      };
      this.onKeyLine = true;
      this.stack[this.stack.length - 1] = map2;
    } else
      yield* this.lineEnd(scalar);
  }
  *blockScalar(scalar) {
    switch (this.type) {
      case "space":
      case "comment":
      case "newline":
        scalar.props.push(this.sourceToken);
        return;
      case "scalar":
        scalar.source = this.source;
        this.atNewLine = true;
        this.indent = 0;
        if (this.onNewLine) {
          let nl = this.source.indexOf("\n") + 1;
          while (nl !== 0) {
            this.onNewLine(this.offset + nl);
            nl = this.source.indexOf("\n", nl) + 1;
          }
        }
        yield* this.pop();
        break;
      default:
        yield* this.pop();
        yield* this.step();
    }
  }
  *blockMap(map2) {
    var _a;
    const it = map2.items[map2.items.length - 1];
    switch (this.type) {
      case "newline":
        this.onKeyLine = false;
        if (it.value) {
          const end = "end" in it.value ? it.value.end : void 0;
          const last = Array.isArray(end) ? end[end.length - 1] : void 0;
          if ((last === null || last === void 0 ? void 0 : last.type) === "comment")
            end === null || end === void 0 ? void 0 : end.push(this.sourceToken);
          else
            map2.items.push({ start: [this.sourceToken] });
        } else if (it.sep)
          it.sep.push(this.sourceToken);
        else
          it.start.push(this.sourceToken);
        return;
      case "space":
      case "comment":
        if (it.value)
          map2.items.push({ start: [this.sourceToken] });
        else if (it.sep)
          it.sep.push(this.sourceToken);
        else {
          if (this.atIndentedComment(it.start, map2.indent)) {
            const prev = map2.items[map2.items.length - 2];
            const end = (_a = prev === null || prev === void 0 ? void 0 : prev.value) === null || _a === void 0 ? void 0 : _a.end;
            if (Array.isArray(end)) {
              Array.prototype.push.apply(end, it.start);
              end.push(this.sourceToken);
              map2.items.pop();
              return;
            }
          }
          it.start.push(this.sourceToken);
        }
        return;
    }
    if (this.indent >= map2.indent) {
      const atNextItem = !this.onKeyLine && this.indent === map2.indent && (it.sep || includesNonEmpty(it.start));
      switch (this.type) {
        case "anchor":
        case "tag":
          if (atNextItem || it.value) {
            map2.items.push({ start: [this.sourceToken] });
            this.onKeyLine = true;
          } else if (it.sep)
            it.sep.push(this.sourceToken);
          else
            it.start.push(this.sourceToken);
          return;
        case "explicit-key-ind":
          if (!it.sep && !includesToken(it.start, "explicit-key-ind"))
            it.start.push(this.sourceToken);
          else if (atNextItem || it.value)
            map2.items.push({ start: [this.sourceToken] });
          else
            this.stack.push({
              type: "block-map",
              offset: this.offset,
              indent: this.indent,
              items: [{ start: [this.sourceToken] }]
            });
          this.onKeyLine = true;
          return;
        case "map-value-ind":
          if (!it.sep)
            Object.assign(it, { key: null, sep: [this.sourceToken] });
          else if (it.value || atNextItem && !includesToken(it.start, "explicit-key-ind"))
            map2.items.push({ start: [], key: null, sep: [this.sourceToken] });
          else if (includesToken(it.sep, "map-value-ind"))
            this.stack.push({
              type: "block-map",
              offset: this.offset,
              indent: this.indent,
              items: [{ start: [], key: null, sep: [this.sourceToken] }]
            });
          else if (includesToken(it.start, "explicit-key-ind") && isFlowToken(it.key) && !includesToken(it.sep, "newline")) {
            const start = getFirstKeyStartProps(it.start);
            const key = it.key;
            const sep = it.sep;
            sep.push(this.sourceToken);
            delete it.key, delete it.sep;
            this.stack.push({
              type: "block-map",
              offset: this.offset,
              indent: this.indent,
              items: [{ start, key, sep }]
            });
          } else
            it.sep.push(this.sourceToken);
          this.onKeyLine = true;
          return;
        case "alias":
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar": {
          const fs = this.flowScalar(this.type);
          if (atNextItem || it.value) {
            map2.items.push({ start: [], key: fs, sep: [] });
            this.onKeyLine = true;
          } else if (it.sep) {
            this.stack.push(fs);
          } else {
            Object.assign(it, { key: fs, sep: [] });
            this.onKeyLine = true;
          }
          return;
        }
        default: {
          const bv = this.startBlockValue(map2);
          if (bv) {
            if (atNextItem && bv.type !== "block-seq" && includesToken(it.start, "explicit-key-ind"))
              map2.items.push({ start: [] });
            this.stack.push(bv);
            return;
          }
        }
      }
    }
    yield* this.pop();
    yield* this.step();
  }
  *blockSequence(seq2) {
    var _a;
    const it = seq2.items[seq2.items.length - 1];
    switch (this.type) {
      case "newline":
        if (it.value) {
          const end = "end" in it.value ? it.value.end : void 0;
          const last = Array.isArray(end) ? end[end.length - 1] : void 0;
          if ((last === null || last === void 0 ? void 0 : last.type) === "comment")
            end === null || end === void 0 ? void 0 : end.push(this.sourceToken);
          else
            seq2.items.push({ start: [this.sourceToken] });
        } else
          it.start.push(this.sourceToken);
        return;
      case "space":
      case "comment":
        if (it.value)
          seq2.items.push({ start: [this.sourceToken] });
        else {
          if (this.atIndentedComment(it.start, seq2.indent)) {
            const prev = seq2.items[seq2.items.length - 2];
            const end = (_a = prev === null || prev === void 0 ? void 0 : prev.value) === null || _a === void 0 ? void 0 : _a.end;
            if (Array.isArray(end)) {
              Array.prototype.push.apply(end, it.start);
              end.push(this.sourceToken);
              seq2.items.pop();
              return;
            }
          }
          it.start.push(this.sourceToken);
        }
        return;
      case "anchor":
      case "tag":
        if (it.value || this.indent <= seq2.indent)
          break;
        it.start.push(this.sourceToken);
        return;
      case "seq-item-ind":
        if (this.indent !== seq2.indent)
          break;
        if (it.value || includesToken(it.start, "seq-item-ind"))
          seq2.items.push({ start: [this.sourceToken] });
        else
          it.start.push(this.sourceToken);
        return;
    }
    if (this.indent > seq2.indent) {
      const bv = this.startBlockValue(seq2);
      if (bv) {
        this.stack.push(bv);
        return;
      }
    }
    yield* this.pop();
    yield* this.step();
  }
  *flowCollection(fc) {
    const it = fc.items[fc.items.length - 1];
    if (this.type === "flow-error-end") {
      let top;
      do {
        yield* this.pop();
        top = this.peek(1);
      } while (top && top.type === "flow-collection");
    } else if (fc.end.length === 0) {
      switch (this.type) {
        case "comma":
        case "explicit-key-ind":
          if (!it || it.sep)
            fc.items.push({ start: [this.sourceToken] });
          else
            it.start.push(this.sourceToken);
          return;
        case "map-value-ind":
          if (!it || it.value)
            fc.items.push({ start: [], key: null, sep: [this.sourceToken] });
          else if (it.sep)
            it.sep.push(this.sourceToken);
          else
            Object.assign(it, { key: null, sep: [this.sourceToken] });
          return;
        case "space":
        case "comment":
        case "newline":
        case "anchor":
        case "tag":
          if (!it || it.value)
            fc.items.push({ start: [this.sourceToken] });
          else if (it.sep)
            it.sep.push(this.sourceToken);
          else
            it.start.push(this.sourceToken);
          return;
        case "alias":
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar": {
          const fs = this.flowScalar(this.type);
          if (!it || it.value)
            fc.items.push({ start: [], key: fs, sep: [] });
          else if (it.sep)
            this.stack.push(fs);
          else
            Object.assign(it, { key: fs, sep: [] });
          return;
        }
        case "flow-map-end":
        case "flow-seq-end":
          fc.end.push(this.sourceToken);
          return;
      }
      const bv = this.startBlockValue(fc);
      if (bv)
        this.stack.push(bv);
      else {
        yield* this.pop();
        yield* this.step();
      }
    } else {
      const parent = this.peek(2);
      if (parent.type === "block-map" && (this.type === "map-value-ind" || this.type === "newline" && !parent.items[parent.items.length - 1].sep)) {
        yield* this.pop();
        yield* this.step();
      } else if (this.type === "map-value-ind" && parent.type !== "flow-collection") {
        const prev = getPrevProps(parent);
        const start = getFirstKeyStartProps(prev);
        fixFlowSeqItems(fc);
        const sep = fc.end.splice(1, fc.end.length);
        sep.push(this.sourceToken);
        const map2 = {
          type: "block-map",
          offset: fc.offset,
          indent: fc.indent,
          items: [{ start, key: fc, sep }]
        };
        this.onKeyLine = true;
        this.stack[this.stack.length - 1] = map2;
      } else {
        yield* this.lineEnd(fc);
      }
    }
  }
  flowScalar(type) {
    if (this.onNewLine) {
      let nl = this.source.indexOf("\n") + 1;
      while (nl !== 0) {
        this.onNewLine(this.offset + nl);
        nl = this.source.indexOf("\n", nl) + 1;
      }
    }
    return {
      type,
      offset: this.offset,
      indent: this.indent,
      source: this.source
    };
  }
  startBlockValue(parent) {
    switch (this.type) {
      case "alias":
      case "scalar":
      case "single-quoted-scalar":
      case "double-quoted-scalar":
        return this.flowScalar(this.type);
      case "block-scalar-header":
        return {
          type: "block-scalar",
          offset: this.offset,
          indent: this.indent,
          props: [this.sourceToken],
          source: ""
        };
      case "flow-map-start":
      case "flow-seq-start":
        return {
          type: "flow-collection",
          offset: this.offset,
          indent: this.indent,
          start: this.sourceToken,
          items: [],
          end: []
        };
      case "seq-item-ind":
        return {
          type: "block-seq",
          offset: this.offset,
          indent: this.indent,
          items: [{ start: [this.sourceToken] }]
        };
      case "explicit-key-ind": {
        this.onKeyLine = true;
        const prev = getPrevProps(parent);
        const start = getFirstKeyStartProps(prev);
        start.push(this.sourceToken);
        return {
          type: "block-map",
          offset: this.offset,
          indent: this.indent,
          items: [{ start }]
        };
      }
      case "map-value-ind": {
        this.onKeyLine = true;
        const prev = getPrevProps(parent);
        const start = getFirstKeyStartProps(prev);
        return {
          type: "block-map",
          offset: this.offset,
          indent: this.indent,
          items: [{ start, key: null, sep: [this.sourceToken] }]
        };
      }
    }
    return null;
  }
  atIndentedComment(start, indent) {
    if (this.type !== "comment")
      return false;
    if (this.indent <= indent)
      return false;
    return start.every((st) => st.type === "newline" || st.type === "space");
  }
  *documentEnd(docEnd) {
    if (this.type !== "doc-mode") {
      if (docEnd.end)
        docEnd.end.push(this.sourceToken);
      else
        docEnd.end = [this.sourceToken];
      if (this.type === "newline")
        yield* this.pop();
    }
  }
  *lineEnd(token) {
    switch (this.type) {
      case "comma":
      case "doc-start":
      case "doc-end":
      case "flow-seq-end":
      case "flow-map-end":
      case "map-value-ind":
        yield* this.pop();
        yield* this.step();
        break;
      case "newline":
        this.onKeyLine = false;
      case "space":
      case "comment":
      default:
        if (token.end)
          token.end.push(this.sourceToken);
        else
          token.end = [this.sourceToken];
        if (this.type === "newline")
          yield* this.pop();
    }
  }
};

// node_modules/yaml/browser/dist/public-api.js
function parseOptions(options) {
  const prettyErrors = options.prettyErrors !== false;
  const lineCounter = options.lineCounter || prettyErrors && new LineCounter() || null;
  return { lineCounter, prettyErrors };
}
function parseDocument(source, options = {}) {
  const { lineCounter, prettyErrors } = parseOptions(options);
  const parser = new Parser(lineCounter === null || lineCounter === void 0 ? void 0 : lineCounter.addNewLine);
  const composer = new Composer(options);
  let doc = null;
  for (const _doc of composer.compose(parser.parse(source), true, source.length)) {
    if (!doc)
      doc = _doc;
    else if (doc.options.logLevel !== "silent") {
      doc.errors.push(new YAMLParseError(_doc.range.slice(0, 2), "MULTIPLE_DOCS", "Source contains multiple documents; please use YAML.parseAllDocuments()"));
      break;
    }
  }
  if (prettyErrors && lineCounter) {
    doc.errors.forEach(prettifyError(source, lineCounter));
    doc.warnings.forEach(prettifyError(source, lineCounter));
  }
  return doc;
}

// tagrenamer/File.ts
var File = class {
  constructor(app2, filename, tagPositions, hasFrontMatter2) {
    this.app = app2;
    this.filename = filename;
    this.basename = filename.split("/").pop();
    this.tagPositions = tagPositions;
    this.hasFrontMatter = !!hasFrontMatter2;
  }
  /** @param {Replacement} replace */
  async renamed(replace) {
    const file = this.app.vault.getAbstractFileByPath(this.filename);
    const original = await this.app.vault.read(file);
    let text = original;
    if (this.hasFrontMatter) {
      text = this.replaceInFrontMatter(text, replace);
    }
    if (text !== original) {
      await this.app.vault.modify(file, text);
      return true;
    }
  }
  /** @param {Replacement} replace */
  replaceInFrontMatter(text, replace) {
    const [empty, frontMatter] = text.split(/^---\r?$\n?/m, 2);
    if (empty.trim() !== "" || !frontMatter.trim() || !frontMatter.endsWith("\n"))
      return text;
    const parsed = parseDocument(frontMatter, { keepSourceTokens: true });
    if (parsed.errors.length) {
      const error = `YAML issue with ${this.filename}: ${parsed.errors[0]}`;
      console.error(error);
      new import_obsidian.Notice(error + "; skipping frontmatter");
      return;
    }
    let changed = false, json = parsed.toJSON();
    function setInNode(node, value, afterKey = false) {
      cst_exports.setScalarValue(node.srcToken, value, { afterKey });
      changed = true;
      node.value = value;
    }
    function processField(prop, isAlias2) {
      const node = parsed.get(prop, true);
      if (!node)
        return;
      const field = json[prop];
      if (!field || !field.length)
        return;
      if (typeof field === "string") {
        const parts = field.split(isAlias2 ? /(^\s+|\s*,\s*|\s+$)/ : /([\s,]+)/);
        const after = replace.inArray(parts, true, isAlias2).join("");
        if (field != after)
          setInNode(node, after, true);
      } else if (Array.isArray(field)) {
        replace.inArray(field, false, isAlias2).forEach((v, i) => {
          if (field[i] !== v)
            setInNode(node.get(i, true), v);
        });
      }
    }
    for (const { key: { value: prop } } of parsed.contents.items) {
      if (/^tags?$/i.test(prop)) {
        processField(prop, false);
      } else if (/^alias(es)?$/i.test(prop)) {
        processField(prop, true);
      }
    }
    return changed ? text.replace(frontMatter, cst_exports.stringify(parsed.contents.srcToken)) : text;
  }
};

// tagrenamer/renaming.ts
function hasFrontMatter(file) {
  let { frontmatter } = app.metadataCache.getFileCache(file) || {};
  return frontmatter != null;
}
function hasTags(file) {
  let { frontmatter } = app.metadataCache.getFileCache(file) || {};
  const fmtags = (0, import_obsidian2.parseFrontMatterTags)(frontmatter) || [];
  const aliasTags = ((0, import_obsidian2.parseFrontMatterAliases)(frontmatter) || []).filter(Tag.isTag);
  return fmtags.length || aliasTags.length ? true : false;
}
async function renameTag(file, tagName, newName) {
  const oldTag = new Tag(tagName), newTag = new Tag(newName), replace = new Replacement(oldTag, newTag);
  const target = await findTargets(oldTag, file);
  if (!target) {
    return false;
  }
  await target.renamed(replace);
  return true;
}
async function findTargets(tag2, file) {
  let { frontmatter, tags } = app.metadataCache.getFileCache(file) || {};
  const fmtags = ((0, import_obsidian2.parseFrontMatterTags)(frontmatter) || []).filter(tag2.matches);
  const aliasTags = ((0, import_obsidian2.parseFrontMatterAliases)(frontmatter) || []).filter(Tag.isTag).filter(tag2.matches);
  if (fmtags.length || aliasTags.length) {
    return new File(app, file.path, tags, fmtags.length + aliasTags.length);
  }
  return null;
}
function renameBlogTitle(app2, path, view) {
  let moment4 = require_moment();
  const dateYYYYMMDD = moment4().format("YYYYMMDD");
  let renamedPath = "";
  if (path.match(/^.\/Blog \d\d\d\d\d\d\d\d/)) {
    return Promise.resolve();
  } else if (path.match(/^.\/blog \d\d\d\d\d\d\d\d/)) {
    new import_obsidian2.Notice("start with blog with date, renaming blog to Blog");
    renamedPath = path.replace(/^(.\/)blog /, `$1Blog `);
    return renameFile(app2, view.file, renamedPath);
  } else if (path.match(/^.\/Blog /)) {
    new import_obsidian2.Notice("starts with Blog but no date, adding date");
    renamedPath = path.replace(/^(.\/Blog )/, `$1${dateYYYYMMDD} `);
    return renameFile(app2, view.file, renamedPath);
  } else if (path.match(/^.\/blog /)) {
    new import_obsidian2.Notice("starts with blog but no date, adding date");
    renamedPath = path.replace(/^(.\/)blog /, `$1Blog ${dateYYYYMMDD} `);
    return renameFile(app2, view.file, renamedPath);
  } else {
    new import_obsidian2.Notice("starts without blog, adding Blog + date");
    renamedPath = path.replace(/^(.\/)/, `$1Blog ${dateYYYYMMDD} `);
    return renameFile(app2, view.file, renamedPath);
  }
}
function renameThreadsTitle(app2, path, view) {
  let moment4 = require_moment();
  const dateYYYYMMDD = moment4().format("YYYYMMDD");
  let renamedPath = "";
  if (path.match(/^.\/Threads \d\d\d\d\d\d\d\d/)) {
    return Promise.resolve();
  } else if (path.match(/^.\/threads \d\d\d\d\d\d\d\d/)) {
    new import_obsidian2.Notice("start with threads with date, renaming threads to Threads");
    renamedPath = path.replace(/^(.\/)threads /, `$1Threads `);
    return renameFile(app2, view.file, renamedPath);
  } else if (path.match(/^.\/Threads /)) {
    new import_obsidian2.Notice("starts with Threads but no date, adding date");
    renamedPath = path.replace(/^(.\/Threads )/, `$1${dateYYYYMMDD} `);
    return renameFile(app2, view.file, renamedPath);
  } else if (path.match(/^.\/threads /)) {
    new import_obsidian2.Notice("starts with threads but no date, adding date");
    renamedPath = path.replace(/^(.\/)threads /, `$1Threads ${dateYYYYMMDD} `);
    return renameFile(app2, view.file, renamedPath);
  } else {
    new import_obsidian2.Notice("starts without threads, adding Threads + date");
    renamedPath = path.replace(/^(.\/)/, `$1Threads ${dateYYYYMMDD} `);
    return renameFile(app2, view.file, renamedPath);
  }
}
async function renameFile(app2, file, newPath) {
  app2.fileManager.renameFile(file, newPath);
}

// selfutil/getTaskTag.ts
var import_obsidian3 = require("obsidian");
var ALL_TYPES = [
  {
    type: "a/n/n",
    description: "N Current Task",
    prefix: "\u{1F534}"
  },
  {
    type: "a/w/n",
    description: "W Current Task",
    prefix: "\u{1F534}"
  },
  {
    type: "a/n/l",
    description: "N Later Task",
    prefix: "\u{1F7E2}"
  },
  {
    type: "a/w/l",
    description: "W Later Task",
    prefix: "\u{1F7E2}"
  },
  {
    type: "a/n/p",
    description: "N Permanent Task",
    prefix: "\u{1F7E0}"
  },
  {
    type: "a/w/p",
    description: "W Permanent Task",
    prefix: "\u{1F7E0}"
  },
  {
    type: "a/a/p",
    description: "Area of Responsibility - Primary",
    prefix: "\u{1F7E5}"
  },
  {
    type: "a/a/s",
    description: "Area of Responsibility - Secondary",
    prefix: "\u{1F7E9}"
  },
  {
    type: "a/a/a",
    description: "Area of Responsibility - Abandoned",
    prefix: "\u{1F7EA}"
  },
  {
    type: "b/n/s",
    description: "Zettelkasten - Source notes snippets from content or Reference notes (like books / video / thoughts / conversation)",
    prefix: "\u{1F4E8}"
  },
  /*
  {
    type: "b/n/r",
    description: "Zettelkasten - Reference notes (like books / video / thoughts / conversation)",
    prefix: "",
  },
  */
  {
    type: "b/n/c",
    description: "Zettelkasten - Cards (With your own thought)",
    prefix: "\u{1F516}"
  },
  {
    type: "b/n/p",
    description: "Perspective - combine mulitple notes into a perspective e.g. solve a problem",
    prefix: "\u{1F50D}"
  },
  {
    type: "b/n/f",
    description: "Framework - Try to put the stuff into a a framework and find the missing puzzle",
    prefix: "\u{1F9E9}"
  },
  {
    type: "c/b/d",
    description: "Blog post draft",
    prefix: "\u{1F4C4}"
  },
  {
    type: "b/n/j",
    description: "Journal / events",
    prefix: "\u{1F4C5}"
  },
  {
    type: "b/n/m",
    description: "Zettelkasten - MOC Notes for a small topic",
    prefix: "\u{1F4C2}"
  },
  {
    type: "b/n/z",
    description: "Zettelkasten - Slip box (mainly on thought and the one I am interested)",
    prefix: "\u{1F5C3}\uFE0F"
  },
  {
    type: "b/n/i",
    description: "Index Notes for others framework",
    prefix: "\u{1F4C9}"
  },
  {
    type: "b/n/t",
    description: "Placeholder Notes for Target Audience (Notes starts with TA)",
    prefix: "\u{1F464}"
  },
  /*
  {
    type: "b/n/w",
    description: "Wiki Notes for a messy wiki topic",
    prefix: "",
  },
  */
  /*
  {
    type: "b/n/v",
    description: "Zettelkasten - Voice script (Deprecated?)",
    prefix: "",
  },
  */
  /*
  {
    type: "b/n/r",
    description: "Zettelkasten - Reference (Deprecated?)",
    prefix: "",
  },
  */
  /*
  {
    type: "b/n/u",
    description: "Zettelkasten - Unprocessed material like an inbox",
    prefix: "",
  },
  */
  {
    type: "b/t/a",
    description: "Atomic Essay Template",
    prefix: "\u270D\u{1F3FB}"
  },
  {
    type: "b/t/p",
    description: "ChatGPT Prompt Template",
    prefix: "\u{1FA84}"
  },
  {
    type: "c/a/d",
    description: "Atomic Essay drafting",
    prefix: "\u{1F195}"
  },
  {
    type: "c/a/r",
    description: "Atomic Essay ready to post",
    prefix: "\u{1F197}"
  },
  {
    type: "c/a/p",
    description: "Atomic Essay published",
    prefix: "\u{1F199}"
  },
  {
    type: "c/a/a",
    description: "Atomic Essay abandoned",
    prefix: "\u{1F5D1}\uFE0F"
  },
  {
    type: "c/b/r",
    description: "Blog post ready to publish",
    prefix: "\u{1F197}"
  },
  {
    type: "c/b/p",
    description: "Blog post published",
    prefix: "\u{1F199}"
  },
  {
    type: "c/b/a",
    description: "Blog post abandoned",
    prefix: "\u{1F5D1}\uFE0F"
  },
  {
    type: "c/t/d",
    description: "Threads post draft",
    prefix: "\u{1F195}"
  },
  {
    type: "c/t/r",
    description: "Threads post ready to post",
    prefix: "\u{1F197}"
  },
  {
    type: "c/t/t",
    description: "Threads post threads published",
    prefix: "\u{1F199}"
  },
  {
    type: "c/t/p",
    description: "Threads post published",
    prefix: "\u{1F199}"
  },
  {
    type: "c/t/o",
    description: "Threads post old (rewritten somewhere",
    prefix: "\u{1F474}\u{1F3FB}"
  },
  {
    type: "c/t/a",
    description: "Threads post abandoned",
    prefix: "\u{1F5D1}\uFE0F"
  },
  {
    type: "c/x/d",
    description: "Twitter post drafting",
    prefix: "\u{1F195}"
  },
  {
    type: "c/x/r",
    description: "Twitter post ready to publish",
    prefix: "\u{1F197}"
  },
  {
    type: "c/x/p",
    description: "Twitter post published",
    prefix: "\u{1F199}"
  },
  {
    type: "a/n/w",
    description: "N Waiting Task",
    prefix: "\u{1F535}"
  },
  {
    type: "a/n/d",
    description: "N Done Task",
    prefix: "\u26AA\uFE0F"
  },
  {
    type: "a/n/a",
    description: "N Archive Task",
    prefix: "\u{1F7E3}"
  },
  {
    type: "a/n/o",
    description: "N Others' Task",
    prefix: "\u{1F7E4}"
  },
  {
    type: "a/w/w",
    description: "W Waiting Task",
    prefix: "\u{1F535}"
  },
  {
    type: "a/w/d",
    description: "W Done Task",
    prefix: "\u26AA\uFE0F"
  },
  {
    type: "a/w/a",
    description: "W Archive Task",
    prefix: "\u{1F7E3}"
  },
  {
    type: "a/w/o",
    description: "W Others' Task",
    prefix: "\u{1F7E4}"
  },
  {
    type: "b/k/q",
    description: "Expermential Knowledge Group - Dummy Question",
    prefix: "0\uFE0F\u20E3"
  },
  {
    type: "b/k/d",
    description: "Expermential Knowledge Group - Data",
    prefix: "1\uFE0F\u20E3"
  },
  {
    type: "b/k/s",
    description: "Expermential Knowledge Group - Subjective",
    prefix: "2\uFE0F\u20E3"
  },
  {
    type: "b/k/p",
    description: "Expermential Knowledge Group - Complete system to solve a Problem",
    prefix: "3\uFE0F\u20E3"
  },
  {
    type: "b/k/c",
    description: "Expermential Knowledge Group - Collections of Subjective / Problem",
    prefix: "4\uFE0F\u20E3"
  }
];
function getNoteType(path) {
  const file = this.app.vault.getAbstractFileByPath(path);
  if (!file) {
    return null;
  }
  const { frontmatter } = app.metadataCache.getFileCache(file) || {};
  const fmtags = (0, import_obsidian3.parseFrontMatterTags)(frontmatter) || [];
  for (const tag2 of fmtags) {
    for (const noteType of ALL_TYPES) {
      if (tag2 == "#" + noteType.type) {
        return noteType;
      }
    }
  }
  return null;
}

// updateNoteTypeModal.ts
var UpdateNoteTypeModal = class extends import_obsidian4.FuzzySuggestModal {
  constructor(app2, editor, file) {
    super(app2);
    this.editor = editor;
    this.file = file;
    this.keydownHandler = (event) => {
      if (event.ctrlKey && event.altKey && event.shiftKey && event.key === "C") {
        this.close();
      } else if (event.ctrlKey && event.metaKey && event.shiftKey && event.key === "C") {
        this.close();
      } else if (event.metaKey || event.ctrlKey) {
        const key = parseInt(event.key, 10);
        if (key >= 1 && key <= 9) {
          event.preventDefault();
          this.selectElement(key - 1);
        }
      }
    };
    document.addEventListener("keydown", this.keydownHandler);
  }
  selectElement(index) {
    const elements = this.resultContainerEl.querySelectorAll(".suggestion-item");
    if (elements.length > index) {
      const element = elements[index];
      element.click();
    }
  }
  onClose() {
    super.onClose();
    document.removeEventListener("keydown", this.keydownHandler);
  }
  getItems() {
    return ALL_TYPES;
  }
  getItemText(noteType) {
    return noteType.type;
  }
  // Renders each suggestion item.
  renderSuggestion(choosenNoteTypeMatch, el) {
    const noteType = choosenNoteTypeMatch.item;
    const index = this.resultContainerEl.querySelectorAll(".suggestion-item").length;
    const itemIndex = index < 10 ? index + ". " : "    ";
    el.createEl("div", { text: itemIndex + noteType.prefix + " " + noteType.type });
    el.createEl("small", { text: "     " + noteType.description });
  }
  containsType(line) {
    return ALL_TYPES.filter((noteType) => line.contains(noteType.type)).length > 0;
  }
  addFrontMatterWithTag(value) {
    const cursor = this.editor.getCursor();
    const oldLine = cursor.line;
    const oldCh = cursor.ch;
    const addText = `---
tags: ${value}
---

${this.editor.getValue()}`;
    this.editor.setValue(addText);
    cursor.line = oldLine + 4;
    cursor.ch = oldCh;
    this.editor.setCursor(cursor);
  }
  addTagAssumingHasFrontMatter(value) {
    const cursor = this.editor.getCursor();
    const oldLine = cursor.line;
    const oldCh = cursor.ch;
    let firstLineIndex = 0;
    const lineCount = this.editor.lineCount();
    for (let i = 0; i < lineCount; i++) {
      if (this.editor.getLine(i).trim() == "---".trim()) {
        firstLineIndex = i;
        break;
      }
    }
    if (firstLineIndex == lineCount) {
      new import_obsidian4.Notice("Something wrong here");
      return;
    }
    let text = "";
    for (let i = 0; i <= firstLineIndex; i++) {
      text = text + this.editor.getLine(i) + "\n";
    }
    text = text + `tags: ${value}
`;
    for (let i = firstLineIndex + 1; i <= this.editor.lineCount(); i++) {
      text = text + this.editor.getLine(i) + "\n";
    }
    this.editor.setValue(text);
    cursor.line = oldLine + (oldLine <= firstLineIndex ? 0 : 1);
    cursor.ch = oldCh;
    this.editor.setCursor(cursor);
  }
  // Perform action on the selected suggestion.
  onChooseItem(choosenNoteType, evt) {
    if (!hasFrontMatter(this.file)) {
      this.addFrontMatterWithTag(choosenNoteType.type);
    } else {
      if (hasTags(this.file)) {
        ALL_TYPES.forEach((t) => {
          renameTag(this.file, t.type, choosenNoteType.type);
        });
      } else {
        this.addTagAssumingHasFrontMatter(choosenNoteType.type);
      }
    }
  }
};

// main.ts
var import_obsidian29 = require("obsidian");

// addCommentTagModal.ts
var import_obsidian5 = require("obsidian");
var ALL_TYPES2 = [
  {
    type: "d/\u23EB",
    description: "Idea/Task/Action Compass - Up - Where does this idea come from / Reason of this idea? OR What is the goal/prereq of this task/action?"
  },
  {
    type: "d/\u23EC",
    description: "Idea/Task/Action Compass - Down - Where does the idea lead to / It can solve what problem? OR What is the result/next task/action of this task/action?"
  },
  {
    type: "d/\u23EA",
    description: "Idea/Task/Action Compass - Left - What are similar / supporting idea? OR Same Goal Different Task/Action?"
  },
  {
    type: "d/\u23E9\uFE0F",
    description: "Idea/Task/Action Compass - Right - What are oppose idea? OR Same Task/Action Different Goal?"
  },
  {
    type: "d/\u2B05\uFE0F",
    description: "Previous version of this idea"
  },
  {
    type: "d/\u27A1\uFE0F",
    description: "Next version of this idea"
  },
  {
    type: "d/\u{1F504}",
    description: "Context"
  },
  {
    type: "d/\u23F9\uFE0F",
    description: "A1 - my experience"
  }
  /*
  {
    type: "d/question",
    description: "Question"
  },
  {
    type: "d/answer",
    description: "Answer"
  },
  {
    type: "d/solves",
    description: "Solves some problem"
  },
  {
    type: "d/ref",
    description: "Reference"
  },
  {
    type: "d/selfthink",
    description: "Self think"
  },
  {
    type: "d/notsure",
    description: "Not sure"
  },
  {
    type: "d/a2",
    description: "A2 - future action"
  },
  */
  /*
  {
    type: "d/toMerge",
    description: "TODO - To Merge with another note"
  },
  {
    type: "d/toMove",
    description: "TODO - To Merge with another note"
  },
  {
    type: "d/toSplit",
    description: "ToDO - To Split to multiple note"
  },
  {
    type: "d/toCard",
    description: "TODO - To Write card"
  },
  */
];
var AddFootnoteTagModal = class extends import_obsidian5.FuzzySuggestModal {
  constructor(app2, editor) {
    super(app2);
    this.editor = editor;
    this.keydownHandler = (event) => {
      if (event.ctrlKey && event.altKey && event.shiftKey && event.key === "Z") {
        this.close();
      } else if (event.ctrlKey && event.metaKey && event.shiftKey && event.key === "Z") {
        this.close();
      } else if (event.metaKey || event.ctrlKey) {
        const key = parseInt(event.key, 10);
        if (key >= 1 && key <= 9) {
          event.preventDefault();
          this.selectElement(key - 1);
        }
      }
    };
    document.addEventListener("keydown", this.keydownHandler);
  }
  selectElement(index) {
    const elements = this.resultContainerEl.querySelectorAll(".suggestion-item");
    if (elements.length > index) {
      const element = elements[index];
      element.click();
    }
  }
  onClose() {
    super.onClose();
    document.removeEventListener("keydown", this.keydownHandler);
  }
  getItems() {
    return ALL_TYPES2;
  }
  getItemText(noteType) {
    return noteType.type;
  }
  static removeTag(line) {
    ALL_TYPES2.forEach((noteType) => line = line.replace(`#${noteType.type} `, ""));
    return line;
  }
  // Renders each suggestion item.
  renderSuggestion(choosenNoteTypeMatch, el) {
    const noteType = choosenNoteTypeMatch.item;
    const index = this.resultContainerEl.querySelectorAll(".suggestion-item").length;
    const itemIndex = index < 10 ? index + ". " : "    ";
    el.createEl("div", { text: itemIndex + noteType.type });
    el.createEl("small", { text: "     " + noteType.description });
  }
  containsType(line) {
    return ALL_TYPES2.filter((noteType) => line.contains(noteType.type)).length > 0;
  }
  // Perform action on the selected suggestion.
  onChooseItem(choosenNoteType, evt) {
    const selection = this.editor.getSelection();
    const replacedStr = `#${choosenNoteType.type} `;
    if (selection.length != 0) {
      this.editor.replaceSelection(replacedStr);
    } else {
      const cursor = this.editor.getCursor();
      this.editor.replaceRange(replacedStr, cursor);
      cursor.ch = cursor.ch + replacedStr.length;
      this.editor.setCursor(cursor);
    }
  }
};

// addTaskTagModal.ts
var import_obsidian6 = require("obsidian");
var ALL_TYPES3 = [
  /*
  {
    type: "n",
    cursor: "c",
    description: "N Cursor"
  },
  */
  {
    type: "n",
    cursor: "b",
    description: "N Beginning of line"
  },
  /*
  {
    type: "n",
    cursor: "e",
    description: "N End of line"
  },
  {
    type: "w",
    cursor: "c",
    description: "W Cursor"
  },
  */
  {
    type: "w",
    cursor: "b",
    description: "W Beginning of line"
  }
  /*
  {
    type: "w",
    cursor: "e",
    description: "W End of line"
  }
  */
];
var AddTaskTagModal = class extends import_obsidian6.FuzzySuggestModal {
  constructor(app2, editor, taskType) {
    super(app2);
    this.editor = editor;
    this.taskType = taskType;
  }
  getItems() {
    return ALL_TYPES3;
  }
  getItemText(noteType) {
    return noteType.type + noteType.cursor;
  }
  // Renders each suggestion item.
  renderSuggestion(choosenNoteTypeMatch, el) {
    const noteType = choosenNoteTypeMatch.item;
    el.createEl("div", { text: noteType.type + " " + noteType.cursor });
    el.createEl("small", { text: noteType.description });
  }
  containsType(line) {
    return ALL_TYPES3.filter((noteType) => line.contains(noteType.type)).length > 0;
  }
  // Perform action on the selected suggestion.
  onChooseItem(choosenNoteType, evt) {
    const cursor = this.editor.getCursor();
    const line = this.editor.getLine(cursor.line);
    if (choosenNoteType.cursor == "c") {
      this.editor.replaceRange(`${line.charAt(cursor.ch - 1) != " " ? " " : ""}#${choosenNoteType.type}${this.taskType} `, cursor);
      cursor.ch = cursor.ch + 4 + (line.charAt(cursor.ch - 1) != " " ? 1 : 0);
      this.editor.setCursor(cursor);
    } else if (choosenNoteType.cursor == "b") {
      let modifiedLine = line;
      if (/^\t*- /.test(line)) {
        modifiedLine = line.replace(/^(\t*- )/, `$1#${choosenNoteType.type}${this.taskType} `);
      } else if (/^\t*\d+\. /.test(line)) {
        modifiedLine = line.replace(/^(\t*\d+\. )/, `$1${choosenNoteType.type}${this.taskType} `);
      } else {
        modifiedLine = line.replace(/^/, `#${choosenNoteType.type}${this.taskType} `);
      }
      this.editor.setLine(cursor.line, modifiedLine);
      cursor.ch = cursor.ch + 4;
      this.editor.setCursor(cursor);
    } else if (choosenNoteType.cursor == "e") {
      let modifiedLine = line.replace(/$/, ` #${choosenNoteType.type}${this.taskType}`);
      this.editor.setLine(cursor.line, modifiedLine);
      cursor.ch = cursor.ch;
      this.editor.setCursor(cursor);
    }
  }
};

// ThreadsToImagesModal.ts
var import_obsidian7 = require("obsidian");
var ALL_TYPES4 = [
  {
    type: "first-page",
    description: "first page"
  },
  {
    type: "with-header",
    description: "with header"
  },
  {
    type: "without-header",
    description: "without header"
  },
  {
    type: "custom-font-size",
    description: "custom font size"
  }
];
var ThreadsToImagesModal = class extends import_obsidian7.FuzzySuggestModal {
  constructor(app2, threadSegment) {
    super(app2);
    this.threadSegment = threadSegment;
  }
  getItems() {
    return ALL_TYPES4;
  }
  getItemText(noteType) {
    return noteType.type;
  }
  // Renders each suggestion item.
  renderSuggestion(choosenNoteTypeMatch, el) {
    const noteType = choosenNoteTypeMatch.item;
    el.createEl("div", { text: noteType.type });
    el.createEl("small", { text: noteType.description });
  }
  containsType(line) {
    return ALL_TYPES4.filter((noteType) => line.contains(noteType.type)).length > 0;
  }
  // Perform action on the selected suggestion.
  onChooseItem(choosenNoteType, evt) {
    let param = choosenNoteType.type;
    let s = this.threadSegment.toString();
    navigator.clipboard.writeText(this.threadSegment.toString()).then(function() {
      new import_obsidian7.Notice(`Copied
\`\`\`
${s}\`\`\`
to clipboard!`);
      window.open(`shortcuts://run-shortcut?name=Threads%20to%20image&input=text&text=${param}&x-success=obsidian://&x-cancel=obsidian://&x-error=obsidian://`);
    }, function(error) {
      new import_obsidian7.Notice(`error when copy to clipboard!`);
    });
  }
};

// copyOrMoveToNewNoteModal.ts
var import_obsidian8 = require("obsidian");
var ALL_TYPES5 = [
  {
    type: "copy",
    description: "Copy"
  },
  {
    type: "move",
    description: "Move"
  }
];
var CopyOrMoveToNewNoteModal = class extends import_obsidian8.FuzzySuggestModal {
  constructor(app2, editor) {
    super(app2);
    this.editor = editor;
    this.setPlaceholder(`Copy or move selection to new note?`);
  }
  getItems() {
    return ALL_TYPES5;
  }
  getItemText(noteType) {
    return noteType.type;
  }
  // Renders each suggestion item.
  renderSuggestion(choosenNoteTypeMatch, el) {
    const noteType = choosenNoteTypeMatch.item;
    el.createEl("div", { text: noteType.type });
    el.createEl("small", { text: noteType.description });
  }
  containsType(line) {
    return ALL_TYPES5.filter((noteType) => line.contains(noteType.type)).length > 0;
  }
  // Perform action on the selected suggestion.
  async onChooseItem(choosenOperation, evt) {
    const selection = this.editor.getSelection();
    const line = this.editor.getCursor().line;
    const textToCopyOrMove = selection.length == 0 ? this.editor.getLine(line) : selection;
    const newFileName = "I/United Push.md";
    await this.createOrAppendFile(newFileName, textToCopyOrMove);
    if (choosenOperation.type == "move") {
      if (selection.length != 0) {
        this.editor.replaceSelection("");
      } else {
        let content = "";
        for (let i = 0; i < this.editor.lineCount(); i++) {
          if (i != line) {
            content += this.editor.getLine(i) + "\n";
          }
        }
        this.editor.setValue(content);
      }
    }
    const { vault } = this.app;
    const { workspace } = this.app;
    const mode = this.app.vault.getConfig("defaultViewMode");
    const leaf = workspace.getLeaf(false);
    await leaf.openFile(vault.getAbstractFileByPath(newFileName), { active: true });
  }
  async createOrAppendFile(filePath, note2) {
    const { vault } = this.app;
    const fileExists = await vault.adapter.exists(filePath);
    if (fileExists) {
      await this.appendFile(vault, filePath, note2);
    } else {
      await vault.create(filePath, "---\ntag: b/n/s\n---\n\n" + note2);
    }
    return filePath;
  }
  async appendFile(vault, filePath, note2) {
    let existingContent = await vault.adapter.read(filePath);
    if (existingContent.length > 0) {
      existingContent = existingContent + "\r\r";
    }
    await vault.adapter.write(filePath, existingContent + note2);
  }
};

// clipboardPasteModal.ts
var import_obsidian9 = require("obsidian");
var ClipboardPasteModal = class extends import_obsidian9.FuzzySuggestModal {
  constructor(app2, editor, clipboardContent) {
    super(app2);
    this.editor = editor;
    this.clipboardContent = clipboardContent;
    this.setPlaceholder(`Which clipboard content do you want to paste?`);
    this.keydownHandler = (event) => {
      if (event.metaKey && event.shiftKey && event.key === "V") {
        this.close();
      } else if (event.metaKey || event.ctrlKey) {
        const key = parseInt(event.key, 10);
        if (key >= 1 && key <= 9) {
          event.preventDefault();
          this.selectElement(key - 1);
        }
      }
    };
    document.addEventListener("keydown", this.keydownHandler);
  }
  onClose() {
    super.onClose();
    document.removeEventListener("keydown", this.keydownHandler);
  }
  selectElement(index) {
    const elements = this.resultContainerEl.querySelectorAll(".suggestion-item");
    if (elements.length > index) {
      const element = elements[index];
      element.click();
    }
  }
  getItems() {
    return this.clipboardContent.slice().reverse();
  }
  getItemText(item) {
    return item;
  }
  // Renders each suggestion item.
  renderSuggestion(i, el) {
    const item = i.item;
    const index = this.resultContainerEl.querySelectorAll(".suggestion-item").length;
    const itemIndex = index < 10 ? index + ". " : "    ";
    el.createEl("div", { text: itemIndex + item.replace(/\n/gm, "").substring(0, 100) });
  }
  // Perform action on the selected suggestion.
  onChooseItem(selectedContent, evt) {
    const index = this.clipboardContent.indexOf(selectedContent, 0);
    if (index > -1) {
      this.clipboardContent.remove(selectedContent);
    }
    this.clipboardContent.push(selectedContent);
    const selection = this.editor.getSelection();
    const replacedStr = selectedContent;
    if (selection.length != 0) {
      this.editor.replaceSelection(replacedStr);
    } else {
      const cursor = this.editor.getCursor();
      this.editor.replaceRange(replacedStr, cursor);
      cursor.ch = cursor.ch + replacedStr.length;
      this.editor.setCursor(cursor);
    }
  }
};

// openPlaygroundModal.ts
var import_obsidian10 = require("obsidian");
var OpenPlaygroundModal = class extends import_obsidian10.FuzzySuggestModal {
  constructor(app2) {
    super(app2);
    this.removeExistingContent = "Remove playground content";
    this.notRemoveExistingContent = "Not remove existing playground content";
    this.playgroundMd = "I/Playground.md";
    this.options = [this.removeExistingContent, this.notRemoveExistingContent];
  }
  getItems() {
    return this.options.reverse();
  }
  getItemText(item) {
    return item;
  }
  // Renders each suggestion item.
  renderSuggestion(i, el) {
    const item = i.item;
    el.createEl("div", { text: item });
  }
  // Perform action on the selected suggestion.
  async onChooseItem(selectedContent, evt) {
    const choosenOption = selectedContent;
    const { vault } = this.app;
    const { workspace } = this.app;
    const leaf = workspace.getLeaf(false);
    Promise.resolve().then(() => {
      if (vault.getAbstractFileByPath(this.playgroundMd) == null) {
        return vault.create(this.playgroundMd, "");
      }
      return vault.getAbstractFileByPath(this.playgroundMd);
    }).then((tFile) => {
      if (this.removeExistingContent === choosenOption) {
        return vault.modify(tFile, "");
      }
      return Promise.resolve();
    }).then(() => {
      return leaf.openFile(vault.getAbstractFileByPath(this.playgroundMd), { active: true });
    });
  }
};

// threadsToBlogModal.ts
var import_obsidian11 = require("obsidian");
var ThreadsToBlogModal = class extends import_obsidian11.FuzzySuggestModal {
  constructor(app2, editor, view) {
    super(app2);
    this.toNewNote = "To New Note";
    this.toClipboard = "To Clipboard";
    this.options = [this.toNewNote, this.toClipboard];
    this.editor = editor;
    this.view = view;
    this.setPlaceholder(`Putting Threads content to Blog notes. Which option do you want to proceed?`);
  }
  getItems() {
    return this.options;
  }
  getItemText(item) {
    return item;
  }
  // Renders each suggestion item.
  renderSuggestion(i, el) {
    const item = i.item;
    el.createEl("div", { text: item });
  }
  // Perform action on the selected suggestion.
  onChooseItem(selectedContent, evt) {
    const choosenOption = selectedContent;
    const lineCount = this.editor.lineCount();
    let tagLineNumber = null;
    let metadataLineCount = 0;
    let text = "";
    for (let i = 0; i < lineCount; i++) {
      let line = this.editor.getLine(i);
      if (!line.trim().startsWith("%%") || !line.trim().endsWith("%%")) {
        let modifiedLine = line.replace("\u{1F9F5} ", "# ").replace("\u3010", "").replace("\u3011", "").replace("\u{1F447}", "");
        if (modifiedLine == "---") {
          metadataLineCount++;
          if (metadataLineCount > 2) {
            if (metadataLineCount == 3) {
              modifiedLine = modifiedLine.replace("---", "");
            } else if (metadataLineCount == 4) {
              modifiedLine = modifiedLine.replace("---", "<!--more-->\n\n**\u76EE\u9304\uFF1A**\n\n* Table of Content\n{:toc}\n\n## .");
            } else {
              modifiedLine = modifiedLine.replace("---", "## .");
            }
          }
        }
        if (metadataLineCount == 1 || metadataLineCount == 2) {
          modifiedLine = modifiedLine.replace("c/t/p", "c/b/d");
          modifiedLine = modifiedLine.replace("c/t/t", "c/b/d");
          modifiedLine = modifiedLine.replace("c/t/r", "c/b/d");
        }
        if (/^!\[.*\]\(.*\)/.test(modifiedLine.trim())) {
          if (!modifiedLine.contains("https://roulesophy.github.io")) {
            modifiedLine = modifiedLine.replace(/!\[([^\[\]\(\)]+)\]\(([^\[\]\(\)]+)\)/g, "$2");
          }
        }
        text = text + modifiedLine + "\n";
      }
    }
    text = text.replace(/## .\n+## [Rr]eferences?[\:]?([\n]*.*)*$/, "");
    text += `

---

#nl generate summary for meta description below:



`;
    text += `---

## References:

- Thread post 1: [[${this.view.file.basename}]]
- Blog link: 
`;
    const { vault } = this.app;
    if (this.toNewNote === choosenOption) {
      const { vault: vault2 } = this.app;
      const path = this.view.file.path;
      const newPath = path.match(/.\/Threads \d\d\d\d\d\d\d\d/) ? path.replace(/(.\/)Threads \d\d\d\d\d\d\d\d/, "$1Blog ") : path.replace(/(.\/)/, "$1Blog ");
      const { workspace } = this.app;
      const leaf = workspace.getLeaf(false);
      Promise.resolve().then(() => {
        return vault2.adapter.exists(newPath);
      }).then((fileExists) => {
        if (fileExists) {
          new import_obsidian11.Notice(`Will not proceed. Blog post "${newPath}" already exist.`);
          return Promise.reject("Blog post exist");
        }
        return vault2.create(newPath, text);
      }).then(
        (tFile) => {
          return leaf.openFile(tFile, { active: true });
        },
        (rejectReason) => {
        }
      );
    }
    if (this.toClipboard === choosenOption) {
      navigator.clipboard.writeText(text).then(function() {
        new import_obsidian11.Notice(`Copied blog content to clipboard!`);
      }, function(error) {
        new import_obsidian11.Notice(`error when copy to clipboard!`);
      });
    }
  }
};

// clipboardRemovalModal.ts
var import_obsidian12 = require("obsidian");
var ClipboardRemovalModal = class extends import_obsidian12.FuzzySuggestModal {
  constructor(app2, editor, clipboardContent) {
    super(app2);
    this.REMOVE_ALL = "REMOVE ALL";
    this.editor = editor;
    this.clipboardContent = clipboardContent;
    this.setPlaceholder(`Which clipboard content do you want to remove?`);
  }
  getItems() {
    return [...[this.REMOVE_ALL], ...this.clipboardContent.slice().reverse()];
  }
  getItemText(item) {
    return item;
  }
  // Renders each suggestion item.
  renderSuggestion(i, el) {
    const item = i.item;
    el.createEl("div", { text: "\u2022 " + item.replace(/\n/gm, "").substring(0, 100) });
  }
  // Perform action on the selected suggestion.
  onChooseItem(selectedContent, evt) {
    if (selectedContent === this.REMOVE_ALL) {
      new import_obsidian12.Notice("haha");
      while (this.clipboardContent.length > 0) {
        this.clipboardContent.pop();
      }
    } else {
      const index = this.clipboardContent.indexOf(selectedContent, 0);
      if (index > -1) {
        this.clipboardContent.splice(index, 1);
      }
    }
  }
};

// tagSearchModal.ts
var import_obsidian14 = require("obsidian");

// selfutil/getAllNoteTags.ts
var import_obsidian13 = require("obsidian");
function getAllNoteTags(app2) {
  return getAllTagsWithFilter(app2, (tag2) => /^#[a-z]\/[a-z]\/[a-z]$/.test(tag2));
}
function getAllTagsWithFilter(app2, filter) {
  var _a;
  const files = app2.vault.getMarkdownFiles();
  const items = [];
  for (const file of files) {
    const cache = app2.metadataCache.getCache(file.path);
    if (cache === null) {
      continue;
    }
    (_a = (0, import_obsidian13.getAllTags)(cache)) == null ? void 0 : _a.forEach((tag2) => {
      if (filter == null || filter(tag2)) {
        const layerOfTag = getLayersOfTag(tag2);
        for (const layer of layerOfTag) {
          if (!items.includes(layer)) {
            items.push(layer);
          }
        }
      }
    });
  }
  return items.sort((a, b) => a.localeCompare(b));
}
function getLayersOfTag(tag2) {
  const layers = [];
  const tagSplit = tag2.split("/");
  let tagLayer = tagSplit[0];
  layers.push(tagLayer);
  for (const tagPart of tagSplit.slice(1, tagSplit.length)) {
    tagLayer += "/" + tagPart;
    layers.push(tagLayer);
  }
  return layers;
}

// tagSearchModal.ts
var TagSearchModal = class extends import_obsidian14.FuzzySuggestModal {
  constructor(app2, search, plugin) {
    super(app2);
    this.app = app2;
    this.search = search;
    this.search = search;
    this.keydownHandler = (event) => {
      if (event.ctrlKey && event.altKey && event.shiftKey && event.key === "S") {
        this.close();
      } else if (event.ctrlKey && event.metaKey && event.shiftKey && event.key === "S") {
        this.close();
      } else if (event.metaKey || event.ctrlKey) {
        const key = parseInt(event.key, 10);
        if (key >= 1 && key <= 9) {
          event.preventDefault();
          this.selectElement(key - 1);
        }
      }
    };
    document.addEventListener("keydown", this.keydownHandler);
    this.plugin = plugin;
  }
  selectElement(index) {
    const elements = this.resultContainerEl.querySelectorAll(".suggestion-item");
    if (elements.length > index) {
      const element = elements[index];
      element.click();
    }
  }
  getItems() {
    return getAllTagsWithFilter(this.app);
  }
  getItemText(item) {
    return item;
  }
  async onChooseItem(item, evt) {
    this.plugin.notesTypeView.notesTypeTag = item;
    this.plugin.activateNoteListView();
    this.plugin.notesTypeView.redraw();
  }
  onClose() {
    super.onClose();
    document.removeEventListener("keydown", this.keydownHandler);
  }
  renderSuggestion(tag2, el) {
    const noteType = tag2.item;
    const index = this.resultContainerEl.querySelectorAll(".suggestion-item").length;
    const itemIndex = index < 10 ? index + ". " : "    ";
    el.createEl("div", { text: itemIndex + noteType });
  }
};

// main.ts
var import_obsidian30 = require("obsidian");
var import_moment3 = __toESM(require_moment());

// addTextToNotesFromSpecificTagModal.ts
var import_obsidian17 = require("obsidian");

// selfutil/addlinktonotes.ts
var import_obsidian15 = require("obsidian");
function addTextToNotes(textToAdd, toPath, app2, insertFromBeginning, headingLine) {
  const vault = this.app.vault;
  const workspace = this.app.workspace;
  const leaf = workspace.getLeaf(false);
  const tFile = vault.getAbstractFileByPath(toPath);
  const link = textToAdd;
  Promise.resolve().then(() => {
    return leaf.openFile(tFile, { active: true });
  }).then(() => {
    const markdownView = app2.workspace.getActiveViewOfType(import_obsidian15.MarkdownView);
    const editor = markdownView == null ? void 0 : markdownView.editor;
    const value = markdownView == null ? void 0 : markdownView.getViewData();
    if (markdownView == null || editor == null || value == null) {
      const errorReason = `editor or value ${toPath} not exist. Aborting...`;
      return Promise.reject(errorReason);
    }
    const trimmedLink = link.trim().replace(/^- /, "");
    if (editor.getValue().includes(trimmedLink)) {
      const errorReason = `Link ${trimmedLink} already exists in ${toPath}!`;
      new import_obsidian15.Notice(errorReason);
      for (let i = 0; i < editor.lineCount(); i++) {
        if (editor.getLine(i).includes(trimmedLink)) {
          editor.setCursor({ line: i, ch: 0 });
          editor.scrollIntoView({ from: { line: i, ch: 0 }, to: { line: i, ch: 0 } }, true);
          break;
        }
      }
    } else {
      if (headingLine < 0) {
        const newValue = insertFromBeginning ? getNoteValueInsertingTextFromStartOfNotes(value, link) : getNoteValueInsertingTextFromEndOfNotes(value, link);
        markdownView.setViewData(newValue, false);
        editor.setValue(newValue);
        if (insertFromBeginning) {
          const frontMatterRegex = /^(---\n[\s\S]*?\n---\n)/gm;
          if (frontMatterRegex.test(value)) {
            const lineAfterFrontMatter = getLineAfterFrontMatter(value);
            editor.setCursor({ line: lineAfterFrontMatter, ch: 0 });
            editor.scrollIntoView({ from: { line: lineAfterFrontMatter, ch: 0 }, to: { line: lineAfterFrontMatter, ch: 0 } }, true);
          } else {
            editor.setCursor({ line: 0, ch: 0 });
            editor.scrollIntoView({ from: { line: 0, ch: 0 }, to: { line: 0, ch: 0 } }, true);
          }
        } else {
          const lastLineNum = editor.lineCount() - 1;
          editor.setCursor({ line: lastLineNum, ch: 0 });
          editor.scrollIntoView({ from: { line: lastLineNum, ch: 0 }, to: { line: lastLineNum, ch: 0 } }, true);
        }
        new import_obsidian15.Notice(`Added link to ${insertFromBeginning ? "beginning" : "end"} of ${toPath}!`);
      } else {
        const newValue = insertFromBeginning ? getNoteValueInsertingTextFromStartOfNotesHeading(value, link, headingLine) : getNoteValueInsertingTextFromEndOfNotesHeading(value, link, headingLine);
        markdownView.setViewData(newValue.value, false);
        editor.setValue(newValue.value);
        editor.setCursor({ line: newValue.line, ch: 0 });
        editor.scrollIntoView({ from: { line: newValue.line, ch: 0 }, to: { line: newValue.line, ch: 0 } }, true);
        new import_obsidian15.Notice(`Added link to ${insertFromBeginning ? "beginning" : "end"} of Section of ${toPath}!`);
      }
    }
    return Promise.resolve();
  }).catch((reason) => {
    new import_obsidian15.Notice(reason);
  });
}
function getLineAfterFrontMatter(value) {
  const values = value.split("\n");
  let fmCount = 0;
  const lineNum = values.length;
  for (let i = 0; i < lineNum; i++) {
    if (values[i] === "---") {
      fmCount++;
    }
    if (fmCount == 2) {
      return Math.min(i + 1, lineNum - 1);
    }
  }
  return lineNum - 1;
}
function getNoteValueInsertingTextFromStartOfNotes(value, text) {
  const frontMatterRegex = /^(---\n[\s\S]*?\n---\n)/gm;
  if (frontMatterRegex.test(value)) {
    return value.replace(frontMatterRegex, "$1" + text + "\n");
  } else {
    return text + "\n" + value;
  }
}
function getNoteValueInsertingTextFromEndOfNotes(value, text) {
  return value + "\n" + text;
}
function getNoteValueInsertingTextFromStartOfNotesHeading(value, text, headingLine) {
  const values = value.split("\n");
  let result = "";
  let addedLine = -1;
  let isAddedLine = false;
  for (let i = 0; i < values.length; i++) {
    if (i <= headingLine) {
      result += values[i] + "\n";
    } else if (values[i].trim() === "") {
      result += values[i] + "\n";
    } else if (!isAddedLine) {
      result += text + "\n" + values[i] + "\n";
      addedLine = i;
      isAddedLine = true;
    } else {
      result += values[i] + "\n";
    }
  }
  return { value: result.replace(/\n$/, ""), line: isAddedLine ? addedLine : headingLine };
}
function getNoteValueInsertingTextFromEndOfNotesHeading(value, text, headingLine) {
  const values = value.split("\n");
  let addedLine = headingLine;
  let endLineOfSection = values.length - 1;
  for (let i = headingLine; i < values.length; i++) {
    if (i === headingLine) {
    } else {
      if (/^[#]{1,6} /.test(values[i])) {
        endLineOfSection = i - 1;
        break;
      }
    }
  }
  let finish = false;
  for (let i = endLineOfSection; i > headingLine && !finish; i--) {
    if (values[i].trim() !== "") {
      addedLine = i;
      finish = true;
    }
  }
  let result = "";
  for (let i = 0; i < values.length; i++) {
    if (i != addedLine) {
      result += values[i] + "\n";
    } else {
      result += values[i] + "\n" + text + "\n";
    }
  }
  return { value: result.replace(/\n$/, ""), line: addedLine + 1 };
}

// selfutil/findNotesFromTag.ts
var import_obsidian16 = require("obsidian");
function filesWhereTagIsUsed(findTag) {
  const filesList = [];
  for (const filePath of locationsWhereTagIsUsed(findTag)) {
    if (!filesList.includes(filePath)) {
      filesList.push(filePath);
    }
  }
  return filesList.sort((a, b) => a.localeCompare(b));
}
function filesHeadersWhereTagIsUsed(app2, findTag) {
  const fileList = filesWhereTagIsUsed(findTag);
  const resultList = [];
  for (const filePath of fileList) {
    const file = app2.vault.getAbstractFileByPath(filePath);
    const fileCache = app2.metadataCache.getFileCache(file);
    if (!fileCache) {
    } else if (!fileCache.headings) {
    } else {
      fileCache.headings.forEach((h) => {
        resultList.push({ notePath: filePath, header: "#" + h.heading, startLine: h.position.start.line, noteType: null });
      });
    }
  }
  return resultList;
}
function locationsWhereTagIsUsed(findTag) {
  const oApp = app;
  const results = [];
  for (const file of oApp.vault.getMarkdownFiles()) {
    const cache = oApp.metadataCache.getFileCache(file);
    if (cache != null && cache.tags) {
      for (const tag2 of cache.tags) {
        if (findTag === tag2.tag) {
          results.push(file.path);
        }
      }
    }
    if (cache != null && cache.frontmatter) {
      const fmtags = ((0, import_obsidian16.parseFrontMatterTags)(cache.frontmatter) || []).filter((tag2) => findTag == tag2 || tag2.startsWith(findTag + "/"));
      if (fmtags.length) {
        results.push(file.path);
      }
      const fmtags2 = ((0, import_obsidian16.parseFrontMatterAliases)(cache.frontmatter) || []).filter((tag2) => findTag == tag2 || tag2.startsWith(findTag + "/"));
      if (fmtags2.length) {
        results.push(file.path);
      }
    }
  }
  return results;
}

// selfutil/noteWithHeader.ts
var SEPARATOR = "-------------------------";

// addTextToNotesFromSpecificTagModal.ts
var BACK_TO_SELECT_TAG = "Back to select tag";
var AddTextToNotesFromSpecificTagModal = class extends import_obsidian17.FuzzySuggestModal {
  constructor(app2, linkToAdd, tagToFind, description, insertFromBeginning, postAction) {
    super(app2);
    this.linkToAdd = linkToAdd;
    this.tagToFind = tagToFind;
    this.insertFromBeginning = insertFromBeginning;
    this.description = description;
    this.postAction = postAction;
    this.setPlaceholder(`Which notes with tag ${tagToFind} do you want to ${description} to ${insertFromBeginning ? "beginning" : "end"} of the notes?`);
    this.setInstructions([
      {
        command: "",
        purpose: `Which notes with tag ${tagToFind} do you want to ${description} to ${insertFromBeginning ? "beginning" : "end"} of the notes?`
      }
    ]);
    this.keydownHandler = (event) => {
      if (event.metaKey || event.ctrlKey) {
        const key = parseInt(event.key, 10);
        if (key >= 1 && key <= 9) {
          event.preventDefault();
          this.selectElement(key - 1);
        }
      }
    };
    document.addEventListener("keydown", this.keydownHandler);
  }
  selectElement(index) {
    const elements = this.resultContainerEl.querySelectorAll(".suggestion-item");
    if (elements.length > index) {
      const element = elements[index];
      element.click();
    }
  }
  onClose() {
    super.onClose();
    document.removeEventListener("keydown", this.keydownHandler);
  }
  getItems() {
    const filePaths = filesWhereTagIsUsed(this.tagToFind);
    const filePathsForHeader = filesHeadersWhereTagIsUsed(this.app, this.tagToFind);
    return [
      ...[{ notePath: BACK_TO_SELECT_TAG, header: "", startLine: -1, noteType: null }],
      ...filePaths.map((f) => {
        return { notePath: f, header: "", startLine: -1, noteType: getNoteType(f) };
      }),
      ...[{ notePath: SEPARATOR, header: "", startLine: 0, noteType: null }],
      ...filePathsForHeader
    ];
  }
  getItemText(path) {
    return path.notePath + path.header;
  }
  // Renders each suggestion item.
  renderSuggestion(path, el) {
    const item = path.item;
    const pathItem = item.notePath;
    let prefix = item.noteType ? item.noteType.prefix ? item.noteType.prefix + " " : "" : "";
    const index = this.resultContainerEl.querySelectorAll(".suggestion-item").length;
    const itemIndex = index < 10 ? index + ". " : "    ";
    el.createEl("div", { text: itemIndex + prefix + item.notePath });
    if (path.item.header.length > 0) {
      el.createEl("small", { text: "     " + item.header });
    }
  }
  // Perform action on the selected suggestion.
  onChooseItem(path, evt) {
    if (BACK_TO_SELECT_TAG == path.notePath) {
      new AddTextToNotesModal(this.app, this.linkToAdd, this.description, this.insertFromBeginning, this.postAction).open();
    } else if (SEPARATOR === path.notePath) {
    } else {
      addTextToNotes(this.linkToAdd, path.notePath, this.app, this.insertFromBeginning, path.startLine);
      this.postAction();
    }
  }
};

// addTextToNotesModal.ts
var import_obsidian18 = require("obsidian");

// selfutil/getAllHeaders.ts
function getAllHeaders(app2, fileList) {
  const resultList = [];
  for (const filePath of fileList) {
    const file = app2.vault.getAbstractFileByPath(filePath);
    const fileCache = app2.metadataCache.getFileCache(file);
    if (!fileCache) {
    } else if (!fileCache.headings) {
    } else {
      fileCache.headings.forEach((h) => {
        resultList.push({ notePath: filePath, header: "#" + h.heading, startLine: h.position.start.line, noteType: null });
      });
    }
  }
  return resultList;
}

// selfutil/getRecentNotes.ts
function getRecentNotes(app2, limit) {
  const recentViewedNotes = app2.workspace.getLastOpenFiles().filter((path) => app2.vault.getAbstractFileByPath(path) !== null);
  return recentViewedNotes.slice(0, Math.min(limit, recentViewedNotes.length));
}
function getAllNotes(app2) {
  const files = app2.vault.getMarkdownFiles();
  const allNotes = files.map((file) => file.path);
  return allNotes;
}
function getAllNotesWithoutMetadata(app2) {
  let getAllNotesWithoutMetadata2 = [];
  const files = app2.vault.getMarkdownFiles();
  files.forEach((file) => {
    const fileCache = this.app.metadataCache.getFileCache(file);
    if (fileCache) {
      const frontmatter = fileCache.frontmatter;
      if (!frontmatter) {
        getAllNotesWithoutMetadata2.push(file.path);
      }
    }
  });
  return getAllNotesWithoutMetadata2;
}

// addTextToNotesModal.ts
var AddTextToNotesModal = class extends import_obsidian18.FuzzySuggestModal {
  constructor(app2, linkToAdd, description, insertFromBeginning, postAction) {
    super(app2);
    this.linkToAdd = linkToAdd;
    this.description = description;
    this.insertFromBeginning = insertFromBeginning;
    this.postAction = postAction;
    this.setPlaceholder(`Which notes with tags do you want to ${description} to ${insertFromBeginning ? "beginning" : "end"} of the notes?`);
    this.setInstructions([
      {
        command: "",
        purpose: `Which notes with tags do you want to ${description} to ${insertFromBeginning ? "beginning" : "end"} of the notes?`
      }
    ]);
    this.keydownHandler = (event) => {
      if (event.metaKey || event.ctrlKey) {
        const key = parseInt(event.key, 10);
        if (key >= 1 && key <= 9) {
          event.preventDefault();
          this.selectElement(key - 1);
        }
      }
    };
    document.addEventListener("keydown", this.keydownHandler);
    this.items = this.prepareItems();
  }
  selectElement(index) {
    const elements = this.resultContainerEl.querySelectorAll(".suggestion-item");
    if (elements.length > index) {
      const element = elements[index];
      element.click();
    }
  }
  getItems() {
    return this.items;
  }
  prepareItems() {
    const allNotesPath = getAllNotes(this.app);
    const allHeader = getAllHeaders(this.app, allNotesPath);
    const l = [
      ...[{ notePath: "I/Inbox.md", header: "", startLine: -1, noteType: getNoteType("I/Inbox.md") }],
      ...getRecentNotes(this.app, 50).map((s) => {
        return { notePath: s, header: "", startLine: -1, noteType: getNoteType(s) };
      }),
      ...getAllNoteTags(this.app).map((s) => s.replace(/^#/, "@")).map((s) => {
        return { notePath: s, header: "", startLine: -1, noteType: null };
      }),
      ...allNotesPath.map((s) => {
        return { notePath: s, header: "", startLine: -1, noteType: getNoteType(s) };
      }),
      ...allHeader
    ];
    return l.filter((item, index) => l.indexOf(item) === index);
  }
  onClose() {
    super.onClose();
    document.removeEventListener("keydown", this.keydownHandler);
  }
  getItemText(value) {
    return value.notePath + value.header;
  }
  // Renders each suggestion item.
  renderSuggestion(value, el) {
    const item = value.item;
    let prefix = item.noteType ? item.noteType.prefix ? item.noteType.prefix + " " : "" : "";
    const index = this.resultContainerEl.querySelectorAll(".suggestion-item").length;
    const itemIndex = index < 10 ? index + ". " : "    ";
    el.createEl("div", { text: itemIndex + prefix + item.notePath });
    if (item.header.length > 0) {
      el.createEl("small", { text: "     " + item.header });
    }
  }
  onOpen() {
    super.onOpen();
    this.inputEl.value = "@";
    this.inputEl.trigger("input");
    this.inputEl.addEventListener("input", () => {
      if (this.inputEl.value.startsWith("@") && (this.inputEl.value.length > 4 || this.inputEl.value.contains("#"))) {
        this.inputEl.value = this.inputEl.value.substring(1);
      }
    });
    this.inputEl.addEventListener("paste", (event) => {
      if (this.inputEl.value === "@") {
        event.preventDefault();
        const text = (event.clipboardData || window.clipboardData).getData("text");
        this.inputEl.value = text;
        this.inputEl.trigger("input");
      }
    });
  }
  // Perform action on the selected suggestion.
  async onChooseItem(choosenValue, evt) {
    if (choosenValue.notePath.startsWith("@")) {
      new AddTextToNotesFromSpecificTagModal(this.app, this.linkToAdd, choosenValue.notePath.replace(/^@/, "#"), this.description, this.insertFromBeginning, this.postAction).open();
    } else {
      addTextToNotes(this.linkToAdd, choosenValue.notePath, this.app, this.insertFromBeginning, choosenValue.startLine);
      this.postAction();
    }
  }
};

// navigateToNoteFromSpecificTagModal.ts
var import_obsidian19 = require("obsidian");
var BACK_TO_SELECT_TAG2 = "Back to select tag";
var OPEN_IN_SEARCH_MODE = "Open in search mode";
var NavigateToNoteFromSpecificTagModal = class extends import_obsidian19.SuggestModal {
  constructor(app2, tagToFind) {
    super(app2);
    this.tagToFind = tagToFind;
    this.setPlaceholder(`Which notes with tag ${tagToFind} do you want to navigate to?`);
    this.setInstructions([
      {
        command: "",
        purpose: `Which notes with tag ${tagToFind} do you want to navigate to?`
      }
    ]);
    this.keydownHandler = (event) => {
      if (event.ctrlKey && event.altKey && event.shiftKey && event.key === ";") {
        this.close();
      } else if (event.ctrlKey && event.metaKey && event.shiftKey && event.key === ";") {
        this.close();
      } else if (event.metaKey || event.ctrlKey) {
        const key = parseInt(event.key, 10);
        if (key >= 1 && key <= 9) {
          event.preventDefault();
          this.selectElement(key - 1);
        }
      }
    };
    document.addEventListener("keydown", this.keydownHandler);
  }
  selectElement(index) {
    const elements = this.resultContainerEl.querySelectorAll(".suggestion-item");
    if (elements.length > index) {
      const element = elements[index];
      element.click();
    }
  }
  onClose() {
    super.onClose();
    document.removeEventListener("keydown", this.keydownHandler);
  }
  async getSuggestions(query) {
    const filePaths = filesWhereTagIsUsed(this.tagToFind);
    const headers = [];
    const lines = [];
    const isActionTag = !/^#[a-z]\/[a-z]\/[a-z]$/.test(this.tagToFind) && !/^#[a-z]\/[a-z]$/.test(this.tagToFind) && !/^#[a-z]$/.test(this.tagToFind);
    const readPromises = filePaths.map(async (filePath) => {
      const file = this.app.vault.getAbstractFileByPath(filePath);
      const fileCache = this.app.metadataCache.getFileCache(file);
      if (!fileCache)
        return;
      if (isActionTag) {
        if (fileCache.tags) {
          const content = await this.app.vault.read(file);
          const fileLines = content.split("\n");
          for (const tag2 of fileCache.tags) {
            if (tag2.tag === this.tagToFind) {
              const heading2 = this.getHeadingForLine(fileCache, tag2.position.start.line);
              const lineContent = fileLines[tag2.position.start.line].trim();
              if ((filePath + lineContent).toLowerCase().includes(query.toLowerCase())) {
                lines.push({
                  notePath: filePath,
                  header: (heading2 ? heading2 + "\n     " : "") + lineContent,
                  startLine: tag2.position.start.line,
                  noteType: null
                });
              }
            }
          }
        }
      } else {
        if (fileCache.headings) {
          fileCache.headings.forEach((h) => {
            headers.push({
              notePath: filePath,
              header: "#" + h.heading,
              startLine: h.position.start.line,
              noteType: null
            });
          });
        }
      }
    });
    await Promise.all(readPromises);
    if (isActionTag) {
      return [
        { notePath: BACK_TO_SELECT_TAG2, header: "", startLine: 0, noteType: null },
        { notePath: OPEN_IN_SEARCH_MODE, header: "", startLine: 0, noteType: null },
        ...lines
      ];
    }
    return [
      { notePath: BACK_TO_SELECT_TAG2, header: "", startLine: 0, noteType: null },
      { notePath: OPEN_IN_SEARCH_MODE, header: "", startLine: 0, noteType: null },
      ...filePaths.filter((f) => f.toLowerCase().includes(query.toLowerCase())).map((f) => ({ notePath: f, header: "", startLine: 0, noteType: getNoteType(f) })),
      //    ...filePaths.filter(f => this.fuzzyMatch(f.toLowerCase(), query.toLowerCase())).map(f => ({ notePath: f, header: "", startLine: 0, noteType: getNoteType(f) })),
      { notePath: SEPARATOR, header: "", startLine: 0, noteType: null },
      ...headers
    ];
  }
  getHeadingForLine(fileCache, lineNumber) {
    if (!fileCache || !fileCache.headings) {
      return "";
    }
    const headings = fileCache.headings;
    let currentHeading = "";
    for (const heading2 of headings) {
      if (heading2.position.start.line <= lineNumber) {
        currentHeading = "# " + heading2.heading;
      } else {
        break;
      }
    }
    return currentHeading;
  }
  fuzzyMatch(str, pattern) {
    if (!pattern)
      return true;
    pattern = pattern.split("").reduce((a, b) => `${a}.*${b}`);
    return new RegExp(pattern).test(str);
  }
  getItemText(path) {
    return path.notePath + path.header;
  }
  // Renders each suggestion item.
  //renderSuggestion(path: FuzzyMatch<NoteWithHeader>, el: HTMLElement) {
  renderSuggestion(item, el) {
    const pathItem = item.notePath;
    let prefix = item.noteType ? item.noteType.prefix ? item.noteType.prefix + " " : "" : "";
    const index = this.resultContainerEl.querySelectorAll(".suggestion-item").length;
    const itemIndex = index < 10 ? index + ". " : "    ";
    el.createEl("div", { text: itemIndex + prefix + pathItem });
    if (item.header.length > 0) {
      el.createEl("small", { text: "     " + item.header });
    }
  }
  onChooseSuggestion(path, evt) {
    if (BACK_TO_SELECT_TAG2 === path.notePath) {
      new NavigateToNoteFromTagModal(this.app).open();
    } else if (OPEN_IN_SEARCH_MODE === path.notePath) {
      const searchPlugin = this.app.internalPlugins.getPluginById("global-search");
      const search = searchPlugin && searchPlugin.instance;
      const defaultTagSearchString = `tag:${this.tagToFind}`;
      search.openGlobalSearch(defaultTagSearchString);
    } else if (SEPARATOR === path.notePath) {
    } else {
      const { vault, workspace } = this.app;
      const leaf = workspace.getLeaf(false);
      Promise.resolve().then(() => {
        return leaf.openFile(vault.getAbstractFileByPath(path.notePath), { active: true });
      }).then(() => {
        const markdownView = app.workspace.getActiveViewOfType(import_obsidian19.MarkdownView);
        const editor = markdownView == null ? void 0 : markdownView.editor;
        if (markdownView == null || editor == null) {
          const errorReason = `editor or value ${path.notePath} not exist. Aborting...`;
          return Promise.reject(errorReason);
        }
        editor.setCursor({ line: path.startLine, ch: 0 });
        editor.scrollIntoView({ from: { line: path.startLine, ch: 0 }, to: { line: path.startLine, ch: 0 } }, true);
      });
    }
  }
};

// navigateToNoteFromTagModal.ts
var import_obsidian20 = require("obsidian");
var note = "note";
var history = "history";
var tag = "tag";
var heading = "heading";
var NavigateToNoteFromTagModal = class extends import_obsidian20.FuzzySuggestModal {
  constructor(app2) {
    super(app2);
    this.setPlaceholder(`Which notes with tags do you want to navigate to?`);
    this.setInstructions([
      {
        command: "",
        purpose: "Which notes with tags do you want to navigate to?"
      }
    ]);
    this.keydownHandler = (event) => {
      if (event.ctrlKey && event.altKey && event.shiftKey && event.key === ";") {
        this.close();
      } else if (event.ctrlKey && event.metaKey && event.shiftKey && event.key === ";") {
        this.close();
      } else if (event.metaKey || event.ctrlKey) {
        const key = parseInt(event.key, 10);
        if (key >= 1 && key <= 9) {
          event.preventDefault();
          this.selectElement(key - 1);
        }
      }
    };
    document.addEventListener("keydown", this.keydownHandler);
    this.items = this.prepareItems();
  }
  selectElement(index) {
    const elements = this.resultContainerEl.querySelectorAll(".suggestion-item");
    if (elements.length > index) {
      const element = elements[index];
      element.click();
    }
  }
  onClose() {
    super.onClose();
    document.removeEventListener("keydown", this.keydownHandler);
  }
  getItems() {
    return this.items;
  }
  prepareItems() {
    const allNotes = getAllNotes(this.app);
    let headings = [];
    allNotes.forEach((n) => {
      const file = this.app.vault.getAbstractFileByPath(n);
      const fileCache = this.app.metadataCache.getFileCache(file);
      if (!fileCache) {
        return;
      }
      if (!fileCache.headings) {
        return;
      }
      fileCache.headings.forEach((h) => {
        headings.push({ note: n, heading: h.heading, level: h.level, startLine: h.position.start.line });
      });
    });
    return [
      ...getRecentNotes(this.app, 50).map((n) => {
        return { search: n, secondary: "", type: history };
      }),
      ...getAllTagsWithFilter(this.app).map((n) => {
        return { search: n.replace(/^#/, "@"), secondary: "", type: tag };
      }),
      ...allNotes.map((n) => {
        return { search: n, secondary: "", type: note };
      }),
      ...headings.map((h) => {
        return { search: "#".repeat(h.level) + " " + h.heading, secondary: h.note, type: heading };
      })
    ];
  }
  getItemText(value) {
    return value.search;
  }
  // Renders each suggestion item.
  renderSuggestion(value, el) {
    const item = value.item;
    let prefix = "";
    if (item.type === note || item.type === history) {
      const noteType = getNoteType(item.search);
      prefix = noteType ? noteType.prefix + " " : "";
    }
    const index = this.resultContainerEl.querySelectorAll(".suggestion-item").length;
    const itemIndex = index < 10 ? index + ". " : "    ";
    el.createEl("div", { text: itemIndex + prefix + item.search });
    el.createEl("small", { text: "     " + item.type + " " + item.secondary });
  }
  onOpen() {
    super.onOpen();
    this.inputEl.value = "@";
    this.inputEl.trigger("input");
    this.inputEl.addEventListener("input", () => {
      if (this.inputEl.value.startsWith("@") && (this.inputEl.value.length > 4 || this.inputEl.value.contains("#"))) {
        this.inputEl.value = this.inputEl.value.substring(1);
      }
    });
    this.inputEl.addEventListener("paste", (event) => {
      if (this.inputEl.value === "@") {
        event.preventDefault();
        const text = (event.clipboardData || window.clipboardData).getData("text");
        this.inputEl.value = text;
        this.inputEl.trigger("input");
      }
    });
  }
  // Perform action on the selected suggestion.
  async onChooseItem(choosenValue, evt) {
    if (choosenValue.type == tag) {
      new NavigateToNoteFromSpecificTagModal(this.app, choosenValue.search.replace("@", "#")).open();
    } else if (choosenValue.type == note || choosenValue.type == history) {
      const { vault, workspace } = this.app;
      const leaf = workspace.getLeaf(false);
      Promise.resolve().then(() => {
        return leaf.openFile(vault.getAbstractFileByPath(choosenValue.search), { active: true });
      });
    } else if (choosenValue.type == heading) {
      const { vault, workspace } = this.app;
      const leaf = workspace.getLeaf(false);
      Promise.resolve().then(() => {
        return leaf.openFile(vault.getAbstractFileByPath(choosenValue.secondary), { active: true });
      }).then(() => {
        const markdownView = app.workspace.getActiveViewOfType(import_obsidian20.MarkdownView);
        const editor = markdownView == null ? void 0 : markdownView.editor;
        if (markdownView == null || editor == null) {
          const errorReason = `editor or value ${choosenValue.secondary} not exist. Aborting...`;
          return Promise.reject(errorReason);
        }
        const totalLineNum = editor.lineCount();
        for (let i = 0; i < totalLineNum; i++) {
          const line = editor.getLine(i);
          if (line == choosenValue.search) {
            editor.setCursor({ line: i, ch: 0 });
            editor.scrollIntoView({ from: { line: i, ch: 0 }, to: { line: i, ch: 0 } }, true);
            return;
          }
        }
      });
    }
  }
};

// selfutil/extractSelection.ts
function exportCurrentSelection(editor) {
  let text = "";
  const listSelections = editor.listSelections();
  listSelections.forEach((listSelection) => {
    const a = listSelection.head.line;
    const b = listSelection.anchor.line;
    const fromLineNum = b > a ? a : b;
    const toLineNum = b > a ? b : a;
    for (let i = fromLineNum; i <= toLineNum; i++) {
      const line = editor.getLine(i);
      text += line + "\n";
    }
  });
  return text.replace(/\n$/, "");
}
function getCurrentSelectionLineNumber(editor) {
  let text = "";
  let fromLineNum = 0;
  let fromCh = 0;
  let toLineNum = 0;
  let toCh = 0;
  const listSelections = editor.listSelections();
  listSelections.forEach((listSelection) => {
    const a = listSelection.head.line;
    const ach = listSelection.head.ch;
    const b = listSelection.anchor.line;
    const bch = listSelection.anchor.ch;
    fromLineNum = b > a ? a : b;
    fromCh = b > a ? ach : bch;
    toLineNum = b > a ? b : a;
    toCh = b > a ? bch : ach;
  });
  return { fromLineNum, fromCh, toLineNum, toCh };
}

// twmigration/twMigrateTools.ts
var skipFrontMatterField = [
  "freetimetask: ",
  "expectedtime: ",
  "mode: ",
  "days: ",
  "showheaderfooter: ",
  "showstate: ",
  "sortsubpagefilter: ",
  "throughttree: ",
  "urgent: ",
  "displayas: ",
  "startdate: ",
  "readwritemode: ",
  "showChandlerNow: ",
  "deepwork: ",
  "expectedtime: ",
  "parsedate: ",
  "tidscope: ",
  "inserttodoaction: ",
  "optional: ",
  "replaceto: ",
  "backuptiddler: ",
  "deadline: ",
  "caption: ",
  "collection: ",
  "library: ",
  "library_version: ",
  "dummy: ",
  "tidName: ",
  "chronicledate: ",
  "eventdate: ",
  "dailyhighlight: ",
  "displaycardmode: ",
  "displaymode: ",
  "numcol: ",
  "dateyyyymmdd: ",
  "graphdisplaymode: ",
  "maxdepth: ",
  "journaldate: ",
  "thisBillDate: ",
  "lastBillDate: ",
  "roottiddler: ",
  "year: ",
  "to: ",
  "tidtemplate: ",
  "tiddlername: ",
  "theme: ",
  "tagvalue: ",
  "subtasknum: ",
  "removetagvalue: ",
  "recurringeventstartdate: ",
  "recurringeventenddate: ",
  "pluginname: ",
  "pid: ",
  "macroname: ",
  "limit: ",
  "keyword: ",
  "keywordtmp: ",
  "from: ",
  "deprecatereason: ",
  "deepwo: ",
  "color: ",
  "row: ",
  "col: ",
  "bookmarked: ",
  "blockingreminderdate: ",
  "backup: "
];
function replaceTWUselessValue(value) {
  return value.replace("## > References\n\n- \n\n", "").replace("## > Goal and Reason\n\n- \n\n", "").replace("## > Deliverable Spec\n\n- \n\n", "").replace("## > Conditon of done\n\n- \n\n", "").replace("## > Step\n\n- \n\n", "").replace("## > Progress\n\n- \n\n", "").replace("## > Results\n\n- \n\n", "").replace("## > Experience\n\n- \n\n", "").replace("## > References\n\n- \n\n", "").replace("## > Results, Steps and Exp\n\n- \n\n", "").replace("## > Checklist\n\n[ ] \n\n", "").replace("## > Cache\n\n[ ] \n\n", "").replace("## > Scenario\n\n- \n\n", "").replace("## > Goal\n\n- \n\n", "").replace("## > Goal\n\n*\n\n", "").replace("## > Deliverable Spec / Condition of Done\n\n- \n\n", "").replace("## > Planned Step\n\n#\n\n", "").replace("## > Actual Step\n\n1. \n\n", "").replace("## > Actual Step\n\n1.  \n\n", "").replace("## > Result\n\n- \n\n", "").replace("## > How to do it better next time\n\n- \n\n", "").replace("## > Next time action\n\n- \n\n", "").replace(/\n\n\n+/g, "\n\n");
}
function shouldSkipFrontMatter(line) {
  for (let i = 0; i < skipFrontMatterField.length; i++) {
    if (line.startsWith(skipFrontMatterField[i])) {
      return true;
    }
  }
  return false;
}
function getParentLine(value) {
  const values = value.split("\n");
  for (let i = 0; i < values.length; i++) {
    const lineContent = values[i];
    if (/^parent\d+: /.test(lineContent) || /^\t+- parent\d+: /.test(lineContent)) {
      return i;
    }
  }
  return 0;
}
function tidyUpFrontMatteronEditor(editor) {
  const value = editor.getValue();
  const modifiedValue = tidyUpFrontMatterOnValue(value);
  editor.setValue(modifiedValue);
}
function tidyUpFrontMatterOnValue(value) {
  const values = value.split("\n");
  const lineCount = values.length;
  let fm = "";
  let c = "";
  let text = "";
  let h3Count = 0;
  let content = "";
  return replaceTWUselessValue(value);
}

// selfutil/removeContentFromCursor.ts
var import_obsidian21 = require("obsidian");
function removeContentFromStartOfNoteToCursor(editor) {
  const cursor = editor.getCursor();
  const line = cursor.line;
  const ch = cursor.ch;
  const lineContent = editor.getLine(line);
  let newContent = lineContent.substring(ch);
  for (let i = line + 1; i < editor.lineCount(); i++) {
    newContent += "\n" + editor.getLine(i);
  }
  editor.setValue(newContent);
  cursor.line = 0;
  cursor.ch = 0;
  editor.setCursor(cursor);
}
function removeContentFromCursorToEndOfNote(editor) {
  const cursor = editor.getCursor();
  const line = cursor.line;
  const ch = cursor.ch;
  const lineContent = editor.getLine(line);
  let newContent = "";
  for (let i = 0; i < line; i++) {
    newContent += editor.getLine(i) + "\n";
  }
  newContent += lineContent.substring(0, ch);
  editor.setValue(newContent);
  cursor.line = line;
  cursor.ch = ch;
  editor.setCursor(cursor);
}
function copyContentFromCursorToEndOfNote(editor) {
  const cursor = editor.getCursor();
  const line = cursor.line;
  const ch = cursor.ch;
  const lineContent = editor.getLine(line);
  let newContent = "";
  newContent += lineContent.substring(ch);
  for (let i = line + 1; i < editor.lineCount(); i++) {
    newContent += "\n" + editor.getLine(i);
  }
  navigator.clipboard.writeText(newContent).then(function() {
    new import_obsidian21.Notice(`Copied content from cursor to end of note to clipboard!`);
  }, function(error) {
    new import_obsidian21.Notice(`error when copy to clipboard!`);
  });
}
function removeContentLeftSameLine(editor) {
  const cursor = editor.getCursor();
  const line = cursor.line;
  const ch = cursor.ch;
  const lineContent = editor.getLine(line);
  editor.setLine(line, lineContent.substring(ch));
  cursor.ch = 0;
  editor.setCursor(cursor);
}
function removeContentRightSameLine(editor) {
  const cursor = editor.getCursor();
  const line = cursor.line;
  const ch = cursor.ch;
  const lineContent = editor.getLine(line);
  editor.setLine(line, lineContent.substring(0, ch));
  cursor.ch = editor.getLine(line).length;
  editor.setCursor(cursor);
}

// removeContentFromCursorModal.ts
var import_obsidian22 = require("obsidian");
var RemoveContentFromCursorModal = class extends import_obsidian22.FuzzySuggestModal {
  constructor(app2, editor) {
    super(app2);
    this.copyContentFromCursorToEndOfNote = "Copy content from cursor to end of note";
    this.cutContentFromCursorToEndOfNote = "Cut content from cursor to end of note";
    this.removeContentLeftSameLine = "Remove content left same line";
    this.removeContentRightSameLine = "Remove content right same line";
    this.removeContentFromStartOfNoteToCursor = "Remove content from start of note to cursor";
    this.removeContentFromCursorToEndOfNote = "Remove content from cursor to end of note";
    this.options = [this.copyContentFromCursorToEndOfNote, this.cutContentFromCursorToEndOfNote, this.removeContentLeftSameLine, this.removeContentRightSameLine, this.removeContentFromStartOfNoteToCursor, this.removeContentFromCursorToEndOfNote];
    this.editor = editor;
    this.keydownHandler = (event) => {
      if (event.ctrlKey && event.altKey && event.shiftKey && event.key === "X") {
        this.close();
      } else if (event.ctrlKey && event.metaKey && event.shiftKey && event.key === "X") {
        this.close();
      } else if (event.metaKey || event.ctrlKey) {
        const key = parseInt(event.key, 10);
        if (key >= 1 && key <= 9) {
          event.preventDefault();
          this.selectElement(key - 1);
        }
      }
    };
    document.addEventListener("keydown", this.keydownHandler);
  }
  selectElement(index) {
    const elements = this.resultContainerEl.querySelectorAll(".suggestion-item");
    if (elements.length > index) {
      const element = elements[index];
      element.click();
    }
  }
  onClose() {
    super.onClose();
    document.removeEventListener("keydown", this.keydownHandler);
  }
  getItems() {
    return this.options;
  }
  getItemText(item) {
    return item;
  }
  // Renders each suggestion item.
  renderSuggestion(i, el) {
    const item = i.item;
    const index = this.resultContainerEl.querySelectorAll(".suggestion-item").length;
    const itemIndex = index < 10 ? index + ". " : "    ";
    el.createEl("div", { text: itemIndex + item });
  }
  // Perform action on the selected suggestion.
  async onChooseItem(selectedContent, evt) {
    const choosenOption = selectedContent;
    if (choosenOption === this.removeContentLeftSameLine) {
      removeContentLeftSameLine(this.editor);
    } else if (choosenOption === this.removeContentRightSameLine) {
      removeContentRightSameLine(this.editor);
    } else if (choosenOption === this.removeContentFromStartOfNoteToCursor) {
      removeContentFromStartOfNoteToCursor(this.editor);
    } else if (choosenOption === this.removeContentFromCursorToEndOfNote) {
      removeContentFromCursorToEndOfNote(this.editor);
    } else if (choosenOption === this.copyContentFromCursorToEndOfNote) {
      copyContentFromCursorToEndOfNote(this.editor);
    } else if (choosenOption === this.cutContentFromCursorToEndOfNote) {
      copyContentFromCursorToEndOfNote(this.editor);
      removeContentFromCursorToEndOfNote(this.editor);
    }
  }
};

// findReplaceModal.ts
var import_obsidian23 = require("obsidian");
var FindReplaceModal = class extends import_obsidian23.FuzzySuggestModal {
  constructor(app2) {
    super(app2);
    this.find = "find";
    this.replace = "replace";
    this.options = [this.find, this.replace];
  }
  getItems() {
    return this.options;
  }
  getItemText(item) {
    return item;
  }
  // Renders each suggestion item.
  renderSuggestion(i, el) {
    const item = i.item;
    el.createEl("div", { text: item });
  }
  // Perform action on the selected suggestion.
  async onChooseItem(selectedContent, evt) {
    const choosenOption = selectedContent;
    if (choosenOption === this.find) {
      this.app.commands.executeCommandById("editor:open-search");
    } else {
      this.app.commands.executeCommandById("obsidian-regex-replace:obsidian-regex-replace");
    }
  }
};

// queryOrphanNotesByTagModal.ts
var import_obsidian24 = require("obsidian");
var QueryOrphanNotesByTagModal = class extends import_obsidian24.FuzzySuggestModal {
  constructor(app2, editor, view) {
    super(app2);
    this.setPlaceholder(`Which notes with tags do you want to search orphan?`);
    this.setInstructions([
      {
        command: "",
        purpose: `Which notes with tags do you want to search orphan?`
      }
    ]);
    this.editor = editor;
    this.view = view;
    this.keydownHandler = (event) => {
      if (event.metaKey || event.ctrlKey) {
        const key = parseInt(event.key, 10);
        if (key >= 1 && key <= 9) {
          event.preventDefault();
          this.selectElement(key - 1);
        }
      }
    };
    document.addEventListener("keydown", this.keydownHandler);
  }
  selectElement(index) {
    const elements = this.resultContainerEl.querySelectorAll(".suggestion-item");
    if (elements.length > index) {
      const element = elements[index];
      element.click();
    }
  }
  onClose() {
    super.onClose();
    document.removeEventListener("keydown", this.keydownHandler);
  }
  getItems() {
    const l = [...getAllNoteTags(this.app).map((s) => s.replace(/^#/, "@"))];
    return l.filter((item, index) => l.indexOf(item) === index);
  }
  getItemText(value) {
    return value;
  }
  // Renders each suggestion item.
  renderSuggestion(value, el) {
    const item = value.item;
    const index = this.resultContainerEl.querySelectorAll(".suggestion-item").length;
    const itemIndex = index < 10 ? index + ". " : "    ";
    el.createEl("div", { text: itemIndex + item });
  }
  // Perform action on the selected suggestion.
  async onChooseItem(choosenValue, evt) {
    const queryMd = "I/Self Query.md";
    if (this.view.file.path === queryMd) {
      new import_obsidian24.Notice("Checking... may need some time");
      const tag2 = choosenValue.replace(/^@/, "#");
      const filePaths = filesWhereTagIsUsed(tag2);
      let result = "## Orphan notes for tag `" + tag2 + "`\n";
      for (const filePath of filePaths) {
        const tFile = this.app.vault.getAbstractFileByPath(filePath);
        const backlinks = this.app.metadataCache.getBacklinksForFile(tFile);
        if (!backlinks || !backlinks.data || Object.keys(backlinks.data).length === 0) {
          console.log(`No backlinks for ${tFile.path}`);
          result += "\n- [[" + tFile.basename + "]]";
        } else {
          delete backlinks.data[queryMd];
          if (Object.keys(backlinks.data).length === 0) {
            result += "\n- [[" + tFile.basename + "]]";
          } else {
          }
        }
      }
      this.editor.setValue(result);
      new import_obsidian24.Notice("Updated orphan");
    } else {
      new import_obsidian24.Notice("Please go to '" + queryMd + "' to run this action");
    }
  }
};

// navigateToForwardAndBacklinkModal.ts
var import_obsidian25 = require("obsidian");
var NavigateToForwardAndBacklinkTagModal = class extends import_obsidian25.SuggestModal {
  constructor(app2, view, editor) {
    super(app2);
    this.view = view;
    this.editor = editor;
    const thisFileName = this.view.file.path;
    const displayThisFileType = getNoteType(thisFileName);
    const displayThisFile = displayThisFileType ? displayThisFileType.prefix + " " + thisFileName : thisFileName;
    this.setPlaceholder(`${displayThisFile} - Which link do you want to navigate to?`);
    this.setInstructions([
      {
        command: "",
        purpose: `${displayThisFile} - Which link do you want to navigate to?`
      }
    ]);
    this.keydownHandler = (event) => {
      if (event.ctrlKey && event.altKey && event.shiftKey && event.key === "O") {
        this.close();
      } else if (event.ctrlKey && event.metaKey && event.shiftKey && event.key === "O") {
        this.close();
      } else if (event.metaKey || event.ctrlKey) {
        const key = parseInt(event.key, 10);
        if (key >= 1 && key <= 9) {
          event.preventDefault();
          this.selectElement(key - 1);
        }
      }
    };
    document.addEventListener("keydown", this.keydownHandler);
  }
  selectElement(index) {
    const elements = this.resultContainerEl.querySelectorAll(".suggestion-item");
    if (elements.length > index) {
      const element = elements[index];
      element.click();
    }
  }
  onClose() {
    super.onClose();
    document.removeEventListener("keydown", this.keydownHandler);
  }
  getTFileByPath(path) {
    const file = this.app.vault.getAbstractFileByPath(path);
    if (file instanceof import_obsidian25.TFile) {
      return file;
    }
    return null;
  }
  getHeadingForLine(path, lineNumber) {
    const file = this.getTFileByPath(path);
    if (!file) {
      return "";
    }
    const fileCache = this.app.metadataCache.getFileCache(file);
    if (!fileCache || !fileCache.headings) {
      return "";
    }
    const headings = fileCache.headings;
    let currentHeading = "";
    for (const heading2 of headings) {
      if (heading2.position.start.line <= lineNumber) {
        currentHeading = "#" + heading2.heading;
      } else {
        break;
      }
    }
    return currentHeading;
  }
  async getLinkItems() {
    const forwardLinkItems = await this.getForwardlinkItems();
    let backLinkItems = [];
    let childLinkItems = [];
    let parentLinkItems = [];
    const backlinks = this.app.metadataCache.getBacklinksForFile(this.view.file);
    const backlinksData = backlinks == null ? void 0 : backlinks.data;
    if (backlinksData) {
      for (let i in backlinksData) {
        for (let j = 0; j < backlinksData[i].length; j++) {
          const index = backlinksData[i].length > 1 ? "[" + j + "]" : "";
          if (i != this.view.file.path) {
            const key = backlinksData[i][j]["key"];
            if (key) {
              childLinkItems.push({ path: i, type: "v ", index, heading: "", line: 0, ch: 0 });
            } else {
              const position = backlinksData[i][j]["position"];
              const line = position["start"]["line"];
              const heading2 = this.getHeadingForLine(i, line);
              const backlinkLineFile = this.app.vault.getAbstractFileByPath(i);
              const backlinkLineFiles = backlinkLineFile ? await this.app.vault.read(backlinkLineFile) : "";
              const backlinkLineFiles2 = backlinkLineFiles.split("\n");
              const backlinkLine = backlinkLineFiles2[line].trim();
              const backlinkLine2 = backlinkLine.replace(/^- /, "").replace(/^\d+\. /, "");
              const backlinkLine3 = backlinkLine2 === backlinksData[i][j]["original"] ? "" : backlinkLine2;
              let zkContent = "";
              const backlinkNoteType = getNoteType(i);
              console.log(backlinkNoteType);
              if (backlinkNoteType && backlinkNoteType.type === "b/n/z") {
                if (line - 3 >= 0) {
                  zkContent += backlinkLineFiles2[line - 3] + "\n";
                }
                if (line - 2 >= 0) {
                  zkContent += backlinkLineFiles2[line - 2] + "\n";
                }
                if (line - 1 >= 0) {
                  zkContent += backlinkLineFiles2[line - 1] + "\n";
                }
                zkContent += backlinkLineFiles2[line] + "\n";
                if (line + 1 < backlinkLineFiles2.length) {
                  zkContent += backlinkLineFiles2[line + 1] + "\n";
                }
                if (line + 2 < backlinkLineFiles2.length) {
                  zkContent += backlinkLineFiles2[line + 2] + "\n";
                }
                if (line + 3 < backlinkLineFiles2.length) {
                  zkContent += backlinkLineFiles2[line + 3] + "\n";
                }
                zkContent = zkContent.replace(/\n$/, "");
              }
              const aaa = this.getBacklinkHeading(heading2, backlinkLine3, zkContent);
              backLinkItems.push({ path: i, type: "< ", index, heading: aaa, line: backlinksData[i][j]["position"]["start"]["line"], ch: backlinksData[i][j]["position"]["start"]["col"] });
            }
          }
        }
      }
    }
    const fileCache = this.app.metadataCache.getFileCache(this.view.file);
    if (fileCache) {
      const frontmatter = fileCache.frontmatter;
      if (frontmatter) {
        for (const key in frontmatter) {
          if (frontmatter.hasOwnProperty(key)) {
            const value = frontmatter[key];
            if (value.startsWith("[[") && value.endsWith("]]")) {
              const noteLink = value.slice(2, -2);
              const linkedFile = this.app.metadataCache.getFirstLinkpathDest(noteLink, this.view.file.path);
              const tf = linkedFile ? this.app.vault.getAbstractFileByPath(linkedFile.path) : null;
              if (tf) {
                parentLinkItems.push({ path: tf.path, type: "^ ", index: "", heading: "", line: 0, ch: 0 });
              }
            }
          }
        }
      }
    }
    return [...childLinkItems, ...parentLinkItems, ...backLinkItems, ...forwardLinkItems];
  }
  getBacklinkHeading(heading2, line, zkContent) {
    if (heading2 !== "" && line !== "" && zkContent !== "") {
      return heading2 + "\n" + line + "\n" + zkContent;
    } else if (heading2 !== "" && line !== "" && zkContent === "") {
      return heading2 + "\n" + line;
    } else if (heading2 !== "" && line === "" && zkContent !== "") {
      return heading2 + "\n" + zkContent;
    } else if (heading2 !== "" && line === "" && zkContent === "") {
      return heading2;
    } else if (heading2 === "" && line !== "" && zkContent !== "") {
      return line + "\n" + zkContent;
    } else if (heading2 === "" && line !== "" && zkContent === "") {
      return line;
    } else if (zkContent !== "") {
      return zkContent;
    } else {
      return "";
    }
  }
  async getForwardlinkItems() {
    var _a;
    const forwardlinks = (_a = this.app.metadataCache.getFileCache(this.view.file)) == null ? void 0 : _a.links;
    if (!forwardlinks) {
      return [];
    }
    const fileContent = this.view.file ? await this.app.vault.read(this.view.file) : "";
    const lineContents = fileContent === "" ? [] : fileContent.split("\n");
    const paths = forwardlinks.map((link) => {
      const linkedFile = this.app.metadataCache.getFirstLinkpathDest(link.link, this.view.file.path);
      const tf = linkedFile ? this.app.vault.getAbstractFileByPath(linkedFile.path) : null;
      const lineContent = lineContents.length != 0 ? lineContents[link.position.start.line].trim() : "";
      const content = lineContent.replace(/^- /, "").replace(/^\d+\. /, "") === link.original ? "" : lineContent;
      return { path: tf ? tf.path : "", content };
    });
    return paths.filter((pc) => pc.path !== "").map((pc) => {
      return { path: pc.path, type: "> ", index: "", heading: pc.content, line: 0, ch: 0 };
    });
  }
  getSameTagItems() {
    let items = [];
    let { frontmatter } = app.metadataCache.getFileCache(this.view.file) || {};
    const fmtags = (0, import_obsidian25.parseFrontMatterTags)(frontmatter) || [];
    var tag2 = "";
    for (let i = 0; i < fmtags.length; i++) {
      if (/#[a-z]\/[a-z]\/[a-z]/.test(fmtags[i])) {
        tag2 = fmtags[i];
        break;
      }
    }
    if (tag2 !== "") {
      const filePaths = filesWhereTagIsUsed(tag2);
      for (let i = 0; i < filePaths.length; i++) {
        items.push({ path: filePaths[i], type: "@ ", index: "", heading: "", line: 0, ch: 0 });
      }
    }
    return items;
  }
  getContentItems() {
    const value = this.editor.getValue();
    const lines = value.split("\n");
    let resultAsJiraLink = [];
    let resultAsHeader = [];
    let resultAsUnfinishedAction = [];
    let resultAsFinishedAction = [];
    let resultAsContent = [];
    let resultAsExternalLinks = [];
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i].trim();
      if (line != "---" && line !== "" && !/^tags: [a-z]\/[a-z]\/[a-z]/.test(line)) {
        if (/^[#]{1,6} /.test(line)) {
          resultAsHeader.push({ path: line.replace(/^[#]{1,6}/, ""), type: line.replace(/^([#]{1,6} ).*/, "$1"), index: "", heading: "", line: i, ch: 0 });
        } else if (/#[wnt][nlwdatme] /.test(line) || / #[wnt][nlwdatme]/.test(line)) {
          if (/#[wn][da] /.test(line) || / #[wn][da]/.test(line)) {
            resultAsFinishedAction.push({ path: line, type: "x ", index: "", heading: "", line: i, ch: 0 });
          } else {
            resultAsUnfinishedAction.push({ path: line, type: "z ", index: "", heading: "", line: i, ch: 0 });
          }
        } else {
          resultAsContent.push({ path: line, type: "c ", index: "", heading: "", line: i, ch: 0 });
        }
      }
      const urlRegex = /(http|https):\/\/(\w+:{0,1}\w*@)?(\S+)(:[0-9]+)?(\/|\/([\w#!:.?+=&%@!\-/]))?/g;
      const matches = line.match(urlRegex);
      if (matches) {
        for (let j = 0; j < matches.length; j++) {
          resultAsExternalLinks.push({ path: matches[j], type: "w ", index: "", heading: "", line: i, ch: 0 });
        }
      } else {
        const jiraLinkRegex = /([A-Z]+-[0-9]+)/g;
        const jiraMatches = line.match(jiraLinkRegex);
        if (jiraMatches) {
          for (let j = 0; j < jiraMatches.length; j++) {
            resultAsJiraLink.push({ path: "https://jira.orcsoftware.com/browse/" + jiraMatches[j], type: "j ", index: "", heading: "", line: i, ch: 0 });
          }
        }
      }
    }
    return [
      ...resultAsHeader,
      ...resultAsUnfinishedAction,
      //...resultAsFinishedAction,
      ...resultAsJiraLink,
      ...resultAsExternalLinks,
      ...resultAsContent
    ];
  }
  /*
    getItems(): LinkType[] {
      return this.items
    }
  */
  async prepareItems() {
    const linkItems = await this.getLinkItems();
    const sameTagItems = await this.getSameTagItems();
    const contentItems = await this.getContentItems();
    return [
      ...linkItems,
      { path: "------------------", type: "", index: "", heading: "", line: 0, ch: 0 },
      ...sameTagItems,
      { path: "------------------", type: "", index: "", heading: "", line: 0, ch: 0 },
      ...contentItems
    ];
  }
  async getSuggestions(query) {
    const items = await this.prepareItems();
    return items.filter((i) => {
      const lowerQuery = query.toLowerCase();
      return new RegExp(lowerQuery).test((i.type + i.path).toLowerCase());
    });
  }
  getItemText(l) {
    return l.path;
  }
  // Renders each suggestion item.
  renderSuggestion(ll, el) {
    const index = this.resultContainerEl.querySelectorAll(".suggestion-item").length;
    const itemIndex = index < 10 ? index + ". " : "    ";
    el.createEl("div", { text: itemIndex + ll.type + this.getTaskTag(ll.type, ll.path) + ll.path + ll.index });
    if (ll.heading !== "") {
      el.createEl("small", { text: ll.heading, cls: "self-padding-left-55" });
    }
  }
  getTaskTag(type, path) {
    if (type === "> " || type === "< " || type === "v " || type === "^ " || type === "@ ") {
      const noteType = getNoteType(path);
      return noteType ? " " + noteType.prefix + " " : "";
    }
    return "";
  }
  // Perform action on the selected suggestion.
  onChooseSuggestion(l, evt) {
    if (l.type === "") {
      return;
    }
    if (l.type === "< " || l.type === "> " || l.type === "v " || l.type === "^ " || l.type === "@ ") {
      const { vault, workspace } = this.app;
      const leaf = workspace.getLeaf(false);
      const line2 = l.line;
      const ch2 = l.ch;
      Promise.resolve().then(() => {
        return leaf.openFile(vault.getAbstractFileByPath(l.path), { active: true });
      }).then(() => {
        const markdownView = app.workspace.getActiveViewOfType(import_obsidian25.MarkdownView);
        const editor = markdownView == null ? void 0 : markdownView.editor;
        const value = markdownView == null ? void 0 : markdownView.getViewData();
        if (markdownView == null || editor == null || value == null) {
          const errorReason = `editor not exist. Aborting...`;
          return Promise.reject(errorReason);
        }
        editor.setCursor({ line: line2, ch: ch2 });
        const ch22 = editor.getLine(line2).length;
        if (ch2 != 0) {
          editor.setSelection({ line: line2, ch: 0 }, { line: line2, ch: ch22 });
        }
        editor.scrollIntoView({ from: { line: line2, ch: ch2 }, to: { line: line2, ch: ch2 } }, true);
        return Promise.resolve();
      }).catch((reason) => {
        new import_obsidian25.Notice(reason);
      });
      return;
    }
    if (l.type === "w " || l.type === "j ") {
      window.open(l.path, "_blank");
      return;
    }
    const line = l.line;
    const ch = l.ch;
    this.editor.setCursor({ line, ch });
    this.editor.scrollIntoView({ from: { line, ch }, to: { line, ch } }, true);
    return;
  }
};

// selfutil/getChildLink.ts
function getChildlinkItems(app2, file) {
  const backlinks = app2.metadataCache.getBacklinksForFile(file);
  const backlinksData = backlinks == null ? void 0 : backlinks.data;
  if (!backlinksData) {
    return [];
  }
  let childLinkResult = [];
  for (let i in backlinksData) {
    for (let j = 0; j < backlinksData[i].length; j++) {
      const index = backlinksData[i].length > 1 ? "[" + j + "]" : "";
      if (i != file.path) {
        const key = backlinksData[i][j]["key"];
        if (key) {
          childLinkResult.push({ path: i, type: "v ", index, heading: "", line: 0, ch: 0 });
        }
      }
    }
  }
  return childLinkResult;
}

// navigateRewritableThreadsModal.ts
var import_obsidian26 = require("obsidian");
var import_moment = __toESM(require_moment());
var NavigateRewritableThreadsModal = class extends import_obsidian26.FuzzySuggestModal {
  constructor(app2) {
    super(app2);
    this.tagToFind = "#c/t/p";
    this.setPlaceholder(`Which published notes do you want to rewrite?`);
    this.setInstructions([
      {
        command: "",
        purpose: `Which published notes do you want to rewrite?`
      }
    ]);
  }
  getItems() {
    const filePaths = filesWhereTagIsUsed(this.tagToFind);
    return filePaths.filter((f) => {
      const time = f.replace(/.*(\d\d\d\d\d\d\d\d).*/, "$1");
      if (/\d\d\d\d\d\d\d\d/.test(time)) {
        const oldDate = (0, import_moment.default)(time, "YYYYMMDD");
        const today = (0, import_moment.default)();
        const diff = today.diff(oldDate, "days");
        return diff > 90;
      }
      return false;
    }).map((f) => {
      return { notePath: f, header: "", startLine: 0, noteType: getNoteType(f) };
    });
  }
  getItemText(path) {
    return path.notePath + path.header;
  }
  // Renders each suggestion item.
  renderSuggestion(path, el) {
    const item = path.item;
    const pathItem = item.notePath;
    let prefix = item.noteType ? item.noteType.prefix ? item.noteType.prefix + " " : "" : "";
    el.createEl("div", { text: prefix + pathItem });
    if (path.item.header.length > 0) {
      el.createEl("small", { text: item.header });
    }
  }
  // Perform action on the selected suggestion.
  onChooseItem(path, evt) {
    const { vault, workspace } = this.app;
    const leaf = workspace.getLeaf(false);
    Promise.resolve().then(() => {
      return leaf.openFile(vault.getAbstractFileByPath(path.notePath), { active: true });
    }).then(() => {
      const markdownView = app.workspace.getActiveViewOfType(import_obsidian26.MarkdownView);
      const editor = markdownView == null ? void 0 : markdownView.editor;
      if (markdownView == null || editor == null) {
        const errorReason = `editor or value ${path.notePath} not exist. Aborting...`;
        return Promise.reject(errorReason);
      }
      editor.setCursor({ line: path.startLine, ch: 0 });
      editor.scrollIntoView({ from: { line: path.startLine, ch: 0 }, to: { line: path.startLine, ch: 0 } }, true);
    });
  }
};

// rewriteThreads.ts
var import_obsidian27 = require("obsidian");
var import_moment2 = __toESM(require_moment());
var ALL_TYPES6 = [
  {
    type: "find",
    description: "Find Threads to rewrite"
  },
  {
    type: "rewrite",
    description: "Rewrite Threads"
  }
];
var RewriteThreadsModal = class extends import_obsidian27.FuzzySuggestModal {
  constructor(app2, editor, view) {
    super(app2);
    this.editor = editor;
    this.view = view;
    this.setPlaceholder(`Find or Rewrite?`);
  }
  getItems() {
    return ALL_TYPES6;
  }
  getItemText(noteType) {
    return noteType.type;
  }
  // Renders each suggestion item.
  renderSuggestion(choosenNoteTypeMatch, el) {
    const noteType = choosenNoteTypeMatch.item;
    el.createEl("div", { text: noteType.type });
    el.createEl("small", { text: noteType.description });
  }
  containsType(line) {
    return ALL_TYPES6.filter((noteType) => line.contains(noteType.type)).length > 0;
  }
  // Perform action on the selected suggestion.
  async onChooseItem(choosenOperation, evt) {
    if (choosenOperation.type === "find") {
      new NavigateRewritableThreadsModal(this.app).open();
      return;
    }
    if (choosenOperation.type === "rewrite") {
      const { vault } = this.app;
      let v = "---\ntags: c/t/d\n---\n\n\u{1F9F5} \n\n\n---\n\n## References\n\n- \n\n";
      const path = this.view.file.path;
      const file = this.view.file;
      const editor = this.editor;
      if (!path.match(/.\/Threads \d\d\d\d\d\d\d\d/)) {
        new import_obsidian27.Notice(`Will not proceed. It is not a threads post.`);
        return;
      }
      const todayYYYYMMDD = (0, import_moment2.default)().format("YYYYMMDD");
      const newPath = path.replace(/^(.\/Threads) \d\d\d\d\d\d\d\d (.*)/, "$1 " + todayYYYYMMDD + " $2");
      const newNoteName = newPath.replace(/^.\//, "").replace(/.md$/, "");
      const { workspace } = this.app;
      const leaf = workspace.getLeaf(false);
      Promise.resolve().then(() => {
        return vault.adapter.exists(newPath);
      }).then((fileExists) => {
        if (fileExists) {
          new import_obsidian27.Notice(`Will not proceed. Rewritten Thread post post already exist.`);
          return Promise.reject("Threads post already exist");
        }
      }).then(function() {
        const beforeTag = "c/t/p";
        const afterTag = "c/t/o";
        return renameTag(file, beforeTag, afterTag);
      }, function(error) {
        new import_obsidian27.Notice(`error when rename tag!`);
      }).then((renameSuccess) => {
        if (!renameSuccess) {
          new import_obsidian27.Notice(`Will not proceed. The old post not published (not c/t/p).`);
          return Promise.reject("Will not proceed. The old post not published (not c/t/p).");
        }
        const value = editor.getValue();
        let modifiedValue;
        if (/---\n\n## [Rr]eference[s]*[:]*\n\n/m.test(value)) {
          modifiedValue = value.replace(/(## [Rr]eference[s]*[:]*\n\n)/m, "$1- Rewrite: [[" + newNoteName + "]]\n");
        } else if (/---[\n\s]*$/.test(value)) {
          modifiedValue = value + "\n\n## References\n\n- Rewrite: [[" + newNoteName + "]]\n";
        } else {
          modifiedValue = value + "\n---\n\n## References\n\n- Rewrite: [[" + newNoteName + "]]\n";
        }
        editor.setValue(modifiedValue);
        return vault.create(newPath, v);
      }).then((tFile) => {
        return leaf.openFile(tFile, { active: true });
      }, (reason) => {
      }).then(() => {
        new import_obsidian27.Notice(`Created and opened Threads notes for rewrite!`);
      });
      return;
    }
  }
};

// notesTypeView.ts
var import_obsidian28 = require("obsidian");
var VIEW_TYPE_NOTE_LIST = "note-list-view";
var NotesTypeView = class extends import_obsidian28.ItemView {
  constructor(leaf, notesTypeTag) {
    super(leaf);
    this.redraw = async () => {
      this.containerEl.empty();
      if (this.notesTypeTag.length <= 0) {
        return;
      }
      this.containerEl.createDiv({ cls: "nav-header", text: "Tags: " + this.notesTypeTag });
      const rootEl = this.containerEl.createDiv({ cls: "nav-folder mod-root scrollable" });
      const childrenEl = rootEl.createDiv({ cls: "nav-folder-children" });
      const length = this.notesTypeTag.split(" ").length;
      const tag1 = this.notesTypeTag.split(" ")[0];
      const tag2 = length > 1 ? this.notesTypeTag.split(" ")[1] : "";
      const files = filesWhereTagIsUsed(tag1).map((filePath) => this.app.vault.getAbstractFileByPath(filePath));
      let noteDatas = await Promise.all(files.map(async (f) => {
        let noteType = getNoteType(f.path);
        let prefix = noteType ? noteType.prefix + " " : "";
        const isActionTag = !/^#[a-z]\/[a-z]\/[a-z]$/.test(tag1) && !/^#[a-z]\/[a-z]$/.test(tag1) && !/^#[a-z]$/.test(tag1) || tag2.length > 0;
        let lineInfo = [];
        if (isActionTag) {
          const actionTag = tag2.length > 0 ? tag2 : tag1;
          const fileCache = this.app.metadataCache.getFileCache(f);
          if (fileCache && fileCache.tags) {
            const content = await this.app.vault.read(f);
            const fileLines = content.split("\n");
            for (const tag3 of fileCache.tags) {
              if (tag3.tag === actionTag) {
                const heading2 = this.getHeadingForLine(fileCache, tag3.position.start.line);
                const lineContent = fileLines[tag3.position.start.line].trim();
                const newLineIfNeeded = heading2.length != 0 ? this.isWindows() ? "\r\n" : "\n" : "";
                lineInfo.push({
                  content: heading2 + newLineIfNeeded + lineContent,
                  line: tag3.position.start.line
                });
              }
            }
          }
        }
        if (tag2.length > 0) {
          if (lineInfo.length > 0) {
            return {
              title: prefix + f.basename,
              lineInfo,
              file: f
            };
          } else {
            return {
              title: "invalid",
              lineInfo: [],
              file: null
            };
          }
        }
        return {
          title: prefix + f.basename,
          lineInfo,
          file: f
        };
      }));
      noteDatas.forEach((data) => {
        if (data.file == null) {
          return;
        }
        const navFile = childrenEl.createDiv({
          cls: "tree-item nav-file recent-files-file"
        });
        const navFileTitle = navFile.createDiv({
          cls: "tree-item-self is-clickable nav-file-title recent-files-title"
        });
        const navFileTitleContent = navFileTitle.createDiv({
          cls: "tree-item-inner nav-file-title-content recent-files-title-content internal-link self-wrap-content"
        });
        navFileTitleContent.setText(data.title);
        navFileTitle.addEventListener("mouseover", (event) => {
          var _a;
          if (!((_a = data.file) == null ? void 0 : _a.path))
            return;
          this.app.workspace.trigger("hover-link", {
            event,
            source: VIEW_TYPE_NOTE_LIST,
            hoverParent: rootEl,
            targetEl: navFile,
            linktext: data.file.path
          });
        });
        navFileTitle.addEventListener("contextmenu", (event) => {
          var _a, _b;
          if (!((_a = data.file) == null ? void 0 : _a.path))
            return;
          const menu = new import_obsidian28.Menu();
          menu.addItem(
            (item) => item.setSection("action").setTitle("Open in new tab").setIcon("file-plus").onClick(() => {
              this.focusFileAtLine(data.file, "tab", 0);
            })
          );
          const file = this.app.vault.getAbstractFileByPath((_b = data.file) == null ? void 0 : _b.path);
          this.app.workspace.trigger(
            "file-menu",
            menu,
            file,
            "link-context-menu"
          );
          menu.showAtPosition({ x: event.clientX, y: event.clientY });
        });
        navFileTitle.addEventListener("click", (event) => {
          if (!data)
            return;
          const newLeaf = import_obsidian28.Keymap.isModEvent(event);
          this.focusFileAtLine(data.file, newLeaf, 0);
        });
        for (const lineInfo of data.lineInfo) {
          const navFileLine = navFile.createDiv({
            //cls: 'tree-item nav-file recent-files-file',
            cls: "tree-item-self is-clickable nav-file-title recent-files-title"
          });
          const navFileLineContent = navFileLine.createDiv({
            cls: "tree-item-inner nav-file-title-content recent-files-title-content internal-link self-wrap-content self-padding-left-10"
          });
          navFileLineContent.innerText = lineInfo.content;
          navFileLine.addEventListener("mouseover", (event) => {
            var _a;
            if (!((_a = data.file) == null ? void 0 : _a.path))
              return;
            this.app.workspace.trigger("hover-link", {
              event,
              source: VIEW_TYPE_NOTE_LIST,
              hoverParent: rootEl,
              targetEl: navFileLine,
              linktext: data.file.path
            });
          });
          navFileLine.addEventListener("contextmenu", (event) => {
            var _a, _b;
            if (!((_a = data.file) == null ? void 0 : _a.path))
              return;
            const menu = new import_obsidian28.Menu();
            menu.addItem(
              (item) => item.setSection("action").setTitle("Open in new tab").setIcon("file-plus").onClick(() => {
                this.focusFileAtLine(data.file, "tab", lineInfo.line);
              })
            );
            const file = this.app.vault.getAbstractFileByPath((_b = data.file) == null ? void 0 : _b.path);
            this.app.workspace.trigger(
              "file-menu",
              menu,
              file,
              "link-context-menu"
            );
            menu.showAtPosition({ x: event.clientX, y: event.clientY });
          });
          navFileLine.addEventListener("click", (event) => {
            if (!data)
              return;
            const newLeaf = import_obsidian28.Keymap.isModEvent(event);
            this.focusFileAtLine(data.file, newLeaf, lineInfo.line);
          });
        }
      });
    };
    this.focusFileAtLine = (file, newLeaf, line) => {
      const targetFile = this.app.vault.getFiles().find((f) => f.path === file.path);
      if (targetFile) {
        const leaf = this.app.workspace.getLeaf(newLeaf);
        leaf.openFile(targetFile).then(() => {
          const view = this.app.workspace.getActiveViewOfType(import_obsidian28.MarkdownView);
          if (view) {
            view.editor.setCursor({ line, ch: 0 });
            view.editor.scrollIntoView({ from: { line, ch: 0 }, to: { line, ch: 0 } }, true);
            if (line != 0) {
              const ch = view.editor.getLine(line).length;
              view.editor.setSelection({ line, ch: 0 }, { line, ch });
            }
          }
        });
      } else {
        new import_obsidian28.Notice("Cannot find a file with that name");
      }
    };
    this.notesTypeTag = notesTypeTag;
  }
  getViewType() {
    return VIEW_TYPE_NOTE_LIST;
  }
  getDisplayText() {
    return "Tagged Notes";
  }
  async onOpen() {
    this.redraw();
  }
  getIcon() {
    return "hash";
  }
  isWindows() {
    return !import_obsidian28.Platform.isAndroidApp && !import_obsidian28.Platform.isIosApp && !import_obsidian28.Platform.isMacOS && !import_obsidian28.Platform.isSafari;
  }
  async onClose() {
  }
  getHeadingForLine(fileCache, lineNumber) {
    if (!fileCache || !fileCache.headings) {
      return "";
    }
    const headings = fileCache.headings;
    let currentHeading = "";
    for (const heading2 of headings) {
      if (heading2.position.start.line <= lineNumber) {
        currentHeading = "# " + heading2.heading;
      } else {
        break;
      }
    }
    return currentHeading;
  }
};

// main.ts
var DEFAULT_SETTINGS = {
  mySetting: "default"
};
var clipboardHistory = [];
var MyPlugin = class extends import_obsidian29.Plugin {
  constructor() {
    super(...arguments);
    this.notesTypeTag = "";
    this.plugin = this;
    this.lastActiveLeaf = null;
  }
  async activateNoteListView() {
    let leaf;
    [leaf] = this.app.workspace.getLeavesOfType(
      VIEW_TYPE_NOTE_LIST
    );
    if (!leaf) {
      leaf = this.app.workspace.getLeftLeaf(false);
      await (leaf == null ? void 0 : leaf.setViewState({ type: VIEW_TYPE_NOTE_LIST }));
    }
    if (leaf) {
      this.app.workspace.revealLeaf(leaf);
    }
  }
  async onload() {
    await this.loadSettings();
    this.registerView(
      VIEW_TYPE_NOTE_LIST,
      (leaf) => this.notesTypeView = new NotesTypeView(leaf, this.notesTypeTag)
    );
    this.addRibbonIcon("hash", "Open Note List View", () => {
      this.activateNoteListView();
    });
    this.app.workspace.onLayoutReady(() => {
      this.app.metadataCache.on("changed", async (file) => {
        if (this.notesTypeView) {
          this.notesTypeView.redraw();
        }
      });
    });
    if (navigator.clipboard) {
      document.addEventListener("copy", (event) => {
        var _a;
        const copiedText = (_a = event.clipboardData) == null ? void 0 : _a.getData("text/plain");
        if (copiedText != null) {
          this.addToClipboardHistory(copiedText);
        }
      });
      document.addEventListener("cut", (event) => {
        var _a;
        const copiedText = (_a = event.clipboardData) == null ? void 0 : _a.getData("text/plain");
        if (copiedText != null) {
          this.addToClipboardHistory(copiedText);
        }
      });
    } else {
      console.log("Clipboard API is not supported in this browser.");
    }
    ["n", "l", "w", "d", "a", "1", "2", "3", "4", "5", "6", "7"].forEach((t) => {
      this.addActionIcon(t);
      this.addActionCommand(t);
    });
    ["t", "m", "e"].forEach((t) => {
      this.addActionIcon(t);
      this.addFollowUpCommand(t);
    });
    ["n", "w"].forEach((t) => {
      this.addNewLaterActionIcon(t);
      this.addNewLaterAction(t);
    });
    this.addCommand({
      id: "obsidian-remove-clipboard-content",
      name: "RC Obsidian Remove Clipboard Content",
      icon: "obsidian-remove-clipboard-content",
      editorCallback: (editor, view) => {
        new ClipboardRemovalModal(this.app, editor, clipboardHistory).open();
      }
    });
    this.addObsidianIcon("auto-correct", "AC");
    this.addCommand({
      id: "auto-correct",
      name: "Auto Correct AC",
      icon: "auto-correct",
      editorCallback: (editor, view) => {
        const value = editor.getValue();
        let modifiedValue = value.split("\n").map((line) => {
          var l2 = line.replace(/10/g, "\u5341\u5206").replace(//g, "\u88E1").replace(//g, "\u5927\u8166");
          if (/[[\u4E00-\u9FFF]]/.test(l2)) {
            l2 = l2.replace(/ *, */g, "\uFF0C").replace(/ *\? */g, "\uFF1F").replace(/ *: */g, "\uFF1A").replace(/ *; */g, "\uFF1B").replace(/ *! */g, "\uFF01");
          }
          return l2;
        }).join("\n");
        modifiedValue = modifiedValue.replace(/([a-zA-Z0-9])([\u4E00-\u9FFF])/g, "$1 $2").replace(/([\u4E00-\u9FFF])([a-zA-Z0-9])/g, "$1 $2");
        editor.setValue(modifiedValue);
      }
    });
    this.addObsidianIcon("find-broken-link", "BL");
    this.addCommand({
      id: "find-broken-link",
      name: "Find Broken Link BL",
      icon: "find-broken-link",
      editorCallback: (editor, view) => {
        if (view.file.path !== "I/Broken Link.md") {
          const cursor = editor.getCursor();
          const line = cursor.line;
          const lineContent = editor.getLine(line);
          if (/\[\[.*[:?\/\\<>].*\]\]/.test(lineContent)) {
            new import_obsidian29.Notice("Trying to fix broken line in current line: " + lineContent);
            editor.setLine(
              line,
              lineContent.replace(/:/g, "_").replace(/\?/g, "_").replace(/\//g, "_").replace(/\\/g, "_").replace(/</g, "_").replace(/>/g, "_").replace(/^(parent\d+)_ /, "$1: ").replace(/^(title\d+)_ /, "$1: ")
            );
          } else {
            const unresolvedLinks2 = this.app.metadataCache.unresolvedLinks;
            const brokenLinkRecord = unresolvedLinks2[view.file.path];
            if (brokenLinkRecord == null) {
              new import_obsidian29.Notice("No broken link found in this file");
              return;
            }
            const brokenLinks = Object.keys(brokenLinkRecord);
            if (brokenLinks == null || brokenLinks.length == 0) {
              new import_obsidian29.Notice("No broken link found in this file");
              return;
            }
            for (let i = line + 1; i < editor.lineCount(); i++) {
              const lineContent2 = editor.getLine(i);
              for (let b = 0; b < brokenLinks.length; b++) {
                const brokenLink = brokenLinks[b];
                if (lineContent2.contains("[[" + brokenLink + "]]")) {
                  editor.setCursor({ line: i, ch: 0 });
                  editor.scrollIntoView({ from: { line: i, ch: 0 }, to: { line: i, ch: 0 } }, true);
                  new import_obsidian29.Notice("Navigated to next Broken link starting from cursor");
                  return;
                }
              }
            }
            new import_obsidian29.Notice("No broken link found after cursor line in this file");
          }
          return;
        }
        let count = 0;
        let result = "";
        const unresolvedLinks = this.app.metadataCache.unresolvedLinks;
        for (const [key, value] of Object.entries(unresolvedLinks)) {
          let v = "";
          for (const [k1, v1] of Object.entries(value)) {
            v += k1 + ":" + v1 + ", ";
          }
          v = v.replace(/, $/, "");
          if (v !== "") {
            result += "- [[" + key.replace(/\.md$/, "") + "]]";
            result += "\n";
            for (const [k2, v2] of Object.entries(value)) {
              result += "	- " + k2.replace(/\.md$/, "");
              result += "\n";
            }
            count++;
          }
        }
        editor.setValue(result);
        new import_obsidian29.Notice("Updated broken link. count=" + count);
      },
      hotkeys: [
        {
          modifiers: [`Ctrl`, `Meta`, `Shift`],
          key: `5`
        },
        {
          modifiers: [`Ctrl`, `Alt`, `Shift`],
          key: `5`
        }
      ]
    });
    this.addCommand({
      id: "previous-unfinished-action",
      name: "PA Previous unfinished action",
      icon: "chevrons-up",
      editorCallback: (editor, view) => {
        const cursor = editor.getCursor();
        const line = cursor.line;
        const lineContent = editor.getLine(line);
        for (let i = line - 1; i >= 0; i--) {
          const lineContent2 = editor.getLine(i);
          if (/ #[nw][nlw]/.test(lineContent2) || /#[nw][nlw] /.test(lineContent2) || / #t[tme]/.test(lineContent2) || /#t[tme] /.test(lineContent2)) {
            editor.setCursor({ line: i, ch: 0 });
            editor.scrollIntoView({ from: { line: i, ch: 0 }, to: { line: i, ch: 0 } }, true);
            new import_obsidian29.Notice("Navigated to previous unfinished action starting from cursor");
            return;
          }
        }
        new import_obsidian29.Notice("No unfinished action found after cursor line in this file");
      },
      hotkeys: [
        {
          modifiers: [`Ctrl`, `Meta`, `Shift`],
          key: `k`
        },
        {
          modifiers: [`Ctrl`, `Alt`, `Shift`],
          key: `k`
        }
      ]
    });
    this.addCommand({
      id: "next-unfinished-action",
      name: "NA Next unfinished action",
      icon: "chevrons-down",
      editorCallback: (editor, view) => {
        const cursor = editor.getCursor();
        const line = cursor.line;
        const lineContent = editor.getLine(line);
        for (let i = line + 1; i < editor.lineCount(); i++) {
          const lineContent2 = editor.getLine(i);
          if (/ #[nw][nlw]/.test(lineContent2) || /#[nw][nlw] /.test(lineContent2) || / #t[tme]/.test(lineContent2) || /#t[tme] /.test(lineContent2)) {
            editor.setCursor({ line: i, ch: 0 });
            editor.scrollIntoView({ from: { line: i, ch: 0 }, to: { line: i, ch: 0 } }, true);
            new import_obsidian29.Notice("Navigated to next unfinished action starting from cursor");
            return;
          }
        }
        new import_obsidian29.Notice("No unfinished action found after cursor line in this file");
      },
      hotkeys: [
        {
          modifiers: [`Ctrl`, `Meta`, `Shift`],
          key: `j`
        },
        {
          modifiers: [`Ctrl`, `Alt`, `Shift`],
          key: `j`
        }
      ]
    });
    this.addCommand({
      id: "open-tag-search",
      name: "Open tag search",
      icon: "hash",
      callback: () => {
        const searchPlugin = this.app.internalPlugins.getPluginById("global-search");
        const search = searchPlugin && searchPlugin.instance;
        if (searchPlugin && searchPlugin.instance) {
          new TagSearchModal(this.app, search, this.plugin).open();
        } else {
          new import_obsidian29.Notice("Please enable the search core plugin!");
        }
      },
      hotkeys: [
        {
          modifiers: [`Ctrl`, `Meta`, `Shift`],
          key: `s`
        },
        {
          modifiers: [`Ctrl`, `Alt`, `Shift`],
          key: `s`
        }
      ]
    });
    this.addCommand({
      id: "open-tag-search",
      name: "Open tag search",
      icon: "hash",
      callback: () => {
        const searchPlugin = this.app.internalPlugins.getPluginById("global-search");
        const search = searchPlugin && searchPlugin.instance;
        if (searchPlugin && searchPlugin.instance) {
          new TagSearchModal(this.app, search, this.plugin).open();
        } else {
          new import_obsidian29.Notice("Please enable the search core plugin!");
        }
      },
      hotkeys: [
        {
          modifiers: [`Ctrl`, `Meta`, `Shift`],
          key: `s`
        },
        {
          modifiers: [`Ctrl`, `Alt`, `Shift`],
          key: `s`
        }
      ]
    });
    this.addCommand({
      id: "query-orphan-notes-by-tag",
      name: "Query orphan notes by tag",
      editorCallback: (editor, view) => {
        new QueryOrphanNotesByTagModal(this.app, editor, view).open();
      }
    });
    this.addObsidianIcon("obsidian-paste", "\u2318V");
    this.addCommand({
      id: "obsidian-paste",
      name: "Obsidian Paste",
      icon: "obsidian-paste",
      editorCallback: (editor, view) => {
        new ClipboardPasteModal(this.app, editor, clipboardHistory).open();
      },
      hotkeys: [
        {
          modifiers: [`Meta`, `Shift`],
          key: `v`
        }
      ]
    });
    this.addObsidianIcon("update-note-type-icon", "NT");
    this.addCommand({
      id: "update-note-type",
      name: "Update Note Type",
      icon: `update-note-type-icon`,
      editorCallback: (editor, view) => {
        new UpdateNoteTypeModal(this.app, editor, view.file).open();
      },
      hotkeys: [
        {
          modifiers: [`Ctrl`, `Meta`, `Shift`],
          key: `c`
        },
        {
          modifiers: [`Ctrl`, `Alt`, `Shift`],
          key: `c`
        }
      ]
    });
    this.addCommand({
      id: "open-recent-days-schedule-with-updated-schedule",
      name: "OR Open Recent Days Updated Schedule",
      icon: "open-recent-day-schedule-icon",
      callback: async () => {
        const { vault } = this.app;
        const scheduleNoteWithoutMd = "D/Scheduling";
        const scheduleNote = `${scheduleNoteWithoutMd}.md`;
        if (vault.getAbstractFileByPath(scheduleNote) == null) {
          await vault.create(scheduleNote, "");
        }
        let noteContent = "";
        Array.from(Array(7).keys()).forEach((i) => noteContent += this.getQueryDateString(i, scheduleNoteWithoutMd));
        vault.modify(vault.getAbstractFileByPath(scheduleNote), noteContent);
        this.addActionNoteContent(vault, "D", "Query W now actions", "Weekly Schedule W", "w");
        this.addActionNoteContent(vault, "D", "Query N now actions", "Weekly Schedule N", "n");
        this.add3DaysActionNoteContent(vault);
        new import_obsidian29.Notice("Updated schedule");
        const { workspace } = this.app;
        const dashboardCanvas = "D/Query Schedule and Actions next 3 days.md";
        const mode = this.app.vault.getConfig("defaultViewMode");
        const leaf = workspace.getLeaf(false);
        await leaf.openFile(vault.getAbstractFileByPath(dashboardCanvas), {
          active: true
          /* mode */
        });
      }
    });
    this.addObsidianIcon("update-scheduling-icon", "US");
    this.addCommand({
      id: "update-scheduling",
      name: "Update Scheduling",
      icon: "update-scheduling-icon",
      callback: async () => {
        const { vault } = this.app;
        const scheduleNoteWithoutMd = "D/Scheduling";
        const scheduleNote = `${scheduleNoteWithoutMd}.md`;
        if (vault.getAbstractFileByPath(scheduleNote) == null) {
          await vault.create(scheduleNote, "");
        }
        let noteContent = "";
        Array.from(Array(7).keys()).forEach((i) => noteContent += this.getQueryDateString(i, scheduleNoteWithoutMd));
        vault.modify(vault.getAbstractFileByPath(scheduleNote), noteContent);
        this.addActionNoteContent(vault, "D", "Query W now actions", "Weekly Schedule W", "w");
        this.addActionNoteContent(vault, "D", "Query N now actions", "Weekly Schedule N", "n");
        this.add3DaysActionNoteContent(vault);
        new import_obsidian29.Notice("Updated schedule");
      }
      /*,
      hotkeys: [
      	{
      		modifiers: [`Ctrl`, `Meta`, `Shift`],
      		key: `u`,
      	},
      	{
      		modifiers: [`Ctrl`, `Alt`, `Shift`],
      		key: `u`,
      	},
      ]*/
    });
    this.addObsidianIcon("open-recent-day-schedule-icon", "OR");
    this.addCommand({
      id: "open-recent-days-schedule",
      name: "Open Recent Days Schedule",
      icon: "open-recent-day-schedule-icon",
      callback: async () => {
        const { vault, workspace } = this.app;
        const dashboardCanvas = "D/Query Schedule and Actions next 3 days.md";
        const leaf = workspace.getLeaf(false);
        await leaf.openFile(vault.getAbstractFileByPath(dashboardCanvas), { active: true });
      }
    });
    this.addObsidianIcon("open-inbox-icon", "OI");
    this.addCommand({
      id: "open-inbox",
      name: "OI Open Inbox",
      icon: "open-inbox-icon",
      callback: async () => {
        const { vault, workspace } = this.app;
        const inboxMd = "I/Inbox.md";
        const leaf = workspace.getLeaf(false);
        await leaf.openFile(vault.getAbstractFileByPath(inboxMd), { active: true });
        const view = this.app.workspace.getActiveViewOfType(import_obsidian29.MarkdownView);
        if (view) {
          const editor = view.editor;
          const line = editor.lastLine();
          const ch = editor.getLine(line).length;
          editor.setCursor({ line, ch });
          editor.scrollIntoView({ from: { line, ch: 0 }, to: { line, ch: 0 } }, true);
        }
      }
    });
    this.addObsidianIcon("open-playground-icon", "OP");
    this.addCommand({
      id: "open-playground",
      name: "OP Open Playground",
      icon: "open-playground-icon",
      callback: async () => {
        new OpenPlaygroundModal(this.app).open();
      },
      hotkeys: [
        {
          modifiers: [`Ctrl`, `Meta`, `Shift`],
          key: `p`
        },
        {
          modifiers: [`Ctrl`, `Alt`, `Shift`],
          key: `p`
        }
      ]
    });
    this.addObsidianIcon("open-braindump-icon", "OB");
    this.addCommand({
      id: "open-braindump",
      name: "OB Open BrainDump",
      icon: "open-braindump-icon",
      callback: async () => {
        const { vault, workspace } = this.app;
        const inboxMd = "I/Brain Dump.md";
        const leaf = workspace.getLeaf(false);
        await leaf.openFile(vault.getAbstractFileByPath(inboxMd), { active: true });
      }
    });
    this.addCommand({
      id: "open-notice",
      name: "Open Notice",
      callback: () => {
        new import_obsidian29.Notice("Test Test", 0);
      }
    });
    this.addObsidianIcon("format-all-notes-custom", "FA");
    this.addCommand({
      id: "format-all-notes-custom",
      name: "FA Format All Notes (Custom usage)",
      icon: `format-all-notes-custom`,
      callback: async () => {
        const vault = this.app.vault;
        let startCount = 0;
        let finishedCount = 0;
        const files = vault.getMarkdownFiles();
        new import_obsidian29.Notice("all=" + files.length);
        console.log("all=" + files.length);
        for (const file of files) {
          console.log("s: " + startCount);
          vault.read(file).then((content) => {
            const modifiedValue = tidyUpFrontMatterOnValue(content);
            return vault.modify(file, modifiedValue);
          }).then(() => {
            console.log("f: " + finishedCount);
            finishedCount++;
            if (finishedCount == files.length) {
              console.log("finished");
              new import_obsidian29.Notice("finished");
            }
          });
          startCount++;
        }
      },
      hotkeys: [
        {
          modifiers: [`Ctrl`, `Meta`, `Shift`],
          key: `1`
        },
        {
          modifiers: [`Ctrl`, `Alt`, `Shift`],
          key: `1`
        }
      ]
    });
    this.addObsidianIcon("tw-fix-broken-link", ":_");
    this.addCommand({
      id: "tw-fix-broken-link",
      name: "BL Fix TW Broken Link",
      icon: `tw-fix-broken-link`,
      editorCallback: (editor, view) => {
        const cursor = editor.getCursor();
        const line = cursor.line;
        const lineContent = editor.getLine(line);
        editor.setLine(
          line,
          lineContent.replace(/:/g, "_").replace(/\?/g, "_").replace(/\//g, "_").replace(/</g, "_").replace(/>/g, "_").replace(/^(parent\d+)_ /, "$1: ").replace(/^(title\d+)_ /, "$1: ")
        );
      }
      /*,
      hotkeys: [
      	{
      		modifiers: [`Ctrl`, `Meta`, `Shift`],
      		key: `5`,
      	},
      	{
      		modifiers: [`Ctrl`, `Alt`, `Shift`],
      		key: `5`,
      	},
      ]*/
    });
    this.addObsidianIcon("format-notes-custom", "FN");
    this.addCommand({
      id: "format-notes-custom",
      name: "FN Format Notes (Custom usage)",
      icon: `format-notes-custom`,
      editorCallback: (editor, view) => {
        tidyUpFrontMatteronEditor(editor);
      },
      hotkeys: [
        {
          modifiers: [`Ctrl`, `Meta`, `Shift`],
          key: `2`
        },
        {
          modifiers: [`Ctrl`, `Alt`, `Shift`],
          key: `2`
        }
      ]
    });
    this.addObsidianIcon("tw-get-parent-link", "[]");
    this.addCommand({
      id: "tw-get-parent-link",
      name: "tw-get-parent-link",
      icon: `tw-get-parent-link`,
      editorCallback: (editor, view) => {
        const cursor = editor.getCursor();
        const line = cursor.line;
        const ch = cursor.ch;
        const lineContent = editor.getLine(line);
        if (/^parent\d+: /.test(lineContent) || /^\t+- parent\d+: /.test(lineContent)) {
          const parentLink = lineContent.replace(/^parent\d+: /, "").replace(/^\t+- parent\d+: /, "").replace(/"/g, "").replace(/\[\[/, "").replace(/\]\]/, "");
          navigator.clipboard.writeText(parentLink).then(() => {
            if (line == 0) {
              editor.setValue("");
            } else {
              const previousLine = editor.getLine(line - 1);
              editor.replaceRange("", { line: line - 1, ch: previousLine.length }, { line, ch: lineContent.length });
            }
            editor.setValue(editor.getValue().replace(/^---\n+---\n/, "---\ntags: b/n/c\n---\n").replace(/\n$/, ""));
            editor.setCursor({ line, ch: ch > editor.getLine(line).length ? editor.getLine(line).length : ch });
            new import_obsidian29.Notice("Copied to clipboard: " + parentLink);
          });
        }
      },
      hotkeys: [
        {
          modifiers: [`Ctrl`, `Meta`, `Shift`],
          key: `y`
        },
        {
          modifiers: [`Ctrl`, `Alt`, `Shift`],
          key: `y`
        }
      ]
    });
    this.addObsidianIcon("tw-tidy-list-note", "==");
    this.addCommand({
      id: "tw-tidy-list-note",
      name: "TL == TW Tidy List Note",
      icon: `tw-tidy-list-note`,
      editorCallback: (editor, view) => {
        editor.setValue(replaceTWUselessValue(editor.getValue()));
        const lineCount = editor.lineCount();
        let fm = "";
        let c = "";
        let text = "";
        let h3Count = 0;
        let content = "";
        let taskTag = "";
        for (let i = 0; i < lineCount; i++) {
          const line = editor.getLine(i);
          if (h3Count == 0) {
            if (line.length != 0 && !/^\t*- ```$/.test(line)) {
              const modifiedLine = line.contains("[[") && line.contains("]]") ? line : line.replace(view.file.basename + " _ ", "").replace(/(\t*- )#+ > /, "$1").replace(/(\t+- )#+ /, "$1");
              content += modifiedLine + "\n";
            }
          } else if (h3Count == 1) {
            if (line.startsWith("title: ") || line.startsWith("list: ")) {
              fm += line + "\n";
            } else if (line.length != 0 && !/^\t*- ```$/.test(line)) {
              const modifiedLine = line.contains("[[") && line.contains("]]") ? line : line.replace(view.file.basename + " _ ", "").replace(/(\t*- )#+ > /, "$1").replace(/(\t+- )#+ /, "$1");
              fm += modifiedLine + "\n";
            }
          }
          if (h3Count >= 2) {
            if (line.length != 0 && !/^\t*- ```$/.test(line)) {
              const modifiedLine = line.contains("[[") && line.contains("]]") ? line : line.replace(view.file.basename + " _ ", "").replace(/(\t*- )#+ > /, "$1").replace(/(\t+- )#+ /, "$1");
              c += modifiedLine + "\n";
            }
          }
          if (line === "---") {
            h3Count++;
            if (h3Count == 2) {
              fm += "\n";
            }
          }
        }
        text += content;
        if (fm.length > 0) {
          text += fm;
        }
        text += c;
        text = text.replace(/^---\n+---\n/m, "---\ntags: b/n/c\n---\n").replace(/\n$/, "");
        editor.setValue(text);
        new import_obsidian29.Notice("Formatted tidy list note");
      },
      hotkeys: [
        {
          modifiers: [`Ctrl`, `Meta`, `Shift`],
          key: `6`
        },
        {
          modifiers: [`Ctrl`, `Alt`, `Shift`],
          key: `6`
        }
      ]
    });
    this.addObsidianIcon("tw-task", "--");
    this.addCommand({
      id: "tw-task",
      name: "TT -- TW Task",
      icon: `tw-task`,
      editorCallback: (editor, view) => {
        if (getChildlinkItems(this.app, view.file).length > 0) {
          new import_obsidian29.Notice("Still have child link. Please check the child link first. Abort...");
          new NavigateToForwardAndBacklinkTagModal(this.app, view, editor).open();
          return;
        }
        editor.setValue(replaceTWUselessValue(editor.getValue()));
        const lineCount = editor.lineCount();
        let fm = "";
        let c = "";
        let text = "";
        let h3Count = 0;
        let content = "";
        let taskTag = "";
        for (let i = 0; i < lineCount; i++) {
          const line = editor.getLine(i);
          if (h3Count == 0) {
            content += line + "\n";
          } else if (h3Count == 1) {
            if (line.startsWith("title: ")) {
            } else if (line.startsWith("tagsss: ")) {
              taskTag = "a/";
              if (/ N /.test(line) || / N$/.test(line)) {
                taskTag += "n/";
              }
              if (/ W /.test(line) || / W$/.test(line)) {
                taskTag += "w/";
              }
              if (/ now /.test(line) || / now$/.test(line)) {
                taskTag += "n";
              }
              if (/ later /.test(line) || / later$/.test(line)) {
                taskTag += "l";
              }
              if (/ waiting /.test(line) || / waiting$/.test(line)) {
                taskTag += "w";
              }
              if (/ done /.test(line) || / done$/.test(line)) {
                taskTag += "d";
              }
              if (/ archive /.test(line) || / archine$/.test(line)) {
                taskTag += "a";
              }
              if (taskTag.length == 5) {
                fm += "tags: " + taskTag + "\n";
              } else {
                new import_obsidian29.Notice("error on setting action tag");
                fm += line + "\n";
              }
            } else {
              fm += line + "\n";
            }
          }
          if (h3Count >= 2) {
            let modifiedLine = line;
            c += modifiedLine + "\n";
          }
          if (line === "---") {
            h3Count++;
          }
        }
        text += content;
        if (fm.length > 0) {
          text += fm;
        }
        text += c;
        text = text.replace(/^---\n+---\n/m, "---\ntags: b/n/s\n---\n").replace(/\n$/, "");
        editor.setValue(text);
        editor.setCursor({ line: getParentLine(text), ch: 0 });
        app.vault.rename(view.file, "C/" + view.file.name);
        new import_obsidian29.Notice("Formatted for adding link to parent note");
      },
      hotkeys: [
        {
          modifiers: [`Ctrl`, `Meta`, `Shift`],
          key: `7`
        },
        {
          modifiers: [`Ctrl`, `Alt`, `Shift`],
          key: `7`
        }
      ]
    });
    this.addObsidianIcon("note-to-tree-list", "**");
    this.addCommand({
      id: "note-to-tree-list",
      name: "NT Note to Tree List",
      icon: `note-to-tree-list`,
      editorCallback: (editor, view) => {
        if (getChildlinkItems(this.app, view.file).length > 0) {
          new import_obsidian29.Notice("Still have child link. Please check the child link first. Abort...");
          new NavigateToForwardAndBacklinkTagModal(this.app, view, editor).open();
          return;
        }
        const checkboxMap = /* @__PURE__ */ new Map();
        const lineCount = editor.lineCount();
        if (editor.getValue().startsWith("- " + view.file.basename + "\n")) {
          const filename = view.file.basename;
          let text = "";
          for (let i = 0; i < lineCount; i++) {
            const line = editor.getLine(i);
            if (line.trim().length != 0) {
              if (!/^\t*- $/.test(line) && !/^\t*\d+\. $/.test(line)) {
                let modLine = line;
                if (!modLine.contains("[[") && !modLine.contains("]]")) {
                  modLine = line.replace(`${filename} _ `, "");
                }
                if (line !== `- ${view.file.basename}` && /^- /.test(line)) {
                  modLine = "	" + modLine;
                }
                text += modLine + "\n";
              }
            }
          }
          text = text.replace(/\n$/m, "");
          editor.setValue(text);
          editor.setCursor({ line: getParentLine(text), ch: 0 });
          new import_obsidian29.Notice("Formatted to remove empyt line and removed duplicated list name");
        } else {
          editor.setValue(replaceTWUselessValue(editor.getValue()));
          let text = "- ";
          let h3Count = 0;
          let actionTag = "";
          let content = "";
          for (let i = 0; i < lineCount; i++) {
            const line = editor.getLine(i);
            if (h3Count == 0) {
              if (line.trim().length != 0 && line != "---") {
                let modifiedLine = line;
                for (let i2 = 0; i2 < 9; i2++) {
                  modifiedLine = modifiedLine.replace(/^    /, "	");
                }
                modifiedLine = modifiedLine.replace(/^(\t*)\*\s/, "$1- ");
                modifiedLine = /^\t*- /.test(modifiedLine) || /^\t*\d+\. /.test(modifiedLine) ? "	" + modifiedLine : "	- " + modifiedLine;
                content += "\n" + modifiedLine;
              }
            } else if (h3Count == 1) {
              if (line === "---" || shouldSkipFrontMatter(line) || line.startsWith("title: ")) {
              } else if (line.startsWith("tagsss: ")) {
                if (/ N /.test(line) || / N$/.test(line)) {
                  actionTag = "n";
                }
                if (/ W /.test(line) || / W$/.test(line)) {
                  actionTag = "w";
                }
                if (/ now /.test(line) || / now$/.test(line)) {
                  actionTag += "n";
                }
                if (/ later /.test(line) || / later$/.test(line)) {
                  actionTag += "l";
                }
                if (/ waiting /.test(line) || / waiting$/.test(line)) {
                  actionTag += "w";
                }
                if (/ done /.test(line) || / done$/.test(line)) {
                  actionTag += "d";
                }
                if (/ archive /.test(line) || / archine$/.test(line)) {
                  actionTag += "w";
                }
                if (actionTag.length == 2) {
                  actionTag = "#" + actionTag + " ";
                } else if (actionTag.length == 1) {
                  new import_obsidian29.Notice("error on setting action tag");
                }
              } else if (line.startsWith("checkboxbytime_")) {
                const keyValueArray = line.split(":").map((item) => item.trim());
                if (keyValueArray.length === 2) {
                  const key = keyValueArray[0];
                  const value = keyValueArray[1];
                  const splitArray = key.split("_");
                  const modifiedKey = `<<checkboxByTime "${splitArray[1]}">>`;
                  checkboxMap.set(modifiedKey, value === "open" ? "[x]" : "[ ]");
                }
              } else {
                if (line.trim().length != 0) {
                  let modifiedLine = line;
                  for (let i2 = 0; i2 < 9; i2++) {
                    modifiedLine = modifiedLine.replace(/^    /, "	");
                  }
                  modifiedLine = modifiedLine.replace(/^(\t*)\*\s/, "$1- ");
                  modifiedLine = /^\t*- /.test(modifiedLine) || /^\t*\d+\. /.test(modifiedLine) ? "	" + modifiedLine : "	- " + modifiedLine;
                  content += "\n" + modifiedLine;
                }
              }
            }
            if (h3Count >= 2 && line.trim().length != 0) {
              let modifiedLine = line === "[ ] " ? "" : line;
              if (modifiedLine.trim().length != 0) {
                for (let i2 = 0; i2 < 9; i2++) {
                  modifiedLine = modifiedLine.replace(/^    /, "	");
                }
                modifiedLine = modifiedLine.replace(/^(\t*)\*\s/, "$1- ");
                modifiedLine = /^\t*- /.test(modifiedLine) || /^\t*\d+\. /.test(modifiedLine) ? "	" + modifiedLine : "	- " + modifiedLine;
                for (const [key, value] of checkboxMap) {
                  modifiedLine = modifiedLine.replace(new RegExp(key, "g"), value);
                }
                modifiedLine = modifiedLine.replace(/<<checkboxByTime "[A-Za-z0-9_]+">>/g, "[ ]");
                text += "\n" + modifiedLine;
              }
            }
            if (line === "---") {
              let beforeH3 = h3Count;
              h3Count++;
              if (beforeH3 == 1 && h3Count == 2) {
                text += actionTag + view.file.basename;
              }
            }
          }
          if (h3Count < 2) {
            text += view.file.basename;
          }
          text += content;
          editor.setValue(text);
          editor.setCursor({ line: getParentLine(text), ch: 0 });
          new import_obsidian29.Notice("Formatted for merging link to parent note");
        }
      },
      hotkeys: [
        {
          modifiers: [`Ctrl`, `Meta`, `Shift`],
          key: `8`
        },
        {
          modifiers: [`Ctrl`, `Alt`, `Shift`],
          key: `8`
        }
      ]
    });
    this.addCommand({
      id: "remove-content-from-cursor",
      name: "Remove content from cursor",
      icon: `axe`,
      editorCallback: (editor, view) => {
        new RemoveContentFromCursorModal(this.app, editor).open();
      },
      hotkeys: [
        {
          modifiers: [`Ctrl`, `Meta`, `Shift`],
          key: `x`
        },
        {
          modifiers: [`Ctrl`, `Alt`, `Shift`],
          key: `x`
        }
      ]
    });
    this.addCommand({
      id: "remove-content-left",
      name: "Remove content left same line",
      icon: `arrow-left-circle`,
      editorCallback: (editor, view) => {
        removeContentLeftSameLine(editor);
      }
    });
    this.addCommand({
      id: "remove-content-right",
      name: "Remove content right same line",
      icon: `arrow-right-circle`,
      editorCallback: (editor, view) => {
        removeContentLeftSameLine(editor);
      }
    });
    this.addCommand({
      id: "remove-content-top-left",
      name: "Remove content from start of note to cursor",
      icon: `arrow-up-circle`,
      editorCallback: (editor, view) => {
        removeContentFromStartOfNoteToCursor(editor);
      }
    });
    this.addCommand({
      id: "remove-content-bottom-right",
      name: "Remove content from cursor to end of note",
      icon: `arrow-down-circle`,
      editorCallback: (editor, view) => {
        removeContentFromCursorToEndOfNote(editor);
      }
    });
    this.addObsidianIcon("threads-to-blog-icon", "TB");
    this.addCommand({
      id: "threads-to-blog",
      name: "TB Threads as pre Blog format to Clipboard",
      icon: `threads-to-blog-icon`,
      editorCallback: (editor, view) => {
        new ThreadsToBlogModal(this.app, editor, view).open();
      }
    });
    this.addObsidianIcon("card-to-threads-icon", "CT");
    this.addCommand({
      id: "card-to-threads",
      name: "CT Card to Threads",
      icon: `card-to-threads-icon`,
      editorCallback: (editor, view) => {
        let text = "";
        text += "---\ntags: c/t/d\n---\n\n";
        text += "\u{1F9F5} " + view.file.basename + "\n\n---\n\n\n\n---\n\n";
        text += "## References\n\n- ";
        text += "[[" + view.file.basename + "]]\n";
        text += `
- \u4E00\u500B\u6A19\u984C\uFF08\u4E3B\u984C\u662F\u4EC0\u9EBC\u3001\u6587\u7AE0\u5BEB\u7D66\u8AB0\u770B\u3001\u770B\u5B8C\u5F8C\u53EF\u4EE5\u7372\u5F97\u4EC0\u9EBC\u597D\u8655\uFF09
	- 
- \u4E00\u500B\u60C5\u666F\uFF08\u4EBA\u6642\u5730\uFF09
	- 
- \u4E00\u500B\u554F\u984C
	- 
- \u4E00\u500B\u539F\u56E0 / \u6211\u6703\u5982\u4F55\u89E3\u6C7A
	- 
- \u4E8C\u500B\u9762\u5411\uFF08\u5C0D\u6BD4 / \u6BD4\u8F03\uFF09
	- 
	- 
- \u4E09\u500B\u6B65\u9A5F / \u505A\u6CD5
	1. 
	2. 
	3. 
- \u4E00\u500B\u884C\u52D5
	- 

`;
        const { vault } = this.app;
        const path = view.file.path;
        const newPath = path.replace(/^([A-Z]\/)/, "$1Threads ");
        console.log("newPath=" + newPath);
        const { workspace } = this.app;
        const leaf = workspace.getLeaf(false);
        Promise.resolve().then(() => {
          return vault.adapter.exists(newPath);
        }).then((fileExists) => {
          if (fileExists) {
            new import_obsidian29.Notice(`Will not proceed. Thread post "${newPath}" already exist.`);
            return Promise.reject("Thread post exist");
          }
          return vault.create(newPath, text);
        }).then(
          (tFile) => {
            return leaf.openFile(tFile, { active: true });
          },
          (rejectReason) => {
          }
        );
      }
    });
    this.addObsidianIcon("add-comment-tag-icon", "CT");
    this.addCommand({
      id: "add-comment-tag",
      name: "CT Add Comment Tag",
      icon: `add-comment-tag-icon`,
      editorCallback: (editor, view) => {
        new AddFootnoteTagModal(this.app, editor).open();
      },
      hotkeys: [
        {
          modifiers: [`Ctrl`, `Meta`, `Shift`],
          key: `z`
        },
        {
          modifiers: [`Ctrl`, `Alt`, `Shift`],
          key: `z`
        }
      ]
    });
    this.addObsidianIcon("action-tag-count-icon", "CA");
    this.addCommand({
      id: "action-tag-count-icon",
      name: "CA Count Action Tag",
      icon: `action-tag-count-icon`,
      editorCallback: (editor, view) => {
        const tags = ["nn", "nl", "nw", "n1", "n2", "n3", "n4", "n5", "n6", "n7", "wn", "wl", "ww", "w1", "w2", "w3", "w4", "w5", "w6", "w7"];
        const matches = [];
        const lineNum = editor.lineCount();
        for (let i = 0; i < lineNum; i++) {
          const line = editor.getLine(i);
          const match = tags.some((tag2) => new RegExp(`#${tag2} `, "g").test(line) || new RegExp(` #${tag2}`, "g").test(line));
          if (match) {
            matches.push(`Line ${i}:
${line.trim()}`);
          }
        }
        const trimmedAndJoinedString = matches.join("\n\n");
        const tasks = matches.length > 0 ? `
Tasks:

${trimmedAndJoinedString}` : ``;
        new import_obsidian29.Notice(`There are ${matches.length} outstanding actions in this notes${tasks}`);
      }
    });
    this.addObsidianIcon("toggle-n-w-task", "#=");
    this.addCommand({
      id: `toggle-n-w-task`,
      name: `Toggle N W Task`,
      icon: `toggle-n-w-task`,
      editorCallback: (editor, view) => {
        console.log(editor.getSelection());
        const cursor = editor.getCursor();
        const lineNumber = editor.getCursor().line;
        const line = editor.getLine(lineNumber);
        if (line.match(/ a\/w\/./)) {
          const replacedLine = line.replace(/ a\/w\/(.)/, ` a/n/$1`);
          editor.setLine(lineNumber, replacedLine);
          editor.setCursor(cursor);
        } else if (line.match(/ a\/n\/./)) {
          const replacedLine = line.replace(/ a\/n\/(.)/, ` a/w/$1`);
          editor.setLine(lineNumber, replacedLine);
          editor.setCursor(cursor);
        } else if (line.match(/#w. /)) {
          const replacedLine = line.replace(/#w(.) /, `#n$1 `);
          editor.setLine(lineNumber, replacedLine);
          editor.setCursor(cursor);
        } else if (line.match(/#n. /)) {
          const replacedLine = line.replace(/#n(.) /, `#w$1 `);
          editor.setLine(lineNumber, replacedLine);
          editor.setCursor(cursor);
        } else if (line.match(/ #w./)) {
          const replacedLine = line.replace(/ #w(.)/, ` #n$1`);
          editor.setLine(lineNumber, replacedLine);
          editor.setCursor(cursor);
        } else if (line.match(/ #n./)) {
          const replacedLine = line.replace(/ #n(.)/, ` #w$1`);
          editor.setLine(lineNumber, replacedLine);
          editor.setCursor(cursor);
        }
      },
      hotkeys: [
        {
          modifiers: [`Ctrl`, `Meta`, `Shift`],
          key: `=`
        },
        {
          modifiers: [`Ctrl`, `Alt`, `Shift`],
          key: `=`
        }
      ]
    });
    this.addCommand({
      id: "cursor-go-to-start-of-line",
      name: "Cursor go to start of line",
      icon: `arrow-big-left`,
      editorCallback: (editor, view) => {
        const cursor = editor.getCursor();
        cursor.ch = 0;
        editor.setCursor(cursor);
      }
    });
    this.addCommand({
      id: "cursor-go-to-end-of-line",
      name: "Cursor go to end of line",
      icon: `arrow-big-right`,
      editorCallback: (editor, view) => {
        const cursor = editor.getCursor();
        const lineNum = cursor.line;
        const line = editor.getLine(lineNum);
        const length = line.length;
        cursor.ch = length;
        editor.setCursor(cursor);
      }
    });
    this.addCommand({
      id: "duplicate-line-below",
      name: "Duplicate line below",
      icon: `align-vertical-space-between`,
      editorCallback: (editor, view) => {
        const cursor = editor.getCursor();
        const lineNum = cursor.line;
        let text = "";
        for (let i = 0; i < editor.lineCount(); i++) {
          const line = editor.getLine(i);
          text += line + "\n";
          if (i === lineNum) {
            text += line + "\n";
          }
        }
        text = text.replace(/\n$/, "");
        editor.setValue(text);
        cursor.line = lineNum + 1;
        editor.setCursor(cursor);
      }
    });
    this.addObsidianIcon("event-to-fantastical-icon", "FE");
    this.addCommand({
      id: "add-fantastical-event",
      name: "FE Add Fantastical Event",
      icon: `event-to-fantastical-icon`,
      editorCallback: (editor, view) => {
        let text = "";
        const vault = this.app.vault;
        const listSelections = editor.listSelections();
        const processLine = async (line, i) => {
          if (/^- \d\d\d\d-\d\d-\d\d \d\d:\d\d /.test(line)) {
            const modifiedLine = line.replace(/^- /, `- #tm `);
            editor.setLine(i, modifiedLine);
            text += line + "\n";
            const lineToAdd = "-" + line.replace(/-/g, "");
            const path = line.replace(/^- (\d\d\d\d)-(\d\d)-.*/, "J/$1-M$2.md");
            let tFile = vault.getAbstractFileByPath(path);
            if (tFile == null) {
              tFile = await vault.create(path, "---\ntags: b/n/j\n---\n\n" + lineToAdd);
            } else {
              const tFileOriginalValue = await vault.read(tFile);
              await vault.modify(tFile, tFileOriginalValue + "\n" + lineToAdd);
            }
          }
        };
        const processSelections = async () => {
          for (const listSelection of listSelections) {
            const a = listSelection.head.line;
            const b = listSelection.anchor.line;
            const fromLineNum = b > a ? a : b;
            const toLineNum = b > a ? b : a;
            for (let i = fromLineNum; i <= toLineNum; i++) {
              const line = editor.getLine(i);
              await processLine(line, i);
            }
          }
        };
        processSelections().then(() => {
          if (text.length !== 0) {
            text = encodeURI(text);
            window.open(`shortcuts://run-shortcut?name=Add%20Obsidian%20Inbox%20Event%20via%20Fantastical&input=text&text=${text}&x-success=obsidian://&x-cancel=obsidian://&x-error=obsidian://`);
          }
        });
      }
    });
    this.addObsidianIcon("action-to-fantastical-event-icon", "AF");
    this.addCommand({
      id: "action-to-fantastical-event",
      name: "AF Action to Fantastical Event",
      icon: `action-to-fantastical-event-icon`,
      editorCallback: (editor, view) => {
        let text = "";
        const vault = this.app.vault;
        const listSelections = editor.listSelections();
        for (const listSelection of listSelections) {
          const a = listSelection.head.line;
          const b = listSelection.anchor.line;
          const fromLineNum = b > a ? a : b;
          const toLineNum = b > a ? b : a;
          for (let i = fromLineNum; i <= toLineNum; i++) {
            const line = editor.getLine(i);
            text += line.trim() + "@@@";
          }
          text = text.replace(/@@@$/, "");
        }
        const vaultName = app.vault.getName();
        const filePath = view.file.path;
        const url = `obsidian://open?vault=${encodeURIComponent(vaultName)}&file=${encodeURIComponent(filePath)}`;
        const encodedUrl = encodeURIComponent(url);
        const input = `{"tasks":"${text}","obsidianURL":"${encodedUrl}"}`;
        const shortcutUrl = `shortcuts://run-shortcut?name=${encodeURIComponent("Obsidian Action To Fantastical Push event")}&input=text&text=${encodeURIComponent(input)}&x-success=obsidian://&x-cancel=obsidian://&x-error=obsidian://`;
        window.open(shortcutUrl);
      },
      hotkeys: [
        {
          modifiers: [`Ctrl`, `Meta`, `Shift`],
          key: `F`
        },
        {
          modifiers: [`Ctrl`, `Alt`, `Shift`],
          key: `F`
        }
      ]
    });
    this.addCommand({
      id: "grep-title-as-link-to-clipboard",
      name: "Grep Title as link to clipboard",
      icon: `clipboard-list`,
      editorCallback: async (editor, view) => {
        const title = view.file.basename;
        const titleAsLink = `[[${title}]]`;
        try {
          this.addToClipboardHistory(titleAsLink);
          await navigator.clipboard.writeText(titleAsLink);
          new import_obsidian29.Notice(`Copied title "${title}" as link to clipboard!`);
        } catch (error) {
          new import_obsidian29.Notice(`Error occurred when copying to clipboard: ${error}`);
        }
      },
      hotkeys: [
        {
          modifiers: [`Meta`, `Shift`],
          key: `l`
        },
        {
          modifiers: [`Ctrl`, `Shift`],
          key: `l`
        }
      ]
    });
    this.addObsidianIcon("move-current-selection-to-beginning-of-notes", "<<");
    this.addCommand({
      id: "move-current-selection-to-beginning-of-notes",
      name: "MB << Move current selection to beginning of notes",
      icon: `move-current-selection-to-beginning-of-notes`,
      editorCallback: (editor, view) => {
        let selection = exportCurrentSelection(editor);
        if (/^    +- /m.test(selection) || /^- /m.test(selection) || /^# /m.test(selection) || /^` /m.test(selection) || /^> /m.test(selection) || /^\d+\. /m.test(selection)) {
        } else {
          selection = "- " + selection;
        }
        let newContent = "";
        const selectionRange = getCurrentSelectionLineNumber(editor);
        for (let i = 0; i < editor.lineCount(); i++) {
          if (i < selectionRange.fromLineNum || i > selectionRange.toLineNum) {
            newContent = newContent + editor.getLine(i) + "\n";
          }
        }
        new AddTextToNotesModal(this.app, selection, "move the selected text", true, () => editor.setValue(newContent.replace(/\n$/m, ""))).open();
      },
      hotkeys: [
        {
          modifiers: [`Ctrl`, `Meta`, `Shift`],
          key: `,`
        },
        {
          modifiers: [`Ctrl`, `Alt`, `Shift`],
          key: `,`
        }
      ]
    });
    this.addObsidianIcon("move-current-selection-to-end-of-notes", ">>");
    this.addCommand({
      id: "move-current-selection-to-end-of-notes",
      name: "ME >> Move current selection to beginning of notes",
      icon: `move-current-selection-to-end-of-notes`,
      editorCallback: (editor, view) => {
        let selection = exportCurrentSelection(editor);
        if (/^    +- /m.test(selection) || /^- /m.test(selection) || /^# /m.test(selection) || /^` /m.test(selection) || /^> /m.test(selection) || /^\d+\. /m.test(selection)) {
        } else {
          selection = "- " + selection;
        }
        let newContent = "";
        const selectionRange = getCurrentSelectionLineNumber(editor);
        for (let i = 0; i < editor.lineCount(); i++) {
          if (i < selectionRange.fromLineNum || i > selectionRange.toLineNum) {
            newContent = newContent + editor.getLine(i) + "\n";
          }
        }
        new AddTextToNotesModal(this.app, selection, "move the selected text", false, () => editor.setValue(newContent.replace(/\n$/m, ""))).open();
      },
      hotkeys: [
        {
          modifiers: [`Ctrl`, `Meta`, `Shift`],
          key: `.`
        },
        {
          modifiers: [`Ctrl`, `Alt`, `Shift`],
          key: `.`
        }
      ]
    });
    this.addObsidianIcon("add-current-selection-to-beginning-of-notes", "((");
    this.addCommand({
      id: "add-current-selection-to-beginning-of-notes",
      name: "SB (( Add current selection to beginning of notes",
      icon: `add-current-selection-to-beginning-of-notes`,
      editorCallback: (editor, view) => {
        let selection = exportCurrentSelection(editor);
        if (/^    +- /m.test(selection) || /^- /m.test(selection) || /^# /m.test(selection) || /^` /m.test(selection) || /^> /m.test(selection) || /^\d+\. /m.test(selection)) {
        } else {
          selection = "- " + selection;
        }
        new AddTextToNotesModal(this.app, selection, "add the selected text", true, () => {
        }).open();
      },
      hotkeys: [
        {
          modifiers: [`Ctrl`, `Meta`, `Shift`],
          key: `9`
        },
        {
          modifiers: [`Ctrl`, `Alt`, `Shift`],
          key: `9`
        }
      ]
    });
    this.addObsidianIcon("add-current-selection-to-end-of-notes", "))");
    this.addCommand({
      id: "add-current-selection-to-end-of-notes",
      name: "SE )) Add current selection to end of notes",
      icon: `add-current-selection-to-end-of-notes`,
      editorCallback: (editor, view) => {
        let selection = exportCurrentSelection(editor);
        if (/^    +- /m.test(selection) || /^- /m.test(selection) || /^# /m.test(selection) || /^` /m.test(selection) || /^> /m.test(selection) || /^\d+\. /m.test(selection)) {
        } else {
          selection = "- " + selection;
        }
        new AddTextToNotesModal(this.app, selection, "add the selected text", false, () => {
        }).open();
      },
      hotkeys: [
        {
          modifiers: [`Ctrl`, `Meta`, `Shift`],
          key: `0`
        },
        {
          modifiers: [`Ctrl`, `Alt`, `Shift`],
          key: `0`
        }
      ]
    });
    this.addObsidianIcon("add-current-link-to-beginning-of-notes", "[[");
    this.addCommand({
      id: "add-current-link-to-beginning-of-notes",
      name: "LB [[ Add current link to beginning of notes",
      icon: `add-current-link-to-beginning-of-notes`,
      editorCallback: (editor, view) => {
        const link = "- [[" + view.file.basename + "]]";
        new AddTextToNotesModal(this.app, link, "add the current note link", true, () => {
        }).open();
      },
      hotkeys: [
        {
          modifiers: [`Ctrl`, `Meta`, `Shift`],
          key: `[`
        },
        {
          modifiers: [`Ctrl`, `Alt`, `Shift`],
          key: `[`
        }
      ]
    });
    this.addObsidianIcon("add-current-link-to-end-of-notes", "]]");
    this.addCommand({
      id: "add-current-link-to-end-of-notes",
      name: "LE ]] Add current link to end-of-notes",
      icon: `add-current-link-to-end-of-notes`,
      editorCallback: (editor, view) => {
        const link = "- [[" + view.file.basename + "]]";
        new AddTextToNotesModal(this.app, link, "add the current note link", false, () => {
        }).open();
      },
      hotkeys: [
        {
          modifiers: [`Ctrl`, `Meta`, `Shift`],
          key: `]`
        },
        {
          modifiers: [`Ctrl`, `Alt`, `Shift`],
          key: `]`
        }
      ]
    });
    this.addCommand({
      id: "navigate-to-forwardlinks-backlinks",
      name: "BL Navigate to Forwardlinks/Backlinks",
      icon: `link-2`,
      editorCallback: (editor, view) => {
        new NavigateToForwardAndBacklinkTagModal(this.app, view, editor).open();
      },
      hotkeys: [
        {
          modifiers: [`Ctrl`, `Meta`, `Shift`],
          key: `O`
        },
        {
          modifiers: [`Ctrl`, `Alt`, `Shift`],
          key: `O`
        }
      ]
    });
    this.addCommand({
      id: "quick-navigate-to-notes",
      name: "NN Quick Navigate to Notes",
      icon: `aperture`,
      callback: async () => {
        new NavigateToNoteFromTagModal(this.app).open();
      },
      hotkeys: [
        {
          modifiers: [`Ctrl`, `Meta`, `Shift`],
          key: `;`
        },
        {
          modifiers: [`Ctrl`, `Alt`, `Shift`],
          key: `;`
        }
      ]
    });
    this.addCommand({
      id: "query-notes-without-or-invalid-metadata",
      name: "Query Notes without or invalid metadata",
      editorCallback: async (editor, view) => {
        console.log(view.file.path);
        let resultValue = "## Notes without metadata\n\nHighlight meaning invalid metadata\n";
        const queryMd = "I/Self Query.md";
        if (view.file.path === queryMd) {
          new import_obsidian29.Notice("Need some time to generate result");
          const result = getAllNotesWithoutMetadata(this.app);
          let resultWithoutMetadata = [];
          let resultInvalidMetadata = [];
          for (const filePath of result) {
            const tFile = this.app.vault.getAbstractFileByPath(filePath);
            const content = await this.app.vault.read(tFile);
            if (content.startsWith("---")) {
              resultInvalidMetadata.push(tFile);
            } else {
              resultWithoutMetadata.push(tFile);
            }
          }
          for (const tFile of resultInvalidMetadata) {
            resultValue += "\n- ==[[" + tFile.basename + "]]==";
          }
          for (const tFile of resultWithoutMetadata) {
            resultValue += "\n- [[" + tFile.basename + "]]";
          }
          editor.setValue(resultValue);
          new import_obsidian29.Notice("Updated notes without metadata. Size=" + result.length);
        } else {
          new import_obsidian29.Notice("Please go to '" + queryMd + "' to run this action");
        }
      }
    });
    this.addObsidianIcon("threads-to-twitter", "TX");
    this.addCommand({
      id: "threads-to-twitter",
      name: "TT TX Threads to Twitter",
      icon: `threads-to-twitter`,
      editorCallback: (editor, view) => {
        const { vault } = this.app;
        let v = editor.getValue();
        v = v.replace(/---\n+## [Rr]eferences?\:([\n]*.*)*$/, "");
        v = v.replace(/---\n+## [Rr]eferences?([\n]*.*)*$/, "");
        const path = view.file.path;
        if (!path.match(/.\/Threads \d\d\d\d\d\d\d\d/)) {
          new import_obsidian29.Notice(`Will not proceed. It is not a threads post.`);
          return;
        }
        const newPath = path.replace(/(.\/)Threads /, "$1Twitter ");
        const { workspace } = this.app;
        const leaf = workspace.getLeaf(false);
        Promise.resolve().then(() => {
          return vault.adapter.exists(newPath);
        }).then((fileExists) => {
          if (fileExists) {
            new import_obsidian29.Notice(`Will not proceed. Twitter post already exist.`);
            return Promise.reject("Twitter post already exist");
          }
          const value = editor.getValue();
          let modifiedValue;
          if (/---\n\n## [Rr]eference[s]*[:]*\n\n/m.test(value)) {
            modifiedValue = value.replace(/(## [Rr]eference[s]*[:]*\n\n)/m, "$1- [[" + view.file.basename.replace(/Threads /, "Twitter ") + "]]\n");
          } else if (/---[\n\s]*$/.test(value)) {
            modifiedValue = value + "\n\n## References\n\n- [[" + view.file.basename.replace(/Threads /, "Twitter ") + "]]\n";
          } else {
            modifiedValue = value + "\n---\n\n## References\n\n- [[" + view.file.basename.replace(/Threads /, "Twitter ") + "]]\n";
          }
          editor.setValue(modifiedValue);
          return vault.create(newPath, v);
        }).then((tFile) => {
          return leaf.openFile(tFile, { active: true });
        }, (reason) => {
        }).then(() => {
          new import_obsidian29.Notice(`Created and opened Twitter notes!`);
        });
      }
    });
    this.addObsidianIcon("threads-rewrite-modal", "TR");
    this.addCommand({
      id: "threads-rewrite-modal",
      name: "TR Threads Rewrite Modal",
      icon: "threads-rewrite-modal",
      editorCallback: (editor, view) => {
        new RewriteThreadsModal(app, editor, view).open();
      }
    });
    this.addObsidianIcon("find-threads-to-rewrite", "FR");
    this.addCommand({
      id: "find-threads-to-rewrite",
      name: "FR Find Threads To Rewrite",
      icon: "hafind-threads-to-rewritesh",
      callback: () => {
        new NavigateRewritableThreadsModal(app).open();
      }
    });
    this.addObsidianIcon("rewrite-current-threads", "TR");
    this.addCommand({
      id: "rewrite-current-threads",
      name: "TR Rewrite Current Threads",
      icon: `rewrite-current-threads`,
      editorCallback: (editor, view) => {
        const { vault } = this.app;
        let v = "---\ntags: c/t/d\n---\n\n\u{1F9F5} \n\n\n---\n\n## References\n\n- \n\n";
        const path = view.file.path;
        if (!path.match(/.\/Threads \d\d\d\d\d\d\d\d/)) {
          new import_obsidian29.Notice(`Will not proceed. It is not a threads post.`);
          return;
        }
        const todayYYYYMMDD = (0, import_moment3.default)().format("YYYYMMDD");
        const newPath = path.replace(/^(.\/Threads) \d\d\d\d\d\d\d\d (.*)/, "$1 " + todayYYYYMMDD + " $2");
        const newNoteName = newPath.replace(/^.\//, "").replace(/.md$/, "");
        const { workspace } = this.app;
        const leaf = workspace.getLeaf(false);
        Promise.resolve().then(() => {
          return vault.adapter.exists(newPath);
        }).then((fileExists) => {
          if (fileExists) {
            new import_obsidian29.Notice(`Will not proceed. Rewritten Thread post post already exist.`);
            return Promise.reject("Threads post already exist");
          }
        }).then(function() {
          const beforeTag = "c/t/p";
          const afterTag = "c/t/o";
          return renameTag(view.file, beforeTag, afterTag);
        }, function(error) {
          new import_obsidian29.Notice(`error when rename tag!`);
        }).then((renameSuccess) => {
          if (!renameSuccess) {
            new import_obsidian29.Notice(`Will not proceed. The old post not published (not c/t/p).`);
            return Promise.reject("Will not proceed. The old post not published (not c/t/p).");
          }
          const value = editor.getValue();
          let modifiedValue;
          if (/---\n\n## [Rr]eference[s]*[:]*\n\n/m.test(value)) {
            modifiedValue = value.replace(/(## [Rr]eference[s]*[:]*\n\n)/m, "$1- Rewrite: [[" + newNoteName + "]]\n");
          } else if (/---[\n\s]*$/.test(value)) {
            modifiedValue = value + "\n\n## References\n\n- Rewrite: [[" + newNoteName + "]]\n";
          } else {
            modifiedValue = value + "\n---\n\n## References\n\n- Rewrite: [[" + newNoteName + "]]\n";
          }
          editor.setValue(modifiedValue);
          return vault.create(newPath, v);
        }).then((tFile) => {
          return leaf.openFile(tFile, { active: true });
        }, (reason) => {
        }).then(() => {
          new import_obsidian29.Notice(`Created and opened Threads notes for rewrite!`);
        });
      }
    });
    this.addObsidianIcon("blog-to-clipboard-icon", "BJ");
    this.addCommand({
      id: "blog-to-clipboard",
      name: "BJ Blog content to clipboard",
      icon: `blog-to-clipboard-icon`,
      editorCallback: async (editor, view) => {
        const v = editor.getValue();
        if (v.includes("#nn") || v.includes("#nl") || v.includes("#nw") || v.includes("#wn") || v.includes("#wl") || v.includes("#ww")) {
          new import_obsidian29.Notice(`Will not proceed. As there are unfinished action tag.`);
          return;
        }
        if (!v.includes("<!--more-->")) {
          try {
            await navigator.clipboard.writeText("<!--more-->");
            new import_obsidian29.Notice(`Require "<!--more-->" as excerpt separator before posting.
"<!--more-->" already in clipboard`);
          } catch (error) {
            new import_obsidian29.Notice(`Require "<!--more-->" as excerpt separator before posting.
"<!--more-->" cannot be copied to clipboard`);
          }
          return;
        }
        const path = view.file.path;
        let line = editor.lineCount();
        let text = "";
        let numLineFirstContent = 0;
        let frontMatterLineCount = 0;
        for (let i = 0; i < line; i++) {
          if (frontMatterLineCount == 2) {
            numLineFirstContent = i;
            break;
          }
          if (editor.getLine(i) == "---") {
            frontMatterLineCount++;
          }
        }
        for (let i = 0; i < line; i++) {
          if (editor.getLine(numLineFirstContent).trim() == "") {
            numLineFirstContent++;
          } else {
            break;
          }
        }
        Array.from(Array(line - numLineFirstContent).keys()).forEach((i) => {
          const line2 = editor.getLine(i + numLineFirstContent);
          text = text + line2 + "\n";
        });
        text = text.replace(/\n---\n\n#nd generate summary for meta description below:\n[^\n]*\n([^\n]*)\n[^\n]*\n---\n/, "\n<!-- Meta Summary -->\n<!--\n$1\n-->\n");
        text = text.replace(/## References?[\:]?([\n]*.*)*$/, "");
        const app2 = this.app;
        const beforeTagCBR = "c/b/r";
        const beforeTagCBD = "c/b/d";
        const beforeTagCBI = "c/b/i";
        const afterTag = "c/b/p";
        try {
          await navigator.clipboard.writeText(text);
          new import_obsidian29.Notice(`Copied blog content to clipboard!`);
          const foundTagFromCBR = await renameTag(view.file, beforeTagCBR, afterTag);
          if (foundTagFromCBR) {
            new import_obsidian29.Notice(`Update notes type from tag="${beforeTagCBR}" to tag="${afterTag}!`);
          }
          const foundTagFromCBI = await renameTag(view.file, beforeTagCBI, afterTag);
          if (foundTagFromCBI) {
            new import_obsidian29.Notice(`Update notes type from tag="${foundTagFromCBI}" to tag="${afterTag}!`);
          }
          const foundTagFromCBD = await renameTag(view.file, beforeTagCBD, afterTag);
          if (foundTagFromCBD) {
            new import_obsidian29.Notice(`Update notes type from tag="${beforeTagCBD}" to tag="${afterTag}!`);
          }
          await renameBlogTitle(app2, path, view);
          window.open(`shortcuts://run-shortcut?name=Jekyll%20blog&x-cancel=obsidian://&x-error=obsidian://`);
        } catch (error) {
          new import_obsidian29.Notice(`Error occurred during the operation: ${error}`);
        }
      }
    });
    this.addObsidianIcon("generate-chatgpt-prompt", "GP");
    this.addCommand({
      id: "generate-chatgpt-prompt",
      name: "GP Generate ChatGPT Prompt",
      icon: `generate-chatgpt-prompt`,
      editorCallback: async (editor, view) => {
        let text = "";
        const selection = editor.getSelection();
        if (selection.length == 0) {
          let line = editor.lineCount();
          text = "\u3010" + view.file.basename + "\u3011\n\n";
          let numLineFirstContent = 0;
          let frontMatterLineCount = 0;
          for (let i = 0; i < line; i++) {
            if (frontMatterLineCount == 2) {
              numLineFirstContent = i;
              break;
            }
            if (editor.getLine(i) == "---") {
              frontMatterLineCount++;
            }
          }
          for (let i = 0; i < line; i++) {
            if (editor.getLine(numLineFirstContent).trim() == "") {
              numLineFirstContent++;
            } else {
              break;
            }
          }
          Array.from(Array(line - numLineFirstContent).keys()).forEach((i) => {
            const line2 = editor.getLine(i + numLineFirstContent);
            if (!line2.startsWith("%%") && !line2.endsWith("%%")) {
              text = text + line2 + "\n";
            }
          });
          text = text.replace(/## References?[\:]?([\n]*.*)*$/, "");
        } else {
          text = selection;
        }
        navigator.clipboard.writeText(text).then(function() {
          new import_obsidian29.Notice(`Copied content to clipboard for generating prompt!`);
          window.open(`shortcuts://run-shortcut?name=Generate%20ChatGPT%20Prompt&x-success=Poe-app://&x-cancel=obsidian://&x-error=obsidian://`);
        }, function(error) {
          new import_obsidian29.Notice(`error when copy to clipboard!`);
        });
      }
    });
    this.addObsidianIcon("threads-to-gpt", "TC");
    this.addCommand({
      id: "threads-to-gpt",
      name: "TC Threads to ChatGPT Prompt",
      icon: `threads-to-gpt`,
      editorCallback: async (editor, view) => {
        let line = editor.lineCount();
        let text = "\u3010" + view.file.basename + "\u3011\n\n";
        let numLineFirstContent = 0;
        let frontMatterLineCount = 0;
        for (let i = 0; i < line; i++) {
          if (frontMatterLineCount == 2) {
            numLineFirstContent = i;
            break;
          }
          if (editor.getLine(i) == "---") {
            frontMatterLineCount++;
          }
        }
        for (let i = 0; i < line; i++) {
          if (editor.getLine(numLineFirstContent).trim() == "") {
            numLineFirstContent++;
          } else {
            break;
          }
        }
        Array.from(Array(line - numLineFirstContent).keys()).forEach((i) => {
          const line2 = editor.getLine(i + numLineFirstContent);
          if (!line2.startsWith("%%") && !line2.endsWith("%%")) {
            text = text + line2 + "\n";
          }
        });
        text = text.replace(/## References?[\:]?([\n]*.*)*$/, "");
        const beforeTag = "c/t/r";
        const afterTag = "c/t/t";
        navigator.clipboard.writeText(text).then(function() {
          return renameTag(view.file, beforeTag, afterTag);
        }, function(error) {
          new import_obsidian29.Notice(`error when copy to clipboard!`);
        }).then(function(a) {
          new import_obsidian29.Notice(`Copied content to clipboard for generating prompt!`);
          window.open(`shortcuts://run-shortcut?name=Generate%20ChatGPT%20Prompt&x-success=Poe-app://&x-cancel=obsidian://&x-error=obsidian://`);
        }, function(error) {
          new import_obsidian29.Notice(`error when copy to clipboard!`);
        });
      }
    });
    this.addObsidianIcon("threads-to-clipboard-icon", "TC");
    this.addCommand({
      id: "threads-to-clipboard",
      name: "TC Threads content to clipboard",
      icon: `threads-to-clipboard-icon`,
      editorCallback: (editor, view) => {
        const value = editor.getValue();
        const text = this.getThreadsSegment(editor);
        const beforeTag = "c/t/r";
        const afterTag = "c/t/t";
        navigator.clipboard.writeText(text).then(function() {
          return renameTag(view.file, beforeTag, afterTag);
        }, function(error) {
          new import_obsidian29.Notice(`error when copy to clipboard!`);
        }).then((foundTag) => {
          if (foundTag) {
            new import_obsidian29.Notice(`Update notes type from tag="${beforeTag}" to tag="${afterTag}!
Copied thread content
\`\`\`
${text}
\`\`\`
to clipboard!`);
          } else {
            new import_obsidian29.Notice(`Tag "${beforeTag}" not found
Copied thread content
\`\`\`
${text}
\`\`\`
to clipboard!`);
          }
        });
      }
    });
    this.addObsidianIcon("twitter-to-chatgpt", "XG");
    this.addCommand({
      id: "twitter-to-chatgpt",
      name: "XG Twitter to ChatGPT",
      icon: `twitter-to-chatgpt`,
      editorCallback: (editor, view) => {
        const value = editor.getValue();
        if (!view.file.basename.contains("Twitter")) {
          new import_obsidian29.Notice("Note name not contains 'Twitter', did not copy from thread note?");
          return;
        }
        const noteType = getNoteType(view.file.path);
        if (noteType != null && noteType.type.startsWith("c/x/")) {
          new import_obsidian29.Notice("Note type starts with c/x, will not proceed");
          return;
        }
        let content = this.convertThreadsContentToPOE(editor);
        let numTweet = Math.ceil(content.length / 110);
        let prompt = `\u60A8\u662F\u793E\u4EA4\u5A92\u9AD4\u5167\u5BB9\u64B0\u5BEB\u5E2B\u3002\u5C07\u4E0B\u5217\u5167\u5BB9\u8F49\u70BA\u4E0D\u8D85\u904E${numTweet}\u689D\u7684\u63A8\u7279\u4E32\uFF0C\u4EE5\u7E41\u9AD4\u4E2D\u6587\u5448\u73FE\u3002\u4FDD\u7559\u6A19\u984C\uFF0C\u4E26\u5C07\u6A19\u984C\u5408\u4F75\u5230\u7B2C\u4E00\u689D\u63A8\u6587\u4E2D\uFF0C\u6A19\u984C\u548C\u7B2C\u4E00\u689D\u63A8\u6587\u4E4B\u9593\u52A0\u5169\u500B\u63DB\u884C\u3002\u6BCF\u689D\u63A8\u6587\u8981\u8D85\u904E100\u5B57\u4F46\u4E0D\u8D85\u904E140\u5B57\u3002\u5167\u5BB9\u4E0D\u7C21\u5316\uFF0C\u4E0D\u65B0\u589E\u672A\u63D0\u53CA\u8CC7\u8A0A\u3002\u4FDD\u7559\u539F\u6587\u4F8B\u5B50\uFF0C\u4E0D\u52A0\u6A19\u7C64\u3002\u63A8\u6587\u4E2D\u4E0D\u52A0\u6578\u5B57\u3002\u6BCF\u689D\u63A8\u6587\u5F8C\u52A0\u5169\u500B\u63DB\u884C\u53CA\u4E09\u500B\u77ED\u5283\u7DDA\u548C\u53E6\u4E00\u500B\u63DB\u884C\u3002\u82F1\u6587\u548C\u4E2D\u6587\u4E4B\u9593\u52A0\u7A7A\u683C\u3002\u82E5\u539F\u6587\u6709\u7DB2\u5740\uFF0C\u4FDD\u7559\u7DB2\u5740\uFF0C\u4E0D\u7528Markdown\u683C\u5F0F\uFF0C\u4E26\u5728\u7DB2\u5740\u524D\u52A0\u5169\u500B\u63DB\u884C\u3002`;
        prompt = prompt + "\n\n" + content;
        prompt = prompt.replace(//g, "");
        prompt = prompt.replace(/\n+https\:\/\/github.com[^\n]+\n/m, "\u3011\n");
        prompt = prompt.replace(/\*\*/gm, "");
        navigator.clipboard.writeText(prompt).then(function() {
          let line = editor.lineCount();
          let numLineFirstContent = 0;
          let frontMatterLineCount = 0;
          for (let i = 0; i < line; i++) {
            if (frontMatterLineCount == 2) {
              numLineFirstContent = i;
              break;
            }
            if (editor.getLine(i) == "---") {
              frontMatterLineCount++;
            }
          }
          for (let i = 0; i < line; i++) {
            if (editor.getLine(numLineFirstContent).trim() == "") {
              numLineFirstContent++;
            } else {
              break;
            }
          }
          let text = "";
          Array.from(Array(numLineFirstContent).keys()).forEach((i) => {
            const line2 = editor.getLine(i);
            text = text + line2 + "\n";
          });
          text = text.replace(/## References?[\:]?([\n]*.*)*$/, "");
          editor.setValue(text);
          const cursor = editor.getCursor();
          cursor.line = editor.lineCount() - 1;
          cursor.ch = 0;
          editor.setCursor(cursor);
          new import_obsidian29.Notice("copied to clipboard, please open chatgpt to paste");
          return renameTag(view.file, "c/t/d", "c/x/d");
        }, function(error) {
          new import_obsidian29.Notice(`error when copy to clipboard!`);
        }).then((a) => {
          renameTag(view.file, "c/t/r", "c/x/d");
        }).then((a) => {
          renameTag(view.file, "c/t/t", "c/x/d");
        }).then((a) => {
          renameTag(view.file, "c/t/p", "c/x/d");
        }).then((a) => {
          window.open(`Poe-app://`);
        });
      }
    });
    this.addObsidianIcon("chatgpt-to-twitter", "GX");
    this.addCommand({
      id: "chatgpt-to-twitter",
      name: "GX ChatGPT to Twitter",
      icon: `chatgpt-to-twitter`,
      editorCallback: (editor, view) => {
        if (!editor.getValue().contains("c/x/d")) {
          new import_obsidian29.Notice("Note type not c/x/d, do the action in wrong note?");
          return;
        }
        const isSuccess = this.convertChatGPTToTwitterFormat(editor);
        if (isSuccess) {
          renameTag(view.file, "c/x/d", "c/x/r");
        }
      }
    });
    this.addObsidianIcon("reverse-twitter-number-icon", "RT");
    this.addCommand({
      id: "reverse-twitter-numbering",
      name: "RT Reverse Twitter Numbering",
      icon: `reverse-twitter-number-icon`,
      editorCallback: (editor, view) => {
        if (!editor.getValue().contains("c/x/r") && !editor.getValue().contains("c/x/p")) {
          new import_obsidian29.Notice("Note type not c/x/r nor c/x/p, do the action in wrong note?");
          return;
        }
        this.reverseTwitterNumbering(editor);
        renameTag(view.file, "c/x/p", "c/x/d");
        renameTag(view.file, "c/x/r", "c/x/d");
      }
    });
    this.addObsidianIcon("threads-as-facebook-post-to-clipboard-icon", "FC");
    this.addCommand({
      id: "threads-as-facebook-post-to-clipboard",
      name: "FC Threads as Facebook post format to Clipboard",
      icon: `threads-as-facebook-post-to-clipboard-icon`,
      editorCallback: (editor, view) => {
        const value = editor.getValue();
        let text = this.convertThreadsContentToFormatForFacebookApp(editor);
        text = text.replace(/\n+## [Rr]eferences?\:([\n]*.*)*$/, "");
        text = text.replace(/\n+## [Rr]eferences?([\n]*.*)*$/, "");
        text = text.replace(/\n#+ /mg, "\n");
        const beforeTag = "c/t/t";
        const afterTag = "c/t/p";
        navigator.clipboard.writeText(text).then(function() {
          return renameTag(view.file, beforeTag, afterTag);
        }, function(error) {
          new import_obsidian29.Notice(`error when copy to clipboard!`);
        }).then((foundTag) => {
          if (foundTag) {
            new import_obsidian29.Notice(`Update notes type from tag="${beforeTag}" to tag="${afterTag}!
Copied fb content to clipboard!`);
          } else {
            new import_obsidian29.Notice(`Tag "${beforeTag}" not found
Copied fb content to clipboard!`);
          }
        });
      }
    });
    this.addObsidianIcon("threads-block-to-image", "TI");
    this.addCommand({
      id: "threads-block-to-image",
      name: "TI Threads segment to image",
      icon: `threads-block-to-image`,
      editorCallback: async (editor, view) => {
        const threadSegment = this.getThreadSegment(editor);
        const beforeTag = "c/t/d";
        const afterTag = "c/t/r";
        const result = await renameTag(view.file, beforeTag, afterTag);
        await renameThreadsTitle(app, view.file.path, view);
        console.log(result);
        new ThreadsToImagesModal(this.app, threadSegment).open();
      }
    });
    this.addObsidianIcon("chatgpt-generate-image", "GI");
    this.addCommand({
      id: "chatgpt-generate-image",
      name: "GI ChatGPT image",
      icon: `chatgpt-generate-image`,
      editorCallback: (editor, view) => {
        window.open("shortcuts://run-shortcut?name=ChatGPT%20Generate%20Image&x-success=obsidian://&x-cancel=obsidian://&x-error=obsidian://");
      }
    });
    this.addObsidianIcon("twitter-segment-to-clipboard", "XC");
    this.addCommand({
      id: "twitter-segment-to-clipboard",
      name: "XC Twitter segment to clipboard",
      icon: `twitter-segment-to-clipboard`,
      editorCallback: (editor, view) => {
        const threadSegment = this.getTwitterSegment(editor);
        const beforeTag = "c/x/r";
        const afterTag = "c/x/p";
        navigator.clipboard.writeText(threadSegment).then(function() {
          return renameTag(view.file, beforeTag, afterTag);
        }, function(error) {
          new import_obsidian29.Notice(`error when copy to clipboard!`);
        }).then((foundTag) => {
          if (foundTag) {
            new import_obsidian29.Notice(`Update notes type from tag="${beforeTag}" to tag="${afterTag}!
Copied
\`\`\`
${threadSegment}\`\`\`
to clipboard!`);
          } else {
            new import_obsidian29.Notice(`Tag "${beforeTag}" not found
Copied
\`\`\`
${threadSegment}\`\`\`
to clipboard!`);
          }
        });
      }
    });
    this.addObsidianIcon("segment-to-clipboard", "SC");
    this.addCommand({
      id: "segment-to-clipboard",
      name: "SC Segment to clipboard",
      icon: `segment-to-clipboard`,
      editorCallback: (editor, view) => {
        const threadSegment = this.getSegment(editor);
        this.addToClipboardHistory(threadSegment);
        navigator.clipboard.writeText(threadSegment).then(function() {
          new import_obsidian29.Notice(`Copied
\`\`\`
${threadSegment}\`\`\`
to clipboard!`);
        }, function(error) {
          new import_obsidian29.Notice(`error when copy to clipboard!`);
        });
      }
    });
    this.addCommand({
      id: "n-find-replace",
      name: "Find or Replace",
      icon: `file-search`,
      editorCallback: (editor, view) => {
        new FindReplaceModal(this.app).open();
      }
    });
    this.addCommand({
      id: "toggle-bullet-number-list",
      name: "Toggle Bullet Number List",
      icon: `bullet-list`,
      editorCallback: (editor, view) => {
        if (editor.getSelection().length > 0) {
          const listSelections = editor.listSelections();
          for (const listSelection of listSelections) {
            const a = listSelection.head.line;
            const b = listSelection.anchor.line;
            const fromLineNum = b > a ? a : b;
            const toLineNum = b > a ? b : a;
            for (let i = fromLineNum; i <= toLineNum; i++) {
              const line = editor.getLine(i);
              const lineContent = editor.getLine(i);
              const previousLineContent = i == 0 ? "" : editor.getLine(i - 1);
              if (/^(> )*\s*- /.test(lineContent)) {
                let n = "1.";
                const a2 = previousLineContent.match(/^\t*(\d+)\. /);
                if (a2) {
                  const nextN = parseInt(a2[0]) + 1;
                  n = nextN.toString() + ".";
                }
                const replacedLineContent = lineContent.replace(/^((> )*)(\s*)- /, "$1$3" + n + " ");
                editor.setLine(i, replacedLineContent);
              } else if (/^(> )*\s*[\d]+\. /.test(lineContent)) {
                const n = lineContent.replace(/^((> )*)(\s*)([\d]+\. ).*/, "$4");
                const replacedLineContent = lineContent.replace(/^((> )*)(\s*)[\d]+\. /, "$1$3");
                editor.setLine(i, replacedLineContent);
              } else {
                const replacedLineContent = lineContent.replace(/^((> )*)(\s*)/, "$1$3- ");
                editor.setLine(i, replacedLineContent);
              }
            }
          }
        } else {
          const cursor = editor.getCursor();
          const ch = cursor.ch;
          const line = cursor.line;
          const lineContent = editor.getLine(line);
          const previousLineContent = line == 0 ? "" : editor.getLine(line - 1);
          if (/^(> )*\s*- /.test(lineContent)) {
            let n = "1.";
            const a = previousLineContent.match(/^\t*(\d+)\. /);
            if (a) {
              const nextN = parseInt(a[0]) + 1;
              n = nextN.toString() + ".";
            }
            const replacedLineContent = lineContent.replace(/^((> )*)(\s*)- /, "$1$3" + n + " ");
            editor.setLine(line, replacedLineContent);
            cursor.ch = cursor.ch + n.length - 1;
            editor.setCursor(cursor);
          } else if (/^(> )*\s*[\d]+\. /.test(lineContent)) {
            const n = lineContent.replace(/^((> )*)(\s*)([\d]+\. ).*/, "$4");
            const replacedLineContent = lineContent.replace(/^((> )*)(\s*)[\d]+\. /, "$1$3");
            editor.setLine(line, replacedLineContent);
            cursor.ch = cursor.ch - n.length > 0 ? cursor.ch - n.length : 0;
            editor.setCursor(cursor);
          } else {
            const replacedLineContent = lineContent.replace(/^((> )*)(\s*)/, "$1$3- ");
            editor.setLine(line, replacedLineContent);
            cursor.ch = cursor.ch + 2;
            editor.setCursor(cursor);
          }
        }
      },
      hotkeys: [
        {
          modifiers: [`Ctrl`, `Meta`, `Shift`],
          key: `-`
        },
        {
          modifiers: [`Ctrl`, `Alt`, `Shift`],
          key: `-`
        }
      ]
    });
    this.addCommand({
      id: "copy-or-move-to-new-note",
      name: "Copy or Move to new note CMN",
      icon: `airplay`,
      editorCallback: async (editor, view) => {
        new CopyOrMoveToNewNoteModal(this.app, editor).open();
      }
    });
    this.addCommand({
      id: "editor-copy-line-to-clipboard",
      name: "Editor Copy Line to Clipboard",
      icon: `align-vertical-space-around`,
      editorCallback: (editor, view) => {
        const selection = exportCurrentSelection(editor);
        const copyContent = selection.contains("\n") ? selection : selection.replace(/^\t*- /, "").replace(/^\t*\d+\. /, "");
        this.addToClipboardHistory(copyContent);
        navigator.clipboard.writeText(copyContent).then(function() {
          new import_obsidian29.Notice(`Copied content
\`\`\`
${copyContent}
\`\`\`
to clipboard!`);
        }, function(error) {
          new import_obsidian29.Notice(`error when copy to clipboard!`);
        });
      },
      hotkeys: [
        {
          modifiers: [`Ctrl`, `Meta`, `Shift`],
          key: "/"
        },
        {
          modifiers: [`Ctrl`, `Alt`, `Shift`],
          key: "/"
        }
      ]
    });
    this.addCommand({
      id: "editor-cut-line-to-clipboard",
      name: "Editor Cut Line to Clipboard",
      icon: `align-vertical-justify-center`,
      editorCallback: (editor, view) => {
        const selection = exportCurrentSelection(editor);
        const cursor = editor.getCursor();
        const copyContent = selection.contains("\n") ? selection : selection.replace(/^\t*- /, "").replace(/^\t*\d+\. /, "");
        let newContent = "";
        const selectionRange = getCurrentSelectionLineNumber(editor);
        for (let i = 0; i < editor.lineCount(); i++) {
          if (i < selectionRange.fromLineNum || i > selectionRange.toLineNum) {
            newContent = newContent + editor.getLine(i) + "\n";
          }
        }
        this.addToClipboardHistory(copyContent);
        navigator.clipboard.writeText(copyContent).then(function() {
          new import_obsidian29.Notice(`Copied content
\`\`\`
${copyContent}
\`\`\`
to clipboard!`);
        }, function(error) {
          new import_obsidian29.Notice(`error when copy to clipboard!`);
        });
        editor.setValue(newContent);
        cursor.line = selectionRange.fromLineNum;
        if (editor.getLine(selectionRange.fromLineNum).length < selectionRange.fromCh) {
          cursor.ch = editor.getLine(selectionRange.fromLineNum).length;
        }
        editor.setCursor(cursor);
      },
      hotkeys: [
        {
          modifiers: [`Ctrl`, `Meta`, `Shift`],
          key: "\\"
        },
        {
          modifiers: [`Ctrl`, `Alt`, `Shift`],
          key: "\\"
        }
      ]
    });
    this.addCommand({
      id: "editor-indent-line",
      name: "Editor Indent Selection",
      icon: `right-arrow-with-tail`,
      editorCallback: (editor, view) => {
        const listSelections = editor.listSelections();
        listSelections.forEach((listSelection) => {
          const a = listSelection.head.line;
          const b = listSelection.anchor.line;
          const fromLineNum = b > a ? a : b;
          const toLineNum = b > a ? b : a;
          for (let i = fromLineNum; i <= toLineNum; i++) {
            const line = editor.getLine(i);
            editor.setLine(i, line.replace(/^/, "	"));
          }
        });
        let lss = [];
        listSelections.forEach((ls) => {
          const head = ls.head;
          head.ch = head.ch + 1;
          const anchor = ls.anchor;
          anchor.ch = anchor.ch + 1;
          const newLs = { anchor, head };
          lss.push(newLs);
        });
        editor.setSelections(lss);
      }
    });
    this.addCommand({
      id: "editor-outdent-line",
      name: "Editor Outdent Selection",
      icon: `left-arrow-with-tail`,
      editorCallback: (editor, view) => {
        const listSelections = editor.listSelections();
        listSelections.forEach((listSelection) => {
          const a = listSelection.head.line;
          const b = listSelection.anchor.line;
          const fromLineNum = b > a ? a : b;
          const toLineNum = b > a ? b : a;
          for (let i = fromLineNum; i <= toLineNum; i++) {
            const line = editor.getLine(i);
            editor.setLine(i, line.replace(/^\t/, ""));
          }
        });
        let lss = [];
        listSelections.forEach((ls) => {
          const head = ls.head;
          head.ch = head.ch + 1;
          const anchor = ls.anchor;
          anchor.ch = anchor.ch + 1;
          const newLs = { anchor, head };
          lss.push(newLs);
        });
        editor.setSelections(lss);
      }
    });
    this.addSettingTab(new SampleSettingTab(this.app, this));
  }
  convertChatGPTToTwitterFormat(editor) {
    let line = editor.lineCount();
    let numLineFirstContent = 0;
    let frontMatterLineCount = 0;
    for (let i = 0; i < line; i++) {
      if (frontMatterLineCount == 2) {
        numLineFirstContent = i;
        break;
      }
      if (editor.getLine(i) == "---") {
        frontMatterLineCount++;
      }
    }
    for (let i = 0; i < line; i++) {
      if (editor.getLine(numLineFirstContent).trim() == "") {
        numLineFirstContent++;
      } else {
        break;
      }
    }
    let totalTweetCount = 1;
    Array.from(Array(line - numLineFirstContent).keys()).forEach((i) => {
      const line2 = editor.getLine(i + numLineFirstContent);
      let modifiedLine = line2.replace(/^____+/, "---").replace(/^----+/, "---");
      editor.setLine(i + numLineFirstContent, modifiedLine);
      if (modifiedLine == "---") {
        totalTweetCount = totalTweetCount + 1;
      }
    });
    let numTweet = 1;
    let readyToAddTweetCount = true;
    let text = "";
    Array.from(Array(numLineFirstContent).keys()).forEach((i) => {
      const line2 = editor.getLine(i);
      text = text + line2 + "\n";
    });
    Array.from(Array(line - numLineFirstContent).keys()).forEach((i) => {
      const line2 = editor.getLine(i + numLineFirstContent);
      let modifiedLine = line2;
      if (line2 == "---") {
        readyToAddTweetCount = true;
        numTweet = numTweet + 1;
      } else if (line2 != "" && readyToAddTweetCount) {
        if (!/^\d+\/\d+.*/.test(line2)) {
          modifiedLine = `${numTweet}/${totalTweetCount} ${line2}`;
        }
        readyToAddTweetCount = false;
      }
      text = text + modifiedLine + "\n";
    });
    text = text.replace("\u258D", "");
    const tweets = text.split("---");
    for (let i = 0; i < tweets.length; i++) {
      const tweet = tweets[i].replace(/(https:|http:|www\.)\S*/gm, "").replace(/^\n+/m, "").replace(/\n+$/m, "");
      if (tweet.length > 140) {
        new import_obsidian29.Notice("```\n" + tweet + "\n```\n\nexceed 140 characters (currently " + tweet.length + " characters). Probably cannot post in twitter. Please refine the tweet. Aborting");
        return false;
      }
    }
    editor.setValue(text);
    const cursor = editor.getCursor();
    cursor.line = editor.lineCount() - 1;
    editor.setCursor(cursor);
    return true;
  }
  reverseTwitterNumbering(editor) {
    let line = editor.lineCount();
    let numLineFirstContent = 0;
    let frontMatterLineCount = 0;
    for (let i = 0; i < line; i++) {
      if (frontMatterLineCount == 2) {
        numLineFirstContent = i;
        break;
      }
      if (editor.getLine(i) == "---") {
        frontMatterLineCount++;
      }
    }
    for (let i = 0; i < line; i++) {
      if (editor.getLine(numLineFirstContent).trim() == "") {
        numLineFirstContent++;
      } else {
        break;
      }
    }
    let text = "";
    Array.from(Array(numLineFirstContent).keys()).forEach((i) => {
      const line2 = editor.getLine(i);
      text = text + line2 + "\n";
    });
    Array.from(Array(line - numLineFirstContent).keys()).forEach((i) => {
      const line2 = editor.getLine(i + numLineFirstContent);
      const modifiedLine = line2.replace(/^\d+\/\d+ /, "");
      text = text + modifiedLine + "\n";
    });
    editor.setValue(text);
    const cursor = editor.getCursor();
    cursor.line = editor.lineCount() - 1;
    editor.setCursor(cursor);
  }
  convertThreadsContentToFormatForThreadsApp(editor) {
    let result = this.convertThreadsContentToLightPostFormat(editor, "\u{1F9F5}", "\n\n\n");
    result = result.replace(/https\:\/\/github.com[^\n]+\n\n\n/m, "");
    return result;
  }
  convertThreadsContentToFormatForFacebookApp(editor) {
    let result = this.convertThreadsContentToLightPostFormat(editor, "", "\n\n\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\n\n", (a) => a.replace("\u{1F447}", ""));
    result = result.replace(/https\:\/\/github.com[^\n]+\n\n\n\n/m, "");
    return result;
  }
  convertThreadsContentToPOE(editor) {
    return this.convertThreadsContentToLightPostFormat(editor, "", "\n\n---\n\n", (a) => a.replace("\u{1F447}", ""));
  }
  /*
  	addTaskToPutIntoCardInThreadsContent(editor: Editor) {
  		let line = editor.lineCount();
  
  		let frontMatterLineCount = 0
  		let text = "";
  		for (let i = 0; i < line; i++) {
  			if (editor.getLine(i) == "---") {
  				frontMatterLineCount++
  			}
  			const line = editor.getLine(i);
  			
  			//if (frontMatterLineCount > 2 && line == "---") {
  			//	text = text + "%% #nm to zk %%\n\n"
  			//}
  			text = text + line + "\n"
  		}
  
  		editor.setValue(text);
  	}
  */
  convertThreadsContentToLightPostFormat(editor, headerIcon, paragraphSeparator, additionReplaceFn = (a) => a) {
    let line = editor.lineCount();
    let numLineFirstContent = 0;
    let frontMatterLineCount = 0;
    for (let i = 0; i < line; i++) {
      if (frontMatterLineCount == 2) {
        numLineFirstContent = i;
        break;
      }
      if (editor.getLine(i) == "---") {
        frontMatterLineCount++;
      }
    }
    for (let i = 0; i < line; i++) {
      if (editor.getLine(numLineFirstContent).trim() == "") {
        numLineFirstContent++;
      } else {
        break;
      }
    }
    let text = "";
    let newConsecutiveLineCount = 0;
    Array.from(Array(line - numLineFirstContent).keys()).forEach((i) => {
      const line2 = editor.getLine(i + numLineFirstContent);
      if (!line2.trim().startsWith("%%") || !line2.trim().endsWith("%%")) {
        if (line2 == "---") {
          newConsecutiveLineCount = 0;
        }
        if (line2 == "") {
          newConsecutiveLineCount++;
        } else {
          newConsecutiveLineCount = 0;
        }
        if (line2 == "" && newConsecutiveLineCount > 1) {
        } else {
          let modifiedLine = line2 == "---" ? "" : line2;
          modifiedLine = modifiedLine.replace(/^		- /g, "\u3000\u3000\u3000\u3000\u2022 ").replace(/^	- /g, "\u3000\u3000\u2022 ").replace(/^- /, "\u2022 ");
          modifiedLine = modifiedLine.replace(/^\[([^\[\]\(\)]+)\]\([^\[\]\(\)]+\)/g, "$1").replace(/[^!]\[([^\[\]\(\)]+)\]\([^\[\]\(\)]+\)/g, "$1");
          modifiedLine = modifiedLine.replace(/!\[([^\[\]\(\)]+)\]\(([^\[\]\(\)]+)\)/g, "$2");
          modifiedLine = modifiedLine.replace(/\*\*/gm, "");
          text = text + modifiedLine + "\n";
        }
      }
    });
    text = text.replace(/[ ]+(.*)/g, headerIcon + "\u3010$1\u3011");
    text = additionReplaceFn(text);
    text = text.replace(/[\n\r]{3,}/gm, `${paragraphSeparator}\u258D`);
    text = text.replace("\n\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\n\n\u258D\n", "");
    let text2 = "";
    text.split("\n").forEach((line2) => {
      var l = "";
      if (line2.endsWith("\u3002") || line2.endsWith("\uFF1A") || line2.endsWith("\uFF5E") || line2.endsWith("\uFF01") || line2.startsWith("\u258Dhttp") || line2.startsWith("\u258D#") || line2 == "\u258D") {
        l = line2.replace(/^/gm, "");
      } else {
        l = line2;
      }
      text2 = text2 + l + "\n";
    });
    text2 = text2.replace("\n\n\n\n", "");
    text2 = text2.replace("\n\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\n\n\n", "");
    text2 = text2.replace(/\n\n## Opinion from ChatGPT\:([\n]*.*)*$/, "");
    text2 = text2.replace(/\n+$/, "");
    return text2;
  }
  getThreadSegment(editor) {
    let cursor = editor.getCursor();
    let line = cursor.line;
    let above = line;
    let below = line;
    while (above >= 0) {
      let l = editor.getLine(above);
      if (l == "---") {
        break;
      }
      above--;
    }
    if (editor.getLine(above) == "---") {
      above++;
    }
    while (true) {
      if (editor.getLine(above) == "") {
        above++;
      } else {
        break;
      }
    }
    while (below < editor.lineCount()) {
      let l = editor.getLine(below);
      if (l == "---") {
        break;
      }
      below++;
    }
    if (editor.getLine(below) == "---") {
      below--;
    }
    while (true) {
      if (editor.getLine(below) == "") {
        below--;
      } else {
        break;
      }
    }
    let text = "";
    Array.from(Array(below - above + 1).keys()).forEach((i) => {
      const line2 = editor.getLine(i + above);
      if (!line2.trim().startsWith("%%") || !line2.trim().endsWith("%%")) {
        let modifiedLine = editor.getLine(i + above);
        modifiedLine = modifiedLine.replace(/^\[([^\[\]\(\)]+)\]\([^\[\]\(\)]+\)/g, "$1").replace(/[^!]\[([^\[\]\(\)]+)\]\([^\[\]\(\)]+\)/g, "$1");
        text = text + modifiedLine + "\n";
      }
    });
    text = text.replace(/\n+$/, "");
    return text;
  }
  getSegment(editor) {
    let cursor = editor.getCursor();
    let line = cursor.line;
    let above = line;
    let below = line;
    while (above >= 0) {
      let l = editor.getLine(above);
      if (l == "---") {
        break;
      }
      above--;
    }
    if (editor.getLine(above) == "---") {
      above++;
    }
    while (true) {
      if (editor.getLine(above) == "") {
        above++;
      } else {
        break;
      }
    }
    while (below < editor.lineCount()) {
      let l = editor.getLine(below);
      if (l == "---") {
        break;
      }
      below++;
    }
    if (editor.getLine(below) == "---") {
      below--;
    }
    while (true) {
      if (editor.getLine(below) == "") {
        below--;
      } else {
        break;
      }
    }
    let text = "";
    Array.from(Array(below - above + 1).keys()).forEach((i) => {
      const line2 = editor.getLine(i + above);
      text = text + line2 + "\n";
    });
    text = text.replace(/\n+$/, "");
    return text;
  }
  getTwitterSegment(editor) {
    let cursor = editor.getCursor();
    let line = cursor.line;
    let above = line;
    let below = line;
    while (above >= 0) {
      let l = editor.getLine(above);
      if (l == "---") {
        break;
      }
      above--;
    }
    if (editor.getLine(above) == "---") {
      above++;
    }
    while (true) {
      if (editor.getLine(above) == "") {
        above++;
      } else {
        break;
      }
    }
    while (below < editor.lineCount()) {
      let l = editor.getLine(below);
      if (l == "---") {
        break;
      }
      below++;
    }
    if (editor.getLine(below) == "---") {
      below--;
    }
    while (true) {
      if (editor.getLine(below) == "") {
        below--;
      } else {
        break;
      }
    }
    let text = "";
    Array.from(Array(below - above + 1).keys()).forEach((i) => {
      const line2 = editor.getLine(i + above);
      if (!line2.trim().startsWith("%%") || !line2.trim().endsWith("%%")) {
        let modifiedLine = editor.getLine(i + above);
        if (!/\d+\/\d+ *.*/.test(modifiedLine)) {
          modifiedLine = modifiedLine.replace(/^\[([^\[\]\(\)]+)\]\([^\[\]\(\)]+\)/g, "$1").replace(/[^!]\[([^\[\]\(\)]+)\]\([^\[\]\(\)]+\)/g, "$1").replace(/https[^\n]+\.jpeg/g, "").replace(/^\s+$/g, "").replace(/^- /, "\u2022 ");
          if (!/^\d+\. /.test(modifiedLine) && !/^ /.test(modifiedLine)) {
            modifiedLine = modifiedLine.replace(/([^\n])/g, "\uFF1F\n\n$1").replace(/([^\n])/g, "\u3002\n\n$1").replace(/([^\n])/g, "\uFF01\n\n$1").replace(/([^\n])/g, "\uFF5E\n\n$1");
          }
        }
        text = text + modifiedLine + "\n";
      }
    });
    text = text.replace(/\n+$/, "");
    return text;
  }
  getThreadsSegment(editor) {
    let cursor = editor.getCursor();
    let line = cursor.line;
    let above = line;
    let below = line;
    while (above >= 0) {
      let l = editor.getLine(above);
      if (l == "---") {
        break;
      }
      above--;
    }
    if (editor.getLine(above) == "---") {
      above++;
    }
    while (true) {
      if (editor.getLine(above) == "") {
        above++;
      } else {
        break;
      }
    }
    while (below < editor.lineCount()) {
      let l = editor.getLine(below);
      if (l == "---") {
        break;
      }
      below++;
    }
    if (editor.getLine(below) == "---") {
      below--;
    }
    while (true) {
      if (editor.getLine(below) == "") {
        below--;
      } else {
        break;
      }
    }
    let text = "";
    Array.from(Array(below - above + 1).keys()).forEach((i) => {
      const line2 = editor.getLine(i + above);
      if (!line2.trim().startsWith("%%") || !line2.trim().endsWith("%%")) {
        let modifiedLine = editor.getLine(i + above);
        if (!/\d+\/\d+ *.*/.test(modifiedLine)) {
          modifiedLine = modifiedLine.replace(/[ ]+(.*)/g, "\u3010$1\u3011").replace(/^\[([^\[\]\(\)]+)\]\([^\[\]\(\)]+\)/g, "$1").replace(/[^!]\[([^\[\]\(\)]+)\]\([^\[\]\(\)]+\)/g, "$1").replace(/!\[.*\]\(https[^\n]+\.jpeg\)/g, "").replace(/https[^\n]+\.jpeg/g, "").replace(/^\s+$/g, "").replace(/^- /, "\u2022 ").replace(/^#+ /, "");
          if (!/^\d+\. /.test(modifiedLine) && !/^ /.test(modifiedLine)) {
            modifiedLine = modifiedLine.replace(/([^\n])/g, "\uFF1F\n\n$1").replace(/([^\n])/g, "\u3002\n\n$1").replace(/([^\n])/g, "\uFF01\n\n$1").replace(/([^\n])/g, "\uFF5E\n\n$1");
          }
        }
        text = text + modifiedLine + "\n";
      }
    });
    text = text.replace(/\n+$/, "");
    return text;
  }
  async add3DaysActionNoteContent(vault) {
    const scheduleNoteWithoutMd = "D/Query Schedule and Actions next 3 days";
    const scheduleNote = `${scheduleNoteWithoutMd}.md`;
    if (vault.getAbstractFileByPath(scheduleNote) == null) {
      await vault.create(scheduleNote, "");
    }
    let noteContent = "[[Query Schedule and Actions next 3 days]]\n";
    const excludeNotes = [scheduleNoteWithoutMd, "D/Scheduling"];
    Array.from(Array(3).keys()).forEach((i) => noteContent += this.getQueryDateAndActionString(i, excludeNotes));
    const otherDays = this.getQueryActionsThisWeek(3);
    noteContent = noteContent + `## nn / wn
\`\`\`query
tag:#nn OR tag:#wn${otherDays}
\`\`\`

## tt
\`\`\`query
tag:#tt
\`\`\`

`;
    noteContent = noteContent + this.getQueryFutureDaysThisWeek("Future Dates", 3, 6, excludeNotes);
    noteContent = noteContent + this.getQueryNext2MonthString(excludeNotes);
    noteContent = noteContent + this.getQueryFutureDaysThisWeek("Past Dates", -7, -1, excludeNotes);
    vault.modify(vault.getAbstractFileByPath(scheduleNote), noteContent);
  }
  async addActionNoteContent(vault, folderName, noteTitleWithoutMd, scheduleNoteTitleWithoutMd, nOrW) {
    const nowActionNoteWithoutMd = `${folderName}/${noteTitleWithoutMd}`;
    const nowActionNote = `${nowActionNoteWithoutMd}.md`;
    if (vault.getAbstractFileByPath(nowActionNote) == null) {
      await vault.create(nowActionNote, "");
    }
    let nowActionNoteContent = "";
    Array.from(Array(2).keys()).forEach((i) => nowActionNoteContent += this.getQueryActionString(i, nOrW));
    nowActionNoteContent += `\`\`\`query
tag:#${nOrW}t
\`\`\`
`;
    nowActionNoteContent += `\`\`\`query
`;
    Array.from(Array(5).keys()).forEach((i) => nowActionNoteContent += this.getQueryWeekDay(i + 2, nOrW));
    nowActionNoteContent += `tag:#${nOrW}n
\`\`\`
`;
    nowActionNoteContent += `Scheduling: [[${scheduleNoteTitleWithoutMd}]]
`;
    nowActionNoteContent += `[[${noteTitleWithoutMd}]]
`;
    vault.modify(vault.getAbstractFileByPath(nowActionNote), nowActionNoteContent);
  }
  getQueryDateAndActionString(addDay, excludeNotes) {
    const dateMoment = (0, import_moment3.default)().add(addDay, "d");
    const dateYYYYMMDD = dateMoment.format("YYYYMMDD");
    const dateEachYYDD = "\\d\\d\\d\\d" + dateMoment.format("MMDD");
    const dateEachDD = "\\d\\d\\d\\d\\d\\d" + dateMoment.format("DD");
    const dayOfWeek = dateMoment.format("E");
    const dayOfWeekLong = dateMoment.format("ddd");
    const excludeNoteStr = excludeNotes.map((excludeNote) => `-path:"${excludeNote}" `).join("");
    return `## ${dateYYYYMMDD} ${dayOfWeekLong}
\`\`\`query
(" ${dateYYYYMMDD}" OR "${dateYYYYMMDD} " OR ${dateEachYYDD} OR ${dateEachDD} OR tag:#n${dayOfWeek} OR tag:#w${dayOfWeek}) ${excludeNoteStr}-block:(query)
\`\`\`

`;
  }
  getQueryActionsThisWeek(excludeNumDays) {
    let excludes = [];
    let includes = [1, 2, 3, 4, 5, 6, 7];
    Array.from(Array(excludeNumDays).keys()).forEach((i) => {
      const dateMoment = (0, import_moment3.default)().add(i, "d");
      const dayOfWeek = parseInt(dateMoment.format("E"));
      excludes.push(dayOfWeek);
    });
    let aaa = includes.filter((i) => {
      for (const e of excludes) {
        if (e == i) {
          return false;
        }
      }
      return true;
    });
    let output = "";
    aaa.forEach((i) => output += ` OR tag:#n${i} OR tag:#w${i}`);
    return output;
  }
  getQueryFutureDaysThisWeek(header, from, to, excludeNotes) {
    let includes = [];
    for (let i = from; i <= to; i++) {
      let dateMoment = (0, import_moment3.default)().add(i, "d");
      includes.push(dateMoment);
    }
    let output = `## ${header}
\`\`\`query
(`;
    includes.forEach((i) => {
      const dateYYYYMMDD = i.format("YYYYMMDD");
      const dateEachYYDD = "\\d\\d\\d\\d" + i.format("MMDD");
      const dateEachDD = "\\d\\d\\d\\d\\d\\d" + i.format("DD");
      output += `" ${dateYYYYMMDD}" OR "${dateYYYYMMDD} " OR ${dateEachYYDD} OR ${dateEachDD} OR `;
    });
    output = output.replace(/ OR $/, "");
    output += ")";
    const excludeNoteStr = excludeNotes.map((excludeNote) => `-path:"${excludeNote}" `).join("");
    output += ` ${excludeNoteStr}-block:(query)`;
    output += `
\`\`\`

`;
    return output;
  }
  getQueryNext2MonthString(excludeNotes) {
    const currentMonthYYYYMM = (0, import_moment3.default)().format("YYYYMM");
    const dateMoment = (0, import_moment3.default)().add(1, "M");
    const nextMonthYYYYMM = dateMoment.format("YYYYMM");
    const excludeNoteStr = excludeNotes.map((excludeNote) => `-path:"${excludeNote}" `).join("");
    return `## ${currentMonthYYYYMM} and ${nextMonthYYYYMM}
\`\`\`query
(${currentMonthYYYYMM}\\d\\d OR ${nextMonthYYYYMM}\\d\\d ${excludeNoteStr}-path:"D/Scheduling" -block:(query)
\`\`\`

`;
  }
  getQueryDateString(addDay, excludeNote) {
    const dateMoment = (0, import_moment3.default)().add(addDay, "d");
    const dateYYYYMMDD = dateMoment.format("YYYYMMDD");
    const dateEachYYDD = "\\d\\d\\d\\d" + dateMoment.format("MMDD");
    const dateEachDD = "\\d\\d\\d\\d\\d\\d" + dateMoment.format("DD");
    return `${dateYYYYMMDD}
\`\`\`query
(${dateYYYYMMDD} OR ${dateEachYYDD} OR ${dateEachDD}) -path:"${excludeNote}" -block:(query)
\`\`\`
`;
  }
  getQueryActionString(addDay, actionType) {
    const dateMoment = (0, import_moment3.default)().add(addDay, "d");
    const dayOfWeek = dateMoment.format("E");
    return `\`\`\`query
tag:#${actionType}${dayOfWeek}
\`\`\`
`;
  }
  getQueryWeekDay(addDay, actionType) {
    const dateMoment = (0, import_moment3.default)().add(addDay, "d");
    const dayOfWeek = dateMoment.format("E");
    return `tag:#${actionType}${dayOfWeek} OR `;
  }
  addNewLaterActionIcon(t) {
    this.addObsidianIcon(`${t}l-icon-new`, `${t}l`);
  }
  addActionIcon(t) {
    this.addObsidianIcon(`${t}-icon`, `#${t}`);
  }
  addObsidianIcon(iconName, iconText) {
    const svg = `<text stroke='#000' transform='matrix(2.79167 0 0 2.12663 -34.0417 -25.2084)' xml:space='preserve' text-anchor='start' font-family='monospace' font-size='24' y='44' x='19' stroke-width='0' fill='currentColor'>${iconText}</text>`;
    (0, import_obsidian30.addIcon)(iconName, svg);
  }
  addNewLaterAction(t) {
    this.addCommand({
      id: `add-new-${t}-later-action`,
      name: `Add ${t}l task`,
      icon: `${t}l-icon-new`,
      editorCallback: (editor, view) => {
        const cursor = editor.getCursor();
        editor.replaceRange(`#${t}l `, cursor);
        cursor.ch = cursor.ch + 4;
        editor.setCursor(cursor);
      }
      /*,
      hotkeys: [
      	{
      		modifiers: [`Ctrl`, `Meta`, `Shift`],
      		key: t == 'n' ? '1' : '2'
      	},
      	{
      		modifiers: [`Ctrl`, `Alt`, `Shift`],
      		key: t == 'n' ? '1' : '2'
      	}
      ]*/
    });
  }
  addActionCommand(t) {
    this.addCommand({
      id: `to-w${t}-n${t}`,
      name: `To w${t} or n${t}`,
      icon: `${t}-icon`,
      editorCallback: (editor, view) => {
        const cursor = editor.getCursor();
        const lineNumber = editor.getCursor().line;
        const line = editor.getLine(lineNumber);
        const replacedLine = line.replace(/ a\/w\/./, ` a/w/${t}`).replace(/ a\/n\/./, ` a/n/${t}`).replace(/#w. /, `#w${t} `).replace(/#n. /, `#n${t} `).replace(/#w.$/, `#w${t}`).replace(/#n.$/, `#n${t}`);
        if (line.contains(`#n${t} `) || line.contains(`#w${t} `)) {
          const nt = `#n${t} `;
          const wt = `#w${t} `;
          const replaceLineToRemoveTag = line.replace(`#n${t} `, ``).replace(`#w${t} `, ``);
          editor.setLine(lineNumber, replaceLineToRemoveTag);
          const ntIndex = line.indexOf(nt);
          const wtIndex = line.indexOf(wt);
          const index = ntIndex == -1 ? wtIndex : ntIndex;
          const newCh = cursor.ch <= index ? cursor.ch : cursor.ch >= index + 4 ? cursor.ch - 4 : index;
          cursor.ch = newCh;
          editor.setCursor(cursor);
        } else if (line.contains(` #n${t}`) || line.contains(` #w${t}`)) {
          const nt = `#n${t} `;
          const wt = `#w${t} `;
          const replaceLineToRemoveTag = line.replace(` #n${t}`, ``).replace(` #w${t}`, ``);
          editor.setLine(lineNumber, replaceLineToRemoveTag);
          const ntIndex = line.indexOf(nt);
          const wtIndex = line.indexOf(wt);
          const index = ntIndex == -1 ? wtIndex : ntIndex;
          const newCh = cursor.ch <= index ? cursor.ch : cursor.ch >= index + 4 ? cursor.ch - 4 : index;
          cursor.ch = newCh;
          editor.setCursor(cursor);
        } else if (line.contains(` a/n/${t}`) || line.contains(` a/w/${t}`)) {
        } else if (replacedLine == line) {
          let { frontmatter } = app.metadataCache.getFileCache(view.file) || {};
          const fmtags = (0, import_obsidian29.parseFrontMatterTags)(frontmatter) || [];
          for (const tag2 of fmtags) {
            if (tag2.contains(`#a/w/`)) {
              let modifiedLine = line;
              if (/^\t*- /.test(line)) {
                modifiedLine = line.replace(/^(\t*- )/, `$1#w${t} `);
              } else if (/^\t*\d+\. /.test(line)) {
                modifiedLine = line.replace(/^(\t*\d+\. )/, `$1w${t} `);
              } else {
                modifiedLine = line.replace(/^/, `#w${t} `);
              }
              editor.setLine(cursor.line, modifiedLine);
              cursor.ch = cursor.ch + 4;
              editor.setCursor(cursor);
              return;
            }
            if (tag2.contains(`#a/n/`)) {
              let modifiedLine = line;
              if (/^\t*- /.test(line)) {
                modifiedLine = line.replace(/^(\t*- )/, `$1#n${t} `);
              } else if (/^\t*\d+\. /.test(line)) {
                modifiedLine = line.replace(/^(\t*\d+\. )/, `$1n${t} `);
              } else {
                modifiedLine = line.replace(/^/, `#n${t} `);
              }
              editor.setLine(cursor.line, modifiedLine);
              cursor.ch = cursor.ch + 4;
              editor.setCursor(cursor);
              return;
            }
          }
          new AddTaskTagModal(this.app, editor, t).open();
        } else {
          editor.setLine(lineNumber, replacedLine);
          editor.setCursor(cursor);
        }
      },
      hotkeys: [
        {
          modifiers: this.is1To7(t) ? [`Ctrl`, `Meta`] : [`Ctrl`, `Meta`, `Shift`],
          key: `${t}`
        },
        {
          modifiers: this.is1To7(t) ? [`Ctrl`, `Alt`] : [`Ctrl`, `Alt`, `Shift`],
          key: `${t}`
        }
      ]
    });
  }
  addFollowUpCommand(t) {
    let name = "";
    if (t === "t") {
      name = "To Try";
    } else if (t === "e") {
      name = "To Explore";
    } else if (t === "m") {
      name = "To Move";
    }
    this.addCommand({
      id: `to-t${t}`,
      name: `To t${t} ${name}`,
      icon: `${t}-icon`,
      editorCallback: (editor, view) => {
        console.log(editor.getSelection());
        const cursor = editor.getCursor();
        const lineNumber = editor.getCursor().line;
        const line = editor.getLine(lineNumber);
        const replacedLine = line.replace(/#t. /, `#t${t} `).replace(/#t.$/, `#t${t}`);
        if (line.contains(`#t${t} `)) {
          const tt = `#t${t} `;
          const replaceLineToRemoveTag = line.replace(`#t${t} `, ``);
          editor.setLine(lineNumber, replaceLineToRemoveTag);
          const ttIndex = line.indexOf(tt);
          const index = ttIndex;
          const newCh = cursor.ch <= index ? cursor.ch : cursor.ch >= index + 4 ? cursor.ch - 4 : index;
          cursor.ch = newCh;
          editor.setCursor(cursor);
        } else if (line.contains(` #t${t}`)) {
          const tt = `#t${t} `;
          const replaceLineToRemoveTag = line.replace(` #t${t}`, ``);
          editor.setLine(lineNumber, replaceLineToRemoveTag);
          const ttIndex = line.indexOf(tt);
          const index = ttIndex;
          const newCh = cursor.ch <= index ? cursor.ch : cursor.ch >= index + 4 ? cursor.ch - 4 : index;
          cursor.ch = newCh;
          editor.setCursor(cursor);
        } else if (replacedLine == line) {
          let modifiedLine = line;
          if (/^\t*- /.test(line)) {
            modifiedLine = line.replace(/^(\t*- )/, `$1#t${t} `);
          } else if (/^\t*\d+\. /.test(line)) {
            modifiedLine = line.replace(/^(\t*\d+\. )/, `$1t${t} `);
          } else {
            modifiedLine = line.replace(/^/, `#t${t} `);
          }
          editor.setLine(cursor.line, modifiedLine);
          cursor.ch = cursor.ch + 4;
          editor.setCursor(cursor);
        } else {
          editor.setLine(lineNumber, replacedLine);
          editor.setCursor(cursor);
        }
      },
      hotkeys: [
        {
          modifiers: [`Ctrl`, `Meta`, `Shift`],
          key: `${t}`
        },
        {
          modifiers: [`Ctrl`, `Alt`, `Shift`],
          key: `${t}`
        }
      ]
    });
  }
  is1To7(t) {
    if (t == "1" || t == "2" || t == "3" || t == "4" || t == "5" || t == "6" || t == "7") {
      return true;
    } else {
      return false;
    }
  }
  addToClipboardHistory(content) {
    const index = clipboardHistory.indexOf(content, 0);
    if (index > -1) {
      clipboardHistory.splice(index, 1);
    }
    if (content.length > 0) {
      clipboardHistory.push(content);
    }
  }
  async onunload() {
    this.app.workspace.detachLeavesOfType(VIEW_TYPE_NOTE_LIST);
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
var SampleSettingTab = class extends import_obsidian29.PluginSettingTab {
  constructor(app2, plugin) {
    super(app2, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Settings for my awesome plugin." });
    new import_obsidian29.Setting(containerEl).setName("Setting #1").setDesc("It's a secret").addText((text) => text.setPlaceholder("Enter your secret").setValue(this.plugin.settings.mySetting).onChange(async (value) => {
      console.log("Secret: " + value);
      this.plugin.settings.mySetting = value;
      await this.plugin.saveSettings();
    }));
  }
};
/*! Bundled license information:

moment/moment.js:
  (*! moment.js *)
  (*! version : 2.29.1 *)
  (*! authors : Tim Wood, Iskren Chernev, Moment.js contributors *)
  (*! license : MIT *)
  (*! momentjs.com *)
*/
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsibm9kZV9tb2R1bGVzL21vbWVudC9tb21lbnQuanMiLCAibWFpbi50cyIsICJ1cGRhdGVOb3RlVHlwZU1vZGFsLnRzIiwgInRhZ3JlbmFtZXIvcmVuYW1pbmcudHMiLCAidGFncmVuYW1lci9UYWcudHMiLCAidGFncmVuYW1lci9GaWxlLnRzIiwgIm5vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9ub2Rlcy9Ob2RlLmpzIiwgIm5vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC92aXNpdC5qcyIsICJub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3QvZG9jL2RpcmVjdGl2ZXMuanMiLCAibm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L2RvYy9hbmNob3JzLmpzIiwgIm5vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9ub2Rlcy9BbGlhcy5qcyIsICJub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3Qvbm9kZXMvdG9KUy5qcyIsICJub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3Qvbm9kZXMvU2NhbGFyLmpzIiwgIm5vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9kb2MvY3JlYXRlTm9kZS5qcyIsICJub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3Qvbm9kZXMvQ29sbGVjdGlvbi5qcyIsICJub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3Qvc3RyaW5naWZ5L3N0cmluZ2lmeUNvbW1lbnQuanMiLCAibm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L3N0cmluZ2lmeS9mb2xkRmxvd0xpbmVzLmpzIiwgIm5vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9zdHJpbmdpZnkvc3RyaW5naWZ5U3RyaW5nLmpzIiwgIm5vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9zdHJpbmdpZnkvc3RyaW5naWZ5LmpzIiwgIm5vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9zdHJpbmdpZnkvc3RyaW5naWZ5UGFpci5qcyIsICJub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3QvbG9nLmpzIiwgIm5vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9ub2Rlcy9hZGRQYWlyVG9KU01hcC5qcyIsICJub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3Qvbm9kZXMvUGFpci5qcyIsICJub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3Qvb3B0aW9ucy5qcyIsICJub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3Qvc3RyaW5naWZ5L3N0cmluZ2lmeUNvbGxlY3Rpb24uanMiLCAibm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L25vZGVzL1lBTUxNYXAuanMiLCAibm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L3NjaGVtYS9jb21tb24vbWFwLmpzIiwgIm5vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9ub2Rlcy9ZQU1MU2VxLmpzIiwgIm5vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9zY2hlbWEvY29tbW9uL3NlcS5qcyIsICJub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3Qvc2NoZW1hL2NvbW1vbi9zdHJpbmcuanMiLCAibm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L3NjaGVtYS9jb21tb24vbnVsbC5qcyIsICJub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3Qvc2NoZW1hL2NvcmUvYm9vbC5qcyIsICJub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3Qvc3RyaW5naWZ5L3N0cmluZ2lmeU51bWJlci5qcyIsICJub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3Qvc2NoZW1hL2NvcmUvZmxvYXQuanMiLCAibm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L3NjaGVtYS9jb3JlL2ludC5qcyIsICJub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3Qvc2NoZW1hL2NvcmUvc2NoZW1hLmpzIiwgIm5vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9zY2hlbWEvanNvbi9zY2hlbWEuanMiLCAibm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L3NjaGVtYS95YW1sLTEuMS9iaW5hcnkuanMiLCAibm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L3NjaGVtYS95YW1sLTEuMS9wYWlycy5qcyIsICJub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3Qvc2NoZW1hL3lhbWwtMS4xL29tYXAuanMiLCAibm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L3NjaGVtYS95YW1sLTEuMS9ib29sLmpzIiwgIm5vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9zY2hlbWEveWFtbC0xLjEvZmxvYXQuanMiLCAibm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L3NjaGVtYS95YW1sLTEuMS9pbnQuanMiLCAibm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L3NjaGVtYS95YW1sLTEuMS9zZXQuanMiLCAibm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L3NjaGVtYS95YW1sLTEuMS90aW1lc3RhbXAuanMiLCAibm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L3NjaGVtYS95YW1sLTEuMS9zY2hlbWEuanMiLCAibm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L3NjaGVtYS90YWdzLmpzIiwgIm5vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9zY2hlbWEvU2NoZW1hLmpzIiwgIm5vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9zdHJpbmdpZnkvc3RyaW5naWZ5RG9jdW1lbnQuanMiLCAibm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L2RvYy9hcHBseVJldml2ZXIuanMiLCAibm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L2RvYy9Eb2N1bWVudC5qcyIsICJub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3QvZXJyb3JzLmpzIiwgIm5vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9jb21wb3NlL3Jlc29sdmUtcHJvcHMuanMiLCAibm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L2NvbXBvc2UvdXRpbC1jb250YWlucy1uZXdsaW5lLmpzIiwgIm5vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9jb21wb3NlL3V0aWwtZmxvdy1pbmRlbnQtY2hlY2suanMiLCAibm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L2NvbXBvc2UvdXRpbC1tYXAtaW5jbHVkZXMuanMiLCAibm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L2NvbXBvc2UvcmVzb2x2ZS1ibG9jay1tYXAuanMiLCAibm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L2NvbXBvc2UvcmVzb2x2ZS1ibG9jay1zZXEuanMiLCAibm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L2NvbXBvc2UvcmVzb2x2ZS1lbmQuanMiLCAibm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L2NvbXBvc2UvcmVzb2x2ZS1mbG93LWNvbGxlY3Rpb24uanMiLCAibm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L2NvbXBvc2UvY29tcG9zZS1jb2xsZWN0aW9uLmpzIiwgIm5vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9jb21wb3NlL3Jlc29sdmUtYmxvY2stc2NhbGFyLmpzIiwgIm5vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9jb21wb3NlL3Jlc29sdmUtZmxvdy1zY2FsYXIuanMiLCAibm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L2NvbXBvc2UvY29tcG9zZS1zY2FsYXIuanMiLCAibm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L2NvbXBvc2UvdXRpbC1lbXB0eS1zY2FsYXItcG9zaXRpb24uanMiLCAibm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L2NvbXBvc2UvY29tcG9zZS1ub2RlLmpzIiwgIm5vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9jb21wb3NlL2NvbXBvc2UtZG9jLmpzIiwgIm5vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9jb21wb3NlL2NvbXBvc2VyLmpzIiwgIm5vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9wYXJzZS9jc3QuanMiLCAibm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L3BhcnNlL2NzdC1zY2FsYXIuanMiLCAibm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L3BhcnNlL2NzdC1zdHJpbmdpZnkuanMiLCAibm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L3BhcnNlL2NzdC12aXNpdC5qcyIsICJub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3QvcGFyc2UvbGV4ZXIuanMiLCAibm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L3BhcnNlL2xpbmUtY291bnRlci5qcyIsICJub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3QvcGFyc2UvcGFyc2VyLmpzIiwgIm5vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9wdWJsaWMtYXBpLmpzIiwgInNlbGZ1dGlsL2dldFRhc2tUYWcudHMiLCAiYWRkQ29tbWVudFRhZ01vZGFsLnRzIiwgImFkZFRhc2tUYWdNb2RhbC50cyIsICJUaHJlYWRzVG9JbWFnZXNNb2RhbC50cyIsICJjb3B5T3JNb3ZlVG9OZXdOb3RlTW9kYWwudHMiLCAiY2xpcGJvYXJkUGFzdGVNb2RhbC50cyIsICJvcGVuUGxheWdyb3VuZE1vZGFsLnRzIiwgInRocmVhZHNUb0Jsb2dNb2RhbC50cyIsICJjbGlwYm9hcmRSZW1vdmFsTW9kYWwudHMiLCAidGFnU2VhcmNoTW9kYWwudHMiLCAic2VsZnV0aWwvZ2V0QWxsTm90ZVRhZ3MudHMiLCAiYWRkVGV4dFRvTm90ZXNGcm9tU3BlY2lmaWNUYWdNb2RhbC50cyIsICJzZWxmdXRpbC9hZGRsaW5rdG9ub3Rlcy50cyIsICJzZWxmdXRpbC9maW5kTm90ZXNGcm9tVGFnLnRzIiwgInNlbGZ1dGlsL25vdGVXaXRoSGVhZGVyLnRzIiwgImFkZFRleHRUb05vdGVzTW9kYWwudHMiLCAic2VsZnV0aWwvZ2V0QWxsSGVhZGVycy50cyIsICJzZWxmdXRpbC9nZXRSZWNlbnROb3Rlcy50cyIsICJuYXZpZ2F0ZVRvTm90ZUZyb21TcGVjaWZpY1RhZ01vZGFsLnRzIiwgIm5hdmlnYXRlVG9Ob3RlRnJvbVRhZ01vZGFsLnRzIiwgInNlbGZ1dGlsL2V4dHJhY3RTZWxlY3Rpb24udHMiLCAidHdtaWdyYXRpb24vdHdNaWdyYXRlVG9vbHMudHMiLCAic2VsZnV0aWwvcmVtb3ZlQ29udGVudEZyb21DdXJzb3IudHMiLCAicmVtb3ZlQ29udGVudEZyb21DdXJzb3JNb2RhbC50cyIsICJmaW5kUmVwbGFjZU1vZGFsLnRzIiwgInF1ZXJ5T3JwaGFuTm90ZXNCeVRhZ01vZGFsLnRzIiwgIm5hdmlnYXRlVG9Gb3J3YXJkQW5kQmFja2xpbmtNb2RhbC50cyIsICJzZWxmdXRpbC9nZXRDaGlsZExpbmsudHMiLCAibmF2aWdhdGVSZXdyaXRhYmxlVGhyZWFkc01vZGFsLnRzIiwgInJld3JpdGVUaHJlYWRzLnRzIiwgIm5vdGVzVHlwZVZpZXcudHMiXSwKICAic291cmNlc0NvbnRlbnQiOiBbIi8vISBtb21lbnQuanNcbi8vISB2ZXJzaW9uIDogMi4yOS4xXG4vLyEgYXV0aG9ycyA6IFRpbSBXb29kLCBJc2tyZW4gQ2hlcm5ldiwgTW9tZW50LmpzIGNvbnRyaWJ1dG9yc1xuLy8hIGxpY2Vuc2UgOiBNSVRcbi8vISBtb21lbnRqcy5jb21cblxuOyhmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCkgOlxuICAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShmYWN0b3J5KSA6XG4gICAgZ2xvYmFsLm1vbWVudCA9IGZhY3RvcnkoKVxufSh0aGlzLCAoZnVuY3Rpb24gKCkgeyAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgaG9va0NhbGxiYWNrO1xuXG4gICAgZnVuY3Rpb24gaG9va3MoKSB7XG4gICAgICAgIHJldHVybiBob29rQ2FsbGJhY2suYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICAvLyBUaGlzIGlzIGRvbmUgdG8gcmVnaXN0ZXIgdGhlIG1ldGhvZCBjYWxsZWQgd2l0aCBtb21lbnQoKVxuICAgIC8vIHdpdGhvdXQgY3JlYXRpbmcgY2lyY3VsYXIgZGVwZW5kZW5jaWVzLlxuICAgIGZ1bmN0aW9uIHNldEhvb2tDYWxsYmFjayhjYWxsYmFjaykge1xuICAgICAgICBob29rQ2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0FycmF5KGlucHV0KSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBpbnB1dCBpbnN0YW5jZW9mIEFycmF5IHx8XG4gICAgICAgICAgICBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaW5wdXQpID09PSAnW29iamVjdCBBcnJheV0nXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNPYmplY3QoaW5wdXQpIHtcbiAgICAgICAgLy8gSUU4IHdpbGwgdHJlYXQgdW5kZWZpbmVkIGFuZCBudWxsIGFzIG9iamVjdCBpZiBpdCB3YXNuJ3QgZm9yXG4gICAgICAgIC8vIGlucHV0ICE9IG51bGxcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIGlucHV0ICE9IG51bGwgJiZcbiAgICAgICAgICAgIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpbnB1dCkgPT09ICdbb2JqZWN0IE9iamVjdF0nXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFzT3duUHJvcChhLCBiKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYSwgYik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNPYmplY3RFbXB0eShvYmopIHtcbiAgICAgICAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKSB7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMob2JqKS5sZW5ndGggPT09IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgaztcbiAgICAgICAgICAgIGZvciAoayBpbiBvYmopIHtcbiAgICAgICAgICAgICAgICBpZiAoaGFzT3duUHJvcChvYmosIGspKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzVW5kZWZpbmVkKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBpbnB1dCA9PT0gdm9pZCAwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzTnVtYmVyKGlucHV0KSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICB0eXBlb2YgaW5wdXQgPT09ICdudW1iZXInIHx8XG4gICAgICAgICAgICBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaW5wdXQpID09PSAnW29iamVjdCBOdW1iZXJdJ1xuICAgICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzRGF0ZShpbnB1dCkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgaW5wdXQgaW5zdGFuY2VvZiBEYXRlIHx8XG4gICAgICAgICAgICBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaW5wdXQpID09PSAnW29iamVjdCBEYXRlXSdcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYXAoYXJyLCBmbikge1xuICAgICAgICB2YXIgcmVzID0gW10sXG4gICAgICAgICAgICBpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICByZXMucHVzaChmbihhcnJbaV0sIGkpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGV4dGVuZChhLCBiKSB7XG4gICAgICAgIGZvciAodmFyIGkgaW4gYikge1xuICAgICAgICAgICAgaWYgKGhhc093blByb3AoYiwgaSkpIHtcbiAgICAgICAgICAgICAgICBhW2ldID0gYltpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoYXNPd25Qcm9wKGIsICd0b1N0cmluZycpKSB7XG4gICAgICAgICAgICBhLnRvU3RyaW5nID0gYi50b1N0cmluZztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoYXNPd25Qcm9wKGIsICd2YWx1ZU9mJykpIHtcbiAgICAgICAgICAgIGEudmFsdWVPZiA9IGIudmFsdWVPZjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZVVUQyhpbnB1dCwgZm9ybWF0LCBsb2NhbGUsIHN0cmljdCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlTG9jYWxPclVUQyhpbnB1dCwgZm9ybWF0LCBsb2NhbGUsIHN0cmljdCwgdHJ1ZSkudXRjKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGVmYXVsdFBhcnNpbmdGbGFncygpIHtcbiAgICAgICAgLy8gV2UgbmVlZCB0byBkZWVwIGNsb25lIHRoaXMgb2JqZWN0LlxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZW1wdHk6IGZhbHNlLFxuICAgICAgICAgICAgdW51c2VkVG9rZW5zOiBbXSxcbiAgICAgICAgICAgIHVudXNlZElucHV0OiBbXSxcbiAgICAgICAgICAgIG92ZXJmbG93OiAtMixcbiAgICAgICAgICAgIGNoYXJzTGVmdE92ZXI6IDAsXG4gICAgICAgICAgICBudWxsSW5wdXQ6IGZhbHNlLFxuICAgICAgICAgICAgaW52YWxpZEVyYTogbnVsbCxcbiAgICAgICAgICAgIGludmFsaWRNb250aDogbnVsbCxcbiAgICAgICAgICAgIGludmFsaWRGb3JtYXQ6IGZhbHNlLFxuICAgICAgICAgICAgdXNlckludmFsaWRhdGVkOiBmYWxzZSxcbiAgICAgICAgICAgIGlzbzogZmFsc2UsXG4gICAgICAgICAgICBwYXJzZWREYXRlUGFydHM6IFtdLFxuICAgICAgICAgICAgZXJhOiBudWxsLFxuICAgICAgICAgICAgbWVyaWRpZW06IG51bGwsXG4gICAgICAgICAgICByZmMyODIyOiBmYWxzZSxcbiAgICAgICAgICAgIHdlZWtkYXlNaXNtYXRjaDogZmFsc2UsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0UGFyc2luZ0ZsYWdzKG0pIHtcbiAgICAgICAgaWYgKG0uX3BmID09IG51bGwpIHtcbiAgICAgICAgICAgIG0uX3BmID0gZGVmYXVsdFBhcnNpbmdGbGFncygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtLl9wZjtcbiAgICB9XG5cbiAgICB2YXIgc29tZTtcbiAgICBpZiAoQXJyYXkucHJvdG90eXBlLnNvbWUpIHtcbiAgICAgICAgc29tZSA9IEFycmF5LnByb3RvdHlwZS5zb21lO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHNvbWUgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgICAgICAgICB2YXIgdCA9IE9iamVjdCh0aGlzKSxcbiAgICAgICAgICAgICAgICBsZW4gPSB0Lmxlbmd0aCA+Pj4gMCxcbiAgICAgICAgICAgICAgICBpO1xuXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoaSBpbiB0ICYmIGZ1bi5jYWxsKHRoaXMsIHRbaV0sIGksIHQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzVmFsaWQobSkge1xuICAgICAgICBpZiAobS5faXNWYWxpZCA9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgZmxhZ3MgPSBnZXRQYXJzaW5nRmxhZ3MobSksXG4gICAgICAgICAgICAgICAgcGFyc2VkUGFydHMgPSBzb21lLmNhbGwoZmxhZ3MucGFyc2VkRGF0ZVBhcnRzLCBmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaSAhPSBudWxsO1xuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIGlzTm93VmFsaWQgPVxuICAgICAgICAgICAgICAgICAgICAhaXNOYU4obS5fZC5nZXRUaW1lKCkpICYmXG4gICAgICAgICAgICAgICAgICAgIGZsYWdzLm92ZXJmbG93IDwgMCAmJlxuICAgICAgICAgICAgICAgICAgICAhZmxhZ3MuZW1wdHkgJiZcbiAgICAgICAgICAgICAgICAgICAgIWZsYWdzLmludmFsaWRFcmEgJiZcbiAgICAgICAgICAgICAgICAgICAgIWZsYWdzLmludmFsaWRNb250aCAmJlxuICAgICAgICAgICAgICAgICAgICAhZmxhZ3MuaW52YWxpZFdlZWtkYXkgJiZcbiAgICAgICAgICAgICAgICAgICAgIWZsYWdzLndlZWtkYXlNaXNtYXRjaCAmJlxuICAgICAgICAgICAgICAgICAgICAhZmxhZ3MubnVsbElucHV0ICYmXG4gICAgICAgICAgICAgICAgICAgICFmbGFncy5pbnZhbGlkRm9ybWF0ICYmXG4gICAgICAgICAgICAgICAgICAgICFmbGFncy51c2VySW52YWxpZGF0ZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgKCFmbGFncy5tZXJpZGllbSB8fCAoZmxhZ3MubWVyaWRpZW0gJiYgcGFyc2VkUGFydHMpKTtcblxuICAgICAgICAgICAgaWYgKG0uX3N0cmljdCkge1xuICAgICAgICAgICAgICAgIGlzTm93VmFsaWQgPVxuICAgICAgICAgICAgICAgICAgICBpc05vd1ZhbGlkICYmXG4gICAgICAgICAgICAgICAgICAgIGZsYWdzLmNoYXJzTGVmdE92ZXIgPT09IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgZmxhZ3MudW51c2VkVG9rZW5zLmxlbmd0aCA9PT0gMCAmJlxuICAgICAgICAgICAgICAgICAgICBmbGFncy5iaWdIb3VyID09PSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChPYmplY3QuaXNGcm96ZW4gPT0gbnVsbCB8fCAhT2JqZWN0LmlzRnJvemVuKG0pKSB7XG4gICAgICAgICAgICAgICAgbS5faXNWYWxpZCA9IGlzTm93VmFsaWQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBpc05vd1ZhbGlkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtLl9pc1ZhbGlkO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUludmFsaWQoZmxhZ3MpIHtcbiAgICAgICAgdmFyIG0gPSBjcmVhdGVVVEMoTmFOKTtcbiAgICAgICAgaWYgKGZsYWdzICE9IG51bGwpIHtcbiAgICAgICAgICAgIGV4dGVuZChnZXRQYXJzaW5nRmxhZ3MobSksIGZsYWdzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhtKS51c2VySW52YWxpZGF0ZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG07XG4gICAgfVxuXG4gICAgLy8gUGx1Z2lucyB0aGF0IGFkZCBwcm9wZXJ0aWVzIHNob3VsZCBhbHNvIGFkZCB0aGUga2V5IGhlcmUgKG51bGwgdmFsdWUpLFxuICAgIC8vIHNvIHdlIGNhbiBwcm9wZXJseSBjbG9uZSBvdXJzZWx2ZXMuXG4gICAgdmFyIG1vbWVudFByb3BlcnRpZXMgPSAoaG9va3MubW9tZW50UHJvcGVydGllcyA9IFtdKSxcbiAgICAgICAgdXBkYXRlSW5Qcm9ncmVzcyA9IGZhbHNlO1xuXG4gICAgZnVuY3Rpb24gY29weUNvbmZpZyh0bywgZnJvbSkge1xuICAgICAgICB2YXIgaSwgcHJvcCwgdmFsO1xuXG4gICAgICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5faXNBTW9tZW50T2JqZWN0KSkge1xuICAgICAgICAgICAgdG8uX2lzQU1vbWVudE9iamVjdCA9IGZyb20uX2lzQU1vbWVudE9iamVjdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX2kpKSB7XG4gICAgICAgICAgICB0by5faSA9IGZyb20uX2k7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9mKSkge1xuICAgICAgICAgICAgdG8uX2YgPSBmcm9tLl9mO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5fbCkpIHtcbiAgICAgICAgICAgIHRvLl9sID0gZnJvbS5fbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX3N0cmljdCkpIHtcbiAgICAgICAgICAgIHRvLl9zdHJpY3QgPSBmcm9tLl9zdHJpY3Q7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl90em0pKSB7XG4gICAgICAgICAgICB0by5fdHptID0gZnJvbS5fdHptO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5faXNVVEMpKSB7XG4gICAgICAgICAgICB0by5faXNVVEMgPSBmcm9tLl9pc1VUQztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX29mZnNldCkpIHtcbiAgICAgICAgICAgIHRvLl9vZmZzZXQgPSBmcm9tLl9vZmZzZXQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9wZikpIHtcbiAgICAgICAgICAgIHRvLl9wZiA9IGdldFBhcnNpbmdGbGFncyhmcm9tKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX2xvY2FsZSkpIHtcbiAgICAgICAgICAgIHRvLl9sb2NhbGUgPSBmcm9tLl9sb2NhbGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobW9tZW50UHJvcGVydGllcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbW9tZW50UHJvcGVydGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHByb3AgPSBtb21lbnRQcm9wZXJ0aWVzW2ldO1xuICAgICAgICAgICAgICAgIHZhbCA9IGZyb21bcHJvcF07XG4gICAgICAgICAgICAgICAgaWYgKCFpc1VuZGVmaW5lZCh2YWwpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvW3Byb3BdID0gdmFsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0bztcbiAgICB9XG5cbiAgICAvLyBNb21lbnQgcHJvdG90eXBlIG9iamVjdFxuICAgIGZ1bmN0aW9uIE1vbWVudChjb25maWcpIHtcbiAgICAgICAgY29weUNvbmZpZyh0aGlzLCBjb25maWcpO1xuICAgICAgICB0aGlzLl9kID0gbmV3IERhdGUoY29uZmlnLl9kICE9IG51bGwgPyBjb25maWcuX2QuZ2V0VGltZSgpIDogTmFOKTtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgdGhpcy5fZCA9IG5ldyBEYXRlKE5hTik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUHJldmVudCBpbmZpbml0ZSBsb29wIGluIGNhc2UgdXBkYXRlT2Zmc2V0IGNyZWF0ZXMgbmV3IG1vbWVudFxuICAgICAgICAvLyBvYmplY3RzLlxuICAgICAgICBpZiAodXBkYXRlSW5Qcm9ncmVzcyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHVwZGF0ZUluUHJvZ3Jlc3MgPSB0cnVlO1xuICAgICAgICAgICAgaG9va3MudXBkYXRlT2Zmc2V0KHRoaXMpO1xuICAgICAgICAgICAgdXBkYXRlSW5Qcm9ncmVzcyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNNb21lbnQob2JqKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBvYmogaW5zdGFuY2VvZiBNb21lbnQgfHwgKG9iaiAhPSBudWxsICYmIG9iai5faXNBTW9tZW50T2JqZWN0ICE9IG51bGwpXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gd2Fybihtc2cpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgaG9va3Muc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmdzID09PSBmYWxzZSAmJlxuICAgICAgICAgICAgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICBjb25zb2xlLndhcm5cbiAgICAgICAgKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ0RlcHJlY2F0aW9uIHdhcm5pbmc6ICcgKyBtc2cpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGVwcmVjYXRlKG1zZywgZm4pIHtcbiAgICAgICAgdmFyIGZpcnN0VGltZSA9IHRydWU7XG5cbiAgICAgICAgcmV0dXJuIGV4dGVuZChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoaG9va3MuZGVwcmVjYXRpb25IYW5kbGVyICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBob29rcy5kZXByZWNhdGlvbkhhbmRsZXIobnVsbCwgbXNnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmaXJzdFRpbWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXJncyA9IFtdLFxuICAgICAgICAgICAgICAgICAgICBhcmcsXG4gICAgICAgICAgICAgICAgICAgIGksXG4gICAgICAgICAgICAgICAgICAgIGtleTtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGFyZyA9ICcnO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGFyZ3VtZW50c1tpXSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZyArPSAnXFxuWycgKyBpICsgJ10gJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoa2V5IGluIGFyZ3VtZW50c1swXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wKGFyZ3VtZW50c1swXSwga2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmcgKz0ga2V5ICsgJzogJyArIGFyZ3VtZW50c1swXVtrZXldICsgJywgJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmcgPSBhcmcuc2xpY2UoMCwgLTIpOyAvLyBSZW1vdmUgdHJhaWxpbmcgY29tbWEgYW5kIHNwYWNlXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmcgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYXJncy5wdXNoKGFyZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAgICAgICAgIG1zZyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnXFxuQXJndW1lbnRzOiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3MpLmpvaW4oJycpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdcXG4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBFcnJvcigpLnN0YWNrXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBmaXJzdFRpbWUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9LCBmbik7XG4gICAgfVxuXG4gICAgdmFyIGRlcHJlY2F0aW9ucyA9IHt9O1xuXG4gICAgZnVuY3Rpb24gZGVwcmVjYXRlU2ltcGxlKG5hbWUsIG1zZykge1xuICAgICAgICBpZiAoaG9va3MuZGVwcmVjYXRpb25IYW5kbGVyICE9IG51bGwpIHtcbiAgICAgICAgICAgIGhvb2tzLmRlcHJlY2F0aW9uSGFuZGxlcihuYW1lLCBtc2cpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZGVwcmVjYXRpb25zW25hbWVdKSB7XG4gICAgICAgICAgICB3YXJuKG1zZyk7XG4gICAgICAgICAgICBkZXByZWNhdGlvbnNbbmFtZV0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaG9va3Muc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmdzID0gZmFsc2U7XG4gICAgaG9va3MuZGVwcmVjYXRpb25IYW5kbGVyID0gbnVsbDtcblxuICAgIGZ1bmN0aW9uIGlzRnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICh0eXBlb2YgRnVuY3Rpb24gIT09ICd1bmRlZmluZWQnICYmIGlucHV0IGluc3RhbmNlb2YgRnVuY3Rpb24pIHx8XG4gICAgICAgICAgICBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaW5wdXQpID09PSAnW29iamVjdCBGdW5jdGlvbl0nXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0KGNvbmZpZykge1xuICAgICAgICB2YXIgcHJvcCwgaTtcbiAgICAgICAgZm9yIChpIGluIGNvbmZpZykge1xuICAgICAgICAgICAgaWYgKGhhc093blByb3AoY29uZmlnLCBpKSkge1xuICAgICAgICAgICAgICAgIHByb3AgPSBjb25maWdbaV07XG4gICAgICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24ocHJvcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpc1tpXSA9IHByb3A7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpc1snXycgKyBpXSA9IHByb3A7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NvbmZpZyA9IGNvbmZpZztcbiAgICAgICAgLy8gTGVuaWVudCBvcmRpbmFsIHBhcnNpbmcgYWNjZXB0cyBqdXN0IGEgbnVtYmVyIGluIGFkZGl0aW9uIHRvXG4gICAgICAgIC8vIG51bWJlciArIChwb3NzaWJseSkgc3R1ZmYgY29taW5nIGZyb20gX2RheU9mTW9udGhPcmRpbmFsUGFyc2UuXG4gICAgICAgIC8vIFRPRE86IFJlbW92ZSBcIm9yZGluYWxQYXJzZVwiIGZhbGxiYWNrIGluIG5leHQgbWFqb3IgcmVsZWFzZS5cbiAgICAgICAgdGhpcy5fZGF5T2ZNb250aE9yZGluYWxQYXJzZUxlbmllbnQgPSBuZXcgUmVnRXhwKFxuICAgICAgICAgICAgKHRoaXMuX2RheU9mTW9udGhPcmRpbmFsUGFyc2Uuc291cmNlIHx8IHRoaXMuX29yZGluYWxQYXJzZS5zb3VyY2UpICtcbiAgICAgICAgICAgICAgICAnfCcgK1xuICAgICAgICAgICAgICAgIC9cXGR7MSwyfS8uc291cmNlXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWVyZ2VDb25maWdzKHBhcmVudENvbmZpZywgY2hpbGRDb25maWcpIHtcbiAgICAgICAgdmFyIHJlcyA9IGV4dGVuZCh7fSwgcGFyZW50Q29uZmlnKSxcbiAgICAgICAgICAgIHByb3A7XG4gICAgICAgIGZvciAocHJvcCBpbiBjaGlsZENvbmZpZykge1xuICAgICAgICAgICAgaWYgKGhhc093blByb3AoY2hpbGRDb25maWcsIHByb3ApKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzT2JqZWN0KHBhcmVudENvbmZpZ1twcm9wXSkgJiYgaXNPYmplY3QoY2hpbGRDb25maWdbcHJvcF0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc1twcm9wXSA9IHt9O1xuICAgICAgICAgICAgICAgICAgICBleHRlbmQocmVzW3Byb3BdLCBwYXJlbnRDb25maWdbcHJvcF0pO1xuICAgICAgICAgICAgICAgICAgICBleHRlbmQocmVzW3Byb3BdLCBjaGlsZENvbmZpZ1twcm9wXSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjaGlsZENvbmZpZ1twcm9wXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc1twcm9wXSA9IGNoaWxkQ29uZmlnW3Byb3BdO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSByZXNbcHJvcF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAocHJvcCBpbiBwYXJlbnRDb25maWcpIHtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBoYXNPd25Qcm9wKHBhcmVudENvbmZpZywgcHJvcCkgJiZcbiAgICAgICAgICAgICAgICAhaGFzT3duUHJvcChjaGlsZENvbmZpZywgcHJvcCkgJiZcbiAgICAgICAgICAgICAgICBpc09iamVjdChwYXJlbnRDb25maWdbcHJvcF0pXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAvLyBtYWtlIHN1cmUgY2hhbmdlcyB0byBwcm9wZXJ0aWVzIGRvbid0IG1vZGlmeSBwYXJlbnQgY29uZmlnXG4gICAgICAgICAgICAgICAgcmVzW3Byb3BdID0gZXh0ZW5kKHt9LCByZXNbcHJvcF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gTG9jYWxlKGNvbmZpZykge1xuICAgICAgICBpZiAoY29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0KGNvbmZpZyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIga2V5cztcblxuICAgIGlmIChPYmplY3Qua2V5cykge1xuICAgICAgICBrZXlzID0gT2JqZWN0LmtleXM7XG4gICAgfSBlbHNlIHtcbiAgICAgICAga2V5cyA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgIHZhciBpLFxuICAgICAgICAgICAgICAgIHJlcyA9IFtdO1xuICAgICAgICAgICAgZm9yIChpIGluIG9iaikge1xuICAgICAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wKG9iaiwgaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzLnB1c2goaSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdENhbGVuZGFyID0ge1xuICAgICAgICBzYW1lRGF5OiAnW1RvZGF5IGF0XSBMVCcsXG4gICAgICAgIG5leHREYXk6ICdbVG9tb3Jyb3cgYXRdIExUJyxcbiAgICAgICAgbmV4dFdlZWs6ICdkZGRkIFthdF0gTFQnLFxuICAgICAgICBsYXN0RGF5OiAnW1llc3RlcmRheSBhdF0gTFQnLFxuICAgICAgICBsYXN0V2VlazogJ1tMYXN0XSBkZGRkIFthdF0gTFQnLFxuICAgICAgICBzYW1lRWxzZTogJ0wnLFxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBjYWxlbmRhcihrZXksIG1vbSwgbm93KSB7XG4gICAgICAgIHZhciBvdXRwdXQgPSB0aGlzLl9jYWxlbmRhcltrZXldIHx8IHRoaXMuX2NhbGVuZGFyWydzYW1lRWxzZSddO1xuICAgICAgICByZXR1cm4gaXNGdW5jdGlvbihvdXRwdXQpID8gb3V0cHV0LmNhbGwobW9tLCBub3cpIDogb3V0cHV0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHplcm9GaWxsKG51bWJlciwgdGFyZ2V0TGVuZ3RoLCBmb3JjZVNpZ24pIHtcbiAgICAgICAgdmFyIGFic051bWJlciA9ICcnICsgTWF0aC5hYnMobnVtYmVyKSxcbiAgICAgICAgICAgIHplcm9zVG9GaWxsID0gdGFyZ2V0TGVuZ3RoIC0gYWJzTnVtYmVyLmxlbmd0aCxcbiAgICAgICAgICAgIHNpZ24gPSBudW1iZXIgPj0gMDtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIChzaWduID8gKGZvcmNlU2lnbiA/ICcrJyA6ICcnKSA6ICctJykgK1xuICAgICAgICAgICAgTWF0aC5wb3coMTAsIE1hdGgubWF4KDAsIHplcm9zVG9GaWxsKSkudG9TdHJpbmcoKS5zdWJzdHIoMSkgK1xuICAgICAgICAgICAgYWJzTnVtYmVyXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgdmFyIGZvcm1hdHRpbmdUb2tlbnMgPSAvKFxcW1teXFxbXSpcXF0pfChcXFxcKT8oW0hoXW1tKHNzKT98TW98TU0/TT9NP3xEb3xERERvfEREP0Q/RD98ZGRkP2Q/fGRvP3x3W298d10/fFdbb3xXXT98UW8/fE57MSw1fXxZWVlZWVl8WVlZWVl8WVlZWXxZWXx5ezIsNH18eW8/fGdnKGdnZz8pP3xHRyhHR0c/KT98ZXxFfGF8QXxoaD98SEg/fGtrP3xtbT98c3M/fFN7MSw5fXx4fFh8eno/fFpaP3wuKS9nLFxuICAgICAgICBsb2NhbEZvcm1hdHRpbmdUb2tlbnMgPSAvKFxcW1teXFxbXSpcXF0pfChcXFxcKT8oTFRTfExUfExMP0w/TD98bHsxLDR9KS9nLFxuICAgICAgICBmb3JtYXRGdW5jdGlvbnMgPSB7fSxcbiAgICAgICAgZm9ybWF0VG9rZW5GdW5jdGlvbnMgPSB7fTtcblxuICAgIC8vIHRva2VuOiAgICAnTSdcbiAgICAvLyBwYWRkZWQ6ICAgWydNTScsIDJdXG4gICAgLy8gb3JkaW5hbDogICdNbydcbiAgICAvLyBjYWxsYmFjazogZnVuY3Rpb24gKCkgeyB0aGlzLm1vbnRoKCkgKyAxIH1cbiAgICBmdW5jdGlvbiBhZGRGb3JtYXRUb2tlbih0b2tlbiwgcGFkZGVkLCBvcmRpbmFsLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgZnVuYyA9IGNhbGxiYWNrO1xuICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgZnVuYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1tjYWxsYmFja10oKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRva2VuKSB7XG4gICAgICAgICAgICBmb3JtYXRUb2tlbkZ1bmN0aW9uc1t0b2tlbl0gPSBmdW5jO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYWRkZWQpIHtcbiAgICAgICAgICAgIGZvcm1hdFRva2VuRnVuY3Rpb25zW3BhZGRlZFswXV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHplcm9GaWxsKGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKSwgcGFkZGVkWzFdLCBwYWRkZWRbMl0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3JkaW5hbCkge1xuICAgICAgICAgICAgZm9ybWF0VG9rZW5GdW5jdGlvbnNbb3JkaW5hbF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLm9yZGluYWwoXG4gICAgICAgICAgICAgICAgICAgIGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKSxcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlbW92ZUZvcm1hdHRpbmdUb2tlbnMoaW5wdXQpIHtcbiAgICAgICAgaWYgKGlucHV0Lm1hdGNoKC9cXFtbXFxzXFxTXS8pKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQucmVwbGFjZSgvXlxcW3xcXF0kL2csICcnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5wdXQucmVwbGFjZSgvXFxcXC9nLCAnJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFrZUZvcm1hdEZ1bmN0aW9uKGZvcm1hdCkge1xuICAgICAgICB2YXIgYXJyYXkgPSBmb3JtYXQubWF0Y2goZm9ybWF0dGluZ1Rva2VucyksXG4gICAgICAgICAgICBpLFxuICAgICAgICAgICAgbGVuZ3RoO1xuXG4gICAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoZm9ybWF0VG9rZW5GdW5jdGlvbnNbYXJyYXlbaV1dKSB7XG4gICAgICAgICAgICAgICAgYXJyYXlbaV0gPSBmb3JtYXRUb2tlbkZ1bmN0aW9uc1thcnJheVtpXV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFycmF5W2ldID0gcmVtb3ZlRm9ybWF0dGluZ1Rva2VucyhhcnJheVtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG1vbSkge1xuICAgICAgICAgICAgdmFyIG91dHB1dCA9ICcnLFxuICAgICAgICAgICAgICAgIGk7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQgKz0gaXNGdW5jdGlvbihhcnJheVtpXSlcbiAgICAgICAgICAgICAgICAgICAgPyBhcnJheVtpXS5jYWxsKG1vbSwgZm9ybWF0KVxuICAgICAgICAgICAgICAgICAgICA6IGFycmF5W2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBmb3JtYXQgZGF0ZSB1c2luZyBuYXRpdmUgZGF0ZSBvYmplY3RcbiAgICBmdW5jdGlvbiBmb3JtYXRNb21lbnQobSwgZm9ybWF0KSB7XG4gICAgICAgIGlmICghbS5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBtLmxvY2FsZURhdGEoKS5pbnZhbGlkRGF0ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9ybWF0ID0gZXhwYW5kRm9ybWF0KGZvcm1hdCwgbS5sb2NhbGVEYXRhKCkpO1xuICAgICAgICBmb3JtYXRGdW5jdGlvbnNbZm9ybWF0XSA9XG4gICAgICAgICAgICBmb3JtYXRGdW5jdGlvbnNbZm9ybWF0XSB8fCBtYWtlRm9ybWF0RnVuY3Rpb24oZm9ybWF0KTtcblxuICAgICAgICByZXR1cm4gZm9ybWF0RnVuY3Rpb25zW2Zvcm1hdF0obSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXhwYW5kRm9ybWF0KGZvcm1hdCwgbG9jYWxlKSB7XG4gICAgICAgIHZhciBpID0gNTtcblxuICAgICAgICBmdW5jdGlvbiByZXBsYWNlTG9uZ0RhdGVGb3JtYXRUb2tlbnMoaW5wdXQpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbGUubG9uZ0RhdGVGb3JtYXQoaW5wdXQpIHx8IGlucHV0O1xuICAgICAgICB9XG5cbiAgICAgICAgbG9jYWxGb3JtYXR0aW5nVG9rZW5zLmxhc3RJbmRleCA9IDA7XG4gICAgICAgIHdoaWxlIChpID49IDAgJiYgbG9jYWxGb3JtYXR0aW5nVG9rZW5zLnRlc3QoZm9ybWF0KSkge1xuICAgICAgICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UoXG4gICAgICAgICAgICAgICAgbG9jYWxGb3JtYXR0aW5nVG9rZW5zLFxuICAgICAgICAgICAgICAgIHJlcGxhY2VMb25nRGF0ZUZvcm1hdFRva2Vuc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGxvY2FsRm9ybWF0dGluZ1Rva2Vucy5sYXN0SW5kZXggPSAwO1xuICAgICAgICAgICAgaSAtPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZvcm1hdDtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdExvbmdEYXRlRm9ybWF0ID0ge1xuICAgICAgICBMVFM6ICdoOm1tOnNzIEEnLFxuICAgICAgICBMVDogJ2g6bW0gQScsXG4gICAgICAgIEw6ICdNTS9ERC9ZWVlZJyxcbiAgICAgICAgTEw6ICdNTU1NIEQsIFlZWVknLFxuICAgICAgICBMTEw6ICdNTU1NIEQsIFlZWVkgaDptbSBBJyxcbiAgICAgICAgTExMTDogJ2RkZGQsIE1NTU0gRCwgWVlZWSBoOm1tIEEnLFxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBsb25nRGF0ZUZvcm1hdChrZXkpIHtcbiAgICAgICAgdmFyIGZvcm1hdCA9IHRoaXMuX2xvbmdEYXRlRm9ybWF0W2tleV0sXG4gICAgICAgICAgICBmb3JtYXRVcHBlciA9IHRoaXMuX2xvbmdEYXRlRm9ybWF0W2tleS50b1VwcGVyQ2FzZSgpXTtcblxuICAgICAgICBpZiAoZm9ybWF0IHx8ICFmb3JtYXRVcHBlcikge1xuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2xvbmdEYXRlRm9ybWF0W2tleV0gPSBmb3JtYXRVcHBlclxuICAgICAgICAgICAgLm1hdGNoKGZvcm1hdHRpbmdUb2tlbnMpXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uICh0b2spIHtcbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgIHRvayA9PT0gJ01NTU0nIHx8XG4gICAgICAgICAgICAgICAgICAgIHRvayA9PT0gJ01NJyB8fFxuICAgICAgICAgICAgICAgICAgICB0b2sgPT09ICdERCcgfHxcbiAgICAgICAgICAgICAgICAgICAgdG9rID09PSAnZGRkZCdcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRvay5zbGljZSgxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRvaztcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuam9pbignJyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvbmdEYXRlRm9ybWF0W2tleV07XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRJbnZhbGlkRGF0ZSA9ICdJbnZhbGlkIGRhdGUnO1xuXG4gICAgZnVuY3Rpb24gaW52YWxpZERhdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnZhbGlkRGF0ZTtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdE9yZGluYWwgPSAnJWQnLFxuICAgICAgICBkZWZhdWx0RGF5T2ZNb250aE9yZGluYWxQYXJzZSA9IC9cXGR7MSwyfS87XG5cbiAgICBmdW5jdGlvbiBvcmRpbmFsKG51bWJlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5fb3JkaW5hbC5yZXBsYWNlKCclZCcsIG51bWJlcik7XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRSZWxhdGl2ZVRpbWUgPSB7XG4gICAgICAgIGZ1dHVyZTogJ2luICVzJyxcbiAgICAgICAgcGFzdDogJyVzIGFnbycsXG4gICAgICAgIHM6ICdhIGZldyBzZWNvbmRzJyxcbiAgICAgICAgc3M6ICclZCBzZWNvbmRzJyxcbiAgICAgICAgbTogJ2EgbWludXRlJyxcbiAgICAgICAgbW06ICclZCBtaW51dGVzJyxcbiAgICAgICAgaDogJ2FuIGhvdXInLFxuICAgICAgICBoaDogJyVkIGhvdXJzJyxcbiAgICAgICAgZDogJ2EgZGF5JyxcbiAgICAgICAgZGQ6ICclZCBkYXlzJyxcbiAgICAgICAgdzogJ2Egd2VlaycsXG4gICAgICAgIHd3OiAnJWQgd2Vla3MnLFxuICAgICAgICBNOiAnYSBtb250aCcsXG4gICAgICAgIE1NOiAnJWQgbW9udGhzJyxcbiAgICAgICAgeTogJ2EgeWVhcicsXG4gICAgICAgIHl5OiAnJWQgeWVhcnMnLFxuICAgIH07XG5cbiAgICBmdW5jdGlvbiByZWxhdGl2ZVRpbWUobnVtYmVyLCB3aXRob3V0U3VmZml4LCBzdHJpbmcsIGlzRnV0dXJlKSB7XG4gICAgICAgIHZhciBvdXRwdXQgPSB0aGlzLl9yZWxhdGl2ZVRpbWVbc3RyaW5nXTtcbiAgICAgICAgcmV0dXJuIGlzRnVuY3Rpb24ob3V0cHV0KVxuICAgICAgICAgICAgPyBvdXRwdXQobnVtYmVyLCB3aXRob3V0U3VmZml4LCBzdHJpbmcsIGlzRnV0dXJlKVxuICAgICAgICAgICAgOiBvdXRwdXQucmVwbGFjZSgvJWQvaSwgbnVtYmVyKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXN0RnV0dXJlKGRpZmYsIG91dHB1dCkge1xuICAgICAgICB2YXIgZm9ybWF0ID0gdGhpcy5fcmVsYXRpdmVUaW1lW2RpZmYgPiAwID8gJ2Z1dHVyZScgOiAncGFzdCddO1xuICAgICAgICByZXR1cm4gaXNGdW5jdGlvbihmb3JtYXQpID8gZm9ybWF0KG91dHB1dCkgOiBmb3JtYXQucmVwbGFjZSgvJXMvaSwgb3V0cHV0KTtcbiAgICB9XG5cbiAgICB2YXIgYWxpYXNlcyA9IHt9O1xuXG4gICAgZnVuY3Rpb24gYWRkVW5pdEFsaWFzKHVuaXQsIHNob3J0aGFuZCkge1xuICAgICAgICB2YXIgbG93ZXJDYXNlID0gdW5pdC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBhbGlhc2VzW2xvd2VyQ2FzZV0gPSBhbGlhc2VzW2xvd2VyQ2FzZSArICdzJ10gPSBhbGlhc2VzW3Nob3J0aGFuZF0gPSB1bml0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZVVuaXRzKHVuaXRzKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdW5pdHMgPT09ICdzdHJpbmcnXG4gICAgICAgICAgICA/IGFsaWFzZXNbdW5pdHNdIHx8IGFsaWFzZXNbdW5pdHMudG9Mb3dlckNhc2UoKV1cbiAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZU9iamVjdFVuaXRzKGlucHV0T2JqZWN0KSB7XG4gICAgICAgIHZhciBub3JtYWxpemVkSW5wdXQgPSB7fSxcbiAgICAgICAgICAgIG5vcm1hbGl6ZWRQcm9wLFxuICAgICAgICAgICAgcHJvcDtcblxuICAgICAgICBmb3IgKHByb3AgaW4gaW5wdXRPYmplY3QpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wKGlucHV0T2JqZWN0LCBwcm9wKSkge1xuICAgICAgICAgICAgICAgIG5vcm1hbGl6ZWRQcm9wID0gbm9ybWFsaXplVW5pdHMocHJvcCk7XG4gICAgICAgICAgICAgICAgaWYgKG5vcm1hbGl6ZWRQcm9wKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vcm1hbGl6ZWRJbnB1dFtub3JtYWxpemVkUHJvcF0gPSBpbnB1dE9iamVjdFtwcm9wXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbm9ybWFsaXplZElucHV0O1xuICAgIH1cblxuICAgIHZhciBwcmlvcml0aWVzID0ge307XG5cbiAgICBmdW5jdGlvbiBhZGRVbml0UHJpb3JpdHkodW5pdCwgcHJpb3JpdHkpIHtcbiAgICAgICAgcHJpb3JpdGllc1t1bml0XSA9IHByaW9yaXR5O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFByaW9yaXRpemVkVW5pdHModW5pdHNPYmopIHtcbiAgICAgICAgdmFyIHVuaXRzID0gW10sXG4gICAgICAgICAgICB1O1xuICAgICAgICBmb3IgKHUgaW4gdW5pdHNPYmopIHtcbiAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wKHVuaXRzT2JqLCB1KSkge1xuICAgICAgICAgICAgICAgIHVuaXRzLnB1c2goeyB1bml0OiB1LCBwcmlvcml0eTogcHJpb3JpdGllc1t1XSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB1bml0cy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gYS5wcmlvcml0eSAtIGIucHJpb3JpdHk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdW5pdHM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNMZWFwWWVhcih5ZWFyKSB7XG4gICAgICAgIHJldHVybiAoeWVhciAlIDQgPT09IDAgJiYgeWVhciAlIDEwMCAhPT0gMCkgfHwgeWVhciAlIDQwMCA9PT0gMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhYnNGbG9vcihudW1iZXIpIHtcbiAgICAgICAgaWYgKG51bWJlciA8IDApIHtcbiAgICAgICAgICAgIC8vIC0wIC0+IDBcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmNlaWwobnVtYmVyKSB8fCAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IobnVtYmVyKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvSW50KGFyZ3VtZW50Rm9yQ29lcmNpb24pIHtcbiAgICAgICAgdmFyIGNvZXJjZWROdW1iZXIgPSArYXJndW1lbnRGb3JDb2VyY2lvbixcbiAgICAgICAgICAgIHZhbHVlID0gMDtcblxuICAgICAgICBpZiAoY29lcmNlZE51bWJlciAhPT0gMCAmJiBpc0Zpbml0ZShjb2VyY2VkTnVtYmVyKSkge1xuICAgICAgICAgICAgdmFsdWUgPSBhYnNGbG9vcihjb2VyY2VkTnVtYmVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYWtlR2V0U2V0KHVuaXQsIGtlZXBUaW1lKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgc2V0JDEodGhpcywgdW5pdCwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIGhvb2tzLnVwZGF0ZU9mZnNldCh0aGlzLCBrZWVwVGltZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZXQodGhpcywgdW5pdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0KG1vbSwgdW5pdCkge1xuICAgICAgICByZXR1cm4gbW9tLmlzVmFsaWQoKVxuICAgICAgICAgICAgPyBtb20uX2RbJ2dldCcgKyAobW9tLl9pc1VUQyA/ICdVVEMnIDogJycpICsgdW5pdF0oKVxuICAgICAgICAgICAgOiBOYU47XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0JDEobW9tLCB1bml0LCB2YWx1ZSkge1xuICAgICAgICBpZiAobW9tLmlzVmFsaWQoKSAmJiAhaXNOYU4odmFsdWUpKSB7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgdW5pdCA9PT0gJ0Z1bGxZZWFyJyAmJlxuICAgICAgICAgICAgICAgIGlzTGVhcFllYXIobW9tLnllYXIoKSkgJiZcbiAgICAgICAgICAgICAgICBtb20ubW9udGgoKSA9PT0gMSAmJlxuICAgICAgICAgICAgICAgIG1vbS5kYXRlKCkgPT09IDI5XG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHRvSW50KHZhbHVlKTtcbiAgICAgICAgICAgICAgICBtb20uX2RbJ3NldCcgKyAobW9tLl9pc1VUQyA/ICdVVEMnIDogJycpICsgdW5pdF0oXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBtb20ubW9udGgoKSxcbiAgICAgICAgICAgICAgICAgICAgZGF5c0luTW9udGgodmFsdWUsIG1vbS5tb250aCgpKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG1vbS5fZFsnc2V0JyArIChtb20uX2lzVVRDID8gJ1VUQycgOiAnJykgKyB1bml0XSh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICBmdW5jdGlvbiBzdHJpbmdHZXQodW5pdHMpIHtcbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKHRoaXNbdW5pdHNdKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXNbdW5pdHNdKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc3RyaW5nU2V0KHVuaXRzLCB2YWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mIHVuaXRzID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgdW5pdHMgPSBub3JtYWxpemVPYmplY3RVbml0cyh1bml0cyk7XG4gICAgICAgICAgICB2YXIgcHJpb3JpdGl6ZWQgPSBnZXRQcmlvcml0aXplZFVuaXRzKHVuaXRzKSxcbiAgICAgICAgICAgICAgICBpO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHByaW9yaXRpemVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpc1twcmlvcml0aXplZFtpXS51bml0XSh1bml0c1twcmlvcml0aXplZFtpXS51bml0XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcbiAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKHRoaXNbdW5pdHNdKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzW3VuaXRzXSh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdmFyIG1hdGNoMSA9IC9cXGQvLCAvLyAgICAgICAwIC0gOVxuICAgICAgICBtYXRjaDIgPSAvXFxkXFxkLywgLy8gICAgICAwMCAtIDk5XG4gICAgICAgIG1hdGNoMyA9IC9cXGR7M30vLCAvLyAgICAgMDAwIC0gOTk5XG4gICAgICAgIG1hdGNoNCA9IC9cXGR7NH0vLCAvLyAgICAwMDAwIC0gOTk5OVxuICAgICAgICBtYXRjaDYgPSAvWystXT9cXGR7Nn0vLCAvLyAtOTk5OTk5IC0gOTk5OTk5XG4gICAgICAgIG1hdGNoMXRvMiA9IC9cXGRcXGQ/LywgLy8gICAgICAgMCAtIDk5XG4gICAgICAgIG1hdGNoM3RvNCA9IC9cXGRcXGRcXGRcXGQ/LywgLy8gICAgIDk5OSAtIDk5OTlcbiAgICAgICAgbWF0Y2g1dG82ID0gL1xcZFxcZFxcZFxcZFxcZFxcZD8vLCAvLyAgIDk5OTk5IC0gOTk5OTk5XG4gICAgICAgIG1hdGNoMXRvMyA9IC9cXGR7MSwzfS8sIC8vICAgICAgIDAgLSA5OTlcbiAgICAgICAgbWF0Y2gxdG80ID0gL1xcZHsxLDR9LywgLy8gICAgICAgMCAtIDk5OTlcbiAgICAgICAgbWF0Y2gxdG82ID0gL1srLV0/XFxkezEsNn0vLCAvLyAtOTk5OTk5IC0gOTk5OTk5XG4gICAgICAgIG1hdGNoVW5zaWduZWQgPSAvXFxkKy8sIC8vICAgICAgIDAgLSBpbmZcbiAgICAgICAgbWF0Y2hTaWduZWQgPSAvWystXT9cXGQrLywgLy8gICAgLWluZiAtIGluZlxuICAgICAgICBtYXRjaE9mZnNldCA9IC9afFsrLV1cXGRcXGQ6P1xcZFxcZC9naSwgLy8gKzAwOjAwIC0wMDowMCArMDAwMCAtMDAwMCBvciBaXG4gICAgICAgIG1hdGNoU2hvcnRPZmZzZXQgPSAvWnxbKy1dXFxkXFxkKD86Oj9cXGRcXGQpPy9naSwgLy8gKzAwIC0wMCArMDA6MDAgLTAwOjAwICswMDAwIC0wMDAwIG9yIFpcbiAgICAgICAgbWF0Y2hUaW1lc3RhbXAgPSAvWystXT9cXGQrKFxcLlxcZHsxLDN9KT8vLCAvLyAxMjM0NTY3ODkgMTIzNDU2Nzg5LjEyM1xuICAgICAgICAvLyBhbnkgd29yZCAob3IgdHdvKSBjaGFyYWN0ZXJzIG9yIG51bWJlcnMgaW5jbHVkaW5nIHR3by90aHJlZSB3b3JkIG1vbnRoIGluIGFyYWJpYy5cbiAgICAgICAgLy8gaW5jbHVkZXMgc2NvdHRpc2ggZ2FlbGljIHR3byB3b3JkIGFuZCBoeXBoZW5hdGVkIG1vbnRoc1xuICAgICAgICBtYXRjaFdvcmQgPSAvWzAtOV17MCwyNTZ9WydhLXpcXHUwMEEwLVxcdTA1RkZcXHUwNzAwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGMDdcXHVGRjEwLVxcdUZGRUZdezEsMjU2fXxbXFx1MDYwMC1cXHUwNkZGXFwvXXsxLDI1Nn0oXFxzKj9bXFx1MDYwMC1cXHUwNkZGXXsxLDI1Nn0pezEsMn0vaSxcbiAgICAgICAgcmVnZXhlcztcblxuICAgIHJlZ2V4ZXMgPSB7fTtcblxuICAgIGZ1bmN0aW9uIGFkZFJlZ2V4VG9rZW4odG9rZW4sIHJlZ2V4LCBzdHJpY3RSZWdleCkge1xuICAgICAgICByZWdleGVzW3Rva2VuXSA9IGlzRnVuY3Rpb24ocmVnZXgpXG4gICAgICAgICAgICA/IHJlZ2V4XG4gICAgICAgICAgICA6IGZ1bmN0aW9uIChpc1N0cmljdCwgbG9jYWxlRGF0YSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGlzU3RyaWN0ICYmIHN0cmljdFJlZ2V4ID8gc3RyaWN0UmVnZXggOiByZWdleDtcbiAgICAgICAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRQYXJzZVJlZ2V4Rm9yVG9rZW4odG9rZW4sIGNvbmZpZykge1xuICAgICAgICBpZiAoIWhhc093blByb3AocmVnZXhlcywgdG9rZW4pKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cCh1bmVzY2FwZUZvcm1hdCh0b2tlbikpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlZ2V4ZXNbdG9rZW5dKGNvbmZpZy5fc3RyaWN0LCBjb25maWcuX2xvY2FsZSk7XG4gICAgfVxuXG4gICAgLy8gQ29kZSBmcm9tIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMzU2MTQ5My9pcy10aGVyZS1hLXJlZ2V4cC1lc2NhcGUtZnVuY3Rpb24taW4tamF2YXNjcmlwdFxuICAgIGZ1bmN0aW9uIHVuZXNjYXBlRm9ybWF0KHMpIHtcbiAgICAgICAgcmV0dXJuIHJlZ2V4RXNjYXBlKFxuICAgICAgICAgICAgc1xuICAgICAgICAgICAgICAgIC5yZXBsYWNlKCdcXFxcJywgJycpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFwoXFxbKXxcXFxcKFxcXSl8XFxbKFteXFxdXFxbXSopXFxdfFxcXFwoLikvZywgZnVuY3Rpb24gKFxuICAgICAgICAgICAgICAgICAgICBtYXRjaGVkLFxuICAgICAgICAgICAgICAgICAgICBwMSxcbiAgICAgICAgICAgICAgICAgICAgcDIsXG4gICAgICAgICAgICAgICAgICAgIHAzLFxuICAgICAgICAgICAgICAgICAgICBwNFxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcDEgfHwgcDIgfHwgcDMgfHwgcDQ7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZWdleEVzY2FwZShzKSB7XG4gICAgICAgIHJldHVybiBzLnJlcGxhY2UoL1stXFwvXFxcXF4kKis/LigpfFtcXF17fV0vZywgJ1xcXFwkJicpO1xuICAgIH1cblxuICAgIHZhciB0b2tlbnMgPSB7fTtcblxuICAgIGZ1bmN0aW9uIGFkZFBhcnNlVG9rZW4odG9rZW4sIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBpLFxuICAgICAgICAgICAgZnVuYyA9IGNhbGxiYWNrO1xuICAgICAgICBpZiAodHlwZW9mIHRva2VuID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdG9rZW4gPSBbdG9rZW5dO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc051bWJlcihjYWxsYmFjaykpIHtcbiAgICAgICAgICAgIGZ1bmMgPSBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgICAgICAgICAgICAgYXJyYXlbY2FsbGJhY2tdID0gdG9JbnQoaW5wdXQpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdG9rZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRva2Vuc1t0b2tlbltpXV0gPSBmdW5jO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkV2Vla1BhcnNlVG9rZW4odG9rZW4sIGNhbGxiYWNrKSB7XG4gICAgICAgIGFkZFBhcnNlVG9rZW4odG9rZW4sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZywgdG9rZW4pIHtcbiAgICAgICAgICAgIGNvbmZpZy5fdyA9IGNvbmZpZy5fdyB8fCB7fTtcbiAgICAgICAgICAgIGNhbGxiYWNrKGlucHV0LCBjb25maWcuX3csIGNvbmZpZywgdG9rZW4pO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRUaW1lVG9BcnJheUZyb21Ub2tlbih0b2tlbiwgaW5wdXQsIGNvbmZpZykge1xuICAgICAgICBpZiAoaW5wdXQgIT0gbnVsbCAmJiBoYXNPd25Qcm9wKHRva2VucywgdG9rZW4pKSB7XG4gICAgICAgICAgICB0b2tlbnNbdG9rZW5dKGlucHV0LCBjb25maWcuX2EsIGNvbmZpZywgdG9rZW4pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIFlFQVIgPSAwLFxuICAgICAgICBNT05USCA9IDEsXG4gICAgICAgIERBVEUgPSAyLFxuICAgICAgICBIT1VSID0gMyxcbiAgICAgICAgTUlOVVRFID0gNCxcbiAgICAgICAgU0VDT05EID0gNSxcbiAgICAgICAgTUlMTElTRUNPTkQgPSA2LFxuICAgICAgICBXRUVLID0gNyxcbiAgICAgICAgV0VFS0RBWSA9IDg7XG5cbiAgICBmdW5jdGlvbiBtb2QobiwgeCkge1xuICAgICAgICByZXR1cm4gKChuICUgeCkgKyB4KSAlIHg7XG4gICAgfVxuXG4gICAgdmFyIGluZGV4T2Y7XG5cbiAgICBpZiAoQXJyYXkucHJvdG90eXBlLmluZGV4T2YpIHtcbiAgICAgICAgaW5kZXhPZiA9IEFycmF5LnByb3RvdHlwZS5pbmRleE9mO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGluZGV4T2YgPSBmdW5jdGlvbiAobykge1xuICAgICAgICAgICAgLy8gSSBrbm93XG4gICAgICAgICAgICB2YXIgaTtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXNbaV0gPT09IG8pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRheXNJbk1vbnRoKHllYXIsIG1vbnRoKSB7XG4gICAgICAgIGlmIChpc05hTih5ZWFyKSB8fCBpc05hTihtb250aCkpIHtcbiAgICAgICAgICAgIHJldHVybiBOYU47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1vZE1vbnRoID0gbW9kKG1vbnRoLCAxMik7XG4gICAgICAgIHllYXIgKz0gKG1vbnRoIC0gbW9kTW9udGgpIC8gMTI7XG4gICAgICAgIHJldHVybiBtb2RNb250aCA9PT0gMVxuICAgICAgICAgICAgPyBpc0xlYXBZZWFyKHllYXIpXG4gICAgICAgICAgICAgICAgPyAyOVxuICAgICAgICAgICAgICAgIDogMjhcbiAgICAgICAgICAgIDogMzEgLSAoKG1vZE1vbnRoICUgNykgJSAyKTtcbiAgICB9XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbignTScsIFsnTU0nLCAyXSwgJ01vJywgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb250aCgpICsgMTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdNTU0nLCAwLCAwLCBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5tb250aHNTaG9ydCh0aGlzLCBmb3JtYXQpO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ01NTU0nLCAwLCAwLCBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5tb250aHModGhpcywgZm9ybWF0KTtcbiAgICB9KTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygnbW9udGgnLCAnTScpO1xuXG4gICAgLy8gUFJJT1JJVFlcblxuICAgIGFkZFVuaXRQcmlvcml0eSgnbW9udGgnLCA4KTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ00nLCBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ01NJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ01NTScsIGZ1bmN0aW9uIChpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGUubW9udGhzU2hvcnRSZWdleChpc1N0cmljdCk7XG4gICAgfSk7XG4gICAgYWRkUmVnZXhUb2tlbignTU1NTScsIGZ1bmN0aW9uIChpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGUubW9udGhzUmVnZXgoaXNTdHJpY3QpO1xuICAgIH0pO1xuXG4gICAgYWRkUGFyc2VUb2tlbihbJ00nLCAnTU0nXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSkge1xuICAgICAgICBhcnJheVtNT05USF0gPSB0b0ludChpbnB1dCkgLSAxO1xuICAgIH0pO1xuXG4gICAgYWRkUGFyc2VUb2tlbihbJ01NTScsICdNTU1NJ10sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZywgdG9rZW4pIHtcbiAgICAgICAgdmFyIG1vbnRoID0gY29uZmlnLl9sb2NhbGUubW9udGhzUGFyc2UoaW5wdXQsIHRva2VuLCBjb25maWcuX3N0cmljdCk7XG4gICAgICAgIC8vIGlmIHdlIGRpZG4ndCBmaW5kIGEgbW9udGggbmFtZSwgbWFyayB0aGUgZGF0ZSBhcyBpbnZhbGlkLlxuICAgICAgICBpZiAobW9udGggIT0gbnVsbCkge1xuICAgICAgICAgICAgYXJyYXlbTU9OVEhdID0gbW9udGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5pbnZhbGlkTW9udGggPSBpbnB1dDtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gTE9DQUxFU1xuXG4gICAgdmFyIGRlZmF1bHRMb2NhbGVNb250aHMgPSAnSmFudWFyeV9GZWJydWFyeV9NYXJjaF9BcHJpbF9NYXlfSnVuZV9KdWx5X0F1Z3VzdF9TZXB0ZW1iZXJfT2N0b2Jlcl9Ob3ZlbWJlcl9EZWNlbWJlcicuc3BsaXQoXG4gICAgICAgICAgICAnXydcbiAgICAgICAgKSxcbiAgICAgICAgZGVmYXVsdExvY2FsZU1vbnRoc1Nob3J0ID0gJ0phbl9GZWJfTWFyX0Fwcl9NYXlfSnVuX0p1bF9BdWdfU2VwX09jdF9Ob3ZfRGVjJy5zcGxpdChcbiAgICAgICAgICAgICdfJ1xuICAgICAgICApLFxuICAgICAgICBNT05USFNfSU5fRk9STUFUID0gL0Rbb0RdPyhcXFtbXlxcW1xcXV0qXFxdfFxccykrTU1NTT8vLFxuICAgICAgICBkZWZhdWx0TW9udGhzU2hvcnRSZWdleCA9IG1hdGNoV29yZCxcbiAgICAgICAgZGVmYXVsdE1vbnRoc1JlZ2V4ID0gbWF0Y2hXb3JkO1xuXG4gICAgZnVuY3Rpb24gbG9jYWxlTW9udGhzKG0sIGZvcm1hdCkge1xuICAgICAgICBpZiAoIW0pIHtcbiAgICAgICAgICAgIHJldHVybiBpc0FycmF5KHRoaXMuX21vbnRocylcbiAgICAgICAgICAgICAgICA/IHRoaXMuX21vbnRoc1xuICAgICAgICAgICAgICAgIDogdGhpcy5fbW9udGhzWydzdGFuZGFsb25lJ107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlzQXJyYXkodGhpcy5fbW9udGhzKVxuICAgICAgICAgICAgPyB0aGlzLl9tb250aHNbbS5tb250aCgpXVxuICAgICAgICAgICAgOiB0aGlzLl9tb250aHNbXG4gICAgICAgICAgICAgICAgICAodGhpcy5fbW9udGhzLmlzRm9ybWF0IHx8IE1PTlRIU19JTl9GT1JNQVQpLnRlc3QoZm9ybWF0KVxuICAgICAgICAgICAgICAgICAgICAgID8gJ2Zvcm1hdCdcbiAgICAgICAgICAgICAgICAgICAgICA6ICdzdGFuZGFsb25lJ1xuICAgICAgICAgICAgICBdW20ubW9udGgoKV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9jYWxlTW9udGhzU2hvcnQobSwgZm9ybWF0KSB7XG4gICAgICAgIGlmICghbSkge1xuICAgICAgICAgICAgcmV0dXJuIGlzQXJyYXkodGhpcy5fbW9udGhzU2hvcnQpXG4gICAgICAgICAgICAgICAgPyB0aGlzLl9tb250aHNTaG9ydFxuICAgICAgICAgICAgICAgIDogdGhpcy5fbW9udGhzU2hvcnRbJ3N0YW5kYWxvbmUnXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXNBcnJheSh0aGlzLl9tb250aHNTaG9ydClcbiAgICAgICAgICAgID8gdGhpcy5fbW9udGhzU2hvcnRbbS5tb250aCgpXVxuICAgICAgICAgICAgOiB0aGlzLl9tb250aHNTaG9ydFtcbiAgICAgICAgICAgICAgICAgIE1PTlRIU19JTl9GT1JNQVQudGVzdChmb3JtYXQpID8gJ2Zvcm1hdCcgOiAnc3RhbmRhbG9uZSdcbiAgICAgICAgICAgICAgXVttLm1vbnRoKCldO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhbmRsZVN0cmljdFBhcnNlKG1vbnRoTmFtZSwgZm9ybWF0LCBzdHJpY3QpIHtcbiAgICAgICAgdmFyIGksXG4gICAgICAgICAgICBpaSxcbiAgICAgICAgICAgIG1vbSxcbiAgICAgICAgICAgIGxsYyA9IG1vbnRoTmFtZS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAoIXRoaXMuX21vbnRoc1BhcnNlKSB7XG4gICAgICAgICAgICAvLyB0aGlzIGlzIG5vdCB1c2VkXG4gICAgICAgICAgICB0aGlzLl9tb250aHNQYXJzZSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fbG9uZ01vbnRoc1BhcnNlID0gW107XG4gICAgICAgICAgICB0aGlzLl9zaG9ydE1vbnRoc1BhcnNlID0gW107XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMTI7ICsraSkge1xuICAgICAgICAgICAgICAgIG1vbSA9IGNyZWF0ZVVUQyhbMjAwMCwgaV0pO1xuICAgICAgICAgICAgICAgIHRoaXMuX3Nob3J0TW9udGhzUGFyc2VbaV0gPSB0aGlzLm1vbnRoc1Nob3J0KFxuICAgICAgICAgICAgICAgICAgICBtb20sXG4gICAgICAgICAgICAgICAgICAgICcnXG4gICAgICAgICAgICAgICAgKS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2xvbmdNb250aHNQYXJzZVtpXSA9IHRoaXMubW9udGhzKG1vbSwgJycpLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RyaWN0KSB7XG4gICAgICAgICAgICBpZiAoZm9ybWF0ID09PSAnTU1NJykge1xuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3Nob3J0TW9udGhzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fbG9uZ01vbnRoc1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoZm9ybWF0ID09PSAnTU1NJykge1xuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3Nob3J0TW9udGhzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX2xvbmdNb250aHNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9sb25nTW9udGhzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3Nob3J0TW9udGhzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvY2FsZU1vbnRoc1BhcnNlKG1vbnRoTmFtZSwgZm9ybWF0LCBzdHJpY3QpIHtcbiAgICAgICAgdmFyIGksIG1vbSwgcmVnZXg7XG5cbiAgICAgICAgaWYgKHRoaXMuX21vbnRoc1BhcnNlRXhhY3QpIHtcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGVTdHJpY3RQYXJzZS5jYWxsKHRoaXMsIG1vbnRoTmFtZSwgZm9ybWF0LCBzdHJpY3QpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLl9tb250aHNQYXJzZSkge1xuICAgICAgICAgICAgdGhpcy5fbW9udGhzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX2xvbmdNb250aHNQYXJzZSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fc2hvcnRNb250aHNQYXJzZSA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVE9ETzogYWRkIHNvcnRpbmdcbiAgICAgICAgLy8gU29ydGluZyBtYWtlcyBzdXJlIGlmIG9uZSBtb250aCAob3IgYWJicikgaXMgYSBwcmVmaXggb2YgYW5vdGhlclxuICAgICAgICAvLyBzZWUgc29ydGluZyBpbiBjb21wdXRlTW9udGhzUGFyc2VcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDEyOyBpKyspIHtcbiAgICAgICAgICAgIC8vIG1ha2UgdGhlIHJlZ2V4IGlmIHdlIGRvbid0IGhhdmUgaXQgYWxyZWFkeVxuICAgICAgICAgICAgbW9tID0gY3JlYXRlVVRDKFsyMDAwLCBpXSk7XG4gICAgICAgICAgICBpZiAoc3RyaWN0ICYmICF0aGlzLl9sb25nTW9udGhzUGFyc2VbaV0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9sb25nTW9udGhzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKFxuICAgICAgICAgICAgICAgICAgICAnXicgKyB0aGlzLm1vbnRocyhtb20sICcnKS5yZXBsYWNlKCcuJywgJycpICsgJyQnLFxuICAgICAgICAgICAgICAgICAgICAnaSdcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHRoaXMuX3Nob3J0TW9udGhzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKFxuICAgICAgICAgICAgICAgICAgICAnXicgKyB0aGlzLm1vbnRoc1Nob3J0KG1vbSwgJycpLnJlcGxhY2UoJy4nLCAnJykgKyAnJCcsXG4gICAgICAgICAgICAgICAgICAgICdpJ1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXN0cmljdCAmJiAhdGhpcy5fbW9udGhzUGFyc2VbaV0pIHtcbiAgICAgICAgICAgICAgICByZWdleCA9XG4gICAgICAgICAgICAgICAgICAgICdeJyArIHRoaXMubW9udGhzKG1vbSwgJycpICsgJ3xeJyArIHRoaXMubW9udGhzU2hvcnQobW9tLCAnJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fbW9udGhzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKHJlZ2V4LnJlcGxhY2UoJy4nLCAnJyksICdpJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB0ZXN0IHRoZSByZWdleFxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIHN0cmljdCAmJlxuICAgICAgICAgICAgICAgIGZvcm1hdCA9PT0gJ01NTU0nICYmXG4gICAgICAgICAgICAgICAgdGhpcy5fbG9uZ01vbnRoc1BhcnNlW2ldLnRlc3QobW9udGhOYW1lKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgICAgIHN0cmljdCAmJlxuICAgICAgICAgICAgICAgIGZvcm1hdCA9PT0gJ01NTScgJiZcbiAgICAgICAgICAgICAgICB0aGlzLl9zaG9ydE1vbnRoc1BhcnNlW2ldLnRlc3QobW9udGhOYW1lKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFzdHJpY3QgJiYgdGhpcy5fbW9udGhzUGFyc2VbaV0udGVzdChtb250aE5hbWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICBmdW5jdGlvbiBzZXRNb250aChtb20sIHZhbHVlKSB7XG4gICAgICAgIHZhciBkYXlPZk1vbnRoO1xuXG4gICAgICAgIGlmICghbW9tLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgLy8gTm8gb3BcbiAgICAgICAgICAgIHJldHVybiBtb207XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgaWYgKC9eXFxkKyQvLnRlc3QodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB0b0ludCh2YWx1ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gbW9tLmxvY2FsZURhdGEoKS5tb250aHNQYXJzZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogQW5vdGhlciBzaWxlbnQgZmFpbHVyZT9cbiAgICAgICAgICAgICAgICBpZiAoIWlzTnVtYmVyKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbW9tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGRheU9mTW9udGggPSBNYXRoLm1pbihtb20uZGF0ZSgpLCBkYXlzSW5Nb250aChtb20ueWVhcigpLCB2YWx1ZSkpO1xuICAgICAgICBtb20uX2RbJ3NldCcgKyAobW9tLl9pc1VUQyA/ICdVVEMnIDogJycpICsgJ01vbnRoJ10odmFsdWUsIGRheU9mTW9udGgpO1xuICAgICAgICByZXR1cm4gbW9tO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFNldE1vbnRoKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBzZXRNb250aCh0aGlzLCB2YWx1ZSk7XG4gICAgICAgICAgICBob29rcy51cGRhdGVPZmZzZXQodGhpcywgdHJ1ZSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBnZXQodGhpcywgJ01vbnRoJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXREYXlzSW5Nb250aCgpIHtcbiAgICAgICAgcmV0dXJuIGRheXNJbk1vbnRoKHRoaXMueWVhcigpLCB0aGlzLm1vbnRoKCkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1vbnRoc1Nob3J0UmVnZXgoaXNTdHJpY3QpIHtcbiAgICAgICAgaWYgKHRoaXMuX21vbnRoc1BhcnNlRXhhY3QpIHtcbiAgICAgICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX21vbnRoc1JlZ2V4JykpIHtcbiAgICAgICAgICAgICAgICBjb21wdXRlTW9udGhzUGFyc2UuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1N0cmljdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9tb250aHNTaG9ydFN0cmljdFJlZ2V4O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzU2hvcnRSZWdleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX21vbnRoc1Nob3J0UmVnZXgnKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX21vbnRoc1Nob3J0UmVnZXggPSBkZWZhdWx0TW9udGhzU2hvcnRSZWdleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9tb250aHNTaG9ydFN0cmljdFJlZ2V4ICYmIGlzU3RyaWN0XG4gICAgICAgICAgICAgICAgPyB0aGlzLl9tb250aHNTaG9ydFN0cmljdFJlZ2V4XG4gICAgICAgICAgICAgICAgOiB0aGlzLl9tb250aHNTaG9ydFJlZ2V4O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbW9udGhzUmVnZXgoaXNTdHJpY3QpIHtcbiAgICAgICAgaWYgKHRoaXMuX21vbnRoc1BhcnNlRXhhY3QpIHtcbiAgICAgICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX21vbnRoc1JlZ2V4JykpIHtcbiAgICAgICAgICAgICAgICBjb21wdXRlTW9udGhzUGFyc2UuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1N0cmljdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9tb250aHNTdHJpY3RSZWdleDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21vbnRoc1JlZ2V4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfbW9udGhzUmVnZXgnKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX21vbnRoc1JlZ2V4ID0gZGVmYXVsdE1vbnRoc1JlZ2V4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21vbnRoc1N0cmljdFJlZ2V4ICYmIGlzU3RyaWN0XG4gICAgICAgICAgICAgICAgPyB0aGlzLl9tb250aHNTdHJpY3RSZWdleFxuICAgICAgICAgICAgICAgIDogdGhpcy5fbW9udGhzUmVnZXg7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb21wdXRlTW9udGhzUGFyc2UoKSB7XG4gICAgICAgIGZ1bmN0aW9uIGNtcExlblJldihhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gYi5sZW5ndGggLSBhLmxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzaG9ydFBpZWNlcyA9IFtdLFxuICAgICAgICAgICAgbG9uZ1BpZWNlcyA9IFtdLFxuICAgICAgICAgICAgbWl4ZWRQaWVjZXMgPSBbXSxcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICBtb207XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCAxMjsgaSsrKSB7XG4gICAgICAgICAgICAvLyBtYWtlIHRoZSByZWdleCBpZiB3ZSBkb24ndCBoYXZlIGl0IGFscmVhZHlcbiAgICAgICAgICAgIG1vbSA9IGNyZWF0ZVVUQyhbMjAwMCwgaV0pO1xuICAgICAgICAgICAgc2hvcnRQaWVjZXMucHVzaCh0aGlzLm1vbnRoc1Nob3J0KG1vbSwgJycpKTtcbiAgICAgICAgICAgIGxvbmdQaWVjZXMucHVzaCh0aGlzLm1vbnRocyhtb20sICcnKSk7XG4gICAgICAgICAgICBtaXhlZFBpZWNlcy5wdXNoKHRoaXMubW9udGhzKG1vbSwgJycpKTtcbiAgICAgICAgICAgIG1peGVkUGllY2VzLnB1c2godGhpcy5tb250aHNTaG9ydChtb20sICcnKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU29ydGluZyBtYWtlcyBzdXJlIGlmIG9uZSBtb250aCAob3IgYWJicikgaXMgYSBwcmVmaXggb2YgYW5vdGhlciBpdFxuICAgICAgICAvLyB3aWxsIG1hdGNoIHRoZSBsb25nZXIgcGllY2UuXG4gICAgICAgIHNob3J0UGllY2VzLnNvcnQoY21wTGVuUmV2KTtcbiAgICAgICAgbG9uZ1BpZWNlcy5zb3J0KGNtcExlblJldik7XG4gICAgICAgIG1peGVkUGllY2VzLnNvcnQoY21wTGVuUmV2KTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDEyOyBpKyspIHtcbiAgICAgICAgICAgIHNob3J0UGllY2VzW2ldID0gcmVnZXhFc2NhcGUoc2hvcnRQaWVjZXNbaV0pO1xuICAgICAgICAgICAgbG9uZ1BpZWNlc1tpXSA9IHJlZ2V4RXNjYXBlKGxvbmdQaWVjZXNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCAyNDsgaSsrKSB7XG4gICAgICAgICAgICBtaXhlZFBpZWNlc1tpXSA9IHJlZ2V4RXNjYXBlKG1peGVkUGllY2VzW2ldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX21vbnRoc1JlZ2V4ID0gbmV3IFJlZ0V4cCgnXignICsgbWl4ZWRQaWVjZXMuam9pbignfCcpICsgJyknLCAnaScpO1xuICAgICAgICB0aGlzLl9tb250aHNTaG9ydFJlZ2V4ID0gdGhpcy5fbW9udGhzUmVnZXg7XG4gICAgICAgIHRoaXMuX21vbnRoc1N0cmljdFJlZ2V4ID0gbmV3IFJlZ0V4cChcbiAgICAgICAgICAgICdeKCcgKyBsb25nUGllY2VzLmpvaW4oJ3wnKSArICcpJyxcbiAgICAgICAgICAgICdpJ1xuICAgICAgICApO1xuICAgICAgICB0aGlzLl9tb250aHNTaG9ydFN0cmljdFJlZ2V4ID0gbmV3IFJlZ0V4cChcbiAgICAgICAgICAgICdeKCcgKyBzaG9ydFBpZWNlcy5qb2luKCd8JykgKyAnKScsXG4gICAgICAgICAgICAnaSdcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbignWScsIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHkgPSB0aGlzLnllYXIoKTtcbiAgICAgICAgcmV0dXJuIHkgPD0gOTk5OSA/IHplcm9GaWxsKHksIDQpIDogJysnICsgeTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnWVknLCAyXSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy55ZWFyKCkgJSAxMDA7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1lZWVknLCA0XSwgMCwgJ3llYXInKTtcbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1lZWVlZJywgNV0sIDAsICd5ZWFyJyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydZWVlZWVknLCA2LCB0cnVlXSwgMCwgJ3llYXInKTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygneWVhcicsICd5Jyk7XG5cbiAgICAvLyBQUklPUklUSUVTXG5cbiAgICBhZGRVbml0UHJpb3JpdHkoJ3llYXInLCAxKTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ1knLCBtYXRjaFNpZ25lZCk7XG4gICAgYWRkUmVnZXhUb2tlbignWVknLCBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgYWRkUmVnZXhUb2tlbignWVlZWScsIG1hdGNoMXRvNCwgbWF0Y2g0KTtcbiAgICBhZGRSZWdleFRva2VuKCdZWVlZWScsIG1hdGNoMXRvNiwgbWF0Y2g2KTtcbiAgICBhZGRSZWdleFRva2VuKCdZWVlZWVknLCBtYXRjaDF0bzYsIG1hdGNoNik7XG5cbiAgICBhZGRQYXJzZVRva2VuKFsnWVlZWVknLCAnWVlZWVlZJ10sIFlFQVIpO1xuICAgIGFkZFBhcnNlVG9rZW4oJ1lZWVknLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgICAgIGFycmF5W1lFQVJdID1cbiAgICAgICAgICAgIGlucHV0Lmxlbmd0aCA9PT0gMiA/IGhvb2tzLnBhcnNlVHdvRGlnaXRZZWFyKGlucHV0KSA6IHRvSW50KGlucHV0KTtcbiAgICB9KTtcbiAgICBhZGRQYXJzZVRva2VuKCdZWScsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICAgICAgYXJyYXlbWUVBUl0gPSBob29rcy5wYXJzZVR3b0RpZ2l0WWVhcihpbnB1dCk7XG4gICAgfSk7XG4gICAgYWRkUGFyc2VUb2tlbignWScsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICAgICAgYXJyYXlbWUVBUl0gPSBwYXJzZUludChpbnB1dCwgMTApO1xuICAgIH0pO1xuXG4gICAgLy8gSEVMUEVSU1xuXG4gICAgZnVuY3Rpb24gZGF5c0luWWVhcih5ZWFyKSB7XG4gICAgICAgIHJldHVybiBpc0xlYXBZZWFyKHllYXIpID8gMzY2IDogMzY1O1xuICAgIH1cblxuICAgIC8vIEhPT0tTXG5cbiAgICBob29rcy5wYXJzZVR3b0RpZ2l0WWVhciA9IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICByZXR1cm4gdG9JbnQoaW5wdXQpICsgKHRvSW50KGlucHV0KSA+IDY4ID8gMTkwMCA6IDIwMDApO1xuICAgIH07XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICB2YXIgZ2V0U2V0WWVhciA9IG1ha2VHZXRTZXQoJ0Z1bGxZZWFyJywgdHJ1ZSk7XG5cbiAgICBmdW5jdGlvbiBnZXRJc0xlYXBZZWFyKCkge1xuICAgICAgICByZXR1cm4gaXNMZWFwWWVhcih0aGlzLnllYXIoKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlRGF0ZSh5LCBtLCBkLCBoLCBNLCBzLCBtcykge1xuICAgICAgICAvLyBjYW4ndCBqdXN0IGFwcGx5KCkgdG8gY3JlYXRlIGEgZGF0ZTpcbiAgICAgICAgLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xLzE4MTM0OFxuICAgICAgICB2YXIgZGF0ZTtcbiAgICAgICAgLy8gdGhlIGRhdGUgY29uc3RydWN0b3IgcmVtYXBzIHllYXJzIDAtOTkgdG8gMTkwMC0xOTk5XG4gICAgICAgIGlmICh5IDwgMTAwICYmIHkgPj0gMCkge1xuICAgICAgICAgICAgLy8gcHJlc2VydmUgbGVhcCB5ZWFycyB1c2luZyBhIGZ1bGwgNDAwIHllYXIgY3ljbGUsIHRoZW4gcmVzZXRcbiAgICAgICAgICAgIGRhdGUgPSBuZXcgRGF0ZSh5ICsgNDAwLCBtLCBkLCBoLCBNLCBzLCBtcyk7XG4gICAgICAgICAgICBpZiAoaXNGaW5pdGUoZGF0ZS5nZXRGdWxsWWVhcigpKSkge1xuICAgICAgICAgICAgICAgIGRhdGUuc2V0RnVsbFllYXIoeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkYXRlID0gbmV3IERhdGUoeSwgbSwgZCwgaCwgTSwgcywgbXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRhdGU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlVVRDRGF0ZSh5KSB7XG4gICAgICAgIHZhciBkYXRlLCBhcmdzO1xuICAgICAgICAvLyB0aGUgRGF0ZS5VVEMgZnVuY3Rpb24gcmVtYXBzIHllYXJzIDAtOTkgdG8gMTkwMC0xOTk5XG4gICAgICAgIGlmICh5IDwgMTAwICYmIHkgPj0gMCkge1xuICAgICAgICAgICAgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAvLyBwcmVzZXJ2ZSBsZWFwIHllYXJzIHVzaW5nIGEgZnVsbCA0MDAgeWVhciBjeWNsZSwgdGhlbiByZXNldFxuICAgICAgICAgICAgYXJnc1swXSA9IHkgKyA0MDA7XG4gICAgICAgICAgICBkYXRlID0gbmV3IERhdGUoRGF0ZS5VVEMuYXBwbHkobnVsbCwgYXJncykpO1xuICAgICAgICAgICAgaWYgKGlzRmluaXRlKGRhdGUuZ2V0VVRDRnVsbFllYXIoKSkpIHtcbiAgICAgICAgICAgICAgICBkYXRlLnNldFVUQ0Z1bGxZZWFyKHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGF0ZSA9IG5ldyBEYXRlKERhdGUuVVRDLmFwcGx5KG51bGwsIGFyZ3VtZW50cykpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRhdGU7XG4gICAgfVxuXG4gICAgLy8gc3RhcnQtb2YtZmlyc3Qtd2VlayAtIHN0YXJ0LW9mLXllYXJcbiAgICBmdW5jdGlvbiBmaXJzdFdlZWtPZmZzZXQoeWVhciwgZG93LCBkb3kpIHtcbiAgICAgICAgdmFyIC8vIGZpcnN0LXdlZWsgZGF5IC0tIHdoaWNoIGphbnVhcnkgaXMgYWx3YXlzIGluIHRoZSBmaXJzdCB3ZWVrICg0IGZvciBpc28sIDEgZm9yIG90aGVyKVxuICAgICAgICAgICAgZndkID0gNyArIGRvdyAtIGRveSxcbiAgICAgICAgICAgIC8vIGZpcnN0LXdlZWsgZGF5IGxvY2FsIHdlZWtkYXkgLS0gd2hpY2ggbG9jYWwgd2Vla2RheSBpcyBmd2RcbiAgICAgICAgICAgIGZ3ZGx3ID0gKDcgKyBjcmVhdGVVVENEYXRlKHllYXIsIDAsIGZ3ZCkuZ2V0VVRDRGF5KCkgLSBkb3cpICUgNztcblxuICAgICAgICByZXR1cm4gLWZ3ZGx3ICsgZndkIC0gMTtcbiAgICB9XG5cbiAgICAvLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JU09fd2Vla19kYXRlI0NhbGN1bGF0aW5nX2FfZGF0ZV9naXZlbl90aGVfeWVhci4yQ193ZWVrX251bWJlcl9hbmRfd2Vla2RheVxuICAgIGZ1bmN0aW9uIGRheU9mWWVhckZyb21XZWVrcyh5ZWFyLCB3ZWVrLCB3ZWVrZGF5LCBkb3csIGRveSkge1xuICAgICAgICB2YXIgbG9jYWxXZWVrZGF5ID0gKDcgKyB3ZWVrZGF5IC0gZG93KSAlIDcsXG4gICAgICAgICAgICB3ZWVrT2Zmc2V0ID0gZmlyc3RXZWVrT2Zmc2V0KHllYXIsIGRvdywgZG95KSxcbiAgICAgICAgICAgIGRheU9mWWVhciA9IDEgKyA3ICogKHdlZWsgLSAxKSArIGxvY2FsV2Vla2RheSArIHdlZWtPZmZzZXQsXG4gICAgICAgICAgICByZXNZZWFyLFxuICAgICAgICAgICAgcmVzRGF5T2ZZZWFyO1xuXG4gICAgICAgIGlmIChkYXlPZlllYXIgPD0gMCkge1xuICAgICAgICAgICAgcmVzWWVhciA9IHllYXIgLSAxO1xuICAgICAgICAgICAgcmVzRGF5T2ZZZWFyID0gZGF5c0luWWVhcihyZXNZZWFyKSArIGRheU9mWWVhcjtcbiAgICAgICAgfSBlbHNlIGlmIChkYXlPZlllYXIgPiBkYXlzSW5ZZWFyKHllYXIpKSB7XG4gICAgICAgICAgICByZXNZZWFyID0geWVhciArIDE7XG4gICAgICAgICAgICByZXNEYXlPZlllYXIgPSBkYXlPZlllYXIgLSBkYXlzSW5ZZWFyKHllYXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzWWVhciA9IHllYXI7XG4gICAgICAgICAgICByZXNEYXlPZlllYXIgPSBkYXlPZlllYXI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeWVhcjogcmVzWWVhcixcbiAgICAgICAgICAgIGRheU9mWWVhcjogcmVzRGF5T2ZZZWFyLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHdlZWtPZlllYXIobW9tLCBkb3csIGRveSkge1xuICAgICAgICB2YXIgd2Vla09mZnNldCA9IGZpcnN0V2Vla09mZnNldChtb20ueWVhcigpLCBkb3csIGRveSksXG4gICAgICAgICAgICB3ZWVrID0gTWF0aC5mbG9vcigobW9tLmRheU9mWWVhcigpIC0gd2Vla09mZnNldCAtIDEpIC8gNykgKyAxLFxuICAgICAgICAgICAgcmVzV2VlayxcbiAgICAgICAgICAgIHJlc1llYXI7XG5cbiAgICAgICAgaWYgKHdlZWsgPCAxKSB7XG4gICAgICAgICAgICByZXNZZWFyID0gbW9tLnllYXIoKSAtIDE7XG4gICAgICAgICAgICByZXNXZWVrID0gd2VlayArIHdlZWtzSW5ZZWFyKHJlc1llYXIsIGRvdywgZG95KTtcbiAgICAgICAgfSBlbHNlIGlmICh3ZWVrID4gd2Vla3NJblllYXIobW9tLnllYXIoKSwgZG93LCBkb3kpKSB7XG4gICAgICAgICAgICByZXNXZWVrID0gd2VlayAtIHdlZWtzSW5ZZWFyKG1vbS55ZWFyKCksIGRvdywgZG95KTtcbiAgICAgICAgICAgIHJlc1llYXIgPSBtb20ueWVhcigpICsgMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc1llYXIgPSBtb20ueWVhcigpO1xuICAgICAgICAgICAgcmVzV2VlayA9IHdlZWs7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgd2VlazogcmVzV2VlayxcbiAgICAgICAgICAgIHllYXI6IHJlc1llYXIsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gd2Vla3NJblllYXIoeWVhciwgZG93LCBkb3kpIHtcbiAgICAgICAgdmFyIHdlZWtPZmZzZXQgPSBmaXJzdFdlZWtPZmZzZXQoeWVhciwgZG93LCBkb3kpLFxuICAgICAgICAgICAgd2Vla09mZnNldE5leHQgPSBmaXJzdFdlZWtPZmZzZXQoeWVhciArIDEsIGRvdywgZG95KTtcbiAgICAgICAgcmV0dXJuIChkYXlzSW5ZZWFyKHllYXIpIC0gd2Vla09mZnNldCArIHdlZWtPZmZzZXROZXh0KSAvIDc7XG4gICAgfVxuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ3cnLCBbJ3d3JywgMl0sICd3bycsICd3ZWVrJyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oJ1cnLCBbJ1dXJywgMl0sICdXbycsICdpc29XZWVrJyk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ3dlZWsnLCAndycpO1xuICAgIGFkZFVuaXRBbGlhcygnaXNvV2VlaycsICdXJyk7XG5cbiAgICAvLyBQUklPUklUSUVTXG5cbiAgICBhZGRVbml0UHJpb3JpdHkoJ3dlZWsnLCA1KTtcbiAgICBhZGRVbml0UHJpb3JpdHkoJ2lzb1dlZWsnLCA1KTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ3cnLCBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ3d3JywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1cnLCBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1dXJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuXG4gICAgYWRkV2Vla1BhcnNlVG9rZW4oWyd3JywgJ3d3JywgJ1cnLCAnV1cnXSwgZnVuY3Rpb24gKFxuICAgICAgICBpbnB1dCxcbiAgICAgICAgd2VlayxcbiAgICAgICAgY29uZmlnLFxuICAgICAgICB0b2tlblxuICAgICkge1xuICAgICAgICB3ZWVrW3Rva2VuLnN1YnN0cigwLCAxKV0gPSB0b0ludChpbnB1dCk7XG4gICAgfSk7XG5cbiAgICAvLyBIRUxQRVJTXG5cbiAgICAvLyBMT0NBTEVTXG5cbiAgICBmdW5jdGlvbiBsb2NhbGVXZWVrKG1vbSkge1xuICAgICAgICByZXR1cm4gd2Vla09mWWVhcihtb20sIHRoaXMuX3dlZWsuZG93LCB0aGlzLl93ZWVrLmRveSkud2VlaztcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdExvY2FsZVdlZWsgPSB7XG4gICAgICAgIGRvdzogMCwgLy8gU3VuZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAgICAgIGRveTogNiwgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gNnRoIGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBsb2NhbGVGaXJzdERheU9mV2VlaygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWsuZG93O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvY2FsZUZpcnN0RGF5T2ZZZWFyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd2Vlay5kb3k7XG4gICAgfVxuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgZnVuY3Rpb24gZ2V0U2V0V2VlayhpbnB1dCkge1xuICAgICAgICB2YXIgd2VlayA9IHRoaXMubG9jYWxlRGF0YSgpLndlZWsodGhpcyk7XG4gICAgICAgIHJldHVybiBpbnB1dCA9PSBudWxsID8gd2VlayA6IHRoaXMuYWRkKChpbnB1dCAtIHdlZWspICogNywgJ2QnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTZXRJU09XZWVrKGlucHV0KSB7XG4gICAgICAgIHZhciB3ZWVrID0gd2Vla09mWWVhcih0aGlzLCAxLCA0KS53ZWVrO1xuICAgICAgICByZXR1cm4gaW5wdXQgPT0gbnVsbCA/IHdlZWsgOiB0aGlzLmFkZCgoaW5wdXQgLSB3ZWVrKSAqIDcsICdkJyk7XG4gICAgfVxuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ2QnLCAwLCAnZG8nLCAnZGF5Jyk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignZGQnLCAwLCAwLCBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS53ZWVrZGF5c01pbih0aGlzLCBmb3JtYXQpO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ2RkZCcsIDAsIDAsIGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLndlZWtkYXlzU2hvcnQodGhpcywgZm9ybWF0KTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdkZGRkJywgMCwgMCwgZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkud2Vla2RheXModGhpcywgZm9ybWF0KTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdlJywgMCwgMCwgJ3dlZWtkYXknKTtcbiAgICBhZGRGb3JtYXRUb2tlbignRScsIDAsIDAsICdpc29XZWVrZGF5Jyk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ2RheScsICdkJyk7XG4gICAgYWRkVW5pdEFsaWFzKCd3ZWVrZGF5JywgJ2UnKTtcbiAgICBhZGRVbml0QWxpYXMoJ2lzb1dlZWtkYXknLCAnRScpO1xuXG4gICAgLy8gUFJJT1JJVFlcbiAgICBhZGRVbml0UHJpb3JpdHkoJ2RheScsIDExKTtcbiAgICBhZGRVbml0UHJpb3JpdHkoJ3dlZWtkYXknLCAxMSk7XG4gICAgYWRkVW5pdFByaW9yaXR5KCdpc29XZWVrZGF5JywgMTEpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignZCcsIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignZScsIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignRScsIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignZGQnLCBmdW5jdGlvbiAoaXNTdHJpY3QsIGxvY2FsZSkge1xuICAgICAgICByZXR1cm4gbG9jYWxlLndlZWtkYXlzTWluUmVnZXgoaXNTdHJpY3QpO1xuICAgIH0pO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2RkZCcsIGZ1bmN0aW9uIChpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGUud2Vla2RheXNTaG9ydFJlZ2V4KGlzU3RyaWN0KTtcbiAgICB9KTtcbiAgICBhZGRSZWdleFRva2VuKCdkZGRkJywgZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZS53ZWVrZGF5c1JlZ2V4KGlzU3RyaWN0KTtcbiAgICB9KTtcblxuICAgIGFkZFdlZWtQYXJzZVRva2VuKFsnZGQnLCAnZGRkJywgJ2RkZGQnXSwgZnVuY3Rpb24gKGlucHV0LCB3ZWVrLCBjb25maWcsIHRva2VuKSB7XG4gICAgICAgIHZhciB3ZWVrZGF5ID0gY29uZmlnLl9sb2NhbGUud2Vla2RheXNQYXJzZShpbnB1dCwgdG9rZW4sIGNvbmZpZy5fc3RyaWN0KTtcbiAgICAgICAgLy8gaWYgd2UgZGlkbid0IGdldCBhIHdlZWtkYXkgbmFtZSwgbWFyayB0aGUgZGF0ZSBhcyBpbnZhbGlkXG4gICAgICAgIGlmICh3ZWVrZGF5ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHdlZWsuZCA9IHdlZWtkYXk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5pbnZhbGlkV2Vla2RheSA9IGlucHV0O1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBhZGRXZWVrUGFyc2VUb2tlbihbJ2QnLCAnZScsICdFJ10sIGZ1bmN0aW9uIChpbnB1dCwgd2VlaywgY29uZmlnLCB0b2tlbikge1xuICAgICAgICB3ZWVrW3Rva2VuXSA9IHRvSW50KGlucHV0KTtcbiAgICB9KTtcblxuICAgIC8vIEhFTFBFUlNcblxuICAgIGZ1bmN0aW9uIHBhcnNlV2Vla2RheShpbnB1dCwgbG9jYWxlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzTmFOKGlucHV0KSkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KGlucHV0LCAxMCk7XG4gICAgICAgIH1cblxuICAgICAgICBpbnB1dCA9IGxvY2FsZS53ZWVrZGF5c1BhcnNlKGlucHV0KTtcbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlSXNvV2Vla2RheShpbnB1dCwgbG9jYWxlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxlLndlZWtkYXlzUGFyc2UoaW5wdXQpICUgNyB8fCA3O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpc05hTihpbnB1dCkgPyBudWxsIDogaW5wdXQ7XG4gICAgfVxuXG4gICAgLy8gTE9DQUxFU1xuICAgIGZ1bmN0aW9uIHNoaWZ0V2Vla2RheXMod3MsIG4pIHtcbiAgICAgICAgcmV0dXJuIHdzLnNsaWNlKG4sIDcpLmNvbmNhdCh3cy5zbGljZSgwLCBuKSk7XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRMb2NhbGVXZWVrZGF5cyA9ICdTdW5kYXlfTW9uZGF5X1R1ZXNkYXlfV2VkbmVzZGF5X1RodXJzZGF5X0ZyaWRheV9TYXR1cmRheScuc3BsaXQoXG4gICAgICAgICAgICAnXydcbiAgICAgICAgKSxcbiAgICAgICAgZGVmYXVsdExvY2FsZVdlZWtkYXlzU2hvcnQgPSAnU3VuX01vbl9UdWVfV2VkX1RodV9GcmlfU2F0Jy5zcGxpdCgnXycpLFxuICAgICAgICBkZWZhdWx0TG9jYWxlV2Vla2RheXNNaW4gPSAnU3VfTW9fVHVfV2VfVGhfRnJfU2EnLnNwbGl0KCdfJyksXG4gICAgICAgIGRlZmF1bHRXZWVrZGF5c1JlZ2V4ID0gbWF0Y2hXb3JkLFxuICAgICAgICBkZWZhdWx0V2Vla2RheXNTaG9ydFJlZ2V4ID0gbWF0Y2hXb3JkLFxuICAgICAgICBkZWZhdWx0V2Vla2RheXNNaW5SZWdleCA9IG1hdGNoV29yZDtcblxuICAgIGZ1bmN0aW9uIGxvY2FsZVdlZWtkYXlzKG0sIGZvcm1hdCkge1xuICAgICAgICB2YXIgd2Vla2RheXMgPSBpc0FycmF5KHRoaXMuX3dlZWtkYXlzKVxuICAgICAgICAgICAgPyB0aGlzLl93ZWVrZGF5c1xuICAgICAgICAgICAgOiB0aGlzLl93ZWVrZGF5c1tcbiAgICAgICAgICAgICAgICAgIG0gJiYgbSAhPT0gdHJ1ZSAmJiB0aGlzLl93ZWVrZGF5cy5pc0Zvcm1hdC50ZXN0KGZvcm1hdClcbiAgICAgICAgICAgICAgICAgICAgICA/ICdmb3JtYXQnXG4gICAgICAgICAgICAgICAgICAgICAgOiAnc3RhbmRhbG9uZSdcbiAgICAgICAgICAgICAgXTtcbiAgICAgICAgcmV0dXJuIG0gPT09IHRydWVcbiAgICAgICAgICAgID8gc2hpZnRXZWVrZGF5cyh3ZWVrZGF5cywgdGhpcy5fd2Vlay5kb3cpXG4gICAgICAgICAgICA6IG1cbiAgICAgICAgICAgID8gd2Vla2RheXNbbS5kYXkoKV1cbiAgICAgICAgICAgIDogd2Vla2RheXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9jYWxlV2Vla2RheXNTaG9ydChtKSB7XG4gICAgICAgIHJldHVybiBtID09PSB0cnVlXG4gICAgICAgICAgICA/IHNoaWZ0V2Vla2RheXModGhpcy5fd2Vla2RheXNTaG9ydCwgdGhpcy5fd2Vlay5kb3cpXG4gICAgICAgICAgICA6IG1cbiAgICAgICAgICAgID8gdGhpcy5fd2Vla2RheXNTaG9ydFttLmRheSgpXVxuICAgICAgICAgICAgOiB0aGlzLl93ZWVrZGF5c1Nob3J0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvY2FsZVdlZWtkYXlzTWluKG0pIHtcbiAgICAgICAgcmV0dXJuIG0gPT09IHRydWVcbiAgICAgICAgICAgID8gc2hpZnRXZWVrZGF5cyh0aGlzLl93ZWVrZGF5c01pbiwgdGhpcy5fd2Vlay5kb3cpXG4gICAgICAgICAgICA6IG1cbiAgICAgICAgICAgID8gdGhpcy5fd2Vla2RheXNNaW5bbS5kYXkoKV1cbiAgICAgICAgICAgIDogdGhpcy5fd2Vla2RheXNNaW47XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFuZGxlU3RyaWN0UGFyc2UkMSh3ZWVrZGF5TmFtZSwgZm9ybWF0LCBzdHJpY3QpIHtcbiAgICAgICAgdmFyIGksXG4gICAgICAgICAgICBpaSxcbiAgICAgICAgICAgIG1vbSxcbiAgICAgICAgICAgIGxsYyA9IHdlZWtkYXlOYW1lLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmICghdGhpcy5fd2Vla2RheXNQYXJzZSkge1xuICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNQYXJzZSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlID0gW107XG4gICAgICAgICAgICB0aGlzLl9taW5XZWVrZGF5c1BhcnNlID0gW107XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCA3OyArK2kpIHtcbiAgICAgICAgICAgICAgICBtb20gPSBjcmVhdGVVVEMoWzIwMDAsIDFdKS5kYXkoaSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fbWluV2Vla2RheXNQYXJzZVtpXSA9IHRoaXMud2Vla2RheXNNaW4oXG4gICAgICAgICAgICAgICAgICAgIG1vbSxcbiAgICAgICAgICAgICAgICAgICAgJydcbiAgICAgICAgICAgICAgICApLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlW2ldID0gdGhpcy53ZWVrZGF5c1Nob3J0KFxuICAgICAgICAgICAgICAgICAgICBtb20sXG4gICAgICAgICAgICAgICAgICAgICcnXG4gICAgICAgICAgICAgICAgKS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzUGFyc2VbaV0gPSB0aGlzLndlZWtkYXlzKG1vbSwgJycpLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RyaWN0KSB7XG4gICAgICAgICAgICBpZiAoZm9ybWF0ID09PSAnZGRkZCcpIHtcbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl93ZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGZvcm1hdCA9PT0gJ2RkZCcpIHtcbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fbWluV2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGZvcm1hdCA9PT0gJ2RkZGQnKSB7XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fd2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICBpZiAoaWkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIGlmIChpaSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9taW5XZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGZvcm1hdCA9PT0gJ2RkZCcpIHtcbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3dlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX21pbldlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fbWluV2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICBpZiAoaWkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fd2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICBpZiAoaWkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb2NhbGVXZWVrZGF5c1BhcnNlKHdlZWtkYXlOYW1lLCBmb3JtYXQsIHN0cmljdCkge1xuICAgICAgICB2YXIgaSwgbW9tLCByZWdleDtcblxuICAgICAgICBpZiAodGhpcy5fd2Vla2RheXNQYXJzZUV4YWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlU3RyaWN0UGFyc2UkMS5jYWxsKHRoaXMsIHdlZWtkYXlOYW1lLCBmb3JtYXQsIHN0cmljdCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuX3dlZWtkYXlzUGFyc2UpIHtcbiAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX21pbldlZWtkYXlzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fZnVsbFdlZWtkYXlzUGFyc2UgPSBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCA3OyBpKyspIHtcbiAgICAgICAgICAgIC8vIG1ha2UgdGhlIHJlZ2V4IGlmIHdlIGRvbid0IGhhdmUgaXQgYWxyZWFkeVxuXG4gICAgICAgICAgICBtb20gPSBjcmVhdGVVVEMoWzIwMDAsIDFdKS5kYXkoaSk7XG4gICAgICAgICAgICBpZiAoc3RyaWN0ICYmICF0aGlzLl9mdWxsV2Vla2RheXNQYXJzZVtpXSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2Z1bGxXZWVrZGF5c1BhcnNlW2ldID0gbmV3IFJlZ0V4cChcbiAgICAgICAgICAgICAgICAgICAgJ14nICsgdGhpcy53ZWVrZGF5cyhtb20sICcnKS5yZXBsYWNlKCcuJywgJ1xcXFwuPycpICsgJyQnLFxuICAgICAgICAgICAgICAgICAgICAnaSdcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZVtpXSA9IG5ldyBSZWdFeHAoXG4gICAgICAgICAgICAgICAgICAgICdeJyArIHRoaXMud2Vla2RheXNTaG9ydChtb20sICcnKS5yZXBsYWNlKCcuJywgJ1xcXFwuPycpICsgJyQnLFxuICAgICAgICAgICAgICAgICAgICAnaSdcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHRoaXMuX21pbldlZWtkYXlzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKFxuICAgICAgICAgICAgICAgICAgICAnXicgKyB0aGlzLndlZWtkYXlzTWluKG1vbSwgJycpLnJlcGxhY2UoJy4nLCAnXFxcXC4/JykgKyAnJCcsXG4gICAgICAgICAgICAgICAgICAgICdpJ1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMuX3dlZWtkYXlzUGFyc2VbaV0pIHtcbiAgICAgICAgICAgICAgICByZWdleCA9XG4gICAgICAgICAgICAgICAgICAgICdeJyArXG4gICAgICAgICAgICAgICAgICAgIHRoaXMud2Vla2RheXMobW9tLCAnJykgK1xuICAgICAgICAgICAgICAgICAgICAnfF4nICtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy53ZWVrZGF5c1Nob3J0KG1vbSwgJycpICtcbiAgICAgICAgICAgICAgICAgICAgJ3xeJyArXG4gICAgICAgICAgICAgICAgICAgIHRoaXMud2Vla2RheXNNaW4obW9tLCAnJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNQYXJzZVtpXSA9IG5ldyBSZWdFeHAocmVnZXgucmVwbGFjZSgnLicsICcnKSwgJ2knKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHRlc3QgdGhlIHJlZ2V4XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgc3RyaWN0ICYmXG4gICAgICAgICAgICAgICAgZm9ybWF0ID09PSAnZGRkZCcgJiZcbiAgICAgICAgICAgICAgICB0aGlzLl9mdWxsV2Vla2RheXNQYXJzZVtpXS50ZXN0KHdlZWtkYXlOYW1lKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgICAgIHN0cmljdCAmJlxuICAgICAgICAgICAgICAgIGZvcm1hdCA9PT0gJ2RkZCcgJiZcbiAgICAgICAgICAgICAgICB0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2VbaV0udGVzdCh3ZWVrZGF5TmFtZSlcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgICAgICBzdHJpY3QgJiZcbiAgICAgICAgICAgICAgICBmb3JtYXQgPT09ICdkZCcgJiZcbiAgICAgICAgICAgICAgICB0aGlzLl9taW5XZWVrZGF5c1BhcnNlW2ldLnRlc3Qod2Vla2RheU5hbWUpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIXN0cmljdCAmJiB0aGlzLl93ZWVrZGF5c1BhcnNlW2ldLnRlc3Qod2Vla2RheU5hbWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICBmdW5jdGlvbiBnZXRTZXREYXlPZldlZWsoaW5wdXQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0ICE9IG51bGwgPyB0aGlzIDogTmFOO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkYXkgPSB0aGlzLl9pc1VUQyA/IHRoaXMuX2QuZ2V0VVRDRGF5KCkgOiB0aGlzLl9kLmdldERheSgpO1xuICAgICAgICBpZiAoaW5wdXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgaW5wdXQgPSBwYXJzZVdlZWtkYXkoaW5wdXQsIHRoaXMubG9jYWxlRGF0YSgpKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZChpbnB1dCAtIGRheSwgJ2QnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBkYXk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTZXRMb2NhbGVEYXlPZldlZWsoaW5wdXQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0ICE9IG51bGwgPyB0aGlzIDogTmFOO1xuICAgICAgICB9XG4gICAgICAgIHZhciB3ZWVrZGF5ID0gKHRoaXMuZGF5KCkgKyA3IC0gdGhpcy5sb2NhbGVEYXRhKCkuX3dlZWsuZG93KSAlIDc7XG4gICAgICAgIHJldHVybiBpbnB1dCA9PSBudWxsID8gd2Vla2RheSA6IHRoaXMuYWRkKGlucHV0IC0gd2Vla2RheSwgJ2QnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTZXRJU09EYXlPZldlZWsoaW5wdXQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0ICE9IG51bGwgPyB0aGlzIDogTmFOO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYmVoYXZlcyB0aGUgc2FtZSBhcyBtb21lbnQjZGF5IGV4Y2VwdFxuICAgICAgICAvLyBhcyBhIGdldHRlciwgcmV0dXJucyA3IGluc3RlYWQgb2YgMCAoMS03IHJhbmdlIGluc3RlYWQgb2YgMC02KVxuICAgICAgICAvLyBhcyBhIHNldHRlciwgc3VuZGF5IHNob3VsZCBiZWxvbmcgdG8gdGhlIHByZXZpb3VzIHdlZWsuXG5cbiAgICAgICAgaWYgKGlucHV0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHZhciB3ZWVrZGF5ID0gcGFyc2VJc29XZWVrZGF5KGlucHV0LCB0aGlzLmxvY2FsZURhdGEoKSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXkodGhpcy5kYXkoKSAlIDcgPyB3ZWVrZGF5IDogd2Vla2RheSAtIDcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF5KCkgfHwgNztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHdlZWtkYXlzUmVnZXgoaXNTdHJpY3QpIHtcbiAgICAgICAgaWYgKHRoaXMuX3dlZWtkYXlzUGFyc2VFeGFjdCkge1xuICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfd2Vla2RheXNSZWdleCcpKSB7XG4gICAgICAgICAgICAgICAgY29tcHV0ZVdlZWtkYXlzUGFyc2UuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1N0cmljdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c1N0cmljdFJlZ2V4O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNSZWdleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX3dlZWtkYXlzUmVnZXgnKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzUmVnZXggPSBkZWZhdWx0V2Vla2RheXNSZWdleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c1N0cmljdFJlZ2V4ICYmIGlzU3RyaWN0XG4gICAgICAgICAgICAgICAgPyB0aGlzLl93ZWVrZGF5c1N0cmljdFJlZ2V4XG4gICAgICAgICAgICAgICAgOiB0aGlzLl93ZWVrZGF5c1JlZ2V4O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gd2Vla2RheXNTaG9ydFJlZ2V4KGlzU3RyaWN0KSB7XG4gICAgICAgIGlmICh0aGlzLl93ZWVrZGF5c1BhcnNlRXhhY3QpIHtcbiAgICAgICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX3dlZWtkYXlzUmVnZXgnKSkge1xuICAgICAgICAgICAgICAgIGNvbXB1dGVXZWVrZGF5c1BhcnNlLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNTdHJpY3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNTaG9ydFN0cmljdFJlZ2V4O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNTaG9ydFJlZ2V4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfd2Vla2RheXNTaG9ydFJlZ2V4JykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1Nob3J0UmVnZXggPSBkZWZhdWx0V2Vla2RheXNTaG9ydFJlZ2V4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzU2hvcnRTdHJpY3RSZWdleCAmJiBpc1N0cmljdFxuICAgICAgICAgICAgICAgID8gdGhpcy5fd2Vla2RheXNTaG9ydFN0cmljdFJlZ2V4XG4gICAgICAgICAgICAgICAgOiB0aGlzLl93ZWVrZGF5c1Nob3J0UmVnZXg7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB3ZWVrZGF5c01pblJlZ2V4KGlzU3RyaWN0KSB7XG4gICAgICAgIGlmICh0aGlzLl93ZWVrZGF5c1BhcnNlRXhhY3QpIHtcbiAgICAgICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX3dlZWtkYXlzUmVnZXgnKSkge1xuICAgICAgICAgICAgICAgIGNvbXB1dGVXZWVrZGF5c1BhcnNlLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNTdHJpY3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNNaW5TdHJpY3RSZWdleDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzTWluUmVnZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ193ZWVrZGF5c01pblJlZ2V4JykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl93ZWVrZGF5c01pblJlZ2V4ID0gZGVmYXVsdFdlZWtkYXlzTWluUmVnZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNNaW5TdHJpY3RSZWdleCAmJiBpc1N0cmljdFxuICAgICAgICAgICAgICAgID8gdGhpcy5fd2Vla2RheXNNaW5TdHJpY3RSZWdleFxuICAgICAgICAgICAgICAgIDogdGhpcy5fd2Vla2RheXNNaW5SZWdleDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbXB1dGVXZWVrZGF5c1BhcnNlKCkge1xuICAgICAgICBmdW5jdGlvbiBjbXBMZW5SZXYoYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIGIubGVuZ3RoIC0gYS5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbWluUGllY2VzID0gW10sXG4gICAgICAgICAgICBzaG9ydFBpZWNlcyA9IFtdLFxuICAgICAgICAgICAgbG9uZ1BpZWNlcyA9IFtdLFxuICAgICAgICAgICAgbWl4ZWRQaWVjZXMgPSBbXSxcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICBtb20sXG4gICAgICAgICAgICBtaW5wLFxuICAgICAgICAgICAgc2hvcnRwLFxuICAgICAgICAgICAgbG9uZ3A7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCA3OyBpKyspIHtcbiAgICAgICAgICAgIC8vIG1ha2UgdGhlIHJlZ2V4IGlmIHdlIGRvbid0IGhhdmUgaXQgYWxyZWFkeVxuICAgICAgICAgICAgbW9tID0gY3JlYXRlVVRDKFsyMDAwLCAxXSkuZGF5KGkpO1xuICAgICAgICAgICAgbWlucCA9IHJlZ2V4RXNjYXBlKHRoaXMud2Vla2RheXNNaW4obW9tLCAnJykpO1xuICAgICAgICAgICAgc2hvcnRwID0gcmVnZXhFc2NhcGUodGhpcy53ZWVrZGF5c1Nob3J0KG1vbSwgJycpKTtcbiAgICAgICAgICAgIGxvbmdwID0gcmVnZXhFc2NhcGUodGhpcy53ZWVrZGF5cyhtb20sICcnKSk7XG4gICAgICAgICAgICBtaW5QaWVjZXMucHVzaChtaW5wKTtcbiAgICAgICAgICAgIHNob3J0UGllY2VzLnB1c2goc2hvcnRwKTtcbiAgICAgICAgICAgIGxvbmdQaWVjZXMucHVzaChsb25ncCk7XG4gICAgICAgICAgICBtaXhlZFBpZWNlcy5wdXNoKG1pbnApO1xuICAgICAgICAgICAgbWl4ZWRQaWVjZXMucHVzaChzaG9ydHApO1xuICAgICAgICAgICAgbWl4ZWRQaWVjZXMucHVzaChsb25ncCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU29ydGluZyBtYWtlcyBzdXJlIGlmIG9uZSB3ZWVrZGF5IChvciBhYmJyKSBpcyBhIHByZWZpeCBvZiBhbm90aGVyIGl0XG4gICAgICAgIC8vIHdpbGwgbWF0Y2ggdGhlIGxvbmdlciBwaWVjZS5cbiAgICAgICAgbWluUGllY2VzLnNvcnQoY21wTGVuUmV2KTtcbiAgICAgICAgc2hvcnRQaWVjZXMuc29ydChjbXBMZW5SZXYpO1xuICAgICAgICBsb25nUGllY2VzLnNvcnQoY21wTGVuUmV2KTtcbiAgICAgICAgbWl4ZWRQaWVjZXMuc29ydChjbXBMZW5SZXYpO1xuXG4gICAgICAgIHRoaXMuX3dlZWtkYXlzUmVnZXggPSBuZXcgUmVnRXhwKCdeKCcgKyBtaXhlZFBpZWNlcy5qb2luKCd8JykgKyAnKScsICdpJyk7XG4gICAgICAgIHRoaXMuX3dlZWtkYXlzU2hvcnRSZWdleCA9IHRoaXMuX3dlZWtkYXlzUmVnZXg7XG4gICAgICAgIHRoaXMuX3dlZWtkYXlzTWluUmVnZXggPSB0aGlzLl93ZWVrZGF5c1JlZ2V4O1xuXG4gICAgICAgIHRoaXMuX3dlZWtkYXlzU3RyaWN0UmVnZXggPSBuZXcgUmVnRXhwKFxuICAgICAgICAgICAgJ14oJyArIGxvbmdQaWVjZXMuam9pbignfCcpICsgJyknLFxuICAgICAgICAgICAgJ2knXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuX3dlZWtkYXlzU2hvcnRTdHJpY3RSZWdleCA9IG5ldyBSZWdFeHAoXG4gICAgICAgICAgICAnXignICsgc2hvcnRQaWVjZXMuam9pbignfCcpICsgJyknLFxuICAgICAgICAgICAgJ2knXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuX3dlZWtkYXlzTWluU3RyaWN0UmVnZXggPSBuZXcgUmVnRXhwKFxuICAgICAgICAgICAgJ14oJyArIG1pblBpZWNlcy5qb2luKCd8JykgKyAnKScsXG4gICAgICAgICAgICAnaSdcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBmdW5jdGlvbiBoRm9ybWF0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ob3VycygpICUgMTIgfHwgMTI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24ga0Zvcm1hdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaG91cnMoKSB8fCAyNDtcbiAgICB9XG5cbiAgICBhZGRGb3JtYXRUb2tlbignSCcsIFsnSEgnLCAyXSwgMCwgJ2hvdXInKTtcbiAgICBhZGRGb3JtYXRUb2tlbignaCcsIFsnaGgnLCAyXSwgMCwgaEZvcm1hdCk7XG4gICAgYWRkRm9ybWF0VG9rZW4oJ2snLCBbJ2trJywgMl0sIDAsIGtGb3JtYXQpO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ2htbScsIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICcnICsgaEZvcm1hdC5hcHBseSh0aGlzKSArIHplcm9GaWxsKHRoaXMubWludXRlcygpLCAyKTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdobW1zcycsIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICcnICtcbiAgICAgICAgICAgIGhGb3JtYXQuYXBwbHkodGhpcykgK1xuICAgICAgICAgICAgemVyb0ZpbGwodGhpcy5taW51dGVzKCksIDIpICtcbiAgICAgICAgICAgIHplcm9GaWxsKHRoaXMuc2Vjb25kcygpLCAyKVxuICAgICAgICApO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ0htbScsIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICcnICsgdGhpcy5ob3VycygpICsgemVyb0ZpbGwodGhpcy5taW51dGVzKCksIDIpO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ0htbXNzJywgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgJycgK1xuICAgICAgICAgICAgdGhpcy5ob3VycygpICtcbiAgICAgICAgICAgIHplcm9GaWxsKHRoaXMubWludXRlcygpLCAyKSArXG4gICAgICAgICAgICB6ZXJvRmlsbCh0aGlzLnNlY29uZHMoKSwgMilcbiAgICAgICAgKTtcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIG1lcmlkaWVtKHRva2VuLCBsb3dlcmNhc2UpIHtcbiAgICAgICAgYWRkRm9ybWF0VG9rZW4odG9rZW4sIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5tZXJpZGllbShcbiAgICAgICAgICAgICAgICB0aGlzLmhvdXJzKCksXG4gICAgICAgICAgICAgICAgdGhpcy5taW51dGVzKCksXG4gICAgICAgICAgICAgICAgbG93ZXJjYXNlXG4gICAgICAgICAgICApO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBtZXJpZGllbSgnYScsIHRydWUpO1xuICAgIG1lcmlkaWVtKCdBJywgZmFsc2UpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCdob3VyJywgJ2gnKTtcblxuICAgIC8vIFBSSU9SSVRZXG4gICAgYWRkVW5pdFByaW9yaXR5KCdob3VyJywgMTMpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgZnVuY3Rpb24gbWF0Y2hNZXJpZGllbShpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGUuX21lcmlkaWVtUGFyc2U7XG4gICAgfVxuXG4gICAgYWRkUmVnZXhUb2tlbignYScsIG1hdGNoTWVyaWRpZW0pO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0EnLCBtYXRjaE1lcmlkaWVtKTtcbiAgICBhZGRSZWdleFRva2VuKCdIJywgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdoJywgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdrJywgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdISCcsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdoaCcsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdraycsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ2htbScsIG1hdGNoM3RvNCk7XG4gICAgYWRkUmVnZXhUb2tlbignaG1tc3MnLCBtYXRjaDV0bzYpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0htbScsIG1hdGNoM3RvNCk7XG4gICAgYWRkUmVnZXhUb2tlbignSG1tc3MnLCBtYXRjaDV0bzYpO1xuXG4gICAgYWRkUGFyc2VUb2tlbihbJ0gnLCAnSEgnXSwgSE9VUik7XG4gICAgYWRkUGFyc2VUb2tlbihbJ2snLCAna2snXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIHZhciBrSW5wdXQgPSB0b0ludChpbnB1dCk7XG4gICAgICAgIGFycmF5W0hPVVJdID0ga0lucHV0ID09PSAyNCA/IDAgOiBrSW5wdXQ7XG4gICAgfSk7XG4gICAgYWRkUGFyc2VUb2tlbihbJ2EnLCAnQSddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgY29uZmlnLl9pc1BtID0gY29uZmlnLl9sb2NhbGUuaXNQTShpbnB1dCk7XG4gICAgICAgIGNvbmZpZy5fbWVyaWRpZW0gPSBpbnB1dDtcbiAgICB9KTtcbiAgICBhZGRQYXJzZVRva2VuKFsnaCcsICdoaCddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgYXJyYXlbSE9VUl0gPSB0b0ludChpbnB1dCk7XG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmJpZ0hvdXIgPSB0cnVlO1xuICAgIH0pO1xuICAgIGFkZFBhcnNlVG9rZW4oJ2htbScsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICB2YXIgcG9zID0gaW5wdXQubGVuZ3RoIC0gMjtcbiAgICAgICAgYXJyYXlbSE9VUl0gPSB0b0ludChpbnB1dC5zdWJzdHIoMCwgcG9zKSk7XG4gICAgICAgIGFycmF5W01JTlVURV0gPSB0b0ludChpbnB1dC5zdWJzdHIocG9zKSk7XG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmJpZ0hvdXIgPSB0cnVlO1xuICAgIH0pO1xuICAgIGFkZFBhcnNlVG9rZW4oJ2htbXNzJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIHZhciBwb3MxID0gaW5wdXQubGVuZ3RoIC0gNCxcbiAgICAgICAgICAgIHBvczIgPSBpbnB1dC5sZW5ndGggLSAyO1xuICAgICAgICBhcnJheVtIT1VSXSA9IHRvSW50KGlucHV0LnN1YnN0cigwLCBwb3MxKSk7XG4gICAgICAgIGFycmF5W01JTlVURV0gPSB0b0ludChpbnB1dC5zdWJzdHIocG9zMSwgMikpO1xuICAgICAgICBhcnJheVtTRUNPTkRdID0gdG9JbnQoaW5wdXQuc3Vic3RyKHBvczIpKTtcbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuYmlnSG91ciA9IHRydWU7XG4gICAgfSk7XG4gICAgYWRkUGFyc2VUb2tlbignSG1tJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIHZhciBwb3MgPSBpbnB1dC5sZW5ndGggLSAyO1xuICAgICAgICBhcnJheVtIT1VSXSA9IHRvSW50KGlucHV0LnN1YnN0cigwLCBwb3MpKTtcbiAgICAgICAgYXJyYXlbTUlOVVRFXSA9IHRvSW50KGlucHV0LnN1YnN0cihwb3MpKTtcbiAgICB9KTtcbiAgICBhZGRQYXJzZVRva2VuKCdIbW1zcycsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICB2YXIgcG9zMSA9IGlucHV0Lmxlbmd0aCAtIDQsXG4gICAgICAgICAgICBwb3MyID0gaW5wdXQubGVuZ3RoIC0gMjtcbiAgICAgICAgYXJyYXlbSE9VUl0gPSB0b0ludChpbnB1dC5zdWJzdHIoMCwgcG9zMSkpO1xuICAgICAgICBhcnJheVtNSU5VVEVdID0gdG9JbnQoaW5wdXQuc3Vic3RyKHBvczEsIDIpKTtcbiAgICAgICAgYXJyYXlbU0VDT05EXSA9IHRvSW50KGlucHV0LnN1YnN0cihwb3MyKSk7XG4gICAgfSk7XG5cbiAgICAvLyBMT0NBTEVTXG5cbiAgICBmdW5jdGlvbiBsb2NhbGVJc1BNKGlucHV0KSB7XG4gICAgICAgIC8vIElFOCBRdWlya3MgTW9kZSAmIElFNyBTdGFuZGFyZHMgTW9kZSBkbyBub3QgYWxsb3cgYWNjZXNzaW5nIHN0cmluZ3MgbGlrZSBhcnJheXNcbiAgICAgICAgLy8gVXNpbmcgY2hhckF0IHNob3VsZCBiZSBtb3JlIGNvbXBhdGlibGUuXG4gICAgICAgIHJldHVybiAoaW5wdXQgKyAnJykudG9Mb3dlckNhc2UoKS5jaGFyQXQoMCkgPT09ICdwJztcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdExvY2FsZU1lcmlkaWVtUGFyc2UgPSAvW2FwXVxcLj9tP1xcLj8vaSxcbiAgICAgICAgLy8gU2V0dGluZyB0aGUgaG91ciBzaG91bGQga2VlcCB0aGUgdGltZSwgYmVjYXVzZSB0aGUgdXNlciBleHBsaWNpdGx5XG4gICAgICAgIC8vIHNwZWNpZmllZCB3aGljaCBob3VyIHRoZXkgd2FudC4gU28gdHJ5aW5nIHRvIG1haW50YWluIHRoZSBzYW1lIGhvdXIgKGluXG4gICAgICAgIC8vIGEgbmV3IHRpbWV6b25lKSBtYWtlcyBzZW5zZS4gQWRkaW5nL3N1YnRyYWN0aW5nIGhvdXJzIGRvZXMgbm90IGZvbGxvd1xuICAgICAgICAvLyB0aGlzIHJ1bGUuXG4gICAgICAgIGdldFNldEhvdXIgPSBtYWtlR2V0U2V0KCdIb3VycycsIHRydWUpO1xuXG4gICAgZnVuY3Rpb24gbG9jYWxlTWVyaWRpZW0oaG91cnMsIG1pbnV0ZXMsIGlzTG93ZXIpIHtcbiAgICAgICAgaWYgKGhvdXJzID4gMTEpIHtcbiAgICAgICAgICAgIHJldHVybiBpc0xvd2VyID8gJ3BtJyA6ICdQTSc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gaXNMb3dlciA/ICdhbScgOiAnQU0nO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGJhc2VDb25maWcgPSB7XG4gICAgICAgIGNhbGVuZGFyOiBkZWZhdWx0Q2FsZW5kYXIsXG4gICAgICAgIGxvbmdEYXRlRm9ybWF0OiBkZWZhdWx0TG9uZ0RhdGVGb3JtYXQsXG4gICAgICAgIGludmFsaWREYXRlOiBkZWZhdWx0SW52YWxpZERhdGUsXG4gICAgICAgIG9yZGluYWw6IGRlZmF1bHRPcmRpbmFsLFxuICAgICAgICBkYXlPZk1vbnRoT3JkaW5hbFBhcnNlOiBkZWZhdWx0RGF5T2ZNb250aE9yZGluYWxQYXJzZSxcbiAgICAgICAgcmVsYXRpdmVUaW1lOiBkZWZhdWx0UmVsYXRpdmVUaW1lLFxuXG4gICAgICAgIG1vbnRoczogZGVmYXVsdExvY2FsZU1vbnRocyxcbiAgICAgICAgbW9udGhzU2hvcnQ6IGRlZmF1bHRMb2NhbGVNb250aHNTaG9ydCxcblxuICAgICAgICB3ZWVrOiBkZWZhdWx0TG9jYWxlV2VlayxcblxuICAgICAgICB3ZWVrZGF5czogZGVmYXVsdExvY2FsZVdlZWtkYXlzLFxuICAgICAgICB3ZWVrZGF5c01pbjogZGVmYXVsdExvY2FsZVdlZWtkYXlzTWluLFxuICAgICAgICB3ZWVrZGF5c1Nob3J0OiBkZWZhdWx0TG9jYWxlV2Vla2RheXNTaG9ydCxcblxuICAgICAgICBtZXJpZGllbVBhcnNlOiBkZWZhdWx0TG9jYWxlTWVyaWRpZW1QYXJzZSxcbiAgICB9O1xuXG4gICAgLy8gaW50ZXJuYWwgc3RvcmFnZSBmb3IgbG9jYWxlIGNvbmZpZyBmaWxlc1xuICAgIHZhciBsb2NhbGVzID0ge30sXG4gICAgICAgIGxvY2FsZUZhbWlsaWVzID0ge30sXG4gICAgICAgIGdsb2JhbExvY2FsZTtcblxuICAgIGZ1bmN0aW9uIGNvbW1vblByZWZpeChhcnIxLCBhcnIyKSB7XG4gICAgICAgIHZhciBpLFxuICAgICAgICAgICAgbWlubCA9IE1hdGgubWluKGFycjEubGVuZ3RoLCBhcnIyLmxlbmd0aCk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBtaW5sOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGlmIChhcnIxW2ldICE9PSBhcnIyW2ldKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1pbmw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbm9ybWFsaXplTG9jYWxlKGtleSkge1xuICAgICAgICByZXR1cm4ga2V5ID8ga2V5LnRvTG93ZXJDYXNlKCkucmVwbGFjZSgnXycsICctJykgOiBrZXk7XG4gICAgfVxuXG4gICAgLy8gcGljayB0aGUgbG9jYWxlIGZyb20gdGhlIGFycmF5XG4gICAgLy8gdHJ5IFsnZW4tYXUnLCAnZW4tZ2InXSBhcyAnZW4tYXUnLCAnZW4tZ2InLCAnZW4nLCBhcyBpbiBtb3ZlIHRocm91Z2ggdGhlIGxpc3QgdHJ5aW5nIGVhY2hcbiAgICAvLyBzdWJzdHJpbmcgZnJvbSBtb3N0IHNwZWNpZmljIHRvIGxlYXN0LCBidXQgbW92ZSB0byB0aGUgbmV4dCBhcnJheSBpdGVtIGlmIGl0J3MgYSBtb3JlIHNwZWNpZmljIHZhcmlhbnQgdGhhbiB0aGUgY3VycmVudCByb290XG4gICAgZnVuY3Rpb24gY2hvb3NlTG9jYWxlKG5hbWVzKSB7XG4gICAgICAgIHZhciBpID0gMCxcbiAgICAgICAgICAgIGosXG4gICAgICAgICAgICBuZXh0LFxuICAgICAgICAgICAgbG9jYWxlLFxuICAgICAgICAgICAgc3BsaXQ7XG5cbiAgICAgICAgd2hpbGUgKGkgPCBuYW1lcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHNwbGl0ID0gbm9ybWFsaXplTG9jYWxlKG5hbWVzW2ldKS5zcGxpdCgnLScpO1xuICAgICAgICAgICAgaiA9IHNwbGl0Lmxlbmd0aDtcbiAgICAgICAgICAgIG5leHQgPSBub3JtYWxpemVMb2NhbGUobmFtZXNbaSArIDFdKTtcbiAgICAgICAgICAgIG5leHQgPSBuZXh0ID8gbmV4dC5zcGxpdCgnLScpIDogbnVsbDtcbiAgICAgICAgICAgIHdoaWxlIChqID4gMCkge1xuICAgICAgICAgICAgICAgIGxvY2FsZSA9IGxvYWRMb2NhbGUoc3BsaXQuc2xpY2UoMCwgaikuam9pbignLScpKTtcbiAgICAgICAgICAgICAgICBpZiAobG9jYWxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBsb2NhbGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgbmV4dCAmJlxuICAgICAgICAgICAgICAgICAgICBuZXh0Lmxlbmd0aCA+PSBqICYmXG4gICAgICAgICAgICAgICAgICAgIGNvbW1vblByZWZpeChzcGxpdCwgbmV4dCkgPj0gaiAtIDFcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgLy90aGUgbmV4dCBhcnJheSBpdGVtIGlzIGJldHRlciB0aGFuIGEgc2hhbGxvd2VyIHN1YnN0cmluZyBvZiB0aGlzIG9uZVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgai0tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBnbG9iYWxMb2NhbGU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9hZExvY2FsZShuYW1lKSB7XG4gICAgICAgIHZhciBvbGRMb2NhbGUgPSBudWxsLFxuICAgICAgICAgICAgYWxpYXNlZFJlcXVpcmU7XG4gICAgICAgIC8vIFRPRE86IEZpbmQgYSBiZXR0ZXIgd2F5IHRvIHJlZ2lzdGVyIGFuZCBsb2FkIGFsbCB0aGUgbG9jYWxlcyBpbiBOb2RlXG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIGxvY2FsZXNbbmFtZV0gPT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgIG1vZHVsZSAmJlxuICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHNcbiAgICAgICAgKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIG9sZExvY2FsZSA9IGdsb2JhbExvY2FsZS5fYWJicjtcbiAgICAgICAgICAgICAgICBhbGlhc2VkUmVxdWlyZSA9IHJlcXVpcmU7XG4gICAgICAgICAgICAgICAgYWxpYXNlZFJlcXVpcmUoJy4vbG9jYWxlLycgKyBuYW1lKTtcbiAgICAgICAgICAgICAgICBnZXRTZXRHbG9iYWxMb2NhbGUob2xkTG9jYWxlKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAvLyBtYXJrIGFzIG5vdCBmb3VuZCB0byBhdm9pZCByZXBlYXRpbmcgZXhwZW5zaXZlIGZpbGUgcmVxdWlyZSBjYWxsIGNhdXNpbmcgaGlnaCBDUFVcbiAgICAgICAgICAgICAgICAvLyB3aGVuIHRyeWluZyB0byBmaW5kIGVuLVVTLCBlbl9VUywgZW4tdXMgZm9yIGV2ZXJ5IGZvcm1hdCBjYWxsXG4gICAgICAgICAgICAgICAgbG9jYWxlc1tuYW1lXSA9IG51bGw7IC8vIG51bGwgbWVhbnMgbm90IGZvdW5kXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxvY2FsZXNbbmFtZV07XG4gICAgfVxuXG4gICAgLy8gVGhpcyBmdW5jdGlvbiB3aWxsIGxvYWQgbG9jYWxlIGFuZCB0aGVuIHNldCB0aGUgZ2xvYmFsIGxvY2FsZS4gIElmXG4gICAgLy8gbm8gYXJndW1lbnRzIGFyZSBwYXNzZWQgaW4sIGl0IHdpbGwgc2ltcGx5IHJldHVybiB0aGUgY3VycmVudCBnbG9iYWxcbiAgICAvLyBsb2NhbGUga2V5LlxuICAgIGZ1bmN0aW9uIGdldFNldEdsb2JhbExvY2FsZShrZXksIHZhbHVlcykge1xuICAgICAgICB2YXIgZGF0YTtcbiAgICAgICAgaWYgKGtleSkge1xuICAgICAgICAgICAgaWYgKGlzVW5kZWZpbmVkKHZhbHVlcykpIHtcbiAgICAgICAgICAgICAgICBkYXRhID0gZ2V0TG9jYWxlKGtleSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRhdGEgPSBkZWZpbmVMb2NhbGUoa2V5LCB2YWx1ZXMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgICAgICAgIC8vIG1vbWVudC5kdXJhdGlvbi5fbG9jYWxlID0gbW9tZW50Ll9sb2NhbGUgPSBkYXRhO1xuICAgICAgICAgICAgICAgIGdsb2JhbExvY2FsZSA9IGRhdGE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiYgY29uc29sZS53YXJuKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vd2FybiB1c2VyIGlmIGFyZ3VtZW50cyBhcmUgcGFzc2VkIGJ1dCB0aGUgbG9jYWxlIGNvdWxkIG5vdCBiZSBzZXRcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0xvY2FsZSAnICsga2V5ICsgJyBub3QgZm91bmQuIERpZCB5b3UgZm9yZ2V0IHRvIGxvYWQgaXQ/J1xuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBnbG9iYWxMb2NhbGUuX2FiYnI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGVmaW5lTG9jYWxlKG5hbWUsIGNvbmZpZykge1xuICAgICAgICBpZiAoY29uZmlnICE9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgbG9jYWxlLFxuICAgICAgICAgICAgICAgIHBhcmVudENvbmZpZyA9IGJhc2VDb25maWc7XG4gICAgICAgICAgICBjb25maWcuYWJiciA9IG5hbWU7XG4gICAgICAgICAgICBpZiAobG9jYWxlc1tuYW1lXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZGVwcmVjYXRlU2ltcGxlKFxuICAgICAgICAgICAgICAgICAgICAnZGVmaW5lTG9jYWxlT3ZlcnJpZGUnLFxuICAgICAgICAgICAgICAgICAgICAndXNlIG1vbWVudC51cGRhdGVMb2NhbGUobG9jYWxlTmFtZSwgY29uZmlnKSB0byBjaGFuZ2UgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnYW4gZXhpc3RpbmcgbG9jYWxlLiBtb21lbnQuZGVmaW5lTG9jYWxlKGxvY2FsZU5hbWUsICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2NvbmZpZykgc2hvdWxkIG9ubHkgYmUgdXNlZCBmb3IgY3JlYXRpbmcgYSBuZXcgbG9jYWxlICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ1NlZSBodHRwOi8vbW9tZW50anMuY29tL2d1aWRlcy8jL3dhcm5pbmdzL2RlZmluZS1sb2NhbGUvIGZvciBtb3JlIGluZm8uJ1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgcGFyZW50Q29uZmlnID0gbG9jYWxlc1tuYW1lXS5fY29uZmlnO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjb25maWcucGFyZW50TG9jYWxlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAobG9jYWxlc1tjb25maWcucGFyZW50TG9jYWxlXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmVudENvbmZpZyA9IGxvY2FsZXNbY29uZmlnLnBhcmVudExvY2FsZV0uX2NvbmZpZztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsb2NhbGUgPSBsb2FkTG9jYWxlKGNvbmZpZy5wYXJlbnRMb2NhbGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobG9jYWxlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudENvbmZpZyA9IGxvY2FsZS5fY29uZmlnO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFsb2NhbGVGYW1pbGllc1tjb25maWcucGFyZW50TG9jYWxlXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsZUZhbWlsaWVzW2NvbmZpZy5wYXJlbnRMb2NhbGVdID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhbGVGYW1pbGllc1tjb25maWcucGFyZW50TG9jYWxlXS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZzogY29uZmlnLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvY2FsZXNbbmFtZV0gPSBuZXcgTG9jYWxlKG1lcmdlQ29uZmlncyhwYXJlbnRDb25maWcsIGNvbmZpZykpO1xuXG4gICAgICAgICAgICBpZiAobG9jYWxlRmFtaWxpZXNbbmFtZV0pIHtcbiAgICAgICAgICAgICAgICBsb2NhbGVGYW1pbGllc1tuYW1lXS5mb3JFYWNoKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICAgICAgICAgIGRlZmluZUxvY2FsZSh4Lm5hbWUsIHguY29uZmlnKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gYmFja3dhcmRzIGNvbXBhdCBmb3Igbm93OiBhbHNvIHNldCB0aGUgbG9jYWxlXG4gICAgICAgICAgICAvLyBtYWtlIHN1cmUgd2Ugc2V0IHRoZSBsb2NhbGUgQUZURVIgYWxsIGNoaWxkIGxvY2FsZXMgaGF2ZSBiZWVuXG4gICAgICAgICAgICAvLyBjcmVhdGVkLCBzbyB3ZSB3b24ndCBlbmQgdXAgd2l0aCB0aGUgY2hpbGQgbG9jYWxlIHNldC5cbiAgICAgICAgICAgIGdldFNldEdsb2JhbExvY2FsZShuYW1lKTtcblxuICAgICAgICAgICAgcmV0dXJuIGxvY2FsZXNbbmFtZV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyB1c2VmdWwgZm9yIHRlc3RpbmdcbiAgICAgICAgICAgIGRlbGV0ZSBsb2NhbGVzW25hbWVdO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1cGRhdGVMb2NhbGUobmFtZSwgY29uZmlnKSB7XG4gICAgICAgIGlmIChjb25maWcgIT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIGxvY2FsZSxcbiAgICAgICAgICAgICAgICB0bXBMb2NhbGUsXG4gICAgICAgICAgICAgICAgcGFyZW50Q29uZmlnID0gYmFzZUNvbmZpZztcblxuICAgICAgICAgICAgaWYgKGxvY2FsZXNbbmFtZV0gIT0gbnVsbCAmJiBsb2NhbGVzW25hbWVdLnBhcmVudExvY2FsZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIGV4aXN0aW5nIGNoaWxkIGxvY2FsZSBpbi1wbGFjZSB0byBhdm9pZCBtZW1vcnktbGVha3NcbiAgICAgICAgICAgICAgICBsb2NhbGVzW25hbWVdLnNldChtZXJnZUNvbmZpZ3MobG9jYWxlc1tuYW1lXS5fY29uZmlnLCBjb25maWcpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gTUVSR0VcbiAgICAgICAgICAgICAgICB0bXBMb2NhbGUgPSBsb2FkTG9jYWxlKG5hbWUpO1xuICAgICAgICAgICAgICAgIGlmICh0bXBMb2NhbGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnRDb25maWcgPSB0bXBMb2NhbGUuX2NvbmZpZztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uZmlnID0gbWVyZ2VDb25maWdzKHBhcmVudENvbmZpZywgY29uZmlnKTtcbiAgICAgICAgICAgICAgICBpZiAodG1wTG9jYWxlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdXBkYXRlTG9jYWxlIGlzIGNhbGxlZCBmb3IgY3JlYXRpbmcgYSBuZXcgbG9jYWxlXG4gICAgICAgICAgICAgICAgICAgIC8vIFNldCBhYmJyIHNvIGl0IHdpbGwgaGF2ZSBhIG5hbWUgKGdldHRlcnMgcmV0dXJuXG4gICAgICAgICAgICAgICAgICAgIC8vIHVuZGVmaW5lZCBvdGhlcndpc2UpLlxuICAgICAgICAgICAgICAgICAgICBjb25maWcuYWJiciA9IG5hbWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxvY2FsZSA9IG5ldyBMb2NhbGUoY29uZmlnKTtcbiAgICAgICAgICAgICAgICBsb2NhbGUucGFyZW50TG9jYWxlID0gbG9jYWxlc1tuYW1lXTtcbiAgICAgICAgICAgICAgICBsb2NhbGVzW25hbWVdID0gbG9jYWxlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBiYWNrd2FyZHMgY29tcGF0IGZvciBub3c6IGFsc28gc2V0IHRoZSBsb2NhbGVcbiAgICAgICAgICAgIGdldFNldEdsb2JhbExvY2FsZShuYW1lKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHBhc3MgbnVsbCBmb3IgY29uZmlnIHRvIHVudXBkYXRlLCB1c2VmdWwgZm9yIHRlc3RzXG4gICAgICAgICAgICBpZiAobG9jYWxlc1tuYW1lXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxvY2FsZXNbbmFtZV0ucGFyZW50TG9jYWxlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxlc1tuYW1lXSA9IGxvY2FsZXNbbmFtZV0ucGFyZW50TG9jYWxlO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmFtZSA9PT0gZ2V0U2V0R2xvYmFsTG9jYWxlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldFNldEdsb2JhbExvY2FsZShuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobG9jYWxlc1tuYW1lXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBsb2NhbGVzW25hbWVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbG9jYWxlc1tuYW1lXTtcbiAgICB9XG5cbiAgICAvLyByZXR1cm5zIGxvY2FsZSBkYXRhXG4gICAgZnVuY3Rpb24gZ2V0TG9jYWxlKGtleSkge1xuICAgICAgICB2YXIgbG9jYWxlO1xuXG4gICAgICAgIGlmIChrZXkgJiYga2V5Ll9sb2NhbGUgJiYga2V5Ll9sb2NhbGUuX2FiYnIpIHtcbiAgICAgICAgICAgIGtleSA9IGtleS5fbG9jYWxlLl9hYmJyO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFrZXkpIHtcbiAgICAgICAgICAgIHJldHVybiBnbG9iYWxMb2NhbGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzQXJyYXkoa2V5KSkge1xuICAgICAgICAgICAgLy9zaG9ydC1jaXJjdWl0IGV2ZXJ5dGhpbmcgZWxzZVxuICAgICAgICAgICAgbG9jYWxlID0gbG9hZExvY2FsZShrZXkpO1xuICAgICAgICAgICAgaWYgKGxvY2FsZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBsb2NhbGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBrZXkgPSBba2V5XTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjaG9vc2VMb2NhbGUoa2V5KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaXN0TG9jYWxlcygpIHtcbiAgICAgICAgcmV0dXJuIGtleXMobG9jYWxlcyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2hlY2tPdmVyZmxvdyhtKSB7XG4gICAgICAgIHZhciBvdmVyZmxvdyxcbiAgICAgICAgICAgIGEgPSBtLl9hO1xuXG4gICAgICAgIGlmIChhICYmIGdldFBhcnNpbmdGbGFncyhtKS5vdmVyZmxvdyA9PT0gLTIpIHtcbiAgICAgICAgICAgIG92ZXJmbG93ID1cbiAgICAgICAgICAgICAgICBhW01PTlRIXSA8IDAgfHwgYVtNT05USF0gPiAxMVxuICAgICAgICAgICAgICAgICAgICA/IE1PTlRIXG4gICAgICAgICAgICAgICAgICAgIDogYVtEQVRFXSA8IDEgfHwgYVtEQVRFXSA+IGRheXNJbk1vbnRoKGFbWUVBUl0sIGFbTU9OVEhdKVxuICAgICAgICAgICAgICAgICAgICA/IERBVEVcbiAgICAgICAgICAgICAgICAgICAgOiBhW0hPVVJdIDwgMCB8fFxuICAgICAgICAgICAgICAgICAgICAgIGFbSE9VUl0gPiAyNCB8fFxuICAgICAgICAgICAgICAgICAgICAgIChhW0hPVVJdID09PSAyNCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAoYVtNSU5VVEVdICE9PSAwIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhW1NFQ09ORF0gIT09IDAgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFbTUlMTElTRUNPTkRdICE9PSAwKSlcbiAgICAgICAgICAgICAgICAgICAgPyBIT1VSXG4gICAgICAgICAgICAgICAgICAgIDogYVtNSU5VVEVdIDwgMCB8fCBhW01JTlVURV0gPiA1OVxuICAgICAgICAgICAgICAgICAgICA/IE1JTlVURVxuICAgICAgICAgICAgICAgICAgICA6IGFbU0VDT05EXSA8IDAgfHwgYVtTRUNPTkRdID4gNTlcbiAgICAgICAgICAgICAgICAgICAgPyBTRUNPTkRcbiAgICAgICAgICAgICAgICAgICAgOiBhW01JTExJU0VDT05EXSA8IDAgfHwgYVtNSUxMSVNFQ09ORF0gPiA5OTlcbiAgICAgICAgICAgICAgICAgICAgPyBNSUxMSVNFQ09ORFxuICAgICAgICAgICAgICAgICAgICA6IC0xO1xuXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKG0pLl9vdmVyZmxvd0RheU9mWWVhciAmJlxuICAgICAgICAgICAgICAgIChvdmVyZmxvdyA8IFlFQVIgfHwgb3ZlcmZsb3cgPiBEQVRFKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgb3ZlcmZsb3cgPSBEQVRFO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdldFBhcnNpbmdGbGFncyhtKS5fb3ZlcmZsb3dXZWVrcyAmJiBvdmVyZmxvdyA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBvdmVyZmxvdyA9IFdFRUs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZ2V0UGFyc2luZ0ZsYWdzKG0pLl9vdmVyZmxvd1dlZWtkYXkgJiYgb3ZlcmZsb3cgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgb3ZlcmZsb3cgPSBXRUVLREFZO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MobSkub3ZlcmZsb3cgPSBvdmVyZmxvdztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtO1xuICAgIH1cblxuICAgIC8vIGlzbyA4NjAxIHJlZ2V4XG4gICAgLy8gMDAwMC0wMC0wMCAwMDAwLVcwMCBvciAwMDAwLVcwMC0wICsgVCArIDAwIG9yIDAwOjAwIG9yIDAwOjAwOjAwIG9yIDAwOjAwOjAwLjAwMCArICswMDowMCBvciArMDAwMCBvciArMDApXG4gICAgdmFyIGV4dGVuZGVkSXNvUmVnZXggPSAvXlxccyooKD86WystXVxcZHs2fXxcXGR7NH0pLSg/OlxcZFxcZC1cXGRcXGR8V1xcZFxcZC1cXGR8V1xcZFxcZHxcXGRcXGRcXGR8XFxkXFxkKSkoPzooVHwgKShcXGRcXGQoPzo6XFxkXFxkKD86OlxcZFxcZCg/OlsuLF1cXGQrKT8pPyk/KShbKy1dXFxkXFxkKD86Oj9cXGRcXGQpP3xcXHMqWik/KT8kLyxcbiAgICAgICAgYmFzaWNJc29SZWdleCA9IC9eXFxzKigoPzpbKy1dXFxkezZ9fFxcZHs0fSkoPzpcXGRcXGRcXGRcXGR8V1xcZFxcZFxcZHxXXFxkXFxkfFxcZFxcZFxcZHxcXGRcXGR8KSkoPzooVHwgKShcXGRcXGQoPzpcXGRcXGQoPzpcXGRcXGQoPzpbLixdXFxkKyk/KT8pPykoWystXVxcZFxcZCg/Ojo/XFxkXFxkKT98XFxzKlopPyk/JC8sXG4gICAgICAgIHR6UmVnZXggPSAvWnxbKy1dXFxkXFxkKD86Oj9cXGRcXGQpPy8sXG4gICAgICAgIGlzb0RhdGVzID0gW1xuICAgICAgICAgICAgWydZWVlZWVktTU0tREQnLCAvWystXVxcZHs2fS1cXGRcXGQtXFxkXFxkL10sXG4gICAgICAgICAgICBbJ1lZWVktTU0tREQnLCAvXFxkezR9LVxcZFxcZC1cXGRcXGQvXSxcbiAgICAgICAgICAgIFsnR0dHRy1bV11XVy1FJywgL1xcZHs0fS1XXFxkXFxkLVxcZC9dLFxuICAgICAgICAgICAgWydHR0dHLVtXXVdXJywgL1xcZHs0fS1XXFxkXFxkLywgZmFsc2VdLFxuICAgICAgICAgICAgWydZWVlZLURERCcsIC9cXGR7NH0tXFxkezN9L10sXG4gICAgICAgICAgICBbJ1lZWVktTU0nLCAvXFxkezR9LVxcZFxcZC8sIGZhbHNlXSxcbiAgICAgICAgICAgIFsnWVlZWVlZTU1ERCcsIC9bKy1dXFxkezEwfS9dLFxuICAgICAgICAgICAgWydZWVlZTU1ERCcsIC9cXGR7OH0vXSxcbiAgICAgICAgICAgIFsnR0dHR1tXXVdXRScsIC9cXGR7NH1XXFxkezN9L10sXG4gICAgICAgICAgICBbJ0dHR0dbV11XVycsIC9cXGR7NH1XXFxkezJ9LywgZmFsc2VdLFxuICAgICAgICAgICAgWydZWVlZREREJywgL1xcZHs3fS9dLFxuICAgICAgICAgICAgWydZWVlZTU0nLCAvXFxkezZ9LywgZmFsc2VdLFxuICAgICAgICAgICAgWydZWVlZJywgL1xcZHs0fS8sIGZhbHNlXSxcbiAgICAgICAgXSxcbiAgICAgICAgLy8gaXNvIHRpbWUgZm9ybWF0cyBhbmQgcmVnZXhlc1xuICAgICAgICBpc29UaW1lcyA9IFtcbiAgICAgICAgICAgIFsnSEg6bW06c3MuU1NTUycsIC9cXGRcXGQ6XFxkXFxkOlxcZFxcZFxcLlxcZCsvXSxcbiAgICAgICAgICAgIFsnSEg6bW06c3MsU1NTUycsIC9cXGRcXGQ6XFxkXFxkOlxcZFxcZCxcXGQrL10sXG4gICAgICAgICAgICBbJ0hIOm1tOnNzJywgL1xcZFxcZDpcXGRcXGQ6XFxkXFxkL10sXG4gICAgICAgICAgICBbJ0hIOm1tJywgL1xcZFxcZDpcXGRcXGQvXSxcbiAgICAgICAgICAgIFsnSEhtbXNzLlNTU1MnLCAvXFxkXFxkXFxkXFxkXFxkXFxkXFwuXFxkKy9dLFxuICAgICAgICAgICAgWydISG1tc3MsU1NTUycsIC9cXGRcXGRcXGRcXGRcXGRcXGQsXFxkKy9dLFxuICAgICAgICAgICAgWydISG1tc3MnLCAvXFxkXFxkXFxkXFxkXFxkXFxkL10sXG4gICAgICAgICAgICBbJ0hIbW0nLCAvXFxkXFxkXFxkXFxkL10sXG4gICAgICAgICAgICBbJ0hIJywgL1xcZFxcZC9dLFxuICAgICAgICBdLFxuICAgICAgICBhc3BOZXRKc29uUmVnZXggPSAvXlxcLz9EYXRlXFwoKC0/XFxkKykvaSxcbiAgICAgICAgLy8gUkZDIDI4MjIgcmVnZXg6IEZvciBkZXRhaWxzIHNlZSBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMjgyMiNzZWN0aW9uLTMuM1xuICAgICAgICByZmMyODIyID0gL14oPzooTW9ufFR1ZXxXZWR8VGh1fEZyaXxTYXR8U3VuKSw/XFxzKT8oXFxkezEsMn0pXFxzKEphbnxGZWJ8TWFyfEFwcnxNYXl8SnVufEp1bHxBdWd8U2VwfE9jdHxOb3Z8RGVjKVxccyhcXGR7Miw0fSlcXHMoXFxkXFxkKTooXFxkXFxkKSg/OjooXFxkXFxkKSk/XFxzKD86KFVUfEdNVHxbRUNNUF1bU0RdVCl8KFtael0pfChbKy1dXFxkezR9KSkkLyxcbiAgICAgICAgb2JzT2Zmc2V0cyA9IHtcbiAgICAgICAgICAgIFVUOiAwLFxuICAgICAgICAgICAgR01UOiAwLFxuICAgICAgICAgICAgRURUOiAtNCAqIDYwLFxuICAgICAgICAgICAgRVNUOiAtNSAqIDYwLFxuICAgICAgICAgICAgQ0RUOiAtNSAqIDYwLFxuICAgICAgICAgICAgQ1NUOiAtNiAqIDYwLFxuICAgICAgICAgICAgTURUOiAtNiAqIDYwLFxuICAgICAgICAgICAgTVNUOiAtNyAqIDYwLFxuICAgICAgICAgICAgUERUOiAtNyAqIDYwLFxuICAgICAgICAgICAgUFNUOiAtOCAqIDYwLFxuICAgICAgICB9O1xuXG4gICAgLy8gZGF0ZSBmcm9tIGlzbyBmb3JtYXRcbiAgICBmdW5jdGlvbiBjb25maWdGcm9tSVNPKGNvbmZpZykge1xuICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgIGwsXG4gICAgICAgICAgICBzdHJpbmcgPSBjb25maWcuX2ksXG4gICAgICAgICAgICBtYXRjaCA9IGV4dGVuZGVkSXNvUmVnZXguZXhlYyhzdHJpbmcpIHx8IGJhc2ljSXNvUmVnZXguZXhlYyhzdHJpbmcpLFxuICAgICAgICAgICAgYWxsb3dUaW1lLFxuICAgICAgICAgICAgZGF0ZUZvcm1hdCxcbiAgICAgICAgICAgIHRpbWVGb3JtYXQsXG4gICAgICAgICAgICB0ekZvcm1hdDtcblxuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmlzbyA9IHRydWU7XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGwgPSBpc29EYXRlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNvRGF0ZXNbaV1bMV0uZXhlYyhtYXRjaFsxXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0ZUZvcm1hdCA9IGlzb0RhdGVzW2ldWzBdO1xuICAgICAgICAgICAgICAgICAgICBhbGxvd1RpbWUgPSBpc29EYXRlc1tpXVsyXSAhPT0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkYXRlRm9ybWF0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb25maWcuX2lzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWF0Y2hbM10pIHtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBsID0gaXNvVGltZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc29UaW1lc1tpXVsxXS5leGVjKG1hdGNoWzNdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWF0Y2hbMl0gc2hvdWxkIGJlICdUJyBvciBzcGFjZVxuICAgICAgICAgICAgICAgICAgICAgICAgdGltZUZvcm1hdCA9IChtYXRjaFsyXSB8fCAnICcpICsgaXNvVGltZXNbaV1bMF07XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGltZUZvcm1hdCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZy5faXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFhbGxvd1RpbWUgJiYgdGltZUZvcm1hdCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29uZmlnLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1hdGNoWzRdKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR6UmVnZXguZXhlYyhtYXRjaFs0XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdHpGb3JtYXQgPSAnWic7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25maWcuX2YgPSBkYXRlRm9ybWF0ICsgKHRpbWVGb3JtYXQgfHwgJycpICsgKHR6Rm9ybWF0IHx8ICcnKTtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21TdHJpbmdBbmRGb3JtYXQoY29uZmlnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbmZpZy5faXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXh0cmFjdEZyb21SRkMyODIyU3RyaW5ncyhcbiAgICAgICAgeWVhclN0cixcbiAgICAgICAgbW9udGhTdHIsXG4gICAgICAgIGRheVN0cixcbiAgICAgICAgaG91clN0cixcbiAgICAgICAgbWludXRlU3RyLFxuICAgICAgICBzZWNvbmRTdHJcbiAgICApIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtcbiAgICAgICAgICAgIHVudHJ1bmNhdGVZZWFyKHllYXJTdHIpLFxuICAgICAgICAgICAgZGVmYXVsdExvY2FsZU1vbnRoc1Nob3J0LmluZGV4T2YobW9udGhTdHIpLFxuICAgICAgICAgICAgcGFyc2VJbnQoZGF5U3RyLCAxMCksXG4gICAgICAgICAgICBwYXJzZUludChob3VyU3RyLCAxMCksXG4gICAgICAgICAgICBwYXJzZUludChtaW51dGVTdHIsIDEwKSxcbiAgICAgICAgXTtcblxuICAgICAgICBpZiAoc2Vjb25kU3RyKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChwYXJzZUludChzZWNvbmRTdHIsIDEwKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVudHJ1bmNhdGVZZWFyKHllYXJTdHIpIHtcbiAgICAgICAgdmFyIHllYXIgPSBwYXJzZUludCh5ZWFyU3RyLCAxMCk7XG4gICAgICAgIGlmICh5ZWFyIDw9IDQ5KSB7XG4gICAgICAgICAgICByZXR1cm4gMjAwMCArIHllYXI7XG4gICAgICAgIH0gZWxzZSBpZiAoeWVhciA8PSA5OTkpIHtcbiAgICAgICAgICAgIHJldHVybiAxOTAwICsgeWVhcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geWVhcjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcmVwcm9jZXNzUkZDMjgyMihzKSB7XG4gICAgICAgIC8vIFJlbW92ZSBjb21tZW50cyBhbmQgZm9sZGluZyB3aGl0ZXNwYWNlIGFuZCByZXBsYWNlIG11bHRpcGxlLXNwYWNlcyB3aXRoIGEgc2luZ2xlIHNwYWNlXG4gICAgICAgIHJldHVybiBzXG4gICAgICAgICAgICAucmVwbGFjZSgvXFwoW14pXSpcXCl8W1xcblxcdF0vZywgJyAnKVxuICAgICAgICAgICAgLnJlcGxhY2UoLyhcXHNcXHMrKS9nLCAnICcpXG4gICAgICAgICAgICAucmVwbGFjZSgvXlxcc1xccyovLCAnJylcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXHNcXHMqJC8sICcnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjaGVja1dlZWtkYXkod2Vla2RheVN0ciwgcGFyc2VkSW5wdXQsIGNvbmZpZykge1xuICAgICAgICBpZiAod2Vla2RheVN0cikge1xuICAgICAgICAgICAgLy8gVE9ETzogUmVwbGFjZSB0aGUgdmFuaWxsYSBKUyBEYXRlIG9iamVjdCB3aXRoIGFuIGluZGVwZW5kZW50IGRheS1vZi13ZWVrIGNoZWNrLlxuICAgICAgICAgICAgdmFyIHdlZWtkYXlQcm92aWRlZCA9IGRlZmF1bHRMb2NhbGVXZWVrZGF5c1Nob3J0LmluZGV4T2Yod2Vla2RheVN0ciksXG4gICAgICAgICAgICAgICAgd2Vla2RheUFjdHVhbCA9IG5ldyBEYXRlKFxuICAgICAgICAgICAgICAgICAgICBwYXJzZWRJbnB1dFswXSxcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VkSW5wdXRbMV0sXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZElucHV0WzJdXG4gICAgICAgICAgICAgICAgKS5nZXREYXkoKTtcbiAgICAgICAgICAgIGlmICh3ZWVrZGF5UHJvdmlkZWQgIT09IHdlZWtkYXlBY3R1YWwpIHtcbiAgICAgICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS53ZWVrZGF5TWlzbWF0Y2ggPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNvbmZpZy5faXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjYWxjdWxhdGVPZmZzZXQob2JzT2Zmc2V0LCBtaWxpdGFyeU9mZnNldCwgbnVtT2Zmc2V0KSB7XG4gICAgICAgIGlmIChvYnNPZmZzZXQpIHtcbiAgICAgICAgICAgIHJldHVybiBvYnNPZmZzZXRzW29ic09mZnNldF07XG4gICAgICAgIH0gZWxzZSBpZiAobWlsaXRhcnlPZmZzZXQpIHtcbiAgICAgICAgICAgIC8vIHRoZSBvbmx5IGFsbG93ZWQgbWlsaXRhcnkgdHogaXMgWlxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgaG0gPSBwYXJzZUludChudW1PZmZzZXQsIDEwKSxcbiAgICAgICAgICAgICAgICBtID0gaG0gJSAxMDAsXG4gICAgICAgICAgICAgICAgaCA9IChobSAtIG0pIC8gMTAwO1xuICAgICAgICAgICAgcmV0dXJuIGggKiA2MCArIG07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBkYXRlIGFuZCB0aW1lIGZyb20gcmVmIDI4MjIgZm9ybWF0XG4gICAgZnVuY3Rpb24gY29uZmlnRnJvbVJGQzI4MjIoY29uZmlnKSB7XG4gICAgICAgIHZhciBtYXRjaCA9IHJmYzI4MjIuZXhlYyhwcmVwcm9jZXNzUkZDMjgyMihjb25maWcuX2kpKSxcbiAgICAgICAgICAgIHBhcnNlZEFycmF5O1xuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIHBhcnNlZEFycmF5ID0gZXh0cmFjdEZyb21SRkMyODIyU3RyaW5ncyhcbiAgICAgICAgICAgICAgICBtYXRjaFs0XSxcbiAgICAgICAgICAgICAgICBtYXRjaFszXSxcbiAgICAgICAgICAgICAgICBtYXRjaFsyXSxcbiAgICAgICAgICAgICAgICBtYXRjaFs1XSxcbiAgICAgICAgICAgICAgICBtYXRjaFs2XSxcbiAgICAgICAgICAgICAgICBtYXRjaFs3XVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmICghY2hlY2tXZWVrZGF5KG1hdGNoWzFdLCBwYXJzZWRBcnJheSwgY29uZmlnKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uZmlnLl9hID0gcGFyc2VkQXJyYXk7XG4gICAgICAgICAgICBjb25maWcuX3R6bSA9IGNhbGN1bGF0ZU9mZnNldChtYXRjaFs4XSwgbWF0Y2hbOV0sIG1hdGNoWzEwXSk7XG5cbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IGNyZWF0ZVVUQ0RhdGUuYXBwbHkobnVsbCwgY29uZmlnLl9hKTtcbiAgICAgICAgICAgIGNvbmZpZy5fZC5zZXRVVENNaW51dGVzKGNvbmZpZy5fZC5nZXRVVENNaW51dGVzKCkgLSBjb25maWcuX3R6bSk7XG5cbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLnJmYzI4MjIgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uZmlnLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBkYXRlIGZyb20gMSkgQVNQLk5FVCwgMikgSVNPLCAzKSBSRkMgMjgyMiBmb3JtYXRzLCBvciA0KSBvcHRpb25hbCBmYWxsYmFjayBpZiBwYXJzaW5nIGlzbid0IHN0cmljdFxuICAgIGZ1bmN0aW9uIGNvbmZpZ0Zyb21TdHJpbmcoY29uZmlnKSB7XG4gICAgICAgIHZhciBtYXRjaGVkID0gYXNwTmV0SnNvblJlZ2V4LmV4ZWMoY29uZmlnLl9pKTtcbiAgICAgICAgaWYgKG1hdGNoZWQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKCttYXRjaGVkWzFdKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbmZpZ0Zyb21JU08oY29uZmlnKTtcbiAgICAgICAgaWYgKGNvbmZpZy5faXNWYWxpZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBjb25maWcuX2lzVmFsaWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25maWdGcm9tUkZDMjgyMihjb25maWcpO1xuICAgICAgICBpZiAoY29uZmlnLl9pc1ZhbGlkID09PSBmYWxzZSkge1xuICAgICAgICAgICAgZGVsZXRlIGNvbmZpZy5faXNWYWxpZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb25maWcuX3N0cmljdCkge1xuICAgICAgICAgICAgY29uZmlnLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBGaW5hbCBhdHRlbXB0LCB1c2UgSW5wdXQgRmFsbGJhY2tcbiAgICAgICAgICAgIGhvb2tzLmNyZWF0ZUZyb21JbnB1dEZhbGxiYWNrKGNvbmZpZyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBob29rcy5jcmVhdGVGcm9tSW5wdXRGYWxsYmFjayA9IGRlcHJlY2F0ZShcbiAgICAgICAgJ3ZhbHVlIHByb3ZpZGVkIGlzIG5vdCBpbiBhIHJlY29nbml6ZWQgUkZDMjgyMiBvciBJU08gZm9ybWF0LiBtb21lbnQgY29uc3RydWN0aW9uIGZhbGxzIGJhY2sgdG8ganMgRGF0ZSgpLCAnICtcbiAgICAgICAgICAgICd3aGljaCBpcyBub3QgcmVsaWFibGUgYWNyb3NzIGFsbCBicm93c2VycyBhbmQgdmVyc2lvbnMuIE5vbiBSRkMyODIyL0lTTyBkYXRlIGZvcm1hdHMgYXJlICcgK1xuICAgICAgICAgICAgJ2Rpc2NvdXJhZ2VkLiBQbGVhc2UgcmVmZXIgdG8gaHR0cDovL21vbWVudGpzLmNvbS9ndWlkZXMvIy93YXJuaW5ncy9qcy1kYXRlLyBmb3IgbW9yZSBpbmZvLicsXG4gICAgICAgIGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKGNvbmZpZy5faSArIChjb25maWcuX3VzZVVUQyA/ICcgVVRDJyA6ICcnKSk7XG4gICAgICAgIH1cbiAgICApO1xuXG4gICAgLy8gUGljayB0aGUgZmlyc3QgZGVmaW5lZCBvZiB0d28gb3IgdGhyZWUgYXJndW1lbnRzLlxuICAgIGZ1bmN0aW9uIGRlZmF1bHRzKGEsIGIsIGMpIHtcbiAgICAgICAgaWYgKGEgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGIgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3VycmVudERhdGVBcnJheShjb25maWcpIHtcbiAgICAgICAgLy8gaG9va3MgaXMgYWN0dWFsbHkgdGhlIGV4cG9ydGVkIG1vbWVudCBvYmplY3RcbiAgICAgICAgdmFyIG5vd1ZhbHVlID0gbmV3IERhdGUoaG9va3Mubm93KCkpO1xuICAgICAgICBpZiAoY29uZmlnLl91c2VVVEMpIHtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgbm93VmFsdWUuZ2V0VVRDRnVsbFllYXIoKSxcbiAgICAgICAgICAgICAgICBub3dWYWx1ZS5nZXRVVENNb250aCgpLFxuICAgICAgICAgICAgICAgIG5vd1ZhbHVlLmdldFVUQ0RhdGUoKSxcbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtub3dWYWx1ZS5nZXRGdWxsWWVhcigpLCBub3dWYWx1ZS5nZXRNb250aCgpLCBub3dWYWx1ZS5nZXREYXRlKCldO1xuICAgIH1cblxuICAgIC8vIGNvbnZlcnQgYW4gYXJyYXkgdG8gYSBkYXRlLlxuICAgIC8vIHRoZSBhcnJheSBzaG91bGQgbWlycm9yIHRoZSBwYXJhbWV0ZXJzIGJlbG93XG4gICAgLy8gbm90ZTogYWxsIHZhbHVlcyBwYXN0IHRoZSB5ZWFyIGFyZSBvcHRpb25hbCBhbmQgd2lsbCBkZWZhdWx0IHRvIHRoZSBsb3dlc3QgcG9zc2libGUgdmFsdWUuXG4gICAgLy8gW3llYXIsIG1vbnRoLCBkYXkgLCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmRdXG4gICAgZnVuY3Rpb24gY29uZmlnRnJvbUFycmF5KGNvbmZpZykge1xuICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgIGRhdGUsXG4gICAgICAgICAgICBpbnB1dCA9IFtdLFxuICAgICAgICAgICAgY3VycmVudERhdGUsXG4gICAgICAgICAgICBleHBlY3RlZFdlZWtkYXksXG4gICAgICAgICAgICB5ZWFyVG9Vc2U7XG5cbiAgICAgICAgaWYgKGNvbmZpZy5fZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY3VycmVudERhdGUgPSBjdXJyZW50RGF0ZUFycmF5KGNvbmZpZyk7XG5cbiAgICAgICAgLy9jb21wdXRlIGRheSBvZiB0aGUgeWVhciBmcm9tIHdlZWtzIGFuZCB3ZWVrZGF5c1xuICAgICAgICBpZiAoY29uZmlnLl93ICYmIGNvbmZpZy5fYVtEQVRFXSA9PSBudWxsICYmIGNvbmZpZy5fYVtNT05USF0gPT0gbnVsbCkge1xuICAgICAgICAgICAgZGF5T2ZZZWFyRnJvbVdlZWtJbmZvKGNvbmZpZyk7XG4gICAgICAgIH1cblxuICAgICAgICAvL2lmIHRoZSBkYXkgb2YgdGhlIHllYXIgaXMgc2V0LCBmaWd1cmUgb3V0IHdoYXQgaXQgaXNcbiAgICAgICAgaWYgKGNvbmZpZy5fZGF5T2ZZZWFyICE9IG51bGwpIHtcbiAgICAgICAgICAgIHllYXJUb1VzZSA9IGRlZmF1bHRzKGNvbmZpZy5fYVtZRUFSXSwgY3VycmVudERhdGVbWUVBUl0pO1xuXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgY29uZmlnLl9kYXlPZlllYXIgPiBkYXlzSW5ZZWFyKHllYXJUb1VzZSkgfHxcbiAgICAgICAgICAgICAgICBjb25maWcuX2RheU9mWWVhciA9PT0gMFxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuX292ZXJmbG93RGF5T2ZZZWFyID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZGF0ZSA9IGNyZWF0ZVVUQ0RhdGUoeWVhclRvVXNlLCAwLCBjb25maWcuX2RheU9mWWVhcik7XG4gICAgICAgICAgICBjb25maWcuX2FbTU9OVEhdID0gZGF0ZS5nZXRVVENNb250aCgpO1xuICAgICAgICAgICAgY29uZmlnLl9hW0RBVEVdID0gZGF0ZS5nZXRVVENEYXRlKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZWZhdWx0IHRvIGN1cnJlbnQgZGF0ZS5cbiAgICAgICAgLy8gKiBpZiBubyB5ZWFyLCBtb250aCwgZGF5IG9mIG1vbnRoIGFyZSBnaXZlbiwgZGVmYXVsdCB0byB0b2RheVxuICAgICAgICAvLyAqIGlmIGRheSBvZiBtb250aCBpcyBnaXZlbiwgZGVmYXVsdCBtb250aCBhbmQgeWVhclxuICAgICAgICAvLyAqIGlmIG1vbnRoIGlzIGdpdmVuLCBkZWZhdWx0IG9ubHkgeWVhclxuICAgICAgICAvLyAqIGlmIHllYXIgaXMgZ2l2ZW4sIGRvbid0IGRlZmF1bHQgYW55dGhpbmdcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDMgJiYgY29uZmlnLl9hW2ldID09IG51bGw7ICsraSkge1xuICAgICAgICAgICAgY29uZmlnLl9hW2ldID0gaW5wdXRbaV0gPSBjdXJyZW50RGF0ZVtpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFplcm8gb3V0IHdoYXRldmVyIHdhcyBub3QgZGVmYXVsdGVkLCBpbmNsdWRpbmcgdGltZVxuICAgICAgICBmb3IgKDsgaSA8IDc7IGkrKykge1xuICAgICAgICAgICAgY29uZmlnLl9hW2ldID0gaW5wdXRbaV0gPVxuICAgICAgICAgICAgICAgIGNvbmZpZy5fYVtpXSA9PSBudWxsID8gKGkgPT09IDIgPyAxIDogMCkgOiBjb25maWcuX2FbaV07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDaGVjayBmb3IgMjQ6MDA6MDAuMDAwXG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIGNvbmZpZy5fYVtIT1VSXSA9PT0gMjQgJiZcbiAgICAgICAgICAgIGNvbmZpZy5fYVtNSU5VVEVdID09PSAwICYmXG4gICAgICAgICAgICBjb25maWcuX2FbU0VDT05EXSA9PT0gMCAmJlxuICAgICAgICAgICAgY29uZmlnLl9hW01JTExJU0VDT05EXSA9PT0gMFxuICAgICAgICApIHtcbiAgICAgICAgICAgIGNvbmZpZy5fbmV4dERheSA9IHRydWU7XG4gICAgICAgICAgICBjb25maWcuX2FbSE9VUl0gPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uZmlnLl9kID0gKGNvbmZpZy5fdXNlVVRDID8gY3JlYXRlVVRDRGF0ZSA6IGNyZWF0ZURhdGUpLmFwcGx5KFxuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgIGlucHV0XG4gICAgICAgICk7XG4gICAgICAgIGV4cGVjdGVkV2Vla2RheSA9IGNvbmZpZy5fdXNlVVRDXG4gICAgICAgICAgICA/IGNvbmZpZy5fZC5nZXRVVENEYXkoKVxuICAgICAgICAgICAgOiBjb25maWcuX2QuZ2V0RGF5KCk7XG5cbiAgICAgICAgLy8gQXBwbHkgdGltZXpvbmUgb2Zmc2V0IGZyb20gaW5wdXQuIFRoZSBhY3R1YWwgdXRjT2Zmc2V0IGNhbiBiZSBjaGFuZ2VkXG4gICAgICAgIC8vIHdpdGggcGFyc2Vab25lLlxuICAgICAgICBpZiAoY29uZmlnLl90em0gIT0gbnVsbCkge1xuICAgICAgICAgICAgY29uZmlnLl9kLnNldFVUQ01pbnV0ZXMoY29uZmlnLl9kLmdldFVUQ01pbnV0ZXMoKSAtIGNvbmZpZy5fdHptKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb25maWcuX25leHREYXkpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fYVtIT1VSXSA9IDI0O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY2hlY2sgZm9yIG1pc21hdGNoaW5nIGRheSBvZiB3ZWVrXG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIGNvbmZpZy5fdyAmJlxuICAgICAgICAgICAgdHlwZW9mIGNvbmZpZy5fdy5kICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgY29uZmlnLl93LmQgIT09IGV4cGVjdGVkV2Vla2RheVxuICAgICAgICApIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLndlZWtkYXlNaXNtYXRjaCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkYXlPZlllYXJGcm9tV2Vla0luZm8oY29uZmlnKSB7XG4gICAgICAgIHZhciB3LCB3ZWVrWWVhciwgd2Vlaywgd2Vla2RheSwgZG93LCBkb3ksIHRlbXAsIHdlZWtkYXlPdmVyZmxvdywgY3VyV2VlaztcblxuICAgICAgICB3ID0gY29uZmlnLl93O1xuICAgICAgICBpZiAody5HRyAhPSBudWxsIHx8IHcuVyAhPSBudWxsIHx8IHcuRSAhPSBudWxsKSB7XG4gICAgICAgICAgICBkb3cgPSAxO1xuICAgICAgICAgICAgZG95ID0gNDtcblxuICAgICAgICAgICAgLy8gVE9ETzogV2UgbmVlZCB0byB0YWtlIHRoZSBjdXJyZW50IGlzb1dlZWtZZWFyLCBidXQgdGhhdCBkZXBlbmRzIG9uXG4gICAgICAgICAgICAvLyBob3cgd2UgaW50ZXJwcmV0IG5vdyAobG9jYWwsIHV0YywgZml4ZWQgb2Zmc2V0KS4gU28gY3JlYXRlXG4gICAgICAgICAgICAvLyBhIG5vdyB2ZXJzaW9uIG9mIGN1cnJlbnQgY29uZmlnICh0YWtlIGxvY2FsL3V0Yy9vZmZzZXQgZmxhZ3MsIGFuZFxuICAgICAgICAgICAgLy8gY3JlYXRlIG5vdykuXG4gICAgICAgICAgICB3ZWVrWWVhciA9IGRlZmF1bHRzKFxuICAgICAgICAgICAgICAgIHcuR0csXG4gICAgICAgICAgICAgICAgY29uZmlnLl9hW1lFQVJdLFxuICAgICAgICAgICAgICAgIHdlZWtPZlllYXIoY3JlYXRlTG9jYWwoKSwgMSwgNCkueWVhclxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHdlZWsgPSBkZWZhdWx0cyh3LlcsIDEpO1xuICAgICAgICAgICAgd2Vla2RheSA9IGRlZmF1bHRzKHcuRSwgMSk7XG4gICAgICAgICAgICBpZiAod2Vla2RheSA8IDEgfHwgd2Vla2RheSA+IDcpIHtcbiAgICAgICAgICAgICAgICB3ZWVrZGF5T3ZlcmZsb3cgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZG93ID0gY29uZmlnLl9sb2NhbGUuX3dlZWsuZG93O1xuICAgICAgICAgICAgZG95ID0gY29uZmlnLl9sb2NhbGUuX3dlZWsuZG95O1xuXG4gICAgICAgICAgICBjdXJXZWVrID0gd2Vla09mWWVhcihjcmVhdGVMb2NhbCgpLCBkb3csIGRveSk7XG5cbiAgICAgICAgICAgIHdlZWtZZWFyID0gZGVmYXVsdHMody5nZywgY29uZmlnLl9hW1lFQVJdLCBjdXJXZWVrLnllYXIpO1xuXG4gICAgICAgICAgICAvLyBEZWZhdWx0IHRvIGN1cnJlbnQgd2Vlay5cbiAgICAgICAgICAgIHdlZWsgPSBkZWZhdWx0cyh3LncsIGN1cldlZWsud2Vlayk7XG5cbiAgICAgICAgICAgIGlmICh3LmQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIHdlZWtkYXkgLS0gbG93IGRheSBudW1iZXJzIGFyZSBjb25zaWRlcmVkIG5leHQgd2Vla1xuICAgICAgICAgICAgICAgIHdlZWtkYXkgPSB3LmQ7XG4gICAgICAgICAgICAgICAgaWYgKHdlZWtkYXkgPCAwIHx8IHdlZWtkYXkgPiA2KSB7XG4gICAgICAgICAgICAgICAgICAgIHdlZWtkYXlPdmVyZmxvdyA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICh3LmUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIGxvY2FsIHdlZWtkYXkgLS0gY291bnRpbmcgc3RhcnRzIGZyb20gYmVnaW5uaW5nIG9mIHdlZWtcbiAgICAgICAgICAgICAgICB3ZWVrZGF5ID0gdy5lICsgZG93O1xuICAgICAgICAgICAgICAgIGlmICh3LmUgPCAwIHx8IHcuZSA+IDYpIHtcbiAgICAgICAgICAgICAgICAgICAgd2Vla2RheU92ZXJmbG93ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGRlZmF1bHQgdG8gYmVnaW5uaW5nIG9mIHdlZWtcbiAgICAgICAgICAgICAgICB3ZWVrZGF5ID0gZG93O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh3ZWVrIDwgMSB8fCB3ZWVrID4gd2Vla3NJblllYXIod2Vla1llYXIsIGRvdywgZG95KSkge1xuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuX292ZXJmbG93V2Vla3MgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKHdlZWtkYXlPdmVyZmxvdyAhPSBudWxsKSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5fb3ZlcmZsb3dXZWVrZGF5ID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRlbXAgPSBkYXlPZlllYXJGcm9tV2Vla3Mod2Vla1llYXIsIHdlZWssIHdlZWtkYXksIGRvdywgZG95KTtcbiAgICAgICAgICAgIGNvbmZpZy5fYVtZRUFSXSA9IHRlbXAueWVhcjtcbiAgICAgICAgICAgIGNvbmZpZy5fZGF5T2ZZZWFyID0gdGVtcC5kYXlPZlllYXI7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBjb25zdGFudCB0aGF0IHJlZmVycyB0byB0aGUgSVNPIHN0YW5kYXJkXG4gICAgaG9va3MuSVNPXzg2MDEgPSBmdW5jdGlvbiAoKSB7fTtcblxuICAgIC8vIGNvbnN0YW50IHRoYXQgcmVmZXJzIHRvIHRoZSBSRkMgMjgyMiBmb3JtXG4gICAgaG9va3MuUkZDXzI4MjIgPSBmdW5jdGlvbiAoKSB7fTtcblxuICAgIC8vIGRhdGUgZnJvbSBzdHJpbmcgYW5kIGZvcm1hdCBzdHJpbmdcbiAgICBmdW5jdGlvbiBjb25maWdGcm9tU3RyaW5nQW5kRm9ybWF0KGNvbmZpZykge1xuICAgICAgICAvLyBUT0RPOiBNb3ZlIHRoaXMgdG8gYW5vdGhlciBwYXJ0IG9mIHRoZSBjcmVhdGlvbiBmbG93IHRvIHByZXZlbnQgY2lyY3VsYXIgZGVwc1xuICAgICAgICBpZiAoY29uZmlnLl9mID09PSBob29rcy5JU09fODYwMSkge1xuICAgICAgICAgICAgY29uZmlnRnJvbUlTTyhjb25maWcpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb25maWcuX2YgPT09IGhvb2tzLlJGQ18yODIyKSB7XG4gICAgICAgICAgICBjb25maWdGcm9tUkZDMjgyMihjb25maWcpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbmZpZy5fYSA9IFtdO1xuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5lbXB0eSA9IHRydWU7XG5cbiAgICAgICAgLy8gVGhpcyBhcnJheSBpcyB1c2VkIHRvIG1ha2UgYSBEYXRlLCBlaXRoZXIgd2l0aCBgbmV3IERhdGVgIG9yIGBEYXRlLlVUQ2BcbiAgICAgICAgdmFyIHN0cmluZyA9ICcnICsgY29uZmlnLl9pLFxuICAgICAgICAgICAgaSxcbiAgICAgICAgICAgIHBhcnNlZElucHV0LFxuICAgICAgICAgICAgdG9rZW5zLFxuICAgICAgICAgICAgdG9rZW4sXG4gICAgICAgICAgICBza2lwcGVkLFxuICAgICAgICAgICAgc3RyaW5nTGVuZ3RoID0gc3RyaW5nLmxlbmd0aCxcbiAgICAgICAgICAgIHRvdGFsUGFyc2VkSW5wdXRMZW5ndGggPSAwLFxuICAgICAgICAgICAgZXJhO1xuXG4gICAgICAgIHRva2VucyA9XG4gICAgICAgICAgICBleHBhbmRGb3JtYXQoY29uZmlnLl9mLCBjb25maWcuX2xvY2FsZSkubWF0Y2goZm9ybWF0dGluZ1Rva2VucykgfHwgW107XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdG9rZW4gPSB0b2tlbnNbaV07XG4gICAgICAgICAgICBwYXJzZWRJbnB1dCA9IChzdHJpbmcubWF0Y2goZ2V0UGFyc2VSZWdleEZvclRva2VuKHRva2VuLCBjb25maWcpKSB8fFxuICAgICAgICAgICAgICAgIFtdKVswXTtcbiAgICAgICAgICAgIGlmIChwYXJzZWRJbnB1dCkge1xuICAgICAgICAgICAgICAgIHNraXBwZWQgPSBzdHJpbmcuc3Vic3RyKDAsIHN0cmluZy5pbmRleE9mKHBhcnNlZElucHV0KSk7XG4gICAgICAgICAgICAgICAgaWYgKHNraXBwZWQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS51bnVzZWRJbnB1dC5wdXNoKHNraXBwZWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdHJpbmcgPSBzdHJpbmcuc2xpY2UoXG4gICAgICAgICAgICAgICAgICAgIHN0cmluZy5pbmRleE9mKHBhcnNlZElucHV0KSArIHBhcnNlZElucHV0Lmxlbmd0aFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgdG90YWxQYXJzZWRJbnB1dExlbmd0aCArPSBwYXJzZWRJbnB1dC5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBkb24ndCBwYXJzZSBpZiBpdCdzIG5vdCBhIGtub3duIHRva2VuXG4gICAgICAgICAgICBpZiAoZm9ybWF0VG9rZW5GdW5jdGlvbnNbdG9rZW5dKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlZElucHV0KSB7XG4gICAgICAgICAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmVtcHR5ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykudW51c2VkVG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhZGRUaW1lVG9BcnJheUZyb21Ub2tlbih0b2tlbiwgcGFyc2VkSW5wdXQsIGNvbmZpZyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNvbmZpZy5fc3RyaWN0ICYmICFwYXJzZWRJbnB1dCkge1xuICAgICAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLnVudXNlZFRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFkZCByZW1haW5pbmcgdW5wYXJzZWQgaW5wdXQgbGVuZ3RoIHRvIHRoZSBzdHJpbmdcbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuY2hhcnNMZWZ0T3ZlciA9XG4gICAgICAgICAgICBzdHJpbmdMZW5ndGggLSB0b3RhbFBhcnNlZElucHV0TGVuZ3RoO1xuICAgICAgICBpZiAoc3RyaW5nLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLnVudXNlZElucHV0LnB1c2goc3RyaW5nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNsZWFyIF8xMmggZmxhZyBpZiBob3VyIGlzIDw9IDEyXG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIGNvbmZpZy5fYVtIT1VSXSA8PSAxMiAmJlxuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuYmlnSG91ciA9PT0gdHJ1ZSAmJlxuICAgICAgICAgICAgY29uZmlnLl9hW0hPVVJdID4gMFxuICAgICAgICApIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmJpZ0hvdXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5wYXJzZWREYXRlUGFydHMgPSBjb25maWcuX2Euc2xpY2UoMCk7XG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLm1lcmlkaWVtID0gY29uZmlnLl9tZXJpZGllbTtcbiAgICAgICAgLy8gaGFuZGxlIG1lcmlkaWVtXG4gICAgICAgIGNvbmZpZy5fYVtIT1VSXSA9IG1lcmlkaWVtRml4V3JhcChcbiAgICAgICAgICAgIGNvbmZpZy5fbG9jYWxlLFxuICAgICAgICAgICAgY29uZmlnLl9hW0hPVVJdLFxuICAgICAgICAgICAgY29uZmlnLl9tZXJpZGllbVxuICAgICAgICApO1xuXG4gICAgICAgIC8vIGhhbmRsZSBlcmFcbiAgICAgICAgZXJhID0gZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuZXJhO1xuICAgICAgICBpZiAoZXJhICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25maWcuX2FbWUVBUl0gPSBjb25maWcuX2xvY2FsZS5lcmFzQ29udmVydFllYXIoZXJhLCBjb25maWcuX2FbWUVBUl0pO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uZmlnRnJvbUFycmF5KGNvbmZpZyk7XG4gICAgICAgIGNoZWNrT3ZlcmZsb3coY29uZmlnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtZXJpZGllbUZpeFdyYXAobG9jYWxlLCBob3VyLCBtZXJpZGllbSkge1xuICAgICAgICB2YXIgaXNQbTtcblxuICAgICAgICBpZiAobWVyaWRpZW0gPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gbm90aGluZyB0byBkb1xuICAgICAgICAgICAgcmV0dXJuIGhvdXI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxvY2FsZS5tZXJpZGllbUhvdXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsZS5tZXJpZGllbUhvdXIoaG91ciwgbWVyaWRpZW0pO1xuICAgICAgICB9IGVsc2UgaWYgKGxvY2FsZS5pc1BNICE9IG51bGwpIHtcbiAgICAgICAgICAgIC8vIEZhbGxiYWNrXG4gICAgICAgICAgICBpc1BtID0gbG9jYWxlLmlzUE0obWVyaWRpZW0pO1xuICAgICAgICAgICAgaWYgKGlzUG0gJiYgaG91ciA8IDEyKSB7XG4gICAgICAgICAgICAgICAgaG91ciArPSAxMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaXNQbSAmJiBob3VyID09PSAxMikge1xuICAgICAgICAgICAgICAgIGhvdXIgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGhvdXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyB0aGlzIGlzIG5vdCBzdXBwb3NlZCB0byBoYXBwZW5cbiAgICAgICAgICAgIHJldHVybiBob3VyO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gZGF0ZSBmcm9tIHN0cmluZyBhbmQgYXJyYXkgb2YgZm9ybWF0IHN0cmluZ3NcbiAgICBmdW5jdGlvbiBjb25maWdGcm9tU3RyaW5nQW5kQXJyYXkoY29uZmlnKSB7XG4gICAgICAgIHZhciB0ZW1wQ29uZmlnLFxuICAgICAgICAgICAgYmVzdE1vbWVudCxcbiAgICAgICAgICAgIHNjb3JlVG9CZWF0LFxuICAgICAgICAgICAgaSxcbiAgICAgICAgICAgIGN1cnJlbnRTY29yZSxcbiAgICAgICAgICAgIHZhbGlkRm9ybWF0Rm91bmQsXG4gICAgICAgICAgICBiZXN0Rm9ybWF0SXNWYWxpZCA9IGZhbHNlO1xuXG4gICAgICAgIGlmIChjb25maWcuX2YubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5pbnZhbGlkRm9ybWF0ID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKE5hTik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY29uZmlnLl9mLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjdXJyZW50U2NvcmUgPSAwO1xuICAgICAgICAgICAgdmFsaWRGb3JtYXRGb3VuZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGVtcENvbmZpZyA9IGNvcHlDb25maWcoe30sIGNvbmZpZyk7XG4gICAgICAgICAgICBpZiAoY29uZmlnLl91c2VVVEMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRlbXBDb25maWcuX3VzZVVUQyA9IGNvbmZpZy5fdXNlVVRDO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGVtcENvbmZpZy5fZiA9IGNvbmZpZy5fZltpXTtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21TdHJpbmdBbmRGb3JtYXQodGVtcENvbmZpZyk7XG5cbiAgICAgICAgICAgIGlmIChpc1ZhbGlkKHRlbXBDb25maWcpKSB7XG4gICAgICAgICAgICAgICAgdmFsaWRGb3JtYXRGb3VuZCA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGlmIHRoZXJlIGlzIGFueSBpbnB1dCB0aGF0IHdhcyBub3QgcGFyc2VkIGFkZCBhIHBlbmFsdHkgZm9yIHRoYXQgZm9ybWF0XG4gICAgICAgICAgICBjdXJyZW50U2NvcmUgKz0gZ2V0UGFyc2luZ0ZsYWdzKHRlbXBDb25maWcpLmNoYXJzTGVmdE92ZXI7XG5cbiAgICAgICAgICAgIC8vb3IgdG9rZW5zXG4gICAgICAgICAgICBjdXJyZW50U2NvcmUgKz0gZ2V0UGFyc2luZ0ZsYWdzKHRlbXBDb25maWcpLnVudXNlZFRva2Vucy5sZW5ndGggKiAxMDtcblxuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKHRlbXBDb25maWcpLnNjb3JlID0gY3VycmVudFNjb3JlO1xuXG4gICAgICAgICAgICBpZiAoIWJlc3RGb3JtYXRJc1ZhbGlkKSB7XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICBzY29yZVRvQmVhdCA9PSBudWxsIHx8XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTY29yZSA8IHNjb3JlVG9CZWF0IHx8XG4gICAgICAgICAgICAgICAgICAgIHZhbGlkRm9ybWF0Rm91bmRcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgc2NvcmVUb0JlYXQgPSBjdXJyZW50U2NvcmU7XG4gICAgICAgICAgICAgICAgICAgIGJlc3RNb21lbnQgPSB0ZW1wQ29uZmlnO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsaWRGb3JtYXRGb3VuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYmVzdEZvcm1hdElzVmFsaWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudFNjb3JlIDwgc2NvcmVUb0JlYXQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2NvcmVUb0JlYXQgPSBjdXJyZW50U2NvcmU7XG4gICAgICAgICAgICAgICAgICAgIGJlc3RNb21lbnQgPSB0ZW1wQ29uZmlnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGV4dGVuZChjb25maWcsIGJlc3RNb21lbnQgfHwgdGVtcENvbmZpZyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29uZmlnRnJvbU9iamVjdChjb25maWcpIHtcbiAgICAgICAgaWYgKGNvbmZpZy5fZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGkgPSBub3JtYWxpemVPYmplY3RVbml0cyhjb25maWcuX2kpLFxuICAgICAgICAgICAgZGF5T3JEYXRlID0gaS5kYXkgPT09IHVuZGVmaW5lZCA/IGkuZGF0ZSA6IGkuZGF5O1xuICAgICAgICBjb25maWcuX2EgPSBtYXAoXG4gICAgICAgICAgICBbaS55ZWFyLCBpLm1vbnRoLCBkYXlPckRhdGUsIGkuaG91ciwgaS5taW51dGUsIGkuc2Vjb25kLCBpLm1pbGxpc2Vjb25kXSxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqICYmIHBhcnNlSW50KG9iaiwgMTApO1xuICAgICAgICAgICAgfVxuICAgICAgICApO1xuXG4gICAgICAgIGNvbmZpZ0Zyb21BcnJheShjb25maWcpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUZyb21Db25maWcoY29uZmlnKSB7XG4gICAgICAgIHZhciByZXMgPSBuZXcgTW9tZW50KGNoZWNrT3ZlcmZsb3cocHJlcGFyZUNvbmZpZyhjb25maWcpKSk7XG4gICAgICAgIGlmIChyZXMuX25leHREYXkpIHtcbiAgICAgICAgICAgIC8vIEFkZGluZyBpcyBzbWFydCBlbm91Z2ggYXJvdW5kIERTVFxuICAgICAgICAgICAgcmVzLmFkZCgxLCAnZCcpO1xuICAgICAgICAgICAgcmVzLl9uZXh0RGF5ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcmVwYXJlQ29uZmlnKGNvbmZpZykge1xuICAgICAgICB2YXIgaW5wdXQgPSBjb25maWcuX2ksXG4gICAgICAgICAgICBmb3JtYXQgPSBjb25maWcuX2Y7XG5cbiAgICAgICAgY29uZmlnLl9sb2NhbGUgPSBjb25maWcuX2xvY2FsZSB8fCBnZXRMb2NhbGUoY29uZmlnLl9sKTtcblxuICAgICAgICBpZiAoaW5wdXQgPT09IG51bGwgfHwgKGZvcm1hdCA9PT0gdW5kZWZpbmVkICYmIGlucHV0ID09PSAnJykpIHtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVJbnZhbGlkKHsgbnVsbElucHV0OiB0cnVlIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGNvbmZpZy5faSA9IGlucHV0ID0gY29uZmlnLl9sb2NhbGUucHJlcGFyc2UoaW5wdXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzTW9tZW50KGlucHV0KSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBNb21lbnQoY2hlY2tPdmVyZmxvdyhpbnB1dCkpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzRGF0ZShpbnB1dCkpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IGlucHV0O1xuICAgICAgICB9IGVsc2UgaWYgKGlzQXJyYXkoZm9ybWF0KSkge1xuICAgICAgICAgICAgY29uZmlnRnJvbVN0cmluZ0FuZEFycmF5KGNvbmZpZyk7XG4gICAgICAgIH0gZWxzZSBpZiAoZm9ybWF0KSB7XG4gICAgICAgICAgICBjb25maWdGcm9tU3RyaW5nQW5kRm9ybWF0KGNvbmZpZyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25maWdGcm9tSW5wdXQoY29uZmlnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNWYWxpZChjb25maWcpKSB7XG4gICAgICAgICAgICBjb25maWcuX2QgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvbmZpZztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb25maWdGcm9tSW5wdXQoY29uZmlnKSB7XG4gICAgICAgIHZhciBpbnB1dCA9IGNvbmZpZy5faTtcbiAgICAgICAgaWYgKGlzVW5kZWZpbmVkKGlucHV0KSkge1xuICAgICAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUoaG9va3Mubm93KCkpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzRGF0ZShpbnB1dCkpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKGlucHV0LnZhbHVlT2YoKSk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgY29uZmlnRnJvbVN0cmluZyhjb25maWcpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzQXJyYXkoaW5wdXQpKSB7XG4gICAgICAgICAgICBjb25maWcuX2EgPSBtYXAoaW5wdXQuc2xpY2UoMCksIGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQob2JqLCAxMCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21BcnJheShjb25maWcpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KGlucHV0KSkge1xuICAgICAgICAgICAgY29uZmlnRnJvbU9iamVjdChjb25maWcpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzTnVtYmVyKGlucHV0KSkge1xuICAgICAgICAgICAgLy8gZnJvbSBtaWxsaXNlY29uZHNcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKGlucHV0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGhvb2tzLmNyZWF0ZUZyb21JbnB1dEZhbGxiYWNrKGNvbmZpZyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVMb2NhbE9yVVRDKGlucHV0LCBmb3JtYXQsIGxvY2FsZSwgc3RyaWN0LCBpc1VUQykge1xuICAgICAgICB2YXIgYyA9IHt9O1xuXG4gICAgICAgIGlmIChmb3JtYXQgPT09IHRydWUgfHwgZm9ybWF0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgc3RyaWN0ID0gZm9ybWF0O1xuICAgICAgICAgICAgZm9ybWF0ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxvY2FsZSA9PT0gdHJ1ZSB8fCBsb2NhbGUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBzdHJpY3QgPSBsb2NhbGU7XG4gICAgICAgICAgICBsb2NhbGUgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoXG4gICAgICAgICAgICAoaXNPYmplY3QoaW5wdXQpICYmIGlzT2JqZWN0RW1wdHkoaW5wdXQpKSB8fFxuICAgICAgICAgICAgKGlzQXJyYXkoaW5wdXQpICYmIGlucHV0Lmxlbmd0aCA9PT0gMClcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBpbnB1dCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICAvLyBvYmplY3QgY29uc3RydWN0aW9uIG11c3QgYmUgZG9uZSB0aGlzIHdheS5cbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21vbWVudC9tb21lbnQvaXNzdWVzLzE0MjNcbiAgICAgICAgYy5faXNBTW9tZW50T2JqZWN0ID0gdHJ1ZTtcbiAgICAgICAgYy5fdXNlVVRDID0gYy5faXNVVEMgPSBpc1VUQztcbiAgICAgICAgYy5fbCA9IGxvY2FsZTtcbiAgICAgICAgYy5faSA9IGlucHV0O1xuICAgICAgICBjLl9mID0gZm9ybWF0O1xuICAgICAgICBjLl9zdHJpY3QgPSBzdHJpY3Q7XG5cbiAgICAgICAgcmV0dXJuIGNyZWF0ZUZyb21Db25maWcoYyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlTG9jYWwoaW5wdXQsIGZvcm1hdCwgbG9jYWxlLCBzdHJpY3QpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUxvY2FsT3JVVEMoaW5wdXQsIGZvcm1hdCwgbG9jYWxlLCBzdHJpY3QsIGZhbHNlKTtcbiAgICB9XG5cbiAgICB2YXIgcHJvdG90eXBlTWluID0gZGVwcmVjYXRlKFxuICAgICAgICAgICAgJ21vbWVudCgpLm1pbiBpcyBkZXByZWNhdGVkLCB1c2UgbW9tZW50Lm1heCBpbnN0ZWFkLiBodHRwOi8vbW9tZW50anMuY29tL2d1aWRlcy8jL3dhcm5pbmdzL21pbi1tYXgvJyxcbiAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgb3RoZXIgPSBjcmVhdGVMb2NhbC5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzVmFsaWQoKSAmJiBvdGhlci5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG90aGVyIDwgdGhpcyA/IHRoaXMgOiBvdGhlcjtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlSW52YWxpZCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgKSxcbiAgICAgICAgcHJvdG90eXBlTWF4ID0gZGVwcmVjYXRlKFxuICAgICAgICAgICAgJ21vbWVudCgpLm1heCBpcyBkZXByZWNhdGVkLCB1c2UgbW9tZW50Lm1pbiBpbnN0ZWFkLiBodHRwOi8vbW9tZW50anMuY29tL2d1aWRlcy8jL3dhcm5pbmdzL21pbi1tYXgvJyxcbiAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgb3RoZXIgPSBjcmVhdGVMb2NhbC5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzVmFsaWQoKSAmJiBvdGhlci5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG90aGVyID4gdGhpcyA/IHRoaXMgOiBvdGhlcjtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlSW52YWxpZCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgKTtcblxuICAgIC8vIFBpY2sgYSBtb21lbnQgbSBmcm9tIG1vbWVudHMgc28gdGhhdCBtW2ZuXShvdGhlcikgaXMgdHJ1ZSBmb3IgYWxsXG4gICAgLy8gb3RoZXIuIFRoaXMgcmVsaWVzIG9uIHRoZSBmdW5jdGlvbiBmbiB0byBiZSB0cmFuc2l0aXZlLlxuICAgIC8vXG4gICAgLy8gbW9tZW50cyBzaG91bGQgZWl0aGVyIGJlIGFuIGFycmF5IG9mIG1vbWVudCBvYmplY3RzIG9yIGFuIGFycmF5LCB3aG9zZVxuICAgIC8vIGZpcnN0IGVsZW1lbnQgaXMgYW4gYXJyYXkgb2YgbW9tZW50IG9iamVjdHMuXG4gICAgZnVuY3Rpb24gcGlja0J5KGZuLCBtb21lbnRzKSB7XG4gICAgICAgIHZhciByZXMsIGk7XG4gICAgICAgIGlmIChtb21lbnRzLmxlbmd0aCA9PT0gMSAmJiBpc0FycmF5KG1vbWVudHNbMF0pKSB7XG4gICAgICAgICAgICBtb21lbnRzID0gbW9tZW50c1swXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW1vbWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlTG9jYWwoKTtcbiAgICAgICAgfVxuICAgICAgICByZXMgPSBtb21lbnRzWzBdO1xuICAgICAgICBmb3IgKGkgPSAxOyBpIDwgbW9tZW50cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgaWYgKCFtb21lbnRzW2ldLmlzVmFsaWQoKSB8fCBtb21lbnRzW2ldW2ZuXShyZXMpKSB7XG4gICAgICAgICAgICAgICAgcmVzID0gbW9tZW50c1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIC8vIFRPRE86IFVzZSBbXS5zb3J0IGluc3RlYWQ/XG4gICAgZnVuY3Rpb24gbWluKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcblxuICAgICAgICByZXR1cm4gcGlja0J5KCdpc0JlZm9yZScsIGFyZ3MpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1heCgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG5cbiAgICAgICAgcmV0dXJuIHBpY2tCeSgnaXNBZnRlcicsIGFyZ3MpO1xuICAgIH1cblxuICAgIHZhciBub3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBEYXRlLm5vdyA/IERhdGUubm93KCkgOiArbmV3IERhdGUoKTtcbiAgICB9O1xuXG4gICAgdmFyIG9yZGVyaW5nID0gW1xuICAgICAgICAneWVhcicsXG4gICAgICAgICdxdWFydGVyJyxcbiAgICAgICAgJ21vbnRoJyxcbiAgICAgICAgJ3dlZWsnLFxuICAgICAgICAnZGF5JyxcbiAgICAgICAgJ2hvdXInLFxuICAgICAgICAnbWludXRlJyxcbiAgICAgICAgJ3NlY29uZCcsXG4gICAgICAgICdtaWxsaXNlY29uZCcsXG4gICAgXTtcblxuICAgIGZ1bmN0aW9uIGlzRHVyYXRpb25WYWxpZChtKSB7XG4gICAgICAgIHZhciBrZXksXG4gICAgICAgICAgICB1bml0SGFzRGVjaW1hbCA9IGZhbHNlLFxuICAgICAgICAgICAgaTtcbiAgICAgICAgZm9yIChrZXkgaW4gbSkge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIGhhc093blByb3AobSwga2V5KSAmJlxuICAgICAgICAgICAgICAgICEoXG4gICAgICAgICAgICAgICAgICAgIGluZGV4T2YuY2FsbChvcmRlcmluZywga2V5KSAhPT0gLTEgJiZcbiAgICAgICAgICAgICAgICAgICAgKG1ba2V5XSA9PSBudWxsIHx8ICFpc05hTihtW2tleV0pKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBvcmRlcmluZy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgaWYgKG1bb3JkZXJpbmdbaV1dKSB7XG4gICAgICAgICAgICAgICAgaWYgKHVuaXRIYXNEZWNpbWFsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gb25seSBhbGxvdyBub24taW50ZWdlcnMgZm9yIHNtYWxsZXN0IHVuaXRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlRmxvYXQobVtvcmRlcmluZ1tpXV0pICE9PSB0b0ludChtW29yZGVyaW5nW2ldXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdW5pdEhhc0RlY2ltYWwgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzVmFsaWQkMSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzVmFsaWQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlSW52YWxpZCQxKCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlRHVyYXRpb24oTmFOKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBEdXJhdGlvbihkdXJhdGlvbikge1xuICAgICAgICB2YXIgbm9ybWFsaXplZElucHV0ID0gbm9ybWFsaXplT2JqZWN0VW5pdHMoZHVyYXRpb24pLFxuICAgICAgICAgICAgeWVhcnMgPSBub3JtYWxpemVkSW5wdXQueWVhciB8fCAwLFxuICAgICAgICAgICAgcXVhcnRlcnMgPSBub3JtYWxpemVkSW5wdXQucXVhcnRlciB8fCAwLFxuICAgICAgICAgICAgbW9udGhzID0gbm9ybWFsaXplZElucHV0Lm1vbnRoIHx8IDAsXG4gICAgICAgICAgICB3ZWVrcyA9IG5vcm1hbGl6ZWRJbnB1dC53ZWVrIHx8IG5vcm1hbGl6ZWRJbnB1dC5pc29XZWVrIHx8IDAsXG4gICAgICAgICAgICBkYXlzID0gbm9ybWFsaXplZElucHV0LmRheSB8fCAwLFxuICAgICAgICAgICAgaG91cnMgPSBub3JtYWxpemVkSW5wdXQuaG91ciB8fCAwLFxuICAgICAgICAgICAgbWludXRlcyA9IG5vcm1hbGl6ZWRJbnB1dC5taW51dGUgfHwgMCxcbiAgICAgICAgICAgIHNlY29uZHMgPSBub3JtYWxpemVkSW5wdXQuc2Vjb25kIHx8IDAsXG4gICAgICAgICAgICBtaWxsaXNlY29uZHMgPSBub3JtYWxpemVkSW5wdXQubWlsbGlzZWNvbmQgfHwgMDtcblxuICAgICAgICB0aGlzLl9pc1ZhbGlkID0gaXNEdXJhdGlvblZhbGlkKG5vcm1hbGl6ZWRJbnB1dCk7XG5cbiAgICAgICAgLy8gcmVwcmVzZW50YXRpb24gZm9yIGRhdGVBZGRSZW1vdmVcbiAgICAgICAgdGhpcy5fbWlsbGlzZWNvbmRzID1cbiAgICAgICAgICAgICttaWxsaXNlY29uZHMgK1xuICAgICAgICAgICAgc2Vjb25kcyAqIDFlMyArIC8vIDEwMDBcbiAgICAgICAgICAgIG1pbnV0ZXMgKiA2ZTQgKyAvLyAxMDAwICogNjBcbiAgICAgICAgICAgIGhvdXJzICogMTAwMCAqIDYwICogNjA7IC8vdXNpbmcgMTAwMCAqIDYwICogNjAgaW5zdGVhZCBvZiAzNmU1IHRvIGF2b2lkIGZsb2F0aW5nIHBvaW50IHJvdW5kaW5nIGVycm9ycyBodHRwczovL2dpdGh1Yi5jb20vbW9tZW50L21vbWVudC9pc3N1ZXMvMjk3OFxuICAgICAgICAvLyBCZWNhdXNlIG9mIGRhdGVBZGRSZW1vdmUgdHJlYXRzIDI0IGhvdXJzIGFzIGRpZmZlcmVudCBmcm9tIGFcbiAgICAgICAgLy8gZGF5IHdoZW4gd29ya2luZyBhcm91bmQgRFNULCB3ZSBuZWVkIHRvIHN0b3JlIHRoZW0gc2VwYXJhdGVseVxuICAgICAgICB0aGlzLl9kYXlzID0gK2RheXMgKyB3ZWVrcyAqIDc7XG4gICAgICAgIC8vIEl0IGlzIGltcG9zc2libGUgdG8gdHJhbnNsYXRlIG1vbnRocyBpbnRvIGRheXMgd2l0aG91dCBrbm93aW5nXG4gICAgICAgIC8vIHdoaWNoIG1vbnRocyB5b3UgYXJlIGFyZSB0YWxraW5nIGFib3V0LCBzbyB3ZSBoYXZlIHRvIHN0b3JlXG4gICAgICAgIC8vIGl0IHNlcGFyYXRlbHkuXG4gICAgICAgIHRoaXMuX21vbnRocyA9ICttb250aHMgKyBxdWFydGVycyAqIDMgKyB5ZWFycyAqIDEyO1xuXG4gICAgICAgIHRoaXMuX2RhdGEgPSB7fTtcblxuICAgICAgICB0aGlzLl9sb2NhbGUgPSBnZXRMb2NhbGUoKTtcblxuICAgICAgICB0aGlzLl9idWJibGUoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0R1cmF0aW9uKG9iaikge1xuICAgICAgICByZXR1cm4gb2JqIGluc3RhbmNlb2YgRHVyYXRpb247XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWJzUm91bmQobnVtYmVyKSB7XG4gICAgICAgIGlmIChudW1iZXIgPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5yb3VuZCgtMSAqIG51bWJlcikgKiAtMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLnJvdW5kKG51bWJlcik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBjb21wYXJlIHR3byBhcnJheXMsIHJldHVybiB0aGUgbnVtYmVyIG9mIGRpZmZlcmVuY2VzXG4gICAgZnVuY3Rpb24gY29tcGFyZUFycmF5cyhhcnJheTEsIGFycmF5MiwgZG9udENvbnZlcnQpIHtcbiAgICAgICAgdmFyIGxlbiA9IE1hdGgubWluKGFycmF5MS5sZW5ndGgsIGFycmF5Mi5sZW5ndGgpLFxuICAgICAgICAgICAgbGVuZ3RoRGlmZiA9IE1hdGguYWJzKGFycmF5MS5sZW5ndGggLSBhcnJheTIubGVuZ3RoKSxcbiAgICAgICAgICAgIGRpZmZzID0gMCxcbiAgICAgICAgICAgIGk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIChkb250Q29udmVydCAmJiBhcnJheTFbaV0gIT09IGFycmF5MltpXSkgfHxcbiAgICAgICAgICAgICAgICAoIWRvbnRDb252ZXJ0ICYmIHRvSW50KGFycmF5MVtpXSkgIT09IHRvSW50KGFycmF5MltpXSkpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBkaWZmcysrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkaWZmcyArIGxlbmd0aERpZmY7XG4gICAgfVxuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgZnVuY3Rpb24gb2Zmc2V0KHRva2VuLCBzZXBhcmF0b3IpIHtcbiAgICAgICAgYWRkRm9ybWF0VG9rZW4odG9rZW4sIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSB0aGlzLnV0Y09mZnNldCgpLFxuICAgICAgICAgICAgICAgIHNpZ24gPSAnKyc7XG4gICAgICAgICAgICBpZiAob2Zmc2V0IDwgMCkge1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IC1vZmZzZXQ7XG4gICAgICAgICAgICAgICAgc2lnbiA9ICctJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgc2lnbiArXG4gICAgICAgICAgICAgICAgemVyb0ZpbGwofn4ob2Zmc2V0IC8gNjApLCAyKSArXG4gICAgICAgICAgICAgICAgc2VwYXJhdG9yICtcbiAgICAgICAgICAgICAgICB6ZXJvRmlsbCh+fm9mZnNldCAlIDYwLCAyKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgb2Zmc2V0KCdaJywgJzonKTtcbiAgICBvZmZzZXQoJ1paJywgJycpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignWicsIG1hdGNoU2hvcnRPZmZzZXQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1paJywgbWF0Y2hTaG9ydE9mZnNldCk7XG4gICAgYWRkUGFyc2VUb2tlbihbJ1onLCAnWlonXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIGNvbmZpZy5fdXNlVVRDID0gdHJ1ZTtcbiAgICAgICAgY29uZmlnLl90em0gPSBvZmZzZXRGcm9tU3RyaW5nKG1hdGNoU2hvcnRPZmZzZXQsIGlucHV0KTtcbiAgICB9KTtcblxuICAgIC8vIEhFTFBFUlNcblxuICAgIC8vIHRpbWV6b25lIGNodW5rZXJcbiAgICAvLyAnKzEwOjAwJyA+IFsnMTAnLCAgJzAwJ11cbiAgICAvLyAnLTE1MzAnICA+IFsnLTE1JywgJzMwJ11cbiAgICB2YXIgY2h1bmtPZmZzZXQgPSAvKFtcXCtcXC1dfFxcZFxcZCkvZ2k7XG5cbiAgICBmdW5jdGlvbiBvZmZzZXRGcm9tU3RyaW5nKG1hdGNoZXIsIHN0cmluZykge1xuICAgICAgICB2YXIgbWF0Y2hlcyA9IChzdHJpbmcgfHwgJycpLm1hdGNoKG1hdGNoZXIpLFxuICAgICAgICAgICAgY2h1bmssXG4gICAgICAgICAgICBwYXJ0cyxcbiAgICAgICAgICAgIG1pbnV0ZXM7XG5cbiAgICAgICAgaWYgKG1hdGNoZXMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgY2h1bmsgPSBtYXRjaGVzW21hdGNoZXMubGVuZ3RoIC0gMV0gfHwgW107XG4gICAgICAgIHBhcnRzID0gKGNodW5rICsgJycpLm1hdGNoKGNodW5rT2Zmc2V0KSB8fCBbJy0nLCAwLCAwXTtcbiAgICAgICAgbWludXRlcyA9ICsocGFydHNbMV0gKiA2MCkgKyB0b0ludChwYXJ0c1syXSk7XG5cbiAgICAgICAgcmV0dXJuIG1pbnV0ZXMgPT09IDAgPyAwIDogcGFydHNbMF0gPT09ICcrJyA/IG1pbnV0ZXMgOiAtbWludXRlcztcbiAgICB9XG5cbiAgICAvLyBSZXR1cm4gYSBtb21lbnQgZnJvbSBpbnB1dCwgdGhhdCBpcyBsb2NhbC91dGMvem9uZSBlcXVpdmFsZW50IHRvIG1vZGVsLlxuICAgIGZ1bmN0aW9uIGNsb25lV2l0aE9mZnNldChpbnB1dCwgbW9kZWwpIHtcbiAgICAgICAgdmFyIHJlcywgZGlmZjtcbiAgICAgICAgaWYgKG1vZGVsLl9pc1VUQykge1xuICAgICAgICAgICAgcmVzID0gbW9kZWwuY2xvbmUoKTtcbiAgICAgICAgICAgIGRpZmYgPVxuICAgICAgICAgICAgICAgIChpc01vbWVudChpbnB1dCkgfHwgaXNEYXRlKGlucHV0KVxuICAgICAgICAgICAgICAgICAgICA/IGlucHV0LnZhbHVlT2YoKVxuICAgICAgICAgICAgICAgICAgICA6IGNyZWF0ZUxvY2FsKGlucHV0KS52YWx1ZU9mKCkpIC0gcmVzLnZhbHVlT2YoKTtcbiAgICAgICAgICAgIC8vIFVzZSBsb3ctbGV2ZWwgYXBpLCBiZWNhdXNlIHRoaXMgZm4gaXMgbG93LWxldmVsIGFwaS5cbiAgICAgICAgICAgIHJlcy5fZC5zZXRUaW1lKHJlcy5fZC52YWx1ZU9mKCkgKyBkaWZmKTtcbiAgICAgICAgICAgIGhvb2tzLnVwZGF0ZU9mZnNldChyZXMsIGZhbHNlKTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlTG9jYWwoaW5wdXQpLmxvY2FsKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXREYXRlT2Zmc2V0KG0pIHtcbiAgICAgICAgLy8gT24gRmlyZWZveC4yNCBEYXRlI2dldFRpbWV6b25lT2Zmc2V0IHJldHVybnMgYSBmbG9hdGluZyBwb2ludC5cbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21vbWVudC9tb21lbnQvcHVsbC8xODcxXG4gICAgICAgIHJldHVybiAtTWF0aC5yb3VuZChtLl9kLmdldFRpbWV6b25lT2Zmc2V0KCkpO1xuICAgIH1cblxuICAgIC8vIEhPT0tTXG5cbiAgICAvLyBUaGlzIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIHdoZW5ldmVyIGEgbW9tZW50IGlzIG11dGF0ZWQuXG4gICAgLy8gSXQgaXMgaW50ZW5kZWQgdG8ga2VlcCB0aGUgb2Zmc2V0IGluIHN5bmMgd2l0aCB0aGUgdGltZXpvbmUuXG4gICAgaG9va3MudXBkYXRlT2Zmc2V0ID0gZnVuY3Rpb24gKCkge307XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICAvLyBrZWVwTG9jYWxUaW1lID0gdHJ1ZSBtZWFucyBvbmx5IGNoYW5nZSB0aGUgdGltZXpvbmUsIHdpdGhvdXRcbiAgICAvLyBhZmZlY3RpbmcgdGhlIGxvY2FsIGhvdXIuIFNvIDU6MzE6MjYgKzAzMDAgLS1bdXRjT2Zmc2V0KDIsIHRydWUpXS0tPlxuICAgIC8vIDU6MzE6MjYgKzAyMDAgSXQgaXMgcG9zc2libGUgdGhhdCA1OjMxOjI2IGRvZXNuJ3QgZXhpc3Qgd2l0aCBvZmZzZXRcbiAgICAvLyArMDIwMCwgc28gd2UgYWRqdXN0IHRoZSB0aW1lIGFzIG5lZWRlZCwgdG8gYmUgdmFsaWQuXG4gICAgLy9cbiAgICAvLyBLZWVwaW5nIHRoZSB0aW1lIGFjdHVhbGx5IGFkZHMvc3VidHJhY3RzIChvbmUgaG91cilcbiAgICAvLyBmcm9tIHRoZSBhY3R1YWwgcmVwcmVzZW50ZWQgdGltZS4gVGhhdCBpcyB3aHkgd2UgY2FsbCB1cGRhdGVPZmZzZXRcbiAgICAvLyBhIHNlY29uZCB0aW1lLiBJbiBjYXNlIGl0IHdhbnRzIHVzIHRvIGNoYW5nZSB0aGUgb2Zmc2V0IGFnYWluXG4gICAgLy8gX2NoYW5nZUluUHJvZ3Jlc3MgPT0gdHJ1ZSBjYXNlLCB0aGVuIHdlIGhhdmUgdG8gYWRqdXN0LCBiZWNhdXNlXG4gICAgLy8gdGhlcmUgaXMgbm8gc3VjaCB0aW1lIGluIHRoZSBnaXZlbiB0aW1lem9uZS5cbiAgICBmdW5jdGlvbiBnZXRTZXRPZmZzZXQoaW5wdXQsIGtlZXBMb2NhbFRpbWUsIGtlZXBNaW51dGVzKSB7XG4gICAgICAgIHZhciBvZmZzZXQgPSB0aGlzLl9vZmZzZXQgfHwgMCxcbiAgICAgICAgICAgIGxvY2FsQWRqdXN0O1xuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQgIT0gbnVsbCA/IHRoaXMgOiBOYU47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlucHV0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgaW5wdXQgPSBvZmZzZXRGcm9tU3RyaW5nKG1hdGNoU2hvcnRPZmZzZXQsIGlucHV0KTtcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChNYXRoLmFicyhpbnB1dCkgPCAxNiAmJiAha2VlcE1pbnV0ZXMpIHtcbiAgICAgICAgICAgICAgICBpbnB1dCA9IGlucHV0ICogNjA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2lzVVRDICYmIGtlZXBMb2NhbFRpbWUpIHtcbiAgICAgICAgICAgICAgICBsb2NhbEFkanVzdCA9IGdldERhdGVPZmZzZXQodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9vZmZzZXQgPSBpbnB1dDtcbiAgICAgICAgICAgIHRoaXMuX2lzVVRDID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChsb2NhbEFkanVzdCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGQobG9jYWxBZGp1c3QsICdtJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob2Zmc2V0ICE9PSBpbnB1dCkge1xuICAgICAgICAgICAgICAgIGlmICgha2VlcExvY2FsVGltZSB8fCB0aGlzLl9jaGFuZ2VJblByb2dyZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZFN1YnRyYWN0KFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNyZWF0ZUR1cmF0aW9uKGlucHV0IC0gb2Zmc2V0LCAnbScpLFxuICAgICAgICAgICAgICAgICAgICAgICAgMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICghdGhpcy5fY2hhbmdlSW5Qcm9ncmVzcykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jaGFuZ2VJblByb2dyZXNzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgaG9va3MudXBkYXRlT2Zmc2V0KHRoaXMsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jaGFuZ2VJblByb2dyZXNzID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pc1VUQyA/IG9mZnNldCA6IGdldERhdGVPZmZzZXQodGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTZXRab25lKGlucHV0LCBrZWVwTG9jYWxUaW1lKSB7XG4gICAgICAgIGlmIChpbnB1dCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGlucHV0ICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGlucHV0ID0gLWlucHV0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnV0Y09mZnNldChpbnB1dCwga2VlcExvY2FsVGltZSk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIC10aGlzLnV0Y09mZnNldCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0T2Zmc2V0VG9VVEMoa2VlcExvY2FsVGltZSkge1xuICAgICAgICByZXR1cm4gdGhpcy51dGNPZmZzZXQoMCwga2VlcExvY2FsVGltZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0T2Zmc2V0VG9Mb2NhbChrZWVwTG9jYWxUaW1lKSB7XG4gICAgICAgIGlmICh0aGlzLl9pc1VUQykge1xuICAgICAgICAgICAgdGhpcy51dGNPZmZzZXQoMCwga2VlcExvY2FsVGltZSk7XG4gICAgICAgICAgICB0aGlzLl9pc1VUQyA9IGZhbHNlO1xuXG4gICAgICAgICAgICBpZiAoa2VlcExvY2FsVGltZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3VidHJhY3QoZ2V0RGF0ZU9mZnNldCh0aGlzKSwgJ20nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRPZmZzZXRUb1BhcnNlZE9mZnNldCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3R6bSAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnV0Y09mZnNldCh0aGlzLl90em0sIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdGhpcy5faSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHZhciB0Wm9uZSA9IG9mZnNldEZyb21TdHJpbmcobWF0Y2hPZmZzZXQsIHRoaXMuX2kpO1xuICAgICAgICAgICAgaWYgKHRab25lICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnV0Y09mZnNldCh0Wm9uZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMudXRjT2Zmc2V0KDAsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhc0FsaWduZWRIb3VyT2Zmc2V0KGlucHV0KSB7XG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpbnB1dCA9IGlucHV0ID8gY3JlYXRlTG9jYWwoaW5wdXQpLnV0Y09mZnNldCgpIDogMDtcblxuICAgICAgICByZXR1cm4gKHRoaXMudXRjT2Zmc2V0KCkgLSBpbnB1dCkgJSA2MCA9PT0gMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0RheWxpZ2h0U2F2aW5nVGltZSgpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHRoaXMudXRjT2Zmc2V0KCkgPiB0aGlzLmNsb25lKCkubW9udGgoMCkudXRjT2Zmc2V0KCkgfHxcbiAgICAgICAgICAgIHRoaXMudXRjT2Zmc2V0KCkgPiB0aGlzLmNsb25lKCkubW9udGgoNSkudXRjT2Zmc2V0KClcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0RheWxpZ2h0U2F2aW5nVGltZVNoaWZ0ZWQoKSB7XG4gICAgICAgIGlmICghaXNVbmRlZmluZWQodGhpcy5faXNEU1RTaGlmdGVkKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2lzRFNUU2hpZnRlZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjID0ge30sXG4gICAgICAgICAgICBvdGhlcjtcblxuICAgICAgICBjb3B5Q29uZmlnKGMsIHRoaXMpO1xuICAgICAgICBjID0gcHJlcGFyZUNvbmZpZyhjKTtcblxuICAgICAgICBpZiAoYy5fYSkge1xuICAgICAgICAgICAgb3RoZXIgPSBjLl9pc1VUQyA/IGNyZWF0ZVVUQyhjLl9hKSA6IGNyZWF0ZUxvY2FsKGMuX2EpO1xuICAgICAgICAgICAgdGhpcy5faXNEU1RTaGlmdGVkID1cbiAgICAgICAgICAgICAgICB0aGlzLmlzVmFsaWQoKSAmJiBjb21wYXJlQXJyYXlzKGMuX2EsIG90aGVyLnRvQXJyYXkoKSkgPiAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5faXNEU1RTaGlmdGVkID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5faXNEU1RTaGlmdGVkO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzTG9jYWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzVmFsaWQoKSA/ICF0aGlzLl9pc1VUQyA6IGZhbHNlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzVXRjT2Zmc2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc1ZhbGlkKCkgPyB0aGlzLl9pc1VUQyA6IGZhbHNlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzVXRjKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc1ZhbGlkKCkgPyB0aGlzLl9pc1VUQyAmJiB0aGlzLl9vZmZzZXQgPT09IDAgOiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBBU1AuTkVUIGpzb24gZGF0ZSBmb3JtYXQgcmVnZXhcbiAgICB2YXIgYXNwTmV0UmVnZXggPSAvXigtfFxcKyk/KD86KFxcZCopWy4gXSk/KFxcZCspOihcXGQrKSg/OjooXFxkKykoXFwuXFxkKik/KT8kLyxcbiAgICAgICAgLy8gZnJvbSBodHRwOi8vZG9jcy5jbG9zdXJlLWxpYnJhcnkuZ29vZ2xlY29kZS5jb20vZ2l0L2Nsb3N1cmVfZ29vZ19kYXRlX2RhdGUuanMuc291cmNlLmh0bWxcbiAgICAgICAgLy8gc29tZXdoYXQgbW9yZSBpbiBsaW5lIHdpdGggNC40LjMuMiAyMDA0IHNwZWMsIGJ1dCBhbGxvd3MgZGVjaW1hbCBhbnl3aGVyZVxuICAgICAgICAvLyBhbmQgZnVydGhlciBtb2RpZmllZCB0byBhbGxvdyBmb3Igc3RyaW5ncyBjb250YWluaW5nIGJvdGggd2VlayBhbmQgZGF5XG4gICAgICAgIGlzb1JlZ2V4ID0gL14oLXxcXCspP1AoPzooWy0rXT9bMC05LC5dKilZKT8oPzooWy0rXT9bMC05LC5dKilNKT8oPzooWy0rXT9bMC05LC5dKilXKT8oPzooWy0rXT9bMC05LC5dKilEKT8oPzpUKD86KFstK10/WzAtOSwuXSopSCk/KD86KFstK10/WzAtOSwuXSopTSk/KD86KFstK10/WzAtOSwuXSopUyk/KT8kLztcblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUR1cmF0aW9uKGlucHV0LCBrZXkpIHtcbiAgICAgICAgdmFyIGR1cmF0aW9uID0gaW5wdXQsXG4gICAgICAgICAgICAvLyBtYXRjaGluZyBhZ2FpbnN0IHJlZ2V4cCBpcyBleHBlbnNpdmUsIGRvIGl0IG9uIGRlbWFuZFxuICAgICAgICAgICAgbWF0Y2ggPSBudWxsLFxuICAgICAgICAgICAgc2lnbixcbiAgICAgICAgICAgIHJldCxcbiAgICAgICAgICAgIGRpZmZSZXM7XG5cbiAgICAgICAgaWYgKGlzRHVyYXRpb24oaW5wdXQpKSB7XG4gICAgICAgICAgICBkdXJhdGlvbiA9IHtcbiAgICAgICAgICAgICAgICBtczogaW5wdXQuX21pbGxpc2Vjb25kcyxcbiAgICAgICAgICAgICAgICBkOiBpbnB1dC5fZGF5cyxcbiAgICAgICAgICAgICAgICBNOiBpbnB1dC5fbW9udGhzLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmIChpc051bWJlcihpbnB1dCkgfHwgIWlzTmFOKCtpbnB1dCkpIHtcbiAgICAgICAgICAgIGR1cmF0aW9uID0ge307XG4gICAgICAgICAgICBpZiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgZHVyYXRpb25ba2V5XSA9ICtpbnB1dDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZHVyYXRpb24ubWlsbGlzZWNvbmRzID0gK2lucHV0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKChtYXRjaCA9IGFzcE5ldFJlZ2V4LmV4ZWMoaW5wdXQpKSkge1xuICAgICAgICAgICAgc2lnbiA9IG1hdGNoWzFdID09PSAnLScgPyAtMSA6IDE7XG4gICAgICAgICAgICBkdXJhdGlvbiA9IHtcbiAgICAgICAgICAgICAgICB5OiAwLFxuICAgICAgICAgICAgICAgIGQ6IHRvSW50KG1hdGNoW0RBVEVdKSAqIHNpZ24sXG4gICAgICAgICAgICAgICAgaDogdG9JbnQobWF0Y2hbSE9VUl0pICogc2lnbixcbiAgICAgICAgICAgICAgICBtOiB0b0ludChtYXRjaFtNSU5VVEVdKSAqIHNpZ24sXG4gICAgICAgICAgICAgICAgczogdG9JbnQobWF0Y2hbU0VDT05EXSkgKiBzaWduLFxuICAgICAgICAgICAgICAgIG1zOiB0b0ludChhYnNSb3VuZChtYXRjaFtNSUxMSVNFQ09ORF0gKiAxMDAwKSkgKiBzaWduLCAvLyB0aGUgbWlsbGlzZWNvbmQgZGVjaW1hbCBwb2ludCBpcyBpbmNsdWRlZCBpbiB0aGUgbWF0Y2hcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAoKG1hdGNoID0gaXNvUmVnZXguZXhlYyhpbnB1dCkpKSB7XG4gICAgICAgICAgICBzaWduID0gbWF0Y2hbMV0gPT09ICctJyA/IC0xIDogMTtcbiAgICAgICAgICAgIGR1cmF0aW9uID0ge1xuICAgICAgICAgICAgICAgIHk6IHBhcnNlSXNvKG1hdGNoWzJdLCBzaWduKSxcbiAgICAgICAgICAgICAgICBNOiBwYXJzZUlzbyhtYXRjaFszXSwgc2lnbiksXG4gICAgICAgICAgICAgICAgdzogcGFyc2VJc28obWF0Y2hbNF0sIHNpZ24pLFxuICAgICAgICAgICAgICAgIGQ6IHBhcnNlSXNvKG1hdGNoWzVdLCBzaWduKSxcbiAgICAgICAgICAgICAgICBoOiBwYXJzZUlzbyhtYXRjaFs2XSwgc2lnbiksXG4gICAgICAgICAgICAgICAgbTogcGFyc2VJc28obWF0Y2hbN10sIHNpZ24pLFxuICAgICAgICAgICAgICAgIHM6IHBhcnNlSXNvKG1hdGNoWzhdLCBzaWduKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAoZHVyYXRpb24gPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gY2hlY2tzIGZvciBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgZHVyYXRpb24gPSB7fTtcbiAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgIHR5cGVvZiBkdXJhdGlvbiA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgICgnZnJvbScgaW4gZHVyYXRpb24gfHwgJ3RvJyBpbiBkdXJhdGlvbilcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBkaWZmUmVzID0gbW9tZW50c0RpZmZlcmVuY2UoXG4gICAgICAgICAgICAgICAgY3JlYXRlTG9jYWwoZHVyYXRpb24uZnJvbSksXG4gICAgICAgICAgICAgICAgY3JlYXRlTG9jYWwoZHVyYXRpb24udG8pXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBkdXJhdGlvbiA9IHt9O1xuICAgICAgICAgICAgZHVyYXRpb24ubXMgPSBkaWZmUmVzLm1pbGxpc2Vjb25kcztcbiAgICAgICAgICAgIGR1cmF0aW9uLk0gPSBkaWZmUmVzLm1vbnRocztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldCA9IG5ldyBEdXJhdGlvbihkdXJhdGlvbik7XG5cbiAgICAgICAgaWYgKGlzRHVyYXRpb24oaW5wdXQpICYmIGhhc093blByb3AoaW5wdXQsICdfbG9jYWxlJykpIHtcbiAgICAgICAgICAgIHJldC5fbG9jYWxlID0gaW5wdXQuX2xvY2FsZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0R1cmF0aW9uKGlucHV0KSAmJiBoYXNPd25Qcm9wKGlucHV0LCAnX2lzVmFsaWQnKSkge1xuICAgICAgICAgICAgcmV0Ll9pc1ZhbGlkID0gaW5wdXQuX2lzVmFsaWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cblxuICAgIGNyZWF0ZUR1cmF0aW9uLmZuID0gRHVyYXRpb24ucHJvdG90eXBlO1xuICAgIGNyZWF0ZUR1cmF0aW9uLmludmFsaWQgPSBjcmVhdGVJbnZhbGlkJDE7XG5cbiAgICBmdW5jdGlvbiBwYXJzZUlzbyhpbnAsIHNpZ24pIHtcbiAgICAgICAgLy8gV2UnZCBub3JtYWxseSB1c2Ugfn5pbnAgZm9yIHRoaXMsIGJ1dCB1bmZvcnR1bmF0ZWx5IGl0IGFsc29cbiAgICAgICAgLy8gY29udmVydHMgZmxvYXRzIHRvIGludHMuXG4gICAgICAgIC8vIGlucCBtYXkgYmUgdW5kZWZpbmVkLCBzbyBjYXJlZnVsIGNhbGxpbmcgcmVwbGFjZSBvbiBpdC5cbiAgICAgICAgdmFyIHJlcyA9IGlucCAmJiBwYXJzZUZsb2F0KGlucC5yZXBsYWNlKCcsJywgJy4nKSk7XG4gICAgICAgIC8vIGFwcGx5IHNpZ24gd2hpbGUgd2UncmUgYXQgaXRcbiAgICAgICAgcmV0dXJuIChpc05hTihyZXMpID8gMCA6IHJlcykgKiBzaWduO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBvc2l0aXZlTW9tZW50c0RpZmZlcmVuY2UoYmFzZSwgb3RoZXIpIHtcbiAgICAgICAgdmFyIHJlcyA9IHt9O1xuXG4gICAgICAgIHJlcy5tb250aHMgPVxuICAgICAgICAgICAgb3RoZXIubW9udGgoKSAtIGJhc2UubW9udGgoKSArIChvdGhlci55ZWFyKCkgLSBiYXNlLnllYXIoKSkgKiAxMjtcbiAgICAgICAgaWYgKGJhc2UuY2xvbmUoKS5hZGQocmVzLm1vbnRocywgJ00nKS5pc0FmdGVyKG90aGVyKSkge1xuICAgICAgICAgICAgLS1yZXMubW9udGhzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzLm1pbGxpc2Vjb25kcyA9ICtvdGhlciAtICtiYXNlLmNsb25lKCkuYWRkKHJlcy5tb250aHMsICdNJyk7XG5cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtb21lbnRzRGlmZmVyZW5jZShiYXNlLCBvdGhlcikge1xuICAgICAgICB2YXIgcmVzO1xuICAgICAgICBpZiAoIShiYXNlLmlzVmFsaWQoKSAmJiBvdGhlci5pc1ZhbGlkKCkpKSB7XG4gICAgICAgICAgICByZXR1cm4geyBtaWxsaXNlY29uZHM6IDAsIG1vbnRoczogMCB9O1xuICAgICAgICB9XG5cbiAgICAgICAgb3RoZXIgPSBjbG9uZVdpdGhPZmZzZXQob3RoZXIsIGJhc2UpO1xuICAgICAgICBpZiAoYmFzZS5pc0JlZm9yZShvdGhlcikpIHtcbiAgICAgICAgICAgIHJlcyA9IHBvc2l0aXZlTW9tZW50c0RpZmZlcmVuY2UoYmFzZSwgb3RoZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzID0gcG9zaXRpdmVNb21lbnRzRGlmZmVyZW5jZShvdGhlciwgYmFzZSk7XG4gICAgICAgICAgICByZXMubWlsbGlzZWNvbmRzID0gLXJlcy5taWxsaXNlY29uZHM7XG4gICAgICAgICAgICByZXMubW9udGhzID0gLXJlcy5tb250aHM7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIC8vIFRPRE86IHJlbW92ZSAnbmFtZScgYXJnIGFmdGVyIGRlcHJlY2F0aW9uIGlzIHJlbW92ZWRcbiAgICBmdW5jdGlvbiBjcmVhdGVBZGRlcihkaXJlY3Rpb24sIG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2YWwsIHBlcmlvZCkge1xuICAgICAgICAgICAgdmFyIGR1ciwgdG1wO1xuICAgICAgICAgICAgLy9pbnZlcnQgdGhlIGFyZ3VtZW50cywgYnV0IGNvbXBsYWluIGFib3V0IGl0XG4gICAgICAgICAgICBpZiAocGVyaW9kICE9PSBudWxsICYmICFpc05hTigrcGVyaW9kKSkge1xuICAgICAgICAgICAgICAgIGRlcHJlY2F0ZVNpbXBsZShcbiAgICAgICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgJ21vbWVudCgpLicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSArXG4gICAgICAgICAgICAgICAgICAgICAgICAnKHBlcmlvZCwgbnVtYmVyKSBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIG1vbWVudCgpLicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSArXG4gICAgICAgICAgICAgICAgICAgICAgICAnKG51bWJlciwgcGVyaW9kKS4gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnU2VlIGh0dHA6Ly9tb21lbnRqcy5jb20vZ3VpZGVzLyMvd2FybmluZ3MvYWRkLWludmVydGVkLXBhcmFtLyBmb3IgbW9yZSBpbmZvLidcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHRtcCA9IHZhbDtcbiAgICAgICAgICAgICAgICB2YWwgPSBwZXJpb2Q7XG4gICAgICAgICAgICAgICAgcGVyaW9kID0gdG1wO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkdXIgPSBjcmVhdGVEdXJhdGlvbih2YWwsIHBlcmlvZCk7XG4gICAgICAgICAgICBhZGRTdWJ0cmFjdCh0aGlzLCBkdXIsIGRpcmVjdGlvbik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRTdWJ0cmFjdChtb20sIGR1cmF0aW9uLCBpc0FkZGluZywgdXBkYXRlT2Zmc2V0KSB7XG4gICAgICAgIHZhciBtaWxsaXNlY29uZHMgPSBkdXJhdGlvbi5fbWlsbGlzZWNvbmRzLFxuICAgICAgICAgICAgZGF5cyA9IGFic1JvdW5kKGR1cmF0aW9uLl9kYXlzKSxcbiAgICAgICAgICAgIG1vbnRocyA9IGFic1JvdW5kKGR1cmF0aW9uLl9tb250aHMpO1xuXG4gICAgICAgIGlmICghbW9tLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgLy8gTm8gb3BcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHVwZGF0ZU9mZnNldCA9IHVwZGF0ZU9mZnNldCA9PSBudWxsID8gdHJ1ZSA6IHVwZGF0ZU9mZnNldDtcblxuICAgICAgICBpZiAobW9udGhzKSB7XG4gICAgICAgICAgICBzZXRNb250aChtb20sIGdldChtb20sICdNb250aCcpICsgbW9udGhzICogaXNBZGRpbmcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXlzKSB7XG4gICAgICAgICAgICBzZXQkMShtb20sICdEYXRlJywgZ2V0KG1vbSwgJ0RhdGUnKSArIGRheXMgKiBpc0FkZGluZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1pbGxpc2Vjb25kcykge1xuICAgICAgICAgICAgbW9tLl9kLnNldFRpbWUobW9tLl9kLnZhbHVlT2YoKSArIG1pbGxpc2Vjb25kcyAqIGlzQWRkaW5nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodXBkYXRlT2Zmc2V0KSB7XG4gICAgICAgICAgICBob29rcy51cGRhdGVPZmZzZXQobW9tLCBkYXlzIHx8IG1vbnRocyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgYWRkID0gY3JlYXRlQWRkZXIoMSwgJ2FkZCcpLFxuICAgICAgICBzdWJ0cmFjdCA9IGNyZWF0ZUFkZGVyKC0xLCAnc3VidHJhY3QnKTtcblxuICAgIGZ1bmN0aW9uIGlzU3RyaW5nKGlucHV0KSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnIHx8IGlucHV0IGluc3RhbmNlb2YgU3RyaW5nO1xuICAgIH1cblxuICAgIC8vIHR5cGUgTW9tZW50SW5wdXQgPSBNb21lbnQgfCBEYXRlIHwgc3RyaW5nIHwgbnVtYmVyIHwgKG51bWJlciB8IHN0cmluZylbXSB8IE1vbWVudElucHV0T2JqZWN0IHwgdm9pZDsgLy8gbnVsbCB8IHVuZGVmaW5lZFxuICAgIGZ1bmN0aW9uIGlzTW9tZW50SW5wdXQoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIGlzTW9tZW50KGlucHV0KSB8fFxuICAgICAgICAgICAgaXNEYXRlKGlucHV0KSB8fFxuICAgICAgICAgICAgaXNTdHJpbmcoaW5wdXQpIHx8XG4gICAgICAgICAgICBpc051bWJlcihpbnB1dCkgfHxcbiAgICAgICAgICAgIGlzTnVtYmVyT3JTdHJpbmdBcnJheShpbnB1dCkgfHxcbiAgICAgICAgICAgIGlzTW9tZW50SW5wdXRPYmplY3QoaW5wdXQpIHx8XG4gICAgICAgICAgICBpbnB1dCA9PT0gbnVsbCB8fFxuICAgICAgICAgICAgaW5wdXQgPT09IHVuZGVmaW5lZFxuICAgICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzTW9tZW50SW5wdXRPYmplY3QoaW5wdXQpIHtcbiAgICAgICAgdmFyIG9iamVjdFRlc3QgPSBpc09iamVjdChpbnB1dCkgJiYgIWlzT2JqZWN0RW1wdHkoaW5wdXQpLFxuICAgICAgICAgICAgcHJvcGVydHlUZXN0ID0gZmFsc2UsXG4gICAgICAgICAgICBwcm9wZXJ0aWVzID0gW1xuICAgICAgICAgICAgICAgICd5ZWFycycsXG4gICAgICAgICAgICAgICAgJ3llYXInLFxuICAgICAgICAgICAgICAgICd5JyxcbiAgICAgICAgICAgICAgICAnbW9udGhzJyxcbiAgICAgICAgICAgICAgICAnbW9udGgnLFxuICAgICAgICAgICAgICAgICdNJyxcbiAgICAgICAgICAgICAgICAnZGF5cycsXG4gICAgICAgICAgICAgICAgJ2RheScsXG4gICAgICAgICAgICAgICAgJ2QnLFxuICAgICAgICAgICAgICAgICdkYXRlcycsXG4gICAgICAgICAgICAgICAgJ2RhdGUnLFxuICAgICAgICAgICAgICAgICdEJyxcbiAgICAgICAgICAgICAgICAnaG91cnMnLFxuICAgICAgICAgICAgICAgICdob3VyJyxcbiAgICAgICAgICAgICAgICAnaCcsXG4gICAgICAgICAgICAgICAgJ21pbnV0ZXMnLFxuICAgICAgICAgICAgICAgICdtaW51dGUnLFxuICAgICAgICAgICAgICAgICdtJyxcbiAgICAgICAgICAgICAgICAnc2Vjb25kcycsXG4gICAgICAgICAgICAgICAgJ3NlY29uZCcsXG4gICAgICAgICAgICAgICAgJ3MnLFxuICAgICAgICAgICAgICAgICdtaWxsaXNlY29uZHMnLFxuICAgICAgICAgICAgICAgICdtaWxsaXNlY29uZCcsXG4gICAgICAgICAgICAgICAgJ21zJyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBpLFxuICAgICAgICAgICAgcHJvcGVydHk7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHByb3BlcnRpZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIHByb3BlcnR5ID0gcHJvcGVydGllc1tpXTtcbiAgICAgICAgICAgIHByb3BlcnR5VGVzdCA9IHByb3BlcnR5VGVzdCB8fCBoYXNPd25Qcm9wKGlucHV0LCBwcm9wZXJ0eSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb2JqZWN0VGVzdCAmJiBwcm9wZXJ0eVRlc3Q7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNOdW1iZXJPclN0cmluZ0FycmF5KGlucHV0KSB7XG4gICAgICAgIHZhciBhcnJheVRlc3QgPSBpc0FycmF5KGlucHV0KSxcbiAgICAgICAgICAgIGRhdGFUeXBlVGVzdCA9IGZhbHNlO1xuICAgICAgICBpZiAoYXJyYXlUZXN0KSB7XG4gICAgICAgICAgICBkYXRhVHlwZVRlc3QgPVxuICAgICAgICAgICAgICAgIGlucHV0LmZpbHRlcihmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gIWlzTnVtYmVyKGl0ZW0pICYmIGlzU3RyaW5nKGlucHV0KTtcbiAgICAgICAgICAgICAgICB9KS5sZW5ndGggPT09IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFycmF5VGVzdCAmJiBkYXRhVHlwZVRlc3Q7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNDYWxlbmRhclNwZWMoaW5wdXQpIHtcbiAgICAgICAgdmFyIG9iamVjdFRlc3QgPSBpc09iamVjdChpbnB1dCkgJiYgIWlzT2JqZWN0RW1wdHkoaW5wdXQpLFxuICAgICAgICAgICAgcHJvcGVydHlUZXN0ID0gZmFsc2UsXG4gICAgICAgICAgICBwcm9wZXJ0aWVzID0gW1xuICAgICAgICAgICAgICAgICdzYW1lRGF5JyxcbiAgICAgICAgICAgICAgICAnbmV4dERheScsXG4gICAgICAgICAgICAgICAgJ2xhc3REYXknLFxuICAgICAgICAgICAgICAgICduZXh0V2VlaycsXG4gICAgICAgICAgICAgICAgJ2xhc3RXZWVrJyxcbiAgICAgICAgICAgICAgICAnc2FtZUVsc2UnLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICBwcm9wZXJ0eTtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcHJvcGVydGllcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgcHJvcGVydHkgPSBwcm9wZXJ0aWVzW2ldO1xuICAgICAgICAgICAgcHJvcGVydHlUZXN0ID0gcHJvcGVydHlUZXN0IHx8IGhhc093blByb3AoaW5wdXQsIHByb3BlcnR5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvYmplY3RUZXN0ICYmIHByb3BlcnR5VGVzdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRDYWxlbmRhckZvcm1hdChteU1vbWVudCwgbm93KSB7XG4gICAgICAgIHZhciBkaWZmID0gbXlNb21lbnQuZGlmZihub3csICdkYXlzJywgdHJ1ZSk7XG4gICAgICAgIHJldHVybiBkaWZmIDwgLTZcbiAgICAgICAgICAgID8gJ3NhbWVFbHNlJ1xuICAgICAgICAgICAgOiBkaWZmIDwgLTFcbiAgICAgICAgICAgID8gJ2xhc3RXZWVrJ1xuICAgICAgICAgICAgOiBkaWZmIDwgMFxuICAgICAgICAgICAgPyAnbGFzdERheSdcbiAgICAgICAgICAgIDogZGlmZiA8IDFcbiAgICAgICAgICAgID8gJ3NhbWVEYXknXG4gICAgICAgICAgICA6IGRpZmYgPCAyXG4gICAgICAgICAgICA/ICduZXh0RGF5J1xuICAgICAgICAgICAgOiBkaWZmIDwgN1xuICAgICAgICAgICAgPyAnbmV4dFdlZWsnXG4gICAgICAgICAgICA6ICdzYW1lRWxzZSc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2FsZW5kYXIkMSh0aW1lLCBmb3JtYXRzKSB7XG4gICAgICAgIC8vIFN1cHBvcnQgZm9yIHNpbmdsZSBwYXJhbWV0ZXIsIGZvcm1hdHMgb25seSBvdmVybG9hZCB0byB0aGUgY2FsZW5kYXIgZnVuY3Rpb25cbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIGlmICghYXJndW1lbnRzWzBdKSB7XG4gICAgICAgICAgICAgICAgdGltZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBmb3JtYXRzID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpc01vbWVudElucHV0KGFyZ3VtZW50c1swXSkpIHtcbiAgICAgICAgICAgICAgICB0aW1lID0gYXJndW1lbnRzWzBdO1xuICAgICAgICAgICAgICAgIGZvcm1hdHMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzQ2FsZW5kYXJTcGVjKGFyZ3VtZW50c1swXSkpIHtcbiAgICAgICAgICAgICAgICBmb3JtYXRzID0gYXJndW1lbnRzWzBdO1xuICAgICAgICAgICAgICAgIHRpbWUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2Ugd2FudCB0byBjb21wYXJlIHRoZSBzdGFydCBvZiB0b2RheSwgdnMgdGhpcy5cbiAgICAgICAgLy8gR2V0dGluZyBzdGFydC1vZi10b2RheSBkZXBlbmRzIG9uIHdoZXRoZXIgd2UncmUgbG9jYWwvdXRjL29mZnNldCBvciBub3QuXG4gICAgICAgIHZhciBub3cgPSB0aW1lIHx8IGNyZWF0ZUxvY2FsKCksXG4gICAgICAgICAgICBzb2QgPSBjbG9uZVdpdGhPZmZzZXQobm93LCB0aGlzKS5zdGFydE9mKCdkYXknKSxcbiAgICAgICAgICAgIGZvcm1hdCA9IGhvb2tzLmNhbGVuZGFyRm9ybWF0KHRoaXMsIHNvZCkgfHwgJ3NhbWVFbHNlJyxcbiAgICAgICAgICAgIG91dHB1dCA9XG4gICAgICAgICAgICAgICAgZm9ybWF0cyAmJlxuICAgICAgICAgICAgICAgIChpc0Z1bmN0aW9uKGZvcm1hdHNbZm9ybWF0XSlcbiAgICAgICAgICAgICAgICAgICAgPyBmb3JtYXRzW2Zvcm1hdF0uY2FsbCh0aGlzLCBub3cpXG4gICAgICAgICAgICAgICAgICAgIDogZm9ybWF0c1tmb3JtYXRdKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5mb3JtYXQoXG4gICAgICAgICAgICBvdXRwdXQgfHwgdGhpcy5sb2NhbGVEYXRhKCkuY2FsZW5kYXIoZm9ybWF0LCB0aGlzLCBjcmVhdGVMb2NhbChub3cpKVxuICAgICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsb25lKCkge1xuICAgICAgICByZXR1cm4gbmV3IE1vbWVudCh0aGlzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0FmdGVyKGlucHV0LCB1bml0cykge1xuICAgICAgICB2YXIgbG9jYWxJbnB1dCA9IGlzTW9tZW50KGlucHV0KSA/IGlucHV0IDogY3JlYXRlTG9jYWwoaW5wdXQpO1xuICAgICAgICBpZiAoISh0aGlzLmlzVmFsaWQoKSAmJiBsb2NhbElucHV0LmlzVmFsaWQoKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKSB8fCAnbWlsbGlzZWNvbmQnO1xuICAgICAgICBpZiAodW5pdHMgPT09ICdtaWxsaXNlY29uZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlT2YoKSA+IGxvY2FsSW5wdXQudmFsdWVPZigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsSW5wdXQudmFsdWVPZigpIDwgdGhpcy5jbG9uZSgpLnN0YXJ0T2YodW5pdHMpLnZhbHVlT2YoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzQmVmb3JlKGlucHV0LCB1bml0cykge1xuICAgICAgICB2YXIgbG9jYWxJbnB1dCA9IGlzTW9tZW50KGlucHV0KSA/IGlucHV0IDogY3JlYXRlTG9jYWwoaW5wdXQpO1xuICAgICAgICBpZiAoISh0aGlzLmlzVmFsaWQoKSAmJiBsb2NhbElucHV0LmlzVmFsaWQoKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKSB8fCAnbWlsbGlzZWNvbmQnO1xuICAgICAgICBpZiAodW5pdHMgPT09ICdtaWxsaXNlY29uZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlT2YoKSA8IGxvY2FsSW5wdXQudmFsdWVPZigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5lbmRPZih1bml0cykudmFsdWVPZigpIDwgbG9jYWxJbnB1dC52YWx1ZU9mKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0JldHdlZW4oZnJvbSwgdG8sIHVuaXRzLCBpbmNsdXNpdml0eSkge1xuICAgICAgICB2YXIgbG9jYWxGcm9tID0gaXNNb21lbnQoZnJvbSkgPyBmcm9tIDogY3JlYXRlTG9jYWwoZnJvbSksXG4gICAgICAgICAgICBsb2NhbFRvID0gaXNNb21lbnQodG8pID8gdG8gOiBjcmVhdGVMb2NhbCh0byk7XG4gICAgICAgIGlmICghKHRoaXMuaXNWYWxpZCgpICYmIGxvY2FsRnJvbS5pc1ZhbGlkKCkgJiYgbG9jYWxUby5pc1ZhbGlkKCkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaW5jbHVzaXZpdHkgPSBpbmNsdXNpdml0eSB8fCAnKCknO1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgKGluY2x1c2l2aXR5WzBdID09PSAnKCdcbiAgICAgICAgICAgICAgICA/IHRoaXMuaXNBZnRlcihsb2NhbEZyb20sIHVuaXRzKVxuICAgICAgICAgICAgICAgIDogIXRoaXMuaXNCZWZvcmUobG9jYWxGcm9tLCB1bml0cykpICYmXG4gICAgICAgICAgICAoaW5jbHVzaXZpdHlbMV0gPT09ICcpJ1xuICAgICAgICAgICAgICAgID8gdGhpcy5pc0JlZm9yZShsb2NhbFRvLCB1bml0cylcbiAgICAgICAgICAgICAgICA6ICF0aGlzLmlzQWZ0ZXIobG9jYWxUbywgdW5pdHMpKVxuICAgICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzU2FtZShpbnB1dCwgdW5pdHMpIHtcbiAgICAgICAgdmFyIGxvY2FsSW5wdXQgPSBpc01vbWVudChpbnB1dCkgPyBpbnB1dCA6IGNyZWF0ZUxvY2FsKGlucHV0KSxcbiAgICAgICAgICAgIGlucHV0TXM7XG4gICAgICAgIGlmICghKHRoaXMuaXNWYWxpZCgpICYmIGxvY2FsSW5wdXQuaXNWYWxpZCgpKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpIHx8ICdtaWxsaXNlY29uZCc7XG4gICAgICAgIGlmICh1bml0cyA9PT0gJ21pbGxpc2Vjb25kJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVPZigpID09PSBsb2NhbElucHV0LnZhbHVlT2YoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlucHV0TXMgPSBsb2NhbElucHV0LnZhbHVlT2YoKTtcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgdGhpcy5jbG9uZSgpLnN0YXJ0T2YodW5pdHMpLnZhbHVlT2YoKSA8PSBpbnB1dE1zICYmXG4gICAgICAgICAgICAgICAgaW5wdXRNcyA8PSB0aGlzLmNsb25lKCkuZW5kT2YodW5pdHMpLnZhbHVlT2YoKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzU2FtZU9yQWZ0ZXIoaW5wdXQsIHVuaXRzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzU2FtZShpbnB1dCwgdW5pdHMpIHx8IHRoaXMuaXNBZnRlcihpbnB1dCwgdW5pdHMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzU2FtZU9yQmVmb3JlKGlucHV0LCB1bml0cykge1xuICAgICAgICByZXR1cm4gdGhpcy5pc1NhbWUoaW5wdXQsIHVuaXRzKSB8fCB0aGlzLmlzQmVmb3JlKGlucHV0LCB1bml0cyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGlmZihpbnB1dCwgdW5pdHMsIGFzRmxvYXQpIHtcbiAgICAgICAgdmFyIHRoYXQsIHpvbmVEZWx0YSwgb3V0cHV0O1xuXG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBOYU47XG4gICAgICAgIH1cblxuICAgICAgICB0aGF0ID0gY2xvbmVXaXRoT2Zmc2V0KGlucHV0LCB0aGlzKTtcblxuICAgICAgICBpZiAoIXRoYXQuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgICB9XG5cbiAgICAgICAgem9uZURlbHRhID0gKHRoYXQudXRjT2Zmc2V0KCkgLSB0aGlzLnV0Y09mZnNldCgpKSAqIDZlNDtcblxuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcblxuICAgICAgICBzd2l0Y2ggKHVuaXRzKSB7XG4gICAgICAgICAgICBjYXNlICd5ZWFyJzpcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSBtb250aERpZmYodGhpcywgdGhhdCkgLyAxMjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ21vbnRoJzpcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSBtb250aERpZmYodGhpcywgdGhhdCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdxdWFydGVyJzpcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSBtb250aERpZmYodGhpcywgdGhhdCkgLyAzO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnc2Vjb25kJzpcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSAodGhpcyAtIHRoYXQpIC8gMWUzO1xuICAgICAgICAgICAgICAgIGJyZWFrOyAvLyAxMDAwXG4gICAgICAgICAgICBjYXNlICdtaW51dGUnOlxuICAgICAgICAgICAgICAgIG91dHB1dCA9ICh0aGlzIC0gdGhhdCkgLyA2ZTQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7IC8vIDEwMDAgKiA2MFxuICAgICAgICAgICAgY2FzZSAnaG91cic6XG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gKHRoaXMgLSB0aGF0KSAvIDM2ZTU7XG4gICAgICAgICAgICAgICAgYnJlYWs7IC8vIDEwMDAgKiA2MCAqIDYwXG4gICAgICAgICAgICBjYXNlICdkYXknOlxuICAgICAgICAgICAgICAgIG91dHB1dCA9ICh0aGlzIC0gdGhhdCAtIHpvbmVEZWx0YSkgLyA4NjRlNTtcbiAgICAgICAgICAgICAgICBicmVhazsgLy8gMTAwMCAqIDYwICogNjAgKiAyNCwgbmVnYXRlIGRzdFxuICAgICAgICAgICAgY2FzZSAnd2Vlayc6XG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gKHRoaXMgLSB0aGF0IC0gem9uZURlbHRhKSAvIDYwNDhlNTtcbiAgICAgICAgICAgICAgICBicmVhazsgLy8gMTAwMCAqIDYwICogNjAgKiAyNCAqIDcsIG5lZ2F0ZSBkc3RcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gdGhpcyAtIHRoYXQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXNGbG9hdCA/IG91dHB1dCA6IGFic0Zsb29yKG91dHB1dCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbW9udGhEaWZmKGEsIGIpIHtcbiAgICAgICAgaWYgKGEuZGF0ZSgpIDwgYi5kYXRlKCkpIHtcbiAgICAgICAgICAgIC8vIGVuZC1vZi1tb250aCBjYWxjdWxhdGlvbnMgd29yayBjb3JyZWN0IHdoZW4gdGhlIHN0YXJ0IG1vbnRoIGhhcyBtb3JlXG4gICAgICAgICAgICAvLyBkYXlzIHRoYW4gdGhlIGVuZCBtb250aC5cbiAgICAgICAgICAgIHJldHVybiAtbW9udGhEaWZmKGIsIGEpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGRpZmZlcmVuY2UgaW4gbW9udGhzXG4gICAgICAgIHZhciB3aG9sZU1vbnRoRGlmZiA9IChiLnllYXIoKSAtIGEueWVhcigpKSAqIDEyICsgKGIubW9udGgoKSAtIGEubW9udGgoKSksXG4gICAgICAgICAgICAvLyBiIGlzIGluIChhbmNob3IgLSAxIG1vbnRoLCBhbmNob3IgKyAxIG1vbnRoKVxuICAgICAgICAgICAgYW5jaG9yID0gYS5jbG9uZSgpLmFkZCh3aG9sZU1vbnRoRGlmZiwgJ21vbnRocycpLFxuICAgICAgICAgICAgYW5jaG9yMixcbiAgICAgICAgICAgIGFkanVzdDtcblxuICAgICAgICBpZiAoYiAtIGFuY2hvciA8IDApIHtcbiAgICAgICAgICAgIGFuY2hvcjIgPSBhLmNsb25lKCkuYWRkKHdob2xlTW9udGhEaWZmIC0gMSwgJ21vbnRocycpO1xuICAgICAgICAgICAgLy8gbGluZWFyIGFjcm9zcyB0aGUgbW9udGhcbiAgICAgICAgICAgIGFkanVzdCA9IChiIC0gYW5jaG9yKSAvIChhbmNob3IgLSBhbmNob3IyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFuY2hvcjIgPSBhLmNsb25lKCkuYWRkKHdob2xlTW9udGhEaWZmICsgMSwgJ21vbnRocycpO1xuICAgICAgICAgICAgLy8gbGluZWFyIGFjcm9zcyB0aGUgbW9udGhcbiAgICAgICAgICAgIGFkanVzdCA9IChiIC0gYW5jaG9yKSAvIChhbmNob3IyIC0gYW5jaG9yKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vY2hlY2sgZm9yIG5lZ2F0aXZlIHplcm8sIHJldHVybiB6ZXJvIGlmIG5lZ2F0aXZlIHplcm9cbiAgICAgICAgcmV0dXJuIC0od2hvbGVNb250aERpZmYgKyBhZGp1c3QpIHx8IDA7XG4gICAgfVxuXG4gICAgaG9va3MuZGVmYXVsdEZvcm1hdCA9ICdZWVlZLU1NLUREVEhIOm1tOnNzWic7XG4gICAgaG9va3MuZGVmYXVsdEZvcm1hdFV0YyA9ICdZWVlZLU1NLUREVEhIOm1tOnNzW1pdJztcblxuICAgIGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmxvY2FsZSgnZW4nKS5mb3JtYXQoJ2RkZCBNTU0gREQgWVlZWSBISDptbTpzcyBbR01UXVpaJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9JU09TdHJpbmcoa2VlcE9mZnNldCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdXRjID0ga2VlcE9mZnNldCAhPT0gdHJ1ZSxcbiAgICAgICAgICAgIG0gPSB1dGMgPyB0aGlzLmNsb25lKCkudXRjKCkgOiB0aGlzO1xuICAgICAgICBpZiAobS55ZWFyKCkgPCAwIHx8IG0ueWVhcigpID4gOTk5OSkge1xuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdE1vbWVudChcbiAgICAgICAgICAgICAgICBtLFxuICAgICAgICAgICAgICAgIHV0Y1xuICAgICAgICAgICAgICAgICAgICA/ICdZWVlZWVktTU0tRERbVF1ISDptbTpzcy5TU1NbWl0nXG4gICAgICAgICAgICAgICAgICAgIDogJ1lZWVlZWS1NTS1ERFtUXUhIOm1tOnNzLlNTU1onXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKERhdGUucHJvdG90eXBlLnRvSVNPU3RyaW5nKSkge1xuICAgICAgICAgICAgLy8gbmF0aXZlIGltcGxlbWVudGF0aW9uIGlzIH41MHggZmFzdGVyLCB1c2UgaXQgd2hlbiB3ZSBjYW5cbiAgICAgICAgICAgIGlmICh1dGMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50b0RhdGUoKS50b0lTT1N0cmluZygpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IERhdGUodGhpcy52YWx1ZU9mKCkgKyB0aGlzLnV0Y09mZnNldCgpICogNjAgKiAxMDAwKVxuICAgICAgICAgICAgICAgICAgICAudG9JU09TdHJpbmcoKVxuICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgnWicsIGZvcm1hdE1vbWVudChtLCAnWicpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm9ybWF0TW9tZW50KFxuICAgICAgICAgICAgbSxcbiAgICAgICAgICAgIHV0YyA/ICdZWVlZLU1NLUREW1RdSEg6bW06c3MuU1NTW1pdJyA6ICdZWVlZLU1NLUREW1RdSEg6bW06c3MuU1NTWidcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSBodW1hbiByZWFkYWJsZSByZXByZXNlbnRhdGlvbiBvZiBhIG1vbWVudCB0aGF0IGNhblxuICAgICAqIGFsc28gYmUgZXZhbHVhdGVkIHRvIGdldCBhIG5ldyBtb21lbnQgd2hpY2ggaXMgdGhlIHNhbWVcbiAgICAgKlxuICAgICAqIEBsaW5rIGh0dHBzOi8vbm9kZWpzLm9yZy9kaXN0L2xhdGVzdC9kb2NzL2FwaS91dGlsLmh0bWwjdXRpbF9jdXN0b21faW5zcGVjdF9mdW5jdGlvbl9vbl9vYmplY3RzXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5zcGVjdCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuICdtb21lbnQuaW52YWxpZCgvKiAnICsgdGhpcy5faSArICcgKi8pJztcbiAgICAgICAgfVxuICAgICAgICB2YXIgZnVuYyA9ICdtb21lbnQnLFxuICAgICAgICAgICAgem9uZSA9ICcnLFxuICAgICAgICAgICAgcHJlZml4LFxuICAgICAgICAgICAgeWVhcixcbiAgICAgICAgICAgIGRhdGV0aW1lLFxuICAgICAgICAgICAgc3VmZml4O1xuICAgICAgICBpZiAoIXRoaXMuaXNMb2NhbCgpKSB7XG4gICAgICAgICAgICBmdW5jID0gdGhpcy51dGNPZmZzZXQoKSA9PT0gMCA/ICdtb21lbnQudXRjJyA6ICdtb21lbnQucGFyc2Vab25lJztcbiAgICAgICAgICAgIHpvbmUgPSAnWic7XG4gICAgICAgIH1cbiAgICAgICAgcHJlZml4ID0gJ1snICsgZnVuYyArICcoXCJdJztcbiAgICAgICAgeWVhciA9IDAgPD0gdGhpcy55ZWFyKCkgJiYgdGhpcy55ZWFyKCkgPD0gOTk5OSA/ICdZWVlZJyA6ICdZWVlZWVknO1xuICAgICAgICBkYXRldGltZSA9ICctTU0tRERbVF1ISDptbTpzcy5TU1MnO1xuICAgICAgICBzdWZmaXggPSB6b25lICsgJ1tcIildJztcblxuICAgICAgICByZXR1cm4gdGhpcy5mb3JtYXQocHJlZml4ICsgeWVhciArIGRhdGV0aW1lICsgc3VmZml4KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmb3JtYXQoaW5wdXRTdHJpbmcpIHtcbiAgICAgICAgaWYgKCFpbnB1dFN0cmluZykge1xuICAgICAgICAgICAgaW5wdXRTdHJpbmcgPSB0aGlzLmlzVXRjKClcbiAgICAgICAgICAgICAgICA/IGhvb2tzLmRlZmF1bHRGb3JtYXRVdGNcbiAgICAgICAgICAgICAgICA6IGhvb2tzLmRlZmF1bHRGb3JtYXQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG91dHB1dCA9IGZvcm1hdE1vbWVudCh0aGlzLCBpbnB1dFN0cmluZyk7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5wb3N0Zm9ybWF0KG91dHB1dCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZnJvbSh0aW1lLCB3aXRob3V0U3VmZml4KSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIHRoaXMuaXNWYWxpZCgpICYmXG4gICAgICAgICAgICAoKGlzTW9tZW50KHRpbWUpICYmIHRpbWUuaXNWYWxpZCgpKSB8fCBjcmVhdGVMb2NhbCh0aW1lKS5pc1ZhbGlkKCkpXG4gICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUR1cmF0aW9uKHsgdG86IHRoaXMsIGZyb206IHRpbWUgfSlcbiAgICAgICAgICAgICAgICAubG9jYWxlKHRoaXMubG9jYWxlKCkpXG4gICAgICAgICAgICAgICAgLmh1bWFuaXplKCF3aXRob3V0U3VmZml4KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5pbnZhbGlkRGF0ZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZnJvbU5vdyh3aXRob3V0U3VmZml4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZyb20oY3JlYXRlTG9jYWwoKSwgd2l0aG91dFN1ZmZpeCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG8odGltZSwgd2l0aG91dFN1ZmZpeCkge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgICB0aGlzLmlzVmFsaWQoKSAmJlxuICAgICAgICAgICAgKChpc01vbWVudCh0aW1lKSAmJiB0aW1lLmlzVmFsaWQoKSkgfHwgY3JlYXRlTG9jYWwodGltZSkuaXNWYWxpZCgpKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVEdXJhdGlvbih7IGZyb206IHRoaXMsIHRvOiB0aW1lIH0pXG4gICAgICAgICAgICAgICAgLmxvY2FsZSh0aGlzLmxvY2FsZSgpKVxuICAgICAgICAgICAgICAgIC5odW1hbml6ZSghd2l0aG91dFN1ZmZpeCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkuaW52YWxpZERhdGUoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvTm93KHdpdGhvdXRTdWZmaXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG8oY3JlYXRlTG9jYWwoKSwgd2l0aG91dFN1ZmZpeCk7XG4gICAgfVxuXG4gICAgLy8gSWYgcGFzc2VkIGEgbG9jYWxlIGtleSwgaXQgd2lsbCBzZXQgdGhlIGxvY2FsZSBmb3IgdGhpc1xuICAgIC8vIGluc3RhbmNlLiAgT3RoZXJ3aXNlLCBpdCB3aWxsIHJldHVybiB0aGUgbG9jYWxlIGNvbmZpZ3VyYXRpb25cbiAgICAvLyB2YXJpYWJsZXMgZm9yIHRoaXMgaW5zdGFuY2UuXG4gICAgZnVuY3Rpb24gbG9jYWxlKGtleSkge1xuICAgICAgICB2YXIgbmV3TG9jYWxlRGF0YTtcblxuICAgICAgICBpZiAoa2V5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9sb2NhbGUuX2FiYnI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXdMb2NhbGVEYXRhID0gZ2V0TG9jYWxlKGtleSk7XG4gICAgICAgICAgICBpZiAobmV3TG9jYWxlRGF0YSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbG9jYWxlID0gbmV3TG9jYWxlRGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGxhbmcgPSBkZXByZWNhdGUoXG4gICAgICAgICdtb21lbnQoKS5sYW5nKCkgaXMgZGVwcmVjYXRlZC4gSW5zdGVhZCwgdXNlIG1vbWVudCgpLmxvY2FsZURhdGEoKSB0byBnZXQgdGhlIGxhbmd1YWdlIGNvbmZpZ3VyYXRpb24uIFVzZSBtb21lbnQoKS5sb2NhbGUoKSB0byBjaGFuZ2UgbGFuZ3VhZ2VzLicsXG4gICAgICAgIGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIGlmIChrZXkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICApO1xuXG4gICAgZnVuY3Rpb24gbG9jYWxlRGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvY2FsZTtcbiAgICB9XG5cbiAgICB2YXIgTVNfUEVSX1NFQ09ORCA9IDEwMDAsXG4gICAgICAgIE1TX1BFUl9NSU5VVEUgPSA2MCAqIE1TX1BFUl9TRUNPTkQsXG4gICAgICAgIE1TX1BFUl9IT1VSID0gNjAgKiBNU19QRVJfTUlOVVRFLFxuICAgICAgICBNU19QRVJfNDAwX1lFQVJTID0gKDM2NSAqIDQwMCArIDk3KSAqIDI0ICogTVNfUEVSX0hPVVI7XG5cbiAgICAvLyBhY3R1YWwgbW9kdWxvIC0gaGFuZGxlcyBuZWdhdGl2ZSBudW1iZXJzIChmb3IgZGF0ZXMgYmVmb3JlIDE5NzApOlxuICAgIGZ1bmN0aW9uIG1vZCQxKGRpdmlkZW5kLCBkaXZpc29yKSB7XG4gICAgICAgIHJldHVybiAoKGRpdmlkZW5kICUgZGl2aXNvcikgKyBkaXZpc29yKSAlIGRpdmlzb3I7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9jYWxTdGFydE9mRGF0ZSh5LCBtLCBkKSB7XG4gICAgICAgIC8vIHRoZSBkYXRlIGNvbnN0cnVjdG9yIHJlbWFwcyB5ZWFycyAwLTk5IHRvIDE5MDAtMTk5OVxuICAgICAgICBpZiAoeSA8IDEwMCAmJiB5ID49IDApIHtcbiAgICAgICAgICAgIC8vIHByZXNlcnZlIGxlYXAgeWVhcnMgdXNpbmcgYSBmdWxsIDQwMCB5ZWFyIGN5Y2xlLCB0aGVuIHJlc2V0XG4gICAgICAgICAgICByZXR1cm4gbmV3IERhdGUoeSArIDQwMCwgbSwgZCkgLSBNU19QRVJfNDAwX1lFQVJTO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHksIG0sIGQpLnZhbHVlT2YoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHV0Y1N0YXJ0T2ZEYXRlKHksIG0sIGQpIHtcbiAgICAgICAgLy8gRGF0ZS5VVEMgcmVtYXBzIHllYXJzIDAtOTkgdG8gMTkwMC0xOTk5XG4gICAgICAgIGlmICh5IDwgMTAwICYmIHkgPj0gMCkge1xuICAgICAgICAgICAgLy8gcHJlc2VydmUgbGVhcCB5ZWFycyB1c2luZyBhIGZ1bGwgNDAwIHllYXIgY3ljbGUsIHRoZW4gcmVzZXRcbiAgICAgICAgICAgIHJldHVybiBEYXRlLlVUQyh5ICsgNDAwLCBtLCBkKSAtIE1TX1BFUl80MDBfWUVBUlM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gRGF0ZS5VVEMoeSwgbSwgZCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzdGFydE9mKHVuaXRzKSB7XG4gICAgICAgIHZhciB0aW1lLCBzdGFydE9mRGF0ZTtcbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG4gICAgICAgIGlmICh1bml0cyA9PT0gdW5kZWZpbmVkIHx8IHVuaXRzID09PSAnbWlsbGlzZWNvbmQnIHx8ICF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICBzdGFydE9mRGF0ZSA9IHRoaXMuX2lzVVRDID8gdXRjU3RhcnRPZkRhdGUgOiBsb2NhbFN0YXJ0T2ZEYXRlO1xuXG4gICAgICAgIHN3aXRjaCAodW5pdHMpIHtcbiAgICAgICAgICAgIGNhc2UgJ3llYXInOlxuICAgICAgICAgICAgICAgIHRpbWUgPSBzdGFydE9mRGF0ZSh0aGlzLnllYXIoKSwgMCwgMSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdxdWFydGVyJzpcbiAgICAgICAgICAgICAgICB0aW1lID0gc3RhcnRPZkRhdGUoXG4gICAgICAgICAgICAgICAgICAgIHRoaXMueWVhcigpLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1vbnRoKCkgLSAodGhpcy5tb250aCgpICUgMyksXG4gICAgICAgICAgICAgICAgICAgIDFcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbW9udGgnOlxuICAgICAgICAgICAgICAgIHRpbWUgPSBzdGFydE9mRGF0ZSh0aGlzLnllYXIoKSwgdGhpcy5tb250aCgpLCAxKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3dlZWsnOlxuICAgICAgICAgICAgICAgIHRpbWUgPSBzdGFydE9mRGF0ZShcbiAgICAgICAgICAgICAgICAgICAgdGhpcy55ZWFyKCksXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubW9udGgoKSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kYXRlKCkgLSB0aGlzLndlZWtkYXkoKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdpc29XZWVrJzpcbiAgICAgICAgICAgICAgICB0aW1lID0gc3RhcnRPZkRhdGUoXG4gICAgICAgICAgICAgICAgICAgIHRoaXMueWVhcigpLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1vbnRoKCksXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGF0ZSgpIC0gKHRoaXMuaXNvV2Vla2RheSgpIC0gMSlcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnZGF5JzpcbiAgICAgICAgICAgIGNhc2UgJ2RhdGUnOlxuICAgICAgICAgICAgICAgIHRpbWUgPSBzdGFydE9mRGF0ZSh0aGlzLnllYXIoKSwgdGhpcy5tb250aCgpLCB0aGlzLmRhdGUoKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdob3VyJzpcbiAgICAgICAgICAgICAgICB0aW1lID0gdGhpcy5fZC52YWx1ZU9mKCk7XG4gICAgICAgICAgICAgICAgdGltZSAtPSBtb2QkMShcbiAgICAgICAgICAgICAgICAgICAgdGltZSArICh0aGlzLl9pc1VUQyA/IDAgOiB0aGlzLnV0Y09mZnNldCgpICogTVNfUEVSX01JTlVURSksXG4gICAgICAgICAgICAgICAgICAgIE1TX1BFUl9IT1VSXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgICAgICAgICAgICAgdGltZSA9IHRoaXMuX2QudmFsdWVPZigpO1xuICAgICAgICAgICAgICAgIHRpbWUgLT0gbW9kJDEodGltZSwgTVNfUEVSX01JTlVURSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdzZWNvbmQnOlxuICAgICAgICAgICAgICAgIHRpbWUgPSB0aGlzLl9kLnZhbHVlT2YoKTtcbiAgICAgICAgICAgICAgICB0aW1lIC09IG1vZCQxKHRpbWUsIE1TX1BFUl9TRUNPTkQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fZC5zZXRUaW1lKHRpbWUpO1xuICAgICAgICBob29rcy51cGRhdGVPZmZzZXQodGhpcywgdHJ1ZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVuZE9mKHVuaXRzKSB7XG4gICAgICAgIHZhciB0aW1lLCBzdGFydE9mRGF0ZTtcbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG4gICAgICAgIGlmICh1bml0cyA9PT0gdW5kZWZpbmVkIHx8IHVuaXRzID09PSAnbWlsbGlzZWNvbmQnIHx8ICF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICBzdGFydE9mRGF0ZSA9IHRoaXMuX2lzVVRDID8gdXRjU3RhcnRPZkRhdGUgOiBsb2NhbFN0YXJ0T2ZEYXRlO1xuXG4gICAgICAgIHN3aXRjaCAodW5pdHMpIHtcbiAgICAgICAgICAgIGNhc2UgJ3llYXInOlxuICAgICAgICAgICAgICAgIHRpbWUgPSBzdGFydE9mRGF0ZSh0aGlzLnllYXIoKSArIDEsIDAsIDEpIC0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3F1YXJ0ZXInOlxuICAgICAgICAgICAgICAgIHRpbWUgPVxuICAgICAgICAgICAgICAgICAgICBzdGFydE9mRGF0ZShcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMueWVhcigpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tb250aCgpIC0gKHRoaXMubW9udGgoKSAlIDMpICsgMyxcbiAgICAgICAgICAgICAgICAgICAgICAgIDFcbiAgICAgICAgICAgICAgICAgICAgKSAtIDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdtb250aCc6XG4gICAgICAgICAgICAgICAgdGltZSA9IHN0YXJ0T2ZEYXRlKHRoaXMueWVhcigpLCB0aGlzLm1vbnRoKCkgKyAxLCAxKSAtIDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICd3ZWVrJzpcbiAgICAgICAgICAgICAgICB0aW1lID1cbiAgICAgICAgICAgICAgICAgICAgc3RhcnRPZkRhdGUoXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnllYXIoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubW9udGgoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGF0ZSgpIC0gdGhpcy53ZWVrZGF5KCkgKyA3XG4gICAgICAgICAgICAgICAgICAgICkgLSAxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnaXNvV2Vlayc6XG4gICAgICAgICAgICAgICAgdGltZSA9XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0T2ZEYXRlKFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy55ZWFyKCksXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1vbnRoKCksXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRhdGUoKSAtICh0aGlzLmlzb1dlZWtkYXkoKSAtIDEpICsgN1xuICAgICAgICAgICAgICAgICAgICApIC0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2RheSc6XG4gICAgICAgICAgICBjYXNlICdkYXRlJzpcbiAgICAgICAgICAgICAgICB0aW1lID0gc3RhcnRPZkRhdGUodGhpcy55ZWFyKCksIHRoaXMubW9udGgoKSwgdGhpcy5kYXRlKCkgKyAxKSAtIDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdob3VyJzpcbiAgICAgICAgICAgICAgICB0aW1lID0gdGhpcy5fZC52YWx1ZU9mKCk7XG4gICAgICAgICAgICAgICAgdGltZSArPVxuICAgICAgICAgICAgICAgICAgICBNU19QRVJfSE9VUiAtXG4gICAgICAgICAgICAgICAgICAgIG1vZCQxKFxuICAgICAgICAgICAgICAgICAgICAgICAgdGltZSArICh0aGlzLl9pc1VUQyA/IDAgOiB0aGlzLnV0Y09mZnNldCgpICogTVNfUEVSX01JTlVURSksXG4gICAgICAgICAgICAgICAgICAgICAgICBNU19QRVJfSE9VUlxuICAgICAgICAgICAgICAgICAgICApIC1cbiAgICAgICAgICAgICAgICAgICAgMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgICAgICAgICAgICAgdGltZSA9IHRoaXMuX2QudmFsdWVPZigpO1xuICAgICAgICAgICAgICAgIHRpbWUgKz0gTVNfUEVSX01JTlVURSAtIG1vZCQxKHRpbWUsIE1TX1BFUl9NSU5VVEUpIC0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgICAgICAgICAgICAgdGltZSA9IHRoaXMuX2QudmFsdWVPZigpO1xuICAgICAgICAgICAgICAgIHRpbWUgKz0gTVNfUEVSX1NFQ09ORCAtIG1vZCQxKHRpbWUsIE1TX1BFUl9TRUNPTkQpIC0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2Quc2V0VGltZSh0aW1lKTtcbiAgICAgICAgaG9va3MudXBkYXRlT2Zmc2V0KHRoaXMsIHRydWUpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2YWx1ZU9mKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZC52YWx1ZU9mKCkgLSAodGhpcy5fb2Zmc2V0IHx8IDApICogNjAwMDA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdW5peCgpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IodGhpcy52YWx1ZU9mKCkgLyAxMDAwKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b0RhdGUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZSh0aGlzLnZhbHVlT2YoKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9BcnJheSgpIHtcbiAgICAgICAgdmFyIG0gPSB0aGlzO1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgbS55ZWFyKCksXG4gICAgICAgICAgICBtLm1vbnRoKCksXG4gICAgICAgICAgICBtLmRhdGUoKSxcbiAgICAgICAgICAgIG0uaG91cigpLFxuICAgICAgICAgICAgbS5taW51dGUoKSxcbiAgICAgICAgICAgIG0uc2Vjb25kKCksXG4gICAgICAgICAgICBtLm1pbGxpc2Vjb25kKCksXG4gICAgICAgIF07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9PYmplY3QoKSB7XG4gICAgICAgIHZhciBtID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHllYXJzOiBtLnllYXIoKSxcbiAgICAgICAgICAgIG1vbnRoczogbS5tb250aCgpLFxuICAgICAgICAgICAgZGF0ZTogbS5kYXRlKCksXG4gICAgICAgICAgICBob3VyczogbS5ob3VycygpLFxuICAgICAgICAgICAgbWludXRlczogbS5taW51dGVzKCksXG4gICAgICAgICAgICBzZWNvbmRzOiBtLnNlY29uZHMoKSxcbiAgICAgICAgICAgIG1pbGxpc2Vjb25kczogbS5taWxsaXNlY29uZHMoKSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICAgIC8vIG5ldyBEYXRlKE5hTikudG9KU09OKCkgPT09IG51bGxcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNWYWxpZCgpID8gdGhpcy50b0lTT1N0cmluZygpIDogbnVsbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1ZhbGlkJDIoKSB7XG4gICAgICAgIHJldHVybiBpc1ZhbGlkKHRoaXMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNpbmdGbGFncygpIHtcbiAgICAgICAgcmV0dXJuIGV4dGVuZCh7fSwgZ2V0UGFyc2luZ0ZsYWdzKHRoaXMpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnZhbGlkQXQoKSB7XG4gICAgICAgIHJldHVybiBnZXRQYXJzaW5nRmxhZ3ModGhpcykub3ZlcmZsb3c7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRpb25EYXRhKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaW5wdXQ6IHRoaXMuX2ksXG4gICAgICAgICAgICBmb3JtYXQ6IHRoaXMuX2YsXG4gICAgICAgICAgICBsb2NhbGU6IHRoaXMuX2xvY2FsZSxcbiAgICAgICAgICAgIGlzVVRDOiB0aGlzLl9pc1VUQyxcbiAgICAgICAgICAgIHN0cmljdDogdGhpcy5fc3RyaWN0LFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGFkZEZvcm1hdFRva2VuKCdOJywgMCwgMCwgJ2VyYUFiYnInKTtcbiAgICBhZGRGb3JtYXRUb2tlbignTk4nLCAwLCAwLCAnZXJhQWJicicpO1xuICAgIGFkZEZvcm1hdFRva2VuKCdOTk4nLCAwLCAwLCAnZXJhQWJicicpO1xuICAgIGFkZEZvcm1hdFRva2VuKCdOTk5OJywgMCwgMCwgJ2VyYU5hbWUnKTtcbiAgICBhZGRGb3JtYXRUb2tlbignTk5OTk4nLCAwLCAwLCAnZXJhTmFycm93Jyk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbigneScsIFsneScsIDFdLCAneW8nLCAnZXJhWWVhcicpO1xuICAgIGFkZEZvcm1hdFRva2VuKCd5JywgWyd5eScsIDJdLCAwLCAnZXJhWWVhcicpO1xuICAgIGFkZEZvcm1hdFRva2VuKCd5JywgWyd5eXknLCAzXSwgMCwgJ2VyYVllYXInKTtcbiAgICBhZGRGb3JtYXRUb2tlbigneScsIFsneXl5eScsIDRdLCAwLCAnZXJhWWVhcicpO1xuXG4gICAgYWRkUmVnZXhUb2tlbignTicsIG1hdGNoRXJhQWJicik7XG4gICAgYWRkUmVnZXhUb2tlbignTk4nLCBtYXRjaEVyYUFiYnIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ05OTicsIG1hdGNoRXJhQWJicik7XG4gICAgYWRkUmVnZXhUb2tlbignTk5OTicsIG1hdGNoRXJhTmFtZSk7XG4gICAgYWRkUmVnZXhUb2tlbignTk5OTk4nLCBtYXRjaEVyYU5hcnJvdyk7XG5cbiAgICBhZGRQYXJzZVRva2VuKFsnTicsICdOTicsICdOTk4nLCAnTk5OTicsICdOTk5OTiddLCBmdW5jdGlvbiAoXG4gICAgICAgIGlucHV0LFxuICAgICAgICBhcnJheSxcbiAgICAgICAgY29uZmlnLFxuICAgICAgICB0b2tlblxuICAgICkge1xuICAgICAgICB2YXIgZXJhID0gY29uZmlnLl9sb2NhbGUuZXJhc1BhcnNlKGlucHV0LCB0b2tlbiwgY29uZmlnLl9zdHJpY3QpO1xuICAgICAgICBpZiAoZXJhKSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5lcmEgPSBlcmE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5pbnZhbGlkRXJhID0gaW5wdXQ7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ3knLCBtYXRjaFVuc2lnbmVkKTtcbiAgICBhZGRSZWdleFRva2VuKCd5eScsIG1hdGNoVW5zaWduZWQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ3l5eScsIG1hdGNoVW5zaWduZWQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ3l5eXknLCBtYXRjaFVuc2lnbmVkKTtcbiAgICBhZGRSZWdleFRva2VuKCd5bycsIG1hdGNoRXJhWWVhck9yZGluYWwpO1xuXG4gICAgYWRkUGFyc2VUb2tlbihbJ3knLCAneXknLCAneXl5JywgJ3l5eXknXSwgWUVBUik7XG4gICAgYWRkUGFyc2VUb2tlbihbJ3lvJ10sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZywgdG9rZW4pIHtcbiAgICAgICAgdmFyIG1hdGNoO1xuICAgICAgICBpZiAoY29uZmlnLl9sb2NhbGUuX2VyYVllYXJPcmRpbmFsUmVnZXgpIHtcbiAgICAgICAgICAgIG1hdGNoID0gaW5wdXQubWF0Y2goY29uZmlnLl9sb2NhbGUuX2VyYVllYXJPcmRpbmFsUmVnZXgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbmZpZy5fbG9jYWxlLmVyYVllYXJPcmRpbmFsUGFyc2UpIHtcbiAgICAgICAgICAgIGFycmF5W1lFQVJdID0gY29uZmlnLl9sb2NhbGUuZXJhWWVhck9yZGluYWxQYXJzZShpbnB1dCwgbWF0Y2gpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXJyYXlbWUVBUl0gPSBwYXJzZUludChpbnB1dCwgMTApO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBsb2NhbGVFcmFzKG0sIGZvcm1hdCkge1xuICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgIGwsXG4gICAgICAgICAgICBkYXRlLFxuICAgICAgICAgICAgZXJhcyA9IHRoaXMuX2VyYXMgfHwgZ2V0TG9jYWxlKCdlbicpLl9lcmFzO1xuICAgICAgICBmb3IgKGkgPSAwLCBsID0gZXJhcy5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIGVyYXNbaV0uc2luY2UpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgICAgICAvLyB0cnVuY2F0ZSB0aW1lXG4gICAgICAgICAgICAgICAgICAgIGRhdGUgPSBob29rcyhlcmFzW2ldLnNpbmNlKS5zdGFydE9mKCdkYXknKTtcbiAgICAgICAgICAgICAgICAgICAgZXJhc1tpXS5zaW5jZSA9IGRhdGUudmFsdWVPZigpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc3dpdGNoICh0eXBlb2YgZXJhc1tpXS51bnRpbCkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgICAgICAgICAgICAgICAgIGVyYXNbaV0udW50aWwgPSArSW5maW5pdHk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICAgICAgICAgIC8vIHRydW5jYXRlIHRpbWVcbiAgICAgICAgICAgICAgICAgICAgZGF0ZSA9IGhvb2tzKGVyYXNbaV0udW50aWwpLnN0YXJ0T2YoJ2RheScpLnZhbHVlT2YoKTtcbiAgICAgICAgICAgICAgICAgICAgZXJhc1tpXS51bnRpbCA9IGRhdGUudmFsdWVPZigpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXJhcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb2NhbGVFcmFzUGFyc2UoZXJhTmFtZSwgZm9ybWF0LCBzdHJpY3QpIHtcbiAgICAgICAgdmFyIGksXG4gICAgICAgICAgICBsLFxuICAgICAgICAgICAgZXJhcyA9IHRoaXMuZXJhcygpLFxuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIGFiYnIsXG4gICAgICAgICAgICBuYXJyb3c7XG4gICAgICAgIGVyYU5hbWUgPSBlcmFOYW1lLnRvVXBwZXJDYXNlKCk7XG5cbiAgICAgICAgZm9yIChpID0gMCwgbCA9IGVyYXMubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgICAgICAgICBuYW1lID0gZXJhc1tpXS5uYW1lLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICBhYmJyID0gZXJhc1tpXS5hYmJyLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICBuYXJyb3cgPSBlcmFzW2ldLm5hcnJvdy50b1VwcGVyQ2FzZSgpO1xuXG4gICAgICAgICAgICBpZiAoc3RyaWN0KSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChmb3JtYXQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnTic6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ05OJzpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnTk5OJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhYmJyID09PSBlcmFOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVyYXNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICBjYXNlICdOTk5OJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuYW1lID09PSBlcmFOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVyYXNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICBjYXNlICdOTk5OTic6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmFycm93ID09PSBlcmFOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVyYXNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKFtuYW1lLCBhYmJyLCBuYXJyb3ddLmluZGV4T2YoZXJhTmFtZSkgPj0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlcmFzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9jYWxlRXJhc0NvbnZlcnRZZWFyKGVyYSwgeWVhcikge1xuICAgICAgICB2YXIgZGlyID0gZXJhLnNpbmNlIDw9IGVyYS51bnRpbCA/ICsxIDogLTE7XG4gICAgICAgIGlmICh5ZWFyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBob29rcyhlcmEuc2luY2UpLnllYXIoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBob29rcyhlcmEuc2luY2UpLnllYXIoKSArICh5ZWFyIC0gZXJhLm9mZnNldCkgKiBkaXI7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRFcmFOYW1lKCkge1xuICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgIGwsXG4gICAgICAgICAgICB2YWwsXG4gICAgICAgICAgICBlcmFzID0gdGhpcy5sb2NhbGVEYXRhKCkuZXJhcygpO1xuICAgICAgICBmb3IgKGkgPSAwLCBsID0gZXJhcy5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgICAgIC8vIHRydW5jYXRlIHRpbWVcbiAgICAgICAgICAgIHZhbCA9IHRoaXMuY2xvbmUoKS5zdGFydE9mKCdkYXknKS52YWx1ZU9mKCk7XG5cbiAgICAgICAgICAgIGlmIChlcmFzW2ldLnNpbmNlIDw9IHZhbCAmJiB2YWwgPD0gZXJhc1tpXS51bnRpbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlcmFzW2ldLm5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXJhc1tpXS51bnRpbCA8PSB2YWwgJiYgdmFsIDw9IGVyYXNbaV0uc2luY2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXJhc1tpXS5uYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldEVyYU5hcnJvdygpIHtcbiAgICAgICAgdmFyIGksXG4gICAgICAgICAgICBsLFxuICAgICAgICAgICAgdmFsLFxuICAgICAgICAgICAgZXJhcyA9IHRoaXMubG9jYWxlRGF0YSgpLmVyYXMoKTtcbiAgICAgICAgZm9yIChpID0gMCwgbCA9IGVyYXMubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgICAgICAgICAvLyB0cnVuY2F0ZSB0aW1lXG4gICAgICAgICAgICB2YWwgPSB0aGlzLmNsb25lKCkuc3RhcnRPZignZGF5JykudmFsdWVPZigpO1xuXG4gICAgICAgICAgICBpZiAoZXJhc1tpXS5zaW5jZSA8PSB2YWwgJiYgdmFsIDw9IGVyYXNbaV0udW50aWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXJhc1tpXS5uYXJyb3c7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXJhc1tpXS51bnRpbCA8PSB2YWwgJiYgdmFsIDw9IGVyYXNbaV0uc2luY2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXJhc1tpXS5uYXJyb3c7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0RXJhQWJicigpIHtcbiAgICAgICAgdmFyIGksXG4gICAgICAgICAgICBsLFxuICAgICAgICAgICAgdmFsLFxuICAgICAgICAgICAgZXJhcyA9IHRoaXMubG9jYWxlRGF0YSgpLmVyYXMoKTtcbiAgICAgICAgZm9yIChpID0gMCwgbCA9IGVyYXMubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgICAgICAgICAvLyB0cnVuY2F0ZSB0aW1lXG4gICAgICAgICAgICB2YWwgPSB0aGlzLmNsb25lKCkuc3RhcnRPZignZGF5JykudmFsdWVPZigpO1xuXG4gICAgICAgICAgICBpZiAoZXJhc1tpXS5zaW5jZSA8PSB2YWwgJiYgdmFsIDw9IGVyYXNbaV0udW50aWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXJhc1tpXS5hYmJyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVyYXNbaV0udW50aWwgPD0gdmFsICYmIHZhbCA8PSBlcmFzW2ldLnNpbmNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVyYXNbaV0uYWJicjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRFcmFZZWFyKCkge1xuICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgIGwsXG4gICAgICAgICAgICBkaXIsXG4gICAgICAgICAgICB2YWwsXG4gICAgICAgICAgICBlcmFzID0gdGhpcy5sb2NhbGVEYXRhKCkuZXJhcygpO1xuICAgICAgICBmb3IgKGkgPSAwLCBsID0gZXJhcy5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgICAgIGRpciA9IGVyYXNbaV0uc2luY2UgPD0gZXJhc1tpXS51bnRpbCA/ICsxIDogLTE7XG5cbiAgICAgICAgICAgIC8vIHRydW5jYXRlIHRpbWVcbiAgICAgICAgICAgIHZhbCA9IHRoaXMuY2xvbmUoKS5zdGFydE9mKCdkYXknKS52YWx1ZU9mKCk7XG5cbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAoZXJhc1tpXS5zaW5jZSA8PSB2YWwgJiYgdmFsIDw9IGVyYXNbaV0udW50aWwpIHx8XG4gICAgICAgICAgICAgICAgKGVyYXNbaV0udW50aWwgPD0gdmFsICYmIHZhbCA8PSBlcmFzW2ldLnNpbmNlKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAgICAgKHRoaXMueWVhcigpIC0gaG9va3MoZXJhc1tpXS5zaW5jZSkueWVhcigpKSAqIGRpciArXG4gICAgICAgICAgICAgICAgICAgIGVyYXNbaV0ub2Zmc2V0XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLnllYXIoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlcmFzTmFtZVJlZ2V4KGlzU3RyaWN0KSB7XG4gICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX2VyYXNOYW1lUmVnZXgnKSkge1xuICAgICAgICAgICAgY29tcHV0ZUVyYXNQYXJzZS5jYWxsKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpc1N0cmljdCA/IHRoaXMuX2VyYXNOYW1lUmVnZXggOiB0aGlzLl9lcmFzUmVnZXg7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXJhc0FiYnJSZWdleChpc1N0cmljdCkge1xuICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ19lcmFzQWJiclJlZ2V4JykpIHtcbiAgICAgICAgICAgIGNvbXB1dGVFcmFzUGFyc2UuY2FsbCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXNTdHJpY3QgPyB0aGlzLl9lcmFzQWJiclJlZ2V4IDogdGhpcy5fZXJhc1JlZ2V4O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVyYXNOYXJyb3dSZWdleChpc1N0cmljdCkge1xuICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ19lcmFzTmFycm93UmVnZXgnKSkge1xuICAgICAgICAgICAgY29tcHV0ZUVyYXNQYXJzZS5jYWxsKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpc1N0cmljdCA/IHRoaXMuX2VyYXNOYXJyb3dSZWdleCA6IHRoaXMuX2VyYXNSZWdleDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYXRjaEVyYUFiYnIoaXNTdHJpY3QsIGxvY2FsZSkge1xuICAgICAgICByZXR1cm4gbG9jYWxlLmVyYXNBYmJyUmVnZXgoaXNTdHJpY3QpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1hdGNoRXJhTmFtZShpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGUuZXJhc05hbWVSZWdleChpc1N0cmljdCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWF0Y2hFcmFOYXJyb3coaXNTdHJpY3QsIGxvY2FsZSkge1xuICAgICAgICByZXR1cm4gbG9jYWxlLmVyYXNOYXJyb3dSZWdleChpc1N0cmljdCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWF0Y2hFcmFZZWFyT3JkaW5hbChpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGUuX2VyYVllYXJPcmRpbmFsUmVnZXggfHwgbWF0Y2hVbnNpZ25lZDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb21wdXRlRXJhc1BhcnNlKCkge1xuICAgICAgICB2YXIgYWJiclBpZWNlcyA9IFtdLFxuICAgICAgICAgICAgbmFtZVBpZWNlcyA9IFtdLFxuICAgICAgICAgICAgbmFycm93UGllY2VzID0gW10sXG4gICAgICAgICAgICBtaXhlZFBpZWNlcyA9IFtdLFxuICAgICAgICAgICAgaSxcbiAgICAgICAgICAgIGwsXG4gICAgICAgICAgICBlcmFzID0gdGhpcy5lcmFzKCk7XG5cbiAgICAgICAgZm9yIChpID0gMCwgbCA9IGVyYXMubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgICAgICAgICBuYW1lUGllY2VzLnB1c2gocmVnZXhFc2NhcGUoZXJhc1tpXS5uYW1lKSk7XG4gICAgICAgICAgICBhYmJyUGllY2VzLnB1c2gocmVnZXhFc2NhcGUoZXJhc1tpXS5hYmJyKSk7XG4gICAgICAgICAgICBuYXJyb3dQaWVjZXMucHVzaChyZWdleEVzY2FwZShlcmFzW2ldLm5hcnJvdykpO1xuXG4gICAgICAgICAgICBtaXhlZFBpZWNlcy5wdXNoKHJlZ2V4RXNjYXBlKGVyYXNbaV0ubmFtZSkpO1xuICAgICAgICAgICAgbWl4ZWRQaWVjZXMucHVzaChyZWdleEVzY2FwZShlcmFzW2ldLmFiYnIpKTtcbiAgICAgICAgICAgIG1peGVkUGllY2VzLnB1c2gocmVnZXhFc2NhcGUoZXJhc1tpXS5uYXJyb3cpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2VyYXNSZWdleCA9IG5ldyBSZWdFeHAoJ14oJyArIG1peGVkUGllY2VzLmpvaW4oJ3wnKSArICcpJywgJ2knKTtcbiAgICAgICAgdGhpcy5fZXJhc05hbWVSZWdleCA9IG5ldyBSZWdFeHAoJ14oJyArIG5hbWVQaWVjZXMuam9pbignfCcpICsgJyknLCAnaScpO1xuICAgICAgICB0aGlzLl9lcmFzQWJiclJlZ2V4ID0gbmV3IFJlZ0V4cCgnXignICsgYWJiclBpZWNlcy5qb2luKCd8JykgKyAnKScsICdpJyk7XG4gICAgICAgIHRoaXMuX2VyYXNOYXJyb3dSZWdleCA9IG5ldyBSZWdFeHAoXG4gICAgICAgICAgICAnXignICsgbmFycm93UGllY2VzLmpvaW4oJ3wnKSArICcpJyxcbiAgICAgICAgICAgICdpJ1xuICAgICAgICApO1xuICAgIH1cblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnZ2cnLCAyXSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy53ZWVrWWVhcigpICUgMTAwO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydHRycsIDJdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzb1dlZWtZZWFyKCkgJSAxMDA7XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBhZGRXZWVrWWVhckZvcm1hdFRva2VuKHRva2VuLCBnZXR0ZXIpIHtcbiAgICAgICAgYWRkRm9ybWF0VG9rZW4oMCwgW3Rva2VuLCB0b2tlbi5sZW5ndGhdLCAwLCBnZXR0ZXIpO1xuICAgIH1cblxuICAgIGFkZFdlZWtZZWFyRm9ybWF0VG9rZW4oJ2dnZ2cnLCAnd2Vla1llYXInKTtcbiAgICBhZGRXZWVrWWVhckZvcm1hdFRva2VuKCdnZ2dnZycsICd3ZWVrWWVhcicpO1xuICAgIGFkZFdlZWtZZWFyRm9ybWF0VG9rZW4oJ0dHR0cnLCAnaXNvV2Vla1llYXInKTtcbiAgICBhZGRXZWVrWWVhckZvcm1hdFRva2VuKCdHR0dHRycsICdpc29XZWVrWWVhcicpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCd3ZWVrWWVhcicsICdnZycpO1xuICAgIGFkZFVuaXRBbGlhcygnaXNvV2Vla1llYXInLCAnR0cnKTtcblxuICAgIC8vIFBSSU9SSVRZXG5cbiAgICBhZGRVbml0UHJpb3JpdHkoJ3dlZWtZZWFyJywgMSk7XG4gICAgYWRkVW5pdFByaW9yaXR5KCdpc29XZWVrWWVhcicsIDEpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignRycsIG1hdGNoU2lnbmVkKTtcbiAgICBhZGRSZWdleFRva2VuKCdnJywgbWF0Y2hTaWduZWQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0dHJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2dnJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0dHR0cnLCBtYXRjaDF0bzQsIG1hdGNoNCk7XG4gICAgYWRkUmVnZXhUb2tlbignZ2dnZycsIG1hdGNoMXRvNCwgbWF0Y2g0KTtcbiAgICBhZGRSZWdleFRva2VuKCdHR0dHRycsIG1hdGNoMXRvNiwgbWF0Y2g2KTtcbiAgICBhZGRSZWdleFRva2VuKCdnZ2dnZycsIG1hdGNoMXRvNiwgbWF0Y2g2KTtcblxuICAgIGFkZFdlZWtQYXJzZVRva2VuKFsnZ2dnZycsICdnZ2dnZycsICdHR0dHJywgJ0dHR0dHJ10sIGZ1bmN0aW9uIChcbiAgICAgICAgaW5wdXQsXG4gICAgICAgIHdlZWssXG4gICAgICAgIGNvbmZpZyxcbiAgICAgICAgdG9rZW5cbiAgICApIHtcbiAgICAgICAgd2Vla1t0b2tlbi5zdWJzdHIoMCwgMildID0gdG9JbnQoaW5wdXQpO1xuICAgIH0pO1xuXG4gICAgYWRkV2Vla1BhcnNlVG9rZW4oWydnZycsICdHRyddLCBmdW5jdGlvbiAoaW5wdXQsIHdlZWssIGNvbmZpZywgdG9rZW4pIHtcbiAgICAgICAgd2Vla1t0b2tlbl0gPSBob29rcy5wYXJzZVR3b0RpZ2l0WWVhcihpbnB1dCk7XG4gICAgfSk7XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICBmdW5jdGlvbiBnZXRTZXRXZWVrWWVhcihpbnB1dCkge1xuICAgICAgICByZXR1cm4gZ2V0U2V0V2Vla1llYXJIZWxwZXIuY2FsbChcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgIHRoaXMud2VlaygpLFxuICAgICAgICAgICAgdGhpcy53ZWVrZGF5KCksXG4gICAgICAgICAgICB0aGlzLmxvY2FsZURhdGEoKS5fd2Vlay5kb3csXG4gICAgICAgICAgICB0aGlzLmxvY2FsZURhdGEoKS5fd2Vlay5kb3lcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTZXRJU09XZWVrWWVhcihpbnB1dCkge1xuICAgICAgICByZXR1cm4gZ2V0U2V0V2Vla1llYXJIZWxwZXIuY2FsbChcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgIHRoaXMuaXNvV2VlaygpLFxuICAgICAgICAgICAgdGhpcy5pc29XZWVrZGF5KCksXG4gICAgICAgICAgICAxLFxuICAgICAgICAgICAgNFxuICAgICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldElTT1dlZWtzSW5ZZWFyKCkge1xuICAgICAgICByZXR1cm4gd2Vla3NJblllYXIodGhpcy55ZWFyKCksIDEsIDQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldElTT1dlZWtzSW5JU09XZWVrWWVhcigpIHtcbiAgICAgICAgcmV0dXJuIHdlZWtzSW5ZZWFyKHRoaXMuaXNvV2Vla1llYXIoKSwgMSwgNCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0V2Vla3NJblllYXIoKSB7XG4gICAgICAgIHZhciB3ZWVrSW5mbyA9IHRoaXMubG9jYWxlRGF0YSgpLl93ZWVrO1xuICAgICAgICByZXR1cm4gd2Vla3NJblllYXIodGhpcy55ZWFyKCksIHdlZWtJbmZvLmRvdywgd2Vla0luZm8uZG95KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRXZWVrc0luV2Vla1llYXIoKSB7XG4gICAgICAgIHZhciB3ZWVrSW5mbyA9IHRoaXMubG9jYWxlRGF0YSgpLl93ZWVrO1xuICAgICAgICByZXR1cm4gd2Vla3NJblllYXIodGhpcy53ZWVrWWVhcigpLCB3ZWVrSW5mby5kb3csIHdlZWtJbmZvLmRveSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U2V0V2Vla1llYXJIZWxwZXIoaW5wdXQsIHdlZWssIHdlZWtkYXksIGRvdywgZG95KSB7XG4gICAgICAgIHZhciB3ZWVrc1RhcmdldDtcbiAgICAgICAgaWYgKGlucHV0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB3ZWVrT2ZZZWFyKHRoaXMsIGRvdywgZG95KS55ZWFyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd2Vla3NUYXJnZXQgPSB3ZWVrc0luWWVhcihpbnB1dCwgZG93LCBkb3kpO1xuICAgICAgICAgICAgaWYgKHdlZWsgPiB3ZWVrc1RhcmdldCkge1xuICAgICAgICAgICAgICAgIHdlZWsgPSB3ZWVrc1RhcmdldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzZXRXZWVrQWxsLmNhbGwodGhpcywgaW5wdXQsIHdlZWssIHdlZWtkYXksIGRvdywgZG95KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldFdlZWtBbGwod2Vla1llYXIsIHdlZWssIHdlZWtkYXksIGRvdywgZG95KSB7XG4gICAgICAgIHZhciBkYXlPZlllYXJEYXRhID0gZGF5T2ZZZWFyRnJvbVdlZWtzKHdlZWtZZWFyLCB3ZWVrLCB3ZWVrZGF5LCBkb3csIGRveSksXG4gICAgICAgICAgICBkYXRlID0gY3JlYXRlVVRDRGF0ZShkYXlPZlllYXJEYXRhLnllYXIsIDAsIGRheU9mWWVhckRhdGEuZGF5T2ZZZWFyKTtcblxuICAgICAgICB0aGlzLnllYXIoZGF0ZS5nZXRVVENGdWxsWWVhcigpKTtcbiAgICAgICAgdGhpcy5tb250aChkYXRlLmdldFVUQ01vbnRoKCkpO1xuICAgICAgICB0aGlzLmRhdGUoZGF0ZS5nZXRVVENEYXRlKCkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbignUScsIDAsICdRbycsICdxdWFydGVyJyk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ3F1YXJ0ZXInLCAnUScpO1xuXG4gICAgLy8gUFJJT1JJVFlcblxuICAgIGFkZFVuaXRQcmlvcml0eSgncXVhcnRlcicsIDcpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignUScsIG1hdGNoMSk7XG4gICAgYWRkUGFyc2VUb2tlbignUScsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICAgICAgYXJyYXlbTU9OVEhdID0gKHRvSW50KGlucHV0KSAtIDEpICogMztcbiAgICB9KTtcblxuICAgIC8vIE1PTUVOVFNcblxuICAgIGZ1bmN0aW9uIGdldFNldFF1YXJ0ZXIoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0ID09IG51bGxcbiAgICAgICAgICAgID8gTWF0aC5jZWlsKCh0aGlzLm1vbnRoKCkgKyAxKSAvIDMpXG4gICAgICAgICAgICA6IHRoaXMubW9udGgoKGlucHV0IC0gMSkgKiAzICsgKHRoaXMubW9udGgoKSAlIDMpKTtcbiAgICB9XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbignRCcsIFsnREQnLCAyXSwgJ0RvJywgJ2RhdGUnKTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygnZGF0ZScsICdEJyk7XG5cbiAgICAvLyBQUklPUklUWVxuICAgIGFkZFVuaXRQcmlvcml0eSgnZGF0ZScsIDkpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignRCcsIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignREQnLCBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgYWRkUmVnZXhUb2tlbignRG8nLCBmdW5jdGlvbiAoaXNTdHJpY3QsIGxvY2FsZSkge1xuICAgICAgICAvLyBUT0RPOiBSZW1vdmUgXCJvcmRpbmFsUGFyc2VcIiBmYWxsYmFjayBpbiBuZXh0IG1ham9yIHJlbGVhc2UuXG4gICAgICAgIHJldHVybiBpc1N0cmljdFxuICAgICAgICAgICAgPyBsb2NhbGUuX2RheU9mTW9udGhPcmRpbmFsUGFyc2UgfHwgbG9jYWxlLl9vcmRpbmFsUGFyc2VcbiAgICAgICAgICAgIDogbG9jYWxlLl9kYXlPZk1vbnRoT3JkaW5hbFBhcnNlTGVuaWVudDtcbiAgICB9KTtcblxuICAgIGFkZFBhcnNlVG9rZW4oWydEJywgJ0REJ10sIERBVEUpO1xuICAgIGFkZFBhcnNlVG9rZW4oJ0RvJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSkge1xuICAgICAgICBhcnJheVtEQVRFXSA9IHRvSW50KGlucHV0Lm1hdGNoKG1hdGNoMXRvMilbMF0pO1xuICAgIH0pO1xuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgdmFyIGdldFNldERheU9mTW9udGggPSBtYWtlR2V0U2V0KCdEYXRlJywgdHJ1ZSk7XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbignREREJywgWydEREREJywgM10sICdERERvJywgJ2RheU9mWWVhcicpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCdkYXlPZlllYXInLCAnREREJyk7XG5cbiAgICAvLyBQUklPUklUWVxuICAgIGFkZFVuaXRQcmlvcml0eSgnZGF5T2ZZZWFyJywgNCk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdEREQnLCBtYXRjaDF0bzMpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0REREQnLCBtYXRjaDMpO1xuICAgIGFkZFBhcnNlVG9rZW4oWydEREQnLCAnRERERCddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgY29uZmlnLl9kYXlPZlllYXIgPSB0b0ludChpbnB1dCk7XG4gICAgfSk7XG5cbiAgICAvLyBIRUxQRVJTXG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICBmdW5jdGlvbiBnZXRTZXREYXlPZlllYXIoaW5wdXQpIHtcbiAgICAgICAgdmFyIGRheU9mWWVhciA9XG4gICAgICAgICAgICBNYXRoLnJvdW5kKFxuICAgICAgICAgICAgICAgICh0aGlzLmNsb25lKCkuc3RhcnRPZignZGF5JykgLSB0aGlzLmNsb25lKCkuc3RhcnRPZigneWVhcicpKSAvIDg2NGU1XG4gICAgICAgICAgICApICsgMTtcbiAgICAgICAgcmV0dXJuIGlucHV0ID09IG51bGwgPyBkYXlPZlllYXIgOiB0aGlzLmFkZChpbnB1dCAtIGRheU9mWWVhciwgJ2QnKTtcbiAgICB9XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbignbScsIFsnbW0nLCAyXSwgMCwgJ21pbnV0ZScpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCdtaW51dGUnLCAnbScpO1xuXG4gICAgLy8gUFJJT1JJVFlcblxuICAgIGFkZFVuaXRQcmlvcml0eSgnbWludXRlJywgMTQpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignbScsIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignbW0nLCBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgYWRkUGFyc2VUb2tlbihbJ20nLCAnbW0nXSwgTUlOVVRFKTtcblxuICAgIC8vIE1PTUVOVFNcblxuICAgIHZhciBnZXRTZXRNaW51dGUgPSBtYWtlR2V0U2V0KCdNaW51dGVzJywgZmFsc2UpO1xuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ3MnLCBbJ3NzJywgMl0sIDAsICdzZWNvbmQnKTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygnc2Vjb25kJywgJ3MnKTtcblxuICAgIC8vIFBSSU9SSVRZXG5cbiAgICBhZGRVbml0UHJpb3JpdHkoJ3NlY29uZCcsIDE1KTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ3MnLCBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ3NzJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgIGFkZFBhcnNlVG9rZW4oWydzJywgJ3NzJ10sIFNFQ09ORCk7XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICB2YXIgZ2V0U2V0U2Vjb25kID0gbWFrZUdldFNldCgnU2Vjb25kcycsIGZhbHNlKTtcblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCdTJywgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gfn4odGhpcy5taWxsaXNlY29uZCgpIC8gMTAwKTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnU1MnLCAyXSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gfn4odGhpcy5taWxsaXNlY29uZCgpIC8gMTApO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTU1MnLCAzXSwgMCwgJ21pbGxpc2Vjb25kJyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTJywgNF0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmQoKSAqIDEwO1xuICAgIH0pO1xuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnU1NTU1MnLCA1XSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZCgpICogMTAwO1xuICAgIH0pO1xuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnU1NTU1NTJywgNl0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmQoKSAqIDEwMDA7XG4gICAgfSk7XG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTU1NTJywgN10sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmQoKSAqIDEwMDAwO1xuICAgIH0pO1xuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnU1NTU1NTU1MnLCA4XSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZCgpICogMTAwMDAwO1xuICAgIH0pO1xuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnU1NTU1NTU1NTJywgOV0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmQoKSAqIDEwMDAwMDA7XG4gICAgfSk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ21pbGxpc2Vjb25kJywgJ21zJyk7XG5cbiAgICAvLyBQUklPUklUWVxuXG4gICAgYWRkVW5pdFByaW9yaXR5KCdtaWxsaXNlY29uZCcsIDE2KTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ1MnLCBtYXRjaDF0bzMsIG1hdGNoMSk7XG4gICAgYWRkUmVnZXhUb2tlbignU1MnLCBtYXRjaDF0bzMsIG1hdGNoMik7XG4gICAgYWRkUmVnZXhUb2tlbignU1NTJywgbWF0Y2gxdG8zLCBtYXRjaDMpO1xuXG4gICAgdmFyIHRva2VuLCBnZXRTZXRNaWxsaXNlY29uZDtcbiAgICBmb3IgKHRva2VuID0gJ1NTU1MnOyB0b2tlbi5sZW5ndGggPD0gOTsgdG9rZW4gKz0gJ1MnKSB7XG4gICAgICAgIGFkZFJlZ2V4VG9rZW4odG9rZW4sIG1hdGNoVW5zaWduZWQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlTXMoaW5wdXQsIGFycmF5KSB7XG4gICAgICAgIGFycmF5W01JTExJU0VDT05EXSA9IHRvSW50KCgnMC4nICsgaW5wdXQpICogMTAwMCk7XG4gICAgfVxuXG4gICAgZm9yICh0b2tlbiA9ICdTJzsgdG9rZW4ubGVuZ3RoIDw9IDk7IHRva2VuICs9ICdTJykge1xuICAgICAgICBhZGRQYXJzZVRva2VuKHRva2VuLCBwYXJzZU1zKTtcbiAgICB9XG5cbiAgICBnZXRTZXRNaWxsaXNlY29uZCA9IG1ha2VHZXRTZXQoJ01pbGxpc2Vjb25kcycsIGZhbHNlKTtcblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCd6JywgMCwgMCwgJ3pvbmVBYmJyJyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oJ3p6JywgMCwgMCwgJ3pvbmVOYW1lJyk7XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICBmdW5jdGlvbiBnZXRab25lQWJicigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzVVRDID8gJ1VUQycgOiAnJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRab25lTmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzVVRDID8gJ0Nvb3JkaW5hdGVkIFVuaXZlcnNhbCBUaW1lJyA6ICcnO1xuICAgIH1cblxuICAgIHZhciBwcm90byA9IE1vbWVudC5wcm90b3R5cGU7XG5cbiAgICBwcm90by5hZGQgPSBhZGQ7XG4gICAgcHJvdG8uY2FsZW5kYXIgPSBjYWxlbmRhciQxO1xuICAgIHByb3RvLmNsb25lID0gY2xvbmU7XG4gICAgcHJvdG8uZGlmZiA9IGRpZmY7XG4gICAgcHJvdG8uZW5kT2YgPSBlbmRPZjtcbiAgICBwcm90by5mb3JtYXQgPSBmb3JtYXQ7XG4gICAgcHJvdG8uZnJvbSA9IGZyb207XG4gICAgcHJvdG8uZnJvbU5vdyA9IGZyb21Ob3c7XG4gICAgcHJvdG8udG8gPSB0bztcbiAgICBwcm90by50b05vdyA9IHRvTm93O1xuICAgIHByb3RvLmdldCA9IHN0cmluZ0dldDtcbiAgICBwcm90by5pbnZhbGlkQXQgPSBpbnZhbGlkQXQ7XG4gICAgcHJvdG8uaXNBZnRlciA9IGlzQWZ0ZXI7XG4gICAgcHJvdG8uaXNCZWZvcmUgPSBpc0JlZm9yZTtcbiAgICBwcm90by5pc0JldHdlZW4gPSBpc0JldHdlZW47XG4gICAgcHJvdG8uaXNTYW1lID0gaXNTYW1lO1xuICAgIHByb3RvLmlzU2FtZU9yQWZ0ZXIgPSBpc1NhbWVPckFmdGVyO1xuICAgIHByb3RvLmlzU2FtZU9yQmVmb3JlID0gaXNTYW1lT3JCZWZvcmU7XG4gICAgcHJvdG8uaXNWYWxpZCA9IGlzVmFsaWQkMjtcbiAgICBwcm90by5sYW5nID0gbGFuZztcbiAgICBwcm90by5sb2NhbGUgPSBsb2NhbGU7XG4gICAgcHJvdG8ubG9jYWxlRGF0YSA9IGxvY2FsZURhdGE7XG4gICAgcHJvdG8ubWF4ID0gcHJvdG90eXBlTWF4O1xuICAgIHByb3RvLm1pbiA9IHByb3RvdHlwZU1pbjtcbiAgICBwcm90by5wYXJzaW5nRmxhZ3MgPSBwYXJzaW5nRmxhZ3M7XG4gICAgcHJvdG8uc2V0ID0gc3RyaW5nU2V0O1xuICAgIHByb3RvLnN0YXJ0T2YgPSBzdGFydE9mO1xuICAgIHByb3RvLnN1YnRyYWN0ID0gc3VidHJhY3Q7XG4gICAgcHJvdG8udG9BcnJheSA9IHRvQXJyYXk7XG4gICAgcHJvdG8udG9PYmplY3QgPSB0b09iamVjdDtcbiAgICBwcm90by50b0RhdGUgPSB0b0RhdGU7XG4gICAgcHJvdG8udG9JU09TdHJpbmcgPSB0b0lTT1N0cmluZztcbiAgICBwcm90by5pbnNwZWN0ID0gaW5zcGVjdDtcbiAgICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLmZvciAhPSBudWxsKSB7XG4gICAgICAgIHByb3RvW1N5bWJvbC5mb3IoJ25vZGVqcy51dGlsLmluc3BlY3QuY3VzdG9tJyldID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICdNb21lbnQ8JyArIHRoaXMuZm9ybWF0KCkgKyAnPic7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHByb3RvLnRvSlNPTiA9IHRvSlNPTjtcbiAgICBwcm90by50b1N0cmluZyA9IHRvU3RyaW5nO1xuICAgIHByb3RvLnVuaXggPSB1bml4O1xuICAgIHByb3RvLnZhbHVlT2YgPSB2YWx1ZU9mO1xuICAgIHByb3RvLmNyZWF0aW9uRGF0YSA9IGNyZWF0aW9uRGF0YTtcbiAgICBwcm90by5lcmFOYW1lID0gZ2V0RXJhTmFtZTtcbiAgICBwcm90by5lcmFOYXJyb3cgPSBnZXRFcmFOYXJyb3c7XG4gICAgcHJvdG8uZXJhQWJiciA9IGdldEVyYUFiYnI7XG4gICAgcHJvdG8uZXJhWWVhciA9IGdldEVyYVllYXI7XG4gICAgcHJvdG8ueWVhciA9IGdldFNldFllYXI7XG4gICAgcHJvdG8uaXNMZWFwWWVhciA9IGdldElzTGVhcFllYXI7XG4gICAgcHJvdG8ud2Vla1llYXIgPSBnZXRTZXRXZWVrWWVhcjtcbiAgICBwcm90by5pc29XZWVrWWVhciA9IGdldFNldElTT1dlZWtZZWFyO1xuICAgIHByb3RvLnF1YXJ0ZXIgPSBwcm90by5xdWFydGVycyA9IGdldFNldFF1YXJ0ZXI7XG4gICAgcHJvdG8ubW9udGggPSBnZXRTZXRNb250aDtcbiAgICBwcm90by5kYXlzSW5Nb250aCA9IGdldERheXNJbk1vbnRoO1xuICAgIHByb3RvLndlZWsgPSBwcm90by53ZWVrcyA9IGdldFNldFdlZWs7XG4gICAgcHJvdG8uaXNvV2VlayA9IHByb3RvLmlzb1dlZWtzID0gZ2V0U2V0SVNPV2VlaztcbiAgICBwcm90by53ZWVrc0luWWVhciA9IGdldFdlZWtzSW5ZZWFyO1xuICAgIHByb3RvLndlZWtzSW5XZWVrWWVhciA9IGdldFdlZWtzSW5XZWVrWWVhcjtcbiAgICBwcm90by5pc29XZWVrc0luWWVhciA9IGdldElTT1dlZWtzSW5ZZWFyO1xuICAgIHByb3RvLmlzb1dlZWtzSW5JU09XZWVrWWVhciA9IGdldElTT1dlZWtzSW5JU09XZWVrWWVhcjtcbiAgICBwcm90by5kYXRlID0gZ2V0U2V0RGF5T2ZNb250aDtcbiAgICBwcm90by5kYXkgPSBwcm90by5kYXlzID0gZ2V0U2V0RGF5T2ZXZWVrO1xuICAgIHByb3RvLndlZWtkYXkgPSBnZXRTZXRMb2NhbGVEYXlPZldlZWs7XG4gICAgcHJvdG8uaXNvV2Vla2RheSA9IGdldFNldElTT0RheU9mV2VlaztcbiAgICBwcm90by5kYXlPZlllYXIgPSBnZXRTZXREYXlPZlllYXI7XG4gICAgcHJvdG8uaG91ciA9IHByb3RvLmhvdXJzID0gZ2V0U2V0SG91cjtcbiAgICBwcm90by5taW51dGUgPSBwcm90by5taW51dGVzID0gZ2V0U2V0TWludXRlO1xuICAgIHByb3RvLnNlY29uZCA9IHByb3RvLnNlY29uZHMgPSBnZXRTZXRTZWNvbmQ7XG4gICAgcHJvdG8ubWlsbGlzZWNvbmQgPSBwcm90by5taWxsaXNlY29uZHMgPSBnZXRTZXRNaWxsaXNlY29uZDtcbiAgICBwcm90by51dGNPZmZzZXQgPSBnZXRTZXRPZmZzZXQ7XG4gICAgcHJvdG8udXRjID0gc2V0T2Zmc2V0VG9VVEM7XG4gICAgcHJvdG8ubG9jYWwgPSBzZXRPZmZzZXRUb0xvY2FsO1xuICAgIHByb3RvLnBhcnNlWm9uZSA9IHNldE9mZnNldFRvUGFyc2VkT2Zmc2V0O1xuICAgIHByb3RvLmhhc0FsaWduZWRIb3VyT2Zmc2V0ID0gaGFzQWxpZ25lZEhvdXJPZmZzZXQ7XG4gICAgcHJvdG8uaXNEU1QgPSBpc0RheWxpZ2h0U2F2aW5nVGltZTtcbiAgICBwcm90by5pc0xvY2FsID0gaXNMb2NhbDtcbiAgICBwcm90by5pc1V0Y09mZnNldCA9IGlzVXRjT2Zmc2V0O1xuICAgIHByb3RvLmlzVXRjID0gaXNVdGM7XG4gICAgcHJvdG8uaXNVVEMgPSBpc1V0YztcbiAgICBwcm90by56b25lQWJiciA9IGdldFpvbmVBYmJyO1xuICAgIHByb3RvLnpvbmVOYW1lID0gZ2V0Wm9uZU5hbWU7XG4gICAgcHJvdG8uZGF0ZXMgPSBkZXByZWNhdGUoXG4gICAgICAgICdkYXRlcyBhY2Nlc3NvciBpcyBkZXByZWNhdGVkLiBVc2UgZGF0ZSBpbnN0ZWFkLicsXG4gICAgICAgIGdldFNldERheU9mTW9udGhcbiAgICApO1xuICAgIHByb3RvLm1vbnRocyA9IGRlcHJlY2F0ZShcbiAgICAgICAgJ21vbnRocyBhY2Nlc3NvciBpcyBkZXByZWNhdGVkLiBVc2UgbW9udGggaW5zdGVhZCcsXG4gICAgICAgIGdldFNldE1vbnRoXG4gICAgKTtcbiAgICBwcm90by55ZWFycyA9IGRlcHJlY2F0ZShcbiAgICAgICAgJ3llYXJzIGFjY2Vzc29yIGlzIGRlcHJlY2F0ZWQuIFVzZSB5ZWFyIGluc3RlYWQnLFxuICAgICAgICBnZXRTZXRZZWFyXG4gICAgKTtcbiAgICBwcm90by56b25lID0gZGVwcmVjYXRlKFxuICAgICAgICAnbW9tZW50KCkuem9uZSBpcyBkZXByZWNhdGVkLCB1c2UgbW9tZW50KCkudXRjT2Zmc2V0IGluc3RlYWQuIGh0dHA6Ly9tb21lbnRqcy5jb20vZ3VpZGVzLyMvd2FybmluZ3Mvem9uZS8nLFxuICAgICAgICBnZXRTZXRab25lXG4gICAgKTtcbiAgICBwcm90by5pc0RTVFNoaWZ0ZWQgPSBkZXByZWNhdGUoXG4gICAgICAgICdpc0RTVFNoaWZ0ZWQgaXMgZGVwcmVjYXRlZC4gU2VlIGh0dHA6Ly9tb21lbnRqcy5jb20vZ3VpZGVzLyMvd2FybmluZ3MvZHN0LXNoaWZ0ZWQvIGZvciBtb3JlIGluZm9ybWF0aW9uJyxcbiAgICAgICAgaXNEYXlsaWdodFNhdmluZ1RpbWVTaGlmdGVkXG4gICAgKTtcblxuICAgIGZ1bmN0aW9uIGNyZWF0ZVVuaXgoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUxvY2FsKGlucHV0ICogMTAwMCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlSW5ab25lKCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlTG9jYWwuYXBwbHkobnVsbCwgYXJndW1lbnRzKS5wYXJzZVpvbmUoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcmVQYXJzZVBvc3RGb3JtYXQoc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgfVxuXG4gICAgdmFyIHByb3RvJDEgPSBMb2NhbGUucHJvdG90eXBlO1xuXG4gICAgcHJvdG8kMS5jYWxlbmRhciA9IGNhbGVuZGFyO1xuICAgIHByb3RvJDEubG9uZ0RhdGVGb3JtYXQgPSBsb25nRGF0ZUZvcm1hdDtcbiAgICBwcm90byQxLmludmFsaWREYXRlID0gaW52YWxpZERhdGU7XG4gICAgcHJvdG8kMS5vcmRpbmFsID0gb3JkaW5hbDtcbiAgICBwcm90byQxLnByZXBhcnNlID0gcHJlUGFyc2VQb3N0Rm9ybWF0O1xuICAgIHByb3RvJDEucG9zdGZvcm1hdCA9IHByZVBhcnNlUG9zdEZvcm1hdDtcbiAgICBwcm90byQxLnJlbGF0aXZlVGltZSA9IHJlbGF0aXZlVGltZTtcbiAgICBwcm90byQxLnBhc3RGdXR1cmUgPSBwYXN0RnV0dXJlO1xuICAgIHByb3RvJDEuc2V0ID0gc2V0O1xuICAgIHByb3RvJDEuZXJhcyA9IGxvY2FsZUVyYXM7XG4gICAgcHJvdG8kMS5lcmFzUGFyc2UgPSBsb2NhbGVFcmFzUGFyc2U7XG4gICAgcHJvdG8kMS5lcmFzQ29udmVydFllYXIgPSBsb2NhbGVFcmFzQ29udmVydFllYXI7XG4gICAgcHJvdG8kMS5lcmFzQWJiclJlZ2V4ID0gZXJhc0FiYnJSZWdleDtcbiAgICBwcm90byQxLmVyYXNOYW1lUmVnZXggPSBlcmFzTmFtZVJlZ2V4O1xuICAgIHByb3RvJDEuZXJhc05hcnJvd1JlZ2V4ID0gZXJhc05hcnJvd1JlZ2V4O1xuXG4gICAgcHJvdG8kMS5tb250aHMgPSBsb2NhbGVNb250aHM7XG4gICAgcHJvdG8kMS5tb250aHNTaG9ydCA9IGxvY2FsZU1vbnRoc1Nob3J0O1xuICAgIHByb3RvJDEubW9udGhzUGFyc2UgPSBsb2NhbGVNb250aHNQYXJzZTtcbiAgICBwcm90byQxLm1vbnRoc1JlZ2V4ID0gbW9udGhzUmVnZXg7XG4gICAgcHJvdG8kMS5tb250aHNTaG9ydFJlZ2V4ID0gbW9udGhzU2hvcnRSZWdleDtcbiAgICBwcm90byQxLndlZWsgPSBsb2NhbGVXZWVrO1xuICAgIHByb3RvJDEuZmlyc3REYXlPZlllYXIgPSBsb2NhbGVGaXJzdERheU9mWWVhcjtcbiAgICBwcm90byQxLmZpcnN0RGF5T2ZXZWVrID0gbG9jYWxlRmlyc3REYXlPZldlZWs7XG5cbiAgICBwcm90byQxLndlZWtkYXlzID0gbG9jYWxlV2Vla2RheXM7XG4gICAgcHJvdG8kMS53ZWVrZGF5c01pbiA9IGxvY2FsZVdlZWtkYXlzTWluO1xuICAgIHByb3RvJDEud2Vla2RheXNTaG9ydCA9IGxvY2FsZVdlZWtkYXlzU2hvcnQ7XG4gICAgcHJvdG8kMS53ZWVrZGF5c1BhcnNlID0gbG9jYWxlV2Vla2RheXNQYXJzZTtcblxuICAgIHByb3RvJDEud2Vla2RheXNSZWdleCA9IHdlZWtkYXlzUmVnZXg7XG4gICAgcHJvdG8kMS53ZWVrZGF5c1Nob3J0UmVnZXggPSB3ZWVrZGF5c1Nob3J0UmVnZXg7XG4gICAgcHJvdG8kMS53ZWVrZGF5c01pblJlZ2V4ID0gd2Vla2RheXNNaW5SZWdleDtcblxuICAgIHByb3RvJDEuaXNQTSA9IGxvY2FsZUlzUE07XG4gICAgcHJvdG8kMS5tZXJpZGllbSA9IGxvY2FsZU1lcmlkaWVtO1xuXG4gICAgZnVuY3Rpb24gZ2V0JDEoZm9ybWF0LCBpbmRleCwgZmllbGQsIHNldHRlcikge1xuICAgICAgICB2YXIgbG9jYWxlID0gZ2V0TG9jYWxlKCksXG4gICAgICAgICAgICB1dGMgPSBjcmVhdGVVVEMoKS5zZXQoc2V0dGVyLCBpbmRleCk7XG4gICAgICAgIHJldHVybiBsb2NhbGVbZmllbGRdKHV0YywgZm9ybWF0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaXN0TW9udGhzSW1wbChmb3JtYXQsIGluZGV4LCBmaWVsZCkge1xuICAgICAgICBpZiAoaXNOdW1iZXIoZm9ybWF0KSkge1xuICAgICAgICAgICAgaW5kZXggPSBmb3JtYXQ7XG4gICAgICAgICAgICBmb3JtYXQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBmb3JtYXQgPSBmb3JtYXQgfHwgJyc7XG5cbiAgICAgICAgaWYgKGluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXQkMShmb3JtYXQsIGluZGV4LCBmaWVsZCwgJ21vbnRoJyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgIG91dCA9IFtdO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMTI7IGkrKykge1xuICAgICAgICAgICAgb3V0W2ldID0gZ2V0JDEoZm9ybWF0LCBpLCBmaWVsZCwgJ21vbnRoJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG5cbiAgICAvLyAoKVxuICAgIC8vICg1KVxuICAgIC8vIChmbXQsIDUpXG4gICAgLy8gKGZtdClcbiAgICAvLyAodHJ1ZSlcbiAgICAvLyAodHJ1ZSwgNSlcbiAgICAvLyAodHJ1ZSwgZm10LCA1KVxuICAgIC8vICh0cnVlLCBmbXQpXG4gICAgZnVuY3Rpb24gbGlzdFdlZWtkYXlzSW1wbChsb2NhbGVTb3J0ZWQsIGZvcm1hdCwgaW5kZXgsIGZpZWxkKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbG9jYWxlU29ydGVkID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgIGlmIChpc051bWJlcihmb3JtYXQpKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBmb3JtYXQ7XG4gICAgICAgICAgICAgICAgZm9ybWF0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3JtYXQgPSBmb3JtYXQgfHwgJyc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3JtYXQgPSBsb2NhbGVTb3J0ZWQ7XG4gICAgICAgICAgICBpbmRleCA9IGZvcm1hdDtcbiAgICAgICAgICAgIGxvY2FsZVNvcnRlZCA9IGZhbHNlO1xuXG4gICAgICAgICAgICBpZiAoaXNOdW1iZXIoZm9ybWF0KSkge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gZm9ybWF0O1xuICAgICAgICAgICAgICAgIGZvcm1hdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9ybWF0ID0gZm9ybWF0IHx8ICcnO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxvY2FsZSA9IGdldExvY2FsZSgpLFxuICAgICAgICAgICAgc2hpZnQgPSBsb2NhbGVTb3J0ZWQgPyBsb2NhbGUuX3dlZWsuZG93IDogMCxcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICBvdXQgPSBbXTtcblxuICAgICAgICBpZiAoaW5kZXggIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGdldCQxKGZvcm1hdCwgKGluZGV4ICsgc2hpZnQpICUgNywgZmllbGQsICdkYXknKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCA3OyBpKyspIHtcbiAgICAgICAgICAgIG91dFtpXSA9IGdldCQxKGZvcm1hdCwgKGkgKyBzaGlmdCkgJSA3LCBmaWVsZCwgJ2RheScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGlzdE1vbnRocyhmb3JtYXQsIGluZGV4KSB7XG4gICAgICAgIHJldHVybiBsaXN0TW9udGhzSW1wbChmb3JtYXQsIGluZGV4LCAnbW9udGhzJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGlzdE1vbnRoc1Nob3J0KGZvcm1hdCwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGxpc3RNb250aHNJbXBsKGZvcm1hdCwgaW5kZXgsICdtb250aHNTaG9ydCcpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpc3RXZWVrZGF5cyhsb2NhbGVTb3J0ZWQsIGZvcm1hdCwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGxpc3RXZWVrZGF5c0ltcGwobG9jYWxlU29ydGVkLCBmb3JtYXQsIGluZGV4LCAnd2Vla2RheXMnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaXN0V2Vla2RheXNTaG9ydChsb2NhbGVTb3J0ZWQsIGZvcm1hdCwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGxpc3RXZWVrZGF5c0ltcGwobG9jYWxlU29ydGVkLCBmb3JtYXQsIGluZGV4LCAnd2Vla2RheXNTaG9ydCcpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpc3RXZWVrZGF5c01pbihsb2NhbGVTb3J0ZWQsIGZvcm1hdCwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGxpc3RXZWVrZGF5c0ltcGwobG9jYWxlU29ydGVkLCBmb3JtYXQsIGluZGV4LCAnd2Vla2RheXNNaW4nKTtcbiAgICB9XG5cbiAgICBnZXRTZXRHbG9iYWxMb2NhbGUoJ2VuJywge1xuICAgICAgICBlcmFzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc2luY2U6ICcwMDAxLTAxLTAxJyxcbiAgICAgICAgICAgICAgICB1bnRpbDogK0luZmluaXR5LFxuICAgICAgICAgICAgICAgIG9mZnNldDogMSxcbiAgICAgICAgICAgICAgICBuYW1lOiAnQW5ubyBEb21pbmknLFxuICAgICAgICAgICAgICAgIG5hcnJvdzogJ0FEJyxcbiAgICAgICAgICAgICAgICBhYmJyOiAnQUQnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzaW5jZTogJzAwMDAtMTItMzEnLFxuICAgICAgICAgICAgICAgIHVudGlsOiAtSW5maW5pdHksXG4gICAgICAgICAgICAgICAgb2Zmc2V0OiAxLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdCZWZvcmUgQ2hyaXN0JyxcbiAgICAgICAgICAgICAgICBuYXJyb3c6ICdCQycsXG4gICAgICAgICAgICAgICAgYWJicjogJ0JDJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0sXG4gICAgICAgIGRheU9mTW9udGhPcmRpbmFsUGFyc2U6IC9cXGR7MSwyfSh0aHxzdHxuZHxyZCkvLFxuICAgICAgICBvcmRpbmFsOiBmdW5jdGlvbiAobnVtYmVyKSB7XG4gICAgICAgICAgICB2YXIgYiA9IG51bWJlciAlIDEwLFxuICAgICAgICAgICAgICAgIG91dHB1dCA9XG4gICAgICAgICAgICAgICAgICAgIHRvSW50KChudW1iZXIgJSAxMDApIC8gMTApID09PSAxXG4gICAgICAgICAgICAgICAgICAgICAgICA/ICd0aCdcbiAgICAgICAgICAgICAgICAgICAgICAgIDogYiA9PT0gMVxuICAgICAgICAgICAgICAgICAgICAgICAgPyAnc3QnXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGIgPT09IDJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gJ25kJ1xuICAgICAgICAgICAgICAgICAgICAgICAgOiBiID09PSAzXG4gICAgICAgICAgICAgICAgICAgICAgICA/ICdyZCdcbiAgICAgICAgICAgICAgICAgICAgICAgIDogJ3RoJztcbiAgICAgICAgICAgIHJldHVybiBudW1iZXIgKyBvdXRwdXQ7XG4gICAgICAgIH0sXG4gICAgfSk7XG5cbiAgICAvLyBTaWRlIGVmZmVjdCBpbXBvcnRzXG5cbiAgICBob29rcy5sYW5nID0gZGVwcmVjYXRlKFxuICAgICAgICAnbW9tZW50LmxhbmcgaXMgZGVwcmVjYXRlZC4gVXNlIG1vbWVudC5sb2NhbGUgaW5zdGVhZC4nLFxuICAgICAgICBnZXRTZXRHbG9iYWxMb2NhbGVcbiAgICApO1xuICAgIGhvb2tzLmxhbmdEYXRhID0gZGVwcmVjYXRlKFxuICAgICAgICAnbW9tZW50LmxhbmdEYXRhIGlzIGRlcHJlY2F0ZWQuIFVzZSBtb21lbnQubG9jYWxlRGF0YSBpbnN0ZWFkLicsXG4gICAgICAgIGdldExvY2FsZVxuICAgICk7XG5cbiAgICB2YXIgbWF0aEFicyA9IE1hdGguYWJzO1xuXG4gICAgZnVuY3Rpb24gYWJzKCkge1xuICAgICAgICB2YXIgZGF0YSA9IHRoaXMuX2RhdGE7XG5cbiAgICAgICAgdGhpcy5fbWlsbGlzZWNvbmRzID0gbWF0aEFicyh0aGlzLl9taWxsaXNlY29uZHMpO1xuICAgICAgICB0aGlzLl9kYXlzID0gbWF0aEFicyh0aGlzLl9kYXlzKTtcbiAgICAgICAgdGhpcy5fbW9udGhzID0gbWF0aEFicyh0aGlzLl9tb250aHMpO1xuXG4gICAgICAgIGRhdGEubWlsbGlzZWNvbmRzID0gbWF0aEFicyhkYXRhLm1pbGxpc2Vjb25kcyk7XG4gICAgICAgIGRhdGEuc2Vjb25kcyA9IG1hdGhBYnMoZGF0YS5zZWNvbmRzKTtcbiAgICAgICAgZGF0YS5taW51dGVzID0gbWF0aEFicyhkYXRhLm1pbnV0ZXMpO1xuICAgICAgICBkYXRhLmhvdXJzID0gbWF0aEFicyhkYXRhLmhvdXJzKTtcbiAgICAgICAgZGF0YS5tb250aHMgPSBtYXRoQWJzKGRhdGEubW9udGhzKTtcbiAgICAgICAgZGF0YS55ZWFycyA9IG1hdGhBYnMoZGF0YS55ZWFycyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkU3VidHJhY3QkMShkdXJhdGlvbiwgaW5wdXQsIHZhbHVlLCBkaXJlY3Rpb24pIHtcbiAgICAgICAgdmFyIG90aGVyID0gY3JlYXRlRHVyYXRpb24oaW5wdXQsIHZhbHVlKTtcblxuICAgICAgICBkdXJhdGlvbi5fbWlsbGlzZWNvbmRzICs9IGRpcmVjdGlvbiAqIG90aGVyLl9taWxsaXNlY29uZHM7XG4gICAgICAgIGR1cmF0aW9uLl9kYXlzICs9IGRpcmVjdGlvbiAqIG90aGVyLl9kYXlzO1xuICAgICAgICBkdXJhdGlvbi5fbW9udGhzICs9IGRpcmVjdGlvbiAqIG90aGVyLl9tb250aHM7XG5cbiAgICAgICAgcmV0dXJuIGR1cmF0aW9uLl9idWJibGUoKTtcbiAgICB9XG5cbiAgICAvLyBzdXBwb3J0cyBvbmx5IDIuMC1zdHlsZSBhZGQoMSwgJ3MnKSBvciBhZGQoZHVyYXRpb24pXG4gICAgZnVuY3Rpb24gYWRkJDEoaW5wdXQsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBhZGRTdWJ0cmFjdCQxKHRoaXMsIGlucHV0LCB2YWx1ZSwgMSk7XG4gICAgfVxuXG4gICAgLy8gc3VwcG9ydHMgb25seSAyLjAtc3R5bGUgc3VidHJhY3QoMSwgJ3MnKSBvciBzdWJ0cmFjdChkdXJhdGlvbilcbiAgICBmdW5jdGlvbiBzdWJ0cmFjdCQxKGlucHV0LCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gYWRkU3VidHJhY3QkMSh0aGlzLCBpbnB1dCwgdmFsdWUsIC0xKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhYnNDZWlsKG51bWJlcikge1xuICAgICAgICBpZiAobnVtYmVyIDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IobnVtYmVyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmNlaWwobnVtYmVyKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGJ1YmJsZSgpIHtcbiAgICAgICAgdmFyIG1pbGxpc2Vjb25kcyA9IHRoaXMuX21pbGxpc2Vjb25kcyxcbiAgICAgICAgICAgIGRheXMgPSB0aGlzLl9kYXlzLFxuICAgICAgICAgICAgbW9udGhzID0gdGhpcy5fbW9udGhzLFxuICAgICAgICAgICAgZGF0YSA9IHRoaXMuX2RhdGEsXG4gICAgICAgICAgICBzZWNvbmRzLFxuICAgICAgICAgICAgbWludXRlcyxcbiAgICAgICAgICAgIGhvdXJzLFxuICAgICAgICAgICAgeWVhcnMsXG4gICAgICAgICAgICBtb250aHNGcm9tRGF5cztcblxuICAgICAgICAvLyBpZiB3ZSBoYXZlIGEgbWl4IG9mIHBvc2l0aXZlIGFuZCBuZWdhdGl2ZSB2YWx1ZXMsIGJ1YmJsZSBkb3duIGZpcnN0XG4gICAgICAgIC8vIGNoZWNrOiBodHRwczovL2dpdGh1Yi5jb20vbW9tZW50L21vbWVudC9pc3N1ZXMvMjE2NlxuICAgICAgICBpZiAoXG4gICAgICAgICAgICAhKFxuICAgICAgICAgICAgICAgIChtaWxsaXNlY29uZHMgPj0gMCAmJiBkYXlzID49IDAgJiYgbW9udGhzID49IDApIHx8XG4gICAgICAgICAgICAgICAgKG1pbGxpc2Vjb25kcyA8PSAwICYmIGRheXMgPD0gMCAmJiBtb250aHMgPD0gMClcbiAgICAgICAgICAgIClcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBtaWxsaXNlY29uZHMgKz0gYWJzQ2VpbChtb250aHNUb0RheXMobW9udGhzKSArIGRheXMpICogODY0ZTU7XG4gICAgICAgICAgICBkYXlzID0gMDtcbiAgICAgICAgICAgIG1vbnRocyA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUaGUgZm9sbG93aW5nIGNvZGUgYnViYmxlcyB1cCB2YWx1ZXMsIHNlZSB0aGUgdGVzdHMgZm9yXG4gICAgICAgIC8vIGV4YW1wbGVzIG9mIHdoYXQgdGhhdCBtZWFucy5cbiAgICAgICAgZGF0YS5taWxsaXNlY29uZHMgPSBtaWxsaXNlY29uZHMgJSAxMDAwO1xuXG4gICAgICAgIHNlY29uZHMgPSBhYnNGbG9vcihtaWxsaXNlY29uZHMgLyAxMDAwKTtcbiAgICAgICAgZGF0YS5zZWNvbmRzID0gc2Vjb25kcyAlIDYwO1xuXG4gICAgICAgIG1pbnV0ZXMgPSBhYnNGbG9vcihzZWNvbmRzIC8gNjApO1xuICAgICAgICBkYXRhLm1pbnV0ZXMgPSBtaW51dGVzICUgNjA7XG5cbiAgICAgICAgaG91cnMgPSBhYnNGbG9vcihtaW51dGVzIC8gNjApO1xuICAgICAgICBkYXRhLmhvdXJzID0gaG91cnMgJSAyNDtcblxuICAgICAgICBkYXlzICs9IGFic0Zsb29yKGhvdXJzIC8gMjQpO1xuXG4gICAgICAgIC8vIGNvbnZlcnQgZGF5cyB0byBtb250aHNcbiAgICAgICAgbW9udGhzRnJvbURheXMgPSBhYnNGbG9vcihkYXlzVG9Nb250aHMoZGF5cykpO1xuICAgICAgICBtb250aHMgKz0gbW9udGhzRnJvbURheXM7XG4gICAgICAgIGRheXMgLT0gYWJzQ2VpbChtb250aHNUb0RheXMobW9udGhzRnJvbURheXMpKTtcblxuICAgICAgICAvLyAxMiBtb250aHMgLT4gMSB5ZWFyXG4gICAgICAgIHllYXJzID0gYWJzRmxvb3IobW9udGhzIC8gMTIpO1xuICAgICAgICBtb250aHMgJT0gMTI7XG5cbiAgICAgICAgZGF0YS5kYXlzID0gZGF5cztcbiAgICAgICAgZGF0YS5tb250aHMgPSBtb250aHM7XG4gICAgICAgIGRhdGEueWVhcnMgPSB5ZWFycztcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkYXlzVG9Nb250aHMoZGF5cykge1xuICAgICAgICAvLyA0MDAgeWVhcnMgaGF2ZSAxNDYwOTcgZGF5cyAodGFraW5nIGludG8gYWNjb3VudCBsZWFwIHllYXIgcnVsZXMpXG4gICAgICAgIC8vIDQwMCB5ZWFycyBoYXZlIDEyIG1vbnRocyA9PT0gNDgwMFxuICAgICAgICByZXR1cm4gKGRheXMgKiA0ODAwKSAvIDE0NjA5NztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtb250aHNUb0RheXMobW9udGhzKSB7XG4gICAgICAgIC8vIHRoZSByZXZlcnNlIG9mIGRheXNUb01vbnRoc1xuICAgICAgICByZXR1cm4gKG1vbnRocyAqIDE0NjA5NykgLyA0ODAwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFzKHVuaXRzKSB7XG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBOYU47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRheXMsXG4gICAgICAgICAgICBtb250aHMsXG4gICAgICAgICAgICBtaWxsaXNlY29uZHMgPSB0aGlzLl9taWxsaXNlY29uZHM7XG5cbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG5cbiAgICAgICAgaWYgKHVuaXRzID09PSAnbW9udGgnIHx8IHVuaXRzID09PSAncXVhcnRlcicgfHwgdW5pdHMgPT09ICd5ZWFyJykge1xuICAgICAgICAgICAgZGF5cyA9IHRoaXMuX2RheXMgKyBtaWxsaXNlY29uZHMgLyA4NjRlNTtcbiAgICAgICAgICAgIG1vbnRocyA9IHRoaXMuX21vbnRocyArIGRheXNUb01vbnRocyhkYXlzKTtcbiAgICAgICAgICAgIHN3aXRjaCAodW5pdHMpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdtb250aCc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtb250aHM7XG4gICAgICAgICAgICAgICAgY2FzZSAncXVhcnRlcic6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtb250aHMgLyAzO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3llYXInOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbW9udGhzIC8gMTI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBoYW5kbGUgbWlsbGlzZWNvbmRzIHNlcGFyYXRlbHkgYmVjYXVzZSBvZiBmbG9hdGluZyBwb2ludCBtYXRoIGVycm9ycyAoaXNzdWUgIzE4NjcpXG4gICAgICAgICAgICBkYXlzID0gdGhpcy5fZGF5cyArIE1hdGgucm91bmQobW9udGhzVG9EYXlzKHRoaXMuX21vbnRocykpO1xuICAgICAgICAgICAgc3dpdGNoICh1bml0cykge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3dlZWsnOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF5cyAvIDcgKyBtaWxsaXNlY29uZHMgLyA2MDQ4ZTU7XG4gICAgICAgICAgICAgICAgY2FzZSAnZGF5JzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRheXMgKyBtaWxsaXNlY29uZHMgLyA4NjRlNTtcbiAgICAgICAgICAgICAgICBjYXNlICdob3VyJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRheXMgKiAyNCArIG1pbGxpc2Vjb25kcyAvIDM2ZTU7XG4gICAgICAgICAgICAgICAgY2FzZSAnbWludXRlJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRheXMgKiAxNDQwICsgbWlsbGlzZWNvbmRzIC8gNmU0O1xuICAgICAgICAgICAgICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXlzICogODY0MDAgKyBtaWxsaXNlY29uZHMgLyAxMDAwO1xuICAgICAgICAgICAgICAgIC8vIE1hdGguZmxvb3IgcHJldmVudHMgZmxvYXRpbmcgcG9pbnQgbWF0aCBlcnJvcnMgaGVyZVxuICAgICAgICAgICAgICAgIGNhc2UgJ21pbGxpc2Vjb25kJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IoZGF5cyAqIDg2NGU1KSArIG1pbGxpc2Vjb25kcztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gdW5pdCAnICsgdW5pdHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gVE9ETzogVXNlIHRoaXMuYXMoJ21zJyk/XG4gICAgZnVuY3Rpb24gdmFsdWVPZiQxKCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICB0aGlzLl9taWxsaXNlY29uZHMgK1xuICAgICAgICAgICAgdGhpcy5fZGF5cyAqIDg2NGU1ICtcbiAgICAgICAgICAgICh0aGlzLl9tb250aHMgJSAxMikgKiAyNTkyZTYgK1xuICAgICAgICAgICAgdG9JbnQodGhpcy5fbW9udGhzIC8gMTIpICogMzE1MzZlNlxuICAgICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1ha2VBcyhhbGlhcykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXMoYWxpYXMpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHZhciBhc01pbGxpc2Vjb25kcyA9IG1ha2VBcygnbXMnKSxcbiAgICAgICAgYXNTZWNvbmRzID0gbWFrZUFzKCdzJyksXG4gICAgICAgIGFzTWludXRlcyA9IG1ha2VBcygnbScpLFxuICAgICAgICBhc0hvdXJzID0gbWFrZUFzKCdoJyksXG4gICAgICAgIGFzRGF5cyA9IG1ha2VBcygnZCcpLFxuICAgICAgICBhc1dlZWtzID0gbWFrZUFzKCd3JyksXG4gICAgICAgIGFzTW9udGhzID0gbWFrZUFzKCdNJyksXG4gICAgICAgIGFzUXVhcnRlcnMgPSBtYWtlQXMoJ1EnKSxcbiAgICAgICAgYXNZZWFycyA9IG1ha2VBcygneScpO1xuXG4gICAgZnVuY3Rpb24gY2xvbmUkMSgpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUR1cmF0aW9uKHRoaXMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldCQyKHVuaXRzKSB7XG4gICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xuICAgICAgICByZXR1cm4gdGhpcy5pc1ZhbGlkKCkgPyB0aGlzW3VuaXRzICsgJ3MnXSgpIDogTmFOO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1ha2VHZXR0ZXIobmFtZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXNWYWxpZCgpID8gdGhpcy5fZGF0YVtuYW1lXSA6IE5hTjtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgbWlsbGlzZWNvbmRzID0gbWFrZUdldHRlcignbWlsbGlzZWNvbmRzJyksXG4gICAgICAgIHNlY29uZHMgPSBtYWtlR2V0dGVyKCdzZWNvbmRzJyksXG4gICAgICAgIG1pbnV0ZXMgPSBtYWtlR2V0dGVyKCdtaW51dGVzJyksXG4gICAgICAgIGhvdXJzID0gbWFrZUdldHRlcignaG91cnMnKSxcbiAgICAgICAgZGF5cyA9IG1ha2VHZXR0ZXIoJ2RheXMnKSxcbiAgICAgICAgbW9udGhzID0gbWFrZUdldHRlcignbW9udGhzJyksXG4gICAgICAgIHllYXJzID0gbWFrZUdldHRlcigneWVhcnMnKTtcblxuICAgIGZ1bmN0aW9uIHdlZWtzKCkge1xuICAgICAgICByZXR1cm4gYWJzRmxvb3IodGhpcy5kYXlzKCkgLyA3KTtcbiAgICB9XG5cbiAgICB2YXIgcm91bmQgPSBNYXRoLnJvdW5kLFxuICAgICAgICB0aHJlc2hvbGRzID0ge1xuICAgICAgICAgICAgc3M6IDQ0LCAvLyBhIGZldyBzZWNvbmRzIHRvIHNlY29uZHNcbiAgICAgICAgICAgIHM6IDQ1LCAvLyBzZWNvbmRzIHRvIG1pbnV0ZVxuICAgICAgICAgICAgbTogNDUsIC8vIG1pbnV0ZXMgdG8gaG91clxuICAgICAgICAgICAgaDogMjIsIC8vIGhvdXJzIHRvIGRheVxuICAgICAgICAgICAgZDogMjYsIC8vIGRheXMgdG8gbW9udGgvd2Vla1xuICAgICAgICAgICAgdzogbnVsbCwgLy8gd2Vla3MgdG8gbW9udGhcbiAgICAgICAgICAgIE06IDExLCAvLyBtb250aHMgdG8geWVhclxuICAgICAgICB9O1xuXG4gICAgLy8gaGVscGVyIGZ1bmN0aW9uIGZvciBtb21lbnQuZm4uZnJvbSwgbW9tZW50LmZuLmZyb21Ob3csIGFuZCBtb21lbnQuZHVyYXRpb24uZm4uaHVtYW5pemVcbiAgICBmdW5jdGlvbiBzdWJzdGl0dXRlVGltZUFnbyhzdHJpbmcsIG51bWJlciwgd2l0aG91dFN1ZmZpeCwgaXNGdXR1cmUsIGxvY2FsZSkge1xuICAgICAgICByZXR1cm4gbG9jYWxlLnJlbGF0aXZlVGltZShudW1iZXIgfHwgMSwgISF3aXRob3V0U3VmZml4LCBzdHJpbmcsIGlzRnV0dXJlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZWxhdGl2ZVRpbWUkMShwb3NOZWdEdXJhdGlvbiwgd2l0aG91dFN1ZmZpeCwgdGhyZXNob2xkcywgbG9jYWxlKSB7XG4gICAgICAgIHZhciBkdXJhdGlvbiA9IGNyZWF0ZUR1cmF0aW9uKHBvc05lZ0R1cmF0aW9uKS5hYnMoKSxcbiAgICAgICAgICAgIHNlY29uZHMgPSByb3VuZChkdXJhdGlvbi5hcygncycpKSxcbiAgICAgICAgICAgIG1pbnV0ZXMgPSByb3VuZChkdXJhdGlvbi5hcygnbScpKSxcbiAgICAgICAgICAgIGhvdXJzID0gcm91bmQoZHVyYXRpb24uYXMoJ2gnKSksXG4gICAgICAgICAgICBkYXlzID0gcm91bmQoZHVyYXRpb24uYXMoJ2QnKSksXG4gICAgICAgICAgICBtb250aHMgPSByb3VuZChkdXJhdGlvbi5hcygnTScpKSxcbiAgICAgICAgICAgIHdlZWtzID0gcm91bmQoZHVyYXRpb24uYXMoJ3cnKSksXG4gICAgICAgICAgICB5ZWFycyA9IHJvdW5kKGR1cmF0aW9uLmFzKCd5JykpLFxuICAgICAgICAgICAgYSA9XG4gICAgICAgICAgICAgICAgKHNlY29uZHMgPD0gdGhyZXNob2xkcy5zcyAmJiBbJ3MnLCBzZWNvbmRzXSkgfHxcbiAgICAgICAgICAgICAgICAoc2Vjb25kcyA8IHRocmVzaG9sZHMucyAmJiBbJ3NzJywgc2Vjb25kc10pIHx8XG4gICAgICAgICAgICAgICAgKG1pbnV0ZXMgPD0gMSAmJiBbJ20nXSkgfHxcbiAgICAgICAgICAgICAgICAobWludXRlcyA8IHRocmVzaG9sZHMubSAmJiBbJ21tJywgbWludXRlc10pIHx8XG4gICAgICAgICAgICAgICAgKGhvdXJzIDw9IDEgJiYgWydoJ10pIHx8XG4gICAgICAgICAgICAgICAgKGhvdXJzIDwgdGhyZXNob2xkcy5oICYmIFsnaGgnLCBob3Vyc10pIHx8XG4gICAgICAgICAgICAgICAgKGRheXMgPD0gMSAmJiBbJ2QnXSkgfHxcbiAgICAgICAgICAgICAgICAoZGF5cyA8IHRocmVzaG9sZHMuZCAmJiBbJ2RkJywgZGF5c10pO1xuXG4gICAgICAgIGlmICh0aHJlc2hvbGRzLncgIT0gbnVsbCkge1xuICAgICAgICAgICAgYSA9XG4gICAgICAgICAgICAgICAgYSB8fFxuICAgICAgICAgICAgICAgICh3ZWVrcyA8PSAxICYmIFsndyddKSB8fFxuICAgICAgICAgICAgICAgICh3ZWVrcyA8IHRocmVzaG9sZHMudyAmJiBbJ3d3Jywgd2Vla3NdKTtcbiAgICAgICAgfVxuICAgICAgICBhID0gYSB8fFxuICAgICAgICAgICAgKG1vbnRocyA8PSAxICYmIFsnTSddKSB8fFxuICAgICAgICAgICAgKG1vbnRocyA8IHRocmVzaG9sZHMuTSAmJiBbJ01NJywgbW9udGhzXSkgfHxcbiAgICAgICAgICAgICh5ZWFycyA8PSAxICYmIFsneSddKSB8fCBbJ3l5JywgeWVhcnNdO1xuXG4gICAgICAgIGFbMl0gPSB3aXRob3V0U3VmZml4O1xuICAgICAgICBhWzNdID0gK3Bvc05lZ0R1cmF0aW9uID4gMDtcbiAgICAgICAgYVs0XSA9IGxvY2FsZTtcbiAgICAgICAgcmV0dXJuIHN1YnN0aXR1dGVUaW1lQWdvLmFwcGx5KG51bGwsIGEpO1xuICAgIH1cblxuICAgIC8vIFRoaXMgZnVuY3Rpb24gYWxsb3dzIHlvdSB0byBzZXQgdGhlIHJvdW5kaW5nIGZ1bmN0aW9uIGZvciByZWxhdGl2ZSB0aW1lIHN0cmluZ3NcbiAgICBmdW5jdGlvbiBnZXRTZXRSZWxhdGl2ZVRpbWVSb3VuZGluZyhyb3VuZGluZ0Z1bmN0aW9uKSB7XG4gICAgICAgIGlmIChyb3VuZGluZ0Z1bmN0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiByb3VuZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHJvdW5kaW5nRnVuY3Rpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJvdW5kID0gcm91bmRpbmdGdW5jdGlvbjtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBUaGlzIGZ1bmN0aW9uIGFsbG93cyB5b3UgdG8gc2V0IGEgdGhyZXNob2xkIGZvciByZWxhdGl2ZSB0aW1lIHN0cmluZ3NcbiAgICBmdW5jdGlvbiBnZXRTZXRSZWxhdGl2ZVRpbWVUaHJlc2hvbGQodGhyZXNob2xkLCBsaW1pdCkge1xuICAgICAgICBpZiAodGhyZXNob2xkc1t0aHJlc2hvbGRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGltaXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRocmVzaG9sZHNbdGhyZXNob2xkXTtcbiAgICAgICAgfVxuICAgICAgICB0aHJlc2hvbGRzW3RocmVzaG9sZF0gPSBsaW1pdDtcbiAgICAgICAgaWYgKHRocmVzaG9sZCA9PT0gJ3MnKSB7XG4gICAgICAgICAgICB0aHJlc2hvbGRzLnNzID0gbGltaXQgLSAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGh1bWFuaXplKGFyZ1dpdGhTdWZmaXgsIGFyZ1RocmVzaG9sZHMpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLmludmFsaWREYXRlKCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgd2l0aFN1ZmZpeCA9IGZhbHNlLFxuICAgICAgICAgICAgdGggPSB0aHJlc2hvbGRzLFxuICAgICAgICAgICAgbG9jYWxlLFxuICAgICAgICAgICAgb3V0cHV0O1xuXG4gICAgICAgIGlmICh0eXBlb2YgYXJnV2l0aFN1ZmZpeCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGFyZ1RocmVzaG9sZHMgPSBhcmdXaXRoU3VmZml4O1xuICAgICAgICAgICAgYXJnV2l0aFN1ZmZpeCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgYXJnV2l0aFN1ZmZpeCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICB3aXRoU3VmZml4ID0gYXJnV2l0aFN1ZmZpeDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGFyZ1RocmVzaG9sZHMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICB0aCA9IE9iamVjdC5hc3NpZ24oe30sIHRocmVzaG9sZHMsIGFyZ1RocmVzaG9sZHMpO1xuICAgICAgICAgICAgaWYgKGFyZ1RocmVzaG9sZHMucyAhPSBudWxsICYmIGFyZ1RocmVzaG9sZHMuc3MgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoLnNzID0gYXJnVGhyZXNob2xkcy5zIC0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGxvY2FsZSA9IHRoaXMubG9jYWxlRGF0YSgpO1xuICAgICAgICBvdXRwdXQgPSByZWxhdGl2ZVRpbWUkMSh0aGlzLCAhd2l0aFN1ZmZpeCwgdGgsIGxvY2FsZSk7XG5cbiAgICAgICAgaWYgKHdpdGhTdWZmaXgpIHtcbiAgICAgICAgICAgIG91dHB1dCA9IGxvY2FsZS5wYXN0RnV0dXJlKCt0aGlzLCBvdXRwdXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGxvY2FsZS5wb3N0Zm9ybWF0KG91dHB1dCk7XG4gICAgfVxuXG4gICAgdmFyIGFicyQxID0gTWF0aC5hYnM7XG5cbiAgICBmdW5jdGlvbiBzaWduKHgpIHtcbiAgICAgICAgcmV0dXJuICh4ID4gMCkgLSAoeCA8IDApIHx8ICt4O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvSVNPU3RyaW5nJDEoKSB7XG4gICAgICAgIC8vIGZvciBJU08gc3RyaW5ncyB3ZSBkbyBub3QgdXNlIHRoZSBub3JtYWwgYnViYmxpbmcgcnVsZXM6XG4gICAgICAgIC8vICAqIG1pbGxpc2Vjb25kcyBidWJibGUgdXAgdW50aWwgdGhleSBiZWNvbWUgaG91cnNcbiAgICAgICAgLy8gICogZGF5cyBkbyBub3QgYnViYmxlIGF0IGFsbFxuICAgICAgICAvLyAgKiBtb250aHMgYnViYmxlIHVwIHVudGlsIHRoZXkgYmVjb21lIHllYXJzXG4gICAgICAgIC8vIFRoaXMgaXMgYmVjYXVzZSB0aGVyZSBpcyBubyBjb250ZXh0LWZyZWUgY29udmVyc2lvbiBiZXR3ZWVuIGhvdXJzIGFuZCBkYXlzXG4gICAgICAgIC8vICh0aGluayBvZiBjbG9jayBjaGFuZ2VzKVxuICAgICAgICAvLyBhbmQgYWxzbyBub3QgYmV0d2VlbiBkYXlzIGFuZCBtb250aHMgKDI4LTMxIGRheXMgcGVyIG1vbnRoKVxuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkuaW52YWxpZERhdGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzZWNvbmRzID0gYWJzJDEodGhpcy5fbWlsbGlzZWNvbmRzKSAvIDEwMDAsXG4gICAgICAgICAgICBkYXlzID0gYWJzJDEodGhpcy5fZGF5cyksXG4gICAgICAgICAgICBtb250aHMgPSBhYnMkMSh0aGlzLl9tb250aHMpLFxuICAgICAgICAgICAgbWludXRlcyxcbiAgICAgICAgICAgIGhvdXJzLFxuICAgICAgICAgICAgeWVhcnMsXG4gICAgICAgICAgICBzLFxuICAgICAgICAgICAgdG90YWwgPSB0aGlzLmFzU2Vjb25kcygpLFxuICAgICAgICAgICAgdG90YWxTaWduLFxuICAgICAgICAgICAgeW1TaWduLFxuICAgICAgICAgICAgZGF5c1NpZ24sXG4gICAgICAgICAgICBobXNTaWduO1xuXG4gICAgICAgIGlmICghdG90YWwpIHtcbiAgICAgICAgICAgIC8vIHRoaXMgaXMgdGhlIHNhbWUgYXMgQyMncyAoTm9kYSkgYW5kIHB5dGhvbiAoaXNvZGF0ZSkuLi5cbiAgICAgICAgICAgIC8vIGJ1dCBub3Qgb3RoZXIgSlMgKGdvb2cuZGF0ZSlcbiAgICAgICAgICAgIHJldHVybiAnUDBEJztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIDM2MDAgc2Vjb25kcyAtPiA2MCBtaW51dGVzIC0+IDEgaG91clxuICAgICAgICBtaW51dGVzID0gYWJzRmxvb3Ioc2Vjb25kcyAvIDYwKTtcbiAgICAgICAgaG91cnMgPSBhYnNGbG9vcihtaW51dGVzIC8gNjApO1xuICAgICAgICBzZWNvbmRzICU9IDYwO1xuICAgICAgICBtaW51dGVzICU9IDYwO1xuXG4gICAgICAgIC8vIDEyIG1vbnRocyAtPiAxIHllYXJcbiAgICAgICAgeWVhcnMgPSBhYnNGbG9vcihtb250aHMgLyAxMik7XG4gICAgICAgIG1vbnRocyAlPSAxMjtcblxuICAgICAgICAvLyBpbnNwaXJlZCBieSBodHRwczovL2dpdGh1Yi5jb20vZG9yZGlsbGUvbW9tZW50LWlzb2R1cmF0aW9uL2Jsb2IvbWFzdGVyL21vbWVudC5pc29kdXJhdGlvbi5qc1xuICAgICAgICBzID0gc2Vjb25kcyA/IHNlY29uZHMudG9GaXhlZCgzKS5yZXBsYWNlKC9cXC4/MCskLywgJycpIDogJyc7XG5cbiAgICAgICAgdG90YWxTaWduID0gdG90YWwgPCAwID8gJy0nIDogJyc7XG4gICAgICAgIHltU2lnbiA9IHNpZ24odGhpcy5fbW9udGhzKSAhPT0gc2lnbih0b3RhbCkgPyAnLScgOiAnJztcbiAgICAgICAgZGF5c1NpZ24gPSBzaWduKHRoaXMuX2RheXMpICE9PSBzaWduKHRvdGFsKSA/ICctJyA6ICcnO1xuICAgICAgICBobXNTaWduID0gc2lnbih0aGlzLl9taWxsaXNlY29uZHMpICE9PSBzaWduKHRvdGFsKSA/ICctJyA6ICcnO1xuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICB0b3RhbFNpZ24gK1xuICAgICAgICAgICAgJ1AnICtcbiAgICAgICAgICAgICh5ZWFycyA/IHltU2lnbiArIHllYXJzICsgJ1knIDogJycpICtcbiAgICAgICAgICAgIChtb250aHMgPyB5bVNpZ24gKyBtb250aHMgKyAnTScgOiAnJykgK1xuICAgICAgICAgICAgKGRheXMgPyBkYXlzU2lnbiArIGRheXMgKyAnRCcgOiAnJykgK1xuICAgICAgICAgICAgKGhvdXJzIHx8IG1pbnV0ZXMgfHwgc2Vjb25kcyA/ICdUJyA6ICcnKSArXG4gICAgICAgICAgICAoaG91cnMgPyBobXNTaWduICsgaG91cnMgKyAnSCcgOiAnJykgK1xuICAgICAgICAgICAgKG1pbnV0ZXMgPyBobXNTaWduICsgbWludXRlcyArICdNJyA6ICcnKSArXG4gICAgICAgICAgICAoc2Vjb25kcyA/IGhtc1NpZ24gKyBzICsgJ1MnIDogJycpXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgdmFyIHByb3RvJDIgPSBEdXJhdGlvbi5wcm90b3R5cGU7XG5cbiAgICBwcm90byQyLmlzVmFsaWQgPSBpc1ZhbGlkJDE7XG4gICAgcHJvdG8kMi5hYnMgPSBhYnM7XG4gICAgcHJvdG8kMi5hZGQgPSBhZGQkMTtcbiAgICBwcm90byQyLnN1YnRyYWN0ID0gc3VidHJhY3QkMTtcbiAgICBwcm90byQyLmFzID0gYXM7XG4gICAgcHJvdG8kMi5hc01pbGxpc2Vjb25kcyA9IGFzTWlsbGlzZWNvbmRzO1xuICAgIHByb3RvJDIuYXNTZWNvbmRzID0gYXNTZWNvbmRzO1xuICAgIHByb3RvJDIuYXNNaW51dGVzID0gYXNNaW51dGVzO1xuICAgIHByb3RvJDIuYXNIb3VycyA9IGFzSG91cnM7XG4gICAgcHJvdG8kMi5hc0RheXMgPSBhc0RheXM7XG4gICAgcHJvdG8kMi5hc1dlZWtzID0gYXNXZWVrcztcbiAgICBwcm90byQyLmFzTW9udGhzID0gYXNNb250aHM7XG4gICAgcHJvdG8kMi5hc1F1YXJ0ZXJzID0gYXNRdWFydGVycztcbiAgICBwcm90byQyLmFzWWVhcnMgPSBhc1llYXJzO1xuICAgIHByb3RvJDIudmFsdWVPZiA9IHZhbHVlT2YkMTtcbiAgICBwcm90byQyLl9idWJibGUgPSBidWJibGU7XG4gICAgcHJvdG8kMi5jbG9uZSA9IGNsb25lJDE7XG4gICAgcHJvdG8kMi5nZXQgPSBnZXQkMjtcbiAgICBwcm90byQyLm1pbGxpc2Vjb25kcyA9IG1pbGxpc2Vjb25kcztcbiAgICBwcm90byQyLnNlY29uZHMgPSBzZWNvbmRzO1xuICAgIHByb3RvJDIubWludXRlcyA9IG1pbnV0ZXM7XG4gICAgcHJvdG8kMi5ob3VycyA9IGhvdXJzO1xuICAgIHByb3RvJDIuZGF5cyA9IGRheXM7XG4gICAgcHJvdG8kMi53ZWVrcyA9IHdlZWtzO1xuICAgIHByb3RvJDIubW9udGhzID0gbW9udGhzO1xuICAgIHByb3RvJDIueWVhcnMgPSB5ZWFycztcbiAgICBwcm90byQyLmh1bWFuaXplID0gaHVtYW5pemU7XG4gICAgcHJvdG8kMi50b0lTT1N0cmluZyA9IHRvSVNPU3RyaW5nJDE7XG4gICAgcHJvdG8kMi50b1N0cmluZyA9IHRvSVNPU3RyaW5nJDE7XG4gICAgcHJvdG8kMi50b0pTT04gPSB0b0lTT1N0cmluZyQxO1xuICAgIHByb3RvJDIubG9jYWxlID0gbG9jYWxlO1xuICAgIHByb3RvJDIubG9jYWxlRGF0YSA9IGxvY2FsZURhdGE7XG5cbiAgICBwcm90byQyLnRvSXNvU3RyaW5nID0gZGVwcmVjYXRlKFxuICAgICAgICAndG9Jc29TdHJpbmcoKSBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIHRvSVNPU3RyaW5nKCkgaW5zdGVhZCAobm90aWNlIHRoZSBjYXBpdGFscyknLFxuICAgICAgICB0b0lTT1N0cmluZyQxXG4gICAgKTtcbiAgICBwcm90byQyLmxhbmcgPSBsYW5nO1xuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ1gnLCAwLCAwLCAndW5peCcpO1xuICAgIGFkZEZvcm1hdFRva2VuKCd4JywgMCwgMCwgJ3ZhbHVlT2YnKTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ3gnLCBtYXRjaFNpZ25lZCk7XG4gICAgYWRkUmVnZXhUb2tlbignWCcsIG1hdGNoVGltZXN0YW1wKTtcbiAgICBhZGRQYXJzZVRva2VuKCdYJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKHBhcnNlRmxvYXQoaW5wdXQpICogMTAwMCk7XG4gICAgfSk7XG4gICAgYWRkUGFyc2VUb2tlbigneCcsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZSh0b0ludChpbnB1dCkpO1xuICAgIH0pO1xuXG4gICAgLy8hIG1vbWVudC5qc1xuXG4gICAgaG9va3MudmVyc2lvbiA9ICcyLjI5LjEnO1xuXG4gICAgc2V0SG9va0NhbGxiYWNrKGNyZWF0ZUxvY2FsKTtcblxuICAgIGhvb2tzLmZuID0gcHJvdG87XG4gICAgaG9va3MubWluID0gbWluO1xuICAgIGhvb2tzLm1heCA9IG1heDtcbiAgICBob29rcy5ub3cgPSBub3c7XG4gICAgaG9va3MudXRjID0gY3JlYXRlVVRDO1xuICAgIGhvb2tzLnVuaXggPSBjcmVhdGVVbml4O1xuICAgIGhvb2tzLm1vbnRocyA9IGxpc3RNb250aHM7XG4gICAgaG9va3MuaXNEYXRlID0gaXNEYXRlO1xuICAgIGhvb2tzLmxvY2FsZSA9IGdldFNldEdsb2JhbExvY2FsZTtcbiAgICBob29rcy5pbnZhbGlkID0gY3JlYXRlSW52YWxpZDtcbiAgICBob29rcy5kdXJhdGlvbiA9IGNyZWF0ZUR1cmF0aW9uO1xuICAgIGhvb2tzLmlzTW9tZW50ID0gaXNNb21lbnQ7XG4gICAgaG9va3Mud2Vla2RheXMgPSBsaXN0V2Vla2RheXM7XG4gICAgaG9va3MucGFyc2Vab25lID0gY3JlYXRlSW5ab25lO1xuICAgIGhvb2tzLmxvY2FsZURhdGEgPSBnZXRMb2NhbGU7XG4gICAgaG9va3MuaXNEdXJhdGlvbiA9IGlzRHVyYXRpb247XG4gICAgaG9va3MubW9udGhzU2hvcnQgPSBsaXN0TW9udGhzU2hvcnQ7XG4gICAgaG9va3Mud2Vla2RheXNNaW4gPSBsaXN0V2Vla2RheXNNaW47XG4gICAgaG9va3MuZGVmaW5lTG9jYWxlID0gZGVmaW5lTG9jYWxlO1xuICAgIGhvb2tzLnVwZGF0ZUxvY2FsZSA9IHVwZGF0ZUxvY2FsZTtcbiAgICBob29rcy5sb2NhbGVzID0gbGlzdExvY2FsZXM7XG4gICAgaG9va3Mud2Vla2RheXNTaG9ydCA9IGxpc3RXZWVrZGF5c1Nob3J0O1xuICAgIGhvb2tzLm5vcm1hbGl6ZVVuaXRzID0gbm9ybWFsaXplVW5pdHM7XG4gICAgaG9va3MucmVsYXRpdmVUaW1lUm91bmRpbmcgPSBnZXRTZXRSZWxhdGl2ZVRpbWVSb3VuZGluZztcbiAgICBob29rcy5yZWxhdGl2ZVRpbWVUaHJlc2hvbGQgPSBnZXRTZXRSZWxhdGl2ZVRpbWVUaHJlc2hvbGQ7XG4gICAgaG9va3MuY2FsZW5kYXJGb3JtYXQgPSBnZXRDYWxlbmRhckZvcm1hdDtcbiAgICBob29rcy5wcm90b3R5cGUgPSBwcm90bztcblxuICAgIC8vIGN1cnJlbnRseSBIVE1MNSBpbnB1dCB0eXBlIG9ubHkgc3VwcG9ydHMgMjQtaG91ciBmb3JtYXRzXG4gICAgaG9va3MuSFRNTDVfRk1UID0ge1xuICAgICAgICBEQVRFVElNRV9MT0NBTDogJ1lZWVktTU0tRERUSEg6bW0nLCAvLyA8aW5wdXQgdHlwZT1cImRhdGV0aW1lLWxvY2FsXCIgLz5cbiAgICAgICAgREFURVRJTUVfTE9DQUxfU0VDT05EUzogJ1lZWVktTU0tRERUSEg6bW06c3MnLCAvLyA8aW5wdXQgdHlwZT1cImRhdGV0aW1lLWxvY2FsXCIgc3RlcD1cIjFcIiAvPlxuICAgICAgICBEQVRFVElNRV9MT0NBTF9NUzogJ1lZWVktTU0tRERUSEg6bW06c3MuU1NTJywgLy8gPGlucHV0IHR5cGU9XCJkYXRldGltZS1sb2NhbFwiIHN0ZXA9XCIwLjAwMVwiIC8+XG4gICAgICAgIERBVEU6ICdZWVlZLU1NLUREJywgLy8gPGlucHV0IHR5cGU9XCJkYXRlXCIgLz5cbiAgICAgICAgVElNRTogJ0hIOm1tJywgLy8gPGlucHV0IHR5cGU9XCJ0aW1lXCIgLz5cbiAgICAgICAgVElNRV9TRUNPTkRTOiAnSEg6bW06c3MnLCAvLyA8aW5wdXQgdHlwZT1cInRpbWVcIiBzdGVwPVwiMVwiIC8+XG4gICAgICAgIFRJTUVfTVM6ICdISDptbTpzcy5TU1MnLCAvLyA8aW5wdXQgdHlwZT1cInRpbWVcIiBzdGVwPVwiMC4wMDFcIiAvPlxuICAgICAgICBXRUVLOiAnR0dHRy1bV11XVycsIC8vIDxpbnB1dCB0eXBlPVwid2Vla1wiIC8+XG4gICAgICAgIE1PTlRIOiAnWVlZWS1NTScsIC8vIDxpbnB1dCB0eXBlPVwibW9udGhcIiAvPlxuICAgIH07XG5cbiAgICByZXR1cm4gaG9va3M7XG5cbn0pKSk7XG4iLCAiaW1wb3J0IHsgVXBkYXRlTm90ZVR5cGVNb2RhbCB9IGZyb20gJ3VwZGF0ZU5vdGVUeXBlTW9kYWwnO1xuaW1wb3J0IHsgQXBwLCBFZGl0b3IsIE1hcmtkb3duVmlldywgTm90aWNlLCBQbHVnaW4sIFBsdWdpblNldHRpbmdUYWIsIFNldHRpbmcsIFRGaWxlLCBWYXVsdCwgRWRpdG9yU2VsZWN0aW9uLCBXb3Jrc3BhY2UsIHBhcnNlRnJvbnRNYXR0ZXJUYWdzLCBXb3Jrc3BhY2VMZWFmIH0gZnJvbSAnb2JzaWRpYW4nO1xuaW1wb3J0IHsgQWRkRm9vdG5vdGVUYWdNb2RhbCB9IGZyb20gJ2FkZENvbW1lbnRUYWdNb2RhbCc7XG5pbXBvcnQgeyBBZGRUYXNrVGFnTW9kYWwgfSBmcm9tICdhZGRUYXNrVGFnTW9kYWwnO1xuaW1wb3J0IHsgcmVuYW1lQmxvZ1RpdGxlLCByZW5hbWVUYWcsIHJlbmFtZVRocmVhZHNUaXRsZSB9IGZyb20gJ3RhZ3JlbmFtZXIvcmVuYW1pbmcnO1xuaW1wb3J0IHsgVGhyZWFkc1RvSW1hZ2VzTW9kYWwgfSBmcm9tICdUaHJlYWRzVG9JbWFnZXNNb2RhbCc7XG5pbXBvcnQgeyBDb3B5T3JNb3ZlVG9OZXdOb3RlTW9kYWwgfSBmcm9tICdjb3B5T3JNb3ZlVG9OZXdOb3RlTW9kYWwnO1xuaW1wb3J0IHsgQ2xpcGJvYXJkUGFzdGVNb2RhbCB9IGZyb20gJ2NsaXBib2FyZFBhc3RlTW9kYWwnO1xuaW1wb3J0IHsgT3BlblBsYXlncm91bmRNb2RhbCB9IGZyb20gJ29wZW5QbGF5Z3JvdW5kTW9kYWwnO1xuaW1wb3J0IHsgVGhyZWFkc1RvQmxvZ01vZGFsIH0gZnJvbSAndGhyZWFkc1RvQmxvZ01vZGFsJztcbmltcG9ydCB7IENsaXBib2FyZFJlbW92YWxNb2RhbCB9IGZyb20gJ2NsaXBib2FyZFJlbW92YWxNb2RhbCc7XG5pbXBvcnQgeyBUYWdTZWFyY2hNb2RhbCB9IGZyb20gJ3RhZ1NlYXJjaE1vZGFsJztcbmltcG9ydCB7IGFkZEljb24gfSBmcm9tICdvYnNpZGlhbic7XG5pbXBvcnQgbW9tZW50IGZyb20gJ21vbWVudCc7XG5pbXBvcnQgeyBBZGRUZXh0VG9Ob3Rlc01vZGFsIH0gZnJvbSAnYWRkVGV4dFRvTm90ZXNNb2RhbCc7XG5pbXBvcnQgeyBOYXZpZ2F0ZVRvTm90ZUZyb21UYWdNb2RhbCB9IGZyb20gJ25hdmlnYXRlVG9Ob3RlRnJvbVRhZ01vZGFsJztcbmltcG9ydCB7IFNlbGVjdGlvblJhbmdlLCBleHBvcnRDdXJyZW50U2VsZWN0aW9uLCBnZXRDdXJyZW50U2VsZWN0aW9uTGluZU51bWJlciB9IGZyb20gJ3NlbGZ1dGlsL2V4dHJhY3RTZWxlY3Rpb24nO1xuaW1wb3J0IHsgZ2V0UGFyZW50TGluZSwgcmVwbGFjZVRXVXNlbGVzc1ZhbHVlLCBzaG91bGRTa2lwRnJvbnRNYXR0ZXIsIHRpZHlVcEZyb250TWF0dGVyT25WYWx1ZSwgdGlkeVVwRnJvbnRNYXR0ZXJvbkVkaXRvciB9IGZyb20gJ3R3bWlncmF0aW9uL3R3TWlncmF0ZVRvb2xzJztcbmltcG9ydCB7IHJlbW92ZUNvbnRlbnRGcm9tQ3Vyc29yVG9FbmRPZk5vdGUsIHJlbW92ZUNvbnRlbnRGcm9tU3RhcnRPZk5vdGVUb0N1cnNvciwgcmVtb3ZlQ29udGVudExlZnRTYW1lTGluZSB9IGZyb20gJ3NlbGZ1dGlsL3JlbW92ZUNvbnRlbnRGcm9tQ3Vyc29yJztcbmltcG9ydCB7IFJlbW92ZUNvbnRlbnRGcm9tQ3Vyc29yTW9kYWwgfSBmcm9tICdyZW1vdmVDb250ZW50RnJvbUN1cnNvck1vZGFsJztcbmltcG9ydCB7IEZpbmRSZXBsYWNlTW9kYWwgfSBmcm9tICdmaW5kUmVwbGFjZU1vZGFsJztcbmltcG9ydCB7IFF1ZXJ5T3JwaGFuTm90ZXNCeVRhZ01vZGFsIH0gZnJvbSAncXVlcnlPcnBoYW5Ob3Rlc0J5VGFnTW9kYWwnO1xuaW1wb3J0IHsgTmF2aWdhdGVUb0ZvcndhcmRBbmRCYWNrbGlua1RhZ01vZGFsIH0gZnJvbSAnbmF2aWdhdGVUb0ZvcndhcmRBbmRCYWNrbGlua01vZGFsJztcbmltcG9ydCB7IE5vdGVUeXBlLCBnZXROb3RlVHlwZSB9IGZyb20gJ3NlbGZ1dGlsL2dldFRhc2tUYWcnO1xuaW1wb3J0IHsgZ2V0Q2hpbGRsaW5rSXRlbXMgfSBmcm9tICdzZWxmdXRpbC9nZXRDaGlsZExpbmsnO1xuaW1wb3J0IHsgZ2V0QWxsTm90ZXNXaXRob3V0TWV0YWRhdGEgfSBmcm9tICdzZWxmdXRpbC9nZXRSZWNlbnROb3Rlcyc7XG5pbXBvcnQgeyBOYXZpZ2F0ZVJld3JpdGFibGVUaHJlYWRzTW9kYWwgfSBmcm9tICduYXZpZ2F0ZVJld3JpdGFibGVUaHJlYWRzTW9kYWwnO1xuaW1wb3J0IHsgUmV3cml0ZVRocmVhZHNNb2RhbCB9IGZyb20gJ3Jld3JpdGVUaHJlYWRzJztcbmltcG9ydCB7IE5vdGVzVHlwZVZpZXcsIFZJRVdfVFlQRV9OT1RFX0xJU1QgfSBmcm9tICdub3Rlc1R5cGVWaWV3JztcblxuLy8gUmVtZW1iZXIgdG8gcmVuYW1lIHRoZXNlIGNsYXNzZXMgYW5kIGludGVyZmFjZXMhXG5cbmludGVyZmFjZSBNeVBsdWdpblNldHRpbmdzIHtcblx0bXlTZXR0aW5nOiBzdHJpbmc7XG59XG5cbmNvbnN0IERFRkFVTFRfU0VUVElOR1M6IE15UGx1Z2luU2V0dGluZ3MgPSB7XG5cdG15U2V0dGluZzogJ2RlZmF1bHQnXG59XG5cbmNvbnN0IGNsaXBib2FyZEhpc3Rvcnk6IHN0cmluZ1tdID0gW11cblxuXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE15UGx1Z2luIGV4dGVuZHMgUGx1Z2luIHtcblx0c2V0dGluZ3M6IE15UGx1Z2luU2V0dGluZ3M7XG5cdHZpZXc6IE1hcmtkb3duVmlldztcblx0cHVibGljIG5vdGVzVHlwZVZpZXc6IE5vdGVzVHlwZVZpZXc7XG5cdHB1YmxpYyBub3Rlc1R5cGVUYWcgOiBzdHJpbmcgPSBcIlwiXG5cdHB1YmxpYyBwbHVnaW46IE15UGx1Z2luID0gdGhpc1xuXHRwcml2YXRlIGxhc3RBY3RpdmVMZWFmOiBXb3Jrc3BhY2VMZWFmIHwgbnVsbCA9IG51bGw7XG5cblx0cHVibGljIGFzeW5jIGFjdGl2YXRlTm90ZUxpc3RWaWV3KCkge1xuXHRcdC8qXG5cdFx0Y29uc3QgbGVhZiA9IHRoaXMuYXBwLndvcmtzcGFjZS5nZXRMZWZ0TGVhZihmYWxzZSk7XG5cdFx0YXdhaXQgbGVhZi5zZXRWaWV3U3RhdGUoe1xuXHRcdCAgdHlwZTogVklFV19UWVBFX05PVEVfTElTVCxcblx0XHQgIGFjdGl2ZTogdHJ1ZSxcblx0XHR9KTtcblx0XHR0aGlzLmFwcC53b3Jrc3BhY2UucmV2ZWFsTGVhZihsZWFmKTtcblx0XHQqL1xuXHRcdGxldCBsZWFmOiBXb3Jrc3BhY2VMZWFmIHwgbnVsbDtcbiAgICAgICAgW2xlYWZdID0gdGhpcy5hcHAud29ya3NwYWNlLmdldExlYXZlc09mVHlwZShcblx0XHRcdFZJRVdfVFlQRV9OT1RFX0xJU1QsXG4gICAgICAgICk7XG4gICAgICAgIGlmICghbGVhZikge1xuICAgICAgICAgIGxlYWYgPSB0aGlzLmFwcC53b3Jrc3BhY2UuZ2V0TGVmdExlYWYoZmFsc2UpO1xuICAgICAgICAgIGF3YWl0IGxlYWY/LnNldFZpZXdTdGF0ZSh7IHR5cGU6IFZJRVdfVFlQRV9OT1RFX0xJU1QgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGVhZikge1xuICAgICAgICAgIHRoaXMuYXBwLndvcmtzcGFjZS5yZXZlYWxMZWFmKGxlYWYpO1xuICAgICAgICB9XG5cdCAgfVxuXG5cdGFzeW5jIG9ubG9hZCgpIHtcblx0XHRhd2FpdCB0aGlzLmxvYWRTZXR0aW5ncygpO1xuXG5cdFx0dGhpcy5yZWdpc3RlclZpZXcoXG5cdFx0XHRWSUVXX1RZUEVfTk9URV9MSVNULFxuXHRcdFx0KGxlYWYpID0+IHRoaXMubm90ZXNUeXBlVmlldyA9IG5ldyBOb3Rlc1R5cGVWaWV3KGxlYWYsIHRoaXMubm90ZXNUeXBlVGFnKVxuXHRcdCk7XG5cdFxuXHRcdHRoaXMuYWRkUmliYm9uSWNvbignaGFzaCcsICdPcGVuIE5vdGUgTGlzdCBWaWV3JywgKCkgPT4ge1xuXHRcdFx0dGhpcy5hY3RpdmF0ZU5vdGVMaXN0VmlldygpO1xuXHRcdH0pO1xuXG5cdFx0Lypcblx0dGhpcy5yZWdpc3RlckV2ZW50KFxuXHRcdHRoaXMuYXBwLndvcmtzcGFjZS5vbignYWN0aXZlLWxlYWYtY2hhbmdlJywgKGxlYWYpID0+IHtcblx0XHQgIGlmIChsZWFmICYmIGxlYWYgIT09IHRoaXMubGFzdEFjdGl2ZUxlYWYpIHtcblx0XHRcdGNvbnN0IHZpZXcgPSBsZWFmLnZpZXc7XG5cdFx0XHRpZiAodmlldyBpbnN0YW5jZW9mIE5vdGVzVHlwZVZpZXcpIHtcblx0XHRcdCAgdmlldy5yZWRyYXcoKVxuXHRcdFx0fVxuXHRcdFx0dGhpcy5sYXN0QWN0aXZlTGVhZiA9IGxlYWY7XG5cdFx0ICB9XG5cdFx0fSlcblx0ICApO1xuXHQgICovXG5cblx0XG5cdHRoaXMuYXBwLndvcmtzcGFjZS5vbkxheW91dFJlYWR5KCgpID0+IHtcblx0XHQvL3RoaXMuYWN0aXZhdGVOb3RlTGlzdFZpZXcoKTtcblx0XHR0aGlzLmFwcC5tZXRhZGF0YUNhY2hlLm9uKFwiY2hhbmdlZFwiLCBhc3luYyAoZmlsZSkgPT4ge1xuXHRcdFx0aWYgKHRoaXMubm90ZXNUeXBlVmlldykge1xuXHRcdFx0XHR0aGlzLm5vdGVzVHlwZVZpZXcucmVkcmF3KCk7XG5cdFx0XHR9XG5cdFx0fSlcblx0fSk7XG5cdFxuXHRcdFxuXG5cdFx0Lypcblx0XHQvL2Z1bmN0aW9uIGRpc3BsYXlOb3RlSW5MZWZ0VmlldyhhcHA6IEFwcCwgbm90ZVBhdGg6IHN0cmluZykge1xuXHRcdFx0Y29uc29sZS5sb2coXCI9PT0xXCIpXG5cdFx0XHQvL2NvbnN0IHZpZXcgPSBuZXcgTWFya2Rvd25WaWV3KHRoaXMuYXBwLndvcmtzcGFjZS5nZXRMZWFmKCkpO1xuXHRcdFx0Ly9jb25zb2xlLmxvZyhcIj09PTJcIilcblx0XHRcdC8vdmlldy5zZXRFcGhlbWVyYWxTdGF0ZSh7IHBhdGg6IFwiSS9JbmJveC5tZFwiIH0pO1xuXHRcdFx0Ly9jb25zb2xlLmxvZyhcIj09PTNcIilcblx0XHRcdC8vYXBwLndvcmtzcGFjZS5nZXRMZWFmKCkuc2V0Vmlld1N0YXRlKHsgdHlwZTogXCJtYXJrZG93blwiLCBzdGF0ZTogdmlldy5nZXRTdGF0ZSgpIH0pO1xuXHRcdFx0Ly9jb25zb2xlLmxvZyhcIj09PTRcIilcblxuXHRcdFx0XG5cdFx0XHR0aGlzLnJlZ2lzdGVyVmlldyhcblx0XHRcdFx0XCJpbmJveFwiLFxuXHRcdFx0XHQobGVhZikgPT4ge1xuXHRcdFx0XHRcdHRoaXMudmlldyA9IG5ldyBNYXJrZG93blZpZXcobGVhZilcblx0XHRcdFx0XHR0aGlzLnZpZXcuc2V0RXBoZW1lcmFsU3RhdGUoeyBwYXRoOiBcIkkvSW5ib3gubWRcIiB9KTtcblx0XHRcdFx0XHRjb25zdCBzdGF0ZSA9IHRoaXMudmlldy5nZXRTdGF0ZSgpXG5cdFx0XHRcdFx0c3RhdGUucGlubmVkID0gdHJ1ZVxuXHRcdFx0XHRcdGxlYWYuc2V0Vmlld1N0YXRlKHsgdHlwZTogXCJtYXJrZG93blwiLCBzdGF0ZTogc3RhdGUgfSk7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMudmlld1xuXHRcdFx0XHR9LFxuXHRcdFx0ICApO1xuXHRcdCAgLy99XG5cblx0XHQgIGNvbnNvbGUubG9nKFwiPT09MlwiKVxuXG5cdFx0ICB0aGlzLmFkZENvbW1hbmQoe1xuXHRcdFx0aWQ6ICdyZWNlbnQtZmlsZXMtb3BlbicsXG5cdFx0XHRuYW1lOiAnT3BlbiBYWFgnLFxuXHRcdFx0Y2FsbGJhY2s6IGFzeW5jICgpID0+IHtcblx0XHRcdCAgbGV0IFtsZWFmXSA9IHRoaXMuYXBwLndvcmtzcGFjZS5nZXRMZWF2ZXNPZlR5cGUoXG5cdFx0XHRcdFwiaW5ib3hcIixcblx0XHRcdCAgKTtcblx0XHRcdCAgaWYgKCFsZWFmKSB7XG5cdFx0XHRcdGxlYWYgPSB0aGlzLmFwcC53b3Jrc3BhY2UuZ2V0TGVmdExlYWYoZmFsc2UpO1xuXHRcdFx0XHRhd2FpdCBsZWFmLnNldFZpZXdTdGF0ZSh7IHR5cGU6IFwiaW5ib3hcIiB9KTtcblx0XHRcdCAgfVxuXHQgIFxuXHRcdFx0ICB0aGlzLmFwcC53b3Jrc3BhY2UucmV2ZWFsTGVhZihsZWFmKTtcblx0XHRcdH0sXG5cdFx0ICB9KTtcblxuXHRcdCAgY29uc29sZS5sb2coXCI9PT0zXCIpXG5cdFx0ICAqL1xuXHRcdCAgXG5cblx0XHRpZiAobmF2aWdhdG9yLmNsaXBib2FyZCkge1xuXHRcdFx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY29weScsIChldmVudDogQ2xpcGJvYXJkRXZlbnQpID0+IHtcblx0XHRcdFx0Y29uc3QgY29waWVkVGV4dCA9IGV2ZW50LmNsaXBib2FyZERhdGE/LmdldERhdGEoJ3RleHQvcGxhaW4nKTtcblx0XHRcdFx0aWYgKGNvcGllZFRleHQgIT0gbnVsbCkge1xuXHRcdFx0XHRcdHRoaXMuYWRkVG9DbGlwYm9hcmRIaXN0b3J5KGNvcGllZFRleHQpXG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdFx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY3V0JywgKGV2ZW50OiBDbGlwYm9hcmRFdmVudCkgPT4ge1xuXHRcdFx0XHRjb25zdCBjb3BpZWRUZXh0ID0gZXZlbnQuY2xpcGJvYXJkRGF0YT8uZ2V0RGF0YSgndGV4dC9wbGFpbicpO1xuXHRcdFx0XHRpZiAoY29waWVkVGV4dCAhPSBudWxsKSB7XG5cdFx0XHRcdFx0dGhpcy5hZGRUb0NsaXBib2FyZEhpc3RvcnkoY29waWVkVGV4dClcblx0XHRcdFx0fVxuXHRcdFx0ICB9KTtcblx0XHQgIH0gZWxzZSB7XG5cdFx0XHRjb25zb2xlLmxvZygnQ2xpcGJvYXJkIEFQSSBpcyBub3Qgc3VwcG9ydGVkIGluIHRoaXMgYnJvd3Nlci4nKTtcblx0XHQgIH1cblxuXHRcdFsnbicsICdsJywgJ3cnLCAnZCcsICdhJywgJzEnLCAnMicsICczJywgJzQnLCAnNScsICc2JywgJzcnXS5mb3JFYWNoKHQgPT4ge1xuXHRcdFx0dGhpcy5hZGRBY3Rpb25JY29uKHQpO1xuXHRcdFx0dGhpcy5hZGRBY3Rpb25Db21tYW5kKHQpO1xuXHRcdH0pO1xuXG5cdFx0Wyd0JywgJ20nLCAnZSddLmZvckVhY2godCA9PiB7XG5cdFx0XHR0aGlzLmFkZEFjdGlvbkljb24odCk7XG5cdFx0XHR0aGlzLmFkZEZvbGxvd1VwQ29tbWFuZCh0KTtcblx0XHR9KTtcblxuXHRcdFsnbicsICd3J10uZm9yRWFjaCh0ID0+IHtcblx0XHRcdHRoaXMuYWRkTmV3TGF0ZXJBY3Rpb25JY29uKHQpO1xuXHRcdFx0dGhpcy5hZGROZXdMYXRlckFjdGlvbih0KTtcblx0XHR9KTtcblxuXHRcdHRoaXMuYWRkQ29tbWFuZCh7XG5cdFx0XHRpZDogXCJvYnNpZGlhbi1yZW1vdmUtY2xpcGJvYXJkLWNvbnRlbnRcIixcblx0XHRcdG5hbWU6IFwiUkMgT2JzaWRpYW4gUmVtb3ZlIENsaXBib2FyZCBDb250ZW50XCIsXG5cdFx0XHRpY29uOiBcIm9ic2lkaWFuLXJlbW92ZS1jbGlwYm9hcmQtY29udGVudFwiLFxuXHRcdFx0ZWRpdG9yQ2FsbGJhY2s6IChlZGl0b3I6IEVkaXRvciwgdmlldzogTWFya2Rvd25WaWV3KSA9PiB7XG5cdFx0XHRcdG5ldyBDbGlwYm9hcmRSZW1vdmFsTW9kYWwodGhpcy5hcHAsIGVkaXRvciwgY2xpcGJvYXJkSGlzdG9yeSkub3BlbigpO1x0XHRcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdC8qXG5cdFx0dGhpcy5hZGRPYnNpZGlhbkljb24oJ29ic2lkaWFuLWNvcHknLCAnXHUyMzE4QycpO1xuXHRcdHRoaXMuYWRkQ29tbWFuZCh7XG5cdFx0XHRpZDogXCJvYnNpZGlhbi1jb3B5XCIsXG5cdFx0XHRuYW1lOiBcIk9ic2lkaWFuIENvcHlcIixcblx0XHRcdGljb246IFwib2JzaWRpYW4tY29weVwiLFxuXHRcdFx0ZWRpdG9yQ2FsbGJhY2s6IChlZGl0b3I6IEVkaXRvciwgdmlldzogTWFya2Rvd25WaWV3KSA9PiB7XG5cdFx0XHRcdGxldCBjb250ZW50ID0gZWRpdG9yLmdldFNlbGVjdGlvbigpLnRvU3RyaW5nKClcblx0XHRcdFx0aWYgKGNvbnRlbnQubGVuZ3RoID09IDApIHtcblx0XHRcdFx0XHRjb250ZW50ID0gZWRpdG9yLmdldExpbmUoZWRpdG9yLmdldEN1cnNvcigpLmxpbmUpXG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5hZGRUb0NsaXBib2FyZEhpc3RvcnkoY29udGVudCk7XG5cdFx0XHRcdG5ldyBOb3RpY2UoXCJgYGBcXG5cIiArIGNvbnRlbnQgKyBcIlxcbmBgYFxcbmlzIGNvcGllZCB0byBjbGlwYm9hcmQhXCIpXG5cdFx0XHR9LFxuXHRcdFx0aG90a2V5czogW1xuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bW9kaWZpZXJzOiBbYE1ldGFgLCBgU2hpZnRgXSxcblx0XHRcdFx0XHRrZXk6IGBjYCxcblx0XHRcdFx0fVxuXHRcdFx0XVxuXHRcdH0pO1xuXHRcdCovXG5cblx0XHQvKlxuXHRcdHRoaXMuYWRkT2JzaWRpYW5JY29uKCdvYnNpZGlhbi1jdXQnLCAnXHUyMzE4WCcpO1xuXHRcdHRoaXMuYWRkQ29tbWFuZCh7XG5cdFx0XHRpZDogXCJvYnNpZGlhbi1jdXRcIixcblx0XHRcdG5hbWU6IFwiT2JzaWRpYW4gQ3V0XCIsXG5cdFx0XHRpY29uOiBcIm9ic2lkaWFuLWN1dFwiLFxuXHRcdFx0ZWRpdG9yQ2FsbGJhY2s6IChlZGl0b3I6IEVkaXRvciwgdmlldzogTWFya2Rvd25WaWV3KSA9PiB7XG5cdFx0XHRcdGxldCBjb250ZW50ID0gZWRpdG9yLmdldFNlbGVjdGlvbigpLnRvU3RyaW5nKClcblx0XHRcdFx0aWYgKGNvbnRlbnQubGVuZ3RoID09IDApIHtcblx0XHRcdFx0XHRjb250ZW50ID0gZWRpdG9yLmdldExpbmUoZWRpdG9yLmdldEN1cnNvcigpLmxpbmUpXG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5hZGRUb0NsaXBib2FyZEhpc3RvcnkoY29udGVudCk7XG5cdFx0XHRcdGVkaXRvci5yZXBsYWNlU2VsZWN0aW9uKFwiXCIpXG5cdFx0XHRcdG5ldyBOb3RpY2UoXCJgYGBcXG5cIiArIGNvbnRlbnQgKyBcIlxcbmBgYFxcbmlzIGN1dCB0byBjbGlwYm9hcmQhXCIpXG5cdFx0XHR9LFxuXHRcdFx0aG90a2V5czogW1xuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bW9kaWZpZXJzOiBbYE1ldGFgLCBgU2hpZnRgXSxcblx0XHRcdFx0XHRrZXk6IGB4YCxcblx0XHRcdFx0fVxuXHRcdFx0XVxuXHRcdH0pO1xuXHQqL1xuXG5cdHRoaXMuYWRkT2JzaWRpYW5JY29uKCdhdXRvLWNvcnJlY3QnLCAnQUMnKTtcblx0dGhpcy5hZGRDb21tYW5kKHtcblx0XHRpZDogXCJhdXRvLWNvcnJlY3RcIixcblx0XHRuYW1lOiBcIkF1dG8gQ29ycmVjdCBBQ1wiLFxuXHRcdGljb246IFwiYXV0by1jb3JyZWN0XCIsXG5cdFx0ZWRpdG9yQ2FsbGJhY2s6IChlZGl0b3I6IEVkaXRvciwgdmlldzogTWFya2Rvd25WaWV3KSA9PiB7XG5cdFx0XHRjb25zdCB2YWx1ZSA9IGVkaXRvci5nZXRWYWx1ZSgpXG5cdFx0XHRsZXQgbW9kaWZpZWRWYWx1ZSA9IHZhbHVlLnNwbGl0KFwiXFxuXCIpLm1hcChsaW5lID0+IHtcblx0XHRcdFx0dmFyIGwyID0gbGluZS5yZXBsYWNlKC8xMFx1NTIwNi9nLCBcIlx1NTM0MVx1NTIwNlwiKVxuXHRcdFx0XHRcdFx0XHQucmVwbGFjZSgvXHU4OENGL2csIFwiXHU4OEUxXCIpXG5cdFx0XHRcdFx0XHRcdC5yZXBsYWNlKC9cdTU5MjdcdTRGNkMvZywgXCJcdTU5MjdcdTgxNjZcIilcblx0XHRcdFx0aWYgKC9bW1xcdTRFMDAtXFx1OUZGRl1dLy50ZXN0KGwyKSkge1xuXHRcdFx0XHRcdGwyID0gbDIucmVwbGFjZSgvICosICovZywgXCJcdUZGMENcIilcblx0XHRcdFx0XHRcdFx0LnJlcGxhY2UoLyAqXFw/ICovZywgXCJcdUZGMUZcIilcblx0XHRcdFx0XHRcdFx0LnJlcGxhY2UoLyAqOiAqL2csIFwiXHVGRjFBXCIpXG5cdFx0XHRcdFx0XHRcdC5yZXBsYWNlKC8gKjsgKi9nLCBcIlx1RkYxQlwiKVxuXHRcdFx0XHRcdFx0XHQucmVwbGFjZSgvICohICovZywgXCJcdUZGMDFcIilcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gbDJcblx0XHRcdH0pLmpvaW4oXCJcXG5cIilcblx0XHRcdFxuXHRcdFx0Ly9sZXQgbW9kaWZpZWRWYWx1ZSA9IHZhbHVlXG5cdFx0XHQvLy5yZXBsYWNlKC8xMFx1NTIwNi9nLCBcIlx1NTM0MVx1NTIwNlwiKVxuXHRcdFx0Ly8ucmVwbGFjZSgvXHU4OENGL2csIFwiXHU4OEUxXCIpXG5cdFx0XHQvLy5yZXBsYWNlKC9cdTU5MjdcdTRGNkMvZywgXCJcdTU5MjdcdTgxNjZcIilcblx0XHRcdC8vLnJlcGxhY2UoLyAqLCAqL2csIFwiXHVGRjBDXCIpXG5cdFx0XHQvLy5yZXBsYWNlKC8gKlxcPyAqL2csIFwiXHVGRjFGXCIpXG5cdFx0XHQvLy5yZXBsYWNlKC8gKjogKi9nLCBcIlx1RkYxQVwiKVxuXHRcdFx0Ly8ucmVwbGFjZSgvICo7ICovZywgXCJcdUZGMUJcIilcblx0XHRcdC8vLnJlcGxhY2UoLyAqISAqL2csIFwiXHVGRjAxXCIpXG5cdFx0XHQvLy5yZXBsYWNlKC90YWdzXHVGRjFBL2csIFwidGFnczogXCIpXG5cdFx0XHQvLy5yZXBsYWNlKC90YWdcdUZGMUEvZywgXCJ0YWdzOiBcIilcblx0XHRcdFxuXG5cdFx0XHQvLyB0aGVuIGFkZCBzcGFjZXMgYmV0d2VlbiBlbmdsaXNoIGFuZCBjaGluZXNlIGlmIG5vIHNwYWNlXG5cdFx0XHRtb2RpZmllZFZhbHVlID0gbW9kaWZpZWRWYWx1ZVxuXHRcdFx0LnJlcGxhY2UoLyhbYS16QS1aMC05XSkoW1xcdTRFMDAtXFx1OUZGRl0pL2csIFwiJDEgJDJcIilcblx0XHRcdC5yZXBsYWNlKC8oW1xcdTRFMDAtXFx1OUZGRl0pKFthLXpBLVowLTldKS9nLCBcIiQxICQyXCIpXG5cdFx0XHRlZGl0b3Iuc2V0VmFsdWUobW9kaWZpZWRWYWx1ZSlcblx0XHR9XG5cdH0pO1xuXG5cdHRoaXMuYWRkT2JzaWRpYW5JY29uKCdmaW5kLWJyb2tlbi1saW5rJywgJ0JMJyk7XG5cdHRoaXMuYWRkQ29tbWFuZCh7XG5cdFx0aWQ6IFwiZmluZC1icm9rZW4tbGlua1wiLFxuXHRcdG5hbWU6IFwiRmluZCBCcm9rZW4gTGluayBCTFwiLFxuXHRcdGljb246IFwiZmluZC1icm9rZW4tbGlua1wiLFxuXHRcdGVkaXRvckNhbGxiYWNrOiAoZWRpdG9yOiBFZGl0b3IsIHZpZXc6IE1hcmtkb3duVmlldykgPT4ge1xuXHRcdFx0aWYgKHZpZXcuZmlsZS5wYXRoICE9PSBcIkkvQnJva2VuIExpbmsubWRcIikge1xuXHRcdFx0XHRcblx0XHRcdFx0Y29uc3QgY3Vyc29yID0gZWRpdG9yLmdldEN1cnNvcigpXG5cdFx0XHRcdGNvbnN0IGxpbmUgPSBjdXJzb3IubGluZVxuXHRcdFx0XHRjb25zdCBsaW5lQ29udGVudCA9IGVkaXRvci5nZXRMaW5lKGxpbmUpXG5cblx0XHRcdFx0Ly8gaWYgbGluZSBjb250ZW50IGhhcyBbWyBhbmQgXV0gIGFuZCA6ID8gLyA8ID4gaW4gYmV0d2VlbiwgcmVwbGFjZSB0aGVtIHRvIF9cblx0XHRcdFx0aWYgKC9cXFtcXFsuKls6P1xcL1xcXFw8Pl0uKlxcXVxcXS8udGVzdChsaW5lQ29udGVudCkpIHtcblx0XHRcdFx0XHRuZXcgTm90aWNlKFwiVHJ5aW5nIHRvIGZpeCBicm9rZW4gbGluZSBpbiBjdXJyZW50IGxpbmU6IFwiICsgbGluZUNvbnRlbnQpXG5cdFx0XHRcdFx0Ly8gcmVwbGFjZSBhbGwgOiB0byBfIGFuZCByZXBsYWNlIGFsbCA/IHRvIF8gYW5kIHJlcGxhY2UgYWxsIC8gdG8gXyBhbmQgcmVwbGFjZSBhbGwgLiB0byBfXG5cdFx0XHRcdFx0ZWRpdG9yLnNldExpbmUobGluZSwgbGluZUNvbnRlbnQucmVwbGFjZSgvOi9nLCBcIl9cIikucmVwbGFjZSgvXFw/L2csIFwiX1wiKS5yZXBsYWNlKC9cXC8vZywgXCJfXCIpLnJlcGxhY2UoL1xcXFwvZywgXCJfXCIpLnJlcGxhY2UoLzwvZywgXCJfXCIpLnJlcGxhY2UoLz4vZywgXCJfXCIpXG5cdFx0XHRcdFx0LnJlcGxhY2UoL14ocGFyZW50XFxkKylfIC8sIFwiJDE6IFwiKVxuXHRcdFx0XHRcdC5yZXBsYWNlKC9eKHRpdGxlXFxkKylfIC8sIFwiJDE6IFwiKVxuXHRcdFx0XHRcdClcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyBmaW5kIG5leHQgYnJva2VuIGxpbmtcblx0XHRcdFx0XHRjb25zdCB1bnJlc29sdmVkTGlua3M6IFJlY29yZDxzdHJpbmcsIFJlY29yZDxzdHJpbmcsIG51bWJlcj4+ID0gdGhpcy5hcHAubWV0YWRhdGFDYWNoZS51bnJlc29sdmVkTGlua3M7XG5cdFx0XHRcdFx0Y29uc3QgYnJva2VuTGlua1JlY29yZDogUmVjb3JkPHN0cmluZywgbnVtYmVyPiA9IHVucmVzb2x2ZWRMaW5rc1t2aWV3LmZpbGUucGF0aF1cblx0XHRcdFx0XHRpZiAoYnJva2VuTGlua1JlY29yZCA9PSBudWxsKSB7XG5cdFx0XHRcdFx0XHRuZXcgTm90aWNlKFwiTm8gYnJva2VuIGxpbmsgZm91bmQgaW4gdGhpcyBmaWxlXCIpXHRcblx0XHRcdFx0XHRcdHJldHVyblxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjb25zdCBicm9rZW5MaW5rcyA9IE9iamVjdC5rZXlzKGJyb2tlbkxpbmtSZWNvcmQpXG5cdFx0XHRcdFx0aWYgKGJyb2tlbkxpbmtzID09IG51bGwgfHwgYnJva2VuTGlua3MubGVuZ3RoID09IDApIHtcblx0XHRcdFx0XHRcdG5ldyBOb3RpY2UoXCJObyBicm9rZW4gbGluayBmb3VuZCBpbiB0aGlzIGZpbGVcIilcdFxuXHRcdFx0XHRcdFx0cmV0dXJuXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGZvciAobGV0IGkgPSBsaW5lICsgMTsgaSA8IGVkaXRvci5saW5lQ291bnQoKTsgaSsrKSB7XG5cdFx0XHRcdFx0XHRjb25zdCBsaW5lQ29udGVudCA9IGVkaXRvci5nZXRMaW5lKGkpXG5cdFx0XHRcdFx0XHRmb3IgKGxldCBiID0gMDsgYiA8IGJyb2tlbkxpbmtzLmxlbmd0aDsgYisrKSB7XG5cdFx0XHRcdFx0XHRcdGNvbnN0IGJyb2tlbkxpbmsgPSBicm9rZW5MaW5rc1tiXVxuXHRcdFx0XHRcdFx0XHRpZiAobGluZUNvbnRlbnQuY29udGFpbnMoXCJbW1wiICsgYnJva2VuTGluayArIFwiXV1cIikpIHtcblx0XHRcdFx0XHRcdFx0XHRlZGl0b3Iuc2V0Q3Vyc29yKHtsaW5lOiBpLCBjaDogMH0pXG5cdFx0XHRcdFx0XHRcdFx0ZWRpdG9yLnNjcm9sbEludG9WaWV3KHtmcm9tOiB7bGluZTogaSwgY2g6IDB9LCB0bzoge2xpbmU6IGksIGNoOiAwfX0sIHRydWUpXG5cdFx0XHRcdFx0XHRcdFx0bmV3IE5vdGljZShcIk5hdmlnYXRlZCB0byBuZXh0IEJyb2tlbiBsaW5rIHN0YXJ0aW5nIGZyb20gY3Vyc29yXCIpXG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0bmV3IE5vdGljZShcIk5vIGJyb2tlbiBsaW5rIGZvdW5kIGFmdGVyIGN1cnNvciBsaW5lIGluIHRoaXMgZmlsZVwiKVx0XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuXG5cdFx0XHR9XG5cdFx0XHRsZXQgY291bnQgPSAwXG5cdFx0XHRsZXQgcmVzdWx0ID0gXCJcIlxuXHRcdFx0Y29uc3QgdW5yZXNvbHZlZExpbmtzOiBSZWNvcmQ8c3RyaW5nLCBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+PiA9IHRoaXMuYXBwLm1ldGFkYXRhQ2FjaGUudW5yZXNvbHZlZExpbmtzO1x0XG5cdFx0XHQvLyB0aGVuIGxvb3AgdGhlIHJlY29yZCBkYXRhIGluIGNvbnNvbGVcblx0XHRcdGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHVucmVzb2x2ZWRMaW5rcykpIHtcblx0XHRcdFx0bGV0IHYgPSAnJ1xuXHRcdFx0XHRmb3IgKGNvbnN0IFtrMSwgdjFdIG9mIE9iamVjdC5lbnRyaWVzKHZhbHVlKSkge1xuXHRcdFx0XHRcdHYgKz0gazEgKyBcIjpcIiArIHYxICsgXCIsIFwiXG5cdFx0XHRcdH1cblx0XHRcdFx0diA9IHYucmVwbGFjZSgvLCAkLywgXCJcIilcblx0XHRcdFx0aWYgKHYgIT09IFwiXCIpIHtcblx0XHRcdFx0XHQvL2NvbnNvbGUubG9nKGtleSArICcgLT4gWycgKyB2ICsgJ10nKVxuXHRcdFx0XHRcdHJlc3VsdCArPSBcIi0gW1tcIiArIGtleS5yZXBsYWNlKC9cXC5tZCQvLFwiXCIpICsgJ11dJy8vIDogWycgKyB2ICsgJ10nXG5cdFx0XHRcdFx0cmVzdWx0ICs9IFwiXFxuXCJcblx0XHRcdFx0XHRmb3IgKGNvbnN0IFtrMiwgdjJdIG9mIE9iamVjdC5lbnRyaWVzKHZhbHVlKSkge1xuXHRcdFx0XHRcdFx0cmVzdWx0ICs9IFwiXFx0LSBcIiArIGsyLnJlcGxhY2UoL1xcLm1kJC8sXCJcIikgKyAnJ1xuXHRcdFx0XHRcdFx0cmVzdWx0ICs9IFwiXFxuXCJcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y291bnQrK1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRlZGl0b3Iuc2V0VmFsdWUocmVzdWx0KVxuXHRcdFx0bmV3IE5vdGljZShcIlVwZGF0ZWQgYnJva2VuIGxpbmsuIGNvdW50PVwiICsgY291bnQpXG5cdFx0XHQvKlxuXHRcdFx0bmF2aWdhdG9yLmNsaXBib2FyZC53cml0ZVRleHQocmVzdWx0KS50aGVuKCgpID0+IHtcblx0XHRcdFx0bmV3IE5vdGljZShcImNvdW50PVwiICsgY291bnQpXG5cdFx0XHRcdG5ldyBOb3RpY2UoXCJjb3BpZWQgcmVzdWx0IHRvIGNsaXBib2FyZCFcIilcblx0XHRcdH0pXG5cdFx0XHQqL1xuXHRcdH0sXG5cdFx0aG90a2V5czogW1xuXHRcdFx0e1xuXHRcdFx0XHRtb2RpZmllcnM6IFtgQ3RybGAsIGBNZXRhYCwgYFNoaWZ0YF0sXG5cdFx0XHRcdGtleTogYDVgLFxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0bW9kaWZpZXJzOiBbYEN0cmxgLCBgQWx0YCwgYFNoaWZ0YF0sXG5cdFx0XHRcdGtleTogYDVgLFxuXHRcdFx0fSxcblx0XHRdXG5cdH0pO1xuXG5cdHRoaXMuYWRkQ29tbWFuZCh7XG5cdFx0aWQ6IFwicHJldmlvdXMtdW5maW5pc2hlZC1hY3Rpb25cIixcblx0XHRuYW1lOiBcIlBBIFByZXZpb3VzIHVuZmluaXNoZWQgYWN0aW9uXCIsXG5cdFx0aWNvbjogXCJjaGV2cm9ucy11cFwiLFxuXHRcdGVkaXRvckNhbGxiYWNrOiAoZWRpdG9yOiBFZGl0b3IsIHZpZXc6IE1hcmtkb3duVmlldykgPT4ge1x0XHRcdFx0XG5cdFx0XHRjb25zdCBjdXJzb3IgPSBlZGl0b3IuZ2V0Q3Vyc29yKClcblx0XHRcdGNvbnN0IGxpbmUgPSBjdXJzb3IubGluZVxuXHRcdFx0Y29uc3QgbGluZUNvbnRlbnQgPSBlZGl0b3IuZ2V0TGluZShsaW5lKVxuXHRcdFx0Zm9yIChsZXQgaSA9IGxpbmUgLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0XHRjb25zdCBsaW5lQ29udGVudCA9IGVkaXRvci5nZXRMaW5lKGkpXG5cdFx0XHRcdGlmICgvICNbbnddW25sd10vLnRlc3QobGluZUNvbnRlbnQpIHx8IC8jW253XVtubHddIC8udGVzdChsaW5lQ29udGVudCkgfHwgLyAjdFt0bWVdLy50ZXN0KGxpbmVDb250ZW50KSB8fCAvI3RbdG1lXSAvLnRlc3QobGluZUNvbnRlbnQpKSB7XG5cdFx0XHRcdFx0ZWRpdG9yLnNldEN1cnNvcih7bGluZTogaSwgY2g6IDB9KVxuXHRcdFx0XHRcdGVkaXRvci5zY3JvbGxJbnRvVmlldyh7ZnJvbToge2xpbmU6IGksIGNoOiAwfSwgdG86IHtsaW5lOiBpLCBjaDogMH19LCB0cnVlKVxuXHRcdFx0XHRcdG5ldyBOb3RpY2UoXCJOYXZpZ2F0ZWQgdG8gcHJldmlvdXMgdW5maW5pc2hlZCBhY3Rpb24gc3RhcnRpbmcgZnJvbSBjdXJzb3JcIilcblx0XHRcdFx0XHRyZXR1cm5cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0bmV3IE5vdGljZShcIk5vIHVuZmluaXNoZWQgYWN0aW9uIGZvdW5kIGFmdGVyIGN1cnNvciBsaW5lIGluIHRoaXMgZmlsZVwiKVx0XG5cdFx0fSxcblx0XHRob3RrZXlzOiBbXG5cdFx0XHR7XG5cdFx0XHRcdG1vZGlmaWVyczogW2BDdHJsYCwgYE1ldGFgLCBgU2hpZnRgXSxcblx0XHRcdFx0a2V5OiBga2AsXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRtb2RpZmllcnM6IFtgQ3RybGAsIGBBbHRgLCBgU2hpZnRgXSxcblx0XHRcdFx0a2V5OiBga2AsXG5cdFx0XHR9LFxuXHRcdF1cblx0fSk7XG5cblx0dGhpcy5hZGRDb21tYW5kKHtcblx0XHRpZDogXCJuZXh0LXVuZmluaXNoZWQtYWN0aW9uXCIsXG5cdFx0bmFtZTogXCJOQSBOZXh0IHVuZmluaXNoZWQgYWN0aW9uXCIsXG5cdFx0aWNvbjogXCJjaGV2cm9ucy1kb3duXCIsXG5cdFx0ZWRpdG9yQ2FsbGJhY2s6IChlZGl0b3I6IEVkaXRvciwgdmlldzogTWFya2Rvd25WaWV3KSA9PiB7XHRcdFx0XHRcblx0XHRcdGNvbnN0IGN1cnNvciA9IGVkaXRvci5nZXRDdXJzb3IoKVxuXHRcdFx0Y29uc3QgbGluZSA9IGN1cnNvci5saW5lXG5cdFx0XHRjb25zdCBsaW5lQ29udGVudCA9IGVkaXRvci5nZXRMaW5lKGxpbmUpXG5cdFx0XHRmb3IgKGxldCBpID0gbGluZSArIDE7IGkgPCBlZGl0b3IubGluZUNvdW50KCk7IGkrKykge1xuXHRcdFx0XHRjb25zdCBsaW5lQ29udGVudCA9IGVkaXRvci5nZXRMaW5lKGkpXG5cdFx0XHRcdGlmICgvICNbbnddW25sd10vLnRlc3QobGluZUNvbnRlbnQpIHx8IC8jW253XVtubHddIC8udGVzdChsaW5lQ29udGVudCkgfHwgLyAjdFt0bWVdLy50ZXN0KGxpbmVDb250ZW50KSB8fCAvI3RbdG1lXSAvLnRlc3QobGluZUNvbnRlbnQpKSB7XG5cdFx0XHRcdFx0ZWRpdG9yLnNldEN1cnNvcih7bGluZTogaSwgY2g6IDB9KVxuXHRcdFx0XHRcdGVkaXRvci5zY3JvbGxJbnRvVmlldyh7ZnJvbToge2xpbmU6IGksIGNoOiAwfSwgdG86IHtsaW5lOiBpLCBjaDogMH19LCB0cnVlKVxuXHRcdFx0XHRcdG5ldyBOb3RpY2UoXCJOYXZpZ2F0ZWQgdG8gbmV4dCB1bmZpbmlzaGVkIGFjdGlvbiBzdGFydGluZyBmcm9tIGN1cnNvclwiKVxuXHRcdFx0XHRcdHJldHVyblxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRuZXcgTm90aWNlKFwiTm8gdW5maW5pc2hlZCBhY3Rpb24gZm91bmQgYWZ0ZXIgY3Vyc29yIGxpbmUgaW4gdGhpcyBmaWxlXCIpXHRcblx0XHR9LFxuXHRcdGhvdGtleXM6IFtcblx0XHRcdHtcblx0XHRcdFx0bW9kaWZpZXJzOiBbYEN0cmxgLCBgTWV0YWAsIGBTaGlmdGBdLFxuXHRcdFx0XHRrZXk6IGBqYCxcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG1vZGlmaWVyczogW2BDdHJsYCwgYEFsdGAsIGBTaGlmdGBdLFxuXHRcdFx0XHRrZXk6IGBqYCxcblx0XHRcdH0sXG5cdFx0XVxuXHR9KTtcblxuXG5cdFx0XHR0aGlzLmFkZENvbW1hbmQoe1xuXHRcdFx0aWQ6IFwib3Blbi10YWctc2VhcmNoXCIsXG5cdFx0XHRuYW1lOiBcIk9wZW4gdGFnIHNlYXJjaFwiLFxuXHRcdFx0aWNvbjogXCJoYXNoXCIsXG5cdFx0XHRjYWxsYmFjazogKCkgPT4ge1xuXHRcdFx0XHQvKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55ICovXG5cdFx0XHRcdGNvbnN0IHNlYXJjaFBsdWdpbiA9IChcblx0XHRcdFx0XHR0aGlzLmFwcCBhcyBhbnlcblx0XHRcdFx0KS5pbnRlcm5hbFBsdWdpbnMuZ2V0UGx1Z2luQnlJZChcImdsb2JhbC1zZWFyY2hcIik7XG5cdFx0XHRcdC8qIGVzbGludC1lbmFibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSAqL1xuXHRcdFx0XHRjb25zdCBzZWFyY2ggPSBzZWFyY2hQbHVnaW4gJiYgc2VhcmNoUGx1Z2luLmluc3RhbmNlO1xuXG5cdFx0XHRcdGlmIChzZWFyY2hQbHVnaW4gJiYgc2VhcmNoUGx1Z2luLmluc3RhbmNlKSB7XG5cdFx0XHRcdFx0bmV3IFRhZ1NlYXJjaE1vZGFsKHRoaXMuYXBwLCBzZWFyY2gsIHRoaXMucGx1Z2luKS5vcGVuKCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0bmV3IE5vdGljZShcIlBsZWFzZSBlbmFibGUgdGhlIHNlYXJjaCBjb3JlIHBsdWdpbiFcIik7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRob3RrZXlzOiBbXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRtb2RpZmllcnM6IFtgQ3RybGAsIGBNZXRhYCwgYFNoaWZ0YF0sXG5cdFx0XHRcdFx0a2V5OiBgc2AsXG5cdFx0XHRcdH0sXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRtb2RpZmllcnM6IFtgQ3RybGAsIGBBbHRgLCBgU2hpZnRgXSxcblx0XHRcdFx0XHRrZXk6IGBzYCxcblx0XHRcdFx0fSxcblx0XHRcdF1cblx0XHR9KTtcblxuXHRcdHRoaXMuYWRkQ29tbWFuZCh7XG5cdFx0XHRpZDogXCJvcGVuLXRhZy1zZWFyY2hcIixcblx0XHRcdG5hbWU6IFwiT3BlbiB0YWcgc2VhcmNoXCIsXG5cdFx0XHRpY29uOiBcImhhc2hcIixcblx0XHRcdGNhbGxiYWNrOiAoKSA9PiB7XG5cdFx0XHRcdC8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnkgKi9cblx0XHRcdFx0Y29uc3Qgc2VhcmNoUGx1Z2luID0gKFxuXHRcdFx0XHRcdHRoaXMuYXBwIGFzIGFueVxuXHRcdFx0XHQpLmludGVybmFsUGx1Z2lucy5nZXRQbHVnaW5CeUlkKFwiZ2xvYmFsLXNlYXJjaFwiKTtcblx0XHRcdFx0LyogZXNsaW50LWVuYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55ICovXG5cdFx0XHRcdGNvbnN0IHNlYXJjaCA9IHNlYXJjaFBsdWdpbiAmJiBzZWFyY2hQbHVnaW4uaW5zdGFuY2U7XG5cblx0XHRcdFx0aWYgKHNlYXJjaFBsdWdpbiAmJiBzZWFyY2hQbHVnaW4uaW5zdGFuY2UpIHtcblx0XHRcdFx0XHRuZXcgVGFnU2VhcmNoTW9kYWwodGhpcy5hcHAsIHNlYXJjaCwgdGhpcy5wbHVnaW4pLm9wZW4oKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRuZXcgTm90aWNlKFwiUGxlYXNlIGVuYWJsZSB0aGUgc2VhcmNoIGNvcmUgcGx1Z2luIVwiKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGhvdGtleXM6IFtcblx0XHRcdFx0e1xuXHRcdFx0XHRcdG1vZGlmaWVyczogW2BDdHJsYCwgYE1ldGFgLCBgU2hpZnRgXSxcblx0XHRcdFx0XHRrZXk6IGBzYCxcblx0XHRcdFx0fSxcblx0XHRcdFx0e1xuXHRcdFx0XHRcdG1vZGlmaWVyczogW2BDdHJsYCwgYEFsdGAsIGBTaGlmdGBdLFxuXHRcdFx0XHRcdGtleTogYHNgLFxuXHRcdFx0XHR9LFxuXHRcdFx0XVxuXHRcdH0pO1xuXG5cdFx0XG5cdFx0dGhpcy5hZGRDb21tYW5kKHtcblx0XHRcdGlkOiBcInF1ZXJ5LW9ycGhhbi1ub3Rlcy1ieS10YWdcIixcblx0XHRcdG5hbWU6IFwiUXVlcnkgb3JwaGFuIG5vdGVzIGJ5IHRhZ1wiLFxuXHRcdFx0ZWRpdG9yQ2FsbGJhY2s6IChlZGl0b3I6IEVkaXRvciwgdmlldzogTWFya2Rvd25WaWV3KSA9PiB7XG5cdFx0XHRcdG5ldyBRdWVyeU9ycGhhbk5vdGVzQnlUYWdNb2RhbCh0aGlzLmFwcCwgZWRpdG9yLCB2aWV3KS5vcGVuKClcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdHRoaXMuYWRkT2JzaWRpYW5JY29uKCdvYnNpZGlhbi1wYXN0ZScsICdcdTIzMThWJyk7XG5cdFx0dGhpcy5hZGRDb21tYW5kKHtcblx0XHRcdGlkOiBcIm9ic2lkaWFuLXBhc3RlXCIsXG5cdFx0XHRuYW1lOiBcIk9ic2lkaWFuIFBhc3RlXCIsXG5cdFx0XHRpY29uOiBcIm9ic2lkaWFuLXBhc3RlXCIsXG5cdFx0XHRlZGl0b3JDYWxsYmFjazogKGVkaXRvcjogRWRpdG9yLCB2aWV3OiBNYXJrZG93blZpZXcpID0+IHtcblx0XHRcdFx0bmV3IENsaXBib2FyZFBhc3RlTW9kYWwodGhpcy5hcHAsIGVkaXRvciwgY2xpcGJvYXJkSGlzdG9yeSkub3BlbigpO1x0XHRcblx0XHRcdH0sXG5cdFx0XHRob3RrZXlzOiBbXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRtb2RpZmllcnM6IFtgTWV0YWAsIGBTaGlmdGBdLFxuXHRcdFx0XHRcdGtleTogYHZgLFxuXHRcdFx0XHR9XG5cdFx0XHRdXG5cdFx0fSk7XG5cblx0XHR0aGlzLmFkZE9ic2lkaWFuSWNvbigndXBkYXRlLW5vdGUtdHlwZS1pY29uJywgJ05UJyk7XG5cdFx0dGhpcy5hZGRDb21tYW5kKHtcblx0XHRcdGlkOiBcInVwZGF0ZS1ub3RlLXR5cGVcIixcblx0XHRcdG5hbWU6IFwiVXBkYXRlIE5vdGUgVHlwZVwiLFxuXHRcdFx0aWNvbjogYHVwZGF0ZS1ub3RlLXR5cGUtaWNvbmAsXG5cdFx0XHRlZGl0b3JDYWxsYmFjazogKGVkaXRvcjogRWRpdG9yLCB2aWV3OiBNYXJrZG93blZpZXcpID0+IHtcblx0XHRcdCAgbmV3IFVwZGF0ZU5vdGVUeXBlTW9kYWwodGhpcy5hcHAsIGVkaXRvciwgdmlldy5maWxlKS5vcGVuKCk7XG5cdFx0XHR9LFxuXHRcdFx0aG90a2V5czogW1xuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bW9kaWZpZXJzOiBbYEN0cmxgLCBgTWV0YWAsIGBTaGlmdGBdLFxuXHRcdFx0XHRcdGtleTogYGNgLFxuXHRcdFx0XHR9LFxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bW9kaWZpZXJzOiBbYEN0cmxgLCBgQWx0YCwgYFNoaWZ0YF0sXG5cdFx0XHRcdFx0a2V5OiBgY2AsXG5cdFx0XHRcdH0sXG5cdFx0XHRdXG5cdFx0fSk7XG5cblxuXHRcdC8vIGNvbWJpbmVkIHZlcnNpb25cblx0XHQvL3RoaXMudXBkYXRlU2NoZWR1bGluZ0ljb24oKVxuXHRcdHRoaXMuYWRkQ29tbWFuZCh7XG5cdFx0XHRpZDogXCJvcGVuLXJlY2VudC1kYXlzLXNjaGVkdWxlLXdpdGgtdXBkYXRlZC1zY2hlZHVsZVwiLFxuXHRcdFx0bmFtZTogXCJPUiBPcGVuIFJlY2VudCBEYXlzIFVwZGF0ZWQgU2NoZWR1bGVcIixcblx0XHRcdGljb246IFwib3Blbi1yZWNlbnQtZGF5LXNjaGVkdWxlLWljb25cIixcblx0XHRcdGNhbGxiYWNrOiBhc3luYyAoKSA9PiB7XG5cdFx0XHRcdC8vIHVwZGF0ZSBzY2hlZHVsaW5nIHBhcnRcblx0XHRcdFx0Y29uc3QgeyB2YXVsdCB9ID0gdGhpcy5hcHA7XG5cdFx0XHRcdGNvbnN0IHNjaGVkdWxlTm90ZVdpdGhvdXRNZCA9IFwiRC9TY2hlZHVsaW5nXCJcblx0XHRcdFx0Y29uc3Qgc2NoZWR1bGVOb3RlID0gYCR7c2NoZWR1bGVOb3RlV2l0aG91dE1kfS5tZGBcdFx0XHRcdFxuXHRcdFx0XHRpZiAodmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKHNjaGVkdWxlTm90ZSkgPT0gbnVsbCkge1xuXHRcdFx0XHRcdGF3YWl0IHZhdWx0LmNyZWF0ZShzY2hlZHVsZU5vdGUsIFwiXCIpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGxldCBub3RlQ29udGVudCA9ICcnXG5cdFx0XHRcdEFycmF5LmZyb20oQXJyYXkoNykua2V5cygpKS5mb3JFYWNoKGkgPT4gbm90ZUNvbnRlbnQgKz0gdGhpcy5nZXRRdWVyeURhdGVTdHJpbmcoaSwgc2NoZWR1bGVOb3RlV2l0aG91dE1kKSk7XG5cdFx0XHRcdHZhdWx0Lm1vZGlmeSh2YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgoc2NoZWR1bGVOb3RlKSBhcyBURmlsZSwgbm90ZUNvbnRlbnQpO1xuXG5cdFx0XHRcdHRoaXMuYWRkQWN0aW9uTm90ZUNvbnRlbnQodmF1bHQsIFwiRFwiLCBcIlF1ZXJ5IFcgbm93IGFjdGlvbnNcIiwgXCJXZWVrbHkgU2NoZWR1bGUgV1wiLCBcIndcIilcblx0XHRcdFx0dGhpcy5hZGRBY3Rpb25Ob3RlQ29udGVudCh2YXVsdCwgXCJEXCIsIFwiUXVlcnkgTiBub3cgYWN0aW9uc1wiLCBcIldlZWtseSBTY2hlZHVsZSBOXCIsIFwiblwiKVxuXHRcdFx0XHR0aGlzLmFkZDNEYXlzQWN0aW9uTm90ZUNvbnRlbnQodmF1bHQpO1xuXHRcdFx0XHRuZXcgTm90aWNlKFwiVXBkYXRlZCBzY2hlZHVsZVwiKTtcblxuXHRcdFx0XHQvLyBvcGVuIHNjaGVkdWxlIHBhcnRcblx0XHRcdFx0Y29uc3QgeyB3b3Jrc3BhY2UgfSA9IHRoaXMuYXBwO1xuXHRcdFx0XHRjb25zdCBkYXNoYm9hcmRDYW52YXMgPSBcIkQvUXVlcnkgU2NoZWR1bGUgYW5kIEFjdGlvbnMgbmV4dCAzIGRheXMubWRcIlxuXHRcdFx0XHRjb25zdCBtb2RlID0gKHRoaXMuYXBwLnZhdWx0IGFzIGFueSkuZ2V0Q29uZmlnKFwiZGVmYXVsdFZpZXdNb2RlXCIpO1xuXHRcdFx0XHRjb25zdCBsZWFmID0gd29ya3NwYWNlLmdldExlYWYoZmFsc2UpO1xuXHRcdFx0XHRhd2FpdCBsZWFmLm9wZW5GaWxlKHZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aChkYXNoYm9hcmRDYW52YXMpIGFzIFRGaWxlLCB7IGFjdGl2ZSA6IHRydWUsLyogbW9kZSAqL30pO1xuXHRcdFx0fVxuXHRcdH0pXG5cblx0XHR0aGlzLmFkZE9ic2lkaWFuSWNvbigndXBkYXRlLXNjaGVkdWxpbmctaWNvbicsICdVUycpO1xuXHRcdHRoaXMuYWRkQ29tbWFuZCh7XG5cdFx0XHRpZDogXCJ1cGRhdGUtc2NoZWR1bGluZ1wiLFxuXHRcdFx0bmFtZTogXCJVcGRhdGUgU2NoZWR1bGluZ1wiLFxuXHRcdFx0aWNvbjogXCJ1cGRhdGUtc2NoZWR1bGluZy1pY29uXCIsXG5cdFx0XHRjYWxsYmFjazogYXN5bmMgKCkgPT4ge1xuXHRcdFx0XHRjb25zdCB7IHZhdWx0IH0gPSB0aGlzLmFwcDtcblx0XHRcdFx0Y29uc3Qgc2NoZWR1bGVOb3RlV2l0aG91dE1kID0gXCJEL1NjaGVkdWxpbmdcIlxuXHRcdFx0XHRjb25zdCBzY2hlZHVsZU5vdGUgPSBgJHtzY2hlZHVsZU5vdGVXaXRob3V0TWR9Lm1kYFx0XHRcdFx0XG5cdFx0XHRcdGlmICh2YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgoc2NoZWR1bGVOb3RlKSA9PSBudWxsKSB7XG5cdFx0XHRcdFx0YXdhaXQgdmF1bHQuY3JlYXRlKHNjaGVkdWxlTm90ZSwgXCJcIik7XG5cdFx0XHRcdH1cblx0XHRcdFx0bGV0IG5vdGVDb250ZW50ID0gJydcblx0XHRcdFx0QXJyYXkuZnJvbShBcnJheSg3KS5rZXlzKCkpLmZvckVhY2goaSA9PiBub3RlQ29udGVudCArPSB0aGlzLmdldFF1ZXJ5RGF0ZVN0cmluZyhpLCBzY2hlZHVsZU5vdGVXaXRob3V0TWQpKTtcblx0XHRcdFx0dmF1bHQubW9kaWZ5KHZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aChzY2hlZHVsZU5vdGUpIGFzIFRGaWxlLCBub3RlQ29udGVudCk7XG5cblx0XHRcdFx0dGhpcy5hZGRBY3Rpb25Ob3RlQ29udGVudCh2YXVsdCwgXCJEXCIsIFwiUXVlcnkgVyBub3cgYWN0aW9uc1wiLCBcIldlZWtseSBTY2hlZHVsZSBXXCIsIFwid1wiKVxuXHRcdFx0XHR0aGlzLmFkZEFjdGlvbk5vdGVDb250ZW50KHZhdWx0LCBcIkRcIiwgXCJRdWVyeSBOIG5vdyBhY3Rpb25zXCIsIFwiV2Vla2x5IFNjaGVkdWxlIE5cIiwgXCJuXCIpXG5cdFx0XHRcdHRoaXMuYWRkM0RheXNBY3Rpb25Ob3RlQ29udGVudCh2YXVsdCk7XG5cdFx0XHRcdG5ldyBOb3RpY2UoXCJVcGRhdGVkIHNjaGVkdWxlXCIpO1xuXHRcdFx0fS8qLFxuXHRcdFx0aG90a2V5czogW1xuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bW9kaWZpZXJzOiBbYEN0cmxgLCBgTWV0YWAsIGBTaGlmdGBdLFxuXHRcdFx0XHRcdGtleTogYHVgLFxuXHRcdFx0XHR9LFxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bW9kaWZpZXJzOiBbYEN0cmxgLCBgQWx0YCwgYFNoaWZ0YF0sXG5cdFx0XHRcdFx0a2V5OiBgdWAsXG5cdFx0XHRcdH0sXG5cdFx0XHRdKi9cblx0XHR9KVxuXG5cdFx0Lypcblx0XHR0aGlzLmFkZE9ic2lkaWFuSWNvbignb3Blbi1kYXNoYm9hcmQtaWNvbicsICdPRCcpO1xuXHRcdHRoaXMuYWRkQ29tbWFuZCh7XG5cdFx0XHRpZDogXCJvcGVuLWRhc2hib2FyZFwiLFxuXHRcdFx0bmFtZTogXCJPcGVuIERhc2hib2FyZFwiLFxuXHRcdFx0aWNvbjogXCJvcGVuLWRhc2hib2FyZC1pY29uXCIsXG5cdFx0XHRjYWxsYmFjazogYXN5bmMgKCkgPT4ge1xuXHRcdFx0XHRjb25zdCB7IHZhdWx0IH0gPSB0aGlzLmFwcDtcblx0XHRcdFx0Y29uc3QgeyB3b3Jrc3BhY2UgfSA9IHRoaXMuYXBwO1xuXHRcdFx0XHRjb25zdCBkYXNoYm9hcmRDYW52YXMgPSBcIkQvRGFzaGJvYXJkLmNhbnZhc1wiXG5cdFx0XHRcdGNvbnN0IG1vZGUgPSAodGhpcy5hcHAudmF1bHQgYXMgYW55KS5nZXRDb25maWcoXCJkZWZhdWx0Vmlld01vZGVcIik7XG5cdFx0XHRcdGNvbnN0IGxlYWYgPSB3b3Jrc3BhY2UuZ2V0TGVhZihmYWxzZSk7XG5cdFx0XHRcdGF3YWl0IGxlYWYub3BlbkZpbGUodmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKGRhc2hib2FyZENhbnZhcykgYXMgVEZpbGUsIHsgYWN0aXZlIDogdHJ1ZX0pO1xuXHRcdFx0fSxcblx0XHR9KVxuXHRcdCovXG5cblx0XHR0aGlzLmFkZE9ic2lkaWFuSWNvbignb3Blbi1yZWNlbnQtZGF5LXNjaGVkdWxlLWljb24nLCAnT1InKTtcblx0XHR0aGlzLmFkZENvbW1hbmQoe1xuXHRcdFx0aWQ6IFwib3Blbi1yZWNlbnQtZGF5cy1zY2hlZHVsZVwiLFxuXHRcdFx0bmFtZTogXCJPcGVuIFJlY2VudCBEYXlzIFNjaGVkdWxlXCIsXG5cdFx0XHRpY29uOiBcIm9wZW4tcmVjZW50LWRheS1zY2hlZHVsZS1pY29uXCIsXG5cdFx0XHRjYWxsYmFjazogYXN5bmMgKCkgPT4ge1xuXHRcdFx0XHRjb25zdCB7IHZhdWx0LCB3b3Jrc3BhY2UgfSA9IHRoaXMuYXBwO1xuXHRcdFx0XHRjb25zdCBkYXNoYm9hcmRDYW52YXMgPSBcIkQvUXVlcnkgU2NoZWR1bGUgYW5kIEFjdGlvbnMgbmV4dCAzIGRheXMubWRcIlxuXHRcdFx0XHRjb25zdCBsZWFmID0gd29ya3NwYWNlLmdldExlYWYoZmFsc2UpO1xuXHRcdFx0XHRhd2FpdCBsZWFmLm9wZW5GaWxlKHZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aChkYXNoYm9hcmRDYW52YXMpIGFzIFRGaWxlLCB7IGFjdGl2ZSA6IHRydWUgfSk7XG5cdFx0XHR9LFxuXHRcdH0pXG5cblx0XHR0aGlzLmFkZE9ic2lkaWFuSWNvbignb3Blbi1pbmJveC1pY29uJywgJ09JJyk7XG5cdFx0dGhpcy5hZGRDb21tYW5kKHtcblx0XHRcdGlkOiBcIm9wZW4taW5ib3hcIixcblx0XHRcdG5hbWU6IFwiT0kgT3BlbiBJbmJveFwiLFxuXHRcdFx0aWNvbjogXCJvcGVuLWluYm94LWljb25cIixcblx0XHRcdGNhbGxiYWNrOiBhc3luYyAoKSA9PiB7XG5cdFx0XHRcdGNvbnN0IHsgdmF1bHQsIHdvcmtzcGFjZSB9ID0gdGhpcy5hcHA7XG5cdFx0XHRcdGNvbnN0IGluYm94TWQgPSBcIkkvSW5ib3gubWRcIlxuXHRcdFx0XHRjb25zdCBsZWFmID0gd29ya3NwYWNlLmdldExlYWYoZmFsc2UpO1xuXHRcdFx0XHRhd2FpdCBsZWFmLm9wZW5GaWxlKHZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aChpbmJveE1kKSBhcyBURmlsZSwgeyBhY3RpdmUgOiB0cnVlIH0pO1xuXG5cdFx0XHRcdC8vIFdhaXQgZm9yIHRoZSBmaWxlIHRvIGJlIGZ1bGx5IGxvYWRlZFxuXHRcdFx0XHRjb25zdCB2aWV3ID0gdGhpcy5hcHAud29ya3NwYWNlLmdldEFjdGl2ZVZpZXdPZlR5cGUoTWFya2Rvd25WaWV3KTtcblx0XHRcdFx0aWYgKHZpZXcpIHtcblx0XHRcdFx0XHRjb25zdCBlZGl0b3IgPSB2aWV3LmVkaXRvcjtcblx0XHRcdFx0XHRjb25zdCBsaW5lID0gZWRpdG9yLmxhc3RMaW5lKCk7XG5cdFx0XHRcdFx0Y29uc3QgY2ggPSBlZGl0b3IuZ2V0TGluZShsaW5lKS5sZW5ndGg7XG5cdFx0XHRcdFx0ZWRpdG9yLnNldEN1cnNvcih7IGxpbmU6IGxpbmUsIGNoOiBjaCB9KTsgLy8gTW92ZSBjdXJzb3IgdG8gbGluZSAxMCwgY29sdW1uIDBcblx0XHRcdFx0XHRlZGl0b3Iuc2Nyb2xsSW50b1ZpZXcoeyBmcm9tOiB7IGxpbmU6IGxpbmUsIGNoOiAwIH0sIHRvOiB7IGxpbmU6IGxpbmUsIGNoOiAwIH0gfSwgdHJ1ZSk7IC8vIFNjcm9sbCB0byB0aGUgbGluZVxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdH0pXG5cblx0XHR0aGlzLmFkZE9ic2lkaWFuSWNvbignb3Blbi1wbGF5Z3JvdW5kLWljb24nLCAnT1AnKTtcblx0XHR0aGlzLmFkZENvbW1hbmQoe1xuXHRcdFx0aWQ6IFwib3Blbi1wbGF5Z3JvdW5kXCIsXG5cdFx0XHRuYW1lOiBcIk9QIE9wZW4gUGxheWdyb3VuZFwiLFxuXHRcdFx0aWNvbjogXCJvcGVuLXBsYXlncm91bmQtaWNvblwiLFxuXHRcdFx0Y2FsbGJhY2s6IGFzeW5jICgpID0+IHtcblx0XHRcdFx0bmV3IE9wZW5QbGF5Z3JvdW5kTW9kYWwodGhpcy5hcHApLm9wZW4oKVxuXHRcdFx0fSxcblx0XHRcdGhvdGtleXM6IFtcblx0XHRcdFx0e1xuXHRcdFx0XHRcdG1vZGlmaWVyczogW2BDdHJsYCwgYE1ldGFgLCBgU2hpZnRgXSxcblx0XHRcdFx0XHRrZXk6IGBwYCxcblx0XHRcdFx0fSxcblx0XHRcdFx0e1xuXHRcdFx0XHRcdG1vZGlmaWVyczogW2BDdHJsYCwgYEFsdGAsIGBTaGlmdGBdLFxuXHRcdFx0XHRcdGtleTogYHBgLFxuXHRcdFx0XHR9LFxuXHRcdFx0XVxuXHRcdH0pXG5cblx0XHR0aGlzLmFkZE9ic2lkaWFuSWNvbignb3Blbi1icmFpbmR1bXAtaWNvbicsICdPQicpO1xuXHRcdHRoaXMuYWRkQ29tbWFuZCh7XG5cdFx0XHRpZDogXCJvcGVuLWJyYWluZHVtcFwiLFxuXHRcdFx0bmFtZTogXCJPQiBPcGVuIEJyYWluRHVtcFwiLFxuXHRcdFx0aWNvbjogXCJvcGVuLWJyYWluZHVtcC1pY29uXCIsXG5cdFx0XHRjYWxsYmFjazogYXN5bmMgKCkgPT4ge1xuXHRcdFx0XHRjb25zdCB7IHZhdWx0LCB3b3Jrc3BhY2UgfSA9IHRoaXMuYXBwO1xuXHRcdFx0XHRjb25zdCBpbmJveE1kID0gXCJJL0JyYWluIER1bXAubWRcIlxuXHRcdFx0XHRjb25zdCBsZWFmID0gd29ya3NwYWNlLmdldExlYWYoZmFsc2UpO1xuXHRcdFx0XHRhd2FpdCBsZWFmLm9wZW5GaWxlKHZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aChpbmJveE1kKSBhcyBURmlsZSwgeyBhY3RpdmUgOiB0cnVlIH0pO1xuXHRcdFx0fSxcblx0XHR9KVxuXG5cdFx0dGhpcy5hZGRDb21tYW5kKHtcblx0XHRcdGlkOiBcIm9wZW4tbm90aWNlXCIsXG5cdFx0XHRuYW1lOiBcIk9wZW4gTm90aWNlXCIsXG5cdFx0XHRjYWxsYmFjazogKCkgPT4ge1xuXHRcdFx0XHRuZXcgTm90aWNlKFwiVGVzdCBUZXN0XCIsIDApXG5cdFx0XHR9LFxuXHRcdH0pXG5cblx0XHQvKlxuXHRcdHRoaXMuYWRkQ29tbWFuZCh7XG5cdFx0XHRpZDogXCJvcGVuLWFjdGlvbnNcIixcblx0XHRcdG5hbWU6IFwiT3BlbiBBY3Rpb25zXCIsXG5cdFx0XHRpY29uOiBgYXBlcnR1cmVgLFxuXHRcdFx0ZWRpdG9yQ2FsbGJhY2s6IChlZGl0b3I6IEVkaXRvciwgdmlldzogTWFya2Rvd25WaWV3KSA9PiB7XG5cdFx0XHQgIG5ldyBPcGVuQWN0aW9uc01vZGFsKHRoaXMuYXBwKS5vcGVuKCk7XG5cdFx0XHR9LFxuXHRcdFx0aG90a2V5czogW1xuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bW9kaWZpZXJzOiBbYEN0cmxgLCBgTWV0YWAsIGBTaGlmdGBdLFxuXHRcdFx0XHRcdGtleTogYHhgLFxuXHRcdFx0XHR9LFxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bW9kaWZpZXJzOiBbYEN0cmxgLCBgQWx0YCwgYFNoaWZ0YF0sXG5cdFx0XHRcdFx0a2V5OiBgeGAsXG5cdFx0XHRcdH0sXG5cdFx0XHRdXG5cdFx0fSk7XG5cdFx0Ki9cblxuXHRcdC8vIFRPRE8gcmVtb3ZlIGFmdGVyIFRXIG1pZ3JhdGUgZmluaXNoXG5cdFx0dGhpcy5hZGRPYnNpZGlhbkljb24oJ2Zvcm1hdC1hbGwtbm90ZXMtY3VzdG9tJywgJ0ZBJyk7XG5cdFx0dGhpcy5hZGRDb21tYW5kKHtcblx0XHRcdGlkOiBcImZvcm1hdC1hbGwtbm90ZXMtY3VzdG9tXCIsXG5cdFx0XHRuYW1lOiBcIkZBIEZvcm1hdCBBbGwgTm90ZXMgKEN1c3RvbSB1c2FnZSlcIixcblx0XHRcdGljb246IGBmb3JtYXQtYWxsLW5vdGVzLWN1c3RvbWAsXG5cdFx0XHRjYWxsYmFjazogYXN5bmMgKCkgPT4ge1xuXHRcdFx0XHRjb25zdCB2YXVsdDogVmF1bHQgPSB0aGlzLmFwcC52YXVsdDtcblx0XHRcdFx0XG5cdFx0XHRcdGxldCBzdGFydENvdW50ID0gMFxuXHRcdFx0XHRsZXQgZmluaXNoZWRDb3VudCA9IDBcblx0XHRcdFx0Y29uc3QgZmlsZXMgPSB2YXVsdC5nZXRNYXJrZG93bkZpbGVzKClcblx0XHRcdFx0bmV3IE5vdGljZShcImFsbD1cIiArIGZpbGVzLmxlbmd0aClcblx0XHRcdFx0Y29uc29sZS5sb2coXCJhbGw9XCIgKyBmaWxlcy5sZW5ndGgpXG5cdFx0XHRcdGZvciAoY29uc3QgZmlsZSBvZiBmaWxlcykge1xuXHRcdFx0XHRcdC8vIG5vdGUgdGhhdCBzdGlsbCBhc3luY1xuXHRcdFx0XHRcdGNvbnNvbGUubG9nKFwiczogXCIgKyBzdGFydENvdW50KVxuXHRcdFx0XHRcdHZhdWx0LnJlYWQoZmlsZSkudGhlbigoY29udGVudCkgPT4ge1xuXHRcdFx0XHRcdFx0Y29uc3QgbW9kaWZpZWRWYWx1ZSA9IHRpZHlVcEZyb250TWF0dGVyT25WYWx1ZShjb250ZW50KVxuXHRcdFx0XHRcdFx0cmV0dXJuIHZhdWx0Lm1vZGlmeShmaWxlLCBtb2RpZmllZFZhbHVlKTtcblx0XHRcdFx0XHR9KS50aGVuKCgpID0+IHtcblx0XHRcdFx0XHRcdGNvbnNvbGUubG9nKFwiZjogXCIgKyBmaW5pc2hlZENvdW50KVxuXHRcdFx0XHRcdFx0ZmluaXNoZWRDb3VudCsrXG5cdFx0XHRcdFx0XHRpZiAoZmluaXNoZWRDb3VudCA9PSBmaWxlcy5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdFx0Y29uc29sZS5sb2coXCJmaW5pc2hlZFwiKVxuXHRcdFx0XHRcdFx0XHRuZXcgTm90aWNlKFwiZmluaXNoZWRcIilcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdHN0YXJ0Q291bnQrK1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0aG90a2V5czogW1xuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bW9kaWZpZXJzOiBbYEN0cmxgLCBgTWV0YWAsIGBTaGlmdGBdLFxuXHRcdFx0XHRcdGtleTogYDFgLFxuXHRcdFx0XHR9LFxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bW9kaWZpZXJzOiBbYEN0cmxgLCBgQWx0YCwgYFNoaWZ0YF0sXG5cdFx0XHRcdFx0a2V5OiBgMWAsXG5cdFx0XHRcdH0sXG5cdFx0XHRdXG5cdFx0fSk7XG5cblx0XHQvLyBUT0RPIHJlbW92ZSBhZnRlciBUVyBtaWdyYXRlIGZpbmlzaFxuXHRcdHRoaXMuYWRkT2JzaWRpYW5JY29uKCd0dy1maXgtYnJva2VuLWxpbmsnLCAnOl8nKTtcblx0XHR0aGlzLmFkZENvbW1hbmQoe1xuXHRcdFx0aWQ6IFwidHctZml4LWJyb2tlbi1saW5rXCIsXG5cdFx0XHRuYW1lOiBcIkJMIEZpeCBUVyBCcm9rZW4gTGlua1wiLFxuXHRcdFx0aWNvbjogYHR3LWZpeC1icm9rZW4tbGlua2AsXG5cdFx0XHRlZGl0b3JDYWxsYmFjazogKGVkaXRvcjogRWRpdG9yLCB2aWV3OiBNYXJrZG93blZpZXcpID0+IHtcblx0XHRcdFx0Y29uc3QgY3Vyc29yID0gZWRpdG9yLmdldEN1cnNvcigpXG5cdFx0XHRcdGNvbnN0IGxpbmUgPSBjdXJzb3IubGluZVxuXHRcdFx0XHRjb25zdCBsaW5lQ29udGVudCA9IGVkaXRvci5nZXRMaW5lKGxpbmUpXG5cdFx0XHRcdC8vIHJlcGxhY2UgYWxsIDogdG8gXyBhbmQgcmVwbGFjZSBhbGwgPyB0byBfIGFuZCByZXBsYWNlIGFsbCAvIHRvIF8gYW5kIHJlcGxhY2UgYWxsIC4gdG8gX1xuXHRcdFx0XHRlZGl0b3Iuc2V0TGluZShsaW5lLCBsaW5lQ29udGVudC5yZXBsYWNlKC86L2csIFwiX1wiKS5yZXBsYWNlKC9cXD8vZywgXCJfXCIpLnJlcGxhY2UoL1xcLy9nLCBcIl9cIikucmVwbGFjZSgvPC9nLCBcIl9cIikucmVwbGFjZSgvPi9nLCBcIl9cIilcblx0XHRcdFx0LnJlcGxhY2UoL14ocGFyZW50XFxkKylfIC8sIFwiJDE6IFwiKVxuXHRcdFx0XHQucmVwbGFjZSgvXih0aXRsZVxcZCspXyAvLCBcIiQxOiBcIilcblx0XHRcdFx0KVxuXHRcdFx0fS8qLFxuXHRcdFx0aG90a2V5czogW1xuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bW9kaWZpZXJzOiBbYEN0cmxgLCBgTWV0YWAsIGBTaGlmdGBdLFxuXHRcdFx0XHRcdGtleTogYDVgLFxuXHRcdFx0XHR9LFxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bW9kaWZpZXJzOiBbYEN0cmxgLCBgQWx0YCwgYFNoaWZ0YF0sXG5cdFx0XHRcdFx0a2V5OiBgNWAsXG5cdFx0XHRcdH0sXG5cdFx0XHRdKi9cblx0XHR9KTtcblxuXHRcdC8vIFRPRE8gcmVtb3ZlIGFmdGVyIFRXIG1pZ3JhdGUgZmluaXNoXG5cdFx0dGhpcy5hZGRPYnNpZGlhbkljb24oJ2Zvcm1hdC1ub3Rlcy1jdXN0b20nLCAnRk4nKTtcblx0XHR0aGlzLmFkZENvbW1hbmQoe1xuXHRcdFx0aWQ6IFwiZm9ybWF0LW5vdGVzLWN1c3RvbVwiLFxuXHRcdFx0bmFtZTogXCJGTiBGb3JtYXQgTm90ZXMgKEN1c3RvbSB1c2FnZSlcIixcblx0XHRcdGljb246IGBmb3JtYXQtbm90ZXMtY3VzdG9tYCxcblx0XHRcdGVkaXRvckNhbGxiYWNrOiAoZWRpdG9yOiBFZGl0b3IsIHZpZXc6IE1hcmtkb3duVmlldykgPT4ge1xuXHRcdFx0XHR0aWR5VXBGcm9udE1hdHRlcm9uRWRpdG9yKGVkaXRvcilcblx0XHRcdH0sXG5cdFx0XHRob3RrZXlzOiBbXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRtb2RpZmllcnM6IFtgQ3RybGAsIGBNZXRhYCwgYFNoaWZ0YF0sXG5cdFx0XHRcdFx0a2V5OiBgMmAsXG5cdFx0XHRcdH0sXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRtb2RpZmllcnM6IFtgQ3RybGAsIGBBbHRgLCBgU2hpZnRgXSxcblx0XHRcdFx0XHRrZXk6IGAyYCxcblx0XHRcdFx0fSxcblx0XHRcdF1cblx0XHR9KTtcblxuLy8gVE9ETyByZW1vdmUgYWZ0ZXIgVFcgbWlncmF0ZSBmaW5pc2hcbnRoaXMuYWRkT2JzaWRpYW5JY29uKCd0dy1nZXQtcGFyZW50LWxpbmsnLCAnW10nKTtcbnRoaXMuYWRkQ29tbWFuZCh7XG5cdGlkOiBcInR3LWdldC1wYXJlbnQtbGlua1wiLFxuXHRuYW1lOiBcInR3LWdldC1wYXJlbnQtbGlua1wiLFxuXHRpY29uOiBgdHctZ2V0LXBhcmVudC1saW5rYCxcblx0ZWRpdG9yQ2FsbGJhY2s6IChlZGl0b3I6IEVkaXRvciwgdmlldzogTWFya2Rvd25WaWV3KSA9PiB7XG5cdFx0Ly8gZXhhbXBsZSBjdXJzb3IgbGluZSBpcyBlaXRoZXIgb25lIG9mIGZvbGxvd2luZzpcblx0XHQvLyBwYXJlbnQxOiBcIltbSVRJVklUSSBfIEFTWCBUcmFkaW5nXV1cIlxuXHRcdC8vIC0gcGFyZW50MTogXCJbW0lUSVZJVEkgXyBBU1ggVHJhZGluZ11dXCJcblx0XHQvLyBnb2FsIGlzIHRvIGNvcHkgXCJJVElWSVRJIF8gQVNYIFRyYWRpbmdcIiB0byBjbGlwYm9hcmQgYW5kIHJlbW92ZSB0aGlzIGxpbmVcblx0XHRjb25zdCBjdXJzb3IgPSBlZGl0b3IuZ2V0Q3Vyc29yKClcblx0XHRjb25zdCBsaW5lID0gY3Vyc29yLmxpbmVcblx0XHRjb25zdCBjaCA9IGN1cnNvci5jaFxuXHRcdGNvbnN0IGxpbmVDb250ZW50ID0gZWRpdG9yLmdldExpbmUobGluZSlcblx0XHRpZiAoL15wYXJlbnRcXGQrOiAvLnRlc3QobGluZUNvbnRlbnQpIHx8IC9eXFx0Ky0gcGFyZW50XFxkKzogLy50ZXN0KGxpbmVDb250ZW50KSkge1xuXHRcdFx0Y29uc3QgcGFyZW50TGluayA9IGxpbmVDb250ZW50LnJlcGxhY2UoL15wYXJlbnRcXGQrOiAvLCBcIlwiKS5yZXBsYWNlKC9eXFx0Ky0gcGFyZW50XFxkKzogLywgXCJcIikucmVwbGFjZSgvXCIvZywgXCJcIikucmVwbGFjZSgvXFxbXFxbLywgXCJcIikucmVwbGFjZSgvXFxdXFxdLywgXCJcIilcblx0XHRcdG5hdmlnYXRvci5jbGlwYm9hcmQud3JpdGVUZXh0KHBhcmVudExpbmspLnRoZW4oKCkgPT4ge1xuXHRcdFx0XHRpZiAobGluZSA9PSAwKSB7XG5cdFx0XHRcdFx0ZWRpdG9yLnNldFZhbHVlKFwiXCIpXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Y29uc3QgcHJldmlvdXNMaW5lID0gZWRpdG9yLmdldExpbmUobGluZS0xKVxuXHRcdFx0XHRcdGVkaXRvci5yZXBsYWNlUmFuZ2UoXCJcIiwge2xpbmU6IGxpbmUtMSwgY2g6IHByZXZpb3VzTGluZS5sZW5ndGh9LCB7bGluZTogbGluZSwgY2g6IGxpbmVDb250ZW50Lmxlbmd0aH0pXG5cdFx0XHRcdH1cblx0XHRcdFx0ZWRpdG9yLnNldFZhbHVlKGVkaXRvci5nZXRWYWx1ZSgpLnJlcGxhY2UoL14tLS1cXG4rLS0tXFxuLywgXCItLS1cXG50YWdzOiBiL24vY1xcbi0tLVxcblwiKS5yZXBsYWNlKC9cXG4kLywgXCJcIikpXG5cdFx0XHRcdGVkaXRvci5zZXRDdXJzb3Ioe2xpbmU6IGxpbmUsIGNoOiBjaCA+IGVkaXRvci5nZXRMaW5lKGxpbmUpLmxlbmd0aCA/IGVkaXRvci5nZXRMaW5lKGxpbmUpLmxlbmd0aCA6IGNofSlcblx0XHRcdFx0bmV3IE5vdGljZShcIkNvcGllZCB0byBjbGlwYm9hcmQ6IFwiICsgcGFyZW50TGluaylcblx0XHRcdH0pXG5cdFx0fVxuXHR9LFxuXHRob3RrZXlzOiBbXG5cdFx0e1xuXHRcdFx0bW9kaWZpZXJzOiBbYEN0cmxgLCBgTWV0YWAsIGBTaGlmdGBdLFxuXHRcdFx0a2V5OiBgeWAsXG5cdFx0fSxcblx0XHR7XG5cdFx0XHRtb2RpZmllcnM6IFtgQ3RybGAsIGBBbHRgLCBgU2hpZnRgXSxcblx0XHRcdGtleTogYHlgLFxuXHRcdH0sXG5cdF1cbn0pO1xuXG4vLyBUT0RPIHJlbW92ZSBhZnRlciBUVyBtaWdyYXRlIGZpbmlzaFxudGhpcy5hZGRPYnNpZGlhbkljb24oJ3R3LXRpZHktbGlzdC1ub3RlJywgJz09Jyk7XG50aGlzLmFkZENvbW1hbmQoe1xuXHRpZDogXCJ0dy10aWR5LWxpc3Qtbm90ZVwiLFxuXHRuYW1lOiBcIlRMID09IFRXIFRpZHkgTGlzdCBOb3RlXCIsXG5cdGljb246IGB0dy10aWR5LWxpc3Qtbm90ZWAsXG5cdGVkaXRvckNhbGxiYWNrOiAoZWRpdG9yOiBFZGl0b3IsIHZpZXc6IE1hcmtkb3duVmlldykgPT4ge1xuXHRcdGVkaXRvci5zZXRWYWx1ZShyZXBsYWNlVFdVc2VsZXNzVmFsdWUoZWRpdG9yLmdldFZhbHVlKCkpKVxuXHRcdGNvbnN0IGxpbmVDb3VudCA9IGVkaXRvci5saW5lQ291bnQoKVxuXHRcdGxldCBmbSA9IFwiXCJcblx0XHRsZXQgYyA9IFwiXCJcblx0XHRsZXQgdGV4dCA9IFwiXCJcblx0XHRsZXQgaDNDb3VudCA9IDA7XG5cdFx0bGV0IGNvbnRlbnQgPSBcIlwiXG5cdFx0bGV0IHRhc2tUYWcgPSBcIlwiXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lQ291bnQ7IGkrKykge1xuXHRcdFx0Y29uc3QgbGluZSA9IGVkaXRvci5nZXRMaW5lKGkpXG5cdFx0XHRpZiAoaDNDb3VudCA9PSAwKSB7XG5cdFx0XHRcdGlmIChsaW5lLmxlbmd0aCAhPSAwICYmICEvXlxcdCotIGBgYCQvLnRlc3QobGluZSkpIHtcblx0XHRcdFx0XHRjb25zdCBtb2RpZmllZExpbmUgPSBsaW5lLmNvbnRhaW5zKFwiW1tcIikgJiYgbGluZS5jb250YWlucyhcIl1dXCIpIFxuXHRcdFx0ICAgICAgICAgICAgPyBsaW5lXG5cdFx0XHRcdFx0XHQ6IGxpbmUucmVwbGFjZSh2aWV3LmZpbGUuYmFzZW5hbWUgKyBcIiBfIFwiLCBcIlwiKS5yZXBsYWNlKC8oXFx0Ki0gKSMrID4gLywgXCIkMVwiKS5yZXBsYWNlKC8oXFx0Ky0gKSMrIC8sIFwiJDFcIilcblx0XHRcdFx0XHRcdC8vIFx0LSAjIyA+IGNzdGF0dXMgYW5kIHR4c3RhdCA9IDBcblx0XHRcdFx0XHRjb250ZW50ICs9IChtb2RpZmllZExpbmUgKyBcIlxcblwiKVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKGgzQ291bnQgPT0gMSkge1xuXHRcdFx0XHRpZiAobGluZS5zdGFydHNXaXRoKFwidGl0bGU6IFwiKSB8fCBsaW5lLnN0YXJ0c1dpdGgoXCJsaXN0OiBcIikpIHtcblx0XHRcdFx0XHRmbSArPSAobGluZSArIFwiXFxuXCIpXG5cdFx0XHRcdH0gZWxzZSBpZiAobGluZS5sZW5ndGggIT0gMCAmJiAhL15cXHQqLSBgYGAkLy50ZXN0KGxpbmUpKSB7IFxuXHRcdFx0XHRcdGNvbnN0IG1vZGlmaWVkTGluZSA9IGxpbmUuY29udGFpbnMoXCJbW1wiKSAmJiBsaW5lLmNvbnRhaW5zKFwiXV1cIikgXG5cdFx0XHRcdFx0XHQ/IGxpbmVcblx0XHRcdFx0XHRcdDogbGluZS5yZXBsYWNlKHZpZXcuZmlsZS5iYXNlbmFtZSArIFwiIF8gXCIsIFwiXCIpLnJlcGxhY2UoLyhcXHQqLSApIysgPiAvLCBcIiQxXCIpLnJlcGxhY2UoLyhcXHQrLSApIysgLywgXCIkMVwiKVxuXHRcdFx0XHRcdGZtICs9IChtb2RpZmllZExpbmUgKyBcIlxcblwiKVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoaDNDb3VudCA+PSAyKSB7XG5cdFx0XHRcdGlmIChsaW5lLmxlbmd0aCAhPSAwICYmICEvXlxcdCotIGBgYCQvLnRlc3QobGluZSkpIHtcblx0XHRcdFx0XHRjb25zdCBtb2RpZmllZExpbmUgPSBsaW5lLmNvbnRhaW5zKFwiW1tcIikgJiYgbGluZS5jb250YWlucyhcIl1dXCIpIFxuXHRcdFx0XHRcdFx0PyBsaW5lXG5cdFx0XHRcdFx0XHQ6IGxpbmUucmVwbGFjZSh2aWV3LmZpbGUuYmFzZW5hbWUgKyBcIiBfIFwiLCBcIlwiKS5yZXBsYWNlKC8oXFx0Ki0gKSMrID4gLywgXCIkMVwiKS5yZXBsYWNlKC8oXFx0Ky0gKSMrIC8sIFwiJDFcIilcblx0XHRcdFx0XHRjICs9IChtb2RpZmllZExpbmUgKyBcIlxcblwiKVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAobGluZSA9PT0gXCItLS1cIikge1xuXHRcdFx0XHRoM0NvdW50Kys7XG5cdFx0XHRcdGlmIChoM0NvdW50ID09IDIpIHtcblx0XHRcdFx0XHRmbSArPSBcIlxcblwiXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IFxuXHRcdHRleHQgKz0gY29udGVudFxuXHRcdGlmIChmbS5sZW5ndGggPiAwKSB7XG5cdFx0XHR0ZXh0ICs9IGZtXG5cdFx0fVxuXHRcdHRleHQgKz0gY1xuXHRcdHRleHQgPSB0ZXh0LnJlcGxhY2UoL14tLS1cXG4rLS0tXFxuL20sIFwiLS0tXFxudGFnczogYi9uL2NcXG4tLS1cXG5cIikucmVwbGFjZSgvXFxuJC8sIFwiXCIpXG5cdFx0ZWRpdG9yLnNldFZhbHVlKHRleHQpXG5cdFx0bmV3IE5vdGljZShcIkZvcm1hdHRlZCB0aWR5IGxpc3Qgbm90ZVwiKVxuXHR9LFxuXHRob3RrZXlzOiBbXG5cdFx0e1xuXHRcdFx0bW9kaWZpZXJzOiBbYEN0cmxgLCBgTWV0YWAsIGBTaGlmdGBdLFxuXHRcdFx0a2V5OiBgNmAsXG5cdFx0fSxcblx0XHR7XG5cdFx0XHRtb2RpZmllcnM6IFtgQ3RybGAsIGBBbHRgLCBgU2hpZnRgXSxcblx0XHRcdGtleTogYDZgLFxuXHRcdH0sXG5cdF1cbn0pO1xuXG4vLyBUT0RPIHJlbW92ZSBhZnRlciBUVyBtaWdyYXRlIGZpbmlzaFxudGhpcy5hZGRPYnNpZGlhbkljb24oJ3R3LXRhc2snLCAnLS0nKTtcbnRoaXMuYWRkQ29tbWFuZCh7XG5cdGlkOiBcInR3LXRhc2tcIixcblx0bmFtZTogXCJUVCAtLSBUVyBUYXNrXCIsXG5cdGljb246IGB0dy10YXNrYCxcblx0ZWRpdG9yQ2FsbGJhY2s6IChlZGl0b3I6IEVkaXRvciwgdmlldzogTWFya2Rvd25WaWV3KSA9PiB7XG5cdFx0aWYgKGdldENoaWxkbGlua0l0ZW1zKHRoaXMuYXBwLCB2aWV3LmZpbGUpLmxlbmd0aCA+IDApIHtcblx0XHRcdG5ldyBOb3RpY2UoXCJTdGlsbCBoYXZlIGNoaWxkIGxpbmsuIFBsZWFzZSBjaGVjayB0aGUgY2hpbGQgbGluayBmaXJzdC4gQWJvcnQuLi5cIilcblx0XHRcdG5ldyBOYXZpZ2F0ZVRvRm9yd2FyZEFuZEJhY2tsaW5rVGFnTW9kYWwodGhpcy5hcHAsIHZpZXcsIGVkaXRvcikub3BlbigpXG5cdFx0XHRyZXR1cm5cblx0XHR9XG5cdFx0ZWRpdG9yLnNldFZhbHVlKHJlcGxhY2VUV1VzZWxlc3NWYWx1ZShlZGl0b3IuZ2V0VmFsdWUoKSkpXG5cdFx0Y29uc3QgbGluZUNvdW50ID0gZWRpdG9yLmxpbmVDb3VudCgpXG5cdFx0bGV0IGZtID0gXCJcIlxuXHRcdGxldCBjID0gXCJcIlxuXHRcdGxldCB0ZXh0ID0gXCJcIlxuXHRcdGxldCBoM0NvdW50ID0gMDtcblx0XHRsZXQgY29udGVudCA9IFwiXCJcblx0XHRsZXQgdGFza1RhZyA9IFwiXCJcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGxpbmVDb3VudDsgaSsrKSB7XG5cdFx0XHRjb25zdCBsaW5lID0gZWRpdG9yLmdldExpbmUoaSlcblx0XHRcdGlmIChoM0NvdW50ID09IDApIHtcblx0XHRcdFx0Y29udGVudCArPSAobGluZSArIFwiXFxuXCIpXG5cdFx0XHR9IGVsc2UgaWYgKGgzQ291bnQgPT0gMSkge1xuXHRcdFx0XHRpZiAobGluZS5zdGFydHNXaXRoKFwidGl0bGU6IFwiKSkge1xuXHRcdFx0XHRcdC8vIGRvIG5vdGhpbmdcblx0XHRcdFx0fSBlbHNlIGlmIChsaW5lLnN0YXJ0c1dpdGgoXCJ0YWdzc3M6IFwiKSkge1xuXHRcdFx0XHRcdHRhc2tUYWcgPSBcImEvXCJcblx0XHRcdFx0XHRpZiAoLyBOIC8udGVzdChsaW5lKSB8fCAvIE4kLy50ZXN0KGxpbmUpKSB7XG5cdFx0XHRcdFx0XHR0YXNrVGFnICs9IFwibi9cIlxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoLyBXIC8udGVzdChsaW5lKSB8fCAvIFckLy50ZXN0KGxpbmUpKSB7XG5cdFx0XHRcdFx0XHR0YXNrVGFnICs9IFwidy9cIlxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoLyBub3cgLy50ZXN0KGxpbmUpIHx8IC8gbm93JC8udGVzdChsaW5lKSkge1xuXHRcdFx0XHRcdFx0dGFza1RhZyArPSBcIm5cIlxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoLyBsYXRlciAvLnRlc3QobGluZSkgfHwgLyBsYXRlciQvLnRlc3QobGluZSkpIHtcblx0XHRcdFx0XHRcdHRhc2tUYWcgKz0gXCJsXCJcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKC8gd2FpdGluZyAvLnRlc3QobGluZSkgfHwgLyB3YWl0aW5nJC8udGVzdChsaW5lKSkge1xuXHRcdFx0XHRcdFx0dGFza1RhZyArPSBcIndcIlxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoLyBkb25lIC8udGVzdChsaW5lKSB8fCAvIGRvbmUkLy50ZXN0KGxpbmUpKSB7XG5cdFx0XHRcdFx0XHR0YXNrVGFnICs9IFwiZFwiXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICgvIGFyY2hpdmUgLy50ZXN0KGxpbmUpIHx8IC8gYXJjaGluZSQvLnRlc3QobGluZSkpIHtcblx0XHRcdFx0XHRcdHRhc2tUYWcgKz0gXCJhXCJcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKHRhc2tUYWcubGVuZ3RoID09IDUpIHtcblx0XHRcdFx0XHRcdGZtICs9IChcInRhZ3M6IFwiICsgdGFza1RhZyArIFwiXFxuXCIpXG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdG5ldyBOb3RpY2UoXCJlcnJvciBvbiBzZXR0aW5nIGFjdGlvbiB0YWdcIilcblx0XHRcdFx0XHRcdGZtICs9IChsaW5lICsgXCJcXG5cIilcblx0XHRcdFx0XHR9XHRcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRmbSArPSAobGluZSArIFwiXFxuXCIpXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmIChoM0NvdW50ID49IDIpIHtcblx0XHRcdFx0bGV0IG1vZGlmaWVkTGluZSA9IGxpbmVcblx0XHRcdFx0YyArPSAobW9kaWZpZWRMaW5lICsgXCJcXG5cIilcblx0XHRcdH1cblx0XHRcdGlmIChsaW5lID09PSBcIi0tLVwiKSB7XG5cdFx0XHRcdGgzQ291bnQrKztcblx0XHRcdH1cblx0XHR9IFxuXHRcdHRleHQgKz0gY29udGVudFxuXHRcdGlmIChmbS5sZW5ndGggPiAwKSB7XG5cdFx0XHR0ZXh0ICs9IGZtXG5cdFx0fVxuXHRcdHRleHQgKz0gY1xuXHRcdHRleHQgPSB0ZXh0LnJlcGxhY2UoL14tLS1cXG4rLS0tXFxuL20sIFwiLS0tXFxudGFnczogYi9uL3NcXG4tLS1cXG5cIikucmVwbGFjZSgvXFxuJC8sIFwiXCIpXG5cdFx0ZWRpdG9yLnNldFZhbHVlKHRleHQpXG5cdFx0ZWRpdG9yLnNldEN1cnNvcih7bGluZTogZ2V0UGFyZW50TGluZSh0ZXh0KSwgY2g6IDB9KVxuXHRcdGFwcC52YXVsdC5yZW5hbWUodmlldy5maWxlLCBcIkMvXCIgKyB2aWV3LmZpbGUubmFtZSlcblx0XHRuZXcgTm90aWNlKFwiRm9ybWF0dGVkIGZvciBhZGRpbmcgbGluayB0byBwYXJlbnQgbm90ZVwiKVxuXHR9LFxuXHRob3RrZXlzOiBbXG5cdFx0e1xuXHRcdFx0bW9kaWZpZXJzOiBbYEN0cmxgLCBgTWV0YWAsIGBTaGlmdGBdLFxuXHRcdFx0a2V5OiBgN2AsXG5cdFx0fSxcblx0XHR7XG5cdFx0XHRtb2RpZmllcnM6IFtgQ3RybGAsIGBBbHRgLCBgU2hpZnRgXSxcblx0XHRcdGtleTogYDdgLFxuXHRcdH0sXG5cdF1cbn0pO1xuXG5cbi8qXG5cdFx0Ly8gVE9ETyByZW1vdmUgYWZ0ZXIgVFcgbWlncmF0ZSBmaW5pc2hcblx0XHR0aGlzLmFkZE9ic2lkaWFuSWNvbigndHctY2hlY2tib3gnLCAnW10nKTtcblx0XHR0aGlzLmFkZENvbW1hbmQoe1xuXHRcdFx0aWQ6IFwidHctY2hlY2tib3hcIixcblx0XHRcdG5hbWU6IFwiQ0IgVFcgQ2hlY2tib3hcIixcblx0XHRcdGljb246IGB0dy1jaGVja2JveGAsXG5cdFx0XHRlZGl0b3JDYWxsYmFjazogKGVkaXRvcjogRWRpdG9yLCB2aWV3OiBNYXJrZG93blZpZXcpID0+IHtcblx0XHRcdFx0Y29uc3QgY2hlY2tib3hNYXAgPSBuZXcgTWFwPHN0cmluZywgc3RyaW5nPigpO1xuXHRcdFx0XHRjb25zdCBsaW5lQ291bnQgPSBlZGl0b3IubGluZUNvdW50KClcblxuXHRcdFx0XHRsZXQgZm0gPSBcIlwiXG5cdFx0XHRcdGxldCBjID0gXCJcIlxuXHRcdFx0XHRsZXQgdGV4dCA9IFwiXCJcblx0XHRcdFx0bGV0IGgzQ291bnQgPSAwO1xuXHRcdFx0XHRsZXQgY29udGVudCA9IFwiXCJcblx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lQ291bnQ7IGkrKykge1xuXHRcdFx0XHRcdGNvbnN0IGxpbmUgPSBlZGl0b3IuZ2V0TGluZShpKVxuXHRcdFx0XHRcdGlmIChoM0NvdW50ID09IDApIHtcblx0XHRcdFx0XHRcdGNvbnRlbnQgKz0gKGxpbmUgKyBcIlxcblwiKVxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoaDNDb3VudCA9PSAxKSB7XG5cdFx0XHRcdFx0XHRpZiAobGluZS5zdGFydHNXaXRoKFwiY2hlY2tib3hieXRpbWVfXCIpKSB7XG5cdFx0XHRcdFx0XHRcdGNvbnN0IGtleVZhbHVlQXJyYXkgPSBsaW5lLnNwbGl0KFwiOlwiKS5tYXAoaXRlbSA9PiBpdGVtLnRyaW0oKSk7XG5cdFx0XHRcdFx0XHRcdGlmIChrZXlWYWx1ZUFycmF5Lmxlbmd0aCA9PT0gMikge1xuXHRcdFx0XHRcdFx0XHRcdGNvbnN0IGtleSA9IGtleVZhbHVlQXJyYXlbMF07XG5cdFx0XHRcdFx0XHRcdFx0Y29uc3QgdmFsdWUgPSBrZXlWYWx1ZUFycmF5WzFdO1xuXG5cdFx0XHRcdFx0XHRcdFx0Y29uc3Qgc3BsaXRBcnJheSA9IGtleS5zcGxpdChcIl9cIik7XG5cdFx0XHRcdFx0XHRcdFx0Y29uc3QgbW9kaWZpZWRLZXkgPSBgPDxjaGVja2JveEJ5VGltZSBcIiR7c3BsaXRBcnJheVsxXX1cIj4+YDtcblxuXHRcdFx0XHRcdFx0XHRcdGNoZWNrYm94TWFwLnNldChtb2RpZmllZEtleSwgdmFsdWUgPT09IFwib3BlblwiID8gXCJbeF1cIiA6IFwiWyBdXCIpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRmbSArPSAobGluZSArIFwiXFxuXCIpXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChoM0NvdW50ID49IDIpIHtcblx0XHRcdFx0XHRcdGxldCBtb2RpZmllZExpbmUgPSBsaW5lXG5cblx0XHRcdFx0XHRcdGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIGNoZWNrYm94TWFwKSB7XG5cdFx0XHRcdFx0XHRcdG1vZGlmaWVkTGluZSA9IG1vZGlmaWVkTGluZS5yZXBsYWNlKG5ldyBSZWdFeHAoa2V5LCBcImdcIiksIHZhbHVlKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdG1vZGlmaWVkTGluZSA9IG1vZGlmaWVkTGluZS5yZXBsYWNlKC88PGNoZWNrYm94QnlUaW1lIFwiW0EtWmEtejAtOV9dK1wiPj4vZywgXCJbIF1cIilcblxuXHRcdFx0XHRcdFx0YyArPSAobW9kaWZpZWRMaW5lICsgXCJcXG5cIilcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKGxpbmUgPT09IFwiLS0tXCIpIHtcblx0XHRcdFx0XHRcdGgzQ291bnQrKztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gXG5cdFx0XHRcdHRleHQgKz0gY29udGVudFxuXHRcdFx0XHRpZiAoZm0ubGVuZ3RoID4gMCkge1xuXHRcdFx0XHRcdHRleHQgKz0gZm1cblx0XHRcdFx0XHQvL3RleHQgKz0gXCItLS1cXG5cIiArIGZtICsgXCItLS1cXG5cIlxuXHRcdFx0XHR9XG5cdFx0XHRcdHRleHQgKz0gY1xuXHRcdFx0XHRcblx0XHRcdFx0ZWRpdG9yLnNldFZhbHVlKHRleHQucmVwbGFjZSgvXFxuJC8sIFwiXCIpKVxuXHRcdFx0fSxcblx0XHRcdGhvdGtleXM6IFtcblx0XHRcdFx0e1xuXHRcdFx0XHRcdG1vZGlmaWVyczogW2BDdHJsYCwgYE1ldGFgLCBgU2hpZnRgXSxcblx0XHRcdFx0XHRrZXk6IGA3YCxcblx0XHRcdFx0fSxcblx0XHRcdFx0e1xuXHRcdFx0XHRcdG1vZGlmaWVyczogW2BDdHJsYCwgYEFsdGAsIGBTaGlmdGBdLFxuXHRcdFx0XHRcdGtleTogYDdgLFxuXHRcdFx0XHR9LFxuXHRcdFx0XVxuXHRcdH0pO1xuKi9cblxuXHRcdC8vIFRPRE8gcmVtb3ZlIGFmdGVyIFRXIG1pZ3JhdGUgZmluaXNoXG5cdFx0dGhpcy5hZGRPYnNpZGlhbkljb24oJ25vdGUtdG8tdHJlZS1saXN0JywgJyoqJyk7XG5cdFx0dGhpcy5hZGRDb21tYW5kKHtcblx0XHRcdGlkOiBcIm5vdGUtdG8tdHJlZS1saXN0XCIsXG5cdFx0XHRuYW1lOiBcIk5UIE5vdGUgdG8gVHJlZSBMaXN0XCIsXG5cdFx0XHRpY29uOiBgbm90ZS10by10cmVlLWxpc3RgLFxuXHRcdFx0ZWRpdG9yQ2FsbGJhY2s6IChlZGl0b3I6IEVkaXRvciwgdmlldzogTWFya2Rvd25WaWV3KSA9PiB7XG5cdFx0XHRcdGlmIChnZXRDaGlsZGxpbmtJdGVtcyh0aGlzLmFwcCwgdmlldy5maWxlKS5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdFx0bmV3IE5vdGljZShcIlN0aWxsIGhhdmUgY2hpbGQgbGluay4gUGxlYXNlIGNoZWNrIHRoZSBjaGlsZCBsaW5rIGZpcnN0LiBBYm9ydC4uLlwiKVxuXHRcdFx0XHRcdG5ldyBOYXZpZ2F0ZVRvRm9yd2FyZEFuZEJhY2tsaW5rVGFnTW9kYWwodGhpcy5hcHAsIHZpZXcsIGVkaXRvcikub3BlbigpXG5cdFx0XHRcdFx0cmV0dXJuXG5cdFx0XHRcdH1cblx0XHRcdFx0Y29uc3QgY2hlY2tib3hNYXAgPSBuZXcgTWFwPHN0cmluZywgc3RyaW5nPigpO1xuXHRcdFx0XHRjb25zdCBsaW5lQ291bnQgPSBlZGl0b3IubGluZUNvdW50KClcblx0XHRcdFx0aWYgKGVkaXRvci5nZXRWYWx1ZSgpLnN0YXJ0c1dpdGgoXCItIFwiICsgdmlldy5maWxlLmJhc2VuYW1lICsgXCJcXG5cIikpIHtcblx0XHRcdFx0XHQvLyBhbHJlYWR5IHRpZHkgb25jZSwgaGVyZSBvbmx5IHNob3VsZCByZW1vdmUgZW1wdHkgbGluZSBhbmQgcmVtb3ZlIGR1cGxpY2F0ZSBsaXN0IG5hbWUgKHR3IGhpZXJhcmNoeSlcblx0XHRcdFx0XHRjb25zdCBmaWxlbmFtZSA9IHZpZXcuZmlsZS5iYXNlbmFtZVxuXHRcdFx0XHRcdGxldCB0ZXh0ID0gXCJcIlxuXHRcdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbGluZUNvdW50OyBpKyspIHtcblx0XHRcdFx0XHRcdGNvbnN0IGxpbmUgPSBlZGl0b3IuZ2V0TGluZShpKVxuXHRcdFx0XHRcdFx0aWYgKGxpbmUudHJpbSgpLmxlbmd0aCAhPSAwKSB7XG5cdFx0XHRcdFx0XHRcdGlmICghL15cXHQqLSAkLy50ZXN0KGxpbmUpICYmICEvXlxcdCpcXGQrXFwuICQvLnRlc3QobGluZSkpIHsgLy8gZW1wdHkgbGlzdCBpdGVtXG5cdFx0XHRcdFx0XHRcdFx0bGV0IG1vZExpbmUgPSBsaW5lXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCFtb2RMaW5lLmNvbnRhaW5zKFwiW1tcIikgJiYgIW1vZExpbmUuY29udGFpbnMoXCJdXVwiKSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0bW9kTGluZSA9IGxpbmUucmVwbGFjZShgJHtmaWxlbmFtZX0gXyBgLCBcIlwiKSAvLyBwcmV2ZW50IHJlcGxhY2UgbGlua1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRpZiAobGluZSAhPT0gYC0gJHt2aWV3LmZpbGUuYmFzZW5hbWV9YCAmJiAvXi0gLy50ZXN0KGxpbmUpKXtcblx0XHRcdFx0XHRcdFx0XHRcdG1vZExpbmUgPSBcIlxcdFwiICsgbW9kTGluZVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR0ZXh0ICs9IG1vZExpbmUgKyBcIlxcblwiXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGV4dCA9IHRleHQucmVwbGFjZSgvXFxuJC9tLCBcIlwiKVxuXHRcdFx0XHRcdGVkaXRvci5zZXRWYWx1ZSh0ZXh0KVxuXHRcdFx0XHRcdGVkaXRvci5zZXRDdXJzb3Ioe2xpbmU6IGdldFBhcmVudExpbmUodGV4dCksIGNoOiAwfSlcblx0XHRcdFx0XHRuZXcgTm90aWNlKFwiRm9ybWF0dGVkIHRvIHJlbW92ZSBlbXB5dCBsaW5lIGFuZCByZW1vdmVkIGR1cGxpY2F0ZWQgbGlzdCBuYW1lXCIpXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZWRpdG9yLnNldFZhbHVlKHJlcGxhY2VUV1VzZWxlc3NWYWx1ZShlZGl0b3IuZ2V0VmFsdWUoKSkpXG5cdFx0XHRcdFx0bGV0IHRleHQgPSBcIi0gXCJcblx0XHRcdFx0XHRsZXQgaDNDb3VudCA9IDA7XG5cdFx0XHRcdFx0bGV0IGFjdGlvblRhZyA9IFwiXCJcblx0XHRcdFx0XHRsZXQgY29udGVudCA9IFwiXCJcblx0XHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGxpbmVDb3VudDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRjb25zdCBsaW5lID0gZWRpdG9yLmdldExpbmUoaSlcblx0XHRcdFx0XHRcdGlmIChoM0NvdW50ID09IDApIHtcblx0XHRcdFx0XHRcdFx0aWYgKGxpbmUudHJpbSgpLmxlbmd0aCAhPSAwICYmIGxpbmUgIT0gXCItLS1cIikge1xuXHRcdFx0XHRcdFx0XHRcdGxldCBtb2RpZmllZExpbmUgPSBsaW5lXG5cdFx0XHRcdFx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCA5OyBpKyspIHtcblx0XHRcdFx0XHRcdFx0XHRcdG1vZGlmaWVkTGluZSA9IG1vZGlmaWVkTGluZS5yZXBsYWNlKC9eICAgIC8sIFwiXFx0XCIpXG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdG1vZGlmaWVkTGluZSA9IG1vZGlmaWVkTGluZS5yZXBsYWNlKC9eKFxcdCopXFwqXFxzLywgXCIkMS0gXCIpXG5cdFx0XHRcdFx0XHRcdFx0bW9kaWZpZWRMaW5lID0gKC9eXFx0Ki0gLy50ZXN0KG1vZGlmaWVkTGluZSkgfHwgL15cXHQqXFxkK1xcLiAvLnRlc3QobW9kaWZpZWRMaW5lKSkgPyAoXCJcXHRcIiArIG1vZGlmaWVkTGluZSkgOiAoXCJcXHQtIFwiICsgbW9kaWZpZWRMaW5lKVxuXHRcdFx0XHRcdFx0XHRcdGNvbnRlbnQgKz0gXCJcXG5cIiArIG1vZGlmaWVkTGluZVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKGgzQ291bnQgPT0gMSkge1xuXHRcdFx0XHRcdFx0XHRpZiAobGluZSA9PT0gXCItLS1cIiB8fCBzaG91bGRTa2lwRnJvbnRNYXR0ZXIobGluZSkgfHwgbGluZS5zdGFydHNXaXRoKFwidGl0bGU6IFwiKSkge1xuXHRcdFx0XHRcdFx0XHRcdC8vIGRvIG5vdGhpbmdcblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmIChsaW5lLnN0YXJ0c1dpdGgoXCJ0YWdzc3M6IFwiKSkge1xuXHRcdFx0XHRcdFx0XHRcdGlmICgvIE4gLy50ZXN0KGxpbmUpIHx8IC8gTiQvLnRlc3QobGluZSkpIHtcblx0XHRcdFx0XHRcdFx0XHRcdGFjdGlvblRhZyA9IFwiblwiXG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdGlmICgvIFcgLy50ZXN0KGxpbmUpIHx8IC8gVyQvLnRlc3QobGluZSkpIHtcblx0XHRcdFx0XHRcdFx0XHRcdGFjdGlvblRhZyA9IFwid1wiXG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdGlmICgvIG5vdyAvLnRlc3QobGluZSkgfHwgLyBub3ckLy50ZXN0KGxpbmUpKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRhY3Rpb25UYWcgKz0gXCJuXCJcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0aWYgKC8gbGF0ZXIgLy50ZXN0KGxpbmUpIHx8IC8gbGF0ZXIkLy50ZXN0KGxpbmUpKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRhY3Rpb25UYWcgKz0gXCJsXCJcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0aWYgKC8gd2FpdGluZyAvLnRlc3QobGluZSkgfHwgLyB3YWl0aW5nJC8udGVzdChsaW5lKSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0YWN0aW9uVGFnICs9IFwid1wiXG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdGlmICgvIGRvbmUgLy50ZXN0KGxpbmUpIHx8IC8gZG9uZSQvLnRlc3QobGluZSkpIHtcblx0XHRcdFx0XHRcdFx0XHRcdGFjdGlvblRhZyArPSBcImRcIlxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRpZiAoLyBhcmNoaXZlIC8udGVzdChsaW5lKSB8fCAvIGFyY2hpbmUkLy50ZXN0KGxpbmUpKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRhY3Rpb25UYWcgKz0gXCJ3XCJcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0aWYgKGFjdGlvblRhZy5sZW5ndGggPT0gMikge1xuXHRcdFx0XHRcdFx0XHRcdFx0YWN0aW9uVGFnID0gXCIjXCIgKyBhY3Rpb25UYWcgKyBcIiBcIlxuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoYWN0aW9uVGFnLmxlbmd0aCA9PSAxKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRuZXcgTm90aWNlKFwiZXJyb3Igb24gc2V0dGluZyBhY3Rpb24gdGFnXCIpXG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKGxpbmUuc3RhcnRzV2l0aChcImNoZWNrYm94Ynl0aW1lX1wiKSkge1xuXHRcdFx0XHRcdFx0XHRcdGNvbnN0IGtleVZhbHVlQXJyYXkgPSBsaW5lLnNwbGl0KFwiOlwiKS5tYXAoaXRlbSA9PiBpdGVtLnRyaW0oKSk7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKGtleVZhbHVlQXJyYXkubGVuZ3RoID09PSAyKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjb25zdCBrZXkgPSBrZXlWYWx1ZUFycmF5WzBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0Y29uc3QgdmFsdWUgPSBrZXlWYWx1ZUFycmF5WzFdO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRjb25zdCBzcGxpdEFycmF5ID0ga2V5LnNwbGl0KFwiX1wiKTtcblx0XHRcdFx0XHRcdFx0XHRcdGNvbnN0IG1vZGlmaWVkS2V5ID0gYDw8Y2hlY2tib3hCeVRpbWUgXCIke3NwbGl0QXJyYXlbMV19XCI+PmA7XG5cblx0XHRcdFx0XHRcdFx0XHRcdGNoZWNrYm94TWFwLnNldChtb2RpZmllZEtleSwgdmFsdWUgPT09IFwib3BlblwiID8gXCJbeF1cIiA6IFwiWyBdXCIpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAobGluZS50cmltKCkubGVuZ3RoICE9IDApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGxldCBtb2RpZmllZExpbmUgPSBsaW5lXG5cdFx0XHRcdFx0XHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IDk7IGkrKykge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRtb2RpZmllZExpbmUgPSBtb2RpZmllZExpbmUucmVwbGFjZSgvXiAgICAvLCBcIlxcdFwiKVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0bW9kaWZpZWRMaW5lID0gbW9kaWZpZWRMaW5lLnJlcGxhY2UoL14oXFx0KilcXCpcXHMvLCBcIiQxLSBcIilcblx0XHRcdFx0XHRcdFx0XHRcdG1vZGlmaWVkTGluZSA9ICgvXlxcdCotIC8udGVzdChtb2RpZmllZExpbmUpIHx8IC9eXFx0KlxcZCtcXC4gLy50ZXN0KG1vZGlmaWVkTGluZSkpID8gKFwiXFx0XCIgKyBtb2RpZmllZExpbmUpIDogKFwiXFx0LSBcIiArIG1vZGlmaWVkTGluZSlcblx0XHRcdFx0XHRcdFx0XHRcdGNvbnRlbnQgKz0gXCJcXG5cIiArIG1vZGlmaWVkTGluZVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKGgzQ291bnQgPj0gMiAmJiBsaW5lLnRyaW0oKS5sZW5ndGggIT0gMCkge1xuXHRcdFx0XHRcdFx0XHRsZXQgbW9kaWZpZWRMaW5lID0gKGxpbmUgPT09IFwiWyBdIFwiKSA/IFwiXCIgOiBsaW5lXG5cdFx0XHRcdFx0XHRcdGlmIChtb2RpZmllZExpbmUudHJpbSgpLmxlbmd0aCAhPSAwKSB7XG5cdFx0XHRcdFx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCA5OyBpKyspIHtcblx0XHRcdFx0XHRcdFx0XHRcdG1vZGlmaWVkTGluZSA9IG1vZGlmaWVkTGluZS5yZXBsYWNlKC9eICAgIC8sIFwiXFx0XCIpXG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdG1vZGlmaWVkTGluZSA9IG1vZGlmaWVkTGluZS5yZXBsYWNlKC9eKFxcdCopXFwqXFxzLywgXCIkMS0gXCIpXG5cdFx0XHRcdFx0XHRcdFx0bW9kaWZpZWRMaW5lID0gKC9eXFx0Ki0gLy50ZXN0KG1vZGlmaWVkTGluZSkgfHwgL15cXHQqXFxkK1xcLiAvLnRlc3QobW9kaWZpZWRMaW5lKSkgPyAoXCJcXHRcIiArIG1vZGlmaWVkTGluZSkgOiAoXCJcXHQtIFwiICsgbW9kaWZpZWRMaW5lKVxuXHRcdFx0XHRcdFx0XHRcdC8vIG1vZGlmaWVkTGluZSA9IGxpbmUgPT09IFwiLS0tXCIgPyBcIi0tLVwiIDogbW9kaWZpZWRMaW5lXG5cblx0XHRcdFx0XHRcdFx0XHRmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBjaGVja2JveE1hcCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0bW9kaWZpZWRMaW5lID0gbW9kaWZpZWRMaW5lLnJlcGxhY2UobmV3IFJlZ0V4cChrZXksIFwiZ1wiKSwgdmFsdWUpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRtb2RpZmllZExpbmUgPSBtb2RpZmllZExpbmUucmVwbGFjZSgvPDxjaGVja2JveEJ5VGltZSBcIltBLVphLXowLTlfXStcIj4+L2csIFwiWyBdXCIpXG5cblx0XHRcdFx0XHRcdFx0XHR0ZXh0ICs9IChcIlxcblwiICsgbW9kaWZpZWRMaW5lKVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAobGluZSA9PT0gXCItLS1cIikge1xuXHRcdFx0XHRcdFx0XHRsZXQgYmVmb3JlSDMgPSBoM0NvdW50XG5cdFx0XHRcdFx0XHRcdGgzQ291bnQrKztcblx0XHRcdFx0XHRcdFx0aWYgKGJlZm9yZUgzID09IDEgJiYgaDNDb3VudCA9PSAyKSB7XG5cdFx0XHRcdFx0XHRcdFx0dGV4dCArPSBhY3Rpb25UYWcgKyB2aWV3LmZpbGUuYmFzZW5hbWVcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoaDNDb3VudCA8IDIpIHsgLy8gbm8gZnJvbnRtYXR0ZXJcblx0XHRcdFx0XHRcdHRleHQgKz0gdmlldy5maWxlLmJhc2VuYW1lXG5cdFx0XHRcdFx0fSBcblx0XHRcdFx0XHR0ZXh0ICs9IGNvbnRlbnRcblx0XHRcdFx0XHRlZGl0b3Iuc2V0VmFsdWUodGV4dClcblx0XHRcdFx0XHRlZGl0b3Iuc2V0Q3Vyc29yKHtsaW5lOiBnZXRQYXJlbnRMaW5lKHRleHQpLCBjaDogMH0pXG5cdFx0XHRcdFx0bmV3IE5vdGljZShcIkZvcm1hdHRlZCBmb3IgbWVyZ2luZyBsaW5rIHRvIHBhcmVudCBub3RlXCIpXG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRob3RrZXlzOiBbXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRtb2RpZmllcnM6IFtgQ3RybGAsIGBNZXRhYCwgYFNoaWZ0YF0sXG5cdFx0XHRcdFx0a2V5OiBgOGAsXG5cdFx0XHRcdH0sXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRtb2RpZmllcnM6IFtgQ3RybGAsIGBBbHRgLCBgU2hpZnRgXSxcblx0XHRcdFx0XHRrZXk6IGA4YCxcblx0XHRcdFx0fSxcblx0XHRcdF1cblx0XHR9KTtcblxuXHRcdHRoaXMuYWRkQ29tbWFuZCh7XG5cdFx0XHRpZDogXCJyZW1vdmUtY29udGVudC1mcm9tLWN1cnNvclwiLFxuXHRcdFx0bmFtZTogXCJSZW1vdmUgY29udGVudCBmcm9tIGN1cnNvclwiLFxuXHRcdFx0aWNvbjogYGF4ZWAsXG5cdFx0XHRlZGl0b3JDYWxsYmFjazogKGVkaXRvcjogRWRpdG9yLCB2aWV3OiBNYXJrZG93blZpZXcpID0+IHtcblx0XHRcdFx0bmV3IFJlbW92ZUNvbnRlbnRGcm9tQ3Vyc29yTW9kYWwodGhpcy5hcHAsIGVkaXRvcikub3BlbigpXG5cdFx0XHR9LFxuXHRcdFx0aG90a2V5czogW1xuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bW9kaWZpZXJzOiBbYEN0cmxgLCBgTWV0YWAsIGBTaGlmdGBdLFxuXHRcdFx0XHRcdGtleTogYHhgLFxuXHRcdFx0XHR9LFxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bW9kaWZpZXJzOiBbYEN0cmxgLCBgQWx0YCwgYFNoaWZ0YF0sXG5cdFx0XHRcdFx0a2V5OiBgeGAsXG5cdFx0XHRcdH0sXG5cdFx0XHRdXG5cdFx0fSk7XG5cdFx0XG5cdFx0dGhpcy5hZGRDb21tYW5kKHtcblx0XHRcdGlkOiBcInJlbW92ZS1jb250ZW50LWxlZnRcIixcblx0XHRcdG5hbWU6IFwiUmVtb3ZlIGNvbnRlbnQgbGVmdCBzYW1lIGxpbmVcIixcblx0XHRcdGljb246IGBhcnJvdy1sZWZ0LWNpcmNsZWAsXG5cdFx0XHRlZGl0b3JDYWxsYmFjazogKGVkaXRvcjogRWRpdG9yLCB2aWV3OiBNYXJrZG93blZpZXcpID0+IHtcblx0XHRcdFx0cmVtb3ZlQ29udGVudExlZnRTYW1lTGluZShlZGl0b3IpXG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHR0aGlzLmFkZENvbW1hbmQoe1xuXHRcdFx0aWQ6IFwicmVtb3ZlLWNvbnRlbnQtcmlnaHRcIixcblx0XHRcdG5hbWU6IFwiUmVtb3ZlIGNvbnRlbnQgcmlnaHQgc2FtZSBsaW5lXCIsXG5cdFx0XHRpY29uOiBgYXJyb3ctcmlnaHQtY2lyY2xlYCxcblx0XHRcdGVkaXRvckNhbGxiYWNrOiAoZWRpdG9yOiBFZGl0b3IsIHZpZXc6IE1hcmtkb3duVmlldykgPT4ge1xuXHRcdFx0XHRyZW1vdmVDb250ZW50TGVmdFNhbWVMaW5lKGVkaXRvcilcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdHRoaXMuYWRkQ29tbWFuZCh7XG5cdFx0XHRpZDogXCJyZW1vdmUtY29udGVudC10b3AtbGVmdFwiLFxuXHRcdFx0bmFtZTogXCJSZW1vdmUgY29udGVudCBmcm9tIHN0YXJ0IG9mIG5vdGUgdG8gY3Vyc29yXCIsXG5cdFx0XHRpY29uOiBgYXJyb3ctdXAtY2lyY2xlYCxcblx0XHRcdGVkaXRvckNhbGxiYWNrOiAoZWRpdG9yOiBFZGl0b3IsIHZpZXc6IE1hcmtkb3duVmlldykgPT4ge1xuXHRcdFx0XHRyZW1vdmVDb250ZW50RnJvbVN0YXJ0T2ZOb3RlVG9DdXJzb3IoZWRpdG9yKVxuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0dGhpcy5hZGRDb21tYW5kKHtcblx0XHRcdGlkOiBcInJlbW92ZS1jb250ZW50LWJvdHRvbS1yaWdodFwiLFxuXHRcdFx0bmFtZTogXCJSZW1vdmUgY29udGVudCBmcm9tIGN1cnNvciB0byBlbmQgb2Ygbm90ZVwiLFxuXHRcdFx0aWNvbjogYGFycm93LWRvd24tY2lyY2xlYCxcblx0XHRcdGVkaXRvckNhbGxiYWNrOiAoZWRpdG9yOiBFZGl0b3IsIHZpZXc6IE1hcmtkb3duVmlldykgPT4ge1xuXHRcdFx0XHRyZW1vdmVDb250ZW50RnJvbUN1cnNvclRvRW5kT2ZOb3RlKGVkaXRvcilcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdHRoaXMuYWRkT2JzaWRpYW5JY29uKCd0aHJlYWRzLXRvLWJsb2ctaWNvbicsICdUQicpO1xuXHRcdHRoaXMuYWRkQ29tbWFuZCh7XG5cdFx0XHRpZDogXCJ0aHJlYWRzLXRvLWJsb2dcIixcblx0XHRcdG5hbWU6IFwiVEIgVGhyZWFkcyBhcyBwcmUgQmxvZyBmb3JtYXQgdG8gQ2xpcGJvYXJkXCIsXG5cdFx0XHRpY29uOiBgdGhyZWFkcy10by1ibG9nLWljb25gLFxuXHRcdFx0ZWRpdG9yQ2FsbGJhY2s6IChlZGl0b3I6IEVkaXRvciwgdmlldzogTWFya2Rvd25WaWV3KSA9PiB7XG5cdFx0XHRcdG5ldyBUaHJlYWRzVG9CbG9nTW9kYWwodGhpcy5hcHAsIGVkaXRvciwgdmlldykub3BlbigpXG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHR0aGlzLmFkZE9ic2lkaWFuSWNvbignY2FyZC10by10aHJlYWRzLWljb24nLCAnQ1QnKTtcblx0XHR0aGlzLmFkZENvbW1hbmQoe1xuXHRcdFx0aWQ6IFwiY2FyZC10by10aHJlYWRzXCIsXG5cdFx0XHRuYW1lOiBcIkNUIENhcmQgdG8gVGhyZWFkc1wiLFxuXHRcdFx0aWNvbjogYGNhcmQtdG8tdGhyZWFkcy1pY29uYCxcblx0XHRcdGVkaXRvckNhbGxiYWNrOiAoZWRpdG9yOiBFZGl0b3IsIHZpZXc6IE1hcmtkb3duVmlldykgPT4ge1xuXHRcdFx0XHRsZXQgdGV4dCA9IFwiXCJcblx0XHRcdFx0dGV4dCArPSBcIi0tLVxcbnRhZ3M6IGMvdC9kXFxuLS0tXFxuXFxuXCJcblx0XHRcdFx0dGV4dCArPSBcIlx1RDgzRVx1RERGNSBcIiArIHZpZXcuZmlsZS5iYXNlbmFtZSArIFwiXFxuXFxuLS0tXFxuXFxuXFxuXFxuLS0tXFxuXFxuXCI7XG5cdFx0XHRcdHRleHQgKz0gXCIjIyBSZWZlcmVuY2VzXFxuXFxuLSBcIjtcblx0XHRcdFx0dGV4dCArPSBcIltbXCIgKyB2aWV3LmZpbGUuYmFzZW5hbWUgKyBcIl1dXFxuXCJcblx0XHRcdFx0dGV4dCArPSBgXG4tIFx1NEUwMFx1NTAwQlx1NkExOVx1OTg0Q1x1RkYwOFx1NEUzQlx1OTg0Q1x1NjYyRlx1NEVDMFx1OUVCQ1x1MzAwMVx1NjU4N1x1N0FFMFx1NUJFQlx1N0Q2Nlx1OEFCMFx1NzcwQlx1MzAwMVx1NzcwQlx1NUI4Q1x1NUY4Q1x1NTNFRlx1NEVFNVx1NzM3Mlx1NUY5N1x1NEVDMFx1OUVCQ1x1NTk3RFx1ODY1NVx1RkYwOVxuXHQtIFxuLSBcdTRFMDBcdTUwMEJcdTYwQzVcdTY2NkZcdUZGMDhcdTRFQkFcdTY2NDJcdTU3MzBcdUZGMDlcblx0LSBcbi0gXHU0RTAwXHU1MDBCXHU1NTRGXHU5ODRDXG5cdC0gXG4tIFx1NEUwMFx1NTAwQlx1NTM5Rlx1NTZFMCAvIFx1NjIxMVx1NjcwM1x1NTk4Mlx1NEY1NVx1ODlFM1x1NkM3QVxuXHQtIFxuLSBcdTRFOENcdTUwMEJcdTk3NjJcdTU0MTFcdUZGMDhcdTVDMERcdTZCRDQgLyBcdTZCRDRcdThGMDNcdUZGMDlcblx0LSBcblx0LSBcbi0gXHU0RTA5XHU1MDBCXHU2QjY1XHU5QTVGIC8gXHU1MDVBXHU2Q0Q1XG5cdDEuIFxuXHQyLiBcblx0My4gXG4tIFx1NEUwMFx1NTAwQlx1ODg0Q1x1NTJENVxuXHQtIFxuXG5gXG5cblx0XHRcdFx0Y29uc3QgeyB2YXVsdCB9ID0gdGhpcy5hcHA7XG5cdFx0XHRcdGNvbnN0IHBhdGggPSB2aWV3LmZpbGUucGF0aFxuXHRcdFx0XHRjb25zdCBuZXdQYXRoID0gcGF0aC5yZXBsYWNlKC9eKFtBLVpdXFwvKS8sIFwiJDFUaHJlYWRzIFwiKVxuXHRcdFx0XHRjb25zb2xlLmxvZyhcIm5ld1BhdGg9XCIgKyBuZXdQYXRoKVxuXG5cdFx0XHRcdGNvbnN0IHsgd29ya3NwYWNlIH0gPSB0aGlzLmFwcDtcblx0XHRcdFx0Y29uc3QgbGVhZiA9IHdvcmtzcGFjZS5nZXRMZWFmKGZhbHNlKTtcblx0XHRcdFx0UHJvbWlzZS5yZXNvbHZlKClcblx0XHRcdFx0LnRoZW4oKCkgPT4ge1xuXHRcdFx0XHRcdHJldHVybiB2YXVsdC5hZGFwdGVyLmV4aXN0cyhuZXdQYXRoKTtcblx0XHRcdFx0fSlcblx0XHRcdFx0LnRoZW4oKGZpbGVFeGlzdHMpID0+IHtcblx0XHRcdFx0XHRpZiAoZmlsZUV4aXN0cykge1xuXHRcdFx0XHRcdG5ldyBOb3RpY2UoYFdpbGwgbm90IHByb2NlZWQuIFRocmVhZCBwb3N0IFwiJHtuZXdQYXRofVwiIGFscmVhZHkgZXhpc3QuYCk7XG5cdFx0XHRcdFx0cmV0dXJuIFByb21pc2UucmVqZWN0KFwiVGhyZWFkIHBvc3QgZXhpc3RcIik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB2YXVsdC5jcmVhdGUobmV3UGF0aCwgdGV4dCk7XG5cdFx0XHRcdH0pXG5cdFx0XHRcdC50aGVuKCh0RmlsZSkgPT4ge1xuXHRcdFx0XHRcdHJldHVybiBsZWFmLm9wZW5GaWxlKHRGaWxlLCB7IGFjdGl2ZSA6IHRydWV9KTtcblx0XHRcdFx0fSxcblx0XHRcdFx0KHJlamVjdFJlYXNvbikgPT4ge30pXG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHQvKlxuXHRcdHRoaXMuYWRkT2JzaWRpYW5JY29uKCdjaGF0Z3B0LXByb21wdC1mb3ItZ2VuZXJhdGluZy1zdW1tYXJ5LXRvLWNsaXBib2FyZCcsICdHUycpO1xuXHRcdHRoaXMuYWRkQ29tbWFuZCh7XG5cdFx0XHRpZDogXCJjaGF0Z3B0LXByb21wdC1mb3ItZ2VuZXJhdGluZy1zdW1tYXJ5LXRvLWNsaXBib2FyZFwiLFxuXHRcdFx0bmFtZTogXCJHUyBDaGF0R1BUIHByb21wdCBmb3IgZ2VuZXJhdGluZyBzdW1tYXJ5IHRvIGNsaXBib2FyZFwiLFxuXHRcdFx0aWNvbjogYGNoYXRncHQtcHJvbXB0LWZvci1nZW5lcmF0aW5nLXN1bW1hcnktdG8tY2xpcGJvYXJkYCxcblx0XHRcdGVkaXRvckNhbGxiYWNrOiAoZWRpdG9yOiBFZGl0b3IsIHZpZXc6IE1hcmtkb3duVmlldykgPT4ge1xuXHRcdFx0XHRjb25zdCBwcm9tcHQgPSBcIlx1OEFDQlx1NUMwN1x1NEVFNVx1NEUwQlx1NzY4NFx1NjU4N1x1N0FFMFx1N0JDMFx1OTMwNFx1N0UyRVx1NzdFRFx1NjIxMFx1N0QwNDE1MFx1NUI1N1x1NzY4NFx1NEUyRFx1NjU4N1x1NjQ1OFx1ODk4MVx1RkYwQ1x1NzhCQVx1NEZERFx1NjQ1OFx1ODk4MVx1NTE2N1x1NUJCOVx1N0NCRVx1NzE0OVx1NEUxNFx1N0E4MVx1NTFGQVx1OTFDRFx1OUVERVx1MzAwMlx1NEY2MFx1OTcwMFx1ODk4MVx1NkNFOFx1NjEwRlx1NEVFNVx1NEUwQlx1NUU3RVx1OUVERVx1RkYxQVxcblwiICtcblx0XHRcdFx0XHRcdFx0ICAgXCJcXG5cIiArXG5cdFx0XHRcdFx0XHRcdCAgIFwiMS4gXHU1QzA3XHU5NTc3XHU3QkM3XHU1OTI3XHU4QUQ2XHU3RTJFXHU3N0VEXHVGRjBDXHU1M0VBXHU0RkREXHU3NTU5XHU2NzAwXHU5MUNEXHU4OTgxXHU3Njg0XHU4QTBBXHU2MDZGXHU1NDhDXHU0RTNCXHU5ODRDXHUzMDAyXFxuXCIgK1xuXHRcdFx0XHRcdFx0XHQgICBcIjIuIFx1NTNCQlx1OTY2NFx1OTc1RVx1NUZDNVx1ODk4MVx1NzY4NFx1OEE3M1x1N0QzMFx1OEEwQVx1NjA2Rlx1RkYwQ1x1NEUyNlx1OTA3Rlx1NTE0RFx1NEY3Rlx1NzUyOFx1OTA0RVx1NjVCQ1x1N0U0MVx1ODkwN1x1NjIxNlx1NEUwRFx1NUZDNVx1ODk4MVx1NzY4NFx1OEE5RVx1OEEwMFx1MzAwMlxcblwiICtcblx0XHRcdFx0XHRcdFx0ICAgXCIzLiBcdTRGRERcdTc1NTlcdTY1ODdcdTdBRTBcdTRFMkRcdTY3MDBcdTkxQ0RcdTg5ODFcdTc2ODRcdTRFM0JcdTk4NENcdTU0OENcdThBMEFcdTYwNkZcdUZGMENcdTRFMjZcdTc4QkFcdTRGRERcdTkwMTlcdTRFOUJcdThBMEFcdTYwNkZcdTU3MjhcdTY0NThcdTg5ODFcdTRFMkRcdTZFMDVcdTY5NUFcdTU3MzBcdTg4NjhcdTkwNTRcdTUxRkFcdTRGODZcdTMwMDJcXG5cIiArXG5cdFx0XHRcdFx0XHRcdCAgIFwiNC4gXHU0RjdGXHU3NTI4XHU3Q0JFXHU3MTQ5XHU0RTE0XHU3NkY0XHU2M0E1XHU3Njg0XHU4QTlFXHU4QTAwXHVGRjBDXHU0RUU1XHU1NDM4XHU1RjE1XHU0RUJBXHU3Njg0XHU2NUI5XHU1RjBGXHU4ODY4XHU5MDU0XHU0RjVDXHU4MDA1XHU1QzA3XHU1NzI4XHU2NTg3XHU3QUUwXHU0RTJEXHU2REYxXHU1MTY1XHU1MjA2XHU0RUFCXHU5MDE5XHU0RTlCXHU0RTNCXHU5ODRDXHU3Njg0XHU2MTBGXHU1NzE2XHUzMDAyXFxuXCIgK1xuXHRcdFx0XHRcdFx0XHQgICBcIjUuIFx1NEY3Rlx1NzUyOFx1MzAwQ1x1NjIxMVx1MzAwRFx1NEY4Nlx1NjMwN1x1N0EzMVx1MzAwQ1x1NEY1Q1x1ODAwNVx1MzAwRFx1RkYwQ1x1MzAwQ1x1NEY2MFx1MzAwRFx1NEY4Nlx1NjMwN1x1N0EzMVx1OEI4MFx1ODAwNVx1MzAwMlxcblwiICtcblx0XHRcdFx0XHRcdFx0ICAgXCJcXG5cIiArXG5cdFx0XHRcdFx0XHRcdCAgIFwiXHU1MTc3XHU5QUQ0XHU0Rjg2XHU4QUFBXHVGRjBDXHU0RjYwXHU5NzAwXHU4OTgxXHU3OEJBXHU0RkREXHU0RUU1XHU0RTBCXHU5MUNEXHU5RURFXHU4QTBBXHU2MDZGXHU4OEFCXHU1MzA1XHU1NDJCXHU1MTc2XHU0RTJEXHVGRjFBXFxuXCIgK1xuXHRcdFx0XHRcdFx0XHQgICBcIjEuIFx1NjU4N1x1N0FFMFx1NzY4NFx1NEUzQlx1ODk4MVx1NEUzQlx1OTg0Q1x1NjIxNlx1OTFDRFx1OUVERVx1OEEwRVx1OEFENlx1MzAwMlxcblwiICtcblx0XHRcdFx0XHRcdFx0ICAgXCIyLiBcdTRGNUNcdTgwMDVcdTYzRDBcdTUxRkFcdTc2ODRcdTVFRkFcdThCNzBcdTMwMDFcdTdCNTZcdTc1NjVcdTYyMTZcdTkxQ0RcdTg5ODFcdTg5QzBcdTlFREVcdTMwMDJcXG5cIiArXG5cdFx0XHRcdFx0XHRcdCAgIFwiMy4gXHU5MDE5XHU0RTlCXHU1RUZBXHU4QjcwXHU2MjE2XHU3QjU2XHU3NTY1XHU3Njg0XHU1MTc3XHU5QUQ0XHU2NTQ4XHU3NkNBXHU2MjE2XHU3RDUwXHU2NzlDXHUzMDAyXFxuXCIgK1xuXHRcdFx0XHRcdFx0XHQgICBcIlxcblwiICtcblx0XHRcdFx0XHRcdFx0ICAgXCJcdTY3MDBcdTVGOENcdUZGMENcdTRFRTVcdTU0MzhcdTVGMTVcdTRFMjZcdTlGMTNcdTUyRjVcdThCODBcdTgwMDVcdTkwMzJcdTg4NENcdTRFMEJcdTRFMDBcdTZCNjVcdTg4NENcdTUyRDVcdTc2ODRcdTY1QjlcdTVGMEZcdTdERThcdTVCRUJcdTY0NThcdTg5ODFcdUZGMENcdTRFMjZcdTg4NjhcdTkwNTRcdTUxRkFcdTY1ODdcdTdBRTBcdTRFMkRcdTY2RjRcdTU5MUFcdTZERjFcdTUxNjVcdTc2ODRcdTUxNjdcdTVCQjlcdTdCNDlcdTVGODVcdThCODBcdTgwMDVcdTUzQkJcdTYzQTJcdTdEMjJcdTMwMDJcXG5cIiArXG5cdFx0XHRcdFx0XHRcdCAgIFwiXHU4QUNCXHU1QkVCXHU1MUZBM1x1NTAwQlx1NzI0OFx1NjcyQ1x1MzAwMlxcblxcblwiICsgZWRpdG9yLmdldFZhbHVlKCk7XG5cblx0XHRcdFx0bmF2aWdhdG9yLmNsaXBib2FyZC53cml0ZVRleHQocHJvbXB0KS50aGVuKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRuZXcgTm90aWNlKGBDb3BpZWQgcHJvbXB0IGZvciBnZW5lcmF0ZSBzdW1tYXJ5IHRvIGNsaXBib2FyZCFgKTtcblx0XHRcdFx0fSwgZnVuY3Rpb24gKGVycm9yKSB7XG5cdFx0XHRcdFx0bmV3IE5vdGljZShgZXJyb3Igd2hlbiBjb3B5IHRvIGNsaXBib2FyZCFgKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0Ki9cblxuXHRcdHRoaXMuYWRkT2JzaWRpYW5JY29uKCdhZGQtY29tbWVudC10YWctaWNvbicsICdDVCcpO1xuXHRcdHRoaXMuYWRkQ29tbWFuZCh7XG5cdFx0XHRpZDogXCJhZGQtY29tbWVudC10YWdcIixcblx0XHRcdG5hbWU6IFwiQ1QgQWRkIENvbW1lbnQgVGFnXCIsXG5cdFx0XHRpY29uOiBgYWRkLWNvbW1lbnQtdGFnLWljb25gLFxuXHRcdFx0ZWRpdG9yQ2FsbGJhY2s6IChlZGl0b3I6IEVkaXRvciwgdmlldzogTWFya2Rvd25WaWV3KSA9PiB7XG5cdFx0XHQgIG5ldyBBZGRGb290bm90ZVRhZ01vZGFsKHRoaXMuYXBwLCBlZGl0b3IpLm9wZW4oKTtcblx0XHRcdH0sXG5cdFx0XHRob3RrZXlzOiBbXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRtb2RpZmllcnM6IFtgQ3RybGAsIGBNZXRhYCwgYFNoaWZ0YF0sXG5cdFx0XHRcdFx0a2V5OiBgemAsXG5cdFx0XHRcdH0sXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRtb2RpZmllcnM6IFtgQ3RybGAsIGBBbHRgLCBgU2hpZnRgXSxcblx0XHRcdFx0XHRrZXk6IGB6YCxcblx0XHRcdFx0fSxcblx0XHRcdF1cblx0XHR9KTtcblxuXHRcdHRoaXMuYWRkT2JzaWRpYW5JY29uKCdhY3Rpb24tdGFnLWNvdW50LWljb24nLCAnQ0EnKTtcblx0XHR0aGlzLmFkZENvbW1hbmQoe1xuXHRcdFx0aWQ6IFwiYWN0aW9uLXRhZy1jb3VudC1pY29uXCIsXG5cdFx0XHRuYW1lOiBcIkNBIENvdW50IEFjdGlvbiBUYWdcIixcblx0XHRcdGljb246IGBhY3Rpb24tdGFnLWNvdW50LWljb25gLFxuXHRcdFx0ZWRpdG9yQ2FsbGJhY2s6IChlZGl0b3I6IEVkaXRvciwgdmlldzogTWFya2Rvd25WaWV3KSA9PiB7XG5cdFx0XHRcdGNvbnN0IHRhZ3MgPSBbXCJublwiLCBcIm5sXCIsIFwibndcIiwgXCJuMVwiLCBcIm4yXCIsIFwibjNcIiwgXCJuNFwiLCBcIm41XCIsIFwibjZcIiwgXCJuN1wiLCBcInduXCIsIFwid2xcIiwgXCJ3d1wiLCBcIncxXCIsIFwidzJcIiwgXCJ3M1wiLCBcInc0XCIsIFwidzVcIiwgXCJ3NlwiLCBcInc3XCJdO1xuXHRcdFx0XHRjb25zdCBtYXRjaGVzOiBzdHJpbmdbXSA9IFtdO1xuXHRcdFx0XHRjb25zdCBsaW5lTnVtID0gZWRpdG9yLmxpbmVDb3VudCgpO1xuXHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGxpbmVOdW07IGkrKykge1xuXHRcdFx0XHRcdGNvbnN0IGxpbmUgPSBlZGl0b3IuZ2V0TGluZShpKVxuXHRcdFx0XHRcdGNvbnN0IG1hdGNoID0gdGFncy5zb21lKHRhZyA9PiBuZXcgUmVnRXhwKGAjJHt0YWd9IGAsIFwiZ1wiKS50ZXN0KGxpbmUpIHx8IG5ldyBSZWdFeHAoYCAjJHt0YWd9YCwgXCJnXCIpLnRlc3QobGluZSkpO1xuXHRcdFx0XHRcdGlmIChtYXRjaCkge1xuXHRcdFx0XHRcdFx0bWF0Y2hlcy5wdXNoKGBMaW5lICR7aX06XFxuJHtsaW5lLnRyaW0oKX1gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0Y29uc3QgdHJpbW1lZEFuZEpvaW5lZFN0cmluZzogc3RyaW5nID0gbWF0Y2hlcy5qb2luKFwiXFxuXFxuXCIpO1xuXHRcdFx0XHRjb25zdCB0YXNrcyA9IG1hdGNoZXMubGVuZ3RoID4gMCA/IGBcXG5UYXNrczpcXG5cXG4ke3RyaW1tZWRBbmRKb2luZWRTdHJpbmd9YCA6IGBgXG5cdFx0XHRcdG5ldyBOb3RpY2UoYFRoZXJlIGFyZSAke21hdGNoZXMubGVuZ3RofSBvdXRzdGFuZGluZyBhY3Rpb25zIGluIHRoaXMgbm90ZXMke3Rhc2tzfWApO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0dGhpcy5hZGRPYnNpZGlhbkljb24oJ3RvZ2dsZS1uLXctdGFzaycsICcjPScpO1xuXHRcdHRoaXMuYWRkQ29tbWFuZCh7XG5cdFx0XHRpZDogYHRvZ2dsZS1uLXctdGFza2AsXG5cdFx0XHRuYW1lOiBgVG9nZ2xlIE4gVyBUYXNrYCxcblx0XHRcdGljb246IGB0b2dnbGUtbi13LXRhc2tgLFxuXHRcdFx0ZWRpdG9yQ2FsbGJhY2s6IChlZGl0b3I6IEVkaXRvciwgdmlldzogTWFya2Rvd25WaWV3KSA9PiB7XG5cdFx0XHRcdGNvbnNvbGUubG9nKGVkaXRvci5nZXRTZWxlY3Rpb24oKSk7XG5cdFx0XHRcdGNvbnN0IGN1cnNvciA9IGVkaXRvci5nZXRDdXJzb3IoKTtcblx0XHRcdFx0Y29uc3QgbGluZU51bWJlciA9IGVkaXRvci5nZXRDdXJzb3IoKS5saW5lO1xuXHRcdFx0XHRjb25zdCBsaW5lID0gZWRpdG9yLmdldExpbmUobGluZU51bWJlcik7XG5cdFx0XHRcdGlmIChsaW5lLm1hdGNoKC8gYVxcL3dcXC8uLykpIHtcblx0XHRcdFx0XHRjb25zdCByZXBsYWNlZExpbmUgPSBsaW5lLnJlcGxhY2UoLyBhXFwvd1xcLyguKS8sIGAgYS9uLyQxYClcblx0XHRcdFx0XHRlZGl0b3Iuc2V0TGluZShsaW5lTnVtYmVyLCByZXBsYWNlZExpbmUpO1xuXHRcdFx0XHRcdGVkaXRvci5zZXRDdXJzb3IoY3Vyc29yKVxuXHRcdFx0XHR9IGVsc2UgaWYgKGxpbmUubWF0Y2goLyBhXFwvblxcLy4vKSkge1xuXHRcdFx0XHRcdGNvbnN0IHJlcGxhY2VkTGluZSA9IGxpbmUucmVwbGFjZSgvIGFcXC9uXFwvKC4pLywgYCBhL3cvJDFgKVxuXHRcdFx0XHRcdGVkaXRvci5zZXRMaW5lKGxpbmVOdW1iZXIsIHJlcGxhY2VkTGluZSk7XG5cdFx0XHRcdFx0ZWRpdG9yLnNldEN1cnNvcihjdXJzb3IpXG5cdFx0XHRcdH0gZWxzZSBpZiAobGluZS5tYXRjaCgvI3cuIC8pKSB7XG5cdFx0XHRcdFx0Y29uc3QgcmVwbGFjZWRMaW5lID0gbGluZS5yZXBsYWNlKC8jdyguKSAvLCBgI24kMSBgKVxuXHRcdFx0XHRcdGVkaXRvci5zZXRMaW5lKGxpbmVOdW1iZXIsIHJlcGxhY2VkTGluZSk7XG5cdFx0XHRcdFx0ZWRpdG9yLnNldEN1cnNvcihjdXJzb3IpXG5cdFx0XHRcdH0gZWxzZSBpZiAobGluZS5tYXRjaCgvI24uIC8pKSB7XG5cdFx0XHRcdFx0Y29uc3QgcmVwbGFjZWRMaW5lID0gbGluZS5yZXBsYWNlKC8jbiguKSAvLCBgI3ckMSBgKVxuXHRcdFx0XHRcdGVkaXRvci5zZXRMaW5lKGxpbmVOdW1iZXIsIHJlcGxhY2VkTGluZSk7XG5cdFx0XHRcdFx0ZWRpdG9yLnNldEN1cnNvcihjdXJzb3IpXG5cdFx0XHRcdH0gZWxzZSBpZiAobGluZS5tYXRjaCgvICN3Li8pKSB7XG5cdFx0XHRcdFx0Y29uc3QgcmVwbGFjZWRMaW5lID0gbGluZS5yZXBsYWNlKC8gI3coLikvLCBgICNuJDFgKVxuXHRcdFx0XHRcdGVkaXRvci5zZXRMaW5lKGxpbmVOdW1iZXIsIHJlcGxhY2VkTGluZSk7XG5cdFx0XHRcdFx0ZWRpdG9yLnNldEN1cnNvcihjdXJzb3IpXG5cdFx0XHRcdH0gZWxzZSBpZiAobGluZS5tYXRjaCgvICNuLi8pKSB7XG5cdFx0XHRcdFx0Y29uc3QgcmVwbGFjZWRMaW5lID0gbGluZS5yZXBsYWNlKC8gI24oLikvLCBgICN3JDFgKVxuXHRcdFx0XHRcdGVkaXRvci5zZXRMaW5lKGxpbmVOdW1iZXIsIHJlcGxhY2VkTGluZSk7XG5cdFx0XHRcdFx0ZWRpdG9yLnNldEN1cnNvcihjdXJzb3IpXG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRob3RrZXlzOiBbXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRtb2RpZmllcnM6IFtgQ3RybGAsIGBNZXRhYCwgYFNoaWZ0YF0sXG5cdFx0XHRcdFx0a2V5OiBgPWAsXG5cdFx0XHRcdH0sXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRtb2RpZmllcnM6IFtgQ3RybGAsIGBBbHRgLCBgU2hpZnRgXSxcblx0XHRcdFx0XHRrZXk6IGA9YCxcblx0XHRcdFx0fVxuXHRcdFx0XVxuXHRcdH0pO1xuXG5cdFx0Lypcblx0XHR0aGlzLmFkZE9ic2lkaWFuSWNvbigncmVtb3ZlLWFjdGlvbi1pY29uJywgJy0jJyk7XG5cdFx0dGhpcy5hZGRDb21tYW5kKHtcblx0XHRcdGlkOiBcInJlbW92ZS1hY3Rpb25cIixcblx0XHRcdG5hbWU6IFwiUmVtb3ZlIGFjdGlvblwiLFxuXHRcdFx0aWNvbjogYHJlbW92ZS1hY3Rpb24taWNvbmAsXG5cdFx0XHRlZGl0b3JDYWxsYmFjazogKGVkaXRvcjogRWRpdG9yLCB2aWV3OiBNYXJrZG93blZpZXcpID0+IHtcblx0XHRcdFx0Y29uc3QgY3Vyc29yID0gZWRpdG9yLmdldEN1cnNvcigpO1xuXHRcdFx0XHRjb25zdCBsaW5lTnVtYmVyID0gZWRpdG9yLmdldEN1cnNvcigpLmxpbmU7XG5cdFx0XHRcdGNvbnN0IGxpbmUgPSBlZGl0b3IuZ2V0TGluZShsaW5lTnVtYmVyKTtcblx0XHRcdFx0bGV0IHJlcGxhY2VkTGluZSA9IGxpbmUucmVwbGFjZSgnI25uICcsICcnKVxuXHRcdFx0XHQgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoJyNubCAnLCAnJylcblx0XHRcdFx0XHRcdFx0XHRcdFx0IC5yZXBsYWNlKCcjbncgJywgJycpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCAucmVwbGFjZSgnI25kICcsICcnKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQgLnJlcGxhY2UoJyNuYSAnLCAnJylcblx0XHRcdFx0XHRcdFx0XHRcdFx0IC5yZXBsYWNlKCcjbnQgJywgJycpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCAucmVwbGFjZSgnI24xICcsICcnKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQgLnJlcGxhY2UoJyNuMiAnLCAnJylcblx0XHRcdFx0XHRcdFx0XHRcdFx0IC5yZXBsYWNlKCcjbjMgJywgJycpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCAucmVwbGFjZSgnI240ICcsICcnKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQgLnJlcGxhY2UoJyNuNSAnLCAnJylcblx0XHRcdFx0XHRcdFx0XHRcdFx0IC5yZXBsYWNlKCcjbjYgJywgJycpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCAucmVwbGFjZSgnI243ICcsICcnKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQgLnJlcGxhY2UoJyN3biAnLCAnJylcblx0XHRcdFx0XHRcdFx0XHRcdFx0IC5yZXBsYWNlKCcjd2wgJywgJycpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCAucmVwbGFjZSgnI3d3ICcsICcnKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQgLnJlcGxhY2UoJyN3ZCAnLCAnJylcblx0XHRcdFx0XHRcdFx0XHRcdFx0IC5yZXBsYWNlKCcjd2EgJywgJycpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCAucmVwbGFjZSgnI3d0ICcsICcnKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQgLnJlcGxhY2UoJyN3MSAnLCAnJylcblx0XHRcdFx0XHRcdFx0XHRcdFx0IC5yZXBsYWNlKCcjdzIgJywgJycpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCAucmVwbGFjZSgnI3czICcsICcnKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQgLnJlcGxhY2UoJyN3NCAnLCAnJylcblx0XHRcdFx0XHRcdFx0XHRcdFx0IC5yZXBsYWNlKCcjdzUgJywgJycpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCAucmVwbGFjZSgnI3c2ICcsICcnKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQgLnJlcGxhY2UoJyN3NyAnLCAnJylcblx0XHRcdFx0cmVwbGFjZWRMaW5lID0gQWRkRm9vdG5vdGVUYWdNb2RhbC5yZW1vdmVUYWcocmVwbGFjZWRMaW5lKVxuXHRcdFx0XHRlZGl0b3Iuc2V0TGluZShsaW5lTnVtYmVyLCByZXBsYWNlZExpbmUpO1xuXHRcdFx0XHRlZGl0b3Iuc2V0Q3Vyc29yKGN1cnNvcik7XG5cdFx0XHR9LFxuXHRcdFx0aG90a2V5czogW1xuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bW9kaWZpZXJzOiBbYEN0cmxgLCBgTWV0YWAsIGBTaGlmdGBdLFxuXHRcdFx0XHRcdGtleTogYHhgLFxuXHRcdFx0XHR9LFxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bW9kaWZpZXJzOiBbYEN0cmxgLCBgQWx0YCwgYFNoaWZ0YF0sXG5cdFx0XHRcdFx0a2V5OiBgeGAsXG5cdFx0XHRcdH1cblx0XHRcdF1cblx0XHR9KTtcblx0XHQqL1xuXG5cdFx0dGhpcy5hZGRDb21tYW5kKHtcblx0XHRcdGlkOiBcImN1cnNvci1nby10by1zdGFydC1vZi1saW5lXCIsXG5cdFx0XHRuYW1lOiBcIkN1cnNvciBnbyB0byBzdGFydCBvZiBsaW5lXCIsXG5cdFx0XHRpY29uOiBgYXJyb3ctYmlnLWxlZnRgLFxuXHRcdFx0ZWRpdG9yQ2FsbGJhY2s6IChlZGl0b3I6IEVkaXRvciwgdmlldzogTWFya2Rvd25WaWV3KSA9PiB7XG5cdFx0XHRcdGNvbnN0IGN1cnNvciA9IGVkaXRvci5nZXRDdXJzb3IoKTtcblx0XHRcdFx0Y3Vyc29yLmNoID0gMDtcblx0XHRcdFx0ZWRpdG9yLnNldEN1cnNvcihjdXJzb3IpO1xuXHRcdFx0fSxcblx0XHR9KTtcblxuXHRcdHRoaXMuYWRkQ29tbWFuZCh7XG5cdFx0XHRpZDogXCJjdXJzb3ItZ28tdG8tZW5kLW9mLWxpbmVcIixcblx0XHRcdG5hbWU6IFwiQ3Vyc29yIGdvIHRvIGVuZCBvZiBsaW5lXCIsXG5cdFx0XHRpY29uOiBgYXJyb3ctYmlnLXJpZ2h0YCxcblx0XHRcdGVkaXRvckNhbGxiYWNrOiAoZWRpdG9yOiBFZGl0b3IsIHZpZXc6IE1hcmtkb3duVmlldykgPT4ge1xuXHRcdFx0XHRjb25zdCBjdXJzb3IgPSBlZGl0b3IuZ2V0Q3Vyc29yKCk7XG5cdFx0XHRcdGNvbnN0IGxpbmVOdW0gPSBjdXJzb3IubGluZTtcblx0XHRcdFx0Y29uc3QgbGluZSA9IGVkaXRvci5nZXRMaW5lKGxpbmVOdW0pO1xuXHRcdFx0XHRjb25zdCBsZW5ndGggPSBsaW5lLmxlbmd0aDtcblx0XHRcdFx0Y3Vyc29yLmNoID0gbGVuZ3RoO1xuXHRcdFx0XHRlZGl0b3Iuc2V0Q3Vyc29yKGN1cnNvcik7XG5cdFx0XHR9LFxuXHRcdH0pO1xuXG5cdFx0dGhpcy5hZGRDb21tYW5kKHtcblx0XHRcdGlkOiBcImR1cGxpY2F0ZS1saW5lLWJlbG93XCIsXG5cdFx0XHRuYW1lOiBcIkR1cGxpY2F0ZSBsaW5lIGJlbG93XCIsXG5cdFx0XHRpY29uOiBgYWxpZ24tdmVydGljYWwtc3BhY2UtYmV0d2VlbmAsXG5cdFx0XHRlZGl0b3JDYWxsYmFjazogKGVkaXRvcjogRWRpdG9yLCB2aWV3OiBNYXJrZG93blZpZXcpID0+IHtcblx0XHRcdFx0Y29uc3QgY3Vyc29yID0gZWRpdG9yLmdldEN1cnNvcigpO1xuXHRcdFx0XHRjb25zdCBsaW5lTnVtID0gY3Vyc29yLmxpbmU7XG5cdFx0XHRcblx0XHRcdFx0Ly9jb25zdCBsaW5lID0gZWRpdG9yLmdldExpbmUobGluZU51bSk7XG5cdFx0XHRcdC8vY29uc3QgbGVuZ3RoID0gbGluZS5sZW5ndGg7XG5cdFx0XHRcdGxldCB0ZXh0OiBzdHJpbmcgPSBcIlwiXG5cdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgZWRpdG9yLmxpbmVDb3VudCgpOyBpKyspIHtcblx0XHRcdFx0XHRjb25zdCBsaW5lID0gZWRpdG9yLmdldExpbmUoaSk7XG5cdFx0XHRcdFx0dGV4dCArPSBsaW5lICsgXCJcXG5cIlxuXHRcdFx0XHRcdGlmIChpID09PSBsaW5lTnVtKSB7XG5cdFx0XHRcdFx0XHR0ZXh0ICs9IGxpbmUgKyBcIlxcblwiXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHRleHQgPSB0ZXh0LnJlcGxhY2UoL1xcbiQvLCBcIlwiKVxuXHRcdFx0XHRlZGl0b3Iuc2V0VmFsdWUodGV4dClcblx0XHRcdFx0Y3Vyc29yLmxpbmUgPSBsaW5lTnVtICsgMTtcblx0XHRcdFx0ZWRpdG9yLnNldEN1cnNvcihjdXJzb3IpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0dGhpcy5hZGRPYnNpZGlhbkljb24oJ2V2ZW50LXRvLWZhbnRhc3RpY2FsLWljb24nLCAnRkUnKTtcblx0XHR0aGlzLmFkZENvbW1hbmQoe1xuXHRcdFx0aWQ6IFwiYWRkLWZhbnRhc3RpY2FsLWV2ZW50XCIsXG5cdFx0XHRuYW1lOiBcIkZFIEFkZCBGYW50YXN0aWNhbCBFdmVudFwiLFxuXHRcdFx0aWNvbjogYGV2ZW50LXRvLWZhbnRhc3RpY2FsLWljb25gLFxuXHRcdFx0ZWRpdG9yQ2FsbGJhY2s6IChlZGl0b3I6IEVkaXRvciwgdmlldzogTWFya2Rvd25WaWV3KSA9PiB7XG5cdFx0XHRcdGxldCB0ZXh0ID0gXCJcIjtcblx0XHRcdFx0Y29uc3QgdmF1bHQ6IFZhdWx0ID0gdGhpcy5hcHAudmF1bHQ7XG5cdFx0XHRcdGNvbnN0IGxpc3RTZWxlY3Rpb25zOiBFZGl0b3JTZWxlY3Rpb25bXSA9IGVkaXRvci5saXN0U2VsZWN0aW9ucygpO1xuXHRcdFx0ICBcblx0XHRcdFx0Y29uc3QgcHJvY2Vzc0xpbmUgPSBhc3luYyAobGluZTogc3RyaW5nLCBpOiBudW1iZXIpID0+IHtcblx0XHRcdFx0XHQvLyB0byBtb2RpZnkgbGluZSBhZGQgdG0gKHRvIG1vdmUpIHRhZyBhbmQgYWRkIHRvIGNvcnJlc3BvbmRpbmcgam91cm5hbCBub3RlXG5cdFx0XHRcdCAgaWYgKC9eLSBcXGRcXGRcXGRcXGQtXFxkXFxkLVxcZFxcZCBcXGRcXGQ6XFxkXFxkIC8udGVzdChsaW5lKSkge1xuXHRcdFx0XHRcdGNvbnN0IG1vZGlmaWVkTGluZSA9IGxpbmUucmVwbGFjZSgvXi0gLywgYC0gI3RtIGApO1xuXHRcdFx0XHRcdGVkaXRvci5zZXRMaW5lKGksIG1vZGlmaWVkTGluZSk7XG5cdFx0XHRcdFx0dGV4dCArPSBsaW5lICsgXCJcXG5cIjtcblx0XHRcdCAgXG5cdFx0XHRcdFx0Y29uc3QgbGluZVRvQWRkID0gJy0nICsgbGluZS5yZXBsYWNlKC8tL2csICcnKTtcblx0XHRcdFx0XHRjb25zdCBwYXRoID0gbGluZS5yZXBsYWNlKC9eLSAoXFxkXFxkXFxkXFxkKS0oXFxkXFxkKS0uKi8sIFwiSi8kMS1NJDIubWRcIik7XG5cdFx0XHQgIFxuXHRcdFx0XHRcdGxldCB0RmlsZSA9IHZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aChwYXRoKTtcblx0XHRcdFx0XHRpZiAodEZpbGUgPT0gbnVsbCkge1xuXHRcdFx0XHRcdCAgdEZpbGUgPSBhd2FpdCB2YXVsdC5jcmVhdGUocGF0aCwgXCItLS1cXG50YWdzOiBiL24valxcbi0tLVxcblxcblwiICsgbGluZVRvQWRkKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdCAgY29uc3QgdEZpbGVPcmlnaW5hbFZhbHVlID0gYXdhaXQgdmF1bHQucmVhZCh0RmlsZSBhcyBURmlsZSk7XG5cdFx0XHRcdFx0ICBhd2FpdCB2YXVsdC5tb2RpZnkodEZpbGUgYXMgVEZpbGUsIHRGaWxlT3JpZ2luYWxWYWx1ZSArIFwiXFxuXCIgKyBsaW5lVG9BZGQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0ICB9XG5cdFx0XHRcdH07XG5cdFx0XHQgIFxuXHRcdFx0XHRjb25zdCBwcm9jZXNzU2VsZWN0aW9ucyA9IGFzeW5jICgpID0+IHtcblx0XHRcdFx0ICBmb3IgKGNvbnN0IGxpc3RTZWxlY3Rpb24gb2YgbGlzdFNlbGVjdGlvbnMpIHtcblx0XHRcdFx0XHRjb25zdCBhID0gbGlzdFNlbGVjdGlvbi5oZWFkLmxpbmU7XG5cdFx0XHRcdFx0Y29uc3QgYiA9IGxpc3RTZWxlY3Rpb24uYW5jaG9yLmxpbmU7XG5cdFx0XHRcdFx0Y29uc3QgZnJvbUxpbmVOdW0gPSBiID4gYSA/IGEgOiBiO1xuXHRcdFx0XHRcdGNvbnN0IHRvTGluZU51bSA9IGIgPiBhID8gYiA6IGE7XG5cdFx0XHQgIFxuXHRcdFx0XHRcdGZvciAobGV0IGkgPSBmcm9tTGluZU51bTsgaSA8PSB0b0xpbmVOdW07IGkrKykge1xuXHRcdFx0XHRcdCAgY29uc3QgbGluZSA9IGVkaXRvci5nZXRMaW5lKGkpO1xuXHRcdFx0XHRcdCAgYXdhaXQgcHJvY2Vzc0xpbmUobGluZSwgaSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHQgIH1cblx0XHRcdFx0fTtcblx0XHRcdCAgXG5cdFx0XHRcdHByb2Nlc3NTZWxlY3Rpb25zKCkudGhlbigoKSA9PiB7XG5cdFx0XHRcdCAgaWYgKHRleHQubGVuZ3RoICE9PSAwKSB7XG5cdFx0XHRcdFx0dGV4dCA9IGVuY29kZVVSSSh0ZXh0KTtcblx0XHRcdFx0XHR3aW5kb3cub3Blbihgc2hvcnRjdXRzOi8vcnVuLXNob3J0Y3V0P25hbWU9QWRkJTIwT2JzaWRpYW4lMjBJbmJveCUyMEV2ZW50JTIwdmlhJTIwRmFudGFzdGljYWwmaW5wdXQ9dGV4dCZ0ZXh0PSR7dGV4dH0meC1zdWNjZXNzPW9ic2lkaWFuOi8vJngtY2FuY2VsPW9ic2lkaWFuOi8vJngtZXJyb3I9b2JzaWRpYW46Ly9gKTtcblx0XHRcdFx0ICB9XG5cdFx0XHRcdH0pO1xuXHRcdFx0ICB9LFxuXHRcdFx0ICBcblx0XHRcdFxuXHRcdH0pO1xuXG5cdFx0dGhpcy5hZGRPYnNpZGlhbkljb24oJ2FjdGlvbi10by1mYW50YXN0aWNhbC1ldmVudC1pY29uJywgJ0FGJyk7XG5cdFx0dGhpcy5hZGRDb21tYW5kKHtcblx0XHRcdGlkOiBcImFjdGlvbi10by1mYW50YXN0aWNhbC1ldmVudFwiLFxuXHRcdFx0bmFtZTogXCJBRiBBY3Rpb24gdG8gRmFudGFzdGljYWwgRXZlbnRcIixcblx0XHRcdGljb246IGBhY3Rpb24tdG8tZmFudGFzdGljYWwtZXZlbnQtaWNvbmAsXG5cdFx0XHRlZGl0b3JDYWxsYmFjazogKGVkaXRvcjogRWRpdG9yLCB2aWV3OiBNYXJrZG93blZpZXcpID0+IHtcblx0XHRcdFx0bGV0IHRleHQgPSBcIlwiO1xuXHRcdFx0XHRjb25zdCB2YXVsdDogVmF1bHQgPSB0aGlzLmFwcC52YXVsdDtcblx0XHRcdFx0Y29uc3QgbGlzdFNlbGVjdGlvbnM6IEVkaXRvclNlbGVjdGlvbltdID0gZWRpdG9yLmxpc3RTZWxlY3Rpb25zKCk7XG5cdFx0XHQgIFxuXHRcdFx0XHRmb3IgKGNvbnN0IGxpc3RTZWxlY3Rpb24gb2YgbGlzdFNlbGVjdGlvbnMpIHtcblx0XHRcdFx0XHRjb25zdCBhID0gbGlzdFNlbGVjdGlvbi5oZWFkLmxpbmU7XG5cdFx0XHRcdFx0Y29uc3QgYiA9IGxpc3RTZWxlY3Rpb24uYW5jaG9yLmxpbmU7XG5cdFx0XHRcdFx0Y29uc3QgZnJvbUxpbmVOdW0gPSBiID4gYSA/IGEgOiBiO1xuXHRcdFx0XHRcdGNvbnN0IHRvTGluZU51bSA9IGIgPiBhID8gYiA6IGE7XG5cdFx0XHRcdFxuXHRcdFx0XHRcdGZvciAobGV0IGkgPSBmcm9tTGluZU51bTsgaSA8PSB0b0xpbmVOdW07IGkrKykge1xuXHRcdFx0XHRcdFx0Y29uc3QgbGluZSA9IGVkaXRvci5nZXRMaW5lKGkpO1xuXHRcdFx0XHRcdFx0dGV4dCArPSBsaW5lLnRyaW0oKSArIFwiQEBAXCI7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRleHQgPSB0ZXh0LnJlcGxhY2UoL0BAQCQvLCBcIlwiKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNvbnN0IHZhdWx0TmFtZSA9IGFwcC52YXVsdC5nZXROYW1lKCk7XG5cdFx0XHRcdGNvbnN0IGZpbGVQYXRoID0gdmlldy5maWxlLnBhdGg7XG5cdFx0XHRcdGNvbnN0IHVybCA9IGBvYnNpZGlhbjovL29wZW4/dmF1bHQ9JHtlbmNvZGVVUklDb21wb25lbnQodmF1bHROYW1lKX0mZmlsZT0ke2VuY29kZVVSSUNvbXBvbmVudChmaWxlUGF0aCl9YDtcblx0XHRcdFx0Y29uc3QgZW5jb2RlZFVybCA9IGVuY29kZVVSSUNvbXBvbmVudCh1cmwpO1xuXHRcdFx0XHRcblx0XHRcdFx0Y29uc3QgaW5wdXQgPSBge1widGFza3NcIjpcIiR7dGV4dH1cIixcIm9ic2lkaWFuVVJMXCI6XCIke2VuY29kZWRVcmx9XCJ9YDtcblx0XHRcdFx0Ly9jb25zb2xlLmxvZyhpbnB1dClcblxuXHRcdFx0XHRcblx0XHRcdFx0Y29uc3Qgc2hvcnRjdXRVcmwgPSBgc2hvcnRjdXRzOi8vcnVuLXNob3J0Y3V0P25hbWU9JHtlbmNvZGVVUklDb21wb25lbnQoXCJPYnNpZGlhbiBBY3Rpb24gVG8gRmFudGFzdGljYWwgUHVzaCBldmVudFwiKX0maW5wdXQ9dGV4dCZ0ZXh0PSR7ZW5jb2RlVVJJQ29tcG9uZW50KGlucHV0KX0meC1zdWNjZXNzPW9ic2lkaWFuOi8vJngtY2FuY2VsPW9ic2lkaWFuOi8vJngtZXJyb3I9b2JzaWRpYW46Ly9gXG5cdFx0XHRcdC8vY29uc29sZS5sb2coc2hvcnRjdXRVcmwpXG5cblx0XHRcdFx0d2luZG93Lm9wZW4oc2hvcnRjdXRVcmwpO1xuXHRcdFx0ICB9LFxuXHRcdFx0ICBob3RrZXlzOiBbXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRtb2RpZmllcnM6IFtgQ3RybGAsIGBNZXRhYCwgYFNoaWZ0YF0sXG5cdFx0XHRcdFx0a2V5OiBgRmAsXG5cdFx0XHRcdH0sXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRtb2RpZmllcnM6IFtgQ3RybGAsIGBBbHRgLCBgU2hpZnRgXSxcblx0XHRcdFx0XHRrZXk6IGBGYCxcblx0XHRcdFx0fSxcblx0XHRcdF1cblx0XHRcdFxuXHRcdH0pO1xuXG5cdFx0XG5cdFx0Lypcblx0XHR0aGlzLmFkZENvbW1hbmQoe1xuXHRcdFx0aWQ6IFwicmVtb3ZlLWZpcnN0LXRhYi1mcm9tLXNlbGVjdGVkLWxpbmVzXCIsXG5cdFx0XHRuYW1lOiBcIlJlbW92ZSBmaXJzdCB0YWIgZnJvbSBzZWxlY3RlZCBsaW5lc1wiLFxuXHRcdFx0ZWRpdG9yQ2FsbGJhY2s6IChlZGl0b3I6IEVkaXRvciwgdmlldzogTWFya2Rvd25WaWV3KSA9PiB7XG5cdFx0XHRcdGNvbnN0IGxpc3RTZWxlY3Rpb25zID0gZWRpdG9yLmxpc3RTZWxlY3Rpb25zKCk7XG5cdFx0XHRcdGxpc3RTZWxlY3Rpb25zLmZvckVhY2gobGlzdFNlbGVjdGlvbiA9PiB7XG5cdFx0XHRcdFx0Y29uc3QgZnJvbUxpbmVOdW0gPSBsaXN0U2VsZWN0aW9uLmhlYWQubGluZVxuXHRcdFx0XHRcdGNvbnN0IHRvTGluZU51bSA9IGxpc3RTZWxlY3Rpb24uYW5jaG9yLmxpbmVcblx0XHRcdFx0XHRmb3IgKGxldCBpID0gZnJvbUxpbmVOdW07IGkgPD0gdG9MaW5lTnVtOyBpKyspIHtcblx0XHRcdFx0XHRcdGNvbnN0IGxpbmUgPSBlZGl0b3IuZ2V0TGluZShpKVxuXHRcdFx0XHRcdFx0Y29uc3QgbW9kaWZpZWRMaW5lID0gbGluZS5yZXBsYWNlKC9cXHQvLCAnJylcblx0XHRcdFx0XHRcdGVkaXRvci5zZXRMaW5lKGksIG1vZGlmaWVkTGluZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KVxuXHRcdFx0fSxcblx0XHR9KTtcblx0XHQqL1xuXG5cdFx0dGhpcy5hZGRDb21tYW5kKHtcblx0XHRcdGlkOiBcImdyZXAtdGl0bGUtYXMtbGluay10by1jbGlwYm9hcmRcIixcblx0XHRcdG5hbWU6IFwiR3JlcCBUaXRsZSBhcyBsaW5rIHRvIGNsaXBib2FyZFwiLFxuXHRcdFx0aWNvbjogYGNsaXBib2FyZC1saXN0YCxcblx0XHRcdGVkaXRvckNhbGxiYWNrOiBhc3luYyAoZWRpdG9yOiBFZGl0b3IsIHZpZXc6IE1hcmtkb3duVmlldykgPT4ge1xuXHRcdFx0XHRjb25zdCB0aXRsZSA9IHZpZXcuZmlsZS5iYXNlbmFtZTtcblx0XHRcdFx0Y29uc3QgdGl0bGVBc0xpbmsgPSBgW1ske3RpdGxlfV1dYDtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHR0aGlzLmFkZFRvQ2xpcGJvYXJkSGlzdG9yeSh0aXRsZUFzTGluayk7XG5cdFx0XHRcdFx0YXdhaXQgbmF2aWdhdG9yLmNsaXBib2FyZC53cml0ZVRleHQodGl0bGVBc0xpbmspO1xuXHRcdFx0XHRcdG5ldyBOb3RpY2UoYENvcGllZCB0aXRsZSBcIiR7dGl0bGV9XCIgYXMgbGluayB0byBjbGlwYm9hcmQhYCk7XG5cdFx0XHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRcdFx0bmV3IE5vdGljZShgRXJyb3Igb2NjdXJyZWQgd2hlbiBjb3B5aW5nIHRvIGNsaXBib2FyZDogJHtlcnJvcn1gKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGhvdGtleXM6IFtcblx0XHRcdFx0e1xuXHRcdFx0XHRcdG1vZGlmaWVyczogW2BNZXRhYCwgYFNoaWZ0YF0sXG5cdFx0XHRcdFx0a2V5OiBgbGAsXG5cdFx0XHRcdH0sXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRtb2RpZmllcnM6IFtgQ3RybGAsIGBTaGlmdGBdLFxuXHRcdFx0XHRcdGtleTogYGxgLFxuXHRcdFx0XHR9XG5cdFx0XHRdXG5cdFx0fSk7XG5cblx0XHR0aGlzLmFkZE9ic2lkaWFuSWNvbignbW92ZS1jdXJyZW50LXNlbGVjdGlvbi10by1iZWdpbm5pbmctb2Ytbm90ZXMnLCAnPDwnKTtcblx0XHR0aGlzLmFkZENvbW1hbmQoe1xuXHRcdFx0aWQ6IFwibW92ZS1jdXJyZW50LXNlbGVjdGlvbi10by1iZWdpbm5pbmctb2Ytbm90ZXNcIixcblx0XHRcdG5hbWU6IFwiTUIgPDwgTW92ZSBjdXJyZW50IHNlbGVjdGlvbiB0byBiZWdpbm5pbmcgb2Ygbm90ZXNcIixcblx0XHRcdGljb246IGBtb3ZlLWN1cnJlbnQtc2VsZWN0aW9uLXRvLWJlZ2lubmluZy1vZi1ub3Rlc2AsXG5cdFx0XHRlZGl0b3JDYWxsYmFjazogKGVkaXRvcjogRWRpdG9yLCB2aWV3OiBNYXJrZG93blZpZXcpID0+IHtcblx0XHRcdFx0bGV0IHNlbGVjdGlvbiA9IGV4cG9ydEN1cnJlbnRTZWxlY3Rpb24oZWRpdG9yKVxuXHRcdFx0XHRpZiAoL14gICAgKy0gL20udGVzdChzZWxlY3Rpb24pXG5cdFx0XHRcdCAgfHwgL14tIC9tLnRlc3Qoc2VsZWN0aW9uKVxuXHRcdFx0XHQgIHx8IC9eIyAvbS50ZXN0KHNlbGVjdGlvbilcblx0XHRcdFx0ICB8fCAvXmAgL20udGVzdChzZWxlY3Rpb24pXG5cdFx0XHRcdCAgfHwgL14+IC9tLnRlc3Qoc2VsZWN0aW9uKVxuXHRcdFx0XHQgIHx8IC9eXFxkK1xcLiAvbS50ZXN0KHNlbGVjdGlvbilcblx0XHRcdFx0ICApXG5cdFx0XHRcdHtcblx0XHRcdFx0Ly8gZG8gbm90aGluZ1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHNlbGVjdGlvbiA9IFwiLSBcIiArIHNlbGVjdGlvblxuXHRcdFx0XHR9XG5cdFx0XHRcdGxldCBuZXdDb250ZW50ID0gJydcblx0XHRcdFx0Y29uc3Qgc2VsZWN0aW9uUmFuZ2U6IFNlbGVjdGlvblJhbmdlID0gZ2V0Q3VycmVudFNlbGVjdGlvbkxpbmVOdW1iZXIoZWRpdG9yKVxuXHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGVkaXRvci5saW5lQ291bnQoKTsgaSsrKSB7XG5cdFx0XHRcdFx0aWYgKGkgPCBzZWxlY3Rpb25SYW5nZS5mcm9tTGluZU51bSB8fCBpID4gc2VsZWN0aW9uUmFuZ2UudG9MaW5lTnVtKSB7XG5cdFx0XHRcdFx0XHRuZXdDb250ZW50ID0gbmV3Q29udGVudCArIGVkaXRvci5nZXRMaW5lKGkpICsgXCJcXG5cIlxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0bmV3IEFkZFRleHRUb05vdGVzTW9kYWwodGhpcy5hcHAsIHNlbGVjdGlvbiwgXCJtb3ZlIHRoZSBzZWxlY3RlZCB0ZXh0XCIsIHRydWUsICgpID0+IGVkaXRvci5zZXRWYWx1ZShuZXdDb250ZW50LnJlcGxhY2UoL1xcbiQvbSwgXCJcIikpKS5vcGVuKClcblx0XHRcdH0sXG5cdFx0XHRob3RrZXlzOiBbXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRtb2RpZmllcnM6IFtgQ3RybGAsIGBNZXRhYCwgYFNoaWZ0YF0sXG5cdFx0XHRcdFx0a2V5OiBgLGAsXG5cdFx0XHRcdH0sXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRtb2RpZmllcnM6IFtgQ3RybGAsIGBBbHRgLCBgU2hpZnRgXSxcblx0XHRcdFx0XHRrZXk6IGAsYCxcblx0XHRcdFx0fSxcblx0XHRcdF1cblx0XHR9KVxuXG5cdFx0dGhpcy5hZGRPYnNpZGlhbkljb24oJ21vdmUtY3VycmVudC1zZWxlY3Rpb24tdG8tZW5kLW9mLW5vdGVzJywgJz4+Jyk7XG5cdFx0dGhpcy5hZGRDb21tYW5kKHtcblx0XHRcdGlkOiBcIm1vdmUtY3VycmVudC1zZWxlY3Rpb24tdG8tZW5kLW9mLW5vdGVzXCIsXG5cdFx0XHRuYW1lOiBcIk1FID4+IE1vdmUgY3VycmVudCBzZWxlY3Rpb24gdG8gYmVnaW5uaW5nIG9mIG5vdGVzXCIsXG5cdFx0XHRpY29uOiBgbW92ZS1jdXJyZW50LXNlbGVjdGlvbi10by1lbmQtb2Ytbm90ZXNgLFxuXHRcdFx0ZWRpdG9yQ2FsbGJhY2s6IChlZGl0b3I6IEVkaXRvciwgdmlldzogTWFya2Rvd25WaWV3KSA9PiB7XG5cdFx0XHRcdGxldCBzZWxlY3Rpb24gPSBleHBvcnRDdXJyZW50U2VsZWN0aW9uKGVkaXRvcilcblx0XHRcdFx0aWYgKC9eICAgICstIC9tLnRlc3Qoc2VsZWN0aW9uKVxuXHRcdFx0XHQgIHx8IC9eLSAvbS50ZXN0KHNlbGVjdGlvbilcblx0XHRcdFx0ICB8fCAvXiMgL20udGVzdChzZWxlY3Rpb24pXG5cdFx0XHRcdCAgfHwgL15gIC9tLnRlc3Qoc2VsZWN0aW9uKVxuXHRcdFx0XHQgIHx8IC9ePiAvbS50ZXN0KHNlbGVjdGlvbilcblx0XHRcdFx0ICB8fCAvXlxcZCtcXC4gL20udGVzdChzZWxlY3Rpb24pXG5cdFx0XHRcdCAgKVxuXHRcdFx0XHR7XG5cdFx0XHRcdC8vIGRvIG5vdGhpbmdcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRzZWxlY3Rpb24gPSBcIi0gXCIgKyBzZWxlY3Rpb25cblx0XHRcdFx0fVxuXHRcdFx0XHRsZXQgbmV3Q29udGVudCA9ICcnXG5cdFx0XHRcdGNvbnN0IHNlbGVjdGlvblJhbmdlOiBTZWxlY3Rpb25SYW5nZSA9IGdldEN1cnJlbnRTZWxlY3Rpb25MaW5lTnVtYmVyKGVkaXRvcilcblx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBlZGl0b3IubGluZUNvdW50KCk7IGkrKykge1xuXHRcdFx0XHRcdGlmIChpIDwgc2VsZWN0aW9uUmFuZ2UuZnJvbUxpbmVOdW0gfHwgaSA+IHNlbGVjdGlvblJhbmdlLnRvTGluZU51bSkge1xuXHRcdFx0XHRcdFx0bmV3Q29udGVudCA9IG5ld0NvbnRlbnQgKyBlZGl0b3IuZ2V0TGluZShpKSArIFwiXFxuXCJcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHRcdG5ldyBBZGRUZXh0VG9Ob3Rlc01vZGFsKHRoaXMuYXBwLCBzZWxlY3Rpb24sIFwibW92ZSB0aGUgc2VsZWN0ZWQgdGV4dFwiLCBmYWxzZSwgKCkgPT4gZWRpdG9yLnNldFZhbHVlKG5ld0NvbnRlbnQucmVwbGFjZSgvXFxuJC9tLCBcIlwiKSkpLm9wZW4oKVxuXHRcdFx0fSxcblx0XHRcdGhvdGtleXM6IFtcblx0XHRcdFx0e1xuXHRcdFx0XHRcdG1vZGlmaWVyczogW2BDdHJsYCwgYE1ldGFgLCBgU2hpZnRgXSxcblx0XHRcdFx0XHRrZXk6IGAuYCxcblx0XHRcdFx0fSxcblx0XHRcdFx0e1xuXHRcdFx0XHRcdG1vZGlmaWVyczogW2BDdHJsYCwgYEFsdGAsIGBTaGlmdGBdLFxuXHRcdFx0XHRcdGtleTogYC5gLFxuXHRcdFx0XHR9LFxuXHRcdFx0XVxuXHRcdH0pXG5cblx0XHR0aGlzLmFkZE9ic2lkaWFuSWNvbignYWRkLWN1cnJlbnQtc2VsZWN0aW9uLXRvLWJlZ2lubmluZy1vZi1ub3RlcycsICcoKCcpO1xuXHRcdHRoaXMuYWRkQ29tbWFuZCh7XG5cdFx0XHRpZDogXCJhZGQtY3VycmVudC1zZWxlY3Rpb24tdG8tYmVnaW5uaW5nLW9mLW5vdGVzXCIsXG5cdFx0XHRuYW1lOiBcIlNCICgoIEFkZCBjdXJyZW50IHNlbGVjdGlvbiB0byBiZWdpbm5pbmcgb2Ygbm90ZXNcIixcblx0XHRcdGljb246IGBhZGQtY3VycmVudC1zZWxlY3Rpb24tdG8tYmVnaW5uaW5nLW9mLW5vdGVzYCxcblx0XHRcdGVkaXRvckNhbGxiYWNrOiAoZWRpdG9yOiBFZGl0b3IsIHZpZXc6IE1hcmtkb3duVmlldykgPT4ge1xuXHRcdFx0XHRsZXQgc2VsZWN0aW9uID0gZXhwb3J0Q3VycmVudFNlbGVjdGlvbihlZGl0b3IpXG5cdFx0XHRcdGlmICgvXiAgICArLSAvbS50ZXN0KHNlbGVjdGlvbilcblx0XHRcdFx0ICB8fCAvXi0gL20udGVzdChzZWxlY3Rpb24pXG5cdFx0XHRcdCAgfHwgL14jIC9tLnRlc3Qoc2VsZWN0aW9uKVxuXHRcdFx0XHQgIHx8IC9eYCAvbS50ZXN0KHNlbGVjdGlvbilcblx0XHRcdFx0ICB8fCAvXj4gL20udGVzdChzZWxlY3Rpb24pXG5cdFx0XHRcdCAgfHwgL15cXGQrXFwuIC9tLnRlc3Qoc2VsZWN0aW9uKVxuXHRcdFx0XHQgICkge1xuXHRcdFx0XHRcdC8vIGRvIG5vdGhpbmdcblx0XHRcdFx0ICB9IGVsc2Uge1xuXHRcdFx0XHRcdHNlbGVjdGlvbiA9IFwiLSBcIiArIHNlbGVjdGlvblxuXHRcdFx0XHQgIH1cblx0XHRcdFx0bmV3IEFkZFRleHRUb05vdGVzTW9kYWwodGhpcy5hcHAsIHNlbGVjdGlvbiwgXCJhZGQgdGhlIHNlbGVjdGVkIHRleHRcIiwgdHJ1ZSwgKCkgPT4ge30pLm9wZW4oKVxuXHRcdFx0fSxcblx0XHRcdGhvdGtleXM6IFtcblx0XHRcdFx0e1xuXHRcdFx0XHRcdG1vZGlmaWVyczogW2BDdHJsYCwgYE1ldGFgLCBgU2hpZnRgXSxcblx0XHRcdFx0XHRrZXk6IGA5YCxcblx0XHRcdFx0fSxcblx0XHRcdFx0e1xuXHRcdFx0XHRcdG1vZGlmaWVyczogW2BDdHJsYCwgYEFsdGAsIGBTaGlmdGBdLFxuXHRcdFx0XHRcdGtleTogYDlgLFxuXHRcdFx0XHR9LFxuXHRcdFx0XVxuXHRcdH0pXG5cblx0XHR0aGlzLmFkZE9ic2lkaWFuSWNvbignYWRkLWN1cnJlbnQtc2VsZWN0aW9uLXRvLWVuZC1vZi1ub3RlcycsICcpKScpO1xuXHRcdHRoaXMuYWRkQ29tbWFuZCh7XG5cdFx0XHRpZDogXCJhZGQtY3VycmVudC1zZWxlY3Rpb24tdG8tZW5kLW9mLW5vdGVzXCIsXG5cdFx0XHRuYW1lOiBcIlNFICkpIEFkZCBjdXJyZW50IHNlbGVjdGlvbiB0byBlbmQgb2Ygbm90ZXNcIixcblx0XHRcdGljb246IGBhZGQtY3VycmVudC1zZWxlY3Rpb24tdG8tZW5kLW9mLW5vdGVzYCxcblx0XHRcdGVkaXRvckNhbGxiYWNrOiAoZWRpdG9yOiBFZGl0b3IsIHZpZXc6IE1hcmtkb3duVmlldykgPT4ge1xuXHRcdFx0XHRsZXQgc2VsZWN0aW9uID0gZXhwb3J0Q3VycmVudFNlbGVjdGlvbihlZGl0b3IpXG5cdFx0XHRcdGlmICgvXiAgICArLSAvbS50ZXN0KHNlbGVjdGlvbilcblx0XHRcdFx0ICB8fCAvXi0gL20udGVzdChzZWxlY3Rpb24pXG5cdFx0XHRcdCAgfHwgL14jIC9tLnRlc3Qoc2VsZWN0aW9uKVxuXHRcdFx0XHQgIHx8IC9eYCAvbS50ZXN0KHNlbGVjdGlvbilcblx0XHRcdFx0ICB8fCAvXj4gL20udGVzdChzZWxlY3Rpb24pXG5cdFx0XHRcdCAgfHwgL15cXGQrXFwuIC9tLnRlc3Qoc2VsZWN0aW9uKVxuXHRcdFx0XHQgICkge1xuXHRcdFx0XHRcdC8vIGRvIG5vdGhpbmdcblx0XHRcdFx0ICB9IGVsc2Uge1xuXHRcdFx0XHRcdHNlbGVjdGlvbiA9IFwiLSBcIiArIHNlbGVjdGlvblxuXHRcdFx0XHQgIH1cblx0XHRcdFx0bmV3IEFkZFRleHRUb05vdGVzTW9kYWwodGhpcy5hcHAsIHNlbGVjdGlvbiwgXCJhZGQgdGhlIHNlbGVjdGVkIHRleHRcIiwgZmFsc2UsICgpID0+IHt9KS5vcGVuKClcblx0XHRcdH0sXG5cdFx0XHRob3RrZXlzOiBbXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRtb2RpZmllcnM6IFtgQ3RybGAsIGBNZXRhYCwgYFNoaWZ0YF0sXG5cdFx0XHRcdFx0a2V5OiBgMGAsXG5cdFx0XHRcdH0sXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRtb2RpZmllcnM6IFtgQ3RybGAsIGBBbHRgLCBgU2hpZnRgXSxcblx0XHRcdFx0XHRrZXk6IGAwYCxcblx0XHRcdFx0fSxcblx0XHRcdF1cblx0XHR9KVxuXG5cdFx0dGhpcy5hZGRPYnNpZGlhbkljb24oJ2FkZC1jdXJyZW50LWxpbmstdG8tYmVnaW5uaW5nLW9mLW5vdGVzJywgJ1tbJyk7XG5cdFx0dGhpcy5hZGRDb21tYW5kKHtcblx0XHRcdGlkOiBcImFkZC1jdXJyZW50LWxpbmstdG8tYmVnaW5uaW5nLW9mLW5vdGVzXCIsXG5cdFx0XHRuYW1lOiBcIkxCIFtbIEFkZCBjdXJyZW50IGxpbmsgdG8gYmVnaW5uaW5nIG9mIG5vdGVzXCIsXG5cdFx0XHRpY29uOiBgYWRkLWN1cnJlbnQtbGluay10by1iZWdpbm5pbmctb2Ytbm90ZXNgLFxuXHRcdFx0ZWRpdG9yQ2FsbGJhY2s6IChlZGl0b3I6IEVkaXRvciwgdmlldzogTWFya2Rvd25WaWV3KSA9PiB7XG5cdFx0XHRcdGNvbnN0IGxpbmsgPSBcIi0gW1tcIiArIHZpZXcuZmlsZS5iYXNlbmFtZSArIFwiXV1cIjtcblx0XHRcdFx0bmV3IEFkZFRleHRUb05vdGVzTW9kYWwodGhpcy5hcHAsIGxpbmssIFwiYWRkIHRoZSBjdXJyZW50IG5vdGUgbGlua1wiLCB0cnVlLCAoKSA9PiB7fSkub3BlbigpXG5cdFx0XHR9LFxuXHRcdFx0aG90a2V5czogW1xuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bW9kaWZpZXJzOiBbYEN0cmxgLCBgTWV0YWAsIGBTaGlmdGBdLFxuXHRcdFx0XHRcdGtleTogYFtgLFxuXHRcdFx0XHR9LFxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bW9kaWZpZXJzOiBbYEN0cmxgLCBgQWx0YCwgYFNoaWZ0YF0sXG5cdFx0XHRcdFx0a2V5OiBgW2AsXG5cdFx0XHRcdH0sXG5cdFx0XHRdXG5cdFx0fSlcblxuXHRcdHRoaXMuYWRkT2JzaWRpYW5JY29uKCdhZGQtY3VycmVudC1saW5rLXRvLWVuZC1vZi1ub3RlcycsICddXScpO1xuXHRcdHRoaXMuYWRkQ29tbWFuZCh7XG5cdFx0XHRpZDogXCJhZGQtY3VycmVudC1saW5rLXRvLWVuZC1vZi1ub3Rlc1wiLFxuXHRcdFx0bmFtZTogXCJMRSBdXSBBZGQgY3VycmVudCBsaW5rIHRvIGVuZC1vZi1ub3Rlc1wiLFxuXHRcdFx0aWNvbjogYGFkZC1jdXJyZW50LWxpbmstdG8tZW5kLW9mLW5vdGVzYCxcblx0XHRcdGVkaXRvckNhbGxiYWNrOiAoZWRpdG9yOiBFZGl0b3IsIHZpZXc6IE1hcmtkb3duVmlldykgPT4ge1xuXHRcdFx0XHRjb25zdCBsaW5rID0gXCItIFtbXCIgKyB2aWV3LmZpbGUuYmFzZW5hbWUgKyBcIl1dXCI7XG5cdFx0XHRcdG5ldyBBZGRUZXh0VG9Ob3Rlc01vZGFsKHRoaXMuYXBwLCBsaW5rLCBcImFkZCB0aGUgY3VycmVudCBub3RlIGxpbmtcIiwgZmFsc2UsICgpID0+IHt9KS5vcGVuKClcblx0XHRcdH0sXG5cdFx0XHRob3RrZXlzOiBbXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRtb2RpZmllcnM6IFtgQ3RybGAsIGBNZXRhYCwgYFNoaWZ0YF0sXG5cdFx0XHRcdFx0a2V5OiBgXWAsXG5cdFx0XHRcdH0sXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRtb2RpZmllcnM6IFtgQ3RybGAsIGBBbHRgLCBgU2hpZnRgXSxcblx0XHRcdFx0XHRrZXk6IGBdYCxcblx0XHRcdFx0fSxcblx0XHRcdF1cblx0XHR9KVxuXG5cdFx0Ly90aGlzLmFkZE9ic2lkaWFuSWNvbignbmF2aWdhdGUtdG8tZm9yd2FyZGxpbmtzLWJhY2tsaW5rcycsICc8PicpO1xuXHRcdHRoaXMuYWRkQ29tbWFuZCh7XG5cdFx0XHRpZDogXCJuYXZpZ2F0ZS10by1mb3J3YXJkbGlua3MtYmFja2xpbmtzXCIsXG5cdFx0XHRuYW1lOiBcIkJMIE5hdmlnYXRlIHRvIEZvcndhcmRsaW5rcy9CYWNrbGlua3NcIixcblx0XHRcdGljb246IGBsaW5rLTJgLFxuXHRcdFx0ZWRpdG9yQ2FsbGJhY2s6IChlZGl0b3I6IEVkaXRvciwgdmlldzogTWFya2Rvd25WaWV3KSA9PiB7XG5cdFx0XHRcdG5ldyBOYXZpZ2F0ZVRvRm9yd2FyZEFuZEJhY2tsaW5rVGFnTW9kYWwodGhpcy5hcHAsIHZpZXcsIGVkaXRvcikub3BlbigpXG5cdFx0XHR9LFxuXHRcdFx0aG90a2V5czogW1xuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bW9kaWZpZXJzOiBbYEN0cmxgLCBgTWV0YWAsIGBTaGlmdGBdLFxuXHRcdFx0XHRcdGtleTogYE9gLFxuXHRcdFx0XHR9LFxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bW9kaWZpZXJzOiBbYEN0cmxgLCBgQWx0YCwgYFNoaWZ0YF0sXG5cdFx0XHRcdFx0a2V5OiBgT2AsXG5cdFx0XHRcdH1cblx0XHRcdF1cblx0XHR9KVxuXG5cdFx0dGhpcy5hZGRDb21tYW5kKHtcblx0XHRcdGlkOiBcInF1aWNrLW5hdmlnYXRlLXRvLW5vdGVzXCIsXG5cdFx0XHRuYW1lOiBcIk5OIFF1aWNrIE5hdmlnYXRlIHRvIE5vdGVzXCIsXG5cdFx0XHRpY29uOiBgYXBlcnR1cmVgLFxuXHRcdFx0Y2FsbGJhY2s6IGFzeW5jICgpID0+IHtcblx0XHRcdFx0bmV3IE5hdmlnYXRlVG9Ob3RlRnJvbVRhZ01vZGFsKHRoaXMuYXBwKS5vcGVuKClcblx0XHRcdH0sXG5cdFx0XHRob3RrZXlzOiBbXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRtb2RpZmllcnM6IFtgQ3RybGAsIGBNZXRhYCwgYFNoaWZ0YF0sXG5cdFx0XHRcdFx0a2V5OiBgO2AsXG5cdFx0XHRcdH0sXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRtb2RpZmllcnM6IFtgQ3RybGAsIGBBbHRgLCBgU2hpZnRgXSxcblx0XHRcdFx0XHRrZXk6IGA7YCxcblx0XHRcdFx0fSxcblx0XHRcdF1cblx0XHR9KVxuXG5cdFx0dGhpcy5hZGRDb21tYW5kKHtcblx0XHRcdGlkOiBcInF1ZXJ5LW5vdGVzLXdpdGhvdXQtb3ItaW52YWxpZC1tZXRhZGF0YVwiLFxuXHRcdFx0bmFtZTogXCJRdWVyeSBOb3RlcyB3aXRob3V0IG9yIGludmFsaWQgbWV0YWRhdGFcIixcblx0XHRcdGVkaXRvckNhbGxiYWNrOiBhc3luYyAoZWRpdG9yOiBFZGl0b3IsIHZpZXc6IE1hcmtkb3duVmlldykgPT4ge1xuXHRcdFx0XHRjb25zb2xlLmxvZyh2aWV3LmZpbGUucGF0aClcblx0XHRcdFx0bGV0IHJlc3VsdFZhbHVlID0gXCIjIyBOb3RlcyB3aXRob3V0IG1ldGFkYXRhXFxuXFxuSGlnaGxpZ2h0IG1lYW5pbmcgaW52YWxpZCBtZXRhZGF0YVxcblwiXG5cdFx0XHRcdGNvbnN0IHF1ZXJ5TWQgPSBcIkkvU2VsZiBRdWVyeS5tZFwiXG5cdFx0XHRcdGlmICh2aWV3LmZpbGUucGF0aCA9PT0gcXVlcnlNZCkge1xuXHRcdFx0XHRcdG5ldyBOb3RpY2UoXCJOZWVkIHNvbWUgdGltZSB0byBnZW5lcmF0ZSByZXN1bHRcIilcblx0XHRcdFx0XHRjb25zdCByZXN1bHQgOiBzdHJpbmdbXSA9IGdldEFsbE5vdGVzV2l0aG91dE1ldGFkYXRhKHRoaXMuYXBwKVxuXHRcdFx0XHRcdGxldCByZXN1bHRXaXRob3V0TWV0YWRhdGE6IFRGaWxlW10gPSBbXVxuXHRcdFx0XHRcdGxldCByZXN1bHRJbnZhbGlkTWV0YWRhdGE6IFRGaWxlW10gPSBbXVxuXHRcdFx0XHRcdGZvciAoY29uc3QgZmlsZVBhdGggb2YgcmVzdWx0KSB7XG5cdFx0XHRcdFx0XHRjb25zdCB0RmlsZTogVEZpbGUgPSB0aGlzLmFwcC52YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgoZmlsZVBhdGgpIGFzIFRGaWxlO1xuXHRcdFx0XHRcdFx0Y29uc3QgY29udGVudCA9IGF3YWl0IHRoaXMuYXBwLnZhdWx0LnJlYWQodEZpbGUpO1xuXHRcdFx0XHRcdFx0aWYgKGNvbnRlbnQuc3RhcnRzV2l0aChcIi0tLVwiKSkge1xuXHRcdFx0XHRcdFx0ICAgIHJlc3VsdEludmFsaWRNZXRhZGF0YS5wdXNoKHRGaWxlKTtcblx0XHRcdFx0XHRcdCAgICAvL2NvbnNvbGUubG9nKGZpbGVQYXRoKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHJlc3VsdFdpdGhvdXRNZXRhZGF0YS5wdXNoKHRGaWxlKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Zm9yIChjb25zdCB0RmlsZSBvZiByZXN1bHRJbnZhbGlkTWV0YWRhdGEpIHtcblx0XHRcdFx0XHRcdHJlc3VsdFZhbHVlICs9IFwiXFxuLSA9PVtbXCIgKyB0RmlsZS5iYXNlbmFtZSArIFwiXV09PVwiXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGZvciAoY29uc3QgdEZpbGUgb2YgcmVzdWx0V2l0aG91dE1ldGFkYXRhKSB7XG5cdFx0XHRcdFx0XHRyZXN1bHRWYWx1ZSArPSBcIlxcbi0gW1tcIiArIHRGaWxlLmJhc2VuYW1lICsgXCJdXVwiXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVkaXRvci5zZXRWYWx1ZShyZXN1bHRWYWx1ZSlcblx0XHRcdFx0XHRuZXcgTm90aWNlKFwiVXBkYXRlZCBub3RlcyB3aXRob3V0IG1ldGFkYXRhLiBTaXplPVwiICsgcmVzdWx0Lmxlbmd0aClcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRuZXcgTm90aWNlKFwiUGxlYXNlIGdvIHRvICdcIiArIHF1ZXJ5TWQgKyBcIicgdG8gcnVuIHRoaXMgYWN0aW9uXCIpXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KVxuXG5cdFx0dGhpcy5hZGRPYnNpZGlhbkljb24oJ3RocmVhZHMtdG8tdHdpdHRlcicsICdUWCcpO1xuXHRcdHRoaXMuYWRkQ29tbWFuZCh7XG5cdFx0XHRpZDogXCJ0aHJlYWRzLXRvLXR3aXR0ZXJcIixcblx0XHRcdG5hbWU6IFwiVFQgVFggVGhyZWFkcyB0byBUd2l0dGVyXCIsXG5cdFx0XHRpY29uOiBgdGhyZWFkcy10by10d2l0dGVyYCxcblx0XHRcdGVkaXRvckNhbGxiYWNrOiAoZWRpdG9yOiBFZGl0b3IsIHZpZXc6IE1hcmtkb3duVmlldykgPT4ge1xuXHRcdFx0XHRjb25zdCB7IHZhdWx0IH0gPSB0aGlzLmFwcDtcblx0XHRcdFx0bGV0IHYgPSBlZGl0b3IuZ2V0VmFsdWUoKVxuXHRcdFx0XHR2ID0gdi5yZXBsYWNlKC8tLS1cXG4rIyMgW1JyXWVmZXJlbmNlcz9cXDooW1xcbl0qLiopKiQvLCBcIlwiKTtcblx0XHRcdFx0diA9IHYucmVwbGFjZSgvLS0tXFxuKyMjIFtScl1lZmVyZW5jZXM/KFtcXG5dKi4qKSokLywgXCJcIik7XG5cdFx0XHRcdGNvbnN0IHBhdGggPSB2aWV3LmZpbGUucGF0aFxuXHRcdFx0XHRpZiAoIXBhdGgubWF0Y2goLy5cXC9UaHJlYWRzIFxcZFxcZFxcZFxcZFxcZFxcZFxcZFxcZC8pKSB7XG5cdFx0XHRcdFx0bmV3IE5vdGljZShgV2lsbCBub3QgcHJvY2VlZC4gSXQgaXMgbm90IGEgdGhyZWFkcyBwb3N0LmApO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHRjb25zdCBuZXdQYXRoID0gcGF0aC5yZXBsYWNlKC8oLlxcLylUaHJlYWRzIC8sIFwiJDFUd2l0dGVyIFwiKVxuXG5cdFx0XHRcdGNvbnN0IHsgd29ya3NwYWNlIH0gPSB0aGlzLmFwcDtcblx0XHRcdFx0Y29uc3QgbGVhZiA9IHdvcmtzcGFjZS5nZXRMZWFmKGZhbHNlKTtcblx0XHRcdFx0UHJvbWlzZS5yZXNvbHZlKClcblx0XHRcdFx0LnRoZW4oKCkgPT4ge1xuXHRcdFx0XHRcdHJldHVybiB2YXVsdC5hZGFwdGVyLmV4aXN0cyhuZXdQYXRoKTtcblx0XHRcdFx0fSlcblx0XHRcdFx0LnRoZW4oKGZpbGVFeGlzdHMpID0+IHtcblx0XHRcdFx0XHRpZiAoZmlsZUV4aXN0cykge1xuXHRcdFx0XHRcdFx0bmV3IE5vdGljZShgV2lsbCBub3QgcHJvY2VlZC4gVHdpdHRlciBwb3N0IGFscmVhZHkgZXhpc3QuYCk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gUHJvbWlzZS5yZWplY3QoXCJUd2l0dGVyIHBvc3QgYWxyZWFkeSBleGlzdFwiKVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjb25zdCB2YWx1ZSA9IGVkaXRvci5nZXRWYWx1ZSgpO1xuXHRcdFx0XHRcdGxldCBtb2RpZmllZFZhbHVlXG5cdFx0XHRcdFx0aWYgKC8tLS1cXG5cXG4jIyBbUnJdZWZlcmVuY2Vbc10qWzpdKlxcblxcbi9tLnRlc3QodmFsdWUpKSB7XG5cdFx0XHRcdFx0XHRtb2RpZmllZFZhbHVlID0gdmFsdWUucmVwbGFjZSgvKCMjIFtScl1lZmVyZW5jZVtzXSpbOl0qXFxuXFxuKS9tLCBcIiQxLSBbW1wiICsgdmlldy5maWxlLmJhc2VuYW1lLnJlcGxhY2UoL1RocmVhZHMgLywgXCJUd2l0dGVyIFwiKSArIFwiXV1cXG5cIilcblx0XHRcdFx0XHR9IGVsc2UgaWYgKC8tLS1bXFxuXFxzXSokLy50ZXN0KHZhbHVlKSkgeyAvLyBlbmQgd2l0aCAtLS1cblx0XHRcdFx0XHRcdG1vZGlmaWVkVmFsdWUgPSB2YWx1ZSArIFwiXFxuXFxuIyMgUmVmZXJlbmNlc1xcblxcbi0gW1tcIiArIHZpZXcuZmlsZS5iYXNlbmFtZS5yZXBsYWNlKC9UaHJlYWRzIC8sIFwiVHdpdHRlciBcIikgKyBcIl1dXFxuXCJcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0bW9kaWZpZWRWYWx1ZSA9IHZhbHVlICsgXCJcXG4tLS1cXG5cXG4jIyBSZWZlcmVuY2VzXFxuXFxuLSBbW1wiICsgdmlldy5maWxlLmJhc2VuYW1lLnJlcGxhY2UoL1RocmVhZHMgLywgXCJUd2l0dGVyIFwiKSArIFwiXV1cXG5cIlxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlZGl0b3Iuc2V0VmFsdWUobW9kaWZpZWRWYWx1ZSlcblx0XHRcdFx0XHRyZXR1cm4gdmF1bHQuY3JlYXRlKG5ld1BhdGgsIHYpO1xuXHRcdFx0XHR9KVxuXHRcdFx0XHQudGhlbigodEZpbGUpID0+IHtcblx0XHRcdFx0XHRyZXR1cm4gbGVhZi5vcGVuRmlsZSh0RmlsZSwgeyBhY3RpdmUgOiB0cnVlfSk7XG5cdFx0XHRcdH0sIHJlYXNvbiA9PiB7fSlcblx0XHRcdFx0LnRoZW4oKCkgPT4ge1xuXHRcdFx0XHRcdG5ldyBOb3RpY2UoYENyZWF0ZWQgYW5kIG9wZW5lZCBUd2l0dGVyIG5vdGVzIWApO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9KVxuXG5cdFx0dGhpcy5hZGRPYnNpZGlhbkljb24oJ3RocmVhZHMtcmV3cml0ZS1tb2RhbCcsICdUUicpO1xuXHRcdHRoaXMuYWRkQ29tbWFuZCh7XG5cdFx0XHRpZDogXCJ0aHJlYWRzLXJld3JpdGUtbW9kYWxcIixcblx0XHRcdG5hbWU6IFwiVFIgVGhyZWFkcyBSZXdyaXRlIE1vZGFsXCIsXG5cdFx0XHRpY29uOiBcInRocmVhZHMtcmV3cml0ZS1tb2RhbFwiLFxuXHRcdFx0ZWRpdG9yQ2FsbGJhY2s6IChlZGl0b3I6IEVkaXRvciwgdmlldzogTWFya2Rvd25WaWV3KSA9PiB7XG5cdFx0XHRcdG5ldyBSZXdyaXRlVGhyZWFkc01vZGFsKGFwcCwgZWRpdG9yLCB2aWV3KS5vcGVuKClcblx0XHRcdH1cblx0XHR9KVxuXG5cdFx0dGhpcy5hZGRPYnNpZGlhbkljb24oJ2ZpbmQtdGhyZWFkcy10by1yZXdyaXRlJywgJ0ZSJyk7XG5cdFx0dGhpcy5hZGRDb21tYW5kKHtcblx0XHRcdGlkOiBcImZpbmQtdGhyZWFkcy10by1yZXdyaXRlXCIsXG5cdFx0XHRuYW1lOiBcIkZSIEZpbmQgVGhyZWFkcyBUbyBSZXdyaXRlXCIsXG5cdFx0XHRpY29uOiBcImhhZmluZC10aHJlYWRzLXRvLXJld3JpdGVzaFwiLFxuXHRcdFx0Y2FsbGJhY2s6ICgpID0+IHtcblx0XHRcdFx0bmV3IE5hdmlnYXRlUmV3cml0YWJsZVRocmVhZHNNb2RhbChhcHApLm9wZW4oKVxuXHRcdFx0fVxuXHRcdH0pXG5cblx0XHR0aGlzLmFkZE9ic2lkaWFuSWNvbigncmV3cml0ZS1jdXJyZW50LXRocmVhZHMnLCAnVFInKTtcblx0XHR0aGlzLmFkZENvbW1hbmQoe1xuXHRcdFx0aWQ6IFwicmV3cml0ZS1jdXJyZW50LXRocmVhZHNcIixcblx0XHRcdG5hbWU6IFwiVFIgUmV3cml0ZSBDdXJyZW50IFRocmVhZHNcIixcblx0XHRcdGljb246IGByZXdyaXRlLWN1cnJlbnQtdGhyZWFkc2AsXG5cdFx0XHRlZGl0b3JDYWxsYmFjazogKGVkaXRvcjogRWRpdG9yLCB2aWV3OiBNYXJrZG93blZpZXcpID0+IHtcblx0XHRcdFx0Y29uc3QgeyB2YXVsdCB9ID0gdGhpcy5hcHA7XG5cdFx0XHRcdGxldCB2ID0gXCItLS1cXG50YWdzOiBjL3QvZFxcbi0tLVxcblxcblx1RDgzRVx1RERGNSBcXG5cXG5cXG4tLS1cXG5cXG4jIyBSZWZlcmVuY2VzXFxuXFxuLSBcXG5cXG5cIlxuXG5cdFx0XHRcdGNvbnN0IHBhdGggPSB2aWV3LmZpbGUucGF0aFxuXHRcdFx0XHRpZiAoIXBhdGgubWF0Y2goLy5cXC9UaHJlYWRzIFxcZFxcZFxcZFxcZFxcZFxcZFxcZFxcZC8pKSB7XG5cdFx0XHRcdFx0bmV3IE5vdGljZShgV2lsbCBub3QgcHJvY2VlZC4gSXQgaXMgbm90IGEgdGhyZWFkcyBwb3N0LmApO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0Y29uc3QgdG9kYXlZWVlZTU1ERCA9IG1vbWVudCgpLmZvcm1hdCgnWVlZWU1NREQnKTtcblx0XHRcdFx0Y29uc3QgbmV3UGF0aCA9IHBhdGgucmVwbGFjZSgvXiguXFwvVGhyZWFkcykgXFxkXFxkXFxkXFxkXFxkXFxkXFxkXFxkICguKikvLCBcIiQxIFwiICsgdG9kYXlZWVlZTU1ERCArIFwiICQyXCIpXG5cdFx0XHRcdGNvbnN0IG5ld05vdGVOYW1lID0gbmV3UGF0aC5yZXBsYWNlKC9eLlxcLy8sIFwiXCIpLnJlcGxhY2UoLy5tZCQvLCBcIlwiKVxuXG5cdFx0XHRcdGNvbnN0IHsgd29ya3NwYWNlIH0gPSB0aGlzLmFwcDtcblx0XHRcdFx0Y29uc3QgbGVhZiA9IHdvcmtzcGFjZS5nZXRMZWFmKGZhbHNlKTtcblx0XHRcdFx0UHJvbWlzZS5yZXNvbHZlKClcblx0XHRcdFx0LnRoZW4oKCkgPT4ge1xuXHRcdFx0XHRcdHJldHVybiB2YXVsdC5hZGFwdGVyLmV4aXN0cyhuZXdQYXRoKTtcblx0XHRcdFx0fSlcblx0XHRcdFx0LnRoZW4oKGZpbGVFeGlzdHMpID0+IHtcblx0XHRcdFx0XHRpZiAoZmlsZUV4aXN0cykge1xuXHRcdFx0XHRcdFx0bmV3IE5vdGljZShgV2lsbCBub3QgcHJvY2VlZC4gUmV3cml0dGVuIFRocmVhZCBwb3N0IHBvc3QgYWxyZWFkeSBleGlzdC5gKTtcblx0XHRcdFx0XHRcdHJldHVybiBQcm9taXNlLnJlamVjdChcIlRocmVhZHMgcG9zdCBhbHJlYWR5IGV4aXN0XCIpXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KS50aGVuKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRjb25zdCBiZWZvcmVUYWcgPSBcImMvdC9wXCJcblx0XHRcdFx0XHRjb25zdCBhZnRlclRhZyA9IFwiYy90L29cIlxuXHRcdFx0XHRcdHJldHVybiByZW5hbWVUYWcodmlldy5maWxlLCBiZWZvcmVUYWcsIGFmdGVyVGFnKVxuXHRcdFx0XHR9LCBmdW5jdGlvbiAoZXJyb3IpIHtcblx0XHRcdFx0XHRuZXcgTm90aWNlKGBlcnJvciB3aGVuIHJlbmFtZSB0YWchYCk7XG5cdFx0XHRcdH0pXG5cdFx0XHRcdC50aGVuKChyZW5hbWVTdWNjZXNzKSA9PiB7XG5cdFx0XHRcdFx0aWYgKCFyZW5hbWVTdWNjZXNzKSB7XG5cdFx0XHRcdFx0XHRuZXcgTm90aWNlKGBXaWxsIG5vdCBwcm9jZWVkLiBUaGUgb2xkIHBvc3Qgbm90IHB1Ymxpc2hlZCAobm90IGMvdC9wKS5gKTtcblx0XHRcdFx0XHRcdHJldHVybiBQcm9taXNlLnJlamVjdChcIldpbGwgbm90IHByb2NlZWQuIFRoZSBvbGQgcG9zdCBub3QgcHVibGlzaGVkIChub3QgYy90L3ApLlwiKVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjb25zdCB2YWx1ZSA9IGVkaXRvci5nZXRWYWx1ZSgpO1xuXHRcdFx0XHRcdGxldCBtb2RpZmllZFZhbHVlXG5cdFx0XHRcdFx0aWYgKC8tLS1cXG5cXG4jIyBbUnJdZWZlcmVuY2Vbc10qWzpdKlxcblxcbi9tLnRlc3QodmFsdWUpKSB7XG5cdFx0XHRcdFx0XHRtb2RpZmllZFZhbHVlID0gdmFsdWUucmVwbGFjZSgvKCMjIFtScl1lZmVyZW5jZVtzXSpbOl0qXFxuXFxuKS9tLCBcIiQxLSBSZXdyaXRlOiBbW1wiICsgbmV3Tm90ZU5hbWUgKyBcIl1dXFxuXCIpXG5cdFx0XHRcdFx0fSBlbHNlIGlmICgvLS0tW1xcblxcc10qJC8udGVzdCh2YWx1ZSkpIHsgLy8gZW5kIHdpdGggLS0tXG5cdFx0XHRcdFx0XHRtb2RpZmllZFZhbHVlID0gdmFsdWUgKyBcIlxcblxcbiMjIFJlZmVyZW5jZXNcXG5cXG4tIFJld3JpdGU6IFtbXCIgKyBuZXdOb3RlTmFtZSArIFwiXV1cXG5cIlxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRtb2RpZmllZFZhbHVlID0gdmFsdWUgKyBcIlxcbi0tLVxcblxcbiMjIFJlZmVyZW5jZXNcXG5cXG4tIFJld3JpdGU6IFtbXCIgKyBuZXdOb3RlTmFtZSArIFwiXV1cXG5cIlxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlZGl0b3Iuc2V0VmFsdWUobW9kaWZpZWRWYWx1ZSlcblx0XHRcdFx0XHRyZXR1cm4gdmF1bHQuY3JlYXRlKG5ld1BhdGgsIHYpO1xuXHRcdFx0XHR9KVxuXHRcdFx0XHQudGhlbigodEZpbGUpID0+IHtcblx0XHRcdFx0XHRyZXR1cm4gbGVhZi5vcGVuRmlsZSh0RmlsZSwgeyBhY3RpdmUgOiB0cnVlfSk7XG5cdFx0XHRcdH0sIHJlYXNvbiA9PiB7fSlcblx0XHRcdFx0LnRoZW4oKCkgPT4ge1xuXHRcdFx0XHRcdG5ldyBOb3RpY2UoYENyZWF0ZWQgYW5kIG9wZW5lZCBUaHJlYWRzIG5vdGVzIGZvciByZXdyaXRlIWApO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9KVxuXG5cdFx0dGhpcy5hZGRPYnNpZGlhbkljb24oJ2Jsb2ctdG8tY2xpcGJvYXJkLWljb24nLCAnQkonKTtcblx0XHR0aGlzLmFkZENvbW1hbmQoe1xuXHRcdFx0aWQ6IFwiYmxvZy10by1jbGlwYm9hcmRcIixcblx0XHRcdG5hbWU6IFwiQkogQmxvZyBjb250ZW50IHRvIGNsaXBib2FyZFwiLFxuXHRcdFx0aWNvbjogYGJsb2ctdG8tY2xpcGJvYXJkLWljb25gLFxuXHRcdFx0ZWRpdG9yQ2FsbGJhY2s6IGFzeW5jIChlZGl0b3I6IEVkaXRvciwgdmlldzogTWFya2Rvd25WaWV3KSA9PiB7XG5cdFx0XHRcdGNvbnN0IHYgPSBlZGl0b3IuZ2V0VmFsdWUoKTtcblx0XHRcdFx0aWYgKHYuaW5jbHVkZXMoXCIjbm5cIikgfHwgdi5pbmNsdWRlcyhcIiNubFwiKSB8fCB2LmluY2x1ZGVzKFwiI253XCIpIHx8IHYuaW5jbHVkZXMoXCIjd25cIikgfHwgdi5pbmNsdWRlcyhcIiN3bFwiKSB8fCB2LmluY2x1ZGVzKFwiI3d3XCIpKSB7XG5cdFx0XHRcdFx0bmV3IE5vdGljZShgV2lsbCBub3QgcHJvY2VlZC4gQXMgdGhlcmUgYXJlIHVuZmluaXNoZWQgYWN0aW9uIHRhZy5gKTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCF2LmluY2x1ZGVzKFwiPCEtLW1vcmUtLT5cIikpIHtcblx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0YXdhaXQgbmF2aWdhdG9yLmNsaXBib2FyZC53cml0ZVRleHQoXCI8IS0tbW9yZS0tPlwiKTtcblx0XHRcdFx0XHRcdG5ldyBOb3RpY2UoYFJlcXVpcmUgXCI8IS0tbW9yZS0tPlwiIGFzIGV4Y2VycHQgc2VwYXJhdG9yIGJlZm9yZSBwb3N0aW5nLlxcblwiPCEtLW1vcmUtLT5cIiBhbHJlYWR5IGluIGNsaXBib2FyZGApO1xuXHRcdFx0XHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRcdFx0XHRuZXcgTm90aWNlKGBSZXF1aXJlIFwiPCEtLW1vcmUtLT5cIiBhcyBleGNlcnB0IHNlcGFyYXRvciBiZWZvcmUgcG9zdGluZy5cXG5cIjwhLS1tb3JlLS0+XCIgY2Fubm90IGJlIGNvcGllZCB0byBjbGlwYm9hcmRgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y29uc3QgcGF0aCA9IHZpZXcuZmlsZS5wYXRoO1xuXHRcdFx0XHRsZXQgbGluZSA9IGVkaXRvci5saW5lQ291bnQoKTtcblx0XHRcdFx0bGV0IHRleHQgPSBcIlwiO1xuXHRcdFx0XHRsZXQgbnVtTGluZUZpcnN0Q29udGVudCA9IDA7XG5cdFx0XHRcdGxldCBmcm9udE1hdHRlckxpbmVDb3VudCA9IDA7XG5cdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbGluZTsgaSsrKSB7XG5cdFx0XHRcdFx0aWYgKGZyb250TWF0dGVyTGluZUNvdW50ID09IDIpIHtcblx0XHRcdFx0XHRcdG51bUxpbmVGaXJzdENvbnRlbnQgPSBpO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChlZGl0b3IuZ2V0TGluZShpKSA9PSBcIi0tLVwiKSB7XG5cdFx0XHRcdFx0XHRmcm9udE1hdHRlckxpbmVDb3VudCsrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGxpbmU7IGkrKykge1xuXHRcdFx0XHRcdGlmIChlZGl0b3IuZ2V0TGluZShudW1MaW5lRmlyc3RDb250ZW50KS50cmltKCkgPT0gXCJcIikge1xuXHRcdFx0XHRcdFx0bnVtTGluZUZpcnN0Q29udGVudCsrO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRBcnJheS5mcm9tKEFycmF5KGxpbmUgLSBudW1MaW5lRmlyc3RDb250ZW50KS5rZXlzKCkpLmZvckVhY2goaSA9PiB7XG5cdFx0XHRcdFx0Y29uc3QgbGluZSA9IGVkaXRvci5nZXRMaW5lKGkgKyBudW1MaW5lRmlyc3RDb250ZW50KTtcblx0XHRcdFx0XHR0ZXh0ID0gdGV4dCArIGxpbmUgKyBcIlxcblwiO1xuXHRcdFx0XHR9KTtcblx0XHRcdFx0dGV4dCA9IHRleHQucmVwbGFjZSgvXFxuLS0tXFxuXFxuI25kIGdlbmVyYXRlIHN1bW1hcnkgZm9yIG1ldGEgZGVzY3JpcHRpb24gYmVsb3c6XFxuW15cXG5dKlxcbihbXlxcbl0qKVxcblteXFxuXSpcXG4tLS1cXG4vLCBcIlxcbjwhLS0gTWV0YSBTdW1tYXJ5IC0tPlxcbjwhLS1cXG4kMVxcbi0tPlxcblwiKTtcblx0XHRcdFx0dGV4dCA9IHRleHQucmVwbGFjZSgvIyMgUmVmZXJlbmNlcz9bXFw6XT8oW1xcbl0qLiopKiQvLCBcIlwiKTtcblxuXHRcdFx0XHRjb25zdCBhcHAgPSB0aGlzLmFwcDtcblx0XHRcdFx0Y29uc3QgYmVmb3JlVGFnQ0JSID0gXCJjL2IvclwiO1xuXHRcdFx0XHRjb25zdCBiZWZvcmVUYWdDQkQgPSBcImMvYi9kXCI7XG5cdFx0XHRcdGNvbnN0IGJlZm9yZVRhZ0NCSSA9IFwiYy9iL2lcIjtcblx0XHRcdFx0Y29uc3QgYWZ0ZXJUYWcgPSBcImMvYi9wXCI7XG5cblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRhd2FpdCBuYXZpZ2F0b3IuY2xpcGJvYXJkLndyaXRlVGV4dCh0ZXh0KTtcblx0XHRcdFx0XHRuZXcgTm90aWNlKGBDb3BpZWQgYmxvZyBjb250ZW50IHRvIGNsaXBib2FyZCFgKTtcblx0XHRcdFx0XHRjb25zdCBmb3VuZFRhZ0Zyb21DQlIgPSBhd2FpdCByZW5hbWVUYWcodmlldy5maWxlLCBiZWZvcmVUYWdDQlIsIGFmdGVyVGFnKTtcblx0XHRcdFx0XHRpZiAoZm91bmRUYWdGcm9tQ0JSKSB7XG5cdFx0XHRcdFx0XHRuZXcgTm90aWNlKGBVcGRhdGUgbm90ZXMgdHlwZSBmcm9tIHRhZz1cIiR7YmVmb3JlVGFnQ0JSfVwiIHRvIHRhZz1cIiR7YWZ0ZXJUYWd9IWApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjb25zdCBmb3VuZFRhZ0Zyb21DQkkgPSBhd2FpdCByZW5hbWVUYWcodmlldy5maWxlLCBiZWZvcmVUYWdDQkksIGFmdGVyVGFnKTtcblx0XHRcdFx0XHRpZiAoZm91bmRUYWdGcm9tQ0JJKSB7XG5cdFx0XHRcdFx0XHRuZXcgTm90aWNlKGBVcGRhdGUgbm90ZXMgdHlwZSBmcm9tIHRhZz1cIiR7Zm91bmRUYWdGcm9tQ0JJfVwiIHRvIHRhZz1cIiR7YWZ0ZXJUYWd9IWApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjb25zdCBmb3VuZFRhZ0Zyb21DQkQgPSBhd2FpdCByZW5hbWVUYWcodmlldy5maWxlLCBiZWZvcmVUYWdDQkQsIGFmdGVyVGFnKTtcblx0XHRcdFx0XHRpZiAoZm91bmRUYWdGcm9tQ0JEKSB7XG5cdFx0XHRcdFx0XHRuZXcgTm90aWNlKGBVcGRhdGUgbm90ZXMgdHlwZSBmcm9tIHRhZz1cIiR7YmVmb3JlVGFnQ0JEfVwiIHRvIHRhZz1cIiR7YWZ0ZXJUYWd9IWApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRhd2FpdCByZW5hbWVCbG9nVGl0bGUoYXBwLCBwYXRoLCB2aWV3KTtcblx0XHRcdFx0XHR3aW5kb3cub3Blbihgc2hvcnRjdXRzOi8vcnVuLXNob3J0Y3V0P25hbWU9SmVreWxsJTIwYmxvZyZ4LWNhbmNlbD1vYnNpZGlhbjovLyZ4LWVycm9yPW9ic2lkaWFuOi8vYCk7XG5cdFx0XHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRcdFx0bmV3IE5vdGljZShgRXJyb3Igb2NjdXJyZWQgZHVyaW5nIHRoZSBvcGVyYXRpb246ICR7ZXJyb3J9YCk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0fSk7XG5cblx0XHR0aGlzLmFkZE9ic2lkaWFuSWNvbignZ2VuZXJhdGUtY2hhdGdwdC1wcm9tcHQnLCAnR1AnKTtcblx0XHR0aGlzLmFkZENvbW1hbmQoe1xuXHRcdFx0aWQ6IFwiZ2VuZXJhdGUtY2hhdGdwdC1wcm9tcHRcIixcblx0XHRcdG5hbWU6IFwiR1AgR2VuZXJhdGUgQ2hhdEdQVCBQcm9tcHRcIixcblx0XHRcdGljb246IGBnZW5lcmF0ZS1jaGF0Z3B0LXByb21wdGAsXG5cdFx0XHRlZGl0b3JDYWxsYmFjazogYXN5bmMgKGVkaXRvcjogRWRpdG9yLCB2aWV3OiBNYXJrZG93blZpZXcpID0+IHtcblx0XHRcdFx0bGV0IHRleHQgPSBcIlwiXG5cblx0XHRcdFx0Y29uc3Qgc2VsZWN0aW9uID0gZWRpdG9yLmdldFNlbGVjdGlvbigpXG5cblx0XHRcdFx0aWYgKHNlbGVjdGlvbi5sZW5ndGggPT0gMCkge1xuXHRcdFx0XHRcdGxldCBsaW5lID0gZWRpdG9yLmxpbmVDb3VudCgpO1xuXG5cdFx0XHRcdFx0dGV4dCA9IFwiXHUzMDEwXCIgKyB2aWV3LmZpbGUuYmFzZW5hbWUgKyBcIlx1MzAxMVxcblxcblwiO1xuXHRcdFx0XHRcdGxldCBudW1MaW5lRmlyc3RDb250ZW50ID0gMFxuXHRcdFx0XHRcdGxldCBmcm9udE1hdHRlckxpbmVDb3VudCA9IDBcblx0XHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGxpbmU7IGkrKykge1xuXHRcdFx0XHRcdFx0aWYgKGZyb250TWF0dGVyTGluZUNvdW50ID09IDIpIHtcblx0XHRcdFx0XHRcdFx0bnVtTGluZUZpcnN0Q29udGVudCA9IGk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKGVkaXRvci5nZXRMaW5lKGkpID09IFwiLS0tXCIpIHtcblx0XHRcdFx0XHRcdFx0ZnJvbnRNYXR0ZXJMaW5lQ291bnQrK1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGxpbmU7IGkrKykge1xuXHRcdFx0XHRcdFx0aWYgKGVkaXRvci5nZXRMaW5lKG51bUxpbmVGaXJzdENvbnRlbnQpLnRyaW0oKSA9PSBcIlwiKSB7XG5cdFx0XHRcdFx0XHRcdG51bUxpbmVGaXJzdENvbnRlbnQrKztcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdEFycmF5LmZyb20oQXJyYXkobGluZSAtIG51bUxpbmVGaXJzdENvbnRlbnQpLmtleXMoKSkuZm9yRWFjaChpID0+IHtcblx0XHRcdFx0XHRcdGNvbnN0IGxpbmUgPSBlZGl0b3IuZ2V0TGluZShpICsgbnVtTGluZUZpcnN0Q29udGVudCk7XG5cdFx0XHRcdFx0XHRpZiAoIWxpbmUuc3RhcnRzV2l0aChcIiUlXCIpICYmICFsaW5lLmVuZHNXaXRoKFwiJSVcIikpIHtcblx0XHRcdFx0XHRcdFx0dGV4dCA9IHRleHQgKyBsaW5lICsgXCJcXG5cIlxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdHRleHQgPSB0ZXh0LnJlcGxhY2UoLyMjIFJlZmVyZW5jZXM/W1xcOl0/KFtcXG5dKi4qKSokLywgXCJcIilcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0ZXh0ID0gc2VsZWN0aW9uXG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHRcdG5hdmlnYXRvci5jbGlwYm9hcmQud3JpdGVUZXh0KHRleHQpLnRoZW4oZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdG5ldyBOb3RpY2UoYENvcGllZCBjb250ZW50IHRvIGNsaXBib2FyZCBmb3IgZ2VuZXJhdGluZyBwcm9tcHQhYCk7XG5cdFx0XHRcdFx0d2luZG93Lm9wZW4oYHNob3J0Y3V0czovL3J1bi1zaG9ydGN1dD9uYW1lPUdlbmVyYXRlJTIwQ2hhdEdQVCUyMFByb21wdCZ4LXN1Y2Nlc3M9UG9lLWFwcDovLyZ4LWNhbmNlbD1vYnNpZGlhbjovLyZ4LWVycm9yPW9ic2lkaWFuOi8vYCk7XG5cdFx0XHRcdH0sIGZ1bmN0aW9uIChlcnJvcikge1xuXHRcdFx0XHRcdG5ldyBOb3RpY2UoYGVycm9yIHdoZW4gY29weSB0byBjbGlwYm9hcmQhYCk7ICAgXG5cdFx0XHRcdH0pOyAgIFxuXHRcdFx0fSwgICBcblx0XHR9KTsgICBcblxuXHRcdHRoaXMuYWRkT2JzaWRpYW5JY29uKCd0aHJlYWRzLXRvLWdwdCcsICdUQycpO1xuXHRcdHRoaXMuYWRkQ29tbWFuZCh7XG5cdFx0XHRpZDogXCJ0aHJlYWRzLXRvLWdwdFwiLFxuXHRcdFx0bmFtZTogXCJUQyBUaHJlYWRzIHRvIENoYXRHUFQgUHJvbXB0XCIsXG5cdFx0XHRpY29uOiBgdGhyZWFkcy10by1ncHRgLFxuXHRcdFx0ZWRpdG9yQ2FsbGJhY2s6IGFzeW5jIChlZGl0b3I6IEVkaXRvciwgdmlldzogTWFya2Rvd25WaWV3KSA9PiB7XG5cdFx0XHRcdGxldCBsaW5lID0gZWRpdG9yLmxpbmVDb3VudCgpO1xuXG5cdFx0XHRcdGxldCB0ZXh0ID0gXCJcdTMwMTBcIiArIHZpZXcuZmlsZS5iYXNlbmFtZSArIFwiXHUzMDExXFxuXFxuXCI7XG5cdFx0XHRcdGxldCBudW1MaW5lRmlyc3RDb250ZW50ID0gMFxuXHRcdFx0XHRsZXQgZnJvbnRNYXR0ZXJMaW5lQ291bnQgPSAwXG5cdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbGluZTsgaSsrKSB7XG5cdFx0XHRcdFx0aWYgKGZyb250TWF0dGVyTGluZUNvdW50ID09IDIpIHtcblx0XHRcdFx0XHRcdG51bUxpbmVGaXJzdENvbnRlbnQgPSBpO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChlZGl0b3IuZ2V0TGluZShpKSA9PSBcIi0tLVwiKSB7XG5cdFx0XHRcdFx0XHRmcm9udE1hdHRlckxpbmVDb3VudCsrXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbGluZTsgaSsrKSB7XG5cdFx0XHRcdFx0aWYgKGVkaXRvci5nZXRMaW5lKG51bUxpbmVGaXJzdENvbnRlbnQpLnRyaW0oKSA9PSBcIlwiKSB7XG5cdFx0XHRcdFx0XHRudW1MaW5lRmlyc3RDb250ZW50Kys7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdEFycmF5LmZyb20oQXJyYXkobGluZSAtIG51bUxpbmVGaXJzdENvbnRlbnQpLmtleXMoKSkuZm9yRWFjaChpID0+IHtcblx0XHRcdFx0XHRjb25zdCBsaW5lID0gZWRpdG9yLmdldExpbmUoaSArIG51bUxpbmVGaXJzdENvbnRlbnQpO1xuXHRcdFx0XHRcdGlmICghbGluZS5zdGFydHNXaXRoKFwiJSVcIikgJiYgIWxpbmUuZW5kc1dpdGgoXCIlJVwiKSkge1xuXHRcdFx0XHRcdFx0dGV4dCA9IHRleHQgKyBsaW5lICsgXCJcXG5cIlxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHRcdFxuXHRcdFx0XHR0ZXh0ID0gdGV4dC5yZXBsYWNlKC8jIyBSZWZlcmVuY2VzP1tcXDpdPyhbXFxuXSouKikqJC8sIFwiXCIpXG5cblx0XHRcdFx0Y29uc3QgYmVmb3JlVGFnID0gXCJjL3QvclwiXG5cdFx0XHRcdGNvbnN0IGFmdGVyVGFnID0gXCJjL3QvdFwiXG5cblx0XHRcdFx0bmF2aWdhdG9yLmNsaXBib2FyZC53cml0ZVRleHQodGV4dClcblx0XHRcdFx0LnRoZW4oZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdHJldHVybiByZW5hbWVUYWcodmlldy5maWxlLCBiZWZvcmVUYWcsIGFmdGVyVGFnKVxuXHRcdFx0XHR9LCBmdW5jdGlvbiAoZXJyb3IpIHtcblx0XHRcdFx0XHRuZXcgTm90aWNlKGBlcnJvciB3aGVuIGNvcHkgdG8gY2xpcGJvYXJkIWApO1xuXHRcdFx0XHR9KVxuXHRcdFx0XHQudGhlbihmdW5jdGlvbiAoYSkge1xuXHRcdFx0XHRcdG5ldyBOb3RpY2UoYENvcGllZCBjb250ZW50IHRvIGNsaXBib2FyZCBmb3IgZ2VuZXJhdGluZyBwcm9tcHQhYCk7XG5cdFx0XHRcdFx0d2luZG93Lm9wZW4oYHNob3J0Y3V0czovL3J1bi1zaG9ydGN1dD9uYW1lPUdlbmVyYXRlJTIwQ2hhdEdQVCUyMFByb21wdCZ4LXN1Y2Nlc3M9UG9lLWFwcDovLyZ4LWNhbmNlbD1vYnNpZGlhbjovLyZ4LWVycm9yPW9ic2lkaWFuOi8vYCk7XG5cdFx0XHRcdH0sIGZ1bmN0aW9uIChlcnJvcikge1xuXHRcdFx0XHRcdG5ldyBOb3RpY2UoYGVycm9yIHdoZW4gY29weSB0byBjbGlwYm9hcmQhYCk7ICAgXG5cdFx0XHRcdH0pOyAgIFxuXHRcdFx0fSwgICBcblx0XHR9KTsgICBcbiAgIFxuXHRcdHRoaXMuYWRkT2JzaWRpYW5JY29uKCd0aHJlYWRzLXRvLWNsaXBib2FyZC1pY29uJywgJ1RDJyk7ICAgXG5cdFx0dGhpcy5hZGRDb21tYW5kKHsgICBcblx0XHRcdGlkOiBcInRocmVhZHMtdG8tY2xpcGJvYXJkXCIsICAgXG5cdFx0XHRuYW1lOiBcIlRDIFRocmVhZHMgY29udGVudCB0byBjbGlwYm9hcmRcIiwgICBcblx0XHRcdGljb246IGB0aHJlYWRzLXRvLWNsaXBib2FyZC1pY29uYCxcblx0XHRcdGVkaXRvckNhbGxiYWNrOiAoZWRpdG9yOiBFZGl0b3IsIHZpZXc6IE1hcmtkb3duVmlldykgPT4geyAgIFxuXHRcdFx0XHRjb25zdCB2YWx1ZSA9IGVkaXRvci5nZXRWYWx1ZSgpXG5cdFx0XHRcdC8vaWYgKCF2YWx1ZS5jb250YWlucyhcIiUlICN0bSB0byB6ayAlJVwiKSAmJiAhdmFsdWUuY29udGFpbnMoXCIlJSAjbmQgdG8gemsgJSVcIikpIHtcblx0XHRcdFx0Ly9cdHRoaXMuYWRkVGFza1RvUHV0SW50b0NhcmRJblRocmVhZHNDb250ZW50KGVkaXRvcilcblx0XHRcdFx0Ly99XG5cdFx0XHRcdC8vIGNvbnN0IHRleHQgPSB0aGlzLmNvbnZlcnRUaHJlYWRzQ29udGVudFRvRm9ybWF0Rm9yVGhyZWFkc0FwcChlZGl0b3IpXG5cdFx0XHRcdGNvbnN0IHRleHQgPSB0aGlzLmdldFRocmVhZHNTZWdtZW50KGVkaXRvcilcblx0XHRcdFx0Y29uc3QgYmVmb3JlVGFnID0gXCJjL3QvclwiXG5cdFx0XHRcdGNvbnN0IGFmdGVyVGFnID0gXCJjL3QvdFwiXG5cdFx0XHRcblx0XHRcdFx0bmF2aWdhdG9yLmNsaXBib2FyZC53cml0ZVRleHQodGV4dClcblx0XHRcdFx0LnRoZW4oZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdHJldHVybiByZW5hbWVUYWcodmlldy5maWxlLCBiZWZvcmVUYWcsIGFmdGVyVGFnKVxuXHRcdFx0XHR9LCBmdW5jdGlvbiAoZXJyb3IpIHtcblx0XHRcdFx0XHRuZXcgTm90aWNlKGBlcnJvciB3aGVuIGNvcHkgdG8gY2xpcGJvYXJkIWApO1xuXHRcdFx0XHR9KVxuXHRcdFx0XHQudGhlbigoZm91bmRUYWcpID0+IHtcblx0XHRcdFx0XHRpZiAoZm91bmRUYWcpIHtcblx0XHRcdFx0XHRcdG5ldyBOb3RpY2UoYFVwZGF0ZSBub3RlcyB0eXBlIGZyb20gdGFnPVwiJHtiZWZvcmVUYWd9XCIgdG8gdGFnPVwiJHthZnRlclRhZ30hXFxuQ29waWVkIHRocmVhZCBjb250ZW50XFxuXFxgXFxgXFxgXFxuJHt0ZXh0fVxcblxcYFxcYFxcYFxcbnRvIGNsaXBib2FyZCFgKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0bmV3IE5vdGljZShgVGFnIFwiJHtiZWZvcmVUYWd9XCIgbm90IGZvdW5kXFxuQ29waWVkIHRocmVhZCBjb250ZW50XFxuXFxgXFxgXFxgXFxuJHt0ZXh0fVxcblxcYFxcYFxcYFxcbnRvIGNsaXBib2FyZCFgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSxcblx0XHR9KTtcblxuXHRcdHRoaXMuYWRkT2JzaWRpYW5JY29uKCd0d2l0dGVyLXRvLWNoYXRncHQnLCAnWEcnKTtcblx0XHR0aGlzLmFkZENvbW1hbmQoe1xuXHRcdFx0aWQ6IFwidHdpdHRlci10by1jaGF0Z3B0XCIsXG5cdFx0XHRuYW1lOiBcIlhHIFR3aXR0ZXIgdG8gQ2hhdEdQVFwiLFxuXHRcdFx0aWNvbjogYHR3aXR0ZXItdG8tY2hhdGdwdGAsXG5cdFx0XHRlZGl0b3JDYWxsYmFjazogKGVkaXRvcjogRWRpdG9yLCB2aWV3OiBNYXJrZG93blZpZXcpID0+IHtcblx0XHRcdFx0Y29uc3QgdmFsdWUgPSBlZGl0b3IuZ2V0VmFsdWUoKVxuXG5cdFx0XHRcdGlmICghdmlldy5maWxlLmJhc2VuYW1lLmNvbnRhaW5zKFwiVHdpdHRlclwiKSkge1xuXHRcdFx0XHRcdG5ldyBOb3RpY2UoXCJOb3RlIG5hbWUgbm90IGNvbnRhaW5zICdUd2l0dGVyJywgZGlkIG5vdCBjb3B5IGZyb20gdGhyZWFkIG5vdGU/XCIpXG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNvbnN0IG5vdGVUeXBlIDogTm90ZVR5cGUgfCBudWxsID0gZ2V0Tm90ZVR5cGUodmlldy5maWxlLnBhdGgpO1xuXHRcdFx0XHRpZiAobm90ZVR5cGUgIT0gbnVsbCAmJiBub3RlVHlwZS50eXBlLnN0YXJ0c1dpdGgoXCJjL3gvXCIpKSB7XG5cdFx0XHRcdFx0bmV3IE5vdGljZShcIk5vdGUgdHlwZSBzdGFydHMgd2l0aCBjL3gsIHdpbGwgbm90IHByb2NlZWRcIilcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHRcdGxldCBjb250ZW50ID0gdGhpcy5jb252ZXJ0VGhyZWFkc0NvbnRlbnRUb1BPRShlZGl0b3IpXG5cdFx0XHRcdGxldCBudW1Ud2VldCA9IE1hdGguY2VpbChjb250ZW50Lmxlbmd0aCAvIDExMClcblx0XHRcdFx0bGV0IHByb21wdCA9IGBcdTYwQThcdTY2MkZcdTc5M0VcdTRFQTRcdTVBOTJcdTlBRDRcdTUxNjdcdTVCQjlcdTY0QjBcdTVCRUJcdTVFMkJcdTMwMDJcdTVDMDdcdTRFMEJcdTUyMTdcdTUxNjdcdTVCQjlcdThGNDlcdTcwQkFcdTRFMERcdThEODVcdTkwNEUke251bVR3ZWV0fVx1Njg5RFx1NzY4NFx1NjNBOFx1NzI3OVx1NEUzMlx1RkYwQ1x1NEVFNVx1N0U0MVx1OUFENFx1NEUyRFx1NjU4N1x1NTQ0OFx1NzNGRVx1MzAwMlx1NEZERFx1NzU1OVx1NkExOVx1OTg0Q1x1RkYwQ1x1NEUyNlx1NUMwN1x1NkExOVx1OTg0Q1x1NTQwOFx1NEY3NVx1NTIzMFx1N0IyQ1x1NEUwMFx1Njg5RFx1NjNBOFx1NjU4N1x1NEUyRFx1RkYwQ1x1NkExOVx1OTg0Q1x1NTQ4Q1x1N0IyQ1x1NEUwMFx1Njg5RFx1NjNBOFx1NjU4N1x1NEU0Qlx1OTU5M1x1NTJBMFx1NTE2OVx1NTAwQlx1NjNEQlx1ODg0Q1x1MzAwMlx1NkJDRlx1Njg5RFx1NjNBOFx1NjU4N1x1ODk4MVx1OEQ4NVx1OTA0RTEwMFx1NUI1N1x1NEY0Nlx1NEUwRFx1OEQ4NVx1OTA0RTE0MFx1NUI1N1x1MzAwMlx1NTE2N1x1NUJCOVx1NEUwRFx1N0MyMVx1NTMxNlx1RkYwQ1x1NEUwRFx1NjVCMFx1NTg5RVx1NjcyQVx1NjNEMFx1NTNDQVx1OENDN1x1OEEwQVx1MzAwMlx1NEZERFx1NzU1OVx1NTM5Rlx1NjU4N1x1NEY4Qlx1NUI1MFx1RkYwQ1x1NEUwRFx1NTJBMFx1NkExOVx1N0M2NFx1MzAwMlx1NjNBOFx1NjU4N1x1NEUyRFx1NEUwRFx1NTJBMFx1NjU3OFx1NUI1N1x1MzAwMlx1NkJDRlx1Njg5RFx1NjNBOFx1NjU4N1x1NUY4Q1x1NTJBMFx1NTE2OVx1NTAwQlx1NjNEQlx1ODg0Q1x1NTNDQVx1NEUwOVx1NTAwQlx1NzdFRFx1NTI4M1x1N0REQVx1NTQ4Q1x1NTNFNlx1NEUwMFx1NTAwQlx1NjNEQlx1ODg0Q1x1MzAwMlx1ODJGMVx1NjU4N1x1NTQ4Q1x1NEUyRFx1NjU4N1x1NEU0Qlx1OTU5M1x1NTJBMFx1N0E3QVx1NjgzQ1x1MzAwMlx1ODJFNVx1NTM5Rlx1NjU4N1x1NjcwOVx1N0RCMlx1NTc0MFx1RkYwQ1x1NEZERFx1NzU1OVx1N0RCMlx1NTc0MFx1RkYwQ1x1NEUwRFx1NzUyOE1hcmtkb3duXHU2ODNDXHU1RjBGXHVGRjBDXHU0RTI2XHU1NzI4XHU3REIyXHU1NzQwXHU1MjREXHU1MkEwXHU1MTY5XHU1MDBCXHU2M0RCXHU4ODRDXHUzMDAyYFxuXG5cdFx0XHRcdC8vbGV0IHByb21wdCA9IGBZb3UgYXJlIGEgc29jaWFsIG1lZGlhIGNvbnRlbnQgY29weXdyaXRlci4gQ29udmVydCB0aGUgZm9sbG93aW5nIGNvbnRlbnQgdG8gdHdpdHRlciB0aHJlYWRzIGxlc3MgdGhhbiAke251bVR3ZWV0fSB0d2VldCBpbiB0cmFkaXRpb25hbCBDaGluZXNlLiBQcmVzZXJ2ZSB0aGUgdGl0bGUuIE1lcmdlIHRpdGxlIHdpdGggdGhlIGZpcnN0IHR3ZWV0IHdoaWxlIGFkZCAyIG5ld2xpbmUgY2hhcmFjdGVycyBiZXR3ZWVuIHRpdGxlIGFuZCBmaXJzdCB0d2VldC4gRXZlcnkgdHdlZXQgaGFzIHRvIG92ZXIgMTAwIGJ1dCBsZXNzIHRoYW4gMTQwIENoaW5lc2UgY2hhcmFjdGVycy4gRG8gbm90IHNpbXBsaWZ5IHRoZSBjb250ZW50LiBEbyBub3QgYWRkIGFueSBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIHdoaWNoIGlzIG5vdCBtZW50aW9uZWQgZnJvbSB0aGUgb3JpZ2luYWwgY29udGVudC4gUHJlc2VydmUgdGhlIGV4YW1wbGUgZnJvbSB0aGUgY29udGVudC4gTm8gbmVlZCB0byBhZGQgYW55IHRhZ3MgdG8gdGhlIHR3ZWV0LiBEbyBub3QgaGF2ZSBhbnkgbnVtYmVyIGluIGVhY2ggdHdlZXQuIEVhY2ggdHdlZXQgc2VwYXJhdGVkIGJ5IDIgbmV3bGluZSBhbmQgMyBcIi1cIiBjaGFyYWN0ZXJzIGFuZCBhbm90aGVyIG5ld2xpbmUuIEFkZCBhIHNwYWNlIGNoYXJhY3RlciBiZXR3ZWVuIGVhY2ggRW5nbGlzaCBjaGFyYWN0ZXIgYW5kIENoaW5lc2UgY2hhcmFjdGVyLiBJZiB0aGUgb3JpZ2luYWwgY29udGVudCBjb250YWlucyBhbnkgVVJMLCBwcmVzZXJ2ZSB0aGUgVVJMIGluIHRoZSB0d2VldCB3aXRob3V0IHVzaW5nIGFueSBNYXJrZG93biBmb3JtYXQgZm9yIHRoZSBVUkwgd2hpbGUgYWRkIDIgbmV3bGluZSBjaGFyYWN0ZXIgYmVmb3JlIHRoZSBVUkwuYFxuXG5cdFx0XHRcdC8vbGV0IHByb21wdCA9IGBDb252ZXJ0IHRoZSBmb2xsb3dpbmcgY29udGVudCB0byB0d2l0dGVyIHRocmVhZHMgbGVzcyB0aGFuICR7bnVtVHdlZXR9IHR3ZWV0IGluIHRyYWRpdGlvbmFsIENoaW5lc2UuIFByZXNlcnZlIHRoZSB0aXRsZS4gRG8gbm90IGFkZCBhbnkgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiB3aGljaCBpcyBub3QgbWVudGlvbmVkIGZyb20gdGhlIG9yaWdpbmFsIGNvbnRlbnQuIE5vIG5lZWQgdG8gYWRkIGFueSB0YWdzIHRvIHRoZSB0d2VldC4gRG8gbm90IGhhdmUgYW55IG51bWJlciBpbiBlYWNoIHR3ZWV0LiBFYWNoIHR3ZWV0IHNlcGFyYXRlZCBieSBuZXdsaW5lIGNoYXJhY3RlciBhbmQgMyBcIi1cIiBjaGFyYWN0ZXJzIGFuZCBhbm90aGVyIG5ld2xpbmUgY2hhcmFjdGVyLmBcblx0XHRcdFx0cHJvbXB0ID0gcHJvbXB0ICsgXCJcXG5cXG5cIiArIGNvbnRlbnRcblx0XHRcdFx0cHJvbXB0ID0gcHJvbXB0LnJlcGxhY2UoL1x1MjU4RC9nLCBcIlwiKVxuXHRcdFx0XHRwcm9tcHQgPSBwcm9tcHQucmVwbGFjZSgvXHUzMDExXFxuK2h0dHBzXFw6XFwvXFwvZ2l0aHViLmNvbVteXFxuXStcXG4vbSwgXCJcdTMwMTFcXG5cIilcblx0XHRcdFx0cHJvbXB0ID0gcHJvbXB0LnJlcGxhY2UoL1xcKlxcKi9nbSwgXCJcIilcblx0XHRcdFx0Ly9wcm9tcHQgPSBwcm9tcHQucmVwbGFjZSgvIVxcW1xcUypcXF1cXCgoKGh0dHBzOnxodHRwOnx3d3dcXC4pXFxTKilcXCkvZ20sIFwiJDFcIilcblxuXHRcdFx0XHRuYXZpZ2F0b3IuY2xpcGJvYXJkLndyaXRlVGV4dChwcm9tcHQpLnRoZW4oZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRcdFx0bGV0IGxpbmUgPSBlZGl0b3IubGluZUNvdW50KCk7XG5cblx0XHRcdFx0XHRsZXQgbnVtTGluZUZpcnN0Q29udGVudCA9IDBcblx0XHRcdFx0XHRsZXQgZnJvbnRNYXR0ZXJMaW5lQ291bnQgPSAwXG5cdFx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lOyBpKyspIHtcblx0XHRcdFx0XHRcdGlmIChmcm9udE1hdHRlckxpbmVDb3VudCA9PSAyKSB7XG5cdFx0XHRcdFx0XHRcdG51bUxpbmVGaXJzdENvbnRlbnQgPSBpO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmIChlZGl0b3IuZ2V0TGluZShpKSA9PSBcIi0tLVwiKSB7XG5cdFx0XHRcdFx0XHRcdGZyb250TWF0dGVyTGluZUNvdW50Kytcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lOyBpKyspIHtcblx0XHRcdFx0XHRcdGlmIChlZGl0b3IuZ2V0TGluZShudW1MaW5lRmlyc3RDb250ZW50KS50cmltKCkgPT0gXCJcIikge1xuXHRcdFx0XHRcdFx0XHRudW1MaW5lRmlyc3RDb250ZW50Kys7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRsZXQgdGV4dCA9IFwiXCI7XG5cdFx0XHRcdFx0QXJyYXkuZnJvbShBcnJheShudW1MaW5lRmlyc3RDb250ZW50KS5rZXlzKCkpLmZvckVhY2goaSA9PiB7XG5cdFx0XHRcdFx0XHRjb25zdCBsaW5lID0gZWRpdG9yLmdldExpbmUoaSk7XG5cdFx0XHRcdFx0XHR0ZXh0ID0gdGV4dCArIGxpbmUgKyBcIlxcblwiXG5cdFx0XHRcdFx0fSlcblx0XHRcdFx0XHR0ZXh0ID0gdGV4dC5yZXBsYWNlKC8jIyBSZWZlcmVuY2VzP1tcXDpdPyhbXFxuXSouKikqJC8sIFwiXCIpO1xuXHRcdFx0XHRcdGVkaXRvci5zZXRWYWx1ZSh0ZXh0KVxuXG5cdFx0XHRcdFx0Y29uc3QgY3Vyc29yID0gZWRpdG9yLmdldEN1cnNvcigpXG5cdFx0XHRcdFx0Y3Vyc29yLmxpbmUgPSBlZGl0b3IubGluZUNvdW50KCkgLSAxXG5cdFx0XHRcdFx0Y3Vyc29yLmNoID0gMFxuXHRcdFx0XHRcdGVkaXRvci5zZXRDdXJzb3IoY3Vyc29yKVxuXG5cdFx0XHRcdFx0bmV3IE5vdGljZShcImNvcGllZCB0byBjbGlwYm9hcmQsIHBsZWFzZSBvcGVuIGNoYXRncHQgdG8gcGFzdGVcIilcblx0XHRcdFx0XHRyZXR1cm4gcmVuYW1lVGFnKHZpZXcuZmlsZSwgXCJjL3QvZFwiLCBcImMveC9kXCIpXG5cdFx0XHRcdH0sIGZ1bmN0aW9uIChlcnJvcikge1xuXHRcdFx0XHRcdG5ldyBOb3RpY2UoYGVycm9yIHdoZW4gY29weSB0byBjbGlwYm9hcmQhYCk7XG5cdFx0XHRcdH0pXG5cdFx0XHRcdC50aGVuKChhKSA9PiB7XG5cdFx0XHRcdFx0cmVuYW1lVGFnKHZpZXcuZmlsZSwgXCJjL3QvclwiLCBcImMveC9kXCIpXG5cdFx0XHRcdH0pXG5cdFx0XHRcdC50aGVuKChhKSA9PiB7XG5cdFx0XHRcdFx0cmVuYW1lVGFnKHZpZXcuZmlsZSwgXCJjL3QvdFwiLCBcImMveC9kXCIpXG5cdFx0XHRcdH0pXG5cdFx0XHRcdC50aGVuKChhKSA9PiB7XG5cdFx0XHRcdFx0cmVuYW1lVGFnKHZpZXcuZmlsZSwgXCJjL3QvcFwiLCBcImMveC9kXCIpXG5cdFx0XHRcdH0pXG5cdFx0XHRcdC50aGVuKChhKSA9PiB7XG5cdFx0XHRcdFx0d2luZG93Lm9wZW4oYFBvZS1hcHA6Ly9gKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9LFxuXHRcdH0pO1xuXG5cdFx0dGhpcy5hZGRPYnNpZGlhbkljb24oJ2NoYXRncHQtdG8tdHdpdHRlcicsICdHWCcpO1xuXHRcdHRoaXMuYWRkQ29tbWFuZCh7XG5cdFx0XHRpZDogXCJjaGF0Z3B0LXRvLXR3aXR0ZXJcIixcblx0XHRcdG5hbWU6IFwiR1ggQ2hhdEdQVCB0byBUd2l0dGVyXCIsXG5cdFx0XHRpY29uOiBgY2hhdGdwdC10by10d2l0dGVyYCxcblx0XHRcdGVkaXRvckNhbGxiYWNrOiAoZWRpdG9yOiBFZGl0b3IsIHZpZXc6IE1hcmtkb3duVmlldykgPT4ge1xuXHRcdFx0XHRpZiAoIWVkaXRvci5nZXRWYWx1ZSgpLmNvbnRhaW5zKFwiYy94L2RcIikpIHtcblx0XHRcdFx0XHRuZXcgTm90aWNlKFwiTm90ZSB0eXBlIG5vdCBjL3gvZCwgZG8gdGhlIGFjdGlvbiBpbiB3cm9uZyBub3RlP1wiKVxuXHRcdFx0XHRcdHJldHVyblxuXHRcdFx0XHR9XG5cdFx0XHRcdGNvbnN0IGlzU3VjY2VzcyA9IHRoaXMuY29udmVydENoYXRHUFRUb1R3aXR0ZXJGb3JtYXQoZWRpdG9yKVxuXHRcdFx0XHRpZiAoaXNTdWNjZXNzKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0cmVuYW1lVGFnKHZpZXcuZmlsZSwgXCJjL3gvZFwiLCBcImMveC9yXCIpXG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0fSk7XG5cblx0XHR0aGlzLmFkZE9ic2lkaWFuSWNvbigncmV2ZXJzZS10d2l0dGVyLW51bWJlci1pY29uJywgJ1JUJyk7XG5cdFx0dGhpcy5hZGRDb21tYW5kKHtcblx0XHRcdGlkOiBcInJldmVyc2UtdHdpdHRlci1udW1iZXJpbmdcIixcblx0XHRcdG5hbWU6IFwiUlQgUmV2ZXJzZSBUd2l0dGVyIE51bWJlcmluZ1wiLFxuXHRcdFx0aWNvbjogYHJldmVyc2UtdHdpdHRlci1udW1iZXItaWNvbmAsXG5cdFx0XHRlZGl0b3JDYWxsYmFjazogKGVkaXRvcjogRWRpdG9yLCB2aWV3OiBNYXJrZG93blZpZXcpID0+IHtcblx0XHRcdFx0aWYgKCFlZGl0b3IuZ2V0VmFsdWUoKS5jb250YWlucyhcImMveC9yXCIpICYmICFlZGl0b3IuZ2V0VmFsdWUoKS5jb250YWlucyhcImMveC9wXCIpKSB7XG5cdFx0XHRcdFx0bmV3IE5vdGljZShcIk5vdGUgdHlwZSBub3QgYy94L3Igbm9yIGMveC9wLCBkbyB0aGUgYWN0aW9uIGluIHdyb25nIG5vdGU/XCIpXG5cdFx0XHRcdFx0cmV0dXJuXG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5yZXZlcnNlVHdpdHRlck51bWJlcmluZyhlZGl0b3IpXG5cdFx0XHRcdHJlbmFtZVRhZyh2aWV3LmZpbGUsIFwiYy94L3BcIiwgXCJjL3gvZFwiKVxuXHRcdFx0XHRyZW5hbWVUYWcodmlldy5maWxlLCBcImMveC9yXCIsIFwiYy94L2RcIilcblx0XHRcdH0sXG5cdFx0fSk7XG5cblx0XHR0aGlzLmFkZE9ic2lkaWFuSWNvbigndGhyZWFkcy1hcy1mYWNlYm9vay1wb3N0LXRvLWNsaXBib2FyZC1pY29uJywgJ0ZDJyk7XG5cdFx0dGhpcy5hZGRDb21tYW5kKHtcblx0XHRcdGlkOiBcInRocmVhZHMtYXMtZmFjZWJvb2stcG9zdC10by1jbGlwYm9hcmRcIixcblx0XHRcdG5hbWU6IFwiRkMgVGhyZWFkcyBhcyBGYWNlYm9vayBwb3N0IGZvcm1hdCB0byBDbGlwYm9hcmRcIixcblx0XHRcdGljb246IGB0aHJlYWRzLWFzLWZhY2Vib29rLXBvc3QtdG8tY2xpcGJvYXJkLWljb25gLFxuXHRcdFx0ZWRpdG9yQ2FsbGJhY2s6IChlZGl0b3I6IEVkaXRvciwgdmlldzogTWFya2Rvd25WaWV3KSA9PiB7XG5cdFx0XHRcdGNvbnN0IHZhbHVlID0gZWRpdG9yLmdldFZhbHVlKClcblx0XHRcdFx0Ly9pZiAoIXZhbHVlLmNvbnRhaW5zKFwiJSUgI25tIHRvIHprICUlXCIpICYmICF2YWx1ZS5jb250YWlucyhcIiUlICNuZCB0byB6ayAlJVwiKSkge1xuXHRcdFx0XHQvL1x0dGhpcy5hZGRUYXNrVG9QdXRJbnRvQ2FyZEluVGhyZWFkc0NvbnRlbnQoZWRpdG9yKVxuXHRcdFx0XHQvL31cblx0XHRcdFx0bGV0IHRleHQgPSB0aGlzLmNvbnZlcnRUaHJlYWRzQ29udGVudFRvRm9ybWF0Rm9yRmFjZWJvb2tBcHAoZWRpdG9yKVxuXHRcdFx0XHR0ZXh0ID0gdGV4dC5yZXBsYWNlKC9cdTExNzNcdTExNzNcdTExNzNcdTExNzNcdTExNzNcdTExNzNcdTExNzNcdTExNzNcdTExNzNcdTExNzNcdTExNzNcdTExNzNcdTExNzNcdTExNzNcdTExNzNcdTExNzNcdTExNzNcdTExNzNcdTExNzNcdTExNzNcdTExNzNcdTExNzNcXG4rIyMgW1JyXWVmZXJlbmNlcz9cXDooW1xcbl0qLiopKiQvLCBcIlwiKTtcblx0XHRcdFx0dGV4dCA9IHRleHQucmVwbGFjZSgvXHUxMTczXHUxMTczXHUxMTczXHUxMTczXHUxMTczXHUxMTczXHUxMTczXHUxMTczXHUxMTczXHUxMTczXHUxMTczXHUxMTczXHUxMTczXHUxMTczXHUxMTczXHUxMTczXHUxMTczXHUxMTczXHUxMTczXHUxMTczXHUxMTczXHUxMTczXFxuKyMjIFtScl1lZmVyZW5jZXM/KFtcXG5dKi4qKSokLywgXCJcIik7XG5cdFx0XHRcdHRleHQgPSB0ZXh0LnJlcGxhY2UoL1xcbiMrIC9tZywgXCJcXG5cIilcblx0XHRcdFxuXHRcdFx0XHRjb25zdCBiZWZvcmVUYWcgPSBcImMvdC90XCJcblx0XHRcdFx0Y29uc3QgYWZ0ZXJUYWcgPSBcImMvdC9wXCJcblx0XHRcdFxuXHRcdFx0XHRuYXZpZ2F0b3IuY2xpcGJvYXJkLndyaXRlVGV4dCh0ZXh0KVxuXHRcdFx0XHQudGhlbihmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHJlbmFtZVRhZyh2aWV3LmZpbGUsIGJlZm9yZVRhZywgYWZ0ZXJUYWcpXG5cdFx0XHRcdH0sIGZ1bmN0aW9uIChlcnJvcikge1xuXHRcdFx0XHRcdG5ldyBOb3RpY2UoYGVycm9yIHdoZW4gY29weSB0byBjbGlwYm9hcmQhYCk7XG5cdFx0XHRcdH0pXG5cdFx0XHRcdC50aGVuKChmb3VuZFRhZykgPT4ge1xuXHRcdFx0XHRcdGlmIChmb3VuZFRhZykge1xuXHRcdFx0XHRcdFx0bmV3IE5vdGljZShgVXBkYXRlIG5vdGVzIHR5cGUgZnJvbSB0YWc9XCIke2JlZm9yZVRhZ31cIiB0byB0YWc9XCIke2FmdGVyVGFnfSFcXG5Db3BpZWQgZmIgY29udGVudCB0byBjbGlwYm9hcmQhYCk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdG5ldyBOb3RpY2UoYFRhZyBcIiR7YmVmb3JlVGFnfVwiIG5vdCBmb3VuZFxcbkNvcGllZCBmYiBjb250ZW50IHRvIGNsaXBib2FyZCFgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSxcblx0XHR9KTtcblxuXHRcdHRoaXMuYWRkT2JzaWRpYW5JY29uKCd0aHJlYWRzLWJsb2NrLXRvLWltYWdlJywgJ1RJJyk7XG5cdFx0dGhpcy5hZGRDb21tYW5kKHtcblx0XHRcdGlkOiBcInRocmVhZHMtYmxvY2stdG8taW1hZ2VcIixcblx0XHRcdG5hbWU6IFwiVEkgVGhyZWFkcyBzZWdtZW50IHRvIGltYWdlXCIsXG5cdFx0XHRpY29uOiBgdGhyZWFkcy1ibG9jay10by1pbWFnZWAsXG5cdFx0XHRlZGl0b3JDYWxsYmFjazogYXN5bmMoZWRpdG9yOiBFZGl0b3IsIHZpZXc6IE1hcmtkb3duVmlldykgPT4ge1xuXHRcdFx0XHRjb25zdCB0aHJlYWRTZWdtZW50ID0gdGhpcy5nZXRUaHJlYWRTZWdtZW50KGVkaXRvcilcblx0XHRcdFx0Y29uc3QgYmVmb3JlVGFnID0gXCJjL3QvZFwiXG5cdFx0XHRcdGNvbnN0IGFmdGVyVGFnID0gXCJjL3QvclwiXG5cdFx0XHRcdGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlbmFtZVRhZyh2aWV3LmZpbGUsIGJlZm9yZVRhZywgYWZ0ZXJUYWcpXG5cdFx0XHRcdGF3YWl0IHJlbmFtZVRocmVhZHNUaXRsZShhcHAsIHZpZXcuZmlsZS5wYXRoLCB2aWV3KTtcblx0XHRcdFx0Y29uc29sZS5sb2cocmVzdWx0KVxuXHRcdFx0XHRuZXcgVGhyZWFkc1RvSW1hZ2VzTW9kYWwodGhpcy5hcHAsIHRocmVhZFNlZ21lbnQpLm9wZW4oKVxuXHRcdFx0fSxcblx0XHR9KTtcblxuXHRcdHRoaXMuYWRkT2JzaWRpYW5JY29uKCdjaGF0Z3B0LWdlbmVyYXRlLWltYWdlJywgJ0dJJyk7XG5cdFx0dGhpcy5hZGRDb21tYW5kKHtcblx0XHRcdGlkOiBcImNoYXRncHQtZ2VuZXJhdGUtaW1hZ2VcIixcblx0XHRcdG5hbWU6IFwiR0kgQ2hhdEdQVCBpbWFnZVwiLFxuXHRcdFx0aWNvbjogYGNoYXRncHQtZ2VuZXJhdGUtaW1hZ2VgLFxuXHRcdFx0ZWRpdG9yQ2FsbGJhY2s6IChlZGl0b3I6IEVkaXRvciwgdmlldzogTWFya2Rvd25WaWV3KSA9PiB7XG5cdFx0XHRcdHdpbmRvdy5vcGVuKCdzaG9ydGN1dHM6Ly9ydW4tc2hvcnRjdXQ/bmFtZT1DaGF0R1BUJTIwR2VuZXJhdGUlMjBJbWFnZSZ4LXN1Y2Nlc3M9b2JzaWRpYW46Ly8meC1jYW5jZWw9b2JzaWRpYW46Ly8meC1lcnJvcj1vYnNpZGlhbjovLycpO1xuXHRcdFx0fSxcblx0XHR9KTtcblxuXHRcdC8qXG5cdFx0dGhpcy5hZGRPYnNpZGlhbkljb24oJ3RocmVhZHMtc2VnbWVudC10by1jbGlwYm9hcmQnLCAnU0MnKTtcblx0XHR0aGlzLmFkZENvbW1hbmQoe1xuXHRcdFx0aWQ6IFwidGhyZWFkcy1zZWdtZW50LXRvLWNsaXBib2FyZFwiLFxuXHRcdFx0bmFtZTogXCJUaHJlYWRzIHNlZ21lbnQgdG8gY2xpcGJvYXJkXCIsXG5cdFx0XHRpY29uOiBgdGhyZWFkcy1zZWdtZW50LXRvLWNsaXBib2FyZGAsXG5cdFx0XHRlZGl0b3JDYWxsYmFjazogKGVkaXRvcjogRWRpdG9yLCB2aWV3OiBNYXJrZG93blZpZXcpID0+IHtcblx0XHRcdFx0Y29uc3QgdGhyZWFkU2VnbWVudCA9IHRoaXMuZ2V0VGhyZWFkU2VnbWVudChlZGl0b3IpXG5cdFx0XHRcdGNvbnN0IGJlZm9yZVRhZyA9IFwiYy94L3JcIlxuXHRcdFx0XHRjb25zdCBhZnRlclRhZyA9IFwiYy94L3BcIlxuXHRcdFx0XHRuYXZpZ2F0b3IuY2xpcGJvYXJkLndyaXRlVGV4dCh0aHJlYWRTZWdtZW50KVxuXHRcdFx0XHQudGhlbihmdW5jdGlvbiAoKSB7XHRcblx0XHRcdFx0XHRyZXR1cm4gcmVuYW1lVGFnKHZpZXcuZmlsZSwgYmVmb3JlVGFnLCBhZnRlclRhZylcblx0XHRcdFx0fSwgZnVuY3Rpb24gKGVycm9yKSB7XG5cdFx0XHRcdFx0bmV3IE5vdGljZShgZXJyb3Igd2hlbiBjb3B5IHRvIGNsaXBib2FyZCFgKTtcblx0XHRcdFx0fSlcblx0XHRcdFx0LnRoZW4oKGZvdW5kVGFnKSA9PiB7XG5cdFx0XHRcdFx0aWYgKGZvdW5kVGFnKSB7XG5cdFx0XHRcdFx0XHRuZXcgTm90aWNlKGBVcGRhdGUgbm90ZXMgdHlwZSBmcm9tIHRhZz1cIiR7YmVmb3JlVGFnfVwiIHRvIHRhZz1cIiR7YWZ0ZXJUYWd9IVxcbkNvcGllZFxcblxcYFxcYFxcYFxcbiR7dGhyZWFkU2VnbWVudH1cXGBcXGBcXGBcXG50byBjbGlwYm9hcmQhYCk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdG5ldyBOb3RpY2UoYFRhZyBcIiR7YmVmb3JlVGFnfVwiIG5vdCBmb3VuZFxcbkNvcGllZFxcblxcYFxcYFxcYFxcbiR7dGhyZWFkU2VnbWVudH1cXGBcXGBcXGBcXG50byBjbGlwYm9hcmQhYCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdH0sXG5cdFx0fSk7XG5cdFx0Ki9cblxuXHRcdHRoaXMuYWRkT2JzaWRpYW5JY29uKCd0d2l0dGVyLXNlZ21lbnQtdG8tY2xpcGJvYXJkJywgJ1hDJyk7XG5cdFx0dGhpcy5hZGRDb21tYW5kKHtcblx0XHRcdGlkOiBcInR3aXR0ZXItc2VnbWVudC10by1jbGlwYm9hcmRcIixcblx0XHRcdG5hbWU6IFwiWEMgVHdpdHRlciBzZWdtZW50IHRvIGNsaXBib2FyZFwiLFxuXHRcdFx0aWNvbjogYHR3aXR0ZXItc2VnbWVudC10by1jbGlwYm9hcmRgLFxuXHRcdFx0ZWRpdG9yQ2FsbGJhY2s6IChlZGl0b3I6IEVkaXRvciwgdmlldzogTWFya2Rvd25WaWV3KSA9PiB7XG5cdFx0XHRcdGNvbnN0IHRocmVhZFNlZ21lbnQgPSB0aGlzLmdldFR3aXR0ZXJTZWdtZW50KGVkaXRvcilcblxuXHRcdFx0XHRjb25zdCBiZWZvcmVUYWcgPSBcImMveC9yXCJcblx0XHRcdFx0Y29uc3QgYWZ0ZXJUYWcgPSBcImMveC9wXCJcblx0XHRcdFx0bmF2aWdhdG9yLmNsaXBib2FyZC53cml0ZVRleHQodGhyZWFkU2VnbWVudClcblx0XHRcdFx0LnRoZW4oZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdHJldHVybiByZW5hbWVUYWcodmlldy5maWxlLCBiZWZvcmVUYWcsIGFmdGVyVGFnKVxuXHRcdFx0XHR9LCBmdW5jdGlvbiAoZXJyb3IpIHtcblx0XHRcdFx0XHRuZXcgTm90aWNlKGBlcnJvciB3aGVuIGNvcHkgdG8gY2xpcGJvYXJkIWApO1xuXHRcdFx0XHR9KVxuXHRcdFx0XHQudGhlbihmb3VuZFRhZyA9PiB7XG5cdFx0XHRcdFx0aWYgKGZvdW5kVGFnKSB7XG5cdFx0XHRcdFx0XHRuZXcgTm90aWNlKGBVcGRhdGUgbm90ZXMgdHlwZSBmcm9tIHRhZz1cIiR7YmVmb3JlVGFnfVwiIHRvIHRhZz1cIiR7YWZ0ZXJUYWd9IVxcbkNvcGllZFxcblxcYFxcYFxcYFxcbiR7dGhyZWFkU2VnbWVudH1cXGBcXGBcXGBcXG50byBjbGlwYm9hcmQhYCk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdG5ldyBOb3RpY2UoYFRhZyBcIiR7YmVmb3JlVGFnfVwiIG5vdCBmb3VuZFxcbkNvcGllZFxcblxcYFxcYFxcYFxcbiR7dGhyZWFkU2VnbWVudH1cXGBcXGBcXGBcXG50byBjbGlwYm9hcmQhYCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdH0sXG5cdFx0fSk7XG5cblx0XHR0aGlzLmFkZE9ic2lkaWFuSWNvbignc2VnbWVudC10by1jbGlwYm9hcmQnLCAnU0MnKTtcblx0XHR0aGlzLmFkZENvbW1hbmQoe1xuXHRcdFx0aWQ6IFwic2VnbWVudC10by1jbGlwYm9hcmRcIixcblx0XHRcdG5hbWU6IFwiU0MgU2VnbWVudCB0byBjbGlwYm9hcmRcIixcblx0XHRcdGljb246IGBzZWdtZW50LXRvLWNsaXBib2FyZGAsXG5cdFx0XHRlZGl0b3JDYWxsYmFjazogKGVkaXRvcjogRWRpdG9yLCB2aWV3OiBNYXJrZG93blZpZXcpID0+IHtcblx0XHRcdFx0Y29uc3QgdGhyZWFkU2VnbWVudCA9IHRoaXMuZ2V0U2VnbWVudChlZGl0b3IpXG5cdFx0XHRcdHRoaXMuYWRkVG9DbGlwYm9hcmRIaXN0b3J5KHRocmVhZFNlZ21lbnQpXG5cdFx0XHRcdG5hdmlnYXRvci5jbGlwYm9hcmQud3JpdGVUZXh0KHRocmVhZFNlZ21lbnQpXG5cdFx0XHRcdC50aGVuKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRuZXcgTm90aWNlKGBDb3BpZWRcXG5cXGBcXGBcXGBcXG4ke3RocmVhZFNlZ21lbnR9XFxgXFxgXFxgXFxudG8gY2xpcGJvYXJkIWApO1xuXHRcdFx0XHR9LCBmdW5jdGlvbiAoZXJyb3IpIHtcblx0XHRcdFx0XHRuZXcgTm90aWNlKGBlcnJvciB3aGVuIGNvcHkgdG8gY2xpcGJvYXJkIWApO1xuXHRcdFx0XHR9KVxuXHRcdFx0fSxcblx0XHR9KTtcblxuXHRcdHRoaXMuYWRkQ29tbWFuZCh7XG5cdFx0XHRpZDogXCJuLWZpbmQtcmVwbGFjZVwiLFxuXHRcdFx0bmFtZTogXCJGaW5kIG9yIFJlcGxhY2VcIixcblx0XHRcdGljb246IGBmaWxlLXNlYXJjaGAsXG5cdFx0XHRlZGl0b3JDYWxsYmFjazogKGVkaXRvcjogRWRpdG9yLCB2aWV3OiBNYXJrZG93blZpZXcpID0+IHtcblx0XHRcdFx0bmV3IEZpbmRSZXBsYWNlTW9kYWwodGhpcy5hcHApLm9wZW4oKVxuXHRcdFx0fSxcblx0XHR9KTtcblxuXG5cdFx0Lypcblx0XHR0aGlzLmFkZE9ic2lkaWFuSWNvbignbi1wcmV2aW91cy10YWInLCAnVDwnKTtcblx0XHR0aGlzLmFkZENvbW1hbmQoe1xuXHRcdFx0aWQ6IFwibi1wcmV2aW91cy10YWJcIixcblx0XHRcdG5hbWU6IFwiUHJldmlvdXMgdGFiXCIsXG5cdFx0XHRpY29uOiBgbi1wcmV2aW91cy10YWJgLFxuXHRcdFx0ZWRpdG9yQ2FsbGJhY2s6IChlZGl0b3I6IEVkaXRvciwgdmlldzogTWFya2Rvd25WaWV3KSA9PiB7XG5cdFx0XHRcdC8vIEB0cy1pZ25vcmVcblx0XHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtY2FsbFxuXHRcdFx0XHQvL2NvbnNvbGUubG9nKHRoaXMuYXBwLmNvbW1hbmRzLmNvbW1hbmRzKVxuXHRcdFx0XHR0aGlzLmFwcC5jb21tYW5kcy5leGVjdXRlQ29tbWFuZEJ5SWQoXCJ3b3Jrc3BhY2U6cHJldmlvdXMtdGFiXCIpXG5cdFx0XHR9LFxuXHRcdH0pO1xuXG5cdFx0dGhpcy5hZGRPYnNpZGlhbkljb24oJ24tbmV4dC10YWInLCAnVD4nKTtcblx0XHR0aGlzLmFkZENvbW1hbmQoe1xuXHRcdFx0aWQ6IFwibi1uZXh0LXRhYlwiLFxuXHRcdFx0bmFtZTogXCJOZXh0IHRhYlwiLFxuXHRcdFx0aWNvbjogYG4tbmV4dC10YWJgLFxuXHRcdFx0ZWRpdG9yQ2FsbGJhY2s6IChlZGl0b3I6IEVkaXRvciwgdmlldzogTWFya2Rvd25WaWV3KSA9PiB7XG5cdFx0XHRcdC8vIEB0cy1pZ25vcmVcblx0XHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtY2FsbFxuXHRcdFx0XHQvL2NvbnNvbGUubG9nKHRoaXMuYXBwLmNvbW1hbmRzLmNvbW1hbmRzKVxuXHRcdFx0XHR0aGlzLmFwcC5jb21tYW5kcy5leGVjdXRlQ29tbWFuZEJ5SWQoXCJ3b3Jrc3BhY2U6bmV4dC10YWJcIilcblx0XHRcdH0sXG5cdFx0fSk7XG5cdFx0Ki9cblxuXHRcdHRoaXMuYWRkQ29tbWFuZCh7XG5cdFx0XHRpZDogXCJ0b2dnbGUtYnVsbGV0LW51bWJlci1saXN0XCIsXG5cdFx0XHRuYW1lOiBcIlRvZ2dsZSBCdWxsZXQgTnVtYmVyIExpc3RcIixcblx0XHRcdGljb246IGBidWxsZXQtbGlzdGAsXG5cdFx0XHRlZGl0b3JDYWxsYmFjazogKGVkaXRvcjogRWRpdG9yLCB2aWV3OiBNYXJrZG93blZpZXcpID0+IHtcblx0XHRcdFx0aWYgKGVkaXRvci5nZXRTZWxlY3Rpb24oKS5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdFx0Y29uc3QgbGlzdFNlbGVjdGlvbnM6IEVkaXRvclNlbGVjdGlvbltdID0gZWRpdG9yLmxpc3RTZWxlY3Rpb25zKCk7XG5cdFx0XHRcdFx0Zm9yIChjb25zdCBsaXN0U2VsZWN0aW9uIG9mIGxpc3RTZWxlY3Rpb25zKSB7XG5cdFx0XHRcdFx0XHRjb25zdCBhID0gbGlzdFNlbGVjdGlvbi5oZWFkLmxpbmU7XG5cdFx0XHRcdFx0XHRjb25zdCBiID0gbGlzdFNlbGVjdGlvbi5hbmNob3IubGluZTtcblx0XHRcdFx0XHRcdGNvbnN0IGZyb21MaW5lTnVtID0gYiA+IGEgPyBhIDogYjtcblx0XHRcdFx0XHRcdGNvbnN0IHRvTGluZU51bSA9IGIgPiBhID8gYiA6IGE7XG5cdFx0XHRcdFxuXHRcdFx0XHRcdFx0Zm9yIChsZXQgaSA9IGZyb21MaW5lTnVtOyBpIDw9IHRvTGluZU51bTsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdGNvbnN0IGxpbmUgPSBlZGl0b3IuZ2V0TGluZShpKTtcblx0XHRcdFx0XHRcdFx0Y29uc3QgbGluZUNvbnRlbnQgPSBlZGl0b3IuZ2V0TGluZShpKVxuXHRcdFx0XHRcdFx0XHRjb25zdCBwcmV2aW91c0xpbmVDb250ZW50ID0gaSA9PSAwID8gXCJcIiA6IGVkaXRvci5nZXRMaW5lKGkgLSAxKVxuXG5cdFx0XHRcdFx0XHRcdGlmICgvXig+ICkqXFxzKi0gLy50ZXN0KGxpbmVDb250ZW50KSkgeyAvLyBidWxsZXQgbGlzdCBjYXNlXG5cdFx0XHRcdFx0XHRcdFx0Ly8gdG9nZ2xlIHRvIG51bWJlciBsaXN0XG5cdFx0XHRcdFx0XHRcdFx0bGV0IG4gPSBcIjEuXCJcblx0XHRcdFx0XHRcdFx0XHRjb25zdCBhID0gcHJldmlvdXNMaW5lQ29udGVudC5tYXRjaCgvXlxcdCooXFxkKylcXC4gLylcblx0XHRcdFx0XHRcdFx0XHRpZiAoYSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y29uc3QgbmV4dE4gPSBwYXJzZUludChhWzBdKSArIDFcblx0XHRcdFx0XHRcdFx0XHRcdG4gPSBuZXh0Ti50b1N0cmluZygpICsgXCIuXCJcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0Y29uc3QgcmVwbGFjZWRMaW5lQ29udGVudCA9IGxpbmVDb250ZW50LnJlcGxhY2UoL14oKD4gKSopKFxccyopLSAvLCBcIiQxJDNcIiArIG4gKyBcIiBcIilcblx0XHRcdFx0XHRcdFx0XHRlZGl0b3Iuc2V0TGluZShpLCByZXBsYWNlZExpbmVDb250ZW50KVxuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKC9eKD4gKSpcXHMqW1xcZF0rXFwuIC8udGVzdChsaW5lQ29udGVudCkpIHsgLy8gbnVtYmVyIGxpc3QgY2FzZVxuXHRcdFx0XHRcdFx0XHRcdC8vIHRvZ2dsZSB0byBub24gbGlzdFxuXHRcdFx0XHRcdFx0XHRcdGNvbnN0IG4gPSBsaW5lQ29udGVudC5yZXBsYWNlKC9eKCg+ICkqKShcXHMqKShbXFxkXStcXC4gKS4qLywgXCIkNFwiKVxuXHRcdFx0XHRcdFx0XHRcdGNvbnN0IHJlcGxhY2VkTGluZUNvbnRlbnQgPSBsaW5lQ29udGVudC5yZXBsYWNlKC9eKCg+ICkqKShcXHMqKVtcXGRdK1xcLiAvLCBcIiQxJDNcIilcblx0XHRcdFx0XHRcdFx0XHRlZGl0b3Iuc2V0TGluZShpLCByZXBsYWNlZExpbmVDb250ZW50KVxuXHRcdFx0XHRcdFx0XHR9IGVsc2UgeyAvLyBubyBsaXN0XG5cdFx0XHRcdFx0XHRcdFx0Ly8gdG9nZ2xlIHRvIGJ1bGxldCBsaXN0XG5cdFx0XHRcdFx0XHRcdFx0Y29uc3QgcmVwbGFjZWRMaW5lQ29udGVudCA9IGxpbmVDb250ZW50LnJlcGxhY2UoL14oKD4gKSopKFxccyopLywgXCIkMSQzLSBcIilcblx0XHRcdFx0XHRcdFx0XHRlZGl0b3Iuc2V0TGluZShpLCByZXBsYWNlZExpbmVDb250ZW50KVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGNvbnN0IGN1cnNvciA9IGVkaXRvci5nZXRDdXJzb3IoKVxuXHRcdFx0XHRcdGNvbnN0IGNoID0gY3Vyc29yLmNoXG5cdFx0XHRcdFx0Y29uc3QgbGluZSA9IGN1cnNvci5saW5lXG5cdFx0XHRcdFx0Y29uc3QgbGluZUNvbnRlbnQgPSBlZGl0b3IuZ2V0TGluZShsaW5lKVxuXHRcdFx0XHRcdGNvbnN0IHByZXZpb3VzTGluZUNvbnRlbnQgPSBsaW5lID09IDAgPyBcIlwiIDogZWRpdG9yLmdldExpbmUobGluZSAtIDEpXG5cblx0XHRcdFx0XHRpZiAoL14oPiApKlxccyotIC8udGVzdChsaW5lQ29udGVudCkpIHsgLy8gYnVsbGV0IGxpc3QgY2FzZVxuXHRcdFx0XHRcdFx0Ly8gdG9nZ2xlIHRvIG51bWJlciBsaXN0XG5cdFx0XHRcdFx0XHRsZXQgbiA9IFwiMS5cIlxuXHRcdFx0XHRcdFx0Y29uc3QgYSA9IHByZXZpb3VzTGluZUNvbnRlbnQubWF0Y2goL15cXHQqKFxcZCspXFwuIC8pXG5cdFx0XHRcdFx0XHRpZiAoYSkge1xuXHRcdFx0XHRcdFx0XHRjb25zdCBuZXh0TiA9IHBhcnNlSW50KGFbMF0pICsgMVxuXHRcdFx0XHRcdFx0XHRuID0gbmV4dE4udG9TdHJpbmcoKSArIFwiLlwiXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRjb25zdCByZXBsYWNlZExpbmVDb250ZW50ID0gbGluZUNvbnRlbnQucmVwbGFjZSgvXigoPiApKikoXFxzKiktIC8sIFwiJDEkM1wiICsgbiArIFwiIFwiKVxuXHRcdFx0XHRcdFx0ZWRpdG9yLnNldExpbmUobGluZSwgcmVwbGFjZWRMaW5lQ29udGVudClcblx0XHRcdFx0XHRcdGN1cnNvci5jaCA9IGN1cnNvci5jaCArIG4ubGVuZ3RoIC0gMVxuXHRcdFx0XHRcdFx0ZWRpdG9yLnNldEN1cnNvcihjdXJzb3IpXG5cdFx0XHRcdFx0fSBlbHNlIGlmICgvXig+ICkqXFxzKltcXGRdK1xcLiAvLnRlc3QobGluZUNvbnRlbnQpKSB7IC8vIG51bWJlciBsaXN0IGNhc2Vcblx0XHRcdFx0XHRcdC8vIHRvZ2dsZSB0byBub24gbGlzdFxuXHRcdFx0XHRcdFx0Y29uc3QgbiA9IGxpbmVDb250ZW50LnJlcGxhY2UoL14oKD4gKSopKFxccyopKFtcXGRdK1xcLiApLiovLCBcIiQ0XCIpXG5cdFx0XHRcdFx0XHRjb25zdCByZXBsYWNlZExpbmVDb250ZW50ID0gbGluZUNvbnRlbnQucmVwbGFjZSgvXigoPiApKikoXFxzKilbXFxkXStcXC4gLywgXCIkMSQzXCIpXG5cdFx0XHRcdFx0XHRlZGl0b3Iuc2V0TGluZShsaW5lLCByZXBsYWNlZExpbmVDb250ZW50KVxuXHRcdFx0XHRcdFx0Y3Vyc29yLmNoID0gKGN1cnNvci5jaCAtIG4ubGVuZ3RoKSA+IDAgPyAoY3Vyc29yLmNoIC0gbi5sZW5ndGgpIDogMFxuXHRcdFx0XHRcdFx0ZWRpdG9yLnNldEN1cnNvcihjdXJzb3IpXG5cdFx0XHRcdFx0fSBlbHNlIHsgLy8gbm8gbGlzdFxuXHRcdFx0XHRcdFx0Ly8gdG9nZ2xlIHRvIGJ1bGxldCBsaXN0XG5cdFx0XHRcdFx0XHRjb25zdCByZXBsYWNlZExpbmVDb250ZW50ID0gbGluZUNvbnRlbnQucmVwbGFjZSgvXigoPiApKikoXFxzKikvLCBcIiQxJDMtIFwiKVxuXHRcdFx0XHRcdFx0ZWRpdG9yLnNldExpbmUobGluZSwgcmVwbGFjZWRMaW5lQ29udGVudClcblx0XHRcdFx0XHRcdGN1cnNvci5jaCA9IGN1cnNvci5jaCArIDJcblx0XHRcdFx0XHRcdGVkaXRvci5zZXRDdXJzb3IoY3Vyc29yKVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGhvdGtleXM6IFtcblx0XHRcdFx0e1xuXHRcdFx0XHRcdG1vZGlmaWVyczogW2BDdHJsYCwgYE1ldGFgLCBgU2hpZnRgXSxcblx0XHRcdFx0XHRrZXk6IGAtYCxcblx0XHRcdFx0fSxcblx0XHRcdFx0e1xuXHRcdFx0XHRcdG1vZGlmaWVyczogW2BDdHJsYCwgYEFsdGAsIGBTaGlmdGBdLFxuXHRcdFx0XHRcdGtleTogYC1gLFxuXHRcdFx0XHR9LFxuXHRcdFx0XVxuXHRcdH0pO1xuXG5cdFx0dGhpcy5hZGRDb21tYW5kKHtcblx0XHRcdGlkOiAnY29weS1vci1tb3ZlLXRvLW5ldy1ub3RlJyxcblx0XHRcdG5hbWU6ICdDb3B5IG9yIE1vdmUgdG8gbmV3IG5vdGUgQ01OJyxcblx0XHRcdGljb246IGBhaXJwbGF5YCxcblx0XHRcdGVkaXRvckNhbGxiYWNrOiBhc3luYyAoZWRpdG9yOiBFZGl0b3IsIHZpZXc6IE1hcmtkb3duVmlldykgPT4ge1xuXHRcdFx0XHRuZXcgQ29weU9yTW92ZVRvTmV3Tm90ZU1vZGFsKHRoaXMuYXBwLCBlZGl0b3IpLm9wZW4oKTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdHRoaXMuYWRkQ29tbWFuZCh7XG5cdFx0XHRpZDogXCJlZGl0b3ItY29weS1saW5lLXRvLWNsaXBib2FyZFwiLFxuXHRcdFx0bmFtZTogXCJFZGl0b3IgQ29weSBMaW5lIHRvIENsaXBib2FyZFwiLFxuXHRcdFx0aWNvbjogYGFsaWduLXZlcnRpY2FsLXNwYWNlLWFyb3VuZGAsXG5cdFx0XHRlZGl0b3JDYWxsYmFjazogKGVkaXRvcjogRWRpdG9yLCB2aWV3OiBNYXJrZG93blZpZXcpID0+IHtcblx0XHRcdFx0Y29uc3Qgc2VsZWN0aW9uID0gZXhwb3J0Q3VycmVudFNlbGVjdGlvbihlZGl0b3IpO1xuXHRcdFx0XHRjb25zdCBjb3B5Q29udGVudCA9IHNlbGVjdGlvbi5jb250YWlucyhcIlxcblwiKVxuXHRcdFx0XHRcdFx0XHRcdFx0PyBzZWxlY3Rpb25cblx0XHRcdFx0XHRcdFx0XHRcdDogc2VsZWN0aW9uLnJlcGxhY2UoL15cXHQqLSAvLCAnJykucmVwbGFjZSgvXlxcdCpcXGQrXFwuIC8sICcnKVxuXHRcdFx0XHR0aGlzLmFkZFRvQ2xpcGJvYXJkSGlzdG9yeShjb3B5Q29udGVudCk7XG5cdFx0XHRcdG5hdmlnYXRvci5jbGlwYm9hcmQud3JpdGVUZXh0KGNvcHlDb250ZW50KS50aGVuKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRuZXcgTm90aWNlKGBDb3BpZWQgY29udGVudFxcblxcYFxcYFxcYFxcbiR7Y29weUNvbnRlbnR9XFxuXFxgXFxgXFxgXFxudG8gY2xpcGJvYXJkIWApO1xuXHRcdFx0XHR9LCBmdW5jdGlvbiAoZXJyb3IpIHtcblx0XHRcdFx0XHRuZXcgTm90aWNlKGBlcnJvciB3aGVuIGNvcHkgdG8gY2xpcGJvYXJkIWApO1xuXHRcdFx0XHR9KTtcblx0XHRcdH0sXG5cdFx0XHRob3RrZXlzOiBbXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRtb2RpZmllcnM6IFtgQ3RybGAsIGBNZXRhYCwgYFNoaWZ0YF0sXG5cdFx0XHRcdFx0a2V5OiBcIi9cIixcblx0XHRcdFx0fSxcblx0XHRcdFx0e1xuXHRcdFx0XHRcdG1vZGlmaWVyczogW2BDdHJsYCwgYEFsdGAsIGBTaGlmdGBdLFxuXHRcdFx0XHRcdGtleTogXCIvXCIsXG5cdFx0XHRcdH0sXG5cdFx0XHRdXG5cdFx0fSlcblxuXHRcdHRoaXMuYWRkQ29tbWFuZCh7XG5cdFx0XHRpZDogXCJlZGl0b3ItY3V0LWxpbmUtdG8tY2xpcGJvYXJkXCIsXG5cdFx0XHRuYW1lOiBcIkVkaXRvciBDdXQgTGluZSB0byBDbGlwYm9hcmRcIixcblx0XHRcdGljb246IGBhbGlnbi12ZXJ0aWNhbC1qdXN0aWZ5LWNlbnRlcmAsXG5cdFx0XHRlZGl0b3JDYWxsYmFjazogKGVkaXRvcjogRWRpdG9yLCB2aWV3OiBNYXJrZG93blZpZXcpID0+IHtcblx0XHRcdFx0Y29uc3Qgc2VsZWN0aW9uID0gZXhwb3J0Q3VycmVudFNlbGVjdGlvbihlZGl0b3IpO1xuXHRcdFx0XHRjb25zdCBjdXJzb3IgPSBlZGl0b3IuZ2V0Q3Vyc29yKClcblx0XHRcdFx0Y29uc3QgY29weUNvbnRlbnQgPSBzZWxlY3Rpb24uY29udGFpbnMoXCJcXG5cIilcblx0XHRcdFx0XHRcdFx0XHRcdD8gc2VsZWN0aW9uXG5cdFx0XHRcdFx0XHRcdFx0XHQ6IHNlbGVjdGlvbi5yZXBsYWNlKC9eXFx0Ki0gLywgJycpLnJlcGxhY2UoL15cXHQqXFxkK1xcLiAvLCAnJylcblx0XHRcdFx0bGV0IG5ld0NvbnRlbnQgPSAnJ1xuXHRcdFx0XHRjb25zdCBzZWxlY3Rpb25SYW5nZTogU2VsZWN0aW9uUmFuZ2UgPSBnZXRDdXJyZW50U2VsZWN0aW9uTGluZU51bWJlcihlZGl0b3IpXG5cdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgZWRpdG9yLmxpbmVDb3VudCgpOyBpKyspIHtcblx0XHRcdFx0XHRpZiAoaSA8IHNlbGVjdGlvblJhbmdlLmZyb21MaW5lTnVtIHx8IGkgPiBzZWxlY3Rpb25SYW5nZS50b0xpbmVOdW0pIHtcblx0XHRcdFx0XHRcdG5ld0NvbnRlbnQgPSBuZXdDb250ZW50ICsgZWRpdG9yLmdldExpbmUoaSkgKyBcIlxcblwiXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuYWRkVG9DbGlwYm9hcmRIaXN0b3J5KGNvcHlDb250ZW50KTtcblx0XHRcdFx0bmF2aWdhdG9yLmNsaXBib2FyZC53cml0ZVRleHQoY29weUNvbnRlbnQpLnRoZW4oZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdG5ldyBOb3RpY2UoYENvcGllZCBjb250ZW50XFxuXFxgXFxgXFxgXFxuJHtjb3B5Q29udGVudH1cXG5cXGBcXGBcXGBcXG50byBjbGlwYm9hcmQhYCk7XG5cdFx0XHRcdH0sIGZ1bmN0aW9uIChlcnJvcikge1xuXHRcdFx0XHRcdG5ldyBOb3RpY2UoYGVycm9yIHdoZW4gY29weSB0byBjbGlwYm9hcmQhYCk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRlZGl0b3Iuc2V0VmFsdWUobmV3Q29udGVudClcblx0XHRcdFx0Y3Vyc29yLmxpbmUgPSBzZWxlY3Rpb25SYW5nZS5mcm9tTGluZU51bVxuXHRcdFx0XHRpZiAoZWRpdG9yLmdldExpbmUoc2VsZWN0aW9uUmFuZ2UuZnJvbUxpbmVOdW0pLmxlbmd0aCA8IHNlbGVjdGlvblJhbmdlLmZyb21DaCkge1xuXHRcdFx0XHRcdGN1cnNvci5jaCA9IGVkaXRvci5nZXRMaW5lKHNlbGVjdGlvblJhbmdlLmZyb21MaW5lTnVtKS5sZW5ndGhcblx0XHRcdFx0fVxuXHRcdFx0XHRlZGl0b3Iuc2V0Q3Vyc29yKGN1cnNvcilcblx0XHRcdH0sXG5cdFx0XHRob3RrZXlzOiBbXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRtb2RpZmllcnM6IFtgQ3RybGAsIGBNZXRhYCwgYFNoaWZ0YF0sXG5cdFx0XHRcdFx0a2V5OiBcIlxcXFxcIixcblx0XHRcdFx0fSxcblx0XHRcdFx0e1xuXHRcdFx0XHRcdG1vZGlmaWVyczogW2BDdHJsYCwgYEFsdGAsIGBTaGlmdGBdLFxuXHRcdFx0XHRcdGtleTogXCJcXFxcXCIsXG5cdFx0XHRcdH0sXG5cdFx0XHRdXG5cdFx0fSlcblxuXHRcdHRoaXMuYWRkQ29tbWFuZCh7XG5cdFx0XHRpZDogXCJlZGl0b3ItaW5kZW50LWxpbmVcIixcblx0XHRcdG5hbWU6IFwiRWRpdG9yIEluZGVudCBTZWxlY3Rpb25cIixcblx0XHRcdGljb246IGByaWdodC1hcnJvdy13aXRoLXRhaWxgLFxuXHRcdFx0ZWRpdG9yQ2FsbGJhY2s6IChlZGl0b3I6IEVkaXRvciwgdmlldzogTWFya2Rvd25WaWV3KSA9PiB7XG5cdFx0XHRcdGNvbnN0IGxpc3RTZWxlY3Rpb25zIDogRWRpdG9yU2VsZWN0aW9uW10gPSBlZGl0b3IubGlzdFNlbGVjdGlvbnMoKVxuXHRcdFx0XHRsaXN0U2VsZWN0aW9ucy5mb3JFYWNoKGxpc3RTZWxlY3Rpb24gPT4ge1xuXHRcdFx0XHRcdGNvbnN0IGEgPSBsaXN0U2VsZWN0aW9uLmhlYWQubGluZVxuXHRcdFx0XHRcdGNvbnN0IGIgPSBsaXN0U2VsZWN0aW9uLmFuY2hvci5saW5lXG5cdFx0XHRcdFx0Y29uc3QgZnJvbUxpbmVOdW0gPSBiID4gYSA/IGEgOiBiXG5cdFx0XHRcdFx0Y29uc3QgdG9MaW5lTnVtID0gYiA+IGEgPyBiIDogYVxuXHRcdFx0XHRcdGZvciAobGV0IGkgPSBmcm9tTGluZU51bTsgaSA8PSB0b0xpbmVOdW07IGkrKykge1xuXHRcdFx0XHRcdFx0Y29uc3QgbGluZSA9IGVkaXRvci5nZXRMaW5lKGkpXG5cdFx0XHRcdFx0XHRlZGl0b3Iuc2V0TGluZShpLCBsaW5lLnJlcGxhY2UoL14vLCBcIlxcdFwiKSlcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pXG5cdFx0XHRcdGxldCBsc3MgOiBFZGl0b3JTZWxlY3Rpb25bXSA9IFtdXG5cdFx0XHRcdGxpc3RTZWxlY3Rpb25zLmZvckVhY2gobHMgPT4ge1xuXHRcdFx0XHRcdGNvbnN0IGhlYWQgPSBscy5oZWFkXG5cdFx0XHRcdFx0aGVhZC5jaCA9IGhlYWQuY2ggKyAxXG5cdFx0XHRcdFx0Y29uc3QgYW5jaG9yID0gbHMuYW5jaG9yXG5cdFx0XHRcdFx0YW5jaG9yLmNoID0gYW5jaG9yLmNoICsgMVxuXHRcdFx0XHRcdGNvbnN0IG5ld0xzOiBFZGl0b3JTZWxlY3Rpb24gPSB7YW5jaG9yLCBoZWFkfVxuXHRcdFx0XHRcdGxzcy5wdXNoKG5ld0xzKVxuXHRcdFx0XHR9KVxuXHRcdFx0XHRlZGl0b3Iuc2V0U2VsZWN0aW9ucyhsc3MpXG5cdFx0XHR9XG5cdFx0fSlcblxuXHRcdHRoaXMuYWRkQ29tbWFuZCh7XG5cdFx0XHRpZDogXCJlZGl0b3Itb3V0ZGVudC1saW5lXCIsXG5cdFx0XHRuYW1lOiBcIkVkaXRvciBPdXRkZW50IFNlbGVjdGlvblwiLFxuXHRcdFx0aWNvbjogYGxlZnQtYXJyb3ctd2l0aC10YWlsYCxcblx0XHRcdGVkaXRvckNhbGxiYWNrOiAoZWRpdG9yOiBFZGl0b3IsIHZpZXc6IE1hcmtkb3duVmlldykgPT4ge1xuXHRcdFx0XHRjb25zdCBsaXN0U2VsZWN0aW9ucyA6IEVkaXRvclNlbGVjdGlvbltdID0gZWRpdG9yLmxpc3RTZWxlY3Rpb25zKClcblx0XHRcdFx0bGlzdFNlbGVjdGlvbnMuZm9yRWFjaChsaXN0U2VsZWN0aW9uID0+IHtcblx0XHRcdFx0XHRjb25zdCBhID0gbGlzdFNlbGVjdGlvbi5oZWFkLmxpbmVcblx0XHRcdFx0XHRjb25zdCBiID0gbGlzdFNlbGVjdGlvbi5hbmNob3IubGluZVxuXHRcdFx0XHRcdGNvbnN0IGZyb21MaW5lTnVtID0gYiA+IGEgPyBhIDogYlxuXHRcdFx0XHRcdGNvbnN0IHRvTGluZU51bSA9IGIgPiBhID8gYiA6IGFcblx0XHRcdFx0XHRmb3IgKGxldCBpID0gZnJvbUxpbmVOdW07IGkgPD0gdG9MaW5lTnVtOyBpKyspIHtcblx0XHRcdFx0XHRcdGNvbnN0IGxpbmUgPSBlZGl0b3IuZ2V0TGluZShpKVxuXHRcdFx0XHRcdFx0ZWRpdG9yLnNldExpbmUoaSwgbGluZS5yZXBsYWNlKC9eXFx0LywgXCJcIikpXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KVxuXHRcdFx0XHRsZXQgbHNzIDogRWRpdG9yU2VsZWN0aW9uW10gPSBbXVxuXHRcdFx0XHRsaXN0U2VsZWN0aW9ucy5mb3JFYWNoKGxzID0+IHtcblx0XHRcdFx0XHRjb25zdCBoZWFkID0gbHMuaGVhZFxuXHRcdFx0XHRcdGhlYWQuY2ggPSBoZWFkLmNoICsgMVxuXHRcdFx0XHRcdGNvbnN0IGFuY2hvciA9IGxzLmFuY2hvclxuXHRcdFx0XHRcdGFuY2hvci5jaCA9IGFuY2hvci5jaCArIDFcblx0XHRcdFx0XHRjb25zdCBuZXdMczogRWRpdG9yU2VsZWN0aW9uID0ge2FuY2hvciwgaGVhZH1cblx0XHRcdFx0XHRsc3MucHVzaChuZXdMcylcblx0XHRcdFx0fSlcblx0XHRcdFx0ZWRpdG9yLnNldFNlbGVjdGlvbnMobHNzKVxuXHRcdFx0fVxuXHRcdH0pXG5cblxuXHRcdC8vIFRoaXMgYWRkcyBhIHNldHRpbmdzIHRhYiBzbyB0aGUgdXNlciBjYW4gY29uZmlndXJlIHZhcmlvdXMgYXNwZWN0cyBvZiB0aGUgcGx1Z2luXG5cdFx0dGhpcy5hZGRTZXR0aW5nVGFiKG5ldyBTYW1wbGVTZXR0aW5nVGFiKHRoaXMuYXBwLCB0aGlzKSk7XG5cdH1cblxuXHRjb252ZXJ0Q2hhdEdQVFRvVHdpdHRlckZvcm1hdChlZGl0b3I6IEVkaXRvcikgOiBib29sZWFuIHsgLy8gdHJ1ZSBtZWFucyBzdWNjZXNzXG5cdFx0bGV0IGxpbmUgPSBlZGl0b3IubGluZUNvdW50KCk7XG5cblx0XHRsZXQgbnVtTGluZUZpcnN0Q29udGVudCA9IDBcblx0XHRsZXQgZnJvbnRNYXR0ZXJMaW5lQ291bnQgPSAwXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lOyBpKyspIHtcblx0XHRcdGlmIChmcm9udE1hdHRlckxpbmVDb3VudCA9PSAyKSB7XG5cdFx0XHRcdG51bUxpbmVGaXJzdENvbnRlbnQgPSBpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdGlmIChlZGl0b3IuZ2V0TGluZShpKSA9PSBcIi0tLVwiKSB7XG5cdFx0XHRcdGZyb250TWF0dGVyTGluZUNvdW50Kytcblx0XHRcdH1cblx0XHR9XG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lOyBpKyspIHtcblx0XHRcdGlmIChlZGl0b3IuZ2V0TGluZShudW1MaW5lRmlyc3RDb250ZW50KS50cmltKCkgPT0gXCJcIikge1xuXHRcdFx0XHRudW1MaW5lRmlyc3RDb250ZW50Kys7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cblx0XHRsZXQgdG90YWxUd2VldENvdW50ID0gMVxuXG5cdFx0QXJyYXkuZnJvbShBcnJheShsaW5lIC0gbnVtTGluZUZpcnN0Q29udGVudCkua2V5cygpKS5mb3JFYWNoKGkgPT4ge1xuXHRcdFx0Y29uc3QgbGluZSA9IGVkaXRvci5nZXRMaW5lKGkgKyBudW1MaW5lRmlyc3RDb250ZW50KTtcblx0XHRcdGxldCBtb2RpZmllZExpbmUgPSBsaW5lLnJlcGxhY2UoL15fX19fKy8sIFwiLS0tXCIpLnJlcGxhY2UoL14tLS0tKy8sIFwiLS0tXCIpXG5cdFx0XHRlZGl0b3Iuc2V0TGluZShpICsgbnVtTGluZUZpcnN0Q29udGVudCwgbW9kaWZpZWRMaW5lKVxuXHRcdFx0aWYgKG1vZGlmaWVkTGluZSA9PSBcIi0tLVwiKSB7XG5cdFx0XHRcdHRvdGFsVHdlZXRDb3VudCA9IHRvdGFsVHdlZXRDb3VudCArIDFcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdGxldCBudW1Ud2VldCA9IDFcblx0XHRsZXQgcmVhZHlUb0FkZFR3ZWV0Q291bnQgPSB0cnVlXG5cblx0XHRsZXQgdGV4dCA9IFwiXCI7XG5cdFx0QXJyYXkuZnJvbShBcnJheShudW1MaW5lRmlyc3RDb250ZW50KS5rZXlzKCkpLmZvckVhY2goaSA9PiB7XG5cdFx0XHRjb25zdCBsaW5lID0gZWRpdG9yLmdldExpbmUoaSk7XG5cdFx0XHR0ZXh0ID0gdGV4dCArIGxpbmUgKyBcIlxcblwiXG5cdFx0fSlcblxuXHRcdEFycmF5LmZyb20oQXJyYXkobGluZSAtIG51bUxpbmVGaXJzdENvbnRlbnQpLmtleXMoKSkuZm9yRWFjaChpID0+IHtcblx0XHRcdGNvbnN0IGxpbmUgPSBlZGl0b3IuZ2V0TGluZShpICsgbnVtTGluZUZpcnN0Q29udGVudCk7XG5cdFx0XHRsZXQgbW9kaWZpZWRMaW5lID0gbGluZTtcblx0XHRcdGlmIChsaW5lID09IFwiLS0tXCIpIHtcblx0XHRcdFx0cmVhZHlUb0FkZFR3ZWV0Q291bnQgPSB0cnVlXG5cdFx0XHRcdG51bVR3ZWV0ID0gbnVtVHdlZXQgKyAxXG5cdFx0XHR9IGVsc2UgaWYgKGxpbmUgIT0gXCJcIiAmJiByZWFkeVRvQWRkVHdlZXRDb3VudCkge1xuXHRcdFx0XHRpZiAoIS9eXFxkK1xcL1xcZCsuKi8udGVzdChsaW5lKSkge1xuXHRcdFx0XHRcdG1vZGlmaWVkTGluZSA9IGAke251bVR3ZWV0fS8ke3RvdGFsVHdlZXRDb3VudH0gJHtsaW5lfWBcblx0XHRcdFx0fVxuXHRcdFx0XHRyZWFkeVRvQWRkVHdlZXRDb3VudCA9IGZhbHNlXG5cdFx0XHR9XG5cdFx0XHR0ZXh0ID0gdGV4dCArIG1vZGlmaWVkTGluZSArIFwiXFxuXCJcblx0XHR9KTtcblxuXHRcdHRleHQgPSB0ZXh0LnJlcGxhY2UoXCJcdTI1OERcIiwgXCJcIilcblxuXHRcdC8vIHNob3VsZCBJIGFkZCBjaGVjayBzZWdtZW50P1xuXHRcdGNvbnN0IHR3ZWV0cyA9IHRleHQuc3BsaXQoXCItLS1cIilcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHR3ZWV0cy5sZW5ndGg7IGkrKylcblx0XHR7XG5cdFx0XHRjb25zdCB0d2VldCA9IHR3ZWV0c1tpXS5yZXBsYWNlKC8oaHR0cHM6fGh0dHA6fHd3d1xcLilcXFMqL2dtLCBcIlwiKS5yZXBsYWNlKC9eXFxuKy9tLCBcIlwiKS5yZXBsYWNlKC9cXG4rJC9tLCBcIlwiKVxuXHRcdFx0aWYgKHR3ZWV0Lmxlbmd0aCA+IDE0MClcblx0XHRcdHtcblx0XHRcdFx0bmV3IE5vdGljZShcImBgYFxcblwiICsgdHdlZXQgKyBcIlxcbmBgYFxcblxcbmV4Y2VlZCAxNDAgY2hhcmFjdGVycyAoY3VycmVudGx5IFwiICsgdHdlZXQubGVuZ3RoICsgXCIgY2hhcmFjdGVycykuIFByb2JhYmx5IGNhbm5vdCBwb3N0IGluIHR3aXR0ZXIuIFBsZWFzZSByZWZpbmUgdGhlIHR3ZWV0LiBBYm9ydGluZ1wiKVxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZWRpdG9yLnNldFZhbHVlKHRleHQpXG5cdFx0Y29uc3QgY3Vyc29yID0gZWRpdG9yLmdldEN1cnNvcigpXG5cdFx0Y3Vyc29yLmxpbmUgPSBlZGl0b3IubGluZUNvdW50KCkgLSAxXG5cdFx0ZWRpdG9yLnNldEN1cnNvcihjdXJzb3IpXG5cdFx0cmV0dXJuIHRydWVcblx0fVxuXG5cdHJldmVyc2VUd2l0dGVyTnVtYmVyaW5nKGVkaXRvcjogRWRpdG9yKSB7XG5cdFx0bGV0IGxpbmUgPSBlZGl0b3IubGluZUNvdW50KCk7XG5cblx0XHRsZXQgbnVtTGluZUZpcnN0Q29udGVudCA9IDBcblx0XHRsZXQgZnJvbnRNYXR0ZXJMaW5lQ291bnQgPSAwXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lOyBpKyspIHtcblx0XHRcdGlmIChmcm9udE1hdHRlckxpbmVDb3VudCA9PSAyKSB7XG5cdFx0XHRcdG51bUxpbmVGaXJzdENvbnRlbnQgPSBpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdGlmIChlZGl0b3IuZ2V0TGluZShpKSA9PSBcIi0tLVwiKSB7XG5cdFx0XHRcdGZyb250TWF0dGVyTGluZUNvdW50Kytcblx0XHRcdH1cblx0XHR9XG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lOyBpKyspIHtcblx0XHRcdGlmIChlZGl0b3IuZ2V0TGluZShudW1MaW5lRmlyc3RDb250ZW50KS50cmltKCkgPT0gXCJcIikge1xuXHRcdFx0XHRudW1MaW5lRmlyc3RDb250ZW50Kys7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cblx0XHRsZXQgdGV4dCA9IFwiXCI7XG5cdFx0QXJyYXkuZnJvbShBcnJheShudW1MaW5lRmlyc3RDb250ZW50KS5rZXlzKCkpLmZvckVhY2goaSA9PiB7XG5cdFx0XHRjb25zdCBsaW5lID0gZWRpdG9yLmdldExpbmUoaSk7XG5cdFx0XHR0ZXh0ID0gdGV4dCArIGxpbmUgKyBcIlxcblwiXG5cdFx0fSlcblxuXHRcdEFycmF5LmZyb20oQXJyYXkobGluZSAtIG51bUxpbmVGaXJzdENvbnRlbnQpLmtleXMoKSkuZm9yRWFjaChpID0+IHtcblx0XHRcdGNvbnN0IGxpbmUgPSBlZGl0b3IuZ2V0TGluZShpICsgbnVtTGluZUZpcnN0Q29udGVudCk7XG5cdFx0XHRjb25zdCBtb2RpZmllZExpbmUgPSBsaW5lLnJlcGxhY2UoL15cXGQrXFwvXFxkKyAvLCBcIlwiKVxuXHRcdFx0dGV4dCA9IHRleHQgKyBtb2RpZmllZExpbmUgKyBcIlxcblwiXG5cdFx0fSk7XG5cblx0XHRlZGl0b3Iuc2V0VmFsdWUodGV4dClcblx0XHRjb25zdCBjdXJzb3IgPSBlZGl0b3IuZ2V0Q3Vyc29yKClcblx0XHRjdXJzb3IubGluZSA9IGVkaXRvci5saW5lQ291bnQoKSAtIDFcblx0XHRlZGl0b3Iuc2V0Q3Vyc29yKGN1cnNvcilcblx0fVxuXG5cblx0Y29udmVydFRocmVhZHNDb250ZW50VG9Gb3JtYXRGb3JUaHJlYWRzQXBwKGVkaXRvcjogRWRpdG9yKSA6IHN0cmluZyB7XG5cdFx0bGV0IHJlc3VsdCA9IHRoaXMuY29udmVydFRocmVhZHNDb250ZW50VG9MaWdodFBvc3RGb3JtYXQoZWRpdG9yLCBcIlx1RDgzRVx1RERGNVwiLCBcIlxcblxcblxcblwiKVxuXHRcdHJlc3VsdCA9IHJlc3VsdC5yZXBsYWNlKC9odHRwc1xcOlxcL1xcL2dpdGh1Yi5jb21bXlxcbl0rXFxuXFxuXFxuL20sIFwiXCIpXG5cdFx0cmV0dXJuIHJlc3VsdFxuXHR9XG5cblx0Y29udmVydFRocmVhZHNDb250ZW50VG9Gb3JtYXRGb3JGYWNlYm9va0FwcChlZGl0b3I6IEVkaXRvcikgOiBzdHJpbmcge1xuXHRcdGxldCByZXN1bHQgPSB0aGlzLmNvbnZlcnRUaHJlYWRzQ29udGVudFRvTGlnaHRQb3N0Rm9ybWF0KGVkaXRvciwgXCJcIiwgXCJcXG5cXG5cdTExNzNcdTExNzNcdTExNzNcdTExNzNcdTExNzNcdTExNzNcdTExNzNcdTExNzNcdTExNzNcdTExNzNcdTExNzNcdTExNzNcdTExNzNcdTExNzNcdTExNzNcdTExNzNcdTExNzNcdTExNzNcdTExNzNcdTExNzNcdTExNzNcdTExNzNcXG5cXG5cIiwgKGEpID0+IGEucmVwbGFjZShcIlx1RDgzRFx1REM0N1wiLCBcIlwiKSlcblx0XHRyZXN1bHQgPSByZXN1bHQucmVwbGFjZSgvaHR0cHNcXDpcXC9cXC9naXRodWIuY29tW15cXG5dK1xcblxcblx1MTE3M1x1MTE3M1x1MTE3M1x1MTE3M1x1MTE3M1x1MTE3M1x1MTE3M1x1MTE3M1x1MTE3M1x1MTE3M1x1MTE3M1x1MTE3M1x1MTE3M1x1MTE3M1x1MTE3M1x1MTE3M1x1MTE3M1x1MTE3M1x1MTE3M1x1MTE3M1x1MTE3M1x1MTE3M1xcblxcbi9tLCBcIlwiKVxuXHRcdHJldHVybiByZXN1bHRcblx0fVxuXG5cdGNvbnZlcnRUaHJlYWRzQ29udGVudFRvUE9FKGVkaXRvcjogRWRpdG9yKSA6IHN0cmluZyB7XG5cdFx0cmV0dXJuIHRoaXMuY29udmVydFRocmVhZHNDb250ZW50VG9MaWdodFBvc3RGb3JtYXQoZWRpdG9yLCBcIlwiLCBcIlxcblxcbi0tLVxcblxcblwiLCAoYSkgPT4gYS5yZXBsYWNlKFwiXHVEODNEXHVEQzQ3XCIsIFwiXCIpKVxuXHR9XG5cbi8qXG5cdGFkZFRhc2tUb1B1dEludG9DYXJkSW5UaHJlYWRzQ29udGVudChlZGl0b3I6IEVkaXRvcikge1xuXHRcdGxldCBsaW5lID0gZWRpdG9yLmxpbmVDb3VudCgpO1xuXG5cdFx0bGV0IGZyb250TWF0dGVyTGluZUNvdW50ID0gMFxuXHRcdGxldCB0ZXh0ID0gXCJcIjtcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGxpbmU7IGkrKykge1xuXHRcdFx0aWYgKGVkaXRvci5nZXRMaW5lKGkpID09IFwiLS0tXCIpIHtcblx0XHRcdFx0ZnJvbnRNYXR0ZXJMaW5lQ291bnQrK1xuXHRcdFx0fVxuXHRcdFx0Y29uc3QgbGluZSA9IGVkaXRvci5nZXRMaW5lKGkpO1xuXHRcdFx0XG5cdFx0XHQvL2lmIChmcm9udE1hdHRlckxpbmVDb3VudCA+IDIgJiYgbGluZSA9PSBcIi0tLVwiKSB7XG5cdFx0XHQvL1x0dGV4dCA9IHRleHQgKyBcIiUlICNubSB0byB6ayAlJVxcblxcblwiXG5cdFx0XHQvL31cblx0XHRcdHRleHQgPSB0ZXh0ICsgbGluZSArIFwiXFxuXCJcblx0XHR9XG5cblx0XHRlZGl0b3Iuc2V0VmFsdWUodGV4dCk7XG5cdH1cbiovXG5cblx0Y29udmVydFRocmVhZHNDb250ZW50VG9MaWdodFBvc3RGb3JtYXQoZWRpdG9yOiBFZGl0b3IsIGhlYWRlckljb246IHN0cmluZywgcGFyYWdyYXBoU2VwYXJhdG9yOiBzdHJpbmdcblx0XHQsIGFkZGl0aW9uUmVwbGFjZUZuOiAoYTogc3RyaW5nKSA9PiBzdHJpbmcgPSAoYSkgPT4gYSkgOiBzdHJpbmcge1xuXHRcdGxldCBsaW5lID0gZWRpdG9yLmxpbmVDb3VudCgpO1xuXG5cdFx0bGV0IG51bUxpbmVGaXJzdENvbnRlbnQgPSAwXG5cdFx0bGV0IGZyb250TWF0dGVyTGluZUNvdW50ID0gMFxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbGluZTsgaSsrKSB7XG5cdFx0XHRpZiAoZnJvbnRNYXR0ZXJMaW5lQ291bnQgPT0gMikge1xuXHRcdFx0XHRudW1MaW5lRmlyc3RDb250ZW50ID0gaTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRpZiAoZWRpdG9yLmdldExpbmUoaSkgPT0gXCItLS1cIikge1xuXHRcdFx0XHRmcm9udE1hdHRlckxpbmVDb3VudCsrXG5cdFx0XHR9XG5cdFx0fVxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbGluZTsgaSsrKSB7XG5cdFx0XHRpZiAoZWRpdG9yLmdldExpbmUobnVtTGluZUZpcnN0Q29udGVudCkudHJpbSgpID09IFwiXCIpIHtcblx0XHRcdFx0bnVtTGluZUZpcnN0Q29udGVudCsrO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0bGV0IHRleHQgPSBcIlwiO1xuXHRcdGxldCBuZXdDb25zZWN1dGl2ZUxpbmVDb3VudCA9IDA7XG5cdFx0QXJyYXkuZnJvbShBcnJheShsaW5lIC0gbnVtTGluZUZpcnN0Q29udGVudCkua2V5cygpKS5mb3JFYWNoKGkgPT4ge1xuXHRcdFx0Y29uc3QgbGluZSA9IGVkaXRvci5nZXRMaW5lKGkgKyBudW1MaW5lRmlyc3RDb250ZW50KTtcblx0XHRcdGlmICghbGluZS50cmltKCkuc3RhcnRzV2l0aChcIiUlXCIpIHx8ICFsaW5lLnRyaW0oKS5lbmRzV2l0aChcIiUlXCIpKSB7XG5cdFx0XHRcdGlmIChsaW5lID09IFwiLS0tXCIpIHtcblx0XHRcdFx0XHRuZXdDb25zZWN1dGl2ZUxpbmVDb3VudCA9IDA7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGxpbmUgPT0gXCJcIikge1xuXHRcdFx0XHRcdG5ld0NvbnNlY3V0aXZlTGluZUNvdW50Kys7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0bmV3Q29uc2VjdXRpdmVMaW5lQ291bnQgPSAwO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChsaW5lID09IFwiXCIgJiYgbmV3Q29uc2VjdXRpdmVMaW5lQ291bnQgPiAxKSB7XG5cdFx0XHRcdFx0Ly8gZG8gbm90aGluZ1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGxldCBtb2RpZmllZExpbmUgPSBsaW5lID09IFwiLS0tXCIgPyBcIlwiIDogbGluZVxuXHRcdFx0XHRcdG1vZGlmaWVkTGluZSA9IG1vZGlmaWVkTGluZS5yZXBsYWNlKC9eXHRcdC0gL2csIFwiXHUzMDAwXHUzMDAwXHUzMDAwXHUzMDAwXHUyMDIyIFwiKS5yZXBsYWNlKC9eXHQtIC9nLCBcIlx1MzAwMFx1MzAwMFx1MjAyMiBcIikucmVwbGFjZSgvXi0gLywgXCJcdTIwMjIgXCIpO1xuXHRcdFx0XHRcdG1vZGlmaWVkTGluZSA9IG1vZGlmaWVkTGluZS5yZXBsYWNlKC9eXFxbKFteXFxbXFxdXFwoXFwpXSspXFxdXFwoW15cXFtcXF1cXChcXCldK1xcKS9nLCBcIiQxXCIpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0LnJlcGxhY2UoL1teIV1cXFsoW15cXFtcXF1cXChcXCldKylcXF1cXChbXlxcW1xcXVxcKFxcKV0rXFwpL2csIFwiJDFcIilcblx0XHRcdFx0XHRtb2RpZmllZExpbmUgPSBtb2RpZmllZExpbmUucmVwbGFjZSgvIVxcWyhbXlxcW1xcXVxcKFxcKV0rKVxcXVxcKChbXlxcW1xcXVxcKFxcKV0rKVxcKS9nLCBcIiQyXCIpXG5cdFx0XHRcdFx0bW9kaWZpZWRMaW5lID0gbW9kaWZpZWRMaW5lLnJlcGxhY2UoL1xcKlxcKi9nbSwgXCJcIilcblx0XHRcdFx0XHR0ZXh0ID0gdGV4dCArIG1vZGlmaWVkTGluZSArIFwiXFxuXCJcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdFxuXHRcdHRleHQgPSB0ZXh0LnJlcGxhY2UoL1x1RDgzRVx1RERGNVsgXSsoLiopL2csIGhlYWRlckljb24gKyBcIlx1MzAxMCQxXHUzMDExXCIpXG5cdFx0dGV4dCA9IGFkZGl0aW9uUmVwbGFjZUZuKHRleHQpXG5cdFx0Ly8gdGV4dCA9IHRleHQucmVwbGFjZSgvXlx0XHQtIC9nLCBcIlx1MzAwMFx1MzAwMFx1MjAyMiBcIikucmVwbGFjZSgvXlx0LSAvZywgXCJcdTMwMDBcdTIwMjIgXCIpLnJlcGxhY2UoL14tIC8sIFwiXHUyMDIyIFwiKTtcblx0XHQvL3RleHQgPSB0ZXh0LnJlcGxhY2UoL1tcXG5cXHJdezMsfShbXlxcblxccl0rXHUzMDAyW1xcblxccl0pL2dtLCBgJHtwYXJhZ3JhcGhTZXBhcmF0b3J9JDFgKTtcblx0XHQvL3RleHQgPSB0ZXh0LnJlcGxhY2UoL1tcXG5cXHJdezMsfShbXlxcblxccl0rXHVGRjFBW1xcblxccl0pL2dtLCBgJHtwYXJhZ3JhcGhTZXBhcmF0b3J9JDFgKTtcblx0XHQvL3RleHQgPSB0ZXh0LnJlcGxhY2UoL1tcXG5cXHJdezMsfShodHRwW15cXG5cXHJdK1tcXG5cXHJdKS9nbSwgYCR7cGFyYWdyYXBoU2VwYXJhdG9yfSQxYCk7XG5cdFx0dGV4dCA9IHRleHQucmVwbGFjZSgvW1xcblxccl17Myx9L2dtLCBgJHtwYXJhZ3JhcGhTZXBhcmF0b3J9XHUyNThEYCk7XG5cblx0XHR0ZXh0ID0gdGV4dC5yZXBsYWNlKFwiXFxuXHUxMTczXHUxMTczXHUxMTczXHUxMTczXHUxMTczXHUxMTczXHUxMTczXHUxMTczXHUxMTczXHUxMTczXHUxMTczXHUxMTczXHUxMTczXHUxMTczXHUxMTczXHUxMTczXHUxMTczXHUxMTczXHUxMTczXHUxMTczXHUxMTczXHUxMTczXFxuXFxuXHUyNThEXFxuXCIsIFwiXCIpIC8vIHJlbW92ZSBlbXB0eSBsaW5lXG5cblx0XHRsZXQgdGV4dDIgPSBcIlwiXG5cblx0XHR0ZXh0LnNwbGl0KFwiXFxuXCIpLmZvckVhY2gobGluZSA9PiB7XG5cdFx0XHR2YXIgbCA9IFwiXCJcblxuXHRcdFx0aWYgKGxpbmUuZW5kc1dpdGgoXCJcdTMwMDJcIikgfHwgbGluZS5lbmRzV2l0aChcIlx1RkYxQVwiKSB8fCBsaW5lLmVuZHNXaXRoKFwiXHVGRjVFXCIpIHx8IGxpbmUuZW5kc1dpdGgoXCJcdUZGMDFcIikgfHwgbGluZS5zdGFydHNXaXRoKFwiXHUyNThEaHR0cFwiKSB8fCBsaW5lLnN0YXJ0c1dpdGgoXCJcdTI1OEQjXCIpIHx8IGxpbmUgPT0gXCJcdTI1OERcIikge1xuXHRcdFx0XHRsID0gbGluZS5yZXBsYWNlKC9eXHUyNThEL2dtLCBcIlwiKVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bCA9IGxpbmVcblx0XHRcdH1cblx0XHRcdHRleHQyID0gdGV4dDIgKyBsICsgXCJcXG5cIlxuXHRcdH0pXG5cblx0XHR0ZXh0MiA9IHRleHQyLnJlcGxhY2UoXCJcXG5cXG5cXG5cXG5cIiwgXCJcIikgLy8gcmVtb3ZlIGVtcHR5IGxpbmVcblx0XHR0ZXh0MiA9IHRleHQyLnJlcGxhY2UoXCJcXG5cdTExNzNcdTExNzNcdTExNzNcdTExNzNcdTExNzNcdTExNzNcdTExNzNcdTExNzNcdTExNzNcdTExNzNcdTExNzNcdTExNzNcdTExNzNcdTExNzNcdTExNzNcdTExNzNcdTExNzNcdTExNzNcdTExNzNcdTExNzNcdTExNzNcdTExNzNcXG5cXG5cXG5cIiwgXCJcIikgLy8gcmVtb3ZlIGVtcHR5IGxpbmVcblx0XHR0ZXh0MiA9IHRleHQyLnJlcGxhY2UoL1xcblxcbiMjIE9waW5pb24gZnJvbSBDaGF0R1BUXFw6KFtcXG5dKi4qKSokLywgXCJcIilcblx0XHR0ZXh0MiA9IHRleHQyLnJlcGxhY2UoL1xcbiskLywgXCJcIilcblxuXHRcdHJldHVybiB0ZXh0MlxuXHR9XG5cblx0Z2V0VGhyZWFkU2VnbWVudChlZGl0b3I6IEVkaXRvcikgOiBzdHJpbmcge1xuXHRcdGxldCBjdXJzb3IgPSBlZGl0b3IuZ2V0Q3Vyc29yKCk7XG5cdFx0bGV0IGxpbmUgPSBjdXJzb3IubGluZTtcblx0XHRsZXQgYWJvdmUgPSBsaW5lO1xuXHRcdGxldCBiZWxvdyA9IGxpbmU7XG5cdFx0Ly8gZmlyc3QgZ2V0IGFib3ZlXG5cdFx0XG5cdFx0d2hpbGUgKGFib3ZlID49IDApIHtcblx0XHRcdGxldCBsID0gZWRpdG9yLmdldExpbmUoYWJvdmUpO1xuXHRcdFx0aWYgKGwgPT0gJy0tLScpIHtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRhYm92ZS0tO1xuXHRcdH1cblx0XHRpZiAoZWRpdG9yLmdldExpbmUoYWJvdmUpID09ICctLS0nKSB7XG5cdFx0XHRhYm92ZSsrO1xuXHRcdH1cblx0XHR3aGlsZSh0cnVlKSB7XG5cdFx0XHRpZiAoZWRpdG9yLmdldExpbmUoYWJvdmUpID09ICcnKSB7XG5cdFx0XHRcdGFib3ZlKys7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyB0aGVuIGdldCBiZWxvd1xuXHRcdHdoaWxlIChiZWxvdyA8IGVkaXRvci5saW5lQ291bnQoKSkge1xuXHRcdFx0bGV0IGwgPSBlZGl0b3IuZ2V0TGluZShiZWxvdyk7XG5cdFx0XHRpZiAobCA9PSAnLS0tJykge1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdGJlbG93Kys7XG5cdFx0fVxuXHRcdGlmIChlZGl0b3IuZ2V0TGluZShiZWxvdykgPT0gJy0tLScpIHtcblx0XHRcdGJlbG93LS07XG5cdFx0fVxuXG5cdFx0d2hpbGUodHJ1ZSkge1xuXHRcdFx0aWYgKGVkaXRvci5nZXRMaW5lKGJlbG93KSA9PSAnJykge1xuXHRcdFx0XHRiZWxvdy0tO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gdGhlbiBwdXQgdGhlbSB0byBsaW5lXG5cblx0XHRsZXQgdGV4dCA9IFwiXCI7XG5cdFx0QXJyYXkuZnJvbShBcnJheShiZWxvdyAtIGFib3ZlICsgMSkua2V5cygpKS5mb3JFYWNoKGkgPT4ge1xuXHRcdFx0Y29uc3QgbGluZSA9IGVkaXRvci5nZXRMaW5lKGkgKyBhYm92ZSlcblx0XHRcdGlmICghbGluZS50cmltKCkuc3RhcnRzV2l0aChcIiUlXCIpIHx8ICFsaW5lLnRyaW0oKS5lbmRzV2l0aChcIiUlXCIpKSB7XG5cdFx0XHRcdGxldCBtb2RpZmllZExpbmUgPSBlZGl0b3IuZ2V0TGluZShpICsgYWJvdmUpXG5cdFx0XHRcdG1vZGlmaWVkTGluZSA9IG1vZGlmaWVkTGluZS5yZXBsYWNlKC9eXFxbKFteXFxbXFxdXFwoXFwpXSspXFxdXFwoW15cXFtcXF1cXChcXCldK1xcKS9nLCBcIiQxXCIpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCAgIC5yZXBsYWNlKC9bXiFdXFxbKFteXFxbXFxdXFwoXFwpXSspXFxdXFwoW15cXFtcXF1cXChcXCldK1xcKS9nLCBcIiQxXCIpXG5cdFx0XHRcdHRleHQgPSB0ZXh0ICsgbW9kaWZpZWRMaW5lICsgXCJcXG5cIlxuXHRcdFx0fVxuXHRcdH0pXG5cdFx0dGV4dCA9IHRleHQucmVwbGFjZSgvXFxuKyQvLCBcIlwiKVxuXHRcdHJldHVybiB0ZXh0XG5cdH1cblxuXHRnZXRTZWdtZW50KGVkaXRvcjogRWRpdG9yKSA6IHN0cmluZyB7XG5cdFx0bGV0IGN1cnNvciA9IGVkaXRvci5nZXRDdXJzb3IoKTtcblx0XHRsZXQgbGluZSA9IGN1cnNvci5saW5lO1xuXHRcdGxldCBhYm92ZSA9IGxpbmU7XG5cdFx0bGV0IGJlbG93ID0gbGluZTtcblx0XHQvLyBmaXJzdCBnZXQgYWJvdmVcblx0XHRcblx0XHR3aGlsZSAoYWJvdmUgPj0gMCkge1xuXHRcdFx0bGV0IGwgPSBlZGl0b3IuZ2V0TGluZShhYm92ZSk7XG5cdFx0XHRpZiAobCA9PSAnLS0tJykge1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdGFib3ZlLS07XG5cdFx0fVxuXHRcdGlmIChlZGl0b3IuZ2V0TGluZShhYm92ZSkgPT0gJy0tLScpIHtcblx0XHRcdGFib3ZlKys7XG5cdFx0fVxuXHRcdHdoaWxlKHRydWUpIHtcblx0XHRcdGlmIChlZGl0b3IuZ2V0TGluZShhYm92ZSkgPT0gJycpIHtcblx0XHRcdFx0YWJvdmUrKztcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIHRoZW4gZ2V0IGJlbG93XG5cdFx0d2hpbGUgKGJlbG93IDwgZWRpdG9yLmxpbmVDb3VudCgpKSB7XG5cdFx0XHRsZXQgbCA9IGVkaXRvci5nZXRMaW5lKGJlbG93KTtcblx0XHRcdGlmIChsID09ICctLS0nKSB7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0YmVsb3crKztcblx0XHR9XG5cdFx0aWYgKGVkaXRvci5nZXRMaW5lKGJlbG93KSA9PSAnLS0tJykge1xuXHRcdFx0YmVsb3ctLTtcblx0XHR9XG5cblx0XHR3aGlsZSh0cnVlKSB7XG5cdFx0XHRpZiAoZWRpdG9yLmdldExpbmUoYmVsb3cpID09ICcnKSB7XG5cdFx0XHRcdGJlbG93LS07XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyB0aGVuIHB1dCB0aGVtIHRvIGxpbmVcblxuXHRcdGxldCB0ZXh0ID0gXCJcIjtcblx0XHRBcnJheS5mcm9tKEFycmF5KGJlbG93IC0gYWJvdmUgKyAxKS5rZXlzKCkpLmZvckVhY2goaSA9PiB7XG5cdFx0XHRjb25zdCBsaW5lID0gZWRpdG9yLmdldExpbmUoaSArIGFib3ZlKVxuXHRcdFx0dGV4dCA9IHRleHQgKyBsaW5lICsgXCJcXG5cIlxuXHRcdH0pXG5cdFx0dGV4dCA9IHRleHQucmVwbGFjZSgvXFxuKyQvLCBcIlwiKVxuXHRcdHJldHVybiB0ZXh0XG5cdH1cblxuXHRnZXRUd2l0dGVyU2VnbWVudChlZGl0b3I6IEVkaXRvcikgOiBzdHJpbmcge1xuXHRcdGxldCBjdXJzb3IgPSBlZGl0b3IuZ2V0Q3Vyc29yKCk7XG5cdFx0bGV0IGxpbmUgPSBjdXJzb3IubGluZTtcblx0XHRsZXQgYWJvdmUgPSBsaW5lO1xuXHRcdGxldCBiZWxvdyA9IGxpbmU7XG5cdFx0Ly8gZmlyc3QgZ2V0IGFib3ZlXG5cdFx0XG5cdFx0d2hpbGUgKGFib3ZlID49IDApIHtcblx0XHRcdGxldCBsID0gZWRpdG9yLmdldExpbmUoYWJvdmUpO1xuXHRcdFx0aWYgKGwgPT0gJy0tLScpIHtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRhYm92ZS0tO1xuXHRcdH1cblx0XHRpZiAoZWRpdG9yLmdldExpbmUoYWJvdmUpID09ICctLS0nKSB7XG5cdFx0XHRhYm92ZSsrO1xuXHRcdH1cblx0XHR3aGlsZSh0cnVlKSB7XG5cdFx0XHRpZiAoZWRpdG9yLmdldExpbmUoYWJvdmUpID09ICcnKSB7XG5cdFx0XHRcdGFib3ZlKys7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyB0aGVuIGdldCBiZWxvd1xuXHRcdHdoaWxlIChiZWxvdyA8IGVkaXRvci5saW5lQ291bnQoKSkge1xuXHRcdFx0bGV0IGwgPSBlZGl0b3IuZ2V0TGluZShiZWxvdyk7XG5cdFx0XHRpZiAobCA9PSAnLS0tJykge1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdGJlbG93Kys7XG5cdFx0fVxuXHRcdGlmIChlZGl0b3IuZ2V0TGluZShiZWxvdykgPT0gJy0tLScpIHtcblx0XHRcdGJlbG93LS07XG5cdFx0fVxuXG5cdFx0d2hpbGUodHJ1ZSkge1xuXHRcdFx0aWYgKGVkaXRvci5nZXRMaW5lKGJlbG93KSA9PSAnJykge1xuXHRcdFx0XHRiZWxvdy0tO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gdGhlbiBwdXQgdGhlbSB0byBsaW5lXG5cblx0XHRsZXQgdGV4dCA9IFwiXCI7XG5cdFx0QXJyYXkuZnJvbShBcnJheShiZWxvdyAtIGFib3ZlICsgMSkua2V5cygpKS5mb3JFYWNoKGkgPT4ge1xuXHRcdFx0Y29uc3QgbGluZSA9IGVkaXRvci5nZXRMaW5lKGkgKyBhYm92ZSlcblx0XHRcdGlmICghbGluZS50cmltKCkuc3RhcnRzV2l0aChcIiUlXCIpIHx8ICFsaW5lLnRyaW0oKS5lbmRzV2l0aChcIiUlXCIpKSB7XG5cdFx0XHRcdGxldCBtb2RpZmllZExpbmUgPSBlZGl0b3IuZ2V0TGluZShpICsgYWJvdmUpXG5cdFx0XHRcdGlmICghL1xcZCtcXC9cXGQrICpcdTMwMTAuKlx1MzAxMS8udGVzdChtb2RpZmllZExpbmUpKSB7XG5cdFx0XHRcdFx0bW9kaWZpZWRMaW5lID0gbW9kaWZpZWRMaW5lLnJlcGxhY2UoL15cXFsoW15cXFtcXF1cXChcXCldKylcXF1cXChbXlxcW1xcXVxcKFxcKV0rXFwpL2csIFwiJDFcIilcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQucmVwbGFjZSgvW14hXVxcWyhbXlxcW1xcXVxcKFxcKV0rKVxcXVxcKFteXFxbXFxdXFwoXFwpXStcXCkvZywgXCIkMVwiKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC5yZXBsYWNlKC9odHRwc1teXFxuXStcXC5qcGVnL2csIFwiXCIpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0LnJlcGxhY2UoL15cXHMrJC9nLCBcIlwiKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC5yZXBsYWNlKC9eLSAvLCBcIlx1MjAyMiBcIilcblx0XHRcdFx0XHRpZiAoIS9eXFxkK1xcLiAvLnRlc3QobW9kaWZpZWRMaW5lKSAmJiAhL15cdTIwMjIgLy50ZXN0KG1vZGlmaWVkTGluZSkpIHtcblx0XHRcdFx0XHRcdG1vZGlmaWVkTGluZSA9IG1vZGlmaWVkTGluZS5yZXBsYWNlKC9cdUZGMUYoW15cdTMwMTFcdTMwMERcXG5dKS9nLCBcIlx1RkYxRlxcblxcbiQxXCIpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0LnJlcGxhY2UoL1x1MzAwMihbXlx1MzAxMVx1MzAwRFxcbl0pL2csIFwiXHUzMDAyXFxuXFxuJDFcIilcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQucmVwbGFjZSgvXHVGRjAxKFteXHUzMDExXHUzMDBEXFxuXSkvZywgXCJcdUZGMDFcXG5cXG4kMVwiKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC5yZXBsYWNlKC9cdUZGNUUoW15cdTMwMTFcdTMwMERcXG5dKS9nLCBcIlx1RkY1RVxcblxcbiQxXCIpXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHRleHQgPSB0ZXh0ICsgbW9kaWZpZWRMaW5lICsgXCJcXG5cIlxuXHRcdFx0fVxuXHRcdH0pXG5cdFx0dGV4dCA9IHRleHQucmVwbGFjZSgvXFxuKyQvLCBcIlwiKVxuXHRcdHJldHVybiB0ZXh0XG5cdH1cblxuXHRnZXRUaHJlYWRzU2VnbWVudChlZGl0b3I6IEVkaXRvcikgOiBzdHJpbmcge1xuXHRcdGxldCBjdXJzb3IgPSBlZGl0b3IuZ2V0Q3Vyc29yKCk7XG5cdFx0bGV0IGxpbmUgPSBjdXJzb3IubGluZTtcblx0XHRsZXQgYWJvdmUgPSBsaW5lO1xuXHRcdGxldCBiZWxvdyA9IGxpbmU7XG5cdFx0Ly8gZmlyc3QgZ2V0IGFib3ZlXG5cdFx0XG5cdFx0d2hpbGUgKGFib3ZlID49IDApIHtcblx0XHRcdGxldCBsID0gZWRpdG9yLmdldExpbmUoYWJvdmUpO1xuXHRcdFx0aWYgKGwgPT0gJy0tLScpIHtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRhYm92ZS0tO1xuXHRcdH1cblx0XHRpZiAoZWRpdG9yLmdldExpbmUoYWJvdmUpID09ICctLS0nKSB7XG5cdFx0XHRhYm92ZSsrO1xuXHRcdH1cblx0XHR3aGlsZSh0cnVlKSB7XG5cdFx0XHRpZiAoZWRpdG9yLmdldExpbmUoYWJvdmUpID09ICcnKSB7XG5cdFx0XHRcdGFib3ZlKys7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyB0aGVuIGdldCBiZWxvd1xuXHRcdHdoaWxlIChiZWxvdyA8IGVkaXRvci5saW5lQ291bnQoKSkge1xuXHRcdFx0bGV0IGwgPSBlZGl0b3IuZ2V0TGluZShiZWxvdyk7XG5cdFx0XHRpZiAobCA9PSAnLS0tJykge1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdGJlbG93Kys7XG5cdFx0fVxuXHRcdGlmIChlZGl0b3IuZ2V0TGluZShiZWxvdykgPT0gJy0tLScpIHtcblx0XHRcdGJlbG93LS07XG5cdFx0fVxuXG5cdFx0d2hpbGUodHJ1ZSkge1xuXHRcdFx0aWYgKGVkaXRvci5nZXRMaW5lKGJlbG93KSA9PSAnJykge1xuXHRcdFx0XHRiZWxvdy0tO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gdGhlbiBwdXQgdGhlbSB0byBsaW5lXG5cblx0XHRsZXQgdGV4dCA9IFwiXCI7XG5cdFx0QXJyYXkuZnJvbShBcnJheShiZWxvdyAtIGFib3ZlICsgMSkua2V5cygpKS5mb3JFYWNoKGkgPT4ge1xuXHRcdFx0Y29uc3QgbGluZSA9IGVkaXRvci5nZXRMaW5lKGkgKyBhYm92ZSlcblx0XHRcdGlmICghbGluZS50cmltKCkuc3RhcnRzV2l0aChcIiUlXCIpIHx8ICFsaW5lLnRyaW0oKS5lbmRzV2l0aChcIiUlXCIpKSB7XG5cdFx0XHRcdGxldCBtb2RpZmllZExpbmUgPSBlZGl0b3IuZ2V0TGluZShpICsgYWJvdmUpXG5cdFx0XHRcdGlmICghL1xcZCtcXC9cXGQrICpcdTMwMTAuKlx1MzAxMS8udGVzdChtb2RpZmllZExpbmUpKSB7XG5cdFx0XHRcdFx0bW9kaWZpZWRMaW5lID0gbW9kaWZpZWRMaW5lLnJlcGxhY2UoL1x1RDgzRVx1RERGNVsgXSsoLiopL2csIFwiXHUzMDEwJDFcdTMwMTFcIilcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQucmVwbGFjZSgvXlxcWyhbXlxcW1xcXVxcKFxcKV0rKVxcXVxcKFteXFxbXFxdXFwoXFwpXStcXCkvZywgXCIkMVwiKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC5yZXBsYWNlKC9bXiFdXFxbKFteXFxbXFxdXFwoXFwpXSspXFxdXFwoW15cXFtcXF1cXChcXCldK1xcKS9nLCBcIiQxXCIpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0LnJlcGxhY2UoLyFcXFsuKlxcXVxcKGh0dHBzW15cXG5dK1xcLmpwZWdcXCkvZywgXCJcIilcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQucmVwbGFjZSgvaHR0cHNbXlxcbl0rXFwuanBlZy9nLCBcIlwiKVx0XHRcdFx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC5yZXBsYWNlKC9eXFxzKyQvZywgXCJcIilcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQucmVwbGFjZSgvXi0gLywgXCJcdTIwMjIgXCIpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0LnJlcGxhY2UoL14jKyAvLCBcIlwiKVxuXHRcdFx0XHRcdGlmICghL15cXGQrXFwuIC8udGVzdChtb2RpZmllZExpbmUpICYmICEvXlx1MjAyMiAvLnRlc3QobW9kaWZpZWRMaW5lKSkge1xuXHRcdFx0XHRcdFx0bW9kaWZpZWRMaW5lID0gbW9kaWZpZWRMaW5lLnJlcGxhY2UoL1x1RkYxRihbXlx1MzAxMVx1MzAwRFxcbl0pL2csIFwiXHVGRjFGXFxuXFxuJDFcIilcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQucmVwbGFjZSgvXHUzMDAyKFteXHUzMDExXHUzMDBEXFxuXSkvZywgXCJcdTMwMDJcXG5cXG4kMVwiKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC5yZXBsYWNlKC9cdUZGMDEoW15cdTMwMTFcdTMwMERcXG5dKS9nLCBcIlx1RkYwMVxcblxcbiQxXCIpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0LnJlcGxhY2UoL1x1RkY1RShbXlx1MzAxMVx1MzAwRFxcbl0pL2csIFwiXHVGRjVFXFxuXFxuJDFcIilcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0dGV4dCA9IHRleHQgKyBtb2RpZmllZExpbmUgKyBcIlxcblwiXG5cdFx0XHR9XG5cdFx0fSlcblx0XHR0ZXh0ID0gdGV4dC5yZXBsYWNlKC9cXG4rJC8sIFwiXCIpXG5cdFx0cmV0dXJuIHRleHRcblx0fVxuXG5cblx0YXN5bmMgYWRkM0RheXNBY3Rpb25Ob3RlQ29udGVudCh2YXVsdDogVmF1bHQpIHtcblx0XHRjb25zdCBzY2hlZHVsZU5vdGVXaXRob3V0TWQgPSBcIkQvUXVlcnkgU2NoZWR1bGUgYW5kIEFjdGlvbnMgbmV4dCAzIGRheXNcIlxuXHRcdGNvbnN0IHNjaGVkdWxlTm90ZSA9IGAke3NjaGVkdWxlTm90ZVdpdGhvdXRNZH0ubWRgXHRcdFx0XHRcblx0XHRpZiAodmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKHNjaGVkdWxlTm90ZSkgPT0gbnVsbCkge1xuXHRcdFx0YXdhaXQgdmF1bHQuY3JlYXRlKHNjaGVkdWxlTm90ZSwgXCJcIik7XG5cdFx0fVxuXHRcdGxldCBub3RlQ29udGVudCA9ICdbW1F1ZXJ5IFNjaGVkdWxlIGFuZCBBY3Rpb25zIG5leHQgMyBkYXlzXV1cXG4nXG5cdFx0Y29uc3QgZXhjbHVkZU5vdGVzID0gW3NjaGVkdWxlTm90ZVdpdGhvdXRNZCwgXCJEL1NjaGVkdWxpbmdcIl07XG5cdFx0QXJyYXkuZnJvbShBcnJheSgzKS5rZXlzKCkpLmZvckVhY2goaSA9PiBub3RlQ29udGVudCArPSB0aGlzLmdldFF1ZXJ5RGF0ZUFuZEFjdGlvblN0cmluZyhpLCBleGNsdWRlTm90ZXMpKTtcblx0XHRjb25zdCBvdGhlckRheXMgPSB0aGlzLmdldFF1ZXJ5QWN0aW9uc1RoaXNXZWVrKDMpO1xuXHRcdG5vdGVDb250ZW50ID0gbm90ZUNvbnRlbnQgKyBgIyMgbm4gLyB3blxcblxcYFxcYFxcYHF1ZXJ5XFxudGFnOiNubiBPUiB0YWc6I3duJHtvdGhlckRheXN9XFxuXFxgXFxgXFxgXFxuXFxuIyMgdHRcXG5cXGBcXGBcXGBxdWVyeVxcbnRhZzojdHRcXG5cXGBcXGBcXGBcXG5cXG5gXG5cdFx0bm90ZUNvbnRlbnQgPSBub3RlQ29udGVudCArIHRoaXMuZ2V0UXVlcnlGdXR1cmVEYXlzVGhpc1dlZWsoXCJGdXR1cmUgRGF0ZXNcIiwgMywgNiwgZXhjbHVkZU5vdGVzKVxuXHRcdG5vdGVDb250ZW50ID0gbm90ZUNvbnRlbnQgKyB0aGlzLmdldFF1ZXJ5TmV4dDJNb250aFN0cmluZyhleGNsdWRlTm90ZXMpXG5cdFx0bm90ZUNvbnRlbnQgPSBub3RlQ29udGVudCArIHRoaXMuZ2V0UXVlcnlGdXR1cmVEYXlzVGhpc1dlZWsoXCJQYXN0IERhdGVzXCIsIC03LCAtMSwgZXhjbHVkZU5vdGVzKVxuXHRcdC8vIG5vdGVDb250ZW50ID0gbm90ZUNvbnRlbnQgKyBgXFxuXFxuW1tRdWVyeSBTY2hlZHVsZSBhbmQgQWN0aW9ucyBuZXh0IDMgZGF5c11dYFxuXHRcdHZhdWx0Lm1vZGlmeSh2YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgoc2NoZWR1bGVOb3RlKSBhcyBURmlsZSwgbm90ZUNvbnRlbnQpO1xuXHR9XG5cblx0YXN5bmMgYWRkQWN0aW9uTm90ZUNvbnRlbnQodmF1bHQ6IFZhdWx0LCBmb2xkZXJOYW1lOiBTdHJpbmcsIG5vdGVUaXRsZVdpdGhvdXRNZDogU3RyaW5nLCBzY2hlZHVsZU5vdGVUaXRsZVdpdGhvdXRNZDogU3RyaW5nLCBuT3JXOiBTdHJpbmcpIHtcblx0XHRjb25zdCBub3dBY3Rpb25Ob3RlV2l0aG91dE1kID0gYCR7Zm9sZGVyTmFtZX0vJHtub3RlVGl0bGVXaXRob3V0TWR9YFxuXHRcdGNvbnN0IG5vd0FjdGlvbk5vdGUgPSBgJHtub3dBY3Rpb25Ob3RlV2l0aG91dE1kfS5tZGBcdFx0XHRcdFxuXHRcdGlmICh2YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgobm93QWN0aW9uTm90ZSkgPT0gbnVsbCkge1xuXHRcdFx0YXdhaXQgdmF1bHQuY3JlYXRlKG5vd0FjdGlvbk5vdGUsIFwiXCIpO1xuXHRcdH1cblx0XHRsZXQgbm93QWN0aW9uTm90ZUNvbnRlbnQgPSAnJ1xuXHRcdEFycmF5LmZyb20oQXJyYXkoMikua2V5cygpKS5mb3JFYWNoKGkgPT4gbm93QWN0aW9uTm90ZUNvbnRlbnQgKz0gdGhpcy5nZXRRdWVyeUFjdGlvblN0cmluZyhpLCBuT3JXKSk7XG5cdFx0bm93QWN0aW9uTm90ZUNvbnRlbnQgKz0gYFxcYFxcYFxcYHF1ZXJ5XFxudGFnOiMke25Pcld9dFxcblxcYFxcYFxcYFxcbmBcblx0XHRub3dBY3Rpb25Ob3RlQ29udGVudCArPSBgXFxgXFxgXFxgcXVlcnlcXG5gXG5cdFx0QXJyYXkuZnJvbShBcnJheSg1KS5rZXlzKCkpLmZvckVhY2goaSA9PiBub3dBY3Rpb25Ob3RlQ29udGVudCArPSB0aGlzLmdldFF1ZXJ5V2Vla0RheShpICsgMiwgbk9yVykpO1xuXHRcdG5vd0FjdGlvbk5vdGVDb250ZW50ICs9IGB0YWc6IyR7bk9yV31uXFxuXFxgXFxgXFxgXFxuYFxuXHRcdG5vd0FjdGlvbk5vdGVDb250ZW50ICs9IGBTY2hlZHVsaW5nOiBbWyR7c2NoZWR1bGVOb3RlVGl0bGVXaXRob3V0TWR9XV1cXG5gXG5cdFx0bm93QWN0aW9uTm90ZUNvbnRlbnQgKz0gYFtbJHtub3RlVGl0bGVXaXRob3V0TWR9XV1cXG5gXG5cblx0XHR2YXVsdC5tb2RpZnkodmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKG5vd0FjdGlvbk5vdGUpIGFzIFRGaWxlLCBub3dBY3Rpb25Ob3RlQ29udGVudCk7XG5cdH1cblxuXHRnZXRRdWVyeURhdGVBbmRBY3Rpb25TdHJpbmcoYWRkRGF5OiBudW1iZXIsIGV4Y2x1ZGVOb3RlczogU3RyaW5nW10pOiBzdHJpbmcge1xuXHRcdGNvbnN0IGRhdGVNb21lbnQgPSBtb21lbnQoKS5hZGQoYWRkRGF5LCAnZCcpO1xuXHRcdGNvbnN0IGRhdGVZWVlZTU1ERCA9IGRhdGVNb21lbnQuZm9ybWF0KCdZWVlZTU1ERCcpO1xuXHRcdGNvbnN0IGRhdGVFYWNoWVlERCA9ICdcXFxcZFxcXFxkXFxcXGRcXFxcZCcgKyBkYXRlTW9tZW50LmZvcm1hdCgnTU1ERCcpO1xuXHRcdGNvbnN0IGRhdGVFYWNoREQgPSAnXFxcXGRcXFxcZFxcXFxkXFxcXGRcXFxcZFxcXFxkJyArIGRhdGVNb21lbnQuZm9ybWF0KCdERCcpO1xuXHRcdGNvbnN0IGRheU9mV2VlayA9IGRhdGVNb21lbnQuZm9ybWF0KCdFJyk7XG5cdFx0Y29uc3QgZGF5T2ZXZWVrTG9uZyA9IGRhdGVNb21lbnQuZm9ybWF0KCdkZGQnKTtcblx0XHRjb25zdCBleGNsdWRlTm90ZVN0ciA9IGV4Y2x1ZGVOb3Rlcy5tYXAoZXhjbHVkZU5vdGUgPT4gYC1wYXRoOlwiJHtleGNsdWRlTm90ZX1cIiBgKS5qb2luKFwiXCIpXG5cdFx0cmV0dXJuIGAjIyAke2RhdGVZWVlZTU1ERH0gJHtkYXlPZldlZWtMb25nfVxcblxcYFxcYFxcYHF1ZXJ5XFxuKFwiICR7ZGF0ZVlZWVlNTUREfVwiIE9SIFwiJHtkYXRlWVlZWU1NRER9IFwiIE9SICR7ZGF0ZUVhY2hZWUREfSBPUiAke2RhdGVFYWNoRER9IE9SIHRhZzojbiR7ZGF5T2ZXZWVrfSBPUiB0YWc6I3cke2RheU9mV2Vla30pICR7ZXhjbHVkZU5vdGVTdHJ9LWJsb2NrOihxdWVyeSlcXG5cXGBcXGBcXGBcXG5cXG5gXG5cdH1cblxuXHRnZXRRdWVyeUFjdGlvbnNUaGlzV2VlayhleGNsdWRlTnVtRGF5czogTnVtYmVyKTogc3RyaW5nIHtcblx0XHRsZXQgZXhjbHVkZXMgOiBudW1iZXJbXSA9IFtdXG5cdFx0bGV0IGluY2x1ZGVzIDogbnVtYmVyW10gPSBbMSwgMiwgMywgNCwgNSwgNiwgN11cblx0XHRcblx0XHRBcnJheS5mcm9tKEFycmF5KGV4Y2x1ZGVOdW1EYXlzKS5rZXlzKCkpLmZvckVhY2goaSA9PiB7XG5cdFx0XHRjb25zdCBkYXRlTW9tZW50ID0gbW9tZW50KCkuYWRkKGksICdkJyk7XG5cdFx0XHRjb25zdCBkYXlPZldlZWsgPSBwYXJzZUludChkYXRlTW9tZW50LmZvcm1hdCgnRScpKTtcblx0XHRcdGV4Y2x1ZGVzLnB1c2goZGF5T2ZXZWVrKVxuXHRcdH0pXG5cdFx0bGV0IGFhYSA9IGluY2x1ZGVzLmZpbHRlcihpID0+IHtcblx0XHRcdGZvciAoY29uc3QgZSBvZiBleGNsdWRlcylcblx0XHRcdHtcblx0XHRcdFx0aWYgKGUgPT0gaSlcblx0XHRcdFx0e1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHJ1ZVxuXHRcdH0pXG5cdFx0bGV0IG91dHB1dCA9IFwiXCJcblx0XHRhYWEuZm9yRWFjaChpID0+IG91dHB1dCArPSBgIE9SIHRhZzojbiR7aX0gT1IgdGFnOiN3JHtpfWApXG5cdFx0cmV0dXJuIG91dHB1dFxuXHR9XG5cblx0Z2V0UXVlcnlGdXR1cmVEYXlzVGhpc1dlZWsoaGVhZGVyOiBTdHJpbmcsIGZyb206IG51bWJlciwgdG86IG51bWJlciwgZXhjbHVkZU5vdGVzOiBTdHJpbmdbXSk6IHN0cmluZyB7XG5cdFx0bGV0IGluY2x1ZGVzID0gW11cblx0XHRmb3IgKGxldCBpID0gZnJvbTsgaSA8PSB0bzsgaSsrKSB7XG5cdFx0XHRsZXQgZGF0ZU1vbWVudCA9IG1vbWVudCgpLmFkZChpLCAnZCcpO1xuXHRcdFx0aW5jbHVkZXMucHVzaChkYXRlTW9tZW50KVxuXHRcdH1cblx0XHRsZXQgb3V0cHV0ID0gYCMjICR7aGVhZGVyfVxcblxcYFxcYFxcYHF1ZXJ5XFxuKGBcblx0XHRpbmNsdWRlcy5mb3JFYWNoKGkgPT4ge1xuXHRcdFx0Y29uc3QgZGF0ZVlZWVlNTUREID0gaS5mb3JtYXQoJ1lZWVlNTUREJyk7XG5cdFx0XHRjb25zdCBkYXRlRWFjaFlZREQgPSAnXFxcXGRcXFxcZFxcXFxkXFxcXGQnICsgaS5mb3JtYXQoJ01NREQnKTtcblx0XHRcdGNvbnN0IGRhdGVFYWNoREQgPSAnXFxcXGRcXFxcZFxcXFxkXFxcXGRcXFxcZFxcXFxkJyArIGkuZm9ybWF0KCdERCcpO1xuXHRcdFx0b3V0cHV0ICs9IGBcIiAke2RhdGVZWVlZTU1ERH1cIiBPUiBcIiR7ZGF0ZVlZWVlNTUREfSBcIiBPUiAke2RhdGVFYWNoWVlERH0gT1IgJHtkYXRlRWFjaEREfSBPUiBgXG5cdFx0fSlcblx0XHRvdXRwdXQgPSBvdXRwdXQucmVwbGFjZSgvIE9SICQvLCBcIlwiKVxuXHRcdG91dHB1dCArPSBcIilcIlxuXHRcdGNvbnN0IGV4Y2x1ZGVOb3RlU3RyID0gZXhjbHVkZU5vdGVzLm1hcChleGNsdWRlTm90ZSA9PiBgLXBhdGg6XCIke2V4Y2x1ZGVOb3RlfVwiIGApLmpvaW4oXCJcIilcblx0XHRvdXRwdXQgKz0gYCAke2V4Y2x1ZGVOb3RlU3RyfS1ibG9jazoocXVlcnkpYFxuXHRcdG91dHB1dCArPSBgXFxuXFxgXFxgXFxgXFxuXFxuYFxuXHRcdHJldHVybiBvdXRwdXRcblx0fVxuXG5cdGdldFF1ZXJ5TmV4dDJNb250aFN0cmluZyhleGNsdWRlTm90ZXM6IFN0cmluZ1tdKTogc3RyaW5nIHtcblx0XHRjb25zdCBjdXJyZW50TW9udGhZWVlZTU0gPSBtb21lbnQoKS5mb3JtYXQoJ1lZWVlNTScpO1xuXHRcdGNvbnN0IGRhdGVNb21lbnQgPSBtb21lbnQoKS5hZGQoMSwgJ00nKTtcblx0XHRjb25zdCBuZXh0TW9udGhZWVlZTU0gPSBkYXRlTW9tZW50LmZvcm1hdCgnWVlZWU1NJyk7XG5cdFx0Y29uc3QgZXhjbHVkZU5vdGVTdHIgPSBleGNsdWRlTm90ZXMubWFwKGV4Y2x1ZGVOb3RlID0+IGAtcGF0aDpcIiR7ZXhjbHVkZU5vdGV9XCIgYCkuam9pbihcIlwiKVxuXHRcdHJldHVybiBgIyMgJHtjdXJyZW50TW9udGhZWVlZTU19IGFuZCAke25leHRNb250aFlZWVlNTX1cXG5cXGBcXGBcXGBxdWVyeVxcbigke2N1cnJlbnRNb250aFlZWVlNTX1cXFxcZFxcXFxkIE9SICR7bmV4dE1vbnRoWVlZWU1NfVxcXFxkXFxcXGQgJHtleGNsdWRlTm90ZVN0cn0tcGF0aDpcIkQvU2NoZWR1bGluZ1wiIC1ibG9jazoocXVlcnkpXFxuXFxgXFxgXFxgXFxuXFxuYFxuXHR9XG5cblx0Z2V0UXVlcnlEYXRlU3RyaW5nKGFkZERheTogbnVtYmVyLCBleGNsdWRlTm90ZTogU3RyaW5nKTogc3RyaW5nIHtcblx0XHRjb25zdCBkYXRlTW9tZW50ID0gbW9tZW50KCkuYWRkKGFkZERheSwgJ2QnKTtcblx0XHRjb25zdCBkYXRlWVlZWU1NREQgPSBkYXRlTW9tZW50LmZvcm1hdCgnWVlZWU1NREQnKTtcblx0XHRjb25zdCBkYXRlRWFjaFlZREQgPSAnXFxcXGRcXFxcZFxcXFxkXFxcXGQnICsgZGF0ZU1vbWVudC5mb3JtYXQoJ01NREQnKTtcblx0XHRjb25zdCBkYXRlRWFjaEREID0gJ1xcXFxkXFxcXGRcXFxcZFxcXFxkXFxcXGRcXFxcZCcgKyBkYXRlTW9tZW50LmZvcm1hdCgnREQnKTtcblx0XHRyZXR1cm4gYCR7ZGF0ZVlZWVlNTUREfVxcblxcYFxcYFxcYHF1ZXJ5XFxuKCR7ZGF0ZVlZWVlNTUREfSBPUiAke2RhdGVFYWNoWVlERH0gT1IgJHtkYXRlRWFjaEREfSkgLXBhdGg6XCIke2V4Y2x1ZGVOb3RlfVwiIC1ibG9jazoocXVlcnkpXFxuXFxgXFxgXFxgXFxuYFxuXHR9XG5cblx0Z2V0UXVlcnlBY3Rpb25TdHJpbmcoYWRkRGF5OiBudW1iZXIsIGFjdGlvblR5cGU6IFN0cmluZyk6IHN0cmluZyB7XG5cdFx0Y29uc3QgZGF0ZU1vbWVudCA9IG1vbWVudCgpLmFkZChhZGREYXksICdkJyk7XG5cdFx0Y29uc3QgZGF5T2ZXZWVrID0gZGF0ZU1vbWVudC5mb3JtYXQoJ0UnKTtcblx0XHRyZXR1cm4gYFxcYFxcYFxcYHF1ZXJ5XFxudGFnOiMke2FjdGlvblR5cGV9JHtkYXlPZldlZWt9XFxuXFxgXFxgXFxgXFxuYFxuXHR9XG5cblx0Z2V0UXVlcnlXZWVrRGF5KGFkZERheTogbnVtYmVyLCBhY3Rpb25UeXBlOiBTdHJpbmcpOiBzdHJpbmcge1xuXHRcdGNvbnN0IGRhdGVNb21lbnQgPSBtb21lbnQoKS5hZGQoYWRkRGF5LCAnZCcpO1xuXHRcdGNvbnN0IGRheU9mV2VlayA9IGRhdGVNb21lbnQuZm9ybWF0KCdFJyk7XG5cdFx0cmV0dXJuIGB0YWc6IyR7YWN0aW9uVHlwZX0ke2RheU9mV2Vla30gT1IgYFxuXHR9XG5cdCAgXG5cdGFkZE5ld0xhdGVyQWN0aW9uSWNvbih0OiBzdHJpbmcpIHtcblx0XHR0aGlzLmFkZE9ic2lkaWFuSWNvbihgJHt0fWwtaWNvbi1uZXdgLCBgJHt0fWxgKTtcblx0fVxuXHQgIFxuXHRhZGRBY3Rpb25JY29uKHQ6IHN0cmluZykge1xuXHRcdHRoaXMuYWRkT2JzaWRpYW5JY29uKGAke3R9LWljb25gLCBgIyR7dH1gKTtcblx0fVxuXG5cdGFkZE9ic2lkaWFuSWNvbihpY29uTmFtZTogc3RyaW5nLCBpY29uVGV4dDogc3RyaW5nKSB7XG5cdFx0Y29uc3Qgc3ZnID0gYDx0ZXh0IHN0cm9rZT0nIzAwMCcgdHJhbnNmb3JtPSdtYXRyaXgoMi43OTE2NyAwIDAgMi4xMjY2MyAtMzQuMDQxNyAtMjUuMjA4NCknIHhtbDpzcGFjZT0ncHJlc2VydmUnIHRleHQtYW5jaG9yPSdzdGFydCcgZm9udC1mYW1pbHk9J21vbm9zcGFjZScgZm9udC1zaXplPScyNCcgeT0nNDQnIHg9JzE5JyBzdHJva2Utd2lkdGg9JzAnIGZpbGw9J2N1cnJlbnRDb2xvcic+JHtpY29uVGV4dH08L3RleHQ+YDtcblx0XHRhZGRJY29uKGljb25OYW1lLCBzdmcpO1xuXHR9XG5cblx0YWRkTmV3TGF0ZXJBY3Rpb24odDogc3RyaW5nKSB7XG5cdFx0dGhpcy5hZGRDb21tYW5kKHtcblx0XHRcdGlkOiBgYWRkLW5ldy0ke3R9LWxhdGVyLWFjdGlvbmAsXG5cdFx0XHRuYW1lOiBgQWRkICR7dH1sIHRhc2tgLFxuXHRcdFx0aWNvbjogYCR7dH1sLWljb24tbmV3YCxcblx0XHRcdGVkaXRvckNhbGxiYWNrOiAoZWRpdG9yOiBFZGl0b3IsIHZpZXc6IE1hcmtkb3duVmlldykgPT4ge1xuXHRcdFx0XHRjb25zdCBjdXJzb3IgPSBlZGl0b3IuZ2V0Q3Vyc29yKCk7XG5cdFx0XHRcdGVkaXRvci5yZXBsYWNlUmFuZ2UoYCMke3R9bCBgLCBjdXJzb3IpO1xuXHRcdFx0XHRjdXJzb3IuY2ggPSBjdXJzb3IuY2ggKyA0O1xuXHRcdFx0XHRlZGl0b3Iuc2V0Q3Vyc29yKGN1cnNvcik7XG5cdFx0XHR9LyosXG5cdFx0XHRob3RrZXlzOiBbXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRtb2RpZmllcnM6IFtgQ3RybGAsIGBNZXRhYCwgYFNoaWZ0YF0sXG5cdFx0XHRcdFx0a2V5OiB0ID09ICduJyA/ICcxJyA6ICcyJ1xuXHRcdFx0XHR9LFxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bW9kaWZpZXJzOiBbYEN0cmxgLCBgQWx0YCwgYFNoaWZ0YF0sXG5cdFx0XHRcdFx0a2V5OiB0ID09ICduJyA/ICcxJyA6ICcyJ1xuXHRcdFx0XHR9XG5cdFx0XHRdKi9cblx0XHR9KTtcblx0fVxuXG5cdGFkZEFjdGlvbkNvbW1hbmQodDogc3RyaW5nKSB7XG5cdFx0dGhpcy5hZGRDb21tYW5kKHtcblx0XHRcdGlkOiBgdG8tdyR7dH0tbiR7dH1gLFxuXHRcdFx0bmFtZTogYFRvIHcke3R9IG9yIG4ke3R9YCxcblx0XHRcdGljb246IGAke3R9LWljb25gLFxuXHRcdFx0ZWRpdG9yQ2FsbGJhY2s6IChlZGl0b3I6IEVkaXRvciwgdmlldzogTWFya2Rvd25WaWV3KSA9PiB7XG5cdFx0XHRcdGNvbnN0IGN1cnNvciA9IGVkaXRvci5nZXRDdXJzb3IoKTtcblx0XHRcdFx0Y29uc3QgbGluZU51bWJlciA9IGVkaXRvci5nZXRDdXJzb3IoKS5saW5lO1xuXHRcdFx0XHRjb25zdCBsaW5lID0gZWRpdG9yLmdldExpbmUobGluZU51bWJlcik7XG5cdFx0XHRcdGNvbnN0IHJlcGxhY2VkTGluZSA9IGxpbmUucmVwbGFjZSgvIGFcXC93XFwvLi8sIGAgYS93LyR7dH1gKVxuXHRcdFx0XHQgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLyBhXFwvblxcLy4vLCBgIGEvbi8ke3R9YClcblx0XHRcdFx0XHRcdFx0XHQgXHQgXHQgLnJlcGxhY2UoLyN3LiAvLCBgI3cke3R9IGApXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCAucmVwbGFjZSgvI24uIC8sIGAjbiR7dH0gYClcblx0XHRcdFx0XHRcdFx0XHRcdFx0IC5yZXBsYWNlKC8jdy4kLywgYCN3JHt0fWApXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCAucmVwbGFjZSgvI24uJC8sIGAjbiR7dH1gKVxuXHRcdFx0XHRpZiAobGluZS5jb250YWlucyhgI24ke3R9IGApIHx8IGxpbmUuY29udGFpbnMoYCN3JHt0fSBgKSkge1xuXHRcdFx0XHRcdGNvbnN0IG50ID0gYCNuJHt0fSBgXG5cdFx0XHRcdFx0Y29uc3Qgd3QgPSBgI3cke3R9IGBcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRjb25zdCByZXBsYWNlTGluZVRvUmVtb3ZlVGFnID0gbGluZS5yZXBsYWNlKGAjbiR7dH0gYCwgYGApLnJlcGxhY2UoYCN3JHt0fSBgLCBgYClcblx0XHRcdFx0XHRlZGl0b3Iuc2V0TGluZShsaW5lTnVtYmVyLCByZXBsYWNlTGluZVRvUmVtb3ZlVGFnKTtcblx0XHRcdFx0XHQvLyBsZXRzIHNheSBcIiNudCBcIiBpcyBhdCAzIChjaGFyIGZvciAjKVxuXHRcdFx0XHRcdC8vIGlmIGNoIDw9IDMgbm8gbmVlZCB0byB1cGRhdGVcblx0XHRcdFx0XHQvLyBpZiBjaCA+PSA3IHRoZW4gbmVlZCB0byAtNFxuXHRcdFx0XHRcdC8vIGVsc2UgY2ggPT0gM1xuXHRcdFx0XHRcdGNvbnN0IG50SW5kZXggPSBsaW5lLmluZGV4T2YobnQpXG5cdFx0XHRcdFx0Y29uc3Qgd3RJbmRleCA9IGxpbmUuaW5kZXhPZih3dClcblx0XHRcdFx0XHRjb25zdCBpbmRleCA9IG50SW5kZXggPT0gLTEgPyB3dEluZGV4IDogbnRJbmRleFxuXHRcdFx0XHRcdGNvbnN0IG5ld0NoID0gY3Vyc29yLmNoIDw9IGluZGV4ID8gY3Vyc29yLmNoIDogKGN1cnNvci5jaCA+PSBpbmRleCArIDQgPyBjdXJzb3IuY2ggLSA0IDogaW5kZXgpXG5cdFx0XHRcdFx0Y3Vyc29yLmNoID0gbmV3Q2hcblx0XHRcdFx0XHRlZGl0b3Iuc2V0Q3Vyc29yKGN1cnNvcik7XG5cdFx0XHRcdH0gZWxzZSBpZiAobGluZS5jb250YWlucyhgICNuJHt0fWApIHx8IGxpbmUuY29udGFpbnMoYCAjdyR7dH1gKSkge1xuXHRcdFx0XHRcdGNvbnN0IG50ID0gYCNuJHt0fSBgXG5cdFx0XHRcdFx0Y29uc3Qgd3QgPSBgI3cke3R9IGBcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRjb25zdCByZXBsYWNlTGluZVRvUmVtb3ZlVGFnID0gbGluZS5yZXBsYWNlKGAgI24ke3R9YCwgYGApLnJlcGxhY2UoYCAjdyR7dH1gLCBgYClcblx0XHRcdFx0XHRlZGl0b3Iuc2V0TGluZShsaW5lTnVtYmVyLCByZXBsYWNlTGluZVRvUmVtb3ZlVGFnKTtcblx0XHRcdFx0XHQvLyBsZXRzIHNheSBcIiNudCBcIiBpcyBhdCAzIChjaGFyIGZvciAjKVxuXHRcdFx0XHRcdC8vIGlmIGNoIDw9IDMgbm8gbmVlZCB0byB1cGRhdGVcblx0XHRcdFx0XHQvLyBpZiBjaCA+PSA3IHRoZW4gbmVlZCB0byAtNFxuXHRcdFx0XHRcdC8vIGVsc2UgY2ggPT0gM1xuXHRcdFx0XHRcdGNvbnN0IG50SW5kZXggPSBsaW5lLmluZGV4T2YobnQpXG5cdFx0XHRcdFx0Y29uc3Qgd3RJbmRleCA9IGxpbmUuaW5kZXhPZih3dClcblx0XHRcdFx0XHRjb25zdCBpbmRleCA9IG50SW5kZXggPT0gLTEgPyB3dEluZGV4IDogbnRJbmRleFxuXHRcdFx0XHRcdGNvbnN0IG5ld0NoID0gY3Vyc29yLmNoIDw9IGluZGV4ID8gY3Vyc29yLmNoIDogKGN1cnNvci5jaCA+PSBpbmRleCArIDQgPyBjdXJzb3IuY2ggLSA0IDogaW5kZXgpXG5cdFx0XHRcdFx0Y3Vyc29yLmNoID0gbmV3Q2hcblx0XHRcdFx0XHRlZGl0b3Iuc2V0Q3Vyc29yKGN1cnNvcik7XG5cdFx0XHRcdH0gZWxzZSBpZiAobGluZS5jb250YWlucyhgIGEvbi8ke3R9YCkgfHwgbGluZS5jb250YWlucyhgIGEvdy8ke3R9YCkpIHtcblx0XHRcdFx0XHQvLyBkbyBub3RoaW5nXG5cdFx0XHRcdH0gZWxzZSBpZiAocmVwbGFjZWRMaW5lID09IGxpbmUpIHsgLy8gbm8gdGFnLCB0byBhZGQgdGFnXG5cdFx0XHRcdFx0bGV0IHsgZnJvbnRtYXR0ZXIgfSA9IGFwcC5tZXRhZGF0YUNhY2hlLmdldEZpbGVDYWNoZSh2aWV3LmZpbGUpIHx8IHt9O1xuICAgIFx0XHRcdFx0Y29uc3QgZm10YWdzID0gKHBhcnNlRnJvbnRNYXR0ZXJUYWdzKGZyb250bWF0dGVyKSB8fCBbXSk7XG5cdFx0XHRcdFx0Zm9yIChjb25zdCB0YWcgb2YgZm10YWdzKSB7XG5cdFx0XHRcdFx0XHRpZiAodGFnLmNvbnRhaW5zKGAjYS93L2ApKSB7XG5cdFx0XHRcdFx0XHRcdGxldCBtb2RpZmllZExpbmUgPSBsaW5lO1xuXHRcdFx0XHRcdFx0XHRpZiAoL15cXHQqLSAvLnRlc3QobGluZSkpIHtcblx0XHRcdFx0XHRcdFx0ICBtb2RpZmllZExpbmUgPSBsaW5lLnJlcGxhY2UoL14oXFx0Ki0gKS8sIGAkMSN3JHt0fSBgKTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmICgvXlxcdCpcXGQrXFwuIC8udGVzdChsaW5lKSkge1xuXHRcdFx0XHRcdFx0XHQgIG1vZGlmaWVkTGluZSA9IGxpbmUucmVwbGFjZSgvXihcXHQqXFxkK1xcLiApLywgYCQxdyR7dH0gYCk7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdCAgbW9kaWZpZWRMaW5lID0gbGluZS5yZXBsYWNlKC9eLywgYCN3JHt0fSBgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRlZGl0b3Iuc2V0TGluZShjdXJzb3IubGluZSwgbW9kaWZpZWRMaW5lKTtcblx0XHRcdFx0XHRcdFx0Y3Vyc29yLmNoID0gY3Vyc29yLmNoICsgNDtcblx0XHRcdFx0XHRcdFx0ZWRpdG9yLnNldEN1cnNvcihjdXJzb3IpO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm5cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmICh0YWcuY29udGFpbnMoYCNhL24vYCkpIHtcblx0XHRcdFx0XHRcdFx0bGV0IG1vZGlmaWVkTGluZSA9IGxpbmU7XG5cdFx0XHRcdFx0XHRcdGlmICgvXlxcdCotIC8udGVzdChsaW5lKSkge1xuXHRcdFx0XHRcdFx0XHQgIG1vZGlmaWVkTGluZSA9IGxpbmUucmVwbGFjZSgvXihcXHQqLSApLywgYCQxI24ke3R9IGApO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKC9eXFx0KlxcZCtcXC4gLy50ZXN0KGxpbmUpKSB7XG5cdFx0XHRcdFx0XHRcdCAgbW9kaWZpZWRMaW5lID0gbGluZS5yZXBsYWNlKC9eKFxcdCpcXGQrXFwuICkvLCBgJDFuJHt0fSBgKTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0ICBtb2RpZmllZExpbmUgPSBsaW5lLnJlcGxhY2UoL14vLCBgI24ke3R9IGApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGVkaXRvci5zZXRMaW5lKGN1cnNvci5saW5lLCBtb2RpZmllZExpbmUpO1xuXHRcdFx0XHRcdFx0XHRjdXJzb3IuY2ggPSBjdXJzb3IuY2ggKyA0O1xuXHRcdFx0XHRcdFx0XHRlZGl0b3Iuc2V0Q3Vyc29yKGN1cnNvcik7XG5cdFx0XHRcdFx0XHRcdHJldHVyblxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRuZXcgQWRkVGFza1RhZ01vZGFsKHRoaXMuYXBwLCBlZGl0b3IsIHQpLm9wZW4oKTtcblx0XHRcdFx0fSBlbHNlIHtcdFx0XHQgXG5cdFx0XHRcdFx0ZWRpdG9yLnNldExpbmUobGluZU51bWJlciwgcmVwbGFjZWRMaW5lKTtcblx0XHRcdFx0XHRlZGl0b3Iuc2V0Q3Vyc29yKGN1cnNvcik7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRob3RrZXlzOiBbXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRtb2RpZmllcnM6IHRoaXMuaXMxVG83KHQpID8gW2BDdHJsYCwgYE1ldGFgXSA6IFtgQ3RybGAsIGBNZXRhYCwgYFNoaWZ0YF0sXG5cdFx0XHRcdFx0a2V5OiBgJHt0fWAsXG5cdFx0XHRcdH0sXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRtb2RpZmllcnM6IHRoaXMuaXMxVG83KHQpID8gW2BDdHJsYCwgYEFsdGBdIDogW2BDdHJsYCwgYEFsdGAsIGBTaGlmdGBdLFxuXHRcdFx0XHRcdGtleTogYCR7dH1gLFxuXHRcdFx0XHR9XG5cdFx0XHRdXG5cdFx0fSk7XG5cdH1cblxuXHRhZGRGb2xsb3dVcENvbW1hbmQodDogc3RyaW5nKSB7XG5cdFx0bGV0IG5hbWUgPSBcIlwiXG5cdFx0aWYgKHQgPT09ICd0Jykge1xuXHRcdFx0bmFtZSA9ICdUbyBUcnknXG5cdFx0fSBlbHNlIGlmICh0ID09PSAnZScpIHtcblx0XHRcdG5hbWUgPSAnVG8gRXhwbG9yZSdcblx0XHR9IGVsc2UgaWYgKHQgPT09ICdtJykge1xuXHRcdFx0bmFtZSA9ICdUbyBNb3ZlJ1xuXHRcdH1cblx0XHR0aGlzLmFkZENvbW1hbmQoe1xuXHRcdFx0aWQ6IGB0by10JHt0fWAsXG5cdFx0XHRuYW1lOiBgVG8gdCR7dH0gJHtuYW1lfWAsXG5cdFx0XHRpY29uOiBgJHt0fS1pY29uYCxcblx0XHRcdGVkaXRvckNhbGxiYWNrOiAoZWRpdG9yOiBFZGl0b3IsIHZpZXc6IE1hcmtkb3duVmlldykgPT4ge1xuXHRcdFx0XHRjb25zb2xlLmxvZyhlZGl0b3IuZ2V0U2VsZWN0aW9uKCkpO1xuXHRcdFx0XHRjb25zdCBjdXJzb3IgPSBlZGl0b3IuZ2V0Q3Vyc29yKCk7XG5cdFx0XHRcdGNvbnN0IGxpbmVOdW1iZXIgPSBlZGl0b3IuZ2V0Q3Vyc29yKCkubGluZTtcblx0XHRcdFx0Y29uc3QgbGluZSA9IGVkaXRvci5nZXRMaW5lKGxpbmVOdW1iZXIpO1xuXHRcdFx0XHRjb25zdCByZXBsYWNlZExpbmUgPSBsaW5lLnJlcGxhY2UoLyN0LiAvLCBgI3Qke3R9IGApXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCAucmVwbGFjZSgvI3QuJC8sIGAjdCR7dH1gKVxuXHRcdFx0XHRpZiAobGluZS5jb250YWlucyhgI3Qke3R9IGApKSB7XG5cdFx0XHRcdFx0Y29uc3QgdHQgPSBgI3Qke3R9IGBcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRjb25zdCByZXBsYWNlTGluZVRvUmVtb3ZlVGFnID0gbGluZS5yZXBsYWNlKGAjdCR7dH0gYCwgYGApXG5cdFx0XHRcdFx0ZWRpdG9yLnNldExpbmUobGluZU51bWJlciwgcmVwbGFjZUxpbmVUb1JlbW92ZVRhZyk7XG5cdFx0XHRcdFx0Ly8gbGV0cyBzYXkgXCIjdHQgXCIgaXMgYXQgMyAoY2hhciBmb3IgIylcblx0XHRcdFx0XHQvLyBpZiBjaCA8PSAzIG5vIG5lZWQgdG8gdXBkYXRlXG5cdFx0XHRcdFx0Ly8gaWYgY2ggPj0gNyB0aGVuIG5lZWQgdG8gLTRcblx0XHRcdFx0XHQvLyBlbHNlIGNoID09IDNcblx0XHRcdFx0XHRjb25zdCB0dEluZGV4ID0gbGluZS5pbmRleE9mKHR0KVxuXHRcdFx0XHRcdGNvbnN0IGluZGV4ID0gdHRJbmRleFxuXHRcdFx0XHRcdGNvbnN0IG5ld0NoID0gY3Vyc29yLmNoIDw9IGluZGV4ID8gY3Vyc29yLmNoIDogKGN1cnNvci5jaCA+PSBpbmRleCArIDQgPyBjdXJzb3IuY2ggLSA0IDogaW5kZXgpXG5cdFx0XHRcdFx0Y3Vyc29yLmNoID0gbmV3Q2hcblx0XHRcdFx0XHRlZGl0b3Iuc2V0Q3Vyc29yKGN1cnNvcik7XG5cdFx0XHRcdH0gZWxzZSBpZiAobGluZS5jb250YWlucyhgICN0JHt0fWApKSB7XG5cdFx0XHRcdFx0Y29uc3QgdHQgPSBgI3Qke3R9IGBcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRjb25zdCByZXBsYWNlTGluZVRvUmVtb3ZlVGFnID0gbGluZS5yZXBsYWNlKGAgI3Qke3R9YCwgYGApXG5cdFx0XHRcdFx0ZWRpdG9yLnNldExpbmUobGluZU51bWJlciwgcmVwbGFjZUxpbmVUb1JlbW92ZVRhZyk7XG5cdFx0XHRcdFx0Ly8gbGV0cyBzYXkgXCIjdHQgXCIgaXMgYXQgMyAoY2hhciBmb3IgIylcblx0XHRcdFx0XHQvLyBpZiBjaCA8PSAzIG5vIG5lZWQgdG8gdXBkYXRlXG5cdFx0XHRcdFx0Ly8gaWYgY2ggPj0gNyB0aGVuIG5lZWQgdG8gLTRcblx0XHRcdFx0XHQvLyBlbHNlIGNoID09IDNcblx0XHRcdFx0XHRjb25zdCB0dEluZGV4ID0gbGluZS5pbmRleE9mKHR0KVxuXHRcdFx0XHRcdGNvbnN0IGluZGV4ID0gdHRJbmRleFxuXHRcdFx0XHRcdGNvbnN0IG5ld0NoID0gY3Vyc29yLmNoIDw9IGluZGV4ID8gY3Vyc29yLmNoIDogKGN1cnNvci5jaCA+PSBpbmRleCArIDQgPyBjdXJzb3IuY2ggLSA0IDogaW5kZXgpXG5cdFx0XHRcdFx0Y3Vyc29yLmNoID0gbmV3Q2hcblx0XHRcdFx0XHRlZGl0b3Iuc2V0Q3Vyc29yKGN1cnNvcik7XG5cdFx0XHRcdH0gZWxzZSBpZiAocmVwbGFjZWRMaW5lID09IGxpbmUpIHsgLy8gbm8gdGFnLCB0byBhZGQgdGFnXG5cdFx0XHRcdFx0Lypcblx0XHRcdFx0XHRjb25zdCBjdXJzb3IgPSBlZGl0b3IuZ2V0Q3Vyc29yKClcblx0XHRcdFx0XHRjb25zdCBsaW5lID0gZWRpdG9yLmdldExpbmUoY3Vyc29yLmxpbmUpO1xuXHRcdFx0XHRcdGVkaXRvci5yZXBsYWNlUmFuZ2UoYCR7bGluZS5jaGFyQXQoY3Vyc29yLmNoIC0gMSkgIT0gJyAnID8gJyAnIDogXCJcIn0jdCR7dH0gYCwgY3Vyc29yKTsgIFxuXHRcdFx0XHRcdGN1cnNvci5jaCA9IGN1cnNvci5jaCArIDQgKyAobGluZS5jaGFyQXQoY3Vyc29yLmNoIC0gMSkgIT0gJyAnID8gMSA6IDApO1xuXHRcdFx0XHRcdGVkaXRvci5zZXRDdXJzb3IoY3Vyc29yKTtcblx0XHRcdFx0XHQqL1xuXG5cdFx0XHRcdFx0bGV0IG1vZGlmaWVkTGluZSA9IGxpbmU7XG5cdFx0XHRcdFx0aWYgKC9eXFx0Ki0gLy50ZXN0KGxpbmUpKSB7XG5cdFx0XHRcdFx0XHRtb2RpZmllZExpbmUgPSBsaW5lLnJlcGxhY2UoL14oXFx0Ki0gKS8sIGAkMSN0JHt0fSBgKTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKC9eXFx0KlxcZCtcXC4gLy50ZXN0KGxpbmUpKSB7XG5cdFx0XHRcdFx0XHRtb2RpZmllZExpbmUgPSBsaW5lLnJlcGxhY2UoL14oXFx0KlxcZCtcXC4gKS8sIGAkMXQke3R9IGApO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRtb2RpZmllZExpbmUgPSBsaW5lLnJlcGxhY2UoL14vLCBgI3Qke3R9IGApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlZGl0b3Iuc2V0TGluZShjdXJzb3IubGluZSwgbW9kaWZpZWRMaW5lKTtcblx0XHRcdFx0XHRjdXJzb3IuY2ggPSBjdXJzb3IuY2ggKyA0O1xuXHRcdFx0XHRcdGVkaXRvci5zZXRDdXJzb3IoY3Vyc29yKTtcblx0XHRcdFx0fSBlbHNlIHtcdFx0XHQgXG5cdFx0XHRcdFx0ZWRpdG9yLnNldExpbmUobGluZU51bWJlciwgcmVwbGFjZWRMaW5lKTtcblx0XHRcdFx0XHRlZGl0b3Iuc2V0Q3Vyc29yKGN1cnNvcik7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRob3RrZXlzOiBbXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRtb2RpZmllcnM6IFtgQ3RybGAsIGBNZXRhYCwgYFNoaWZ0YF0sXG5cdFx0XHRcdFx0a2V5OiBgJHt0fWAsXG5cdFx0XHRcdH0sXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRtb2RpZmllcnM6IFtgQ3RybGAsIGBBbHRgLCBgU2hpZnRgXSxcblx0XHRcdFx0XHRrZXk6IGAke3R9YCxcblx0XHRcdFx0fVxuXHRcdFx0XVxuXHRcdH0pO1xuXHR9XG5cblxuXHRpczFUbzcodDogc3RyaW5nKSA6IGJvb2xlYW4ge1xuXHRcdGlmICh0ID09IFwiMVwiIHx8IHQgPT0gXCIyXCIgfHwgdCA9PSBcIjNcIiB8fCB0ID09IFwiNFwiIHx8IHQgPT0gXCI1XCIgfHwgdCA9PSBcIjZcIiB8fCB0ID09IFwiN1wiKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gZmFsc2Vcblx0XHR9XG5cdH1cblxuXHRhZGRUb0NsaXBib2FyZEhpc3RvcnkoY29udGVudDogc3RyaW5nKSB7XG5cdFx0Y29uc3QgaW5kZXggPSBjbGlwYm9hcmRIaXN0b3J5LmluZGV4T2YoY29udGVudCwgMCk7XG5cdFx0aWYgKGluZGV4ID4gLTEpIHtcblx0XHRcdGNsaXBib2FyZEhpc3Rvcnkuc3BsaWNlKGluZGV4LCAxKTtcblx0XHR9XG5cdFx0aWYgKGNvbnRlbnQubGVuZ3RoID4gMCkge1xuXHRcdFx0Y2xpcGJvYXJkSGlzdG9yeS5wdXNoKGNvbnRlbnQpO1xuXHRcdH1cblx0fVxuXG5cdGFzeW5jIG9udW5sb2FkKCkge1xuXHRcdHRoaXMuYXBwLndvcmtzcGFjZS5kZXRhY2hMZWF2ZXNPZlR5cGUoVklFV19UWVBFX05PVEVfTElTVCk7XG5cdCAgfVxuXG5cdGFzeW5jIGxvYWRTZXR0aW5ncygpIHtcblx0XHR0aGlzLnNldHRpbmdzID0gT2JqZWN0LmFzc2lnbih7fSwgREVGQVVMVF9TRVRUSU5HUywgYXdhaXQgdGhpcy5sb2FkRGF0YSgpKTtcblx0fVxuXG5cdGFzeW5jIHNhdmVTZXR0aW5ncygpIHtcblx0XHRhd2FpdCB0aGlzLnNhdmVEYXRhKHRoaXMuc2V0dGluZ3MpO1xuXHR9XG59XG5cbmNsYXNzIFNhbXBsZVNldHRpbmdUYWIgZXh0ZW5kcyBQbHVnaW5TZXR0aW5nVGFiIHtcblx0cGx1Z2luOiBNeVBsdWdpbjtcblxuXHRjb25zdHJ1Y3RvcihhcHA6IEFwcCwgcGx1Z2luOiBNeVBsdWdpbikge1xuXHRcdHN1cGVyKGFwcCwgcGx1Z2luKTtcblx0XHR0aGlzLnBsdWdpbiA9IHBsdWdpbjtcblx0fVxuXG5cdGRpc3BsYXkoKTogdm9pZCB7XG5cdFx0Y29uc3Qge2NvbnRhaW5lckVsfSA9IHRoaXM7XG5cblx0XHRjb250YWluZXJFbC5lbXB0eSgpO1xuXG5cdFx0Y29udGFpbmVyRWwuY3JlYXRlRWwoJ2gyJywge3RleHQ6ICdTZXR0aW5ncyBmb3IgbXkgYXdlc29tZSBwbHVnaW4uJ30pO1xuXG5cdFx0bmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG5cdFx0XHQuc2V0TmFtZSgnU2V0dGluZyAjMScpXG5cdFx0XHQuc2V0RGVzYygnSXRcXCdzIGEgc2VjcmV0Jylcblx0XHRcdC5hZGRUZXh0KHRleHQgPT4gdGV4dFxuXHRcdFx0XHQuc2V0UGxhY2Vob2xkZXIoJ0VudGVyIHlvdXIgc2VjcmV0Jylcblx0XHRcdFx0LnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLm15U2V0dGluZylcblx0XHRcdFx0Lm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuXHRcdFx0XHRcdGNvbnNvbGUubG9nKCdTZWNyZXQ6ICcgKyB2YWx1ZSk7XG5cdFx0XHRcdFx0dGhpcy5wbHVnaW4uc2V0dGluZ3MubXlTZXR0aW5nID0gdmFsdWU7XG5cdFx0XHRcdFx0YXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG5cdFx0XHRcdH0pKTtcblx0fVxufVxuXG5cbiIsICJpbXBvcnQgeyBBcHAsIEVkaXRvciwgRnV6enlTdWdnZXN0TW9kYWwsIEZ1enp5TWF0Y2gsIFRGaWxlLCBOb3RpY2UgfSBmcm9tIFwib2JzaWRpYW5cIjtcbmltcG9ydCB7IGhhc0Zyb250TWF0dGVyLCBoYXNUYWdzLCByZW5hbWVUYWcgfSBmcm9tIFwidGFncmVuYW1lci9yZW5hbWluZ1wiO1xuaW1wb3J0IHsgTm90ZVR5cGUsIEFMTF9UWVBFUyB9IGZyb20gXCJzZWxmdXRpbC9nZXRUYXNrVGFnXCI7XG5cbmV4cG9ydCBjbGFzcyBVcGRhdGVOb3RlVHlwZU1vZGFsIGV4dGVuZHMgRnV6enlTdWdnZXN0TW9kYWw8Tm90ZVR5cGU+IHtcblxuICBlZGl0b3I6IEVkaXRvclxuICBmaWxlOiBURmlsZVxuICBrZXlkb3duSGFuZGxlcjogKGV2ZW50OiBLZXlib2FyZEV2ZW50KSA9PiB2b2lkO1xuXG4gIGNvbnN0cnVjdG9yKGFwcDogQXBwLCBlZGl0b3I6IEVkaXRvciwgZmlsZTogVEZpbGUpXG4gIHtcbiAgICBzdXBlcihhcHApXG4gICAgdGhpcy5lZGl0b3IgPSBlZGl0b3JcbiAgICB0aGlzLmZpbGUgPSBmaWxlXG4gICAgdGhpcy5rZXlkb3duSGFuZGxlciA9IChldmVudDogS2V5Ym9hcmRFdmVudCkgPT4ge1xuICAgICAgaWYgKGV2ZW50LmN0cmxLZXkgJiYgZXZlbnQuYWx0S2V5ICYmIGV2ZW50LnNoaWZ0S2V5ICYmIGV2ZW50LmtleSA9PT0gJ0MnKSB7IC8vIHdpbmRvd3NcbiAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgfSBlbHNlIGlmIChldmVudC5jdHJsS2V5ICYmIGV2ZW50Lm1ldGFLZXkgJiYgZXZlbnQuc2hpZnRLZXkgJiYgZXZlbnQua2V5ID09PSAnQycpIHsgLy8gbWFjb3NcbiAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgfSBlbHNlIGlmIChldmVudC5tZXRhS2V5IHx8IGV2ZW50LmN0cmxLZXkpIHtcbiAgICAgICAgY29uc3Qga2V5ID0gcGFyc2VJbnQoZXZlbnQua2V5LCAxMCk7XG4gICAgICAgIGlmIChrZXkgPj0gMSAmJiBrZXkgPD0gOSkge1xuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7IC8vIFByZXZlbnQgZGVmYXVsdCBhY3Rpb25cbiAgICAgICAgICB0aGlzLnNlbGVjdEVsZW1lbnQoa2V5IC0gMSk7IC8vIFNlbGVjdCB0aGUgZWxlbWVudCAoaW5kZXgga2V5IC0gMSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBMaXN0ZW4gZm9yIGtleWRvd24gZXZlbnRzIGF0IHRoZSBkb2N1bWVudCBsZXZlbFxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLmtleWRvd25IYW5kbGVyKTtcbiAgfVxuXG4gIHNlbGVjdEVsZW1lbnQoaW5kZXg6IG51bWJlcikge1xuICAgIGNvbnN0IGVsZW1lbnRzID0gdGhpcy5yZXN1bHRDb250YWluZXJFbC5xdWVyeVNlbGVjdG9yQWxsKCcuc3VnZ2VzdGlvbi1pdGVtJyk7XG4gICAgaWYgKGVsZW1lbnRzLmxlbmd0aCA+IGluZGV4KSB7XG4gICAgICBjb25zdCBlbGVtZW50ID0gZWxlbWVudHNbaW5kZXhdIGFzIEhUTUxFbGVtZW50O1xuICAgICAgZWxlbWVudC5jbGljaygpOyAvLyBTaW11bGF0ZSBhIGNsaWNrIHRvIHNlbGVjdCB0aGUgZWxlbWVudFxuICAgIH1cbiAgfVxuXG4gIG9uQ2xvc2UoKSB7XG4gICAgc3VwZXIub25DbG9zZSgpO1xuICAgIC8vIFN0b3AgbGlzdGVuaW5nIGZvciBrZXlkb3duIGV2ZW50cyB3aGVuIHRoZSBtb2RhbCBpcyBjbG9zZWRcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5rZXlkb3duSGFuZGxlcik7XG4gICAgLy90aGlzLnNjb3BlLnVucmVnaXN0ZXIoKTsgLy8gVW5yZWdpc3RlciB0aGUgc2NvcGUgd2hlbiB0aGUgbW9kYWwgaXMgY2xvc2VkXG4gIH1cblxuICBnZXRJdGVtcygpOiBOb3RlVHlwZVtdIHtcbiAgICByZXR1cm4gQUxMX1RZUEVTO1xuICB9XG5cbiAgZ2V0SXRlbVRleHQobm90ZVR5cGU6IE5vdGVUeXBlKTogc3RyaW5nIHtcbiAgICByZXR1cm4gbm90ZVR5cGUudHlwZTtcbiAgfVxuXG4gIC8vIFJlbmRlcnMgZWFjaCBzdWdnZXN0aW9uIGl0ZW0uXG4gIHJlbmRlclN1Z2dlc3Rpb24oY2hvb3Nlbk5vdGVUeXBlTWF0Y2g6IEZ1enp5TWF0Y2g8Tm90ZVR5cGU+LCBlbDogSFRNTEVsZW1lbnQpIHtcbiAgICBjb25zdCBub3RlVHlwZSA9IGNob29zZW5Ob3RlVHlwZU1hdGNoLml0ZW1cbiAgICBjb25zdCBpbmRleCA9IHRoaXMucmVzdWx0Q29udGFpbmVyRWwucXVlcnlTZWxlY3RvckFsbCgnLnN1Z2dlc3Rpb24taXRlbScpLmxlbmd0aDtcbiAgICBjb25zdCBpdGVtSW5kZXggPSBpbmRleCA8IDEwID8gaW5kZXggKyBcIi4gXCIgOiBcIiAgICBcIlxuICAgIGVsLmNyZWF0ZUVsKFwiZGl2XCIsIHsgdGV4dDogaXRlbUluZGV4ICsgbm90ZVR5cGUucHJlZml4ICsgXCIgXCIgKyBub3RlVHlwZS50eXBlIH0pO1xuICAgIGVsLmNyZWF0ZUVsKFwic21hbGxcIiwgeyB0ZXh0OiBcIiAgICAgXCIgKyBub3RlVHlwZS5kZXNjcmlwdGlvbiB9KTtcbiAgfVxuXG4gIGNvbnRhaW5zVHlwZShsaW5lOiBTdHJpbmcpIDogQm9vbGVhbiB7XG4gICAgcmV0dXJuIEFMTF9UWVBFUy5maWx0ZXIoKG5vdGVUeXBlKSA9PiBsaW5lLmNvbnRhaW5zKG5vdGVUeXBlLnR5cGUpKS5sZW5ndGggPiAwXG4gIH1cblxuICBhZGRGcm9udE1hdHRlcldpdGhUYWcodmFsdWU6IHN0cmluZykge1xuICAgIGNvbnN0IGN1cnNvciA9IHRoaXMuZWRpdG9yLmdldEN1cnNvcigpXG4gICAgY29uc3Qgb2xkTGluZSA9IGN1cnNvci5saW5lXG4gICAgY29uc3Qgb2xkQ2ggPSBjdXJzb3IuY2hcbiAgICBjb25zdCBhZGRUZXh0ID0gYC0tLVxcbnRhZ3M6ICR7dmFsdWV9XFxuLS0tXFxuXFxuJHt0aGlzLmVkaXRvci5nZXRWYWx1ZSgpfWBcbiAgICB0aGlzLmVkaXRvci5zZXRWYWx1ZShhZGRUZXh0KVxuICAgIGN1cnNvci5saW5lID0gb2xkTGluZSArIDRcbiAgICBjdXJzb3IuY2ggPSBvbGRDaFxuICAgIHRoaXMuZWRpdG9yLnNldEN1cnNvcihjdXJzb3IpXG4gIH1cblxuICBhZGRUYWdBc3N1bWluZ0hhc0Zyb250TWF0dGVyKHZhbHVlOiBzdHJpbmcpIHtcbiAgICBjb25zdCBjdXJzb3IgPSB0aGlzLmVkaXRvci5nZXRDdXJzb3IoKVxuICAgIGNvbnN0IG9sZExpbmUgPSBjdXJzb3IubGluZVxuICAgIGNvbnN0IG9sZENoID0gY3Vyc29yLmNoXG5cbiAgICBsZXQgZmlyc3RMaW5lSW5kZXggPSAwO1xuICAgIGNvbnN0IGxpbmVDb3VudCA9IHRoaXMuZWRpdG9yLmxpbmVDb3VudCgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZUNvdW50OyBpKyspIHtcbiAgICAgIGlmICh0aGlzLmVkaXRvci5nZXRMaW5lKGkpLnRyaW0oKSA9PSBcIi0tLVwiLnRyaW0oKSkge1xuICAgICAgICBmaXJzdExpbmVJbmRleCA9IGk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZmlyc3RMaW5lSW5kZXggPT0gbGluZUNvdW50KSB7XG4gICAgICBuZXcgTm90aWNlKFwiU29tZXRoaW5nIHdyb25nIGhlcmVcIilcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IHRleHQgPSBcIlwiXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gZmlyc3RMaW5lSW5kZXg7IGkrKykge1xuICAgICAgdGV4dCA9IHRleHQgKyB0aGlzLmVkaXRvci5nZXRMaW5lKGkpICsgXCJcXG5cIjtcbiAgICB9XG4gICAgdGV4dCA9IHRleHQgKyBgdGFnczogJHt2YWx1ZX1cXG5gXG4gICAgZm9yIChsZXQgaSA9IGZpcnN0TGluZUluZGV4ICsgMTsgaSA8PSB0aGlzLmVkaXRvci5saW5lQ291bnQoKTsgaSsrKSB7XG4gICAgICB0ZXh0ID0gdGV4dCArIHRoaXMuZWRpdG9yLmdldExpbmUoaSkgKyBcIlxcblwiO1xuICAgIH1cblxuICAgIHRoaXMuZWRpdG9yLnNldFZhbHVlKHRleHQpXG4gICAgY3Vyc29yLmxpbmUgPSBvbGRMaW5lICsgKG9sZExpbmUgPD0gZmlyc3RMaW5lSW5kZXggPyAwIDogMSlcbiAgICBjdXJzb3IuY2ggPSBvbGRDaFxuICAgIHRoaXMuZWRpdG9yLnNldEN1cnNvcihjdXJzb3IpXG4gIH1cblxuICAvLyBQZXJmb3JtIGFjdGlvbiBvbiB0aGUgc2VsZWN0ZWQgc3VnZ2VzdGlvbi5cbiAgb25DaG9vc2VJdGVtKGNob29zZW5Ob3RlVHlwZTogTm90ZVR5cGUsIGV2dDogTW91c2VFdmVudCB8IEtleWJvYXJkRXZlbnQpIHtcbiAgICBpZiAoIWhhc0Zyb250TWF0dGVyKHRoaXMuZmlsZSkpIHtcbiAgICAgIHRoaXMuYWRkRnJvbnRNYXR0ZXJXaXRoVGFnKGNob29zZW5Ob3RlVHlwZS50eXBlKVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaGFzVGFncyh0aGlzLmZpbGUpKVxuICAgICAge1xuICAgICAgICBBTExfVFlQRVMuZm9yRWFjaCh0ID0+IHtcbiAgICAgICAgICByZW5hbWVUYWcodGhpcy5maWxlLCB0LnR5cGUsIGNob29zZW5Ob3RlVHlwZS50eXBlKVxuICAgICAgICAgIH0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBuZXcgTm90aWNlKFwiYWRkaW5nIHRhZyB0b2RvXCIpXG4gICAgICAgIC8vIG5ldyBGaWxlKGFwcCwgdGhpcy5maWxlLnBhdGgsIG51bGwsIDApLnJlcGxhY2VJbkZyb250TWF0dGVyO1xuXG4gICAgICAgIC8vIFRPRE8gYWRkIHRhZ3NcbiAgICAgICAgdGhpcy5hZGRUYWdBc3N1bWluZ0hhc0Zyb250TWF0dGVyKGNob29zZW5Ob3RlVHlwZS50eXBlKVxuICAgICAgfVxuICAgIH1cbiAgfVxufSIsICJpbXBvcnQge0FwcCwgTWFya2Rvd25WaWV3LCBOb3RpY2UsIFRBYnN0cmFjdEZpbGUsIFRGaWxlLCBwYXJzZUZyb250TWF0dGVyQWxpYXNlcywgcGFyc2VGcm9udE1hdHRlclRhZ3N9IGZyb20gXCJvYnNpZGlhblwiO1xuaW1wb3J0IHtUYWcsIFJlcGxhY2VtZW50fSBmcm9tIFwiLi9UYWdcIjtcbmltcG9ydCB7RmlsZX0gZnJvbSBcIi4vRmlsZVwiO1xuXG5leHBvcnQgZnVuY3Rpb24gaGFzRnJvbnRNYXR0ZXIoZmlsZTogVEZpbGUpIDogYm9vbGVhbiB7XG4gICAgbGV0IHsgZnJvbnRtYXR0ZXIgfSA9IGFwcC5tZXRhZGF0YUNhY2hlLmdldEZpbGVDYWNoZShmaWxlKSB8fCB7fTtcbiAgICByZXR1cm4gZnJvbnRtYXR0ZXIgIT0gbnVsbFxufVxuXG5leHBvcnQgZnVuY3Rpb24gaGFzVGFncyhmaWxlOiBURmlsZSkgOiBib29sZWFuIHtcbiAgICBsZXQgeyBmcm9udG1hdHRlciB9ID0gYXBwLm1ldGFkYXRhQ2FjaGUuZ2V0RmlsZUNhY2hlKGZpbGUpIHx8IHt9O1xuICAgIGNvbnN0IGZtdGFncyA9IChwYXJzZUZyb250TWF0dGVyVGFncyhmcm9udG1hdHRlcikgfHwgW10pO1xuICAgIGNvbnN0IGFsaWFzVGFncyA9IChwYXJzZUZyb250TWF0dGVyQWxpYXNlcyhmcm9udG1hdHRlcikgfHwgW10pLmZpbHRlcihUYWcuaXNUYWcpO1xuICAgIHJldHVybiAoZm10YWdzLmxlbmd0aCB8fCBhbGlhc1RhZ3MubGVuZ3RoKSA/IHRydWUgOiBmYWxzZVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmVuYW1lVGFnKGZpbGU6IFRGaWxlLCB0YWdOYW1lOiBzdHJpbmcsIG5ld05hbWU6c3RyaW5nKSA6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIGNvbnN0XG4gICAgICAgIG9sZFRhZyAgPSBuZXcgVGFnKHRhZ05hbWUpLFxuICAgICAgICBuZXdUYWcgID0gbmV3IFRhZyhuZXdOYW1lKSxcbiAgICAgICAgcmVwbGFjZSA9IG5ldyBSZXBsYWNlbWVudChvbGRUYWcsIG5ld1RhZylcblxuICAgIGNvbnN0IHRhcmdldCA9IGF3YWl0IGZpbmRUYXJnZXRzKG9sZFRhZywgZmlsZSk7XG4gICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBhd2FpdCB0YXJnZXQucmVuYW1lZChyZXBsYWNlKVxuICAgIHJldHVybiB0cnVlXG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBmaW5kVGFyZ2V0cyh0YWc6IFRhZywgZmlsZTogVEZpbGUpIHtcbiAgICBsZXQgeyBmcm9udG1hdHRlciwgdGFncyB9ID0gYXBwLm1ldGFkYXRhQ2FjaGUuZ2V0RmlsZUNhY2hlKGZpbGUpIHx8IHt9O1xuICAgIGNvbnN0IGZtdGFncyA9IChwYXJzZUZyb250TWF0dGVyVGFncyhmcm9udG1hdHRlcikgfHwgW10pLmZpbHRlcih0YWcubWF0Y2hlcyk7XG4gICAgY29uc3QgYWxpYXNUYWdzID0gKHBhcnNlRnJvbnRNYXR0ZXJBbGlhc2VzKGZyb250bWF0dGVyKSB8fCBbXSkuZmlsdGVyKFRhZy5pc1RhZykuZmlsdGVyKHRhZy5tYXRjaGVzKTtcbiAgICBpZiAoZm10YWdzLmxlbmd0aCB8fCBhbGlhc1RhZ3MubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBuZXcgRmlsZShhcHAsIGZpbGUucGF0aCwgdGFncywgZm10YWdzLmxlbmd0aCArIGFsaWFzVGFncy5sZW5ndGgpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlbmFtZUJsb2dUaXRsZShhcHAgOiBBcHAsIHBhdGg6IHN0cmluZywgdmlldzogTWFya2Rvd25WaWV3KSA6IFByb21pc2U8dm9pZD4ge1xuICAgIGxldCBtb21lbnQgPSByZXF1aXJlKCdtb21lbnQnKTtcbiAgICBjb25zdCBkYXRlWVlZWU1NREQgPSBtb21lbnQoKS5mb3JtYXQoJ1lZWVlNTUREJyk7XG4gICAgbGV0IHJlbmFtZWRQYXRoID0gXCJcIlxuICAgIGlmIChwYXRoLm1hdGNoKC9eLlxcL0Jsb2cgXFxkXFxkXFxkXFxkXFxkXFxkXFxkXFxkLykpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG4gICAgfSBlbHNlIGlmIChwYXRoLm1hdGNoKC9eLlxcL2Jsb2cgXFxkXFxkXFxkXFxkXFxkXFxkXFxkXFxkLykpIHtcbiAgICAgICAgbmV3IE5vdGljZShcInN0YXJ0IHdpdGggYmxvZyB3aXRoIGRhdGUsIHJlbmFtaW5nIGJsb2cgdG8gQmxvZ1wiKVxuICAgICAgICByZW5hbWVkUGF0aCA9IHBhdGgucmVwbGFjZSgvXiguXFwvKWJsb2cgLywgYCQxQmxvZyBgKVxuICAgICAgICByZXR1cm4gcmVuYW1lRmlsZShhcHAsIHZpZXcuZmlsZSwgcmVuYW1lZFBhdGgpO1xuICAgIH0gZWxzZSBpZiAocGF0aC5tYXRjaCgvXi5cXC9CbG9nIC8pKSB7XG4gICAgICAgIG5ldyBOb3RpY2UoXCJzdGFydHMgd2l0aCBCbG9nIGJ1dCBubyBkYXRlLCBhZGRpbmcgZGF0ZVwiKVxuICAgICAgICByZW5hbWVkUGF0aCA9IHBhdGgucmVwbGFjZSgvXiguXFwvQmxvZyApLywgYCQxJHtkYXRlWVlZWU1NRER9IGApXG4gICAgICAgIHJldHVybiByZW5hbWVGaWxlKGFwcCwgdmlldy5maWxlLCByZW5hbWVkUGF0aCk7XG4gICAgfSBlbHNlIGlmIChwYXRoLm1hdGNoKC9eLlxcL2Jsb2cgLykpIHtcbiAgICAgICAgbmV3IE5vdGljZShcInN0YXJ0cyB3aXRoIGJsb2cgYnV0IG5vIGRhdGUsIGFkZGluZyBkYXRlXCIpXG4gICAgICAgIHJlbmFtZWRQYXRoID0gcGF0aC5yZXBsYWNlKC9eKC5cXC8pYmxvZyAvLCBgJDFCbG9nICR7ZGF0ZVlZWVlNTUREfSBgKVxuICAgICAgICByZXR1cm4gcmVuYW1lRmlsZShhcHAsIHZpZXcuZmlsZSwgcmVuYW1lZFBhdGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG5ldyBOb3RpY2UoXCJzdGFydHMgd2l0aG91dCBibG9nLCBhZGRpbmcgQmxvZyArIGRhdGVcIilcbiAgICAgICAgcmVuYW1lZFBhdGggPSBwYXRoLnJlcGxhY2UoL14oLlxcLykvLCBgJDFCbG9nICR7ZGF0ZVlZWVlNTUREfSBgKVxuICAgICAgICByZXR1cm4gcmVuYW1lRmlsZShhcHAsIHZpZXcuZmlsZSwgcmVuYW1lZFBhdGgpO1xuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlbmFtZVRocmVhZHNUaXRsZShhcHAgOiBBcHAsIHBhdGg6IHN0cmluZywgdmlldzogTWFya2Rvd25WaWV3KSA6IFByb21pc2U8dm9pZD4ge1xuICAgIGxldCBtb21lbnQgPSByZXF1aXJlKCdtb21lbnQnKTtcbiAgICBjb25zdCBkYXRlWVlZWU1NREQgPSBtb21lbnQoKS5mb3JtYXQoJ1lZWVlNTUREJyk7XG4gICAgbGV0IHJlbmFtZWRQYXRoID0gXCJcIlxuICAgIGlmIChwYXRoLm1hdGNoKC9eLlxcL1RocmVhZHMgXFxkXFxkXFxkXFxkXFxkXFxkXFxkXFxkLykpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG4gICAgfSBlbHNlIGlmIChwYXRoLm1hdGNoKC9eLlxcL3RocmVhZHMgXFxkXFxkXFxkXFxkXFxkXFxkXFxkXFxkLykpIHtcbiAgICAgICAgbmV3IE5vdGljZShcInN0YXJ0IHdpdGggdGhyZWFkcyB3aXRoIGRhdGUsIHJlbmFtaW5nIHRocmVhZHMgdG8gVGhyZWFkc1wiKVxuICAgICAgICByZW5hbWVkUGF0aCA9IHBhdGgucmVwbGFjZSgvXiguXFwvKXRocmVhZHMgLywgYCQxVGhyZWFkcyBgKVxuICAgICAgICByZXR1cm4gcmVuYW1lRmlsZShhcHAsIHZpZXcuZmlsZSwgcmVuYW1lZFBhdGgpO1xuICAgIH0gZWxzZSBpZiAocGF0aC5tYXRjaCgvXi5cXC9UaHJlYWRzIC8pKSB7XG4gICAgICAgIG5ldyBOb3RpY2UoXCJzdGFydHMgd2l0aCBUaHJlYWRzIGJ1dCBubyBkYXRlLCBhZGRpbmcgZGF0ZVwiKVxuICAgICAgICByZW5hbWVkUGF0aCA9IHBhdGgucmVwbGFjZSgvXiguXFwvVGhyZWFkcyApLywgYCQxJHtkYXRlWVlZWU1NRER9IGApXG4gICAgICAgIHJldHVybiByZW5hbWVGaWxlKGFwcCwgdmlldy5maWxlLCByZW5hbWVkUGF0aCk7XG4gICAgfSBlbHNlIGlmIChwYXRoLm1hdGNoKC9eLlxcL3RocmVhZHMgLykpIHtcbiAgICAgICAgbmV3IE5vdGljZShcInN0YXJ0cyB3aXRoIHRocmVhZHMgYnV0IG5vIGRhdGUsIGFkZGluZyBkYXRlXCIpXG4gICAgICAgIHJlbmFtZWRQYXRoID0gcGF0aC5yZXBsYWNlKC9eKC5cXC8pdGhyZWFkcyAvLCBgJDFUaHJlYWRzICR7ZGF0ZVlZWVlNTUREfSBgKVxuICAgICAgICByZXR1cm4gcmVuYW1lRmlsZShhcHAsIHZpZXcuZmlsZSwgcmVuYW1lZFBhdGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG5ldyBOb3RpY2UoXCJzdGFydHMgd2l0aG91dCB0aHJlYWRzLCBhZGRpbmcgVGhyZWFkcyArIGRhdGVcIilcbiAgICAgICAgcmVuYW1lZFBhdGggPSBwYXRoLnJlcGxhY2UoL14oLlxcLykvLCBgJDFUaHJlYWRzICR7ZGF0ZVlZWVlNTUREfSBgKVxuICAgICAgICByZXR1cm4gcmVuYW1lRmlsZShhcHAsIHZpZXcuZmlsZSwgcmVuYW1lZFBhdGgpO1xuICAgIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gcmVuYW1lRmlsZShhcHAgOiBBcHAsIGZpbGUgOiBUQWJzdHJhY3RGaWxlLCBuZXdQYXRoOiBzdHJpbmcpIHtcbiAgICBhcHAuZmlsZU1hbmFnZXIucmVuYW1lRmlsZShmaWxlLCBuZXdQYXRoKVxufVxuXG5cbiIsICJjb25zdCB0YWdCb2R5ID0gL14jW15cXHUyMDAwLVxcdTIwNkZcXHUyRTAwLVxcdTJFN0YnIVwiIyQlJigpKissLjo7PD0+P0BeYHt8fX5cXFtcXF1cXFxcXFxzXSskLztcblxuZXhwb3J0IGNsYXNzIFRhZyB7XG4gICAgdGFnOiBhbnk7XG4gICAgY2Fub25pY2FsX3ByZWZpeDogc3RyaW5nO1xuICAgIGNhbm9uaWNhbDogc3RyaW5nO1xuICAgIG5hbWU6IGFueTtcbiAgICBtYXRjaGVzOiAodGV4dDogYW55KSA9PiBhbnk7XG4gICAgY29uc3RydWN0b3IobmFtZTogYW55KSB7XG4gICAgICAgIGNvbnN0XG4gICAgICAgICAgICBoYXNoZWQgPSB0aGlzLnRhZyA9IFRhZy50b1RhZyhuYW1lKSxcbiAgICAgICAgICAgIGNhbm9uaWNhbCA9IHRoaXMuY2Fub25pY2FsID0gaGFzaGVkLnRvTG93ZXJDYXNlKCksXG4gICAgICAgICAgICBjYW5vbmljYWxfcHJlZml4ID0gdGhpcy5jYW5vbmljYWxfcHJlZml4ID0gY2Fub25pY2FsICsgXCIvXCI7XG4gICAgICAgIHRoaXMubmFtZSA9IGhhc2hlZC5zbGljZSgxKTtcbiAgICAgICAgdGhpcy5tYXRjaGVzID0gZnVuY3Rpb24gKHRleHQpIHtcbiAgICAgICAgICAgIHRleHQgPSB0ZXh0LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICByZXR1cm4gdGV4dCA9PSBjYW5vbmljYWwgfHwgdGV4dC5zdGFydHNXaXRoKGNhbm9uaWNhbF9wcmVmaXgpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICB0b1N0cmluZygpIHsgcmV0dXJuIHRoaXMudGFnOyB9XG5cbiAgICBzdGF0aWMgaXNUYWcoczogc3RyaW5nKSB7IHJldHVybiB0YWdCb2R5LnRlc3Qocyk7IH1cblxuICAgIHN0YXRpYyB0b1RhZyhuYW1lOiBzdHJpbmcpIHtcbiAgICAgICAgd2hpbGUgKG5hbWUuc3RhcnRzV2l0aChcIiMjXCIpKSBuYW1lID0gbmFtZS5zbGljZSgxKTtcbiAgICAgICAgcmV0dXJuIG5hbWUuc3RhcnRzV2l0aChcIiNcIikgPyBuYW1lIDogXCIjXCIrbmFtZTtcbiAgICB9XG5cbiAgICBzdGF0aWMgY2Fub25pY2FsKG5hbWU6IGFueSkge1xuICAgICAgICByZXR1cm4gVGFnLnRvVGFnKG5hbWUpLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxufVxuXG5leHBvcnQgY2xhc3MgUmVwbGFjZW1lbnQge1xuICAgIGluU3RyaW5nOiAodGV4dDogYW55LCBwb3M/OiBudW1iZXIpID0+IGFueTtcbiAgICBpbkFycmF5OiAodGFnczogYW55LCBza2lwT2RkOiBhbnksIGlzQWxpYXM6IGFueSkgPT4gYW55O1xuICAgIHdpbGxNZXJnZVRhZ3M6ICh0YWdOYW1lczogYW55KSA9PiBUYWdbXSB8IHVuZGVmaW5lZDtcblxuICAgIGNvbnN0cnVjdG9yKGZyb21UYWc6IFRhZywgdG9UYWc6IFRhZykge1xuICAgICAgICBjb25zdCBjYWNoZSA9ICBPYmplY3QuYXNzaWduKFxuICAgICAgICAgICAgT2JqZWN0LmNyZWF0ZShudWxsKSwge1xuICAgICAgICAgICAgICAgIFtmcm9tVGFnLnRhZ106ICB0b1RhZy50YWcsXG4gICAgICAgICAgICAgICAgW2Zyb21UYWcubmFtZV06IHRvVGFnLm5hbWUsXG4gICAgICAgICAgICB9XG4gICAgICAgICk7XG5cbiAgICAgICAgdGhpcy5pblN0cmluZyA9IGZ1bmN0aW9uKHRleHQsIHBvcyA9IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0ZXh0LnNsaWNlKDAsIHBvcykgKyB0b1RhZy50YWcgKyB0ZXh0LnNsaWNlKHBvcyArIGZyb21UYWcudGFnLmxlbmd0aCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmluQXJyYXkgPSAodGFncywgc2tpcE9kZCwgaXNBbGlhcykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRhZ3MubWFwKCh0OiBzdHJpbmcsIGk6IG51bWJlcikgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChza2lwT2RkICYmIChpICYgMSkpIHJldHVybiB0OyAgIC8vIGxlYXZlIG9kZCBlbnRyaWVzIChzZXBhcmF0b3JzKSBhbG9uZVxuICAgICAgICAgICAgICAgIC8vIE9ic2lkaWFuIGFsbG93cyBzcGFjZXMgYXMgc2VwYXJhdG9ycyB3aXRoaW4gYXJyYXkgZWxlbWVudHNcbiAgICAgICAgICAgICAgICBpZiAoIXQpIHJldHVybiB0O1xuICAgICAgICAgICAgICAgIC8vIFNraXAgbm9uLXRhZyBwYXJ0c1xuICAgICAgICAgICAgICAgIGlmIChpc0FsaWFzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdC5zdGFydHNXaXRoKFwiI1wiKSB8fCAhVGFnLmlzVGFnKHQpKSByZXR1cm4gdDtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKC9bICxcXG5dLy50ZXN0KHQpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHJldHVybiB0aGlzLmluQXJyYXkodC5zcGxpdCgvKFssIFxcbl0rKS8pLCB0cnVlKS5qb2luKFwiXCIpOyAvLyBub3Qgc3VyZVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pbkFycmF5KHQuc3BsaXQoLyhbLCBcXG5dKykvKSwgdHJ1ZSwgaXNBbGlhcykuam9pbihcIlwiKTsgLy8gbm90IHN1cmVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNhY2hlW3RdKSByZXR1cm4gY2FjaGVbdF07XG4gICAgICAgICAgICAgICAgY29uc3QgbGMgPSB0LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgaWYgKGNhY2hlW2xjXSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FjaGVbdF0gPSBjYWNoZVtsY107XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChsYy5zdGFydHNXaXRoKGZyb21UYWcuY2Fub25pY2FsX3ByZWZpeCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhY2hlW3RdID0gY2FjaGVbbGNdID0gdGhpcy5pblN0cmluZyh0KTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKChcIiNcIiArIGxjKS5zdGFydHNXaXRoKGZyb21UYWcuY2Fub25pY2FsX3ByZWZpeCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhY2hlW3RdID0gY2FjaGVbbGNdID0gdGhpcy5pblN0cmluZyhcIiNcIiArIHQpLnNsaWNlKDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gY2FjaGVbdF0gPSBjYWNoZVtsY10gPSB0O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy53aWxsTWVyZ2VUYWdzID0gZnVuY3Rpb24gKHRhZ05hbWVzKSB7XG4gICAgICAgICAgICAvLyBSZW5hbWluZyB0byBjaGFuZ2UgY2FzZSBkb2Vzbid0IGxvc2UgaW5mbywgc28gaWdub3JlIGl0XG4gICAgICAgICAgICBpZiAoZnJvbVRhZy5jYW5vbmljYWwgPT09IHRvVGFnLmNhbm9uaWNhbCkgcmV0dXJuO1xuXG4gICAgICAgICAgICBjb25zdCBleGlzdGluZyA9IG5ldyBTZXQodGFnTmFtZXMubWFwKChzOiBzdHJpbmcpID0+IHMudG9Mb3dlckNhc2UoKSkpO1xuXG4gICAgICAgICAgICBmb3IgKGNvbnN0IHRhZ05hbWUgb2YgdGFnTmFtZXMuZmlsdGVyKGZyb21UYWcubWF0Y2hlcykpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGFuZ2VkID0gdGhpcy5pblN0cmluZyh0YWdOYW1lKTtcbiAgICAgICAgICAgICAgICBpZiAoZXhpc3RpbmcuaGFzKGNoYW5nZWQudG9Mb3dlckNhc2UoKSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbbmV3IFRhZyh0YWdOYW1lKSwgbmV3IFRhZyhjaGFuZ2VkKV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuICAgIH1cbn1cblxuXG4iLCAiaW1wb3J0IHsgTm90aWNlIH0gZnJvbSBcIm9ic2lkaWFuXCI7XG5pbXBvcnQgeyBDU1QsIHBhcnNlRG9jdW1lbnQgfSBmcm9tIFwieWFtbFwiO1xuaW1wb3J0IHsgUmVwbGFjZW1lbnQgfSBmcm9tIFwiLi9UYWdcIjtcblxuZXhwb3J0IGNsYXNzIEZpbGUge1xuICAgIGFwcDogYW55O1xuICAgIGZpbGVuYW1lOiBhbnk7XG4gICAgYmFzZW5hbWU6IGFueTtcbiAgICB0YWdQb3NpdGlvbnM6IGFueTtcbiAgICBoYXNGcm9udE1hdHRlcjogYm9vbGVhbjtcblxuICAgIGNvbnN0cnVjdG9yKGFwcDogYW55LCBmaWxlbmFtZTogc3RyaW5nLCB0YWdQb3NpdGlvbnM6IGFueSwgaGFzRnJvbnRNYXR0ZXI6IG51bWJlcikge1xuICAgICAgICB0aGlzLmFwcCA9IGFwcDtcbiAgICAgICAgdGhpcy5maWxlbmFtZSA9IGZpbGVuYW1lO1xuICAgICAgICB0aGlzLmJhc2VuYW1lID0gZmlsZW5hbWUuc3BsaXQoXCIvXCIpLnBvcCgpO1xuICAgICAgICB0aGlzLnRhZ1Bvc2l0aW9ucyA9IHRhZ1Bvc2l0aW9ucztcbiAgICAgICAgdGhpcy5oYXNGcm9udE1hdHRlciA9ICEhaGFzRnJvbnRNYXR0ZXI7XG4gICAgfVxuXG4gICAgLyoqIEBwYXJhbSB7UmVwbGFjZW1lbnR9IHJlcGxhY2UgKi9cbiAgICBhc3luYyByZW5hbWVkKHJlcGxhY2UgOiBSZXBsYWNlbWVudCkge1xuICAgICAgICBjb25zdCBmaWxlID0gdGhpcy5hcHAudmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKHRoaXMuZmlsZW5hbWUpO1xuICAgICAgICBjb25zdCBvcmlnaW5hbCA9IGF3YWl0IHRoaXMuYXBwLnZhdWx0LnJlYWQoZmlsZSk7XG4gICAgICAgIGxldCB0ZXh0ID0gb3JpZ2luYWw7XG5cbiAgICAgICAgaWYgKHRoaXMuaGFzRnJvbnRNYXR0ZXIpIHtcbiAgICAgICAgICAgIHRleHQgPSB0aGlzLnJlcGxhY2VJbkZyb250TWF0dGVyKHRleHQsIHJlcGxhY2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRleHQgIT09IG9yaWdpbmFsKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmFwcC52YXVsdC5tb2RpZnkoZmlsZSwgdGV4dCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKiBAcGFyYW0ge1JlcGxhY2VtZW50fSByZXBsYWNlICovXG4gICAgcmVwbGFjZUluRnJvbnRNYXR0ZXIodGV4dDogeyBzcGxpdDogKGFyZzA6IFJlZ0V4cCwgYXJnMTogbnVtYmVyKSA9PiBbYW55LCBhbnldOyByZXBsYWNlOiAoYXJnMDogYW55LCBhcmcxOiBhbnkpID0+IGFueTsgfSwgcmVwbGFjZTogeyBpbkFycmF5OiAoYXJnMDogYW55W10sIGFyZzE6IGJvb2xlYW4sIGFyZzI6IGFueSkgPT4gYW55W107IH0pIHtcbiAgICAgICAgY29uc3QgW2VtcHR5LCBmcm9udE1hdHRlcl0gPSB0ZXh0LnNwbGl0KC9eLS0tXFxyPyRcXG4/L20sIDIpO1xuXG4gICAgICAgIC8vIENoZWNrIGZvciB2YWxpZCwgbm9uLWVtcHR5LCBwcm9wZXJseSB0ZXJtaW5hdGVkIGZyb250IG1hdHRlclxuICAgICAgICBpZiAoZW1wdHkudHJpbSgpICE9PSBcIlwiIHx8ICFmcm9udE1hdHRlci50cmltKCkgfHwgIWZyb250TWF0dGVyLmVuZHNXaXRoKFwiXFxuXCIpKVxuICAgICAgICAgICAgcmV0dXJuIHRleHQ7XG5cbiAgICAgICAgY29uc3QgcGFyc2VkID0gcGFyc2VEb2N1bWVudChmcm9udE1hdHRlciwge2tlZXBTb3VyY2VUb2tlbnM6IHRydWV9KTtcbiAgICAgICAgaWYgKHBhcnNlZC5lcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCBlcnJvciA9IGBZQU1MIGlzc3VlIHdpdGggJHt0aGlzLmZpbGVuYW1lfTogJHtwYXJzZWQuZXJyb3JzWzBdfWA7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yKTsgbmV3IE5vdGljZShlcnJvciArIFwiOyBza2lwcGluZyBmcm9udG1hdHRlclwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBjaGFuZ2VkID0gZmFsc2UsIGpzb24gPSBwYXJzZWQudG9KU09OKCk7XG5cbiAgICAgICAgZnVuY3Rpb24gc2V0SW5Ob2RlKG5vZGU6IHsgc3JjVG9rZW46IGFueTsgdmFsdWU6IGFueTsgfSwgdmFsdWU6IGFueSwgYWZ0ZXJLZXk9ZmFsc2UpIHtcbiAgICAgICAgICAgIENTVC5zZXRTY2FsYXJWYWx1ZShub2RlLnNyY1Rva2VuLCB2YWx1ZSwge2FmdGVyS2V5fSk7XG4gICAgICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIG5vZGUudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHByb2Nlc3NGaWVsZChwcm9wOiBzdHJpbmcgfCBudW1iZXIsIGlzQWxpYXM6IGJvb2xlYW4pIHtcbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBwYXJzZWQuZ2V0KHByb3AsIHRydWUpO1xuICAgICAgICAgICAgaWYgKCFub2RlKSByZXR1cm47XG4gICAgICAgICAgICBjb25zdCBmaWVsZCA9IGpzb25bcHJvcF07XG4gICAgICAgICAgICBpZiAoIWZpZWxkIHx8ICFmaWVsZC5sZW5ndGgpIHJldHVybjtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZmllbGQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJ0cyA9IGZpZWxkLnNwbGl0KGlzQWxpYXMgPyAvKF5cXHMrfFxccyosXFxzKnxcXHMrJCkvIDogLyhbXFxzLF0rKS8pO1xuICAgICAgICAgICAgICAgIGNvbnN0IGFmdGVyID0gcmVwbGFjZS5pbkFycmF5KHBhcnRzLCB0cnVlLCBpc0FsaWFzKS5qb2luKFwiXCIpO1xuICAgICAgICAgICAgICAgIGlmIChmaWVsZCAhPSBhZnRlcikgc2V0SW5Ob2RlKG5vZGUsIGFmdGVyLCB0cnVlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShmaWVsZCkpIHtcbiAgICAgICAgICAgICAgICByZXBsYWNlLmluQXJyYXkoZmllbGQsIGZhbHNlLCBpc0FsaWFzKS5mb3JFYWNoKCh2OiBhbnksIGk6IG51bWJlcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmllbGRbaV0gIT09IHYpIHNldEluTm9kZShub2RlLmdldChpLCB0cnVlKSwgdilcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoY29uc3Qge2tleToge3ZhbHVlOnByb3B9fSBvZiBwYXJzZWQuY29udGVudHMuaXRlbXMpIHtcbiAgICAgICAgICAgIGlmICgvXnRhZ3M/JC9pLnRlc3QocHJvcCkpIHtcbiAgICAgICAgICAgICAgICBwcm9jZXNzRmllbGQocHJvcCwgZmFsc2UpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICgvXmFsaWFzKGVzKT8kL2kudGVzdChwcm9wKSkge1xuICAgICAgICAgICAgICAgIHByb2Nlc3NGaWVsZChwcm9wLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2hhbmdlZCA/IHRleHQucmVwbGFjZShmcm9udE1hdHRlciwgQ1NULnN0cmluZ2lmeShwYXJzZWQuY29udGVudHMuc3JjVG9rZW4pKSA6IHRleHQ7XG4gICAgfVxufVxuIiwgImNvbnN0IEFMSUFTID0gU3ltYm9sLmZvcigneWFtbC5hbGlhcycpO1xuY29uc3QgRE9DID0gU3ltYm9sLmZvcigneWFtbC5kb2N1bWVudCcpO1xuY29uc3QgTUFQID0gU3ltYm9sLmZvcigneWFtbC5tYXAnKTtcbmNvbnN0IFBBSVIgPSBTeW1ib2wuZm9yKCd5YW1sLnBhaXInKTtcbmNvbnN0IFNDQUxBUiA9IFN5bWJvbC5mb3IoJ3lhbWwuc2NhbGFyJyk7XG5jb25zdCBTRVEgPSBTeW1ib2wuZm9yKCd5YW1sLnNlcScpO1xuY29uc3QgTk9ERV9UWVBFID0gU3ltYm9sLmZvcigneWFtbC5ub2RlLnR5cGUnKTtcbmNvbnN0IGlzQWxpYXMgPSAobm9kZSkgPT4gISFub2RlICYmIHR5cGVvZiBub2RlID09PSAnb2JqZWN0JyAmJiBub2RlW05PREVfVFlQRV0gPT09IEFMSUFTO1xuY29uc3QgaXNEb2N1bWVudCA9IChub2RlKSA9PiAhIW5vZGUgJiYgdHlwZW9mIG5vZGUgPT09ICdvYmplY3QnICYmIG5vZGVbTk9ERV9UWVBFXSA9PT0gRE9DO1xuY29uc3QgaXNNYXAgPSAobm9kZSkgPT4gISFub2RlICYmIHR5cGVvZiBub2RlID09PSAnb2JqZWN0JyAmJiBub2RlW05PREVfVFlQRV0gPT09IE1BUDtcbmNvbnN0IGlzUGFpciA9IChub2RlKSA9PiAhIW5vZGUgJiYgdHlwZW9mIG5vZGUgPT09ICdvYmplY3QnICYmIG5vZGVbTk9ERV9UWVBFXSA9PT0gUEFJUjtcbmNvbnN0IGlzU2NhbGFyID0gKG5vZGUpID0+ICEhbm9kZSAmJiB0eXBlb2Ygbm9kZSA9PT0gJ29iamVjdCcgJiYgbm9kZVtOT0RFX1RZUEVdID09PSBTQ0FMQVI7XG5jb25zdCBpc1NlcSA9IChub2RlKSA9PiAhIW5vZGUgJiYgdHlwZW9mIG5vZGUgPT09ICdvYmplY3QnICYmIG5vZGVbTk9ERV9UWVBFXSA9PT0gU0VRO1xuZnVuY3Rpb24gaXNDb2xsZWN0aW9uKG5vZGUpIHtcbiAgICBpZiAobm9kZSAmJiB0eXBlb2Ygbm9kZSA9PT0gJ29iamVjdCcpXG4gICAgICAgIHN3aXRjaCAobm9kZVtOT0RFX1RZUEVdKSB7XG4gICAgICAgICAgICBjYXNlIE1BUDpcbiAgICAgICAgICAgIGNhc2UgU0VROlxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gaXNOb2RlKG5vZGUpIHtcbiAgICBpZiAobm9kZSAmJiB0eXBlb2Ygbm9kZSA9PT0gJ29iamVjdCcpXG4gICAgICAgIHN3aXRjaCAobm9kZVtOT0RFX1RZUEVdKSB7XG4gICAgICAgICAgICBjYXNlIEFMSUFTOlxuICAgICAgICAgICAgY2FzZSBNQVA6XG4gICAgICAgICAgICBjYXNlIFNDQUxBUjpcbiAgICAgICAgICAgIGNhc2UgU0VROlxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuY29uc3QgaGFzQW5jaG9yID0gKG5vZGUpID0+IChpc1NjYWxhcihub2RlKSB8fCBpc0NvbGxlY3Rpb24obm9kZSkpICYmICEhbm9kZS5hbmNob3I7XG5jbGFzcyBOb2RlQmFzZSB7XG4gICAgY29uc3RydWN0b3IodHlwZSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgTk9ERV9UWVBFLCB7IHZhbHVlOiB0eXBlIH0pO1xuICAgIH1cbiAgICAvKiogQ3JlYXRlIGEgY29weSBvZiB0aGlzIG5vZGUuICAqL1xuICAgIGNsb25lKCkge1xuICAgICAgICBjb25zdCBjb3B5ID0gT2JqZWN0LmNyZWF0ZShPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcyksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHRoaXMpKTtcbiAgICAgICAgaWYgKHRoaXMucmFuZ2UpXG4gICAgICAgICAgICBjb3B5LnJhbmdlID0gdGhpcy5yYW5nZS5zbGljZSgpO1xuICAgICAgICByZXR1cm4gY29weTtcbiAgICB9XG59XG5cbmV4cG9ydCB7IEFMSUFTLCBET0MsIE1BUCwgTk9ERV9UWVBFLCBOb2RlQmFzZSwgUEFJUiwgU0NBTEFSLCBTRVEsIGhhc0FuY2hvciwgaXNBbGlhcywgaXNDb2xsZWN0aW9uLCBpc0RvY3VtZW50LCBpc01hcCwgaXNOb2RlLCBpc1BhaXIsIGlzU2NhbGFyLCBpc1NlcSB9O1xuIiwgImltcG9ydCB7IGlzRG9jdW1lbnQsIGlzTWFwLCBpc1NlcSwgaXNQYWlyLCBpc1NjYWxhciwgaXNBbGlhcywgaXNOb2RlLCBpc0NvbGxlY3Rpb24gfSBmcm9tICcuL25vZGVzL05vZGUuanMnO1xuXG5jb25zdCBCUkVBSyA9IFN5bWJvbCgnYnJlYWsgdmlzaXQnKTtcbmNvbnN0IFNLSVAgPSBTeW1ib2woJ3NraXAgY2hpbGRyZW4nKTtcbmNvbnN0IFJFTU9WRSA9IFN5bWJvbCgncmVtb3ZlIG5vZGUnKTtcbi8qKlxuICogQXBwbHkgYSB2aXNpdG9yIHRvIGFuIEFTVCBub2RlIG9yIGRvY3VtZW50LlxuICpcbiAqIFdhbGtzIHRocm91Z2ggdGhlIHRyZWUgKGRlcHRoLWZpcnN0KSBzdGFydGluZyBmcm9tIGBub2RlYCwgY2FsbGluZyBhXG4gKiBgdmlzaXRvcmAgZnVuY3Rpb24gd2l0aCB0aHJlZSBhcmd1bWVudHM6XG4gKiAgIC0gYGtleWA6IEZvciBzZXF1ZW5jZSB2YWx1ZXMgYW5kIG1hcCBgUGFpcmAsIHRoZSBub2RlJ3MgaW5kZXggaW4gdGhlXG4gKiAgICAgY29sbGVjdGlvbi4gV2l0aGluIGEgYFBhaXJgLCBgJ2tleSdgIG9yIGAndmFsdWUnYCwgY29ycmVzcG9uZGluZ2x5LlxuICogICAgIGBudWxsYCBmb3IgdGhlIHJvb3Qgbm9kZS5cbiAqICAgLSBgbm9kZWA6IFRoZSBjdXJyZW50IG5vZGUuXG4gKiAgIC0gYHBhdGhgOiBUaGUgYW5jZXN0cnkgb2YgdGhlIGN1cnJlbnQgbm9kZS5cbiAqXG4gKiBUaGUgcmV0dXJuIHZhbHVlIG9mIHRoZSB2aXNpdG9yIG1heSBiZSB1c2VkIHRvIGNvbnRyb2wgdGhlIHRyYXZlcnNhbDpcbiAqICAgLSBgdW5kZWZpbmVkYCAoZGVmYXVsdCk6IERvIG5vdGhpbmcgYW5kIGNvbnRpbnVlXG4gKiAgIC0gYHZpc2l0LlNLSVBgOiBEbyBub3QgdmlzaXQgdGhlIGNoaWxkcmVuIG9mIHRoaXMgbm9kZSwgY29udGludWUgd2l0aCBuZXh0XG4gKiAgICAgc2libGluZ1xuICogICAtIGB2aXNpdC5CUkVBS2A6IFRlcm1pbmF0ZSB0cmF2ZXJzYWwgY29tcGxldGVseVxuICogICAtIGB2aXNpdC5SRU1PVkVgOiBSZW1vdmUgdGhlIGN1cnJlbnQgbm9kZSwgdGhlbiBjb250aW51ZSB3aXRoIHRoZSBuZXh0IG9uZVxuICogICAtIGBOb2RlYDogUmVwbGFjZSB0aGUgY3VycmVudCBub2RlLCB0aGVuIGNvbnRpbnVlIGJ5IHZpc2l0aW5nIGl0XG4gKiAgIC0gYG51bWJlcmA6IFdoaWxlIGl0ZXJhdGluZyB0aGUgaXRlbXMgb2YgYSBzZXF1ZW5jZSBvciBtYXAsIHNldCB0aGUgaW5kZXhcbiAqICAgICBvZiB0aGUgbmV4dCBzdGVwLiBUaGlzIGlzIHVzZWZ1bCBlc3BlY2lhbGx5IGlmIHRoZSBpbmRleCBvZiB0aGUgY3VycmVudFxuICogICAgIG5vZGUgaGFzIGNoYW5nZWQuXG4gKlxuICogSWYgYHZpc2l0b3JgIGlzIGEgc2luZ2xlIGZ1bmN0aW9uLCBpdCB3aWxsIGJlIGNhbGxlZCB3aXRoIGFsbCB2YWx1ZXNcbiAqIGVuY291bnRlcmVkIGluIHRoZSB0cmVlLCBpbmNsdWRpbmcgZS5nLiBgbnVsbGAgdmFsdWVzLiBBbHRlcm5hdGl2ZWx5LFxuICogc2VwYXJhdGUgdmlzaXRvciBmdW5jdGlvbnMgbWF5IGJlIGRlZmluZWQgZm9yIGVhY2ggYE1hcGAsIGBQYWlyYCwgYFNlcWAsXG4gKiBgQWxpYXNgIGFuZCBgU2NhbGFyYCBub2RlLiBUbyBkZWZpbmUgdGhlIHNhbWUgdmlzaXRvciBmdW5jdGlvbiBmb3IgbW9yZSB0aGFuXG4gKiBvbmUgbm9kZSB0eXBlLCB1c2UgdGhlIGBDb2xsZWN0aW9uYCAobWFwIGFuZCBzZXEpLCBgVmFsdWVgIChtYXAsIHNlcSAmIHNjYWxhcilcbiAqIGFuZCBgTm9kZWAgKGFsaWFzLCBtYXAsIHNlcSAmIHNjYWxhcikgdGFyZ2V0cy4gT2YgYWxsIHRoZXNlLCBvbmx5IHRoZSBtb3N0XG4gKiBzcGVjaWZpYyBkZWZpbmVkIG9uZSB3aWxsIGJlIHVzZWQgZm9yIGVhY2ggbm9kZS5cbiAqL1xuZnVuY3Rpb24gdmlzaXQobm9kZSwgdmlzaXRvcikge1xuICAgIGlmICh0eXBlb2YgdmlzaXRvciA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgKHZpc2l0b3IuQ29sbGVjdGlvbiB8fCB2aXNpdG9yLk5vZGUgfHwgdmlzaXRvci5WYWx1ZSkpIHtcbiAgICAgICAgdmlzaXRvciA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgQWxpYXM6IHZpc2l0b3IuTm9kZSxcbiAgICAgICAgICAgIE1hcDogdmlzaXRvci5Ob2RlLFxuICAgICAgICAgICAgU2NhbGFyOiB2aXNpdG9yLk5vZGUsXG4gICAgICAgICAgICBTZXE6IHZpc2l0b3IuTm9kZVxuICAgICAgICB9LCB2aXNpdG9yLlZhbHVlICYmIHtcbiAgICAgICAgICAgIE1hcDogdmlzaXRvci5WYWx1ZSxcbiAgICAgICAgICAgIFNjYWxhcjogdmlzaXRvci5WYWx1ZSxcbiAgICAgICAgICAgIFNlcTogdmlzaXRvci5WYWx1ZVxuICAgICAgICB9LCB2aXNpdG9yLkNvbGxlY3Rpb24gJiYge1xuICAgICAgICAgICAgTWFwOiB2aXNpdG9yLkNvbGxlY3Rpb24sXG4gICAgICAgICAgICBTZXE6IHZpc2l0b3IuQ29sbGVjdGlvblxuICAgICAgICB9LCB2aXNpdG9yKTtcbiAgICB9XG4gICAgaWYgKGlzRG9jdW1lbnQobm9kZSkpIHtcbiAgICAgICAgY29uc3QgY2QgPSBfdmlzaXQobnVsbCwgbm9kZS5jb250ZW50cywgdmlzaXRvciwgT2JqZWN0LmZyZWV6ZShbbm9kZV0pKTtcbiAgICAgICAgaWYgKGNkID09PSBSRU1PVkUpXG4gICAgICAgICAgICBub2RlLmNvbnRlbnRzID0gbnVsbDtcbiAgICB9XG4gICAgZWxzZVxuICAgICAgICBfdmlzaXQobnVsbCwgbm9kZSwgdmlzaXRvciwgT2JqZWN0LmZyZWV6ZShbXSkpO1xufVxuLy8gV2l0aG91dCB0aGUgYGFzIHN5bWJvbGAgY2FzdHMsIFRTIGRlY2xhcmVzIHRoZXNlIGluIHRoZSBgdmlzaXRgXG4vLyBuYW1lc3BhY2UgdXNpbmcgYHZhcmAsIGJ1dCB0aGVuIGNvbXBsYWlucyBhYm91dCB0aGF0IGJlY2F1c2Vcbi8vIGB1bmlxdWUgc3ltYm9sYCBtdXN0IGJlIGBjb25zdGAuXG4vKiogVGVybWluYXRlIHZpc2l0IHRyYXZlcnNhbCBjb21wbGV0ZWx5ICovXG52aXNpdC5CUkVBSyA9IEJSRUFLO1xuLyoqIERvIG5vdCB2aXNpdCB0aGUgY2hpbGRyZW4gb2YgdGhlIGN1cnJlbnQgbm9kZSAqL1xudmlzaXQuU0tJUCA9IFNLSVA7XG4vKiogUmVtb3ZlIHRoZSBjdXJyZW50IG5vZGUgKi9cbnZpc2l0LlJFTU9WRSA9IFJFTU9WRTtcbmZ1bmN0aW9uIF92aXNpdChrZXksIG5vZGUsIHZpc2l0b3IsIHBhdGgpIHtcbiAgICBsZXQgY3RybCA9IHVuZGVmaW5lZDtcbiAgICBpZiAodHlwZW9mIHZpc2l0b3IgPT09ICdmdW5jdGlvbicpXG4gICAgICAgIGN0cmwgPSB2aXNpdG9yKGtleSwgbm9kZSwgcGF0aCk7XG4gICAgZWxzZSBpZiAoaXNNYXAobm9kZSkpIHtcbiAgICAgICAgaWYgKHZpc2l0b3IuTWFwKVxuICAgICAgICAgICAgY3RybCA9IHZpc2l0b3IuTWFwKGtleSwgbm9kZSwgcGF0aCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzU2VxKG5vZGUpKSB7XG4gICAgICAgIGlmICh2aXNpdG9yLlNlcSlcbiAgICAgICAgICAgIGN0cmwgPSB2aXNpdG9yLlNlcShrZXksIG5vZGUsIHBhdGgpO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc1BhaXIobm9kZSkpIHtcbiAgICAgICAgaWYgKHZpc2l0b3IuUGFpcilcbiAgICAgICAgICAgIGN0cmwgPSB2aXNpdG9yLlBhaXIoa2V5LCBub2RlLCBwYXRoKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNTY2FsYXIobm9kZSkpIHtcbiAgICAgICAgaWYgKHZpc2l0b3IuU2NhbGFyKVxuICAgICAgICAgICAgY3RybCA9IHZpc2l0b3IuU2NhbGFyKGtleSwgbm9kZSwgcGF0aCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzQWxpYXMobm9kZSkpIHtcbiAgICAgICAgaWYgKHZpc2l0b3IuQWxpYXMpXG4gICAgICAgICAgICBjdHJsID0gdmlzaXRvci5BbGlhcyhrZXksIG5vZGUsIHBhdGgpO1xuICAgIH1cbiAgICBpZiAoaXNOb2RlKGN0cmwpIHx8IGlzUGFpcihjdHJsKSkge1xuICAgICAgICBjb25zdCBwYXJlbnQgPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV07XG4gICAgICAgIGlmIChpc0NvbGxlY3Rpb24ocGFyZW50KSkge1xuICAgICAgICAgICAgcGFyZW50Lml0ZW1zW2tleV0gPSBjdHJsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzUGFpcihwYXJlbnQpKSB7XG4gICAgICAgICAgICBpZiAoa2V5ID09PSAna2V5JylcbiAgICAgICAgICAgICAgICBwYXJlbnQua2V5ID0gY3RybDtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBwYXJlbnQudmFsdWUgPSBjdHJsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzRG9jdW1lbnQocGFyZW50KSkge1xuICAgICAgICAgICAgcGFyZW50LmNvbnRlbnRzID0gY3RybDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHB0ID0gaXNBbGlhcyhwYXJlbnQpID8gJ2FsaWFzJyA6ICdzY2FsYXInO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgcmVwbGFjZSBub2RlIHdpdGggJHtwdH0gcGFyZW50YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF92aXNpdChrZXksIGN0cmwsIHZpc2l0b3IsIHBhdGgpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGN0cmwgIT09ICdzeW1ib2wnKSB7XG4gICAgICAgIGlmIChpc0NvbGxlY3Rpb24obm9kZSkpIHtcbiAgICAgICAgICAgIHBhdGggPSBPYmplY3QuZnJlZXplKHBhdGguY29uY2F0KG5vZGUpKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5pdGVtcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNpID0gX3Zpc2l0KGksIG5vZGUuaXRlbXNbaV0sIHZpc2l0b3IsIHBhdGgpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY2kgPT09ICdudW1iZXInKVxuICAgICAgICAgICAgICAgICAgICBpID0gY2kgLSAxO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNpID09PSBCUkVBSylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEJSRUFLO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNpID09PSBSRU1PVkUpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5pdGVtcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIGkgLT0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNQYWlyKG5vZGUpKSB7XG4gICAgICAgICAgICBwYXRoID0gT2JqZWN0LmZyZWV6ZShwYXRoLmNvbmNhdChub2RlKSk7XG4gICAgICAgICAgICBjb25zdCBjayA9IF92aXNpdCgna2V5Jywgbm9kZS5rZXksIHZpc2l0b3IsIHBhdGgpO1xuICAgICAgICAgICAgaWYgKGNrID09PSBCUkVBSylcbiAgICAgICAgICAgICAgICByZXR1cm4gQlJFQUs7XG4gICAgICAgICAgICBlbHNlIGlmIChjayA9PT0gUkVNT1ZFKVxuICAgICAgICAgICAgICAgIG5vZGUua2V5ID0gbnVsbDtcbiAgICAgICAgICAgIGNvbnN0IGN2ID0gX3Zpc2l0KCd2YWx1ZScsIG5vZGUudmFsdWUsIHZpc2l0b3IsIHBhdGgpO1xuICAgICAgICAgICAgaWYgKGN2ID09PSBCUkVBSylcbiAgICAgICAgICAgICAgICByZXR1cm4gQlJFQUs7XG4gICAgICAgICAgICBlbHNlIGlmIChjdiA9PT0gUkVNT1ZFKVxuICAgICAgICAgICAgICAgIG5vZGUudmFsdWUgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjdHJsO1xufVxuXG5leHBvcnQgeyB2aXNpdCB9O1xuIiwgImltcG9ydCB7IGlzTm9kZSB9IGZyb20gJy4uL25vZGVzL05vZGUuanMnO1xuaW1wb3J0IHsgdmlzaXQgfSBmcm9tICcuLi92aXNpdC5qcyc7XG5cbmNvbnN0IGVzY2FwZUNoYXJzID0ge1xuICAgICchJzogJyUyMScsXG4gICAgJywnOiAnJTJDJyxcbiAgICAnWyc6ICclNUInLFxuICAgICddJzogJyU1RCcsXG4gICAgJ3snOiAnJTdCJyxcbiAgICAnfSc6ICclN0QnXG59O1xuY29uc3QgZXNjYXBlVGFnTmFtZSA9ICh0bikgPT4gdG4ucmVwbGFjZSgvWyEsW1xcXXt9XS9nLCBjaCA9PiBlc2NhcGVDaGFyc1tjaF0pO1xuY2xhc3MgRGlyZWN0aXZlcyB7XG4gICAgY29uc3RydWN0b3IoeWFtbCwgdGFncykge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGRpcmVjdGl2ZXMtZW5kL2RvYy1zdGFydCBtYXJrZXIgYC0tLWAuIElmIGBudWxsYCwgYSBtYXJrZXIgbWF5IHN0aWxsIGJlXG4gICAgICAgICAqIGluY2x1ZGVkIGluIHRoZSBkb2N1bWVudCdzIHN0cmluZ2lmaWVkIHJlcHJlc2VudGF0aW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5tYXJrZXIgPSBudWxsO1xuICAgICAgICB0aGlzLnlhbWwgPSBPYmplY3QuYXNzaWduKHt9LCBEaXJlY3RpdmVzLmRlZmF1bHRZYW1sLCB5YW1sKTtcbiAgICAgICAgdGhpcy50YWdzID0gT2JqZWN0LmFzc2lnbih7fSwgRGlyZWN0aXZlcy5kZWZhdWx0VGFncywgdGFncyk7XG4gICAgfVxuICAgIGNsb25lKCkge1xuICAgICAgICBjb25zdCBjb3B5ID0gbmV3IERpcmVjdGl2ZXModGhpcy55YW1sLCB0aGlzLnRhZ3MpO1xuICAgICAgICBjb3B5Lm1hcmtlciA9IHRoaXMubWFya2VyO1xuICAgICAgICByZXR1cm4gY29weTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRHVyaW5nIHBhcnNpbmcsIGdldCBhIERpcmVjdGl2ZXMgaW5zdGFuY2UgZm9yIHRoZSBjdXJyZW50IGRvY3VtZW50IGFuZFxuICAgICAqIHVwZGF0ZSB0aGUgc3RyZWFtIHN0YXRlIGFjY29yZGluZyB0byB0aGUgY3VycmVudCB2ZXJzaW9uJ3Mgc3BlYy5cbiAgICAgKi9cbiAgICBhdERvY3VtZW50KCkge1xuICAgICAgICBjb25zdCByZXMgPSBuZXcgRGlyZWN0aXZlcyh0aGlzLnlhbWwsIHRoaXMudGFncyk7XG4gICAgICAgIHN3aXRjaCAodGhpcy55YW1sLnZlcnNpb24pIHtcbiAgICAgICAgICAgIGNhc2UgJzEuMSc6XG4gICAgICAgICAgICAgICAgdGhpcy5hdE5leHREb2N1bWVudCA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICcxLjInOlxuICAgICAgICAgICAgICAgIHRoaXMuYXROZXh0RG9jdW1lbnQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLnlhbWwgPSB7XG4gICAgICAgICAgICAgICAgICAgIGV4cGxpY2l0OiBEaXJlY3RpdmVzLmRlZmF1bHRZYW1sLmV4cGxpY2l0LFxuICAgICAgICAgICAgICAgICAgICB2ZXJzaW9uOiAnMS4yJ1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdGhpcy50YWdzID0gT2JqZWN0LmFzc2lnbih7fSwgRGlyZWN0aXZlcy5kZWZhdWx0VGFncyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIG9uRXJyb3IgLSBNYXkgYmUgY2FsbGVkIGV2ZW4gaWYgdGhlIGFjdGlvbiB3YXMgc3VjY2Vzc2Z1bFxuICAgICAqIEByZXR1cm5zIGB0cnVlYCBvbiBzdWNjZXNzXG4gICAgICovXG4gICAgYWRkKGxpbmUsIG9uRXJyb3IpIHtcbiAgICAgICAgaWYgKHRoaXMuYXROZXh0RG9jdW1lbnQpIHtcbiAgICAgICAgICAgIHRoaXMueWFtbCA9IHsgZXhwbGljaXQ6IERpcmVjdGl2ZXMuZGVmYXVsdFlhbWwuZXhwbGljaXQsIHZlcnNpb246ICcxLjEnIH07XG4gICAgICAgICAgICB0aGlzLnRhZ3MgPSBPYmplY3QuYXNzaWduKHt9LCBEaXJlY3RpdmVzLmRlZmF1bHRUYWdzKTtcbiAgICAgICAgICAgIHRoaXMuYXROZXh0RG9jdW1lbnQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJ0cyA9IGxpbmUudHJpbSgpLnNwbGl0KC9bIFxcdF0rLyk7XG4gICAgICAgIGNvbnN0IG5hbWUgPSBwYXJ0cy5zaGlmdCgpO1xuICAgICAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgICAgICAgIGNhc2UgJyVUQUcnOiB7XG4gICAgICAgICAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCAhPT0gMikge1xuICAgICAgICAgICAgICAgICAgICBvbkVycm9yKDAsICclVEFHIGRpcmVjdGl2ZSBzaG91bGQgY29udGFpbiBleGFjdGx5IHR3byBwYXJ0cycpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocGFydHMubGVuZ3RoIDwgMilcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgW2hhbmRsZSwgcHJlZml4XSA9IHBhcnRzO1xuICAgICAgICAgICAgICAgIHRoaXMudGFnc1toYW5kbGVdID0gcHJlZml4O1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnJVlBTUwnOiB7XG4gICAgICAgICAgICAgICAgdGhpcy55YW1sLmV4cGxpY2l0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAocGFydHMubGVuZ3RoIDwgMSkge1xuICAgICAgICAgICAgICAgICAgICBvbkVycm9yKDAsICclWUFNTCBkaXJlY3RpdmUgc2hvdWxkIGNvbnRhaW4gZXhhY3RseSBvbmUgcGFydCcpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IFt2ZXJzaW9uXSA9IHBhcnRzO1xuICAgICAgICAgICAgICAgIGlmICh2ZXJzaW9uID09PSAnMS4xJyB8fCB2ZXJzaW9uID09PSAnMS4yJykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnlhbWwudmVyc2lvbiA9IHZlcnNpb247XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgb25FcnJvcig2LCBgVW5zdXBwb3J0ZWQgWUFNTCB2ZXJzaW9uICR7dmVyc2lvbn1gLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgb25FcnJvcigwLCBgVW5rbm93biBkaXJlY3RpdmUgJHtuYW1lfWAsIHRydWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXNvbHZlcyBhIHRhZywgbWF0Y2hpbmcgaGFuZGxlcyB0byB0aG9zZSBkZWZpbmVkIGluICVUQUcgZGlyZWN0aXZlcy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFJlc29sdmVkIHRhZywgd2hpY2ggbWF5IGFsc28gYmUgdGhlIG5vbi1zcGVjaWZpYyB0YWcgYCchJ2Agb3IgYVxuICAgICAqICAgYCchbG9jYWwnYCB0YWcsIG9yIGBudWxsYCBpZiB1bnJlc29sdmFibGUuXG4gICAgICovXG4gICAgdGFnTmFtZShzb3VyY2UsIG9uRXJyb3IpIHtcbiAgICAgICAgaWYgKHNvdXJjZSA9PT0gJyEnKVxuICAgICAgICAgICAgcmV0dXJuICchJzsgLy8gbm9uLXNwZWNpZmljIHRhZ1xuICAgICAgICBpZiAoc291cmNlWzBdICE9PSAnIScpIHtcbiAgICAgICAgICAgIG9uRXJyb3IoYE5vdCBhIHZhbGlkIHRhZzogJHtzb3VyY2V9YCk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc291cmNlWzFdID09PSAnPCcpIHtcbiAgICAgICAgICAgIGNvbnN0IHZlcmJhdGltID0gc291cmNlLnNsaWNlKDIsIC0xKTtcbiAgICAgICAgICAgIGlmICh2ZXJiYXRpbSA9PT0gJyEnIHx8IHZlcmJhdGltID09PSAnISEnKSB7XG4gICAgICAgICAgICAgICAgb25FcnJvcihgVmVyYmF0aW0gdGFncyBhcmVuJ3QgcmVzb2x2ZWQsIHNvICR7c291cmNlfSBpcyBpbnZhbGlkLmApO1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNvdXJjZVtzb3VyY2UubGVuZ3RoIC0gMV0gIT09ICc+JylcbiAgICAgICAgICAgICAgICBvbkVycm9yKCdWZXJiYXRpbSB0YWdzIG11c3QgZW5kIHdpdGggYSA+Jyk7XG4gICAgICAgICAgICByZXR1cm4gdmVyYmF0aW07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgWywgaGFuZGxlLCBzdWZmaXhdID0gc291cmNlLm1hdGNoKC9eKC4qISkoW14hXSopJC8pO1xuICAgICAgICBpZiAoIXN1ZmZpeClcbiAgICAgICAgICAgIG9uRXJyb3IoYFRoZSAke3NvdXJjZX0gdGFnIGhhcyBubyBzdWZmaXhgKTtcbiAgICAgICAgY29uc3QgcHJlZml4ID0gdGhpcy50YWdzW2hhbmRsZV07XG4gICAgICAgIGlmIChwcmVmaXgpXG4gICAgICAgICAgICByZXR1cm4gcHJlZml4ICsgZGVjb2RlVVJJQ29tcG9uZW50KHN1ZmZpeCk7XG4gICAgICAgIGlmIChoYW5kbGUgPT09ICchJylcbiAgICAgICAgICAgIHJldHVybiBzb3VyY2U7IC8vIGxvY2FsIHRhZ1xuICAgICAgICBvbkVycm9yKGBDb3VsZCBub3QgcmVzb2x2ZSB0YWc6ICR7c291cmNlfWApO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2l2ZW4gYSBmdWxseSByZXNvbHZlZCB0YWcsIHJldHVybnMgaXRzIHByaW50YWJsZSBzdHJpbmcgZm9ybSxcbiAgICAgKiB0YWtpbmcgaW50byBhY2NvdW50IGN1cnJlbnQgdGFnIHByZWZpeGVzIGFuZCBkZWZhdWx0cy5cbiAgICAgKi9cbiAgICB0YWdTdHJpbmcodGFnKSB7XG4gICAgICAgIGZvciAoY29uc3QgW2hhbmRsZSwgcHJlZml4XSBvZiBPYmplY3QuZW50cmllcyh0aGlzLnRhZ3MpKSB7XG4gICAgICAgICAgICBpZiAodGFnLnN0YXJ0c1dpdGgocHJlZml4KSlcbiAgICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlICsgZXNjYXBlVGFnTmFtZSh0YWcuc3Vic3RyaW5nKHByZWZpeC5sZW5ndGgpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGFnWzBdID09PSAnIScgPyB0YWcgOiBgITwke3RhZ30+YDtcbiAgICB9XG4gICAgdG9TdHJpbmcoZG9jKSB7XG4gICAgICAgIGNvbnN0IGxpbmVzID0gdGhpcy55YW1sLmV4cGxpY2l0XG4gICAgICAgICAgICA/IFtgJVlBTUwgJHt0aGlzLnlhbWwudmVyc2lvbiB8fCAnMS4yJ31gXVxuICAgICAgICAgICAgOiBbXTtcbiAgICAgICAgY29uc3QgdGFnRW50cmllcyA9IE9iamVjdC5lbnRyaWVzKHRoaXMudGFncyk7XG4gICAgICAgIGxldCB0YWdOYW1lcztcbiAgICAgICAgaWYgKGRvYyAmJiB0YWdFbnRyaWVzLmxlbmd0aCA+IDAgJiYgaXNOb2RlKGRvYy5jb250ZW50cykpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZ3MgPSB7fTtcbiAgICAgICAgICAgIHZpc2l0KGRvYy5jb250ZW50cywgKF9rZXksIG5vZGUpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoaXNOb2RlKG5vZGUpICYmIG5vZGUudGFnKVxuICAgICAgICAgICAgICAgICAgICB0YWdzW25vZGUudGFnXSA9IHRydWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRhZ05hbWVzID0gT2JqZWN0LmtleXModGFncyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGFnTmFtZXMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBbaGFuZGxlLCBwcmVmaXhdIG9mIHRhZ0VudHJpZXMpIHtcbiAgICAgICAgICAgIGlmIChoYW5kbGUgPT09ICchIScgJiYgcHJlZml4ID09PSAndGFnOnlhbWwub3JnLDIwMDI6JylcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGlmICghZG9jIHx8IHRhZ05hbWVzLnNvbWUodG4gPT4gdG4uc3RhcnRzV2l0aChwcmVmaXgpKSlcbiAgICAgICAgICAgICAgICBsaW5lcy5wdXNoKGAlVEFHICR7aGFuZGxlfSAke3ByZWZpeH1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGluZXMuam9pbignXFxuJyk7XG4gICAgfVxufVxuRGlyZWN0aXZlcy5kZWZhdWx0WWFtbCA9IHsgZXhwbGljaXQ6IGZhbHNlLCB2ZXJzaW9uOiAnMS4yJyB9O1xuRGlyZWN0aXZlcy5kZWZhdWx0VGFncyA9IHsgJyEhJzogJ3RhZzp5YW1sLm9yZywyMDAyOicgfTtcblxuZXhwb3J0IHsgRGlyZWN0aXZlcyB9O1xuIiwgImltcG9ydCB7IGlzU2NhbGFyLCBpc0NvbGxlY3Rpb24gfSBmcm9tICcuLi9ub2Rlcy9Ob2RlLmpzJztcbmltcG9ydCB7IHZpc2l0IH0gZnJvbSAnLi4vdmlzaXQuanMnO1xuXG4vKipcbiAqIFZlcmlmeSB0aGF0IHRoZSBpbnB1dCBzdHJpbmcgaXMgYSB2YWxpZCBhbmNob3IuXG4gKlxuICogV2lsbCB0aHJvdyBvbiBlcnJvcnMuXG4gKi9cbmZ1bmN0aW9uIGFuY2hvcklzVmFsaWQoYW5jaG9yKSB7XG4gICAgaWYgKC9bXFx4MDAtXFx4MTlcXHMsW1xcXXt9XS8udGVzdChhbmNob3IpKSB7XG4gICAgICAgIGNvbnN0IHNhID0gSlNPTi5zdHJpbmdpZnkoYW5jaG9yKTtcbiAgICAgICAgY29uc3QgbXNnID0gYEFuY2hvciBtdXN0IG5vdCBjb250YWluIHdoaXRlc3BhY2Ugb3IgY29udHJvbCBjaGFyYWN0ZXJzOiAke3NhfWA7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGFuY2hvck5hbWVzKHJvb3QpIHtcbiAgICBjb25zdCBhbmNob3JzID0gbmV3IFNldCgpO1xuICAgIHZpc2l0KHJvb3QsIHtcbiAgICAgICAgVmFsdWUoX2tleSwgbm9kZSkge1xuICAgICAgICAgICAgaWYgKG5vZGUuYW5jaG9yKVxuICAgICAgICAgICAgICAgIGFuY2hvcnMuYWRkKG5vZGUuYW5jaG9yKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBhbmNob3JzO1xufVxuLyoqIEZpbmQgYSBuZXcgYW5jaG9yIG5hbWUgd2l0aCB0aGUgZ2l2ZW4gYHByZWZpeGAgYW5kIGEgb25lLWluZGV4ZWQgc3VmZml4LiAqL1xuZnVuY3Rpb24gZmluZE5ld0FuY2hvcihwcmVmaXgsIGV4Y2x1ZGUpIHtcbiAgICBmb3IgKGxldCBpID0gMTsgdHJ1ZTsgKytpKSB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSBgJHtwcmVmaXh9JHtpfWA7XG4gICAgICAgIGlmICghZXhjbHVkZS5oYXMobmFtZSkpXG4gICAgICAgICAgICByZXR1cm4gbmFtZTtcbiAgICB9XG59XG5mdW5jdGlvbiBjcmVhdGVOb2RlQW5jaG9ycyhkb2MsIHByZWZpeCkge1xuICAgIGNvbnN0IGFsaWFzT2JqZWN0cyA9IFtdO1xuICAgIGNvbnN0IHNvdXJjZU9iamVjdHMgPSBuZXcgTWFwKCk7XG4gICAgbGV0IHByZXZBbmNob3JzID0gbnVsbDtcbiAgICByZXR1cm4ge1xuICAgICAgICBvbkFuY2hvcihzb3VyY2UpIHtcbiAgICAgICAgICAgIGFsaWFzT2JqZWN0cy5wdXNoKHNvdXJjZSk7XG4gICAgICAgICAgICBpZiAoIXByZXZBbmNob3JzKVxuICAgICAgICAgICAgICAgIHByZXZBbmNob3JzID0gYW5jaG9yTmFtZXMoZG9jKTtcbiAgICAgICAgICAgIGNvbnN0IGFuY2hvciA9IGZpbmROZXdBbmNob3IocHJlZml4LCBwcmV2QW5jaG9ycyk7XG4gICAgICAgICAgICBwcmV2QW5jaG9ycy5hZGQoYW5jaG9yKTtcbiAgICAgICAgICAgIHJldHVybiBhbmNob3I7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaXRoIGNpcmN1bGFyIHJlZmVyZW5jZXMsIHRoZSBzb3VyY2Ugbm9kZSBpcyBvbmx5IHJlc29sdmVkIGFmdGVyIGFsbFxuICAgICAgICAgKiBvZiBpdHMgY2hpbGQgbm9kZXMgYXJlLiBUaGlzIGlzIHdoeSBhbmNob3JzIGFyZSBzZXQgb25seSBhZnRlciBhbGwgb2ZcbiAgICAgICAgICogdGhlIG5vZGVzIGhhdmUgYmVlbiBjcmVhdGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgc2V0QW5jaG9ycygpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3Qgc291cmNlIG9mIGFsaWFzT2JqZWN0cykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlZiA9IHNvdXJjZU9iamVjdHMuZ2V0KHNvdXJjZSk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiByZWYgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICAgICAgICAgIHJlZi5hbmNob3IgJiZcbiAgICAgICAgICAgICAgICAgICAgKGlzU2NhbGFyKHJlZi5ub2RlKSB8fCBpc0NvbGxlY3Rpb24ocmVmLm5vZGUpKSkge1xuICAgICAgICAgICAgICAgICAgICByZWYubm9kZS5hbmNob3IgPSByZWYuYW5jaG9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoJ0ZhaWxlZCB0byByZXNvbHZlIHJlcGVhdGVkIG9iamVjdCAodGhpcyBzaG91bGQgbm90IGhhcHBlbiknKTtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3Iuc291cmNlID0gc291cmNlO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHNvdXJjZU9iamVjdHNcbiAgICB9O1xufVxuXG5leHBvcnQgeyBhbmNob3JJc1ZhbGlkLCBhbmNob3JOYW1lcywgY3JlYXRlTm9kZUFuY2hvcnMsIGZpbmROZXdBbmNob3IgfTtcbiIsICJpbXBvcnQgeyBhbmNob3JJc1ZhbGlkIH0gZnJvbSAnLi4vZG9jL2FuY2hvcnMuanMnO1xuaW1wb3J0IHsgdmlzaXQgfSBmcm9tICcuLi92aXNpdC5qcyc7XG5pbXBvcnQgeyBOb2RlQmFzZSwgQUxJQVMsIGlzQWxpYXMsIGlzQ29sbGVjdGlvbiwgaXNQYWlyIH0gZnJvbSAnLi9Ob2RlLmpzJztcblxuY2xhc3MgQWxpYXMgZXh0ZW5kcyBOb2RlQmFzZSB7XG4gICAgY29uc3RydWN0b3Ioc291cmNlKSB7XG4gICAgICAgIHN1cGVyKEFMSUFTKTtcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAndGFnJywge1xuICAgICAgICAgICAgc2V0KCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQWxpYXMgbm9kZXMgY2Fubm90IGhhdmUgdGFncycpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVzb2x2ZSB0aGUgdmFsdWUgb2YgdGhpcyBhbGlhcyB3aXRoaW4gYGRvY2AsIGZpbmRpbmcgdGhlIGxhc3RcbiAgICAgKiBpbnN0YW5jZSBvZiB0aGUgYHNvdXJjZWAgYW5jaG9yIGJlZm9yZSB0aGlzIG5vZGUuXG4gICAgICovXG4gICAgcmVzb2x2ZShkb2MpIHtcbiAgICAgICAgbGV0IGZvdW5kID0gdW5kZWZpbmVkO1xuICAgICAgICB2aXNpdChkb2MsIHtcbiAgICAgICAgICAgIE5vZGU6IChfa2V5LCBub2RlKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUgPT09IHRoaXMpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2aXNpdC5CUkVBSztcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5hbmNob3IgPT09IHRoaXMuc291cmNlKVxuICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IG5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZm91bmQ7XG4gICAgfVxuICAgIHRvSlNPTihfYXJnLCBjdHgpIHtcbiAgICAgICAgaWYgKCFjdHgpXG4gICAgICAgICAgICByZXR1cm4geyBzb3VyY2U6IHRoaXMuc291cmNlIH07XG4gICAgICAgIGNvbnN0IHsgYW5jaG9ycywgZG9jLCBtYXhBbGlhc0NvdW50IH0gPSBjdHg7XG4gICAgICAgIGNvbnN0IHNvdXJjZSA9IHRoaXMucmVzb2x2ZShkb2MpO1xuICAgICAgICBpZiAoIXNvdXJjZSkge1xuICAgICAgICAgICAgY29uc3QgbXNnID0gYFVucmVzb2x2ZWQgYWxpYXMgKHRoZSBhbmNob3IgbXVzdCBiZSBzZXQgYmVmb3JlIHRoZSBhbGlhcyk6ICR7dGhpcy5zb3VyY2V9YDtcbiAgICAgICAgICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihtc2cpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRhdGEgPSBhbmNob3JzLmdldChzb3VyY2UpO1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKCFkYXRhIHx8IGRhdGEucmVzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IG1zZyA9ICdUaGlzIHNob3VsZCBub3QgaGFwcGVuOiBBbGlhcyBhbmNob3Igd2FzIG5vdCByZXNvbHZlZD8nO1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKG1zZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1heEFsaWFzQ291bnQgPj0gMCkge1xuICAgICAgICAgICAgZGF0YS5jb3VudCArPSAxO1xuICAgICAgICAgICAgaWYgKGRhdGEuYWxpYXNDb3VudCA9PT0gMClcbiAgICAgICAgICAgICAgICBkYXRhLmFsaWFzQ291bnQgPSBnZXRBbGlhc0NvdW50KGRvYywgc291cmNlLCBhbmNob3JzKTtcbiAgICAgICAgICAgIGlmIChkYXRhLmNvdW50ICogZGF0YS5hbGlhc0NvdW50ID4gbWF4QWxpYXNDb3VudCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1zZyA9ICdFeGNlc3NpdmUgYWxpYXMgY291bnQgaW5kaWNhdGVzIGEgcmVzb3VyY2UgZXhoYXVzdGlvbiBhdHRhY2snO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihtc2cpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRhLnJlcztcbiAgICB9XG4gICAgdG9TdHJpbmcoY3R4LCBfb25Db21tZW50LCBfb25DaG9tcEtlZXApIHtcbiAgICAgICAgY29uc3Qgc3JjID0gYCoke3RoaXMuc291cmNlfWA7XG4gICAgICAgIGlmIChjdHgpIHtcbiAgICAgICAgICAgIGFuY2hvcklzVmFsaWQodGhpcy5zb3VyY2UpO1xuICAgICAgICAgICAgaWYgKGN0eC5vcHRpb25zLnZlcmlmeUFsaWFzT3JkZXIgJiYgIWN0eC5hbmNob3JzLmhhcyh0aGlzLnNvdXJjZSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtc2cgPSBgVW5yZXNvbHZlZCBhbGlhcyAodGhlIGFuY2hvciBtdXN0IGJlIHNldCBiZWZvcmUgdGhlIGFsaWFzKTogJHt0aGlzLnNvdXJjZX1gO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGN0eC5pbXBsaWNpdEtleSlcbiAgICAgICAgICAgICAgICByZXR1cm4gYCR7c3JjfSBgO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzcmM7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0QWxpYXNDb3VudChkb2MsIG5vZGUsIGFuY2hvcnMpIHtcbiAgICBpZiAoaXNBbGlhcyhub2RlKSkge1xuICAgICAgICBjb25zdCBzb3VyY2UgPSBub2RlLnJlc29sdmUoZG9jKTtcbiAgICAgICAgY29uc3QgYW5jaG9yID0gYW5jaG9ycyAmJiBzb3VyY2UgJiYgYW5jaG9ycy5nZXQoc291cmNlKTtcbiAgICAgICAgcmV0dXJuIGFuY2hvciA/IGFuY2hvci5jb3VudCAqIGFuY2hvci5hbGlhc0NvdW50IDogMDtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNDb2xsZWN0aW9uKG5vZGUpKSB7XG4gICAgICAgIGxldCBjb3VudCA9IDA7XG4gICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBub2RlLml0ZW1zKSB7XG4gICAgICAgICAgICBjb25zdCBjID0gZ2V0QWxpYXNDb3VudChkb2MsIGl0ZW0sIGFuY2hvcnMpO1xuICAgICAgICAgICAgaWYgKGMgPiBjb3VudClcbiAgICAgICAgICAgICAgICBjb3VudCA9IGM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvdW50O1xuICAgIH1cbiAgICBlbHNlIGlmIChpc1BhaXIobm9kZSkpIHtcbiAgICAgICAgY29uc3Qga2MgPSBnZXRBbGlhc0NvdW50KGRvYywgbm9kZS5rZXksIGFuY2hvcnMpO1xuICAgICAgICBjb25zdCB2YyA9IGdldEFsaWFzQ291bnQoZG9jLCBub2RlLnZhbHVlLCBhbmNob3JzKTtcbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KGtjLCB2Yyk7XG4gICAgfVxuICAgIHJldHVybiAxO1xufVxuXG5leHBvcnQgeyBBbGlhcyB9O1xuIiwgImltcG9ydCB7IGhhc0FuY2hvciB9IGZyb20gJy4vTm9kZS5qcyc7XG5cbi8qKlxuICogUmVjdXJzaXZlbHkgY29udmVydCBhbnkgbm9kZSBvciBpdHMgY29udGVudHMgdG8gbmF0aXZlIEphdmFTY3JpcHRcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgaW5wdXQgdmFsdWVcbiAqIEBwYXJhbSBhcmcgLSBJZiBgdmFsdWVgIGRlZmluZXMgYSBgdG9KU09OKClgIG1ldGhvZCwgdXNlIHRoaXNcbiAqICAgYXMgaXRzIGZpcnN0IGFyZ3VtZW50XG4gKiBAcGFyYW0gY3R4IC0gQ29udmVyc2lvbiBjb250ZXh0LCBvcmlnaW5hbGx5IHNldCBpbiBEb2N1bWVudCN0b0pTKCkuIElmXG4gKiAgIGB7IGtlZXA6IHRydWUgfWAgaXMgbm90IHNldCwgb3V0cHV0IHNob3VsZCBiZSBzdWl0YWJsZSBmb3IgSlNPTlxuICogICBzdHJpbmdpZmljYXRpb24uXG4gKi9cbmZ1bmN0aW9uIHRvSlModmFsdWUsIGFyZywgY3R4KSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKVxuICAgICAgICByZXR1cm4gdmFsdWUubWFwKCh2LCBpKSA9PiB0b0pTKHYsIFN0cmluZyhpKSwgY3R4KSk7XG4gICAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZS50b0pTT04gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgaWYgKCFjdHggfHwgIWhhc0FuY2hvcih2YWx1ZSkpXG4gICAgICAgICAgICByZXR1cm4gdmFsdWUudG9KU09OKGFyZywgY3R4KTtcbiAgICAgICAgY29uc3QgZGF0YSA9IHsgYWxpYXNDb3VudDogMCwgY291bnQ6IDEsIHJlczogdW5kZWZpbmVkIH07XG4gICAgICAgIGN0eC5hbmNob3JzLnNldCh2YWx1ZSwgZGF0YSk7XG4gICAgICAgIGN0eC5vbkNyZWF0ZSA9IHJlcyA9PiB7XG4gICAgICAgICAgICBkYXRhLnJlcyA9IHJlcztcbiAgICAgICAgICAgIGRlbGV0ZSBjdHgub25DcmVhdGU7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlcyA9IHZhbHVlLnRvSlNPTihhcmcsIGN0eCk7XG4gICAgICAgIGlmIChjdHgub25DcmVhdGUpXG4gICAgICAgICAgICBjdHgub25DcmVhdGUocmVzKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2JpZ2ludCcgJiYgIShjdHggJiYgY3R4LmtlZXApKVxuICAgICAgICByZXR1cm4gTnVtYmVyKHZhbHVlKTtcbiAgICByZXR1cm4gdmFsdWU7XG59XG5cbmV4cG9ydCB7IHRvSlMgfTtcbiIsICJpbXBvcnQgeyBOb2RlQmFzZSwgU0NBTEFSIH0gZnJvbSAnLi9Ob2RlLmpzJztcbmltcG9ydCB7IHRvSlMgfSBmcm9tICcuL3RvSlMuanMnO1xuXG5jb25zdCBpc1NjYWxhclZhbHVlID0gKHZhbHVlKSA9PiAhdmFsdWUgfHwgKHR5cGVvZiB2YWx1ZSAhPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnKTtcbmNsYXNzIFNjYWxhciBleHRlbmRzIE5vZGVCYXNlIHtcbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZSkge1xuICAgICAgICBzdXBlcihTQ0FMQVIpO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIHRvSlNPTihhcmcsIGN0eCkge1xuICAgICAgICByZXR1cm4gY3R4ICYmIGN0eC5rZWVwID8gdGhpcy52YWx1ZSA6IHRvSlModGhpcy52YWx1ZSwgYXJnLCBjdHgpO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIFN0cmluZyh0aGlzLnZhbHVlKTtcbiAgICB9XG59XG5TY2FsYXIuQkxPQ0tfRk9MREVEID0gJ0JMT0NLX0ZPTERFRCc7XG5TY2FsYXIuQkxPQ0tfTElURVJBTCA9ICdCTE9DS19MSVRFUkFMJztcblNjYWxhci5QTEFJTiA9ICdQTEFJTic7XG5TY2FsYXIuUVVPVEVfRE9VQkxFID0gJ1FVT1RFX0RPVUJMRSc7XG5TY2FsYXIuUVVPVEVfU0lOR0xFID0gJ1FVT1RFX1NJTkdMRSc7XG5cbmV4cG9ydCB7IFNjYWxhciwgaXNTY2FsYXJWYWx1ZSB9O1xuIiwgImltcG9ydCB7IEFsaWFzIH0gZnJvbSAnLi4vbm9kZXMvQWxpYXMuanMnO1xuaW1wb3J0IHsgaXNOb2RlLCBpc1BhaXIsIE1BUCwgU0VRLCBpc0RvY3VtZW50IH0gZnJvbSAnLi4vbm9kZXMvTm9kZS5qcyc7XG5pbXBvcnQgeyBTY2FsYXIgfSBmcm9tICcuLi9ub2Rlcy9TY2FsYXIuanMnO1xuXG5jb25zdCBkZWZhdWx0VGFnUHJlZml4ID0gJ3RhZzp5YW1sLm9yZywyMDAyOic7XG5mdW5jdGlvbiBmaW5kVGFnT2JqZWN0KHZhbHVlLCB0YWdOYW1lLCB0YWdzKSB7XG4gICAgaWYgKHRhZ05hbWUpIHtcbiAgICAgICAgY29uc3QgbWF0Y2ggPSB0YWdzLmZpbHRlcih0ID0+IHQudGFnID09PSB0YWdOYW1lKTtcbiAgICAgICAgY29uc3QgdGFnT2JqID0gbWF0Y2guZmluZCh0ID0+ICF0LmZvcm1hdCkgfHwgbWF0Y2hbMF07XG4gICAgICAgIGlmICghdGFnT2JqKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUYWcgJHt0YWdOYW1lfSBub3QgZm91bmRgKTtcbiAgICAgICAgcmV0dXJuIHRhZ09iajtcbiAgICB9XG4gICAgcmV0dXJuIHRhZ3MuZmluZCh0ID0+IHQuaWRlbnRpZnkgJiYgdC5pZGVudGlmeSh2YWx1ZSkgJiYgIXQuZm9ybWF0KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZU5vZGUodmFsdWUsIHRhZ05hbWUsIGN0eCkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgaWYgKGlzRG9jdW1lbnQodmFsdWUpKVxuICAgICAgICB2YWx1ZSA9IHZhbHVlLmNvbnRlbnRzO1xuICAgIGlmIChpc05vZGUodmFsdWUpKVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgaWYgKGlzUGFpcih2YWx1ZSkpIHtcbiAgICAgICAgY29uc3QgbWFwID0gKF9iID0gKF9hID0gY3R4LnNjaGVtYVtNQVBdKS5jcmVhdGVOb2RlKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSwgY3R4LnNjaGVtYSwgbnVsbCwgY3R4KTtcbiAgICAgICAgbWFwLml0ZW1zLnB1c2godmFsdWUpO1xuICAgICAgICByZXR1cm4gbWFwO1xuICAgIH1cbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBTdHJpbmcgfHxcbiAgICAgICAgdmFsdWUgaW5zdGFuY2VvZiBOdW1iZXIgfHxcbiAgICAgICAgdmFsdWUgaW5zdGFuY2VvZiBCb29sZWFuIHx8XG4gICAgICAgICh0eXBlb2YgQmlnSW50ID09PSAnZnVuY3Rpb24nICYmIHZhbHVlIGluc3RhbmNlb2YgQmlnSW50KSAvLyBub3Qgc3VwcG9ydGVkIGV2ZXJ5d2hlcmVcbiAgICApIHtcbiAgICAgICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zZXJpYWxpemVqc29ucHJvcGVydHlcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS52YWx1ZU9mKCk7XG4gICAgfVxuICAgIGNvbnN0IHsgYWxpYXNEdXBsaWNhdGVPYmplY3RzLCBvbkFuY2hvciwgb25UYWdPYmosIHNjaGVtYSwgc291cmNlT2JqZWN0cyB9ID0gY3R4O1xuICAgIC8vIERldGVjdCBkdXBsaWNhdGUgcmVmZXJlbmNlcyB0byB0aGUgc2FtZSBvYmplY3QgJiB1c2UgQWxpYXMgbm9kZXMgZm9yIGFsbFxuICAgIC8vIGFmdGVyIGZpcnN0LiBUaGUgYHJlZmAgd3JhcHBlciBhbGxvd3MgZm9yIGNpcmN1bGFyIHJlZmVyZW5jZXMgdG8gcmVzb2x2ZS5cbiAgICBsZXQgcmVmID0gdW5kZWZpbmVkO1xuICAgIGlmIChhbGlhc0R1cGxpY2F0ZU9iamVjdHMgJiYgdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgICAgICByZWYgPSBzb3VyY2VPYmplY3RzLmdldCh2YWx1ZSk7XG4gICAgICAgIGlmIChyZWYpIHtcbiAgICAgICAgICAgIGlmICghcmVmLmFuY2hvcilcbiAgICAgICAgICAgICAgICByZWYuYW5jaG9yID0gb25BbmNob3IodmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBBbGlhcyhyZWYuYW5jaG9yKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlZiA9IHsgYW5jaG9yOiBudWxsLCBub2RlOiBudWxsIH07XG4gICAgICAgICAgICBzb3VyY2VPYmplY3RzLnNldCh2YWx1ZSwgcmVmKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAodGFnTmFtZSAmJiB0YWdOYW1lLnN0YXJ0c1dpdGgoJyEhJykpXG4gICAgICAgIHRhZ05hbWUgPSBkZWZhdWx0VGFnUHJlZml4ICsgdGFnTmFtZS5zbGljZSgyKTtcbiAgICBsZXQgdGFnT2JqID0gZmluZFRhZ09iamVjdCh2YWx1ZSwgdGFnTmFtZSwgc2NoZW1hLnRhZ3MpO1xuICAgIGlmICghdGFnT2JqKSB7XG4gICAgICAgIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUudG9KU09OID09PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS50b0pTT04oKTtcbiAgICAgICAgaWYgKCF2YWx1ZSB8fCB0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBjb25zdCBub2RlID0gbmV3IFNjYWxhcih2YWx1ZSk7XG4gICAgICAgICAgICBpZiAocmVmKVxuICAgICAgICAgICAgICAgIHJlZi5ub2RlID0gbm9kZTtcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICB9XG4gICAgICAgIHRhZ09iaiA9XG4gICAgICAgICAgICB2YWx1ZSBpbnN0YW5jZW9mIE1hcFxuICAgICAgICAgICAgICAgID8gc2NoZW1hW01BUF1cbiAgICAgICAgICAgICAgICA6IFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QodmFsdWUpXG4gICAgICAgICAgICAgICAgICAgID8gc2NoZW1hW1NFUV1cbiAgICAgICAgICAgICAgICAgICAgOiBzY2hlbWFbTUFQXTtcbiAgICB9XG4gICAgaWYgKG9uVGFnT2JqKSB7XG4gICAgICAgIG9uVGFnT2JqKHRhZ09iaik7XG4gICAgICAgIGRlbGV0ZSBjdHgub25UYWdPYmo7XG4gICAgfVxuICAgIGNvbnN0IG5vZGUgPSAodGFnT2JqID09PSBudWxsIHx8IHRhZ09iaiA9PT0gdm9pZCAwID8gdm9pZCAwIDogdGFnT2JqLmNyZWF0ZU5vZGUpXG4gICAgICAgID8gdGFnT2JqLmNyZWF0ZU5vZGUoY3R4LnNjaGVtYSwgdmFsdWUsIGN0eClcbiAgICAgICAgOiBuZXcgU2NhbGFyKHZhbHVlKTtcbiAgICBpZiAodGFnTmFtZSlcbiAgICAgICAgbm9kZS50YWcgPSB0YWdOYW1lO1xuICAgIGlmIChyZWYpXG4gICAgICAgIHJlZi5ub2RlID0gbm9kZTtcbiAgICByZXR1cm4gbm9kZTtcbn1cblxuZXhwb3J0IHsgY3JlYXRlTm9kZSB9O1xuIiwgImltcG9ydCB7IGNyZWF0ZU5vZGUgfSBmcm9tICcuLi9kb2MvY3JlYXRlTm9kZS5qcyc7XG5pbXBvcnQgeyBOb2RlQmFzZSwgaXNOb2RlLCBpc1BhaXIsIGlzQ29sbGVjdGlvbiwgaXNTY2FsYXIgfSBmcm9tICcuL05vZGUuanMnO1xuXG5mdW5jdGlvbiBjb2xsZWN0aW9uRnJvbVBhdGgoc2NoZW1hLCBwYXRoLCB2YWx1ZSkge1xuICAgIGxldCB2ID0gdmFsdWU7XG4gICAgZm9yIChsZXQgaSA9IHBhdGgubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgY29uc3QgayA9IHBhdGhbaV07XG4gICAgICAgIGlmICh0eXBlb2YgayA9PT0gJ251bWJlcicgJiYgTnVtYmVyLmlzSW50ZWdlcihrKSAmJiBrID49IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGEgPSBbXTtcbiAgICAgICAgICAgIGFba10gPSB2O1xuICAgICAgICAgICAgdiA9IGE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2ID0gbmV3IE1hcChbW2ssIHZdXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZU5vZGUodiwgdW5kZWZpbmVkLCB7XG4gICAgICAgIGFsaWFzRHVwbGljYXRlT2JqZWN0czogZmFsc2UsXG4gICAgICAgIGtlZXBVbmRlZmluZWQ6IGZhbHNlLFxuICAgICAgICBvbkFuY2hvcjogKCkgPT4ge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIHNob3VsZCBub3QgaGFwcGVuLCBwbGVhc2UgcmVwb3J0IGEgYnVnLicpO1xuICAgICAgICB9LFxuICAgICAgICBzY2hlbWEsXG4gICAgICAgIHNvdXJjZU9iamVjdHM6IG5ldyBNYXAoKVxuICAgIH0pO1xufVxuLy8gbnVsbCwgdW5kZWZpbmVkLCBvciBhbiBlbXB0eSBub24tc3RyaW5nIGl0ZXJhYmxlIChlLmcuIFtdKVxuY29uc3QgaXNFbXB0eVBhdGggPSAocGF0aCkgPT4gcGF0aCA9PSBudWxsIHx8XG4gICAgKHR5cGVvZiBwYXRoID09PSAnb2JqZWN0JyAmJiAhIXBhdGhbU3ltYm9sLml0ZXJhdG9yXSgpLm5leHQoKS5kb25lKTtcbmNsYXNzIENvbGxlY3Rpb24gZXh0ZW5kcyBOb2RlQmFzZSB7XG4gICAgY29uc3RydWN0b3IodHlwZSwgc2NoZW1hKSB7XG4gICAgICAgIHN1cGVyKHR5cGUpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3NjaGVtYScsIHtcbiAgICAgICAgICAgIHZhbHVlOiBzY2hlbWEsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBjb3B5IG9mIHRoaXMgY29sbGVjdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzY2hlbWEgLSBJZiBkZWZpbmVkLCBvdmVyd3JpdGVzIHRoZSBvcmlnaW5hbCdzIHNjaGVtYVxuICAgICAqL1xuICAgIGNsb25lKHNjaGVtYSkge1xuICAgICAgICBjb25zdCBjb3B5ID0gT2JqZWN0LmNyZWF0ZShPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcyksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHRoaXMpKTtcbiAgICAgICAgaWYgKHNjaGVtYSlcbiAgICAgICAgICAgIGNvcHkuc2NoZW1hID0gc2NoZW1hO1xuICAgICAgICBjb3B5Lml0ZW1zID0gY29weS5pdGVtcy5tYXAoaXQgPT4gaXNOb2RlKGl0KSB8fCBpc1BhaXIoaXQpID8gaXQuY2xvbmUoc2NoZW1hKSA6IGl0KTtcbiAgICAgICAgaWYgKHRoaXMucmFuZ2UpXG4gICAgICAgICAgICBjb3B5LnJhbmdlID0gdGhpcy5yYW5nZS5zbGljZSgpO1xuICAgICAgICByZXR1cm4gY29weTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBhIHZhbHVlIHRvIHRoZSBjb2xsZWN0aW9uLiBGb3IgYCEhbWFwYCBhbmQgYCEhb21hcGAgdGhlIHZhbHVlIG11c3RcbiAgICAgKiBiZSBhIFBhaXIgaW5zdGFuY2Ugb3IgYSBgeyBrZXksIHZhbHVlIH1gIG9iamVjdCwgd2hpY2ggbWF5IG5vdCBoYXZlIGEga2V5XG4gICAgICogdGhhdCBhbHJlYWR5IGV4aXN0cyBpbiB0aGUgbWFwLlxuICAgICAqL1xuICAgIGFkZEluKHBhdGgsIHZhbHVlKSB7XG4gICAgICAgIGlmIChpc0VtcHR5UGF0aChwYXRoKSlcbiAgICAgICAgICAgIHRoaXMuYWRkKHZhbHVlKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBba2V5LCAuLi5yZXN0XSA9IHBhdGg7XG4gICAgICAgICAgICBjb25zdCBub2RlID0gdGhpcy5nZXQoa2V5LCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChpc0NvbGxlY3Rpb24obm9kZSkpXG4gICAgICAgICAgICAgICAgbm9kZS5hZGRJbihyZXN0LCB2YWx1ZSk7XG4gICAgICAgICAgICBlbHNlIGlmIChub2RlID09PSB1bmRlZmluZWQgJiYgdGhpcy5zY2hlbWEpXG4gICAgICAgICAgICAgICAgdGhpcy5zZXQoa2V5LCBjb2xsZWN0aW9uRnJvbVBhdGgodGhpcy5zY2hlbWEsIHJlc3QsIHZhbHVlKSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBZQU1MIGNvbGxlY3Rpb24gYXQgJHtrZXl9LiBSZW1haW5pbmcgcGF0aDogJHtyZXN0fWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYSB2YWx1ZSBmcm9tIHRoZSBjb2xsZWN0aW9uLlxuICAgICAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgaXRlbSB3YXMgZm91bmQgYW5kIHJlbW92ZWQuXG4gICAgICovXG4gICAgZGVsZXRlSW4ocGF0aCkge1xuICAgICAgICBjb25zdCBba2V5LCAuLi5yZXN0XSA9IHBhdGg7XG4gICAgICAgIGlmIChyZXN0Lmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRlbGV0ZShrZXkpO1xuICAgICAgICBjb25zdCBub2RlID0gdGhpcy5nZXQoa2V5LCB0cnVlKTtcbiAgICAgICAgaWYgKGlzQ29sbGVjdGlvbihub2RlKSlcbiAgICAgICAgICAgIHJldHVybiBub2RlLmRlbGV0ZUluKHJlc3QpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIFlBTUwgY29sbGVjdGlvbiBhdCAke2tleX0uIFJlbWFpbmluZyBwYXRoOiAke3Jlc3R9YCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgaXRlbSBhdCBga2V5YCwgb3IgYHVuZGVmaW5lZGAgaWYgbm90IGZvdW5kLiBCeSBkZWZhdWx0IHVud3JhcHNcbiAgICAgKiBzY2FsYXIgdmFsdWVzIGZyb20gdGhlaXIgc3Vycm91bmRpbmcgbm9kZTsgdG8gZGlzYWJsZSBzZXQgYGtlZXBTY2FsYXJgIHRvXG4gICAgICogYHRydWVgIChjb2xsZWN0aW9ucyBhcmUgYWx3YXlzIHJldHVybmVkIGludGFjdCkuXG4gICAgICovXG4gICAgZ2V0SW4ocGF0aCwga2VlcFNjYWxhcikge1xuICAgICAgICBjb25zdCBba2V5LCAuLi5yZXN0XSA9IHBhdGg7XG4gICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLmdldChrZXksIHRydWUpO1xuICAgICAgICBpZiAocmVzdC5sZW5ndGggPT09IDApXG4gICAgICAgICAgICByZXR1cm4gIWtlZXBTY2FsYXIgJiYgaXNTY2FsYXIobm9kZSkgPyBub2RlLnZhbHVlIDogbm9kZTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIGlzQ29sbGVjdGlvbihub2RlKSA/IG5vZGUuZ2V0SW4ocmVzdCwga2VlcFNjYWxhcikgOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGhhc0FsbE51bGxWYWx1ZXMoYWxsb3dTY2FsYXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXRlbXMuZXZlcnkobm9kZSA9PiB7XG4gICAgICAgICAgICBpZiAoIWlzUGFpcihub2RlKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBjb25zdCBuID0gbm9kZS52YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiAobiA9PSBudWxsIHx8XG4gICAgICAgICAgICAgICAgKGFsbG93U2NhbGFyICYmXG4gICAgICAgICAgICAgICAgICAgIGlzU2NhbGFyKG4pICYmXG4gICAgICAgICAgICAgICAgICAgIG4udmFsdWUgPT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgICAgICAhbi5jb21tZW50QmVmb3JlICYmXG4gICAgICAgICAgICAgICAgICAgICFuLmNvbW1lbnQgJiZcbiAgICAgICAgICAgICAgICAgICAgIW4udGFnKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGhlIGNvbGxlY3Rpb24gaW5jbHVkZXMgYSB2YWx1ZSB3aXRoIHRoZSBrZXkgYGtleWAuXG4gICAgICovXG4gICAgaGFzSW4ocGF0aCkge1xuICAgICAgICBjb25zdCBba2V5LCAuLi5yZXN0XSA9IHBhdGg7XG4gICAgICAgIGlmIChyZXN0Lmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmhhcyhrZXkpO1xuICAgICAgICBjb25zdCBub2RlID0gdGhpcy5nZXQoa2V5LCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIGlzQ29sbGVjdGlvbihub2RlKSA/IG5vZGUuaGFzSW4ocmVzdCkgOiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyBhIHZhbHVlIGluIHRoaXMgY29sbGVjdGlvbi4gRm9yIGAhIXNldGAsIGB2YWx1ZWAgbmVlZHMgdG8gYmUgYVxuICAgICAqIGJvb2xlYW4gdG8gYWRkL3JlbW92ZSB0aGUgaXRlbSBmcm9tIHRoZSBzZXQuXG4gICAgICovXG4gICAgc2V0SW4ocGF0aCwgdmFsdWUpIHtcbiAgICAgICAgY29uc3QgW2tleSwgLi4ucmVzdF0gPSBwYXRoO1xuICAgICAgICBpZiAocmVzdC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuZ2V0KGtleSwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAoaXNDb2xsZWN0aW9uKG5vZGUpKVxuICAgICAgICAgICAgICAgIG5vZGUuc2V0SW4ocmVzdCwgdmFsdWUpO1xuICAgICAgICAgICAgZWxzZSBpZiAobm9kZSA9PT0gdW5kZWZpbmVkICYmIHRoaXMuc2NoZW1hKVxuICAgICAgICAgICAgICAgIHRoaXMuc2V0KGtleSwgY29sbGVjdGlvbkZyb21QYXRoKHRoaXMuc2NoZW1hLCByZXN0LCB2YWx1ZSkpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgWUFNTCBjb2xsZWN0aW9uIGF0ICR7a2V5fS4gUmVtYWluaW5nIHBhdGg6ICR7cmVzdH1gKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbkNvbGxlY3Rpb24ubWF4Rmxvd1N0cmluZ1NpbmdsZUxpbmVMZW5ndGggPSA2MDtcblxuZXhwb3J0IHsgQ29sbGVjdGlvbiwgY29sbGVjdGlvbkZyb21QYXRoLCBpc0VtcHR5UGF0aCB9O1xuIiwgIi8qKlxuICogU3RyaW5naWZpZXMgYSBjb21tZW50LlxuICpcbiAqIEVtcHR5IGNvbW1lbnQgbGluZXMgYXJlIGxlZnQgZW1wdHksXG4gKiBsaW5lcyBjb25zaXN0aW5nIG9mIGEgc2luZ2xlIHNwYWNlIGFyZSByZXBsYWNlZCBieSBgI2AsXG4gKiBhbmQgYWxsIG90aGVyIGxpbmVzIGFyZSBwcmVmaXhlZCB3aXRoIGEgYCNgLlxuICovXG5jb25zdCBzdHJpbmdpZnlDb21tZW50ID0gKHN0cikgPT4gc3RyLnJlcGxhY2UoL14oPyEkKSg/OiAkKT8vZ20sICcjJyk7XG5mdW5jdGlvbiBpbmRlbnRDb21tZW50KGNvbW1lbnQsIGluZGVudCkge1xuICAgIGlmICgvXlxcbiskLy50ZXN0KGNvbW1lbnQpKVxuICAgICAgICByZXR1cm4gY29tbWVudC5zdWJzdHJpbmcoMSk7XG4gICAgcmV0dXJuIGluZGVudCA/IGNvbW1lbnQucmVwbGFjZSgvXig/ISAqJCkvZ20sIGluZGVudCkgOiBjb21tZW50O1xufVxuY29uc3QgbGluZUNvbW1lbnQgPSAoc3RyLCBpbmRlbnQsIGNvbW1lbnQpID0+IGNvbW1lbnQuaW5jbHVkZXMoJ1xcbicpXG4gICAgPyAnXFxuJyArIGluZGVudENvbW1lbnQoY29tbWVudCwgaW5kZW50KVxuICAgIDogKHN0ci5lbmRzV2l0aCgnICcpID8gJycgOiAnICcpICsgY29tbWVudDtcblxuZXhwb3J0IHsgaW5kZW50Q29tbWVudCwgbGluZUNvbW1lbnQsIHN0cmluZ2lmeUNvbW1lbnQgfTtcbiIsICJjb25zdCBGT0xEX0ZMT1cgPSAnZmxvdyc7XG5jb25zdCBGT0xEX0JMT0NLID0gJ2Jsb2NrJztcbmNvbnN0IEZPTERfUVVPVEVEID0gJ3F1b3RlZCc7XG4vKipcbiAqIFRyaWVzIHRvIGtlZXAgaW5wdXQgYXQgdXAgdG8gYGxpbmVXaWR0aGAgY2hhcmFjdGVycywgc3BsaXR0aW5nIG9ubHkgb24gc3BhY2VzXG4gKiBub3QgZm9sbG93ZWQgYnkgbmV3bGluZXMgb3Igc3BhY2VzIHVubGVzcyBgbW9kZWAgaXMgYCdxdW90ZWQnYC4gTGluZXMgYXJlXG4gKiB0ZXJtaW5hdGVkIHdpdGggYFxcbmAgYW5kIHN0YXJ0ZWQgd2l0aCBgaW5kZW50YC5cbiAqL1xuZnVuY3Rpb24gZm9sZEZsb3dMaW5lcyh0ZXh0LCBpbmRlbnQsIG1vZGUgPSAnZmxvdycsIHsgaW5kZW50QXRTdGFydCwgbGluZVdpZHRoID0gODAsIG1pbkNvbnRlbnRXaWR0aCA9IDIwLCBvbkZvbGQsIG9uT3ZlcmZsb3cgfSA9IHt9KSB7XG4gICAgaWYgKCFsaW5lV2lkdGggfHwgbGluZVdpZHRoIDwgMClcbiAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgY29uc3QgZW5kU3RlcCA9IE1hdGgubWF4KDEgKyBtaW5Db250ZW50V2lkdGgsIDEgKyBsaW5lV2lkdGggLSBpbmRlbnQubGVuZ3RoKTtcbiAgICBpZiAodGV4dC5sZW5ndGggPD0gZW5kU3RlcClcbiAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgY29uc3QgZm9sZHMgPSBbXTtcbiAgICBjb25zdCBlc2NhcGVkRm9sZHMgPSB7fTtcbiAgICBsZXQgZW5kID0gbGluZVdpZHRoIC0gaW5kZW50Lmxlbmd0aDtcbiAgICBpZiAodHlwZW9mIGluZGVudEF0U3RhcnQgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGlmIChpbmRlbnRBdFN0YXJ0ID4gbGluZVdpZHRoIC0gTWF0aC5tYXgoMiwgbWluQ29udGVudFdpZHRoKSlcbiAgICAgICAgICAgIGZvbGRzLnB1c2goMCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGVuZCA9IGxpbmVXaWR0aCAtIGluZGVudEF0U3RhcnQ7XG4gICAgfVxuICAgIGxldCBzcGxpdCA9IHVuZGVmaW5lZDtcbiAgICBsZXQgcHJldiA9IHVuZGVmaW5lZDtcbiAgICBsZXQgb3ZlcmZsb3cgPSBmYWxzZTtcbiAgICBsZXQgaSA9IC0xO1xuICAgIGxldCBlc2NTdGFydCA9IC0xO1xuICAgIGxldCBlc2NFbmQgPSAtMTtcbiAgICBpZiAobW9kZSA9PT0gRk9MRF9CTE9DSykge1xuICAgICAgICBpID0gY29uc3VtZU1vcmVJbmRlbnRlZExpbmVzKHRleHQsIGkpO1xuICAgICAgICBpZiAoaSAhPT0gLTEpXG4gICAgICAgICAgICBlbmQgPSBpICsgZW5kU3RlcDtcbiAgICB9XG4gICAgZm9yIChsZXQgY2g7IChjaCA9IHRleHRbKGkgKz0gMSldKTspIHtcbiAgICAgICAgaWYgKG1vZGUgPT09IEZPTERfUVVPVEVEICYmIGNoID09PSAnXFxcXCcpIHtcbiAgICAgICAgICAgIGVzY1N0YXJ0ID0gaTtcbiAgICAgICAgICAgIHN3aXRjaCAodGV4dFtpICsgMV0pIHtcbiAgICAgICAgICAgICAgICBjYXNlICd4JzpcbiAgICAgICAgICAgICAgICAgICAgaSArPSAzO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICd1JzpcbiAgICAgICAgICAgICAgICAgICAgaSArPSA1O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdVJzpcbiAgICAgICAgICAgICAgICAgICAgaSArPSA5O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBpICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlc2NFbmQgPSBpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaCA9PT0gJ1xcbicpIHtcbiAgICAgICAgICAgIGlmIChtb2RlID09PSBGT0xEX0JMT0NLKVxuICAgICAgICAgICAgICAgIGkgPSBjb25zdW1lTW9yZUluZGVudGVkTGluZXModGV4dCwgaSk7XG4gICAgICAgICAgICBlbmQgPSBpICsgZW5kU3RlcDtcbiAgICAgICAgICAgIHNwbGl0ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGNoID09PSAnICcgJiZcbiAgICAgICAgICAgICAgICBwcmV2ICYmXG4gICAgICAgICAgICAgICAgcHJldiAhPT0gJyAnICYmXG4gICAgICAgICAgICAgICAgcHJldiAhPT0gJ1xcbicgJiZcbiAgICAgICAgICAgICAgICBwcmV2ICE9PSAnXFx0Jykge1xuICAgICAgICAgICAgICAgIC8vIHNwYWNlIHN1cnJvdW5kZWQgYnkgbm9uLXNwYWNlIGNhbiBiZSByZXBsYWNlZCB3aXRoIG5ld2xpbmUgKyBpbmRlbnRcbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0ID0gdGV4dFtpICsgMV07XG4gICAgICAgICAgICAgICAgaWYgKG5leHQgJiYgbmV4dCAhPT0gJyAnICYmIG5leHQgIT09ICdcXG4nICYmIG5leHQgIT09ICdcXHQnKVxuICAgICAgICAgICAgICAgICAgICBzcGxpdCA9IGk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaSA+PSBlbmQpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3BsaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9sZHMucHVzaChzcGxpdCk7XG4gICAgICAgICAgICAgICAgICAgIGVuZCA9IHNwbGl0ICsgZW5kU3RlcDtcbiAgICAgICAgICAgICAgICAgICAgc3BsaXQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1vZGUgPT09IEZPTERfUVVPVEVEKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHdoaXRlLXNwYWNlIGNvbGxlY3RlZCBhdCBlbmQgbWF5IHN0cmV0Y2ggcGFzdCBsaW5lV2lkdGhcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHByZXYgPT09ICcgJyB8fCBwcmV2ID09PSAnXFx0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJldiA9IGNoO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2ggPSB0ZXh0WyhpICs9IDEpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJmbG93ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBBY2NvdW50IGZvciBuZXdsaW5lIGVzY2FwZSwgYnV0IGRvbid0IGJyZWFrIHByZWNlZGluZyBlc2NhcGVcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaiA9IGkgPiBlc2NFbmQgKyAxID8gaSAtIDIgOiBlc2NTdGFydCAtIDE7XG4gICAgICAgICAgICAgICAgICAgIC8vIEJhaWwgb3V0IGlmIGxpbmVXaWR0aCAmIG1pbkNvbnRlbnRXaWR0aCBhcmUgc2hvcnRlciB0aGFuIGFuIGVzY2FwZSBzdHJpbmdcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVzY2FwZWRGb2xkc1tqXSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0ZXh0O1xuICAgICAgICAgICAgICAgICAgICBmb2xkcy5wdXNoKGopO1xuICAgICAgICAgICAgICAgICAgICBlc2NhcGVkRm9sZHNbal0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBlbmQgPSBqICsgZW5kU3RlcDtcbiAgICAgICAgICAgICAgICAgICAgc3BsaXQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBvdmVyZmxvdyA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHByZXYgPSBjaDtcbiAgICB9XG4gICAgaWYgKG92ZXJmbG93ICYmIG9uT3ZlcmZsb3cpXG4gICAgICAgIG9uT3ZlcmZsb3coKTtcbiAgICBpZiAoZm9sZHMubGVuZ3RoID09PSAwKVxuICAgICAgICByZXR1cm4gdGV4dDtcbiAgICBpZiAob25Gb2xkKVxuICAgICAgICBvbkZvbGQoKTtcbiAgICBsZXQgcmVzID0gdGV4dC5zbGljZSgwLCBmb2xkc1swXSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmb2xkcy5sZW5ndGg7ICsraSkge1xuICAgICAgICBjb25zdCBmb2xkID0gZm9sZHNbaV07XG4gICAgICAgIGNvbnN0IGVuZCA9IGZvbGRzW2kgKyAxXSB8fCB0ZXh0Lmxlbmd0aDtcbiAgICAgICAgaWYgKGZvbGQgPT09IDApXG4gICAgICAgICAgICByZXMgPSBgXFxuJHtpbmRlbnR9JHt0ZXh0LnNsaWNlKDAsIGVuZCl9YDtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAobW9kZSA9PT0gRk9MRF9RVU9URUQgJiYgZXNjYXBlZEZvbGRzW2ZvbGRdKVxuICAgICAgICAgICAgICAgIHJlcyArPSBgJHt0ZXh0W2ZvbGRdfVxcXFxgO1xuICAgICAgICAgICAgcmVzICs9IGBcXG4ke2luZGVudH0ke3RleHQuc2xpY2UoZm9sZCArIDEsIGVuZCl9YDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuLyoqXG4gKiBQcmVzdW1lcyBgaSArIDFgIGlzIGF0IHRoZSBzdGFydCBvZiBhIGxpbmVcbiAqIEByZXR1cm5zIGluZGV4IG9mIGxhc3QgbmV3bGluZSBpbiBtb3JlLWluZGVudGVkIGJsb2NrXG4gKi9cbmZ1bmN0aW9uIGNvbnN1bWVNb3JlSW5kZW50ZWRMaW5lcyh0ZXh0LCBpKSB7XG4gICAgbGV0IGNoID0gdGV4dFtpICsgMV07XG4gICAgd2hpbGUgKGNoID09PSAnICcgfHwgY2ggPT09ICdcXHQnKSB7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIGNoID0gdGV4dFsoaSArPSAxKV07XG4gICAgICAgIH0gd2hpbGUgKGNoICYmIGNoICE9PSAnXFxuJyk7XG4gICAgICAgIGNoID0gdGV4dFtpICsgMV07XG4gICAgfVxuICAgIHJldHVybiBpO1xufVxuXG5leHBvcnQgeyBGT0xEX0JMT0NLLCBGT0xEX0ZMT1csIEZPTERfUVVPVEVELCBmb2xkRmxvd0xpbmVzIH07XG4iLCAiaW1wb3J0IHsgU2NhbGFyIH0gZnJvbSAnLi4vbm9kZXMvU2NhbGFyLmpzJztcbmltcG9ydCB7IGZvbGRGbG93TGluZXMsIEZPTERfUVVPVEVELCBGT0xEX0ZMT1csIEZPTERfQkxPQ0sgfSBmcm9tICcuL2ZvbGRGbG93TGluZXMuanMnO1xuXG5jb25zdCBnZXRGb2xkT3B0aW9ucyA9IChjdHgpID0+ICh7XG4gICAgaW5kZW50QXRTdGFydDogY3R4LmluZGVudEF0U3RhcnQsXG4gICAgbGluZVdpZHRoOiBjdHgub3B0aW9ucy5saW5lV2lkdGgsXG4gICAgbWluQ29udGVudFdpZHRoOiBjdHgub3B0aW9ucy5taW5Db250ZW50V2lkdGhcbn0pO1xuLy8gQWxzbyBjaGVja3MgZm9yIGxpbmVzIHN0YXJ0aW5nIHdpdGggJSwgYXMgcGFyc2luZyB0aGUgb3V0cHV0IGFzIFlBTUwgMS4xIHdpbGxcbi8vIHByZXN1bWUgdGhhdCdzIHN0YXJ0aW5nIGEgbmV3IGRvY3VtZW50LlxuY29uc3QgY29udGFpbnNEb2N1bWVudE1hcmtlciA9IChzdHIpID0+IC9eKCV8LS0tfFxcLlxcLlxcLikvbS50ZXN0KHN0cik7XG5mdW5jdGlvbiBsaW5lTGVuZ3RoT3ZlckxpbWl0KHN0ciwgbGluZVdpZHRoLCBpbmRlbnRMZW5ndGgpIHtcbiAgICBpZiAoIWxpbmVXaWR0aCB8fCBsaW5lV2lkdGggPCAwKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgY29uc3QgbGltaXQgPSBsaW5lV2lkdGggLSBpbmRlbnRMZW5ndGg7XG4gICAgY29uc3Qgc3RyTGVuID0gc3RyLmxlbmd0aDtcbiAgICBpZiAoc3RyTGVuIDw9IGxpbWl0KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgZm9yIChsZXQgaSA9IDAsIHN0YXJ0ID0gMDsgaSA8IHN0ckxlbjsgKytpKSB7XG4gICAgICAgIGlmIChzdHJbaV0gPT09ICdcXG4nKSB7XG4gICAgICAgICAgICBpZiAoaSAtIHN0YXJ0ID4gbGltaXQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBzdGFydCA9IGkgKyAxO1xuICAgICAgICAgICAgaWYgKHN0ckxlbiAtIHN0YXJ0IDw9IGxpbWl0KVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGRvdWJsZVF1b3RlZFN0cmluZyh2YWx1ZSwgY3R4KSB7XG4gICAgY29uc3QganNvbiA9IEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcbiAgICBpZiAoY3R4Lm9wdGlvbnMuZG91YmxlUXVvdGVkQXNKU09OKVxuICAgICAgICByZXR1cm4ganNvbjtcbiAgICBjb25zdCB7IGltcGxpY2l0S2V5IH0gPSBjdHg7XG4gICAgY29uc3QgbWluTXVsdGlMaW5lTGVuZ3RoID0gY3R4Lm9wdGlvbnMuZG91YmxlUXVvdGVkTWluTXVsdGlMaW5lTGVuZ3RoO1xuICAgIGNvbnN0IGluZGVudCA9IGN0eC5pbmRlbnQgfHwgKGNvbnRhaW5zRG9jdW1lbnRNYXJrZXIodmFsdWUpID8gJyAgJyA6ICcnKTtcbiAgICBsZXQgc3RyID0gJyc7XG4gICAgbGV0IHN0YXJ0ID0gMDtcbiAgICBmb3IgKGxldCBpID0gMCwgY2ggPSBqc29uW2ldOyBjaDsgY2ggPSBqc29uWysraV0pIHtcbiAgICAgICAgaWYgKGNoID09PSAnICcgJiYganNvbltpICsgMV0gPT09ICdcXFxcJyAmJiBqc29uW2kgKyAyXSA9PT0gJ24nKSB7XG4gICAgICAgICAgICAvLyBzcGFjZSBiZWZvcmUgbmV3bGluZSBuZWVkcyB0byBiZSBlc2NhcGVkIHRvIG5vdCBiZSBmb2xkZWRcbiAgICAgICAgICAgIHN0ciArPSBqc29uLnNsaWNlKHN0YXJ0LCBpKSArICdcXFxcICc7XG4gICAgICAgICAgICBpICs9IDE7XG4gICAgICAgICAgICBzdGFydCA9IGk7XG4gICAgICAgICAgICBjaCA9ICdcXFxcJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2ggPT09ICdcXFxcJylcbiAgICAgICAgICAgIHN3aXRjaCAoanNvbltpICsgMV0pIHtcbiAgICAgICAgICAgICAgICBjYXNlICd1JzpcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9IGpzb24uc2xpY2Uoc3RhcnQsIGkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY29kZSA9IGpzb24uc3Vic3RyKGkgKyAyLCA0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoY29kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJzAwMDAnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gJ1xcXFwwJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnMDAwNyc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSAnXFxcXGEnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICcwMDBiJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9ICdcXFxcdic7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJzAwMWInOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gJ1xcXFxlJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnMDA4NSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSAnXFxcXE4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICcwMGEwJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9ICdcXFxcXyc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJzIwMjgnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gJ1xcXFxMJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnMjAyOSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSAnXFxcXFAnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29kZS5zdWJzdHIoMCwgMikgPT09ICcwMCcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gJ1xcXFx4JyArIGNvZGUuc3Vic3RyKDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0ganNvbi5zdWJzdHIoaSwgNik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpICs9IDU7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydCA9IGkgKyAxO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ24nOlxuICAgICAgICAgICAgICAgICAgICBpZiAoaW1wbGljaXRLZXkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIGpzb25baSArIDJdID09PSAnXCInIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBqc29uLmxlbmd0aCA8IG1pbk11bHRpTGluZUxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaSArPSAxO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZm9sZGluZyB3aWxsIGVhdCBmaXJzdCBuZXdsaW5lXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0ganNvbi5zbGljZShzdGFydCwgaSkgKyAnXFxuXFxuJztcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChqc29uW2kgKyAyXSA9PT0gJ1xcXFwnICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAganNvbltpICsgM10gPT09ICduJyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpzb25baSArIDRdICE9PSAnXCInKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9ICdcXG4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgKz0gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSBpbmRlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzcGFjZSBhZnRlciBuZXdsaW5lIG5lZWRzIHRvIGJlIGVzY2FwZWQgdG8gbm90IGJlIGZvbGRlZFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGpzb25baSArIDJdID09PSAnICcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9ICdcXFxcJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gaSArIDE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaSArPSAxO1xuICAgICAgICAgICAgfVxuICAgIH1cbiAgICBzdHIgPSBzdGFydCA/IHN0ciArIGpzb24uc2xpY2Uoc3RhcnQpIDoganNvbjtcbiAgICByZXR1cm4gaW1wbGljaXRLZXlcbiAgICAgICAgPyBzdHJcbiAgICAgICAgOiBmb2xkRmxvd0xpbmVzKHN0ciwgaW5kZW50LCBGT0xEX1FVT1RFRCwgZ2V0Rm9sZE9wdGlvbnMoY3R4KSk7XG59XG5mdW5jdGlvbiBzaW5nbGVRdW90ZWRTdHJpbmcodmFsdWUsIGN0eCkge1xuICAgIGlmIChjdHgub3B0aW9ucy5zaW5nbGVRdW90ZSA9PT0gZmFsc2UgfHxcbiAgICAgICAgKGN0eC5pbXBsaWNpdEtleSAmJiB2YWx1ZS5pbmNsdWRlcygnXFxuJykpIHx8XG4gICAgICAgIC9bIFxcdF1cXG58XFxuWyBcXHRdLy50ZXN0KHZhbHVlKSAvLyBzaW5nbGUgcXVvdGVkIHN0cmluZyBjYW4ndCBoYXZlIGxlYWRpbmcgb3IgdHJhaWxpbmcgd2hpdGVzcGFjZSBhcm91bmQgbmV3bGluZVxuICAgIClcbiAgICAgICAgcmV0dXJuIGRvdWJsZVF1b3RlZFN0cmluZyh2YWx1ZSwgY3R4KTtcbiAgICBjb25zdCBpbmRlbnQgPSBjdHguaW5kZW50IHx8IChjb250YWluc0RvY3VtZW50TWFya2VyKHZhbHVlKSA/ICcgICcgOiAnJyk7XG4gICAgY29uc3QgcmVzID0gXCInXCIgKyB2YWx1ZS5yZXBsYWNlKC8nL2csIFwiJydcIikucmVwbGFjZSgvXFxuKy9nLCBgJCZcXG4ke2luZGVudH1gKSArIFwiJ1wiO1xuICAgIHJldHVybiBjdHguaW1wbGljaXRLZXlcbiAgICAgICAgPyByZXNcbiAgICAgICAgOiBmb2xkRmxvd0xpbmVzKHJlcywgaW5kZW50LCBGT0xEX0ZMT1csIGdldEZvbGRPcHRpb25zKGN0eCkpO1xufVxuZnVuY3Rpb24gcXVvdGVkU3RyaW5nKHZhbHVlLCBjdHgpIHtcbiAgICBjb25zdCB7IHNpbmdsZVF1b3RlIH0gPSBjdHgub3B0aW9ucztcbiAgICBsZXQgcXM7XG4gICAgaWYgKHNpbmdsZVF1b3RlID09PSBmYWxzZSlcbiAgICAgICAgcXMgPSBkb3VibGVRdW90ZWRTdHJpbmc7XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IGhhc0RvdWJsZSA9IHZhbHVlLmluY2x1ZGVzKCdcIicpO1xuICAgICAgICBjb25zdCBoYXNTaW5nbGUgPSB2YWx1ZS5pbmNsdWRlcyhcIidcIik7XG4gICAgICAgIGlmIChoYXNEb3VibGUgJiYgIWhhc1NpbmdsZSlcbiAgICAgICAgICAgIHFzID0gc2luZ2xlUXVvdGVkU3RyaW5nO1xuICAgICAgICBlbHNlIGlmIChoYXNTaW5nbGUgJiYgIWhhc0RvdWJsZSlcbiAgICAgICAgICAgIHFzID0gZG91YmxlUXVvdGVkU3RyaW5nO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBxcyA9IHNpbmdsZVF1b3RlID8gc2luZ2xlUXVvdGVkU3RyaW5nIDogZG91YmxlUXVvdGVkU3RyaW5nO1xuICAgIH1cbiAgICByZXR1cm4gcXModmFsdWUsIGN0eCk7XG59XG5mdW5jdGlvbiBibG9ja1N0cmluZyh7IGNvbW1lbnQsIHR5cGUsIHZhbHVlIH0sIGN0eCwgb25Db21tZW50LCBvbkNob21wS2VlcCkge1xuICAgIGNvbnN0IHsgYmxvY2tRdW90ZSwgY29tbWVudFN0cmluZywgbGluZVdpZHRoIH0gPSBjdHgub3B0aW9ucztcbiAgICAvLyAxLiBCbG9jayBjYW4ndCBlbmQgaW4gd2hpdGVzcGFjZSB1bmxlc3MgdGhlIGxhc3QgbGluZSBpcyBub24tZW1wdHkuXG4gICAgLy8gMi4gU3RyaW5ncyBjb25zaXN0aW5nIG9mIG9ubHkgd2hpdGVzcGFjZSBhcmUgYmVzdCByZW5kZXJlZCBleHBsaWNpdGx5LlxuICAgIGlmICghYmxvY2tRdW90ZSB8fCAvXFxuW1xcdCBdKyQvLnRlc3QodmFsdWUpIHx8IC9eXFxzKiQvLnRlc3QodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBxdW90ZWRTdHJpbmcodmFsdWUsIGN0eCk7XG4gICAgfVxuICAgIGNvbnN0IGluZGVudCA9IGN0eC5pbmRlbnQgfHxcbiAgICAgICAgKGN0eC5mb3JjZUJsb2NrSW5kZW50IHx8IGNvbnRhaW5zRG9jdW1lbnRNYXJrZXIodmFsdWUpID8gJyAgJyA6ICcnKTtcbiAgICBjb25zdCBsaXRlcmFsID0gYmxvY2tRdW90ZSA9PT0gJ2xpdGVyYWwnXG4gICAgICAgID8gdHJ1ZVxuICAgICAgICA6IGJsb2NrUXVvdGUgPT09ICdmb2xkZWQnIHx8IHR5cGUgPT09IFNjYWxhci5CTE9DS19GT0xERURcbiAgICAgICAgICAgID8gZmFsc2VcbiAgICAgICAgICAgIDogdHlwZSA9PT0gU2NhbGFyLkJMT0NLX0xJVEVSQUxcbiAgICAgICAgICAgICAgICA/IHRydWVcbiAgICAgICAgICAgICAgICA6ICFsaW5lTGVuZ3RoT3ZlckxpbWl0KHZhbHVlLCBsaW5lV2lkdGgsIGluZGVudC5sZW5ndGgpO1xuICAgIGlmICghdmFsdWUpXG4gICAgICAgIHJldHVybiBsaXRlcmFsID8gJ3xcXG4nIDogJz5cXG4nO1xuICAgIC8vIGRldGVybWluZSBjaG9tcGluZyBmcm9tIHdoaXRlc3BhY2UgYXQgdmFsdWUgZW5kXG4gICAgbGV0IGNob21wO1xuICAgIGxldCBlbmRTdGFydDtcbiAgICBmb3IgKGVuZFN0YXJ0ID0gdmFsdWUubGVuZ3RoOyBlbmRTdGFydCA+IDA7IC0tZW5kU3RhcnQpIHtcbiAgICAgICAgY29uc3QgY2ggPSB2YWx1ZVtlbmRTdGFydCAtIDFdO1xuICAgICAgICBpZiAoY2ggIT09ICdcXG4nICYmIGNoICE9PSAnXFx0JyAmJiBjaCAhPT0gJyAnKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGxldCBlbmQgPSB2YWx1ZS5zdWJzdHJpbmcoZW5kU3RhcnQpO1xuICAgIGNvbnN0IGVuZE5sUG9zID0gZW5kLmluZGV4T2YoJ1xcbicpO1xuICAgIGlmIChlbmRObFBvcyA9PT0gLTEpIHtcbiAgICAgICAgY2hvbXAgPSAnLSc7IC8vIHN0cmlwXG4gICAgfVxuICAgIGVsc2UgaWYgKHZhbHVlID09PSBlbmQgfHwgZW5kTmxQb3MgIT09IGVuZC5sZW5ndGggLSAxKSB7XG4gICAgICAgIGNob21wID0gJysnOyAvLyBrZWVwXG4gICAgICAgIGlmIChvbkNob21wS2VlcClcbiAgICAgICAgICAgIG9uQ2hvbXBLZWVwKCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjaG9tcCA9ICcnOyAvLyBjbGlwXG4gICAgfVxuICAgIGlmIChlbmQpIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5zbGljZSgwLCAtZW5kLmxlbmd0aCk7XG4gICAgICAgIGlmIChlbmRbZW5kLmxlbmd0aCAtIDFdID09PSAnXFxuJylcbiAgICAgICAgICAgIGVuZCA9IGVuZC5zbGljZSgwLCAtMSk7XG4gICAgICAgIGVuZCA9IGVuZC5yZXBsYWNlKC9cXG4rKD8hXFxufCQpL2csIGAkJiR7aW5kZW50fWApO1xuICAgIH1cbiAgICAvLyBkZXRlcm1pbmUgaW5kZW50IGluZGljYXRvciBmcm9tIHdoaXRlc3BhY2UgYXQgdmFsdWUgc3RhcnRcbiAgICBsZXQgc3RhcnRXaXRoU3BhY2UgPSBmYWxzZTtcbiAgICBsZXQgc3RhcnRFbmQ7XG4gICAgbGV0IHN0YXJ0TmxQb3MgPSAtMTtcbiAgICBmb3IgKHN0YXJ0RW5kID0gMDsgc3RhcnRFbmQgPCB2YWx1ZS5sZW5ndGg7ICsrc3RhcnRFbmQpIHtcbiAgICAgICAgY29uc3QgY2ggPSB2YWx1ZVtzdGFydEVuZF07XG4gICAgICAgIGlmIChjaCA9PT0gJyAnKVxuICAgICAgICAgICAgc3RhcnRXaXRoU3BhY2UgPSB0cnVlO1xuICAgICAgICBlbHNlIGlmIChjaCA9PT0gJ1xcbicpXG4gICAgICAgICAgICBzdGFydE5sUG9zID0gc3RhcnRFbmQ7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBsZXQgc3RhcnQgPSB2YWx1ZS5zdWJzdHJpbmcoMCwgc3RhcnRObFBvcyA8IHN0YXJ0RW5kID8gc3RhcnRObFBvcyArIDEgOiBzdGFydEVuZCk7XG4gICAgaWYgKHN0YXJ0KSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUuc3Vic3RyaW5nKHN0YXJ0Lmxlbmd0aCk7XG4gICAgICAgIHN0YXJ0ID0gc3RhcnQucmVwbGFjZSgvXFxuKy9nLCBgJCYke2luZGVudH1gKTtcbiAgICB9XG4gICAgY29uc3QgaW5kZW50U2l6ZSA9IGluZGVudCA/ICcyJyA6ICcxJzsgLy8gcm9vdCBpcyBhdCAtMVxuICAgIGxldCBoZWFkZXIgPSAobGl0ZXJhbCA/ICd8JyA6ICc+JykgKyAoc3RhcnRXaXRoU3BhY2UgPyBpbmRlbnRTaXplIDogJycpICsgY2hvbXA7XG4gICAgaWYgKGNvbW1lbnQpIHtcbiAgICAgICAgaGVhZGVyICs9ICcgJyArIGNvbW1lbnRTdHJpbmcoY29tbWVudC5yZXBsYWNlKC8gP1tcXHJcXG5dKy9nLCAnICcpKTtcbiAgICAgICAgaWYgKG9uQ29tbWVudClcbiAgICAgICAgICAgIG9uQ29tbWVudCgpO1xuICAgIH1cbiAgICBpZiAobGl0ZXJhbCkge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL1xcbisvZywgYCQmJHtpbmRlbnR9YCk7XG4gICAgICAgIHJldHVybiBgJHtoZWFkZXJ9XFxuJHtpbmRlbnR9JHtzdGFydH0ke3ZhbHVlfSR7ZW5kfWA7XG4gICAgfVxuICAgIHZhbHVlID0gdmFsdWVcbiAgICAgICAgLnJlcGxhY2UoL1xcbisvZywgJ1xcbiQmJylcbiAgICAgICAgLnJlcGxhY2UoLyg/Ol58XFxuKShbXFx0IF0uKikoPzooW1xcblxcdCBdKilcXG4oPyFbXFxuXFx0IF0pKT8vZywgJyQxJDInKSAvLyBtb3JlLWluZGVudGVkIGxpbmVzIGFyZW4ndCBmb2xkZWRcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgXiBtb3JlLWluZC4gXiBlbXB0eSAgICAgXiBjYXB0dXJlIG5leHQgZW1wdHkgbGluZXMgb25seSBhdCBlbmQgb2YgaW5kZW50XG4gICAgICAgIC5yZXBsYWNlKC9cXG4rL2csIGAkJiR7aW5kZW50fWApO1xuICAgIGNvbnN0IGJvZHkgPSBmb2xkRmxvd0xpbmVzKGAke3N0YXJ0fSR7dmFsdWV9JHtlbmR9YCwgaW5kZW50LCBGT0xEX0JMT0NLLCBnZXRGb2xkT3B0aW9ucyhjdHgpKTtcbiAgICByZXR1cm4gYCR7aGVhZGVyfVxcbiR7aW5kZW50fSR7Ym9keX1gO1xufVxuZnVuY3Rpb24gcGxhaW5TdHJpbmcoaXRlbSwgY3R4LCBvbkNvbW1lbnQsIG9uQ2hvbXBLZWVwKSB7XG4gICAgY29uc3QgeyB0eXBlLCB2YWx1ZSB9ID0gaXRlbTtcbiAgICBjb25zdCB7IGFjdHVhbFN0cmluZywgaW1wbGljaXRLZXksIGluZGVudCwgaW5GbG93IH0gPSBjdHg7XG4gICAgaWYgKChpbXBsaWNpdEtleSAmJiAvW1xcbltcXF17fSxdLy50ZXN0KHZhbHVlKSkgfHxcbiAgICAgICAgKGluRmxvdyAmJiAvW1tcXF17fSxdLy50ZXN0KHZhbHVlKSkpIHtcbiAgICAgICAgcmV0dXJuIHF1b3RlZFN0cmluZyh2YWx1ZSwgY3R4KTtcbiAgICB9XG4gICAgaWYgKCF2YWx1ZSB8fFxuICAgICAgICAvXltcXG5cXHQgLFtcXF17fSMmKiF8PidcIiVAYF18Xls/LV0kfF5bPy1dWyBcXHRdfFtcXG46XVsgXFx0XXxbIFxcdF1cXG58W1xcblxcdCBdI3xbXFxuXFx0IDpdJC8udGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgLy8gbm90IGFsbG93ZWQ6XG4gICAgICAgIC8vIC0gZW1wdHkgc3RyaW5nLCAnLScgb3IgJz8nXG4gICAgICAgIC8vIC0gc3RhcnQgd2l0aCBhbiBpbmRpY2F0b3IgY2hhcmFjdGVyIChleGNlcHQgWz86LV0pIG9yIC9bPy1dIC9cbiAgICAgICAgLy8gLSAnXFxuICcsICc6ICcgb3IgJyBcXG4nIGFueXdoZXJlXG4gICAgICAgIC8vIC0gJyMnIG5vdCBwcmVjZWRlZCBieSBhIG5vbi1zcGFjZSBjaGFyXG4gICAgICAgIC8vIC0gZW5kIHdpdGggJyAnIG9yICc6J1xuICAgICAgICByZXR1cm4gaW1wbGljaXRLZXkgfHwgaW5GbG93IHx8IHZhbHVlLmluZGV4T2YoJ1xcbicpID09PSAtMVxuICAgICAgICAgICAgPyBxdW90ZWRTdHJpbmcodmFsdWUsIGN0eClcbiAgICAgICAgICAgIDogYmxvY2tTdHJpbmcoaXRlbSwgY3R4LCBvbkNvbW1lbnQsIG9uQ2hvbXBLZWVwKTtcbiAgICB9XG4gICAgaWYgKCFpbXBsaWNpdEtleSAmJlxuICAgICAgICAhaW5GbG93ICYmXG4gICAgICAgIHR5cGUgIT09IFNjYWxhci5QTEFJTiAmJlxuICAgICAgICB2YWx1ZS5pbmRleE9mKCdcXG4nKSAhPT0gLTEpIHtcbiAgICAgICAgLy8gV2hlcmUgYWxsb3dlZCAmIHR5cGUgbm90IHNldCBleHBsaWNpdGx5LCBwcmVmZXIgYmxvY2sgc3R5bGUgZm9yIG11bHRpbGluZSBzdHJpbmdzXG4gICAgICAgIHJldHVybiBibG9ja1N0cmluZyhpdGVtLCBjdHgsIG9uQ29tbWVudCwgb25DaG9tcEtlZXApO1xuICAgIH1cbiAgICBpZiAoaW5kZW50ID09PSAnJyAmJiBjb250YWluc0RvY3VtZW50TWFya2VyKHZhbHVlKSkge1xuICAgICAgICBjdHguZm9yY2VCbG9ja0luZGVudCA9IHRydWU7XG4gICAgICAgIHJldHVybiBibG9ja1N0cmluZyhpdGVtLCBjdHgsIG9uQ29tbWVudCwgb25DaG9tcEtlZXApO1xuICAgIH1cbiAgICBjb25zdCBzdHIgPSB2YWx1ZS5yZXBsYWNlKC9cXG4rL2csIGAkJlxcbiR7aW5kZW50fWApO1xuICAgIC8vIFZlcmlmeSB0aGF0IG91dHB1dCB3aWxsIGJlIHBhcnNlZCBhcyBhIHN0cmluZywgYXMgZS5nLiBwbGFpbiBudW1iZXJzIGFuZFxuICAgIC8vIGJvb2xlYW5zIGdldCBwYXJzZWQgd2l0aCB0aG9zZSB0eXBlcyBpbiB2MS4yIChlLmcuICc0MicsICd0cnVlJyAmICcwLjllLTMnKSxcbiAgICAvLyBhbmQgb3RoZXJzIGluIHYxLjEuXG4gICAgaWYgKGFjdHVhbFN0cmluZykge1xuICAgICAgICBjb25zdCB0ZXN0ID0gKHRhZykgPT4geyB2YXIgX2E7IHJldHVybiB0YWcuZGVmYXVsdCAmJiB0YWcudGFnICE9PSAndGFnOnlhbWwub3JnLDIwMDI6c3RyJyAmJiAoKF9hID0gdGFnLnRlc3QpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50ZXN0KHN0cikpOyB9O1xuICAgICAgICBjb25zdCB7IGNvbXBhdCwgdGFncyB9ID0gY3R4LmRvYy5zY2hlbWE7XG4gICAgICAgIGlmICh0YWdzLnNvbWUodGVzdCkgfHwgKGNvbXBhdCA9PT0gbnVsbCB8fCBjb21wYXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbXBhdC5zb21lKHRlc3QpKSlcbiAgICAgICAgICAgIHJldHVybiBxdW90ZWRTdHJpbmcodmFsdWUsIGN0eCk7XG4gICAgfVxuICAgIHJldHVybiBpbXBsaWNpdEtleVxuICAgICAgICA/IHN0clxuICAgICAgICA6IGZvbGRGbG93TGluZXMoc3RyLCBpbmRlbnQsIEZPTERfRkxPVywgZ2V0Rm9sZE9wdGlvbnMoY3R4KSk7XG59XG5mdW5jdGlvbiBzdHJpbmdpZnlTdHJpbmcoaXRlbSwgY3R4LCBvbkNvbW1lbnQsIG9uQ2hvbXBLZWVwKSB7XG4gICAgY29uc3QgeyBpbXBsaWNpdEtleSwgaW5GbG93IH0gPSBjdHg7XG4gICAgY29uc3Qgc3MgPSB0eXBlb2YgaXRlbS52YWx1ZSA9PT0gJ3N0cmluZydcbiAgICAgICAgPyBpdGVtXG4gICAgICAgIDogT2JqZWN0LmFzc2lnbih7fSwgaXRlbSwgeyB2YWx1ZTogU3RyaW5nKGl0ZW0udmFsdWUpIH0pO1xuICAgIGxldCB7IHR5cGUgfSA9IGl0ZW07XG4gICAgaWYgKHR5cGUgIT09IFNjYWxhci5RVU9URV9ET1VCTEUpIHtcbiAgICAgICAgLy8gZm9yY2UgZG91YmxlIHF1b3RlcyBvbiBjb250cm9sIGNoYXJhY3RlcnMgJiB1bnBhaXJlZCBzdXJyb2dhdGVzXG4gICAgICAgIGlmICgvW1xceDAwLVxceDA4XFx4MGItXFx4MWZcXHg3Zi1cXHg5ZlxcdXtEODAwfS1cXHV7REZGRn1dL3UudGVzdChzcy52YWx1ZSkpXG4gICAgICAgICAgICB0eXBlID0gU2NhbGFyLlFVT1RFX0RPVUJMRTtcbiAgICB9XG4gICAgY29uc3QgX3N0cmluZ2lmeSA9IChfdHlwZSkgPT4ge1xuICAgICAgICBzd2l0Y2ggKF90eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFNjYWxhci5CTE9DS19GT0xERUQ6XG4gICAgICAgICAgICBjYXNlIFNjYWxhci5CTE9DS19MSVRFUkFMOlxuICAgICAgICAgICAgICAgIHJldHVybiBpbXBsaWNpdEtleSB8fCBpbkZsb3dcbiAgICAgICAgICAgICAgICAgICAgPyBxdW90ZWRTdHJpbmcoc3MudmFsdWUsIGN0eCkgLy8gYmxvY2tzIGFyZSBub3QgdmFsaWQgaW5zaWRlIGZsb3cgY29udGFpbmVyc1xuICAgICAgICAgICAgICAgICAgICA6IGJsb2NrU3RyaW5nKHNzLCBjdHgsIG9uQ29tbWVudCwgb25DaG9tcEtlZXApO1xuICAgICAgICAgICAgY2FzZSBTY2FsYXIuUVVPVEVfRE9VQkxFOlxuICAgICAgICAgICAgICAgIHJldHVybiBkb3VibGVRdW90ZWRTdHJpbmcoc3MudmFsdWUsIGN0eCk7XG4gICAgICAgICAgICBjYXNlIFNjYWxhci5RVU9URV9TSU5HTEU6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNpbmdsZVF1b3RlZFN0cmluZyhzcy52YWx1ZSwgY3R4KTtcbiAgICAgICAgICAgIGNhc2UgU2NhbGFyLlBMQUlOOlxuICAgICAgICAgICAgICAgIHJldHVybiBwbGFpblN0cmluZyhzcywgY3R4LCBvbkNvbW1lbnQsIG9uQ2hvbXBLZWVwKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGxldCByZXMgPSBfc3RyaW5naWZ5KHR5cGUpO1xuICAgIGlmIChyZXMgPT09IG51bGwpIHtcbiAgICAgICAgY29uc3QgeyBkZWZhdWx0S2V5VHlwZSwgZGVmYXVsdFN0cmluZ1R5cGUgfSA9IGN0eC5vcHRpb25zO1xuICAgICAgICBjb25zdCB0ID0gKGltcGxpY2l0S2V5ICYmIGRlZmF1bHRLZXlUeXBlKSB8fCBkZWZhdWx0U3RyaW5nVHlwZTtcbiAgICAgICAgcmVzID0gX3N0cmluZ2lmeSh0KTtcbiAgICAgICAgaWYgKHJlcyA9PT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgZGVmYXVsdCBzdHJpbmcgdHlwZSAke3R9YCk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5cbmV4cG9ydCB7IHN0cmluZ2lmeVN0cmluZyB9O1xuIiwgImltcG9ydCB7IGFuY2hvcklzVmFsaWQgfSBmcm9tICcuLi9kb2MvYW5jaG9ycy5qcyc7XG5pbXBvcnQgeyBpc1BhaXIsIGlzQWxpYXMsIGlzTm9kZSwgaXNTY2FsYXIsIGlzQ29sbGVjdGlvbiB9IGZyb20gJy4uL25vZGVzL05vZGUuanMnO1xuaW1wb3J0IHsgc3RyaW5naWZ5Q29tbWVudCB9IGZyb20gJy4vc3RyaW5naWZ5Q29tbWVudC5qcyc7XG5pbXBvcnQgeyBzdHJpbmdpZnlTdHJpbmcgfSBmcm9tICcuL3N0cmluZ2lmeVN0cmluZy5qcyc7XG5cbmZ1bmN0aW9uIGNyZWF0ZVN0cmluZ2lmeUNvbnRleHQoZG9jLCBvcHRpb25zKSB7XG4gICAgY29uc3Qgb3B0ID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgIGJsb2NrUXVvdGU6IHRydWUsXG4gICAgICAgIGNvbW1lbnRTdHJpbmc6IHN0cmluZ2lmeUNvbW1lbnQsXG4gICAgICAgIGRlZmF1bHRLZXlUeXBlOiBudWxsLFxuICAgICAgICBkZWZhdWx0U3RyaW5nVHlwZTogJ1BMQUlOJyxcbiAgICAgICAgZGlyZWN0aXZlczogbnVsbCxcbiAgICAgICAgZG91YmxlUXVvdGVkQXNKU09OOiBmYWxzZSxcbiAgICAgICAgZG91YmxlUXVvdGVkTWluTXVsdGlMaW5lTGVuZ3RoOiA0MCxcbiAgICAgICAgZmFsc2VTdHI6ICdmYWxzZScsXG4gICAgICAgIGluZGVudFNlcTogdHJ1ZSxcbiAgICAgICAgbGluZVdpZHRoOiA4MCxcbiAgICAgICAgbWluQ29udGVudFdpZHRoOiAyMCxcbiAgICAgICAgbnVsbFN0cjogJ251bGwnLFxuICAgICAgICBzaW1wbGVLZXlzOiBmYWxzZSxcbiAgICAgICAgc2luZ2xlUXVvdGU6IG51bGwsXG4gICAgICAgIHRydWVTdHI6ICd0cnVlJyxcbiAgICAgICAgdmVyaWZ5QWxpYXNPcmRlcjogdHJ1ZVxuICAgIH0sIGRvYy5zY2hlbWEudG9TdHJpbmdPcHRpb25zLCBvcHRpb25zKTtcbiAgICBsZXQgaW5GbG93O1xuICAgIHN3aXRjaCAob3B0LmNvbGxlY3Rpb25TdHlsZSkge1xuICAgICAgICBjYXNlICdibG9jayc6XG4gICAgICAgICAgICBpbkZsb3cgPSBmYWxzZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdmbG93JzpcbiAgICAgICAgICAgIGluRmxvdyA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGluRmxvdyA9IG51bGw7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGFuY2hvcnM6IG5ldyBTZXQoKSxcbiAgICAgICAgZG9jLFxuICAgICAgICBpbmRlbnQ6ICcnLFxuICAgICAgICBpbmRlbnRTdGVwOiB0eXBlb2Ygb3B0LmluZGVudCA9PT0gJ251bWJlcicgPyAnICcucmVwZWF0KG9wdC5pbmRlbnQpIDogJyAgJyxcbiAgICAgICAgaW5GbG93LFxuICAgICAgICBvcHRpb25zOiBvcHRcbiAgICB9O1xufVxuZnVuY3Rpb24gZ2V0VGFnT2JqZWN0KHRhZ3MsIGl0ZW0pIHtcbiAgICBpZiAoaXRlbS50YWcpIHtcbiAgICAgICAgY29uc3QgbWF0Y2ggPSB0YWdzLmZpbHRlcih0ID0+IHQudGFnID09PSBpdGVtLnRhZyk7XG4gICAgICAgIGlmIChtYXRjaC5sZW5ndGggPiAwKVxuICAgICAgICAgICAgcmV0dXJuIG1hdGNoLmZpbmQodCA9PiB0LmZvcm1hdCA9PT0gaXRlbS5mb3JtYXQpIHx8IG1hdGNoWzBdO1xuICAgIH1cbiAgICBsZXQgdGFnT2JqID0gdW5kZWZpbmVkO1xuICAgIGxldCBvYmo7XG4gICAgaWYgKGlzU2NhbGFyKGl0ZW0pKSB7XG4gICAgICAgIG9iaiA9IGl0ZW0udmFsdWU7XG4gICAgICAgIGNvbnN0IG1hdGNoID0gdGFncy5maWx0ZXIodCA9PiB0LmlkZW50aWZ5ICYmIHQuaWRlbnRpZnkob2JqKSk7XG4gICAgICAgIHRhZ09iaiA9XG4gICAgICAgICAgICBtYXRjaC5maW5kKHQgPT4gdC5mb3JtYXQgPT09IGl0ZW0uZm9ybWF0KSB8fCBtYXRjaC5maW5kKHQgPT4gIXQuZm9ybWF0KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIG9iaiA9IGl0ZW07XG4gICAgICAgIHRhZ09iaiA9IHRhZ3MuZmluZCh0ID0+IHQubm9kZUNsYXNzICYmIG9iaiBpbnN0YW5jZW9mIHQubm9kZUNsYXNzKTtcbiAgICB9XG4gICAgaWYgKCF0YWdPYmopIHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBjb25zdCBuYW1lID0gb2JqICYmIG9iai5jb25zdHJ1Y3RvciA/IG9iai5jb25zdHJ1Y3Rvci5uYW1lIDogdHlwZW9mIG9iajtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUYWcgbm90IHJlc29sdmVkIGZvciAke25hbWV9IHZhbHVlYCk7XG4gICAgfVxuICAgIHJldHVybiB0YWdPYmo7XG59XG4vLyBuZWVkcyB0byBiZSBjYWxsZWQgYmVmb3JlIHZhbHVlIHN0cmluZ2lmaWVyIHRvIGFsbG93IGZvciBjaXJjdWxhciBhbmNob3IgcmVmc1xuZnVuY3Rpb24gc3RyaW5naWZ5UHJvcHMobm9kZSwgdGFnT2JqLCB7IGFuY2hvcnMsIGRvYyB9KSB7XG4gICAgaWYgKCFkb2MuZGlyZWN0aXZlcylcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIGNvbnN0IHByb3BzID0gW107XG4gICAgY29uc3QgYW5jaG9yID0gKGlzU2NhbGFyKG5vZGUpIHx8IGlzQ29sbGVjdGlvbihub2RlKSkgJiYgbm9kZS5hbmNob3I7XG4gICAgaWYgKGFuY2hvciAmJiBhbmNob3JJc1ZhbGlkKGFuY2hvcikpIHtcbiAgICAgICAgYW5jaG9ycy5hZGQoYW5jaG9yKTtcbiAgICAgICAgcHJvcHMucHVzaChgJiR7YW5jaG9yfWApO1xuICAgIH1cbiAgICBjb25zdCB0YWcgPSBub2RlLnRhZyB8fCAodGFnT2JqLmRlZmF1bHQgPyBudWxsIDogdGFnT2JqLnRhZyk7XG4gICAgaWYgKHRhZylcbiAgICAgICAgcHJvcHMucHVzaChkb2MuZGlyZWN0aXZlcy50YWdTdHJpbmcodGFnKSk7XG4gICAgcmV0dXJuIHByb3BzLmpvaW4oJyAnKTtcbn1cbmZ1bmN0aW9uIHN0cmluZ2lmeShpdGVtLCBjdHgsIG9uQ29tbWVudCwgb25DaG9tcEtlZXApIHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKGlzUGFpcihpdGVtKSlcbiAgICAgICAgcmV0dXJuIGl0ZW0udG9TdHJpbmcoY3R4LCBvbkNvbW1lbnQsIG9uQ2hvbXBLZWVwKTtcbiAgICBpZiAoaXNBbGlhcyhpdGVtKSkge1xuICAgICAgICBpZiAoY3R4LmRvYy5kaXJlY3RpdmVzKVxuICAgICAgICAgICAgcmV0dXJuIGl0ZW0udG9TdHJpbmcoY3R4KTtcbiAgICAgICAgaWYgKChfYSA9IGN0eC5yZXNvbHZlZEFsaWFzZXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5oYXMoaXRlbSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYENhbm5vdCBzdHJpbmdpZnkgY2lyY3VsYXIgc3RydWN0dXJlIHdpdGhvdXQgYWxpYXMgbm9kZXNgKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChjdHgucmVzb2x2ZWRBbGlhc2VzKVxuICAgICAgICAgICAgICAgIGN0eC5yZXNvbHZlZEFsaWFzZXMuYWRkKGl0ZW0pO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGN0eC5yZXNvbHZlZEFsaWFzZXMgPSBuZXcgU2V0KFtpdGVtXSk7XG4gICAgICAgICAgICBpdGVtID0gaXRlbS5yZXNvbHZlKGN0eC5kb2MpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxldCB0YWdPYmogPSB1bmRlZmluZWQ7XG4gICAgY29uc3Qgbm9kZSA9IGlzTm9kZShpdGVtKVxuICAgICAgICA/IGl0ZW1cbiAgICAgICAgOiBjdHguZG9jLmNyZWF0ZU5vZGUoaXRlbSwgeyBvblRhZ09iajogbyA9PiAodGFnT2JqID0gbykgfSk7XG4gICAgaWYgKCF0YWdPYmopXG4gICAgICAgIHRhZ09iaiA9IGdldFRhZ09iamVjdChjdHguZG9jLnNjaGVtYS50YWdzLCBub2RlKTtcbiAgICBjb25zdCBwcm9wcyA9IHN0cmluZ2lmeVByb3BzKG5vZGUsIHRhZ09iaiwgY3R4KTtcbiAgICBpZiAocHJvcHMubGVuZ3RoID4gMClcbiAgICAgICAgY3R4LmluZGVudEF0U3RhcnQgPSAoY3R4LmluZGVudEF0U3RhcnQgfHwgMCkgKyBwcm9wcy5sZW5ndGggKyAxO1xuICAgIGNvbnN0IHN0ciA9IHR5cGVvZiB0YWdPYmouc3RyaW5naWZ5ID09PSAnZnVuY3Rpb24nXG4gICAgICAgID8gdGFnT2JqLnN0cmluZ2lmeShub2RlLCBjdHgsIG9uQ29tbWVudCwgb25DaG9tcEtlZXApXG4gICAgICAgIDogaXNTY2FsYXIobm9kZSlcbiAgICAgICAgICAgID8gc3RyaW5naWZ5U3RyaW5nKG5vZGUsIGN0eCwgb25Db21tZW50LCBvbkNob21wS2VlcClcbiAgICAgICAgICAgIDogbm9kZS50b1N0cmluZyhjdHgsIG9uQ29tbWVudCwgb25DaG9tcEtlZXApO1xuICAgIGlmICghcHJvcHMpXG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgcmV0dXJuIGlzU2NhbGFyKG5vZGUpIHx8IHN0clswXSA9PT0gJ3snIHx8IHN0clswXSA9PT0gJ1snXG4gICAgICAgID8gYCR7cHJvcHN9ICR7c3RyfWBcbiAgICAgICAgOiBgJHtwcm9wc31cXG4ke2N0eC5pbmRlbnR9JHtzdHJ9YDtcbn1cblxuZXhwb3J0IHsgY3JlYXRlU3RyaW5naWZ5Q29udGV4dCwgc3RyaW5naWZ5IH07XG4iLCAiaW1wb3J0IHsgaXNDb2xsZWN0aW9uLCBpc05vZGUsIGlzU2NhbGFyLCBpc1NlcSB9IGZyb20gJy4uL25vZGVzL05vZGUuanMnO1xuaW1wb3J0IHsgU2NhbGFyIH0gZnJvbSAnLi4vbm9kZXMvU2NhbGFyLmpzJztcbmltcG9ydCB7IHN0cmluZ2lmeSB9IGZyb20gJy4vc3RyaW5naWZ5LmpzJztcbmltcG9ydCB7IGxpbmVDb21tZW50LCBpbmRlbnRDb21tZW50IH0gZnJvbSAnLi9zdHJpbmdpZnlDb21tZW50LmpzJztcblxuZnVuY3Rpb24gc3RyaW5naWZ5UGFpcih7IGtleSwgdmFsdWUgfSwgY3R4LCBvbkNvbW1lbnQsIG9uQ2hvbXBLZWVwKSB7XG4gICAgY29uc3QgeyBhbGxOdWxsVmFsdWVzLCBkb2MsIGluZGVudCwgaW5kZW50U3RlcCwgb3B0aW9uczogeyBjb21tZW50U3RyaW5nLCBpbmRlbnRTZXEsIHNpbXBsZUtleXMgfSB9ID0gY3R4O1xuICAgIGxldCBrZXlDb21tZW50ID0gKGlzTm9kZShrZXkpICYmIGtleS5jb21tZW50KSB8fCBudWxsO1xuICAgIGlmIChzaW1wbGVLZXlzKSB7XG4gICAgICAgIGlmIChrZXlDb21tZW50KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dpdGggc2ltcGxlIGtleXMsIGtleSBub2RlcyBjYW5ub3QgaGF2ZSBjb21tZW50cycpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0NvbGxlY3Rpb24oa2V5KSkge1xuICAgICAgICAgICAgY29uc3QgbXNnID0gJ1dpdGggc2ltcGxlIGtleXMsIGNvbGxlY3Rpb24gY2Fubm90IGJlIHVzZWQgYXMgYSBrZXkgdmFsdWUnO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IGV4cGxpY2l0S2V5ID0gIXNpbXBsZUtleXMgJiZcbiAgICAgICAgKCFrZXkgfHxcbiAgICAgICAgICAgIChrZXlDb21tZW50ICYmIHZhbHVlID09IG51bGwgJiYgIWN0eC5pbkZsb3cpIHx8XG4gICAgICAgICAgICBpc0NvbGxlY3Rpb24oa2V5KSB8fFxuICAgICAgICAgICAgKGlzU2NhbGFyKGtleSlcbiAgICAgICAgICAgICAgICA/IGtleS50eXBlID09PSBTY2FsYXIuQkxPQ0tfRk9MREVEIHx8IGtleS50eXBlID09PSBTY2FsYXIuQkxPQ0tfTElURVJBTFxuICAgICAgICAgICAgICAgIDogdHlwZW9mIGtleSA9PT0gJ29iamVjdCcpKTtcbiAgICBjdHggPSBPYmplY3QuYXNzaWduKHt9LCBjdHgsIHtcbiAgICAgICAgYWxsTnVsbFZhbHVlczogZmFsc2UsXG4gICAgICAgIGltcGxpY2l0S2V5OiAhZXhwbGljaXRLZXkgJiYgKHNpbXBsZUtleXMgfHwgIWFsbE51bGxWYWx1ZXMpLFxuICAgICAgICBpbmRlbnQ6IGluZGVudCArIGluZGVudFN0ZXBcbiAgICB9KTtcbiAgICBsZXQga2V5Q29tbWVudERvbmUgPSBmYWxzZTtcbiAgICBsZXQgY2hvbXBLZWVwID0gZmFsc2U7XG4gICAgbGV0IHN0ciA9IHN0cmluZ2lmeShrZXksIGN0eCwgKCkgPT4gKGtleUNvbW1lbnREb25lID0gdHJ1ZSksICgpID0+IChjaG9tcEtlZXAgPSB0cnVlKSk7XG4gICAgaWYgKCFleHBsaWNpdEtleSAmJiAhY3R4LmluRmxvdyAmJiBzdHIubGVuZ3RoID4gMTAyNCkge1xuICAgICAgICBpZiAoc2ltcGxlS2V5cylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignV2l0aCBzaW1wbGUga2V5cywgc2luZ2xlIGxpbmUgc2NhbGFyIG11c3Qgbm90IHNwYW4gbW9yZSB0aGFuIDEwMjQgY2hhcmFjdGVycycpO1xuICAgICAgICBleHBsaWNpdEtleSA9IHRydWU7XG4gICAgfVxuICAgIGlmIChjdHguaW5GbG93KSB7XG4gICAgICAgIGlmIChhbGxOdWxsVmFsdWVzIHx8IHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChrZXlDb21tZW50RG9uZSAmJiBvbkNvbW1lbnQpXG4gICAgICAgICAgICAgICAgb25Db21tZW50KCk7XG4gICAgICAgICAgICByZXR1cm4gZXhwbGljaXRLZXkgPyBgPyAke3N0cn1gIDogc3RyO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKChhbGxOdWxsVmFsdWVzICYmICFzaW1wbGVLZXlzKSB8fCAodmFsdWUgPT0gbnVsbCAmJiBleHBsaWNpdEtleSkpIHtcbiAgICAgICAgc3RyID0gYD8gJHtzdHJ9YDtcbiAgICAgICAgaWYgKGtleUNvbW1lbnQgJiYgIWtleUNvbW1lbnREb25lKSB7XG4gICAgICAgICAgICBzdHIgKz0gbGluZUNvbW1lbnQoc3RyLCBjdHguaW5kZW50LCBjb21tZW50U3RyaW5nKGtleUNvbW1lbnQpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjaG9tcEtlZXAgJiYgb25DaG9tcEtlZXApXG4gICAgICAgICAgICBvbkNob21wS2VlcCgpO1xuICAgICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgICBpZiAoa2V5Q29tbWVudERvbmUpXG4gICAgICAgIGtleUNvbW1lbnQgPSBudWxsO1xuICAgIGlmIChleHBsaWNpdEtleSkge1xuICAgICAgICBpZiAoa2V5Q29tbWVudClcbiAgICAgICAgICAgIHN0ciArPSBsaW5lQ29tbWVudChzdHIsIGN0eC5pbmRlbnQsIGNvbW1lbnRTdHJpbmcoa2V5Q29tbWVudCkpO1xuICAgICAgICBzdHIgPSBgPyAke3N0cn1cXG4ke2luZGVudH06YDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHN0ciA9IGAke3N0cn06YDtcbiAgICAgICAgaWYgKGtleUNvbW1lbnQpXG4gICAgICAgICAgICBzdHIgKz0gbGluZUNvbW1lbnQoc3RyLCBjdHguaW5kZW50LCBjb21tZW50U3RyaW5nKGtleUNvbW1lbnQpKTtcbiAgICB9XG4gICAgbGV0IHZjYiA9ICcnO1xuICAgIGxldCB2YWx1ZUNvbW1lbnQgPSBudWxsO1xuICAgIGlmIChpc05vZGUodmFsdWUpKSB7XG4gICAgICAgIGlmICh2YWx1ZS5zcGFjZUJlZm9yZSlcbiAgICAgICAgICAgIHZjYiA9ICdcXG4nO1xuICAgICAgICBpZiAodmFsdWUuY29tbWVudEJlZm9yZSkge1xuICAgICAgICAgICAgY29uc3QgY3MgPSBjb21tZW50U3RyaW5nKHZhbHVlLmNvbW1lbnRCZWZvcmUpO1xuICAgICAgICAgICAgdmNiICs9IGBcXG4ke2luZGVudENvbW1lbnQoY3MsIGN0eC5pbmRlbnQpfWA7XG4gICAgICAgIH1cbiAgICAgICAgdmFsdWVDb21tZW50ID0gdmFsdWUuY29tbWVudDtcbiAgICB9XG4gICAgZWxzZSBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgICAgICB2YWx1ZSA9IGRvYy5jcmVhdGVOb2RlKHZhbHVlKTtcbiAgICB9XG4gICAgY3R4LmltcGxpY2l0S2V5ID0gZmFsc2U7XG4gICAgaWYgKCFleHBsaWNpdEtleSAmJiAha2V5Q29tbWVudCAmJiBpc1NjYWxhcih2YWx1ZSkpXG4gICAgICAgIGN0eC5pbmRlbnRBdFN0YXJ0ID0gc3RyLmxlbmd0aCArIDE7XG4gICAgY2hvbXBLZWVwID0gZmFsc2U7XG4gICAgaWYgKCFpbmRlbnRTZXEgJiZcbiAgICAgICAgaW5kZW50U3RlcC5sZW5ndGggPj0gMiAmJlxuICAgICAgICAhY3R4LmluRmxvdyAmJlxuICAgICAgICAhZXhwbGljaXRLZXkgJiZcbiAgICAgICAgaXNTZXEodmFsdWUpICYmXG4gICAgICAgICF2YWx1ZS5mbG93ICYmXG4gICAgICAgICF2YWx1ZS50YWcgJiZcbiAgICAgICAgIXZhbHVlLmFuY2hvcikge1xuICAgICAgICAvLyBJZiBpbmRlbnRTZXEgPT09IGZhbHNlLCBjb25zaWRlciAnLSAnIGFzIHBhcnQgb2YgaW5kZW50YXRpb24gd2hlcmUgcG9zc2libGVcbiAgICAgICAgY3R4LmluZGVudCA9IGN0eC5pbmRlbnQuc3Vic3RyKDIpO1xuICAgIH1cbiAgICBsZXQgdmFsdWVDb21tZW50RG9uZSA9IGZhbHNlO1xuICAgIGNvbnN0IHZhbHVlU3RyID0gc3RyaW5naWZ5KHZhbHVlLCBjdHgsICgpID0+ICh2YWx1ZUNvbW1lbnREb25lID0gdHJ1ZSksICgpID0+IChjaG9tcEtlZXAgPSB0cnVlKSk7XG4gICAgbGV0IHdzID0gJyAnO1xuICAgIGlmICh2Y2IgfHwga2V5Q29tbWVudCkge1xuICAgICAgICB3cyA9IHZhbHVlU3RyID09PSAnJyAmJiAhY3R4LmluRmxvdyA/IHZjYiA6IGAke3ZjYn1cXG4ke2N0eC5pbmRlbnR9YDtcbiAgICB9XG4gICAgZWxzZSBpZiAoIWV4cGxpY2l0S2V5ICYmIGlzQ29sbGVjdGlvbih2YWx1ZSkpIHtcbiAgICAgICAgY29uc3QgZmxvdyA9IHZhbHVlU3RyWzBdID09PSAnWycgfHwgdmFsdWVTdHJbMF0gPT09ICd7JztcbiAgICAgICAgaWYgKCFmbG93IHx8IHZhbHVlU3RyLmluY2x1ZGVzKCdcXG4nKSlcbiAgICAgICAgICAgIHdzID0gYFxcbiR7Y3R4LmluZGVudH1gO1xuICAgIH1cbiAgICBlbHNlIGlmICh2YWx1ZVN0ciA9PT0gJycgfHwgdmFsdWVTdHJbMF0gPT09ICdcXG4nKVxuICAgICAgICB3cyA9ICcnO1xuICAgIHN0ciArPSB3cyArIHZhbHVlU3RyO1xuICAgIGlmIChjdHguaW5GbG93KSB7XG4gICAgICAgIGlmICh2YWx1ZUNvbW1lbnREb25lICYmIG9uQ29tbWVudClcbiAgICAgICAgICAgIG9uQ29tbWVudCgpO1xuICAgIH1cbiAgICBlbHNlIGlmICh2YWx1ZUNvbW1lbnQgJiYgIXZhbHVlQ29tbWVudERvbmUpIHtcbiAgICAgICAgc3RyICs9IGxpbmVDb21tZW50KHN0ciwgY3R4LmluZGVudCwgY29tbWVudFN0cmluZyh2YWx1ZUNvbW1lbnQpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoY2hvbXBLZWVwICYmIG9uQ2hvbXBLZWVwKSB7XG4gICAgICAgIG9uQ2hvbXBLZWVwKCk7XG4gICAgfVxuICAgIHJldHVybiBzdHI7XG59XG5cbmV4cG9ydCB7IHN0cmluZ2lmeVBhaXIgfTtcbiIsICJmdW5jdGlvbiBkZWJ1Zyhsb2dMZXZlbCwgLi4ubWVzc2FnZXMpIHtcbiAgICBpZiAobG9nTGV2ZWwgPT09ICdkZWJ1ZycpXG4gICAgICAgIGNvbnNvbGUubG9nKC4uLm1lc3NhZ2VzKTtcbn1cbmZ1bmN0aW9uIHdhcm4obG9nTGV2ZWwsIHdhcm5pbmcpIHtcbiAgICBpZiAobG9nTGV2ZWwgPT09ICdkZWJ1ZycgfHwgbG9nTGV2ZWwgPT09ICd3YXJuJykge1xuICAgICAgICBpZiAodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHByb2Nlc3MuZW1pdFdhcm5pbmcpXG4gICAgICAgICAgICBwcm9jZXNzLmVtaXRXYXJuaW5nKHdhcm5pbmcpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBjb25zb2xlLndhcm4od2FybmluZyk7XG4gICAgfVxufVxuXG5leHBvcnQgeyBkZWJ1Zywgd2FybiB9O1xuIiwgImltcG9ydCB7IHdhcm4gfSBmcm9tICcuLi9sb2cuanMnO1xuaW1wb3J0IHsgY3JlYXRlU3RyaW5naWZ5Q29udGV4dCB9IGZyb20gJy4uL3N0cmluZ2lmeS9zdHJpbmdpZnkuanMnO1xuaW1wb3J0IHsgaXNBbGlhcywgaXNTZXEsIGlzU2NhbGFyLCBpc01hcCwgaXNOb2RlIH0gZnJvbSAnLi9Ob2RlLmpzJztcbmltcG9ydCB7IFNjYWxhciB9IGZyb20gJy4vU2NhbGFyLmpzJztcbmltcG9ydCB7IHRvSlMgfSBmcm9tICcuL3RvSlMuanMnO1xuXG5jb25zdCBNRVJHRV9LRVkgPSAnPDwnO1xuZnVuY3Rpb24gYWRkUGFpclRvSlNNYXAoY3R4LCBtYXAsIHsga2V5LCB2YWx1ZSB9KSB7XG4gICAgaWYgKGN0eCAmJiBjdHguZG9jLnNjaGVtYS5tZXJnZSAmJiBpc01lcmdlS2V5KGtleSkpIHtcbiAgICAgICAgdmFsdWUgPSBpc0FsaWFzKHZhbHVlKSA/IHZhbHVlLnJlc29sdmUoY3R4LmRvYykgOiB2YWx1ZTtcbiAgICAgICAgaWYgKGlzU2VxKHZhbHVlKSlcbiAgICAgICAgICAgIGZvciAoY29uc3QgaXQgb2YgdmFsdWUuaXRlbXMpXG4gICAgICAgICAgICAgICAgbWVyZ2VUb0pTTWFwKGN0eCwgbWFwLCBpdCk7XG4gICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKVxuICAgICAgICAgICAgZm9yIChjb25zdCBpdCBvZiB2YWx1ZSlcbiAgICAgICAgICAgICAgICBtZXJnZVRvSlNNYXAoY3R4LCBtYXAsIGl0KTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgbWVyZ2VUb0pTTWFwKGN0eCwgbWFwLCB2YWx1ZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBqc0tleSA9IHRvSlMoa2V5LCAnJywgY3R4KTtcbiAgICAgICAgaWYgKG1hcCBpbnN0YW5jZW9mIE1hcCkge1xuICAgICAgICAgICAgbWFwLnNldChqc0tleSwgdG9KUyh2YWx1ZSwganNLZXksIGN0eCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG1hcCBpbnN0YW5jZW9mIFNldCkge1xuICAgICAgICAgICAgbWFwLmFkZChqc0tleSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBzdHJpbmdLZXkgPSBzdHJpbmdpZnlLZXkoa2V5LCBqc0tleSwgY3R4KTtcbiAgICAgICAgICAgIGNvbnN0IGpzVmFsdWUgPSB0b0pTKHZhbHVlLCBzdHJpbmdLZXksIGN0eCk7XG4gICAgICAgICAgICBpZiAoc3RyaW5nS2V5IGluIG1hcClcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobWFwLCBzdHJpbmdLZXksIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGpzVmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBtYXBbc3RyaW5nS2V5XSA9IGpzVmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1hcDtcbn1cbmNvbnN0IGlzTWVyZ2VLZXkgPSAoa2V5KSA9PiBrZXkgPT09IE1FUkdFX0tFWSB8fFxuICAgIChpc1NjYWxhcihrZXkpICYmXG4gICAgICAgIGtleS52YWx1ZSA9PT0gTUVSR0VfS0VZICYmXG4gICAgICAgICgha2V5LnR5cGUgfHwga2V5LnR5cGUgPT09IFNjYWxhci5QTEFJTikpO1xuLy8gSWYgdGhlIHZhbHVlIGFzc29jaWF0ZWQgd2l0aCBhIG1lcmdlIGtleSBpcyBhIHNpbmdsZSBtYXBwaW5nIG5vZGUsIGVhY2ggb2Zcbi8vIGl0cyBrZXkvdmFsdWUgcGFpcnMgaXMgaW5zZXJ0ZWQgaW50byB0aGUgY3VycmVudCBtYXBwaW5nLCB1bmxlc3MgdGhlIGtleVxuLy8gYWxyZWFkeSBleGlzdHMgaW4gaXQuIElmIHRoZSB2YWx1ZSBhc3NvY2lhdGVkIHdpdGggdGhlIG1lcmdlIGtleSBpcyBhXG4vLyBzZXF1ZW5jZSwgdGhlbiB0aGlzIHNlcXVlbmNlIGlzIGV4cGVjdGVkIHRvIGNvbnRhaW4gbWFwcGluZyBub2RlcyBhbmQgZWFjaFxuLy8gb2YgdGhlc2Ugbm9kZXMgaXMgbWVyZ2VkIGluIHR1cm4gYWNjb3JkaW5nIHRvIGl0cyBvcmRlciBpbiB0aGUgc2VxdWVuY2UuXG4vLyBLZXlzIGluIG1hcHBpbmcgbm9kZXMgZWFybGllciBpbiB0aGUgc2VxdWVuY2Ugb3ZlcnJpZGUga2V5cyBzcGVjaWZpZWQgaW5cbi8vIGxhdGVyIG1hcHBpbmcgbm9kZXMuIC0tIGh0dHA6Ly95YW1sLm9yZy90eXBlL21lcmdlLmh0bWxcbmZ1bmN0aW9uIG1lcmdlVG9KU01hcChjdHgsIG1hcCwgdmFsdWUpIHtcbiAgICBjb25zdCBzb3VyY2UgPSBjdHggJiYgaXNBbGlhcyh2YWx1ZSkgPyB2YWx1ZS5yZXNvbHZlKGN0eC5kb2MpIDogdmFsdWU7XG4gICAgaWYgKCFpc01hcChzb3VyY2UpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01lcmdlIHNvdXJjZXMgbXVzdCBiZSBtYXBzIG9yIG1hcCBhbGlhc2VzJyk7XG4gICAgY29uc3Qgc3JjTWFwID0gc291cmNlLnRvSlNPTihudWxsLCBjdHgsIE1hcCk7XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2Ygc3JjTWFwKSB7XG4gICAgICAgIGlmIChtYXAgaW5zdGFuY2VvZiBNYXApIHtcbiAgICAgICAgICAgIGlmICghbWFwLmhhcyhrZXkpKVxuICAgICAgICAgICAgICAgIG1hcC5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobWFwIGluc3RhbmNlb2YgU2V0KSB7XG4gICAgICAgICAgICBtYXAuYWRkKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtYXAsIGtleSkpIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtYXAsIGtleSwge1xuICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWFwO1xufVxuZnVuY3Rpb24gc3RyaW5naWZ5S2V5KGtleSwganNLZXksIGN0eCkge1xuICAgIGlmIChqc0tleSA9PT0gbnVsbClcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIGlmICh0eXBlb2YganNLZXkgIT09ICdvYmplY3QnKVxuICAgICAgICByZXR1cm4gU3RyaW5nKGpzS2V5KTtcbiAgICBpZiAoaXNOb2RlKGtleSkgJiYgY3R4ICYmIGN0eC5kb2MpIHtcbiAgICAgICAgY29uc3Qgc3RyQ3R4ID0gY3JlYXRlU3RyaW5naWZ5Q29udGV4dChjdHguZG9jLCB7fSk7XG4gICAgICAgIHN0ckN0eC5hbmNob3JzID0gbmV3IFNldCgpO1xuICAgICAgICBmb3IgKGNvbnN0IG5vZGUgb2YgY3R4LmFuY2hvcnMua2V5cygpKVxuICAgICAgICAgICAgc3RyQ3R4LmFuY2hvcnMuYWRkKG5vZGUuYW5jaG9yKTtcbiAgICAgICAgc3RyQ3R4LmluRmxvdyA9IHRydWU7XG4gICAgICAgIHN0ckN0eC5pblN0cmluZ2lmeUtleSA9IHRydWU7XG4gICAgICAgIGNvbnN0IHN0cktleSA9IGtleS50b1N0cmluZyhzdHJDdHgpO1xuICAgICAgICBpZiAoIWN0eC5tYXBLZXlXYXJuZWQpIHtcbiAgICAgICAgICAgIGxldCBqc29uU3RyID0gSlNPTi5zdHJpbmdpZnkoc3RyS2V5KTtcbiAgICAgICAgICAgIGlmIChqc29uU3RyLmxlbmd0aCA+IDQwKVxuICAgICAgICAgICAgICAgIGpzb25TdHIgPSBqc29uU3RyLnN1YnN0cmluZygwLCAzNikgKyAnLi4uXCInO1xuICAgICAgICAgICAgd2FybihjdHguZG9jLm9wdGlvbnMubG9nTGV2ZWwsIGBLZXlzIHdpdGggY29sbGVjdGlvbiB2YWx1ZXMgd2lsbCBiZSBzdHJpbmdpZmllZCBkdWUgdG8gSlMgT2JqZWN0IHJlc3RyaWN0aW9uczogJHtqc29uU3RyfS4gU2V0IG1hcEFzTWFwOiB0cnVlIHRvIHVzZSBvYmplY3Qga2V5cy5gKTtcbiAgICAgICAgICAgIGN0eC5tYXBLZXlXYXJuZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHJLZXk7XG4gICAgfVxuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShqc0tleSk7XG59XG5cbmV4cG9ydCB7IGFkZFBhaXJUb0pTTWFwIH07XG4iLCAiaW1wb3J0IHsgY3JlYXRlTm9kZSB9IGZyb20gJy4uL2RvYy9jcmVhdGVOb2RlLmpzJztcbmltcG9ydCB7IHN0cmluZ2lmeVBhaXIgfSBmcm9tICcuLi9zdHJpbmdpZnkvc3RyaW5naWZ5UGFpci5qcyc7XG5pbXBvcnQgeyBhZGRQYWlyVG9KU01hcCB9IGZyb20gJy4vYWRkUGFpclRvSlNNYXAuanMnO1xuaW1wb3J0IHsgTk9ERV9UWVBFLCBQQUlSLCBpc05vZGUgfSBmcm9tICcuL05vZGUuanMnO1xuXG5mdW5jdGlvbiBjcmVhdGVQYWlyKGtleSwgdmFsdWUsIGN0eCkge1xuICAgIGNvbnN0IGsgPSBjcmVhdGVOb2RlKGtleSwgdW5kZWZpbmVkLCBjdHgpO1xuICAgIGNvbnN0IHYgPSBjcmVhdGVOb2RlKHZhbHVlLCB1bmRlZmluZWQsIGN0eCk7XG4gICAgcmV0dXJuIG5ldyBQYWlyKGssIHYpO1xufVxuY2xhc3MgUGFpciB7XG4gICAgY29uc3RydWN0b3Ioa2V5LCB2YWx1ZSA9IG51bGwpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIE5PREVfVFlQRSwgeyB2YWx1ZTogUEFJUiB9KTtcbiAgICAgICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gICAgY2xvbmUoc2NoZW1hKSB7XG4gICAgICAgIGxldCB7IGtleSwgdmFsdWUgfSA9IHRoaXM7XG4gICAgICAgIGlmIChpc05vZGUoa2V5KSlcbiAgICAgICAgICAgIGtleSA9IGtleS5jbG9uZShzY2hlbWEpO1xuICAgICAgICBpZiAoaXNOb2RlKHZhbHVlKSlcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuY2xvbmUoc2NoZW1hKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQYWlyKGtleSwgdmFsdWUpO1xuICAgIH1cbiAgICB0b0pTT04oXywgY3R4KSB7XG4gICAgICAgIGNvbnN0IHBhaXIgPSBjdHggJiYgY3R4Lm1hcEFzTWFwID8gbmV3IE1hcCgpIDoge307XG4gICAgICAgIHJldHVybiBhZGRQYWlyVG9KU01hcChjdHgsIHBhaXIsIHRoaXMpO1xuICAgIH1cbiAgICB0b1N0cmluZyhjdHgsIG9uQ29tbWVudCwgb25DaG9tcEtlZXApIHtcbiAgICAgICAgcmV0dXJuIGN0eCAmJiBjdHguZG9jXG4gICAgICAgICAgICA/IHN0cmluZ2lmeVBhaXIodGhpcywgY3R4LCBvbkNvbW1lbnQsIG9uQ2hvbXBLZWVwKVxuICAgICAgICAgICAgOiBKU09OLnN0cmluZ2lmeSh0aGlzKTtcbiAgICB9XG59XG5cbmV4cG9ydCB7IFBhaXIsIGNyZWF0ZVBhaXIgfTtcbiIsICIvKipcbiAqIGB5YW1sYCBkZWZpbmVzIGRvY3VtZW50LXNwZWNpZmljIG9wdGlvbnMgaW4gdGhyZWUgcGxhY2VzOiBhcyBhbiBhcmd1bWVudCBvZlxuICogcGFyc2UsIGNyZWF0ZSBhbmQgc3RyaW5naWZ5IGNhbGxzLCBpbiB0aGUgdmFsdWVzIG9mIGBZQU1MLmRlZmF1bHRPcHRpb25zYCxcbiAqIGFuZCBpbiB0aGUgdmVyc2lvbi1kZXBlbmRlbnQgYFlBTUwuRG9jdW1lbnQuZGVmYXVsdHNgIG9iamVjdC4gVmFsdWVzIHNldCBpblxuICogYFlBTUwuZGVmYXVsdE9wdGlvbnNgIG92ZXJyaWRlIHZlcnNpb24tZGVwZW5kZW50IGRlZmF1bHRzLCBhbmQgYXJndW1lbnRcbiAqIG9wdGlvbnMgb3ZlcnJpZGUgYm90aC5cbiAqL1xuY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgaW50QXNCaWdJbnQ6IGZhbHNlLFxuICAgIGtlZXBTb3VyY2VUb2tlbnM6IGZhbHNlLFxuICAgIGxvZ0xldmVsOiAnd2FybicsXG4gICAgcHJldHR5RXJyb3JzOiB0cnVlLFxuICAgIHN0cmljdDogdHJ1ZSxcbiAgICB1bmlxdWVLZXlzOiB0cnVlLFxuICAgIHZlcnNpb246ICcxLjInXG59O1xuXG5leHBvcnQgeyBkZWZhdWx0T3B0aW9ucyB9O1xuIiwgImltcG9ydCB7IENvbGxlY3Rpb24gfSBmcm9tICcuLi9ub2Rlcy9Db2xsZWN0aW9uLmpzJztcbmltcG9ydCB7IGlzTm9kZSwgaXNQYWlyIH0gZnJvbSAnLi4vbm9kZXMvTm9kZS5qcyc7XG5pbXBvcnQgeyBzdHJpbmdpZnkgfSBmcm9tICcuL3N0cmluZ2lmeS5qcyc7XG5pbXBvcnQgeyBsaW5lQ29tbWVudCwgaW5kZW50Q29tbWVudCB9IGZyb20gJy4vc3RyaW5naWZ5Q29tbWVudC5qcyc7XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeUNvbGxlY3Rpb24oY29sbGVjdGlvbiwgY3R4LCBvcHRpb25zKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IGZsb3cgPSAoX2EgPSBjdHguaW5GbG93KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBjb2xsZWN0aW9uLmZsb3c7XG4gICAgY29uc3Qgc3RyaW5naWZ5ID0gZmxvdyA/IHN0cmluZ2lmeUZsb3dDb2xsZWN0aW9uIDogc3RyaW5naWZ5QmxvY2tDb2xsZWN0aW9uO1xuICAgIHJldHVybiBzdHJpbmdpZnkoY29sbGVjdGlvbiwgY3R4LCBvcHRpb25zKTtcbn1cbmZ1bmN0aW9uIHN0cmluZ2lmeUJsb2NrQ29sbGVjdGlvbih7IGNvbW1lbnQsIGl0ZW1zIH0sIGN0eCwgeyBibG9ja0l0ZW1QcmVmaXgsIGZsb3dDaGFycywgaXRlbUluZGVudCwgb25DaG9tcEtlZXAsIG9uQ29tbWVudCB9KSB7XG4gICAgY29uc3QgeyBpbmRlbnQsIG9wdGlvbnM6IHsgY29tbWVudFN0cmluZyB9IH0gPSBjdHg7XG4gICAgY29uc3QgaXRlbUN0eCA9IE9iamVjdC5hc3NpZ24oe30sIGN0eCwgeyBpbmRlbnQ6IGl0ZW1JbmRlbnQsIHR5cGU6IG51bGwgfSk7XG4gICAgbGV0IGNob21wS2VlcCA9IGZhbHNlOyAvLyBmbGFnIGZvciB0aGUgcHJlY2VkaW5nIG5vZGUncyBzdGF0dXNcbiAgICBjb25zdCBsaW5lcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29uc3QgaXRlbSA9IGl0ZW1zW2ldO1xuICAgICAgICBsZXQgY29tbWVudCA9IG51bGw7XG4gICAgICAgIGlmIChpc05vZGUoaXRlbSkpIHtcbiAgICAgICAgICAgIGlmICghY2hvbXBLZWVwICYmIGl0ZW0uc3BhY2VCZWZvcmUpXG4gICAgICAgICAgICAgICAgbGluZXMucHVzaCgnJyk7XG4gICAgICAgICAgICBhZGRDb21tZW50QmVmb3JlKGN0eCwgbGluZXMsIGl0ZW0uY29tbWVudEJlZm9yZSwgY2hvbXBLZWVwKTtcbiAgICAgICAgICAgIGlmIChpdGVtLmNvbW1lbnQpXG4gICAgICAgICAgICAgICAgY29tbWVudCA9IGl0ZW0uY29tbWVudDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc1BhaXIoaXRlbSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGlrID0gaXNOb2RlKGl0ZW0ua2V5KSA/IGl0ZW0ua2V5IDogbnVsbDtcbiAgICAgICAgICAgIGlmIChpaykge1xuICAgICAgICAgICAgICAgIGlmICghY2hvbXBLZWVwICYmIGlrLnNwYWNlQmVmb3JlKVxuICAgICAgICAgICAgICAgICAgICBsaW5lcy5wdXNoKCcnKTtcbiAgICAgICAgICAgICAgICBhZGRDb21tZW50QmVmb3JlKGN0eCwgbGluZXMsIGlrLmNvbW1lbnRCZWZvcmUsIGNob21wS2VlcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2hvbXBLZWVwID0gZmFsc2U7XG4gICAgICAgIGxldCBzdHIgPSBzdHJpbmdpZnkoaXRlbSwgaXRlbUN0eCwgKCkgPT4gKGNvbW1lbnQgPSBudWxsKSwgKCkgPT4gKGNob21wS2VlcCA9IHRydWUpKTtcbiAgICAgICAgaWYgKGNvbW1lbnQpXG4gICAgICAgICAgICBzdHIgKz0gbGluZUNvbW1lbnQoc3RyLCBpdGVtSW5kZW50LCBjb21tZW50U3RyaW5nKGNvbW1lbnQpKTtcbiAgICAgICAgaWYgKGNob21wS2VlcCAmJiBjb21tZW50KVxuICAgICAgICAgICAgY2hvbXBLZWVwID0gZmFsc2U7XG4gICAgICAgIGxpbmVzLnB1c2goYmxvY2tJdGVtUHJlZml4ICsgc3RyKTtcbiAgICB9XG4gICAgbGV0IHN0cjtcbiAgICBpZiAobGluZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHN0ciA9IGZsb3dDaGFycy5zdGFydCArIGZsb3dDaGFycy5lbmQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBzdHIgPSBsaW5lc1swXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBsaW5lcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgY29uc3QgbGluZSA9IGxpbmVzW2ldO1xuICAgICAgICAgICAgc3RyICs9IGxpbmUgPyBgXFxuJHtpbmRlbnR9JHtsaW5lfWAgOiAnXFxuJztcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoY29tbWVudCkge1xuICAgICAgICBzdHIgKz0gJ1xcbicgKyBpbmRlbnRDb21tZW50KGNvbW1lbnRTdHJpbmcoY29tbWVudCksIGluZGVudCk7XG4gICAgICAgIGlmIChvbkNvbW1lbnQpXG4gICAgICAgICAgICBvbkNvbW1lbnQoKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoY2hvbXBLZWVwICYmIG9uQ2hvbXBLZWVwKVxuICAgICAgICBvbkNob21wS2VlcCgpO1xuICAgIHJldHVybiBzdHI7XG59XG5mdW5jdGlvbiBzdHJpbmdpZnlGbG93Q29sbGVjdGlvbih7IGNvbW1lbnQsIGl0ZW1zIH0sIGN0eCwgeyBmbG93Q2hhcnMsIGl0ZW1JbmRlbnQsIG9uQ29tbWVudCB9KSB7XG4gICAgY29uc3QgeyBpbmRlbnQsIGluZGVudFN0ZXAsIG9wdGlvbnM6IHsgY29tbWVudFN0cmluZyB9IH0gPSBjdHg7XG4gICAgaXRlbUluZGVudCArPSBpbmRlbnRTdGVwO1xuICAgIGNvbnN0IGl0ZW1DdHggPSBPYmplY3QuYXNzaWduKHt9LCBjdHgsIHtcbiAgICAgICAgaW5kZW50OiBpdGVtSW5kZW50LFxuICAgICAgICBpbkZsb3c6IHRydWUsXG4gICAgICAgIHR5cGU6IG51bGxcbiAgICB9KTtcbiAgICBsZXQgcmVxTmV3bGluZSA9IGZhbHNlO1xuICAgIGxldCBsaW5lc0F0VmFsdWUgPSAwO1xuICAgIGNvbnN0IGxpbmVzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7ICsraSkge1xuICAgICAgICBjb25zdCBpdGVtID0gaXRlbXNbaV07XG4gICAgICAgIGxldCBjb21tZW50ID0gbnVsbDtcbiAgICAgICAgaWYgKGlzTm9kZShpdGVtKSkge1xuICAgICAgICAgICAgaWYgKGl0ZW0uc3BhY2VCZWZvcmUpXG4gICAgICAgICAgICAgICAgbGluZXMucHVzaCgnJyk7XG4gICAgICAgICAgICBhZGRDb21tZW50QmVmb3JlKGN0eCwgbGluZXMsIGl0ZW0uY29tbWVudEJlZm9yZSwgZmFsc2UpO1xuICAgICAgICAgICAgaWYgKGl0ZW0uY29tbWVudClcbiAgICAgICAgICAgICAgICBjb21tZW50ID0gaXRlbS5jb21tZW50O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzUGFpcihpdGVtKSkge1xuICAgICAgICAgICAgY29uc3QgaWsgPSBpc05vZGUoaXRlbS5rZXkpID8gaXRlbS5rZXkgOiBudWxsO1xuICAgICAgICAgICAgaWYgKGlrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlrLnNwYWNlQmVmb3JlKVxuICAgICAgICAgICAgICAgICAgICBsaW5lcy5wdXNoKCcnKTtcbiAgICAgICAgICAgICAgICBhZGRDb21tZW50QmVmb3JlKGN0eCwgbGluZXMsIGlrLmNvbW1lbnRCZWZvcmUsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICBpZiAoaWsuY29tbWVudClcbiAgICAgICAgICAgICAgICAgICAgcmVxTmV3bGluZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBpdiA9IGlzTm9kZShpdGVtLnZhbHVlKSA/IGl0ZW0udmFsdWUgOiBudWxsO1xuICAgICAgICAgICAgaWYgKGl2KSB7XG4gICAgICAgICAgICAgICAgaWYgKGl2LmNvbW1lbnQpXG4gICAgICAgICAgICAgICAgICAgIGNvbW1lbnQgPSBpdi5jb21tZW50O1xuICAgICAgICAgICAgICAgIGlmIChpdi5jb21tZW50QmVmb3JlKVxuICAgICAgICAgICAgICAgICAgICByZXFOZXdsaW5lID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGl0ZW0udmFsdWUgPT0gbnVsbCAmJiBpayAmJiBpay5jb21tZW50KSB7XG4gICAgICAgICAgICAgICAgY29tbWVudCA9IGlrLmNvbW1lbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbW1lbnQpXG4gICAgICAgICAgICByZXFOZXdsaW5lID0gdHJ1ZTtcbiAgICAgICAgbGV0IHN0ciA9IHN0cmluZ2lmeShpdGVtLCBpdGVtQ3R4LCAoKSA9PiAoY29tbWVudCA9IG51bGwpKTtcbiAgICAgICAgaWYgKGkgPCBpdGVtcy5sZW5ndGggLSAxKVxuICAgICAgICAgICAgc3RyICs9ICcsJztcbiAgICAgICAgaWYgKGNvbW1lbnQpXG4gICAgICAgICAgICBzdHIgKz0gbGluZUNvbW1lbnQoc3RyLCBpdGVtSW5kZW50LCBjb21tZW50U3RyaW5nKGNvbW1lbnQpKTtcbiAgICAgICAgaWYgKCFyZXFOZXdsaW5lICYmIChsaW5lcy5sZW5ndGggPiBsaW5lc0F0VmFsdWUgfHwgc3RyLmluY2x1ZGVzKCdcXG4nKSkpXG4gICAgICAgICAgICByZXFOZXdsaW5lID0gdHJ1ZTtcbiAgICAgICAgbGluZXMucHVzaChzdHIpO1xuICAgICAgICBsaW5lc0F0VmFsdWUgPSBsaW5lcy5sZW5ndGg7XG4gICAgfVxuICAgIGxldCBzdHI7XG4gICAgY29uc3QgeyBzdGFydCwgZW5kIH0gPSBmbG93Q2hhcnM7XG4gICAgaWYgKGxpbmVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBzdHIgPSBzdGFydCArIGVuZDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmICghcmVxTmV3bGluZSkge1xuICAgICAgICAgICAgY29uc3QgbGVuID0gbGluZXMucmVkdWNlKChzdW0sIGxpbmUpID0+IHN1bSArIGxpbmUubGVuZ3RoICsgMiwgMik7XG4gICAgICAgICAgICByZXFOZXdsaW5lID0gbGVuID4gQ29sbGVjdGlvbi5tYXhGbG93U3RyaW5nU2luZ2xlTGluZUxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVxTmV3bGluZSkge1xuICAgICAgICAgICAgc3RyID0gc3RhcnQ7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGxpbmUgb2YgbGluZXMpXG4gICAgICAgICAgICAgICAgc3RyICs9IGxpbmUgPyBgXFxuJHtpbmRlbnRTdGVwfSR7aW5kZW50fSR7bGluZX1gIDogJ1xcbic7XG4gICAgICAgICAgICBzdHIgKz0gYFxcbiR7aW5kZW50fSR7ZW5kfWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdHIgPSBgJHtzdGFydH0gJHtsaW5lcy5qb2luKCcgJyl9ICR7ZW5kfWA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNvbW1lbnQpIHtcbiAgICAgICAgc3RyICs9IGxpbmVDb21tZW50KHN0ciwgY29tbWVudFN0cmluZyhjb21tZW50KSwgaW5kZW50KTtcbiAgICAgICAgaWYgKG9uQ29tbWVudClcbiAgICAgICAgICAgIG9uQ29tbWVudCgpO1xuICAgIH1cbiAgICByZXR1cm4gc3RyO1xufVxuZnVuY3Rpb24gYWRkQ29tbWVudEJlZm9yZSh7IGluZGVudCwgb3B0aW9uczogeyBjb21tZW50U3RyaW5nIH0gfSwgbGluZXMsIGNvbW1lbnQsIGNob21wS2VlcCkge1xuICAgIGlmIChjb21tZW50ICYmIGNob21wS2VlcClcbiAgICAgICAgY29tbWVudCA9IGNvbW1lbnQucmVwbGFjZSgvXlxcbisvLCAnJyk7XG4gICAgaWYgKGNvbW1lbnQpIHtcbiAgICAgICAgY29uc3QgaWMgPSBpbmRlbnRDb21tZW50KGNvbW1lbnRTdHJpbmcoY29tbWVudCksIGluZGVudCk7XG4gICAgICAgIGxpbmVzLnB1c2goaWMudHJpbVN0YXJ0KCkpOyAvLyBBdm9pZCBkb3VibGUgaW5kZW50IG9uIGZpcnN0IGxpbmVcbiAgICB9XG59XG5cbmV4cG9ydCB7IHN0cmluZ2lmeUNvbGxlY3Rpb24gfTtcbiIsICJpbXBvcnQgeyBzdHJpbmdpZnlDb2xsZWN0aW9uIH0gZnJvbSAnLi4vc3RyaW5naWZ5L3N0cmluZ2lmeUNvbGxlY3Rpb24uanMnO1xuaW1wb3J0IHsgYWRkUGFpclRvSlNNYXAgfSBmcm9tICcuL2FkZFBhaXJUb0pTTWFwLmpzJztcbmltcG9ydCB7IENvbGxlY3Rpb24gfSBmcm9tICcuL0NvbGxlY3Rpb24uanMnO1xuaW1wb3J0IHsgaXNQYWlyLCBpc1NjYWxhciwgTUFQIH0gZnJvbSAnLi9Ob2RlLmpzJztcbmltcG9ydCB7IFBhaXIgfSBmcm9tICcuL1BhaXIuanMnO1xuaW1wb3J0IHsgaXNTY2FsYXJWYWx1ZSB9IGZyb20gJy4vU2NhbGFyLmpzJztcblxuZnVuY3Rpb24gZmluZFBhaXIoaXRlbXMsIGtleSkge1xuICAgIGNvbnN0IGsgPSBpc1NjYWxhcihrZXkpID8ga2V5LnZhbHVlIDoga2V5O1xuICAgIGZvciAoY29uc3QgaXQgb2YgaXRlbXMpIHtcbiAgICAgICAgaWYgKGlzUGFpcihpdCkpIHtcbiAgICAgICAgICAgIGlmIChpdC5rZXkgPT09IGtleSB8fCBpdC5rZXkgPT09IGspXG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0O1xuICAgICAgICAgICAgaWYgKGlzU2NhbGFyKGl0LmtleSkgJiYgaXQua2V5LnZhbHVlID09PSBrKVxuICAgICAgICAgICAgICAgIHJldHVybiBpdDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuY2xhc3MgWUFNTE1hcCBleHRlbmRzIENvbGxlY3Rpb24ge1xuICAgIGNvbnN0cnVjdG9yKHNjaGVtYSkge1xuICAgICAgICBzdXBlcihNQVAsIHNjaGVtYSk7XG4gICAgICAgIHRoaXMuaXRlbXMgPSBbXTtcbiAgICB9XG4gICAgc3RhdGljIGdldCB0YWdOYW1lKCkge1xuICAgICAgICByZXR1cm4gJ3RhZzp5YW1sLm9yZywyMDAyOm1hcCc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYSB2YWx1ZSB0byB0aGUgY29sbGVjdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvdmVyd3JpdGUgLSBJZiBub3Qgc2V0IGB0cnVlYCwgdXNpbmcgYSBrZXkgdGhhdCBpcyBhbHJlYWR5IGluIHRoZVxuICAgICAqICAgY29sbGVjdGlvbiB3aWxsIHRocm93LiBPdGhlcndpc2UsIG92ZXJ3cml0ZXMgdGhlIHByZXZpb3VzIHZhbHVlLlxuICAgICAqL1xuICAgIGFkZChwYWlyLCBvdmVyd3JpdGUpIHtcbiAgICAgICAgbGV0IF9wYWlyO1xuICAgICAgICBpZiAoaXNQYWlyKHBhaXIpKVxuICAgICAgICAgICAgX3BhaXIgPSBwYWlyO1xuICAgICAgICBlbHNlIGlmICghcGFpciB8fCB0eXBlb2YgcGFpciAhPT0gJ29iamVjdCcgfHwgISgna2V5JyBpbiBwYWlyKSkge1xuICAgICAgICAgICAgLy8gSW4gVHlwZVNjcmlwdCwgdGhpcyBuZXZlciBoYXBwZW5zLlxuICAgICAgICAgICAgX3BhaXIgPSBuZXcgUGFpcihwYWlyLCBwYWlyLnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICBfcGFpciA9IG5ldyBQYWlyKHBhaXIua2V5LCBwYWlyLnZhbHVlKTtcbiAgICAgICAgY29uc3QgcHJldiA9IGZpbmRQYWlyKHRoaXMuaXRlbXMsIF9wYWlyLmtleSk7XG4gICAgICAgIGNvbnN0IHNvcnRFbnRyaWVzID0gdGhpcy5zY2hlbWEgJiYgdGhpcy5zY2hlbWEuc29ydE1hcEVudHJpZXM7XG4gICAgICAgIGlmIChwcmV2KSB7XG4gICAgICAgICAgICBpZiAoIW92ZXJ3cml0ZSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEtleSAke19wYWlyLmtleX0gYWxyZWFkeSBzZXRgKTtcbiAgICAgICAgICAgIC8vIEZvciBzY2FsYXJzLCBrZWVwIHRoZSBvbGQgbm9kZSAmIGl0cyBjb21tZW50cyBhbmQgYW5jaG9yc1xuICAgICAgICAgICAgaWYgKGlzU2NhbGFyKHByZXYudmFsdWUpICYmIGlzU2NhbGFyVmFsdWUoX3BhaXIudmFsdWUpKVxuICAgICAgICAgICAgICAgIHByZXYudmFsdWUudmFsdWUgPSBfcGFpci52YWx1ZTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBwcmV2LnZhbHVlID0gX3BhaXIudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc29ydEVudHJpZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGkgPSB0aGlzLml0ZW1zLmZpbmRJbmRleChpdGVtID0+IHNvcnRFbnRyaWVzKF9wYWlyLCBpdGVtKSA8IDApO1xuICAgICAgICAgICAgaWYgKGkgPT09IC0xKVxuICAgICAgICAgICAgICAgIHRoaXMuaXRlbXMucHVzaChfcGFpcik7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhpcy5pdGVtcy5zcGxpY2UoaSwgMCwgX3BhaXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5pdGVtcy5wdXNoKF9wYWlyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkZWxldGUoa2V5KSB7XG4gICAgICAgIGNvbnN0IGl0ID0gZmluZFBhaXIodGhpcy5pdGVtcywga2V5KTtcbiAgICAgICAgaWYgKCFpdClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgY29uc3QgZGVsID0gdGhpcy5pdGVtcy5zcGxpY2UodGhpcy5pdGVtcy5pbmRleE9mKGl0KSwgMSk7XG4gICAgICAgIHJldHVybiBkZWwubGVuZ3RoID4gMDtcbiAgICB9XG4gICAgZ2V0KGtleSwga2VlcFNjYWxhcikge1xuICAgICAgICBjb25zdCBpdCA9IGZpbmRQYWlyKHRoaXMuaXRlbXMsIGtleSk7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBpdCAmJiBpdC52YWx1ZTtcbiAgICAgICAgcmV0dXJuICFrZWVwU2NhbGFyICYmIGlzU2NhbGFyKG5vZGUpID8gbm9kZS52YWx1ZSA6IG5vZGU7XG4gICAgfVxuICAgIGhhcyhrZXkpIHtcbiAgICAgICAgcmV0dXJuICEhZmluZFBhaXIodGhpcy5pdGVtcywga2V5KTtcbiAgICB9XG4gICAgc2V0KGtleSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5hZGQobmV3IFBhaXIoa2V5LCB2YWx1ZSksIHRydWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gY3R4IC0gQ29udmVyc2lvbiBjb250ZXh0LCBvcmlnaW5hbGx5IHNldCBpbiBEb2N1bWVudCN0b0pTKClcbiAgICAgKiBAcGFyYW0ge0NsYXNzfSBUeXBlIC0gSWYgc2V0LCBmb3JjZXMgdGhlIHJldHVybmVkIGNvbGxlY3Rpb24gdHlwZVxuICAgICAqIEByZXR1cm5zIEluc3RhbmNlIG9mIFR5cGUsIE1hcCwgb3IgT2JqZWN0XG4gICAgICovXG4gICAgdG9KU09OKF8sIGN0eCwgVHlwZSkge1xuICAgICAgICBjb25zdCBtYXAgPSBUeXBlID8gbmV3IFR5cGUoKSA6IGN0eCAmJiBjdHgubWFwQXNNYXAgPyBuZXcgTWFwKCkgOiB7fTtcbiAgICAgICAgaWYgKGN0eCAmJiBjdHgub25DcmVhdGUpXG4gICAgICAgICAgICBjdHgub25DcmVhdGUobWFwKTtcbiAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIHRoaXMuaXRlbXMpXG4gICAgICAgICAgICBhZGRQYWlyVG9KU01hcChjdHgsIG1hcCwgaXRlbSk7XG4gICAgICAgIHJldHVybiBtYXA7XG4gICAgfVxuICAgIHRvU3RyaW5nKGN0eCwgb25Db21tZW50LCBvbkNob21wS2VlcCkge1xuICAgICAgICBpZiAoIWN0eClcbiAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzKTtcbiAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIHRoaXMuaXRlbXMpIHtcbiAgICAgICAgICAgIGlmICghaXNQYWlyKGl0ZW0pKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTWFwIGl0ZW1zIG11c3QgYWxsIGJlIHBhaXJzOyBmb3VuZCAke0pTT04uc3RyaW5naWZ5KGl0ZW0pfSBpbnN0ZWFkYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjdHguYWxsTnVsbFZhbHVlcyAmJiB0aGlzLmhhc0FsbE51bGxWYWx1ZXMoZmFsc2UpKVxuICAgICAgICAgICAgY3R4ID0gT2JqZWN0LmFzc2lnbih7fSwgY3R4LCB7IGFsbE51bGxWYWx1ZXM6IHRydWUgfSk7XG4gICAgICAgIHJldHVybiBzdHJpbmdpZnlDb2xsZWN0aW9uKHRoaXMsIGN0eCwge1xuICAgICAgICAgICAgYmxvY2tJdGVtUHJlZml4OiAnJyxcbiAgICAgICAgICAgIGZsb3dDaGFyczogeyBzdGFydDogJ3snLCBlbmQ6ICd9JyB9LFxuICAgICAgICAgICAgaXRlbUluZGVudDogY3R4LmluZGVudCB8fCAnJyxcbiAgICAgICAgICAgIG9uQ2hvbXBLZWVwLFxuICAgICAgICAgICAgb25Db21tZW50XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuZXhwb3J0IHsgWUFNTE1hcCwgZmluZFBhaXIgfTtcbiIsICJpbXBvcnQgeyBpc01hcCB9IGZyb20gJy4uLy4uL25vZGVzL05vZGUuanMnO1xuaW1wb3J0IHsgY3JlYXRlUGFpciB9IGZyb20gJy4uLy4uL25vZGVzL1BhaXIuanMnO1xuaW1wb3J0IHsgWUFNTE1hcCB9IGZyb20gJy4uLy4uL25vZGVzL1lBTUxNYXAuanMnO1xuXG5mdW5jdGlvbiBjcmVhdGVNYXAoc2NoZW1hLCBvYmosIGN0eCkge1xuICAgIGNvbnN0IHsga2VlcFVuZGVmaW5lZCwgcmVwbGFjZXIgfSA9IGN0eDtcbiAgICBjb25zdCBtYXAgPSBuZXcgWUFNTE1hcChzY2hlbWEpO1xuICAgIGNvbnN0IGFkZCA9IChrZXksIHZhbHVlKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgcmVwbGFjZXIgPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICB2YWx1ZSA9IHJlcGxhY2VyLmNhbGwob2JqLCBrZXksIHZhbHVlKTtcbiAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShyZXBsYWNlcikgJiYgIXJlcGxhY2VyLmluY2x1ZGVzKGtleSkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkIHx8IGtlZXBVbmRlZmluZWQpXG4gICAgICAgICAgICBtYXAuaXRlbXMucHVzaChjcmVhdGVQYWlyKGtleSwgdmFsdWUsIGN0eCkpO1xuICAgIH07XG4gICAgaWYgKG9iaiBpbnN0YW5jZW9mIE1hcCkge1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBvYmopXG4gICAgICAgICAgICBhZGQoa2V5LCB2YWx1ZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKG9iaiAmJiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0Jykge1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhvYmopKVxuICAgICAgICAgICAgYWRkKGtleSwgb2JqW2tleV0pO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHNjaGVtYS5zb3J0TWFwRW50cmllcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBtYXAuaXRlbXMuc29ydChzY2hlbWEuc29ydE1hcEVudHJpZXMpO1xuICAgIH1cbiAgICByZXR1cm4gbWFwO1xufVxuY29uc3QgbWFwID0ge1xuICAgIGNvbGxlY3Rpb246ICdtYXAnLFxuICAgIGNyZWF0ZU5vZGU6IGNyZWF0ZU1hcCxcbiAgICBkZWZhdWx0OiB0cnVlLFxuICAgIG5vZGVDbGFzczogWUFNTE1hcCxcbiAgICB0YWc6ICd0YWc6eWFtbC5vcmcsMjAwMjptYXAnLFxuICAgIHJlc29sdmUobWFwLCBvbkVycm9yKSB7XG4gICAgICAgIGlmICghaXNNYXAobWFwKSlcbiAgICAgICAgICAgIG9uRXJyb3IoJ0V4cGVjdGVkIGEgbWFwcGluZyBmb3IgdGhpcyB0YWcnKTtcbiAgICAgICAgcmV0dXJuIG1hcDtcbiAgICB9XG59O1xuXG5leHBvcnQgeyBtYXAgfTtcbiIsICJpbXBvcnQgeyBzdHJpbmdpZnlDb2xsZWN0aW9uIH0gZnJvbSAnLi4vc3RyaW5naWZ5L3N0cmluZ2lmeUNvbGxlY3Rpb24uanMnO1xuaW1wb3J0IHsgQ29sbGVjdGlvbiB9IGZyb20gJy4vQ29sbGVjdGlvbi5qcyc7XG5pbXBvcnQgeyBTRVEsIGlzU2NhbGFyIH0gZnJvbSAnLi9Ob2RlLmpzJztcbmltcG9ydCB7IGlzU2NhbGFyVmFsdWUgfSBmcm9tICcuL1NjYWxhci5qcyc7XG5pbXBvcnQgeyB0b0pTIH0gZnJvbSAnLi90b0pTLmpzJztcblxuY2xhc3MgWUFNTFNlcSBleHRlbmRzIENvbGxlY3Rpb24ge1xuICAgIGNvbnN0cnVjdG9yKHNjaGVtYSkge1xuICAgICAgICBzdXBlcihTRVEsIHNjaGVtYSk7XG4gICAgICAgIHRoaXMuaXRlbXMgPSBbXTtcbiAgICB9XG4gICAgc3RhdGljIGdldCB0YWdOYW1lKCkge1xuICAgICAgICByZXR1cm4gJ3RhZzp5YW1sLm9yZywyMDAyOnNlcSc7XG4gICAgfVxuICAgIGFkZCh2YWx1ZSkge1xuICAgICAgICB0aGlzLml0ZW1zLnB1c2godmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGEgdmFsdWUgZnJvbSB0aGUgY29sbGVjdGlvbi5cbiAgICAgKlxuICAgICAqIGBrZXlgIG11c3QgY29udGFpbiBhIHJlcHJlc2VudGF0aW9uIG9mIGFuIGludGVnZXIgZm9yIHRoaXMgdG8gc3VjY2VlZC5cbiAgICAgKiBJdCBtYXkgYmUgd3JhcHBlZCBpbiBhIGBTY2FsYXJgLlxuICAgICAqXG4gICAgICogQHJldHVybnMgYHRydWVgIGlmIHRoZSBpdGVtIHdhcyBmb3VuZCBhbmQgcmVtb3ZlZC5cbiAgICAgKi9cbiAgICBkZWxldGUoa2V5KSB7XG4gICAgICAgIGNvbnN0IGlkeCA9IGFzSXRlbUluZGV4KGtleSk7XG4gICAgICAgIGlmICh0eXBlb2YgaWR4ICE9PSAnbnVtYmVyJylcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgY29uc3QgZGVsID0gdGhpcy5pdGVtcy5zcGxpY2UoaWR4LCAxKTtcbiAgICAgICAgcmV0dXJuIGRlbC5sZW5ndGggPiAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGl0ZW0gYXQgYGtleWAsIG9yIGB1bmRlZmluZWRgIGlmIG5vdCBmb3VuZC4gQnkgZGVmYXVsdCB1bndyYXBzXG4gICAgICogc2NhbGFyIHZhbHVlcyBmcm9tIHRoZWlyIHN1cnJvdW5kaW5nIG5vZGU7IHRvIGRpc2FibGUgc2V0IGBrZWVwU2NhbGFyYCB0b1xuICAgICAqIGB0cnVlYCAoY29sbGVjdGlvbnMgYXJlIGFsd2F5cyByZXR1cm5lZCBpbnRhY3QpLlxuICAgICAqXG4gICAgICogYGtleWAgbXVzdCBjb250YWluIGEgcmVwcmVzZW50YXRpb24gb2YgYW4gaW50ZWdlciBmb3IgdGhpcyB0byBzdWNjZWVkLlxuICAgICAqIEl0IG1heSBiZSB3cmFwcGVkIGluIGEgYFNjYWxhcmAuXG4gICAgICovXG4gICAgZ2V0KGtleSwga2VlcFNjYWxhcikge1xuICAgICAgICBjb25zdCBpZHggPSBhc0l0ZW1JbmRleChrZXkpO1xuICAgICAgICBpZiAodHlwZW9mIGlkeCAhPT0gJ251bWJlcicpXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCBpdCA9IHRoaXMuaXRlbXNbaWR4XTtcbiAgICAgICAgcmV0dXJuICFrZWVwU2NhbGFyICYmIGlzU2NhbGFyKGl0KSA/IGl0LnZhbHVlIDogaXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGUgY29sbGVjdGlvbiBpbmNsdWRlcyBhIHZhbHVlIHdpdGggdGhlIGtleSBga2V5YC5cbiAgICAgKlxuICAgICAqIGBrZXlgIG11c3QgY29udGFpbiBhIHJlcHJlc2VudGF0aW9uIG9mIGFuIGludGVnZXIgZm9yIHRoaXMgdG8gc3VjY2VlZC5cbiAgICAgKiBJdCBtYXkgYmUgd3JhcHBlZCBpbiBhIGBTY2FsYXJgLlxuICAgICAqL1xuICAgIGhhcyhrZXkpIHtcbiAgICAgICAgY29uc3QgaWR4ID0gYXNJdGVtSW5kZXgoa2V5KTtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBpZHggPT09ICdudW1iZXInICYmIGlkeCA8IHRoaXMuaXRlbXMubGVuZ3RoO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIGEgdmFsdWUgaW4gdGhpcyBjb2xsZWN0aW9uLiBGb3IgYCEhc2V0YCwgYHZhbHVlYCBuZWVkcyB0byBiZSBhXG4gICAgICogYm9vbGVhbiB0byBhZGQvcmVtb3ZlIHRoZSBpdGVtIGZyb20gdGhlIHNldC5cbiAgICAgKlxuICAgICAqIElmIGBrZXlgIGRvZXMgbm90IGNvbnRhaW4gYSByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnRlZ2VyLCB0aGlzIHdpbGwgdGhyb3cuXG4gICAgICogSXQgbWF5IGJlIHdyYXBwZWQgaW4gYSBgU2NhbGFyYC5cbiAgICAgKi9cbiAgICBzZXQoa2V5LCB2YWx1ZSkge1xuICAgICAgICBjb25zdCBpZHggPSBhc0l0ZW1JbmRleChrZXkpO1xuICAgICAgICBpZiAodHlwZW9mIGlkeCAhPT0gJ251bWJlcicpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIGEgdmFsaWQgaW5kZXgsIG5vdCAke2tleX0uYCk7XG4gICAgICAgIGNvbnN0IHByZXYgPSB0aGlzLml0ZW1zW2lkeF07XG4gICAgICAgIGlmIChpc1NjYWxhcihwcmV2KSAmJiBpc1NjYWxhclZhbHVlKHZhbHVlKSlcbiAgICAgICAgICAgIHByZXYudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy5pdGVtc1tpZHhdID0gdmFsdWU7XG4gICAgfVxuICAgIHRvSlNPTihfLCBjdHgpIHtcbiAgICAgICAgY29uc3Qgc2VxID0gW107XG4gICAgICAgIGlmIChjdHggJiYgY3R4Lm9uQ3JlYXRlKVxuICAgICAgICAgICAgY3R4Lm9uQ3JlYXRlKHNlcSk7XG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIHRoaXMuaXRlbXMpXG4gICAgICAgICAgICBzZXEucHVzaCh0b0pTKGl0ZW0sIFN0cmluZyhpKyspLCBjdHgpKTtcbiAgICAgICAgcmV0dXJuIHNlcTtcbiAgICB9XG4gICAgdG9TdHJpbmcoY3R4LCBvbkNvbW1lbnQsIG9uQ2hvbXBLZWVwKSB7XG4gICAgICAgIGlmICghY3R4KVxuICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMpO1xuICAgICAgICByZXR1cm4gc3RyaW5naWZ5Q29sbGVjdGlvbih0aGlzLCBjdHgsIHtcbiAgICAgICAgICAgIGJsb2NrSXRlbVByZWZpeDogJy0gJyxcbiAgICAgICAgICAgIGZsb3dDaGFyczogeyBzdGFydDogJ1snLCBlbmQ6ICddJyB9LFxuICAgICAgICAgICAgaXRlbUluZGVudDogKGN0eC5pbmRlbnQgfHwgJycpICsgJyAgJyxcbiAgICAgICAgICAgIG9uQ2hvbXBLZWVwLFxuICAgICAgICAgICAgb25Db21tZW50XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGFzSXRlbUluZGV4KGtleSkge1xuICAgIGxldCBpZHggPSBpc1NjYWxhcihrZXkpID8ga2V5LnZhbHVlIDoga2V5O1xuICAgIGlmIChpZHggJiYgdHlwZW9mIGlkeCA9PT0gJ3N0cmluZycpXG4gICAgICAgIGlkeCA9IE51bWJlcihpZHgpO1xuICAgIHJldHVybiB0eXBlb2YgaWR4ID09PSAnbnVtYmVyJyAmJiBOdW1iZXIuaXNJbnRlZ2VyKGlkeCkgJiYgaWR4ID49IDBcbiAgICAgICAgPyBpZHhcbiAgICAgICAgOiBudWxsO1xufVxuXG5leHBvcnQgeyBZQU1MU2VxIH07XG4iLCAiaW1wb3J0IHsgY3JlYXRlTm9kZSB9IGZyb20gJy4uLy4uL2RvYy9jcmVhdGVOb2RlLmpzJztcbmltcG9ydCB7IGlzU2VxIH0gZnJvbSAnLi4vLi4vbm9kZXMvTm9kZS5qcyc7XG5pbXBvcnQgeyBZQU1MU2VxIH0gZnJvbSAnLi4vLi4vbm9kZXMvWUFNTFNlcS5qcyc7XG5cbmZ1bmN0aW9uIGNyZWF0ZVNlcShzY2hlbWEsIG9iaiwgY3R4KSB7XG4gICAgY29uc3QgeyByZXBsYWNlciB9ID0gY3R4O1xuICAgIGNvbnN0IHNlcSA9IG5ldyBZQU1MU2VxKHNjaGVtYSk7XG4gICAgaWYgKG9iaiAmJiBTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KG9iaikpIHtcbiAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICBmb3IgKGxldCBpdCBvZiBvYmopIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcmVwbGFjZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBvYmogaW5zdGFuY2VvZiBTZXQgPyBpdCA6IFN0cmluZyhpKyspO1xuICAgICAgICAgICAgICAgIGl0ID0gcmVwbGFjZXIuY2FsbChvYmosIGtleSwgaXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VxLml0ZW1zLnB1c2goY3JlYXRlTm9kZShpdCwgdW5kZWZpbmVkLCBjdHgpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2VxO1xufVxuY29uc3Qgc2VxID0ge1xuICAgIGNvbGxlY3Rpb246ICdzZXEnLFxuICAgIGNyZWF0ZU5vZGU6IGNyZWF0ZVNlcSxcbiAgICBkZWZhdWx0OiB0cnVlLFxuICAgIG5vZGVDbGFzczogWUFNTFNlcSxcbiAgICB0YWc6ICd0YWc6eWFtbC5vcmcsMjAwMjpzZXEnLFxuICAgIHJlc29sdmUoc2VxLCBvbkVycm9yKSB7XG4gICAgICAgIGlmICghaXNTZXEoc2VxKSlcbiAgICAgICAgICAgIG9uRXJyb3IoJ0V4cGVjdGVkIGEgc2VxdWVuY2UgZm9yIHRoaXMgdGFnJyk7XG4gICAgICAgIHJldHVybiBzZXE7XG4gICAgfVxufTtcblxuZXhwb3J0IHsgc2VxIH07XG4iLCAiaW1wb3J0IHsgc3RyaW5naWZ5U3RyaW5nIH0gZnJvbSAnLi4vLi4vc3RyaW5naWZ5L3N0cmluZ2lmeVN0cmluZy5qcyc7XG5cbmNvbnN0IHN0cmluZyA9IHtcbiAgICBpZGVudGlmeTogdmFsdWUgPT4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyxcbiAgICBkZWZhdWx0OiB0cnVlLFxuICAgIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOnN0cicsXG4gICAgcmVzb2x2ZTogc3RyID0+IHN0cixcbiAgICBzdHJpbmdpZnkoaXRlbSwgY3R4LCBvbkNvbW1lbnQsIG9uQ2hvbXBLZWVwKSB7XG4gICAgICAgIGN0eCA9IE9iamVjdC5hc3NpZ24oeyBhY3R1YWxTdHJpbmc6IHRydWUgfSwgY3R4KTtcbiAgICAgICAgcmV0dXJuIHN0cmluZ2lmeVN0cmluZyhpdGVtLCBjdHgsIG9uQ29tbWVudCwgb25DaG9tcEtlZXApO1xuICAgIH1cbn07XG5cbmV4cG9ydCB7IHN0cmluZyB9O1xuIiwgImltcG9ydCB7IFNjYWxhciB9IGZyb20gJy4uLy4uL25vZGVzL1NjYWxhci5qcyc7XG5cbmNvbnN0IG51bGxUYWcgPSB7XG4gICAgaWRlbnRpZnk6IHZhbHVlID0+IHZhbHVlID09IG51bGwsXG4gICAgY3JlYXRlTm9kZTogKCkgPT4gbmV3IFNjYWxhcihudWxsKSxcbiAgICBkZWZhdWx0OiB0cnVlLFxuICAgIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOm51bGwnLFxuICAgIHRlc3Q6IC9eKD86fnxbTm5ddWxsfE5VTEwpPyQvLFxuICAgIHJlc29sdmU6ICgpID0+IG5ldyBTY2FsYXIobnVsbCksXG4gICAgc3RyaW5naWZ5OiAoeyBzb3VyY2UgfSwgY3R4KSA9PiBzb3VyY2UgJiYgbnVsbFRhZy50ZXN0LnRlc3Qoc291cmNlKSA/IHNvdXJjZSA6IGN0eC5vcHRpb25zLm51bGxTdHJcbn07XG5cbmV4cG9ydCB7IG51bGxUYWcgfTtcbiIsICJpbXBvcnQgeyBTY2FsYXIgfSBmcm9tICcuLi8uLi9ub2Rlcy9TY2FsYXIuanMnO1xuXG5jb25zdCBib29sVGFnID0ge1xuICAgIGlkZW50aWZ5OiB2YWx1ZSA9PiB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJyxcbiAgICBkZWZhdWx0OiB0cnVlLFxuICAgIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOmJvb2wnLFxuICAgIHRlc3Q6IC9eKD86W1R0XXJ1ZXxUUlVFfFtGZl1hbHNlfEZBTFNFKSQvLFxuICAgIHJlc29sdmU6IHN0ciA9PiBuZXcgU2NhbGFyKHN0clswXSA9PT0gJ3QnIHx8IHN0clswXSA9PT0gJ1QnKSxcbiAgICBzdHJpbmdpZnkoeyBzb3VyY2UsIHZhbHVlIH0sIGN0eCkge1xuICAgICAgICBpZiAoc291cmNlICYmIGJvb2xUYWcudGVzdC50ZXN0KHNvdXJjZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHN2ID0gc291cmNlWzBdID09PSAndCcgfHwgc291cmNlWzBdID09PSAnVCc7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IHN2KVxuICAgICAgICAgICAgICAgIHJldHVybiBzb3VyY2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlID8gY3R4Lm9wdGlvbnMudHJ1ZVN0ciA6IGN0eC5vcHRpb25zLmZhbHNlU3RyO1xuICAgIH1cbn07XG5cbmV4cG9ydCB7IGJvb2xUYWcgfTtcbiIsICJmdW5jdGlvbiBzdHJpbmdpZnlOdW1iZXIoeyBmb3JtYXQsIG1pbkZyYWN0aW9uRGlnaXRzLCB0YWcsIHZhbHVlIH0pIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnYmlnaW50JylcbiAgICAgICAgcmV0dXJuIFN0cmluZyh2YWx1ZSk7XG4gICAgY29uc3QgbnVtID0gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyA/IHZhbHVlIDogTnVtYmVyKHZhbHVlKTtcbiAgICBpZiAoIWlzRmluaXRlKG51bSkpXG4gICAgICAgIHJldHVybiBpc05hTihudW0pID8gJy5uYW4nIDogbnVtIDwgMCA/ICctLmluZicgOiAnLmluZic7XG4gICAgbGV0IG4gPSBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG4gICAgaWYgKCFmb3JtYXQgJiZcbiAgICAgICAgbWluRnJhY3Rpb25EaWdpdHMgJiZcbiAgICAgICAgKCF0YWcgfHwgdGFnID09PSAndGFnOnlhbWwub3JnLDIwMDI6ZmxvYXQnKSAmJlxuICAgICAgICAvXlxcZC8udGVzdChuKSkge1xuICAgICAgICBsZXQgaSA9IG4uaW5kZXhPZignLicpO1xuICAgICAgICBpZiAoaSA8IDApIHtcbiAgICAgICAgICAgIGkgPSBuLmxlbmd0aDtcbiAgICAgICAgICAgIG4gKz0gJy4nO1xuICAgICAgICB9XG4gICAgICAgIGxldCBkID0gbWluRnJhY3Rpb25EaWdpdHMgLSAobi5sZW5ndGggLSBpIC0gMSk7XG4gICAgICAgIHdoaWxlIChkLS0gPiAwKVxuICAgICAgICAgICAgbiArPSAnMCc7XG4gICAgfVxuICAgIHJldHVybiBuO1xufVxuXG5leHBvcnQgeyBzdHJpbmdpZnlOdW1iZXIgfTtcbiIsICJpbXBvcnQgeyBTY2FsYXIgfSBmcm9tICcuLi8uLi9ub2Rlcy9TY2FsYXIuanMnO1xuaW1wb3J0IHsgc3RyaW5naWZ5TnVtYmVyIH0gZnJvbSAnLi4vLi4vc3RyaW5naWZ5L3N0cmluZ2lmeU51bWJlci5qcyc7XG5cbmNvbnN0IGZsb2F0TmFOID0ge1xuICAgIGlkZW50aWZ5OiB2YWx1ZSA9PiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInLFxuICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6ZmxvYXQnLFxuICAgIHRlc3Q6IC9eKD86Wy0rXT9cXC4oPzppbmZ8SW5mfElORnxuYW58TmFOfE5BTikpJC8sXG4gICAgcmVzb2x2ZTogc3RyID0+IHN0ci5zbGljZSgtMykudG9Mb3dlckNhc2UoKSA9PT0gJ25hbidcbiAgICAgICAgPyBOYU5cbiAgICAgICAgOiBzdHJbMF0gPT09ICctJ1xuICAgICAgICAgICAgPyBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFlcbiAgICAgICAgICAgIDogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLFxuICAgIHN0cmluZ2lmeTogc3RyaW5naWZ5TnVtYmVyXG59O1xuY29uc3QgZmxvYXRFeHAgPSB7XG4gICAgaWRlbnRpZnk6IHZhbHVlID0+IHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicsXG4gICAgZGVmYXVsdDogdHJ1ZSxcbiAgICB0YWc6ICd0YWc6eWFtbC5vcmcsMjAwMjpmbG9hdCcsXG4gICAgZm9ybWF0OiAnRVhQJyxcbiAgICB0ZXN0OiAvXlstK10/KD86XFwuWzAtOV0rfFswLTldKyg/OlxcLlswLTldKik/KVtlRV1bLStdP1swLTldKyQvLFxuICAgIHJlc29sdmU6IHN0ciA9PiBwYXJzZUZsb2F0KHN0ciksXG4gICAgc3RyaW5naWZ5KG5vZGUpIHtcbiAgICAgICAgY29uc3QgbnVtID0gTnVtYmVyKG5vZGUudmFsdWUpO1xuICAgICAgICByZXR1cm4gaXNGaW5pdGUobnVtKSA/IG51bS50b0V4cG9uZW50aWFsKCkgOiBzdHJpbmdpZnlOdW1iZXIobm9kZSk7XG4gICAgfVxufTtcbmNvbnN0IGZsb2F0ID0ge1xuICAgIGlkZW50aWZ5OiB2YWx1ZSA9PiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInLFxuICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6ZmxvYXQnLFxuICAgIHRlc3Q6IC9eWy0rXT8oPzpcXC5bMC05XSt8WzAtOV0rXFwuWzAtOV0qKSQvLFxuICAgIHJlc29sdmUoc3RyKSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBuZXcgU2NhbGFyKHBhcnNlRmxvYXQoc3RyKSk7XG4gICAgICAgIGNvbnN0IGRvdCA9IHN0ci5pbmRleE9mKCcuJyk7XG4gICAgICAgIGlmIChkb3QgIT09IC0xICYmIHN0cltzdHIubGVuZ3RoIC0gMV0gPT09ICcwJylcbiAgICAgICAgICAgIG5vZGUubWluRnJhY3Rpb25EaWdpdHMgPSBzdHIubGVuZ3RoIC0gZG90IC0gMTtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfSxcbiAgICBzdHJpbmdpZnk6IHN0cmluZ2lmeU51bWJlclxufTtcblxuZXhwb3J0IHsgZmxvYXQsIGZsb2F0RXhwLCBmbG9hdE5hTiB9O1xuIiwgImltcG9ydCB7IHN0cmluZ2lmeU51bWJlciB9IGZyb20gJy4uLy4uL3N0cmluZ2lmeS9zdHJpbmdpZnlOdW1iZXIuanMnO1xuXG5jb25zdCBpbnRJZGVudGlmeSA9ICh2YWx1ZSkgPT4gdHlwZW9mIHZhbHVlID09PSAnYmlnaW50JyB8fCBOdW1iZXIuaXNJbnRlZ2VyKHZhbHVlKTtcbmNvbnN0IGludFJlc29sdmUgPSAoc3RyLCBvZmZzZXQsIHJhZGl4LCB7IGludEFzQmlnSW50IH0pID0+IChpbnRBc0JpZ0ludCA/IEJpZ0ludChzdHIpIDogcGFyc2VJbnQoc3RyLnN1YnN0cmluZyhvZmZzZXQpLCByYWRpeCkpO1xuZnVuY3Rpb24gaW50U3RyaW5naWZ5KG5vZGUsIHJhZGl4LCBwcmVmaXgpIHtcbiAgICBjb25zdCB7IHZhbHVlIH0gPSBub2RlO1xuICAgIGlmIChpbnRJZGVudGlmeSh2YWx1ZSkgJiYgdmFsdWUgPj0gMClcbiAgICAgICAgcmV0dXJuIHByZWZpeCArIHZhbHVlLnRvU3RyaW5nKHJhZGl4KTtcbiAgICByZXR1cm4gc3RyaW5naWZ5TnVtYmVyKG5vZGUpO1xufVxuY29uc3QgaW50T2N0ID0ge1xuICAgIGlkZW50aWZ5OiB2YWx1ZSA9PiBpbnRJZGVudGlmeSh2YWx1ZSkgJiYgdmFsdWUgPj0gMCxcbiAgICBkZWZhdWx0OiB0cnVlLFxuICAgIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOmludCcsXG4gICAgZm9ybWF0OiAnT0NUJyxcbiAgICB0ZXN0OiAvXjBvWzAtN10rJC8sXG4gICAgcmVzb2x2ZTogKHN0ciwgX29uRXJyb3IsIG9wdCkgPT4gaW50UmVzb2x2ZShzdHIsIDIsIDgsIG9wdCksXG4gICAgc3RyaW5naWZ5OiBub2RlID0+IGludFN0cmluZ2lmeShub2RlLCA4LCAnMG8nKVxufTtcbmNvbnN0IGludCA9IHtcbiAgICBpZGVudGlmeTogaW50SWRlbnRpZnksXG4gICAgZGVmYXVsdDogdHJ1ZSxcbiAgICB0YWc6ICd0YWc6eWFtbC5vcmcsMjAwMjppbnQnLFxuICAgIHRlc3Q6IC9eWy0rXT9bMC05XSskLyxcbiAgICByZXNvbHZlOiAoc3RyLCBfb25FcnJvciwgb3B0KSA9PiBpbnRSZXNvbHZlKHN0ciwgMCwgMTAsIG9wdCksXG4gICAgc3RyaW5naWZ5OiBzdHJpbmdpZnlOdW1iZXJcbn07XG5jb25zdCBpbnRIZXggPSB7XG4gICAgaWRlbnRpZnk6IHZhbHVlID0+IGludElkZW50aWZ5KHZhbHVlKSAmJiB2YWx1ZSA+PSAwLFxuICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6aW50JyxcbiAgICBmb3JtYXQ6ICdIRVgnLFxuICAgIHRlc3Q6IC9eMHhbMC05YS1mQS1GXSskLyxcbiAgICByZXNvbHZlOiAoc3RyLCBfb25FcnJvciwgb3B0KSA9PiBpbnRSZXNvbHZlKHN0ciwgMiwgMTYsIG9wdCksXG4gICAgc3RyaW5naWZ5OiBub2RlID0+IGludFN0cmluZ2lmeShub2RlLCAxNiwgJzB4Jylcbn07XG5cbmV4cG9ydCB7IGludCwgaW50SGV4LCBpbnRPY3QgfTtcbiIsICJpbXBvcnQgeyBtYXAgfSBmcm9tICcuLi9jb21tb24vbWFwLmpzJztcbmltcG9ydCB7IG51bGxUYWcgfSBmcm9tICcuLi9jb21tb24vbnVsbC5qcyc7XG5pbXBvcnQgeyBzZXEgfSBmcm9tICcuLi9jb21tb24vc2VxLmpzJztcbmltcG9ydCB7IHN0cmluZyB9IGZyb20gJy4uL2NvbW1vbi9zdHJpbmcuanMnO1xuaW1wb3J0IHsgYm9vbFRhZyB9IGZyb20gJy4vYm9vbC5qcyc7XG5pbXBvcnQgeyBmbG9hdE5hTiwgZmxvYXRFeHAsIGZsb2F0IH0gZnJvbSAnLi9mbG9hdC5qcyc7XG5pbXBvcnQgeyBpbnRPY3QsIGludCwgaW50SGV4IH0gZnJvbSAnLi9pbnQuanMnO1xuXG5jb25zdCBzY2hlbWEgPSBbXG4gICAgbWFwLFxuICAgIHNlcSxcbiAgICBzdHJpbmcsXG4gICAgbnVsbFRhZyxcbiAgICBib29sVGFnLFxuICAgIGludE9jdCxcbiAgICBpbnQsXG4gICAgaW50SGV4LFxuICAgIGZsb2F0TmFOLFxuICAgIGZsb2F0RXhwLFxuICAgIGZsb2F0XG5dO1xuXG5leHBvcnQgeyBzY2hlbWEgfTtcbiIsICJpbXBvcnQgeyBTY2FsYXIgfSBmcm9tICcuLi8uLi9ub2Rlcy9TY2FsYXIuanMnO1xuaW1wb3J0IHsgbWFwIH0gZnJvbSAnLi4vY29tbW9uL21hcC5qcyc7XG5pbXBvcnQgeyBzZXEgfSBmcm9tICcuLi9jb21tb24vc2VxLmpzJztcblxuZnVuY3Rpb24gaW50SWRlbnRpZnkodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnYmlnaW50JyB8fCBOdW1iZXIuaXNJbnRlZ2VyKHZhbHVlKTtcbn1cbmNvbnN0IHN0cmluZ2lmeUpTT04gPSAoeyB2YWx1ZSB9KSA9PiBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG5jb25zdCBqc29uU2NhbGFycyA9IFtcbiAgICB7XG4gICAgICAgIGlkZW50aWZ5OiB2YWx1ZSA9PiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnLFxuICAgICAgICBkZWZhdWx0OiB0cnVlLFxuICAgICAgICB0YWc6ICd0YWc6eWFtbC5vcmcsMjAwMjpzdHInLFxuICAgICAgICByZXNvbHZlOiBzdHIgPT4gc3RyLFxuICAgICAgICBzdHJpbmdpZnk6IHN0cmluZ2lmeUpTT05cbiAgICB9LFxuICAgIHtcbiAgICAgICAgaWRlbnRpZnk6IHZhbHVlID0+IHZhbHVlID09IG51bGwsXG4gICAgICAgIGNyZWF0ZU5vZGU6ICgpID0+IG5ldyBTY2FsYXIobnVsbCksXG4gICAgICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgICAgIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOm51bGwnLFxuICAgICAgICB0ZXN0OiAvXm51bGwkLyxcbiAgICAgICAgcmVzb2x2ZTogKCkgPT4gbnVsbCxcbiAgICAgICAgc3RyaW5naWZ5OiBzdHJpbmdpZnlKU09OXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGlkZW50aWZ5OiB2YWx1ZSA9PiB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJyxcbiAgICAgICAgZGVmYXVsdDogdHJ1ZSxcbiAgICAgICAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6Ym9vbCcsXG4gICAgICAgIHRlc3Q6IC9edHJ1ZXxmYWxzZSQvLFxuICAgICAgICByZXNvbHZlOiBzdHIgPT4gc3RyID09PSAndHJ1ZScsXG4gICAgICAgIHN0cmluZ2lmeTogc3RyaW5naWZ5SlNPTlxuICAgIH0sXG4gICAge1xuICAgICAgICBpZGVudGlmeTogaW50SWRlbnRpZnksXG4gICAgICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgICAgIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOmludCcsXG4gICAgICAgIHRlc3Q6IC9eLT8oPzowfFsxLTldWzAtOV0qKSQvLFxuICAgICAgICByZXNvbHZlOiAoc3RyLCBfb25FcnJvciwgeyBpbnRBc0JpZ0ludCB9KSA9PiBpbnRBc0JpZ0ludCA/IEJpZ0ludChzdHIpIDogcGFyc2VJbnQoc3RyLCAxMCksXG4gICAgICAgIHN0cmluZ2lmeTogKHsgdmFsdWUgfSkgPT4gaW50SWRlbnRpZnkodmFsdWUpID8gdmFsdWUudG9TdHJpbmcoKSA6IEpTT04uc3RyaW5naWZ5KHZhbHVlKVxuICAgIH0sXG4gICAge1xuICAgICAgICBpZGVudGlmeTogdmFsdWUgPT4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyxcbiAgICAgICAgZGVmYXVsdDogdHJ1ZSxcbiAgICAgICAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6ZmxvYXQnLFxuICAgICAgICB0ZXN0OiAvXi0/KD86MHxbMS05XVswLTldKikoPzpcXC5bMC05XSopPyg/OltlRV1bLStdP1swLTldKyk/JC8sXG4gICAgICAgIHJlc29sdmU6IHN0ciA9PiBwYXJzZUZsb2F0KHN0ciksXG4gICAgICAgIHN0cmluZ2lmeTogc3RyaW5naWZ5SlNPTlxuICAgIH1cbl07XG5jb25zdCBqc29uRXJyb3IgPSB7XG4gICAgZGVmYXVsdDogdHJ1ZSxcbiAgICB0YWc6ICcnLFxuICAgIHRlc3Q6IC9eLyxcbiAgICByZXNvbHZlKHN0ciwgb25FcnJvcikge1xuICAgICAgICBvbkVycm9yKGBVbnJlc29sdmVkIHBsYWluIHNjYWxhciAke0pTT04uc3RyaW5naWZ5KHN0cil9YCk7XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgfVxufTtcbmNvbnN0IHNjaGVtYSA9IFttYXAsIHNlcV0uY29uY2F0KGpzb25TY2FsYXJzLCBqc29uRXJyb3IpO1xuXG5leHBvcnQgeyBzY2hlbWEgfTtcbiIsICJpbXBvcnQgeyBTY2FsYXIgfSBmcm9tICcuLi8uLi9ub2Rlcy9TY2FsYXIuanMnO1xuaW1wb3J0IHsgc3RyaW5naWZ5U3RyaW5nIH0gZnJvbSAnLi4vLi4vc3RyaW5naWZ5L3N0cmluZ2lmeVN0cmluZy5qcyc7XG5cbmNvbnN0IGJpbmFyeSA9IHtcbiAgICBpZGVudGlmeTogdmFsdWUgPT4gdmFsdWUgaW5zdGFuY2VvZiBVaW50OEFycmF5LFxuICAgIGRlZmF1bHQ6IGZhbHNlLFxuICAgIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOmJpbmFyeScsXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIEJ1ZmZlciBpbiBub2RlIGFuZCBhbiBVaW50OEFycmF5IGluIGJyb3dzZXJzXG4gICAgICpcbiAgICAgKiBUbyB1c2UgdGhlIHJlc3VsdGluZyBidWZmZXIgYXMgYW4gaW1hZ2UsIHlvdSdsbCB3YW50IHRvIGRvIHNvbWV0aGluZyBsaWtlOlxuICAgICAqXG4gICAgICogICBjb25zdCBibG9iID0gbmV3IEJsb2IoW2J1ZmZlcl0sIHsgdHlwZTogJ2ltYWdlL2pwZWcnIH0pXG4gICAgICogICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjcGhvdG8nKS5zcmMgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpXG4gICAgICovXG4gICAgcmVzb2x2ZShzcmMsIG9uRXJyb3IpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBCdWZmZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybiBCdWZmZXIuZnJvbShzcmMsICdiYXNlNjQnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgYXRvYiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgLy8gT24gSUUgMTEsIGF0b2IoKSBjYW4ndCBoYW5kbGUgbmV3bGluZXNcbiAgICAgICAgICAgIGNvbnN0IHN0ciA9IGF0b2Ioc3JjLnJlcGxhY2UoL1tcXG5cXHJdL2csICcnKSk7XG4gICAgICAgICAgICBjb25zdCBidWZmZXIgPSBuZXcgVWludDhBcnJheShzdHIubGVuZ3RoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgIGJ1ZmZlcltpXSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICAgICAgcmV0dXJuIGJ1ZmZlcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9uRXJyb3IoJ1RoaXMgZW52aXJvbm1lbnQgZG9lcyBub3Qgc3VwcG9ydCByZWFkaW5nIGJpbmFyeSB0YWdzOyBlaXRoZXIgQnVmZmVyIG9yIGF0b2IgaXMgcmVxdWlyZWQnKTtcbiAgICAgICAgICAgIHJldHVybiBzcmM7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHN0cmluZ2lmeSh7IGNvbW1lbnQsIHR5cGUsIHZhbHVlIH0sIGN0eCwgb25Db21tZW50LCBvbkNob21wS2VlcCkge1xuICAgICAgICBjb25zdCBidWYgPSB2YWx1ZTsgLy8gY2hlY2tlZCBlYXJsaWVyIGJ5IGJpbmFyeS5pZGVudGlmeSgpXG4gICAgICAgIGxldCBzdHI7XG4gICAgICAgIGlmICh0eXBlb2YgQnVmZmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBzdHIgPVxuICAgICAgICAgICAgICAgIGJ1ZiBpbnN0YW5jZW9mIEJ1ZmZlclxuICAgICAgICAgICAgICAgICAgICA/IGJ1Zi50b1N0cmluZygnYmFzZTY0JylcbiAgICAgICAgICAgICAgICAgICAgOiBCdWZmZXIuZnJvbShidWYuYnVmZmVyKS50b1N0cmluZygnYmFzZTY0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGJ0b2EgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGxldCBzID0gJyc7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ1Zi5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICBzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKTtcbiAgICAgICAgICAgIHN0ciA9IGJ0b2Eocyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgZW52aXJvbm1lbnQgZG9lcyBub3Qgc3VwcG9ydCB3cml0aW5nIGJpbmFyeSB0YWdzOyBlaXRoZXIgQnVmZmVyIG9yIGJ0b2EgaXMgcmVxdWlyZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXR5cGUpXG4gICAgICAgICAgICB0eXBlID0gU2NhbGFyLkJMT0NLX0xJVEVSQUw7XG4gICAgICAgIGlmICh0eXBlICE9PSBTY2FsYXIuUVVPVEVfRE9VQkxFKSB7XG4gICAgICAgICAgICBjb25zdCBsaW5lV2lkdGggPSBNYXRoLm1heChjdHgub3B0aW9ucy5saW5lV2lkdGggLSBjdHguaW5kZW50Lmxlbmd0aCwgY3R4Lm9wdGlvbnMubWluQ29udGVudFdpZHRoKTtcbiAgICAgICAgICAgIGNvbnN0IG4gPSBNYXRoLmNlaWwoc3RyLmxlbmd0aCAvIGxpbmVXaWR0aCk7XG4gICAgICAgICAgICBjb25zdCBsaW5lcyA9IG5ldyBBcnJheShuKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBvID0gMDsgaSA8IG47ICsraSwgbyArPSBsaW5lV2lkdGgpIHtcbiAgICAgICAgICAgICAgICBsaW5lc1tpXSA9IHN0ci5zdWJzdHIobywgbGluZVdpZHRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0ciA9IGxpbmVzLmpvaW4odHlwZSA9PT0gU2NhbGFyLkJMT0NLX0xJVEVSQUwgPyAnXFxuJyA6ICcgJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0cmluZ2lmeVN0cmluZyh7IGNvbW1lbnQsIHR5cGUsIHZhbHVlOiBzdHIgfSwgY3R4LCBvbkNvbW1lbnQsIG9uQ2hvbXBLZWVwKTtcbiAgICB9XG59O1xuXG5leHBvcnQgeyBiaW5hcnkgfTtcbiIsICJpbXBvcnQgeyBpc1NlcSwgaXNQYWlyLCBpc01hcCB9IGZyb20gJy4uLy4uL25vZGVzL05vZGUuanMnO1xuaW1wb3J0IHsgUGFpciwgY3JlYXRlUGFpciB9IGZyb20gJy4uLy4uL25vZGVzL1BhaXIuanMnO1xuaW1wb3J0IHsgU2NhbGFyIH0gZnJvbSAnLi4vLi4vbm9kZXMvU2NhbGFyLmpzJztcbmltcG9ydCB7IFlBTUxTZXEgfSBmcm9tICcuLi8uLi9ub2Rlcy9ZQU1MU2VxLmpzJztcblxuZnVuY3Rpb24gcmVzb2x2ZVBhaXJzKHNlcSwgb25FcnJvcikge1xuICAgIGlmIChpc1NlcShzZXEpKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2VxLml0ZW1zLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBsZXQgaXRlbSA9IHNlcS5pdGVtc1tpXTtcbiAgICAgICAgICAgIGlmIChpc1BhaXIoaXRlbSkpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBlbHNlIGlmIChpc01hcChpdGVtKSkge1xuICAgICAgICAgICAgICAgIGlmIChpdGVtLml0ZW1zLmxlbmd0aCA+IDEpXG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3IoJ0VhY2ggcGFpciBtdXN0IGhhdmUgaXRzIG93biBzZXF1ZW5jZSBpbmRpY2F0b3InKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwYWlyID0gaXRlbS5pdGVtc1swXSB8fCBuZXcgUGFpcihuZXcgU2NhbGFyKG51bGwpKTtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbS5jb21tZW50QmVmb3JlKVxuICAgICAgICAgICAgICAgICAgICBwYWlyLmtleS5jb21tZW50QmVmb3JlID0gcGFpci5rZXkuY29tbWVudEJlZm9yZVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBgJHtpdGVtLmNvbW1lbnRCZWZvcmV9XFxuJHtwYWlyLmtleS5jb21tZW50QmVmb3JlfWBcbiAgICAgICAgICAgICAgICAgICAgICAgIDogaXRlbS5jb21tZW50QmVmb3JlO1xuICAgICAgICAgICAgICAgIGlmIChpdGVtLmNvbW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY24gPSBwYWlyLnZhbHVlIHx8IHBhaXIua2V5O1xuICAgICAgICAgICAgICAgICAgICBjbi5jb21tZW50ID0gY24uY29tbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgPyBgJHtpdGVtLmNvbW1lbnR9XFxuJHtjbi5jb21tZW50fWBcbiAgICAgICAgICAgICAgICAgICAgICAgIDogaXRlbS5jb21tZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpdGVtID0gcGFpcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlcS5pdGVtc1tpXSA9IGlzUGFpcihpdGVtKSA/IGl0ZW0gOiBuZXcgUGFpcihpdGVtKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlXG4gICAgICAgIG9uRXJyb3IoJ0V4cGVjdGVkIGEgc2VxdWVuY2UgZm9yIHRoaXMgdGFnJyk7XG4gICAgcmV0dXJuIHNlcTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVBhaXJzKHNjaGVtYSwgaXRlcmFibGUsIGN0eCkge1xuICAgIGNvbnN0IHsgcmVwbGFjZXIgfSA9IGN0eDtcbiAgICBjb25zdCBwYWlycyA9IG5ldyBZQU1MU2VxKHNjaGVtYSk7XG4gICAgcGFpcnMudGFnID0gJ3RhZzp5YW1sLm9yZywyMDAyOnBhaXJzJztcbiAgICBsZXQgaSA9IDA7XG4gICAgaWYgKGl0ZXJhYmxlICYmIFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoaXRlcmFibGUpKVxuICAgICAgICBmb3IgKGxldCBpdCBvZiBpdGVyYWJsZSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiByZXBsYWNlciA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgICAgICBpdCA9IHJlcGxhY2VyLmNhbGwoaXRlcmFibGUsIFN0cmluZyhpKyspLCBpdCk7XG4gICAgICAgICAgICBsZXQga2V5LCB2YWx1ZTtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGl0KSkge1xuICAgICAgICAgICAgICAgIGlmIChpdC5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAga2V5ID0gaXRbMF07XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gaXRbMV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgRXhwZWN0ZWQgW2tleSwgdmFsdWVdIHR1cGxlOiAke2l0fWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXQgJiYgaXQgaW5zdGFuY2VvZiBPYmplY3QpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoaXQpO1xuICAgICAgICAgICAgICAgIGlmIChrZXlzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICBrZXkgPSBrZXlzWzBdO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGl0W2tleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgRXhwZWN0ZWQgeyBrZXk6IHZhbHVlIH0gdHVwbGU6ICR7aXR9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBrZXkgPSBpdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhaXJzLml0ZW1zLnB1c2goY3JlYXRlUGFpcihrZXksIHZhbHVlLCBjdHgpKTtcbiAgICAgICAgfVxuICAgIHJldHVybiBwYWlycztcbn1cbmNvbnN0IHBhaXJzID0ge1xuICAgIGNvbGxlY3Rpb246ICdzZXEnLFxuICAgIGRlZmF1bHQ6IGZhbHNlLFxuICAgIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOnBhaXJzJyxcbiAgICByZXNvbHZlOiByZXNvbHZlUGFpcnMsXG4gICAgY3JlYXRlTm9kZTogY3JlYXRlUGFpcnNcbn07XG5cbmV4cG9ydCB7IGNyZWF0ZVBhaXJzLCBwYWlycywgcmVzb2x2ZVBhaXJzIH07XG4iLCAiaW1wb3J0IHsgWUFNTFNlcSB9IGZyb20gJy4uLy4uL25vZGVzL1lBTUxTZXEuanMnO1xuaW1wb3J0IHsgdG9KUyB9IGZyb20gJy4uLy4uL25vZGVzL3RvSlMuanMnO1xuaW1wb3J0IHsgaXNTY2FsYXIsIGlzUGFpciB9IGZyb20gJy4uLy4uL25vZGVzL05vZGUuanMnO1xuaW1wb3J0IHsgWUFNTE1hcCB9IGZyb20gJy4uLy4uL25vZGVzL1lBTUxNYXAuanMnO1xuaW1wb3J0IHsgcmVzb2x2ZVBhaXJzLCBjcmVhdGVQYWlycyB9IGZyb20gJy4vcGFpcnMuanMnO1xuXG5jbGFzcyBZQU1MT01hcCBleHRlbmRzIFlBTUxTZXEge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmFkZCA9IFlBTUxNYXAucHJvdG90eXBlLmFkZC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmRlbGV0ZSA9IFlBTUxNYXAucHJvdG90eXBlLmRlbGV0ZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmdldCA9IFlBTUxNYXAucHJvdG90eXBlLmdldC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmhhcyA9IFlBTUxNYXAucHJvdG90eXBlLmhhcy5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnNldCA9IFlBTUxNYXAucHJvdG90eXBlLnNldC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnRhZyA9IFlBTUxPTWFwLnRhZztcbiAgICB9XG4gICAgLyoqXG4gICAgICogSWYgYGN0eGAgaXMgZ2l2ZW4sIHRoZSByZXR1cm4gdHlwZSBpcyBhY3R1YWxseSBgTWFwPHVua25vd24sIHVua25vd24+YCxcbiAgICAgKiBidXQgVHlwZVNjcmlwdCB3b24ndCBhbGxvdyB3aWRlbmluZyB0aGUgc2lnbmF0dXJlIG9mIGEgY2hpbGQgbWV0aG9kLlxuICAgICAqL1xuICAgIHRvSlNPTihfLCBjdHgpIHtcbiAgICAgICAgaWYgKCFjdHgpXG4gICAgICAgICAgICByZXR1cm4gc3VwZXIudG9KU09OKF8pO1xuICAgICAgICBjb25zdCBtYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIGlmIChjdHggJiYgY3R4Lm9uQ3JlYXRlKVxuICAgICAgICAgICAgY3R4Lm9uQ3JlYXRlKG1hcCk7XG4gICAgICAgIGZvciAoY29uc3QgcGFpciBvZiB0aGlzLml0ZW1zKSB7XG4gICAgICAgICAgICBsZXQga2V5LCB2YWx1ZTtcbiAgICAgICAgICAgIGlmIChpc1BhaXIocGFpcikpIHtcbiAgICAgICAgICAgICAgICBrZXkgPSB0b0pTKHBhaXIua2V5LCAnJywgY3R4KTtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHRvSlMocGFpci52YWx1ZSwga2V5LCBjdHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAga2V5ID0gdG9KUyhwYWlyLCAnJywgY3R4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYXAuaGFzKGtleSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdPcmRlcmVkIG1hcHMgbXVzdCBub3QgaW5jbHVkZSBkdXBsaWNhdGUga2V5cycpO1xuICAgICAgICAgICAgbWFwLnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWFwO1xuICAgIH1cbn1cbllBTUxPTWFwLnRhZyA9ICd0YWc6eWFtbC5vcmcsMjAwMjpvbWFwJztcbmNvbnN0IG9tYXAgPSB7XG4gICAgY29sbGVjdGlvbjogJ3NlcScsXG4gICAgaWRlbnRpZnk6IHZhbHVlID0+IHZhbHVlIGluc3RhbmNlb2YgTWFwLFxuICAgIG5vZGVDbGFzczogWUFNTE9NYXAsXG4gICAgZGVmYXVsdDogZmFsc2UsXG4gICAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6b21hcCcsXG4gICAgcmVzb2x2ZShzZXEsIG9uRXJyb3IpIHtcbiAgICAgICAgY29uc3QgcGFpcnMgPSByZXNvbHZlUGFpcnMoc2VxLCBvbkVycm9yKTtcbiAgICAgICAgY29uc3Qgc2VlbktleXMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCB7IGtleSB9IG9mIHBhaXJzLml0ZW1zKSB7XG4gICAgICAgICAgICBpZiAoaXNTY2FsYXIoa2V5KSkge1xuICAgICAgICAgICAgICAgIGlmIChzZWVuS2V5cy5pbmNsdWRlcyhrZXkudmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3IoYE9yZGVyZWQgbWFwcyBtdXN0IG5vdCBpbmNsdWRlIGR1cGxpY2F0ZSBrZXlzOiAke2tleS52YWx1ZX1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNlZW5LZXlzLnB1c2goa2V5LnZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24obmV3IFlBTUxPTWFwKCksIHBhaXJzKTtcbiAgICB9LFxuICAgIGNyZWF0ZU5vZGUoc2NoZW1hLCBpdGVyYWJsZSwgY3R4KSB7XG4gICAgICAgIGNvbnN0IHBhaXJzID0gY3JlYXRlUGFpcnMoc2NoZW1hLCBpdGVyYWJsZSwgY3R4KTtcbiAgICAgICAgY29uc3Qgb21hcCA9IG5ldyBZQU1MT01hcCgpO1xuICAgICAgICBvbWFwLml0ZW1zID0gcGFpcnMuaXRlbXM7XG4gICAgICAgIHJldHVybiBvbWFwO1xuICAgIH1cbn07XG5cbmV4cG9ydCB7IFlBTUxPTWFwLCBvbWFwIH07XG4iLCAiaW1wb3J0IHsgU2NhbGFyIH0gZnJvbSAnLi4vLi4vbm9kZXMvU2NhbGFyLmpzJztcblxuZnVuY3Rpb24gYm9vbFN0cmluZ2lmeSh7IHZhbHVlLCBzb3VyY2UgfSwgY3R4KSB7XG4gICAgY29uc3QgYm9vbE9iaiA9IHZhbHVlID8gdHJ1ZVRhZyA6IGZhbHNlVGFnO1xuICAgIGlmIChzb3VyY2UgJiYgYm9vbE9iai50ZXN0LnRlc3Qoc291cmNlKSlcbiAgICAgICAgcmV0dXJuIHNvdXJjZTtcbiAgICByZXR1cm4gdmFsdWUgPyBjdHgub3B0aW9ucy50cnVlU3RyIDogY3R4Lm9wdGlvbnMuZmFsc2VTdHI7XG59XG5jb25zdCB0cnVlVGFnID0ge1xuICAgIGlkZW50aWZ5OiB2YWx1ZSA9PiB2YWx1ZSA9PT0gdHJ1ZSxcbiAgICBkZWZhdWx0OiB0cnVlLFxuICAgIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOmJvb2wnLFxuICAgIHRlc3Q6IC9eKD86WXx5fFtZeV1lc3xZRVN8W1R0XXJ1ZXxUUlVFfFtPb11ufE9OKSQvLFxuICAgIHJlc29sdmU6ICgpID0+IG5ldyBTY2FsYXIodHJ1ZSksXG4gICAgc3RyaW5naWZ5OiBib29sU3RyaW5naWZ5XG59O1xuY29uc3QgZmFsc2VUYWcgPSB7XG4gICAgaWRlbnRpZnk6IHZhbHVlID0+IHZhbHVlID09PSBmYWxzZSxcbiAgICBkZWZhdWx0OiB0cnVlLFxuICAgIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOmJvb2wnLFxuICAgIHRlc3Q6IC9eKD86TnxufFtObl1vfE5PfFtGZl1hbHNlfEZBTFNFfFtPb11mZnxPRkYpJC9pLFxuICAgIHJlc29sdmU6ICgpID0+IG5ldyBTY2FsYXIoZmFsc2UpLFxuICAgIHN0cmluZ2lmeTogYm9vbFN0cmluZ2lmeVxufTtcblxuZXhwb3J0IHsgZmFsc2VUYWcsIHRydWVUYWcgfTtcbiIsICJpbXBvcnQgeyBTY2FsYXIgfSBmcm9tICcuLi8uLi9ub2Rlcy9TY2FsYXIuanMnO1xuaW1wb3J0IHsgc3RyaW5naWZ5TnVtYmVyIH0gZnJvbSAnLi4vLi4vc3RyaW5naWZ5L3N0cmluZ2lmeU51bWJlci5qcyc7XG5cbmNvbnN0IGZsb2F0TmFOID0ge1xuICAgIGlkZW50aWZ5OiB2YWx1ZSA9PiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInLFxuICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6ZmxvYXQnLFxuICAgIHRlc3Q6IC9eWy0rXT9cXC4oPzppbmZ8SW5mfElORnxuYW58TmFOfE5BTikkLyxcbiAgICByZXNvbHZlOiAoc3RyKSA9PiBzdHIuc2xpY2UoLTMpLnRvTG93ZXJDYXNlKCkgPT09ICduYW4nXG4gICAgICAgID8gTmFOXG4gICAgICAgIDogc3RyWzBdID09PSAnLSdcbiAgICAgICAgICAgID8gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZXG4gICAgICAgICAgICA6IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSxcbiAgICBzdHJpbmdpZnk6IHN0cmluZ2lmeU51bWJlclxufTtcbmNvbnN0IGZsb2F0RXhwID0ge1xuICAgIGlkZW50aWZ5OiB2YWx1ZSA9PiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInLFxuICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6ZmxvYXQnLFxuICAgIGZvcm1hdDogJ0VYUCcsXG4gICAgdGVzdDogL15bLStdPyg/OlswLTldWzAtOV9dKik/KD86XFwuWzAtOV9dKik/W2VFXVstK10/WzAtOV0rJC8sXG4gICAgcmVzb2x2ZTogKHN0cikgPT4gcGFyc2VGbG9hdChzdHIucmVwbGFjZSgvXy9nLCAnJykpLFxuICAgIHN0cmluZ2lmeShub2RlKSB7XG4gICAgICAgIGNvbnN0IG51bSA9IE51bWJlcihub2RlLnZhbHVlKTtcbiAgICAgICAgcmV0dXJuIGlzRmluaXRlKG51bSkgPyBudW0udG9FeHBvbmVudGlhbCgpIDogc3RyaW5naWZ5TnVtYmVyKG5vZGUpO1xuICAgIH1cbn07XG5jb25zdCBmbG9hdCA9IHtcbiAgICBpZGVudGlmeTogdmFsdWUgPT4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyxcbiAgICBkZWZhdWx0OiB0cnVlLFxuICAgIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOmZsb2F0JyxcbiAgICB0ZXN0OiAvXlstK10/KD86WzAtOV1bMC05X10qKT9cXC5bMC05X10qJC8sXG4gICAgcmVzb2x2ZShzdHIpIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IG5ldyBTY2FsYXIocGFyc2VGbG9hdChzdHIucmVwbGFjZSgvXy9nLCAnJykpKTtcbiAgICAgICAgY29uc3QgZG90ID0gc3RyLmluZGV4T2YoJy4nKTtcbiAgICAgICAgaWYgKGRvdCAhPT0gLTEpIHtcbiAgICAgICAgICAgIGNvbnN0IGYgPSBzdHIuc3Vic3RyaW5nKGRvdCArIDEpLnJlcGxhY2UoL18vZywgJycpO1xuICAgICAgICAgICAgaWYgKGZbZi5sZW5ndGggLSAxXSA9PT0gJzAnKVxuICAgICAgICAgICAgICAgIG5vZGUubWluRnJhY3Rpb25EaWdpdHMgPSBmLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9LFxuICAgIHN0cmluZ2lmeTogc3RyaW5naWZ5TnVtYmVyXG59O1xuXG5leHBvcnQgeyBmbG9hdCwgZmxvYXRFeHAsIGZsb2F0TmFOIH07XG4iLCAiaW1wb3J0IHsgc3RyaW5naWZ5TnVtYmVyIH0gZnJvbSAnLi4vLi4vc3RyaW5naWZ5L3N0cmluZ2lmeU51bWJlci5qcyc7XG5cbmNvbnN0IGludElkZW50aWZ5ID0gKHZhbHVlKSA9PiB0eXBlb2YgdmFsdWUgPT09ICdiaWdpbnQnIHx8IE51bWJlci5pc0ludGVnZXIodmFsdWUpO1xuZnVuY3Rpb24gaW50UmVzb2x2ZShzdHIsIG9mZnNldCwgcmFkaXgsIHsgaW50QXNCaWdJbnQgfSkge1xuICAgIGNvbnN0IHNpZ24gPSBzdHJbMF07XG4gICAgaWYgKHNpZ24gPT09ICctJyB8fCBzaWduID09PSAnKycpXG4gICAgICAgIG9mZnNldCArPSAxO1xuICAgIHN0ciA9IHN0ci5zdWJzdHJpbmcob2Zmc2V0KS5yZXBsYWNlKC9fL2csICcnKTtcbiAgICBpZiAoaW50QXNCaWdJbnQpIHtcbiAgICAgICAgc3dpdGNoIChyYWRpeCkge1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIHN0ciA9IGAwYiR7c3RyfWA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgc3RyID0gYDBvJHtzdHJ9YDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMTY6XG4gICAgICAgICAgICAgICAgc3RyID0gYDB4JHtzdHJ9YDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuID0gQmlnSW50KHN0cik7XG4gICAgICAgIHJldHVybiBzaWduID09PSAnLScgPyBCaWdJbnQoLTEpICogbiA6IG47XG4gICAgfVxuICAgIGNvbnN0IG4gPSBwYXJzZUludChzdHIsIHJhZGl4KTtcbiAgICByZXR1cm4gc2lnbiA9PT0gJy0nID8gLTEgKiBuIDogbjtcbn1cbmZ1bmN0aW9uIGludFN0cmluZ2lmeShub2RlLCByYWRpeCwgcHJlZml4KSB7XG4gICAgY29uc3QgeyB2YWx1ZSB9ID0gbm9kZTtcbiAgICBpZiAoaW50SWRlbnRpZnkodmFsdWUpKSB7XG4gICAgICAgIGNvbnN0IHN0ciA9IHZhbHVlLnRvU3RyaW5nKHJhZGl4KTtcbiAgICAgICAgcmV0dXJuIHZhbHVlIDwgMCA/ICctJyArIHByZWZpeCArIHN0ci5zdWJzdHIoMSkgOiBwcmVmaXggKyBzdHI7XG4gICAgfVxuICAgIHJldHVybiBzdHJpbmdpZnlOdW1iZXIobm9kZSk7XG59XG5jb25zdCBpbnRCaW4gPSB7XG4gICAgaWRlbnRpZnk6IGludElkZW50aWZ5LFxuICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6aW50JyxcbiAgICBmb3JtYXQ6ICdCSU4nLFxuICAgIHRlc3Q6IC9eWy0rXT8wYlswLTFfXSskLyxcbiAgICByZXNvbHZlOiAoc3RyLCBfb25FcnJvciwgb3B0KSA9PiBpbnRSZXNvbHZlKHN0ciwgMiwgMiwgb3B0KSxcbiAgICBzdHJpbmdpZnk6IG5vZGUgPT4gaW50U3RyaW5naWZ5KG5vZGUsIDIsICcwYicpXG59O1xuY29uc3QgaW50T2N0ID0ge1xuICAgIGlkZW50aWZ5OiBpbnRJZGVudGlmeSxcbiAgICBkZWZhdWx0OiB0cnVlLFxuICAgIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOmludCcsXG4gICAgZm9ybWF0OiAnT0NUJyxcbiAgICB0ZXN0OiAvXlstK10/MFswLTdfXSskLyxcbiAgICByZXNvbHZlOiAoc3RyLCBfb25FcnJvciwgb3B0KSA9PiBpbnRSZXNvbHZlKHN0ciwgMSwgOCwgb3B0KSxcbiAgICBzdHJpbmdpZnk6IG5vZGUgPT4gaW50U3RyaW5naWZ5KG5vZGUsIDgsICcwJylcbn07XG5jb25zdCBpbnQgPSB7XG4gICAgaWRlbnRpZnk6IGludElkZW50aWZ5LFxuICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6aW50JyxcbiAgICB0ZXN0OiAvXlstK10/WzAtOV1bMC05X10qJC8sXG4gICAgcmVzb2x2ZTogKHN0ciwgX29uRXJyb3IsIG9wdCkgPT4gaW50UmVzb2x2ZShzdHIsIDAsIDEwLCBvcHQpLFxuICAgIHN0cmluZ2lmeTogc3RyaW5naWZ5TnVtYmVyXG59O1xuY29uc3QgaW50SGV4ID0ge1xuICAgIGlkZW50aWZ5OiBpbnRJZGVudGlmeSxcbiAgICBkZWZhdWx0OiB0cnVlLFxuICAgIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOmludCcsXG4gICAgZm9ybWF0OiAnSEVYJyxcbiAgICB0ZXN0OiAvXlstK10/MHhbMC05YS1mQS1GX10rJC8sXG4gICAgcmVzb2x2ZTogKHN0ciwgX29uRXJyb3IsIG9wdCkgPT4gaW50UmVzb2x2ZShzdHIsIDIsIDE2LCBvcHQpLFxuICAgIHN0cmluZ2lmeTogbm9kZSA9PiBpbnRTdHJpbmdpZnkobm9kZSwgMTYsICcweCcpXG59O1xuXG5leHBvcnQgeyBpbnQsIGludEJpbiwgaW50SGV4LCBpbnRPY3QgfTtcbiIsICJpbXBvcnQgeyBpc01hcCwgaXNQYWlyLCBpc1NjYWxhciB9IGZyb20gJy4uLy4uL25vZGVzL05vZGUuanMnO1xuaW1wb3J0IHsgY3JlYXRlUGFpciwgUGFpciB9IGZyb20gJy4uLy4uL25vZGVzL1BhaXIuanMnO1xuaW1wb3J0IHsgWUFNTE1hcCwgZmluZFBhaXIgfSBmcm9tICcuLi8uLi9ub2Rlcy9ZQU1MTWFwLmpzJztcblxuY2xhc3MgWUFNTFNldCBleHRlbmRzIFlBTUxNYXAge1xuICAgIGNvbnN0cnVjdG9yKHNjaGVtYSkge1xuICAgICAgICBzdXBlcihzY2hlbWEpO1xuICAgICAgICB0aGlzLnRhZyA9IFlBTUxTZXQudGFnO1xuICAgIH1cbiAgICBhZGQoa2V5KSB7XG4gICAgICAgIGxldCBwYWlyO1xuICAgICAgICBpZiAoaXNQYWlyKGtleSkpXG4gICAgICAgICAgICBwYWlyID0ga2V5O1xuICAgICAgICBlbHNlIGlmICh0eXBlb2Yga2V5ID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgJ2tleScgaW4ga2V5ICYmXG4gICAgICAgICAgICAndmFsdWUnIGluIGtleSAmJlxuICAgICAgICAgICAga2V5LnZhbHVlID09PSBudWxsKVxuICAgICAgICAgICAgcGFpciA9IG5ldyBQYWlyKGtleS5rZXksIG51bGwpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBwYWlyID0gbmV3IFBhaXIoa2V5LCBudWxsKTtcbiAgICAgICAgY29uc3QgcHJldiA9IGZpbmRQYWlyKHRoaXMuaXRlbXMsIHBhaXIua2V5KTtcbiAgICAgICAgaWYgKCFwcmV2KVxuICAgICAgICAgICAgdGhpcy5pdGVtcy5wdXNoKHBhaXIpO1xuICAgIH1cbiAgICBnZXQoa2V5LCBrZWVwUGFpcikge1xuICAgICAgICBjb25zdCBwYWlyID0gZmluZFBhaXIodGhpcy5pdGVtcywga2V5KTtcbiAgICAgICAgcmV0dXJuICFrZWVwUGFpciAmJiBpc1BhaXIocGFpcilcbiAgICAgICAgICAgID8gaXNTY2FsYXIocGFpci5rZXkpXG4gICAgICAgICAgICAgICAgPyBwYWlyLmtleS52YWx1ZVxuICAgICAgICAgICAgICAgIDogcGFpci5rZXlcbiAgICAgICAgICAgIDogcGFpcjtcbiAgICB9XG4gICAgc2V0KGtleSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ2Jvb2xlYW4nKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBib29sZWFuIHZhbHVlIGZvciBzZXQoa2V5LCB2YWx1ZSkgaW4gYSBZQU1MIHNldCwgbm90ICR7dHlwZW9mIHZhbHVlfWApO1xuICAgICAgICBjb25zdCBwcmV2ID0gZmluZFBhaXIodGhpcy5pdGVtcywga2V5KTtcbiAgICAgICAgaWYgKHByZXYgJiYgIXZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLml0ZW1zLnNwbGljZSh0aGlzLml0ZW1zLmluZGV4T2YocHJldiksIDEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFwcmV2ICYmIHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLml0ZW1zLnB1c2gobmV3IFBhaXIoa2V5KSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdG9KU09OKF8sIGN0eCkge1xuICAgICAgICByZXR1cm4gc3VwZXIudG9KU09OKF8sIGN0eCwgU2V0KTtcbiAgICB9XG4gICAgdG9TdHJpbmcoY3R4LCBvbkNvbW1lbnQsIG9uQ2hvbXBLZWVwKSB7XG4gICAgICAgIGlmICghY3R4KVxuICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMpO1xuICAgICAgICBpZiAodGhpcy5oYXNBbGxOdWxsVmFsdWVzKHRydWUpKVxuICAgICAgICAgICAgcmV0dXJuIHN1cGVyLnRvU3RyaW5nKE9iamVjdC5hc3NpZ24oe30sIGN0eCwgeyBhbGxOdWxsVmFsdWVzOiB0cnVlIH0pLCBvbkNvbW1lbnQsIG9uQ2hvbXBLZWVwKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTZXQgaXRlbXMgbXVzdCBhbGwgaGF2ZSBudWxsIHZhbHVlcycpO1xuICAgIH1cbn1cbllBTUxTZXQudGFnID0gJ3RhZzp5YW1sLm9yZywyMDAyOnNldCc7XG5jb25zdCBzZXQgPSB7XG4gICAgY29sbGVjdGlvbjogJ21hcCcsXG4gICAgaWRlbnRpZnk6IHZhbHVlID0+IHZhbHVlIGluc3RhbmNlb2YgU2V0LFxuICAgIG5vZGVDbGFzczogWUFNTFNldCxcbiAgICBkZWZhdWx0OiBmYWxzZSxcbiAgICB0YWc6ICd0YWc6eWFtbC5vcmcsMjAwMjpzZXQnLFxuICAgIHJlc29sdmUobWFwLCBvbkVycm9yKSB7XG4gICAgICAgIGlmIChpc01hcChtYXApKSB7XG4gICAgICAgICAgICBpZiAobWFwLmhhc0FsbE51bGxWYWx1ZXModHJ1ZSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24obmV3IFlBTUxTZXQoKSwgbWFwKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBvbkVycm9yKCdTZXQgaXRlbXMgbXVzdCBhbGwgaGF2ZSBudWxsIHZhbHVlcycpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIG9uRXJyb3IoJ0V4cGVjdGVkIGEgbWFwcGluZyBmb3IgdGhpcyB0YWcnKTtcbiAgICAgICAgcmV0dXJuIG1hcDtcbiAgICB9LFxuICAgIGNyZWF0ZU5vZGUoc2NoZW1hLCBpdGVyYWJsZSwgY3R4KSB7XG4gICAgICAgIGNvbnN0IHsgcmVwbGFjZXIgfSA9IGN0eDtcbiAgICAgICAgY29uc3Qgc2V0ID0gbmV3IFlBTUxTZXQoc2NoZW1hKTtcbiAgICAgICAgaWYgKGl0ZXJhYmxlICYmIFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoaXRlcmFibGUpKVxuICAgICAgICAgICAgZm9yIChsZXQgdmFsdWUgb2YgaXRlcmFibGUpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHJlcGxhY2VyID09PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHJlcGxhY2VyLmNhbGwoaXRlcmFibGUsIHZhbHVlLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgc2V0Lml0ZW1zLnB1c2goY3JlYXRlUGFpcih2YWx1ZSwgbnVsbCwgY3R4KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZXQ7XG4gICAgfVxufTtcblxuZXhwb3J0IHsgWUFNTFNldCwgc2V0IH07XG4iLCAiaW1wb3J0IHsgc3RyaW5naWZ5TnVtYmVyIH0gZnJvbSAnLi4vLi4vc3RyaW5naWZ5L3N0cmluZ2lmeU51bWJlci5qcyc7XG5cbi8qKiBJbnRlcm5hbCB0eXBlcyBoYW5kbGUgYmlnaW50IGFzIG51bWJlciwgYmVjYXVzZSBUUyBjYW4ndCBmaWd1cmUgaXQgb3V0LiAqL1xuZnVuY3Rpb24gcGFyc2VTZXhhZ2VzaW1hbChzdHIsIGFzQmlnSW50KSB7XG4gICAgY29uc3Qgc2lnbiA9IHN0clswXTtcbiAgICBjb25zdCBwYXJ0cyA9IHNpZ24gPT09ICctJyB8fCBzaWduID09PSAnKycgPyBzdHIuc3Vic3RyaW5nKDEpIDogc3RyO1xuICAgIGNvbnN0IG51bSA9IChuKSA9PiBhc0JpZ0ludCA/IEJpZ0ludChuKSA6IE51bWJlcihuKTtcbiAgICBjb25zdCByZXMgPSBwYXJ0c1xuICAgICAgICAucmVwbGFjZSgvXy9nLCAnJylcbiAgICAgICAgLnNwbGl0KCc6JylcbiAgICAgICAgLnJlZHVjZSgocmVzLCBwKSA9PiByZXMgKiBudW0oNjApICsgbnVtKHApLCBudW0oMCkpO1xuICAgIHJldHVybiAoc2lnbiA9PT0gJy0nID8gbnVtKC0xKSAqIHJlcyA6IHJlcyk7XG59XG4vKipcbiAqIGhoaGg6bW06c3Muc3NzXG4gKlxuICogSW50ZXJuYWwgdHlwZXMgaGFuZGxlIGJpZ2ludCBhcyBudW1iZXIsIGJlY2F1c2UgVFMgY2FuJ3QgZmlndXJlIGl0IG91dC5cbiAqL1xuZnVuY3Rpb24gc3RyaW5naWZ5U2V4YWdlc2ltYWwobm9kZSkge1xuICAgIGxldCB7IHZhbHVlIH0gPSBub2RlO1xuICAgIGxldCBudW0gPSAobikgPT4gbjtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnYmlnaW50JylcbiAgICAgICAgbnVtID0gbiA9PiBCaWdJbnQobik7XG4gICAgZWxzZSBpZiAoaXNOYU4odmFsdWUpIHx8ICFpc0Zpbml0ZSh2YWx1ZSkpXG4gICAgICAgIHJldHVybiBzdHJpbmdpZnlOdW1iZXIobm9kZSk7XG4gICAgbGV0IHNpZ24gPSAnJztcbiAgICBpZiAodmFsdWUgPCAwKSB7XG4gICAgICAgIHNpZ24gPSAnLSc7XG4gICAgICAgIHZhbHVlICo9IG51bSgtMSk7XG4gICAgfVxuICAgIGNvbnN0IF82MCA9IG51bSg2MCk7XG4gICAgY29uc3QgcGFydHMgPSBbdmFsdWUgJSBfNjBdOyAvLyBzZWNvbmRzLCBpbmNsdWRpbmcgbXNcbiAgICBpZiAodmFsdWUgPCA2MCkge1xuICAgICAgICBwYXJ0cy51bnNoaWZ0KDApOyAvLyBhdCBsZWFzdCBvbmUgOiBpcyByZXF1aXJlZFxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmFsdWUgPSAodmFsdWUgLSBwYXJ0c1swXSkgLyBfNjA7XG4gICAgICAgIHBhcnRzLnVuc2hpZnQodmFsdWUgJSBfNjApOyAvLyBtaW51dGVzXG4gICAgICAgIGlmICh2YWx1ZSA+PSA2MCkge1xuICAgICAgICAgICAgdmFsdWUgPSAodmFsdWUgLSBwYXJ0c1swXSkgLyBfNjA7XG4gICAgICAgICAgICBwYXJ0cy51bnNoaWZ0KHZhbHVlKTsgLy8gaG91cnNcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gKHNpZ24gK1xuICAgICAgICBwYXJ0c1xuICAgICAgICAgICAgLm1hcChuID0+IChuIDwgMTAgPyAnMCcgKyBTdHJpbmcobikgOiBTdHJpbmcobikpKVxuICAgICAgICAgICAgLmpvaW4oJzonKVxuICAgICAgICAgICAgLnJlcGxhY2UoLzAwMDAwMFxcZCokLywgJycpIC8vICUgNjAgbWF5IGludHJvZHVjZSBlcnJvclxuICAgICk7XG59XG5jb25zdCBpbnRUaW1lID0ge1xuICAgIGlkZW50aWZ5OiB2YWx1ZSA9PiB0eXBlb2YgdmFsdWUgPT09ICdiaWdpbnQnIHx8IE51bWJlci5pc0ludGVnZXIodmFsdWUpLFxuICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6aW50JyxcbiAgICBmb3JtYXQ6ICdUSU1FJyxcbiAgICB0ZXN0OiAvXlstK10/WzAtOV1bMC05X10qKD86OlswLTVdP1swLTldKSskLyxcbiAgICByZXNvbHZlOiAoc3RyLCBfb25FcnJvciwgeyBpbnRBc0JpZ0ludCB9KSA9PiBwYXJzZVNleGFnZXNpbWFsKHN0ciwgaW50QXNCaWdJbnQpLFxuICAgIHN0cmluZ2lmeTogc3RyaW5naWZ5U2V4YWdlc2ltYWxcbn07XG5jb25zdCBmbG9hdFRpbWUgPSB7XG4gICAgaWRlbnRpZnk6IHZhbHVlID0+IHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicsXG4gICAgZGVmYXVsdDogdHJ1ZSxcbiAgICB0YWc6ICd0YWc6eWFtbC5vcmcsMjAwMjpmbG9hdCcsXG4gICAgZm9ybWF0OiAnVElNRScsXG4gICAgdGVzdDogL15bLStdP1swLTldWzAtOV9dKig/OjpbMC01XT9bMC05XSkrXFwuWzAtOV9dKiQvLFxuICAgIHJlc29sdmU6IHN0ciA9PiBwYXJzZVNleGFnZXNpbWFsKHN0ciwgZmFsc2UpLFxuICAgIHN0cmluZ2lmeTogc3RyaW5naWZ5U2V4YWdlc2ltYWxcbn07XG5jb25zdCB0aW1lc3RhbXAgPSB7XG4gICAgaWRlbnRpZnk6IHZhbHVlID0+IHZhbHVlIGluc3RhbmNlb2YgRGF0ZSxcbiAgICBkZWZhdWx0OiB0cnVlLFxuICAgIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOnRpbWVzdGFtcCcsXG4gICAgLy8gSWYgdGhlIHRpbWUgem9uZSBpcyBvbWl0dGVkLCB0aGUgdGltZXN0YW1wIGlzIGFzc3VtZWQgdG8gYmUgc3BlY2lmaWVkIGluIFVUQy4gVGhlIHRpbWUgcGFydFxuICAgIC8vIG1heSBiZSBvbWl0dGVkIGFsdG9nZXRoZXIsIHJlc3VsdGluZyBpbiBhIGRhdGUgZm9ybWF0LiBJbiBzdWNoIGEgY2FzZSwgdGhlIHRpbWUgcGFydCBpc1xuICAgIC8vIGFzc3VtZWQgdG8gYmUgMDA6MDA6MDBaIChzdGFydCBvZiBkYXksIFVUQykuXG4gICAgdGVzdDogUmVnRXhwKCdeKFswLTldezR9KS0oWzAtOV17MSwyfSktKFswLTldezEsMn0pJyArIC8vIFlZWVktTW0tRGRcbiAgICAgICAgJyg/OicgKyAvLyB0aW1lIGlzIG9wdGlvbmFsXG4gICAgICAgICcoPzp0fFR8WyBcXFxcdF0rKScgKyAvLyB0IHwgVCB8IHdoaXRlc3BhY2VcbiAgICAgICAgJyhbMC05XXsxLDJ9KTooWzAtOV17MSwyfSk6KFswLTldezEsMn0oXFxcXC5bMC05XSspPyknICsgLy8gSGg6TW06U3MoLnNzKT9cbiAgICAgICAgJyg/OlsgXFxcXHRdKihafFstK11bMDEyXT9bMC05XSg/OjpbMC05XXsyfSk/KSk/JyArIC8vIFogfCArNSB8IC0wMzozMFxuICAgICAgICAnKT8kJyksXG4gICAgcmVzb2x2ZShzdHIpIHtcbiAgICAgICAgY29uc3QgbWF0Y2ggPSBzdHIubWF0Y2godGltZXN0YW1wLnRlc3QpO1xuICAgICAgICBpZiAoIW1hdGNoKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCchIXRpbWVzdGFtcCBleHBlY3RzIGEgZGF0ZSwgc3RhcnRpbmcgd2l0aCB5eXl5LW1tLWRkJyk7XG4gICAgICAgIGNvbnN0IFssIHllYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbnV0ZSwgc2Vjb25kXSA9IG1hdGNoLm1hcChOdW1iZXIpO1xuICAgICAgICBjb25zdCBtaWxsaXNlYyA9IG1hdGNoWzddID8gTnVtYmVyKChtYXRjaFs3XSArICcwMCcpLnN1YnN0cigxLCAzKSkgOiAwO1xuICAgICAgICBsZXQgZGF0ZSA9IERhdGUuVVRDKHllYXIsIG1vbnRoIC0gMSwgZGF5LCBob3VyIHx8IDAsIG1pbnV0ZSB8fCAwLCBzZWNvbmQgfHwgMCwgbWlsbGlzZWMpO1xuICAgICAgICBjb25zdCB0eiA9IG1hdGNoWzhdO1xuICAgICAgICBpZiAodHogJiYgdHogIT09ICdaJykge1xuICAgICAgICAgICAgbGV0IGQgPSBwYXJzZVNleGFnZXNpbWFsKHR6LCBmYWxzZSk7XG4gICAgICAgICAgICBpZiAoTWF0aC5hYnMoZCkgPCAzMClcbiAgICAgICAgICAgICAgICBkICo9IDYwO1xuICAgICAgICAgICAgZGF0ZSAtPSA2MDAwMCAqIGQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKGRhdGUpO1xuICAgIH0sXG4gICAgc3RyaW5naWZ5OiAoeyB2YWx1ZSB9KSA9PiB2YWx1ZS50b0lTT1N0cmluZygpLnJlcGxhY2UoLygoVDAwOjAwKT86MDApP1xcLjAwMFokLywgJycpXG59O1xuXG5leHBvcnQgeyBmbG9hdFRpbWUsIGludFRpbWUsIHRpbWVzdGFtcCB9O1xuIiwgImltcG9ydCB7IG1hcCB9IGZyb20gJy4uL2NvbW1vbi9tYXAuanMnO1xuaW1wb3J0IHsgbnVsbFRhZyB9IGZyb20gJy4uL2NvbW1vbi9udWxsLmpzJztcbmltcG9ydCB7IHNlcSB9IGZyb20gJy4uL2NvbW1vbi9zZXEuanMnO1xuaW1wb3J0IHsgc3RyaW5nIH0gZnJvbSAnLi4vY29tbW9uL3N0cmluZy5qcyc7XG5pbXBvcnQgeyBiaW5hcnkgfSBmcm9tICcuL2JpbmFyeS5qcyc7XG5pbXBvcnQgeyB0cnVlVGFnLCBmYWxzZVRhZyB9IGZyb20gJy4vYm9vbC5qcyc7XG5pbXBvcnQgeyBmbG9hdE5hTiwgZmxvYXRFeHAsIGZsb2F0IH0gZnJvbSAnLi9mbG9hdC5qcyc7XG5pbXBvcnQgeyBpbnRCaW4sIGludE9jdCwgaW50LCBpbnRIZXggfSBmcm9tICcuL2ludC5qcyc7XG5pbXBvcnQgeyBvbWFwIH0gZnJvbSAnLi9vbWFwLmpzJztcbmltcG9ydCB7IHBhaXJzIH0gZnJvbSAnLi9wYWlycy5qcyc7XG5pbXBvcnQgeyBzZXQgfSBmcm9tICcuL3NldC5qcyc7XG5pbXBvcnQgeyBpbnRUaW1lLCBmbG9hdFRpbWUsIHRpbWVzdGFtcCB9IGZyb20gJy4vdGltZXN0YW1wLmpzJztcblxuY29uc3Qgc2NoZW1hID0gW1xuICAgIG1hcCxcbiAgICBzZXEsXG4gICAgc3RyaW5nLFxuICAgIG51bGxUYWcsXG4gICAgdHJ1ZVRhZyxcbiAgICBmYWxzZVRhZyxcbiAgICBpbnRCaW4sXG4gICAgaW50T2N0LFxuICAgIGludCxcbiAgICBpbnRIZXgsXG4gICAgZmxvYXROYU4sXG4gICAgZmxvYXRFeHAsXG4gICAgZmxvYXQsXG4gICAgYmluYXJ5LFxuICAgIG9tYXAsXG4gICAgcGFpcnMsXG4gICAgc2V0LFxuICAgIGludFRpbWUsXG4gICAgZmxvYXRUaW1lLFxuICAgIHRpbWVzdGFtcFxuXTtcblxuZXhwb3J0IHsgc2NoZW1hIH07XG4iLCAiaW1wb3J0IHsgbWFwIH0gZnJvbSAnLi9jb21tb24vbWFwLmpzJztcbmltcG9ydCB7IG51bGxUYWcgfSBmcm9tICcuL2NvbW1vbi9udWxsLmpzJztcbmltcG9ydCB7IHNlcSB9IGZyb20gJy4vY29tbW9uL3NlcS5qcyc7XG5pbXBvcnQgeyBzdHJpbmcgfSBmcm9tICcuL2NvbW1vbi9zdHJpbmcuanMnO1xuaW1wb3J0IHsgYm9vbFRhZyB9IGZyb20gJy4vY29yZS9ib29sLmpzJztcbmltcG9ydCB7IGZsb2F0LCBmbG9hdEV4cCwgZmxvYXROYU4gfSBmcm9tICcuL2NvcmUvZmxvYXQuanMnO1xuaW1wb3J0IHsgaW50LCBpbnRIZXgsIGludE9jdCB9IGZyb20gJy4vY29yZS9pbnQuanMnO1xuaW1wb3J0IHsgc2NoZW1hIH0gZnJvbSAnLi9jb3JlL3NjaGVtYS5qcyc7XG5pbXBvcnQgeyBzY2hlbWEgYXMgc2NoZW1hJDEgfSBmcm9tICcuL2pzb24vc2NoZW1hLmpzJztcbmltcG9ydCB7IGJpbmFyeSB9IGZyb20gJy4veWFtbC0xLjEvYmluYXJ5LmpzJztcbmltcG9ydCB7IG9tYXAgfSBmcm9tICcuL3lhbWwtMS4xL29tYXAuanMnO1xuaW1wb3J0IHsgcGFpcnMgfSBmcm9tICcuL3lhbWwtMS4xL3BhaXJzLmpzJztcbmltcG9ydCB7IHNjaGVtYSBhcyBzY2hlbWEkMiB9IGZyb20gJy4veWFtbC0xLjEvc2NoZW1hLmpzJztcbmltcG9ydCB7IHNldCB9IGZyb20gJy4veWFtbC0xLjEvc2V0LmpzJztcbmltcG9ydCB7IGZsb2F0VGltZSwgaW50VGltZSwgdGltZXN0YW1wIH0gZnJvbSAnLi95YW1sLTEuMS90aW1lc3RhbXAuanMnO1xuXG5jb25zdCBzY2hlbWFzID0gbmV3IE1hcChbXG4gICAgWydjb3JlJywgc2NoZW1hXSxcbiAgICBbJ2ZhaWxzYWZlJywgW21hcCwgc2VxLCBzdHJpbmddXSxcbiAgICBbJ2pzb24nLCBzY2hlbWEkMV0sXG4gICAgWyd5YW1sMTEnLCBzY2hlbWEkMl0sXG4gICAgWyd5YW1sLTEuMScsIHNjaGVtYSQyXVxuXSk7XG5jb25zdCB0YWdzQnlOYW1lID0ge1xuICAgIGJpbmFyeSxcbiAgICBib29sOiBib29sVGFnLFxuICAgIGZsb2F0LFxuICAgIGZsb2F0RXhwLFxuICAgIGZsb2F0TmFOLFxuICAgIGZsb2F0VGltZSxcbiAgICBpbnQsXG4gICAgaW50SGV4LFxuICAgIGludE9jdCxcbiAgICBpbnRUaW1lLFxuICAgIG1hcCxcbiAgICBudWxsOiBudWxsVGFnLFxuICAgIG9tYXAsXG4gICAgcGFpcnMsXG4gICAgc2VxLFxuICAgIHNldCxcbiAgICB0aW1lc3RhbXBcbn07XG5jb25zdCBjb3JlS25vd25UYWdzID0ge1xuICAgICd0YWc6eWFtbC5vcmcsMjAwMjpiaW5hcnknOiBiaW5hcnksXG4gICAgJ3RhZzp5YW1sLm9yZywyMDAyOm9tYXAnOiBvbWFwLFxuICAgICd0YWc6eWFtbC5vcmcsMjAwMjpwYWlycyc6IHBhaXJzLFxuICAgICd0YWc6eWFtbC5vcmcsMjAwMjpzZXQnOiBzZXQsXG4gICAgJ3RhZzp5YW1sLm9yZywyMDAyOnRpbWVzdGFtcCc6IHRpbWVzdGFtcFxufTtcbmZ1bmN0aW9uIGdldFRhZ3MoY3VzdG9tVGFncywgc2NoZW1hTmFtZSkge1xuICAgIGxldCB0YWdzID0gc2NoZW1hcy5nZXQoc2NoZW1hTmFtZSk7XG4gICAgaWYgKCF0YWdzKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGN1c3RvbVRhZ3MpKVxuICAgICAgICAgICAgdGFncyA9IFtdO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGtleXMgPSBBcnJheS5mcm9tKHNjaGVtYXMua2V5cygpKVxuICAgICAgICAgICAgICAgIC5maWx0ZXIoa2V5ID0+IGtleSAhPT0gJ3lhbWwxMScpXG4gICAgICAgICAgICAgICAgLm1hcChrZXkgPT4gSlNPTi5zdHJpbmdpZnkoa2V5KSlcbiAgICAgICAgICAgICAgICAuam9pbignLCAnKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBzY2hlbWEgXCIke3NjaGVtYU5hbWV9XCI7IHVzZSBvbmUgb2YgJHtrZXlzfSBvciBkZWZpbmUgY3VzdG9tVGFncyBhcnJheWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KGN1c3RvbVRhZ3MpKSB7XG4gICAgICAgIGZvciAoY29uc3QgdGFnIG9mIGN1c3RvbVRhZ3MpXG4gICAgICAgICAgICB0YWdzID0gdGFncy5jb25jYXQodGFnKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGN1c3RvbVRhZ3MgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGFncyA9IGN1c3RvbVRhZ3ModGFncy5zbGljZSgpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRhZ3MubWFwKHRhZyA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgdGFnICE9PSAnc3RyaW5nJylcbiAgICAgICAgICAgIHJldHVybiB0YWc7XG4gICAgICAgIGNvbnN0IHRhZ09iaiA9IHRhZ3NCeU5hbWVbdGFnXTtcbiAgICAgICAgaWYgKHRhZ09iailcbiAgICAgICAgICAgIHJldHVybiB0YWdPYmo7XG4gICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyh0YWdzQnlOYW1lKVxuICAgICAgICAgICAgLm1hcChrZXkgPT4gSlNPTi5zdHJpbmdpZnkoa2V5KSlcbiAgICAgICAgICAgIC5qb2luKCcsICcpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gY3VzdG9tIHRhZyBcIiR7dGFnfVwiOyB1c2Ugb25lIG9mICR7a2V5c31gKTtcbiAgICB9KTtcbn1cblxuZXhwb3J0IHsgY29yZUtub3duVGFncywgZ2V0VGFncyB9O1xuIiwgImltcG9ydCB7IE1BUCwgU0NBTEFSLCBTRVEgfSBmcm9tICcuLi9ub2Rlcy9Ob2RlLmpzJztcbmltcG9ydCB7IG1hcCB9IGZyb20gJy4vY29tbW9uL21hcC5qcyc7XG5pbXBvcnQgeyBzZXEgfSBmcm9tICcuL2NvbW1vbi9zZXEuanMnO1xuaW1wb3J0IHsgc3RyaW5nIH0gZnJvbSAnLi9jb21tb24vc3RyaW5nLmpzJztcbmltcG9ydCB7IGdldFRhZ3MsIGNvcmVLbm93blRhZ3MgfSBmcm9tICcuL3RhZ3MuanMnO1xuXG5jb25zdCBzb3J0TWFwRW50cmllc0J5S2V5ID0gKGEsIGIpID0+IGEua2V5IDwgYi5rZXkgPyAtMSA6IGEua2V5ID4gYi5rZXkgPyAxIDogMDtcbmNsYXNzIFNjaGVtYSB7XG4gICAgY29uc3RydWN0b3IoeyBjb21wYXQsIGN1c3RvbVRhZ3MsIG1lcmdlLCByZXNvbHZlS25vd25UYWdzLCBzY2hlbWEsIHNvcnRNYXBFbnRyaWVzLCB0b1N0cmluZ0RlZmF1bHRzIH0pIHtcbiAgICAgICAgdGhpcy5jb21wYXQgPSBBcnJheS5pc0FycmF5KGNvbXBhdClcbiAgICAgICAgICAgID8gZ2V0VGFncyhjb21wYXQsICdjb21wYXQnKVxuICAgICAgICAgICAgOiBjb21wYXRcbiAgICAgICAgICAgICAgICA/IGdldFRhZ3MobnVsbCwgY29tcGF0KVxuICAgICAgICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgdGhpcy5tZXJnZSA9ICEhbWVyZ2U7XG4gICAgICAgIHRoaXMubmFtZSA9ICh0eXBlb2Ygc2NoZW1hID09PSAnc3RyaW5nJyAmJiBzY2hlbWEpIHx8ICdjb3JlJztcbiAgICAgICAgdGhpcy5rbm93blRhZ3MgPSByZXNvbHZlS25vd25UYWdzID8gY29yZUtub3duVGFncyA6IHt9O1xuICAgICAgICB0aGlzLnRhZ3MgPSBnZXRUYWdzKGN1c3RvbVRhZ3MsIHRoaXMubmFtZSk7XG4gICAgICAgIHRoaXMudG9TdHJpbmdPcHRpb25zID0gdG9TdHJpbmdEZWZhdWx0cyB8fCBudWxsO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgTUFQLCB7IHZhbHVlOiBtYXAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBTQ0FMQVIsIHsgdmFsdWU6IHN0cmluZyB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFNFUSwgeyB2YWx1ZTogc2VxIH0pO1xuICAgICAgICAvLyBVc2VkIGJ5IGNyZWF0ZU1hcCgpXG4gICAgICAgIHRoaXMuc29ydE1hcEVudHJpZXMgPVxuICAgICAgICAgICAgc29ydE1hcEVudHJpZXMgPT09IHRydWUgPyBzb3J0TWFwRW50cmllc0J5S2V5IDogc29ydE1hcEVudHJpZXMgfHwgbnVsbDtcbiAgICB9XG4gICAgY2xvbmUoKSB7XG4gICAgICAgIGNvbnN0IGNvcHkgPSBPYmplY3QuY3JlYXRlKFNjaGVtYS5wcm90b3R5cGUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHRoaXMpKTtcbiAgICAgICAgY29weS50YWdzID0gdGhpcy50YWdzLnNsaWNlKCk7XG4gICAgICAgIHJldHVybiBjb3B5O1xuICAgIH1cbn1cblxuZXhwb3J0IHsgU2NoZW1hIH07XG4iLCAiaW1wb3J0IHsgaXNOb2RlIH0gZnJvbSAnLi4vbm9kZXMvTm9kZS5qcyc7XG5pbXBvcnQgeyBjcmVhdGVTdHJpbmdpZnlDb250ZXh0LCBzdHJpbmdpZnkgfSBmcm9tICcuL3N0cmluZ2lmeS5qcyc7XG5pbXBvcnQgeyBpbmRlbnRDb21tZW50LCBsaW5lQ29tbWVudCB9IGZyb20gJy4vc3RyaW5naWZ5Q29tbWVudC5qcyc7XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeURvY3VtZW50KGRvYywgb3B0aW9ucykge1xuICAgIGNvbnN0IGxpbmVzID0gW107XG4gICAgbGV0IGhhc0RpcmVjdGl2ZXMgPSBvcHRpb25zLmRpcmVjdGl2ZXMgPT09IHRydWU7XG4gICAgaWYgKG9wdGlvbnMuZGlyZWN0aXZlcyAhPT0gZmFsc2UgJiYgZG9jLmRpcmVjdGl2ZXMpIHtcbiAgICAgICAgY29uc3QgZGlyID0gZG9jLmRpcmVjdGl2ZXMudG9TdHJpbmcoZG9jKTtcbiAgICAgICAgaWYgKGRpcikge1xuICAgICAgICAgICAgbGluZXMucHVzaChkaXIpO1xuICAgICAgICAgICAgaGFzRGlyZWN0aXZlcyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZG9jLmRpcmVjdGl2ZXMubWFya2VyKVxuICAgICAgICAgICAgaGFzRGlyZWN0aXZlcyA9IHRydWU7XG4gICAgfVxuICAgIGlmIChoYXNEaXJlY3RpdmVzKVxuICAgICAgICBsaW5lcy5wdXNoKCctLS0nKTtcbiAgICBjb25zdCBjdHggPSBjcmVhdGVTdHJpbmdpZnlDb250ZXh0KGRvYywgb3B0aW9ucyk7XG4gICAgY29uc3QgeyBjb21tZW50U3RyaW5nIH0gPSBjdHgub3B0aW9ucztcbiAgICBpZiAoZG9jLmNvbW1lbnRCZWZvcmUpIHtcbiAgICAgICAgaWYgKGxpbmVzLmxlbmd0aCAhPT0gMSlcbiAgICAgICAgICAgIGxpbmVzLnVuc2hpZnQoJycpO1xuICAgICAgICBjb25zdCBjcyA9IGNvbW1lbnRTdHJpbmcoZG9jLmNvbW1lbnRCZWZvcmUpO1xuICAgICAgICBsaW5lcy51bnNoaWZ0KGluZGVudENvbW1lbnQoY3MsICcnKSk7XG4gICAgfVxuICAgIGxldCBjaG9tcEtlZXAgPSBmYWxzZTtcbiAgICBsZXQgY29udGVudENvbW1lbnQgPSBudWxsO1xuICAgIGlmIChkb2MuY29udGVudHMpIHtcbiAgICAgICAgaWYgKGlzTm9kZShkb2MuY29udGVudHMpKSB7XG4gICAgICAgICAgICBpZiAoZG9jLmNvbnRlbnRzLnNwYWNlQmVmb3JlICYmIGhhc0RpcmVjdGl2ZXMpXG4gICAgICAgICAgICAgICAgbGluZXMucHVzaCgnJyk7XG4gICAgICAgICAgICBpZiAoZG9jLmNvbnRlbnRzLmNvbW1lbnRCZWZvcmUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjcyA9IGNvbW1lbnRTdHJpbmcoZG9jLmNvbnRlbnRzLmNvbW1lbnRCZWZvcmUpO1xuICAgICAgICAgICAgICAgIGxpbmVzLnB1c2goaW5kZW50Q29tbWVudChjcywgJycpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHRvcC1sZXZlbCBibG9jayBzY2FsYXJzIG5lZWQgdG8gYmUgaW5kZW50ZWQgaWYgZm9sbG93ZWQgYnkgYSBjb21tZW50XG4gICAgICAgICAgICBjdHguZm9yY2VCbG9ja0luZGVudCA9ICEhZG9jLmNvbW1lbnQ7XG4gICAgICAgICAgICBjb250ZW50Q29tbWVudCA9IGRvYy5jb250ZW50cy5jb21tZW50O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9uQ2hvbXBLZWVwID0gY29udGVudENvbW1lbnQgPyB1bmRlZmluZWQgOiAoKSA9PiAoY2hvbXBLZWVwID0gdHJ1ZSk7XG4gICAgICAgIGxldCBib2R5ID0gc3RyaW5naWZ5KGRvYy5jb250ZW50cywgY3R4LCAoKSA9PiAoY29udGVudENvbW1lbnQgPSBudWxsKSwgb25DaG9tcEtlZXApO1xuICAgICAgICBpZiAoY29udGVudENvbW1lbnQpXG4gICAgICAgICAgICBib2R5ICs9IGxpbmVDb21tZW50KGJvZHksICcnLCBjb21tZW50U3RyaW5nKGNvbnRlbnRDb21tZW50KSk7XG4gICAgICAgIGlmICgoYm9keVswXSA9PT0gJ3wnIHx8IGJvZHlbMF0gPT09ICc+JykgJiZcbiAgICAgICAgICAgIGxpbmVzW2xpbmVzLmxlbmd0aCAtIDFdID09PSAnLS0tJykge1xuICAgICAgICAgICAgLy8gVG9wLWxldmVsIGJsb2NrIHNjYWxhcnMgd2l0aCBhIHByZWNlZGluZyBkb2MgbWFya2VyIG91Z2h0IHRvIHVzZSB0aGVcbiAgICAgICAgICAgIC8vIHNhbWUgbGluZSBmb3IgdGhlaXIgaGVhZGVyLlxuICAgICAgICAgICAgbGluZXNbbGluZXMubGVuZ3RoIC0gMV0gPSBgLS0tICR7Ym9keX1gO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGxpbmVzLnB1c2goYm9keSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBsaW5lcy5wdXNoKHN0cmluZ2lmeShkb2MuY29udGVudHMsIGN0eCkpO1xuICAgIH1cbiAgICBsZXQgZGMgPSBkb2MuY29tbWVudDtcbiAgICBpZiAoZGMgJiYgY2hvbXBLZWVwKVxuICAgICAgICBkYyA9IGRjLnJlcGxhY2UoL15cXG4rLywgJycpO1xuICAgIGlmIChkYykge1xuICAgICAgICBpZiAoKCFjaG9tcEtlZXAgfHwgY29udGVudENvbW1lbnQpICYmIGxpbmVzW2xpbmVzLmxlbmd0aCAtIDFdICE9PSAnJylcbiAgICAgICAgICAgIGxpbmVzLnB1c2goJycpO1xuICAgICAgICBsaW5lcy5wdXNoKGluZGVudENvbW1lbnQoY29tbWVudFN0cmluZyhkYyksICcnKSk7XG4gICAgfVxuICAgIHJldHVybiBsaW5lcy5qb2luKCdcXG4nKSArICdcXG4nO1xufVxuXG5leHBvcnQgeyBzdHJpbmdpZnlEb2N1bWVudCB9O1xuIiwgIi8qKlxuICogQXBwbGllcyB0aGUgSlNPTi5wYXJzZSByZXZpdmVyIGFsZ29yaXRobSBhcyBkZWZpbmVkIGluIHRoZSBFQ01BLTI2MiBzcGVjLFxuICogaW4gc2VjdGlvbiAyNC41LjEuMSBcIlJ1bnRpbWUgU2VtYW50aWNzOiBJbnRlcm5hbGl6ZUpTT05Qcm9wZXJ0eVwiIG9mIHRoZVxuICogMjAyMSBlZGl0aW9uOiBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWpzb24ucGFyc2VcbiAqXG4gKiBJbmNsdWRlcyBleHRlbnNpb25zIGZvciBoYW5kbGluZyBNYXAgYW5kIFNldCBvYmplY3RzLlxuICovXG5mdW5jdGlvbiBhcHBseVJldml2ZXIocmV2aXZlciwgb2JqLCBrZXksIHZhbCkge1xuICAgIGlmICh2YWwgJiYgdHlwZW9mIHZhbCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHZhbC5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHYwID0gdmFsW2ldO1xuICAgICAgICAgICAgICAgIGNvbnN0IHYxID0gYXBwbHlSZXZpdmVyKHJldml2ZXIsIHZhbCwgU3RyaW5nKGkpLCB2MCk7XG4gICAgICAgICAgICAgICAgaWYgKHYxID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB2YWxbaV07XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodjEgIT09IHYwKVxuICAgICAgICAgICAgICAgICAgICB2YWxbaV0gPSB2MTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2YWwgaW5zdGFuY2VvZiBNYXApIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgayBvZiBBcnJheS5mcm9tKHZhbC5rZXlzKCkpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdjAgPSB2YWwuZ2V0KGspO1xuICAgICAgICAgICAgICAgIGNvbnN0IHYxID0gYXBwbHlSZXZpdmVyKHJldml2ZXIsIHZhbCwgaywgdjApO1xuICAgICAgICAgICAgICAgIGlmICh2MSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgICAgICB2YWwuZGVsZXRlKGspO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHYxICE9PSB2MClcbiAgICAgICAgICAgICAgICAgICAgdmFsLnNldChrLCB2MSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmFsIGluc3RhbmNlb2YgU2V0KSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHYwIG9mIEFycmF5LmZyb20odmFsKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHYxID0gYXBwbHlSZXZpdmVyKHJldml2ZXIsIHZhbCwgdjAsIHYwKTtcbiAgICAgICAgICAgICAgICBpZiAodjEgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICAgICAgdmFsLmRlbGV0ZSh2MCk7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodjEgIT09IHYwKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbC5kZWxldGUodjApO1xuICAgICAgICAgICAgICAgICAgICB2YWwuYWRkKHYxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtrLCB2MF0gb2YgT2JqZWN0LmVudHJpZXModmFsKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHYxID0gYXBwbHlSZXZpdmVyKHJldml2ZXIsIHZhbCwgaywgdjApO1xuICAgICAgICAgICAgICAgIGlmICh2MSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdmFsW2tdO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHYxICE9PSB2MClcbiAgICAgICAgICAgICAgICAgICAgdmFsW2tdID0gdjE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJldml2ZXIuY2FsbChvYmosIGtleSwgdmFsKTtcbn1cblxuZXhwb3J0IHsgYXBwbHlSZXZpdmVyIH07XG4iLCAiaW1wb3J0IHsgQWxpYXMgfSBmcm9tICcuLi9ub2Rlcy9BbGlhcy5qcyc7XG5pbXBvcnQgeyBpc0VtcHR5UGF0aCwgY29sbGVjdGlvbkZyb21QYXRoIH0gZnJvbSAnLi4vbm9kZXMvQ29sbGVjdGlvbi5qcyc7XG5pbXBvcnQgeyBOT0RFX1RZUEUsIERPQywgaXNOb2RlLCBpc0NvbGxlY3Rpb24sIGlzU2NhbGFyIH0gZnJvbSAnLi4vbm9kZXMvTm9kZS5qcyc7XG5pbXBvcnQgeyBQYWlyIH0gZnJvbSAnLi4vbm9kZXMvUGFpci5qcyc7XG5pbXBvcnQgeyB0b0pTIH0gZnJvbSAnLi4vbm9kZXMvdG9KUy5qcyc7XG5pbXBvcnQgeyBkZWZhdWx0T3B0aW9ucyB9IGZyb20gJy4uL29wdGlvbnMuanMnO1xuaW1wb3J0IHsgU2NoZW1hIH0gZnJvbSAnLi4vc2NoZW1hL1NjaGVtYS5qcyc7XG5pbXBvcnQgeyBzdHJpbmdpZnkgfSBmcm9tICcuLi9zdHJpbmdpZnkvc3RyaW5naWZ5LmpzJztcbmltcG9ydCB7IHN0cmluZ2lmeURvY3VtZW50IH0gZnJvbSAnLi4vc3RyaW5naWZ5L3N0cmluZ2lmeURvY3VtZW50LmpzJztcbmltcG9ydCB7IGFuY2hvck5hbWVzLCBmaW5kTmV3QW5jaG9yLCBjcmVhdGVOb2RlQW5jaG9ycyB9IGZyb20gJy4vYW5jaG9ycy5qcyc7XG5pbXBvcnQgeyBhcHBseVJldml2ZXIgfSBmcm9tICcuL2FwcGx5UmV2aXZlci5qcyc7XG5pbXBvcnQgeyBjcmVhdGVOb2RlIH0gZnJvbSAnLi9jcmVhdGVOb2RlLmpzJztcbmltcG9ydCB7IERpcmVjdGl2ZXMgfSBmcm9tICcuL2RpcmVjdGl2ZXMuanMnO1xuXG5jbGFzcyBEb2N1bWVudCB7XG4gICAgY29uc3RydWN0b3IodmFsdWUsIHJlcGxhY2VyLCBvcHRpb25zKSB7XG4gICAgICAgIC8qKiBBIGNvbW1lbnQgYmVmb3JlIHRoaXMgRG9jdW1lbnQgKi9cbiAgICAgICAgdGhpcy5jb21tZW50QmVmb3JlID0gbnVsbDtcbiAgICAgICAgLyoqIEEgY29tbWVudCBpbW1lZGlhdGVseSBhZnRlciB0aGlzIERvY3VtZW50ICovXG4gICAgICAgIHRoaXMuY29tbWVudCA9IG51bGw7XG4gICAgICAgIC8qKiBFcnJvcnMgZW5jb3VudGVyZWQgZHVyaW5nIHBhcnNpbmcuICovXG4gICAgICAgIHRoaXMuZXJyb3JzID0gW107XG4gICAgICAgIC8qKiBXYXJuaW5ncyBlbmNvdW50ZXJlZCBkdXJpbmcgcGFyc2luZy4gKi9cbiAgICAgICAgdGhpcy53YXJuaW5ncyA9IFtdO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgTk9ERV9UWVBFLCB7IHZhbHVlOiBET0MgfSk7XG4gICAgICAgIGxldCBfcmVwbGFjZXIgPSBudWxsO1xuICAgICAgICBpZiAodHlwZW9mIHJlcGxhY2VyID09PSAnZnVuY3Rpb24nIHx8IEFycmF5LmlzQXJyYXkocmVwbGFjZXIpKSB7XG4gICAgICAgICAgICBfcmVwbGFjZXIgPSByZXBsYWNlcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvcHRpb25zID09PSB1bmRlZmluZWQgJiYgcmVwbGFjZXIpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSByZXBsYWNlcjtcbiAgICAgICAgICAgIHJlcGxhY2VyID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9wdCA9IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRPcHRpb25zLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0O1xuICAgICAgICBsZXQgeyB2ZXJzaW9uIH0gPSBvcHQ7XG4gICAgICAgIGlmIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZGlyZWN0aXZlcykge1xuICAgICAgICAgICAgdGhpcy5kaXJlY3RpdmVzID0gb3B0aW9ucy5kaXJlY3RpdmVzLmF0RG9jdW1lbnQoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmRpcmVjdGl2ZXMueWFtbC5leHBsaWNpdClcbiAgICAgICAgICAgICAgICB2ZXJzaW9uID0gdGhpcy5kaXJlY3RpdmVzLnlhbWwudmVyc2lvbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLmRpcmVjdGl2ZXMgPSBuZXcgRGlyZWN0aXZlcyh7IHZlcnNpb24gfSk7XG4gICAgICAgIHRoaXMuc2V0U2NoZW1hKHZlcnNpb24sIG9wdGlvbnMpO1xuICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHRoaXMuY29udGVudHMgPSBudWxsO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY29udGVudHMgPSB0aGlzLmNyZWF0ZU5vZGUodmFsdWUsIF9yZXBsYWNlciwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgZGVlcCBjb3B5IG9mIHRoaXMgRG9jdW1lbnQgYW5kIGl0cyBjb250ZW50cy5cbiAgICAgKlxuICAgICAqIEN1c3RvbSBOb2RlIHZhbHVlcyB0aGF0IGluaGVyaXQgZnJvbSBgT2JqZWN0YCBzdGlsbCByZWZlciB0byB0aGVpciBvcmlnaW5hbCBpbnN0YW5jZXMuXG4gICAgICovXG4gICAgY2xvbmUoKSB7XG4gICAgICAgIGNvbnN0IGNvcHkgPSBPYmplY3QuY3JlYXRlKERvY3VtZW50LnByb3RvdHlwZSwge1xuICAgICAgICAgICAgW05PREVfVFlQRV06IHsgdmFsdWU6IERPQyB9XG4gICAgICAgIH0pO1xuICAgICAgICBjb3B5LmNvbW1lbnRCZWZvcmUgPSB0aGlzLmNvbW1lbnRCZWZvcmU7XG4gICAgICAgIGNvcHkuY29tbWVudCA9IHRoaXMuY29tbWVudDtcbiAgICAgICAgY29weS5lcnJvcnMgPSB0aGlzLmVycm9ycy5zbGljZSgpO1xuICAgICAgICBjb3B5Lndhcm5pbmdzID0gdGhpcy53YXJuaW5ncy5zbGljZSgpO1xuICAgICAgICBjb3B5Lm9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLm9wdGlvbnMpO1xuICAgICAgICBpZiAodGhpcy5kaXJlY3RpdmVzKVxuICAgICAgICAgICAgY29weS5kaXJlY3RpdmVzID0gdGhpcy5kaXJlY3RpdmVzLmNsb25lKCk7XG4gICAgICAgIGNvcHkuc2NoZW1hID0gdGhpcy5zY2hlbWEuY2xvbmUoKTtcbiAgICAgICAgY29weS5jb250ZW50cyA9IGlzTm9kZSh0aGlzLmNvbnRlbnRzKVxuICAgICAgICAgICAgPyB0aGlzLmNvbnRlbnRzLmNsb25lKGNvcHkuc2NoZW1hKVxuICAgICAgICAgICAgOiB0aGlzLmNvbnRlbnRzO1xuICAgICAgICBpZiAodGhpcy5yYW5nZSlcbiAgICAgICAgICAgIGNvcHkucmFuZ2UgPSB0aGlzLnJhbmdlLnNsaWNlKCk7XG4gICAgICAgIHJldHVybiBjb3B5O1xuICAgIH1cbiAgICAvKiogQWRkcyBhIHZhbHVlIHRvIHRoZSBkb2N1bWVudC4gKi9cbiAgICBhZGQodmFsdWUpIHtcbiAgICAgICAgaWYgKGFzc2VydENvbGxlY3Rpb24odGhpcy5jb250ZW50cykpXG4gICAgICAgICAgICB0aGlzLmNvbnRlbnRzLmFkZCh2YWx1ZSk7XG4gICAgfVxuICAgIC8qKiBBZGRzIGEgdmFsdWUgdG8gdGhlIGRvY3VtZW50LiAqL1xuICAgIGFkZEluKHBhdGgsIHZhbHVlKSB7XG4gICAgICAgIGlmIChhc3NlcnRDb2xsZWN0aW9uKHRoaXMuY29udGVudHMpKVxuICAgICAgICAgICAgdGhpcy5jb250ZW50cy5hZGRJbihwYXRoLCB2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBgQWxpYXNgIG5vZGUsIGVuc3VyaW5nIHRoYXQgdGhlIHRhcmdldCBgbm9kZWAgaGFzIHRoZSByZXF1aXJlZCBhbmNob3IuXG4gICAgICpcbiAgICAgKiBJZiBgbm9kZWAgYWxyZWFkeSBoYXMgYW4gYW5jaG9yLCBgbmFtZWAgaXMgaWdub3JlZC5cbiAgICAgKiBPdGhlcndpc2UsIHRoZSBgbm9kZS5hbmNob3JgIHZhbHVlIHdpbGwgYmUgc2V0IHRvIGBuYW1lYCxcbiAgICAgKiBvciBpZiBhbiBhbmNob3Igd2l0aCB0aGF0IG5hbWUgaXMgYWxyZWFkeSBwcmVzZW50IGluIHRoZSBkb2N1bWVudCxcbiAgICAgKiBgbmFtZWAgd2lsbCBiZSB1c2VkIGFzIGEgcHJlZml4IGZvciBhIG5ldyB1bmlxdWUgYW5jaG9yLlxuICAgICAqIElmIGBuYW1lYCBpcyB1bmRlZmluZWQsIHRoZSBnZW5lcmF0ZWQgYW5jaG9yIHdpbGwgdXNlICdhJyBhcyBhIHByZWZpeC5cbiAgICAgKi9cbiAgICBjcmVhdGVBbGlhcyhub2RlLCBuYW1lKSB7XG4gICAgICAgIGlmICghbm9kZS5hbmNob3IpIHtcbiAgICAgICAgICAgIGNvbnN0IHByZXYgPSBhbmNob3JOYW1lcyh0aGlzKTtcbiAgICAgICAgICAgIG5vZGUuYW5jaG9yID1cbiAgICAgICAgICAgICAgICAhbmFtZSB8fCBwcmV2LmhhcyhuYW1lKSA/IGZpbmROZXdBbmNob3IobmFtZSB8fCAnYScsIHByZXYpIDogbmFtZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEFsaWFzKG5vZGUuYW5jaG9yKTtcbiAgICB9XG4gICAgY3JlYXRlTm9kZSh2YWx1ZSwgcmVwbGFjZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgbGV0IF9yZXBsYWNlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHR5cGVvZiByZXBsYWNlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdmFsdWUgPSByZXBsYWNlci5jYWxsKHsgJyc6IHZhbHVlIH0sICcnLCB2YWx1ZSk7XG4gICAgICAgICAgICBfcmVwbGFjZXIgPSByZXBsYWNlcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHJlcGxhY2VyKSkge1xuICAgICAgICAgICAgY29uc3Qga2V5VG9TdHIgPSAodikgPT4gdHlwZW9mIHYgPT09ICdudW1iZXInIHx8IHYgaW5zdGFuY2VvZiBTdHJpbmcgfHwgdiBpbnN0YW5jZW9mIE51bWJlcjtcbiAgICAgICAgICAgIGNvbnN0IGFzU3RyID0gcmVwbGFjZXIuZmlsdGVyKGtleVRvU3RyKS5tYXAoU3RyaW5nKTtcbiAgICAgICAgICAgIGlmIChhc1N0ci5sZW5ndGggPiAwKVxuICAgICAgICAgICAgICAgIHJlcGxhY2VyID0gcmVwbGFjZXIuY29uY2F0KGFzU3RyKTtcbiAgICAgICAgICAgIF9yZXBsYWNlciA9IHJlcGxhY2VyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9wdGlvbnMgPT09IHVuZGVmaW5lZCAmJiByZXBsYWNlcikge1xuICAgICAgICAgICAgb3B0aW9ucyA9IHJlcGxhY2VyO1xuICAgICAgICAgICAgcmVwbGFjZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBhbGlhc0R1cGxpY2F0ZU9iamVjdHMsIGFuY2hvclByZWZpeCwgZmxvdywga2VlcFVuZGVmaW5lZCwgb25UYWdPYmosIHRhZyB9ID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgY29uc3QgeyBvbkFuY2hvciwgc2V0QW5jaG9ycywgc291cmNlT2JqZWN0cyB9ID0gY3JlYXRlTm9kZUFuY2hvcnModGhpcywgYW5jaG9yUHJlZml4IHx8ICdhJyk7XG4gICAgICAgIGNvbnN0IGN0eCA9IHtcbiAgICAgICAgICAgIGFsaWFzRHVwbGljYXRlT2JqZWN0czogYWxpYXNEdXBsaWNhdGVPYmplY3RzICE9PSBudWxsICYmIGFsaWFzRHVwbGljYXRlT2JqZWN0cyAhPT0gdm9pZCAwID8gYWxpYXNEdXBsaWNhdGVPYmplY3RzIDogdHJ1ZSxcbiAgICAgICAgICAgIGtlZXBVbmRlZmluZWQ6IGtlZXBVbmRlZmluZWQgIT09IG51bGwgJiYga2VlcFVuZGVmaW5lZCAhPT0gdm9pZCAwID8ga2VlcFVuZGVmaW5lZCA6IGZhbHNlLFxuICAgICAgICAgICAgb25BbmNob3IsXG4gICAgICAgICAgICBvblRhZ09iaixcbiAgICAgICAgICAgIHJlcGxhY2VyOiBfcmVwbGFjZXIsXG4gICAgICAgICAgICBzY2hlbWE6IHRoaXMuc2NoZW1hLFxuICAgICAgICAgICAgc291cmNlT2JqZWN0c1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBub2RlID0gY3JlYXRlTm9kZSh2YWx1ZSwgdGFnLCBjdHgpO1xuICAgICAgICBpZiAoZmxvdyAmJiBpc0NvbGxlY3Rpb24obm9kZSkpXG4gICAgICAgICAgICBub2RlLmZsb3cgPSB0cnVlO1xuICAgICAgICBzZXRBbmNob3JzKCk7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IGEga2V5IGFuZCBhIHZhbHVlIGludG8gYSBgUGFpcmAgdXNpbmcgdGhlIGN1cnJlbnQgc2NoZW1hLFxuICAgICAqIHJlY3Vyc2l2ZWx5IHdyYXBwaW5nIGFsbCB2YWx1ZXMgYXMgYFNjYWxhcmAgb3IgYENvbGxlY3Rpb25gIG5vZGVzLlxuICAgICAqL1xuICAgIGNyZWF0ZVBhaXIoa2V5LCB2YWx1ZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IGsgPSB0aGlzLmNyZWF0ZU5vZGUoa2V5LCBudWxsLCBvcHRpb25zKTtcbiAgICAgICAgY29uc3QgdiA9IHRoaXMuY3JlYXRlTm9kZSh2YWx1ZSwgbnVsbCwgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBuZXcgUGFpcihrLCB2KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhIHZhbHVlIGZyb20gdGhlIGRvY3VtZW50LlxuICAgICAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgaXRlbSB3YXMgZm91bmQgYW5kIHJlbW92ZWQuXG4gICAgICovXG4gICAgZGVsZXRlKGtleSkge1xuICAgICAgICByZXR1cm4gYXNzZXJ0Q29sbGVjdGlvbih0aGlzLmNvbnRlbnRzKSA/IHRoaXMuY29udGVudHMuZGVsZXRlKGtleSkgOiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhIHZhbHVlIGZyb20gdGhlIGRvY3VtZW50LlxuICAgICAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgaXRlbSB3YXMgZm91bmQgYW5kIHJlbW92ZWQuXG4gICAgICovXG4gICAgZGVsZXRlSW4ocGF0aCkge1xuICAgICAgICBpZiAoaXNFbXB0eVBhdGgocGF0aCkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbnRlbnRzID09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5jb250ZW50cyA9IG51bGw7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXNzZXJ0Q29sbGVjdGlvbih0aGlzLmNvbnRlbnRzKVxuICAgICAgICAgICAgPyB0aGlzLmNvbnRlbnRzLmRlbGV0ZUluKHBhdGgpXG4gICAgICAgICAgICA6IGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGl0ZW0gYXQgYGtleWAsIG9yIGB1bmRlZmluZWRgIGlmIG5vdCBmb3VuZC4gQnkgZGVmYXVsdCB1bndyYXBzXG4gICAgICogc2NhbGFyIHZhbHVlcyBmcm9tIHRoZWlyIHN1cnJvdW5kaW5nIG5vZGU7IHRvIGRpc2FibGUgc2V0IGBrZWVwU2NhbGFyYCB0b1xuICAgICAqIGB0cnVlYCAoY29sbGVjdGlvbnMgYXJlIGFsd2F5cyByZXR1cm5lZCBpbnRhY3QpLlxuICAgICAqL1xuICAgIGdldChrZXksIGtlZXBTY2FsYXIpIHtcbiAgICAgICAgcmV0dXJuIGlzQ29sbGVjdGlvbih0aGlzLmNvbnRlbnRzKVxuICAgICAgICAgICAgPyB0aGlzLmNvbnRlbnRzLmdldChrZXksIGtlZXBTY2FsYXIpXG4gICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBpdGVtIGF0IGBwYXRoYCwgb3IgYHVuZGVmaW5lZGAgaWYgbm90IGZvdW5kLiBCeSBkZWZhdWx0IHVud3JhcHNcbiAgICAgKiBzY2FsYXIgdmFsdWVzIGZyb20gdGhlaXIgc3Vycm91bmRpbmcgbm9kZTsgdG8gZGlzYWJsZSBzZXQgYGtlZXBTY2FsYXJgIHRvXG4gICAgICogYHRydWVgIChjb2xsZWN0aW9ucyBhcmUgYWx3YXlzIHJldHVybmVkIGludGFjdCkuXG4gICAgICovXG4gICAgZ2V0SW4ocGF0aCwga2VlcFNjYWxhcikge1xuICAgICAgICBpZiAoaXNFbXB0eVBhdGgocGF0aCkpXG4gICAgICAgICAgICByZXR1cm4gIWtlZXBTY2FsYXIgJiYgaXNTY2FsYXIodGhpcy5jb250ZW50cylcbiAgICAgICAgICAgICAgICA/IHRoaXMuY29udGVudHMudmFsdWVcbiAgICAgICAgICAgICAgICA6IHRoaXMuY29udGVudHM7XG4gICAgICAgIHJldHVybiBpc0NvbGxlY3Rpb24odGhpcy5jb250ZW50cylcbiAgICAgICAgICAgID8gdGhpcy5jb250ZW50cy5nZXRJbihwYXRoLCBrZWVwU2NhbGFyKVxuICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGUgZG9jdW1lbnQgaW5jbHVkZXMgYSB2YWx1ZSB3aXRoIHRoZSBrZXkgYGtleWAuXG4gICAgICovXG4gICAgaGFzKGtleSkge1xuICAgICAgICByZXR1cm4gaXNDb2xsZWN0aW9uKHRoaXMuY29udGVudHMpID8gdGhpcy5jb250ZW50cy5oYXMoa2V5KSA6IGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGhlIGRvY3VtZW50IGluY2x1ZGVzIGEgdmFsdWUgYXQgYHBhdGhgLlxuICAgICAqL1xuICAgIGhhc0luKHBhdGgpIHtcbiAgICAgICAgaWYgKGlzRW1wdHlQYXRoKHBhdGgpKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udGVudHMgIT09IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIGlzQ29sbGVjdGlvbih0aGlzLmNvbnRlbnRzKSA/IHRoaXMuY29udGVudHMuaGFzSW4ocGF0aCkgOiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyBhIHZhbHVlIGluIHRoaXMgZG9jdW1lbnQuIEZvciBgISFzZXRgLCBgdmFsdWVgIG5lZWRzIHRvIGJlIGFcbiAgICAgKiBib29sZWFuIHRvIGFkZC9yZW1vdmUgdGhlIGl0ZW0gZnJvbSB0aGUgc2V0LlxuICAgICAqL1xuICAgIHNldChrZXksIHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbnRlbnRzID09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuY29udGVudHMgPSBjb2xsZWN0aW9uRnJvbVBhdGgodGhpcy5zY2hlbWEsIFtrZXldLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYXNzZXJ0Q29sbGVjdGlvbih0aGlzLmNvbnRlbnRzKSkge1xuICAgICAgICAgICAgdGhpcy5jb250ZW50cy5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyBhIHZhbHVlIGluIHRoaXMgZG9jdW1lbnQuIEZvciBgISFzZXRgLCBgdmFsdWVgIG5lZWRzIHRvIGJlIGFcbiAgICAgKiBib29sZWFuIHRvIGFkZC9yZW1vdmUgdGhlIGl0ZW0gZnJvbSB0aGUgc2V0LlxuICAgICAqL1xuICAgIHNldEluKHBhdGgsIHZhbHVlKSB7XG4gICAgICAgIGlmIChpc0VtcHR5UGF0aChwYXRoKSlcbiAgICAgICAgICAgIHRoaXMuY29udGVudHMgPSB2YWx1ZTtcbiAgICAgICAgZWxzZSBpZiAodGhpcy5jb250ZW50cyA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRlbnRzID0gY29sbGVjdGlvbkZyb21QYXRoKHRoaXMuc2NoZW1hLCBBcnJheS5mcm9tKHBhdGgpLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYXNzZXJ0Q29sbGVjdGlvbih0aGlzLmNvbnRlbnRzKSkge1xuICAgICAgICAgICAgdGhpcy5jb250ZW50cy5zZXRJbihwYXRoLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hhbmdlIHRoZSBZQU1MIHZlcnNpb24gYW5kIHNjaGVtYSB1c2VkIGJ5IHRoZSBkb2N1bWVudC5cbiAgICAgKiBBIGBudWxsYCB2ZXJzaW9uIGRpc2FibGVzIHN1cHBvcnQgZm9yIGRpcmVjdGl2ZXMsIGV4cGxpY2l0IHRhZ3MsIGFuY2hvcnMsIGFuZCBhbGlhc2VzLlxuICAgICAqIEl0IGFsc28gcmVxdWlyZXMgdGhlIGBzY2hlbWFgIG9wdGlvbiB0byBiZSBnaXZlbiBhcyBhIGBTY2hlbWFgIGluc3RhbmNlIHZhbHVlLlxuICAgICAqXG4gICAgICogT3ZlcnJpZGVzIGFsbCBwcmV2aW91c2x5IHNldCBzY2hlbWEgb3B0aW9ucy5cbiAgICAgKi9cbiAgICBzZXRTY2hlbWEodmVyc2lvbiwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmVyc2lvbiA9PT0gJ251bWJlcicpXG4gICAgICAgICAgICB2ZXJzaW9uID0gU3RyaW5nKHZlcnNpb24pO1xuICAgICAgICBsZXQgb3B0O1xuICAgICAgICBzd2l0Y2ggKHZlcnNpb24pIHtcbiAgICAgICAgICAgIGNhc2UgJzEuMSc6XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZGlyZWN0aXZlcylcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXJlY3RpdmVzLnlhbWwudmVyc2lvbiA9ICcxLjEnO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXJlY3RpdmVzID0gbmV3IERpcmVjdGl2ZXMoeyB2ZXJzaW9uOiAnMS4xJyB9KTtcbiAgICAgICAgICAgICAgICBvcHQgPSB7IG1lcmdlOiB0cnVlLCByZXNvbHZlS25vd25UYWdzOiBmYWxzZSwgc2NoZW1hOiAneWFtbC0xLjEnIH07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICcxLjInOlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmRpcmVjdGl2ZXMpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlyZWN0aXZlcy55YW1sLnZlcnNpb24gPSAnMS4yJztcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlyZWN0aXZlcyA9IG5ldyBEaXJlY3RpdmVzKHsgdmVyc2lvbjogJzEuMicgfSk7XG4gICAgICAgICAgICAgICAgb3B0ID0geyBtZXJnZTogZmFsc2UsIHJlc29sdmVLbm93blRhZ3M6IHRydWUsIHNjaGVtYTogJ2NvcmUnIH07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIG51bGw6XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZGlyZWN0aXZlcylcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuZGlyZWN0aXZlcztcbiAgICAgICAgICAgICAgICBvcHQgPSBudWxsO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN2ID0gSlNPTi5zdHJpbmdpZnkodmVyc2lvbik7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCAnMS4xJywgJzEuMicgb3IgbnVsbCBhcyBmaXJzdCBhcmd1bWVudCwgYnV0IGZvdW5kOiAke3N2fWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIE5vdCB1c2luZyBgaW5zdGFuY2VvZiBTY2hlbWFgIHRvIGFsbG93IGZvciBkdWNrIHR5cGluZ1xuICAgICAgICBpZiAob3B0aW9ucy5zY2hlbWEgaW5zdGFuY2VvZiBPYmplY3QpXG4gICAgICAgICAgICB0aGlzLnNjaGVtYSA9IG9wdGlvbnMuc2NoZW1hO1xuICAgICAgICBlbHNlIGlmIChvcHQpXG4gICAgICAgICAgICB0aGlzLnNjaGVtYSA9IG5ldyBTY2hlbWEoT2JqZWN0LmFzc2lnbihvcHQsIG9wdGlvbnMpKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBXaXRoIGEgbnVsbCBZQU1MIHZlcnNpb24sIHRoZSB7IHNjaGVtYTogU2NoZW1hIH0gb3B0aW9uIGlzIHJlcXVpcmVkYCk7XG4gICAgfVxuICAgIC8vIGpzb24gJiBqc29uQXJnIGFyZSBvbmx5IHVzZWQgZnJvbSB0b0pTT04oKVxuICAgIHRvSlMoeyBqc29uLCBqc29uQXJnLCBtYXBBc01hcCwgbWF4QWxpYXNDb3VudCwgb25BbmNob3IsIHJldml2ZXIgfSA9IHt9KSB7XG4gICAgICAgIGNvbnN0IGN0eCA9IHtcbiAgICAgICAgICAgIGFuY2hvcnM6IG5ldyBNYXAoKSxcbiAgICAgICAgICAgIGRvYzogdGhpcyxcbiAgICAgICAgICAgIGtlZXA6ICFqc29uLFxuICAgICAgICAgICAgbWFwQXNNYXA6IG1hcEFzTWFwID09PSB0cnVlLFxuICAgICAgICAgICAgbWFwS2V5V2FybmVkOiBmYWxzZSxcbiAgICAgICAgICAgIG1heEFsaWFzQ291bnQ6IHR5cGVvZiBtYXhBbGlhc0NvdW50ID09PSAnbnVtYmVyJyA/IG1heEFsaWFzQ291bnQgOiAxMDAsXG4gICAgICAgICAgICBzdHJpbmdpZnlcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcmVzID0gdG9KUyh0aGlzLmNvbnRlbnRzLCBqc29uQXJnIHx8ICcnLCBjdHgpO1xuICAgICAgICBpZiAodHlwZW9mIG9uQW5jaG9yID09PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgZm9yIChjb25zdCB7IGNvdW50LCByZXMgfSBvZiBjdHguYW5jaG9ycy52YWx1ZXMoKSlcbiAgICAgICAgICAgICAgICBvbkFuY2hvcihyZXMsIGNvdW50KTtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiByZXZpdmVyID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgICA/IGFwcGx5UmV2aXZlcihyZXZpdmVyLCB7ICcnOiByZXMgfSwgJycsIHJlcylcbiAgICAgICAgICAgIDogcmVzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIEpTT04gcmVwcmVzZW50YXRpb24gb2YgdGhlIGRvY3VtZW50IGBjb250ZW50c2AuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ganNvbkFyZyBVc2VkIGJ5IGBKU09OLnN0cmluZ2lmeWAgdG8gaW5kaWNhdGUgdGhlIGFycmF5IGluZGV4IG9yXG4gICAgICogICBwcm9wZXJ0eSBuYW1lLlxuICAgICAqL1xuICAgIHRvSlNPTihqc29uQXJnLCBvbkFuY2hvcikge1xuICAgICAgICByZXR1cm4gdGhpcy50b0pTKHsganNvbjogdHJ1ZSwganNvbkFyZywgbWFwQXNNYXA6IGZhbHNlLCBvbkFuY2hvciB9KTtcbiAgICB9XG4gICAgLyoqIEEgWUFNTCByZXByZXNlbnRhdGlvbiBvZiB0aGUgZG9jdW1lbnQuICovXG4gICAgdG9TdHJpbmcob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGlmICh0aGlzLmVycm9ycy5sZW5ndGggPiAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEb2N1bWVudCB3aXRoIGVycm9ycyBjYW5ub3QgYmUgc3RyaW5naWZpZWQnKTtcbiAgICAgICAgaWYgKCdpbmRlbnQnIGluIG9wdGlvbnMgJiZcbiAgICAgICAgICAgICghTnVtYmVyLmlzSW50ZWdlcihvcHRpb25zLmluZGVudCkgfHwgTnVtYmVyKG9wdGlvbnMuaW5kZW50KSA8PSAwKSkge1xuICAgICAgICAgICAgY29uc3QgcyA9IEpTT04uc3RyaW5naWZ5KG9wdGlvbnMuaW5kZW50KTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgXCJpbmRlbnRcIiBvcHRpb24gbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXIsIG5vdCAke3N9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0cmluZ2lmeURvY3VtZW50KHRoaXMsIG9wdGlvbnMpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGFzc2VydENvbGxlY3Rpb24oY29udGVudHMpIHtcbiAgICBpZiAoaXNDb2xsZWN0aW9uKGNvbnRlbnRzKSlcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBhIFlBTUwgY29sbGVjdGlvbiBhcyBkb2N1bWVudCBjb250ZW50cycpO1xufVxuXG5leHBvcnQgeyBEb2N1bWVudCB9O1xuIiwgImNsYXNzIFlBTUxFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihuYW1lLCBwb3MsIGNvZGUsIG1lc3NhZ2UpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5jb2RlID0gY29kZTtcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICAgICAgdGhpcy5wb3MgPSBwb3M7XG4gICAgfVxufVxuY2xhc3MgWUFNTFBhcnNlRXJyb3IgZXh0ZW5kcyBZQU1MRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHBvcywgY29kZSwgbWVzc2FnZSkge1xuICAgICAgICBzdXBlcignWUFNTFBhcnNlRXJyb3InLCBwb3MsIGNvZGUsIG1lc3NhZ2UpO1xuICAgIH1cbn1cbmNsYXNzIFlBTUxXYXJuaW5nIGV4dGVuZHMgWUFNTEVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcihwb3MsIGNvZGUsIG1lc3NhZ2UpIHtcbiAgICAgICAgc3VwZXIoJ1lBTUxXYXJuaW5nJywgcG9zLCBjb2RlLCBtZXNzYWdlKTtcbiAgICB9XG59XG5jb25zdCBwcmV0dGlmeUVycm9yID0gKHNyYywgbGMpID0+IChlcnJvcikgPT4ge1xuICAgIGlmIChlcnJvci5wb3NbMF0gPT09IC0xKVxuICAgICAgICByZXR1cm47XG4gICAgZXJyb3IubGluZVBvcyA9IGVycm9yLnBvcy5tYXAocG9zID0+IGxjLmxpbmVQb3MocG9zKSk7XG4gICAgY29uc3QgeyBsaW5lLCBjb2wgfSA9IGVycm9yLmxpbmVQb3NbMF07XG4gICAgZXJyb3IubWVzc2FnZSArPSBgIGF0IGxpbmUgJHtsaW5lfSwgY29sdW1uICR7Y29sfWA7XG4gICAgbGV0IGNpID0gY29sIC0gMTtcbiAgICBsZXQgbGluZVN0ciA9IHNyY1xuICAgICAgICAuc3Vic3RyaW5nKGxjLmxpbmVTdGFydHNbbGluZSAtIDFdLCBsYy5saW5lU3RhcnRzW2xpbmVdKVxuICAgICAgICAucmVwbGFjZSgvW1xcblxccl0rJC8sICcnKTtcbiAgICAvLyBUcmltIHRvIG1heCA4MCBjaGFycywga2VlcGluZyBjb2wgcG9zaXRpb24gbmVhciB0aGUgbWlkZGxlXG4gICAgaWYgKGNpID49IDYwICYmIGxpbmVTdHIubGVuZ3RoID4gODApIHtcbiAgICAgICAgY29uc3QgdHJpbVN0YXJ0ID0gTWF0aC5taW4oY2kgLSAzOSwgbGluZVN0ci5sZW5ndGggLSA3OSk7XG4gICAgICAgIGxpbmVTdHIgPSAnXHUyMDI2JyArIGxpbmVTdHIuc3Vic3RyaW5nKHRyaW1TdGFydCk7XG4gICAgICAgIGNpIC09IHRyaW1TdGFydCAtIDE7XG4gICAgfVxuICAgIGlmIChsaW5lU3RyLmxlbmd0aCA+IDgwKVxuICAgICAgICBsaW5lU3RyID0gbGluZVN0ci5zdWJzdHJpbmcoMCwgNzkpICsgJ1x1MjAyNic7XG4gICAgLy8gSW5jbHVkZSBwcmV2aW91cyBsaW5lIGluIGNvbnRleHQgaWYgcG9pbnRpbmcgYXQgbGluZSBzdGFydFxuICAgIGlmIChsaW5lID4gMSAmJiAvXiAqJC8udGVzdChsaW5lU3RyLnN1YnN0cmluZygwLCBjaSkpKSB7XG4gICAgICAgIC8vIFJlZ2V4cCB3b24ndCBtYXRjaCBpZiBzdGFydCBpcyB0cmltbWVkXG4gICAgICAgIGxldCBwcmV2ID0gc3JjLnN1YnN0cmluZyhsYy5saW5lU3RhcnRzW2xpbmUgLSAyXSwgbGMubGluZVN0YXJ0c1tsaW5lIC0gMV0pO1xuICAgICAgICBpZiAocHJldi5sZW5ndGggPiA4MClcbiAgICAgICAgICAgIHByZXYgPSBwcmV2LnN1YnN0cmluZygwLCA3OSkgKyAnXHUyMDI2XFxuJztcbiAgICAgICAgbGluZVN0ciA9IHByZXYgKyBsaW5lU3RyO1xuICAgIH1cbiAgICBpZiAoL1teIF0vLnRlc3QobGluZVN0cikpIHtcbiAgICAgICAgbGV0IGNvdW50ID0gMTtcbiAgICAgICAgY29uc3QgZW5kID0gZXJyb3IubGluZVBvc1sxXTtcbiAgICAgICAgaWYgKGVuZCAmJiBlbmQubGluZSA9PT0gbGluZSAmJiBlbmQuY29sID4gY29sKSB7XG4gICAgICAgICAgICBjb3VudCA9IE1hdGgubWluKGVuZC5jb2wgLSBjb2wsIDgwIC0gY2kpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBvaW50ZXIgPSAnICcucmVwZWF0KGNpKSArICdeJy5yZXBlYXQoY291bnQpO1xuICAgICAgICBlcnJvci5tZXNzYWdlICs9IGA6XFxuXFxuJHtsaW5lU3RyfVxcbiR7cG9pbnRlcn1cXG5gO1xuICAgIH1cbn07XG5cbmV4cG9ydCB7IFlBTUxFcnJvciwgWUFNTFBhcnNlRXJyb3IsIFlBTUxXYXJuaW5nLCBwcmV0dGlmeUVycm9yIH07XG4iLCAiZnVuY3Rpb24gcmVzb2x2ZVByb3BzKHRva2VucywgeyBmbG93LCBpbmRpY2F0b3IsIG5leHQsIG9mZnNldCwgb25FcnJvciwgc3RhcnRPbk5ld2xpbmUgfSkge1xuICAgIGxldCBzcGFjZUJlZm9yZSA9IGZhbHNlO1xuICAgIGxldCBhdE5ld2xpbmUgPSBzdGFydE9uTmV3bGluZTtcbiAgICBsZXQgaGFzU3BhY2UgPSBzdGFydE9uTmV3bGluZTtcbiAgICBsZXQgY29tbWVudCA9ICcnO1xuICAgIGxldCBjb21tZW50U2VwID0gJyc7XG4gICAgbGV0IGhhc05ld2xpbmUgPSBmYWxzZTtcbiAgICBsZXQgcmVxU3BhY2UgPSBmYWxzZTtcbiAgICBsZXQgYW5jaG9yID0gbnVsbDtcbiAgICBsZXQgdGFnID0gbnVsbDtcbiAgICBsZXQgY29tbWEgPSBudWxsO1xuICAgIGxldCBmb3VuZCA9IG51bGw7XG4gICAgbGV0IHN0YXJ0ID0gbnVsbDtcbiAgICBmb3IgKGNvbnN0IHRva2VuIG9mIHRva2Vucykge1xuICAgICAgICBpZiAocmVxU3BhY2UpIHtcbiAgICAgICAgICAgIGlmICh0b2tlbi50eXBlICE9PSAnc3BhY2UnICYmXG4gICAgICAgICAgICAgICAgdG9rZW4udHlwZSAhPT0gJ25ld2xpbmUnICYmXG4gICAgICAgICAgICAgICAgdG9rZW4udHlwZSAhPT0gJ2NvbW1hJylcbiAgICAgICAgICAgICAgICBvbkVycm9yKHRva2VuLm9mZnNldCwgJ01JU1NJTkdfQ0hBUicsICdUYWdzIGFuZCBhbmNob3JzIG11c3QgYmUgc2VwYXJhdGVkIGZyb20gdGhlIG5leHQgdG9rZW4gYnkgd2hpdGUgc3BhY2UnKTtcbiAgICAgICAgICAgIHJlcVNwYWNlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoICh0b2tlbi50eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdzcGFjZSc6XG4gICAgICAgICAgICAgICAgLy8gQXQgdGhlIGRvYyBsZXZlbCwgdGFicyBhdCBsaW5lIHN0YXJ0IG1heSBiZSBwYXJzZWRcbiAgICAgICAgICAgICAgICAvLyBhcyBsZWFkaW5nIHdoaXRlIHNwYWNlIHJhdGhlciB0aGFuIGluZGVudGF0aW9uLlxuICAgICAgICAgICAgICAgIC8vIEluIGEgZmxvdyBjb2xsZWN0aW9uLCBvbmx5IHRoZSBwYXJzZXIgaGFuZGxlcyBpbmRlbnQuXG4gICAgICAgICAgICAgICAgaWYgKCFmbG93ICYmXG4gICAgICAgICAgICAgICAgICAgIGF0TmV3bGluZSAmJlxuICAgICAgICAgICAgICAgICAgICBpbmRpY2F0b3IgIT09ICdkb2Mtc3RhcnQnICYmXG4gICAgICAgICAgICAgICAgICAgIHRva2VuLnNvdXJjZVswXSA9PT0gJ1xcdCcpXG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3IodG9rZW4sICdUQUJfQVNfSU5ERU5UJywgJ1RhYnMgYXJlIG5vdCBhbGxvd2VkIGFzIGluZGVudGF0aW9uJyk7XG4gICAgICAgICAgICAgICAgaGFzU3BhY2UgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnY29tbWVudCc6IHtcbiAgICAgICAgICAgICAgICBpZiAoIWhhc1NwYWNlKVxuICAgICAgICAgICAgICAgICAgICBvbkVycm9yKHRva2VuLCAnTUlTU0lOR19DSEFSJywgJ0NvbW1lbnRzIG11c3QgYmUgc2VwYXJhdGVkIGZyb20gb3RoZXIgdG9rZW5zIGJ5IHdoaXRlIHNwYWNlIGNoYXJhY3RlcnMnKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjYiA9IHRva2VuLnNvdXJjZS5zdWJzdHJpbmcoMSkgfHwgJyAnO1xuICAgICAgICAgICAgICAgIGlmICghY29tbWVudClcbiAgICAgICAgICAgICAgICAgICAgY29tbWVudCA9IGNiO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgY29tbWVudCArPSBjb21tZW50U2VwICsgY2I7XG4gICAgICAgICAgICAgICAgY29tbWVudFNlcCA9ICcnO1xuICAgICAgICAgICAgICAgIGF0TmV3bGluZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnbmV3bGluZSc6XG4gICAgICAgICAgICAgICAgaWYgKGF0TmV3bGluZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29tbWVudClcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1lbnQgKz0gdG9rZW4uc291cmNlO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBzcGFjZUJlZm9yZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgY29tbWVudFNlcCArPSB0b2tlbi5zb3VyY2U7XG4gICAgICAgICAgICAgICAgYXROZXdsaW5lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBoYXNOZXdsaW5lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBoYXNTcGFjZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdhbmNob3InOlxuICAgICAgICAgICAgICAgIGlmIChhbmNob3IpXG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3IodG9rZW4sICdNVUxUSVBMRV9BTkNIT1JTJywgJ0Egbm9kZSBjYW4gaGF2ZSBhdCBtb3N0IG9uZSBhbmNob3InKTtcbiAgICAgICAgICAgICAgICBhbmNob3IgPSB0b2tlbjtcbiAgICAgICAgICAgICAgICBpZiAoc3RhcnQgPT09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gdG9rZW4ub2Zmc2V0O1xuICAgICAgICAgICAgICAgIGF0TmV3bGluZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGhhc1NwYWNlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcmVxU3BhY2UgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAndGFnJzoge1xuICAgICAgICAgICAgICAgIGlmICh0YWcpXG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3IodG9rZW4sICdNVUxUSVBMRV9UQUdTJywgJ0Egbm9kZSBjYW4gaGF2ZSBhdCBtb3N0IG9uZSB0YWcnKTtcbiAgICAgICAgICAgICAgICB0YWcgPSB0b2tlbjtcbiAgICAgICAgICAgICAgICBpZiAoc3RhcnQgPT09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gdG9rZW4ub2Zmc2V0O1xuICAgICAgICAgICAgICAgIGF0TmV3bGluZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGhhc1NwYWNlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcmVxU3BhY2UgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBpbmRpY2F0b3I6XG4gICAgICAgICAgICAgICAgLy8gQ291bGQgaGVyZSBoYW5kbGUgcHJlY2VkaW5nIGNvbW1lbnRzIGRpZmZlcmVudGx5XG4gICAgICAgICAgICAgICAgaWYgKGFuY2hvciB8fCB0YWcpXG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3IodG9rZW4sICdCQURfUFJPUF9PUkRFUicsIGBBbmNob3JzIGFuZCB0YWdzIG11c3QgYmUgYWZ0ZXIgdGhlICR7dG9rZW4uc291cmNlfSBpbmRpY2F0b3JgKTtcbiAgICAgICAgICAgICAgICBpZiAoZm91bmQpXG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3IodG9rZW4sICdVTkVYUEVDVEVEX1RPS0VOJywgYFVuZXhwZWN0ZWQgJHt0b2tlbi5zb3VyY2V9IGluICR7ZmxvdyB8fCAnY29sbGVjdGlvbid9YCk7XG4gICAgICAgICAgICAgICAgZm91bmQgPSB0b2tlbjtcbiAgICAgICAgICAgICAgICBhdE5ld2xpbmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBoYXNTcGFjZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnY29tbWEnOlxuICAgICAgICAgICAgICAgIGlmIChmbG93KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb21tYSlcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uRXJyb3IodG9rZW4sICdVTkVYUEVDVEVEX1RPS0VOJywgYFVuZXhwZWN0ZWQgLCBpbiAke2Zsb3d9YCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbW1hID0gdG9rZW47XG4gICAgICAgICAgICAgICAgICAgIGF0TmV3bGluZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBoYXNTcGFjZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBlbHNlIGZhbGx0aHJvdWdoXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIG9uRXJyb3IodG9rZW4sICdVTkVYUEVDVEVEX1RPS0VOJywgYFVuZXhwZWN0ZWQgJHt0b2tlbi50eXBlfSB0b2tlbmApO1xuICAgICAgICAgICAgICAgIGF0TmV3bGluZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGhhc1NwYWNlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgbGFzdCA9IHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV07XG4gICAgY29uc3QgZW5kID0gbGFzdCA/IGxhc3Qub2Zmc2V0ICsgbGFzdC5zb3VyY2UubGVuZ3RoIDogb2Zmc2V0O1xuICAgIGlmIChyZXFTcGFjZSAmJlxuICAgICAgICBuZXh0ICYmXG4gICAgICAgIG5leHQudHlwZSAhPT0gJ3NwYWNlJyAmJlxuICAgICAgICBuZXh0LnR5cGUgIT09ICduZXdsaW5lJyAmJlxuICAgICAgICBuZXh0LnR5cGUgIT09ICdjb21tYScgJiZcbiAgICAgICAgKG5leHQudHlwZSAhPT0gJ3NjYWxhcicgfHwgbmV4dC5zb3VyY2UgIT09ICcnKSlcbiAgICAgICAgb25FcnJvcihuZXh0Lm9mZnNldCwgJ01JU1NJTkdfQ0hBUicsICdUYWdzIGFuZCBhbmNob3JzIG11c3QgYmUgc2VwYXJhdGVkIGZyb20gdGhlIG5leHQgdG9rZW4gYnkgd2hpdGUgc3BhY2UnKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBjb21tYSxcbiAgICAgICAgZm91bmQsXG4gICAgICAgIHNwYWNlQmVmb3JlLFxuICAgICAgICBjb21tZW50LFxuICAgICAgICBoYXNOZXdsaW5lLFxuICAgICAgICBhbmNob3IsXG4gICAgICAgIHRhZyxcbiAgICAgICAgZW5kLFxuICAgICAgICBzdGFydDogc3RhcnQgIT09IG51bGwgJiYgc3RhcnQgIT09IHZvaWQgMCA/IHN0YXJ0IDogZW5kXG4gICAgfTtcbn1cblxuZXhwb3J0IHsgcmVzb2x2ZVByb3BzIH07XG4iLCAiZnVuY3Rpb24gY29udGFpbnNOZXdsaW5lKGtleSkge1xuICAgIGlmICgha2V5KVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBzd2l0Y2ggKGtleS50eXBlKSB7XG4gICAgICAgIGNhc2UgJ2FsaWFzJzpcbiAgICAgICAgY2FzZSAnc2NhbGFyJzpcbiAgICAgICAgY2FzZSAnZG91YmxlLXF1b3RlZC1zY2FsYXInOlxuICAgICAgICBjYXNlICdzaW5nbGUtcXVvdGVkLXNjYWxhcic6XG4gICAgICAgICAgICBpZiAoa2V5LnNvdXJjZS5pbmNsdWRlcygnXFxuJykpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBpZiAoa2V5LmVuZClcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHN0IG9mIGtleS5lbmQpXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdC50eXBlID09PSAnbmV3bGluZScpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgY2FzZSAnZmxvdy1jb2xsZWN0aW9uJzpcbiAgICAgICAgICAgIGZvciAoY29uc3QgaXQgb2Yga2V5Lml0ZW1zKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBzdCBvZiBpdC5zdGFydClcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0LnR5cGUgPT09ICduZXdsaW5lJylcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIGlmIChpdC5zZXApXG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3Qgc3Qgb2YgaXQuc2VwKVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0LnR5cGUgPT09ICduZXdsaW5lJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAoY29udGFpbnNOZXdsaW5lKGl0LmtleSkgfHwgY29udGFpbnNOZXdsaW5lKGl0LnZhbHVlKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59XG5cbmV4cG9ydCB7IGNvbnRhaW5zTmV3bGluZSB9O1xuIiwgImltcG9ydCB7IGNvbnRhaW5zTmV3bGluZSB9IGZyb20gJy4vdXRpbC1jb250YWlucy1uZXdsaW5lLmpzJztcblxuZnVuY3Rpb24gZmxvd0luZGVudENoZWNrKGluZGVudCwgZmMsIG9uRXJyb3IpIHtcbiAgICBpZiAoKGZjID09PSBudWxsIHx8IGZjID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmYy50eXBlKSA9PT0gJ2Zsb3ctY29sbGVjdGlvbicpIHtcbiAgICAgICAgY29uc3QgZW5kID0gZmMuZW5kWzBdO1xuICAgICAgICBpZiAoZW5kLmluZGVudCA9PT0gaW5kZW50ICYmXG4gICAgICAgICAgICAoZW5kLnNvdXJjZSA9PT0gJ10nIHx8IGVuZC5zb3VyY2UgPT09ICd9JykgJiZcbiAgICAgICAgICAgIGNvbnRhaW5zTmV3bGluZShmYykpIHtcbiAgICAgICAgICAgIGNvbnN0IG1zZyA9ICdGbG93IGVuZCBpbmRpY2F0b3Igc2hvdWxkIGJlIG1vcmUgaW5kZW50ZWQgdGhhbiBwYXJlbnQnO1xuICAgICAgICAgICAgb25FcnJvcihlbmQsICdCQURfSU5ERU5UJywgbXNnLCB0cnVlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IHsgZmxvd0luZGVudENoZWNrIH07XG4iLCAiaW1wb3J0IHsgaXNTY2FsYXIgfSBmcm9tICcuLi9ub2Rlcy9Ob2RlLmpzJztcblxuZnVuY3Rpb24gbWFwSW5jbHVkZXMoY3R4LCBpdGVtcywgc2VhcmNoKSB7XG4gICAgY29uc3QgeyB1bmlxdWVLZXlzIH0gPSBjdHgub3B0aW9ucztcbiAgICBpZiAodW5pcXVlS2V5cyA9PT0gZmFsc2UpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCBpc0VxdWFsID0gdHlwZW9mIHVuaXF1ZUtleXMgPT09ICdmdW5jdGlvbidcbiAgICAgICAgPyB1bmlxdWVLZXlzXG4gICAgICAgIDogKGEsIGIpID0+IGEgPT09IGIgfHxcbiAgICAgICAgICAgIChpc1NjYWxhcihhKSAmJlxuICAgICAgICAgICAgICAgIGlzU2NhbGFyKGIpICYmXG4gICAgICAgICAgICAgICAgYS52YWx1ZSA9PT0gYi52YWx1ZSAmJlxuICAgICAgICAgICAgICAgICEoYS52YWx1ZSA9PT0gJzw8JyAmJiBjdHguc2NoZW1hLm1lcmdlKSk7XG4gICAgcmV0dXJuIGl0ZW1zLnNvbWUocGFpciA9PiBpc0VxdWFsKHBhaXIua2V5LCBzZWFyY2gpKTtcbn1cblxuZXhwb3J0IHsgbWFwSW5jbHVkZXMgfTtcbiIsICJpbXBvcnQgeyBQYWlyIH0gZnJvbSAnLi4vbm9kZXMvUGFpci5qcyc7XG5pbXBvcnQgeyBZQU1MTWFwIH0gZnJvbSAnLi4vbm9kZXMvWUFNTE1hcC5qcyc7XG5pbXBvcnQgeyByZXNvbHZlUHJvcHMgfSBmcm9tICcuL3Jlc29sdmUtcHJvcHMuanMnO1xuaW1wb3J0IHsgY29udGFpbnNOZXdsaW5lIH0gZnJvbSAnLi91dGlsLWNvbnRhaW5zLW5ld2xpbmUuanMnO1xuaW1wb3J0IHsgZmxvd0luZGVudENoZWNrIH0gZnJvbSAnLi91dGlsLWZsb3ctaW5kZW50LWNoZWNrLmpzJztcbmltcG9ydCB7IG1hcEluY2x1ZGVzIH0gZnJvbSAnLi91dGlsLW1hcC1pbmNsdWRlcy5qcyc7XG5cbmNvbnN0IHN0YXJ0Q29sTXNnID0gJ0FsbCBtYXBwaW5nIGl0ZW1zIG11c3Qgc3RhcnQgYXQgdGhlIHNhbWUgY29sdW1uJztcbmZ1bmN0aW9uIHJlc29sdmVCbG9ja01hcCh7IGNvbXBvc2VOb2RlLCBjb21wb3NlRW1wdHlOb2RlIH0sIGN0eCwgYm0sIG9uRXJyb3IpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgbWFwID0gbmV3IFlBTUxNYXAoY3R4LnNjaGVtYSk7XG4gICAgaWYgKGN0eC5hdFJvb3QpXG4gICAgICAgIGN0eC5hdFJvb3QgPSBmYWxzZTtcbiAgICBsZXQgb2Zmc2V0ID0gYm0ub2Zmc2V0O1xuICAgIGZvciAoY29uc3QgY29sbEl0ZW0gb2YgYm0uaXRlbXMpIHtcbiAgICAgICAgY29uc3QgeyBzdGFydCwga2V5LCBzZXAsIHZhbHVlIH0gPSBjb2xsSXRlbTtcbiAgICAgICAgLy8ga2V5IHByb3BlcnRpZXNcbiAgICAgICAgY29uc3Qga2V5UHJvcHMgPSByZXNvbHZlUHJvcHMoc3RhcnQsIHtcbiAgICAgICAgICAgIGluZGljYXRvcjogJ2V4cGxpY2l0LWtleS1pbmQnLFxuICAgICAgICAgICAgbmV4dDoga2V5IHx8IChzZXAgPT09IG51bGwgfHwgc2VwID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzZXBbMF0pLFxuICAgICAgICAgICAgb2Zmc2V0LFxuICAgICAgICAgICAgb25FcnJvcixcbiAgICAgICAgICAgIHN0YXJ0T25OZXdsaW5lOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBpbXBsaWNpdEtleSA9ICFrZXlQcm9wcy5mb3VuZDtcbiAgICAgICAgaWYgKGltcGxpY2l0S2V5KSB7XG4gICAgICAgICAgICBpZiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgaWYgKGtleS50eXBlID09PSAnYmxvY2stc2VxJylcbiAgICAgICAgICAgICAgICAgICAgb25FcnJvcihvZmZzZXQsICdCTE9DS19BU19JTVBMSUNJVF9LRVknLCAnQSBibG9jayBzZXF1ZW5jZSBtYXkgbm90IGJlIHVzZWQgYXMgYW4gaW1wbGljaXQgbWFwIGtleScpO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCdpbmRlbnQnIGluIGtleSAmJiBrZXkuaW5kZW50ICE9PSBibS5pbmRlbnQpXG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3Iob2Zmc2V0LCAnQkFEX0lOREVOVCcsIHN0YXJ0Q29sTXNnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgha2V5UHJvcHMuYW5jaG9yICYmICFrZXlQcm9wcy50YWcgJiYgIXNlcCkge1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IGFzc2VydCBiZWluZyBhdCBsYXN0IGl0ZW0/XG4gICAgICAgICAgICAgICAgaWYgKGtleVByb3BzLmNvbW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hcC5jb21tZW50KVxuICAgICAgICAgICAgICAgICAgICAgICAgbWFwLmNvbW1lbnQgKz0gJ1xcbicgKyBrZXlQcm9wcy5jb21tZW50O1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXAuY29tbWVudCA9IGtleVByb3BzLmNvbW1lbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCgoX2EgPSBrZXlQcm9wcy5mb3VuZCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmluZGVudCkgIT09IGJtLmluZGVudClcbiAgICAgICAgICAgIG9uRXJyb3Iob2Zmc2V0LCAnQkFEX0lOREVOVCcsIHN0YXJ0Q29sTXNnKTtcbiAgICAgICAgaWYgKGltcGxpY2l0S2V5ICYmIGNvbnRhaW5zTmV3bGluZShrZXkpKVxuICAgICAgICAgICAgb25FcnJvcihrZXksIC8vIGNoZWNrZWQgYnkgY29udGFpbnNOZXdsaW5lKClcbiAgICAgICAgICAgICdNVUxUSUxJTkVfSU1QTElDSVRfS0VZJywgJ0ltcGxpY2l0IGtleXMgbmVlZCB0byBiZSBvbiBhIHNpbmdsZSBsaW5lJyk7XG4gICAgICAgIC8vIGtleSB2YWx1ZVxuICAgICAgICBjb25zdCBrZXlTdGFydCA9IGtleVByb3BzLmVuZDtcbiAgICAgICAgY29uc3Qga2V5Tm9kZSA9IGtleVxuICAgICAgICAgICAgPyBjb21wb3NlTm9kZShjdHgsIGtleSwga2V5UHJvcHMsIG9uRXJyb3IpXG4gICAgICAgICAgICA6IGNvbXBvc2VFbXB0eU5vZGUoY3R4LCBrZXlTdGFydCwgc3RhcnQsIG51bGwsIGtleVByb3BzLCBvbkVycm9yKTtcbiAgICAgICAgaWYgKGN0eC5zY2hlbWEuY29tcGF0KVxuICAgICAgICAgICAgZmxvd0luZGVudENoZWNrKGJtLmluZGVudCwga2V5LCBvbkVycm9yKTtcbiAgICAgICAgaWYgKG1hcEluY2x1ZGVzKGN0eCwgbWFwLml0ZW1zLCBrZXlOb2RlKSlcbiAgICAgICAgICAgIG9uRXJyb3Ioa2V5U3RhcnQsICdEVVBMSUNBVEVfS0VZJywgJ01hcCBrZXlzIG11c3QgYmUgdW5pcXVlJyk7XG4gICAgICAgIC8vIHZhbHVlIHByb3BlcnRpZXNcbiAgICAgICAgY29uc3QgdmFsdWVQcm9wcyA9IHJlc29sdmVQcm9wcyhzZXAgfHwgW10sIHtcbiAgICAgICAgICAgIGluZGljYXRvcjogJ21hcC12YWx1ZS1pbmQnLFxuICAgICAgICAgICAgbmV4dDogdmFsdWUsXG4gICAgICAgICAgICBvZmZzZXQ6IGtleU5vZGUucmFuZ2VbMl0sXG4gICAgICAgICAgICBvbkVycm9yLFxuICAgICAgICAgICAgc3RhcnRPbk5ld2xpbmU6ICFrZXkgfHwga2V5LnR5cGUgPT09ICdibG9jay1zY2FsYXInXG4gICAgICAgIH0pO1xuICAgICAgICBvZmZzZXQgPSB2YWx1ZVByb3BzLmVuZDtcbiAgICAgICAgaWYgKHZhbHVlUHJvcHMuZm91bmQpIHtcbiAgICAgICAgICAgIGlmIChpbXBsaWNpdEtleSkge1xuICAgICAgICAgICAgICAgIGlmICgodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHZhbHVlLnR5cGUpID09PSAnYmxvY2stbWFwJyAmJiAhdmFsdWVQcm9wcy5oYXNOZXdsaW5lKVxuICAgICAgICAgICAgICAgICAgICBvbkVycm9yKG9mZnNldCwgJ0JMT0NLX0FTX0lNUExJQ0lUX0tFWScsICdOZXN0ZWQgbWFwcGluZ3MgYXJlIG5vdCBhbGxvd2VkIGluIGNvbXBhY3QgbWFwcGluZ3MnKTtcbiAgICAgICAgICAgICAgICBpZiAoY3R4Lm9wdGlvbnMuc3RyaWN0ICYmXG4gICAgICAgICAgICAgICAgICAgIGtleVByb3BzLnN0YXJ0IDwgdmFsdWVQcm9wcy5mb3VuZC5vZmZzZXQgLSAxMDI0KVxuICAgICAgICAgICAgICAgICAgICBvbkVycm9yKGtleU5vZGUucmFuZ2UsICdLRVlfT1ZFUl8xMDI0X0NIQVJTJywgJ1RoZSA6IGluZGljYXRvciBtdXN0IGJlIGF0IG1vc3QgMTAyNCBjaGFycyBhZnRlciB0aGUgc3RhcnQgb2YgYW4gaW1wbGljaXQgYmxvY2sgbWFwcGluZyBrZXknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHZhbHVlIHZhbHVlXG4gICAgICAgICAgICBjb25zdCB2YWx1ZU5vZGUgPSB2YWx1ZVxuICAgICAgICAgICAgICAgID8gY29tcG9zZU5vZGUoY3R4LCB2YWx1ZSwgdmFsdWVQcm9wcywgb25FcnJvcilcbiAgICAgICAgICAgICAgICA6IGNvbXBvc2VFbXB0eU5vZGUoY3R4LCBvZmZzZXQsIHNlcCwgbnVsbCwgdmFsdWVQcm9wcywgb25FcnJvcik7XG4gICAgICAgICAgICBpZiAoY3R4LnNjaGVtYS5jb21wYXQpXG4gICAgICAgICAgICAgICAgZmxvd0luZGVudENoZWNrKGJtLmluZGVudCwgdmFsdWUsIG9uRXJyb3IpO1xuICAgICAgICAgICAgb2Zmc2V0ID0gdmFsdWVOb2RlLnJhbmdlWzJdO1xuICAgICAgICAgICAgY29uc3QgcGFpciA9IG5ldyBQYWlyKGtleU5vZGUsIHZhbHVlTm9kZSk7XG4gICAgICAgICAgICBpZiAoY3R4Lm9wdGlvbnMua2VlcFNvdXJjZVRva2VucylcbiAgICAgICAgICAgICAgICBwYWlyLnNyY1Rva2VuID0gY29sbEl0ZW07XG4gICAgICAgICAgICBtYXAuaXRlbXMucHVzaChwYWlyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGtleSB3aXRoIG5vIHZhbHVlXG4gICAgICAgICAgICBpZiAoaW1wbGljaXRLZXkpXG4gICAgICAgICAgICAgICAgb25FcnJvcihrZXlOb2RlLnJhbmdlLCAnTUlTU0lOR19DSEFSJywgJ0ltcGxpY2l0IG1hcCBrZXlzIG5lZWQgdG8gYmUgZm9sbG93ZWQgYnkgbWFwIHZhbHVlcycpO1xuICAgICAgICAgICAgaWYgKHZhbHVlUHJvcHMuY29tbWVudCkge1xuICAgICAgICAgICAgICAgIGlmIChrZXlOb2RlLmNvbW1lbnQpXG4gICAgICAgICAgICAgICAgICAgIGtleU5vZGUuY29tbWVudCArPSAnXFxuJyArIHZhbHVlUHJvcHMuY29tbWVudDtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGtleU5vZGUuY29tbWVudCA9IHZhbHVlUHJvcHMuY29tbWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHBhaXIgPSBuZXcgUGFpcihrZXlOb2RlKTtcbiAgICAgICAgICAgIGlmIChjdHgub3B0aW9ucy5rZWVwU291cmNlVG9rZW5zKVxuICAgICAgICAgICAgICAgIHBhaXIuc3JjVG9rZW4gPSBjb2xsSXRlbTtcbiAgICAgICAgICAgIG1hcC5pdGVtcy5wdXNoKHBhaXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG1hcC5yYW5nZSA9IFtibS5vZmZzZXQsIG9mZnNldCwgb2Zmc2V0XTtcbiAgICByZXR1cm4gbWFwO1xufVxuXG5leHBvcnQgeyByZXNvbHZlQmxvY2tNYXAgfTtcbiIsICJpbXBvcnQgeyBZQU1MU2VxIH0gZnJvbSAnLi4vbm9kZXMvWUFNTFNlcS5qcyc7XG5pbXBvcnQgeyByZXNvbHZlUHJvcHMgfSBmcm9tICcuL3Jlc29sdmUtcHJvcHMuanMnO1xuaW1wb3J0IHsgZmxvd0luZGVudENoZWNrIH0gZnJvbSAnLi91dGlsLWZsb3ctaW5kZW50LWNoZWNrLmpzJztcblxuZnVuY3Rpb24gcmVzb2x2ZUJsb2NrU2VxKHsgY29tcG9zZU5vZGUsIGNvbXBvc2VFbXB0eU5vZGUgfSwgY3R4LCBicywgb25FcnJvcikge1xuICAgIGNvbnN0IHNlcSA9IG5ldyBZQU1MU2VxKGN0eC5zY2hlbWEpO1xuICAgIGlmIChjdHguYXRSb290KVxuICAgICAgICBjdHguYXRSb290ID0gZmFsc2U7XG4gICAgbGV0IG9mZnNldCA9IGJzLm9mZnNldDtcbiAgICBmb3IgKGNvbnN0IHsgc3RhcnQsIHZhbHVlIH0gb2YgYnMuaXRlbXMpIHtcbiAgICAgICAgY29uc3QgcHJvcHMgPSByZXNvbHZlUHJvcHMoc3RhcnQsIHtcbiAgICAgICAgICAgIGluZGljYXRvcjogJ3NlcS1pdGVtLWluZCcsXG4gICAgICAgICAgICBuZXh0OiB2YWx1ZSxcbiAgICAgICAgICAgIG9mZnNldCxcbiAgICAgICAgICAgIG9uRXJyb3IsXG4gICAgICAgICAgICBzdGFydE9uTmV3bGluZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgb2Zmc2V0ID0gcHJvcHMuZW5kO1xuICAgICAgICBpZiAoIXByb3BzLmZvdW5kKSB7XG4gICAgICAgICAgICBpZiAocHJvcHMuYW5jaG9yIHx8IHByb3BzLnRhZyB8fCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAmJiB2YWx1ZS50eXBlID09PSAnYmxvY2stc2VxJylcbiAgICAgICAgICAgICAgICAgICAgb25FcnJvcihvZmZzZXQsICdCQURfSU5ERU5UJywgJ0FsbCBzZXF1ZW5jZSBpdGVtcyBtdXN0IHN0YXJ0IGF0IHRoZSBzYW1lIGNvbHVtbicpO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgb25FcnJvcihvZmZzZXQsICdNSVNTSU5HX0NIQVInLCAnU2VxdWVuY2UgaXRlbSB3aXRob3V0IC0gaW5kaWNhdG9yJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBhc3NlcnQgYmVpbmcgYXQgbGFzdCBpdGVtP1xuICAgICAgICAgICAgICAgIGlmIChwcm9wcy5jb21tZW50KVxuICAgICAgICAgICAgICAgICAgICBzZXEuY29tbWVudCA9IHByb3BzLmNvbW1lbnQ7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgbm9kZSA9IHZhbHVlXG4gICAgICAgICAgICA/IGNvbXBvc2VOb2RlKGN0eCwgdmFsdWUsIHByb3BzLCBvbkVycm9yKVxuICAgICAgICAgICAgOiBjb21wb3NlRW1wdHlOb2RlKGN0eCwgb2Zmc2V0LCBzdGFydCwgbnVsbCwgcHJvcHMsIG9uRXJyb3IpO1xuICAgICAgICBpZiAoY3R4LnNjaGVtYS5jb21wYXQpXG4gICAgICAgICAgICBmbG93SW5kZW50Q2hlY2soYnMuaW5kZW50LCB2YWx1ZSwgb25FcnJvcik7XG4gICAgICAgIG9mZnNldCA9IG5vZGUucmFuZ2VbMl07XG4gICAgICAgIHNlcS5pdGVtcy5wdXNoKG5vZGUpO1xuICAgIH1cbiAgICBzZXEucmFuZ2UgPSBbYnMub2Zmc2V0LCBvZmZzZXQsIG9mZnNldF07XG4gICAgcmV0dXJuIHNlcTtcbn1cblxuZXhwb3J0IHsgcmVzb2x2ZUJsb2NrU2VxIH07XG4iLCAiZnVuY3Rpb24gcmVzb2x2ZUVuZChlbmQsIG9mZnNldCwgcmVxU3BhY2UsIG9uRXJyb3IpIHtcbiAgICBsZXQgY29tbWVudCA9ICcnO1xuICAgIGlmIChlbmQpIHtcbiAgICAgICAgbGV0IGhhc1NwYWNlID0gZmFsc2U7XG4gICAgICAgIGxldCBzZXAgPSAnJztcbiAgICAgICAgZm9yIChjb25zdCB0b2tlbiBvZiBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgc291cmNlLCB0eXBlIH0gPSB0b2tlbjtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3NwYWNlJzpcbiAgICAgICAgICAgICAgICAgICAgaGFzU3BhY2UgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdjb21tZW50Jzoge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVxU3BhY2UgJiYgIWhhc1NwYWNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgb25FcnJvcih0b2tlbiwgJ01JU1NJTkdfQ0hBUicsICdDb21tZW50cyBtdXN0IGJlIHNlcGFyYXRlZCBmcm9tIG90aGVyIHRva2VucyBieSB3aGl0ZSBzcGFjZSBjaGFyYWN0ZXJzJyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNiID0gc291cmNlLnN1YnN0cmluZygxKSB8fCAnICc7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY29tbWVudClcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1lbnQgPSBjYjtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgY29tbWVudCArPSBzZXAgKyBjYjtcbiAgICAgICAgICAgICAgICAgICAgc2VwID0gJyc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlICduZXdsaW5lJzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbW1lbnQpXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXAgKz0gc291cmNlO1xuICAgICAgICAgICAgICAgICAgICBoYXNTcGFjZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3IodG9rZW4sICdVTkVYUEVDVEVEX1RPS0VOJywgYFVuZXhwZWN0ZWQgJHt0eXBlfSBhdCBub2RlIGVuZGApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2Zmc2V0ICs9IHNvdXJjZS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgY29tbWVudCwgb2Zmc2V0IH07XG59XG5cbmV4cG9ydCB7IHJlc29sdmVFbmQgfTtcbiIsICJpbXBvcnQgeyBpc1BhaXIgfSBmcm9tICcuLi9ub2Rlcy9Ob2RlLmpzJztcbmltcG9ydCB7IFBhaXIgfSBmcm9tICcuLi9ub2Rlcy9QYWlyLmpzJztcbmltcG9ydCB7IFlBTUxNYXAgfSBmcm9tICcuLi9ub2Rlcy9ZQU1MTWFwLmpzJztcbmltcG9ydCB7IFlBTUxTZXEgfSBmcm9tICcuLi9ub2Rlcy9ZQU1MU2VxLmpzJztcbmltcG9ydCB7IHJlc29sdmVFbmQgfSBmcm9tICcuL3Jlc29sdmUtZW5kLmpzJztcbmltcG9ydCB7IHJlc29sdmVQcm9wcyB9IGZyb20gJy4vcmVzb2x2ZS1wcm9wcy5qcyc7XG5pbXBvcnQgeyBjb250YWluc05ld2xpbmUgfSBmcm9tICcuL3V0aWwtY29udGFpbnMtbmV3bGluZS5qcyc7XG5pbXBvcnQgeyBtYXBJbmNsdWRlcyB9IGZyb20gJy4vdXRpbC1tYXAtaW5jbHVkZXMuanMnO1xuXG5jb25zdCBibG9ja01zZyA9ICdCbG9jayBjb2xsZWN0aW9ucyBhcmUgbm90IGFsbG93ZWQgd2l0aGluIGZsb3cgY29sbGVjdGlvbnMnO1xuY29uc3QgaXNCbG9jayA9ICh0b2tlbikgPT4gdG9rZW4gJiYgKHRva2VuLnR5cGUgPT09ICdibG9jay1tYXAnIHx8IHRva2VuLnR5cGUgPT09ICdibG9jay1zZXEnKTtcbmZ1bmN0aW9uIHJlc29sdmVGbG93Q29sbGVjdGlvbih7IGNvbXBvc2VOb2RlLCBjb21wb3NlRW1wdHlOb2RlIH0sIGN0eCwgZmMsIG9uRXJyb3IpIHtcbiAgICBjb25zdCBpc01hcCA9IGZjLnN0YXJ0LnNvdXJjZSA9PT0gJ3snO1xuICAgIGNvbnN0IGZjTmFtZSA9IGlzTWFwID8gJ2Zsb3cgbWFwJyA6ICdmbG93IHNlcXVlbmNlJztcbiAgICBjb25zdCBjb2xsID0gaXNNYXBcbiAgICAgICAgPyBuZXcgWUFNTE1hcChjdHguc2NoZW1hKVxuICAgICAgICA6IG5ldyBZQU1MU2VxKGN0eC5zY2hlbWEpO1xuICAgIGNvbGwuZmxvdyA9IHRydWU7XG4gICAgY29uc3QgYXRSb290ID0gY3R4LmF0Um9vdDtcbiAgICBpZiAoYXRSb290KVxuICAgICAgICBjdHguYXRSb290ID0gZmFsc2U7XG4gICAgbGV0IG9mZnNldCA9IGZjLm9mZnNldCArIGZjLnN0YXJ0LnNvdXJjZS5sZW5ndGg7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmYy5pdGVtcy5sZW5ndGg7ICsraSkge1xuICAgICAgICBjb25zdCBjb2xsSXRlbSA9IGZjLml0ZW1zW2ldO1xuICAgICAgICBjb25zdCB7IHN0YXJ0LCBrZXksIHNlcCwgdmFsdWUgfSA9IGNvbGxJdGVtO1xuICAgICAgICBjb25zdCBwcm9wcyA9IHJlc29sdmVQcm9wcyhzdGFydCwge1xuICAgICAgICAgICAgZmxvdzogZmNOYW1lLFxuICAgICAgICAgICAgaW5kaWNhdG9yOiAnZXhwbGljaXQta2V5LWluZCcsXG4gICAgICAgICAgICBuZXh0OiBrZXkgfHwgKHNlcCA9PT0gbnVsbCB8fCBzZXAgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNlcFswXSksXG4gICAgICAgICAgICBvZmZzZXQsXG4gICAgICAgICAgICBvbkVycm9yLFxuICAgICAgICAgICAgc3RhcnRPbk5ld2xpbmU6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIXByb3BzLmZvdW5kKSB7XG4gICAgICAgICAgICBpZiAoIXByb3BzLmFuY2hvciAmJiAhcHJvcHMudGFnICYmICFzZXAgJiYgIXZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgPT09IDAgJiYgcHJvcHMuY29tbWEpXG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3IocHJvcHMuY29tbWEsICdVTkVYUEVDVEVEX1RPS0VOJywgYFVuZXhwZWN0ZWQgLCBpbiAke2ZjTmFtZX1gKTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpIDwgZmMuaXRlbXMubGVuZ3RoIC0gMSlcbiAgICAgICAgICAgICAgICAgICAgb25FcnJvcihwcm9wcy5zdGFydCwgJ1VORVhQRUNURURfVE9LRU4nLCBgVW5leHBlY3RlZCBlbXB0eSBpdGVtIGluICR7ZmNOYW1lfWApO1xuICAgICAgICAgICAgICAgIGlmIChwcm9wcy5jb21tZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb2xsLmNvbW1lbnQpXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xsLmNvbW1lbnQgKz0gJ1xcbicgKyBwcm9wcy5jb21tZW50O1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xsLmNvbW1lbnQgPSBwcm9wcy5jb21tZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvZmZzZXQgPSBwcm9wcy5lbmQ7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWlzTWFwICYmIGN0eC5vcHRpb25zLnN0cmljdCAmJiBjb250YWluc05ld2xpbmUoa2V5KSlcbiAgICAgICAgICAgICAgICBvbkVycm9yKGtleSwgLy8gY2hlY2tlZCBieSBjb250YWluc05ld2xpbmUoKVxuICAgICAgICAgICAgICAgICdNVUxUSUxJTkVfSU1QTElDSVRfS0VZJywgJ0ltcGxpY2l0IGtleXMgb2YgZmxvdyBzZXF1ZW5jZSBwYWlycyBuZWVkIHRvIGJlIG9uIGEgc2luZ2xlIGxpbmUnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgICAgaWYgKHByb3BzLmNvbW1hKVxuICAgICAgICAgICAgICAgIG9uRXJyb3IocHJvcHMuY29tbWEsICdVTkVYUEVDVEVEX1RPS0VOJywgYFVuZXhwZWN0ZWQgLCBpbiAke2ZjTmFtZX1gKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICghcHJvcHMuY29tbWEpXG4gICAgICAgICAgICAgICAgb25FcnJvcihwcm9wcy5zdGFydCwgJ01JU1NJTkdfQ0hBUicsIGBNaXNzaW5nICwgYmV0d2VlbiAke2ZjTmFtZX0gaXRlbXNgKTtcbiAgICAgICAgICAgIGlmIChwcm9wcy5jb21tZW50KSB7XG4gICAgICAgICAgICAgICAgbGV0IHByZXZJdGVtQ29tbWVudCA9ICcnO1xuICAgICAgICAgICAgICAgIGxvb3A6IGZvciAoY29uc3Qgc3Qgb2Ygc3RhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChzdC50eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdjb21tYSc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdzcGFjZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdjb21tZW50JzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmV2SXRlbUNvbW1lbnQgPSBzdC5zb3VyY2Uuc3Vic3RyaW5nKDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIGxvb3A7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIGxvb3A7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHByZXZJdGVtQ29tbWVudCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcHJldiA9IGNvbGwuaXRlbXNbY29sbC5pdGVtcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzUGFpcihwcmV2KSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXYgPSBwcmV2LnZhbHVlIHx8IHByZXYua2V5O1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJldi5jb21tZW50KVxuICAgICAgICAgICAgICAgICAgICAgICAgcHJldi5jb21tZW50ICs9ICdcXG4nICsgcHJldkl0ZW1Db21tZW50O1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2LmNvbW1lbnQgPSBwcmV2SXRlbUNvbW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgIHByb3BzLmNvbW1lbnQgPSBwcm9wcy5jb21tZW50LnN1YnN0cmluZyhwcmV2SXRlbUNvbW1lbnQubGVuZ3RoICsgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghaXNNYXAgJiYgIXNlcCAmJiAhcHJvcHMuZm91bmQpIHtcbiAgICAgICAgICAgIC8vIGl0ZW0gaXMgYSB2YWx1ZSBpbiBhIHNlcVxuICAgICAgICAgICAgLy8gXHUyMTkyIGtleSAmIHNlcCBhcmUgZW1wdHksIHN0YXJ0IGRvZXMgbm90IGluY2x1ZGUgPyBvciA6XG4gICAgICAgICAgICBjb25zdCB2YWx1ZU5vZGUgPSB2YWx1ZVxuICAgICAgICAgICAgICAgID8gY29tcG9zZU5vZGUoY3R4LCB2YWx1ZSwgcHJvcHMsIG9uRXJyb3IpXG4gICAgICAgICAgICAgICAgOiBjb21wb3NlRW1wdHlOb2RlKGN0eCwgcHJvcHMuZW5kLCBzZXAsIG51bGwsIHByb3BzLCBvbkVycm9yKTtcbiAgICAgICAgICAgIGNvbGwuaXRlbXMucHVzaCh2YWx1ZU5vZGUpO1xuICAgICAgICAgICAgb2Zmc2V0ID0gdmFsdWVOb2RlLnJhbmdlWzJdO1xuICAgICAgICAgICAgaWYgKGlzQmxvY2sodmFsdWUpKVxuICAgICAgICAgICAgICAgIG9uRXJyb3IodmFsdWVOb2RlLnJhbmdlLCAnQkxPQ0tfSU5fRkxPVycsIGJsb2NrTXNnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGl0ZW0gaXMgYSBrZXkrdmFsdWUgcGFpclxuICAgICAgICAgICAgLy8ga2V5IHZhbHVlXG4gICAgICAgICAgICBjb25zdCBrZXlTdGFydCA9IHByb3BzLmVuZDtcbiAgICAgICAgICAgIGNvbnN0IGtleU5vZGUgPSBrZXlcbiAgICAgICAgICAgICAgICA/IGNvbXBvc2VOb2RlKGN0eCwga2V5LCBwcm9wcywgb25FcnJvcilcbiAgICAgICAgICAgICAgICA6IGNvbXBvc2VFbXB0eU5vZGUoY3R4LCBrZXlTdGFydCwgc3RhcnQsIG51bGwsIHByb3BzLCBvbkVycm9yKTtcbiAgICAgICAgICAgIGlmIChpc0Jsb2NrKGtleSkpXG4gICAgICAgICAgICAgICAgb25FcnJvcihrZXlOb2RlLnJhbmdlLCAnQkxPQ0tfSU5fRkxPVycsIGJsb2NrTXNnKTtcbiAgICAgICAgICAgIC8vIHZhbHVlIHByb3BlcnRpZXNcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlUHJvcHMgPSByZXNvbHZlUHJvcHMoc2VwIHx8IFtdLCB7XG4gICAgICAgICAgICAgICAgZmxvdzogZmNOYW1lLFxuICAgICAgICAgICAgICAgIGluZGljYXRvcjogJ21hcC12YWx1ZS1pbmQnLFxuICAgICAgICAgICAgICAgIG5leHQ6IHZhbHVlLFxuICAgICAgICAgICAgICAgIG9mZnNldDoga2V5Tm9kZS5yYW5nZVsyXSxcbiAgICAgICAgICAgICAgICBvbkVycm9yLFxuICAgICAgICAgICAgICAgIHN0YXJ0T25OZXdsaW5lOiBmYWxzZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAodmFsdWVQcm9wcy5mb3VuZCkge1xuICAgICAgICAgICAgICAgIGlmICghaXNNYXAgJiYgIXByb3BzLmZvdW5kICYmIGN0eC5vcHRpb25zLnN0cmljdCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VwKVxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBzdCBvZiBzZXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3QgPT09IHZhbHVlUHJvcHMuZm91bmQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdC50eXBlID09PSAnbmV3bGluZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25FcnJvcihzdCwgJ01VTFRJTElORV9JTVBMSUNJVF9LRVknLCAnSW1wbGljaXQga2V5cyBvZiBmbG93IHNlcXVlbmNlIHBhaXJzIG5lZWQgdG8gYmUgb24gYSBzaW5nbGUgbGluZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9wcy5zdGFydCA8IHZhbHVlUHJvcHMuZm91bmQub2Zmc2V0IC0gMTAyNClcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uRXJyb3IodmFsdWVQcm9wcy5mb3VuZCwgJ0tFWV9PVkVSXzEwMjRfQ0hBUlMnLCAnVGhlIDogaW5kaWNhdG9yIG11c3QgYmUgYXQgbW9zdCAxMDI0IGNoYXJzIGFmdGVyIHRoZSBzdGFydCBvZiBhbiBpbXBsaWNpdCBmbG93IHNlcXVlbmNlIGtleScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCdzb3VyY2UnIGluIHZhbHVlICYmIHZhbHVlLnNvdXJjZSAmJiB2YWx1ZS5zb3VyY2VbMF0gPT09ICc6JylcbiAgICAgICAgICAgICAgICAgICAgb25FcnJvcih2YWx1ZSwgJ01JU1NJTkdfQ0hBUicsIGBNaXNzaW5nIHNwYWNlIGFmdGVyIDogaW4gJHtmY05hbWV9YCk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBvbkVycm9yKHZhbHVlUHJvcHMuc3RhcnQsICdNSVNTSU5HX0NIQVInLCBgTWlzc2luZyAsIG9yIDogYmV0d2VlbiAke2ZjTmFtZX0gaXRlbXNgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHZhbHVlIHZhbHVlXG4gICAgICAgICAgICBjb25zdCB2YWx1ZU5vZGUgPSB2YWx1ZVxuICAgICAgICAgICAgICAgID8gY29tcG9zZU5vZGUoY3R4LCB2YWx1ZSwgdmFsdWVQcm9wcywgb25FcnJvcilcbiAgICAgICAgICAgICAgICA6IHZhbHVlUHJvcHMuZm91bmRcbiAgICAgICAgICAgICAgICAgICAgPyBjb21wb3NlRW1wdHlOb2RlKGN0eCwgdmFsdWVQcm9wcy5lbmQsIHNlcCwgbnVsbCwgdmFsdWVQcm9wcywgb25FcnJvcilcbiAgICAgICAgICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICAgICAgaWYgKHZhbHVlTm9kZSkge1xuICAgICAgICAgICAgICAgIGlmIChpc0Jsb2NrKHZhbHVlKSlcbiAgICAgICAgICAgICAgICAgICAgb25FcnJvcih2YWx1ZU5vZGUucmFuZ2UsICdCTE9DS19JTl9GTE9XJywgYmxvY2tNc2cpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWVQcm9wcy5jb21tZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKGtleU5vZGUuY29tbWVudClcbiAgICAgICAgICAgICAgICAgICAga2V5Tm9kZS5jb21tZW50ICs9ICdcXG4nICsgdmFsdWVQcm9wcy5jb21tZW50O1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAga2V5Tm9kZS5jb21tZW50ID0gdmFsdWVQcm9wcy5jb21tZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcGFpciA9IG5ldyBQYWlyKGtleU5vZGUsIHZhbHVlTm9kZSk7XG4gICAgICAgICAgICBpZiAoY3R4Lm9wdGlvbnMua2VlcFNvdXJjZVRva2VucylcbiAgICAgICAgICAgICAgICBwYWlyLnNyY1Rva2VuID0gY29sbEl0ZW07XG4gICAgICAgICAgICBpZiAoaXNNYXApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXAgPSBjb2xsO1xuICAgICAgICAgICAgICAgIGlmIChtYXBJbmNsdWRlcyhjdHgsIG1hcC5pdGVtcywga2V5Tm9kZSkpXG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3Ioa2V5U3RhcnQsICdEVVBMSUNBVEVfS0VZJywgJ01hcCBrZXlzIG11c3QgYmUgdW5pcXVlJyk7XG4gICAgICAgICAgICAgICAgbWFwLml0ZW1zLnB1c2gocGFpcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXAgPSBuZXcgWUFNTE1hcChjdHguc2NoZW1hKTtcbiAgICAgICAgICAgICAgICBtYXAuZmxvdyA9IHRydWU7XG4gICAgICAgICAgICAgICAgbWFwLml0ZW1zLnB1c2gocGFpcik7XG4gICAgICAgICAgICAgICAgY29sbC5pdGVtcy5wdXNoKG1hcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvZmZzZXQgPSB2YWx1ZU5vZGUgPyB2YWx1ZU5vZGUucmFuZ2VbMl0gOiB2YWx1ZVByb3BzLmVuZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBleHBlY3RlZEVuZCA9IGlzTWFwID8gJ30nIDogJ10nO1xuICAgIGNvbnN0IFtjZSwgLi4uZWVdID0gZmMuZW5kO1xuICAgIGxldCBjZVBvcyA9IG9mZnNldDtcbiAgICBpZiAoY2UgJiYgY2Uuc291cmNlID09PSBleHBlY3RlZEVuZClcbiAgICAgICAgY2VQb3MgPSBjZS5vZmZzZXQgKyBjZS5zb3VyY2UubGVuZ3RoO1xuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBuYW1lID0gZmNOYW1lWzBdLnRvVXBwZXJDYXNlKCkgKyBmY05hbWUuc3Vic3RyaW5nKDEpO1xuICAgICAgICBjb25zdCBtc2cgPSBhdFJvb3RcbiAgICAgICAgICAgID8gYCR7bmFtZX0gbXVzdCBlbmQgd2l0aCBhICR7ZXhwZWN0ZWRFbmR9YFxuICAgICAgICAgICAgOiBgJHtuYW1lfSBpbiBibG9jayBjb2xsZWN0aW9uIG11c3QgYmUgc3VmZmljaWVudGx5IGluZGVudGVkIGFuZCBlbmQgd2l0aCBhICR7ZXhwZWN0ZWRFbmR9YDtcbiAgICAgICAgb25FcnJvcihvZmZzZXQsIGF0Um9vdCA/ICdNSVNTSU5HX0NIQVInIDogJ0JBRF9JTkRFTlQnLCBtc2cpO1xuICAgICAgICBpZiAoY2UgJiYgY2Uuc291cmNlLmxlbmd0aCAhPT0gMSlcbiAgICAgICAgICAgIGVlLnVuc2hpZnQoY2UpO1xuICAgIH1cbiAgICBpZiAoZWUubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCBlbmQgPSByZXNvbHZlRW5kKGVlLCBjZVBvcywgY3R4Lm9wdGlvbnMuc3RyaWN0LCBvbkVycm9yKTtcbiAgICAgICAgaWYgKGVuZC5jb21tZW50KSB7XG4gICAgICAgICAgICBpZiAoY29sbC5jb21tZW50KVxuICAgICAgICAgICAgICAgIGNvbGwuY29tbWVudCArPSAnXFxuJyArIGVuZC5jb21tZW50O1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGNvbGwuY29tbWVudCA9IGVuZC5jb21tZW50O1xuICAgICAgICB9XG4gICAgICAgIGNvbGwucmFuZ2UgPSBbZmMub2Zmc2V0LCBjZVBvcywgZW5kLm9mZnNldF07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb2xsLnJhbmdlID0gW2ZjLm9mZnNldCwgY2VQb3MsIGNlUG9zXTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbGw7XG59XG5cbmV4cG9ydCB7IHJlc29sdmVGbG93Q29sbGVjdGlvbiB9O1xuIiwgImltcG9ydCB7IGlzTm9kZSwgaXNNYXAgfSBmcm9tICcuLi9ub2Rlcy9Ob2RlLmpzJztcbmltcG9ydCB7IFNjYWxhciB9IGZyb20gJy4uL25vZGVzL1NjYWxhci5qcyc7XG5pbXBvcnQgeyByZXNvbHZlQmxvY2tNYXAgfSBmcm9tICcuL3Jlc29sdmUtYmxvY2stbWFwLmpzJztcbmltcG9ydCB7IHJlc29sdmVCbG9ja1NlcSB9IGZyb20gJy4vcmVzb2x2ZS1ibG9jay1zZXEuanMnO1xuaW1wb3J0IHsgcmVzb2x2ZUZsb3dDb2xsZWN0aW9uIH0gZnJvbSAnLi9yZXNvbHZlLWZsb3ctY29sbGVjdGlvbi5qcyc7XG5cbmZ1bmN0aW9uIGNvbXBvc2VDb2xsZWN0aW9uKENOLCBjdHgsIHRva2VuLCB0YWdUb2tlbiwgb25FcnJvcikge1xuICAgIGxldCBjb2xsO1xuICAgIHN3aXRjaCAodG9rZW4udHlwZSkge1xuICAgICAgICBjYXNlICdibG9jay1tYXAnOiB7XG4gICAgICAgICAgICBjb2xsID0gcmVzb2x2ZUJsb2NrTWFwKENOLCBjdHgsIHRva2VuLCBvbkVycm9yKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ2Jsb2NrLXNlcSc6IHtcbiAgICAgICAgICAgIGNvbGwgPSByZXNvbHZlQmxvY2tTZXEoQ04sIGN0eCwgdG9rZW4sIG9uRXJyb3IpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnZmxvdy1jb2xsZWN0aW9uJzoge1xuICAgICAgICAgICAgY29sbCA9IHJlc29sdmVGbG93Q29sbGVjdGlvbihDTiwgY3R4LCB0b2tlbiwgb25FcnJvcik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXRhZ1Rva2VuKVxuICAgICAgICByZXR1cm4gY29sbDtcbiAgICBjb25zdCB0YWdOYW1lID0gY3R4LmRpcmVjdGl2ZXMudGFnTmFtZSh0YWdUb2tlbi5zb3VyY2UsIG1zZyA9PiBvbkVycm9yKHRhZ1Rva2VuLCAnVEFHX1JFU09MVkVfRkFJTEVEJywgbXNnKSk7XG4gICAgaWYgKCF0YWdOYW1lKVxuICAgICAgICByZXR1cm4gY29sbDtcbiAgICAvLyBDYXN0IG5lZWRlZCBkdWUgdG86IGh0dHBzOi8vZ2l0aHViLmNvbS9NaWNyb3NvZnQvVHlwZVNjcmlwdC9pc3N1ZXMvMzg0MVxuICAgIGNvbnN0IENvbGwgPSBjb2xsLmNvbnN0cnVjdG9yO1xuICAgIGlmICh0YWdOYW1lID09PSAnIScgfHwgdGFnTmFtZSA9PT0gQ29sbC50YWdOYW1lKSB7XG4gICAgICAgIGNvbGwudGFnID0gQ29sbC50YWdOYW1lO1xuICAgICAgICByZXR1cm4gY29sbDtcbiAgICB9XG4gICAgY29uc3QgZXhwVHlwZSA9IGlzTWFwKGNvbGwpID8gJ21hcCcgOiAnc2VxJztcbiAgICBsZXQgdGFnID0gY3R4LnNjaGVtYS50YWdzLmZpbmQodCA9PiB0LmNvbGxlY3Rpb24gPT09IGV4cFR5cGUgJiYgdC50YWcgPT09IHRhZ05hbWUpO1xuICAgIGlmICghdGFnKSB7XG4gICAgICAgIGNvbnN0IGt0ID0gY3R4LnNjaGVtYS5rbm93blRhZ3NbdGFnTmFtZV07XG4gICAgICAgIGlmIChrdCAmJiBrdC5jb2xsZWN0aW9uID09PSBleHBUeXBlKSB7XG4gICAgICAgICAgICBjdHguc2NoZW1hLnRhZ3MucHVzaChPYmplY3QuYXNzaWduKHt9LCBrdCwgeyBkZWZhdWx0OiBmYWxzZSB9KSk7XG4gICAgICAgICAgICB0YWcgPSBrdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9uRXJyb3IodGFnVG9rZW4sICdUQUdfUkVTT0xWRV9GQUlMRUQnLCBgVW5yZXNvbHZlZCB0YWc6ICR7dGFnTmFtZX1gLCB0cnVlKTtcbiAgICAgICAgICAgIGNvbGwudGFnID0gdGFnTmFtZTtcbiAgICAgICAgICAgIHJldHVybiBjb2xsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHJlcyA9IHRhZy5yZXNvbHZlKGNvbGwsIG1zZyA9PiBvbkVycm9yKHRhZ1Rva2VuLCAnVEFHX1JFU09MVkVfRkFJTEVEJywgbXNnKSwgY3R4Lm9wdGlvbnMpO1xuICAgIGNvbnN0IG5vZGUgPSBpc05vZGUocmVzKVxuICAgICAgICA/IHJlc1xuICAgICAgICA6IG5ldyBTY2FsYXIocmVzKTtcbiAgICBub2RlLnJhbmdlID0gY29sbC5yYW5nZTtcbiAgICBub2RlLnRhZyA9IHRhZ05hbWU7XG4gICAgaWYgKHRhZyA9PT0gbnVsbCB8fCB0YWcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRhZy5mb3JtYXQpXG4gICAgICAgIG5vZGUuZm9ybWF0ID0gdGFnLmZvcm1hdDtcbiAgICByZXR1cm4gbm9kZTtcbn1cblxuZXhwb3J0IHsgY29tcG9zZUNvbGxlY3Rpb24gfTtcbiIsICJpbXBvcnQgeyBTY2FsYXIgfSBmcm9tICcuLi9ub2Rlcy9TY2FsYXIuanMnO1xuXG5mdW5jdGlvbiByZXNvbHZlQmxvY2tTY2FsYXIoc2NhbGFyLCBzdHJpY3QsIG9uRXJyb3IpIHtcbiAgICBjb25zdCBzdGFydCA9IHNjYWxhci5vZmZzZXQ7XG4gICAgY29uc3QgaGVhZGVyID0gcGFyc2VCbG9ja1NjYWxhckhlYWRlcihzY2FsYXIsIHN0cmljdCwgb25FcnJvcik7XG4gICAgaWYgKCFoZWFkZXIpXG4gICAgICAgIHJldHVybiB7IHZhbHVlOiAnJywgdHlwZTogbnVsbCwgY29tbWVudDogJycsIHJhbmdlOiBbc3RhcnQsIHN0YXJ0LCBzdGFydF0gfTtcbiAgICBjb25zdCB0eXBlID0gaGVhZGVyLm1vZGUgPT09ICc+JyA/IFNjYWxhci5CTE9DS19GT0xERUQgOiBTY2FsYXIuQkxPQ0tfTElURVJBTDtcbiAgICBjb25zdCBsaW5lcyA9IHNjYWxhci5zb3VyY2UgPyBzcGxpdExpbmVzKHNjYWxhci5zb3VyY2UpIDogW107XG4gICAgLy8gZGV0ZXJtaW5lIHRoZSBlbmQgb2YgY29udGVudCAmIHN0YXJ0IG9mIGNob21waW5nXG4gICAgbGV0IGNob21wU3RhcnQgPSBsaW5lcy5sZW5ndGg7XG4gICAgZm9yIChsZXQgaSA9IGxpbmVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIGNvbnN0IGNvbnRlbnQgPSBsaW5lc1tpXVsxXTtcbiAgICAgICAgaWYgKGNvbnRlbnQgPT09ICcnIHx8IGNvbnRlbnQgPT09ICdcXHInKVxuICAgICAgICAgICAgY2hvbXBTdGFydCA9IGk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICAvLyBzaG9ydGN1dCBmb3IgZW1wdHkgY29udGVudHNcbiAgICBpZiAoIXNjYWxhci5zb3VyY2UgfHwgY2hvbXBTdGFydCA9PT0gMCkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGhlYWRlci5jaG9tcCA9PT0gJysnID8gJ1xcbicucmVwZWF0KE1hdGgubWF4KDAsIGxpbmVzLmxlbmd0aCAtIDEpKSA6ICcnO1xuICAgICAgICBsZXQgZW5kID0gc3RhcnQgKyBoZWFkZXIubGVuZ3RoO1xuICAgICAgICBpZiAoc2NhbGFyLnNvdXJjZSlcbiAgICAgICAgICAgIGVuZCArPSBzY2FsYXIuc291cmNlLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHsgdmFsdWUsIHR5cGUsIGNvbW1lbnQ6IGhlYWRlci5jb21tZW50LCByYW5nZTogW3N0YXJ0LCBlbmQsIGVuZF0gfTtcbiAgICB9XG4gICAgLy8gZmluZCB0aGUgaW5kZW50YXRpb24gbGV2ZWwgdG8gdHJpbSBmcm9tIHN0YXJ0XG4gICAgbGV0IHRyaW1JbmRlbnQgPSBzY2FsYXIuaW5kZW50ICsgaGVhZGVyLmluZGVudDtcbiAgICBsZXQgb2Zmc2V0ID0gc2NhbGFyLm9mZnNldCArIGhlYWRlci5sZW5ndGg7XG4gICAgbGV0IGNvbnRlbnRTdGFydCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaG9tcFN0YXJ0OyArK2kpIHtcbiAgICAgICAgY29uc3QgW2luZGVudCwgY29udGVudF0gPSBsaW5lc1tpXTtcbiAgICAgICAgaWYgKGNvbnRlbnQgPT09ICcnIHx8IGNvbnRlbnQgPT09ICdcXHInKSB7XG4gICAgICAgICAgICBpZiAoaGVhZGVyLmluZGVudCA9PT0gMCAmJiBpbmRlbnQubGVuZ3RoID4gdHJpbUluZGVudClcbiAgICAgICAgICAgICAgICB0cmltSW5kZW50ID0gaW5kZW50Lmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChpbmRlbnQubGVuZ3RoIDwgdHJpbUluZGVudCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSAnQmxvY2sgc2NhbGFycyB3aXRoIG1vcmUtaW5kZW50ZWQgbGVhZGluZyBlbXB0eSBsaW5lcyBtdXN0IHVzZSBhbiBleHBsaWNpdCBpbmRlbnRhdGlvbiBpbmRpY2F0b3InO1xuICAgICAgICAgICAgICAgIG9uRXJyb3Iob2Zmc2V0ICsgaW5kZW50Lmxlbmd0aCwgJ01JU1NJTkdfQ0hBUicsIG1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGhlYWRlci5pbmRlbnQgPT09IDApXG4gICAgICAgICAgICAgICAgdHJpbUluZGVudCA9IGluZGVudC5sZW5ndGg7XG4gICAgICAgICAgICBjb250ZW50U3RhcnQgPSBpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgb2Zmc2V0ICs9IGluZGVudC5sZW5ndGggKyBjb250ZW50Lmxlbmd0aCArIDE7XG4gICAgfVxuICAgIGxldCB2YWx1ZSA9ICcnO1xuICAgIGxldCBzZXAgPSAnJztcbiAgICBsZXQgcHJldk1vcmVJbmRlbnRlZCA9IGZhbHNlO1xuICAgIC8vIGxlYWRpbmcgd2hpdGVzcGFjZSBpcyBrZXB0IGludGFjdFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29udGVudFN0YXJ0OyArK2kpXG4gICAgICAgIHZhbHVlICs9IGxpbmVzW2ldWzBdLnNsaWNlKHRyaW1JbmRlbnQpICsgJ1xcbic7XG4gICAgZm9yIChsZXQgaSA9IGNvbnRlbnRTdGFydDsgaSA8IGNob21wU3RhcnQ7ICsraSkge1xuICAgICAgICBsZXQgW2luZGVudCwgY29udGVudF0gPSBsaW5lc1tpXTtcbiAgICAgICAgb2Zmc2V0ICs9IGluZGVudC5sZW5ndGggKyBjb250ZW50Lmxlbmd0aCArIDE7XG4gICAgICAgIGNvbnN0IGNybGYgPSBjb250ZW50W2NvbnRlbnQubGVuZ3RoIC0gMV0gPT09ICdcXHInO1xuICAgICAgICBpZiAoY3JsZilcbiAgICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50LnNsaWNlKDAsIC0xKTtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmIGFscmVhZHkgY2F1Z2h0IGluIGxleGVyICovXG4gICAgICAgIGlmIChjb250ZW50ICYmIGluZGVudC5sZW5ndGggPCB0cmltSW5kZW50KSB7XG4gICAgICAgICAgICBjb25zdCBzcmMgPSBoZWFkZXIuaW5kZW50XG4gICAgICAgICAgICAgICAgPyAnZXhwbGljaXQgaW5kZW50YXRpb24gaW5kaWNhdG9yJ1xuICAgICAgICAgICAgICAgIDogJ2ZpcnN0IGxpbmUnO1xuICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IGBCbG9jayBzY2FsYXIgbGluZXMgbXVzdCBub3QgYmUgbGVzcyBpbmRlbnRlZCB0aGFuIHRoZWlyICR7c3JjfWA7XG4gICAgICAgICAgICBvbkVycm9yKG9mZnNldCAtIGNvbnRlbnQubGVuZ3RoIC0gKGNybGYgPyAyIDogMSksICdCQURfSU5ERU5UJywgbWVzc2FnZSk7XG4gICAgICAgICAgICBpbmRlbnQgPSAnJztcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZSA9PT0gU2NhbGFyLkJMT0NLX0xJVEVSQUwpIHtcbiAgICAgICAgICAgIHZhbHVlICs9IHNlcCArIGluZGVudC5zbGljZSh0cmltSW5kZW50KSArIGNvbnRlbnQ7XG4gICAgICAgICAgICBzZXAgPSAnXFxuJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpbmRlbnQubGVuZ3RoID4gdHJpbUluZGVudCB8fCBjb250ZW50WzBdID09PSAnXFx0Jykge1xuICAgICAgICAgICAgLy8gbW9yZS1pbmRlbnRlZCBjb250ZW50IHdpdGhpbiBhIGZvbGRlZCBibG9ja1xuICAgICAgICAgICAgaWYgKHNlcCA9PT0gJyAnKVxuICAgICAgICAgICAgICAgIHNlcCA9ICdcXG4nO1xuICAgICAgICAgICAgZWxzZSBpZiAoIXByZXZNb3JlSW5kZW50ZWQgJiYgc2VwID09PSAnXFxuJylcbiAgICAgICAgICAgICAgICBzZXAgPSAnXFxuXFxuJztcbiAgICAgICAgICAgIHZhbHVlICs9IHNlcCArIGluZGVudC5zbGljZSh0cmltSW5kZW50KSArIGNvbnRlbnQ7XG4gICAgICAgICAgICBzZXAgPSAnXFxuJztcbiAgICAgICAgICAgIHByZXZNb3JlSW5kZW50ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvbnRlbnQgPT09ICcnKSB7XG4gICAgICAgICAgICAvLyBlbXB0eSBsaW5lXG4gICAgICAgICAgICBpZiAoc2VwID09PSAnXFxuJylcbiAgICAgICAgICAgICAgICB2YWx1ZSArPSAnXFxuJztcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBzZXAgPSAnXFxuJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhbHVlICs9IHNlcCArIGNvbnRlbnQ7XG4gICAgICAgICAgICBzZXAgPSAnICc7XG4gICAgICAgICAgICBwcmV2TW9yZUluZGVudGVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3dpdGNoIChoZWFkZXIuY2hvbXApIHtcbiAgICAgICAgY2FzZSAnLSc6XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnKyc6XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gY2hvbXBTdGFydDsgaSA8IGxpbmVzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgIHZhbHVlICs9ICdcXG4nICsgbGluZXNbaV1bMF0uc2xpY2UodHJpbUluZGVudCk7XG4gICAgICAgICAgICBpZiAodmFsdWVbdmFsdWUubGVuZ3RoIC0gMV0gIT09ICdcXG4nKVxuICAgICAgICAgICAgICAgIHZhbHVlICs9ICdcXG4nO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB2YWx1ZSArPSAnXFxuJztcbiAgICB9XG4gICAgY29uc3QgZW5kID0gc3RhcnQgKyBoZWFkZXIubGVuZ3RoICsgc2NhbGFyLnNvdXJjZS5sZW5ndGg7XG4gICAgcmV0dXJuIHsgdmFsdWUsIHR5cGUsIGNvbW1lbnQ6IGhlYWRlci5jb21tZW50LCByYW5nZTogW3N0YXJ0LCBlbmQsIGVuZF0gfTtcbn1cbmZ1bmN0aW9uIHBhcnNlQmxvY2tTY2FsYXJIZWFkZXIoeyBvZmZzZXQsIHByb3BzIH0sIHN0cmljdCwgb25FcnJvcikge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiBzaG91bGQgbm90IGhhcHBlbiAqL1xuICAgIGlmIChwcm9wc1swXS50eXBlICE9PSAnYmxvY2stc2NhbGFyLWhlYWRlcicpIHtcbiAgICAgICAgb25FcnJvcihwcm9wc1swXSwgJ0lNUE9TU0lCTEUnLCAnQmxvY2sgc2NhbGFyIGhlYWRlciBub3QgZm91bmQnKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHsgc291cmNlIH0gPSBwcm9wc1swXTtcbiAgICBjb25zdCBtb2RlID0gc291cmNlWzBdO1xuICAgIGxldCBpbmRlbnQgPSAwO1xuICAgIGxldCBjaG9tcCA9ICcnO1xuICAgIGxldCBlcnJvciA9IC0xO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgc291cmNlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IGNoID0gc291cmNlW2ldO1xuICAgICAgICBpZiAoIWNob21wICYmIChjaCA9PT0gJy0nIHx8IGNoID09PSAnKycpKVxuICAgICAgICAgICAgY2hvbXAgPSBjaDtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBuID0gTnVtYmVyKGNoKTtcbiAgICAgICAgICAgIGlmICghaW5kZW50ICYmIG4pXG4gICAgICAgICAgICAgICAgaW5kZW50ID0gbjtcbiAgICAgICAgICAgIGVsc2UgaWYgKGVycm9yID09PSAtMSlcbiAgICAgICAgICAgICAgICBlcnJvciA9IG9mZnNldCArIGk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGVycm9yICE9PSAtMSlcbiAgICAgICAgb25FcnJvcihlcnJvciwgJ1VORVhQRUNURURfVE9LRU4nLCBgQmxvY2sgc2NhbGFyIGhlYWRlciBpbmNsdWRlcyBleHRyYSBjaGFyYWN0ZXJzOiAke3NvdXJjZX1gKTtcbiAgICBsZXQgaGFzU3BhY2UgPSBmYWxzZTtcbiAgICBsZXQgY29tbWVudCA9ICcnO1xuICAgIGxldCBsZW5ndGggPSBzb3VyY2UubGVuZ3RoO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgcHJvcHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29uc3QgdG9rZW4gPSBwcm9wc1tpXTtcbiAgICAgICAgc3dpdGNoICh0b2tlbi50eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdzcGFjZSc6XG4gICAgICAgICAgICAgICAgaGFzU3BhY2UgPSB0cnVlO1xuICAgICAgICAgICAgLy8gZmFsbHRocm91Z2hcbiAgICAgICAgICAgIGNhc2UgJ25ld2xpbmUnOlxuICAgICAgICAgICAgICAgIGxlbmd0aCArPSB0b2tlbi5zb3VyY2UubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnY29tbWVudCc6XG4gICAgICAgICAgICAgICAgaWYgKHN0cmljdCAmJiAhaGFzU3BhY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9ICdDb21tZW50cyBtdXN0IGJlIHNlcGFyYXRlZCBmcm9tIG90aGVyIHRva2VucyBieSB3aGl0ZSBzcGFjZSBjaGFyYWN0ZXJzJztcbiAgICAgICAgICAgICAgICAgICAgb25FcnJvcih0b2tlbiwgJ01JU1NJTkdfQ0hBUicsIG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZW5ndGggKz0gdG9rZW4uc291cmNlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBjb21tZW50ID0gdG9rZW4uc291cmNlLnN1YnN0cmluZygxKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2Vycm9yJzpcbiAgICAgICAgICAgICAgICBvbkVycm9yKHRva2VuLCAnVU5FWFBFQ1RFRF9UT0tFTicsIHRva2VuLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIGxlbmd0aCArPSB0b2tlbi5zb3VyY2UubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgc2hvdWxkIG5vdCBoYXBwZW4gKi9cbiAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gYFVuZXhwZWN0ZWQgdG9rZW4gaW4gYmxvY2sgc2NhbGFyIGhlYWRlcjogJHt0b2tlbi50eXBlfWA7XG4gICAgICAgICAgICAgICAgb25FcnJvcih0b2tlbiwgJ1VORVhQRUNURURfVE9LRU4nLCBtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0cyA9IHRva2VuLnNvdXJjZTtcbiAgICAgICAgICAgICAgICBpZiAodHMgJiYgdHlwZW9mIHRzID09PSAnc3RyaW5nJylcbiAgICAgICAgICAgICAgICAgICAgbGVuZ3RoICs9IHRzLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBtb2RlLCBpbmRlbnQsIGNob21wLCBjb21tZW50LCBsZW5ndGggfTtcbn1cbi8qKiBAcmV0dXJucyBBcnJheSBvZiBsaW5lcyBzcGxpdCB1cCBhcyBgW2luZGVudCwgY29udGVudF1gICovXG5mdW5jdGlvbiBzcGxpdExpbmVzKHNvdXJjZSkge1xuICAgIGNvbnN0IHNwbGl0ID0gc291cmNlLnNwbGl0KC9cXG4oICopLyk7XG4gICAgY29uc3QgZmlyc3QgPSBzcGxpdFswXTtcbiAgICBjb25zdCBtID0gZmlyc3QubWF0Y2goL14oICopLyk7XG4gICAgY29uc3QgbGluZTAgPSBtICYmIG1bMV0gPyBbbVsxXSwgZmlyc3Quc2xpY2UobVsxXS5sZW5ndGgpXSA6IFsnJywgZmlyc3RdO1xuICAgIGNvbnN0IGxpbmVzID0gW2xpbmUwXTtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IHNwbGl0Lmxlbmd0aDsgaSArPSAyKVxuICAgICAgICBsaW5lcy5wdXNoKFtzcGxpdFtpXSwgc3BsaXRbaSArIDFdXSk7XG4gICAgcmV0dXJuIGxpbmVzO1xufVxuXG5leHBvcnQgeyByZXNvbHZlQmxvY2tTY2FsYXIgfTtcbiIsICJpbXBvcnQgeyBTY2FsYXIgfSBmcm9tICcuLi9ub2Rlcy9TY2FsYXIuanMnO1xuaW1wb3J0IHsgcmVzb2x2ZUVuZCB9IGZyb20gJy4vcmVzb2x2ZS1lbmQuanMnO1xuXG5mdW5jdGlvbiByZXNvbHZlRmxvd1NjYWxhcihzY2FsYXIsIHN0cmljdCwgb25FcnJvcikge1xuICAgIGNvbnN0IHsgb2Zmc2V0LCB0eXBlLCBzb3VyY2UsIGVuZCB9ID0gc2NhbGFyO1xuICAgIGxldCBfdHlwZTtcbiAgICBsZXQgdmFsdWU7XG4gICAgY29uc3QgX29uRXJyb3IgPSAocmVsLCBjb2RlLCBtc2cpID0+IG9uRXJyb3Iob2Zmc2V0ICsgcmVsLCBjb2RlLCBtc2cpO1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlICdzY2FsYXInOlxuICAgICAgICAgICAgX3R5cGUgPSBTY2FsYXIuUExBSU47XG4gICAgICAgICAgICB2YWx1ZSA9IHBsYWluVmFsdWUoc291cmNlLCBfb25FcnJvcik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnc2luZ2xlLXF1b3RlZC1zY2FsYXInOlxuICAgICAgICAgICAgX3R5cGUgPSBTY2FsYXIuUVVPVEVfU0lOR0xFO1xuICAgICAgICAgICAgdmFsdWUgPSBzaW5nbGVRdW90ZWRWYWx1ZShzb3VyY2UsIF9vbkVycm9yKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdkb3VibGUtcXVvdGVkLXNjYWxhcic6XG4gICAgICAgICAgICBfdHlwZSA9IFNjYWxhci5RVU9URV9ET1VCTEU7XG4gICAgICAgICAgICB2YWx1ZSA9IGRvdWJsZVF1b3RlZFZhbHVlKHNvdXJjZSwgX29uRXJyb3IpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0IHNob3VsZCBub3QgaGFwcGVuICovXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBvbkVycm9yKHNjYWxhciwgJ1VORVhQRUNURURfVE9LRU4nLCBgRXhwZWN0ZWQgYSBmbG93IHNjYWxhciB2YWx1ZSwgYnV0IGZvdW5kOiAke3R5cGV9YCk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHZhbHVlOiAnJyxcbiAgICAgICAgICAgICAgICB0eXBlOiBudWxsLFxuICAgICAgICAgICAgICAgIGNvbW1lbnQ6ICcnLFxuICAgICAgICAgICAgICAgIHJhbmdlOiBbb2Zmc2V0LCBvZmZzZXQgKyBzb3VyY2UubGVuZ3RoLCBvZmZzZXQgKyBzb3VyY2UubGVuZ3RoXVxuICAgICAgICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgdmFsdWVFbmQgPSBvZmZzZXQgKyBzb3VyY2UubGVuZ3RoO1xuICAgIGNvbnN0IHJlID0gcmVzb2x2ZUVuZChlbmQsIHZhbHVlRW5kLCBzdHJpY3QsIG9uRXJyb3IpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlLFxuICAgICAgICB0eXBlOiBfdHlwZSxcbiAgICAgICAgY29tbWVudDogcmUuY29tbWVudCxcbiAgICAgICAgcmFuZ2U6IFtvZmZzZXQsIHZhbHVlRW5kLCByZS5vZmZzZXRdXG4gICAgfTtcbn1cbmZ1bmN0aW9uIHBsYWluVmFsdWUoc291cmNlLCBvbkVycm9yKSB7XG4gICAgbGV0IGJhZENoYXIgPSAnJztcbiAgICBzd2l0Y2ggKHNvdXJjZVswXSkge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCBzaG91bGQgbm90IGhhcHBlbiAqL1xuICAgICAgICBjYXNlICdcXHQnOlxuICAgICAgICAgICAgYmFkQ2hhciA9ICdhIHRhYiBjaGFyYWN0ZXInO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJywnOlxuICAgICAgICAgICAgYmFkQ2hhciA9ICdmbG93IGluZGljYXRvciBjaGFyYWN0ZXIgLCc7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnJSc6XG4gICAgICAgICAgICBiYWRDaGFyID0gJ2RpcmVjdGl2ZSBpbmRpY2F0b3IgY2hhcmFjdGVyICUnO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3wnOlxuICAgICAgICBjYXNlICc+Jzoge1xuICAgICAgICAgICAgYmFkQ2hhciA9IGBibG9jayBzY2FsYXIgaW5kaWNhdG9yICR7c291cmNlWzBdfWA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdAJzpcbiAgICAgICAgY2FzZSAnYCc6IHtcbiAgICAgICAgICAgIGJhZENoYXIgPSBgcmVzZXJ2ZWQgY2hhcmFjdGVyICR7c291cmNlWzBdfWA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoYmFkQ2hhcilcbiAgICAgICAgb25FcnJvcigwLCAnQkFEX1NDQUxBUl9TVEFSVCcsIGBQbGFpbiB2YWx1ZSBjYW5ub3Qgc3RhcnQgd2l0aCAke2JhZENoYXJ9YCk7XG4gICAgcmV0dXJuIGZvbGRMaW5lcyhzb3VyY2UpO1xufVxuZnVuY3Rpb24gc2luZ2xlUXVvdGVkVmFsdWUoc291cmNlLCBvbkVycm9yKSB7XG4gICAgaWYgKHNvdXJjZVtzb3VyY2UubGVuZ3RoIC0gMV0gIT09IFwiJ1wiIHx8IHNvdXJjZS5sZW5ndGggPT09IDEpXG4gICAgICAgIG9uRXJyb3Ioc291cmNlLmxlbmd0aCwgJ01JU1NJTkdfQ0hBUicsIFwiTWlzc2luZyBjbG9zaW5nICdxdW90ZVwiKTtcbiAgICByZXR1cm4gZm9sZExpbmVzKHNvdXJjZS5zbGljZSgxLCAtMSkpLnJlcGxhY2UoLycnL2csIFwiJ1wiKTtcbn1cbmZ1bmN0aW9uIGZvbGRMaW5lcyhzb3VyY2UpIHtcbiAgICAvKipcbiAgICAgKiBUaGUgbmVnYXRpdmUgbG9va2JlaGluZCBoZXJlIGFuZCBpbiB0aGUgYHJlYCBSZWdFeHAgaXMgdG9cbiAgICAgKiBwcmV2ZW50IGNhdXNpbmcgYSBwb2x5bm9taWFsIHNlYXJjaCB0aW1lIGluIGNlcnRhaW4gY2FzZXMuXG4gICAgICpcbiAgICAgKiBUaGUgdHJ5LWNhdGNoIGlzIGZvciBTYWZhcmksIHdoaWNoIGRvZXNuJ3Qgc3VwcG9ydCB0aGlzIHlldDpcbiAgICAgKiBodHRwczovL2Nhbml1c2UuY29tL2pzLXJlZ2V4cC1sb29rYmVoaW5kXG4gICAgICovXG4gICAgbGV0IGZpcnN0LCBsaW5lO1xuICAgIHRyeSB7XG4gICAgICAgIGZpcnN0ID0gbmV3IFJlZ0V4cCgnKC4qPykoPzwhWyBcXHRdKVsgXFx0XSpcXHI/XFxuJywgJ3N5Jyk7XG4gICAgICAgIGxpbmUgPSBuZXcgUmVnRXhwKCdbIFxcdF0qKC4qPykoPzooPzwhWyBcXHRdKVsgXFx0XSopP1xccj9cXG4nLCAnc3knKTtcbiAgICB9XG4gICAgY2F0Y2ggKF8pIHtcbiAgICAgICAgZmlyc3QgPSAvKC4qPylbIFxcdF0qXFxyP1xcbi9zeTtcbiAgICAgICAgbGluZSA9IC9bIFxcdF0qKC4qPylbIFxcdF0qXFxyP1xcbi9zeTtcbiAgICB9XG4gICAgbGV0IG1hdGNoID0gZmlyc3QuZXhlYyhzb3VyY2UpO1xuICAgIGlmICghbWF0Y2gpXG4gICAgICAgIHJldHVybiBzb3VyY2U7XG4gICAgbGV0IHJlcyA9IG1hdGNoWzFdO1xuICAgIGxldCBzZXAgPSAnICc7XG4gICAgbGV0IHBvcyA9IGZpcnN0Lmxhc3RJbmRleDtcbiAgICBsaW5lLmxhc3RJbmRleCA9IHBvcztcbiAgICB3aGlsZSAoKG1hdGNoID0gbGluZS5leGVjKHNvdXJjZSkpKSB7XG4gICAgICAgIGlmIChtYXRjaFsxXSA9PT0gJycpIHtcbiAgICAgICAgICAgIGlmIChzZXAgPT09ICdcXG4nKVxuICAgICAgICAgICAgICAgIHJlcyArPSBzZXA7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgc2VwID0gJ1xcbic7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXMgKz0gc2VwICsgbWF0Y2hbMV07XG4gICAgICAgICAgICBzZXAgPSAnICc7XG4gICAgICAgIH1cbiAgICAgICAgcG9zID0gbGluZS5sYXN0SW5kZXg7XG4gICAgfVxuICAgIGNvbnN0IGxhc3QgPSAvWyBcXHRdKiguKikvc3k7XG4gICAgbGFzdC5sYXN0SW5kZXggPSBwb3M7XG4gICAgbWF0Y2ggPSBsYXN0LmV4ZWMoc291cmNlKTtcbiAgICByZXR1cm4gcmVzICsgc2VwICsgKChtYXRjaCAmJiBtYXRjaFsxXSkgfHwgJycpO1xufVxuZnVuY3Rpb24gZG91YmxlUXVvdGVkVmFsdWUoc291cmNlLCBvbkVycm9yKSB7XG4gICAgbGV0IHJlcyA9ICcnO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgc291cmNlLmxlbmd0aCAtIDE7ICsraSkge1xuICAgICAgICBjb25zdCBjaCA9IHNvdXJjZVtpXTtcbiAgICAgICAgaWYgKGNoID09PSAnXFxyJyAmJiBzb3VyY2VbaSArIDFdID09PSAnXFxuJylcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBpZiAoY2ggPT09ICdcXG4nKSB7XG4gICAgICAgICAgICBjb25zdCB7IGZvbGQsIG9mZnNldCB9ID0gZm9sZE5ld2xpbmUoc291cmNlLCBpKTtcbiAgICAgICAgICAgIHJlcyArPSBmb2xkO1xuICAgICAgICAgICAgaSA9IG9mZnNldDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjaCA9PT0gJ1xcXFwnKSB7XG4gICAgICAgICAgICBsZXQgbmV4dCA9IHNvdXJjZVsrK2ldO1xuICAgICAgICAgICAgY29uc3QgY2MgPSBlc2NhcGVDb2Rlc1tuZXh0XTtcbiAgICAgICAgICAgIGlmIChjYylcbiAgICAgICAgICAgICAgICByZXMgKz0gY2M7XG4gICAgICAgICAgICBlbHNlIGlmIChuZXh0ID09PSAnXFxuJykge1xuICAgICAgICAgICAgICAgIC8vIHNraXAgZXNjYXBlZCBuZXdsaW5lcywgYnV0IHN0aWxsIHRyaW0gdGhlIGZvbGxvd2luZyBsaW5lXG4gICAgICAgICAgICAgICAgbmV4dCA9IHNvdXJjZVtpICsgMV07XG4gICAgICAgICAgICAgICAgd2hpbGUgKG5leHQgPT09ICcgJyB8fCBuZXh0ID09PSAnXFx0JylcbiAgICAgICAgICAgICAgICAgICAgbmV4dCA9IHNvdXJjZVsrK2kgKyAxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG5leHQgPT09ICdcXHInICYmIHNvdXJjZVtpICsgMV0gPT09ICdcXG4nKSB7XG4gICAgICAgICAgICAgICAgLy8gc2tpcCBlc2NhcGVkIENSTEYgbmV3bGluZXMsIGJ1dCBzdGlsbCB0cmltIHRoZSBmb2xsb3dpbmcgbGluZVxuICAgICAgICAgICAgICAgIG5leHQgPSBzb3VyY2VbKytpICsgMV07XG4gICAgICAgICAgICAgICAgd2hpbGUgKG5leHQgPT09ICcgJyB8fCBuZXh0ID09PSAnXFx0JylcbiAgICAgICAgICAgICAgICAgICAgbmV4dCA9IHNvdXJjZVsrK2kgKyAxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG5leHQgPT09ICd4JyB8fCBuZXh0ID09PSAndScgfHwgbmV4dCA9PT0gJ1UnKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0geyB4OiAyLCB1OiA0LCBVOiA4IH1bbmV4dF07XG4gICAgICAgICAgICAgICAgcmVzICs9IHBhcnNlQ2hhckNvZGUoc291cmNlLCBpICsgMSwgbGVuZ3RoLCBvbkVycm9yKTtcbiAgICAgICAgICAgICAgICBpICs9IGxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJhdyA9IHNvdXJjZS5zdWJzdHIoaSAtIDEsIDIpO1xuICAgICAgICAgICAgICAgIG9uRXJyb3IoaSAtIDEsICdCQURfRFFfRVNDQVBFJywgYEludmFsaWQgZXNjYXBlIHNlcXVlbmNlICR7cmF3fWApO1xuICAgICAgICAgICAgICAgIHJlcyArPSByYXc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2ggPT09ICcgJyB8fCBjaCA9PT0gJ1xcdCcpIHtcbiAgICAgICAgICAgIC8vIHRyaW0gdHJhaWxpbmcgd2hpdGVzcGFjZVxuICAgICAgICAgICAgY29uc3Qgd3NTdGFydCA9IGk7XG4gICAgICAgICAgICBsZXQgbmV4dCA9IHNvdXJjZVtpICsgMV07XG4gICAgICAgICAgICB3aGlsZSAobmV4dCA9PT0gJyAnIHx8IG5leHQgPT09ICdcXHQnKVxuICAgICAgICAgICAgICAgIG5leHQgPSBzb3VyY2VbKytpICsgMV07XG4gICAgICAgICAgICBpZiAobmV4dCAhPT0gJ1xcbicgJiYgIShuZXh0ID09PSAnXFxyJyAmJiBzb3VyY2VbaSArIDJdID09PSAnXFxuJykpXG4gICAgICAgICAgICAgICAgcmVzICs9IGkgPiB3c1N0YXJ0ID8gc291cmNlLnNsaWNlKHdzU3RhcnQsIGkgKyAxKSA6IGNoO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzICs9IGNoO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChzb3VyY2Vbc291cmNlLmxlbmd0aCAtIDFdICE9PSAnXCInIHx8IHNvdXJjZS5sZW5ndGggPT09IDEpXG4gICAgICAgIG9uRXJyb3Ioc291cmNlLmxlbmd0aCwgJ01JU1NJTkdfQ0hBUicsICdNaXNzaW5nIGNsb3NpbmcgXCJxdW90ZScpO1xuICAgIHJldHVybiByZXM7XG59XG4vKipcbiAqIEZvbGQgYSBzaW5nbGUgbmV3bGluZSBpbnRvIGEgc3BhY2UsIG11bHRpcGxlIG5ld2xpbmVzIHRvIE4gLSAxIG5ld2xpbmVzLlxuICogUHJlc3VtZXMgYHNvdXJjZVtvZmZzZXRdID09PSAnXFxuJ2BcbiAqL1xuZnVuY3Rpb24gZm9sZE5ld2xpbmUoc291cmNlLCBvZmZzZXQpIHtcbiAgICBsZXQgZm9sZCA9ICcnO1xuICAgIGxldCBjaCA9IHNvdXJjZVtvZmZzZXQgKyAxXTtcbiAgICB3aGlsZSAoY2ggPT09ICcgJyB8fCBjaCA9PT0gJ1xcdCcgfHwgY2ggPT09ICdcXG4nIHx8IGNoID09PSAnXFxyJykge1xuICAgICAgICBpZiAoY2ggPT09ICdcXHInICYmIHNvdXJjZVtvZmZzZXQgKyAyXSAhPT0gJ1xcbicpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgaWYgKGNoID09PSAnXFxuJylcbiAgICAgICAgICAgIGZvbGQgKz0gJ1xcbic7XG4gICAgICAgIG9mZnNldCArPSAxO1xuICAgICAgICBjaCA9IHNvdXJjZVtvZmZzZXQgKyAxXTtcbiAgICB9XG4gICAgaWYgKCFmb2xkKVxuICAgICAgICBmb2xkID0gJyAnO1xuICAgIHJldHVybiB7IGZvbGQsIG9mZnNldCB9O1xufVxuY29uc3QgZXNjYXBlQ29kZXMgPSB7XG4gICAgJzAnOiAnXFwwJyxcbiAgICBhOiAnXFx4MDcnLFxuICAgIGI6ICdcXGInLFxuICAgIGU6ICdcXHgxYicsXG4gICAgZjogJ1xcZicsXG4gICAgbjogJ1xcbicsXG4gICAgcjogJ1xccicsXG4gICAgdDogJ1xcdCcsXG4gICAgdjogJ1xcdicsXG4gICAgTjogJ1xcdTAwODUnLFxuICAgIF86ICdcXHUwMGEwJyxcbiAgICBMOiAnXFx1MjAyOCcsXG4gICAgUDogJ1xcdTIwMjknLFxuICAgICcgJzogJyAnLFxuICAgICdcIic6ICdcIicsXG4gICAgJy8nOiAnLycsXG4gICAgJ1xcXFwnOiAnXFxcXCcsXG4gICAgJ1xcdCc6ICdcXHQnXG59O1xuZnVuY3Rpb24gcGFyc2VDaGFyQ29kZShzb3VyY2UsIG9mZnNldCwgbGVuZ3RoLCBvbkVycm9yKSB7XG4gICAgY29uc3QgY2MgPSBzb3VyY2Uuc3Vic3RyKG9mZnNldCwgbGVuZ3RoKTtcbiAgICBjb25zdCBvayA9IGNjLmxlbmd0aCA9PT0gbGVuZ3RoICYmIC9eWzAtOWEtZkEtRl0rJC8udGVzdChjYyk7XG4gICAgY29uc3QgY29kZSA9IG9rID8gcGFyc2VJbnQoY2MsIDE2KSA6IE5hTjtcbiAgICBpZiAoaXNOYU4oY29kZSkpIHtcbiAgICAgICAgY29uc3QgcmF3ID0gc291cmNlLnN1YnN0cihvZmZzZXQgLSAyLCBsZW5ndGggKyAyKTtcbiAgICAgICAgb25FcnJvcihvZmZzZXQgLSAyLCAnQkFEX0RRX0VTQ0FQRScsIGBJbnZhbGlkIGVzY2FwZSBzZXF1ZW5jZSAke3Jhd31gKTtcbiAgICAgICAgcmV0dXJuIHJhdztcbiAgICB9XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ29kZVBvaW50KGNvZGUpO1xufVxuXG5leHBvcnQgeyByZXNvbHZlRmxvd1NjYWxhciB9O1xuIiwgImltcG9ydCB7IFNDQUxBUiwgaXNTY2FsYXIgfSBmcm9tICcuLi9ub2Rlcy9Ob2RlLmpzJztcbmltcG9ydCB7IFNjYWxhciB9IGZyb20gJy4uL25vZGVzL1NjYWxhci5qcyc7XG5pbXBvcnQgeyByZXNvbHZlQmxvY2tTY2FsYXIgfSBmcm9tICcuL3Jlc29sdmUtYmxvY2stc2NhbGFyLmpzJztcbmltcG9ydCB7IHJlc29sdmVGbG93U2NhbGFyIH0gZnJvbSAnLi9yZXNvbHZlLWZsb3ctc2NhbGFyLmpzJztcblxuZnVuY3Rpb24gY29tcG9zZVNjYWxhcihjdHgsIHRva2VuLCB0YWdUb2tlbiwgb25FcnJvcikge1xuICAgIGNvbnN0IHsgdmFsdWUsIHR5cGUsIGNvbW1lbnQsIHJhbmdlIH0gPSB0b2tlbi50eXBlID09PSAnYmxvY2stc2NhbGFyJ1xuICAgICAgICA/IHJlc29sdmVCbG9ja1NjYWxhcih0b2tlbiwgY3R4Lm9wdGlvbnMuc3RyaWN0LCBvbkVycm9yKVxuICAgICAgICA6IHJlc29sdmVGbG93U2NhbGFyKHRva2VuLCBjdHgub3B0aW9ucy5zdHJpY3QsIG9uRXJyb3IpO1xuICAgIGNvbnN0IHRhZ05hbWUgPSB0YWdUb2tlblxuICAgICAgICA/IGN0eC5kaXJlY3RpdmVzLnRhZ05hbWUodGFnVG9rZW4uc291cmNlLCBtc2cgPT4gb25FcnJvcih0YWdUb2tlbiwgJ1RBR19SRVNPTFZFX0ZBSUxFRCcsIG1zZykpXG4gICAgICAgIDogbnVsbDtcbiAgICBjb25zdCB0YWcgPSB0YWdUb2tlbiAmJiB0YWdOYW1lXG4gICAgICAgID8gZmluZFNjYWxhclRhZ0J5TmFtZShjdHguc2NoZW1hLCB2YWx1ZSwgdGFnTmFtZSwgdGFnVG9rZW4sIG9uRXJyb3IpXG4gICAgICAgIDogdG9rZW4udHlwZSA9PT0gJ3NjYWxhcidcbiAgICAgICAgICAgID8gZmluZFNjYWxhclRhZ0J5VGVzdChjdHgsIHZhbHVlLCB0b2tlbiwgb25FcnJvcilcbiAgICAgICAgICAgIDogY3R4LnNjaGVtYVtTQ0FMQVJdO1xuICAgIGxldCBzY2FsYXI7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzID0gdGFnLnJlc29sdmUodmFsdWUsIG1zZyA9PiBvbkVycm9yKHRhZ1Rva2VuIHx8IHRva2VuLCAnVEFHX1JFU09MVkVfRkFJTEVEJywgbXNnKSwgY3R4Lm9wdGlvbnMpO1xuICAgICAgICBzY2FsYXIgPSBpc1NjYWxhcihyZXMpID8gcmVzIDogbmV3IFNjYWxhcihyZXMpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc3QgbXNnID0gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpO1xuICAgICAgICBvbkVycm9yKHRhZ1Rva2VuIHx8IHRva2VuLCAnVEFHX1JFU09MVkVfRkFJTEVEJywgbXNnKTtcbiAgICAgICAgc2NhbGFyID0gbmV3IFNjYWxhcih2YWx1ZSk7XG4gICAgfVxuICAgIHNjYWxhci5yYW5nZSA9IHJhbmdlO1xuICAgIHNjYWxhci5zb3VyY2UgPSB2YWx1ZTtcbiAgICBpZiAodHlwZSlcbiAgICAgICAgc2NhbGFyLnR5cGUgPSB0eXBlO1xuICAgIGlmICh0YWdOYW1lKVxuICAgICAgICBzY2FsYXIudGFnID0gdGFnTmFtZTtcbiAgICBpZiAodGFnLmZvcm1hdClcbiAgICAgICAgc2NhbGFyLmZvcm1hdCA9IHRhZy5mb3JtYXQ7XG4gICAgaWYgKGNvbW1lbnQpXG4gICAgICAgIHNjYWxhci5jb21tZW50ID0gY29tbWVudDtcbiAgICByZXR1cm4gc2NhbGFyO1xufVxuZnVuY3Rpb24gZmluZFNjYWxhclRhZ0J5TmFtZShzY2hlbWEsIHZhbHVlLCB0YWdOYW1lLCB0YWdUb2tlbiwgb25FcnJvcikge1xuICAgIHZhciBfYTtcbiAgICBpZiAodGFnTmFtZSA9PT0gJyEnKVxuICAgICAgICByZXR1cm4gc2NoZW1hW1NDQUxBUl07IC8vIG5vbi1zcGVjaWZpYyB0YWdcbiAgICBjb25zdCBtYXRjaFdpdGhUZXN0ID0gW107XG4gICAgZm9yIChjb25zdCB0YWcgb2Ygc2NoZW1hLnRhZ3MpIHtcbiAgICAgICAgaWYgKCF0YWcuY29sbGVjdGlvbiAmJiB0YWcudGFnID09PSB0YWdOYW1lKSB7XG4gICAgICAgICAgICBpZiAodGFnLmRlZmF1bHQgJiYgdGFnLnRlc3QpXG4gICAgICAgICAgICAgICAgbWF0Y2hXaXRoVGVzdC5wdXNoKHRhZyk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhZztcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IHRhZyBvZiBtYXRjaFdpdGhUZXN0KVxuICAgICAgICBpZiAoKF9hID0gdGFnLnRlc3QpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50ZXN0KHZhbHVlKSlcbiAgICAgICAgICAgIHJldHVybiB0YWc7XG4gICAgY29uc3Qga3QgPSBzY2hlbWEua25vd25UYWdzW3RhZ05hbWVdO1xuICAgIGlmIChrdCAmJiAha3QuY29sbGVjdGlvbikge1xuICAgICAgICAvLyBFbnN1cmUgdGhhdCB0aGUga25vd24gdGFnIGlzIGF2YWlsYWJsZSBmb3Igc3RyaW5naWZ5aW5nLFxuICAgICAgICAvLyBidXQgZG9lcyBub3QgZ2V0IHVzZWQgYnkgZGVmYXVsdC5cbiAgICAgICAgc2NoZW1hLnRhZ3MucHVzaChPYmplY3QuYXNzaWduKHt9LCBrdCwgeyBkZWZhdWx0OiBmYWxzZSwgdGVzdDogdW5kZWZpbmVkIH0pKTtcbiAgICAgICAgcmV0dXJuIGt0O1xuICAgIH1cbiAgICBvbkVycm9yKHRhZ1Rva2VuLCAnVEFHX1JFU09MVkVfRkFJTEVEJywgYFVucmVzb2x2ZWQgdGFnOiAke3RhZ05hbWV9YCwgdGFnTmFtZSAhPT0gJ3RhZzp5YW1sLm9yZywyMDAyOnN0cicpO1xuICAgIHJldHVybiBzY2hlbWFbU0NBTEFSXTtcbn1cbmZ1bmN0aW9uIGZpbmRTY2FsYXJUYWdCeVRlc3QoeyBkaXJlY3RpdmVzLCBzY2hlbWEgfSwgdmFsdWUsIHRva2VuLCBvbkVycm9yKSB7XG4gICAgY29uc3QgdGFnID0gc2NoZW1hLnRhZ3MuZmluZCh0YWcgPT4geyB2YXIgX2E7IHJldHVybiB0YWcuZGVmYXVsdCAmJiAoKF9hID0gdGFnLnRlc3QpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50ZXN0KHZhbHVlKSk7IH0pIHx8IHNjaGVtYVtTQ0FMQVJdO1xuICAgIGlmIChzY2hlbWEuY29tcGF0KSB7XG4gICAgICAgIGNvbnN0IGNvbXBhdCA9IHNjaGVtYS5jb21wYXQuZmluZCh0YWcgPT4geyB2YXIgX2E7IHJldHVybiB0YWcuZGVmYXVsdCAmJiAoKF9hID0gdGFnLnRlc3QpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50ZXN0KHZhbHVlKSk7IH0pIHx8XG4gICAgICAgICAgICBzY2hlbWFbU0NBTEFSXTtcbiAgICAgICAgaWYgKHRhZy50YWcgIT09IGNvbXBhdC50YWcpIHtcbiAgICAgICAgICAgIGNvbnN0IHRzID0gZGlyZWN0aXZlcy50YWdTdHJpbmcodGFnLnRhZyk7XG4gICAgICAgICAgICBjb25zdCBjcyA9IGRpcmVjdGl2ZXMudGFnU3RyaW5nKGNvbXBhdC50YWcpO1xuICAgICAgICAgICAgY29uc3QgbXNnID0gYFZhbHVlIG1heSBiZSBwYXJzZWQgYXMgZWl0aGVyICR7dHN9IG9yICR7Y3N9YDtcbiAgICAgICAgICAgIG9uRXJyb3IodG9rZW4sICdUQUdfUkVTT0xWRV9GQUlMRUQnLCBtc2csIHRydWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0YWc7XG59XG5cbmV4cG9ydCB7IGNvbXBvc2VTY2FsYXIgfTtcbiIsICJmdW5jdGlvbiBlbXB0eVNjYWxhclBvc2l0aW9uKG9mZnNldCwgYmVmb3JlLCBwb3MpIHtcbiAgICBpZiAoYmVmb3JlKSB7XG4gICAgICAgIGlmIChwb3MgPT09IG51bGwpXG4gICAgICAgICAgICBwb3MgPSBiZWZvcmUubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBpID0gcG9zIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgICAgIGxldCBzdCA9IGJlZm9yZVtpXTtcbiAgICAgICAgICAgIHN3aXRjaCAoc3QudHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3NwYWNlJzpcbiAgICAgICAgICAgICAgICBjYXNlICdjb21tZW50JzpcbiAgICAgICAgICAgICAgICBjYXNlICduZXdsaW5lJzpcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0IC09IHN0LnNvdXJjZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVGVjaG5pY2FsbHksIGFuIGVtcHR5IHNjYWxhciBpcyBpbW1lZGlhdGVseSBhZnRlciB0aGUgbGFzdCBub24tZW1wdHlcbiAgICAgICAgICAgIC8vIG5vZGUsIGJ1dCBpdCdzIG1vcmUgdXNlZnVsIHRvIHBsYWNlIGl0IGFmdGVyIGFueSB3aGl0ZXNwYWNlLlxuICAgICAgICAgICAgc3QgPSBiZWZvcmVbKytpXTtcbiAgICAgICAgICAgIHdoaWxlICgoc3QgPT09IG51bGwgfHwgc3QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHN0LnR5cGUpID09PSAnc3BhY2UnKSB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ICs9IHN0LnNvdXJjZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgc3QgPSBiZWZvcmVbKytpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvZmZzZXQ7XG59XG5cbmV4cG9ydCB7IGVtcHR5U2NhbGFyUG9zaXRpb24gfTtcbiIsICJpbXBvcnQgeyBBbGlhcyB9IGZyb20gJy4uL25vZGVzL0FsaWFzLmpzJztcbmltcG9ydCB7IGNvbXBvc2VDb2xsZWN0aW9uIH0gZnJvbSAnLi9jb21wb3NlLWNvbGxlY3Rpb24uanMnO1xuaW1wb3J0IHsgY29tcG9zZVNjYWxhciB9IGZyb20gJy4vY29tcG9zZS1zY2FsYXIuanMnO1xuaW1wb3J0IHsgcmVzb2x2ZUVuZCB9IGZyb20gJy4vcmVzb2x2ZS1lbmQuanMnO1xuaW1wb3J0IHsgZW1wdHlTY2FsYXJQb3NpdGlvbiB9IGZyb20gJy4vdXRpbC1lbXB0eS1zY2FsYXItcG9zaXRpb24uanMnO1xuXG5jb25zdCBDTiA9IHsgY29tcG9zZU5vZGUsIGNvbXBvc2VFbXB0eU5vZGUgfTtcbmZ1bmN0aW9uIGNvbXBvc2VOb2RlKGN0eCwgdG9rZW4sIHByb3BzLCBvbkVycm9yKSB7XG4gICAgY29uc3QgeyBzcGFjZUJlZm9yZSwgY29tbWVudCwgYW5jaG9yLCB0YWcgfSA9IHByb3BzO1xuICAgIGxldCBub2RlO1xuICAgIHN3aXRjaCAodG9rZW4udHlwZSkge1xuICAgICAgICBjYXNlICdhbGlhcyc6XG4gICAgICAgICAgICBub2RlID0gY29tcG9zZUFsaWFzKGN0eCwgdG9rZW4sIG9uRXJyb3IpO1xuICAgICAgICAgICAgaWYgKGFuY2hvciB8fCB0YWcpXG4gICAgICAgICAgICAgICAgb25FcnJvcih0b2tlbiwgJ0FMSUFTX1BST1BTJywgJ0FuIGFsaWFzIG5vZGUgbXVzdCBub3Qgc3BlY2lmeSBhbnkgcHJvcGVydGllcycpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3NjYWxhcic6XG4gICAgICAgIGNhc2UgJ3NpbmdsZS1xdW90ZWQtc2NhbGFyJzpcbiAgICAgICAgY2FzZSAnZG91YmxlLXF1b3RlZC1zY2FsYXInOlxuICAgICAgICBjYXNlICdibG9jay1zY2FsYXInOlxuICAgICAgICAgICAgbm9kZSA9IGNvbXBvc2VTY2FsYXIoY3R4LCB0b2tlbiwgdGFnLCBvbkVycm9yKTtcbiAgICAgICAgICAgIGlmIChhbmNob3IpXG4gICAgICAgICAgICAgICAgbm9kZS5hbmNob3IgPSBhbmNob3Iuc291cmNlLnN1YnN0cmluZygxKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdibG9jay1tYXAnOlxuICAgICAgICBjYXNlICdibG9jay1zZXEnOlxuICAgICAgICBjYXNlICdmbG93LWNvbGxlY3Rpb24nOlxuICAgICAgICAgICAgbm9kZSA9IGNvbXBvc2VDb2xsZWN0aW9uKENOLCBjdHgsIHRva2VuLCB0YWcsIG9uRXJyb3IpO1xuICAgICAgICAgICAgaWYgKGFuY2hvcilcbiAgICAgICAgICAgICAgICBub2RlLmFuY2hvciA9IGFuY2hvci5zb3VyY2Uuc3Vic3RyaW5nKDEpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBjb25zb2xlLmxvZyh0b2tlbik7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVuIHRva2VuIHR5cGU6ICR7dG9rZW4udHlwZX1gKTtcbiAgICB9XG4gICAgaWYgKGFuY2hvciAmJiBub2RlLmFuY2hvciA9PT0gJycpXG4gICAgICAgIG9uRXJyb3IoYW5jaG9yLCAnQkFEX0FMSUFTJywgJ0FuY2hvciBjYW5ub3QgYmUgYW4gZW1wdHkgc3RyaW5nJyk7XG4gICAgaWYgKHNwYWNlQmVmb3JlKVxuICAgICAgICBub2RlLnNwYWNlQmVmb3JlID0gdHJ1ZTtcbiAgICBpZiAoY29tbWVudCkge1xuICAgICAgICBpZiAodG9rZW4udHlwZSA9PT0gJ3NjYWxhcicgJiYgdG9rZW4uc291cmNlID09PSAnJylcbiAgICAgICAgICAgIG5vZGUuY29tbWVudCA9IGNvbW1lbnQ7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIG5vZGUuY29tbWVudEJlZm9yZSA9IGNvbW1lbnQ7XG4gICAgfVxuICAgIGlmIChjdHgub3B0aW9ucy5rZWVwU291cmNlVG9rZW5zKVxuICAgICAgICBub2RlLnNyY1Rva2VuID0gdG9rZW47XG4gICAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiBjb21wb3NlRW1wdHlOb2RlKGN0eCwgb2Zmc2V0LCBiZWZvcmUsIHBvcywgeyBzcGFjZUJlZm9yZSwgY29tbWVudCwgYW5jaG9yLCB0YWcgfSwgb25FcnJvcikge1xuICAgIGNvbnN0IHRva2VuID0ge1xuICAgICAgICB0eXBlOiAnc2NhbGFyJyxcbiAgICAgICAgb2Zmc2V0OiBlbXB0eVNjYWxhclBvc2l0aW9uKG9mZnNldCwgYmVmb3JlLCBwb3MpLFxuICAgICAgICBpbmRlbnQ6IC0xLFxuICAgICAgICBzb3VyY2U6ICcnXG4gICAgfTtcbiAgICBjb25zdCBub2RlID0gY29tcG9zZVNjYWxhcihjdHgsIHRva2VuLCB0YWcsIG9uRXJyb3IpO1xuICAgIGlmIChhbmNob3IpIHtcbiAgICAgICAgbm9kZS5hbmNob3IgPSBhbmNob3Iuc291cmNlLnN1YnN0cmluZygxKTtcbiAgICAgICAgaWYgKG5vZGUuYW5jaG9yID09PSAnJylcbiAgICAgICAgICAgIG9uRXJyb3IoYW5jaG9yLCAnQkFEX0FMSUFTJywgJ0FuY2hvciBjYW5ub3QgYmUgYW4gZW1wdHkgc3RyaW5nJyk7XG4gICAgfVxuICAgIGlmIChzcGFjZUJlZm9yZSlcbiAgICAgICAgbm9kZS5zcGFjZUJlZm9yZSA9IHRydWU7XG4gICAgaWYgKGNvbW1lbnQpXG4gICAgICAgIG5vZGUuY29tbWVudCA9IGNvbW1lbnQ7XG4gICAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiBjb21wb3NlQWxpYXMoeyBvcHRpb25zIH0sIHsgb2Zmc2V0LCBzb3VyY2UsIGVuZCB9LCBvbkVycm9yKSB7XG4gICAgY29uc3QgYWxpYXMgPSBuZXcgQWxpYXMoc291cmNlLnN1YnN0cmluZygxKSk7XG4gICAgaWYgKGFsaWFzLnNvdXJjZSA9PT0gJycpXG4gICAgICAgIG9uRXJyb3Iob2Zmc2V0LCAnQkFEX0FMSUFTJywgJ0FsaWFzIGNhbm5vdCBiZSBhbiBlbXB0eSBzdHJpbmcnKTtcbiAgICBjb25zdCB2YWx1ZUVuZCA9IG9mZnNldCArIHNvdXJjZS5sZW5ndGg7XG4gICAgY29uc3QgcmUgPSByZXNvbHZlRW5kKGVuZCwgdmFsdWVFbmQsIG9wdGlvbnMuc3RyaWN0LCBvbkVycm9yKTtcbiAgICBhbGlhcy5yYW5nZSA9IFtvZmZzZXQsIHZhbHVlRW5kLCByZS5vZmZzZXRdO1xuICAgIGlmIChyZS5jb21tZW50KVxuICAgICAgICBhbGlhcy5jb21tZW50ID0gcmUuY29tbWVudDtcbiAgICByZXR1cm4gYWxpYXM7XG59XG5cbmV4cG9ydCB7IGNvbXBvc2VFbXB0eU5vZGUsIGNvbXBvc2VOb2RlIH07XG4iLCAiaW1wb3J0IHsgRG9jdW1lbnQgfSBmcm9tICcuLi9kb2MvRG9jdW1lbnQuanMnO1xuaW1wb3J0IHsgY29tcG9zZU5vZGUsIGNvbXBvc2VFbXB0eU5vZGUgfSBmcm9tICcuL2NvbXBvc2Utbm9kZS5qcyc7XG5pbXBvcnQgeyByZXNvbHZlRW5kIH0gZnJvbSAnLi9yZXNvbHZlLWVuZC5qcyc7XG5pbXBvcnQgeyByZXNvbHZlUHJvcHMgfSBmcm9tICcuL3Jlc29sdmUtcHJvcHMuanMnO1xuXG5mdW5jdGlvbiBjb21wb3NlRG9jKG9wdGlvbnMsIGRpcmVjdGl2ZXMsIHsgb2Zmc2V0LCBzdGFydCwgdmFsdWUsIGVuZCB9LCBvbkVycm9yKSB7XG4gICAgY29uc3Qgb3B0cyA9IE9iamVjdC5hc3NpZ24oeyBkaXJlY3RpdmVzIH0sIG9wdGlvbnMpO1xuICAgIGNvbnN0IGRvYyA9IG5ldyBEb2N1bWVudCh1bmRlZmluZWQsIG9wdHMpO1xuICAgIGNvbnN0IGN0eCA9IHtcbiAgICAgICAgYXRSb290OiB0cnVlLFxuICAgICAgICBkaXJlY3RpdmVzOiBkb2MuZGlyZWN0aXZlcyxcbiAgICAgICAgb3B0aW9uczogZG9jLm9wdGlvbnMsXG4gICAgICAgIHNjaGVtYTogZG9jLnNjaGVtYVxuICAgIH07XG4gICAgY29uc3QgcHJvcHMgPSByZXNvbHZlUHJvcHMoc3RhcnQsIHtcbiAgICAgICAgaW5kaWNhdG9yOiAnZG9jLXN0YXJ0JyxcbiAgICAgICAgbmV4dDogdmFsdWUgfHwgKGVuZCA9PT0gbnVsbCB8fCBlbmQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVuZFswXSksXG4gICAgICAgIG9mZnNldCxcbiAgICAgICAgb25FcnJvcixcbiAgICAgICAgc3RhcnRPbk5ld2xpbmU6IHRydWVcbiAgICB9KTtcbiAgICBpZiAocHJvcHMuZm91bmQpIHtcbiAgICAgICAgZG9jLmRpcmVjdGl2ZXMubWFya2VyID0gdHJ1ZTtcbiAgICAgICAgaWYgKHZhbHVlICYmXG4gICAgICAgICAgICAodmFsdWUudHlwZSA9PT0gJ2Jsb2NrLW1hcCcgfHwgdmFsdWUudHlwZSA9PT0gJ2Jsb2NrLXNlcScpICYmXG4gICAgICAgICAgICAhcHJvcHMuaGFzTmV3bGluZSlcbiAgICAgICAgICAgIG9uRXJyb3IocHJvcHMuZW5kLCAnTUlTU0lOR19DSEFSJywgJ0Jsb2NrIGNvbGxlY3Rpb24gY2Fubm90IHN0YXJ0IG9uIHNhbWUgbGluZSB3aXRoIGRpcmVjdGl2ZXMtZW5kIG1hcmtlcicpO1xuICAgIH1cbiAgICBkb2MuY29udGVudHMgPSB2YWx1ZVxuICAgICAgICA/IGNvbXBvc2VOb2RlKGN0eCwgdmFsdWUsIHByb3BzLCBvbkVycm9yKVxuICAgICAgICA6IGNvbXBvc2VFbXB0eU5vZGUoY3R4LCBwcm9wcy5lbmQsIHN0YXJ0LCBudWxsLCBwcm9wcywgb25FcnJvcik7XG4gICAgY29uc3QgY29udGVudEVuZCA9IGRvYy5jb250ZW50cy5yYW5nZVsyXTtcbiAgICBjb25zdCByZSA9IHJlc29sdmVFbmQoZW5kLCBjb250ZW50RW5kLCBmYWxzZSwgb25FcnJvcik7XG4gICAgaWYgKHJlLmNvbW1lbnQpXG4gICAgICAgIGRvYy5jb21tZW50ID0gcmUuY29tbWVudDtcbiAgICBkb2MucmFuZ2UgPSBbb2Zmc2V0LCBjb250ZW50RW5kLCByZS5vZmZzZXRdO1xuICAgIHJldHVybiBkb2M7XG59XG5cbmV4cG9ydCB7IGNvbXBvc2VEb2MgfTtcbiIsICJpbXBvcnQgeyBEaXJlY3RpdmVzIH0gZnJvbSAnLi4vZG9jL2RpcmVjdGl2ZXMuanMnO1xuaW1wb3J0IHsgRG9jdW1lbnQgfSBmcm9tICcuLi9kb2MvRG9jdW1lbnQuanMnO1xuaW1wb3J0IHsgWUFNTFdhcm5pbmcsIFlBTUxQYXJzZUVycm9yIH0gZnJvbSAnLi4vZXJyb3JzLmpzJztcbmltcG9ydCB7IGlzQ29sbGVjdGlvbiwgaXNQYWlyIH0gZnJvbSAnLi4vbm9kZXMvTm9kZS5qcyc7XG5pbXBvcnQgeyBkZWZhdWx0T3B0aW9ucyB9IGZyb20gJy4uL29wdGlvbnMuanMnO1xuaW1wb3J0IHsgY29tcG9zZURvYyB9IGZyb20gJy4vY29tcG9zZS1kb2MuanMnO1xuaW1wb3J0IHsgcmVzb2x2ZUVuZCB9IGZyb20gJy4vcmVzb2x2ZS1lbmQuanMnO1xuXG5mdW5jdGlvbiBnZXRFcnJvclBvcyhzcmMpIHtcbiAgICBpZiAodHlwZW9mIHNyYyA9PT0gJ251bWJlcicpXG4gICAgICAgIHJldHVybiBbc3JjLCBzcmMgKyAxXTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShzcmMpKVxuICAgICAgICByZXR1cm4gc3JjLmxlbmd0aCA9PT0gMiA/IHNyYyA6IFtzcmNbMF0sIHNyY1sxXV07XG4gICAgY29uc3QgeyBvZmZzZXQsIHNvdXJjZSB9ID0gc3JjO1xuICAgIHJldHVybiBbb2Zmc2V0LCBvZmZzZXQgKyAodHlwZW9mIHNvdXJjZSA9PT0gJ3N0cmluZycgPyBzb3VyY2UubGVuZ3RoIDogMSldO1xufVxuZnVuY3Rpb24gcGFyc2VQcmVsdWRlKHByZWx1ZGUpIHtcbiAgICB2YXIgX2E7XG4gICAgbGV0IGNvbW1lbnQgPSAnJztcbiAgICBsZXQgYXRDb21tZW50ID0gZmFsc2U7XG4gICAgbGV0IGFmdGVyRW1wdHlMaW5lID0gZmFsc2U7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcmVsdWRlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IHNvdXJjZSA9IHByZWx1ZGVbaV07XG4gICAgICAgIHN3aXRjaCAoc291cmNlWzBdKSB7XG4gICAgICAgICAgICBjYXNlICcjJzpcbiAgICAgICAgICAgICAgICBjb21tZW50ICs9XG4gICAgICAgICAgICAgICAgICAgIChjb21tZW50ID09PSAnJyA/ICcnIDogYWZ0ZXJFbXB0eUxpbmUgPyAnXFxuXFxuJyA6ICdcXG4nKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAoc291cmNlLnN1YnN0cmluZygxKSB8fCAnICcpO1xuICAgICAgICAgICAgICAgIGF0Q29tbWVudCA9IHRydWU7XG4gICAgICAgICAgICAgICAgYWZ0ZXJFbXB0eUxpbmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJyUnOlxuICAgICAgICAgICAgICAgIGlmICgoKF9hID0gcHJlbHVkZVtpICsgMV0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVswXSkgIT09ICcjJylcbiAgICAgICAgICAgICAgICAgICAgaSArPSAxO1xuICAgICAgICAgICAgICAgIGF0Q29tbWVudCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAvLyBUaGlzIG1heSBiZSB3cm9uZyBhZnRlciBkb2MtZW5kLCBidXQgaW4gdGhhdCBjYXNlIGl0IGRvZXNuJ3QgbWF0dGVyXG4gICAgICAgICAgICAgICAgaWYgKCFhdENvbW1lbnQpXG4gICAgICAgICAgICAgICAgICAgIGFmdGVyRW1wdHlMaW5lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBhdENvbW1lbnQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBjb21tZW50LCBhZnRlckVtcHR5TGluZSB9O1xufVxuLyoqXG4gKiBDb21wb3NlIGEgc3RyZWFtIG9mIENTVCBub2RlcyBpbnRvIGEgc3RyZWFtIG9mIFlBTUwgRG9jdW1lbnRzLlxuICpcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBDb21wb3NlciwgUGFyc2VyIH0gZnJvbSAneWFtbCdcbiAqXG4gKiBjb25zdCBzcmM6IHN0cmluZyA9IC4uLlxuICogY29uc3QgdG9rZW5zID0gbmV3IFBhcnNlcigpLnBhcnNlKHNyYylcbiAqIGNvbnN0IGRvY3MgPSBuZXcgQ29tcG9zZXIoKS5jb21wb3NlKHRva2VucylcbiAqIGBgYFxuICovXG5jbGFzcyBDb21wb3NlciB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHRoaXMuZG9jID0gbnVsbDtcbiAgICAgICAgdGhpcy5hdERpcmVjdGl2ZXMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5wcmVsdWRlID0gW107XG4gICAgICAgIHRoaXMuZXJyb3JzID0gW107XG4gICAgICAgIHRoaXMud2FybmluZ3MgPSBbXTtcbiAgICAgICAgdGhpcy5vbkVycm9yID0gKHNvdXJjZSwgY29kZSwgbWVzc2FnZSwgd2FybmluZykgPT4ge1xuICAgICAgICAgICAgY29uc3QgcG9zID0gZ2V0RXJyb3JQb3Moc291cmNlKTtcbiAgICAgICAgICAgIGlmICh3YXJuaW5nKVxuICAgICAgICAgICAgICAgIHRoaXMud2FybmluZ3MucHVzaChuZXcgWUFNTFdhcm5pbmcocG9zLCBjb2RlLCBtZXNzYWdlKSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhpcy5lcnJvcnMucHVzaChuZXcgWUFNTFBhcnNlRXJyb3IocG9zLCBjb2RlLCBtZXNzYWdlKSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZGlyZWN0aXZlcyA9IG5ldyBEaXJlY3RpdmVzKHtcbiAgICAgICAgICAgIHZlcnNpb246IG9wdGlvbnMudmVyc2lvbiB8fCBkZWZhdWx0T3B0aW9ucy52ZXJzaW9uXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIH1cbiAgICBkZWNvcmF0ZShkb2MsIGFmdGVyRG9jKSB7XG4gICAgICAgIGNvbnN0IHsgY29tbWVudCwgYWZ0ZXJFbXB0eUxpbmUgfSA9IHBhcnNlUHJlbHVkZSh0aGlzLnByZWx1ZGUpO1xuICAgICAgICAvL2NvbnNvbGUubG9nKHsgZGM6IGRvYy5jb21tZW50LCBwcmVsdWRlLCBjb21tZW50IH0pXG4gICAgICAgIGlmIChjb21tZW50KSB7XG4gICAgICAgICAgICBjb25zdCBkYyA9IGRvYy5jb250ZW50cztcbiAgICAgICAgICAgIGlmIChhZnRlckRvYykge1xuICAgICAgICAgICAgICAgIGRvYy5jb21tZW50ID0gZG9jLmNvbW1lbnQgPyBgJHtkb2MuY29tbWVudH1cXG4ke2NvbW1lbnR9YCA6IGNvbW1lbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChhZnRlckVtcHR5TGluZSB8fCBkb2MuZGlyZWN0aXZlcy5tYXJrZXIgfHwgIWRjKSB7XG4gICAgICAgICAgICAgICAgZG9jLmNvbW1lbnRCZWZvcmUgPSBjb21tZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNDb2xsZWN0aW9uKGRjKSAmJiAhZGMuZmxvdyAmJiBkYy5pdGVtcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgbGV0IGl0ID0gZGMuaXRlbXNbMF07XG4gICAgICAgICAgICAgICAgaWYgKGlzUGFpcihpdCkpXG4gICAgICAgICAgICAgICAgICAgIGl0ID0gaXQua2V5O1xuICAgICAgICAgICAgICAgIGNvbnN0IGNiID0gaXQuY29tbWVudEJlZm9yZTtcbiAgICAgICAgICAgICAgICBpdC5jb21tZW50QmVmb3JlID0gY2IgPyBgJHtjb21tZW50fVxcbiR7Y2J9YCA6IGNvbW1lbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjYiA9IGRjLmNvbW1lbnRCZWZvcmU7XG4gICAgICAgICAgICAgICAgZGMuY29tbWVudEJlZm9yZSA9IGNiID8gYCR7Y29tbWVudH1cXG4ke2NifWAgOiBjb21tZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChhZnRlckRvYykge1xuICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkoZG9jLmVycm9ycywgdGhpcy5lcnJvcnMpO1xuICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkoZG9jLndhcm5pbmdzLCB0aGlzLndhcm5pbmdzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRvYy5lcnJvcnMgPSB0aGlzLmVycm9ycztcbiAgICAgICAgICAgIGRvYy53YXJuaW5ncyA9IHRoaXMud2FybmluZ3M7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wcmVsdWRlID0gW107XG4gICAgICAgIHRoaXMuZXJyb3JzID0gW107XG4gICAgICAgIHRoaXMud2FybmluZ3MgPSBbXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3VycmVudCBzdHJlYW0gc3RhdHVzIGluZm9ybWF0aW9uLlxuICAgICAqXG4gICAgICogTW9zdGx5IHVzZWZ1bCBhdCB0aGUgZW5kIG9mIGlucHV0IGZvciBhbiBlbXB0eSBzdHJlYW0uXG4gICAgICovXG4gICAgc3RyZWFtSW5mbygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvbW1lbnQ6IHBhcnNlUHJlbHVkZSh0aGlzLnByZWx1ZGUpLmNvbW1lbnQsXG4gICAgICAgICAgICBkaXJlY3RpdmVzOiB0aGlzLmRpcmVjdGl2ZXMsXG4gICAgICAgICAgICBlcnJvcnM6IHRoaXMuZXJyb3JzLFxuICAgICAgICAgICAgd2FybmluZ3M6IHRoaXMud2FybmluZ3NcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29tcG9zZSB0b2tlbnMgaW50byBkb2N1bWVudHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZm9yY2VEb2MgLSBJZiB0aGUgc3RyZWFtIGNvbnRhaW5zIG5vIGRvY3VtZW50LCBzdGlsbCBlbWl0IGEgZmluYWwgZG9jdW1lbnQgaW5jbHVkaW5nIGFueSBjb21tZW50cyBhbmQgZGlyZWN0aXZlcyB0aGF0IHdvdWxkIGJlIGFwcGxpZWQgdG8gYSBzdWJzZXF1ZW50IGRvY3VtZW50LlxuICAgICAqIEBwYXJhbSBlbmRPZmZzZXQgLSBTaG91bGQgYmUgc2V0IGlmIGBmb3JjZURvY2AgaXMgYWxzbyBzZXQsIHRvIHNldCB0aGUgZG9jdW1lbnQgcmFuZ2UgZW5kIGFuZCB0byBpbmRpY2F0ZSBlcnJvcnMgY29ycmVjdGx5LlxuICAgICAqL1xuICAgICpjb21wb3NlKHRva2VucywgZm9yY2VEb2MgPSBmYWxzZSwgZW5kT2Zmc2V0ID0gLTEpIHtcbiAgICAgICAgZm9yIChjb25zdCB0b2tlbiBvZiB0b2tlbnMpXG4gICAgICAgICAgICB5aWVsZCogdGhpcy5uZXh0KHRva2VuKTtcbiAgICAgICAgeWllbGQqIHRoaXMuZW5kKGZvcmNlRG9jLCBlbmRPZmZzZXQpO1xuICAgIH1cbiAgICAvKiogQWR2YW5jZSB0aGUgY29tcG9zZXIgYnkgb25lIENTVCB0b2tlbi4gKi9cbiAgICAqbmV4dCh0b2tlbikge1xuICAgICAgICBzd2l0Y2ggKHRva2VuLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2RpcmVjdGl2ZSc6XG4gICAgICAgICAgICAgICAgdGhpcy5kaXJlY3RpdmVzLmFkZCh0b2tlbi5zb3VyY2UsIChvZmZzZXQsIG1lc3NhZ2UsIHdhcm5pbmcpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcG9zID0gZ2V0RXJyb3JQb3ModG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICBwb3NbMF0gKz0gb2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uRXJyb3IocG9zLCAnQkFEX0RJUkVDVElWRScsIG1lc3NhZ2UsIHdhcm5pbmcpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMucHJlbHVkZS5wdXNoKHRva2VuLnNvdXJjZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5hdERpcmVjdGl2ZXMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnZG9jdW1lbnQnOiB7XG4gICAgICAgICAgICAgICAgY29uc3QgZG9jID0gY29tcG9zZURvYyh0aGlzLm9wdGlvbnMsIHRoaXMuZGlyZWN0aXZlcywgdG9rZW4sIHRoaXMub25FcnJvcik7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYXREaXJlY3RpdmVzICYmICFkb2MuZGlyZWN0aXZlcy5tYXJrZXIpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25FcnJvcih0b2tlbiwgJ01JU1NJTkdfQ0hBUicsICdNaXNzaW5nIGRpcmVjdGl2ZXMtZW5kIGluZGljYXRvciBsaW5lJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWNvcmF0ZShkb2MsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5kb2MpXG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMuZG9jO1xuICAgICAgICAgICAgICAgIHRoaXMuZG9jID0gZG9jO1xuICAgICAgICAgICAgICAgIHRoaXMuYXREaXJlY3RpdmVzID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdieXRlLW9yZGVyLW1hcmsnOlxuICAgICAgICAgICAgY2FzZSAnc3BhY2UnOlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnY29tbWVudCc6XG4gICAgICAgICAgICBjYXNlICduZXdsaW5lJzpcbiAgICAgICAgICAgICAgICB0aGlzLnByZWx1ZGUucHVzaCh0b2tlbi5zb3VyY2UpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnZXJyb3InOiB7XG4gICAgICAgICAgICAgICAgY29uc3QgbXNnID0gdG9rZW4uc291cmNlXG4gICAgICAgICAgICAgICAgICAgID8gYCR7dG9rZW4ubWVzc2FnZX06ICR7SlNPTi5zdHJpbmdpZnkodG9rZW4uc291cmNlKX1gXG4gICAgICAgICAgICAgICAgICAgIDogdG9rZW4ubWVzc2FnZTtcbiAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBZQU1MUGFyc2VFcnJvcihnZXRFcnJvclBvcyh0b2tlbiksICdVTkVYUEVDVEVEX1RPS0VOJywgbXNnKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5hdERpcmVjdGl2ZXMgfHwgIXRoaXMuZG9jKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVycm9ycy5wdXNoKGVycm9yKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZG9jLmVycm9ycy5wdXNoKGVycm9yKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ2RvYy1lbmQnOiB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmRvYykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtc2cgPSAnVW5leHBlY3RlZCBkb2MtZW5kIHdpdGhvdXQgcHJlY2VkaW5nIGRvY3VtZW50JztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lcnJvcnMucHVzaChuZXcgWUFNTFBhcnNlRXJyb3IoZ2V0RXJyb3JQb3ModG9rZW4pLCAnVU5FWFBFQ1RFRF9UT0tFTicsIG1zZykpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgZW5kID0gcmVzb2x2ZUVuZCh0b2tlbi5lbmQsIHRva2VuLm9mZnNldCArIHRva2VuLnNvdXJjZS5sZW5ndGgsIHRoaXMuZG9jLm9wdGlvbnMuc3RyaWN0LCB0aGlzLm9uRXJyb3IpO1xuICAgICAgICAgICAgICAgIHRoaXMuZGVjb3JhdGUodGhpcy5kb2MsIHRydWUpO1xuICAgICAgICAgICAgICAgIGlmIChlbmQuY29tbWVudCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkYyA9IHRoaXMuZG9jLmNvbW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZG9jLmNvbW1lbnQgPSBkYyA/IGAke2RjfVxcbiR7ZW5kLmNvbW1lbnR9YCA6IGVuZC5jb21tZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmRvYy5yYW5nZVsyXSA9IGVuZC5vZmZzZXQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRoaXMuZXJyb3JzLnB1c2gobmV3IFlBTUxQYXJzZUVycm9yKGdldEVycm9yUG9zKHRva2VuKSwgJ1VORVhQRUNURURfVE9LRU4nLCBgVW5zdXBwb3J0ZWQgdG9rZW4gJHt0b2tlbi50eXBlfWApKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsIGF0IGVuZCBvZiBpbnB1dCB0byB5aWVsZCBhbnkgcmVtYWluaW5nIGRvY3VtZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIGZvcmNlRG9jIC0gSWYgdGhlIHN0cmVhbSBjb250YWlucyBubyBkb2N1bWVudCwgc3RpbGwgZW1pdCBhIGZpbmFsIGRvY3VtZW50IGluY2x1ZGluZyBhbnkgY29tbWVudHMgYW5kIGRpcmVjdGl2ZXMgdGhhdCB3b3VsZCBiZSBhcHBsaWVkIHRvIGEgc3Vic2VxdWVudCBkb2N1bWVudC5cbiAgICAgKiBAcGFyYW0gZW5kT2Zmc2V0IC0gU2hvdWxkIGJlIHNldCBpZiBgZm9yY2VEb2NgIGlzIGFsc28gc2V0LCB0byBzZXQgdGhlIGRvY3VtZW50IHJhbmdlIGVuZCBhbmQgdG8gaW5kaWNhdGUgZXJyb3JzIGNvcnJlY3RseS5cbiAgICAgKi9cbiAgICAqZW5kKGZvcmNlRG9jID0gZmFsc2UsIGVuZE9mZnNldCA9IC0xKSB7XG4gICAgICAgIGlmICh0aGlzLmRvYykge1xuICAgICAgICAgICAgdGhpcy5kZWNvcmF0ZSh0aGlzLmRvYywgdHJ1ZSk7XG4gICAgICAgICAgICB5aWVsZCB0aGlzLmRvYztcbiAgICAgICAgICAgIHRoaXMuZG9jID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChmb3JjZURvYykge1xuICAgICAgICAgICAgY29uc3Qgb3B0cyA9IE9iamVjdC5hc3NpZ24oeyBkaXJlY3RpdmVzOiB0aGlzLmRpcmVjdGl2ZXMgfSwgdGhpcy5vcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGRvYyA9IG5ldyBEb2N1bWVudCh1bmRlZmluZWQsIG9wdHMpO1xuICAgICAgICAgICAgaWYgKHRoaXMuYXREaXJlY3RpdmVzKVxuICAgICAgICAgICAgICAgIHRoaXMub25FcnJvcihlbmRPZmZzZXQsICdNSVNTSU5HX0NIQVInLCAnTWlzc2luZyBkaXJlY3RpdmVzLWVuZCBpbmRpY2F0b3IgbGluZScpO1xuICAgICAgICAgICAgZG9jLnJhbmdlID0gWzAsIGVuZE9mZnNldCwgZW5kT2Zmc2V0XTtcbiAgICAgICAgICAgIHRoaXMuZGVjb3JhdGUoZG9jLCBmYWxzZSk7XG4gICAgICAgICAgICB5aWVsZCBkb2M7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCB7IENvbXBvc2VyIH07XG4iLCAiZXhwb3J0IHsgY3JlYXRlU2NhbGFyVG9rZW4sIHJlc29sdmVBc1NjYWxhciwgc2V0U2NhbGFyVmFsdWUgfSBmcm9tICcuL2NzdC1zY2FsYXIuanMnO1xuZXhwb3J0IHsgc3RyaW5naWZ5IH0gZnJvbSAnLi9jc3Qtc3RyaW5naWZ5LmpzJztcbmV4cG9ydCB7IHZpc2l0IH0gZnJvbSAnLi9jc3QtdmlzaXQuanMnO1xuXG4vKiogVGhlIGJ5dGUgb3JkZXIgbWFyayAqL1xuY29uc3QgQk9NID0gJ1xcdXtGRUZGfSc7XG4vKiogU3RhcnQgb2YgZG9jLW1vZGUgKi9cbmNvbnN0IERPQ1VNRU5UID0gJ1xceDAyJzsgLy8gQzA6IFN0YXJ0IG9mIFRleHRcbi8qKiBVbmV4cGVjdGVkIGVuZCBvZiBmbG93LW1vZGUgKi9cbmNvbnN0IEZMT1dfRU5EID0gJ1xceDE4JzsgLy8gQzA6IENhbmNlbFxuLyoqIE5leHQgdG9rZW4gaXMgYSBzY2FsYXIgdmFsdWUgKi9cbmNvbnN0IFNDQUxBUiA9ICdcXHgxZic7IC8vIEMwOiBVbml0IFNlcGFyYXRvclxuLyoqIEByZXR1cm5zIGB0cnVlYCBpZiBgdG9rZW5gIGlzIGEgZmxvdyBvciBibG9jayBjb2xsZWN0aW9uICovXG5jb25zdCBpc0NvbGxlY3Rpb24gPSAodG9rZW4pID0+ICEhdG9rZW4gJiYgJ2l0ZW1zJyBpbiB0b2tlbjtcbi8qKiBAcmV0dXJucyBgdHJ1ZWAgaWYgYHRva2VuYCBpcyBhIGZsb3cgb3IgYmxvY2sgc2NhbGFyOyBub3QgYW4gYWxpYXMgKi9cbmNvbnN0IGlzU2NhbGFyID0gKHRva2VuKSA9PiAhIXRva2VuICYmXG4gICAgKHRva2VuLnR5cGUgPT09ICdzY2FsYXInIHx8XG4gICAgICAgIHRva2VuLnR5cGUgPT09ICdzaW5nbGUtcXVvdGVkLXNjYWxhcicgfHxcbiAgICAgICAgdG9rZW4udHlwZSA9PT0gJ2RvdWJsZS1xdW90ZWQtc2NhbGFyJyB8fFxuICAgICAgICB0b2tlbi50eXBlID09PSAnYmxvY2stc2NhbGFyJyk7XG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuLyoqIEdldCBhIHByaW50YWJsZSByZXByZXNlbnRhdGlvbiBvZiBhIGxleGVyIHRva2VuICovXG5mdW5jdGlvbiBwcmV0dHlUb2tlbih0b2tlbikge1xuICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgICAgY2FzZSBCT006XG4gICAgICAgICAgICByZXR1cm4gJzxCT00+JztcbiAgICAgICAgY2FzZSBET0NVTUVOVDpcbiAgICAgICAgICAgIHJldHVybiAnPERPQz4nO1xuICAgICAgICBjYXNlIEZMT1dfRU5EOlxuICAgICAgICAgICAgcmV0dXJuICc8RkxPV19FTkQ+JztcbiAgICAgICAgY2FzZSBTQ0FMQVI6XG4gICAgICAgICAgICByZXR1cm4gJzxTQ0FMQVI+JztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh0b2tlbik7XG4gICAgfVxufVxuLyoqIElkZW50aWZ5IHRoZSB0eXBlIG9mIGEgbGV4ZXIgdG9rZW4uIE1heSByZXR1cm4gYG51bGxgIGZvciB1bmtub3duIHRva2Vucy4gKi9cbmZ1bmN0aW9uIHRva2VuVHlwZShzb3VyY2UpIHtcbiAgICBzd2l0Y2ggKHNvdXJjZSkge1xuICAgICAgICBjYXNlIEJPTTpcbiAgICAgICAgICAgIHJldHVybiAnYnl0ZS1vcmRlci1tYXJrJztcbiAgICAgICAgY2FzZSBET0NVTUVOVDpcbiAgICAgICAgICAgIHJldHVybiAnZG9jLW1vZGUnO1xuICAgICAgICBjYXNlIEZMT1dfRU5EOlxuICAgICAgICAgICAgcmV0dXJuICdmbG93LWVycm9yLWVuZCc7XG4gICAgICAgIGNhc2UgU0NBTEFSOlxuICAgICAgICAgICAgcmV0dXJuICdzY2FsYXInO1xuICAgICAgICBjYXNlICctLS0nOlxuICAgICAgICAgICAgcmV0dXJuICdkb2Mtc3RhcnQnO1xuICAgICAgICBjYXNlICcuLi4nOlxuICAgICAgICAgICAgcmV0dXJuICdkb2MtZW5kJztcbiAgICAgICAgY2FzZSAnJzpcbiAgICAgICAgY2FzZSAnXFxuJzpcbiAgICAgICAgY2FzZSAnXFxyXFxuJzpcbiAgICAgICAgICAgIHJldHVybiAnbmV3bGluZSc7XG4gICAgICAgIGNhc2UgJy0nOlxuICAgICAgICAgICAgcmV0dXJuICdzZXEtaXRlbS1pbmQnO1xuICAgICAgICBjYXNlICc/JzpcbiAgICAgICAgICAgIHJldHVybiAnZXhwbGljaXQta2V5LWluZCc7XG4gICAgICAgIGNhc2UgJzonOlxuICAgICAgICAgICAgcmV0dXJuICdtYXAtdmFsdWUtaW5kJztcbiAgICAgICAgY2FzZSAneyc6XG4gICAgICAgICAgICByZXR1cm4gJ2Zsb3ctbWFwLXN0YXJ0JztcbiAgICAgICAgY2FzZSAnfSc6XG4gICAgICAgICAgICByZXR1cm4gJ2Zsb3ctbWFwLWVuZCc7XG4gICAgICAgIGNhc2UgJ1snOlxuICAgICAgICAgICAgcmV0dXJuICdmbG93LXNlcS1zdGFydCc7XG4gICAgICAgIGNhc2UgJ10nOlxuICAgICAgICAgICAgcmV0dXJuICdmbG93LXNlcS1lbmQnO1xuICAgICAgICBjYXNlICcsJzpcbiAgICAgICAgICAgIHJldHVybiAnY29tbWEnO1xuICAgIH1cbiAgICBzd2l0Y2ggKHNvdXJjZVswXSkge1xuICAgICAgICBjYXNlICcgJzpcbiAgICAgICAgY2FzZSAnXFx0JzpcbiAgICAgICAgICAgIHJldHVybiAnc3BhY2UnO1xuICAgICAgICBjYXNlICcjJzpcbiAgICAgICAgICAgIHJldHVybiAnY29tbWVudCc7XG4gICAgICAgIGNhc2UgJyUnOlxuICAgICAgICAgICAgcmV0dXJuICdkaXJlY3RpdmUtbGluZSc7XG4gICAgICAgIGNhc2UgJyonOlxuICAgICAgICAgICAgcmV0dXJuICdhbGlhcyc7XG4gICAgICAgIGNhc2UgJyYnOlxuICAgICAgICAgICAgcmV0dXJuICdhbmNob3InO1xuICAgICAgICBjYXNlICchJzpcbiAgICAgICAgICAgIHJldHVybiAndGFnJztcbiAgICAgICAgY2FzZSBcIidcIjpcbiAgICAgICAgICAgIHJldHVybiAnc2luZ2xlLXF1b3RlZC1zY2FsYXInO1xuICAgICAgICBjYXNlICdcIic6XG4gICAgICAgICAgICByZXR1cm4gJ2RvdWJsZS1xdW90ZWQtc2NhbGFyJztcbiAgICAgICAgY2FzZSAnfCc6XG4gICAgICAgIGNhc2UgJz4nOlxuICAgICAgICAgICAgcmV0dXJuICdibG9jay1zY2FsYXItaGVhZGVyJztcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5cbmV4cG9ydCB7IEJPTSwgRE9DVU1FTlQsIEZMT1dfRU5ELCBTQ0FMQVIsIGlzQ29sbGVjdGlvbiwgaXNTY2FsYXIsIHByZXR0eVRva2VuLCB0b2tlblR5cGUgfTtcbiIsICJpbXBvcnQgeyByZXNvbHZlQmxvY2tTY2FsYXIgfSBmcm9tICcuLi9jb21wb3NlL3Jlc29sdmUtYmxvY2stc2NhbGFyLmpzJztcbmltcG9ydCB7IHJlc29sdmVGbG93U2NhbGFyIH0gZnJvbSAnLi4vY29tcG9zZS9yZXNvbHZlLWZsb3ctc2NhbGFyLmpzJztcbmltcG9ydCB7IFlBTUxQYXJzZUVycm9yIH0gZnJvbSAnLi4vZXJyb3JzLmpzJztcbmltcG9ydCB7IHN0cmluZ2lmeVN0cmluZyB9IGZyb20gJy4uL3N0cmluZ2lmeS9zdHJpbmdpZnlTdHJpbmcuanMnO1xuXG5mdW5jdGlvbiByZXNvbHZlQXNTY2FsYXIodG9rZW4sIHN0cmljdCA9IHRydWUsIG9uRXJyb3IpIHtcbiAgICBpZiAodG9rZW4pIHtcbiAgICAgICAgY29uc3QgX29uRXJyb3IgPSAocG9zLCBjb2RlLCBtZXNzYWdlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBvZmZzZXQgPSB0eXBlb2YgcG9zID09PSAnbnVtYmVyJyA/IHBvcyA6IEFycmF5LmlzQXJyYXkocG9zKSA/IHBvc1swXSA6IHBvcy5vZmZzZXQ7XG4gICAgICAgICAgICBpZiAob25FcnJvcilcbiAgICAgICAgICAgICAgICBvbkVycm9yKG9mZnNldCwgY29kZSwgbWVzc2FnZSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFlBTUxQYXJzZUVycm9yKFtvZmZzZXQsIG9mZnNldCArIDFdLCBjb2RlLCBtZXNzYWdlKTtcbiAgICAgICAgfTtcbiAgICAgICAgc3dpdGNoICh0b2tlbi50eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdzY2FsYXInOlxuICAgICAgICAgICAgY2FzZSAnc2luZ2xlLXF1b3RlZC1zY2FsYXInOlxuICAgICAgICAgICAgY2FzZSAnZG91YmxlLXF1b3RlZC1zY2FsYXInOlxuICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlRmxvd1NjYWxhcih0b2tlbiwgc3RyaWN0LCBfb25FcnJvcik7XG4gICAgICAgICAgICBjYXNlICdibG9jay1zY2FsYXInOlxuICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlQmxvY2tTY2FsYXIodG9rZW4sIHN0cmljdCwgX29uRXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgc2NhbGFyIHRva2VuIHdpdGggYHZhbHVlYFxuICpcbiAqIFZhbHVlcyB0aGF0IHJlcHJlc2VudCBhbiBhY3R1YWwgc3RyaW5nIGJ1dCBtYXkgYmUgcGFyc2VkIGFzIGEgZGlmZmVyZW50IHR5cGUgc2hvdWxkIHVzZSBhIGB0eXBlYCBvdGhlciB0aGFuIGAnUExBSU4nYCxcbiAqIGFzIHRoaXMgZnVuY3Rpb24gZG9lcyBub3Qgc3VwcG9ydCBhbnkgc2NoZW1hIG9wZXJhdGlvbnMgYW5kIHdvbid0IGNoZWNrIGZvciBzdWNoIGNvbmZsaWN0cy5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgVGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgdmFsdWUsIHdoaWNoIHdpbGwgaGF2ZSBpdHMgY29udGVudCBwcm9wZXJseSBpbmRlbnRlZC5cbiAqIEBwYXJhbSBjb250ZXh0LmVuZCBDb21tZW50cyBhbmQgd2hpdGVzcGFjZSBhZnRlciB0aGUgZW5kIG9mIHRoZSB2YWx1ZSwgb3IgYWZ0ZXIgdGhlIGJsb2NrIHNjYWxhciBoZWFkZXIuIElmIHVuZGVmaW5lZCwgYSBuZXdsaW5lIHdpbGwgYmUgYWRkZWQuXG4gKiBAcGFyYW0gY29udGV4dC5pbXBsaWNpdEtleSBCZWluZyB3aXRoaW4gYW4gaW1wbGljaXQga2V5IG1heSBhZmZlY3QgdGhlIHJlc29sdmVkIHR5cGUgb2YgdGhlIHRva2VuJ3MgdmFsdWUuXG4gKiBAcGFyYW0gY29udGV4dC5pbmRlbnQgVGhlIGluZGVudCBsZXZlbCBvZiB0aGUgdG9rZW4uXG4gKiBAcGFyYW0gY29udGV4dC5pbkZsb3cgSXMgdGhpcyBzY2FsYXIgd2l0aGluIGEgZmxvdyBjb2xsZWN0aW9uPyBUaGlzIG1heSBhZmZlY3QgdGhlIHJlc29sdmVkIHR5cGUgb2YgdGhlIHRva2VuJ3MgdmFsdWUuXG4gKiBAcGFyYW0gY29udGV4dC5vZmZzZXQgVGhlIG9mZnNldCBwb3NpdGlvbiBvZiB0aGUgdG9rZW4uXG4gKiBAcGFyYW0gY29udGV4dC50eXBlIFRoZSBwcmVmZXJyZWQgdHlwZSBvZiB0aGUgc2NhbGFyIHRva2VuLiBJZiB1bmRlZmluZWQsIHRoZSBwcmV2aW91cyB0eXBlIG9mIHRoZSBgdG9rZW5gIHdpbGwgYmUgdXNlZCwgZGVmYXVsdGluZyB0byBgJ1BMQUlOJ2AuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVNjYWxhclRva2VuKHZhbHVlLCBjb250ZXh0KSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHsgaW1wbGljaXRLZXkgPSBmYWxzZSwgaW5kZW50LCBpbkZsb3cgPSBmYWxzZSwgb2Zmc2V0ID0gLTEsIHR5cGUgPSAnUExBSU4nIH0gPSBjb250ZXh0O1xuICAgIGNvbnN0IHNvdXJjZSA9IHN0cmluZ2lmeVN0cmluZyh7IHR5cGUsIHZhbHVlIH0sIHtcbiAgICAgICAgaW1wbGljaXRLZXksXG4gICAgICAgIGluZGVudDogaW5kZW50ID4gMCA/ICcgJy5yZXBlYXQoaW5kZW50KSA6ICcnLFxuICAgICAgICBpbkZsb3csXG4gICAgICAgIG9wdGlvbnM6IHsgYmxvY2tRdW90ZTogdHJ1ZSwgbGluZVdpZHRoOiAtMSB9XG4gICAgfSk7XG4gICAgY29uc3QgZW5kID0gKF9hID0gY29udGV4dC5lbmQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFtcbiAgICAgICAgeyB0eXBlOiAnbmV3bGluZScsIG9mZnNldDogLTEsIGluZGVudCwgc291cmNlOiAnXFxuJyB9XG4gICAgXTtcbiAgICBzd2l0Y2ggKHNvdXJjZVswXSkge1xuICAgICAgICBjYXNlICd8JzpcbiAgICAgICAgY2FzZSAnPic6IHtcbiAgICAgICAgICAgIGNvbnN0IGhlID0gc291cmNlLmluZGV4T2YoJ1xcbicpO1xuICAgICAgICAgICAgY29uc3QgaGVhZCA9IHNvdXJjZS5zdWJzdHJpbmcoMCwgaGUpO1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IHNvdXJjZS5zdWJzdHJpbmcoaGUgKyAxKSArICdcXG4nO1xuICAgICAgICAgICAgY29uc3QgcHJvcHMgPSBbXG4gICAgICAgICAgICAgICAgeyB0eXBlOiAnYmxvY2stc2NhbGFyLWhlYWRlcicsIG9mZnNldCwgaW5kZW50LCBzb3VyY2U6IGhlYWQgfVxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIGlmICghYWRkRW5kdG9CbG9ja1Byb3BzKHByb3BzLCBlbmQpKVxuICAgICAgICAgICAgICAgIHByb3BzLnB1c2goeyB0eXBlOiAnbmV3bGluZScsIG9mZnNldDogLTEsIGluZGVudCwgc291cmNlOiAnXFxuJyB9KTtcbiAgICAgICAgICAgIHJldHVybiB7IHR5cGU6ICdibG9jay1zY2FsYXInLCBvZmZzZXQsIGluZGVudCwgcHJvcHMsIHNvdXJjZTogYm9keSB9O1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ1wiJzpcbiAgICAgICAgICAgIHJldHVybiB7IHR5cGU6ICdkb3VibGUtcXVvdGVkLXNjYWxhcicsIG9mZnNldCwgaW5kZW50LCBzb3VyY2UsIGVuZCB9O1xuICAgICAgICBjYXNlIFwiJ1wiOlxuICAgICAgICAgICAgcmV0dXJuIHsgdHlwZTogJ3NpbmdsZS1xdW90ZWQtc2NhbGFyJywgb2Zmc2V0LCBpbmRlbnQsIHNvdXJjZSwgZW5kIH07XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4geyB0eXBlOiAnc2NhbGFyJywgb2Zmc2V0LCBpbmRlbnQsIHNvdXJjZSwgZW5kIH07XG4gICAgfVxufVxuLyoqXG4gKiBTZXQgdGhlIHZhbHVlIG9mIGB0b2tlbmAgdG8gdGhlIGdpdmVuIHN0cmluZyBgdmFsdWVgLCBvdmVyd3JpdGluZyBhbnkgcHJldmlvdXMgY29udGVudHMgYW5kIHR5cGUgdGhhdCBpdCBtYXkgaGF2ZS5cbiAqXG4gKiBCZXN0IGVmZm9ydHMgYXJlIG1hZGUgdG8gcmV0YWluIGFueSBjb21tZW50cyBwcmV2aW91c2x5IGFzc29jaWF0ZWQgd2l0aCB0aGUgYHRva2VuYCxcbiAqIHRob3VnaCBhbGwgY29udGVudHMgd2l0aGluIGEgY29sbGVjdGlvbidzIGBpdGVtc2Agd2lsbCBiZSBvdmVyd3JpdHRlbi5cbiAqXG4gKiBWYWx1ZXMgdGhhdCByZXByZXNlbnQgYW4gYWN0dWFsIHN0cmluZyBidXQgbWF5IGJlIHBhcnNlZCBhcyBhIGRpZmZlcmVudCB0eXBlIHNob3VsZCB1c2UgYSBgdHlwZWAgb3RoZXIgdGhhbiBgJ1BMQUlOJ2AsXG4gKiBhcyB0aGlzIGZ1bmN0aW9uIGRvZXMgbm90IHN1cHBvcnQgYW55IHNjaGVtYSBvcGVyYXRpb25zIGFuZCB3b24ndCBjaGVjayBmb3Igc3VjaCBjb25mbGljdHMuXG4gKlxuICogQHBhcmFtIHRva2VuIEFueSB0b2tlbi4gSWYgaXQgZG9lcyBub3QgaW5jbHVkZSBhbiBgaW5kZW50YCB2YWx1ZSwgdGhlIHZhbHVlIHdpbGwgYmUgc3RyaW5naWZpZWQgYXMgaWYgaXQgd2VyZSBhbiBpbXBsaWNpdCBrZXkuXG4gKiBAcGFyYW0gdmFsdWUgVGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgdmFsdWUsIHdoaWNoIHdpbGwgaGF2ZSBpdHMgY29udGVudCBwcm9wZXJseSBpbmRlbnRlZC5cbiAqIEBwYXJhbSBjb250ZXh0LmFmdGVyS2V5IEluIG1vc3QgY2FzZXMsIHZhbHVlcyBhZnRlciBhIGtleSBzaG91bGQgaGF2ZSBhbiBhZGRpdGlvbmFsIGxldmVsIG9mIGluZGVudGF0aW9uLlxuICogQHBhcmFtIGNvbnRleHQuaW1wbGljaXRLZXkgQmVpbmcgd2l0aGluIGFuIGltcGxpY2l0IGtleSBtYXkgYWZmZWN0IHRoZSByZXNvbHZlZCB0eXBlIG9mIHRoZSB0b2tlbidzIHZhbHVlLlxuICogQHBhcmFtIGNvbnRleHQuaW5GbG93IEJlaW5nIHdpdGhpbiBhIGZsb3cgY29sbGVjdGlvbiBtYXkgYWZmZWN0IHRoZSByZXNvbHZlZCB0eXBlIG9mIHRoZSB0b2tlbidzIHZhbHVlLlxuICogQHBhcmFtIGNvbnRleHQudHlwZSBUaGUgcHJlZmVycmVkIHR5cGUgb2YgdGhlIHNjYWxhciB0b2tlbi4gSWYgdW5kZWZpbmVkLCB0aGUgcHJldmlvdXMgdHlwZSBvZiB0aGUgYHRva2VuYCB3aWxsIGJlIHVzZWQsIGRlZmF1bHRpbmcgdG8gYCdQTEFJTidgLlxuICovXG5mdW5jdGlvbiBzZXRTY2FsYXJWYWx1ZSh0b2tlbiwgdmFsdWUsIGNvbnRleHQgPSB7fSkge1xuICAgIGxldCB7IGFmdGVyS2V5ID0gZmFsc2UsIGltcGxpY2l0S2V5ID0gZmFsc2UsIGluRmxvdyA9IGZhbHNlLCB0eXBlIH0gPSBjb250ZXh0O1xuICAgIGxldCBpbmRlbnQgPSAnaW5kZW50JyBpbiB0b2tlbiA/IHRva2VuLmluZGVudCA6IG51bGw7XG4gICAgaWYgKGFmdGVyS2V5ICYmIHR5cGVvZiBpbmRlbnQgPT09ICdudW1iZXInKVxuICAgICAgICBpbmRlbnQgKz0gMjtcbiAgICBpZiAoIXR5cGUpXG4gICAgICAgIHN3aXRjaCAodG9rZW4udHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnc2luZ2xlLXF1b3RlZC1zY2FsYXInOlxuICAgICAgICAgICAgICAgIHR5cGUgPSAnUVVPVEVfU0lOR0xFJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2RvdWJsZS1xdW90ZWQtc2NhbGFyJzpcbiAgICAgICAgICAgICAgICB0eXBlID0gJ1FVT1RFX0RPVUJMRSc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdibG9jay1zY2FsYXInOiB7XG4gICAgICAgICAgICAgICAgY29uc3QgaGVhZGVyID0gdG9rZW4ucHJvcHNbMF07XG4gICAgICAgICAgICAgICAgaWYgKGhlYWRlci50eXBlICE9PSAnYmxvY2stc2NhbGFyLWhlYWRlcicpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBibG9jayBzY2FsYXIgaGVhZGVyJyk7XG4gICAgICAgICAgICAgICAgdHlwZSA9IGhlYWRlci5zb3VyY2VbMF0gPT09ICc+JyA/ICdCTE9DS19GT0xERUQnIDogJ0JMT0NLX0xJVEVSQUwnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0eXBlID0gJ1BMQUlOJztcbiAgICAgICAgfVxuICAgIGNvbnN0IHNvdXJjZSA9IHN0cmluZ2lmeVN0cmluZyh7IHR5cGUsIHZhbHVlIH0sIHtcbiAgICAgICAgaW1wbGljaXRLZXk6IGltcGxpY2l0S2V5IHx8IGluZGVudCA9PT0gbnVsbCxcbiAgICAgICAgaW5kZW50OiBpbmRlbnQgIT09IG51bGwgJiYgaW5kZW50ID4gMCA/ICcgJy5yZXBlYXQoaW5kZW50KSA6ICcnLFxuICAgICAgICBpbkZsb3csXG4gICAgICAgIG9wdGlvbnM6IHsgYmxvY2tRdW90ZTogdHJ1ZSwgbGluZVdpZHRoOiAtMSB9XG4gICAgfSk7XG4gICAgc3dpdGNoIChzb3VyY2VbMF0pIHtcbiAgICAgICAgY2FzZSAnfCc6XG4gICAgICAgIGNhc2UgJz4nOlxuICAgICAgICAgICAgc2V0QmxvY2tTY2FsYXJWYWx1ZSh0b2tlbiwgc291cmNlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdcIic6XG4gICAgICAgICAgICBzZXRGbG93U2NhbGFyVmFsdWUodG9rZW4sIHNvdXJjZSwgJ2RvdWJsZS1xdW90ZWQtc2NhbGFyJyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIidcIjpcbiAgICAgICAgICAgIHNldEZsb3dTY2FsYXJWYWx1ZSh0b2tlbiwgc291cmNlLCAnc2luZ2xlLXF1b3RlZC1zY2FsYXInKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgc2V0Rmxvd1NjYWxhclZhbHVlKHRva2VuLCBzb3VyY2UsICdzY2FsYXInKTtcbiAgICB9XG59XG5mdW5jdGlvbiBzZXRCbG9ja1NjYWxhclZhbHVlKHRva2VuLCBzb3VyY2UpIHtcbiAgICBjb25zdCBoZSA9IHNvdXJjZS5pbmRleE9mKCdcXG4nKTtcbiAgICBjb25zdCBoZWFkID0gc291cmNlLnN1YnN0cmluZygwLCBoZSk7XG4gICAgY29uc3QgYm9keSA9IHNvdXJjZS5zdWJzdHJpbmcoaGUgKyAxKSArICdcXG4nO1xuICAgIGlmICh0b2tlbi50eXBlID09PSAnYmxvY2stc2NhbGFyJykge1xuICAgICAgICBjb25zdCBoZWFkZXIgPSB0b2tlbi5wcm9wc1swXTtcbiAgICAgICAgaWYgKGhlYWRlci50eXBlICE9PSAnYmxvY2stc2NhbGFyLWhlYWRlcicpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYmxvY2sgc2NhbGFyIGhlYWRlcicpO1xuICAgICAgICBoZWFkZXIuc291cmNlID0gaGVhZDtcbiAgICAgICAgdG9rZW4uc291cmNlID0gYm9keTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IHsgb2Zmc2V0IH0gPSB0b2tlbjtcbiAgICAgICAgY29uc3QgaW5kZW50ID0gJ2luZGVudCcgaW4gdG9rZW4gPyB0b2tlbi5pbmRlbnQgOiAtMTtcbiAgICAgICAgY29uc3QgcHJvcHMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6ICdibG9jay1zY2FsYXItaGVhZGVyJywgb2Zmc2V0LCBpbmRlbnQsIHNvdXJjZTogaGVhZCB9XG4gICAgICAgIF07XG4gICAgICAgIGlmICghYWRkRW5kdG9CbG9ja1Byb3BzKHByb3BzLCAnZW5kJyBpbiB0b2tlbiA/IHRva2VuLmVuZCA6IHVuZGVmaW5lZCkpXG4gICAgICAgICAgICBwcm9wcy5wdXNoKHsgdHlwZTogJ25ld2xpbmUnLCBvZmZzZXQ6IC0xLCBpbmRlbnQsIHNvdXJjZTogJ1xcbicgfSk7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHRva2VuKSlcbiAgICAgICAgICAgIGlmIChrZXkgIT09ICd0eXBlJyAmJiBrZXkgIT09ICdvZmZzZXQnKVxuICAgICAgICAgICAgICAgIGRlbGV0ZSB0b2tlbltrZXldO1xuICAgICAgICBPYmplY3QuYXNzaWduKHRva2VuLCB7IHR5cGU6ICdibG9jay1zY2FsYXInLCBpbmRlbnQsIHByb3BzLCBzb3VyY2U6IGJvZHkgfSk7XG4gICAgfVxufVxuLyoqIEByZXR1cm5zIGB0cnVlYCBpZiBsYXN0IHRva2VuIGlzIGEgbmV3bGluZSAqL1xuZnVuY3Rpb24gYWRkRW5kdG9CbG9ja1Byb3BzKHByb3BzLCBlbmQpIHtcbiAgICBpZiAoZW5kKVxuICAgICAgICBmb3IgKGNvbnN0IHN0IG9mIGVuZClcbiAgICAgICAgICAgIHN3aXRjaCAoc3QudHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3NwYWNlJzpcbiAgICAgICAgICAgICAgICBjYXNlICdjb21tZW50JzpcbiAgICAgICAgICAgICAgICAgICAgcHJvcHMucHVzaChzdCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ25ld2xpbmUnOlxuICAgICAgICAgICAgICAgICAgICBwcm9wcy5wdXNoKHN0KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gc2V0Rmxvd1NjYWxhclZhbHVlKHRva2VuLCBzb3VyY2UsIHR5cGUpIHtcbiAgICBzd2l0Y2ggKHRva2VuLnR5cGUpIHtcbiAgICAgICAgY2FzZSAnc2NhbGFyJzpcbiAgICAgICAgY2FzZSAnZG91YmxlLXF1b3RlZC1zY2FsYXInOlxuICAgICAgICBjYXNlICdzaW5nbGUtcXVvdGVkLXNjYWxhcic6XG4gICAgICAgICAgICB0b2tlbi50eXBlID0gdHlwZTtcbiAgICAgICAgICAgIHRva2VuLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdibG9jay1zY2FsYXInOiB7XG4gICAgICAgICAgICBjb25zdCBlbmQgPSB0b2tlbi5wcm9wcy5zbGljZSgxKTtcbiAgICAgICAgICAgIGxldCBvYSA9IHNvdXJjZS5sZW5ndGg7XG4gICAgICAgICAgICBpZiAodG9rZW4ucHJvcHNbMF0udHlwZSA9PT0gJ2Jsb2NrLXNjYWxhci1oZWFkZXInKVxuICAgICAgICAgICAgICAgIG9hIC09IHRva2VuLnByb3BzWzBdLnNvdXJjZS5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHRvayBvZiBlbmQpXG4gICAgICAgICAgICAgICAgdG9rLm9mZnNldCArPSBvYTtcbiAgICAgICAgICAgIGRlbGV0ZSB0b2tlbi5wcm9wcztcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odG9rZW4sIHsgdHlwZSwgc291cmNlLCBlbmQgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdibG9jay1tYXAnOlxuICAgICAgICBjYXNlICdibG9jay1zZXEnOiB7XG4gICAgICAgICAgICBjb25zdCBvZmZzZXQgPSB0b2tlbi5vZmZzZXQgKyBzb3VyY2UubGVuZ3RoO1xuICAgICAgICAgICAgY29uc3QgbmwgPSB7IHR5cGU6ICduZXdsaW5lJywgb2Zmc2V0LCBpbmRlbnQ6IHRva2VuLmluZGVudCwgc291cmNlOiAnXFxuJyB9O1xuICAgICAgICAgICAgZGVsZXRlIHRva2VuLml0ZW1zO1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0b2tlbiwgeyB0eXBlLCBzb3VyY2UsIGVuZDogW25sXSB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgIGNvbnN0IGluZGVudCA9ICdpbmRlbnQnIGluIHRva2VuID8gdG9rZW4uaW5kZW50IDogLTE7XG4gICAgICAgICAgICBjb25zdCBlbmQgPSAnZW5kJyBpbiB0b2tlbiAmJiBBcnJheS5pc0FycmF5KHRva2VuLmVuZClcbiAgICAgICAgICAgICAgICA/IHRva2VuLmVuZC5maWx0ZXIoc3QgPT4gc3QudHlwZSA9PT0gJ3NwYWNlJyB8fFxuICAgICAgICAgICAgICAgICAgICBzdC50eXBlID09PSAnY29tbWVudCcgfHxcbiAgICAgICAgICAgICAgICAgICAgc3QudHlwZSA9PT0gJ25ld2xpbmUnKVxuICAgICAgICAgICAgICAgIDogW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyh0b2tlbikpXG4gICAgICAgICAgICAgICAgaWYgKGtleSAhPT0gJ3R5cGUnICYmIGtleSAhPT0gJ29mZnNldCcpXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0b2tlbltrZXldO1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0b2tlbiwgeyB0eXBlLCBpbmRlbnQsIHNvdXJjZSwgZW5kIH0pO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgeyBjcmVhdGVTY2FsYXJUb2tlbiwgcmVzb2x2ZUFzU2NhbGFyLCBzZXRTY2FsYXJWYWx1ZSB9O1xuIiwgIi8qKlxuICogU3RyaW5naWZ5IGEgQ1NUIGRvY3VtZW50LCB0b2tlbiwgb3IgY29sbGVjdGlvbiBpdGVtXG4gKlxuICogRmFpciB3YXJuaW5nOiBUaGlzIGFwcGxpZXMgbm8gdmFsaWRhdGlvbiB3aGF0c29ldmVyLCBhbmRcbiAqIHNpbXBseSBjb25jYXRlbmF0ZXMgdGhlIHNvdXJjZXMgaW4gdGhlaXIgbG9naWNhbCBvcmRlci5cbiAqL1xuY29uc3Qgc3RyaW5naWZ5ID0gKGNzdCkgPT4gJ3R5cGUnIGluIGNzdCA/IHN0cmluZ2lmeVRva2VuKGNzdCkgOiBzdHJpbmdpZnlJdGVtKGNzdCk7XG5mdW5jdGlvbiBzdHJpbmdpZnlUb2tlbih0b2tlbikge1xuICAgIHN3aXRjaCAodG9rZW4udHlwZSkge1xuICAgICAgICBjYXNlICdibG9jay1zY2FsYXInOiB7XG4gICAgICAgICAgICBsZXQgcmVzID0gJyc7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHRvayBvZiB0b2tlbi5wcm9wcylcbiAgICAgICAgICAgICAgICByZXMgKz0gc3RyaW5naWZ5VG9rZW4odG9rKTtcbiAgICAgICAgICAgIHJldHVybiByZXMgKyB0b2tlbi5zb3VyY2U7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnYmxvY2stbWFwJzpcbiAgICAgICAgY2FzZSAnYmxvY2stc2VxJzoge1xuICAgICAgICAgICAgbGV0IHJlcyA9ICcnO1xuICAgICAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIHRva2VuLml0ZW1zKVxuICAgICAgICAgICAgICAgIHJlcyArPSBzdHJpbmdpZnlJdGVtKGl0ZW0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdmbG93LWNvbGxlY3Rpb24nOiB7XG4gICAgICAgICAgICBsZXQgcmVzID0gdG9rZW4uc3RhcnQuc291cmNlO1xuICAgICAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIHRva2VuLml0ZW1zKVxuICAgICAgICAgICAgICAgIHJlcyArPSBzdHJpbmdpZnlJdGVtKGl0ZW0pO1xuICAgICAgICAgICAgZm9yIChjb25zdCBzdCBvZiB0b2tlbi5lbmQpXG4gICAgICAgICAgICAgICAgcmVzICs9IHN0LnNvdXJjZTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnZG9jdW1lbnQnOiB7XG4gICAgICAgICAgICBsZXQgcmVzID0gc3RyaW5naWZ5SXRlbSh0b2tlbik7XG4gICAgICAgICAgICBpZiAodG9rZW4uZW5kKVxuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qgc3Qgb2YgdG9rZW4uZW5kKVxuICAgICAgICAgICAgICAgICAgICByZXMgKz0gc3Quc291cmNlO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICBsZXQgcmVzID0gdG9rZW4uc291cmNlO1xuICAgICAgICAgICAgaWYgKCdlbmQnIGluIHRva2VuICYmIHRva2VuLmVuZClcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHN0IG9mIHRva2VuLmVuZClcbiAgICAgICAgICAgICAgICAgICAgcmVzICs9IHN0LnNvdXJjZTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBzdHJpbmdpZnlJdGVtKHsgc3RhcnQsIGtleSwgc2VwLCB2YWx1ZSB9KSB7XG4gICAgbGV0IHJlcyA9ICcnO1xuICAgIGZvciAoY29uc3Qgc3Qgb2Ygc3RhcnQpXG4gICAgICAgIHJlcyArPSBzdC5zb3VyY2U7XG4gICAgaWYgKGtleSlcbiAgICAgICAgcmVzICs9IHN0cmluZ2lmeVRva2VuKGtleSk7XG4gICAgaWYgKHNlcClcbiAgICAgICAgZm9yIChjb25zdCBzdCBvZiBzZXApXG4gICAgICAgICAgICByZXMgKz0gc3Quc291cmNlO1xuICAgIGlmICh2YWx1ZSlcbiAgICAgICAgcmVzICs9IHN0cmluZ2lmeVRva2VuKHZhbHVlKTtcbiAgICByZXR1cm4gcmVzO1xufVxuXG5leHBvcnQgeyBzdHJpbmdpZnkgfTtcbiIsICJjb25zdCBCUkVBSyA9IFN5bWJvbCgnYnJlYWsgdmlzaXQnKTtcbmNvbnN0IFNLSVAgPSBTeW1ib2woJ3NraXAgY2hpbGRyZW4nKTtcbmNvbnN0IFJFTU9WRSA9IFN5bWJvbCgncmVtb3ZlIGl0ZW0nKTtcbi8qKlxuICogQXBwbHkgYSB2aXNpdG9yIHRvIGEgQ1NUIGRvY3VtZW50IG9yIGl0ZW0uXG4gKlxuICogV2Fsa3MgdGhyb3VnaCB0aGUgdHJlZSAoZGVwdGgtZmlyc3QpIHN0YXJ0aW5nIGZyb20gdGhlIHJvb3QsIGNhbGxpbmcgYVxuICogYHZpc2l0b3JgIGZ1bmN0aW9uIHdpdGggdHdvIGFyZ3VtZW50cyB3aGVuIGVudGVyaW5nIGVhY2ggaXRlbTpcbiAqICAgLSBgaXRlbWA6IFRoZSBjdXJyZW50IGl0ZW0sIHdoaWNoIGluY2x1ZGVkIHRoZSBmb2xsb3dpbmcgbWVtYmVyczpcbiAqICAgICAtIGBzdGFydDogU291cmNlVG9rZW5bXWAgXHUyMDEzIFNvdXJjZSB0b2tlbnMgYmVmb3JlIHRoZSBrZXkgb3IgdmFsdWUsXG4gKiAgICAgICBwb3NzaWJseSBpbmNsdWRpbmcgaXRzIGFuY2hvciBvciB0YWcuXG4gKiAgICAgLSBga2V5PzogVG9rZW4gfCBudWxsYCBcdTIwMTMgU2V0IGZvciBwYWlyIHZhbHVlcy4gTWF5IHRoZW4gYmUgYG51bGxgLCBpZlxuICogICAgICAgdGhlIGtleSBiZWZvcmUgdGhlIGA6YCBzZXBhcmF0b3IgaXMgZW1wdHkuXG4gKiAgICAgLSBgc2VwPzogU291cmNlVG9rZW5bXWAgXHUyMDEzIFNvdXJjZSB0b2tlbnMgYmV0d2VlbiB0aGUga2V5IGFuZCB0aGUgdmFsdWUsXG4gKiAgICAgICB3aGljaCBzaG91bGQgaW5jbHVkZSB0aGUgYDpgIG1hcCB2YWx1ZSBpbmRpY2F0b3IgaWYgYHZhbHVlYCBpcyBzZXQuXG4gKiAgICAgLSBgdmFsdWU/OiBUb2tlbmAgXHUyMDEzIFRoZSB2YWx1ZSBvZiBhIHNlcXVlbmNlIGl0ZW0sIG9yIG9mIGEgbWFwIHBhaXIuXG4gKiAgIC0gYHBhdGhgOiBUaGUgc3RlcHMgZnJvbSB0aGUgcm9vdCB0byB0aGUgY3VycmVudCBub2RlLCBhcyBhbiBhcnJheSBvZlxuICogICAgIGBbJ2tleScgfCAndmFsdWUnLCBudW1iZXJdYCB0dXBsZXMuXG4gKlxuICogVGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgdmlzaXRvciBtYXkgYmUgdXNlZCB0byBjb250cm9sIHRoZSB0cmF2ZXJzYWw6XG4gKiAgIC0gYHVuZGVmaW5lZGAgKGRlZmF1bHQpOiBEbyBub3RoaW5nIGFuZCBjb250aW51ZVxuICogICAtIGB2aXNpdC5TS0lQYDogRG8gbm90IHZpc2l0IHRoZSBjaGlsZHJlbiBvZiB0aGlzIHRva2VuLCBjb250aW51ZSB3aXRoXG4gKiAgICAgIG5leHQgc2libGluZ1xuICogICAtIGB2aXNpdC5CUkVBS2A6IFRlcm1pbmF0ZSB0cmF2ZXJzYWwgY29tcGxldGVseVxuICogICAtIGB2aXNpdC5SRU1PVkVgOiBSZW1vdmUgdGhlIGN1cnJlbnQgaXRlbSwgdGhlbiBjb250aW51ZSB3aXRoIHRoZSBuZXh0IG9uZVxuICogICAtIGBudW1iZXJgOiBTZXQgdGhlIGluZGV4IG9mIHRoZSBuZXh0IHN0ZXAuIFRoaXMgaXMgdXNlZnVsIGVzcGVjaWFsbHkgaWZcbiAqICAgICB0aGUgaW5kZXggb2YgdGhlIGN1cnJlbnQgdG9rZW4gaGFzIGNoYW5nZWQuXG4gKiAgIC0gYGZ1bmN0aW9uYDogRGVmaW5lIHRoZSBuZXh0IHZpc2l0b3IgZm9yIHRoaXMgaXRlbS4gQWZ0ZXIgdGhlIG9yaWdpbmFsXG4gKiAgICAgdmlzaXRvciBpcyBjYWxsZWQgb24gaXRlbSBlbnRyeSwgbmV4dCB2aXNpdG9ycyBhcmUgY2FsbGVkIGFmdGVyIGhhbmRsaW5nXG4gKiAgICAgYSBub24tZW1wdHkgYGtleWAgYW5kIHdoZW4gZXhpdGluZyB0aGUgaXRlbS5cbiAqL1xuZnVuY3Rpb24gdmlzaXQoY3N0LCB2aXNpdG9yKSB7XG4gICAgaWYgKCd0eXBlJyBpbiBjc3QgJiYgY3N0LnR5cGUgPT09ICdkb2N1bWVudCcpXG4gICAgICAgIGNzdCA9IHsgc3RhcnQ6IGNzdC5zdGFydCwgdmFsdWU6IGNzdC52YWx1ZSB9O1xuICAgIF92aXNpdChPYmplY3QuZnJlZXplKFtdKSwgY3N0LCB2aXNpdG9yKTtcbn1cbi8vIFdpdGhvdXQgdGhlIGBhcyBzeW1ib2xgIGNhc3RzLCBUUyBkZWNsYXJlcyB0aGVzZSBpbiB0aGUgYHZpc2l0YFxuLy8gbmFtZXNwYWNlIHVzaW5nIGB2YXJgLCBidXQgdGhlbiBjb21wbGFpbnMgYWJvdXQgdGhhdCBiZWNhdXNlXG4vLyBgdW5pcXVlIHN5bWJvbGAgbXVzdCBiZSBgY29uc3RgLlxuLyoqIFRlcm1pbmF0ZSB2aXNpdCB0cmF2ZXJzYWwgY29tcGxldGVseSAqL1xudmlzaXQuQlJFQUsgPSBCUkVBSztcbi8qKiBEbyBub3QgdmlzaXQgdGhlIGNoaWxkcmVuIG9mIHRoZSBjdXJyZW50IGl0ZW0gKi9cbnZpc2l0LlNLSVAgPSBTS0lQO1xuLyoqIFJlbW92ZSB0aGUgY3VycmVudCBpdGVtICovXG52aXNpdC5SRU1PVkUgPSBSRU1PVkU7XG4vKiogRmluZCB0aGUgaXRlbSBhdCBgcGF0aGAgZnJvbSBgY3N0YCBhcyB0aGUgcm9vdCAqL1xudmlzaXQuaXRlbUF0UGF0aCA9IChjc3QsIHBhdGgpID0+IHtcbiAgICBsZXQgaXRlbSA9IGNzdDtcbiAgICBmb3IgKGNvbnN0IFtmaWVsZCwgaW5kZXhdIG9mIHBhdGgpIHtcbiAgICAgICAgY29uc3QgdG9rID0gaXRlbSAmJiBpdGVtW2ZpZWxkXTtcbiAgICAgICAgaWYgKHRvayAmJiAnaXRlbXMnIGluIHRvaykge1xuICAgICAgICAgICAgaXRlbSA9IHRvay5pdGVtc1tpbmRleF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIGl0ZW07XG59O1xuLyoqXG4gKiBHZXQgdGhlIGltbWVkaWF0ZSBwYXJlbnQgY29sbGVjdGlvbiBvZiB0aGUgaXRlbSBhdCBgcGF0aGAgZnJvbSBgY3N0YCBhcyB0aGUgcm9vdC5cbiAqXG4gKiBUaHJvd3MgYW4gZXJyb3IgaWYgdGhlIGNvbGxlY3Rpb24gaXMgbm90IGZvdW5kLCB3aGljaCBzaG91bGQgbmV2ZXIgaGFwcGVuIGlmIHRoZSBpdGVtIGl0c2VsZiBleGlzdHMuXG4gKi9cbnZpc2l0LnBhcmVudENvbGxlY3Rpb24gPSAoY3N0LCBwYXRoKSA9PiB7XG4gICAgY29uc3QgcGFyZW50ID0gdmlzaXQuaXRlbUF0UGF0aChjc3QsIHBhdGguc2xpY2UoMCwgLTEpKTtcbiAgICBjb25zdCBmaWVsZCA9IHBhdGhbcGF0aC5sZW5ndGggLSAxXVswXTtcbiAgICBjb25zdCBjb2xsID0gcGFyZW50ICYmIHBhcmVudFtmaWVsZF07XG4gICAgaWYgKGNvbGwgJiYgJ2l0ZW1zJyBpbiBjb2xsKVxuICAgICAgICByZXR1cm4gY29sbDtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1BhcmVudCBjb2xsZWN0aW9uIG5vdCBmb3VuZCcpO1xufTtcbmZ1bmN0aW9uIF92aXNpdChwYXRoLCBpdGVtLCB2aXNpdG9yKSB7XG4gICAgbGV0IGN0cmwgPSB2aXNpdG9yKGl0ZW0sIHBhdGgpO1xuICAgIGlmICh0eXBlb2YgY3RybCA9PT0gJ3N5bWJvbCcpXG4gICAgICAgIHJldHVybiBjdHJsO1xuICAgIGZvciAoY29uc3QgZmllbGQgb2YgWydrZXknLCAndmFsdWUnXSkge1xuICAgICAgICBjb25zdCB0b2tlbiA9IGl0ZW1bZmllbGRdO1xuICAgICAgICBpZiAodG9rZW4gJiYgJ2l0ZW1zJyBpbiB0b2tlbikge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b2tlbi5pdGVtcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNpID0gX3Zpc2l0KE9iamVjdC5mcmVlemUocGF0aC5jb25jYXQoW1tmaWVsZCwgaV1dKSksIHRva2VuLml0ZW1zW2ldLCB2aXNpdG9yKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNpID09PSAnbnVtYmVyJylcbiAgICAgICAgICAgICAgICAgICAgaSA9IGNpIC0gMTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjaSA9PT0gQlJFQUspXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBCUkVBSztcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjaSA9PT0gUkVNT1ZFKSB7XG4gICAgICAgICAgICAgICAgICAgIHRva2VuLml0ZW1zLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgaSAtPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgY3RybCA9PT0gJ2Z1bmN0aW9uJyAmJiBmaWVsZCA9PT0gJ2tleScpXG4gICAgICAgICAgICAgICAgY3RybCA9IGN0cmwoaXRlbSwgcGF0aCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHR5cGVvZiBjdHJsID09PSAnZnVuY3Rpb24nID8gY3RybChpdGVtLCBwYXRoKSA6IGN0cmw7XG59XG5cbmV4cG9ydCB7IHZpc2l0IH07XG4iLCAiaW1wb3J0IHsgQk9NLCBET0NVTUVOVCwgRkxPV19FTkQsIFNDQUxBUiB9IGZyb20gJy4vY3N0LmpzJztcblxuLypcblNUQVJUIC0+IHN0cmVhbVxuXG5zdHJlYW1cbiAgZGlyZWN0aXZlIC0+IGxpbmUtZW5kIC0+IHN0cmVhbVxuICBpbmRlbnQgKyBsaW5lLWVuZCAtPiBzdHJlYW1cbiAgW2Vsc2VdIC0+IGxpbmUtc3RhcnRcblxubGluZS1lbmRcbiAgY29tbWVudCAtPiBsaW5lLWVuZFxuICBuZXdsaW5lIC0+IC5cbiAgaW5wdXQtZW5kIC0+IEVORFxuXG5saW5lLXN0YXJ0XG4gIGRvYy1zdGFydCAtPiBkb2NcbiAgZG9jLWVuZCAtPiBzdHJlYW1cbiAgW2Vsc2VdIC0+IGluZGVudCAtPiBibG9jay1zdGFydFxuXG5ibG9jay1zdGFydFxuICBzZXEtaXRlbS1zdGFydCAtPiBibG9jay1zdGFydFxuICBleHBsaWNpdC1rZXktc3RhcnQgLT4gYmxvY2stc3RhcnRcbiAgbWFwLXZhbHVlLXN0YXJ0IC0+IGJsb2NrLXN0YXJ0XG4gIFtlbHNlXSAtPiBkb2NcblxuZG9jXG4gIGxpbmUtZW5kIC0+IGxpbmUtc3RhcnRcbiAgc3BhY2VzIC0+IGRvY1xuICBhbmNob3IgLT4gZG9jXG4gIHRhZyAtPiBkb2NcbiAgZmxvdy1zdGFydCAtPiBmbG93IC0+IGRvY1xuICBmbG93LWVuZCAtPiBlcnJvciAtPiBkb2NcbiAgc2VxLWl0ZW0tc3RhcnQgLT4gZXJyb3IgLT4gZG9jXG4gIGV4cGxpY2l0LWtleS1zdGFydCAtPiBlcnJvciAtPiBkb2NcbiAgbWFwLXZhbHVlLXN0YXJ0IC0+IGRvY1xuICBhbGlhcyAtPiBkb2NcbiAgcXVvdGUtc3RhcnQgLT4gcXVvdGVkLXNjYWxhciAtPiBkb2NcbiAgYmxvY2stc2NhbGFyLWhlYWRlciAtPiBsaW5lLWVuZCAtPiBibG9jay1zY2FsYXIobWluKSAtPiBsaW5lLXN0YXJ0XG4gIFtlbHNlXSAtPiBwbGFpbi1zY2FsYXIoZmFsc2UsIG1pbikgLT4gZG9jXG5cbmZsb3dcbiAgbGluZS1lbmQgLT4gZmxvd1xuICBzcGFjZXMgLT4gZmxvd1xuICBhbmNob3IgLT4gZmxvd1xuICB0YWcgLT4gZmxvd1xuICBmbG93LXN0YXJ0IC0+IGZsb3cgLT4gZmxvd1xuICBmbG93LWVuZCAtPiAuXG4gIHNlcS1pdGVtLXN0YXJ0IC0+IGVycm9yIC0+IGZsb3dcbiAgZXhwbGljaXQta2V5LXN0YXJ0IC0+IGZsb3dcbiAgbWFwLXZhbHVlLXN0YXJ0IC0+IGZsb3dcbiAgYWxpYXMgLT4gZmxvd1xuICBxdW90ZS1zdGFydCAtPiBxdW90ZWQtc2NhbGFyIC0+IGZsb3dcbiAgY29tbWEgLT4gZmxvd1xuICBbZWxzZV0gLT4gcGxhaW4tc2NhbGFyKHRydWUsIDApIC0+IGZsb3dcblxucXVvdGVkLXNjYWxhclxuICBxdW90ZS1lbmQgLT4gLlxuICBbZWxzZV0gLT4gcXVvdGVkLXNjYWxhclxuXG5ibG9jay1zY2FsYXIobWluKVxuICBuZXdsaW5lICsgcGVlayhpbmRlbnQgPCBtaW4pIC0+IC5cbiAgW2Vsc2VdIC0+IGJsb2NrLXNjYWxhcihtaW4pXG5cbnBsYWluLXNjYWxhcihpcy1mbG93LCBtaW4pXG4gIHNjYWxhci1lbmQoaXMtZmxvdykgLT4gLlxuICBwZWVrKG5ld2xpbmUgKyAoaW5kZW50IDwgbWluKSkgLT4gLlxuICBbZWxzZV0gLT4gcGxhaW4tc2NhbGFyKG1pbilcbiovXG5mdW5jdGlvbiBpc0VtcHR5KGNoKSB7XG4gICAgc3dpdGNoIChjaCkge1xuICAgICAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgICAgY2FzZSAnICc6XG4gICAgICAgIGNhc2UgJ1xcbic6XG4gICAgICAgIGNhc2UgJ1xccic6XG4gICAgICAgIGNhc2UgJ1xcdCc6XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5jb25zdCBoZXhEaWdpdHMgPSAnMDEyMzQ1Njc4OUFCQ0RFRmFiY2RlZicuc3BsaXQoJycpO1xuY29uc3QgdGFnQ2hhcnMgPSBcIjAxMjM0NTY3ODlBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6LSM7Lz86QCY9KyRfLiF+KicoKVwiLnNwbGl0KCcnKTtcbmNvbnN0IGludmFsaWRGbG93U2NhbGFyQ2hhcnMgPSAnLFtde30nLnNwbGl0KCcnKTtcbmNvbnN0IGludmFsaWRBbmNob3JDaGFycyA9ICcgLFtde31cXG5cXHJcXHQnLnNwbGl0KCcnKTtcbmNvbnN0IGlzTm90QW5jaG9yQ2hhciA9IChjaCkgPT4gIWNoIHx8IGludmFsaWRBbmNob3JDaGFycy5pbmNsdWRlcyhjaCk7XG4vKipcbiAqIFNwbGl0cyBhbiBpbnB1dCBzdHJpbmcgaW50byBsZXhpY2FsIHRva2VucywgaS5lLiBzbWFsbGVyIHN0cmluZ3MgdGhhdCBhcmVcbiAqIGVhc2lseSBpZGVudGlmaWFibGUgYnkgYHRva2Vucy50b2tlblR5cGUoKWAuXG4gKlxuICogTGV4aW5nIHN0YXJ0cyBhbHdheXMgaW4gYSBcInN0cmVhbVwiIGNvbnRleHQuIEluY29tcGxldGUgaW5wdXQgbWF5IGJlIGJ1ZmZlcmVkXG4gKiB1bnRpbCBhIGNvbXBsZXRlIHRva2VuIGNhbiBiZSBlbWl0dGVkLlxuICpcbiAqIEluIGFkZGl0aW9uIHRvIHNsaWNlcyBvZiB0aGUgb3JpZ2luYWwgaW5wdXQsIHRoZSBmb2xsb3dpbmcgY29udHJvbCBjaGFyYWN0ZXJzXG4gKiBtYXkgYWxzbyBiZSBlbWl0dGVkOlxuICpcbiAqIC0gYFxceDAyYCAoU3RhcnQgb2YgVGV4dCk6IEEgZG9jdW1lbnQgc3RhcnRzIHdpdGggdGhlIG5leHQgdG9rZW5cbiAqIC0gYFxceDE4YCAoQ2FuY2VsKTogVW5leHBlY3RlZCBlbmQgb2YgZmxvdy1tb2RlIChpbmRpY2F0ZXMgYW4gZXJyb3IpXG4gKiAtIGBcXHgxZmAgKFVuaXQgU2VwYXJhdG9yKTogTmV4dCB0b2tlbiBpcyBhIHNjYWxhciB2YWx1ZVxuICogLSBgXFx1e0ZFRkZ9YCAoQnl0ZSBvcmRlciBtYXJrKTogRW1pdHRlZCBzZXBhcmF0ZWx5IG91dHNpZGUgZG9jdW1lbnRzXG4gKi9cbmNsYXNzIExleGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZsYWcgaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBlbmQgb2YgdGhlIGN1cnJlbnQgYnVmZmVyIG1hcmtzIHRoZSBlbmQgb2ZcbiAgICAgICAgICogYWxsIGlucHV0XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmF0RW5kID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFeHBsaWNpdCBpbmRlbnQgc2V0IGluIGJsb2NrIHNjYWxhciBoZWFkZXIsIGFzIGFuIG9mZnNldCBmcm9tIHRoZSBjdXJyZW50XG4gICAgICAgICAqIG1pbmltdW0gaW5kZW50LCBzbyBlLmcuIHNldCB0byAxIGZyb20gYSBoZWFkZXIgYHwyK2AuIFNldCB0byAtMSBpZiBub3RcbiAgICAgICAgICogZXhwbGljaXRseSBzZXQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmJsb2NrU2NhbGFySW5kZW50ID0gLTE7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBCbG9jayBzY2FsYXJzIHRoYXQgaW5jbHVkZSBhICsgKGtlZXApIGNob21waW5nIGluZGljYXRvciBpbiB0aGVpciBoZWFkZXJcbiAgICAgICAgICogaW5jbHVkZSB0cmFpbGluZyBlbXB0eSBsaW5lcywgd2hpY2ggYXJlIG90aGVyd2lzZSBleGNsdWRlZCBmcm9tIHRoZVxuICAgICAgICAgKiBzY2FsYXIncyBjb250ZW50cy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYmxvY2tTY2FsYXJLZWVwID0gZmFsc2U7XG4gICAgICAgIC8qKiBDdXJyZW50IGlucHV0ICovXG4gICAgICAgIHRoaXMuYnVmZmVyID0gJyc7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGbGFnIG5vdGluZyB3aGV0aGVyIHRoZSBtYXAgdmFsdWUgaW5kaWNhdG9yIDogY2FuIGltbWVkaWF0ZWx5IGZvbGxvdyB0aGlzXG4gICAgICAgICAqIG5vZGUgd2l0aGluIGEgZmxvdyBjb250ZXh0LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5mbG93S2V5ID0gZmFsc2U7XG4gICAgICAgIC8qKiBDb3VudCBvZiBzdXJyb3VuZGluZyBmbG93IGNvbGxlY3Rpb24gbGV2ZWxzLiAqL1xuICAgICAgICB0aGlzLmZsb3dMZXZlbCA9IDA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNaW5pbXVtIGxldmVsIG9mIGluZGVudGF0aW9uIHJlcXVpcmVkIGZvciBuZXh0IGxpbmVzIHRvIGJlIHBhcnNlZCBhcyBhXG4gICAgICAgICAqIHBhcnQgb2YgdGhlIGN1cnJlbnQgc2NhbGFyIHZhbHVlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pbmRlbnROZXh0ID0gMDtcbiAgICAgICAgLyoqIEluZGVudGF0aW9uIGxldmVsIG9mIHRoZSBjdXJyZW50IGxpbmUuICovXG4gICAgICAgIHRoaXMuaW5kZW50VmFsdWUgPSAwO1xuICAgICAgICAvKiogUG9zaXRpb24gb2YgdGhlIG5leHQgXFxuIGNoYXJhY3Rlci4gKi9cbiAgICAgICAgdGhpcy5saW5lRW5kUG9zID0gbnVsbDtcbiAgICAgICAgLyoqIFN0b3JlcyB0aGUgc3RhdGUgb2YgdGhlIGxleGVyIGlmIHJlYWNoaW5nIHRoZSBlbmQgb2YgaW5jcG9tcGxldGUgaW5wdXQgKi9cbiAgICAgICAgdGhpcy5uZXh0ID0gbnVsbDtcbiAgICAgICAgLyoqIEEgcG9pbnRlciB0byBgYnVmZmVyYDsgdGhlIGN1cnJlbnQgcG9zaXRpb24gb2YgdGhlIGxleGVyLiAqL1xuICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlIFlBTUwgdG9rZW5zIGZyb20gdGhlIGBzb3VyY2VgIHN0cmluZy4gSWYgYGluY29tcGxldGVgLFxuICAgICAqIGEgcGFydCBvZiB0aGUgbGFzdCBsaW5lIG1heSBiZSBsZWZ0IGFzIGEgYnVmZmVyIGZvciB0aGUgbmV4dCBjYWxsLlxuICAgICAqXG4gICAgICogQHJldHVybnMgQSBnZW5lcmF0b3Igb2YgbGV4aWNhbCB0b2tlbnNcbiAgICAgKi9cbiAgICAqbGV4KHNvdXJjZSwgaW5jb21wbGV0ZSA9IGZhbHNlKSB7XG4gICAgICAgIGlmIChzb3VyY2UpIHtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyID0gdGhpcy5idWZmZXIgPyB0aGlzLmJ1ZmZlciArIHNvdXJjZSA6IHNvdXJjZTtcbiAgICAgICAgICAgIHRoaXMubGluZUVuZFBvcyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hdEVuZCA9ICFpbmNvbXBsZXRlO1xuICAgICAgICBsZXQgbmV4dCA9IHRoaXMubmV4dCB8fCAnc3RyZWFtJztcbiAgICAgICAgd2hpbGUgKG5leHQgJiYgKGluY29tcGxldGUgfHwgdGhpcy5oYXNDaGFycygxKSkpXG4gICAgICAgICAgICBuZXh0ID0geWllbGQqIHRoaXMucGFyc2VOZXh0KG5leHQpO1xuICAgIH1cbiAgICBhdExpbmVFbmQoKSB7XG4gICAgICAgIGxldCBpID0gdGhpcy5wb3M7XG4gICAgICAgIGxldCBjaCA9IHRoaXMuYnVmZmVyW2ldO1xuICAgICAgICB3aGlsZSAoY2ggPT09ICcgJyB8fCBjaCA9PT0gJ1xcdCcpXG4gICAgICAgICAgICBjaCA9IHRoaXMuYnVmZmVyWysraV07XG4gICAgICAgIGlmICghY2ggfHwgY2ggPT09ICcjJyB8fCBjaCA9PT0gJ1xcbicpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKGNoID09PSAnXFxyJylcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJ1ZmZlcltpICsgMV0gPT09ICdcXG4nO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNoYXJBdChuKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJ1ZmZlclt0aGlzLnBvcyArIG5dO1xuICAgIH1cbiAgICBjb250aW51ZVNjYWxhcihvZmZzZXQpIHtcbiAgICAgICAgbGV0IGNoID0gdGhpcy5idWZmZXJbb2Zmc2V0XTtcbiAgICAgICAgaWYgKHRoaXMuaW5kZW50TmV4dCA+IDApIHtcbiAgICAgICAgICAgIGxldCBpbmRlbnQgPSAwO1xuICAgICAgICAgICAgd2hpbGUgKGNoID09PSAnICcpXG4gICAgICAgICAgICAgICAgY2ggPSB0aGlzLmJ1ZmZlclsrK2luZGVudCArIG9mZnNldF07XG4gICAgICAgICAgICBpZiAoY2ggPT09ICdcXHInKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dCA9IHRoaXMuYnVmZmVyW2luZGVudCArIG9mZnNldCArIDFdO1xuICAgICAgICAgICAgICAgIGlmIChuZXh0ID09PSAnXFxuJyB8fCAoIW5leHQgJiYgIXRoaXMuYXRFbmQpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2Zmc2V0ICsgaW5kZW50ICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjaCA9PT0gJ1xcbicgfHwgaW5kZW50ID49IHRoaXMuaW5kZW50TmV4dCB8fCAoIWNoICYmICF0aGlzLmF0RW5kKVxuICAgICAgICAgICAgICAgID8gb2Zmc2V0ICsgaW5kZW50XG4gICAgICAgICAgICAgICAgOiAtMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2ggPT09ICctJyB8fCBjaCA9PT0gJy4nKSB7XG4gICAgICAgICAgICBjb25zdCBkdCA9IHRoaXMuYnVmZmVyLnN1YnN0cihvZmZzZXQsIDMpO1xuICAgICAgICAgICAgaWYgKChkdCA9PT0gJy0tLScgfHwgZHQgPT09ICcuLi4nKSAmJiBpc0VtcHR5KHRoaXMuYnVmZmVyW29mZnNldCArIDNdKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9mZnNldDtcbiAgICB9XG4gICAgZ2V0TGluZSgpIHtcbiAgICAgICAgbGV0IGVuZCA9IHRoaXMubGluZUVuZFBvcztcbiAgICAgICAgaWYgKHR5cGVvZiBlbmQgIT09ICdudW1iZXInIHx8IChlbmQgIT09IC0xICYmIGVuZCA8IHRoaXMucG9zKSkge1xuICAgICAgICAgICAgZW5kID0gdGhpcy5idWZmZXIuaW5kZXhPZignXFxuJywgdGhpcy5wb3MpO1xuICAgICAgICAgICAgdGhpcy5saW5lRW5kUG9zID0gZW5kO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbmQgPT09IC0xKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXRFbmQgPyB0aGlzLmJ1ZmZlci5zdWJzdHJpbmcodGhpcy5wb3MpIDogbnVsbDtcbiAgICAgICAgaWYgKHRoaXMuYnVmZmVyW2VuZCAtIDFdID09PSAnXFxyJylcbiAgICAgICAgICAgIGVuZCAtPSAxO1xuICAgICAgICByZXR1cm4gdGhpcy5idWZmZXIuc3Vic3RyaW5nKHRoaXMucG9zLCBlbmQpO1xuICAgIH1cbiAgICBoYXNDaGFycyhuKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBvcyArIG4gPD0gdGhpcy5idWZmZXIubGVuZ3RoO1xuICAgIH1cbiAgICBzZXROZXh0KHN0YXRlKSB7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gdGhpcy5idWZmZXIuc3Vic3RyaW5nKHRoaXMucG9zKTtcbiAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgICAgICB0aGlzLmxpbmVFbmRQb3MgPSBudWxsO1xuICAgICAgICB0aGlzLm5leHQgPSBzdGF0ZTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHBlZWsobikge1xuICAgICAgICByZXR1cm4gdGhpcy5idWZmZXIuc3Vic3RyKHRoaXMucG9zLCBuKTtcbiAgICB9XG4gICAgKnBhcnNlTmV4dChuZXh0KSB7XG4gICAgICAgIHN3aXRjaCAobmV4dCkge1xuICAgICAgICAgICAgY2FzZSAnc3RyZWFtJzpcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQqIHRoaXMucGFyc2VTdHJlYW0oKTtcbiAgICAgICAgICAgIGNhc2UgJ2xpbmUtc3RhcnQnOlxuICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCogdGhpcy5wYXJzZUxpbmVTdGFydCgpO1xuICAgICAgICAgICAgY2FzZSAnYmxvY2stc3RhcnQnOlxuICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCogdGhpcy5wYXJzZUJsb2NrU3RhcnQoKTtcbiAgICAgICAgICAgIGNhc2UgJ2RvYyc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkKiB0aGlzLnBhcnNlRG9jdW1lbnQoKTtcbiAgICAgICAgICAgIGNhc2UgJ2Zsb3cnOlxuICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCogdGhpcy5wYXJzZUZsb3dDb2xsZWN0aW9uKCk7XG4gICAgICAgICAgICBjYXNlICdxdW90ZWQtc2NhbGFyJzpcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQqIHRoaXMucGFyc2VRdW90ZWRTY2FsYXIoKTtcbiAgICAgICAgICAgIGNhc2UgJ2Jsb2NrLXNjYWxhcic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkKiB0aGlzLnBhcnNlQmxvY2tTY2FsYXIoKTtcbiAgICAgICAgICAgIGNhc2UgJ3BsYWluLXNjYWxhcic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkKiB0aGlzLnBhcnNlUGxhaW5TY2FsYXIoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAqcGFyc2VTdHJlYW0oKSB7XG4gICAgICAgIGxldCBsaW5lID0gdGhpcy5nZXRMaW5lKCk7XG4gICAgICAgIGlmIChsaW5lID09PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0TmV4dCgnc3RyZWFtJyk7XG4gICAgICAgIGlmIChsaW5lWzBdID09PSBCT00pIHtcbiAgICAgICAgICAgIHlpZWxkKiB0aGlzLnB1c2hDb3VudCgxKTtcbiAgICAgICAgICAgIGxpbmUgPSBsaW5lLnN1YnN0cmluZygxKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGluZVswXSA9PT0gJyUnKSB7XG4gICAgICAgICAgICBsZXQgZGlyRW5kID0gbGluZS5sZW5ndGg7XG4gICAgICAgICAgICBjb25zdCBjcyA9IGxpbmUuaW5kZXhPZignIycpO1xuICAgICAgICAgICAgaWYgKGNzICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoID0gbGluZVtjcyAtIDFdO1xuICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJyAnIHx8IGNoID09PSAnXFx0JylcbiAgICAgICAgICAgICAgICAgICAgZGlyRW5kID0gY3MgLSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaCA9IGxpbmVbZGlyRW5kIC0gMV07XG4gICAgICAgICAgICAgICAgaWYgKGNoID09PSAnICcgfHwgY2ggPT09ICdcXHQnKVxuICAgICAgICAgICAgICAgICAgICBkaXJFbmQgLT0gMTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbiA9ICh5aWVsZCogdGhpcy5wdXNoQ291bnQoZGlyRW5kKSkgKyAoeWllbGQqIHRoaXMucHVzaFNwYWNlcyh0cnVlKSk7XG4gICAgICAgICAgICB5aWVsZCogdGhpcy5wdXNoQ291bnQobGluZS5sZW5ndGggLSBuKTsgLy8gcG9zc2libGUgY29tbWVudFxuICAgICAgICAgICAgdGhpcy5wdXNoTmV3bGluZSgpO1xuICAgICAgICAgICAgcmV0dXJuICdzdHJlYW0nO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmF0TGluZUVuZCgpKSB7XG4gICAgICAgICAgICBjb25zdCBzcCA9IHlpZWxkKiB0aGlzLnB1c2hTcGFjZXModHJ1ZSk7XG4gICAgICAgICAgICB5aWVsZCogdGhpcy5wdXNoQ291bnQobGluZS5sZW5ndGggLSBzcCk7XG4gICAgICAgICAgICB5aWVsZCogdGhpcy5wdXNoTmV3bGluZSgpO1xuICAgICAgICAgICAgcmV0dXJuICdzdHJlYW0nO1xuICAgICAgICB9XG4gICAgICAgIHlpZWxkIERPQ1VNRU5UO1xuICAgICAgICByZXR1cm4geWllbGQqIHRoaXMucGFyc2VMaW5lU3RhcnQoKTtcbiAgICB9XG4gICAgKnBhcnNlTGluZVN0YXJ0KCkge1xuICAgICAgICBjb25zdCBjaCA9IHRoaXMuY2hhckF0KDApO1xuICAgICAgICBpZiAoIWNoICYmICF0aGlzLmF0RW5kKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0TmV4dCgnbGluZS1zdGFydCcpO1xuICAgICAgICBpZiAoY2ggPT09ICctJyB8fCBjaCA9PT0gJy4nKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuYXRFbmQgJiYgIXRoaXMuaGFzQ2hhcnMoNCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0TmV4dCgnbGluZS1zdGFydCcpO1xuICAgICAgICAgICAgY29uc3QgcyA9IHRoaXMucGVlaygzKTtcbiAgICAgICAgICAgIGlmIChzID09PSAnLS0tJyAmJiBpc0VtcHR5KHRoaXMuY2hhckF0KDMpKSkge1xuICAgICAgICAgICAgICAgIHlpZWxkKiB0aGlzLnB1c2hDb3VudCgzKTtcbiAgICAgICAgICAgICAgICB0aGlzLmluZGVudFZhbHVlID0gMDtcbiAgICAgICAgICAgICAgICB0aGlzLmluZGVudE5leHQgPSAwO1xuICAgICAgICAgICAgICAgIHJldHVybiAnZG9jJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHMgPT09ICcuLi4nICYmIGlzRW1wdHkodGhpcy5jaGFyQXQoMykpKSB7XG4gICAgICAgICAgICAgICAgeWllbGQqIHRoaXMucHVzaENvdW50KDMpO1xuICAgICAgICAgICAgICAgIHJldHVybiAnc3RyZWFtJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmluZGVudFZhbHVlID0geWllbGQqIHRoaXMucHVzaFNwYWNlcyhmYWxzZSk7XG4gICAgICAgIGlmICh0aGlzLmluZGVudE5leHQgPiB0aGlzLmluZGVudFZhbHVlICYmICFpc0VtcHR5KHRoaXMuY2hhckF0KDEpKSlcbiAgICAgICAgICAgIHRoaXMuaW5kZW50TmV4dCA9IHRoaXMuaW5kZW50VmFsdWU7XG4gICAgICAgIHJldHVybiB5aWVsZCogdGhpcy5wYXJzZUJsb2NrU3RhcnQoKTtcbiAgICB9XG4gICAgKnBhcnNlQmxvY2tTdGFydCgpIHtcbiAgICAgICAgY29uc3QgW2NoMCwgY2gxXSA9IHRoaXMucGVlaygyKTtcbiAgICAgICAgaWYgKCFjaDEgJiYgIXRoaXMuYXRFbmQpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZXROZXh0KCdibG9jay1zdGFydCcpO1xuICAgICAgICBpZiAoKGNoMCA9PT0gJy0nIHx8IGNoMCA9PT0gJz8nIHx8IGNoMCA9PT0gJzonKSAmJiBpc0VtcHR5KGNoMSkpIHtcbiAgICAgICAgICAgIGNvbnN0IG4gPSAoeWllbGQqIHRoaXMucHVzaENvdW50KDEpKSArICh5aWVsZCogdGhpcy5wdXNoU3BhY2VzKHRydWUpKTtcbiAgICAgICAgICAgIHRoaXMuaW5kZW50TmV4dCA9IHRoaXMuaW5kZW50VmFsdWUgKyAxO1xuICAgICAgICAgICAgdGhpcy5pbmRlbnRWYWx1ZSArPSBuO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkKiB0aGlzLnBhcnNlQmxvY2tTdGFydCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnZG9jJztcbiAgICB9XG4gICAgKnBhcnNlRG9jdW1lbnQoKSB7XG4gICAgICAgIHlpZWxkKiB0aGlzLnB1c2hTcGFjZXModHJ1ZSk7XG4gICAgICAgIGNvbnN0IGxpbmUgPSB0aGlzLmdldExpbmUoKTtcbiAgICAgICAgaWYgKGxpbmUgPT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZXROZXh0KCdkb2MnKTtcbiAgICAgICAgbGV0IG4gPSB5aWVsZCogdGhpcy5wdXNoSW5kaWNhdG9ycygpO1xuICAgICAgICBzd2l0Y2ggKGxpbmVbbl0pIHtcbiAgICAgICAgICAgIGNhc2UgJyMnOlxuICAgICAgICAgICAgICAgIHlpZWxkKiB0aGlzLnB1c2hDb3VudChsaW5lLmxlbmd0aCAtIG4pO1xuICAgICAgICAgICAgLy8gZmFsbHRocm91Z2hcbiAgICAgICAgICAgIGNhc2UgdW5kZWZpbmVkOlxuICAgICAgICAgICAgICAgIHlpZWxkKiB0aGlzLnB1c2hOZXdsaW5lKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkKiB0aGlzLnBhcnNlTGluZVN0YXJ0KCk7XG4gICAgICAgICAgICBjYXNlICd7JzpcbiAgICAgICAgICAgIGNhc2UgJ1snOlxuICAgICAgICAgICAgICAgIHlpZWxkKiB0aGlzLnB1c2hDb3VudCgxKTtcbiAgICAgICAgICAgICAgICB0aGlzLmZsb3dLZXkgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLmZsb3dMZXZlbCA9IDE7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdmbG93JztcbiAgICAgICAgICAgIGNhc2UgJ30nOlxuICAgICAgICAgICAgY2FzZSAnXSc6XG4gICAgICAgICAgICAgICAgLy8gdGhpcyBpcyBhbiBlcnJvclxuICAgICAgICAgICAgICAgIHlpZWxkKiB0aGlzLnB1c2hDb3VudCgxKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2RvYyc7XG4gICAgICAgICAgICBjYXNlICcqJzpcbiAgICAgICAgICAgICAgICB5aWVsZCogdGhpcy5wdXNoVW50aWwoaXNOb3RBbmNob3JDaGFyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2RvYyc7XG4gICAgICAgICAgICBjYXNlICdcIic6XG4gICAgICAgICAgICBjYXNlIFwiJ1wiOlxuICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCogdGhpcy5wYXJzZVF1b3RlZFNjYWxhcigpO1xuICAgICAgICAgICAgY2FzZSAnfCc6XG4gICAgICAgICAgICBjYXNlICc+JzpcbiAgICAgICAgICAgICAgICBuICs9IHlpZWxkKiB0aGlzLnBhcnNlQmxvY2tTY2FsYXJIZWFkZXIoKTtcbiAgICAgICAgICAgICAgICBuICs9IHlpZWxkKiB0aGlzLnB1c2hTcGFjZXModHJ1ZSk7XG4gICAgICAgICAgICAgICAgeWllbGQqIHRoaXMucHVzaENvdW50KGxpbmUubGVuZ3RoIC0gbik7XG4gICAgICAgICAgICAgICAgeWllbGQqIHRoaXMucHVzaE5ld2xpbmUoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQqIHRoaXMucGFyc2VCbG9ja1NjYWxhcigpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQqIHRoaXMucGFyc2VQbGFpblNjYWxhcigpO1xuICAgICAgICB9XG4gICAgfVxuICAgICpwYXJzZUZsb3dDb2xsZWN0aW9uKCkge1xuICAgICAgICBsZXQgbmwsIHNwO1xuICAgICAgICBsZXQgaW5kZW50ID0gLTE7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIG5sID0geWllbGQqIHRoaXMucHVzaE5ld2xpbmUoKTtcbiAgICAgICAgICAgIHNwID0geWllbGQqIHRoaXMucHVzaFNwYWNlcyh0cnVlKTtcbiAgICAgICAgICAgIGlmIChubCA+IDApXG4gICAgICAgICAgICAgICAgdGhpcy5pbmRlbnRWYWx1ZSA9IGluZGVudCA9IHNwO1xuICAgICAgICB9IHdoaWxlIChubCArIHNwID4gMCk7XG4gICAgICAgIGNvbnN0IGxpbmUgPSB0aGlzLmdldExpbmUoKTtcbiAgICAgICAgaWYgKGxpbmUgPT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZXROZXh0KCdmbG93Jyk7XG4gICAgICAgIGlmICgoaW5kZW50ICE9PSAtMSAmJiBpbmRlbnQgPCB0aGlzLmluZGVudE5leHQgJiYgbGluZVswXSAhPT0gJyMnKSB8fFxuICAgICAgICAgICAgKGluZGVudCA9PT0gMCAmJlxuICAgICAgICAgICAgICAgIChsaW5lLnN0YXJ0c1dpdGgoJy0tLScpIHx8IGxpbmUuc3RhcnRzV2l0aCgnLi4uJykpICYmXG4gICAgICAgICAgICAgICAgaXNFbXB0eShsaW5lWzNdKSkpIHtcbiAgICAgICAgICAgIC8vIEFsbG93aW5nIGZvciB0aGUgdGVybWluYWwgXSBvciB9IGF0IHRoZSBzYW1lIChyYXRoZXIgdGhhbiBncmVhdGVyKVxuICAgICAgICAgICAgLy8gaW5kZW50IGxldmVsIGFzIHRoZSBpbml0aWFsIFsgb3IgeyBpcyB0ZWNobmljYWxseSBpbnZhbGlkLCBidXRcbiAgICAgICAgICAgIC8vIGZhaWxpbmcgaGVyZSB3b3VsZCBiZSBzdXJwcmlzaW5nIHRvIHVzZXJzLlxuICAgICAgICAgICAgY29uc3QgYXRGbG93RW5kTWFya2VyID0gaW5kZW50ID09PSB0aGlzLmluZGVudE5leHQgLSAxICYmXG4gICAgICAgICAgICAgICAgdGhpcy5mbG93TGV2ZWwgPT09IDEgJiZcbiAgICAgICAgICAgICAgICAobGluZVswXSA9PT0gJ10nIHx8IGxpbmVbMF0gPT09ICd9Jyk7XG4gICAgICAgICAgICBpZiAoIWF0Rmxvd0VuZE1hcmtlcikge1xuICAgICAgICAgICAgICAgIC8vIHRoaXMgaXMgYW4gZXJyb3JcbiAgICAgICAgICAgICAgICB0aGlzLmZsb3dMZXZlbCA9IDA7XG4gICAgICAgICAgICAgICAgeWllbGQgRkxPV19FTkQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkKiB0aGlzLnBhcnNlTGluZVN0YXJ0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG4gPSAwO1xuICAgICAgICB3aGlsZSAobGluZVtuXSA9PT0gJywnKSB7XG4gICAgICAgICAgICBuICs9IHlpZWxkKiB0aGlzLnB1c2hDb3VudCgxKTtcbiAgICAgICAgICAgIG4gKz0geWllbGQqIHRoaXMucHVzaFNwYWNlcyh0cnVlKTtcbiAgICAgICAgICAgIHRoaXMuZmxvd0tleSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIG4gKz0geWllbGQqIHRoaXMucHVzaEluZGljYXRvcnMoKTtcbiAgICAgICAgc3dpdGNoIChsaW5lW25dKSB7XG4gICAgICAgICAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2Zsb3cnO1xuICAgICAgICAgICAgY2FzZSAnIyc6XG4gICAgICAgICAgICAgICAgeWllbGQqIHRoaXMucHVzaENvdW50KGxpbmUubGVuZ3RoIC0gbik7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdmbG93JztcbiAgICAgICAgICAgIGNhc2UgJ3snOlxuICAgICAgICAgICAgY2FzZSAnWyc6XG4gICAgICAgICAgICAgICAgeWllbGQqIHRoaXMucHVzaENvdW50KDEpO1xuICAgICAgICAgICAgICAgIHRoaXMuZmxvd0tleSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMuZmxvd0xldmVsICs9IDE7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdmbG93JztcbiAgICAgICAgICAgIGNhc2UgJ30nOlxuICAgICAgICAgICAgY2FzZSAnXSc6XG4gICAgICAgICAgICAgICAgeWllbGQqIHRoaXMucHVzaENvdW50KDEpO1xuICAgICAgICAgICAgICAgIHRoaXMuZmxvd0tleSA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5mbG93TGV2ZWwgLT0gMTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5mbG93TGV2ZWwgPyAnZmxvdycgOiAnZG9jJztcbiAgICAgICAgICAgIGNhc2UgJyonOlxuICAgICAgICAgICAgICAgIHlpZWxkKiB0aGlzLnB1c2hVbnRpbChpc05vdEFuY2hvckNoYXIpO1xuICAgICAgICAgICAgICAgIHJldHVybiAnZmxvdyc7XG4gICAgICAgICAgICBjYXNlICdcIic6XG4gICAgICAgICAgICBjYXNlIFwiJ1wiOlxuICAgICAgICAgICAgICAgIHRoaXMuZmxvd0tleSA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkKiB0aGlzLnBhcnNlUXVvdGVkU2NhbGFyKCk7XG4gICAgICAgICAgICBjYXNlICc6Jzoge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5leHQgPSB0aGlzLmNoYXJBdCgxKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5mbG93S2V5IHx8IGlzRW1wdHkobmV4dCkgfHwgbmV4dCA9PT0gJywnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmxvd0tleSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCogdGhpcy5wdXNoQ291bnQoMSk7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkKiB0aGlzLnB1c2hTcGFjZXModHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnZmxvdyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZmFsbHRocm91Z2hcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhpcy5mbG93S2V5ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkKiB0aGlzLnBhcnNlUGxhaW5TY2FsYXIoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAqcGFyc2VRdW90ZWRTY2FsYXIoKSB7XG4gICAgICAgIGNvbnN0IHF1b3RlID0gdGhpcy5jaGFyQXQoMCk7XG4gICAgICAgIGxldCBlbmQgPSB0aGlzLmJ1ZmZlci5pbmRleE9mKHF1b3RlLCB0aGlzLnBvcyArIDEpO1xuICAgICAgICBpZiAocXVvdGUgPT09IFwiJ1wiKSB7XG4gICAgICAgICAgICB3aGlsZSAoZW5kICE9PSAtMSAmJiB0aGlzLmJ1ZmZlcltlbmQgKyAxXSA9PT0gXCInXCIpXG4gICAgICAgICAgICAgICAgZW5kID0gdGhpcy5idWZmZXIuaW5kZXhPZihcIidcIiwgZW5kICsgMik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBkb3VibGUtcXVvdGVcbiAgICAgICAgICAgIHdoaWxlIChlbmQgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgbGV0IG4gPSAwO1xuICAgICAgICAgICAgICAgIHdoaWxlICh0aGlzLmJ1ZmZlcltlbmQgLSAxIC0gbl0gPT09ICdcXFxcJylcbiAgICAgICAgICAgICAgICAgICAgbiArPSAxO1xuICAgICAgICAgICAgICAgIGlmIChuICUgMiA9PT0gMClcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZW5kID0gdGhpcy5idWZmZXIuaW5kZXhPZignXCInLCBlbmQgKyAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBPbmx5IGxvb2tpbmcgZm9yIG5ld2xpbmVzIHdpdGhpbiB0aGUgcXVvdGVzXG4gICAgICAgIGNvbnN0IHFiID0gdGhpcy5idWZmZXIuc3Vic3RyaW5nKDAsIGVuZCk7XG4gICAgICAgIGxldCBubCA9IHFiLmluZGV4T2YoJ1xcbicsIHRoaXMucG9zKTtcbiAgICAgICAgaWYgKG5sICE9PSAtMSkge1xuICAgICAgICAgICAgd2hpbGUgKG5sICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNzID0gdGhpcy5jb250aW51ZVNjYWxhcihubCArIDEpO1xuICAgICAgICAgICAgICAgIGlmIChjcyA9PT0gLTEpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIG5sID0gcWIuaW5kZXhPZignXFxuJywgY3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5sICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIC8vIHRoaXMgaXMgYW4gZXJyb3IgY2F1c2VkIGJ5IGFuIHVuZXhwZWN0ZWQgdW5pbmRlbnRcbiAgICAgICAgICAgICAgICBlbmQgPSBubCAtIChxYltubCAtIDFdID09PSAnXFxyJyA/IDIgOiAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZW5kID09PSAtMSkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmF0RW5kKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNldE5leHQoJ3F1b3RlZC1zY2FsYXInKTtcbiAgICAgICAgICAgIGVuZCA9IHRoaXMuYnVmZmVyLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICB5aWVsZCogdGhpcy5wdXNoVG9JbmRleChlbmQgKyAxLCBmYWxzZSk7XG4gICAgICAgIHJldHVybiB0aGlzLmZsb3dMZXZlbCA/ICdmbG93JyA6ICdkb2MnO1xuICAgIH1cbiAgICAqcGFyc2VCbG9ja1NjYWxhckhlYWRlcigpIHtcbiAgICAgICAgdGhpcy5ibG9ja1NjYWxhckluZGVudCA9IC0xO1xuICAgICAgICB0aGlzLmJsb2NrU2NhbGFyS2VlcCA9IGZhbHNlO1xuICAgICAgICBsZXQgaSA9IHRoaXMucG9zO1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgY29uc3QgY2ggPSB0aGlzLmJ1ZmZlclsrK2ldO1xuICAgICAgICAgICAgaWYgKGNoID09PSAnKycpXG4gICAgICAgICAgICAgICAgdGhpcy5ibG9ja1NjYWxhcktlZXAgPSB0cnVlO1xuICAgICAgICAgICAgZWxzZSBpZiAoY2ggPiAnMCcgJiYgY2ggPD0gJzknKVxuICAgICAgICAgICAgICAgIHRoaXMuYmxvY2tTY2FsYXJJbmRlbnQgPSBOdW1iZXIoY2gpIC0gMTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGNoICE9PSAnLScpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHlpZWxkKiB0aGlzLnB1c2hVbnRpbChjaCA9PiBpc0VtcHR5KGNoKSB8fCBjaCA9PT0gJyMnKTtcbiAgICB9XG4gICAgKnBhcnNlQmxvY2tTY2FsYXIoKSB7XG4gICAgICAgIGxldCBubCA9IHRoaXMucG9zIC0gMTsgLy8gbWF5IGJlIC0xIGlmIHRoaXMucG9zID09PSAwXG4gICAgICAgIGxldCBpbmRlbnQgPSAwO1xuICAgICAgICBsZXQgY2g7XG4gICAgICAgIGxvb3A6IGZvciAobGV0IGkgPSB0aGlzLnBvczsgKGNoID0gdGhpcy5idWZmZXJbaV0pOyArK2kpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoY2gpIHtcbiAgICAgICAgICAgICAgICBjYXNlICcgJzpcbiAgICAgICAgICAgICAgICAgICAgaW5kZW50ICs9IDE7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ1xcbic6XG4gICAgICAgICAgICAgICAgICAgIG5sID0gaTtcbiAgICAgICAgICAgICAgICAgICAgaW5kZW50ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnXFxyJzoge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXh0ID0gdGhpcy5idWZmZXJbaSArIDFdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW5leHQgJiYgIXRoaXMuYXRFbmQpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zZXROZXh0KCdibG9jay1zY2FsYXInKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5leHQgPT09ICdcXG4nKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfSAvLyBmYWxsdGhyb3VnaFxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrIGxvb3A7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjaCAmJiAhdGhpcy5hdEVuZClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNldE5leHQoJ2Jsb2NrLXNjYWxhcicpO1xuICAgICAgICBpZiAoaW5kZW50ID49IHRoaXMuaW5kZW50TmV4dCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuYmxvY2tTY2FsYXJJbmRlbnQgPT09IC0xKVxuICAgICAgICAgICAgICAgIHRoaXMuaW5kZW50TmV4dCA9IGluZGVudDtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aGlzLmluZGVudE5leHQgKz0gdGhpcy5ibG9ja1NjYWxhckluZGVudDtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjcyA9IHRoaXMuY29udGludWVTY2FsYXIobmwgKyAxKTtcbiAgICAgICAgICAgICAgICBpZiAoY3MgPT09IC0xKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBubCA9IHRoaXMuYnVmZmVyLmluZGV4T2YoJ1xcbicsIGNzKTtcbiAgICAgICAgICAgIH0gd2hpbGUgKG5sICE9PSAtMSk7XG4gICAgICAgICAgICBpZiAobmwgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmF0RW5kKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zZXROZXh0KCdibG9jay1zY2FsYXInKTtcbiAgICAgICAgICAgICAgICBubCA9IHRoaXMuYnVmZmVyLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuYmxvY2tTY2FsYXJLZWVwKSB7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgbGV0IGkgPSBubCAtIDE7XG4gICAgICAgICAgICAgICAgbGV0IGNoID0gdGhpcy5idWZmZXJbaV07XG4gICAgICAgICAgICAgICAgaWYgKGNoID09PSAnXFxyJylcbiAgICAgICAgICAgICAgICAgICAgY2ggPSB0aGlzLmJ1ZmZlclstLWldO1xuICAgICAgICAgICAgICAgIHdoaWxlIChjaCA9PT0gJyAnIHx8IGNoID09PSAnXFx0JylcbiAgICAgICAgICAgICAgICAgICAgY2ggPSB0aGlzLmJ1ZmZlclstLWldO1xuICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJ1xcbicgJiYgaSA+PSB0aGlzLnBvcylcbiAgICAgICAgICAgICAgICAgICAgbmwgPSBpO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9IHdoaWxlICh0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICB5aWVsZCBTQ0FMQVI7XG4gICAgICAgIHlpZWxkKiB0aGlzLnB1c2hUb0luZGV4KG5sICsgMSwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiB5aWVsZCogdGhpcy5wYXJzZUxpbmVTdGFydCgpO1xuICAgIH1cbiAgICAqcGFyc2VQbGFpblNjYWxhcigpIHtcbiAgICAgICAgY29uc3QgaW5GbG93ID0gdGhpcy5mbG93TGV2ZWwgPiAwO1xuICAgICAgICBsZXQgZW5kID0gdGhpcy5wb3MgLSAxO1xuICAgICAgICBsZXQgaSA9IHRoaXMucG9zIC0gMTtcbiAgICAgICAgbGV0IGNoO1xuICAgICAgICB3aGlsZSAoKGNoID0gdGhpcy5idWZmZXJbKytpXSkpIHtcbiAgICAgICAgICAgIGlmIChjaCA9PT0gJzonKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dCA9IHRoaXMuYnVmZmVyW2kgKyAxXTtcbiAgICAgICAgICAgICAgICBpZiAoaXNFbXB0eShuZXh0KSB8fCAoaW5GbG93ICYmIG5leHQgPT09ICcsJykpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGVuZCA9IGk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc0VtcHR5KGNoKSkge1xuICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gdGhpcy5idWZmZXJbaSArIDFdO1xuICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJ1xccicpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5leHQgPT09ICdcXG4nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpICs9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaCA9ICdcXG4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCA9IHRoaXMuYnVmZmVyW2kgKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmQgPSBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobmV4dCA9PT0gJyMnIHx8IChpbkZsb3cgJiYgaW52YWxpZEZsb3dTY2FsYXJDaGFycy5pbmNsdWRlcyhuZXh0KSkpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJ1xcbicpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY3MgPSB0aGlzLmNvbnRpbnVlU2NhbGFyKGkgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNzID09PSAtMSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBpID0gTWF0aC5tYXgoaSwgY3MgLSAyKTsgLy8gdG8gYWR2YW5jZSwgYnV0IHN0aWxsIGFjY291bnQgZm9yICcgIydcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5GbG93ICYmIGludmFsaWRGbG93U2NhbGFyQ2hhcnMuaW5jbHVkZXMoY2gpKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBlbmQgPSBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghY2ggJiYgIXRoaXMuYXRFbmQpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZXROZXh0KCdwbGFpbi1zY2FsYXInKTtcbiAgICAgICAgeWllbGQgU0NBTEFSO1xuICAgICAgICB5aWVsZCogdGhpcy5wdXNoVG9JbmRleChlbmQgKyAxLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIGluRmxvdyA/ICdmbG93JyA6ICdkb2MnO1xuICAgIH1cbiAgICAqcHVzaENvdW50KG4pIHtcbiAgICAgICAgaWYgKG4gPiAwKSB7XG4gICAgICAgICAgICB5aWVsZCB0aGlzLmJ1ZmZlci5zdWJzdHIodGhpcy5wb3MsIG4pO1xuICAgICAgICAgICAgdGhpcy5wb3MgKz0gbjtcbiAgICAgICAgICAgIHJldHVybiBuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICAqcHVzaFRvSW5kZXgoaSwgYWxsb3dFbXB0eSkge1xuICAgICAgICBjb25zdCBzID0gdGhpcy5idWZmZXIuc2xpY2UodGhpcy5wb3MsIGkpO1xuICAgICAgICBpZiAocykge1xuICAgICAgICAgICAgeWllbGQgcztcbiAgICAgICAgICAgIHRoaXMucG9zICs9IHMubGVuZ3RoO1xuICAgICAgICAgICAgcmV0dXJuIHMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFsbG93RW1wdHkpXG4gICAgICAgICAgICB5aWVsZCAnJztcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgICpwdXNoSW5kaWNhdG9ycygpIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLmNoYXJBdCgwKSkge1xuICAgICAgICAgICAgY2FzZSAnISc6XG4gICAgICAgICAgICAgICAgcmV0dXJuICgoeWllbGQqIHRoaXMucHVzaFRhZygpKSArXG4gICAgICAgICAgICAgICAgICAgICh5aWVsZCogdGhpcy5wdXNoU3BhY2VzKHRydWUpKSArXG4gICAgICAgICAgICAgICAgICAgICh5aWVsZCogdGhpcy5wdXNoSW5kaWNhdG9ycygpKSk7XG4gICAgICAgICAgICBjYXNlICcmJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gKCh5aWVsZCogdGhpcy5wdXNoVW50aWwoaXNOb3RBbmNob3JDaGFyKSkgK1xuICAgICAgICAgICAgICAgICAgICAoeWllbGQqIHRoaXMucHVzaFNwYWNlcyh0cnVlKSkgK1xuICAgICAgICAgICAgICAgICAgICAoeWllbGQqIHRoaXMucHVzaEluZGljYXRvcnMoKSkpO1xuICAgICAgICAgICAgY2FzZSAnOic6XG4gICAgICAgICAgICBjYXNlICc/JzogLy8gdGhpcyBpcyBhbiBlcnJvciBvdXRzaWRlIGZsb3cgY29sbGVjdGlvbnNcbiAgICAgICAgICAgIGNhc2UgJy0nOiAvLyB0aGlzIGlzIGFuIGVycm9yXG4gICAgICAgICAgICAgICAgaWYgKGlzRW1wdHkodGhpcy5jaGFyQXQoMSkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmZsb3dMZXZlbCA9PT0gMClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW5kZW50TmV4dCA9IHRoaXMuaW5kZW50VmFsdWUgKyAxO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLmZsb3dLZXkpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZsb3dLZXkgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgoeWllbGQqIHRoaXMucHVzaENvdW50KDEpKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAoeWllbGQqIHRoaXMucHVzaFNwYWNlcyh0cnVlKSkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgKHlpZWxkKiB0aGlzLnB1c2hJbmRpY2F0b3JzKCkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgICpwdXNoVGFnKCkge1xuICAgICAgICBpZiAodGhpcy5jaGFyQXQoMSkgPT09ICc8Jykge1xuICAgICAgICAgICAgbGV0IGkgPSB0aGlzLnBvcyArIDI7XG4gICAgICAgICAgICBsZXQgY2ggPSB0aGlzLmJ1ZmZlcltpXTtcbiAgICAgICAgICAgIHdoaWxlICghaXNFbXB0eShjaCkgJiYgY2ggIT09ICc+JylcbiAgICAgICAgICAgICAgICBjaCA9IHRoaXMuYnVmZmVyWysraV07XG4gICAgICAgICAgICByZXR1cm4geWllbGQqIHRoaXMucHVzaFRvSW5kZXgoY2ggPT09ICc+JyA/IGkgKyAxIDogaSwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IGkgPSB0aGlzLnBvcyArIDE7XG4gICAgICAgICAgICBsZXQgY2ggPSB0aGlzLmJ1ZmZlcltpXTtcbiAgICAgICAgICAgIHdoaWxlIChjaCkge1xuICAgICAgICAgICAgICAgIGlmICh0YWdDaGFycy5pbmNsdWRlcyhjaCkpXG4gICAgICAgICAgICAgICAgICAgIGNoID0gdGhpcy5idWZmZXJbKytpXTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjaCA9PT0gJyUnICYmXG4gICAgICAgICAgICAgICAgICAgIGhleERpZ2l0cy5pbmNsdWRlcyh0aGlzLmJ1ZmZlcltpICsgMV0pICYmXG4gICAgICAgICAgICAgICAgICAgIGhleERpZ2l0cy5pbmNsdWRlcyh0aGlzLmJ1ZmZlcltpICsgMl0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoID0gdGhpcy5idWZmZXJbKGkgKz0gMyldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHlpZWxkKiB0aGlzLnB1c2hUb0luZGV4KGksIGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAqcHVzaE5ld2xpbmUoKSB7XG4gICAgICAgIGNvbnN0IGNoID0gdGhpcy5idWZmZXJbdGhpcy5wb3NdO1xuICAgICAgICBpZiAoY2ggPT09ICdcXG4nKVxuICAgICAgICAgICAgcmV0dXJuIHlpZWxkKiB0aGlzLnB1c2hDb3VudCgxKTtcbiAgICAgICAgZWxzZSBpZiAoY2ggPT09ICdcXHInICYmIHRoaXMuY2hhckF0KDEpID09PSAnXFxuJylcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCogdGhpcy5wdXNoQ291bnQoMik7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICAqcHVzaFNwYWNlcyhhbGxvd1RhYnMpIHtcbiAgICAgICAgbGV0IGkgPSB0aGlzLnBvcyAtIDE7XG4gICAgICAgIGxldCBjaDtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgY2ggPSB0aGlzLmJ1ZmZlclsrK2ldO1xuICAgICAgICB9IHdoaWxlIChjaCA9PT0gJyAnIHx8IChhbGxvd1RhYnMgJiYgY2ggPT09ICdcXHQnKSk7XG4gICAgICAgIGNvbnN0IG4gPSBpIC0gdGhpcy5wb3M7XG4gICAgICAgIGlmIChuID4gMCkge1xuICAgICAgICAgICAgeWllbGQgdGhpcy5idWZmZXIuc3Vic3RyKHRoaXMucG9zLCBuKTtcbiAgICAgICAgICAgIHRoaXMucG9zID0gaTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbjtcbiAgICB9XG4gICAgKnB1c2hVbnRpbCh0ZXN0KSB7XG4gICAgICAgIGxldCBpID0gdGhpcy5wb3M7XG4gICAgICAgIGxldCBjaCA9IHRoaXMuYnVmZmVyW2ldO1xuICAgICAgICB3aGlsZSAoIXRlc3QoY2gpKVxuICAgICAgICAgICAgY2ggPSB0aGlzLmJ1ZmZlclsrK2ldO1xuICAgICAgICByZXR1cm4geWllbGQqIHRoaXMucHVzaFRvSW5kZXgoaSwgZmFsc2UpO1xuICAgIH1cbn1cblxuZXhwb3J0IHsgTGV4ZXIgfTtcbiIsICIvKipcbiAqIFRyYWNrcyBuZXdsaW5lcyBkdXJpbmcgcGFyc2luZyBpbiBvcmRlciB0byBwcm92aWRlIGFuIGVmZmljaWVudCBBUEkgZm9yXG4gKiBkZXRlcm1pbmluZyB0aGUgb25lLWluZGV4ZWQgYHsgbGluZSwgY29sIH1gIHBvc2l0aW9uIGZvciBhbnkgb2Zmc2V0XG4gKiB3aXRoaW4gdGhlIGlucHV0LlxuICovXG5jbGFzcyBMaW5lQ291bnRlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMubGluZVN0YXJ0cyA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgICogU2hvdWxkIGJlIGNhbGxlZCBpbiBhc2NlbmRpbmcgb3JkZXIuIE90aGVyd2lzZSwgY2FsbFxuICAgICAgICAgKiBgbGluZUNvdW50ZXIubGluZVN0YXJ0cy5zb3J0KClgIGJlZm9yZSBjYWxsaW5nIGBsaW5lUG9zKClgLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hZGROZXdMaW5lID0gKG9mZnNldCkgPT4gdGhpcy5saW5lU3RhcnRzLnB1c2gob2Zmc2V0KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFBlcmZvcm1zIGEgYmluYXJ5IHNlYXJjaCBhbmQgcmV0dXJucyB0aGUgMS1pbmRleGVkIHsgbGluZSwgY29sIH1cbiAgICAgICAgICogcG9zaXRpb24gb2YgYG9mZnNldGAuIElmIGBsaW5lID09PSAwYCwgYGFkZE5ld0xpbmVgIGhhcyBuZXZlciBiZWVuXG4gICAgICAgICAqIGNhbGxlZCBvciBgb2Zmc2V0YCBpcyBiZWZvcmUgdGhlIGZpcnN0IGtub3duIG5ld2xpbmUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmxpbmVQb3MgPSAob2Zmc2V0KSA9PiB7XG4gICAgICAgICAgICBsZXQgbG93ID0gMDtcbiAgICAgICAgICAgIGxldCBoaWdoID0gdGhpcy5saW5lU3RhcnRzLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlIChsb3cgPCBoaWdoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWlkID0gKGxvdyArIGhpZ2gpID4+IDE7IC8vIE1hdGguZmxvb3IoKGxvdyArIGhpZ2gpIC8gMilcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5saW5lU3RhcnRzW21pZF0gPCBvZmZzZXQpXG4gICAgICAgICAgICAgICAgICAgIGxvdyA9IG1pZCArIDE7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBoaWdoID0gbWlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMubGluZVN0YXJ0c1tsb3ddID09PSBvZmZzZXQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgbGluZTogbG93ICsgMSwgY29sOiAxIH07XG4gICAgICAgICAgICBpZiAobG93ID09PSAwKVxuICAgICAgICAgICAgICAgIHJldHVybiB7IGxpbmU6IDAsIGNvbDogb2Zmc2V0IH07XG4gICAgICAgICAgICBjb25zdCBzdGFydCA9IHRoaXMubGluZVN0YXJ0c1tsb3cgLSAxXTtcbiAgICAgICAgICAgIHJldHVybiB7IGxpbmU6IGxvdywgY29sOiBvZmZzZXQgLSBzdGFydCArIDEgfTtcbiAgICAgICAgfTtcbiAgICB9XG59XG5cbmV4cG9ydCB7IExpbmVDb3VudGVyIH07XG4iLCAiaW1wb3J0IHsgdG9rZW5UeXBlIH0gZnJvbSAnLi9jc3QuanMnO1xuaW1wb3J0IHsgTGV4ZXIgfSBmcm9tICcuL2xleGVyLmpzJztcblxuZnVuY3Rpb24gaW5jbHVkZXNUb2tlbihsaXN0LCB0eXBlKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKVxuICAgICAgICBpZiAobGlzdFtpXS50eXBlID09PSB0eXBlKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gaW5jbHVkZXNOb25FbXB0eShsaXN0KSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHN3aXRjaCAobGlzdFtpXS50eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdzcGFjZSc6XG4gICAgICAgICAgICBjYXNlICdjb21tZW50JzpcbiAgICAgICAgICAgIGNhc2UgJ25ld2xpbmUnOlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBpc0Zsb3dUb2tlbih0b2tlbikge1xuICAgIHN3aXRjaCAodG9rZW4gPT09IG51bGwgfHwgdG9rZW4gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRva2VuLnR5cGUpIHtcbiAgICAgICAgY2FzZSAnYWxpYXMnOlxuICAgICAgICBjYXNlICdzY2FsYXInOlxuICAgICAgICBjYXNlICdzaW5nbGUtcXVvdGVkLXNjYWxhcic6XG4gICAgICAgIGNhc2UgJ2RvdWJsZS1xdW90ZWQtc2NhbGFyJzpcbiAgICAgICAgY2FzZSAnZmxvdy1jb2xsZWN0aW9uJzpcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldFByZXZQcm9wcyhwYXJlbnQpIHtcbiAgICBzd2l0Y2ggKHBhcmVudC50eXBlKSB7XG4gICAgICAgIGNhc2UgJ2RvY3VtZW50JzpcbiAgICAgICAgICAgIHJldHVybiBwYXJlbnQuc3RhcnQ7XG4gICAgICAgIGNhc2UgJ2Jsb2NrLW1hcCc6IHtcbiAgICAgICAgICAgIGNvbnN0IGl0ID0gcGFyZW50Lml0ZW1zW3BhcmVudC5pdGVtcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIHJldHVybiBpdC5zZXAgfHwgaXQuc3RhcnQ7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnYmxvY2stc2VxJzpcbiAgICAgICAgICAgIHJldHVybiBwYXJlbnQuaXRlbXNbcGFyZW50Lml0ZW1zLmxlbmd0aCAtIDFdLnN0YXJ0O1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCBzaG91bGQgbm90IGhhcHBlbiAqL1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbn1cbi8qKiBOb3RlOiBNYXkgbW9kaWZ5IGlucHV0IGFycmF5ICovXG5mdW5jdGlvbiBnZXRGaXJzdEtleVN0YXJ0UHJvcHMocHJldikge1xuICAgIHZhciBfYTtcbiAgICBpZiAocHJldi5sZW5ndGggPT09IDApXG4gICAgICAgIHJldHVybiBbXTtcbiAgICBsZXQgaSA9IHByZXYubGVuZ3RoO1xuICAgIGxvb3A6IHdoaWxlICgtLWkgPj0gMCkge1xuICAgICAgICBzd2l0Y2ggKHByZXZbaV0udHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnZG9jLXN0YXJ0JzpcbiAgICAgICAgICAgIGNhc2UgJ2V4cGxpY2l0LWtleS1pbmQnOlxuICAgICAgICAgICAgY2FzZSAnbWFwLXZhbHVlLWluZCc6XG4gICAgICAgICAgICBjYXNlICdzZXEtaXRlbS1pbmQnOlxuICAgICAgICAgICAgY2FzZSAnbmV3bGluZSc6XG4gICAgICAgICAgICAgICAgYnJlYWsgbG9vcDtcbiAgICAgICAgfVxuICAgIH1cbiAgICB3aGlsZSAoKChfYSA9IHByZXZbKytpXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnR5cGUpID09PSAnc3BhY2UnKSB7XG4gICAgICAgIC8qIGxvb3AgKi9cbiAgICB9XG4gICAgcmV0dXJuIHByZXYuc3BsaWNlKGksIHByZXYubGVuZ3RoKTtcbn1cbmZ1bmN0aW9uIGZpeEZsb3dTZXFJdGVtcyhmYykge1xuICAgIGlmIChmYy5zdGFydC50eXBlID09PSAnZmxvdy1zZXEtc3RhcnQnKSB7XG4gICAgICAgIGZvciAoY29uc3QgaXQgb2YgZmMuaXRlbXMpIHtcbiAgICAgICAgICAgIGlmIChpdC5zZXAgJiZcbiAgICAgICAgICAgICAgICAhaXQudmFsdWUgJiZcbiAgICAgICAgICAgICAgICAhaW5jbHVkZXNUb2tlbihpdC5zdGFydCwgJ2V4cGxpY2l0LWtleS1pbmQnKSAmJlxuICAgICAgICAgICAgICAgICFpbmNsdWRlc1Rva2VuKGl0LnNlcCwgJ21hcC12YWx1ZS1pbmQnKSkge1xuICAgICAgICAgICAgICAgIGlmIChpdC5rZXkpXG4gICAgICAgICAgICAgICAgICAgIGl0LnZhbHVlID0gaXQua2V5O1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBpdC5rZXk7XG4gICAgICAgICAgICAgICAgaWYgKGlzRmxvd1Rva2VuKGl0LnZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXQudmFsdWUuZW5kKVxuICAgICAgICAgICAgICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkoaXQudmFsdWUuZW5kLCBpdC5zZXApO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBpdC52YWx1ZS5lbmQgPSBpdC5zZXA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkoaXQuc3RhcnQsIGl0LnNlcCk7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGl0LnNlcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogQSBZQU1MIGNvbmNyZXRlIHN5bnRheCB0cmVlIChDU1QpIHBhcnNlclxuICpcbiAqIGBgYHRzXG4gKiBjb25zdCBzcmM6IHN0cmluZyA9IC4uLlxuICogZm9yIChjb25zdCB0b2tlbiBvZiBuZXcgUGFyc2VyKCkucGFyc2Uoc3JjKSkge1xuICogICAvLyB0b2tlbjogVG9rZW5cbiAqIH1cbiAqIGBgYFxuICpcbiAqIFRvIHVzZSB0aGUgcGFyc2VyIHdpdGggYSB1c2VyLXByb3ZpZGVkIGxleGVyOlxuICpcbiAqIGBgYHRzXG4gKiBmdW5jdGlvbiogcGFyc2Uoc291cmNlOiBzdHJpbmcsIGxleGVyOiBMZXhlcikge1xuICogICBjb25zdCBwYXJzZXIgPSBuZXcgUGFyc2VyKClcbiAqICAgZm9yIChjb25zdCBsZXhlbWUgb2YgbGV4ZXIubGV4KHNvdXJjZSkpXG4gKiAgICAgeWllbGQqIHBhcnNlci5uZXh0KGxleGVtZSlcbiAqICAgeWllbGQqIHBhcnNlci5lbmQoKVxuICogfVxuICpcbiAqIGNvbnN0IHNyYzogc3RyaW5nID0gLi4uXG4gKiBjb25zdCBsZXhlciA9IG5ldyBMZXhlcigpXG4gKiBmb3IgKGNvbnN0IHRva2VuIG9mIHBhcnNlKHNyYywgbGV4ZXIpKSB7XG4gKiAgIC8vIHRva2VuOiBUb2tlblxuICogfVxuICogYGBgXG4gKi9cbmNsYXNzIFBhcnNlciB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIG9uTmV3TGluZSAtIElmIGRlZmluZWQsIGNhbGxlZCBzZXBhcmF0ZWx5IHdpdGggdGhlIHN0YXJ0IHBvc2l0aW9uIG9mXG4gICAgICogICBlYWNoIG5ldyBsaW5lIChpbiBgcGFyc2UoKWAsIGluY2x1ZGluZyB0aGUgc3RhcnQgb2YgaW5wdXQpLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG9uTmV3TGluZSkge1xuICAgICAgICAvKiogSWYgdHJ1ZSwgc3BhY2UgYW5kIHNlcXVlbmNlIGluZGljYXRvcnMgY291bnQgYXMgaW5kZW50YXRpb24gKi9cbiAgICAgICAgdGhpcy5hdE5ld0xpbmUgPSB0cnVlO1xuICAgICAgICAvKiogSWYgdHJ1ZSwgbmV4dCB0b2tlbiBpcyBhIHNjYWxhciB2YWx1ZSAqL1xuICAgICAgICB0aGlzLmF0U2NhbGFyID0gZmFsc2U7XG4gICAgICAgIC8qKiBDdXJyZW50IGluZGVudGF0aW9uIGxldmVsICovXG4gICAgICAgIHRoaXMuaW5kZW50ID0gMDtcbiAgICAgICAgLyoqIEN1cnJlbnQgb2Zmc2V0IHNpbmNlIHRoZSBzdGFydCBvZiBwYXJzaW5nICovXG4gICAgICAgIHRoaXMub2Zmc2V0ID0gMDtcbiAgICAgICAgLyoqIE9uIHRoZSBzYW1lIGxpbmUgd2l0aCBhIGJsb2NrIG1hcCBrZXkgKi9cbiAgICAgICAgdGhpcy5vbktleUxpbmUgPSBmYWxzZTtcbiAgICAgICAgLyoqIFRvcCBpbmRpY2F0ZXMgdGhlIG5vZGUgdGhhdCdzIGN1cnJlbnRseSBiZWluZyBidWlsdCAqL1xuICAgICAgICB0aGlzLnN0YWNrID0gW107XG4gICAgICAgIC8qKiBUaGUgc291cmNlIG9mIHRoZSBjdXJyZW50IHRva2VuLCBzZXQgaW4gcGFyc2UoKSAqL1xuICAgICAgICB0aGlzLnNvdXJjZSA9ICcnO1xuICAgICAgICAvKiogVGhlIHR5cGUgb2YgdGhlIGN1cnJlbnQgdG9rZW4sIHNldCBpbiBwYXJzZSgpICovXG4gICAgICAgIHRoaXMudHlwZSA9ICcnO1xuICAgICAgICAvLyBNdXN0IGJlIGRlZmluZWQgYWZ0ZXIgYG5leHQoKWBcbiAgICAgICAgdGhpcy5sZXhlciA9IG5ldyBMZXhlcigpO1xuICAgICAgICB0aGlzLm9uTmV3TGluZSA9IG9uTmV3TGluZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGFyc2UgYHNvdXJjZWAgYXMgYSBZQU1MIHN0cmVhbS5cbiAgICAgKiBJZiBgaW5jb21wbGV0ZWAsIGEgcGFydCBvZiB0aGUgbGFzdCBsaW5lIG1heSBiZSBsZWZ0IGFzIGEgYnVmZmVyIGZvciB0aGUgbmV4dCBjYWxsLlxuICAgICAqXG4gICAgICogRXJyb3JzIGFyZSBub3QgdGhyb3duLCBidXQgeWllbGRlZCBhcyBgeyB0eXBlOiAnZXJyb3InLCBtZXNzYWdlIH1gIHRva2Vucy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEEgZ2VuZXJhdG9yIG9mIHRva2VucyByZXByZXNlbnRpbmcgZWFjaCBkaXJlY3RpdmUsIGRvY3VtZW50LCBhbmQgb3RoZXIgc3RydWN0dXJlLlxuICAgICAqL1xuICAgICpwYXJzZShzb3VyY2UsIGluY29tcGxldGUgPSBmYWxzZSkge1xuICAgICAgICBpZiAodGhpcy5vbk5ld0xpbmUgJiYgdGhpcy5vZmZzZXQgPT09IDApXG4gICAgICAgICAgICB0aGlzLm9uTmV3TGluZSgwKTtcbiAgICAgICAgZm9yIChjb25zdCBsZXhlbWUgb2YgdGhpcy5sZXhlci5sZXgoc291cmNlLCBpbmNvbXBsZXRlKSlcbiAgICAgICAgICAgIHlpZWxkKiB0aGlzLm5leHQobGV4ZW1lKTtcbiAgICAgICAgaWYgKCFpbmNvbXBsZXRlKVxuICAgICAgICAgICAgeWllbGQqIHRoaXMuZW5kKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkdmFuY2UgdGhlIHBhcnNlciBieSB0aGUgYHNvdXJjZWAgb2Ygb25lIGxleGljYWwgdG9rZW4uXG4gICAgICovXG4gICAgKm5leHQoc291cmNlKSB7XG4gICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgICBpZiAodGhpcy5hdFNjYWxhcikge1xuICAgICAgICAgICAgdGhpcy5hdFNjYWxhciA9IGZhbHNlO1xuICAgICAgICAgICAgeWllbGQqIHRoaXMuc3RlcCgpO1xuICAgICAgICAgICAgdGhpcy5vZmZzZXQgKz0gc291cmNlLmxlbmd0aDtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0eXBlID0gdG9rZW5UeXBlKHNvdXJjZSk7XG4gICAgICAgIGlmICghdHlwZSkge1xuICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IGBOb3QgYSBZQU1MIHRva2VuOiAke3NvdXJjZX1gO1xuICAgICAgICAgICAgeWllbGQqIHRoaXMucG9wKHsgdHlwZTogJ2Vycm9yJywgb2Zmc2V0OiB0aGlzLm9mZnNldCwgbWVzc2FnZSwgc291cmNlIH0pO1xuICAgICAgICAgICAgdGhpcy5vZmZzZXQgKz0gc291cmNlLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlID09PSAnc2NhbGFyJykge1xuICAgICAgICAgICAgdGhpcy5hdE5ld0xpbmUgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuYXRTY2FsYXIgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy50eXBlID0gJ3NjYWxhcic7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICAgICAgeWllbGQqIHRoaXMuc3RlcCgpO1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnbmV3bGluZSc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXROZXdMaW5lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmRlbnQgPSAwO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5vbk5ld0xpbmUpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9uTmV3TGluZSh0aGlzLm9mZnNldCArIHNvdXJjZS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdzcGFjZSc6XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmF0TmV3TGluZSAmJiBzb3VyY2VbMF0gPT09ICcgJylcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW5kZW50ICs9IHNvdXJjZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2V4cGxpY2l0LWtleS1pbmQnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ21hcC12YWx1ZS1pbmQnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ3NlcS1pdGVtLWluZCc6XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmF0TmV3TGluZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW5kZW50ICs9IHNvdXJjZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2RvYy1tb2RlJzpcbiAgICAgICAgICAgICAgICBjYXNlICdmbG93LWVycm9yLWVuZCc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmF0TmV3TGluZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5vZmZzZXQgKz0gc291cmNlLmxlbmd0aDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiogQ2FsbCBhdCBlbmQgb2YgaW5wdXQgdG8gcHVzaCBvdXQgYW55IHJlbWFpbmluZyBjb25zdHJ1Y3Rpb25zICovXG4gICAgKmVuZCgpIHtcbiAgICAgICAgd2hpbGUgKHRoaXMuc3RhY2subGVuZ3RoID4gMClcbiAgICAgICAgICAgIHlpZWxkKiB0aGlzLnBvcCgpO1xuICAgIH1cbiAgICBnZXQgc291cmNlVG9rZW4oKSB7XG4gICAgICAgIGNvbnN0IHN0ID0ge1xuICAgICAgICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgICAgICAgb2Zmc2V0OiB0aGlzLm9mZnNldCxcbiAgICAgICAgICAgIGluZGVudDogdGhpcy5pbmRlbnQsXG4gICAgICAgICAgICBzb3VyY2U6IHRoaXMuc291cmNlXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBzdDtcbiAgICB9XG4gICAgKnN0ZXAoKSB7XG4gICAgICAgIGNvbnN0IHRvcCA9IHRoaXMucGVlaygxKTtcbiAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gJ2RvYy1lbmQnICYmICghdG9wIHx8IHRvcC50eXBlICE9PSAnZG9jLWVuZCcpKSB7XG4gICAgICAgICAgICB3aGlsZSAodGhpcy5zdGFjay5sZW5ndGggPiAwKVxuICAgICAgICAgICAgICAgIHlpZWxkKiB0aGlzLnBvcCgpO1xuICAgICAgICAgICAgdGhpcy5zdGFjay5wdXNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnZG9jLWVuZCcsXG4gICAgICAgICAgICAgICAgb2Zmc2V0OiB0aGlzLm9mZnNldCxcbiAgICAgICAgICAgICAgICBzb3VyY2U6IHRoaXMuc291cmNlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRvcClcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCogdGhpcy5zdHJlYW0oKTtcbiAgICAgICAgc3dpdGNoICh0b3AudHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnZG9jdW1lbnQnOlxuICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCogdGhpcy5kb2N1bWVudCh0b3ApO1xuICAgICAgICAgICAgY2FzZSAnYWxpYXMnOlxuICAgICAgICAgICAgY2FzZSAnc2NhbGFyJzpcbiAgICAgICAgICAgIGNhc2UgJ3NpbmdsZS1xdW90ZWQtc2NhbGFyJzpcbiAgICAgICAgICAgIGNhc2UgJ2RvdWJsZS1xdW90ZWQtc2NhbGFyJzpcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQqIHRoaXMuc2NhbGFyKHRvcCk7XG4gICAgICAgICAgICBjYXNlICdibG9jay1zY2FsYXInOlxuICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCogdGhpcy5ibG9ja1NjYWxhcih0b3ApO1xuICAgICAgICAgICAgY2FzZSAnYmxvY2stbWFwJzpcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQqIHRoaXMuYmxvY2tNYXAodG9wKTtcbiAgICAgICAgICAgIGNhc2UgJ2Jsb2NrLXNlcSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkKiB0aGlzLmJsb2NrU2VxdWVuY2UodG9wKTtcbiAgICAgICAgICAgIGNhc2UgJ2Zsb3ctY29sbGVjdGlvbic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkKiB0aGlzLmZsb3dDb2xsZWN0aW9uKHRvcCk7XG4gICAgICAgICAgICBjYXNlICdkb2MtZW5kJzpcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQqIHRoaXMuZG9jdW1lbnRFbmQodG9wKTtcbiAgICAgICAgfVxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCBzaG91bGQgbm90IGhhcHBlbiAqL1xuICAgICAgICB5aWVsZCogdGhpcy5wb3AoKTtcbiAgICB9XG4gICAgcGVlayhuKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gbl07XG4gICAgfVxuICAgICpwb3AoZXJyb3IpIHtcbiAgICAgICAgY29uc3QgdG9rZW4gPSBlcnJvciB8fCB0aGlzLnN0YWNrLnBvcCgpO1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgc2hvdWxkIG5vdCBoYXBwZW4gKi9cbiAgICAgICAgaWYgKCF0b2tlbikge1xuICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9ICdUcmllZCB0byBwb3AgYW4gZW1wdHkgc3RhY2snO1xuICAgICAgICAgICAgeWllbGQgeyB0eXBlOiAnZXJyb3InLCBvZmZzZXQ6IHRoaXMub2Zmc2V0LCBzb3VyY2U6ICcnLCBtZXNzYWdlIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5zdGFjay5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHlpZWxkIHRva2VuO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgdG9wID0gdGhpcy5wZWVrKDEpO1xuICAgICAgICAgICAgaWYgKHRva2VuLnR5cGUgPT09ICdibG9jay1zY2FsYXInKSB7XG4gICAgICAgICAgICAgICAgLy8gQmxvY2sgc2NhbGFycyB1c2UgdGhlaXIgcGFyZW50IHJhdGhlciB0aGFuIGhlYWRlciBpbmRlbnRcbiAgICAgICAgICAgICAgICB0b2tlbi5pbmRlbnQgPSAnaW5kZW50JyBpbiB0b3AgPyB0b3AuaW5kZW50IDogMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRva2VuLnR5cGUgPT09ICdmbG93LWNvbGxlY3Rpb24nICYmIHRvcC50eXBlID09PSAnZG9jdW1lbnQnKSB7XG4gICAgICAgICAgICAgICAgLy8gSWdub3JlIGFsbCBpbmRlbnQgZm9yIHRvcC1sZXZlbCBmbG93IGNvbGxlY3Rpb25zXG4gICAgICAgICAgICAgICAgdG9rZW4uaW5kZW50ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0b2tlbi50eXBlID09PSAnZmxvdy1jb2xsZWN0aW9uJylcbiAgICAgICAgICAgICAgICBmaXhGbG93U2VxSXRlbXModG9rZW4pO1xuICAgICAgICAgICAgc3dpdGNoICh0b3AudHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2RvY3VtZW50JzpcbiAgICAgICAgICAgICAgICAgICAgdG9wLnZhbHVlID0gdG9rZW47XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2Jsb2NrLXNjYWxhcic6XG4gICAgICAgICAgICAgICAgICAgIHRvcC5wcm9wcy5wdXNoKHRva2VuKTsgLy8gZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnYmxvY2stbWFwJzoge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpdCA9IHRvcC5pdGVtc1t0b3AuaXRlbXMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChpdC52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9wLml0ZW1zLnB1c2goeyBzdGFydDogW10sIGtleTogdG9rZW4sIHNlcDogW10gfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9uS2V5TGluZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaXQuc2VwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdC52YWx1ZSA9IHRva2VuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihpdCwgeyBrZXk6IHRva2VuLCBzZXA6IFtdIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vbktleUxpbmUgPSAhaW5jbHVkZXNUb2tlbihpdC5zdGFydCwgJ2V4cGxpY2l0LWtleS1pbmQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAnYmxvY2stc2VxJzoge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpdCA9IHRvcC5pdGVtc1t0b3AuaXRlbXMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChpdC52YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvcC5pdGVtcy5wdXNoKHsgc3RhcnQ6IFtdLCB2YWx1ZTogdG9rZW4gfSk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0LnZhbHVlID0gdG9rZW47XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlICdmbG93LWNvbGxlY3Rpb24nOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGl0ID0gdG9wLml0ZW1zW3RvcC5pdGVtcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpdCB8fCBpdC52YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvcC5pdGVtcy5wdXNoKHsgc3RhcnQ6IFtdLCBrZXk6IHRva2VuLCBzZXA6IFtdIH0pO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpdC5zZXApXG4gICAgICAgICAgICAgICAgICAgICAgICBpdC52YWx1ZSA9IHRva2VuO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKGl0LCB7IGtleTogdG9rZW4sIHNlcDogW10gfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgc2hvdWxkIG5vdCBoYXBwZW4gKi9cbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB5aWVsZCogdGhpcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQqIHRoaXMucG9wKHRva2VuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgodG9wLnR5cGUgPT09ICdkb2N1bWVudCcgfHxcbiAgICAgICAgICAgICAgICB0b3AudHlwZSA9PT0gJ2Jsb2NrLW1hcCcgfHxcbiAgICAgICAgICAgICAgICB0b3AudHlwZSA9PT0gJ2Jsb2NrLXNlcScpICYmXG4gICAgICAgICAgICAgICAgKHRva2VuLnR5cGUgPT09ICdibG9jay1tYXAnIHx8IHRva2VuLnR5cGUgPT09ICdibG9jay1zZXEnKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxhc3QgPSB0b2tlbi5pdGVtc1t0b2tlbi5pdGVtcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICBpZiAobGFzdCAmJlxuICAgICAgICAgICAgICAgICAgICAhbGFzdC5zZXAgJiZcbiAgICAgICAgICAgICAgICAgICAgIWxhc3QudmFsdWUgJiZcbiAgICAgICAgICAgICAgICAgICAgbGFzdC5zdGFydC5sZW5ndGggPiAwICYmXG4gICAgICAgICAgICAgICAgICAgICFpbmNsdWRlc05vbkVtcHR5KGxhc3Quc3RhcnQpICYmXG4gICAgICAgICAgICAgICAgICAgICh0b2tlbi5pbmRlbnQgPT09IDAgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3Quc3RhcnQuZXZlcnkoc3QgPT4gc3QudHlwZSAhPT0gJ2NvbW1lbnQnIHx8IHN0LmluZGVudCA8IHRva2VuLmluZGVudCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0b3AudHlwZSA9PT0gJ2RvY3VtZW50JylcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvcC5lbmQgPSBsYXN0LnN0YXJ0O1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICB0b3AuaXRlbXMucHVzaCh7IHN0YXJ0OiBsYXN0LnN0YXJ0IH0pO1xuICAgICAgICAgICAgICAgICAgICB0b2tlbi5pdGVtcy5zcGxpY2UoLTEsIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAqc3RyZWFtKCkge1xuICAgICAgICBzd2l0Y2ggKHRoaXMudHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnZGlyZWN0aXZlLWxpbmUnOlxuICAgICAgICAgICAgICAgIHlpZWxkIHsgdHlwZTogJ2RpcmVjdGl2ZScsIG9mZnNldDogdGhpcy5vZmZzZXQsIHNvdXJjZTogdGhpcy5zb3VyY2UgfTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjYXNlICdieXRlLW9yZGVyLW1hcmsnOlxuICAgICAgICAgICAgY2FzZSAnc3BhY2UnOlxuICAgICAgICAgICAgY2FzZSAnY29tbWVudCc6XG4gICAgICAgICAgICBjYXNlICduZXdsaW5lJzpcbiAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLnNvdXJjZVRva2VuO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNhc2UgJ2RvYy1tb2RlJzpcbiAgICAgICAgICAgIGNhc2UgJ2RvYy1zdGFydCc6IHtcbiAgICAgICAgICAgICAgICBjb25zdCBkb2MgPSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdkb2N1bWVudCcsXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldDogdGhpcy5vZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBbXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gJ2RvYy1zdGFydCcpXG4gICAgICAgICAgICAgICAgICAgIGRvYy5zdGFydC5wdXNoKHRoaXMuc291cmNlVG9rZW4pO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhY2sucHVzaChkb2MpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB5aWVsZCB7XG4gICAgICAgICAgICB0eXBlOiAnZXJyb3InLFxuICAgICAgICAgICAgb2Zmc2V0OiB0aGlzLm9mZnNldCxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGBVbmV4cGVjdGVkICR7dGhpcy50eXBlfSB0b2tlbiBpbiBZQU1MIHN0cmVhbWAsXG4gICAgICAgICAgICBzb3VyY2U6IHRoaXMuc291cmNlXG4gICAgICAgIH07XG4gICAgfVxuICAgICpkb2N1bWVudChkb2MpIHtcbiAgICAgICAgaWYgKGRvYy52YWx1ZSlcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCogdGhpcy5saW5lRW5kKGRvYyk7XG4gICAgICAgIHN3aXRjaCAodGhpcy50eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdkb2Mtc3RhcnQnOiB7XG4gICAgICAgICAgICAgICAgaWYgKGluY2x1ZGVzTm9uRW1wdHkoZG9jLnN0YXJ0KSkge1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCogdGhpcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQqIHRoaXMuc3RlcCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGRvYy5zdGFydC5wdXNoKHRoaXMuc291cmNlVG9rZW4pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ2FuY2hvcic6XG4gICAgICAgICAgICBjYXNlICd0YWcnOlxuICAgICAgICAgICAgY2FzZSAnc3BhY2UnOlxuICAgICAgICAgICAgY2FzZSAnY29tbWVudCc6XG4gICAgICAgICAgICBjYXNlICduZXdsaW5lJzpcbiAgICAgICAgICAgICAgICBkb2Muc3RhcnQucHVzaCh0aGlzLnNvdXJjZVRva2VuKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYnYgPSB0aGlzLnN0YXJ0QmxvY2tWYWx1ZShkb2MpO1xuICAgICAgICBpZiAoYnYpXG4gICAgICAgICAgICB0aGlzLnN0YWNrLnB1c2goYnYpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHlpZWxkIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnZXJyb3InLFxuICAgICAgICAgICAgICAgIG9mZnNldDogdGhpcy5vZmZzZXQsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogYFVuZXhwZWN0ZWQgJHt0aGlzLnR5cGV9IHRva2VuIGluIFlBTUwgZG9jdW1lbnRgLFxuICAgICAgICAgICAgICAgIHNvdXJjZTogdGhpcy5zb3VyY2VcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgKnNjYWxhcihzY2FsYXIpIHtcbiAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gJ21hcC12YWx1ZS1pbmQnKSB7XG4gICAgICAgICAgICBjb25zdCBwcmV2ID0gZ2V0UHJldlByb3BzKHRoaXMucGVlaygyKSk7XG4gICAgICAgICAgICBjb25zdCBzdGFydCA9IGdldEZpcnN0S2V5U3RhcnRQcm9wcyhwcmV2KTtcbiAgICAgICAgICAgIGxldCBzZXA7XG4gICAgICAgICAgICBpZiAoc2NhbGFyLmVuZCkge1xuICAgICAgICAgICAgICAgIHNlcCA9IHNjYWxhci5lbmQ7XG4gICAgICAgICAgICAgICAgc2VwLnB1c2godGhpcy5zb3VyY2VUb2tlbik7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHNjYWxhci5lbmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgc2VwID0gW3RoaXMuc291cmNlVG9rZW5dO1xuICAgICAgICAgICAgY29uc3QgbWFwID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdibG9jay1tYXAnLFxuICAgICAgICAgICAgICAgIG9mZnNldDogc2NhbGFyLm9mZnNldCxcbiAgICAgICAgICAgICAgICBpbmRlbnQ6IHNjYWxhci5pbmRlbnQsXG4gICAgICAgICAgICAgICAgaXRlbXM6IFt7IHN0YXJ0LCBrZXk6IHNjYWxhciwgc2VwIH1dXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5vbktleUxpbmUgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdID0gbWFwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHlpZWxkKiB0aGlzLmxpbmVFbmQoc2NhbGFyKTtcbiAgICB9XG4gICAgKmJsb2NrU2NhbGFyKHNjYWxhcikge1xuICAgICAgICBzd2l0Y2ggKHRoaXMudHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnc3BhY2UnOlxuICAgICAgICAgICAgY2FzZSAnY29tbWVudCc6XG4gICAgICAgICAgICBjYXNlICduZXdsaW5lJzpcbiAgICAgICAgICAgICAgICBzY2FsYXIucHJvcHMucHVzaCh0aGlzLnNvdXJjZVRva2VuKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjYXNlICdzY2FsYXInOlxuICAgICAgICAgICAgICAgIHNjYWxhci5zb3VyY2UgPSB0aGlzLnNvdXJjZTtcbiAgICAgICAgICAgICAgICAvLyBibG9jay1zY2FsYXIgc291cmNlIGluY2x1ZGVzIHRyYWlsaW5nIG5ld2xpbmVcbiAgICAgICAgICAgICAgICB0aGlzLmF0TmV3TGluZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5pbmRlbnQgPSAwO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9uTmV3TGluZSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbmwgPSB0aGlzLnNvdXJjZS5pbmRleE9mKCdcXG4nKSArIDE7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChubCAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vbk5ld0xpbmUodGhpcy5vZmZzZXQgKyBubCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBubCA9IHRoaXMuc291cmNlLmluZGV4T2YoJ1xcbicsIG5sKSArIDE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgeWllbGQqIHRoaXMucG9wKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCBzaG91bGQgbm90IGhhcHBlbiAqL1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB5aWVsZCogdGhpcy5wb3AoKTtcbiAgICAgICAgICAgICAgICB5aWVsZCogdGhpcy5zdGVwKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgKmJsb2NrTWFwKG1hcCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IGl0ID0gbWFwLml0ZW1zW21hcC5pdGVtcy5sZW5ndGggLSAxXTtcbiAgICAgICAgLy8gaXQuc2VwIGlzIHRydWUtaXNoIGlmIHBhaXIgYWxyZWFkeSBoYXMga2V5IG9yIDogc2VwYXJhdG9yXG4gICAgICAgIHN3aXRjaCAodGhpcy50eXBlKSB7XG4gICAgICAgICAgICBjYXNlICduZXdsaW5lJzpcbiAgICAgICAgICAgICAgICB0aGlzLm9uS2V5TGluZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGlmIChpdC52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlbmQgPSAnZW5kJyBpbiBpdC52YWx1ZSA/IGl0LnZhbHVlLmVuZCA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGFzdCA9IEFycmF5LmlzQXJyYXkoZW5kKSA/IGVuZFtlbmQubGVuZ3RoIC0gMV0gOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICgobGFzdCA9PT0gbnVsbCB8fCBsYXN0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsYXN0LnR5cGUpID09PSAnY29tbWVudCcpXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmQgPT09IG51bGwgfHwgZW5kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlbmQucHVzaCh0aGlzLnNvdXJjZVRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgbWFwLml0ZW1zLnB1c2goeyBzdGFydDogW3RoaXMuc291cmNlVG9rZW5dIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpdC5zZXApXG4gICAgICAgICAgICAgICAgICAgIGl0LnNlcC5wdXNoKHRoaXMuc291cmNlVG9rZW4pO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgaXQuc3RhcnQucHVzaCh0aGlzLnNvdXJjZVRva2VuKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjYXNlICdzcGFjZSc6XG4gICAgICAgICAgICBjYXNlICdjb21tZW50JzpcbiAgICAgICAgICAgICAgICBpZiAoaXQudmFsdWUpXG4gICAgICAgICAgICAgICAgICAgIG1hcC5pdGVtcy5wdXNoKHsgc3RhcnQ6IFt0aGlzLnNvdXJjZVRva2VuXSB9KTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpdC5zZXApXG4gICAgICAgICAgICAgICAgICAgIGl0LnNlcC5wdXNoKHRoaXMuc291cmNlVG9rZW4pO1xuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5hdEluZGVudGVkQ29tbWVudChpdC5zdGFydCwgbWFwLmluZGVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHByZXYgPSBtYXAuaXRlbXNbbWFwLml0ZW1zLmxlbmd0aCAtIDJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZW5kID0gKF9hID0gcHJldiA9PT0gbnVsbCB8fCBwcmV2ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwcmV2LnZhbHVlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZW5kO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZW5kKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGVuZCwgaXQuc3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZC5wdXNoKHRoaXMuc291cmNlVG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcC5pdGVtcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaXQuc3RhcnQucHVzaCh0aGlzLnNvdXJjZVRva2VuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmluZGVudCA+PSBtYXAuaW5kZW50KSB7XG4gICAgICAgICAgICBjb25zdCBhdE5leHRJdGVtID0gIXRoaXMub25LZXlMaW5lICYmXG4gICAgICAgICAgICAgICAgdGhpcy5pbmRlbnQgPT09IG1hcC5pbmRlbnQgJiZcbiAgICAgICAgICAgICAgICAoaXQuc2VwIHx8IGluY2x1ZGVzTm9uRW1wdHkoaXQuc3RhcnQpKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy50eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnYW5jaG9yJzpcbiAgICAgICAgICAgICAgICBjYXNlICd0YWcnOlxuICAgICAgICAgICAgICAgICAgICBpZiAoYXROZXh0SXRlbSB8fCBpdC52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFwLml0ZW1zLnB1c2goeyBzdGFydDogW3RoaXMuc291cmNlVG9rZW5dIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vbktleUxpbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGl0LnNlcClcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0LnNlcC5wdXNoKHRoaXMuc291cmNlVG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBpdC5zdGFydC5wdXNoKHRoaXMuc291cmNlVG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgY2FzZSAnZXhwbGljaXQta2V5LWluZCc6XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXQuc2VwICYmICFpbmNsdWRlc1Rva2VuKGl0LnN0YXJ0LCAnZXhwbGljaXQta2V5LWluZCcpKVxuICAgICAgICAgICAgICAgICAgICAgICAgaXQuc3RhcnQucHVzaCh0aGlzLnNvdXJjZVRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoYXROZXh0SXRlbSB8fCBpdC52YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcC5pdGVtcy5wdXNoKHsgc3RhcnQ6IFt0aGlzLnNvdXJjZVRva2VuXSB9KTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGFjay5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnYmxvY2stbWFwJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IHRoaXMub2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGVudDogdGhpcy5pbmRlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbXM6IFt7IHN0YXJ0OiBbdGhpcy5zb3VyY2VUb2tlbl0gfV1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uS2V5TGluZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBjYXNlICdtYXAtdmFsdWUtaW5kJzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpdC5zZXApXG4gICAgICAgICAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKGl0LCB7IGtleTogbnVsbCwgc2VwOiBbdGhpcy5zb3VyY2VUb2tlbl0gfSk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGl0LnZhbHVlIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAoYXROZXh0SXRlbSAmJiAhaW5jbHVkZXNUb2tlbihpdC5zdGFydCwgJ2V4cGxpY2l0LWtleS1pbmQnKSkpXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXAuaXRlbXMucHVzaCh7IHN0YXJ0OiBbXSwga2V5OiBudWxsLCBzZXA6IFt0aGlzLnNvdXJjZVRva2VuXSB9KTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaW5jbHVkZXNUb2tlbihpdC5zZXAsICdtYXAtdmFsdWUtaW5kJykpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YWNrLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdibG9jay1tYXAnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldDogdGhpcy5vZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZW50OiB0aGlzLmluZGVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtczogW3sgc3RhcnQ6IFtdLCBrZXk6IG51bGwsIHNlcDogW3RoaXMuc291cmNlVG9rZW5dIH1dXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaW5jbHVkZXNUb2tlbihpdC5zdGFydCwgJ2V4cGxpY2l0LWtleS1pbmQnKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgaXNGbG93VG9rZW4oaXQua2V5KSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgIWluY2x1ZGVzVG9rZW4oaXQuc2VwLCAnbmV3bGluZScpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzdGFydCA9IGdldEZpcnN0S2V5U3RhcnRQcm9wcyhpdC5zdGFydCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBpdC5rZXk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzZXAgPSBpdC5zZXA7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXAucHVzaCh0aGlzLnNvdXJjZVRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmUgdHlwZSBndWFyZCBpcyB3cm9uZyBoZXJlXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgaXQua2V5LCBkZWxldGUgaXQuc2VwO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGFjay5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnYmxvY2stbWFwJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IHRoaXMub2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGVudDogdGhpcy5pbmRlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbXM6IFt7IHN0YXJ0LCBrZXksIHNlcCB9XVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgaXQuc2VwLnB1c2godGhpcy5zb3VyY2VUb2tlbik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25LZXlMaW5lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2FsaWFzJzpcbiAgICAgICAgICAgICAgICBjYXNlICdzY2FsYXInOlxuICAgICAgICAgICAgICAgIGNhc2UgJ3NpbmdsZS1xdW90ZWQtc2NhbGFyJzpcbiAgICAgICAgICAgICAgICBjYXNlICdkb3VibGUtcXVvdGVkLXNjYWxhcic6IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZnMgPSB0aGlzLmZsb3dTY2FsYXIodGhpcy50eXBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGF0TmV4dEl0ZW0gfHwgaXQudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcC5pdGVtcy5wdXNoKHsgc3RhcnQ6IFtdLCBrZXk6IGZzLCBzZXA6IFtdIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vbktleUxpbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGl0LnNlcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGFjay5wdXNoKGZzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oaXQsIHsga2V5OiBmcywgc2VwOiBbXSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub25LZXlMaW5lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYnYgPSB0aGlzLnN0YXJ0QmxvY2tWYWx1ZShtYXApO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYnYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhdE5leHRJdGVtICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnYudHlwZSAhPT0gJ2Jsb2NrLXNlcScgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmNsdWRlc1Rva2VuKGl0LnN0YXJ0LCAnZXhwbGljaXQta2V5LWluZCcpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcC5pdGVtcy5wdXNoKHsgc3RhcnQ6IFtdIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGFjay5wdXNoKGJ2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB5aWVsZCogdGhpcy5wb3AoKTtcbiAgICAgICAgeWllbGQqIHRoaXMuc3RlcCgpO1xuICAgIH1cbiAgICAqYmxvY2tTZXF1ZW5jZShzZXEpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBpdCA9IHNlcS5pdGVtc1tzZXEuaXRlbXMubGVuZ3RoIC0gMV07XG4gICAgICAgIHN3aXRjaCAodGhpcy50eXBlKSB7XG4gICAgICAgICAgICBjYXNlICduZXdsaW5lJzpcbiAgICAgICAgICAgICAgICBpZiAoaXQudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZW5kID0gJ2VuZCcgaW4gaXQudmFsdWUgPyBpdC52YWx1ZS5lbmQgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxhc3QgPSBBcnJheS5pc0FycmF5KGVuZCkgPyBlbmRbZW5kLmxlbmd0aCAtIDFdIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICBpZiAoKGxhc3QgPT09IG51bGwgfHwgbGFzdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGFzdC50eXBlKSA9PT0gJ2NvbW1lbnQnKVxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kID09PSBudWxsIHx8IGVuZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogZW5kLnB1c2godGhpcy5zb3VyY2VUb2tlbik7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcS5pdGVtcy5wdXNoKHsgc3RhcnQ6IFt0aGlzLnNvdXJjZVRva2VuXSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBpdC5zdGFydC5wdXNoKHRoaXMuc291cmNlVG9rZW4pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNhc2UgJ3NwYWNlJzpcbiAgICAgICAgICAgIGNhc2UgJ2NvbW1lbnQnOlxuICAgICAgICAgICAgICAgIGlmIChpdC52YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgc2VxLml0ZW1zLnB1c2goeyBzdGFydDogW3RoaXMuc291cmNlVG9rZW5dIH0pO1xuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5hdEluZGVudGVkQ29tbWVudChpdC5zdGFydCwgc2VxLmluZGVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHByZXYgPSBzZXEuaXRlbXNbc2VxLml0ZW1zLmxlbmd0aCAtIDJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZW5kID0gKF9hID0gcHJldiA9PT0gbnVsbCB8fCBwcmV2ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwcmV2LnZhbHVlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZW5kO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZW5kKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGVuZCwgaXQuc3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZC5wdXNoKHRoaXMuc291cmNlVG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlcS5pdGVtcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaXQuc3RhcnQucHVzaCh0aGlzLnNvdXJjZVRva2VuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY2FzZSAnYW5jaG9yJzpcbiAgICAgICAgICAgIGNhc2UgJ3RhZyc6XG4gICAgICAgICAgICAgICAgaWYgKGl0LnZhbHVlIHx8IHRoaXMuaW5kZW50IDw9IHNlcS5pbmRlbnQpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGl0LnN0YXJ0LnB1c2godGhpcy5zb3VyY2VUb2tlbik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY2FzZSAnc2VxLWl0ZW0taW5kJzpcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pbmRlbnQgIT09IHNlcS5pbmRlbnQpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGlmIChpdC52YWx1ZSB8fCBpbmNsdWRlc1Rva2VuKGl0LnN0YXJ0LCAnc2VxLWl0ZW0taW5kJykpXG4gICAgICAgICAgICAgICAgICAgIHNlcS5pdGVtcy5wdXNoKHsgc3RhcnQ6IFt0aGlzLnNvdXJjZVRva2VuXSB9KTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGl0LnN0YXJ0LnB1c2godGhpcy5zb3VyY2VUb2tlbik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmluZGVudCA+IHNlcS5pbmRlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IGJ2ID0gdGhpcy5zdGFydEJsb2NrVmFsdWUoc2VxKTtcbiAgICAgICAgICAgIGlmIChidikge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhY2sucHVzaChidik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHlpZWxkKiB0aGlzLnBvcCgpO1xuICAgICAgICB5aWVsZCogdGhpcy5zdGVwKCk7XG4gICAgfVxuICAgICpmbG93Q29sbGVjdGlvbihmYykge1xuICAgICAgICBjb25zdCBpdCA9IGZjLml0ZW1zW2ZjLml0ZW1zLmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAodGhpcy50eXBlID09PSAnZmxvdy1lcnJvci1lbmQnKSB7XG4gICAgICAgICAgICBsZXQgdG9wO1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIHlpZWxkKiB0aGlzLnBvcCgpO1xuICAgICAgICAgICAgICAgIHRvcCA9IHRoaXMucGVlaygxKTtcbiAgICAgICAgICAgIH0gd2hpbGUgKHRvcCAmJiB0b3AudHlwZSA9PT0gJ2Zsb3ctY29sbGVjdGlvbicpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGZjLmVuZC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy50eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnY29tbWEnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2V4cGxpY2l0LWtleS1pbmQnOlxuICAgICAgICAgICAgICAgICAgICBpZiAoIWl0IHx8IGl0LnNlcClcbiAgICAgICAgICAgICAgICAgICAgICAgIGZjLml0ZW1zLnB1c2goeyBzdGFydDogW3RoaXMuc291cmNlVG9rZW5dIH0pO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBpdC5zdGFydC5wdXNoKHRoaXMuc291cmNlVG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgY2FzZSAnbWFwLXZhbHVlLWluZCc6XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXQgfHwgaXQudmFsdWUpXG4gICAgICAgICAgICAgICAgICAgICAgICBmYy5pdGVtcy5wdXNoKHsgc3RhcnQ6IFtdLCBrZXk6IG51bGwsIHNlcDogW3RoaXMuc291cmNlVG9rZW5dIH0pO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpdC5zZXApXG4gICAgICAgICAgICAgICAgICAgICAgICBpdC5zZXAucHVzaCh0aGlzLnNvdXJjZVRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihpdCwgeyBrZXk6IG51bGwsIHNlcDogW3RoaXMuc291cmNlVG9rZW5dIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgY2FzZSAnc3BhY2UnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2NvbW1lbnQnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ25ld2xpbmUnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2FuY2hvcic6XG4gICAgICAgICAgICAgICAgY2FzZSAndGFnJzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpdCB8fCBpdC52YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGZjLml0ZW1zLnB1c2goeyBzdGFydDogW3RoaXMuc291cmNlVG9rZW5dIH0pO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpdC5zZXApXG4gICAgICAgICAgICAgICAgICAgICAgICBpdC5zZXAucHVzaCh0aGlzLnNvdXJjZVRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgaXQuc3RhcnQucHVzaCh0aGlzLnNvdXJjZVRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2FsaWFzJzpcbiAgICAgICAgICAgICAgICBjYXNlICdzY2FsYXInOlxuICAgICAgICAgICAgICAgIGNhc2UgJ3NpbmdsZS1xdW90ZWQtc2NhbGFyJzpcbiAgICAgICAgICAgICAgICBjYXNlICdkb3VibGUtcXVvdGVkLXNjYWxhcic6IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZnMgPSB0aGlzLmZsb3dTY2FsYXIodGhpcy50eXBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpdCB8fCBpdC52YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGZjLml0ZW1zLnB1c2goeyBzdGFydDogW10sIGtleTogZnMsIHNlcDogW10gfSk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGl0LnNlcClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhY2sucHVzaChmcyk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oaXQsIHsga2V5OiBmcywgc2VwOiBbXSB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlICdmbG93LW1hcC1lbmQnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2Zsb3ctc2VxLWVuZCc6XG4gICAgICAgICAgICAgICAgICAgIGZjLmVuZC5wdXNoKHRoaXMuc291cmNlVG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBidiA9IHRoaXMuc3RhcnRCbG9ja1ZhbHVlKGZjKTtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlIHNob3VsZCBub3QgaGFwcGVuICovXG4gICAgICAgICAgICBpZiAoYnYpXG4gICAgICAgICAgICAgICAgdGhpcy5zdGFjay5wdXNoKGJ2KTtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHlpZWxkKiB0aGlzLnBvcCgpO1xuICAgICAgICAgICAgICAgIHlpZWxkKiB0aGlzLnN0ZXAoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcmVudCA9IHRoaXMucGVlaygyKTtcbiAgICAgICAgICAgIGlmIChwYXJlbnQudHlwZSA9PT0gJ2Jsb2NrLW1hcCcgJiZcbiAgICAgICAgICAgICAgICAodGhpcy50eXBlID09PSAnbWFwLXZhbHVlLWluZCcgfHxcbiAgICAgICAgICAgICAgICAgICAgKHRoaXMudHlwZSA9PT0gJ25ld2xpbmUnICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAhcGFyZW50Lml0ZW1zW3BhcmVudC5pdGVtcy5sZW5ndGggLSAxXS5zZXApKSkge1xuICAgICAgICAgICAgICAgIHlpZWxkKiB0aGlzLnBvcCgpO1xuICAgICAgICAgICAgICAgIHlpZWxkKiB0aGlzLnN0ZXAoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMudHlwZSA9PT0gJ21hcC12YWx1ZS1pbmQnICYmXG4gICAgICAgICAgICAgICAgcGFyZW50LnR5cGUgIT09ICdmbG93LWNvbGxlY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJldiA9IGdldFByZXZQcm9wcyhwYXJlbnQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gZ2V0Rmlyc3RLZXlTdGFydFByb3BzKHByZXYpO1xuICAgICAgICAgICAgICAgIGZpeEZsb3dTZXFJdGVtcyhmYyk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2VwID0gZmMuZW5kLnNwbGljZSgxLCBmYy5lbmQubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBzZXAucHVzaCh0aGlzLnNvdXJjZVRva2VuKTtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXAgPSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdibG9jay1tYXAnLFxuICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IGZjLm9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgaW5kZW50OiBmYy5pbmRlbnQsXG4gICAgICAgICAgICAgICAgICAgIGl0ZW1zOiBbeyBzdGFydCwga2V5OiBmYywgc2VwIH1dXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0aGlzLm9uS2V5TGluZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdID0gbWFwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgeWllbGQqIHRoaXMubGluZUVuZChmYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZmxvd1NjYWxhcih0eXBlKSB7XG4gICAgICAgIGlmICh0aGlzLm9uTmV3TGluZSkge1xuICAgICAgICAgICAgbGV0IG5sID0gdGhpcy5zb3VyY2UuaW5kZXhPZignXFxuJykgKyAxO1xuICAgICAgICAgICAgd2hpbGUgKG5sICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vbk5ld0xpbmUodGhpcy5vZmZzZXQgKyBubCk7XG4gICAgICAgICAgICAgICAgbmwgPSB0aGlzLnNvdXJjZS5pbmRleE9mKCdcXG4nLCBubCkgKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgb2Zmc2V0OiB0aGlzLm9mZnNldCxcbiAgICAgICAgICAgIGluZGVudDogdGhpcy5pbmRlbnQsXG4gICAgICAgICAgICBzb3VyY2U6IHRoaXMuc291cmNlXG4gICAgICAgIH07XG4gICAgfVxuICAgIHN0YXJ0QmxvY2tWYWx1ZShwYXJlbnQpIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2FsaWFzJzpcbiAgICAgICAgICAgIGNhc2UgJ3NjYWxhcic6XG4gICAgICAgICAgICBjYXNlICdzaW5nbGUtcXVvdGVkLXNjYWxhcic6XG4gICAgICAgICAgICBjYXNlICdkb3VibGUtcXVvdGVkLXNjYWxhcic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmxvd1NjYWxhcih0aGlzLnR5cGUpO1xuICAgICAgICAgICAgY2FzZSAnYmxvY2stc2NhbGFyLWhlYWRlcic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2Jsb2NrLXNjYWxhcicsXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldDogdGhpcy5vZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgIGluZGVudDogdGhpcy5pbmRlbnQsXG4gICAgICAgICAgICAgICAgICAgIHByb3BzOiBbdGhpcy5zb3VyY2VUb2tlbl0sXG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZTogJydcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgY2FzZSAnZmxvdy1tYXAtc3RhcnQnOlxuICAgICAgICAgICAgY2FzZSAnZmxvdy1zZXEtc3RhcnQnOlxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdmbG93LWNvbGxlY3Rpb24nLFxuICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IHRoaXMub2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICBpbmRlbnQ6IHRoaXMuaW5kZW50LFxuICAgICAgICAgICAgICAgICAgICBzdGFydDogdGhpcy5zb3VyY2VUb2tlbixcbiAgICAgICAgICAgICAgICAgICAgaXRlbXM6IFtdLFxuICAgICAgICAgICAgICAgICAgICBlbmQ6IFtdXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNhc2UgJ3NlcS1pdGVtLWluZCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2Jsb2NrLXNlcScsXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldDogdGhpcy5vZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgIGluZGVudDogdGhpcy5pbmRlbnQsXG4gICAgICAgICAgICAgICAgICAgIGl0ZW1zOiBbeyBzdGFydDogW3RoaXMuc291cmNlVG9rZW5dIH1dXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNhc2UgJ2V4cGxpY2l0LWtleS1pbmQnOiB7XG4gICAgICAgICAgICAgICAgdGhpcy5vbktleUxpbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNvbnN0IHByZXYgPSBnZXRQcmV2UHJvcHMocGFyZW50KTtcbiAgICAgICAgICAgICAgICBjb25zdCBzdGFydCA9IGdldEZpcnN0S2V5U3RhcnRQcm9wcyhwcmV2KTtcbiAgICAgICAgICAgICAgICBzdGFydC5wdXNoKHRoaXMuc291cmNlVG9rZW4pO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdibG9jay1tYXAnLFxuICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IHRoaXMub2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICBpbmRlbnQ6IHRoaXMuaW5kZW50LFxuICAgICAgICAgICAgICAgICAgICBpdGVtczogW3sgc3RhcnQgfV1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnbWFwLXZhbHVlLWluZCc6IHtcbiAgICAgICAgICAgICAgICB0aGlzLm9uS2V5TGluZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJldiA9IGdldFByZXZQcm9wcyhwYXJlbnQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gZ2V0Rmlyc3RLZXlTdGFydFByb3BzKHByZXYpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdibG9jay1tYXAnLFxuICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IHRoaXMub2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICBpbmRlbnQ6IHRoaXMuaW5kZW50LFxuICAgICAgICAgICAgICAgICAgICBpdGVtczogW3sgc3RhcnQsIGtleTogbnVsbCwgc2VwOiBbdGhpcy5zb3VyY2VUb2tlbl0gfV1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBhdEluZGVudGVkQ29tbWVudChzdGFydCwgaW5kZW50KSB7XG4gICAgICAgIGlmICh0aGlzLnR5cGUgIT09ICdjb21tZW50JylcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuaW5kZW50IDw9IGluZGVudClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHN0YXJ0LmV2ZXJ5KHN0ID0+IHN0LnR5cGUgPT09ICduZXdsaW5lJyB8fCBzdC50eXBlID09PSAnc3BhY2UnKTtcbiAgICB9XG4gICAgKmRvY3VtZW50RW5kKGRvY0VuZCkge1xuICAgICAgICBpZiAodGhpcy50eXBlICE9PSAnZG9jLW1vZGUnKSB7XG4gICAgICAgICAgICBpZiAoZG9jRW5kLmVuZClcbiAgICAgICAgICAgICAgICBkb2NFbmQuZW5kLnB1c2godGhpcy5zb3VyY2VUb2tlbik7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgZG9jRW5kLmVuZCA9IFt0aGlzLnNvdXJjZVRva2VuXTtcbiAgICAgICAgICAgIGlmICh0aGlzLnR5cGUgPT09ICduZXdsaW5lJylcbiAgICAgICAgICAgICAgICB5aWVsZCogdGhpcy5wb3AoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAqbGluZUVuZCh0b2tlbikge1xuICAgICAgICBzd2l0Y2ggKHRoaXMudHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnY29tbWEnOlxuICAgICAgICAgICAgY2FzZSAnZG9jLXN0YXJ0JzpcbiAgICAgICAgICAgIGNhc2UgJ2RvYy1lbmQnOlxuICAgICAgICAgICAgY2FzZSAnZmxvdy1zZXEtZW5kJzpcbiAgICAgICAgICAgIGNhc2UgJ2Zsb3ctbWFwLWVuZCc6XG4gICAgICAgICAgICBjYXNlICdtYXAtdmFsdWUtaW5kJzpcbiAgICAgICAgICAgICAgICB5aWVsZCogdGhpcy5wb3AoKTtcbiAgICAgICAgICAgICAgICB5aWVsZCogdGhpcy5zdGVwKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICduZXdsaW5lJzpcbiAgICAgICAgICAgICAgICB0aGlzLm9uS2V5TGluZSA9IGZhbHNlO1xuICAgICAgICAgICAgLy8gZmFsbHRocm91Z2hcbiAgICAgICAgICAgIGNhc2UgJ3NwYWNlJzpcbiAgICAgICAgICAgIGNhc2UgJ2NvbW1lbnQnOlxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAvLyBhbGwgb3RoZXIgdmFsdWVzIGFyZSBlcnJvcnNcbiAgICAgICAgICAgICAgICBpZiAodG9rZW4uZW5kKVxuICAgICAgICAgICAgICAgICAgICB0b2tlbi5lbmQucHVzaCh0aGlzLnNvdXJjZVRva2VuKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHRva2VuLmVuZCA9IFt0aGlzLnNvdXJjZVRva2VuXTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy50eXBlID09PSAnbmV3bGluZScpXG4gICAgICAgICAgICAgICAgICAgIHlpZWxkKiB0aGlzLnBvcCgpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgeyBQYXJzZXIgfTtcbiIsICJpbXBvcnQgeyBDb21wb3NlciB9IGZyb20gJy4vY29tcG9zZS9jb21wb3Nlci5qcyc7XG5pbXBvcnQgeyBEb2N1bWVudCB9IGZyb20gJy4vZG9jL0RvY3VtZW50LmpzJztcbmltcG9ydCB7IHByZXR0aWZ5RXJyb3IsIFlBTUxQYXJzZUVycm9yIH0gZnJvbSAnLi9lcnJvcnMuanMnO1xuaW1wb3J0IHsgd2FybiB9IGZyb20gJy4vbG9nLmpzJztcbmltcG9ydCB7IExpbmVDb3VudGVyIH0gZnJvbSAnLi9wYXJzZS9saW5lLWNvdW50ZXIuanMnO1xuaW1wb3J0IHsgUGFyc2VyIH0gZnJvbSAnLi9wYXJzZS9wYXJzZXIuanMnO1xuXG5mdW5jdGlvbiBwYXJzZU9wdGlvbnMob3B0aW9ucykge1xuICAgIGNvbnN0IHByZXR0eUVycm9ycyA9IG9wdGlvbnMucHJldHR5RXJyb3JzICE9PSBmYWxzZTtcbiAgICBjb25zdCBsaW5lQ291bnRlciA9IG9wdGlvbnMubGluZUNvdW50ZXIgfHwgKHByZXR0eUVycm9ycyAmJiBuZXcgTGluZUNvdW50ZXIoKSkgfHwgbnVsbDtcbiAgICByZXR1cm4geyBsaW5lQ291bnRlciwgcHJldHR5RXJyb3JzIH07XG59XG4vKipcbiAqIFBhcnNlIHRoZSBpbnB1dCBhcyBhIHN0cmVhbSBvZiBZQU1MIGRvY3VtZW50cy5cbiAqXG4gKiBEb2N1bWVudHMgc2hvdWxkIGJlIHNlcGFyYXRlZCBmcm9tIGVhY2ggb3RoZXIgYnkgYC4uLmAgb3IgYC0tLWAgbWFya2VyIGxpbmVzLlxuICpcbiAqIEByZXR1cm5zIElmIGFuIGVtcHR5IGBkb2NzYCBhcnJheSBpcyByZXR1cm5lZCwgaXQgd2lsbCBiZSBvZiB0eXBlXG4gKiAgIEVtcHR5U3RyZWFtIGFuZCBjb250YWluIGFkZGl0aW9uYWwgc3RyZWFtIGluZm9ybWF0aW9uLiBJblxuICogICBUeXBlU2NyaXB0LCB5b3Ugc2hvdWxkIHVzZSBgJ2VtcHR5JyBpbiBkb2NzYCBhcyBhIHR5cGUgZ3VhcmQgZm9yIGl0LlxuICovXG5mdW5jdGlvbiBwYXJzZUFsbERvY3VtZW50cyhzb3VyY2UsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgbGluZUNvdW50ZXIsIHByZXR0eUVycm9ycyB9ID0gcGFyc2VPcHRpb25zKG9wdGlvbnMpO1xuICAgIGNvbnN0IHBhcnNlciA9IG5ldyBQYXJzZXIobGluZUNvdW50ZXIgPT09IG51bGwgfHwgbGluZUNvdW50ZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxpbmVDb3VudGVyLmFkZE5ld0xpbmUpO1xuICAgIGNvbnN0IGNvbXBvc2VyID0gbmV3IENvbXBvc2VyKG9wdGlvbnMpO1xuICAgIGNvbnN0IGRvY3MgPSBBcnJheS5mcm9tKGNvbXBvc2VyLmNvbXBvc2UocGFyc2VyLnBhcnNlKHNvdXJjZSkpKTtcbiAgICBpZiAocHJldHR5RXJyb3JzICYmIGxpbmVDb3VudGVyKVxuICAgICAgICBmb3IgKGNvbnN0IGRvYyBvZiBkb2NzKSB7XG4gICAgICAgICAgICBkb2MuZXJyb3JzLmZvckVhY2gocHJldHRpZnlFcnJvcihzb3VyY2UsIGxpbmVDb3VudGVyKSk7XG4gICAgICAgICAgICBkb2Mud2FybmluZ3MuZm9yRWFjaChwcmV0dGlmeUVycm9yKHNvdXJjZSwgbGluZUNvdW50ZXIpKTtcbiAgICAgICAgfVxuICAgIGlmIChkb2NzLmxlbmd0aCA+IDApXG4gICAgICAgIHJldHVybiBkb2NzO1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKFtdLCB7IGVtcHR5OiB0cnVlIH0sIGNvbXBvc2VyLnN0cmVhbUluZm8oKSk7XG59XG4vKiogUGFyc2UgYW4gaW5wdXQgc3RyaW5nIGludG8gYSBzaW5nbGUgWUFNTC5Eb2N1bWVudCAqL1xuZnVuY3Rpb24gcGFyc2VEb2N1bWVudChzb3VyY2UsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgbGluZUNvdW50ZXIsIHByZXR0eUVycm9ycyB9ID0gcGFyc2VPcHRpb25zKG9wdGlvbnMpO1xuICAgIGNvbnN0IHBhcnNlciA9IG5ldyBQYXJzZXIobGluZUNvdW50ZXIgPT09IG51bGwgfHwgbGluZUNvdW50ZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxpbmVDb3VudGVyLmFkZE5ld0xpbmUpO1xuICAgIGNvbnN0IGNvbXBvc2VyID0gbmV3IENvbXBvc2VyKG9wdGlvbnMpO1xuICAgIC8vIGBkb2NgIGlzIGFsd2F5cyBzZXQgYnkgY29tcG9zZS5lbmQodHJ1ZSkgYXQgdGhlIHZlcnkgbGF0ZXN0XG4gICAgbGV0IGRvYyA9IG51bGw7XG4gICAgZm9yIChjb25zdCBfZG9jIG9mIGNvbXBvc2VyLmNvbXBvc2UocGFyc2VyLnBhcnNlKHNvdXJjZSksIHRydWUsIHNvdXJjZS5sZW5ndGgpKSB7XG4gICAgICAgIGlmICghZG9jKVxuICAgICAgICAgICAgZG9jID0gX2RvYztcbiAgICAgICAgZWxzZSBpZiAoZG9jLm9wdGlvbnMubG9nTGV2ZWwgIT09ICdzaWxlbnQnKSB7XG4gICAgICAgICAgICBkb2MuZXJyb3JzLnB1c2gobmV3IFlBTUxQYXJzZUVycm9yKF9kb2MucmFuZ2Uuc2xpY2UoMCwgMiksICdNVUxUSVBMRV9ET0NTJywgJ1NvdXJjZSBjb250YWlucyBtdWx0aXBsZSBkb2N1bWVudHM7IHBsZWFzZSB1c2UgWUFNTC5wYXJzZUFsbERvY3VtZW50cygpJykpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHByZXR0eUVycm9ycyAmJiBsaW5lQ291bnRlcikge1xuICAgICAgICBkb2MuZXJyb3JzLmZvckVhY2gocHJldHRpZnlFcnJvcihzb3VyY2UsIGxpbmVDb3VudGVyKSk7XG4gICAgICAgIGRvYy53YXJuaW5ncy5mb3JFYWNoKHByZXR0aWZ5RXJyb3Ioc291cmNlLCBsaW5lQ291bnRlcikpO1xuICAgIH1cbiAgICByZXR1cm4gZG9jO1xufVxuZnVuY3Rpb24gcGFyc2Uoc3JjLCByZXZpdmVyLCBvcHRpb25zKSB7XG4gICAgbGV0IF9yZXZpdmVyID0gdW5kZWZpbmVkO1xuICAgIGlmICh0eXBlb2YgcmV2aXZlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBfcmV2aXZlciA9IHJldml2ZXI7XG4gICAgfVxuICAgIGVsc2UgaWYgKG9wdGlvbnMgPT09IHVuZGVmaW5lZCAmJiByZXZpdmVyICYmIHR5cGVvZiByZXZpdmVyID09PSAnb2JqZWN0Jykge1xuICAgICAgICBvcHRpb25zID0gcmV2aXZlcjtcbiAgICB9XG4gICAgY29uc3QgZG9jID0gcGFyc2VEb2N1bWVudChzcmMsIG9wdGlvbnMpO1xuICAgIGlmICghZG9jKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBkb2Mud2FybmluZ3MuZm9yRWFjaCh3YXJuaW5nID0+IHdhcm4oZG9jLm9wdGlvbnMubG9nTGV2ZWwsIHdhcm5pbmcpKTtcbiAgICBpZiAoZG9jLmVycm9ycy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGlmIChkb2Mub3B0aW9ucy5sb2dMZXZlbCAhPT0gJ3NpbGVudCcpXG4gICAgICAgICAgICB0aHJvdyBkb2MuZXJyb3JzWzBdO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBkb2MuZXJyb3JzID0gW107XG4gICAgfVxuICAgIHJldHVybiBkb2MudG9KUyhPYmplY3QuYXNzaWduKHsgcmV2aXZlcjogX3Jldml2ZXIgfSwgb3B0aW9ucykpO1xufVxuZnVuY3Rpb24gc3RyaW5naWZ5KHZhbHVlLCByZXBsYWNlciwgb3B0aW9ucykge1xuICAgIGxldCBfcmVwbGFjZXIgPSBudWxsO1xuICAgIGlmICh0eXBlb2YgcmVwbGFjZXIgPT09ICdmdW5jdGlvbicgfHwgQXJyYXkuaXNBcnJheShyZXBsYWNlcikpIHtcbiAgICAgICAgX3JlcGxhY2VyID0gcmVwbGFjZXI7XG4gICAgfVxuICAgIGVsc2UgaWYgKG9wdGlvbnMgPT09IHVuZGVmaW5lZCAmJiByZXBsYWNlcikge1xuICAgICAgICBvcHRpb25zID0gcmVwbGFjZXI7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ3N0cmluZycpXG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zLmxlbmd0aDtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGNvbnN0IGluZGVudCA9IE1hdGgucm91bmQob3B0aW9ucyk7XG4gICAgICAgIG9wdGlvbnMgPSBpbmRlbnQgPCAxID8gdW5kZWZpbmVkIDogaW5kZW50ID4gOCA/IHsgaW5kZW50OiA4IH0gOiB7IGluZGVudCB9O1xuICAgIH1cbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCB7IGtlZXBVbmRlZmluZWQgfSA9IG9wdGlvbnMgfHwgcmVwbGFjZXIgfHwge307XG4gICAgICAgIGlmICgha2VlcFVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiBuZXcgRG9jdW1lbnQodmFsdWUsIF9yZXBsYWNlciwgb3B0aW9ucykudG9TdHJpbmcob3B0aW9ucyk7XG59XG5cbmV4cG9ydCB7IHBhcnNlLCBwYXJzZUFsbERvY3VtZW50cywgcGFyc2VEb2N1bWVudCwgc3RyaW5naWZ5IH07XG4iLCAiaW1wb3J0IHsgcGFyc2VGcm9udE1hdHRlckFsaWFzZXMsIHBhcnNlRnJvbnRNYXR0ZXJUYWdzIH0gZnJvbSBcIm9ic2lkaWFuXCI7XG5cbmV4cG9ydCBpbnRlcmZhY2UgTm90ZVR5cGUge1xuICAgIHR5cGU6IHN0cmluZztcbiAgICBkZXNjcmlwdGlvbjogc3RyaW5nO1xuICAgIHByZWZpeDogc3RyaW5nO1xuICB9XG4gIFxuZXhwb3J0IGNvbnN0IEFMTF9UWVBFUyA9IFtcbiAgICB7XG4gICAgICB0eXBlOiBcImEvbi9uXCIsXG4gICAgICBkZXNjcmlwdGlvbjogXCJOIEN1cnJlbnQgVGFza1wiLFxuICAgICAgcHJlZml4OiBcIlx1RDgzRFx1REQzNFwiLFxuICAgIH0sXG4gICAge1xuICAgICAgdHlwZTogXCJhL3cvblwiLFxuICAgICAgZGVzY3JpcHRpb246IFwiVyBDdXJyZW50IFRhc2tcIixcbiAgICAgIHByZWZpeDogXCJcdUQ4M0RcdUREMzRcIixcbiAgICB9LFxuICAgIHtcbiAgICAgIHR5cGU6IFwiYS9uL2xcIixcbiAgICAgIGRlc2NyaXB0aW9uOiBcIk4gTGF0ZXIgVGFza1wiLFxuICAgICAgcHJlZml4OiBcIlx1RDgzRFx1REZFMlwiLFxuICAgIH0sXG4gICAge1xuICAgICAgdHlwZTogXCJhL3cvbFwiLFxuICAgICAgZGVzY3JpcHRpb246IFwiVyBMYXRlciBUYXNrXCIsXG4gICAgICBwcmVmaXg6IFwiXHVEODNEXHVERkUyXCIsXG4gICAgfSxcbiAgICB7XG4gICAgICB0eXBlOiBcImEvbi9wXCIsXG4gICAgICBkZXNjcmlwdGlvbjogXCJOIFBlcm1hbmVudCBUYXNrXCIsXG4gICAgICBwcmVmaXg6IFwiXHVEODNEXHVERkUwXCIsXG4gICAgfSxcbiAgICB7XG4gICAgICB0eXBlOiBcImEvdy9wXCIsXG4gICAgICBkZXNjcmlwdGlvbjogXCJXIFBlcm1hbmVudCBUYXNrXCIsXG4gICAgICBwcmVmaXg6IFwiXHVEODNEXHVERkUwXCIsXG4gICAgfSxcbiAgICB7XG4gICAgICB0eXBlOiBcImEvYS9wXCIsXG4gICAgICBkZXNjcmlwdGlvbjogXCJBcmVhIG9mIFJlc3BvbnNpYmlsaXR5IC0gUHJpbWFyeVwiLFxuICAgICAgcHJlZml4OiBcIlx1RDgzRFx1REZFNVwiLFxuICAgIH0sXG4gICAge1xuICAgICAgdHlwZTogXCJhL2Evc1wiLFxuICAgICAgZGVzY3JpcHRpb246IFwiQXJlYSBvZiBSZXNwb25zaWJpbGl0eSAtIFNlY29uZGFyeVwiLFxuICAgICAgcHJlZml4OiBcIlx1RDgzRFx1REZFOVwiLFxuICAgIH0sXG4gICAge1xuICAgICAgdHlwZTogXCJhL2EvYVwiLFxuICAgICAgZGVzY3JpcHRpb246IFwiQXJlYSBvZiBSZXNwb25zaWJpbGl0eSAtIEFiYW5kb25lZFwiLFxuICAgICAgcHJlZml4OiBcIlx1RDgzRFx1REZFQVwiLFxuICAgIH0sXG4gICAge1xuICAgICAgdHlwZTogXCJiL24vc1wiLFxuICAgICAgZGVzY3JpcHRpb246IFwiWmV0dGVsa2FzdGVuIC0gU291cmNlIG5vdGVzIHNuaXBwZXRzIGZyb20gY29udGVudCBvciBSZWZlcmVuY2Ugbm90ZXMgKGxpa2UgYm9va3MgLyB2aWRlbyAvIHRob3VnaHRzIC8gY29udmVyc2F0aW9uKVwiLFxuICAgICAgcHJlZml4OiBcIlx1RDgzRFx1RENFOFwiLFxuICAgIH0sXG4gICAgLypcbiAgICB7XG4gICAgICB0eXBlOiBcImIvbi9yXCIsXG4gICAgICBkZXNjcmlwdGlvbjogXCJaZXR0ZWxrYXN0ZW4gLSBSZWZlcmVuY2Ugbm90ZXMgKGxpa2UgYm9va3MgLyB2aWRlbyAvIHRob3VnaHRzIC8gY29udmVyc2F0aW9uKVwiLFxuICAgICAgcHJlZml4OiBcIlx1RDgzRFx1RENENlwiLFxuICAgIH0sXG4gICAgKi9cbiAgICB7XG4gICAgICB0eXBlOiBcImIvbi9jXCIsXG4gICAgICBkZXNjcmlwdGlvbjogXCJaZXR0ZWxrYXN0ZW4gLSBDYXJkcyAoV2l0aCB5b3VyIG93biB0aG91Z2h0KVwiLFxuICAgICAgcHJlZml4OiBcIlx1RDgzRFx1REQxNlwiLFxuICAgIH0sXG4gICAge1xuICAgICAgdHlwZTogXCJiL24vcFwiLFxuICAgICAgZGVzY3JpcHRpb246IFwiUGVyc3BlY3RpdmUgLSBjb21iaW5lIG11bGl0cGxlIG5vdGVzIGludG8gYSBwZXJzcGVjdGl2ZSBlLmcuIHNvbHZlIGEgcHJvYmxlbVwiLFxuICAgICAgcHJlZml4OiBcIlx1RDgzRFx1REQwRFwiLFxuICAgIH0sXG4gICAge1xuICAgICAgdHlwZTogXCJiL24vZlwiLFxuICAgICAgZGVzY3JpcHRpb246IFwiRnJhbWV3b3JrIC0gVHJ5IHRvIHB1dCB0aGUgc3R1ZmYgaW50byBhIGEgZnJhbWV3b3JrIGFuZCBmaW5kIHRoZSBtaXNzaW5nIHB1enpsZVwiLFxuICAgICAgcHJlZml4OiBcIlx1RDgzRVx1RERFOVwiLFxuICAgIH0sXG4gICAge1xuICAgICAgdHlwZTogXCJjL2IvZFwiLFxuICAgICAgZGVzY3JpcHRpb246IFwiQmxvZyBwb3N0IGRyYWZ0XCIsXG4gICAgICBwcmVmaXg6IFwiXHVEODNEXHVEQ0M0XCIsXG4gICAgfSxcbiAgICB7XG4gICAgICB0eXBlOiBcImIvbi9qXCIsXG4gICAgICBkZXNjcmlwdGlvbjogXCJKb3VybmFsIC8gZXZlbnRzXCIsXG4gICAgICBwcmVmaXg6IFwiXHVEODNEXHVEQ0M1XCIsXG4gICAgfSxcbiAgICB7XG4gICAgICB0eXBlOiBcImIvbi9tXCIsXG4gICAgICBkZXNjcmlwdGlvbjogXCJaZXR0ZWxrYXN0ZW4gLSBNT0MgTm90ZXMgZm9yIGEgc21hbGwgdG9waWNcIixcbiAgICAgIHByZWZpeDogXCJcdUQ4M0RcdURDQzJcIixcbiAgICB9LFxuICAgIHtcbiAgICAgIHR5cGU6IFwiYi9uL3pcIixcbiAgICAgIGRlc2NyaXB0aW9uOiBcIlpldHRlbGthc3RlbiAtIFNsaXAgYm94IChtYWlubHkgb24gdGhvdWdodCBhbmQgdGhlIG9uZSBJIGFtIGludGVyZXN0ZWQpXCIsXG4gICAgICBwcmVmaXg6IFwiXHVEODNEXHVEREMzXHVGRTBGXCIsXG4gICAgfSxcbiAgICB7XG4gICAgICB0eXBlOiBcImIvbi9pXCIsXG4gICAgICBkZXNjcmlwdGlvbjogXCJJbmRleCBOb3RlcyBmb3Igb3RoZXJzIGZyYW1ld29ya1wiLFxuICAgICAgcHJlZml4OiBcIlx1RDgzRFx1RENDOVwiLFxuICAgIH0sXG4gICAge1xuICAgICAgdHlwZTogXCJiL24vdFwiLFxuICAgICAgZGVzY3JpcHRpb246IFwiUGxhY2Vob2xkZXIgTm90ZXMgZm9yIFRhcmdldCBBdWRpZW5jZSAoTm90ZXMgc3RhcnRzIHdpdGggVEEpXCIsXG4gICAgICBwcmVmaXg6IFwiXHVEODNEXHVEQzY0XCIsXG4gICAgfSxcbiAgICAvKlxuICAgIHtcbiAgICAgIHR5cGU6IFwiYi9uL3dcIixcbiAgICAgIGRlc2NyaXB0aW9uOiBcIldpa2kgTm90ZXMgZm9yIGEgbWVzc3kgd2lraSB0b3BpY1wiLFxuICAgICAgcHJlZml4OiBcIlx1RDgzRFx1RENENlwiLFxuICAgIH0sXG4gICAgKi9cbiAgICAvKlxuICAgIHtcbiAgICAgIHR5cGU6IFwiYi9uL3ZcIixcbiAgICAgIGRlc2NyaXB0aW9uOiBcIlpldHRlbGthc3RlbiAtIFZvaWNlIHNjcmlwdCAoRGVwcmVjYXRlZD8pXCIsXG4gICAgICBwcmVmaXg6IFwiXHVEODNEXHVEREUzXHVGRTBGXCIsXG4gICAgfSxcbiAgICAqL1xuICAgIC8qXG4gICAge1xuICAgICAgdHlwZTogXCJiL24vclwiLFxuICAgICAgZGVzY3JpcHRpb246IFwiWmV0dGVsa2FzdGVuIC0gUmVmZXJlbmNlIChEZXByZWNhdGVkPylcIixcbiAgICAgIHByZWZpeDogXCJcdUQ4M0RcdURDRDZcIixcbiAgICB9LFxuICAgICovXG4gICAgLypcbiAgICB7XG4gICAgICB0eXBlOiBcImIvbi91XCIsXG4gICAgICBkZXNjcmlwdGlvbjogXCJaZXR0ZWxrYXN0ZW4gLSBVbnByb2Nlc3NlZCBtYXRlcmlhbCBsaWtlIGFuIGluYm94XCIsXG4gICAgICBwcmVmaXg6IFwiXHVEODNEXHVEQ0U1XCIsXG4gICAgfSxcbiAgICAqL1xuICAgIHtcbiAgICAgIHR5cGU6IFwiYi90L2FcIixcbiAgICAgIGRlc2NyaXB0aW9uOiBcIkF0b21pYyBFc3NheSBUZW1wbGF0ZVwiLFxuICAgICAgcHJlZml4OiBcIlx1MjcwRFx1RDgzQ1x1REZGQlwiLFxuICAgIH0sXG4gICAge1xuICAgICAgdHlwZTogXCJiL3QvcFwiLFxuICAgICAgZGVzY3JpcHRpb246IFwiQ2hhdEdQVCBQcm9tcHQgVGVtcGxhdGVcIixcbiAgICAgIHByZWZpeDogXCJcdUQ4M0VcdURFODRcIixcbiAgICB9LFxuICAgIHtcbiAgICAgIHR5cGU6IFwiYy9hL2RcIixcbiAgICAgIGRlc2NyaXB0aW9uOiBcIkF0b21pYyBFc3NheSBkcmFmdGluZ1wiLFxuICAgICAgcHJlZml4OiBcIlx1RDgzQ1x1REQ5NVwiLFxuICAgIH0sXG4gICAge1xuICAgICAgdHlwZTogXCJjL2EvclwiLFxuICAgICAgZGVzY3JpcHRpb246IFwiQXRvbWljIEVzc2F5IHJlYWR5IHRvIHBvc3RcIixcbiAgICAgIHByZWZpeDogXCJcdUQ4M0NcdUREOTdcIixcbiAgICB9LFxuICAgIHtcbiAgICAgIHR5cGU6IFwiYy9hL3BcIixcbiAgICAgIGRlc2NyaXB0aW9uOiBcIkF0b21pYyBFc3NheSBwdWJsaXNoZWRcIixcbiAgICAgIHByZWZpeDogXCJcdUQ4M0NcdUREOTlcIixcbiAgICB9LFxuICAgIHtcbiAgICAgIHR5cGU6IFwiYy9hL2FcIixcbiAgICAgIGRlc2NyaXB0aW9uOiBcIkF0b21pYyBFc3NheSBhYmFuZG9uZWRcIixcbiAgICAgIHByZWZpeDogXCJcdUQ4M0RcdURERDFcdUZFMEZcIixcbiAgICB9LFxuICAgIHtcbiAgICAgIHR5cGU6IFwiYy9iL3JcIixcbiAgICAgIGRlc2NyaXB0aW9uOiBcIkJsb2cgcG9zdCByZWFkeSB0byBwdWJsaXNoXCIsXG4gICAgICBwcmVmaXg6IFwiXHVEODNDXHVERDk3XCIsXG4gICAgfSxcbiAgICB7XG4gICAgICB0eXBlOiBcImMvYi9wXCIsXG4gICAgICBkZXNjcmlwdGlvbjogXCJCbG9nIHBvc3QgcHVibGlzaGVkXCIsXG4gICAgICBwcmVmaXg6IFwiXHVEODNDXHVERDk5XCIsXG4gICAgfSxcbiAgICB7XG4gICAgICB0eXBlOiBcImMvYi9hXCIsXG4gICAgICBkZXNjcmlwdGlvbjogXCJCbG9nIHBvc3QgYWJhbmRvbmVkXCIsXG4gICAgICBwcmVmaXg6IFwiXHVEODNEXHVEREQxXHVGRTBGXCIsXG4gICAgfSxcbiAgICB7XG4gICAgICB0eXBlOiBcImMvdC9kXCIsXG4gICAgICBkZXNjcmlwdGlvbjogXCJUaHJlYWRzIHBvc3QgZHJhZnRcIixcbiAgICAgIHByZWZpeDogXCJcdUQ4M0NcdUREOTVcIixcbiAgICB9LFxuICAgIHtcbiAgICAgIHR5cGU6IFwiYy90L3JcIixcbiAgICAgIGRlc2NyaXB0aW9uOiBcIlRocmVhZHMgcG9zdCByZWFkeSB0byBwb3N0XCIsXG4gICAgICBwcmVmaXg6IFwiXHVEODNDXHVERDk3XCIsXG4gICAgfSxcbiAgICB7XG4gICAgICB0eXBlOiBcImMvdC90XCIsXG4gICAgICBkZXNjcmlwdGlvbjogXCJUaHJlYWRzIHBvc3QgdGhyZWFkcyBwdWJsaXNoZWRcIixcbiAgICAgIHByZWZpeDogXCJcdUQ4M0NcdUREOTlcIixcbiAgICB9LFxuICAgIHtcbiAgICAgIHR5cGU6IFwiYy90L3BcIixcbiAgICAgIGRlc2NyaXB0aW9uOiBcIlRocmVhZHMgcG9zdCBwdWJsaXNoZWRcIixcbiAgICAgIHByZWZpeDogXCJcdUQ4M0NcdUREOTlcIixcbiAgICB9LFxuICAgIHtcbiAgICAgIHR5cGU6IFwiYy90L29cIixcbiAgICAgIGRlc2NyaXB0aW9uOiBcIlRocmVhZHMgcG9zdCBvbGQgKHJld3JpdHRlbiBzb21ld2hlcmVcIixcbiAgICAgIHByZWZpeDogXCJcdUQ4M0RcdURDNzRcdUQ4M0NcdURGRkJcIixcbiAgICB9LFxuICAgIHtcbiAgICAgIHR5cGU6IFwiYy90L2FcIixcbiAgICAgIGRlc2NyaXB0aW9uOiBcIlRocmVhZHMgcG9zdCBhYmFuZG9uZWRcIixcbiAgICAgIHByZWZpeDogXCJcdUQ4M0RcdURERDFcdUZFMEZcIixcbiAgICB9LFxuICAgIHtcbiAgICAgIHR5cGU6IFwiYy94L2RcIixcbiAgICAgIGRlc2NyaXB0aW9uOiBcIlR3aXR0ZXIgcG9zdCBkcmFmdGluZ1wiLFxuICAgICAgcHJlZml4OiBcIlx1RDgzQ1x1REQ5NVwiLFxuICAgIH0sXG4gICAge1xuICAgICAgdHlwZTogXCJjL3gvclwiLFxuICAgICAgZGVzY3JpcHRpb246IFwiVHdpdHRlciBwb3N0IHJlYWR5IHRvIHB1Ymxpc2hcIixcbiAgICAgIHByZWZpeDogXCJcdUQ4M0NcdUREOTdcIixcbiAgICB9LFxuICAgIHtcbiAgICAgIHR5cGU6IFwiYy94L3BcIixcbiAgICAgIGRlc2NyaXB0aW9uOiBcIlR3aXR0ZXIgcG9zdCBwdWJsaXNoZWRcIixcbiAgICAgIHByZWZpeDogXCJcdUQ4M0NcdUREOTlcIixcbiAgICB9LFxuICAgIHtcbiAgICAgIHR5cGU6IFwiYS9uL3dcIixcbiAgICAgIGRlc2NyaXB0aW9uOiBcIk4gV2FpdGluZyBUYXNrXCIsXG4gICAgICBwcmVmaXg6IFwiXHVEODNEXHVERDM1XCIsXG4gICAgfSxcbiAgICB7XG4gICAgICB0eXBlOiBcImEvbi9kXCIsXG4gICAgICBkZXNjcmlwdGlvbjogXCJOIERvbmUgVGFza1wiLFxuICAgICAgcHJlZml4OiBcIlx1MjZBQVx1RkUwRlwiLFxuICAgIH0sXG4gICAge1xuICAgICAgdHlwZTogXCJhL24vYVwiLFxuICAgICAgZGVzY3JpcHRpb246IFwiTiBBcmNoaXZlIFRhc2tcIixcbiAgICAgIHByZWZpeDogXCJcdUQ4M0RcdURGRTNcIixcbiAgICB9LFxuICAgIHtcbiAgICAgIHR5cGU6IFwiYS9uL29cIixcbiAgICAgIGRlc2NyaXB0aW9uOiBcIk4gT3RoZXJzJyBUYXNrXCIsXG4gICAgICBwcmVmaXg6IFwiXHVEODNEXHVERkU0XCIsXG4gICAgfSxcbiAgICB7XG4gICAgICB0eXBlOiBcImEvdy93XCIsXG4gICAgICBkZXNjcmlwdGlvbjogXCJXIFdhaXRpbmcgVGFza1wiLFxuICAgICAgcHJlZml4OiBcIlx1RDgzRFx1REQzNVwiLFxuICAgIH0sXG4gICAge1xuICAgICAgdHlwZTogXCJhL3cvZFwiLFxuICAgICAgZGVzY3JpcHRpb246IFwiVyBEb25lIFRhc2tcIixcbiAgICAgIHByZWZpeDogXCJcdTI2QUFcdUZFMEZcIixcbiAgICB9LFxuICAgIHtcbiAgICAgIHR5cGU6IFwiYS93L2FcIixcbiAgICAgIGRlc2NyaXB0aW9uOiBcIlcgQXJjaGl2ZSBUYXNrXCIsXG4gICAgICBwcmVmaXg6IFwiXHVEODNEXHVERkUzXCIsXG4gICAgfSxcbiAgICB7XG4gICAgICB0eXBlOiBcImEvdy9vXCIsXG4gICAgICBkZXNjcmlwdGlvbjogXCJXIE90aGVycycgVGFza1wiLFxuICAgICAgcHJlZml4OiBcIlx1RDgzRFx1REZFNFwiLFxuICAgIH0sXG4gICAge1xuICAgICAgdHlwZTogXCJiL2svcVwiLFxuICAgICAgZGVzY3JpcHRpb246IFwiRXhwZXJtZW50aWFsIEtub3dsZWRnZSBHcm91cCAtIER1bW15IFF1ZXN0aW9uXCIsXG4gICAgICBwcmVmaXg6IFwiMFx1RkUwRlx1MjBFM1wiLFxuICAgIH0sXG4gICAge1xuICAgICAgdHlwZTogXCJiL2svZFwiLFxuICAgICAgZGVzY3JpcHRpb246IFwiRXhwZXJtZW50aWFsIEtub3dsZWRnZSBHcm91cCAtIERhdGFcIixcbiAgICAgIHByZWZpeDogXCIxXHVGRTBGXHUyMEUzXCIsXG4gICAgfSxcbiAgICB7XG4gICAgICB0eXBlOiBcImIvay9zXCIsXG4gICAgICBkZXNjcmlwdGlvbjogXCJFeHBlcm1lbnRpYWwgS25vd2xlZGdlIEdyb3VwIC0gU3ViamVjdGl2ZVwiLFxuICAgICAgcHJlZml4OiBcIjJcdUZFMEZcdTIwRTNcIixcbiAgICB9LFxuICAgIHtcbiAgICAgIHR5cGU6IFwiYi9rL3BcIixcbiAgICAgIGRlc2NyaXB0aW9uOiBcIkV4cGVybWVudGlhbCBLbm93bGVkZ2UgR3JvdXAgLSBDb21wbGV0ZSBzeXN0ZW0gdG8gc29sdmUgYSBQcm9ibGVtXCIsXG4gICAgICBwcmVmaXg6IFwiM1x1RkUwRlx1MjBFM1wiLFxuICAgIH0sXG4gICAge1xuICAgICAgdHlwZTogXCJiL2svY1wiLFxuICAgICAgZGVzY3JpcHRpb246IFwiRXhwZXJtZW50aWFsIEtub3dsZWRnZSBHcm91cCAtIENvbGxlY3Rpb25zIG9mIFN1YmplY3RpdmUgLyBQcm9ibGVtXCIsXG4gICAgICBwcmVmaXg6IFwiNFx1RkUwRlx1MjBFM1wiLFxuICAgIH0sXG5dO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Tm90ZVR5cGUocGF0aDpTdHJpbmcpIDogTm90ZVR5cGUgfCBudWxsIHtcbiAgICBjb25zdCBmaWxlID0gdGhpcy5hcHAudmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKHBhdGgpO1xuICAgIGlmICghZmlsZSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgeyBmcm9udG1hdHRlciB9ID0gYXBwLm1ldGFkYXRhQ2FjaGUuZ2V0RmlsZUNhY2hlKGZpbGUpIHx8IHt9O1xuICAgIGNvbnN0IGZtdGFncyA9IChwYXJzZUZyb250TWF0dGVyVGFncyhmcm9udG1hdHRlcikgfHwgW10pO1xuICAgIGZvciAoY29uc3QgdGFnIG9mIGZtdGFncykge1xuICAgICAgICBmb3IgKGNvbnN0IG5vdGVUeXBlIG9mIEFMTF9UWVBFUykge1xuICAgICAgICAgICAgaWYgKHRhZyA9PSBcIiNcIiArIG5vdGVUeXBlLnR5cGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm90ZVR5cGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGxcbn0iLCAiaW1wb3J0IHsgQXBwLCBFZGl0b3IsIEZ1enp5U3VnZ2VzdE1vZGFsLCBGdXp6eU1hdGNoIH0gZnJvbSBcIm9ic2lkaWFuXCI7XG5cbmludGVyZmFjZSBGb290bm90ZVR5cGUge1xuICB0eXBlOiBzdHJpbmc7XG4gIGRlc2NyaXB0aW9uOiBzdHJpbmc7XG59XG5cbmNvbnN0IEFMTF9UWVBFUyA9IFtcbiAge1xuICAgIHR5cGU6IFwiZC9cdTIzRUJcIixcbiAgICBkZXNjcmlwdGlvbjogXCJJZGVhL1Rhc2svQWN0aW9uIENvbXBhc3MgLSBVcCAtIFdoZXJlIGRvZXMgdGhpcyBpZGVhIGNvbWUgZnJvbSAvIFJlYXNvbiBvZiB0aGlzIGlkZWE/IE9SIFdoYXQgaXMgdGhlIGdvYWwvcHJlcmVxIG9mIHRoaXMgdGFzay9hY3Rpb24/XCJcbiAgfSxcbiAge1xuICAgIHR5cGU6IFwiZC9cdTIzRUNcIixcbiAgICBkZXNjcmlwdGlvbjogXCJJZGVhL1Rhc2svQWN0aW9uIENvbXBhc3MgLSBEb3duIC0gV2hlcmUgZG9lcyB0aGUgaWRlYSBsZWFkIHRvIC8gSXQgY2FuIHNvbHZlIHdoYXQgcHJvYmxlbT8gT1IgV2hhdCBpcyB0aGUgcmVzdWx0L25leHQgdGFzay9hY3Rpb24gb2YgdGhpcyB0YXNrL2FjdGlvbj9cIlxuICB9LFxuICB7XG4gICAgdHlwZTogXCJkL1x1MjNFQVwiLFxuICAgIGRlc2NyaXB0aW9uOiBcIklkZWEvVGFzay9BY3Rpb24gQ29tcGFzcyAtIExlZnQgLSBXaGF0IGFyZSBzaW1pbGFyIC8gc3VwcG9ydGluZyBpZGVhPyBPUiBTYW1lIEdvYWwgRGlmZmVyZW50IFRhc2svQWN0aW9uP1wiXG4gIH0sXG4gIHtcbiAgICB0eXBlOiBcImQvXHUyM0U5XHVGRTBGXCIsXG4gICAgZGVzY3JpcHRpb246IFwiSWRlYS9UYXNrL0FjdGlvbiBDb21wYXNzIC0gUmlnaHQgLSBXaGF0IGFyZSBvcHBvc2UgaWRlYT8gT1IgU2FtZSBUYXNrL0FjdGlvbiBEaWZmZXJlbnQgR29hbD9cIlxuICB9LFxuICB7XG4gICAgdHlwZTogXCJkL1x1MkIwNVx1RkUwRlwiLFxuICAgIGRlc2NyaXB0aW9uOiBcIlByZXZpb3VzIHZlcnNpb24gb2YgdGhpcyBpZGVhXCJcbiAgfSxcbiAge1xuICAgIHR5cGU6IFwiZC9cdTI3QTFcdUZFMEZcIixcbiAgICBkZXNjcmlwdGlvbjogXCJOZXh0IHZlcnNpb24gb2YgdGhpcyBpZGVhXCJcbiAgfSxcbiAge1xuICAgIHR5cGU6IFwiZC9cdUQ4M0RcdUREMDRcIixcbiAgICBkZXNjcmlwdGlvbjogXCJDb250ZXh0XCJcbiAgfSxcbiAge1xuICAgIHR5cGU6IFwiZC9cdTIzRjlcdUZFMEZcIixcbiAgICBkZXNjcmlwdGlvbjogXCJBMSAtIG15IGV4cGVyaWVuY2VcIlxuICB9LFxuICAvKlxuICB7XG4gICAgdHlwZTogXCJkL3F1ZXN0aW9uXCIsXG4gICAgZGVzY3JpcHRpb246IFwiUXVlc3Rpb25cIlxuICB9LFxuICB7XG4gICAgdHlwZTogXCJkL2Fuc3dlclwiLFxuICAgIGRlc2NyaXB0aW9uOiBcIkFuc3dlclwiXG4gIH0sXG4gIHtcbiAgICB0eXBlOiBcImQvc29sdmVzXCIsXG4gICAgZGVzY3JpcHRpb246IFwiU29sdmVzIHNvbWUgcHJvYmxlbVwiXG4gIH0sXG4gIHtcbiAgICB0eXBlOiBcImQvcmVmXCIsXG4gICAgZGVzY3JpcHRpb246IFwiUmVmZXJlbmNlXCJcbiAgfSxcbiAge1xuICAgIHR5cGU6IFwiZC9zZWxmdGhpbmtcIixcbiAgICBkZXNjcmlwdGlvbjogXCJTZWxmIHRoaW5rXCJcbiAgfSxcbiAge1xuICAgIHR5cGU6IFwiZC9ub3RzdXJlXCIsXG4gICAgZGVzY3JpcHRpb246IFwiTm90IHN1cmVcIlxuICB9LFxuICB7XG4gICAgdHlwZTogXCJkL2EyXHUyM0ZBXHVGRTBGXCIsXG4gICAgZGVzY3JpcHRpb246IFwiQTIgLSBmdXR1cmUgYWN0aW9uXCJcbiAgfSxcbiAgKi9cbiAgLypcbiAge1xuICAgIHR5cGU6IFwiZC90b01lcmdlXCIsXG4gICAgZGVzY3JpcHRpb246IFwiVE9ETyAtIFRvIE1lcmdlIHdpdGggYW5vdGhlciBub3RlXCJcbiAgfSxcbiAge1xuICAgIHR5cGU6IFwiZC90b01vdmVcIixcbiAgICBkZXNjcmlwdGlvbjogXCJUT0RPIC0gVG8gTWVyZ2Ugd2l0aCBhbm90aGVyIG5vdGVcIlxuICB9LFxuICB7XG4gICAgdHlwZTogXCJkL3RvU3BsaXRcIixcbiAgICBkZXNjcmlwdGlvbjogXCJUb0RPIC0gVG8gU3BsaXQgdG8gbXVsdGlwbGUgbm90ZVwiXG4gIH0sXG4gIHtcbiAgICB0eXBlOiBcImQvdG9DYXJkXCIsXG4gICAgZGVzY3JpcHRpb246IFwiVE9ETyAtIFRvIFdyaXRlIGNhcmRcIlxuICB9LFxuICAqL1xuXTtcblxuZXhwb3J0IGNsYXNzIEFkZEZvb3Rub3RlVGFnTW9kYWwgZXh0ZW5kcyBGdXp6eVN1Z2dlc3RNb2RhbDxGb290bm90ZVR5cGU+IHtcblxuICBlZGl0b3I6IEVkaXRvclxuICBrZXlkb3duSGFuZGxlcjogKGV2ZW50OiBLZXlib2FyZEV2ZW50KSA9PiB2b2lkO1xuXG4gIGNvbnN0cnVjdG9yKGFwcDogQXBwLCBlZGl0b3I6IEVkaXRvcilcbiAge1xuICAgIHN1cGVyKGFwcClcbiAgICB0aGlzLmVkaXRvciA9IGVkaXRvclxuICAgIHRoaXMua2V5ZG93bkhhbmRsZXIgPSAoZXZlbnQ6IEtleWJvYXJkRXZlbnQpID0+IHtcbiAgICAgIC8vY29uc29sZS5sb2coXCJjdHJsIFwiICsgZXZlbnQuY3RybEtleSlcbiAgICAgIC8vY29uc29sZS5sb2coXCJhbHQgXCIgKyBldmVudC5hbHRLZXkpXG4gICAgICAvL2NvbnNvbGUubG9nKFwibWV0YSBcIiArIGV2ZW50Lm1ldGFLZXkpXG4gICAgICAvL2NvbnNvbGUubG9nKFwic2hpZnQgXCIgKyBldmVudC5zaGlmdEtleSlcbiAgICAgIC8vY29uc29sZS5sb2coXCJrZXkgXCIgKyBldmVudC5rZXkpXG4gICAgICAvLyBDaGVjayBpZiBDdHJsICsgUSB3YXMgcHJlc3NlZFxuICAgICAgaWYgKGV2ZW50LmN0cmxLZXkgJiYgZXZlbnQuYWx0S2V5ICYmIGV2ZW50LnNoaWZ0S2V5ICYmIGV2ZW50LmtleSA9PT0gJ1onKSB7IC8vIHdpbmRvd3NcbiAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgfSBlbHNlIGlmIChldmVudC5jdHJsS2V5ICYmIGV2ZW50Lm1ldGFLZXkgJiYgZXZlbnQuc2hpZnRLZXkgJiYgZXZlbnQua2V5ID09PSAnWicpIHsgLy8gbWFjb3NcbiAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgfSBlbHNlIGlmIChldmVudC5tZXRhS2V5IHx8IGV2ZW50LmN0cmxLZXkpIHtcbiAgICAgICAgY29uc3Qga2V5ID0gcGFyc2VJbnQoZXZlbnQua2V5LCAxMCk7XG4gICAgICAgIGlmIChrZXkgPj0gMSAmJiBrZXkgPD0gOSkge1xuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7IC8vIFByZXZlbnQgZGVmYXVsdCBhY3Rpb25cbiAgICAgICAgICB0aGlzLnNlbGVjdEVsZW1lbnQoa2V5IC0gMSk7IC8vIFNlbGVjdCB0aGUgZWxlbWVudCAoaW5kZXgga2V5IC0gMSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBMaXN0ZW4gZm9yIGtleWRvd24gZXZlbnRzIGF0IHRoZSBkb2N1bWVudCBsZXZlbFxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLmtleWRvd25IYW5kbGVyKTtcbiAgfVxuXG4gIHNlbGVjdEVsZW1lbnQoaW5kZXg6IG51bWJlcikge1xuICAgIGNvbnN0IGVsZW1lbnRzID0gdGhpcy5yZXN1bHRDb250YWluZXJFbC5xdWVyeVNlbGVjdG9yQWxsKCcuc3VnZ2VzdGlvbi1pdGVtJyk7XG4gICAgaWYgKGVsZW1lbnRzLmxlbmd0aCA+IGluZGV4KSB7XG4gICAgICBjb25zdCBlbGVtZW50ID0gZWxlbWVudHNbaW5kZXhdIGFzIEhUTUxFbGVtZW50O1xuICAgICAgZWxlbWVudC5jbGljaygpOyAvLyBTaW11bGF0ZSBhIGNsaWNrIHRvIHNlbGVjdCB0aGUgZWxlbWVudFxuICAgIH1cbiAgfVxuXG4gIG9uQ2xvc2UoKSB7XG4gICAgc3VwZXIub25DbG9zZSgpO1xuICAgIC8vIFN0b3AgbGlzdGVuaW5nIGZvciBrZXlkb3duIGV2ZW50cyB3aGVuIHRoZSBtb2RhbCBpcyBjbG9zZWRcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5rZXlkb3duSGFuZGxlcik7XG4gIH1cblxuICBnZXRJdGVtcygpOiBGb290bm90ZVR5cGVbXSB7XG4gICAgcmV0dXJuIEFMTF9UWVBFUztcbiAgfVxuXG4gIGdldEl0ZW1UZXh0KG5vdGVUeXBlOiBGb290bm90ZVR5cGUpOiBzdHJpbmcge1xuICAgIHJldHVybiBub3RlVHlwZS50eXBlO1xuICB9XG5cbiAgc3RhdGljIHJlbW92ZVRhZyhsaW5lOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIEFMTF9UWVBFUy5mb3JFYWNoKChub3RlVHlwZSkgPT4gbGluZSA9IGxpbmUucmVwbGFjZShgIyR7bm90ZVR5cGUudHlwZX0gYCwgJycpKVxuICAgIHJldHVybiBsaW5lXG4gIH1cblxuICAvLyBSZW5kZXJzIGVhY2ggc3VnZ2VzdGlvbiBpdGVtLlxuICByZW5kZXJTdWdnZXN0aW9uKGNob29zZW5Ob3RlVHlwZU1hdGNoOiBGdXp6eU1hdGNoPEZvb3Rub3RlVHlwZT4sIGVsOiBIVE1MRWxlbWVudCkge1xuICAgIGNvbnN0IG5vdGVUeXBlID0gY2hvb3Nlbk5vdGVUeXBlTWF0Y2guaXRlbVxuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5yZXN1bHRDb250YWluZXJFbC5xdWVyeVNlbGVjdG9yQWxsKCcuc3VnZ2VzdGlvbi1pdGVtJykubGVuZ3RoO1xuICAgIGNvbnN0IGl0ZW1JbmRleCA9IGluZGV4IDwgMTAgPyBpbmRleCArIFwiLiBcIiA6IFwiICAgIFwiXG4gICAgZWwuY3JlYXRlRWwoXCJkaXZcIiwgeyB0ZXh0OiBpdGVtSW5kZXggKyBub3RlVHlwZS50eXBlIH0pO1xuICAgIGVsLmNyZWF0ZUVsKFwic21hbGxcIiwgeyB0ZXh0OiBcIiAgICAgXCIgKyBub3RlVHlwZS5kZXNjcmlwdGlvbiB9KTtcbiAgfVxuXG4gIGNvbnRhaW5zVHlwZShsaW5lOiBTdHJpbmcpIDogQm9vbGVhbiB7XG4gICAgcmV0dXJuIEFMTF9UWVBFUy5maWx0ZXIoKG5vdGVUeXBlKSA9PiBsaW5lLmNvbnRhaW5zKG5vdGVUeXBlLnR5cGUpKS5sZW5ndGggPiAwXG4gIH1cblxuICAvLyBQZXJmb3JtIGFjdGlvbiBvbiB0aGUgc2VsZWN0ZWQgc3VnZ2VzdGlvbi5cbiAgb25DaG9vc2VJdGVtKGNob29zZW5Ob3RlVHlwZTogRm9vdG5vdGVUeXBlLCBldnQ6IE1vdXNlRXZlbnQgfCBLZXlib2FyZEV2ZW50KSB7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gdGhpcy5lZGl0b3IuZ2V0U2VsZWN0aW9uKClcbiAgICBjb25zdCByZXBsYWNlZFN0ciA9IGAjJHtjaG9vc2VuTm90ZVR5cGUudHlwZX0gYFxuICAgIGlmIChzZWxlY3Rpb24ubGVuZ3RoICE9IDApIHtcbiAgICAgICAgdGhpcy5lZGl0b3IucmVwbGFjZVNlbGVjdGlvbihyZXBsYWNlZFN0cik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgY3Vyc29yID0gdGhpcy5lZGl0b3IuZ2V0Q3Vyc29yKCk7XG4gICAgICAgIHRoaXMuZWRpdG9yLnJlcGxhY2VSYW5nZShyZXBsYWNlZFN0ciwgY3Vyc29yKTtcbiAgICAgICAgY3Vyc29yLmNoID0gY3Vyc29yLmNoICsgcmVwbGFjZWRTdHIubGVuZ3RoO1xuICAgICAgICB0aGlzLmVkaXRvci5zZXRDdXJzb3IoY3Vyc29yKTtcbiAgICB9XG4gIH1cbn0iLCAiaW1wb3J0IHsgQXBwLCBFZGl0b3IsIEZ1enp5U3VnZ2VzdE1vZGFsLCBGdXp6eU1hdGNoIH0gZnJvbSBcIm9ic2lkaWFuXCI7XG5cbmludGVyZmFjZSBDb21tZW50VHlwZSB7XG4gIHR5cGU6IHN0cmluZztcbiAgY3Vyc29yOiBzdHJpbmc7XG4gIGRlc2NyaXB0aW9uOiBzdHJpbmc7XG59XG5cbmNvbnN0IEFMTF9UWVBFUyA9IFtcbiAgLypcbiAge1xuICAgIHR5cGU6IFwiblwiLFxuICAgIGN1cnNvcjogXCJjXCIsXG4gICAgZGVzY3JpcHRpb246IFwiTiBDdXJzb3JcIlxuICB9LFxuICAqL1xuICB7XG4gICAgdHlwZTogXCJuXCIsXG4gICAgY3Vyc29yOiBcImJcIixcbiAgICBkZXNjcmlwdGlvbjogXCJOIEJlZ2lubmluZyBvZiBsaW5lXCJcbiAgfSxcbiAgLypcbiAge1xuICAgIHR5cGU6IFwiblwiLFxuICAgIGN1cnNvcjogXCJlXCIsXG4gICAgZGVzY3JpcHRpb246IFwiTiBFbmQgb2YgbGluZVwiXG4gIH0sXG4gIHtcbiAgICB0eXBlOiBcIndcIixcbiAgICBjdXJzb3I6IFwiY1wiLFxuICAgIGRlc2NyaXB0aW9uOiBcIlcgQ3Vyc29yXCJcbiAgfSxcbiAgKi9cbiAge1xuICAgIHR5cGU6IFwid1wiLFxuICAgIGN1cnNvcjogXCJiXCIsXG4gICAgZGVzY3JpcHRpb246IFwiVyBCZWdpbm5pbmcgb2YgbGluZVwiXG4gIH0sXG4gIC8qXG4gIHtcbiAgICB0eXBlOiBcIndcIixcbiAgICBjdXJzb3I6IFwiZVwiLFxuICAgIGRlc2NyaXB0aW9uOiBcIlcgRW5kIG9mIGxpbmVcIlxuICB9XG4gICovXG5dO1xuXG5leHBvcnQgY2xhc3MgQWRkVGFza1RhZ01vZGFsIGV4dGVuZHMgRnV6enlTdWdnZXN0TW9kYWw8Q29tbWVudFR5cGU+IHtcblxuICBlZGl0b3I6IEVkaXRvclxuICB0YXNrVHlwZTogU3RyaW5nXG5cbiAgY29uc3RydWN0b3IoYXBwOiBBcHAsIGVkaXRvcjogRWRpdG9yLCB0YXNrVHlwZTogU3RyaW5nKVxuICB7XG4gICAgc3VwZXIoYXBwKVxuICAgIHRoaXMuZWRpdG9yID0gZWRpdG9yXG4gICAgdGhpcy50YXNrVHlwZSA9IHRhc2tUeXBlXG4gIH1cblxuICBnZXRJdGVtcygpOiBDb21tZW50VHlwZVtdIHtcbiAgICByZXR1cm4gQUxMX1RZUEVTO1xuICB9XG5cbiAgZ2V0SXRlbVRleHQobm90ZVR5cGU6IENvbW1lbnRUeXBlKTogc3RyaW5nIHtcbiAgICByZXR1cm4gbm90ZVR5cGUudHlwZSArIG5vdGVUeXBlLmN1cnNvcjtcbiAgfVxuXG4gIC8vIFJlbmRlcnMgZWFjaCBzdWdnZXN0aW9uIGl0ZW0uXG4gIHJlbmRlclN1Z2dlc3Rpb24oY2hvb3Nlbk5vdGVUeXBlTWF0Y2g6IEZ1enp5TWF0Y2g8Q29tbWVudFR5cGU+LCBlbDogSFRNTEVsZW1lbnQpIHtcbiAgICBjb25zdCBub3RlVHlwZSA9IGNob29zZW5Ob3RlVHlwZU1hdGNoLml0ZW1cbiAgICBlbC5jcmVhdGVFbChcImRpdlwiLCB7IHRleHQ6IG5vdGVUeXBlLnR5cGUgKyBcIiBcIiArIG5vdGVUeXBlLmN1cnNvciB9KTtcbiAgICBlbC5jcmVhdGVFbChcInNtYWxsXCIsIHsgdGV4dDogbm90ZVR5cGUuZGVzY3JpcHRpb24gfSk7XG4gIH1cblxuICBjb250YWluc1R5cGUobGluZTogU3RyaW5nKSA6IEJvb2xlYW4ge1xuICAgIHJldHVybiBBTExfVFlQRVMuZmlsdGVyKChub3RlVHlwZSkgPT4gbGluZS5jb250YWlucyhub3RlVHlwZS50eXBlKSkubGVuZ3RoID4gMFxuICB9XG5cbiAgLy8gUGVyZm9ybSBhY3Rpb24gb24gdGhlIHNlbGVjdGVkIHN1Z2dlc3Rpb24uXG4gIG9uQ2hvb3NlSXRlbShjaG9vc2VuTm90ZVR5cGU6IENvbW1lbnRUeXBlLCBldnQ6IE1vdXNlRXZlbnQgfCBLZXlib2FyZEV2ZW50KSB7XG4gICAgY29uc3QgY3Vyc29yID0gdGhpcy5lZGl0b3IuZ2V0Q3Vyc29yKClcbiAgICBjb25zdCBsaW5lID0gdGhpcy5lZGl0b3IuZ2V0TGluZShjdXJzb3IubGluZSk7XG4gICAgXG4gICAgaWYgKGNob29zZW5Ob3RlVHlwZS5jdXJzb3IgPT0gXCJjXCIpIHtcbiAgICAgIHRoaXMuZWRpdG9yLnJlcGxhY2VSYW5nZShgJHtsaW5lLmNoYXJBdChjdXJzb3IuY2ggLSAxKSAhPSAnICcgPyAnICcgOiBcIlwifSMke2Nob29zZW5Ob3RlVHlwZS50eXBlfSR7dGhpcy50YXNrVHlwZX0gYCwgY3Vyc29yKTsgIFxuICAgICAgY3Vyc29yLmNoID0gY3Vyc29yLmNoICsgNCArIChsaW5lLmNoYXJBdChjdXJzb3IuY2ggLSAxKSAhPSAnICcgPyAxIDogMCk7XG5cdFx0ICB0aGlzLmVkaXRvci5zZXRDdXJzb3IoY3Vyc29yKTtcbiAgICB9IGVsc2UgaWYgKGNob29zZW5Ob3RlVHlwZS5jdXJzb3IgPT0gXCJiXCIpIHtcbiAgICAgIGxldCBtb2RpZmllZExpbmUgPSBsaW5lO1xuICAgICAgaWYgKC9eXFx0Ki0gLy50ZXN0KGxpbmUpKSB7XG4gICAgICAgIG1vZGlmaWVkTGluZSA9IGxpbmUucmVwbGFjZSgvXihcXHQqLSApLywgYCQxIyR7Y2hvb3Nlbk5vdGVUeXBlLnR5cGV9JHt0aGlzLnRhc2tUeXBlfSBgKTtcbiAgICAgIH0gZWxzZSBpZiAoL15cXHQqXFxkK1xcLiAvLnRlc3QobGluZSkpIHtcbiAgICAgICAgbW9kaWZpZWRMaW5lID0gbGluZS5yZXBsYWNlKC9eKFxcdCpcXGQrXFwuICkvLCBgJDEke2Nob29zZW5Ob3RlVHlwZS50eXBlfSR7dGhpcy50YXNrVHlwZX0gYCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtb2RpZmllZExpbmUgPSBsaW5lLnJlcGxhY2UoL14vLCBgIyR7Y2hvb3Nlbk5vdGVUeXBlLnR5cGV9JHt0aGlzLnRhc2tUeXBlfSBgKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZWRpdG9yLnNldExpbmUoY3Vyc29yLmxpbmUsIG1vZGlmaWVkTGluZSk7XG4gICAgICBjdXJzb3IuY2ggPSBjdXJzb3IuY2ggKyA0O1xuXHRcdCAgdGhpcy5lZGl0b3Iuc2V0Q3Vyc29yKGN1cnNvcik7XG4gICAgfSBlbHNlIGlmIChjaG9vc2VuTm90ZVR5cGUuY3Vyc29yID09IFwiZVwiKSB7XG4gICAgICBsZXQgbW9kaWZpZWRMaW5lID0gbGluZS5yZXBsYWNlKC8kLywgYCAjJHtjaG9vc2VuTm90ZVR5cGUudHlwZX0ke3RoaXMudGFza1R5cGV9YCk7XG4gICAgICB0aGlzLmVkaXRvci5zZXRMaW5lKGN1cnNvci5saW5lLCBtb2RpZmllZExpbmUpO1xuICAgICAgY3Vyc29yLmNoID0gY3Vyc29yLmNoO1xuXHRcdCAgdGhpcy5lZGl0b3Iuc2V0Q3Vyc29yKGN1cnNvcik7XG4gICAgfVxuICAgIFxuICB9XG59IiwgImltcG9ydCB7IEFwcCwgRWRpdG9yLCBGdXp6eVN1Z2dlc3RNb2RhbCwgRnV6enlNYXRjaCwgTm90aWNlIH0gZnJvbSBcIm9ic2lkaWFuXCI7XG5cbmludGVyZmFjZSBDb21tZW50VHlwZSB7XG4gIHR5cGU6IHN0cmluZztcbiAgZGVzY3JpcHRpb246IHN0cmluZztcbn1cblxuY29uc3QgQUxMX1RZUEVTID0gW1xuICB7XG4gICAgdHlwZTogXCJmaXJzdC1wYWdlXCIsXG4gICAgZGVzY3JpcHRpb246IFwiZmlyc3QgcGFnZVwiXG4gIH0sXG4gIHtcbiAgICB0eXBlOiBcIndpdGgtaGVhZGVyXCIsXG4gICAgZGVzY3JpcHRpb246IFwid2l0aCBoZWFkZXJcIlxuICB9LFxuICB7XG4gICAgdHlwZTogXCJ3aXRob3V0LWhlYWRlclwiLFxuICAgIGRlc2NyaXB0aW9uOiBcIndpdGhvdXQgaGVhZGVyXCJcbiAgfSxcbiAge1xuICAgIHR5cGU6IFwiY3VzdG9tLWZvbnQtc2l6ZVwiLFxuICAgIGRlc2NyaXB0aW9uOiBcImN1c3RvbSBmb250IHNpemVcIlxuICB9LFxuXTtcblxuZXhwb3J0IGNsYXNzIFRocmVhZHNUb0ltYWdlc01vZGFsIGV4dGVuZHMgRnV6enlTdWdnZXN0TW9kYWw8Q29tbWVudFR5cGU+IHtcblxuICB0aHJlYWRTZWdtZW50OiBTdHJpbmdcblxuICBjb25zdHJ1Y3RvcihhcHA6IEFwcCwgdGhyZWFkU2VnbWVudDogU3RyaW5nKVxuICB7XG4gICAgc3VwZXIoYXBwKVxuICAgIHRoaXMudGhyZWFkU2VnbWVudCA9IHRocmVhZFNlZ21lbnRcbiAgfVxuXG4gIGdldEl0ZW1zKCk6IENvbW1lbnRUeXBlW10ge1xuICAgIHJldHVybiBBTExfVFlQRVM7XG4gIH1cblxuICBnZXRJdGVtVGV4dChub3RlVHlwZTogQ29tbWVudFR5cGUpOiBzdHJpbmcge1xuICAgIHJldHVybiBub3RlVHlwZS50eXBlO1xuICB9XG5cbiAgLy8gUmVuZGVycyBlYWNoIHN1Z2dlc3Rpb24gaXRlbS5cbiAgcmVuZGVyU3VnZ2VzdGlvbihjaG9vc2VuTm90ZVR5cGVNYXRjaDogRnV6enlNYXRjaDxDb21tZW50VHlwZT4sIGVsOiBIVE1MRWxlbWVudCkge1xuICAgIGNvbnN0IG5vdGVUeXBlID0gY2hvb3Nlbk5vdGVUeXBlTWF0Y2guaXRlbVxuICAgIGVsLmNyZWF0ZUVsKFwiZGl2XCIsIHsgdGV4dDogbm90ZVR5cGUudHlwZSB9KTtcbiAgICBlbC5jcmVhdGVFbChcInNtYWxsXCIsIHsgdGV4dDogbm90ZVR5cGUuZGVzY3JpcHRpb24gfSk7XG4gIH1cblxuICBjb250YWluc1R5cGUobGluZTogU3RyaW5nKSA6IEJvb2xlYW4ge1xuICAgIHJldHVybiBBTExfVFlQRVMuZmlsdGVyKChub3RlVHlwZSkgPT4gbGluZS5jb250YWlucyhub3RlVHlwZS50eXBlKSkubGVuZ3RoID4gMFxuICB9XG5cbiAgLy8gUGVyZm9ybSBhY3Rpb24gb24gdGhlIHNlbGVjdGVkIHN1Z2dlc3Rpb24uXG4gIG9uQ2hvb3NlSXRlbShjaG9vc2VuTm90ZVR5cGU6IENvbW1lbnRUeXBlLCBldnQ6IE1vdXNlRXZlbnQgfCBLZXlib2FyZEV2ZW50KSB7XG4gICAgbGV0IHBhcmFtID0gY2hvb3Nlbk5vdGVUeXBlLnR5cGVcbiAgICBsZXQgcyA9IHRoaXMudGhyZWFkU2VnbWVudC50b1N0cmluZygpXG4gICAgbmF2aWdhdG9yLmNsaXBib2FyZC53cml0ZVRleHQodGhpcy50aHJlYWRTZWdtZW50LnRvU3RyaW5nKCkpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICBuZXcgTm90aWNlKGBDb3BpZWRcXG5cXGBcXGBcXGBcXG4ke3N9XFxgXFxgXFxgXFxudG8gY2xpcGJvYXJkIWApO1xuICAgICAgICB3aW5kb3cub3Blbihgc2hvcnRjdXRzOi8vcnVuLXNob3J0Y3V0P25hbWU9VGhyZWFkcyUyMHRvJTIwaW1hZ2UmaW5wdXQ9dGV4dCZ0ZXh0PSR7cGFyYW19Jngtc3VjY2Vzcz1vYnNpZGlhbjovLyZ4LWNhbmNlbD1vYnNpZGlhbjovLyZ4LWVycm9yPW9ic2lkaWFuOi8vYCk7XG4gICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgIG5ldyBOb3RpY2UoYGVycm9yIHdoZW4gY29weSB0byBjbGlwYm9hcmQhYCk7XG4gICAgfSk7XG4gIH1cbn0iLCAiaW1wb3J0IHsgQXBwLCBFZGl0b3IsIEZ1enp5U3VnZ2VzdE1vZGFsLCBGdXp6eU1hdGNoLCBURmlsZSwgVmF1bHQgfSBmcm9tIFwib2JzaWRpYW5cIjtcblxuaW50ZXJmYWNlIENvcHlPck1vdmUge1xuICB0eXBlOiBzdHJpbmc7XG4gIGRlc2NyaXB0aW9uOiBzdHJpbmc7XG59XG5cbmNvbnN0IEFMTF9UWVBFUyA9IFtcbiAge1xuICAgIHR5cGU6IFwiY29weVwiLFxuICAgIGRlc2NyaXB0aW9uOiBcIkNvcHlcIlxuICB9LFxuICB7XG4gICAgdHlwZTogXCJtb3ZlXCIsXG4gICAgZGVzY3JpcHRpb246IFwiTW92ZVwiXG4gIH0sXG5dO1xuXG5leHBvcnQgY2xhc3MgQ29weU9yTW92ZVRvTmV3Tm90ZU1vZGFsIGV4dGVuZHMgRnV6enlTdWdnZXN0TW9kYWw8Q29weU9yTW92ZT4ge1xuXG4gIGVkaXRvcjogRWRpdG9yXG4gIHRhc2tUeXBlOiBTdHJpbmdcblxuICBjb25zdHJ1Y3RvcihhcHA6IEFwcCwgZWRpdG9yOiBFZGl0b3IpXG4gIHtcbiAgICBzdXBlcihhcHApXG4gICAgdGhpcy5lZGl0b3IgPSBlZGl0b3JcbiAgICB0aGlzLnNldFBsYWNlaG9sZGVyKGBDb3B5IG9yIG1vdmUgc2VsZWN0aW9uIHRvIG5ldyBub3RlP2ApXG4gIH1cblxuICBnZXRJdGVtcygpOiBDb3B5T3JNb3ZlW10ge1xuICAgIHJldHVybiBBTExfVFlQRVM7XG4gIH1cblxuICBnZXRJdGVtVGV4dChub3RlVHlwZTogQ29weU9yTW92ZSk6IHN0cmluZyB7XG4gICAgcmV0dXJuIG5vdGVUeXBlLnR5cGU7XG4gIH1cblxuICAvLyBSZW5kZXJzIGVhY2ggc3VnZ2VzdGlvbiBpdGVtLlxuICByZW5kZXJTdWdnZXN0aW9uKGNob29zZW5Ob3RlVHlwZU1hdGNoOiBGdXp6eU1hdGNoPENvcHlPck1vdmU+LCBlbDogSFRNTEVsZW1lbnQpIHtcbiAgICBjb25zdCBub3RlVHlwZSA9IGNob29zZW5Ob3RlVHlwZU1hdGNoLml0ZW1cbiAgICBlbC5jcmVhdGVFbChcImRpdlwiLCB7IHRleHQ6IG5vdGVUeXBlLnR5cGUgfSk7XG4gICAgZWwuY3JlYXRlRWwoXCJzbWFsbFwiLCB7IHRleHQ6IG5vdGVUeXBlLmRlc2NyaXB0aW9uIH0pO1xuICB9XG5cbiAgY29udGFpbnNUeXBlKGxpbmU6IFN0cmluZykgOiBCb29sZWFuIHtcbiAgICByZXR1cm4gQUxMX1RZUEVTLmZpbHRlcigobm90ZVR5cGUpID0+IGxpbmUuY29udGFpbnMobm90ZVR5cGUudHlwZSkpLmxlbmd0aCA+IDBcbiAgfVxuXG4gIC8vIFBlcmZvcm0gYWN0aW9uIG9uIHRoZSBzZWxlY3RlZCBzdWdnZXN0aW9uLlxuICBhc3luYyBvbkNob29zZUl0ZW0oY2hvb3Nlbk9wZXJhdGlvbjogQ29weU9yTW92ZSwgZXZ0OiBNb3VzZUV2ZW50IHwgS2V5Ym9hcmRFdmVudCkge1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9IHRoaXMuZWRpdG9yLmdldFNlbGVjdGlvbigpXG4gICAgY29uc3QgbGluZSA9IHRoaXMuZWRpdG9yLmdldEN1cnNvcigpLmxpbmVcbiAgICBjb25zdCB0ZXh0VG9Db3B5T3JNb3ZlID0gKHNlbGVjdGlvbi5sZW5ndGggPT0gMClcbiAgICAgICAgICAgICAgICA/IHRoaXMuZWRpdG9yLmdldExpbmUobGluZSlcbiAgICAgICAgICAgICAgICA6IHNlbGVjdGlvblxuICAgIFxuICAgIGNvbnN0IG5ld0ZpbGVOYW1lID0gXCJJL1VuaXRlZCBQdXNoLm1kXCJcbiAgICBhd2FpdCB0aGlzLmNyZWF0ZU9yQXBwZW5kRmlsZShuZXdGaWxlTmFtZSwgdGV4dFRvQ29weU9yTW92ZSlcblxuICAgIGlmIChjaG9vc2VuT3BlcmF0aW9uLnR5cGUgPT0gXCJtb3ZlXCIpIHtcbiAgICAgIGlmIChzZWxlY3Rpb24ubGVuZ3RoICE9IDApIHtcbiAgICAgICAgdGhpcy5lZGl0b3IucmVwbGFjZVNlbGVjdGlvbihcIlwiKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IGNvbnRlbnQgPSBcIlwiXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5lZGl0b3IubGluZUNvdW50KCk7IGkrKykge1xuICAgICAgICAgIGlmIChpICE9IGxpbmUpIHtcbiAgICAgICAgICAgIGNvbnRlbnQgKz0gdGhpcy5lZGl0b3IuZ2V0TGluZShpKSArIFwiXFxuXCJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lZGl0b3Iuc2V0VmFsdWUoY29udGVudClcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCB7IHZhdWx0IH0gPSB0aGlzLmFwcDtcbiAgICBjb25zdCB7IHdvcmtzcGFjZSB9ID0gdGhpcy5hcHA7XG4gICAgY29uc3QgbW9kZSA9ICh0aGlzLmFwcC52YXVsdCBhcyBhbnkpLmdldENvbmZpZyhcImRlZmF1bHRWaWV3TW9kZVwiKTtcbiAgICBjb25zdCBsZWFmID0gd29ya3NwYWNlLmdldExlYWYoZmFsc2UpO1xuICAgIGF3YWl0IGxlYWYub3BlbkZpbGUodmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKG5ld0ZpbGVOYW1lKSBhcyBURmlsZSwgeyBhY3RpdmUgOiB0cnVlLH0pO1xuICB9XG5cbiAgYXN5bmMgY3JlYXRlT3JBcHBlbmRGaWxlKGZpbGVQYXRoOiBzdHJpbmcsIG5vdGU6IHN0cmluZykge1xuXHRcdC8vSWYgZmlsZXMgZXhpc3RzIHRoZW4gYXBwZW5kIGNvbmVudCB0byBleGlzdGluZyBmaWxlXG5cdFx0Y29uc3QgeyB2YXVsdCB9ID0gdGhpcy5hcHA7XG5cdFx0Y29uc3QgZmlsZUV4aXN0cyA9IGF3YWl0IHZhdWx0LmFkYXB0ZXIuZXhpc3RzKGZpbGVQYXRoKTtcblx0XHRpZihmaWxlRXhpc3RzKXtcblx0XHRcdGF3YWl0IHRoaXMuYXBwZW5kRmlsZSh2YXVsdCwgZmlsZVBhdGgsIG5vdGUpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRhd2FpdCB2YXVsdC5jcmVhdGUoZmlsZVBhdGgsIFwiLS0tXFxudGFnOiBiL24vc1xcbi0tLVxcblxcblwiICsgbm90ZSk7XG5cdFx0fVxuXHRcdHJldHVybiBmaWxlUGF0aDtcblx0fVxuXG4gICAgYXN5bmMgYXBwZW5kRmlsZSh2YXVsdDogVmF1bHQsIGZpbGVQYXRoOiBzdHJpbmcsIG5vdGU6IHN0cmluZykge1xuXHRcdGxldCBleGlzdGluZ0NvbnRlbnQgPSBhd2FpdCB2YXVsdC5hZGFwdGVyLnJlYWQoZmlsZVBhdGgpO1xuXHRcdGlmKGV4aXN0aW5nQ29udGVudC5sZW5ndGggPiAwKSB7XG5cdFx0ICBleGlzdGluZ0NvbnRlbnQgPSBleGlzdGluZ0NvbnRlbnQgKyAnXFxyXFxyJztcblx0XHR9XG5cdFx0YXdhaXQgdmF1bHQuYWRhcHRlci53cml0ZShmaWxlUGF0aCwgZXhpc3RpbmdDb250ZW50ICsgbm90ZSk7XG5cdCAgfVxufSIsICJpbXBvcnQgeyBBcHAsIEVkaXRvciwgRnV6enlTdWdnZXN0TW9kYWwsIEZ1enp5TWF0Y2ggfSBmcm9tIFwib2JzaWRpYW5cIjtcblxuZXhwb3J0IGNsYXNzIENsaXBib2FyZFBhc3RlTW9kYWwgZXh0ZW5kcyBGdXp6eVN1Z2dlc3RNb2RhbDxzdHJpbmc+IHtcblxuICBlZGl0b3I6IEVkaXRvclxuXG4gIGNsaXBib2FyZENvbnRlbnQ6IHN0cmluZ1tdXG5cbiAga2V5ZG93bkhhbmRsZXI6IChldmVudDogS2V5Ym9hcmRFdmVudCkgPT4gdm9pZDtcblxuICBjb25zdHJ1Y3RvcihhcHA6IEFwcCwgZWRpdG9yOiBFZGl0b3IsIGNsaXBib2FyZENvbnRlbnQ6IHN0cmluZ1tdKVxuICB7XG4gICAgc3VwZXIoYXBwKVxuICAgIHRoaXMuZWRpdG9yID0gZWRpdG9yXG4gICAgdGhpcy5jbGlwYm9hcmRDb250ZW50ID0gY2xpcGJvYXJkQ29udGVudFxuICAgIHRoaXMuc2V0UGxhY2Vob2xkZXIoYFdoaWNoIGNsaXBib2FyZCBjb250ZW50IGRvIHlvdSB3YW50IHRvIHBhc3RlP2ApXG4gICAgdGhpcy5rZXlkb3duSGFuZGxlciA9IChldmVudDogS2V5Ym9hcmRFdmVudCkgPT4ge1xuICAgICAgaWYgKGV2ZW50Lm1ldGFLZXkgJiYgZXZlbnQuc2hpZnRLZXkgJiYgZXZlbnQua2V5ID09PSAnVicpIHsgLy8gbWFjb3NcbiAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgfSBlbHNlIGlmIChldmVudC5tZXRhS2V5IHx8IGV2ZW50LmN0cmxLZXkpIHtcbiAgICAgICAgY29uc3Qga2V5ID0gcGFyc2VJbnQoZXZlbnQua2V5LCAxMCk7XG4gICAgICAgIGlmIChrZXkgPj0gMSAmJiBrZXkgPD0gOSkge1xuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7IC8vIFByZXZlbnQgZGVmYXVsdCBhY3Rpb25cbiAgICAgICAgICB0aGlzLnNlbGVjdEVsZW1lbnQoa2V5IC0gMSk7IC8vIFNlbGVjdCB0aGUgZWxlbWVudCAoaW5kZXgga2V5IC0gMSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBMaXN0ZW4gZm9yIGtleWRvd24gZXZlbnRzIGF0IHRoZSBkb2N1bWVudCBsZXZlbFxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLmtleWRvd25IYW5kbGVyKTtcbiAgfVxuXG4gIG9uQ2xvc2UoKSB7XG4gICAgc3VwZXIub25DbG9zZSgpO1xuICAgIC8vIFN0b3AgbGlzdGVuaW5nIGZvciBrZXlkb3duIGV2ZW50cyB3aGVuIHRoZSBtb2RhbCBpcyBjbG9zZWRcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5rZXlkb3duSGFuZGxlcik7XG4gIH1cblxuICBzZWxlY3RFbGVtZW50KGluZGV4OiBudW1iZXIpIHtcbiAgICBjb25zdCBlbGVtZW50cyA9IHRoaXMucmVzdWx0Q29udGFpbmVyRWwucXVlcnlTZWxlY3RvckFsbCgnLnN1Z2dlc3Rpb24taXRlbScpO1xuICAgIGlmIChlbGVtZW50cy5sZW5ndGggPiBpbmRleCkge1xuICAgICAgY29uc3QgZWxlbWVudCA9IGVsZW1lbnRzW2luZGV4XSBhcyBIVE1MRWxlbWVudDtcbiAgICAgIGVsZW1lbnQuY2xpY2soKTsgLy8gU2ltdWxhdGUgYSBjbGljayB0byBzZWxlY3QgdGhlIGVsZW1lbnRcbiAgICB9XG4gIH1cblxuICBnZXRJdGVtcygpOiBzdHJpbmdbXSB7XG4gICAgcmV0dXJuIHRoaXMuY2xpcGJvYXJkQ29udGVudC5zbGljZSgpLnJldmVyc2UoKTtcbiAgfVxuXG4gIGdldEl0ZW1UZXh0KGl0ZW06IHN0cmluZyk6IHN0cmluZyB7XG4gICAgcmV0dXJuIGl0ZW07XG4gIH1cblxuICAvLyBSZW5kZXJzIGVhY2ggc3VnZ2VzdGlvbiBpdGVtLlxuICByZW5kZXJTdWdnZXN0aW9uKGk6IEZ1enp5TWF0Y2g8c3RyaW5nPiwgZWw6IEhUTUxFbGVtZW50KSB7XG4gICAgY29uc3QgaXRlbSA9IGkuaXRlbVxuICAgIC8vZWwuY3JlYXRlRWwoXCJkaXZcIiwgeyB0ZXh0OiBpdGVtIH0pO1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5yZXN1bHRDb250YWluZXJFbC5xdWVyeVNlbGVjdG9yQWxsKCcuc3VnZ2VzdGlvbi1pdGVtJykubGVuZ3RoO1xuICAgIGNvbnN0IGl0ZW1JbmRleCA9IGluZGV4IDwgMTAgPyBpbmRleCArIFwiLiBcIiA6IFwiICAgIFwiXG4gICAgZWwuY3JlYXRlRWwoXCJkaXZcIiwgeyB0ZXh0OiBpdGVtSW5kZXggKyBpdGVtLnJlcGxhY2UoL1xcbi9nbSwgXCJcIikuc3Vic3RyaW5nKDAsIDEwMCkgfSk7XG4gIH1cblxuICAvLyBQZXJmb3JtIGFjdGlvbiBvbiB0aGUgc2VsZWN0ZWQgc3VnZ2VzdGlvbi5cbiAgb25DaG9vc2VJdGVtKHNlbGVjdGVkQ29udGVudDogc3RyaW5nLCBldnQ6IE1vdXNlRXZlbnQgfCBLZXlib2FyZEV2ZW50KSB7XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLmNsaXBib2FyZENvbnRlbnQuaW5kZXhPZihzZWxlY3RlZENvbnRlbnQsIDApO1xuICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICB0aGlzLmNsaXBib2FyZENvbnRlbnQucmVtb3ZlKHNlbGVjdGVkQ29udGVudCk7XG4gICAgfVxuICAgIHRoaXMuY2xpcGJvYXJkQ29udGVudC5wdXNoKHNlbGVjdGVkQ29udGVudCk7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gdGhpcy5lZGl0b3IuZ2V0U2VsZWN0aW9uKClcbiAgICBjb25zdCByZXBsYWNlZFN0ciA9IHNlbGVjdGVkQ29udGVudFxuICAgIGlmIChzZWxlY3Rpb24ubGVuZ3RoICE9IDApIHtcbiAgICAgICAgdGhpcy5lZGl0b3IucmVwbGFjZVNlbGVjdGlvbihyZXBsYWNlZFN0cik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgY3Vyc29yID0gdGhpcy5lZGl0b3IuZ2V0Q3Vyc29yKCk7XG4gICAgICAgIHRoaXMuZWRpdG9yLnJlcGxhY2VSYW5nZShyZXBsYWNlZFN0ciwgY3Vyc29yKTtcbiAgICAgICAgY3Vyc29yLmNoID0gY3Vyc29yLmNoICsgcmVwbGFjZWRTdHIubGVuZ3RoO1xuICAgICAgICB0aGlzLmVkaXRvci5zZXRDdXJzb3IoY3Vyc29yKTtcbiAgICB9XG4gIH1cbn0iLCAiaW1wb3J0IHsgQXBwLCBFZGl0b3IsIEZ1enp5U3VnZ2VzdE1vZGFsLCBGdXp6eU1hdGNoLCBURmlsZSB9IGZyb20gXCJvYnNpZGlhblwiO1xuXG5leHBvcnQgY2xhc3MgT3BlblBsYXlncm91bmRNb2RhbCBleHRlbmRzIEZ1enp5U3VnZ2VzdE1vZGFsPHN0cmluZz4ge1xuXG4gIHJlbW92ZUV4aXN0aW5nQ29udGVudCA6IHN0cmluZyA9IFwiUmVtb3ZlIHBsYXlncm91bmQgY29udGVudFwiXG4gIG5vdFJlbW92ZUV4aXN0aW5nQ29udGVudDogc3RyaW5nID0gXCJOb3QgcmVtb3ZlIGV4aXN0aW5nIHBsYXlncm91bmQgY29udGVudFwiXG4gIHBsYXlncm91bmRNZDogc3RyaW5nID0gXCJJL1BsYXlncm91bmQubWRcIlxuICBvcHRpb25zOiBzdHJpbmdbXSA9IFt0aGlzLnJlbW92ZUV4aXN0aW5nQ29udGVudCwgdGhpcy5ub3RSZW1vdmVFeGlzdGluZ0NvbnRlbnRdXG5cbiAgY29uc3RydWN0b3IoYXBwOiBBcHApXG4gIHtcbiAgICBzdXBlcihhcHApXG4gIH1cblxuICBnZXRJdGVtcygpOiBzdHJpbmdbXSB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy5yZXZlcnNlKCk7XG4gIH1cblxuICBnZXRJdGVtVGV4dChpdGVtOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIHJldHVybiBpdGVtO1xuICB9XG5cbiAgLy8gUmVuZGVycyBlYWNoIHN1Z2dlc3Rpb24gaXRlbS5cbiAgcmVuZGVyU3VnZ2VzdGlvbihpOiBGdXp6eU1hdGNoPHN0cmluZz4sIGVsOiBIVE1MRWxlbWVudCkge1xuICAgIGNvbnN0IGl0ZW0gPSBpLml0ZW1cbiAgICBlbC5jcmVhdGVFbChcImRpdlwiLCB7IHRleHQ6IGl0ZW0gfSk7XG4gIH1cblxuICAvLyBQZXJmb3JtIGFjdGlvbiBvbiB0aGUgc2VsZWN0ZWQgc3VnZ2VzdGlvbi5cbiAgYXN5bmMgb25DaG9vc2VJdGVtKHNlbGVjdGVkQ29udGVudDogc3RyaW5nLCBldnQ6IE1vdXNlRXZlbnQgfCBLZXlib2FyZEV2ZW50KSB7XG4gICAgY29uc3QgY2hvb3Nlbk9wdGlvbiA9IHNlbGVjdGVkQ29udGVudFxuXG4gICAgY29uc3QgeyB2YXVsdCB9ID0gdGhpcy5hcHA7XG4gICAgY29uc3QgeyB3b3Jrc3BhY2UgfSA9IHRoaXMuYXBwO1xuICAgIGNvbnN0IGxlYWYgPSB3b3Jrc3BhY2UuZ2V0TGVhZihmYWxzZSk7XG5cbiAgICBQcm9taXNlLnJlc29sdmUoKVxuICAgIC50aGVuKCgpID0+IHtcbiAgICAgIGlmICh2YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgodGhpcy5wbGF5Z3JvdW5kTWQpID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHZhdWx0LmNyZWF0ZSh0aGlzLnBsYXlncm91bmRNZCwgXCJcIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKHRoaXMucGxheWdyb3VuZE1kKVxuICAgIH0pXG4gICAgLnRoZW4oKHRGaWxlKSA9PiB7XG4gICAgICBpZiAodGhpcy5yZW1vdmVFeGlzdGluZ0NvbnRlbnQgPT09IGNob29zZW5PcHRpb24pIHtcbiAgICAgICAgcmV0dXJuIHZhdWx0Lm1vZGlmeSh0RmlsZSBhcyBURmlsZSwgXCJcIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKClcbiAgICB9KVxuICAgIC50aGVuKCgpID0+IHtcbiAgICAgIHJldHVybiBsZWFmLm9wZW5GaWxlKHZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aCh0aGlzLnBsYXlncm91bmRNZCkgYXMgVEZpbGUsIHsgYWN0aXZlIDogdHJ1ZX0pO1xuICAgIH0pXG4gIH1cbn0iLCAiaW1wb3J0IHsgQXBwLCBFZGl0b3IsIEZ1enp5U3VnZ2VzdE1vZGFsLCBGdXp6eU1hdGNoLCBURmlsZSwgTm90aWNlLCBNYXJrZG93blZpZXcgfSBmcm9tIFwib2JzaWRpYW5cIjtcblxuZXhwb3J0IGNsYXNzIFRocmVhZHNUb0Jsb2dNb2RhbCBleHRlbmRzIEZ1enp5U3VnZ2VzdE1vZGFsPHN0cmluZz4ge1xuXG4gIHRvTmV3Tm90ZSA6IHN0cmluZyA9IFwiVG8gTmV3IE5vdGVcIlxuICB0b0NsaXBib2FyZDogc3RyaW5nID0gXCJUbyBDbGlwYm9hcmRcIlxuICBvcHRpb25zOiBzdHJpbmdbXSA9IFt0aGlzLnRvTmV3Tm90ZSwgdGhpcy50b0NsaXBib2FyZF1cbiAgZWRpdG9yOiBFZGl0b3JcbiAgdmlldzogTWFya2Rvd25WaWV3XG5cbiAgY29uc3RydWN0b3IoYXBwOiBBcHAsIGVkaXRvcjogRWRpdG9yLCB2aWV3OiBNYXJrZG93blZpZXcpXG4gIHtcbiAgICBzdXBlcihhcHApXG4gICAgdGhpcy5lZGl0b3IgPSBlZGl0b3JcbiAgICB0aGlzLnZpZXcgPSB2aWV3XG4gICAgdGhpcy5zZXRQbGFjZWhvbGRlcihgUHV0dGluZyBUaHJlYWRzIGNvbnRlbnQgdG8gQmxvZyBub3Rlcy4gV2hpY2ggb3B0aW9uIGRvIHlvdSB3YW50IHRvIHByb2NlZWQ/YClcbiAgfVxuXG4gIGdldEl0ZW1zKCk6IHN0cmluZ1tdIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zO1xuICB9XG5cbiAgZ2V0SXRlbVRleHQoaXRlbTogc3RyaW5nKTogc3RyaW5nIHtcbiAgICByZXR1cm4gaXRlbTtcbiAgfVxuXG4gIC8vIFJlbmRlcnMgZWFjaCBzdWdnZXN0aW9uIGl0ZW0uXG4gIHJlbmRlclN1Z2dlc3Rpb24oaTogRnV6enlNYXRjaDxzdHJpbmc+LCBlbDogSFRNTEVsZW1lbnQpIHtcbiAgICBjb25zdCBpdGVtID0gaS5pdGVtXG4gICAgZWwuY3JlYXRlRWwoXCJkaXZcIiwgeyB0ZXh0OiBpdGVtIH0pO1xuICB9XG5cbiAgLy8gUGVyZm9ybSBhY3Rpb24gb24gdGhlIHNlbGVjdGVkIHN1Z2dlc3Rpb24uXG4gIG9uQ2hvb3NlSXRlbShzZWxlY3RlZENvbnRlbnQ6IHN0cmluZywgZXZ0OiBNb3VzZUV2ZW50IHwgS2V5Ym9hcmRFdmVudCkge1xuICAgIGNvbnN0IGNob29zZW5PcHRpb24gPSBzZWxlY3RlZENvbnRlbnRcblxuICAgIGNvbnN0IGxpbmVDb3VudCA9IHRoaXMuZWRpdG9yLmxpbmVDb3VudCgpO1xuICAgIGxldCB0YWdMaW5lTnVtYmVyID0gbnVsbDtcbiAgICBsZXQgbWV0YWRhdGFMaW5lQ291bnQgPSAwO1xuICAgIGxldCB0ZXh0ID0gXCJcIlxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZUNvdW50OyBpKyspIHtcbiAgICAgIGxldCBsaW5lID0gdGhpcy5lZGl0b3IuZ2V0TGluZShpKTtcbiAgICAgIGlmICghbGluZS50cmltKCkuc3RhcnRzV2l0aChcIiUlXCIpIHx8ICFsaW5lLnRyaW0oKS5lbmRzV2l0aChcIiUlXCIpKSB7XG4gICAgICAgIGxldCBtb2RpZmllZExpbmUgPSBsaW5lLnJlcGxhY2UoJ1x1RDgzRVx1RERGNSAnLCAnIyAnKS5yZXBsYWNlKCdcdTMwMTAnLCAnJykucmVwbGFjZSgnXHUzMDExJywgJycpLnJlcGxhY2UoJ1x1RDgzRFx1REM0NycsICcnKVxuICAgICAgICBpZiAobW9kaWZpZWRMaW5lID09ICctLS0nKSB7XG4gICAgICAgICAgbWV0YWRhdGFMaW5lQ291bnQrK1xuICAgICAgICAgIGlmIChtZXRhZGF0YUxpbmVDb3VudCA+IDIpIHtcbiAgICAgICAgICAgIGlmIChtZXRhZGF0YUxpbmVDb3VudCA9PSAzKSB7XG4gICAgICAgICAgICAgIG1vZGlmaWVkTGluZSA9IG1vZGlmaWVkTGluZS5yZXBsYWNlKCctLS0nLCAnJylcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobWV0YWRhdGFMaW5lQ291bnQgPT0gNCkge1xuICAgICAgICAgICAgICBtb2RpZmllZExpbmUgPSBtb2RpZmllZExpbmUucmVwbGFjZSgnLS0tJywgJzwhLS1tb3JlLS0+XFxuXFxuKipcdTc2RUVcdTkzMDRcdUZGMUEqKlxcblxcbiogVGFibGUgb2YgQ29udGVudFxcbns6dG9jfVxcblxcbiMjIC4nKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbW9kaWZpZWRMaW5lID0gbW9kaWZpZWRMaW5lLnJlcGxhY2UoJy0tLScsICcjIyAuJylcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobWV0YWRhdGFMaW5lQ291bnQgPT0gMSB8fCBtZXRhZGF0YUxpbmVDb3VudCA9PSAyKSB7XG4gICAgICAgICAgbW9kaWZpZWRMaW5lID0gbW9kaWZpZWRMaW5lLnJlcGxhY2UoXCJjL3QvcFwiLCBcImMvYi9kXCIpXG4gICAgICAgICAgbW9kaWZpZWRMaW5lID0gbW9kaWZpZWRMaW5lLnJlcGxhY2UoXCJjL3QvdFwiLCBcImMvYi9kXCIpXG4gICAgICAgICAgbW9kaWZpZWRMaW5lID0gbW9kaWZpZWRMaW5lLnJlcGxhY2UoXCJjL3QvclwiLCBcImMvYi9kXCIpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoL14hXFxbLipcXF1cXCguKlxcKS8udGVzdChtb2RpZmllZExpbmUudHJpbSgpKSkge1xuICAgICAgICAgIGlmICghbW9kaWZpZWRMaW5lLmNvbnRhaW5zKFwiaHR0cHM6Ly9yb3VsZXNvcGh5LmdpdGh1Yi5pb1wiKSkge1xuICAgICAgICAgICAgbW9kaWZpZWRMaW5lID0gbW9kaWZpZWRMaW5lLnJlcGxhY2UoLyFcXFsoW15cXFtcXF1cXChcXCldKylcXF1cXCgoW15cXFtcXF1cXChcXCldKylcXCkvZywgXCIkMlwiKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0ZXh0ID0gdGV4dCArIG1vZGlmaWVkTGluZSArIFwiXFxuXCI7XG4gICAgICB9XG4gICAgfVxuICAgIHRleHQgPSB0ZXh0LnJlcGxhY2UoLyMjIC5cXG4rIyMgW1JyXWVmZXJlbmNlcz9bXFw6XT8oW1xcbl0qLiopKiQvLCBcIlwiKTtcblxuICAgIHRleHQgKz0gYFxcblxcbi0tLVxcblxcbiNubCBnZW5lcmF0ZSBzdW1tYXJ5IGZvciBtZXRhIGRlc2NyaXB0aW9uIGJlbG93OlxcblxcblxcblxcbmBcbiAgICB0ZXh0ICs9IGAtLS1cXG5cXG4jIyBSZWZlcmVuY2VzOlxcblxcbi0gVGhyZWFkIHBvc3QgMTogW1ske3RoaXMudmlldy5maWxlLmJhc2VuYW1lfV1dXFxuLSBCbG9nIGxpbms6IFxcbmBcblxuICAgIGNvbnN0IHsgdmF1bHQgfSA9IHRoaXMuYXBwO1xuXG4gICAgaWYgKHRoaXMudG9OZXdOb3RlID09PSBjaG9vc2VuT3B0aW9uKSB7XG4gICAgICBjb25zdCB7IHZhdWx0IH0gPSB0aGlzLmFwcDtcbiAgICAgIGNvbnN0IHBhdGggPSB0aGlzLnZpZXcuZmlsZS5wYXRoXG4gICAgICBjb25zdCBuZXdQYXRoID0gcGF0aC5tYXRjaCgvLlxcL1RocmVhZHMgXFxkXFxkXFxkXFxkXFxkXFxkXFxkXFxkLylcbiAgICAgICAgICAgICAgICAgICAgICA/IHBhdGgucmVwbGFjZSgvKC5cXC8pVGhyZWFkcyBcXGRcXGRcXGRcXGRcXGRcXGRcXGRcXGQvLCBcIiQxQmxvZyBcIilcbiAgICAgICAgICAgICAgICAgICAgICA6IHBhdGgucmVwbGFjZSgvKC5cXC8pLywgXCIkMUJsb2cgXCIpXG5cbiAgICAgIGNvbnN0IHsgd29ya3NwYWNlIH0gPSB0aGlzLmFwcDtcbiAgICAgIGNvbnN0IGxlYWYgPSB3b3Jrc3BhY2UuZ2V0TGVhZihmYWxzZSk7XG4gICAgICBQcm9taXNlLnJlc29sdmUoKVxuICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICByZXR1cm4gdmF1bHQuYWRhcHRlci5leGlzdHMobmV3UGF0aCk7XG4gICAgICB9KVxuICAgICAgLnRoZW4oKGZpbGVFeGlzdHMpID0+IHtcbiAgICAgICAgaWYgKGZpbGVFeGlzdHMpIHtcbiAgICAgICAgICBuZXcgTm90aWNlKGBXaWxsIG5vdCBwcm9jZWVkLiBCbG9nIHBvc3QgXCIke25ld1BhdGh9XCIgYWxyZWFkeSBleGlzdC5gKTtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoXCJCbG9nIHBvc3QgZXhpc3RcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhdWx0LmNyZWF0ZShuZXdQYXRoLCB0ZXh0KTtcbiAgICAgIH0pXG4gICAgICAudGhlbigodEZpbGUpID0+IHtcbiAgICAgICAgcmV0dXJuIGxlYWYub3BlbkZpbGUodEZpbGUsIHsgYWN0aXZlIDogdHJ1ZX0pO1xuICAgICAgfSxcbiAgICAgIChyZWplY3RSZWFzb24pID0+IHt9KVxuICAgIH1cbiAgICBpZiAodGhpcy50b0NsaXBib2FyZCA9PT0gY2hvb3Nlbk9wdGlvbikge1xuICAgICAgbmF2aWdhdG9yLmNsaXBib2FyZC53cml0ZVRleHQodGV4dCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIG5ldyBOb3RpY2UoYENvcGllZCBibG9nIGNvbnRlbnQgdG8gY2xpcGJvYXJkIWApO1xuICAgICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgIG5ldyBOb3RpY2UoYGVycm9yIHdoZW4gY29weSB0byBjbGlwYm9hcmQhYCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn0iLCAiaW1wb3J0IHsgQXBwLCBFZGl0b3IsIEZ1enp5U3VnZ2VzdE1vZGFsLCBGdXp6eU1hdGNoLCBOb3RpY2UgfSBmcm9tIFwib2JzaWRpYW5cIjtcblxuZXhwb3J0IGNsYXNzIENsaXBib2FyZFJlbW92YWxNb2RhbCBleHRlbmRzIEZ1enp5U3VnZ2VzdE1vZGFsPHN0cmluZz4ge1xuXG4gIGVkaXRvcjogRWRpdG9yXG5cbiAgY2xpcGJvYXJkQ29udGVudDogc3RyaW5nW11cblxuICBSRU1PVkVfQUxMIDogc3RyaW5nID0gXCJSRU1PVkUgQUxMXCJcblxuICBjb25zdHJ1Y3RvcihhcHA6IEFwcCwgZWRpdG9yOiBFZGl0b3IsIGNsaXBib2FyZENvbnRlbnQ6IHN0cmluZ1tdKVxuICB7XG4gICAgc3VwZXIoYXBwKVxuICAgIHRoaXMuZWRpdG9yID0gZWRpdG9yXG4gICAgdGhpcy5jbGlwYm9hcmRDb250ZW50ID0gY2xpcGJvYXJkQ29udGVudFxuICAgIHRoaXMuc2V0UGxhY2Vob2xkZXIoYFdoaWNoIGNsaXBib2FyZCBjb250ZW50IGRvIHlvdSB3YW50IHRvIHJlbW92ZT9gKVxuICB9XG5cbiAgZ2V0SXRlbXMoKTogc3RyaW5nW10ge1xuICAgIHJldHVybiBbLi4uW3RoaXMuUkVNT1ZFX0FMTF0sIC4uLnRoaXMuY2xpcGJvYXJkQ29udGVudC5zbGljZSgpLnJldmVyc2UoKV07XG4gIH1cblxuICBnZXRJdGVtVGV4dChpdGVtOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIHJldHVybiBpdGVtO1xuICB9XG5cbiAgLy8gUmVuZGVycyBlYWNoIHN1Z2dlc3Rpb24gaXRlbS5cbiAgcmVuZGVyU3VnZ2VzdGlvbihpOiBGdXp6eU1hdGNoPHN0cmluZz4sIGVsOiBIVE1MRWxlbWVudCkge1xuICAgIGNvbnN0IGl0ZW0gPSBpLml0ZW1cbiAgICAvL2VsLmNyZWF0ZUVsKFwiZGl2XCIsIHsgdGV4dDogaXRlbSB9KTtcbiAgICBlbC5jcmVhdGVFbChcImRpdlwiLCB7IHRleHQ6IFwiXHUyMDIyIFwiICsgaXRlbS5yZXBsYWNlKC9cXG4vZ20sIFwiXCIpLnN1YnN0cmluZygwLCAxMDApIH0pO1xuICB9XG5cbiAgLy8gUGVyZm9ybSBhY3Rpb24gb24gdGhlIHNlbGVjdGVkIHN1Z2dlc3Rpb24uXG4gIG9uQ2hvb3NlSXRlbShzZWxlY3RlZENvbnRlbnQ6IHN0cmluZywgZXZ0OiBNb3VzZUV2ZW50IHwgS2V5Ym9hcmRFdmVudCkge1xuICAgIGlmIChzZWxlY3RlZENvbnRlbnQgPT09IHRoaXMuUkVNT1ZFX0FMTCkge1xuICAgICAgbmV3IE5vdGljZShcImhhaGFcIilcbiAgICAgIHdoaWxlKHRoaXMuY2xpcGJvYXJkQ29udGVudC5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRoaXMuY2xpcGJvYXJkQ29udGVudC5wb3AoKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgaW5kZXggPSB0aGlzLmNsaXBib2FyZENvbnRlbnQuaW5kZXhPZihzZWxlY3RlZENvbnRlbnQsIDApO1xuICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgdGhpcy5jbGlwYm9hcmRDb250ZW50LnNwbGljZShpbmRleCwgMSk7XG4gICAgICB9ICBcbiAgICB9XG4gIH1cbn0iLCAiaW1wb3J0IE15UGx1Z2luIGZyb20gXCJtYWluXCI7XG5pbXBvcnQgeyBOb3Rlc1R5cGVWaWV3IH0gZnJvbSBcIm5vdGVzVHlwZVZpZXdcIjtcbmltcG9ydCB7IEFwcCwgRnV6enlNYXRjaCwgRnV6enlTdWdnZXN0TW9kYWwgfSBmcm9tIFwib2JzaWRpYW5cIjtcbmltcG9ydCB7IGdldEFsbFRhZ3NXaXRoRmlsdGVyIH0gZnJvbSBcInNlbGZ1dGlsL2dldEFsbE5vdGVUYWdzXCI7XG5cbmludGVyZmFjZSBTZWFyY2gge1xuXHRvcGVuR2xvYmFsU2VhcmNoKF86IHN0cmluZyk6IHZvaWQ7XG5cdGdldEdsb2JhbFNlYXJjaFF1ZXJ5KCk6IHN0cmluZztcbn1cblxuZXhwb3J0IGNsYXNzIFRhZ1NlYXJjaE1vZGFsIGV4dGVuZHMgRnV6enlTdWdnZXN0TW9kYWw8c3RyaW5nPiB7XG5cblx0a2V5ZG93bkhhbmRsZXI6IChldmVudDogS2V5Ym9hcmRFdmVudCkgPT4gdm9pZDtcblx0XG5cdHBsdWdpbjogTXlQbHVnaW47XG5cblx0Y29uc3RydWN0b3IocHVibGljIGFwcDogQXBwLCBwcml2YXRlIHNlYXJjaDogU2VhcmNoLCBwbHVnaW46IE15UGx1Z2luKSB7XG5cdFx0c3VwZXIoYXBwKTtcblx0XHR0aGlzLnNlYXJjaCA9IHNlYXJjaDtcblx0XHR0aGlzLmtleWRvd25IYW5kbGVyID0gKGV2ZW50OiBLZXlib2FyZEV2ZW50KSA9PiB7XG5cdFx0XHRpZiAoZXZlbnQuY3RybEtleSAmJiBldmVudC5hbHRLZXkgJiYgZXZlbnQuc2hpZnRLZXkgJiYgZXZlbnQua2V5ID09PSAnUycpIHsgLy8gd2luZG93c1xuXHRcdFx0ICB0aGlzLmNsb3NlKCk7XG5cdFx0XHR9IGVsc2UgaWYgKGV2ZW50LmN0cmxLZXkgJiYgZXZlbnQubWV0YUtleSAmJiBldmVudC5zaGlmdEtleSAmJiBldmVudC5rZXkgPT09ICdTJykgeyAvLyBtYWNvc1xuXHRcdFx0ICB0aGlzLmNsb3NlKCk7XG5cdFx0XHR9IGVsc2UgaWYgKGV2ZW50Lm1ldGFLZXkgfHwgZXZlbnQuY3RybEtleSkge1xuXHRcdFx0ICBjb25zdCBrZXkgPSBwYXJzZUludChldmVudC5rZXksIDEwKTtcblx0XHRcdCAgaWYgKGtleSA+PSAxICYmIGtleSA8PSA5KSB7XG5cdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7IC8vIFByZXZlbnQgZGVmYXVsdCBhY3Rpb25cblx0XHRcdFx0dGhpcy5zZWxlY3RFbGVtZW50KGtleSAtIDEpOyAvLyBTZWxlY3QgdGhlIGVsZW1lbnQgKGluZGV4IGtleSAtIDEpXG5cdFx0XHQgIH1cblx0XHRcdH1cblx0XHQgIH07XG5cdCAgXG5cdFx0ICAvLyBMaXN0ZW4gZm9yIGtleWRvd24gZXZlbnRzIGF0IHRoZSBkb2N1bWVudCBsZXZlbFxuXHRcdCAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMua2V5ZG93bkhhbmRsZXIpO1xuXHRcdHRoaXMucGx1Z2luID0gcGx1Z2luO1xuXHRcdC8vY29uc29sZS5sb2coXCJwbHVnaW46IFwiICsgcGx1Z2luKVxuXHR9XG5cblx0c2VsZWN0RWxlbWVudChpbmRleDogbnVtYmVyKSB7XG5cdFx0Y29uc3QgZWxlbWVudHMgPSB0aGlzLnJlc3VsdENvbnRhaW5lckVsLnF1ZXJ5U2VsZWN0b3JBbGwoJy5zdWdnZXN0aW9uLWl0ZW0nKTtcblx0XHRpZiAoZWxlbWVudHMubGVuZ3RoID4gaW5kZXgpIHtcblx0XHQgIGNvbnN0IGVsZW1lbnQgPSBlbGVtZW50c1tpbmRleF0gYXMgSFRNTEVsZW1lbnQ7XG5cdFx0ICBlbGVtZW50LmNsaWNrKCk7IC8vIFNpbXVsYXRlIGEgY2xpY2sgdG8gc2VsZWN0IHRoZSBlbGVtZW50XG5cdFx0fVxuXHR9XG5cblx0Z2V0SXRlbXMoKTogc3RyaW5nW10ge1xuXHRcdHJldHVybiBnZXRBbGxUYWdzV2l0aEZpbHRlcih0aGlzLmFwcCk7XG5cdH1cblxuXHRnZXRJdGVtVGV4dChpdGVtOiBzdHJpbmcpOiBzdHJpbmcge1xuXHRcdHJldHVybiBpdGVtO1xuXHR9XG5cblx0YXN5bmMgb25DaG9vc2VJdGVtKGl0ZW06IHN0cmluZywgZXZ0OiBNb3VzZUV2ZW50IHwgS2V5Ym9hcmRFdmVudCk6IHZvaWQge1xuXHRcdC8vaWYgKC9eI1thLXpdJC8udGVzdChpdGVtKSB8fCAvXiNbYS16XVxcL1thLXpdJC8udGVzdChpdGVtKSB8fCAvXiNbYS16XVxcL1thLXpdXFwvW2Etel0kLy50ZXN0KGl0ZW0pKSB7XG5cdFx0XHQvLyBub3RlIHR5cGUgdGFnXG5cdFx0XHR0aGlzLnBsdWdpbi5ub3Rlc1R5cGVWaWV3Lm5vdGVzVHlwZVRhZyA9IGl0ZW07XG5cdFx0XHR0aGlzLnBsdWdpbi5hY3RpdmF0ZU5vdGVMaXN0VmlldygpXG5cdFx0XHR0aGlzLnBsdWdpbi5ub3Rlc1R5cGVWaWV3LnJlZHJhdygpO1xuXHRcdC8qfSBlbHNlIHtcblx0XHRcdC8vIGluIHRleHQgdGFnXG5cdFx0XHRjb25zdCBkZWZhdWx0VGFnU2VhcmNoU3RyaW5nID0gYHRhZzoke2l0ZW19YDtcblx0XHRcdHRoaXMuc2VhcmNoLm9wZW5HbG9iYWxTZWFyY2goZGVmYXVsdFRhZ1NlYXJjaFN0cmluZyk7XG5cdFx0fSovXG5cdH1cblxuXHRvbkNsb3NlKCkge1xuXHRcdHN1cGVyLm9uQ2xvc2UoKTtcblx0XHQvLyBTdG9wIGxpc3RlbmluZyBmb3Iga2V5ZG93biBldmVudHMgd2hlbiB0aGUgbW9kYWwgaXMgY2xvc2VkXG5cdFx0ZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMua2V5ZG93bkhhbmRsZXIpO1xuXHRcdC8vdGhpcy5zY29wZS51bnJlZ2lzdGVyKCk7IC8vIFVucmVnaXN0ZXIgdGhlIHNjb3BlIHdoZW4gdGhlIG1vZGFsIGlzIGNsb3NlZFxuXHR9XG5cblx0cmVuZGVyU3VnZ2VzdGlvbih0YWc6IEZ1enp5TWF0Y2g8c3RyaW5nPiwgZWw6IEhUTUxFbGVtZW50KSB7XG5cdFx0Y29uc3Qgbm90ZVR5cGUgPSB0YWcuaXRlbVxuXHRcdGNvbnN0IGluZGV4ID0gdGhpcy5yZXN1bHRDb250YWluZXJFbC5xdWVyeVNlbGVjdG9yQWxsKCcuc3VnZ2VzdGlvbi1pdGVtJykubGVuZ3RoO1xuXHRcdGNvbnN0IGl0ZW1JbmRleCA9IGluZGV4IDwgMTAgPyBpbmRleCArIFwiLiBcIiA6IFwiICAgIFwiXG5cdFx0ZWwuY3JlYXRlRWwoXCJkaXZcIiwgeyB0ZXh0OiBpdGVtSW5kZXggKyBub3RlVHlwZSB9KTtcblx0fVxuXG59IiwgImltcG9ydCB7IEFwcCwgZ2V0QWxsVGFncyB9IGZyb20gXCJvYnNpZGlhblwiO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0QWxsTm90ZVRhZ3MoYXBwOiBBcHApIHtcbiAgICByZXR1cm4gZ2V0QWxsVGFnc1dpdGhGaWx0ZXIoYXBwLCAodGFnKSA9PiAvXiNbYS16XVxcL1thLXpdXFwvW2Etel0kLy50ZXN0KHRhZykpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRBbGxUYWdzV2l0aEZpbHRlcihhcHA6IEFwcCwgZmlsdGVyPzogKHRhZzogc3RyaW5nKSA9PiBib29sZWFuIHwgbnVsbCkge1xuICAgIGNvbnN0IGZpbGVzID0gYXBwLnZhdWx0LmdldE1hcmtkb3duRmlsZXMoKTtcbiAgICBjb25zdCBpdGVtczogc3RyaW5nW10gPSBbXTtcbiAgICBmb3IgKGNvbnN0IGZpbGUgb2YgZmlsZXMpIHtcbiAgICAgICAgY29uc3QgY2FjaGUgPSBhcHAubWV0YWRhdGFDYWNoZS5nZXRDYWNoZShmaWxlLnBhdGgpO1xuICAgICAgICBpZiAoY2FjaGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGdldEFsbFRhZ3MoY2FjaGUpPy5mb3JFYWNoKCh0YWcpID0+IHtcbiAgICAgICAgICAgIGlmIChmaWx0ZXIgPT0gbnVsbCB8fCBmaWx0ZXIodGFnKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxheWVyT2ZUYWc6IHN0cmluZ1tdID0gZ2V0TGF5ZXJzT2ZUYWcodGFnKVxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgbGF5ZXIgb2YgbGF5ZXJPZlRhZykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWl0ZW1zLmluY2x1ZGVzKGxheWVyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbXMucHVzaChsYXllcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gaXRlbXMuc29ydCgoYTogc3RyaW5nLCBiOiBzdHJpbmcpID0+IGEubG9jYWxlQ29tcGFyZShiKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRBbGxUYXNrTWl4ZWRXaXRoQWN0aW9uVGFnc1dpdGhGaWx0ZXIoYXBwOiBBcHApIHtcbiAgICBjb25zdCBmaWxlcyA9IGFwcC52YXVsdC5nZXRNYXJrZG93bkZpbGVzKCk7XG4gICAgY29uc3QgdGFza1RhZ3M6IHN0cmluZ1tdID0gW107XG4gICAgY29uc3Qgbm9uVGFza1RhZ3M6IHN0cmluZ1tdID0gW107XG4gICAgY29uc3QgYWxsVGFnczogc3RyaW5nW10gPSBbXTtcbiAgICBmb3IgKGNvbnN0IGZpbGUgb2YgZmlsZXMpIHtcbiAgICAgICAgY29uc3QgY2FjaGUgPSBhcHAubWV0YWRhdGFDYWNoZS5nZXRDYWNoZShmaWxlLnBhdGgpO1xuICAgICAgICBpZiAoY2FjaGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGdldEFsbFRhZ3MoY2FjaGUpPy5mb3JFYWNoKCh0YWcpID0+IHtcbiAgICAgICAgICAgIGlmICgvXiNbYS16XVxcL1thLXpdXFwvW2Etel0kLy50ZXN0KHRhZykpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsYXllck9mVGFnOiBzdHJpbmdbXSA9IGdldExheWVyc09mVGFnKHRhZylcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGxheWVyIG9mIGxheWVyT2ZUYWcpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0YXNrVGFncy5pbmNsdWRlcyhsYXllcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhc2tUYWdzLnB1c2gobGF5ZXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoIW5vblRhc2tUYWdzLmluY2x1ZGVzKHRhZykpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9uVGFza1RhZ3MucHVzaCh0YWcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IHRhc2tUYWdzU29ydGVkID0gdGFza1RhZ3Muc29ydCgoYTogc3RyaW5nLCBiOiBzdHJpbmcpID0+IGEubG9jYWxlQ29tcGFyZShiKSk7XG4gICAgY29uc3Qgbm9uVGFza1RhZ3NTb3J0ZWQgPSBub25UYXNrVGFncy5zb3J0KChhOiBzdHJpbmcsIGI6IHN0cmluZykgPT4gYS5sb2NhbGVDb21wYXJlKGIpKTtcbiAgICBhbGxUYWdzLnB1c2goLi4ubm9uVGFza1RhZ3NTb3J0ZWQsIC4uLnRhc2tUYWdzU29ydGVkKVxuICAgIGZvciAoY29uc3QgdGFnIG9mIHRhc2tUYWdzU29ydGVkKSB7XG4gICAgICAgIGZvciAoY29uc3Qgbm9uVGFza1RhZyBvZiBub25UYXNrVGFnc1NvcnRlZCkge1xuICAgICAgICAgICAgYWxsVGFncy5wdXNoKHRhZyArIFwiIFwiICsgbm9uVGFza1RhZylcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYWxsVGFncztcbn1cblxuZnVuY3Rpb24gZ2V0TGF5ZXJzT2ZUYWcodGFnOiBzdHJpbmcpOiBzdHJpbmdbXSB7XG4gICAgLy8gcHJvdmlkZSBhIHRhZyB3aXRoICN6enovYmJiL2NjYywgcmV0dXJuIFsjenp6LCAjenp6L2JiYiwgI3p6ei9iYmIvY2NjXVxuICAgIC8vIGlmIHRhZyB3aXRob3V0IC8gKGUuZy4gI3p6eiksIHJldHVybiBbI3p6el1cbiAgICBjb25zdCBsYXllcnM6IHN0cmluZ1tdID0gW11cbiAgICBjb25zdCB0YWdTcGxpdCA9IHRhZy5zcGxpdChcIi9cIilcbiAgICBsZXQgdGFnTGF5ZXIgPSB0YWdTcGxpdFswXVxuICAgIGxheWVycy5wdXNoKHRhZ0xheWVyKVxuICAgIGZvciAoY29uc3QgdGFnUGFydCBvZiB0YWdTcGxpdC5zbGljZSgxLCB0YWdTcGxpdC5sZW5ndGgpKSB7XG4gICAgICAgIHRhZ0xheWVyICs9IFwiL1wiICsgdGFnUGFydFxuICAgICAgICBsYXllcnMucHVzaCh0YWdMYXllcilcbiAgICB9XG4gICAgcmV0dXJuIGxheWVyc1xufSIsICJpbXBvcnQgeyBBZGRUZXh0VG9Ob3Rlc01vZGFsIH0gZnJvbSBcImFkZFRleHRUb05vdGVzTW9kYWxcIlxuaW1wb3J0IHsgQXBwLCBGdXp6eVN1Z2dlc3RNb2RhbCwgRnV6enlNYXRjaCB9IGZyb20gXCJvYnNpZGlhblwiXG5pbXBvcnQgeyBhZGRUZXh0VG9Ob3RlcyB9IGZyb20gXCJzZWxmdXRpbC9hZGRsaW5rdG9ub3Rlc1wiXG5pbXBvcnQgeyBmaWxlc0hlYWRlcnNXaGVyZVRhZ0lzVXNlZCwgZmlsZXNXaGVyZVRhZ0lzVXNlZCB9IGZyb20gXCJzZWxmdXRpbC9maW5kTm90ZXNGcm9tVGFnXCJcbmltcG9ydCB7IGdldE5vdGVUeXBlIH0gZnJvbSBcInNlbGZ1dGlsL2dldFRhc2tUYWdcIlxuaW1wb3J0IHsgTm90ZVdpdGhIZWFkZXIsIFNFUEFSQVRPUiB9IGZyb20gXCJzZWxmdXRpbC9ub3RlV2l0aEhlYWRlclwiXG5cbmNvbnN0IEJBQ0tfVE9fU0VMRUNUX1RBRyA9IFwiQmFjayB0byBzZWxlY3QgdGFnXCJcblxuZXhwb3J0IGNsYXNzIEFkZFRleHRUb05vdGVzRnJvbVNwZWNpZmljVGFnTW9kYWwgZXh0ZW5kcyBGdXp6eVN1Z2dlc3RNb2RhbDxOb3RlV2l0aEhlYWRlcj4ge1xuXG4gIGxpbmtUb0FkZDogc3RyaW5nXG5cbiAgdGFnVG9GaW5kOiBzdHJpbmdcblxuICBkZXNjcmlwdGlvbjogc3RyaW5nXG5cbiAgaW5zZXJ0RnJvbUJlZ2lubmluZzogYm9vbGVhblxuXG4gIHBvc3RBY3Rpb246ICgpID0+IHZvaWRcblxuICBrZXlkb3duSGFuZGxlcjogKGV2ZW50OiBLZXlib2FyZEV2ZW50KSA9PiB2b2lkO1xuXG4gIGNvbnN0cnVjdG9yKGFwcDogQXBwLCBsaW5rVG9BZGQ6IHN0cmluZywgdGFnVG9GaW5kOiBzdHJpbmcsIGRlc2NyaXB0aW9uOiBzdHJpbmcsIGluc2VydEZyb21CZWdpbm5pbmc6IGJvb2xlYW4sIHBvc3RBY3Rpb246ICgpID0+IHZvaWQpXG4gIHtcbiAgICBzdXBlcihhcHApXG4gICAgdGhpcy5saW5rVG9BZGQgPSBsaW5rVG9BZGRcbiAgICB0aGlzLnRhZ1RvRmluZCA9IHRhZ1RvRmluZFxuICAgIHRoaXMuaW5zZXJ0RnJvbUJlZ2lubmluZyA9IGluc2VydEZyb21CZWdpbm5pbmdcbiAgICB0aGlzLmRlc2NyaXB0aW9uID0gZGVzY3JpcHRpb25cbiAgICB0aGlzLnBvc3RBY3Rpb24gPSBwb3N0QWN0aW9uXG4gICAgdGhpcy5zZXRQbGFjZWhvbGRlcihgV2hpY2ggbm90ZXMgd2l0aCB0YWcgJHt0YWdUb0ZpbmR9IGRvIHlvdSB3YW50IHRvICR7ZGVzY3JpcHRpb259IHRvICR7aW5zZXJ0RnJvbUJlZ2lubmluZyA/IFwiYmVnaW5uaW5nXCIgOiBcImVuZFwifSBvZiB0aGUgbm90ZXM/YClcbiAgICB0aGlzLnNldEluc3RydWN0aW9ucyhbXG4gICAgICB7XG4gICAgICAgIGNvbW1hbmQ6IFwiXCIsXG4gICAgICAgIHB1cnBvc2U6IGBXaGljaCBub3RlcyB3aXRoIHRhZyAke3RhZ1RvRmluZH0gZG8geW91IHdhbnQgdG8gJHtkZXNjcmlwdGlvbn0gdG8gJHtpbnNlcnRGcm9tQmVnaW5uaW5nID8gXCJiZWdpbm5pbmdcIiA6IFwiZW5kXCJ9IG9mIHRoZSBub3Rlcz9gXG4gICAgICB9XG4gICAgXSk7XG4gICAgdGhpcy5rZXlkb3duSGFuZGxlciA9IChldmVudDogS2V5Ym9hcmRFdmVudCkgPT4ge1xuICAgICAgaWYgKGV2ZW50Lm1ldGFLZXkgfHwgZXZlbnQuY3RybEtleSkge1xuICAgICAgICBjb25zdCBrZXkgPSBwYXJzZUludChldmVudC5rZXksIDEwKTtcbiAgICAgICAgaWYgKGtleSA+PSAxICYmIGtleSA8PSA5KSB7XG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTsgLy8gUHJldmVudCBkZWZhdWx0IGFjdGlvblxuICAgICAgICAgIHRoaXMuc2VsZWN0RWxlbWVudChrZXkgLSAxKTsgLy8gU2VsZWN0IHRoZSBlbGVtZW50IChpbmRleCBrZXkgLSAxKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vIExpc3RlbiBmb3Iga2V5ZG93biBldmVudHMgYXQgdGhlIGRvY3VtZW50IGxldmVsXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMua2V5ZG93bkhhbmRsZXIpO1xuICB9XG5cbiAgc2VsZWN0RWxlbWVudChpbmRleDogbnVtYmVyKSB7XG4gICAgY29uc3QgZWxlbWVudHMgPSB0aGlzLnJlc3VsdENvbnRhaW5lckVsLnF1ZXJ5U2VsZWN0b3JBbGwoJy5zdWdnZXN0aW9uLWl0ZW0nKTtcbiAgICBpZiAoZWxlbWVudHMubGVuZ3RoID4gaW5kZXgpIHtcbiAgICAgIGNvbnN0IGVsZW1lbnQgPSBlbGVtZW50c1tpbmRleF0gYXMgSFRNTEVsZW1lbnQ7XG4gICAgICBlbGVtZW50LmNsaWNrKCk7IC8vIFNpbXVsYXRlIGEgY2xpY2sgdG8gc2VsZWN0IHRoZSBlbGVtZW50XG4gICAgfVxuICB9XG5cbiAgb25DbG9zZSgpIHtcbiAgICBzdXBlci5vbkNsb3NlKCk7XG4gICAgLy8gU3RvcCBsaXN0ZW5pbmcgZm9yIGtleWRvd24gZXZlbnRzIHdoZW4gdGhlIG1vZGFsIGlzIGNsb3NlZFxuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLmtleWRvd25IYW5kbGVyKTtcbiAgfVxuXG4gIGdldEl0ZW1zKCk6IE5vdGVXaXRoSGVhZGVyW10ge1xuICAgIGNvbnN0IGZpbGVQYXRocyA9IGZpbGVzV2hlcmVUYWdJc1VzZWQodGhpcy50YWdUb0ZpbmQpXG4gICAgY29uc3QgZmlsZVBhdGhzRm9ySGVhZGVyID0gZmlsZXNIZWFkZXJzV2hlcmVUYWdJc1VzZWQodGhpcy5hcHAsIHRoaXMudGFnVG9GaW5kKVxuICAgIFxuICAgIHJldHVybiBbLi4uW3tub3RlUGF0aDogQkFDS19UT19TRUxFQ1RfVEFHLCBoZWFkZXI6IFwiXCIsIHN0YXJ0TGluZTogLTEsIG5vdGVUeXBlOiBudWxsfV0sIFxuICAgICAgLi4uZmlsZVBhdGhzLm1hcChmID0+IHsgcmV0dXJuIHtub3RlUGF0aDogZiwgaGVhZGVyOiBcIlwiLCBzdGFydExpbmU6IC0xLCBub3RlVHlwZTogZ2V0Tm90ZVR5cGUoZil9IH0pLFxuICAgICAgLi4uW3tub3RlUGF0aDogU0VQQVJBVE9SLCBoZWFkZXI6IFwiXCIsIHN0YXJ0TGluZTogMCwgbm90ZVR5cGU6IG51bGwgfV0sXG4gICAgICAuLi5maWxlUGF0aHNGb3JIZWFkZXJdO1xuICB9XG5cbiAgZ2V0SXRlbVRleHQocGF0aDogTm90ZVdpdGhIZWFkZXIpOiBzdHJpbmcge1xuICAgIHJldHVybiBwYXRoLm5vdGVQYXRoICsgcGF0aC5oZWFkZXI7XG4gIH1cblxuICAvLyBSZW5kZXJzIGVhY2ggc3VnZ2VzdGlvbiBpdGVtLlxuICByZW5kZXJTdWdnZXN0aW9uKHBhdGg6IEZ1enp5TWF0Y2g8Tm90ZVdpdGhIZWFkZXI+LCBlbDogSFRNTEVsZW1lbnQpIHtcbiAgICBjb25zdCBpdGVtOiBOb3RlV2l0aEhlYWRlciA9IHBhdGguaXRlbVxuICAgIGNvbnN0IHBhdGhJdGVtOiBzdHJpbmcgPSBpdGVtLm5vdGVQYXRoXG4gICAgbGV0IHByZWZpeCA9IGl0ZW0ubm90ZVR5cGUgPyAoaXRlbS5ub3RlVHlwZS5wcmVmaXggPyBpdGVtLm5vdGVUeXBlLnByZWZpeCArIFwiIFwiIDogXCJcIikgOiBcIlwiXG4gICAgLypcbiAgICBsZXQgcHJlZml4ID0gXCJcIlxuICAgIGlmIChwYXRoSXRlbSAhPT0gQkFDS19UT19TRUxFQ1RfVEFHKSB7XG4gICAgICBjb25zdCBub3RlVHlwZSA9IGdldE5vdGVUeXBlKHBhdGhJdGVtKVxuICAgICAgcHJlZml4ID0gbm90ZVR5cGUgPyBub3RlVHlwZS5wcmVmaXggKyBcIiBcIiA6IFwiXCJcbiAgICB9XG4gICAgKi9cbiAgICAvL2VsLmNyZWF0ZUVsKFwiZGl2XCIsIHsgdGV4dDogcHJlZml4ICsgcGF0aEl0ZW0gKyBwYXRoLml0ZW0uaGVhZGVyfSk7XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLnJlc3VsdENvbnRhaW5lckVsLnF1ZXJ5U2VsZWN0b3JBbGwoJy5zdWdnZXN0aW9uLWl0ZW0nKS5sZW5ndGg7XG4gICAgY29uc3QgaXRlbUluZGV4ID0gaW5kZXggPCAxMCA/IGluZGV4ICsgXCIuIFwiIDogXCIgICAgXCJcbiAgICBlbC5jcmVhdGVFbChcImRpdlwiLCB7IHRleHQ6IGl0ZW1JbmRleCArIHByZWZpeCArIGl0ZW0ubm90ZVBhdGh9KS8vICsgaXRlbS5oZWFkZXJ9KVxuICAgIGlmIChwYXRoLml0ZW0uaGVhZGVyLmxlbmd0aCA+IDApIHtcbiAgICAgIGVsLmNyZWF0ZUVsKFwic21hbGxcIiwgeyB0ZXh0OiBcIiAgICAgXCIgKyBpdGVtLmhlYWRlcn0pXG4gICAgfVxuICB9XG5cbiAgLy8gUGVyZm9ybSBhY3Rpb24gb24gdGhlIHNlbGVjdGVkIHN1Z2dlc3Rpb24uXG4gIG9uQ2hvb3NlSXRlbShwYXRoOiBOb3RlV2l0aEhlYWRlciwgZXZ0OiBNb3VzZUV2ZW50IHwgS2V5Ym9hcmRFdmVudCkge1xuICAgIGlmIChCQUNLX1RPX1NFTEVDVF9UQUcgPT0gcGF0aC5ub3RlUGF0aCkge1xuICAgICAgbmV3IEFkZFRleHRUb05vdGVzTW9kYWwodGhpcy5hcHAsIHRoaXMubGlua1RvQWRkLCB0aGlzLmRlc2NyaXB0aW9uLCB0aGlzLmluc2VydEZyb21CZWdpbm5pbmcsIHRoaXMucG9zdEFjdGlvbikub3BlbigpXG4gICAgfSBlbHNlIGlmIChTRVBBUkFUT1IgPT09IHBhdGgubm90ZVBhdGgpIHtcbiAgICAgIC8vIGRvIG5vdGhpbmdcbiAgICB9IGVsc2Uge1xuICAgICAgYWRkVGV4dFRvTm90ZXModGhpcy5saW5rVG9BZGQsIHBhdGgubm90ZVBhdGgsIHRoaXMuYXBwLCB0aGlzLmluc2VydEZyb21CZWdpbm5pbmcsIHBhdGguc3RhcnRMaW5lKVxuICAgICAgdGhpcy5wb3N0QWN0aW9uKClcbiAgICB9XG4gIH1cbn0iLCAiaW1wb3J0IHsgQXBwLCBFZGl0b3IsIE1hcmtkb3duVmlldywgTm90aWNlLCBURmlsZSwgVGV4dEZpbGVWaWV3LCBWYXVsdCwgV29ya3NwYWNlIH0gZnJvbSBcIm9ic2lkaWFuXCJcblxuLy8gaWYgaGVhZGluZ0xpbmUgPCAwLCBtZWFuaW5nIGluc2VydCBmaXJzdCBvciBsYXN0IG9mIG5vdGVzXG4vLyBlbHNlIGluc2VydCBmaXJzdCBvciBsYXN0IG9mIGhlYWRpbmcgbGluZVxuZXhwb3J0IGZ1bmN0aW9uIGFkZFRleHRUb05vdGVzKHRleHRUb0FkZDogc3RyaW5nLCB0b1BhdGg6IHN0cmluZywgYXBwOiBBcHAsIGluc2VydEZyb21CZWdpbm5pbmc6IGJvb2xlYW4sIGhlYWRpbmdMaW5lOiBudW1iZXIpIHtcbiAgICBjb25zdCB2YXVsdDogVmF1bHQgPSB0aGlzLmFwcC52YXVsdDtcbiAgICBjb25zdCB3b3Jrc3BhY2U6IFdvcmtzcGFjZSA9IHRoaXMuYXBwLndvcmtzcGFjZVxuICAgIGNvbnN0IGxlYWYgPSB3b3Jrc3BhY2UuZ2V0TGVhZihmYWxzZSk7XG4gICAgY29uc3QgdEZpbGU6IFRGaWxlID0gdmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKHRvUGF0aCkgYXMgVEZpbGVcbiAgICBjb25zdCBsaW5rID0gdGV4dFRvQWRkXG4gICAgUHJvbWlzZS5yZXNvbHZlKClcbiAgICAudGhlbigoKSA9PiB7XG4gICAgICAgIHJldHVybiBsZWFmLm9wZW5GaWxlKHRGaWxlLCB7IGFjdGl2ZTogdHJ1ZSB9KTtcbiAgICB9KVxuICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgLy9jb25zdCBlZGl0b3IgPSBhcHAud29ya3NwYWNlLmdldEFjdGl2ZVZpZXdPZlR5cGUoVGV4dEZpbGVWaWV3KTtcbiAgICAgICAgY29uc3QgbWFya2Rvd25WaWV3ID0gYXBwLndvcmtzcGFjZS5nZXRBY3RpdmVWaWV3T2ZUeXBlKE1hcmtkb3duVmlldyk7XG4gICAgICAgIGNvbnN0IGVkaXRvciA9IG1hcmtkb3duVmlldz8uZWRpdG9yXG4gICAgICAgIGNvbnN0IHZhbHVlID0gbWFya2Rvd25WaWV3Py5nZXRWaWV3RGF0YSgpXG4gICAgICAgIGlmIChtYXJrZG93blZpZXcgPT0gbnVsbCB8fCBlZGl0b3IgPT0gbnVsbCB8fCB2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBlcnJvclJlYXNvbiA9IGBlZGl0b3Igb3IgdmFsdWUgJHt0b1BhdGh9IG5vdCBleGlzdC4gQWJvcnRpbmcuLi5gXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3JSZWFzb24pXG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdHJpbW1lZExpbmsgPSBsaW5rLnRyaW0oKS5yZXBsYWNlKC9eLSAvLCAnJylcbiAgICAgICAgaWYgKGVkaXRvci5nZXRWYWx1ZSgpLmluY2x1ZGVzKHRyaW1tZWRMaW5rKSkge1xuICAgICAgICAgICAgY29uc3QgZXJyb3JSZWFzb24gPSBgTGluayAke3RyaW1tZWRMaW5rfSBhbHJlYWR5IGV4aXN0cyBpbiAke3RvUGF0aH0hYFxuICAgICAgICAgICAgbmV3IE5vdGljZShlcnJvclJlYXNvbilcblxuICAgICAgICAgICAgLy8gVGhlbiBzY3JvbGwgdG8gdGhhdCBsaW5lXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVkaXRvci5saW5lQ291bnQoKTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVkaXRvci5nZXRMaW5lKGkpLmluY2x1ZGVzKHRyaW1tZWRMaW5rKSkge1xuICAgICAgICAgICAgICAgICAgICBlZGl0b3Iuc2V0Q3Vyc29yKHtsaW5lOiBpLCBjaDogMH0pXG4gICAgICAgICAgICAgICAgICAgIGVkaXRvci5zY3JvbGxJbnRvVmlldyh7ZnJvbToge2xpbmU6IGksIGNoOiAwfSwgdG86IHtsaW5lOiBpLCBjaDogMH19LCB0cnVlKVxuICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChoZWFkaW5nTGluZSA8IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdWYWx1ZSA9IGluc2VydEZyb21CZWdpbm5pbmcgPyBcbiAgICAgICAgICAgICAgICBnZXROb3RlVmFsdWVJbnNlcnRpbmdUZXh0RnJvbVN0YXJ0T2ZOb3Rlcyh2YWx1ZSwgbGluaykgOiBcbiAgICAgICAgICAgICAgICBnZXROb3RlVmFsdWVJbnNlcnRpbmdUZXh0RnJvbUVuZE9mTm90ZXModmFsdWUsIGxpbmspXG4gICAgICAgICAgICAgICAgbWFya2Rvd25WaWV3LnNldFZpZXdEYXRhKG5ld1ZhbHVlLCBmYWxzZSlcbiAgICAgICAgICAgICAgICBlZGl0b3Iuc2V0VmFsdWUobmV3VmFsdWUpXG4gICAgICAgICAgICAgICAgaWYgKGluc2VydEZyb21CZWdpbm5pbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZnJvbnRNYXR0ZXJSZWdleCA9IC9eKC0tLVxcbltcXHNcXFNdKj9cXG4tLS1cXG4pL2dtXG4gICAgICAgICAgICAgICAgICAgIGlmIChmcm9udE1hdHRlclJlZ2V4LnRlc3QodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBsaW5lQWZ0ZXJGcm9udE1hdHRlciA9IGdldExpbmVBZnRlckZyb250TWF0dGVyKHZhbHVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgZWRpdG9yLnNldEN1cnNvcih7IGxpbmU6IGxpbmVBZnRlckZyb250TWF0dGVyLCBjaDogMCB9KSBcbiAgICAgICAgICAgICAgICAgICAgICAgIGVkaXRvci5zY3JvbGxJbnRvVmlldyh7ZnJvbToge2xpbmU6IGxpbmVBZnRlckZyb250TWF0dGVyLCBjaDogMH0sIHRvOiB7bGluZTogbGluZUFmdGVyRnJvbnRNYXR0ZXIsIGNoOiAwfX0sIHRydWUpXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlZGl0b3Iuc2V0Q3Vyc29yKHsgbGluZTogMCwgY2g6IDAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGVkaXRvci5zY3JvbGxJbnRvVmlldyh7ZnJvbToge2xpbmU6IDAsIGNoOiAwfSwgdG86IHtsaW5lOiAwLCBjaDogMH19LCB0cnVlKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGFzdExpbmVOdW0gPSBlZGl0b3IubGluZUNvdW50KCkgLSAxXG4gICAgICAgICAgICAgICAgICAgIGVkaXRvci5zZXRDdXJzb3IoeyBsaW5lOiBsYXN0TGluZU51bSwgY2g6IDAgfSlcbiAgICAgICAgICAgICAgICAgICAgZWRpdG9yLnNjcm9sbEludG9WaWV3KHtmcm9tOiB7bGluZTogbGFzdExpbmVOdW0sIGNoOiAwfSwgdG86IHtsaW5lOiBsYXN0TGluZU51bSwgY2g6IDB9fSwgdHJ1ZSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbmV3IE5vdGljZShgQWRkZWQgbGluayB0byAke2luc2VydEZyb21CZWdpbm5pbmcgPyBcImJlZ2lubmluZ1wiIDogXCJlbmRcIn0gb2YgJHt0b1BhdGh9IWApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdWYWx1ZTogTm90ZXNXaXRoQ3Vyc29yTGluZSA9IGluc2VydEZyb21CZWdpbm5pbmcgPyBcbiAgICAgICAgICAgICAgICBnZXROb3RlVmFsdWVJbnNlcnRpbmdUZXh0RnJvbVN0YXJ0T2ZOb3Rlc0hlYWRpbmcodmFsdWUsIGxpbmssIGhlYWRpbmdMaW5lKSA6IFxuICAgICAgICAgICAgICAgIGdldE5vdGVWYWx1ZUluc2VydGluZ1RleHRGcm9tRW5kT2ZOb3Rlc0hlYWRpbmcodmFsdWUsIGxpbmssIGhlYWRpbmdMaW5lKVxuICAgICAgICAgICAgICAgIG1hcmtkb3duVmlldy5zZXRWaWV3RGF0YShuZXdWYWx1ZS52YWx1ZSwgZmFsc2UpXG4gICAgICAgICAgICAgICAgZWRpdG9yLnNldFZhbHVlKG5ld1ZhbHVlLnZhbHVlKVxuICAgICAgICAgICAgICAgIGVkaXRvci5zZXRDdXJzb3Ioe2xpbmU6IG5ld1ZhbHVlLmxpbmUsIGNoOiAwfSlcbiAgICAgICAgICAgICAgICBlZGl0b3Iuc2Nyb2xsSW50b1ZpZXcoe2Zyb206IHtsaW5lOiBuZXdWYWx1ZS5saW5lLCBjaDogMH0sIHRvOiB7bGluZTogbmV3VmFsdWUubGluZSwgY2g6IDB9fSwgdHJ1ZSlcbiAgICAgICAgICAgICAgICBuZXcgTm90aWNlKGBBZGRlZCBsaW5rIHRvICR7aW5zZXJ0RnJvbUJlZ2lubmluZyA/IFwiYmVnaW5uaW5nXCIgOiBcImVuZFwifSBvZiBTZWN0aW9uIG9mICR7dG9QYXRofSFgKTtcbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgIGlmIChpbnNlcnRGcm9tQmVnaW5uaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZyb250TWF0dGVyUmVnZXggPSAvXigtLS1cXG5bXFxzXFxTXSo/XFxuLS0tXFxuKS9nbVxuICAgICAgICAgICAgICAgICAgICBpZiAoZnJvbnRNYXR0ZXJSZWdleC50ZXN0KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbGluZUFmdGVyRnJvbnRNYXR0ZXIgPSBnZXRMaW5lQWZ0ZXJGcm9udE1hdHRlcih2YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGVkaXRvci5zZXRDdXJzb3IoeyBsaW5lOiBsaW5lQWZ0ZXJGcm9udE1hdHRlciwgY2g6IDAgfSkgXG4gICAgICAgICAgICAgICAgICAgICAgICBlZGl0b3Iuc2Nyb2xsSW50b1ZpZXcoe2Zyb206IHtsaW5lOiBsaW5lQWZ0ZXJGcm9udE1hdHRlciwgY2g6IDB9LCB0bzoge2xpbmU6IGxpbmVBZnRlckZyb250TWF0dGVyLCBjaDogMH19LCB0cnVlKVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWRpdG9yLnNldEN1cnNvcih7IGxpbmU6IDAsIGNoOiAwIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICBlZGl0b3Iuc2Nyb2xsSW50b1ZpZXcoe2Zyb206IHtsaW5lOiAwLCBjaDogMH0sIHRvOiB7bGluZTogMCwgY2g6IDB9fSwgdHJ1ZSlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxhc3RMaW5lTnVtID0gZWRpdG9yLmxpbmVDb3VudCgpIC0gMVxuICAgICAgICAgICAgICAgICAgICBlZGl0b3Iuc2V0Q3Vyc29yKHsgbGluZTogbGFzdExpbmVOdW0sIGNoOiAwIH0pXG4gICAgICAgICAgICAgICAgICAgIGVkaXRvci5zY3JvbGxJbnRvVmlldyh7ZnJvbToge2xpbmU6IGxhc3RMaW5lTnVtLCBjaDogMH0sIHRvOiB7bGluZTogbGFzdExpbmVOdW0sIGNoOiAwfX0sIHRydWUpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICBcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKClcbiAgICB9KVxuICAgIC5jYXRjaCgocmVhc29uKSA9PiB7IFxuICAgICAgICBuZXcgTm90aWNlKHJlYXNvbilcbiAgICB9KVxuICAgIC8qIHRoaXMgdmVyc2lvbiBjYW5ub3QgcmVkbywgY2FuIHJlbW92ZSBpZiBhYm92ZVxuICAgIFByb21pc2UucmVzb2x2ZSgpXG4gICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB2YXVsdC5yZWFkKHRGaWxlKVxuICAgICAgICB9LCByZWFzb24gPT4geyBuZXcgTm90aWNlKFwiRXJyb3Igb2NjdXJyZWQgd2hlbiByZWFkaW5nIFwiICsgdG9QYXRoKSB9KVxuICAgICAgICAudGhlbigodmFsdWUpID0+IHtcbiAgICAgICAgICAgIGlmICh2YWx1ZS5pbmNsdWRlcyhsaW5rKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yUmVhc29uID0gYExpbmsgJHtsaW5rVG9BZGR9IGFscmVhZHkgZXhpc3RzIGluICR7dG9QYXRofSFgXG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yUmVhc29uKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbmV3VmFsdWUgPSBpbnNlcnRGcm9tQmVnaW5uaW5nID8gXG4gICAgICAgICAgICAgICAgZ2V0Tm90ZVZhbHVlSW5zZXJ0aW5nTm90ZUxpbmtGcm9tU3RhcnRPZk5vdGVzKHZhbHVlLCBsaW5rKSA6IFxuICAgICAgICAgICAgICAgIGdldE5vdGVWYWx1ZUluc2VydGluZ05vdGVMaW5rRnJvbUVuZE9mTm90ZXModmFsdWUsIGxpbmspXG4gICAgICAgICAgICByZXR1cm4gdmF1bHQubW9kaWZ5KHRGaWxlLCBuZXdWYWx1ZSlcbiAgICAgICAgfSlcbiAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgbmV3IE5vdGljZShgQWRkZWQgbGluayB0byAke2luc2VydEZyb21CZWdpbm5pbmcgPyBcImJlZ2lubmluZ1wiIDogXCJlbmRcIn0gb2YgJHt0b1BhdGh9IWApO1xuICAgICAgICAgICAgY29uc3QgbGVhZiA9IHdvcmtzcGFjZS5nZXRMZWFmKGZhbHNlKTtcbiAgICAgICAgICAgIHJldHVybiBsZWFmLm9wZW5GaWxlKHRGaWxlLCB7IGFjdGl2ZTogdHJ1ZSB9KTtcbiAgICAgICAgfSwgKHJlYXNvbikgPT4geyBcbiAgICAgICAgICAgIG5ldyBOb3RpY2UocmVhc29uKSBcbiAgICAgICAgICAgIGNvbnN0IGxlYWYgPSB3b3Jrc3BhY2UuZ2V0TGVhZihmYWxzZSk7XG4gICAgICAgICAgICByZXR1cm4gbGVhZi5vcGVuRmlsZSh0RmlsZSwgeyBhY3RpdmU6IHRydWUgfSk7XG4gICAgICAgIH0pXG4gICAgICAgICovXG59XG5cbmZ1bmN0aW9uIGdldExpbmVBZnRlckZyb250TWF0dGVyKHZhbHVlOiBzdHJpbmcpIHtcbiAgICBjb25zdCB2YWx1ZXMgPSB2YWx1ZS5zcGxpdChcIlxcblwiKVxuICAgIGxldCBmbUNvdW50ID0gMFxuICAgIGNvbnN0IGxpbmVOdW0gPSB2YWx1ZXMubGVuZ3RoXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lTnVtOyBpKyspIHtcbiAgICAgICAgaWYgKHZhbHVlc1tpXSA9PT0gXCItLS1cIikge1xuICAgICAgICAgICAgZm1Db3VudCsrXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZtQ291bnQgPT0gMikge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGgubWluKGkgKyAxLCBsaW5lTnVtIC0gMSlcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbGluZU51bSAtIDFcbn1cblxuZnVuY3Rpb24gZ2V0Tm90ZVZhbHVlSW5zZXJ0aW5nVGV4dEZyb21TdGFydE9mTm90ZXModmFsdWU6IHN0cmluZywgdGV4dDogc3RyaW5nKSB7XG4gICAgY29uc3QgZnJvbnRNYXR0ZXJSZWdleCA9IC9eKC0tLVxcbltcXHNcXFNdKj9cXG4tLS1cXG4pL2dtXG4gICAgLy8gL14tLS1cXG4oLiopKlxcbi0tLVxcbi9cbiAgICBpZiAoZnJvbnRNYXR0ZXJSZWdleC50ZXN0KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdmFsdWUucmVwbGFjZShmcm9udE1hdHRlclJlZ2V4LCBcIiQxXCIgKyB0ZXh0ICsgXCJcXG5cIilcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGV4dCArIFwiXFxuXCIgKyB2YWx1ZVxuICAgIH1cbn1cblxuZnVuY3Rpb24gZ2V0Tm90ZVZhbHVlSW5zZXJ0aW5nVGV4dEZyb21FbmRPZk5vdGVzKHZhbHVlOiBzdHJpbmcsIHRleHQ6IHN0cmluZykge1xuICAgIHJldHVybiB2YWx1ZSArIFwiXFxuXCIgKyB0ZXh0XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTm90ZXNXaXRoQ3Vyc29yTGluZSB7XG4gICAgdmFsdWU6IHN0cmluZyxcbiAgICBsaW5lOiBudW1iZXJcbn1cblxuZnVuY3Rpb24gZ2V0Tm90ZVZhbHVlSW5zZXJ0aW5nVGV4dEZyb21TdGFydE9mTm90ZXNIZWFkaW5nKHZhbHVlOiBzdHJpbmcsIHRleHQ6IHN0cmluZywgaGVhZGluZ0xpbmU6IG51bWJlcikgOiBOb3Rlc1dpdGhDdXJzb3JMaW5le1xuICAgIGNvbnN0IHZhbHVlczogc3RyaW5nW10gPSB2YWx1ZS5zcGxpdChcIlxcblwiKVxuICAgIGxldCByZXN1bHQgPSBcIlwiXG4gICAgbGV0IGFkZGVkTGluZSA9IC0xXG4gICAgbGV0IGlzQWRkZWRMaW5lID0gZmFsc2VcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoaSA8PSBoZWFkaW5nTGluZSkge1xuICAgICAgICAgICAgcmVzdWx0ICs9IHZhbHVlc1tpXSArIFwiXFxuXCJcbiAgICAgICAgfSBlbHNlIGlmICh2YWx1ZXNbaV0udHJpbSgpID09PSBcIlwiKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gdmFsdWVzW2ldICsgXCJcXG5cIlxuICAgICAgICB9IGVsc2UgaWYgKCFpc0FkZGVkTGluZSkge1xuICAgICAgICAgICAgcmVzdWx0ICs9IHRleHQgKyBcIlxcblwiICsgdmFsdWVzW2ldICsgXCJcXG5cIlxuICAgICAgICAgICAgYWRkZWRMaW5lID0gaVxuICAgICAgICAgICAgaXNBZGRlZExpbmUgPSB0cnVlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gdmFsdWVzW2ldICsgXCJcXG5cIlxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7dmFsdWU6IHJlc3VsdC5yZXBsYWNlKC9cXG4kLywgXCJcIiksIGxpbmU6IGlzQWRkZWRMaW5lID8gYWRkZWRMaW5lIDogaGVhZGluZ0xpbmV9XG59XG5cbmZ1bmN0aW9uIGdldE5vdGVWYWx1ZUluc2VydGluZ1RleHRGcm9tRW5kT2ZOb3Rlc0hlYWRpbmcodmFsdWU6IHN0cmluZywgdGV4dDogc3RyaW5nLCBoZWFkaW5nTGluZTogbnVtYmVyKSA6IE5vdGVzV2l0aEN1cnNvckxpbmV7XG4gICAgY29uc3QgdmFsdWVzOiBzdHJpbmdbXSA9IHZhbHVlLnNwbGl0KFwiXFxuXCIpXG5cbiAgICBsZXQgYWRkZWRMaW5lID0gaGVhZGluZ0xpbmUgXG5cbiAgICBsZXQgZW5kTGluZU9mU2VjdGlvbiA9IHZhbHVlcy5sZW5ndGggLSAxXG4gICAgLy8gZmlyc3QgZ2V0IHJhbmdlIG9mIHRoZSBoZWFkZXJcbiAgICBmb3IgKGxldCBpID0gaGVhZGluZ0xpbmU7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGkgPT09IGhlYWRpbmdMaW5lKSB7XG4gICAgICAgICAgICBcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICgvXlsjXXsxLDZ9IC8udGVzdCh2YWx1ZXNbaV0pKSB7XG4gICAgICAgICAgICAgICAgZW5kTGluZU9mU2VjdGlvbiA9IGkgLSAxXG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvL2NvbnNvbGUubG9nKGhlYWRpbmdMaW5lICsgXCIgXCIgKyBlbmRMaW5lT2ZTZWN0aW9uKVxuICAgIC8vY29uc29sZS5sb2codmFsdWVzW2VuZExpbmVPZlNlY3Rpb25dKVxuICAgIGxldCBmaW5pc2ggPSBmYWxzZVxuICAgIC8vIHRoZW4gZ2V0IGxhc3QgbGluZSBvZiByYW5nZSB3aGljaCBpcyBub24tZW1wdHlcbiAgICBmb3IgKGxldCBpID0gZW5kTGluZU9mU2VjdGlvbjsgaSA+IGhlYWRpbmdMaW5lICYmICFmaW5pc2g7IGktLSkge1xuICAgICAgICBpZiAodmFsdWVzW2ldLnRyaW0oKSAhPT0gXCJcIikge1xuICAgICAgICAgICAgYWRkZWRMaW5lID0gaVxuICAgICAgICAgICAgZmluaXNoID0gdHJ1ZVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vY29uc29sZS5sb2coYWRkZWRMaW5lKVxuICAgIC8vY29uc29sZS5sb2codmFsdWVzW2FkZGVkTGluZV0pXG4gICAgLy8gdGhlbiBhZGQgaW4gdGhpcyBsaW5lXG4gICAgbGV0IHJlc3VsdCA9IFwiXCJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoaSAhPSBhZGRlZExpbmUpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSB2YWx1ZXNbaV0gKyBcIlxcblwiXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gdmFsdWVzW2ldICsgXCJcXG5cIiArIHRleHQgKyBcIlxcblwiXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge3ZhbHVlOiByZXN1bHQucmVwbGFjZSgvXFxuJC8sIFwiXCIpLCBsaW5lOiBhZGRlZExpbmUgKyAxfVxufVxuXG4iLCAiaW1wb3J0IHsgQXBwLCBDYWNoZWRNZXRhZGF0YSwgVEZpbGUsIHBhcnNlRnJvbnRNYXR0ZXJBbGlhc2VzLCBwYXJzZUZyb250TWF0dGVyVGFncyB9IGZyb20gXCJvYnNpZGlhblwiO1xuaW1wb3J0IHsgTm90ZVdpdGhIZWFkZXIgfSBmcm9tIFwiLi9ub3RlV2l0aEhlYWRlclwiO1xuXG5leHBvcnQgZnVuY3Rpb24gZmlsZXNXaGVyZVRhZ0lzVXNlZChmaW5kVGFnOiBzdHJpbmcpOiBzdHJpbmdbXSB7XG4gICAgY29uc3QgZmlsZXNMaXN0OiBzdHJpbmdbXSA9IFtdO1xuICAgIGZvciAoY29uc3QgZmlsZVBhdGggb2YgbG9jYXRpb25zV2hlcmVUYWdJc1VzZWQoZmluZFRhZykpIHtcbiAgICAgICAgaWYgKCFmaWxlc0xpc3QuaW5jbHVkZXMoZmlsZVBhdGgpKSB7XG4gICAgICAgICAgICBmaWxlc0xpc3QucHVzaChmaWxlUGF0aClcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmlsZXNMaXN0LnNvcnQoKGE6IHN0cmluZywgYjogc3RyaW5nKSA9PiBhLmxvY2FsZUNvbXBhcmUoYikpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZmlsZXNIZWFkZXJzV2hlcmVUYWdJc1VzZWQoYXBwOiBBcHAsIGZpbmRUYWc6IHN0cmluZyk6IE5vdGVXaXRoSGVhZGVyW10ge1xuICAgIGNvbnN0IGZpbGVMaXN0OiBzdHJpbmdbXSA9IGZpbGVzV2hlcmVUYWdJc1VzZWQoZmluZFRhZyk7XG4gICAgY29uc3QgcmVzdWx0TGlzdDogTm90ZVdpdGhIZWFkZXJbXSA9IFtdO1xuICAgIGZvciAoY29uc3QgZmlsZVBhdGggb2YgZmlsZUxpc3QpIHtcbiAgICAgICAgY29uc3QgZmlsZSA6IFRGaWxlID0gYXBwLnZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aChmaWxlUGF0aCkgYXMgVEZpbGVcbiAgICAgICAgY29uc3QgZmlsZUNhY2hlID0gYXBwLm1ldGFkYXRhQ2FjaGUuZ2V0RmlsZUNhY2hlKGZpbGUpXG4gICAgICAgIGlmICghZmlsZUNhY2hlKSB7XG5cbiAgICAgICAgfSBlbHNlIGlmICghZmlsZUNhY2hlLmhlYWRpbmdzKSB7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZpbGVDYWNoZS5oZWFkaW5ncy5mb3JFYWNoKGggPT4ge1xuICAgICAgICAgICAgICAgIHJlc3VsdExpc3QucHVzaCh7bm90ZVBhdGg6IGZpbGVQYXRoLCBoZWFkZXI6IFwiI1wiICsgaC5oZWFkaW5nLCBzdGFydExpbmU6IGgucG9zaXRpb24uc3RhcnQubGluZSwgbm90ZVR5cGU6IG51bGx9KVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfSAgIFxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0TGlzdFxufVxuXG4vLyByZXR1cm4gYXJyYXkgb2YgZmlsZSBwYXRoXG5mdW5jdGlvbiBsb2NhdGlvbnNXaGVyZVRhZ0lzVXNlZChmaW5kVGFnOiBzdHJpbmcpOiBBcnJheTxzdHJpbmc+IHtcbiAgICBjb25zdCBvQXBwOiBBcHAgPSBhcHA7XG4gICAgY29uc3QgcmVzdWx0czogc3RyaW5nW10gPSBbXTtcblxuICAgIGZvciAoY29uc3QgZmlsZSBvZiBvQXBwLnZhdWx0LmdldE1hcmtkb3duRmlsZXMoKSkge1xuICAgICAgICBjb25zdCBjYWNoZTogQ2FjaGVkTWV0YWRhdGEgfCBudWxsID0gb0FwcC5tZXRhZGF0YUNhY2hlLmdldEZpbGVDYWNoZShmaWxlKTtcbiAgICAgICAgaWYgKGNhY2hlICE9IG51bGwgJiYgY2FjaGUudGFncykge1xuICAgICAgICAgICAgZm9yIChjb25zdCB0YWcgb2YgY2FjaGUudGFncykge1xuICAgICAgICAgICAgICAgIGlmIChmaW5kVGFnID09PSB0YWcudGFnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChmaWxlLnBhdGgpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjYWNoZSAhPSBudWxsICYmIGNhY2hlLmZyb250bWF0dGVyKSB7XG4gICAgICAgICAgICBjb25zdCBmbXRhZ3MgPSAocGFyc2VGcm9udE1hdHRlclRhZ3MoY2FjaGUuZnJvbnRtYXR0ZXIpIHx8IFtdKS5maWx0ZXIodGFnID0+IGZpbmRUYWcgPT0gdGFnIHx8IHRhZy5zdGFydHNXaXRoKGZpbmRUYWcgKyBcIi9cIikpO1xuICAgICAgICAgICAgaWYgKGZtdGFncy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goZmlsZS5wYXRoKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZm10YWdzMiA9IChwYXJzZUZyb250TWF0dGVyQWxpYXNlcyhjYWNoZS5mcm9udG1hdHRlcikgfHwgW10pLmZpbHRlcih0YWcgPT4gZmluZFRhZyA9PSB0YWcgfHwgdGFnLnN0YXJ0c1dpdGgoZmluZFRhZyArIFwiL1wiKSk7XG4gICAgICAgICAgICBpZiAoZm10YWdzMi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goZmlsZS5wYXRoKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRzXG59IiwgImltcG9ydCB7IE5vdGVUeXBlIH0gZnJvbSBcIi4vZ2V0VGFza1RhZ1wiXG5cbmV4cG9ydCBpbnRlcmZhY2UgTm90ZVdpdGhIZWFkZXIge1xuICAgIG5vdGVQYXRoOiBzdHJpbmcsXG4gICAgaGVhZGVyOiBzdHJpbmcsXG4gICAgc3RhcnRMaW5lOiBudW1iZXIsXG4gICAgbm90ZVR5cGU6IE5vdGVUeXBlIHwgbnVsbFxufVxuXG5leHBvcnQgY29uc3QgU0VQQVJBVE9SID0gXCItLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXCIiLCAiaW1wb3J0IHsgQWRkVGV4dFRvTm90ZXNGcm9tU3BlY2lmaWNUYWdNb2RhbCB9IGZyb20gXCJhZGRUZXh0VG9Ob3Rlc0Zyb21TcGVjaWZpY1RhZ01vZGFsXCI7XG5pbXBvcnQgeyBBcHAsIEZ1enp5U3VnZ2VzdE1vZGFsLCBGdXp6eU1hdGNoLCBnZXRBbGxUYWdzIH0gZnJvbSBcIm9ic2lkaWFuXCI7XG5pbXBvcnQgeyBhZGRUZXh0VG9Ob3RlcyB9IGZyb20gXCJzZWxmdXRpbC9hZGRsaW5rdG9ub3Rlc1wiO1xuaW1wb3J0IHsgZ2V0QWxsSGVhZGVycyB9IGZyb20gXCJzZWxmdXRpbC9nZXRBbGxIZWFkZXJzXCI7XG5pbXBvcnQgeyBnZXRBbGxOb3RlVGFncyB9IGZyb20gXCJzZWxmdXRpbC9nZXRBbGxOb3RlVGFnc1wiO1xuaW1wb3J0IHsgZ2V0QWxsTm90ZXMsIGdldFJlY2VudE5vdGVzIH0gZnJvbSBcInNlbGZ1dGlsL2dldFJlY2VudE5vdGVzXCI7XG5pbXBvcnQgeyBOb3RlVHlwZSwgZ2V0Tm90ZVR5cGUgfSBmcm9tIFwic2VsZnV0aWwvZ2V0VGFza1RhZ1wiO1xuaW1wb3J0IHsgTm90ZVdpdGhIZWFkZXIgfSBmcm9tIFwic2VsZnV0aWwvbm90ZVdpdGhIZWFkZXJcIjtcblxuZXhwb3J0IGNsYXNzIEFkZFRleHRUb05vdGVzTW9kYWwgZXh0ZW5kcyBGdXp6eVN1Z2dlc3RNb2RhbDxOb3RlV2l0aEhlYWRlcj4ge1xuXG4gIGxpbmtUb0FkZDogc3RyaW5nXG4gIHRhc2tUeXBlOiBTdHJpbmdcbiAgZGVzY3JpcHRpb246IHN0cmluZ1xuICBpbnNlcnRGcm9tQmVnaW5uaW5nOiBib29sZWFuXG4gIHBvc3RBY3Rpb246ICgpID0+IHZvaWRcbiAgaXRlbXM6IE5vdGVXaXRoSGVhZGVyW11cbiAga2V5ZG93bkhhbmRsZXI6IChldmVudDogS2V5Ym9hcmRFdmVudCkgPT4gdm9pZDtcblxuICBjb25zdHJ1Y3RvcihhcHA6IEFwcCwgbGlua1RvQWRkOiBzdHJpbmcsIGRlc2NyaXB0aW9uOiBzdHJpbmcsIGluc2VydEZyb21CZWdpbm5pbmc6IGJvb2xlYW4sIHBvc3RBY3Rpb246ICgpID0+IHZvaWQpXG4gIHtcbiAgICBzdXBlcihhcHApXG4gICAgdGhpcy5saW5rVG9BZGQgPSBsaW5rVG9BZGRcbiAgICB0aGlzLmRlc2NyaXB0aW9uID0gZGVzY3JpcHRpb25cbiAgICB0aGlzLmluc2VydEZyb21CZWdpbm5pbmcgPSBpbnNlcnRGcm9tQmVnaW5uaW5nXG4gICAgdGhpcy5wb3N0QWN0aW9uID0gcG9zdEFjdGlvblxuICAgIHRoaXMuc2V0UGxhY2Vob2xkZXIoYFdoaWNoIG5vdGVzIHdpdGggdGFncyBkbyB5b3Ugd2FudCB0byAke2Rlc2NyaXB0aW9ufSB0byAke2luc2VydEZyb21CZWdpbm5pbmcgPyBcImJlZ2lubmluZ1wiIDogXCJlbmRcIn0gb2YgdGhlIG5vdGVzP2ApXG4gICAgdGhpcy5zZXRJbnN0cnVjdGlvbnMoW1xuICAgICAge1xuICAgICAgICBjb21tYW5kOiBcIlwiLFxuICAgICAgICBwdXJwb3NlOiBgV2hpY2ggbm90ZXMgd2l0aCB0YWdzIGRvIHlvdSB3YW50IHRvICR7ZGVzY3JpcHRpb259IHRvICR7aW5zZXJ0RnJvbUJlZ2lubmluZyA/IFwiYmVnaW5uaW5nXCIgOiBcImVuZFwifSBvZiB0aGUgbm90ZXM/YFxuICAgICAgfVxuICAgIF0pO1xuICAgIHRoaXMua2V5ZG93bkhhbmRsZXIgPSAoZXZlbnQ6IEtleWJvYXJkRXZlbnQpID0+IHtcbiAgICAgIGlmIChldmVudC5tZXRhS2V5IHx8IGV2ZW50LmN0cmxLZXkpIHtcbiAgICAgICAgY29uc3Qga2V5ID0gcGFyc2VJbnQoZXZlbnQua2V5LCAxMCk7XG4gICAgICAgIGlmIChrZXkgPj0gMSAmJiBrZXkgPD0gOSkge1xuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7IC8vIFByZXZlbnQgZGVmYXVsdCBhY3Rpb25cbiAgICAgICAgICB0aGlzLnNlbGVjdEVsZW1lbnQoa2V5IC0gMSk7IC8vIFNlbGVjdCB0aGUgZWxlbWVudCAoaW5kZXgga2V5IC0gMSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBMaXN0ZW4gZm9yIGtleWRvd24gZXZlbnRzIGF0IHRoZSBkb2N1bWVudCBsZXZlbFxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLmtleWRvd25IYW5kbGVyKTtcbiAgICB0aGlzLml0ZW1zID0gdGhpcy5wcmVwYXJlSXRlbXMoKVxuICB9XG5cbiAgc2VsZWN0RWxlbWVudChpbmRleDogbnVtYmVyKSB7XG4gICAgY29uc3QgZWxlbWVudHMgPSB0aGlzLnJlc3VsdENvbnRhaW5lckVsLnF1ZXJ5U2VsZWN0b3JBbGwoJy5zdWdnZXN0aW9uLWl0ZW0nKTtcbiAgICBpZiAoZWxlbWVudHMubGVuZ3RoID4gaW5kZXgpIHtcbiAgICAgIGNvbnN0IGVsZW1lbnQgPSBlbGVtZW50c1tpbmRleF0gYXMgSFRNTEVsZW1lbnQ7XG4gICAgICBlbGVtZW50LmNsaWNrKCk7IC8vIFNpbXVsYXRlIGEgY2xpY2sgdG8gc2VsZWN0IHRoZSBlbGVtZW50XG4gICAgfVxuICB9XG5cbiAgZ2V0SXRlbXMoKSA6IE5vdGVXaXRoSGVhZGVyW10ge1xuICAgIHJldHVybiB0aGlzLml0ZW1zXG4gIH1cblxuICBwcmVwYXJlSXRlbXMoKSA6IE5vdGVXaXRoSGVhZGVyW10ge1xuICAgIGNvbnN0IGFsbE5vdGVzUGF0aCA9IGdldEFsbE5vdGVzKHRoaXMuYXBwKVxuICAgIGNvbnN0IGFsbEhlYWRlciA9IGdldEFsbEhlYWRlcnModGhpcy5hcHAsIGFsbE5vdGVzUGF0aClcblx0XHRjb25zdCBsID0gWy4uLlt7bm90ZVBhdGg6ICdJL0luYm94Lm1kJywgaGVhZGVyOiBcIlwiLCBzdGFydExpbmU6IC0xLCBub3RlVHlwZTogZ2V0Tm90ZVR5cGUoJ0kvSW5ib3gubWQnKX1dLFxuICAgICAgICAgICAgICAgLi4uZ2V0UmVjZW50Tm90ZXModGhpcy5hcHAsIDUwKS5tYXAocyA9PiB7IHJldHVybiB7bm90ZVBhdGg6IHMsIGhlYWRlcjogXCJcIiwgc3RhcnRMaW5lOiAtMSwgbm90ZVR5cGU6IGdldE5vdGVUeXBlKHMpfSB9KSxcbiAgICAgICAgICAgICAgIC4uLmdldEFsbE5vdGVUYWdzKHRoaXMuYXBwKS5tYXAocyA9PiBzLnJlcGxhY2UoL14jLywgXCJAXCIpKS5tYXAocyA9PiB7IHJldHVybiB7bm90ZVBhdGg6IHMsIGhlYWRlcjogXCJcIiwgc3RhcnRMaW5lOiAtMSwgbm90ZVR5cGU6IG51bGx9IH0pLFxuICAgICAgICAgICAgICAgLi4uYWxsTm90ZXNQYXRoLm1hcChzID0+IHsgcmV0dXJuIHtub3RlUGF0aDogcywgaGVhZGVyOiBcIlwiLCBzdGFydExpbmU6IC0xLCBub3RlVHlwZTogZ2V0Tm90ZVR5cGUocyl9IH0pLFxuICAgICAgICAgICAgICAgLi4uYWxsSGVhZGVyXG4gICAgICAgICAgICAgIF07XG4gICAgLy8gcmVtb3ZlIGR1cGxpY2F0ZSBmb3IgbFxuICAgIHJldHVybiBsLmZpbHRlcigoaXRlbSwgaW5kZXgpID0+IGwuaW5kZXhPZihpdGVtKSA9PT0gaW5kZXgpO1xuXG4gIH1cblxuICBvbkNsb3NlKCkge1xuICAgIHN1cGVyLm9uQ2xvc2UoKTtcbiAgICAvLyBTdG9wIGxpc3RlbmluZyBmb3Iga2V5ZG93biBldmVudHMgd2hlbiB0aGUgbW9kYWwgaXMgY2xvc2VkXG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMua2V5ZG93bkhhbmRsZXIpO1xuICB9XG5cbiAgZ2V0SXRlbVRleHQodmFsdWU6IE5vdGVXaXRoSGVhZGVyKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdmFsdWUubm90ZVBhdGggKyB2YWx1ZS5oZWFkZXI7XG4gIH1cblxuICAvLyBSZW5kZXJzIGVhY2ggc3VnZ2VzdGlvbiBpdGVtLlxuICByZW5kZXJTdWdnZXN0aW9uKHZhbHVlOiBGdXp6eU1hdGNoPE5vdGVXaXRoSGVhZGVyPiwgZWw6IEhUTUxFbGVtZW50KSB7XG4gICAgY29uc3QgaXRlbSA9IHZhbHVlLml0ZW1cbiAgICBsZXQgcHJlZml4ID0gaXRlbS5ub3RlVHlwZSA/IChpdGVtLm5vdGVUeXBlLnByZWZpeCA/IGl0ZW0ubm90ZVR5cGUucHJlZml4ICsgXCIgXCIgOiBcIlwiKSA6IFwiXCJcbiAgICAvKlxuICAgIGlmICghaXRlbS5ub3RlUGF0aC5zdGFydHNXaXRoKFwiQFwiKSkge1xuICAgICAgY29uc3Qgbm90ZVR5cGUgOiBOb3RlVHlwZSB8IG51bGwgPSBnZXROb3RlVHlwZShpdGVtLm5vdGVQYXRoKVxuICAgICAgcHJlZml4ID0gbm90ZVR5cGUgPyBub3RlVHlwZS5wcmVmaXggKyBcIiBcIiA6IFwiXCJcbiAgICB9XG4gICAgKi9cbiAgICBjb25zdCBpbmRleCA9IHRoaXMucmVzdWx0Q29udGFpbmVyRWwucXVlcnlTZWxlY3RvckFsbCgnLnN1Z2dlc3Rpb24taXRlbScpLmxlbmd0aDtcbiAgICBjb25zdCBpdGVtSW5kZXggPSBpbmRleCA8IDEwID8gaW5kZXggKyBcIi4gXCIgOiBcIiAgICBcIlxuICAgIGVsLmNyZWF0ZUVsKFwiZGl2XCIsIHsgdGV4dDogaXRlbUluZGV4ICsgcHJlZml4ICsgaXRlbS5ub3RlUGF0aH0pLy8gKyBpdGVtLmhlYWRlcn0pXG4gICAgaWYgKGl0ZW0uaGVhZGVyLmxlbmd0aCA+IDApIHtcbiAgICAgIGVsLmNyZWF0ZUVsKFwic21hbGxcIiwgeyB0ZXh0OiBcIiAgICAgXCIgKyBpdGVtLmhlYWRlcn0pXG4gICAgfVxuICB9XG5cbiAgb25PcGVuKCkge1xuICAgIHN1cGVyLm9uT3BlbigpO1xuICAgIHRoaXMuaW5wdXRFbC52YWx1ZSA9IFwiQFwiO1xuICAgIHRoaXMuaW5wdXRFbC50cmlnZ2VyKFwiaW5wdXRcIik7XG5cbiAgICB0aGlzLmlucHV0RWwuYWRkRXZlbnRMaXN0ZW5lcignaW5wdXQnLCAoKSA9PiB7XG4gICAgICBpZiAodGhpcy5pbnB1dEVsLnZhbHVlLnN0YXJ0c1dpdGgoJ0AnKSAmJiAodGhpcy5pbnB1dEVsLnZhbHVlLmxlbmd0aCA+IDQgfHwgdGhpcy5pbnB1dEVsLnZhbHVlLmNvbnRhaW5zKCcjJykpICkge1xuICAgICAgICB0aGlzLmlucHV0RWwudmFsdWUgPSB0aGlzLmlucHV0RWwudmFsdWUuc3Vic3RyaW5nKDEpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGhpcy5pbnB1dEVsLmFkZEV2ZW50TGlzdGVuZXIoJ3Bhc3RlJywgKGV2ZW50KSA9PiB7XG5cbiAgICAgIGlmICh0aGlzLmlucHV0RWwudmFsdWUgPT09IFwiQFwiKSB7XG4gICAgICAgIC8vIFByZXZlbnQgdGhlIHBhc3RlZCB0ZXh0IGZyb20gYmVpbmcgaW5zZXJ0ZWRcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICBcbiAgICAgICAgLy8gR2V0IHRoZSB0ZXh0IGZyb20gdGhlIGNsaXBib2FyZFxuICAgICAgICBjb25zdCB0ZXh0ID0gKGV2ZW50LmNsaXBib2FyZERhdGEgfHwgd2luZG93LmNsaXBib2FyZERhdGEpLmdldERhdGEoJ3RleHQnKTtcbiAgICBcbiAgICAgICAgLy8gQ2xlYXIgdGhlIGlucHV0IGFuZCBpbnNlcnQgdGhlIG5ldyB0ZXh0XG4gICAgICAgIHRoaXMuaW5wdXRFbC52YWx1ZSA9IHRleHQ7XG4gICAgICAgIHRoaXMuaW5wdXRFbC50cmlnZ2VyKFwiaW5wdXRcIik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvLyBQZXJmb3JtIGFjdGlvbiBvbiB0aGUgc2VsZWN0ZWQgc3VnZ2VzdGlvbi5cbiAgYXN5bmMgb25DaG9vc2VJdGVtKGNob29zZW5WYWx1ZTogTm90ZVdpdGhIZWFkZXIsIGV2dDogTW91c2VFdmVudCB8IEtleWJvYXJkRXZlbnQpIHtcbiAgICBpZiAoY2hvb3NlblZhbHVlLm5vdGVQYXRoLnN0YXJ0c1dpdGgoXCJAXCIpKSB7XG4gICAgICBuZXcgQWRkVGV4dFRvTm90ZXNGcm9tU3BlY2lmaWNUYWdNb2RhbCh0aGlzLmFwcCwgdGhpcy5saW5rVG9BZGQsIGNob29zZW5WYWx1ZS5ub3RlUGF0aC5yZXBsYWNlKC9eQC8sIFwiI1wiKSwgdGhpcy5kZXNjcmlwdGlvbiwgdGhpcy5pbnNlcnRGcm9tQmVnaW5uaW5nLCB0aGlzLnBvc3RBY3Rpb24pLm9wZW4oKVxuICAgIH0gZWxzZSB7XG4gICAgICBhZGRUZXh0VG9Ob3Rlcyh0aGlzLmxpbmtUb0FkZCwgY2hvb3NlblZhbHVlLm5vdGVQYXRoLCB0aGlzLmFwcCwgdGhpcy5pbnNlcnRGcm9tQmVnaW5uaW5nLCBjaG9vc2VuVmFsdWUuc3RhcnRMaW5lKVxuICAgICAgdGhpcy5wb3N0QWN0aW9uKClcbiAgICB9XG4gIH1cbn0iLCAiaW1wb3J0IHsgQXBwLCBDYWNoZWRNZXRhZGF0YSwgVEZpbGUgfSBmcm9tIFwib2JzaWRpYW5cIjtcbmltcG9ydCB7IE5vdGVXaXRoSGVhZGVyIH0gZnJvbSBcIi4vbm90ZVdpdGhIZWFkZXJcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIGdldEFsbEhlYWRlcnMoYXBwOiBBcHAsIGZpbGVMaXN0IDogc3RyaW5nW10pOiBOb3RlV2l0aEhlYWRlcltdIHtcbiAgICBjb25zdCByZXN1bHRMaXN0OiBOb3RlV2l0aEhlYWRlcltdID0gW107XG4gICAgZm9yIChjb25zdCBmaWxlUGF0aCBvZiBmaWxlTGlzdCkge1xuICAgICAgICBjb25zdCBmaWxlIDogVEZpbGUgPSBhcHAudmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKGZpbGVQYXRoKSBhcyBURmlsZVxuICAgICAgICBjb25zdCBmaWxlQ2FjaGUgOiBDYWNoZWRNZXRhZGF0YSB8IG51bGwgPSBhcHAubWV0YWRhdGFDYWNoZS5nZXRGaWxlQ2FjaGUoZmlsZSlcbiAgICAgICAgaWYgKCFmaWxlQ2FjaGUpIHtcblxuICAgICAgICB9IGVsc2UgaWYgKCFmaWxlQ2FjaGUuaGVhZGluZ3MpIHtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZmlsZUNhY2hlLmhlYWRpbmdzLmZvckVhY2goaCA9PiB7XG4gICAgICAgICAgICAgICAgcmVzdWx0TGlzdC5wdXNoKHtub3RlUGF0aDogZmlsZVBhdGgsIGhlYWRlcjogXCIjXCIgKyBoLmhlYWRpbmcsIHN0YXJ0TGluZTogaC5wb3NpdGlvbi5zdGFydC5saW5lLCBub3RlVHlwZTogbnVsbH0pXG4gICAgICAgICAgICB9KVxuICAgICAgICB9ICAgXG4gICAgfVxuICAgIHJldHVybiByZXN1bHRMaXN0XG59IiwgImltcG9ydCB7IEFwcCwgQ2FjaGVkTWV0YWRhdGEsIEZyb250TWF0dGVyQ2FjaGUgfSBmcm9tIFwib2JzaWRpYW5cIjtcblxuZXhwb3J0IGZ1bmN0aW9uIGdldFJlY2VudE5vdGVzKGFwcDogQXBwLCBsaW1pdDogbnVtYmVyKTogc3RyaW5nW10ge1xuICBjb25zdCByZWNlbnRWaWV3ZWROb3RlcyA9IGFwcC53b3Jrc3BhY2UuZ2V0TGFzdE9wZW5GaWxlcygpLmZpbHRlcihwYXRoID0+IGFwcC52YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgocGF0aCkgIT09IG51bGwpO1xuICByZXR1cm4gcmVjZW50Vmlld2VkTm90ZXMuc2xpY2UoMCwgTWF0aC5taW4obGltaXQsIHJlY2VudFZpZXdlZE5vdGVzLmxlbmd0aCkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0QWxsTm90ZXMoYXBwOiBBcHApOiBzdHJpbmdbXSB7XG4gIGNvbnN0IGZpbGVzID0gYXBwLnZhdWx0LmdldE1hcmtkb3duRmlsZXMoKTtcbiAgY29uc3QgYWxsTm90ZXMgPSBmaWxlcy5tYXAoKGZpbGUpID0+IGZpbGUucGF0aCk7XG4gIHJldHVybiBhbGxOb3Rlcztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEFsbE5vdGVzV2l0aG91dE1ldGFkYXRhKGFwcDogQXBwKTogc3RyaW5nW10ge1xuICBsZXQgZ2V0QWxsTm90ZXNXaXRob3V0TWV0YWRhdGE6IHN0cmluZ1tdID0gW107XG4gIGNvbnN0IGZpbGVzID0gYXBwLnZhdWx0LmdldE1hcmtkb3duRmlsZXMoKTtcbiAgZmlsZXMuZm9yRWFjaCgoZmlsZSkgPT4ge1xuICAgIGNvbnN0IGZpbGVDYWNoZSA6IENhY2hlZE1ldGFkYXRhIHwgbnVsbCA9IHRoaXMuYXBwLm1ldGFkYXRhQ2FjaGUuZ2V0RmlsZUNhY2hlKGZpbGUpXG4gICAgaWYgKGZpbGVDYWNoZSkge1xuICAgICAgY29uc3QgZnJvbnRtYXR0ZXIgOiBGcm9udE1hdHRlckNhY2hlIHwgdW5kZWZpbmVkID0gZmlsZUNhY2hlLmZyb250bWF0dGVyXG4gICAgICBpZiAoIWZyb250bWF0dGVyKSB7XG4gICAgICAgIGdldEFsbE5vdGVzV2l0aG91dE1ldGFkYXRhLnB1c2goZmlsZS5wYXRoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pXG4gIHJldHVybiBnZXRBbGxOb3Rlc1dpdGhvdXRNZXRhZGF0YTtcbn1cbiIsICJpbXBvcnQgeyBOYXZpZ2F0ZVRvTm90ZUZyb21UYWdNb2RhbCB9IGZyb20gXCJuYXZpZ2F0ZVRvTm90ZUZyb21UYWdNb2RhbFwiXG5pbXBvcnQgeyBBcHAsIEZ1enp5U3VnZ2VzdE1vZGFsLCBGdXp6eU1hdGNoLCBOb3RpY2UsIENhY2hlZE1ldGFkYXRhLCBwYXJzZUZyb250TWF0dGVyVGFncywgcGFyc2VGcm9udE1hdHRlckFsaWFzZXMsIFRGaWxlLCBNYXJrZG93blZpZXcsIFN1Z2dlc3RNb2RhbCB9IGZyb20gXCJvYnNpZGlhblwiXG5pbXBvcnQgeyBmaWxlc1doZXJlVGFnSXNVc2VkIH0gZnJvbSBcInNlbGZ1dGlsL2ZpbmROb3Rlc0Zyb21UYWdcIlxuaW1wb3J0IHsgZ2V0Tm90ZVR5cGUgfSBmcm9tIFwic2VsZnV0aWwvZ2V0VGFza1RhZ1wiXG5pbXBvcnQgeyBOb3RlV2l0aEhlYWRlciwgU0VQQVJBVE9SIH0gZnJvbSBcInNlbGZ1dGlsL25vdGVXaXRoSGVhZGVyXCJcblxuXG5jb25zdCBCQUNLX1RPX1NFTEVDVF9UQUcgPSBcIkJhY2sgdG8gc2VsZWN0IHRhZ1wiXG5jb25zdCBPUEVOX0lOX1NFQVJDSF9NT0RFID0gXCJPcGVuIGluIHNlYXJjaCBtb2RlXCJcblxuZXhwb3J0IGNsYXNzIE5hdmlnYXRlVG9Ob3RlRnJvbVNwZWNpZmljVGFnTW9kYWwgZXh0ZW5kcyBTdWdnZXN0TW9kYWw8Tm90ZVdpdGhIZWFkZXI+IHtcblxuICB0YWdUb0ZpbmQ6IHN0cmluZ1xuICBrZXlkb3duSGFuZGxlcjogKGV2ZW50OiBLZXlib2FyZEV2ZW50KSA9PiB2b2lkO1xuXG4gIGNvbnN0cnVjdG9yKGFwcDogQXBwLCB0YWdUb0ZpbmQ6IHN0cmluZylcbiAge1xuICAgIHN1cGVyKGFwcClcbiAgICB0aGlzLnRhZ1RvRmluZCA9IHRhZ1RvRmluZFxuICAgIHRoaXMuc2V0UGxhY2Vob2xkZXIoYFdoaWNoIG5vdGVzIHdpdGggdGFnICR7dGFnVG9GaW5kfSBkbyB5b3Ugd2FudCB0byBuYXZpZ2F0ZSB0bz9gKVxuICAgIHRoaXMuc2V0SW5zdHJ1Y3Rpb25zKFtcbiAgICAgIHtcbiAgICAgICAgY29tbWFuZDogXCJcIixcbiAgICAgICAgcHVycG9zZTogYFdoaWNoIG5vdGVzIHdpdGggdGFnICR7dGFnVG9GaW5kfSBkbyB5b3Ugd2FudCB0byBuYXZpZ2F0ZSB0bz9gXG4gICAgICB9XG4gICAgXSk7XG4gICAgdGhpcy5rZXlkb3duSGFuZGxlciA9IChldmVudDogS2V5Ym9hcmRFdmVudCkgPT4ge1xuICAgICAgLy9jb25zb2xlLmxvZyhcImN0cmwgXCIgKyBldmVudC5jdHJsS2V5KVxuICAgICAgLy9jb25zb2xlLmxvZyhcImFsdCBcIiArIGV2ZW50LmFsdEtleSlcbiAgICAgIC8vY29uc29sZS5sb2coXCJtZXRhIFwiICsgZXZlbnQubWV0YUtleSlcbiAgICAgIC8vY29uc29sZS5sb2coXCJzaGlmdCBcIiArIGV2ZW50LnNoaWZ0S2V5KVxuICAgICAgLy9jb25zb2xlLmxvZyhcImtleSBcIiArIGV2ZW50LmtleSlcbiAgICAgIC8vIENoZWNrIGlmIEN0cmwgKyBRIHdhcyBwcmVzc2VkXG4gICAgICBpZiAoZXZlbnQuY3RybEtleSAmJiBldmVudC5hbHRLZXkgJiYgZXZlbnQuc2hpZnRLZXkgJiYgZXZlbnQua2V5ID09PSAnOycpIHsgLy8gd2luZG93c1xuICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICB9IGVsc2UgaWYgKGV2ZW50LmN0cmxLZXkgJiYgZXZlbnQubWV0YUtleSAmJiBldmVudC5zaGlmdEtleSAmJiBldmVudC5rZXkgPT09ICc7JykgeyAvLyBtYWNvc1xuICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICB9IGVsc2UgaWYgKGV2ZW50Lm1ldGFLZXkgfHwgZXZlbnQuY3RybEtleSkge1xuICAgICAgICBjb25zdCBrZXkgPSBwYXJzZUludChldmVudC5rZXksIDEwKTtcbiAgICAgICAgaWYgKGtleSA+PSAxICYmIGtleSA8PSA5KSB7XG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTsgLy8gUHJldmVudCBkZWZhdWx0IGFjdGlvblxuICAgICAgICAgIHRoaXMuc2VsZWN0RWxlbWVudChrZXkgLSAxKTsgLy8gU2VsZWN0IHRoZSBlbGVtZW50IChpbmRleCBrZXkgLSAxKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vIExpc3RlbiBmb3Iga2V5ZG93biBldmVudHMgYXQgdGhlIGRvY3VtZW50IGxldmVsXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMua2V5ZG93bkhhbmRsZXIpO1xuICB9XG5cbiAgc2VsZWN0RWxlbWVudChpbmRleDogbnVtYmVyKSB7XG4gICAgY29uc3QgZWxlbWVudHMgPSB0aGlzLnJlc3VsdENvbnRhaW5lckVsLnF1ZXJ5U2VsZWN0b3JBbGwoJy5zdWdnZXN0aW9uLWl0ZW0nKTtcbiAgICBpZiAoZWxlbWVudHMubGVuZ3RoID4gaW5kZXgpIHtcbiAgICAgIGNvbnN0IGVsZW1lbnQgPSBlbGVtZW50c1tpbmRleF0gYXMgSFRNTEVsZW1lbnQ7XG4gICAgICBlbGVtZW50LmNsaWNrKCk7IC8vIFNpbXVsYXRlIGEgY2xpY2sgdG8gc2VsZWN0IHRoZSBlbGVtZW50XG4gICAgfVxuICB9XG5cbiAgb25DbG9zZSgpIHtcbiAgICBzdXBlci5vbkNsb3NlKCk7XG4gICAgLy8gU3RvcCBsaXN0ZW5pbmcgZm9yIGtleWRvd24gZXZlbnRzIHdoZW4gdGhlIG1vZGFsIGlzIGNsb3NlZFxuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLmtleWRvd25IYW5kbGVyKTtcbiAgfVxuYXN5bmMgZ2V0U3VnZ2VzdGlvbnMocXVlcnk6IHN0cmluZyk6IFByb21pc2U8Tm90ZVdpdGhIZWFkZXJbXT4ge1xuICBjb25zdCBmaWxlUGF0aHM6IHN0cmluZ1tdID0gZmlsZXNXaGVyZVRhZ0lzVXNlZCh0aGlzLnRhZ1RvRmluZCk7XG4gIGNvbnN0IGhlYWRlcnM6IE5vdGVXaXRoSGVhZGVyW10gPSBbXTtcbiAgY29uc3QgbGluZXM6IE5vdGVXaXRoSGVhZGVyW10gPSBbXTtcblxuICBjb25zdCBpc0FjdGlvblRhZyA9ICEvXiNbYS16XVxcL1thLXpdXFwvW2Etel0kLy50ZXN0KHRoaXMudGFnVG9GaW5kKVxuICAmJiAhL14jW2Etel1cXC9bYS16XSQvLnRlc3QodGhpcy50YWdUb0ZpbmQpXG4gICYmICEvXiNbYS16XSQvLnRlc3QodGhpcy50YWdUb0ZpbmQpXG5cbiAgY29uc3QgcmVhZFByb21pc2VzID0gZmlsZVBhdGhzLm1hcChhc3luYyAoZmlsZVBhdGgpID0+IHtcbiAgICBjb25zdCBmaWxlID0gdGhpcy5hcHAudmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKGZpbGVQYXRoKSBhcyBURmlsZTtcbiAgICBjb25zdCBmaWxlQ2FjaGUgPSB0aGlzLmFwcC5tZXRhZGF0YUNhY2hlLmdldEZpbGVDYWNoZShmaWxlKTtcbiAgICBpZiAoIWZpbGVDYWNoZSkgcmV0dXJuO1xuXG4gICAgaWYgKGlzQWN0aW9uVGFnKSB7XG4gICAgICBpZiAoZmlsZUNhY2hlLnRhZ3MpIHtcbiAgICAgICAgY29uc3QgY29udGVudCA9IGF3YWl0IHRoaXMuYXBwLnZhdWx0LnJlYWQoZmlsZSk7XG4gICAgICAgIGNvbnN0IGZpbGVMaW5lcyA9IGNvbnRlbnQuc3BsaXQoJ1xcbicpO1xuICAgICAgICBmb3IgKGNvbnN0IHRhZyBvZiBmaWxlQ2FjaGUudGFncykge1xuICAgICAgICAgIGlmICh0YWcudGFnID09PSB0aGlzLnRhZ1RvRmluZCkge1xuICAgICAgICAgICAgY29uc3QgaGVhZGluZyA9IHRoaXMuZ2V0SGVhZGluZ0ZvckxpbmUoZmlsZUNhY2hlLCB0YWcucG9zaXRpb24uc3RhcnQubGluZSk7XG4gICAgICAgICAgICBjb25zdCBsaW5lQ29udGVudCA9IGZpbGVMaW5lc1t0YWcucG9zaXRpb24uc3RhcnQubGluZV0udHJpbSgpO1xuICAgICAgICAgICAgaWYgKChmaWxlUGF0aCArIGxpbmVDb250ZW50KS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKHF1ZXJ5LnRvTG93ZXJDYXNlKCkpKVxuICAgICAgICAgICAgLy8gaWYgKHRoaXMuZnV6enlNYXRjaCgoZmlsZVBhdGggKyBsaW5lQ29udGVudCkudG9Mb3dlckNhc2UoKSwgcXVlcnkudG9Mb3dlckNhc2UoKSkpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGxpbmVzLnB1c2goe1xuICAgICAgICAgICAgICAgIG5vdGVQYXRoOiBmaWxlUGF0aCxcbiAgICAgICAgICAgICAgICBoZWFkZXI6IChoZWFkaW5nID8gaGVhZGluZyArIFwiXFxuICAgICBcIiA6IFwiXCIpICsgbGluZUNvbnRlbnQsXG4gICAgICAgICAgICAgICAgc3RhcnRMaW5lOiB0YWcucG9zaXRpb24uc3RhcnQubGluZSxcbiAgICAgICAgICAgICAgICBub3RlVHlwZTogbnVsbFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGZpbGVDYWNoZS5oZWFkaW5ncykge1xuICAgICAgICBmaWxlQ2FjaGUuaGVhZGluZ3MuZm9yRWFjaChoID0+IHtcbiAgICAgICAgICBoZWFkZXJzLnB1c2goe1xuICAgICAgICAgICAgbm90ZVBhdGg6IGZpbGVQYXRoLFxuICAgICAgICAgICAgaGVhZGVyOiBcIiNcIiArIGguaGVhZGluZyxcbiAgICAgICAgICAgIHN0YXJ0TGluZTogaC5wb3NpdGlvbi5zdGFydC5saW5lLFxuICAgICAgICAgICAgbm90ZVR5cGU6IG51bGxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICBhd2FpdCBQcm9taXNlLmFsbChyZWFkUHJvbWlzZXMpO1xuXG4gIGlmIChpc0FjdGlvblRhZykge1xuICAgIHJldHVybiBbXG4gICAgICB7IG5vdGVQYXRoOiBCQUNLX1RPX1NFTEVDVF9UQUcsIGhlYWRlcjogXCJcIiwgc3RhcnRMaW5lOiAwLCBub3RlVHlwZTogbnVsbCB9LFxuICAgICAgeyBub3RlUGF0aDogT1BFTl9JTl9TRUFSQ0hfTU9ERSwgaGVhZGVyOiBcIlwiLCBzdGFydExpbmU6IDAsIG5vdGVUeXBlOiBudWxsIH0sXG4gICAgICAuLi5saW5lc1xuICAgIF07XG4gIH1cblxuICByZXR1cm4gW1xuICAgIHsgbm90ZVBhdGg6IEJBQ0tfVE9fU0VMRUNUX1RBRywgaGVhZGVyOiBcIlwiLCBzdGFydExpbmU6IDAsIG5vdGVUeXBlOiBudWxsIH0sXG4gICAgeyBub3RlUGF0aDogT1BFTl9JTl9TRUFSQ0hfTU9ERSwgaGVhZGVyOiBcIlwiLCBzdGFydExpbmU6IDAsIG5vdGVUeXBlOiBudWxsIH0sXG4gICAgLi4uZmlsZVBhdGhzLmZpbHRlcihmID0+IGYudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhxdWVyeS50b0xvd2VyQ2FzZSgpKSkubWFwKGYgPT4gKHsgbm90ZVBhdGg6IGYsIGhlYWRlcjogXCJcIiwgc3RhcnRMaW5lOiAwLCBub3RlVHlwZTogZ2V0Tm90ZVR5cGUoZikgfSkpLFxuICAgIC8vICAgIC4uLmZpbGVQYXRocy5maWx0ZXIoZiA9PiB0aGlzLmZ1enp5TWF0Y2goZi50b0xvd2VyQ2FzZSgpLCBxdWVyeS50b0xvd2VyQ2FzZSgpKSkubWFwKGYgPT4gKHsgbm90ZVBhdGg6IGYsIGhlYWRlcjogXCJcIiwgc3RhcnRMaW5lOiAwLCBub3RlVHlwZTogZ2V0Tm90ZVR5cGUoZikgfSkpLFxuICAgIHsgbm90ZVBhdGg6IFNFUEFSQVRPUiwgaGVhZGVyOiBcIlwiLCBzdGFydExpbmU6IDAsIG5vdGVUeXBlOiBudWxsIH0sXG4gICAgLi4uaGVhZGVyc1xuICBdXG59XG5cblxuZ2V0SGVhZGluZ0ZvckxpbmUoZmlsZUNhY2hlOiBDYWNoZWRNZXRhZGF0YSwgbGluZU51bWJlcjogbnVtYmVyKTogc3RyaW5nIHtcbiAgaWYgKCFmaWxlQ2FjaGUgfHwgIWZpbGVDYWNoZS5oZWFkaW5ncykge1xuICAgIHJldHVybiBcIlwiO1xuICB9XG5cbiAgY29uc3QgaGVhZGluZ3MgPSBmaWxlQ2FjaGUuaGVhZGluZ3M7XG4gIGxldCBjdXJyZW50SGVhZGluZyA9IFwiXCI7XG5cbiAgZm9yIChjb25zdCBoZWFkaW5nIG9mIGhlYWRpbmdzKSB7XG4gICAgaWYgKGhlYWRpbmcucG9zaXRpb24uc3RhcnQubGluZSA8PSBsaW5lTnVtYmVyKSB7XG4gICAgICBjdXJyZW50SGVhZGluZyA9IFwiIyBcIiArIGhlYWRpbmcuaGVhZGluZztcbiAgICB9IGVsc2Uge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGN1cnJlbnRIZWFkaW5nO1xufVxuXG5mdXp6eU1hdGNoKHN0cjogc3RyaW5nLCBwYXR0ZXJuOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgaWYgKCFwYXR0ZXJuKSByZXR1cm4gdHJ1ZTtcbiAgcGF0dGVybiA9IHBhdHRlcm4uc3BsaXQoJycpLnJlZHVjZSgoYSwgYikgPT4gYCR7YX0uKiR7Yn1gKTtcbiAgcmV0dXJuIG5ldyBSZWdFeHAocGF0dGVybikudGVzdChzdHIpO1xufVxuXG4gIGdldEl0ZW1UZXh0KHBhdGg6IE5vdGVXaXRoSGVhZGVyKTogc3RyaW5nIHtcbiAgICByZXR1cm4gcGF0aC5ub3RlUGF0aCArIHBhdGguaGVhZGVyO1xuICB9XG5cbiAgLy8gUmVuZGVycyBlYWNoIHN1Z2dlc3Rpb24gaXRlbS5cbiAgLy9yZW5kZXJTdWdnZXN0aW9uKHBhdGg6IEZ1enp5TWF0Y2g8Tm90ZVdpdGhIZWFkZXI+LCBlbDogSFRNTEVsZW1lbnQpIHtcbiAgICByZW5kZXJTdWdnZXN0aW9uKGl0ZW06IE5vdGVXaXRoSGVhZGVyLCBlbDogSFRNTEVsZW1lbnQpIHtcbiAgICAvL2NvbnN0IGl0ZW06IE5vdGVXaXRoSGVhZGVyID0gcGF0aC5pdGVtXG4gICAgY29uc3QgcGF0aEl0ZW06IHN0cmluZyA9IGl0ZW0ubm90ZVBhdGhcbiAgICBsZXQgcHJlZml4ID0gaXRlbS5ub3RlVHlwZSA/IChpdGVtLm5vdGVUeXBlLnByZWZpeCA/IGl0ZW0ubm90ZVR5cGUucHJlZml4ICsgXCIgXCIgOiBcIlwiKSA6IFwiXCJcbiAgICAvKlxuICAgIGxldCBwcmVmaXggPSBcIlwiXG4gICAgaWYgKHBhdGhJdGVtICE9PSBCQUNLX1RPX1NFTEVDVF9UQUcgJiYgcGF0aEl0ZW0gIT09IE9QRU5fSU5fU0VBUkNIX01PREUpIHtcbiAgICAgIGNvbnN0IG5vdGVUeXBlID0gZ2V0Tm90ZVR5cGUocGF0aEl0ZW0pXG4gICAgICBwcmVmaXggPSBub3RlVHlwZSA/IG5vdGVUeXBlLnByZWZpeCArIFwiIFwiIDogXCJcIlxuICAgIH1cbiAgICAqL1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5yZXN1bHRDb250YWluZXJFbC5xdWVyeVNlbGVjdG9yQWxsKCcuc3VnZ2VzdGlvbi1pdGVtJykubGVuZ3RoO1xuICAgIGNvbnN0IGl0ZW1JbmRleCA9IGluZGV4IDwgMTAgPyBpbmRleCArIFwiLiBcIiA6IFwiICAgIFwiXG4gICAgZWwuY3JlYXRlRWwoXCJkaXZcIiwgeyB0ZXh0OiBpdGVtSW5kZXggKyBwcmVmaXggKyBwYXRoSXRlbSB9KTtcbiAgICAvL2lmIChwYXRoLml0ZW0uaGVhZGVyLmxlbmd0aCA+IDApIHtcbiAgICBpZiAoaXRlbS5oZWFkZXIubGVuZ3RoID4gMCkge1xuICAgICAgZWwuY3JlYXRlRWwoXCJzbWFsbFwiLCB7IHRleHQ6IFwiICAgICBcIiArIGl0ZW0uaGVhZGVyfSlcbiAgICB9XG4gIH1cblxuICBvbkNob29zZVN1Z2dlc3Rpb24ocGF0aDogTm90ZVdpdGhIZWFkZXIsIGV2dDogTW91c2VFdmVudCB8IEtleWJvYXJkRXZlbnQpIHtcbiAgICBcbiAgLy8gUGVyZm9ybSBhY3Rpb24gb24gdGhlIHNlbGVjdGVkIHN1Z2dlc3Rpb24uXG4gIC8vb25DaG9vc2VJdGVtKHBhdGg6IE5vdGVXaXRoSGVhZGVyLCBldnQ6IE1vdXNlRXZlbnQgfCBLZXlib2FyZEV2ZW50KSB7XG4gICAgaWYgKEJBQ0tfVE9fU0VMRUNUX1RBRyA9PT0gcGF0aC5ub3RlUGF0aCkge1xuICAgICAgbmV3IE5hdmlnYXRlVG9Ob3RlRnJvbVRhZ01vZGFsKHRoaXMuYXBwKS5vcGVuKClcbiAgICB9IGVsc2UgaWYgKE9QRU5fSU5fU0VBUkNIX01PREUgPT09IHBhdGgubm90ZVBhdGgpIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnkgKi9cblx0XHRcdFx0Y29uc3Qgc2VhcmNoUGx1Z2luID0gKFxuXHRcdFx0XHRcdHRoaXMuYXBwIGFzIGFueVxuXHRcdFx0XHQpLmludGVybmFsUGx1Z2lucy5nZXRQbHVnaW5CeUlkKFwiZ2xvYmFsLXNlYXJjaFwiKTtcblx0XHRcdFx0LyogZXNsaW50LWVuYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55ICovXG5cdFx0XHRcdGNvbnN0IHNlYXJjaCA9IHNlYXJjaFBsdWdpbiAmJiBzZWFyY2hQbHVnaW4uaW5zdGFuY2U7XG4gICAgICAgIGNvbnN0IGRlZmF1bHRUYWdTZWFyY2hTdHJpbmcgPSBgdGFnOiR7dGhpcy50YWdUb0ZpbmR9YDtcbiAgICAgICAgc2VhcmNoLm9wZW5HbG9iYWxTZWFyY2goZGVmYXVsdFRhZ1NlYXJjaFN0cmluZyk7XG4gICAgfSBlbHNlIGlmIChTRVBBUkFUT1IgPT09IHBhdGgubm90ZVBhdGgpIHtcbiAgICAgIC8vIGRvIG5vdGhpbmdcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgeyB2YXVsdCwgd29ya3NwYWNlIH0gPSB0aGlzLmFwcDtcbiAgICAgIGNvbnN0IGxlYWYgPSB3b3Jrc3BhY2UuZ2V0TGVhZihmYWxzZSk7XG4gICAgICBQcm9taXNlLnJlc29sdmUoKVxuICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgIHJldHVybiBsZWFmLm9wZW5GaWxlKHZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aChwYXRoLm5vdGVQYXRoKSBhcyBURmlsZSwgeyBhY3RpdmUgOiB0cnVlIH0pO1xuICAgICAgICAgIFxuICAgICAgfSlcbiAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgY29uc3QgbWFya2Rvd25WaWV3ID0gYXBwLndvcmtzcGFjZS5nZXRBY3RpdmVWaWV3T2ZUeXBlKE1hcmtkb3duVmlldyk7XG4gICAgICAgIGNvbnN0IGVkaXRvciA9IG1hcmtkb3duVmlldz8uZWRpdG9yXG4gICAgICAgIGlmIChtYXJrZG93blZpZXcgPT0gbnVsbCB8fCBlZGl0b3IgPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgZXJyb3JSZWFzb24gPSBgZWRpdG9yIG9yIHZhbHVlICR7cGF0aC5ub3RlUGF0aH0gbm90IGV4aXN0LiBBYm9ydGluZy4uLmBcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvclJlYXNvbilcbiAgICAgICAgfVxuICAgICAgICBlZGl0b3Iuc2V0Q3Vyc29yKHtsaW5lOiBwYXRoLnN0YXJ0TGluZSwgY2g6IDB9KVxuICAgICAgICAgICAgLy8gc2Nyb2xsIHRoZSB2aWV3IHRvIHRoZSBjdXJzb3JcbiAgICAgICAgZWRpdG9yLnNjcm9sbEludG9WaWV3KHtmcm9tOiB7bGluZTogcGF0aC5zdGFydExpbmUsIGNoOiAwfSwgdG86IHtsaW5lOiBwYXRoLnN0YXJ0TGluZSwgY2g6IDB9fSwgdHJ1ZSlcbiAgICAgIH0pXG4gICAgfVxuICB9XG59IiwgImltcG9ydCB7IE5hdmlnYXRlVG9Ob3RlRnJvbVNwZWNpZmljVGFnTW9kYWwgfSBmcm9tIFwibmF2aWdhdGVUb05vdGVGcm9tU3BlY2lmaWNUYWdNb2RhbFwiO1xuaW1wb3J0IHsgQXBwLCBGdXp6eVN1Z2dlc3RNb2RhbCwgRnV6enlNYXRjaCwgZ2V0QWxsVGFncywgVEZpbGUsIE5vdGljZSwgTWFya2Rvd25WaWV3IH0gZnJvbSBcIm9ic2lkaWFuXCI7XG5pbXBvcnQgeyBnZXRBbGxUYWdzV2l0aEZpbHRlciB9IGZyb20gXCJzZWxmdXRpbC9nZXRBbGxOb3RlVGFnc1wiO1xuaW1wb3J0IHsgZ2V0QWxsTm90ZXMsIGdldFJlY2VudE5vdGVzIH0gZnJvbSBcInNlbGZ1dGlsL2dldFJlY2VudE5vdGVzXCI7XG5pbXBvcnQgeyBnZXROb3RlVHlwZSB9IGZyb20gXCJzZWxmdXRpbC9nZXRUYXNrVGFnXCI7XG5pbXBvcnQgeyBIZWFkaW5nIH0gZnJvbSBcInNlbGZ1dGlsL2hlYWRpbmdcIjtcblxuaW50ZXJmYWNlIE5vdGUge1xuICBzZWFyY2g6IHN0cmluZyxcbiAgc2Vjb25kYXJ5OiBzdHJpbmdcbiAgdHlwZTogc3RyaW5nXG59XG5cbmNvbnN0IG5vdGUgPSBcIm5vdGVcIlxuY29uc3QgaGlzdG9yeSA9IFwiaGlzdG9yeVwiXG5jb25zdCB0YWcgPSBcInRhZ1wiXG5jb25zdCBoZWFkaW5nID0gXCJoZWFkaW5nXCJcblxuZXhwb3J0IGNsYXNzIE5hdmlnYXRlVG9Ob3RlRnJvbVRhZ01vZGFsIGV4dGVuZHMgRnV6enlTdWdnZXN0TW9kYWw8Tm90ZT4ge1xuICBpdGVtczogTm90ZVtdXG4gIHRhc2tUeXBlOiBOb3RlXG4gIGtleWRvd25IYW5kbGVyOiAoZXZlbnQ6IEtleWJvYXJkRXZlbnQpID0+IHZvaWQ7XG5cbiAgY29uc3RydWN0b3IoYXBwOiBBcHApXG4gIHtcbiAgICBzdXBlcihhcHApXG4gICAgdGhpcy5zZXRQbGFjZWhvbGRlcihgV2hpY2ggbm90ZXMgd2l0aCB0YWdzIGRvIHlvdSB3YW50IHRvIG5hdmlnYXRlIHRvP2ApXG4gICAgdGhpcy5zZXRJbnN0cnVjdGlvbnMoW1xuICAgICAge1xuICAgICAgICBjb21tYW5kOiBcIlwiLFxuICAgICAgICBwdXJwb3NlOiBcIldoaWNoIG5vdGVzIHdpdGggdGFncyBkbyB5b3Ugd2FudCB0byBuYXZpZ2F0ZSB0bz9cIlxuICAgICAgfVxuICAgIF0pO1xuICAgIHRoaXMua2V5ZG93bkhhbmRsZXIgPSAoZXZlbnQ6IEtleWJvYXJkRXZlbnQpID0+IHtcbiAgICAgIC8vY29uc29sZS5sb2coXCJjdHJsIFwiICsgZXZlbnQuY3RybEtleSlcbiAgICAgIC8vY29uc29sZS5sb2coXCJhbHQgXCIgKyBldmVudC5hbHRLZXkpXG4gICAgICAvL2NvbnNvbGUubG9nKFwibWV0YSBcIiArIGV2ZW50Lm1ldGFLZXkpXG4gICAgICAvL2NvbnNvbGUubG9nKFwic2hpZnQgXCIgKyBldmVudC5zaGlmdEtleSlcbiAgICAgIC8vY29uc29sZS5sb2coXCJrZXkgXCIgKyBldmVudC5rZXkpXG4gICAgICAvLyBDaGVjayBpZiBDdHJsICsgUSB3YXMgcHJlc3NlZFxuICAgICAgaWYgKGV2ZW50LmN0cmxLZXkgJiYgZXZlbnQuYWx0S2V5ICYmIGV2ZW50LnNoaWZ0S2V5ICYmIGV2ZW50LmtleSA9PT0gJzsnKSB7IC8vIHdpbmRvd3NcbiAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgfSBlbHNlIGlmIChldmVudC5jdHJsS2V5ICYmIGV2ZW50Lm1ldGFLZXkgJiYgZXZlbnQuc2hpZnRLZXkgJiYgZXZlbnQua2V5ID09PSAnOycpIHsgLy8gbWFjb3NcbiAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgfSBlbHNlIGlmIChldmVudC5tZXRhS2V5IHx8IGV2ZW50LmN0cmxLZXkpIHtcbiAgICAgICAgY29uc3Qga2V5ID0gcGFyc2VJbnQoZXZlbnQua2V5LCAxMCk7XG4gICAgICAgIGlmIChrZXkgPj0gMSAmJiBrZXkgPD0gOSkge1xuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7IC8vIFByZXZlbnQgZGVmYXVsdCBhY3Rpb25cbiAgICAgICAgICB0aGlzLnNlbGVjdEVsZW1lbnQoa2V5IC0gMSk7IC8vIFNlbGVjdCB0aGUgZWxlbWVudCAoaW5kZXgga2V5IC0gMSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBMaXN0ZW4gZm9yIGtleWRvd24gZXZlbnRzIGF0IHRoZSBkb2N1bWVudCBsZXZlbFxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLmtleWRvd25IYW5kbGVyKTtcbiAgICB0aGlzLml0ZW1zID0gdGhpcy5wcmVwYXJlSXRlbXMoKVxuICB9XG5cbiAgc2VsZWN0RWxlbWVudChpbmRleDogbnVtYmVyKSB7XG4gICAgY29uc3QgZWxlbWVudHMgPSB0aGlzLnJlc3VsdENvbnRhaW5lckVsLnF1ZXJ5U2VsZWN0b3JBbGwoJy5zdWdnZXN0aW9uLWl0ZW0nKTtcbiAgICBpZiAoZWxlbWVudHMubGVuZ3RoID4gaW5kZXgpIHtcbiAgICAgIGNvbnN0IGVsZW1lbnQgPSBlbGVtZW50c1tpbmRleF0gYXMgSFRNTEVsZW1lbnQ7XG4gICAgICBlbGVtZW50LmNsaWNrKCk7IC8vIFNpbXVsYXRlIGEgY2xpY2sgdG8gc2VsZWN0IHRoZSBlbGVtZW50XG4gICAgfVxuICB9XG5cbiAgb25DbG9zZSgpIHtcbiAgICBzdXBlci5vbkNsb3NlKCk7XG4gICAgLy8gU3RvcCBsaXN0ZW5pbmcgZm9yIGtleWRvd24gZXZlbnRzIHdoZW4gdGhlIG1vZGFsIGlzIGNsb3NlZFxuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLmtleWRvd25IYW5kbGVyKTtcbiAgfVxuXG4gIGdldEl0ZW1zKCkgOiBOb3RlW10ge1xuICAgIHJldHVybiB0aGlzLml0ZW1zXG4gIH1cblxuICBwcmVwYXJlSXRlbXMoKSA6IE5vdGVbXSB7XG4gICAgY29uc3QgYWxsTm90ZXMgPSBnZXRBbGxOb3Rlcyh0aGlzLmFwcClcbiAgICBsZXQgaGVhZGluZ3M6IEhlYWRpbmdbXSA9IFtdXG4gICAgYWxsTm90ZXMuZm9yRWFjaChuID0+IHtcbiAgICAgIGNvbnN0IGZpbGUgPSB0aGlzLmFwcC52YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgobikgYXMgVEZpbGVcbiAgICAgIGNvbnN0IGZpbGVDYWNoZSA9IHRoaXMuYXBwLm1ldGFkYXRhQ2FjaGUuZ2V0RmlsZUNhY2hlKGZpbGUpXG4gICAgICBpZiAoIWZpbGVDYWNoZSkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIGlmICghZmlsZUNhY2hlLmhlYWRpbmdzKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgZmlsZUNhY2hlLmhlYWRpbmdzLmZvckVhY2goaCA9PiB7XG4gICAgICAgIGhlYWRpbmdzLnB1c2goe25vdGU6IG4sIGhlYWRpbmc6IGguaGVhZGluZywgbGV2ZWw6IGgubGV2ZWwsIHN0YXJ0TGluZTogaC5wb3NpdGlvbi5zdGFydC5saW5lfSlcbiAgICAgIH0pXG4gICAgfSlcblx0XHRyZXR1cm4gW1xuICAgICAgLi4uZ2V0UmVjZW50Tm90ZXModGhpcy5hcHAsIDUwKS5tYXAobiA9PiB7XG4gICAgICAgIHJldHVybiB7c2VhcmNoOiBuLCBzZWNvbmRhcnk6IFwiXCIsIHR5cGU6IGhpc3Rvcnl9XG4gICAgICB9KSxcbiAgICAgIC4uLmdldEFsbFRhZ3NXaXRoRmlsdGVyKHRoaXMuYXBwKS5tYXAobiA9PiB7XG4gICAgICAgIHJldHVybiB7c2VhcmNoOiBuLnJlcGxhY2UoL14jLywgXCJAXCIpLCBzZWNvbmRhcnk6IFwiXCIsIHR5cGU6IHRhZ31cbiAgICAgIH0pLFxuICAgICAgLi4uYWxsTm90ZXMubWFwKG4gPT4ge1xuICAgICAgICByZXR1cm4ge3NlYXJjaDogbiwgc2Vjb25kYXJ5OiBcIlwiLCB0eXBlOiBub3RlfVxuICAgICAgfSksXG4gICAgICAuLi5oZWFkaW5ncy5tYXAoaCA9PiB7XG4gICAgICAgIHJldHVybiB7c2VhcmNoOiAnIycucmVwZWF0KGgubGV2ZWwpICsgXCIgXCIgKyBoLmhlYWRpbmcsIHNlY29uZGFyeTogaC5ub3RlLCB0eXBlOiBoZWFkaW5nfVxuICAgICAgfSlcbiAgICBdO1xuICB9XG5cbiAgZ2V0SXRlbVRleHQodmFsdWU6IE5vdGUpOiBzdHJpbmcge1xuICAgIHJldHVybiB2YWx1ZS5zZWFyY2g7XG4gIH1cblxuICAvLyBSZW5kZXJzIGVhY2ggc3VnZ2VzdGlvbiBpdGVtLlxuICByZW5kZXJTdWdnZXN0aW9uKHZhbHVlOiBGdXp6eU1hdGNoPE5vdGU+LCBlbDogSFRNTEVsZW1lbnQpIHtcbiAgICBjb25zdCBpdGVtID0gdmFsdWUuaXRlbVxuICAgIGxldCBwcmVmaXggPSBcIlwiXG4gICAgaWYgKGl0ZW0udHlwZSA9PT0gbm90ZSB8fCBpdGVtLnR5cGUgPT09IGhpc3RvcnkpIHtcbiAgICAgIGNvbnN0IG5vdGVUeXBlID0gZ2V0Tm90ZVR5cGUoaXRlbS5zZWFyY2gpXG4gICAgICBwcmVmaXggPSBub3RlVHlwZSA/IG5vdGVUeXBlLnByZWZpeCArIFwiIFwiIDogXCJcIlxuICAgIH1cbiAgICBjb25zdCBpbmRleCA9IHRoaXMucmVzdWx0Q29udGFpbmVyRWwucXVlcnlTZWxlY3RvckFsbCgnLnN1Z2dlc3Rpb24taXRlbScpLmxlbmd0aDtcbiAgICBjb25zdCBpdGVtSW5kZXggPSBpbmRleCA8IDEwID8gaW5kZXggKyBcIi4gXCIgOiBcIiAgICBcIlxuICAgIGVsLmNyZWF0ZUVsKFwiZGl2XCIsIHsgdGV4dDogaXRlbUluZGV4ICsgcHJlZml4ICsgaXRlbS5zZWFyY2ggfSk7XG4gICAgZWwuY3JlYXRlRWwoXCJzbWFsbFwiLCB7IHRleHQ6IFwiICAgICBcIiArIGl0ZW0udHlwZSArIFwiIFwiICsgaXRlbS5zZWNvbmRhcnkgfSk7XG4gIH1cblxuICBvbk9wZW4oKSB7XG4gICAgc3VwZXIub25PcGVuKCk7XG4gICAgdGhpcy5pbnB1dEVsLnZhbHVlID0gXCJAXCI7XG4gICAgdGhpcy5pbnB1dEVsLnRyaWdnZXIoXCJpbnB1dFwiKTtcblxuICAgIHRoaXMuaW5wdXRFbC5hZGRFdmVudExpc3RlbmVyKCdpbnB1dCcsICgpID0+IHtcbiAgICAgIGlmICh0aGlzLmlucHV0RWwudmFsdWUuc3RhcnRzV2l0aCgnQCcpICYmICh0aGlzLmlucHV0RWwudmFsdWUubGVuZ3RoID4gNCB8fCB0aGlzLmlucHV0RWwudmFsdWUuY29udGFpbnMoJyMnKSkgKSB7XG4gICAgICAgIHRoaXMuaW5wdXRFbC52YWx1ZSA9IHRoaXMuaW5wdXRFbC52YWx1ZS5zdWJzdHJpbmcoMSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0aGlzLmlucHV0RWwuYWRkRXZlbnRMaXN0ZW5lcigncGFzdGUnLCAoZXZlbnQpID0+IHtcblxuICAgICAgaWYgKHRoaXMuaW5wdXRFbC52YWx1ZSA9PT0gXCJAXCIpIHtcbiAgICAgICAgLy8gUHJldmVudCB0aGUgcGFzdGVkIHRleHQgZnJvbSBiZWluZyBpbnNlcnRlZFxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIFxuICAgICAgICAvLyBHZXQgdGhlIHRleHQgZnJvbSB0aGUgY2xpcGJvYXJkXG4gICAgICAgIGNvbnN0IHRleHQgPSAoZXZlbnQuY2xpcGJvYXJkRGF0YSB8fCB3aW5kb3cuY2xpcGJvYXJkRGF0YSkuZ2V0RGF0YSgndGV4dCcpO1xuICAgIFxuICAgICAgICAvLyBDbGVhciB0aGUgaW5wdXQgYW5kIGluc2VydCB0aGUgbmV3IHRleHRcbiAgICAgICAgdGhpcy5pbnB1dEVsLnZhbHVlID0gdGV4dDtcbiAgICAgICAgdGhpcy5pbnB1dEVsLnRyaWdnZXIoXCJpbnB1dFwiKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8vIFBlcmZvcm0gYWN0aW9uIG9uIHRoZSBzZWxlY3RlZCBzdWdnZXN0aW9uLlxuICBhc3luYyBvbkNob29zZUl0ZW0oY2hvb3NlblZhbHVlOiBOb3RlLCBldnQ6IE1vdXNlRXZlbnQgfCBLZXlib2FyZEV2ZW50KSB7XG4gICAgaWYgKGNob29zZW5WYWx1ZS50eXBlID09IHRhZykge1xuICAgICAgbmV3IE5hdmlnYXRlVG9Ob3RlRnJvbVNwZWNpZmljVGFnTW9kYWwodGhpcy5hcHAsIGNob29zZW5WYWx1ZS5zZWFyY2gucmVwbGFjZShcIkBcIiwgXCIjXCIpKS5vcGVuKClcbiAgICB9IGVsc2UgaWYgKGNob29zZW5WYWx1ZS50eXBlID09IG5vdGUgfHwgY2hvb3NlblZhbHVlLnR5cGUgPT0gaGlzdG9yeSkge1xuICAgICAgY29uc3QgeyB2YXVsdCwgd29ya3NwYWNlIH0gPSB0aGlzLmFwcDtcbiAgICAgIGNvbnN0IGxlYWYgPSB3b3Jrc3BhY2UuZ2V0TGVhZihmYWxzZSk7XG4gICAgICBQcm9taXNlLnJlc29sdmUoKVxuICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgIHJldHVybiBsZWFmLm9wZW5GaWxlKHZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aChjaG9vc2VuVmFsdWUuc2VhcmNoKSBhcyBURmlsZSwgeyBhY3RpdmUgOiB0cnVlIH0pO1xuICAgICAgfSlcbiAgICB9IGVsc2UgaWYgKGNob29zZW5WYWx1ZS50eXBlID09IGhlYWRpbmcpIHtcbiAgICAgIGNvbnN0IHsgdmF1bHQsIHdvcmtzcGFjZSB9ID0gdGhpcy5hcHA7XG4gICAgICBjb25zdCBsZWFmID0gd29ya3NwYWNlLmdldExlYWYoZmFsc2UpO1xuICAgICAgUHJvbWlzZS5yZXNvbHZlKClcbiAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICByZXR1cm4gbGVhZi5vcGVuRmlsZSh2YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgoY2hvb3NlblZhbHVlLnNlY29uZGFyeSkgYXMgVEZpbGUsIHsgYWN0aXZlIDogdHJ1ZSB9KTtcbiAgICAgIH0pXG4gICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgIGNvbnN0IG1hcmtkb3duVmlldyA9IGFwcC53b3Jrc3BhY2UuZ2V0QWN0aXZlVmlld09mVHlwZShNYXJrZG93blZpZXcpO1xuICAgICAgICBjb25zdCBlZGl0b3IgPSBtYXJrZG93blZpZXc/LmVkaXRvclxuICAgICAgICBpZiAobWFya2Rvd25WaWV3ID09IG51bGwgfHwgZWRpdG9yID09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yUmVhc29uID0gYGVkaXRvciBvciB2YWx1ZSAke2Nob29zZW5WYWx1ZS5zZWNvbmRhcnl9IG5vdCBleGlzdC4gQWJvcnRpbmcuLi5gXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3JSZWFzb24pXG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdG90YWxMaW5lTnVtID0gZWRpdG9yLmxpbmVDb3VudCgpXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdG90YWxMaW5lTnVtOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBsaW5lID0gZWRpdG9yLmdldExpbmUoaSlcbiAgICAgICAgICBpZiAobGluZSA9PSBjaG9vc2VuVmFsdWUuc2VhcmNoKSB7XG4gICAgICAgICAgICBlZGl0b3Iuc2V0Q3Vyc29yKHtsaW5lOiBpLCBjaDogMH0pXG4gICAgICAgICAgICAvLyBzY3JvbGwgdGhlIHZpZXcgdG8gdGhlIGN1cnNvclxuICAgICAgICAgICAgZWRpdG9yLnNjcm9sbEludG9WaWV3KHtmcm9tOiB7bGluZTogaSwgY2g6IDB9LCB0bzoge2xpbmU6IGksIGNoOiAwfX0sIHRydWUpXG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICB9XG59IiwgImltcG9ydCB7IEVkaXRvciwgRWRpdG9yU2VsZWN0aW9uIH0gZnJvbSBcIm9ic2lkaWFuXCJcblxuZXhwb3J0IGZ1bmN0aW9uIGV4cG9ydEN1cnJlbnRTZWxlY3Rpb24oZWRpdG9yOiBFZGl0b3IpOiBzdHJpbmcge1xuICAgIGxldCB0ZXh0ID0gXCJcIlxuICAgIGNvbnN0IGxpc3RTZWxlY3Rpb25zOiBFZGl0b3JTZWxlY3Rpb25bXSA9IGVkaXRvci5saXN0U2VsZWN0aW9ucygpXG4gICAgbGlzdFNlbGVjdGlvbnMuZm9yRWFjaChsaXN0U2VsZWN0aW9uID0+IHtcbiAgICAgICAgY29uc3QgYSA9IGxpc3RTZWxlY3Rpb24uaGVhZC5saW5lXG4gICAgICAgIGNvbnN0IGIgPSBsaXN0U2VsZWN0aW9uLmFuY2hvci5saW5lXG4gICAgICAgIGNvbnN0IGZyb21MaW5lTnVtID0gYiA+IGEgPyBhIDogYlxuICAgICAgICBjb25zdCB0b0xpbmVOdW0gPSBiID4gYSA/IGIgOiBhXG4gICAgICAgIGZvciAobGV0IGkgPSBmcm9tTGluZU51bTsgaSA8PSB0b0xpbmVOdW07IGkrKykge1xuICAgICAgICAgICAgY29uc3QgbGluZSA9IGVkaXRvci5nZXRMaW5lKGkpXG4gICAgICAgICAgICB0ZXh0ICs9IGxpbmUgKyBcIlxcblwiXG4gICAgICAgIH1cbiAgICB9KVxuICAgIHJldHVybiB0ZXh0LnJlcGxhY2UoL1xcbiQvLCBcIlwiKVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFNlbGVjdGlvblJhbmdlIHtcbiAgICBmcm9tTGluZU51bTogbnVtYmVyXG4gICAgZnJvbUNoOiBudW1iZXJcbiAgICB0b0xpbmVOdW06IG51bWJlclxuICAgIHRvQ2g6IG51bWJlclxufVxuXG4vLyBhc3N1bWUgMSBzZWxlY3Rpb25cbmV4cG9ydCBmdW5jdGlvbiBnZXRDdXJyZW50U2VsZWN0aW9uTGluZU51bWJlcihlZGl0b3I6IEVkaXRvcik6IFNlbGVjdGlvblJhbmdlIHtcbiAgICBsZXQgdGV4dCA9IFwiXCJcbiAgICBsZXQgZnJvbUxpbmVOdW0gPSAwXG4gICAgbGV0IGZyb21DaCA9IDBcbiAgICBsZXQgdG9MaW5lTnVtID0gMFxuICAgIGxldCB0b0NoID0gMFxuICAgIGNvbnN0IGxpc3RTZWxlY3Rpb25zOiBFZGl0b3JTZWxlY3Rpb25bXSA9IGVkaXRvci5saXN0U2VsZWN0aW9ucygpXG4gICAgbGlzdFNlbGVjdGlvbnMuZm9yRWFjaChsaXN0U2VsZWN0aW9uID0+IHtcbiAgICAgICAgY29uc3QgYSA9IGxpc3RTZWxlY3Rpb24uaGVhZC5saW5lXG4gICAgICAgIGNvbnN0IGFjaCA9IGxpc3RTZWxlY3Rpb24uaGVhZC5jaFxuICAgICAgICBjb25zdCBiID0gbGlzdFNlbGVjdGlvbi5hbmNob3IubGluZVxuICAgICAgICBjb25zdCBiY2ggPSBsaXN0U2VsZWN0aW9uLmFuY2hvci5jaFxuICAgICAgICBmcm9tTGluZU51bSA9IGIgPiBhID8gYSA6IGJcbiAgICAgICAgZnJvbUNoID0gYiA+IGEgPyBhY2ggOiBiY2hcbiAgICAgICAgdG9MaW5lTnVtID0gYiA+IGEgPyBiIDogYVxuICAgICAgICB0b0NoID0gYiA+IGEgPyBiY2ggOiBhY2hcbiAgICB9KVxuICAgIHJldHVybiB7IGZyb21MaW5lTnVtLCBmcm9tQ2gsIHRvTGluZU51bSwgdG9DaCB9XG59IiwgImltcG9ydCB7IEVkaXRvciB9IGZyb20gXCJvYnNpZGlhblwiXG5cbmNvbnN0IHNraXBGcm9udE1hdHRlckZpZWxkOiBzdHJpbmdbXSA9IFtcblx0XCJmcmVldGltZXRhc2s6IFwiLFxuXHRcImV4cGVjdGVkdGltZTogXCIsXG5cdFwibW9kZTogXCIsXG5cdFwiZGF5czogXCIsXG5cdFwic2hvd2hlYWRlcmZvb3RlcjogXCIsXG5cdFwic2hvd3N0YXRlOiBcIixcblx0XCJzb3J0c3VicGFnZWZpbHRlcjogXCIsXG5cdFwidGhyb3VnaHR0cmVlOiBcIixcblx0XCJ1cmdlbnQ6IFwiLFxuXHRcImRpc3BsYXlhczogXCIsXG5cdFwic3RhcnRkYXRlOiBcIixcblx0XCJyZWFkd3JpdGVtb2RlOiBcIixcblx0XCJzaG93Q2hhbmRsZXJOb3c6IFwiLFxuXHRcImRlZXB3b3JrOiBcIixcblx0XCJleHBlY3RlZHRpbWU6IFwiLFxuXHRcInBhcnNlZGF0ZTogXCIsXG5cdFwidGlkc2NvcGU6IFwiLFxuXHRcImluc2VydHRvZG9hY3Rpb246IFwiLFxuXHRcIm9wdGlvbmFsOiBcIixcblx0XCJyZXBsYWNldG86IFwiLFxuXHRcImJhY2t1cHRpZGRsZXI6IFwiLFxuXHRcImRlYWRsaW5lOiBcIixcblx0XCJjYXB0aW9uOiBcIixcblx0XCJjb2xsZWN0aW9uOiBcIixcblx0XCJsaWJyYXJ5OiBcIixcblx0XCJsaWJyYXJ5X3ZlcnNpb246IFwiLFxuXHRcImR1bW15OiBcIixcblx0XCJ0aWROYW1lOiBcIixcblx0XCJjaHJvbmljbGVkYXRlOiBcIixcblx0XCJldmVudGRhdGU6IFwiLFxuXHRcImRhaWx5aGlnaGxpZ2h0OiBcIixcblx0XCJkaXNwbGF5Y2FyZG1vZGU6IFwiLFxuXHRcImRpc3BsYXltb2RlOiBcIixcblx0XCJudW1jb2w6IFwiLFxuXHRcImRhdGV5eXl5bW1kZDogXCIsXG5cdFwiZ3JhcGhkaXNwbGF5bW9kZTogXCIsXG5cdFwibWF4ZGVwdGg6IFwiLFxuXHRcImpvdXJuYWxkYXRlOiBcIixcblx0XCJ0aGlzQmlsbERhdGU6IFwiLFxuXHRcImxhc3RCaWxsRGF0ZTogXCIsXG5cdFwicm9vdHRpZGRsZXI6IFwiLFxuXHRcInllYXI6IFwiLFxuXHRcInRvOiBcIixcblx0XCJ0aWR0ZW1wbGF0ZTogXCIsXG5cdFwidGlkZGxlcm5hbWU6IFwiLFxuXHRcInRoZW1lOiBcIixcblx0XCJ0YWd2YWx1ZTogXCIsXG5cdFwic3VidGFza251bTogXCIsXG5cdFwicmVtb3ZldGFndmFsdWU6IFwiLFxuXHRcInJlY3VycmluZ2V2ZW50c3RhcnRkYXRlOiBcIixcblx0XCJyZWN1cnJpbmdldmVudGVuZGRhdGU6IFwiLFxuXHRcInBsdWdpbm5hbWU6IFwiLFxuXHRcInBpZDogXCIsXG5cdFwibWFjcm9uYW1lOiBcIixcblx0XCJsaW1pdDogXCIsXG5cdFwia2V5d29yZDogXCIsXG5cdFwia2V5d29yZHRtcDogXCIsXG5cdFwiZnJvbTogXCIsXG5cdFwiZGVwcmVjYXRlcmVhc29uOiBcIixcblx0XCJkZWVwd286IFwiLFxuXHRcImNvbG9yOiBcIixcblx0XCJyb3c6IFwiLFxuXHRcImNvbDogXCIsXG5cdFwiYm9va21hcmtlZDogXCIsXG5cdFwiYmxvY2tpbmdyZW1pbmRlcmRhdGU6IFwiLFxuXHRcImJhY2t1cDogXCJcbl1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlcGxhY2VUV1VzZWxlc3NWYWx1ZSh2YWx1ZTogc3RyaW5nKSA6IHN0cmluZyB7XG4gICAgcmV0dXJuIHZhbHVlXG4gICAgICAgIC5yZXBsYWNlKFwiIyMgPiBSZWZlcmVuY2VzXFxuXFxuLSBcXG5cXG5cIiwgXCJcIilcbiAgICAgICAgLnJlcGxhY2UoXCIjIyA+IEdvYWwgYW5kIFJlYXNvblxcblxcbi0gXFxuXFxuXCIsIFwiXCIpXG4gICAgICAgIC5yZXBsYWNlKFwiIyMgPiBEZWxpdmVyYWJsZSBTcGVjXFxuXFxuLSBcXG5cXG5cIiwgXCJcIilcbiAgICAgICAgLnJlcGxhY2UoXCIjIyA+IENvbmRpdG9uIG9mIGRvbmVcXG5cXG4tIFxcblxcblwiLCBcIlwiKVxuICAgICAgICAucmVwbGFjZShcIiMjID4gU3RlcFxcblxcbi0gXFxuXFxuXCIsIFwiXCIpXG4gICAgICAgIC5yZXBsYWNlKFwiIyMgPiBQcm9ncmVzc1xcblxcbi0gXFxuXFxuXCIsIFwiXCIpXG4gICAgICAgIC5yZXBsYWNlKFwiIyMgPiBSZXN1bHRzXFxuXFxuLSBcXG5cXG5cIiwgXCJcIilcbiAgICAgICAgLnJlcGxhY2UoXCIjIyA+IEV4cGVyaWVuY2VcXG5cXG4tIFxcblxcblwiLCBcIlwiKVxuICAgICAgICAucmVwbGFjZShcIiMjID4gUmVmZXJlbmNlc1xcblxcbi0gXFxuXFxuXCIsIFwiXCIpXG4gICAgICAgIC5yZXBsYWNlKFwiIyMgPiBSZXN1bHRzLCBTdGVwcyBhbmQgRXhwXFxuXFxuLSBcXG5cXG5cIiwgXCJcIilcbiAgICAgICAgLnJlcGxhY2UoXCIjIyA+IENoZWNrbGlzdFxcblxcblsgXSBcXG5cXG5cIiwgXCJcIilcbiAgICAgICAgLnJlcGxhY2UoXCIjIyA+IENhY2hlXFxuXFxuWyBdIFxcblxcblwiLCBcIlwiKVxuXG4gICAgICAgIC5yZXBsYWNlKFwiIyMgPiBTY2VuYXJpb1xcblxcbi0gXFxuXFxuXCIsIFwiXCIpXG4gICAgICAgIC5yZXBsYWNlKFwiIyMgPiBHb2FsXFxuXFxuLSBcXG5cXG5cIiwgXCJcIilcbiAgICAgICAgLnJlcGxhY2UoXCIjIyA+IEdvYWxcXG5cXG4qXFxuXFxuXCIsIFwiXCIpXG4gICAgICAgIC5yZXBsYWNlKFwiIyMgPiBEZWxpdmVyYWJsZSBTcGVjIC8gQ29uZGl0aW9uIG9mIERvbmVcXG5cXG4tIFxcblxcblwiLCBcIlwiKVxuICAgICAgICAucmVwbGFjZShcIiMjID4gUGxhbm5lZCBTdGVwXFxuXFxuI1xcblxcblwiLCBcIlwiKVxuICAgICAgICAucmVwbGFjZShcIiMjID4gQWN0dWFsIFN0ZXBcXG5cXG4xLiBcXG5cXG5cIiwgXCJcIilcbiAgICAgICAgLnJlcGxhY2UoXCIjIyA+IEFjdHVhbCBTdGVwXFxuXFxuMS4gIFxcblxcblwiLCBcIlwiKVxuICAgICAgICAucmVwbGFjZShcIiMjID4gUmVzdWx0XFxuXFxuLSBcXG5cXG5cIiwgXCJcIilcbiAgICAgICAgLnJlcGxhY2UoXCIjIyA+IEhvdyB0byBkbyBpdCBiZXR0ZXIgbmV4dCB0aW1lXFxuXFxuLSBcXG5cXG5cIiwgXCJcIilcbiAgICAgICAgLnJlcGxhY2UoXCIjIyA+IE5leHQgdGltZSBhY3Rpb25cXG5cXG4tIFxcblxcblwiLCBcIlwiKVxuICAgICAgICAvLy5yZXBsYWNlKC8tLS1bXFxuXXsyLH0tLS0vZywgXCItLS1cIilcbiAgICAgICAgXG4gICAgICAgIC5yZXBsYWNlKC9cXG5cXG5cXG4rL2csIFwiXFxuXFxuXCIpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzaG91bGRTa2lwRnJvbnRNYXR0ZXIobGluZTogc3RyaW5nKSA6IGJvb2xlYW4ge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2tpcEZyb250TWF0dGVyRmllbGQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGxpbmUuc3RhcnRzV2l0aChza2lwRnJvbnRNYXR0ZXJGaWVsZFtpXSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRQYXJlbnRMaW5lKHZhbHVlOiBzdHJpbmcpIHtcbiAgICBjb25zdCB2YWx1ZXMgPSB2YWx1ZS5zcGxpdChcIlxcblwiKVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGxpbmVDb250ZW50ID0gdmFsdWVzW2ldXG4gICAgICAgIGlmICgvXnBhcmVudFxcZCs6IC8udGVzdChsaW5lQ29udGVudCkgfHwgL15cXHQrLSBwYXJlbnRcXGQrOiAvLnRlc3QobGluZUNvbnRlbnQpKSB7XG4gICAgICAgICAgICByZXR1cm4gaVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAwXG59XG5cbmV4cG9ydCBmdW5jdGlvblx0dGlkeVVwRnJvbnRNYXR0ZXJvbkVkaXRvcihlZGl0b3I6IEVkaXRvcikge1xuICAgIGNvbnN0IHZhbHVlID0gZWRpdG9yLmdldFZhbHVlKClcbiAgICBjb25zdCBtb2RpZmllZFZhbHVlID0gdGlkeVVwRnJvbnRNYXR0ZXJPblZhbHVlKHZhbHVlKVxuICAgIGVkaXRvci5zZXRWYWx1ZShtb2RpZmllZFZhbHVlKVxufVxuXG4vKlxuZXhwb3J0IGZ1bmN0aW9uXHR0aWR5VXBGcm9udE1hdHRlck9uVmFsdWUodmFsdWU6IFN0cmluZykge1xuICAgIGNvbnN0IHZhbHVlczogc3RyaW5nW10gPSB2YWx1ZS5zcGxpdChcIlxcblwiKVxuICAgIGNvbnN0IGxpbmVDb3VudCA9IHZhbHVlcy5sZW5ndGhcblxuICAgIGxldCBmbSA9IFwiXCJcbiAgICBsZXQgYyA9IFwiXCJcbiAgICBsZXQgdGV4dCA9IFwiXCJcbiAgICBsZXQgaDNDb3VudCA9IDA7XG4gICAgbGV0IGNvbnRlbnQgPSBcIlwiXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lQ291bnQ7IGkrKykge1xuICAgICAgICBjb25zdCBsaW5lID0gdmFsdWVzW2ldXG4gICAgICAgIGlmIChoM0NvdW50ID09IDApIHtcbiAgICAgICAgICAgIGNvbnRlbnQgKz0gKGxpbmUgKyBcIlxcblwiKVxuICAgICAgICB9IGVsc2UgaWYgKGgzQ291bnQgPT0gMSkge1xuICAgICAgICAgICAgaWYgKHNob3VsZFNraXBGcm9udE1hdHRlcihsaW5lKSkge1xuICAgICAgICAgICAgICAgIC8vIGRvIG5vdGhpbmdcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoL15wYXJlbnRcXGQrOiAvLnRlc3QobGluZSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtb2RpZmllZExpbmUgPSBsaW5lLnJlcGxhY2UoL1xcLy9nLCBcIl9cIikucmVwbGFjZSgvXFw/L2csIFwiX1wiKS5yZXBsYWNlKC86L2csIFwiX1wiKS5yZXBsYWNlKC9eKHBhcmVudFxcZCspXyAvLCBcIiQxOiBcIilcbiAgICAgICAgICAgICAgICBmbSArPSAobW9kaWZpZWRMaW5lICsgXCJcXG5cIilcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobGluZS5zdGFydHNXaXRoKFwidGl0bGU6IFwiKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1vZGlmaWVkTGluZSA9IGxpbmUucmVwbGFjZSgvOi9nLCBcIl9cIikucmVwbGFjZSgvXnRpdGxlXyAvLCBcInRpdGxlOiBcIikucmVwbGFjZSgvXFwvL2csIFwiX1wiKS5yZXBsYWNlKC9cXD8vZywgXCJfXCIpXG4gICAgICAgICAgICAgICAgZm0gKz0gKG1vZGlmaWVkTGluZSArIFwiXFxuXCIpXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGxpbmUgPT09IFwidGFnczogW2V4Y2FsaWRyYXddXCIpe1xuICAgICAgICAgICAgICAgIGZtICs9IChsaW5lICsgXCJcXG5cIilcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobGluZS5zdGFydHNXaXRoKFwidGFnc3NzOiBcIikgfHwgbGluZS5zdGFydHNXaXRoKFwidGFnczogXCIpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYnJhY2tldFBhdHRlcm4gPSAvXFxbXFxbLio/XFxdXFxdL2c7XG5cbiAgICAgICAgICAgICAgICAvLyBGaW5kIGFsbCBicmFja2V0ZWQgaXRlbXNcbiAgICAgICAgICAgICAgICBjb25zdCBicmFja2V0ZWRJdGVtcyA9IGxpbmUubWF0Y2goYnJhY2tldFBhdHRlcm4pIHx8IFtdO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBicmFja2V0ZWQgaXRlbXMgZnJvbSB0aGUgaW5wdXQgc3RyaW5nIHRvIGRlYWwgd2l0aCB0aGUgcmVtYWluaW5nXG4gICAgICAgICAgICAgICAgY29uc3QgcmVtYWluaW5nU3RyaW5nID0gbGluZS5yZXBsYWNlKGJyYWNrZXRQYXR0ZXJuLCAnJykudHJpbSgpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vIFNwbGl0IHRoZSByZW1haW5pbmcgc3RyaW5nIGJ5IHNwYWNlcyB0byBnZXQgdGhlIGluZGl2aWR1YWwgd29yZHNcbiAgICAgICAgICAgICAgICBjb25zdCByZW1haW5pbmdJdGVtcyA9IHJlbWFpbmluZ1N0cmluZy5zcGxpdCgvXFxzKy8pLmZpbHRlcihpdGVtID0+IGl0ZW0pO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vIENvbWJpbmUgdGhlIGJyYWNrZXRlZCBpdGVtcyBhbmQgdGhlIGluZGl2aWR1YWwgd29yZHMgaW50byBvbmUgYXJyYXlcbiAgICAgICAgICAgICAgICBjb25zdCBmbXRhZ3NzcyA9IFsuLi5icmFja2V0ZWRJdGVtcywgLi4ucmVtYWluaW5nSXRlbXNdO1xuXG4gICAgICAgICAgICAgICAgbGV0IHBhcmVudCA6IHN0cmluZ1tdID0gW11cbiAgICAgICAgICAgICAgICBsZXQgdGFnc3NzIDogc3RyaW5nW10gPSBbXVxuICAgICAgICAgICAgICAgIGxldCBza2lwcyA6IHN0cmluZ1tdPSBbXVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGZtdGFnc3NzLmZvckVhY2godGFnID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGFnID0gdGFnLnRyaW0oKVxuICAgICAgICAgICAgICAgICAgICAvLyBbW2V2ZW50IG5dXSAvIFtbZXZlbnQgd11dIC8gcmVnZXggb2YgW1syMDIyMDcxNyBKb3VybmFsIChXZWVrIDI4IFN1bildXTogcHV0IGluIHNraXBzXG4gICAgICAgICAgICAgICAgICAgIC8vIFtbMjAyMjA3MjEgSm91cm5hbCAoV2VlayAyOSBUaHUpXV1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhZyA9PT0gXCJbWy5IZWFkZXIgU2hvcnRjdXRdXVwiIHx8IHRhZyA9PT0gXCJbWy5DdXJyZW50IFByb2plY3RdXVwiIHx8IHRhZyA9PT0gXCJjb25jZXB0XCIgfHwgdGFnID09PSBcInNwYWNlXCIgfHwgdGFnID09PSBcInByb2JsZW1cIiB8fCB0YWcgPT09IFwidGFnc3NzOlwiIHx8IHRhZyA9PT0gXCJ0YWdzOlwiIHx8IHRhZyA9PT0gXCJbW2V2ZW50IG5dXVwiIHx8IHRhZyA9PT0gXCJbW2V2ZW50IHddXVwiXG4gICAgICAgICAgICAgICAgICAgICAgICB8fCAvXFxbXFxbXFxkezh9IEpvdXJuYWwgXFwoV2VlayBcXGQrIFtBLVphLXpdezN9XFwpXFxdXFxdLy50ZXN0KHRhZykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNraXBzLnB1c2godGFnKVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRhZyA9PT0gXCJwZXJtdGFza1wiIHx8IFx0dGFnID09PSBcIk5cIiB8fCB0YWcgPT09IFwiV1wiIHx8IHRhZyA9PT0gXCJub3dcIiB8fCB0YWcgPT09IFwibGF0ZXJcIiB8fCB0YWcgPT09IFwid2FpdGluZ1wiIHx8IHRhZyA9PT0gXCJkb25lXCIgfHwgdGFnID09PSBcImFyY2hpdmVcIiB8fCB0YWcgPT09IFwiYWN0aW9uXCIgfHwgdGFnID09PSBcInRhc2tcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFnc3NzLnB1c2godGFnLnJlcGxhY2UoXCJbW1wiLCBcIlwiKS5yZXBsYWNlKFwiXV1cIiwgXCJcIikpXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGFnID09PSBcInByZWJsb2dcIiB8fCB0YWcgPT09IFwicHJlcHJlYmxvZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnQucHVzaChcIltbQmxvZyBfIFBvc3RdXVwiKVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50LnB1c2godGFnKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAvL25ldyBOb3RpY2Uoc2tpcHMuam9pbihcIlxcblwiKSlcbiAgICAgICAgICAgICAgICBsZXQgbW9kaWZpZWRMaW5lID0gXCJcIlxuICAgICAgICAgICAgICAgIGlmICh0YWdzc3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBtb2RpZmllZExpbmUgKz0gXCJ0YWdzc3M6IFwiICsgdGFnc3NzLmpvaW4oXCIgXCIpICsgXCJcXG5cIlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgcGFyZW50Q291bnQgPSAxXG4gICAgICAgICAgICAgICAgaWYgKHBhcmVudC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHVuaXF1ZVBhcmVudCA9IEFycmF5LmZyb20obmV3IFNldChwYXJlbnQpKTtcbiAgICAgICAgICAgICAgICAgICAgdW5pcXVlUGFyZW50LmZvckVhY2gocCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocC5zdGFydHNXaXRoKFwiW1tcIikgJiYgcC5lbmRzV2l0aChcIl1dXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kaWZpZWRMaW5lICs9IFwicGFyZW50XCIgKyBwYXJlbnRDb3VudCArIFwiOiBcXFwiXCIgKyBwLnJlcGxhY2UoXCI6XCIsIFwiX1wiKSArIFwiXFxcIlxcblwiXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZGlmaWVkTGluZSArPSBcInBhcmVudFwiICsgcGFyZW50Q291bnQgKyBcIjogXFxcIltbXCIgKyBwLnJlcGxhY2UoXCI6XCIsIFwiX1wiKSArIFwiXV1cXFwiXFxuXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudENvdW50KytcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm0gKz0gbW9kaWZpZWRMaW5lXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZtICs9IChsaW5lICsgXCJcXG5cIilcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaDNDb3VudCA+PSAyKSB7XG4gICAgICAgICAgICBjICs9IChsaW5lICsgXCJcXG5cIilcbiAgICAgICAgfVxuICAgICAgICBpZiAobGluZSA9PT0gXCItLS1cIikge1xuICAgICAgICAgICAgaDNDb3VudCsrO1xuICAgICAgICB9XG4gICAgfSBcbiAgICB0ZXh0ICs9IGNvbnRlbnRcbiAgICBpZiAoZm0ubGVuZ3RoID4gMCkge1xuICAgICAgICB0ZXh0ICs9IGZtXG4gICAgfVxuICAgIHRleHQgKz0gY1xuICAgIFxuICAgIHJldHVybiB0ZXh0LnJlcGxhY2UoL14tLS1cXG4tLS1cXG4vbSwgXCJcIikucmVwbGFjZSgvXFxuJC8sIFwiXCIpXG59XG4qL1xuXG5leHBvcnQgZnVuY3Rpb25cdHRpZHlVcEZyb250TWF0dGVyT25WYWx1ZSh2YWx1ZTogc3RyaW5nKSB7XG4gICAgY29uc3QgdmFsdWVzOiBzdHJpbmdbXSA9IHZhbHVlLnNwbGl0KFwiXFxuXCIpXG4gICAgY29uc3QgbGluZUNvdW50ID0gdmFsdWVzLmxlbmd0aFxuXG4gICAgXG4gICAgbGV0IGZtID0gXCJcIlxuICAgIGxldCBjID0gXCJcIlxuICAgIGxldCB0ZXh0ID0gXCJcIlxuICAgIGxldCBoM0NvdW50ID0gMDtcbiAgICBsZXQgY29udGVudCA9IFwiXCJcblxuICAgIC8qXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lQ291bnQ7IGkrKykge1xuICAgICAgICBjb25zdCBsaW5lID0gdmFsdWVzW2ldXG4gICAgICAgIGNvbnN0IG1vZGlmaWVkTGluZSA9IGxpbmUucmVwbGFjZSgvXihcXHMqKVxcKiAvLCBcIiQxLSBcIilcbiAgICAgICAgdGV4dCArPSBtb2RpZmllZExpbmUgKyBcIlxcblwiXG4qL1xuICAgICAgICAvKlxuICAgICAgICBpZiAoaDNDb3VudCA9PSAwKSB7XG4gICAgICAgICAgICBjb250ZW50ICs9IChsaW5lICsgXCJcXG5cIilcbiAgICAgICAgfSBlbHNlIGlmIChoM0NvdW50ID09IDEpIHtcbiAgICAgICAgICAgIGlmICgvXmxpc3Q6IC8udGVzdChsaW5lKSkge1xuICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBsaXN0IGZpZWxkXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZtICs9IChsaW5lICsgXCJcXG5cIilcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy9pZiAoL150YWc6IFthLWNdXFwvW2Etel1cXC9bYS16XSQvLnRlc3QobGluZSkpIHtcbiAgICAgICAgICAgIC8vICAgIGZtICs9IChsaW5lLnJlcGxhY2UoL150YWc6IC8sIFwidGFnczogXCIpICsgXCJcXG5cIilcbiAgICAgICAgICAgIC8vfSBlbHNlIHtcbiAgICAgICAgICAgIC8vICAgIGZtICs9IChsaW5lICsgXCJcXG5cIilcbiAgICAgICAgICAgIC8vfVxuICAgICAgICAgICAgXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGgzQ291bnQgPj0gMikge1xuICAgICAgICAgICAgYyArPSAobGluZSArIFwiXFxuXCIpXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxpbmUgPT09IFwiLS0tXCIpIHtcbiAgICAgICAgICAgIGgzQ291bnQrKztcbiAgICAgICAgfVxuICAgICAgICAqL1xuICAgIC8vfSBcbiAgICAvKlxuICAgIHRleHQgKz0gY29udGVudFxuICAgIGlmIChmbS5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRleHQgKz0gZm1cbiAgICB9XG4gICAgdGV4dCArPSBjXG4gICAgKi9cbiAgIC8vY29uc29sZS5sb2codGV4dClcbiAgICAvL3JldHVybiB0ZXh0LnJlcGxhY2UoL1xcbiQvLCBcIlwiKVxuXG4gICAgcmV0dXJuIHJlcGxhY2VUV1VzZWxlc3NWYWx1ZSh2YWx1ZSlcbn0iLCAiaW1wb3J0IHsgRWRpdG9yLCBOb3RpY2UgfSBmcm9tIFwib2JzaWRpYW5cIlxuXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlQ29udGVudEZyb21TdGFydE9mTm90ZVRvQ3Vyc29yKGVkaXRvcjogRWRpdG9yKSB7XG4gICAgY29uc3QgY3Vyc29yID0gZWRpdG9yLmdldEN1cnNvcigpXG4gICAgY29uc3QgbGluZSA9IGN1cnNvci5saW5lXG4gICAgY29uc3QgY2ggPSBjdXJzb3IuY2hcbiAgICBjb25zdCBsaW5lQ29udGVudCA9IGVkaXRvci5nZXRMaW5lKGxpbmUpXG4gICAgLy8gcmVtb3ZlIGNvbnRlbnQgZnJvbSBmaXJzdCBjaGFyYWN0ZXIgdG8gY2ggY2hhcmFjdGVyIG9mIGxpbmVDb250ZW50XG4gICAgbGV0IG5ld0NvbnRlbnQgPSBsaW5lQ29udGVudC5zdWJzdHJpbmcoY2gpXG4gICAgZm9yIChsZXQgaSA9IGxpbmUgKyAxOyBpIDwgZWRpdG9yLmxpbmVDb3VudCgpOyBpKyspIHtcbiAgICAgICAgbmV3Q29udGVudCArPSBcIlxcblwiICsgZWRpdG9yLmdldExpbmUoaSlcbiAgICB9XG4gICAgZWRpdG9yLnNldFZhbHVlKG5ld0NvbnRlbnQpXG4gICAgY3Vyc29yLmxpbmUgPSAwXG4gICAgY3Vyc29yLmNoID0gMFxuICAgIGVkaXRvci5zZXRDdXJzb3IoY3Vyc29yKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlQ29udGVudEZyb21DdXJzb3JUb0VuZE9mTm90ZShlZGl0b3I6IEVkaXRvcikge1xuICAgIGNvbnN0IGN1cnNvciA9IGVkaXRvci5nZXRDdXJzb3IoKVxuICAgIGNvbnN0IGxpbmUgPSBjdXJzb3IubGluZVxuICAgIGNvbnN0IGNoID0gY3Vyc29yLmNoXG4gICAgY29uc3QgbGluZUNvbnRlbnQgPSBlZGl0b3IuZ2V0TGluZShsaW5lKVxuICAgIGxldCBuZXdDb250ZW50ID0gXCJcIlxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZTsgaSsrKSB7XG4gICAgICAgIG5ld0NvbnRlbnQgKz0gZWRpdG9yLmdldExpbmUoaSkgKyBcIlxcblwiXG4gICAgfVxuICAgIG5ld0NvbnRlbnQgKz0gbGluZUNvbnRlbnQuc3Vic3RyaW5nKDAsIGNoKVxuICAgIGVkaXRvci5zZXRWYWx1ZShuZXdDb250ZW50KVxuICAgIGN1cnNvci5saW5lID0gbGluZVxuICAgIGN1cnNvci5jaCA9IGNoXG4gICAgZWRpdG9yLnNldEN1cnNvcihjdXJzb3IpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb3B5Q29udGVudEZyb21DdXJzb3JUb0VuZE9mTm90ZShlZGl0b3I6IEVkaXRvcikge1xuICAgIGNvbnN0IGN1cnNvciA9IGVkaXRvci5nZXRDdXJzb3IoKVxuICAgIGNvbnN0IGxpbmUgPSBjdXJzb3IubGluZVxuICAgIGNvbnN0IGNoID0gY3Vyc29yLmNoXG4gICAgY29uc3QgbGluZUNvbnRlbnQgPSBlZGl0b3IuZ2V0TGluZShsaW5lKVxuICAgIGxldCBuZXdDb250ZW50ID0gXCJcIlxuICAgIG5ld0NvbnRlbnQgKz0gbGluZUNvbnRlbnQuc3Vic3RyaW5nKGNoKVxuICAgIGZvciAobGV0IGkgPSBsaW5lICsgMTsgaSA8IGVkaXRvci5saW5lQ291bnQoKTsgaSsrKSB7XG4gICAgICAgIG5ld0NvbnRlbnQgKz0gXCJcXG5cIiArIGVkaXRvci5nZXRMaW5lKGkpXG4gICAgfVxuICAgIG5hdmlnYXRvci5jbGlwYm9hcmQud3JpdGVUZXh0KG5ld0NvbnRlbnQpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICBuZXcgTm90aWNlKGBDb3BpZWQgY29udGVudCBmcm9tIGN1cnNvciB0byBlbmQgb2Ygbm90ZSB0byBjbGlwYm9hcmQhYCk7XG4gICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgIG5ldyBOb3RpY2UoYGVycm9yIHdoZW4gY29weSB0byBjbGlwYm9hcmQhYCk7XG4gICAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVDb250ZW50TGVmdFNhbWVMaW5lKGVkaXRvcjogRWRpdG9yKSB7XG4gICAgY29uc3QgY3Vyc29yID0gZWRpdG9yLmdldEN1cnNvcigpXG4gICAgY29uc3QgbGluZSA9IGN1cnNvci5saW5lXG4gICAgY29uc3QgY2ggPSBjdXJzb3IuY2hcbiAgICBjb25zdCBsaW5lQ29udGVudCA9IGVkaXRvci5nZXRMaW5lKGxpbmUpXG4gICAgLy8gcmVtb3ZlIGNvbnRlbnQgZnJvbSBmaXJzdCBjaGFyYWN0ZXIgdG8gY2ggY2hhcmFjdGVyIG9mIGxpbmVDb250ZW50XG4gICAgZWRpdG9yLnNldExpbmUobGluZSwgbGluZUNvbnRlbnQuc3Vic3RyaW5nKGNoKSlcbiAgICBjdXJzb3IuY2ggPSAwXG4gICAgZWRpdG9yLnNldEN1cnNvcihjdXJzb3IpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVDb250ZW50UmlnaHRTYW1lTGluZShlZGl0b3I6IEVkaXRvcikge1xuICAgIGNvbnN0IGN1cnNvciA9IGVkaXRvci5nZXRDdXJzb3IoKVxuICAgIGNvbnN0IGxpbmUgPSBjdXJzb3IubGluZVxuICAgIGNvbnN0IGNoID0gY3Vyc29yLmNoXG4gICAgY29uc3QgbGluZUNvbnRlbnQgPSBlZGl0b3IuZ2V0TGluZShsaW5lKVxuICAgIC8vIHJlbW92ZSBjb250ZW50IGZyb20gY2ggY2hhcmFjdGVyIHRvIGVuZCBvZiBsaW5lQ29udGVudFxuICAgIGVkaXRvci5zZXRMaW5lKGxpbmUsIGxpbmVDb250ZW50LnN1YnN0cmluZygwLCBjaCkpXG4gICAgY3Vyc29yLmNoID0gZWRpdG9yLmdldExpbmUobGluZSkubGVuZ3RoXG4gICAgZWRpdG9yLnNldEN1cnNvcihjdXJzb3IpXG59IiwgImltcG9ydCB7IEFwcCwgRWRpdG9yLCBGdXp6eVN1Z2dlc3RNb2RhbCwgRnV6enlNYXRjaCwgVEZpbGUgfSBmcm9tIFwib2JzaWRpYW5cIjtcbmltcG9ydCB7IGNvcHlDb250ZW50RnJvbUN1cnNvclRvRW5kT2ZOb3RlLCByZW1vdmVDb250ZW50RnJvbUN1cnNvclRvRW5kT2ZOb3RlLCByZW1vdmVDb250ZW50RnJvbVN0YXJ0T2ZOb3RlVG9DdXJzb3IsIHJlbW92ZUNvbnRlbnRMZWZ0U2FtZUxpbmUsIHJlbW92ZUNvbnRlbnRSaWdodFNhbWVMaW5lIH0gZnJvbSBcInNlbGZ1dGlsL3JlbW92ZUNvbnRlbnRGcm9tQ3Vyc29yXCI7XG5cbmV4cG9ydCBjbGFzcyBSZW1vdmVDb250ZW50RnJvbUN1cnNvck1vZGFsIGV4dGVuZHMgRnV6enlTdWdnZXN0TW9kYWw8c3RyaW5nPiB7XG5cbiAgY29weUNvbnRlbnRGcm9tQ3Vyc29yVG9FbmRPZk5vdGU6IHN0cmluZyA9IFwiQ29weSBjb250ZW50IGZyb20gY3Vyc29yIHRvIGVuZCBvZiBub3RlXCJcbiAgY3V0Q29udGVudEZyb21DdXJzb3JUb0VuZE9mTm90ZTogc3RyaW5nID0gXCJDdXQgY29udGVudCBmcm9tIGN1cnNvciB0byBlbmQgb2Ygbm90ZVwiXG4gIHJlbW92ZUNvbnRlbnRMZWZ0U2FtZUxpbmUgOiBzdHJpbmcgPSBcIlJlbW92ZSBjb250ZW50IGxlZnQgc2FtZSBsaW5lXCJcbiAgcmVtb3ZlQ29udGVudFJpZ2h0U2FtZUxpbmUgOiBzdHJpbmcgPSBcIlJlbW92ZSBjb250ZW50IHJpZ2h0IHNhbWUgbGluZVwiXG4gIHJlbW92ZUNvbnRlbnRGcm9tU3RhcnRPZk5vdGVUb0N1cnNvcjogc3RyaW5nID0gXCJSZW1vdmUgY29udGVudCBmcm9tIHN0YXJ0IG9mIG5vdGUgdG8gY3Vyc29yXCJcbiAgcmVtb3ZlQ29udGVudEZyb21DdXJzb3JUb0VuZE9mTm90ZTogc3RyaW5nID0gXCJSZW1vdmUgY29udGVudCBmcm9tIGN1cnNvciB0byBlbmQgb2Ygbm90ZVwiXG5cbiAgb3B0aW9uczogc3RyaW5nW10gPSBbdGhpcy5jb3B5Q29udGVudEZyb21DdXJzb3JUb0VuZE9mTm90ZSwgdGhpcy5jdXRDb250ZW50RnJvbUN1cnNvclRvRW5kT2ZOb3RlLCB0aGlzLnJlbW92ZUNvbnRlbnRMZWZ0U2FtZUxpbmUsIHRoaXMucmVtb3ZlQ29udGVudFJpZ2h0U2FtZUxpbmUsIHRoaXMucmVtb3ZlQ29udGVudEZyb21TdGFydE9mTm90ZVRvQ3Vyc29yLCB0aGlzLnJlbW92ZUNvbnRlbnRGcm9tQ3Vyc29yVG9FbmRPZk5vdGVdXG4gIGVkaXRvcjogRWRpdG9yO1xuICBrZXlkb3duSGFuZGxlcjogKGV2ZW50OiBLZXlib2FyZEV2ZW50KSA9PiB2b2lkO1xuXG4gIGNvbnN0cnVjdG9yKGFwcDogQXBwLCBlZGl0b3I6IEVkaXRvcilcbiAge1xuICAgIHN1cGVyKGFwcClcbiAgICB0aGlzLmVkaXRvciA9IGVkaXRvclxuICAgIHRoaXMua2V5ZG93bkhhbmRsZXIgPSAoZXZlbnQ6IEtleWJvYXJkRXZlbnQpID0+IHtcbiAgICAgIGlmIChldmVudC5jdHJsS2V5ICYmIGV2ZW50LmFsdEtleSAmJiBldmVudC5zaGlmdEtleSAmJiBldmVudC5rZXkgPT09ICdYJykgeyAvLyB3aW5kb3dzXG4gICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgIH0gZWxzZSBpZiAoZXZlbnQuY3RybEtleSAmJiBldmVudC5tZXRhS2V5ICYmIGV2ZW50LnNoaWZ0S2V5ICYmIGV2ZW50LmtleSA9PT0gJ1gnKSB7IC8vIG1hY29zXG4gICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgIH0gZWxzZSBpZiAoZXZlbnQubWV0YUtleSB8fCBldmVudC5jdHJsS2V5KSB7XG4gICAgICAgIGNvbnN0IGtleSA9IHBhcnNlSW50KGV2ZW50LmtleSwgMTApO1xuICAgICAgICBpZiAoa2V5ID49IDEgJiYga2V5IDw9IDkpIHtcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpOyAvLyBQcmV2ZW50IGRlZmF1bHQgYWN0aW9uXG4gICAgICAgICAgdGhpcy5zZWxlY3RFbGVtZW50KGtleSAtIDEpOyAvLyBTZWxlY3QgdGhlIGVsZW1lbnQgKGluZGV4IGtleSAtIDEpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gTGlzdGVuIGZvciBrZXlkb3duIGV2ZW50cyBhdCB0aGUgZG9jdW1lbnQgbGV2ZWxcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5rZXlkb3duSGFuZGxlcik7XG4gIH1cblxuICBzZWxlY3RFbGVtZW50KGluZGV4OiBudW1iZXIpIHtcbiAgICBjb25zdCBlbGVtZW50cyA9IHRoaXMucmVzdWx0Q29udGFpbmVyRWwucXVlcnlTZWxlY3RvckFsbCgnLnN1Z2dlc3Rpb24taXRlbScpO1xuICAgIGlmIChlbGVtZW50cy5sZW5ndGggPiBpbmRleCkge1xuICAgICAgY29uc3QgZWxlbWVudCA9IGVsZW1lbnRzW2luZGV4XSBhcyBIVE1MRWxlbWVudDtcbiAgICAgIGVsZW1lbnQuY2xpY2soKTsgLy8gU2ltdWxhdGUgYSBjbGljayB0byBzZWxlY3QgdGhlIGVsZW1lbnRcbiAgICB9XG4gIH1cblxuICBvbkNsb3NlKCkge1xuICAgIHN1cGVyLm9uQ2xvc2UoKTtcbiAgICAvLyBTdG9wIGxpc3RlbmluZyBmb3Iga2V5ZG93biBldmVudHMgd2hlbiB0aGUgbW9kYWwgaXMgY2xvc2VkXG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMua2V5ZG93bkhhbmRsZXIpO1xuICAgIC8vdGhpcy5zY29wZS51bnJlZ2lzdGVyKCk7IC8vIFVucmVnaXN0ZXIgdGhlIHNjb3BlIHdoZW4gdGhlIG1vZGFsIGlzIGNsb3NlZFxuICB9XG5cbiAgZ2V0SXRlbXMoKTogc3RyaW5nW10ge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnM7XG4gIH1cblxuICBnZXRJdGVtVGV4dChpdGVtOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIHJldHVybiBpdGVtO1xuICB9XG5cbiAgLy8gUmVuZGVycyBlYWNoIHN1Z2dlc3Rpb24gaXRlbS5cbiAgcmVuZGVyU3VnZ2VzdGlvbihpOiBGdXp6eU1hdGNoPHN0cmluZz4sIGVsOiBIVE1MRWxlbWVudCkge1xuICAgIGNvbnN0IGl0ZW0gPSBpLml0ZW1cbiAgICBjb25zdCBpbmRleCA9IHRoaXMucmVzdWx0Q29udGFpbmVyRWwucXVlcnlTZWxlY3RvckFsbCgnLnN1Z2dlc3Rpb24taXRlbScpLmxlbmd0aDtcbiAgICBjb25zdCBpdGVtSW5kZXggPSBpbmRleCA8IDEwID8gaW5kZXggKyBcIi4gXCIgOiBcIiAgICBcIlxuICAgIGVsLmNyZWF0ZUVsKFwiZGl2XCIsIHsgdGV4dDogaXRlbUluZGV4ICsgaXRlbSB9KTtcbiAgfVxuXG4gIC8vIFBlcmZvcm0gYWN0aW9uIG9uIHRoZSBzZWxlY3RlZCBzdWdnZXN0aW9uLlxuICBhc3luYyBvbkNob29zZUl0ZW0oc2VsZWN0ZWRDb250ZW50OiBzdHJpbmcsIGV2dDogTW91c2VFdmVudCB8IEtleWJvYXJkRXZlbnQpIHtcbiAgICBjb25zdCBjaG9vc2VuT3B0aW9uID0gc2VsZWN0ZWRDb250ZW50XG4gICAgaWYgKGNob29zZW5PcHRpb24gPT09IHRoaXMucmVtb3ZlQ29udGVudExlZnRTYW1lTGluZSkge1xuICAgICAgcmVtb3ZlQ29udGVudExlZnRTYW1lTGluZSh0aGlzLmVkaXRvcilcbiAgICB9IGVsc2UgaWYgKGNob29zZW5PcHRpb24gPT09IHRoaXMucmVtb3ZlQ29udGVudFJpZ2h0U2FtZUxpbmUpIHtcbiAgICAgIHJlbW92ZUNvbnRlbnRSaWdodFNhbWVMaW5lKHRoaXMuZWRpdG9yKVxuICAgIH0gZWxzZSBpZiAoY2hvb3Nlbk9wdGlvbiA9PT0gdGhpcy5yZW1vdmVDb250ZW50RnJvbVN0YXJ0T2ZOb3RlVG9DdXJzb3IpIHtcbiAgICAgIHJlbW92ZUNvbnRlbnRGcm9tU3RhcnRPZk5vdGVUb0N1cnNvcih0aGlzLmVkaXRvcilcbiAgICB9IGVsc2UgaWYgKGNob29zZW5PcHRpb24gPT09IHRoaXMucmVtb3ZlQ29udGVudEZyb21DdXJzb3JUb0VuZE9mTm90ZSkge1xuICAgICAgcmVtb3ZlQ29udGVudEZyb21DdXJzb3JUb0VuZE9mTm90ZSh0aGlzLmVkaXRvcilcbiAgICB9IGVsc2UgaWYgKGNob29zZW5PcHRpb24gPT09IHRoaXMuY29weUNvbnRlbnRGcm9tQ3Vyc29yVG9FbmRPZk5vdGUpIHtcbiAgICAgIGNvcHlDb250ZW50RnJvbUN1cnNvclRvRW5kT2ZOb3RlKHRoaXMuZWRpdG9yKVxuICAgIH0gZWxzZSBpZiAoY2hvb3Nlbk9wdGlvbiA9PT0gdGhpcy5jdXRDb250ZW50RnJvbUN1cnNvclRvRW5kT2ZOb3RlKSB7XG4gICAgICBjb3B5Q29udGVudEZyb21DdXJzb3JUb0VuZE9mTm90ZSh0aGlzLmVkaXRvcilcbiAgICAgIHJlbW92ZUNvbnRlbnRGcm9tQ3Vyc29yVG9FbmRPZk5vdGUodGhpcy5lZGl0b3IpXG4gICAgfVxuICB9XG59IiwgImltcG9ydCB7IEFwcCwgRWRpdG9yLCBGdXp6eVN1Z2dlc3RNb2RhbCwgRnV6enlNYXRjaCwgVEZpbGUgfSBmcm9tIFwib2JzaWRpYW5cIjtcblxuZXhwb3J0IGNsYXNzIEZpbmRSZXBsYWNlTW9kYWwgZXh0ZW5kcyBGdXp6eVN1Z2dlc3RNb2RhbDxzdHJpbmc+IHtcblxuICBmaW5kIDogc3RyaW5nID0gXCJmaW5kXCJcbiAgcmVwbGFjZTogc3RyaW5nID0gXCJyZXBsYWNlXCJcbiAgb3B0aW9uczogc3RyaW5nW10gPSBbdGhpcy5maW5kLCB0aGlzLnJlcGxhY2VdXG5cbiAgY29uc3RydWN0b3IoYXBwOiBBcHApXG4gIHtcbiAgICBzdXBlcihhcHApXG4gIH1cblxuICBnZXRJdGVtcygpOiBzdHJpbmdbXSB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucztcbiAgfVxuXG4gIGdldEl0ZW1UZXh0KGl0ZW06IHN0cmluZyk6IHN0cmluZyB7XG4gICAgcmV0dXJuIGl0ZW07XG4gIH1cblxuICAvLyBSZW5kZXJzIGVhY2ggc3VnZ2VzdGlvbiBpdGVtLlxuICByZW5kZXJTdWdnZXN0aW9uKGk6IEZ1enp5TWF0Y2g8c3RyaW5nPiwgZWw6IEhUTUxFbGVtZW50KSB7XG4gICAgY29uc3QgaXRlbSA9IGkuaXRlbVxuICAgIGVsLmNyZWF0ZUVsKFwiZGl2XCIsIHsgdGV4dDogaXRlbSB9KTtcbiAgfVxuXG4gIC8vIFBlcmZvcm0gYWN0aW9uIG9uIHRoZSBzZWxlY3RlZCBzdWdnZXN0aW9uLlxuICBhc3luYyBvbkNob29zZUl0ZW0oc2VsZWN0ZWRDb250ZW50OiBzdHJpbmcsIGV2dDogTW91c2VFdmVudCB8IEtleWJvYXJkRXZlbnQpIHtcbiAgICBjb25zdCBjaG9vc2VuT3B0aW9uID0gc2VsZWN0ZWRDb250ZW50XG4gICAgaWYgKGNob29zZW5PcHRpb24gPT09IHRoaXMuZmluZClcbiAgICB7XG4gICAgICAvLyBAdHMtaWdub3JlXG5cdFx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWNhbGxcblx0XHRcdFx0dGhpcy5hcHAuY29tbWFuZHMuZXhlY3V0ZUNvbW1hbmRCeUlkKFwiZWRpdG9yOm9wZW4tc2VhcmNoXCIpXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEB0cy1pZ25vcmVcblx0XHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtY2FsbFxuXHRcdFx0XHR0aGlzLmFwcC5jb21tYW5kcy5leGVjdXRlQ29tbWFuZEJ5SWQoXCJvYnNpZGlhbi1yZWdleC1yZXBsYWNlOm9ic2lkaWFuLXJlZ2V4LXJlcGxhY2VcIilcbiAgICB9XG4gIH1cbn0iLCAiaW1wb3J0IHsgQXBwLCBGdXp6eVN1Z2dlc3RNb2RhbCwgRnV6enlNYXRjaCwgZ2V0QWxsVGFncywgVEZpbGUsIEVkaXRvciwgTWFya2Rvd25WaWV3LCBOb3RpY2UgfSBmcm9tIFwib2JzaWRpYW5cIjtcbmltcG9ydCB7IGZpbGVzV2hlcmVUYWdJc1VzZWQgfSBmcm9tIFwic2VsZnV0aWwvZmluZE5vdGVzRnJvbVRhZ1wiO1xuaW1wb3J0IHsgZ2V0QWxsTm90ZVRhZ3MgfSBmcm9tIFwic2VsZnV0aWwvZ2V0QWxsTm90ZVRhZ3NcIjtcblxuZXhwb3J0IGNsYXNzIFF1ZXJ5T3JwaGFuTm90ZXNCeVRhZ01vZGFsIGV4dGVuZHMgRnV6enlTdWdnZXN0TW9kYWw8c3RyaW5nPiB7XG5cbiAgZWRpdG9yOiBFZGl0b3JcbiAgdmlldzogTWFya2Rvd25WaWV3XG4gIGtleWRvd25IYW5kbGVyOiAoZXZlbnQ6IEtleWJvYXJkRXZlbnQpID0+IHZvaWQ7XG5cbiAgY29uc3RydWN0b3IoYXBwOiBBcHAsIGVkaXRvcjogRWRpdG9yLCB2aWV3OiBNYXJrZG93blZpZXcpXG4gIHtcbiAgICBzdXBlcihhcHApXG4gICAgdGhpcy5zZXRQbGFjZWhvbGRlcihgV2hpY2ggbm90ZXMgd2l0aCB0YWdzIGRvIHlvdSB3YW50IHRvIHNlYXJjaCBvcnBoYW4/YClcbiAgICB0aGlzLnNldEluc3RydWN0aW9ucyhbXG4gICAgICB7XG4gICAgICAgIGNvbW1hbmQ6IFwiXCIsXG4gICAgICAgIHB1cnBvc2U6IGBXaGljaCBub3RlcyB3aXRoIHRhZ3MgZG8geW91IHdhbnQgdG8gc2VhcmNoIG9ycGhhbj9gXG4gICAgICB9XG4gICAgXSk7XG4gICAgdGhpcy5lZGl0b3IgPSBlZGl0b3JcbiAgICB0aGlzLnZpZXcgPSB2aWV3XG4gICAgdGhpcy5rZXlkb3duSGFuZGxlciA9IChldmVudDogS2V5Ym9hcmRFdmVudCkgPT4ge1xuICAgICBpZiAoZXZlbnQubWV0YUtleSB8fCBldmVudC5jdHJsS2V5KSB7XG4gICAgICAgIGNvbnN0IGtleSA9IHBhcnNlSW50KGV2ZW50LmtleSwgMTApO1xuICAgICAgICBpZiAoa2V5ID49IDEgJiYga2V5IDw9IDkpIHtcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpOyAvLyBQcmV2ZW50IGRlZmF1bHQgYWN0aW9uXG4gICAgICAgICAgdGhpcy5zZWxlY3RFbGVtZW50KGtleSAtIDEpOyAvLyBTZWxlY3QgdGhlIGVsZW1lbnQgKGluZGV4IGtleSAtIDEpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gTGlzdGVuIGZvciBrZXlkb3duIGV2ZW50cyBhdCB0aGUgZG9jdW1lbnQgbGV2ZWxcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5rZXlkb3duSGFuZGxlcik7XG4gIH1cblxuICBzZWxlY3RFbGVtZW50KGluZGV4OiBudW1iZXIpIHtcbiAgICBjb25zdCBlbGVtZW50cyA9IHRoaXMucmVzdWx0Q29udGFpbmVyRWwucXVlcnlTZWxlY3RvckFsbCgnLnN1Z2dlc3Rpb24taXRlbScpO1xuICAgIGlmIChlbGVtZW50cy5sZW5ndGggPiBpbmRleCkge1xuICAgICAgY29uc3QgZWxlbWVudCA9IGVsZW1lbnRzW2luZGV4XSBhcyBIVE1MRWxlbWVudDtcbiAgICAgIGVsZW1lbnQuY2xpY2soKTsgLy8gU2ltdWxhdGUgYSBjbGljayB0byBzZWxlY3QgdGhlIGVsZW1lbnRcbiAgICB9XG4gIH1cblxuICBvbkNsb3NlKCkge1xuICAgIHN1cGVyLm9uQ2xvc2UoKTtcbiAgICAvLyBTdG9wIGxpc3RlbmluZyBmb3Iga2V5ZG93biBldmVudHMgd2hlbiB0aGUgbW9kYWwgaXMgY2xvc2VkXG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMua2V5ZG93bkhhbmRsZXIpO1xuICB9XG5cbiAgZ2V0SXRlbXMoKSA6IHN0cmluZ1tdIHtcblx0XHRjb25zdCBsID0gWy4uLmdldEFsbE5vdGVUYWdzKHRoaXMuYXBwKS5tYXAocyA9PiBzLnJlcGxhY2UoL14jLywgXCJAXCIpKV07XG4gICAgLy8gcmVtb3ZlIGR1cGxpY2F0ZSBmb3IgbFxuICAgIHJldHVybiBsLmZpbHRlcigoaXRlbSwgaW5kZXgpID0+IGwuaW5kZXhPZihpdGVtKSA9PT0gaW5kZXgpO1xuICB9XG5cbiAgZ2V0SXRlbVRleHQodmFsdWU6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgLy8gUmVuZGVycyBlYWNoIHN1Z2dlc3Rpb24gaXRlbS5cbiAgcmVuZGVyU3VnZ2VzdGlvbih2YWx1ZTogRnV6enlNYXRjaDxzdHJpbmc+LCBlbDogSFRNTEVsZW1lbnQpIHtcbiAgICBjb25zdCBpdGVtID0gdmFsdWUuaXRlbVxuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5yZXN1bHRDb250YWluZXJFbC5xdWVyeVNlbGVjdG9yQWxsKCcuc3VnZ2VzdGlvbi1pdGVtJykubGVuZ3RoO1xuICAgIGNvbnN0IGl0ZW1JbmRleCA9IGluZGV4IDwgMTAgPyBpbmRleCArIFwiLiBcIiA6IFwiICAgIFwiXG4gICAgZWwuY3JlYXRlRWwoXCJkaXZcIiwgeyB0ZXh0OiBpdGVtSW5kZXggKyBpdGVtIH0pXG4gIH1cblxuICAvLyBQZXJmb3JtIGFjdGlvbiBvbiB0aGUgc2VsZWN0ZWQgc3VnZ2VzdGlvbi5cbiAgYXN5bmMgb25DaG9vc2VJdGVtKGNob29zZW5WYWx1ZTogc3RyaW5nLCBldnQ6IE1vdXNlRXZlbnQgfCBLZXlib2FyZEV2ZW50KSB7XG4gICAgLy9jb25zb2xlLmxvZyh0aGlzLnZpZXcuZmlsZS5wYXRoKVxuICAgIGNvbnN0IHF1ZXJ5TWQgPSBcIkkvU2VsZiBRdWVyeS5tZFwiXG4gICAgaWYgKHRoaXMudmlldy5maWxlLnBhdGggPT09IHF1ZXJ5TWQpIHtcbiAgICAgIG5ldyBOb3RpY2UoXCJDaGVja2luZy4uLiBtYXkgbmVlZCBzb21lIHRpbWVcIilcbiAgICAgIGNvbnN0IHRhZyA9ICBjaG9vc2VuVmFsdWUucmVwbGFjZSgvXkAvLCBcIiNcIilcbiAgICAgIGNvbnN0IGZpbGVQYXRocyA9IGZpbGVzV2hlcmVUYWdJc1VzZWQodGFnKVxuICAgICAgbGV0IHJlc3VsdCA9IFwiIyMgT3JwaGFuIG5vdGVzIGZvciB0YWcgYFwiICsgdGFnICsgXCJgXFxuXCJcbiAgICAgIGZvciAoY29uc3QgZmlsZVBhdGggb2YgZmlsZVBhdGhzKSB7XG4gICAgICAgIC8vY29uc29sZS5sb2coYENoZWNraW5nIGJhY2tsaW5rcyBmb3IgJHtmaWxlUGF0aH1gKVxuICAgICAgICBjb25zdCB0RmlsZTogVEZpbGUgPSB0aGlzLmFwcC52YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgoZmlsZVBhdGgpIGFzIFRGaWxlXG4gICAgICAgIGNvbnN0IGJhY2tsaW5rcyA9IHRoaXMuYXBwLm1ldGFkYXRhQ2FjaGUuZ2V0QmFja2xpbmtzRm9yRmlsZSh0RmlsZSlcbiAgICAgICAgLy9jb25zb2xlLmxvZyhiYWNrbGlua3MpXG4gICAgICAgIC8vY29uc29sZS5sb2coYmFja2xpbmtzLmRhdGEpXG4gICAgICAgIGlmICghYmFja2xpbmtzIHx8ICFiYWNrbGlua3MuZGF0YSB8fCBPYmplY3Qua2V5cyhiYWNrbGlua3MuZGF0YSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coYE5vIGJhY2tsaW5rcyBmb3IgJHt0RmlsZS5wYXRofWApXG4gICAgICAgICAgcmVzdWx0ICs9IFwiXFxuXCIgKyBcIi0gW1tcIiArIHRGaWxlLmJhc2VuYW1lICsgXCJdXVwiXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gcmVtb3ZlIGtleSBcImFhYVwiIGZyb20gYmFja2xpbmtzLmRhdGFcbiAgICAgICAgICBkZWxldGUgYmFja2xpbmtzLmRhdGFbcXVlcnlNZF1cbiAgICAgICAgICBpZiAoT2JqZWN0LmtleXMoYmFja2xpbmtzLmRhdGEpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhgTm8gYmFja2xpbmtzIGZvciAke3RGaWxlLnBhdGh9YClcbiAgICAgICAgICAgIHJlc3VsdCArPSBcIlxcblwiICsgXCItIFtbXCIgKyB0RmlsZS5iYXNlbmFtZSArIFwiXV1cIlxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKGBIYXMgYmFja2xpbmtzIGZvciAke3RGaWxlLnBhdGh9YClcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuZWRpdG9yLnNldFZhbHVlKHJlc3VsdClcbiAgICAgIG5ldyBOb3RpY2UoXCJVcGRhdGVkIG9ycGhhblwiKVxuICAgIH0gZWxzZSB7XG4gICAgICBuZXcgTm90aWNlKFwiUGxlYXNlIGdvIHRvICdcIiArIHF1ZXJ5TWQgKyBcIicgdG8gcnVuIHRoaXMgYWN0aW9uXCIpXG4gICAgfVxuICAgIFxuICAgIFxuICB9IFxufSIsICJpbXBvcnQgeyBBcHAsIEZ1enp5U3VnZ2VzdE1vZGFsLCBGdXp6eU1hdGNoLCBURmlsZSwgTWFya2Rvd25WaWV3LCBOb3RpY2UsIEVkaXRvciwgU3VnZ2VzdE1vZGFsLCBDYWNoZWRNZXRhZGF0YSwgRnJvbnRNYXR0ZXJDYWNoZSwgcGFyc2VGcm9udE1hdHRlclRhZ3MsIFNjb3BlIH0gZnJvbSBcIm9ic2lkaWFuXCJcbmltcG9ydCB7IGZpbGVzV2hlcmVUYWdJc1VzZWQgfSBmcm9tIFwic2VsZnV0aWwvZmluZE5vdGVzRnJvbVRhZ1wiO1xuaW1wb3J0IHsgZ2V0Tm90ZVR5cGUgfSBmcm9tIFwic2VsZnV0aWwvZ2V0VGFza1RhZ1wiO1xuaW1wb3J0IHsgTGlua1R5cGUgfSBmcm9tIFwic2VsZnV0aWwvbGlua1R5cGVcIjtcblxuaW50ZXJmYWNlIFBhdGhXaXRoQ29udGVudCB7XG4gIHBhdGg6IHN0cmluZztcbiAgY29udGVudCA6IHN0cmluZztcbn1cblxuZXhwb3J0IGNsYXNzIE5hdmlnYXRlVG9Gb3J3YXJkQW5kQmFja2xpbmtUYWdNb2RhbCBleHRlbmRzIFN1Z2dlc3RNb2RhbDxMaW5rVHlwZT4ge1xuXG4gIHZpZXc6IE1hcmtkb3duVmlld1xuICBlZGl0b3I6IEVkaXRvclxuICAvL2l0ZW1zOiBMaW5rVHlwZVtdXG5cbiAga2V5ZG93bkhhbmRsZXI6IChldmVudDogS2V5Ym9hcmRFdmVudCkgPT4gdm9pZDtcblxuICBjb25zdHJ1Y3RvcihhcHA6IEFwcCwgdmlldzogTWFya2Rvd25WaWV3LCBlZGl0b3I6IEVkaXRvcilcbiAge1xuICAgIHN1cGVyKGFwcClcbiAgICB0aGlzLnZpZXcgPSB2aWV3XG4gICAgdGhpcy5lZGl0b3IgPSBlZGl0b3JcbiAgICBjb25zdCB0aGlzRmlsZU5hbWUgPSB0aGlzLnZpZXcuZmlsZS5wYXRoXG4gICAgY29uc3QgZGlzcGxheVRoaXNGaWxlVHlwZSA9IGdldE5vdGVUeXBlKHRoaXNGaWxlTmFtZSlcbiAgICBjb25zdCBkaXNwbGF5VGhpc0ZpbGUgPSBkaXNwbGF5VGhpc0ZpbGVUeXBlID8gZGlzcGxheVRoaXNGaWxlVHlwZS5wcmVmaXggKyBcIiBcIiArIHRoaXNGaWxlTmFtZSA6IHRoaXNGaWxlTmFtZVxuICAgIHRoaXMuc2V0UGxhY2Vob2xkZXIoYCR7ZGlzcGxheVRoaXNGaWxlfSAtIFdoaWNoIGxpbmsgZG8geW91IHdhbnQgdG8gbmF2aWdhdGUgdG8/YClcbiAgICB0aGlzLnNldEluc3RydWN0aW9ucyhbXG4gICAgICB7XG4gICAgICAgIGNvbW1hbmQ6IFwiXCIsXG4gICAgICAgIHB1cnBvc2U6IGAke2Rpc3BsYXlUaGlzRmlsZX0gLSBXaGljaCBsaW5rIGRvIHlvdSB3YW50IHRvIG5hdmlnYXRlIHRvP2BcbiAgICAgIH1cbiAgICBdKTtcblxuICAgIHRoaXMua2V5ZG93bkhhbmRsZXIgPSAoZXZlbnQ6IEtleWJvYXJkRXZlbnQpID0+IHtcbiAgICAgIC8vY29uc29sZS5sb2coXCJjdHJsIFwiICsgZXZlbnQuY3RybEtleSlcbiAgICAgIC8vY29uc29sZS5sb2coXCJhbHQgXCIgKyBldmVudC5hbHRLZXkpXG4gICAgICAvL2NvbnNvbGUubG9nKFwibWV0YSBcIiArIGV2ZW50Lm1ldGFLZXkpXG4gICAgICAvL2NvbnNvbGUubG9nKFwic2hpZnQgXCIgKyBldmVudC5zaGlmdEtleSlcbiAgICAgIC8vY29uc29sZS5sb2coXCJrZXkgXCIgKyBldmVudC5rZXkpXG4gICAgICAvLyBDaGVjayBpZiBDdHJsICsgUSB3YXMgcHJlc3NlZFxuICAgICAgaWYgKGV2ZW50LmN0cmxLZXkgJiYgZXZlbnQuYWx0S2V5ICYmIGV2ZW50LnNoaWZ0S2V5ICYmIGV2ZW50LmtleSA9PT0gJ08nKSB7IC8vIHdpbmRvd3NcbiAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgfSBlbHNlIGlmIChldmVudC5jdHJsS2V5ICYmIGV2ZW50Lm1ldGFLZXkgJiYgZXZlbnQuc2hpZnRLZXkgJiYgZXZlbnQua2V5ID09PSAnTycpIHsgLy8gbWFjb3NcbiAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgfSBlbHNlIGlmIChldmVudC5tZXRhS2V5IHx8IGV2ZW50LmN0cmxLZXkpIHtcbiAgICAgICAgY29uc3Qga2V5ID0gcGFyc2VJbnQoZXZlbnQua2V5LCAxMCk7XG4gICAgICAgIGlmIChrZXkgPj0gMSAmJiBrZXkgPD0gOSkge1xuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7IC8vIFByZXZlbnQgZGVmYXVsdCBhY3Rpb25cbiAgICAgICAgICB0aGlzLnNlbGVjdEVsZW1lbnQoa2V5IC0gMSk7IC8vIFNlbGVjdCB0aGUgZWxlbWVudCAoaW5kZXgga2V5IC0gMSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBMaXN0ZW4gZm9yIGtleWRvd24gZXZlbnRzIGF0IHRoZSBkb2N1bWVudCBsZXZlbFxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLmtleWRvd25IYW5kbGVyKTtcblxuICB9XG5cbiAgc2VsZWN0RWxlbWVudChpbmRleDogbnVtYmVyKSB7XG4gICAgY29uc3QgZWxlbWVudHMgPSB0aGlzLnJlc3VsdENvbnRhaW5lckVsLnF1ZXJ5U2VsZWN0b3JBbGwoJy5zdWdnZXN0aW9uLWl0ZW0nKTtcbiAgICBpZiAoZWxlbWVudHMubGVuZ3RoID4gaW5kZXgpIHtcbiAgICAgIGNvbnN0IGVsZW1lbnQgPSBlbGVtZW50c1tpbmRleF0gYXMgSFRNTEVsZW1lbnQ7XG4gICAgICBlbGVtZW50LmNsaWNrKCk7IC8vIFNpbXVsYXRlIGEgY2xpY2sgdG8gc2VsZWN0IHRoZSBlbGVtZW50XG4gICAgfVxuICB9XG5cbiAgb25DbG9zZSgpIHtcbiAgICBzdXBlci5vbkNsb3NlKCk7XG4gICAgLy8gU3RvcCBsaXN0ZW5pbmcgZm9yIGtleWRvd24gZXZlbnRzIHdoZW4gdGhlIG1vZGFsIGlzIGNsb3NlZFxuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLmtleWRvd25IYW5kbGVyKTtcbiAgICAvL3RoaXMuc2NvcGUudW5yZWdpc3RlcigpOyAvLyBVbnJlZ2lzdGVyIHRoZSBzY29wZSB3aGVuIHRoZSBtb2RhbCBpcyBjbG9zZWRcbiAgfVxuXG4gIGdldFRGaWxlQnlQYXRoKHBhdGg6IHN0cmluZyk6IFRGaWxlIHwgbnVsbCB7XG4gICAgY29uc3QgZmlsZSA9IHRoaXMuYXBwLnZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aChwYXRoKTtcbiAgICBpZiAoZmlsZSBpbnN0YW5jZW9mIFRGaWxlKSB7XG4gICAgICByZXR1cm4gZmlsZTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBnZXRIZWFkaW5nRm9yTGluZShwYXRoOiBzdHJpbmcsIGxpbmVOdW1iZXI6IG51bWJlcik6IHN0cmluZyB7XG4gICAgY29uc3QgZmlsZSA9IHRoaXMuZ2V0VEZpbGVCeVBhdGgocGF0aCk7XG4gICAgaWYgKCFmaWxlKSB7XG4gICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG4gICAgY29uc3QgZmlsZUNhY2hlID0gdGhpcy5hcHAubWV0YWRhdGFDYWNoZS5nZXRGaWxlQ2FjaGUoZmlsZSk7XG4gICAgaWYgKCFmaWxlQ2FjaGUgfHwgIWZpbGVDYWNoZS5oZWFkaW5ncykge1xuICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuICBcbiAgICBjb25zdCBoZWFkaW5ncyA9IGZpbGVDYWNoZS5oZWFkaW5ncztcbiAgICBsZXQgY3VycmVudEhlYWRpbmcgPSBcIlwiO1xuICBcbiAgICBmb3IgKGNvbnN0IGhlYWRpbmcgb2YgaGVhZGluZ3MpIHtcbiAgICAgIGlmIChoZWFkaW5nLnBvc2l0aW9uLnN0YXJ0LmxpbmUgPD0gbGluZU51bWJlcikge1xuICAgICAgICBjdXJyZW50SGVhZGluZyA9IFwiI1wiICsgaGVhZGluZy5oZWFkaW5nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICBcbiAgICByZXR1cm4gY3VycmVudEhlYWRpbmc7XG4gIH1cblxuICBhc3luYyBnZXRMaW5rSXRlbXMoKTogUHJvbWlzZTxMaW5rVHlwZVtdPiB7XG4gICAgY29uc3QgZm9yd2FyZExpbmtJdGVtcyA9IGF3YWl0IHRoaXMuZ2V0Rm9yd2FyZGxpbmtJdGVtcygpXG4gICAgbGV0IGJhY2tMaW5rSXRlbXMgPSBbXVxuICAgIGxldCBjaGlsZExpbmtJdGVtcyA9IFtdXG4gICAgbGV0IHBhcmVudExpbmtJdGVtcyA9IFtdXG5cbiAgICBjb25zdCBiYWNrbGlua3MgPSB0aGlzLmFwcC5tZXRhZGF0YUNhY2hlLmdldEJhY2tsaW5rc0ZvckZpbGUodGhpcy52aWV3LmZpbGUpXG4gICAgY29uc3QgYmFja2xpbmtzRGF0YSA9IGJhY2tsaW5rcz8uZGF0YVxuICAgIGlmIChiYWNrbGlua3NEYXRhKSB7XG4gICAgICBmb3IgKGxldCBpIGluIGJhY2tsaW5rc0RhdGEpIHtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBiYWNrbGlua3NEYXRhW2ldLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgY29uc3QgaW5kZXggPSBiYWNrbGlua3NEYXRhW2ldLmxlbmd0aCA+IDEgPyBcIltcIiArIGogKyBcIl1cIiA6IFwiXCJcbiAgICAgICAgICBpZiAoaSAhPSB0aGlzLnZpZXcuZmlsZS5wYXRoKSB7XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiQEBcIilcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coaSlcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coYmFja2xpbmtzRGF0YVtpXVtqXSlcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IGJhY2tsaW5rc0RhdGFbaV1bal1bJ2tleSddXG4gICAgICAgICAgICBpZiAoa2V5KSB7XG4gICAgICAgICAgICAgIGNoaWxkTGlua0l0ZW1zLnB1c2goe3BhdGg6IGksIHR5cGU6IFwidiBcIiwgaW5kZXg6IGluZGV4LCBoZWFkaW5nOiBcIlwiLCBsaW5lOiAwLCBjaDogMH0pICBcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNvbnN0IHBvc2l0aW9uID0gYmFja2xpbmtzRGF0YVtpXVtqXVsncG9zaXRpb24nXVxuICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKHBvc2l0aW9uKVxuICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKHBvc2l0aW9uWydzdGFydCddWydsaW5lJ10pXG4gICAgICAgICAgICAgIGNvbnN0IGxpbmUgPSBwb3NpdGlvblsnc3RhcnQnXVsnbGluZSddXG4gICAgICAgICAgICAgIGNvbnN0IGhlYWRpbmcgPSB0aGlzLmdldEhlYWRpbmdGb3JMaW5lKGksIGxpbmUpXG4gICAgICAgICAgICAgIGNvbnN0IGJhY2tsaW5rTGluZUZpbGUgPSB0aGlzLmFwcC52YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgoaSlcbiAgICAgICAgICAgICAgY29uc3QgYmFja2xpbmtMaW5lRmlsZXMgPSBiYWNrbGlua0xpbmVGaWxlID8gYXdhaXQgdGhpcy5hcHAudmF1bHQucmVhZChiYWNrbGlua0xpbmVGaWxlIGFzIFRGaWxlKSA6IFwiXCJcbiAgICAgICAgICAgICAgY29uc3QgYmFja2xpbmtMaW5lRmlsZXMyID0gYmFja2xpbmtMaW5lRmlsZXMuc3BsaXQoXCJcXG5cIilcbiAgICAgICAgICAgICAgY29uc3QgYmFja2xpbmtMaW5lID0gYmFja2xpbmtMaW5lRmlsZXMyW2xpbmVdLnRyaW0oKVxuICAgICAgICAgICAgICBjb25zdCBiYWNrbGlua0xpbmUyID0gYmFja2xpbmtMaW5lLnJlcGxhY2UoL14tIC8sIFwiXCIpLnJlcGxhY2UoL15cXGQrXFwuIC8sIFwiXCIpXG4gICAgICAgICAgICAgIGNvbnN0IGJhY2tsaW5rTGluZTMgPSBiYWNrbGlua0xpbmUyID09PSBiYWNrbGlua3NEYXRhW2ldW2pdWydvcmlnaW5hbCddID8gXCJcIiA6IGJhY2tsaW5rTGluZTJcblxuICAgICAgICAgICAgICAvLyBmb3IgWktcbiAgICAgICAgICAgICAgbGV0IHprQ29udGVudCA9IFwiXCJcbiAgICAgICAgICAgICAgY29uc3QgYmFja2xpbmtOb3RlVHlwZSA9IGdldE5vdGVUeXBlKGkpXG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKGJhY2tsaW5rTm90ZVR5cGUpXG4gICAgICAgICAgICAgIGlmIChiYWNrbGlua05vdGVUeXBlICYmIGJhY2tsaW5rTm90ZVR5cGUudHlwZSA9PT0gXCJiL24velwiKVxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaWYgKGxpbmUgLSAzID49IDApIHtcbiAgICAgICAgICAgICAgICAgIHprQ29udGVudCArPSBiYWNrbGlua0xpbmVGaWxlczJbbGluZSAtIDNdICsgXCJcXG5cIlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobGluZSAtIDIgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgemtDb250ZW50ICs9IGJhY2tsaW5rTGluZUZpbGVzMltsaW5lIC0gMl0gKyBcIlxcblwiXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChsaW5lIC0gMSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICB6a0NvbnRlbnQgKz0gYmFja2xpbmtMaW5lRmlsZXMyW2xpbmUgLSAxXSArIFwiXFxuXCJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgemtDb250ZW50ICs9IGJhY2tsaW5rTGluZUZpbGVzMltsaW5lXSArIFwiXFxuXCJcbiAgICAgICAgICAgICAgICBpZiAobGluZSArIDEgPCBiYWNrbGlua0xpbmVGaWxlczIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICB6a0NvbnRlbnQgKz0gYmFja2xpbmtMaW5lRmlsZXMyW2xpbmUgKyAxXSArIFwiXFxuXCJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGxpbmUgKyAyIDwgYmFja2xpbmtMaW5lRmlsZXMyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgemtDb250ZW50ICs9IGJhY2tsaW5rTGluZUZpbGVzMltsaW5lICsgMl0gKyBcIlxcblwiXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChsaW5lICsgMyA8IGJhY2tsaW5rTGluZUZpbGVzMi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgIHprQ29udGVudCArPSBiYWNrbGlua0xpbmVGaWxlczJbbGluZSArIDNdICsgXCJcXG5cIlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyByZW1vdmUgZW5kIG5ld2xpbmUgY2hhcmFjdGVyXG4gICAgICAgICAgICAgICAgemtDb250ZW50ID0gemtDb250ZW50LnJlcGxhY2UoL1xcbiQvLCBcIlwiKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbnN0IGFhYSA9IHRoaXMuZ2V0QmFja2xpbmtIZWFkaW5nKGhlYWRpbmcsIGJhY2tsaW5rTGluZTMsIHprQ29udGVudCk7XG4gICAgICAgICAgICAgIGJhY2tMaW5rSXRlbXMucHVzaCh7cGF0aDogaSwgdHlwZTogXCI8IFwiLCBpbmRleDogaW5kZXgsIGhlYWRpbmc6IGFhYSwgbGluZTogYmFja2xpbmtzRGF0YVtpXVtqXVsncG9zaXRpb24nXVsnc3RhcnQnXVsnbGluZSddLCBjaDogYmFja2xpbmtzRGF0YVtpXVtqXVsncG9zaXRpb24nXVsnc3RhcnQnXVsnY29sJ119KVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGZpbGVDYWNoZSA6IENhY2hlZE1ldGFkYXRhIHwgbnVsbCA9IHRoaXMuYXBwLm1ldGFkYXRhQ2FjaGUuZ2V0RmlsZUNhY2hlKHRoaXMudmlldy5maWxlKVxuICAgIGlmIChmaWxlQ2FjaGUpIHtcbiAgICAgIGNvbnN0IGZyb250bWF0dGVyIDogRnJvbnRNYXR0ZXJDYWNoZSB8IHVuZGVmaW5lZCA9IGZpbGVDYWNoZS5mcm9udG1hdHRlclxuICAgICAgaWYgKGZyb250bWF0dGVyKSB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIGZyb250bWF0dGVyKSB7XG4gICAgICAgICAgaWYgKGZyb250bWF0dGVyLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gZnJvbnRtYXR0ZXJba2V5XTtcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coYEtleTogJHtrZXl9LCBWYWx1ZTogJHt2YWx1ZX1gKTtcbiAgICAgICAgICAgIGlmICh2YWx1ZS5zdGFydHNXaXRoKCdbWycpICYmIHZhbHVlLmVuZHNXaXRoKCddXScpKSB7XG4gICAgICAgICAgICAgIC8vIEV4dHJhY3QgdGhlIG5vdGUgbGluayB3aXRob3V0IHRoZSBzcXVhcmUgYnJhY2tldHNcbiAgICAgICAgICAgICAgY29uc3Qgbm90ZUxpbmsgPSB2YWx1ZS5zbGljZSgyLCAtMik7XG4gICAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ05vdGUgbGluazonLCBub3RlTGluayk7XG4gICAgICAgICAgICAgIGNvbnN0IGxpbmtlZEZpbGUgPSB0aGlzLmFwcC5tZXRhZGF0YUNhY2hlLmdldEZpcnN0TGlua3BhdGhEZXN0KG5vdGVMaW5rLCB0aGlzLnZpZXcuZmlsZS5wYXRoKTtcbiAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcImxpbmtlZEZpbGVcIilcbiAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhsaW5rZWRGaWxlKVxuICAgICAgICAgICAgICBjb25zdCB0ZiA9IGxpbmtlZEZpbGUgPyB0aGlzLmFwcC52YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgobGlua2VkRmlsZS5wYXRoKSA6IG51bGxcbiAgICAgICAgICAgICAgaWYgKHRmKSB7XG4gICAgICAgICAgICAgICAgcGFyZW50TGlua0l0ZW1zLnB1c2goe3BhdGg6IHRmLnBhdGgsIHR5cGU6IFwiXiBcIiwgaW5kZXg6IFwiXCIsIGhlYWRpbmc6IFwiXCIsIGxpbmU6IDAsIGNoOiAwfSkgXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFsuLi5jaGlsZExpbmtJdGVtcywgLi4ucGFyZW50TGlua0l0ZW1zLCAuLi5iYWNrTGlua0l0ZW1zLCAuLi5mb3J3YXJkTGlua0l0ZW1zXVxuICB9XG5cbiAgZ2V0QmFja2xpbmtIZWFkaW5nKGhlYWRpbmcgOiBzdHJpbmcsIGxpbmUgOiBzdHJpbmcsIHprQ29udGVudCA6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgaWYgKGhlYWRpbmcgIT09IFwiXCIgJiYgbGluZSAhPT0gXCJcIiAmJiB6a0NvbnRlbnQgIT09IFwiXCIpIHtcbiAgICAgIHJldHVybiBoZWFkaW5nICsgXCJcXG5cIiArIGxpbmUgKyBcIlxcblwiICsgemtDb250ZW50XG4gICAgfSBlbHNlIGlmIChoZWFkaW5nICE9PSBcIlwiICYmIGxpbmUgIT09IFwiXCIgJiYgemtDb250ZW50ID09PSBcIlwiKSB7XG4gICAgICAgIHJldHVybiBoZWFkaW5nICsgXCJcXG5cIiArIGxpbmVcbiAgICB9IGVsc2UgaWYgKGhlYWRpbmcgIT09IFwiXCIgJiYgbGluZSA9PT0gXCJcIiAmJiB6a0NvbnRlbnQgIT09IFwiXCIpIHtcbiAgICAgIHJldHVybiBoZWFkaW5nICsgXCJcXG5cIiArIHprQ29udGVudFxuICAgIH0gZWxzZSBpZiAoaGVhZGluZyAhPT0gXCJcIiAmJiBsaW5lID09PSBcIlwiICYmIHprQ29udGVudCA9PT0gXCJcIikge1xuICAgICAgcmV0dXJuIGhlYWRpbmdcbiAgICB9IGVsc2UgaWYgKGhlYWRpbmcgPT09IFwiXCIgJiYgbGluZSAhPT0gXCJcIiAmJiB6a0NvbnRlbnQgIT09IFwiXCIpIHtcbiAgICAgIHJldHVybiBsaW5lICsgXCJcXG5cIiArIHprQ29udGVudFxuICAgIH0gZWxzZSBpZiAoaGVhZGluZyA9PT0gXCJcIiAmJiBsaW5lICE9PSBcIlwiICYmIHprQ29udGVudCA9PT0gXCJcIikge1xuICAgICAgcmV0dXJuIGxpbmVcbiAgICB9IGVsc2UgaWYgKHprQ29udGVudCAhPT0gXCJcIikge1xuICAgICAgcmV0dXJuIHprQ29udGVudFxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gXCJcIlxuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGdldEZvcndhcmRsaW5rSXRlbXMoKTogUHJvbWlzZTxMaW5rVHlwZVtdPiB7XG4gICAgY29uc3QgZm9yd2FyZGxpbmtzID0gdGhpcy5hcHAubWV0YWRhdGFDYWNoZS5nZXRGaWxlQ2FjaGUodGhpcy52aWV3LmZpbGUpPy5saW5rc1xuXG4gICAgaWYgKCFmb3J3YXJkbGlua3MpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICBjb25zdCBmaWxlQ29udGVudCA9IHRoaXMudmlldy5maWxlID8gYXdhaXQgdGhpcy5hcHAudmF1bHQucmVhZCh0aGlzLnZpZXcuZmlsZSkgOiBcIlwiO1xuICAgIGNvbnN0IGxpbmVDb250ZW50cyA9IGZpbGVDb250ZW50ID09PSBcIlwiID8gW10gOiBmaWxlQ29udGVudC5zcGxpdChcIlxcblwiKVxuXG4gICAgY29uc3QgcGF0aHMgOiBQYXRoV2l0aENvbnRlbnRbXSA9IGZvcndhcmRsaW5rcy5tYXAoKGxpbmspID0+IHtcbiAgICAgIGNvbnN0IGxpbmtlZEZpbGUgPSB0aGlzLmFwcC5tZXRhZGF0YUNhY2hlLmdldEZpcnN0TGlua3BhdGhEZXN0KGxpbmsubGluaywgdGhpcy52aWV3LmZpbGUucGF0aCk7XG4gICAgICBjb25zdCB0ZiA9IGxpbmtlZEZpbGUgPyB0aGlzLmFwcC52YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgobGlua2VkRmlsZS5wYXRoKSA6IG51bGw7XG4gICAgICAvL3JldHVybiB7cGF0aDogdGYgPyB0Zi5wYXRoIDogXCJcIiwgY29udGVudDogXCJcIn07XG4gICAgICAvLyBiZWxvdyB3b3JrcywganVzdCBzbG93XG4gICAgICBcbiAgICAgIGNvbnN0IGxpbmVDb250ZW50ID0gbGluZUNvbnRlbnRzLmxlbmd0aCAhPSAwID8gbGluZUNvbnRlbnRzW2xpbmsucG9zaXRpb24uc3RhcnQubGluZV0udHJpbSgpIDogXCJcIjtcbiAgICAgIGNvbnN0IGNvbnRlbnQgPSBsaW5lQ29udGVudC5yZXBsYWNlKC9eLSAvLCBcIlwiKS5yZXBsYWNlKC9eXFxkK1xcLiAvLCBcIlwiKSA9PT0gbGluay5vcmlnaW5hbCA/IFwiXCIgOiBsaW5lQ29udGVudDtcbiAgICAgIHJldHVybiB7cGF0aDogdGYgPyB0Zi5wYXRoIDogXCJcIiwgY29udGVudDogY29udGVudH07XG4gIH0pO1xuXG4gIHJldHVybiBwYXRocy5maWx0ZXIocGMgPT4gcGMucGF0aCAhPT0gXCJcIikubWFwKHBjID0+IHtcbiAgICAgIHJldHVybiB7cGF0aDogcGMucGF0aCwgdHlwZTogXCI+IFwiLCBpbmRleDogXCJcIiwgaGVhZGluZzogcGMuY29udGVudCwgbGluZTogMCwgY2g6IDB9O1xuICB9KTtcblxuICAvKlxuICAgIC8vIHRoZW4gcmVzb2x2ZSB0aGUgcGF0aCBieSB0aGUgbGluayBuYW1lXG4gICAgcmV0dXJuIChmb3J3YXJkbGlua3MgPyBmb3J3YXJkbGlua3MubWFwKGFzeW5jIGxpbmsgPT4ge1xuICAgICAgY29uc29sZS5sb2cobGluay5saW5rKVxuICAgICAgY29uc29sZS5sb2cobGluay5kaXNwbGF5VGV4dClcbiAgICAgIGNvbnNvbGUubG9nKGxpbmsub3JpZ2luYWwpXG4gICAgICBjb25zb2xlLmxvZyhsaW5rLnBvc2l0aW9uKVxuICAgICAgY29uc3QgbGlua2VkRmlsZSA9IHRoaXMuYXBwLm1ldGFkYXRhQ2FjaGUuZ2V0Rmlyc3RMaW5rcGF0aERlc3QobGluay5saW5rLCB0aGlzLnZpZXcuZmlsZS5wYXRoKTtcbiAgICAgIGNvbnN0IHRmID0gbGlua2VkRmlsZSA/IHRoaXMuYXBwLnZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aChsaW5rZWRGaWxlLnBhdGgpIDogbnVsbFxuICAgICAgY29uc3QgY29udGVudCA9IGxpbmtlZEZpbGUgPyBhd2FpdCB0aGlzLmFwcC52YXVsdC5yZWFkKGxpbmtlZEZpbGUpIDogXCJcIjtcbiAgICAgIHJldHVybiB0ZiA/IHRmLnBhdGggOiBcIlwiXG4gICAgfSkuZmlsdGVyKHBhdGggPT4gcGF0aCAhPT0gXCJcIilcbiAgICAgICA6IFtdKS5tYXAocCA9PiB7XG4gICAgICAgICAgcmV0dXJuIHtwYXRoOiBwLCB0eXBlOiBcIj4gXCIsIGluZGV4OiBcIlwiLCBoZWFkaW5nOiBcIlwiLCBsaW5lOiAwLCBjaDogMH1cbiAgICAgICB9KVxuICAgICAgICovXG4gIH1cblxuICBnZXRTYW1lVGFnSXRlbXMoKTogTGlua1R5cGVbXSB7XG4gICAgbGV0IGl0ZW1zOiBMaW5rVHlwZVtdID0gW11cbiAgICBsZXQgeyBmcm9udG1hdHRlciB9ID0gYXBwLm1ldGFkYXRhQ2FjaGUuZ2V0RmlsZUNhY2hlKHRoaXMudmlldy5maWxlKSB8fCB7fTtcbiAgICBjb25zdCBmbXRhZ3MgPSAocGFyc2VGcm9udE1hdHRlclRhZ3MoZnJvbnRtYXR0ZXIpIHx8IFtdKS8vLmZpbHRlcih0ID0+IHQgPT0gXCJ0YWdzXCIpO1xuICAgIC8vY29uc29sZS5sb2coZm10YWdzKVxuICAgIHZhciB0YWcgPSBcIlwiXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmbXRhZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICgvI1thLXpdXFwvW2Etel1cXC9bYS16XS8udGVzdChmbXRhZ3NbaV0pKSB7XG4gICAgICAgIHRhZyA9IGZtdGFnc1tpXVxuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgICAvL2NvbnNvbGUubG9nKFwiZm91bmQgdGFnID0gXCIgKyB0YWcpXG4gICAgaWYgKHRhZyAhPT0gXCJcIikge1xuICAgICAgY29uc3QgZmlsZVBhdGhzIDogc3RyaW5nW10gPSBmaWxlc1doZXJlVGFnSXNVc2VkKHRhZylcbiAgICAgIC8vY29uc29sZS5sb2coXCJmaWxlUGF0aHM6IFwiICsgZmlsZVBhdGhzKVxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmaWxlUGF0aHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaXRlbXMucHVzaCh7cGF0aDogZmlsZVBhdGhzW2ldLCB0eXBlOiBcIkAgXCIsIGluZGV4OiBcIlwiLCBoZWFkaW5nOiBcIlwiLCBsaW5lOiAwLCBjaDogMH0pIFxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaXRlbXNcbiAgfVxuXG4gIGdldENvbnRlbnRJdGVtcygpOiBMaW5rVHlwZVtdIHtcbiAgICBjb25zdCB2YWx1ZSA9IHRoaXMuZWRpdG9yLmdldFZhbHVlKClcbiAgICBjb25zdCBsaW5lcyA9IHZhbHVlLnNwbGl0KFwiXFxuXCIpXG5cbiAgICBsZXQgcmVzdWx0QXNKaXJhTGluayA9IFtdXG4gICAgbGV0IHJlc3VsdEFzSGVhZGVyID0gW11cbiAgICBsZXQgcmVzdWx0QXNVbmZpbmlzaGVkQWN0aW9uID0gW11cbiAgICBsZXQgcmVzdWx0QXNGaW5pc2hlZEFjdGlvbiA9IFtdXG4gICAgbGV0IHJlc3VsdEFzQ29udGVudCA9IFtdXG4gICAgbGV0IHJlc3VsdEFzRXh0ZXJuYWxMaW5rcyA9IFtdXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgbGluZSA9IGxpbmVzW2ldLnRyaW0oKVxuICAgICAgaWYgKGxpbmUgIT0gXCItLS1cIiAmJiBsaW5lICE9PSBcIlwiICYmICEvXnRhZ3M6IFthLXpdXFwvW2Etel1cXC9bYS16XS8udGVzdChsaW5lKSkge1xuICAgICAgICBpZiAoL15bI117MSw2fSAvLnRlc3QobGluZSkpIHtcbiAgICAgICAgICByZXN1bHRBc0hlYWRlci5wdXNoKHtwYXRoOiBsaW5lLnJlcGxhY2UoL15bI117MSw2fS8sIFwiXCIpLCB0eXBlOiBsaW5lLnJlcGxhY2UoL14oWyNdezEsNn0gKS4qLywgXCIkMVwiKSwgaW5kZXg6IFwiXCIsIGhlYWRpbmc6IFwiXCIsIGxpbmU6IGksIGNoOiAwfSlcbiAgICAgICAgfSBlbHNlIGlmICgvI1t3bnRdW25sd2RhdG1lXSAvLnRlc3QobGluZSkgfHwgLyAjW3dudF1bbmx3ZGF0bWVdLy50ZXN0KGxpbmUpKSB7XG4gICAgICAgICAgaWYgKC8jW3duXVtkYV0gLy50ZXN0KGxpbmUpIHx8IC8gI1t3bl1bZGFdLy50ZXN0KGxpbmUpKSB7XG4gICAgICAgICAgICByZXN1bHRBc0ZpbmlzaGVkQWN0aW9uLnB1c2goe3BhdGg6IGxpbmUsIHR5cGU6IFwieCBcIiwgaW5kZXg6IFwiXCIsIGhlYWRpbmc6IFwiXCIsIGxpbmU6IGksIGNoOiAwfSlcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0QXNVbmZpbmlzaGVkQWN0aW9uLnB1c2goe3BhdGg6IGxpbmUsIHR5cGU6IFwieiBcIiwgaW5kZXg6IFwiXCIsIGhlYWRpbmc6IFwiXCIsIGxpbmU6IGksIGNoOiAwfSlcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0QXNDb250ZW50LnB1c2goe3BhdGg6IGxpbmUsIHR5cGU6IFwiYyBcIiwgaW5kZXg6IFwiXCIsIGhlYWRpbmc6IFwiXCIsIGxpbmU6IGksIGNoOiAwfSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgdXJsUmVnZXggPSAvKGh0dHB8aHR0cHMpOlxcL1xcLyhcXHcrOnswLDF9XFx3KkApPyhcXFMrKSg6WzAtOV0rKT8oXFwvfFxcLyhbXFx3IyE6Lj8rPSYlQCFcXC0vXSkpPy9nO1xuICAgICAgY29uc3QgbWF0Y2hlcyA9IGxpbmUubWF0Y2godXJsUmVnZXgpXG4gICAgICBpZiAobWF0Y2hlcykge1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG1hdGNoZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICByZXN1bHRBc0V4dGVybmFsTGlua3MucHVzaCh7cGF0aDogbWF0Y2hlc1tqXSwgdHlwZTogXCJ3IFwiLCBpbmRleDogXCJcIiwgaGVhZGluZzogXCJcIiwgbGluZTogaSwgY2g6IDB9KVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBqaXJhTGlua1JlZ2V4ID0gLyhbQS1aXSstWzAtOV0rKS9nXG4gICAgICAgIGNvbnN0IGppcmFNYXRjaGVzID0gbGluZS5tYXRjaChqaXJhTGlua1JlZ2V4KVxuICAgICAgICBpZiAoamlyYU1hdGNoZXMpIHtcbiAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGppcmFNYXRjaGVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICByZXN1bHRBc0ppcmFMaW5rLnB1c2goe3BhdGg6IFwiaHR0cHM6Ly9qaXJhLm9yY3NvZnR3YXJlLmNvbS9icm93c2UvXCIgKyBqaXJhTWF0Y2hlc1tqXSwgdHlwZTogXCJqIFwiLCBpbmRleDogXCJcIiwgaGVhZGluZzogXCJcIiwgbGluZTogaSwgY2g6IDB9KVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gW1xuICAgICAgLi4ucmVzdWx0QXNIZWFkZXIsXG4gICAgICAuLi5yZXN1bHRBc1VuZmluaXNoZWRBY3Rpb24sXG4gICAgICAvLy4uLnJlc3VsdEFzRmluaXNoZWRBY3Rpb24sXG4gICAgICAuLi5yZXN1bHRBc0ppcmFMaW5rLFxuICAgICAgLi4ucmVzdWx0QXNFeHRlcm5hbExpbmtzLFxuICAgICAgLi4ucmVzdWx0QXNDb250ZW50XG4gICAgXVxuICB9XG5cbiAgLypcbiAgZ2V0SXRlbXMoKTogTGlua1R5cGVbXSB7XG4gICAgcmV0dXJuIHRoaXMuaXRlbXNcbiAgfVxuKi9cbmFzeW5jIHByZXBhcmVJdGVtcygpOiBQcm9taXNlPExpbmtUeXBlW10+IHtcbiAgY29uc3QgbGlua0l0ZW1zID0gYXdhaXQgdGhpcy5nZXRMaW5rSXRlbXMoKTtcbiAgY29uc3Qgc2FtZVRhZ0l0ZW1zID0gYXdhaXQgdGhpcy5nZXRTYW1lVGFnSXRlbXMoKTtcbiAgY29uc3QgY29udGVudEl0ZW1zID0gYXdhaXQgdGhpcy5nZXRDb250ZW50SXRlbXMoKTtcblxuICByZXR1cm4gW1xuICAgICAgLi4ubGlua0l0ZW1zLFxuICAgICAge3BhdGg6IFwiLS0tLS0tLS0tLS0tLS0tLS0tXCIsIHR5cGU6IFwiXCIsIGluZGV4OiBcIlwiLCBoZWFkaW5nOiBcIlwiLCBsaW5lOiAwLCBjaDogMH0sXG4gICAgICAuLi5zYW1lVGFnSXRlbXMsXG4gICAgICB7cGF0aDogXCItLS0tLS0tLS0tLS0tLS0tLS1cIiwgdHlwZTogXCJcIiwgaW5kZXg6IFwiXCIsIGhlYWRpbmc6IFwiXCIsIGxpbmU6IDAsIGNoOiAwfSxcbiAgICAgIC4uLmNvbnRlbnRJdGVtcyxcbiAgXTtcbn1cblxuICBhc3luYyBnZXRTdWdnZXN0aW9ucyhxdWVyeTogc3RyaW5nKTogUHJvbWlzZTxMaW5rVHlwZVtdPiB7XG4gICAgY29uc3QgaXRlbXMgPSBhd2FpdCB0aGlzLnByZXBhcmVJdGVtcygpXG4gICAgcmV0dXJuIGl0ZW1zLmZpbHRlcigoaSkgPT4ge1xuICAgICAgY29uc3QgbG93ZXJRdWVyeSA9IHF1ZXJ5LnRvTG93ZXJDYXNlKClcbiAgICAgIHJldHVybiBuZXcgUmVnRXhwKGxvd2VyUXVlcnkpLnRlc3QoKGkudHlwZSArIGkucGF0aCkudG9Mb3dlckNhc2UoKSlcbiAgICB9KTtcbiAgfVxuXG4gIGdldEl0ZW1UZXh0KGw6IExpbmtUeXBlKTogc3RyaW5nIHtcbiAgICByZXR1cm4gbC5wYXRoO1xuICB9XG5cbiAgLy8gUmVuZGVycyBlYWNoIHN1Z2dlc3Rpb24gaXRlbS5cbiAgcmVuZGVyU3VnZ2VzdGlvbihsbDogTGlua1R5cGUsIGVsOiBIVE1MRWxlbWVudCkge1xuICAgIC8vY29uc3QgbGw6IExpbmtUeXBlID0gbC5pdGVtXG4gICAgY29uc3QgaW5kZXggPSB0aGlzLnJlc3VsdENvbnRhaW5lckVsLnF1ZXJ5U2VsZWN0b3JBbGwoJy5zdWdnZXN0aW9uLWl0ZW0nKS5sZW5ndGg7XG4gICAgY29uc3QgaXRlbUluZGV4ID0gaW5kZXggPCAxMCA/IGluZGV4ICsgXCIuIFwiIDogXCIgICAgXCJcbiAgICBlbC5jcmVhdGVFbChcImRpdlwiLCB7IHRleHQ6IGl0ZW1JbmRleCArIGxsLnR5cGUgKyB0aGlzLmdldFRhc2tUYWcobGwudHlwZSwgbGwucGF0aCkgKyBsbC5wYXRoICsgbGwuaW5kZXh9KTtcbiAgICBpZiAobGwuaGVhZGluZyAhPT0gXCJcIikge1xuICAgICAgZWwuY3JlYXRlRWwoXCJzbWFsbFwiLCB7IHRleHQ6IGxsLmhlYWRpbmcsIGNsczogJ3NlbGYtcGFkZGluZy1sZWZ0LTU1JyB9KTtcbiAgICB9XG4gIH1cblxuICBnZXRUYXNrVGFnKHR5cGU6IHN0cmluZywgcGF0aDogc3RyaW5nKTogc3RyaW5nIHtcbiAgICBpZiAodHlwZSA9PT0gXCI+IFwiIHx8IHR5cGUgPT09IFwiPCBcIiB8fCB0eXBlID09PSBcInYgXCIgfHwgdHlwZSA9PT0gXCJeIFwiIHx8IHR5cGUgPT09IFwiQCBcIikge1xuICAgICAgY29uc3Qgbm90ZVR5cGUgPSBnZXROb3RlVHlwZShwYXRoKVxuICAgICAgcmV0dXJuIG5vdGVUeXBlID8gXCIgXCIgKyBub3RlVHlwZS5wcmVmaXggKyBcIiBcIiA6IFwiXCJcbiAgICB9XG4gICAgcmV0dXJuIFwiXCJcbiAgfVxuXG4gIC8vIFBlcmZvcm0gYWN0aW9uIG9uIHRoZSBzZWxlY3RlZCBzdWdnZXN0aW9uLlxuICBvbkNob29zZVN1Z2dlc3Rpb24obDogTGlua1R5cGUsIGV2dDogTW91c2VFdmVudCB8IEtleWJvYXJkRXZlbnQpIHtcbiAgICBpZiAobC50eXBlID09PSBcIlwiKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgaWYgKGwudHlwZSA9PT0gXCI8IFwiIHx8IGwudHlwZSA9PT0gXCI+IFwiIHx8IGwudHlwZSA9PT0gXCJ2IFwiIHx8IGwudHlwZSA9PT0gXCJeIFwiIHx8IGwudHlwZSA9PT0gXCJAIFwiKSB7XG4gICAgICAgIGNvbnN0IHsgdmF1bHQsIHdvcmtzcGFjZSB9ID0gdGhpcy5hcHA7XG4gICAgICAgIGNvbnN0IGxlYWYgPSB3b3Jrc3BhY2UuZ2V0TGVhZihmYWxzZSk7XG4gICAgICAgIGNvbnN0IGxpbmUgPSBsLmxpbmVcbiAgICAgICAgY29uc3QgY2ggPSBsLmNoXG4gICAgICAgIFByb21pc2UucmVzb2x2ZSgpXG4gICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBsZWFmLm9wZW5GaWxlKHZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aChsLnBhdGgpIGFzIFRGaWxlLCB7IGFjdGl2ZSA6IHRydWUgfSk7XG4gICAgICAgIH0pXG4gICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICBjb25zdCBtYXJrZG93blZpZXcgPSBhcHAud29ya3NwYWNlLmdldEFjdGl2ZVZpZXdPZlR5cGUoTWFya2Rvd25WaWV3KTtcbiAgICAgICAgICBjb25zdCBlZGl0b3IgPSBtYXJrZG93blZpZXc/LmVkaXRvclxuICAgICAgICAgIGNvbnN0IHZhbHVlID0gbWFya2Rvd25WaWV3Py5nZXRWaWV3RGF0YSgpXG4gICAgICAgICAgaWYgKG1hcmtkb3duVmlldyA9PSBudWxsIHx8IGVkaXRvciA9PSBudWxsIHx8IHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgY29uc3QgZXJyb3JSZWFzb24gPSBgZWRpdG9yIG5vdCBleGlzdC4gQWJvcnRpbmcuLi5gXG4gICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvclJlYXNvbilcbiAgICAgICAgICB9XG4gICAgICAgICAgZWRpdG9yLnNldEN1cnNvcih7bGluZTogbGluZSwgY2g6IGNofSlcbiAgICAgICAgICBjb25zdCBjaDIgPSBlZGl0b3IuZ2V0TGluZShsaW5lKS5sZW5ndGhcbiAgICAgICAgICBpZiAoY2ggIT0gMClcbiAgICAgICAgICB7XG4gICAgICAgICAgICBlZGl0b3Iuc2V0U2VsZWN0aW9uKHtsaW5lOiBsaW5lLCBjaDogMH0sIHtsaW5lOiBsaW5lLCBjaDogY2gyfSlcbiAgICAgICAgICB9XG4gICAgICAgICAgZWRpdG9yLnNjcm9sbEludG9WaWV3KHtmcm9tOiB7bGluZTogbGluZSwgY2g6IGNofSwgdG86IHtsaW5lOiBsaW5lLCBjaDogY2h9fSwgdHJ1ZSlcbiAgICAgICAgICAvL2VkaXRvci5tYXJrVGV4dCh7bGluZTogbGluZSwgY2g6IGNofSwge2xpbmU6IGxpbmUgKyAxLCBjaDogY2ggKyAzfSwge2NsYXNzTmFtZTogXCJteS1oaWdobGlnaHRcIn0pXG5cbiAgICAgICAgICAvLyBQT0MgdGVzdGluZyBoaWdobGlnaHQgdGhlIGxpbmUgaWYgc2VsZWN0ZWQsIGJ1dCBmYWlsZWRcbiAgICAgICAgICAvKlxuICAgICAgICAgIGNvbnN0IGxpbmVDb250ZW50ID0gZWRpdG9yLmdldExpbmUobGluZSk7XG4gICAgICAgICAgY29uc3QgbGluZUVsZW1lbnRzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLkNvZGVNaXJyb3ItbGluZScpO1xuICAgICAgICAgIGxldCBsaW5lRWxlbWVudDogSFRNTEVsZW1lbnQgfCBudWxsID0gbnVsbDtcblxuICAgICAgICAgIGxpbmVFbGVtZW50cy5mb3JFYWNoKChlbCkgPT4ge1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhlbClcbiAgICAgICAgICAgICAgaWYgKGVsLnRleHRDb250ZW50ID09PSBsaW5lQ29udGVudCkge1xuICAgICAgICAgICAgICAgICAgbGluZUVsZW1lbnQgPSBlbCBhcyBIVE1MRWxlbWVudDtcbiAgICAgICAgICAgICAgICAgIC8vIEFkZCB0aGUgXCJpcy1mbGFzaGluZ1wiIGNsYXNzIHRvIHRoZSBsaW5lIGVsZW1lbnRcbiAgICAgICAgICAgICAgICAgIGxpbmVFbGVtZW50LmNsYXNzTGlzdC5hZGQoJ2lzLWZsYXNoaW5nJyk7XG5cbiAgICAgICAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgaGlnaGxpZ2h0IHdoZW4gY2xpY2tpbmcgZWxzZXdoZXJlXG4gICAgICAgICAgICAgICAgICBjb25zdCByZW1vdmVIaWdobGlnaHQgPSAoZXZlbnQ6IE1vdXNlRXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAobGluZUVsZW1lbnQgIT0gbnVsbCAmJiAhbGluZUVsZW1lbnQuY29udGFpbnMoZXZlbnQudGFyZ2V0IGFzIE5vZGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVFbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoJ2lzLWZsYXNoaW5nJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgcmVtb3ZlSGlnaGxpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCByZW1vdmVIaWdobGlnaHQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgKi9cbiAgICAgICAgIFxuICAgICAgICAgIC8vIGZpbmlzaCB0ZXN0XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG4gICAgICB9KVxuICAgICAgLmNhdGNoKChyZWFzb24pID0+IHsgXG4gICAgICAgICAgbmV3IE5vdGljZShyZWFzb24pXG4gICAgICB9KVxuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGlmIChsLnR5cGUgPT09IFwidyBcIiB8fCBsLnR5cGUgPT09IFwiaiBcIikge1xuICAgICAgd2luZG93Lm9wZW4obC5wYXRoLCAnX2JsYW5rJyk7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgY29uc3QgbGluZSA9IGwubGluZVxuICAgIGNvbnN0IGNoID0gbC5jaFxuICAgIHRoaXMuZWRpdG9yLnNldEN1cnNvcih7bGluZTogbGluZSwgY2g6IGNofSlcbiAgICB0aGlzLmVkaXRvci5zY3JvbGxJbnRvVmlldyh7ZnJvbToge2xpbmU6IGxpbmUsIGNoOiBjaH0sIHRvOiB7bGluZTogbGluZSwgY2g6IGNofX0sIHRydWUpXG4gICAgLy90aGlzLmVkaXRvci5tYXJrVGV4dCh7bGluZTogbGluZSwgY2g6IGNofSwge2xpbmU6IGxpbmUgKyAxLCBjaDogY2h9LCB7Y2xhc3NOYW1lOiBcIm15LWhpZ2hsaWdodFwifSlcbiAgICByZXR1cm5cbiAgfVxufVxuIiwgImltcG9ydCB7IEFwcCwgVEZpbGUgfSBmcm9tIFwib2JzaWRpYW5cIlxuaW1wb3J0IHsgTGlua1R5cGUgfSBmcm9tIFwiLi9saW5rVHlwZVwiXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRDaGlsZGxpbmtJdGVtcyhhcHA6IEFwcCwgZmlsZSA6IFRGaWxlKTogTGlua1R5cGVbXSB7XG4gICAgY29uc3QgYmFja2xpbmtzID0gYXBwLm1ldGFkYXRhQ2FjaGUuZ2V0QmFja2xpbmtzRm9yRmlsZShmaWxlKVxuICAgIGNvbnN0IGJhY2tsaW5rc0RhdGEgPSBiYWNrbGlua3M/LmRhdGFcbiAgICBpZiAoIWJhY2tsaW5rc0RhdGEpIHtcbiAgICAgIHJldHVybiBbXVxuICAgIH1cbiAgICBsZXQgY2hpbGRMaW5rUmVzdWx0ID0gW11cbiAgICBmb3IgKGxldCBpIGluIGJhY2tsaW5rc0RhdGEpIHtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgYmFja2xpbmtzRGF0YVtpXS5sZW5ndGg7IGorKykge1xuICAgICAgICBjb25zdCBpbmRleCA9IGJhY2tsaW5rc0RhdGFbaV0ubGVuZ3RoID4gMSA/IFwiW1wiICsgaiArIFwiXVwiIDogXCJcIlxuICAgICAgICBpZiAoaSAhPSBmaWxlLnBhdGgpIHtcbiAgICAgICAgICBjb25zdCBrZXkgPSBiYWNrbGlua3NEYXRhW2ldW2pdWydrZXknXVxuICAgICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgICAgIGNoaWxkTGlua1Jlc3VsdC5wdXNoKHtwYXRoOiBpLCB0eXBlOiBcInYgXCIsIGluZGV4OiBpbmRleCwgaGVhZGluZzogXCJcIiwgbGluZTogMCwgY2g6IDB9KSAgXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjaGlsZExpbmtSZXN1bHRcbiAgfSIsICJpbXBvcnQgeyBBcHAsIEZ1enp5U3VnZ2VzdE1vZGFsLCBGdXp6eU1hdGNoLCBOb3RpY2UsIENhY2hlZE1ldGFkYXRhLCBwYXJzZUZyb250TWF0dGVyVGFncywgcGFyc2VGcm9udE1hdHRlckFsaWFzZXMsIFRGaWxlLCBNYXJrZG93blZpZXcgfSBmcm9tIFwib2JzaWRpYW5cIlxuaW1wb3J0IHsgZmlsZXNXaGVyZVRhZ0lzVXNlZCB9IGZyb20gXCJzZWxmdXRpbC9maW5kTm90ZXNGcm9tVGFnXCJcbmltcG9ydCB7IGdldE5vdGVUeXBlIH0gZnJvbSBcInNlbGZ1dGlsL2dldFRhc2tUYWdcIlxuaW1wb3J0IHsgTm90ZVdpdGhIZWFkZXIsIFNFUEFSQVRPUiB9IGZyb20gXCJzZWxmdXRpbC9ub3RlV2l0aEhlYWRlclwiXG5pbXBvcnQgbW9tZW50IGZyb20gJ21vbWVudCc7XG5cbmNvbnN0IEJBQ0tfVE9fU0VMRUNUX1RBRyA9IFwiQmFjayB0byBzZWxlY3QgdGFnXCJcbmNvbnN0IE9QRU5fSU5fU0VBUkNIX01PREUgPSBcIk9wZW4gaW4gc2VhcmNoIG1vZGVcIlxuXG5leHBvcnQgY2xhc3MgTmF2aWdhdGVSZXdyaXRhYmxlVGhyZWFkc01vZGFsIGV4dGVuZHMgRnV6enlTdWdnZXN0TW9kYWw8Tm90ZVdpdGhIZWFkZXI+IHtcblxuICB0YWdUb0ZpbmQ6IHN0cmluZ1xuICBrZXlkb3duSGFuZGxlcjogKGV2ZW50OiBLZXlib2FyZEV2ZW50KSA9PiB2b2lkO1xuXG4gIGNvbnN0cnVjdG9yKGFwcDogQXBwKVxuICB7XG4gICAgc3VwZXIoYXBwKVxuICAgIHRoaXMudGFnVG9GaW5kID0gXCIjYy90L3BcIlxuICAgIHRoaXMuc2V0UGxhY2Vob2xkZXIoYFdoaWNoIHB1Ymxpc2hlZCBub3RlcyBkbyB5b3Ugd2FudCB0byByZXdyaXRlP2ApXG4gICAgdGhpcy5zZXRJbnN0cnVjdGlvbnMoW1xuICAgICAge1xuICAgICAgICBjb21tYW5kOiBcIlwiLFxuICAgICAgICBwdXJwb3NlOiBgV2hpY2ggcHVibGlzaGVkIG5vdGVzIGRvIHlvdSB3YW50IHRvIHJld3JpdGU/YFxuICAgICAgfVxuICAgIF0pO1xuICB9XG5cbiAgZ2V0SXRlbXMoKTogTm90ZVdpdGhIZWFkZXJbXSB7XG4gICAgY29uc3QgZmlsZVBhdGhzIDogc3RyaW5nW10gPSBmaWxlc1doZXJlVGFnSXNVc2VkKHRoaXMudGFnVG9GaW5kKVxuICAgIHJldHVybiBmaWxlUGF0aHMuZmlsdGVyKChmKSA9PiB7XG4gICAgICBjb25zdCB0aW1lID0gZi5yZXBsYWNlKC8uKihcXGRcXGRcXGRcXGRcXGRcXGRcXGRcXGQpLiovLFwiJDFcIilcbiAgICAgIGlmICgvXFxkXFxkXFxkXFxkXFxkXFxkXFxkXFxkLy50ZXN0KHRpbWUpKSB7XG4gICAgICAgIGNvbnN0IG9sZERhdGUgPSBtb21lbnQodGltZSwgJ1lZWVlNTUREJyk7XG4gICAgICAgIGNvbnN0IHRvZGF5ID0gbW9tZW50KCk7XG4gICAgICAgIGNvbnN0IGRpZmYgPSB0b2RheS5kaWZmKG9sZERhdGUsICdkYXlzJyk7XG4gICAgICAgIHJldHVybiBkaWZmID4gOTBcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH0pLm1hcChmID0+IHsgcmV0dXJuIHtub3RlUGF0aDogZiwgaGVhZGVyOiBcIlwiLCBzdGFydExpbmU6IDAsIG5vdGVUeXBlOiBnZXROb3RlVHlwZShmKX0gfSk7XG4gIH1cblxuICBnZXRJdGVtVGV4dChwYXRoOiBOb3RlV2l0aEhlYWRlcik6IHN0cmluZyB7XG4gICAgcmV0dXJuIHBhdGgubm90ZVBhdGggKyBwYXRoLmhlYWRlcjtcbiAgfVxuXG4gIC8vIFJlbmRlcnMgZWFjaCBzdWdnZXN0aW9uIGl0ZW0uXG4gIHJlbmRlclN1Z2dlc3Rpb24ocGF0aDogRnV6enlNYXRjaDxOb3RlV2l0aEhlYWRlcj4sIGVsOiBIVE1MRWxlbWVudCkge1xuICAgIGNvbnN0IGl0ZW06IE5vdGVXaXRoSGVhZGVyID0gcGF0aC5pdGVtXG4gICAgY29uc3QgcGF0aEl0ZW06IHN0cmluZyA9IGl0ZW0ubm90ZVBhdGhcbiAgICBsZXQgcHJlZml4ID0gaXRlbS5ub3RlVHlwZSA/IChpdGVtLm5vdGVUeXBlLnByZWZpeCA/IGl0ZW0ubm90ZVR5cGUucHJlZml4ICsgXCIgXCIgOiBcIlwiKSA6IFwiXCJcbiAgICBlbC5jcmVhdGVFbChcImRpdlwiLCB7IHRleHQ6IHByZWZpeCArIHBhdGhJdGVtIH0pO1xuICAgIGlmIChwYXRoLml0ZW0uaGVhZGVyLmxlbmd0aCA+IDApIHtcbiAgICAgIGVsLmNyZWF0ZUVsKFwic21hbGxcIiwgeyB0ZXh0OiBpdGVtLmhlYWRlcn0pXG4gICAgfVxuICB9XG5cbiAgLy8gUGVyZm9ybSBhY3Rpb24gb24gdGhlIHNlbGVjdGVkIHN1Z2dlc3Rpb24uXG4gIG9uQ2hvb3NlSXRlbShwYXRoOiBOb3RlV2l0aEhlYWRlciwgZXZ0OiBNb3VzZUV2ZW50IHwgS2V5Ym9hcmRFdmVudCkge1xuICAgIGNvbnN0IHsgdmF1bHQsIHdvcmtzcGFjZSB9ID0gdGhpcy5hcHA7XG4gICAgY29uc3QgbGVhZiA9IHdvcmtzcGFjZS5nZXRMZWFmKGZhbHNlKTtcbiAgICBQcm9taXNlLnJlc29sdmUoKVxuICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgcmV0dXJuIGxlYWYub3BlbkZpbGUodmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKHBhdGgubm90ZVBhdGgpIGFzIFRGaWxlLCB7IGFjdGl2ZSA6IHRydWUgfSk7XG4gICAgICAgIFxuICAgIH0pXG4gICAgLnRoZW4oKCkgPT4ge1xuICAgICAgY29uc3QgbWFya2Rvd25WaWV3ID0gYXBwLndvcmtzcGFjZS5nZXRBY3RpdmVWaWV3T2ZUeXBlKE1hcmtkb3duVmlldyk7XG4gICAgICBjb25zdCBlZGl0b3IgPSBtYXJrZG93blZpZXc/LmVkaXRvclxuICAgICAgaWYgKG1hcmtkb3duVmlldyA9PSBudWxsIHx8IGVkaXRvciA9PSBudWxsKSB7XG4gICAgICAgICAgY29uc3QgZXJyb3JSZWFzb24gPSBgZWRpdG9yIG9yIHZhbHVlICR7cGF0aC5ub3RlUGF0aH0gbm90IGV4aXN0LiBBYm9ydGluZy4uLmBcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3JSZWFzb24pXG4gICAgICB9XG4gICAgICBlZGl0b3Iuc2V0Q3Vyc29yKHtsaW5lOiBwYXRoLnN0YXJ0TGluZSwgY2g6IDB9KVxuICAgICAgICAgIC8vIHNjcm9sbCB0aGUgdmlldyB0byB0aGUgY3Vyc29yXG4gICAgICBlZGl0b3Iuc2Nyb2xsSW50b1ZpZXcoe2Zyb206IHtsaW5lOiBwYXRoLnN0YXJ0TGluZSwgY2g6IDB9LCB0bzoge2xpbmU6IHBhdGguc3RhcnRMaW5lLCBjaDogMH19LCB0cnVlKVxuICAgIH0pXG4gIH1cbn0iLCAiaW1wb3J0IHsgQXBwLCBFZGl0b3IsIEZ1enp5U3VnZ2VzdE1vZGFsLCBGdXp6eU1hdGNoLCBURmlsZSwgVmF1bHQsIE1hcmtkb3duVmlldywgTm90aWNlIH0gZnJvbSBcIm9ic2lkaWFuXCI7XG5pbXBvcnQgbW9tZW50IGZyb20gJ21vbWVudCc7XG5pbXBvcnQgeyByZW5hbWVUYWcgfSBmcm9tIFwidGFncmVuYW1lci9yZW5hbWluZ1wiO1xuaW1wb3J0IHsgTmF2aWdhdGVSZXdyaXRhYmxlVGhyZWFkc01vZGFsIH0gZnJvbSBcIm5hdmlnYXRlUmV3cml0YWJsZVRocmVhZHNNb2RhbFwiO1xuXG5pbnRlcmZhY2UgRmluZE9yUmV3cml0ZSB7XG4gIHR5cGU6IHN0cmluZztcbiAgZGVzY3JpcHRpb246IHN0cmluZztcbn1cblxuY29uc3QgQUxMX1RZUEVTID0gW1xuICB7XG4gICAgdHlwZTogXCJmaW5kXCIsXG4gICAgZGVzY3JpcHRpb246IFwiRmluZCBUaHJlYWRzIHRvIHJld3JpdGVcIlxuICB9LFxuICB7XG4gICAgdHlwZTogXCJyZXdyaXRlXCIsXG4gICAgZGVzY3JpcHRpb246IFwiUmV3cml0ZSBUaHJlYWRzXCJcbiAgfSxcbl07XG5cbmV4cG9ydCBjbGFzcyBSZXdyaXRlVGhyZWFkc01vZGFsIGV4dGVuZHMgRnV6enlTdWdnZXN0TW9kYWw8RmluZE9yUmV3cml0ZT4ge1xuXG4gIGVkaXRvcjogRWRpdG9yXG4gIHRhc2tUeXBlOiBTdHJpbmdcbiAgdmlldzogTWFya2Rvd25WaWV3XG5cbiAgY29uc3RydWN0b3IoYXBwOiBBcHAsIGVkaXRvcjogRWRpdG9yLCB2aWV3OiBNYXJrZG93blZpZXcpXG4gIHtcbiAgICBzdXBlcihhcHApXG4gICAgdGhpcy5lZGl0b3IgPSBlZGl0b3JcbiAgICB0aGlzLnZpZXcgPSB2aWV3XG4gICAgdGhpcy5zZXRQbGFjZWhvbGRlcihgRmluZCBvciBSZXdyaXRlP2ApXG4gIH1cblxuICBnZXRJdGVtcygpOiBGaW5kT3JSZXdyaXRlW10ge1xuICAgIHJldHVybiBBTExfVFlQRVM7XG4gIH1cblxuICBnZXRJdGVtVGV4dChub3RlVHlwZTogRmluZE9yUmV3cml0ZSk6IHN0cmluZyB7XG4gICAgcmV0dXJuIG5vdGVUeXBlLnR5cGU7XG4gIH1cblxuICAvLyBSZW5kZXJzIGVhY2ggc3VnZ2VzdGlvbiBpdGVtLlxuICByZW5kZXJTdWdnZXN0aW9uKGNob29zZW5Ob3RlVHlwZU1hdGNoOiBGdXp6eU1hdGNoPEZpbmRPclJld3JpdGU+LCBlbDogSFRNTEVsZW1lbnQpIHtcbiAgICBjb25zdCBub3RlVHlwZSA9IGNob29zZW5Ob3RlVHlwZU1hdGNoLml0ZW1cbiAgICBlbC5jcmVhdGVFbChcImRpdlwiLCB7IHRleHQ6IG5vdGVUeXBlLnR5cGUgfSk7XG4gICAgZWwuY3JlYXRlRWwoXCJzbWFsbFwiLCB7IHRleHQ6IG5vdGVUeXBlLmRlc2NyaXB0aW9uIH0pO1xuICB9XG5cbiAgY29udGFpbnNUeXBlKGxpbmU6IFN0cmluZykgOiBCb29sZWFuIHtcbiAgICByZXR1cm4gQUxMX1RZUEVTLmZpbHRlcigobm90ZVR5cGUpID0+IGxpbmUuY29udGFpbnMobm90ZVR5cGUudHlwZSkpLmxlbmd0aCA+IDBcbiAgfVxuXG4gIC8vIFBlcmZvcm0gYWN0aW9uIG9uIHRoZSBzZWxlY3RlZCBzdWdnZXN0aW9uLlxuICBhc3luYyBvbkNob29zZUl0ZW0oY2hvb3Nlbk9wZXJhdGlvbjogRmluZE9yUmV3cml0ZSwgZXZ0OiBNb3VzZUV2ZW50IHwgS2V5Ym9hcmRFdmVudCkge1xuICAgIGlmIChjaG9vc2VuT3BlcmF0aW9uLnR5cGUgPT09IFwiZmluZFwiKSB7XG4gICAgICBuZXcgTmF2aWdhdGVSZXdyaXRhYmxlVGhyZWFkc01vZGFsKHRoaXMuYXBwKS5vcGVuKClcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBpZiAoY2hvb3Nlbk9wZXJhdGlvbi50eXBlID09PSBcInJld3JpdGVcIikge1xuICAgICAgY29uc3QgeyB2YXVsdCB9ID0gdGhpcy5hcHA7XG5cdFx0XHRcdGxldCB2ID0gXCItLS1cXG50YWdzOiBjL3QvZFxcbi0tLVxcblxcblx1RDgzRVx1RERGNSBcXG5cXG5cXG4tLS1cXG5cXG4jIyBSZWZlcmVuY2VzXFxuXFxuLSBcXG5cXG5cIlxuXG5cdFx0XHRcdGNvbnN0IHBhdGggPSB0aGlzLnZpZXcuZmlsZS5wYXRoXG4gICAgICAgIGNvbnN0IGZpbGUgPSB0aGlzLnZpZXcuZmlsZVxuICAgICAgICBjb25zdCBlZGl0b3IgPSB0aGlzLmVkaXRvclxuXHRcdFx0XHRpZiAoIXBhdGgubWF0Y2goLy5cXC9UaHJlYWRzIFxcZFxcZFxcZFxcZFxcZFxcZFxcZFxcZC8pKSB7XG5cdFx0XHRcdFx0bmV3IE5vdGljZShgV2lsbCBub3QgcHJvY2VlZC4gSXQgaXMgbm90IGEgdGhyZWFkcyBwb3N0LmApO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0Y29uc3QgdG9kYXlZWVlZTU1ERCA9IG1vbWVudCgpLmZvcm1hdCgnWVlZWU1NREQnKTtcblx0XHRcdFx0Y29uc3QgbmV3UGF0aCA9IHBhdGgucmVwbGFjZSgvXiguXFwvVGhyZWFkcykgXFxkXFxkXFxkXFxkXFxkXFxkXFxkXFxkICguKikvLCBcIiQxIFwiICsgdG9kYXlZWVlZTU1ERCArIFwiICQyXCIpXG5cdFx0XHRcdGNvbnN0IG5ld05vdGVOYW1lID0gbmV3UGF0aC5yZXBsYWNlKC9eLlxcLy8sIFwiXCIpLnJlcGxhY2UoLy5tZCQvLCBcIlwiKVxuXG5cdFx0XHRcdGNvbnN0IHsgd29ya3NwYWNlIH0gPSB0aGlzLmFwcDtcblx0XHRcdFx0Y29uc3QgbGVhZiA9IHdvcmtzcGFjZS5nZXRMZWFmKGZhbHNlKTtcblx0XHRcdFx0UHJvbWlzZS5yZXNvbHZlKClcblx0XHRcdFx0LnRoZW4oKCkgPT4ge1xuXHRcdFx0XHRcdHJldHVybiB2YXVsdC5hZGFwdGVyLmV4aXN0cyhuZXdQYXRoKTtcblx0XHRcdFx0fSlcblx0XHRcdFx0LnRoZW4oKGZpbGVFeGlzdHMpID0+IHtcblx0XHRcdFx0XHRpZiAoZmlsZUV4aXN0cykge1xuXHRcdFx0XHRcdFx0bmV3IE5vdGljZShgV2lsbCBub3QgcHJvY2VlZC4gUmV3cml0dGVuIFRocmVhZCBwb3N0IHBvc3QgYWxyZWFkeSBleGlzdC5gKTtcblx0XHRcdFx0XHRcdHJldHVybiBQcm9taXNlLnJlamVjdChcIlRocmVhZHMgcG9zdCBhbHJlYWR5IGV4aXN0XCIpXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KS50aGVuKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRjb25zdCBiZWZvcmVUYWcgPSBcImMvdC9wXCJcblx0XHRcdFx0XHRjb25zdCBhZnRlclRhZyA9IFwiYy90L29cIlxuXHRcdFx0XHRcdHJldHVybiByZW5hbWVUYWcoZmlsZSwgYmVmb3JlVGFnLCBhZnRlclRhZylcblx0XHRcdFx0fSwgZnVuY3Rpb24gKGVycm9yKSB7XG5cdFx0XHRcdFx0bmV3IE5vdGljZShgZXJyb3Igd2hlbiByZW5hbWUgdGFnIWApO1xuXHRcdFx0XHR9KVxuXHRcdFx0XHQudGhlbigocmVuYW1lU3VjY2VzcykgPT4ge1xuXHRcdFx0XHRcdGlmICghcmVuYW1lU3VjY2Vzcykge1xuXHRcdFx0XHRcdFx0bmV3IE5vdGljZShgV2lsbCBub3QgcHJvY2VlZC4gVGhlIG9sZCBwb3N0IG5vdCBwdWJsaXNoZWQgKG5vdCBjL3QvcCkuYCk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gUHJvbWlzZS5yZWplY3QoXCJXaWxsIG5vdCBwcm9jZWVkLiBUaGUgb2xkIHBvc3Qgbm90IHB1Ymxpc2hlZCAobm90IGMvdC9wKS5cIilcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y29uc3QgdmFsdWUgPSBlZGl0b3IuZ2V0VmFsdWUoKTtcblx0XHRcdFx0XHRsZXQgbW9kaWZpZWRWYWx1ZVxuXHRcdFx0XHRcdGlmICgvLS0tXFxuXFxuIyMgW1JyXWVmZXJlbmNlW3NdKls6XSpcXG5cXG4vbS50ZXN0KHZhbHVlKSkge1xuXHRcdFx0XHRcdFx0bW9kaWZpZWRWYWx1ZSA9IHZhbHVlLnJlcGxhY2UoLygjIyBbUnJdZWZlcmVuY2Vbc10qWzpdKlxcblxcbikvbSwgXCIkMS0gUmV3cml0ZTogW1tcIiArIG5ld05vdGVOYW1lICsgXCJdXVxcblwiKVxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoLy0tLVtcXG5cXHNdKiQvLnRlc3QodmFsdWUpKSB7IC8vIGVuZCB3aXRoIC0tLVxuXHRcdFx0XHRcdFx0bW9kaWZpZWRWYWx1ZSA9IHZhbHVlICsgXCJcXG5cXG4jIyBSZWZlcmVuY2VzXFxuXFxuLSBSZXdyaXRlOiBbW1wiICsgbmV3Tm90ZU5hbWUgKyBcIl1dXFxuXCJcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0bW9kaWZpZWRWYWx1ZSA9IHZhbHVlICsgXCJcXG4tLS1cXG5cXG4jIyBSZWZlcmVuY2VzXFxuXFxuLSBSZXdyaXRlOiBbW1wiICsgbmV3Tm90ZU5hbWUgKyBcIl1dXFxuXCJcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWRpdG9yLnNldFZhbHVlKG1vZGlmaWVkVmFsdWUpXG5cdFx0XHRcdFx0cmV0dXJuIHZhdWx0LmNyZWF0ZShuZXdQYXRoLCB2KTtcblx0XHRcdFx0fSlcblx0XHRcdFx0LnRoZW4oKHRGaWxlKSA9PiB7XG5cdFx0XHRcdFx0cmV0dXJuIGxlYWYub3BlbkZpbGUodEZpbGUsIHsgYWN0aXZlIDogdHJ1ZX0pO1xuXHRcdFx0XHR9LCByZWFzb24gPT4ge30pXG5cdFx0XHRcdC50aGVuKCgpID0+IHtcblx0XHRcdFx0XHRuZXcgTm90aWNlKGBDcmVhdGVkIGFuZCBvcGVuZWQgVGhyZWFkcyBub3RlcyBmb3IgcmV3cml0ZSFgKTtcblx0XHRcdFx0fSk7XG4gICAgICByZXR1cm5cbiAgICB9XG4gIH1cbn0iLCAiaW1wb3J0IHsgSXRlbVZpZXcsIFdvcmtzcGFjZUxlYWYsIFRGaWxlLCBLZXltYXAsIFBhbmVUeXBlLCBOb3RpY2UsIE1lbnUsIE1hcmtkb3duVmlldywgQ2FjaGVkTWV0YWRhdGEsIFBsYXRmb3JtIH0gZnJvbSAnb2JzaWRpYW4nO1xuaW1wb3J0IHsgZmlsZXNXaGVyZVRhZ0lzVXNlZCB9IGZyb20gJ3NlbGZ1dGlsL2ZpbmROb3Rlc0Zyb21UYWcnO1xuaW1wb3J0IHsgZ2V0Tm90ZVR5cGUgfSBmcm9tICdzZWxmdXRpbC9nZXRUYXNrVGFnJztcblxuY29uc3QgVklFV19UWVBFX05PVEVfTElTVCA9ICdub3RlLWxpc3Qtdmlldyc7XG5cbmludGVyZmFjZSBOb3Rlc1R5cGVWaWV3RGF0YSB7XG4gIHRpdGxlOiBzdHJpbmc7XG4gIGxpbmVJbmZvOiBMaW5lSW5mb1tdO1xuICBmaWxlOiBURmlsZSB8IG51bGw7XG59XG5cbmludGVyZmFjZSBMaW5lSW5mbyB7XG4gIGNvbnRlbnQ6IHN0cmluZztcbiAgbGluZTogbnVtYmVyO1xufVxuXG5jbGFzcyBOb3Rlc1R5cGVWaWV3IGV4dGVuZHMgSXRlbVZpZXcge1xuICBwdWJsaWMgbm90ZXNUeXBlVGFnOiBzdHJpbmdcbiAgY29uc3RydWN0b3IobGVhZjogV29ya3NwYWNlTGVhZiwgbm90ZXNUeXBlVGFnOiBzdHJpbmcpIHtcbiAgICBzdXBlcihsZWFmKTtcbiAgICB0aGlzLm5vdGVzVHlwZVRhZyA9IG5vdGVzVHlwZVRhZ1xuICB9XG5cbiAgZ2V0Vmlld1R5cGUoKSB7XG4gICAgcmV0dXJuIFZJRVdfVFlQRV9OT1RFX0xJU1Q7XG4gIH1cblxuICBnZXREaXNwbGF5VGV4dCgpIHtcbiAgICByZXR1cm4gJ1RhZ2dlZCBOb3Rlcyc7XG4gIH1cblxuICBhc3luYyBvbk9wZW4oKSB7XG4gICAgdGhpcy5yZWRyYXcoKTtcbiAgfVxuXG4gIHB1YmxpYyBnZXRJY29uKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuICdoYXNoJztcbiAgfVxuXG4gIHB1YmxpYyByZWFkb25seSByZWRyYXcgPSBhc3luYyAoKTogUHJvbWlzZTx2b2lkPiA9PiB7XG4gICAgLy9jb25zb2xlLmxvZyhcInJlZHJhdygpXCIpXG4gICAgLy9jb25zdCB0YWcgPSBcIiNjL3QvcFwiXG4gICAgXG5cbiAgICB0aGlzLmNvbnRhaW5lckVsLmVtcHR5KCk7XG5cbiAgICBpZiAodGhpcy5ub3Rlc1R5cGVUYWcubGVuZ3RoIDw9IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBcbiAgICB0aGlzLmNvbnRhaW5lckVsLmNyZWF0ZURpdih7IGNsczogJ25hdi1oZWFkZXInLCB0ZXh0OiBcIlRhZ3M6IFwiICsgdGhpcy5ub3Rlc1R5cGVUYWcgfSk7XG5cbiAgICBjb25zdCByb290RWwgPSB0aGlzLmNvbnRhaW5lckVsLmNyZWF0ZURpdih7IGNsczogJ25hdi1mb2xkZXIgbW9kLXJvb3Qgc2Nyb2xsYWJsZScgfSk7XG4gICAgY29uc3QgY2hpbGRyZW5FbCA9IHJvb3RFbC5jcmVhdGVEaXYoeyBjbHM6ICduYXYtZm9sZGVyLWNoaWxkcmVuJyB9KTtcblxuICAgIGNvbnN0IGxlbmd0aCA9IHRoaXMubm90ZXNUeXBlVGFnLnNwbGl0KFwiIFwiKS5sZW5ndGhcbiAgICBjb25zdCB0YWcxID0gdGhpcy5ub3Rlc1R5cGVUYWcuc3BsaXQoXCIgXCIpWzBdXG4gICAgY29uc3QgdGFnMiA9IGxlbmd0aCA+IDEgPyB0aGlzLm5vdGVzVHlwZVRhZy5zcGxpdChcIiBcIilbMV0gOiBcIlwiXG5cbiAgICBjb25zdCBmaWxlcyA6IFRGaWxlW10gPSBmaWxlc1doZXJlVGFnSXNVc2VkKHRhZzEpLm1hcChmaWxlUGF0aCA9PiB0aGlzLmFwcC52YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgoZmlsZVBhdGgpIGFzIFRGaWxlKVxuXG4gICAgbGV0IG5vdGVEYXRhczogTm90ZXNUeXBlVmlld0RhdGFbXSA9IGF3YWl0IFByb21pc2UuYWxsKGZpbGVzLm1hcChhc3luYyAoZikgPT4ge1xuICAgICAgbGV0IG5vdGVUeXBlID0gZ2V0Tm90ZVR5cGUoZi5wYXRoKVxuICAgICAgbGV0IHByZWZpeCA9IG5vdGVUeXBlID8gbm90ZVR5cGUucHJlZml4ICsgXCIgXCIgOiBcIlwiXG5cbiAgICAgIGNvbnN0IGlzQWN0aW9uVGFnID0gKCEvXiNbYS16XVxcL1thLXpdXFwvW2Etel0kLy50ZXN0KHRhZzEpXG4gICAgICAmJiAhL14jW2Etel1cXC9bYS16XSQvLnRlc3QodGFnMSlcbiAgICAgICYmICEvXiNbYS16XSQvLnRlc3QodGFnMSkpIHx8IHRhZzIubGVuZ3RoID4gMFxuXG4gICAgICBsZXQgbGluZUluZm86IExpbmVJbmZvW10gPSBbXVxuXG4gICAgICBpZiAoaXNBY3Rpb25UYWcpIHtcbiAgICAgICAgY29uc3QgYWN0aW9uVGFnID0gdGFnMi5sZW5ndGggPiAwID8gdGFnMiA6IHRhZzFcbiAgICAgICAgY29uc3QgZmlsZUNhY2hlID0gdGhpcy5hcHAubWV0YWRhdGFDYWNoZS5nZXRGaWxlQ2FjaGUoZik7XG4gICAgICAgIGlmIChmaWxlQ2FjaGUgJiYgZmlsZUNhY2hlLnRhZ3MpIHtcbiAgICAgICAgICBjb25zdCBjb250ZW50ID0gYXdhaXQgdGhpcy5hcHAudmF1bHQucmVhZChmKTtcbiAgICAgICAgICBjb25zdCBmaWxlTGluZXMgPSBjb250ZW50LnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICBmb3IgKGNvbnN0IHRhZyBvZiBmaWxlQ2FjaGUudGFncykge1xuICAgICAgICAgICAgaWYgKHRhZy50YWcgPT09IGFjdGlvblRhZykge1xuICAgICAgICAgICAgICBjb25zdCBoZWFkaW5nID0gdGhpcy5nZXRIZWFkaW5nRm9yTGluZShmaWxlQ2FjaGUsIHRhZy5wb3NpdGlvbi5zdGFydC5saW5lKTtcbiAgICAgICAgICAgICAgY29uc3QgbGluZUNvbnRlbnQgPSBmaWxlTGluZXNbdGFnLnBvc2l0aW9uLnN0YXJ0LmxpbmVdLnRyaW0oKTtcbiAgICAgICAgICAgICAgY29uc3QgbmV3TGluZUlmTmVlZGVkID0gaGVhZGluZy5sZW5ndGggIT0gMCA/ICh0aGlzLmlzV2luZG93cygpID8gXCJcXHJcXG5cIiA6IFwiXFxuXCIpIDogXCJcIiBcbiAgICAgICAgICAgICAgbGluZUluZm8ucHVzaCh7XG4gICAgICAgICAgICAgICAgY29udGVudDogaGVhZGluZyArIG5ld0xpbmVJZk5lZWRlZCArIGxpbmVDb250ZW50LCBcbiAgICAgICAgICAgICAgICBsaW5lOiB0YWcucG9zaXRpb24uc3RhcnQubGluZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHRhZzIubGVuZ3RoID4gMCkge1xuICAgICAgICBpZiAobGluZUluZm8ubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0aXRsZTogcHJlZml4ICsgZi5iYXNlbmFtZSxcbiAgICAgICAgICAgIGxpbmVJbmZvOiBsaW5lSW5mbyxcbiAgICAgICAgICAgIGZpbGU6IGZcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0aXRsZTogXCJpbnZhbGlkXCIsXG4gICAgICAgICAgICBsaW5lSW5mbzogW10sXG4gICAgICAgICAgICBmaWxlOiBudWxsXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0aXRsZTogcHJlZml4ICsgZi5iYXNlbmFtZSxcbiAgICAgICAgbGluZUluZm86IGxpbmVJbmZvLFxuICAgICAgICBmaWxlOiBmXG4gICAgICB9O1xuICAgIH0pKTtcblxuICAgIG5vdGVEYXRhcy5mb3JFYWNoKGRhdGEgPT4ge1xuICAgICAgaWYgKGRhdGEuZmlsZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgbmF2RmlsZSA9IGNoaWxkcmVuRWwuY3JlYXRlRGl2KHtcbiAgICAgICAgY2xzOiAndHJlZS1pdGVtIG5hdi1maWxlIHJlY2VudC1maWxlcy1maWxlJyxcbiAgICAgIH0pO1xuICAgICAgY29uc3QgbmF2RmlsZVRpdGxlID0gbmF2RmlsZS5jcmVhdGVEaXYoe1xuICAgICAgICBjbHM6ICd0cmVlLWl0ZW0tc2VsZiBpcy1jbGlja2FibGUgbmF2LWZpbGUtdGl0bGUgcmVjZW50LWZpbGVzLXRpdGxlJyxcbiAgICAgIH0pO1xuICAgICAgY29uc3QgbmF2RmlsZVRpdGxlQ29udGVudCA9IG5hdkZpbGVUaXRsZS5jcmVhdGVEaXYoe1xuICAgICAgICBjbHM6ICd0cmVlLWl0ZW0taW5uZXIgbmF2LWZpbGUtdGl0bGUtY29udGVudCByZWNlbnQtZmlsZXMtdGl0bGUtY29udGVudCBpbnRlcm5hbC1saW5rIHNlbGYtd3JhcC1jb250ZW50JyxcbiAgICAgIH0pO1xuXG4gICAgICBuYXZGaWxlVGl0bGVDb250ZW50LnNldFRleHQoZGF0YS50aXRsZSk7XG5cbiAgICAgIG5hdkZpbGVUaXRsZS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW92ZXInLCAoZXZlbnQ6IE1vdXNlRXZlbnQpID0+IHtcbiAgICAgICAgaWYgKCFkYXRhLmZpbGU/LnBhdGgpIHJldHVybjtcblxuICAgICAgICB0aGlzLmFwcC53b3Jrc3BhY2UudHJpZ2dlcignaG92ZXItbGluaycsIHtcbiAgICAgICAgICBldmVudCxcbiAgICAgICAgICBzb3VyY2U6IFZJRVdfVFlQRV9OT1RFX0xJU1QsXG4gICAgICAgICAgaG92ZXJQYXJlbnQ6IHJvb3RFbCxcbiAgICAgICAgICB0YXJnZXRFbDogbmF2RmlsZSxcbiAgICAgICAgICBsaW5rdGV4dDogZGF0YS5maWxlLnBhdGgsXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIG5hdkZpbGVUaXRsZS5hZGRFdmVudExpc3RlbmVyKCdjb250ZXh0bWVudScsIChldmVudDogTW91c2VFdmVudCkgPT4ge1xuICAgICAgICBpZiAoIWRhdGEuZmlsZT8ucGF0aCkgcmV0dXJuO1xuXG4gICAgICAgIGNvbnN0IG1lbnUgPSBuZXcgTWVudSgpO1xuICAgICAgICBtZW51LmFkZEl0ZW0oKGl0ZW0pID0+XG4gICAgICAgICAgaXRlbVxuICAgICAgICAgICAgLnNldFNlY3Rpb24oJ2FjdGlvbicpXG4gICAgICAgICAgICAuc2V0VGl0bGUoJ09wZW4gaW4gbmV3IHRhYicpXG4gICAgICAgICAgICAuc2V0SWNvbignZmlsZS1wbHVzJylcbiAgICAgICAgICAgIC5vbkNsaWNrKCgpID0+IHtcbiAgICAgICAgICAgICAgdGhpcy5mb2N1c0ZpbGVBdExpbmUoZGF0YS5maWxlLCAndGFiJywgMCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgICAgICBjb25zdCBmaWxlID0gdGhpcy5hcHAudmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKGRhdGEuZmlsZT8ucGF0aCk7XG4gICAgICAgIHRoaXMuYXBwLndvcmtzcGFjZS50cmlnZ2VyKFxuICAgICAgICAgICdmaWxlLW1lbnUnLFxuICAgICAgICAgIG1lbnUsXG4gICAgICAgICAgZmlsZSxcbiAgICAgICAgICAnbGluay1jb250ZXh0LW1lbnUnLFxuICAgICAgICApO1xuICAgICAgICBtZW51LnNob3dBdFBvc2l0aW9uKHsgeDogZXZlbnQuY2xpZW50WCwgeTogZXZlbnQuY2xpZW50WSB9KTtcbiAgICAgIH0pO1xuXG4gICAgICBuYXZGaWxlVGl0bGUuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZXZlbnQ6IE1vdXNlRXZlbnQpID0+IHtcbiAgICAgICAgaWYgKCFkYXRhKSByZXR1cm47XG5cbiAgICAgICAgY29uc3QgbmV3TGVhZiA9IEtleW1hcC5pc01vZEV2ZW50KGV2ZW50KVxuICAgICAgICB0aGlzLmZvY3VzRmlsZUF0TGluZShkYXRhLmZpbGUsIG5ld0xlYWYsIDApO1xuICAgICAgfSk7XG5cbiAgICAgIC8vID09PT09PT09PT09PT1cblxuICAgICAgZm9yIChjb25zdCBsaW5lSW5mbyBvZiBkYXRhLmxpbmVJbmZvKSB7XG4gICAgICAgIGNvbnN0IG5hdkZpbGVMaW5lID0gbmF2RmlsZS5jcmVhdGVEaXYoe1xuICAgICAgICAgIC8vY2xzOiAndHJlZS1pdGVtIG5hdi1maWxlIHJlY2VudC1maWxlcy1maWxlJyxcbiAgICAgICAgICBjbHM6ICd0cmVlLWl0ZW0tc2VsZiBpcy1jbGlja2FibGUgbmF2LWZpbGUtdGl0bGUgcmVjZW50LWZpbGVzLXRpdGxlJyxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IG5hdkZpbGVMaW5lQ29udGVudCA9IG5hdkZpbGVMaW5lLmNyZWF0ZURpdih7XG4gICAgICAgICAgY2xzOiAndHJlZS1pdGVtLWlubmVyIG5hdi1maWxlLXRpdGxlLWNvbnRlbnQgcmVjZW50LWZpbGVzLXRpdGxlLWNvbnRlbnQgaW50ZXJuYWwtbGluayBzZWxmLXdyYXAtY29udGVudCBzZWxmLXBhZGRpbmctbGVmdC0xMCcsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIG5hdkZpbGVMaW5lQ29udGVudC5pbm5lclRleHQgPSBsaW5lSW5mby5jb250ZW50O1xuXG4gICAgICAgIG5hdkZpbGVMaW5lLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlb3ZlcicsIChldmVudDogTW91c2VFdmVudCkgPT4ge1xuICAgICAgICAgIGlmICghZGF0YS5maWxlPy5wYXRoKSByZXR1cm47XG5cbiAgICAgICAgICB0aGlzLmFwcC53b3Jrc3BhY2UudHJpZ2dlcignaG92ZXItbGluaycsIHtcbiAgICAgICAgICAgIGV2ZW50LFxuICAgICAgICAgICAgc291cmNlOiBWSUVXX1RZUEVfTk9URV9MSVNULFxuICAgICAgICAgICAgaG92ZXJQYXJlbnQ6IHJvb3RFbCxcbiAgICAgICAgICAgIHRhcmdldEVsOiBuYXZGaWxlTGluZSxcbiAgICAgICAgICAgIGxpbmt0ZXh0OiBkYXRhLmZpbGUucGF0aCxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgbmF2RmlsZUxpbmUuYWRkRXZlbnRMaXN0ZW5lcignY29udGV4dG1lbnUnLCAoZXZlbnQ6IE1vdXNlRXZlbnQpID0+IHtcbiAgICAgICAgICBpZiAoIWRhdGEuZmlsZT8ucGF0aCkgcmV0dXJuO1xuXG4gICAgICAgICAgY29uc3QgbWVudSA9IG5ldyBNZW51KCk7XG4gICAgICAgICAgbWVudS5hZGRJdGVtKChpdGVtKSA9PlxuICAgICAgICAgICAgaXRlbVxuICAgICAgICAgICAgICAuc2V0U2VjdGlvbignYWN0aW9uJylcbiAgICAgICAgICAgICAgLnNldFRpdGxlKCdPcGVuIGluIG5ldyB0YWInKVxuICAgICAgICAgICAgICAuc2V0SWNvbignZmlsZS1wbHVzJylcbiAgICAgICAgICAgICAgLm9uQ2xpY2soKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZm9jdXNGaWxlQXRMaW5lKGRhdGEuZmlsZSwgJ3RhYicsIGxpbmVJbmZvLmxpbmUpO1xuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICk7XG4gICAgICAgICAgY29uc3QgZmlsZSA9IHRoaXMuYXBwLnZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aChkYXRhLmZpbGU/LnBhdGgpO1xuICAgICAgICAgIHRoaXMuYXBwLndvcmtzcGFjZS50cmlnZ2VyKFxuICAgICAgICAgICAgJ2ZpbGUtbWVudScsXG4gICAgICAgICAgICBtZW51LFxuICAgICAgICAgICAgZmlsZSxcbiAgICAgICAgICAgICdsaW5rLWNvbnRleHQtbWVudScsXG4gICAgICAgICAgKTtcbiAgICAgICAgICBtZW51LnNob3dBdFBvc2l0aW9uKHsgeDogZXZlbnQuY2xpZW50WCwgeTogZXZlbnQuY2xpZW50WSB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgbmF2RmlsZUxpbmUuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZXZlbnQ6IE1vdXNlRXZlbnQpID0+IHtcbiAgICAgICAgICBpZiAoIWRhdGEpIHJldHVybjtcblxuICAgICAgICAgIGNvbnN0IG5ld0xlYWYgPSBLZXltYXAuaXNNb2RFdmVudChldmVudClcbiAgICAgICAgICB0aGlzLmZvY3VzRmlsZUF0TGluZShkYXRhLmZpbGUsIG5ld0xlYWYsIGxpbmVJbmZvLmxpbmUpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuXG4gICAgICAvLyA9PT09PT09PT09PT09PT09PVxuXG4gICAgfSk7XG4gICAgXG4gIH1cblxuICBpc1dpbmRvd3MoKSB7XG4gICAgcmV0dXJuICFQbGF0Zm9ybS5pc0FuZHJvaWRBcHAgJiYgIVBsYXRmb3JtLmlzSW9zQXBwICYmICFQbGF0Zm9ybS5pc01hY09TICYmICFQbGF0Zm9ybS5pc1NhZmFyaVxuICB9XG5cbiAgYXN5bmMgb25DbG9zZSgpIHtcbiAgICAvLyBDbGVhbnVwIGlmIG5lY2Vzc2FyeVxuICB9XG5cbiAgcHJpdmF0ZSByZWFkb25seSBmb2N1c0ZpbGVBdExpbmUgPSAoZmlsZTogVEZpbGUsIG5ld0xlYWY6IGJvb2xlYW4gfCBQYW5lVHlwZSwgbGluZTogbnVtYmVyKTogdm9pZCA9PiB7XG4gICAgY29uc3QgdGFyZ2V0RmlsZSA9IHRoaXMuYXBwLnZhdWx0XG4gICAgICAuZ2V0RmlsZXMoKVxuICAgICAgLmZpbmQoKGYpID0+IGYucGF0aCA9PT0gZmlsZS5wYXRoKTtcblxuICAgIGlmICh0YXJnZXRGaWxlKSB7XG4gICAgICBjb25zdCBsZWFmID0gdGhpcy5hcHAud29ya3NwYWNlLmdldExlYWYobmV3TGVhZik7XG4gICAgICBsZWFmLm9wZW5GaWxlKHRhcmdldEZpbGUpLnRoZW4oKCkgPT4ge1xuICAgICAgICBjb25zdCB2aWV3ID0gdGhpcy5hcHAud29ya3NwYWNlLmdldEFjdGl2ZVZpZXdPZlR5cGUoTWFya2Rvd25WaWV3KTtcbiAgICAgICAgaWYgKHZpZXcpIHtcbiAgICAgICAgICB2aWV3LmVkaXRvci5zZXRDdXJzb3IoeyBsaW5lOiBsaW5lLCBjaDogMCB9KTtcbiAgICAgICAgICB2aWV3LmVkaXRvci5zY3JvbGxJbnRvVmlldyh7ZnJvbToge2xpbmU6IGxpbmUsIGNoOiAwfSwgdG86IHtsaW5lOiBsaW5lLCBjaDogMH19LCB0cnVlKVxuICAgICAgICAgIGlmIChsaW5lICE9IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGNoID0gdmlldy5lZGl0b3IuZ2V0TGluZShsaW5lKS5sZW5ndGg7XG4gICAgICAgICAgICB2aWV3LmVkaXRvci5zZXRTZWxlY3Rpb24oe2xpbmU6IGxpbmUsIGNoOiAwfSwge2xpbmU6IGxpbmUsIGNoOiBjaH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5ldyBOb3RpY2UoJ0Nhbm5vdCBmaW5kIGEgZmlsZSB3aXRoIHRoYXQgbmFtZScpO1xuICAgIH1cbiAgfTtcblxuXG5nZXRIZWFkaW5nRm9yTGluZShmaWxlQ2FjaGU6IENhY2hlZE1ldGFkYXRhLCBsaW5lTnVtYmVyOiBudW1iZXIpOiBzdHJpbmcge1xuICBpZiAoIWZpbGVDYWNoZSB8fCAhZmlsZUNhY2hlLmhlYWRpbmdzKSB7XG4gICAgcmV0dXJuIFwiXCI7XG4gIH1cblxuICBjb25zdCBoZWFkaW5ncyA9IGZpbGVDYWNoZS5oZWFkaW5ncztcbiAgbGV0IGN1cnJlbnRIZWFkaW5nID0gXCJcIjtcblxuICBmb3IgKGNvbnN0IGhlYWRpbmcgb2YgaGVhZGluZ3MpIHtcbiAgICBpZiAoaGVhZGluZy5wb3NpdGlvbi5zdGFydC5saW5lIDw9IGxpbmVOdW1iZXIpIHtcbiAgICAgIGN1cnJlbnRIZWFkaW5nID0gXCIjIFwiICsgaGVhZGluZy5oZWFkaW5nO1xuICAgIH0gZWxzZSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gY3VycmVudEhlYWRpbmc7XG59XG59XG5cbmV4cG9ydCB7IE5vdGVzVHlwZVZpZXcsIFZJRVdfVFlQRV9OT1RFX0xJU1QgfTsiXSwKICAibWFwcGluZ3MiOiAiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFBQSwyQ0FBQUEsU0FBQTtBQU1DLEtBQUMsU0FBVSxRQUFRLFNBQVM7QUFDekIsYUFBTyxZQUFZLFlBQVksT0FBT0EsWUFBVyxjQUFjQSxRQUFPLFVBQVUsUUFBUSxJQUN4RixPQUFPLFdBQVcsY0FBYyxPQUFPLE1BQU0sT0FBTyxPQUFPLElBQzNELE9BQU8sU0FBUyxRQUFRO0FBQUEsSUFDNUIsR0FBRSxTQUFPLFdBQVk7QUFBRTtBQUVuQixVQUFJO0FBRUosZUFBUyxRQUFRO0FBQ2IsZUFBTyxh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QUFBQSxFQUNBO0FBQUEsSUFDRSxNQUFNO0FBQUEsSUFDTixhQUFhO0FBQUEsSUFDYixRQUFRO0FBQUEsRUFDVjtBQUFBLEVBQ0E7QUFBQSxJQUNFLE1BQU07QUFBQSxJQUNOLGFBQWE7QUFBQSxJQUNiLFFBQVE7QUFBQSxFQUNWO0FBQUEsRUFDQTtBQUFBLElBQ0UsTUFBTTtBQUFBLElBQ04sYUFBYTtBQUFBLElBQ2IsUUFBUTtBQUFBLEVBQ1Y7QUFBQSxFQUNBO0FBQUEsSUFDRSxNQUFNO0FBQUEsSUFDTixhQUFhO0FBQUEsSUFDYixRQUFRO0FBQUEsRUFDVjtBQUFBLEVBQ0E7QUFBQSxJQUNFLE1BQU07QUFBQSxJQUNOLGFBQWE7QUFBQSxJQUNiLFFBQVE7QUFBQSxFQUNWO0FBQUEsRUFDQTtBQUFBLElBQ0UsTUFBTTtBQUFBLElBQ04sYUFBYTtBQUFBLElBQ2IsUUFBUTtBQUFBLEVBQ1Y7QUFBQSxFQUNBO0FBQUEsSUFDRSxNQUFNO0FBQUEsSUFDTixhQUFhO0FBQUEsSUFDYixRQUFRO0FBQUEsRUFDVjtBQUFBLEVBQ0E7QUFBQSxJQUNFLE1BQU07QUFBQSxJQUNOLGFBQWE7QUFBQSxJQUNiLFFBQVE7QUFBQSxFQUNWO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQTZCQTtBQUFBLElBQ0UsTUFBTTtBQUFBLElBQ04sYUFBYTtBQUFBLElBQ2IsUUFBUTtBQUFBLEVBQ1Y7QUFBQSxFQUNBO0FBQUEsSUFDRSxNQUFNO0FBQUEsSUFDTixhQUFhO0FBQUEsSUFDYixRQUFRO0FBQUEsRUFDVjtBQUFBLEVBQ0E7QUFBQSxJQUNFLE1BQU07QUFBQSxJQUNOLGFBQWE7QUFBQSxJQUNiLFFBQVE7QUFBQSxFQUNWO0FBQUEsRUFDQTtBQUFBLElBQ0UsTUFBTTtBQUFBLElBQ04sYUFBYTtBQUFBLElBQ2IsUUFBUTtBQUFBLEVBQ1Y7QUFBQSxFQUNBO0FBQUEsSUFDRSxNQUFNO0FBQUEsSUFDTixhQUFhO0FBQUEsSUFDYixRQUFRO0FBQUEsRUFDVjtBQUFBLEVBQ0E7QUFBQSxJQUNFLE1BQU07QUFBQSxJQUNOLGFBQWE7QUFBQSxJQUNiLFFBQVE7QUFBQSxFQUNWO0FBQUEsRUFDQTtBQUFBLElBQ0UsTUFBTTtBQUFBLElBQ04sYUFBYTtBQUFBLElBQ2IsUUFBUTtBQUFBLEVBQ1Y7QUFBQSxFQUNBO0FBQUEsSUFDRSxNQUFNO0FBQUEsSUFDTixhQUFhO0FBQUEsSUFDYixRQUFRO0FBQUEsRUFDVjtBQUFBLEVBQ0E7QUFBQSxJQUNFLE1BQU07QUFBQSxJQUNOLGFBQWE7QUFBQSxJQUNiLFFBQVE7QUFBQSxFQUNWO0FBQUEsRUFDQTtBQUFBLElBQ0UsTUFBTTtBQUFBLElBQ04sYUFBYTtBQUFBLElBQ2IsUUFBUTtBQUFBLEVBQ1Y7QUFBQSxFQUNBO0FBQUEsSUFDRSxNQUFNO0FBQUEsSUFDTixhQUFhO0FBQUEsSUFDYixRQUFRO0FBQUEsRUFDVjtBQUFBLEVBQ0E7QUFBQSxJQUNFLE1BQU07QUFBQSxJQUNOLGFBQWE7QUFBQSxJQUNiLFFBQVE7QUFBQSxFQUNWO0FBQUEsRUFDQTtBQUFBLElBQ0UsTUFBTTtBQUFBLElBQ04sYUFBYTtBQUFBLElBQ2IsUUFBUTtBQUFBLEVBQ1Y7QUFBQSxFQUNBO0FBQUEsSUFDRSxNQUFNO0FBQUEsSUFDTixhQUFhO0FBQUEsSUFDYixRQUFRO0FBQUEsRUFDVjtBQUFBLEVBQ0E7QUFBQSxJQUNFLE1BQU07QUFBQSxJQUNOLGFBQWE7QUFBQSxJQUNiLFFBQVE7QUFBQSxFQUNWO0FBQUEsRUFDQTtBQUFBLElBQ0UsTUFBTTtBQUFBLElBQ04sYUFBYTtBQUFBLElBQ2IsUUFBUTtBQUFBLEVBQ1Y7QUFBQSxFQUNBO0FBQUEsSUFDRSxNQUFNO0FBQUEsSUFDTixhQUFhO0FBQUEsSUFDYixRQUFRO0FBQUEsRUFDVjtBQUFBLEVBQ0E7QUFBQSxJQUNFLE1BQU07QUFBQSxJQUNOLGFBQWE7QUFBQSxJQUNiLFFBQVE7QUFBQSxFQUNWO0FBQUEsRUFDQTtBQUFBLElBQ0UsTUFBTTtBQUFBLElBQ04sYUFBYTtBQUFBLElBQ2IsUUFBUTtBQUFBLEVBQ1Y7QUFBQSxFQUNBO0FBQUEsSUFDRSxNQUFNO0FBQUEsSUFDTixhQUFhO0FBQUEsSUFDYixRQUFRO0FBQUEsRUFDVjtBQUFBLEVBQ0E7QUFBQSxJQUNFLE1BQU07QUFBQSxJQUNOLGFBQWE7QUFBQSxJQUNiLFFBQVE7QUFBQSxFQUNWO0FBQUEsRUFDQTtBQUFBLElBQ0UsTUFBTTtBQUFBLElBQ04sYUFBYTtBQUFBLElBQ2IsUUFBUTtBQUFBLEVBQ1Y7QUFBQSxFQUNBO0FBQUEsSUFDRSxNQUFNO0FBQUEsSUFDTixhQUFhO0FBQUEsSUFDYixRQUFRO0FBQUEsRUFDVjtBQUFBLEVBQ0E7QUFBQSxJQUNFLE1BQU07QUFBQSxJQUNOLGFBQWE7QUFBQSxJQUNiLFFBQVE7QUFBQSxFQUNWO0FBQUEsRUFDQTtBQUFBLElBQ0UsTUFBTTtBQUFBLElBQ04sYUFBYTtBQUFBLElBQ2IsUUFBUTtBQUFBLEVBQ1Y7QUFBQSxFQUNBO0FBQUEsSUFDRSxNQUFNO0FBQUEsSUFDTixhQUFhO0FBQUEsSUFDYixRQUFRO0FBQUEsRUFDVjtBQUFBLEVBQ0E7QUFBQSxJQUNFLE1BQU07QUFBQSxJQUNOLGFBQWE7QUFBQSxJQUNiLFFBQVE7QUFBQSxFQUNWO0FBQUEsRUFDQTtBQUFBLElBQ0UsTUFBTTtBQUFBLElBQ04sYUFBYTtBQUFBLElBQ2IsUUFBUTtBQUFBLEVBQ1Y7QUFBQSxFQUNBO0FBQUEsSUFDRSxNQUFNO0FBQUEsSUFDTixhQUFhO0FBQUEsSUFDYixRQUFRO0FBQUEsRUFDVjtBQUFBLEVBQ0E7QUFBQSxJQUNFLE1BQU07QUFBQSxJQUNOLGFBQWE7QUFBQSxJQUNiLFFBQVE7QUFBQSxFQUNWO0FBQUEsRUFDQTtBQUFBLElBQ0UsTUFBTTtBQUFBLElBQ04sYUFBYTtBQUFBLElBQ2IsUUFBUTtBQUFBLEVBQ1Y7QUFDSjtBQUVPLFNBQVMsWUFBWSxNQUErQjtBQUN2RCxRQUFNLE9BQU8sS0FBSyxJQUFJLE1BQU0sc0JBQXNCLElBQUk7QUFDdEQsTUFBSSxDQUFDLE1BQU07QUFDUCxXQUFPO0FBQUEsRUFDWDtBQUNBLFFBQU0sRUFBRSxZQUFZLElBQUksSUFBSSxjQUFjLGFBQWEsSUFBSSxLQUFLLENBQUM7QUFDakUsUUFBTSxhQUFVLHVDQUFxQixXQUFXLEtBQUssQ0FBQztBQUN0RCxhQUFXQyxRQUFPLFFBQVE7QUFDdEIsZUFBVyxZQUFZLFdBQVc7QUFDOUIsVUFBSUEsUUFBTyxNQUFNLFNBQVMsTUFBTTtBQUM1QixlQUFPO0FBQUEsTUFDWDtBQUFBLElBQ0o7QUFBQSxFQUNKO0FBQ0EsU0FBTztBQUNYOzs7QTFFblRPLElBQU0sc0JBQU4sY0FBa0MsbUNBQTRCO0FBQUEsRUFNbkUsWUFBWUMsTUFBVSxRQUFnQixNQUN0QztBQUNFLFVBQU1BLElBQUc7QUFDVCxTQUFLLFNBQVM7QUFDZCxTQUFLLE9BQU87QUFDWixTQUFLLGlCQUFpQixDQUFDLFVBQXlCO0FBQzlDLFVBQUksTUFBTSxXQUFXLE1BQU0sVUFBVSxNQUFNLFlBQVksTUFBTSxRQUFRLEtBQUs7QUFDeEUsYUFBSyxNQUFNO0FBQUEsTUFDYixXQUFXLE1BQU0sV0FBVyxNQUFNLFdBQVcsTUFBTSxZQUFZLE1BQU0sUUFBUSxLQUFLO0FBQ2hGLGFBQUssTUFBTTtBQUFBLE1BQ2IsV0FBVyxNQUFNLFdBQVcsTUFBTSxTQUFTO0FBQ3pDLGNBQU0sTUFBTSxTQUFTLE1BQU0sS0FBSyxFQUFFO0FBQ2xDLFlBQUksT0FBTyxLQUFLLE9BQU8sR0FBRztBQUN4QixnQkFBTSxlQUFlO0FBQ3JCLGVBQUssY0FBYyxNQUFNLENBQUM7QUFBQSxRQUM1QjtBQUFBLE1BQ0Y7QUFBQSxJQUNGO0FBR0EsYUFBUyxpQkFBaUIsV0FBVyxLQUFLLGNBQWM7QUFBQSxFQUMxRDtBQUFBLEVBRUEsY0FBYyxPQUFlO0FBQzNCLFVBQU0sV0FBVyxLQUFLLGtCQUFrQixpQkFBaUIsa0JBQWtCO0FBQzNFLFFBQUksU0FBUyxTQUFTLE9BQU87QUFDM0IsWUFBTSxVQUFVLFNBQVMsS0FBSztBQUM5QixjQUFRLE1BQU07QUFBQSxJQUNoQjtBQUFBLEVBQ0Y7QUFBQSxFQUVBLFVBQVU7QUFDUixVQUFNLFFBQVE7QUFFZCxhQUFTLG9CQUFvQixXQUFXLEtBQUssY0FBYztBQUFBLEVBRTdEO0FBQUEsRUFFQSxXQUF1QjtBQUNyQixXQUFPO0FBQUEsRUFDVDtBQUFBLEVBRUEsWUFBWSxVQUE0QjtBQUN0QyxXQUFPLFNBQVM7QUFBQSxFQUNsQjtBQUFBO0FBQUEsRUFHQSxpQkFBaUIsc0JBQTRDLElBQWlCO0FBQzVFLFVBQU0sV0FBVyxxQkFBcUI7QUFDdEMsVUFBTSxRQUFRLEtBQUssa0JBQWtCLGlCQUFpQixrQkFBa0IsRUFBRTtBQUMxRSxVQUFNLFlBQVksUUFBUSxLQUFLLFFBQVEsT0FBTztBQUM5QyxPQUFHLFNBQVMsT0FBTyxFQUFFLE1BQU0sWUFBWSxTQUFTLFNBQVMsTUFBTSxTQUFTLEtBQUssQ0FBQztBQUM5RSxPQUFHLFNBQVMsU0FBUyxFQUFFLE1BQU0sVUFBVSxTQUFTLFlBQVksQ0FBQztBQUFBLEVBQy9EO0FBQUEsRUFFQSxhQUFhLE1BQXdCO0FBQ25DLFdBQU8sVUFBVSxPQUFPLENBQUMsYUFBYSxLQUFLLFNBQVMsU0FBUyxJQUFJLENBQUMsRUFBRSxTQUFTO0FBQUEsRUFDL0U7QUFBQSxFQUVBLHNCQUFzQixPQUFlO0FBQ25DLFVBQU0sU0FBUyxLQUFLLE9BQU8sVUFBVTtBQUNyQyxVQUFNLFVBQVUsT0FBTztBQUN2QixVQUFNLFFBQVEsT0FBTztBQUNyQixVQUFNLFVBQVU7QUFBQSxRQUFjO0FBQUE7QUFBQTtBQUFBLEVBQWlCLEtBQUssT0FBTyxTQUFTO0FBQ3BFLFNBQUssT0FBTyxTQUFTLE9BQU87QUFDNUIsV0FBTyxPQUFPLFVBQVU7QUFDeEIsV0FBTyxLQUFLO0FBQ1osU0FBSyxPQUFPLFVBQVUsTUFBTTtBQUFBLEVBQzlCO0FBQUEsRUFFQSw2QkFBNkIsT0FBZTtBQUMxQyxVQUFNLFNBQVMsS0FBSyxPQUFPLFVBQVU7QUFDckMsVUFBTSxVQUFVLE9BQU87QUFDdkIsVUFBTSxRQUFRLE9BQU87QUFFckIsUUFBSSxpQkFBaUI7QUFDckIsVUFBTSxZQUFZLEtBQUssT0FBTyxVQUFVO0FBQ3hDLGFBQVMsSUFBSSxHQUFHLElBQUksV0FBVyxLQUFLO0FBQ2xDLFVBQUksS0FBSyxPQUFPLFFBQVEsQ0FBQyxFQUFFLEtBQUssS0FBSyxNQUFNLEtBQUssR0FBRztBQUNqRCx5QkFBaUI7QUFDakI7QUFBQSxNQUNGO0FBQUEsSUFDRjtBQUNBLFFBQUksa0JBQWtCLFdBQVc7QUFDL0IsVUFBSSx3QkFBTyxzQkFBc0I7QUFDakM7QUFBQSxJQUNGO0FBQ0EsUUFBSSxPQUFPO0FBQ1gsYUFBUyxJQUFJLEdBQUcsS0FBSyxnQkFBZ0IsS0FBSztBQUN4QyxhQUFPLE9BQU8sS0FBSyxPQUFPLFFBQVEsQ0FBQyxJQUFJO0FBQUEsSUFDekM7QUFDQSxXQUFPLE9BQU8sU0FBUztBQUFBO0FBQ3ZCLGFBQVMsSUFBSSxpQkFBaUIsR0FBRyxLQUFLLEtBQUssT0FBTyxVQUFVLEdBQUcsS0FBSztBQUNsRSxhQUFPLE9BQU8sS0FBSyxPQUFPLFFBQVEsQ0FBQyxJQUFJO0FBQUEsSUFDekM7QUFFQSxTQUFLLE9BQU8sU0FBUyxJQUFJO0FBQ3pCLFdBQU8sT0FBTyxXQUFXLFdBQVcsaUJBQWlCLElBQUk7QUFDekQsV0FBTyxLQUFLO0FBQ1osU0FBSyxPQUFPLFVBQVUsTUFBTTtBQUFBLEVBQzlCO0FBQUE7QUFBQSxFQUdBLGFBQWEsaUJBQTJCLEtBQWlDO0FBQ3ZFLFFBQUksQ0FBQyxlQUFlLEtBQUssSUFBSSxHQUFHO0FBQzlCLFdBQUssc0JBQXNCLGdCQUFnQixJQUFJO0FBQUEsSUFDakQsT0FBTztBQUNMLFVBQUksUUFBUSxLQUFLLElBQUksR0FDckI7QUFDRSxrQkFBVSxRQUFRLE9BQUs7QUFDckIsb0JBQVUsS0FBSyxNQUFNLEVBQUUsTUFBTSxnQkFBZ0IsSUFBSTtBQUFBLFFBQ2pELENBQUM7QUFBQSxNQUNMLE9BQU87QUFLTCxhQUFLLDZCQUE2QixnQkFBZ0IsSUFBSTtBQUFBLE1BQ3hEO0FBQUEsSUFDRjtBQUFBLEVBQ0Y7QUFDRjs7O0FEbElBLElBQUFDLG9CQUFvSzs7O0E0RURwSyxJQUFBQyxtQkFBMkQ7QUFPM0QsSUFBTUMsYUFBWTtBQUFBLEVBQ2hCO0FBQUEsSUFDRSxNQUFNO0FBQUEsSUFDTixhQUFhO0FBQUEsRUFDZjtBQUFBLEVBQ0E7QUFBQSxJQUNFLE1BQU07QUFBQSxJQUNOLGFBQWE7QUFBQSxFQUNmO0FBQUEsRUFDQTtBQUFBLElBQ0UsTUFBTTtBQUFBLElBQ04sYUFBYTtBQUFBLEVBQ2Y7QUFBQSxFQUNBO0FBQUEsSUFDRSxNQUFNO0FBQUEsSUFDTixhQUFhO0FBQUEsRUFDZjtBQUFBLEVBQ0E7QUFBQSxJQUNFLE1BQU07QUFBQSxJQUNOLGFBQWE7QUFBQSxFQUNmO0FBQUEsRUFDQTtBQUFBLElBQ0UsTUFBTTtBQUFBLElBQ04sYUFBYTtBQUFBLEVBQ2Y7QUFBQSxFQUNBO0FBQUEsSUFDRSxNQUFNO0FBQUEsSUFDTixhQUFhO0FBQUEsRUFDZjtBQUFBLEVBQ0E7QUFBQSxJQUNFLE1BQU07QUFBQSxJQUNOLGFBQWE7QUFBQSxFQUNmO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBaURGO0FBRU8sSUFBTSxzQkFBTixjQUFrQyxtQ0FBZ0M7QUFBQSxFQUt2RSxZQUFZQyxNQUFVLFFBQ3RCO0FBQ0UsVUFBTUEsSUFBRztBQUNULFNBQUssU0FBUztBQUNkLFNBQUssaUJBQWlCLENBQUMsVUFBeUI7QUFPOUMsVUFBSSxNQUFNLFdBQVcsTUFBTSxVQUFVLE1BQU0sWUFBWSxNQUFNLFFBQVEsS0FBSztBQUN4RSxhQUFLLE1BQU07QUFBQSxNQUNiLFdBQVcsTUFBTSxXQUFXLE1BQU0sV0FBVyxNQUFNLFlBQVksTUFBTSxRQUFRLEtBQUs7QUFDaEYsYUFBSyxNQUFNO0FBQUEsTUFDYixXQUFXLE1BQU0sV0FBVyxNQUFNLFNBQVM7QUFDekMsY0FBTSxNQUFNLFNBQVMsTUFBTSxLQUFLLEVBQUU7QUFDbEMsWUFBSSxPQUFPLEtBQUssT0FBTyxHQUFHO0FBQ3hCLGdCQUFNLGVBQWU7QUFDckIsZUFBSyxjQUFjLE1BQU0sQ0FBQztBQUFBLFFBQzVCO0FBQUEsTUFDRjtBQUFBLElBQ0Y7QUFHQSxhQUFTLGlCQUFpQixXQUFXLEtBQUssY0FBYztBQUFBLEVBQzFEO0FBQUEsRUFFQSxjQUFjLE9BQWU7QUFDM0IsVUFBTSxXQUFXLEtBQUssa0JBQWtCLGlCQUFpQixrQkFBa0I7QUFDM0UsUUFBSSxTQUFTLFNBQVMsT0FBTztBQUMzQixZQUFNLFVBQVUsU0FBUyxLQUFLO0FBQzlCLGNBQVEsTUFBTTtBQUFBLElBQ2hCO0FBQUEsRUFDRjtBQUFBLEVBRUEsVUFBVTtBQUNSLFVBQU0sUUFBUTtBQUVkLGFBQVMsb0JBQW9CLFdBQVcsS0FBSyxjQUFjO0FBQUEsRUFDN0Q7QUFBQSxFQUVBLFdBQTJCO0FBQ3pCLFdBQU9EO0FBQUEsRUFDVDtBQUFBLEVBRUEsWUFBWSxVQUFnQztBQUMxQyxXQUFPLFNBQVM7QUFBQSxFQUNsQjtBQUFBLEVBRUEsT0FBTyxVQUFVLE1BQXNCO0FBQ3JDLElBQUFBLFdBQVUsUUFBUSxDQUFDLGFBQWEsT0FBTyxLQUFLLFFBQVEsSUFBSSxTQUFTLFNBQVMsRUFBRSxDQUFDO0FBQzdFLFdBQU87QUFBQSxFQUNUO0FBQUE7QUFBQSxFQUdBLGlCQUFpQixzQkFBZ0QsSUFBaUI7QUFDaEYsVUFBTSxXQUFXLHFCQUFxQjtBQUN0QyxVQUFNLFFBQVEsS0FBSyxrQkFBa0IsaUJBQWlCLGtCQUFrQixFQUFFO0FBQzFFLFVBQU0sWUFBWSxRQUFRLEtBQUssUUFBUSxPQUFPO0FBQzlDLE9BQUcsU0FBUyxPQUFPLEVBQUUsTUFBTSxZQUFZLFNBQVMsS0FBSyxDQUFDO0FBQ3RELE9BQUcsU0FBUyxTQUFTLEVBQUUsTUFBTSxVQUFVLFNBQVMsWUFBWSxDQUFDO0FBQUEsRUFDL0Q7QUFBQSxFQUVBLGFBQWEsTUFBd0I7QUFDbkMsV0FBT0EsV0FBVSxPQUFPLENBQUMsYUFBYSxLQUFLLFNBQVMsU0FBUyxJQUFJLENBQUMsRUFBRSxTQUFTO0FBQUEsRUFDL0U7QUFBQTtBQUFBLEVBR0EsYUFBYSxpQkFBK0IsS0FBaUM7QUFDM0UsVUFBTSxZQUFZLEtBQUssT0FBTyxhQUFhO0FBQzNDLFVBQU0sY0FBYyxJQUFJLGdCQUFnQjtBQUN4QyxRQUFJLFVBQVUsVUFBVSxHQUFHO0FBQ3ZCLFdBQUssT0FBTyxpQkFBaUIsV0FBVztBQUFBLElBQzVDLE9BQU87QUFDSCxZQUFNLFNBQVMsS0FBSyxPQUFPLFVBQVU7QUFDckMsV0FBSyxPQUFPLGFBQWEsYUFBYSxNQUFNO0FBQzVDLGFBQU8sS0FBSyxPQUFPLEtBQUssWUFBWTtBQUNwQyxXQUFLLE9BQU8sVUFBVSxNQUFNO0FBQUEsSUFDaEM7QUFBQSxFQUNGO0FBQ0Y7OztBQ2hMQSxJQUFBRSxtQkFBMkQ7QUFRM0QsSUFBTUMsYUFBWTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFRaEI7QUFBQSxJQUNFLE1BQU07QUFBQSxJQUNOLFFBQVE7QUFBQSxJQUNSLGFBQWE7QUFBQSxFQUNmO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFhQTtBQUFBLElBQ0UsTUFBTTtBQUFBLElBQ04sUUFBUTtBQUFBLElBQ1IsYUFBYTtBQUFBLEVBQ2Y7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQVFGO0FBRU8sSUFBTSxrQkFBTixjQUE4QixtQ0FBK0I7QUFBQSxFQUtsRSxZQUFZQyxNQUFVLFFBQWdCLFVBQ3RDO0FBQ0UsVUFBTUEsSUFBRztBQUNULFNBQUssU0FBUztBQUNkLFNBQUssV0FBVztBQUFBLEVBQ2xCO0FBQUEsRUFFQSxXQUEwQjtBQUN4QixXQUFPRDtBQUFBLEVBQ1Q7QUFBQSxFQUVBLFlBQVksVUFBK0I7QUFDekMsV0FBTyxTQUFTLE9BQU8sU0FBUztBQUFBLEVBQ2xDO0FBQUE7QUFBQSxFQUdBLGlCQUFpQixzQkFBK0MsSUFBaUI7QUFDL0UsVUFBTSxXQUFXLHFCQUFxQjtBQUN0QyxPQUFHLFNBQVMsT0FBTyxFQUFFLE1BQU0sU0FBUyxPQUFPLE1BQU0sU0FBUyxPQUFPLENBQUM7QUFDbEUsT0FBRyxTQUFTLFNBQVMsRUFBRSxNQUFNLFNBQVMsWUFBWSxDQUFDO0FBQUEsRUFDckQ7QUFBQSxFQUVBLGFBQWEsTUFBd0I7QUFDbkMsV0FBT0EsV0FBVSxPQUFPLENBQUMsYUFBYSxLQUFLLFNBQVMsU0FBUyxJQUFJLENBQUMsRUFBRSxTQUFTO0FBQUEsRUFDL0U7QUFBQTtBQUFBLEVBR0EsYUFBYSxpQkFBOEIsS0FBaUM7QUFDMUUsVUFBTSxTQUFTLEtBQUssT0FBTyxVQUFVO0FBQ3JDLFVBQU0sT0FBTyxLQUFLLE9BQU8sUUFBUSxPQUFPLElBQUk7QUFFNUMsUUFBSSxnQkFBZ0IsVUFBVSxLQUFLO0FBQ2pDLFdBQUssT0FBTyxhQUFhLEdBQUcsS0FBSyxPQUFPLE9BQU8sS0FBSyxDQUFDLEtBQUssTUFBTSxNQUFNLE1BQU0sZ0JBQWdCLE9BQU8sS0FBSyxhQUFhLE1BQU07QUFDM0gsYUFBTyxLQUFLLE9BQU8sS0FBSyxLQUFLLEtBQUssT0FBTyxPQUFPLEtBQUssQ0FBQyxLQUFLLE1BQU0sSUFBSTtBQUN2RSxXQUFLLE9BQU8sVUFBVSxNQUFNO0FBQUEsSUFDNUIsV0FBVyxnQkFBZ0IsVUFBVSxLQUFLO0FBQ3hDLFVBQUksZUFBZTtBQUNuQixVQUFJLFNBQVMsS0FBSyxJQUFJLEdBQUc7QUFDdkIsdUJBQWUsS0FBSyxRQUFRLFlBQVksTUFBTSxnQkFBZ0IsT0FBTyxLQUFLLFdBQVc7QUFBQSxNQUN2RixXQUFXLGFBQWEsS0FBSyxJQUFJLEdBQUc7QUFDbEMsdUJBQWUsS0FBSyxRQUFRLGdCQUFnQixLQUFLLGdCQUFnQixPQUFPLEtBQUssV0FBVztBQUFBLE1BQzFGLE9BQU87QUFDTCx1QkFBZSxLQUFLLFFBQVEsS0FBSyxJQUFJLGdCQUFnQixPQUFPLEtBQUssV0FBVztBQUFBLE1BQzlFO0FBQ0EsV0FBSyxPQUFPLFFBQVEsT0FBTyxNQUFNLFlBQVk7QUFDN0MsYUFBTyxLQUFLLE9BQU8sS0FBSztBQUMxQixXQUFLLE9BQU8sVUFBVSxNQUFNO0FBQUEsSUFDNUIsV0FBVyxnQkFBZ0IsVUFBVSxLQUFLO0FBQ3hDLFVBQUksZUFBZSxLQUFLLFFBQVEsS0FBSyxLQUFLLGdCQUFnQixPQUFPLEtBQUssVUFBVTtBQUNoRixXQUFLLE9BQU8sUUFBUSxPQUFPLE1BQU0sWUFBWTtBQUM3QyxhQUFPLEtBQUssT0FBTztBQUNyQixXQUFLLE9BQU8sVUFBVSxNQUFNO0FBQUEsSUFDNUI7QUFBQSxFQUVGO0FBQ0Y7OztBQzNHQSxJQUFBRSxtQkFBbUU7QUFPbkUsSUFBTUMsYUFBWTtBQUFBLEVBQ2hCO0FBQUEsSUFDRSxNQUFNO0FBQUEsSUFDTixhQUFhO0FBQUEsRUFDZjtBQUFBLEVBQ0E7QUFBQSxJQUNFLE1BQU07QUFBQSxJQUNOLGFBQWE7QUFBQSxFQUNmO0FBQUEsRUFDQTtBQUFBLElBQ0UsTUFBTTtBQUFBLElBQ04sYUFBYTtBQUFBLEVBQ2Y7QUFBQSxFQUNBO0FBQUEsSUFDRSxNQUFNO0FBQUEsSUFDTixhQUFhO0FBQUEsRUFDZjtBQUNGO0FBRU8sSUFBTSx1QkFBTixjQUFtQyxtQ0FBK0I7QUFBQSxFQUl2RSxZQUFZQyxNQUFVLGVBQ3RCO0FBQ0UsVUFBTUEsSUFBRztBQUNULFNBQUssZ0JBQWdCO0FBQUEsRUFDdkI7QUFBQSxFQUVBLFdBQTBCO0FBQ3hCLFdBQU9EO0FBQUEsRUFDVDtBQUFBLEVBRUEsWUFBWSxVQUErQjtBQUN6QyxXQUFPLFNBQVM7QUFBQSxFQUNsQjtBQUFBO0FBQUEsRUFHQSxpQkFBaUIsc0JBQStDLElBQWlCO0FBQy9FLFVBQU0sV0FBVyxxQkFBcUI7QUFDdEMsT0FBRyxTQUFTLE9BQU8sRUFBRSxNQUFNLFNBQVMsS0FBSyxDQUFDO0FBQzFDLE9BQUcsU0FBUyxTQUFTLEVBQUUsTUFBTSxTQUFTLFlBQVksQ0FBQztBQUFBLEVBQ3JEO0FBQUEsRUFFQSxhQUFhLE1BQXdCO0FBQ25DLFdBQU9BLFdBQVUsT0FBTyxDQUFDLGFBQWEsS0FBSyxTQUFTLFNBQVMsSUFBSSxDQUFDLEVBQUUsU0FBUztBQUFBLEVBQy9FO0FBQUE7QUFBQSxFQUdBLGFBQWEsaUJBQThCLEtBQWlDO0FBQzFFLFFBQUksUUFBUSxnQkFBZ0I7QUFDNUIsUUFBSSxJQUFJLEtBQUssY0FBYyxTQUFTO0FBQ3BDLGNBQVUsVUFBVSxVQUFVLEtBQUssY0FBYyxTQUFTLENBQUMsRUFBRSxLQUFLLFdBQVk7QUFDMUUsVUFBSSx3QkFBTztBQUFBO0FBQUEsRUFBbUI7QUFBQSxjQUF3QjtBQUN0RCxhQUFPLEtBQUssc0VBQXNFLHNFQUFzRTtBQUFBLElBQzVKLEdBQUcsU0FBVSxPQUFPO0FBQ2hCLFVBQUksd0JBQU8sK0JBQStCO0FBQUEsSUFDOUMsQ0FBQztBQUFBLEVBQ0g7QUFDRjs7O0FDbEVBLElBQUFFLG1CQUF5RTtBQU96RSxJQUFNQyxhQUFZO0FBQUEsRUFDaEI7QUFBQSxJQUNFLE1BQU07QUFBQSxJQUNOLGFBQWE7QUFBQSxFQUNmO0FBQUEsRUFDQTtBQUFBLElBQ0UsTUFBTTtBQUFBLElBQ04sYUFBYTtBQUFBLEVBQ2Y7QUFDRjtBQUVPLElBQU0sMkJBQU4sY0FBdUMsbUNBQThCO0FBQUEsRUFLMUUsWUFBWUMsTUFBVSxRQUN0QjtBQUNFLFVBQU1BLElBQUc7QUFDVCxTQUFLLFNBQVM7QUFDZCxTQUFLLGVBQWUscUNBQXFDO0FBQUEsRUFDM0Q7QUFBQSxFQUVBLFdBQXlCO0FBQ3ZCLFdBQU9EO0FBQUEsRUFDVDtBQUFBLEVBRUEsWUFBWSxVQUE4QjtBQUN4QyxXQUFPLFNBQVM7QUFBQSxFQUNsQjtBQUFBO0FBQUEsRUFHQSxpQkFBaUIsc0JBQThDLElBQWlCO0FBQzlFLFVBQU0sV0FBVyxxQkFBcUI7QUFDdEMsT0FBRyxTQUFTLE9BQU8sRUFBRSxNQUFNLFNBQVMsS0FBSyxDQUFDO0FBQzFDLE9BQUcsU0FBUyxTQUFTLEVBQUUsTUFBTSxTQUFTLFlBQVksQ0FBQztBQUFBLEVBQ3JEO0FBQUEsRUFFQSxhQUFhLE1BQXdCO0FBQ25DLFdBQU9BLFdBQVUsT0FBTyxDQUFDLGFBQWEsS0FBSyxTQUFTLFNBQVMsSUFBSSxDQUFDLEVBQUUsU0FBUztBQUFBLEVBQy9FO0FBQUE7QUFBQSxFQUdBLE1BQU0sYUFBYSxrQkFBOEIsS0FBaUM7QUFDaEYsVUFBTSxZQUFZLEtBQUssT0FBTyxhQUFhO0FBQzNDLFVBQU0sT0FBTyxLQUFLLE9BQU8sVUFBVSxFQUFFO0FBQ3JDLFVBQU0sbUJBQW9CLFVBQVUsVUFBVSxJQUNoQyxLQUFLLE9BQU8sUUFBUSxJQUFJLElBQ3hCO0FBRWQsVUFBTSxjQUFjO0FBQ3BCLFVBQU0sS0FBSyxtQkFBbUIsYUFBYSxnQkFBZ0I7QUFFM0QsUUFBSSxpQkFBaUIsUUFBUSxRQUFRO0FBQ25DLFVBQUksVUFBVSxVQUFVLEdBQUc7QUFDekIsYUFBSyxPQUFPLGlCQUFpQixFQUFFO0FBQUEsTUFDakMsT0FBTztBQUNMLFlBQUksVUFBVTtBQUNkLGlCQUFTLElBQUksR0FBRyxJQUFJLEtBQUssT0FBTyxVQUFVLEdBQUcsS0FBSztBQUNoRCxjQUFJLEtBQUssTUFBTTtBQUNiLHVCQUFXLEtBQUssT0FBTyxRQUFRLENBQUMsSUFBSTtBQUFBLFVBQ3RDO0FBQUEsUUFDRjtBQUNBLGFBQUssT0FBTyxTQUFTLE9BQU87QUFBQSxNQUM5QjtBQUFBLElBQ0Y7QUFFQSxVQUFNLEVBQUUsTUFBTSxJQUFJLEtBQUs7QUFDdkIsVUFBTSxFQUFFLFVBQVUsSUFBSSxLQUFLO0FBQzNCLFVBQU0sT0FBUSxLQUFLLElBQUksTUFBYyxVQUFVLGlCQUFpQjtBQUNoRSxVQUFNLE9BQU8sVUFBVSxRQUFRLEtBQUs7QUFDcEMsVUFBTSxLQUFLLFNBQVMsTUFBTSxzQkFBc0IsV0FBVyxHQUFZLEVBQUUsUUFBUyxLQUFLLENBQUM7QUFBQSxFQUMxRjtBQUFBLEVBRUEsTUFBTSxtQkFBbUIsVUFBa0JFLE9BQWM7QUFFekQsVUFBTSxFQUFFLE1BQU0sSUFBSSxLQUFLO0FBQ3ZCLFVBQU0sYUFBYSxNQUFNLE1BQU0sUUFBUSxPQUFPLFFBQVE7QUFDdEQsUUFBRyxZQUFXO0FBQ2IsWUFBTSxLQUFLLFdBQVcsT0FBTyxVQUFVQSxLQUFJO0FBQUEsSUFDNUMsT0FBTztBQUNOLFlBQU0sTUFBTSxPQUFPLFVBQVUsNkJBQTZCQSxLQUFJO0FBQUEsSUFDL0Q7QUFDQSxXQUFPO0FBQUEsRUFDUjtBQUFBLEVBRUcsTUFBTSxXQUFXLE9BQWMsVUFBa0JBLE9BQWM7QUFDakUsUUFBSSxrQkFBa0IsTUFBTSxNQUFNLFFBQVEsS0FBSyxRQUFRO0FBQ3ZELFFBQUcsZ0JBQWdCLFNBQVMsR0FBRztBQUM3Qix3QkFBa0Isa0JBQWtCO0FBQUEsSUFDdEM7QUFDQSxVQUFNLE1BQU0sUUFBUSxNQUFNLFVBQVUsa0JBQWtCQSxLQUFJO0FBQUEsRUFDekQ7QUFDSDs7O0FDcEdBLElBQUFDLG1CQUEyRDtBQUVwRCxJQUFNLHNCQUFOLGNBQWtDLG1DQUEwQjtBQUFBLEVBUWpFLFlBQVlDLE1BQVUsUUFBZ0Isa0JBQ3RDO0FBQ0UsVUFBTUEsSUFBRztBQUNULFNBQUssU0FBUztBQUNkLFNBQUssbUJBQW1CO0FBQ3hCLFNBQUssZUFBZSwrQ0FBK0M7QUFDbkUsU0FBSyxpQkFBaUIsQ0FBQyxVQUF5QjtBQUM5QyxVQUFJLE1BQU0sV0FBVyxNQUFNLFlBQVksTUFBTSxRQUFRLEtBQUs7QUFDeEQsYUFBSyxNQUFNO0FBQUEsTUFDYixXQUFXLE1BQU0sV0FBVyxNQUFNLFNBQVM7QUFDekMsY0FBTSxNQUFNLFNBQVMsTUFBTSxLQUFLLEVBQUU7QUFDbEMsWUFBSSxPQUFPLEtBQUssT0FBTyxHQUFHO0FBQ3hCLGdCQUFNLGVBQWU7QUFDckIsZUFBSyxjQUFjLE1BQU0sQ0FBQztBQUFBLFFBQzVCO0FBQUEsTUFDRjtBQUFBLElBQ0Y7QUFHQSxhQUFTLGlCQUFpQixXQUFXLEtBQUssY0FBYztBQUFBLEVBQzFEO0FBQUEsRUFFQSxVQUFVO0FBQ1IsVUFBTSxRQUFRO0FBRWQsYUFBUyxvQkFBb0IsV0FBVyxLQUFLLGNBQWM7QUFBQSxFQUM3RDtBQUFBLEVBRUEsY0FBYyxPQUFlO0FBQzNCLFVBQU0sV0FBVyxLQUFLLGtCQUFrQixpQkFBaUIsa0JBQWtCO0FBQzNFLFFBQUksU0FBUyxTQUFTLE9BQU87QUFDM0IsWUFBTSxVQUFVLFNBQVMsS0FBSztBQUM5QixjQUFRLE1BQU07QUFBQSxJQUNoQjtBQUFBLEVBQ0Y7QUFBQSxFQUVBLFdBQXFCO0FBQ25CLFdBQU8sS0FBSyxpQkFBaUIsTUFBTSxFQUFFLFFBQVE7QUFBQSxFQUMvQztBQUFBLEVBRUEsWUFBWSxNQUFzQjtBQUNoQyxXQUFPO0FBQUEsRUFDVDtBQUFBO0FBQUEsRUFHQSxpQkFBaUIsR0FBdUIsSUFBaUI7QUFDdkQsVUFBTSxPQUFPLEVBQUU7QUFFZixVQUFNLFFBQVEsS0FBSyxrQkFBa0IsaUJBQWlCLGtCQUFrQixFQUFFO0FBQzFFLFVBQU0sWUFBWSxRQUFRLEtBQUssUUFBUSxPQUFPO0FBQzlDLE9BQUcsU0FBUyxPQUFPLEVBQUUsTUFBTSxZQUFZLEtBQUssUUFBUSxRQUFRLEVBQUUsRUFBRSxVQUFVLEdBQUcsR0FBRyxFQUFFLENBQUM7QUFBQSxFQUNyRjtBQUFBO0FBQUEsRUFHQSxhQUFhLGlCQUF5QixLQUFpQztBQUNyRSxVQUFNLFFBQVEsS0FBSyxpQkFBaUIsUUFBUSxpQkFBaUIsQ0FBQztBQUM5RCxRQUFJLFFBQVEsSUFBSTtBQUNkLFdBQUssaUJBQWlCLE9BQU8sZUFBZTtBQUFBLElBQzlDO0FBQ0EsU0FBSyxpQkFBaUIsS0FBSyxlQUFlO0FBQzFDLFVBQU0sWUFBWSxLQUFLLE9BQU8sYUFBYTtBQUMzQyxVQUFNLGNBQWM7QUFDcEIsUUFBSSxVQUFVLFVBQVUsR0FBRztBQUN2QixXQUFLLE9BQU8saUJBQWlCLFdBQVc7QUFBQSxJQUM1QyxPQUFPO0FBQ0gsWUFBTSxTQUFTLEtBQUssT0FBTyxVQUFVO0FBQ3JDLFdBQUssT0FBTyxhQUFhLGFBQWEsTUFBTTtBQUM1QyxhQUFPLEtBQUssT0FBTyxLQUFLLFlBQVk7QUFDcEMsV0FBSyxPQUFPLFVBQVUsTUFBTTtBQUFBLElBQ2hDO0FBQUEsRUFDRjtBQUNGOzs7QUNqRkEsSUFBQUMsb0JBQWtFO0FBRTNELElBQU0sc0JBQU4sY0FBa0Msb0NBQTBCO0FBQUEsRUFPakUsWUFBWUMsTUFDWjtBQUNFLFVBQU1BLElBQUc7QUFQWCxpQ0FBaUM7QUFDakMsb0NBQW1DO0FBQ25DLHdCQUF1QjtBQUN2QixtQkFBb0IsQ0FBQyxLQUFLLHVCQUF1QixLQUFLLHdCQUF3QjtBQUFBLEVBSzlFO0FBQUEsRUFFQSxXQUFxQjtBQUNuQixXQUFPLEtBQUssUUFBUSxRQUFRO0FBQUEsRUFDOUI7QUFBQSxFQUVBLFlBQVksTUFBc0I7QUFDaEMsV0FBTztBQUFBLEVBQ1Q7QUFBQTtBQUFBLEVBR0EsaUJBQWlCLEdBQXVCLElBQWlCO0FBQ3ZELFVBQU0sT0FBTyxFQUFFO0FBQ2YsT0FBRyxTQUFTLE9BQU8sRUFBRSxNQUFNLEtBQUssQ0FBQztBQUFBLEVBQ25DO0FBQUE7QUFBQSxFQUdBLE1BQU0sYUFBYSxpQkFBeUIsS0FBaUM7QUFDM0UsVUFBTSxnQkFBZ0I7QUFFdEIsVUFBTSxFQUFFLE1BQU0sSUFBSSxLQUFLO0FBQ3ZCLFVBQU0sRUFBRSxVQUFVLElBQUksS0FBSztBQUMzQixVQUFNLE9BQU8sVUFBVSxRQUFRLEtBQUs7QUFFcEMsWUFBUSxRQUFRLEVBQ2YsS0FBSyxNQUFNO0FBQ1YsVUFBSSxNQUFNLHNCQUFzQixLQUFLLFlBQVksS0FBSyxNQUFNO0FBQzFELGVBQU8sTUFBTSxPQUFPLEtBQUssY0FBYyxFQUFFO0FBQUEsTUFDM0M7QUFDQSxhQUFPLE1BQU0sc0JBQXNCLEtBQUssWUFBWTtBQUFBLElBQ3RELENBQUMsRUFDQSxLQUFLLENBQUMsVUFBVTtBQUNmLFVBQUksS0FBSywwQkFBMEIsZUFBZTtBQUNoRCxlQUFPLE1BQU0sT0FBTyxPQUFnQixFQUFFO0FBQUEsTUFDeEM7QUFDQSxhQUFPLFFBQVEsUUFBUTtBQUFBLElBQ3pCLENBQUMsRUFDQSxLQUFLLE1BQU07QUFDVixhQUFPLEtBQUssU0FBUyxNQUFNLHNCQUFzQixLQUFLLFlBQVksR0FBWSxFQUFFLFFBQVMsS0FBSSxDQUFDO0FBQUEsSUFDaEcsQ0FBQztBQUFBLEVBQ0g7QUFDRjs7O0FDckRBLElBQUFDLG9CQUF3RjtBQUVqRixJQUFNLHFCQUFOLGNBQWlDLG9DQUEwQjtBQUFBLEVBUWhFLFlBQVlDLE1BQVUsUUFBZ0IsTUFDdEM7QUFDRSxVQUFNQSxJQUFHO0FBUlgscUJBQXFCO0FBQ3JCLHVCQUFzQjtBQUN0QixtQkFBb0IsQ0FBQyxLQUFLLFdBQVcsS0FBSyxXQUFXO0FBT25ELFNBQUssU0FBUztBQUNkLFNBQUssT0FBTztBQUNaLFNBQUssZUFBZSw2RUFBNkU7QUFBQSxFQUNuRztBQUFBLEVBRUEsV0FBcUI7QUFDbkIsV0FBTyxLQUFLO0FBQUEsRUFDZDtBQUFBLEVBRUEsWUFBWSxNQUFzQjtBQUNoQyxXQUFPO0FBQUEsRUFDVDtBQUFBO0FBQUEsRUFHQSxpQkFBaUIsR0FBdUIsSUFBaUI7QUFDdkQsVUFBTSxPQUFPLEVBQUU7QUFDZixPQUFHLFNBQVMsT0FBTyxFQUFFLE1BQU0sS0FBSyxDQUFDO0FBQUEsRUFDbkM7QUFBQTtBQUFBLEVBR0EsYUFBYSxpQkFBeUIsS0FBaUM7QUFDckUsVUFBTSxnQkFBZ0I7QUFFdEIsVUFBTSxZQUFZLEtBQUssT0FBTyxVQUFVO0FBQ3hDLFFBQUksZ0JBQWdCO0FBQ3BCLFFBQUksb0JBQW9CO0FBQ3hCLFFBQUksT0FBTztBQUNYLGFBQVMsSUFBSSxHQUFHLElBQUksV0FBVyxLQUFLO0FBQ2xDLFVBQUksT0FBTyxLQUFLLE9BQU8sUUFBUSxDQUFDO0FBQ2hDLFVBQUksQ0FBQyxLQUFLLEtBQUssRUFBRSxXQUFXLElBQUksS0FBSyxDQUFDLEtBQUssS0FBSyxFQUFFLFNBQVMsSUFBSSxHQUFHO0FBQ2hFLFlBQUksZUFBZSxLQUFLLFFBQVEsY0FBTyxJQUFJLEVBQUUsUUFBUSxVQUFLLEVBQUUsRUFBRSxRQUFRLFVBQUssRUFBRSxFQUFFLFFBQVEsYUFBTSxFQUFFO0FBQy9GLFlBQUksZ0JBQWdCLE9BQU87QUFDekI7QUFDQSxjQUFJLG9CQUFvQixHQUFHO0FBQ3pCLGdCQUFJLHFCQUFxQixHQUFHO0FBQzFCLDZCQUFlLGFBQWEsUUFBUSxPQUFPLEVBQUU7QUFBQSxZQUMvQyxXQUFXLHFCQUFxQixHQUFHO0FBQ2pDLDZCQUFlLGFBQWEsUUFBUSxPQUFPLDZFQUE4RDtBQUFBLFlBQzNHLE9BQU87QUFDTCw2QkFBZSxhQUFhLFFBQVEsT0FBTyxNQUFNO0FBQUEsWUFDbkQ7QUFBQSxVQUVGO0FBQUEsUUFDRjtBQUNBLFlBQUkscUJBQXFCLEtBQUsscUJBQXFCLEdBQUc7QUFDcEQseUJBQWUsYUFBYSxRQUFRLFNBQVMsT0FBTztBQUNwRCx5QkFBZSxhQUFhLFFBQVEsU0FBUyxPQUFPO0FBQ3BELHlCQUFlLGFBQWEsUUFBUSxTQUFTLE9BQU87QUFBQSxRQUN0RDtBQUVBLFlBQUksaUJBQWlCLEtBQUssYUFBYSxLQUFLLENBQUMsR0FBRztBQUM5QyxjQUFJLENBQUMsYUFBYSxTQUFTLDhCQUE4QixHQUFHO0FBQzFELDJCQUFlLGFBQWEsUUFBUSwwQ0FBMEMsSUFBSTtBQUFBLFVBQ3BGO0FBQUEsUUFDRjtBQUNBLGVBQU8sT0FBTyxlQUFlO0FBQUEsTUFDL0I7QUFBQSxJQUNGO0FBQ0EsV0FBTyxLQUFLLFFBQVEsNENBQTRDLEVBQUU7QUFFbEUsWUFBUTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDUixZQUFRO0FBQUE7QUFBQTtBQUFBO0FBQUEscUJBQStDLEtBQUssS0FBSyxLQUFLO0FBQUE7QUFBQTtBQUV0RSxVQUFNLEVBQUUsTUFBTSxJQUFJLEtBQUs7QUFFdkIsUUFBSSxLQUFLLGNBQWMsZUFBZTtBQUNwQyxZQUFNLEVBQUUsT0FBQUMsT0FBTSxJQUFJLEtBQUs7QUFDdkIsWUFBTSxPQUFPLEtBQUssS0FBSyxLQUFLO0FBQzVCLFlBQU0sVUFBVSxLQUFLLE1BQU0sNkJBQTZCLElBQ3RDLEtBQUssUUFBUSxpQ0FBaUMsU0FBUyxJQUN2RCxLQUFLLFFBQVEsU0FBUyxTQUFTO0FBRWpELFlBQU0sRUFBRSxVQUFVLElBQUksS0FBSztBQUMzQixZQUFNLE9BQU8sVUFBVSxRQUFRLEtBQUs7QUFDcEMsY0FBUSxRQUFRLEVBQ2YsS0FBSyxNQUFNO0FBQ1YsZUFBT0EsT0FBTSxRQUFRLE9BQU8sT0FBTztBQUFBLE1BQ3JDLENBQUMsRUFDQSxLQUFLLENBQUMsZUFBZTtBQUNwQixZQUFJLFlBQVk7QUFDZCxjQUFJLHlCQUFPLGdDQUFnQyx5QkFBeUI7QUFDcEUsaUJBQU8sUUFBUSxPQUFPLGlCQUFpQjtBQUFBLFFBQ3pDO0FBQ0EsZUFBT0EsT0FBTSxPQUFPLFNBQVMsSUFBSTtBQUFBLE1BQ25DLENBQUMsRUFDQTtBQUFBLFFBQUssQ0FBQyxVQUFVO0FBQ2YsaUJBQU8sS0FBSyxTQUFTLE9BQU8sRUFBRSxRQUFTLEtBQUksQ0FBQztBQUFBLFFBQzlDO0FBQUEsUUFDQSxDQUFDLGlCQUFpQjtBQUFBLFFBQUM7QUFBQSxNQUFDO0FBQUEsSUFDdEI7QUFDQSxRQUFJLEtBQUssZ0JBQWdCLGVBQWU7QUFDdEMsZ0JBQVUsVUFBVSxVQUFVLElBQUksRUFBRSxLQUFLLFdBQVk7QUFDbkQsWUFBSSx5QkFBTyxtQ0FBbUM7QUFBQSxNQUNoRCxHQUFHLFNBQVUsT0FBTztBQUNsQixZQUFJLHlCQUFPLCtCQUErQjtBQUFBLE1BQzVDLENBQUM7QUFBQSxJQUNIO0FBQUEsRUFDRjtBQUNGOzs7QUMvR0EsSUFBQUMsb0JBQW1FO0FBRTVELElBQU0sd0JBQU4sY0FBb0Msb0NBQTBCO0FBQUEsRUFRbkUsWUFBWUMsTUFBVSxRQUFnQixrQkFDdEM7QUFDRSxVQUFNQSxJQUFHO0FBSlgsc0JBQXNCO0FBS3BCLFNBQUssU0FBUztBQUNkLFNBQUssbUJBQW1CO0FBQ3hCLFNBQUssZUFBZSxnREFBZ0Q7QUFBQSxFQUN0RTtBQUFBLEVBRUEsV0FBcUI7QUFDbkIsV0FBTyxDQUFDLEdBQUcsQ0FBQyxLQUFLLFVBQVUsR0FBRyxHQUFHLEtBQUssaUJBQWlCLE1BQU0sRUFBRSxRQUFRLENBQUM7QUFBQSxFQUMxRTtBQUFBLEVBRUEsWUFBWSxNQUFzQjtBQUNoQyxXQUFPO0FBQUEsRUFDVDtBQUFBO0FBQUEsRUFHQSxpQkFBaUIsR0FBdUIsSUFBaUI7QUFDdkQsVUFBTSxPQUFPLEVBQUU7QUFFZixPQUFHLFNBQVMsT0FBTyxFQUFFLE1BQU0sWUFBTyxLQUFLLFFBQVEsUUFBUSxFQUFFLEVBQUUsVUFBVSxHQUFHLEdBQUcsRUFBRSxDQUFDO0FBQUEsRUFDaEY7QUFBQTtBQUFBLEVBR0EsYUFBYSxpQkFBeUIsS0FBaUM7QUFDckUsUUFBSSxvQkFBb0IsS0FBSyxZQUFZO0FBQ3ZDLFVBQUkseUJBQU8sTUFBTTtBQUNqQixhQUFNLEtBQUssaUJBQWlCLFNBQVMsR0FBRztBQUN0QyxhQUFLLGlCQUFpQixJQUFJO0FBQUEsTUFDNUI7QUFBQSxJQUNGLE9BQU87QUFDTCxZQUFNLFFBQVEsS0FBSyxpQkFBaUIsUUFBUSxpQkFBaUIsQ0FBQztBQUM5RCxVQUFJLFFBQVEsSUFBSTtBQUNkLGFBQUssaUJBQWlCLE9BQU8sT0FBTyxDQUFDO0FBQUEsTUFDdkM7QUFBQSxJQUNGO0FBQUEsRUFDRjtBQUNGOzs7QUM3Q0EsSUFBQUMsb0JBQW1EOzs7QUNGbkQsSUFBQUMsb0JBQWdDO0FBRXpCLFNBQVMsZUFBZUMsTUFBVTtBQUNyQyxTQUFPLHFCQUFxQkEsTUFBSyxDQUFDQyxTQUFRLHlCQUF5QixLQUFLQSxJQUFHLENBQUM7QUFDaEY7QUFFTyxTQUFTLHFCQUFxQkQsTUFBVSxRQUEwQztBQU56RjtBQU9JLFFBQU0sUUFBUUEsS0FBSSxNQUFNLGlCQUFpQjtBQUN6QyxRQUFNLFFBQWtCLENBQUM7QUFDekIsYUFBVyxRQUFRLE9BQU87QUFDdEIsVUFBTSxRQUFRQSxLQUFJLGNBQWMsU0FBUyxLQUFLLElBQUk7QUFDbEQsUUFBSSxVQUFVLE1BQU07QUFDaEI7QUFBQSxJQUNKO0FBQ0EsNENBQVcsS0FBSyxNQUFoQixtQkFBbUIsUUFBUSxDQUFDQyxTQUFRO0FBQ2hDLFVBQUksVUFBVSxRQUFRLE9BQU9BLElBQUcsR0FBRztBQUMvQixjQUFNLGFBQXVCLGVBQWVBLElBQUc7QUFDL0MsbUJBQVcsU0FBUyxZQUFZO0FBQzVCLGNBQUksQ0FBQyxNQUFNLFNBQVMsS0FBSyxHQUFHO0FBQ3hCLGtCQUFNLEtBQUssS0FBSztBQUFBLFVBQ3BCO0FBQUEsUUFDSjtBQUFBLE1BQ0o7QUFBQSxJQUNKO0FBQUEsRUFDSjtBQUNBLFNBQU8sTUFBTSxLQUFLLENBQUMsR0FBVyxNQUFjLEVBQUUsY0FBYyxDQUFDLENBQUM7QUFDbEU7QUFzQ0EsU0FBUyxlQUFlQyxNQUF1QjtBQUczQyxRQUFNLFNBQW1CLENBQUM7QUFDMUIsUUFBTSxXQUFXQSxLQUFJLE1BQU0sR0FBRztBQUM5QixNQUFJLFdBQVcsU0FBUyxDQUFDO0FBQ3pCLFNBQU8sS0FBSyxRQUFRO0FBQ3BCLGFBQVcsV0FBVyxTQUFTLE1BQU0sR0FBRyxTQUFTLE1BQU0sR0FBRztBQUN0RCxnQkFBWSxNQUFNO0FBQ2xCLFdBQU8sS0FBSyxRQUFRO0FBQUEsRUFDeEI7QUFDQSxTQUFPO0FBQ1g7OztBRGxFTyxJQUFNLGlCQUFOLGNBQTZCLG9DQUEwQjtBQUFBLEVBTTdELFlBQW1CQyxNQUFrQixRQUFnQixRQUFrQjtBQUN0RSxVQUFNQSxJQUFHO0FBRFMsZUFBQUE7QUFBa0I7QUFFcEMsU0FBSyxTQUFTO0FBQ2QsU0FBSyxpQkFBaUIsQ0FBQyxVQUF5QjtBQUMvQyxVQUFJLE1BQU0sV0FBVyxNQUFNLFVBQVUsTUFBTSxZQUFZLE1BQU0sUUFBUSxLQUFLO0FBQ3hFLGFBQUssTUFBTTtBQUFBLE1BQ2IsV0FBVyxNQUFNLFdBQVcsTUFBTSxXQUFXLE1BQU0sWUFBWSxNQUFNLFFBQVEsS0FBSztBQUNoRixhQUFLLE1BQU07QUFBQSxNQUNiLFdBQVcsTUFBTSxXQUFXLE1BQU0sU0FBUztBQUN6QyxjQUFNLE1BQU0sU0FBUyxNQUFNLEtBQUssRUFBRTtBQUNsQyxZQUFJLE9BQU8sS0FBSyxPQUFPLEdBQUc7QUFDM0IsZ0JBQU0sZUFBZTtBQUNyQixlQUFLLGNBQWMsTUFBTSxDQUFDO0FBQUEsUUFDekI7QUFBQSxNQUNGO0FBQUEsSUFDQztBQUdBLGFBQVMsaUJBQWlCLFdBQVcsS0FBSyxjQUFjO0FBQzFELFNBQUssU0FBUztBQUFBLEVBRWY7QUFBQSxFQUVBLGNBQWMsT0FBZTtBQUM1QixVQUFNLFdBQVcsS0FBSyxrQkFBa0IsaUJBQWlCLGtCQUFrQjtBQUMzRSxRQUFJLFNBQVMsU0FBUyxPQUFPO0FBQzNCLFlBQU0sVUFBVSxTQUFTLEtBQUs7QUFDOUIsY0FBUSxNQUFNO0FBQUEsSUFDaEI7QUFBQSxFQUNEO0FBQUEsRUFFQSxXQUFxQjtBQUNwQixXQUFPLHFCQUFxQixLQUFLLEdBQUc7QUFBQSxFQUNyQztBQUFBLEVBRUEsWUFBWSxNQUFzQjtBQUNqQyxXQUFPO0FBQUEsRUFDUjtBQUFBLEVBRUEsTUFBTSxhQUFhLE1BQWMsS0FBdUM7QUFHdEUsU0FBSyxPQUFPLGNBQWMsZUFBZTtBQUN6QyxTQUFLLE9BQU8scUJBQXFCO0FBQ2pDLFNBQUssT0FBTyxjQUFjLE9BQU87QUFBQSxFQU1uQztBQUFBLEVBRUEsVUFBVTtBQUNULFVBQU0sUUFBUTtBQUVkLGFBQVMsb0JBQW9CLFdBQVcsS0FBSyxjQUFjO0FBQUEsRUFFNUQ7QUFBQSxFQUVBLGlCQUFpQkMsTUFBeUIsSUFBaUI7QUFDMUQsVUFBTSxXQUFXQSxLQUFJO0FBQ3JCLFVBQU0sUUFBUSxLQUFLLGtCQUFrQixpQkFBaUIsa0JBQWtCLEVBQUU7QUFDMUUsVUFBTSxZQUFZLFFBQVEsS0FBSyxRQUFRLE9BQU87QUFDOUMsT0FBRyxTQUFTLE9BQU8sRUFBRSxNQUFNLFlBQVksU0FBUyxDQUFDO0FBQUEsRUFDbEQ7QUFFRDs7O0FwRnRFQSxJQUFBQyxvQkFBd0I7QUFDeEIsSUFBQUMsaUJBQW1COzs7QXNGWm5CLElBQUFDLG9CQUFtRDs7O0FDRG5ELElBQUFDLG9CQUF5RjtBQUlsRixTQUFTLGVBQWUsV0FBbUIsUUFBZ0JDLE1BQVUscUJBQThCLGFBQXFCO0FBQzNILFFBQU0sUUFBZSxLQUFLLElBQUk7QUFDOUIsUUFBTSxZQUF1QixLQUFLLElBQUk7QUFDdEMsUUFBTSxPQUFPLFVBQVUsUUFBUSxLQUFLO0FBQ3BDLFFBQU0sUUFBZSxNQUFNLHNCQUFzQixNQUFNO0FBQ3ZELFFBQU0sT0FBTztBQUNiLFVBQVEsUUFBUSxFQUNmLEtBQUssTUFBTTtBQUNSLFdBQU8sS0FBSyxTQUFTLE9BQU8sRUFBRSxRQUFRLEtBQUssQ0FBQztBQUFBLEVBQ2hELENBQUMsRUFDQSxLQUFLLE1BQU07QUFFUixVQUFNLGVBQWVBLEtBQUksVUFBVSxvQkFBb0IsOEJBQVk7QUFDbkUsVUFBTSxTQUFTLDZDQUFjO0FBQzdCLFVBQU0sUUFBUSw2Q0FBYztBQUM1QixRQUFJLGdCQUFnQixRQUFRLFVBQVUsUUFBUSxTQUFTLE1BQU07QUFDekQsWUFBTSxjQUFjLG1CQUFtQjtBQUN2QyxhQUFPLFFBQVEsT0FBTyxXQUFXO0FBQUEsSUFDckM7QUFDQSxVQUFNLGNBQWMsS0FBSyxLQUFLLEVBQUUsUUFBUSxPQUFPLEVBQUU7QUFDakQsUUFBSSxPQUFPLFNBQVMsRUFBRSxTQUFTLFdBQVcsR0FBRztBQUN6QyxZQUFNLGNBQWMsUUFBUSxpQ0FBaUM7QUFDN0QsVUFBSSx5QkFBTyxXQUFXO0FBR3RCLGVBQVMsSUFBSSxHQUFHLElBQUksT0FBTyxVQUFVLEdBQUcsS0FBSztBQUN6QyxZQUFJLE9BQU8sUUFBUSxDQUFDLEVBQUUsU0FBUyxXQUFXLEdBQUc7QUFDekMsaUJBQU8sVUFBVSxFQUFDLE1BQU0sR0FBRyxJQUFJLEVBQUMsQ0FBQztBQUNqQyxpQkFBTyxlQUFlLEVBQUMsTUFBTSxFQUFDLE1BQU0sR0FBRyxJQUFJLEVBQUMsR0FBRyxJQUFJLEVBQUMsTUFBTSxHQUFHLElBQUksRUFBQyxFQUFDLEdBQUcsSUFBSTtBQUMxRTtBQUFBLFFBQ0o7QUFBQSxNQUNKO0FBQUEsSUFDSixPQUFPO0FBQ0gsVUFBSSxjQUFjLEdBQUc7QUFDakIsY0FBTSxXQUFXLHNCQUNqQiwwQ0FBMEMsT0FBTyxJQUFJLElBQ3JELHdDQUF3QyxPQUFPLElBQUk7QUFDbkQscUJBQWEsWUFBWSxVQUFVLEtBQUs7QUFDeEMsZUFBTyxTQUFTLFFBQVE7QUFDeEIsWUFBSSxxQkFBcUI7QUFDckIsZ0JBQU0sbUJBQW1CO0FBQ3pCLGNBQUksaUJBQWlCLEtBQUssS0FBSyxHQUFHO0FBQzlCLGtCQUFNLHVCQUF1Qix3QkFBd0IsS0FBSztBQUMxRCxtQkFBTyxVQUFVLEVBQUUsTUFBTSxzQkFBc0IsSUFBSSxFQUFFLENBQUM7QUFDdEQsbUJBQU8sZUFBZSxFQUFDLE1BQU0sRUFBQyxNQUFNLHNCQUFzQixJQUFJLEVBQUMsR0FBRyxJQUFJLEVBQUMsTUFBTSxzQkFBc0IsSUFBSSxFQUFDLEVBQUMsR0FBRyxJQUFJO0FBQUEsVUFDcEgsT0FBTztBQUNILG1CQUFPLFVBQVUsRUFBRSxNQUFNLEdBQUcsSUFBSSxFQUFFLENBQUM7QUFDbkMsbUJBQU8sZUFBZSxFQUFDLE1BQU0sRUFBQyxNQUFNLEdBQUcsSUFBSSxFQUFDLEdBQUcsSUFBSSxFQUFDLE1BQU0sR0FBRyxJQUFJLEVBQUMsRUFBQyxHQUFHLElBQUk7QUFBQSxVQUM5RTtBQUFBLFFBQ0osT0FBTztBQUNILGdCQUFNLGNBQWMsT0FBTyxVQUFVLElBQUk7QUFDekMsaUJBQU8sVUFBVSxFQUFFLE1BQU0sYUFBYSxJQUFJLEVBQUUsQ0FBQztBQUM3QyxpQkFBTyxlQUFlLEVBQUMsTUFBTSxFQUFDLE1BQU0sYUFBYSxJQUFJLEVBQUMsR0FBRyxJQUFJLEVBQUMsTUFBTSxhQUFhLElBQUksRUFBQyxFQUFDLEdBQUcsSUFBSTtBQUFBLFFBQ2xHO0FBQ0EsWUFBSSx5QkFBTyxpQkFBaUIsc0JBQXNCLGNBQWMsWUFBWSxTQUFTO0FBQUEsTUFDekYsT0FBTztBQUNILGNBQU0sV0FBZ0Msc0JBQ3RDLGlEQUFpRCxPQUFPLE1BQU0sV0FBVyxJQUN6RSwrQ0FBK0MsT0FBTyxNQUFNLFdBQVc7QUFDdkUscUJBQWEsWUFBWSxTQUFTLE9BQU8sS0FBSztBQUM5QyxlQUFPLFNBQVMsU0FBUyxLQUFLO0FBQzlCLGVBQU8sVUFBVSxFQUFDLE1BQU0sU0FBUyxNQUFNLElBQUksRUFBQyxDQUFDO0FBQzdDLGVBQU8sZUFBZSxFQUFDLE1BQU0sRUFBQyxNQUFNLFNBQVMsTUFBTSxJQUFJLEVBQUMsR0FBRyxJQUFJLEVBQUMsTUFBTSxTQUFTLE1BQU0sSUFBSSxFQUFDLEVBQUMsR0FBRyxJQUFJO0FBQ2xHLFlBQUkseUJBQU8saUJBQWlCLHNCQUFzQixjQUFjLHVCQUF1QixTQUFTO0FBQUEsTUFtQnBHO0FBQUEsSUFDSjtBQUNBLFdBQU8sUUFBUSxRQUFRO0FBQUEsRUFDM0IsQ0FBQyxFQUNBLE1BQU0sQ0FBQyxXQUFXO0FBQ2YsUUFBSSx5QkFBTyxNQUFNO0FBQUEsRUFDckIsQ0FBQztBQTBCTDtBQUVBLFNBQVMsd0JBQXdCLE9BQWU7QUFDNUMsUUFBTSxTQUFTLE1BQU0sTUFBTSxJQUFJO0FBQy9CLE1BQUksVUFBVTtBQUNkLFFBQU0sVUFBVSxPQUFPO0FBQ3ZCLFdBQVMsSUFBSSxHQUFHLElBQUksU0FBUyxLQUFLO0FBQzlCLFFBQUksT0FBTyxDQUFDLE1BQU0sT0FBTztBQUNyQjtBQUFBLElBQ0o7QUFDQSxRQUFJLFdBQVcsR0FBRztBQUNkLGFBQU8sS0FBSyxJQUFJLElBQUksR0FBRyxVQUFVLENBQUM7QUFBQSxJQUN0QztBQUFBLEVBQ0o7QUFDQSxTQUFPLFVBQVU7QUFDckI7QUFFQSxTQUFTLDBDQUEwQyxPQUFlLE1BQWM7QUFDNUUsUUFBTSxtQkFBbUI7QUFFekIsTUFBSSxpQkFBaUIsS0FBSyxLQUFLLEdBQUc7QUFDOUIsV0FBTyxNQUFNLFFBQVEsa0JBQWtCLE9BQU8sT0FBTyxJQUFJO0FBQUEsRUFDN0QsT0FBTztBQUNILFdBQU8sT0FBTyxPQUFPO0FBQUEsRUFDekI7QUFDSjtBQUVBLFNBQVMsd0NBQXdDLE9BQWUsTUFBYztBQUMxRSxTQUFPLFFBQVEsT0FBTztBQUMxQjtBQU9BLFNBQVMsaURBQWlELE9BQWUsTUFBYyxhQUEwQztBQUM3SCxRQUFNLFNBQW1CLE1BQU0sTUFBTSxJQUFJO0FBQ3pDLE1BQUksU0FBUztBQUNiLE1BQUksWUFBWTtBQUNoQixNQUFJLGNBQWM7QUFDbEIsV0FBUyxJQUFJLEdBQUcsSUFBSSxPQUFPLFFBQVEsS0FBSztBQUNwQyxRQUFJLEtBQUssYUFBYTtBQUNsQixnQkFBVSxPQUFPLENBQUMsSUFBSTtBQUFBLElBQzFCLFdBQVcsT0FBTyxDQUFDLEVBQUUsS0FBSyxNQUFNLElBQUk7QUFDaEMsZ0JBQVUsT0FBTyxDQUFDLElBQUk7QUFBQSxJQUMxQixXQUFXLENBQUMsYUFBYTtBQUNyQixnQkFBVSxPQUFPLE9BQU8sT0FBTyxDQUFDLElBQUk7QUFDcEMsa0JBQVk7QUFDWixvQkFBYztBQUFBLElBQ2xCLE9BQU87QUFDSCxnQkFBVSxPQUFPLENBQUMsSUFBSTtBQUFBLElBQzFCO0FBQUEsRUFDSjtBQUNBLFNBQU8sRUFBQyxPQUFPLE9BQU8sUUFBUSxPQUFPLEVBQUUsR0FBRyxNQUFNLGNBQWMsWUFBWSxZQUFXO0FBQ3pGO0FBRUEsU0FBUywrQ0FBK0MsT0FBZSxNQUFjLGFBQTBDO0FBQzNILFFBQU0sU0FBbUIsTUFBTSxNQUFNLElBQUk7QUFFekMsTUFBSSxZQUFZO0FBRWhCLE1BQUksbUJBQW1CLE9BQU8sU0FBUztBQUV2QyxXQUFTLElBQUksYUFBYSxJQUFJLE9BQU8sUUFBUSxLQUFLO0FBQzlDLFFBQUksTUFBTSxhQUFhO0FBQUEsSUFFdkIsT0FBTztBQUNILFVBQUksYUFBYSxLQUFLLE9BQU8sQ0FBQyxDQUFDLEdBQUc7QUFDOUIsMkJBQW1CLElBQUk7QUFDdkI7QUFBQSxNQUNKO0FBQUEsSUFDSjtBQUFBLEVBQ0o7QUFHQSxNQUFJLFNBQVM7QUFFYixXQUFTLElBQUksa0JBQWtCLElBQUksZUFBZSxDQUFDLFFBQVEsS0FBSztBQUM1RCxRQUFJLE9BQU8sQ0FBQyxFQUFFLEtBQUssTUFBTSxJQUFJO0FBQ3pCLGtCQUFZO0FBQ1osZUFBUztBQUFBLElBQ2I7QUFBQSxFQUNKO0FBSUEsTUFBSSxTQUFTO0FBQ2IsV0FBUyxJQUFJLEdBQUcsSUFBSSxPQUFPLFFBQVEsS0FBSztBQUNwQyxRQUFJLEtBQUssV0FBVztBQUNoQixnQkFBVSxPQUFPLENBQUMsSUFBSTtBQUFBLElBQzFCLE9BQU87QUFDSCxnQkFBVSxPQUFPLENBQUMsSUFBSSxPQUFPLE9BQU87QUFBQSxJQUN4QztBQUFBLEVBQ0o7QUFFQSxTQUFPLEVBQUMsT0FBTyxPQUFPLFFBQVEsT0FBTyxFQUFFLEdBQUcsTUFBTSxZQUFZLEVBQUM7QUFDakU7OztBQ3ZOQSxJQUFBQyxvQkFBMEY7QUFHbkYsU0FBUyxvQkFBb0IsU0FBMkI7QUFDM0QsUUFBTSxZQUFzQixDQUFDO0FBQzdCLGFBQVcsWUFBWSx3QkFBd0IsT0FBTyxHQUFHO0FBQ3JELFFBQUksQ0FBQyxVQUFVLFNBQVMsUUFBUSxHQUFHO0FBQy9CLGdCQUFVLEtBQUssUUFBUTtBQUFBLElBQzNCO0FBQUEsRUFDSjtBQUNBLFNBQU8sVUFBVSxLQUFLLENBQUMsR0FBVyxNQUFjLEVBQUUsY0FBYyxDQUFDLENBQUM7QUFDdEU7QUFFTyxTQUFTLDJCQUEyQkMsTUFBVSxTQUFtQztBQUNwRixRQUFNLFdBQXFCLG9CQUFvQixPQUFPO0FBQ3RELFFBQU0sYUFBK0IsQ0FBQztBQUN0QyxhQUFXLFlBQVksVUFBVTtBQUM3QixVQUFNLE9BQWVBLEtBQUksTUFBTSxzQkFBc0IsUUFBUTtBQUM3RCxVQUFNLFlBQVlBLEtBQUksY0FBYyxhQUFhLElBQUk7QUFDckQsUUFBSSxDQUFDLFdBQVc7QUFBQSxJQUVoQixXQUFXLENBQUMsVUFBVSxVQUFVO0FBQUEsSUFFaEMsT0FBTztBQUNILGdCQUFVLFNBQVMsUUFBUSxPQUFLO0FBQzVCLG1CQUFXLEtBQUssRUFBQyxVQUFVLFVBQVUsUUFBUSxNQUFNLEVBQUUsU0FBUyxXQUFXLEVBQUUsU0FBUyxNQUFNLE1BQU0sVUFBVSxLQUFJLENBQUM7QUFBQSxNQUNuSCxDQUFDO0FBQUEsSUFDTDtBQUFBLEVBQ0o7QUFDQSxTQUFPO0FBQ1g7QUFHQSxTQUFTLHdCQUF3QixTQUFnQztBQUM3RCxRQUFNLE9BQVk7QUFDbEIsUUFBTSxVQUFvQixDQUFDO0FBRTNCLGFBQVcsUUFBUSxLQUFLLE1BQU0saUJBQWlCLEdBQUc7QUFDOUMsVUFBTSxRQUErQixLQUFLLGNBQWMsYUFBYSxJQUFJO0FBQ3pFLFFBQUksU0FBUyxRQUFRLE1BQU0sTUFBTTtBQUM3QixpQkFBV0MsUUFBTyxNQUFNLE1BQU07QUFDMUIsWUFBSSxZQUFZQSxLQUFJLEtBQUs7QUFDckIsa0JBQVEsS0FBSyxLQUFLLElBQUk7QUFBQSxRQUMxQjtBQUFBLE1BQ0o7QUFBQSxJQUNKO0FBQ0EsUUFBSSxTQUFTLFFBQVEsTUFBTSxhQUFhO0FBQ3BDLFlBQU0sY0FBVSx3Q0FBcUIsTUFBTSxXQUFXLEtBQUssQ0FBQyxHQUFHLE9BQU8sQ0FBQUEsU0FBTyxXQUFXQSxRQUFPQSxLQUFJLFdBQVcsVUFBVSxHQUFHLENBQUM7QUFDNUgsVUFBSSxPQUFPLFFBQVE7QUFDZixnQkFBUSxLQUFLLEtBQUssSUFBSTtBQUFBLE1BQzFCO0FBQ0EsWUFBTSxlQUFXLDJDQUF3QixNQUFNLFdBQVcsS0FBSyxDQUFDLEdBQUcsT0FBTyxDQUFBQSxTQUFPLFdBQVdBLFFBQU9BLEtBQUksV0FBVyxVQUFVLEdBQUcsQ0FBQztBQUNoSSxVQUFJLFFBQVEsUUFBUTtBQUNoQixnQkFBUSxLQUFLLEtBQUssSUFBSTtBQUFBLE1BQzFCO0FBQUEsSUFDSjtBQUFBLEVBQ0o7QUFDQSxTQUFPO0FBQ1g7OztBQ2pETyxJQUFNLFlBQVk7OztBSEZ6QixJQUFNLHFCQUFxQjtBQUVwQixJQUFNLHFDQUFOLGNBQWlELG9DQUFrQztBQUFBLEVBY3hGLFlBQVlDLE1BQVUsV0FBbUIsV0FBbUIsYUFBcUIscUJBQThCLFlBQy9HO0FBQ0UsVUFBTUEsSUFBRztBQUNULFNBQUssWUFBWTtBQUNqQixTQUFLLFlBQVk7QUFDakIsU0FBSyxzQkFBc0I7QUFDM0IsU0FBSyxjQUFjO0FBQ25CLFNBQUssYUFBYTtBQUNsQixTQUFLLGVBQWUsd0JBQXdCLDRCQUE0QixrQkFBa0Isc0JBQXNCLGNBQWMscUJBQXFCO0FBQ25KLFNBQUssZ0JBQWdCO0FBQUEsTUFDbkI7QUFBQSxRQUNFLFNBQVM7QUFBQSxRQUNULFNBQVMsd0JBQXdCLDRCQUE0QixrQkFBa0Isc0JBQXNCLGNBQWM7QUFBQSxNQUNySDtBQUFBLElBQ0YsQ0FBQztBQUNELFNBQUssaUJBQWlCLENBQUMsVUFBeUI7QUFDOUMsVUFBSSxNQUFNLFdBQVcsTUFBTSxTQUFTO0FBQ2xDLGNBQU0sTUFBTSxTQUFTLE1BQU0sS0FBSyxFQUFFO0FBQ2xDLFlBQUksT0FBTyxLQUFLLE9BQU8sR0FBRztBQUN4QixnQkFBTSxlQUFlO0FBQ3JCLGVBQUssY0FBYyxNQUFNLENBQUM7QUFBQSxRQUM1QjtBQUFBLE1BQ0Y7QUFBQSxJQUNGO0FBR0EsYUFBUyxpQkFBaUIsV0FBVyxLQUFLLGNBQWM7QUFBQSxFQUMxRDtBQUFBLEVBRUEsY0FBYyxPQUFlO0FBQzNCLFVBQU0sV0FBVyxLQUFLLGtCQUFrQixpQkFBaUIsa0JBQWtCO0FBQzNFLFFBQUksU0FBUyxTQUFTLE9BQU87QUFDM0IsWUFBTSxVQUFVLFNBQVMsS0FBSztBQUM5QixjQUFRLE1BQU07QUFBQSxJQUNoQjtBQUFBLEVBQ0Y7QUFBQSxFQUVBLFVBQVU7QUFDUixVQUFNLFFBQVE7QUFFZCxhQUFTLG9CQUFvQixXQUFXLEtBQUssY0FBYztBQUFBLEVBQzdEO0FBQUEsRUFFQSxXQUE2QjtBQUMzQixVQUFNLFlBQVksb0JBQW9CLEtBQUssU0FBUztBQUNwRCxVQUFNLHFCQUFxQiwyQkFBMkIsS0FBSyxLQUFLLEtBQUssU0FBUztBQUU5RSxXQUFPO0FBQUEsTUFBQyxHQUFHLENBQUMsRUFBQyxVQUFVLG9CQUFvQixRQUFRLElBQUksV0FBVyxJQUFJLFVBQVUsS0FBSSxDQUFDO0FBQUEsTUFDbkYsR0FBRyxVQUFVLElBQUksT0FBSztBQUFFLGVBQU8sRUFBQyxVQUFVLEdBQUcsUUFBUSxJQUFJLFdBQVcsSUFBSSxVQUFVLFlBQVksQ0FBQyxFQUFDO0FBQUEsTUFBRSxDQUFDO0FBQUEsTUFDbkcsR0FBRyxDQUFDLEVBQUMsVUFBVSxXQUFXLFFBQVEsSUFBSSxXQUFXLEdBQUcsVUFBVSxLQUFLLENBQUM7QUFBQSxNQUNwRSxHQUFHO0FBQUEsSUFBa0I7QUFBQSxFQUN6QjtBQUFBLEVBRUEsWUFBWSxNQUE4QjtBQUN4QyxXQUFPLEtBQUssV0FBVyxLQUFLO0FBQUEsRUFDOUI7QUFBQTtBQUFBLEVBR0EsaUJBQWlCLE1BQWtDLElBQWlCO0FBQ2xFLFVBQU0sT0FBdUIsS0FBSztBQUNsQyxVQUFNLFdBQW1CLEtBQUs7QUFDOUIsUUFBSSxTQUFTLEtBQUssV0FBWSxLQUFLLFNBQVMsU0FBUyxLQUFLLFNBQVMsU0FBUyxNQUFNLEtBQU07QUFTeEYsVUFBTSxRQUFRLEtBQUssa0JBQWtCLGlCQUFpQixrQkFBa0IsRUFBRTtBQUMxRSxVQUFNLFlBQVksUUFBUSxLQUFLLFFBQVEsT0FBTztBQUM5QyxPQUFHLFNBQVMsT0FBTyxFQUFFLE1BQU0sWUFBWSxTQUFTLEtBQUssU0FBUSxDQUFDO0FBQzlELFFBQUksS0FBSyxLQUFLLE9BQU8sU0FBUyxHQUFHO0FBQy9CLFNBQUcsU0FBUyxTQUFTLEVBQUUsTUFBTSxVQUFVLEtBQUssT0FBTSxDQUFDO0FBQUEsSUFDckQ7QUFBQSxFQUNGO0FBQUE7QUFBQSxFQUdBLGFBQWEsTUFBc0IsS0FBaUM7QUFDbEUsUUFBSSxzQkFBc0IsS0FBSyxVQUFVO0FBQ3ZDLFVBQUksb0JBQW9CLEtBQUssS0FBSyxLQUFLLFdBQVcsS0FBSyxhQUFhLEtBQUsscUJBQXFCLEtBQUssVUFBVSxFQUFFLEtBQUs7QUFBQSxJQUN0SCxXQUFXLGNBQWMsS0FBSyxVQUFVO0FBQUEsSUFFeEMsT0FBTztBQUNMLHFCQUFlLEtBQUssV0FBVyxLQUFLLFVBQVUsS0FBSyxLQUFLLEtBQUsscUJBQXFCLEtBQUssU0FBUztBQUNoRyxXQUFLLFdBQVc7QUFBQSxJQUNsQjtBQUFBLEVBQ0Y7QUFDRjs7O0FJL0dBLElBQUFDLG9CQUErRDs7O0FDRXhELFNBQVMsY0FBY0MsTUFBVSxVQUF1QztBQUMzRSxRQUFNLGFBQStCLENBQUM7QUFDdEMsYUFBVyxZQUFZLFVBQVU7QUFDN0IsVUFBTSxPQUFlQSxLQUFJLE1BQU0sc0JBQXNCLFFBQVE7QUFDN0QsVUFBTSxZQUFvQ0EsS0FBSSxjQUFjLGFBQWEsSUFBSTtBQUM3RSxRQUFJLENBQUMsV0FBVztBQUFBLElBRWhCLFdBQVcsQ0FBQyxVQUFVLFVBQVU7QUFBQSxJQUVoQyxPQUFPO0FBQ0gsZ0JBQVUsU0FBUyxRQUFRLE9BQUs7QUFDNUIsbUJBQVcsS0FBSyxFQUFDLFVBQVUsVUFBVSxRQUFRLE1BQU0sRUFBRSxTQUFTLFdBQVcsRUFBRSxTQUFTLE1BQU0sTUFBTSxVQUFVLEtBQUksQ0FBQztBQUFBLE1BQ25ILENBQUM7QUFBQSxJQUNMO0FBQUEsRUFDSjtBQUNBLFNBQU87QUFDWDs7O0FDakJPLFNBQVMsZUFBZUMsTUFBVSxPQUF5QjtBQUNoRSxRQUFNLG9CQUFvQkEsS0FBSSxVQUFVLGlCQUFpQixFQUFFLE9BQU8sVUFBUUEsS0FBSSxNQUFNLHNCQUFzQixJQUFJLE1BQU0sSUFBSTtBQUN4SCxTQUFPLGtCQUFrQixNQUFNLEdBQUcsS0FBSyxJQUFJLE9BQU8sa0JBQWtCLE1BQU0sQ0FBQztBQUM3RTtBQUVPLFNBQVMsWUFBWUEsTUFBb0I7QUFDOUMsUUFBTSxRQUFRQSxLQUFJLE1BQU0saUJBQWlCO0FBQ3pDLFFBQU0sV0FBVyxNQUFNLElBQUksQ0FBQyxTQUFTLEtBQUssSUFBSTtBQUM5QyxTQUFPO0FBQ1Q7QUFFTyxTQUFTLDJCQUEyQkEsTUFBb0I7QUFDN0QsTUFBSUMsOEJBQXVDLENBQUM7QUFDNUMsUUFBTSxRQUFRRCxLQUFJLE1BQU0saUJBQWlCO0FBQ3pDLFFBQU0sUUFBUSxDQUFDLFNBQVM7QUFDdEIsVUFBTSxZQUFvQyxLQUFLLElBQUksY0FBYyxhQUFhLElBQUk7QUFDbEYsUUFBSSxXQUFXO0FBQ2IsWUFBTSxjQUE2QyxVQUFVO0FBQzdELFVBQUksQ0FBQyxhQUFhO0FBQ2hCLFFBQUFDLDRCQUEyQixLQUFLLEtBQUssSUFBSTtBQUFBLE1BQzNDO0FBQUEsSUFDRjtBQUFBLEVBQ0YsQ0FBQztBQUNELFNBQU9BO0FBQ1Q7OztBRmpCTyxJQUFNLHNCQUFOLGNBQWtDLG9DQUFrQztBQUFBLEVBVXpFLFlBQVlDLE1BQVUsV0FBbUIsYUFBcUIscUJBQThCLFlBQzVGO0FBQ0UsVUFBTUEsSUFBRztBQUNULFNBQUssWUFBWTtBQUNqQixTQUFLLGNBQWM7QUFDbkIsU0FBSyxzQkFBc0I7QUFDM0IsU0FBSyxhQUFhO0FBQ2xCLFNBQUssZUFBZSx3Q0FBd0Msa0JBQWtCLHNCQUFzQixjQUFjLHFCQUFxQjtBQUN2SSxTQUFLLGdCQUFnQjtBQUFBLE1BQ25CO0FBQUEsUUFDRSxTQUFTO0FBQUEsUUFDVCxTQUFTLHdDQUF3QyxrQkFBa0Isc0JBQXNCLGNBQWM7QUFBQSxNQUN6RztBQUFBLElBQ0YsQ0FBQztBQUNELFNBQUssaUJBQWlCLENBQUMsVUFBeUI7QUFDOUMsVUFBSSxNQUFNLFdBQVcsTUFBTSxTQUFTO0FBQ2xDLGNBQU0sTUFBTSxTQUFTLE1BQU0sS0FBSyxFQUFFO0FBQ2xDLFlBQUksT0FBTyxLQUFLLE9BQU8sR0FBRztBQUN4QixnQkFBTSxlQUFlO0FBQ3JCLGVBQUssY0FBYyxNQUFNLENBQUM7QUFBQSxRQUM1QjtBQUFBLE1BQ0Y7QUFBQSxJQUNGO0FBR0EsYUFBUyxpQkFBaUIsV0FBVyxLQUFLLGNBQWM7QUFDeEQsU0FBSyxRQUFRLEtBQUssYUFBYTtBQUFBLEVBQ2pDO0FBQUEsRUFFQSxjQUFjLE9BQWU7QUFDM0IsVUFBTSxXQUFXLEtBQUssa0JBQWtCLGlCQUFpQixrQkFBa0I7QUFDM0UsUUFBSSxTQUFTLFNBQVMsT0FBTztBQUMzQixZQUFNLFVBQVUsU0FBUyxLQUFLO0FBQzlCLGNBQVEsTUFBTTtBQUFBLElBQ2hCO0FBQUEsRUFDRjtBQUFBLEVBRUEsV0FBOEI7QUFDNUIsV0FBTyxLQUFLO0FBQUEsRUFDZDtBQUFBLEVBRUEsZUFBa0M7QUFDaEMsVUFBTSxlQUFlLFlBQVksS0FBSyxHQUFHO0FBQ3pDLFVBQU0sWUFBWSxjQUFjLEtBQUssS0FBSyxZQUFZO0FBQ3hELFVBQU0sSUFBSTtBQUFBLE1BQUMsR0FBRyxDQUFDLEVBQUMsVUFBVSxjQUFjLFFBQVEsSUFBSSxXQUFXLElBQUksVUFBVSxZQUFZLFlBQVksRUFBQyxDQUFDO0FBQUEsTUFDMUYsR0FBRyxlQUFlLEtBQUssS0FBSyxFQUFFLEVBQUUsSUFBSSxPQUFLO0FBQUUsZUFBTyxFQUFDLFVBQVUsR0FBRyxRQUFRLElBQUksV0FBVyxJQUFJLFVBQVUsWUFBWSxDQUFDLEVBQUM7QUFBQSxNQUFFLENBQUM7QUFBQSxNQUN0SCxHQUFHLGVBQWUsS0FBSyxHQUFHLEVBQUUsSUFBSSxPQUFLLEVBQUUsUUFBUSxNQUFNLEdBQUcsQ0FBQyxFQUFFLElBQUksT0FBSztBQUFFLGVBQU8sRUFBQyxVQUFVLEdBQUcsUUFBUSxJQUFJLFdBQVcsSUFBSSxVQUFVLEtBQUk7QUFBQSxNQUFFLENBQUM7QUFBQSxNQUN2SSxHQUFHLGFBQWEsSUFBSSxPQUFLO0FBQUUsZUFBTyxFQUFDLFVBQVUsR0FBRyxRQUFRLElBQUksV0FBVyxJQUFJLFVBQVUsWUFBWSxDQUFDLEVBQUM7QUFBQSxNQUFFLENBQUM7QUFBQSxNQUN0RyxHQUFHO0FBQUEsSUFDSjtBQUVWLFdBQU8sRUFBRSxPQUFPLENBQUMsTUFBTSxVQUFVLEVBQUUsUUFBUSxJQUFJLE1BQU0sS0FBSztBQUFBLEVBRTVEO0FBQUEsRUFFQSxVQUFVO0FBQ1IsVUFBTSxRQUFRO0FBRWQsYUFBUyxvQkFBb0IsV0FBVyxLQUFLLGNBQWM7QUFBQSxFQUM3RDtBQUFBLEVBRUEsWUFBWSxPQUErQjtBQUN6QyxXQUFPLE1BQU0sV0FBVyxNQUFNO0FBQUEsRUFDaEM7QUFBQTtBQUFBLEVBR0EsaUJBQWlCLE9BQW1DLElBQWlCO0FBQ25FLFVBQU0sT0FBTyxNQUFNO0FBQ25CLFFBQUksU0FBUyxLQUFLLFdBQVksS0FBSyxTQUFTLFNBQVMsS0FBSyxTQUFTLFNBQVMsTUFBTSxLQUFNO0FBT3hGLFVBQU0sUUFBUSxLQUFLLGtCQUFrQixpQkFBaUIsa0JBQWtCLEVBQUU7QUFDMUUsVUFBTSxZQUFZLFFBQVEsS0FBSyxRQUFRLE9BQU87QUFDOUMsT0FBRyxTQUFTLE9BQU8sRUFBRSxNQUFNLFlBQVksU0FBUyxLQUFLLFNBQVEsQ0FBQztBQUM5RCxRQUFJLEtBQUssT0FBTyxTQUFTLEdBQUc7QUFDMUIsU0FBRyxTQUFTLFNBQVMsRUFBRSxNQUFNLFVBQVUsS0FBSyxPQUFNLENBQUM7QUFBQSxJQUNyRDtBQUFBLEVBQ0Y7QUFBQSxFQUVBLFNBQVM7QUFDUCxVQUFNLE9BQU87QUFDYixTQUFLLFFBQVEsUUFBUTtBQUNyQixTQUFLLFFBQVEsUUFBUSxPQUFPO0FBRTVCLFNBQUssUUFBUSxpQkFBaUIsU0FBUyxNQUFNO0FBQzNDLFVBQUksS0FBSyxRQUFRLE1BQU0sV0FBVyxHQUFHLE1BQU0sS0FBSyxRQUFRLE1BQU0sU0FBUyxLQUFLLEtBQUssUUFBUSxNQUFNLFNBQVMsR0FBRyxJQUFLO0FBQzlHLGFBQUssUUFBUSxRQUFRLEtBQUssUUFBUSxNQUFNLFVBQVUsQ0FBQztBQUFBLE1BQ3JEO0FBQUEsSUFDRixDQUFDO0FBRUQsU0FBSyxRQUFRLGlCQUFpQixTQUFTLENBQUMsVUFBVTtBQUVoRCxVQUFJLEtBQUssUUFBUSxVQUFVLEtBQUs7QUFFOUIsY0FBTSxlQUFlO0FBR3JCLGNBQU0sUUFBUSxNQUFNLGlCQUFpQixPQUFPLGVBQWUsUUFBUSxNQUFNO0FBR3pFLGFBQUssUUFBUSxRQUFRO0FBQ3JCLGFBQUssUUFBUSxRQUFRLE9BQU87QUFBQSxNQUM5QjtBQUFBLElBQ0YsQ0FBQztBQUFBLEVBQ0g7QUFBQTtBQUFBLEVBR0EsTUFBTSxhQUFhLGNBQThCLEtBQWlDO0FBQ2hGLFFBQUksYUFBYSxTQUFTLFdBQVcsR0FBRyxHQUFHO0FBQ3pDLFVBQUksbUNBQW1DLEtBQUssS0FBSyxLQUFLLFdBQVcsYUFBYSxTQUFTLFFBQVEsTUFBTSxHQUFHLEdBQUcsS0FBSyxhQUFhLEtBQUsscUJBQXFCLEtBQUssVUFBVSxFQUFFLEtBQUs7QUFBQSxJQUMvSyxPQUFPO0FBQ0wscUJBQWUsS0FBSyxXQUFXLGFBQWEsVUFBVSxLQUFLLEtBQUssS0FBSyxxQkFBcUIsYUFBYSxTQUFTO0FBQ2hILFdBQUssV0FBVztBQUFBLElBQ2xCO0FBQUEsRUFDRjtBQUNGOzs7QUd6SUEsSUFBQUMsb0JBQTZKO0FBTTdKLElBQU1DLHNCQUFxQjtBQUMzQixJQUFNLHNCQUFzQjtBQUVyQixJQUFNLHFDQUFOLGNBQWlELCtCQUE2QjtBQUFBLEVBS25GLFlBQVlDLE1BQVUsV0FDdEI7QUFDRSxVQUFNQSxJQUFHO0FBQ1QsU0FBSyxZQUFZO0FBQ2pCLFNBQUssZUFBZSx3QkFBd0IsdUNBQXVDO0FBQ25GLFNBQUssZ0JBQWdCO0FBQUEsTUFDbkI7QUFBQSxRQUNFLFNBQVM7QUFBQSxRQUNULFNBQVMsd0JBQXdCO0FBQUEsTUFDbkM7QUFBQSxJQUNGLENBQUM7QUFDRCxTQUFLLGlCQUFpQixDQUFDLFVBQXlCO0FBTzlDLFVBQUksTUFBTSxXQUFXLE1BQU0sVUFBVSxNQUFNLFlBQVksTUFBTSxRQUFRLEtBQUs7QUFDeEUsYUFBSyxNQUFNO0FBQUEsTUFDYixXQUFXLE1BQU0sV0FBVyxNQUFNLFdBQVcsTUFBTSxZQUFZLE1BQU0sUUFBUSxLQUFLO0FBQ2hGLGFBQUssTUFBTTtBQUFBLE1BQ2IsV0FBVyxNQUFNLFdBQVcsTUFBTSxTQUFTO0FBQ3pDLGNBQU0sTUFBTSxTQUFTLE1BQU0sS0FBSyxFQUFFO0FBQ2xDLFlBQUksT0FBTyxLQUFLLE9BQU8sR0FBRztBQUN4QixnQkFBTSxlQUFlO0FBQ3JCLGVBQUssY0FBYyxNQUFNLENBQUM7QUFBQSxRQUM1QjtBQUFBLE1BQ0Y7QUFBQSxJQUNGO0FBR0EsYUFBUyxpQkFBaUIsV0FBVyxLQUFLLGNBQWM7QUFBQSxFQUMxRDtBQUFBLEVBRUEsY0FBYyxPQUFlO0FBQzNCLFVBQU0sV0FBVyxLQUFLLGtCQUFrQixpQkFBaUIsa0JBQWtCO0FBQzNFLFFBQUksU0FBUyxTQUFTLE9BQU87QUFDM0IsWUFBTSxVQUFVLFNBQVMsS0FBSztBQUM5QixjQUFRLE1BQU07QUFBQSxJQUNoQjtBQUFBLEVBQ0Y7QUFBQSxFQUVBLFVBQVU7QUFDUixVQUFNLFFBQVE7QUFFZCxhQUFTLG9CQUFvQixXQUFXLEtBQUssY0FBYztBQUFBLEVBQzdEO0FBQUEsRUFDRixNQUFNLGVBQWUsT0FBMEM7QUFDN0QsVUFBTSxZQUFzQixvQkFBb0IsS0FBSyxTQUFTO0FBQzlELFVBQU0sVUFBNEIsQ0FBQztBQUNuQyxVQUFNLFFBQTBCLENBQUM7QUFFakMsVUFBTSxjQUFjLENBQUMseUJBQXlCLEtBQUssS0FBSyxTQUFTLEtBQzlELENBQUMsa0JBQWtCLEtBQUssS0FBSyxTQUFTLEtBQ3RDLENBQUMsV0FBVyxLQUFLLEtBQUssU0FBUztBQUVsQyxVQUFNLGVBQWUsVUFBVSxJQUFJLE9BQU8sYUFBYTtBQUNyRCxZQUFNLE9BQU8sS0FBSyxJQUFJLE1BQU0sc0JBQXNCLFFBQVE7QUFDMUQsWUFBTSxZQUFZLEtBQUssSUFBSSxjQUFjLGFBQWEsSUFBSTtBQUMxRCxVQUFJLENBQUM7QUFBVztBQUVoQixVQUFJLGFBQWE7QUFDZixZQUFJLFVBQVUsTUFBTTtBQUNsQixnQkFBTSxVQUFVLE1BQU0sS0FBSyxJQUFJLE1BQU0sS0FBSyxJQUFJO0FBQzlDLGdCQUFNLFlBQVksUUFBUSxNQUFNLElBQUk7QUFDcEMscUJBQVdDLFFBQU8sVUFBVSxNQUFNO0FBQ2hDLGdCQUFJQSxLQUFJLFFBQVEsS0FBSyxXQUFXO0FBQzlCLG9CQUFNQyxXQUFVLEtBQUssa0JBQWtCLFdBQVdELEtBQUksU0FBUyxNQUFNLElBQUk7QUFDekUsb0JBQU0sY0FBYyxVQUFVQSxLQUFJLFNBQVMsTUFBTSxJQUFJLEVBQUUsS0FBSztBQUM1RCxtQkFBSyxXQUFXLGFBQWEsWUFBWSxFQUFFLFNBQVMsTUFBTSxZQUFZLENBQUMsR0FFdkU7QUFDRSxzQkFBTSxLQUFLO0FBQUEsa0JBQ1QsVUFBVTtBQUFBLGtCQUNWLFNBQVNDLFdBQVVBLFdBQVUsWUFBWSxNQUFNO0FBQUEsa0JBQy9DLFdBQVdELEtBQUksU0FBUyxNQUFNO0FBQUEsa0JBQzlCLFVBQVU7QUFBQSxnQkFDWixDQUFDO0FBQUEsY0FDSDtBQUFBLFlBQ0Y7QUFBQSxVQUNGO0FBQUEsUUFDRjtBQUFBLE1BQ0YsT0FBTztBQUNMLFlBQUksVUFBVSxVQUFVO0FBQ3RCLG9CQUFVLFNBQVMsUUFBUSxPQUFLO0FBQzlCLG9CQUFRLEtBQUs7QUFBQSxjQUNYLFVBQVU7QUFBQSxjQUNWLFFBQVEsTUFBTSxFQUFFO0FBQUEsY0FDaEIsV0FBVyxFQUFFLFNBQVMsTUFBTTtBQUFBLGNBQzVCLFVBQVU7QUFBQSxZQUNaLENBQUM7QUFBQSxVQUNILENBQUM7QUFBQSxRQUNIO0FBQUEsTUFDRjtBQUFBLElBQ0YsQ0FBQztBQUVELFVBQU0sUUFBUSxJQUFJLFlBQVk7QUFFOUIsUUFBSSxhQUFhO0FBQ2YsYUFBTztBQUFBLFFBQ0wsRUFBRSxVQUFVRixxQkFBb0IsUUFBUSxJQUFJLFdBQVcsR0FBRyxVQUFVLEtBQUs7QUFBQSxRQUN6RSxFQUFFLFVBQVUscUJBQXFCLFFBQVEsSUFBSSxXQUFXLEdBQUcsVUFBVSxLQUFLO0FBQUEsUUFDMUUsR0FBRztBQUFBLE1BQ0w7QUFBQSxJQUNGO0FBRUEsV0FBTztBQUFBLE1BQ0wsRUFBRSxVQUFVQSxxQkFBb0IsUUFBUSxJQUFJLFdBQVcsR0FBRyxVQUFVLEtBQUs7QUFBQSxNQUN6RSxFQUFFLFVBQVUscUJBQXFCLFFBQVEsSUFBSSxXQUFXLEdBQUcsVUFBVSxLQUFLO0FBQUEsTUFDMUUsR0FBRyxVQUFVLE9BQU8sT0FBSyxFQUFFLFlBQVksRUFBRSxTQUFTLE1BQU0sWUFBWSxDQUFDLENBQUMsRUFBRSxJQUFJLFFBQU0sRUFBRSxVQUFVLEdBQUcsUUFBUSxJQUFJLFdBQVcsR0FBRyxVQUFVLFlBQVksQ0FBQyxFQUFFLEVBQUU7QUFBQTtBQUFBLE1BRXRKLEVBQUUsVUFBVSxXQUFXLFFBQVEsSUFBSSxXQUFXLEdBQUcsVUFBVSxLQUFLO0FBQUEsTUFDaEUsR0FBRztBQUFBLElBQ0w7QUFBQSxFQUNGO0FBQUEsRUFHQSxrQkFBa0IsV0FBMkIsWUFBNEI7QUFDdkUsUUFBSSxDQUFDLGFBQWEsQ0FBQyxVQUFVLFVBQVU7QUFDckMsYUFBTztBQUFBLElBQ1Q7QUFFQSxVQUFNLFdBQVcsVUFBVTtBQUMzQixRQUFJLGlCQUFpQjtBQUVyQixlQUFXRyxZQUFXLFVBQVU7QUFDOUIsVUFBSUEsU0FBUSxTQUFTLE1BQU0sUUFBUSxZQUFZO0FBQzdDLHlCQUFpQixPQUFPQSxTQUFRO0FBQUEsTUFDbEMsT0FBTztBQUNMO0FBQUEsTUFDRjtBQUFBLElBQ0Y7QUFFQSxXQUFPO0FBQUEsRUFDVDtBQUFBLEVBRUEsV0FBVyxLQUFhLFNBQTBCO0FBQ2hELFFBQUksQ0FBQztBQUFTLGFBQU87QUFDckIsY0FBVSxRQUFRLE1BQU0sRUFBRSxFQUFFLE9BQU8sQ0FBQyxHQUFHLE1BQU0sR0FBRyxNQUFNLEdBQUc7QUFDekQsV0FBTyxJQUFJLE9BQU8sT0FBTyxFQUFFLEtBQUssR0FBRztBQUFBLEVBQ3JDO0FBQUEsRUFFRSxZQUFZLE1BQThCO0FBQ3hDLFdBQU8sS0FBSyxXQUFXLEtBQUs7QUFBQSxFQUM5QjtBQUFBO0FBQUE7QUFBQSxFQUlFLGlCQUFpQixNQUFzQixJQUFpQjtBQUV4RCxVQUFNLFdBQW1CLEtBQUs7QUFDOUIsUUFBSSxTQUFTLEtBQUssV0FBWSxLQUFLLFNBQVMsU0FBUyxLQUFLLFNBQVMsU0FBUyxNQUFNLEtBQU07QUFReEYsVUFBTSxRQUFRLEtBQUssa0JBQWtCLGlCQUFpQixrQkFBa0IsRUFBRTtBQUMxRSxVQUFNLFlBQVksUUFBUSxLQUFLLFFBQVEsT0FBTztBQUM5QyxPQUFHLFNBQVMsT0FBTyxFQUFFLE1BQU0sWUFBWSxTQUFTLFNBQVMsQ0FBQztBQUUxRCxRQUFJLEtBQUssT0FBTyxTQUFTLEdBQUc7QUFDMUIsU0FBRyxTQUFTLFNBQVMsRUFBRSxNQUFNLFVBQVUsS0FBSyxPQUFNLENBQUM7QUFBQSxJQUNyRDtBQUFBLEVBQ0Y7QUFBQSxFQUVBLG1CQUFtQixNQUFzQixLQUFpQztBQUl4RSxRQUFJSCx3QkFBdUIsS0FBSyxVQUFVO0FBQ3hDLFVBQUksMkJBQTJCLEtBQUssR0FBRyxFQUFFLEtBQUs7QUFBQSxJQUNoRCxXQUFXLHdCQUF3QixLQUFLLFVBQVU7QUFFbEQsWUFBTSxlQUNMLEtBQUssSUFDSixnQkFBZ0IsY0FBYyxlQUFlO0FBRS9DLFlBQU0sU0FBUyxnQkFBZ0IsYUFBYTtBQUN4QyxZQUFNLHlCQUF5QixPQUFPLEtBQUs7QUFDM0MsYUFBTyxpQkFBaUIsc0JBQXNCO0FBQUEsSUFDbEQsV0FBVyxjQUFjLEtBQUssVUFBVTtBQUFBLElBRXhDLE9BQU87QUFDTCxZQUFNLEVBQUUsT0FBTyxVQUFVLElBQUksS0FBSztBQUNsQyxZQUFNLE9BQU8sVUFBVSxRQUFRLEtBQUs7QUFDcEMsY0FBUSxRQUFRLEVBQ2YsS0FBSyxNQUFNO0FBQ1IsZUFBTyxLQUFLLFNBQVMsTUFBTSxzQkFBc0IsS0FBSyxRQUFRLEdBQVksRUFBRSxRQUFTLEtBQUssQ0FBQztBQUFBLE1BRS9GLENBQUMsRUFDQSxLQUFLLE1BQU07QUFDVixjQUFNLGVBQWUsSUFBSSxVQUFVLG9CQUFvQiw4QkFBWTtBQUNuRSxjQUFNLFNBQVMsNkNBQWM7QUFDN0IsWUFBSSxnQkFBZ0IsUUFBUSxVQUFVLE1BQU07QUFDeEMsZ0JBQU0sY0FBYyxtQkFBbUIsS0FBSztBQUM1QyxpQkFBTyxRQUFRLE9BQU8sV0FBVztBQUFBLFFBQ3JDO0FBQ0EsZUFBTyxVQUFVLEVBQUMsTUFBTSxLQUFLLFdBQVcsSUFBSSxFQUFDLENBQUM7QUFFOUMsZUFBTyxlQUFlLEVBQUMsTUFBTSxFQUFDLE1BQU0sS0FBSyxXQUFXLElBQUksRUFBQyxHQUFHLElBQUksRUFBQyxNQUFNLEtBQUssV0FBVyxJQUFJLEVBQUMsRUFBQyxHQUFHLElBQUk7QUFBQSxNQUN0RyxDQUFDO0FBQUEsSUFDSDtBQUFBLEVBQ0Y7QUFDRjs7O0FDN05BLElBQUFJLG9CQUE0RjtBQVk1RixJQUFNLE9BQU87QUFDYixJQUFNLFVBQVU7QUFDaEIsSUFBTSxNQUFNO0FBQ1osSUFBTSxVQUFVO0FBRVQsSUFBTSw2QkFBTixjQUF5QyxvQ0FBd0I7QUFBQSxFQUt0RSxZQUFZQyxNQUNaO0FBQ0UsVUFBTUEsSUFBRztBQUNULFNBQUssZUFBZSxtREFBbUQ7QUFDdkUsU0FBSyxnQkFBZ0I7QUFBQSxNQUNuQjtBQUFBLFFBQ0UsU0FBUztBQUFBLFFBQ1QsU0FBUztBQUFBLE1BQ1g7QUFBQSxJQUNGLENBQUM7QUFDRCxTQUFLLGlCQUFpQixDQUFDLFVBQXlCO0FBTzlDLFVBQUksTUFBTSxXQUFXLE1BQU0sVUFBVSxNQUFNLFlBQVksTUFBTSxRQUFRLEtBQUs7QUFDeEUsYUFBSyxNQUFNO0FBQUEsTUFDYixXQUFXLE1BQU0sV0FBVyxNQUFNLFdBQVcsTUFBTSxZQUFZLE1BQU0sUUFBUSxLQUFLO0FBQ2hGLGFBQUssTUFBTTtBQUFBLE1BQ2IsV0FBVyxNQUFNLFdBQVcsTUFBTSxTQUFTO0FBQ3pDLGNBQU0sTUFBTSxTQUFTLE1BQU0sS0FBSyxFQUFFO0FBQ2xDLFlBQUksT0FBTyxLQUFLLE9BQU8sR0FBRztBQUN4QixnQkFBTSxlQUFlO0FBQ3JCLGVBQUssY0FBYyxNQUFNLENBQUM7QUFBQSxRQUM1QjtBQUFBLE1BQ0Y7QUFBQSxJQUNGO0FBR0EsYUFBUyxpQkFBaUIsV0FBVyxLQUFLLGNBQWM7QUFDeEQsU0FBSyxRQUFRLEtBQUssYUFBYTtBQUFBLEVBQ2pDO0FBQUEsRUFFQSxjQUFjLE9BQWU7QUFDM0IsVUFBTSxXQUFXLEtBQUssa0JBQWtCLGlCQUFpQixrQkFBa0I7QUFDM0UsUUFBSSxTQUFTLFNBQVMsT0FBTztBQUMzQixZQUFNLFVBQVUsU0FBUyxLQUFLO0FBQzlCLGNBQVEsTUFBTTtBQUFBLElBQ2hCO0FBQUEsRUFDRjtBQUFBLEVBRUEsVUFBVTtBQUNSLFVBQU0sUUFBUTtBQUVkLGFBQVMsb0JBQW9CLFdBQVcsS0FBSyxjQUFjO0FBQUEsRUFDN0Q7QUFBQSxFQUVBLFdBQW9CO0FBQ2xCLFdBQU8sS0FBSztBQUFBLEVBQ2Q7QUFBQSxFQUVBLGVBQXdCO0FBQ3RCLFVBQU0sV0FBVyxZQUFZLEtBQUssR0FBRztBQUNyQyxRQUFJLFdBQXNCLENBQUM7QUFDM0IsYUFBUyxRQUFRLE9BQUs7QUFDcEIsWUFBTSxPQUFPLEtBQUssSUFBSSxNQUFNLHNCQUFzQixDQUFDO0FBQ25ELFlBQU0sWUFBWSxLQUFLLElBQUksY0FBYyxhQUFhLElBQUk7QUFDMUQsVUFBSSxDQUFDLFdBQVc7QUFDZDtBQUFBLE1BQ0Y7QUFDQSxVQUFJLENBQUMsVUFBVSxVQUFVO0FBQ3ZCO0FBQUEsTUFDRjtBQUNBLGdCQUFVLFNBQVMsUUFBUSxPQUFLO0FBQzlCLGlCQUFTLEtBQUssRUFBQyxNQUFNLEdBQUcsU0FBUyxFQUFFLFNBQVMsT0FBTyxFQUFFLE9BQU8sV0FBVyxFQUFFLFNBQVMsTUFBTSxLQUFJLENBQUM7QUFBQSxNQUMvRixDQUFDO0FBQUEsSUFDSCxDQUFDO0FBQ0gsV0FBTztBQUFBLE1BQ0gsR0FBRyxlQUFlLEtBQUssS0FBSyxFQUFFLEVBQUUsSUFBSSxPQUFLO0FBQ3ZDLGVBQU8sRUFBQyxRQUFRLEdBQUcsV0FBVyxJQUFJLE1BQU0sUUFBTztBQUFBLE1BQ2pELENBQUM7QUFBQSxNQUNELEdBQUcscUJBQXFCLEtBQUssR0FBRyxFQUFFLElBQUksT0FBSztBQUN6QyxlQUFPLEVBQUMsUUFBUSxFQUFFLFFBQVEsTUFBTSxHQUFHLEdBQUcsV0FBVyxJQUFJLE1BQU0sSUFBRztBQUFBLE1BQ2hFLENBQUM7QUFBQSxNQUNELEdBQUcsU0FBUyxJQUFJLE9BQUs7QUFDbkIsZUFBTyxFQUFDLFFBQVEsR0FBRyxXQUFXLElBQUksTUFBTSxLQUFJO0FBQUEsTUFDOUMsQ0FBQztBQUFBLE1BQ0QsR0FBRyxTQUFTLElBQUksT0FBSztBQUNuQixlQUFPLEVBQUMsUUFBUSxJQUFJLE9BQU8sRUFBRSxLQUFLLElBQUksTUFBTSxFQUFFLFNBQVMsV0FBVyxFQUFFLE1BQU0sTUFBTSxRQUFPO0FBQUEsTUFDekYsQ0FBQztBQUFBLElBQ0g7QUFBQSxFQUNGO0FBQUEsRUFFQSxZQUFZLE9BQXFCO0FBQy9CLFdBQU8sTUFBTTtBQUFBLEVBQ2Y7QUFBQTtBQUFBLEVBR0EsaUJBQWlCLE9BQXlCLElBQWlCO0FBQ3pELFVBQU0sT0FBTyxNQUFNO0FBQ25CLFFBQUksU0FBUztBQUNiLFFBQUksS0FBSyxTQUFTLFFBQVEsS0FBSyxTQUFTLFNBQVM7QUFDL0MsWUFBTSxXQUFXLFlBQVksS0FBSyxNQUFNO0FBQ3hDLGVBQVMsV0FBVyxTQUFTLFNBQVMsTUFBTTtBQUFBLElBQzlDO0FBQ0EsVUFBTSxRQUFRLEtBQUssa0JBQWtCLGlCQUFpQixrQkFBa0IsRUFBRTtBQUMxRSxVQUFNLFlBQVksUUFBUSxLQUFLLFFBQVEsT0FBTztBQUM5QyxPQUFHLFNBQVMsT0FBTyxFQUFFLE1BQU0sWUFBWSxTQUFTLEtBQUssT0FBTyxDQUFDO0FBQzdELE9BQUcsU0FBUyxTQUFTLEVBQUUsTUFBTSxVQUFVLEtBQUssT0FBTyxNQUFNLEtBQUssVUFBVSxDQUFDO0FBQUEsRUFDM0U7QUFBQSxFQUVBLFNBQVM7QUFDUCxVQUFNLE9BQU87QUFDYixTQUFLLFFBQVEsUUFBUTtBQUNyQixTQUFLLFFBQVEsUUFBUSxPQUFPO0FBRTVCLFNBQUssUUFBUSxpQkFBaUIsU0FBUyxNQUFNO0FBQzNDLFVBQUksS0FBSyxRQUFRLE1BQU0sV0FBVyxHQUFHLE1BQU0sS0FBSyxRQUFRLE1BQU0sU0FBUyxLQUFLLEtBQUssUUFBUSxNQUFNLFNBQVMsR0FBRyxJQUFLO0FBQzlHLGFBQUssUUFBUSxRQUFRLEtBQUssUUFBUSxNQUFNLFVBQVUsQ0FBQztBQUFBLE1BQ3JEO0FBQUEsSUFDRixDQUFDO0FBRUQsU0FBSyxRQUFRLGlCQUFpQixTQUFTLENBQUMsVUFBVTtBQUVoRCxVQUFJLEtBQUssUUFBUSxVQUFVLEtBQUs7QUFFOUIsY0FBTSxlQUFlO0FBR3JCLGNBQU0sUUFBUSxNQUFNLGlCQUFpQixPQUFPLGVBQWUsUUFBUSxNQUFNO0FBR3pFLGFBQUssUUFBUSxRQUFRO0FBQ3JCLGFBQUssUUFBUSxRQUFRLE9BQU87QUFBQSxNQUM5QjtBQUFBLElBQ0YsQ0FBQztBQUFBLEVBQ0g7QUFBQTtBQUFBLEVBR0EsTUFBTSxhQUFhLGNBQW9CLEtBQWlDO0FBQ3RFLFFBQUksYUFBYSxRQUFRLEtBQUs7QUFDNUIsVUFBSSxtQ0FBbUMsS0FBSyxLQUFLLGFBQWEsT0FBTyxRQUFRLEtBQUssR0FBRyxDQUFDLEVBQUUsS0FBSztBQUFBLElBQy9GLFdBQVcsYUFBYSxRQUFRLFFBQVEsYUFBYSxRQUFRLFNBQVM7QUFDcEUsWUFBTSxFQUFFLE9BQU8sVUFBVSxJQUFJLEtBQUs7QUFDbEMsWUFBTSxPQUFPLFVBQVUsUUFBUSxLQUFLO0FBQ3BDLGNBQVEsUUFBUSxFQUNmLEtBQUssTUFBTTtBQUNSLGVBQU8sS0FBSyxTQUFTLE1BQU0sc0JBQXNCLGFBQWEsTUFBTSxHQUFZLEVBQUUsUUFBUyxLQUFLLENBQUM7QUFBQSxNQUNyRyxDQUFDO0FBQUEsSUFDSCxXQUFXLGFBQWEsUUFBUSxTQUFTO0FBQ3ZDLFlBQU0sRUFBRSxPQUFPLFVBQVUsSUFBSSxLQUFLO0FBQ2xDLFlBQU0sT0FBTyxVQUFVLFFBQVEsS0FBSztBQUNwQyxjQUFRLFFBQVEsRUFDZixLQUFLLE1BQU07QUFDUixlQUFPLEtBQUssU0FBUyxNQUFNLHNCQUFzQixhQUFhLFNBQVMsR0FBWSxFQUFFLFFBQVMsS0FBSyxDQUFDO0FBQUEsTUFDeEcsQ0FBQyxFQUNBLEtBQUssTUFBTTtBQUNWLGNBQU0sZUFBZSxJQUFJLFVBQVUsb0JBQW9CLDhCQUFZO0FBQ25FLGNBQU0sU0FBUyw2Q0FBYztBQUM3QixZQUFJLGdCQUFnQixRQUFRLFVBQVUsTUFBTTtBQUN4QyxnQkFBTSxjQUFjLG1CQUFtQixhQUFhO0FBQ3BELGlCQUFPLFFBQVEsT0FBTyxXQUFXO0FBQUEsUUFDckM7QUFDQSxjQUFNLGVBQWUsT0FBTyxVQUFVO0FBQ3RDLGlCQUFTLElBQUksR0FBRyxJQUFJLGNBQWMsS0FBSztBQUNyQyxnQkFBTSxPQUFPLE9BQU8sUUFBUSxDQUFDO0FBQzdCLGNBQUksUUFBUSxhQUFhLFFBQVE7QUFDL0IsbUJBQU8sVUFBVSxFQUFDLE1BQU0sR0FBRyxJQUFJLEVBQUMsQ0FBQztBQUVqQyxtQkFBTyxlQUFlLEVBQUMsTUFBTSxFQUFDLE1BQU0sR0FBRyxJQUFJLEVBQUMsR0FBRyxJQUFJLEVBQUMsTUFBTSxHQUFHLElBQUksRUFBQyxFQUFDLEdBQUcsSUFBSTtBQUMxRTtBQUFBLFVBQ0Y7QUFBQSxRQUNGO0FBQUEsTUFDRixDQUFDO0FBQUEsSUFDSDtBQUFBLEVBQ0Y7QUFDRjs7O0FDN0xPLFNBQVMsdUJBQXVCLFFBQXdCO0FBQzNELE1BQUksT0FBTztBQUNYLFFBQU0saUJBQW9DLE9BQU8sZUFBZTtBQUNoRSxpQkFBZSxRQUFRLG1CQUFpQjtBQUNwQyxVQUFNLElBQUksY0FBYyxLQUFLO0FBQzdCLFVBQU0sSUFBSSxjQUFjLE9BQU87QUFDL0IsVUFBTSxjQUFjLElBQUksSUFBSSxJQUFJO0FBQ2hDLFVBQU0sWUFBWSxJQUFJLElBQUksSUFBSTtBQUM5QixhQUFTLElBQUksYUFBYSxLQUFLLFdBQVcsS0FBSztBQUMzQyxZQUFNLE9BQU8sT0FBTyxRQUFRLENBQUM7QUFDN0IsY0FBUSxPQUFPO0FBQUEsSUFDbkI7QUFBQSxFQUNKLENBQUM7QUFDRCxTQUFPLEtBQUssUUFBUSxPQUFPLEVBQUU7QUFDakM7QUFVTyxTQUFTLDhCQUE4QixRQUFnQztBQUMxRSxNQUFJLE9BQU87QUFDWCxNQUFJLGNBQWM7QUFDbEIsTUFBSSxTQUFTO0FBQ2IsTUFBSSxZQUFZO0FBQ2hCLE1BQUksT0FBTztBQUNYLFFBQU0saUJBQW9DLE9BQU8sZUFBZTtBQUNoRSxpQkFBZSxRQUFRLG1CQUFpQjtBQUNwQyxVQUFNLElBQUksY0FBYyxLQUFLO0FBQzdCLFVBQU0sTUFBTSxjQUFjLEtBQUs7QUFDL0IsVUFBTSxJQUFJLGNBQWMsT0FBTztBQUMvQixVQUFNLE1BQU0sY0FBYyxPQUFPO0FBQ2pDLGtCQUFjLElBQUksSUFBSSxJQUFJO0FBQzFCLGFBQVMsSUFBSSxJQUFJLE1BQU07QUFDdkIsZ0JBQVksSUFBSSxJQUFJLElBQUk7QUFDeEIsV0FBTyxJQUFJLElBQUksTUFBTTtBQUFBLEVBQ3pCLENBQUM7QUFDRCxTQUFPLEVBQUUsYUFBYSxRQUFRLFdBQVcsS0FBSztBQUNsRDs7O0FDMUNBLElBQU0sdUJBQWlDO0FBQUEsRUFDdEM7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUNEO0FBRU8sU0FBUyxzQkFBc0IsT0FBd0I7QUFDMUQsU0FBTyxNQUNGLFFBQVEsNkJBQTZCLEVBQUUsRUFDdkMsUUFBUSxrQ0FBa0MsRUFBRSxFQUM1QyxRQUFRLG1DQUFtQyxFQUFFLEVBQzdDLFFBQVEsbUNBQW1DLEVBQUUsRUFDN0MsUUFBUSx1QkFBdUIsRUFBRSxFQUNqQyxRQUFRLDJCQUEyQixFQUFFLEVBQ3JDLFFBQVEsMEJBQTBCLEVBQUUsRUFDcEMs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QUEsRUFFQSxNQUFNLGVBQWU7QUFDcEIsVUFBTSxLQUFLLFNBQVMsS0FBSyxRQUFRO0FBQUEsRUFDbEM7QUFDRDtBQUVBLElBQU0sbUJBQU4sY0FBK0IsbUNBQWlCO0FBQUEsRUFHL0MsWUFBWUcsTUFBVSxRQUFrQjtBQUN2QyxVQUFNQSxNQUFLLE1BQU07QUFDakIsU0FBSyxTQUFTO0FBQUEsRUFDZjtBQUFBLEVBRUEsVUFBZ0I7QUFDZixVQUFNLEVBQUMsWUFBVyxJQUFJO0FBRXRCLGdCQUFZLE1BQU07QUFFbEIsZ0JBQVksU0FBUyxNQUFNLEVBQUMsTUFBTSxrQ0FBaUMsQ0FBQztBQUVwRSxRQUFJLDBCQUFRLFdBQVcsRUFDckIsUUFBUSxZQUFZLEVBQ3BCLFFBQVEsZUFBZ0IsRUFDeEIsUUFBUSxVQUFRLEtBQ2YsZUFBZSxtQkFBbUIsRUFDbEMsU0FBUyxLQUFLLE9BQU8sU0FBUyxTQUFTLEVBQ3ZDLFNBQVMsT0FBTyxVQUFVO0FBQzFCLGNBQVEsSUFBSSxhQUFhLEtBQUs7QUFDOUIsV0FBSyxPQUFPLFNBQVMsWUFBWTtBQUNqQyxZQUFNLEtBQUssT0FBTyxhQUFhO0FBQUEsSUFDaEMsQ0FBQyxDQUFDO0FBQUEsRUFDTDtBQUNEOyIsCiAgIm5hbWVzIjogWyJtb2R1bGUiLCAibWFwIiwgImZvcm1hdCIsICJsb2NhbGUiLCAidG8iLCAiZnJvbSIsICJ3YXJuIiwgInNldCIsICJub3ciLCAic2lnbiIsICJ0b2tlbiIsICJvcmRpbmFsIiwgImkiLCAic3RyaW5nIiwgImRpZmYiLCAibG9jYWxlRGF0YSIsICJob3VycyIsICJtaW51dGVzIiwgInRva2VucyIsICJtZXJpZGllbSIsICJ5ZWFycyIsICJtb250aHMiLCAid2Vla3MiLCAiZGF5cyIsICJzZWNvbmRzIiwgIm1pbGxpc2Vjb25kcyIsICJvZmZzZXQiLCAidGhyZXNob2xkcyIsICJpbXBvcnRfb2JzaWRpYW4iLCAiaW1wb3J0X29ic2lkaWFuIiwgImlzQWxpYXMiLCAidGFnIiwgInJlcyIsICJtYXAiLCAic2NoZW1hIiwgIm5vZGUiLCAic2NoZW1hIiwgImkiLCAiZW5kIiwgInRhZyIsICJ0YWciLCAibWFwIiwgInZhbHVlIiwgInNjaGVtYSIsICJzdHJpbmdpZnkiLCAiY29tbWVudCIsICJzdHIiLCAic2NoZW1hIiwgIm1hcCIsICJzY2hlbWEiLCAibWFwIiwgInNjaGVtYSIsICJzZXEiLCAic2NoZW1hIiwgInNlcSIsICJ0YWciLCAiaW50SWRlbnRpZnkiLCAic2NoZW1hIiwgInNlcSIsICJzY2hlbWEiLCAicGFpcnMiLCAibWFwIiwgInNlcSIsICJwYWlycyIsICJzY2hlbWEiLCAib21hcCIsICJmbG9hdE5hTiIsICJmbG9hdEV4cCIsICJmbG9hdCIsICJpbnRJZGVudGlmeSIsICJpbnRSZXNvbHZlIiwgIm4iLCAiaW50U3RyaW5naWZ5IiwgImludE9jdCIsICJpbnQiLCAiaW50SGV4IiwgInNjaGVtYSIsICJtYXAiLCAic2V0IiwgInJlcyIsICJzY2hlbWEiLCAiaW50T2N0IiwgImludCIsICJpbnRIZXgiLCAiZmxvYXROYU4iLCAiZmxvYXRFeHAiLCAiZmxvYXQiLCAic2NoZW1hIiwgInRhZyIsICJzY2hlbWEiLCAidGFnIiwgInJlcyIsICJ0YWciLCAiY29tcG9zZU5vZGUiLCAiY29tcG9zZUVtcHR5Tm9kZSIsICJtYXAiLCAiY29tcG9zZU5vZGUiLCAiY29tcG9zZUVtcHR5Tm9kZSIsICJzZXEiLCAiY29tcG9zZU5vZGUiLCAiY29tcG9zZUVtcHR5Tm9kZSIsICJpc01hcCIsICJtYXAiLCAiQ04iLCAidGFnIiwgInZhbHVlIiwgImVuZCIsICJ0YWciLCAic2NoZW1hIiwgInRhZyIsICJTQ0FMQVIiLCAiaXNDb2xsZWN0aW9uIiwgImlzU2NhbGFyIiwgInN0cmluZ2lmeSIsICJ2aXNpdCIsICJzdHJpbmdpZnkiLCAiQlJFQUsiLCAiU0tJUCIsICJSRU1PVkUiLCAidmlzaXQiLCAiX3Zpc2l0IiwgIlNDQUxBUiIsICJpc0NvbGxlY3Rpb24iLCAiaXNTY2FsYXIiLCAiY2giLCAiU0NBTEFSIiwgIm1hcCIsICJzZXEiLCAiYXBwIiwgImhhc0Zyb250TWF0dGVyIiwgImlzQWxpYXMiLCAidGFnIiwgImFwcCIsICJtb21lbnQiLCAiaW1wb3J0X29ic2lkaWFuIiwgInRhZyIsICJhcHAiLCAiaW1wb3J0X29ic2lkaWFuIiwgImltcG9ydF9vYnNpZGlhbiIsICJBTExfVFlQRVMiLCAiYXBwIiwgImltcG9ydF9vYnNpZGlhbiIsICJBTExfVFlQRVMiLCAiYXBwIiwgImltcG9ydF9vYnNpZGlhbiIsICJBTExfVFlQRVMiLCAiYXBwIiwgImltcG9ydF9vYnNpZGlhbiIsICJBTExfVFlQRVMiLCAiYXBwIiwgIm5vdGUiLCAiaW1wb3J0X29ic2lkaWFuIiwgImFwcCIsICJpbXBvcnRfb2JzaWRpYW4iLCAiYXBwIiwgImltcG9ydF9vYnNpZGlhbiIsICJhcHAiLCAidmF1bHQiLCAiaW1wb3J0X29ic2lkaWFuIiwgImFwcCIsICJpbXBvcnRfb2JzaWRpYW4iLCAiaW1wb3J0X29ic2lkaWFuIiwgImFwcCIsICJ0YWciLCAidGFnIiwgImFwcCIsICJ0YWciLCAiaW1wb3J0X29ic2lkaWFuIiwgImltcG9ydF9tb21lbnQiLCAiaW1wb3J0X29ic2lkaWFuIiwgImltcG9ydF9vYnNpZGlhbiIsICJhcHAiLCAiaW1wb3J0X29ic2lkaWFuIiwgImFwcCIsICJ0YWciLCAiYXBwIiwgImltcG9ydF9vYnNpZGlhbiIsICJhcHAiLCAiYXBwIiwgImdldEFsbE5vdGVzV2l0aG91dE1ldGFkYXRhIiwgImFwcCIsICJpbXBvcnRfb2JzaWRpYW4iLCAiQkFDS19UT19TRUxFQ1RfVEFHIiwgImFwcCIsICJ0YWciLCAiaGVhZGluZyIsICJpbXBvcnRfb2JzaWRpYW4iLCAiYXBwIiwgImltcG9ydF9vYnNpZGlhbiIsICJpbXBvcnRfb2JzaWRpYW4iLCAiYXBwIiwgImltcG9ydF9vYnNpZGlhbiIsICJhcHAiLCAiaW1wb3J0X29ic2lkaWFuIiwgImFwcCIsICJ0YWciLCAiaW1wb3J0X29ic2lkaWFuIiwgImFwcCIsICJoZWFkaW5nIiwgInRhZyIsICJsaW5lIiwgImNoIiwgImNoMiIsICJhcHAiLCAiaW1wb3J0X29ic2lkaWFuIiwgImFwcCIsICJtb21lbnQiLCAiaW1wb3J0X29ic2lkaWFuIiwgImltcG9ydF9tb21lbnQiLCAiQUxMX1RZUEVTIiwgImFwcCIsICJtb21lbnQiLCAiaW1wb3J0X29ic2lkaWFuIiwgInRhZyIsICJoZWFkaW5nIiwgInVucmVzb2x2ZWRMaW5rcyIsICJsaW5lQ29udGVudCIsICJpIiwgInRhZyIsICJtb21lbnQiLCAibGluZSIsICJhcHAiLCAiYSJdCn0K
