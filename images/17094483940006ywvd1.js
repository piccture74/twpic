/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/moment/moment.js
var require_moment = __commonJS({
  "node_modules/moment/moment.js"(exports, module2) {
    (function(global, factory) {
      typeof exports === "object" && typeof module2 !== "undefined" ? module2.exports = factory() : typeof define === "function" && define.amd ? define(factory) : global.moment = factory();
    })(exports, function() {
      "use strict";
      var hookCallback;
      function hooks() {
        return hookCallback.apply(null, arguments);
      }
      function setHookCallback(callback) {
        hookCallback = callback;
      }
      function isArray(input) {
        return input instanceof Array || Object.prototype.toString.call(input) === "[object Array]";
      }
      function isObject(input) {
        return input != null && Object.prototype.toString.call(input) === "[object Object]";
      }
      function hasOwnProp(a, b) {
        return Object.prototype.hasOwnProperty.call(a, b);
      }
      function isObjectEmpty(obj) {
        if (Object.getOwnPropertyNames) {
          return Object.getOwnPropertyNames(obj).length === 0;
        } else {
          var k;
          for (k in obj) {
            if (hasOwnProp(obj, k)) {
              return false;
            }
          }
          return true;
        }
      }
      function isUndefined(input) {
        return input === void 0;
      }
      function isNumber(input) {
        return typeof input === "number" || Object.prototype.toString.call(input) === "[object Number]";
      }
      function isDate(input) {
        return input instanceof Date || Object.prototype.toString.call(input) === "[object Date]";
      }
      function map2(arr, fn) {
        var res = [], i;
        for (i = 0; i < arr.length; ++i) {
          res.push(fn(arr[i], i));
        }
        return res;
      }
      function extend(a, b) {
        for (var i in b) {
          if (hasOwnProp(b, i)) {
            a[i] = b[i];
          }
        }
        if (hasOwnProp(b, "toString")) {
          a.toString = b.toString;
        }
        if (hasOwnProp(b, "valueOf")) {
          a.valueOf = b.valueOf;
        }
        return a;
      }
      function createUTC(input, format2, locale2, strict) {
        return createLocalOrUTC(input, format2, locale2, strict, true).utc();
      }
      function defaultParsingFlags() {
        return {
          empty: false,
          unusedTokens: [],
          unusedInput: [],
          overflow: -2,
          charsLeftOver: 0,
          nullInput: false,
          invalidEra: null,
          invalidMonth: null,
          invalidFormat: false,
          userInvalidated: false,
          iso: false,
          parsedDateParts: [],
          era: null,
          meridiem: null,
          rfc2822: false,
          weekdayMismatch: false
        };
      }
      function getParsingFlags(m) {
        if (m._pf == null) {
          m._pf = defaultParsingFlags();
        }
        return m._pf;
      }
      var some;
      if (Array.prototype.some) {
        some = Array.prototype.some;
      } else {
        some = function(fun) {
          var t = Object(this), len = t.length >>> 0, i;
          for (i = 0; i < len; i++) {
            if (i in t && fun.call(this, t[i], i, t)) {
              return true;
            }
          }
          return false;
        };
      }
      function isValid(m) {
        if (m._isValid == null) {
          var flags = getParsingFlags(m), parsedParts = some.call(flags.parsedDateParts, function(i) {
            return i != null;
          }), isNowValid = !isNaN(m._d.getTime()) && flags.overflow < 0 && !flags.empty && !flags.invalidEra && !flags.invalidMonth && !flags.invalidWeekday && !flags.weekdayMismatch && !flags.nullInput && !flags.invalidFormat && !flags.userInvalidated && (!flags.meridiem || flags.meridiem && parsedParts);
          if (m._strict) {
            isNowValid = isNowValid && flags.charsLeftOver === 0 && flags.unusedTokens.length === 0 && flags.bigHour === void 0;
          }
          if (Object.isFrozen == null || !Object.isFrozen(m)) {
            m._isValid = isNowValid;
          } else {
            return isNowValid;
          }
        }
        return m._isValid;
      }
      function createInvalid(flags) {
        var m = createUTC(NaN);
        if (flags != null) {
          extend(getParsingFlags(m), flags);
        } else {
          getParsingFlags(m).userInvalidated = true;
        }
        return m;
      }
      var momentProperties = hooks.momentProperties = [], updateInProgress = false;
      function copyConfig(to2, from2) {
        var i, prop, val;
        if (!isUndefined(from2._isAMomentObject)) {
          to2._isAMomentObject = from2._isAMomentObject;
        }
        if (!isUndefined(from2._i)) {
          to2._i = from2._i;
        }
        if (!isUndefined(from2._f)) {
          to2._f = from2._f;
        }
        if (!isUndefined(from2._l)) {
          to2._l = from2._l;
        }
        if (!isUndefined(from2._strict)) {
          to2._strict = from2._strict;
        }
        if (!isUndefined(from2._tzm)) {
          to2._tzm = from2._tzm;
        }
        if (!isUndefined(from2._isUTC)) {
          to2._isUTC = from2._isUTC;
        }
        if (!isUndefined(from2._offset)) {
          to2._offset = from2._offset;
        }
        if (!isUndefined(from2._pf)) {
          to2._pf = getParsingFlags(from2);
        }
        if (!isUndefined(from2._locale)) {
          to2._locale = from2._locale;
        }
        if (momentProperties.length > 0) {
          for (i = 0; i < momentProperties.length; i++) {
            prop = momentProperties[i];
            val = from2[prop];
            if (!isUndefined(val)) {
              to2[prop] = val;
            }
          }
        }
        return to2;
      }
      function Moment(config) {
        copyConfig(this, config);
        this._d = new Date(config._d != null ? config._d.getTime() : NaN);
        if (!this.isValid()) {
          this._d = new Date(NaN);
        }
        if (updateInProgress === false) {
          updateInProgress = true;
          hooks.updateOffset(this);
          updateInProgress = false;
        }
      }
      function isMoment(obj) {
        return obj instanceof Moment || obj != null && obj._isAMomentObject != null;
      }
      function warn2(msg) {
        if (hooks.suppressDeprecationWarnings === false && typeof console !== "undefined" && console.warn) {
          console.warn("Deprecation warning: " + msg);
        }
      }
      function deprecate(msg, fn) {
        var firstTime = true;
        return extend(function() {
          if (hooks.deprecationHandler != null) {
            hooks.deprecationHandler(null, msg);
          }
          if (firstTime) {
            var args = [], arg, i, key;
            for (i = 0; i < arguments.length; i++) {
              arg = "";
              if (typeof arguments[i] === "object") {
                arg += "\n[" + i + "] ";
                for (key in arguments[0]) {
                  if (hasOwnProp(arguments[0], key)) {
                    arg += key + ": " + arguments[0][key] + ", ";
                  }
                }
                arg = arg.slice(0, -2);
              } else {
                arg = arguments[i];
              }
              args.push(arg);
            }
            warn2(
              msg + "\nArguments: " + Array.prototype.slice.call(args).join("") + "\n" + new Error().stack
            );
            firstTime = false;
          }
          return fn.apply(this, arguments);
        }, fn);
      }
      var deprecations = {};
      function deprecateSimple(name, msg) {
        if (hooks.deprecationHandler != null) {
          hooks.deprecationHandler(name, msg);
        }
        if (!deprecations[name]) {
          warn2(msg);
          deprecations[name] = true;
        }
      }
      hooks.suppressDeprecationWarnings = false;
      hooks.deprecationHandler = null;
      function isFunction(input) {
        return typeof Function !== "undefined" && input instanceof Function || Object.prototype.toString.call(input) === "[object Function]";
      }
      function set2(config) {
        var prop, i;
        for (i in config) {
          if (hasOwnProp(config, i)) {
            prop = config[i];
            if (isFunction(prop)) {
              this[i] = prop;
            } else {
              this["_" + i] = prop;
            }
          }
        }
        this._config = config;
        this._dayOfMonthOrdinalParseLenient = new RegExp(
          (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + "|" + /\d{1,2}/.source
        );
      }
      function mergeConfigs(parentConfig, childConfig) {
        var res = extend({}, parentConfig), prop;
        for (prop in childConfig) {
          if (hasOwnProp(childConfig, prop)) {
            if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
              res[prop] = {};
              extend(res[prop], parentConfig[prop]);
              extend(res[prop], childConfig[prop]);
            } else if (childConfig[prop] != null) {
              res[prop] = childConfig[prop];
            } else {
              delete res[prop];
            }
          }
        }
        for (prop in parentConfig) {
          if (hasOwnProp(parentConfig, prop) && !hasOwnProp(childConfig, prop) && isObject(parentConfig[prop])) {
            res[prop] = extend({}, res[prop]);
          }
        }
        return res;
      }
      function Locale(config) {
        if (config != null) {
          this.set(config);
        }
      }
      var keys;
      if (Object.keys) {
        keys = Object.keys;
      } else {
        keys = function(obj) {
          var i, res = [];
          for (i in obj) {
            if (hasOwnProp(obj, i)) {
              res.push(i);
            }
          }
          return res;
        };
      }
      var defaultCalendar = {
        sameDay: "[Today at] LT",
        nextDay: "[Tomorrow at] LT",
        nextWeek: "dddd [at] LT",
        lastDay: "[Yesterday at] LT",
        lastWeek: "[Last] dddd [at] LT",
        sameElse: "L"
      };
      function calendar(key, mom, now2) {
        var output = this._calendar[key] || this._calendar["sameElse"];
        return isFunction(output) ? output.call(mom, now2) : output;
      }
      function zeroFill(number, targetLength, forceSign) {
        var absNumber = "" + Math.abs(number), zerosToFill = targetLength - absNumber.length, sign2 = number >= 0;
        return (sign2 ? forceSign ? "+" : "" : "-") + Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
      }
      var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g, localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g, formatFunctions = {}, formatTokenFunctions = {};
      function addFormatToken(token2, padded, ordinal2, callback) {
        var func = callback;
        if (typeof callback === "string") {
          func = function() {
            return this[callback]();
          };
        }
        if (token2) {
          formatTokenFunctions[token2] = func;
        }
        if (padded) {
          formatTokenFunctions[padded[0]] = function() {
            return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
          };
        }
        if (ordinal2) {
          formatTokenFunctions[ordinal2] = function() {
            return this.localeData().ordinal(
              func.apply(this, arguments),
              token2
            );
          };
        }
      }
      function removeFormattingTokens(input) {
        if (input.match(/\[[\s\S]/)) {
          return input.replace(/^\[|\]$/g, "");
        }
        return input.replace(/\\/g, "");
      }
      function makeFormatFunction(format2) {
        var array = format2.match(formattingTokens), i, length;
        for (i = 0, length = array.length; i < length; i++) {
          if (formatTokenFunctions[array[i]]) {
            array[i] = formatTokenFunctions[array[i]];
          } else {
            array[i] = removeFormattingTokens(array[i]);
          }
        }
        return function(mom) {
          var output = "", i2;
          for (i2 = 0; i2 < length; i2++) {
            output += isFunction(array[i2]) ? array[i2].call(mom, format2) : array[i2];
          }
          return output;
        };
      }
      function formatMoment(m, format2) {
        if (!m.isValid()) {
          return m.localeData().invalidDate();
        }
        format2 = expandFormat(format2, m.localeData());
        formatFunctions[format2] = formatFunctions[format2] || makeFormatFunction(format2);
        return formatFunctions[format2](m);
      }
      function expandFormat(format2, locale2) {
        var i = 5;
        function replaceLongDateFormatTokens(input) {
          return locale2.longDateFormat(input) || input;
        }
        localFormattingTokens.lastIndex = 0;
        while (i >= 0 && localFormattingTokens.test(format2)) {
          format2 = format2.replace(
            localFormattingTokens,
            replaceLongDateFormatTokens
          );
          localFormattingTokens.lastIndex = 0;
          i -= 1;
        }
        return format2;
      }
      var defaultLongDateFormat = {
        LTS: "h:mm:ss A",
        LT: "h:mm A",
        L: "MM/DD/YYYY",
        LL: "MMMM D, YYYY",
        LLL: "MMMM D, YYYY h:mm A",
        LLLL: "dddd, MMMM D, YYYY h:mm A"
      };
      function longDateFormat(key) {
        var format2 = this._longDateFormat[key], formatUpper = this._longDateFormat[key.toUpperCase()];
        if (format2 || !formatUpper) {
          return format2;
        }
        this._longDateFormat[key] = formatUpper.match(formattingTokens).map(function(tok) {
          if (tok === "MMMM" || tok === "MM" || tok === "DD" || tok === "dddd") {
            return tok.slice(1);
          }
          return tok;
        }).join("");
        return this._longDateFormat[key];
      }
      var defaultInvalidDate = "Invalid date";
      function invalidDate() {
        return this._invalidDate;
      }
      var defaultOrdinal = "%d", defaultDayOfMonthOrdinalParse = /\d{1,2}/;
      function ordinal(number) {
        return this._ordinal.replace("%d", number);
      }
      var defaultRelativeTime = {
        future: "in %s",
        past: "%s ago",
        s: "a few seconds",
        ss: "%d seconds",
        m: "a minute",
        mm: "%d minutes",
        h: "an hour",
        hh: "%d hours",
        d: "a day",
        dd: "%d days",
        w: "a week",
        ww: "%d weeks",
        M: "a month",
        MM: "%d months",
        y: "a year",
        yy: "%d years"
      };
      function relativeTime(number, withoutSuffix, string2, isFuture) {
        var output = this._relativeTime[string2];
        return isFunction(output) ? output(number, withoutSuffix, string2, isFuture) : output.replace(/%d/i, number);
      }
      function pastFuture(diff2, output) {
        var format2 = this._relativeTime[diff2 > 0 ? "future" : "past"];
        return isFunction(format2) ? format2(output) : format2.replace(/%s/i, output);
      }
      var aliases = {};
      function addUnitAlias(unit, shorthand) {
        var lowerCase = unit.toLowerCase();
        aliases[lowerCase] = aliases[lowerCase + "s"] = aliases[shorthand] = unit;
      }
      function normalizeUnits(units) {
        return typeof units === "string" ? aliases[units] || aliases[units.toLowerCase()] : void 0;
      }
      function normalizeObjectUnits(inputObject) {
        var normalizedInput = {}, normalizedProp, prop;
        for (prop in inputObject) {
          if (hasOwnProp(inputObject, prop)) {
            normalizedProp = normalizeUnits(prop);
            if (normalizedProp) {
              normalizedInput[normalizedProp] = inputObject[prop];
            }
          }
        }
        return normalizedInput;
      }
      var priorities = {};
      function addUnitPriority(unit, priority) {
        priorities[unit] = priority;
      }
      function getPrioritizedUnits(unitsObj) {
        var units = [], u;
        for (u in unitsObj) {
          if (hasOwnProp(unitsObj, u)) {
            units.push({ unit: u, priority: priorities[u] });
          }
        }
        units.sort(function(a, b) {
          return a.priority - b.priority;
        });
        return units;
      }
      function isLeapYear(year) {
        return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
      }
      function absFloor(number) {
        if (number < 0) {
          return Math.ceil(number) || 0;
        } else {
          return Math.floor(number);
        }
      }
      function toInt(argumentForCoercion) {
        var coercedNumber = +argumentForCoercion, value = 0;
        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
          value = absFloor(coercedNumber);
        }
        return value;
      }
      function makeGetSet(unit, keepTime) {
        return function(value) {
          if (value != null) {
            set$1(this, unit, value);
            hooks.updateOffset(this, keepTime);
            return this;
          } else {
            return get(this, unit);
          }
        };
      }
      function get(mom, unit) {
        return mom.isValid() ? mom._d["get" + (mom._isUTC ? "UTC" : "") + unit]() : NaN;
      }
      function set$1(mom, unit, value) {
        if (mom.isValid() && !isNaN(value)) {
          if (unit === "FullYear" && isLeapYear(mom.year()) && mom.month() === 1 && mom.date() === 29) {
            value = toInt(value);
            mom._d["set" + (mom._isUTC ? "UTC" : "") + unit](
              value,
              mom.month(),
              daysInMonth(value, mom.month())
            );
          } else {
            mom._d["set" + (mom._isUTC ? "UTC" : "") + unit](value);
          }
        }
      }
      function stringGet(units) {
        units = normalizeUnits(units);
        if (isFunction(this[units])) {
          return this[units]();
        }
        return this;
      }
      function stringSet(units, value) {
        if (typeof units === "object") {
          units = normalizeObjectUnits(units);
          var prioritized = getPrioritizedUnits(units), i;
          for (i = 0; i < prioritized.length; i++) {
            this[prioritized[i].unit](units[prioritized[i].unit]);
          }
        } else {
          units = normalizeUnits(units);
          if (isFunction(this[units])) {
            return this[units](value);
          }
        }
        return this;
      }
      var match1 = /\d/, match2 = /\d\d/, match3 = /\d{3}/, match4 = /\d{4}/, match6 = /[+-]?\d{6}/, match1to2 = /\d\d?/, match3to4 = /\d\d\d\d?/, match5to6 = /\d\d\d\d\d\d?/, match1to3 = /\d{1,3}/, match1to4 = /\d{1,4}/, match1to6 = /[+-]?\d{1,6}/, matchUnsigned = /\d+/, matchSigned = /[+-]?\d+/, matchOffset = /Z|[+-]\d\d:?\d\d/gi, matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi, matchTimestamp = /[+-]?\d+(\.\d{1,3})?/, matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i, regexes;
      regexes = {};
      function addRegexToken(token2, regex, strictRegex) {
        regexes[token2] = isFunction(regex) ? regex : function(isStrict, localeData2) {
          return isStrict && strictRegex ? strictRegex : regex;
        };
      }
      function getParseRegexForToken(token2, config) {
        if (!hasOwnProp(regexes, token2)) {
          return new RegExp(unescapeFormat(token2));
        }
        return regexes[token2](config._strict, config._locale);
      }
      function unescapeFormat(s) {
        return regexEscape(
          s.replace("\\", "").replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function(matched, p1, p2, p3, p4) {
            return p1 || p2 || p3 || p4;
          })
        );
      }
      function regexEscape(s) {
        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
      }
      var tokens = {};
      function addParseToken(token2, callback) {
        var i, func = callback;
        if (typeof token2 === "string") {
          token2 = [token2];
        }
        if (isNumber(callback)) {
          func = function(input, array) {
            array[callback] = toInt(input);
          };
        }
        for (i = 0; i < token2.length; i++) {
          tokens[token2[i]] = func;
        }
      }
      function addWeekParseToken(token2, callback) {
        addParseToken(token2, function(input, array, config, token3) {
          config._w = config._w || {};
          callback(input, config._w, config, token3);
        });
      }
      function addTimeToArrayFromToken(token2, input, config) {
        if (input != null && hasOwnProp(tokens, token2)) {
          tokens[token2](input, config._a, config, token2);
        }
      }
      var YEAR = 0, MONTH = 1, DATE = 2, HOUR = 3, MINUTE = 4, SECOND = 5, MILLISECOND = 6, WEEK = 7, WEEKDAY = 8;
      function mod(n, x) {
        return (n % x + x) % x;
      }
      var indexOf;
      if (Array.prototype.indexOf) {
        indexOf = Array.prototype.indexOf;
      } else {
        indexOf = function(o) {
          var i;
          for (i = 0; i < this.length; ++i) {
            if (this[i] === o) {
              return i;
            }
          }
          return -1;
        };
      }
      function daysInMonth(year, month) {
        if (isNaN(year) || isNaN(month)) {
          return NaN;
        }
        var modMonth = mod(month, 12);
        year += (month - modMonth) / 12;
        return modMonth === 1 ? isLeapYear(year) ? 29 : 28 : 31 - modMonth % 7 % 2;
      }
      addFormatToken("M", ["MM", 2], "Mo", function() {
        return this.month() + 1;
      });
      addFormatToken("MMM", 0, 0, function(format2) {
        return this.localeData().monthsShort(this, format2);
      });
      addFormatToken("MMMM", 0, 0, function(format2) {
        return this.localeData().months(this, format2);
      });
      addUnitAlias("month", "M");
      addUnitPriority("month", 8);
      addRegexToken("M", match1to2);
      addRegexToken("MM", match1to2, match2);
      addRegexToken("MMM", function(isStrict, locale2) {
        return locale2.monthsShortRegex(isStrict);
      });
      addRegexToken("MMMM", function(isStrict, locale2) {
        return locale2.monthsRegex(isStrict);
      });
      addParseToken(["M", "MM"], function(input, array) {
        array[MONTH] = toInt(input) - 1;
      });
      addParseToken(["MMM", "MMMM"], function(input, array, config, token2) {
        var month = config._locale.monthsParse(input, token2, config._strict);
        if (month != null) {
          array[MONTH] = month;
        } else {
          getParsingFlags(config).invalidMonth = input;
        }
      });
      var defaultLocaleMonths = "January_February_March_April_May_June_July_August_September_October_November_December".split(
        "_"
      ), defaultLocaleMonthsShort = "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split(
        "_"
      ), MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/, defaultMonthsShortRegex = matchWord, defaultMonthsRegex = matchWord;
      function localeMonths(m, format2) {
        if (!m) {
          return isArray(this._months) ? this._months : this._months["standalone"];
        }
        return isArray(this._months) ? this._months[m.month()] : this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format2) ? "format" : "standalone"][m.month()];
      }
      function localeMonthsShort(m, format2) {
        if (!m) {
          return isArray(this._monthsShort) ? this._monthsShort : this._monthsShort["standalone"];
        }
        return isArray(this._monthsShort) ? this._monthsShort[m.month()] : this._monthsShort[MONTHS_IN_FORMAT.test(format2) ? "format" : "standalone"][m.month()];
      }
      function handleStrictParse(monthName, format2, strict) {
        var i, ii, mom, llc = monthName.toLocaleLowerCase();
        if (!this._monthsParse) {
          this._monthsParse = [];
          this._longMonthsParse = [];
          this._shortMonthsParse = [];
          for (i = 0; i < 12; ++i) {
            mom = createUTC([2e3, i]);
            this._shortMonthsParse[i] = this.monthsShort(
              mom,
              ""
            ).toLocaleLowerCase();
            this._longMonthsParse[i] = this.months(mom, "").toLocaleLowerCase();
          }
        }
        if (strict) {
          if (format2 === "MMM") {
            ii = indexOf.call(this._shortMonthsParse, llc);
            return ii !== -1 ? ii : null;
          } else {
            ii = indexOf.call(this._longMonthsParse, llc);
            return ii !== -1 ? ii : null;
          }
        } else {
          if (format2 === "MMM") {
            ii = indexOf.call(this._shortMonthsParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._longMonthsParse, llc);
            return ii !== -1 ? ii : null;
          } else {
            ii = indexOf.call(this._longMonthsParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._shortMonthsParse, llc);
            return ii !== -1 ? ii : null;
          }
        }
      }
      function localeMonthsParse(monthName, format2, strict) {
        var i, mom, regex;
        if (this._monthsParseExact) {
          return handleStrictParse.call(this, monthName, format2, strict);
        }
        if (!this._monthsParse) {
          this._monthsParse = [];
          this._longMonthsParse = [];
          this._shortMonthsParse = [];
        }
        for (i = 0; i < 12; i++) {
          mom = createUTC([2e3, i]);
          if (strict && !this._longMonthsParse[i]) {
            this._longMonthsParse[i] = new RegExp(
              "^" + this.months(mom, "").replace(".", "") + "$",
              "i"
            );
            this._shortMonthsParse[i] = new RegExp(
              "^" + this.monthsShort(mom, "").replace(".", "") + "$",
              "i"
            );
          }
          if (!strict && !this._monthsParse[i]) {
            regex = "^" + this.months(mom, "") + "|^" + this.monthsShort(mom, "");
            this._monthsParse[i] = new RegExp(regex.replace(".", ""), "i");
          }
          if (strict && format2 === "MMMM" && this._longMonthsParse[i].test(monthName)) {
            return i;
          } else if (strict && format2 === "MMM" && this._shortMonthsParse[i].test(monthName)) {
            return i;
          } else if (!strict && this._monthsParse[i].test(monthName)) {
            return i;
          }
        }
      }
      function setMonth(mom, value) {
        var dayOfMonth;
        if (!mom.isValid()) {
          return mom;
        }
        if (typeof value === "string") {
          if (/^\d+$/.test(value)) {
            value = toInt(value);
          } else {
            value = mom.localeData().monthsParse(value);
            if (!isNumber(value)) {
              return mom;
            }
          }
        }
        dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
        mom._d["set" + (mom._isUTC ? "UTC" : "") + "Month"](value, dayOfMonth);
        return mom;
      }
      function getSetMonth(value) {
        if (value != null) {
          setMonth(this, value);
          hooks.updateOffset(this, true);
          return this;
        } else {
          return get(this, "Month");
        }
      }
      function getDaysInMonth() {
        return daysInMonth(this.year(), this.month());
      }
      function monthsShortRegex(isStrict) {
        if (this._monthsParseExact) {
          if (!hasOwnProp(this, "_monthsRegex")) {
            computeMonthsParse.call(this);
          }
          if (isStrict) {
            return this._monthsShortStrictRegex;
          } else {
            return this._monthsShortRegex;
          }
        } else {
          if (!hasOwnProp(this, "_monthsShortRegex")) {
            this._monthsShortRegex = defaultMonthsShortRegex;
          }
          return this._monthsShortStrictRegex && isStrict ? this._monthsShortStrictRegex : this._monthsShortRegex;
        }
      }
      function monthsRegex(isStrict) {
        if (this._monthsParseExact) {
          if (!hasOwnProp(this, "_monthsRegex")) {
            computeMonthsParse.call(this);
          }
          if (isStrict) {
            return this._monthsStrictRegex;
          } else {
            return this._monthsRegex;
          }
        } else {
          if (!hasOwnProp(this, "_monthsRegex")) {
            this._monthsRegex = defaultMonthsRegex;
          }
          return this._monthsStrictRegex && isStrict ? this._monthsStrictRegex : this._monthsRegex;
        }
      }
      function computeMonthsParse() {
        function cmpLenRev(a, b) {
          return b.length - a.length;
        }
        var shortPieces = [], longPieces = [], mixedPieces = [], i, mom;
        for (i = 0; i < 12; i++) {
          mom = createUTC([2e3, i]);
          shortPieces.push(this.monthsShort(mom, ""));
          longPieces.push(this.months(mom, ""));
          mixedPieces.push(this.months(mom, ""));
          mixedPieces.push(this.monthsShort(mom, ""));
        }
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);
        for (i = 0; i < 12; i++) {
          shortPieces[i] = regexEscape(shortPieces[i]);
          longPieces[i] = regexEscape(longPieces[i]);
        }
        for (i = 0; i < 24; i++) {
          mixedPieces[i] = regexEscape(mixedPieces[i]);
        }
        this._monthsRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
        this._monthsShortRegex = this._monthsRegex;
        this._monthsStrictRegex = new RegExp(
          "^(" + longPieces.join("|") + ")",
          "i"
        );
        this._monthsShortStrictRegex = new RegExp(
          "^(" + shortPieces.join("|") + ")",
          "i"
        );
      }
      addFormatToken("Y", 0, 0, function() {
        var y = this.year();
        return y <= 9999 ? zeroFill(y, 4) : "+" + y;
      });
      addFormatToken(0, ["YY", 2], 0, function() {
        return this.year() % 100;
      });
      addFormatToken(0, ["YYYY", 4], 0, "year");
      addFormatToken(0, ["YYYYY", 5], 0, "year");
      addFormatToken(0, ["YYYYYY", 6, true], 0, "year");
      addUnitAlias("year", "y");
      addUnitPriority("year", 1);
      addRegexToken("Y", matchSigned);
      addRegexToken("YY", match1to2, match2);
      addRegexToken("YYYY", match1to4, match4);
      addRegexToken("YYYYY", match1to6, match6);
      addRegexToken("YYYYYY", match1to6, match6);
      addParseToken(["YYYYY", "YYYYYY"], YEAR);
      addParseToken("YYYY", function(input, array) {
        array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
      });
      addParseToken("YY", function(input, array) {
        array[YEAR] = hooks.parseTwoDigitYear(input);
      });
      addParseToken("Y", function(input, array) {
        array[YEAR] = parseInt(input, 10);
      });
      function daysInYear(year) {
        return isLeapYear(year) ? 366 : 365;
      }
      hooks.parseTwoDigitYear = function(input) {
        return toInt(input) + (toInt(input) > 68 ? 1900 : 2e3);
      };
      var getSetYear = makeGetSet("FullYear", true);
      function getIsLeapYear() {
        return isLeapYear(this.year());
      }
      function createDate(y, m, d, h, M, s, ms) {
        var date;
        if (y < 100 && y >= 0) {
          date = new Date(y + 400, m, d, h, M, s, ms);
          if (isFinite(date.getFullYear())) {
            date.setFullYear(y);
          }
        } else {
          date = new Date(y, m, d, h, M, s, ms);
        }
        return date;
      }
      function createUTCDate(y) {
        var date, args;
        if (y < 100 && y >= 0) {
          args = Array.prototype.slice.call(arguments);
          args[0] = y + 400;
          date = new Date(Date.UTC.apply(null, args));
          if (isFinite(date.getUTCFullYear())) {
            date.setUTCFullYear(y);
          }
        } else {
          date = new Date(Date.UTC.apply(null, arguments));
        }
        return date;
      }
      function firstWeekOffset(year, dow, doy) {
        var fwd = 7 + dow - doy, fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;
        return -fwdlw + fwd - 1;
      }
      function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
        var localWeekday = (7 + weekday - dow) % 7, weekOffset = firstWeekOffset(year, dow, doy), dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset, resYear, resDayOfYear;
        if (dayOfYear <= 0) {
          resYear = year - 1;
          resDayOfYear = daysInYear(resYear) + dayOfYear;
        } else if (dayOfYear > daysInYear(year)) {
          resYear = year + 1;
          resDayOfYear = dayOfYear - daysInYear(year);
        } else {
          resYear = year;
          resDayOfYear = dayOfYear;
        }
        return {
          year: resYear,
          dayOfYear: resDayOfYear
        };
      }
      function weekOfYear(mom, dow, doy) {
        var weekOffset = firstWeekOffset(mom.year(), dow, doy), week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1, resWeek, resYear;
        if (week < 1) {
          resYear = mom.year() - 1;
          resWeek = week + weeksInYear(resYear, dow, doy);
        } else if (week > weeksInYear(mom.year(), dow, doy)) {
          resWeek = week - weeksInYear(mom.year(), dow, doy);
          resYear = mom.year() + 1;
        } else {
          resYear = mom.year();
          resWeek = week;
        }
        return {
          week: resWeek,
          year: resYear
        };
      }
      function weeksInYear(year, dow, doy) {
        var weekOffset = firstWeekOffset(year, dow, doy), weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
        return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
      }
      addFormatToken("w", ["ww", 2], "wo", "week");
      addFormatToken("W", ["WW", 2], "Wo", "isoWeek");
      addUnitAlias("week", "w");
      addUnitAlias("isoWeek", "W");
      addUnitPriority("week", 5);
      addUnitPriority("isoWeek", 5);
      addRegexToken("w", match1to2);
      addRegexToken("ww", match1to2, match2);
      addRegexToken("W", match1to2);
      addRegexToken("WW", match1to2, match2);
      addWeekParseToken(["w", "ww", "W", "WW"], function(input, week, config, token2) {
        week[token2.substr(0, 1)] = toInt(input);
      });
      function localeWeek(mom) {
        return weekOfYear(mom, this._week.dow, this._week.doy).week;
      }
      var defaultLocaleWeek = {
        dow: 0,
        // Sunday is the first day of the week.
        doy: 6
        // The week that contains Jan 6th is the first week of the year.
      };
      function localeFirstDayOfWeek() {
        return this._week.dow;
      }
      function localeFirstDayOfYear() {
        return this._week.doy;
      }
      function getSetWeek(input) {
        var week = this.localeData().week(this);
        return input == null ? week : this.add((input - week) * 7, "d");
      }
      function getSetISOWeek(input) {
        var week = weekOfYear(this, 1, 4).week;
        return input == null ? week : this.add((input - week) * 7, "d");
      }
      addFormatToken("d", 0, "do", "day");
      addFormatToken("dd", 0, 0, function(format2) {
        return this.localeData().weekdaysMin(this, format2);
      });
      addFormatToken("ddd", 0, 0, function(format2) {
        return this.localeData().weekdaysShort(this, format2);
      });
      addFormatToken("dddd", 0, 0, function(format2) {
        return this.localeData().weekdays(this, format2);
      });
      addFormatToken("e", 0, 0, "weekday");
      addFormatToken("E", 0, 0, "isoWeekday");
      addUnitAlias("day", "d");
      addUnitAlias("weekday", "e");
      addUnitAlias("isoWeekday", "E");
      addUnitPriority("day", 11);
      addUnitPriority("weekday", 11);
      addUnitPriority("isoWeekday", 11);
      addRegexToken("d", match1to2);
      addRegexToken("e", match1to2);
      addRegexToken("E", match1to2);
      addRegexToken("dd", function(isStrict, locale2) {
        return locale2.weekdaysMinRegex(isStrict);
      });
      addRegexToken("ddd", function(isStrict, locale2) {
        return locale2.weekdaysShortRegex(isStrict);
      });
      addRegexToken("dddd", function(isStrict, locale2) {
        return locale2.weekdaysRegex(isStrict);
      });
      addWeekParseToken(["dd", "ddd", "dddd"], function(input, week, config, token2) {
        var weekday = config._locale.weekdaysParse(input, token2, config._strict);
        if (weekday != null) {
          week.d = weekday;
        } else {
          getParsingFlags(config).invalidWeekday = input;
        }
      });
      addWeekParseToken(["d", "e", "E"], function(input, week, config, token2) {
        week[token2] = toInt(input);
      });
      function parseWeekday(input, locale2) {
        if (typeof input !== "string") {
          return input;
        }
        if (!isNaN(input)) {
          return parseInt(input, 10);
        }
        input = locale2.weekdaysParse(input);
        if (typeof input === "number") {
          return input;
        }
        return null;
      }
      function parseIsoWeekday(input, locale2) {
        if (typeof input === "string") {
          return locale2.weekdaysParse(input) % 7 || 7;
        }
        return isNaN(input) ? null : input;
      }
      function shiftWeekdays(ws, n) {
        return ws.slice(n, 7).concat(ws.slice(0, n));
      }
      var defaultLocaleWeekdays = "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split(
        "_"
      ), defaultLocaleWeekdaysShort = "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"), defaultLocaleWeekdaysMin = "Su_Mo_Tu_We_Th_Fr_Sa".split("_"), defaultWeekdaysRegex = matchWord, defaultWeekdaysShortRegex = matchWord, defaultWeekdaysMinRegex = matchWord;
      function localeWeekdays(m, format2) {
        var weekdays = isArray(this._weekdays) ? this._weekdays : this._weekdays[m && m !== true && this._weekdays.isFormat.test(format2) ? "format" : "standalone"];
        return m === true ? shiftWeekdays(weekdays, this._week.dow) : m ? weekdays[m.day()] : weekdays;
      }
      function localeWeekdaysShort(m) {
        return m === true ? shiftWeekdays(this._weekdaysShort, this._week.dow) : m ? this._weekdaysShort[m.day()] : this._weekdaysShort;
      }
      function localeWeekdaysMin(m) {
        return m === true ? shiftWeekdays(this._weekdaysMin, this._week.dow) : m ? this._weekdaysMin[m.day()] : this._weekdaysMin;
      }
      function handleStrictParse$1(weekdayName, format2, strict) {
        var i, ii, mom, llc = weekdayName.toLocaleLowerCase();
        if (!this._weekdaysParse) {
          this._weekdaysParse = [];
          this._shortWeekdaysParse = [];
          this._minWeekdaysParse = [];
          for (i = 0; i < 7; ++i) {
            mom = createUTC([2e3, 1]).day(i);
            this._minWeekdaysParse[i] = this.weekdaysMin(
              mom,
              ""
            ).toLocaleLowerCase();
            this._shortWeekdaysParse[i] = this.weekdaysShort(
              mom,
              ""
            ).toLocaleLowerCase();
            this._weekdaysParse[i] = this.weekdays(mom, "").toLocaleLowerCase();
          }
        }
        if (strict) {
          if (format2 === "dddd") {
            ii = indexOf.call(this._weekdaysParse, llc);
            return ii !== -1 ? ii : null;
          } else if (format2 === "ddd") {
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          } else {
            ii = indexOf.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          }
        } else {
          if (format2 === "dddd") {
            ii = indexOf.call(this._weekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          } else if (format2 === "ddd") {
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._weekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          } else {
            ii = indexOf.call(this._minWeekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._weekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          }
        }
      }
      function localeWeekdaysParse(weekdayName, format2, strict) {
        var i, mom, regex;
        if (this._weekdaysParseExact) {
          return handleStrictParse$1.call(this, weekdayName, format2, strict);
        }
        if (!this._weekdaysParse) {
          this._weekdaysParse = [];
          this._minWeekdaysParse = [];
          this._shortWeekdaysParse = [];
          this._fullWeekdaysParse = [];
        }
        for (i = 0; i < 7; i++) {
          mom = createUTC([2e3, 1]).day(i);
          if (strict && !this._fullWeekdaysParse[i]) {
            this._fullWeekdaysParse[i] = new RegExp(
              "^" + this.weekdays(mom, "").replace(".", "\\.?") + "$",
              "i"
            );
            this._shortWeekdaysParse[i] = new RegExp(
              "^" + this.weekdaysShort(mom, "").replace(".", "\\.?") + "$",
              "i"
            );
            this._minWeekdaysParse[i] = new RegExp(
              "^" + this.weekdaysMin(mom, "").replace(".", "\\.?") + "$",
              "i"
            );
          }
          if (!this._weekdaysParse[i]) {
            regex = "^" + this.weekdays(mom, "") + "|^" + this.weekdaysShort(mom, "") + "|^" + this.weekdaysMin(mom, "");
            this._weekdaysParse[i] = new RegExp(regex.replace(".", ""), "i");
          }
          if (strict && format2 === "dddd" && this._fullWeekdaysParse[i].test(weekdayName)) {
            return i;
          } else if (strict && format2 === "ddd" && this._shortWeekdaysParse[i].test(weekdayName)) {
            return i;
          } else if (strict && format2 === "dd" && this._minWeekdaysParse[i].test(weekdayName)) {
            return i;
          } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
            return i;
          }
        }
      }
      function getSetDayOfWeek(input) {
        if (!this.isValid()) {
          return input != null ? this : NaN;
        }
        var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
        if (input != null) {
          input = parseWeekday(input, this.localeData());
          return this.add(input - day, "d");
        } else {
          return day;
        }
      }
      function getSetLocaleDayOfWeek(input) {
        if (!this.isValid()) {
          return input != null ? this : NaN;
        }
        var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
        return input == null ? weekday : this.add(input - weekday, "d");
      }
      function getSetISODayOfWeek(input) {
        if (!this.isValid()) {
          return input != null ? this : NaN;
        }
        if (input != null) {
          var weekday = parseIsoWeekday(input, this.localeData());
          return this.day(this.day() % 7 ? weekday : weekday - 7);
        } else {
          return this.day() || 7;
        }
      }
      function weekdaysRegex(isStrict) {
        if (this._weekdaysParseExact) {
          if (!hasOwnProp(this, "_weekdaysRegex")) {
            computeWeekdaysParse.call(this);
          }
          if (isStrict) {
            return this._weekdaysStrictRegex;
          } else {
            return this._weekdaysRegex;
          }
        } else {
          if (!hasOwnProp(this, "_weekdaysRegex")) {
            this._weekdaysRegex = defaultWeekdaysRegex;
          }
          return this._weekdaysStrictRegex && isStrict ? this._weekdaysStrictRegex : this._weekdaysRegex;
        }
      }
      function weekdaysShortRegex(isStrict) {
        if (this._weekdaysParseExact) {
          if (!hasOwnProp(this, "_weekdaysRegex")) {
            computeWeekdaysParse.call(this);
          }
          if (isStrict) {
            return this._weekdaysShortStrictRegex;
          } else {
            return this._weekdaysShortRegex;
          }
        } else {
          if (!hasOwnProp(this, "_weekdaysShortRegex")) {
            this._weekdaysShortRegex = defaultWeekdaysShortRegex;
          }
          return this._weekdaysShortStrictRegex && isStrict ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
        }
      }
      function weekdaysMinRegex(isStrict) {
        if (this._weekdaysParseExact) {
          if (!hasOwnProp(this, "_weekdaysRegex")) {
            computeWeekdaysParse.call(this);
          }
          if (isStrict) {
            return this._weekdaysMinStrictRegex;
          } else {
            return this._weekdaysMinRegex;
          }
        } else {
          if (!hasOwnProp(this, "_weekdaysMinRegex")) {
            this._weekdaysMinRegex = defaultWeekdaysMinRegex;
          }
          return this._weekdaysMinStrictRegex && isStrict ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
        }
      }
      function computeWeekdaysParse() {
        function cmpLenRev(a, b) {
          return b.length - a.length;
        }
        var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [], i, mom, minp, shortp, longp;
        for (i = 0; i < 7; i++) {
          mom = createUTC([2e3, 1]).day(i);
          minp = regexEscape(this.weekdaysMin(mom, ""));
          shortp = regexEscape(this.weekdaysShort(mom, ""));
          longp = regexEscape(this.weekdays(mom, ""));
          minPieces.push(minp);
          shortPieces.push(shortp);
          longPieces.push(longp);
          mixedPieces.push(minp);
          mixedPieces.push(shortp);
          mixedPieces.push(longp);
        }
        minPieces.sort(cmpLenRev);
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);
        this._weekdaysRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
        this._weekdaysShortRegex = this._weekdaysRegex;
        this._weekdaysMinRegex = this._weekdaysRegex;
        this._weekdaysStrictRegex = new RegExp(
          "^(" + longPieces.join("|") + ")",
          "i"
        );
        this._weekdaysShortStrictRegex = new RegExp(
          "^(" + shortPieces.join("|") + ")",
          "i"
        );
        this._weekdaysMinStrictRegex = new RegExp(
          "^(" + minPieces.join("|") + ")",
          "i"
        );
      }
      function hFormat() {
        return this.hours() % 12 || 12;
      }
      function kFormat() {
        return this.hours() || 24;
      }
      addFormatToken("H", ["HH", 2], 0, "hour");
      addFormatToken("h", ["hh", 2], 0, hFormat);
      addFormatToken("k", ["kk", 2], 0, kFormat);
      addFormatToken("hmm", 0, 0, function() {
        return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2);
      });
      addFormatToken("hmmss", 0, 0, function() {
        return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
      });
      addFormatToken("Hmm", 0, 0, function() {
        return "" + this.hours() + zeroFill(this.minutes(), 2);
      });
      addFormatToken("Hmmss", 0, 0, function() {
        return "" + this.hours() + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
      });
      function meridiem(token2, lowercase) {
        addFormatToken(token2, 0, 0, function() {
          return this.localeData().meridiem(
            this.hours(),
            this.minutes(),
            lowercase
          );
        });
      }
      meridiem("a", true);
      meridiem("A", false);
      addUnitAlias("hour", "h");
      addUnitPriority("hour", 13);
      function matchMeridiem(isStrict, locale2) {
        return locale2._meridiemParse;
      }
      addRegexToken("a", matchMeridiem);
      addRegexToken("A", matchMeridiem);
      addRegexToken("H", match1to2);
      addRegexToken("h", match1to2);
      addRegexToken("k", match1to2);
      addRegexToken("HH", match1to2, match2);
      addRegexToken("hh", match1to2, match2);
      addRegexToken("kk", match1to2, match2);
      addRegexToken("hmm", match3to4);
      addRegexToken("hmmss", match5to6);
      addRegexToken("Hmm", match3to4);
      addRegexToken("Hmmss", match5to6);
      addParseToken(["H", "HH"], HOUR);
      addParseToken(["k", "kk"], function(input, array, config) {
        var kInput = toInt(input);
        array[HOUR] = kInput === 24 ? 0 : kInput;
      });
      addParseToken(["a", "A"], function(input, array, config) {
        config._isPm = config._locale.isPM(input);
        config._meridiem = input;
      });
      addParseToken(["h", "hh"], function(input, array, config) {
        array[HOUR] = toInt(input);
        getParsingFlags(config).bigHour = true;
      });
      addParseToken("hmm", function(input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
        getParsingFlags(config).bigHour = true;
      });
      addParseToken("hmmss", function(input, array, config) {
        var pos1 = input.length - 4, pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
        getParsingFlags(config).bigHour = true;
      });
      addParseToken("Hmm", function(input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
      });
      addParseToken("Hmmss", function(input, array, config) {
        var pos1 = input.length - 4, pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
      });
      function localeIsPM(input) {
        return (input + "").toLowerCase().charAt(0) === "p";
      }
      var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i, getSetHour = makeGetSet("Hours", true);
      function localeMeridiem(hours2, minutes2, isLower) {
        if (hours2 > 11) {
          return isLower ? "pm" : "PM";
        } else {
          return isLower ? "am" : "AM";
        }
      }
      var baseConfig = {
        calendar: defaultCalendar,
        longDateFormat: defaultLongDateFormat,
        invalidDate: defaultInvalidDate,
        ordinal: defaultOrdinal,
        dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
        relativeTime: defaultRelativeTime,
        months: defaultLocaleMonths,
        monthsShort: defaultLocaleMonthsShort,
        week: defaultLocaleWeek,
        weekdays: defaultLocaleWeekdays,
        weekdaysMin: defaultLocaleWeekdaysMin,
        weekdaysShort: defaultLocaleWeekdaysShort,
        meridiemParse: defaultLocaleMeridiemParse
      };
      var locales = {}, localeFamilies = {}, globalLocale;
      function commonPrefix(arr1, arr2) {
        var i, minl = Math.min(arr1.length, arr2.length);
        for (i = 0; i < minl; i += 1) {
          if (arr1[i] !== arr2[i]) {
            return i;
          }
        }
        return minl;
      }
      function normalizeLocale(key) {
        return key ? key.toLowerCase().replace("_", "-") : key;
      }
      function chooseLocale(names) {
        var i = 0, j, next, locale2, split;
        while (i < names.length) {
          split = normalizeLocale(names[i]).split("-");
          j = split.length;
          next = normalizeLocale(names[i + 1]);
          next = next ? next.split("-") : null;
          while (j > 0) {
            locale2 = loadLocale(split.slice(0, j).join("-"));
            if (locale2) {
              return locale2;
            }
            if (next && next.length >= j && commonPrefix(split, next) >= j - 1) {
              break;
            }
            j--;
          }
          i++;
        }
        return globalLocale;
      }
      function loadLocale(name) {
        var oldLocale = null, aliasedRequire;
        if (locales[name] === void 0 && typeof module2 !== "undefined" && module2 && module2.exports) {
          try {
            oldLocale = globalLocale._abbr;
            aliasedRequire = require;
            aliasedRequire("./locale/" + name);
            getSetGlobalLocale(oldLocale);
          } catch (e) {
            locales[name] = null;
          }
        }
        return locales[name];
      }
      function getSetGlobalLocale(key, values) {
        var data;
        if (key) {
          if (isUndefined(values)) {
            data = getLocale(key);
          } else {
            data = defineLocale(key, values);
          }
          if (data) {
            globalLocale = data;
          } else {
            if (typeof console !== "undefined" && console.warn) {
              console.warn(
                "Locale " + key + " not found. Did you forget to load it?"
              );
            }
          }
        }
        return globalLocale._abbr;
      }
      function defineLocale(name, config) {
        if (config !== null) {
          var locale2, parentConfig = baseConfig;
          config.abbr = name;
          if (locales[name] != null) {
            deprecateSimple(
              "defineLocaleOverride",
              "use moment.updateLocale(localeName, config) to change an existing locale. moment.defineLocale(localeName, config) should only be used for creating a new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more info."
            );
            parentConfig = locales[name]._config;
          } else if (config.parentLocale != null) {
            if (locales[config.parentLocale] != null) {
              parentConfig = locales[config.parentLocale]._config;
            } else {
              locale2 = loadLocale(config.parentLocale);
              if (locale2 != null) {
                parentConfig = locale2._config;
              } else {
                if (!localeFamilies[config.parentLocale]) {
                  localeFamilies[config.parentLocale] = [];
                }
                localeFamilies[config.parentLocale].push({
                  name,
                  config
                });
                return null;
              }
            }
          }
          locales[name] = new Locale(mergeConfigs(parentConfig, config));
          if (localeFamilies[name]) {
            localeFamilies[name].forEach(function(x) {
              defineLocale(x.name, x.config);
            });
          }
          getSetGlobalLocale(name);
          return locales[name];
        } else {
          delete locales[name];
          return null;
        }
      }
      function updateLocale(name, config) {
        if (config != null) {
          var locale2, tmpLocale, parentConfig = baseConfig;
          if (locales[name] != null && locales[name].parentLocale != null) {
            locales[name].set(mergeConfigs(locales[name]._config, config));
          } else {
            tmpLocale = loadLocale(name);
            if (tmpLocale != null) {
              parentConfig = tmpLocale._config;
            }
            config = mergeConfigs(parentConfig, config);
            if (tmpLocale == null) {
              config.abbr = name;
            }
            locale2 = new Locale(config);
            locale2.parentLocale = locales[name];
            locales[name] = locale2;
          }
          getSetGlobalLocale(name);
        } else {
          if (locales[name] != null) {
            if (locales[name].parentLocale != null) {
              locales[name] = locales[name].parentLocale;
              if (name === getSetGlobalLocale()) {
                getSetGlobalLocale(name);
              }
            } else if (locales[name] != null) {
              delete locales[name];
            }
          }
        }
        return locales[name];
      }
      function getLocale(key) {
        var locale2;
        if (key && key._locale && key._locale._abbr) {
          key = key._locale._abbr;
        }
        if (!key) {
          return globalLocale;
        }
        if (!isArray(key)) {
          locale2 = loadLocale(key);
          if (locale2) {
            return locale2;
          }
          key = [key];
        }
        return chooseLocale(key);
      }
      function listLocales() {
        return keys(locales);
      }
      function checkOverflow(m) {
        var overflow, a = m._a;
        if (a && getParsingFlags(m).overflow === -2) {
          overflow = a[MONTH] < 0 || a[MONTH] > 11 ? MONTH : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH]) ? DATE : a[HOUR] < 0 || a[HOUR] > 24 || a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0) ? HOUR : a[MINUTE] < 0 || a[MINUTE] > 59 ? MINUTE : a[SECOND] < 0 || a[SECOND] > 59 ? SECOND : a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND : -1;
          if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
            overflow = DATE;
          }
          if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
            overflow = WEEK;
          }
          if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
            overflow = WEEKDAY;
          }
          getParsingFlags(m).overflow = overflow;
        }
        return m;
      }
      var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, tzRegex = /Z|[+-]\d\d(?::?\d\d)?/, isoDates = [
        ["YYYYYY-MM-DD", /[+-]\d{6}-\d\d-\d\d/],
        ["YYYY-MM-DD", /\d{4}-\d\d-\d\d/],
        ["GGGG-[W]WW-E", /\d{4}-W\d\d-\d/],
        ["GGGG-[W]WW", /\d{4}-W\d\d/, false],
        ["YYYY-DDD", /\d{4}-\d{3}/],
        ["YYYY-MM", /\d{4}-\d\d/, false],
        ["YYYYYYMMDD", /[+-]\d{10}/],
        ["YYYYMMDD", /\d{8}/],
        ["GGGG[W]WWE", /\d{4}W\d{3}/],
        ["GGGG[W]WW", /\d{4}W\d{2}/, false],
        ["YYYYDDD", /\d{7}/],
        ["YYYYMM", /\d{6}/, false],
        ["YYYY", /\d{4}/, false]
      ], isoTimes = [
        ["HH:mm:ss.SSSS", /\d\d:\d\d:\d\d\.\d+/],
        ["HH:mm:ss,SSSS", /\d\d:\d\d:\d\d,\d+/],
        ["HH:mm:ss", /\d\d:\d\d:\d\d/],
        ["HH:mm", /\d\d:\d\d/],
        ["HHmmss.SSSS", /\d\d\d\d\d\d\.\d+/],
        ["HHmmss,SSSS", /\d\d\d\d\d\d,\d+/],
        ["HHmmss", /\d\d\d\d\d\d/],
        ["HHmm", /\d\d\d\d/],
        ["HH", /\d\d/]
      ], aspNetJsonRegex = /^\/?Date\((-?\d+)/i, rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/, obsOffsets = {
        UT: 0,
        GMT: 0,
        EDT: -4 * 60,
        EST: -5 * 60,
        CDT: -5 * 60,
        CST: -6 * 60,
        MDT: -6 * 60,
        MST: -7 * 60,
        PDT: -7 * 60,
        PST: -8 * 60
      };
      function configFromISO(config) {
        var i, l, string2 = config._i, match = extendedIsoRegex.exec(string2) || basicIsoRegex.exec(string2), allowTime, dateFormat, timeFormat, tzFormat;
        if (match) {
          getParsingFlags(config).iso = true;
          for (i = 0, l = isoDates.length; i < l; i++) {
            if (isoDates[i][1].exec(match[1])) {
              dateFormat = isoDates[i][0];
              allowTime = isoDates[i][2] !== false;
              break;
            }
          }
          if (dateFormat == null) {
            config._isValid = false;
            return;
          }
          if (match[3]) {
            for (i = 0, l = isoTimes.length; i < l; i++) {
              if (isoTimes[i][1].exec(match[3])) {
                timeFormat = (match[2] || " ") + isoTimes[i][0];
                break;
              }
            }
            if (timeFormat == null) {
              config._isValid = false;
              return;
            }
          }
          if (!allowTime && timeFormat != null) {
            config._isValid = false;
            return;
          }
          if (match[4]) {
            if (tzRegex.exec(match[4])) {
              tzFormat = "Z";
            } else {
              config._isValid = false;
              return;
            }
          }
          config._f = dateFormat + (timeFormat || "") + (tzFormat || "");
          configFromStringAndFormat(config);
        } else {
          config._isValid = false;
        }
      }
      function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
        var result = [
          untruncateYear(yearStr),
          defaultLocaleMonthsShort.indexOf(monthStr),
          parseInt(dayStr, 10),
          parseInt(hourStr, 10),
          parseInt(minuteStr, 10)
        ];
        if (secondStr) {
          result.push(parseInt(secondStr, 10));
        }
        return result;
      }
      function untruncateYear(yearStr) {
        var year = parseInt(yearStr, 10);
        if (year <= 49) {
          return 2e3 + year;
        } else if (year <= 999) {
          return 1900 + year;
        }
        return year;
      }
      function preprocessRFC2822(s) {
        return s.replace(/\([^)]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").replace(/^\s\s*/, "").replace(/\s\s*$/, "");
      }
      function checkWeekday(weekdayStr, parsedInput, config) {
        if (weekdayStr) {
          var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr), weekdayActual = new Date(
            parsedInput[0],
            parsedInput[1],
            parsedInput[2]
          ).getDay();
          if (weekdayProvided !== weekdayActual) {
            getParsingFlags(config).weekdayMismatch = true;
            config._isValid = false;
            return false;
          }
        }
        return true;
      }
      function calculateOffset(obsOffset, militaryOffset, numOffset) {
        if (obsOffset) {
          return obsOffsets[obsOffset];
        } else if (militaryOffset) {
          return 0;
        } else {
          var hm = parseInt(numOffset, 10), m = hm % 100, h = (hm - m) / 100;
          return h * 60 + m;
        }
      }
      function configFromRFC2822(config) {
        var match = rfc2822.exec(preprocessRFC2822(config._i)), parsedArray;
        if (match) {
          parsedArray = extractFromRFC2822Strings(
            match[4],
            match[3],
            match[2],
            match[5],
            match[6],
            match[7]
          );
          if (!checkWeekday(match[1], parsedArray, config)) {
            return;
          }
          config._a = parsedArray;
          config._tzm = calculateOffset(match[8], match[9], match[10]);
          config._d = createUTCDate.apply(null, config._a);
          config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
          getParsingFlags(config).rfc2822 = true;
        } else {
          config._isValid = false;
        }
      }
      function configFromString(config) {
        var matched = aspNetJsonRegex.exec(config._i);
        if (matched !== null) {
          config._d = new Date(+matched[1]);
          return;
        }
        configFromISO(config);
        if (config._isValid === false) {
          delete config._isValid;
        } else {
          return;
        }
        configFromRFC2822(config);
        if (config._isValid === false) {
          delete config._isValid;
        } else {
          return;
        }
        if (config._strict) {
          config._isValid = false;
        } else {
          hooks.createFromInputFallback(config);
        }
      }
      hooks.createFromInputFallback = deprecate(
        "value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.",
        function(config) {
          config._d = new Date(config._i + (config._useUTC ? " UTC" : ""));
        }
      );
      function defaults(a, b, c) {
        if (a != null) {
          return a;
        }
        if (b != null) {
          return b;
        }
        return c;
      }
      function currentDateArray(config) {
        var nowValue = new Date(hooks.now());
        if (config._useUTC) {
          return [
            nowValue.getUTCFullYear(),
            nowValue.getUTCMonth(),
            nowValue.getUTCDate()
          ];
        }
        return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
      }
      function configFromArray(config) {
        var i, date, input = [], currentDate, expectedWeekday, yearToUse;
        if (config._d) {
          return;
        }
        currentDate = currentDateArray(config);
        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
          dayOfYearFromWeekInfo(config);
        }
        if (config._dayOfYear != null) {
          yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);
          if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {
            getParsingFlags(config)._overflowDayOfYear = true;
          }
          date = createUTCDate(yearToUse, 0, config._dayOfYear);
          config._a[MONTH] = date.getUTCMonth();
          config._a[DATE] = date.getUTCDate();
        }
        for (i = 0; i < 3 && config._a[i] == null; ++i) {
          config._a[i] = input[i] = currentDate[i];
        }
        for (; i < 7; i++) {
          config._a[i] = input[i] = config._a[i] == null ? i === 2 ? 1 : 0 : config._a[i];
        }
        if (config._a[HOUR] === 24 && config._a[MINUTE] === 0 && config._a[SECOND] === 0 && config._a[MILLISECOND] === 0) {
          config._nextDay = true;
          config._a[HOUR] = 0;
        }
        config._d = (config._useUTC ? createUTCDate : createDate).apply(
          null,
          input
        );
        expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay();
        if (config._tzm != null) {
          config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
        }
        if (config._nextDay) {
          config._a[HOUR] = 24;
        }
        if (config._w && typeof config._w.d !== "undefined" && config._w.d !== expectedWeekday) {
          getParsingFlags(config).weekdayMismatch = true;
        }
      }
      function dayOfYearFromWeekInfo(config) {
        var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow, curWeek;
        w = config._w;
        if (w.GG != null || w.W != null || w.E != null) {
          dow = 1;
          doy = 4;
          weekYear = defaults(
            w.GG,
            config._a[YEAR],
            weekOfYear(createLocal(), 1, 4).year
          );
          week = defaults(w.W, 1);
          weekday = defaults(w.E, 1);
          if (weekday < 1 || weekday > 7) {
            weekdayOverflow = true;
          }
        } else {
          dow = config._locale._week.dow;
          doy = config._locale._week.doy;
          curWeek = weekOfYear(createLocal(), dow, doy);
          weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);
          week = defaults(w.w, curWeek.week);
          if (w.d != null) {
            weekday = w.d;
            if (weekday < 0 || weekday > 6) {
              weekdayOverflow = true;
            }
          } else if (w.e != null) {
            weekday = w.e + dow;
            if (w.e < 0 || w.e > 6) {
              weekdayOverflow = true;
            }
          } else {
            weekday = dow;
          }
        }
        if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
          getParsingFlags(config)._overflowWeeks = true;
        } else if (weekdayOverflow != null) {
          getParsingFlags(config)._overflowWeekday = true;
        } else {
          temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
          config._a[YEAR] = temp.year;
          config._dayOfYear = temp.dayOfYear;
        }
      }
      hooks.ISO_8601 = function() {
      };
      hooks.RFC_2822 = function() {
      };
      function configFromStringAndFormat(config) {
        if (config._f === hooks.ISO_8601) {
          configFromISO(config);
          return;
        }
        if (config._f === hooks.RFC_2822) {
          configFromRFC2822(config);
          return;
        }
        config._a = [];
        getParsingFlags(config).empty = true;
        var string2 = "" + config._i, i, parsedInput, tokens2, token2, skipped, stringLength = string2.length, totalParsedInputLength = 0, era;
        tokens2 = expandFormat(config._f, config._locale).match(formattingTokens) || [];
        for (i = 0; i < tokens2.length; i++) {
          token2 = tokens2[i];
          parsedInput = (string2.match(getParseRegexForToken(token2, config)) || [])[0];
          if (parsedInput) {
            skipped = string2.substr(0, string2.indexOf(parsedInput));
            if (skipped.length > 0) {
              getParsingFlags(config).unusedInput.push(skipped);
            }
            string2 = string2.slice(
              string2.indexOf(parsedInput) + parsedInput.length
            );
            totalParsedInputLength += parsedInput.length;
          }
          if (formatTokenFunctions[token2]) {
            if (parsedInput) {
              getParsingFlags(config).empty = false;
            } else {
              getParsingFlags(config).unusedTokens.push(token2);
            }
            addTimeToArrayFromToken(token2, parsedInput, config);
          } else if (config._strict && !parsedInput) {
            getParsingFlags(config).unusedTokens.push(token2);
          }
        }
        getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
        if (string2.length > 0) {
          getParsingFlags(config).unusedInput.push(string2);
        }
        if (config._a[HOUR] <= 12 && getParsingFlags(config).bigHour === true && config._a[HOUR] > 0) {
          getParsingFlags(config).bigHour = void 0;
        }
        getParsingFlags(config).parsedDateParts = config._a.slice(0);
        getParsingFlags(config).meridiem = config._meridiem;
        config._a[HOUR] = meridiemFixWrap(
          config._locale,
          config._a[HOUR],
          config._meridiem
        );
        era = getParsingFlags(config).era;
        if (era !== null) {
          config._a[YEAR] = config._locale.erasConvertYear(era, config._a[YEAR]);
        }
        configFromArray(config);
        checkOverflow(config);
      }
      function meridiemFixWrap(locale2, hour, meridiem2) {
        var isPm;
        if (meridiem2 == null) {
          return hour;
        }
        if (locale2.meridiemHour != null) {
          return locale2.meridiemHour(hour, meridiem2);
        } else if (locale2.isPM != null) {
          isPm = locale2.isPM(meridiem2);
          if (isPm && hour < 12) {
            hour += 12;
          }
          if (!isPm && hour === 12) {
            hour = 0;
          }
          return hour;
        } else {
          return hour;
        }
      }
      function configFromStringAndArray(config) {
        var tempConfig, bestMoment, scoreToBeat, i, currentScore, validFormatFound, bestFormatIsValid = false;
        if (config._f.length === 0) {
          getParsingFlags(config).invalidFormat = true;
          config._d = new Date(NaN);
          return;
        }
        for (i = 0; i < config._f.length; i++) {
          currentScore = 0;
          validFormatFound = false;
          tempConfig = copyConfig({}, config);
          if (config._useUTC != null) {
            tempConfig._useUTC = config._useUTC;
          }
          tempConfig._f = config._f[i];
          configFromStringAndFormat(tempConfig);
          if (isValid(tempConfig)) {
            validFormatFound = true;
          }
          currentScore += getParsingFlags(tempConfig).charsLeftOver;
          currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;
          getParsingFlags(tempConfig).score = currentScore;
          if (!bestFormatIsValid) {
            if (scoreToBeat == null || currentScore < scoreToBeat || validFormatFound) {
              scoreToBeat = currentScore;
              bestMoment = tempConfig;
              if (validFormatFound) {
                bestFormatIsValid = true;
              }
            }
          } else {
            if (currentScore < scoreToBeat) {
              scoreToBeat = currentScore;
              bestMoment = tempConfig;
            }
          }
        }
        extend(config, bestMoment || tempConfig);
      }
      function configFromObject(config) {
        if (config._d) {
          return;
        }
        var i = normalizeObjectUnits(config._i), dayOrDate = i.day === void 0 ? i.date : i.day;
        config._a = map2(
          [i.year, i.month, dayOrDate, i.hour, i.minute, i.second, i.millisecond],
          function(obj) {
            return obj && parseInt(obj, 10);
          }
        );
        configFromArray(config);
      }
      function createFromConfig(config) {
        var res = new Moment(checkOverflow(prepareConfig(config)));
        if (res._nextDay) {
          res.add(1, "d");
          res._nextDay = void 0;
        }
        return res;
      }
      function prepareConfig(config) {
        var input = config._i, format2 = config._f;
        config._locale = config._locale || getLocale(config._l);
        if (input === null || format2 === void 0 && input === "") {
          return createInvalid({ nullInput: true });
        }
        if (typeof input === "string") {
          config._i = input = config._locale.preparse(input);
        }
        if (isMoment(input)) {
          return new Moment(checkOverflow(input));
        } else if (isDate(input)) {
          config._d = input;
        } else if (isArray(format2)) {
          configFromStringAndArray(config);
        } else if (format2) {
          configFromStringAndFormat(config);
        } else {
          configFromInput(config);
        }
        if (!isValid(config)) {
          config._d = null;
        }
        return config;
      }
      function configFromInput(config) {
        var input = config._i;
        if (isUndefined(input)) {
          config._d = new Date(hooks.now());
        } else if (isDate(input)) {
          config._d = new Date(input.valueOf());
        } else if (typeof input === "string") {
          configFromString(config);
        } else if (isArray(input)) {
          config._a = map2(input.slice(0), function(obj) {
            return parseInt(obj, 10);
          });
          configFromArray(config);
        } else if (isObject(input)) {
          configFromObject(config);
        } else if (isNumber(input)) {
          config._d = new Date(input);
        } else {
          hooks.createFromInputFallback(config);
        }
      }
      function createLocalOrUTC(input, format2, locale2, strict, isUTC) {
        var c = {};
        if (format2 === true || format2 === false) {
          strict = format2;
          format2 = void 0;
        }
        if (locale2 === true || locale2 === false) {
          strict = locale2;
          locale2 = void 0;
        }
        if (isObject(input) && isObjectEmpty(input) || isArray(input) && input.length === 0) {
          input = void 0;
        }
        c._isAMomentObject = true;
        c._useUTC = c._isUTC = isUTC;
        c._l = locale2;
        c._i = input;
        c._f = format2;
        c._strict = strict;
        return createFromConfig(c);
      }
      function createLocal(input, format2, locale2, strict) {
        return createLocalOrUTC(input, format2, locale2, strict, false);
      }
      var prototypeMin = deprecate(
        "moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/",
        function() {
          var other = createLocal.apply(null, arguments);
          if (this.isValid() && other.isValid()) {
            return other < this ? this : other;
          } else {
            return createInvalid();
          }
        }
      ), prototypeMax = deprecate(
        "moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/",
        function() {
          var other = createLocal.apply(null, arguments);
          if (this.isValid() && other.isValid()) {
            return other > this ? this : other;
          } else {
            return createInvalid();
          }
        }
      );
      function pickBy(fn, moments) {
        var res, i;
        if (moments.length === 1 && isArray(moments[0])) {
          moments = moments[0];
        }
        if (!moments.length) {
          return createLocal();
        }
        res = moments[0];
        for (i = 1; i < moments.length; ++i) {
          if (!moments[i].isValid() || moments[i][fn](res)) {
            res = moments[i];
          }
        }
        return res;
      }
      function min() {
        var args = [].slice.call(arguments, 0);
        return pickBy("isBefore", args);
      }
      function max() {
        var args = [].slice.call(arguments, 0);
        return pickBy("isAfter", args);
      }
      var now = function() {
        return Date.now ? Date.now() : +new Date();
      };
      var ordering = [
        "year",
        "quarter",
        "month",
        "week",
        "day",
        "hour",
        "minute",
        "second",
        "millisecond"
      ];
      function isDurationValid(m) {
        var key, unitHasDecimal = false, i;
        for (key in m) {
          if (hasOwnProp(m, key) && !(indexOf.call(ordering, key) !== -1 && (m[key] == null || !isNaN(m[key])))) {
            return false;
          }
        }
        for (i = 0; i < ordering.length; ++i) {
          if (m[ordering[i]]) {
            if (unitHasDecimal) {
              return false;
            }
            if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
              unitHasDecimal = true;
            }
          }
        }
        return true;
      }
      function isValid$1() {
        return this._isValid;
      }
      function createInvalid$1() {
        return createDuration(NaN);
      }
      function Duration(duration) {
        var normalizedInput = normalizeObjectUnits(duration), years2 = normalizedInput.year || 0, quarters = normalizedInput.quarter || 0, months2 = normalizedInput.month || 0, weeks2 = normalizedInput.week || normalizedInput.isoWeek || 0, days2 = normalizedInput.day || 0, hours2 = normalizedInput.hour || 0, minutes2 = normalizedInput.minute || 0, seconds2 = normalizedInput.second || 0, milliseconds2 = normalizedInput.millisecond || 0;
        this._isValid = isDurationValid(normalizedInput);
        this._milliseconds = +milliseconds2 + seconds2 * 1e3 + // 1000
        minutes2 * 6e4 + // 1000 * 60
        hours2 * 1e3 * 60 * 60;
        this._days = +days2 + weeks2 * 7;
        this._months = +months2 + quarters * 3 + years2 * 12;
        this._data = {};
        this._locale = getLocale();
        this._bubble();
      }
      function isDuration(obj) {
        return obj instanceof Duration;
      }
      function absRound(number) {
        if (number < 0) {
          return Math.round(-1 * number) * -1;
        } else {
          return Math.round(number);
        }
      }
      function compareArrays(array1, array2, dontConvert) {
        var len = Math.min(array1.length, array2.length), lengthDiff = Math.abs(array1.length - array2.length), diffs = 0, i;
        for (i = 0; i < len; i++) {
          if (dontConvert && array1[i] !== array2[i] || !dontConvert && toInt(array1[i]) !== toInt(array2[i])) {
            diffs++;
          }
        }
        return diffs + lengthDiff;
      }
      function offset(token2, separator) {
        addFormatToken(token2, 0, 0, function() {
          var offset2 = this.utcOffset(), sign2 = "+";
          if (offset2 < 0) {
            offset2 = -offset2;
            sign2 = "-";
          }
          return sign2 + zeroFill(~~(offset2 / 60), 2) + separator + zeroFill(~~offset2 % 60, 2);
        });
      }
      offset("Z", ":");
      offset("ZZ", "");
      addRegexToken("Z", matchShortOffset);
      addRegexToken("ZZ", matchShortOffset);
      addParseToken(["Z", "ZZ"], function(input, array, config) {
        config._useUTC = true;
        config._tzm = offsetFromString(matchShortOffset, input);
      });
      var chunkOffset = /([\+\-]|\d\d)/gi;
      function offsetFromString(matcher, string2) {
        var matches = (string2 || "").match(matcher), chunk, parts, minutes2;
        if (matches === null) {
          return null;
        }
        chunk = matches[matches.length - 1] || [];
        parts = (chunk + "").match(chunkOffset) || ["-", 0, 0];
        minutes2 = +(parts[1] * 60) + toInt(parts[2]);
        return minutes2 === 0 ? 0 : parts[0] === "+" ? minutes2 : -minutes2;
      }
      function cloneWithOffset(input, model) {
        var res, diff2;
        if (model._isUTC) {
          res = model.clone();
          diff2 = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
          res._d.setTime(res._d.valueOf() + diff2);
          hooks.updateOffset(res, false);
          return res;
        } else {
          return createLocal(input).local();
        }
      }
      function getDateOffset(m) {
        return -Math.round(m._d.getTimezoneOffset());
      }
      hooks.updateOffset = function() {
      };
      function getSetOffset(input, keepLocalTime, keepMinutes) {
        var offset2 = this._offset || 0, localAdjust;
        if (!this.isValid()) {
          return input != null ? this : NaN;
        }
        if (input != null) {
          if (typeof input === "string") {
            input = offsetFromString(matchShortOffset, input);
            if (input === null) {
              return this;
            }
          } else if (Math.abs(input) < 16 && !keepMinutes) {
            input = input * 60;
          }
          if (!this._isUTC && keepLocalTime) {
            localAdjust = getDateOffset(this);
          }
          this._offset = input;
          this._isUTC = true;
          if (localAdjust != null) {
            this.add(localAdjust, "m");
          }
          if (offset2 !== input) {
            if (!keepLocalTime || this._changeInProgress) {
              addSubtract(
                this,
                createDuration(input - offset2, "m"),
                1,
                false
              );
            } else if (!this._changeInProgress) {
              this._changeInProgress = true;
              hooks.updateOffset(this, true);
              this._changeInProgress = null;
            }
          }
          return this;
        } else {
          return this._isUTC ? offset2 : getDateOffset(this);
        }
      }
      function getSetZone(input, keepLocalTime) {
        if (input != null) {
          if (typeof input !== "string") {
            input = -input;
          }
          this.utcOffset(input, keepLocalTime);
          return this;
        } else {
          return -this.utcOffset();
        }
      }
      function setOffsetToUTC(keepLocalTime) {
        return this.utcOffset(0, keepLocalTime);
      }
      function setOffsetToLocal(keepLocalTime) {
        if (this._isUTC) {
          this.utcOffset(0, keepLocalTime);
          this._isUTC = false;
          if (keepLocalTime) {
            this.subtract(getDateOffset(this), "m");
          }
        }
        return this;
      }
      function setOffsetToParsedOffset() {
        if (this._tzm != null) {
          this.utcOffset(this._tzm, false, true);
        } else if (typeof this._i === "string") {
          var tZone = offsetFromString(matchOffset, this._i);
          if (tZone != null) {
            this.utcOffset(tZone);
          } else {
            this.utcOffset(0, true);
          }
        }
        return this;
      }
      function hasAlignedHourOffset(input) {
        if (!this.isValid()) {
          return false;
        }
        input = input ? createLocal(input).utcOffset() : 0;
        return (this.utcOffset() - input) % 60 === 0;
      }
      function isDaylightSavingTime() {
        return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();
      }
      function isDaylightSavingTimeShifted() {
        if (!isUndefined(this._isDSTShifted)) {
          return this._isDSTShifted;
        }
        var c = {}, other;
        copyConfig(c, this);
        c = prepareConfig(c);
        if (c._a) {
          other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
          this._isDSTShifted = this.isValid() && compareArrays(c._a, other.toArray()) > 0;
        } else {
          this._isDSTShifted = false;
        }
        return this._isDSTShifted;
      }
      function isLocal() {
        return this.isValid() ? !this._isUTC : false;
      }
      function isUtcOffset() {
        return this.isValid() ? this._isUTC : false;
      }
      function isUtc() {
        return this.isValid() ? this._isUTC && this._offset === 0 : false;
      }
      var aspNetRegex = /^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)?)?$/, isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
      function createDuration(input, key) {
        var duration = input, match = null, sign2, ret, diffRes;
        if (isDuration(input)) {
          duration = {
            ms: input._milliseconds,
            d: input._days,
            M: input._months
          };
        } else if (isNumber(input) || !isNaN(+input)) {
          duration = {};
          if (key) {
            duration[key] = +input;
          } else {
            duration.milliseconds = +input;
          }
        } else if (match = aspNetRegex.exec(input)) {
          sign2 = match[1] === "-" ? -1 : 1;
          duration = {
            y: 0,
            d: toInt(match[DATE]) * sign2,
            h: toInt(match[HOUR]) * sign2,
            m: toInt(match[MINUTE]) * sign2,
            s: toInt(match[SECOND]) * sign2,
            ms: toInt(absRound(match[MILLISECOND] * 1e3)) * sign2
            // the millisecond decimal point is included in the match
          };
        } else if (match = isoRegex.exec(input)) {
          sign2 = match[1] === "-" ? -1 : 1;
          duration = {
            y: parseIso(match[2], sign2),
            M: parseIso(match[3], sign2),
            w: parseIso(match[4], sign2),
            d: parseIso(match[5], sign2),
            h: parseIso(match[6], sign2),
            m: parseIso(match[7], sign2),
            s: parseIso(match[8], sign2)
          };
        } else if (duration == null) {
          duration = {};
        } else if (typeof duration === "object" && ("from" in duration || "to" in duration)) {
          diffRes = momentsDifference(
            createLocal(duration.from),
            createLocal(duration.to)
          );
          duration = {};
          duration.ms = diffRes.milliseconds;
          duration.M = diffRes.months;
        }
        ret = new Duration(duration);
        if (isDuration(input) && hasOwnProp(input, "_locale")) {
          ret._locale = input._locale;
        }
        if (isDuration(input) && hasOwnProp(input, "_isValid")) {
          ret._isValid = input._isValid;
        }
        return ret;
      }
      createDuration.fn = Duration.prototype;
      createDuration.invalid = createInvalid$1;
      function parseIso(inp, sign2) {
        var res = inp && parseFloat(inp.replace(",", "."));
        return (isNaN(res) ? 0 : res) * sign2;
      }
      function positiveMomentsDifference(base, other) {
        var res = {};
        res.months = other.month() - base.month() + (other.year() - base.year()) * 12;
        if (base.clone().add(res.months, "M").isAfter(other)) {
          --res.months;
        }
        res.milliseconds = +other - +base.clone().add(res.months, "M");
        return res;
      }
      function momentsDifference(base, other) {
        var res;
        if (!(base.isValid() && other.isValid())) {
          return { milliseconds: 0, months: 0 };
        }
        other = cloneWithOffset(other, base);
        if (base.isBefore(other)) {
          res = positiveMomentsDifference(base, other);
        } else {
          res = positiveMomentsDifference(other, base);
          res.milliseconds = -res.milliseconds;
          res.months = -res.months;
        }
        return res;
      }
      function createAdder(direction, name) {
        return function(val, period) {
          var dur, tmp;
          if (period !== null && !isNaN(+period)) {
            deprecateSimple(
              name,
              "moment()." + name + "(period, number) is deprecated. Please use moment()." + name + "(number, period). See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info."
            );
            tmp = val;
            val = period;
            period = tmp;
          }
          dur = createDuration(val, period);
          addSubtract(this, dur, direction);
          return this;
        };
      }
      function addSubtract(mom, duration, isAdding, updateOffset) {
        var milliseconds2 = duration._milliseconds, days2 = absRound(duration._days), months2 = absRound(duration._months);
        if (!mom.isValid()) {
          return;
        }
        updateOffset = updateOffset == null ? true : updateOffset;
        if (months2) {
          setMonth(mom, get(mom, "Month") + months2 * isAdding);
        }
        if (days2) {
          set$1(mom, "Date", get(mom, "Date") + days2 * isAdding);
        }
        if (milliseconds2) {
          mom._d.setTime(mom._d.valueOf() + milliseconds2 * isAdding);
        }
        if (updateOffset) {
          hooks.updateOffset(mom, days2 || months2);
        }
      }
      var add = createAdder(1, "add"), subtract = createAdder(-1, "subtract");
      function isString(input) {
        return typeof input === "string" || input instanceof String;
      }
      function isMomentInput(input) {
        return isMoment(input) || isDate(input) || isString(input) || isNumber(input) || isNumberOrStringArray(input) || isMomentInputObject(input) || input === null || input === void 0;
      }
      function isMomentInputObject(input) {
        var objectTest = isObject(input) && !isObjectEmpty(input), propertyTest = false, properties = [
          "years",
          "year",
          "y",
          "months",
          "month",
          "M",
          "days",
          "day",
          "d",
          "dates",
          "date",
          "D",
          "hours",
          "hour",
          "h",
          "minutes",
          "minute",
          "m",
          "seconds",
          "second",
          "s",
          "milliseconds",
          "millisecond",
          "ms"
        ], i, property;
        for (i = 0; i < properties.length; i += 1) {
          property = properties[i];
          propertyTest = propertyTest || hasOwnProp(input, property);
        }
        return objectTest && propertyTest;
      }
      function isNumberOrStringArray(input) {
        var arrayTest = isArray(input), dataTypeTest = false;
        if (arrayTest) {
          dataTypeTest = input.filter(function(item) {
            return !isNumber(item) && isString(input);
          }).length === 0;
        }
        return arrayTest && dataTypeTest;
      }
      function isCalendarSpec(input) {
        var objectTest = isObject(input) && !isObjectEmpty(input), propertyTest = false, properties = [
          "sameDay",
          "nextDay",
          "lastDay",
          "nextWeek",
          "lastWeek",
          "sameElse"
        ], i, property;
        for (i = 0; i < properties.length; i += 1) {
          property = properties[i];
          propertyTest = propertyTest || hasOwnProp(input, property);
        }
        return objectTest && propertyTest;
      }
      function getCalendarFormat(myMoment, now2) {
        var diff2 = myMoment.diff(now2, "days", true);
        return diff2 < -6 ? "sameElse" : diff2 < -1 ? "lastWeek" : diff2 < 0 ? "lastDay" : diff2 < 1 ? "sameDay" : diff2 < 2 ? "nextDay" : diff2 < 7 ? "nextWeek" : "sameElse";
      }
      function calendar$1(time, formats) {
        if (arguments.length === 1) {
          if (!arguments[0]) {
            time = void 0;
            formats = void 0;
          } else if (isMomentInput(arguments[0])) {
            time = arguments[0];
            formats = void 0;
          } else if (isCalendarSpec(arguments[0])) {
            formats = arguments[0];
            time = void 0;
          }
        }
        var now2 = time || createLocal(), sod = cloneWithOffset(now2, this).startOf("day"), format2 = hooks.calendarFormat(this, sod) || "sameElse", output = formats && (isFunction(formats[format2]) ? formats[format2].call(this, now2) : formats[format2]);
        return this.format(
          output || this.localeData().calendar(format2, this, createLocal(now2))
        );
      }
      function clone() {
        return new Moment(this);
      }
      function isAfter(input, units) {
        var localInput = isMoment(input) ? input : createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
          return false;
        }
        units = normalizeUnits(units) || "millisecond";
        if (units === "millisecond") {
          return this.valueOf() > localInput.valueOf();
        } else {
          return localInput.valueOf() < this.clone().startOf(units).valueOf();
        }
      }
      function isBefore(input, units) {
        var localInput = isMoment(input) ? input : createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
          return false;
        }
        units = normalizeUnits(units) || "millisecond";
        if (units === "millisecond") {
          return this.valueOf() < localInput.valueOf();
        } else {
          return this.clone().endOf(units).valueOf() < localInput.valueOf();
        }
      }
      function isBetween(from2, to2, units, inclusivity) {
        var localFrom = isMoment(from2) ? from2 : createLocal(from2), localTo = isMoment(to2) ? to2 : createLocal(to2);
        if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
          return false;
        }
        inclusivity = inclusivity || "()";
        return (inclusivity[0] === "(" ? this.isAfter(localFrom, units) : !this.isBefore(localFrom, units)) && (inclusivity[1] === ")" ? this.isBefore(localTo, units) : !this.isAfter(localTo, units));
      }
      function isSame(input, units) {
        var localInput = isMoment(input) ? input : createLocal(input), inputMs;
        if (!(this.isValid() && localInput.isValid())) {
          return false;
        }
        units = normalizeUnits(units) || "millisecond";
        if (units === "millisecond") {
          return this.valueOf() === localInput.valueOf();
        } else {
          inputMs = localInput.valueOf();
          return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
        }
      }
      function isSameOrAfter(input, units) {
        return this.isSame(input, units) || this.isAfter(input, units);
      }
      function isSameOrBefore(input, units) {
        return this.isSame(input, units) || this.isBefore(input, units);
      }
      function diff(input, units, asFloat) {
        var that, zoneDelta, output;
        if (!this.isValid()) {
          return NaN;
        }
        that = cloneWithOffset(input, this);
        if (!that.isValid()) {
          return NaN;
        }
        zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;
        units = normalizeUnits(units);
        switch (units) {
          case "year":
            output = monthDiff(this, that) / 12;
            break;
          case "month":
            output = monthDiff(this, that);
            break;
          case "quarter":
            output = monthDiff(this, that) / 3;
            break;
          case "second":
            output = (this - that) / 1e3;
            break;
          case "minute":
            output = (this - that) / 6e4;
            break;
          case "hour":
            output = (this - that) / 36e5;
            break;
          case "day":
            output = (this - that - zoneDelta) / 864e5;
            break;
          case "week":
            output = (this - that - zoneDelta) / 6048e5;
            break;
          default:
            output = this - that;
        }
        return asFloat ? output : absFloor(output);
      }
      function monthDiff(a, b) {
        if (a.date() < b.date()) {
          return -monthDiff(b, a);
        }
        var wholeMonthDiff = (b.year() - a.year()) * 12 + (b.month() - a.month()), anchor = a.clone().add(wholeMonthDiff, "months"), anchor2, adjust;
        if (b - anchor < 0) {
          anchor2 = a.clone().add(wholeMonthDiff - 1, "months");
          adjust = (b - anchor) / (anchor - anchor2);
        } else {
          anchor2 = a.clone().add(wholeMonthDiff + 1, "months");
          adjust = (b - anchor) / (anchor2 - anchor);
        }
        return -(wholeMonthDiff + adjust) || 0;
      }
      hooks.defaultFormat = "YYYY-MM-DDTHH:mm:ssZ";
      hooks.defaultFormatUtc = "YYYY-MM-DDTHH:mm:ss[Z]";
      function toString() {
        return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
      }
      function toISOString(keepOffset) {
        if (!this.isValid()) {
          return null;
        }
        var utc = keepOffset !== true, m = utc ? this.clone().utc() : this;
        if (m.year() < 0 || m.year() > 9999) {
          return formatMoment(
            m,
            utc ? "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYYYY-MM-DD[T]HH:mm:ss.SSSZ"
          );
        }
        if (isFunction(Date.prototype.toISOString)) {
          if (utc) {
            return this.toDate().toISOString();
          } else {
            return new Date(this.valueOf() + this.utcOffset() * 60 * 1e3).toISOString().replace("Z", formatMoment(m, "Z"));
          }
        }
        return formatMoment(
          m,
          utc ? "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYY-MM-DD[T]HH:mm:ss.SSSZ"
        );
      }
      function inspect() {
        if (!this.isValid()) {
          return "moment.invalid(/* " + this._i + " */)";
        }
        var func = "moment", zone = "", prefix, year, datetime, suffix;
        if (!this.isLocal()) {
          func = this.utcOffset() === 0 ? "moment.utc" : "moment.parseZone";
          zone = "Z";
        }
        prefix = "[" + func + '("]';
        year = 0 <= this.year() && this.year() <= 9999 ? "YYYY" : "YYYYYY";
        datetime = "-MM-DD[T]HH:mm:ss.SSS";
        suffix = zone + '[")]';
        return this.format(prefix + year + datetime + suffix);
      }
      function format(inputString) {
        if (!inputString) {
          inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
        }
        var output = formatMoment(this, inputString);
        return this.localeData().postformat(output);
      }
      function from(time, withoutSuffix) {
        if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
          return createDuration({ to: this, from: time }).locale(this.locale()).humanize(!withoutSuffix);
        } else {
          return this.localeData().invalidDate();
        }
      }
      function fromNow(withoutSuffix) {
        return this.from(createLocal(), withoutSuffix);
      }
      function to(time, withoutSuffix) {
        if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
          return createDuration({ from: this, to: time }).locale(this.locale()).humanize(!withoutSuffix);
        } else {
          return this.localeData().invalidDate();
        }
      }
      function toNow(withoutSuffix) {
        return this.to(createLocal(), withoutSuffix);
      }
      function locale(key) {
        var newLocaleData;
        if (key === void 0) {
          return this._locale._abbr;
        } else {
          newLocaleData = getLocale(key);
          if (newLocaleData != null) {
            this._locale = newLocaleData;
          }
          return this;
        }
      }
      var lang = deprecate(
        "moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.",
        function(key) {
          if (key === void 0) {
            return this.localeData();
          } else {
            return this.locale(key);
          }
        }
      );
      function localeData() {
        return this._locale;
      }
      var MS_PER_SECOND = 1e3, MS_PER_MINUTE = 60 * MS_PER_SECOND, MS_PER_HOUR = 60 * MS_PER_MINUTE, MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;
      function mod$1(dividend, divisor) {
        return (dividend % divisor + divisor) % divisor;
      }
      function localStartOfDate(y, m, d) {
        if (y < 100 && y >= 0) {
          return new Date(y + 400, m, d) - MS_PER_400_YEARS;
        } else {
          return new Date(y, m, d).valueOf();
        }
      }
      function utcStartOfDate(y, m, d) {
        if (y < 100 && y >= 0) {
          return Date.UTC(y + 400, m, d) - MS_PER_400_YEARS;
        } else {
          return Date.UTC(y, m, d);
        }
      }
      function startOf(units) {
        var time, startOfDate;
        units = normalizeUnits(units);
        if (units === void 0 || units === "millisecond" || !this.isValid()) {
          return this;
        }
        startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
        switch (units) {
          case "year":
            time = startOfDate(this.year(), 0, 1);
            break;
          case "quarter":
            time = startOfDate(
              this.year(),
              this.month() - this.month() % 3,
              1
            );
            break;
          case "month":
            time = startOfDate(this.year(), this.month(), 1);
            break;
          case "week":
            time = startOfDate(
              this.year(),
              this.month(),
              this.date() - this.weekday()
            );
            break;
          case "isoWeek":
            time = startOfDate(
              this.year(),
              this.month(),
              this.date() - (this.isoWeekday() - 1)
            );
            break;
          case "day":
          case "date":
            time = startOfDate(this.year(), this.month(), this.date());
            break;
          case "hour":
            time = this._d.valueOf();
            time -= mod$1(
              time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
              MS_PER_HOUR
            );
            break;
          case "minute":
            time = this._d.valueOf();
            time -= mod$1(time, MS_PER_MINUTE);
            break;
          case "second":
            time = this._d.valueOf();
            time -= mod$1(time, MS_PER_SECOND);
            break;
        }
        this._d.setTime(time);
        hooks.updateOffset(this, true);
        return this;
      }
      function endOf(units) {
        var time, startOfDate;
        units = normalizeUnits(units);
        if (units === void 0 || units === "millisecond" || !this.isValid()) {
          return this;
        }
        startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
        switch (units) {
          case "year":
            time = startOfDate(this.year() + 1, 0, 1) - 1;
            break;
          case "quarter":
            time = startOfDate(
              this.year(),
              this.month() - this.month() % 3 + 3,
              1
            ) - 1;
            break;
          case "month":
            time = startOfDate(this.year(), this.month() + 1, 1) - 1;
            break;
          case "week":
            time = startOfDate(
              this.year(),
              this.month(),
              this.date() - this.weekday() + 7
            ) - 1;
            break;
          case "isoWeek":
            time = startOfDate(
              this.year(),
              this.month(),
              this.date() - (this.isoWeekday() - 1) + 7
            ) - 1;
            break;
          case "day":
          case "date":
            time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
            break;
          case "hour":
            time = this._d.valueOf();
            time += MS_PER_HOUR - mod$1(
              time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
              MS_PER_HOUR
            ) - 1;
            break;
          case "minute":
            time = this._d.valueOf();
            time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
            break;
          case "second":
            time = this._d.valueOf();
            time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
            break;
        }
        this._d.setTime(time);
        hooks.updateOffset(this, true);
        return this;
      }
      function valueOf() {
        return this._d.valueOf() - (this._offset || 0) * 6e4;
      }
      function unix() {
        return Math.floor(this.valueOf() / 1e3);
      }
      function toDate() {
        return new Date(this.valueOf());
      }
      function toArray() {
        var m = this;
        return [
          m.year(),
          m.month(),
          m.date(),
          m.hour(),
          m.minute(),
          m.second(),
          m.millisecond()
        ];
      }
      function toObject() {
        var m = this;
        return {
          years: m.year(),
          months: m.month(),
          date: m.date(),
          hours: m.hours(),
          minutes: m.minutes(),
          seconds: m.seconds(),
          milliseconds: m.milliseconds()
        };
      }
      function toJSON() {
        return this.isValid() ? this.toISOString() : null;
      }
      function isValid$2() {
        return isValid(this);
      }
      function parsingFlags() {
        return extend({}, getParsingFlags(this));
      }
      function invalidAt() {
        return getParsingFlags(this).overflow;
      }
      function creationData() {
        return {
          input: this._i,
          format: this._f,
          locale: this._locale,
          isUTC: this._isUTC,
          strict: this._strict
        };
      }
      addFormatToken("N", 0, 0, "eraAbbr");
      addFormatToken("NN", 0, 0, "eraAbbr");
      addFormatToken("NNN", 0, 0, "eraAbbr");
      addFormatToken("NNNN", 0, 0, "eraName");
      addFormatToken("NNNNN", 0, 0, "eraNarrow");
      addFormatToken("y", ["y", 1], "yo", "eraYear");
      addFormatToken("y", ["yy", 2], 0, "eraYear");
      addFormatToken("y", ["yyy", 3], 0, "eraYear");
      addFormatToken("y", ["yyyy", 4], 0, "eraYear");
      addRegexToken("N", matchEraAbbr);
      addRegexToken("NN", matchEraAbbr);
      addRegexToken("NNN", matchEraAbbr);
      addRegexToken("NNNN", matchEraName);
      addRegexToken("NNNNN", matchEraNarrow);
      addParseToken(["N", "NN", "NNN", "NNNN", "NNNNN"], function(input, array, config, token2) {
        var era = config._locale.erasParse(input, token2, config._strict);
        if (era) {
          getParsingFlags(config).era = era;
        } else {
          getParsingFlags(config).invalidEra = input;
        }
      });
      addRegexToken("y", matchUnsigned);
      addRegexToken("yy", matchUnsigned);
      addRegexToken("yyy", matchUnsigned);
      addRegexToken("yyyy", matchUnsigned);
      addRegexToken("yo", matchEraYearOrdinal);
      addParseToken(["y", "yy", "yyy", "yyyy"], YEAR);
      addParseToken(["yo"], function(input, array, config, token2) {
        var match;
        if (config._locale._eraYearOrdinalRegex) {
          match = input.match(config._locale._eraYearOrdinalRegex);
        }
        if (config._locale.eraYearOrdinalParse) {
          array[YEAR] = config._locale.eraYearOrdinalParse(input, match);
        } else {
          array[YEAR] = parseInt(input, 10);
        }
      });
      function localeEras(m, format2) {
        var i, l, date, eras = this._eras || getLocale("en")._eras;
        for (i = 0, l = eras.length; i < l; ++i) {
          switch (typeof eras[i].since) {
            case "string":
              date = hooks(eras[i].since).startOf("day");
              eras[i].since = date.valueOf();
              break;
          }
          switch (typeof eras[i].until) {
            case "undefined":
              eras[i].until = Infinity;
              break;
            case "string":
              date = hooks(eras[i].until).startOf("day").valueOf();
              eras[i].until = date.valueOf();
              break;
          }
        }
        return eras;
      }
      function localeErasParse(eraName, format2, strict) {
        var i, l, eras = this.eras(), name, abbr, narrow;
        eraName = eraName.toUpperCase();
        for (i = 0, l = eras.length; i < l; ++i) {
          name = eras[i].name.toUpperCase();
          abbr = eras[i].abbr.toUpperCase();
          narrow = eras[i].narrow.toUpperCase();
          if (strict) {
            switch (format2) {
              case "N":
              case "NN":
              case "NNN":
                if (abbr === eraName) {
                  return eras[i];
                }
                break;
              case "NNNN":
                if (name === eraName) {
                  return eras[i];
                }
                break;
              case "NNNNN":
                if (narrow === eraName) {
                  return eras[i];
                }
                break;
            }
          } else if ([name, abbr, narrow].indexOf(eraName) >= 0) {
            return eras[i];
          }
        }
      }
      function localeErasConvertYear(era, year) {
        var dir = era.since <= era.until ? 1 : -1;
        if (year === void 0) {
          return hooks(era.since).year();
        } else {
          return hooks(era.since).year() + (year - era.offset) * dir;
        }
      }
      function getEraName() {
        var i, l, val, eras = this.localeData().eras();
        for (i = 0, l = eras.length; i < l; ++i) {
          val = this.clone().startOf("day").valueOf();
          if (eras[i].since <= val && val <= eras[i].until) {
            return eras[i].name;
          }
          if (eras[i].until <= val && val <= eras[i].since) {
            return eras[i].name;
          }
        }
        return "";
      }
      function getEraNarrow() {
        var i, l, val, eras = this.localeData().eras();
        for (i = 0, l = eras.length; i < l; ++i) {
          val = this.clone().startOf("day").valueOf();
          if (eras[i].since <= val && val <= eras[i].until) {
            return eras[i].narrow;
          }
          if (eras[i].until <= val && val <= eras[i].since) {
            return eras[i].narrow;
          }
        }
        return "";
      }
      function getEraAbbr() {
        var i, l, val, eras = this.localeData().eras();
        for (i = 0, l = eras.length; i < l; ++i) {
          val = this.clone().startOf("day").valueOf();
          if (eras[i].since <= val && val <= eras[i].until) {
            return eras[i].abbr;
          }
          if (eras[i].until <= val && val <= eras[i].since) {
            return eras[i].abbr;
          }
        }
        return "";
      }
      function getEraYear() {
        var i, l, dir, val, eras = this.localeData().eras();
        for (i = 0, l = eras.length; i < l; ++i) {
          dir = eras[i].since <= eras[i].until ? 1 : -1;
          val = this.clone().startOf("day").valueOf();
          if (eras[i].since <= val && val <= eras[i].until || eras[i].until <= val && val <= eras[i].since) {
            return (this.year() - hooks(eras[i].since).year()) * dir + eras[i].offset;
          }
        }
        return this.year();
      }
      function erasNameRegex(isStrict) {
        if (!hasOwnProp(this, "_erasNameRegex")) {
          computeErasParse.call(this);
        }
        return isStrict ? this._erasNameRegex : this._erasRegex;
      }
      function erasAbbrRegex(isStrict) {
        if (!hasOwnProp(this, "_erasAbbrRegex")) {
          computeErasParse.call(this);
        }
        return isStrict ? this._erasAbbrRegex : this._erasRegex;
      }
      function erasNarrowRegex(isStrict) {
        if (!hasOwnProp(this, "_erasNarrowRegex")) {
          computeErasParse.call(this);
        }
        return isStrict ? this._erasNarrowRegex : this._erasRegex;
      }
      function matchEraAbbr(isStrict, locale2) {
        return locale2.erasAbbrRegex(isStrict);
      }
      function matchEraName(isStrict, locale2) {
        return locale2.erasNameRegex(isStrict);
      }
      function matchEraNarrow(isStrict, locale2) {
        return locale2.erasNarrowRegex(isStrict);
      }
      function matchEraYearOrdinal(isStrict, locale2) {
        return locale2._eraYearOrdinalRegex || matchUnsigned;
      }
      function computeErasParse() {
        var abbrPieces = [], namePieces = [], narrowPieces = [], mixedPieces = [], i, l, eras = this.eras();
        for (i = 0, l = eras.length; i < l; ++i) {
          namePieces.push(regexEscape(eras[i].name));
          abbrPieces.push(regexEscape(eras[i].abbr));
          narrowPieces.push(regexEscape(eras[i].narrow));
          mixedPieces.push(regexEscape(eras[i].name));
          mixedPieces.push(regexEscape(eras[i].abbr));
          mixedPieces.push(regexEscape(eras[i].narrow));
        }
        this._erasRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
        this._erasNameRegex = new RegExp("^(" + namePieces.join("|") + ")", "i");
        this._erasAbbrRegex = new RegExp("^(" + abbrPieces.join("|") + ")", "i");
        this._erasNarrowRegex = new RegExp(
          "^(" + narrowPieces.join("|") + ")",
          "i"
        );
      }
      addFormatToken(0, ["gg", 2], 0, function() {
        return this.weekYear() % 100;
      });
      addFormatToken(0, ["GG", 2], 0, function() {
        return this.isoWeekYear() % 100;
      });
      function addWeekYearFormatToken(token2, getter) {
        addFormatToken(0, [token2, token2.length], 0, getter);
      }
      addWeekYearFormatToken("gggg", "weekYear");
      addWeekYearFormatToken("ggggg", "weekYear");
      addWeekYearFormatToken("GGGG", "isoWeekYear");
      addWeekYearFormatToken("GGGGG", "isoWeekYear");
      addUnitAlias("weekYear", "gg");
      addUnitAlias("isoWeekYear", "GG");
      addUnitPriority("weekYear", 1);
      addUnitPriority("isoWeekYear", 1);
      addRegexToken("G", matchSigned);
      addRegexToken("g", matchSigned);
      addRegexToken("GG", match1to2, match2);
      addRegexToken("gg", match1to2, match2);
      addRegexToken("GGGG", match1to4, match4);
      addRegexToken("gggg", match1to4, match4);
      addRegexToken("GGGGG", match1to6, match6);
      addRegexToken("ggggg", match1to6, match6);
      addWeekParseToken(["gggg", "ggggg", "GGGG", "GGGGG"], function(input, week, config, token2) {
        week[token2.substr(0, 2)] = toInt(input);
      });
      addWeekParseToken(["gg", "GG"], function(input, week, config, token2) {
        week[token2] = hooks.parseTwoDigitYear(input);
      });
      function getSetWeekYear(input) {
        return getSetWeekYearHelper.call(
          this,
          input,
          this.week(),
          this.weekday(),
          this.localeData()._week.dow,
          this.localeData()._week.doy
        );
      }
      function getSetISOWeekYear(input) {
        return getSetWeekYearHelper.call(
          this,
          input,
          this.isoWeek(),
          this.isoWeekday(),
          1,
          4
        );
      }
      function getISOWeeksInYear() {
        return weeksInYear(this.year(), 1, 4);
      }
      function getISOWeeksInISOWeekYear() {
        return weeksInYear(this.isoWeekYear(), 1, 4);
      }
      function getWeeksInYear() {
        var weekInfo = this.localeData()._week;
        return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
      }
      function getWeeksInWeekYear() {
        var weekInfo = this.localeData()._week;
        return weeksInYear(this.weekYear(), weekInfo.dow, weekInfo.doy);
      }
      function getSetWeekYearHelper(input, week, weekday, dow, doy) {
        var weeksTarget;
        if (input == null) {
          return weekOfYear(this, dow, doy).year;
        } else {
          weeksTarget = weeksInYear(input, dow, doy);
          if (week > weeksTarget) {
            week = weeksTarget;
          }
          return setWeekAll.call(this, input, week, weekday, dow, doy);
        }
      }
      function setWeekAll(weekYear, week, weekday, dow, doy) {
        var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy), date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);
        this.year(date.getUTCFullYear());
        this.month(date.getUTCMonth());
        this.date(date.getUTCDate());
        return this;
      }
      addFormatToken("Q", 0, "Qo", "quarter");
      addUnitAlias("quarter", "Q");
      addUnitPriority("quarter", 7);
      addRegexToken("Q", match1);
      addParseToken("Q", function(input, array) {
        array[MONTH] = (toInt(input) - 1) * 3;
      });
      function getSetQuarter(input) {
        return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
      }
      addFormatToken("D", ["DD", 2], "Do", "date");
      addUnitAlias("date", "D");
      addUnitPriority("date", 9);
      addRegexToken("D", match1to2);
      addRegexToken("DD", match1to2, match2);
      addRegexToken("Do", function(isStrict, locale2) {
        return isStrict ? locale2._dayOfMonthOrdinalParse || locale2._ordinalParse : locale2._dayOfMonthOrdinalParseLenient;
      });
      addParseToken(["D", "DD"], DATE);
      addParseToken("Do", function(input, array) {
        array[DATE] = toInt(input.match(match1to2)[0]);
      });
      var getSetDayOfMonth = makeGetSet("Date", true);
      addFormatToken("DDD", ["DDDD", 3], "DDDo", "dayOfYear");
      addUnitAlias("dayOfYear", "DDD");
      addUnitPriority("dayOfYear", 4);
      addRegexToken("DDD", match1to3);
      addRegexToken("DDDD", match3);
      addParseToken(["DDD", "DDDD"], function(input, array, config) {
        config._dayOfYear = toInt(input);
      });
      function getSetDayOfYear(input) {
        var dayOfYear = Math.round(
          (this.clone().startOf("day") - this.clone().startOf("year")) / 864e5
        ) + 1;
        return input == null ? dayOfYear : this.add(input - dayOfYear, "d");
      }
      addFormatToken("m", ["mm", 2], 0, "minute");
      addUnitAlias("minute", "m");
      addUnitPriority("minute", 14);
      addRegexToken("m", match1to2);
      addRegexToken("mm", match1to2, match2);
      addParseToken(["m", "mm"], MINUTE);
      var getSetMinute = makeGetSet("Minutes", false);
      addFormatToken("s", ["ss", 2], 0, "second");
      addUnitAlias("second", "s");
      addUnitPriority("second", 15);
      addRegexToken("s", match1to2);
      addRegexToken("ss", match1to2, match2);
      addParseToken(["s", "ss"], SECOND);
      var getSetSecond = makeGetSet("Seconds", false);
      addFormatToken("S", 0, 0, function() {
        return ~~(this.millisecond() / 100);
      });
      addFormatToken(0, ["SS", 2], 0, function() {
        return ~~(this.millisecond() / 10);
      });
      addFormatToken(0, ["SSS", 3], 0, "millisecond");
      addFormatToken(0, ["SSSS", 4], 0, function() {
        return this.millisecond() * 10;
      });
      addFormatToken(0, ["SSSSS", 5], 0, function() {
        return this.millisecond() * 100;
      });
      addFormatToken(0, ["SSSSSS", 6], 0, function() {
        return this.millisecond() * 1e3;
      });
      addFormatToken(0, ["SSSSSSS", 7], 0, function() {
        return this.millisecond() * 1e4;
      });
      addFormatToken(0, ["SSSSSSSS", 8], 0, function() {
        return this.millisecond() * 1e5;
      });
      addFormatToken(0, ["SSSSSSSSS", 9], 0, function() {
        return this.millisecond() * 1e6;
      });
      addUnitAlias("millisecond", "ms");
      addUnitPriority("millisecond", 16);
      addRegexToken("S", match1to3, match1);
      addRegexToken("SS", match1to3, match2);
      addRegexToken("SSS", match1to3, match3);
      var token, getSetMillisecond;
      for (token = "SSSS"; token.length <= 9; token += "S") {
        addRegexToken(token, matchUnsigned);
      }
      function parseMs(input, array) {
        array[MILLISECOND] = toInt(("0." + input) * 1e3);
      }
      for (token = "S"; token.length <= 9; token += "S") {
        addParseToken(token, parseMs);
      }
      getSetMillisecond = makeGetSet("Milliseconds", false);
      addFormatToken("z", 0, 0, "zoneAbbr");
      addFormatToken("zz", 0, 0, "zoneName");
      function getZoneAbbr() {
        return this._isUTC ? "UTC" : "";
      }
      function getZoneName() {
        return this._isUTC ? "Coordinated Universal Time" : "";
      }
      var proto = Moment.prototype;
      proto.add = add;
      proto.calendar = calendar$1;
      proto.clone = clone;
      proto.diff = diff;
      proto.endOf = endOf;
      proto.format = format;
      proto.from = from;
      proto.fromNow = fromNow;
      proto.to = to;
      proto.toNow = toNow;
      proto.get = stringGet;
      proto.invalidAt = invalidAt;
      proto.isAfter = isAfter;
      proto.isBefore = isBefore;
      proto.isBetween = isBetween;
      proto.isSame = isSame;
      proto.isSameOrAfter = isSameOrAfter;
      proto.isSameOrBefore = isSameOrBefore;
      proto.isValid = isValid$2;
      proto.lang = lang;
      proto.locale = locale;
      proto.localeData = localeData;
      proto.max = prototypeMax;
      proto.min = prototypeMin;
      proto.parsingFlags = parsingFlags;
      proto.set = stringSet;
      proto.startOf = startOf;
      proto.subtract = subtract;
      proto.toArray = toArray;
      proto.toObject = toObject;
      proto.toDate = toDate;
      proto.toISOString = toISOString;
      proto.inspect = inspect;
      if (typeof Symbol !== "undefined" && Symbol.for != null) {
        proto[Symbol.for("nodejs.util.inspect.custom")] = function() {
          return "Moment<" + this.format() + ">";
        };
      }
      proto.toJSON = toJSON;
      proto.toString = toString;
      proto.unix = unix;
      proto.valueOf = valueOf;
      proto.creationData = creationData;
      proto.eraName = getEraName;
      proto.eraNarrow = getEraNarrow;
      proto.eraAbbr = getEraAbbr;
      proto.eraYear = getEraYear;
      proto.year = getSetYear;
      proto.isLeapYear = getIsLeapYear;
      proto.weekYear = getSetWeekYear;
      proto.isoWeekYear = getSetISOWeekYear;
      proto.quarter = proto.quarters = getSetQuarter;
      proto.month = getSetMonth;
      proto.daysInMonth = getDaysInMonth;
      proto.week = proto.weeks = getSetWeek;
      proto.isoWeek = proto.isoWeeks = getSetISOWeek;
      proto.weeksInYear = getWeeksInYear;
      proto.weeksInWeekYear = getWeeksInWeekYear;
      proto.isoWeeksInYear = getISOWeeksInYear;
      proto.isoWeeksInISOWeekYear = getISOWeeksInISOWeekYear;
      proto.date = getSetDayOfMonth;
      proto.day = proto.days = getSetDayOfWeek;
      proto.weekday = getSetLocaleDayOfWeek;
      proto.isoWeekday = getSetISODayOfWeek;
      proto.dayOfYear = getSetDayOfYear;
      proto.hour = proto.hours = getSetHour;
      proto.minute = proto.minutes = getSetMinute;
      proto.second = proto.seconds = getSetSecond;
      proto.millisecond = proto.milliseconds = getSetMillisecond;
      proto.utcOffset = getSetOffset;
      proto.utc = setOffsetToUTC;
      proto.local = setOffsetToLocal;
      proto.parseZone = setOffsetToParsedOffset;
      proto.hasAlignedHourOffset = hasAlignedHourOffset;
      proto.isDST = isDaylightSavingTime;
      proto.isLocal = isLocal;
      proto.isUtcOffset = isUtcOffset;
      proto.isUtc = isUtc;
      proto.isUTC = isUtc;
      proto.zoneAbbr = getZoneAbbr;
      proto.zoneName = getZoneName;
      proto.dates = deprecate(
        "dates accessor is deprecated. Use date instead.",
        getSetDayOfMonth
      );
      proto.months = deprecate(
        "months accessor is deprecated. Use month instead",
        getSetMonth
      );
      proto.years = deprecate(
        "years accessor is deprecated. Use year instead",
        getSetYear
      );
      proto.zone = deprecate(
        "moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/",
        getSetZone
      );
      proto.isDSTShifted = deprecate(
        "isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information",
        isDaylightSavingTimeShifted
      );
      function createUnix(input) {
        return createLocal(input * 1e3);
      }
      function createInZone() {
        return createLocal.apply(null, arguments).parseZone();
      }
      function preParsePostFormat(string2) {
        return string2;
      }
      var proto$1 = Locale.prototype;
      proto$1.calendar = calendar;
      proto$1.longDateFormat = longDateFormat;
      proto$1.invalidDate = invalidDate;
      proto$1.ordinal = ordinal;
      proto$1.preparse = preParsePostFormat;
      proto$1.postformat = preParsePostFormat;
      proto$1.relativeTime = relativeTime;
      proto$1.pastFuture = pastFuture;
      proto$1.set = set2;
      proto$1.eras = localeEras;
      proto$1.erasParse = localeErasParse;
      proto$1.erasConvertYear = localeErasConvertYear;
      proto$1.erasAbbrRegex = erasAbbrRegex;
      proto$1.erasNameRegex = erasNameRegex;
      proto$1.erasNarrowRegex = erasNarrowRegex;
      proto$1.months = localeMonths;
      proto$1.monthsShort = localeMonthsShort;
      proto$1.monthsParse = localeMonthsParse;
      proto$1.monthsRegex = monthsRegex;
      proto$1.monthsShortRegex = monthsShortRegex;
      proto$1.week = localeWeek;
      proto$1.firstDayOfYear = localeFirstDayOfYear;
      proto$1.firstDayOfWeek = localeFirstDayOfWeek;
      proto$1.weekdays = localeWeekdays;
      proto$1.weekdaysMin = localeWeekdaysMin;
      proto$1.weekdaysShort = localeWeekdaysShort;
      proto$1.weekdaysParse = localeWeekdaysParse;
      proto$1.weekdaysRegex = weekdaysRegex;
      proto$1.weekdaysShortRegex = weekdaysShortRegex;
      proto$1.weekdaysMinRegex = weekdaysMinRegex;
      proto$1.isPM = localeIsPM;
      proto$1.meridiem = localeMeridiem;
      function get$1(format2, index, field, setter) {
        var locale2 = getLocale(), utc = createUTC().set(setter, index);
        return locale2[field](utc, format2);
      }
      function listMonthsImpl(format2, index, field) {
        if (isNumber(format2)) {
          index = format2;
          format2 = void 0;
        }
        format2 = format2 || "";
        if (index != null) {
          return get$1(format2, index, field, "month");
        }
        var i, out = [];
        for (i = 0; i < 12; i++) {
          out[i] = get$1(format2, i, field, "month");
        }
        return out;
      }
      function listWeekdaysImpl(localeSorted, format2, index, field) {
        if (typeof localeSorted === "boolean") {
          if (isNumber(format2)) {
            index = format2;
            format2 = void 0;
          }
          format2 = format2 || "";
        } else {
          format2 = localeSorted;
          index = format2;
          localeSorted = false;
          if (isNumber(format2)) {
            index = format2;
            format2 = void 0;
          }
          format2 = format2 || "";
        }
        var locale2 = getLocale(), shift = localeSorted ? locale2._week.dow : 0, i, out = [];
        if (index != null) {
          return get$1(format2, (index + shift) % 7, field, "day");
        }
        for (i = 0; i < 7; i++) {
          out[i] = get$1(format2, (i + shift) % 7, field, "day");
        }
        return out;
      }
      function listMonths(format2, index) {
        return listMonthsImpl(format2, index, "months");
      }
      function listMonthsShort(format2, index) {
        return listMonthsImpl(format2, index, "monthsShort");
      }
      function listWeekdays(localeSorted, format2, index) {
        return listWeekdaysImpl(localeSorted, format2, index, "weekdays");
      }
      function listWeekdaysShort(localeSorted, format2, index) {
        return listWeekdaysImpl(localeSorted, format2, index, "weekdaysShort");
      }
      function listWeekdaysMin(localeSorted, format2, index) {
        return listWeekdaysImpl(localeSorted, format2, index, "weekdaysMin");
      }
      getSetGlobalLocale("en", {
        eras: [
          {
            since: "0001-01-01",
            until: Infinity,
            offset: 1,
            name: "Anno Domini",
            narrow: "AD",
            abbr: "AD"
          },
          {
            since: "0000-12-31",
            until: -Infinity,
            offset: 1,
            name: "Before Christ",
            narrow: "BC",
            abbr: "BC"
          }
        ],
        dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
        ordinal: function(number) {
          var b = number % 10, output = toInt(number % 100 / 10) === 1 ? "th" : b === 1 ? "st" : b === 2 ? "nd" : b === 3 ? "rd" : "th";
          return number + output;
        }
      });
      hooks.lang = deprecate(
        "moment.lang is deprecated. Use moment.locale instead.",
        getSetGlobalLocale
      );
      hooks.langData = deprecate(
        "moment.langData is deprecated. Use moment.localeData instead.",
        getLocale
      );
      var mathAbs = Math.abs;
      function abs() {
        var data = this._data;
        this._milliseconds = mathAbs(this._milliseconds);
        this._days = mathAbs(this._days);
        this._months = mathAbs(this._months);
        data.milliseconds = mathAbs(data.milliseconds);
        data.seconds = mathAbs(data.seconds);
        data.minutes = mathAbs(data.minutes);
        data.hours = mathAbs(data.hours);
        data.months = mathAbs(data.months);
        data.years = mathAbs(data.years);
        return this;
      }
      function addSubtract$1(duration, input, value, direction) {
        var other = createDuration(input, value);
        duration._milliseconds += direction * other._milliseconds;
        duration._days += direction * other._days;
        duration._months += direction * other._months;
        return duration._bubble();
      }
      function add$1(input, value) {
        return addSubtract$1(this, input, value, 1);
      }
      function subtract$1(input, value) {
        return addSubtract$1(this, input, value, -1);
      }
      function absCeil(number) {
        if (number < 0) {
          return Math.floor(number);
        } else {
          return Math.ceil(number);
        }
      }
      function bubble() {
        var milliseconds2 = this._milliseconds, days2 = this._days, months2 = this._months, data = this._data, seconds2, minutes2, hours2, years2, monthsFromDays;
        if (!(milliseconds2 >= 0 && days2 >= 0 && months2 >= 0 || milliseconds2 <= 0 && days2 <= 0 && months2 <= 0)) {
          milliseconds2 += absCeil(monthsToDays(months2) + days2) * 864e5;
          days2 = 0;
          months2 = 0;
        }
        data.milliseconds = milliseconds2 % 1e3;
        seconds2 = absFloor(milliseconds2 / 1e3);
        data.seconds = seconds2 % 60;
        minutes2 = absFloor(seconds2 / 60);
        data.minutes = minutes2 % 60;
        hours2 = absFloor(minutes2 / 60);
        data.hours = hours2 % 24;
        days2 += absFloor(hours2 / 24);
        monthsFromDays = absFloor(daysToMonths(days2));
        months2 += monthsFromDays;
        days2 -= absCeil(monthsToDays(monthsFromDays));
        years2 = absFloor(months2 / 12);
        months2 %= 12;
        data.days = days2;
        data.months = months2;
        data.years = years2;
        return this;
      }
      function daysToMonths(days2) {
        return days2 * 4800 / 146097;
      }
      function monthsToDays(months2) {
        return months2 * 146097 / 4800;
      }
      function as(units) {
        if (!this.isValid()) {
          return NaN;
        }
        var days2, months2, milliseconds2 = this._milliseconds;
        units = normalizeUnits(units);
        if (units === "month" || units === "quarter" || units === "year") {
          days2 = this._days + milliseconds2 / 864e5;
          months2 = this._months + daysToMonths(days2);
          switch (units) {
            case "month":
              return months2;
            case "quarter":
              return months2 / 3;
            case "year":
              return months2 / 12;
          }
        } else {
          days2 = this._days + Math.round(monthsToDays(this._months));
          switch (units) {
            case "week":
              return days2 / 7 + milliseconds2 / 6048e5;
            case "day":
              return days2 + milliseconds2 / 864e5;
            case "hour":
              return days2 * 24 + milliseconds2 / 36e5;
            case "minute":
              return days2 * 1440 + milliseconds2 / 6e4;
            case "second":
              return days2 * 86400 + milliseconds2 / 1e3;
            case "millisecond":
              return Math.floor(days2 * 864e5) + milliseconds2;
            default:
              throw new Error("Unknown unit " + units);
          }
        }
      }
      function valueOf$1() {
        if (!this.isValid()) {
          return NaN;
        }
        return this._milliseconds + this._days * 864e5 + this._months % 12 * 2592e6 + toInt(this._months / 12) * 31536e6;
      }
      function makeAs(alias) {
        return function() {
          return this.as(alias);
        };
      }
      var asMilliseconds = makeAs("ms"), asSeconds = makeAs("s"), asMinutes = makeAs("m"), asHours = makeAs("h"), asDays = makeAs("d"), asWeeks = makeAs("w"), asMonths = makeAs("M"), asQuarters = makeAs("Q"), asYears = makeAs("y");
      function clone$1() {
        return createDuration(this);
      }
      function get$2(units) {
        units = normalizeUnits(units);
        return this.isValid() ? this[units + "s"]() : NaN;
      }
      function makeGetter(name) {
        return function() {
          return this.isValid() ? this._data[name] : NaN;
        };
      }
      var milliseconds = makeGetter("milliseconds"), seconds = makeGetter("seconds"), minutes = makeGetter("minutes"), hours = makeGetter("hours"), days = makeGetter("days"), months = makeGetter("months"), years = makeGetter("years");
      function weeks() {
        return absFloor(this.days() / 7);
      }
      var round = Math.round, thresholds = {
        ss: 44,
        // a few seconds to seconds
        s: 45,
        // seconds to minute
        m: 45,
        // minutes to hour
        h: 22,
        // hours to day
        d: 26,
        // days to month/week
        w: null,
        // weeks to month
        M: 11
        // months to year
      };
      function substituteTimeAgo(string2, number, withoutSuffix, isFuture, locale2) {
        return locale2.relativeTime(number || 1, !!withoutSuffix, string2, isFuture);
      }
      function relativeTime$1(posNegDuration, withoutSuffix, thresholds2, locale2) {
        var duration = createDuration(posNegDuration).abs(), seconds2 = round(duration.as("s")), minutes2 = round(duration.as("m")), hours2 = round(duration.as("h")), days2 = round(duration.as("d")), months2 = round(duration.as("M")), weeks2 = round(duration.as("w")), years2 = round(duration.as("y")), a = seconds2 <= thresholds2.ss && ["s", seconds2] || seconds2 < thresholds2.s && ["ss", seconds2] || minutes2 <= 1 && ["m"] || minutes2 < thresholds2.m && ["mm", minutes2] || hours2 <= 1 && ["h"] || hours2 < thresholds2.h && ["hh", hours2] || days2 <= 1 && ["d"] || days2 < thresholds2.d && ["dd", days2];
        if (thresholds2.w != null) {
          a = a || weeks2 <= 1 && ["w"] || weeks2 < thresholds2.w && ["ww", weeks2];
        }
        a = a || months2 <= 1 && ["M"] || months2 < thresholds2.M && ["MM", months2] || years2 <= 1 && ["y"] || ["yy", years2];
        a[2] = withoutSuffix;
        a[3] = +posNegDuration > 0;
        a[4] = locale2;
        return substituteTimeAgo.apply(null, a);
      }
      function getSetRelativeTimeRounding(roundingFunction) {
        if (roundingFunction === void 0) {
          return round;
        }
        if (typeof roundingFunction === "function") {
          round = roundingFunction;
          return true;
        }
        return false;
      }
      function getSetRelativeTimeThreshold(threshold, limit) {
        if (thresholds[threshold] === void 0) {
          return false;
        }
        if (limit === void 0) {
          return thresholds[threshold];
        }
        thresholds[threshold] = limit;
        if (threshold === "s") {
          thresholds.ss = limit - 1;
        }
        return true;
      }
      function humanize(argWithSuffix, argThresholds) {
        if (!this.isValid()) {
          return this.localeData().invalidDate();
        }
        var withSuffix = false, th = thresholds, locale2, output;
        if (typeof argWithSuffix === "object") {
          argThresholds = argWithSuffix;
          argWithSuffix = false;
        }
        if (typeof argWithSuffix === "boolean") {
          withSuffix = argWithSuffix;
        }
        if (typeof argThresholds === "object") {
          th = Object.assign({}, thresholds, argThresholds);
          if (argThresholds.s != null && argThresholds.ss == null) {
            th.ss = argThresholds.s - 1;
          }
        }
        locale2 = this.localeData();
        output = relativeTime$1(this, !withSuffix, th, locale2);
        if (withSuffix) {
          output = locale2.pastFuture(+this, output);
        }
        return locale2.postformat(output);
      }
      var abs$1 = Math.abs;
      function sign(x) {
        return (x > 0) - (x < 0) || +x;
      }
      function toISOString$1() {
        if (!this.isValid()) {
          return this.localeData().invalidDate();
        }
        var seconds2 = abs$1(this._milliseconds) / 1e3, days2 = abs$1(this._days), months2 = abs$1(this._months), minutes2, hours2, years2, s, total = this.asSeconds(), totalSign, ymSign, daysSign, hmsSign;
        if (!total) {
          return "P0D";
        }
        minutes2 = absFloor(seconds2 / 60);
        hours2 = absFloor(minutes2 / 60);
        seconds2 %= 60;
        minutes2 %= 60;
        years2 = absFloor(months2 / 12);
        months2 %= 12;
        s = seconds2 ? seconds2.toFixed(3).replace(/\.?0+$/, "") : "";
        totalSign = total < 0 ? "-" : "";
        ymSign = sign(this._months) !== sign(total) ? "-" : "";
        daysSign = sign(this._days) !== sign(total) ? "-" : "";
        hmsSign = sign(this._milliseconds) !== sign(total) ? "-" : "";
        return totalSign + "P" + (years2 ? ymSign + years2 + "Y" : "") + (months2 ? ymSign + months2 + "M" : "") + (days2 ? daysSign + days2 + "D" : "") + (hours2 || minutes2 || seconds2 ? "T" : "") + (hours2 ? hmsSign + hours2 + "H" : "") + (minutes2 ? hmsSign + minutes2 + "M" : "") + (seconds2 ? hmsSign + s + "S" : "");
      }
      var proto$2 = Duration.prototype;
      proto$2.isValid = isValid$1;
      proto$2.abs = abs;
      proto$2.add = add$1;
      proto$2.subtract = subtract$1;
      proto$2.as = as;
      proto$2.asMilliseconds = asMilliseconds;
      proto$2.asSeconds = asSeconds;
      proto$2.asMinutes = asMinutes;
      proto$2.asHours = asHours;
      proto$2.asDays = asDays;
      proto$2.asWeeks = asWeeks;
      proto$2.asMonths = asMonths;
      proto$2.asQuarters = asQuarters;
      proto$2.asYears = asYears;
      proto$2.valueOf = valueOf$1;
      proto$2._bubble = bubble;
      proto$2.clone = clone$1;
      proto$2.get = get$2;
      proto$2.milliseconds = milliseconds;
      proto$2.seconds = seconds;
      proto$2.minutes = minutes;
      proto$2.hours = hours;
      proto$2.days = days;
      proto$2.weeks = weeks;
      proto$2.months = months;
      proto$2.years = years;
      proto$2.humanize = humanize;
      proto$2.toISOString = toISOString$1;
      proto$2.toString = toISOString$1;
      proto$2.toJSON = toISOString$1;
      proto$2.locale = locale;
      proto$2.localeData = localeData;
      proto$2.toIsoString = deprecate(
        "toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)",
        toISOString$1
      );
      proto$2.lang = lang;
      addFormatToken("X", 0, 0, "unix");
      addFormatToken("x", 0, 0, "valueOf");
      addRegexToken("x", matchSigned);
      addRegexToken("X", matchTimestamp);
      addParseToken("X", function(input, array, config) {
        config._d = new Date(parseFloat(input) * 1e3);
      });
      addParseToken("x", function(input, array, config) {
        config._d = new Date(toInt(input));
      });
      hooks.version = "2.29.1";
      setHookCallback(createLocal);
      hooks.fn = proto;
      hooks.min = min;
      hooks.max = max;
      hooks.now = now;
      hooks.utc = createUTC;
      hooks.unix = createUnix;
      hooks.months = listMonths;
      hooks.isDate = isDate;
      hooks.locale = getSetGlobalLocale;
      hooks.invalid = createInvalid;
      hooks.duration = createDuration;
      hooks.isMoment = isMoment;
      hooks.weekdays = listWeekdays;
      hooks.parseZone = createInZone;
      hooks.localeData = getLocale;
      hooks.isDuration = isDuration;
      hooks.monthsShort = listMonthsShort;
      hooks.weekdaysMin = listWeekdaysMin;
      hooks.defineLocale = defineLocale;
      hooks.updateLocale = updateLocale;
      hooks.locales = listLocales;
      hooks.weekdaysShort = listWeekdaysShort;
      hooks.normalizeUnits = normalizeUnits;
      hooks.relativeTimeRounding = getSetRelativeTimeRounding;
      hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
      hooks.calendarFormat = getCalendarFormat;
      hooks.prototype = proto;
      hooks.HTML5_FMT = {
        DATETIME_LOCAL: "YYYY-MM-DDTHH:mm",
        // <input type="datetime-local" />
        DATETIME_LOCAL_SECONDS: "YYYY-MM-DDTHH:mm:ss",
        // <input type="datetime-local" step="1" />
        DATETIME_LOCAL_MS: "YYYY-MM-DDTHH:mm:ss.SSS",
        // <input type="datetime-local" step="0.001" />
        DATE: "YYYY-MM-DD",
        // <input type="date" />
        TIME: "HH:mm",
        // <input type="time" />
        TIME_SECONDS: "HH:mm:ss",
        // <input type="time" step="1" />
        TIME_MS: "HH:mm:ss.SSS",
        // <input type="time" step="0.001" />
        WEEK: "GGGG-[W]WW",
        // <input type="week" />
        MONTH: "YYYY-MM"
        // <input type="month" />
      };
      return hooks;
    });
  }
});

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => MyPlugin
});
module.exports = __toCommonJS(main_exports);

// updateNoteTypeModal.ts
var import_obsidian3 = require("obsidian");

// tagrenamer/renaming.ts
var import_obsidian2 = require("obsidian");

// tagrenamer/Tag.ts
var tagBody = /^#[^\u2000-\u206F\u2E00-\u2E7F'!"#$%&()*+,.:;<=>?@^`{|}~\[\]\\\s]+$/;
var Tag = class {
  constructor(name) {
    const hashed = this.tag = Tag.toTag(name), canonical = this.canonical = hashed.toLowerCase(), canonical_prefix = this.canonical_prefix = canonical + "/";
    this.name = hashed.slice(1);
    this.matches = function(text) {
      text = text.toLowerCase();
      return text == canonical || text.startsWith(canonical_prefix);
    };
  }
  toString() {
    return this.tag;
  }
  static isTag(s) {
    return tagBody.test(s);
  }
  static toTag(name) {
    while (name.startsWith("##"))
      name = name.slice(1);
    return name.startsWith("#") ? name : "#" + name;
  }
  static canonical(name) {
    return Tag.toTag(name).toLowerCase();
  }
};
var Replacement = class {
  constructor(fromTag, toTag) {
    const cache = Object.assign(
      /* @__PURE__ */ Object.create(null),
      {
        [fromTag.tag]: toTag.tag,
        [fromTag.name]: toTag.name
      }
    );
    this.inString = function(text, pos = 0) {
      return text.slice(0, pos) + toTag.tag + text.slice(pos + fromTag.tag.length);
    };
    this.inArray = (tags, skipOdd, isAlias2) => {
      return tags.map((t, i) => {
        if (skipOdd && i & 1)
          return t;
        if (!t)
          return t;
        if (isAlias2) {
          if (!t.startsWith("#") || !Tag.isTag(t))
            return t;
        } else if (/[ ,\n]/.test(t)) {
          return this.inArray(t.split(/([, \n]+)/), true, isAlias2).join("");
        }
        if (cache[t])
          return cache[t];
        const lc = t.toLowerCase();
        if (cache[lc]) {
          return cache[t] = cache[lc];
        } else if (lc.startsWith(fromTag.canonical_prefix)) {
          return cache[t] = cache[lc] = this.inString(t);
        } else if (("#" + lc).startsWith(fromTag.canonical_prefix)) {
          return cache[t] = cache[lc] = this.inString("#" + t).slice(1);
        }
        return cache[t] = cache[lc] = t;
      });
    };
    this.willMergeTags = function(tagNames) {
      if (fromTag.canonical === toTag.canonical)
        return;
      const existing = new Set(tagNames.map((s) => s.toLowerCase()));
      for (const tagName of tagNames.filter(fromTag.matches)) {
        const changed = this.inString(tagName);
        if (existing.has(changed.toLowerCase()))
          return [new Tag(tagName), new Tag(changed)];
      }
    };
  }
};

// tagrenamer/File.ts
var import_obsidian = require("obsidian");

// node_modules/yaml/browser/dist/nodes/Node.js
var ALIAS = Symbol.for("yaml.alias");
var DOC = Symbol.for("yaml.document");
var MAP = Symbol.for("yaml.map");
var PAIR = Symbol.for("yaml.pair");
var SCALAR = Symbol.for("yaml.scalar");
var SEQ = Symbol.for("yaml.seq");
var NODE_TYPE = Symbol.for("yaml.node.type");
var isAlias = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === ALIAS;
var isDocument = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === DOC;
var isMap = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === MAP;
var isPair = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === PAIR;
var isScalar = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === SCALAR;
var isSeq = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === SEQ;
function isCollection(node) {
  if (node && typeof node === "object")
    switch (node[NODE_TYPE]) {
      case MAP:
      case SEQ:
        return true;
    }
  return false;
}
function isNode(node) {
  if (node && typeof node === "object")
    switch (node[NODE_TYPE]) {
      case ALIAS:
      case MAP:
      case SCALAR:
      case SEQ:
        return true;
    }
  return false;
}
var hasAnchor = (node) => (isScalar(node) || isCollection(node)) && !!node.anchor;
var NodeBase = class {
  constructor(type) {
    Object.defineProperty(this, NODE_TYPE, { value: type });
  }
  /** Create a copy of this node.  */
  clone() {
    const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
    if (this.range)
      copy.range = this.range.slice();
    return copy;
  }
};

// node_modules/yaml/browser/dist/visit.js
var BREAK = Symbol("break visit");
var SKIP = Symbol("skip children");
var REMOVE = Symbol("remove node");
function visit(node, visitor) {
  if (typeof visitor === "object" && (visitor.Collection || visitor.Node || visitor.Value)) {
    visitor = Object.assign({
      Alias: visitor.Node,
      Map: visitor.Node,
      Scalar: visitor.Node,
      Seq: visitor.Node
    }, visitor.Value && {
      Map: visitor.Value,
      Scalar: visitor.Value,
      Seq: visitor.Value
    }, visitor.Collection && {
      Map: visitor.Collection,
      Seq: visitor.Collection
    }, visitor);
  }
  if (isDocument(node)) {
    const cd = _visit(null, node.contents, visitor, Object.freeze([node]));
    if (cd === REMOVE)
      node.contents = null;
  } else
    _visit(null, node, visitor, Object.freeze([]));
}
visit.BREAK = BREAK;
visit.SKIP = SKIP;
visit.REMOVE = REMOVE;
function _visit(key, node, visitor, path) {
  let ctrl = void 0;
  if (typeof visitor === "function")
    ctrl = visitor(key, node, path);
  else if (isMap(node)) {
    if (visitor.Map)
      ctrl = visitor.Map(key, node, path);
  } else if (isSeq(node)) {
    if (visitor.Seq)
      ctrl = visitor.Seq(key, node, path);
  } else if (isPair(node)) {
    if (visitor.Pair)
      ctrl = visitor.Pair(key, node, path);
  } else if (isScalar(node)) {
    if (visitor.Scalar)
      ctrl = visitor.Scalar(key, node, path);
  } else if (isAlias(node)) {
    if (visitor.Alias)
      ctrl = visitor.Alias(key, node, path);
  }
  if (isNode(ctrl) || isPair(ctrl)) {
    const parent = path[path.length - 1];
    if (isCollection(parent)) {
      parent.items[key] = ctrl;
    } else if (isPair(parent)) {
      if (key === "key")
        parent.key = ctrl;
      else
        parent.value = ctrl;
    } else if (isDocument(parent)) {
      parent.contents = ctrl;
    } else {
      const pt = isAlias(parent) ? "alias" : "scalar";
      throw new Error(`Cannot replace node with ${pt} parent`);
    }
    return _visit(key, ctrl, visitor, path);
  }
  if (typeof ctrl !== "symbol") {
    if (isCollection(node)) {
      path = Object.freeze(path.concat(node));
      for (let i = 0; i < node.items.length; ++i) {
        const ci = _visit(i, node.items[i], visitor, path);
        if (typeof ci === "number")
          i = ci - 1;
        else if (ci === BREAK)
          return BREAK;
        else if (ci === REMOVE) {
          node.items.splice(i, 1);
          i -= 1;
        }
      }
    } else if (isPair(node)) {
      path = Object.freeze(path.concat(node));
      const ck = _visit("key", node.key, visitor, path);
      if (ck === BREAK)
        return BREAK;
      else if (ck === REMOVE)
        node.key = null;
      const cv = _visit("value", node.value, visitor, path);
      if (cv === BREAK)
        return BREAK;
      else if (cv === REMOVE)
        node.value = null;
    }
  }
  return ctrl;
}

// node_modules/yaml/browser/dist/doc/directives.js
var escapeChars = {
  "!": "%21",
  ",": "%2C",
  "[": "%5B",
  "]": "%5D",
  "{": "%7B",
  "}": "%7D"
};
var escapeTagName = (tn) => tn.replace(/[!,[\]{}]/g, (ch) => escapeChars[ch]);
var Directives = class {
  constructor(yaml, tags) {
    this.marker = null;
    this.yaml = Object.assign({}, Directives.defaultYaml, yaml);
    this.tags = Object.assign({}, Directives.defaultTags, tags);
  }
  clone() {
    const copy = new Directives(this.yaml, this.tags);
    copy.marker = this.marker;
    return copy;
  }
  /**
   * During parsing, get a Directives instance for the current document and
   * update the stream state according to the current version's spec.
   */
  atDocument() {
    const res = new Directives(this.yaml, this.tags);
    switch (this.yaml.version) {
      case "1.1":
        this.atNextDocument = true;
        break;
      case "1.2":
        this.atNextDocument = false;
        this.yaml = {
          explicit: Directives.defaultYaml.explicit,
          version: "1.2"
        };
        this.tags = Object.assign({}, Directives.defaultTags);
        break;
    }
    return res;
  }
  /**
   * @param onError - May be called even if the action was successful
   * @returns `true` on success
   */
  add(line, onError) {
    if (this.atNextDocument) {
      this.yaml = { explicit: Directives.defaultYaml.explicit, version: "1.1" };
      this.tags = Object.assign({}, Directives.defaultTags);
      this.atNextDocument = false;
    }
    const parts = line.trim().split(/[ \t]+/);
    const name = parts.shift();
    switch (name) {
      case "%TAG": {
        if (parts.length !== 2) {
          onError(0, "%TAG directive should contain exactly two parts");
          if (parts.length < 2)
            return false;
        }
        const [handle, prefix] = parts;
        this.tags[handle] = prefix;
        return true;
      }
      case "%YAML": {
        this.yaml.explicit = true;
        if (parts.length < 1) {
          onError(0, "%YAML directive should contain exactly one part");
          return false;
        }
        const [version] = parts;
        if (version === "1.1" || version === "1.2") {
          this.yaml.version = version;
          return true;
        } else {
          onError(6, `Unsupported YAML version ${version}`, true);
          return false;
        }
      }
      default:
        onError(0, `Unknown directive ${name}`, true);
        return false;
    }
  }
  /**
   * Resolves a tag, matching handles to those defined in %TAG directives.
   *
   * @returns Resolved tag, which may also be the non-specific tag `'!'` or a
   *   `'!local'` tag, or `null` if unresolvable.
   */
  tagName(source, onError) {
    if (source === "!")
      return "!";
    if (source[0] !== "!") {
      onError(`Not a valid tag: ${source}`);
      return null;
    }
    if (source[1] === "<") {
      const verbatim = source.slice(2, -1);
      if (verbatim === "!" || verbatim === "!!") {
        onError(`Verbatim tags aren't resolved, so ${source} is invalid.`);
        return null;
      }
      if (source[source.length - 1] !== ">")
        onError("Verbatim tags must end with a >");
      return verbatim;
    }
    const [, handle, suffix] = source.match(/^(.*!)([^!]*)$/);
    if (!suffix)
      onError(`The ${source} tag has no suffix`);
    const prefix = this.tags[handle];
    if (prefix)
      return prefix + decodeURIComponent(suffix);
    if (handle === "!")
      return source;
    onError(`Could not resolve tag: ${source}`);
    return null;
  }
  /**
   * Given a fully resolved tag, returns its printable string form,
   * taking into account current tag prefixes and defaults.
   */
  tagString(tag2) {
    for (const [handle, prefix] of Object.entries(this.tags)) {
      if (tag2.startsWith(prefix))
        return handle + escapeTagName(tag2.substring(prefix.length));
    }
    return tag2[0] === "!" ? tag2 : `!<${tag2}>`;
  }
  toString(doc) {
    const lines = this.yaml.explicit ? [`%YAML ${this.yaml.version || "1.2"}`] : [];
    const tagEntries = Object.entries(this.tags);
    let tagNames;
    if (doc && tagEntries.length > 0 && isNode(doc.contents)) {
      const tags = {};
      visit(doc.contents, (_key, node) => {
        if (isNode(node) && node.tag)
          tags[node.tag] = true;
      });
      tagNames = Object.keys(tags);
    } else
      tagNames = [];
    for (const [handle, prefix] of tagEntries) {
      if (handle === "!!" && prefix === "tag:yaml.org,2002:")
        continue;
      if (!doc || tagNames.some((tn) => tn.startsWith(prefix)))
        lines.push(`%TAG ${handle} ${prefix}`);
    }
    return lines.join("\n");
  }
};
Directives.defaultYaml = { explicit: false, version: "1.2" };
Directives.defaultTags = { "!!": "tag:yaml.org,2002:" };

// node_modules/yaml/browser/dist/doc/anchors.js
function anchorIsValid(anchor) {
  if (/[\x00-\x19\s,[\]{}]/.test(anchor)) {
    const sa = JSON.stringify(anchor);
    const msg = `Anchor must not contain whitespace or control characters: ${sa}`;
    throw new Error(msg);
  }
  return true;
}
function anchorNames(root) {
  const anchors = /* @__PURE__ */ new Set();
  visit(root, {
    Value(_key, node) {
      if (node.anchor)
        anchors.add(node.anchor);
    }
  });
  return anchors;
}
function findNewAnchor(prefix, exclude) {
  for (let i = 1; true; ++i) {
    const name = `${prefix}${i}`;
    if (!exclude.has(name))
      return name;
  }
}
function createNodeAnchors(doc, prefix) {
  const aliasObjects = [];
  const sourceObjects = /* @__PURE__ */ new Map();
  let prevAnchors = null;
  return {
    onAnchor(source) {
      aliasObjects.push(source);
      if (!prevAnchors)
        prevAnchors = anchorNames(doc);
      const anchor = findNewAnchor(prefix, prevAnchors);
      prevAnchors.add(anchor);
      return anchor;
    },
    /**
     * With circular references, the source node is only resolved after all
     * of its child nodes are. This is why anchors are set only after all of
     * the nodes have been created.
     */
    setAnchors() {
      for (const source of aliasObjects) {
        const ref = sourceObjects.get(source);
        if (typeof ref === "object" && ref.anchor && (isScalar(ref.node) || isCollection(ref.node))) {
          ref.node.anchor = ref.anchor;
        } else {
          const error = new Error("Failed to resolve repeated object (this should not happen)");
          error.source = source;
          throw error;
        }
      }
    },
    sourceObjects
  };
}

// node_modules/yaml/browser/dist/nodes/Alias.js
var Alias = class extends NodeBase {
  constructor(source) {
    super(ALIAS);
    this.source = source;
    Object.defineProperty(this, "tag", {
      set() {
        throw new Error("Alias nodes cannot have tags");
      }
    });
  }
  /**
   * Resolve the value of this alias within `doc`, finding the last
   * instance of the `source` anchor before this node.
   */
  resolve(doc) {
    let found = void 0;
    visit(doc, {
      Node: (_key, node) => {
        if (node === this)
          return visit.BREAK;
        if (node.anchor === this.source)
          found = node;
      }
    });
    return found;
  }
  toJSON(_arg, ctx) {
    if (!ctx)
      return { source: this.source };
    const { anchors, doc, maxAliasCount } = ctx;
    const source = this.resolve(doc);
    if (!source) {
      const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
      throw new ReferenceError(msg);
    }
    const data = anchors.get(source);
    if (!data || data.res === void 0) {
      const msg = "This should not happen: Alias anchor was not resolved?";
      throw new ReferenceError(msg);
    }
    if (maxAliasCount >= 0) {
      data.count += 1;
      if (data.aliasCount === 0)
        data.aliasCount = getAliasCount(doc, source, anchors);
      if (data.count * data.aliasCount > maxAliasCount) {
        const msg = "Excessive alias count indicates a resource exhaustion attack";
        throw new ReferenceError(msg);
      }
    }
    return data.res;
  }
  toString(ctx, _onComment, _onChompKeep) {
    const src = `*${this.source}`;
    if (ctx) {
      anchorIsValid(this.source);
      if (ctx.options.verifyAliasOrder && !ctx.anchors.has(this.source)) {
        const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
        throw new Error(msg);
      }
      if (ctx.implicitKey)
        return `${src} `;
    }
    return src;
  }
};
function getAliasCount(doc, node, anchors) {
  if (isAlias(node)) {
    const source = node.resolve(doc);
    const anchor = anchors && source && anchors.get(source);
    return anchor ? anchor.count * anchor.aliasCount : 0;
  } else if (isCollection(node)) {
    let count = 0;
    for (const item of node.items) {
      const c = getAliasCount(doc, item, anchors);
      if (c > count)
        count = c;
    }
    return count;
  } else if (isPair(node)) {
    const kc = getAliasCount(doc, node.key, anchors);
    const vc = getAliasCount(doc, node.value, anchors);
    return Math.max(kc, vc);
  }
  return 1;
}

// node_modules/yaml/browser/dist/nodes/toJS.js
function toJS(value, arg, ctx) {
  if (Array.isArray(value))
    return value.map((v, i) => toJS(v, String(i), ctx));
  if (value && typeof value.toJSON === "function") {
    if (!ctx || !hasAnchor(value))
      return value.toJSON(arg, ctx);
    const data = { aliasCount: 0, count: 1, res: void 0 };
    ctx.anchors.set(value, data);
    ctx.onCreate = (res2) => {
      data.res = res2;
      delete ctx.onCreate;
    };
    const res = value.toJSON(arg, ctx);
    if (ctx.onCreate)
      ctx.onCreate(res);
    return res;
  }
  if (typeof value === "bigint" && !(ctx && ctx.keep))
    return Number(value);
  return value;
}

// node_modules/yaml/browser/dist/nodes/Scalar.js
var isScalarValue = (value) => !value || typeof value !== "function" && typeof value !== "object";
var Scalar = class extends NodeBase {
  constructor(value) {
    super(SCALAR);
    this.value = value;
  }
  toJSON(arg, ctx) {
    return ctx && ctx.keep ? this.value : toJS(this.value, arg, ctx);
  }
  toString() {
    return String(this.value);
  }
};
Scalar.BLOCK_FOLDED = "BLOCK_FOLDED";
Scalar.BLOCK_LITERAL = "BLOCK_LITERAL";
Scalar.PLAIN = "PLAIN";
Scalar.QUOTE_DOUBLE = "QUOTE_DOUBLE";
Scalar.QUOTE_SINGLE = "QUOTE_SINGLE";

// node_modules/yaml/browser/dist/doc/createNode.js
var defaultTagPrefix = "tag:yaml.org,2002:";
function findTagObject(value, tagName, tags) {
  if (tagName) {
    const match = tags.filter((t) => t.tag === tagName);
    const tagObj = match.find((t) => !t.format) || match[0];
    if (!tagObj)
      throw new Error(`Tag ${tagName} not found`);
    return tagObj;
  }
  return tags.find((t) => t.identify && t.identify(value) && !t.format);
}
function createNode(value, tagName, ctx) {
  var _a, _b;
  if (isDocument(value))
    value = value.contents;
  if (isNode(value))
    return value;
  if (isPair(value)) {
    const map2 = (_b = (_a = ctx.schema[MAP]).createNode) === null || _b === void 0 ? void 0 : _b.call(_a, ctx.schema, null, ctx);
    map2.items.push(value);
    return map2;
  }
  if (value instanceof String || value instanceof Number || value instanceof Boolean || typeof BigInt === "function" && value instanceof BigInt) {
    value = value.valueOf();
  }
  const { aliasDuplicateObjects, onAnchor, onTagObj, schema: schema4, sourceObjects } = ctx;
  let ref = void 0;
  if (aliasDuplicateObjects && value && typeof value === "object") {
    ref = sourceObjects.get(value);
    if (ref) {
      if (!ref.anchor)
        ref.anchor = onAnchor(value);
      return new Alias(ref.anchor);
    } else {
      ref = { anchor: null, node: null };
      sourceObjects.set(value, ref);
    }
  }
  if (tagName && tagName.startsWith("!!"))
    tagName = defaultTagPrefix + tagName.slice(2);
  let tagObj = findTagObject(value, tagName, schema4.tags);
  if (!tagObj) {
    if (value && typeof value.toJSON === "function")
      value = value.toJSON();
    if (!value || typeof value !== "object") {
      const node2 = new Scalar(value);
      if (ref)
        ref.node = node2;
      return node2;
    }
    tagObj = value instanceof Map ? schema4[MAP] : Symbol.iterator in Object(value) ? schema4[SEQ] : schema4[MAP];
  }
  if (onTagObj) {
    onTagObj(tagObj);
    delete ctx.onTagObj;
  }
  const node = (tagObj === null || tagObj === void 0 ? void 0 : tagObj.createNode) ? tagObj.createNode(ctx.schema, value, ctx) : new Scalar(value);
  if (tagName)
    node.tag = tagName;
  if (ref)
    ref.node = node;
  return node;
}

// node_modules/yaml/browser/dist/nodes/Collection.js
function collectionFromPath(schema4, path, value) {
  let v = value;
  for (let i = path.length - 1; i >= 0; --i) {
    const k = path[i];
    if (typeof k === "number" && Number.isInteger(k) && k >= 0) {
      const a = [];
      a[k] = v;
      v = a;
    } else {
      v = /* @__PURE__ */ new Map([[k, v]]);
    }
  }
  return createNode(v, void 0, {
    aliasDuplicateObjects: false,
    keepUndefined: false,
    onAnchor: () => {
      throw new Error("This should not happen, please report a bug.");
    },
    schema: schema4,
    sourceObjects: /* @__PURE__ */ new Map()
  });
}
var isEmptyPath = (path) => path == null || typeof path === "object" && !!path[Symbol.iterator]().next().done;
var Collection = class extends NodeBase {
  constructor(type, schema4) {
    super(type);
    Object.defineProperty(this, "schema", {
      value: schema4,
      configurable: true,
      enumerable: false,
      writable: true
    });
  }
  /**
   * Create a copy of this collection.
   *
   * @param schema - If defined, overwrites the original's schema
   */
  clone(schema4) {
    const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
    if (schema4)
      copy.schema = schema4;
    copy.items = copy.items.map((it) => isNode(it) || isPair(it) ? it.clone(schema4) : it);
    if (this.range)
      copy.range = this.range.slice();
    return copy;
  }
  /**
   * Adds a value to the collection. For `!!map` and `!!omap` the value must
   * be a Pair instance or a `{ key, value }` object, which may not have a key
   * that already exists in the map.
   */
  addIn(path, value) {
    if (isEmptyPath(path))
      this.add(value);
    else {
      const [key, ...rest] = path;
      const node = this.get(key, true);
      if (isCollection(node))
        node.addIn(rest, value);
      else if (node === void 0 && this.schema)
        this.set(key, collectionFromPath(this.schema, rest, value));
      else
        throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
    }
  }
  /**
   * Removes a value from the collection.
   * @returns `true` if the item was found and removed.
   */
  deleteIn(path) {
    const [key, ...rest] = path;
    if (rest.length === 0)
      return this.delete(key);
    const node = this.get(key, true);
    if (isCollection(node))
      return node.deleteIn(rest);
    else
      throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
  }
  /**
   * Returns item at `key`, or `undefined` if not found. By default unwraps
   * scalar values from their surrounding node; to disable set `keepScalar` to
   * `true` (collections are always returned intact).
   */
  getIn(path, keepScalar) {
    const [key, ...rest] = path;
    const node = this.get(key, true);
    if (rest.length === 0)
      return !keepScalar && isScalar(node) ? node.value : node;
    else
      return isCollection(node) ? node.getIn(rest, keepScalar) : void 0;
  }
  hasAllNullValues(allowScalar) {
    return this.items.every((node) => {
      if (!isPair(node))
        return false;
      const n = node.value;
      return n == null || allowScalar && isScalar(n) && n.value == null && !n.commentBefore && !n.comment && !n.tag;
    });
  }
  /**
   * Checks if the collection includes a value with the key `key`.
   */
  hasIn(path) {
    const [key, ...rest] = path;
    if (rest.length === 0)
      return this.has(key);
    const node = this.get(key, true);
    return isCollection(node) ? node.hasIn(rest) : false;
  }
  /**
   * Sets a value in this collection. For `!!set`, `value` needs to be a
   * boolean to add/remove the item from the set.
   */
  setIn(path, value) {
    const [key, ...rest] = path;
    if (rest.length === 0) {
      this.set(key, value);
    } else {
      const node = this.get(key, true);
      if (isCollection(node))
        node.setIn(rest, value);
      else if (node === void 0 && this.schema)
        this.set(key, collectionFromPath(this.schema, rest, value));
      else
        throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
    }
  }
};
Collection.maxFlowStringSingleLineLength = 60;

// node_modules/yaml/browser/dist/stringify/stringifyComment.js
var stringifyComment = (str) => str.replace(/^(?!$)(?: $)?/gm, "#");
function indentComment(comment, indent) {
  if (/^\n+$/.test(comment))
    return comment.substring(1);
  return indent ? comment.replace(/^(?! *$)/gm, indent) : comment;
}
var lineComment = (str, indent, comment) => comment.includes("\n") ? "\n" + indentComment(comment, indent) : (str.endsWith(" ") ? "" : " ") + comment;

// node_modules/yaml/browser/dist/stringify/foldFlowLines.js
var FOLD_FLOW = "flow";
var FOLD_BLOCK = "block";
var FOLD_QUOTED = "quoted";
function foldFlowLines(text, indent, mode = "flow", { indentAtStart, lineWidth = 80, minContentWidth = 20, onFold, onOverflow } = {}) {
  if (!lineWidth || lineWidth < 0)
    return text;
  const endStep = Math.max(1 + minContentWidth, 1 + lineWidth - indent.length);
  if (text.length <= endStep)
    return text;
  const folds = [];
  const escapedFolds = {};
  let end = lineWidth - indent.length;
  if (typeof indentAtStart === "number") {
    if (indentAtStart > lineWidth - Math.max(2, minContentWidth))
      folds.push(0);
    else
      end = lineWidth - indentAtStart;
  }
  let split = void 0;
  let prev = void 0;
  let overflow = false;
  let i = -1;
  let escStart = -1;
  let escEnd = -1;
  if (mode === FOLD_BLOCK) {
    i = consumeMoreIndentedLines(text, i);
    if (i !== -1)
      end = i + endStep;
  }
  for (let ch; ch = text[i += 1]; ) {
    if (mode === FOLD_QUOTED && ch === "\\") {
      escStart = i;
      switch (text[i + 1]) {
        case "x":
          i += 3;
          break;
        case "u":
          i += 5;
          break;
        case "U":
          i += 9;
          break;
        default:
          i += 1;
      }
      escEnd = i;
    }
    if (ch === "\n") {
      if (mode === FOLD_BLOCK)
        i = consumeMoreIndentedLines(text, i);
      end = i + endStep;
      split = void 0;
    } else {
      if (ch === " " && prev && prev !== " " && prev !== "\n" && prev !== "	") {
        const next = text[i + 1];
        if (next && next !== " " && next !== "\n" && next !== "	")
          split = i;
      }
      if (i >= end) {
        if (split) {
          folds.push(split);
          end = split + endStep;
          split = void 0;
        } else if (mode === FOLD_QUOTED) {
          while (prev === " " || prev === "	") {
            prev = ch;
            ch = text[i += 1];
            overflow = true;
          }
          const j = i > escEnd + 1 ? i - 2 : escStart - 1;
          if (escapedFolds[j])
            return text;
          folds.push(j);
          escapedFolds[j] = true;
          end = j + endStep;
          split = void 0;
        } else {
          overflow = true;
        }
      }
    }
    prev = ch;
  }
  if (overflow && onOverflow)
    onOverflow();
  if (folds.length === 0)
    return text;
  if (onFold)
    onFold();
  let res = text.slice(0, folds[0]);
  for (let i2 = 0; i2 < folds.length; ++i2) {
    const fold = folds[i2];
    const end2 = folds[i2 + 1] || text.length;
    if (fold === 0)
      res = `
${indent}${text.slice(0, end2)}`;
    else {
      if (mode === FOLD_QUOTED && escapedFolds[fold])
        res += `${text[fold]}\\`;
      res += `
${indent}${text.slice(fold + 1, end2)}`;
    }
  }
  return res;
}
function consumeMoreIndentedLines(text, i) {
  let ch = text[i + 1];
  while (ch === " " || ch === "	") {
    do {
      ch = text[i += 1];
    } while (ch && ch !== "\n");
    ch = text[i + 1];
  }
  return i;
}

// node_modules/yaml/browser/dist/stringify/stringifyString.js
var getFoldOptions = (ctx) => ({
  indentAtStart: ctx.indentAtStart,
  lineWidth: ctx.options.lineWidth,
  minContentWidth: ctx.options.minContentWidth
});
var containsDocumentMarker = (str) => /^(%|---|\.\.\.)/m.test(str);
function lineLengthOverLimit(str, lineWidth, indentLength) {
  if (!lineWidth || lineWidth < 0)
    return false;
  const limit = lineWidth - indentLength;
  const strLen = str.length;
  if (strLen <= limit)
    return false;
  for (let i = 0, start = 0; i < strLen; ++i) {
    if (str[i] === "\n") {
      if (i - start > limit)
        return true;
      start = i + 1;
      if (strLen - start <= limit)
        return false;
    }
  }
  return true;
}
function doubleQuotedString(value, ctx) {
  const json = JSON.stringify(value);
  if (ctx.options.doubleQuotedAsJSON)
    return json;
  const { implicitKey } = ctx;
  const minMultiLineLength = ctx.options.doubleQuotedMinMultiLineLength;
  const indent = ctx.indent || (containsDocumentMarker(value) ? "  " : "");
  let str = "";
  let start = 0;
  for (let i = 0, ch = json[i]; ch; ch = json[++i]) {
    if (ch === " " && json[i + 1] === "\\" && json[i + 2] === "n") {
      str += json.slice(start, i) + "\\ ";
      i += 1;
      start = i;
      ch = "\\";
    }
    if (ch === "\\")
      switch (json[i + 1]) {
        case "u":
          {
            str += json.slice(start, i);
            const code = json.substr(i + 2, 4);
            switch (code) {
              case "0000":
                str += "\\0";
                break;
              case "0007":
                str += "\\a";
                break;
              case "000b":
                str += "\\v";
                break;
              case "001b":
                str += "\\e";
                break;
              case "0085":
                str += "\\N";
                break;
              case "00a0":
                str += "\\_";
                break;
              case "2028":
                str += "\\L";
                break;
              case "2029":
                str += "\\P";
                break;
              default:
                if (code.substr(0, 2) === "00")
                  str += "\\x" + code.substr(2);
                else
                  str += json.substr(i, 6);
            }
            i += 5;
            start = i + 1;
          }
          break;
        case "n":
          if (implicitKey || json[i + 2] === '"' || json.length < minMultiLineLength) {
            i += 1;
          } else {
            str += json.slice(start, i) + "\n\n";
            while (json[i + 2] === "\\" && json[i + 3] === "n" && json[i + 4] !== '"') {
              str += "\n";
              i += 2;
            }
            str += indent;
            if (json[i + 2] === " ")
              str += "\\";
            i += 1;
            start = i + 1;
          }
          break;
        default:
          i += 1;
      }
  }
  str = start ? str + json.slice(start) : json;
  return implicitKey ? str : foldFlowLines(str, indent, FOLD_QUOTED, getFoldOptions(ctx));
}
function singleQuotedString(value, ctx) {
  if (ctx.options.singleQuote === false || ctx.implicitKey && value.includes("\n") || /[ \t]\n|\n[ \t]/.test(value))
    return doubleQuotedString(value, ctx);
  const indent = ctx.indent || (containsDocumentMarker(value) ? "  " : "");
  const res = "'" + value.replace(/'/g, "''").replace(/\n+/g, `$&
${indent}`) + "'";
  return ctx.implicitKey ? res : foldFlowLines(res, indent, FOLD_FLOW, getFoldOptions(ctx));
}
function quotedString(value, ctx) {
  const { singleQuote } = ctx.options;
  let qs;
  if (singleQuote === false)
    qs = doubleQuotedString;
  else {
    const hasDouble = value.includes('"');
    const hasSingle = value.includes("'");
    if (hasDouble && !hasSingle)
      qs = singleQuotedString;
    else if (hasSingle && !hasDouble)
      qs = doubleQuotedString;
    else
      qs = singleQuote ? singleQuotedString : doubleQuotedString;
  }
  return qs(value, ctx);
}
function blockString({ comment, type, value }, ctx, onComment, onChompKeep) {
  const { blockQuote, commentString, lineWidth } = ctx.options;
  if (!blockQuote || /\n[\t ]+$/.test(value) || /^\s*$/.test(value)) {
    return quotedString(value, ctx);
  }
  const indent = ctx.indent || (ctx.forceBlockIndent || containsDocumentMarker(value) ? "  " : "");
  const literal = blockQuote === "literal" ? true : blockQuote === "folded" || type === Scalar.BLOCK_FOLDED ? false : type === Scalar.BLOCK_LITERAL ? true : !lineLengthOverLimit(value, lineWidth, indent.length);
  if (!value)
    return literal ? "|\n" : ">\n";
  let chomp;
  let endStart;
  for (endStart = value.length; endStart > 0; --endStart) {
    const ch = value[endStart - 1];
    if (ch !== "\n" && ch !== "	" && ch !== " ")
      break;
  }
  let end = value.substring(endStart);
  const endNlPos = end.indexOf("\n");
  if (endNlPos === -1) {
    chomp = "-";
  } else if (value === end || endNlPos !== end.length - 1) {
    chomp = "+";
    if (onChompKeep)
      onChompKeep();
  } else {
    chomp = "";
  }
  if (end) {
    value = value.slice(0, -end.length);
    if (end[end.length - 1] === "\n")
      end = end.slice(0, -1);
    end = end.replace(/\n+(?!\n|$)/g, `$&${indent}`);
  }
  let startWithSpace = false;
  let startEnd;
  let startNlPos = -1;
  for (startEnd = 0; startEnd < value.length; ++startEnd) {
    const ch = value[startEnd];
    if (ch === " ")
      startWithSpace = true;
    else if (ch === "\n")
      startNlPos = startEnd;
    else
      break;
  }
  let start = value.substring(0, startNlPos < startEnd ? startNlPos + 1 : startEnd);
  if (start) {
    value = value.substring(start.length);
    start = start.replace(/\n+/g, `$&${indent}`);
  }
  const indentSize = indent ? "2" : "1";
  let header = (literal ? "|" : ">") + (startWithSpace ? indentSize : "") + chomp;
  if (comment) {
    header += " " + commentString(comment.replace(/ ?[\r\n]+/g, " "));
    if (onComment)
      onComment();
  }
  if (literal) {
    value = value.replace(/\n+/g, `$&${indent}`);
    return `${header}
${indent}${start}${value}${end}`;
  }
  value = value.replace(/\n+/g, "\n$&").replace(/(?:^|\n)([\t ].*)(?:([\n\t ]*)\n(?![\n\t ]))?/g, "$1$2").replace(/\n+/g, `$&${indent}`);
  const body = foldFlowLines(`${start}${value}${end}`, indent, FOLD_BLOCK, getFoldOptions(ctx));
  return `${header}
${indent}${body}`;
}
function plainString(item, ctx, onComment, onChompKeep) {
  const { type, value } = item;
  const { actualString, implicitKey, indent, inFlow } = ctx;
  if (implicitKey && /[\n[\]{},]/.test(value) || inFlow && /[[\]{},]/.test(value)) {
    return quotedString(value, ctx);
  }
  if (!value || /^[\n\t ,[\]{}#&*!|>'"%@`]|^[?-]$|^[?-][ \t]|[\n:][ \t]|[ \t]\n|[\n\t ]#|[\n\t :]$/.test(value)) {
    return implicitKey || inFlow || value.indexOf("\n") === -1 ? quotedString(value, ctx) : blockString(item, ctx, onComment, onChompKeep);
  }
  if (!implicitKey && !inFlow && type !== Scalar.PLAIN && value.indexOf("\n") !== -1) {
    return blockString(item, ctx, onComment, onChompKeep);
  }
  if (indent === "" && containsDocumentMarker(value)) {
    ctx.forceBlockIndent = true;
    return blockString(item, ctx, onComment, onChompKeep);
  }
  const str = value.replace(/\n+/g, `$&
${indent}`);
  if (actualString) {
    const test = (tag2) => {
      var _a;
      return tag2.default && tag2.tag !== "tag:yaml.org,2002:str" && ((_a = tag2.test) === null || _a === void 0 ? void 0 : _a.test(str));
    };
    const { compat, tags } = ctx.doc.schema;
    if (tags.some(test) || (compat === null || compat === void 0 ? void 0 : compat.some(test)))
      return quotedString(value, ctx);
  }
  return implicitKey ? str : foldFlowLines(str, indent, FOLD_FLOW, getFoldOptions(ctx));
}
function stringifyString(item, ctx, onComment, onChompKeep) {
  const { implicitKey, inFlow } = ctx;
  const ss = typeof item.value === "string" ? item : Object.assign({}, item, { value: String(item.value) });
  let { type } = item;
  if (type !== Scalar.QUOTE_DOUBLE) {
    if (/[\x00-\x08\x0b-\x1f\x7f-\x9f\u{D800}-\u{DFFF}]/u.test(ss.value))
      type = Scalar.QUOTE_DOUBLE;
  }
  const _stringify = (_type) => {
    switch (_type) {
      case Scalar.BLOCK_FOLDED:
      case Scalar.BLOCK_LITERAL:
        return implicitKey || inFlow ? quotedString(ss.value, ctx) : blockString(ss, ctx, onComment, onChompKeep);
      case Scalar.QUOTE_DOUBLE:
        return doubleQuotedString(ss.value, ctx);
      case Scalar.QUOTE_SINGLE:
        return singleQuotedString(ss.value, ctx);
      case Scalar.PLAIN:
        return plainString(ss, ctx, onComment, onChompKeep);
      default:
        return null;
    }
  };
  let res = _stringify(type);
  if (res === null) {
    const { defaultKeyType, defaultStringType } = ctx.options;
    const t = implicitKey && defaultKeyType || defaultStringType;
    res = _stringify(t);
    if (res === null)
      throw new Error(`Unsupported default string type ${t}`);
  }
  return res;
}

// node_modules/yaml/browser/dist/stringify/stringify.js
function createStringifyContext(doc, options) {
  const opt = Object.assign({
    blockQuote: true,
    commentString: stringifyComment,
    defaultKeyType: null,
    defaultStringType: "PLAIN",
    directives: null,
    doubleQuotedAsJSON: false,
    doubleQuotedMinMultiLineLength: 40,
    falseStr: "false",
    indentSeq: true,
    lineWidth: 80,
    minContentWidth: 20,
    nullStr: "null",
    simpleKeys: false,
    singleQuote: null,
    trueStr: "true",
    verifyAliasOrder: true
  }, doc.schema.toStringOptions, options);
  let inFlow;
  switch (opt.collectionStyle) {
    case "block":
      inFlow = false;
      break;
    case "flow":
      inFlow = true;
      break;
    default:
      inFlow = null;
  }
  return {
    anchors: /* @__PURE__ */ new Set(),
    doc,
    indent: "",
    indentStep: typeof opt.indent === "number" ? " ".repeat(opt.indent) : "  ",
    inFlow,
    options: opt
  };
}
function getTagObject(tags, item) {
  if (item.tag) {
    const match = tags.filter((t) => t.tag === item.tag);
    if (match.length > 0)
      return match.find((t) => t.format === item.format) || match[0];
  }
  let tagObj = void 0;
  let obj;
  if (isScalar(item)) {
    obj = item.value;
    const match = tags.filter((t) => t.identify && t.identify(obj));
    tagObj = match.find((t) => t.format === item.format) || match.find((t) => !t.format);
  } else {
    obj = item;
    tagObj = tags.find((t) => t.nodeClass && obj instanceof t.nodeClass);
  }
  if (!tagObj) {
    const name = obj && obj.constructor ? obj.constructor.name : typeof obj;
    throw new Error(`Tag not resolved for ${name} value`);
  }
  return tagObj;
}
function stringifyProps(node, tagObj, { anchors, doc }) {
  if (!doc.directives)
    return "";
  const props = [];
  const anchor = (isScalar(node) || isCollection(node)) && node.anchor;
  if (anchor && anchorIsValid(anchor)) {
    anchors.add(anchor);
    props.push(`&${anchor}`);
  }
  const tag2 = node.tag || (tagObj.default ? null : tagObj.tag);
  if (tag2)
    props.push(doc.directives.tagString(tag2));
  return props.join(" ");
}
function stringify(item, ctx, onComment, onChompKeep) {
  var _a;
  if (isPair(item))
    return item.toString(ctx, onComment, onChompKeep);
  if (isAlias(item)) {
    if (ctx.doc.directives)
      return item.toString(ctx);
    if ((_a = ctx.resolvedAliases) === null || _a === void 0 ? void 0 : _a.has(item)) {
      throw new TypeError(`Cannot stringify circular structure without alias nodes`);
    } else {
      if (ctx.resolvedAliases)
        ctx.resolvedAliases.add(item);
      else
        ctx.resolvedAliases = /* @__PURE__ */ new Set([item]);
      item = item.resolve(ctx.doc);
    }
  }
  let tagObj = void 0;
  const node = isNode(item) ? item : ctx.doc.createNode(item, { onTagObj: (o) => tagObj = o });
  if (!tagObj)
    tagObj = getTagObject(ctx.doc.schema.tags, node);
  const props = stringifyProps(node, tagObj, ctx);
  if (props.length > 0)
    ctx.indentAtStart = (ctx.indentAtStart || 0) + props.length + 1;
  const str = typeof tagObj.stringify === "function" ? tagObj.stringify(node, ctx, onComment, onChompKeep) : isScalar(node) ? stringifyString(node, ctx, onComment, onChompKeep) : node.toString(ctx, onComment, onChompKeep);
  if (!props)
    return str;
  return isScalar(node) || str[0] === "{" || str[0] === "[" ? `${props} ${str}` : `${props}
${ctx.indent}${str}`;
}

// node_modules/yaml/browser/dist/stringify/stringifyPair.js
function stringifyPair({ key, value }, ctx, onComment, onChompKeep) {
  const { allNullValues, doc, indent, indentStep, options: { commentString, indentSeq, simpleKeys } } = ctx;
  let keyComment = isNode(key) && key.comment || null;
  if (simpleKeys) {
    if (keyComment) {
      throw new Error("With simple keys, key nodes cannot have comments");
    }
    if (isCollection(key)) {
      const msg = "With simple keys, collection cannot be used as a key value";
      throw new Error(msg);
    }
  }
  let explicitKey = !simpleKeys && (!key || keyComment && value == null && !ctx.inFlow || isCollection(key) || (isScalar(key) ? key.type === Scalar.BLOCK_FOLDED || key.type === Scalar.BLOCK_LITERAL : typeof key === "object"));
  ctx = Object.assign({}, ctx, {
    allNullValues: false,
    implicitKey: !explicitKey && (simpleKeys || !allNullValues),
    indent: indent + indentStep
  });
  let keyCommentDone = false;
  let chompKeep = false;
  let str = stringify(key, ctx, () => keyCommentDone = true, () => chompKeep = true);
  if (!explicitKey && !ctx.inFlow && str.length > 1024) {
    if (simpleKeys)
      throw new Error("With simple keys, single line scalar must not span more than 1024 characters");
    explicitKey = true;
  }
  if (ctx.inFlow) {
    if (allNullValues || value == null) {
      if (keyCommentDone && onComment)
        onComment();
      return explicitKey ? `? ${str}` : str;
    }
  } else if (allNullValues && !simpleKeys || value == null && explicitKey) {
    str = `? ${str}`;
    if (keyComment && !keyCommentDone) {
      str += lineComment(str, ctx.indent, commentString(keyComment));
    } else if (chompKeep && onChompKeep)
      onChompKeep();
    return str;
  }
  if (keyCommentDone)
    keyComment = null;
  if (explicitKey) {
    if (keyComment)
      str += lineComment(str, ctx.indent, commentString(keyComment));
    str = `? ${str}
${indent}:`;
  } else {
    str = `${str}:`;
    if (keyComment)
      str += lineComment(str, ctx.indent, commentString(keyComment));
  }
  let vcb = "";
  let valueComment = null;
  if (isNode(value)) {
    if (value.spaceBefore)
      vcb = "\n";
    if (value.commentBefore) {
      const cs = commentString(value.commentBefore);
      vcb += `
${indentComment(cs, ctx.indent)}`;
    }
    valueComment = value.comment;
  } else if (value && typeof value === "object") {
    value = doc.createNode(value);
  }
  ctx.implicitKey = false;
  if (!explicitKey && !keyComment && isScalar(value))
    ctx.indentAtStart = str.length + 1;
  chompKeep = false;
  if (!indentSeq && indentStep.length >= 2 && !ctx.inFlow && !explicitKey && isSeq(value) && !value.flow && !value.tag && !value.anchor) {
    ctx.indent = ctx.indent.substr(2);
  }
  let valueCommentDone = false;
  const valueStr = stringify(value, ctx, () => valueCommentDone = true, () => chompKeep = true);
  let ws = " ";
  if (vcb || keyComment) {
    ws = valueStr === "" && !ctx.inFlow ? vcb : `${vcb}
${ctx.indent}`;
  } else if (!explicitKey && isCollection(value)) {
    const flow = valueStr[0] === "[" || valueStr[0] === "{";
    if (!flow || valueStr.includes("\n"))
      ws = `
${ctx.indent}`;
  } else if (valueStr === "" || valueStr[0] === "\n")
    ws = "";
  str += ws + valueStr;
  if (ctx.inFlow) {
    if (valueCommentDone && onComment)
      onComment();
  } else if (valueComment && !valueCommentDone) {
    str += lineComment(str, ctx.indent, commentString(valueComment));
  } else if (chompKeep && onChompKeep) {
    onChompKeep();
  }
  return str;
}

// node_modules/yaml/browser/dist/log.js
function warn(logLevel, warning) {
  if (logLevel === "debug" || logLevel === "warn") {
    if (typeof process !== "undefined" && process.emitWarning)
      process.emitWarning(warning);
    else
      console.warn(warning);
  }
}

// node_modules/yaml/browser/dist/nodes/addPairToJSMap.js
var MERGE_KEY = "<<";
function addPairToJSMap(ctx, map2, { key, value }) {
  if (ctx && ctx.doc.schema.merge && isMergeKey(key)) {
    value = isAlias(value) ? value.resolve(ctx.doc) : value;
    if (isSeq(value))
      for (const it of value.items)
        mergeToJSMap(ctx, map2, it);
    else if (Array.isArray(value))
      for (const it of value)
        mergeToJSMap(ctx, map2, it);
    else
      mergeToJSMap(ctx, map2, value);
  } else {
    const jsKey = toJS(key, "", ctx);
    if (map2 instanceof Map) {
      map2.set(jsKey, toJS(value, jsKey, ctx));
    } else if (map2 instanceof Set) {
      map2.add(jsKey);
    } else {
      const stringKey = stringifyKey(key, jsKey, ctx);
      const jsValue = toJS(value, stringKey, ctx);
      if (stringKey in map2)
        Object.defineProperty(map2, stringKey, {
          value: jsValue,
          writable: true,
          enumerable: true,
          configurable: true
        });
      else
        map2[stringKey] = jsValue;
    }
  }
  return map2;
}
var isMergeKey = (key) => key === MERGE_KEY || isScalar(key) && key.value === MERGE_KEY && (!key.type || key.type === Scalar.PLAIN);
function mergeToJSMap(ctx, map2, value) {
  const source = ctx && isAlias(value) ? value.resolve(ctx.doc) : value;
  if (!isMap(source))
    throw new Error("Merge sources must be maps or map aliases");
  const srcMap = source.toJSON(null, ctx, Map);
  for (const [key, value2] of srcMap) {
    if (map2 instanceof Map) {
      if (!map2.has(key))
        map2.set(key, value2);
    } else if (map2 instanceof Set) {
      map2.add(key);
    } else if (!Object.prototype.hasOwnProperty.call(map2, key)) {
      Object.defineProperty(map2, key, {
        value: value2,
        writable: true,
        enumerable: true,
        configurable: true
      });
    }
  }
  return map2;
}
function stringifyKey(key, jsKey, ctx) {
  if (jsKey === null)
    return "";
  if (typeof jsKey !== "object")
    return String(jsKey);
  if (isNode(key) && ctx && ctx.doc) {
    const strCtx = createStringifyContext(ctx.doc, {});
    strCtx.anchors = /* @__PURE__ */ new Set();
    for (const node of ctx.anchors.keys())
      strCtx.anchors.add(node.anchor);
    strCtx.inFlow = true;
    strCtx.inStringifyKey = true;
    const strKey = key.toString(strCtx);
    if (!ctx.mapKeyWarned) {
      let jsonStr = JSON.stringify(strKey);
      if (jsonStr.length > 40)
        jsonStr = jsonStr.substring(0, 36) + '..."';
      warn(ctx.doc.options.logLevel, `Keys with collection values will be stringified due to JS Object restrictions: ${jsonStr}. Set mapAsMap: true to use object keys.`);
      ctx.mapKeyWarned = true;
    }
    return strKey;
  }
  return JSON.stringify(jsKey);
}

// node_modules/yaml/browser/dist/nodes/Pair.js
function createPair(key, value, ctx) {
  const k = createNode(key, void 0, ctx);
  const v = createNode(value, void 0, ctx);
  return new Pair(k, v);
}
var Pair = class {
  constructor(key, value = null) {
    Object.defineProperty(this, NODE_TYPE, { value: PAIR });
    this.key = key;
    this.value = value;
  }
  clone(schema4) {
    let { key, value } = this;
    if (isNode(key))
      key = key.clone(schema4);
    if (isNode(value))
      value = value.clone(schema4);
    return new Pair(key, value);
  }
  toJSON(_, ctx) {
    const pair = ctx && ctx.mapAsMap ? /* @__PURE__ */ new Map() : {};
    return addPairToJSMap(ctx, pair, this);
  }
  toString(ctx, onComment, onChompKeep) {
    return ctx && ctx.doc ? stringifyPair(this, ctx, onComment, onChompKeep) : JSON.stringify(this);
  }
};

// node_modules/yaml/browser/dist/options.js
var defaultOptions = {
  intAsBigInt: false,
  keepSourceTokens: false,
  logLevel: "warn",
  prettyErrors: true,
  strict: true,
  uniqueKeys: true,
  version: "1.2"
};

// node_modules/yaml/browser/dist/stringify/stringifyCollection.js
function stringifyCollection(collection, ctx, options) {
  var _a;
  const flow = (_a = ctx.inFlow) !== null && _a !== void 0 ? _a : collection.flow;
  const stringify4 = flow ? stringifyFlowCollection : stringifyBlockCollection;
  return stringify4(collection, ctx, options);
}
function stringifyBlockCollection({ comment, items }, ctx, { blockItemPrefix, flowChars, itemIndent, onChompKeep, onComment }) {
  const { indent, options: { commentString } } = ctx;
  const itemCtx = Object.assign({}, ctx, { indent: itemIndent, type: null });
  let chompKeep = false;
  const lines = [];
  for (let i = 0; i < items.length; ++i) {
    const item = items[i];
    let comment2 = null;
    if (isNode(item)) {
      if (!chompKeep && item.spaceBefore)
        lines.push("");
      addCommentBefore(ctx, lines, item.commentBefore, chompKeep);
      if (item.comment)
        comment2 = item.comment;
    } else if (isPair(item)) {
      const ik = isNode(item.key) ? item.key : null;
      if (ik) {
        if (!chompKeep && ik.spaceBefore)
          lines.push("");
        addCommentBefore(ctx, lines, ik.commentBefore, chompKeep);
      }
    }
    chompKeep = false;
    let str2 = stringify(item, itemCtx, () => comment2 = null, () => chompKeep = true);
    if (comment2)
      str2 += lineComment(str2, itemIndent, commentString(comment2));
    if (chompKeep && comment2)
      chompKeep = false;
    lines.push(blockItemPrefix + str2);
  }
  let str;
  if (lines.length === 0) {
    str = flowChars.start + flowChars.end;
  } else {
    str = lines[0];
    for (let i = 1; i < lines.length; ++i) {
      const line = lines[i];
      str += line ? `
${indent}${line}` : "\n";
    }
  }
  if (comment) {
    str += "\n" + indentComment(commentString(comment), indent);
    if (onComment)
      onComment();
  } else if (chompKeep && onChompKeep)
    onChompKeep();
  return str;
}
function stringifyFlowCollection({ comment, items }, ctx, { flowChars, itemIndent, onComment }) {
  const { indent, indentStep, options: { commentString } } = ctx;
  itemIndent += indentStep;
  const itemCtx = Object.assign({}, ctx, {
    indent: itemIndent,
    inFlow: true,
    type: null
  });
  let reqNewline = false;
  let linesAtValue = 0;
  const lines = [];
  for (let i = 0; i < items.length; ++i) {
    const item = items[i];
    let comment2 = null;
    if (isNode(item)) {
      if (item.spaceBefore)
        lines.push("");
      addCommentBefore(ctx, lines, item.commentBefore, false);
      if (item.comment)
        comment2 = item.comment;
    } else if (isPair(item)) {
      const ik = isNode(item.key) ? item.key : null;
      if (ik) {
        if (ik.spaceBefore)
          lines.push("");
        addCommentBefore(ctx, lines, ik.commentBefore, false);
        if (ik.comment)
          reqNewline = true;
      }
      const iv = isNode(item.value) ? item.value : null;
      if (iv) {
        if (iv.comment)
          comment2 = iv.comment;
        if (iv.commentBefore)
          reqNewline = true;
      } else if (item.value == null && ik && ik.comment) {
        comment2 = ik.comment;
      }
    }
    if (comment2)
      reqNewline = true;
    let str2 = stringify(item, itemCtx, () => comment2 = null);
    if (i < items.length - 1)
      str2 += ",";
    if (comment2)
      str2 += lineComment(str2, itemIndent, commentString(comment2));
    if (!reqNewline && (lines.length > linesAtValue || str2.includes("\n")))
      reqNewline = true;
    lines.push(str2);
    linesAtValue = lines.length;
  }
  let str;
  const { start, end } = flowChars;
  if (lines.length === 0) {
    str = start + end;
  } else {
    if (!reqNewline) {
      const len = lines.reduce((sum, line) => sum + line.length + 2, 2);
      reqNewline = len > Collection.maxFlowStringSingleLineLength;
    }
    if (reqNewline) {
      str = start;
      for (const line of lines)
        str += line ? `
${indentStep}${indent}${line}` : "\n";
      str += `
${indent}${end}`;
    } else {
      str = `${start} ${lines.join(" ")} ${end}`;
    }
  }
  if (comment) {
    str += lineComment(str, commentString(comment), indent);
    if (onComment)
      onComment();
  }
  return str;
}
function addCommentBefore({ indent, options: { commentString } }, lines, comment, chompKeep) {
  if (comment && chompKeep)
    comment = comment.replace(/^\n+/, "");
  if (comment) {
    const ic = indentComment(commentString(comment), indent);
    lines.push(ic.trimStart());
  }
}

// node_modules/yaml/browser/dist/nodes/YAMLMap.js
function findPair(items, key) {
  const k = isScalar(key) ? key.value : key;
  for (const it of items) {
    if (isPair(it)) {
      if (it.key === key || it.key === k)
        return it;
      if (isScalar(it.key) && it.key.value === k)
        return it;
    }
  }
  return void 0;
}
var YAMLMap = class extends Collection {
  constructor(schema4) {
    super(MAP, schema4);
    this.items = [];
  }
  static get tagName() {
    return "tag:yaml.org,2002:map";
  }
  /**
   * Adds a value to the collection.
   *
   * @param overwrite - If not set `true`, using a key that is already in the
   *   collection will throw. Otherwise, overwrites the previous value.
   */
  add(pair, overwrite) {
    let _pair;
    if (isPair(pair))
      _pair = pair;
    else if (!pair || typeof pair !== "object" || !("key" in pair)) {
      _pair = new Pair(pair, pair.value);
    } else
      _pair = new Pair(pair.key, pair.value);
    const prev = findPair(this.items, _pair.key);
    const sortEntries = this.schema && this.schema.sortMapEntries;
    if (prev) {
      if (!overwrite)
        throw new Error(`Key ${_pair.key} already set`);
      if (isScalar(prev.value) && isScalarValue(_pair.value))
        prev.value.value = _pair.value;
      else
        prev.value = _pair.value;
    } else if (sortEntries) {
      const i = this.items.findIndex((item) => sortEntries(_pair, item) < 0);
      if (i === -1)
        this.items.push(_pair);
      else
        this.items.splice(i, 0, _pair);
    } else {
      this.items.push(_pair);
    }
  }
  delete(key) {
    const it = findPair(this.items, key);
    if (!it)
      return false;
    const del = this.items.splice(this.items.indexOf(it), 1);
    return del.length > 0;
  }
  get(key, keepScalar) {
    const it = findPair(this.items, key);
    const node = it && it.value;
    return !keepScalar && isScalar(node) ? node.value : node;
  }
  has(key) {
    return !!findPair(this.items, key);
  }
  set(key, value) {
    this.add(new Pair(key, value), true);
  }
  /**
   * @param ctx - Conversion context, originally set in Document#toJS()
   * @param {Class} Type - If set, forces the returned collection type
   * @returns Instance of Type, Map, or Object
   */
  toJSON(_, ctx, Type) {
    const map2 = Type ? new Type() : ctx && ctx.mapAsMap ? /* @__PURE__ */ new Map() : {};
    if (ctx && ctx.onCreate)
      ctx.onCreate(map2);
    for (const item of this.items)
      addPairToJSMap(ctx, map2, item);
    return map2;
  }
  toString(ctx, onComment, onChompKeep) {
    if (!ctx)
      return JSON.stringify(this);
    for (const item of this.items) {
      if (!isPair(item))
        throw new Error(`Map items must all be pairs; found ${JSON.stringify(item)} instead`);
    }
    if (!ctx.allNullValues && this.hasAllNullValues(false))
      ctx = Object.assign({}, ctx, { allNullValues: true });
    return stringifyCollection(this, ctx, {
      blockItemPrefix: "",
      flowChars: { start: "{", end: "}" },
      itemIndent: ctx.indent || "",
      onChompKeep,
      onComment
    });
  }
};

// node_modules/yaml/browser/dist/schema/common/map.js
function createMap(schema4, obj, ctx) {
  const { keepUndefined, replacer } = ctx;
  const map2 = new YAMLMap(schema4);
  const add = (key, value) => {
    if (typeof replacer === "function")
      value = replacer.call(obj, key, value);
    else if (Array.isArray(replacer) && !replacer.includes(key))
      return;
    if (value !== void 0 || keepUndefined)
      map2.items.push(createPair(key, value, ctx));
  };
  if (obj instanceof Map) {
    for (const [key, value] of obj)
      add(key, value);
  } else if (obj && typeof obj === "object") {
    for (const key of Object.keys(obj))
      add(key, obj[key]);
  }
  if (typeof schema4.sortMapEntries === "function") {
    map2.items.sort(schema4.sortMapEntries);
  }
  return map2;
}
var map = {
  collection: "map",
  createNode: createMap,
  default: true,
  nodeClass: YAMLMap,
  tag: "tag:yaml.org,2002:map",
  resolve(map2, onError) {
    if (!isMap(map2))
      onError("Expected a mapping for this tag");
    return map2;
  }
};

// node_modules/yaml/browser/dist/nodes/YAMLSeq.js
var YAMLSeq = class extends Collection {
  constructor(schema4) {
    super(SEQ, schema4);
    this.items = [];
  }
  static get tagName() {
    return "tag:yaml.org,2002:seq";
  }
  add(value) {
    this.items.push(value);
  }
  /**
   * Removes a value from the collection.
   *
   * `key` must contain a representation of an integer for this to succeed.
   * It may be wrapped in a `Scalar`.
   *
   * @returns `true` if the item was found and removed.
   */
  delete(key) {
    const idx = asItemIndex(key);
    if (typeof idx !== "number")
      return false;
    const del = this.items.splice(idx, 1);
    return del.length > 0;
  }
  /**
   * Returns item at `key`, or `undefined` if not found. By default unwraps
   * scalar values from their surrounding node; to disable set `keepScalar` to
   * `true` (collections are always returned intact).
   *
   * `key` must contain a representation of an integer for this to succeed.
   * It may be wrapped in a `Scalar`.
   */
  get(key, keepScalar) {
    const idx = asItemIndex(key);
    if (typeof idx !== "number")
      return void 0;
    const it = this.items[idx];
    return !keepScalar && isScalar(it) ? it.value : it;
  }
  /**
   * Checks if the collection includes a value with the key `key`.
   *
   * `key` must contain a representation of an integer for this to succeed.
   * It may be wrapped in a `Scalar`.
   */
  has(key) {
    const idx = asItemIndex(key);
    return typeof idx === "number" && idx < this.items.length;
  }
  /**
   * Sets a value in this collection. For `!!set`, `value` needs to be a
   * boolean to add/remove the item from the set.
   *
   * If `key` does not contain a representation of an integer, this will throw.
   * It may be wrapped in a `Scalar`.
   */
  set(key, value) {
    const idx = asItemIndex(key);
    if (typeof idx !== "number")
      throw new Error(`Expected a valid index, not ${key}.`);
    const prev = this.items[idx];
    if (isScalar(prev) && isScalarValue(value))
      prev.value = value;
    else
      this.items[idx] = value;
  }
  toJSON(_, ctx) {
    const seq2 = [];
    if (ctx && ctx.onCreate)
      ctx.onCreate(seq2);
    let i = 0;
    for (const item of this.items)
      seq2.push(toJS(item, String(i++), ctx));
    return seq2;
  }
  toString(ctx, onComment, onChompKeep) {
    if (!ctx)
      return JSON.stringify(this);
    return stringifyCollection(this, ctx, {
      blockItemPrefix: "- ",
      flowChars: { start: "[", end: "]" },
      itemIndent: (ctx.indent || "") + "  ",
      onChompKeep,
      onComment
    });
  }
};
function asItemIndex(key) {
  let idx = isScalar(key) ? key.value : key;
  if (idx && typeof idx === "string")
    idx = Number(idx);
  return typeof idx === "number" && Number.isInteger(idx) && idx >= 0 ? idx : null;
}

// node_modules/yaml/browser/dist/schema/common/seq.js
function createSeq(schema4, obj, ctx) {
  const { replacer } = ctx;
  const seq2 = new YAMLSeq(schema4);
  if (obj && Symbol.iterator in Object(obj)) {
    let i = 0;
    for (let it of obj) {
      if (typeof replacer === "function") {
        const key = obj instanceof Set ? it : String(i++);
        it = replacer.call(obj, key, it);
      }
      seq2.items.push(createNode(it, void 0, ctx));
    }
  }
  return seq2;
}
var seq = {
  collection: "seq",
  createNode: createSeq,
  default: true,
  nodeClass: YAMLSeq,
  tag: "tag:yaml.org,2002:seq",
  resolve(seq2, onError) {
    if (!isSeq(seq2))
      onError("Expected a sequence for this tag");
    return seq2;
  }
};

// node_modules/yaml/browser/dist/schema/common/string.js
var string = {
  identify: (value) => typeof value === "string",
  default: true,
  tag: "tag:yaml.org,2002:str",
  resolve: (str) => str,
  stringify(item, ctx, onComment, onChompKeep) {
    ctx = Object.assign({ actualString: true }, ctx);
    return stringifyString(item, ctx, onComment, onChompKeep);
  }
};

// node_modules/yaml/browser/dist/schema/common/null.js
var nullTag = {
  identify: (value) => value == null,
  createNode: () => new Scalar(null),
  default: true,
  tag: "tag:yaml.org,2002:null",
  test: /^(?:~|[Nn]ull|NULL)?$/,
  resolve: () => new Scalar(null),
  stringify: ({ source }, ctx) => source && nullTag.test.test(source) ? source : ctx.options.nullStr
};

// node_modules/yaml/browser/dist/schema/core/bool.js
var boolTag = {
  identify: (value) => typeof value === "boolean",
  default: true,
  tag: "tag:yaml.org,2002:bool",
  test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,
  resolve: (str) => new Scalar(str[0] === "t" || str[0] === "T"),
  stringify({ source, value }, ctx) {
    if (source && boolTag.test.test(source)) {
      const sv = source[0] === "t" || source[0] === "T";
      if (value === sv)
        return source;
    }
    return value ? ctx.options.trueStr : ctx.options.falseStr;
  }
};

// node_modules/yaml/browser/dist/stringify/stringifyNumber.js
function stringifyNumber({ format, minFractionDigits, tag: tag2, value }) {
  if (typeof value === "bigint")
    return String(value);
  const num = typeof value === "number" ? value : Number(value);
  if (!isFinite(num))
    return isNaN(num) ? ".nan" : num < 0 ? "-.inf" : ".inf";
  let n = JSON.stringify(value);
  if (!format && minFractionDigits && (!tag2 || tag2 === "tag:yaml.org,2002:float") && /^\d/.test(n)) {
    let i = n.indexOf(".");
    if (i < 0) {
      i = n.length;
      n += ".";
    }
    let d = minFractionDigits - (n.length - i - 1);
    while (d-- > 0)
      n += "0";
  }
  return n;
}

// node_modules/yaml/browser/dist/schema/core/float.js
var floatNaN = {
  identify: (value) => typeof value === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  test: /^(?:[-+]?\.(?:inf|Inf|INF|nan|NaN|NAN))$/,
  resolve: (str) => str.slice(-3).toLowerCase() === "nan" ? NaN : str[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
  stringify: stringifyNumber
};
var floatExp = {
  identify: (value) => typeof value === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  format: "EXP",
  test: /^[-+]?(?:\.[0-9]+|[0-9]+(?:\.[0-9]*)?)[eE][-+]?[0-9]+$/,
  resolve: (str) => parseFloat(str),
  stringify(node) {
    const num = Number(node.value);
    return isFinite(num) ? num.toExponential() : stringifyNumber(node);
  }
};
var float = {
  identify: (value) => typeof value === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  test: /^[-+]?(?:\.[0-9]+|[0-9]+\.[0-9]*)$/,
  resolve(str) {
    const node = new Scalar(parseFloat(str));
    const dot = str.indexOf(".");
    if (dot !== -1 && str[str.length - 1] === "0")
      node.minFractionDigits = str.length - dot - 1;
    return node;
  },
  stringify: stringifyNumber
};

// node_modules/yaml/browser/dist/schema/core/int.js
var intIdentify = (value) => typeof value === "bigint" || Number.isInteger(value);
var intResolve = (str, offset, radix, { intAsBigInt }) => intAsBigInt ? BigInt(str) : parseInt(str.substring(offset), radix);
function intStringify(node, radix, prefix) {
  const { value } = node;
  if (intIdentify(value) && value >= 0)
    return prefix + value.toString(radix);
  return stringifyNumber(node);
}
var intOct = {
  identify: (value) => intIdentify(value) && value >= 0,
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "OCT",
  test: /^0o[0-7]+$/,
  resolve: (str, _onError, opt) => intResolve(str, 2, 8, opt),
  stringify: (node) => intStringify(node, 8, "0o")
};
var int = {
  identify: intIdentify,
  default: true,
  tag: "tag:yaml.org,2002:int",
  test: /^[-+]?[0-9]+$/,
  resolve: (str, _onError, opt) => intResolve(str, 0, 10, opt),
  stringify: stringifyNumber
};
var intHex = {
  identify: (value) => intIdentify(value) && value >= 0,
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "HEX",
  test: /^0x[0-9a-fA-F]+$/,
  resolve: (str, _onError, opt) => intResolve(str, 2, 16, opt),
  stringify: (node) => intStringify(node, 16, "0x")
};

// node_modules/yaml/browser/dist/schema/core/schema.js
var schema = [
  map,
  seq,
  string,
  nullTag,
  boolTag,
  intOct,
  int,
  intHex,
  floatNaN,
  floatExp,
  float
];

// node_modules/yaml/browser/dist/schema/json/schema.js
function intIdentify2(value) {
  return typeof value === "bigint" || Number.isInteger(value);
}
var stringifyJSON = ({ value }) => JSON.stringify(value);
var jsonScalars = [
  {
    identify: (value) => typeof value === "string",
    default: true,
    tag: "tag:yaml.org,2002:str",
    resolve: (str) => str,
    stringify: stringifyJSON
  },
  {
    identify: (value) => value == null,
    createNode: () => new Scalar(null),
    default: true,
    tag: "tag:yaml.org,2002:null",
    test: /^null$/,
    resolve: () => null,
    stringify: stringifyJSON
  },
  {
    identify: (value) => typeof value === "boolean",
    default: true,
    tag: "tag:yaml.org,2002:bool",
    test: /^true|false$/,
    resolve: (str) => str === "true",
    stringify: stringifyJSON
  },
  {
    identify: intIdentify2,
    default: true,
    tag: "tag:yaml.org,2002:int",
    test: /^-?(?:0|[1-9][0-9]*)$/,
    resolve: (str, _onError, { intAsBigInt }) => intAsBigInt ? BigInt(str) : parseInt(str, 10),
    stringify: ({ value }) => intIdentify2(value) ? value.toString() : JSON.stringify(value)
  },
  {
    identify: (value) => typeof value === "number",
    default: true,
    tag: "tag:yaml.org,2002:float",
    test: /^-?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,
    resolve: (str) => parseFloat(str),
    stringify: stringifyJSON
  }
];
var jsonError = {
  default: true,
  tag: "",
  test: /^/,
  resolve(str, onError) {
    onError(`Unresolved plain scalar ${JSON.stringify(str)}`);
    return str;
  }
};
var schema2 = [map, seq].concat(jsonScalars, jsonError);

// node_modules/yaml/browser/dist/schema/yaml-1.1/binary.js
var binary = {
  identify: (value) => value instanceof Uint8Array,
  default: false,
  tag: "tag:yaml.org,2002:binary",
  /**
   * Returns a Buffer in node and an Uint8Array in browsers
   *
   * To use the resulting buffer as an image, you'll want to do something like:
   *
   *   const blob = new Blob([buffer], { type: 'image/jpeg' })
   *   document.querySelector('#photo').src = URL.createObjectURL(blob)
   */
  resolve(src, onError) {
    if (typeof Buffer === "function") {
      return Buffer.from(src, "base64");
    } else if (typeof atob === "function") {
      const str = atob(src.replace(/[\n\r]/g, ""));
      const buffer = new Uint8Array(str.length);
      for (let i = 0; i < str.length; ++i)
        buffer[i] = str.charCodeAt(i);
      return buffer;
    } else {
      onError("This environment does not support reading binary tags; either Buffer or atob is required");
      return src;
    }
  },
  stringify({ comment, type, value }, ctx, onComment, onChompKeep) {
    const buf = value;
    let str;
    if (typeof Buffer === "function") {
      str = buf instanceof Buffer ? buf.toString("base64") : Buffer.from(buf.buffer).toString("base64");
    } else if (typeof btoa === "function") {
      let s = "";
      for (let i = 0; i < buf.length; ++i)
        s += String.fromCharCode(buf[i]);
      str = btoa(s);
    } else {
      throw new Error("This environment does not support writing binary tags; either Buffer or btoa is required");
    }
    if (!type)
      type = Scalar.BLOCK_LITERAL;
    if (type !== Scalar.QUOTE_DOUBLE) {
      const lineWidth = Math.max(ctx.options.lineWidth - ctx.indent.length, ctx.options.minContentWidth);
      const n = Math.ceil(str.length / lineWidth);
      const lines = new Array(n);
      for (let i = 0, o = 0; i < n; ++i, o += lineWidth) {
        lines[i] = str.substr(o, lineWidth);
      }
      str = lines.join(type === Scalar.BLOCK_LITERAL ? "\n" : " ");
    }
    return stringifyString({ comment, type, value: str }, ctx, onComment, onChompKeep);
  }
};

// node_modules/yaml/browser/dist/schema/yaml-1.1/pairs.js
function resolvePairs(seq2, onError) {
  if (isSeq(seq2)) {
    for (let i = 0; i < seq2.items.length; ++i) {
      let item = seq2.items[i];
      if (isPair(item))
        continue;
      else if (isMap(item)) {
        if (item.items.length > 1)
          onError("Each pair must have its own sequence indicator");
        const pair = item.items[0] || new Pair(new Scalar(null));
        if (item.commentBefore)
          pair.key.commentBefore = pair.key.commentBefore ? `${item.commentBefore}
${pair.key.commentBefore}` : item.commentBefore;
        if (item.comment) {
          const cn = pair.value || pair.key;
          cn.comment = cn.comment ? `${item.comment}
${cn.comment}` : item.comment;
        }
        item = pair;
      }
      seq2.items[i] = isPair(item) ? item : new Pair(item);
    }
  } else
    onError("Expected a sequence for this tag");
  return seq2;
}
function createPairs(schema4, iterable, ctx) {
  const { replacer } = ctx;
  const pairs2 = new YAMLSeq(schema4);
  pairs2.tag = "tag:yaml.org,2002:pairs";
  let i = 0;
  if (iterable && Symbol.iterator in Object(iterable))
    for (let it of iterable) {
      if (typeof replacer === "function")
        it = replacer.call(iterable, String(i++), it);
      let key, value;
      if (Array.isArray(it)) {
        if (it.length === 2) {
          key = it[0];
          value = it[1];
        } else
          throw new TypeError(`Expected [key, value] tuple: ${it}`);
      } else if (it && it instanceof Object) {
        const keys = Object.keys(it);
        if (keys.length === 1) {
          key = keys[0];
          value = it[key];
        } else
          throw new TypeError(`Expected { key: value } tuple: ${it}`);
      } else {
        key = it;
      }
      pairs2.items.push(createPair(key, value, ctx));
    }
  return pairs2;
}
var pairs = {
  collection: "seq",
  default: false,
  tag: "tag:yaml.org,2002:pairs",
  resolve: resolvePairs,
  createNode: createPairs
};

// node_modules/yaml/browser/dist/schema/yaml-1.1/omap.js
var YAMLOMap = class extends YAMLSeq {
  constructor() {
    super();
    this.add = YAMLMap.prototype.add.bind(this);
    this.delete = YAMLMap.prototype.delete.bind(this);
    this.get = YAMLMap.prototype.get.bind(this);
    this.has = YAMLMap.prototype.has.bind(this);
    this.set = YAMLMap.prototype.set.bind(this);
    this.tag = YAMLOMap.tag;
  }
  /**
   * If `ctx` is given, the return type is actually `Map<unknown, unknown>`,
   * but TypeScript won't allow widening the signature of a child method.
   */
  toJSON(_, ctx) {
    if (!ctx)
      return super.toJSON(_);
    const map2 = /* @__PURE__ */ new Map();
    if (ctx && ctx.onCreate)
      ctx.onCreate(map2);
    for (const pair of this.items) {
      let key, value;
      if (isPair(pair)) {
        key = toJS(pair.key, "", ctx);
        value = toJS(pair.value, key, ctx);
      } else {
        key = toJS(pair, "", ctx);
      }
      if (map2.has(key))
        throw new Error("Ordered maps must not include duplicate keys");
      map2.set(key, value);
    }
    return map2;
  }
};
YAMLOMap.tag = "tag:yaml.org,2002:omap";
var omap = {
  collection: "seq",
  identify: (value) => value instanceof Map,
  nodeClass: YAMLOMap,
  default: false,
  tag: "tag:yaml.org,2002:omap",
  resolve(seq2, onError) {
    const pairs2 = resolvePairs(seq2, onError);
    const seenKeys = [];
    for (const { key } of pairs2.items) {
      if (isScalar(key)) {
        if (seenKeys.includes(key.value)) {
          onError(`Ordered maps must not include duplicate keys: ${key.value}`);
        } else {
          seenKeys.push(key.value);
        }
      }
    }
    return Object.assign(new YAMLOMap(), pairs2);
  },
  createNode(schema4, iterable, ctx) {
    const pairs2 = createPairs(schema4, iterable, ctx);
    const omap2 = new YAMLOMap();
    omap2.items = pairs2.items;
    return omap2;
  }
};

// node_modules/yaml/browser/dist/schema/yaml-1.1/bool.js
function boolStringify({ value, source }, ctx) {
  const boolObj = value ? trueTag : falseTag;
  if (source && boolObj.test.test(source))
    return source;
  return value ? ctx.options.trueStr : ctx.options.falseStr;
}
var trueTag = {
  identify: (value) => value === true,
  default: true,
  tag: "tag:yaml.org,2002:bool",
  test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,
  resolve: () => new Scalar(true),
  stringify: boolStringify
};
var falseTag = {
  identify: (value) => value === false,
  default: true,
  tag: "tag:yaml.org,2002:bool",
  test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/i,
  resolve: () => new Scalar(false),
  stringify: boolStringify
};

// node_modules/yaml/browser/dist/schema/yaml-1.1/float.js
var floatNaN2 = {
  identify: (value) => typeof value === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  test: /^[-+]?\.(?:inf|Inf|INF|nan|NaN|NAN)$/,
  resolve: (str) => str.slice(-3).toLowerCase() === "nan" ? NaN : str[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
  stringify: stringifyNumber
};
var floatExp2 = {
  identify: (value) => typeof value === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  format: "EXP",
  test: /^[-+]?(?:[0-9][0-9_]*)?(?:\.[0-9_]*)?[eE][-+]?[0-9]+$/,
  resolve: (str) => parseFloat(str.replace(/_/g, "")),
  stringify(node) {
    const num = Number(node.value);
    return isFinite(num) ? num.toExponential() : stringifyNumber(node);
  }
};
var float2 = {
  identify: (value) => typeof value === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  test: /^[-+]?(?:[0-9][0-9_]*)?\.[0-9_]*$/,
  resolve(str) {
    const node = new Scalar(parseFloat(str.replace(/_/g, "")));
    const dot = str.indexOf(".");
    if (dot !== -1) {
      const f = str.substring(dot + 1).replace(/_/g, "");
      if (f[f.length - 1] === "0")
        node.minFractionDigits = f.length;
    }
    return node;
  },
  stringify: stringifyNumber
};

// node_modules/yaml/browser/dist/schema/yaml-1.1/int.js
var intIdentify3 = (value) => typeof value === "bigint" || Number.isInteger(value);
function intResolve2(str, offset, radix, { intAsBigInt }) {
  const sign = str[0];
  if (sign === "-" || sign === "+")
    offset += 1;
  str = str.substring(offset).replace(/_/g, "");
  if (intAsBigInt) {
    switch (radix) {
      case 2:
        str = `0b${str}`;
        break;
      case 8:
        str = `0o${str}`;
        break;
      case 16:
        str = `0x${str}`;
        break;
    }
    const n2 = BigInt(str);
    return sign === "-" ? BigInt(-1) * n2 : n2;
  }
  const n = parseInt(str, radix);
  return sign === "-" ? -1 * n : n;
}
function intStringify2(node, radix, prefix) {
  const { value } = node;
  if (intIdentify3(value)) {
    const str = value.toString(radix);
    return value < 0 ? "-" + prefix + str.substr(1) : prefix + str;
  }
  return stringifyNumber(node);
}
var intBin = {
  identify: intIdentify3,
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "BIN",
  test: /^[-+]?0b[0-1_]+$/,
  resolve: (str, _onError, opt) => intResolve2(str, 2, 2, opt),
  stringify: (node) => intStringify2(node, 2, "0b")
};
var intOct2 = {
  identify: intIdentify3,
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "OCT",
  test: /^[-+]?0[0-7_]+$/,
  resolve: (str, _onError, opt) => intResolve2(str, 1, 8, opt),
  stringify: (node) => intStringify2(node, 8, "0")
};
var int2 = {
  identify: intIdentify3,
  default: true,
  tag: "tag:yaml.org,2002:int",
  test: /^[-+]?[0-9][0-9_]*$/,
  resolve: (str, _onError, opt) => intResolve2(str, 0, 10, opt),
  stringify: stringifyNumber
};
var intHex2 = {
  identify: intIdentify3,
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "HEX",
  test: /^[-+]?0x[0-9a-fA-F_]+$/,
  resolve: (str, _onError, opt) => intResolve2(str, 2, 16, opt),
  stringify: (node) => intStringify2(node, 16, "0x")
};

// node_modules/yaml/browser/dist/schema/yaml-1.1/set.js
var YAMLSet = class extends YAMLMap {
  constructor(schema4) {
    super(schema4);
    this.tag = YAMLSet.tag;
  }
  add(key) {
    let pair;
    if (isPair(key))
      pair = key;
    else if (typeof key === "object" && "key" in key && "value" in key && key.value === null)
      pair = new Pair(key.key, null);
    else
      pair = new Pair(key, null);
    const prev = findPair(this.items, pair.key);
    if (!prev)
      this.items.push(pair);
  }
  get(key, keepPair) {
    const pair = findPair(this.items, key);
    return !keepPair && isPair(pair) ? isScalar(pair.key) ? pair.key.value : pair.key : pair;
  }
  set(key, value) {
    if (typeof value !== "boolean")
      throw new Error(`Expected boolean value for set(key, value) in a YAML set, not ${typeof value}`);
    const prev = findPair(this.items, key);
    if (prev && !value) {
      this.items.splice(this.items.indexOf(prev), 1);
    } else if (!prev && value) {
      this.items.push(new Pair(key));
    }
  }
  toJSON(_, ctx) {
    return super.toJSON(_, ctx, Set);
  }
  toString(ctx, onComment, onChompKeep) {
    if (!ctx)
      return JSON.stringify(this);
    if (this.hasAllNullValues(true))
      return super.toString(Object.assign({}, ctx, { allNullValues: true }), onComment, onChompKeep);
    else
      throw new Error("Set items must all have null values");
  }
};
YAMLSet.tag = "tag:yaml.org,2002:set";
var set = {
  collection: "map",
  identify: (value) => value instanceof Set,
  nodeClass: YAMLSet,
  default: false,
  tag: "tag:yaml.org,2002:set",
  resolve(map2, onError) {
    if (isMap(map2)) {
      if (map2.hasAllNullValues(true))
        return Object.assign(new YAMLSet(), map2);
      else
        onError("Set items must all have null values");
    } else
      onError("Expected a mapping for this tag");
    return map2;
  },
  createNode(schema4, iterable, ctx) {
    const { replacer } = ctx;
    const set2 = new YAMLSet(schema4);
    if (iterable && Symbol.iterator in Object(iterable))
      for (let value of iterable) {
        if (typeof replacer === "function")
          value = replacer.call(iterable, value, value);
        set2.items.push(createPair(value, null, ctx));
      }
    return set2;
  }
};

// node_modules/yaml/browser/dist/schema/yaml-1.1/timestamp.js
function parseSexagesimal(str, asBigInt) {
  const sign = str[0];
  const parts = sign === "-" || sign === "+" ? str.substring(1) : str;
  const num = (n) => asBigInt ? BigInt(n) : Number(n);
  const res = parts.replace(/_/g, "").split(":").reduce((res2, p) => res2 * num(60) + num(p), num(0));
  return sign === "-" ? num(-1) * res : res;
}
function stringifySexagesimal(node) {
  let { value } = node;
  let num = (n) => n;
  if (typeof value === "bigint")
    num = (n) => BigInt(n);
  else if (isNaN(value) || !isFinite(value))
    return stringifyNumber(node);
  let sign = "";
  if (value < 0) {
    sign = "-";
    value *= num(-1);
  }
  const _60 = num(60);
  const parts = [value % _60];
  if (value < 60) {
    parts.unshift(0);
  } else {
    value = (value - parts[0]) / _60;
    parts.unshift(value % _60);
    if (value >= 60) {
      value = (value - parts[0]) / _60;
      parts.unshift(value);
    }
  }
  return sign + parts.map((n) => n < 10 ? "0" + String(n) : String(n)).join(":").replace(/000000\d*$/, "");
}
var intTime = {
  identify: (value) => typeof value === "bigint" || Number.isInteger(value),
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "TIME",
  test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+$/,
  resolve: (str, _onError, { intAsBigInt }) => parseSexagesimal(str, intAsBigInt),
  stringify: stringifySexagesimal
};
var floatTime = {
  identify: (value) => typeof value === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  format: "TIME",
  test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\.[0-9_]*$/,
  resolve: (str) => parseSexagesimal(str, false),
  stringify: stringifySexagesimal
};
var timestamp = {
  identify: (value) => value instanceof Date,
  default: true,
  tag: "tag:yaml.org,2002:timestamp",
  // If the time zone is omitted, the timestamp is assumed to be specified in UTC. The time part
  // may be omitted altogether, resulting in a date format. In such a case, the time part is
  // assumed to be 00:00:00Z (start of day, UTC).
  test: RegExp("^([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})(?:(?:t|T|[ \\t]+)([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\.[0-9]+)?)(?:[ \\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?)?$"),
  resolve(str) {
    const match = str.match(timestamp.test);
    if (!match)
      throw new Error("!!timestamp expects a date, starting with yyyy-mm-dd");
    const [, year, month, day, hour, minute, second] = match.map(Number);
    const millisec = match[7] ? Number((match[7] + "00").substr(1, 3)) : 0;
    let date = Date.UTC(year, month - 1, day, hour || 0, minute || 0, second || 0, millisec);
    const tz = match[8];
    if (tz && tz !== "Z") {
      let d = parseSexagesimal(tz, false);
      if (Math.abs(d) < 30)
        d *= 60;
      date -= 6e4 * d;
    }
    return new Date(date);
  },
  stringify: ({ value }) => value.toISOString().replace(/((T00:00)?:00)?\.000Z$/, "")
};

// node_modules/yaml/browser/dist/schema/yaml-1.1/schema.js
var schema3 = [
  map,
  seq,
  string,
  nullTag,
  trueTag,
  falseTag,
  intBin,
  intOct2,
  int2,
  intHex2,
  floatNaN2,
  floatExp2,
  float2,
  binary,
  omap,
  pairs,
  set,
  intTime,
  floatTime,
  timestamp
];

// node_modules/yaml/browser/dist/schema/tags.js
var schemas = /* @__PURE__ */ new Map([
  ["core", schema],
  ["failsafe", [map, seq, string]],
  ["json", schema2],
  ["yaml11", schema3],
  ["yaml-1.1", schema3]
]);
var tagsByName = {
  binary,
  bool: boolTag,
  float,
  floatExp,
  floatNaN,
  floatTime,
  int,
  intHex,
  intOct,
  intTime,
  map,
  null: nullTag,
  omap,
  pairs,
  seq,
  set,
  timestamp
};
var coreKnownTags = {
  "tag:yaml.org,2002:binary": binary,
  "tag:yaml.org,2002:omap": omap,
  "tag:yaml.org,2002:pairs": pairs,
  "tag:yaml.org,2002:set": set,
  "tag:yaml.org,2002:timestamp": timestamp
};
function getTags(customTags, schemaName) {
  let tags = schemas.get(schemaName);
  if (!tags) {
    if (Array.isArray(customTags))
      tags = [];
    else {
      const keys = Array.from(schemas.keys()).filter((key) => key !== "yaml11").map((key) => JSON.stringify(key)).join(", ");
      throw new Error(`Unknown schema "${schemaName}"; use one of ${keys} or define customTags array`);
    }
  }
  if (Array.isArray(customTags)) {
    for (const tag2 of customTags)
      tags = tags.concat(tag2);
  } else if (typeof customTags === "function") {
    tags = customTags(tags.slice());
  }
  return tags.map((tag2) => {
    if (typeof tag2 !== "string")
      return tag2;
    const tagObj = tagsByName[tag2];
    if (tagObj)
      return tagObj;
    const keys = Object.keys(tagsByName).map((key) => JSON.stringify(key)).join(", ");
    throw new Error(`Unknown custom tag "${tag2}"; use one of ${keys}`);
  });
}

// node_modules/yaml/browser/dist/schema/Schema.js
var sortMapEntriesByKey = (a, b) => a.key < b.key ? -1 : a.key > b.key ? 1 : 0;
var Schema = class {
  constructor({ compat, customTags, merge, resolveKnownTags, schema: schema4, sortMapEntries, toStringDefaults }) {
    this.compat = Array.isArray(compat) ? getTags(compat, "compat") : compat ? getTags(null, compat) : null;
    this.merge = !!merge;
    this.name = typeof schema4 === "string" && schema4 || "core";
    this.knownTags = resolveKnownTags ? coreKnownTags : {};
    this.tags = getTags(customTags, this.name);
    this.toStringOptions = toStringDefaults || null;
    Object.defineProperty(this, MAP, { value: map });
    Object.defineProperty(this, SCALAR, { value: string });
    Object.defineProperty(this, SEQ, { value: seq });
    this.sortMapEntries = sortMapEntries === true ? sortMapEntriesByKey : sortMapEntries || null;
  }
  clone() {
    const copy = Object.create(Schema.prototype, Object.getOwnPropertyDescriptors(this));
    copy.tags = this.tags.slice();
    return copy;
  }
};

// node_modules/yaml/browser/dist/stringify/stringifyDocument.js
function stringifyDocument(doc, options) {
  const lines = [];
  let hasDirectives = options.directives === true;
  if (options.directives !== false && doc.directives) {
    const dir = doc.directives.toString(doc);
    if (dir) {
      lines.push(dir);
      hasDirectives = true;
    } else if (doc.directives.marker)
      hasDirectives = true;
  }
  if (hasDirectives)
    lines.push("---");
  const ctx = createStringifyContext(doc, options);
  const { commentString } = ctx.options;
  if (doc.commentBefore) {
    if (lines.length !== 1)
      lines.unshift("");
    const cs = commentString(doc.commentBefore);
    lines.unshift(indentComment(cs, ""));
  }
  let chompKeep = false;
  let contentComment = null;
  if (doc.contents) {
    if (isNode(doc.contents)) {
      if (doc.contents.spaceBefore && hasDirectives)
        lines.push("");
      if (doc.contents.commentBefore) {
        const cs = commentString(doc.contents.commentBefore);
        lines.push(indentComment(cs, ""));
      }
      ctx.forceBlockIndent = !!doc.comment;
      contentComment = doc.contents.comment;
    }
    const onChompKeep = contentComment ? void 0 : () => chompKeep = true;
    let body = stringify(doc.contents, ctx, () => contentComment = null, onChompKeep);
    if (contentComment)
      body += lineComment(body, "", commentString(contentComment));
    if ((body[0] === "|" || body[0] === ">") && lines[lines.length - 1] === "---") {
      lines[lines.length - 1] = `--- ${body}`;
    } else
      lines.push(body);
  } else {
    lines.push(stringify(doc.contents, ctx));
  }
  let dc = doc.comment;
  if (dc && chompKeep)
    dc = dc.replace(/^\n+/, "");
  if (dc) {
    if ((!chompKeep || contentComment) && lines[lines.length - 1] !== "")
      lines.push("");
    lines.push(indentComment(commentString(dc), ""));
  }
  return lines.join("\n") + "\n";
}

// node_modules/yaml/browser/dist/doc/applyReviver.js
function applyReviver(reviver, obj, key, val) {
  if (val && typeof val === "object") {
    if (Array.isArray(val)) {
      for (let i = 0, len = val.length; i < len; ++i) {
        const v0 = val[i];
        const v1 = applyReviver(reviver, val, String(i), v0);
        if (v1 === void 0)
          delete val[i];
        else if (v1 !== v0)
          val[i] = v1;
      }
    } else if (val instanceof Map) {
      for (const k of Array.from(val.keys())) {
        const v0 = val.get(k);
        const v1 = applyReviver(reviver, val, k, v0);
        if (v1 === void 0)
          val.delete(k);
        else if (v1 !== v0)
          val.set(k, v1);
      }
    } else if (val instanceof Set) {
      for (const v0 of Array.from(val)) {
        const v1 = applyReviver(reviver, val, v0, v0);
        if (v1 === void 0)
          val.delete(v0);
        else if (v1 !== v0) {
          val.delete(v0);
          val.add(v1);
        }
      }
    } else {
      for (const [k, v0] of Object.entries(val)) {
        const v1 = applyReviver(reviver, val, k, v0);
        if (v1 === void 0)
          delete val[k];
        else if (v1 !== v0)
          val[k] = v1;
      }
    }
  }
  return reviver.call(obj, key, val);
}

// node_modules/yaml/browser/dist/doc/Document.js
var Document = class {
  constructor(value, replacer, options) {
    this.commentBefore = null;
    this.comment = null;
    this.errors = [];
    this.warnings = [];
    Object.defineProperty(this, NODE_TYPE, { value: DOC });
    let _replacer = null;
    if (typeof replacer === "function" || Array.isArray(replacer)) {
      _replacer = replacer;
    } else if (options === void 0 && replacer) {
      options = replacer;
      replacer = void 0;
    }
    const opt = Object.assign({}, defaultOptions, options);
    this.options = opt;
    let { version } = opt;
    if (options === null || options === void 0 ? void 0 : options.directives) {
      this.directives = options.directives.atDocument();
      if (this.directives.yaml.explicit)
        version = this.directives.yaml.version;
    } else
      this.directives = new Directives({ version });
    this.setSchema(version, options);
    if (value === void 0)
      this.contents = null;
    else {
      this.contents = this.createNode(value, _replacer, options);
    }
  }
  /**
   * Create a deep copy of this Document and its contents.
   *
   * Custom Node values that inherit from `Object` still refer to their original instances.
   */
  clone() {
    const copy = Object.create(Document.prototype, {
      [NODE_TYPE]: { value: DOC }
    });
    copy.commentBefore = this.commentBefore;
    copy.comment = this.comment;
    copy.errors = this.errors.slice();
    copy.warnings = this.warnings.slice();
    copy.options = Object.assign({}, this.options);
    if (this.directives)
      copy.directives = this.directives.clone();
    copy.schema = this.schema.clone();
    copy.contents = isNode(this.contents) ? this.contents.clone(copy.schema) : this.contents;
    if (this.range)
      copy.range = this.range.slice();
    return copy;
  }
  /** Adds a value to the document. */
  add(value) {
    if (assertCollection(this.contents))
      this.contents.add(value);
  }
  /** Adds a value to the document. */
  addIn(path, value) {
    if (assertCollection(this.contents))
      this.contents.addIn(path, value);
  }
  /**
   * Create a new `Alias` node, ensuring that the target `node` has the required anchor.
   *
   * If `node` already has an anchor, `name` is ignored.
   * Otherwise, the `node.anchor` value will be set to `name`,
   * or if an anchor with that name is already present in the document,
   * `name` will be used as a prefix for a new unique anchor.
   * If `name` is undefined, the generated anchor will use 'a' as a prefix.
   */
  createAlias(node, name) {
    if (!node.anchor) {
      const prev = anchorNames(this);
      node.anchor = !name || prev.has(name) ? findNewAnchor(name || "a", prev) : name;
    }
    return new Alias(node.anchor);
  }
  createNode(value, replacer, options) {
    let _replacer = void 0;
    if (typeof replacer === "function") {
      value = replacer.call({ "": value }, "", value);
      _replacer = replacer;
    } else if (Array.isArray(replacer)) {
      const keyToStr = (v) => typeof v === "number" || v instanceof String || v instanceof Number;
      const asStr = replacer.filter(keyToStr).map(String);
      if (asStr.length > 0)
        replacer = replacer.concat(asStr);
      _replacer = replacer;
    } else if (options === void 0 && replacer) {
      options = replacer;
      replacer = void 0;
    }
    const { aliasDuplicateObjects, anchorPrefix, flow, keepUndefined, onTagObj, tag: tag2 } = options || {};
    const { onAnchor, setAnchors, sourceObjects } = createNodeAnchors(this, anchorPrefix || "a");
    const ctx = {
      aliasDuplicateObjects: aliasDuplicateObjects !== null && aliasDuplicateObjects !== void 0 ? aliasDuplicateObjects : true,
      keepUndefined: keepUndefined !== null && keepUndefined !== void 0 ? keepUndefined : false,
      onAnchor,
      onTagObj,
      replacer: _replacer,
      schema: this.schema,
      sourceObjects
    };
    const node = createNode(value, tag2, ctx);
    if (flow && isCollection(node))
      node.flow = true;
    setAnchors();
    return node;
  }
  /**
   * Convert a key and a value into a `Pair` using the current schema,
   * recursively wrapping all values as `Scalar` or `Collection` nodes.
   */
  createPair(key, value, options = {}) {
    const k = this.createNode(key, null, options);
    const v = this.createNode(value, null, options);
    return new Pair(k, v);
  }
  /**
   * Removes a value from the document.
   * @returns `true` if the item was found and removed.
   */
  delete(key) {
    return assertCollection(this.contents) ? this.contents.delete(key) : false;
  }
  /**
   * Removes a value from the document.
   * @returns `true` if the item was found and removed.
   */
  deleteIn(path) {
    if (isEmptyPath(path)) {
      if (this.contents == null)
        return false;
      this.contents = null;
      return true;
    }
    return assertCollection(this.contents) ? this.contents.deleteIn(path) : false;
  }
  /**
   * Returns item at `key`, or `undefined` if not found. By default unwraps
   * scalar values from their surrounding node; to disable set `keepScalar` to
   * `true` (collections are always returned intact).
   */
  get(key, keepScalar) {
    return isCollection(this.contents) ? this.contents.get(key, keepScalar) : void 0;
  }
  /**
   * Returns item at `path`, or `undefined` if not found. By default unwraps
   * scalar values from their surrounding node; to disable set `keepScalar` to
   * `true` (collections are always returned intact).
   */
  getIn(path, keepScalar) {
    if (isEmptyPath(path))
      return !keepScalar && isScalar(this.contents) ? this.contents.value : this.contents;
    return isCollection(this.contents) ? this.contents.getIn(path, keepScalar) : void 0;
  }
  /**
   * Checks if the document includes a value with the key `key`.
   */
  has(key) {
    return isCollection(this.contents) ? this.contents.has(key) : false;
  }
  /**
   * Checks if the document includes a value at `path`.
   */
  hasIn(path) {
    if (isEmptyPath(path))
      return this.contents !== void 0;
    return isCollection(this.contents) ? this.contents.hasIn(path) : false;
  }
  /**
   * Sets a value in this document. For `!!set`, `value` needs to be a
   * boolean to add/remove the item from the set.
   */
  set(key, value) {
    if (this.contents == null) {
      this.contents = collectionFromPath(this.schema, [key], value);
    } else if (assertCollection(this.contents)) {
      this.contents.set(key, value);
    }
  }
  /**
   * Sets a value in this document. For `!!set`, `value` needs to be a
   * boolean to add/remove the item from the set.
   */
  setIn(path, value) {
    if (isEmptyPath(path))
      this.contents = value;
    else if (this.contents == null) {
      this.contents = collectionFromPath(this.schema, Array.from(path), value);
    } else if (assertCollection(this.contents)) {
      this.contents.setIn(path, value);
    }
  }
  /**
   * Change the YAML version and schema used by the document.
   * A `null` version disables support for directives, explicit tags, anchors, and aliases.
   * It also requires the `schema` option to be given as a `Schema` instance value.
   *
   * Overrides all previously set schema options.
   */
  setSchema(version, options = {}) {
    if (typeof version === "number")
      version = String(version);
    let opt;
    switch (version) {
      case "1.1":
        if (this.directives)
          this.directives.yaml.version = "1.1";
        else
          this.directives = new Directives({ version: "1.1" });
        opt = { merge: true, resolveKnownTags: false, schema: "yaml-1.1" };
        break;
      case "1.2":
        if (this.directives)
          this.directives.yaml.version = "1.2";
        else
          this.directives = new Directives({ version: "1.2" });
        opt = { merge: false, resolveKnownTags: true, schema: "core" };
        break;
      case null:
        if (this.directives)
          delete this.directives;
        opt = null;
        break;
      default: {
        const sv = JSON.stringify(version);
        throw new Error(`Expected '1.1', '1.2' or null as first argument, but found: ${sv}`);
      }
    }
    if (options.schema instanceof Object)
      this.schema = options.schema;
    else if (opt)
      this.schema = new Schema(Object.assign(opt, options));
    else
      throw new Error(`With a null YAML version, the { schema: Schema } option is required`);
  }
  // json & jsonArg are only used from toJSON()
  toJS({ json, jsonArg, mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {
    const ctx = {
      anchors: /* @__PURE__ */ new Map(),
      doc: this,
      keep: !json,
      mapAsMap: mapAsMap === true,
      mapKeyWarned: false,
      maxAliasCount: typeof maxAliasCount === "number" ? maxAliasCount : 100,
      stringify
    };
    const res = toJS(this.contents, jsonArg || "", ctx);
    if (typeof onAnchor === "function")
      for (const { count, res: res2 } of ctx.anchors.values())
        onAnchor(res2, count);
    return typeof reviver === "function" ? applyReviver(reviver, { "": res }, "", res) : res;
  }
  /**
   * A JSON representation of the document `contents`.
   *
   * @param jsonArg Used by `JSON.stringify` to indicate the array index or
   *   property name.
   */
  toJSON(jsonArg, onAnchor) {
    return this.toJS({ json: true, jsonArg, mapAsMap: false, onAnchor });
  }
  /** A YAML representation of the document. */
  toString(options = {}) {
    if (this.errors.length > 0)
      throw new Error("Document with errors cannot be stringified");
    if ("indent" in options && (!Number.isInteger(options.indent) || Number(options.indent) <= 0)) {
      const s = JSON.stringify(options.indent);
      throw new Error(`"indent" option must be a positive integer, not ${s}`);
    }
    return stringifyDocument(this, options);
  }
};
function assertCollection(contents) {
  if (isCollection(contents))
    return true;
  throw new Error("Expected a YAML collection as document contents");
}

// node_modules/yaml/browser/dist/errors.js
var YAMLError = class extends Error {
  constructor(name, pos, code, message) {
    super();
    this.name = name;
    this.code = code;
    this.message = message;
    this.pos = pos;
  }
};
var YAMLParseError = class extends YAMLError {
  constructor(pos, code, message) {
    super("YAMLParseError", pos, code, message);
  }
};
var YAMLWarning = class extends YAMLError {
  constructor(pos, code, message) {
    super("YAMLWarning", pos, code, message);
  }
};
var prettifyError = (src, lc) => (error) => {
  if (error.pos[0] === -1)
    return;
  error.linePos = error.pos.map((pos) => lc.linePos(pos));
  const { line, col } = error.linePos[0];
  error.message += ` at line ${line}, column ${col}`;
  let ci = col - 1;
  let lineStr = src.substring(lc.lineStarts[line - 1], lc.lineStarts[line]).replace(/[\n\r]+$/, "");
  if (ci >= 60 && lineStr.length > 80) {
    const trimStart = Math.min(ci - 39, lineStr.length - 79);
    lineStr = "\u2026" + lineStr.substring(trimStart);
    ci -= trimStart - 1;
  }
  if (lineStr.length > 80)
    lineStr = lineStr.substring(0, 79) + "\u2026";
  if (line > 1 && /^ *$/.test(lineStr.substring(0, ci))) {
    let prev = src.substring(lc.lineStarts[line - 2], lc.lineStarts[line - 1]);
    if (prev.length > 80)
      prev = prev.substring(0, 79) + "\u2026\n";
    lineStr = prev + lineStr;
  }
  if (/[^ ]/.test(lineStr)) {
    let count = 1;
    const end = error.linePos[1];
    if (end && end.line === line && end.col > col) {
      count = Math.min(end.col - col, 80 - ci);
    }
    const pointer = " ".repeat(ci) + "^".repeat(count);
    error.message += `:

${lineStr}
${pointer}
`;
  }
};

// node_modules/yaml/browser/dist/compose/resolve-props.js
function resolveProps(tokens, { flow, indicator, next, offset, onError, startOnNewline }) {
  let spaceBefore = false;
  let atNewline = startOnNewline;
  let hasSpace = startOnNewline;
  let comment = "";
  let commentSep = "";
  let hasNewline = false;
  let reqSpace = false;
  let anchor = null;
  let tag2 = null;
  let comma = null;
  let found = null;
  let start = null;
  for (const token of tokens) {
    if (reqSpace) {
      if (token.type !== "space" && token.type !== "newline" && token.type !== "comma")
        onError(token.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space");
      reqSpace = false;
    }
    switch (token.type) {
      case "space":
        if (!flow && atNewline && indicator !== "doc-start" && token.source[0] === "	")
          onError(token, "TAB_AS_INDENT", "Tabs are not allowed as indentation");
        hasSpace = true;
        break;
      case "comment": {
        if (!hasSpace)
          onError(token, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
        const cb = token.source.substring(1) || " ";
        if (!comment)
          comment = cb;
        else
          comment += commentSep + cb;
        commentSep = "";
        atNewline = false;
        break;
      }
      case "newline":
        if (atNewline) {
          if (comment)
            comment += token.source;
          else
            spaceBefore = true;
        } else
          commentSep += token.source;
        atNewline = true;
        hasNewline = true;
        hasSpace = true;
        break;
      case "anchor":
        if (anchor)
          onError(token, "MULTIPLE_ANCHORS", "A node can have at most one anchor");
        anchor = token;
        if (start === null)
          start = token.offset;
        atNewline = false;
        hasSpace = false;
        reqSpace = true;
        break;
      case "tag": {
        if (tag2)
          onError(token, "MULTIPLE_TAGS", "A node can have at most one tag");
        tag2 = token;
        if (start === null)
          start = token.offset;
        atNewline = false;
        hasSpace = false;
        reqSpace = true;
        break;
      }
      case indicator:
        if (anchor || tag2)
          onError(token, "BAD_PROP_ORDER", `Anchors and tags must be after the ${token.source} indicator`);
        if (found)
          onError(token, "UNEXPECTED_TOKEN", `Unexpected ${token.source} in ${flow || "collection"}`);
        found = token;
        atNewline = false;
        hasSpace = false;
        break;
      case "comma":
        if (flow) {
          if (comma)
            onError(token, "UNEXPECTED_TOKEN", `Unexpected , in ${flow}`);
          comma = token;
          atNewline = false;
          hasSpace = false;
          break;
        }
      default:
        onError(token, "UNEXPECTED_TOKEN", `Unexpected ${token.type} token`);
        atNewline = false;
        hasSpace = false;
    }
  }
  const last = tokens[tokens.length - 1];
  const end = last ? last.offset + last.source.length : offset;
  if (reqSpace && next && next.type !== "space" && next.type !== "newline" && next.type !== "comma" && (next.type !== "scalar" || next.source !== ""))
    onError(next.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space");
  return {
    comma,
    found,
    spaceBefore,
    comment,
    hasNewline,
    anchor,
    tag: tag2,
    end,
    start: start !== null && start !== void 0 ? start : end
  };
}

// node_modules/yaml/browser/dist/compose/util-contains-newline.js
function containsNewline(key) {
  if (!key)
    return null;
  switch (key.type) {
    case "alias":
    case "scalar":
    case "double-quoted-scalar":
    case "single-quoted-scalar":
      if (key.source.includes("\n"))
        return true;
      if (key.end) {
        for (const st of key.end)
          if (st.type === "newline")
            return true;
      }
      return false;
    case "flow-collection":
      for (const it of key.items) {
        for (const st of it.start)
          if (st.type === "newline")
            return true;
        if (it.sep) {
          for (const st of it.sep)
            if (st.type === "newline")
              return true;
        }
        if (containsNewline(it.key) || containsNewline(it.value))
          return true;
      }
      return false;
    default:
      return true;
  }
}

// node_modules/yaml/browser/dist/compose/util-flow-indent-check.js
function flowIndentCheck(indent, fc, onError) {
  if ((fc === null || fc === void 0 ? void 0 : fc.type) === "flow-collection") {
    const end = fc.end[0];
    if (end.indent === indent && (end.source === "]" || end.source === "}") && containsNewline(fc)) {
      const msg = "Flow end indicator should be more indented than parent";
      onError(end, "BAD_INDENT", msg, true);
    }
  }
}

// node_modules/yaml/browser/dist/compose/util-map-includes.js
function mapIncludes(ctx, items, search) {
  const { uniqueKeys } = ctx.options;
  if (uniqueKeys === false)
    return false;
  const isEqual = typeof uniqueKeys === "function" ? uniqueKeys : (a, b) => a === b || isScalar(a) && isScalar(b) && a.value === b.value && !(a.value === "<<" && ctx.schema.merge);
  return items.some((pair) => isEqual(pair.key, search));
}

// node_modules/yaml/browser/dist/compose/resolve-block-map.js
var startColMsg = "All mapping items must start at the same column";
function resolveBlockMap({ composeNode: composeNode2, composeEmptyNode: composeEmptyNode2 }, ctx, bm, onError) {
  var _a;
  const map2 = new YAMLMap(ctx.schema);
  if (ctx.atRoot)
    ctx.atRoot = false;
  let offset = bm.offset;
  for (const collItem of bm.items) {
    const { start, key, sep, value } = collItem;
    const keyProps = resolveProps(start, {
      indicator: "explicit-key-ind",
      next: key || (sep === null || sep === void 0 ? void 0 : sep[0]),
      offset,
      onError,
      startOnNewline: true
    });
    const implicitKey = !keyProps.found;
    if (implicitKey) {
      if (key) {
        if (key.type === "block-seq")
          onError(offset, "BLOCK_AS_IMPLICIT_KEY", "A block sequence may not be used as an implicit map key");
        else if ("indent" in key && key.indent !== bm.indent)
          onError(offset, "BAD_INDENT", startColMsg);
      }
      if (!keyProps.anchor && !keyProps.tag && !sep) {
        if (keyProps.comment) {
          if (map2.comment)
            map2.comment += "\n" + keyProps.comment;
          else
            map2.comment = keyProps.comment;
        }
        continue;
      }
    } else if (((_a = keyProps.found) === null || _a === void 0 ? void 0 : _a.indent) !== bm.indent)
      onError(offset, "BAD_INDENT", startColMsg);
    if (implicitKey && containsNewline(key))
      onError(
        key,
        // checked by containsNewline()
        "MULTILINE_IMPLICIT_KEY",
        "Implicit keys need to be on a single line"
      );
    const keyStart = keyProps.end;
    const keyNode = key ? composeNode2(ctx, key, keyProps, onError) : composeEmptyNode2(ctx, keyStart, start, null, keyProps, onError);
    if (ctx.schema.compat)
      flowIndentCheck(bm.indent, key, onError);
    if (mapIncludes(ctx, map2.items, keyNode))
      onError(keyStart, "DUPLICATE_KEY", "Map keys must be unique");
    const valueProps = resolveProps(sep || [], {
      indicator: "map-value-ind",
      next: value,
      offset: keyNode.range[2],
      onError,
      startOnNewline: !key || key.type === "block-scalar"
    });
    offset = valueProps.end;
    if (valueProps.found) {
      if (implicitKey) {
        if ((value === null || value === void 0 ? void 0 : value.type) === "block-map" && !valueProps.hasNewline)
          onError(offset, "BLOCK_AS_IMPLICIT_KEY", "Nested mappings are not allowed in compact mappings");
        if (ctx.options.strict && keyProps.start < valueProps.found.offset - 1024)
          onError(keyNode.range, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit block mapping key");
      }
      const valueNode = value ? composeNode2(ctx, value, valueProps, onError) : composeEmptyNode2(ctx, offset, sep, null, valueProps, onError);
      if (ctx.schema.compat)
        flowIndentCheck(bm.indent, value, onError);
      offset = valueNode.range[2];
      const pair = new Pair(keyNode, valueNode);
      if (ctx.options.keepSourceTokens)
        pair.srcToken = collItem;
      map2.items.push(pair);
    } else {
      if (implicitKey)
        onError(keyNode.range, "MISSING_CHAR", "Implicit map keys need to be followed by map values");
      if (valueProps.comment) {
        if (keyNode.comment)
          keyNode.comment += "\n" + valueProps.comment;
        else
          keyNode.comment = valueProps.comment;
      }
      const pair = new Pair(keyNode);
      if (ctx.options.keepSourceTokens)
        pair.srcToken = collItem;
      map2.items.push(pair);
    }
  }
  map2.range = [bm.offset, offset, offset];
  return map2;
}

// node_modules/yaml/browser/dist/compose/resolve-block-seq.js
function resolveBlockSeq({ composeNode: composeNode2, composeEmptyNode: composeEmptyNode2 }, ctx, bs, onError) {
  const seq2 = new YAMLSeq(ctx.schema);
  if (ctx.atRoot)
    ctx.atRoot = false;
  let offset = bs.offset;
  for (const { start, value } of bs.items) {
    const props = resolveProps(start, {
      indicator: "seq-item-ind",
      next: value,
      offset,
      onError,
      startOnNewline: true
    });
    offset = props.end;
    if (!props.found) {
      if (props.anchor || props.tag || value) {
        if (value && value.type === "block-seq")
          onError(offset, "BAD_INDENT", "All sequence items must start at the same column");
        else
          onError(offset, "MISSING_CHAR", "Sequence item without - indicator");
      } else {
        if (props.comment)
          seq2.comment = props.comment;
        continue;
      }
    }
    const node = value ? composeNode2(ctx, value, props, onError) : composeEmptyNode2(ctx, offset, start, null, props, onError);
    if (ctx.schema.compat)
      flowIndentCheck(bs.indent, value, onError);
    offset = node.range[2];
    seq2.items.push(node);
  }
  seq2.range = [bs.offset, offset, offset];
  return seq2;
}

// node_modules/yaml/browser/dist/compose/resolve-end.js
function resolveEnd(end, offset, reqSpace, onError) {
  let comment = "";
  if (end) {
    let hasSpace = false;
    let sep = "";
    for (const token of end) {
      const { source, type } = token;
      switch (type) {
        case "space":
          hasSpace = true;
          break;
        case "comment": {
          if (reqSpace && !hasSpace)
            onError(token, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
          const cb = source.substring(1) || " ";
          if (!comment)
            comment = cb;
          else
            comment += sep + cb;
          sep = "";
          break;
        }
        case "newline":
          if (comment)
            sep += source;
          hasSpace = true;
          break;
        default:
          onError(token, "UNEXPECTED_TOKEN", `Unexpected ${type} at node end`);
      }
      offset += source.length;
    }
  }
  return { comment, offset };
}

// node_modules/yaml/browser/dist/compose/resolve-flow-collection.js
var blockMsg = "Block collections are not allowed within flow collections";
var isBlock = (token) => token && (token.type === "block-map" || token.type === "block-seq");
function resolveFlowCollection({ composeNode: composeNode2, composeEmptyNode: composeEmptyNode2 }, ctx, fc, onError) {
  const isMap2 = fc.start.source === "{";
  const fcName = isMap2 ? "flow map" : "flow sequence";
  const coll = isMap2 ? new YAMLMap(ctx.schema) : new YAMLSeq(ctx.schema);
  coll.flow = true;
  const atRoot = ctx.atRoot;
  if (atRoot)
    ctx.atRoot = false;
  let offset = fc.offset + fc.start.source.length;
  for (let i = 0; i < fc.items.length; ++i) {
    const collItem = fc.items[i];
    const { start, key, sep, value } = collItem;
    const props = resolveProps(start, {
      flow: fcName,
      indicator: "explicit-key-ind",
      next: key || (sep === null || sep === void 0 ? void 0 : sep[0]),
      offset,
      onError,
      startOnNewline: false
    });
    if (!props.found) {
      if (!props.anchor && !props.tag && !sep && !value) {
        if (i === 0 && props.comma)
          onError(props.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${fcName}`);
        else if (i < fc.items.length - 1)
          onError(props.start, "UNEXPECTED_TOKEN", `Unexpected empty item in ${fcName}`);
        if (props.comment) {
          if (coll.comment)
            coll.comment += "\n" + props.comment;
          else
            coll.comment = props.comment;
        }
        offset = props.end;
        continue;
      }
      if (!isMap2 && ctx.options.strict && containsNewline(key))
        onError(
          key,
          // checked by containsNewline()
          "MULTILINE_IMPLICIT_KEY",
          "Implicit keys of flow sequence pairs need to be on a single line"
        );
    }
    if (i === 0) {
      if (props.comma)
        onError(props.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${fcName}`);
    } else {
      if (!props.comma)
        onError(props.start, "MISSING_CHAR", `Missing , between ${fcName} items`);
      if (props.comment) {
        let prevItemComment = "";
        loop:
          for (const st of start) {
            switch (st.type) {
              case "comma":
              case "space":
                break;
              case "comment":
                prevItemComment = st.source.substring(1);
                break loop;
              default:
                break loop;
            }
          }
        if (prevItemComment) {
          let prev = coll.items[coll.items.length - 1];
          if (isPair(prev))
            prev = prev.value || prev.key;
          if (prev.comment)
            prev.comment += "\n" + prevItemComment;
          else
            prev.comment = prevItemComment;
          props.comment = props.comment.substring(prevItemComment.length + 1);
        }
      }
    }
    if (!isMap2 && !sep && !props.found) {
      const valueNode = value ? composeNode2(ctx, value, props, onError) : composeEmptyNode2(ctx, props.end, sep, null, props, onError);
      coll.items.push(valueNode);
      offset = valueNode.range[2];
      if (isBlock(value))
        onError(valueNode.range, "BLOCK_IN_FLOW", blockMsg);
    } else {
      const keyStart = props.end;
      const keyNode = key ? composeNode2(ctx, key, props, onError) : composeEmptyNode2(ctx, keyStart, start, null, props, onError);
      if (isBlock(key))
        onError(keyNode.range, "BLOCK_IN_FLOW", blockMsg);
      const valueProps = resolveProps(sep || [], {
        flow: fcName,
        indicator: "map-value-ind",
        next: value,
        offset: keyNode.range[2],
        onError,
        startOnNewline: false
      });
      if (valueProps.found) {
        if (!isMap2 && !props.found && ctx.options.strict) {
          if (sep)
            for (const st of sep) {
              if (st === valueProps.found)
                break;
              if (st.type === "newline") {
                onError(st, "MULTILINE_IMPLICIT_KEY", "Implicit keys of flow sequence pairs need to be on a single line");
                break;
              }
            }
          if (props.start < valueProps.found.offset - 1024)
            onError(valueProps.found, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit flow sequence key");
        }
      } else if (value) {
        if ("source" in value && value.source && value.source[0] === ":")
          onError(value, "MISSING_CHAR", `Missing space after : in ${fcName}`);
        else
          onError(valueProps.start, "MISSING_CHAR", `Missing , or : between ${fcName} items`);
      }
      const valueNode = value ? composeNode2(ctx, value, valueProps, onError) : valueProps.found ? composeEmptyNode2(ctx, valueProps.end, sep, null, valueProps, onError) : null;
      if (valueNode) {
        if (isBlock(value))
          onError(valueNode.range, "BLOCK_IN_FLOW", blockMsg);
      } else if (valueProps.comment) {
        if (keyNode.comment)
          keyNode.comment += "\n" + valueProps.comment;
        else
          keyNode.comment = valueProps.comment;
      }
      const pair = new Pair(keyNode, valueNode);
      if (ctx.options.keepSourceTokens)
        pair.srcToken = collItem;
      if (isMap2) {
        const map2 = coll;
        if (mapIncludes(ctx, map2.items, keyNode))
          onError(keyStart, "DUPLICATE_KEY", "Map keys must be unique");
        map2.items.push(pair);
      } else {
        const map2 = new YAMLMap(ctx.schema);
        map2.flow = true;
        map2.items.push(pair);
        coll.items.push(map2);
      }
      offset = valueNode ? valueNode.range[2] : valueProps.end;
    }
  }
  const expectedEnd = isMap2 ? "}" : "]";
  const [ce, ...ee] = fc.end;
  let cePos = offset;
  if (ce && ce.source === expectedEnd)
    cePos = ce.offset + ce.source.length;
  else {
    const name = fcName[0].toUpperCase() + fcName.substring(1);
    const msg = atRoot ? `${name} must end with a ${expectedEnd}` : `${name} in block collection must be sufficiently indented and end with a ${expectedEnd}`;
    onError(offset, atRoot ? "MISSING_CHAR" : "BAD_INDENT", msg);
    if (ce && ce.source.length !== 1)
      ee.unshift(ce);
  }
  if (ee.length > 0) {
    const end = resolveEnd(ee, cePos, ctx.options.strict, onError);
    if (end.comment) {
      if (coll.comment)
        coll.comment += "\n" + end.comment;
      else
        coll.comment = end.comment;
    }
    coll.range = [fc.offset, cePos, end.offset];
  } else {
    coll.range = [fc.offset, cePos, cePos];
  }
  return coll;
}

// node_modules/yaml/browser/dist/compose/compose-collection.js
function composeCollection(CN2, ctx, token, tagToken, onError) {
  let coll;
  switch (token.type) {
    case "block-map": {
      coll = resolveBlockMap(CN2, ctx, token, onError);
      break;
    }
    case "block-seq": {
      coll = resolveBlockSeq(CN2, ctx, token, onError);
      break;
    }
    case "flow-collection": {
      coll = resolveFlowCollection(CN2, ctx, token, onError);
      break;
    }
  }
  if (!tagToken)
    return coll;
  const tagName = ctx.directives.tagName(tagToken.source, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg));
  if (!tagName)
    return coll;
  const Coll = coll.constructor;
  if (tagName === "!" || tagName === Coll.tagName) {
    coll.tag = Coll.tagName;
    return coll;
  }
  const expType = isMap(coll) ? "map" : "seq";
  let tag2 = ctx.schema.tags.find((t) => t.collection === expType && t.tag === tagName);
  if (!tag2) {
    const kt = ctx.schema.knownTags[tagName];
    if (kt && kt.collection === expType) {
      ctx.schema.tags.push(Object.assign({}, kt, { default: false }));
      tag2 = kt;
    } else {
      onError(tagToken, "TAG_RESOLVE_FAILED", `Unresolved tag: ${tagName}`, true);
      coll.tag = tagName;
      return coll;
    }
  }
  const res = tag2.resolve(coll, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg), ctx.options);
  const node = isNode(res) ? res : new Scalar(res);
  node.range = coll.range;
  node.tag = tagName;
  if (tag2 === null || tag2 === void 0 ? void 0 : tag2.format)
    node.format = tag2.format;
  return node;
}

// node_modules/yaml/browser/dist/compose/resolve-block-scalar.js
function resolveBlockScalar(scalar, strict, onError) {
  const start = scalar.offset;
  const header = parseBlockScalarHeader(scalar, strict, onError);
  if (!header)
    return { value: "", type: null, comment: "", range: [start, start, start] };
  const type = header.mode === ">" ? Scalar.BLOCK_FOLDED : Scalar.BLOCK_LITERAL;
  const lines = scalar.source ? splitLines(scalar.source) : [];
  let chompStart = lines.length;
  for (let i = lines.length - 1; i >= 0; --i) {
    const content = lines[i][1];
    if (content === "" || content === "\r")
      chompStart = i;
    else
      break;
  }
  if (!scalar.source || chompStart === 0) {
    const value2 = header.chomp === "+" ? "\n".repeat(Math.max(0, lines.length - 1)) : "";
    let end2 = start + header.length;
    if (scalar.source)
      end2 += scalar.source.length;
    return { value: value2, type, comment: header.comment, range: [start, end2, end2] };
  }
  let trimIndent = scalar.indent + header.indent;
  let offset = scalar.offset + header.length;
  let contentStart = 0;
  for (let i = 0; i < chompStart; ++i) {
    const [indent, content] = lines[i];
    if (content === "" || content === "\r") {
      if (header.indent === 0 && indent.length > trimIndent)
        trimIndent = indent.length;
    } else {
      if (indent.length < trimIndent) {
        const message = "Block scalars with more-indented leading empty lines must use an explicit indentation indicator";
        onError(offset + indent.length, "MISSING_CHAR", message);
      }
      if (header.indent === 0)
        trimIndent = indent.length;
      contentStart = i;
      break;
    }
    offset += indent.length + content.length + 1;
  }
  let value = "";
  let sep = "";
  let prevMoreIndented = false;
  for (let i = 0; i < contentStart; ++i)
    value += lines[i][0].slice(trimIndent) + "\n";
  for (let i = contentStart; i < chompStart; ++i) {
    let [indent, content] = lines[i];
    offset += indent.length + content.length + 1;
    const crlf = content[content.length - 1] === "\r";
    if (crlf)
      content = content.slice(0, -1);
    if (content && indent.length < trimIndent) {
      const src = header.indent ? "explicit indentation indicator" : "first line";
      const message = `Block scalar lines must not be less indented than their ${src}`;
      onError(offset - content.length - (crlf ? 2 : 1), "BAD_INDENT", message);
      indent = "";
    }
    if (type === Scalar.BLOCK_LITERAL) {
      value += sep + indent.slice(trimIndent) + content;
      sep = "\n";
    } else if (indent.length > trimIndent || content[0] === "	") {
      if (sep === " ")
        sep = "\n";
      else if (!prevMoreIndented && sep === "\n")
        sep = "\n\n";
      value += sep + indent.slice(trimIndent) + content;
      sep = "\n";
      prevMoreIndented = true;
    } else if (content === "") {
      if (sep === "\n")
        value += "\n";
      else
        sep = "\n";
    } else {
      value += sep + content;
      sep = " ";
      prevMoreIndented = false;
    }
  }
  switch (header.chomp) {
    case "-":
      break;
    case "+":
      for (let i = chompStart; i < lines.length; ++i)
        value += "\n" + lines[i][0].slice(trimIndent);
      if (value[value.length - 1] !== "\n")
        value += "\n";
      break;
    default:
      value += "\n";
  }
  const end = start + header.length + scalar.source.length;
  return { value, type, comment: header.comment, range: [start, end, end] };
}
function parseBlockScalarHeader({ offset, props }, strict, onError) {
  if (props[0].type !== "block-scalar-header") {
    onError(props[0], "IMPOSSIBLE", "Block scalar header not found");
    return null;
  }
  const { source } = props[0];
  const mode = source[0];
  let indent = 0;
  let chomp = "";
  let error = -1;
  for (let i = 1; i < source.length; ++i) {
    const ch = source[i];
    if (!chomp && (ch === "-" || ch === "+"))
      chomp = ch;
    else {
      const n = Number(ch);
      if (!indent && n)
        indent = n;
      else if (error === -1)
        error = offset + i;
    }
  }
  if (error !== -1)
    onError(error, "UNEXPECTED_TOKEN", `Block scalar header includes extra characters: ${source}`);
  let hasSpace = false;
  let comment = "";
  let length = source.length;
  for (let i = 1; i < props.length; ++i) {
    const token = props[i];
    switch (token.type) {
      case "space":
        hasSpace = true;
      case "newline":
        length += token.source.length;
        break;
      case "comment":
        if (strict && !hasSpace) {
          const message = "Comments must be separated from other tokens by white space characters";
          onError(token, "MISSING_CHAR", message);
        }
        length += token.source.length;
        comment = token.source.substring(1);
        break;
      case "error":
        onError(token, "UNEXPECTED_TOKEN", token.message);
        length += token.source.length;
        break;
      default: {
        const message = `Unexpected token in block scalar header: ${token.type}`;
        onError(token, "UNEXPECTED_TOKEN", message);
        const ts = token.source;
        if (ts && typeof ts === "string")
          length += ts.length;
      }
    }
  }
  return { mode, indent, chomp, comment, length };
}
function splitLines(source) {
  const split = source.split(/\n( *)/);
  const first = split[0];
  const m = first.match(/^( *)/);
  const line0 = m && m[1] ? [m[1], first.slice(m[1].length)] : ["", first];
  const lines = [line0];
  for (let i = 1; i < split.length; i += 2)
    lines.push([split[i], split[i + 1]]);
  return lines;
}

// node_modules/yaml/browser/dist/compose/resolve-flow-scalar.js
function resolveFlowScalar(scalar, strict, onError) {
  const { offset, type, source, end } = scalar;
  let _type;
  let value;
  const _onError = (rel, code, msg) => onError(offset + rel, code, msg);
  switch (type) {
    case "scalar":
      _type = Scalar.PLAIN;
      value = plainValue(source, _onError);
      break;
    case "single-quoted-scalar":
      _type = Scalar.QUOTE_SINGLE;
      value = singleQuotedValue(source, _onError);
      break;
    case "double-quoted-scalar":
      _type = Scalar.QUOTE_DOUBLE;
      value = doubleQuotedValue(source, _onError);
      break;
    default:
      onError(scalar, "UNEXPECTED_TOKEN", `Expected a flow scalar value, but found: ${type}`);
      return {
        value: "",
        type: null,
        comment: "",
        range: [offset, offset + source.length, offset + source.length]
      };
  }
  const valueEnd = offset + source.length;
  const re = resolveEnd(end, valueEnd, strict, onError);
  return {
    value,
    type: _type,
    comment: re.comment,
    range: [offset, valueEnd, re.offset]
  };
}
function plainValue(source, onError) {
  let badChar = "";
  switch (source[0]) {
    case "	":
      badChar = "a tab character";
      break;
    case ",":
      badChar = "flow indicator character ,";
      break;
    case "%":
      badChar = "directive indicator character %";
      break;
    case "|":
    case ">": {
      badChar = `block scalar indicator ${source[0]}`;
      break;
    }
    case "@":
    case "`": {
      badChar = `reserved character ${source[0]}`;
      break;
    }
  }
  if (badChar)
    onError(0, "BAD_SCALAR_START", `Plain value cannot start with ${badChar}`);
  return foldLines(source);
}
function singleQuotedValue(source, onError) {
  if (source[source.length - 1] !== "'" || source.length === 1)
    onError(source.length, "MISSING_CHAR", "Missing closing 'quote");
  return foldLines(source.slice(1, -1)).replace(/''/g, "'");
}
function foldLines(source) {
  let first, line;
  try {
    first = new RegExp("(.*?)(?<![ 	])[ 	]*\r?\n", "sy");
    line = new RegExp("[ 	]*(.*?)(?:(?<![ 	])[ 	]*)?\r?\n", "sy");
  } catch (_) {
    first = /(.*?)[ \t]*\r?\n/sy;
    line = /[ \t]*(.*?)[ \t]*\r?\n/sy;
  }
  let match = first.exec(source);
  if (!match)
    return source;
  let res = match[1];
  let sep = " ";
  let pos = first.lastIndex;
  line.lastIndex = pos;
  while (match = line.exec(source)) {
    if (match[1] === "") {
      if (sep === "\n")
        res += sep;
      else
        sep = "\n";
    } else {
      res += sep + match[1];
      sep = " ";
    }
    pos = line.lastIndex;
  }
  const last = /[ \t]*(.*)/sy;
  last.lastIndex = pos;
  match = last.exec(source);
  return res + sep + (match && match[1] || "");
}
function doubleQuotedValue(source, onError) {
  let res = "";
  for (let i = 1; i < source.length - 1; ++i) {
    const ch = source[i];
    if (ch === "\r" && source[i + 1] === "\n")
      continue;
    if (ch === "\n") {
      const { fold, offset } = foldNewline(source, i);
      res += fold;
      i = offset;
    } else if (ch === "\\") {
      let next = source[++i];
      const cc = escapeCodes[next];
      if (cc)
        res += cc;
      else if (next === "\n") {
        next = source[i + 1];
        while (next === " " || next === "	")
          next = source[++i + 1];
      } else if (next === "\r" && source[i + 1] === "\n") {
        next = source[++i + 1];
        while (next === " " || next === "	")
          next = source[++i + 1];
      } else if (next === "x" || next === "u" || next === "U") {
        const length = { x: 2, u: 4, U: 8 }[next];
        res += parseCharCode(source, i + 1, length, onError);
        i += length;
      } else {
        const raw = source.substr(i - 1, 2);
        onError(i - 1, "BAD_DQ_ESCAPE", `Invalid escape sequence ${raw}`);
        res += raw;
      }
    } else if (ch === " " || ch === "	") {
      const wsStart = i;
      let next = source[i + 1];
      while (next === " " || next === "	")
        next = source[++i + 1];
      if (next !== "\n" && !(next === "\r" && source[i + 2] === "\n"))
        res += i > wsStart ? source.slice(wsStart, i + 1) : ch;
    } else {
      res += ch;
    }
  }
  if (source[source.length - 1] !== '"' || source.length === 1)
    onError(source.length, "MISSING_CHAR", 'Missing closing "quote');
  return res;
}
function foldNewline(source, offset) {
  let fold = "";
  let ch = source[offset + 1];
  while (ch === " " || ch === "	" || ch === "\n" || ch === "\r") {
    if (ch === "\r" && source[offset + 2] !== "\n")
      break;
    if (ch === "\n")
      fold += "\n";
    offset += 1;
    ch = source[offset + 1];
  }
  if (!fold)
    fold = " ";
  return { fold, offset };
}
var escapeCodes = {
  "0": "\0",
  a: "\x07",
  b: "\b",
  e: "\x1B",
  f: "\f",
  n: "\n",
  r: "\r",
  t: "	",
  v: "\v",
  N: "\x85",
  _: "\xA0",
  L: "\u2028",
  P: "\u2029",
  " ": " ",
  '"': '"',
  "/": "/",
  "\\": "\\",
  "	": "	"
};
function parseCharCode(source, offset, length, onError) {
  const cc = source.substr(offset, length);
  const ok = cc.length === length && /^[0-9a-fA-F]+$/.test(cc);
  const code = ok ? parseInt(cc, 16) : NaN;
  if (isNaN(code)) {
    const raw = source.substr(offset - 2, length + 2);
    onError(offset - 2, "BAD_DQ_ESCAPE", `Invalid escape sequence ${raw}`);
    return raw;
  }
  return String.fromCodePoint(code);
}

// node_modules/yaml/browser/dist/compose/compose-scalar.js
function composeScalar(ctx, token, tagToken, onError) {
  const { value, type, comment, range } = token.type === "block-scalar" ? resolveBlockScalar(token, ctx.options.strict, onError) : resolveFlowScalar(token, ctx.options.strict, onError);
  const tagName = tagToken ? ctx.directives.tagName(tagToken.source, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg)) : null;
  const tag2 = tagToken && tagName ? findScalarTagByName(ctx.schema, value, tagName, tagToken, onError) : token.type === "scalar" ? findScalarTagByTest(ctx, value, token, onError) : ctx.schema[SCALAR];
  let scalar;
  try {
    const res = tag2.resolve(value, (msg) => onError(tagToken || token, "TAG_RESOLVE_FAILED", msg), ctx.options);
    scalar = isScalar(res) ? res : new Scalar(res);
  } catch (error) {
    const msg = error instanceof Error ? error.message : String(error);
    onError(tagToken || token, "TAG_RESOLVE_FAILED", msg);
    scalar = new Scalar(value);
  }
  scalar.range = range;
  scalar.source = value;
  if (type)
    scalar.type = type;
  if (tagName)
    scalar.tag = tagName;
  if (tag2.format)
    scalar.format = tag2.format;
  if (comment)
    scalar.comment = comment;
  return scalar;
}
function findScalarTagByName(schema4, value, tagName, tagToken, onError) {
  var _a;
  if (tagName === "!")
    return schema4[SCALAR];
  const matchWithTest = [];
  for (const tag2 of schema4.tags) {
    if (!tag2.collection && tag2.tag === tagName) {
      if (tag2.default && tag2.test)
        matchWithTest.push(tag2);
      else
        return tag2;
    }
  }
  for (const tag2 of matchWithTest)
    if ((_a = tag2.test) === null || _a === void 0 ? void 0 : _a.test(value))
      return tag2;
  const kt = schema4.knownTags[tagName];
  if (kt && !kt.collection) {
    schema4.tags.push(Object.assign({}, kt, { default: false, test: void 0 }));
    return kt;
  }
  onError(tagToken, "TAG_RESOLVE_FAILED", `Unresolved tag: ${tagName}`, tagName !== "tag:yaml.org,2002:str");
  return schema4[SCALAR];
}
function findScalarTagByTest({ directives, schema: schema4 }, value, token, onError) {
  const tag2 = schema4.tags.find((tag3) => {
    var _a;
    return tag3.default && ((_a = tag3.test) === null || _a === void 0 ? void 0 : _a.test(value));
  }) || schema4[SCALAR];
  if (schema4.compat) {
    const compat = schema4.compat.find((tag3) => {
      var _a;
      return tag3.default && ((_a = tag3.test) === null || _a === void 0 ? void 0 : _a.test(value));
    }) || schema4[SCALAR];
    if (tag2.tag !== compat.tag) {
      const ts = directives.tagString(tag2.tag);
      const cs = directives.tagString(compat.tag);
      const msg = `Value may be parsed as either ${ts} or ${cs}`;
      onError(token, "TAG_RESOLVE_FAILED", msg, true);
    }
  }
  return tag2;
}

// node_modules/yaml/browser/dist/compose/util-empty-scalar-position.js
function emptyScalarPosition(offset, before, pos) {
  if (before) {
    if (pos === null)
      pos = before.length;
    for (let i = pos - 1; i >= 0; --i) {
      let st = before[i];
      switch (st.type) {
        case "space":
        case "comment":
        case "newline":
          offset -= st.source.length;
          continue;
      }
      st = before[++i];
      while ((st === null || st === void 0 ? void 0 : st.type) === "space") {
        offset += st.source.length;
        st = before[++i];
      }
      break;
    }
  }
  return offset;
}

// node_modules/yaml/browser/dist/compose/compose-node.js
var CN = { composeNode, composeEmptyNode };
function composeNode(ctx, token, props, onError) {
  const { spaceBefore, comment, anchor, tag: tag2 } = props;
  let node;
  switch (token.type) {
    case "alias":
      node = composeAlias(ctx, token, onError);
      if (anchor || tag2)
        onError(token, "ALIAS_PROPS", "An alias node must not specify any properties");
      break;
    case "scalar":
    case "single-quoted-scalar":
    case "double-quoted-scalar":
    case "block-scalar":
      node = composeScalar(ctx, token, tag2, onError);
      if (anchor)
        node.anchor = anchor.source.substring(1);
      break;
    case "block-map":
    case "block-seq":
    case "flow-collection":
      node = composeCollection(CN, ctx, token, tag2, onError);
      if (anchor)
        node.anchor = anchor.source.substring(1);
      break;
    default:
      console.log(token);
      throw new Error(`Unsupporten token type: ${token.type}`);
  }
  if (anchor && node.anchor === "")
    onError(anchor, "BAD_ALIAS", "Anchor cannot be an empty string");
  if (spaceBefore)
    node.spaceBefore = true;
  if (comment) {
    if (token.type === "scalar" && token.source === "")
      node.comment = comment;
    else
      node.commentBefore = comment;
  }
  if (ctx.options.keepSourceTokens)
    node.srcToken = token;
  return node;
}
function composeEmptyNode(ctx, offset, before, pos, { spaceBefore, comment, anchor, tag: tag2 }, onError) {
  const token = {
    type: "scalar",
    offset: emptyScalarPosition(offset, before, pos),
    indent: -1,
    source: ""
  };
  const node = composeScalar(ctx, token, tag2, onError);
  if (anchor) {
    node.anchor = anchor.source.substring(1);
    if (node.anchor === "")
      onError(anchor, "BAD_ALIAS", "Anchor cannot be an empty string");
  }
  if (spaceBefore)
    node.spaceBefore = true;
  if (comment)
    node.comment = comment;
  return node;
}
function composeAlias({ options }, { offset, source, end }, onError) {
  const alias = new Alias(source.substring(1));
  if (alias.source === "")
    onError(offset, "BAD_ALIAS", "Alias cannot be an empty string");
  const valueEnd = offset + source.length;
  const re = resolveEnd(end, valueEnd, options.strict, onError);
  alias.range = [offset, valueEnd, re.offset];
  if (re.comment)
    alias.comment = re.comment;
  return alias;
}

// node_modules/yaml/browser/dist/compose/compose-doc.js
function composeDoc(options, directives, { offset, start, value, end }, onError) {
  const opts = Object.assign({ directives }, options);
  const doc = new Document(void 0, opts);
  const ctx = {
    atRoot: true,
    directives: doc.directives,
    options: doc.options,
    schema: doc.schema
  };
  const props = resolveProps(start, {
    indicator: "doc-start",
    next: value || (end === null || end === void 0 ? void 0 : end[0]),
    offset,
    onError,
    startOnNewline: true
  });
  if (props.found) {
    doc.directives.marker = true;
    if (value && (value.type === "block-map" || value.type === "block-seq") && !props.hasNewline)
      onError(props.end, "MISSING_CHAR", "Block collection cannot start on same line with directives-end marker");
  }
  doc.contents = value ? composeNode(ctx, value, props, onError) : composeEmptyNode(ctx, props.end, start, null, props, onError);
  const contentEnd = doc.contents.range[2];
  const re = resolveEnd(end, contentEnd, false, onError);
  if (re.comment)
    doc.comment = re.comment;
  doc.range = [offset, contentEnd, re.offset];
  return doc;
}

// node_modules/yaml/browser/dist/compose/composer.js
function getErrorPos(src) {
  if (typeof src === "number")
    return [src, src + 1];
  if (Array.isArray(src))
    return src.length === 2 ? src : [src[0], src[1]];
  const { offset, source } = src;
  return [offset, offset + (typeof source === "string" ? source.length : 1)];
}
function parsePrelude(prelude) {
  var _a;
  let comment = "";
  let atComment = false;
  let afterEmptyLine = false;
  for (let i = 0; i < prelude.length; ++i) {
    const source = prelude[i];
    switch (source[0]) {
      case "#":
        comment += (comment === "" ? "" : afterEmptyLine ? "\n\n" : "\n") + (source.substring(1) || " ");
        atComment = true;
        afterEmptyLine = false;
        break;
      case "%":
        if (((_a = prelude[i + 1]) === null || _a === void 0 ? void 0 : _a[0]) !== "#")
          i += 1;
        atComment = false;
        break;
      default:
        if (!atComment)
          afterEmptyLine = true;
        atComment = false;
    }
  }
  return { comment, afterEmptyLine };
}
var Composer = class {
  constructor(options = {}) {
    this.doc = null;
    this.atDirectives = false;
    this.prelude = [];
    this.errors = [];
    this.warnings = [];
    this.onError = (source, code, message, warning) => {
      const pos = getErrorPos(source);
      if (warning)
        this.warnings.push(new YAMLWarning(pos, code, message));
      else
        this.errors.push(new YAMLParseError(pos, code, message));
    };
    this.directives = new Directives({
      version: options.version || defaultOptions.version
    });
    this.options = options;
  }
  decorate(doc, afterDoc) {
    const { comment, afterEmptyLine } = parsePrelude(this.prelude);
    if (comment) {
      const dc = doc.contents;
      if (afterDoc) {
        doc.comment = doc.comment ? `${doc.comment}
${comment}` : comment;
      } else if (afterEmptyLine || doc.directives.marker || !dc) {
        doc.commentBefore = comment;
      } else if (isCollection(dc) && !dc.flow && dc.items.length > 0) {
        let it = dc.items[0];
        if (isPair(it))
          it = it.key;
        const cb = it.commentBefore;
        it.commentBefore = cb ? `${comment}
${cb}` : comment;
      } else {
        const cb = dc.commentBefore;
        dc.commentBefore = cb ? `${comment}
${cb}` : comment;
      }
    }
    if (afterDoc) {
      Array.prototype.push.apply(doc.errors, this.errors);
      Array.prototype.push.apply(doc.warnings, this.warnings);
    } else {
      doc.errors = this.errors;
      doc.warnings = this.warnings;
    }
    this.prelude = [];
    this.errors = [];
    this.warnings = [];
  }
  /**
   * Current stream status information.
   *
   * Mostly useful at the end of input for an empty stream.
   */
  streamInfo() {
    return {
      comment: parsePrelude(this.prelude).comment,
      directives: this.directives,
      errors: this.errors,
      warnings: this.warnings
    };
  }
  /**
   * Compose tokens into documents.
   *
   * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
   * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
   */
  *compose(tokens, forceDoc = false, endOffset = -1) {
    for (const token of tokens)
      yield* this.next(token);
    yield* this.end(forceDoc, endOffset);
  }
  /** Advance the composer by one CST token. */
  *next(token) {
    switch (token.type) {
      case "directive":
        this.directives.add(token.source, (offset, message, warning) => {
          const pos = getErrorPos(token);
          pos[0] += offset;
          this.onError(pos, "BAD_DIRECTIVE", message, warning);
        });
        this.prelude.push(token.source);
        this.atDirectives = true;
        break;
      case "document": {
        const doc = composeDoc(this.options, this.directives, token, this.onError);
        if (this.atDirectives && !doc.directives.marker)
          this.onError(token, "MISSING_CHAR", "Missing directives-end indicator line");
        this.decorate(doc, false);
        if (this.doc)
          yield this.doc;
        this.doc = doc;
        this.atDirectives = false;
        break;
      }
      case "byte-order-mark":
      case "space":
        break;
      case "comment":
      case "newline":
        this.prelude.push(token.source);
        break;
      case "error": {
        const msg = token.source ? `${token.message}: ${JSON.stringify(token.source)}` : token.message;
        const error = new YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", msg);
        if (this.atDirectives || !this.doc)
          this.errors.push(error);
        else
          this.doc.errors.push(error);
        break;
      }
      case "doc-end": {
        if (!this.doc) {
          const msg = "Unexpected doc-end without preceding document";
          this.errors.push(new YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", msg));
          break;
        }
        const end = resolveEnd(token.end, token.offset + token.source.length, this.doc.options.strict, this.onError);
        this.decorate(this.doc, true);
        if (end.comment) {
          const dc = this.doc.comment;
          this.doc.comment = dc ? `${dc}
${end.comment}` : end.comment;
        }
        this.doc.range[2] = end.offset;
        break;
      }
      default:
        this.errors.push(new YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", `Unsupported token ${token.type}`));
    }
  }
  /**
   * Call at end of input to yield any remaining document.
   *
   * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
   * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
   */
  *end(forceDoc = false, endOffset = -1) {
    if (this.doc) {
      this.decorate(this.doc, true);
      yield this.doc;
      this.doc = null;
    } else if (forceDoc) {
      const opts = Object.assign({ directives: this.directives }, this.options);
      const doc = new Document(void 0, opts);
      if (this.atDirectives)
        this.onError(endOffset, "MISSING_CHAR", "Missing directives-end indicator line");
      doc.range = [0, endOffset, endOffset];
      this.decorate(doc, false);
      yield doc;
    }
  }
};

// node_modules/yaml/browser/dist/parse/cst.js
var cst_exports = {};
__export(cst_exports, {
  BOM: () => BOM,
  DOCUMENT: () => DOCUMENT,
  FLOW_END: () => FLOW_END,
  SCALAR: () => SCALAR2,
  createScalarToken: () => createScalarToken,
  isCollection: () => isCollection2,
  isScalar: () => isScalar2,
  prettyToken: () => prettyToken,
  resolveAsScalar: () => resolveAsScalar,
  setScalarValue: () => setScalarValue,
  stringify: () => stringify2,
  tokenType: () => tokenType,
  visit: () => visit2
});

// node_modules/yaml/browser/dist/parse/cst-scalar.js
function resolveAsScalar(token, strict = true, onError) {
  if (token) {
    const _onError = (pos, code, message) => {
      const offset = typeof pos === "number" ? pos : Array.isArray(pos) ? pos[0] : pos.offset;
      if (onError)
        onError(offset, code, message);
      else
        throw new YAMLParseError([offset, offset + 1], code, message);
    };
    switch (token.type) {
      case "scalar":
      case "single-quoted-scalar":
      case "double-quoted-scalar":
        return resolveFlowScalar(token, strict, _onError);
      case "block-scalar":
        return resolveBlockScalar(token, strict, _onError);
    }
  }
  return null;
}
function createScalarToken(value, context) {
  var _a;
  const { implicitKey = false, indent, inFlow = false, offset = -1, type = "PLAIN" } = context;
  const source = stringifyString({ type, value }, {
    implicitKey,
    indent: indent > 0 ? " ".repeat(indent) : "",
    inFlow,
    options: { blockQuote: true, lineWidth: -1 }
  });
  const end = (_a = context.end) !== null && _a !== void 0 ? _a : [
    { type: "newline", offset: -1, indent, source: "\n" }
  ];
  switch (source[0]) {
    case "|":
    case ">": {
      const he = source.indexOf("\n");
      const head = source.substring(0, he);
      const body = source.substring(he + 1) + "\n";
      const props = [
        { type: "block-scalar-header", offset, indent, source: head }
      ];
      if (!addEndtoBlockProps(props, end))
        props.push({ type: "newline", offset: -1, indent, source: "\n" });
      return { type: "block-scalar", offset, indent, props, source: body };
    }
    case '"':
      return { type: "double-quoted-scalar", offset, indent, source, end };
    case "'":
      return { type: "single-quoted-scalar", offset, indent, source, end };
    default:
      return { type: "scalar", offset, indent, source, end };
  }
}
function setScalarValue(token, value, context = {}) {
  let { afterKey = false, implicitKey = false, inFlow = false, type } = context;
  let indent = "indent" in token ? token.indent : null;
  if (afterKey && typeof indent === "number")
    indent += 2;
  if (!type)
    switch (token.type) {
      case "single-quoted-scalar":
        type = "QUOTE_SINGLE";
        break;
      case "double-quoted-scalar":
        type = "QUOTE_DOUBLE";
        break;
      case "block-scalar": {
        const header = token.props[0];
        if (header.type !== "block-scalar-header")
          throw new Error("Invalid block scalar header");
        type = header.source[0] === ">" ? "BLOCK_FOLDED" : "BLOCK_LITERAL";
        break;
      }
      default:
        type = "PLAIN";
    }
  const source = stringifyString({ type, value }, {
    implicitKey: implicitKey || indent === null,
    indent: indent !== null && indent > 0 ? " ".repeat(indent) : "",
    inFlow,
    options: { blockQuote: true, lineWidth: -1 }
  });
  switch (source[0]) {
    case "|":
    case ">":
      setBlockScalarValue(token, source);
      break;
    case '"':
      setFlowScalarValue(token, source, "double-quoted-scalar");
      break;
    case "'":
      setFlowScalarValue(token, source, "single-quoted-scalar");
      break;
    default:
      setFlowScalarValue(token, source, "scalar");
  }
}
function setBlockScalarValue(token, source) {
  const he = source.indexOf("\n");
  const head = source.substring(0, he);
  const body = source.substring(he + 1) + "\n";
  if (token.type === "block-scalar") {
    const header = token.props[0];
    if (header.type !== "block-scalar-header")
      throw new Error("Invalid block scalar header");
    header.source = head;
    token.source = body;
  } else {
    const { offset } = token;
    const indent = "indent" in token ? token.indent : -1;
    const props = [
      { type: "block-scalar-header", offset, indent, source: head }
    ];
    if (!addEndtoBlockProps(props, "end" in token ? token.end : void 0))
      props.push({ type: "newline", offset: -1, indent, source: "\n" });
    for (const key of Object.keys(token))
      if (key !== "type" && key !== "offset")
        delete token[key];
    Object.assign(token, { type: "block-scalar", indent, props, source: body });
  }
}
function addEndtoBlockProps(props, end) {
  if (end)
    for (const st of end)
      switch (st.type) {
        case "space":
        case "comment":
          props.push(st);
          break;
        case "newline":
          props.push(st);
          return true;
      }
  return false;
}
function setFlowScalarValue(token, source, type) {
  switch (token.type) {
    case "scalar":
    case "double-quoted-scalar":
    case "single-quoted-scalar":
      token.type = type;
      token.source = source;
      break;
    case "block-scalar": {
      const end = token.props.slice(1);
      let oa = source.length;
      if (token.props[0].type === "block-scalar-header")
        oa -= token.props[0].source.length;
      for (const tok of end)
        tok.offset += oa;
      delete token.props;
      Object.assign(token, { type, source, end });
      break;
    }
    case "block-map":
    case "block-seq": {
      const offset = token.offset + source.length;
      const nl = { type: "newline", offset, indent: token.indent, source: "\n" };
      delete token.items;
      Object.assign(token, { type, source, end: [nl] });
      break;
    }
    default: {
      const indent = "indent" in token ? token.indent : -1;
      const end = "end" in token && Array.isArray(token.end) ? token.end.filter((st) => st.type === "space" || st.type === "comment" || st.type === "newline") : [];
      for (const key of Object.keys(token))
        if (key !== "type" && key !== "offset")
          delete token[key];
      Object.assign(token, { type, indent, source, end });
    }
  }
}

// node_modules/yaml/browser/dist/parse/cst-stringify.js
var stringify2 = (cst) => "type" in cst ? stringifyToken(cst) : stringifyItem(cst);
function stringifyToken(token) {
  switch (token.type) {
    case "block-scalar": {
      let res = "";
      for (const tok of token.props)
        res += stringifyToken(tok);
      return res + token.source;
    }
    case "block-map":
    case "block-seq": {
      let res = "";
      for (const item of token.items)
        res += stringifyItem(item);
      return res;
    }
    case "flow-collection": {
      let res = token.start.source;
      for (const item of token.items)
        res += stringifyItem(item);
      for (const st of token.end)
        res += st.source;
      return res;
    }
    case "document": {
      let res = stringifyItem(token);
      if (token.end)
        for (const st of token.end)
          res += st.source;
      return res;
    }
    default: {
      let res = token.source;
      if ("end" in token && token.end)
        for (const st of token.end)
          res += st.source;
      return res;
    }
  }
}
function stringifyItem({ start, key, sep, value }) {
  let res = "";
  for (const st of start)
    res += st.source;
  if (key)
    res += stringifyToken(key);
  if (sep)
    for (const st of sep)
      res += st.source;
  if (value)
    res += stringifyToken(value);
  return res;
}

// node_modules/yaml/browser/dist/parse/cst-visit.js
var BREAK2 = Symbol("break visit");
var SKIP2 = Symbol("skip children");
var REMOVE2 = Symbol("remove item");
function visit2(cst, visitor) {
  if ("type" in cst && cst.type === "document")
    cst = { start: cst.start, value: cst.value };
  _visit2(Object.freeze([]), cst, visitor);
}
visit2.BREAK = BREAK2;
visit2.SKIP = SKIP2;
visit2.REMOVE = REMOVE2;
visit2.itemAtPath = (cst, path) => {
  let item = cst;
  for (const [field, index] of path) {
    const tok = item && item[field];
    if (tok && "items" in tok) {
      item = tok.items[index];
    } else
      return void 0;
  }
  return item;
};
visit2.parentCollection = (cst, path) => {
  const parent = visit2.itemAtPath(cst, path.slice(0, -1));
  const field = path[path.length - 1][0];
  const coll = parent && parent[field];
  if (coll && "items" in coll)
    return coll;
  throw new Error("Parent collection not found");
};
function _visit2(path, item, visitor) {
  let ctrl = visitor(item, path);
  if (typeof ctrl === "symbol")
    return ctrl;
  for (const field of ["key", "value"]) {
    const token = item[field];
    if (token && "items" in token) {
      for (let i = 0; i < token.items.length; ++i) {
        const ci = _visit2(Object.freeze(path.concat([[field, i]])), token.items[i], visitor);
        if (typeof ci === "number")
          i = ci - 1;
        else if (ci === BREAK2)
          return BREAK2;
        else if (ci === REMOVE2) {
          token.items.splice(i, 1);
          i -= 1;
        }
      }
      if (typeof ctrl === "function" && field === "key")
        ctrl = ctrl(item, path);
    }
  }
  return typeof ctrl === "function" ? ctrl(item, path) : ctrl;
}

// node_modules/yaml/browser/dist/parse/cst.js
var BOM = "\uFEFF";
var DOCUMENT = "";
var FLOW_END = "";
var SCALAR2 = "";
var isCollection2 = (token) => !!token && "items" in token;
var isScalar2 = (token) => !!token && (token.type === "scalar" || token.type === "single-quoted-scalar" || token.type === "double-quoted-scalar" || token.type === "block-scalar");
function prettyToken(token) {
  switch (token) {
    case BOM:
      return "<BOM>";
    case DOCUMENT:
      return "<DOC>";
    case FLOW_END:
      return "<FLOW_END>";
    case SCALAR2:
      return "<SCALAR>";
    default:
      return JSON.stringify(token);
  }
}
function tokenType(source) {
  switch (source) {
    case BOM:
      return "byte-order-mark";
    case DOCUMENT:
      return "doc-mode";
    case FLOW_END:
      return "flow-error-end";
    case SCALAR2:
      return "scalar";
    case "---":
      return "doc-start";
    case "...":
      return "doc-end";
    case "":
    case "\n":
    case "\r\n":
      return "newline";
    case "-":
      return "seq-item-ind";
    case "?":
      return "explicit-key-ind";
    case ":":
      return "map-value-ind";
    case "{":
      return "flow-map-start";
    case "}":
      return "flow-map-end";
    case "[":
      return "flow-seq-start";
    case "]":
      return "flow-seq-end";
    case ",":
      return "comma";
  }
  switch (source[0]) {
    case " ":
    case "	":
      return "space";
    case "#":
      return "comment";
    case "%":
      return "directive-line";
    case "*":
      return "alias";
    case "&":
      return "anchor";
    case "!":
      return "tag";
    case "'":
      return "single-quoted-scalar";
    case '"':
      return "double-quoted-scalar";
    case "|":
    case ">":
      return "block-scalar-header";
  }
  return null;
}

// node_modules/yaml/browser/dist/parse/lexer.js
function isEmpty(ch) {
  switch (ch) {
    case void 0:
    case " ":
    case "\n":
    case "\r":
    case "	":
      return true;
    default:
      return false;
  }
}
var hexDigits = "0123456789ABCDEFabcdef".split("");
var tagChars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-#;/?:@&=+$_.!~*'()".split("");
var invalidFlowScalarChars = ",[]{}".split("");
var invalidAnchorChars = " ,[]{}\n\r	".split("");
var isNotAnchorChar = (ch) => !ch || invalidAnchorChars.includes(ch);
var Lexer = class {
  constructor() {
    this.atEnd = false;
    this.blockScalarIndent = -1;
    this.blockScalarKeep = false;
    this.buffer = "";
    this.flowKey = false;
    this.flowLevel = 0;
    this.indentNext = 0;
    this.indentValue = 0;
    this.lineEndPos = null;
    this.next = null;
    this.pos = 0;
  }
  /**
   * Generate YAML tokens from the `source` string. If `incomplete`,
   * a part of the last line may be left as a buffer for the next call.
   *
   * @returns A generator of lexical tokens
   */
  *lex(source, incomplete = false) {
    if (source) {
      this.buffer = this.buffer ? this.buffer + source : source;
      this.lineEndPos = null;
    }
    this.atEnd = !incomplete;
    let next = this.next || "stream";
    while (next && (incomplete || this.hasChars(1)))
      next = yield* this.parseNext(next);
  }
  atLineEnd() {
    let i = this.pos;
    let ch = this.buffer[i];
    while (ch === " " || ch === "	")
      ch = this.buffer[++i];
    if (!ch || ch === "#" || ch === "\n")
      return true;
    if (ch === "\r")
      return this.buffer[i + 1] === "\n";
    return false;
  }
  charAt(n) {
    return this.buffer[this.pos + n];
  }
  continueScalar(offset) {
    let ch = this.buffer[offset];
    if (this.indentNext > 0) {
      let indent = 0;
      while (ch === " ")
        ch = this.buffer[++indent + offset];
      if (ch === "\r") {
        const next = this.buffer[indent + offset + 1];
        if (next === "\n" || !next && !this.atEnd)
          return offset + indent + 1;
      }
      return ch === "\n" || indent >= this.indentNext || !ch && !this.atEnd ? offset + indent : -1;
    }
    if (ch === "-" || ch === ".") {
      const dt = this.buffer.substr(offset, 3);
      if ((dt === "---" || dt === "...") && isEmpty(this.buffer[offset + 3]))
        return -1;
    }
    return offset;
  }
  getLine() {
    let end = this.lineEndPos;
    if (typeof end !== "number" || end !== -1 && end < this.pos) {
      end = this.buffer.indexOf("\n", this.pos);
      this.lineEndPos = end;
    }
    if (end === -1)
      return this.atEnd ? this.buffer.substring(this.pos) : null;
    if (this.buffer[end - 1] === "\r")
      end -= 1;
    return this.buffer.substring(this.pos, end);
  }
  hasChars(n) {
    return this.pos + n <= this.buffer.length;
  }
  setNext(state) {
    this.buffer = this.buffer.substring(this.pos);
    this.pos = 0;
    this.lineEndPos = null;
    this.next = state;
    return null;
  }
  peek(n) {
    return this.buffer.substr(this.pos, n);
  }
  *parseNext(next) {
    switch (next) {
      case "stream":
        return yield* this.parseStream();
      case "line-start":
        return yield* this.parseLineStart();
      case "block-start":
        return yield* this.parseBlockStart();
      case "doc":
        return yield* this.parseDocument();
      case "flow":
        return yield* this.parseFlowCollection();
      case "quoted-scalar":
        return yield* this.parseQuotedScalar();
      case "block-scalar":
        return yield* this.parseBlockScalar();
      case "plain-scalar":
        return yield* this.parsePlainScalar();
    }
  }
  *parseStream() {
    let line = this.getLine();
    if (line === null)
      return this.setNext("stream");
    if (line[0] === BOM) {
      yield* this.pushCount(1);
      line = line.substring(1);
    }
    if (line[0] === "%") {
      let dirEnd = line.length;
      const cs = line.indexOf("#");
      if (cs !== -1) {
        const ch = line[cs - 1];
        if (ch === " " || ch === "	")
          dirEnd = cs - 1;
      }
      while (true) {
        const ch = line[dirEnd - 1];
        if (ch === " " || ch === "	")
          dirEnd -= 1;
        else
          break;
      }
      const n = (yield* this.pushCount(dirEnd)) + (yield* this.pushSpaces(true));
      yield* this.pushCount(line.length - n);
      this.pushNewline();
      return "stream";
    }
    if (this.atLineEnd()) {
      const sp = yield* this.pushSpaces(true);
      yield* this.pushCount(line.length - sp);
      yield* this.pushNewline();
      return "stream";
    }
    yield DOCUMENT;
    return yield* this.parseLineStart();
  }
  *parseLineStart() {
    const ch = this.charAt(0);
    if (!ch && !this.atEnd)
      return this.setNext("line-start");
    if (ch === "-" || ch === ".") {
      if (!this.atEnd && !this.hasChars(4))
        return this.setNext("line-start");
      const s = this.peek(3);
      if (s === "---" && isEmpty(this.charAt(3))) {
        yield* this.pushCount(3);
        this.indentValue = 0;
        this.indentNext = 0;
        return "doc";
      } else if (s === "..." && isEmpty(this.charAt(3))) {
        yield* this.pushCount(3);
        return "stream";
      }
    }
    this.indentValue = yield* this.pushSpaces(false);
    if (this.indentNext > this.indentValue && !isEmpty(this.charAt(1)))
      this.indentNext = this.indentValue;
    return yield* this.parseBlockStart();
  }
  *parseBlockStart() {
    const [ch0, ch1] = this.peek(2);
    if (!ch1 && !this.atEnd)
      return this.setNext("block-start");
    if ((ch0 === "-" || ch0 === "?" || ch0 === ":") && isEmpty(ch1)) {
      const n = (yield* this.pushCount(1)) + (yield* this.pushSpaces(true));
      this.indentNext = this.indentValue + 1;
      this.indentValue += n;
      return yield* this.parseBlockStart();
    }
    return "doc";
  }
  *parseDocument() {
    yield* this.pushSpaces(true);
    const line = this.getLine();
    if (line === null)
      return this.setNext("doc");
    let n = yield* this.pushIndicators();
    switch (line[n]) {
      case "#":
        yield* this.pushCount(line.length - n);
      case void 0:
        yield* this.pushNewline();
        return yield* this.parseLineStart();
      case "{":
      case "[":
        yield* this.pushCount(1);
        this.flowKey = false;
        this.flowLevel = 1;
        return "flow";
      case "}":
      case "]":
        yield* this.pushCount(1);
        return "doc";
      case "*":
        yield* this.pushUntil(isNotAnchorChar);
        return "doc";
      case '"':
      case "'":
        return yield* this.parseQuotedScalar();
      case "|":
      case ">":
        n += yield* this.parseBlockScalarHeader();
        n += yield* this.pushSpaces(true);
        yield* this.pushCount(line.length - n);
        yield* this.pushNewline();
        return yield* this.parseBlockScalar();
      default:
        return yield* this.parsePlainScalar();
    }
  }
  *parseFlowCollection() {
    let nl, sp;
    let indent = -1;
    do {
      nl = yield* this.pushNewline();
      sp = yield* this.pushSpaces(true);
      if (nl > 0)
        this.indentValue = indent = sp;
    } while (nl + sp > 0);
    const line = this.getLine();
    if (line === null)
      return this.setNext("flow");
    if (indent !== -1 && indent < this.indentNext && line[0] !== "#" || indent === 0 && (line.startsWith("---") || line.startsWith("...")) && isEmpty(line[3])) {
      const atFlowEndMarker = indent === this.indentNext - 1 && this.flowLevel === 1 && (line[0] === "]" || line[0] === "}");
      if (!atFlowEndMarker) {
        this.flowLevel = 0;
        yield FLOW_END;
        return yield* this.parseLineStart();
      }
    }
    let n = 0;
    while (line[n] === ",") {
      n += yield* this.pushCount(1);
      n += yield* this.pushSpaces(true);
      this.flowKey = false;
    }
    n += yield* this.pushIndicators();
    switch (line[n]) {
      case void 0:
        return "flow";
      case "#":
        yield* this.pushCount(line.length - n);
        return "flow";
      case "{":
      case "[":
        yield* this.pushCount(1);
        this.flowKey = false;
        this.flowLevel += 1;
        return "flow";
      case "}":
      case "]":
        yield* this.pushCount(1);
        this.flowKey = true;
        this.flowLevel -= 1;
        return this.flowLevel ? "flow" : "doc";
      case "*":
        yield* this.pushUntil(isNotAnchorChar);
        return "flow";
      case '"':
      case "'":
        this.flowKey = true;
        return yield* this.parseQuotedScalar();
      case ":": {
        const next = this.charAt(1);
        if (this.flowKey || isEmpty(next) || next === ",") {
          this.flowKey = false;
          yield* this.pushCount(1);
          yield* this.pushSpaces(true);
          return "flow";
        }
      }
      default:
        this.flowKey = false;
        return yield* this.parsePlainScalar();
    }
  }
  *parseQuotedScalar() {
    const quote = this.charAt(0);
    let end = this.buffer.indexOf(quote, this.pos + 1);
    if (quote === "'") {
      while (end !== -1 && this.buffer[end + 1] === "'")
        end = this.buffer.indexOf("'", end + 2);
    } else {
      while (end !== -1) {
        let n = 0;
        while (this.buffer[end - 1 - n] === "\\")
          n += 1;
        if (n % 2 === 0)
          break;
        end = this.buffer.indexOf('"', end + 1);
      }
    }
    const qb = this.buffer.substring(0, end);
    let nl = qb.indexOf("\n", this.pos);
    if (nl !== -1) {
      while (nl !== -1) {
        const cs = this.continueScalar(nl + 1);
        if (cs === -1)
          break;
        nl = qb.indexOf("\n", cs);
      }
      if (nl !== -1) {
        end = nl - (qb[nl - 1] === "\r" ? 2 : 1);
      }
    }
    if (end === -1) {
      if (!this.atEnd)
        return this.setNext("quoted-scalar");
      end = this.buffer.length;
    }
    yield* this.pushToIndex(end + 1, false);
    return this.flowLevel ? "flow" : "doc";
  }
  *parseBlockScalarHeader() {
    this.blockScalarIndent = -1;
    this.blockScalarKeep = false;
    let i = this.pos;
    while (true) {
      const ch = this.buffer[++i];
      if (ch === "+")
        this.blockScalarKeep = true;
      else if (ch > "0" && ch <= "9")
        this.blockScalarIndent = Number(ch) - 1;
      else if (ch !== "-")
        break;
    }
    return yield* this.pushUntil((ch) => isEmpty(ch) || ch === "#");
  }
  *parseBlockScalar() {
    let nl = this.pos - 1;
    let indent = 0;
    let ch;
    loop:
      for (let i = this.pos; ch = this.buffer[i]; ++i) {
        switch (ch) {
          case " ":
            indent += 1;
            break;
          case "\n":
            nl = i;
            indent = 0;
            break;
          case "\r": {
            const next = this.buffer[i + 1];
            if (!next && !this.atEnd)
              return this.setNext("block-scalar");
            if (next === "\n")
              break;
          }
          default:
            break loop;
        }
      }
    if (!ch && !this.atEnd)
      return this.setNext("block-scalar");
    if (indent >= this.indentNext) {
      if (this.blockScalarIndent === -1)
        this.indentNext = indent;
      else
        this.indentNext += this.blockScalarIndent;
      do {
        const cs = this.continueScalar(nl + 1);
        if (cs === -1)
          break;
        nl = this.buffer.indexOf("\n", cs);
      } while (nl !== -1);
      if (nl === -1) {
        if (!this.atEnd)
          return this.setNext("block-scalar");
        nl = this.buffer.length;
      }
    }
    if (!this.blockScalarKeep) {
      do {
        let i = nl - 1;
        let ch2 = this.buffer[i];
        if (ch2 === "\r")
          ch2 = this.buffer[--i];
        while (ch2 === " " || ch2 === "	")
          ch2 = this.buffer[--i];
        if (ch2 === "\n" && i >= this.pos)
          nl = i;
        else
          break;
      } while (true);
    }
    yield SCALAR2;
    yield* this.pushToIndex(nl + 1, true);
    return yield* this.parseLineStart();
  }
  *parsePlainScalar() {
    const inFlow = this.flowLevel > 0;
    let end = this.pos - 1;
    let i = this.pos - 1;
    let ch;
    while (ch = this.buffer[++i]) {
      if (ch === ":") {
        const next = this.buffer[i + 1];
        if (isEmpty(next) || inFlow && next === ",")
          break;
        end = i;
      } else if (isEmpty(ch)) {
        let next = this.buffer[i + 1];
        if (ch === "\r") {
          if (next === "\n") {
            i += 1;
            ch = "\n";
            next = this.buffer[i + 1];
          } else
            end = i;
        }
        if (next === "#" || inFlow && invalidFlowScalarChars.includes(next))
          break;
        if (ch === "\n") {
          const cs = this.continueScalar(i + 1);
          if (cs === -1)
            break;
          i = Math.max(i, cs - 2);
        }
      } else {
        if (inFlow && invalidFlowScalarChars.includes(ch))
          break;
        end = i;
      }
    }
    if (!ch && !this.atEnd)
      return this.setNext("plain-scalar");
    yield SCALAR2;
    yield* this.pushToIndex(end + 1, true);
    return inFlow ? "flow" : "doc";
  }
  *pushCount(n) {
    if (n > 0) {
      yield this.buffer.substr(this.pos, n);
      this.pos += n;
      return n;
    }
    return 0;
  }
  *pushToIndex(i, allowEmpty) {
    const s = this.buffer.slice(this.pos, i);
    if (s) {
      yield s;
      this.pos += s.length;
      return s.length;
    } else if (allowEmpty)
      yield "";
    return 0;
  }
  *pushIndicators() {
    switch (this.charAt(0)) {
      case "!":
        return (yield* this.pushTag()) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
      case "&":
        return (yield* this.pushUntil(isNotAnchorChar)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
      case ":":
      case "?":
      case "-":
        if (isEmpty(this.charAt(1))) {
          if (this.flowLevel === 0)
            this.indentNext = this.indentValue + 1;
          else if (this.flowKey)
            this.flowKey = false;
          return (yield* this.pushCount(1)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
        }
    }
    return 0;
  }
  *pushTag() {
    if (this.charAt(1) === "<") {
      let i = this.pos + 2;
      let ch = this.buffer[i];
      while (!isEmpty(ch) && ch !== ">")
        ch = this.buffer[++i];
      return yield* this.pushToIndex(ch === ">" ? i + 1 : i, false);
    } else {
      let i = this.pos + 1;
      let ch = this.buffer[i];
      while (ch) {
        if (tagChars.includes(ch))
          ch = this.buffer[++i];
        else if (ch === "%" && hexDigits.includes(this.buffer[i + 1]) && hexDigits.includes(this.buffer[i + 2])) {
          ch = this.buffer[i += 3];
        } else
          break;
      }
      return yield* this.pushToIndex(i, false);
    }
  }
  *pushNewline() {
    const ch = this.buffer[this.pos];
    if (ch === "\n")
      return yield* this.pushCount(1);
    else if (ch === "\r" && this.charAt(1) === "\n")
      return yield* this.pushCount(2);
    else
      return 0;
  }
  *pushSpaces(allowTabs) {
    let i = this.pos - 1;
    let ch;
    do {
      ch = this.buffer[++i];
    } while (ch === " " || allowTabs && ch === "	");
    const n = i - this.pos;
    if (n > 0) {
      yield this.buffer.substr(this.pos, n);
      this.pos = i;
    }
    return n;
  }
  *pushUntil(test) {
    let i = this.pos;
    let ch = this.buffer[i];
    while (!test(ch))
      ch = this.buffer[++i];
    return yield* this.pushToIndex(i, false);
  }
};

// node_modules/yaml/browser/dist/parse/line-counter.js
var LineCounter = class {
  constructor() {
    this.lineStarts = [];
    this.addNewLine = (offset) => this.lineStarts.push(offset);
    this.linePos = (offset) => {
      let low = 0;
      let high = this.lineStarts.length;
      while (low < high) {
        const mid = low + high >> 1;
        if (this.lineStarts[mid] < offset)
          low = mid + 1;
        else
          high = mid;
      }
      if (this.lineStarts[low] === offset)
        return { line: low + 1, col: 1 };
      if (low === 0)
        return { line: 0, col: offset };
      const start = this.lineStarts[low - 1];
      return { line: low, col: offset - start + 1 };
    };
  }
};

// node_modules/yaml/browser/dist/parse/parser.js
function includesToken(list, type) {
  for (let i = 0; i < list.length; ++i)
    if (list[i].type === type)
      return true;
  return false;
}
function includesNonEmpty(list) {
  for (let i = 0; i < list.length; ++i) {
    switch (list[i].type) {
      case "space":
      case "comment":
      case "newline":
        break;
      default:
        return true;
    }
  }
  return false;
}
function isFlowToken(token) {
  switch (token === null || token === void 0 ? void 0 : token.type) {
    case "alias":
    case "scalar":
    case "single-quoted-scalar":
    case "double-quoted-scalar":
    case "flow-collection":
      return true;
    default:
      return false;
  }
}
function getPrevProps(parent) {
  switch (parent.type) {
    case "document":
      return parent.start;
    case "block-map": {
      const it = parent.items[parent.items.length - 1];
      return it.sep || it.start;
    }
    case "block-seq":
      return parent.items[parent.items.length - 1].start;
    default:
      return [];
  }
}
function getFirstKeyStartProps(prev) {
  var _a;
  if (prev.length === 0)
    return [];
  let i = prev.length;
  loop:
    while (--i >= 0) {
      switch (prev[i].type) {
        case "doc-start":
        case "explicit-key-ind":
        case "map-value-ind":
        case "seq-item-ind":
        case "newline":
          break loop;
      }
    }
  while (((_a = prev[++i]) === null || _a === void 0 ? void 0 : _a.type) === "space") {
  }
  return prev.splice(i, prev.length);
}
function fixFlowSeqItems(fc) {
  if (fc.start.type === "flow-seq-start") {
    for (const it of fc.items) {
      if (it.sep && !it.value && !includesToken(it.start, "explicit-key-ind") && !includesToken(it.sep, "map-value-ind")) {
        if (it.key)
          it.value = it.key;
        delete it.key;
        if (isFlowToken(it.value)) {
          if (it.value.end)
            Array.prototype.push.apply(it.value.end, it.sep);
          else
            it.value.end = it.sep;
        } else
          Array.prototype.push.apply(it.start, it.sep);
        delete it.sep;
      }
    }
  }
}
var Parser = class {
  /**
   * @param onNewLine - If defined, called separately with the start position of
   *   each new line (in `parse()`, including the start of input).
   */
  constructor(onNewLine) {
    this.atNewLine = true;
    this.atScalar = false;
    this.indent = 0;
    this.offset = 0;
    this.onKeyLine = false;
    this.stack = [];
    this.source = "";
    this.type = "";
    this.lexer = new Lexer();
    this.onNewLine = onNewLine;
  }
  /**
   * Parse `source` as a YAML stream.
   * If `incomplete`, a part of the last line may be left as a buffer for the next call.
   *
   * Errors are not thrown, but yielded as `{ type: 'error', message }` tokens.
   *
   * @returns A generator of tokens representing each directive, document, and other structure.
   */
  *parse(source, incomplete = false) {
    if (this.onNewLine && this.offset === 0)
      this.onNewLine(0);
    for (const lexeme of this.lexer.lex(source, incomplete))
      yield* this.next(lexeme);
    if (!incomplete)
      yield* this.end();
  }
  /**
   * Advance the parser by the `source` of one lexical token.
   */
  *next(source) {
    this.source = source;
    if (this.atScalar) {
      this.atScalar = false;
      yield* this.step();
      this.offset += source.length;
      return;
    }
    const type = tokenType(source);
    if (!type) {
      const message = `Not a YAML token: ${source}`;
      yield* this.pop({ type: "error", offset: this.offset, message, source });
      this.offset += source.length;
    } else if (type === "scalar") {
      this.atNewLine = false;
      this.atScalar = true;
      this.type = "scalar";
    } else {
      this.type = type;
      yield* this.step();
      switch (type) {
        case "newline":
          this.atNewLine = true;
          this.indent = 0;
          if (this.onNewLine)
            this.onNewLine(this.offset + source.length);
          break;
        case "space":
          if (this.atNewLine && source[0] === " ")
            this.indent += source.length;
          break;
        case "explicit-key-ind":
        case "map-value-ind":
        case "seq-item-ind":
          if (this.atNewLine)
            this.indent += source.length;
          break;
        case "doc-mode":
        case "flow-error-end":
          return;
        default:
          this.atNewLine = false;
      }
      this.offset += source.length;
    }
  }
  /** Call at end of input to push out any remaining constructions */
  *end() {
    while (this.stack.length > 0)
      yield* this.pop();
  }
  get sourceToken() {
    const st = {
      type: this.type,
      offset: this.offset,
      indent: this.indent,
      source: this.source
    };
    return st;
  }
  *step() {
    const top = this.peek(1);
    if (this.type === "doc-end" && (!top || top.type !== "doc-end")) {
      while (this.stack.length > 0)
        yield* this.pop();
      this.stack.push({
        type: "doc-end",
        offset: this.offset,
        source: this.source
      });
      return;
    }
    if (!top)
      return yield* this.stream();
    switch (top.type) {
      case "document":
        return yield* this.document(top);
      case "alias":
      case "scalar":
      case "single-quoted-scalar":
      case "double-quoted-scalar":
        return yield* this.scalar(top);
      case "block-scalar":
        return yield* this.blockScalar(top);
      case "block-map":
        return yield* this.blockMap(top);
      case "block-seq":
        return yield* this.blockSequence(top);
      case "flow-collection":
        return yield* this.flowCollection(top);
      case "doc-end":
        return yield* this.documentEnd(top);
    }
    yield* this.pop();
  }
  peek(n) {
    return this.stack[this.stack.length - n];
  }
  *pop(error) {
    const token = error || this.stack.pop();
    if (!token) {
      const message = "Tried to pop an empty stack";
      yield { type: "error", offset: this.offset, source: "", message };
    } else if (this.stack.length === 0) {
      yield token;
    } else {
      const top = this.peek(1);
      if (token.type === "block-scalar") {
        token.indent = "indent" in top ? top.indent : 0;
      } else if (token.type === "flow-collection" && top.type === "document") {
        token.indent = 0;
      }
      if (token.type === "flow-collection")
        fixFlowSeqItems(token);
      switch (top.type) {
        case "document":
          top.value = token;
          break;
        case "block-scalar":
          top.props.push(token);
          break;
        case "block-map": {
          const it = top.items[top.items.length - 1];
          if (it.value) {
            top.items.push({ start: [], key: token, sep: [] });
            this.onKeyLine = true;
            return;
          } else if (it.sep) {
            it.value = token;
          } else {
            Object.assign(it, { key: token, sep: [] });
            this.onKeyLine = !includesToken(it.start, "explicit-key-ind");
            return;
          }
          break;
        }
        case "block-seq": {
          const it = top.items[top.items.length - 1];
          if (it.value)
            top.items.push({ start: [], value: token });
          else
            it.value = token;
          break;
        }
        case "flow-collection": {
          const it = top.items[top.items.length - 1];
          if (!it || it.value)
            top.items.push({ start: [], key: token, sep: [] });
          else if (it.sep)
            it.value = token;
          else
            Object.assign(it, { key: token, sep: [] });
          return;
        }
        default:
          yield* this.pop();
          yield* this.pop(token);
      }
      if ((top.type === "document" || top.type === "block-map" || top.type === "block-seq") && (token.type === "block-map" || token.type === "block-seq")) {
        const last = token.items[token.items.length - 1];
        if (last && !last.sep && !last.value && last.start.length > 0 && !includesNonEmpty(last.start) && (token.indent === 0 || last.start.every((st) => st.type !== "comment" || st.indent < token.indent))) {
          if (top.type === "document")
            top.end = last.start;
          else
            top.items.push({ start: last.start });
          token.items.splice(-1, 1);
        }
      }
    }
  }
  *stream() {
    switch (this.type) {
      case "directive-line":
        yield { type: "directive", offset: this.offset, source: this.source };
        return;
      case "byte-order-mark":
      case "space":
      case "comment":
      case "newline":
        yield this.sourceToken;
        return;
      case "doc-mode":
      case "doc-start": {
        const doc = {
          type: "document",
          offset: this.offset,
          start: []
        };
        if (this.type === "doc-start")
          doc.start.push(this.sourceToken);
        this.stack.push(doc);
        return;
      }
    }
    yield {
      type: "error",
      offset: this.offset,
      message: `Unexpected ${this.type} token in YAML stream`,
      source: this.source
    };
  }
  *document(doc) {
    if (doc.value)
      return yield* this.lineEnd(doc);
    switch (this.type) {
      case "doc-start": {
        if (includesNonEmpty(doc.start)) {
          yield* this.pop();
          yield* this.step();
        } else
          doc.start.push(this.sourceToken);
        return;
      }
      case "anchor":
      case "tag":
      case "space":
      case "comment":
      case "newline":
        doc.start.push(this.sourceToken);
        return;
    }
    const bv = this.startBlockValue(doc);
    if (bv)
      this.stack.push(bv);
    else {
      yield {
        type: "error",
        offset: this.offset,
        message: `Unexpected ${this.type} token in YAML document`,
        source: this.source
      };
    }
  }
  *scalar(scalar) {
    if (this.type === "map-value-ind") {
      const prev = getPrevProps(this.peek(2));
      const start = getFirstKeyStartProps(prev);
      let sep;
      if (scalar.end) {
        sep = scalar.end;
        sep.push(this.sourceToken);
        delete scalar.end;
      } else
        sep = [this.sourceToken];
      const map2 = {
        type: "block-map",
        offset: scalar.offset,
        indent: scalar.indent,
        items: [{ start, key: scalar, sep }]
      };
      this.onKeyLine = true;
      this.stack[this.stack.length - 1] = map2;
    } else
      yield* this.lineEnd(scalar);
  }
  *blockScalar(scalar) {
    switch (this.type) {
      case "space":
      case "comment":
      case "newline":
        scalar.props.push(this.sourceToken);
        return;
      case "scalar":
        scalar.source = this.source;
        this.atNewLine = true;
        this.indent = 0;
        if (this.onNewLine) {
          let nl = this.source.indexOf("\n") + 1;
          while (nl !== 0) {
            this.onNewLine(this.offset + nl);
            nl = this.source.indexOf("\n", nl) + 1;
          }
        }
        yield* this.pop();
        break;
      default:
        yield* this.pop();
        yield* this.step();
    }
  }
  *blockMap(map2) {
    var _a;
    const it = map2.items[map2.items.length - 1];
    switch (this.type) {
      case "newline":
        this.onKeyLine = false;
        if (it.value) {
          const end = "end" in it.value ? it.value.end : void 0;
          const last = Array.isArray(end) ? end[end.length - 1] : void 0;
          if ((last === null || last === void 0 ? void 0 : last.type) === "comment")
            end === null || end === void 0 ? void 0 : end.push(this.sourceToken);
          else
            map2.items.push({ start: [this.sourceToken] });
        } else if (it.sep)
          it.sep.push(this.sourceToken);
        else
          it.start.push(this.sourceToken);
        return;
      case "space":
      case "comment":
        if (it.value)
          map2.items.push({ start: [this.sourceToken] });
        else if (it.sep)
          it.sep.push(this.sourceToken);
        else {
          if (this.atIndentedComment(it.start, map2.indent)) {
            const prev = map2.items[map2.items.length - 2];
            const end = (_a = prev === null || prev === void 0 ? void 0 : prev.value) === null || _a === void 0 ? void 0 : _a.end;
            if (Array.isArray(end)) {
              Array.prototype.push.apply(end, it.start);
              end.push(this.sourceToken);
              map2.items.pop();
              return;
            }
          }
          it.start.push(this.sourceToken);
        }
        return;
    }
    if (this.indent >= map2.indent) {
      const atNextItem = !this.onKeyLine && this.indent === map2.indent && (it.sep || includesNonEmpty(it.start));
      switch (this.type) {
        case "anchor":
        case "tag":
          if (atNextItem || it.value) {
            map2.items.push({ start: [this.sourceToken] });
            this.onKeyLine = true;
          } else if (it.sep)
            it.sep.push(this.sourceToken);
          else
            it.start.push(this.sourceToken);
          return;
        case "explicit-key-ind":
          if (!it.sep && !includesToken(it.start, "explicit-key-ind"))
            it.start.push(this.sourceToken);
          else if (atNextItem || it.value)
            map2.items.push({ start: [this.sourceToken] });
          else
            this.stack.push({
              type: "block-map",
              offset: this.offset,
              indent: this.indent,
              items: [{ start: [this.sourceToken] }]
            });
          this.onKeyLine = true;
          return;
        case "map-value-ind":
          if (!it.sep)
            Object.assign(it, { key: null, sep: [this.sourceToken] });
          else if (it.value || atNextItem && !includesToken(it.start, "explicit-key-ind"))
            map2.items.push({ start: [], key: null, sep: [this.sourceToken] });
          else if (includesToken(it.sep, "map-value-ind"))
            this.stack.push({
              type: "block-map",
              offset: this.offset,
              indent: this.indent,
              items: [{ start: [], key: null, sep: [this.sourceToken] }]
            });
          else if (includesToken(it.start, "explicit-key-ind") && isFlowToken(it.key) && !includesToken(it.sep, "newline")) {
            const start = getFirstKeyStartProps(it.start);
            const key = it.key;
            const sep = it.sep;
            sep.push(this.sourceToken);
            delete it.key, delete it.sep;
            this.stack.push({
              type: "block-map",
              offset: this.offset,
              indent: this.indent,
              items: [{ start, key, sep }]
            });
          } else
            it.sep.push(this.sourceToken);
          this.onKeyLine = true;
          return;
        case "alias":
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar": {
          const fs = this.flowScalar(this.type);
          if (atNextItem || it.value) {
            map2.items.push({ start: [], key: fs, sep: [] });
            this.onKeyLine = true;
          } else if (it.sep) {
            this.stack.push(fs);
          } else {
            Object.assign(it, { key: fs, sep: [] });
            this.onKeyLine = true;
          }
          return;
        }
        default: {
          const bv = this.startBlockValue(map2);
          if (bv) {
            if (atNextItem && bv.type !== "block-seq" && includesToken(it.start, "explicit-key-ind"))
              map2.items.push({ start: [] });
            this.stack.push(bv);
            return;
          }
        }
      }
    }
    yield* this.pop();
    yield* this.step();
  }
  *blockSequence(seq2) {
    var _a;
    const it = seq2.items[seq2.items.length - 1];
    switch (this.type) {
      case "newline":
        if (it.value) {
          const end = "end" in it.value ? it.value.end : void 0;
          const last = Array.isArray(end) ? end[end.length - 1] : void 0;
          if ((last === null || last === void 0 ? void 0 : last.type) === "comment")
            end === null || end === void 0 ? void 0 : end.push(this.sourceToken);
          else
            seq2.items.push({ start: [this.sourceToken] });
        } else
          it.start.push(this.sourceToken);
        return;
      case "space":
      case "comment":
        if (it.value)
          seq2.items.push({ start: [this.sourceToken] });
        else {
          if (this.atIndentedComment(it.start, seq2.indent)) {
            const prev = seq2.items[seq2.items.length - 2];
            const end = (_a = prev === null || prev === void 0 ? void 0 : prev.value) === null || _a === void 0 ? void 0 : _a.end;
            if (Array.isArray(end)) {
              Array.prototype.push.apply(end, it.start);
              end.push(this.sourceToken);
              seq2.items.pop();
              return;
            }
          }
          it.start.push(this.sourceToken);
        }
        return;
      case "anchor":
      case "tag":
        if (it.value || this.indent <= seq2.indent)
          break;
        it.start.push(this.sourceToken);
        return;
      case "seq-item-ind":
        if (this.indent !== seq2.indent)
          break;
        if (it.value || includesToken(it.start, "seq-item-ind"))
          seq2.items.push({ start: [this.sourceToken] });
        else
          it.start.push(this.sourceToken);
        return;
    }
    if (this.indent > seq2.indent) {
      const bv = this.startBlockValue(seq2);
      if (bv) {
        this.stack.push(bv);
        return;
      }
    }
    yield* this.pop();
    yield* this.step();
  }
  *flowCollection(fc) {
    const it = fc.items[fc.items.length - 1];
    if (this.type === "flow-error-end") {
      let top;
      do {
        yield* this.pop();
        top = this.peek(1);
      } while (top && top.type === "flow-collection");
    } else if (fc.end.length === 0) {
      switch (this.type) {
        case "comma":
        case "explicit-key-ind":
          if (!it || it.sep)
            fc.items.push({ start: [this.sourceToken] });
          else
            it.start.push(this.sourceToken);
          return;
        case "map-value-ind":
          if (!it || it.value)
            fc.items.push({ start: [], key: null, sep: [this.sourceToken] });
          else if (it.sep)
            it.sep.push(this.sourceToken);
          else
            Object.assign(it, { key: null, sep: [this.sourceToken] });
          return;
        case "space":
        case "comment":
        case "newline":
        case "anchor":
        case "tag":
          if (!it || it.value)
            fc.items.push({ start: [this.sourceToken] });
          else if (it.sep)
            it.sep.push(this.sourceToken);
          else
            it.start.push(this.sourceToken);
          return;
        case "alias":
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar": {
          const fs = this.flowScalar(this.type);
          if (!it || it.value)
            fc.items.push({ start: [], key: fs, sep: [] });
          else if (it.sep)
            this.stack.push(fs);
          else
            Object.assign(it, { key: fs, sep: [] });
          return;
        }
        case "flow-map-end":
        case "flow-seq-end":
          fc.end.push(this.sourceToken);
          return;
      }
      const bv = this.startBlockValue(fc);
      if (bv)
        this.stack.push(bv);
      else {
        yield* this.pop();
        yield* this.step();
      }
    } else {
      const parent = this.peek(2);
      if (parent.type === "block-map" && (this.type === "map-value-ind" || this.type === "newline" && !parent.items[parent.items.length - 1].sep)) {
        yield* this.pop();
        yield* this.step();
      } else if (this.type === "map-value-ind" && parent.type !== "flow-collection") {
        const prev = getPrevProps(parent);
        const start = getFirstKeyStartProps(prev);
        fixFlowSeqItems(fc);
        const sep = fc.end.splice(1, fc.end.length);
        sep.push(this.sourceToken);
        const map2 = {
          type: "block-map",
          offset: fc.offset,
          indent: fc.indent,
          items: [{ start, key: fc, sep }]
        };
        this.onKeyLine = true;
        this.stack[this.stack.length - 1] = map2;
      } else {
        yield* this.lineEnd(fc);
      }
    }
  }
  flowScalar(type) {
    if (this.onNewLine) {
      let nl = this.source.indexOf("\n") + 1;
      while (nl !== 0) {
        this.onNewLine(this.offset + nl);
        nl = this.source.indexOf("\n", nl) + 1;
      }
    }
    return {
      type,
      offset: this.offset,
      indent: this.indent,
      source: this.source
    };
  }
  startBlockValue(parent) {
    switch (this.type) {
      case "alias":
      case "scalar":
      case "single-quoted-scalar":
      case "double-quoted-scalar":
        return this.flowScalar(this.type);
      case "block-scalar-header":
        return {
          type: "block-scalar",
          offset: this.offset,
          indent: this.indent,
          props: [this.sourceToken],
          source: ""
        };
      case "flow-map-start":
      case "flow-seq-start":
        return {
          type: "flow-collection",
          offset: this.offset,
          indent: this.indent,
          start: this.sourceToken,
          items: [],
          end: []
        };
      case "seq-item-ind":
        return {
          type: "block-seq",
          offset: this.offset,
          indent: this.indent,
          items: [{ start: [this.sourceToken] }]
        };
      case "explicit-key-ind": {
        this.onKeyLine = true;
        const prev = getPrevProps(parent);
        const start = getFirstKeyStartProps(prev);
        start.push(this.sourceToken);
        return {
          type: "block-map",
          offset: this.offset,
          indent: this.indent,
          items: [{ start }]
        };
      }
      case "map-value-ind": {
        this.onKeyLine = true;
        const prev = getPrevProps(parent);
        const start = getFirstKeyStartProps(prev);
        return {
          type: "block-map",
          offset: this.offset,
          indent: this.indent,
          items: [{ start, key: null, sep: [this.sourceToken] }]
        };
      }
    }
    return null;
  }
  atIndentedComment(start, indent) {
    if (this.type !== "comment")
      return false;
    if (this.indent <= indent)
      return false;
    return start.every((st) => st.type === "newline" || st.type === "space");
  }
  *documentEnd(docEnd) {
    if (this.type !== "doc-mode") {
      if (docEnd.end)
        docEnd.end.push(this.sourceToken);
      else
        docEnd.end = [this.sourceToken];
      if (this.type === "newline")
        yield* this.pop();
    }
  }
  *lineEnd(token) {
    switch (this.type) {
      case "comma":
      case "doc-start":
      case "doc-end":
      case "flow-seq-end":
      case "flow-map-end":
      case "map-value-ind":
        yield* this.pop();
        yield* this.step();
        break;
      case "newline":
        this.onKeyLine = false;
      case "space":
      case "comment":
      default:
        if (token.end)
          token.end.push(this.sourceToken);
        else
          token.end = [this.sourceToken];
        if (this.type === "newline")
          yield* this.pop();
    }
  }
};

// node_modules/yaml/browser/dist/public-api.js
function parseOptions(options) {
  const prettyErrors = options.prettyErrors !== false;
  const lineCounter = options.lineCounter || prettyErrors && new LineCounter() || null;
  return { lineCounter, prettyErrors };
}
function parseDocument(source, options = {}) {
  const { lineCounter, prettyErrors } = parseOptions(options);
  const parser = new Parser(lineCounter === null || lineCounter === void 0 ? void 0 : lineCounter.addNewLine);
  const composer = new Composer(options);
  let doc = null;
  for (const _doc of composer.compose(parser.parse(source), true, source.length)) {
    if (!doc)
      doc = _doc;
    else if (doc.options.logLevel !== "silent") {
      doc.errors.push(new YAMLParseError(_doc.range.slice(0, 2), "MULTIPLE_DOCS", "Source contains multiple documents; please use YAML.parseAllDocuments()"));
      break;
    }
  }
  if (prettyErrors && lineCounter) {
    doc.errors.forEach(prettifyError(source, lineCounter));
    doc.warnings.forEach(prettifyError(source, lineCounter));
  }
  return doc;
}

// tagrenamer/File.ts
var File = class {
  constructor(app2, filename, tagPositions, hasFrontMatter2) {
    this.app = app2;
    this.filename = filename;
    this.basename = filename.split("/").pop();
    this.tagPositions = tagPositions;
    this.hasFrontMatter = !!hasFrontMatter2;
  }
  /** @param {Replacement} replace */
  async renamed(replace) {
    const file = this.app.vault.getAbstractFileByPath(this.filename);
    const original = await this.app.vault.read(file);
    let text = original;
    if (this.hasFrontMatter) {
      text = this.replaceInFrontMatter(text, replace);
    }
    if (text !== original) {
      await this.app.vault.modify(file, text);
      return true;
    }
  }
  /** @param {Replacement} replace */
  replaceInFrontMatter(text, replace) {
    const [empty, frontMatter] = text.split(/^---\r?$\n?/m, 2);
    if (empty.trim() !== "" || !frontMatter.trim() || !frontMatter.endsWith("\n"))
      return text;
    const parsed = parseDocument(frontMatter, { keepSourceTokens: true });
    if (parsed.errors.length) {
      const error = `YAML issue with ${this.filename}: ${parsed.errors[0]}`;
      console.error(error);
      new import_obsidian.Notice(error + "; skipping frontmatter");
      return;
    }
    let changed = false, json = parsed.toJSON();
    function setInNode(node, value, afterKey = false) {
      cst_exports.setScalarValue(node.srcToken, value, { afterKey });
      changed = true;
      node.value = value;
    }
    function processField(prop, isAlias2) {
      const node = parsed.get(prop, true);
      if (!node)
        return;
      const field = json[prop];
      if (!field || !field.length)
        return;
      if (typeof field === "string") {
        const parts = field.split(isAlias2 ? /(^\s+|\s*,\s*|\s+$)/ : /([\s,]+)/);
        const after = replace.inArray(parts, true, isAlias2).join("");
        if (field != after)
          setInNode(node, after, true);
      } else if (Array.isArray(field)) {
        replace.inArray(field, false, isAlias2).forEach((v, i) => {
          if (field[i] !== v)
            setInNode(node.get(i, true), v);
        });
      }
    }
    for (const { key: { value: prop } } of parsed.contents.items) {
      if (/^tags?$/i.test(prop)) {
        processField(prop, false);
      } else if (/^alias(es)?$/i.test(prop)) {
        processField(prop, true);
      }
    }
    return changed ? text.replace(frontMatter, cst_exports.stringify(parsed.contents.srcToken)) : text;
  }
};

// tagrenamer/renaming.ts
function hasFrontMatter(file) {
  let { frontmatter } = app.metadataCache.getFileCache(file) || {};
  return frontmatter != null;
}
function hasTags(file) {
  let { frontmatter } = app.metadataCache.getFileCache(file) || {};
  const fmtags = (0, import_obsidian2.parseFrontMatterTags)(frontmatter) || [];
  const aliasTags = ((0, import_obsidian2.parseFrontMatterAliases)(frontmatter) || []).filter(Tag.isTag);
  return fmtags.length || aliasTags.length ? true : false;
}
async function renameTag(file, tagName, newName) {
  const oldTag = new Tag(tagName), newTag = new Tag(newName), replace = new Replacement(oldTag, newTag);
  const target = await findTargets(oldTag, file);
  if (!target) {
    return false;
  }
  await target.renamed(replace);
  return true;
}
async function findTargets(tag2, file) {
  let { frontmatter, tags } = app.metadataCache.getFileCache(file) || {};
  const fmtags = ((0, import_obsidian2.parseFrontMatterTags)(frontmatter) || []).filter(tag2.matches);
  const aliasTags = ((0, import_obsidian2.parseFrontMatterAliases)(frontmatter) || []).filter(Tag.isTag).filter(tag2.matches);
  if (fmtags.length || aliasTags.length) {
    return new File(app, file.path, tags, fmtags.length + aliasTags.length);
  }
  return null;
}
function renameBlogTitle(app2, path, view) {
  let moment2 = require_moment();
  const dateYYYYMMDD = moment2().format("YYYYMMDD");
  let renamedPath = "";
  if (path.match(/^.\/Blog \d\d\d\d\d\d\d\d/)) {
    return Promise.resolve();
  } else if (path.match(/^.\/blog \d\d\d\d\d\d\d\d/)) {
    new import_obsidian2.Notice("start with blog with date, renaming blog to Blog");
    renamedPath = path.replace(/^(.\/)blog /, `$1Blog `);
    return renameFile(app2, view.file, renamedPath);
  } else if (path.match(/^.\/Blog /)) {
    new import_obsidian2.Notice("starts with Blog but no date, adding date");
    renamedPath = path.replace(/^(.\/Blog )/, `$1${dateYYYYMMDD} `);
    return renameFile(app2, view.file, renamedPath);
  } else if (path.match(/^.\/blog /)) {
    new import_obsidian2.Notice("starts with blog but no date, adding date");
    renamedPath = path.replace(/^(.\/)blog /, `$1Blog ${dateYYYYMMDD} `);
    return renameFile(app2, view.file, renamedPath);
  } else {
    new import_obsidian2.Notice("starts without blog, adding Blog + date");
    renamedPath = path.replace(/^(.\/)/, `$1Blog ${dateYYYYMMDD} `);
    return renameFile(app2, view.file, renamedPath);
  }
}
async function renameFile(app2, file, newPath) {
  app2.fileManager.renameFile(file, newPath);
}

// updateNoteTypeModal.ts
var ALL_TYPES = [
  {
    type: "a/n/n",
    description: "N Current Task"
  },
  {
    type: "a/w/n",
    description: "W Current Task"
  },
  {
    type: "a/n/l",
    description: "N Later Task"
  },
  {
    type: "a/w/l",
    description: "W Later Task"
  },
  {
    type: "a/n/p",
    description: "N Permanent Task"
  },
  {
    type: "a/w/p",
    description: "W Permanent Task"
  },
  {
    type: "b/n/s",
    description: "Zettelkasten - Source notes (like books / video / thoughts / conversation)"
  },
  {
    type: "b/n/c",
    description: "Zettelkasten - Cards (With your own thought)"
  },
  {
    type: "c/t/d",
    description: "Threads post draft"
  },
  {
    type: "c/b/d",
    description: "Blog post draft"
  },
  {
    type: "b/n/u",
    description: "Zettelkasten - Unprocessed material like an inbox"
  },
  {
    type: "b/n/m",
    description: "Zettelkasten - MOC Notes for a small topic"
  },
  {
    type: "b/n/z",
    description: "Zettelkasten - Slip box (mainly on thought and the one I am interested)"
  },
  {
    type: "b/n/i",
    description: "Index Notes for self framework"
  },
  {
    type: "b/n/w",
    description: "Wiki Notes for a messy wiki topic"
  },
  {
    type: "b/n/v",
    description: "Zettelkasten - Voice script (Deprecated?)"
  },
  {
    type: "b/n/r",
    description: "Zettelkasten - Reference (Deprecated?)"
  },
  {
    type: "b/n/p",
    description: "Placeholder Notes (Deprecated?)"
  },
  {
    type: "b/a/p",
    description: "Area of Responsibility - Primary"
  },
  {
    type: "b/a/s",
    description: "Area of Responsibility - Secondary"
  },
  {
    type: "c/b/i",
    description: "Blog post content completed but awaiting upload image"
  },
  {
    type: "c/b/r",
    description: "Blog post ready to publish"
  },
  {
    type: "c/b/p",
    description: "Blog post published"
  },
  {
    type: "c/b/i",
    description: "Blog post series index"
  },
  {
    type: "c/b/a",
    description: "Blog post abandoned"
  },
  {
    type: "c/b/o",
    description: "Blog post outlined (Deprecated?)"
  },
  {
    type: "c/b/f",
    description: "Blog post fine tuned (Deprecated?)"
  },
  {
    type: "c/t/r",
    description: "Threads post ready to post"
  },
  {
    type: "c/t/t",
    description: "Threads post threads published"
  },
  {
    type: "c/t/p",
    description: "Threads post published"
  },
  {
    type: "c/t/i",
    description: "Threads post series index"
  },
  {
    type: "c/t/a",
    description: "Threads post abandoned"
  },
  {
    type: "c/x/d",
    description: "Twitter post drafting"
  },
  {
    type: "c/x/r",
    description: "Twitter post ready to publish"
  },
  {
    type: "c/x/p",
    description: "Twitter post published"
  },
  {
    type: "a/n/w",
    description: "N Waiting Task"
  },
  {
    type: "a/n/d",
    description: "N Done Task"
  },
  {
    type: "a/n/a",
    description: "N Archive Task"
  },
  {
    type: "a/w/w",
    description: "W Waiting Task"
  },
  {
    type: "a/w/d",
    description: "W Done Task"
  },
  {
    type: "a/w/a",
    description: "W Archive Task"
  }
];
var UpdateNoteTypeModal = class extends import_obsidian3.FuzzySuggestModal {
  constructor(app2, editor, file) {
    super(app2);
    this.editor = editor;
    this.file = file;
  }
  getItems() {
    return ALL_TYPES;
  }
  getItemText(noteType) {
    return noteType.type;
  }
  // Renders each suggestion item.
  renderSuggestion(choosenNoteTypeMatch, el) {
    const noteType = choosenNoteTypeMatch.item;
    el.createEl("div", { text: noteType.type });
    el.createEl("small", { text: noteType.description });
  }
  containsType(line) {
    return ALL_TYPES.filter((noteType) => line.contains(noteType.type)).length > 0;
  }
  addFrontMatterWithTag(value) {
    const cursor = this.editor.getCursor();
    const oldLine = cursor.line;
    const oldCh = cursor.ch;
    const addText = `---
tags: ${value}
---

${this.editor.getValue()}`;
    this.editor.setValue(addText);
    cursor.line = oldLine + 4;
    cursor.ch = oldCh;
    this.editor.setCursor(cursor);
  }
  addTagAssumingHasFrontMatter(value) {
    const cursor = this.editor.getCursor();
    const oldLine = cursor.line;
    const oldCh = cursor.ch;
    let firstLineIndex = 0;
    const lineCount = this.editor.lineCount();
    for (let i = 0; i < lineCount; i++) {
      if (this.editor.getLine(i).trim() == "---".trim()) {
        firstLineIndex = i;
        break;
      }
    }
    if (firstLineIndex == lineCount) {
      new import_obsidian3.Notice("Something wrong here");
      return;
    }
    let text = "";
    for (let i = 0; i <= firstLineIndex; i++) {
      text = text + this.editor.getLine(i) + "\n";
    }
    text = text + `tags: ${value}
`;
    for (let i = firstLineIndex + 1; i <= this.editor.lineCount(); i++) {
      text = text + this.editor.getLine(i) + "\n";
    }
    this.editor.setValue(text);
    cursor.line = oldLine + (oldLine <= firstLineIndex ? 0 : 1);
    cursor.ch = oldCh;
    this.editor.setCursor(cursor);
  }
  // Perform action on the selected suggestion.
  onChooseItem(choosenNoteType, evt) {
    if (!hasFrontMatter(this.file)) {
      this.addFrontMatterWithTag(choosenNoteType.type);
    } else {
      if (hasTags(this.file)) {
        ALL_TYPES.forEach((t) => {
          renameTag(this.file, t.type, choosenNoteType.type);
        });
      } else {
        this.addTagAssumingHasFrontMatter(choosenNoteType.type);
      }
    }
  }
};

// main.ts
var import_obsidian23 = require("obsidian");

// addCommentTagModal.ts
var import_obsidian4 = require("obsidian");
var ALL_TYPES2 = [
  {
    type: "d/question",
    description: "Question"
  },
  {
    type: "d/answer",
    description: "Answer"
  },
  {
    type: "d/solves",
    description: "Solves some problem"
  },
  {
    type: "d/ref",
    description: "Reference"
  },
  {
    type: "d/selfthink",
    description: "Self think"
  },
  {
    type: "d/notsure",
    description: "Not sure"
  },
  {
    type: "d/a1\u23F9\uFE0F",
    description: "A1 - my experience"
  },
  {
    type: "d/a2\u23FA\uFE0F",
    description: "A2 - future action"
  },
  {
    type: "d/c\u{1F504}",
    description: "Context"
  },
  {
    type: "d/w\u23EA",
    description: "Idea Compass - West - What are similar / supporting idea?"
  },
  {
    type: "d/n\u23EB",
    description: "Idea Compass - North - Where does this idea come from?"
  },
  {
    type: "d/s\u23EC",
    description: "Idea Compass - South - Where does the idea lead to?"
  },
  {
    type: "d/toMerge",
    description: "TODO - To Merge with another note"
  },
  {
    type: "d/toMove",
    description: "TODO - To Merge with another note"
  },
  {
    type: "d/toSplit",
    description: "ToDO - To Split to multiple note"
  },
  {
    type: "d/toCard",
    description: "TODO - To Write card"
  }
];
var AddFootnoteTagModal = class extends import_obsidian4.FuzzySuggestModal {
  constructor(app2, editor) {
    super(app2);
    this.editor = editor;
  }
  getItems() {
    return ALL_TYPES2;
  }
  getItemText(noteType) {
    return noteType.type;
  }
  static removeTag(line) {
    ALL_TYPES2.forEach((noteType) => line = line.replace(`#${noteType.type} `, ""));
    return line;
  }
  // Renders each suggestion item.
  renderSuggestion(choosenNoteTypeMatch, el) {
    const noteType = choosenNoteTypeMatch.item;
    el.createEl("div", { text: noteType.type });
    el.createEl("small", { text: noteType.description });
  }
  containsType(line) {
    return ALL_TYPES2.filter((noteType) => line.contains(noteType.type)).length > 0;
  }
  // Perform action on the selected suggestion.
  onChooseItem(choosenNoteType, evt) {
    const selection = this.editor.getSelection();
    const replacedStr = `#${choosenNoteType.type} `;
    if (selection.length != 0) {
      this.editor.replaceSelection(replacedStr);
    } else {
      const cursor = this.editor.getCursor();
      this.editor.replaceRange(replacedStr, cursor);
      cursor.ch = cursor.ch + replacedStr.length;
      this.editor.setCursor(cursor);
    }
  }
};

// addTaskTagModal.ts
var import_obsidian5 = require("obsidian");
var ALL_TYPES3 = [
  {
    type: "n",
    cursor: "c",
    description: "N Cursor"
  },
  {
    type: "n",
    cursor: "b",
    description: "N Beginning of line"
  },
  {
    type: "n",
    cursor: "e",
    description: "N End of line"
  },
  {
    type: "w",
    cursor: "c",
    description: "W Cursor"
  },
  {
    type: "w",
    cursor: "b",
    description: "W Beginning of line"
  },
  {
    type: "w",
    cursor: "e",
    description: "W End of line"
  }
];
var AddTaskTagModal = class extends import_obsidian5.FuzzySuggestModal {
  constructor(app2, editor, taskType) {
    super(app2);
    this.editor = editor;
    this.taskType = taskType;
  }
  getItems() {
    return ALL_TYPES3;
  }
  getItemText(noteType) {
    return noteType.type + noteType.cursor;
  }
  // Renders each suggestion item.
  renderSuggestion(choosenNoteTypeMatch, el) {
    const noteType = choosenNoteTypeMatch.item;
    el.createEl("div", { text: noteType.type + " " + noteType.cursor });
    el.createEl("small", { text: noteType.description });
  }
  containsType(line) {
    return ALL_TYPES3.filter((noteType) => line.contains(noteType.type)).length > 0;
  }
  // Perform action on the selected suggestion.
  onChooseItem(choosenNoteType, evt) {
    const cursor = this.editor.getCursor();
    const line = this.editor.getLine(cursor.line);
    if (choosenNoteType.cursor == "c") {
      this.editor.replaceRange(`${line.charAt(cursor.ch - 1) != " " ? " " : ""}#${choosenNoteType.type}${this.taskType} `, cursor);
      cursor.ch = cursor.ch + 4 + (line.charAt(cursor.ch - 1) != " " ? 1 : 0);
      this.editor.setCursor(cursor);
    } else if (choosenNoteType.cursor == "b") {
      let modifiedLine = line;
      if (/^\t*- /.test(line)) {
        modifiedLine = line.replace(/^(\t*- )/, `$1#${choosenNoteType.type}${this.taskType} `);
      } else if (/^\t*\d+\. /.test(line)) {
        modifiedLine = line.replace(/^(\t*\d+\. )/, `$1${choosenNoteType.type}${this.taskType} `);
      } else {
        modifiedLine = line.replace(/^/, `#${choosenNoteType.type}${this.taskType} `);
      }
      this.editor.setLine(cursor.line, modifiedLine);
      cursor.ch = cursor.ch + 4;
      this.editor.setCursor(cursor);
    } else if (choosenNoteType.cursor == "e") {
      let modifiedLine = line.replace(/$/, ` #${choosenNoteType.type}${this.taskType}`);
      this.editor.setLine(cursor.line, modifiedLine);
      cursor.ch = cursor.ch;
      this.editor.setCursor(cursor);
    }
  }
};

// ThreadsToImagesModal.ts
var import_obsidian6 = require("obsidian");
var ALL_TYPES4 = [
  {
    type: "first-page",
    description: "first page"
  },
  {
    type: "with-header",
    description: "with header"
  },
  {
    type: "without-header",
    description: "without header"
  },
  {
    type: "custom-font-size",
    description: "custom font size"
  }
];
var ThreadsToImagesModal = class extends import_obsidian6.FuzzySuggestModal {
  constructor(app2, threadSegment) {
    super(app2);
    this.threadSegment = threadSegment;
  }
  getItems() {
    return ALL_TYPES4;
  }
  getItemText(noteType) {
    return noteType.type;
  }
  // Renders each suggestion item.
  renderSuggestion(choosenNoteTypeMatch, el) {
    const noteType = choosenNoteTypeMatch.item;
    el.createEl("div", { text: noteType.type });
    el.createEl("small", { text: noteType.description });
  }
  containsType(line) {
    return ALL_TYPES4.filter((noteType) => line.contains(noteType.type)).length > 0;
  }
  // Perform action on the selected suggestion.
  onChooseItem(choosenNoteType, evt) {
    let param = choosenNoteType.type;
    let s = this.threadSegment.toString();
    navigator.clipboard.writeText(this.threadSegment.toString()).then(function() {
      new import_obsidian6.Notice(`Copied
\`\`\`
${s}\`\`\`
to clipboard!`);
      window.open(`shortcuts://run-shortcut?name=Threads%20to%20image&input=text&text=${param}&x-success=obsidian://&x-cancel=obsidian://&x-error=obsidian://`);
    }, function(error) {
      new import_obsidian6.Notice(`error when copy to clipboard!`);
    });
  }
};

// copyOrMoveToNewNoteModal.ts
var import_obsidian7 = require("obsidian");
var ALL_TYPES5 = [
  {
    type: "copy",
    description: "Copy"
  },
  {
    type: "move",
    description: "Move"
  }
];
var CopyOrMoveToNewNoteModal = class extends import_obsidian7.FuzzySuggestModal {
  constructor(app2, editor) {
    super(app2);
    this.editor = editor;
    this.setPlaceholder(`Copy or move selection to new note?`);
  }
  getItems() {
    return ALL_TYPES5;
  }
  getItemText(noteType) {
    return noteType.type;
  }
  // Renders each suggestion item.
  renderSuggestion(choosenNoteTypeMatch, el) {
    const noteType = choosenNoteTypeMatch.item;
    el.createEl("div", { text: noteType.type });
    el.createEl("small", { text: noteType.description });
  }
  containsType(line) {
    return ALL_TYPES5.filter((noteType) => line.contains(noteType.type)).length > 0;
  }
  // Perform action on the selected suggestion.
  async onChooseItem(choosenOperation, evt) {
    const selection = this.editor.getSelection();
    const line = this.editor.getCursor().line;
    const textToCopyOrMove = selection.length == 0 ? this.editor.getLine(line) : selection;
    const newFileName = "I/United Push.md";
    await this.createOrAppendFile(newFileName, textToCopyOrMove);
    if (choosenOperation.type == "move") {
      if (selection.length != 0) {
        this.editor.replaceSelection("");
      } else {
        let content = "";
        for (let i = 0; i < this.editor.lineCount(); i++) {
          if (i != line) {
            content += this.editor.getLine(i) + "\n";
          }
        }
        this.editor.setValue(content);
      }
    }
    const { vault } = this.app;
    const { workspace } = this.app;
    const mode = this.app.vault.getConfig("defaultViewMode");
    const leaf = workspace.getLeaf(false);
    await leaf.openFile(vault.getAbstractFileByPath(newFileName), { active: true });
  }
  async createOrAppendFile(filePath, note2) {
    const { vault } = this.app;
    const fileExists = await vault.adapter.exists(filePath);
    if (fileExists) {
      await this.appendFile(vault, filePath, note2);
    } else {
      await vault.create(filePath, "---\ntag: b/n/s\n---\n\n" + note2);
    }
    return filePath;
  }
  async appendFile(vault, filePath, note2) {
    let existingContent = await vault.adapter.read(filePath);
    if (existingContent.length > 0) {
      existingContent = existingContent + "\r\r";
    }
    await vault.adapter.write(filePath, existingContent + note2);
  }
};

// clipboardPasteModal.ts
var import_obsidian8 = require("obsidian");
var ClipboardPasteModal = class extends import_obsidian8.FuzzySuggestModal {
  constructor(app2, editor, clipboardContent) {
    super(app2);
    this.editor = editor;
    this.clipboardContent = clipboardContent;
    this.setPlaceholder(`Which clipboard content do you want to paste?`);
  }
  getItems() {
    return this.clipboardContent.slice().reverse();
  }
  getItemText(item) {
    return item;
  }
  // Renders each suggestion item.
  renderSuggestion(i, el) {
    const item = i.item;
    el.createEl("div", { text: "\u2022 " + item.replace(/\n/gm, "").substring(0, 100) });
  }
  // Perform action on the selected suggestion.
  onChooseItem(selectedContent, evt) {
    const index = this.clipboardContent.indexOf(selectedContent, 0);
    if (index > -1) {
      this.clipboardContent.remove(selectedContent);
    }
    this.clipboardContent.push(selectedContent);
    const selection = this.editor.getSelection();
    const replacedStr = selectedContent;
    if (selection.length != 0) {
      this.editor.replaceSelection(replacedStr);
    } else {
      const cursor = this.editor.getCursor();
      this.editor.replaceRange(replacedStr, cursor);
      cursor.ch = cursor.ch + replacedStr.length;
      this.editor.setCursor(cursor);
    }
  }
};

// openPlaygroundModal.ts
var import_obsidian9 = require("obsidian");
var OpenPlaygroundModal = class extends import_obsidian9.FuzzySuggestModal {
  constructor(app2) {
    super(app2);
    this.removeExistingContent = "Remove playground content";
    this.notRemoveExistingContent = "Not remove existing playground content";
    this.playgroundMd = "I/Playground.md";
    this.options = [this.removeExistingContent, this.notRemoveExistingContent];
  }
  getItems() {
    return this.options.reverse();
  }
  getItemText(item) {
    return item;
  }
  // Renders each suggestion item.
  renderSuggestion(i, el) {
    const item = i.item;
    el.createEl("div", { text: item });
  }
  // Perform action on the selected suggestion.
  async onChooseItem(selectedContent, evt) {
    const choosenOption = selectedContent;
    const { vault } = this.app;
    const { workspace } = this.app;
    const leaf = workspace.getLeaf(false);
    Promise.resolve().then(() => {
      if (vault.getAbstractFileByPath(this.playgroundMd) == null) {
        return vault.create(this.playgroundMd, "");
      }
      return vault.getAbstractFileByPath(this.playgroundMd);
    }).then((tFile) => {
      if (this.removeExistingContent === choosenOption) {
        return vault.modify(tFile, "");
      }
      return Promise.resolve();
    }).then(() => {
      return leaf.openFile(vault.getAbstractFileByPath(this.playgroundMd), { active: true });
    });
  }
};

// threadsToBlogModal.ts
var import_obsidian10 = require("obsidian");
var ThreadsToBlogModal = class extends import_obsidian10.FuzzySuggestModal {
  constructor(app2, editor, view) {
    super(app2);
    this.toNewNote = "To New Note";
    this.toClipboard = "To Clipboard";
    this.options = [this.toNewNote, this.toClipboard];
    this.editor = editor;
    this.view = view;
    this.setPlaceholder(`Putting Threads content to Blog notes. Which option do you want to proceed?`);
  }
  getItems() {
    return this.options;
  }
  getItemText(item) {
    return item;
  }
  // Renders each suggestion item.
  renderSuggestion(i, el) {
    const item = i.item;
    el.createEl("div", { text: item });
  }
  // Perform action on the selected suggestion.
  onChooseItem(selectedContent, evt) {
    const choosenOption = selectedContent;
    const lineCount = this.editor.lineCount();
    let tagLineNumber = null;
    let metadataLineCount = 0;
    let text = "";
    for (let i = 0; i < lineCount; i++) {
      let line = this.editor.getLine(i);
      if (!line.trim().startsWith("%%") || !line.trim().endsWith("%%")) {
        let modifiedLine = line.replace("\u{1F9F5} ", "# ").replace("\u3010", "").replace("\u3011", "").replace("\u{1F447}", "");
        if (modifiedLine == "---") {
          metadataLineCount++;
          if (metadataLineCount > 2) {
            if (metadataLineCount == 3) {
              modifiedLine = modifiedLine.replace("---", "");
            } else if (metadataLineCount == 4) {
              modifiedLine = modifiedLine.replace("---", "<!--more-->\n\n**\u76EE\u9304\uFF1A**\n\n* Table of Content\n{:toc}\n\n## .");
            } else {
              modifiedLine = modifiedLine.replace("---", "## .");
            }
          }
        }
        if (metadataLineCount == 1 || metadataLineCount == 2) {
          modifiedLine = modifiedLine.replace("c/t/p", "c/b/d");
          modifiedLine = modifiedLine.replace("c/t/t", "c/b/d");
          modifiedLine = modifiedLine.replace("c/t/r", "c/b/d");
        }
        if (/^!\[.*\]\(.*\)/.test(modifiedLine.trim())) {
          if (!modifiedLine.contains("https://roulesophy.github.io")) {
            modifiedLine = modifiedLine.replace(/!\[([^\[\]\(\)]+)\]\(([^\[\]\(\)]+)\)/g, "$2");
          }
        }
        text = text + modifiedLine + "\n";
      }
    }
    text += `

---

#nl generate summary for meta description below:



`;
    text += `---

## References:

- Thread post 1: [[${this.view.file.basename}]]
- Blog link: 
`;
    const { vault } = this.app;
    if (this.toNewNote === choosenOption) {
      const { vault: vault2 } = this.app;
      const path = this.view.file.path;
      const newPath = path.match(/.\/Threads \d\d\d\d\d\d\d\d/) ? path.replace(/(.\/)Threads \d\d\d\d\d\d\d\d/, "$1Blog ") : path.replace(/(.\/)/, "$1Blog ");
      const { workspace } = this.app;
      const leaf = workspace.getLeaf(false);
      Promise.resolve().then(() => {
        return vault2.adapter.exists(newPath);
      }).then((fileExists) => {
        if (fileExists) {
          new import_obsidian10.Notice(`Will not proceed. Blog post "${newPath}" already exist.`);
          return Promise.reject("Blog post exist");
        }
        return vault2.create(newPath, text);
      }).then(
        (tFile) => {
          return leaf.openFile(tFile, { active: true });
        },
        (rejectReason) => {
        }
      );
    }
    if (this.toClipboard === choosenOption) {
      navigator.clipboard.writeText(text).then(function() {
        new import_obsidian10.Notice(`Copied blog content to clipboard!`);
      }, function(error) {
        new import_obsidian10.Notice(`error when copy to clipboard!`);
      });
    }
  }
};

// clipboardRemovalModal.ts
var import_obsidian11 = require("obsidian");
var ClipboardRemovalModal = class extends import_obsidian11.FuzzySuggestModal {
  constructor(app2, editor, clipboardContent) {
    super(app2);
    this.REMOVE_ALL = "REMOVE ALL";
    this.editor = editor;
    this.clipboardContent = clipboardContent;
    this.setPlaceholder(`Which clipboard content do you want to remove?`);
  }
  getItems() {
    return [...[this.REMOVE_ALL], ...this.clipboardContent.slice().reverse()];
  }
  getItemText(item) {
    return item;
  }
  // Renders each suggestion item.
  renderSuggestion(i, el) {
    const item = i.item;
    el.createEl("div", { text: "\u2022 " + item.replace(/\n/gm, "").substring(0, 100) });
  }
  // Perform action on the selected suggestion.
  onChooseItem(selectedContent, evt) {
    if (selectedContent === this.REMOVE_ALL) {
      new import_obsidian11.Notice("haha");
      while (this.clipboardContent.length > 0) {
        this.clipboardContent.pop();
      }
    } else {
      const index = this.clipboardContent.indexOf(selectedContent, 0);
      if (index > -1) {
        this.clipboardContent.splice(index, 1);
      }
    }
  }
};

// tagSearchModal.ts
var import_obsidian13 = require("obsidian");

// selfutil/getAllNoteTags.ts
var import_obsidian12 = require("obsidian");
function getAllNoteTags(app2) {
  return getAllTagsWithFilter(app2, (tag2) => /^#[a-z]\/[a-z]\/[a-z]$/.test(tag2));
}
function getAllTagsWithFilter(app2, filter) {
  var _a;
  const files = app2.vault.getMarkdownFiles();
  const items = [];
  for (const file of files) {
    const cache = app2.metadataCache.getCache(file.path);
    if (cache === null) {
      continue;
    }
    (_a = (0, import_obsidian12.getAllTags)(cache)) == null ? void 0 : _a.forEach((tag2) => {
      if (filter == null || filter(tag2)) {
        const layerOfTag = getLayersOfTag(tag2);
        for (const layer of layerOfTag) {
          if (!items.includes(layer)) {
            items.push(layer);
          }
        }
      }
    });
  }
  return items.sort((a, b) => a.localeCompare(b));
}
function getLayersOfTag(tag2) {
  const layers = [];
  const tagSplit = tag2.split("/");
  let tagLayer = tagSplit[0];
  layers.push(tagLayer);
  for (const tagPart of tagSplit.slice(1, tagSplit.length)) {
    tagLayer += "/" + tagPart;
    layers.push(tagLayer);
  }
  return layers;
}

// tagSearchModal.ts
var TagSearchModal = class extends import_obsidian13.FuzzySuggestModal {
  constructor(app2, search) {
    super(app2);
    this.app = app2;
    this.search = search;
    this.search = search;
  }
  getItems() {
    return getAllTagsWithFilter(this.app);
  }
  getItemText(item) {
    return item;
  }
  onChooseItem(item, evt) {
    const defaultTagSearchString = `tag:${item}`;
    this.search.openGlobalSearch(defaultTagSearchString);
  }
};

// main.ts
var import_obsidian24 = require("obsidian");
var import_moment = __toESM(require_moment());

// addTextToNotesFromSpecificTagModal.ts
var import_obsidian16 = require("obsidian");

// selfutil/addlinktonotes.ts
var import_obsidian14 = require("obsidian");
function addTextToNotes(textToAdd, toPath, app2, insertFromBeginning) {
  const vault = this.app.vault;
  const workspace = this.app.workspace;
  const leaf = workspace.getLeaf(false);
  const tFile = vault.getAbstractFileByPath(toPath);
  const link = textToAdd;
  Promise.resolve().then(() => {
    return leaf.openFile(tFile, { active: true });
  }).then(() => {
    const markdownView = app2.workspace.getActiveViewOfType(import_obsidian14.MarkdownView);
    const editor = markdownView == null ? void 0 : markdownView.editor;
    const value = markdownView == null ? void 0 : markdownView.getViewData();
    if (markdownView == null || editor == null || value == null) {
      const errorReason = `editor or value ${toPath} not exist. Aborting...`;
      return Promise.reject(errorReason);
    }
    if (value.includes(link)) {
      const errorReason = `Link ${link} already exists in ${toPath}!`;
      new import_obsidian14.Notice(errorReason);
    } else {
      const newValue = insertFromBeginning ? getNoteValueInsertingTextFromStartOfNotes(value, link) : getNoteValueInsertingTextFromEndOfNotes(value, link);
      markdownView.setViewData(newValue, false);
      if (insertFromBeginning) {
        const frontMatterRegex = /^(---\n[\s\S]*?\n---\n)/gm;
        if (frontMatterRegex.test(value)) {
          editor.setCursor({ line: getLineAfterFrontMatter(value), ch: 0 });
        } else {
          editor.setCursor({ line: 0, ch: 0 });
        }
      } else {
        editor.setCursor({ line: editor.lineCount() - 1, ch: 0 });
      }
      new import_obsidian14.Notice(`Added link to ${insertFromBeginning ? "beginning" : "end"} of ${toPath}!`);
    }
    return Promise.resolve();
  }).catch((reason) => {
    new import_obsidian14.Notice(reason);
  });
}
function getLineAfterFrontMatter(value) {
  const values = value.split("\n");
  let fmCount = 0;
  const lineNum = values.length;
  for (let i = 0; i < lineNum; i++) {
    if (values[i] === "---") {
      fmCount++;
    }
    if (fmCount == 2) {
      return Math.min(i + 1, lineNum - 1);
    }
  }
  return lineNum - 1;
}
function getNoteValueInsertingTextFromStartOfNotes(value, text) {
  const frontMatterRegex = /^(---\n[\s\S]*?\n---\n)/gm;
  if (frontMatterRegex.test(value)) {
    return value.replace(frontMatterRegex, "$1" + text + "\n");
  } else {
    return text + "\n" + value;
  }
}
function getNoteValueInsertingTextFromEndOfNotes(value, text) {
  return value + "\n" + text;
}

// selfutil/findNotesFromTag.ts
var import_obsidian15 = require("obsidian");
function filesWhereTagIsUsed(findTag) {
  const filesList = [];
  for (const filePath of locationsWhereTagIsUsed(findTag)) {
    if (!filesList.includes(filePath)) {
      filesList.push(filePath);
    }
  }
  return filesList.sort((a, b) => a.localeCompare(b));
}
function locationsWhereTagIsUsed(findTag) {
  const oApp = app;
  const results = [];
  for (const file of oApp.vault.getMarkdownFiles()) {
    const cache = oApp.metadataCache.getFileCache(file);
    if (cache != null && cache.tags) {
      for (const tag2 of cache.tags) {
        if (findTag === tag2.tag) {
          results.push(file.path);
        }
      }
    }
    if (cache != null && cache.frontmatter) {
      const fmtags = ((0, import_obsidian15.parseFrontMatterTags)(cache.frontmatter) || []).filter((tag2) => findTag == tag2 || tag2.startsWith(findTag + "/"));
      if (fmtags.length) {
        results.push(file.path);
      }
      const fmtags2 = ((0, import_obsidian15.parseFrontMatterAliases)(cache.frontmatter) || []).filter((tag2) => findTag == tag2 || tag2.startsWith(findTag + "/"));
      if (fmtags2.length) {
        results.push(file.path);
      }
    }
  }
  return results;
}

// addTextToNotesFromSpecificTagModal.ts
var BACK_TO_SELECT_TAG = "Back to select tag";
var AddTextToNotesFromSpecificTagModal = class extends import_obsidian16.FuzzySuggestModal {
  constructor(app2, linkToAdd, tagToFind, description, insertFromBeginning, postAction) {
    super(app2);
    this.linkToAdd = linkToAdd;
    this.tagToFind = tagToFind;
    this.insertFromBeginning = insertFromBeginning;
    this.description = description;
    this.postAction = postAction;
    this.setPlaceholder(`Which notes with tag ${tagToFind} do you want to ${description} to?`);
    this.setInstructions([
      {
        command: "",
        purpose: `Which notes with tag ${tagToFind} do you want to ${description} to?`
      }
    ]);
  }
  getItems() {
    return [...[BACK_TO_SELECT_TAG], ...filesWhereTagIsUsed(this.tagToFind)];
  }
  getItemText(path) {
    return path;
  }
  // Renders each suggestion item.
  renderSuggestion(path, el) {
    const pathItem = path.item;
    el.createEl("div", { text: pathItem });
  }
  // Perform action on the selected suggestion.
  onChooseItem(path, evt) {
    if (BACK_TO_SELECT_TAG == path) {
      new AddTextToNotesModal(this.app, this.linkToAdd, this.description, this.insertFromBeginning, this.postAction).open();
    } else {
      addTextToNotes(this.linkToAdd, path, this.app, this.insertFromBeginning);
      this.postAction();
    }
  }
};

// addTextToNotesModal.ts
var import_obsidian17 = require("obsidian");

// selfutil/getRecentNotes.ts
function getRecentNotes(app2, limit) {
  const recentViewedNotes = app2.workspace.getLastOpenFiles();
  return recentViewedNotes.slice(0, Math.min(limit, recentViewedNotes.length));
}
function getAllNotes(app2) {
  const files = app2.vault.getMarkdownFiles();
  const allNotes = files.map((file) => file.path);
  return allNotes;
}

// addTextToNotesModal.ts
var AddTextToNotesModal = class extends import_obsidian17.FuzzySuggestModal {
  constructor(app2, linkToAdd, description, insertFromBeginning, postAction) {
    super(app2);
    this.linkToAdd = linkToAdd;
    this.description = description;
    this.insertFromBeginning = insertFromBeginning;
    this.postAction = postAction;
    this.setPlaceholder(`Which notes with tags do you want to ${description} to?`);
    this.setInstructions([
      {
        command: "",
        purpose: `Which notes with tags do you want to ${description} to?`
      }
    ]);
  }
  getItems() {
    const l = [...["I/Inbox.md"], ...getRecentNotes(this.app, 7), ...getAllNoteTags(this.app).map((s) => s.replace(/^#/, "@")), ...getAllNotes(this.app)];
    return l.filter((item, index) => l.indexOf(item) === index);
  }
  getItemText(value) {
    return value;
  }
  // Renders each suggestion item.
  renderSuggestion(value, el) {
    const item = value.item;
    el.createEl("div", { text: item });
  }
  // Perform action on the selected suggestion.
  async onChooseItem(choosenValue, evt) {
    if (choosenValue.startsWith("@")) {
      new AddTextToNotesFromSpecificTagModal(this.app, this.linkToAdd, choosenValue.replace(/^@/, "#"), this.description, this.insertFromBeginning, this.postAction).open();
    } else {
      addTextToNotes(this.linkToAdd, choosenValue, this.app, this.insertFromBeginning);
      this.postAction();
    }
  }
};

// navigateToNoteFromSpecificTagModal.ts
var import_obsidian18 = require("obsidian");
var BACK_TO_SELECT_TAG2 = "Back to select tag";
var NavigateToNoteFromSpecificTagModal = class extends import_obsidian18.FuzzySuggestModal {
  constructor(app2, tagToFind) {
    super(app2);
    this.tagToFind = tagToFind;
    this.setPlaceholder(`Which notes with tag ${tagToFind} do you want to navigate to?`);
    this.setInstructions([
      {
        command: "",
        purpose: `Which notes with tag ${tagToFind} do you want to navigate to?`
      }
    ]);
  }
  getItems() {
    return [...[BACK_TO_SELECT_TAG2], ...filesWhereTagIsUsed(this.tagToFind)];
  }
  getItemText(path) {
    return path;
  }
  // Renders each suggestion item.
  renderSuggestion(path, el) {
    const pathItem = path.item;
    el.createEl("div", { text: pathItem });
  }
  // Perform action on the selected suggestion.
  onChooseItem(path, evt) {
    if (BACK_TO_SELECT_TAG2 == path) {
      new NavigateToNoteFromTagModal(this.app).open();
    } else {
      const { vault, workspace } = this.app;
      const leaf = workspace.getLeaf(false);
      Promise.resolve().then(() => {
        return leaf.openFile(vault.getAbstractFileByPath(path), { active: true });
      });
    }
  }
};

// navigateToNoteFromTagModal.ts
var import_obsidian19 = require("obsidian");
var note = "note";
var tag = "tag";
var heading = "heading";
var NavigateToNoteFromTagModal = class extends import_obsidian19.FuzzySuggestModal {
  constructor(app2) {
    super(app2);
    this.setPlaceholder(`Which notes with tags do you want to navigate to?`);
    this.setInstructions([
      {
        command: "",
        purpose: "Which notes with tags do you want to navigate to?"
      }
    ]);
  }
  getItems() {
    const allNotes = getAllNotes(this.app);
    let headings = [];
    allNotes.forEach((n) => {
      const file = this.app.vault.getAbstractFileByPath(n);
      const fileCache = this.app.metadataCache.getFileCache(file);
      if (!fileCache) {
        return;
      }
      if (!fileCache.headings) {
        return;
      }
      fileCache.headings.forEach((h) => {
        headings.push({ note: n, heading: h.heading, level: h.level });
      });
    });
    return [
      ...getRecentNotes(this.app, 7).map((n) => {
        return { search: n, secondary: "", type: note };
      }),
      ...getAllTagsWithFilter(this.app).map((n) => {
        return { search: n.replace(/^#/, "@"), secondary: "", type: tag };
      }),
      ...allNotes.map((n) => {
        return { search: n, secondary: "", type: note };
      }),
      ...headings.map((h) => {
        return { search: "#".repeat(h.level) + " " + h.heading, secondary: h.note, type: heading };
      })
    ];
  }
  getItemText(value) {
    return value.search;
  }
  // Renders each suggestion item.
  renderSuggestion(value, el) {
    const item = value.item;
    el.createEl("div", { text: item.search });
    el.createEl("small", { text: item.type + " " + item.secondary });
  }
  // Perform action on the selected suggestion.
  async onChooseItem(choosenValue, evt) {
    if (choosenValue.type == tag) {
      new NavigateToNoteFromSpecificTagModal(this.app, choosenValue.search.replace("@", "#")).open();
    } else if (choosenValue.type == note) {
      const { vault, workspace } = this.app;
      const leaf = workspace.getLeaf(false);
      Promise.resolve().then(() => {
        return leaf.openFile(vault.getAbstractFileByPath(choosenValue.search), { active: true });
      });
    } else if (choosenValue.type == heading) {
      const { vault, workspace } = this.app;
      const leaf = workspace.getLeaf(false);
      Promise.resolve().then(() => {
        return leaf.openFile(vault.getAbstractFileByPath(choosenValue.secondary), { active: true });
      }).then(() => {
        const markdownView = app.workspace.getActiveViewOfType(import_obsidian19.MarkdownView);
        const editor = markdownView == null ? void 0 : markdownView.editor;
        if (markdownView == null || editor == null) {
          const errorReason = `editor or value ${choosenValue.secondary} not exist. Aborting...`;
          return Promise.reject(errorReason);
        }
        const totalLineNum = editor.lineCount();
        for (let i = 0; i < totalLineNum; i++) {
          const line = editor.getLine(i);
          if (line == choosenValue.search) {
            editor.setCursor({ line: i, ch: 0 });
            editor.scrollIntoView({ from: { line: i, ch: 0 }, to: { line: i, ch: 0 } }, true);
            return;
          }
        }
      });
    }
  }
};

// selfutil/extractSelection.ts
function exportCurrentSelection(editor) {
  let text = "";
  const listSelections = editor.listSelections();
  listSelections.forEach((listSelection) => {
    const a = listSelection.head.line;
    const b = listSelection.anchor.line;
    const fromLineNum = b > a ? a : b;
    const toLineNum = b > a ? b : a;
    for (let i = fromLineNum; i <= toLineNum; i++) {
      const line = editor.getLine(i);
      text += line + "\n";
    }
  });
  return text.replace(/\n$/, "");
}
function getCurrentSelectionLineNumber(editor) {
  let text = "";
  let fromLineNum = 0;
  let fromCh = 0;
  let toLineNum = 0;
  let toCh = 0;
  const listSelections = editor.listSelections();
  listSelections.forEach((listSelection) => {
    const a = listSelection.head.line;
    const ach = listSelection.head.ch;
    const b = listSelection.anchor.line;
    const bch = listSelection.anchor.ch;
    fromLineNum = b > a ? a : b;
    fromCh = b > a ? ach : bch;
    toLineNum = b > a ? b : a;
    toCh = b > a ? bch : ach;
  });
  return { fromLineNum, fromCh, toLineNum, toCh };
}

// twmigration/twMigrateTools.ts
var skipFrontMatterField = [
  "freetimetask: ",
  "expectedtime: ",
  "mode: ",
  "days: ",
  "showheaderfooter: ",
  "showstate: ",
  "sortsubpagefilter: ",
  "throughttree: ",
  "urgent: ",
  "displayas: ",
  "startdate: ",
  "readwritemode: ",
  "showChandlerNow: ",
  "deepwork: ",
  "expectedtime: ",
  "parsedate: ",
  "tidscope: ",
  "inserttodoaction: ",
  "optional: ",
  "replaceto: ",
  "backuptiddler: ",
  "deadline: ",
  "caption: ",
  "collection: ",
  "library: ",
  "library_version: ",
  "dummy: ",
  "tidName: ",
  "chronicledate: ",
  "eventdate: ",
  "dailyhighlight: ",
  "displaycardmode: ",
  "displaymode: ",
  "numcol: ",
  "dateyyyymmdd: ",
  "graphdisplaymode: ",
  "maxdepth: ",
  "journaldate: ",
  "thisBillDate: ",
  "lastBillDate: ",
  "roottiddler: ",
  "year: ",
  "to: ",
  "tidtemplate: ",
  "tiddlername: ",
  "theme: ",
  "tagvalue: ",
  "subtasknum: ",
  "removetagvalue: ",
  "recurringeventstartdate: ",
  "recurringeventenddate: ",
  "pluginname: ",
  "pid: ",
  "macroname: ",
  "limit: ",
  "keyword: ",
  "keywordtmp: ",
  "from: ",
  "deprecatereason: ",
  "deepwo: ",
  "color: ",
  "row: ",
  "col: ",
  "bookmarked: ",
  "blockingreminderdate: ",
  "backup: "
];
function replaceTWUselessValue(value) {
  return value.replace("## > References\n\n* \n\n", "").replace("## > Goal and Reason\n\n* \n\n", "").replace("## > Deliverable Spec\n\n* \n\n", "").replace("## > Conditon of done\n\n* \n\n", "").replace("## > Step\n\n* \n\n", "").replace("## > Progress\n\n* \n\n", "").replace("## > Results\n\n* \n\n", "").replace("## > Experience\n\n* \n\n", "").replace("## > References\n\n* \n\n", "").replace("## > Results, Steps and Exp\n\n* \n\n", "").replace("## > Checklist\n\n[ ] \n\n", "").replace(/\n\n\n+/, "\n\n");
}
function shouldSkipFrontMatter(line) {
  for (let i = 0; i < skipFrontMatterField.length; i++) {
    if (line.startsWith(skipFrontMatterField[i])) {
      return true;
    }
  }
  return false;
}
function getParentLine(value) {
  const values = value.split("\n");
  for (let i = 0; i < values.length; i++) {
    const lineContent = values[i];
    if (/^parent\d+: /.test(lineContent) || /^\t+- parent\d+: /.test(lineContent)) {
      return i;
    }
  }
  return 0;
}
function tidyUpFrontMatteronEditor(editor) {
  const value = editor.getValue();
  const modifiedValue = tidyUpFrontMatterOnValue(value);
  editor.setValue(modifiedValue);
}
function tidyUpFrontMatterOnValue(value) {
  const values = value.split("\n");
  const lineCount = values.length;
  let fm = "";
  let c = "";
  let text = "";
  let h3Count = 0;
  let content = "";
  for (let i = 0; i < lineCount; i++) {
    const line = values[i];
    if (h3Count == 0) {
      content += line + "\n";
    } else if (h3Count == 1) {
      if (/^list: /.test(line)) {
      } else {
        fm += line + "\n";
      }
    }
    if (h3Count >= 2) {
      c += line + "\n";
    }
    if (line === "---") {
      h3Count++;
    }
  }
  text += content;
  if (fm.length > 0) {
    text += fm;
  }
  text += c;
  return text.replace(/^---\n---\n/m, "").replace(/\n$/, "");
}

// selfutil/removeContentFromCursor.ts
function removeContentFromStartOfNoteToCursor(editor) {
  const cursor = editor.getCursor();
  const line = cursor.line;
  const ch = cursor.ch;
  const lineContent = editor.getLine(line);
  let newContent = lineContent.substring(ch);
  for (let i = line + 1; i < editor.lineCount(); i++) {
    newContent += "\n" + editor.getLine(i);
  }
  editor.setValue(newContent);
  cursor.line = 0;
  cursor.ch = 0;
  editor.setCursor(cursor);
}
function removeContentFromCursorToEndOfNote(editor) {
  const cursor = editor.getCursor();
  const line = cursor.line;
  const ch = cursor.ch;
  const lineContent = editor.getLine(line);
  let newContent = "";
  for (let i = 0; i < line; i++) {
    newContent += editor.getLine(i) + "\n";
  }
  newContent += lineContent.substring(0, ch);
  editor.setValue(newContent);
  cursor.line = line;
  cursor.ch = ch;
  editor.setCursor(cursor);
}
function removeContentLeftSameLine(editor) {
  const cursor = editor.getCursor();
  const line = cursor.line;
  const ch = cursor.ch;
  const lineContent = editor.getLine(line);
  editor.setLine(line, lineContent.substring(ch));
  cursor.ch = 0;
  editor.setCursor(cursor);
}
function removeContentRightSameLine(editor) {
  const cursor = editor.getCursor();
  const line = cursor.line;
  const ch = cursor.ch;
  const lineContent = editor.getLine(line);
  editor.setLine(line, lineContent.substring(0, ch));
  cursor.ch = editor.getLine(line).length;
  editor.setCursor(cursor);
}

// removeContentFromCursorModal.ts
var import_obsidian20 = require("obsidian");
var RemoveContentFromCursorModal = class extends import_obsidian20.FuzzySuggestModal {
  constructor(app2, editor) {
    super(app2);
    this.removeContentLeftSameLine = "Remove content left same line";
    this.removeContentRightSameLine = "Remove content right same line";
    this.removeContentFromStartOfNoteToCursor = "Remove content from start of note to cursor";
    this.removeContentFromCursorToEndOfNote = "Remove content from cursor to end of note";
    this.options = [this.removeContentLeftSameLine, this.removeContentRightSameLine, this.removeContentFromStartOfNoteToCursor, this.removeContentFromCursorToEndOfNote];
    this.editor = editor;
  }
  getItems() {
    return this.options;
  }
  getItemText(item) {
    return item;
  }
  // Renders each suggestion item.
  renderSuggestion(i, el) {
    const item = i.item;
    el.createEl("div", { text: item });
  }
  // Perform action on the selected suggestion.
  async onChooseItem(selectedContent, evt) {
    const choosenOption = selectedContent;
    if (choosenOption === this.removeContentLeftSameLine) {
      removeContentLeftSameLine(this.editor);
    } else if (choosenOption === this.removeContentRightSameLine) {
      removeContentRightSameLine(this.editor);
    } else if (choosenOption === this.removeContentFromStartOfNoteToCursor) {
      removeContentFromStartOfNoteToCursor(this.editor);
    } else if (choosenOption === this.removeContentFromCursorToEndOfNote) {
      removeContentFromCursorToEndOfNote(this.editor);
    }
  }
};

// findReplaceModal.ts
var import_obsidian21 = require("obsidian");
var FindReplaceModal = class extends import_obsidian21.FuzzySuggestModal {
  constructor(app2) {
    super(app2);
    this.find = "find";
    this.replace = "replace";
    this.options = [this.find, this.replace];
  }
  getItems() {
    return this.options;
  }
  getItemText(item) {
    return item;
  }
  // Renders each suggestion item.
  renderSuggestion(i, el) {
    const item = i.item;
    el.createEl("div", { text: item });
  }
  // Perform action on the selected suggestion.
  async onChooseItem(selectedContent, evt) {
    const choosenOption = selectedContent;
    if (choosenOption === this.find) {
      this.app.commands.executeCommandById("editor:open-search");
    } else {
      this.app.commands.executeCommandById("obsidian-regex-replace:obsidian-regex-replace");
    }
  }
};

// queryOrphanNotesByTagModal.ts
var import_obsidian22 = require("obsidian");
var QueryOrphanNotesByTagModal = class extends import_obsidian22.FuzzySuggestModal {
  constructor(app2, editor, view) {
    super(app2);
    this.setPlaceholder(`Which notes with tags do you want to search orphan?`);
    this.setInstructions([
      {
        command: "",
        purpose: `Which notes with tags do you want to search orphan?`
      }
    ]);
    this.editor = editor;
    this.view = view;
  }
  getItems() {
    const l = [...getAllNoteTags(this.app).map((s) => s.replace(/^#/, "@"))];
    return l.filter((item, index) => l.indexOf(item) === index);
  }
  getItemText(value) {
    return value;
  }
  // Renders each suggestion item.
  renderSuggestion(value, el) {
    const item = value.item;
    el.createEl("div", { text: item });
  }
  // Perform action on the selected suggestion.
  async onChooseItem(choosenValue, evt) {
    console.log(this.view.file.path);
    const queryMd = "I/Self Query.md";
    if (this.view.file.path === queryMd) {
      new import_obsidian22.Notice("Checking... may need some time");
      const tag2 = choosenValue.replace(/^@/, "#");
      const filePaths = filesWhereTagIsUsed(tag2);
      let result = "## Orphan notes for tag `" + tag2 + "`\n";
      for (const filePath of filePaths) {
        console.log(`Checking backlinks for ${filePath}`);
        const tFile = this.app.vault.getAbstractFileByPath(filePath);
        const backlinks = this.app.metadataCache.getBacklinksForFile(tFile);
        console.log(backlinks);
        console.log(backlinks.data);
        if (!backlinks || !backlinks.data || Object.keys(backlinks.data).length === 0) {
          console.log(`No backlinks for ${tFile.path}`);
          result += "\n- [[" + tFile.basename + "]]";
        } else {
          delete backlinks.data[queryMd];
          if (Object.keys(backlinks.data).length === 0) {
            console.log(`No backlinks for ${tFile.path}`);
            result += "\n- [[" + tFile.basename + "]]";
          } else {
            console.log(`Has backlinks for ${tFile.path}`);
          }
        }
      }
      this.editor.setValue(result);
      new import_obsidian22.Notice("Updated orphan");
    } else {
      new import_obsidian22.Notice("Please go to '" + queryMd + "' to run this action");
    }
  }
};

// main.ts
var DEFAULT_SETTINGS = {
  mySetting: "default"
};
var clipboardHistory = [];
var MyPlugin = class extends import_obsidian23.Plugin {
  async onload() {
    await this.loadSettings();
    if (navigator.clipboard) {
      document.addEventListener("copy", (event) => {
        var _a;
        const copiedText = (_a = event.clipboardData) == null ? void 0 : _a.getData("text/plain");
        if (copiedText != null) {
          this.addToClipboardHistory(copiedText);
        }
      });
      document.addEventListener("cut", (event) => {
        var _a;
        const copiedText = (_a = event.clipboardData) == null ? void 0 : _a.getData("text/plain");
        if (copiedText != null) {
          this.addToClipboardHistory(copiedText);
        }
      });
    } else {
      console.log("Clipboard API is not supported in this browser.");
    }
    ["n", "l", "w", "d", "a", "1", "2", "3", "4", "5", "6", "7"].forEach((t) => {
      this.addActionIcon(t);
      this.addActionCommand(t);
    });
    ["t", "m", "e"].forEach((t) => {
      this.addActionIcon(t);
      this.addFollowUpCommand(t);
    });
    ["n", "w"].forEach((t) => {
      this.addNewLaterActionIcon(t);
      this.addNewLaterAction(t);
    });
    this.addCommand({
      id: "obsidian-remove-clipboard-content",
      name: "RC Obsidian Remove Clipboard Content",
      icon: "obsidian-remove-clipboard-content",
      editorCallback: (editor, view) => {
        new ClipboardRemovalModal(this.app, editor, clipboardHistory).open();
      }
    });
    this.addObsidianIcon("auto-correct", "AC");
    this.addCommand({
      id: "auto-correct",
      name: "Auto Correct AC",
      icon: "auto-correct",
      editorCallback: (editor, view) => {
        const value = editor.getValue();
        let modifiedValue = value.replace(/10分/g, "\u5341\u5206").replace(/裏/g, "\u88E1").replace(/大佬/g, "\u5927\u8166");
        modifiedValue = modifiedValue.replace(/([a-zA-Z0-9])([\u4E00-\u9FFF])/g, "$1 $2").replace(/([\u4E00-\u9FFF])([a-zA-Z0-9])/g, "$1 $2");
        editor.setValue(modifiedValue);
      }
    });
    this.addObsidianIcon("find-broken-link", "BL");
    this.addCommand({
      id: "find-broken-link",
      name: "Find Broken Link BL",
      icon: "find-broken-link",
      editorCallback: (editor, view) => {
        if (view.file.path !== "I/Broken Link.md") {
          const cursor = editor.getCursor();
          const line = cursor.line;
          const lineContent = editor.getLine(line);
          if (/\[\[.*[:?\/\\<>].*\]\]/.test(lineContent)) {
            new import_obsidian23.Notice("Trying to fix broken line in current line: " + lineContent);
            editor.setLine(
              line,
              lineContent.replace(/:/g, "_").replace(/\?/g, "_").replace(/\//g, "_").replace(/\\/g, "_").replace(/</g, "_").replace(/>/g, "_").replace(/^(parent\d+)_ /, "$1: ").replace(/^(title\d+)_ /, "$1: ")
            );
          } else {
            const unresolvedLinks2 = this.app.metadataCache.unresolvedLinks;
            const brokenLinkRecord = unresolvedLinks2[view.file.path];
            if (brokenLinkRecord == null) {
              new import_obsidian23.Notice("No broken link found in this file");
              return;
            }
            const brokenLinks = Object.keys(brokenLinkRecord);
            if (brokenLinks == null || brokenLinks.length == 0) {
              new import_obsidian23.Notice("No broken link found in this file");
              return;
            }
            for (let i = line + 1; i < editor.lineCount(); i++) {
              const lineContent2 = editor.getLine(i);
              for (let b = 0; b < brokenLinks.length; b++) {
                const brokenLink = brokenLinks[b];
                if (lineContent2.contains("[[" + brokenLink + "]]")) {
                  editor.setCursor({ line: i, ch: 0 });
                  editor.scrollIntoView({ from: { line: i, ch: 0 }, to: { line: i, ch: 0 } }, true);
                  new import_obsidian23.Notice("Navigated to next Broken link starting from cursor");
                  return;
                }
              }
            }
            new import_obsidian23.Notice("No broken link found after cursor line in this file");
          }
          return;
        }
        let count = 0;
        let result = "";
        const unresolvedLinks = this.app.metadataCache.unresolvedLinks;
        for (const [key, value] of Object.entries(unresolvedLinks)) {
          let v = "";
          for (const [k1, v1] of Object.entries(value)) {
            v += k1 + ":" + v1 + ", ";
          }
          v = v.replace(/, $/, "");
          if (v !== "") {
            console.log(key + " -> [" + v + "]");
            result += "- [[" + key.replace(/\.md$/, "") + "]]";
            result += "\n";
            for (const [k2, v2] of Object.entries(value)) {
              result += "	- " + k2.replace(/\.md$/, "");
              result += "\n";
            }
            count++;
          }
        }
        editor.setValue(result);
        new import_obsidian23.Notice("Updated broken link. count=" + count);
      },
      hotkeys: [
        {
          modifiers: [`Ctrl`, `Meta`, `Shift`],
          key: `5`
        },
        {
          modifiers: [`Ctrl`, `Alt`, `Shift`],
          key: `5`
        }
      ]
    });
    this.addCommand({
      id: "open-tag-search",
      name: "Open tag search",
      icon: "hash",
      callback: () => {
        const searchPlugin = this.app.internalPlugins.getPluginById("global-search");
        const search = searchPlugin && searchPlugin.instance;
        if (searchPlugin && searchPlugin.instance) {
          new TagSearchModal(this.app, search).open();
        } else {
          new import_obsidian23.Notice("Please enable the search core plugin!");
        }
      },
      hotkeys: [
        {
          modifiers: [`Ctrl`, `Meta`, `Shift`],
          key: `s`
        },
        {
          modifiers: [`Ctrl`, `Alt`, `Shift`],
          key: `s`
        }
      ]
    });
    this.addCommand({
      id: "open-tag-search",
      name: "Open tag search",
      icon: "hash",
      callback: () => {
        const searchPlugin = this.app.internalPlugins.getPluginById("global-search");
        const search = searchPlugin && searchPlugin.instance;
        if (searchPlugin && searchPlugin.instance) {
          new TagSearchModal(this.app, search).open();
        } else {
          new import_obsidian23.Notice("Please enable the search core plugin!");
        }
      },
      hotkeys: [
        {
          modifiers: [`Ctrl`, `Meta`, `Shift`],
          key: `s`
        },
        {
          modifiers: [`Ctrl`, `Alt`, `Shift`],
          key: `s`
        }
      ]
    });
    this.addCommand({
      id: "self-query",
      name: "Self Query",
      editorCallback: (editor, view) => {
        new QueryOrphanNotesByTagModal(this.app, editor, view).open();
      }
    });
    this.addObsidianIcon("obsidian-paste", "\u2318V");
    this.addCommand({
      id: "obsidian-paste",
      name: "Obsidian Paste",
      icon: "obsidian-paste",
      editorCallback: (editor, view) => {
        new ClipboardPasteModal(this.app, editor, clipboardHistory).open();
      },
      hotkeys: [
        {
          modifiers: [`Meta`, `Shift`],
          key: `v`
        }
      ]
    });
    this.addObsidianIcon("update-note-type-icon", "NT");
    this.addCommand({
      id: "update-note-type",
      name: "Update Note Type",
      icon: `update-note-type-icon`,
      editorCallback: (editor, view) => {
        new UpdateNoteTypeModal(this.app, editor, view.file).open();
      },
      hotkeys: [
        {
          modifiers: [`Ctrl`, `Meta`, `Shift`],
          key: `c`
        },
        {
          modifiers: [`Ctrl`, `Alt`, `Shift`],
          key: `c`
        }
      ]
    });
    this.addCommand({
      id: "open-recent-days-schedule-with-updated-schedule",
      name: "OR Open Recent Days Updated Schedule",
      icon: "open-recent-day-schedule-icon",
      callback: async () => {
        const { vault } = this.app;
        const scheduleNoteWithoutMd = "D/Scheduling";
        const scheduleNote = `${scheduleNoteWithoutMd}.md`;
        if (vault.getAbstractFileByPath(scheduleNote) == null) {
          await vault.create(scheduleNote, "");
        }
        let noteContent = "";
        Array.from(Array(7).keys()).forEach((i) => noteContent += this.getQueryDateString(i, scheduleNoteWithoutMd));
        vault.modify(vault.getAbstractFileByPath(scheduleNote), noteContent);
        this.addActionNoteContent(vault, "D", "Query W now actions", "Weekly Schedule W", "w");
        this.addActionNoteContent(vault, "D", "Query N now actions", "Weekly Schedule N", "n");
        this.add3DaysActionNoteContent(vault);
        new import_obsidian23.Notice("Updated schedule");
        const { workspace } = this.app;
        const dashboardCanvas = "D/Query Schedule and Actions next 3 days.md";
        const mode = this.app.vault.getConfig("defaultViewMode");
        const leaf = workspace.getLeaf(false);
        await leaf.openFile(vault.getAbstractFileByPath(dashboardCanvas), {
          active: true
          /* mode */
        });
      }
    });
    this.addObsidianIcon("update-scheduling-icon", "US");
    this.addCommand({
      id: "update-scheduling",
      name: "Update Scheduling",
      icon: "update-scheduling-icon",
      callback: async () => {
        const { vault } = this.app;
        const scheduleNoteWithoutMd = "D/Scheduling";
        const scheduleNote = `${scheduleNoteWithoutMd}.md`;
        if (vault.getAbstractFileByPath(scheduleNote) == null) {
          await vault.create(scheduleNote, "");
        }
        let noteContent = "";
        Array.from(Array(7).keys()).forEach((i) => noteContent += this.getQueryDateString(i, scheduleNoteWithoutMd));
        vault.modify(vault.getAbstractFileByPath(scheduleNote), noteContent);
        this.addActionNoteContent(vault, "D", "Query W now actions", "Weekly Schedule W", "w");
        this.addActionNoteContent(vault, "D", "Query N now actions", "Weekly Schedule N", "n");
        this.add3DaysActionNoteContent(vault);
        new import_obsidian23.Notice("Updated schedule");
      }
      /*,
      hotkeys: [
      	{
      		modifiers: [`Ctrl`, `Meta`, `Shift`],
      		key: `u`,
      	},
      	{
      		modifiers: [`Ctrl`, `Alt`, `Shift`],
      		key: `u`,
      	},
      ]*/
    });
    this.addObsidianIcon("open-recent-day-schedule-icon", "OR");
    this.addCommand({
      id: "open-recent-days-schedule",
      name: "Open Recent Days Schedule",
      icon: "open-recent-day-schedule-icon",
      callback: async () => {
        const { vault, workspace } = this.app;
        const dashboardCanvas = "D/Query Schedule and Actions next 3 days.md";
        const leaf = workspace.getLeaf(false);
        await leaf.openFile(vault.getAbstractFileByPath(dashboardCanvas), { active: true });
      }
    });
    this.addObsidianIcon("open-inbox-icon", "OI");
    this.addCommand({
      id: "open-inbox",
      name: "OI Open Inbox",
      icon: "open-inbox-icon",
      callback: async () => {
        const { vault, workspace } = this.app;
        const inboxMd = "I/Inbox.md";
        const leaf = workspace.getLeaf(false);
        await leaf.openFile(vault.getAbstractFileByPath(inboxMd), { active: true });
      }
    });
    this.addObsidianIcon("open-playground-icon", "OP");
    this.addCommand({
      id: "open-playground",
      name: "OP Open Playground",
      icon: "open-playground-icon",
      callback: async () => {
        new OpenPlaygroundModal(this.app).open();
      },
      hotkeys: [
        {
          modifiers: [`Ctrl`, `Meta`, `Shift`],
          key: `p`
        },
        {
          modifiers: [`Ctrl`, `Alt`, `Shift`],
          key: `p`
        }
      ]
    });
    this.addObsidianIcon("open-braindump-icon", "OB");
    this.addCommand({
      id: "open-braindump",
      name: "OB Open BrainDump",
      icon: "open-braindump-icon",
      callback: async () => {
        const { vault, workspace } = this.app;
        const inboxMd = "I/Brain Dump.md";
        const leaf = workspace.getLeaf(false);
        await leaf.openFile(vault.getAbstractFileByPath(inboxMd), { active: true });
      }
    });
    this.addObsidianIcon("format-all-notes-custom", "FA");
    this.addCommand({
      id: "format-all-notes-custom",
      name: "FA Format All Notes (Custom usage)",
      icon: `format-all-notes-custom`,
      callback: async () => {
        const vault = this.app.vault;
        let startCount = 0;
        let finishedCount = 0;
        const files = vault.getMarkdownFiles();
        new import_obsidian23.Notice("all=" + files.length);
        console.log("all=" + files.length);
        for (const file of files) {
          console.log("s: " + startCount);
          vault.read(file).then((content) => {
            const modifiedValue = tidyUpFrontMatterOnValue(content);
            return vault.modify(file, modifiedValue);
          }).then(() => {
            console.log("f: " + finishedCount);
            finishedCount++;
            if (finishedCount == files.length) {
              console.log("finished");
              new import_obsidian23.Notice("finished");
            }
          });
          startCount++;
        }
      },
      hotkeys: [
        {
          modifiers: [`Ctrl`, `Meta`, `Shift`],
          key: `1`
        },
        {
          modifiers: [`Ctrl`, `Alt`, `Shift`],
          key: `1`
        }
      ]
    });
    this.addObsidianIcon("tw-fix-broken-link", ":_");
    this.addCommand({
      id: "tw-fix-broken-link",
      name: "BL Fix TW Broken Link",
      icon: `tw-fix-broken-link`,
      editorCallback: (editor, view) => {
        const cursor = editor.getCursor();
        const line = cursor.line;
        const lineContent = editor.getLine(line);
        editor.setLine(
          line,
          lineContent.replace(/:/g, "_").replace(/\?/g, "_").replace(/\//g, "_").replace(/</g, "_").replace(/>/g, "_").replace(/^(parent\d+)_ /, "$1: ").replace(/^(title\d+)_ /, "$1: ")
        );
      }
      /*,
      hotkeys: [
      	{
      		modifiers: [`Ctrl`, `Meta`, `Shift`],
      		key: `5`,
      	},
      	{
      		modifiers: [`Ctrl`, `Alt`, `Shift`],
      		key: `5`,
      	},
      ]*/
    });
    this.addObsidianIcon("format-notes-custom", "FN");
    this.addCommand({
      id: "format-notes-custom",
      name: "FN Format Notes (Custom usage)",
      icon: `format-notes-custom`,
      editorCallback: (editor, view) => {
        tidyUpFrontMatteronEditor(editor);
      },
      hotkeys: [
        {
          modifiers: [`Ctrl`, `Meta`, `Shift`],
          key: `2`
        },
        {
          modifiers: [`Ctrl`, `Alt`, `Shift`],
          key: `2`
        }
      ]
    });
    this.addObsidianIcon("tw-get-parent-link", "[]");
    this.addCommand({
      id: "tw-get-parent-link",
      name: "tw-get-parent-link",
      icon: `tw-get-parent-link`,
      editorCallback: (editor, view) => {
        const cursor = editor.getCursor();
        const line = cursor.line;
        const ch = cursor.ch;
        const lineContent = editor.getLine(line);
        if (/^parent\d+: /.test(lineContent) || /^\t+- parent\d+: /.test(lineContent)) {
          const parentLink = lineContent.replace(/^parent\d+: /, "").replace(/^\t+- parent\d+: /, "").replace(/"/g, "").replace(/\[\[/, "").replace(/\]\]/, "");
          navigator.clipboard.writeText(parentLink).then(() => {
            if (line == 0) {
              editor.setValue("");
            } else {
              const previousLine = editor.getLine(line - 1);
              editor.replaceRange("", { line: line - 1, ch: previousLine.length }, { line, ch: lineContent.length });
            }
            editor.setValue(editor.getValue().replace(/^---\n+---\n/, "---\ntags: b/n/c\n---\n").replace(/\n$/, ""));
            editor.setCursor({ line, ch: ch > editor.getLine(line).length ? editor.getLine(line).length : ch });
            new import_obsidian23.Notice("Copied to clipboard: " + parentLink);
          });
        }
      },
      hotkeys: [
        {
          modifiers: [`Ctrl`, `Meta`, `Shift`],
          key: `y`
        },
        {
          modifiers: [`Ctrl`, `Alt`, `Shift`],
          key: `y`
        }
      ]
    });
    this.addObsidianIcon("tw-tidy-list-note", "==");
    this.addCommand({
      id: "tw-tidy-list-note",
      name: "TL == TW Tidy List Note",
      icon: `tw-tidy-list-note`,
      editorCallback: (editor, view) => {
        editor.setValue(replaceTWUselessValue(editor.getValue()));
        const lineCount = editor.lineCount();
        let fm = "";
        let c = "";
        let text = "";
        let h3Count = 0;
        let content = "";
        let taskTag = "";
        for (let i = 0; i < lineCount; i++) {
          const line = editor.getLine(i);
          if (h3Count == 0) {
            if (line.length != 0 && !/^\t*- ```$/.test(line)) {
              const modifiedLine = line.contains("[[") && line.contains("]]") ? line : line.replace(view.file.basename + " _ ", "").replace(/(\t*- )#+ > /, "$1").replace(/(\t+- )#+ /, "$1");
              content += modifiedLine + "\n";
            }
          } else if (h3Count == 1) {
            if (line.startsWith("title: ") || line.startsWith("list: ")) {
              fm += line + "\n";
            } else if (line.length != 0 && !/^\t*- ```$/.test(line)) {
              const modifiedLine = line.contains("[[") && line.contains("]]") ? line : line.replace(view.file.basename + " _ ", "").replace(/(\t*- )#+ > /, "$1").replace(/(\t+- )#+ /, "$1");
              fm += modifiedLine + "\n";
            }
          }
          if (h3Count >= 2) {
            if (line.length != 0 && !/^\t*- ```$/.test(line)) {
              const modifiedLine = line.contains("[[") && line.contains("]]") ? line : line.replace(view.file.basename + " _ ", "").replace(/(\t*- )#+ > /, "$1").replace(/(\t+- )#+ /, "$1");
              c += modifiedLine + "\n";
            }
          }
          if (line === "---") {
            h3Count++;
            if (h3Count == 2) {
              fm += "\n";
            }
          }
        }
        text += content;
        if (fm.length > 0) {
          text += fm;
        }
        text += c;
        text = text.replace(/^---\n+---\n/m, "---\ntags: b/n/c\n---\n").replace(/\n$/, "");
        editor.setValue(text);
      },
      hotkeys: [
        {
          modifiers: [`Ctrl`, `Meta`, `Shift`],
          key: `6`
        },
        {
          modifiers: [`Ctrl`, `Alt`, `Shift`],
          key: `6`
        }
      ]
    });
    this.addObsidianIcon("tw-task", "--");
    this.addCommand({
      id: "tw-task",
      name: "TT -- TW Task",
      icon: `tw-task`,
      editorCallback: (editor, view) => {
        editor.setValue(replaceTWUselessValue(editor.getValue()));
        const lineCount = editor.lineCount();
        let fm = "";
        let c = "";
        let text = "";
        let h3Count = 0;
        let content = "";
        let taskTag = "";
        for (let i = 0; i < lineCount; i++) {
          const line = editor.getLine(i);
          if (h3Count == 0) {
            content += line + "\n";
          } else if (h3Count == 1) {
            if (line.startsWith("title: ")) {
            } else if (line.startsWith("tagsss: ")) {
              taskTag = "a/";
              if (/ N /.test(line) || / N$/.test(line)) {
                taskTag += "n/";
              }
              if (/ W /.test(line) || / W$/.test(line)) {
                taskTag += "w/";
              }
              if (/ now /.test(line) || / now$/.test(line)) {
                taskTag += "n";
              }
              if (/ later /.test(line) || / later$/.test(line)) {
                taskTag += "l";
              }
              if (/ waiting /.test(line) || / waiting$/.test(line)) {
                taskTag += "w";
              }
              if (/ done /.test(line) || / done$/.test(line)) {
                taskTag += "d";
              }
              if (/ archive /.test(line) || / archine$/.test(line)) {
                taskTag += "a";
              }
              if (taskTag.length == 5) {
                fm += "tags: " + taskTag + "\n";
              } else {
                new import_obsidian23.Notice("error on setting action tag");
                fm += line + "\n";
              }
            } else {
              fm += line + "\n";
            }
          }
          if (h3Count >= 2) {
            let modifiedLine = line;
            c += modifiedLine + "\n";
          }
          if (line === "---") {
            h3Count++;
          }
        }
        text += content;
        if (fm.length > 0) {
          text += fm;
        }
        text += c;
        text = text.replace(/^---\n+---\n/m, "---\ntags: b/n/c\n---\n").replace(/\n$/, "");
        editor.setValue(text);
        editor.setCursor({ line: getParentLine(text), ch: 0 });
        app.vault.rename(view.file, "C/" + view.file.name);
      },
      hotkeys: [
        {
          modifiers: [`Ctrl`, `Meta`, `Shift`],
          key: `7`
        },
        {
          modifiers: [`Ctrl`, `Alt`, `Shift`],
          key: `7`
        }
      ]
    });
    this.addObsidianIcon("note-to-tree-list", "**");
    this.addCommand({
      id: "note-to-tree-list",
      name: "NT Note to Tree List",
      icon: `note-to-tree-list`,
      editorCallback: (editor, view) => {
        const checkboxMap = /* @__PURE__ */ new Map();
        const lineCount = editor.lineCount();
        if (editor.getValue().startsWith("- " + view.file.basename + "\n")) {
          const filename = view.file.basename;
          let text = "";
          for (let i = 0; i < lineCount; i++) {
            const line = editor.getLine(i);
            if (line.trim().length != 0) {
              if (!/^\t*- $/.test(line) && !/^\t*\d+\. $/.test(line)) {
                let modLine = line;
                if (!modLine.contains("[[") && !modLine.contains("]]")) {
                  modLine = line.replace(`${filename} _ `, "");
                }
                if (line !== `- ${view.file.basename}` && /^- /.test(line)) {
                  modLine = "	" + modLine;
                }
                text += modLine + "\n";
              }
            }
          }
          text = text.replace(/\n$/m, "");
          editor.setValue(text);
          editor.setCursor({ line: getParentLine(text), ch: 0 });
        } else {
          editor.setValue(replaceTWUselessValue(editor.getValue()));
          let text = "- ";
          let h3Count = 0;
          let actionTag = "";
          let content = "";
          for (let i = 0; i < lineCount; i++) {
            const line = editor.getLine(i);
            if (h3Count == 0) {
              if (line.trim().length != 0 && line != "---") {
                let modifiedLine = line;
                for (let i2 = 0; i2 < 9; i2++) {
                  modifiedLine = modifiedLine.replace(/^    /, "	");
                }
                modifiedLine = modifiedLine.replace(/^(\t*)\*\s/, "$1- ");
                modifiedLine = /^\t*- /.test(modifiedLine) || /^\t*\d+\. /.test(modifiedLine) ? "	" + modifiedLine : "	- " + modifiedLine;
                content += "\n" + modifiedLine;
              }
            } else if (h3Count == 1) {
              if (line === "---" || shouldSkipFrontMatter(line) || line.startsWith("title: ")) {
              } else if (line.startsWith("tagsss: ")) {
                if (/ N /.test(line) || / N$/.test(line)) {
                  actionTag = "n";
                }
                if (/ W /.test(line) || / W$/.test(line)) {
                  actionTag = "w";
                }
                if (/ now /.test(line) || / now$/.test(line)) {
                  actionTag += "n";
                }
                if (/ later /.test(line) || / later$/.test(line)) {
                  actionTag += "l";
                }
                if (/ waiting /.test(line) || / waiting$/.test(line)) {
                  actionTag += "w";
                }
                if (/ done /.test(line) || / done$/.test(line)) {
                  actionTag += "d";
                }
                if (/ archive /.test(line) || / archine$/.test(line)) {
                  actionTag += "w";
                }
                if (actionTag.length == 2) {
                  actionTag = "#" + actionTag + " ";
                } else if (actionTag.length == 1) {
                  new import_obsidian23.Notice("error on setting action tag");
                }
              } else if (line.startsWith("checkboxbytime_")) {
                const keyValueArray = line.split(":").map((item) => item.trim());
                if (keyValueArray.length === 2) {
                  const key = keyValueArray[0];
                  const value = keyValueArray[1];
                  const splitArray = key.split("_");
                  const modifiedKey = `<<checkboxByTime "${splitArray[1]}">>`;
                  checkboxMap.set(modifiedKey, value === "open" ? "[x]" : "[ ]");
                }
              } else {
                if (line.trim().length != 0) {
                  let modifiedLine = line;
                  for (let i2 = 0; i2 < 9; i2++) {
                    modifiedLine = modifiedLine.replace(/^    /, "	");
                  }
                  modifiedLine = modifiedLine.replace(/^(\t*)\*\s/, "$1- ");
                  modifiedLine = /^\t*- /.test(modifiedLine) || /^\t*\d+\. /.test(modifiedLine) ? "	" + modifiedLine : "	- " + modifiedLine;
                  content += "\n" + modifiedLine;
                }
              }
            }
            if (h3Count >= 2 && line.trim().length != 0) {
              let modifiedLine = line === "[ ] " ? "" : line;
              if (modifiedLine.trim().length != 0) {
                for (let i2 = 0; i2 < 9; i2++) {
                  modifiedLine = modifiedLine.replace(/^    /, "	");
                }
                modifiedLine = modifiedLine.replace(/^(\t*)\*\s/, "$1- ");
                modifiedLine = /^\t*- /.test(modifiedLine) || /^\t*\d+\. /.test(modifiedLine) ? "	" + modifiedLine : "	- " + modifiedLine;
                for (const [key, value] of checkboxMap) {
                  modifiedLine = modifiedLine.replace(new RegExp(key, "g"), value);
                }
                modifiedLine = modifiedLine.replace(/<<checkboxByTime "[A-Za-z0-9_]+">>/g, "[ ]");
                text += "\n" + modifiedLine;
              }
            }
            if (line === "---") {
              let beforeH3 = h3Count;
              h3Count++;
              if (beforeH3 == 1 && h3Count == 2) {
                text += actionTag + view.file.basename;
              }
            }
          }
          if (h3Count < 2) {
            text += view.file.basename;
          }
          text += content;
          editor.setValue(text);
          editor.setCursor({ line: getParentLine(text), ch: 0 });
        }
      },
      hotkeys: [
        {
          modifiers: [`Ctrl`, `Meta`, `Shift`],
          key: `8`
        },
        {
          modifiers: [`Ctrl`, `Alt`, `Shift`],
          key: `8`
        }
      ]
    });
    this.addCommand({
      id: "remove-content-from-cursor",
      name: "Remove content from cursor",
      icon: `axe`,
      editorCallback: (editor, view) => {
        new RemoveContentFromCursorModal(this.app, editor).open();
      },
      hotkeys: [
        {
          modifiers: [`Ctrl`, `Meta`, `Shift`],
          key: `x`
        },
        {
          modifiers: [`Ctrl`, `Alt`, `Shift`],
          key: `x`
        }
      ]
    });
    this.addCommand({
      id: "remove-content-left",
      name: "Remove content left same line",
      icon: `arrow-left-circle`,
      editorCallback: (editor, view) => {
        removeContentLeftSameLine(editor);
      }
    });
    this.addCommand({
      id: "remove-content-right",
      name: "Remove content right same line",
      icon: `arrow-right-circle`,
      editorCallback: (editor, view) => {
        removeContentLeftSameLine(editor);
      }
    });
    this.addCommand({
      id: "remove-content-top-left",
      name: "Remove content from start of note to cursor",
      icon: `arrow-up-circle`,
      editorCallback: (editor, view) => {
        removeContentFromStartOfNoteToCursor(editor);
      }
    });
    this.addCommand({
      id: "remove-content-bottom-right",
      name: "Remove content from cursor to end of note",
      icon: `arrow-down-circle`,
      editorCallback: (editor, view) => {
        removeContentFromCursorToEndOfNote(editor);
      }
    });
    this.addObsidianIcon("threads-to-blog-icon", "TB");
    this.addCommand({
      id: "threads-to-blog",
      name: "TB Threads as pre Blog format to Clipboard",
      icon: `threads-to-blog-icon`,
      editorCallback: (editor, view) => {
        new ThreadsToBlogModal(this.app, editor, view).open();
      }
    });
    this.addObsidianIcon("add-comment-tag-icon", "CT");
    this.addCommand({
      id: "add-comment-tag",
      name: "CT Add Comment Tag",
      icon: `add-comment-tag-icon`,
      editorCallback: (editor, view) => {
        new AddFootnoteTagModal(this.app, editor).open();
      },
      hotkeys: [
        {
          modifiers: [`Ctrl`, `Meta`, `Shift`],
          key: `z`
        },
        {
          modifiers: [`Ctrl`, `Alt`, `Shift`],
          key: `z`
        }
      ]
    });
    this.addObsidianIcon("action-tag-count-icon", "CA");
    this.addCommand({
      id: "action-tag-count-icon",
      name: "CA Count Action Tag",
      icon: `action-tag-count-icon`,
      editorCallback: (editor, view) => {
        const tags = ["nn", "nl", "nw", "n1", "n2", "n3", "n4", "n5", "n6", "n7", "wn", "wl", "ww", "w1", "w2", "w3", "w4", "w5", "w6", "w7"];
        const matches = [];
        const lineNum = editor.lineCount();
        for (let i = 0; i < lineNum; i++) {
          const line = editor.getLine(i);
          const match = tags.some((tag2) => new RegExp(`#${tag2} `, "g").test(line) || new RegExp(` #${tag2}`, "g").test(line));
          if (match) {
            matches.push(`Line ${i}:
${line.trim()}`);
          }
        }
        const trimmedAndJoinedString = matches.join("\n\n");
        const tasks = matches.length > 0 ? `
Tasks:

${trimmedAndJoinedString}` : ``;
        new import_obsidian23.Notice(`There are ${matches.length} outstanding actions in this notes${tasks}`);
      }
    });
    this.addObsidianIcon("toggle-n-w-task", "#=");
    this.addCommand({
      id: `toggle-n-w-task`,
      name: `Toggle N W Task`,
      icon: `toggle-n-w-task`,
      editorCallback: (editor, view) => {
        console.log(editor.getSelection());
        const cursor = editor.getCursor();
        const lineNumber = editor.getCursor().line;
        const line = editor.getLine(lineNumber);
        if (line.match(/ a\/w\/./)) {
          const replacedLine = line.replace(/ a\/w\/(.)/, ` a/n/$1`);
          editor.setLine(lineNumber, replacedLine);
          editor.setCursor(cursor);
        } else if (line.match(/ a\/n\/./)) {
          const replacedLine = line.replace(/ a\/n\/(.)/, ` a/w/$1`);
          editor.setLine(lineNumber, replacedLine);
          editor.setCursor(cursor);
        } else if (line.match(/#w. /)) {
          const replacedLine = line.replace(/#w(.) /, `#n$1 `);
          editor.setLine(lineNumber, replacedLine);
          editor.setCursor(cursor);
        } else if (line.match(/#n. /)) {
          const replacedLine = line.replace(/#n(.) /, `#w$1 `);
          editor.setLine(lineNumber, replacedLine);
          editor.setCursor(cursor);
        } else if (line.match(/ #w./)) {
          const replacedLine = line.replace(/ #w(.)/, ` #n$1`);
          editor.setLine(lineNumber, replacedLine);
          editor.setCursor(cursor);
        } else if (line.match(/ #n./)) {
          const replacedLine = line.replace(/ #n(.)/, ` #w$1`);
          editor.setLine(lineNumber, replacedLine);
          editor.setCursor(cursor);
        }
      },
      hotkeys: [
        {
          modifiers: [`Ctrl`, `Meta`, `Shift`],
          key: `=`
        },
        {
          modifiers: [`Ctrl`, `Alt`, `Shift`],
          key: `=`
        }
      ]
    });
    this.addCommand({
      id: "cursor-go-to-start-of-line",
      name: "Cursor go to start of line",
      icon: `arrow-big-left`,
      editorCallback: (editor, view) => {
        const cursor = editor.getCursor();
        cursor.ch = 0;
        editor.setCursor(cursor);
      }
    });
    this.addCommand({
      id: "cursor-go-to-end-of-line",
      name: "Cursor go to end of line",
      icon: `arrow-big-right`,
      editorCallback: (editor, view) => {
        const cursor = editor.getCursor();
        const lineNum = cursor.line;
        const line = editor.getLine(lineNum);
        const length = line.length;
        cursor.ch = length;
        editor.setCursor(cursor);
      }
    });
    this.addObsidianIcon("event-to-fantastical-icon", "FE");
    this.addCommand({
      id: "add-fantastical-event",
      name: "FE Add Fantastical Event",
      icon: `event-to-fantastical-icon`,
      editorCallback: (editor, view) => {
        let text = "";
        const vault = this.app.vault;
        const listSelections = editor.listSelections();
        const processLine = async (line, i) => {
          if (/^- \d\d\d\d-\d\d-\d\d \d\d:\d\d /.test(line)) {
            const modifiedLine = line.replace(/^- /, `- #tm `);
            editor.setLine(i, modifiedLine);
            text += line + "\n";
            const lineToAdd = "-" + line.replace(/-/g, "");
            const path = line.replace(/^- (\d\d\d\d)-(\d\d)-.*/, "J/$1-M$2.md");
            let tFile = vault.getAbstractFileByPath(path);
            if (tFile == null) {
              tFile = await vault.create(path, lineToAdd);
            } else {
              const tFileOriginalValue = await vault.read(tFile);
              await vault.modify(tFile, tFileOriginalValue + "\n" + lineToAdd);
            }
          }
        };
        const processSelections = async () => {
          for (const listSelection of listSelections) {
            const a = listSelection.head.line;
            const b = listSelection.anchor.line;
            const fromLineNum = b > a ? a : b;
            const toLineNum = b > a ? b : a;
            for (let i = fromLineNum; i <= toLineNum; i++) {
              const line = editor.getLine(i);
              await processLine(line, i);
            }
          }
        };
        processSelections().then(() => {
          if (text.length !== 0) {
            text = encodeURI(text);
            window.open(`shortcuts://run-shortcut?name=Add%20Obsidian%20Inbox%20Event%20via%20Fantastical&input=text&text=${text}&x-success=obsidian://&x-cancel=obsidian://&x-error=obsidian://`);
          }
        });
      }
    });
    this.addCommand({
      id: "grep-title-as-link-to-clipboard",
      name: "Grep Title as link to clipboard",
      icon: `clipboard-list`,
      editorCallback: async (editor, view) => {
        const title = view.file.basename;
        const titleAsLink = `[[${title}]]`;
        try {
          this.addToClipboardHistory(titleAsLink);
          await navigator.clipboard.writeText(titleAsLink);
          new import_obsidian23.Notice(`Copied title "${title}" as link to clipboard!`);
        } catch (error) {
          new import_obsidian23.Notice(`Error occurred when copying to clipboard: ${error}`);
        }
      },
      hotkeys: [
        {
          modifiers: [`Meta`, `Shift`],
          key: `l`
        },
        {
          modifiers: [`Ctrl`, `Shift`],
          key: `l`
        }
      ]
    });
    this.addObsidianIcon("move-current-selection-to-beginning-of-notes", "<<");
    this.addCommand({
      id: "move-current-selection-to-beginning-of-notes",
      name: "MB << Move current selection to beginning of notes",
      icon: `move-current-selection-to-beginning-of-notes`,
      editorCallback: (editor, view) => {
        let selection = exportCurrentSelection(editor);
        if (/^    +- /m.test(selection) || /^- /m.test(selection) || /^# /m.test(selection) || /^` /m.test(selection) || /^> /m.test(selection) || /^\d+\. /m.test(selection)) {
        } else {
          selection = "- " + selection;
        }
        let newContent = "";
        const selectionRange = getCurrentSelectionLineNumber(editor);
        for (let i = 0; i < editor.lineCount(); i++) {
          if (i < selectionRange.fromLineNum || i > selectionRange.toLineNum) {
            newContent = newContent + editor.getLine(i) + "\n";
          }
        }
        new AddTextToNotesModal(this.app, selection, "move the selected text", true, () => editor.setValue(newContent.replace(/\n$/m, ""))).open();
      },
      hotkeys: [
        {
          modifiers: [`Ctrl`, `Meta`, `Shift`],
          key: `,`
        },
        {
          modifiers: [`Ctrl`, `Alt`, `Shift`],
          key: `,`
        }
      ]
    });
    this.addObsidianIcon("move-current-selection-to-end-of-notes", ">>");
    this.addCommand({
      id: "move-current-selection-to-end-of-notes",
      name: "ME >> Move current selection to beginning of notes",
      icon: `move-current-selection-to-end-of-notes`,
      editorCallback: (editor, view) => {
        let selection = exportCurrentSelection(editor);
        if (/^    +- /m.test(selection) || /^- /m.test(selection) || /^# /m.test(selection) || /^` /m.test(selection) || /^> /m.test(selection) || /^\d+\. /m.test(selection)) {
        } else {
          selection = "- " + selection;
        }
        let newContent = "";
        const selectionRange = getCurrentSelectionLineNumber(editor);
        for (let i = 0; i < editor.lineCount(); i++) {
          if (i < selectionRange.fromLineNum || i > selectionRange.toLineNum) {
            newContent = newContent + editor.getLine(i) + "\n";
          }
        }
        new AddTextToNotesModal(this.app, selection, "move the selected text", false, () => editor.setValue(newContent.replace(/\n$/m, ""))).open();
      },
      hotkeys: [
        {
          modifiers: [`Ctrl`, `Meta`, `Shift`],
          key: `.`
        },
        {
          modifiers: [`Ctrl`, `Alt`, `Shift`],
          key: `.`
        }
      ]
    });
    this.addObsidianIcon("add-current-selection-to-beginning-of-notes", "((");
    this.addCommand({
      id: "add-current-selection-to-beginning-of-notes",
      name: "SB (( Add current selection to beginning of notes",
      icon: `add-current-selection-to-beginning-of-notes`,
      editorCallback: (editor, view) => {
        let selection = exportCurrentSelection(editor);
        if (/^    +- /m.test(selection) || /^- /m.test(selection) || /^# /m.test(selection) || /^` /m.test(selection) || /^> /m.test(selection) || /^\d+\. /m.test(selection)) {
        } else {
          selection = "- " + selection;
        }
        new AddTextToNotesModal(this.app, selection, "add the selected text", true, () => {
        }).open();
      },
      hotkeys: [
        {
          modifiers: [`Ctrl`, `Meta`, `Shift`],
          key: `9`
        },
        {
          modifiers: [`Ctrl`, `Alt`, `Shift`],
          key: `9`
        }
      ]
    });
    this.addObsidianIcon("add-current-selection-to-end-of-notes", "))");
    this.addCommand({
      id: "add-current-selection-to-end-of-notes",
      name: "SE )) Add current selection to end of notes",
      icon: `add-current-selection-to-end-of-notes`,
      editorCallback: (editor, view) => {
        let selection = exportCurrentSelection(editor);
        if (/^    +- /m.test(selection) || /^- /m.test(selection) || /^# /m.test(selection) || /^` /m.test(selection) || /^> /m.test(selection) || /^\d+\. /m.test(selection)) {
        } else {
          selection = "- " + selection;
        }
        new AddTextToNotesModal(this.app, selection, "add the selected text", false, () => {
        }).open();
      },
      hotkeys: [
        {
          modifiers: [`Ctrl`, `Meta`, `Shift`],
          key: `0`
        },
        {
          modifiers: [`Ctrl`, `Alt`, `Shift`],
          key: `0`
        }
      ]
    });
    this.addObsidianIcon("add-current-link-to-beginning-of-notes", "[[");
    this.addCommand({
      id: "add-current-link-to-beginning-of-notes",
      name: "LB [[ Add current link to beginning of notes",
      icon: `add-current-link-to-beginning-of-notes`,
      editorCallback: (editor, view) => {
        const link = "- [[" + view.file.basename + "]]";
        new AddTextToNotesModal(this.app, link, "add the current note link", true, () => {
        }).open();
      },
      hotkeys: [
        {
          modifiers: [`Ctrl`, `Meta`, `Shift`],
          key: `[`
        },
        {
          modifiers: [`Ctrl`, `Alt`, `Shift`],
          key: `[`
        }
      ]
    });
    this.addObsidianIcon("add-current-link-to-end-of-notes", "]]");
    this.addCommand({
      id: "add-current-link-to-end-of-notes",
      name: "LE ]] Add current link to end-of-notes",
      icon: `add-current-link-to-end-of-notes`,
      editorCallback: (editor, view) => {
        const link = "- [[" + view.file.basename + "]]";
        new AddTextToNotesModal(this.app, link, "add the current note link", false, () => {
        }).open();
      },
      hotkeys: [
        {
          modifiers: [`Ctrl`, `Meta`, `Shift`],
          key: `]`
        },
        {
          modifiers: [`Ctrl`, `Alt`, `Shift`],
          key: `]`
        }
      ]
    });
    this.addCommand({
      id: "quick-navigate-to-notes",
      name: "NN Quick Navigate to Notes",
      icon: `aperture`,
      callback: async () => {
        new NavigateToNoteFromTagModal(this.app).open();
      },
      hotkeys: [
        {
          modifiers: [`Ctrl`, `Meta`, `Shift`],
          key: `;`
        },
        {
          modifiers: [`Ctrl`, `Alt`, `Shift`],
          key: `;`
        }
      ]
    });
    this.addObsidianIcon("threads-to-twitter", "TX");
    this.addCommand({
      id: "threads-to-twitter",
      name: "TT TX Threads to Twitter",
      icon: `threads-to-twitter`,
      editorCallback: (editor, view) => {
        const { vault } = this.app;
        const v = editor.getValue();
        const path = view.file.path;
        if (!path.match(/.\/Threads \d\d\d\d\d\d\d\d/)) {
          new import_obsidian23.Notice(`Will not proceed. It is not a threads post.`);
          return;
        }
        const newPath = path.replace(/(.\/)Threads /, "$1Twitter ");
        const { workspace } = this.app;
        const leaf = workspace.getLeaf(false);
        Promise.resolve().then(() => {
          return vault.adapter.exists(newPath);
        }).then((fileExists) => {
          if (fileExists) {
            new import_obsidian23.Notice(`Will not proceed. Twitter post already exist.`);
            return Promise.reject("Twitter post already exist");
          }
          return vault.create(newPath, v);
        }).then((tFile) => {
          return leaf.openFile(tFile, { active: true });
        }, (reason) => {
        }).then(() => {
          new import_obsidian23.Notice(`Created and opened Twitter notes!`);
        });
      }
    });
    this.addObsidianIcon("blog-to-clipboard-icon", "BJ");
    this.addCommand({
      id: "blog-to-clipboard",
      name: "BJ Blog content to clipboard",
      icon: `blog-to-clipboard-icon`,
      editorCallback: async (editor, view) => {
        const v = editor.getValue();
        if (v.includes("#nn") || v.includes("#nl") || v.includes("#nw") || v.includes("#wn") || v.includes("#wl") || v.includes("#ww")) {
          new import_obsidian23.Notice(`Will not proceed. As there are unfinished action tag.`);
          return;
        }
        if (!v.includes("<!--more-->")) {
          try {
            await navigator.clipboard.writeText("<!--more-->");
            new import_obsidian23.Notice(`Require "<!--more-->" as excerpt separator before posting.
"<!--more-->" already in clipboard`);
          } catch (error) {
            new import_obsidian23.Notice(`Require "<!--more-->" as excerpt separator before posting.
"<!--more-->" cannot be copied to clipboard`);
          }
          return;
        }
        const path = view.file.path;
        let line = editor.lineCount();
        let text = "";
        let numLineFirstContent = 0;
        let frontMatterLineCount = 0;
        for (let i = 0; i < line; i++) {
          if (frontMatterLineCount == 2) {
            numLineFirstContent = i;
            break;
          }
          if (editor.getLine(i) == "---") {
            frontMatterLineCount++;
          }
        }
        for (let i = 0; i < line; i++) {
          if (editor.getLine(numLineFirstContent).trim() == "") {
            numLineFirstContent++;
          } else {
            break;
          }
        }
        Array.from(Array(line - numLineFirstContent).keys()).forEach((i) => {
          const line2 = editor.getLine(i + numLineFirstContent);
          text = text + line2 + "\n";
        });
        text = text.replace(/\n---\n\n#nd generate summary for meta description below:\n[^\n]*\n([^\n]*)\n[^\n]*\n---\n/, "\n<!-- Meta Summary -->\n<!--\n$1\n-->\n");
        text = text.replace(/## References\:([\n]*.*)*$/, "");
        const app2 = this.app;
        const beforeTagCBR = "c/b/r";
        const beforeTagCBD = "c/b/d";
        const beforeTagCBI = "c/b/i";
        const afterTag = "c/b/p";
        try {
          await navigator.clipboard.writeText(text);
          new import_obsidian23.Notice(`Copied blog content to clipboard!`);
          const foundTagFromCBR = await renameTag(view.file, beforeTagCBR, afterTag);
          if (foundTagFromCBR) {
            new import_obsidian23.Notice(`Update notes type from tag="${beforeTagCBR}" to tag="${afterTag}!`);
          }
          const foundTagFromCBI = await renameTag(view.file, beforeTagCBI, afterTag);
          if (foundTagFromCBI) {
            new import_obsidian23.Notice(`Update notes type from tag="${foundTagFromCBI}" to tag="${afterTag}!`);
          }
          const foundTagFromCBD = await renameTag(view.file, beforeTagCBD, afterTag);
          if (foundTagFromCBD) {
            new import_obsidian23.Notice(`Update notes type from tag="${beforeTagCBD}" to tag="${afterTag}!`);
          }
          await renameBlogTitle(app2, path, view);
          window.open(`shortcuts://run-shortcut?name=Jekyll%20blog&x-cancel=obsidian://&x-error=obsidian://`);
        } catch (error) {
          new import_obsidian23.Notice(`Error occurred during the operation: ${error}`);
        }
      }
    });
    this.addObsidianIcon("generate-chatgpt-prompt", "GP");
    this.addCommand({
      id: "generate-chatgpt-prompt",
      name: "GP Generate ChatGPT Prompt",
      icon: `generate-chatgpt-prompt`,
      editorCallback: async (editor, view) => {
        let line = editor.lineCount();
        let text = "\u3010" + view.file.basename + "\u3011\n\n";
        let numLineFirstContent = 0;
        let frontMatterLineCount = 0;
        for (let i = 0; i < line; i++) {
          if (frontMatterLineCount == 2) {
            numLineFirstContent = i;
            break;
          }
          if (editor.getLine(i) == "---") {
            frontMatterLineCount++;
          }
        }
        for (let i = 0; i < line; i++) {
          if (editor.getLine(numLineFirstContent).trim() == "") {
            numLineFirstContent++;
          } else {
            break;
          }
        }
        Array.from(Array(line - numLineFirstContent).keys()).forEach((i) => {
          const line2 = editor.getLine(i + numLineFirstContent);
          if (!line2.startsWith("%%") && !line2.endsWith("%%")) {
            text = text + line2 + "\n";
          }
        });
        text = text.replace(/## References\:([\n]*.*)*$/, "");
        navigator.clipboard.writeText(text).then(function() {
          new import_obsidian23.Notice(`Copied content to clipboard for generating prompt!`);
          window.open(`shortcuts://run-shortcut?name=Generate%20ChatGPT%20Prompt&x-success=obsidian://&x-cancel=obsidian://&x-error=obsidian://`);
        }, function(error) {
          new import_obsidian23.Notice(`error when copy to clipboard!`);
        });
      }
    });
    this.addObsidianIcon("threads-to-clipboard-icon", "TC");
    this.addCommand({
      id: "threads-to-clipboard",
      name: "TC Threads content to clipboard",
      icon: `threads-to-clipboard-icon`,
      editorCallback: (editor, view) => {
        const value = editor.getValue();
        const text = this.getThreadsSegment(editor);
        const beforeTag = "c/t/r";
        const afterTag = "c/t/t";
        navigator.clipboard.writeText(text).then(function() {
          return renameTag(view.file, beforeTag, afterTag);
        }, function(error) {
          new import_obsidian23.Notice(`error when copy to clipboard!`);
        }).then((foundTag) => {
          if (foundTag) {
            new import_obsidian23.Notice(`Update notes type from tag="${beforeTag}" to tag="${afterTag}!
Copied thread content to clipboard!`);
          } else {
            new import_obsidian23.Notice(`Tag "${beforeTag}" not found
Copied thread content to clipboard!`);
          }
        });
      }
    });
    this.addObsidianIcon("twitter-to-chatgpt", "XG");
    this.addCommand({
      id: "twitter-to-chatgpt",
      name: "XG Twitter to ChatGPT",
      icon: `twitter-to-chatgpt`,
      editorCallback: (editor, view) => {
        const value = editor.getValue();
        if (!view.file.basename.contains("Twitter")) {
          new import_obsidian23.Notice("Note name not contains 'Twitter', did not copy from thread note?");
          return;
        }
        let content = this.convertThreadsContentToPOE(editor);
        let numTweet = Math.ceil(content.length / 110);
        let prompt = `\u60A8\u662F\u793E\u4EA4\u5A92\u9AD4\u5167\u5BB9\u64B0\u5BEB\u5E2B\u3002\u5C07\u4E0B\u5217\u5167\u5BB9\u8F49\u70BA\u4E0D\u8D85\u904E${numTweet}\u689D\u7684\u63A8\u7279\u4E32\uFF0C\u4EE5\u7E41\u9AD4\u4E2D\u6587\u5448\u73FE\u3002\u4FDD\u7559\u6A19\u984C\uFF0C\u4E26\u5C07\u6A19\u984C\u5408\u4F75\u5230\u7B2C\u4E00\u689D\u63A8\u6587\u4E2D\uFF0C\u6A19\u984C\u548C\u7B2C\u4E00\u689D\u63A8\u6587\u4E4B\u9593\u52A0\u5169\u500B\u63DB\u884C\u3002\u6BCF\u689D\u63A8\u6587\u8981\u8D85\u904E100\u5B57\u4F46\u4E0D\u8D85\u904E140\u5B57\u3002\u5167\u5BB9\u4E0D\u7C21\u5316\uFF0C\u4E0D\u65B0\u589E\u672A\u63D0\u53CA\u8CC7\u8A0A\u3002\u4FDD\u7559\u539F\u6587\u4F8B\u5B50\uFF0C\u4E0D\u52A0\u6A19\u7C64\u3002\u63A8\u6587\u4E2D\u4E0D\u52A0\u6578\u5B57\u3002\u6BCF\u689D\u63A8\u6587\u5F8C\u52A0\u5169\u500B\u63DB\u884C\u53CA\u4E09\u500B\u77ED\u5283\u7DDA\u548C\u53E6\u4E00\u500B\u63DB\u884C\u3002\u82F1\u6587\u548C\u4E2D\u6587\u4E4B\u9593\u52A0\u7A7A\u683C\u3002\u82E5\u539F\u6587\u6709\u7DB2\u5740\uFF0C\u4FDD\u7559\u7DB2\u5740\uFF0C\u4E0D\u7528Markdown\u683C\u5F0F\uFF0C\u4E26\u5728\u7DB2\u5740\u524D\u52A0\u5169\u500B\u63DB\u884C\u3002`;
        prompt = prompt + "\n\n" + content;
        prompt = prompt.replace(/▍/g, "");
        prompt = prompt.replace(/】\n+https\:\/\/github.com[^\n]+\n/m, "\u3011\n");
        prompt = prompt.replace(/\*\*/gm, "");
        navigator.clipboard.writeText(prompt).then(function() {
          let line = editor.lineCount();
          let numLineFirstContent = 0;
          let frontMatterLineCount = 0;
          for (let i = 0; i < line; i++) {
            if (frontMatterLineCount == 2) {
              numLineFirstContent = i;
              break;
            }
            if (editor.getLine(i) == "---") {
              frontMatterLineCount++;
            }
          }
          for (let i = 0; i < line; i++) {
            if (editor.getLine(numLineFirstContent).trim() == "") {
              numLineFirstContent++;
            } else {
              break;
            }
          }
          let text = "";
          Array.from(Array(numLineFirstContent).keys()).forEach((i) => {
            const line2 = editor.getLine(i);
            text = text + line2 + "\n";
          });
          editor.setValue(text);
          renameTag(view.file, "c/t/d", "c/x/d");
          renameTag(view.file, "c/t/r", "c/x/d");
          renameTag(view.file, "c/t/t", "c/x/d");
          renameTag(view.file, "c/t/p", "c/x/d");
          const cursor = editor.getCursor();
          cursor.line = editor.lineCount() - 1;
          cursor.ch = 0;
          editor.setCursor(cursor);
          new import_obsidian23.Notice("copied to clipboard, please open chatgpt to paste");
        }, function(error) {
          new import_obsidian23.Notice(`error when copy to clipboard!`);
        });
      }
    });
    this.addObsidianIcon("chatgpt-to-twitter", "GX");
    this.addCommand({
      id: "chatgpt-to-twitter",
      name: "GX ChatGPT to Twitter",
      icon: `chatgpt-to-twitter`,
      editorCallback: (editor, view) => {
        if (!editor.getValue().contains("c/x/d")) {
          new import_obsidian23.Notice("Note type not c/x/d, do the action in wrong note?");
          return;
        }
        const isSuccess = this.convertChatGPTToTwitterFormat(editor);
        if (isSuccess) {
          renameTag(view.file, "c/x/d", "c/x/r");
        }
      }
    });
    this.addObsidianIcon("reverse-twitter-number-icon", "RT");
    this.addCommand({
      id: "reverse-twitter-numbering",
      name: "RT Reverse Twitter Numbering",
      icon: `reverse-twitter-number-icon`,
      editorCallback: (editor, view) => {
        if (!editor.getValue().contains("c/x/r") && !editor.getValue().contains("c/x/p")) {
          new import_obsidian23.Notice("Note type not c/x/r nor c/x/p, do the action in wrong note?");
          return;
        }
        this.reverseTwitterNumbering(editor);
        renameTag(view.file, "c/x/p", "c/x/d");
        renameTag(view.file, "c/x/r", "c/x/d");
      }
    });
    this.addObsidianIcon("threads-as-facebook-post-to-clipboard-icon", "FC");
    this.addCommand({
      id: "threads-as-facebook-post-to-clipboard",
      name: "FC Threads as Facebook post format to Clipboard",
      icon: `threads-as-facebook-post-to-clipboard-icon`,
      editorCallback: (editor, view) => {
        const value = editor.getValue();
        const text = this.convertThreadsContentToFormatForFacebookApp(editor);
        const beforeTag = "c/t/t";
        const afterTag = "c/t/p";
        navigator.clipboard.writeText(text).then(function() {
          return renameTag(view.file, beforeTag, afterTag);
        }, function(error) {
          new import_obsidian23.Notice(`error when copy to clipboard!`);
        }).then((foundTag) => {
          if (foundTag) {
            new import_obsidian23.Notice(`Update notes type from tag="${beforeTag}" to tag="${afterTag}!
Copied fb content to clipboard!`);
          } else {
            new import_obsidian23.Notice(`Tag "${beforeTag}" not found
Copied fb content to clipboard!`);
          }
        });
      }
    });
    this.addObsidianIcon("threads-block-to-image", "TI");
    this.addCommand({
      id: "threads-block-to-image",
      name: "TI Threads segment to image",
      icon: `threads-block-to-image`,
      editorCallback: (editor, view) => {
        const threadSegment = this.getThreadSegment(editor);
        new ThreadsToImagesModal(this.app, threadSegment).open();
      }
    });
    this.addObsidianIcon("chatgpt-generate-image", "GI");
    this.addCommand({
      id: "chatgpt-generate-image",
      name: "GI ChatGPT image",
      icon: `chatgpt-generate-image`,
      editorCallback: (editor, view) => {
        window.open("shortcuts://run-shortcut?name=ChatGPT%20Generate%20Image&x-success=obsidian://&x-cancel=obsidian://&x-error=obsidian://");
      }
    });
    this.addObsidianIcon("twitter-segment-to-clipboard", "XC");
    this.addCommand({
      id: "twitter-segment-to-clipboard",
      name: "XC Twitter segment to clipboard",
      icon: `twitter-segment-to-clipboard`,
      editorCallback: (editor, view) => {
        const threadSegment = this.getTwitterSegment(editor);
        const beforeTag = "c/x/r";
        const afterTag = "c/x/p";
        navigator.clipboard.writeText(threadSegment).then(function() {
          return renameTag(view.file, beforeTag, afterTag);
        }, function(error) {
          new import_obsidian23.Notice(`error when copy to clipboard!`);
        }).then((foundTag) => {
          if (foundTag) {
            new import_obsidian23.Notice(`Update notes type from tag="${beforeTag}" to tag="${afterTag}!
Copied
\`\`\`
${threadSegment}\`\`\`
to clipboard!`);
          } else {
            new import_obsidian23.Notice(`Tag "${beforeTag}" not found
Copied
\`\`\`
${threadSegment}\`\`\`
to clipboard!`);
          }
        });
      }
    });
    this.addObsidianIcon("segment-to-clipboard", "SC");
    this.addCommand({
      id: "segment-to-clipboard",
      name: "SC Segment to clipboard",
      icon: `segment-to-clipboard`,
      editorCallback: (editor, view) => {
        const threadSegment = this.getSegment(editor);
        this.addToClipboardHistory(threadSegment);
        navigator.clipboard.writeText(threadSegment).then(function() {
          new import_obsidian23.Notice(`Copied
\`\`\`
${threadSegment}\`\`\`
to clipboard!`);
        }, function(error) {
          new import_obsidian23.Notice(`error when copy to clipboard!`);
        });
      }
    });
    this.addCommand({
      id: "n-find-replace",
      name: "Find or Replace",
      icon: `file-search`,
      editorCallback: (editor, view) => {
        new FindReplaceModal(this.app).open();
      }
    });
    this.addCommand({
      id: "toggle-bullet-number-list",
      name: "Toggle Bullet Number List",
      icon: `bullet-list`,
      editorCallback: (editor, view) => {
        const cursor = editor.getCursor();
        const ch = cursor.ch;
        const line = cursor.line;
        const lineContent = editor.getLine(line);
        const previousLineContent = line == 0 ? "" : editor.getLine(line - 1);
        if (/^(> )*\s*- /.test(lineContent)) {
          let n = "1.";
          const a = previousLineContent.match(/^\t*(\d+)\. /);
          if (a) {
            const nextN = parseInt(a[0]) + 1;
            n = nextN.toString() + ".";
          }
          const replacedLineContent = lineContent.replace(/^((> )*)(\s*)- /, "$1$3" + n + " ");
          editor.setLine(line, replacedLineContent);
          cursor.ch = cursor.ch + n.length - 1;
          editor.setCursor(cursor);
        } else if (/^(> )*\s*[\d]+\. /.test(lineContent)) {
          const n = lineContent.replace(/^((> )*)(\s*)([\d]+\. ).*/, "$4");
          const replacedLineContent = lineContent.replace(/^((> )*)(\s*)[\d]+\. /, "$1$3");
          editor.setLine(line, replacedLineContent);
          cursor.ch = cursor.ch - n.length > 0 ? cursor.ch - n.length : 0;
          editor.setCursor(cursor);
        } else {
          const replacedLineContent = lineContent.replace(/^((> )*)(\s*)/, "$1$3- ");
          editor.setLine(line, replacedLineContent);
          cursor.ch = cursor.ch + 2;
          editor.setCursor(cursor);
        }
      },
      hotkeys: [
        {
          modifiers: [`Ctrl`, `Meta`, `Shift`],
          key: `-`
        },
        {
          modifiers: [`Ctrl`, `Alt`, `Shift`],
          key: `-`
        }
      ]
    });
    this.addCommand({
      id: "copy-or-move-to-new-note",
      name: "Copy or Move to new note CMN",
      icon: `airplay`,
      editorCallback: async (editor, view) => {
        new CopyOrMoveToNewNoteModal(this.app, editor).open();
      }
    });
    this.addCommand({
      id: "editor-copy-line-to-clipboard",
      name: "Editor Copy Line to Clipboard",
      icon: `align-vertical-space-around`,
      editorCallback: (editor, view) => {
        const selection = exportCurrentSelection(editor);
        const copyContent = selection.contains("\n") ? selection : selection.replace(/^\t*- /, "").replace(/^\t*\d+\. /, "");
        this.addToClipboardHistory(copyContent);
        navigator.clipboard.writeText(copyContent).then(function() {
          new import_obsidian23.Notice(`Copied content
\`\`\`
${copyContent}
\`\`\`
to clipboard!`);
        }, function(error) {
          new import_obsidian23.Notice(`error when copy to clipboard!`);
        });
      },
      hotkeys: [
        {
          modifiers: [`Ctrl`, `Meta`, `Shift`],
          key: "/"
        },
        {
          modifiers: [`Ctrl`, `Alt`, `Shift`],
          key: "/"
        }
      ]
    });
    this.addCommand({
      id: "editor-cut-line-to-clipboard",
      name: "Editor Cut Line to Clipboard",
      icon: `align-vertical-justify-center`,
      editorCallback: (editor, view) => {
        const selection = exportCurrentSelection(editor);
        const cursor = editor.getCursor();
        const copyContent = selection.contains("\n") ? selection : selection.replace(/^\t*- /, "").replace(/^\t*\d+\. /, "");
        let newContent = "";
        const selectionRange = getCurrentSelectionLineNumber(editor);
        for (let i = 0; i < editor.lineCount(); i++) {
          if (i < selectionRange.fromLineNum || i > selectionRange.toLineNum) {
            newContent = newContent + editor.getLine(i) + "\n";
          }
        }
        this.addToClipboardHistory(copyContent);
        navigator.clipboard.writeText(copyContent).then(function() {
          new import_obsidian23.Notice(`Copied content
\`\`\`
${copyContent}
\`\`\`
to clipboard!`);
        }, function(error) {
          new import_obsidian23.Notice(`error when copy to clipboard!`);
        });
        editor.setValue(newContent);
        cursor.line = selectionRange.fromLineNum;
        if (editor.getLine(selectionRange.fromLineNum).length < selectionRange.fromCh) {
          cursor.ch = editor.getLine(selectionRange.fromLineNum).length;
        }
        editor.setCursor(cursor);
      },
      hotkeys: [
        {
          modifiers: [`Ctrl`, `Meta`, `Shift`],
          key: "\\"
        },
        {
          modifiers: [`Ctrl`, `Alt`, `Shift`],
          key: "\\"
        }
      ]
    });
    this.addCommand({
      id: "editor-indent-line",
      name: "Editor Indent Selection",
      icon: `right-arrow-with-tail`,
      editorCallback: (editor, view) => {
        const listSelections = editor.listSelections();
        listSelections.forEach((listSelection) => {
          const a = listSelection.head.line;
          const b = listSelection.anchor.line;
          const fromLineNum = b > a ? a : b;
          const toLineNum = b > a ? b : a;
          for (let i = fromLineNum; i <= toLineNum; i++) {
            const line = editor.getLine(i);
            editor.setLine(i, line.replace(/^/, "	"));
          }
        });
        let lss = [];
        listSelections.forEach((ls) => {
          const head = ls.head;
          head.ch = head.ch + 1;
          const anchor = ls.anchor;
          anchor.ch = anchor.ch + 1;
          const newLs = { anchor, head };
          lss.push(newLs);
        });
        editor.setSelections(lss);
      }
    });
    this.addCommand({
      id: "editor-outdent-line",
      name: "Editor Outdent Selection",
      icon: `left-arrow-with-tail`,
      editorCallback: (editor, view) => {
        const listSelections = editor.listSelections();
        listSelections.forEach((listSelection) => {
          const a = listSelection.head.line;
          const b = listSelection.anchor.line;
          const fromLineNum = b > a ? a : b;
          const toLineNum = b > a ? b : a;
          for (let i = fromLineNum; i <= toLineNum; i++) {
            const line = editor.getLine(i);
            editor.setLine(i, line.replace(/^\t/, ""));
          }
        });
        let lss = [];
        listSelections.forEach((ls) => {
          const head = ls.head;
          head.ch = head.ch + 1;
          const anchor = ls.anchor;
          anchor.ch = anchor.ch + 1;
          const newLs = { anchor, head };
          lss.push(newLs);
        });
        editor.setSelections(lss);
      }
    });
    this.addSettingTab(new SampleSettingTab(this.app, this));
  }
  convertChatGPTToTwitterFormat(editor) {
    let line = editor.lineCount();
    let numLineFirstContent = 0;
    let frontMatterLineCount = 0;
    for (let i = 0; i < line; i++) {
      if (frontMatterLineCount == 2) {
        numLineFirstContent = i;
        break;
      }
      if (editor.getLine(i) == "---") {
        frontMatterLineCount++;
      }
    }
    for (let i = 0; i < line; i++) {
      if (editor.getLine(numLineFirstContent).trim() == "") {
        numLineFirstContent++;
      } else {
        break;
      }
    }
    let totalTweetCount = 1;
    Array.from(Array(line - numLineFirstContent).keys()).forEach((i) => {
      const line2 = editor.getLine(i + numLineFirstContent);
      let modifiedLine = line2.replace(/^____+/, "---").replace(/^----+/, "---");
      editor.setLine(i + numLineFirstContent, modifiedLine);
      if (modifiedLine == "---") {
        totalTweetCount = totalTweetCount + 1;
      }
    });
    let numTweet = 1;
    let readyToAddTweetCount = true;
    let text = "";
    Array.from(Array(numLineFirstContent).keys()).forEach((i) => {
      const line2 = editor.getLine(i);
      text = text + line2 + "\n";
    });
    Array.from(Array(line - numLineFirstContent).keys()).forEach((i) => {
      const line2 = editor.getLine(i + numLineFirstContent);
      let modifiedLine = line2;
      if (line2 == "---") {
        readyToAddTweetCount = true;
        numTweet = numTweet + 1;
      } else if (line2 != "" && readyToAddTweetCount) {
        if (!/^\d+\/\d+.*/.test(line2)) {
          modifiedLine = `${numTweet}/${totalTweetCount} ${line2}`;
        }
        readyToAddTweetCount = false;
      }
      text = text + modifiedLine + "\n";
    });
    text = text.replace("\u258D", "");
    const tweets = text.split("---");
    for (let i = 0; i < tweets.length; i++) {
      const tweet = tweets[i].replace(/(https:|http:|www\.)\S*/gm, "").replace(/^\n+/m, "").replace(/\n+$/m, "");
      if (tweet.length > 140) {
        new import_obsidian23.Notice("```\n" + tweet + "\n```\n\nexceed 140 characters. Probably cannot post in twitter. Please refine the tweet. Aborting");
        return false;
      }
    }
    editor.setValue(text);
    const cursor = editor.getCursor();
    cursor.line = editor.lineCount() - 1;
    editor.setCursor(cursor);
    return true;
  }
  reverseTwitterNumbering(editor) {
    let line = editor.lineCount();
    let numLineFirstContent = 0;
    let frontMatterLineCount = 0;
    for (let i = 0; i < line; i++) {
      if (frontMatterLineCount == 2) {
        numLineFirstContent = i;
        break;
      }
      if (editor.getLine(i) == "---") {
        frontMatterLineCount++;
      }
    }
    for (let i = 0; i < line; i++) {
      if (editor.getLine(numLineFirstContent).trim() == "") {
        numLineFirstContent++;
      } else {
        break;
      }
    }
    let text = "";
    Array.from(Array(numLineFirstContent).keys()).forEach((i) => {
      const line2 = editor.getLine(i);
      text = text + line2 + "\n";
    });
    Array.from(Array(line - numLineFirstContent).keys()).forEach((i) => {
      const line2 = editor.getLine(i + numLineFirstContent);
      const modifiedLine = line2.replace(/^\d+\/\d+ /, "");
      text = text + modifiedLine + "\n";
    });
    editor.setValue(text);
    const cursor = editor.getCursor();
    cursor.line = editor.lineCount() - 1;
    editor.setCursor(cursor);
  }
  convertThreadsContentToFormatForThreadsApp(editor) {
    let result = this.convertThreadsContentToLightPostFormat(editor, "\u{1F9F5}", "\n\n\n");
    result = result.replace(/https\:\/\/github.com[^\n]+\n\n\n/m, "");
    return result;
  }
  convertThreadsContentToFormatForFacebookApp(editor) {
    return this.convertThreadsContentToLightPostFormat(editor, "", "\n\n\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\n\n", (a) => a.replace("\u{1F447}", ""));
  }
  convertThreadsContentToPOE(editor) {
    return this.convertThreadsContentToLightPostFormat(editor, "", "\n\n---\n\n", (a) => a.replace("\u{1F447}", ""));
  }
  /*
  	addTaskToPutIntoCardInThreadsContent(editor: Editor) {
  		let line = editor.lineCount();
  
  		let frontMatterLineCount = 0
  		let text = "";
  		for (let i = 0; i < line; i++) {
  			if (editor.getLine(i) == "---") {
  				frontMatterLineCount++
  			}
  			const line = editor.getLine(i);
  			
  			//if (frontMatterLineCount > 2 && line == "---") {
  			//	text = text + "%% #nm to zk %%\n\n"
  			//}
  			text = text + line + "\n"
  		}
  
  		editor.setValue(text);
  	}
  */
  convertThreadsContentToLightPostFormat(editor, headerIcon2, paragraphSeparator, additionReplaceFn = (a) => a) {
    let line = editor.lineCount();
    let numLineFirstContent = 0;
    let frontMatterLineCount = 0;
    for (let i = 0; i < line; i++) {
      if (frontMatterLineCount == 2) {
        numLineFirstContent = i;
        break;
      }
      if (editor.getLine(i) == "---") {
        frontMatterLineCount++;
      }
    }
    for (let i = 0; i < line; i++) {
      if (editor.getLine(numLineFirstContent).trim() == "") {
        numLineFirstContent++;
      } else {
        break;
      }
    }
    let text = "";
    let newConsecutiveLineCount = 0;
    Array.from(Array(line - numLineFirstContent).keys()).forEach((i) => {
      const line2 = editor.getLine(i + numLineFirstContent);
      if (!line2.trim().startsWith("%%") || !line2.trim().endsWith("%%")) {
        if (line2 == "---") {
          newConsecutiveLineCount = 0;
        }
        if (line2 == "") {
          newConsecutiveLineCount++;
        } else {
          newConsecutiveLineCount = 0;
        }
        if (line2 == "" && newConsecutiveLineCount > 1) {
        } else {
          let modifiedLine = line2 == "---" ? "" : line2;
          modifiedLine = modifiedLine.replace(/^		- /g, "\u3000\u3000\u3000\u3000\u2022 ").replace(/^	- /g, "\u3000\u3000\u2022 ").replace(/^- /, "\u2022 ");
          modifiedLine = modifiedLine.replace(/^\[([^\[\]\(\)]+)\]\([^\[\]\(\)]+\)/g, "$1").replace(/[^!]\[([^\[\]\(\)]+)\]\([^\[\]\(\)]+\)/g, "$1");
          modifiedLine = modifiedLine.replace(/!\[([^\[\]\(\)]+)\]\(([^\[\]\(\)]+)\)/g, "$2");
          modifiedLine = modifiedLine.replace(/\*\*/gm, "");
          text = text + modifiedLine + "\n";
        }
      }
    });
    text = text.replace(/🧵[ ]+(.*)/g, headerIcon2 + "\u3010$1\u3011");
    text = additionReplaceFn(text);
    text = text.replace(/[\n\r]{3,}/gm, `${paragraphSeparator}\u258D`);
    text = text.replace("\n\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\n\n\u258D\n", "");
    let text2 = "";
    text.split("\n").forEach((line2) => {
      var l = "";
      if (line2.endsWith("\u3002") || line2.endsWith("\uFF1A") || line2.endsWith("\uFF5E") || line2.endsWith("\uFF01") || line2.startsWith("\u258Dhttp") || line2.startsWith("\u258D#") || line2 == "\u258D") {
        l = line2.replace(/^▍/gm, "");
      } else {
        l = line2;
      }
      text2 = text2 + l + "\n";
    });
    text2 = text2.replace("\n\n\n\n", "");
    text2 = text2.replace("\n\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\n\n\n", "");
    text2 = text2.replace(/\n\n## Opinion from ChatGPT\:([\n]*.*)*$/, "");
    text2 = text2.replace(/## References\:([\n]*.*)*$/, "");
    text2 = text2.replace(/\n+$/, "");
    return text2;
  }
  getThreadSegment(editor) {
    let cursor = editor.getCursor();
    let line = cursor.line;
    let above = line;
    let below = line;
    while (above >= 0) {
      let l = editor.getLine(above);
      if (l == "---") {
        break;
      }
      above--;
    }
    if (editor.getLine(above) == "---") {
      above++;
    }
    while (true) {
      if (editor.getLine(above) == "") {
        above++;
      } else {
        break;
      }
    }
    while (below < editor.lineCount()) {
      let l = editor.getLine(below);
      if (l == "---") {
        break;
      }
      below++;
    }
    if (editor.getLine(below) == "---") {
      below--;
    }
    while (true) {
      if (editor.getLine(below) == "") {
        below--;
      } else {
        break;
      }
    }
    let text = "";
    Array.from(Array(below - above + 1).keys()).forEach((i) => {
      const line2 = editor.getLine(i + above);
      if (!line2.trim().startsWith("%%") || !line2.trim().endsWith("%%")) {
        let modifiedLine = editor.getLine(i + above);
        modifiedLine = modifiedLine.replace(/^\[([^\[\]\(\)]+)\]\([^\[\]\(\)]+\)/g, "$1").replace(/[^!]\[([^\[\]\(\)]+)\]\([^\[\]\(\)]+\)/g, "$1");
        text = text + modifiedLine + "\n";
      }
    });
    text = text.replace(/\n+$/, "");
    return text;
  }
  getSegment(editor) {
    let cursor = editor.getCursor();
    let line = cursor.line;
    let above = line;
    let below = line;
    while (above >= 0) {
      let l = editor.getLine(above);
      if (l == "---") {
        break;
      }
      above--;
    }
    if (editor.getLine(above) == "---") {
      above++;
    }
    while (true) {
      if (editor.getLine(above) == "") {
        above++;
      } else {
        break;
      }
    }
    while (below < editor.lineCount()) {
      let l = editor.getLine(below);
      if (l == "---") {
        break;
      }
      below++;
    }
    if (editor.getLine(below) == "---") {
      below--;
    }
    while (true) {
      if (editor.getLine(below) == "") {
        below--;
      } else {
        break;
      }
    }
    let text = "";
    Array.from(Array(below - above + 1).keys()).forEach((i) => {
      const line2 = editor.getLine(i + above);
      text = text + line2 + "\n";
    });
    text = text.replace(/\n+$/, "");
    return text;
  }
  getTwitterSegment(editor) {
    let cursor = editor.getCursor();
    let line = cursor.line;
    let above = line;
    let below = line;
    while (above >= 0) {
      let l = editor.getLine(above);
      if (l == "---") {
        break;
      }
      above--;
    }
    if (editor.getLine(above) == "---") {
      above++;
    }
    while (true) {
      if (editor.getLine(above) == "") {
        above++;
      } else {
        break;
      }
    }
    while (below < editor.lineCount()) {
      let l = editor.getLine(below);
      if (l == "---") {
        break;
      }
      below++;
    }
    if (editor.getLine(below) == "---") {
      below--;
    }
    while (true) {
      if (editor.getLine(below) == "") {
        below--;
      } else {
        break;
      }
    }
    let text = "";
    Array.from(Array(below - above + 1).keys()).forEach((i) => {
      const line2 = editor.getLine(i + above);
      if (!line2.trim().startsWith("%%") || !line2.trim().endsWith("%%")) {
        let modifiedLine = editor.getLine(i + above);
        if (!/\d+\/\d+ *【.*】/.test(modifiedLine)) {
          modifiedLine = modifiedLine.replace(/^\[([^\[\]\(\)]+)\]\([^\[\]\(\)]+\)/g, "$1").replace(/[^!]\[([^\[\]\(\)]+)\]\([^\[\]\(\)]+\)/g, "$1").replace(/https[^\n]+\.jpeg/g, "").replace(/？([^】」\n])/g, "\uFF1F\n\n$1").replace(/。([^】」\n])/g, "\u3002\n\n$1").replace(/！([^】」\n])/g, "\uFF01\n\n$1").replace(/～([^】」\n])/g, "\uFF5E\n\n$1").replace(/^\s+$/, "");
        }
        text = text + modifiedLine + "\n";
      }
    });
    text = text.replace(/\n+$/, "");
    return text;
  }
  getThreadsSegment(editor) {
    let cursor = editor.getCursor();
    let line = cursor.line;
    let above = line;
    let below = line;
    while (above >= 0) {
      let l = editor.getLine(above);
      if (l == "---") {
        break;
      }
      above--;
    }
    if (editor.getLine(above) == "---") {
      above++;
    }
    while (true) {
      if (editor.getLine(above) == "") {
        above++;
      } else {
        break;
      }
    }
    while (below < editor.lineCount()) {
      let l = editor.getLine(below);
      if (l == "---") {
        break;
      }
      below++;
    }
    if (editor.getLine(below) == "---") {
      below--;
    }
    while (true) {
      if (editor.getLine(below) == "") {
        below--;
      } else {
        break;
      }
    }
    let text = "";
    Array.from(Array(below - above + 1).keys()).forEach((i) => {
      const line2 = editor.getLine(i + above);
      if (!line2.trim().startsWith("%%") || !line2.trim().endsWith("%%")) {
        let modifiedLine = editor.getLine(i + above);
        if (!/\d+\/\d+ *【.*】/.test(modifiedLine)) {
          modifiedLine = modifiedLine.replace(/🧵[ ]+(.*)/g, headerIcon + "\u3010$1\u3011").replace(/^\[([^\[\]\(\)]+)\]\([^\[\]\(\)]+\)/g, "$1").replace(/[^!]\[([^\[\]\(\)]+)\]\([^\[\]\(\)]+\)/g, "$1").replace(/!\[.*\]\(https[^\n]+\.jpeg\)/g, "").replace(/https[^\n]+\.jpeg/g, "").replace(/？([^】」\n])/g, "\uFF1F\n\n$1").replace(/。([^】」\n])/g, "\u3002\n\n$1").replace(/！([^】」\n])/g, "\uFF01\n\n$1").replace(/～([^】」\n])/g, "\uFF5E\n\n$1").replace(/^\s+$/, "");
        }
        text = text + modifiedLine + "\n";
      }
    });
    text = text.replace(/\n+$/, "");
    return text;
  }
  async add3DaysActionNoteContent(vault) {
    const scheduleNoteWithoutMd = "D/Query Schedule and Actions next 3 days";
    const scheduleNote = `${scheduleNoteWithoutMd}.md`;
    if (vault.getAbstractFileByPath(scheduleNote) == null) {
      await vault.create(scheduleNote, "");
    }
    let noteContent = "[[Query Schedule and Actions next 3 days]]\n";
    const excludeNotes = [scheduleNoteWithoutMd, "D/Scheduling"];
    Array.from(Array(3).keys()).forEach((i) => noteContent += this.getQueryDateAndActionString(i, excludeNotes));
    const otherDays = this.getQueryActionsThisWeek(3);
    noteContent = noteContent + `## nn / wn
\`\`\`query
tag:#nn OR tag:#wn${otherDays}
\`\`\`

## tt
\`\`\`query
tag:#tt
\`\`\`

`;
    noteContent = noteContent + this.getQueryFutureDaysThisWeek("Future Dates", 3, 6, excludeNotes);
    noteContent = noteContent + this.getQueryNext2MonthString(excludeNotes);
    noteContent = noteContent + this.getQueryFutureDaysThisWeek("Past Dates", -7, -1, excludeNotes);
    vault.modify(vault.getAbstractFileByPath(scheduleNote), noteContent);
  }
  async addActionNoteContent(vault, folderName, noteTitleWithoutMd, scheduleNoteTitleWithoutMd, nOrW) {
    const nowActionNoteWithoutMd = `${folderName}/${noteTitleWithoutMd}`;
    const nowActionNote = `${nowActionNoteWithoutMd}.md`;
    if (vault.getAbstractFileByPath(nowActionNote) == null) {
      await vault.create(nowActionNote, "");
    }
    let nowActionNoteContent = "";
    Array.from(Array(2).keys()).forEach((i) => nowActionNoteContent += this.getQueryActionString(i, nOrW));
    nowActionNoteContent += `\`\`\`query
tag:#${nOrW}t
\`\`\`
`;
    nowActionNoteContent += `\`\`\`query
`;
    Array.from(Array(5).keys()).forEach((i) => nowActionNoteContent += this.getQueryWeekDay(i + 2, nOrW));
    nowActionNoteContent += `tag:#${nOrW}n
\`\`\`
`;
    nowActionNoteContent += `Scheduling: [[${scheduleNoteTitleWithoutMd}]]
`;
    nowActionNoteContent += `[[${noteTitleWithoutMd}]]
`;
    vault.modify(vault.getAbstractFileByPath(nowActionNote), nowActionNoteContent);
  }
  getQueryDateAndActionString(addDay, excludeNotes) {
    const dateMoment = (0, import_moment.default)().add(addDay, "d");
    const dateYYYYMMDD = dateMoment.format("YYYYMMDD");
    const dateEachYYDD = "\\d\\d\\d\\d" + dateMoment.format("MMDD");
    const dateEachDD = "\\d\\d\\d\\d\\d\\d" + dateMoment.format("DD");
    const dayOfWeek = dateMoment.format("E");
    const dayOfWeekLong = dateMoment.format("ddd");
    const excludeNoteStr = excludeNotes.map((excludeNote) => `-path:"${excludeNote}" `).join("");
    return `## ${dateYYYYMMDD} ${dayOfWeekLong}
\`\`\`query
(" ${dateYYYYMMDD}" OR "${dateYYYYMMDD} " OR ${dateEachYYDD} OR ${dateEachDD} OR tag:#n${dayOfWeek} OR tag:#w${dayOfWeek}) ${excludeNoteStr}-block:(query)
\`\`\`

`;
  }
  getQueryActionsThisWeek(excludeNumDays) {
    let excludes = [];
    let includes = [1, 2, 3, 4, 5, 6, 7];
    Array.from(Array(excludeNumDays).keys()).forEach((i) => {
      const dateMoment = (0, import_moment.default)().add(i, "d");
      const dayOfWeek = parseInt(dateMoment.format("E"));
      excludes.push(dayOfWeek);
    });
    let aaa = includes.filter((i) => {
      for (const e of excludes) {
        if (e == i) {
          return false;
        }
      }
      return true;
    });
    let output = "";
    aaa.forEach((i) => output += ` OR tag:#n${i} OR tag:#w${i}`);
    return output;
  }
  getQueryFutureDaysThisWeek(header, from, to, excludeNotes) {
    let includes = [];
    for (let i = from; i <= to; i++) {
      let dateMoment = (0, import_moment.default)().add(i, "d");
      includes.push(dateMoment);
    }
    let output = `## ${header}
\`\`\`query
(`;
    includes.forEach((i) => {
      const dateYYYYMMDD = i.format("YYYYMMDD");
      const dateEachYYDD = "\\d\\d\\d\\d" + i.format("MMDD");
      const dateEachDD = "\\d\\d\\d\\d\\d\\d" + i.format("DD");
      output += `" ${dateYYYYMMDD}" OR "${dateYYYYMMDD} " OR ${dateEachYYDD} OR ${dateEachDD} OR `;
    });
    output = output.replace(/ OR $/, "");
    output += ")";
    const excludeNoteStr = excludeNotes.map((excludeNote) => `-path:"${excludeNote}" `).join("");
    output += ` ${excludeNoteStr}-block:(query)`;
    output += `
\`\`\`

`;
    return output;
  }
  getQueryNext2MonthString(excludeNotes) {
    const currentMonthYYYYMM = (0, import_moment.default)().format("YYYYMM");
    const dateMoment = (0, import_moment.default)().add(1, "M");
    const nextMonthYYYYMM = dateMoment.format("YYYYMM");
    const excludeNoteStr = excludeNotes.map((excludeNote) => `-path:"${excludeNote}" `).join("");
    return `## ${currentMonthYYYYMM} and ${nextMonthYYYYMM}
\`\`\`query
(${currentMonthYYYYMM}\\d\\d OR ${nextMonthYYYYMM}\\d\\d ${excludeNoteStr}-path:"D/Scheduling" -block:(query)
\`\`\`

`;
  }
  getQueryDateString(addDay, excludeNote) {
    const dateMoment = (0, import_moment.default)().add(addDay, "d");
    const dateYYYYMMDD = dateMoment.format("YYYYMMDD");
    const dateEachYYDD = "\\d\\d\\d\\d" + dateMoment.format("MMDD");
    const dateEachDD = "\\d\\d\\d\\d\\d\\d" + dateMoment.format("DD");
    return `${dateYYYYMMDD}
\`\`\`query
(${dateYYYYMMDD} OR ${dateEachYYDD} OR ${dateEachDD}) -path:"${excludeNote}" -block:(query)
\`\`\`
`;
  }
  getQueryActionString(addDay, actionType) {
    const dateMoment = (0, import_moment.default)().add(addDay, "d");
    const dayOfWeek = dateMoment.format("E");
    return `\`\`\`query
tag:#${actionType}${dayOfWeek}
\`\`\`
`;
  }
  getQueryWeekDay(addDay, actionType) {
    const dateMoment = (0, import_moment.default)().add(addDay, "d");
    const dayOfWeek = dateMoment.format("E");
    return `tag:#${actionType}${dayOfWeek} OR `;
  }
  addNewLaterActionIcon(t) {
    this.addObsidianIcon(`${t}l-icon-new`, `${t}l`);
  }
  addActionIcon(t) {
    this.addObsidianIcon(`${t}-icon`, `#${t}`);
  }
  addObsidianIcon(iconName, iconText) {
    const svg = `<text stroke='#000' transform='matrix(2.79167 0 0 2.12663 -34.0417 -25.2084)' xml:space='preserve' text-anchor='start' font-family='monospace' font-size='24' y='44' x='19' stroke-width='0' fill='currentColor'>${iconText}</text>`;
    (0, import_obsidian24.addIcon)(iconName, svg);
  }
  addNewLaterAction(t) {
    this.addCommand({
      id: `add-new-${t}-later-action`,
      name: `Add ${t}l task`,
      icon: `${t}l-icon-new`,
      editorCallback: (editor, view) => {
        const cursor = editor.getCursor();
        editor.replaceRange(`#${t}l `, cursor);
        cursor.ch = cursor.ch + 4;
        editor.setCursor(cursor);
      }
      /*,
      hotkeys: [
      	{
      		modifiers: [`Ctrl`, `Meta`, `Shift`],
      		key: t == 'n' ? '1' : '2'
      	},
      	{
      		modifiers: [`Ctrl`, `Alt`, `Shift`],
      		key: t == 'n' ? '1' : '2'
      	}
      ]*/
    });
  }
  addActionCommand(t) {
    this.addCommand({
      id: `to-w${t}-n${t}`,
      name: `To w${t} or n${t}`,
      icon: `${t}-icon`,
      editorCallback: (editor, view) => {
        console.log(editor.getSelection());
        const cursor = editor.getCursor();
        const lineNumber = editor.getCursor().line;
        const line = editor.getLine(lineNumber);
        const replacedLine = line.replace(/ a\/w\/./, ` a/w/${t}`).replace(/ a\/n\/./, ` a/n/${t}`).replace(/#w. /, `#w${t} `).replace(/#n. /, `#n${t} `).replace(/#w.$/, `#w${t}`).replace(/#n.$/, `#n${t}`);
        if (line.contains(`#n${t} `) || line.contains(`#w${t} `)) {
          const nt = `#n${t} `;
          const wt = `#w${t} `;
          const replaceLineToRemoveTag = line.replace(`#n${t} `, ``).replace(`#w${t} `, ``);
          editor.setLine(lineNumber, replaceLineToRemoveTag);
          const ntIndex = line.indexOf(nt);
          const wtIndex = line.indexOf(wt);
          const index = ntIndex == -1 ? wtIndex : ntIndex;
          const newCh = cursor.ch <= index ? cursor.ch : cursor.ch >= index + 4 ? cursor.ch - 4 : index;
          cursor.ch = newCh;
          editor.setCursor(cursor);
        } else if (line.contains(` #n${t}`) || line.contains(` #w${t}`)) {
          const nt = `#n${t} `;
          const wt = `#w${t} `;
          const replaceLineToRemoveTag = line.replace(` #n${t}`, ``).replace(` #w${t}`, ``);
          editor.setLine(lineNumber, replaceLineToRemoveTag);
          const ntIndex = line.indexOf(nt);
          const wtIndex = line.indexOf(wt);
          const index = ntIndex == -1 ? wtIndex : ntIndex;
          const newCh = cursor.ch <= index ? cursor.ch : cursor.ch >= index + 4 ? cursor.ch - 4 : index;
          cursor.ch = newCh;
          editor.setCursor(cursor);
        } else if (line.contains(` a/n/${t}`) || line.contains(` a/w/${t}`)) {
        } else if (replacedLine == line) {
          new AddTaskTagModal(this.app, editor, t).open();
        } else {
          editor.setLine(lineNumber, replacedLine);
          editor.setCursor(cursor);
        }
      },
      hotkeys: [
        {
          modifiers: this.is1To7(t) ? [`Ctrl`, `Meta`] : [`Ctrl`, `Meta`, `Shift`],
          key: `${t}`
        },
        {
          modifiers: this.is1To7(t) ? [`Ctrl`, `Alt`] : [`Ctrl`, `Alt`, `Shift`],
          key: `${t}`
        }
      ]
    });
  }
  addFollowUpCommand(t) {
    let name = "";
    if (t === "t") {
      name = "To Try";
    } else if (t === "e") {
      name = "To Explore";
    } else if (t === "m") {
      name = "To Move";
    }
    this.addCommand({
      id: `to-t${t}`,
      name: `To t${t} ${name}`,
      icon: `${t}-icon`,
      editorCallback: (editor, view) => {
        console.log(editor.getSelection());
        const cursor = editor.getCursor();
        const lineNumber = editor.getCursor().line;
        const line = editor.getLine(lineNumber);
        const replacedLine = line.replace(/#t. /, `#t${t} `).replace(/#t.$/, `#t${t}`);
        if (line.contains(`#t${t} `)) {
          const tt = `#t${t} `;
          const replaceLineToRemoveTag = line.replace(`#t${t} `, ``);
          editor.setLine(lineNumber, replaceLineToRemoveTag);
          const ttIndex = line.indexOf(tt);
          const index = ttIndex;
          const newCh = cursor.ch <= index ? cursor.ch : cursor.ch >= index + 4 ? cursor.ch - 4 : index;
          cursor.ch = newCh;
          editor.setCursor(cursor);
        } else if (line.contains(` #t${t}`)) {
          const tt = `#t${t} `;
          const replaceLineToRemoveTag = line.replace(` #t${t}`, ``);
          editor.setLine(lineNumber, replaceLineToRemoveTag);
          const ttIndex = line.indexOf(tt);
          const index = ttIndex;
          const newCh = cursor.ch <= index ? cursor.ch : cursor.ch >= index + 4 ? cursor.ch - 4 : index;
          cursor.ch = newCh;
          editor.setCursor(cursor);
        } else if (replacedLine == line) {
          const cursor2 = editor.getCursor();
          const line2 = editor.getLine(cursor2.line);
          editor.replaceRange(`${line2.charAt(cursor2.ch - 1) != " " ? " " : ""}#t${t} `, cursor2);
          cursor2.ch = cursor2.ch + 4 + (line2.charAt(cursor2.ch - 1) != " " ? 1 : 0);
          editor.setCursor(cursor2);
        } else {
          editor.setLine(lineNumber, replacedLine);
          editor.setCursor(cursor);
        }
      },
      hotkeys: [
        {
          modifiers: [`Ctrl`, `Meta`, `Shift`],
          key: `${t}`
        },
        {
          modifiers: [`Ctrl`, `Alt`, `Shift`],
          key: `${t}`
        }
      ]
    });
  }
  is1To7(t) {
    if (t == "1" || t == "2" || t == "3" || t == "4" || t == "5" || t == "6" || t == "7") {
      return true;
    } else {
      return false;
    }
  }
  addToClipboardHistory(content) {
    const index = clipboardHistory.indexOf(content, 0);
    if (index > -1) {
      clipboardHistory.splice(index, 1);
    }
    if (content.length > 0) {
      clipboardHistory.push(content);
    }
  }
  onunload() {
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
var SampleSettingTab = class extends import_obsidian23.PluginSettingTab {
  constructor(app2, plugin) {
    super(app2, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Settings for my awesome plugin." });
    new import_obsidian23.Setting(containerEl).setName("Setting #1").setDesc("It's a secret").addText((text) => text.setPlaceholder("Enter your secret").setValue(this.plugin.settings.mySetting).onChange(async (value) => {
      console.log("Secret: " + value);
      this.plugin.settings.mySetting = value;
      await this.plugin.saveSettings();
    }));
  }
};
/*! Bundled license information:

moment/moment.js:
  (*! moment.js *)
  (*! version : 2.29.1 *)
  (*! authors : Tim Wood, Iskren Chernev, Moment.js contributors *)
  (*! license : MIT *)
  (*! momentjs.com *)
*/
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsibm9kZV9tb2R1bGVzL21vbWVudC9tb21lbnQuanMiLCAibWFpbi50cyIsICJ1cGRhdGVOb3RlVHlwZU1vZGFsLnRzIiwgInRhZ3JlbmFtZXIvcmVuYW1pbmcudHMiLCAidGFncmVuYW1lci9UYWcudHMiLCAidGFncmVuYW1lci9GaWxlLnRzIiwgIm5vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9ub2Rlcy9Ob2RlLmpzIiwgIm5vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC92aXNpdC5qcyIsICJub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3QvZG9jL2RpcmVjdGl2ZXMuanMiLCAibm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L2RvYy9hbmNob3JzLmpzIiwgIm5vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9ub2Rlcy9BbGlhcy5qcyIsICJub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3Qvbm9kZXMvdG9KUy5qcyIsICJub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3Qvbm9kZXMvU2NhbGFyLmpzIiwgIm5vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9kb2MvY3JlYXRlTm9kZS5qcyIsICJub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3Qvbm9kZXMvQ29sbGVjdGlvbi5qcyIsICJub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3Qvc3RyaW5naWZ5L3N0cmluZ2lmeUNvbW1lbnQuanMiLCAibm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L3N0cmluZ2lmeS9mb2xkRmxvd0xpbmVzLmpzIiwgIm5vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9zdHJpbmdpZnkvc3RyaW5naWZ5U3RyaW5nLmpzIiwgIm5vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9zdHJpbmdpZnkvc3RyaW5naWZ5LmpzIiwgIm5vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9zdHJpbmdpZnkvc3RyaW5naWZ5UGFpci5qcyIsICJub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3QvbG9nLmpzIiwgIm5vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9ub2Rlcy9hZGRQYWlyVG9KU01hcC5qcyIsICJub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3Qvbm9kZXMvUGFpci5qcyIsICJub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3Qvb3B0aW9ucy5qcyIsICJub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3Qvc3RyaW5naWZ5L3N0cmluZ2lmeUNvbGxlY3Rpb24uanMiLCAibm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L25vZGVzL1lBTUxNYXAuanMiLCAibm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L3NjaGVtYS9jb21tb24vbWFwLmpzIiwgIm5vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9ub2Rlcy9ZQU1MU2VxLmpzIiwgIm5vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9zY2hlbWEvY29tbW9uL3NlcS5qcyIsICJub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3Qvc2NoZW1hL2NvbW1vbi9zdHJpbmcuanMiLCAibm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L3NjaGVtYS9jb21tb24vbnVsbC5qcyIsICJub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3Qvc2NoZW1hL2NvcmUvYm9vbC5qcyIsICJub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3Qvc3RyaW5naWZ5L3N0cmluZ2lmeU51bWJlci5qcyIsICJub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3Qvc2NoZW1hL2NvcmUvZmxvYXQuanMiLCAibm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L3NjaGVtYS9jb3JlL2ludC5qcyIsICJub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3Qvc2NoZW1hL2NvcmUvc2NoZW1hLmpzIiwgIm5vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9zY2hlbWEvanNvbi9zY2hlbWEuanMiLCAibm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L3NjaGVtYS95YW1sLTEuMS9iaW5hcnkuanMiLCAibm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L3NjaGVtYS95YW1sLTEuMS9wYWlycy5qcyIsICJub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3Qvc2NoZW1hL3lhbWwtMS4xL29tYXAuanMiLCAibm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L3NjaGVtYS95YW1sLTEuMS9ib29sLmpzIiwgIm5vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9zY2hlbWEveWFtbC0xLjEvZmxvYXQuanMiLCAibm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L3NjaGVtYS95YW1sLTEuMS9pbnQuanMiLCAibm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L3NjaGVtYS95YW1sLTEuMS9zZXQuanMiLCAibm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L3NjaGVtYS95YW1sLTEuMS90aW1lc3RhbXAuanMiLCAibm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L3NjaGVtYS95YW1sLTEuMS9zY2hlbWEuanMiLCAibm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L3NjaGVtYS90YWdzLmpzIiwgIm5vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9zY2hlbWEvU2NoZW1hLmpzIiwgIm5vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9zdHJpbmdpZnkvc3RyaW5naWZ5RG9jdW1lbnQuanMiLCAibm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L2RvYy9hcHBseVJldml2ZXIuanMiLCAibm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L2RvYy9Eb2N1bWVudC5qcyIsICJub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3QvZXJyb3JzLmpzIiwgIm5vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9jb21wb3NlL3Jlc29sdmUtcHJvcHMuanMiLCAibm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L2NvbXBvc2UvdXRpbC1jb250YWlucy1uZXdsaW5lLmpzIiwgIm5vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9jb21wb3NlL3V0aWwtZmxvdy1pbmRlbnQtY2hlY2suanMiLCAibm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L2NvbXBvc2UvdXRpbC1tYXAtaW5jbHVkZXMuanMiLCAibm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L2NvbXBvc2UvcmVzb2x2ZS1ibG9jay1tYXAuanMiLCAibm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L2NvbXBvc2UvcmVzb2x2ZS1ibG9jay1zZXEuanMiLCAibm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L2NvbXBvc2UvcmVzb2x2ZS1lbmQuanMiLCAibm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L2NvbXBvc2UvcmVzb2x2ZS1mbG93LWNvbGxlY3Rpb24uanMiLCAibm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L2NvbXBvc2UvY29tcG9zZS1jb2xsZWN0aW9uLmpzIiwgIm5vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9jb21wb3NlL3Jlc29sdmUtYmxvY2stc2NhbGFyLmpzIiwgIm5vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9jb21wb3NlL3Jlc29sdmUtZmxvdy1zY2FsYXIuanMiLCAibm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L2NvbXBvc2UvY29tcG9zZS1zY2FsYXIuanMiLCAibm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L2NvbXBvc2UvdXRpbC1lbXB0eS1zY2FsYXItcG9zaXRpb24uanMiLCAibm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L2NvbXBvc2UvY29tcG9zZS1ub2RlLmpzIiwgIm5vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9jb21wb3NlL2NvbXBvc2UtZG9jLmpzIiwgIm5vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9jb21wb3NlL2NvbXBvc2VyLmpzIiwgIm5vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9wYXJzZS9jc3QuanMiLCAibm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L3BhcnNlL2NzdC1zY2FsYXIuanMiLCAibm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L3BhcnNlL2NzdC1zdHJpbmdpZnkuanMiLCAibm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L3BhcnNlL2NzdC12aXNpdC5qcyIsICJub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3QvcGFyc2UvbGV4ZXIuanMiLCAibm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L3BhcnNlL2xpbmUtY291bnRlci5qcyIsICJub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3QvcGFyc2UvcGFyc2VyLmpzIiwgIm5vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9wdWJsaWMtYXBpLmpzIiwgImFkZENvbW1lbnRUYWdNb2RhbC50cyIsICJhZGRUYXNrVGFnTW9kYWwudHMiLCAiVGhyZWFkc1RvSW1hZ2VzTW9kYWwudHMiLCAiY29weU9yTW92ZVRvTmV3Tm90ZU1vZGFsLnRzIiwgImNsaXBib2FyZFBhc3RlTW9kYWwudHMiLCAib3BlblBsYXlncm91bmRNb2RhbC50cyIsICJ0aHJlYWRzVG9CbG9nTW9kYWwudHMiLCAiY2xpcGJvYXJkUmVtb3ZhbE1vZGFsLnRzIiwgInRhZ1NlYXJjaE1vZGFsLnRzIiwgInNlbGZ1dGlsL2dldEFsbE5vdGVUYWdzLnRzIiwgImFkZFRleHRUb05vdGVzRnJvbVNwZWNpZmljVGFnTW9kYWwudHMiLCAic2VsZnV0aWwvYWRkbGlua3Rvbm90ZXMudHMiLCAic2VsZnV0aWwvZmluZE5vdGVzRnJvbVRhZy50cyIsICJhZGRUZXh0VG9Ob3Rlc01vZGFsLnRzIiwgInNlbGZ1dGlsL2dldFJlY2VudE5vdGVzLnRzIiwgIm5hdmlnYXRlVG9Ob3RlRnJvbVNwZWNpZmljVGFnTW9kYWwudHMiLCAibmF2aWdhdGVUb05vdGVGcm9tVGFnTW9kYWwudHMiLCAic2VsZnV0aWwvZXh0cmFjdFNlbGVjdGlvbi50cyIsICJ0d21pZ3JhdGlvbi90d01pZ3JhdGVUb29scy50cyIsICJzZWxmdXRpbC9yZW1vdmVDb250ZW50RnJvbUN1cnNvci50cyIsICJyZW1vdmVDb250ZW50RnJvbUN1cnNvck1vZGFsLnRzIiwgImZpbmRSZXBsYWNlTW9kYWwudHMiLCAicXVlcnlPcnBoYW5Ob3Rlc0J5VGFnTW9kYWwudHMiXSwKICAic291cmNlc0NvbnRlbnQiOiBbIi8vISBtb21lbnQuanNcbi8vISB2ZXJzaW9uIDogMi4yOS4xXG4vLyEgYXV0aG9ycyA6IFRpbSBXb29kLCBJc2tyZW4gQ2hlcm5ldiwgTW9tZW50LmpzIGNvbnRyaWJ1dG9yc1xuLy8hIGxpY2Vuc2UgOiBNSVRcbi8vISBtb21lbnRqcy5jb21cblxuOyhmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCkgOlxuICAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShmYWN0b3J5KSA6XG4gICAgZ2xvYmFsLm1vbWVudCA9IGZhY3RvcnkoKVxufSh0aGlzLCAoZnVuY3Rpb24gKCkgeyAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgaG9va0NhbGxiYWNrO1xuXG4gICAgZnVuY3Rpb24gaG9va3MoKSB7XG4gICAgICAgIHJldHVybiBob29rQ2FsbGJhY2suYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICAvLyBUaGlzIGlzIGRvbmUgdG8gcmVnaXN0ZXIgdGhlIG1ldGhvZCBjYWxsZWQgd2l0aCBtb21lbnQoKVxuICAgIC8vIHdpdGhvdXQgY3JlYXRpbmcgY2lyY3VsYXIgZGVwZW5kZW5jaWVzLlxuICAgIGZ1bmN0aW9uIHNldEhvb2tDYWxsYmFjayhjYWxsYmFjaykge1xuICAgICAgICBob29rQ2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0FycmF5KGlucHV0KSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBpbnB1dCBpbnN0YW5jZW9mIEFycmF5IHx8XG4gICAgICAgICAgICBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaW5wdXQpID09PSAnW29iamVjdCBBcnJheV0nXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNPYmplY3QoaW5wdXQpIHtcbiAgICAgICAgLy8gSUU4IHdpbGwgdHJlYXQgdW5kZWZpbmVkIGFuZCBudWxsIGFzIG9iamVjdCBpZiBpdCB3YXNuJ3QgZm9yXG4gICAgICAgIC8vIGlucHV0ICE9IG51bGxcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIGlucHV0ICE9IG51bGwgJiZcbiAgICAgICAgICAgIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpbnB1dCkgPT09ICdbb2JqZWN0IE9iamVjdF0nXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFzT3duUHJvcChhLCBiKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYSwgYik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNPYmplY3RFbXB0eShvYmopIHtcbiAgICAgICAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKSB7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMob2JqKS5sZW5ndGggPT09IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgaztcbiAgICAgICAgICAgIGZvciAoayBpbiBvYmopIHtcbiAgICAgICAgICAgICAgICBpZiAoaGFzT3duUHJvcChvYmosIGspKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzVW5kZWZpbmVkKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBpbnB1dCA9PT0gdm9pZCAwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzTnVtYmVyKGlucHV0KSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICB0eXBlb2YgaW5wdXQgPT09ICdudW1iZXInIHx8XG4gICAgICAgICAgICBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaW5wdXQpID09PSAnW29iamVjdCBOdW1iZXJdJ1xuICAgICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzRGF0ZShpbnB1dCkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgaW5wdXQgaW5zdGFuY2VvZiBEYXRlIHx8XG4gICAgICAgICAgICBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaW5wdXQpID09PSAnW29iamVjdCBEYXRlXSdcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYXAoYXJyLCBmbikge1xuICAgICAgICB2YXIgcmVzID0gW10sXG4gICAgICAgICAgICBpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICByZXMucHVzaChmbihhcnJbaV0sIGkpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGV4dGVuZChhLCBiKSB7XG4gICAgICAgIGZvciAodmFyIGkgaW4gYikge1xuICAgICAgICAgICAgaWYgKGhhc093blByb3AoYiwgaSkpIHtcbiAgICAgICAgICAgICAgICBhW2ldID0gYltpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoYXNPd25Qcm9wKGIsICd0b1N0cmluZycpKSB7XG4gICAgICAgICAgICBhLnRvU3RyaW5nID0gYi50b1N0cmluZztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoYXNPd25Qcm9wKGIsICd2YWx1ZU9mJykpIHtcbiAgICAgICAgICAgIGEudmFsdWVPZiA9IGIudmFsdWVPZjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZVVUQyhpbnB1dCwgZm9ybWF0LCBsb2NhbGUsIHN0cmljdCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlTG9jYWxPclVUQyhpbnB1dCwgZm9ybWF0LCBsb2NhbGUsIHN0cmljdCwgdHJ1ZSkudXRjKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGVmYXVsdFBhcnNpbmdGbGFncygpIHtcbiAgICAgICAgLy8gV2UgbmVlZCB0byBkZWVwIGNsb25lIHRoaXMgb2JqZWN0LlxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZW1wdHk6IGZhbHNlLFxuICAgICAgICAgICAgdW51c2VkVG9rZW5zOiBbXSxcbiAgICAgICAgICAgIHVudXNlZElucHV0OiBbXSxcbiAgICAgICAgICAgIG92ZXJmbG93OiAtMixcbiAgICAgICAgICAgIGNoYXJzTGVmdE92ZXI6IDAsXG4gICAgICAgICAgICBudWxsSW5wdXQ6IGZhbHNlLFxuICAgICAgICAgICAgaW52YWxpZEVyYTogbnVsbCxcbiAgICAgICAgICAgIGludmFsaWRNb250aDogbnVsbCxcbiAgICAgICAgICAgIGludmFsaWRGb3JtYXQ6IGZhbHNlLFxuICAgICAgICAgICAgdXNlckludmFsaWRhdGVkOiBmYWxzZSxcbiAgICAgICAgICAgIGlzbzogZmFsc2UsXG4gICAgICAgICAgICBwYXJzZWREYXRlUGFydHM6IFtdLFxuICAgICAgICAgICAgZXJhOiBudWxsLFxuICAgICAgICAgICAgbWVyaWRpZW06IG51bGwsXG4gICAgICAgICAgICByZmMyODIyOiBmYWxzZSxcbiAgICAgICAgICAgIHdlZWtkYXlNaXNtYXRjaDogZmFsc2UsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0UGFyc2luZ0ZsYWdzKG0pIHtcbiAgICAgICAgaWYgKG0uX3BmID09IG51bGwpIHtcbiAgICAgICAgICAgIG0uX3BmID0gZGVmYXVsdFBhcnNpbmdGbGFncygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtLl9wZjtcbiAgICB9XG5cbiAgICB2YXIgc29tZTtcbiAgICBpZiAoQXJyYXkucHJvdG90eXBlLnNvbWUpIHtcbiAgICAgICAgc29tZSA9IEFycmF5LnByb3RvdHlwZS5zb21lO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHNvbWUgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgICAgICAgICB2YXIgdCA9IE9iamVjdCh0aGlzKSxcbiAgICAgICAgICAgICAgICBsZW4gPSB0Lmxlbmd0aCA+Pj4gMCxcbiAgICAgICAgICAgICAgICBpO1xuXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoaSBpbiB0ICYmIGZ1bi5jYWxsKHRoaXMsIHRbaV0sIGksIHQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzVmFsaWQobSkge1xuICAgICAgICBpZiAobS5faXNWYWxpZCA9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgZmxhZ3MgPSBnZXRQYXJzaW5nRmxhZ3MobSksXG4gICAgICAgICAgICAgICAgcGFyc2VkUGFydHMgPSBzb21lLmNhbGwoZmxhZ3MucGFyc2VkRGF0ZVBhcnRzLCBmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaSAhPSBudWxsO1xuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIGlzTm93VmFsaWQgPVxuICAgICAgICAgICAgICAgICAgICAhaXNOYU4obS5fZC5nZXRUaW1lKCkpICYmXG4gICAgICAgICAgICAgICAgICAgIGZsYWdzLm92ZXJmbG93IDwgMCAmJlxuICAgICAgICAgICAgICAgICAgICAhZmxhZ3MuZW1wdHkgJiZcbiAgICAgICAgICAgICAgICAgICAgIWZsYWdzLmludmFsaWRFcmEgJiZcbiAgICAgICAgICAgICAgICAgICAgIWZsYWdzLmludmFsaWRNb250aCAmJlxuICAgICAgICAgICAgICAgICAgICAhZmxhZ3MuaW52YWxpZFdlZWtkYXkgJiZcbiAgICAgICAgICAgICAgICAgICAgIWZsYWdzLndlZWtkYXlNaXNtYXRjaCAmJlxuICAgICAgICAgICAgICAgICAgICAhZmxhZ3MubnVsbElucHV0ICYmXG4gICAgICAgICAgICAgICAgICAgICFmbGFncy5pbnZhbGlkRm9ybWF0ICYmXG4gICAgICAgICAgICAgICAgICAgICFmbGFncy51c2VySW52YWxpZGF0ZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgKCFmbGFncy5tZXJpZGllbSB8fCAoZmxhZ3MubWVyaWRpZW0gJiYgcGFyc2VkUGFydHMpKTtcblxuICAgICAgICAgICAgaWYgKG0uX3N0cmljdCkge1xuICAgICAgICAgICAgICAgIGlzTm93VmFsaWQgPVxuICAgICAgICAgICAgICAgICAgICBpc05vd1ZhbGlkICYmXG4gICAgICAgICAgICAgICAgICAgIGZsYWdzLmNoYXJzTGVmdE92ZXIgPT09IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgZmxhZ3MudW51c2VkVG9rZW5zLmxlbmd0aCA9PT0gMCAmJlxuICAgICAgICAgICAgICAgICAgICBmbGFncy5iaWdIb3VyID09PSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChPYmplY3QuaXNGcm96ZW4gPT0gbnVsbCB8fCAhT2JqZWN0LmlzRnJvemVuKG0pKSB7XG4gICAgICAgICAgICAgICAgbS5faXNWYWxpZCA9IGlzTm93VmFsaWQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBpc05vd1ZhbGlkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtLl9pc1ZhbGlkO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUludmFsaWQoZmxhZ3MpIHtcbiAgICAgICAgdmFyIG0gPSBjcmVhdGVVVEMoTmFOKTtcbiAgICAgICAgaWYgKGZsYWdzICE9IG51bGwpIHtcbiAgICAgICAgICAgIGV4dGVuZChnZXRQYXJzaW5nRmxhZ3MobSksIGZsYWdzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhtKS51c2VySW52YWxpZGF0ZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG07XG4gICAgfVxuXG4gICAgLy8gUGx1Z2lucyB0aGF0IGFkZCBwcm9wZXJ0aWVzIHNob3VsZCBhbHNvIGFkZCB0aGUga2V5IGhlcmUgKG51bGwgdmFsdWUpLFxuICAgIC8vIHNvIHdlIGNhbiBwcm9wZXJseSBjbG9uZSBvdXJzZWx2ZXMuXG4gICAgdmFyIG1vbWVudFByb3BlcnRpZXMgPSAoaG9va3MubW9tZW50UHJvcGVydGllcyA9IFtdKSxcbiAgICAgICAgdXBkYXRlSW5Qcm9ncmVzcyA9IGZhbHNlO1xuXG4gICAgZnVuY3Rpb24gY29weUNvbmZpZyh0bywgZnJvbSkge1xuICAgICAgICB2YXIgaSwgcHJvcCwgdmFsO1xuXG4gICAgICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5faXNBTW9tZW50T2JqZWN0KSkge1xuICAgICAgICAgICAgdG8uX2lzQU1vbWVudE9iamVjdCA9IGZyb20uX2lzQU1vbWVudE9iamVjdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX2kpKSB7XG4gICAgICAgICAgICB0by5faSA9IGZyb20uX2k7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9mKSkge1xuICAgICAgICAgICAgdG8uX2YgPSBmcm9tLl9mO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5fbCkpIHtcbiAgICAgICAgICAgIHRvLl9sID0gZnJvbS5fbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX3N0cmljdCkpIHtcbiAgICAgICAgICAgIHRvLl9zdHJpY3QgPSBmcm9tLl9zdHJpY3Q7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl90em0pKSB7XG4gICAgICAgICAgICB0by5fdHptID0gZnJvbS5fdHptO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5faXNVVEMpKSB7XG4gICAgICAgICAgICB0by5faXNVVEMgPSBmcm9tLl9pc1VUQztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX29mZnNldCkpIHtcbiAgICAgICAgICAgIHRvLl9vZmZzZXQgPSBmcm9tLl9vZmZzZXQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9wZikpIHtcbiAgICAgICAgICAgIHRvLl9wZiA9IGdldFBhcnNpbmdGbGFncyhmcm9tKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX2xvY2FsZSkpIHtcbiAgICAgICAgICAgIHRvLl9sb2NhbGUgPSBmcm9tLl9sb2NhbGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobW9tZW50UHJvcGVydGllcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbW9tZW50UHJvcGVydGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHByb3AgPSBtb21lbnRQcm9wZXJ0aWVzW2ldO1xuICAgICAgICAgICAgICAgIHZhbCA9IGZyb21bcHJvcF07XG4gICAgICAgICAgICAgICAgaWYgKCFpc1VuZGVmaW5lZCh2YWwpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvW3Byb3BdID0gdmFsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0bztcbiAgICB9XG5cbiAgICAvLyBNb21lbnQgcHJvdG90eXBlIG9iamVjdFxuICAgIGZ1bmN0aW9uIE1vbWVudChjb25maWcpIHtcbiAgICAgICAgY29weUNvbmZpZyh0aGlzLCBjb25maWcpO1xuICAgICAgICB0aGlzLl9kID0gbmV3IERhdGUoY29uZmlnLl9kICE9IG51bGwgPyBjb25maWcuX2QuZ2V0VGltZSgpIDogTmFOKTtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgdGhpcy5fZCA9IG5ldyBEYXRlKE5hTik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUHJldmVudCBpbmZpbml0ZSBsb29wIGluIGNhc2UgdXBkYXRlT2Zmc2V0IGNyZWF0ZXMgbmV3IG1vbWVudFxuICAgICAgICAvLyBvYmplY3RzLlxuICAgICAgICBpZiAodXBkYXRlSW5Qcm9ncmVzcyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHVwZGF0ZUluUHJvZ3Jlc3MgPSB0cnVlO1xuICAgICAgICAgICAgaG9va3MudXBkYXRlT2Zmc2V0KHRoaXMpO1xuICAgICAgICAgICAgdXBkYXRlSW5Qcm9ncmVzcyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNNb21lbnQob2JqKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBvYmogaW5zdGFuY2VvZiBNb21lbnQgfHwgKG9iaiAhPSBudWxsICYmIG9iai5faXNBTW9tZW50T2JqZWN0ICE9IG51bGwpXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gd2Fybihtc2cpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgaG9va3Muc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmdzID09PSBmYWxzZSAmJlxuICAgICAgICAgICAgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICBjb25zb2xlLndhcm5cbiAgICAgICAgKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ0RlcHJlY2F0aW9uIHdhcm5pbmc6ICcgKyBtc2cpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGVwcmVjYXRlKG1zZywgZm4pIHtcbiAgICAgICAgdmFyIGZpcnN0VGltZSA9IHRydWU7XG5cbiAgICAgICAgcmV0dXJuIGV4dGVuZChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoaG9va3MuZGVwcmVjYXRpb25IYW5kbGVyICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBob29rcy5kZXByZWNhdGlvbkhhbmRsZXIobnVsbCwgbXNnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmaXJzdFRpbWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXJncyA9IFtdLFxuICAgICAgICAgICAgICAgICAgICBhcmcsXG4gICAgICAgICAgICAgICAgICAgIGksXG4gICAgICAgICAgICAgICAgICAgIGtleTtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGFyZyA9ICcnO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGFyZ3VtZW50c1tpXSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZyArPSAnXFxuWycgKyBpICsgJ10gJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoa2V5IGluIGFyZ3VtZW50c1swXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wKGFyZ3VtZW50c1swXSwga2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmcgKz0ga2V5ICsgJzogJyArIGFyZ3VtZW50c1swXVtrZXldICsgJywgJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmcgPSBhcmcuc2xpY2UoMCwgLTIpOyAvLyBSZW1vdmUgdHJhaWxpbmcgY29tbWEgYW5kIHNwYWNlXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmcgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYXJncy5wdXNoKGFyZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAgICAgICAgIG1zZyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnXFxuQXJndW1lbnRzOiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3MpLmpvaW4oJycpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdcXG4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBFcnJvcigpLnN0YWNrXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBmaXJzdFRpbWUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9LCBmbik7XG4gICAgfVxuXG4gICAgdmFyIGRlcHJlY2F0aW9ucyA9IHt9O1xuXG4gICAgZnVuY3Rpb24gZGVwcmVjYXRlU2ltcGxlKG5hbWUsIG1zZykge1xuICAgICAgICBpZiAoaG9va3MuZGVwcmVjYXRpb25IYW5kbGVyICE9IG51bGwpIHtcbiAgICAgICAgICAgIGhvb2tzLmRlcHJlY2F0aW9uSGFuZGxlcihuYW1lLCBtc2cpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZGVwcmVjYXRpb25zW25hbWVdKSB7XG4gICAgICAgICAgICB3YXJuKG1zZyk7XG4gICAgICAgICAgICBkZXByZWNhdGlvbnNbbmFtZV0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaG9va3Muc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmdzID0gZmFsc2U7XG4gICAgaG9va3MuZGVwcmVjYXRpb25IYW5kbGVyID0gbnVsbDtcblxuICAgIGZ1bmN0aW9uIGlzRnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICh0eXBlb2YgRnVuY3Rpb24gIT09ICd1bmRlZmluZWQnICYmIGlucHV0IGluc3RhbmNlb2YgRnVuY3Rpb24pIHx8XG4gICAgICAgICAgICBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaW5wdXQpID09PSAnW29iamVjdCBGdW5jdGlvbl0nXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0KGNvbmZpZykge1xuICAgICAgICB2YXIgcHJvcCwgaTtcbiAgICAgICAgZm9yIChpIGluIGNvbmZpZykge1xuICAgICAgICAgICAgaWYgKGhhc093blByb3AoY29uZmlnLCBpKSkge1xuICAgICAgICAgICAgICAgIHByb3AgPSBjb25maWdbaV07XG4gICAgICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24ocHJvcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpc1tpXSA9IHByb3A7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpc1snXycgKyBpXSA9IHByb3A7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NvbmZpZyA9IGNvbmZpZztcbiAgICAgICAgLy8gTGVuaWVudCBvcmRpbmFsIHBhcnNpbmcgYWNjZXB0cyBqdXN0IGEgbnVtYmVyIGluIGFkZGl0aW9uIHRvXG4gICAgICAgIC8vIG51bWJlciArIChwb3NzaWJseSkgc3R1ZmYgY29taW5nIGZyb20gX2RheU9mTW9udGhPcmRpbmFsUGFyc2UuXG4gICAgICAgIC8vIFRPRE86IFJlbW92ZSBcIm9yZGluYWxQYXJzZVwiIGZhbGxiYWNrIGluIG5leHQgbWFqb3IgcmVsZWFzZS5cbiAgICAgICAgdGhpcy5fZGF5T2ZNb250aE9yZGluYWxQYXJzZUxlbmllbnQgPSBuZXcgUmVnRXhwKFxuICAgICAgICAgICAgKHRoaXMuX2RheU9mTW9udGhPcmRpbmFsUGFyc2Uuc291cmNlIHx8IHRoaXMuX29yZGluYWxQYXJzZS5zb3VyY2UpICtcbiAgICAgICAgICAgICAgICAnfCcgK1xuICAgICAgICAgICAgICAgIC9cXGR7MSwyfS8uc291cmNlXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWVyZ2VDb25maWdzKHBhcmVudENvbmZpZywgY2hpbGRDb25maWcpIHtcbiAgICAgICAgdmFyIHJlcyA9IGV4dGVuZCh7fSwgcGFyZW50Q29uZmlnKSxcbiAgICAgICAgICAgIHByb3A7XG4gICAgICAgIGZvciAocHJvcCBpbiBjaGlsZENvbmZpZykge1xuICAgICAgICAgICAgaWYgKGhhc093blByb3AoY2hpbGRDb25maWcsIHByb3ApKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzT2JqZWN0KHBhcmVudENvbmZpZ1twcm9wXSkgJiYgaXNPYmplY3QoY2hpbGRDb25maWdbcHJvcF0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc1twcm9wXSA9IHt9O1xuICAgICAgICAgICAgICAgICAgICBleHRlbmQocmVzW3Byb3BdLCBwYXJlbnRDb25maWdbcHJvcF0pO1xuICAgICAgICAgICAgICAgICAgICBleHRlbmQocmVzW3Byb3BdLCBjaGlsZENvbmZpZ1twcm9wXSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjaGlsZENvbmZpZ1twcm9wXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc1twcm9wXSA9IGNoaWxkQ29uZmlnW3Byb3BdO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSByZXNbcHJvcF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAocHJvcCBpbiBwYXJlbnRDb25maWcpIHtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBoYXNPd25Qcm9wKHBhcmVudENvbmZpZywgcHJvcCkgJiZcbiAgICAgICAgICAgICAgICAhaGFzT3duUHJvcChjaGlsZENvbmZpZywgcHJvcCkgJiZcbiAgICAgICAgICAgICAgICBpc09iamVjdChwYXJlbnRDb25maWdbcHJvcF0pXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAvLyBtYWtlIHN1cmUgY2hhbmdlcyB0byBwcm9wZXJ0aWVzIGRvbid0IG1vZGlmeSBwYXJlbnQgY29uZmlnXG4gICAgICAgICAgICAgICAgcmVzW3Byb3BdID0gZXh0ZW5kKHt9LCByZXNbcHJvcF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gTG9jYWxlKGNvbmZpZykge1xuICAgICAgICBpZiAoY29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0KGNvbmZpZyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIga2V5cztcblxuICAgIGlmIChPYmplY3Qua2V5cykge1xuICAgICAgICBrZXlzID0gT2JqZWN0LmtleXM7XG4gICAgfSBlbHNlIHtcbiAgICAgICAga2V5cyA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgIHZhciBpLFxuICAgICAgICAgICAgICAgIHJlcyA9IFtdO1xuICAgICAgICAgICAgZm9yIChpIGluIG9iaikge1xuICAgICAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wKG9iaiwgaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzLnB1c2goaSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdENhbGVuZGFyID0ge1xuICAgICAgICBzYW1lRGF5OiAnW1RvZGF5IGF0XSBMVCcsXG4gICAgICAgIG5leHREYXk6ICdbVG9tb3Jyb3cgYXRdIExUJyxcbiAgICAgICAgbmV4dFdlZWs6ICdkZGRkIFthdF0gTFQnLFxuICAgICAgICBsYXN0RGF5OiAnW1llc3RlcmRheSBhdF0gTFQnLFxuICAgICAgICBsYXN0V2VlazogJ1tMYXN0XSBkZGRkIFthdF0gTFQnLFxuICAgICAgICBzYW1lRWxzZTogJ0wnLFxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBjYWxlbmRhcihrZXksIG1vbSwgbm93KSB7XG4gICAgICAgIHZhciBvdXRwdXQgPSB0aGlzLl9jYWxlbmRhcltrZXldIHx8IHRoaXMuX2NhbGVuZGFyWydzYW1lRWxzZSddO1xuICAgICAgICByZXR1cm4gaXNGdW5jdGlvbihvdXRwdXQpID8gb3V0cHV0LmNhbGwobW9tLCBub3cpIDogb3V0cHV0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHplcm9GaWxsKG51bWJlciwgdGFyZ2V0TGVuZ3RoLCBmb3JjZVNpZ24pIHtcbiAgICAgICAgdmFyIGFic051bWJlciA9ICcnICsgTWF0aC5hYnMobnVtYmVyKSxcbiAgICAgICAgICAgIHplcm9zVG9GaWxsID0gdGFyZ2V0TGVuZ3RoIC0gYWJzTnVtYmVyLmxlbmd0aCxcbiAgICAgICAgICAgIHNpZ24gPSBudW1iZXIgPj0gMDtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIChzaWduID8gKGZvcmNlU2lnbiA/ICcrJyA6ICcnKSA6ICctJykgK1xuICAgICAgICAgICAgTWF0aC5wb3coMTAsIE1hdGgubWF4KDAsIHplcm9zVG9GaWxsKSkudG9TdHJpbmcoKS5zdWJzdHIoMSkgK1xuICAgICAgICAgICAgYWJzTnVtYmVyXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgdmFyIGZvcm1hdHRpbmdUb2tlbnMgPSAvKFxcW1teXFxbXSpcXF0pfChcXFxcKT8oW0hoXW1tKHNzKT98TW98TU0/TT9NP3xEb3xERERvfEREP0Q/RD98ZGRkP2Q/fGRvP3x3W298d10/fFdbb3xXXT98UW8/fE57MSw1fXxZWVlZWVl8WVlZWVl8WVlZWXxZWXx5ezIsNH18eW8/fGdnKGdnZz8pP3xHRyhHR0c/KT98ZXxFfGF8QXxoaD98SEg/fGtrP3xtbT98c3M/fFN7MSw5fXx4fFh8eno/fFpaP3wuKS9nLFxuICAgICAgICBsb2NhbEZvcm1hdHRpbmdUb2tlbnMgPSAvKFxcW1teXFxbXSpcXF0pfChcXFxcKT8oTFRTfExUfExMP0w/TD98bHsxLDR9KS9nLFxuICAgICAgICBmb3JtYXRGdW5jdGlvbnMgPSB7fSxcbiAgICAgICAgZm9ybWF0VG9rZW5GdW5jdGlvbnMgPSB7fTtcblxuICAgIC8vIHRva2VuOiAgICAnTSdcbiAgICAvLyBwYWRkZWQ6ICAgWydNTScsIDJdXG4gICAgLy8gb3JkaW5hbDogICdNbydcbiAgICAvLyBjYWxsYmFjazogZnVuY3Rpb24gKCkgeyB0aGlzLm1vbnRoKCkgKyAxIH1cbiAgICBmdW5jdGlvbiBhZGRGb3JtYXRUb2tlbih0b2tlbiwgcGFkZGVkLCBvcmRpbmFsLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgZnVuYyA9IGNhbGxiYWNrO1xuICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgZnVuYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1tjYWxsYmFja10oKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRva2VuKSB7XG4gICAgICAgICAgICBmb3JtYXRUb2tlbkZ1bmN0aW9uc1t0b2tlbl0gPSBmdW5jO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYWRkZWQpIHtcbiAgICAgICAgICAgIGZvcm1hdFRva2VuRnVuY3Rpb25zW3BhZGRlZFswXV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHplcm9GaWxsKGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKSwgcGFkZGVkWzFdLCBwYWRkZWRbMl0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3JkaW5hbCkge1xuICAgICAgICAgICAgZm9ybWF0VG9rZW5GdW5jdGlvbnNbb3JkaW5hbF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLm9yZGluYWwoXG4gICAgICAgICAgICAgICAgICAgIGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKSxcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlbW92ZUZvcm1hdHRpbmdUb2tlbnMoaW5wdXQpIHtcbiAgICAgICAgaWYgKGlucHV0Lm1hdGNoKC9cXFtbXFxzXFxTXS8pKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQucmVwbGFjZSgvXlxcW3xcXF0kL2csICcnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5wdXQucmVwbGFjZSgvXFxcXC9nLCAnJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFrZUZvcm1hdEZ1bmN0aW9uKGZvcm1hdCkge1xuICAgICAgICB2YXIgYXJyYXkgPSBmb3JtYXQubWF0Y2goZm9ybWF0dGluZ1Rva2VucyksXG4gICAgICAgICAgICBpLFxuICAgICAgICAgICAgbGVuZ3RoO1xuXG4gICAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoZm9ybWF0VG9rZW5GdW5jdGlvbnNbYXJyYXlbaV1dKSB7XG4gICAgICAgICAgICAgICAgYXJyYXlbaV0gPSBmb3JtYXRUb2tlbkZ1bmN0aW9uc1thcnJheVtpXV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFycmF5W2ldID0gcmVtb3ZlRm9ybWF0dGluZ1Rva2VucyhhcnJheVtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG1vbSkge1xuICAgICAgICAgICAgdmFyIG91dHB1dCA9ICcnLFxuICAgICAgICAgICAgICAgIGk7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQgKz0gaXNGdW5jdGlvbihhcnJheVtpXSlcbiAgICAgICAgICAgICAgICAgICAgPyBhcnJheVtpXS5jYWxsKG1vbSwgZm9ybWF0KVxuICAgICAgICAgICAgICAgICAgICA6IGFycmF5W2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBmb3JtYXQgZGF0ZSB1c2luZyBuYXRpdmUgZGF0ZSBvYmplY3RcbiAgICBmdW5jdGlvbiBmb3JtYXRNb21lbnQobSwgZm9ybWF0KSB7XG4gICAgICAgIGlmICghbS5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBtLmxvY2FsZURhdGEoKS5pbnZhbGlkRGF0ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9ybWF0ID0gZXhwYW5kRm9ybWF0KGZvcm1hdCwgbS5sb2NhbGVEYXRhKCkpO1xuICAgICAgICBmb3JtYXRGdW5jdGlvbnNbZm9ybWF0XSA9XG4gICAgICAgICAgICBmb3JtYXRGdW5jdGlvbnNbZm9ybWF0XSB8fCBtYWtlRm9ybWF0RnVuY3Rpb24oZm9ybWF0KTtcblxuICAgICAgICByZXR1cm4gZm9ybWF0RnVuY3Rpb25zW2Zvcm1hdF0obSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXhwYW5kRm9ybWF0KGZvcm1hdCwgbG9jYWxlKSB7XG4gICAgICAgIHZhciBpID0gNTtcblxuICAgICAgICBmdW5jdGlvbiByZXBsYWNlTG9uZ0RhdGVGb3JtYXRUb2tlbnMoaW5wdXQpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbGUubG9uZ0RhdGVGb3JtYXQoaW5wdXQpIHx8IGlucHV0O1xuICAgICAgICB9XG5cbiAgICAgICAgbG9jYWxGb3JtYXR0aW5nVG9rZW5zLmxhc3RJbmRleCA9IDA7XG4gICAgICAgIHdoaWxlIChpID49IDAgJiYgbG9jYWxGb3JtYXR0aW5nVG9rZW5zLnRlc3QoZm9ybWF0KSkge1xuICAgICAgICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UoXG4gICAgICAgICAgICAgICAgbG9jYWxGb3JtYXR0aW5nVG9rZW5zLFxuICAgICAgICAgICAgICAgIHJlcGxhY2VMb25nRGF0ZUZvcm1hdFRva2Vuc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGxvY2FsRm9ybWF0dGluZ1Rva2Vucy5sYXN0SW5kZXggPSAwO1xuICAgICAgICAgICAgaSAtPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZvcm1hdDtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdExvbmdEYXRlRm9ybWF0ID0ge1xuICAgICAgICBMVFM6ICdoOm1tOnNzIEEnLFxuICAgICAgICBMVDogJ2g6bW0gQScsXG4gICAgICAgIEw6ICdNTS9ERC9ZWVlZJyxcbiAgICAgICAgTEw6ICdNTU1NIEQsIFlZWVknLFxuICAgICAgICBMTEw6ICdNTU1NIEQsIFlZWVkgaDptbSBBJyxcbiAgICAgICAgTExMTDogJ2RkZGQsIE1NTU0gRCwgWVlZWSBoOm1tIEEnLFxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBsb25nRGF0ZUZvcm1hdChrZXkpIHtcbiAgICAgICAgdmFyIGZvcm1hdCA9IHRoaXMuX2xvbmdEYXRlRm9ybWF0W2tleV0sXG4gICAgICAgICAgICBmb3JtYXRVcHBlciA9IHRoaXMuX2xvbmdEYXRlRm9ybWF0W2tleS50b1VwcGVyQ2FzZSgpXTtcblxuICAgICAgICBpZiAoZm9ybWF0IHx8ICFmb3JtYXRVcHBlcikge1xuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2xvbmdEYXRlRm9ybWF0W2tleV0gPSBmb3JtYXRVcHBlclxuICAgICAgICAgICAgLm1hdGNoKGZvcm1hdHRpbmdUb2tlbnMpXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uICh0b2spIHtcbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgIHRvayA9PT0gJ01NTU0nIHx8XG4gICAgICAgICAgICAgICAgICAgIHRvayA9PT0gJ01NJyB8fFxuICAgICAgICAgICAgICAgICAgICB0b2sgPT09ICdERCcgfHxcbiAgICAgICAgICAgICAgICAgICAgdG9rID09PSAnZGRkZCdcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRvay5zbGljZSgxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRvaztcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuam9pbignJyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvbmdEYXRlRm9ybWF0W2tleV07XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRJbnZhbGlkRGF0ZSA9ICdJbnZhbGlkIGRhdGUnO1xuXG4gICAgZnVuY3Rpb24gaW52YWxpZERhdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnZhbGlkRGF0ZTtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdE9yZGluYWwgPSAnJWQnLFxuICAgICAgICBkZWZhdWx0RGF5T2ZNb250aE9yZGluYWxQYXJzZSA9IC9cXGR7MSwyfS87XG5cbiAgICBmdW5jdGlvbiBvcmRpbmFsKG51bWJlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5fb3JkaW5hbC5yZXBsYWNlKCclZCcsIG51bWJlcik7XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRSZWxhdGl2ZVRpbWUgPSB7XG4gICAgICAgIGZ1dHVyZTogJ2luICVzJyxcbiAgICAgICAgcGFzdDogJyVzIGFnbycsXG4gICAgICAgIHM6ICdhIGZldyBzZWNvbmRzJyxcbiAgICAgICAgc3M6ICclZCBzZWNvbmRzJyxcbiAgICAgICAgbTogJ2EgbWludXRlJyxcbiAgICAgICAgbW06ICclZCBtaW51dGVzJyxcbiAgICAgICAgaDogJ2FuIGhvdXInLFxuICAgICAgICBoaDogJyVkIGhvdXJzJyxcbiAgICAgICAgZDogJ2EgZGF5JyxcbiAgICAgICAgZGQ6ICclZCBkYXlzJyxcbiAgICAgICAgdzogJ2Egd2VlaycsXG4gICAgICAgIHd3OiAnJWQgd2Vla3MnLFxuICAgICAgICBNOiAnYSBtb250aCcsXG4gICAgICAgIE1NOiAnJWQgbW9udGhzJyxcbiAgICAgICAgeTogJ2EgeWVhcicsXG4gICAgICAgIHl5OiAnJWQgeWVhcnMnLFxuICAgIH07XG5cbiAgICBmdW5jdGlvbiByZWxhdGl2ZVRpbWUobnVtYmVyLCB3aXRob3V0U3VmZml4LCBzdHJpbmcsIGlzRnV0dXJlKSB7XG4gICAgICAgIHZhciBvdXRwdXQgPSB0aGlzLl9yZWxhdGl2ZVRpbWVbc3RyaW5nXTtcbiAgICAgICAgcmV0dXJuIGlzRnVuY3Rpb24ob3V0cHV0KVxuICAgICAgICAgICAgPyBvdXRwdXQobnVtYmVyLCB3aXRob3V0U3VmZml4LCBzdHJpbmcsIGlzRnV0dXJlKVxuICAgICAgICAgICAgOiBvdXRwdXQucmVwbGFjZSgvJWQvaSwgbnVtYmVyKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXN0RnV0dXJlKGRpZmYsIG91dHB1dCkge1xuICAgICAgICB2YXIgZm9ybWF0ID0gdGhpcy5fcmVsYXRpdmVUaW1lW2RpZmYgPiAwID8gJ2Z1dHVyZScgOiAncGFzdCddO1xuICAgICAgICByZXR1cm4gaXNGdW5jdGlvbihmb3JtYXQpID8gZm9ybWF0KG91dHB1dCkgOiBmb3JtYXQucmVwbGFjZSgvJXMvaSwgb3V0cHV0KTtcbiAgICB9XG5cbiAgICB2YXIgYWxpYXNlcyA9IHt9O1xuXG4gICAgZnVuY3Rpb24gYWRkVW5pdEFsaWFzKHVuaXQsIHNob3J0aGFuZCkge1xuICAgICAgICB2YXIgbG93ZXJDYXNlID0gdW5pdC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBhbGlhc2VzW2xvd2VyQ2FzZV0gPSBhbGlhc2VzW2xvd2VyQ2FzZSArICdzJ10gPSBhbGlhc2VzW3Nob3J0aGFuZF0gPSB1bml0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZVVuaXRzKHVuaXRzKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdW5pdHMgPT09ICdzdHJpbmcnXG4gICAgICAgICAgICA/IGFsaWFzZXNbdW5pdHNdIHx8IGFsaWFzZXNbdW5pdHMudG9Mb3dlckNhc2UoKV1cbiAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZU9iamVjdFVuaXRzKGlucHV0T2JqZWN0KSB7XG4gICAgICAgIHZhciBub3JtYWxpemVkSW5wdXQgPSB7fSxcbiAgICAgICAgICAgIG5vcm1hbGl6ZWRQcm9wLFxuICAgICAgICAgICAgcHJvcDtcblxuICAgICAgICBmb3IgKHByb3AgaW4gaW5wdXRPYmplY3QpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wKGlucHV0T2JqZWN0LCBwcm9wKSkge1xuICAgICAgICAgICAgICAgIG5vcm1hbGl6ZWRQcm9wID0gbm9ybWFsaXplVW5pdHMocHJvcCk7XG4gICAgICAgICAgICAgICAgaWYgKG5vcm1hbGl6ZWRQcm9wKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vcm1hbGl6ZWRJbnB1dFtub3JtYWxpemVkUHJvcF0gPSBpbnB1dE9iamVjdFtwcm9wXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbm9ybWFsaXplZElucHV0O1xuICAgIH1cblxuICAgIHZhciBwcmlvcml0aWVzID0ge307XG5cbiAgICBmdW5jdGlvbiBhZGRVbml0UHJpb3JpdHkodW5pdCwgcHJpb3JpdHkpIHtcbiAgICAgICAgcHJpb3JpdGllc1t1bml0XSA9IHByaW9yaXR5O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFByaW9yaXRpemVkVW5pdHModW5pdHNPYmopIHtcbiAgICAgICAgdmFyIHVuaXRzID0gW10sXG4gICAgICAgICAgICB1O1xuICAgICAgICBmb3IgKHUgaW4gdW5pdHNPYmopIHtcbiAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wKHVuaXRzT2JqLCB1KSkge1xuICAgICAgICAgICAgICAgIHVuaXRzLnB1c2goeyB1bml0OiB1LCBwcmlvcml0eTogcHJpb3JpdGllc1t1XSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB1bml0cy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gYS5wcmlvcml0eSAtIGIucHJpb3JpdHk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdW5pdHM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNMZWFwWWVhcih5ZWFyKSB7XG4gICAgICAgIHJldHVybiAoeWVhciAlIDQgPT09IDAgJiYgeWVhciAlIDEwMCAhPT0gMCkgfHwgeWVhciAlIDQwMCA9PT0gMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhYnNGbG9vcihudW1iZXIpIHtcbiAgICAgICAgaWYgKG51bWJlciA8IDApIHtcbiAgICAgICAgICAgIC8vIC0wIC0+IDBcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmNlaWwobnVtYmVyKSB8fCAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IobnVtYmVyKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvSW50KGFyZ3VtZW50Rm9yQ29lcmNpb24pIHtcbiAgICAgICAgdmFyIGNvZXJjZWROdW1iZXIgPSArYXJndW1lbnRGb3JDb2VyY2lvbixcbiAgICAgICAgICAgIHZhbHVlID0gMDtcblxuICAgICAgICBpZiAoY29lcmNlZE51bWJlciAhPT0gMCAmJiBpc0Zpbml0ZShjb2VyY2VkTnVtYmVyKSkge1xuICAgICAgICAgICAgdmFsdWUgPSBhYnNGbG9vcihjb2VyY2VkTnVtYmVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYWtlR2V0U2V0KHVuaXQsIGtlZXBUaW1lKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgc2V0JDEodGhpcywgdW5pdCwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIGhvb2tzLnVwZGF0ZU9mZnNldCh0aGlzLCBrZWVwVGltZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZXQodGhpcywgdW5pdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0KG1vbSwgdW5pdCkge1xuICAgICAgICByZXR1cm4gbW9tLmlzVmFsaWQoKVxuICAgICAgICAgICAgPyBtb20uX2RbJ2dldCcgKyAobW9tLl9pc1VUQyA/ICdVVEMnIDogJycpICsgdW5pdF0oKVxuICAgICAgICAgICAgOiBOYU47XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0JDEobW9tLCB1bml0LCB2YWx1ZSkge1xuICAgICAgICBpZiAobW9tLmlzVmFsaWQoKSAmJiAhaXNOYU4odmFsdWUpKSB7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgdW5pdCA9PT0gJ0Z1bGxZZWFyJyAmJlxuICAgICAgICAgICAgICAgIGlzTGVhcFllYXIobW9tLnllYXIoKSkgJiZcbiAgICAgICAgICAgICAgICBtb20ubW9udGgoKSA9PT0gMSAmJlxuICAgICAgICAgICAgICAgIG1vbS5kYXRlKCkgPT09IDI5XG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHRvSW50KHZhbHVlKTtcbiAgICAgICAgICAgICAgICBtb20uX2RbJ3NldCcgKyAobW9tLl9pc1VUQyA/ICdVVEMnIDogJycpICsgdW5pdF0oXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBtb20ubW9udGgoKSxcbiAgICAgICAgICAgICAgICAgICAgZGF5c0luTW9udGgodmFsdWUsIG1vbS5tb250aCgpKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG1vbS5fZFsnc2V0JyArIChtb20uX2lzVVRDID8gJ1VUQycgOiAnJykgKyB1bml0XSh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICBmdW5jdGlvbiBzdHJpbmdHZXQodW5pdHMpIHtcbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKHRoaXNbdW5pdHNdKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXNbdW5pdHNdKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc3RyaW5nU2V0KHVuaXRzLCB2YWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mIHVuaXRzID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgdW5pdHMgPSBub3JtYWxpemVPYmplY3RVbml0cyh1bml0cyk7XG4gICAgICAgICAgICB2YXIgcHJpb3JpdGl6ZWQgPSBnZXRQcmlvcml0aXplZFVuaXRzKHVuaXRzKSxcbiAgICAgICAgICAgICAgICBpO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHByaW9yaXRpemVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpc1twcmlvcml0aXplZFtpXS51bml0XSh1bml0c1twcmlvcml0aXplZFtpXS51bml0XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcbiAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKHRoaXNbdW5pdHNdKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzW3VuaXRzXSh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdmFyIG1hdGNoMSA9IC9cXGQvLCAvLyAgICAgICAwIC0gOVxuICAgICAgICBtYXRjaDIgPSAvXFxkXFxkLywgLy8gICAgICAwMCAtIDk5XG4gICAgICAgIG1hdGNoMyA9IC9cXGR7M30vLCAvLyAgICAgMDAwIC0gOTk5XG4gICAgICAgIG1hdGNoNCA9IC9cXGR7NH0vLCAvLyAgICAwMDAwIC0gOTk5OVxuICAgICAgICBtYXRjaDYgPSAvWystXT9cXGR7Nn0vLCAvLyAtOTk5OTk5IC0gOTk5OTk5XG4gICAgICAgIG1hdGNoMXRvMiA9IC9cXGRcXGQ/LywgLy8gICAgICAgMCAtIDk5XG4gICAgICAgIG1hdGNoM3RvNCA9IC9cXGRcXGRcXGRcXGQ/LywgLy8gICAgIDk5OSAtIDk5OTlcbiAgICAgICAgbWF0Y2g1dG82ID0gL1xcZFxcZFxcZFxcZFxcZFxcZD8vLCAvLyAgIDk5OTk5IC0gOTk5OTk5XG4gICAgICAgIG1hdGNoMXRvMyA9IC9cXGR7MSwzfS8sIC8vICAgICAgIDAgLSA5OTlcbiAgICAgICAgbWF0Y2gxdG80ID0gL1xcZHsxLDR9LywgLy8gICAgICAgMCAtIDk5OTlcbiAgICAgICAgbWF0Y2gxdG82ID0gL1srLV0/XFxkezEsNn0vLCAvLyAtOTk5OTk5IC0gOTk5OTk5XG4gICAgICAgIG1hdGNoVW5zaWduZWQgPSAvXFxkKy8sIC8vICAgICAgIDAgLSBpbmZcbiAgICAgICAgbWF0Y2hTaWduZWQgPSAvWystXT9cXGQrLywgLy8gICAgLWluZiAtIGluZlxuICAgICAgICBtYXRjaE9mZnNldCA9IC9afFsrLV1cXGRcXGQ6P1xcZFxcZC9naSwgLy8gKzAwOjAwIC0wMDowMCArMDAwMCAtMDAwMCBvciBaXG4gICAgICAgIG1hdGNoU2hvcnRPZmZzZXQgPSAvWnxbKy1dXFxkXFxkKD86Oj9cXGRcXGQpPy9naSwgLy8gKzAwIC0wMCArMDA6MDAgLTAwOjAwICswMDAwIC0wMDAwIG9yIFpcbiAgICAgICAgbWF0Y2hUaW1lc3RhbXAgPSAvWystXT9cXGQrKFxcLlxcZHsxLDN9KT8vLCAvLyAxMjM0NTY3ODkgMTIzNDU2Nzg5LjEyM1xuICAgICAgICAvLyBhbnkgd29yZCAob3IgdHdvKSBjaGFyYWN0ZXJzIG9yIG51bWJlcnMgaW5jbHVkaW5nIHR3by90aHJlZSB3b3JkIG1vbnRoIGluIGFyYWJpYy5cbiAgICAgICAgLy8gaW5jbHVkZXMgc2NvdHRpc2ggZ2FlbGljIHR3byB3b3JkIGFuZCBoeXBoZW5hdGVkIG1vbnRoc1xuICAgICAgICBtYXRjaFdvcmQgPSAvWzAtOV17MCwyNTZ9WydhLXpcXHUwMEEwLVxcdTA1RkZcXHUwNzAwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGMDdcXHVGRjEwLVxcdUZGRUZdezEsMjU2fXxbXFx1MDYwMC1cXHUwNkZGXFwvXXsxLDI1Nn0oXFxzKj9bXFx1MDYwMC1cXHUwNkZGXXsxLDI1Nn0pezEsMn0vaSxcbiAgICAgICAgcmVnZXhlcztcblxuICAgIHJlZ2V4ZXMgPSB7fTtcblxuICAgIGZ1bmN0aW9uIGFkZFJlZ2V4VG9rZW4odG9rZW4sIHJlZ2V4LCBzdHJpY3RSZWdleCkge1xuICAgICAgICByZWdleGVzW3Rva2VuXSA9IGlzRnVuY3Rpb24ocmVnZXgpXG4gICAgICAgICAgICA/IHJlZ2V4XG4gICAgICAgICAgICA6IGZ1bmN0aW9uIChpc1N0cmljdCwgbG9jYWxlRGF0YSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGlzU3RyaWN0ICYmIHN0cmljdFJlZ2V4ID8gc3RyaWN0UmVnZXggOiByZWdleDtcbiAgICAgICAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRQYXJzZVJlZ2V4Rm9yVG9rZW4odG9rZW4sIGNvbmZpZykge1xuICAgICAgICBpZiAoIWhhc093blByb3AocmVnZXhlcywgdG9rZW4pKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cCh1bmVzY2FwZUZvcm1hdCh0b2tlbikpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlZ2V4ZXNbdG9rZW5dKGNvbmZpZy5fc3RyaWN0LCBjb25maWcuX2xvY2FsZSk7XG4gICAgfVxuXG4gICAgLy8gQ29kZSBmcm9tIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMzU2MTQ5My9pcy10aGVyZS1hLXJlZ2V4cC1lc2NhcGUtZnVuY3Rpb24taW4tamF2YXNjcmlwdFxuICAgIGZ1bmN0aW9uIHVuZXNjYXBlRm9ybWF0KHMpIHtcbiAgICAgICAgcmV0dXJuIHJlZ2V4RXNjYXBlKFxuICAgICAgICAgICAgc1xuICAgICAgICAgICAgICAgIC5yZXBsYWNlKCdcXFxcJywgJycpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFwoXFxbKXxcXFxcKFxcXSl8XFxbKFteXFxdXFxbXSopXFxdfFxcXFwoLikvZywgZnVuY3Rpb24gKFxuICAgICAgICAgICAgICAgICAgICBtYXRjaGVkLFxuICAgICAgICAgICAgICAgICAgICBwMSxcbiAgICAgICAgICAgICAgICAgICAgcDIsXG4gICAgICAgICAgICAgICAgICAgIHAzLFxuICAgICAgICAgICAgICAgICAgICBwNFxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcDEgfHwgcDIgfHwgcDMgfHwgcDQ7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZWdleEVzY2FwZShzKSB7XG4gICAgICAgIHJldHVybiBzLnJlcGxhY2UoL1stXFwvXFxcXF4kKis/LigpfFtcXF17fV0vZywgJ1xcXFwkJicpO1xuICAgIH1cblxuICAgIHZhciB0b2tlbnMgPSB7fTtcblxuICAgIGZ1bmN0aW9uIGFkZFBhcnNlVG9rZW4odG9rZW4sIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBpLFxuICAgICAgICAgICAgZnVuYyA9IGNhbGxiYWNrO1xuICAgICAgICBpZiAodHlwZW9mIHRva2VuID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdG9rZW4gPSBbdG9rZW5dO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc051bWJlcihjYWxsYmFjaykpIHtcbiAgICAgICAgICAgIGZ1bmMgPSBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgICAgICAgICAgICAgYXJyYXlbY2FsbGJhY2tdID0gdG9JbnQoaW5wdXQpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdG9rZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRva2Vuc1t0b2tlbltpXV0gPSBmdW5jO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkV2Vla1BhcnNlVG9rZW4odG9rZW4sIGNhbGxiYWNrKSB7XG4gICAgICAgIGFkZFBhcnNlVG9rZW4odG9rZW4sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZywgdG9rZW4pIHtcbiAgICAgICAgICAgIGNvbmZpZy5fdyA9IGNvbmZpZy5fdyB8fCB7fTtcbiAgICAgICAgICAgIGNhbGxiYWNrKGlucHV0LCBjb25maWcuX3csIGNvbmZpZywgdG9rZW4pO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRUaW1lVG9BcnJheUZyb21Ub2tlbih0b2tlbiwgaW5wdXQsIGNvbmZpZykge1xuICAgICAgICBpZiAoaW5wdXQgIT0gbnVsbCAmJiBoYXNPd25Qcm9wKHRva2VucywgdG9rZW4pKSB7XG4gICAgICAgICAgICB0b2tlbnNbdG9rZW5dKGlucHV0LCBjb25maWcuX2EsIGNvbmZpZywgdG9rZW4pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIFlFQVIgPSAwLFxuICAgICAgICBNT05USCA9IDEsXG4gICAgICAgIERBVEUgPSAyLFxuICAgICAgICBIT1VSID0gMyxcbiAgICAgICAgTUlOVVRFID0gNCxcbiAgICAgICAgU0VDT05EID0gNSxcbiAgICAgICAgTUlMTElTRUNPTkQgPSA2LFxuICAgICAgICBXRUVLID0gNyxcbiAgICAgICAgV0VFS0RBWSA9IDg7XG5cbiAgICBmdW5jdGlvbiBtb2QobiwgeCkge1xuICAgICAgICByZXR1cm4gKChuICUgeCkgKyB4KSAlIHg7XG4gICAgfVxuXG4gICAgdmFyIGluZGV4T2Y7XG5cbiAgICBpZiAoQXJyYXkucHJvdG90eXBlLmluZGV4T2YpIHtcbiAgICAgICAgaW5kZXhPZiA9IEFycmF5LnByb3RvdHlwZS5pbmRleE9mO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGluZGV4T2YgPSBmdW5jdGlvbiAobykge1xuICAgICAgICAgICAgLy8gSSBrbm93XG4gICAgICAgICAgICB2YXIgaTtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXNbaV0gPT09IG8pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRheXNJbk1vbnRoKHllYXIsIG1vbnRoKSB7XG4gICAgICAgIGlmIChpc05hTih5ZWFyKSB8fCBpc05hTihtb250aCkpIHtcbiAgICAgICAgICAgIHJldHVybiBOYU47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1vZE1vbnRoID0gbW9kKG1vbnRoLCAxMik7XG4gICAgICAgIHllYXIgKz0gKG1vbnRoIC0gbW9kTW9udGgpIC8gMTI7XG4gICAgICAgIHJldHVybiBtb2RNb250aCA9PT0gMVxuICAgICAgICAgICAgPyBpc0xlYXBZZWFyKHllYXIpXG4gICAgICAgICAgICAgICAgPyAyOVxuICAgICAgICAgICAgICAgIDogMjhcbiAgICAgICAgICAgIDogMzEgLSAoKG1vZE1vbnRoICUgNykgJSAyKTtcbiAgICB9XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbignTScsIFsnTU0nLCAyXSwgJ01vJywgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb250aCgpICsgMTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdNTU0nLCAwLCAwLCBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5tb250aHNTaG9ydCh0aGlzLCBmb3JtYXQpO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ01NTU0nLCAwLCAwLCBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5tb250aHModGhpcywgZm9ybWF0KTtcbiAgICB9KTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygnbW9udGgnLCAnTScpO1xuXG4gICAgLy8gUFJJT1JJVFlcblxuICAgIGFkZFVuaXRQcmlvcml0eSgnbW9udGgnLCA4KTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ00nLCBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ01NJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ01NTScsIGZ1bmN0aW9uIChpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGUubW9udGhzU2hvcnRSZWdleChpc1N0cmljdCk7XG4gICAgfSk7XG4gICAgYWRkUmVnZXhUb2tlbignTU1NTScsIGZ1bmN0aW9uIChpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGUubW9udGhzUmVnZXgoaXNTdHJpY3QpO1xuICAgIH0pO1xuXG4gICAgYWRkUGFyc2VUb2tlbihbJ00nLCAnTU0nXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSkge1xuICAgICAgICBhcnJheVtNT05USF0gPSB0b0ludChpbnB1dCkgLSAxO1xuICAgIH0pO1xuXG4gICAgYWRkUGFyc2VUb2tlbihbJ01NTScsICdNTU1NJ10sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZywgdG9rZW4pIHtcbiAgICAgICAgdmFyIG1vbnRoID0gY29uZmlnLl9sb2NhbGUubW9udGhzUGFyc2UoaW5wdXQsIHRva2VuLCBjb25maWcuX3N0cmljdCk7XG4gICAgICAgIC8vIGlmIHdlIGRpZG4ndCBmaW5kIGEgbW9udGggbmFtZSwgbWFyayB0aGUgZGF0ZSBhcyBpbnZhbGlkLlxuICAgICAgICBpZiAobW9udGggIT0gbnVsbCkge1xuICAgICAgICAgICAgYXJyYXlbTU9OVEhdID0gbW9udGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5pbnZhbGlkTW9udGggPSBpbnB1dDtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gTE9DQUxFU1xuXG4gICAgdmFyIGRlZmF1bHRMb2NhbGVNb250aHMgPSAnSmFudWFyeV9GZWJydWFyeV9NYXJjaF9BcHJpbF9NYXlfSnVuZV9KdWx5X0F1Z3VzdF9TZXB0ZW1iZXJfT2N0b2Jlcl9Ob3ZlbWJlcl9EZWNlbWJlcicuc3BsaXQoXG4gICAgICAgICAgICAnXydcbiAgICAgICAgKSxcbiAgICAgICAgZGVmYXVsdExvY2FsZU1vbnRoc1Nob3J0ID0gJ0phbl9GZWJfTWFyX0Fwcl9NYXlfSnVuX0p1bF9BdWdfU2VwX09jdF9Ob3ZfRGVjJy5zcGxpdChcbiAgICAgICAgICAgICdfJ1xuICAgICAgICApLFxuICAgICAgICBNT05USFNfSU5fRk9STUFUID0gL0Rbb0RdPyhcXFtbXlxcW1xcXV0qXFxdfFxccykrTU1NTT8vLFxuICAgICAgICBkZWZhdWx0TW9udGhzU2hvcnRSZWdleCA9IG1hdGNoV29yZCxcbiAgICAgICAgZGVmYXVsdE1vbnRoc1JlZ2V4ID0gbWF0Y2hXb3JkO1xuXG4gICAgZnVuY3Rpb24gbG9jYWxlTW9udGhzKG0sIGZvcm1hdCkge1xuICAgICAgICBpZiAoIW0pIHtcbiAgICAgICAgICAgIHJldHVybiBpc0FycmF5KHRoaXMuX21vbnRocylcbiAgICAgICAgICAgICAgICA/IHRoaXMuX21vbnRoc1xuICAgICAgICAgICAgICAgIDogdGhpcy5fbW9udGhzWydzdGFuZGFsb25lJ107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlzQXJyYXkodGhpcy5fbW9udGhzKVxuICAgICAgICAgICAgPyB0aGlzLl9tb250aHNbbS5tb250aCgpXVxuICAgICAgICAgICAgOiB0aGlzLl9tb250aHNbXG4gICAgICAgICAgICAgICAgICAodGhpcy5fbW9udGhzLmlzRm9ybWF0IHx8IE1PTlRIU19JTl9GT1JNQVQpLnRlc3QoZm9ybWF0KVxuICAgICAgICAgICAgICAgICAgICAgID8gJ2Zvcm1hdCdcbiAgICAgICAgICAgICAgICAgICAgICA6ICdzdGFuZGFsb25lJ1xuICAgICAgICAgICAgICBdW20ubW9udGgoKV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9jYWxlTW9udGhzU2hvcnQobSwgZm9ybWF0KSB7XG4gICAgICAgIGlmICghbSkge1xuICAgICAgICAgICAgcmV0dXJuIGlzQXJyYXkodGhpcy5fbW9udGhzU2hvcnQpXG4gICAgICAgICAgICAgICAgPyB0aGlzLl9tb250aHNTaG9ydFxuICAgICAgICAgICAgICAgIDogdGhpcy5fbW9udGhzU2hvcnRbJ3N0YW5kYWxvbmUnXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXNBcnJheSh0aGlzLl9tb250aHNTaG9ydClcbiAgICAgICAgICAgID8gdGhpcy5fbW9udGhzU2hvcnRbbS5tb250aCgpXVxuICAgICAgICAgICAgOiB0aGlzLl9tb250aHNTaG9ydFtcbiAgICAgICAgICAgICAgICAgIE1PTlRIU19JTl9GT1JNQVQudGVzdChmb3JtYXQpID8gJ2Zvcm1hdCcgOiAnc3RhbmRhbG9uZSdcbiAgICAgICAgICAgICAgXVttLm1vbnRoKCldO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhbmRsZVN0cmljdFBhcnNlKG1vbnRoTmFtZSwgZm9ybWF0LCBzdHJpY3QpIHtcbiAgICAgICAgdmFyIGksXG4gICAgICAgICAgICBpaSxcbiAgICAgICAgICAgIG1vbSxcbiAgICAgICAgICAgIGxsYyA9IG1vbnRoTmFtZS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAoIXRoaXMuX21vbnRoc1BhcnNlKSB7XG4gICAgICAgICAgICAvLyB0aGlzIGlzIG5vdCB1c2VkXG4gICAgICAgICAgICB0aGlzLl9tb250aHNQYXJzZSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fbG9uZ01vbnRoc1BhcnNlID0gW107XG4gICAgICAgICAgICB0aGlzLl9zaG9ydE1vbnRoc1BhcnNlID0gW107XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMTI7ICsraSkge1xuICAgICAgICAgICAgICAgIG1vbSA9IGNyZWF0ZVVUQyhbMjAwMCwgaV0pO1xuICAgICAgICAgICAgICAgIHRoaXMuX3Nob3J0TW9udGhzUGFyc2VbaV0gPSB0aGlzLm1vbnRoc1Nob3J0KFxuICAgICAgICAgICAgICAgICAgICBtb20sXG4gICAgICAgICAgICAgICAgICAgICcnXG4gICAgICAgICAgICAgICAgKS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2xvbmdNb250aHNQYXJzZVtpXSA9IHRoaXMubW9udGhzKG1vbSwgJycpLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RyaWN0KSB7XG4gICAgICAgICAgICBpZiAoZm9ybWF0ID09PSAnTU1NJykge1xuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3Nob3J0TW9udGhzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fbG9uZ01vbnRoc1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoZm9ybWF0ID09PSAnTU1NJykge1xuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3Nob3J0TW9udGhzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX2xvbmdNb250aHNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9sb25nTW9udGhzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3Nob3J0TW9udGhzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvY2FsZU1vbnRoc1BhcnNlKG1vbnRoTmFtZSwgZm9ybWF0LCBzdHJpY3QpIHtcbiAgICAgICAgdmFyIGksIG1vbSwgcmVnZXg7XG5cbiAgICAgICAgaWYgKHRoaXMuX21vbnRoc1BhcnNlRXhhY3QpIHtcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGVTdHJpY3RQYXJzZS5jYWxsKHRoaXMsIG1vbnRoTmFtZSwgZm9ybWF0LCBzdHJpY3QpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLl9tb250aHNQYXJzZSkge1xuICAgICAgICAgICAgdGhpcy5fbW9udGhzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX2xvbmdNb250aHNQYXJzZSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fc2hvcnRNb250aHNQYXJzZSA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVE9ETzogYWRkIHNvcnRpbmdcbiAgICAgICAgLy8gU29ydGluZyBtYWtlcyBzdXJlIGlmIG9uZSBtb250aCAob3IgYWJicikgaXMgYSBwcmVmaXggb2YgYW5vdGhlclxuICAgICAgICAvLyBzZWUgc29ydGluZyBpbiBjb21wdXRlTW9udGhzUGFyc2VcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDEyOyBpKyspIHtcbiAgICAgICAgICAgIC8vIG1ha2UgdGhlIHJlZ2V4IGlmIHdlIGRvbid0IGhhdmUgaXQgYWxyZWFkeVxuICAgICAgICAgICAgbW9tID0gY3JlYXRlVVRDKFsyMDAwLCBpXSk7XG4gICAgICAgICAgICBpZiAoc3RyaWN0ICYmICF0aGlzLl9sb25nTW9udGhzUGFyc2VbaV0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9sb25nTW9udGhzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKFxuICAgICAgICAgICAgICAgICAgICAnXicgKyB0aGlzLm1vbnRocyhtb20sICcnKS5yZXBsYWNlKCcuJywgJycpICsgJyQnLFxuICAgICAgICAgICAgICAgICAgICAnaSdcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHRoaXMuX3Nob3J0TW9udGhzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKFxuICAgICAgICAgICAgICAgICAgICAnXicgKyB0aGlzLm1vbnRoc1Nob3J0KG1vbSwgJycpLnJlcGxhY2UoJy4nLCAnJykgKyAnJCcsXG4gICAgICAgICAgICAgICAgICAgICdpJ1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXN0cmljdCAmJiAhdGhpcy5fbW9udGhzUGFyc2VbaV0pIHtcbiAgICAgICAgICAgICAgICByZWdleCA9XG4gICAgICAgICAgICAgICAgICAgICdeJyArIHRoaXMubW9udGhzKG1vbSwgJycpICsgJ3xeJyArIHRoaXMubW9udGhzU2hvcnQobW9tLCAnJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fbW9udGhzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKHJlZ2V4LnJlcGxhY2UoJy4nLCAnJyksICdpJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB0ZXN0IHRoZSByZWdleFxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIHN0cmljdCAmJlxuICAgICAgICAgICAgICAgIGZvcm1hdCA9PT0gJ01NTU0nICYmXG4gICAgICAgICAgICAgICAgdGhpcy5fbG9uZ01vbnRoc1BhcnNlW2ldLnRlc3QobW9udGhOYW1lKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgICAgIHN0cmljdCAmJlxuICAgICAgICAgICAgICAgIGZvcm1hdCA9PT0gJ01NTScgJiZcbiAgICAgICAgICAgICAgICB0aGlzLl9zaG9ydE1vbnRoc1BhcnNlW2ldLnRlc3QobW9udGhOYW1lKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFzdHJpY3QgJiYgdGhpcy5fbW9udGhzUGFyc2VbaV0udGVzdChtb250aE5hbWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICBmdW5jdGlvbiBzZXRNb250aChtb20sIHZhbHVlKSB7XG4gICAgICAgIHZhciBkYXlPZk1vbnRoO1xuXG4gICAgICAgIGlmICghbW9tLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgLy8gTm8gb3BcbiAgICAgICAgICAgIHJldHVybiBtb207XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgaWYgKC9eXFxkKyQvLnRlc3QodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB0b0ludCh2YWx1ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gbW9tLmxvY2FsZURhdGEoKS5tb250aHNQYXJzZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogQW5vdGhlciBzaWxlbnQgZmFpbHVyZT9cbiAgICAgICAgICAgICAgICBpZiAoIWlzTnVtYmVyKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbW9tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGRheU9mTW9udGggPSBNYXRoLm1pbihtb20uZGF0ZSgpLCBkYXlzSW5Nb250aChtb20ueWVhcigpLCB2YWx1ZSkpO1xuICAgICAgICBtb20uX2RbJ3NldCcgKyAobW9tLl9pc1VUQyA/ICdVVEMnIDogJycpICsgJ01vbnRoJ10odmFsdWUsIGRheU9mTW9udGgpO1xuICAgICAgICByZXR1cm4gbW9tO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFNldE1vbnRoKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBzZXRNb250aCh0aGlzLCB2YWx1ZSk7XG4gICAgICAgICAgICBob29rcy51cGRhdGVPZmZzZXQodGhpcywgdHJ1ZSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBnZXQodGhpcywgJ01vbnRoJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXREYXlzSW5Nb250aCgpIHtcbiAgICAgICAgcmV0dXJuIGRheXNJbk1vbnRoKHRoaXMueWVhcigpLCB0aGlzLm1vbnRoKCkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1vbnRoc1Nob3J0UmVnZXgoaXNTdHJpY3QpIHtcbiAgICAgICAgaWYgKHRoaXMuX21vbnRoc1BhcnNlRXhhY3QpIHtcbiAgICAgICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX21vbnRoc1JlZ2V4JykpIHtcbiAgICAgICAgICAgICAgICBjb21wdXRlTW9udGhzUGFyc2UuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1N0cmljdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9tb250aHNTaG9ydFN0cmljdFJlZ2V4O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzU2hvcnRSZWdleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX21vbnRoc1Nob3J0UmVnZXgnKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX21vbnRoc1Nob3J0UmVnZXggPSBkZWZhdWx0TW9udGhzU2hvcnRSZWdleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9tb250aHNTaG9ydFN0cmljdFJlZ2V4ICYmIGlzU3RyaWN0XG4gICAgICAgICAgICAgICAgPyB0aGlzLl9tb250aHNTaG9ydFN0cmljdFJlZ2V4XG4gICAgICAgICAgICAgICAgOiB0aGlzLl9tb250aHNTaG9ydFJlZ2V4O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbW9udGhzUmVnZXgoaXNTdHJpY3QpIHtcbiAgICAgICAgaWYgKHRoaXMuX21vbnRoc1BhcnNlRXhhY3QpIHtcbiAgICAgICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX21vbnRoc1JlZ2V4JykpIHtcbiAgICAgICAgICAgICAgICBjb21wdXRlTW9udGhzUGFyc2UuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1N0cmljdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9tb250aHNTdHJpY3RSZWdleDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21vbnRoc1JlZ2V4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfbW9udGhzUmVnZXgnKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX21vbnRoc1JlZ2V4ID0gZGVmYXVsdE1vbnRoc1JlZ2V4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21vbnRoc1N0cmljdFJlZ2V4ICYmIGlzU3RyaWN0XG4gICAgICAgICAgICAgICAgPyB0aGlzLl9tb250aHNTdHJpY3RSZWdleFxuICAgICAgICAgICAgICAgIDogdGhpcy5fbW9udGhzUmVnZXg7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb21wdXRlTW9udGhzUGFyc2UoKSB7XG4gICAgICAgIGZ1bmN0aW9uIGNtcExlblJldihhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gYi5sZW5ndGggLSBhLmxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzaG9ydFBpZWNlcyA9IFtdLFxuICAgICAgICAgICAgbG9uZ1BpZWNlcyA9IFtdLFxuICAgICAgICAgICAgbWl4ZWRQaWVjZXMgPSBbXSxcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICBtb207XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCAxMjsgaSsrKSB7XG4gICAgICAgICAgICAvLyBtYWtlIHRoZSByZWdleCBpZiB3ZSBkb24ndCBoYXZlIGl0IGFscmVhZHlcbiAgICAgICAgICAgIG1vbSA9IGNyZWF0ZVVUQyhbMjAwMCwgaV0pO1xuICAgICAgICAgICAgc2hvcnRQaWVjZXMucHVzaCh0aGlzLm1vbnRoc1Nob3J0KG1vbSwgJycpKTtcbiAgICAgICAgICAgIGxvbmdQaWVjZXMucHVzaCh0aGlzLm1vbnRocyhtb20sICcnKSk7XG4gICAgICAgICAgICBtaXhlZFBpZWNlcy5wdXNoKHRoaXMubW9udGhzKG1vbSwgJycpKTtcbiAgICAgICAgICAgIG1peGVkUGllY2VzLnB1c2godGhpcy5tb250aHNTaG9ydChtb20sICcnKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU29ydGluZyBtYWtlcyBzdXJlIGlmIG9uZSBtb250aCAob3IgYWJicikgaXMgYSBwcmVmaXggb2YgYW5vdGhlciBpdFxuICAgICAgICAvLyB3aWxsIG1hdGNoIHRoZSBsb25nZXIgcGllY2UuXG4gICAgICAgIHNob3J0UGllY2VzLnNvcnQoY21wTGVuUmV2KTtcbiAgICAgICAgbG9uZ1BpZWNlcy5zb3J0KGNtcExlblJldik7XG4gICAgICAgIG1peGVkUGllY2VzLnNvcnQoY21wTGVuUmV2KTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDEyOyBpKyspIHtcbiAgICAgICAgICAgIHNob3J0UGllY2VzW2ldID0gcmVnZXhFc2NhcGUoc2hvcnRQaWVjZXNbaV0pO1xuICAgICAgICAgICAgbG9uZ1BpZWNlc1tpXSA9IHJlZ2V4RXNjYXBlKGxvbmdQaWVjZXNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCAyNDsgaSsrKSB7XG4gICAgICAgICAgICBtaXhlZFBpZWNlc1tpXSA9IHJlZ2V4RXNjYXBlKG1peGVkUGllY2VzW2ldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX21vbnRoc1JlZ2V4ID0gbmV3IFJlZ0V4cCgnXignICsgbWl4ZWRQaWVjZXMuam9pbignfCcpICsgJyknLCAnaScpO1xuICAgICAgICB0aGlzLl9tb250aHNTaG9ydFJlZ2V4ID0gdGhpcy5fbW9udGhzUmVnZXg7XG4gICAgICAgIHRoaXMuX21vbnRoc1N0cmljdFJlZ2V4ID0gbmV3IFJlZ0V4cChcbiAgICAgICAgICAgICdeKCcgKyBsb25nUGllY2VzLmpvaW4oJ3wnKSArICcpJyxcbiAgICAgICAgICAgICdpJ1xuICAgICAgICApO1xuICAgICAgICB0aGlzLl9tb250aHNTaG9ydFN0cmljdFJlZ2V4ID0gbmV3IFJlZ0V4cChcbiAgICAgICAgICAgICdeKCcgKyBzaG9ydFBpZWNlcy5qb2luKCd8JykgKyAnKScsXG4gICAgICAgICAgICAnaSdcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbignWScsIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHkgPSB0aGlzLnllYXIoKTtcbiAgICAgICAgcmV0dXJuIHkgPD0gOTk5OSA/IHplcm9GaWxsKHksIDQpIDogJysnICsgeTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnWVknLCAyXSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy55ZWFyKCkgJSAxMDA7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1lZWVknLCA0XSwgMCwgJ3llYXInKTtcbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1lZWVlZJywgNV0sIDAsICd5ZWFyJyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydZWVlZWVknLCA2LCB0cnVlXSwgMCwgJ3llYXInKTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygneWVhcicsICd5Jyk7XG5cbiAgICAvLyBQUklPUklUSUVTXG5cbiAgICBhZGRVbml0UHJpb3JpdHkoJ3llYXInLCAxKTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ1knLCBtYXRjaFNpZ25lZCk7XG4gICAgYWRkUmVnZXhUb2tlbignWVknLCBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgYWRkUmVnZXhUb2tlbignWVlZWScsIG1hdGNoMXRvNCwgbWF0Y2g0KTtcbiAgICBhZGRSZWdleFRva2VuKCdZWVlZWScsIG1hdGNoMXRvNiwgbWF0Y2g2KTtcbiAgICBhZGRSZWdleFRva2VuKCdZWVlZWVknLCBtYXRjaDF0bzYsIG1hdGNoNik7XG5cbiAgICBhZGRQYXJzZVRva2VuKFsnWVlZWVknLCAnWVlZWVlZJ10sIFlFQVIpO1xuICAgIGFkZFBhcnNlVG9rZW4oJ1lZWVknLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgICAgIGFycmF5W1lFQVJdID1cbiAgICAgICAgICAgIGlucHV0Lmxlbmd0aCA9PT0gMiA/IGhvb2tzLnBhcnNlVHdvRGlnaXRZZWFyKGlucHV0KSA6IHRvSW50KGlucHV0KTtcbiAgICB9KTtcbiAgICBhZGRQYXJzZVRva2VuKCdZWScsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICAgICAgYXJyYXlbWUVBUl0gPSBob29rcy5wYXJzZVR3b0RpZ2l0WWVhcihpbnB1dCk7XG4gICAgfSk7XG4gICAgYWRkUGFyc2VUb2tlbignWScsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICAgICAgYXJyYXlbWUVBUl0gPSBwYXJzZUludChpbnB1dCwgMTApO1xuICAgIH0pO1xuXG4gICAgLy8gSEVMUEVSU1xuXG4gICAgZnVuY3Rpb24gZGF5c0luWWVhcih5ZWFyKSB7XG4gICAgICAgIHJldHVybiBpc0xlYXBZZWFyKHllYXIpID8gMzY2IDogMzY1O1xuICAgIH1cblxuICAgIC8vIEhPT0tTXG5cbiAgICBob29rcy5wYXJzZVR3b0RpZ2l0WWVhciA9IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICByZXR1cm4gdG9JbnQoaW5wdXQpICsgKHRvSW50KGlucHV0KSA+IDY4ID8gMTkwMCA6IDIwMDApO1xuICAgIH07XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICB2YXIgZ2V0U2V0WWVhciA9IG1ha2VHZXRTZXQoJ0Z1bGxZZWFyJywgdHJ1ZSk7XG5cbiAgICBmdW5jdGlvbiBnZXRJc0xlYXBZZWFyKCkge1xuICAgICAgICByZXR1cm4gaXNMZWFwWWVhcih0aGlzLnllYXIoKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlRGF0ZSh5LCBtLCBkLCBoLCBNLCBzLCBtcykge1xuICAgICAgICAvLyBjYW4ndCBqdXN0IGFwcGx5KCkgdG8gY3JlYXRlIGEgZGF0ZTpcbiAgICAgICAgLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xLzE4MTM0OFxuICAgICAgICB2YXIgZGF0ZTtcbiAgICAgICAgLy8gdGhlIGRhdGUgY29uc3RydWN0b3IgcmVtYXBzIHllYXJzIDAtOTkgdG8gMTkwMC0xOTk5XG4gICAgICAgIGlmICh5IDwgMTAwICYmIHkgPj0gMCkge1xuICAgICAgICAgICAgLy8gcHJlc2VydmUgbGVhcCB5ZWFycyB1c2luZyBhIGZ1bGwgNDAwIHllYXIgY3ljbGUsIHRoZW4gcmVzZXRcbiAgICAgICAgICAgIGRhdGUgPSBuZXcgRGF0ZSh5ICsgNDAwLCBtLCBkLCBoLCBNLCBzLCBtcyk7XG4gICAgICAgICAgICBpZiAoaXNGaW5pdGUoZGF0ZS5nZXRGdWxsWWVhcigpKSkge1xuICAgICAgICAgICAgICAgIGRhdGUuc2V0RnVsbFllYXIoeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkYXRlID0gbmV3IERhdGUoeSwgbSwgZCwgaCwgTSwgcywgbXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRhdGU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlVVRDRGF0ZSh5KSB7XG4gICAgICAgIHZhciBkYXRlLCBhcmdzO1xuICAgICAgICAvLyB0aGUgRGF0ZS5VVEMgZnVuY3Rpb24gcmVtYXBzIHllYXJzIDAtOTkgdG8gMTkwMC0xOTk5XG4gICAgICAgIGlmICh5IDwgMTAwICYmIHkgPj0gMCkge1xuICAgICAgICAgICAgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAvLyBwcmVzZXJ2ZSBsZWFwIHllYXJzIHVzaW5nIGEgZnVsbCA0MDAgeWVhciBjeWNsZSwgdGhlbiByZXNldFxuICAgICAgICAgICAgYXJnc1swXSA9IHkgKyA0MDA7XG4gICAgICAgICAgICBkYXRlID0gbmV3IERhdGUoRGF0ZS5VVEMuYXBwbHkobnVsbCwgYXJncykpO1xuICAgICAgICAgICAgaWYgKGlzRmluaXRlKGRhdGUuZ2V0VVRDRnVsbFllYXIoKSkpIHtcbiAgICAgICAgICAgICAgICBkYXRlLnNldFVUQ0Z1bGxZZWFyKHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGF0ZSA9IG5ldyBEYXRlKERhdGUuVVRDLmFwcGx5KG51bGwsIGFyZ3VtZW50cykpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRhdGU7XG4gICAgfVxuXG4gICAgLy8gc3RhcnQtb2YtZmlyc3Qtd2VlayAtIHN0YXJ0LW9mLXllYXJcbiAgICBmdW5jdGlvbiBmaXJzdFdlZWtPZmZzZXQoeWVhciwgZG93LCBkb3kpIHtcbiAgICAgICAgdmFyIC8vIGZpcnN0LXdlZWsgZGF5IC0tIHdoaWNoIGphbnVhcnkgaXMgYWx3YXlzIGluIHRoZSBmaXJzdCB3ZWVrICg0IGZvciBpc28sIDEgZm9yIG90aGVyKVxuICAgICAgICAgICAgZndkID0gNyArIGRvdyAtIGRveSxcbiAgICAgICAgICAgIC8vIGZpcnN0LXdlZWsgZGF5IGxvY2FsIHdlZWtkYXkgLS0gd2hpY2ggbG9jYWwgd2Vla2RheSBpcyBmd2RcbiAgICAgICAgICAgIGZ3ZGx3ID0gKDcgKyBjcmVhdGVVVENEYXRlKHllYXIsIDAsIGZ3ZCkuZ2V0VVRDRGF5KCkgLSBkb3cpICUgNztcblxuICAgICAgICByZXR1cm4gLWZ3ZGx3ICsgZndkIC0gMTtcbiAgICB9XG5cbiAgICAvLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JU09fd2Vla19kYXRlI0NhbGN1bGF0aW5nX2FfZGF0ZV9naXZlbl90aGVfeWVhci4yQ193ZWVrX251bWJlcl9hbmRfd2Vla2RheVxuICAgIGZ1bmN0aW9uIGRheU9mWWVhckZyb21XZWVrcyh5ZWFyLCB3ZWVrLCB3ZWVrZGF5LCBkb3csIGRveSkge1xuICAgICAgICB2YXIgbG9jYWxXZWVrZGF5ID0gKDcgKyB3ZWVrZGF5IC0gZG93KSAlIDcsXG4gICAgICAgICAgICB3ZWVrT2Zmc2V0ID0gZmlyc3RXZWVrT2Zmc2V0KHllYXIsIGRvdywgZG95KSxcbiAgICAgICAgICAgIGRheU9mWWVhciA9IDEgKyA3ICogKHdlZWsgLSAxKSArIGxvY2FsV2Vla2RheSArIHdlZWtPZmZzZXQsXG4gICAgICAgICAgICByZXNZZWFyLFxuICAgICAgICAgICAgcmVzRGF5T2ZZZWFyO1xuXG4gICAgICAgIGlmIChkYXlPZlllYXIgPD0gMCkge1xuICAgICAgICAgICAgcmVzWWVhciA9IHllYXIgLSAxO1xuICAgICAgICAgICAgcmVzRGF5T2ZZZWFyID0gZGF5c0luWWVhcihyZXNZZWFyKSArIGRheU9mWWVhcjtcbiAgICAgICAgfSBlbHNlIGlmIChkYXlPZlllYXIgPiBkYXlzSW5ZZWFyKHllYXIpKSB7XG4gICAgICAgICAgICByZXNZZWFyID0geWVhciArIDE7XG4gICAgICAgICAgICByZXNEYXlPZlllYXIgPSBkYXlPZlllYXIgLSBkYXlzSW5ZZWFyKHllYXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzWWVhciA9IHllYXI7XG4gICAgICAgICAgICByZXNEYXlPZlllYXIgPSBkYXlPZlllYXI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeWVhcjogcmVzWWVhcixcbiAgICAgICAgICAgIGRheU9mWWVhcjogcmVzRGF5T2ZZZWFyLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHdlZWtPZlllYXIobW9tLCBkb3csIGRveSkge1xuICAgICAgICB2YXIgd2Vla09mZnNldCA9IGZpcnN0V2Vla09mZnNldChtb20ueWVhcigpLCBkb3csIGRveSksXG4gICAgICAgICAgICB3ZWVrID0gTWF0aC5mbG9vcigobW9tLmRheU9mWWVhcigpIC0gd2Vla09mZnNldCAtIDEpIC8gNykgKyAxLFxuICAgICAgICAgICAgcmVzV2VlayxcbiAgICAgICAgICAgIHJlc1llYXI7XG5cbiAgICAgICAgaWYgKHdlZWsgPCAxKSB7XG4gICAgICAgICAgICByZXNZZWFyID0gbW9tLnllYXIoKSAtIDE7XG4gICAgICAgICAgICByZXNXZWVrID0gd2VlayArIHdlZWtzSW5ZZWFyKHJlc1llYXIsIGRvdywgZG95KTtcbiAgICAgICAgfSBlbHNlIGlmICh3ZWVrID4gd2Vla3NJblllYXIobW9tLnllYXIoKSwgZG93LCBkb3kpKSB7XG4gICAgICAgICAgICByZXNXZWVrID0gd2VlayAtIHdlZWtzSW5ZZWFyKG1vbS55ZWFyKCksIGRvdywgZG95KTtcbiAgICAgICAgICAgIHJlc1llYXIgPSBtb20ueWVhcigpICsgMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc1llYXIgPSBtb20ueWVhcigpO1xuICAgICAgICAgICAgcmVzV2VlayA9IHdlZWs7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgd2VlazogcmVzV2VlayxcbiAgICAgICAgICAgIHllYXI6IHJlc1llYXIsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gd2Vla3NJblllYXIoeWVhciwgZG93LCBkb3kpIHtcbiAgICAgICAgdmFyIHdlZWtPZmZzZXQgPSBmaXJzdFdlZWtPZmZzZXQoeWVhciwgZG93LCBkb3kpLFxuICAgICAgICAgICAgd2Vla09mZnNldE5leHQgPSBmaXJzdFdlZWtPZmZzZXQoeWVhciArIDEsIGRvdywgZG95KTtcbiAgICAgICAgcmV0dXJuIChkYXlzSW5ZZWFyKHllYXIpIC0gd2Vla09mZnNldCArIHdlZWtPZmZzZXROZXh0KSAvIDc7XG4gICAgfVxuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ3cnLCBbJ3d3JywgMl0sICd3bycsICd3ZWVrJyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oJ1cnLCBbJ1dXJywgMl0sICdXbycsICdpc29XZWVrJyk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ3dlZWsnLCAndycpO1xuICAgIGFkZFVuaXRBbGlhcygnaXNvV2VlaycsICdXJyk7XG5cbiAgICAvLyBQUklPUklUSUVTXG5cbiAgICBhZGRVbml0UHJpb3JpdHkoJ3dlZWsnLCA1KTtcbiAgICBhZGRVbml0UHJpb3JpdHkoJ2lzb1dlZWsnLCA1KTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ3cnLCBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ3d3JywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1cnLCBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1dXJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuXG4gICAgYWRkV2Vla1BhcnNlVG9rZW4oWyd3JywgJ3d3JywgJ1cnLCAnV1cnXSwgZnVuY3Rpb24gKFxuICAgICAgICBpbnB1dCxcbiAgICAgICAgd2VlayxcbiAgICAgICAgY29uZmlnLFxuICAgICAgICB0b2tlblxuICAgICkge1xuICAgICAgICB3ZWVrW3Rva2VuLnN1YnN0cigwLCAxKV0gPSB0b0ludChpbnB1dCk7XG4gICAgfSk7XG5cbiAgICAvLyBIRUxQRVJTXG5cbiAgICAvLyBMT0NBTEVTXG5cbiAgICBmdW5jdGlvbiBsb2NhbGVXZWVrKG1vbSkge1xuICAgICAgICByZXR1cm4gd2Vla09mWWVhcihtb20sIHRoaXMuX3dlZWsuZG93LCB0aGlzLl93ZWVrLmRveSkud2VlaztcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdExvY2FsZVdlZWsgPSB7XG4gICAgICAgIGRvdzogMCwgLy8gU3VuZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAgICAgIGRveTogNiwgLy8gVGhlIHdlZWsgdGhhdCBjb250YWlucyBKYW4gNnRoIGlzIHRoZSBmaXJzdCB3ZWVrIG9mIHRoZSB5ZWFyLlxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBsb2NhbGVGaXJzdERheU9mV2VlaygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWsuZG93O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvY2FsZUZpcnN0RGF5T2ZZZWFyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd2Vlay5kb3k7XG4gICAgfVxuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgZnVuY3Rpb24gZ2V0U2V0V2VlayhpbnB1dCkge1xuICAgICAgICB2YXIgd2VlayA9IHRoaXMubG9jYWxlRGF0YSgpLndlZWsodGhpcyk7XG4gICAgICAgIHJldHVybiBpbnB1dCA9PSBudWxsID8gd2VlayA6IHRoaXMuYWRkKChpbnB1dCAtIHdlZWspICogNywgJ2QnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTZXRJU09XZWVrKGlucHV0KSB7XG4gICAgICAgIHZhciB3ZWVrID0gd2Vla09mWWVhcih0aGlzLCAxLCA0KS53ZWVrO1xuICAgICAgICByZXR1cm4gaW5wdXQgPT0gbnVsbCA/IHdlZWsgOiB0aGlzLmFkZCgoaW5wdXQgLSB3ZWVrKSAqIDcsICdkJyk7XG4gICAgfVxuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ2QnLCAwLCAnZG8nLCAnZGF5Jyk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignZGQnLCAwLCAwLCBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS53ZWVrZGF5c01pbih0aGlzLCBmb3JtYXQpO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ2RkZCcsIDAsIDAsIGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLndlZWtkYXlzU2hvcnQodGhpcywgZm9ybWF0KTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdkZGRkJywgMCwgMCwgZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkud2Vla2RheXModGhpcywgZm9ybWF0KTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdlJywgMCwgMCwgJ3dlZWtkYXknKTtcbiAgICBhZGRGb3JtYXRUb2tlbignRScsIDAsIDAsICdpc29XZWVrZGF5Jyk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ2RheScsICdkJyk7XG4gICAgYWRkVW5pdEFsaWFzKCd3ZWVrZGF5JywgJ2UnKTtcbiAgICBhZGRVbml0QWxpYXMoJ2lzb1dlZWtkYXknLCAnRScpO1xuXG4gICAgLy8gUFJJT1JJVFlcbiAgICBhZGRVbml0UHJpb3JpdHkoJ2RheScsIDExKTtcbiAgICBhZGRVbml0UHJpb3JpdHkoJ3dlZWtkYXknLCAxMSk7XG4gICAgYWRkVW5pdFByaW9yaXR5KCdpc29XZWVrZGF5JywgMTEpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignZCcsIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignZScsIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignRScsIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignZGQnLCBmdW5jdGlvbiAoaXNTdHJpY3QsIGxvY2FsZSkge1xuICAgICAgICByZXR1cm4gbG9jYWxlLndlZWtkYXlzTWluUmVnZXgoaXNTdHJpY3QpO1xuICAgIH0pO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2RkZCcsIGZ1bmN0aW9uIChpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGUud2Vla2RheXNTaG9ydFJlZ2V4KGlzU3RyaWN0KTtcbiAgICB9KTtcbiAgICBhZGRSZWdleFRva2VuKCdkZGRkJywgZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZS53ZWVrZGF5c1JlZ2V4KGlzU3RyaWN0KTtcbiAgICB9KTtcblxuICAgIGFkZFdlZWtQYXJzZVRva2VuKFsnZGQnLCAnZGRkJywgJ2RkZGQnXSwgZnVuY3Rpb24gKGlucHV0LCB3ZWVrLCBjb25maWcsIHRva2VuKSB7XG4gICAgICAgIHZhciB3ZWVrZGF5ID0gY29uZmlnLl9sb2NhbGUud2Vla2RheXNQYXJzZShpbnB1dCwgdG9rZW4sIGNvbmZpZy5fc3RyaWN0KTtcbiAgICAgICAgLy8gaWYgd2UgZGlkbid0IGdldCBhIHdlZWtkYXkgbmFtZSwgbWFyayB0aGUgZGF0ZSBhcyBpbnZhbGlkXG4gICAgICAgIGlmICh3ZWVrZGF5ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHdlZWsuZCA9IHdlZWtkYXk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5pbnZhbGlkV2Vla2RheSA9IGlucHV0O1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBhZGRXZWVrUGFyc2VUb2tlbihbJ2QnLCAnZScsICdFJ10sIGZ1bmN0aW9uIChpbnB1dCwgd2VlaywgY29uZmlnLCB0b2tlbikge1xuICAgICAgICB3ZWVrW3Rva2VuXSA9IHRvSW50KGlucHV0KTtcbiAgICB9KTtcblxuICAgIC8vIEhFTFBFUlNcblxuICAgIGZ1bmN0aW9uIHBhcnNlV2Vla2RheShpbnB1dCwgbG9jYWxlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzTmFOKGlucHV0KSkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KGlucHV0LCAxMCk7XG4gICAgICAgIH1cblxuICAgICAgICBpbnB1dCA9IGxvY2FsZS53ZWVrZGF5c1BhcnNlKGlucHV0KTtcbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlSXNvV2Vla2RheShpbnB1dCwgbG9jYWxlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxlLndlZWtkYXlzUGFyc2UoaW5wdXQpICUgNyB8fCA3O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpc05hTihpbnB1dCkgPyBudWxsIDogaW5wdXQ7XG4gICAgfVxuXG4gICAgLy8gTE9DQUxFU1xuICAgIGZ1bmN0aW9uIHNoaWZ0V2Vla2RheXMod3MsIG4pIHtcbiAgICAgICAgcmV0dXJuIHdzLnNsaWNlKG4sIDcpLmNvbmNhdCh3cy5zbGljZSgwLCBuKSk7XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRMb2NhbGVXZWVrZGF5cyA9ICdTdW5kYXlfTW9uZGF5X1R1ZXNkYXlfV2VkbmVzZGF5X1RodXJzZGF5X0ZyaWRheV9TYXR1cmRheScuc3BsaXQoXG4gICAgICAgICAgICAnXydcbiAgICAgICAgKSxcbiAgICAgICAgZGVmYXVsdExvY2FsZVdlZWtkYXlzU2hvcnQgPSAnU3VuX01vbl9UdWVfV2VkX1RodV9GcmlfU2F0Jy5zcGxpdCgnXycpLFxuICAgICAgICBkZWZhdWx0TG9jYWxlV2Vla2RheXNNaW4gPSAnU3VfTW9fVHVfV2VfVGhfRnJfU2EnLnNwbGl0KCdfJyksXG4gICAgICAgIGRlZmF1bHRXZWVrZGF5c1JlZ2V4ID0gbWF0Y2hXb3JkLFxuICAgICAgICBkZWZhdWx0V2Vla2RheXNTaG9ydFJlZ2V4ID0gbWF0Y2hXb3JkLFxuICAgICAgICBkZWZhdWx0V2Vla2RheXNNaW5SZWdleCA9IG1hdGNoV29yZDtcblxuICAgIGZ1bmN0aW9uIGxvY2FsZVdlZWtkYXlzKG0sIGZvcm1hdCkge1xuICAgICAgICB2YXIgd2Vla2RheXMgPSBpc0FycmF5KHRoaXMuX3dlZWtkYXlzKVxuICAgICAgICAgICAgPyB0aGlzLl93ZWVrZGF5c1xuICAgICAgICAgICAgOiB0aGlzLl93ZWVrZGF5c1tcbiAgICAgICAgICAgICAgICAgIG0gJiYgbSAhPT0gdHJ1ZSAmJiB0aGlzLl93ZWVrZGF5cy5pc0Zvcm1hdC50ZXN0KGZvcm1hdClcbiAgICAgICAgICAgICAgICAgICAgICA/ICdmb3JtYXQnXG4gICAgICAgICAgICAgICAgICAgICAgOiAnc3RhbmRhbG9uZSdcbiAgICAgICAgICAgICAgXTtcbiAgICAgICAgcmV0dXJuIG0gPT09IHRydWVcbiAgICAgICAgICAgID8gc2hpZnRXZWVrZGF5cyh3ZWVrZGF5cywgdGhpcy5fd2Vlay5kb3cpXG4gICAgICAgICAgICA6IG1cbiAgICAgICAgICAgID8gd2Vla2RheXNbbS5kYXkoKV1cbiAgICAgICAgICAgIDogd2Vla2RheXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9jYWxlV2Vla2RheXNTaG9ydChtKSB7XG4gICAgICAgIHJldHVybiBtID09PSB0cnVlXG4gICAgICAgICAgICA/IHNoaWZ0V2Vla2RheXModGhpcy5fd2Vla2RheXNTaG9ydCwgdGhpcy5fd2Vlay5kb3cpXG4gICAgICAgICAgICA6IG1cbiAgICAgICAgICAgID8gdGhpcy5fd2Vla2RheXNTaG9ydFttLmRheSgpXVxuICAgICAgICAgICAgOiB0aGlzLl93ZWVrZGF5c1Nob3J0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvY2FsZVdlZWtkYXlzTWluKG0pIHtcbiAgICAgICAgcmV0dXJuIG0gPT09IHRydWVcbiAgICAgICAgICAgID8gc2hpZnRXZWVrZGF5cyh0aGlzLl93ZWVrZGF5c01pbiwgdGhpcy5fd2Vlay5kb3cpXG4gICAgICAgICAgICA6IG1cbiAgICAgICAgICAgID8gdGhpcy5fd2Vla2RheXNNaW5bbS5kYXkoKV1cbiAgICAgICAgICAgIDogdGhpcy5fd2Vla2RheXNNaW47XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFuZGxlU3RyaWN0UGFyc2UkMSh3ZWVrZGF5TmFtZSwgZm9ybWF0LCBzdHJpY3QpIHtcbiAgICAgICAgdmFyIGksXG4gICAgICAgICAgICBpaSxcbiAgICAgICAgICAgIG1vbSxcbiAgICAgICAgICAgIGxsYyA9IHdlZWtkYXlOYW1lLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmICghdGhpcy5fd2Vla2RheXNQYXJzZSkge1xuICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNQYXJzZSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlID0gW107XG4gICAgICAgICAgICB0aGlzLl9taW5XZWVrZGF5c1BhcnNlID0gW107XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCA3OyArK2kpIHtcbiAgICAgICAgICAgICAgICBtb20gPSBjcmVhdGVVVEMoWzIwMDAsIDFdKS5kYXkoaSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fbWluV2Vla2RheXNQYXJzZVtpXSA9IHRoaXMud2Vla2RheXNNaW4oXG4gICAgICAgICAgICAgICAgICAgIG1vbSxcbiAgICAgICAgICAgICAgICAgICAgJydcbiAgICAgICAgICAgICAgICApLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlW2ldID0gdGhpcy53ZWVrZGF5c1Nob3J0KFxuICAgICAgICAgICAgICAgICAgICBtb20sXG4gICAgICAgICAgICAgICAgICAgICcnXG4gICAgICAgICAgICAgICAgKS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzUGFyc2VbaV0gPSB0aGlzLndlZWtkYXlzKG1vbSwgJycpLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RyaWN0KSB7XG4gICAgICAgICAgICBpZiAoZm9ybWF0ID09PSAnZGRkZCcpIHtcbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl93ZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGZvcm1hdCA9PT0gJ2RkZCcpIHtcbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fbWluV2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGZvcm1hdCA9PT0gJ2RkZGQnKSB7XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fd2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICBpZiAoaWkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIGlmIChpaSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9taW5XZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGZvcm1hdCA9PT0gJ2RkZCcpIHtcbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3dlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX21pbldlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fbWluV2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICBpZiAoaWkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fd2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICBpZiAoaWkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb2NhbGVXZWVrZGF5c1BhcnNlKHdlZWtkYXlOYW1lLCBmb3JtYXQsIHN0cmljdCkge1xuICAgICAgICB2YXIgaSwgbW9tLCByZWdleDtcblxuICAgICAgICBpZiAodGhpcy5fd2Vla2RheXNQYXJzZUV4YWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlU3RyaWN0UGFyc2UkMS5jYWxsKHRoaXMsIHdlZWtkYXlOYW1lLCBmb3JtYXQsIHN0cmljdCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuX3dlZWtkYXlzUGFyc2UpIHtcbiAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX21pbldlZWtkYXlzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fZnVsbFdlZWtkYXlzUGFyc2UgPSBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCA3OyBpKyspIHtcbiAgICAgICAgICAgIC8vIG1ha2UgdGhlIHJlZ2V4IGlmIHdlIGRvbid0IGhhdmUgaXQgYWxyZWFkeVxuXG4gICAgICAgICAgICBtb20gPSBjcmVhdGVVVEMoWzIwMDAsIDFdKS5kYXkoaSk7XG4gICAgICAgICAgICBpZiAoc3RyaWN0ICYmICF0aGlzLl9mdWxsV2Vla2RheXNQYXJzZVtpXSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2Z1bGxXZWVrZGF5c1BhcnNlW2ldID0gbmV3IFJlZ0V4cChcbiAgICAgICAgICAgICAgICAgICAgJ14nICsgdGhpcy53ZWVrZGF5cyhtb20sICcnKS5yZXBsYWNlKCcuJywgJ1xcXFwuPycpICsgJyQnLFxuICAgICAgICAgICAgICAgICAgICAnaSdcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZVtpXSA9IG5ldyBSZWdFeHAoXG4gICAgICAgICAgICAgICAgICAgICdeJyArIHRoaXMud2Vla2RheXNTaG9ydChtb20sICcnKS5yZXBsYWNlKCcuJywgJ1xcXFwuPycpICsgJyQnLFxuICAgICAgICAgICAgICAgICAgICAnaSdcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHRoaXMuX21pbldlZWtkYXlzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKFxuICAgICAgICAgICAgICAgICAgICAnXicgKyB0aGlzLndlZWtkYXlzTWluKG1vbSwgJycpLnJlcGxhY2UoJy4nLCAnXFxcXC4/JykgKyAnJCcsXG4gICAgICAgICAgICAgICAgICAgICdpJ1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMuX3dlZWtkYXlzUGFyc2VbaV0pIHtcbiAgICAgICAgICAgICAgICByZWdleCA9XG4gICAgICAgICAgICAgICAgICAgICdeJyArXG4gICAgICAgICAgICAgICAgICAgIHRoaXMud2Vla2RheXMobW9tLCAnJykgK1xuICAgICAgICAgICAgICAgICAgICAnfF4nICtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy53ZWVrZGF5c1Nob3J0KG1vbSwgJycpICtcbiAgICAgICAgICAgICAgICAgICAgJ3xeJyArXG4gICAgICAgICAgICAgICAgICAgIHRoaXMud2Vla2RheXNNaW4obW9tLCAnJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNQYXJzZVtpXSA9IG5ldyBSZWdFeHAocmVnZXgucmVwbGFjZSgnLicsICcnKSwgJ2knKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHRlc3QgdGhlIHJlZ2V4XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgc3RyaWN0ICYmXG4gICAgICAgICAgICAgICAgZm9ybWF0ID09PSAnZGRkZCcgJiZcbiAgICAgICAgICAgICAgICB0aGlzLl9mdWxsV2Vla2RheXNQYXJzZVtpXS50ZXN0KHdlZWtkYXlOYW1lKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgICAgIHN0cmljdCAmJlxuICAgICAgICAgICAgICAgIGZvcm1hdCA9PT0gJ2RkZCcgJiZcbiAgICAgICAgICAgICAgICB0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2VbaV0udGVzdCh3ZWVrZGF5TmFtZSlcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgICAgICBzdHJpY3QgJiZcbiAgICAgICAgICAgICAgICBmb3JtYXQgPT09ICdkZCcgJiZcbiAgICAgICAgICAgICAgICB0aGlzLl9taW5XZWVrZGF5c1BhcnNlW2ldLnRlc3Qod2Vla2RheU5hbWUpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIXN0cmljdCAmJiB0aGlzLl93ZWVrZGF5c1BhcnNlW2ldLnRlc3Qod2Vla2RheU5hbWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICBmdW5jdGlvbiBnZXRTZXREYXlPZldlZWsoaW5wdXQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0ICE9IG51bGwgPyB0aGlzIDogTmFOO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkYXkgPSB0aGlzLl9pc1VUQyA/IHRoaXMuX2QuZ2V0VVRDRGF5KCkgOiB0aGlzLl9kLmdldERheSgpO1xuICAgICAgICBpZiAoaW5wdXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgaW5wdXQgPSBwYXJzZVdlZWtkYXkoaW5wdXQsIHRoaXMubG9jYWxlRGF0YSgpKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZChpbnB1dCAtIGRheSwgJ2QnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBkYXk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTZXRMb2NhbGVEYXlPZldlZWsoaW5wdXQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0ICE9IG51bGwgPyB0aGlzIDogTmFOO1xuICAgICAgICB9XG4gICAgICAgIHZhciB3ZWVrZGF5ID0gKHRoaXMuZGF5KCkgKyA3IC0gdGhpcy5sb2NhbGVEYXRhKCkuX3dlZWsuZG93KSAlIDc7XG4gICAgICAgIHJldHVybiBpbnB1dCA9PSBudWxsID8gd2Vla2RheSA6IHRoaXMuYWRkKGlucHV0IC0gd2Vla2RheSwgJ2QnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTZXRJU09EYXlPZldlZWsoaW5wdXQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0ICE9IG51bGwgPyB0aGlzIDogTmFOO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYmVoYXZlcyB0aGUgc2FtZSBhcyBtb21lbnQjZGF5IGV4Y2VwdFxuICAgICAgICAvLyBhcyBhIGdldHRlciwgcmV0dXJucyA3IGluc3RlYWQgb2YgMCAoMS03IHJhbmdlIGluc3RlYWQgb2YgMC02KVxuICAgICAgICAvLyBhcyBhIHNldHRlciwgc3VuZGF5IHNob3VsZCBiZWxvbmcgdG8gdGhlIHByZXZpb3VzIHdlZWsuXG5cbiAgICAgICAgaWYgKGlucHV0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHZhciB3ZWVrZGF5ID0gcGFyc2VJc29XZWVrZGF5KGlucHV0LCB0aGlzLmxvY2FsZURhdGEoKSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXkodGhpcy5kYXkoKSAlIDcgPyB3ZWVrZGF5IDogd2Vla2RheSAtIDcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF5KCkgfHwgNztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHdlZWtkYXlzUmVnZXgoaXNTdHJpY3QpIHtcbiAgICAgICAgaWYgKHRoaXMuX3dlZWtkYXlzUGFyc2VFeGFjdCkge1xuICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfd2Vla2RheXNSZWdleCcpKSB7XG4gICAgICAgICAgICAgICAgY29tcHV0ZVdlZWtkYXlzUGFyc2UuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1N0cmljdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c1N0cmljdFJlZ2V4O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNSZWdleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX3dlZWtkYXlzUmVnZXgnKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzUmVnZXggPSBkZWZhdWx0V2Vla2RheXNSZWdleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c1N0cmljdFJlZ2V4ICYmIGlzU3RyaWN0XG4gICAgICAgICAgICAgICAgPyB0aGlzLl93ZWVrZGF5c1N0cmljdFJlZ2V4XG4gICAgICAgICAgICAgICAgOiB0aGlzLl93ZWVrZGF5c1JlZ2V4O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gd2Vla2RheXNTaG9ydFJlZ2V4KGlzU3RyaWN0KSB7XG4gICAgICAgIGlmICh0aGlzLl93ZWVrZGF5c1BhcnNlRXhhY3QpIHtcbiAgICAgICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX3dlZWtkYXlzUmVnZXgnKSkge1xuICAgICAgICAgICAgICAgIGNvbXB1dGVXZWVrZGF5c1BhcnNlLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNTdHJpY3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNTaG9ydFN0cmljdFJlZ2V4O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNTaG9ydFJlZ2V4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfd2Vla2RheXNTaG9ydFJlZ2V4JykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1Nob3J0UmVnZXggPSBkZWZhdWx0V2Vla2RheXNTaG9ydFJlZ2V4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzU2hvcnRTdHJpY3RSZWdleCAmJiBpc1N0cmljdFxuICAgICAgICAgICAgICAgID8gdGhpcy5fd2Vla2RheXNTaG9ydFN0cmljdFJlZ2V4XG4gICAgICAgICAgICAgICAgOiB0aGlzLl93ZWVrZGF5c1Nob3J0UmVnZXg7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB3ZWVrZGF5c01pblJlZ2V4KGlzU3RyaWN0KSB7XG4gICAgICAgIGlmICh0aGlzLl93ZWVrZGF5c1BhcnNlRXhhY3QpIHtcbiAgICAgICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX3dlZWtkYXlzUmVnZXgnKSkge1xuICAgICAgICAgICAgICAgIGNvbXB1dGVXZWVrZGF5c1BhcnNlLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNTdHJpY3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNNaW5TdHJpY3RSZWdleDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzTWluUmVnZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ193ZWVrZGF5c01pblJlZ2V4JykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl93ZWVrZGF5c01pblJlZ2V4ID0gZGVmYXVsdFdlZWtkYXlzTWluUmVnZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNNaW5TdHJpY3RSZWdleCAmJiBpc1N0cmljdFxuICAgICAgICAgICAgICAgID8gdGhpcy5fd2Vla2RheXNNaW5TdHJpY3RSZWdleFxuICAgICAgICAgICAgICAgIDogdGhpcy5fd2Vla2RheXNNaW5SZWdleDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbXB1dGVXZWVrZGF5c1BhcnNlKCkge1xuICAgICAgICBmdW5jdGlvbiBjbXBMZW5SZXYoYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIGIubGVuZ3RoIC0gYS5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbWluUGllY2VzID0gW10sXG4gICAgICAgICAgICBzaG9ydFBpZWNlcyA9IFtdLFxuICAgICAgICAgICAgbG9uZ1BpZWNlcyA9IFtdLFxuICAgICAgICAgICAgbWl4ZWRQaWVjZXMgPSBbXSxcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICBtb20sXG4gICAgICAgICAgICBtaW5wLFxuICAgICAgICAgICAgc2hvcnRwLFxuICAgICAgICAgICAgbG9uZ3A7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCA3OyBpKyspIHtcbiAgICAgICAgICAgIC8vIG1ha2UgdGhlIHJlZ2V4IGlmIHdlIGRvbid0IGhhdmUgaXQgYWxyZWFkeVxuICAgICAgICAgICAgbW9tID0gY3JlYXRlVVRDKFsyMDAwLCAxXSkuZGF5KGkpO1xuICAgICAgICAgICAgbWlucCA9IHJlZ2V4RXNjYXBlKHRoaXMud2Vla2RheXNNaW4obW9tLCAnJykpO1xuICAgICAgICAgICAgc2hvcnRwID0gcmVnZXhFc2NhcGUodGhpcy53ZWVrZGF5c1Nob3J0KG1vbSwgJycpKTtcbiAgICAgICAgICAgIGxvbmdwID0gcmVnZXhFc2NhcGUodGhpcy53ZWVrZGF5cyhtb20sICcnKSk7XG4gICAgICAgICAgICBtaW5QaWVjZXMucHVzaChtaW5wKTtcbiAgICAgICAgICAgIHNob3J0UGllY2VzLnB1c2goc2hvcnRwKTtcbiAgICAgICAgICAgIGxvbmdQaWVjZXMucHVzaChsb25ncCk7XG4gICAgICAgICAgICBtaXhlZFBpZWNlcy5wdXNoKG1pbnApO1xuICAgICAgICAgICAgbWl4ZWRQaWVjZXMucHVzaChzaG9ydHApO1xuICAgICAgICAgICAgbWl4ZWRQaWVjZXMucHVzaChsb25ncCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU29ydGluZyBtYWtlcyBzdXJlIGlmIG9uZSB3ZWVrZGF5IChvciBhYmJyKSBpcyBhIHByZWZpeCBvZiBhbm90aGVyIGl0XG4gICAgICAgIC8vIHdpbGwgbWF0Y2ggdGhlIGxvbmdlciBwaWVjZS5cbiAgICAgICAgbWluUGllY2VzLnNvcnQoY21wTGVuUmV2KTtcbiAgICAgICAgc2hvcnRQaWVjZXMuc29ydChjbXBMZW5SZXYpO1xuICAgICAgICBsb25nUGllY2VzLnNvcnQoY21wTGVuUmV2KTtcbiAgICAgICAgbWl4ZWRQaWVjZXMuc29ydChjbXBMZW5SZXYpO1xuXG4gICAgICAgIHRoaXMuX3dlZWtkYXlzUmVnZXggPSBuZXcgUmVnRXhwKCdeKCcgKyBtaXhlZFBpZWNlcy5qb2luKCd8JykgKyAnKScsICdpJyk7XG4gICAgICAgIHRoaXMuX3dlZWtkYXlzU2hvcnRSZWdleCA9IHRoaXMuX3dlZWtkYXlzUmVnZXg7XG4gICAgICAgIHRoaXMuX3dlZWtkYXlzTWluUmVnZXggPSB0aGlzLl93ZWVrZGF5c1JlZ2V4O1xuXG4gICAgICAgIHRoaXMuX3dlZWtkYXlzU3RyaWN0UmVnZXggPSBuZXcgUmVnRXhwKFxuICAgICAgICAgICAgJ14oJyArIGxvbmdQaWVjZXMuam9pbignfCcpICsgJyknLFxuICAgICAgICAgICAgJ2knXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuX3dlZWtkYXlzU2hvcnRTdHJpY3RSZWdleCA9IG5ldyBSZWdFeHAoXG4gICAgICAgICAgICAnXignICsgc2hvcnRQaWVjZXMuam9pbignfCcpICsgJyknLFxuICAgICAgICAgICAgJ2knXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuX3dlZWtkYXlzTWluU3RyaWN0UmVnZXggPSBuZXcgUmVnRXhwKFxuICAgICAgICAgICAgJ14oJyArIG1pblBpZWNlcy5qb2luKCd8JykgKyAnKScsXG4gICAgICAgICAgICAnaSdcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBmdW5jdGlvbiBoRm9ybWF0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ob3VycygpICUgMTIgfHwgMTI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24ga0Zvcm1hdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaG91cnMoKSB8fCAyNDtcbiAgICB9XG5cbiAgICBhZGRGb3JtYXRUb2tlbignSCcsIFsnSEgnLCAyXSwgMCwgJ2hvdXInKTtcbiAgICBhZGRGb3JtYXRUb2tlbignaCcsIFsnaGgnLCAyXSwgMCwgaEZvcm1hdCk7XG4gICAgYWRkRm9ybWF0VG9rZW4oJ2snLCBbJ2trJywgMl0sIDAsIGtGb3JtYXQpO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ2htbScsIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICcnICsgaEZvcm1hdC5hcHBseSh0aGlzKSArIHplcm9GaWxsKHRoaXMubWludXRlcygpLCAyKTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdobW1zcycsIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICcnICtcbiAgICAgICAgICAgIGhGb3JtYXQuYXBwbHkodGhpcykgK1xuICAgICAgICAgICAgemVyb0ZpbGwodGhpcy5taW51dGVzKCksIDIpICtcbiAgICAgICAgICAgIHplcm9GaWxsKHRoaXMuc2Vjb25kcygpLCAyKVxuICAgICAgICApO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ0htbScsIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICcnICsgdGhpcy5ob3VycygpICsgemVyb0ZpbGwodGhpcy5taW51dGVzKCksIDIpO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ0htbXNzJywgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgJycgK1xuICAgICAgICAgICAgdGhpcy5ob3VycygpICtcbiAgICAgICAgICAgIHplcm9GaWxsKHRoaXMubWludXRlcygpLCAyKSArXG4gICAgICAgICAgICB6ZXJvRmlsbCh0aGlzLnNlY29uZHMoKSwgMilcbiAgICAgICAgKTtcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIG1lcmlkaWVtKHRva2VuLCBsb3dlcmNhc2UpIHtcbiAgICAgICAgYWRkRm9ybWF0VG9rZW4odG9rZW4sIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5tZXJpZGllbShcbiAgICAgICAgICAgICAgICB0aGlzLmhvdXJzKCksXG4gICAgICAgICAgICAgICAgdGhpcy5taW51dGVzKCksXG4gICAgICAgICAgICAgICAgbG93ZXJjYXNlXG4gICAgICAgICAgICApO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBtZXJpZGllbSgnYScsIHRydWUpO1xuICAgIG1lcmlkaWVtKCdBJywgZmFsc2UpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCdob3VyJywgJ2gnKTtcblxuICAgIC8vIFBSSU9SSVRZXG4gICAgYWRkVW5pdFByaW9yaXR5KCdob3VyJywgMTMpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgZnVuY3Rpb24gbWF0Y2hNZXJpZGllbShpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGUuX21lcmlkaWVtUGFyc2U7XG4gICAgfVxuXG4gICAgYWRkUmVnZXhUb2tlbignYScsIG1hdGNoTWVyaWRpZW0pO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0EnLCBtYXRjaE1lcmlkaWVtKTtcbiAgICBhZGRSZWdleFRva2VuKCdIJywgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdoJywgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdrJywgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdISCcsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdoaCcsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdraycsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ2htbScsIG1hdGNoM3RvNCk7XG4gICAgYWRkUmVnZXhUb2tlbignaG1tc3MnLCBtYXRjaDV0bzYpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0htbScsIG1hdGNoM3RvNCk7XG4gICAgYWRkUmVnZXhUb2tlbignSG1tc3MnLCBtYXRjaDV0bzYpO1xuXG4gICAgYWRkUGFyc2VUb2tlbihbJ0gnLCAnSEgnXSwgSE9VUik7XG4gICAgYWRkUGFyc2VUb2tlbihbJ2snLCAna2snXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIHZhciBrSW5wdXQgPSB0b0ludChpbnB1dCk7XG4gICAgICAgIGFycmF5W0hPVVJdID0ga0lucHV0ID09PSAyNCA/IDAgOiBrSW5wdXQ7XG4gICAgfSk7XG4gICAgYWRkUGFyc2VUb2tlbihbJ2EnLCAnQSddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgY29uZmlnLl9pc1BtID0gY29uZmlnLl9sb2NhbGUuaXNQTShpbnB1dCk7XG4gICAgICAgIGNvbmZpZy5fbWVyaWRpZW0gPSBpbnB1dDtcbiAgICB9KTtcbiAgICBhZGRQYXJzZVRva2VuKFsnaCcsICdoaCddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgYXJyYXlbSE9VUl0gPSB0b0ludChpbnB1dCk7XG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmJpZ0hvdXIgPSB0cnVlO1xuICAgIH0pO1xuICAgIGFkZFBhcnNlVG9rZW4oJ2htbScsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICB2YXIgcG9zID0gaW5wdXQubGVuZ3RoIC0gMjtcbiAgICAgICAgYXJyYXlbSE9VUl0gPSB0b0ludChpbnB1dC5zdWJzdHIoMCwgcG9zKSk7XG4gICAgICAgIGFycmF5W01JTlVURV0gPSB0b0ludChpbnB1dC5zdWJzdHIocG9zKSk7XG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmJpZ0hvdXIgPSB0cnVlO1xuICAgIH0pO1xuICAgIGFkZFBhcnNlVG9rZW4oJ2htbXNzJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIHZhciBwb3MxID0gaW5wdXQubGVuZ3RoIC0gNCxcbiAgICAgICAgICAgIHBvczIgPSBpbnB1dC5sZW5ndGggLSAyO1xuICAgICAgICBhcnJheVtIT1VSXSA9IHRvSW50KGlucHV0LnN1YnN0cigwLCBwb3MxKSk7XG4gICAgICAgIGFycmF5W01JTlVURV0gPSB0b0ludChpbnB1dC5zdWJzdHIocG9zMSwgMikpO1xuICAgICAgICBhcnJheVtTRUNPTkRdID0gdG9JbnQoaW5wdXQuc3Vic3RyKHBvczIpKTtcbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuYmlnSG91ciA9IHRydWU7XG4gICAgfSk7XG4gICAgYWRkUGFyc2VUb2tlbignSG1tJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIHZhciBwb3MgPSBpbnB1dC5sZW5ndGggLSAyO1xuICAgICAgICBhcnJheVtIT1VSXSA9IHRvSW50KGlucHV0LnN1YnN0cigwLCBwb3MpKTtcbiAgICAgICAgYXJyYXlbTUlOVVRFXSA9IHRvSW50KGlucHV0LnN1YnN0cihwb3MpKTtcbiAgICB9KTtcbiAgICBhZGRQYXJzZVRva2VuKCdIbW1zcycsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICB2YXIgcG9zMSA9IGlucHV0Lmxlbmd0aCAtIDQsXG4gICAgICAgICAgICBwb3MyID0gaW5wdXQubGVuZ3RoIC0gMjtcbiAgICAgICAgYXJyYXlbSE9VUl0gPSB0b0ludChpbnB1dC5zdWJzdHIoMCwgcG9zMSkpO1xuICAgICAgICBhcnJheVtNSU5VVEVdID0gdG9JbnQoaW5wdXQuc3Vic3RyKHBvczEsIDIpKTtcbiAgICAgICAgYXJyYXlbU0VDT05EXSA9IHRvSW50KGlucHV0LnN1YnN0cihwb3MyKSk7XG4gICAgfSk7XG5cbiAgICAvLyBMT0NBTEVTXG5cbiAgICBmdW5jdGlvbiBsb2NhbGVJc1BNKGlucHV0KSB7XG4gICAgICAgIC8vIElFOCBRdWlya3MgTW9kZSAmIElFNyBTdGFuZGFyZHMgTW9kZSBkbyBub3QgYWxsb3cgYWNjZXNzaW5nIHN0cmluZ3MgbGlrZSBhcnJheXNcbiAgICAgICAgLy8gVXNpbmcgY2hhckF0IHNob3VsZCBiZSBtb3JlIGNvbXBhdGlibGUuXG4gICAgICAgIHJldHVybiAoaW5wdXQgKyAnJykudG9Mb3dlckNhc2UoKS5jaGFyQXQoMCkgPT09ICdwJztcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdExvY2FsZU1lcmlkaWVtUGFyc2UgPSAvW2FwXVxcLj9tP1xcLj8vaSxcbiAgICAgICAgLy8gU2V0dGluZyB0aGUgaG91ciBzaG91bGQga2VlcCB0aGUgdGltZSwgYmVjYXVzZSB0aGUgdXNlciBleHBsaWNpdGx5XG4gICAgICAgIC8vIHNwZWNpZmllZCB3aGljaCBob3VyIHRoZXkgd2FudC4gU28gdHJ5aW5nIHRvIG1haW50YWluIHRoZSBzYW1lIGhvdXIgKGluXG4gICAgICAgIC8vIGEgbmV3IHRpbWV6b25lKSBtYWtlcyBzZW5zZS4gQWRkaW5nL3N1YnRyYWN0aW5nIGhvdXJzIGRvZXMgbm90IGZvbGxvd1xuICAgICAgICAvLyB0aGlzIHJ1bGUuXG4gICAgICAgIGdldFNldEhvdXIgPSBtYWtlR2V0U2V0KCdIb3VycycsIHRydWUpO1xuXG4gICAgZnVuY3Rpb24gbG9jYWxlTWVyaWRpZW0oaG91cnMsIG1pbnV0ZXMsIGlzTG93ZXIpIHtcbiAgICAgICAgaWYgKGhvdXJzID4gMTEpIHtcbiAgICAgICAgICAgIHJldHVybiBpc0xvd2VyID8gJ3BtJyA6ICdQTSc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gaXNMb3dlciA/ICdhbScgOiAnQU0nO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGJhc2VDb25maWcgPSB7XG4gICAgICAgIGNhbGVuZGFyOiBkZWZhdWx0Q2FsZW5kYXIsXG4gICAgICAgIGxvbmdEYXRlRm9ybWF0OiBkZWZhdWx0TG9uZ0RhdGVGb3JtYXQsXG4gICAgICAgIGludmFsaWREYXRlOiBkZWZhdWx0SW52YWxpZERhdGUsXG4gICAgICAgIG9yZGluYWw6IGRlZmF1bHRPcmRpbmFsLFxuICAgICAgICBkYXlPZk1vbnRoT3JkaW5hbFBhcnNlOiBkZWZhdWx0RGF5T2ZNb250aE9yZGluYWxQYXJzZSxcbiAgICAgICAgcmVsYXRpdmVUaW1lOiBkZWZhdWx0UmVsYXRpdmVUaW1lLFxuXG4gICAgICAgIG1vbnRoczogZGVmYXVsdExvY2FsZU1vbnRocyxcbiAgICAgICAgbW9udGhzU2hvcnQ6IGRlZmF1bHRMb2NhbGVNb250aHNTaG9ydCxcblxuICAgICAgICB3ZWVrOiBkZWZhdWx0TG9jYWxlV2VlayxcblxuICAgICAgICB3ZWVrZGF5czogZGVmYXVsdExvY2FsZVdlZWtkYXlzLFxuICAgICAgICB3ZWVrZGF5c01pbjogZGVmYXVsdExvY2FsZVdlZWtkYXlzTWluLFxuICAgICAgICB3ZWVrZGF5c1Nob3J0OiBkZWZhdWx0TG9jYWxlV2Vla2RheXNTaG9ydCxcblxuICAgICAgICBtZXJpZGllbVBhcnNlOiBkZWZhdWx0TG9jYWxlTWVyaWRpZW1QYXJzZSxcbiAgICB9O1xuXG4gICAgLy8gaW50ZXJuYWwgc3RvcmFnZSBmb3IgbG9jYWxlIGNvbmZpZyBmaWxlc1xuICAgIHZhciBsb2NhbGVzID0ge30sXG4gICAgICAgIGxvY2FsZUZhbWlsaWVzID0ge30sXG4gICAgICAgIGdsb2JhbExvY2FsZTtcblxuICAgIGZ1bmN0aW9uIGNvbW1vblByZWZpeChhcnIxLCBhcnIyKSB7XG4gICAgICAgIHZhciBpLFxuICAgICAgICAgICAgbWlubCA9IE1hdGgubWluKGFycjEubGVuZ3RoLCBhcnIyLmxlbmd0aCk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBtaW5sOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGlmIChhcnIxW2ldICE9PSBhcnIyW2ldKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1pbmw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbm9ybWFsaXplTG9jYWxlKGtleSkge1xuICAgICAgICByZXR1cm4ga2V5ID8ga2V5LnRvTG93ZXJDYXNlKCkucmVwbGFjZSgnXycsICctJykgOiBrZXk7XG4gICAgfVxuXG4gICAgLy8gcGljayB0aGUgbG9jYWxlIGZyb20gdGhlIGFycmF5XG4gICAgLy8gdHJ5IFsnZW4tYXUnLCAnZW4tZ2InXSBhcyAnZW4tYXUnLCAnZW4tZ2InLCAnZW4nLCBhcyBpbiBtb3ZlIHRocm91Z2ggdGhlIGxpc3QgdHJ5aW5nIGVhY2hcbiAgICAvLyBzdWJzdHJpbmcgZnJvbSBtb3N0IHNwZWNpZmljIHRvIGxlYXN0LCBidXQgbW92ZSB0byB0aGUgbmV4dCBhcnJheSBpdGVtIGlmIGl0J3MgYSBtb3JlIHNwZWNpZmljIHZhcmlhbnQgdGhhbiB0aGUgY3VycmVudCByb290XG4gICAgZnVuY3Rpb24gY2hvb3NlTG9jYWxlKG5hbWVzKSB7XG4gICAgICAgIHZhciBpID0gMCxcbiAgICAgICAgICAgIGosXG4gICAgICAgICAgICBuZXh0LFxuICAgICAgICAgICAgbG9jYWxlLFxuICAgICAgICAgICAgc3BsaXQ7XG5cbiAgICAgICAgd2hpbGUgKGkgPCBuYW1lcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHNwbGl0ID0gbm9ybWFsaXplTG9jYWxlKG5hbWVzW2ldKS5zcGxpdCgnLScpO1xuICAgICAgICAgICAgaiA9IHNwbGl0Lmxlbmd0aDtcbiAgICAgICAgICAgIG5leHQgPSBub3JtYWxpemVMb2NhbGUobmFtZXNbaSArIDFdKTtcbiAgICAgICAgICAgIG5leHQgPSBuZXh0ID8gbmV4dC5zcGxpdCgnLScpIDogbnVsbDtcbiAgICAgICAgICAgIHdoaWxlIChqID4gMCkge1xuICAgICAgICAgICAgICAgIGxvY2FsZSA9IGxvYWRMb2NhbGUoc3BsaXQuc2xpY2UoMCwgaikuam9pbignLScpKTtcbiAgICAgICAgICAgICAgICBpZiAobG9jYWxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBsb2NhbGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgbmV4dCAmJlxuICAgICAgICAgICAgICAgICAgICBuZXh0Lmxlbmd0aCA+PSBqICYmXG4gICAgICAgICAgICAgICAgICAgIGNvbW1vblByZWZpeChzcGxpdCwgbmV4dCkgPj0gaiAtIDFcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgLy90aGUgbmV4dCBhcnJheSBpdGVtIGlzIGJldHRlciB0aGFuIGEgc2hhbGxvd2VyIHN1YnN0cmluZyBvZiB0aGlzIG9uZVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgai0tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBnbG9iYWxMb2NhbGU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9hZExvY2FsZShuYW1lKSB7XG4gICAgICAgIHZhciBvbGRMb2NhbGUgPSBudWxsLFxuICAgICAgICAgICAgYWxpYXNlZFJlcXVpcmU7XG4gICAgICAgIC8vIFRPRE86IEZpbmQgYSBiZXR0ZXIgd2F5IHRvIHJlZ2lzdGVyIGFuZCBsb2FkIGFsbCB0aGUgbG9jYWxlcyBpbiBOb2RlXG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIGxvY2FsZXNbbmFtZV0gPT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgIG1vZHVsZSAmJlxuICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHNcbiAgICAgICAgKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIG9sZExvY2FsZSA9IGdsb2JhbExvY2FsZS5fYWJicjtcbiAgICAgICAgICAgICAgICBhbGlhc2VkUmVxdWlyZSA9IHJlcXVpcmU7XG4gICAgICAgICAgICAgICAgYWxpYXNlZFJlcXVpcmUoJy4vbG9jYWxlLycgKyBuYW1lKTtcbiAgICAgICAgICAgICAgICBnZXRTZXRHbG9iYWxMb2NhbGUob2xkTG9jYWxlKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAvLyBtYXJrIGFzIG5vdCBmb3VuZCB0byBhdm9pZCByZXBlYXRpbmcgZXhwZW5zaXZlIGZpbGUgcmVxdWlyZSBjYWxsIGNhdXNpbmcgaGlnaCBDUFVcbiAgICAgICAgICAgICAgICAvLyB3aGVuIHRyeWluZyB0byBmaW5kIGVuLVVTLCBlbl9VUywgZW4tdXMgZm9yIGV2ZXJ5IGZvcm1hdCBjYWxsXG4gICAgICAgICAgICAgICAgbG9jYWxlc1tuYW1lXSA9IG51bGw7IC8vIG51bGwgbWVhbnMgbm90IGZvdW5kXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxvY2FsZXNbbmFtZV07XG4gICAgfVxuXG4gICAgLy8gVGhpcyBmdW5jdGlvbiB3aWxsIGxvYWQgbG9jYWxlIGFuZCB0aGVuIHNldCB0aGUgZ2xvYmFsIGxvY2FsZS4gIElmXG4gICAgLy8gbm8gYXJndW1lbnRzIGFyZSBwYXNzZWQgaW4sIGl0IHdpbGwgc2ltcGx5IHJldHVybiB0aGUgY3VycmVudCBnbG9iYWxcbiAgICAvLyBsb2NhbGUga2V5LlxuICAgIGZ1bmN0aW9uIGdldFNldEdsb2JhbExvY2FsZShrZXksIHZhbHVlcykge1xuICAgICAgICB2YXIgZGF0YTtcbiAgICAgICAgaWYgKGtleSkge1xuICAgICAgICAgICAgaWYgKGlzVW5kZWZpbmVkKHZhbHVlcykpIHtcbiAgICAgICAgICAgICAgICBkYXRhID0gZ2V0TG9jYWxlKGtleSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRhdGEgPSBkZWZpbmVMb2NhbGUoa2V5LCB2YWx1ZXMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgICAgICAgIC8vIG1vbWVudC5kdXJhdGlvbi5fbG9jYWxlID0gbW9tZW50Ll9sb2NhbGUgPSBkYXRhO1xuICAgICAgICAgICAgICAgIGdsb2JhbExvY2FsZSA9IGRhdGE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiYgY29uc29sZS53YXJuKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vd2FybiB1c2VyIGlmIGFyZ3VtZW50cyBhcmUgcGFzc2VkIGJ1dCB0aGUgbG9jYWxlIGNvdWxkIG5vdCBiZSBzZXRcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0xvY2FsZSAnICsga2V5ICsgJyBub3QgZm91bmQuIERpZCB5b3UgZm9yZ2V0IHRvIGxvYWQgaXQ/J1xuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBnbG9iYWxMb2NhbGUuX2FiYnI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGVmaW5lTG9jYWxlKG5hbWUsIGNvbmZpZykge1xuICAgICAgICBpZiAoY29uZmlnICE9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgbG9jYWxlLFxuICAgICAgICAgICAgICAgIHBhcmVudENvbmZpZyA9IGJhc2VDb25maWc7XG4gICAgICAgICAgICBjb25maWcuYWJiciA9IG5hbWU7XG4gICAgICAgICAgICBpZiAobG9jYWxlc1tuYW1lXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZGVwcmVjYXRlU2ltcGxlKFxuICAgICAgICAgICAgICAgICAgICAnZGVmaW5lTG9jYWxlT3ZlcnJpZGUnLFxuICAgICAgICAgICAgICAgICAgICAndXNlIG1vbWVudC51cGRhdGVMb2NhbGUobG9jYWxlTmFtZSwgY29uZmlnKSB0byBjaGFuZ2UgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnYW4gZXhpc3RpbmcgbG9jYWxlLiBtb21lbnQuZGVmaW5lTG9jYWxlKGxvY2FsZU5hbWUsICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2NvbmZpZykgc2hvdWxkIG9ubHkgYmUgdXNlZCBmb3IgY3JlYXRpbmcgYSBuZXcgbG9jYWxlICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ1NlZSBodHRwOi8vbW9tZW50anMuY29tL2d1aWRlcy8jL3dhcm5pbmdzL2RlZmluZS1sb2NhbGUvIGZvciBtb3JlIGluZm8uJ1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgcGFyZW50Q29uZmlnID0gbG9jYWxlc1tuYW1lXS5fY29uZmlnO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjb25maWcucGFyZW50TG9jYWxlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAobG9jYWxlc1tjb25maWcucGFyZW50TG9jYWxlXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmVudENvbmZpZyA9IGxvY2FsZXNbY29uZmlnLnBhcmVudExvY2FsZV0uX2NvbmZpZztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsb2NhbGUgPSBsb2FkTG9jYWxlKGNvbmZpZy5wYXJlbnRMb2NhbGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobG9jYWxlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudENvbmZpZyA9IGxvY2FsZS5fY29uZmlnO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFsb2NhbGVGYW1pbGllc1tjb25maWcucGFyZW50TG9jYWxlXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsZUZhbWlsaWVzW2NvbmZpZy5wYXJlbnRMb2NhbGVdID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhbGVGYW1pbGllc1tjb25maWcucGFyZW50TG9jYWxlXS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZzogY29uZmlnLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvY2FsZXNbbmFtZV0gPSBuZXcgTG9jYWxlKG1lcmdlQ29uZmlncyhwYXJlbnRDb25maWcsIGNvbmZpZykpO1xuXG4gICAgICAgICAgICBpZiAobG9jYWxlRmFtaWxpZXNbbmFtZV0pIHtcbiAgICAgICAgICAgICAgICBsb2NhbGVGYW1pbGllc1tuYW1lXS5mb3JFYWNoKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICAgICAgICAgIGRlZmluZUxvY2FsZSh4Lm5hbWUsIHguY29uZmlnKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gYmFja3dhcmRzIGNvbXBhdCBmb3Igbm93OiBhbHNvIHNldCB0aGUgbG9jYWxlXG4gICAgICAgICAgICAvLyBtYWtlIHN1cmUgd2Ugc2V0IHRoZSBsb2NhbGUgQUZURVIgYWxsIGNoaWxkIGxvY2FsZXMgaGF2ZSBiZWVuXG4gICAgICAgICAgICAvLyBjcmVhdGVkLCBzbyB3ZSB3b24ndCBlbmQgdXAgd2l0aCB0aGUgY2hpbGQgbG9jYWxlIHNldC5cbiAgICAgICAgICAgIGdldFNldEdsb2JhbExvY2FsZShuYW1lKTtcblxuICAgICAgICAgICAgcmV0dXJuIGxvY2FsZXNbbmFtZV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyB1c2VmdWwgZm9yIHRlc3RpbmdcbiAgICAgICAgICAgIGRlbGV0ZSBsb2NhbGVzW25hbWVdO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1cGRhdGVMb2NhbGUobmFtZSwgY29uZmlnKSB7XG4gICAgICAgIGlmIChjb25maWcgIT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIGxvY2FsZSxcbiAgICAgICAgICAgICAgICB0bXBMb2NhbGUsXG4gICAgICAgICAgICAgICAgcGFyZW50Q29uZmlnID0gYmFzZUNvbmZpZztcblxuICAgICAgICAgICAgaWYgKGxvY2FsZXNbbmFtZV0gIT0gbnVsbCAmJiBsb2NhbGVzW25hbWVdLnBhcmVudExvY2FsZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIGV4aXN0aW5nIGNoaWxkIGxvY2FsZSBpbi1wbGFjZSB0byBhdm9pZCBtZW1vcnktbGVha3NcbiAgICAgICAgICAgICAgICBsb2NhbGVzW25hbWVdLnNldChtZXJnZUNvbmZpZ3MobG9jYWxlc1tuYW1lXS5fY29uZmlnLCBjb25maWcpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gTUVSR0VcbiAgICAgICAgICAgICAgICB0bXBMb2NhbGUgPSBsb2FkTG9jYWxlKG5hbWUpO1xuICAgICAgICAgICAgICAgIGlmICh0bXBMb2NhbGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnRDb25maWcgPSB0bXBMb2NhbGUuX2NvbmZpZztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uZmlnID0gbWVyZ2VDb25maWdzKHBhcmVudENvbmZpZywgY29uZmlnKTtcbiAgICAgICAgICAgICAgICBpZiAodG1wTG9jYWxlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdXBkYXRlTG9jYWxlIGlzIGNhbGxlZCBmb3IgY3JlYXRpbmcgYSBuZXcgbG9jYWxlXG4gICAgICAgICAgICAgICAgICAgIC8vIFNldCBhYmJyIHNvIGl0IHdpbGwgaGF2ZSBhIG5hbWUgKGdldHRlcnMgcmV0dXJuXG4gICAgICAgICAgICAgICAgICAgIC8vIHVuZGVmaW5lZCBvdGhlcndpc2UpLlxuICAgICAgICAgICAgICAgICAgICBjb25maWcuYWJiciA9IG5hbWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxvY2FsZSA9IG5ldyBMb2NhbGUoY29uZmlnKTtcbiAgICAgICAgICAgICAgICBsb2NhbGUucGFyZW50TG9jYWxlID0gbG9jYWxlc1tuYW1lXTtcbiAgICAgICAgICAgICAgICBsb2NhbGVzW25hbWVdID0gbG9jYWxlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBiYWNrd2FyZHMgY29tcGF0IGZvciBub3c6IGFsc28gc2V0IHRoZSBsb2NhbGVcbiAgICAgICAgICAgIGdldFNldEdsb2JhbExvY2FsZShuYW1lKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHBhc3MgbnVsbCBmb3IgY29uZmlnIHRvIHVudXBkYXRlLCB1c2VmdWwgZm9yIHRlc3RzXG4gICAgICAgICAgICBpZiAobG9jYWxlc1tuYW1lXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxvY2FsZXNbbmFtZV0ucGFyZW50TG9jYWxlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxlc1tuYW1lXSA9IGxvY2FsZXNbbmFtZV0ucGFyZW50TG9jYWxlO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmFtZSA9PT0gZ2V0U2V0R2xvYmFsTG9jYWxlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldFNldEdsb2JhbExvY2FsZShuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobG9jYWxlc1tuYW1lXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBsb2NhbGVzW25hbWVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbG9jYWxlc1tuYW1lXTtcbiAgICB9XG5cbiAgICAvLyByZXR1cm5zIGxvY2FsZSBkYXRhXG4gICAgZnVuY3Rpb24gZ2V0TG9jYWxlKGtleSkge1xuICAgICAgICB2YXIgbG9jYWxlO1xuXG4gICAgICAgIGlmIChrZXkgJiYga2V5Ll9sb2NhbGUgJiYga2V5Ll9sb2NhbGUuX2FiYnIpIHtcbiAgICAgICAgICAgIGtleSA9IGtleS5fbG9jYWxlLl9hYmJyO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFrZXkpIHtcbiAgICAgICAgICAgIHJldHVybiBnbG9iYWxMb2NhbGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzQXJyYXkoa2V5KSkge1xuICAgICAgICAgICAgLy9zaG9ydC1jaXJjdWl0IGV2ZXJ5dGhpbmcgZWxzZVxuICAgICAgICAgICAgbG9jYWxlID0gbG9hZExvY2FsZShrZXkpO1xuICAgICAgICAgICAgaWYgKGxvY2FsZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBsb2NhbGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBrZXkgPSBba2V5XTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjaG9vc2VMb2NhbGUoa2V5KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaXN0TG9jYWxlcygpIHtcbiAgICAgICAgcmV0dXJuIGtleXMobG9jYWxlcyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2hlY2tPdmVyZmxvdyhtKSB7XG4gICAgICAgIHZhciBvdmVyZmxvdyxcbiAgICAgICAgICAgIGEgPSBtLl9hO1xuXG4gICAgICAgIGlmIChhICYmIGdldFBhcnNpbmdGbGFncyhtKS5vdmVyZmxvdyA9PT0gLTIpIHtcbiAgICAgICAgICAgIG92ZXJmbG93ID1cbiAgICAgICAgICAgICAgICBhW01PTlRIXSA8IDAgfHwgYVtNT05USF0gPiAxMVxuICAgICAgICAgICAgICAgICAgICA/IE1PTlRIXG4gICAgICAgICAgICAgICAgICAgIDogYVtEQVRFXSA8IDEgfHwgYVtEQVRFXSA+IGRheXNJbk1vbnRoKGFbWUVBUl0sIGFbTU9OVEhdKVxuICAgICAgICAgICAgICAgICAgICA/IERBVEVcbiAgICAgICAgICAgICAgICAgICAgOiBhW0hPVVJdIDwgMCB8fFxuICAgICAgICAgICAgICAgICAgICAgIGFbSE9VUl0gPiAyNCB8fFxuICAgICAgICAgICAgICAgICAgICAgIChhW0hPVVJdID09PSAyNCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAoYVtNSU5VVEVdICE9PSAwIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhW1NFQ09ORF0gIT09IDAgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFbTUlMTElTRUNPTkRdICE9PSAwKSlcbiAgICAgICAgICAgICAgICAgICAgPyBIT1VSXG4gICAgICAgICAgICAgICAgICAgIDogYVtNSU5VVEVdIDwgMCB8fCBhW01JTlVURV0gPiA1OVxuICAgICAgICAgICAgICAgICAgICA/IE1JTlVURVxuICAgICAgICAgICAgICAgICAgICA6IGFbU0VDT05EXSA8IDAgfHwgYVtTRUNPTkRdID4gNTlcbiAgICAgICAgICAgICAgICAgICAgPyBTRUNPTkRcbiAgICAgICAgICAgICAgICAgICAgOiBhW01JTExJU0VDT05EXSA8IDAgfHwgYVtNSUxMSVNFQ09ORF0gPiA5OTlcbiAgICAgICAgICAgICAgICAgICAgPyBNSUxMSVNFQ09ORFxuICAgICAgICAgICAgICAgICAgICA6IC0xO1xuXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKG0pLl9vdmVyZmxvd0RheU9mWWVhciAmJlxuICAgICAgICAgICAgICAgIChvdmVyZmxvdyA8IFlFQVIgfHwgb3ZlcmZsb3cgPiBEQVRFKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgb3ZlcmZsb3cgPSBEQVRFO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdldFBhcnNpbmdGbGFncyhtKS5fb3ZlcmZsb3dXZWVrcyAmJiBvdmVyZmxvdyA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBvdmVyZmxvdyA9IFdFRUs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZ2V0UGFyc2luZ0ZsYWdzKG0pLl9vdmVyZmxvd1dlZWtkYXkgJiYgb3ZlcmZsb3cgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgb3ZlcmZsb3cgPSBXRUVLREFZO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MobSkub3ZlcmZsb3cgPSBvdmVyZmxvdztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtO1xuICAgIH1cblxuICAgIC8vIGlzbyA4NjAxIHJlZ2V4XG4gICAgLy8gMDAwMC0wMC0wMCAwMDAwLVcwMCBvciAwMDAwLVcwMC0wICsgVCArIDAwIG9yIDAwOjAwIG9yIDAwOjAwOjAwIG9yIDAwOjAwOjAwLjAwMCArICswMDowMCBvciArMDAwMCBvciArMDApXG4gICAgdmFyIGV4dGVuZGVkSXNvUmVnZXggPSAvXlxccyooKD86WystXVxcZHs2fXxcXGR7NH0pLSg/OlxcZFxcZC1cXGRcXGR8V1xcZFxcZC1cXGR8V1xcZFxcZHxcXGRcXGRcXGR8XFxkXFxkKSkoPzooVHwgKShcXGRcXGQoPzo6XFxkXFxkKD86OlxcZFxcZCg/OlsuLF1cXGQrKT8pPyk/KShbKy1dXFxkXFxkKD86Oj9cXGRcXGQpP3xcXHMqWik/KT8kLyxcbiAgICAgICAgYmFzaWNJc29SZWdleCA9IC9eXFxzKigoPzpbKy1dXFxkezZ9fFxcZHs0fSkoPzpcXGRcXGRcXGRcXGR8V1xcZFxcZFxcZHxXXFxkXFxkfFxcZFxcZFxcZHxcXGRcXGR8KSkoPzooVHwgKShcXGRcXGQoPzpcXGRcXGQoPzpcXGRcXGQoPzpbLixdXFxkKyk/KT8pPykoWystXVxcZFxcZCg/Ojo/XFxkXFxkKT98XFxzKlopPyk/JC8sXG4gICAgICAgIHR6UmVnZXggPSAvWnxbKy1dXFxkXFxkKD86Oj9cXGRcXGQpPy8sXG4gICAgICAgIGlzb0RhdGVzID0gW1xuICAgICAgICAgICAgWydZWVlZWVktTU0tREQnLCAvWystXVxcZHs2fS1cXGRcXGQtXFxkXFxkL10sXG4gICAgICAgICAgICBbJ1lZWVktTU0tREQnLCAvXFxkezR9LVxcZFxcZC1cXGRcXGQvXSxcbiAgICAgICAgICAgIFsnR0dHRy1bV11XVy1FJywgL1xcZHs0fS1XXFxkXFxkLVxcZC9dLFxuICAgICAgICAgICAgWydHR0dHLVtXXVdXJywgL1xcZHs0fS1XXFxkXFxkLywgZmFsc2VdLFxuICAgICAgICAgICAgWydZWVlZLURERCcsIC9cXGR7NH0tXFxkezN9L10sXG4gICAgICAgICAgICBbJ1lZWVktTU0nLCAvXFxkezR9LVxcZFxcZC8sIGZhbHNlXSxcbiAgICAgICAgICAgIFsnWVlZWVlZTU1ERCcsIC9bKy1dXFxkezEwfS9dLFxuICAgICAgICAgICAgWydZWVlZTU1ERCcsIC9cXGR7OH0vXSxcbiAgICAgICAgICAgIFsnR0dHR1tXXVdXRScsIC9cXGR7NH1XXFxkezN9L10sXG4gICAgICAgICAgICBbJ0dHR0dbV11XVycsIC9cXGR7NH1XXFxkezJ9LywgZmFsc2VdLFxuICAgICAgICAgICAgWydZWVlZREREJywgL1xcZHs3fS9dLFxuICAgICAgICAgICAgWydZWVlZTU0nLCAvXFxkezZ9LywgZmFsc2VdLFxuICAgICAgICAgICAgWydZWVlZJywgL1xcZHs0fS8sIGZhbHNlXSxcbiAgICAgICAgXSxcbiAgICAgICAgLy8gaXNvIHRpbWUgZm9ybWF0cyBhbmQgcmVnZXhlc1xuICAgICAgICBpc29UaW1lcyA9IFtcbiAgICAgICAgICAgIFsnSEg6bW06c3MuU1NTUycsIC9cXGRcXGQ6XFxkXFxkOlxcZFxcZFxcLlxcZCsvXSxcbiAgICAgICAgICAgIFsnSEg6bW06c3MsU1NTUycsIC9cXGRcXGQ6XFxkXFxkOlxcZFxcZCxcXGQrL10sXG4gICAgICAgICAgICBbJ0hIOm1tOnNzJywgL1xcZFxcZDpcXGRcXGQ6XFxkXFxkL10sXG4gICAgICAgICAgICBbJ0hIOm1tJywgL1xcZFxcZDpcXGRcXGQvXSxcbiAgICAgICAgICAgIFsnSEhtbXNzLlNTU1MnLCAvXFxkXFxkXFxkXFxkXFxkXFxkXFwuXFxkKy9dLFxuICAgICAgICAgICAgWydISG1tc3MsU1NTUycsIC9cXGRcXGRcXGRcXGRcXGRcXGQsXFxkKy9dLFxuICAgICAgICAgICAgWydISG1tc3MnLCAvXFxkXFxkXFxkXFxkXFxkXFxkL10sXG4gICAgICAgICAgICBbJ0hIbW0nLCAvXFxkXFxkXFxkXFxkL10sXG4gICAgICAgICAgICBbJ0hIJywgL1xcZFxcZC9dLFxuICAgICAgICBdLFxuICAgICAgICBhc3BOZXRKc29uUmVnZXggPSAvXlxcLz9EYXRlXFwoKC0/XFxkKykvaSxcbiAgICAgICAgLy8gUkZDIDI4MjIgcmVnZXg6IEZvciBkZXRhaWxzIHNlZSBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMjgyMiNzZWN0aW9uLTMuM1xuICAgICAgICByZmMyODIyID0gL14oPzooTW9ufFR1ZXxXZWR8VGh1fEZyaXxTYXR8U3VuKSw/XFxzKT8oXFxkezEsMn0pXFxzKEphbnxGZWJ8TWFyfEFwcnxNYXl8SnVufEp1bHxBdWd8U2VwfE9jdHxOb3Z8RGVjKVxccyhcXGR7Miw0fSlcXHMoXFxkXFxkKTooXFxkXFxkKSg/OjooXFxkXFxkKSk/XFxzKD86KFVUfEdNVHxbRUNNUF1bU0RdVCl8KFtael0pfChbKy1dXFxkezR9KSkkLyxcbiAgICAgICAgb2JzT2Zmc2V0cyA9IHtcbiAgICAgICAgICAgIFVUOiAwLFxuICAgICAgICAgICAgR01UOiAwLFxuICAgICAgICAgICAgRURUOiAtNCAqIDYwLFxuICAgICAgICAgICAgRVNUOiAtNSAqIDYwLFxuICAgICAgICAgICAgQ0RUOiAtNSAqIDYwLFxuICAgICAgICAgICAgQ1NUOiAtNiAqIDYwLFxuICAgICAgICAgICAgTURUOiAtNiAqIDYwLFxuICAgICAgICAgICAgTVNUOiAtNyAqIDYwLFxuICAgICAgICAgICAgUERUOiAtNyAqIDYwLFxuICAgICAgICAgICAgUFNUOiAtOCAqIDYwLFxuICAgICAgICB9O1xuXG4gICAgLy8gZGF0ZSBmcm9tIGlzbyBmb3JtYXRcbiAgICBmdW5jdGlvbiBjb25maWdGcm9tSVNPKGNvbmZpZykge1xuICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgIGwsXG4gICAgICAgICAgICBzdHJpbmcgPSBjb25maWcuX2ksXG4gICAgICAgICAgICBtYXRjaCA9IGV4dGVuZGVkSXNvUmVnZXguZXhlYyhzdHJpbmcpIHx8IGJhc2ljSXNvUmVnZXguZXhlYyhzdHJpbmcpLFxuICAgICAgICAgICAgYWxsb3dUaW1lLFxuICAgICAgICAgICAgZGF0ZUZvcm1hdCxcbiAgICAgICAgICAgIHRpbWVGb3JtYXQsXG4gICAgICAgICAgICB0ekZvcm1hdDtcblxuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmlzbyA9IHRydWU7XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGwgPSBpc29EYXRlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNvRGF0ZXNbaV1bMV0uZXhlYyhtYXRjaFsxXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0ZUZvcm1hdCA9IGlzb0RhdGVzW2ldWzBdO1xuICAgICAgICAgICAgICAgICAgICBhbGxvd1RpbWUgPSBpc29EYXRlc1tpXVsyXSAhPT0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkYXRlRm9ybWF0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb25maWcuX2lzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWF0Y2hbM10pIHtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBsID0gaXNvVGltZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc29UaW1lc1tpXVsxXS5leGVjKG1hdGNoWzNdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWF0Y2hbMl0gc2hvdWxkIGJlICdUJyBvciBzcGFjZVxuICAgICAgICAgICAgICAgICAgICAgICAgdGltZUZvcm1hdCA9IChtYXRjaFsyXSB8fCAnICcpICsgaXNvVGltZXNbaV1bMF07XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGltZUZvcm1hdCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZy5faXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFhbGxvd1RpbWUgJiYgdGltZUZvcm1hdCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29uZmlnLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1hdGNoWzRdKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR6UmVnZXguZXhlYyhtYXRjaFs0XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdHpGb3JtYXQgPSAnWic7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25maWcuX2YgPSBkYXRlRm9ybWF0ICsgKHRpbWVGb3JtYXQgfHwgJycpICsgKHR6Rm9ybWF0IHx8ICcnKTtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21TdHJpbmdBbmRGb3JtYXQoY29uZmlnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbmZpZy5faXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXh0cmFjdEZyb21SRkMyODIyU3RyaW5ncyhcbiAgICAgICAgeWVhclN0cixcbiAgICAgICAgbW9udGhTdHIsXG4gICAgICAgIGRheVN0cixcbiAgICAgICAgaG91clN0cixcbiAgICAgICAgbWludXRlU3RyLFxuICAgICAgICBzZWNvbmRTdHJcbiAgICApIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtcbiAgICAgICAgICAgIHVudHJ1bmNhdGVZZWFyKHllYXJTdHIpLFxuICAgICAgICAgICAgZGVmYXVsdExvY2FsZU1vbnRoc1Nob3J0LmluZGV4T2YobW9udGhTdHIpLFxuICAgICAgICAgICAgcGFyc2VJbnQoZGF5U3RyLCAxMCksXG4gICAgICAgICAgICBwYXJzZUludChob3VyU3RyLCAxMCksXG4gICAgICAgICAgICBwYXJzZUludChtaW51dGVTdHIsIDEwKSxcbiAgICAgICAgXTtcblxuICAgICAgICBpZiAoc2Vjb25kU3RyKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChwYXJzZUludChzZWNvbmRTdHIsIDEwKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVudHJ1bmNhdGVZZWFyKHllYXJTdHIpIHtcbiAgICAgICAgdmFyIHllYXIgPSBwYXJzZUludCh5ZWFyU3RyLCAxMCk7XG4gICAgICAgIGlmICh5ZWFyIDw9IDQ5KSB7XG4gICAgICAgICAgICByZXR1cm4gMjAwMCArIHllYXI7XG4gICAgICAgIH0gZWxzZSBpZiAoeWVhciA8PSA5OTkpIHtcbiAgICAgICAgICAgIHJldHVybiAxOTAwICsgeWVhcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geWVhcjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcmVwcm9jZXNzUkZDMjgyMihzKSB7XG4gICAgICAgIC8vIFJlbW92ZSBjb21tZW50cyBhbmQgZm9sZGluZyB3aGl0ZXNwYWNlIGFuZCByZXBsYWNlIG11bHRpcGxlLXNwYWNlcyB3aXRoIGEgc2luZ2xlIHNwYWNlXG4gICAgICAgIHJldHVybiBzXG4gICAgICAgICAgICAucmVwbGFjZSgvXFwoW14pXSpcXCl8W1xcblxcdF0vZywgJyAnKVxuICAgICAgICAgICAgLnJlcGxhY2UoLyhcXHNcXHMrKS9nLCAnICcpXG4gICAgICAgICAgICAucmVwbGFjZSgvXlxcc1xccyovLCAnJylcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXHNcXHMqJC8sICcnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjaGVja1dlZWtkYXkod2Vla2RheVN0ciwgcGFyc2VkSW5wdXQsIGNvbmZpZykge1xuICAgICAgICBpZiAod2Vla2RheVN0cikge1xuICAgICAgICAgICAgLy8gVE9ETzogUmVwbGFjZSB0aGUgdmFuaWxsYSBKUyBEYXRlIG9iamVjdCB3aXRoIGFuIGluZGVwZW5kZW50IGRheS1vZi13ZWVrIGNoZWNrLlxuICAgICAgICAgICAgdmFyIHdlZWtkYXlQcm92aWRlZCA9IGRlZmF1bHRMb2NhbGVXZWVrZGF5c1Nob3J0LmluZGV4T2Yod2Vla2RheVN0ciksXG4gICAgICAgICAgICAgICAgd2Vla2RheUFjdHVhbCA9IG5ldyBEYXRlKFxuICAgICAgICAgICAgICAgICAgICBwYXJzZWRJbnB1dFswXSxcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VkSW5wdXRbMV0sXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZElucHV0WzJdXG4gICAgICAgICAgICAgICAgKS5nZXREYXkoKTtcbiAgICAgICAgICAgIGlmICh3ZWVrZGF5UHJvdmlkZWQgIT09IHdlZWtkYXlBY3R1YWwpIHtcbiAgICAgICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS53ZWVrZGF5TWlzbWF0Y2ggPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNvbmZpZy5faXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjYWxjdWxhdGVPZmZzZXQob2JzT2Zmc2V0LCBtaWxpdGFyeU9mZnNldCwgbnVtT2Zmc2V0KSB7XG4gICAgICAgIGlmIChvYnNPZmZzZXQpIHtcbiAgICAgICAgICAgIHJldHVybiBvYnNPZmZzZXRzW29ic09mZnNldF07XG4gICAgICAgIH0gZWxzZSBpZiAobWlsaXRhcnlPZmZzZXQpIHtcbiAgICAgICAgICAgIC8vIHRoZSBvbmx5IGFsbG93ZWQgbWlsaXRhcnkgdHogaXMgWlxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgaG0gPSBwYXJzZUludChudW1PZmZzZXQsIDEwKSxcbiAgICAgICAgICAgICAgICBtID0gaG0gJSAxMDAsXG4gICAgICAgICAgICAgICAgaCA9IChobSAtIG0pIC8gMTAwO1xuICAgICAgICAgICAgcmV0dXJuIGggKiA2MCArIG07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBkYXRlIGFuZCB0aW1lIGZyb20gcmVmIDI4MjIgZm9ybWF0XG4gICAgZnVuY3Rpb24gY29uZmlnRnJvbVJGQzI4MjIoY29uZmlnKSB7XG4gICAgICAgIHZhciBtYXRjaCA9IHJmYzI4MjIuZXhlYyhwcmVwcm9jZXNzUkZDMjgyMihjb25maWcuX2kpKSxcbiAgICAgICAgICAgIHBhcnNlZEFycmF5O1xuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIHBhcnNlZEFycmF5ID0gZXh0cmFjdEZyb21SRkMyODIyU3RyaW5ncyhcbiAgICAgICAgICAgICAgICBtYXRjaFs0XSxcbiAgICAgICAgICAgICAgICBtYXRjaFszXSxcbiAgICAgICAgICAgICAgICBtYXRjaFsyXSxcbiAgICAgICAgICAgICAgICBtYXRjaFs1XSxcbiAgICAgICAgICAgICAgICBtYXRjaFs2XSxcbiAgICAgICAgICAgICAgICBtYXRjaFs3XVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmICghY2hlY2tXZWVrZGF5KG1hdGNoWzFdLCBwYXJzZWRBcnJheSwgY29uZmlnKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uZmlnLl9hID0gcGFyc2VkQXJyYXk7XG4gICAgICAgICAgICBjb25maWcuX3R6bSA9IGNhbGN1bGF0ZU9mZnNldChtYXRjaFs4XSwgbWF0Y2hbOV0sIG1hdGNoWzEwXSk7XG5cbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IGNyZWF0ZVVUQ0RhdGUuYXBwbHkobnVsbCwgY29uZmlnLl9hKTtcbiAgICAgICAgICAgIGNvbmZpZy5fZC5zZXRVVENNaW51dGVzKGNvbmZpZy5fZC5nZXRVVENNaW51dGVzKCkgLSBjb25maWcuX3R6bSk7XG5cbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLnJmYzI4MjIgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uZmlnLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBkYXRlIGZyb20gMSkgQVNQLk5FVCwgMikgSVNPLCAzKSBSRkMgMjgyMiBmb3JtYXRzLCBvciA0KSBvcHRpb25hbCBmYWxsYmFjayBpZiBwYXJzaW5nIGlzbid0IHN0cmljdFxuICAgIGZ1bmN0aW9uIGNvbmZpZ0Zyb21TdHJpbmcoY29uZmlnKSB7XG4gICAgICAgIHZhciBtYXRjaGVkID0gYXNwTmV0SnNvblJlZ2V4LmV4ZWMoY29uZmlnLl9pKTtcbiAgICAgICAgaWYgKG1hdGNoZWQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKCttYXRjaGVkWzFdKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbmZpZ0Zyb21JU08oY29uZmlnKTtcbiAgICAgICAgaWYgKGNvbmZpZy5faXNWYWxpZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBjb25maWcuX2lzVmFsaWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25maWdGcm9tUkZDMjgyMihjb25maWcpO1xuICAgICAgICBpZiAoY29uZmlnLl9pc1ZhbGlkID09PSBmYWxzZSkge1xuICAgICAgICAgICAgZGVsZXRlIGNvbmZpZy5faXNWYWxpZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb25maWcuX3N0cmljdCkge1xuICAgICAgICAgICAgY29uZmlnLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBGaW5hbCBhdHRlbXB0LCB1c2UgSW5wdXQgRmFsbGJhY2tcbiAgICAgICAgICAgIGhvb2tzLmNyZWF0ZUZyb21JbnB1dEZhbGxiYWNrKGNvbmZpZyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBob29rcy5jcmVhdGVGcm9tSW5wdXRGYWxsYmFjayA9IGRlcHJlY2F0ZShcbiAgICAgICAgJ3ZhbHVlIHByb3ZpZGVkIGlzIG5vdCBpbiBhIHJlY29nbml6ZWQgUkZDMjgyMiBvciBJU08gZm9ybWF0LiBtb21lbnQgY29uc3RydWN0aW9uIGZhbGxzIGJhY2sgdG8ganMgRGF0ZSgpLCAnICtcbiAgICAgICAgICAgICd3aGljaCBpcyBub3QgcmVsaWFibGUgYWNyb3NzIGFsbCBicm93c2VycyBhbmQgdmVyc2lvbnMuIE5vbiBSRkMyODIyL0lTTyBkYXRlIGZvcm1hdHMgYXJlICcgK1xuICAgICAgICAgICAgJ2Rpc2NvdXJhZ2VkLiBQbGVhc2UgcmVmZXIgdG8gaHR0cDovL21vbWVudGpzLmNvbS9ndWlkZXMvIy93YXJuaW5ncy9qcy1kYXRlLyBmb3IgbW9yZSBpbmZvLicsXG4gICAgICAgIGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKGNvbmZpZy5faSArIChjb25maWcuX3VzZVVUQyA/ICcgVVRDJyA6ICcnKSk7XG4gICAgICAgIH1cbiAgICApO1xuXG4gICAgLy8gUGljayB0aGUgZmlyc3QgZGVmaW5lZCBvZiB0d28gb3IgdGhyZWUgYXJndW1lbnRzLlxuICAgIGZ1bmN0aW9uIGRlZmF1bHRzKGEsIGIsIGMpIHtcbiAgICAgICAgaWYgKGEgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGIgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3VycmVudERhdGVBcnJheShjb25maWcpIHtcbiAgICAgICAgLy8gaG9va3MgaXMgYWN0dWFsbHkgdGhlIGV4cG9ydGVkIG1vbWVudCBvYmplY3RcbiAgICAgICAgdmFyIG5vd1ZhbHVlID0gbmV3IERhdGUoaG9va3Mubm93KCkpO1xuICAgICAgICBpZiAoY29uZmlnLl91c2VVVEMpIHtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgbm93VmFsdWUuZ2V0VVRDRnVsbFllYXIoKSxcbiAgICAgICAgICAgICAgICBub3dWYWx1ZS5nZXRVVENNb250aCgpLFxuICAgICAgICAgICAgICAgIG5vd1ZhbHVlLmdldFVUQ0RhdGUoKSxcbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtub3dWYWx1ZS5nZXRGdWxsWWVhcigpLCBub3dWYWx1ZS5nZXRNb250aCgpLCBub3dWYWx1ZS5nZXREYXRlKCldO1xuICAgIH1cblxuICAgIC8vIGNvbnZlcnQgYW4gYXJyYXkgdG8gYSBkYXRlLlxuICAgIC8vIHRoZSBhcnJheSBzaG91bGQgbWlycm9yIHRoZSBwYXJhbWV0ZXJzIGJlbG93XG4gICAgLy8gbm90ZTogYWxsIHZhbHVlcyBwYXN0IHRoZSB5ZWFyIGFyZSBvcHRpb25hbCBhbmQgd2lsbCBkZWZhdWx0IHRvIHRoZSBsb3dlc3QgcG9zc2libGUgdmFsdWUuXG4gICAgLy8gW3llYXIsIG1vbnRoLCBkYXkgLCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmRdXG4gICAgZnVuY3Rpb24gY29uZmlnRnJvbUFycmF5KGNvbmZpZykge1xuICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgIGRhdGUsXG4gICAgICAgICAgICBpbnB1dCA9IFtdLFxuICAgICAgICAgICAgY3VycmVudERhdGUsXG4gICAgICAgICAgICBleHBlY3RlZFdlZWtkYXksXG4gICAgICAgICAgICB5ZWFyVG9Vc2U7XG5cbiAgICAgICAgaWYgKGNvbmZpZy5fZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY3VycmVudERhdGUgPSBjdXJyZW50RGF0ZUFycmF5KGNvbmZpZyk7XG5cbiAgICAgICAgLy9jb21wdXRlIGRheSBvZiB0aGUgeWVhciBmcm9tIHdlZWtzIGFuZCB3ZWVrZGF5c1xuICAgICAgICBpZiAoY29uZmlnLl93ICYmIGNvbmZpZy5fYVtEQVRFXSA9PSBudWxsICYmIGNvbmZpZy5fYVtNT05USF0gPT0gbnVsbCkge1xuICAgICAgICAgICAgZGF5T2ZZZWFyRnJvbVdlZWtJbmZvKGNvbmZpZyk7XG4gICAgICAgIH1cblxuICAgICAgICAvL2lmIHRoZSBkYXkgb2YgdGhlIHllYXIgaXMgc2V0LCBmaWd1cmUgb3V0IHdoYXQgaXQgaXNcbiAgICAgICAgaWYgKGNvbmZpZy5fZGF5T2ZZZWFyICE9IG51bGwpIHtcbiAgICAgICAgICAgIHllYXJUb1VzZSA9IGRlZmF1bHRzKGNvbmZpZy5fYVtZRUFSXSwgY3VycmVudERhdGVbWUVBUl0pO1xuXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgY29uZmlnLl9kYXlPZlllYXIgPiBkYXlzSW5ZZWFyKHllYXJUb1VzZSkgfHxcbiAgICAgICAgICAgICAgICBjb25maWcuX2RheU9mWWVhciA9PT0gMFxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuX292ZXJmbG93RGF5T2ZZZWFyID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZGF0ZSA9IGNyZWF0ZVVUQ0RhdGUoeWVhclRvVXNlLCAwLCBjb25maWcuX2RheU9mWWVhcik7XG4gICAgICAgICAgICBjb25maWcuX2FbTU9OVEhdID0gZGF0ZS5nZXRVVENNb250aCgpO1xuICAgICAgICAgICAgY29uZmlnLl9hW0RBVEVdID0gZGF0ZS5nZXRVVENEYXRlKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZWZhdWx0IHRvIGN1cnJlbnQgZGF0ZS5cbiAgICAgICAgLy8gKiBpZiBubyB5ZWFyLCBtb250aCwgZGF5IG9mIG1vbnRoIGFyZSBnaXZlbiwgZGVmYXVsdCB0byB0b2RheVxuICAgICAgICAvLyAqIGlmIGRheSBvZiBtb250aCBpcyBnaXZlbiwgZGVmYXVsdCBtb250aCBhbmQgeWVhclxuICAgICAgICAvLyAqIGlmIG1vbnRoIGlzIGdpdmVuLCBkZWZhdWx0IG9ubHkgeWVhclxuICAgICAgICAvLyAqIGlmIHllYXIgaXMgZ2l2ZW4sIGRvbid0IGRlZmF1bHQgYW55dGhpbmdcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDMgJiYgY29uZmlnLl9hW2ldID09IG51bGw7ICsraSkge1xuICAgICAgICAgICAgY29uZmlnLl9hW2ldID0gaW5wdXRbaV0gPSBjdXJyZW50RGF0ZVtpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFplcm8gb3V0IHdoYXRldmVyIHdhcyBub3QgZGVmYXVsdGVkLCBpbmNsdWRpbmcgdGltZVxuICAgICAgICBmb3IgKDsgaSA8IDc7IGkrKykge1xuICAgICAgICAgICAgY29uZmlnLl9hW2ldID0gaW5wdXRbaV0gPVxuICAgICAgICAgICAgICAgIGNvbmZpZy5fYVtpXSA9PSBudWxsID8gKGkgPT09IDIgPyAxIDogMCkgOiBjb25maWcuX2FbaV07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDaGVjayBmb3IgMjQ6MDA6MDAuMDAwXG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIGNvbmZpZy5fYVtIT1VSXSA9PT0gMjQgJiZcbiAgICAgICAgICAgIGNvbmZpZy5fYVtNSU5VVEVdID09PSAwICYmXG4gICAgICAgICAgICBjb25maWcuX2FbU0VDT05EXSA9PT0gMCAmJlxuICAgICAgICAgICAgY29uZmlnLl9hW01JTExJU0VDT05EXSA9PT0gMFxuICAgICAgICApIHtcbiAgICAgICAgICAgIGNvbmZpZy5fbmV4dERheSA9IHRydWU7XG4gICAgICAgICAgICBjb25maWcuX2FbSE9VUl0gPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uZmlnLl9kID0gKGNvbmZpZy5fdXNlVVRDID8gY3JlYXRlVVRDRGF0ZSA6IGNyZWF0ZURhdGUpLmFwcGx5KFxuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgIGlucHV0XG4gICAgICAgICk7XG4gICAgICAgIGV4cGVjdGVkV2Vla2RheSA9IGNvbmZpZy5fdXNlVVRDXG4gICAgICAgICAgICA/IGNvbmZpZy5fZC5nZXRVVENEYXkoKVxuICAgICAgICAgICAgOiBjb25maWcuX2QuZ2V0RGF5KCk7XG5cbiAgICAgICAgLy8gQXBwbHkgdGltZXpvbmUgb2Zmc2V0IGZyb20gaW5wdXQuIFRoZSBhY3R1YWwgdXRjT2Zmc2V0IGNhbiBiZSBjaGFuZ2VkXG4gICAgICAgIC8vIHdpdGggcGFyc2Vab25lLlxuICAgICAgICBpZiAoY29uZmlnLl90em0gIT0gbnVsbCkge1xuICAgICAgICAgICAgY29uZmlnLl9kLnNldFVUQ01pbnV0ZXMoY29uZmlnLl9kLmdldFVUQ01pbnV0ZXMoKSAtIGNvbmZpZy5fdHptKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb25maWcuX25leHREYXkpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fYVtIT1VSXSA9IDI0O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY2hlY2sgZm9yIG1pc21hdGNoaW5nIGRheSBvZiB3ZWVrXG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIGNvbmZpZy5fdyAmJlxuICAgICAgICAgICAgdHlwZW9mIGNvbmZpZy5fdy5kICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgY29uZmlnLl93LmQgIT09IGV4cGVjdGVkV2Vla2RheVxuICAgICAgICApIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLndlZWtkYXlNaXNtYXRjaCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkYXlPZlllYXJGcm9tV2Vla0luZm8oY29uZmlnKSB7XG4gICAgICAgIHZhciB3LCB3ZWVrWWVhciwgd2Vlaywgd2Vla2RheSwgZG93LCBkb3ksIHRlbXAsIHdlZWtkYXlPdmVyZmxvdywgY3VyV2VlaztcblxuICAgICAgICB3ID0gY29uZmlnLl93O1xuICAgICAgICBpZiAody5HRyAhPSBudWxsIHx8IHcuVyAhPSBudWxsIHx8IHcuRSAhPSBudWxsKSB7XG4gICAgICAgICAgICBkb3cgPSAxO1xuICAgICAgICAgICAgZG95ID0gNDtcblxuICAgICAgICAgICAgLy8gVE9ETzogV2UgbmVlZCB0byB0YWtlIHRoZSBjdXJyZW50IGlzb1dlZWtZZWFyLCBidXQgdGhhdCBkZXBlbmRzIG9uXG4gICAgICAgICAgICAvLyBob3cgd2UgaW50ZXJwcmV0IG5vdyAobG9jYWwsIHV0YywgZml4ZWQgb2Zmc2V0KS4gU28gY3JlYXRlXG4gICAgICAgICAgICAvLyBhIG5vdyB2ZXJzaW9uIG9mIGN1cnJlbnQgY29uZmlnICh0YWtlIGxvY2FsL3V0Yy9vZmZzZXQgZmxhZ3MsIGFuZFxuICAgICAgICAgICAgLy8gY3JlYXRlIG5vdykuXG4gICAgICAgICAgICB3ZWVrWWVhciA9IGRlZmF1bHRzKFxuICAgICAgICAgICAgICAgIHcuR0csXG4gICAgICAgICAgICAgICAgY29uZmlnLl9hW1lFQVJdLFxuICAgICAgICAgICAgICAgIHdlZWtPZlllYXIoY3JlYXRlTG9jYWwoKSwgMSwgNCkueWVhclxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHdlZWsgPSBkZWZhdWx0cyh3LlcsIDEpO1xuICAgICAgICAgICAgd2Vla2RheSA9IGRlZmF1bHRzKHcuRSwgMSk7XG4gICAgICAgICAgICBpZiAod2Vla2RheSA8IDEgfHwgd2Vla2RheSA+IDcpIHtcbiAgICAgICAgICAgICAgICB3ZWVrZGF5T3ZlcmZsb3cgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZG93ID0gY29uZmlnLl9sb2NhbGUuX3dlZWsuZG93O1xuICAgICAgICAgICAgZG95ID0gY29uZmlnLl9sb2NhbGUuX3dlZWsuZG95O1xuXG4gICAgICAgICAgICBjdXJXZWVrID0gd2Vla09mWWVhcihjcmVhdGVMb2NhbCgpLCBkb3csIGRveSk7XG5cbiAgICAgICAgICAgIHdlZWtZZWFyID0gZGVmYXVsdHMody5nZywgY29uZmlnLl9hW1lFQVJdLCBjdXJXZWVrLnllYXIpO1xuXG4gICAgICAgICAgICAvLyBEZWZhdWx0IHRvIGN1cnJlbnQgd2Vlay5cbiAgICAgICAgICAgIHdlZWsgPSBkZWZhdWx0cyh3LncsIGN1cldlZWsud2Vlayk7XG5cbiAgICAgICAgICAgIGlmICh3LmQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIHdlZWtkYXkgLS0gbG93IGRheSBudW1iZXJzIGFyZSBjb25zaWRlcmVkIG5leHQgd2Vla1xuICAgICAgICAgICAgICAgIHdlZWtkYXkgPSB3LmQ7XG4gICAgICAgICAgICAgICAgaWYgKHdlZWtkYXkgPCAwIHx8IHdlZWtkYXkgPiA2KSB7XG4gICAgICAgICAgICAgICAgICAgIHdlZWtkYXlPdmVyZmxvdyA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICh3LmUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIGxvY2FsIHdlZWtkYXkgLS0gY291bnRpbmcgc3RhcnRzIGZyb20gYmVnaW5uaW5nIG9mIHdlZWtcbiAgICAgICAgICAgICAgICB3ZWVrZGF5ID0gdy5lICsgZG93O1xuICAgICAgICAgICAgICAgIGlmICh3LmUgPCAwIHx8IHcuZSA+IDYpIHtcbiAgICAgICAgICAgICAgICAgICAgd2Vla2RheU92ZXJmbG93ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGRlZmF1bHQgdG8gYmVnaW5uaW5nIG9mIHdlZWtcbiAgICAgICAgICAgICAgICB3ZWVrZGF5ID0gZG93O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh3ZWVrIDwgMSB8fCB3ZWVrID4gd2Vla3NJblllYXIod2Vla1llYXIsIGRvdywgZG95KSkge1xuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuX292ZXJmbG93V2Vla3MgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKHdlZWtkYXlPdmVyZmxvdyAhPSBudWxsKSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5fb3ZlcmZsb3dXZWVrZGF5ID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRlbXAgPSBkYXlPZlllYXJGcm9tV2Vla3Mod2Vla1llYXIsIHdlZWssIHdlZWtkYXksIGRvdywgZG95KTtcbiAgICAgICAgICAgIGNvbmZpZy5fYVtZRUFSXSA9IHRlbXAueWVhcjtcbiAgICAgICAgICAgIGNvbmZpZy5fZGF5T2ZZZWFyID0gdGVtcC5kYXlPZlllYXI7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBjb25zdGFudCB0aGF0IHJlZmVycyB0byB0aGUgSVNPIHN0YW5kYXJkXG4gICAgaG9va3MuSVNPXzg2MDEgPSBmdW5jdGlvbiAoKSB7fTtcblxuICAgIC8vIGNvbnN0YW50IHRoYXQgcmVmZXJzIHRvIHRoZSBSRkMgMjgyMiBmb3JtXG4gICAgaG9va3MuUkZDXzI4MjIgPSBmdW5jdGlvbiAoKSB7fTtcblxuICAgIC8vIGRhdGUgZnJvbSBzdHJpbmcgYW5kIGZvcm1hdCBzdHJpbmdcbiAgICBmdW5jdGlvbiBjb25maWdGcm9tU3RyaW5nQW5kRm9ybWF0KGNvbmZpZykge1xuICAgICAgICAvLyBUT0RPOiBNb3ZlIHRoaXMgdG8gYW5vdGhlciBwYXJ0IG9mIHRoZSBjcmVhdGlvbiBmbG93IHRvIHByZXZlbnQgY2lyY3VsYXIgZGVwc1xuICAgICAgICBpZiAoY29uZmlnLl9mID09PSBob29rcy5JU09fODYwMSkge1xuICAgICAgICAgICAgY29uZmlnRnJvbUlTTyhjb25maWcpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb25maWcuX2YgPT09IGhvb2tzLlJGQ18yODIyKSB7XG4gICAgICAgICAgICBjb25maWdGcm9tUkZDMjgyMihjb25maWcpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbmZpZy5fYSA9IFtdO1xuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5lbXB0eSA9IHRydWU7XG5cbiAgICAgICAgLy8gVGhpcyBhcnJheSBpcyB1c2VkIHRvIG1ha2UgYSBEYXRlLCBlaXRoZXIgd2l0aCBgbmV3IERhdGVgIG9yIGBEYXRlLlVUQ2BcbiAgICAgICAgdmFyIHN0cmluZyA9ICcnICsgY29uZmlnLl9pLFxuICAgICAgICAgICAgaSxcbiAgICAgICAgICAgIHBhcnNlZElucHV0LFxuICAgICAgICAgICAgdG9rZW5zLFxuICAgICAgICAgICAgdG9rZW4sXG4gICAgICAgICAgICBza2lwcGVkLFxuICAgICAgICAgICAgc3RyaW5nTGVuZ3RoID0gc3RyaW5nLmxlbmd0aCxcbiAgICAgICAgICAgIHRvdGFsUGFyc2VkSW5wdXRMZW5ndGggPSAwLFxuICAgICAgICAgICAgZXJhO1xuXG4gICAgICAgIHRva2VucyA9XG4gICAgICAgICAgICBleHBhbmRGb3JtYXQoY29uZmlnLl9mLCBjb25maWcuX2xvY2FsZSkubWF0Y2goZm9ybWF0dGluZ1Rva2VucykgfHwgW107XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdG9rZW4gPSB0b2tlbnNbaV07XG4gICAgICAgICAgICBwYXJzZWRJbnB1dCA9IChzdHJpbmcubWF0Y2goZ2V0UGFyc2VSZWdleEZvclRva2VuKHRva2VuLCBjb25maWcpKSB8fFxuICAgICAgICAgICAgICAgIFtdKVswXTtcbiAgICAgICAgICAgIGlmIChwYXJzZWRJbnB1dCkge1xuICAgICAgICAgICAgICAgIHNraXBwZWQgPSBzdHJpbmcuc3Vic3RyKDAsIHN0cmluZy5pbmRleE9mKHBhcnNlZElucHV0KSk7XG4gICAgICAgICAgICAgICAgaWYgKHNraXBwZWQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS51bnVzZWRJbnB1dC5wdXNoKHNraXBwZWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdHJpbmcgPSBzdHJpbmcuc2xpY2UoXG4gICAgICAgICAgICAgICAgICAgIHN0cmluZy5pbmRleE9mKHBhcnNlZElucHV0KSArIHBhcnNlZElucHV0Lmxlbmd0aFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgdG90YWxQYXJzZWRJbnB1dExlbmd0aCArPSBwYXJzZWRJbnB1dC5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBkb24ndCBwYXJzZSBpZiBpdCdzIG5vdCBhIGtub3duIHRva2VuXG4gICAgICAgICAgICBpZiAoZm9ybWF0VG9rZW5GdW5jdGlvbnNbdG9rZW5dKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlZElucHV0KSB7XG4gICAgICAgICAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmVtcHR5ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykudW51c2VkVG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhZGRUaW1lVG9BcnJheUZyb21Ub2tlbih0b2tlbiwgcGFyc2VkSW5wdXQsIGNvbmZpZyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNvbmZpZy5fc3RyaWN0ICYmICFwYXJzZWRJbnB1dCkge1xuICAgICAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLnVudXNlZFRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFkZCByZW1haW5pbmcgdW5wYXJzZWQgaW5wdXQgbGVuZ3RoIHRvIHRoZSBzdHJpbmdcbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuY2hhcnNMZWZ0T3ZlciA9XG4gICAgICAgICAgICBzdHJpbmdMZW5ndGggLSB0b3RhbFBhcnNlZElucHV0TGVuZ3RoO1xuICAgICAgICBpZiAoc3RyaW5nLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLnVudXNlZElucHV0LnB1c2goc3RyaW5nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNsZWFyIF8xMmggZmxhZyBpZiBob3VyIGlzIDw9IDEyXG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIGNvbmZpZy5fYVtIT1VSXSA8PSAxMiAmJlxuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuYmlnSG91ciA9PT0gdHJ1ZSAmJlxuICAgICAgICAgICAgY29uZmlnLl9hW0hPVVJdID4gMFxuICAgICAgICApIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmJpZ0hvdXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5wYXJzZWREYXRlUGFydHMgPSBjb25maWcuX2Euc2xpY2UoMCk7XG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLm1lcmlkaWVtID0gY29uZmlnLl9tZXJpZGllbTtcbiAgICAgICAgLy8gaGFuZGxlIG1lcmlkaWVtXG4gICAgICAgIGNvbmZpZy5fYVtIT1VSXSA9IG1lcmlkaWVtRml4V3JhcChcbiAgICAgICAgICAgIGNvbmZpZy5fbG9jYWxlLFxuICAgICAgICAgICAgY29uZmlnLl9hW0hPVVJdLFxuICAgICAgICAgICAgY29uZmlnLl9tZXJpZGllbVxuICAgICAgICApO1xuXG4gICAgICAgIC8vIGhhbmRsZSBlcmFcbiAgICAgICAgZXJhID0gZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuZXJhO1xuICAgICAgICBpZiAoZXJhICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25maWcuX2FbWUVBUl0gPSBjb25maWcuX2xvY2FsZS5lcmFzQ29udmVydFllYXIoZXJhLCBjb25maWcuX2FbWUVBUl0pO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uZmlnRnJvbUFycmF5KGNvbmZpZyk7XG4gICAgICAgIGNoZWNrT3ZlcmZsb3coY29uZmlnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtZXJpZGllbUZpeFdyYXAobG9jYWxlLCBob3VyLCBtZXJpZGllbSkge1xuICAgICAgICB2YXIgaXNQbTtcblxuICAgICAgICBpZiAobWVyaWRpZW0gPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gbm90aGluZyB0byBkb1xuICAgICAgICAgICAgcmV0dXJuIGhvdXI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxvY2FsZS5tZXJpZGllbUhvdXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsZS5tZXJpZGllbUhvdXIoaG91ciwgbWVyaWRpZW0pO1xuICAgICAgICB9IGVsc2UgaWYgKGxvY2FsZS5pc1BNICE9IG51bGwpIHtcbiAgICAgICAgICAgIC8vIEZhbGxiYWNrXG4gICAgICAgICAgICBpc1BtID0gbG9jYWxlLmlzUE0obWVyaWRpZW0pO1xuICAgICAgICAgICAgaWYgKGlzUG0gJiYgaG91ciA8IDEyKSB7XG4gICAgICAgICAgICAgICAgaG91ciArPSAxMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaXNQbSAmJiBob3VyID09PSAxMikge1xuICAgICAgICAgICAgICAgIGhvdXIgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGhvdXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyB0aGlzIGlzIG5vdCBzdXBwb3NlZCB0byBoYXBwZW5cbiAgICAgICAgICAgIHJldHVybiBob3VyO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gZGF0ZSBmcm9tIHN0cmluZyBhbmQgYXJyYXkgb2YgZm9ybWF0IHN0cmluZ3NcbiAgICBmdW5jdGlvbiBjb25maWdGcm9tU3RyaW5nQW5kQXJyYXkoY29uZmlnKSB7XG4gICAgICAgIHZhciB0ZW1wQ29uZmlnLFxuICAgICAgICAgICAgYmVzdE1vbWVudCxcbiAgICAgICAgICAgIHNjb3JlVG9CZWF0LFxuICAgICAgICAgICAgaSxcbiAgICAgICAgICAgIGN1cnJlbnRTY29yZSxcbiAgICAgICAgICAgIHZhbGlkRm9ybWF0Rm91bmQsXG4gICAgICAgICAgICBiZXN0Rm9ybWF0SXNWYWxpZCA9IGZhbHNlO1xuXG4gICAgICAgIGlmIChjb25maWcuX2YubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5pbnZhbGlkRm9ybWF0ID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKE5hTik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY29uZmlnLl9mLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjdXJyZW50U2NvcmUgPSAwO1xuICAgICAgICAgICAgdmFsaWRGb3JtYXRGb3VuZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGVtcENvbmZpZyA9IGNvcHlDb25maWcoe30sIGNvbmZpZyk7XG4gICAgICAgICAgICBpZiAoY29uZmlnLl91c2VVVEMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRlbXBDb25maWcuX3VzZVVUQyA9IGNvbmZpZy5fdXNlVVRDO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGVtcENvbmZpZy5fZiA9IGNvbmZpZy5fZltpXTtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21TdHJpbmdBbmRGb3JtYXQodGVtcENvbmZpZyk7XG5cbiAgICAgICAgICAgIGlmIChpc1ZhbGlkKHRlbXBDb25maWcpKSB7XG4gICAgICAgICAgICAgICAgdmFsaWRGb3JtYXRGb3VuZCA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGlmIHRoZXJlIGlzIGFueSBpbnB1dCB0aGF0IHdhcyBub3QgcGFyc2VkIGFkZCBhIHBlbmFsdHkgZm9yIHRoYXQgZm9ybWF0XG4gICAgICAgICAgICBjdXJyZW50U2NvcmUgKz0gZ2V0UGFyc2luZ0ZsYWdzKHRlbXBDb25maWcpLmNoYXJzTGVmdE92ZXI7XG5cbiAgICAgICAgICAgIC8vb3IgdG9rZW5zXG4gICAgICAgICAgICBjdXJyZW50U2NvcmUgKz0gZ2V0UGFyc2luZ0ZsYWdzKHRlbXBDb25maWcpLnVudXNlZFRva2Vucy5sZW5ndGggKiAxMDtcblxuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKHRlbXBDb25maWcpLnNjb3JlID0gY3VycmVudFNjb3JlO1xuXG4gICAgICAgICAgICBpZiAoIWJlc3RGb3JtYXRJc1ZhbGlkKSB7XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICBzY29yZVRvQmVhdCA9PSBudWxsIHx8XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTY29yZSA8IHNjb3JlVG9CZWF0IHx8XG4gICAgICAgICAgICAgICAgICAgIHZhbGlkRm9ybWF0Rm91bmRcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgc2NvcmVUb0JlYXQgPSBjdXJyZW50U2NvcmU7XG4gICAgICAgICAgICAgICAgICAgIGJlc3RNb21lbnQgPSB0ZW1wQ29uZmlnO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsaWRGb3JtYXRGb3VuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYmVzdEZvcm1hdElzVmFsaWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudFNjb3JlIDwgc2NvcmVUb0JlYXQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2NvcmVUb0JlYXQgPSBjdXJyZW50U2NvcmU7XG4gICAgICAgICAgICAgICAgICAgIGJlc3RNb21lbnQgPSB0ZW1wQ29uZmlnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGV4dGVuZChjb25maWcsIGJlc3RNb21lbnQgfHwgdGVtcENvbmZpZyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29uZmlnRnJvbU9iamVjdChjb25maWcpIHtcbiAgICAgICAgaWYgKGNvbmZpZy5fZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGkgPSBub3JtYWxpemVPYmplY3RVbml0cyhjb25maWcuX2kpLFxuICAgICAgICAgICAgZGF5T3JEYXRlID0gaS5kYXkgPT09IHVuZGVmaW5lZCA/IGkuZGF0ZSA6IGkuZGF5O1xuICAgICAgICBjb25maWcuX2EgPSBtYXAoXG4gICAgICAgICAgICBbaS55ZWFyLCBpLm1vbnRoLCBkYXlPckRhdGUsIGkuaG91ciwgaS5taW51dGUsIGkuc2Vjb25kLCBpLm1pbGxpc2Vjb25kXSxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqICYmIHBhcnNlSW50KG9iaiwgMTApO1xuICAgICAgICAgICAgfVxuICAgICAgICApO1xuXG4gICAgICAgIGNvbmZpZ0Zyb21BcnJheShjb25maWcpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUZyb21Db25maWcoY29uZmlnKSB7XG4gICAgICAgIHZhciByZXMgPSBuZXcgTW9tZW50KGNoZWNrT3ZlcmZsb3cocHJlcGFyZUNvbmZpZyhjb25maWcpKSk7XG4gICAgICAgIGlmIChyZXMuX25leHREYXkpIHtcbiAgICAgICAgICAgIC8vIEFkZGluZyBpcyBzbWFydCBlbm91Z2ggYXJvdW5kIERTVFxuICAgICAgICAgICAgcmVzLmFkZCgxLCAnZCcpO1xuICAgICAgICAgICAgcmVzLl9uZXh0RGF5ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcmVwYXJlQ29uZmlnKGNvbmZpZykge1xuICAgICAgICB2YXIgaW5wdXQgPSBjb25maWcuX2ksXG4gICAgICAgICAgICBmb3JtYXQgPSBjb25maWcuX2Y7XG5cbiAgICAgICAgY29uZmlnLl9sb2NhbGUgPSBjb25maWcuX2xvY2FsZSB8fCBnZXRMb2NhbGUoY29uZmlnLl9sKTtcblxuICAgICAgICBpZiAoaW5wdXQgPT09IG51bGwgfHwgKGZvcm1hdCA9PT0gdW5kZWZpbmVkICYmIGlucHV0ID09PSAnJykpIHtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVJbnZhbGlkKHsgbnVsbElucHV0OiB0cnVlIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGNvbmZpZy5faSA9IGlucHV0ID0gY29uZmlnLl9sb2NhbGUucHJlcGFyc2UoaW5wdXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzTW9tZW50KGlucHV0KSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBNb21lbnQoY2hlY2tPdmVyZmxvdyhpbnB1dCkpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzRGF0ZShpbnB1dCkpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IGlucHV0O1xuICAgICAgICB9IGVsc2UgaWYgKGlzQXJyYXkoZm9ybWF0KSkge1xuICAgICAgICAgICAgY29uZmlnRnJvbVN0cmluZ0FuZEFycmF5KGNvbmZpZyk7XG4gICAgICAgIH0gZWxzZSBpZiAoZm9ybWF0KSB7XG4gICAgICAgICAgICBjb25maWdGcm9tU3RyaW5nQW5kRm9ybWF0KGNvbmZpZyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25maWdGcm9tSW5wdXQoY29uZmlnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNWYWxpZChjb25maWcpKSB7XG4gICAgICAgICAgICBjb25maWcuX2QgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvbmZpZztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb25maWdGcm9tSW5wdXQoY29uZmlnKSB7XG4gICAgICAgIHZhciBpbnB1dCA9IGNvbmZpZy5faTtcbiAgICAgICAgaWYgKGlzVW5kZWZpbmVkKGlucHV0KSkge1xuICAgICAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUoaG9va3Mubm93KCkpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzRGF0ZShpbnB1dCkpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKGlucHV0LnZhbHVlT2YoKSk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgY29uZmlnRnJvbVN0cmluZyhjb25maWcpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzQXJyYXkoaW5wdXQpKSB7XG4gICAgICAgICAgICBjb25maWcuX2EgPSBtYXAoaW5wdXQuc2xpY2UoMCksIGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQob2JqLCAxMCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21BcnJheShjb25maWcpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KGlucHV0KSkge1xuICAgICAgICAgICAgY29uZmlnRnJvbU9iamVjdChjb25maWcpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzTnVtYmVyKGlucHV0KSkge1xuICAgICAgICAgICAgLy8gZnJvbSBtaWxsaXNlY29uZHNcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKGlucHV0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGhvb2tzLmNyZWF0ZUZyb21JbnB1dEZhbGxiYWNrKGNvbmZpZyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVMb2NhbE9yVVRDKGlucHV0LCBmb3JtYXQsIGxvY2FsZSwgc3RyaWN0LCBpc1VUQykge1xuICAgICAgICB2YXIgYyA9IHt9O1xuXG4gICAgICAgIGlmIChmb3JtYXQgPT09IHRydWUgfHwgZm9ybWF0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgc3RyaWN0ID0gZm9ybWF0O1xuICAgICAgICAgICAgZm9ybWF0ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxvY2FsZSA9PT0gdHJ1ZSB8fCBsb2NhbGUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBzdHJpY3QgPSBsb2NhbGU7XG4gICAgICAgICAgICBsb2NhbGUgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoXG4gICAgICAgICAgICAoaXNPYmplY3QoaW5wdXQpICYmIGlzT2JqZWN0RW1wdHkoaW5wdXQpKSB8fFxuICAgICAgICAgICAgKGlzQXJyYXkoaW5wdXQpICYmIGlucHV0Lmxlbmd0aCA9PT0gMClcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBpbnB1dCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICAvLyBvYmplY3QgY29uc3RydWN0aW9uIG11c3QgYmUgZG9uZSB0aGlzIHdheS5cbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21vbWVudC9tb21lbnQvaXNzdWVzLzE0MjNcbiAgICAgICAgYy5faXNBTW9tZW50T2JqZWN0ID0gdHJ1ZTtcbiAgICAgICAgYy5fdXNlVVRDID0gYy5faXNVVEMgPSBpc1VUQztcbiAgICAgICAgYy5fbCA9IGxvY2FsZTtcbiAgICAgICAgYy5faSA9IGlucHV0O1xuICAgICAgICBjLl9mID0gZm9ybWF0O1xuICAgICAgICBjLl9zdHJpY3QgPSBzdHJpY3Q7XG5cbiAgICAgICAgcmV0dXJuIGNyZWF0ZUZyb21Db25maWcoYyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlTG9jYWwoaW5wdXQsIGZvcm1hdCwgbG9jYWxlLCBzdHJpY3QpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUxvY2FsT3JVVEMoaW5wdXQsIGZvcm1hdCwgbG9jYWxlLCBzdHJpY3QsIGZhbHNlKTtcbiAgICB9XG5cbiAgICB2YXIgcHJvdG90eXBlTWluID0gZGVwcmVjYXRlKFxuICAgICAgICAgICAgJ21vbWVudCgpLm1pbiBpcyBkZXByZWNhdGVkLCB1c2UgbW9tZW50Lm1heCBpbnN0ZWFkLiBodHRwOi8vbW9tZW50anMuY29tL2d1aWRlcy8jL3dhcm5pbmdzL21pbi1tYXgvJyxcbiAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgb3RoZXIgPSBjcmVhdGVMb2NhbC5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzVmFsaWQoKSAmJiBvdGhlci5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG90aGVyIDwgdGhpcyA/IHRoaXMgOiBvdGhlcjtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlSW52YWxpZCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgKSxcbiAgICAgICAgcHJvdG90eXBlTWF4ID0gZGVwcmVjYXRlKFxuICAgICAgICAgICAgJ21vbWVudCgpLm1heCBpcyBkZXByZWNhdGVkLCB1c2UgbW9tZW50Lm1pbiBpbnN0ZWFkLiBodHRwOi8vbW9tZW50anMuY29tL2d1aWRlcy8jL3dhcm5pbmdzL21pbi1tYXgvJyxcbiAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgb3RoZXIgPSBjcmVhdGVMb2NhbC5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzVmFsaWQoKSAmJiBvdGhlci5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG90aGVyID4gdGhpcyA/IHRoaXMgOiBvdGhlcjtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlSW52YWxpZCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgKTtcblxuICAgIC8vIFBpY2sgYSBtb21lbnQgbSBmcm9tIG1vbWVudHMgc28gdGhhdCBtW2ZuXShvdGhlcikgaXMgdHJ1ZSBmb3IgYWxsXG4gICAgLy8gb3RoZXIuIFRoaXMgcmVsaWVzIG9uIHRoZSBmdW5jdGlvbiBmbiB0byBiZSB0cmFuc2l0aXZlLlxuICAgIC8vXG4gICAgLy8gbW9tZW50cyBzaG91bGQgZWl0aGVyIGJlIGFuIGFycmF5IG9mIG1vbWVudCBvYmplY3RzIG9yIGFuIGFycmF5LCB3aG9zZVxuICAgIC8vIGZpcnN0IGVsZW1lbnQgaXMgYW4gYXJyYXkgb2YgbW9tZW50IG9iamVjdHMuXG4gICAgZnVuY3Rpb24gcGlja0J5KGZuLCBtb21lbnRzKSB7XG4gICAgICAgIHZhciByZXMsIGk7XG4gICAgICAgIGlmIChtb21lbnRzLmxlbmd0aCA9PT0gMSAmJiBpc0FycmF5KG1vbWVudHNbMF0pKSB7XG4gICAgICAgICAgICBtb21lbnRzID0gbW9tZW50c1swXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW1vbWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlTG9jYWwoKTtcbiAgICAgICAgfVxuICAgICAgICByZXMgPSBtb21lbnRzWzBdO1xuICAgICAgICBmb3IgKGkgPSAxOyBpIDwgbW9tZW50cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgaWYgKCFtb21lbnRzW2ldLmlzVmFsaWQoKSB8fCBtb21lbnRzW2ldW2ZuXShyZXMpKSB7XG4gICAgICAgICAgICAgICAgcmVzID0gbW9tZW50c1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIC8vIFRPRE86IFVzZSBbXS5zb3J0IGluc3RlYWQ/XG4gICAgZnVuY3Rpb24gbWluKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcblxuICAgICAgICByZXR1cm4gcGlja0J5KCdpc0JlZm9yZScsIGFyZ3MpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1heCgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG5cbiAgICAgICAgcmV0dXJuIHBpY2tCeSgnaXNBZnRlcicsIGFyZ3MpO1xuICAgIH1cblxuICAgIHZhciBub3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBEYXRlLm5vdyA/IERhdGUubm93KCkgOiArbmV3IERhdGUoKTtcbiAgICB9O1xuXG4gICAgdmFyIG9yZGVyaW5nID0gW1xuICAgICAgICAneWVhcicsXG4gICAgICAgICdxdWFydGVyJyxcbiAgICAgICAgJ21vbnRoJyxcbiAgICAgICAgJ3dlZWsnLFxuICAgICAgICAnZGF5JyxcbiAgICAgICAgJ2hvdXInLFxuICAgICAgICAnbWludXRlJyxcbiAgICAgICAgJ3NlY29uZCcsXG4gICAgICAgICdtaWxsaXNlY29uZCcsXG4gICAgXTtcblxuICAgIGZ1bmN0aW9uIGlzRHVyYXRpb25WYWxpZChtKSB7XG4gICAgICAgIHZhciBrZXksXG4gICAgICAgICAgICB1bml0SGFzRGVjaW1hbCA9IGZhbHNlLFxuICAgICAgICAgICAgaTtcbiAgICAgICAgZm9yIChrZXkgaW4gbSkge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIGhhc093blByb3AobSwga2V5KSAmJlxuICAgICAgICAgICAgICAgICEoXG4gICAgICAgICAgICAgICAgICAgIGluZGV4T2YuY2FsbChvcmRlcmluZywga2V5KSAhPT0gLTEgJiZcbiAgICAgICAgICAgICAgICAgICAgKG1ba2V5XSA9PSBudWxsIHx8ICFpc05hTihtW2tleV0pKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBvcmRlcmluZy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgaWYgKG1bb3JkZXJpbmdbaV1dKSB7XG4gICAgICAgICAgICAgICAgaWYgKHVuaXRIYXNEZWNpbWFsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gb25seSBhbGxvdyBub24taW50ZWdlcnMgZm9yIHNtYWxsZXN0IHVuaXRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlRmxvYXQobVtvcmRlcmluZ1tpXV0pICE9PSB0b0ludChtW29yZGVyaW5nW2ldXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdW5pdEhhc0RlY2ltYWwgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzVmFsaWQkMSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzVmFsaWQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlSW52YWxpZCQxKCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlRHVyYXRpb24oTmFOKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBEdXJhdGlvbihkdXJhdGlvbikge1xuICAgICAgICB2YXIgbm9ybWFsaXplZElucHV0ID0gbm9ybWFsaXplT2JqZWN0VW5pdHMoZHVyYXRpb24pLFxuICAgICAgICAgICAgeWVhcnMgPSBub3JtYWxpemVkSW5wdXQueWVhciB8fCAwLFxuICAgICAgICAgICAgcXVhcnRlcnMgPSBub3JtYWxpemVkSW5wdXQucXVhcnRlciB8fCAwLFxuICAgICAgICAgICAgbW9udGhzID0gbm9ybWFsaXplZElucHV0Lm1vbnRoIHx8IDAsXG4gICAgICAgICAgICB3ZWVrcyA9IG5vcm1hbGl6ZWRJbnB1dC53ZWVrIHx8IG5vcm1hbGl6ZWRJbnB1dC5pc29XZWVrIHx8IDAsXG4gICAgICAgICAgICBkYXlzID0gbm9ybWFsaXplZElucHV0LmRheSB8fCAwLFxuICAgICAgICAgICAgaG91cnMgPSBub3JtYWxpemVkSW5wdXQuaG91ciB8fCAwLFxuICAgICAgICAgICAgbWludXRlcyA9IG5vcm1hbGl6ZWRJbnB1dC5taW51dGUgfHwgMCxcbiAgICAgICAgICAgIHNlY29uZHMgPSBub3JtYWxpemVkSW5wdXQuc2Vjb25kIHx8IDAsXG4gICAgICAgICAgICBtaWxsaXNlY29uZHMgPSBub3JtYWxpemVkSW5wdXQubWlsbGlzZWNvbmQgfHwgMDtcblxuICAgICAgICB0aGlzLl9pc1ZhbGlkID0gaXNEdXJhdGlvblZhbGlkKG5vcm1hbGl6ZWRJbnB1dCk7XG5cbiAgICAgICAgLy8gcmVwcmVzZW50YXRpb24gZm9yIGRhdGVBZGRSZW1vdmVcbiAgICAgICAgdGhpcy5fbWlsbGlzZWNvbmRzID1cbiAgICAgICAgICAgICttaWxsaXNlY29uZHMgK1xuICAgICAgICAgICAgc2Vjb25kcyAqIDFlMyArIC8vIDEwMDBcbiAgICAgICAgICAgIG1pbnV0ZXMgKiA2ZTQgKyAvLyAxMDAwICogNjBcbiAgICAgICAgICAgIGhvdXJzICogMTAwMCAqIDYwICogNjA7IC8vdXNpbmcgMTAwMCAqIDYwICogNjAgaW5zdGVhZCBvZiAzNmU1IHRvIGF2b2lkIGZsb2F0aW5nIHBvaW50IHJvdW5kaW5nIGVycm9ycyBodHRwczovL2dpdGh1Yi5jb20vbW9tZW50L21vbWVudC9pc3N1ZXMvMjk3OFxuICAgICAgICAvLyBCZWNhdXNlIG9mIGRhdGVBZGRSZW1vdmUgdHJlYXRzIDI0IGhvdXJzIGFzIGRpZmZlcmVudCBmcm9tIGFcbiAgICAgICAgLy8gZGF5IHdoZW4gd29ya2luZyBhcm91bmQgRFNULCB3ZSBuZWVkIHRvIHN0b3JlIHRoZW0gc2VwYXJhdGVseVxuICAgICAgICB0aGlzLl9kYXlzID0gK2RheXMgKyB3ZWVrcyAqIDc7XG4gICAgICAgIC8vIEl0IGlzIGltcG9zc2libGUgdG8gdHJhbnNsYXRlIG1vbnRocyBpbnRvIGRheXMgd2l0aG91dCBrbm93aW5nXG4gICAgICAgIC8vIHdoaWNoIG1vbnRocyB5b3UgYXJlIGFyZSB0YWxraW5nIGFib3V0LCBzbyB3ZSBoYXZlIHRvIHN0b3JlXG4gICAgICAgIC8vIGl0IHNlcGFyYXRlbHkuXG4gICAgICAgIHRoaXMuX21vbnRocyA9ICttb250aHMgKyBxdWFydGVycyAqIDMgKyB5ZWFycyAqIDEyO1xuXG4gICAgICAgIHRoaXMuX2RhdGEgPSB7fTtcblxuICAgICAgICB0aGlzLl9sb2NhbGUgPSBnZXRMb2NhbGUoKTtcblxuICAgICAgICB0aGlzLl9idWJibGUoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0R1cmF0aW9uKG9iaikge1xuICAgICAgICByZXR1cm4gb2JqIGluc3RhbmNlb2YgRHVyYXRpb247XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWJzUm91bmQobnVtYmVyKSB7XG4gICAgICAgIGlmIChudW1iZXIgPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5yb3VuZCgtMSAqIG51bWJlcikgKiAtMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLnJvdW5kKG51bWJlcik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBjb21wYXJlIHR3byBhcnJheXMsIHJldHVybiB0aGUgbnVtYmVyIG9mIGRpZmZlcmVuY2VzXG4gICAgZnVuY3Rpb24gY29tcGFyZUFycmF5cyhhcnJheTEsIGFycmF5MiwgZG9udENvbnZlcnQpIHtcbiAgICAgICAgdmFyIGxlbiA9IE1hdGgubWluKGFycmF5MS5sZW5ndGgsIGFycmF5Mi5sZW5ndGgpLFxuICAgICAgICAgICAgbGVuZ3RoRGlmZiA9IE1hdGguYWJzKGFycmF5MS5sZW5ndGggLSBhcnJheTIubGVuZ3RoKSxcbiAgICAgICAgICAgIGRpZmZzID0gMCxcbiAgICAgICAgICAgIGk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIChkb250Q29udmVydCAmJiBhcnJheTFbaV0gIT09IGFycmF5MltpXSkgfHxcbiAgICAgICAgICAgICAgICAoIWRvbnRDb252ZXJ0ICYmIHRvSW50KGFycmF5MVtpXSkgIT09IHRvSW50KGFycmF5MltpXSkpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBkaWZmcysrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkaWZmcyArIGxlbmd0aERpZmY7XG4gICAgfVxuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgZnVuY3Rpb24gb2Zmc2V0KHRva2VuLCBzZXBhcmF0b3IpIHtcbiAgICAgICAgYWRkRm9ybWF0VG9rZW4odG9rZW4sIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSB0aGlzLnV0Y09mZnNldCgpLFxuICAgICAgICAgICAgICAgIHNpZ24gPSAnKyc7XG4gICAgICAgICAgICBpZiAob2Zmc2V0IDwgMCkge1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IC1vZmZzZXQ7XG4gICAgICAgICAgICAgICAgc2lnbiA9ICctJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgc2lnbiArXG4gICAgICAgICAgICAgICAgemVyb0ZpbGwofn4ob2Zmc2V0IC8gNjApLCAyKSArXG4gICAgICAgICAgICAgICAgc2VwYXJhdG9yICtcbiAgICAgICAgICAgICAgICB6ZXJvRmlsbCh+fm9mZnNldCAlIDYwLCAyKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgb2Zmc2V0KCdaJywgJzonKTtcbiAgICBvZmZzZXQoJ1paJywgJycpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignWicsIG1hdGNoU2hvcnRPZmZzZXQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1paJywgbWF0Y2hTaG9ydE9mZnNldCk7XG4gICAgYWRkUGFyc2VUb2tlbihbJ1onLCAnWlonXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIGNvbmZpZy5fdXNlVVRDID0gdHJ1ZTtcbiAgICAgICAgY29uZmlnLl90em0gPSBvZmZzZXRGcm9tU3RyaW5nKG1hdGNoU2hvcnRPZmZzZXQsIGlucHV0KTtcbiAgICB9KTtcblxuICAgIC8vIEhFTFBFUlNcblxuICAgIC8vIHRpbWV6b25lIGNodW5rZXJcbiAgICAvLyAnKzEwOjAwJyA+IFsnMTAnLCAgJzAwJ11cbiAgICAvLyAnLTE1MzAnICA+IFsnLTE1JywgJzMwJ11cbiAgICB2YXIgY2h1bmtPZmZzZXQgPSAvKFtcXCtcXC1dfFxcZFxcZCkvZ2k7XG5cbiAgICBmdW5jdGlvbiBvZmZzZXRGcm9tU3RyaW5nKG1hdGNoZXIsIHN0cmluZykge1xuICAgICAgICB2YXIgbWF0Y2hlcyA9IChzdHJpbmcgfHwgJycpLm1hdGNoKG1hdGNoZXIpLFxuICAgICAgICAgICAgY2h1bmssXG4gICAgICAgICAgICBwYXJ0cyxcbiAgICAgICAgICAgIG1pbnV0ZXM7XG5cbiAgICAgICAgaWYgKG1hdGNoZXMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgY2h1bmsgPSBtYXRjaGVzW21hdGNoZXMubGVuZ3RoIC0gMV0gfHwgW107XG4gICAgICAgIHBhcnRzID0gKGNodW5rICsgJycpLm1hdGNoKGNodW5rT2Zmc2V0KSB8fCBbJy0nLCAwLCAwXTtcbiAgICAgICAgbWludXRlcyA9ICsocGFydHNbMV0gKiA2MCkgKyB0b0ludChwYXJ0c1syXSk7XG5cbiAgICAgICAgcmV0dXJuIG1pbnV0ZXMgPT09IDAgPyAwIDogcGFydHNbMF0gPT09ICcrJyA/IG1pbnV0ZXMgOiAtbWludXRlcztcbiAgICB9XG5cbiAgICAvLyBSZXR1cm4gYSBtb21lbnQgZnJvbSBpbnB1dCwgdGhhdCBpcyBsb2NhbC91dGMvem9uZSBlcXVpdmFsZW50IHRvIG1vZGVsLlxuICAgIGZ1bmN0aW9uIGNsb25lV2l0aE9mZnNldChpbnB1dCwgbW9kZWwpIHtcbiAgICAgICAgdmFyIHJlcywgZGlmZjtcbiAgICAgICAgaWYgKG1vZGVsLl9pc1VUQykge1xuICAgICAgICAgICAgcmVzID0gbW9kZWwuY2xvbmUoKTtcbiAgICAgICAgICAgIGRpZmYgPVxuICAgICAgICAgICAgICAgIChpc01vbWVudChpbnB1dCkgfHwgaXNEYXRlKGlucHV0KVxuICAgICAgICAgICAgICAgICAgICA/IGlucHV0LnZhbHVlT2YoKVxuICAgICAgICAgICAgICAgICAgICA6IGNyZWF0ZUxvY2FsKGlucHV0KS52YWx1ZU9mKCkpIC0gcmVzLnZhbHVlT2YoKTtcbiAgICAgICAgICAgIC8vIFVzZSBsb3ctbGV2ZWwgYXBpLCBiZWNhdXNlIHRoaXMgZm4gaXMgbG93LWxldmVsIGFwaS5cbiAgICAgICAgICAgIHJlcy5fZC5zZXRUaW1lKHJlcy5fZC52YWx1ZU9mKCkgKyBkaWZmKTtcbiAgICAgICAgICAgIGhvb2tzLnVwZGF0ZU9mZnNldChyZXMsIGZhbHNlKTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlTG9jYWwoaW5wdXQpLmxvY2FsKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXREYXRlT2Zmc2V0KG0pIHtcbiAgICAgICAgLy8gT24gRmlyZWZveC4yNCBEYXRlI2dldFRpbWV6b25lT2Zmc2V0IHJldHVybnMgYSBmbG9hdGluZyBwb2ludC5cbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21vbWVudC9tb21lbnQvcHVsbC8xODcxXG4gICAgICAgIHJldHVybiAtTWF0aC5yb3VuZChtLl9kLmdldFRpbWV6b25lT2Zmc2V0KCkpO1xuICAgIH1cblxuICAgIC8vIEhPT0tTXG5cbiAgICAvLyBUaGlzIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIHdoZW5ldmVyIGEgbW9tZW50IGlzIG11dGF0ZWQuXG4gICAgLy8gSXQgaXMgaW50ZW5kZWQgdG8ga2VlcCB0aGUgb2Zmc2V0IGluIHN5bmMgd2l0aCB0aGUgdGltZXpvbmUuXG4gICAgaG9va3MudXBkYXRlT2Zmc2V0ID0gZnVuY3Rpb24gKCkge307XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICAvLyBrZWVwTG9jYWxUaW1lID0gdHJ1ZSBtZWFucyBvbmx5IGNoYW5nZSB0aGUgdGltZXpvbmUsIHdpdGhvdXRcbiAgICAvLyBhZmZlY3RpbmcgdGhlIGxvY2FsIGhvdXIuIFNvIDU6MzE6MjYgKzAzMDAgLS1bdXRjT2Zmc2V0KDIsIHRydWUpXS0tPlxuICAgIC8vIDU6MzE6MjYgKzAyMDAgSXQgaXMgcG9zc2libGUgdGhhdCA1OjMxOjI2IGRvZXNuJ3QgZXhpc3Qgd2l0aCBvZmZzZXRcbiAgICAvLyArMDIwMCwgc28gd2UgYWRqdXN0IHRoZSB0aW1lIGFzIG5lZWRlZCwgdG8gYmUgdmFsaWQuXG4gICAgLy9cbiAgICAvLyBLZWVwaW5nIHRoZSB0aW1lIGFjdHVhbGx5IGFkZHMvc3VidHJhY3RzIChvbmUgaG91cilcbiAgICAvLyBmcm9tIHRoZSBhY3R1YWwgcmVwcmVzZW50ZWQgdGltZS4gVGhhdCBpcyB3aHkgd2UgY2FsbCB1cGRhdGVPZmZzZXRcbiAgICAvLyBhIHNlY29uZCB0aW1lLiBJbiBjYXNlIGl0IHdhbnRzIHVzIHRvIGNoYW5nZSB0aGUgb2Zmc2V0IGFnYWluXG4gICAgLy8gX2NoYW5nZUluUHJvZ3Jlc3MgPT0gdHJ1ZSBjYXNlLCB0aGVuIHdlIGhhdmUgdG8gYWRqdXN0LCBiZWNhdXNlXG4gICAgLy8gdGhlcmUgaXMgbm8gc3VjaCB0aW1lIGluIHRoZSBnaXZlbiB0aW1lem9uZS5cbiAgICBmdW5jdGlvbiBnZXRTZXRPZmZzZXQoaW5wdXQsIGtlZXBMb2NhbFRpbWUsIGtlZXBNaW51dGVzKSB7XG4gICAgICAgIHZhciBvZmZzZXQgPSB0aGlzLl9vZmZzZXQgfHwgMCxcbiAgICAgICAgICAgIGxvY2FsQWRqdXN0O1xuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQgIT0gbnVsbCA/IHRoaXMgOiBOYU47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlucHV0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgaW5wdXQgPSBvZmZzZXRGcm9tU3RyaW5nKG1hdGNoU2hvcnRPZmZzZXQsIGlucHV0KTtcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChNYXRoLmFicyhpbnB1dCkgPCAxNiAmJiAha2VlcE1pbnV0ZXMpIHtcbiAgICAgICAgICAgICAgICBpbnB1dCA9IGlucHV0ICogNjA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2lzVVRDICYmIGtlZXBMb2NhbFRpbWUpIHtcbiAgICAgICAgICAgICAgICBsb2NhbEFkanVzdCA9IGdldERhdGVPZmZzZXQodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9vZmZzZXQgPSBpbnB1dDtcbiAgICAgICAgICAgIHRoaXMuX2lzVVRDID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChsb2NhbEFkanVzdCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGQobG9jYWxBZGp1c3QsICdtJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob2Zmc2V0ICE9PSBpbnB1dCkge1xuICAgICAgICAgICAgICAgIGlmICgha2VlcExvY2FsVGltZSB8fCB0aGlzLl9jaGFuZ2VJblByb2dyZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZFN1YnRyYWN0KFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNyZWF0ZUR1cmF0aW9uKGlucHV0IC0gb2Zmc2V0LCAnbScpLFxuICAgICAgICAgICAgICAgICAgICAgICAgMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICghdGhpcy5fY2hhbmdlSW5Qcm9ncmVzcykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jaGFuZ2VJblByb2dyZXNzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgaG9va3MudXBkYXRlT2Zmc2V0KHRoaXMsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jaGFuZ2VJblByb2dyZXNzID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pc1VUQyA/IG9mZnNldCA6IGdldERhdGVPZmZzZXQodGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTZXRab25lKGlucHV0LCBrZWVwTG9jYWxUaW1lKSB7XG4gICAgICAgIGlmIChpbnB1dCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGlucHV0ICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGlucHV0ID0gLWlucHV0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnV0Y09mZnNldChpbnB1dCwga2VlcExvY2FsVGltZSk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIC10aGlzLnV0Y09mZnNldCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0T2Zmc2V0VG9VVEMoa2VlcExvY2FsVGltZSkge1xuICAgICAgICByZXR1cm4gdGhpcy51dGNPZmZzZXQoMCwga2VlcExvY2FsVGltZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0T2Zmc2V0VG9Mb2NhbChrZWVwTG9jYWxUaW1lKSB7XG4gICAgICAgIGlmICh0aGlzLl9pc1VUQykge1xuICAgICAgICAgICAgdGhpcy51dGNPZmZzZXQoMCwga2VlcExvY2FsVGltZSk7XG4gICAgICAgICAgICB0aGlzLl9pc1VUQyA9IGZhbHNlO1xuXG4gICAgICAgICAgICBpZiAoa2VlcExvY2FsVGltZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3VidHJhY3QoZ2V0RGF0ZU9mZnNldCh0aGlzKSwgJ20nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRPZmZzZXRUb1BhcnNlZE9mZnNldCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3R6bSAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnV0Y09mZnNldCh0aGlzLl90em0sIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdGhpcy5faSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHZhciB0Wm9uZSA9IG9mZnNldEZyb21TdHJpbmcobWF0Y2hPZmZzZXQsIHRoaXMuX2kpO1xuICAgICAgICAgICAgaWYgKHRab25lICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnV0Y09mZnNldCh0Wm9uZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMudXRjT2Zmc2V0KDAsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhc0FsaWduZWRIb3VyT2Zmc2V0KGlucHV0KSB7XG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpbnB1dCA9IGlucHV0ID8gY3JlYXRlTG9jYWwoaW5wdXQpLnV0Y09mZnNldCgpIDogMDtcblxuICAgICAgICByZXR1cm4gKHRoaXMudXRjT2Zmc2V0KCkgLSBpbnB1dCkgJSA2MCA9PT0gMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0RheWxpZ2h0U2F2aW5nVGltZSgpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHRoaXMudXRjT2Zmc2V0KCkgPiB0aGlzLmNsb25lKCkubW9udGgoMCkudXRjT2Zmc2V0KCkgfHxcbiAgICAgICAgICAgIHRoaXMudXRjT2Zmc2V0KCkgPiB0aGlzLmNsb25lKCkubW9udGgoNSkudXRjT2Zmc2V0KClcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0RheWxpZ2h0U2F2aW5nVGltZVNoaWZ0ZWQoKSB7XG4gICAgICAgIGlmICghaXNVbmRlZmluZWQodGhpcy5faXNEU1RTaGlmdGVkKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2lzRFNUU2hpZnRlZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjID0ge30sXG4gICAgICAgICAgICBvdGhlcjtcblxuICAgICAgICBjb3B5Q29uZmlnKGMsIHRoaXMpO1xuICAgICAgICBjID0gcHJlcGFyZUNvbmZpZyhjKTtcblxuICAgICAgICBpZiAoYy5fYSkge1xuICAgICAgICAgICAgb3RoZXIgPSBjLl9pc1VUQyA/IGNyZWF0ZVVUQyhjLl9hKSA6IGNyZWF0ZUxvY2FsKGMuX2EpO1xuICAgICAgICAgICAgdGhpcy5faXNEU1RTaGlmdGVkID1cbiAgICAgICAgICAgICAgICB0aGlzLmlzVmFsaWQoKSAmJiBjb21wYXJlQXJyYXlzKGMuX2EsIG90aGVyLnRvQXJyYXkoKSkgPiAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5faXNEU1RTaGlmdGVkID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5faXNEU1RTaGlmdGVkO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzTG9jYWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzVmFsaWQoKSA/ICF0aGlzLl9pc1VUQyA6IGZhbHNlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzVXRjT2Zmc2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc1ZhbGlkKCkgPyB0aGlzLl9pc1VUQyA6IGZhbHNlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzVXRjKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc1ZhbGlkKCkgPyB0aGlzLl9pc1VUQyAmJiB0aGlzLl9vZmZzZXQgPT09IDAgOiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBBU1AuTkVUIGpzb24gZGF0ZSBmb3JtYXQgcmVnZXhcbiAgICB2YXIgYXNwTmV0UmVnZXggPSAvXigtfFxcKyk/KD86KFxcZCopWy4gXSk/KFxcZCspOihcXGQrKSg/OjooXFxkKykoXFwuXFxkKik/KT8kLyxcbiAgICAgICAgLy8gZnJvbSBodHRwOi8vZG9jcy5jbG9zdXJlLWxpYnJhcnkuZ29vZ2xlY29kZS5jb20vZ2l0L2Nsb3N1cmVfZ29vZ19kYXRlX2RhdGUuanMuc291cmNlLmh0bWxcbiAgICAgICAgLy8gc29tZXdoYXQgbW9yZSBpbiBsaW5lIHdpdGggNC40LjMuMiAyMDA0IHNwZWMsIGJ1dCBhbGxvd3MgZGVjaW1hbCBhbnl3aGVyZVxuICAgICAgICAvLyBhbmQgZnVydGhlciBtb2RpZmllZCB0byBhbGxvdyBmb3Igc3RyaW5ncyBjb250YWluaW5nIGJvdGggd2VlayBhbmQgZGF5XG4gICAgICAgIGlzb1JlZ2V4ID0gL14oLXxcXCspP1AoPzooWy0rXT9bMC05LC5dKilZKT8oPzooWy0rXT9bMC05LC5dKilNKT8oPzooWy0rXT9bMC05LC5dKilXKT8oPzooWy0rXT9bMC05LC5dKilEKT8oPzpUKD86KFstK10/WzAtOSwuXSopSCk/KD86KFstK10/WzAtOSwuXSopTSk/KD86KFstK10/WzAtOSwuXSopUyk/KT8kLztcblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUR1cmF0aW9uKGlucHV0LCBrZXkpIHtcbiAgICAgICAgdmFyIGR1cmF0aW9uID0gaW5wdXQsXG4gICAgICAgICAgICAvLyBtYXRjaGluZyBhZ2FpbnN0IHJlZ2V4cCBpcyBleHBlbnNpdmUsIGRvIGl0IG9uIGRlbWFuZFxuICAgICAgICAgICAgbWF0Y2ggPSBudWxsLFxuICAgICAgICAgICAgc2lnbixcbiAgICAgICAgICAgIHJldCxcbiAgICAgICAgICAgIGRpZmZSZXM7XG5cbiAgICAgICAgaWYgKGlzRHVyYXRpb24oaW5wdXQpKSB7XG4gICAgICAgICAgICBkdXJhdGlvbiA9IHtcbiAgICAgICAgICAgICAgICBtczogaW5wdXQuX21pbGxpc2Vjb25kcyxcbiAgICAgICAgICAgICAgICBkOiBpbnB1dC5fZGF5cyxcbiAgICAgICAgICAgICAgICBNOiBpbnB1dC5fbW9udGhzLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmIChpc051bWJlcihpbnB1dCkgfHwgIWlzTmFOKCtpbnB1dCkpIHtcbiAgICAgICAgICAgIGR1cmF0aW9uID0ge307XG4gICAgICAgICAgICBpZiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgZHVyYXRpb25ba2V5XSA9ICtpbnB1dDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZHVyYXRpb24ubWlsbGlzZWNvbmRzID0gK2lucHV0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKChtYXRjaCA9IGFzcE5ldFJlZ2V4LmV4ZWMoaW5wdXQpKSkge1xuICAgICAgICAgICAgc2lnbiA9IG1hdGNoWzFdID09PSAnLScgPyAtMSA6IDE7XG4gICAgICAgICAgICBkdXJhdGlvbiA9IHtcbiAgICAgICAgICAgICAgICB5OiAwLFxuICAgICAgICAgICAgICAgIGQ6IHRvSW50KG1hdGNoW0RBVEVdKSAqIHNpZ24sXG4gICAgICAgICAgICAgICAgaDogdG9JbnQobWF0Y2hbSE9VUl0pICogc2lnbixcbiAgICAgICAgICAgICAgICBtOiB0b0ludChtYXRjaFtNSU5VVEVdKSAqIHNpZ24sXG4gICAgICAgICAgICAgICAgczogdG9JbnQobWF0Y2hbU0VDT05EXSkgKiBzaWduLFxuICAgICAgICAgICAgICAgIG1zOiB0b0ludChhYnNSb3VuZChtYXRjaFtNSUxMSVNFQ09ORF0gKiAxMDAwKSkgKiBzaWduLCAvLyB0aGUgbWlsbGlzZWNvbmQgZGVjaW1hbCBwb2ludCBpcyBpbmNsdWRlZCBpbiB0aGUgbWF0Y2hcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAoKG1hdGNoID0gaXNvUmVnZXguZXhlYyhpbnB1dCkpKSB7XG4gICAgICAgICAgICBzaWduID0gbWF0Y2hbMV0gPT09ICctJyA/IC0xIDogMTtcbiAgICAgICAgICAgIGR1cmF0aW9uID0ge1xuICAgICAgICAgICAgICAgIHk6IHBhcnNlSXNvKG1hdGNoWzJdLCBzaWduKSxcbiAgICAgICAgICAgICAgICBNOiBwYXJzZUlzbyhtYXRjaFszXSwgc2lnbiksXG4gICAgICAgICAgICAgICAgdzogcGFyc2VJc28obWF0Y2hbNF0sIHNpZ24pLFxuICAgICAgICAgICAgICAgIGQ6IHBhcnNlSXNvKG1hdGNoWzVdLCBzaWduKSxcbiAgICAgICAgICAgICAgICBoOiBwYXJzZUlzbyhtYXRjaFs2XSwgc2lnbiksXG4gICAgICAgICAgICAgICAgbTogcGFyc2VJc28obWF0Y2hbN10sIHNpZ24pLFxuICAgICAgICAgICAgICAgIHM6IHBhcnNlSXNvKG1hdGNoWzhdLCBzaWduKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAoZHVyYXRpb24gPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gY2hlY2tzIGZvciBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgZHVyYXRpb24gPSB7fTtcbiAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgIHR5cGVvZiBkdXJhdGlvbiA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgICgnZnJvbScgaW4gZHVyYXRpb24gfHwgJ3RvJyBpbiBkdXJhdGlvbilcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBkaWZmUmVzID0gbW9tZW50c0RpZmZlcmVuY2UoXG4gICAgICAgICAgICAgICAgY3JlYXRlTG9jYWwoZHVyYXRpb24uZnJvbSksXG4gICAgICAgICAgICAgICAgY3JlYXRlTG9jYWwoZHVyYXRpb24udG8pXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBkdXJhdGlvbiA9IHt9O1xuICAgICAgICAgICAgZHVyYXRpb24ubXMgPSBkaWZmUmVzLm1pbGxpc2Vjb25kcztcbiAgICAgICAgICAgIGR1cmF0aW9uLk0gPSBkaWZmUmVzLm1vbnRocztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldCA9IG5ldyBEdXJhdGlvbihkdXJhdGlvbik7XG5cbiAgICAgICAgaWYgKGlzRHVyYXRpb24oaW5wdXQpICYmIGhhc093blByb3AoaW5wdXQsICdfbG9jYWxlJykpIHtcbiAgICAgICAgICAgIHJldC5fbG9jYWxlID0gaW5wdXQuX2xvY2FsZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0R1cmF0aW9uKGlucHV0KSAmJiBoYXNPd25Qcm9wKGlucHV0LCAnX2lzVmFsaWQnKSkge1xuICAgICAgICAgICAgcmV0Ll9pc1ZhbGlkID0gaW5wdXQuX2lzVmFsaWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cblxuICAgIGNyZWF0ZUR1cmF0aW9uLmZuID0gRHVyYXRpb24ucHJvdG90eXBlO1xuICAgIGNyZWF0ZUR1cmF0aW9uLmludmFsaWQgPSBjcmVhdGVJbnZhbGlkJDE7XG5cbiAgICBmdW5jdGlvbiBwYXJzZUlzbyhpbnAsIHNpZ24pIHtcbiAgICAgICAgLy8gV2UnZCBub3JtYWxseSB1c2Ugfn5pbnAgZm9yIHRoaXMsIGJ1dCB1bmZvcnR1bmF0ZWx5IGl0IGFsc29cbiAgICAgICAgLy8gY29udmVydHMgZmxvYXRzIHRvIGludHMuXG4gICAgICAgIC8vIGlucCBtYXkgYmUgdW5kZWZpbmVkLCBzbyBjYXJlZnVsIGNhbGxpbmcgcmVwbGFjZSBvbiBpdC5cbiAgICAgICAgdmFyIHJlcyA9IGlucCAmJiBwYXJzZUZsb2F0KGlucC5yZXBsYWNlKCcsJywgJy4nKSk7XG4gICAgICAgIC8vIGFwcGx5IHNpZ24gd2hpbGUgd2UncmUgYXQgaXRcbiAgICAgICAgcmV0dXJuIChpc05hTihyZXMpID8gMCA6IHJlcykgKiBzaWduO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBvc2l0aXZlTW9tZW50c0RpZmZlcmVuY2UoYmFzZSwgb3RoZXIpIHtcbiAgICAgICAgdmFyIHJlcyA9IHt9O1xuXG4gICAgICAgIHJlcy5tb250aHMgPVxuICAgICAgICAgICAgb3RoZXIubW9udGgoKSAtIGJhc2UubW9udGgoKSArIChvdGhlci55ZWFyKCkgLSBiYXNlLnllYXIoKSkgKiAxMjtcbiAgICAgICAgaWYgKGJhc2UuY2xvbmUoKS5hZGQocmVzLm1vbnRocywgJ00nKS5pc0FmdGVyKG90aGVyKSkge1xuICAgICAgICAgICAgLS1yZXMubW9udGhzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzLm1pbGxpc2Vjb25kcyA9ICtvdGhlciAtICtiYXNlLmNsb25lKCkuYWRkKHJlcy5tb250aHMsICdNJyk7XG5cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtb21lbnRzRGlmZmVyZW5jZShiYXNlLCBvdGhlcikge1xuICAgICAgICB2YXIgcmVzO1xuICAgICAgICBpZiAoIShiYXNlLmlzVmFsaWQoKSAmJiBvdGhlci5pc1ZhbGlkKCkpKSB7XG4gICAgICAgICAgICByZXR1cm4geyBtaWxsaXNlY29uZHM6IDAsIG1vbnRoczogMCB9O1xuICAgICAgICB9XG5cbiAgICAgICAgb3RoZXIgPSBjbG9uZVdpdGhPZmZzZXQob3RoZXIsIGJhc2UpO1xuICAgICAgICBpZiAoYmFzZS5pc0JlZm9yZShvdGhlcikpIHtcbiAgICAgICAgICAgIHJlcyA9IHBvc2l0aXZlTW9tZW50c0RpZmZlcmVuY2UoYmFzZSwgb3RoZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzID0gcG9zaXRpdmVNb21lbnRzRGlmZmVyZW5jZShvdGhlciwgYmFzZSk7XG4gICAgICAgICAgICByZXMubWlsbGlzZWNvbmRzID0gLXJlcy5taWxsaXNlY29uZHM7XG4gICAgICAgICAgICByZXMubW9udGhzID0gLXJlcy5tb250aHM7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIC8vIFRPRE86IHJlbW92ZSAnbmFtZScgYXJnIGFmdGVyIGRlcHJlY2F0aW9uIGlzIHJlbW92ZWRcbiAgICBmdW5jdGlvbiBjcmVhdGVBZGRlcihkaXJlY3Rpb24sIG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2YWwsIHBlcmlvZCkge1xuICAgICAgICAgICAgdmFyIGR1ciwgdG1wO1xuICAgICAgICAgICAgLy9pbnZlcnQgdGhlIGFyZ3VtZW50cywgYnV0IGNvbXBsYWluIGFib3V0IGl0XG4gICAgICAgICAgICBpZiAocGVyaW9kICE9PSBudWxsICYmICFpc05hTigrcGVyaW9kKSkge1xuICAgICAgICAgICAgICAgIGRlcHJlY2F0ZVNpbXBsZShcbiAgICAgICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgJ21vbWVudCgpLicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSArXG4gICAgICAgICAgICAgICAgICAgICAgICAnKHBlcmlvZCwgbnVtYmVyKSBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIG1vbWVudCgpLicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSArXG4gICAgICAgICAgICAgICAgICAgICAgICAnKG51bWJlciwgcGVyaW9kKS4gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnU2VlIGh0dHA6Ly9tb21lbnRqcy5jb20vZ3VpZGVzLyMvd2FybmluZ3MvYWRkLWludmVydGVkLXBhcmFtLyBmb3IgbW9yZSBpbmZvLidcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHRtcCA9IHZhbDtcbiAgICAgICAgICAgICAgICB2YWwgPSBwZXJpb2Q7XG4gICAgICAgICAgICAgICAgcGVyaW9kID0gdG1wO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkdXIgPSBjcmVhdGVEdXJhdGlvbih2YWwsIHBlcmlvZCk7XG4gICAgICAgICAgICBhZGRTdWJ0cmFjdCh0aGlzLCBkdXIsIGRpcmVjdGlvbik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRTdWJ0cmFjdChtb20sIGR1cmF0aW9uLCBpc0FkZGluZywgdXBkYXRlT2Zmc2V0KSB7XG4gICAgICAgIHZhciBtaWxsaXNlY29uZHMgPSBkdXJhdGlvbi5fbWlsbGlzZWNvbmRzLFxuICAgICAgICAgICAgZGF5cyA9IGFic1JvdW5kKGR1cmF0aW9uLl9kYXlzKSxcbiAgICAgICAgICAgIG1vbnRocyA9IGFic1JvdW5kKGR1cmF0aW9uLl9tb250aHMpO1xuXG4gICAgICAgIGlmICghbW9tLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgLy8gTm8gb3BcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHVwZGF0ZU9mZnNldCA9IHVwZGF0ZU9mZnNldCA9PSBudWxsID8gdHJ1ZSA6IHVwZGF0ZU9mZnNldDtcblxuICAgICAgICBpZiAobW9udGhzKSB7XG4gICAgICAgICAgICBzZXRNb250aChtb20sIGdldChtb20sICdNb250aCcpICsgbW9udGhzICogaXNBZGRpbmcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXlzKSB7XG4gICAgICAgICAgICBzZXQkMShtb20sICdEYXRlJywgZ2V0KG1vbSwgJ0RhdGUnKSArIGRheXMgKiBpc0FkZGluZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1pbGxpc2Vjb25kcykge1xuICAgICAgICAgICAgbW9tLl9kLnNldFRpbWUobW9tLl9kLnZhbHVlT2YoKSArIG1pbGxpc2Vjb25kcyAqIGlzQWRkaW5nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodXBkYXRlT2Zmc2V0KSB7XG4gICAgICAgICAgICBob29rcy51cGRhdGVPZmZzZXQobW9tLCBkYXlzIHx8IG1vbnRocyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgYWRkID0gY3JlYXRlQWRkZXIoMSwgJ2FkZCcpLFxuICAgICAgICBzdWJ0cmFjdCA9IGNyZWF0ZUFkZGVyKC0xLCAnc3VidHJhY3QnKTtcblxuICAgIGZ1bmN0aW9uIGlzU3RyaW5nKGlucHV0KSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnIHx8IGlucHV0IGluc3RhbmNlb2YgU3RyaW5nO1xuICAgIH1cblxuICAgIC8vIHR5cGUgTW9tZW50SW5wdXQgPSBNb21lbnQgfCBEYXRlIHwgc3RyaW5nIHwgbnVtYmVyIHwgKG51bWJlciB8IHN0cmluZylbXSB8IE1vbWVudElucHV0T2JqZWN0IHwgdm9pZDsgLy8gbnVsbCB8IHVuZGVmaW5lZFxuICAgIGZ1bmN0aW9uIGlzTW9tZW50SW5wdXQoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIGlzTW9tZW50KGlucHV0KSB8fFxuICAgICAgICAgICAgaXNEYXRlKGlucHV0KSB8fFxuICAgICAgICAgICAgaXNTdHJpbmcoaW5wdXQpIHx8XG4gICAgICAgICAgICBpc051bWJlcihpbnB1dCkgfHxcbiAgICAgICAgICAgIGlzTnVtYmVyT3JTdHJpbmdBcnJheShpbnB1dCkgfHxcbiAgICAgICAgICAgIGlzTW9tZW50SW5wdXRPYmplY3QoaW5wdXQpIHx8XG4gICAgICAgICAgICBpbnB1dCA9PT0gbnVsbCB8fFxuICAgICAgICAgICAgaW5wdXQgPT09IHVuZGVmaW5lZFxuICAgICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzTW9tZW50SW5wdXRPYmplY3QoaW5wdXQpIHtcbiAgICAgICAgdmFyIG9iamVjdFRlc3QgPSBpc09iamVjdChpbnB1dCkgJiYgIWlzT2JqZWN0RW1wdHkoaW5wdXQpLFxuICAgICAgICAgICAgcHJvcGVydHlUZXN0ID0gZmFsc2UsXG4gICAgICAgICAgICBwcm9wZXJ0aWVzID0gW1xuICAgICAgICAgICAgICAgICd5ZWFycycsXG4gICAgICAgICAgICAgICAgJ3llYXInLFxuICAgICAgICAgICAgICAgICd5JyxcbiAgICAgICAgICAgICAgICAnbW9udGhzJyxcbiAgICAgICAgICAgICAgICAnbW9udGgnLFxuICAgICAgICAgICAgICAgICdNJyxcbiAgICAgICAgICAgICAgICAnZGF5cycsXG4gICAgICAgICAgICAgICAgJ2RheScsXG4gICAgICAgICAgICAgICAgJ2QnLFxuICAgICAgICAgICAgICAgICdkYXRlcycsXG4gICAgICAgICAgICAgICAgJ2RhdGUnLFxuICAgICAgICAgICAgICAgICdEJyxcbiAgICAgICAgICAgICAgICAnaG91cnMnLFxuICAgICAgICAgICAgICAgICdob3VyJyxcbiAgICAgICAgICAgICAgICAnaCcsXG4gICAgICAgICAgICAgICAgJ21pbnV0ZXMnLFxuICAgICAgICAgICAgICAgICdtaW51dGUnLFxuICAgICAgICAgICAgICAgICdtJyxcbiAgICAgICAgICAgICAgICAnc2Vjb25kcycsXG4gICAgICAgICAgICAgICAgJ3NlY29uZCcsXG4gICAgICAgICAgICAgICAgJ3MnLFxuICAgICAgICAgICAgICAgICdtaWxsaXNlY29uZHMnLFxuICAgICAgICAgICAgICAgICdtaWxsaXNlY29uZCcsXG4gICAgICAgICAgICAgICAgJ21zJyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBpLFxuICAgICAgICAgICAgcHJvcGVydHk7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHByb3BlcnRpZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIHByb3BlcnR5ID0gcHJvcGVydGllc1tpXTtcbiAgICAgICAgICAgIHByb3BlcnR5VGVzdCA9IHByb3BlcnR5VGVzdCB8fCBoYXNPd25Qcm9wKGlucHV0LCBwcm9wZXJ0eSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb2JqZWN0VGVzdCAmJiBwcm9wZXJ0eVRlc3Q7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNOdW1iZXJPclN0cmluZ0FycmF5KGlucHV0KSB7XG4gICAgICAgIHZhciBhcnJheVRlc3QgPSBpc0FycmF5KGlucHV0KSxcbiAgICAgICAgICAgIGRhdGFUeXBlVGVzdCA9IGZhbHNlO1xuICAgICAgICBpZiAoYXJyYXlUZXN0KSB7XG4gICAgICAgICAgICBkYXRhVHlwZVRlc3QgPVxuICAgICAgICAgICAgICAgIGlucHV0LmZpbHRlcihmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gIWlzTnVtYmVyKGl0ZW0pICYmIGlzU3RyaW5nKGlucHV0KTtcbiAgICAgICAgICAgICAgICB9KS5sZW5ndGggPT09IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFycmF5VGVzdCAmJiBkYXRhVHlwZVRlc3Q7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNDYWxlbmRhclNwZWMoaW5wdXQpIHtcbiAgICAgICAgdmFyIG9iamVjdFRlc3QgPSBpc09iamVjdChpbnB1dCkgJiYgIWlzT2JqZWN0RW1wdHkoaW5wdXQpLFxuICAgICAgICAgICAgcHJvcGVydHlUZXN0ID0gZmFsc2UsXG4gICAgICAgICAgICBwcm9wZXJ0aWVzID0gW1xuICAgICAgICAgICAgICAgICdzYW1lRGF5JyxcbiAgICAgICAgICAgICAgICAnbmV4dERheScsXG4gICAgICAgICAgICAgICAgJ2xhc3REYXknLFxuICAgICAgICAgICAgICAgICduZXh0V2VlaycsXG4gICAgICAgICAgICAgICAgJ2xhc3RXZWVrJyxcbiAgICAgICAgICAgICAgICAnc2FtZUVsc2UnLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICBwcm9wZXJ0eTtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcHJvcGVydGllcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgcHJvcGVydHkgPSBwcm9wZXJ0aWVzW2ldO1xuICAgICAgICAgICAgcHJvcGVydHlUZXN0ID0gcHJvcGVydHlUZXN0IHx8IGhhc093blByb3AoaW5wdXQsIHByb3BlcnR5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvYmplY3RUZXN0ICYmIHByb3BlcnR5VGVzdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRDYWxlbmRhckZvcm1hdChteU1vbWVudCwgbm93KSB7XG4gICAgICAgIHZhciBkaWZmID0gbXlNb21lbnQuZGlmZihub3csICdkYXlzJywgdHJ1ZSk7XG4gICAgICAgIHJldHVybiBkaWZmIDwgLTZcbiAgICAgICAgICAgID8gJ3NhbWVFbHNlJ1xuICAgICAgICAgICAgOiBkaWZmIDwgLTFcbiAgICAgICAgICAgID8gJ2xhc3RXZWVrJ1xuICAgICAgICAgICAgOiBkaWZmIDwgMFxuICAgICAgICAgICAgPyAnbGFzdERheSdcbiAgICAgICAgICAgIDogZGlmZiA8IDFcbiAgICAgICAgICAgID8gJ3NhbWVEYXknXG4gICAgICAgICAgICA6IGRpZmYgPCAyXG4gICAgICAgICAgICA/ICduZXh0RGF5J1xuICAgICAgICAgICAgOiBkaWZmIDwgN1xuICAgICAgICAgICAgPyAnbmV4dFdlZWsnXG4gICAgICAgICAgICA6ICdzYW1lRWxzZSc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2FsZW5kYXIkMSh0aW1lLCBmb3JtYXRzKSB7XG4gICAgICAgIC8vIFN1cHBvcnQgZm9yIHNpbmdsZSBwYXJhbWV0ZXIsIGZvcm1hdHMgb25seSBvdmVybG9hZCB0byB0aGUgY2FsZW5kYXIgZnVuY3Rpb25cbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIGlmICghYXJndW1lbnRzWzBdKSB7XG4gICAgICAgICAgICAgICAgdGltZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBmb3JtYXRzID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpc01vbWVudElucHV0KGFyZ3VtZW50c1swXSkpIHtcbiAgICAgICAgICAgICAgICB0aW1lID0gYXJndW1lbnRzWzBdO1xuICAgICAgICAgICAgICAgIGZvcm1hdHMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzQ2FsZW5kYXJTcGVjKGFyZ3VtZW50c1swXSkpIHtcbiAgICAgICAgICAgICAgICBmb3JtYXRzID0gYXJndW1lbnRzWzBdO1xuICAgICAgICAgICAgICAgIHRpbWUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2Ugd2FudCB0byBjb21wYXJlIHRoZSBzdGFydCBvZiB0b2RheSwgdnMgdGhpcy5cbiAgICAgICAgLy8gR2V0dGluZyBzdGFydC1vZi10b2RheSBkZXBlbmRzIG9uIHdoZXRoZXIgd2UncmUgbG9jYWwvdXRjL29mZnNldCBvciBub3QuXG4gICAgICAgIHZhciBub3cgPSB0aW1lIHx8IGNyZWF0ZUxvY2FsKCksXG4gICAgICAgICAgICBzb2QgPSBjbG9uZVdpdGhPZmZzZXQobm93LCB0aGlzKS5zdGFydE9mKCdkYXknKSxcbiAgICAgICAgICAgIGZvcm1hdCA9IGhvb2tzLmNhbGVuZGFyRm9ybWF0KHRoaXMsIHNvZCkgfHwgJ3NhbWVFbHNlJyxcbiAgICAgICAgICAgIG91dHB1dCA9XG4gICAgICAgICAgICAgICAgZm9ybWF0cyAmJlxuICAgICAgICAgICAgICAgIChpc0Z1bmN0aW9uKGZvcm1hdHNbZm9ybWF0XSlcbiAgICAgICAgICAgICAgICAgICAgPyBmb3JtYXRzW2Zvcm1hdF0uY2FsbCh0aGlzLCBub3cpXG4gICAgICAgICAgICAgICAgICAgIDogZm9ybWF0c1tmb3JtYXRdKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5mb3JtYXQoXG4gICAgICAgICAgICBvdXRwdXQgfHwgdGhpcy5sb2NhbGVEYXRhKCkuY2FsZW5kYXIoZm9ybWF0LCB0aGlzLCBjcmVhdGVMb2NhbChub3cpKVxuICAgICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsb25lKCkge1xuICAgICAgICByZXR1cm4gbmV3IE1vbWVudCh0aGlzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0FmdGVyKGlucHV0LCB1bml0cykge1xuICAgICAgICB2YXIgbG9jYWxJbnB1dCA9IGlzTW9tZW50KGlucHV0KSA/IGlucHV0IDogY3JlYXRlTG9jYWwoaW5wdXQpO1xuICAgICAgICBpZiAoISh0aGlzLmlzVmFsaWQoKSAmJiBsb2NhbElucHV0LmlzVmFsaWQoKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKSB8fCAnbWlsbGlzZWNvbmQnO1xuICAgICAgICBpZiAodW5pdHMgPT09ICdtaWxsaXNlY29uZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlT2YoKSA+IGxvY2FsSW5wdXQudmFsdWVPZigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsSW5wdXQudmFsdWVPZigpIDwgdGhpcy5jbG9uZSgpLnN0YXJ0T2YodW5pdHMpLnZhbHVlT2YoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzQmVmb3JlKGlucHV0LCB1bml0cykge1xuICAgICAgICB2YXIgbG9jYWxJbnB1dCA9IGlzTW9tZW50KGlucHV0KSA/IGlucHV0IDogY3JlYXRlTG9jYWwoaW5wdXQpO1xuICAgICAgICBpZiAoISh0aGlzLmlzVmFsaWQoKSAmJiBsb2NhbElucHV0LmlzVmFsaWQoKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKSB8fCAnbWlsbGlzZWNvbmQnO1xuICAgICAgICBpZiAodW5pdHMgPT09ICdtaWxsaXNlY29uZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlT2YoKSA8IGxvY2FsSW5wdXQudmFsdWVPZigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5lbmRPZih1bml0cykudmFsdWVPZigpIDwgbG9jYWxJbnB1dC52YWx1ZU9mKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0JldHdlZW4oZnJvbSwgdG8sIHVuaXRzLCBpbmNsdXNpdml0eSkge1xuICAgICAgICB2YXIgbG9jYWxGcm9tID0gaXNNb21lbnQoZnJvbSkgPyBmcm9tIDogY3JlYXRlTG9jYWwoZnJvbSksXG4gICAgICAgICAgICBsb2NhbFRvID0gaXNNb21lbnQodG8pID8gdG8gOiBjcmVhdGVMb2NhbCh0byk7XG4gICAgICAgIGlmICghKHRoaXMuaXNWYWxpZCgpICYmIGxvY2FsRnJvbS5pc1ZhbGlkKCkgJiYgbG9jYWxUby5pc1ZhbGlkKCkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaW5jbHVzaXZpdHkgPSBpbmNsdXNpdml0eSB8fCAnKCknO1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgKGluY2x1c2l2aXR5WzBdID09PSAnKCdcbiAgICAgICAgICAgICAgICA/IHRoaXMuaXNBZnRlcihsb2NhbEZyb20sIHVuaXRzKVxuICAgICAgICAgICAgICAgIDogIXRoaXMuaXNCZWZvcmUobG9jYWxGcm9tLCB1bml0cykpICYmXG4gICAgICAgICAgICAoaW5jbHVzaXZpdHlbMV0gPT09ICcpJ1xuICAgICAgICAgICAgICAgID8gdGhpcy5pc0JlZm9yZShsb2NhbFRvLCB1bml0cylcbiAgICAgICAgICAgICAgICA6ICF0aGlzLmlzQWZ0ZXIobG9jYWxUbywgdW5pdHMpKVxuICAgICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzU2FtZShpbnB1dCwgdW5pdHMpIHtcbiAgICAgICAgdmFyIGxvY2FsSW5wdXQgPSBpc01vbWVudChpbnB1dCkgPyBpbnB1dCA6IGNyZWF0ZUxvY2FsKGlucHV0KSxcbiAgICAgICAgICAgIGlucHV0TXM7XG4gICAgICAgIGlmICghKHRoaXMuaXNWYWxpZCgpICYmIGxvY2FsSW5wdXQuaXNWYWxpZCgpKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpIHx8ICdtaWxsaXNlY29uZCc7XG4gICAgICAgIGlmICh1bml0cyA9PT0gJ21pbGxpc2Vjb25kJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVPZigpID09PSBsb2NhbElucHV0LnZhbHVlT2YoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlucHV0TXMgPSBsb2NhbElucHV0LnZhbHVlT2YoKTtcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgdGhpcy5jbG9uZSgpLnN0YXJ0T2YodW5pdHMpLnZhbHVlT2YoKSA8PSBpbnB1dE1zICYmXG4gICAgICAgICAgICAgICAgaW5wdXRNcyA8PSB0aGlzLmNsb25lKCkuZW5kT2YodW5pdHMpLnZhbHVlT2YoKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzU2FtZU9yQWZ0ZXIoaW5wdXQsIHVuaXRzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzU2FtZShpbnB1dCwgdW5pdHMpIHx8IHRoaXMuaXNBZnRlcihpbnB1dCwgdW5pdHMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzU2FtZU9yQmVmb3JlKGlucHV0LCB1bml0cykge1xuICAgICAgICByZXR1cm4gdGhpcy5pc1NhbWUoaW5wdXQsIHVuaXRzKSB8fCB0aGlzLmlzQmVmb3JlKGlucHV0LCB1bml0cyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGlmZihpbnB1dCwgdW5pdHMsIGFzRmxvYXQpIHtcbiAgICAgICAgdmFyIHRoYXQsIHpvbmVEZWx0YSwgb3V0cHV0O1xuXG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBOYU47XG4gICAgICAgIH1cblxuICAgICAgICB0aGF0ID0gY2xvbmVXaXRoT2Zmc2V0KGlucHV0LCB0aGlzKTtcblxuICAgICAgICBpZiAoIXRoYXQuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgICB9XG5cbiAgICAgICAgem9uZURlbHRhID0gKHRoYXQudXRjT2Zmc2V0KCkgLSB0aGlzLnV0Y09mZnNldCgpKSAqIDZlNDtcblxuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcblxuICAgICAgICBzd2l0Y2ggKHVuaXRzKSB7XG4gICAgICAgICAgICBjYXNlICd5ZWFyJzpcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSBtb250aERpZmYodGhpcywgdGhhdCkgLyAxMjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ21vbnRoJzpcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSBtb250aERpZmYodGhpcywgdGhhdCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdxdWFydGVyJzpcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSBtb250aERpZmYodGhpcywgdGhhdCkgLyAzO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnc2Vjb25kJzpcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSAodGhpcyAtIHRoYXQpIC8gMWUzO1xuICAgICAgICAgICAgICAgIGJyZWFrOyAvLyAxMDAwXG4gICAgICAgICAgICBjYXNlICdtaW51dGUnOlxuICAgICAgICAgICAgICAgIG91dHB1dCA9ICh0aGlzIC0gdGhhdCkgLyA2ZTQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7IC8vIDEwMDAgKiA2MFxuICAgICAgICAgICAgY2FzZSAnaG91cic6XG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gKHRoaXMgLSB0aGF0KSAvIDM2ZTU7XG4gICAgICAgICAgICAgICAgYnJlYWs7IC8vIDEwMDAgKiA2MCAqIDYwXG4gICAgICAgICAgICBjYXNlICdkYXknOlxuICAgICAgICAgICAgICAgIG91dHB1dCA9ICh0aGlzIC0gdGhhdCAtIHpvbmVEZWx0YSkgLyA4NjRlNTtcbiAgICAgICAgICAgICAgICBicmVhazsgLy8gMTAwMCAqIDYwICogNjAgKiAyNCwgbmVnYXRlIGRzdFxuICAgICAgICAgICAgY2FzZSAnd2Vlayc6XG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gKHRoaXMgLSB0aGF0IC0gem9uZURlbHRhKSAvIDYwNDhlNTtcbiAgICAgICAgICAgICAgICBicmVhazsgLy8gMTAwMCAqIDYwICogNjAgKiAyNCAqIDcsIG5lZ2F0ZSBkc3RcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gdGhpcyAtIHRoYXQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXNGbG9hdCA/IG91dHB1dCA6IGFic0Zsb29yKG91dHB1dCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbW9udGhEaWZmKGEsIGIpIHtcbiAgICAgICAgaWYgKGEuZGF0ZSgpIDwgYi5kYXRlKCkpIHtcbiAgICAgICAgICAgIC8vIGVuZC1vZi1tb250aCBjYWxjdWxhdGlvbnMgd29yayBjb3JyZWN0IHdoZW4gdGhlIHN0YXJ0IG1vbnRoIGhhcyBtb3JlXG4gICAgICAgICAgICAvLyBkYXlzIHRoYW4gdGhlIGVuZCBtb250aC5cbiAgICAgICAgICAgIHJldHVybiAtbW9udGhEaWZmKGIsIGEpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGRpZmZlcmVuY2UgaW4gbW9udGhzXG4gICAgICAgIHZhciB3aG9sZU1vbnRoRGlmZiA9IChiLnllYXIoKSAtIGEueWVhcigpKSAqIDEyICsgKGIubW9udGgoKSAtIGEubW9udGgoKSksXG4gICAgICAgICAgICAvLyBiIGlzIGluIChhbmNob3IgLSAxIG1vbnRoLCBhbmNob3IgKyAxIG1vbnRoKVxuICAgICAgICAgICAgYW5jaG9yID0gYS5jbG9uZSgpLmFkZCh3aG9sZU1vbnRoRGlmZiwgJ21vbnRocycpLFxuICAgICAgICAgICAgYW5jaG9yMixcbiAgICAgICAgICAgIGFkanVzdDtcblxuICAgICAgICBpZiAoYiAtIGFuY2hvciA8IDApIHtcbiAgICAgICAgICAgIGFuY2hvcjIgPSBhLmNsb25lKCkuYWRkKHdob2xlTW9udGhEaWZmIC0gMSwgJ21vbnRocycpO1xuICAgICAgICAgICAgLy8gbGluZWFyIGFjcm9zcyB0aGUgbW9udGhcbiAgICAgICAgICAgIGFkanVzdCA9IChiIC0gYW5jaG9yKSAvIChhbmNob3IgLSBhbmNob3IyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFuY2hvcjIgPSBhLmNsb25lKCkuYWRkKHdob2xlTW9udGhEaWZmICsgMSwgJ21vbnRocycpO1xuICAgICAgICAgICAgLy8gbGluZWFyIGFjcm9zcyB0aGUgbW9udGhcbiAgICAgICAgICAgIGFkanVzdCA9IChiIC0gYW5jaG9yKSAvIChhbmNob3IyIC0gYW5jaG9yKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vY2hlY2sgZm9yIG5lZ2F0aXZlIHplcm8sIHJldHVybiB6ZXJvIGlmIG5lZ2F0aXZlIHplcm9cbiAgICAgICAgcmV0dXJuIC0od2hvbGVNb250aERpZmYgKyBhZGp1c3QpIHx8IDA7XG4gICAgfVxuXG4gICAgaG9va3MuZGVmYXVsdEZvcm1hdCA9ICdZWVlZLU1NLUREVEhIOm1tOnNzWic7XG4gICAgaG9va3MuZGVmYXVsdEZvcm1hdFV0YyA9ICdZWVlZLU1NLUREVEhIOm1tOnNzW1pdJztcblxuICAgIGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmxvY2FsZSgnZW4nKS5mb3JtYXQoJ2RkZCBNTU0gREQgWVlZWSBISDptbTpzcyBbR01UXVpaJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9JU09TdHJpbmcoa2VlcE9mZnNldCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdXRjID0ga2VlcE9mZnNldCAhPT0gdHJ1ZSxcbiAgICAgICAgICAgIG0gPSB1dGMgPyB0aGlzLmNsb25lKCkudXRjKCkgOiB0aGlzO1xuICAgICAgICBpZiAobS55ZWFyKCkgPCAwIHx8IG0ueWVhcigpID4gOTk5OSkge1xuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdE1vbWVudChcbiAgICAgICAgICAgICAgICBtLFxuICAgICAgICAgICAgICAgIHV0Y1xuICAgICAgICAgICAgICAgICAgICA/ICdZWVlZWVktTU0tRERbVF1ISDptbTpzcy5TU1NbWl0nXG4gICAgICAgICAgICAgICAgICAgIDogJ1lZWVlZWS1NTS1ERFtUXUhIOm1tOnNzLlNTU1onXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKERhdGUucHJvdG90eXBlLnRvSVNPU3RyaW5nKSkge1xuICAgICAgICAgICAgLy8gbmF0aXZlIGltcGxlbWVudGF0aW9uIGlzIH41MHggZmFzdGVyLCB1c2UgaXQgd2hlbiB3ZSBjYW5cbiAgICAgICAgICAgIGlmICh1dGMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50b0RhdGUoKS50b0lTT1N0cmluZygpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IERhdGUodGhpcy52YWx1ZU9mKCkgKyB0aGlzLnV0Y09mZnNldCgpICogNjAgKiAxMDAwKVxuICAgICAgICAgICAgICAgICAgICAudG9JU09TdHJpbmcoKVxuICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgnWicsIGZvcm1hdE1vbWVudChtLCAnWicpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm9ybWF0TW9tZW50KFxuICAgICAgICAgICAgbSxcbiAgICAgICAgICAgIHV0YyA/ICdZWVlZLU1NLUREW1RdSEg6bW06c3MuU1NTW1pdJyA6ICdZWVlZLU1NLUREW1RdSEg6bW06c3MuU1NTWidcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSBodW1hbiByZWFkYWJsZSByZXByZXNlbnRhdGlvbiBvZiBhIG1vbWVudCB0aGF0IGNhblxuICAgICAqIGFsc28gYmUgZXZhbHVhdGVkIHRvIGdldCBhIG5ldyBtb21lbnQgd2hpY2ggaXMgdGhlIHNhbWVcbiAgICAgKlxuICAgICAqIEBsaW5rIGh0dHBzOi8vbm9kZWpzLm9yZy9kaXN0L2xhdGVzdC9kb2NzL2FwaS91dGlsLmh0bWwjdXRpbF9jdXN0b21faW5zcGVjdF9mdW5jdGlvbl9vbl9vYmplY3RzXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5zcGVjdCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuICdtb21lbnQuaW52YWxpZCgvKiAnICsgdGhpcy5faSArICcgKi8pJztcbiAgICAgICAgfVxuICAgICAgICB2YXIgZnVuYyA9ICdtb21lbnQnLFxuICAgICAgICAgICAgem9uZSA9ICcnLFxuICAgICAgICAgICAgcHJlZml4LFxuICAgICAgICAgICAgeWVhcixcbiAgICAgICAgICAgIGRhdGV0aW1lLFxuICAgICAgICAgICAgc3VmZml4O1xuICAgICAgICBpZiAoIXRoaXMuaXNMb2NhbCgpKSB7XG4gICAgICAgICAgICBmdW5jID0gdGhpcy51dGNPZmZzZXQoKSA9PT0gMCA/ICdtb21lbnQudXRjJyA6ICdtb21lbnQucGFyc2Vab25lJztcbiAgICAgICAgICAgIHpvbmUgPSAnWic7XG4gICAgICAgIH1cbiAgICAgICAgcHJlZml4ID0gJ1snICsgZnVuYyArICcoXCJdJztcbiAgICAgICAgeWVhciA9IDAgPD0gdGhpcy55ZWFyKCkgJiYgdGhpcy55ZWFyKCkgPD0gOTk5OSA/ICdZWVlZJyA6ICdZWVlZWVknO1xuICAgICAgICBkYXRldGltZSA9ICctTU0tRERbVF1ISDptbTpzcy5TU1MnO1xuICAgICAgICBzdWZmaXggPSB6b25lICsgJ1tcIildJztcblxuICAgICAgICByZXR1cm4gdGhpcy5mb3JtYXQocHJlZml4ICsgeWVhciArIGRhdGV0aW1lICsgc3VmZml4KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmb3JtYXQoaW5wdXRTdHJpbmcpIHtcbiAgICAgICAgaWYgKCFpbnB1dFN0cmluZykge1xuICAgICAgICAgICAgaW5wdXRTdHJpbmcgPSB0aGlzLmlzVXRjKClcbiAgICAgICAgICAgICAgICA/IGhvb2tzLmRlZmF1bHRGb3JtYXRVdGNcbiAgICAgICAgICAgICAgICA6IGhvb2tzLmRlZmF1bHRGb3JtYXQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG91dHB1dCA9IGZvcm1hdE1vbWVudCh0aGlzLCBpbnB1dFN0cmluZyk7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5wb3N0Zm9ybWF0KG91dHB1dCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZnJvbSh0aW1lLCB3aXRob3V0U3VmZml4KSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIHRoaXMuaXNWYWxpZCgpICYmXG4gICAgICAgICAgICAoKGlzTW9tZW50KHRpbWUpICYmIHRpbWUuaXNWYWxpZCgpKSB8fCBjcmVhdGVMb2NhbCh0aW1lKS5pc1ZhbGlkKCkpXG4gICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUR1cmF0aW9uKHsgdG86IHRoaXMsIGZyb206IHRpbWUgfSlcbiAgICAgICAgICAgICAgICAubG9jYWxlKHRoaXMubG9jYWxlKCkpXG4gICAgICAgICAgICAgICAgLmh1bWFuaXplKCF3aXRob3V0U3VmZml4KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5pbnZhbGlkRGF0ZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZnJvbU5vdyh3aXRob3V0U3VmZml4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZyb20oY3JlYXRlTG9jYWwoKSwgd2l0aG91dFN1ZmZpeCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG8odGltZSwgd2l0aG91dFN1ZmZpeCkge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgICB0aGlzLmlzVmFsaWQoKSAmJlxuICAgICAgICAgICAgKChpc01vbWVudCh0aW1lKSAmJiB0aW1lLmlzVmFsaWQoKSkgfHwgY3JlYXRlTG9jYWwodGltZSkuaXNWYWxpZCgpKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVEdXJhdGlvbih7IGZyb206IHRoaXMsIHRvOiB0aW1lIH0pXG4gICAgICAgICAgICAgICAgLmxvY2FsZSh0aGlzLmxvY2FsZSgpKVxuICAgICAgICAgICAgICAgIC5odW1hbml6ZSghd2l0aG91dFN1ZmZpeCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkuaW52YWxpZERhdGUoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvTm93KHdpdGhvdXRTdWZmaXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG8oY3JlYXRlTG9jYWwoKSwgd2l0aG91dFN1ZmZpeCk7XG4gICAgfVxuXG4gICAgLy8gSWYgcGFzc2VkIGEgbG9jYWxlIGtleSwgaXQgd2lsbCBzZXQgdGhlIGxvY2FsZSBmb3IgdGhpc1xuICAgIC8vIGluc3RhbmNlLiAgT3RoZXJ3aXNlLCBpdCB3aWxsIHJldHVybiB0aGUgbG9jYWxlIGNvbmZpZ3VyYXRpb25cbiAgICAvLyB2YXJpYWJsZXMgZm9yIHRoaXMgaW5zdGFuY2UuXG4gICAgZnVuY3Rpb24gbG9jYWxlKGtleSkge1xuICAgICAgICB2YXIgbmV3TG9jYWxlRGF0YTtcblxuICAgICAgICBpZiAoa2V5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9sb2NhbGUuX2FiYnI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXdMb2NhbGVEYXRhID0gZ2V0TG9jYWxlKGtleSk7XG4gICAgICAgICAgICBpZiAobmV3TG9jYWxlRGF0YSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbG9jYWxlID0gbmV3TG9jYWxlRGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGxhbmcgPSBkZXByZWNhdGUoXG4gICAgICAgICdtb21lbnQoKS5sYW5nKCkgaXMgZGVwcmVjYXRlZC4gSW5zdGVhZCwgdXNlIG1vbWVudCgpLmxvY2FsZURhdGEoKSB0byBnZXQgdGhlIGxhbmd1YWdlIGNvbmZpZ3VyYXRpb24uIFVzZSBtb21lbnQoKS5sb2NhbGUoKSB0byBjaGFuZ2UgbGFuZ3VhZ2VzLicsXG4gICAgICAgIGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIGlmIChrZXkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICApO1xuXG4gICAgZnVuY3Rpb24gbG9jYWxlRGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvY2FsZTtcbiAgICB9XG5cbiAgICB2YXIgTVNfUEVSX1NFQ09ORCA9IDEwMDAsXG4gICAgICAgIE1TX1BFUl9NSU5VVEUgPSA2MCAqIE1TX1BFUl9TRUNPTkQsXG4gICAgICAgIE1TX1BFUl9IT1VSID0gNjAgKiBNU19QRVJfTUlOVVRFLFxuICAgICAgICBNU19QRVJfNDAwX1lFQVJTID0gKDM2NSAqIDQwMCArIDk3KSAqIDI0ICogTVNfUEVSX0hPVVI7XG5cbiAgICAvLyBhY3R1YWwgbW9kdWxvIC0gaGFuZGxlcyBuZWdhdGl2ZSBudW1iZXJzIChmb3IgZGF0ZXMgYmVmb3JlIDE5NzApOlxuICAgIGZ1bmN0aW9uIG1vZCQxKGRpdmlkZW5kLCBkaXZpc29yKSB7XG4gICAgICAgIHJldHVybiAoKGRpdmlkZW5kICUgZGl2aXNvcikgKyBkaXZpc29yKSAlIGRpdmlzb3I7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9jYWxTdGFydE9mRGF0ZSh5LCBtLCBkKSB7XG4gICAgICAgIC8vIHRoZSBkYXRlIGNvbnN0cnVjdG9yIHJlbWFwcyB5ZWFycyAwLTk5IHRvIDE5MDAtMTk5OVxuICAgICAgICBpZiAoeSA8IDEwMCAmJiB5ID49IDApIHtcbiAgICAgICAgICAgIC8vIHByZXNlcnZlIGxlYXAgeWVhcnMgdXNpbmcgYSBmdWxsIDQwMCB5ZWFyIGN5Y2xlLCB0aGVuIHJlc2V0XG4gICAgICAgICAgICByZXR1cm4gbmV3IERhdGUoeSArIDQwMCwgbSwgZCkgLSBNU19QRVJfNDAwX1lFQVJTO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHksIG0sIGQpLnZhbHVlT2YoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHV0Y1N0YXJ0T2ZEYXRlKHksIG0sIGQpIHtcbiAgICAgICAgLy8gRGF0ZS5VVEMgcmVtYXBzIHllYXJzIDAtOTkgdG8gMTkwMC0xOTk5XG4gICAgICAgIGlmICh5IDwgMTAwICYmIHkgPj0gMCkge1xuICAgICAgICAgICAgLy8gcHJlc2VydmUgbGVhcCB5ZWFycyB1c2luZyBhIGZ1bGwgNDAwIHllYXIgY3ljbGUsIHRoZW4gcmVzZXRcbiAgICAgICAgICAgIHJldHVybiBEYXRlLlVUQyh5ICsgNDAwLCBtLCBkKSAtIE1TX1BFUl80MDBfWUVBUlM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gRGF0ZS5VVEMoeSwgbSwgZCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzdGFydE9mKHVuaXRzKSB7XG4gICAgICAgIHZhciB0aW1lLCBzdGFydE9mRGF0ZTtcbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG4gICAgICAgIGlmICh1bml0cyA9PT0gdW5kZWZpbmVkIHx8IHVuaXRzID09PSAnbWlsbGlzZWNvbmQnIHx8ICF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICBzdGFydE9mRGF0ZSA9IHRoaXMuX2lzVVRDID8gdXRjU3RhcnRPZkRhdGUgOiBsb2NhbFN0YXJ0T2ZEYXRlO1xuXG4gICAgICAgIHN3aXRjaCAodW5pdHMpIHtcbiAgICAgICAgICAgIGNhc2UgJ3llYXInOlxuICAgICAgICAgICAgICAgIHRpbWUgPSBzdGFydE9mRGF0ZSh0aGlzLnllYXIoKSwgMCwgMSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdxdWFydGVyJzpcbiAgICAgICAgICAgICAgICB0aW1lID0gc3RhcnRPZkRhdGUoXG4gICAgICAgICAgICAgICAgICAgIHRoaXMueWVhcigpLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1vbnRoKCkgLSAodGhpcy5tb250aCgpICUgMyksXG4gICAgICAgICAgICAgICAgICAgIDFcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbW9udGgnOlxuICAgICAgICAgICAgICAgIHRpbWUgPSBzdGFydE9mRGF0ZSh0aGlzLnllYXIoKSwgdGhpcy5tb250aCgpLCAxKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3dlZWsnOlxuICAgICAgICAgICAgICAgIHRpbWUgPSBzdGFydE9mRGF0ZShcbiAgICAgICAgICAgICAgICAgICAgdGhpcy55ZWFyKCksXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubW9udGgoKSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kYXRlKCkgLSB0aGlzLndlZWtkYXkoKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdpc29XZWVrJzpcbiAgICAgICAgICAgICAgICB0aW1lID0gc3RhcnRPZkRhdGUoXG4gICAgICAgICAgICAgICAgICAgIHRoaXMueWVhcigpLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1vbnRoKCksXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGF0ZSgpIC0gKHRoaXMuaXNvV2Vla2RheSgpIC0gMSlcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnZGF5JzpcbiAgICAgICAgICAgIGNhc2UgJ2RhdGUnOlxuICAgICAgICAgICAgICAgIHRpbWUgPSBzdGFydE9mRGF0ZSh0aGlzLnllYXIoKSwgdGhpcy5tb250aCgpLCB0aGlzLmRhdGUoKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdob3VyJzpcbiAgICAgICAgICAgICAgICB0aW1lID0gdGhpcy5fZC52YWx1ZU9mKCk7XG4gICAgICAgICAgICAgICAgdGltZSAtPSBtb2QkMShcbiAgICAgICAgICAgICAgICAgICAgdGltZSArICh0aGlzLl9pc1VUQyA/IDAgOiB0aGlzLnV0Y09mZnNldCgpICogTVNfUEVSX01JTlVURSksXG4gICAgICAgICAgICAgICAgICAgIE1TX1BFUl9IT1VSXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgICAgICAgICAgICAgdGltZSA9IHRoaXMuX2QudmFsdWVPZigpO1xuICAgICAgICAgICAgICAgIHRpbWUgLT0gbW9kJDEodGltZSwgTVNfUEVSX01JTlVURSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdzZWNvbmQnOlxuICAgICAgICAgICAgICAgIHRpbWUgPSB0aGlzLl9kLnZhbHVlT2YoKTtcbiAgICAgICAgICAgICAgICB0aW1lIC09IG1vZCQxKHRpbWUsIE1TX1BFUl9TRUNPTkQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fZC5zZXRUaW1lKHRpbWUpO1xuICAgICAgICBob29rcy51cGRhdGVPZmZzZXQodGhpcywgdHJ1ZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVuZE9mKHVuaXRzKSB7XG4gICAgICAgIHZhciB0aW1lLCBzdGFydE9mRGF0ZTtcbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG4gICAgICAgIGlmICh1bml0cyA9PT0gdW5kZWZpbmVkIHx8IHVuaXRzID09PSAnbWlsbGlzZWNvbmQnIHx8ICF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICBzdGFydE9mRGF0ZSA9IHRoaXMuX2lzVVRDID8gdXRjU3RhcnRPZkRhdGUgOiBsb2NhbFN0YXJ0T2ZEYXRlO1xuXG4gICAgICAgIHN3aXRjaCAodW5pdHMpIHtcbiAgICAgICAgICAgIGNhc2UgJ3llYXInOlxuICAgICAgICAgICAgICAgIHRpbWUgPSBzdGFydE9mRGF0ZSh0aGlzLnllYXIoKSArIDEsIDAsIDEpIC0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3F1YXJ0ZXInOlxuICAgICAgICAgICAgICAgIHRpbWUgPVxuICAgICAgICAgICAgICAgICAgICBzdGFydE9mRGF0ZShcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMueWVhcigpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tb250aCgpIC0gKHRoaXMubW9udGgoKSAlIDMpICsgMyxcbiAgICAgICAgICAgICAgICAgICAgICAgIDFcbiAgICAgICAgICAgICAgICAgICAgKSAtIDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdtb250aCc6XG4gICAgICAgICAgICAgICAgdGltZSA9IHN0YXJ0T2ZEYXRlKHRoaXMueWVhcigpLCB0aGlzLm1vbnRoKCkgKyAxLCAxKSAtIDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICd3ZWVrJzpcbiAgICAgICAgICAgICAgICB0aW1lID1cbiAgICAgICAgICAgICAgICAgICAgc3RhcnRPZkRhdGUoXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnllYXIoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubW9udGgoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGF0ZSgpIC0gdGhpcy53ZWVrZGF5KCkgKyA3XG4gICAgICAgICAgICAgICAgICAgICkgLSAxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnaXNvV2Vlayc6XG4gICAgICAgICAgICAgICAgdGltZSA9XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0T2ZEYXRlKFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy55ZWFyKCksXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1vbnRoKCksXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRhdGUoKSAtICh0aGlzLmlzb1dlZWtkYXkoKSAtIDEpICsgN1xuICAgICAgICAgICAgICAgICAgICApIC0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2RheSc6XG4gICAgICAgICAgICBjYXNlICdkYXRlJzpcbiAgICAgICAgICAgICAgICB0aW1lID0gc3RhcnRPZkRhdGUodGhpcy55ZWFyKCksIHRoaXMubW9udGgoKSwgdGhpcy5kYXRlKCkgKyAxKSAtIDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdob3VyJzpcbiAgICAgICAgICAgICAgICB0aW1lID0gdGhpcy5fZC52YWx1ZU9mKCk7XG4gICAgICAgICAgICAgICAgdGltZSArPVxuICAgICAgICAgICAgICAgICAgICBNU19QRVJfSE9VUiAtXG4gICAgICAgICAgICAgICAgICAgIG1vZCQxKFxuICAgICAgICAgICAgICAgICAgICAgICAgdGltZSArICh0aGlzLl9pc1VUQyA/IDAgOiB0aGlzLnV0Y09mZnNldCgpICogTVNfUEVSX01JTlVURSksXG4gICAgICAgICAgICAgICAgICAgICAgICBNU19QRVJfSE9VUlxuICAgICAgICAgICAgICAgICAgICApIC1cbiAgICAgICAgICAgICAgICAgICAgMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgICAgICAgICAgICAgdGltZSA9IHRoaXMuX2QudmFsdWVPZigpO1xuICAgICAgICAgICAgICAgIHRpbWUgKz0gTVNfUEVSX01JTlVURSAtIG1vZCQxKHRpbWUsIE1TX1BFUl9NSU5VVEUpIC0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgICAgICAgICAgICAgdGltZSA9IHRoaXMuX2QudmFsdWVPZigpO1xuICAgICAgICAgICAgICAgIHRpbWUgKz0gTVNfUEVSX1NFQ09ORCAtIG1vZCQxKHRpbWUsIE1TX1BFUl9TRUNPTkQpIC0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2Quc2V0VGltZSh0aW1lKTtcbiAgICAgICAgaG9va3MudXBkYXRlT2Zmc2V0KHRoaXMsIHRydWUpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2YWx1ZU9mKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZC52YWx1ZU9mKCkgLSAodGhpcy5fb2Zmc2V0IHx8IDApICogNjAwMDA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdW5peCgpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IodGhpcy52YWx1ZU9mKCkgLyAxMDAwKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b0RhdGUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZSh0aGlzLnZhbHVlT2YoKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9BcnJheSgpIHtcbiAgICAgICAgdmFyIG0gPSB0aGlzO1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgbS55ZWFyKCksXG4gICAgICAgICAgICBtLm1vbnRoKCksXG4gICAgICAgICAgICBtLmRhdGUoKSxcbiAgICAgICAgICAgIG0uaG91cigpLFxuICAgICAgICAgICAgbS5taW51dGUoKSxcbiAgICAgICAgICAgIG0uc2Vjb25kKCksXG4gICAgICAgICAgICBtLm1pbGxpc2Vjb25kKCksXG4gICAgICAgIF07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9PYmplY3QoKSB7XG4gICAgICAgIHZhciBtID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHllYXJzOiBtLnllYXIoKSxcbiAgICAgICAgICAgIG1vbnRoczogbS5tb250aCgpLFxuICAgICAgICAgICAgZGF0ZTogbS5kYXRlKCksXG4gICAgICAgICAgICBob3VyczogbS5ob3VycygpLFxuICAgICAgICAgICAgbWludXRlczogbS5taW51dGVzKCksXG4gICAgICAgICAgICBzZWNvbmRzOiBtLnNlY29uZHMoKSxcbiAgICAgICAgICAgIG1pbGxpc2Vjb25kczogbS5taWxsaXNlY29uZHMoKSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICAgIC8vIG5ldyBEYXRlKE5hTikudG9KU09OKCkgPT09IG51bGxcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNWYWxpZCgpID8gdGhpcy50b0lTT1N0cmluZygpIDogbnVsbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1ZhbGlkJDIoKSB7XG4gICAgICAgIHJldHVybiBpc1ZhbGlkKHRoaXMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNpbmdGbGFncygpIHtcbiAgICAgICAgcmV0dXJuIGV4dGVuZCh7fSwgZ2V0UGFyc2luZ0ZsYWdzKHRoaXMpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnZhbGlkQXQoKSB7XG4gICAgICAgIHJldHVybiBnZXRQYXJzaW5nRmxhZ3ModGhpcykub3ZlcmZsb3c7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRpb25EYXRhKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaW5wdXQ6IHRoaXMuX2ksXG4gICAgICAgICAgICBmb3JtYXQ6IHRoaXMuX2YsXG4gICAgICAgICAgICBsb2NhbGU6IHRoaXMuX2xvY2FsZSxcbiAgICAgICAgICAgIGlzVVRDOiB0aGlzLl9pc1VUQyxcbiAgICAgICAgICAgIHN0cmljdDogdGhpcy5fc3RyaWN0LFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGFkZEZvcm1hdFRva2VuKCdOJywgMCwgMCwgJ2VyYUFiYnInKTtcbiAgICBhZGRGb3JtYXRUb2tlbignTk4nLCAwLCAwLCAnZXJhQWJicicpO1xuICAgIGFkZEZvcm1hdFRva2VuKCdOTk4nLCAwLCAwLCAnZXJhQWJicicpO1xuICAgIGFkZEZvcm1hdFRva2VuKCdOTk5OJywgMCwgMCwgJ2VyYU5hbWUnKTtcbiAgICBhZGRGb3JtYXRUb2tlbignTk5OTk4nLCAwLCAwLCAnZXJhTmFycm93Jyk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbigneScsIFsneScsIDFdLCAneW8nLCAnZXJhWWVhcicpO1xuICAgIGFkZEZvcm1hdFRva2VuKCd5JywgWyd5eScsIDJdLCAwLCAnZXJhWWVhcicpO1xuICAgIGFkZEZvcm1hdFRva2VuKCd5JywgWyd5eXknLCAzXSwgMCwgJ2VyYVllYXInKTtcbiAgICBhZGRGb3JtYXRUb2tlbigneScsIFsneXl5eScsIDRdLCAwLCAnZXJhWWVhcicpO1xuXG4gICAgYWRkUmVnZXhUb2tlbignTicsIG1hdGNoRXJhQWJicik7XG4gICAgYWRkUmVnZXhUb2tlbignTk4nLCBtYXRjaEVyYUFiYnIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ05OTicsIG1hdGNoRXJhQWJicik7XG4gICAgYWRkUmVnZXhUb2tlbignTk5OTicsIG1hdGNoRXJhTmFtZSk7XG4gICAgYWRkUmVnZXhUb2tlbignTk5OTk4nLCBtYXRjaEVyYU5hcnJvdyk7XG5cbiAgICBhZGRQYXJzZVRva2VuKFsnTicsICdOTicsICdOTk4nLCAnTk5OTicsICdOTk5OTiddLCBmdW5jdGlvbiAoXG4gICAgICAgIGlucHV0LFxuICAgICAgICBhcnJheSxcbiAgICAgICAgY29uZmlnLFxuICAgICAgICB0b2tlblxuICAgICkge1xuICAgICAgICB2YXIgZXJhID0gY29uZmlnLl9sb2NhbGUuZXJhc1BhcnNlKGlucHV0LCB0b2tlbiwgY29uZmlnLl9zdHJpY3QpO1xuICAgICAgICBpZiAoZXJhKSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5lcmEgPSBlcmE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5pbnZhbGlkRXJhID0gaW5wdXQ7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ3knLCBtYXRjaFVuc2lnbmVkKTtcbiAgICBhZGRSZWdleFRva2VuKCd5eScsIG1hdGNoVW5zaWduZWQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ3l5eScsIG1hdGNoVW5zaWduZWQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ3l5eXknLCBtYXRjaFVuc2lnbmVkKTtcbiAgICBhZGRSZWdleFRva2VuKCd5bycsIG1hdGNoRXJhWWVhck9yZGluYWwpO1xuXG4gICAgYWRkUGFyc2VUb2tlbihbJ3knLCAneXknLCAneXl5JywgJ3l5eXknXSwgWUVBUik7XG4gICAgYWRkUGFyc2VUb2tlbihbJ3lvJ10sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZywgdG9rZW4pIHtcbiAgICAgICAgdmFyIG1hdGNoO1xuICAgICAgICBpZiAoY29uZmlnLl9sb2NhbGUuX2VyYVllYXJPcmRpbmFsUmVnZXgpIHtcbiAgICAgICAgICAgIG1hdGNoID0gaW5wdXQubWF0Y2goY29uZmlnLl9sb2NhbGUuX2VyYVllYXJPcmRpbmFsUmVnZXgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbmZpZy5fbG9jYWxlLmVyYVllYXJPcmRpbmFsUGFyc2UpIHtcbiAgICAgICAgICAgIGFycmF5W1lFQVJdID0gY29uZmlnLl9sb2NhbGUuZXJhWWVhck9yZGluYWxQYXJzZShpbnB1dCwgbWF0Y2gpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXJyYXlbWUVBUl0gPSBwYXJzZUludChpbnB1dCwgMTApO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBsb2NhbGVFcmFzKG0sIGZvcm1hdCkge1xuICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgIGwsXG4gICAgICAgICAgICBkYXRlLFxuICAgICAgICAgICAgZXJhcyA9IHRoaXMuX2VyYXMgfHwgZ2V0TG9jYWxlKCdlbicpLl9lcmFzO1xuICAgICAgICBmb3IgKGkgPSAwLCBsID0gZXJhcy5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIGVyYXNbaV0uc2luY2UpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgICAgICAvLyB0cnVuY2F0ZSB0aW1lXG4gICAgICAgICAgICAgICAgICAgIGRhdGUgPSBob29rcyhlcmFzW2ldLnNpbmNlKS5zdGFydE9mKCdkYXknKTtcbiAgICAgICAgICAgICAgICAgICAgZXJhc1tpXS5zaW5jZSA9IGRhdGUudmFsdWVPZigpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc3dpdGNoICh0eXBlb2YgZXJhc1tpXS51bnRpbCkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgICAgICAgICAgICAgICAgIGVyYXNbaV0udW50aWwgPSArSW5maW5pdHk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICAgICAgICAgIC8vIHRydW5jYXRlIHRpbWVcbiAgICAgICAgICAgICAgICAgICAgZGF0ZSA9IGhvb2tzKGVyYXNbaV0udW50aWwpLnN0YXJ0T2YoJ2RheScpLnZhbHVlT2YoKTtcbiAgICAgICAgICAgICAgICAgICAgZXJhc1tpXS51bnRpbCA9IGRhdGUudmFsdWVPZigpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXJhcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb2NhbGVFcmFzUGFyc2UoZXJhTmFtZSwgZm9ybWF0LCBzdHJpY3QpIHtcbiAgICAgICAgdmFyIGksXG4gICAgICAgICAgICBsLFxuICAgICAgICAgICAgZXJhcyA9IHRoaXMuZXJhcygpLFxuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIGFiYnIsXG4gICAgICAgICAgICBuYXJyb3c7XG4gICAgICAgIGVyYU5hbWUgPSBlcmFOYW1lLnRvVXBwZXJDYXNlKCk7XG5cbiAgICAgICAgZm9yIChpID0gMCwgbCA9IGVyYXMubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgICAgICAgICBuYW1lID0gZXJhc1tpXS5uYW1lLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICBhYmJyID0gZXJhc1tpXS5hYmJyLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICBuYXJyb3cgPSBlcmFzW2ldLm5hcnJvdy50b1VwcGVyQ2FzZSgpO1xuXG4gICAgICAgICAgICBpZiAoc3RyaWN0KSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChmb3JtYXQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnTic6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ05OJzpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnTk5OJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhYmJyID09PSBlcmFOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVyYXNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICBjYXNlICdOTk5OJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuYW1lID09PSBlcmFOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVyYXNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICBjYXNlICdOTk5OTic6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmFycm93ID09PSBlcmFOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVyYXNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKFtuYW1lLCBhYmJyLCBuYXJyb3ddLmluZGV4T2YoZXJhTmFtZSkgPj0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlcmFzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9jYWxlRXJhc0NvbnZlcnRZZWFyKGVyYSwgeWVhcikge1xuICAgICAgICB2YXIgZGlyID0gZXJhLnNpbmNlIDw9IGVyYS51bnRpbCA/ICsxIDogLTE7XG4gICAgICAgIGlmICh5ZWFyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBob29rcyhlcmEuc2luY2UpLnllYXIoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBob29rcyhlcmEuc2luY2UpLnllYXIoKSArICh5ZWFyIC0gZXJhLm9mZnNldCkgKiBkaXI7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRFcmFOYW1lKCkge1xuICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgIGwsXG4gICAgICAgICAgICB2YWwsXG4gICAgICAgICAgICBlcmFzID0gdGhpcy5sb2NhbGVEYXRhKCkuZXJhcygpO1xuICAgICAgICBmb3IgKGkgPSAwLCBsID0gZXJhcy5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgICAgIC8vIHRydW5jYXRlIHRpbWVcbiAgICAgICAgICAgIHZhbCA9IHRoaXMuY2xvbmUoKS5zdGFydE9mKCdkYXknKS52YWx1ZU9mKCk7XG5cbiAgICAgICAgICAgIGlmIChlcmFzW2ldLnNpbmNlIDw9IHZhbCAmJiB2YWwgPD0gZXJhc1tpXS51bnRpbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlcmFzW2ldLm5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXJhc1tpXS51bnRpbCA8PSB2YWwgJiYgdmFsIDw9IGVyYXNbaV0uc2luY2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXJhc1tpXS5uYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldEVyYU5hcnJvdygpIHtcbiAgICAgICAgdmFyIGksXG4gICAgICAgICAgICBsLFxuICAgICAgICAgICAgdmFsLFxuICAgICAgICAgICAgZXJhcyA9IHRoaXMubG9jYWxlRGF0YSgpLmVyYXMoKTtcbiAgICAgICAgZm9yIChpID0gMCwgbCA9IGVyYXMubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgICAgICAgICAvLyB0cnVuY2F0ZSB0aW1lXG4gICAgICAgICAgICB2YWwgPSB0aGlzLmNsb25lKCkuc3RhcnRPZignZGF5JykudmFsdWVPZigpO1xuXG4gICAgICAgICAgICBpZiAoZXJhc1tpXS5zaW5jZSA8PSB2YWwgJiYgdmFsIDw9IGVyYXNbaV0udW50aWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXJhc1tpXS5uYXJyb3c7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXJhc1tpXS51bnRpbCA8PSB2YWwgJiYgdmFsIDw9IGVyYXNbaV0uc2luY2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXJhc1tpXS5uYXJyb3c7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0RXJhQWJicigpIHtcbiAgICAgICAgdmFyIGksXG4gICAgICAgICAgICBsLFxuICAgICAgICAgICAgdmFsLFxuICAgICAgICAgICAgZXJhcyA9IHRoaXMubG9jYWxlRGF0YSgpLmVyYXMoKTtcbiAgICAgICAgZm9yIChpID0gMCwgbCA9IGVyYXMubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgICAgICAgICAvLyB0cnVuY2F0ZSB0aW1lXG4gICAgICAgICAgICB2YWwgPSB0aGlzLmNsb25lKCkuc3RhcnRPZignZGF5JykudmFsdWVPZigpO1xuXG4gICAgICAgICAgICBpZiAoZXJhc1tpXS5zaW5jZSA8PSB2YWwgJiYgdmFsIDw9IGVyYXNbaV0udW50aWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXJhc1tpXS5hYmJyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVyYXNbaV0udW50aWwgPD0gdmFsICYmIHZhbCA8PSBlcmFzW2ldLnNpbmNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVyYXNbaV0uYWJicjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRFcmFZZWFyKCkge1xuICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgIGwsXG4gICAgICAgICAgICBkaXIsXG4gICAgICAgICAgICB2YWwsXG4gICAgICAgICAgICBlcmFzID0gdGhpcy5sb2NhbGVEYXRhKCkuZXJhcygpO1xuICAgICAgICBmb3IgKGkgPSAwLCBsID0gZXJhcy5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgICAgIGRpciA9IGVyYXNbaV0uc2luY2UgPD0gZXJhc1tpXS51bnRpbCA/ICsxIDogLTE7XG5cbiAgICAgICAgICAgIC8vIHRydW5jYXRlIHRpbWVcbiAgICAgICAgICAgIHZhbCA9IHRoaXMuY2xvbmUoKS5zdGFydE9mKCdkYXknKS52YWx1ZU9mKCk7XG5cbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAoZXJhc1tpXS5zaW5jZSA8PSB2YWwgJiYgdmFsIDw9IGVyYXNbaV0udW50aWwpIHx8XG4gICAgICAgICAgICAgICAgKGVyYXNbaV0udW50aWwgPD0gdmFsICYmIHZhbCA8PSBlcmFzW2ldLnNpbmNlKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAgICAgKHRoaXMueWVhcigpIC0gaG9va3MoZXJhc1tpXS5zaW5jZSkueWVhcigpKSAqIGRpciArXG4gICAgICAgICAgICAgICAgICAgIGVyYXNbaV0ub2Zmc2V0XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLnllYXIoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlcmFzTmFtZVJlZ2V4KGlzU3RyaWN0KSB7XG4gICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX2VyYXNOYW1lUmVnZXgnKSkge1xuICAgICAgICAgICAgY29tcHV0ZUVyYXNQYXJzZS5jYWxsKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpc1N0cmljdCA/IHRoaXMuX2VyYXNOYW1lUmVnZXggOiB0aGlzLl9lcmFzUmVnZXg7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXJhc0FiYnJSZWdleChpc1N0cmljdCkge1xuICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ19lcmFzQWJiclJlZ2V4JykpIHtcbiAgICAgICAgICAgIGNvbXB1dGVFcmFzUGFyc2UuY2FsbCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXNTdHJpY3QgPyB0aGlzLl9lcmFzQWJiclJlZ2V4IDogdGhpcy5fZXJhc1JlZ2V4O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVyYXNOYXJyb3dSZWdleChpc1N0cmljdCkge1xuICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ19lcmFzTmFycm93UmVnZXgnKSkge1xuICAgICAgICAgICAgY29tcHV0ZUVyYXNQYXJzZS5jYWxsKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpc1N0cmljdCA/IHRoaXMuX2VyYXNOYXJyb3dSZWdleCA6IHRoaXMuX2VyYXNSZWdleDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYXRjaEVyYUFiYnIoaXNTdHJpY3QsIGxvY2FsZSkge1xuICAgICAgICByZXR1cm4gbG9jYWxlLmVyYXNBYmJyUmVnZXgoaXNTdHJpY3QpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1hdGNoRXJhTmFtZShpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGUuZXJhc05hbWVSZWdleChpc1N0cmljdCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWF0Y2hFcmFOYXJyb3coaXNTdHJpY3QsIGxvY2FsZSkge1xuICAgICAgICByZXR1cm4gbG9jYWxlLmVyYXNOYXJyb3dSZWdleChpc1N0cmljdCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWF0Y2hFcmFZZWFyT3JkaW5hbChpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGUuX2VyYVllYXJPcmRpbmFsUmVnZXggfHwgbWF0Y2hVbnNpZ25lZDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb21wdXRlRXJhc1BhcnNlKCkge1xuICAgICAgICB2YXIgYWJiclBpZWNlcyA9IFtdLFxuICAgICAgICAgICAgbmFtZVBpZWNlcyA9IFtdLFxuICAgICAgICAgICAgbmFycm93UGllY2VzID0gW10sXG4gICAgICAgICAgICBtaXhlZFBpZWNlcyA9IFtdLFxuICAgICAgICAgICAgaSxcbiAgICAgICAgICAgIGwsXG4gICAgICAgICAgICBlcmFzID0gdGhpcy5lcmFzKCk7XG5cbiAgICAgICAgZm9yIChpID0gMCwgbCA9IGVyYXMubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgICAgICAgICBuYW1lUGllY2VzLnB1c2gocmVnZXhFc2NhcGUoZXJhc1tpXS5uYW1lKSk7XG4gICAgICAgICAgICBhYmJyUGllY2VzLnB1c2gocmVnZXhFc2NhcGUoZXJhc1tpXS5hYmJyKSk7XG4gICAgICAgICAgICBuYXJyb3dQaWVjZXMucHVzaChyZWdleEVzY2FwZShlcmFzW2ldLm5hcnJvdykpO1xuXG4gICAgICAgICAgICBtaXhlZFBpZWNlcy5wdXNoKHJlZ2V4RXNjYXBlKGVyYXNbaV0ubmFtZSkpO1xuICAgICAgICAgICAgbWl4ZWRQaWVjZXMucHVzaChyZWdleEVzY2FwZShlcmFzW2ldLmFiYnIpKTtcbiAgICAgICAgICAgIG1peGVkUGllY2VzLnB1c2gocmVnZXhFc2NhcGUoZXJhc1tpXS5uYXJyb3cpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2VyYXNSZWdleCA9IG5ldyBSZWdFeHAoJ14oJyArIG1peGVkUGllY2VzLmpvaW4oJ3wnKSArICcpJywgJ2knKTtcbiAgICAgICAgdGhpcy5fZXJhc05hbWVSZWdleCA9IG5ldyBSZWdFeHAoJ14oJyArIG5hbWVQaWVjZXMuam9pbignfCcpICsgJyknLCAnaScpO1xuICAgICAgICB0aGlzLl9lcmFzQWJiclJlZ2V4ID0gbmV3IFJlZ0V4cCgnXignICsgYWJiclBpZWNlcy5qb2luKCd8JykgKyAnKScsICdpJyk7XG4gICAgICAgIHRoaXMuX2VyYXNOYXJyb3dSZWdleCA9IG5ldyBSZWdFeHAoXG4gICAgICAgICAgICAnXignICsgbmFycm93UGllY2VzLmpvaW4oJ3wnKSArICcpJyxcbiAgICAgICAgICAgICdpJ1xuICAgICAgICApO1xuICAgIH1cblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnZ2cnLCAyXSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy53ZWVrWWVhcigpICUgMTAwO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydHRycsIDJdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzb1dlZWtZZWFyKCkgJSAxMDA7XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBhZGRXZWVrWWVhckZvcm1hdFRva2VuKHRva2VuLCBnZXR0ZXIpIHtcbiAgICAgICAgYWRkRm9ybWF0VG9rZW4oMCwgW3Rva2VuLCB0b2tlbi5sZW5ndGhdLCAwLCBnZXR0ZXIpO1xuICAgIH1cblxuICAgIGFkZFdlZWtZZWFyRm9ybWF0VG9rZW4oJ2dnZ2cnLCAnd2Vla1llYXInKTtcbiAgICBhZGRXZWVrWWVhckZvcm1hdFRva2VuKCdnZ2dnZycsICd3ZWVrWWVhcicpO1xuICAgIGFkZFdlZWtZZWFyRm9ybWF0VG9rZW4oJ0dHR0cnLCAnaXNvV2Vla1llYXInKTtcbiAgICBhZGRXZWVrWWVhckZvcm1hdFRva2VuKCdHR0dHRycsICdpc29XZWVrWWVhcicpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCd3ZWVrWWVhcicsICdnZycpO1xuICAgIGFkZFVuaXRBbGlhcygnaXNvV2Vla1llYXInLCAnR0cnKTtcblxuICAgIC8vIFBSSU9SSVRZXG5cbiAgICBhZGRVbml0UHJpb3JpdHkoJ3dlZWtZZWFyJywgMSk7XG4gICAgYWRkVW5pdFByaW9yaXR5KCdpc29XZWVrWWVhcicsIDEpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignRycsIG1hdGNoU2lnbmVkKTtcbiAgICBhZGRSZWdleFRva2VuKCdnJywgbWF0Y2hTaWduZWQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0dHJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2dnJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0dHR0cnLCBtYXRjaDF0bzQsIG1hdGNoNCk7XG4gICAgYWRkUmVnZXhUb2tlbignZ2dnZycsIG1hdGNoMXRvNCwgbWF0Y2g0KTtcbiAgICBhZGRSZWdleFRva2VuKCdHR0dHRycsIG1hdGNoMXRvNiwgbWF0Y2g2KTtcbiAgICBhZGRSZWdleFRva2VuKCdnZ2dnZycsIG1hdGNoMXRvNiwgbWF0Y2g2KTtcblxuICAgIGFkZFdlZWtQYXJzZVRva2VuKFsnZ2dnZycsICdnZ2dnZycsICdHR0dHJywgJ0dHR0dHJ10sIGZ1bmN0aW9uIChcbiAgICAgICAgaW5wdXQsXG4gICAgICAgIHdlZWssXG4gICAgICAgIGNvbmZpZyxcbiAgICAgICAgdG9rZW5cbiAgICApIHtcbiAgICAgICAgd2Vla1t0b2tlbi5zdWJzdHIoMCwgMildID0gdG9JbnQoaW5wdXQpO1xuICAgIH0pO1xuXG4gICAgYWRkV2Vla1BhcnNlVG9rZW4oWydnZycsICdHRyddLCBmdW5jdGlvbiAoaW5wdXQsIHdlZWssIGNvbmZpZywgdG9rZW4pIHtcbiAgICAgICAgd2Vla1t0b2tlbl0gPSBob29rcy5wYXJzZVR3b0RpZ2l0WWVhcihpbnB1dCk7XG4gICAgfSk7XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICBmdW5jdGlvbiBnZXRTZXRXZWVrWWVhcihpbnB1dCkge1xuICAgICAgICByZXR1cm4gZ2V0U2V0V2Vla1llYXJIZWxwZXIuY2FsbChcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgIHRoaXMud2VlaygpLFxuICAgICAgICAgICAgdGhpcy53ZWVrZGF5KCksXG4gICAgICAgICAgICB0aGlzLmxvY2FsZURhdGEoKS5fd2Vlay5kb3csXG4gICAgICAgICAgICB0aGlzLmxvY2FsZURhdGEoKS5fd2Vlay5kb3lcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTZXRJU09XZWVrWWVhcihpbnB1dCkge1xuICAgICAgICByZXR1cm4gZ2V0U2V0V2Vla1llYXJIZWxwZXIuY2FsbChcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgIHRoaXMuaXNvV2VlaygpLFxuICAgICAgICAgICAgdGhpcy5pc29XZWVrZGF5KCksXG4gICAgICAgICAgICAxLFxuICAgICAgICAgICAgNFxuICAgICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldElTT1dlZWtzSW5ZZWFyKCkge1xuICAgICAgICByZXR1cm4gd2Vla3NJblllYXIodGhpcy55ZWFyKCksIDEsIDQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldElTT1dlZWtzSW5JU09XZWVrWWVhcigpIHtcbiAgICAgICAgcmV0dXJuIHdlZWtzSW5ZZWFyKHRoaXMuaXNvV2Vla1llYXIoKSwgMSwgNCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0V2Vla3NJblllYXIoKSB7XG4gICAgICAgIHZhciB3ZWVrSW5mbyA9IHRoaXMubG9jYWxlRGF0YSgpLl93ZWVrO1xuICAgICAgICByZXR1cm4gd2Vla3NJblllYXIodGhpcy55ZWFyKCksIHdlZWtJbmZvLmRvdywgd2Vla0luZm8uZG95KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRXZWVrc0luV2Vla1llYXIoKSB7XG4gICAgICAgIHZhciB3ZWVrSW5mbyA9IHRoaXMubG9jYWxlRGF0YSgpLl93ZWVrO1xuICAgICAgICByZXR1cm4gd2Vla3NJblllYXIodGhpcy53ZWVrWWVhcigpLCB3ZWVrSW5mby5kb3csIHdlZWtJbmZvLmRveSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U2V0V2Vla1llYXJIZWxwZXIoaW5wdXQsIHdlZWssIHdlZWtkYXksIGRvdywgZG95KSB7XG4gICAgICAgIHZhciB3ZWVrc1RhcmdldDtcbiAgICAgICAgaWYgKGlucHV0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB3ZWVrT2ZZZWFyKHRoaXMsIGRvdywgZG95KS55ZWFyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd2Vla3NUYXJnZXQgPSB3ZWVrc0luWWVhcihpbnB1dCwgZG93LCBkb3kpO1xuICAgICAgICAgICAgaWYgKHdlZWsgPiB3ZWVrc1RhcmdldCkge1xuICAgICAgICAgICAgICAgIHdlZWsgPSB3ZWVrc1RhcmdldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzZXRXZWVrQWxsLmNhbGwodGhpcywgaW5wdXQsIHdlZWssIHdlZWtkYXksIGRvdywgZG95KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldFdlZWtBbGwod2Vla1llYXIsIHdlZWssIHdlZWtkYXksIGRvdywgZG95KSB7XG4gICAgICAgIHZhciBkYXlPZlllYXJEYXRhID0gZGF5T2ZZZWFyRnJvbVdlZWtzKHdlZWtZZWFyLCB3ZWVrLCB3ZWVrZGF5LCBkb3csIGRveSksXG4gICAgICAgICAgICBkYXRlID0gY3JlYXRlVVRDRGF0ZShkYXlPZlllYXJEYXRhLnllYXIsIDAsIGRheU9mWWVhckRhdGEuZGF5T2ZZZWFyKTtcblxuICAgICAgICB0aGlzLnllYXIoZGF0ZS5nZXRVVENGdWxsWWVhcigpKTtcbiAgICAgICAgdGhpcy5tb250aChkYXRlLmdldFVUQ01vbnRoKCkpO1xuICAgICAgICB0aGlzLmRhdGUoZGF0ZS5nZXRVVENEYXRlKCkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbignUScsIDAsICdRbycsICdxdWFydGVyJyk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ3F1YXJ0ZXInLCAnUScpO1xuXG4gICAgLy8gUFJJT1JJVFlcblxuICAgIGFkZFVuaXRQcmlvcml0eSgncXVhcnRlcicsIDcpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignUScsIG1hdGNoMSk7XG4gICAgYWRkUGFyc2VUb2tlbignUScsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICAgICAgYXJyYXlbTU9OVEhdID0gKHRvSW50KGlucHV0KSAtIDEpICogMztcbiAgICB9KTtcblxuICAgIC8vIE1PTUVOVFNcblxuICAgIGZ1bmN0aW9uIGdldFNldFF1YXJ0ZXIoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0ID09IG51bGxcbiAgICAgICAgICAgID8gTWF0aC5jZWlsKCh0aGlzLm1vbnRoKCkgKyAxKSAvIDMpXG4gICAgICAgICAgICA6IHRoaXMubW9udGgoKGlucHV0IC0gMSkgKiAzICsgKHRoaXMubW9udGgoKSAlIDMpKTtcbiAgICB9XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbignRCcsIFsnREQnLCAyXSwgJ0RvJywgJ2RhdGUnKTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygnZGF0ZScsICdEJyk7XG5cbiAgICAvLyBQUklPUklUWVxuICAgIGFkZFVuaXRQcmlvcml0eSgnZGF0ZScsIDkpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignRCcsIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignREQnLCBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgYWRkUmVnZXhUb2tlbignRG8nLCBmdW5jdGlvbiAoaXNTdHJpY3QsIGxvY2FsZSkge1xuICAgICAgICAvLyBUT0RPOiBSZW1vdmUgXCJvcmRpbmFsUGFyc2VcIiBmYWxsYmFjayBpbiBuZXh0IG1ham9yIHJlbGVhc2UuXG4gICAgICAgIHJldHVybiBpc1N0cmljdFxuICAgICAgICAgICAgPyBsb2NhbGUuX2RheU9mTW9udGhPcmRpbmFsUGFyc2UgfHwgbG9jYWxlLl9vcmRpbmFsUGFyc2VcbiAgICAgICAgICAgIDogbG9jYWxlLl9kYXlPZk1vbnRoT3JkaW5hbFBhcnNlTGVuaWVudDtcbiAgICB9KTtcblxuICAgIGFkZFBhcnNlVG9rZW4oWydEJywgJ0REJ10sIERBVEUpO1xuICAgIGFkZFBhcnNlVG9rZW4oJ0RvJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSkge1xuICAgICAgICBhcnJheVtEQVRFXSA9IHRvSW50KGlucHV0Lm1hdGNoKG1hdGNoMXRvMilbMF0pO1xuICAgIH0pO1xuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgdmFyIGdldFNldERheU9mTW9udGggPSBtYWtlR2V0U2V0KCdEYXRlJywgdHJ1ZSk7XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbignREREJywgWydEREREJywgM10sICdERERvJywgJ2RheU9mWWVhcicpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCdkYXlPZlllYXInLCAnREREJyk7XG5cbiAgICAvLyBQUklPUklUWVxuICAgIGFkZFVuaXRQcmlvcml0eSgnZGF5T2ZZZWFyJywgNCk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdEREQnLCBtYXRjaDF0bzMpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0REREQnLCBtYXRjaDMpO1xuICAgIGFkZFBhcnNlVG9rZW4oWydEREQnLCAnRERERCddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgY29uZmlnLl9kYXlPZlllYXIgPSB0b0ludChpbnB1dCk7XG4gICAgfSk7XG5cbiAgICAvLyBIRUxQRVJTXG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICBmdW5jdGlvbiBnZXRTZXREYXlPZlllYXIoaW5wdXQpIHtcbiAgICAgICAgdmFyIGRheU9mWWVhciA9XG4gICAgICAgICAgICBNYXRoLnJvdW5kKFxuICAgICAgICAgICAgICAgICh0aGlzLmNsb25lKCkuc3RhcnRPZignZGF5JykgLSB0aGlzLmNsb25lKCkuc3RhcnRPZigneWVhcicpKSAvIDg2NGU1XG4gICAgICAgICAgICApICsgMTtcbiAgICAgICAgcmV0dXJuIGlucHV0ID09IG51bGwgPyBkYXlPZlllYXIgOiB0aGlzLmFkZChpbnB1dCAtIGRheU9mWWVhciwgJ2QnKTtcbiAgICB9XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbignbScsIFsnbW0nLCAyXSwgMCwgJ21pbnV0ZScpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCdtaW51dGUnLCAnbScpO1xuXG4gICAgLy8gUFJJT1JJVFlcblxuICAgIGFkZFVuaXRQcmlvcml0eSgnbWludXRlJywgMTQpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignbScsIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignbW0nLCBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgYWRkUGFyc2VUb2tlbihbJ20nLCAnbW0nXSwgTUlOVVRFKTtcblxuICAgIC8vIE1PTUVOVFNcblxuICAgIHZhciBnZXRTZXRNaW51dGUgPSBtYWtlR2V0U2V0KCdNaW51dGVzJywgZmFsc2UpO1xuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ3MnLCBbJ3NzJywgMl0sIDAsICdzZWNvbmQnKTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygnc2Vjb25kJywgJ3MnKTtcblxuICAgIC8vIFBSSU9SSVRZXG5cbiAgICBhZGRVbml0UHJpb3JpdHkoJ3NlY29uZCcsIDE1KTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ3MnLCBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ3NzJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgIGFkZFBhcnNlVG9rZW4oWydzJywgJ3NzJ10sIFNFQ09ORCk7XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICB2YXIgZ2V0U2V0U2Vjb25kID0gbWFrZUdldFNldCgnU2Vjb25kcycsIGZhbHNlKTtcblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCdTJywgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gfn4odGhpcy5taWxsaXNlY29uZCgpIC8gMTAwKTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnU1MnLCAyXSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gfn4odGhpcy5taWxsaXNlY29uZCgpIC8gMTApO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTU1MnLCAzXSwgMCwgJ21pbGxpc2Vjb25kJyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTJywgNF0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmQoKSAqIDEwO1xuICAgIH0pO1xuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnU1NTU1MnLCA1XSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZCgpICogMTAwO1xuICAgIH0pO1xuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnU1NTU1NTJywgNl0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmQoKSAqIDEwMDA7XG4gICAgfSk7XG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTU1NTJywgN10sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmQoKSAqIDEwMDAwO1xuICAgIH0pO1xuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnU1NTU1NTU1MnLCA4XSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZCgpICogMTAwMDAwO1xuICAgIH0pO1xuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnU1NTU1NTU1NTJywgOV0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmQoKSAqIDEwMDAwMDA7XG4gICAgfSk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ21pbGxpc2Vjb25kJywgJ21zJyk7XG5cbiAgICAvLyBQUklPUklUWVxuXG4gICAgYWRkVW5pdFByaW9yaXR5KCdtaWxsaXNlY29uZCcsIDE2KTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ1MnLCBtYXRjaDF0bzMsIG1hdGNoMSk7XG4gICAgYWRkUmVnZXhUb2tlbignU1MnLCBtYXRjaDF0bzMsIG1hdGNoMik7XG4gICAgYWRkUmVnZXhUb2tlbignU1NTJywgbWF0Y2gxdG8zLCBtYXRjaDMpO1xuXG4gICAgdmFyIHRva2VuLCBnZXRTZXRNaWxsaXNlY29uZDtcbiAgICBmb3IgKHRva2VuID0gJ1NTU1MnOyB0b2tlbi5sZW5ndGggPD0gOTsgdG9rZW4gKz0gJ1MnKSB7XG4gICAgICAgIGFkZFJlZ2V4VG9rZW4odG9rZW4sIG1hdGNoVW5zaWduZWQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlTXMoaW5wdXQsIGFycmF5KSB7XG4gICAgICAgIGFycmF5W01JTExJU0VDT05EXSA9IHRvSW50KCgnMC4nICsgaW5wdXQpICogMTAwMCk7XG4gICAgfVxuXG4gICAgZm9yICh0b2tlbiA9ICdTJzsgdG9rZW4ubGVuZ3RoIDw9IDk7IHRva2VuICs9ICdTJykge1xuICAgICAgICBhZGRQYXJzZVRva2VuKHRva2VuLCBwYXJzZU1zKTtcbiAgICB9XG5cbiAgICBnZXRTZXRNaWxsaXNlY29uZCA9IG1ha2VHZXRTZXQoJ01pbGxpc2Vjb25kcycsIGZhbHNlKTtcblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCd6JywgMCwgMCwgJ3pvbmVBYmJyJyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oJ3p6JywgMCwgMCwgJ3pvbmVOYW1lJyk7XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICBmdW5jdGlvbiBnZXRab25lQWJicigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzVVRDID8gJ1VUQycgOiAnJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRab25lTmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzVVRDID8gJ0Nvb3JkaW5hdGVkIFVuaXZlcnNhbCBUaW1lJyA6ICcnO1xuICAgIH1cblxuICAgIHZhciBwcm90byA9IE1vbWVudC5wcm90b3R5cGU7XG5cbiAgICBwcm90by5hZGQgPSBhZGQ7XG4gICAgcHJvdG8uY2FsZW5kYXIgPSBjYWxlbmRhciQxO1xuICAgIHByb3RvLmNsb25lID0gY2xvbmU7XG4gICAgcHJvdG8uZGlmZiA9IGRpZmY7XG4gICAgcHJvdG8uZW5kT2YgPSBlbmRPZjtcbiAgICBwcm90by5mb3JtYXQgPSBmb3JtYXQ7XG4gICAgcHJvdG8uZnJvbSA9IGZyb207XG4gICAgcHJvdG8uZnJvbU5vdyA9IGZyb21Ob3c7XG4gICAgcHJvdG8udG8gPSB0bztcbiAgICBwcm90by50b05vdyA9IHRvTm93O1xuICAgIHByb3RvLmdldCA9IHN0cmluZ0dldDtcbiAgICBwcm90by5pbnZhbGlkQXQgPSBpbnZhbGlkQXQ7XG4gICAgcHJvdG8uaXNBZnRlciA9IGlzQWZ0ZXI7XG4gICAgcHJvdG8uaXNCZWZvcmUgPSBpc0JlZm9yZTtcbiAgICBwcm90by5pc0JldHdlZW4gPSBpc0JldHdlZW47XG4gICAgcHJvdG8uaXNTYW1lID0gaXNTYW1lO1xuICAgIHByb3RvLmlzU2FtZU9yQWZ0ZXIgPSBpc1NhbWVPckFmdGVyO1xuICAgIHByb3RvLmlzU2FtZU9yQmVmb3JlID0gaXNTYW1lT3JCZWZvcmU7XG4gICAgcHJvdG8uaXNWYWxpZCA9IGlzVmFsaWQkMjtcbiAgICBwcm90by5sYW5nID0gbGFuZztcbiAgICBwcm90by5sb2NhbGUgPSBsb2NhbGU7XG4gICAgcHJvdG8ubG9jYWxlRGF0YSA9IGxvY2FsZURhdGE7XG4gICAgcHJvdG8ubWF4ID0gcHJvdG90eXBlTWF4O1xuICAgIHByb3RvLm1pbiA9IHByb3RvdHlwZU1pbjtcbiAgICBwcm90by5wYXJzaW5nRmxhZ3MgPSBwYXJzaW5nRmxhZ3M7XG4gICAgcHJvdG8uc2V0ID0gc3RyaW5nU2V0O1xuICAgIHByb3RvLnN0YXJ0T2YgPSBzdGFydE9mO1xuICAgIHByb3RvLnN1YnRyYWN0ID0gc3VidHJhY3Q7XG4gICAgcHJvdG8udG9BcnJheSA9IHRvQXJyYXk7XG4gICAgcHJvdG8udG9PYmplY3QgPSB0b09iamVjdDtcbiAgICBwcm90by50b0RhdGUgPSB0b0RhdGU7XG4gICAgcHJvdG8udG9JU09TdHJpbmcgPSB0b0lTT1N0cmluZztcbiAgICBwcm90by5pbnNwZWN0ID0gaW5zcGVjdDtcbiAgICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLmZvciAhPSBudWxsKSB7XG4gICAgICAgIHByb3RvW1N5bWJvbC5mb3IoJ25vZGVqcy51dGlsLmluc3BlY3QuY3VzdG9tJyldID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICdNb21lbnQ8JyArIHRoaXMuZm9ybWF0KCkgKyAnPic7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHByb3RvLnRvSlNPTiA9IHRvSlNPTjtcbiAgICBwcm90by50b1N0cmluZyA9IHRvU3RyaW5nO1xuICAgIHByb3RvLnVuaXggPSB1bml4O1xuICAgIHByb3RvLnZhbHVlT2YgPSB2YWx1ZU9mO1xuICAgIHByb3RvLmNyZWF0aW9uRGF0YSA9IGNyZWF0aW9uRGF0YTtcbiAgICBwcm90by5lcmFOYW1lID0gZ2V0RXJhTmFtZTtcbiAgICBwcm90by5lcmFOYXJyb3cgPSBnZXRFcmFOYXJyb3c7XG4gICAgcHJvdG8uZXJhQWJiciA9IGdldEVyYUFiYnI7XG4gICAgcHJvdG8uZXJhWWVhciA9IGdldEVyYVllYXI7XG4gICAgcHJvdG8ueWVhciA9IGdldFNldFllYXI7XG4gICAgcHJvdG8uaXNMZWFwWWVhciA9IGdldElzTGVhcFllYXI7XG4gICAgcHJvdG8ud2Vla1llYXIgPSBnZXRTZXRXZWVrWWVhcjtcbiAgICBwcm90by5pc29XZWVrWWVhciA9IGdldFNldElTT1dlZWtZZWFyO1xuICAgIHByb3RvLnF1YXJ0ZXIgPSBwcm90by5xdWFydGVycyA9IGdldFNldFF1YXJ0ZXI7XG4gICAgcHJvdG8ubW9udGggPSBnZXRTZXRNb250aDtcbiAgICBwcm90by5kYXlzSW5Nb250aCA9IGdldERheXNJbk1vbnRoO1xuICAgIHByb3RvLndlZWsgPSBwcm90by53ZWVrcyA9IGdldFNldFdlZWs7XG4gICAgcHJvdG8uaXNvV2VlayA9IHByb3RvLmlzb1dlZWtzID0gZ2V0U2V0SVNPV2VlaztcbiAgICBwcm90by53ZWVrc0luWWVhciA9IGdldFdlZWtzSW5ZZWFyO1xuICAgIHByb3RvLndlZWtzSW5XZWVrWWVhciA9IGdldFdlZWtzSW5XZWVrWWVhcjtcbiAgICBwcm90by5pc29XZWVrc0luWWVhciA9IGdldElTT1dlZWtzSW5ZZWFyO1xuICAgIHByb3RvLmlzb1dlZWtzSW5JU09XZWVrWWVhciA9IGdldElTT1dlZWtzSW5JU09XZWVrWWVhcjtcbiAgICBwcm90by5kYXRlID0gZ2V0U2V0RGF5T2ZNb250aDtcbiAgICBwcm90by5kYXkgPSBwcm90by5kYXlzID0gZ2V0U2V0RGF5T2ZXZWVrO1xuICAgIHByb3RvLndlZWtkYXkgPSBnZXRTZXRMb2NhbGVEYXlPZldlZWs7XG4gICAgcHJvdG8uaXNvV2Vla2RheSA9IGdldFNldElTT0RheU9mV2VlaztcbiAgICBwcm90by5kYXlPZlllYXIgPSBnZXRTZXREYXlPZlllYXI7XG4gICAgcHJvdG8uaG91ciA9IHByb3RvLmhvdXJzID0gZ2V0U2V0SG91cjtcbiAgICBwcm90by5taW51dGUgPSBwcm90by5taW51dGVzID0gZ2V0U2V0TWludXRlO1xuICAgIHByb3RvLnNlY29uZCA9IHByb3RvLnNlY29uZHMgPSBnZXRTZXRTZWNvbmQ7XG4gICAgcHJvdG8ubWlsbGlzZWNvbmQgPSBwcm90by5taWxsaXNlY29uZHMgPSBnZXRTZXRNaWxsaXNlY29uZDtcbiAgICBwcm90by51dGNPZmZzZXQgPSBnZXRTZXRPZmZzZXQ7XG4gICAgcHJvdG8udXRjID0gc2V0T2Zmc2V0VG9VVEM7XG4gICAgcHJvdG8ubG9jYWwgPSBzZXRPZmZzZXRUb0xvY2FsO1xuICAgIHByb3RvLnBhcnNlWm9uZSA9IHNldE9mZnNldFRvUGFyc2VkT2Zmc2V0O1xuICAgIHByb3RvLmhhc0FsaWduZWRIb3VyT2Zmc2V0ID0gaGFzQWxpZ25lZEhvdXJPZmZzZXQ7XG4gICAgcHJvdG8uaXNEU1QgPSBpc0RheWxpZ2h0U2F2aW5nVGltZTtcbiAgICBwcm90by5pc0xvY2FsID0gaXNMb2NhbDtcbiAgICBwcm90by5pc1V0Y09mZnNldCA9IGlzVXRjT2Zmc2V0O1xuICAgIHByb3RvLmlzVXRjID0gaXNVdGM7XG4gICAgcHJvdG8uaXNVVEMgPSBpc1V0YztcbiAgICBwcm90by56b25lQWJiciA9IGdldFpvbmVBYmJyO1xuICAgIHByb3RvLnpvbmVOYW1lID0gZ2V0Wm9uZU5hbWU7XG4gICAgcHJvdG8uZGF0ZXMgPSBkZXByZWNhdGUoXG4gICAgICAgICdkYXRlcyBhY2Nlc3NvciBpcyBkZXByZWNhdGVkLiBVc2UgZGF0ZSBpbnN0ZWFkLicsXG4gICAgICAgIGdldFNldERheU9mTW9udGhcbiAgICApO1xuICAgIHByb3RvLm1vbnRocyA9IGRlcHJlY2F0ZShcbiAgICAgICAgJ21vbnRocyBhY2Nlc3NvciBpcyBkZXByZWNhdGVkLiBVc2UgbW9udGggaW5zdGVhZCcsXG4gICAgICAgIGdldFNldE1vbnRoXG4gICAgKTtcbiAgICBwcm90by55ZWFycyA9IGRlcHJlY2F0ZShcbiAgICAgICAgJ3llYXJzIGFjY2Vzc29yIGlzIGRlcHJlY2F0ZWQuIFVzZSB5ZWFyIGluc3RlYWQnLFxuICAgICAgICBnZXRTZXRZZWFyXG4gICAgKTtcbiAgICBwcm90by56b25lID0gZGVwcmVjYXRlKFxuICAgICAgICAnbW9tZW50KCkuem9uZSBpcyBkZXByZWNhdGVkLCB1c2UgbW9tZW50KCkudXRjT2Zmc2V0IGluc3RlYWQuIGh0dHA6Ly9tb21lbnRqcy5jb20vZ3VpZGVzLyMvd2FybmluZ3Mvem9uZS8nLFxuICAgICAgICBnZXRTZXRab25lXG4gICAgKTtcbiAgICBwcm90by5pc0RTVFNoaWZ0ZWQgPSBkZXByZWNhdGUoXG4gICAgICAgICdpc0RTVFNoaWZ0ZWQgaXMgZGVwcmVjYXRlZC4gU2VlIGh0dHA6Ly9tb21lbnRqcy5jb20vZ3VpZGVzLyMvd2FybmluZ3MvZHN0LXNoaWZ0ZWQvIGZvciBtb3JlIGluZm9ybWF0aW9uJyxcbiAgICAgICAgaXNEYXlsaWdodFNhdmluZ1RpbWVTaGlmdGVkXG4gICAgKTtcblxuICAgIGZ1bmN0aW9uIGNyZWF0ZVVuaXgoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUxvY2FsKGlucHV0ICogMTAwMCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlSW5ab25lKCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlTG9jYWwuYXBwbHkobnVsbCwgYXJndW1lbnRzKS5wYXJzZVpvbmUoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwcmVQYXJzZVBvc3RGb3JtYXQoc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgfVxuXG4gICAgdmFyIHByb3RvJDEgPSBMb2NhbGUucHJvdG90eXBlO1xuXG4gICAgcHJvdG8kMS5jYWxlbmRhciA9IGNhbGVuZGFyO1xuICAgIHByb3RvJDEubG9uZ0RhdGVGb3JtYXQgPSBsb25nRGF0ZUZvcm1hdDtcbiAgICBwcm90byQxLmludmFsaWREYXRlID0gaW52YWxpZERhdGU7XG4gICAgcHJvdG8kMS5vcmRpbmFsID0gb3JkaW5hbDtcbiAgICBwcm90byQxLnByZXBhcnNlID0gcHJlUGFyc2VQb3N0Rm9ybWF0O1xuICAgIHByb3RvJDEucG9zdGZvcm1hdCA9IHByZVBhcnNlUG9zdEZvcm1hdDtcbiAgICBwcm90byQxLnJlbGF0aXZlVGltZSA9IHJlbGF0aXZlVGltZTtcbiAgICBwcm90byQxLnBhc3RGdXR1cmUgPSBwYXN0RnV0dXJlO1xuICAgIHByb3RvJDEuc2V0ID0gc2V0O1xuICAgIHByb3RvJDEuZXJhcyA9IGxvY2FsZUVyYXM7XG4gICAgcHJvdG8kMS5lcmFzUGFyc2UgPSBsb2NhbGVFcmFzUGFyc2U7XG4gICAgcHJvdG8kMS5lcmFzQ29udmVydFllYXIgPSBsb2NhbGVFcmFzQ29udmVydFllYXI7XG4gICAgcHJvdG8kMS5lcmFzQWJiclJlZ2V4ID0gZXJhc0FiYnJSZWdleDtcbiAgICBwcm90byQxLmVyYXNOYW1lUmVnZXggPSBlcmFzTmFtZVJlZ2V4O1xuICAgIHByb3RvJDEuZXJhc05hcnJvd1JlZ2V4ID0gZXJhc05hcnJvd1JlZ2V4O1xuXG4gICAgcHJvdG8kMS5tb250aHMgPSBsb2NhbGVNb250aHM7XG4gICAgcHJvdG8kMS5tb250aHNTaG9ydCA9IGxvY2FsZU1vbnRoc1Nob3J0O1xuICAgIHByb3RvJDEubW9udGhzUGFyc2UgPSBsb2NhbGVNb250aHNQYXJzZTtcbiAgICBwcm90byQxLm1vbnRoc1JlZ2V4ID0gbW9udGhzUmVnZXg7XG4gICAgcHJvdG8kMS5tb250aHNTaG9ydFJlZ2V4ID0gbW9udGhzU2hvcnRSZWdleDtcbiAgICBwcm90byQxLndlZWsgPSBsb2NhbGVXZWVrO1xuICAgIHByb3RvJDEuZmlyc3REYXlPZlllYXIgPSBsb2NhbGVGaXJzdERheU9mWWVhcjtcbiAgICBwcm90byQxLmZpcnN0RGF5T2ZXZWVrID0gbG9jYWxlRmlyc3REYXlPZldlZWs7XG5cbiAgICBwcm90byQxLndlZWtkYXlzID0gbG9jYWxlV2Vla2RheXM7XG4gICAgcHJvdG8kMS53ZWVrZGF5c01pbiA9IGxvY2FsZVdlZWtkYXlzTWluO1xuICAgIHByb3RvJDEud2Vla2RheXNTaG9ydCA9IGxvY2FsZVdlZWtkYXlzU2hvcnQ7XG4gICAgcHJvdG8kMS53ZWVrZGF5c1BhcnNlID0gbG9jYWxlV2Vla2RheXNQYXJzZTtcblxuICAgIHByb3RvJDEud2Vla2RheXNSZWdleCA9IHdlZWtkYXlzUmVnZXg7XG4gICAgcHJvdG8kMS53ZWVrZGF5c1Nob3J0UmVnZXggPSB3ZWVrZGF5c1Nob3J0UmVnZXg7XG4gICAgcHJvdG8kMS53ZWVrZGF5c01pblJlZ2V4ID0gd2Vla2RheXNNaW5SZWdleDtcblxuICAgIHByb3RvJDEuaXNQTSA9IGxvY2FsZUlzUE07XG4gICAgcHJvdG8kMS5tZXJpZGllbSA9IGxvY2FsZU1lcmlkaWVtO1xuXG4gICAgZnVuY3Rpb24gZ2V0JDEoZm9ybWF0LCBpbmRleCwgZmllbGQsIHNldHRlcikge1xuICAgICAgICB2YXIgbG9jYWxlID0gZ2V0TG9jYWxlKCksXG4gICAgICAgICAgICB1dGMgPSBjcmVhdGVVVEMoKS5zZXQoc2V0dGVyLCBpbmRleCk7XG4gICAgICAgIHJldHVybiBsb2NhbGVbZmllbGRdKHV0YywgZm9ybWF0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaXN0TW9udGhzSW1wbChmb3JtYXQsIGluZGV4LCBmaWVsZCkge1xuICAgICAgICBpZiAoaXNOdW1iZXIoZm9ybWF0KSkge1xuICAgICAgICAgICAgaW5kZXggPSBmb3JtYXQ7XG4gICAgICAgICAgICBmb3JtYXQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBmb3JtYXQgPSBmb3JtYXQgfHwgJyc7XG5cbiAgICAgICAgaWYgKGluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXQkMShmb3JtYXQsIGluZGV4LCBmaWVsZCwgJ21vbnRoJyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgIG91dCA9IFtdO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMTI7IGkrKykge1xuICAgICAgICAgICAgb3V0W2ldID0gZ2V0JDEoZm9ybWF0LCBpLCBmaWVsZCwgJ21vbnRoJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG5cbiAgICAvLyAoKVxuICAgIC8vICg1KVxuICAgIC8vIChmbXQsIDUpXG4gICAgLy8gKGZtdClcbiAgICAvLyAodHJ1ZSlcbiAgICAvLyAodHJ1ZSwgNSlcbiAgICAvLyAodHJ1ZSwgZm10LCA1KVxuICAgIC8vICh0cnVlLCBmbXQpXG4gICAgZnVuY3Rpb24gbGlzdFdlZWtkYXlzSW1wbChsb2NhbGVTb3J0ZWQsIGZvcm1hdCwgaW5kZXgsIGZpZWxkKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbG9jYWxlU29ydGVkID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgIGlmIChpc051bWJlcihmb3JtYXQpKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBmb3JtYXQ7XG4gICAgICAgICAgICAgICAgZm9ybWF0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3JtYXQgPSBmb3JtYXQgfHwgJyc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3JtYXQgPSBsb2NhbGVTb3J0ZWQ7XG4gICAgICAgICAgICBpbmRleCA9IGZvcm1hdDtcbiAgICAgICAgICAgIGxvY2FsZVNvcnRlZCA9IGZhbHNlO1xuXG4gICAgICAgICAgICBpZiAoaXNOdW1iZXIoZm9ybWF0KSkge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gZm9ybWF0O1xuICAgICAgICAgICAgICAgIGZvcm1hdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9ybWF0ID0gZm9ybWF0IHx8ICcnO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxvY2FsZSA9IGdldExvY2FsZSgpLFxuICAgICAgICAgICAgc2hpZnQgPSBsb2NhbGVTb3J0ZWQgPyBsb2NhbGUuX3dlZWsuZG93IDogMCxcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICBvdXQgPSBbXTtcblxuICAgICAgICBpZiAoaW5kZXggIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGdldCQxKGZvcm1hdCwgKGluZGV4ICsgc2hpZnQpICUgNywgZmllbGQsICdkYXknKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCA3OyBpKyspIHtcbiAgICAgICAgICAgIG91dFtpXSA9IGdldCQxKGZvcm1hdCwgKGkgKyBzaGlmdCkgJSA3LCBmaWVsZCwgJ2RheScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGlzdE1vbnRocyhmb3JtYXQsIGluZGV4KSB7XG4gICAgICAgIHJldHVybiBsaXN0TW9udGhzSW1wbChmb3JtYXQsIGluZGV4LCAnbW9udGhzJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGlzdE1vbnRoc1Nob3J0KGZvcm1hdCwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGxpc3RNb250aHNJbXBsKGZvcm1hdCwgaW5kZXgsICdtb250aHNTaG9ydCcpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpc3RXZWVrZGF5cyhsb2NhbGVTb3J0ZWQsIGZvcm1hdCwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGxpc3RXZWVrZGF5c0ltcGwobG9jYWxlU29ydGVkLCBmb3JtYXQsIGluZGV4LCAnd2Vla2RheXMnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaXN0V2Vla2RheXNTaG9ydChsb2NhbGVTb3J0ZWQsIGZvcm1hdCwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGxpc3RXZWVrZGF5c0ltcGwobG9jYWxlU29ydGVkLCBmb3JtYXQsIGluZGV4LCAnd2Vla2RheXNTaG9ydCcpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpc3RXZWVrZGF5c01pbihsb2NhbGVTb3J0ZWQsIGZvcm1hdCwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGxpc3RXZWVrZGF5c0ltcGwobG9jYWxlU29ydGVkLCBmb3JtYXQsIGluZGV4LCAnd2Vla2RheXNNaW4nKTtcbiAgICB9XG5cbiAgICBnZXRTZXRHbG9iYWxMb2NhbGUoJ2VuJywge1xuICAgICAgICBlcmFzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc2luY2U6ICcwMDAxLTAxLTAxJyxcbiAgICAgICAgICAgICAgICB1bnRpbDogK0luZmluaXR5LFxuICAgICAgICAgICAgICAgIG9mZnNldDogMSxcbiAgICAgICAgICAgICAgICBuYW1lOiAnQW5ubyBEb21pbmknLFxuICAgICAgICAgICAgICAgIG5hcnJvdzogJ0FEJyxcbiAgICAgICAgICAgICAgICBhYmJyOiAnQUQnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzaW5jZTogJzAwMDAtMTItMzEnLFxuICAgICAgICAgICAgICAgIHVudGlsOiAtSW5maW5pdHksXG4gICAgICAgICAgICAgICAgb2Zmc2V0OiAxLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdCZWZvcmUgQ2hyaXN0JyxcbiAgICAgICAgICAgICAgICBuYXJyb3c6ICdCQycsXG4gICAgICAgICAgICAgICAgYWJicjogJ0JDJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0sXG4gICAgICAgIGRheU9mTW9udGhPcmRpbmFsUGFyc2U6IC9cXGR7MSwyfSh0aHxzdHxuZHxyZCkvLFxuICAgICAgICBvcmRpbmFsOiBmdW5jdGlvbiAobnVtYmVyKSB7XG4gICAgICAgICAgICB2YXIgYiA9IG51bWJlciAlIDEwLFxuICAgICAgICAgICAgICAgIG91dHB1dCA9XG4gICAgICAgICAgICAgICAgICAgIHRvSW50KChudW1iZXIgJSAxMDApIC8gMTApID09PSAxXG4gICAgICAgICAgICAgICAgICAgICAgICA/ICd0aCdcbiAgICAgICAgICAgICAgICAgICAgICAgIDogYiA9PT0gMVxuICAgICAgICAgICAgICAgICAgICAgICAgPyAnc3QnXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGIgPT09IDJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gJ25kJ1xuICAgICAgICAgICAgICAgICAgICAgICAgOiBiID09PSAzXG4gICAgICAgICAgICAgICAgICAgICAgICA/ICdyZCdcbiAgICAgICAgICAgICAgICAgICAgICAgIDogJ3RoJztcbiAgICAgICAgICAgIHJldHVybiBudW1iZXIgKyBvdXRwdXQ7XG4gICAgICAgIH0sXG4gICAgfSk7XG5cbiAgICAvLyBTaWRlIGVmZmVjdCBpbXBvcnRzXG5cbiAgICBob29rcy5sYW5nID0gZGVwcmVjYXRlKFxuICAgICAgICAnbW9tZW50LmxhbmcgaXMgZGVwcmVjYXRlZC4gVXNlIG1vbWVudC5sb2NhbGUgaW5zdGVhZC4nLFxuICAgICAgICBnZXRTZXRHbG9iYWxMb2NhbGVcbiAgICApO1xuICAgIGhvb2tzLmxhbmdEYXRhID0gZGVwcmVjYXRlKFxuICAgICAgICAnbW9tZW50LmxhbmdEYXRhIGlzIGRlcHJlY2F0ZWQuIFVzZSBtb21lbnQubG9jYWxlRGF0YSBpbnN0ZWFkLicsXG4gICAgICAgIGdldExvY2FsZVxuICAgICk7XG5cbiAgICB2YXIgbWF0aEFicyA9IE1hdGguYWJzO1xuXG4gICAgZnVuY3Rpb24gYWJzKCkge1xuICAgICAgICB2YXIgZGF0YSA9IHRoaXMuX2RhdGE7XG5cbiAgICAgICAgdGhpcy5fbWlsbGlzZWNvbmRzID0gbWF0aEFicyh0aGlzLl9taWxsaXNlY29uZHMpO1xuICAgICAgICB0aGlzLl9kYXlzID0gbWF0aEFicyh0aGlzLl9kYXlzKTtcbiAgICAgICAgdGhpcy5fbW9udGhzID0gbWF0aEFicyh0aGlzLl9tb250aHMpO1xuXG4gICAgICAgIGRhdGEubWlsbGlzZWNvbmRzID0gbWF0aEFicyhkYXRhLm1pbGxpc2Vjb25kcyk7XG4gICAgICAgIGRhdGEuc2Vjb25kcyA9IG1hdGhBYnMoZGF0YS5zZWNvbmRzKTtcbiAgICAgICAgZGF0YS5taW51dGVzID0gbWF0aEFicyhkYXRhLm1pbnV0ZXMpO1xuICAgICAgICBkYXRhLmhvdXJzID0gbWF0aEFicyhkYXRhLmhvdXJzKTtcbiAgICAgICAgZGF0YS5tb250aHMgPSBtYXRoQWJzKGRhdGEubW9udGhzKTtcbiAgICAgICAgZGF0YS55ZWFycyA9IG1hdGhBYnMoZGF0YS55ZWFycyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkU3VidHJhY3QkMShkdXJhdGlvbiwgaW5wdXQsIHZhbHVlLCBkaXJlY3Rpb24pIHtcbiAgICAgICAgdmFyIG90aGVyID0gY3JlYXRlRHVyYXRpb24oaW5wdXQsIHZhbHVlKTtcblxuICAgICAgICBkdXJhdGlvbi5fbWlsbGlzZWNvbmRzICs9IGRpcmVjdGlvbiAqIG90aGVyLl9taWxsaXNlY29uZHM7XG4gICAgICAgIGR1cmF0aW9uLl9kYXlzICs9IGRpcmVjdGlvbiAqIG90aGVyLl9kYXlzO1xuICAgICAgICBkdXJhdGlvbi5fbW9udGhzICs9IGRpcmVjdGlvbiAqIG90aGVyLl9tb250aHM7XG5cbiAgICAgICAgcmV0dXJuIGR1cmF0aW9uLl9idWJibGUoKTtcbiAgICB9XG5cbiAgICAvLyBzdXBwb3J0cyBvbmx5IDIuMC1zdHlsZSBhZGQoMSwgJ3MnKSBvciBhZGQoZHVyYXRpb24pXG4gICAgZnVuY3Rpb24gYWRkJDEoaW5wdXQsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBhZGRTdWJ0cmFjdCQxKHRoaXMsIGlucHV0LCB2YWx1ZSwgMSk7XG4gICAgfVxuXG4gICAgLy8gc3VwcG9ydHMgb25seSAyLjAtc3R5bGUgc3VidHJhY3QoMSwgJ3MnKSBvciBzdWJ0cmFjdChkdXJhdGlvbilcbiAgICBmdW5jdGlvbiBzdWJ0cmFjdCQxKGlucHV0LCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gYWRkU3VidHJhY3QkMSh0aGlzLCBpbnB1dCwgdmFsdWUsIC0xKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhYnNDZWlsKG51bWJlcikge1xuICAgICAgICBpZiAobnVtYmVyIDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IobnVtYmVyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmNlaWwobnVtYmVyKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGJ1YmJsZSgpIHtcbiAgICAgICAgdmFyIG1pbGxpc2Vjb25kcyA9IHRoaXMuX21pbGxpc2Vjb25kcyxcbiAgICAgICAgICAgIGRheXMgPSB0aGlzLl9kYXlzLFxuICAgICAgICAgICAgbW9udGhzID0gdGhpcy5fbW9udGhzLFxuICAgICAgICAgICAgZGF0YSA9IHRoaXMuX2RhdGEsXG4gICAgICAgICAgICBzZWNvbmRzLFxuICAgICAgICAgICAgbWludXRlcyxcbiAgICAgICAgICAgIGhvdXJzLFxuICAgICAgICAgICAgeWVhcnMsXG4gICAgICAgICAgICBtb250aHNGcm9tRGF5cztcblxuICAgICAgICAvLyBpZiB3ZSBoYXZlIGEgbWl4IG9mIHBvc2l0aXZlIGFuZCBuZWdhdGl2ZSB2YWx1ZXMsIGJ1YmJsZSBkb3duIGZpcnN0XG4gICAgICAgIC8vIGNoZWNrOiBodHRwczovL2dpdGh1Yi5jb20vbW9tZW50L21vbWVudC9pc3N1ZXMvMjE2NlxuICAgICAgICBpZiAoXG4gICAgICAgICAgICAhKFxuICAgICAgICAgICAgICAgIChtaWxsaXNlY29uZHMgPj0gMCAmJiBkYXlzID49IDAgJiYgbW9udGhzID49IDApIHx8XG4gICAgICAgICAgICAgICAgKG1pbGxpc2Vjb25kcyA8PSAwICYmIGRheXMgPD0gMCAmJiBtb250aHMgPD0gMClcbiAgICAgICAgICAgIClcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBtaWxsaXNlY29uZHMgKz0gYWJzQ2VpbChtb250aHNUb0RheXMobW9udGhzKSArIGRheXMpICogODY0ZTU7XG4gICAgICAgICAgICBkYXlzID0gMDtcbiAgICAgICAgICAgIG1vbnRocyA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUaGUgZm9sbG93aW5nIGNvZGUgYnViYmxlcyB1cCB2YWx1ZXMsIHNlZSB0aGUgdGVzdHMgZm9yXG4gICAgICAgIC8vIGV4YW1wbGVzIG9mIHdoYXQgdGhhdCBtZWFucy5cbiAgICAgICAgZGF0YS5taWxsaXNlY29uZHMgPSBtaWxsaXNlY29uZHMgJSAxMDAwO1xuXG4gICAgICAgIHNlY29uZHMgPSBhYnNGbG9vcihtaWxsaXNlY29uZHMgLyAxMDAwKTtcbiAgICAgICAgZGF0YS5zZWNvbmRzID0gc2Vjb25kcyAlIDYwO1xuXG4gICAgICAgIG1pbnV0ZXMgPSBhYnNGbG9vcihzZWNvbmRzIC8gNjApO1xuICAgICAgICBkYXRhLm1pbnV0ZXMgPSBtaW51dGVzICUgNjA7XG5cbiAgICAgICAgaG91cnMgPSBhYnNGbG9vcihtaW51dGVzIC8gNjApO1xuICAgICAgICBkYXRhLmhvdXJzID0gaG91cnMgJSAyNDtcblxuICAgICAgICBkYXlzICs9IGFic0Zsb29yKGhvdXJzIC8gMjQpO1xuXG4gICAgICAgIC8vIGNvbnZlcnQgZGF5cyB0byBtb250aHNcbiAgICAgICAgbW9udGhzRnJvbURheXMgPSBhYnNGbG9vcihkYXlzVG9Nb250aHMoZGF5cykpO1xuICAgICAgICBtb250aHMgKz0gbW9udGhzRnJvbURheXM7XG4gICAgICAgIGRheXMgLT0gYWJzQ2VpbChtb250aHNUb0RheXMobW9udGhzRnJvbURheXMpKTtcblxuICAgICAgICAvLyAxMiBtb250aHMgLT4gMSB5ZWFyXG4gICAgICAgIHllYXJzID0gYWJzRmxvb3IobW9udGhzIC8gMTIpO1xuICAgICAgICBtb250aHMgJT0gMTI7XG5cbiAgICAgICAgZGF0YS5kYXlzID0gZGF5cztcbiAgICAgICAgZGF0YS5tb250aHMgPSBtb250aHM7XG4gICAgICAgIGRhdGEueWVhcnMgPSB5ZWFycztcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkYXlzVG9Nb250aHMoZGF5cykge1xuICAgICAgICAvLyA0MDAgeWVhcnMgaGF2ZSAxNDYwOTcgZGF5cyAodGFraW5nIGludG8gYWNjb3VudCBsZWFwIHllYXIgcnVsZXMpXG4gICAgICAgIC8vIDQwMCB5ZWFycyBoYXZlIDEyIG1vbnRocyA9PT0gNDgwMFxuICAgICAgICByZXR1cm4gKGRheXMgKiA0ODAwKSAvIDE0NjA5NztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtb250aHNUb0RheXMobW9udGhzKSB7XG4gICAgICAgIC8vIHRoZSByZXZlcnNlIG9mIGRheXNUb01vbnRoc1xuICAgICAgICByZXR1cm4gKG1vbnRocyAqIDE0NjA5NykgLyA0ODAwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFzKHVuaXRzKSB7XG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBOYU47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRheXMsXG4gICAgICAgICAgICBtb250aHMsXG4gICAgICAgICAgICBtaWxsaXNlY29uZHMgPSB0aGlzLl9taWxsaXNlY29uZHM7XG5cbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG5cbiAgICAgICAgaWYgKHVuaXRzID09PSAnbW9udGgnIHx8IHVuaXRzID09PSAncXVhcnRlcicgfHwgdW5pdHMgPT09ICd5ZWFyJykge1xuICAgICAgICAgICAgZGF5cyA9IHRoaXMuX2RheXMgKyBtaWxsaXNlY29uZHMgLyA4NjRlNTtcbiAgICAgICAgICAgIG1vbnRocyA9IHRoaXMuX21vbnRocyArIGRheXNUb01vbnRocyhkYXlzKTtcbiAgICAgICAgICAgIHN3aXRjaCAodW5pdHMpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdtb250aCc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtb250aHM7XG4gICAgICAgICAgICAgICAgY2FzZSAncXVhcnRlcic6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtb250aHMgLyAzO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3llYXInOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbW9udGhzIC8gMTI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBoYW5kbGUgbWlsbGlzZWNvbmRzIHNlcGFyYXRlbHkgYmVjYXVzZSBvZiBmbG9hdGluZyBwb2ludCBtYXRoIGVycm9ycyAoaXNzdWUgIzE4NjcpXG4gICAgICAgICAgICBkYXlzID0gdGhpcy5fZGF5cyArIE1hdGgucm91bmQobW9udGhzVG9EYXlzKHRoaXMuX21vbnRocykpO1xuICAgICAgICAgICAgc3dpdGNoICh1bml0cykge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3dlZWsnOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF5cyAvIDcgKyBtaWxsaXNlY29uZHMgLyA2MDQ4ZTU7XG4gICAgICAgICAgICAgICAgY2FzZSAnZGF5JzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRheXMgKyBtaWxsaXNlY29uZHMgLyA4NjRlNTtcbiAgICAgICAgICAgICAgICBjYXNlICdob3VyJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRheXMgKiAyNCArIG1pbGxpc2Vjb25kcyAvIDM2ZTU7XG4gICAgICAgICAgICAgICAgY2FzZSAnbWludXRlJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRheXMgKiAxNDQwICsgbWlsbGlzZWNvbmRzIC8gNmU0O1xuICAgICAgICAgICAgICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXlzICogODY0MDAgKyBtaWxsaXNlY29uZHMgLyAxMDAwO1xuICAgICAgICAgICAgICAgIC8vIE1hdGguZmxvb3IgcHJldmVudHMgZmxvYXRpbmcgcG9pbnQgbWF0aCBlcnJvcnMgaGVyZVxuICAgICAgICAgICAgICAgIGNhc2UgJ21pbGxpc2Vjb25kJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IoZGF5cyAqIDg2NGU1KSArIG1pbGxpc2Vjb25kcztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gdW5pdCAnICsgdW5pdHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gVE9ETzogVXNlIHRoaXMuYXMoJ21zJyk/XG4gICAgZnVuY3Rpb24gdmFsdWVPZiQxKCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICB0aGlzLl9taWxsaXNlY29uZHMgK1xuICAgICAgICAgICAgdGhpcy5fZGF5cyAqIDg2NGU1ICtcbiAgICAgICAgICAgICh0aGlzLl9tb250aHMgJSAxMikgKiAyNTkyZTYgK1xuICAgICAgICAgICAgdG9JbnQodGhpcy5fbW9udGhzIC8gMTIpICogMzE1MzZlNlxuICAgICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1ha2VBcyhhbGlhcykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXMoYWxpYXMpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHZhciBhc01pbGxpc2Vjb25kcyA9IG1ha2VBcygnbXMnKSxcbiAgICAgICAgYXNTZWNvbmRzID0gbWFrZUFzKCdzJyksXG4gICAgICAgIGFzTWludXRlcyA9IG1ha2VBcygnbScpLFxuICAgICAgICBhc0hvdXJzID0gbWFrZUFzKCdoJyksXG4gICAgICAgIGFzRGF5cyA9IG1ha2VBcygnZCcpLFxuICAgICAgICBhc1dlZWtzID0gbWFrZUFzKCd3JyksXG4gICAgICAgIGFzTW9udGhzID0gbWFrZUFzKCdNJyksXG4gICAgICAgIGFzUXVhcnRlcnMgPSBtYWtlQXMoJ1EnKSxcbiAgICAgICAgYXNZZWFycyA9IG1ha2VBcygneScpO1xuXG4gICAgZnVuY3Rpb24gY2xvbmUkMSgpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUR1cmF0aW9uKHRoaXMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldCQyKHVuaXRzKSB7XG4gICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xuICAgICAgICByZXR1cm4gdGhpcy5pc1ZhbGlkKCkgPyB0aGlzW3VuaXRzICsgJ3MnXSgpIDogTmFOO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1ha2VHZXR0ZXIobmFtZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXNWYWxpZCgpID8gdGhpcy5fZGF0YVtuYW1lXSA6IE5hTjtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgbWlsbGlzZWNvbmRzID0gbWFrZUdldHRlcignbWlsbGlzZWNvbmRzJyksXG4gICAgICAgIHNlY29uZHMgPSBtYWtlR2V0dGVyKCdzZWNvbmRzJyksXG4gICAgICAgIG1pbnV0ZXMgPSBtYWtlR2V0dGVyKCdtaW51dGVzJyksXG4gICAgICAgIGhvdXJzID0gbWFrZUdldHRlcignaG91cnMnKSxcbiAgICAgICAgZGF5cyA9IG1ha2VHZXR0ZXIoJ2RheXMnKSxcbiAgICAgICAgbW9udGhzID0gbWFrZUdldHRlcignbW9udGhzJyksXG4gICAgICAgIHllYXJzID0gbWFrZUdldHRlcigneWVhcnMnKTtcblxuICAgIGZ1bmN0aW9uIHdlZWtzKCkge1xuICAgICAgICByZXR1cm4gYWJzRmxvb3IodGhpcy5kYXlzKCkgLyA3KTtcbiAgICB9XG5cbiAgICB2YXIgcm91bmQgPSBNYXRoLnJvdW5kLFxuICAgICAgICB0aHJlc2hvbGRzID0ge1xuICAgICAgICAgICAgc3M6IDQ0LCAvLyBhIGZldyBzZWNvbmRzIHRvIHNlY29uZHNcbiAgICAgICAgICAgIHM6IDQ1LCAvLyBzZWNvbmRzIHRvIG1pbnV0ZVxuICAgICAgICAgICAgbTogNDUsIC8vIG1pbnV0ZXMgdG8gaG91clxuICAgICAgICAgICAgaDogMjIsIC8vIGhvdXJzIHRvIGRheVxuICAgICAgICAgICAgZDogMjYsIC8vIGRheXMgdG8gbW9udGgvd2Vla1xuICAgICAgICAgICAgdzogbnVsbCwgLy8gd2Vla3MgdG8gbW9udGhcbiAgICAgICAgICAgIE06IDExLCAvLyBtb250aHMgdG8geWVhclxuICAgICAgICB9O1xuXG4gICAgLy8gaGVscGVyIGZ1bmN0aW9uIGZvciBtb21lbnQuZm4uZnJvbSwgbW9tZW50LmZuLmZyb21Ob3csIGFuZCBtb21lbnQuZHVyYXRpb24uZm4uaHVtYW5pemVcbiAgICBmdW5jdGlvbiBzdWJzdGl0dXRlVGltZUFnbyhzdHJpbmcsIG51bWJlciwgd2l0aG91dFN1ZmZpeCwgaXNGdXR1cmUsIGxvY2FsZSkge1xuICAgICAgICByZXR1cm4gbG9jYWxlLnJlbGF0aXZlVGltZShudW1iZXIgfHwgMSwgISF3aXRob3V0U3VmZml4LCBzdHJpbmcsIGlzRnV0dXJlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZWxhdGl2ZVRpbWUkMShwb3NOZWdEdXJhdGlvbiwgd2l0aG91dFN1ZmZpeCwgdGhyZXNob2xkcywgbG9jYWxlKSB7XG4gICAgICAgIHZhciBkdXJhdGlvbiA9IGNyZWF0ZUR1cmF0aW9uKHBvc05lZ0R1cmF0aW9uKS5hYnMoKSxcbiAgICAgICAgICAgIHNlY29uZHMgPSByb3VuZChkdXJhdGlvbi5hcygncycpKSxcbiAgICAgICAgICAgIG1pbnV0ZXMgPSByb3VuZChkdXJhdGlvbi5hcygnbScpKSxcbiAgICAgICAgICAgIGhvdXJzID0gcm91bmQoZHVyYXRpb24uYXMoJ2gnKSksXG4gICAgICAgICAgICBkYXlzID0gcm91bmQoZHVyYXRpb24uYXMoJ2QnKSksXG4gICAgICAgICAgICBtb250aHMgPSByb3VuZChkdXJhdGlvbi5hcygnTScpKSxcbiAgICAgICAgICAgIHdlZWtzID0gcm91bmQoZHVyYXRpb24uYXMoJ3cnKSksXG4gICAgICAgICAgICB5ZWFycyA9IHJvdW5kKGR1cmF0aW9uLmFzKCd5JykpLFxuICAgICAgICAgICAgYSA9XG4gICAgICAgICAgICAgICAgKHNlY29uZHMgPD0gdGhyZXNob2xkcy5zcyAmJiBbJ3MnLCBzZWNvbmRzXSkgfHxcbiAgICAgICAgICAgICAgICAoc2Vjb25kcyA8IHRocmVzaG9sZHMucyAmJiBbJ3NzJywgc2Vjb25kc10pIHx8XG4gICAgICAgICAgICAgICAgKG1pbnV0ZXMgPD0gMSAmJiBbJ20nXSkgfHxcbiAgICAgICAgICAgICAgICAobWludXRlcyA8IHRocmVzaG9sZHMubSAmJiBbJ21tJywgbWludXRlc10pIHx8XG4gICAgICAgICAgICAgICAgKGhvdXJzIDw9IDEgJiYgWydoJ10pIHx8XG4gICAgICAgICAgICAgICAgKGhvdXJzIDwgdGhyZXNob2xkcy5oICYmIFsnaGgnLCBob3Vyc10pIHx8XG4gICAgICAgICAgICAgICAgKGRheXMgPD0gMSAmJiBbJ2QnXSkgfHxcbiAgICAgICAgICAgICAgICAoZGF5cyA8IHRocmVzaG9sZHMuZCAmJiBbJ2RkJywgZGF5c10pO1xuXG4gICAgICAgIGlmICh0aHJlc2hvbGRzLncgIT0gbnVsbCkge1xuICAgICAgICAgICAgYSA9XG4gICAgICAgICAgICAgICAgYSB8fFxuICAgICAgICAgICAgICAgICh3ZWVrcyA8PSAxICYmIFsndyddKSB8fFxuICAgICAgICAgICAgICAgICh3ZWVrcyA8IHRocmVzaG9sZHMudyAmJiBbJ3d3Jywgd2Vla3NdKTtcbiAgICAgICAgfVxuICAgICAgICBhID0gYSB8fFxuICAgICAgICAgICAgKG1vbnRocyA8PSAxICYmIFsnTSddKSB8fFxuICAgICAgICAgICAgKG1vbnRocyA8IHRocmVzaG9sZHMuTSAmJiBbJ01NJywgbW9udGhzXSkgfHxcbiAgICAgICAgICAgICh5ZWFycyA8PSAxICYmIFsneSddKSB8fCBbJ3l5JywgeWVhcnNdO1xuXG4gICAgICAgIGFbMl0gPSB3aXRob3V0U3VmZml4O1xuICAgICAgICBhWzNdID0gK3Bvc05lZ0R1cmF0aW9uID4gMDtcbiAgICAgICAgYVs0XSA9IGxvY2FsZTtcbiAgICAgICAgcmV0dXJuIHN1YnN0aXR1dGVUaW1lQWdvLmFwcGx5KG51bGwsIGEpO1xuICAgIH1cblxuICAgIC8vIFRoaXMgZnVuY3Rpb24gYWxsb3dzIHlvdSB0byBzZXQgdGhlIHJvdW5kaW5nIGZ1bmN0aW9uIGZvciByZWxhdGl2ZSB0aW1lIHN0cmluZ3NcbiAgICBmdW5jdGlvbiBnZXRTZXRSZWxhdGl2ZVRpbWVSb3VuZGluZyhyb3VuZGluZ0Z1bmN0aW9uKSB7XG4gICAgICAgIGlmIChyb3VuZGluZ0Z1bmN0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiByb3VuZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHJvdW5kaW5nRnVuY3Rpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJvdW5kID0gcm91bmRpbmdGdW5jdGlvbjtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBUaGlzIGZ1bmN0aW9uIGFsbG93cyB5b3UgdG8gc2V0IGEgdGhyZXNob2xkIGZvciByZWxhdGl2ZSB0aW1lIHN0cmluZ3NcbiAgICBmdW5jdGlvbiBnZXRTZXRSZWxhdGl2ZVRpbWVUaHJlc2hvbGQodGhyZXNob2xkLCBsaW1pdCkge1xuICAgICAgICBpZiAodGhyZXNob2xkc1t0aHJlc2hvbGRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGltaXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRocmVzaG9sZHNbdGhyZXNob2xkXTtcbiAgICAgICAgfVxuICAgICAgICB0aHJlc2hvbGRzW3RocmVzaG9sZF0gPSBsaW1pdDtcbiAgICAgICAgaWYgKHRocmVzaG9sZCA9PT0gJ3MnKSB7XG4gICAgICAgICAgICB0aHJlc2hvbGRzLnNzID0gbGltaXQgLSAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGh1bWFuaXplKGFyZ1dpdGhTdWZmaXgsIGFyZ1RocmVzaG9sZHMpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLmludmFsaWREYXRlKCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgd2l0aFN1ZmZpeCA9IGZhbHNlLFxuICAgICAgICAgICAgdGggPSB0aHJlc2hvbGRzLFxuICAgICAgICAgICAgbG9jYWxlLFxuICAgICAgICAgICAgb3V0cHV0O1xuXG4gICAgICAgIGlmICh0eXBlb2YgYXJnV2l0aFN1ZmZpeCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGFyZ1RocmVzaG9sZHMgPSBhcmdXaXRoU3VmZml4O1xuICAgICAgICAgICAgYXJnV2l0aFN1ZmZpeCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgYXJnV2l0aFN1ZmZpeCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICB3aXRoU3VmZml4ID0gYXJnV2l0aFN1ZmZpeDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGFyZ1RocmVzaG9sZHMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICB0aCA9IE9iamVjdC5hc3NpZ24oe30sIHRocmVzaG9sZHMsIGFyZ1RocmVzaG9sZHMpO1xuICAgICAgICAgICAgaWYgKGFyZ1RocmVzaG9sZHMucyAhPSBudWxsICYmIGFyZ1RocmVzaG9sZHMuc3MgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoLnNzID0gYXJnVGhyZXNob2xkcy5zIC0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGxvY2FsZSA9IHRoaXMubG9jYWxlRGF0YSgpO1xuICAgICAgICBvdXRwdXQgPSByZWxhdGl2ZVRpbWUkMSh0aGlzLCAhd2l0aFN1ZmZpeCwgdGgsIGxvY2FsZSk7XG5cbiAgICAgICAgaWYgKHdpdGhTdWZmaXgpIHtcbiAgICAgICAgICAgIG91dHB1dCA9IGxvY2FsZS5wYXN0RnV0dXJlKCt0aGlzLCBvdXRwdXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGxvY2FsZS5wb3N0Zm9ybWF0KG91dHB1dCk7XG4gICAgfVxuXG4gICAgdmFyIGFicyQxID0gTWF0aC5hYnM7XG5cbiAgICBmdW5jdGlvbiBzaWduKHgpIHtcbiAgICAgICAgcmV0dXJuICh4ID4gMCkgLSAoeCA8IDApIHx8ICt4O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvSVNPU3RyaW5nJDEoKSB7XG4gICAgICAgIC8vIGZvciBJU08gc3RyaW5ncyB3ZSBkbyBub3QgdXNlIHRoZSBub3JtYWwgYnViYmxpbmcgcnVsZXM6XG4gICAgICAgIC8vICAqIG1pbGxpc2Vjb25kcyBidWJibGUgdXAgdW50aWwgdGhleSBiZWNvbWUgaG91cnNcbiAgICAgICAgLy8gICogZGF5cyBkbyBub3QgYnViYmxlIGF0IGFsbFxuICAgICAgICAvLyAgKiBtb250aHMgYnViYmxlIHVwIHVudGlsIHRoZXkgYmVjb21lIHllYXJzXG4gICAgICAgIC8vIFRoaXMgaXMgYmVjYXVzZSB0aGVyZSBpcyBubyBjb250ZXh0LWZyZWUgY29udmVyc2lvbiBiZXR3ZWVuIGhvdXJzIGFuZCBkYXlzXG4gICAgICAgIC8vICh0aGluayBvZiBjbG9jayBjaGFuZ2VzKVxuICAgICAgICAvLyBhbmQgYWxzbyBub3QgYmV0d2VlbiBkYXlzIGFuZCBtb250aHMgKDI4LTMxIGRheXMgcGVyIG1vbnRoKVxuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkuaW52YWxpZERhdGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzZWNvbmRzID0gYWJzJDEodGhpcy5fbWlsbGlzZWNvbmRzKSAvIDEwMDAsXG4gICAgICAgICAgICBkYXlzID0gYWJzJDEodGhpcy5fZGF5cyksXG4gICAgICAgICAgICBtb250aHMgPSBhYnMkMSh0aGlzLl9tb250aHMpLFxuICAgICAgICAgICAgbWludXRlcyxcbiAgICAgICAgICAgIGhvdXJzLFxuICAgICAgICAgICAgeWVhcnMsXG4gICAgICAgICAgICBzLFxuICAgICAgICAgICAgdG90YWwgPSB0aGlzLmFzU2Vjb25kcygpLFxuICAgICAgICAgICAgdG90YWxTaWduLFxuICAgICAgICAgICAgeW1TaWduLFxuICAgICAgICAgICAgZGF5c1NpZ24sXG4gICAgICAgICAgICBobXNTaWduO1xuXG4gICAgICAgIGlmICghdG90YWwpIHtcbiAgICAgICAgICAgIC8vIHRoaXMgaXMgdGhlIHNhbWUgYXMgQyMncyAoTm9kYSkgYW5kIHB5dGhvbiAoaXNvZGF0ZSkuLi5cbiAgICAgICAgICAgIC8vIGJ1dCBub3Qgb3RoZXIgSlMgKGdvb2cuZGF0ZSlcbiAgICAgICAgICAgIHJldHVybiAnUDBEJztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIDM2MDAgc2Vjb25kcyAtPiA2MCBtaW51dGVzIC0+IDEgaG91clxuICAgICAgICBtaW51dGVzID0gYWJzRmxvb3Ioc2Vjb25kcyAvIDYwKTtcbiAgICAgICAgaG91cnMgPSBhYnNGbG9vcihtaW51dGVzIC8gNjApO1xuICAgICAgICBzZWNvbmRzICU9IDYwO1xuICAgICAgICBtaW51dGVzICU9IDYwO1xuXG4gICAgICAgIC8vIDEyIG1vbnRocyAtPiAxIHllYXJcbiAgICAgICAgeWVhcnMgPSBhYnNGbG9vcihtb250aHMgLyAxMik7XG4gICAgICAgIG1vbnRocyAlPSAxMjtcblxuICAgICAgICAvLyBpbnNwaXJlZCBieSBodHRwczovL2dpdGh1Yi5jb20vZG9yZGlsbGUvbW9tZW50LWlzb2R1cmF0aW9uL2Jsb2IvbWFzdGVyL21vbWVudC5pc29kdXJhdGlvbi5qc1xuICAgICAgICBzID0gc2Vjb25kcyA/IHNlY29uZHMudG9GaXhlZCgzKS5yZXBsYWNlKC9cXC4/MCskLywgJycpIDogJyc7XG5cbiAgICAgICAgdG90YWxTaWduID0gdG90YWwgPCAwID8gJy0nIDogJyc7XG4gICAgICAgIHltU2lnbiA9IHNpZ24odGhpcy5fbW9udGhzKSAhPT0gc2lnbih0b3RhbCkgPyAnLScgOiAnJztcbiAgICAgICAgZGF5c1NpZ24gPSBzaWduKHRoaXMuX2RheXMpICE9PSBzaWduKHRvdGFsKSA/ICctJyA6ICcnO1xuICAgICAgICBobXNTaWduID0gc2lnbih0aGlzLl9taWxsaXNlY29uZHMpICE9PSBzaWduKHRvdGFsKSA/ICctJyA6ICcnO1xuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICB0b3RhbFNpZ24gK1xuICAgICAgICAgICAgJ1AnICtcbiAgICAgICAgICAgICh5ZWFycyA/IHltU2lnbiArIHllYXJzICsgJ1knIDogJycpICtcbiAgICAgICAgICAgIChtb250aHMgPyB5bVNpZ24gKyBtb250aHMgKyAnTScgOiAnJykgK1xuICAgICAgICAgICAgKGRheXMgPyBkYXlzU2lnbiArIGRheXMgKyAnRCcgOiAnJykgK1xuICAgICAgICAgICAgKGhvdXJzIHx8IG1pbnV0ZXMgfHwgc2Vjb25kcyA/ICdUJyA6ICcnKSArXG4gICAgICAgICAgICAoaG91cnMgPyBobXNTaWduICsgaG91cnMgKyAnSCcgOiAnJykgK1xuICAgICAgICAgICAgKG1pbnV0ZXMgPyBobXNTaWduICsgbWludXRlcyArICdNJyA6ICcnKSArXG4gICAgICAgICAgICAoc2Vjb25kcyA/IGhtc1NpZ24gKyBzICsgJ1MnIDogJycpXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgdmFyIHByb3RvJDIgPSBEdXJhdGlvbi5wcm90b3R5cGU7XG5cbiAgICBwcm90byQyLmlzVmFsaWQgPSBpc1ZhbGlkJDE7XG4gICAgcHJvdG8kMi5hYnMgPSBhYnM7XG4gICAgcHJvdG8kMi5hZGQgPSBhZGQkMTtcbiAgICBwcm90byQyLnN1YnRyYWN0ID0gc3VidHJhY3QkMTtcbiAgICBwcm90byQyLmFzID0gYXM7XG4gICAgcHJvdG8kMi5hc01pbGxpc2Vjb25kcyA9IGFzTWlsbGlzZWNvbmRzO1xuICAgIHByb3RvJDIuYXNTZWNvbmRzID0gYXNTZWNvbmRzO1xuICAgIHByb3RvJDIuYXNNaW51dGVzID0gYXNNaW51dGVzO1xuICAgIHByb3RvJDIuYXNIb3VycyA9IGFzSG91cnM7XG4gICAgcHJvdG8kMi5hc0RheXMgPSBhc0RheXM7XG4gICAgcHJvdG8kMi5hc1dlZWtzID0gYXNXZWVrcztcbiAgICBwcm90byQyLmFzTW9udGhzID0gYXNNb250aHM7XG4gICAgcHJvdG8kMi5hc1F1YXJ0ZXJzID0gYXNRdWFydGVycztcbiAgICBwcm90byQyLmFzWWVhcnMgPSBhc1llYXJzO1xuICAgIHByb3RvJDIudmFsdWVPZiA9IHZhbHVlT2YkMTtcbiAgICBwcm90byQyLl9idWJibGUgPSBidWJibGU7XG4gICAgcHJvdG8kMi5jbG9uZSA9IGNsb25lJDE7XG4gICAgcHJvdG8kMi5nZXQgPSBnZXQkMjtcbiAgICBwcm90byQyLm1pbGxpc2Vjb25kcyA9IG1pbGxpc2Vjb25kcztcbiAgICBwcm90byQyLnNlY29uZHMgPSBzZWNvbmRzO1xuICAgIHByb3RvJDIubWludXRlcyA9IG1pbnV0ZXM7XG4gICAgcHJvdG8kMi5ob3VycyA9IGhvdXJzO1xuICAgIHByb3RvJDIuZGF5cyA9IGRheXM7XG4gICAgcHJvdG8kMi53ZWVrcyA9IHdlZWtzO1xuICAgIHByb3RvJDIubW9udGhzID0gbW9udGhzO1xuICAgIHByb3RvJDIueWVhcnMgPSB5ZWFycztcbiAgICBwcm90byQyLmh1bWFuaXplID0gaHVtYW5pemU7XG4gICAgcHJvdG8kMi50b0lTT1N0cmluZyA9IHRvSVNPU3RyaW5nJDE7XG4gICAgcHJvdG8kMi50b1N0cmluZyA9IHRvSVNPU3RyaW5nJDE7XG4gICAgcHJvdG8kMi50b0pTT04gPSB0b0lTT1N0cmluZyQxO1xuICAgIHByb3RvJDIubG9jYWxlID0gbG9jYWxlO1xuICAgIHByb3RvJDIubG9jYWxlRGF0YSA9IGxvY2FsZURhdGE7XG5cbiAgICBwcm90byQyLnRvSXNvU3RyaW5nID0gZGVwcmVjYXRlKFxuICAgICAgICAndG9Jc29TdHJpbmcoKSBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIHRvSVNPU3RyaW5nKCkgaW5zdGVhZCAobm90aWNlIHRoZSBjYXBpdGFscyknLFxuICAgICAgICB0b0lTT1N0cmluZyQxXG4gICAgKTtcbiAgICBwcm90byQyLmxhbmcgPSBsYW5nO1xuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ1gnLCAwLCAwLCAndW5peCcpO1xuICAgIGFkZEZvcm1hdFRva2VuKCd4JywgMCwgMCwgJ3ZhbHVlT2YnKTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ3gnLCBtYXRjaFNpZ25lZCk7XG4gICAgYWRkUmVnZXhUb2tlbignWCcsIG1hdGNoVGltZXN0YW1wKTtcbiAgICBhZGRQYXJzZVRva2VuKCdYJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKHBhcnNlRmxvYXQoaW5wdXQpICogMTAwMCk7XG4gICAgfSk7XG4gICAgYWRkUGFyc2VUb2tlbigneCcsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZSh0b0ludChpbnB1dCkpO1xuICAgIH0pO1xuXG4gICAgLy8hIG1vbWVudC5qc1xuXG4gICAgaG9va3MudmVyc2lvbiA9ICcyLjI5LjEnO1xuXG4gICAgc2V0SG9va0NhbGxiYWNrKGNyZWF0ZUxvY2FsKTtcblxuICAgIGhvb2tzLmZuID0gcHJvdG87XG4gICAgaG9va3MubWluID0gbWluO1xuICAgIGhvb2tzLm1heCA9IG1heDtcbiAgICBob29rcy5ub3cgPSBub3c7XG4gICAgaG9va3MudXRjID0gY3JlYXRlVVRDO1xuICAgIGhvb2tzLnVuaXggPSBjcmVhdGVVbml4O1xuICAgIGhvb2tzLm1vbnRocyA9IGxpc3RNb250aHM7XG4gICAgaG9va3MuaXNEYXRlID0gaXNEYXRlO1xuICAgIGhvb2tzLmxvY2FsZSA9IGdldFNldEdsb2JhbExvY2FsZTtcbiAgICBob29rcy5pbnZhbGlkID0gY3JlYXRlSW52YWxpZDtcbiAgICBob29rcy5kdXJhdGlvbiA9IGNyZWF0ZUR1cmF0aW9uO1xuICAgIGhvb2tzLmlzTW9tZW50ID0gaXNNb21lbnQ7XG4gICAgaG9va3Mud2Vla2RheXMgPSBsaXN0V2Vla2RheXM7XG4gICAgaG9va3MucGFyc2Vab25lID0gY3JlYXRlSW5ab25lO1xuICAgIGhvb2tzLmxvY2FsZURhdGEgPSBnZXRMb2NhbGU7XG4gICAgaG9va3MuaXNEdXJhdGlvbiA9IGlzRHVyYXRpb247XG4gICAgaG9va3MubW9udGhzU2hvcnQgPSBsaXN0TW9udGhzU2hvcnQ7XG4gICAgaG9va3Mud2Vla2RheXNNaW4gPSBsaXN0V2Vla2RheXNNaW47XG4gICAgaG9va3MuZGVmaW5lTG9jYWxlID0gZGVmaW5lTG9jYWxlO1xuICAgIGhvb2tzLnVwZGF0ZUxvY2FsZSA9IHVwZGF0ZUxvY2FsZTtcbiAgICBob29rcy5sb2NhbGVzID0gbGlzdExvY2FsZXM7XG4gICAgaG9va3Mud2Vla2RheXNTaG9ydCA9IGxpc3RXZWVrZGF5c1Nob3J0O1xuICAgIGhvb2tzLm5vcm1hbGl6ZVVuaXRzID0gbm9ybWFsaXplVW5pdHM7XG4gICAgaG9va3MucmVsYXRpdmVUaW1lUm91bmRpbmcgPSBnZXRTZXRSZWxhdGl2ZVRpbWVSb3VuZGluZztcbiAgICBob29rcy5yZWxhdGl2ZVRpbWVUaHJlc2hvbGQgPSBnZXRTZXRSZWxhdGl2ZVRpbWVUaHJlc2hvbGQ7XG4gICAgaG9va3MuY2FsZW5kYXJGb3JtYXQgPSBnZXRDYWxlbmRhckZvcm1hdDtcbiAgICBob29rcy5wcm90b3R5cGUgPSBwcm90bztcblxuICAgIC8vIGN1cnJlbnRseSBIVE1MNSBpbnB1dCB0eXBlIG9ubHkgc3VwcG9ydHMgMjQtaG91ciBmb3JtYXRzXG4gICAgaG9va3MuSFRNTDVfRk1UID0ge1xuICAgICAgICBEQVRFVElNRV9MT0NBTDogJ1lZWVktTU0tRERUSEg6bW0nLCAvLyA8aW5wdXQgdHlwZT1cImRhdGV0aW1lLWxvY2FsXCIgLz5cbiAgICAgICAgREFURVRJTUVfTE9DQUxfU0VDT05EUzogJ1lZWVktTU0tRERUSEg6bW06c3MnLCAvLyA8aW5wdXQgdHlwZT1cImRhdGV0aW1lLWxvY2FsXCIgc3RlcD1cIjFcIiAvPlxuICAgICAgICBEQVRFVElNRV9MT0NBTF9NUzogJ1lZWVktTU0tRERUSEg6bW06c3MuU1NTJywgLy8gPGlucHV0IHR5cGU9XCJkYXRldGltZS1sb2NhbFwiIHN0ZXA9XCIwLjAwMVwiIC8+XG4gICAgICAgIERBVEU6ICdZWVlZLU1NLUREJywgLy8gPGlucHV0IHR5cGU9XCJkYXRlXCIgLz5cbiAgICAgICAgVElNRTogJ0hIOm1tJywgLy8gPGlucHV0IHR5cGU9XCJ0aW1lXCIgLz5cbiAgICAgICAgVElNRV9TRUNPTkRTOiAnSEg6bW06c3MnLCAvLyA8aW5wdXQgdHlwZT1cInRpbWVcIiBzdGVwPVwiMVwiIC8+XG4gICAgICAgIFRJTUVfTVM6ICdISDptbTpzcy5TU1MnLCAvLyA8aW5wdXQgdHlwZT1cInRpbWVcIiBzdGVwPVwiMC4wMDFcIiAvPlxuICAgICAgICBXRUVLOiAnR0dHRy1bV11XVycsIC8vIDxpbnB1dCB0eXBlPVwid2Vla1wiIC8+XG4gICAgICAgIE1PTlRIOiAnWVlZWS1NTScsIC8vIDxpbnB1dCB0eXBlPVwibW9udGhcIiAvPlxuICAgIH07XG5cbiAgICByZXR1cm4gaG9va3M7XG5cbn0pKSk7XG4iLCAiaW1wb3J0IHsgVXBkYXRlTm90ZVR5cGVNb2RhbCB9IGZyb20gJ3VwZGF0ZU5vdGVUeXBlTW9kYWwnO1xuaW1wb3J0IHsgQXBwLCBFZGl0b3IsIE1hcmtkb3duVmlldywgTm90aWNlLCBQbHVnaW4sIFBsdWdpblNldHRpbmdUYWIsIFNldHRpbmcsIFRGaWxlLCBWYXVsdCwgRWRpdG9yU2VsZWN0aW9uLCBXb3Jrc3BhY2UgfSBmcm9tICdvYnNpZGlhbic7XG5pbXBvcnQgeyBBZGRGb290bm90ZVRhZ01vZGFsIH0gZnJvbSAnYWRkQ29tbWVudFRhZ01vZGFsJztcbmltcG9ydCB7IEFkZFRhc2tUYWdNb2RhbCB9IGZyb20gJ2FkZFRhc2tUYWdNb2RhbCc7XG5pbXBvcnQgeyByZW5hbWVCbG9nVGl0bGUsIHJlbmFtZVRhZyB9IGZyb20gJ3RhZ3JlbmFtZXIvcmVuYW1pbmcnO1xuaW1wb3J0IHsgVGhyZWFkc1RvSW1hZ2VzTW9kYWwgfSBmcm9tICdUaHJlYWRzVG9JbWFnZXNNb2RhbCc7XG5pbXBvcnQgeyBDb3B5T3JNb3ZlVG9OZXdOb3RlTW9kYWwgfSBmcm9tICdjb3B5T3JNb3ZlVG9OZXdOb3RlTW9kYWwnO1xuaW1wb3J0IHsgQ2xpcGJvYXJkUGFzdGVNb2RhbCB9IGZyb20gJ2NsaXBib2FyZFBhc3RlTW9kYWwnO1xuaW1wb3J0IHsgT3BlblBsYXlncm91bmRNb2RhbCB9IGZyb20gJ29wZW5QbGF5Z3JvdW5kTW9kYWwnO1xuaW1wb3J0IHsgVGhyZWFkc1RvQmxvZ01vZGFsIH0gZnJvbSAndGhyZWFkc1RvQmxvZ01vZGFsJztcbmltcG9ydCB7IENsaXBib2FyZFJlbW92YWxNb2RhbCB9IGZyb20gJ2NsaXBib2FyZFJlbW92YWxNb2RhbCc7XG5pbXBvcnQgeyBUYWdTZWFyY2hNb2RhbCB9IGZyb20gJ3RhZ1NlYXJjaE1vZGFsJztcbmltcG9ydCB7IGFkZEljb24gfSBmcm9tICdvYnNpZGlhbic7XG5pbXBvcnQgbW9tZW50IGZyb20gJ21vbWVudCc7XG5pbXBvcnQgeyBBZGRUZXh0VG9Ob3Rlc01vZGFsIH0gZnJvbSAnYWRkVGV4dFRvTm90ZXNNb2RhbCc7XG5pbXBvcnQgeyBOYXZpZ2F0ZVRvTm90ZUZyb21UYWdNb2RhbCB9IGZyb20gJ25hdmlnYXRlVG9Ob3RlRnJvbVRhZ01vZGFsJztcbmltcG9ydCB7IFNlbGVjdGlvblJhbmdlLCBleHBvcnRDdXJyZW50U2VsZWN0aW9uLCBnZXRDdXJyZW50U2VsZWN0aW9uTGluZU51bWJlciB9IGZyb20gJ3NlbGZ1dGlsL2V4dHJhY3RTZWxlY3Rpb24nO1xuaW1wb3J0IHsgZ2V0UGFyZW50TGluZSwgcmVwbGFjZVRXVXNlbGVzc1ZhbHVlLCBzaG91bGRTa2lwRnJvbnRNYXR0ZXIsIHRpZHlVcEZyb250TWF0dGVyT25WYWx1ZSwgdGlkeVVwRnJvbnRNYXR0ZXJvbkVkaXRvciB9IGZyb20gJ3R3bWlncmF0aW9uL3R3TWlncmF0ZVRvb2xzJztcbmltcG9ydCB7IHJlbW92ZUNvbnRlbnRGcm9tQ3Vyc29yVG9FbmRPZk5vdGUsIHJlbW92ZUNvbnRlbnRGcm9tU3RhcnRPZk5vdGVUb0N1cnNvciwgcmVtb3ZlQ29udGVudExlZnRTYW1lTGluZSB9IGZyb20gJ3NlbGZ1dGlsL3JlbW92ZUNvbnRlbnRGcm9tQ3Vyc29yJztcbmltcG9ydCB7IFJlbW92ZUNvbnRlbnRGcm9tQ3Vyc29yTW9kYWwgfSBmcm9tICdyZW1vdmVDb250ZW50RnJvbUN1cnNvck1vZGFsJztcbmltcG9ydCB7IEZpbmRSZXBsYWNlTW9kYWwgfSBmcm9tICdmaW5kUmVwbGFjZU1vZGFsJztcbmltcG9ydCB7IFF1ZXJ5T3JwaGFuTm90ZXNCeVRhZ01vZGFsIH0gZnJvbSAncXVlcnlPcnBoYW5Ob3Rlc0J5VGFnTW9kYWwnO1xuXG4vLyBSZW1lbWJlciB0byByZW5hbWUgdGhlc2UgY2xhc3NlcyBhbmQgaW50ZXJmYWNlcyFcblxuaW50ZXJmYWNlIE15UGx1Z2luU2V0dGluZ3Mge1xuXHRteVNldHRpbmc6IHN0cmluZztcbn1cblxuY29uc3QgREVGQVVMVF9TRVRUSU5HUzogTXlQbHVnaW5TZXR0aW5ncyA9IHtcblx0bXlTZXR0aW5nOiAnZGVmYXVsdCdcbn1cblxuY29uc3QgY2xpcGJvYXJkSGlzdG9yeTogc3RyaW5nW10gPSBbXVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNeVBsdWdpbiBleHRlbmRzIFBsdWdpbiB7XG5cdHNldHRpbmdzOiBNeVBsdWdpblNldHRpbmdzO1xuXHR2aWV3OiBNYXJrZG93blZpZXc7XG5cblx0YXN5bmMgb25sb2FkKCkge1xuXHRcdGF3YWl0IHRoaXMubG9hZFNldHRpbmdzKCk7XG5cblx0XHQvKlxuXHRcdC8vZnVuY3Rpb24gZGlzcGxheU5vdGVJbkxlZnRWaWV3KGFwcDogQXBwLCBub3RlUGF0aDogc3RyaW5nKSB7XG5cdFx0XHRjb25zb2xlLmxvZyhcIj09PTFcIilcblx0XHRcdC8vY29uc3QgdmlldyA9IG5ldyBNYXJrZG93blZpZXcodGhpcy5hcHAud29ya3NwYWNlLmdldExlYWYoKSk7XG5cdFx0XHQvL2NvbnNvbGUubG9nKFwiPT09MlwiKVxuXHRcdFx0Ly92aWV3LnNldEVwaGVtZXJhbFN0YXRlKHsgcGF0aDogXCJJL0luYm94Lm1kXCIgfSk7XG5cdFx0XHQvL2NvbnNvbGUubG9nKFwiPT09M1wiKVxuXHRcdFx0Ly9hcHAud29ya3NwYWNlLmdldExlYWYoKS5zZXRWaWV3U3RhdGUoeyB0eXBlOiBcIm1hcmtkb3duXCIsIHN0YXRlOiB2aWV3LmdldFN0YXRlKCkgfSk7XG5cdFx0XHQvL2NvbnNvbGUubG9nKFwiPT09NFwiKVxuXG5cdFx0XHRcblx0XHRcdHRoaXMucmVnaXN0ZXJWaWV3KFxuXHRcdFx0XHRcImluYm94XCIsXG5cdFx0XHRcdChsZWFmKSA9PiB7XG5cdFx0XHRcdFx0dGhpcy52aWV3ID0gbmV3IE1hcmtkb3duVmlldyhsZWFmKVxuXHRcdFx0XHRcdHRoaXMudmlldy5zZXRFcGhlbWVyYWxTdGF0ZSh7IHBhdGg6IFwiSS9JbmJveC5tZFwiIH0pO1xuXHRcdFx0XHRcdGNvbnN0IHN0YXRlID0gdGhpcy52aWV3LmdldFN0YXRlKClcblx0XHRcdFx0XHRzdGF0ZS5waW5uZWQgPSB0cnVlXG5cdFx0XHRcdFx0bGVhZi5zZXRWaWV3U3RhdGUoeyB0eXBlOiBcIm1hcmtkb3duXCIsIHN0YXRlOiBzdGF0ZSB9KTtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcy52aWV3XG5cdFx0XHRcdH0sXG5cdFx0XHQgICk7XG5cdFx0ICAvL31cblxuXHRcdCAgY29uc29sZS5sb2coXCI9PT0yXCIpXG5cblx0XHQgIHRoaXMuYWRkQ29tbWFuZCh7XG5cdFx0XHRpZDogJ3JlY2VudC1maWxlcy1vcGVuJyxcblx0XHRcdG5hbWU6ICdPcGVuIFhYWCcsXG5cdFx0XHRjYWxsYmFjazogYXN5bmMgKCkgPT4ge1xuXHRcdFx0ICBsZXQgW2xlYWZdID0gdGhpcy5hcHAud29ya3NwYWNlLmdldExlYXZlc09mVHlwZShcblx0XHRcdFx0XCJpbmJveFwiLFxuXHRcdFx0ICApO1xuXHRcdFx0ICBpZiAoIWxlYWYpIHtcblx0XHRcdFx0bGVhZiA9IHRoaXMuYXBwLndvcmtzcGFjZS5nZXRMZWZ0TGVhZihmYWxzZSk7XG5cdFx0XHRcdGF3YWl0IGxlYWYuc2V0Vmlld1N0YXRlKHsgdHlwZTogXCJpbmJveFwiIH0pO1xuXHRcdFx0ICB9XG5cdCAgXG5cdFx0XHQgIHRoaXMuYXBwLndvcmtzcGFjZS5yZXZlYWxMZWFmKGxlYWYpO1xuXHRcdFx0fSxcblx0XHQgIH0pO1xuXG5cdFx0ICBjb25zb2xlLmxvZyhcIj09PTNcIilcblx0XHQgICovXG5cdFx0ICBcblxuXHRcdGlmIChuYXZpZ2F0b3IuY2xpcGJvYXJkKSB7XG5cdFx0XHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdjb3B5JywgKGV2ZW50OiBDbGlwYm9hcmRFdmVudCkgPT4ge1xuXHRcdFx0XHRjb25zdCBjb3BpZWRUZXh0ID0gZXZlbnQuY2xpcGJvYXJkRGF0YT8uZ2V0RGF0YSgndGV4dC9wbGFpbicpO1xuXHRcdFx0XHRpZiAoY29waWVkVGV4dCAhPSBudWxsKSB7XG5cdFx0XHRcdFx0dGhpcy5hZGRUb0NsaXBib2FyZEhpc3RvcnkoY29waWVkVGV4dClcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0XHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdjdXQnLCAoZXZlbnQ6IENsaXBib2FyZEV2ZW50KSA9PiB7XG5cdFx0XHRcdGNvbnN0IGNvcGllZFRleHQgPSBldmVudC5jbGlwYm9hcmREYXRhPy5nZXREYXRhKCd0ZXh0L3BsYWluJyk7XG5cdFx0XHRcdGlmIChjb3BpZWRUZXh0ICE9IG51bGwpIHtcblx0XHRcdFx0XHR0aGlzLmFkZFRvQ2xpcGJvYXJkSGlzdG9yeShjb3BpZWRUZXh0KVxuXHRcdFx0XHR9XG5cdFx0XHQgIH0pO1xuXHRcdCAgfSBlbHNlIHtcblx0XHRcdGNvbnNvbGUubG9nKCdDbGlwYm9hcmQgQVBJIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBicm93c2VyLicpO1xuXHRcdCAgfVxuXG5cdFx0WyduJywgJ2wnLCAndycsICdkJywgJ2EnLCAnMScsICcyJywgJzMnLCAnNCcsICc1JywgJzYnLCAnNyddLmZvckVhY2godCA9PiB7XG5cdFx0XHR0aGlzLmFkZEFjdGlvbkljb24odCk7XG5cdFx0XHR0aGlzLmFkZEFjdGlvbkNvbW1hbmQodCk7XG5cdFx0fSk7XG5cblx0XHRbJ3QnLCAnbScsICdlJ10uZm9yRWFjaCh0ID0+IHtcblx0XHRcdHRoaXMuYWRkQWN0aW9uSWNvbih0KTtcblx0XHRcdHRoaXMuYWRkRm9sbG93VXBDb21tYW5kKHQpO1xuXHRcdH0pO1xuXG5cdFx0WyduJywgJ3cnXS5mb3JFYWNoKHQgPT4ge1xuXHRcdFx0dGhpcy5hZGROZXdMYXRlckFjdGlvbkljb24odCk7XG5cdFx0XHR0aGlzLmFkZE5ld0xhdGVyQWN0aW9uKHQpO1xuXHRcdH0pO1xuXG5cdFx0dGhpcy5hZGRDb21tYW5kKHtcblx0XHRcdGlkOiBcIm9ic2lkaWFuLXJlbW92ZS1jbGlwYm9hcmQtY29udGVudFwiLFxuXHRcdFx0bmFtZTogXCJSQyBPYnNpZGlhbiBSZW1vdmUgQ2xpcGJvYXJkIENvbnRlbnRcIixcblx0XHRcdGljb246IFwib2JzaWRpYW4tcmVtb3ZlLWNsaXBib2FyZC1jb250ZW50XCIsXG5cdFx0XHRlZGl0b3JDYWxsYmFjazogKGVkaXRvcjogRWRpdG9yLCB2aWV3OiBNYXJrZG93blZpZXcpID0+IHtcblx0XHRcdFx0bmV3IENsaXBib2FyZFJlbW92YWxNb2RhbCh0aGlzLmFwcCwgZWRpdG9yLCBjbGlwYm9hcmRIaXN0b3J5KS5vcGVuKCk7XHRcdFxuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0Lypcblx0XHR0aGlzLmFkZE9ic2lkaWFuSWNvbignb2JzaWRpYW4tY29weScsICdcdTIzMThDJyk7XG5cdFx0dGhpcy5hZGRDb21tYW5kKHtcblx0XHRcdGlkOiBcIm9ic2lkaWFuLWNvcHlcIixcblx0XHRcdG5hbWU6IFwiT2JzaWRpYW4gQ29weVwiLFxuXHRcdFx0aWNvbjogXCJvYnNpZGlhbi1jb3B5XCIsXG5cdFx0XHRlZGl0b3JDYWxsYmFjazogKGVkaXRvcjogRWRpdG9yLCB2aWV3OiBNYXJrZG93blZpZXcpID0+IHtcblx0XHRcdFx0bGV0IGNvbnRlbnQgPSBlZGl0b3IuZ2V0U2VsZWN0aW9uKCkudG9TdHJpbmcoKVxuXHRcdFx0XHRpZiAoY29udGVudC5sZW5ndGggPT0gMCkge1xuXHRcdFx0XHRcdGNvbnRlbnQgPSBlZGl0b3IuZ2V0TGluZShlZGl0b3IuZ2V0Q3Vyc29yKCkubGluZSlcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLmFkZFRvQ2xpcGJvYXJkSGlzdG9yeShjb250ZW50KTtcblx0XHRcdFx0bmV3IE5vdGljZShcImBgYFxcblwiICsgY29udGVudCArIFwiXFxuYGBgXFxuaXMgY29waWVkIHRvIGNsaXBib2FyZCFcIilcblx0XHRcdH0sXG5cdFx0XHRob3RrZXlzOiBbXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRtb2RpZmllcnM6IFtgTWV0YWAsIGBTaGlmdGBdLFxuXHRcdFx0XHRcdGtleTogYGNgLFxuXHRcdFx0XHR9XG5cdFx0XHRdXG5cdFx0fSk7XG5cdFx0Ki9cblxuXHRcdC8qXG5cdFx0dGhpcy5hZGRPYnNpZGlhbkljb24oJ29ic2lkaWFuLWN1dCcsICdcdTIzMThYJyk7XG5cdFx0dGhpcy5hZGRDb21tYW5kKHtcblx0XHRcdGlkOiBcIm9ic2lkaWFuLWN1dFwiLFxuXHRcdFx0bmFtZTogXCJPYnNpZGlhbiBDdXRcIixcblx0XHRcdGljb246IFwib2JzaWRpYW4tY3V0XCIsXG5cdFx0XHRlZGl0b3JDYWxsYmFjazogKGVkaXRvcjogRWRpdG9yLCB2aWV3OiBNYXJrZG93blZpZXcpID0+IHtcblx0XHRcdFx0bGV0IGNvbnRlbnQgPSBlZGl0b3IuZ2V0U2VsZWN0aW9uKCkudG9TdHJpbmcoKVxuXHRcdFx0XHRpZiAoY29udGVudC5sZW5ndGggPT0gMCkge1xuXHRcdFx0XHRcdGNvbnRlbnQgPSBlZGl0b3IuZ2V0TGluZShlZGl0b3IuZ2V0Q3Vyc29yKCkubGluZSlcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLmFkZFRvQ2xpcGJvYXJkSGlzdG9yeShjb250ZW50KTtcblx0XHRcdFx0ZWRpdG9yLnJlcGxhY2VTZWxlY3Rpb24oXCJcIilcblx0XHRcdFx0bmV3IE5vdGljZShcImBgYFxcblwiICsgY29udGVudCArIFwiXFxuYGBgXFxuaXMgY3V0IHRvIGNsaXBib2FyZCFcIilcblx0XHRcdH0sXG5cdFx0XHRob3RrZXlzOiBbXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRtb2RpZmllcnM6IFtgTWV0YWAsIGBTaGlmdGBdLFxuXHRcdFx0XHRcdGtleTogYHhgLFxuXHRcdFx0XHR9XG5cdFx0XHRdXG5cdFx0fSk7XG5cdCovXG5cblx0dGhpcy5hZGRPYnNpZGlhbkljb24oJ2F1dG8tY29ycmVjdCcsICdBQycpO1xuXHR0aGlzLmFkZENvbW1hbmQoe1xuXHRcdGlkOiBcImF1dG8tY29ycmVjdFwiLFxuXHRcdG5hbWU6IFwiQXV0byBDb3JyZWN0IEFDXCIsXG5cdFx0aWNvbjogXCJhdXRvLWNvcnJlY3RcIixcblx0XHRlZGl0b3JDYWxsYmFjazogKGVkaXRvcjogRWRpdG9yLCB2aWV3OiBNYXJrZG93blZpZXcpID0+IHtcblx0XHRcdGNvbnN0IHZhbHVlID0gZWRpdG9yLmdldFZhbHVlKClcblx0XHRcdGxldCBtb2RpZmllZFZhbHVlID0gdmFsdWVcblx0XHRcdC5yZXBsYWNlKC8xMFx1NTIwNi9nLCBcIlx1NTM0MVx1NTIwNlwiKVxuXHRcdFx0LnJlcGxhY2UoL1x1ODhDRi9nLCBcIlx1ODhFMVwiKVxuXHRcdFx0LnJlcGxhY2UoL1x1NTkyN1x1NEY2Qy9nLCBcIlx1NTkyN1x1ODE2NlwiKVxuXG5cdFx0XHQvLyB0aGVuIGFkZCBzcGFjZXMgYmV0d2VlbiBlbmdsaXNoIGFuZCBjaGluZXNlIGlmIG5vIHNwYWNlXG5cdFx0XHRtb2RpZmllZFZhbHVlID0gbW9kaWZpZWRWYWx1ZVxuXHRcdFx0LnJlcGxhY2UoLyhbYS16QS1aMC05XSkoW1xcdTRFMDAtXFx1OUZGRl0pL2csIFwiJDEgJDJcIilcblx0XHRcdC5yZXBsYWNlKC8oW1xcdTRFMDAtXFx1OUZGRl0pKFthLXpBLVowLTldKS9nLCBcIiQxICQyXCIpXG5cdFx0XHRlZGl0b3Iuc2V0VmFsdWUobW9kaWZpZWRWYWx1ZSlcblx0XHR9XG5cdH0pO1xuXG5cdHRoaXMuYWRkT2JzaWRpYW5JY29uKCdmaW5kLWJyb2tlbi1saW5rJywgJ0JMJyk7XG5cdHRoaXMuYWRkQ29tbWFuZCh7XG5cdFx0aWQ6IFwiZmluZC1icm9rZW4tbGlua1wiLFxuXHRcdG5hbWU6IFwiRmluZCBCcm9rZW4gTGluayBCTFwiLFxuXHRcdGljb246IFwiZmluZC1icm9rZW4tbGlua1wiLFxuXHRcdGVkaXRvckNhbGxiYWNrOiAoZWRpdG9yOiBFZGl0b3IsIHZpZXc6IE1hcmtkb3duVmlldykgPT4ge1xuXHRcdFx0aWYgKHZpZXcuZmlsZS5wYXRoICE9PSBcIkkvQnJva2VuIExpbmsubWRcIikge1xuXHRcdFx0XHRcblx0XHRcdFx0Y29uc3QgY3Vyc29yID0gZWRpdG9yLmdldEN1cnNvcigpXG5cdFx0XHRcdGNvbnN0IGxpbmUgPSBjdXJzb3IubGluZVxuXHRcdFx0XHRjb25zdCBsaW5lQ29udGVudCA9IGVkaXRvci5nZXRMaW5lKGxpbmUpXG5cblx0XHRcdFx0Ly8gaWYgbGluZSBjb250ZW50IGhhcyBbWyBhbmQgXV0gIGFuZCA6ID8gLyA8ID4gaW4gYmV0d2VlbiwgcmVwbGFjZSB0aGVtIHRvIF9cblx0XHRcdFx0aWYgKC9cXFtcXFsuKls6P1xcL1xcXFw8Pl0uKlxcXVxcXS8udGVzdChsaW5lQ29udGVudCkpIHtcblx0XHRcdFx0XHRuZXcgTm90aWNlKFwiVHJ5aW5nIHRvIGZpeCBicm9rZW4gbGluZSBpbiBjdXJyZW50IGxpbmU6IFwiICsgbGluZUNvbnRlbnQpXG5cdFx0XHRcdFx0Ly8gcmVwbGFjZSBhbGwgOiB0byBfIGFuZCByZXBsYWNlIGFsbCA/IHRvIF8gYW5kIHJlcGxhY2UgYWxsIC8gdG8gXyBhbmQgcmVwbGFjZSBhbGwgLiB0byBfXG5cdFx0XHRcdFx0ZWRpdG9yLnNldExpbmUobGluZSwgbGluZUNvbnRlbnQucmVwbGFjZSgvOi9nLCBcIl9cIikucmVwbGFjZSgvXFw/L2csIFwiX1wiKS5yZXBsYWNlKC9cXC8vZywgXCJfXCIpLnJlcGxhY2UoL1xcXFwvZywgXCJfXCIpLnJlcGxhY2UoLzwvZywgXCJfXCIpLnJlcGxhY2UoLz4vZywgXCJfXCIpXG5cdFx0XHRcdFx0LnJlcGxhY2UoL14ocGFyZW50XFxkKylfIC8sIFwiJDE6IFwiKVxuXHRcdFx0XHRcdC5yZXBsYWNlKC9eKHRpdGxlXFxkKylfIC8sIFwiJDE6IFwiKVxuXHRcdFx0XHRcdClcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyBmaW5kIG5leHQgYnJva2VuIGxpbmtcblx0XHRcdFx0XHRjb25zdCB1bnJlc29sdmVkTGlua3M6IFJlY29yZDxzdHJpbmcsIFJlY29yZDxzdHJpbmcsIG51bWJlcj4+ID0gdGhpcy5hcHAubWV0YWRhdGFDYWNoZS51bnJlc29sdmVkTGlua3M7XG5cdFx0XHRcdFx0Y29uc3QgYnJva2VuTGlua1JlY29yZDogUmVjb3JkPHN0cmluZywgbnVtYmVyPiA9IHVucmVzb2x2ZWRMaW5rc1t2aWV3LmZpbGUucGF0aF1cblx0XHRcdFx0XHRpZiAoYnJva2VuTGlua1JlY29yZCA9PSBudWxsKSB7XG5cdFx0XHRcdFx0XHRuZXcgTm90aWNlKFwiTm8gYnJva2VuIGxpbmsgZm91bmQgaW4gdGhpcyBmaWxlXCIpXHRcblx0XHRcdFx0XHRcdHJldHVyblxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjb25zdCBicm9rZW5MaW5rcyA9IE9iamVjdC5rZXlzKGJyb2tlbkxpbmtSZWNvcmQpXG5cdFx0XHRcdFx0aWYgKGJyb2tlbkxpbmtzID09IG51bGwgfHwgYnJva2VuTGlua3MubGVuZ3RoID09IDApIHtcblx0XHRcdFx0XHRcdG5ldyBOb3RpY2UoXCJObyBicm9rZW4gbGluayBmb3VuZCBpbiB0aGlzIGZpbGVcIilcdFxuXHRcdFx0XHRcdFx0cmV0dXJuXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGZvciAobGV0IGkgPSBsaW5lICsgMTsgaSA8IGVkaXRvci5saW5lQ291bnQoKTsgaSsrKSB7XG5cdFx0XHRcdFx0XHRjb25zdCBsaW5lQ29udGVudCA9IGVkaXRvci5nZXRMaW5lKGkpXG5cdFx0XHRcdFx0XHRmb3IgKGxldCBiID0gMDsgYiA8IGJyb2tlbkxpbmtzLmxlbmd0aDsgYisrKSB7XG5cdFx0XHRcdFx0XHRcdGNvbnN0IGJyb2tlbkxpbmsgPSBicm9rZW5MaW5rc1tiXVxuXHRcdFx0XHRcdFx0XHRpZiAobGluZUNvbnRlbnQuY29udGFpbnMoXCJbW1wiICsgYnJva2VuTGluayArIFwiXV1cIikpIHtcblx0XHRcdFx0XHRcdFx0XHRlZGl0b3Iuc2V0Q3Vyc29yKHtsaW5lOiBpLCBjaDogMH0pXG5cdFx0XHRcdFx0XHRcdFx0ZWRpdG9yLnNjcm9sbEludG9WaWV3KHtmcm9tOiB7bGluZTogaSwgY2g6IDB9LCB0bzoge2xpbmU6IGksIGNoOiAwfX0sIHRydWUpXG5cdFx0XHRcdFx0XHRcdFx0bmV3IE5vdGljZShcIk5hdmlnYXRlZCB0byBuZXh0IEJyb2tlbiBsaW5rIHN0YXJ0aW5nIGZyb20gY3Vyc29yXCIpXG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0bmV3IE5vdGljZShcIk5vIGJyb2tlbiBsaW5rIGZvdW5kIGFmdGVyIGN1cnNvciBsaW5lIGluIHRoaXMgZmlsZVwiKVx0XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuXG5cdFx0XHR9XG5cdFx0XHRsZXQgY291bnQgPSAwXG5cdFx0XHRsZXQgcmVzdWx0ID0gXCJcIlxuXHRcdFx0Y29uc3QgdW5yZXNvbHZlZExpbmtzOiBSZWNvcmQ8c3RyaW5nLCBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+PiA9IHRoaXMuYXBwLm1ldGFkYXRhQ2FjaGUudW5yZXNvbHZlZExpbmtzO1x0XG5cdFx0XHQvLyB0aGVuIGxvb3AgdGhlIHJlY29yZCBkYXRhIGluIGNvbnNvbGVcblx0XHRcdGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHVucmVzb2x2ZWRMaW5rcykpIHtcblx0XHRcdFx0bGV0IHYgPSAnJ1xuXHRcdFx0XHRmb3IgKGNvbnN0IFtrMSwgdjFdIG9mIE9iamVjdC5lbnRyaWVzKHZhbHVlKSkge1xuXHRcdFx0XHRcdHYgKz0gazEgKyBcIjpcIiArIHYxICsgXCIsIFwiXG5cdFx0XHRcdH1cblx0XHRcdFx0diA9IHYucmVwbGFjZSgvLCAkLywgXCJcIilcblx0XHRcdFx0aWYgKHYgIT09IFwiXCIpIHtcblx0XHRcdFx0XHRjb25zb2xlLmxvZyhrZXkgKyAnIC0+IFsnICsgdiArICddJylcblx0XHRcdFx0XHRyZXN1bHQgKz0gXCItIFtbXCIgKyBrZXkucmVwbGFjZSgvXFwubWQkLyxcIlwiKSArICddXScvLyA6IFsnICsgdiArICddJ1xuXHRcdFx0XHRcdHJlc3VsdCArPSBcIlxcblwiXG5cdFx0XHRcdFx0Zm9yIChjb25zdCBbazIsIHYyXSBvZiBPYmplY3QuZW50cmllcyh2YWx1ZSkpIHtcblx0XHRcdFx0XHRcdHJlc3VsdCArPSBcIlxcdC0gXCIgKyBrMi5yZXBsYWNlKC9cXC5tZCQvLFwiXCIpICsgJydcblx0XHRcdFx0XHRcdHJlc3VsdCArPSBcIlxcblwiXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGNvdW50Kytcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0ZWRpdG9yLnNldFZhbHVlKHJlc3VsdClcblx0XHRcdG5ldyBOb3RpY2UoXCJVcGRhdGVkIGJyb2tlbiBsaW5rLiBjb3VudD1cIiArIGNvdW50KVxuXHRcdFx0Lypcblx0XHRcdG5hdmlnYXRvci5jbGlwYm9hcmQud3JpdGVUZXh0KHJlc3VsdCkudGhlbigoKSA9PiB7XG5cdFx0XHRcdG5ldyBOb3RpY2UoXCJjb3VudD1cIiArIGNvdW50KVxuXHRcdFx0XHRuZXcgTm90aWNlKFwiY29waWVkIHJlc3VsdCB0byBjbGlwYm9hcmQhXCIpXG5cdFx0XHR9KVxuXHRcdFx0Ki9cblx0XHR9LFxuXHRcdGhvdGtleXM6IFtcblx0XHRcdHtcblx0XHRcdFx0bW9kaWZpZXJzOiBbYEN0cmxgLCBgTWV0YWAsIGBTaGlmdGBdLFxuXHRcdFx0XHRrZXk6IGA1YCxcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdG1vZGlmaWVyczogW2BDdHJsYCwgYEFsdGAsIGBTaGlmdGBdLFxuXHRcdFx0XHRrZXk6IGA1YCxcblx0XHRcdH0sXG5cdFx0XVxuXHR9KTtcblxuXHRcdFx0dGhpcy5hZGRDb21tYW5kKHtcblx0XHRcdGlkOiBcIm9wZW4tdGFnLXNlYXJjaFwiLFxuXHRcdFx0bmFtZTogXCJPcGVuIHRhZyBzZWFyY2hcIixcblx0XHRcdGljb246IFwiaGFzaFwiLFxuXHRcdFx0Y2FsbGJhY2s6ICgpID0+IHtcblx0XHRcdFx0LyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSAqL1xuXHRcdFx0XHRjb25zdCBzZWFyY2hQbHVnaW4gPSAoXG5cdFx0XHRcdFx0dGhpcy5hcHAgYXMgYW55XG5cdFx0XHRcdCkuaW50ZXJuYWxQbHVnaW5zLmdldFBsdWdpbkJ5SWQoXCJnbG9iYWwtc2VhcmNoXCIpO1xuXHRcdFx0XHQvKiBlc2xpbnQtZW5hYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnkgKi9cblx0XHRcdFx0Y29uc3Qgc2VhcmNoID0gc2VhcmNoUGx1Z2luICYmIHNlYXJjaFBsdWdpbi5pbnN0YW5jZTtcblxuXHRcdFx0XHRpZiAoc2VhcmNoUGx1Z2luICYmIHNlYXJjaFBsdWdpbi5pbnN0YW5jZSkge1xuXHRcdFx0XHRcdG5ldyBUYWdTZWFyY2hNb2RhbCh0aGlzLmFwcCwgc2VhcmNoKS5vcGVuKCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0bmV3IE5vdGljZShcIlBsZWFzZSBlbmFibGUgdGhlIHNlYXJjaCBjb3JlIHBsdWdpbiFcIik7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRob3RrZXlzOiBbXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRtb2RpZmllcnM6IFtgQ3RybGAsIGBNZXRhYCwgYFNoaWZ0YF0sXG5cdFx0XHRcdFx0a2V5OiBgc2AsXG5cdFx0XHRcdH0sXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRtb2RpZmllcnM6IFtgQ3RybGAsIGBBbHRgLCBgU2hpZnRgXSxcblx0XHRcdFx0XHRrZXk6IGBzYCxcblx0XHRcdFx0fSxcblx0XHRcdF1cblx0XHR9KTtcblxuXHRcdHRoaXMuYWRkQ29tbWFuZCh7XG5cdFx0XHRpZDogXCJvcGVuLXRhZy1zZWFyY2hcIixcblx0XHRcdG5hbWU6IFwiT3BlbiB0YWcgc2VhcmNoXCIsXG5cdFx0XHRpY29uOiBcImhhc2hcIixcblx0XHRcdGNhbGxiYWNrOiAoKSA9PiB7XG5cdFx0XHRcdC8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnkgKi9cblx0XHRcdFx0Y29uc3Qgc2VhcmNoUGx1Z2luID0gKFxuXHRcdFx0XHRcdHRoaXMuYXBwIGFzIGFueVxuXHRcdFx0XHQpLmludGVybmFsUGx1Z2lucy5nZXRQbHVnaW5CeUlkKFwiZ2xvYmFsLXNlYXJjaFwiKTtcblx0XHRcdFx0LyogZXNsaW50LWVuYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55ICovXG5cdFx0XHRcdGNvbnN0IHNlYXJjaCA9IHNlYXJjaFBsdWdpbiAmJiBzZWFyY2hQbHVnaW4uaW5zdGFuY2U7XG5cblx0XHRcdFx0aWYgKHNlYXJjaFBsdWdpbiAmJiBzZWFyY2hQbHVnaW4uaW5zdGFuY2UpIHtcblx0XHRcdFx0XHRuZXcgVGFnU2VhcmNoTW9kYWwodGhpcy5hcHAsIHNlYXJjaCkub3BlbigpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdG5ldyBOb3RpY2UoXCJQbGVhc2UgZW5hYmxlIHRoZSBzZWFyY2ggY29yZSBwbHVnaW4hXCIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0aG90a2V5czogW1xuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bW9kaWZpZXJzOiBbYEN0cmxgLCBgTWV0YWAsIGBTaGlmdGBdLFxuXHRcdFx0XHRcdGtleTogYHNgLFxuXHRcdFx0XHR9LFxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bW9kaWZpZXJzOiBbYEN0cmxgLCBgQWx0YCwgYFNoaWZ0YF0sXG5cdFx0XHRcdFx0a2V5OiBgc2AsXG5cdFx0XHRcdH0sXG5cdFx0XHRdXG5cdFx0fSk7XG5cblx0XHRcblx0XHR0aGlzLmFkZENvbW1hbmQoe1xuXHRcdFx0aWQ6IFwic2VsZi1xdWVyeVwiLFxuXHRcdFx0bmFtZTogXCJTZWxmIFF1ZXJ5XCIsXG5cdFx0XHRlZGl0b3JDYWxsYmFjazogKGVkaXRvcjogRWRpdG9yLCB2aWV3OiBNYXJrZG93blZpZXcpID0+IHtcblx0XHRcdFx0bmV3IFF1ZXJ5T3JwaGFuTm90ZXNCeVRhZ01vZGFsKHRoaXMuYXBwLCBlZGl0b3IsIHZpZXcpLm9wZW4oKVxuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0dGhpcy5hZGRPYnNpZGlhbkljb24oJ29ic2lkaWFuLXBhc3RlJywgJ1x1MjMxOFYnKTtcblx0XHR0aGlzLmFkZENvbW1hbmQoe1xuXHRcdFx0aWQ6IFwib2JzaWRpYW4tcGFzdGVcIixcblx0XHRcdG5hbWU6IFwiT2JzaWRpYW4gUGFzdGVcIixcblx0XHRcdGljb246IFwib2JzaWRpYW4tcGFzdGVcIixcblx0XHRcdGVkaXRvckNhbGxiYWNrOiAoZWRpdG9yOiBFZGl0b3IsIHZpZXc6IE1hcmtkb3duVmlldykgPT4ge1xuXHRcdFx0XHRuZXcgQ2xpcGJvYXJkUGFzdGVNb2RhbCh0aGlzLmFwcCwgZWRpdG9yLCBjbGlwYm9hcmRIaXN0b3J5KS5vcGVuKCk7XHRcdFxuXHRcdFx0fSxcblx0XHRcdGhvdGtleXM6IFtcblx0XHRcdFx0e1xuXHRcdFx0XHRcdG1vZGlmaWVyczogW2BNZXRhYCwgYFNoaWZ0YF0sXG5cdFx0XHRcdFx0a2V5OiBgdmAsXG5cdFx0XHRcdH1cblx0XHRcdF1cblx0XHR9KTtcblxuXHRcdHRoaXMuYWRkT2JzaWRpYW5JY29uKCd1cGRhdGUtbm90ZS10eXBlLWljb24nLCAnTlQnKTtcblx0XHR0aGlzLmFkZENvbW1hbmQoe1xuXHRcdFx0aWQ6IFwidXBkYXRlLW5vdGUtdHlwZVwiLFxuXHRcdFx0bmFtZTogXCJVcGRhdGUgTm90ZSBUeXBlXCIsXG5cdFx0XHRpY29uOiBgdXBkYXRlLW5vdGUtdHlwZS1pY29uYCxcblx0XHRcdGVkaXRvckNhbGxiYWNrOiAoZWRpdG9yOiBFZGl0b3IsIHZpZXc6IE1hcmtkb3duVmlldykgPT4ge1xuXHRcdFx0ICBuZXcgVXBkYXRlTm90ZVR5cGVNb2RhbCh0aGlzLmFwcCwgZWRpdG9yLCB2aWV3LmZpbGUpLm9wZW4oKTtcblx0XHRcdH0sXG5cdFx0XHRob3RrZXlzOiBbXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRtb2RpZmllcnM6IFtgQ3RybGAsIGBNZXRhYCwgYFNoaWZ0YF0sXG5cdFx0XHRcdFx0a2V5OiBgY2AsXG5cdFx0XHRcdH0sXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRtb2RpZmllcnM6IFtgQ3RybGAsIGBBbHRgLCBgU2hpZnRgXSxcblx0XHRcdFx0XHRrZXk6IGBjYCxcblx0XHRcdFx0fSxcblx0XHRcdF1cblx0XHR9KTtcblxuXG5cdFx0Ly8gY29tYmluZWQgdmVyc2lvblxuXHRcdC8vdGhpcy51cGRhdGVTY2hlZHVsaW5nSWNvbigpXG5cdFx0dGhpcy5hZGRDb21tYW5kKHtcblx0XHRcdGlkOiBcIm9wZW4tcmVjZW50LWRheXMtc2NoZWR1bGUtd2l0aC11cGRhdGVkLXNjaGVkdWxlXCIsXG5cdFx0XHRuYW1lOiBcIk9SIE9wZW4gUmVjZW50IERheXMgVXBkYXRlZCBTY2hlZHVsZVwiLFxuXHRcdFx0aWNvbjogXCJvcGVuLXJlY2VudC1kYXktc2NoZWR1bGUtaWNvblwiLFxuXHRcdFx0Y2FsbGJhY2s6IGFzeW5jICgpID0+IHtcblx0XHRcdFx0Ly8gdXBkYXRlIHNjaGVkdWxpbmcgcGFydFxuXHRcdFx0XHRjb25zdCB7IHZhdWx0IH0gPSB0aGlzLmFwcDtcblx0XHRcdFx0Y29uc3Qgc2NoZWR1bGVOb3RlV2l0aG91dE1kID0gXCJEL1NjaGVkdWxpbmdcIlxuXHRcdFx0XHRjb25zdCBzY2hlZHVsZU5vdGUgPSBgJHtzY2hlZHVsZU5vdGVXaXRob3V0TWR9Lm1kYFx0XHRcdFx0XG5cdFx0XHRcdGlmICh2YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgoc2NoZWR1bGVOb3RlKSA9PSBudWxsKSB7XG5cdFx0XHRcdFx0YXdhaXQgdmF1bHQuY3JlYXRlKHNjaGVkdWxlTm90ZSwgXCJcIik7XG5cdFx0XHRcdH1cblx0XHRcdFx0bGV0IG5vdGVDb250ZW50ID0gJydcblx0XHRcdFx0QXJyYXkuZnJvbShBcnJheSg3KS5rZXlzKCkpLmZvckVhY2goaSA9PiBub3RlQ29udGVudCArPSB0aGlzLmdldFF1ZXJ5RGF0ZVN0cmluZyhpLCBzY2hlZHVsZU5vdGVXaXRob3V0TWQpKTtcblx0XHRcdFx0dmF1bHQubW9kaWZ5KHZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aChzY2hlZHVsZU5vdGUpIGFzIFRGaWxlLCBub3RlQ29udGVudCk7XG5cblx0XHRcdFx0dGhpcy5hZGRBY3Rpb25Ob3RlQ29udGVudCh2YXVsdCwgXCJEXCIsIFwiUXVlcnkgVyBub3cgYWN0aW9uc1wiLCBcIldlZWtseSBTY2hlZHVsZSBXXCIsIFwid1wiKVxuXHRcdFx0XHR0aGlzLmFkZEFjdGlvbk5vdGVDb250ZW50KHZhdWx0LCBcIkRcIiwgXCJRdWVyeSBOIG5vdyBhY3Rpb25zXCIsIFwiV2Vla2x5IFNjaGVkdWxlIE5cIiwgXCJuXCIpXG5cdFx0XHRcdHRoaXMuYWRkM0RheXNBY3Rpb25Ob3RlQ29udGVudCh2YXVsdCk7XG5cdFx0XHRcdG5ldyBOb3RpY2UoXCJVcGRhdGVkIHNjaGVkdWxlXCIpO1xuXG5cdFx0XHRcdC8vIG9wZW4gc2NoZWR1bGUgcGFydFxuXHRcdFx0XHRjb25zdCB7IHdvcmtzcGFjZSB9ID0gdGhpcy5hcHA7XG5cdFx0XHRcdGNvbnN0IGRhc2hib2FyZENhbnZhcyA9IFwiRC9RdWVyeSBTY2hlZHVsZSBhbmQgQWN0aW9ucyBuZXh0IDMgZGF5cy5tZFwiXG5cdFx0XHRcdGNvbnN0IG1vZGUgPSAodGhpcy5hcHAudmF1bHQgYXMgYW55KS5nZXRDb25maWcoXCJkZWZhdWx0Vmlld01vZGVcIik7XG5cdFx0XHRcdGNvbnN0IGxlYWYgPSB3b3Jrc3BhY2UuZ2V0TGVhZihmYWxzZSk7XG5cdFx0XHRcdGF3YWl0IGxlYWYub3BlbkZpbGUodmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKGRhc2hib2FyZENhbnZhcykgYXMgVEZpbGUsIHsgYWN0aXZlIDogdHJ1ZSwvKiBtb2RlICovfSk7XG5cdFx0XHR9XG5cdFx0fSlcblxuXHRcdHRoaXMuYWRkT2JzaWRpYW5JY29uKCd1cGRhdGUtc2NoZWR1bGluZy1pY29uJywgJ1VTJyk7XG5cdFx0dGhpcy5hZGRDb21tYW5kKHtcblx0XHRcdGlkOiBcInVwZGF0ZS1zY2hlZHVsaW5nXCIsXG5cdFx0XHRuYW1lOiBcIlVwZGF0ZSBTY2hlZHVsaW5nXCIsXG5cdFx0XHRpY29uOiBcInVwZGF0ZS1zY2hlZHVsaW5nLWljb25cIixcblx0XHRcdGNhbGxiYWNrOiBhc3luYyAoKSA9PiB7XG5cdFx0XHRcdGNvbnN0IHsgdmF1bHQgfSA9IHRoaXMuYXBwO1xuXHRcdFx0XHRjb25zdCBzY2hlZHVsZU5vdGVXaXRob3V0TWQgPSBcIkQvU2NoZWR1bGluZ1wiXG5cdFx0XHRcdGNvbnN0IHNjaGVkdWxlTm90ZSA9IGAke3NjaGVkdWxlTm90ZVdpdGhvdXRNZH0ubWRgXHRcdFx0XHRcblx0XHRcdFx0aWYgKHZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aChzY2hlZHVsZU5vdGUpID09IG51bGwpIHtcblx0XHRcdFx0XHRhd2FpdCB2YXVsdC5jcmVhdGUoc2NoZWR1bGVOb3RlLCBcIlwiKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRsZXQgbm90ZUNvbnRlbnQgPSAnJ1xuXHRcdFx0XHRBcnJheS5mcm9tKEFycmF5KDcpLmtleXMoKSkuZm9yRWFjaChpID0+IG5vdGVDb250ZW50ICs9IHRoaXMuZ2V0UXVlcnlEYXRlU3RyaW5nKGksIHNjaGVkdWxlTm90ZVdpdGhvdXRNZCkpO1xuXHRcdFx0XHR2YXVsdC5tb2RpZnkodmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKHNjaGVkdWxlTm90ZSkgYXMgVEZpbGUsIG5vdGVDb250ZW50KTtcblxuXHRcdFx0XHR0aGlzLmFkZEFjdGlvbk5vdGVDb250ZW50KHZhdWx0LCBcIkRcIiwgXCJRdWVyeSBXIG5vdyBhY3Rpb25zXCIsIFwiV2Vla2x5IFNjaGVkdWxlIFdcIiwgXCJ3XCIpXG5cdFx0XHRcdHRoaXMuYWRkQWN0aW9uTm90ZUNvbnRlbnQodmF1bHQsIFwiRFwiLCBcIlF1ZXJ5IE4gbm93IGFjdGlvbnNcIiwgXCJXZWVrbHkgU2NoZWR1bGUgTlwiLCBcIm5cIilcblx0XHRcdFx0dGhpcy5hZGQzRGF5c0FjdGlvbk5vdGVDb250ZW50KHZhdWx0KTtcblx0XHRcdFx0bmV3IE5vdGljZShcIlVwZGF0ZWQgc2NoZWR1bGVcIik7XG5cdFx0XHR9LyosXG5cdFx0XHRob3RrZXlzOiBbXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRtb2RpZmllcnM6IFtgQ3RybGAsIGBNZXRhYCwgYFNoaWZ0YF0sXG5cdFx0XHRcdFx0a2V5OiBgdWAsXG5cdFx0XHRcdH0sXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRtb2RpZmllcnM6IFtgQ3RybGAsIGBBbHRgLCBgU2hpZnRgXSxcblx0XHRcdFx0XHRrZXk6IGB1YCxcblx0XHRcdFx0fSxcblx0XHRcdF0qL1xuXHRcdH0pXG5cblx0XHQvKlxuXHRcdHRoaXMuYWRkT2JzaWRpYW5JY29uKCdvcGVuLWRhc2hib2FyZC1pY29uJywgJ09EJyk7XG5cdFx0dGhpcy5hZGRDb21tYW5kKHtcblx0XHRcdGlkOiBcIm9wZW4tZGFzaGJvYXJkXCIsXG5cdFx0XHRuYW1lOiBcIk9wZW4gRGFzaGJvYXJkXCIsXG5cdFx0XHRpY29uOiBcIm9wZW4tZGFzaGJvYXJkLWljb25cIixcblx0XHRcdGNhbGxiYWNrOiBhc3luYyAoKSA9PiB7XG5cdFx0XHRcdGNvbnN0IHsgdmF1bHQgfSA9IHRoaXMuYXBwO1xuXHRcdFx0XHRjb25zdCB7IHdvcmtzcGFjZSB9ID0gdGhpcy5hcHA7XG5cdFx0XHRcdGNvbnN0IGRhc2hib2FyZENhbnZhcyA9IFwiRC9EYXNoYm9hcmQuY2FudmFzXCJcblx0XHRcdFx0Y29uc3QgbW9kZSA9ICh0aGlzLmFwcC52YXVsdCBhcyBhbnkpLmdldENvbmZpZyhcImRlZmF1bHRWaWV3TW9kZVwiKTtcblx0XHRcdFx0Y29uc3QgbGVhZiA9IHdvcmtzcGFjZS5nZXRMZWFmKGZhbHNlKTtcblx0XHRcdFx0YXdhaXQgbGVhZi5vcGVuRmlsZSh2YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgoZGFzaGJvYXJkQ2FudmFzKSBhcyBURmlsZSwgeyBhY3RpdmUgOiB0cnVlfSk7XG5cdFx0XHR9LFxuXHRcdH0pXG5cdFx0Ki9cblxuXHRcdHRoaXMuYWRkT2JzaWRpYW5JY29uKCdvcGVuLXJlY2VudC1kYXktc2NoZWR1bGUtaWNvbicsICdPUicpO1xuXHRcdHRoaXMuYWRkQ29tbWFuZCh7XG5cdFx0XHRpZDogXCJvcGVuLXJlY2VudC1kYXlzLXNjaGVkdWxlXCIsXG5cdFx0XHRuYW1lOiBcIk9wZW4gUmVjZW50IERheXMgU2NoZWR1bGVcIixcblx0XHRcdGljb246IFwib3Blbi1yZWNlbnQtZGF5LXNjaGVkdWxlLWljb25cIixcblx0XHRcdGNhbGxiYWNrOiBhc3luYyAoKSA9PiB7XG5cdFx0XHRcdGNvbnN0IHsgdmF1bHQsIHdvcmtzcGFjZSB9ID0gdGhpcy5hcHA7XG5cdFx0XHRcdGNvbnN0IGRhc2hib2FyZENhbnZhcyA9IFwiRC9RdWVyeSBTY2hlZHVsZSBhbmQgQWN0aW9ucyBuZXh0IDMgZGF5cy5tZFwiXG5cdFx0XHRcdGNvbnN0IGxlYWYgPSB3b3Jrc3BhY2UuZ2V0TGVhZihmYWxzZSk7XG5cdFx0XHRcdGF3YWl0IGxlYWYub3BlbkZpbGUodmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKGRhc2hib2FyZENhbnZhcykgYXMgVEZpbGUsIHsgYWN0aXZlIDogdHJ1ZSB9KTtcblx0XHRcdH0sXG5cdFx0fSlcblxuXHRcdHRoaXMuYWRkT2JzaWRpYW5JY29uKCdvcGVuLWluYm94LWljb24nLCAnT0knKTtcblx0XHR0aGlzLmFkZENvbW1hbmQoe1xuXHRcdFx0aWQ6IFwib3Blbi1pbmJveFwiLFxuXHRcdFx0bmFtZTogXCJPSSBPcGVuIEluYm94XCIsXG5cdFx0XHRpY29uOiBcIm9wZW4taW5ib3gtaWNvblwiLFxuXHRcdFx0Y2FsbGJhY2s6IGFzeW5jICgpID0+IHtcblx0XHRcdFx0Y29uc3QgeyB2YXVsdCwgd29ya3NwYWNlIH0gPSB0aGlzLmFwcDtcblx0XHRcdFx0Y29uc3QgaW5ib3hNZCA9IFwiSS9JbmJveC5tZFwiXG5cdFx0XHRcdGNvbnN0IGxlYWYgPSB3b3Jrc3BhY2UuZ2V0TGVhZihmYWxzZSk7XG5cdFx0XHRcdGF3YWl0IGxlYWYub3BlbkZpbGUodmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKGluYm94TWQpIGFzIFRGaWxlLCB7IGFjdGl2ZSA6IHRydWUgfSk7XG5cdFx0XHR9LFxuXHRcdH0pXG5cblx0XHR0aGlzLmFkZE9ic2lkaWFuSWNvbignb3Blbi1wbGF5Z3JvdW5kLWljb24nLCAnT1AnKTtcblx0XHR0aGlzLmFkZENvbW1hbmQoe1xuXHRcdFx0aWQ6IFwib3Blbi1wbGF5Z3JvdW5kXCIsXG5cdFx0XHRuYW1lOiBcIk9QIE9wZW4gUGxheWdyb3VuZFwiLFxuXHRcdFx0aWNvbjogXCJvcGVuLXBsYXlncm91bmQtaWNvblwiLFxuXHRcdFx0Y2FsbGJhY2s6IGFzeW5jICgpID0+IHtcblx0XHRcdFx0bmV3IE9wZW5QbGF5Z3JvdW5kTW9kYWwodGhpcy5hcHApLm9wZW4oKVxuXHRcdFx0fSxcblx0XHRcdGhvdGtleXM6IFtcblx0XHRcdFx0e1xuXHRcdFx0XHRcdG1vZGlmaWVyczogW2BDdHJsYCwgYE1ldGFgLCBgU2hpZnRgXSxcblx0XHRcdFx0XHRrZXk6IGBwYCxcblx0XHRcdFx0fSxcblx0XHRcdFx0e1xuXHRcdFx0XHRcdG1vZGlmaWVyczogW2BDdHJsYCwgYEFsdGAsIGBTaGlmdGBdLFxuXHRcdFx0XHRcdGtleTogYHBgLFxuXHRcdFx0XHR9LFxuXHRcdFx0XVxuXHRcdH0pXG5cblx0XHR0aGlzLmFkZE9ic2lkaWFuSWNvbignb3Blbi1icmFpbmR1bXAtaWNvbicsICdPQicpO1xuXHRcdHRoaXMuYWRkQ29tbWFuZCh7XG5cdFx0XHRpZDogXCJvcGVuLWJyYWluZHVtcFwiLFxuXHRcdFx0bmFtZTogXCJPQiBPcGVuIEJyYWluRHVtcFwiLFxuXHRcdFx0aWNvbjogXCJvcGVuLWJyYWluZHVtcC1pY29uXCIsXG5cdFx0XHRjYWxsYmFjazogYXN5bmMgKCkgPT4ge1xuXHRcdFx0XHRjb25zdCB7IHZhdWx0LCB3b3Jrc3BhY2UgfSA9IHRoaXMuYXBwO1xuXHRcdFx0XHRjb25zdCBpbmJveE1kID0gXCJJL0JyYWluIER1bXAubWRcIlxuXHRcdFx0XHRjb25zdCBsZWFmID0gd29ya3NwYWNlLmdldExlYWYoZmFsc2UpO1xuXHRcdFx0XHRhd2FpdCBsZWFmLm9wZW5GaWxlKHZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aChpbmJveE1kKSBhcyBURmlsZSwgeyBhY3RpdmUgOiB0cnVlIH0pO1xuXHRcdFx0fSxcblx0XHR9KVxuXG5cdFx0Lypcblx0XHR0aGlzLmFkZENvbW1hbmQoe1xuXHRcdFx0aWQ6IFwib3Blbi1hY3Rpb25zXCIsXG5cdFx0XHRuYW1lOiBcIk9wZW4gQWN0aW9uc1wiLFxuXHRcdFx0aWNvbjogYGFwZXJ0dXJlYCxcblx0XHRcdGVkaXRvckNhbGxiYWNrOiAoZWRpdG9yOiBFZGl0b3IsIHZpZXc6IE1hcmtkb3duVmlldykgPT4ge1xuXHRcdFx0ICBuZXcgT3BlbkFjdGlvbnNNb2RhbCh0aGlzLmFwcCkub3BlbigpO1xuXHRcdFx0fSxcblx0XHRcdGhvdGtleXM6IFtcblx0XHRcdFx0e1xuXHRcdFx0XHRcdG1vZGlmaWVyczogW2BDdHJsYCwgYE1ldGFgLCBgU2hpZnRgXSxcblx0XHRcdFx0XHRrZXk6IGB4YCxcblx0XHRcdFx0fSxcblx0XHRcdFx0e1xuXHRcdFx0XHRcdG1vZGlmaWVyczogW2BDdHJsYCwgYEFsdGAsIGBTaGlmdGBdLFxuXHRcdFx0XHRcdGtleTogYHhgLFxuXHRcdFx0XHR9LFxuXHRcdFx0XVxuXHRcdH0pO1xuXHRcdCovXG5cblx0XHQvLyBUT0RPIHJlbW92ZSBhZnRlciBUVyBtaWdyYXRlIGZpbmlzaFxuXHRcdHRoaXMuYWRkT2JzaWRpYW5JY29uKCdmb3JtYXQtYWxsLW5vdGVzLWN1c3RvbScsICdGQScpO1xuXHRcdHRoaXMuYWRkQ29tbWFuZCh7XG5cdFx0XHRpZDogXCJmb3JtYXQtYWxsLW5vdGVzLWN1c3RvbVwiLFxuXHRcdFx0bmFtZTogXCJGQSBGb3JtYXQgQWxsIE5vdGVzIChDdXN0b20gdXNhZ2UpXCIsXG5cdFx0XHRpY29uOiBgZm9ybWF0LWFsbC1ub3Rlcy1jdXN0b21gLFxuXHRcdFx0Y2FsbGJhY2s6IGFzeW5jICgpID0+IHtcblx0XHRcdFx0Y29uc3QgdmF1bHQ6IFZhdWx0ID0gdGhpcy5hcHAudmF1bHQ7XG5cdFx0XHRcdFxuXHRcdFx0XHRsZXQgc3RhcnRDb3VudCA9IDBcblx0XHRcdFx0bGV0IGZpbmlzaGVkQ291bnQgPSAwXG5cdFx0XHRcdGNvbnN0IGZpbGVzID0gdmF1bHQuZ2V0TWFya2Rvd25GaWxlcygpXG5cdFx0XHRcdG5ldyBOb3RpY2UoXCJhbGw9XCIgKyBmaWxlcy5sZW5ndGgpXG5cdFx0XHRcdGNvbnNvbGUubG9nKFwiYWxsPVwiICsgZmlsZXMubGVuZ3RoKVxuXHRcdFx0XHRmb3IgKGNvbnN0IGZpbGUgb2YgZmlsZXMpIHtcblx0XHRcdFx0XHQvLyBub3RlIHRoYXQgc3RpbGwgYXN5bmNcblx0XHRcdFx0XHRjb25zb2xlLmxvZyhcInM6IFwiICsgc3RhcnRDb3VudClcblx0XHRcdFx0XHR2YXVsdC5yZWFkKGZpbGUpLnRoZW4oKGNvbnRlbnQpID0+IHtcblx0XHRcdFx0XHRcdGNvbnN0IG1vZGlmaWVkVmFsdWUgPSB0aWR5VXBGcm9udE1hdHRlck9uVmFsdWUoY29udGVudClcblx0XHRcdFx0XHRcdHJldHVybiB2YXVsdC5tb2RpZnkoZmlsZSwgbW9kaWZpZWRWYWx1ZSk7XG5cdFx0XHRcdFx0fSkudGhlbigoKSA9PiB7XG5cdFx0XHRcdFx0XHRjb25zb2xlLmxvZyhcImY6IFwiICsgZmluaXNoZWRDb3VudClcblx0XHRcdFx0XHRcdGZpbmlzaGVkQ291bnQrK1xuXHRcdFx0XHRcdFx0aWYgKGZpbmlzaGVkQ291bnQgPT0gZmlsZXMubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRcdGNvbnNvbGUubG9nKFwiZmluaXNoZWRcIilcblx0XHRcdFx0XHRcdFx0bmV3IE5vdGljZShcImZpbmlzaGVkXCIpXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSlcblx0XHRcdFx0XHRzdGFydENvdW50Kytcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGhvdGtleXM6IFtcblx0XHRcdFx0e1xuXHRcdFx0XHRcdG1vZGlmaWVyczogW2BDdHJsYCwgYE1ldGFgLCBgU2hpZnRgXSxcblx0XHRcdFx0XHRrZXk6IGAxYCxcblx0XHRcdFx0fSxcblx0XHRcdFx0e1xuXHRcdFx0XHRcdG1vZGlmaWVyczogW2BDdHJsYCwgYEFsdGAsIGBTaGlmdGBdLFxuXHRcdFx0XHRcdGtleTogYDFgLFxuXHRcdFx0XHR9LFxuXHRcdFx0XVxuXHRcdH0pO1xuXG5cdFx0Ly8gVE9ETyByZW1vdmUgYWZ0ZXIgVFcgbWlncmF0ZSBmaW5pc2hcblx0XHR0aGlzLmFkZE9ic2lkaWFuSWNvbigndHctZml4LWJyb2tlbi1saW5rJywgJzpfJyk7XG5cdFx0dGhpcy5hZGRDb21tYW5kKHtcblx0XHRcdGlkOiBcInR3LWZpeC1icm9rZW4tbGlua1wiLFxuXHRcdFx0bmFtZTogXCJCTCBGaXggVFcgQnJva2VuIExpbmtcIixcblx0XHRcdGljb246IGB0dy1maXgtYnJva2VuLWxpbmtgLFxuXHRcdFx0ZWRpdG9yQ2FsbGJhY2s6IChlZGl0b3I6IEVkaXRvciwgdmlldzogTWFya2Rvd25WaWV3KSA9PiB7XG5cdFx0XHRcdGNvbnN0IGN1cnNvciA9IGVkaXRvci5nZXRDdXJzb3IoKVxuXHRcdFx0XHRjb25zdCBsaW5lID0gY3Vyc29yLmxpbmVcblx0XHRcdFx0Y29uc3QgbGluZUNvbnRlbnQgPSBlZGl0b3IuZ2V0TGluZShsaW5lKVxuXHRcdFx0XHQvLyByZXBsYWNlIGFsbCA6IHRvIF8gYW5kIHJlcGxhY2UgYWxsID8gdG8gXyBhbmQgcmVwbGFjZSBhbGwgLyB0byBfIGFuZCByZXBsYWNlIGFsbCAuIHRvIF9cblx0XHRcdFx0ZWRpdG9yLnNldExpbmUobGluZSwgbGluZUNvbnRlbnQucmVwbGFjZSgvOi9nLCBcIl9cIikucmVwbGFjZSgvXFw/L2csIFwiX1wiKS5yZXBsYWNlKC9cXC8vZywgXCJfXCIpLnJlcGxhY2UoLzwvZywgXCJfXCIpLnJlcGxhY2UoLz4vZywgXCJfXCIpXG5cdFx0XHRcdC5yZXBsYWNlKC9eKHBhcmVudFxcZCspXyAvLCBcIiQxOiBcIilcblx0XHRcdFx0LnJlcGxhY2UoL14odGl0bGVcXGQrKV8gLywgXCIkMTogXCIpXG5cdFx0XHRcdClcblx0XHRcdH0vKixcblx0XHRcdGhvdGtleXM6IFtcblx0XHRcdFx0e1xuXHRcdFx0XHRcdG1vZGlmaWVyczogW2BDdHJsYCwgYE1ldGFgLCBgU2hpZnRgXSxcblx0XHRcdFx0XHRrZXk6IGA1YCxcblx0XHRcdFx0fSxcblx0XHRcdFx0e1xuXHRcdFx0XHRcdG1vZGlmaWVyczogW2BDdHJsYCwgYEFsdGAsIGBTaGlmdGBdLFxuXHRcdFx0XHRcdGtleTogYDVgLFxuXHRcdFx0XHR9LFxuXHRcdFx0XSovXG5cdFx0fSk7XG5cblx0XHQvLyBUT0RPIHJlbW92ZSBhZnRlciBUVyBtaWdyYXRlIGZpbmlzaFxuXHRcdHRoaXMuYWRkT2JzaWRpYW5JY29uKCdmb3JtYXQtbm90ZXMtY3VzdG9tJywgJ0ZOJyk7XG5cdFx0dGhpcy5hZGRDb21tYW5kKHtcblx0XHRcdGlkOiBcImZvcm1hdC1ub3Rlcy1jdXN0b21cIixcblx0XHRcdG5hbWU6IFwiRk4gRm9ybWF0IE5vdGVzIChDdXN0b20gdXNhZ2UpXCIsXG5cdFx0XHRpY29uOiBgZm9ybWF0LW5vdGVzLWN1c3RvbWAsXG5cdFx0XHRlZGl0b3JDYWxsYmFjazogKGVkaXRvcjogRWRpdG9yLCB2aWV3OiBNYXJrZG93blZpZXcpID0+IHtcblx0XHRcdFx0dGlkeVVwRnJvbnRNYXR0ZXJvbkVkaXRvcihlZGl0b3IpXG5cdFx0XHR9LFxuXHRcdFx0aG90a2V5czogW1xuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bW9kaWZpZXJzOiBbYEN0cmxgLCBgTWV0YWAsIGBTaGlmdGBdLFxuXHRcdFx0XHRcdGtleTogYDJgLFxuXHRcdFx0XHR9LFxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bW9kaWZpZXJzOiBbYEN0cmxgLCBgQWx0YCwgYFNoaWZ0YF0sXG5cdFx0XHRcdFx0a2V5OiBgMmAsXG5cdFx0XHRcdH0sXG5cdFx0XHRdXG5cdFx0fSk7XG5cbi8vIFRPRE8gcmVtb3ZlIGFmdGVyIFRXIG1pZ3JhdGUgZmluaXNoXG50aGlzLmFkZE9ic2lkaWFuSWNvbigndHctZ2V0LXBhcmVudC1saW5rJywgJ1tdJyk7XG50aGlzLmFkZENvbW1hbmQoe1xuXHRpZDogXCJ0dy1nZXQtcGFyZW50LWxpbmtcIixcblx0bmFtZTogXCJ0dy1nZXQtcGFyZW50LWxpbmtcIixcblx0aWNvbjogYHR3LWdldC1wYXJlbnQtbGlua2AsXG5cdGVkaXRvckNhbGxiYWNrOiAoZWRpdG9yOiBFZGl0b3IsIHZpZXc6IE1hcmtkb3duVmlldykgPT4ge1xuXHRcdC8vIGV4YW1wbGUgY3Vyc29yIGxpbmUgaXMgZWl0aGVyIG9uZSBvZiBmb2xsb3dpbmc6XG5cdFx0Ly8gcGFyZW50MTogXCJbW0lUSVZJVEkgXyBBU1ggVHJhZGluZ11dXCJcblx0XHQvLyAtIHBhcmVudDE6IFwiW1tJVElWSVRJIF8gQVNYIFRyYWRpbmddXVwiXG5cdFx0Ly8gZ29hbCBpcyB0byBjb3B5IFwiSVRJVklUSSBfIEFTWCBUcmFkaW5nXCIgdG8gY2xpcGJvYXJkIGFuZCByZW1vdmUgdGhpcyBsaW5lXG5cdFx0Y29uc3QgY3Vyc29yID0gZWRpdG9yLmdldEN1cnNvcigpXG5cdFx0Y29uc3QgbGluZSA9IGN1cnNvci5saW5lXG5cdFx0Y29uc3QgY2ggPSBjdXJzb3IuY2hcblx0XHRjb25zdCBsaW5lQ29udGVudCA9IGVkaXRvci5nZXRMaW5lKGxpbmUpXG5cdFx0aWYgKC9ecGFyZW50XFxkKzogLy50ZXN0KGxpbmVDb250ZW50KSB8fCAvXlxcdCstIHBhcmVudFxcZCs6IC8udGVzdChsaW5lQ29udGVudCkpIHtcblx0XHRcdGNvbnN0IHBhcmVudExpbmsgPSBsaW5lQ29udGVudC5yZXBsYWNlKC9ecGFyZW50XFxkKzogLywgXCJcIikucmVwbGFjZSgvXlxcdCstIHBhcmVudFxcZCs6IC8sIFwiXCIpLnJlcGxhY2UoL1wiL2csIFwiXCIpLnJlcGxhY2UoL1xcW1xcWy8sIFwiXCIpLnJlcGxhY2UoL1xcXVxcXS8sIFwiXCIpXG5cdFx0XHRuYXZpZ2F0b3IuY2xpcGJvYXJkLndyaXRlVGV4dChwYXJlbnRMaW5rKS50aGVuKCgpID0+IHtcblx0XHRcdFx0aWYgKGxpbmUgPT0gMCkge1xuXHRcdFx0XHRcdGVkaXRvci5zZXRWYWx1ZShcIlwiKVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGNvbnN0IHByZXZpb3VzTGluZSA9IGVkaXRvci5nZXRMaW5lKGxpbmUtMSlcblx0XHRcdFx0XHRlZGl0b3IucmVwbGFjZVJhbmdlKFwiXCIsIHtsaW5lOiBsaW5lLTEsIGNoOiBwcmV2aW91c0xpbmUubGVuZ3RofSwge2xpbmU6IGxpbmUsIGNoOiBsaW5lQ29udGVudC5sZW5ndGh9KVxuXHRcdFx0XHR9XG5cdFx0XHRcdGVkaXRvci5zZXRWYWx1ZShlZGl0b3IuZ2V0VmFsdWUoKS5yZXBsYWNlKC9eLS0tXFxuKy0tLVxcbi8sIFwiLS0tXFxudGFnczogYi9uL2NcXG4tLS1cXG5cIikucmVwbGFjZSgvXFxuJC8sIFwiXCIpKVxuXHRcdFx0XHRlZGl0b3Iuc2V0Q3Vyc29yKHtsaW5lOiBsaW5lLCBjaDogY2ggPiBlZGl0b3IuZ2V0TGluZShsaW5lKS5sZW5ndGggPyBlZGl0b3IuZ2V0TGluZShsaW5lKS5sZW5ndGggOiBjaH0pXG5cdFx0XHRcdG5ldyBOb3RpY2UoXCJDb3BpZWQgdG8gY2xpcGJvYXJkOiBcIiArIHBhcmVudExpbmspXG5cdFx0XHR9KVxuXHRcdH1cblx0fSxcblx0aG90a2V5czogW1xuXHRcdHtcblx0XHRcdG1vZGlmaWVyczogW2BDdHJsYCwgYE1ldGFgLCBgU2hpZnRgXSxcblx0XHRcdGtleTogYHlgLFxuXHRcdH0sXG5cdFx0e1xuXHRcdFx0bW9kaWZpZXJzOiBbYEN0cmxgLCBgQWx0YCwgYFNoaWZ0YF0sXG5cdFx0XHRrZXk6IGB5YCxcblx0XHR9LFxuXHRdXG59KTtcblxuLy8gVE9ETyByZW1vdmUgYWZ0ZXIgVFcgbWlncmF0ZSBmaW5pc2hcbnRoaXMuYWRkT2JzaWRpYW5JY29uKCd0dy10aWR5LWxpc3Qtbm90ZScsICc9PScpO1xudGhpcy5hZGRDb21tYW5kKHtcblx0aWQ6IFwidHctdGlkeS1saXN0LW5vdGVcIixcblx0bmFtZTogXCJUTCA9PSBUVyBUaWR5IExpc3QgTm90ZVwiLFxuXHRpY29uOiBgdHctdGlkeS1saXN0LW5vdGVgLFxuXHRlZGl0b3JDYWxsYmFjazogKGVkaXRvcjogRWRpdG9yLCB2aWV3OiBNYXJrZG93blZpZXcpID0+IHtcblx0XHRlZGl0b3Iuc2V0VmFsdWUocmVwbGFjZVRXVXNlbGVzc1ZhbHVlKGVkaXRvci5nZXRWYWx1ZSgpKSlcblx0XHRjb25zdCBsaW5lQ291bnQgPSBlZGl0b3IubGluZUNvdW50KClcblx0XHRsZXQgZm0gPSBcIlwiXG5cdFx0bGV0IGMgPSBcIlwiXG5cdFx0bGV0IHRleHQgPSBcIlwiXG5cdFx0bGV0IGgzQ291bnQgPSAwO1xuXHRcdGxldCBjb250ZW50ID0gXCJcIlxuXHRcdGxldCB0YXNrVGFnID0gXCJcIlxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbGluZUNvdW50OyBpKyspIHtcblx0XHRcdGNvbnN0IGxpbmUgPSBlZGl0b3IuZ2V0TGluZShpKVxuXHRcdFx0aWYgKGgzQ291bnQgPT0gMCkge1xuXHRcdFx0XHRpZiAobGluZS5sZW5ndGggIT0gMCAmJiAhL15cXHQqLSBgYGAkLy50ZXN0KGxpbmUpKSB7XG5cdFx0XHRcdFx0Y29uc3QgbW9kaWZpZWRMaW5lID0gbGluZS5jb250YWlucyhcIltbXCIpICYmIGxpbmUuY29udGFpbnMoXCJdXVwiKSBcblx0XHRcdCAgICAgICAgICAgID8gbGluZVxuXHRcdFx0XHRcdFx0OiBsaW5lLnJlcGxhY2Uodmlldy5maWxlLmJhc2VuYW1lICsgXCIgXyBcIiwgXCJcIikucmVwbGFjZSgvKFxcdCotICkjKyA+IC8sIFwiJDFcIikucmVwbGFjZSgvKFxcdCstICkjKyAvLCBcIiQxXCIpXG5cdFx0XHRcdFx0XHQvLyBcdC0gIyMgPiBjc3RhdHVzIGFuZCB0eHN0YXQgPSAwXG5cdFx0XHRcdFx0Y29udGVudCArPSAobW9kaWZpZWRMaW5lICsgXCJcXG5cIilcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmIChoM0NvdW50ID09IDEpIHtcblx0XHRcdFx0aWYgKGxpbmUuc3RhcnRzV2l0aChcInRpdGxlOiBcIikgfHwgbGluZS5zdGFydHNXaXRoKFwibGlzdDogXCIpKSB7XG5cdFx0XHRcdFx0Zm0gKz0gKGxpbmUgKyBcIlxcblwiKVxuXHRcdFx0XHR9IGVsc2UgaWYgKGxpbmUubGVuZ3RoICE9IDAgJiYgIS9eXFx0Ki0gYGBgJC8udGVzdChsaW5lKSkgeyBcblx0XHRcdFx0XHRjb25zdCBtb2RpZmllZExpbmUgPSBsaW5lLmNvbnRhaW5zKFwiW1tcIikgJiYgbGluZS5jb250YWlucyhcIl1dXCIpIFxuXHRcdFx0XHRcdFx0PyBsaW5lXG5cdFx0XHRcdFx0XHQ6IGxpbmUucmVwbGFjZSh2aWV3LmZpbGUuYmFzZW5hbWUgKyBcIiBfIFwiLCBcIlwiKS5yZXBsYWNlKC8oXFx0Ki0gKSMrID4gLywgXCIkMVwiKS5yZXBsYWNlKC8oXFx0Ky0gKSMrIC8sIFwiJDFcIilcblx0XHRcdFx0XHRmbSArPSAobW9kaWZpZWRMaW5lICsgXCJcXG5cIilcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKGgzQ291bnQgPj0gMikge1xuXHRcdFx0XHRpZiAobGluZS5sZW5ndGggIT0gMCAmJiAhL15cXHQqLSBgYGAkLy50ZXN0KGxpbmUpKSB7XG5cdFx0XHRcdFx0Y29uc3QgbW9kaWZpZWRMaW5lID0gbGluZS5jb250YWlucyhcIltbXCIpICYmIGxpbmUuY29udGFpbnMoXCJdXVwiKSBcblx0XHRcdFx0XHRcdD8gbGluZVxuXHRcdFx0XHRcdFx0OiBsaW5lLnJlcGxhY2Uodmlldy5maWxlLmJhc2VuYW1lICsgXCIgXyBcIiwgXCJcIikucmVwbGFjZSgvKFxcdCotICkjKyA+IC8sIFwiJDFcIikucmVwbGFjZSgvKFxcdCstICkjKyAvLCBcIiQxXCIpXG5cdFx0XHRcdFx0YyArPSAobW9kaWZpZWRMaW5lICsgXCJcXG5cIilcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKGxpbmUgPT09IFwiLS0tXCIpIHtcblx0XHRcdFx0aDNDb3VudCsrO1xuXHRcdFx0XHRpZiAoaDNDb3VudCA9PSAyKSB7XG5cdFx0XHRcdFx0Zm0gKz0gXCJcXG5cIlxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSBcblx0XHR0ZXh0ICs9IGNvbnRlbnRcblx0XHRpZiAoZm0ubGVuZ3RoID4gMCkge1xuXHRcdFx0dGV4dCArPSBmbVxuXHRcdH1cblx0XHR0ZXh0ICs9IGNcblx0XHR0ZXh0ID0gdGV4dC5yZXBsYWNlKC9eLS0tXFxuKy0tLVxcbi9tLCBcIi0tLVxcbnRhZ3M6IGIvbi9jXFxuLS0tXFxuXCIpLnJlcGxhY2UoL1xcbiQvLCBcIlwiKVxuXHRcdGVkaXRvci5zZXRWYWx1ZSh0ZXh0KVxuXHR9LFxuXHRob3RrZXlzOiBbXG5cdFx0e1xuXHRcdFx0bW9kaWZpZXJzOiBbYEN0cmxgLCBgTWV0YWAsIGBTaGlmdGBdLFxuXHRcdFx0a2V5OiBgNmAsXG5cdFx0fSxcblx0XHR7XG5cdFx0XHRtb2RpZmllcnM6IFtgQ3RybGAsIGBBbHRgLCBgU2hpZnRgXSxcblx0XHRcdGtleTogYDZgLFxuXHRcdH0sXG5cdF1cbn0pO1xuXG4vLyBUT0RPIHJlbW92ZSBhZnRlciBUVyBtaWdyYXRlIGZpbmlzaFxudGhpcy5hZGRPYnNpZGlhbkljb24oJ3R3LXRhc2snLCAnLS0nKTtcbnRoaXMuYWRkQ29tbWFuZCh7XG5cdGlkOiBcInR3LXRhc2tcIixcblx0bmFtZTogXCJUVCAtLSBUVyBUYXNrXCIsXG5cdGljb246IGB0dy10YXNrYCxcblx0ZWRpdG9yQ2FsbGJhY2s6IChlZGl0b3I6IEVkaXRvciwgdmlldzogTWFya2Rvd25WaWV3KSA9PiB7XG5cdFx0ZWRpdG9yLnNldFZhbHVlKHJlcGxhY2VUV1VzZWxlc3NWYWx1ZShlZGl0b3IuZ2V0VmFsdWUoKSkpXG5cdFx0Y29uc3QgbGluZUNvdW50ID0gZWRpdG9yLmxpbmVDb3VudCgpXG5cdFx0bGV0IGZtID0gXCJcIlxuXHRcdGxldCBjID0gXCJcIlxuXHRcdGxldCB0ZXh0ID0gXCJcIlxuXHRcdGxldCBoM0NvdW50ID0gMDtcblx0XHRsZXQgY29udGVudCA9IFwiXCJcblx0XHRsZXQgdGFza1RhZyA9IFwiXCJcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGxpbmVDb3VudDsgaSsrKSB7XG5cdFx0XHRjb25zdCBsaW5lID0gZWRpdG9yLmdldExpbmUoaSlcblx0XHRcdGlmIChoM0NvdW50ID09IDApIHtcblx0XHRcdFx0Y29udGVudCArPSAobGluZSArIFwiXFxuXCIpXG5cdFx0XHR9IGVsc2UgaWYgKGgzQ291bnQgPT0gMSkge1xuXHRcdFx0XHRpZiAobGluZS5zdGFydHNXaXRoKFwidGl0bGU6IFwiKSkge1xuXHRcdFx0XHRcdC8vIGRvIG5vdGhpbmdcblx0XHRcdFx0fSBlbHNlIGlmIChsaW5lLnN0YXJ0c1dpdGgoXCJ0YWdzc3M6IFwiKSkge1xuXHRcdFx0XHRcdHRhc2tUYWcgPSBcImEvXCJcblx0XHRcdFx0XHRpZiAoLyBOIC8udGVzdChsaW5lKSB8fCAvIE4kLy50ZXN0KGxpbmUpKSB7XG5cdFx0XHRcdFx0XHR0YXNrVGFnICs9IFwibi9cIlxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoLyBXIC8udGVzdChsaW5lKSB8fCAvIFckLy50ZXN0KGxpbmUpKSB7XG5cdFx0XHRcdFx0XHR0YXNrVGFnICs9IFwidy9cIlxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoLyBub3cgLy50ZXN0KGxpbmUpIHx8IC8gbm93JC8udGVzdChsaW5lKSkge1xuXHRcdFx0XHRcdFx0dGFza1RhZyArPSBcIm5cIlxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoLyBsYXRlciAvLnRlc3QobGluZSkgfHwgLyBsYXRlciQvLnRlc3QobGluZSkpIHtcblx0XHRcdFx0XHRcdHRhc2tUYWcgKz0gXCJsXCJcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKC8gd2FpdGluZyAvLnRlc3QobGluZSkgfHwgLyB3YWl0aW5nJC8udGVzdChsaW5lKSkge1xuXHRcdFx0XHRcdFx0dGFza1RhZyArPSBcIndcIlxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoLyBkb25lIC8udGVzdChsaW5lKSB8fCAvIGRvbmUkLy50ZXN0KGxpbmUpKSB7XG5cdFx0XHRcdFx0XHR0YXNrVGFnICs9IFwiZFwiXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICgvIGFyY2hpdmUgLy50ZXN0KGxpbmUpIHx8IC8gYXJjaGluZSQvLnRlc3QobGluZSkpIHtcblx0XHRcdFx0XHRcdHRhc2tUYWcgKz0gXCJhXCJcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKHRhc2tUYWcubGVuZ3RoID09IDUpIHtcblx0XHRcdFx0XHRcdGZtICs9IChcInRhZ3M6IFwiICsgdGFza1RhZyArIFwiXFxuXCIpXG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdG5ldyBOb3RpY2UoXCJlcnJvciBvbiBzZXR0aW5nIGFjdGlvbiB0YWdcIilcblx0XHRcdFx0XHRcdGZtICs9IChsaW5lICsgXCJcXG5cIilcblx0XHRcdFx0XHR9XHRcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRmbSArPSAobGluZSArIFwiXFxuXCIpXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmIChoM0NvdW50ID49IDIpIHtcblx0XHRcdFx0bGV0IG1vZGlmaWVkTGluZSA9IGxpbmVcblx0XHRcdFx0YyArPSAobW9kaWZpZWRMaW5lICsgXCJcXG5cIilcblx0XHRcdH1cblx0XHRcdGlmIChsaW5lID09PSBcIi0tLVwiKSB7XG5cdFx0XHRcdGgzQ291bnQrKztcblx0XHRcdH1cblx0XHR9IFxuXHRcdHRleHQgKz0gY29udGVudFxuXHRcdGlmIChmbS5sZW5ndGggPiAwKSB7XG5cdFx0XHR0ZXh0ICs9IGZtXG5cdFx0fVxuXHRcdHRleHQgKz0gY1xuXHRcdHRleHQgPSB0ZXh0LnJlcGxhY2UoL14tLS1cXG4rLS0tXFxuL20sIFwiLS0tXFxudGFnczogYi9uL2NcXG4tLS1cXG5cIikucmVwbGFjZSgvXFxuJC8sIFwiXCIpXG5cdFx0ZWRpdG9yLnNldFZhbHVlKHRleHQpXG5cdFx0ZWRpdG9yLnNldEN1cnNvcih7bGluZTogZ2V0UGFyZW50TGluZSh0ZXh0KSwgY2g6IDB9KVxuXHRcdGFwcC52YXVsdC5yZW5hbWUodmlldy5maWxlLCBcIkMvXCIgKyB2aWV3LmZpbGUubmFtZSlcblx0fSxcblx0aG90a2V5czogW1xuXHRcdHtcblx0XHRcdG1vZGlmaWVyczogW2BDdHJsYCwgYE1ldGFgLCBgU2hpZnRgXSxcblx0XHRcdGtleTogYDdgLFxuXHRcdH0sXG5cdFx0e1xuXHRcdFx0bW9kaWZpZXJzOiBbYEN0cmxgLCBgQWx0YCwgYFNoaWZ0YF0sXG5cdFx0XHRrZXk6IGA3YCxcblx0XHR9LFxuXHRdXG59KTtcblxuXG4vKlxuXHRcdC8vIFRPRE8gcmVtb3ZlIGFmdGVyIFRXIG1pZ3JhdGUgZmluaXNoXG5cdFx0dGhpcy5hZGRPYnNpZGlhbkljb24oJ3R3LWNoZWNrYm94JywgJ1tdJyk7XG5cdFx0dGhpcy5hZGRDb21tYW5kKHtcblx0XHRcdGlkOiBcInR3LWNoZWNrYm94XCIsXG5cdFx0XHRuYW1lOiBcIkNCIFRXIENoZWNrYm94XCIsXG5cdFx0XHRpY29uOiBgdHctY2hlY2tib3hgLFxuXHRcdFx0ZWRpdG9yQ2FsbGJhY2s6IChlZGl0b3I6IEVkaXRvciwgdmlldzogTWFya2Rvd25WaWV3KSA9PiB7XG5cdFx0XHRcdGNvbnN0IGNoZWNrYm94TWFwID0gbmV3IE1hcDxzdHJpbmcsIHN0cmluZz4oKTtcblx0XHRcdFx0Y29uc3QgbGluZUNvdW50ID0gZWRpdG9yLmxpbmVDb3VudCgpXG5cblx0XHRcdFx0bGV0IGZtID0gXCJcIlxuXHRcdFx0XHRsZXQgYyA9IFwiXCJcblx0XHRcdFx0bGV0IHRleHQgPSBcIlwiXG5cdFx0XHRcdGxldCBoM0NvdW50ID0gMDtcblx0XHRcdFx0bGV0IGNvbnRlbnQgPSBcIlwiXG5cdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbGluZUNvdW50OyBpKyspIHtcblx0XHRcdFx0XHRjb25zdCBsaW5lID0gZWRpdG9yLmdldExpbmUoaSlcblx0XHRcdFx0XHRpZiAoaDNDb3VudCA9PSAwKSB7XG5cdFx0XHRcdFx0XHRjb250ZW50ICs9IChsaW5lICsgXCJcXG5cIilcblx0XHRcdFx0XHR9IGVsc2UgaWYgKGgzQ291bnQgPT0gMSkge1xuXHRcdFx0XHRcdFx0aWYgKGxpbmUuc3RhcnRzV2l0aChcImNoZWNrYm94Ynl0aW1lX1wiKSkge1xuXHRcdFx0XHRcdFx0XHRjb25zdCBrZXlWYWx1ZUFycmF5ID0gbGluZS5zcGxpdChcIjpcIikubWFwKGl0ZW0gPT4gaXRlbS50cmltKCkpO1xuXHRcdFx0XHRcdFx0XHRpZiAoa2V5VmFsdWVBcnJheS5sZW5ndGggPT09IDIpIHtcblx0XHRcdFx0XHRcdFx0XHRjb25zdCBrZXkgPSBrZXlWYWx1ZUFycmF5WzBdO1xuXHRcdFx0XHRcdFx0XHRcdGNvbnN0IHZhbHVlID0ga2V5VmFsdWVBcnJheVsxXTtcblxuXHRcdFx0XHRcdFx0XHRcdGNvbnN0IHNwbGl0QXJyYXkgPSBrZXkuc3BsaXQoXCJfXCIpO1xuXHRcdFx0XHRcdFx0XHRcdGNvbnN0IG1vZGlmaWVkS2V5ID0gYDw8Y2hlY2tib3hCeVRpbWUgXCIke3NwbGl0QXJyYXlbMV19XCI+PmA7XG5cblx0XHRcdFx0XHRcdFx0XHRjaGVja2JveE1hcC5zZXQobW9kaWZpZWRLZXksIHZhbHVlID09PSBcIm9wZW5cIiA/IFwiW3hdXCIgOiBcIlsgXVwiKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0Zm0gKz0gKGxpbmUgKyBcIlxcblwiKVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoaDNDb3VudCA+PSAyKSB7XG5cdFx0XHRcdFx0XHRsZXQgbW9kaWZpZWRMaW5lID0gbGluZVxuXG5cdFx0XHRcdFx0XHRmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBjaGVja2JveE1hcCkge1xuXHRcdFx0XHRcdFx0XHRtb2RpZmllZExpbmUgPSBtb2RpZmllZExpbmUucmVwbGFjZShuZXcgUmVnRXhwKGtleSwgXCJnXCIpLCB2YWx1ZSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRtb2RpZmllZExpbmUgPSBtb2RpZmllZExpbmUucmVwbGFjZSgvPDxjaGVja2JveEJ5VGltZSBcIltBLVphLXowLTlfXStcIj4+L2csIFwiWyBdXCIpXG5cblx0XHRcdFx0XHRcdGMgKz0gKG1vZGlmaWVkTGluZSArIFwiXFxuXCIpXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChsaW5lID09PSBcIi0tLVwiKSB7XG5cdFx0XHRcdFx0XHRoM0NvdW50Kys7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IFxuXHRcdFx0XHR0ZXh0ICs9IGNvbnRlbnRcblx0XHRcdFx0aWYgKGZtLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0XHR0ZXh0ICs9IGZtXG5cdFx0XHRcdFx0Ly90ZXh0ICs9IFwiLS0tXFxuXCIgKyBmbSArIFwiLS0tXFxuXCJcblx0XHRcdFx0fVxuXHRcdFx0XHR0ZXh0ICs9IGNcblx0XHRcdFx0XG5cdFx0XHRcdGVkaXRvci5zZXRWYWx1ZSh0ZXh0LnJlcGxhY2UoL1xcbiQvLCBcIlwiKSlcblx0XHRcdH0sXG5cdFx0XHRob3RrZXlzOiBbXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRtb2RpZmllcnM6IFtgQ3RybGAsIGBNZXRhYCwgYFNoaWZ0YF0sXG5cdFx0XHRcdFx0a2V5OiBgN2AsXG5cdFx0XHRcdH0sXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRtb2RpZmllcnM6IFtgQ3RybGAsIGBBbHRgLCBgU2hpZnRgXSxcblx0XHRcdFx0XHRrZXk6IGA3YCxcblx0XHRcdFx0fSxcblx0XHRcdF1cblx0XHR9KTtcbiovXG5cblx0XHQvLyBUT0RPIHJlbW92ZSBhZnRlciBUVyBtaWdyYXRlIGZpbmlzaFxuXHRcdHRoaXMuYWRkT2JzaWRpYW5JY29uKCdub3RlLXRvLXRyZWUtbGlzdCcsICcqKicpO1xuXHRcdHRoaXMuYWRkQ29tbWFuZCh7XG5cdFx0XHRpZDogXCJub3RlLXRvLXRyZWUtbGlzdFwiLFxuXHRcdFx0bmFtZTogXCJOVCBOb3RlIHRvIFRyZWUgTGlzdFwiLFxuXHRcdFx0aWNvbjogYG5vdGUtdG8tdHJlZS1saXN0YCxcblx0XHRcdGVkaXRvckNhbGxiYWNrOiAoZWRpdG9yOiBFZGl0b3IsIHZpZXc6IE1hcmtkb3duVmlldykgPT4ge1xuXHRcdFx0XHRjb25zdCBjaGVja2JveE1hcCA9IG5ldyBNYXA8c3RyaW5nLCBzdHJpbmc+KCk7XG5cdFx0XHRcdGNvbnN0IGxpbmVDb3VudCA9IGVkaXRvci5saW5lQ291bnQoKVxuXHRcdFx0XHRpZiAoZWRpdG9yLmdldFZhbHVlKCkuc3RhcnRzV2l0aChcIi0gXCIgKyB2aWV3LmZpbGUuYmFzZW5hbWUgKyBcIlxcblwiKSkge1xuXHRcdFx0XHRcdC8vIGFscmVhZHkgdGlkeSBvbmNlLCBoZXJlIG9ubHkgc2hvdWxkIHJlbW92ZSBlbXB0eSBsaW5lIGFuZCByZW1vdmUgZHVwbGljYXRlIGxpc3QgbmFtZSAodHcgaGllcmFyY2h5KVxuXHRcdFx0XHRcdGNvbnN0IGZpbGVuYW1lID0gdmlldy5maWxlLmJhc2VuYW1lXG5cdFx0XHRcdFx0bGV0IHRleHQgPSBcIlwiXG5cdFx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lQ291bnQ7IGkrKykge1xuXHRcdFx0XHRcdFx0Y29uc3QgbGluZSA9IGVkaXRvci5nZXRMaW5lKGkpXG5cdFx0XHRcdFx0XHRpZiAobGluZS50cmltKCkubGVuZ3RoICE9IDApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCEvXlxcdCotICQvLnRlc3QobGluZSkgJiYgIS9eXFx0KlxcZCtcXC4gJC8udGVzdChsaW5lKSkgeyAvLyBlbXB0eSBsaXN0IGl0ZW1cblx0XHRcdFx0XHRcdFx0XHRsZXQgbW9kTGluZSA9IGxpbmVcblx0XHRcdFx0XHRcdFx0XHRpZiAoIW1vZExpbmUuY29udGFpbnMoXCJbW1wiKSAmJiAhbW9kTGluZS5jb250YWlucyhcIl1dXCIpKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRtb2RMaW5lID0gbGluZS5yZXBsYWNlKGAke2ZpbGVuYW1lfSBfIGAsIFwiXCIpIC8vIHByZXZlbnQgcmVwbGFjZSBsaW5rXG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdGlmIChsaW5lICE9PSBgLSAke3ZpZXcuZmlsZS5iYXNlbmFtZX1gICYmIC9eLSAvLnRlc3QobGluZSkpe1xuXHRcdFx0XHRcdFx0XHRcdFx0bW9kTGluZSA9IFwiXFx0XCIgKyBtb2RMaW5lXG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdHRleHQgKz0gbW9kTGluZSArIFwiXFxuXCJcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0ZXh0ID0gdGV4dC5yZXBsYWNlKC9cXG4kL20sIFwiXCIpXG5cdFx0XHRcdFx0ZWRpdG9yLnNldFZhbHVlKHRleHQpXG5cdFx0XHRcdFx0ZWRpdG9yLnNldEN1cnNvcih7bGluZTogZ2V0UGFyZW50TGluZSh0ZXh0KSwgY2g6IDB9KVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGVkaXRvci5zZXRWYWx1ZShyZXBsYWNlVFdVc2VsZXNzVmFsdWUoZWRpdG9yLmdldFZhbHVlKCkpKVxuXHRcdFx0XHRcdGxldCB0ZXh0ID0gXCItIFwiXG5cdFx0XHRcdFx0bGV0IGgzQ291bnQgPSAwO1xuXHRcdFx0XHRcdGxldCBhY3Rpb25UYWcgPSBcIlwiXG5cdFx0XHRcdFx0bGV0IGNvbnRlbnQgPSBcIlwiXG5cdFx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lQ291bnQ7IGkrKykge1xuXHRcdFx0XHRcdFx0Y29uc3QgbGluZSA9IGVkaXRvci5nZXRMaW5lKGkpXG5cdFx0XHRcdFx0XHRpZiAoaDNDb3VudCA9PSAwKSB7XG5cdFx0XHRcdFx0XHRcdGlmIChsaW5lLnRyaW0oKS5sZW5ndGggIT0gMCAmJiBsaW5lICE9IFwiLS0tXCIpIHtcblx0XHRcdFx0XHRcdFx0XHRsZXQgbW9kaWZpZWRMaW5lID0gbGluZVxuXHRcdFx0XHRcdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgOTsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRtb2RpZmllZExpbmUgPSBtb2RpZmllZExpbmUucmVwbGFjZSgvXiAgICAvLCBcIlxcdFwiKVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRtb2RpZmllZExpbmUgPSBtb2RpZmllZExpbmUucmVwbGFjZSgvXihcXHQqKVxcKlxccy8sIFwiJDEtIFwiKVxuXHRcdFx0XHRcdFx0XHRcdG1vZGlmaWVkTGluZSA9ICgvXlxcdCotIC8udGVzdChtb2RpZmllZExpbmUpIHx8IC9eXFx0KlxcZCtcXC4gLy50ZXN0KG1vZGlmaWVkTGluZSkpID8gKFwiXFx0XCIgKyBtb2RpZmllZExpbmUpIDogKFwiXFx0LSBcIiArIG1vZGlmaWVkTGluZSlcblx0XHRcdFx0XHRcdFx0XHRjb250ZW50ICs9IFwiXFxuXCIgKyBtb2RpZmllZExpbmVcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSBlbHNlIGlmIChoM0NvdW50ID09IDEpIHtcblx0XHRcdFx0XHRcdFx0aWYgKGxpbmUgPT09IFwiLS0tXCIgfHwgc2hvdWxkU2tpcEZyb250TWF0dGVyKGxpbmUpIHx8IGxpbmUuc3RhcnRzV2l0aChcInRpdGxlOiBcIikpIHtcblx0XHRcdFx0XHRcdFx0XHQvLyBkbyBub3RoaW5nXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAobGluZS5zdGFydHNXaXRoKFwidGFnc3NzOiBcIikpIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAoLyBOIC8udGVzdChsaW5lKSB8fCAvIE4kLy50ZXN0KGxpbmUpKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRhY3Rpb25UYWcgPSBcIm5cIlxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRpZiAoLyBXIC8udGVzdChsaW5lKSB8fCAvIFckLy50ZXN0KGxpbmUpKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRhY3Rpb25UYWcgPSBcIndcIlxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRpZiAoLyBub3cgLy50ZXN0KGxpbmUpIHx8IC8gbm93JC8udGVzdChsaW5lKSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0YWN0aW9uVGFnICs9IFwiblwiXG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdGlmICgvIGxhdGVyIC8udGVzdChsaW5lKSB8fCAvIGxhdGVyJC8udGVzdChsaW5lKSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0YWN0aW9uVGFnICs9IFwibFwiXG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdGlmICgvIHdhaXRpbmcgLy50ZXN0KGxpbmUpIHx8IC8gd2FpdGluZyQvLnRlc3QobGluZSkpIHtcblx0XHRcdFx0XHRcdFx0XHRcdGFjdGlvblRhZyArPSBcIndcIlxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRpZiAoLyBkb25lIC8udGVzdChsaW5lKSB8fCAvIGRvbmUkLy50ZXN0KGxpbmUpKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRhY3Rpb25UYWcgKz0gXCJkXCJcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0aWYgKC8gYXJjaGl2ZSAvLnRlc3QobGluZSkgfHwgLyBhcmNoaW5lJC8udGVzdChsaW5lKSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0YWN0aW9uVGFnICs9IFwid1wiXG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdGlmIChhY3Rpb25UYWcubGVuZ3RoID09IDIpIHtcblx0XHRcdFx0XHRcdFx0XHRcdGFjdGlvblRhZyA9IFwiI1wiICsgYWN0aW9uVGFnICsgXCIgXCJcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKGFjdGlvblRhZy5sZW5ndGggPT0gMSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0bmV3IE5vdGljZShcImVycm9yIG9uIHNldHRpbmcgYWN0aW9uIHRhZ1wiKVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmIChsaW5lLnN0YXJ0c1dpdGgoXCJjaGVja2JveGJ5dGltZV9cIikpIHtcblx0XHRcdFx0XHRcdFx0XHRjb25zdCBrZXlWYWx1ZUFycmF5ID0gbGluZS5zcGxpdChcIjpcIikubWFwKGl0ZW0gPT4gaXRlbS50cmltKCkpO1xuXHRcdFx0XHRcdFx0XHRcdGlmIChrZXlWYWx1ZUFycmF5Lmxlbmd0aCA9PT0gMikge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y29uc3Qga2V5ID0ga2V5VmFsdWVBcnJheVswXTtcblx0XHRcdFx0XHRcdFx0XHRcdGNvbnN0IHZhbHVlID0ga2V5VmFsdWVBcnJheVsxXTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0Y29uc3Qgc3BsaXRBcnJheSA9IGtleS5zcGxpdChcIl9cIik7XG5cdFx0XHRcdFx0XHRcdFx0XHRjb25zdCBtb2RpZmllZEtleSA9IGA8PGNoZWNrYm94QnlUaW1lIFwiJHtzcGxpdEFycmF5WzFdfVwiPj5gO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRjaGVja2JveE1hcC5zZXQobW9kaWZpZWRLZXksIHZhbHVlID09PSBcIm9wZW5cIiA/IFwiW3hdXCIgOiBcIlsgXVwiKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKGxpbmUudHJpbSgpLmxlbmd0aCAhPSAwKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRsZXQgbW9kaWZpZWRMaW5lID0gbGluZVxuXHRcdFx0XHRcdFx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCA5OyBpKyspIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0bW9kaWZpZWRMaW5lID0gbW9kaWZpZWRMaW5lLnJlcGxhY2UoL14gICAgLywgXCJcXHRcIilcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdG1vZGlmaWVkTGluZSA9IG1vZGlmaWVkTGluZS5yZXBsYWNlKC9eKFxcdCopXFwqXFxzLywgXCIkMS0gXCIpXG5cdFx0XHRcdFx0XHRcdFx0XHRtb2RpZmllZExpbmUgPSAoL15cXHQqLSAvLnRlc3QobW9kaWZpZWRMaW5lKSB8fCAvXlxcdCpcXGQrXFwuIC8udGVzdChtb2RpZmllZExpbmUpKSA/IChcIlxcdFwiICsgbW9kaWZpZWRMaW5lKSA6IChcIlxcdC0gXCIgKyBtb2RpZmllZExpbmUpXG5cdFx0XHRcdFx0XHRcdFx0XHRjb250ZW50ICs9IFwiXFxuXCIgKyBtb2RpZmllZExpbmVcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmIChoM0NvdW50ID49IDIgJiYgbGluZS50cmltKCkubGVuZ3RoICE9IDApIHtcblx0XHRcdFx0XHRcdFx0bGV0IG1vZGlmaWVkTGluZSA9IChsaW5lID09PSBcIlsgXSBcIikgPyBcIlwiIDogbGluZVxuXHRcdFx0XHRcdFx0XHRpZiAobW9kaWZpZWRMaW5lLnRyaW0oKS5sZW5ndGggIT0gMCkge1xuXHRcdFx0XHRcdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgOTsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRtb2RpZmllZExpbmUgPSBtb2RpZmllZExpbmUucmVwbGFjZSgvXiAgICAvLCBcIlxcdFwiKVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRtb2RpZmllZExpbmUgPSBtb2RpZmllZExpbmUucmVwbGFjZSgvXihcXHQqKVxcKlxccy8sIFwiJDEtIFwiKVxuXHRcdFx0XHRcdFx0XHRcdG1vZGlmaWVkTGluZSA9ICgvXlxcdCotIC8udGVzdChtb2RpZmllZExpbmUpIHx8IC9eXFx0KlxcZCtcXC4gLy50ZXN0KG1vZGlmaWVkTGluZSkpID8gKFwiXFx0XCIgKyBtb2RpZmllZExpbmUpIDogKFwiXFx0LSBcIiArIG1vZGlmaWVkTGluZSlcblx0XHRcdFx0XHRcdFx0XHQvLyBtb2RpZmllZExpbmUgPSBsaW5lID09PSBcIi0tLVwiID8gXCItLS1cIiA6IG1vZGlmaWVkTGluZVxuXG5cdFx0XHRcdFx0XHRcdFx0Zm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgY2hlY2tib3hNYXApIHtcblx0XHRcdFx0XHRcdFx0XHRcdG1vZGlmaWVkTGluZSA9IG1vZGlmaWVkTGluZS5yZXBsYWNlKG5ldyBSZWdFeHAoa2V5LCBcImdcIiksIHZhbHVlKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0bW9kaWZpZWRMaW5lID0gbW9kaWZpZWRMaW5lLnJlcGxhY2UoLzw8Y2hlY2tib3hCeVRpbWUgXCJbQS1aYS16MC05X10rXCI+Pi9nLCBcIlsgXVwiKVxuXG5cdFx0XHRcdFx0XHRcdFx0dGV4dCArPSAoXCJcXG5cIiArIG1vZGlmaWVkTGluZSlcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKGxpbmUgPT09IFwiLS0tXCIpIHtcblx0XHRcdFx0XHRcdFx0bGV0IGJlZm9yZUgzID0gaDNDb3VudFxuXHRcdFx0XHRcdFx0XHRoM0NvdW50Kys7XG5cdFx0XHRcdFx0XHRcdGlmIChiZWZvcmVIMyA9PSAxICYmIGgzQ291bnQgPT0gMikge1xuXHRcdFx0XHRcdFx0XHRcdHRleHQgKz0gYWN0aW9uVGFnICsgdmlldy5maWxlLmJhc2VuYW1lXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKGgzQ291bnQgPCAyKSB7IC8vIG5vIGZyb250bWF0dGVyXG5cdFx0XHRcdFx0XHR0ZXh0ICs9IHZpZXcuZmlsZS5iYXNlbmFtZVxuXHRcdFx0XHRcdH0gXG5cdFx0XHRcdFx0dGV4dCArPSBjb250ZW50XG5cdFx0XHRcdFx0ZWRpdG9yLnNldFZhbHVlKHRleHQpXG5cdFx0XHRcdFx0ZWRpdG9yLnNldEN1cnNvcih7bGluZTogZ2V0UGFyZW50TGluZSh0ZXh0KSwgY2g6IDB9KVxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0aG90a2V5czogW1xuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bW9kaWZpZXJzOiBbYEN0cmxgLCBgTWV0YWAsIGBTaGlmdGBdLFxuXHRcdFx0XHRcdGtleTogYDhgLFxuXHRcdFx0XHR9LFxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bW9kaWZpZXJzOiBbYEN0cmxgLCBgQWx0YCwgYFNoaWZ0YF0sXG5cdFx0XHRcdFx0a2V5OiBgOGAsXG5cdFx0XHRcdH0sXG5cdFx0XHRdXG5cdFx0fSk7XG5cblx0XHR0aGlzLmFkZENvbW1hbmQoe1xuXHRcdFx0aWQ6IFwicmVtb3ZlLWNvbnRlbnQtZnJvbS1jdXJzb3JcIixcblx0XHRcdG5hbWU6IFwiUmVtb3ZlIGNvbnRlbnQgZnJvbSBjdXJzb3JcIixcblx0XHRcdGljb246IGBheGVgLFxuXHRcdFx0ZWRpdG9yQ2FsbGJhY2s6IChlZGl0b3I6IEVkaXRvciwgdmlldzogTWFya2Rvd25WaWV3KSA9PiB7XG5cdFx0XHRcdG5ldyBSZW1vdmVDb250ZW50RnJvbUN1cnNvck1vZGFsKHRoaXMuYXBwLCBlZGl0b3IpLm9wZW4oKVxuXHRcdFx0fSxcblx0XHRcdGhvdGtleXM6IFtcblx0XHRcdFx0e1xuXHRcdFx0XHRcdG1vZGlmaWVyczogW2BDdHJsYCwgYE1ldGFgLCBgU2hpZnRgXSxcblx0XHRcdFx0XHRrZXk6IGB4YCxcblx0XHRcdFx0fSxcblx0XHRcdFx0e1xuXHRcdFx0XHRcdG1vZGlmaWVyczogW2BDdHJsYCwgYEFsdGAsIGBTaGlmdGBdLFxuXHRcdFx0XHRcdGtleTogYHhgLFxuXHRcdFx0XHR9LFxuXHRcdFx0XVxuXHRcdH0pO1xuXHRcdFxuXHRcdHRoaXMuYWRkQ29tbWFuZCh7XG5cdFx0XHRpZDogXCJyZW1vdmUtY29udGVudC1sZWZ0XCIsXG5cdFx0XHRuYW1lOiBcIlJlbW92ZSBjb250ZW50IGxlZnQgc2FtZSBsaW5lXCIsXG5cdFx0XHRpY29uOiBgYXJyb3ctbGVmdC1jaXJjbGVgLFxuXHRcdFx0ZWRpdG9yQ2FsbGJhY2s6IChlZGl0b3I6IEVkaXRvciwgdmlldzogTWFya2Rvd25WaWV3KSA9PiB7XG5cdFx0XHRcdHJlbW92ZUNvbnRlbnRMZWZ0U2FtZUxpbmUoZWRpdG9yKVxuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0dGhpcy5hZGRDb21tYW5kKHtcblx0XHRcdGlkOiBcInJlbW92ZS1jb250ZW50LXJpZ2h0XCIsXG5cdFx0XHRuYW1lOiBcIlJlbW92ZSBjb250ZW50IHJpZ2h0IHNhbWUgbGluZVwiLFxuXHRcdFx0aWNvbjogYGFycm93LXJpZ2h0LWNpcmNsZWAsXG5cdFx0XHRlZGl0b3JDYWxsYmFjazogKGVkaXRvcjogRWRpdG9yLCB2aWV3OiBNYXJrZG93blZpZXcpID0+IHtcblx0XHRcdFx0cmVtb3ZlQ29udGVudExlZnRTYW1lTGluZShlZGl0b3IpXG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHR0aGlzLmFkZENvbW1hbmQoe1xuXHRcdFx0aWQ6IFwicmVtb3ZlLWNvbnRlbnQtdG9wLWxlZnRcIixcblx0XHRcdG5hbWU6IFwiUmVtb3ZlIGNvbnRlbnQgZnJvbSBzdGFydCBvZiBub3RlIHRvIGN1cnNvclwiLFxuXHRcdFx0aWNvbjogYGFycm93LXVwLWNpcmNsZWAsXG5cdFx0XHRlZGl0b3JDYWxsYmFjazogKGVkaXRvcjogRWRpdG9yLCB2aWV3OiBNYXJrZG93blZpZXcpID0+IHtcblx0XHRcdFx0cmVtb3ZlQ29udGVudEZyb21TdGFydE9mTm90ZVRvQ3Vyc29yKGVkaXRvcilcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdHRoaXMuYWRkQ29tbWFuZCh7XG5cdFx0XHRpZDogXCJyZW1vdmUtY29udGVudC1ib3R0b20tcmlnaHRcIixcblx0XHRcdG5hbWU6IFwiUmVtb3ZlIGNvbnRlbnQgZnJvbSBjdXJzb3IgdG8gZW5kIG9mIG5vdGVcIixcblx0XHRcdGljb246IGBhcnJvdy1kb3duLWNpcmNsZWAsXG5cdFx0XHRlZGl0b3JDYWxsYmFjazogKGVkaXRvcjogRWRpdG9yLCB2aWV3OiBNYXJrZG93blZpZXcpID0+IHtcblx0XHRcdFx0cmVtb3ZlQ29udGVudEZyb21DdXJzb3JUb0VuZE9mTm90ZShlZGl0b3IpXG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHR0aGlzLmFkZE9ic2lkaWFuSWNvbigndGhyZWFkcy10by1ibG9nLWljb24nLCAnVEInKTtcblx0XHR0aGlzLmFkZENvbW1hbmQoe1xuXHRcdFx0aWQ6IFwidGhyZWFkcy10by1ibG9nXCIsXG5cdFx0XHRuYW1lOiBcIlRCIFRocmVhZHMgYXMgcHJlIEJsb2cgZm9ybWF0IHRvIENsaXBib2FyZFwiLFxuXHRcdFx0aWNvbjogYHRocmVhZHMtdG8tYmxvZy1pY29uYCxcblx0XHRcdGVkaXRvckNhbGxiYWNrOiAoZWRpdG9yOiBFZGl0b3IsIHZpZXc6IE1hcmtkb3duVmlldykgPT4ge1xuXHRcdFx0XHRuZXcgVGhyZWFkc1RvQmxvZ01vZGFsKHRoaXMuYXBwLCBlZGl0b3IsIHZpZXcpLm9wZW4oKVxuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0Lypcblx0XHR0aGlzLmFkZE9ic2lkaWFuSWNvbignY2hhdGdwdC1wcm9tcHQtZm9yLWdlbmVyYXRpbmctc3VtbWFyeS10by1jbGlwYm9hcmQnLCAnR1MnKTtcblx0XHR0aGlzLmFkZENvbW1hbmQoe1xuXHRcdFx0aWQ6IFwiY2hhdGdwdC1wcm9tcHQtZm9yLWdlbmVyYXRpbmctc3VtbWFyeS10by1jbGlwYm9hcmRcIixcblx0XHRcdG5hbWU6IFwiR1MgQ2hhdEdQVCBwcm9tcHQgZm9yIGdlbmVyYXRpbmcgc3VtbWFyeSB0byBjbGlwYm9hcmRcIixcblx0XHRcdGljb246IGBjaGF0Z3B0LXByb21wdC1mb3ItZ2VuZXJhdGluZy1zdW1tYXJ5LXRvLWNsaXBib2FyZGAsXG5cdFx0XHRlZGl0b3JDYWxsYmFjazogKGVkaXRvcjogRWRpdG9yLCB2aWV3OiBNYXJrZG93blZpZXcpID0+IHtcblx0XHRcdFx0Y29uc3QgcHJvbXB0ID0gXCJcdThBQ0JcdTVDMDdcdTRFRTVcdTRFMEJcdTc2ODRcdTY1ODdcdTdBRTBcdTdCQzBcdTkzMDRcdTdFMkVcdTc3RURcdTYyMTBcdTdEMDQxNTBcdTVCNTdcdTc2ODRcdTRFMkRcdTY1ODdcdTY0NThcdTg5ODFcdUZGMENcdTc4QkFcdTRGRERcdTY0NThcdTg5ODFcdTUxNjdcdTVCQjlcdTdDQkVcdTcxNDlcdTRFMTRcdTdBODFcdTUxRkFcdTkxQ0RcdTlFREVcdTMwMDJcdTRGNjBcdTk3MDBcdTg5ODFcdTZDRThcdTYxMEZcdTRFRTVcdTRFMEJcdTVFN0VcdTlFREVcdUZGMUFcXG5cIiArXG5cdFx0XHRcdFx0XHRcdCAgIFwiXFxuXCIgK1xuXHRcdFx0XHRcdFx0XHQgICBcIjEuIFx1NUMwN1x1OTU3N1x1N0JDN1x1NTkyN1x1OEFENlx1N0UyRVx1NzdFRFx1RkYwQ1x1NTNFQVx1NEZERFx1NzU1OVx1NjcwMFx1OTFDRFx1ODk4MVx1NzY4NFx1OEEwQVx1NjA2Rlx1NTQ4Q1x1NEUzQlx1OTg0Q1x1MzAwMlxcblwiICtcblx0XHRcdFx0XHRcdFx0ICAgXCIyLiBcdTUzQkJcdTk2NjRcdTk3NUVcdTVGQzVcdTg5ODFcdTc2ODRcdThBNzNcdTdEMzBcdThBMEFcdTYwNkZcdUZGMENcdTRFMjZcdTkwN0ZcdTUxNERcdTRGN0ZcdTc1MjhcdTkwNEVcdTY1QkNcdTdFNDFcdTg5MDdcdTYyMTZcdTRFMERcdTVGQzVcdTg5ODFcdTc2ODRcdThBOUVcdThBMDBcdTMwMDJcXG5cIiArXG5cdFx0XHRcdFx0XHRcdCAgIFwiMy4gXHU0RkREXHU3NTU5XHU2NTg3XHU3QUUwXHU0RTJEXHU2NzAwXHU5MUNEXHU4OTgxXHU3Njg0XHU0RTNCXHU5ODRDXHU1NDhDXHU4QTBBXHU2MDZGXHVGRjBDXHU0RTI2XHU3OEJBXHU0RkREXHU5MDE5XHU0RTlCXHU4QTBBXHU2MDZGXHU1NzI4XHU2NDU4XHU4OTgxXHU0RTJEXHU2RTA1XHU2OTVBXHU1NzMwXHU4ODY4XHU5MDU0XHU1MUZBXHU0Rjg2XHUzMDAyXFxuXCIgK1xuXHRcdFx0XHRcdFx0XHQgICBcIjQuIFx1NEY3Rlx1NzUyOFx1N0NCRVx1NzE0OVx1NEUxNFx1NzZGNFx1NjNBNVx1NzY4NFx1OEE5RVx1OEEwMFx1RkYwQ1x1NEVFNVx1NTQzOFx1NUYxNVx1NEVCQVx1NzY4NFx1NjVCOVx1NUYwRlx1ODg2OFx1OTA1NFx1NEY1Q1x1ODAwNVx1NUMwN1x1NTcyOFx1NjU4N1x1N0FFMFx1NEUyRFx1NkRGMVx1NTE2NVx1NTIwNlx1NEVBQlx1OTAxOVx1NEU5Qlx1NEUzQlx1OTg0Q1x1NzY4NFx1NjEwRlx1NTcxNlx1MzAwMlxcblwiICtcblx0XHRcdFx0XHRcdFx0ICAgXCI1LiBcdTRGN0ZcdTc1MjhcdTMwMENcdTYyMTFcdTMwMERcdTRGODZcdTYzMDdcdTdBMzFcdTMwMENcdTRGNUNcdTgwMDVcdTMwMERcdUZGMENcdTMwMENcdTRGNjBcdTMwMERcdTRGODZcdTYzMDdcdTdBMzFcdThCODBcdTgwMDVcdTMwMDJcXG5cIiArXG5cdFx0XHRcdFx0XHRcdCAgIFwiXFxuXCIgK1xuXHRcdFx0XHRcdFx0XHQgICBcIlx1NTE3N1x1OUFENFx1NEY4Nlx1OEFBQVx1RkYwQ1x1NEY2MFx1OTcwMFx1ODk4MVx1NzhCQVx1NEZERFx1NEVFNVx1NEUwQlx1OTFDRFx1OUVERVx1OEEwQVx1NjA2Rlx1ODhBQlx1NTMwNVx1NTQyQlx1NTE3Nlx1NEUyRFx1RkYxQVxcblwiICtcblx0XHRcdFx0XHRcdFx0ICAgXCIxLiBcdTY1ODdcdTdBRTBcdTc2ODRcdTRFM0JcdTg5ODFcdTRFM0JcdTk4NENcdTYyMTZcdTkxQ0RcdTlFREVcdThBMEVcdThBRDZcdTMwMDJcXG5cIiArXG5cdFx0XHRcdFx0XHRcdCAgIFwiMi4gXHU0RjVDXHU4MDA1XHU2M0QwXHU1MUZBXHU3Njg0XHU1RUZBXHU4QjcwXHUzMDAxXHU3QjU2XHU3NTY1XHU2MjE2XHU5MUNEXHU4OTgxXHU4OUMwXHU5RURFXHUzMDAyXFxuXCIgK1xuXHRcdFx0XHRcdFx0XHQgICBcIjMuIFx1OTAxOVx1NEU5Qlx1NUVGQVx1OEI3MFx1NjIxNlx1N0I1Nlx1NzU2NVx1NzY4NFx1NTE3N1x1OUFENFx1NjU0OFx1NzZDQVx1NjIxNlx1N0Q1MFx1Njc5Q1x1MzAwMlxcblwiICtcblx0XHRcdFx0XHRcdFx0ICAgXCJcXG5cIiArXG5cdFx0XHRcdFx0XHRcdCAgIFwiXHU2NzAwXHU1RjhDXHVGRjBDXHU0RUU1XHU1NDM4XHU1RjE1XHU0RTI2XHU5RjEzXHU1MkY1XHU4QjgwXHU4MDA1XHU5MDMyXHU4ODRDXHU0RTBCXHU0RTAwXHU2QjY1XHU4ODRDXHU1MkQ1XHU3Njg0XHU2NUI5XHU1RjBGXHU3REU4XHU1QkVCXHU2NDU4XHU4OTgxXHVGRjBDXHU0RTI2XHU4ODY4XHU5MDU0XHU1MUZBXHU2NTg3XHU3QUUwXHU0RTJEXHU2NkY0XHU1OTFBXHU2REYxXHU1MTY1XHU3Njg0XHU1MTY3XHU1QkI5XHU3QjQ5XHU1Rjg1XHU4QjgwXHU4MDA1XHU1M0JCXHU2M0EyXHU3RDIyXHUzMDAyXFxuXCIgK1xuXHRcdFx0XHRcdFx0XHQgICBcIlx1OEFDQlx1NUJFQlx1NTFGQTNcdTUwMEJcdTcyNDhcdTY3MkNcdTMwMDJcXG5cXG5cIiArIGVkaXRvci5nZXRWYWx1ZSgpO1xuXG5cdFx0XHRcdG5hdmlnYXRvci5jbGlwYm9hcmQud3JpdGVUZXh0KHByb21wdCkudGhlbihmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0bmV3IE5vdGljZShgQ29waWVkIHByb21wdCBmb3IgZ2VuZXJhdGUgc3VtbWFyeSB0byBjbGlwYm9hcmQhYCk7XG5cdFx0XHRcdH0sIGZ1bmN0aW9uIChlcnJvcikge1xuXHRcdFx0XHRcdG5ldyBOb3RpY2UoYGVycm9yIHdoZW4gY29weSB0byBjbGlwYm9hcmQhYCk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdCovXG5cblx0XHR0aGlzLmFkZE9ic2lkaWFuSWNvbignYWRkLWNvbW1lbnQtdGFnLWljb24nLCAnQ1QnKTtcblx0XHR0aGlzLmFkZENvbW1hbmQoe1xuXHRcdFx0aWQ6IFwiYWRkLWNvbW1lbnQtdGFnXCIsXG5cdFx0XHRuYW1lOiBcIkNUIEFkZCBDb21tZW50IFRhZ1wiLFxuXHRcdFx0aWNvbjogYGFkZC1jb21tZW50LXRhZy1pY29uYCxcblx0XHRcdGVkaXRvckNhbGxiYWNrOiAoZWRpdG9yOiBFZGl0b3IsIHZpZXc6IE1hcmtkb3duVmlldykgPT4ge1xuXHRcdFx0ICBuZXcgQWRkRm9vdG5vdGVUYWdNb2RhbCh0aGlzLmFwcCwgZWRpdG9yKS5vcGVuKCk7XG5cdFx0XHR9LFxuXHRcdFx0aG90a2V5czogW1xuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bW9kaWZpZXJzOiBbYEN0cmxgLCBgTWV0YWAsIGBTaGlmdGBdLFxuXHRcdFx0XHRcdGtleTogYHpgLFxuXHRcdFx0XHR9LFxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bW9kaWZpZXJzOiBbYEN0cmxgLCBgQWx0YCwgYFNoaWZ0YF0sXG5cdFx0XHRcdFx0a2V5OiBgemAsXG5cdFx0XHRcdH0sXG5cdFx0XHRdXG5cdFx0fSk7XG5cblx0XHR0aGlzLmFkZE9ic2lkaWFuSWNvbignYWN0aW9uLXRhZy1jb3VudC1pY29uJywgJ0NBJyk7XG5cdFx0dGhpcy5hZGRDb21tYW5kKHtcblx0XHRcdGlkOiBcImFjdGlvbi10YWctY291bnQtaWNvblwiLFxuXHRcdFx0bmFtZTogXCJDQSBDb3VudCBBY3Rpb24gVGFnXCIsXG5cdFx0XHRpY29uOiBgYWN0aW9uLXRhZy1jb3VudC1pY29uYCxcblx0XHRcdGVkaXRvckNhbGxiYWNrOiAoZWRpdG9yOiBFZGl0b3IsIHZpZXc6IE1hcmtkb3duVmlldykgPT4ge1xuXHRcdFx0XHRjb25zdCB0YWdzID0gW1wibm5cIiwgXCJubFwiLCBcIm53XCIsIFwibjFcIiwgXCJuMlwiLCBcIm4zXCIsIFwibjRcIiwgXCJuNVwiLCBcIm42XCIsIFwibjdcIiwgXCJ3blwiLCBcIndsXCIsIFwid3dcIiwgXCJ3MVwiLCBcIncyXCIsIFwidzNcIiwgXCJ3NFwiLCBcInc1XCIsIFwidzZcIiwgXCJ3N1wiXTtcblx0XHRcdFx0Y29uc3QgbWF0Y2hlczogc3RyaW5nW10gPSBbXTtcblx0XHRcdFx0Y29uc3QgbGluZU51bSA9IGVkaXRvci5saW5lQ291bnQoKTtcblx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lTnVtOyBpKyspIHtcblx0XHRcdFx0XHRjb25zdCBsaW5lID0gZWRpdG9yLmdldExpbmUoaSlcblx0XHRcdFx0XHRjb25zdCBtYXRjaCA9IHRhZ3Muc29tZSh0YWcgPT4gbmV3IFJlZ0V4cChgIyR7dGFnfSBgLCBcImdcIikudGVzdChsaW5lKSB8fCBuZXcgUmVnRXhwKGAgIyR7dGFnfWAsIFwiZ1wiKS50ZXN0KGxpbmUpKTtcblx0XHRcdFx0XHRpZiAobWF0Y2gpIHtcblx0XHRcdFx0XHRcdG1hdGNoZXMucHVzaChgTGluZSAke2l9OlxcbiR7bGluZS50cmltKCl9YCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGNvbnN0IHRyaW1tZWRBbmRKb2luZWRTdHJpbmc6IHN0cmluZyA9IG1hdGNoZXMuam9pbihcIlxcblxcblwiKTtcblx0XHRcdFx0Y29uc3QgdGFza3MgPSBtYXRjaGVzLmxlbmd0aCA+IDAgPyBgXFxuVGFza3M6XFxuXFxuJHt0cmltbWVkQW5kSm9pbmVkU3RyaW5nfWAgOiBgYFxuXHRcdFx0XHRuZXcgTm90aWNlKGBUaGVyZSBhcmUgJHttYXRjaGVzLmxlbmd0aH0gb3V0c3RhbmRpbmcgYWN0aW9ucyBpbiB0aGlzIG5vdGVzJHt0YXNrc31gKTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdHRoaXMuYWRkT2JzaWRpYW5JY29uKCd0b2dnbGUtbi13LXRhc2snLCAnIz0nKTtcblx0XHR0aGlzLmFkZENvbW1hbmQoe1xuXHRcdFx0aWQ6IGB0b2dnbGUtbi13LXRhc2tgLFxuXHRcdFx0bmFtZTogYFRvZ2dsZSBOIFcgVGFza2AsXG5cdFx0XHRpY29uOiBgdG9nZ2xlLW4tdy10YXNrYCxcblx0XHRcdGVkaXRvckNhbGxiYWNrOiAoZWRpdG9yOiBFZGl0b3IsIHZpZXc6IE1hcmtkb3duVmlldykgPT4ge1xuXHRcdFx0XHRjb25zb2xlLmxvZyhlZGl0b3IuZ2V0U2VsZWN0aW9uKCkpO1xuXHRcdFx0XHRjb25zdCBjdXJzb3IgPSBlZGl0b3IuZ2V0Q3Vyc29yKCk7XG5cdFx0XHRcdGNvbnN0IGxpbmVOdW1iZXIgPSBlZGl0b3IuZ2V0Q3Vyc29yKCkubGluZTtcblx0XHRcdFx0Y29uc3QgbGluZSA9IGVkaXRvci5nZXRMaW5lKGxpbmVOdW1iZXIpO1xuXHRcdFx0XHRpZiAobGluZS5tYXRjaCgvIGFcXC93XFwvLi8pKSB7XG5cdFx0XHRcdFx0Y29uc3QgcmVwbGFjZWRMaW5lID0gbGluZS5yZXBsYWNlKC8gYVxcL3dcXC8oLikvLCBgIGEvbi8kMWApXG5cdFx0XHRcdFx0ZWRpdG9yLnNldExpbmUobGluZU51bWJlciwgcmVwbGFjZWRMaW5lKTtcblx0XHRcdFx0XHRlZGl0b3Iuc2V0Q3Vyc29yKGN1cnNvcilcblx0XHRcdFx0fSBlbHNlIGlmIChsaW5lLm1hdGNoKC8gYVxcL25cXC8uLykpIHtcblx0XHRcdFx0XHRjb25zdCByZXBsYWNlZExpbmUgPSBsaW5lLnJlcGxhY2UoLyBhXFwvblxcLyguKS8sIGAgYS93LyQxYClcblx0XHRcdFx0XHRlZGl0b3Iuc2V0TGluZShsaW5lTnVtYmVyLCByZXBsYWNlZExpbmUpO1xuXHRcdFx0XHRcdGVkaXRvci5zZXRDdXJzb3IoY3Vyc29yKVxuXHRcdFx0XHR9IGVsc2UgaWYgKGxpbmUubWF0Y2goLyN3LiAvKSkge1xuXHRcdFx0XHRcdGNvbnN0IHJlcGxhY2VkTGluZSA9IGxpbmUucmVwbGFjZSgvI3coLikgLywgYCNuJDEgYClcblx0XHRcdFx0XHRlZGl0b3Iuc2V0TGluZShsaW5lTnVtYmVyLCByZXBsYWNlZExpbmUpO1xuXHRcdFx0XHRcdGVkaXRvci5zZXRDdXJzb3IoY3Vyc29yKVxuXHRcdFx0XHR9IGVsc2UgaWYgKGxpbmUubWF0Y2goLyNuLiAvKSkge1xuXHRcdFx0XHRcdGNvbnN0IHJlcGxhY2VkTGluZSA9IGxpbmUucmVwbGFjZSgvI24oLikgLywgYCN3JDEgYClcblx0XHRcdFx0XHRlZGl0b3Iuc2V0TGluZShsaW5lTnVtYmVyLCByZXBsYWNlZExpbmUpO1xuXHRcdFx0XHRcdGVkaXRvci5zZXRDdXJzb3IoY3Vyc29yKVxuXHRcdFx0XHR9IGVsc2UgaWYgKGxpbmUubWF0Y2goLyAjdy4vKSkge1xuXHRcdFx0XHRcdGNvbnN0IHJlcGxhY2VkTGluZSA9IGxpbmUucmVwbGFjZSgvICN3KC4pLywgYCAjbiQxYClcblx0XHRcdFx0XHRlZGl0b3Iuc2V0TGluZShsaW5lTnVtYmVyLCByZXBsYWNlZExpbmUpO1xuXHRcdFx0XHRcdGVkaXRvci5zZXRDdXJzb3IoY3Vyc29yKVxuXHRcdFx0XHR9IGVsc2UgaWYgKGxpbmUubWF0Y2goLyAjbi4vKSkge1xuXHRcdFx0XHRcdGNvbnN0IHJlcGxhY2VkTGluZSA9IGxpbmUucmVwbGFjZSgvICNuKC4pLywgYCAjdyQxYClcblx0XHRcdFx0XHRlZGl0b3Iuc2V0TGluZShsaW5lTnVtYmVyLCByZXBsYWNlZExpbmUpO1xuXHRcdFx0XHRcdGVkaXRvci5zZXRDdXJzb3IoY3Vyc29yKVxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0aG90a2V5czogW1xuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bW9kaWZpZXJzOiBbYEN0cmxgLCBgTWV0YWAsIGBTaGlmdGBdLFxuXHRcdFx0XHRcdGtleTogYD1gLFxuXHRcdFx0XHR9LFxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bW9kaWZpZXJzOiBbYEN0cmxgLCBgQWx0YCwgYFNoaWZ0YF0sXG5cdFx0XHRcdFx0a2V5OiBgPWAsXG5cdFx0XHRcdH1cblx0XHRcdF1cblx0XHR9KTtcblxuXHRcdC8qXG5cdFx0dGhpcy5hZGRPYnNpZGlhbkljb24oJ3JlbW92ZS1hY3Rpb24taWNvbicsICctIycpO1xuXHRcdHRoaXMuYWRkQ29tbWFuZCh7XG5cdFx0XHRpZDogXCJyZW1vdmUtYWN0aW9uXCIsXG5cdFx0XHRuYW1lOiBcIlJlbW92ZSBhY3Rpb25cIixcblx0XHRcdGljb246IGByZW1vdmUtYWN0aW9uLWljb25gLFxuXHRcdFx0ZWRpdG9yQ2FsbGJhY2s6IChlZGl0b3I6IEVkaXRvciwgdmlldzogTWFya2Rvd25WaWV3KSA9PiB7XG5cdFx0XHRcdGNvbnN0IGN1cnNvciA9IGVkaXRvci5nZXRDdXJzb3IoKTtcblx0XHRcdFx0Y29uc3QgbGluZU51bWJlciA9IGVkaXRvci5nZXRDdXJzb3IoKS5saW5lO1xuXHRcdFx0XHRjb25zdCBsaW5lID0gZWRpdG9yLmdldExpbmUobGluZU51bWJlcik7XG5cdFx0XHRcdGxldCByZXBsYWNlZExpbmUgPSBsaW5lLnJlcGxhY2UoJyNubiAnLCAnJylcblx0XHRcdFx0ICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKCcjbmwgJywgJycpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCAucmVwbGFjZSgnI253ICcsICcnKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQgLnJlcGxhY2UoJyNuZCAnLCAnJylcblx0XHRcdFx0XHRcdFx0XHRcdFx0IC5yZXBsYWNlKCcjbmEgJywgJycpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCAucmVwbGFjZSgnI250ICcsICcnKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQgLnJlcGxhY2UoJyNuMSAnLCAnJylcblx0XHRcdFx0XHRcdFx0XHRcdFx0IC5yZXBsYWNlKCcjbjIgJywgJycpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCAucmVwbGFjZSgnI24zICcsICcnKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQgLnJlcGxhY2UoJyNuNCAnLCAnJylcblx0XHRcdFx0XHRcdFx0XHRcdFx0IC5yZXBsYWNlKCcjbjUgJywgJycpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCAucmVwbGFjZSgnI242ICcsICcnKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQgLnJlcGxhY2UoJyNuNyAnLCAnJylcblx0XHRcdFx0XHRcdFx0XHRcdFx0IC5yZXBsYWNlKCcjd24gJywgJycpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCAucmVwbGFjZSgnI3dsICcsICcnKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQgLnJlcGxhY2UoJyN3dyAnLCAnJylcblx0XHRcdFx0XHRcdFx0XHRcdFx0IC5yZXBsYWNlKCcjd2QgJywgJycpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCAucmVwbGFjZSgnI3dhICcsICcnKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQgLnJlcGxhY2UoJyN3dCAnLCAnJylcblx0XHRcdFx0XHRcdFx0XHRcdFx0IC5yZXBsYWNlKCcjdzEgJywgJycpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCAucmVwbGFjZSgnI3cyICcsICcnKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQgLnJlcGxhY2UoJyN3MyAnLCAnJylcblx0XHRcdFx0XHRcdFx0XHRcdFx0IC5yZXBsYWNlKCcjdzQgJywgJycpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCAucmVwbGFjZSgnI3c1ICcsICcnKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQgLnJlcGxhY2UoJyN3NiAnLCAnJylcblx0XHRcdFx0XHRcdFx0XHRcdFx0IC5yZXBsYWNlKCcjdzcgJywgJycpXG5cdFx0XHRcdHJlcGxhY2VkTGluZSA9IEFkZEZvb3Rub3RlVGFnTW9kYWwucmVtb3ZlVGFnKHJlcGxhY2VkTGluZSlcblx0XHRcdFx0ZWRpdG9yLnNldExpbmUobGluZU51bWJlciwgcmVwbGFjZWRMaW5lKTtcblx0XHRcdFx0ZWRpdG9yLnNldEN1cnNvcihjdXJzb3IpO1xuXHRcdFx0fSxcblx0XHRcdGhvdGtleXM6IFtcblx0XHRcdFx0e1xuXHRcdFx0XHRcdG1vZGlmaWVyczogW2BDdHJsYCwgYE1ldGFgLCBgU2hpZnRgXSxcblx0XHRcdFx0XHRrZXk6IGB4YCxcblx0XHRcdFx0fSxcblx0XHRcdFx0e1xuXHRcdFx0XHRcdG1vZGlmaWVyczogW2BDdHJsYCwgYEFsdGAsIGBTaGlmdGBdLFxuXHRcdFx0XHRcdGtleTogYHhgLFxuXHRcdFx0XHR9XG5cdFx0XHRdXG5cdFx0fSk7XG5cdFx0Ki9cblxuXHRcdHRoaXMuYWRkQ29tbWFuZCh7XG5cdFx0XHRpZDogXCJjdXJzb3ItZ28tdG8tc3RhcnQtb2YtbGluZVwiLFxuXHRcdFx0bmFtZTogXCJDdXJzb3IgZ28gdG8gc3RhcnQgb2YgbGluZVwiLFxuXHRcdFx0aWNvbjogYGFycm93LWJpZy1sZWZ0YCxcblx0XHRcdGVkaXRvckNhbGxiYWNrOiAoZWRpdG9yOiBFZGl0b3IsIHZpZXc6IE1hcmtkb3duVmlldykgPT4ge1xuXHRcdFx0XHRjb25zdCBjdXJzb3IgPSBlZGl0b3IuZ2V0Q3Vyc29yKCk7XG5cdFx0XHRcdGN1cnNvci5jaCA9IDA7XG5cdFx0XHRcdGVkaXRvci5zZXRDdXJzb3IoY3Vyc29yKTtcblx0XHRcdH0sXG5cdFx0fSk7XG5cblx0XHR0aGlzLmFkZENvbW1hbmQoe1xuXHRcdFx0aWQ6IFwiY3Vyc29yLWdvLXRvLWVuZC1vZi1saW5lXCIsXG5cdFx0XHRuYW1lOiBcIkN1cnNvciBnbyB0byBlbmQgb2YgbGluZVwiLFxuXHRcdFx0aWNvbjogYGFycm93LWJpZy1yaWdodGAsXG5cdFx0XHRlZGl0b3JDYWxsYmFjazogKGVkaXRvcjogRWRpdG9yLCB2aWV3OiBNYXJrZG93blZpZXcpID0+IHtcblx0XHRcdFx0Y29uc3QgY3Vyc29yID0gZWRpdG9yLmdldEN1cnNvcigpO1xuXHRcdFx0XHRjb25zdCBsaW5lTnVtID0gY3Vyc29yLmxpbmU7XG5cdFx0XHRcdGNvbnN0IGxpbmUgPSBlZGl0b3IuZ2V0TGluZShsaW5lTnVtKTtcblx0XHRcdFx0Y29uc3QgbGVuZ3RoID0gbGluZS5sZW5ndGg7XG5cdFx0XHRcdGN1cnNvci5jaCA9IGxlbmd0aDtcblx0XHRcdFx0ZWRpdG9yLnNldEN1cnNvcihjdXJzb3IpO1xuXHRcdFx0fSxcblx0XHR9KTtcblxuXHRcdHRoaXMuYWRkT2JzaWRpYW5JY29uKCdldmVudC10by1mYW50YXN0aWNhbC1pY29uJywgJ0ZFJyk7XG5cdFx0dGhpcy5hZGRDb21tYW5kKHtcblx0XHRcdGlkOiBcImFkZC1mYW50YXN0aWNhbC1ldmVudFwiLFxuXHRcdFx0bmFtZTogXCJGRSBBZGQgRmFudGFzdGljYWwgRXZlbnRcIixcblx0XHRcdGljb246IGBldmVudC10by1mYW50YXN0aWNhbC1pY29uYCxcblx0XHRcdGVkaXRvckNhbGxiYWNrOiAoZWRpdG9yOiBFZGl0b3IsIHZpZXc6IE1hcmtkb3duVmlldykgPT4ge1xuXHRcdFx0XHRsZXQgdGV4dCA9IFwiXCI7XG5cdFx0XHRcdGNvbnN0IHZhdWx0OiBWYXVsdCA9IHRoaXMuYXBwLnZhdWx0O1xuXHRcdFx0XHRjb25zdCBsaXN0U2VsZWN0aW9uczogRWRpdG9yU2VsZWN0aW9uW10gPSBlZGl0b3IubGlzdFNlbGVjdGlvbnMoKTtcblx0XHRcdCAgXG5cdFx0XHRcdGNvbnN0IHByb2Nlc3NMaW5lID0gYXN5bmMgKGxpbmU6IHN0cmluZywgaTogbnVtYmVyKSA9PiB7XG5cdFx0XHRcdFx0Ly8gdG8gbW9kaWZ5IGxpbmUgYWRkIHRtICh0byBtb3ZlKSB0YWcgYW5kIGFkZCB0byBjb3JyZXNwb25kaW5nIGpvdXJuYWwgbm90ZVxuXHRcdFx0XHQgIGlmICgvXi0gXFxkXFxkXFxkXFxkLVxcZFxcZC1cXGRcXGQgXFxkXFxkOlxcZFxcZCAvLnRlc3QobGluZSkpIHtcblx0XHRcdFx0XHRjb25zdCBtb2RpZmllZExpbmUgPSBsaW5lLnJlcGxhY2UoL14tIC8sIGAtICN0bSBgKTtcblx0XHRcdFx0XHRlZGl0b3Iuc2V0TGluZShpLCBtb2RpZmllZExpbmUpO1xuXHRcdFx0XHRcdHRleHQgKz0gbGluZSArIFwiXFxuXCI7XG5cdFx0XHQgIFxuXHRcdFx0XHRcdGNvbnN0IGxpbmVUb0FkZCA9ICctJyArIGxpbmUucmVwbGFjZSgvLS9nLCAnJyk7XG5cdFx0XHRcdFx0Y29uc3QgcGF0aCA9IGxpbmUucmVwbGFjZSgvXi0gKFxcZFxcZFxcZFxcZCktKFxcZFxcZCktLiovLCBcIkovJDEtTSQyLm1kXCIpO1xuXHRcdFx0ICBcblx0XHRcdFx0XHRsZXQgdEZpbGUgPSB2YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgocGF0aCk7XG5cdFx0XHRcdFx0aWYgKHRGaWxlID09IG51bGwpIHtcblx0XHRcdFx0XHQgIHRGaWxlID0gYXdhaXQgdmF1bHQuY3JlYXRlKHBhdGgsIGxpbmVUb0FkZCk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQgIGNvbnN0IHRGaWxlT3JpZ2luYWxWYWx1ZSA9IGF3YWl0IHZhdWx0LnJlYWQodEZpbGUgYXMgVEZpbGUpO1xuXHRcdFx0XHRcdCAgYXdhaXQgdmF1bHQubW9kaWZ5KHRGaWxlIGFzIFRGaWxlLCB0RmlsZU9yaWdpbmFsVmFsdWUgKyBcIlxcblwiICsgbGluZVRvQWRkKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdCAgfVxuXHRcdFx0XHR9O1xuXHRcdFx0ICBcblx0XHRcdFx0Y29uc3QgcHJvY2Vzc1NlbGVjdGlvbnMgPSBhc3luYyAoKSA9PiB7XG5cdFx0XHRcdCAgZm9yIChjb25zdCBsaXN0U2VsZWN0aW9uIG9mIGxpc3RTZWxlY3Rpb25zKSB7XG5cdFx0XHRcdFx0Y29uc3QgYSA9IGxpc3RTZWxlY3Rpb24uaGVhZC5saW5lO1xuXHRcdFx0XHRcdGNvbnN0IGIgPSBsaXN0U2VsZWN0aW9uLmFuY2hvci5saW5lO1xuXHRcdFx0XHRcdGNvbnN0IGZyb21MaW5lTnVtID0gYiA+IGEgPyBhIDogYjtcblx0XHRcdFx0XHRjb25zdCB0b0xpbmVOdW0gPSBiID4gYSA/IGIgOiBhO1xuXHRcdFx0ICBcblx0XHRcdFx0XHRmb3IgKGxldCBpID0gZnJvbUxpbmVOdW07IGkgPD0gdG9MaW5lTnVtOyBpKyspIHtcblx0XHRcdFx0XHQgIGNvbnN0IGxpbmUgPSBlZGl0b3IuZ2V0TGluZShpKTtcblx0XHRcdFx0XHQgIGF3YWl0IHByb2Nlc3NMaW5lKGxpbmUsIGkpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0ICB9XG5cdFx0XHRcdH07XG5cdFx0XHQgIFxuXHRcdFx0XHRwcm9jZXNzU2VsZWN0aW9ucygpLnRoZW4oKCkgPT4ge1xuXHRcdFx0XHQgIGlmICh0ZXh0Lmxlbmd0aCAhPT0gMCkge1xuXHRcdFx0XHRcdHRleHQgPSBlbmNvZGVVUkkodGV4dCk7XG5cdFx0XHRcdFx0d2luZG93Lm9wZW4oYHNob3J0Y3V0czovL3J1bi1zaG9ydGN1dD9uYW1lPUFkZCUyME9ic2lkaWFuJTIwSW5ib3glMjBFdmVudCUyMHZpYSUyMEZhbnRhc3RpY2FsJmlucHV0PXRleHQmdGV4dD0ke3RleHR9Jngtc3VjY2Vzcz1vYnNpZGlhbjovLyZ4LWNhbmNlbD1vYnNpZGlhbjovLyZ4LWVycm9yPW9ic2lkaWFuOi8vYCk7XG5cdFx0XHRcdCAgfVxuXHRcdFx0XHR9KTtcblx0XHRcdCAgfSxcblx0XHRcdCAgXG5cdFx0XHRcblx0XHR9KTtcblxuXHRcdC8qXG5cdFx0dGhpcy5hZGRDb21tYW5kKHtcblx0XHRcdGlkOiBcInJlbW92ZS1maXJzdC10YWItZnJvbS1zZWxlY3RlZC1saW5lc1wiLFxuXHRcdFx0bmFtZTogXCJSZW1vdmUgZmlyc3QgdGFiIGZyb20gc2VsZWN0ZWQgbGluZXNcIixcblx0XHRcdGVkaXRvckNhbGxiYWNrOiAoZWRpdG9yOiBFZGl0b3IsIHZpZXc6IE1hcmtkb3duVmlldykgPT4ge1xuXHRcdFx0XHRjb25zdCBsaXN0U2VsZWN0aW9ucyA9IGVkaXRvci5saXN0U2VsZWN0aW9ucygpO1xuXHRcdFx0XHRsaXN0U2VsZWN0aW9ucy5mb3JFYWNoKGxpc3RTZWxlY3Rpb24gPT4ge1xuXHRcdFx0XHRcdGNvbnN0IGZyb21MaW5lTnVtID0gbGlzdFNlbGVjdGlvbi5oZWFkLmxpbmVcblx0XHRcdFx0XHRjb25zdCB0b0xpbmVOdW0gPSBsaXN0U2VsZWN0aW9uLmFuY2hvci5saW5lXG5cdFx0XHRcdFx0Zm9yIChsZXQgaSA9IGZyb21MaW5lTnVtOyBpIDw9IHRvTGluZU51bTsgaSsrKSB7XG5cdFx0XHRcdFx0XHRjb25zdCBsaW5lID0gZWRpdG9yLmdldExpbmUoaSlcblx0XHRcdFx0XHRcdGNvbnN0IG1vZGlmaWVkTGluZSA9IGxpbmUucmVwbGFjZSgvXFx0LywgJycpXG5cdFx0XHRcdFx0XHRlZGl0b3Iuc2V0TGluZShpLCBtb2RpZmllZExpbmUpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSlcblx0XHRcdH0sXG5cdFx0fSk7XG5cdFx0Ki9cblxuXHRcdHRoaXMuYWRkQ29tbWFuZCh7XG5cdFx0XHRpZDogXCJncmVwLXRpdGxlLWFzLWxpbmstdG8tY2xpcGJvYXJkXCIsXG5cdFx0XHRuYW1lOiBcIkdyZXAgVGl0bGUgYXMgbGluayB0byBjbGlwYm9hcmRcIixcblx0XHRcdGljb246IGBjbGlwYm9hcmQtbGlzdGAsXG5cdFx0XHRlZGl0b3JDYWxsYmFjazogYXN5bmMgKGVkaXRvcjogRWRpdG9yLCB2aWV3OiBNYXJrZG93blZpZXcpID0+IHtcblx0XHRcdFx0Y29uc3QgdGl0bGUgPSB2aWV3LmZpbGUuYmFzZW5hbWU7XG5cdFx0XHRcdGNvbnN0IHRpdGxlQXNMaW5rID0gYFtbJHt0aXRsZX1dXWA7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0dGhpcy5hZGRUb0NsaXBib2FyZEhpc3RvcnkodGl0bGVBc0xpbmspO1xuXHRcdFx0XHRcdGF3YWl0IG5hdmlnYXRvci5jbGlwYm9hcmQud3JpdGVUZXh0KHRpdGxlQXNMaW5rKTtcblx0XHRcdFx0XHRuZXcgTm90aWNlKGBDb3BpZWQgdGl0bGUgXCIke3RpdGxlfVwiIGFzIGxpbmsgdG8gY2xpcGJvYXJkIWApO1xuXHRcdFx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0XHRcdG5ldyBOb3RpY2UoYEVycm9yIG9jY3VycmVkIHdoZW4gY29weWluZyB0byBjbGlwYm9hcmQ6ICR7ZXJyb3J9YCk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRob3RrZXlzOiBbXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRtb2RpZmllcnM6IFtgTWV0YWAsIGBTaGlmdGBdLFxuXHRcdFx0XHRcdGtleTogYGxgLFxuXHRcdFx0XHR9LFxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bW9kaWZpZXJzOiBbYEN0cmxgLCBgU2hpZnRgXSxcblx0XHRcdFx0XHRrZXk6IGBsYCxcblx0XHRcdFx0fVxuXHRcdFx0XVxuXHRcdH0pO1xuXG5cdFx0dGhpcy5hZGRPYnNpZGlhbkljb24oJ21vdmUtY3VycmVudC1zZWxlY3Rpb24tdG8tYmVnaW5uaW5nLW9mLW5vdGVzJywgJzw8Jyk7XG5cdFx0dGhpcy5hZGRDb21tYW5kKHtcblx0XHRcdGlkOiBcIm1vdmUtY3VycmVudC1zZWxlY3Rpb24tdG8tYmVnaW5uaW5nLW9mLW5vdGVzXCIsXG5cdFx0XHRuYW1lOiBcIk1CIDw8IE1vdmUgY3VycmVudCBzZWxlY3Rpb24gdG8gYmVnaW5uaW5nIG9mIG5vdGVzXCIsXG5cdFx0XHRpY29uOiBgbW92ZS1jdXJyZW50LXNlbGVjdGlvbi10by1iZWdpbm5pbmctb2Ytbm90ZXNgLFxuXHRcdFx0ZWRpdG9yQ2FsbGJhY2s6IChlZGl0b3I6IEVkaXRvciwgdmlldzogTWFya2Rvd25WaWV3KSA9PiB7XG5cdFx0XHRcdGxldCBzZWxlY3Rpb24gPSBleHBvcnRDdXJyZW50U2VsZWN0aW9uKGVkaXRvcilcblx0XHRcdFx0aWYgKC9eICAgICstIC9tLnRlc3Qoc2VsZWN0aW9uKVxuXHRcdFx0XHQgIHx8IC9eLSAvbS50ZXN0KHNlbGVjdGlvbilcblx0XHRcdFx0ICB8fCAvXiMgL20udGVzdChzZWxlY3Rpb24pXG5cdFx0XHRcdCAgfHwgL15gIC9tLnRlc3Qoc2VsZWN0aW9uKVxuXHRcdFx0XHQgIHx8IC9ePiAvbS50ZXN0KHNlbGVjdGlvbilcblx0XHRcdFx0ICB8fCAvXlxcZCtcXC4gL20udGVzdChzZWxlY3Rpb24pXG5cdFx0XHRcdCAgKVxuXHRcdFx0XHR7XG5cdFx0XHRcdC8vIGRvIG5vdGhpbmdcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRzZWxlY3Rpb24gPSBcIi0gXCIgKyBzZWxlY3Rpb25cblx0XHRcdFx0fVxuXHRcdFx0XHRsZXQgbmV3Q29udGVudCA9ICcnXG5cdFx0XHRcdGNvbnN0IHNlbGVjdGlvblJhbmdlOiBTZWxlY3Rpb25SYW5nZSA9IGdldEN1cnJlbnRTZWxlY3Rpb25MaW5lTnVtYmVyKGVkaXRvcilcblx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBlZGl0b3IubGluZUNvdW50KCk7IGkrKykge1xuXHRcdFx0XHRcdGlmIChpIDwgc2VsZWN0aW9uUmFuZ2UuZnJvbUxpbmVOdW0gfHwgaSA+IHNlbGVjdGlvblJhbmdlLnRvTGluZU51bSkge1xuXHRcdFx0XHRcdFx0bmV3Q29udGVudCA9IG5ld0NvbnRlbnQgKyBlZGl0b3IuZ2V0TGluZShpKSArIFwiXFxuXCJcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHRcdG5ldyBBZGRUZXh0VG9Ob3Rlc01vZGFsKHRoaXMuYXBwLCBzZWxlY3Rpb24sIFwibW92ZSB0aGUgc2VsZWN0ZWQgdGV4dFwiLCB0cnVlLCAoKSA9PiBlZGl0b3Iuc2V0VmFsdWUobmV3Q29udGVudC5yZXBsYWNlKC9cXG4kL20sIFwiXCIpKSkub3BlbigpXG5cdFx0XHR9LFxuXHRcdFx0aG90a2V5czogW1xuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bW9kaWZpZXJzOiBbYEN0cmxgLCBgTWV0YWAsIGBTaGlmdGBdLFxuXHRcdFx0XHRcdGtleTogYCxgLFxuXHRcdFx0XHR9LFxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bW9kaWZpZXJzOiBbYEN0cmxgLCBgQWx0YCwgYFNoaWZ0YF0sXG5cdFx0XHRcdFx0a2V5OiBgLGAsXG5cdFx0XHRcdH0sXG5cdFx0XHRdXG5cdFx0fSlcblxuXHRcdHRoaXMuYWRkT2JzaWRpYW5JY29uKCdtb3ZlLWN1cnJlbnQtc2VsZWN0aW9uLXRvLWVuZC1vZi1ub3RlcycsICc+PicpO1xuXHRcdHRoaXMuYWRkQ29tbWFuZCh7XG5cdFx0XHRpZDogXCJtb3ZlLWN1cnJlbnQtc2VsZWN0aW9uLXRvLWVuZC1vZi1ub3Rlc1wiLFxuXHRcdFx0bmFtZTogXCJNRSA+PiBNb3ZlIGN1cnJlbnQgc2VsZWN0aW9uIHRvIGJlZ2lubmluZyBvZiBub3Rlc1wiLFxuXHRcdFx0aWNvbjogYG1vdmUtY3VycmVudC1zZWxlY3Rpb24tdG8tZW5kLW9mLW5vdGVzYCxcblx0XHRcdGVkaXRvckNhbGxiYWNrOiAoZWRpdG9yOiBFZGl0b3IsIHZpZXc6IE1hcmtkb3duVmlldykgPT4ge1xuXHRcdFx0XHRsZXQgc2VsZWN0aW9uID0gZXhwb3J0Q3VycmVudFNlbGVjdGlvbihlZGl0b3IpXG5cdFx0XHRcdGlmICgvXiAgICArLSAvbS50ZXN0KHNlbGVjdGlvbilcblx0XHRcdFx0ICB8fCAvXi0gL20udGVzdChzZWxlY3Rpb24pXG5cdFx0XHRcdCAgfHwgL14jIC9tLnRlc3Qoc2VsZWN0aW9uKVxuXHRcdFx0XHQgIHx8IC9eYCAvbS50ZXN0KHNlbGVjdGlvbilcblx0XHRcdFx0ICB8fCAvXj4gL20udGVzdChzZWxlY3Rpb24pXG5cdFx0XHRcdCAgfHwgL15cXGQrXFwuIC9tLnRlc3Qoc2VsZWN0aW9uKVxuXHRcdFx0XHQgIClcblx0XHRcdFx0e1xuXHRcdFx0XHQvLyBkbyBub3RoaW5nXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0c2VsZWN0aW9uID0gXCItIFwiICsgc2VsZWN0aW9uXG5cdFx0XHRcdH1cblx0XHRcdFx0bGV0IG5ld0NvbnRlbnQgPSAnJ1xuXHRcdFx0XHRjb25zdCBzZWxlY3Rpb25SYW5nZTogU2VsZWN0aW9uUmFuZ2UgPSBnZXRDdXJyZW50U2VsZWN0aW9uTGluZU51bWJlcihlZGl0b3IpXG5cdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgZWRpdG9yLmxpbmVDb3VudCgpOyBpKyspIHtcblx0XHRcdFx0XHRpZiAoaSA8IHNlbGVjdGlvblJhbmdlLmZyb21MaW5lTnVtIHx8IGkgPiBzZWxlY3Rpb25SYW5nZS50b0xpbmVOdW0pIHtcblx0XHRcdFx0XHRcdG5ld0NvbnRlbnQgPSBuZXdDb250ZW50ICsgZWRpdG9yLmdldExpbmUoaSkgKyBcIlxcblwiXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0XHRuZXcgQWRkVGV4dFRvTm90ZXNNb2RhbCh0aGlzLmFwcCwgc2VsZWN0aW9uLCBcIm1vdmUgdGhlIHNlbGVjdGVkIHRleHRcIiwgZmFsc2UsICgpID0+IGVkaXRvci5zZXRWYWx1ZShuZXdDb250ZW50LnJlcGxhY2UoL1xcbiQvbSwgXCJcIikpKS5vcGVuKClcblx0XHRcdH0sXG5cdFx0XHRob3RrZXlzOiBbXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRtb2RpZmllcnM6IFtgQ3RybGAsIGBNZXRhYCwgYFNoaWZ0YF0sXG5cdFx0XHRcdFx0a2V5OiBgLmAsXG5cdFx0XHRcdH0sXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRtb2RpZmllcnM6IFtgQ3RybGAsIGBBbHRgLCBgU2hpZnRgXSxcblx0XHRcdFx0XHRrZXk6IGAuYCxcblx0XHRcdFx0fSxcblx0XHRcdF1cblx0XHR9KVxuXG5cdFx0dGhpcy5hZGRPYnNpZGlhbkljb24oJ2FkZC1jdXJyZW50LXNlbGVjdGlvbi10by1iZWdpbm5pbmctb2Ytbm90ZXMnLCAnKCgnKTtcblx0XHR0aGlzLmFkZENvbW1hbmQoe1xuXHRcdFx0aWQ6IFwiYWRkLWN1cnJlbnQtc2VsZWN0aW9uLXRvLWJlZ2lubmluZy1vZi1ub3Rlc1wiLFxuXHRcdFx0bmFtZTogXCJTQiAoKCBBZGQgY3VycmVudCBzZWxlY3Rpb24gdG8gYmVnaW5uaW5nIG9mIG5vdGVzXCIsXG5cdFx0XHRpY29uOiBgYWRkLWN1cnJlbnQtc2VsZWN0aW9uLXRvLWJlZ2lubmluZy1vZi1ub3Rlc2AsXG5cdFx0XHRlZGl0b3JDYWxsYmFjazogKGVkaXRvcjogRWRpdG9yLCB2aWV3OiBNYXJrZG93blZpZXcpID0+IHtcblx0XHRcdFx0bGV0IHNlbGVjdGlvbiA9IGV4cG9ydEN1cnJlbnRTZWxlY3Rpb24oZWRpdG9yKVxuXHRcdFx0XHRpZiAoL14gICAgKy0gL20udGVzdChzZWxlY3Rpb24pXG5cdFx0XHRcdCAgfHwgL14tIC9tLnRlc3Qoc2VsZWN0aW9uKVxuXHRcdFx0XHQgIHx8IC9eIyAvbS50ZXN0KHNlbGVjdGlvbilcblx0XHRcdFx0ICB8fCAvXmAgL20udGVzdChzZWxlY3Rpb24pXG5cdFx0XHRcdCAgfHwgL14+IC9tLnRlc3Qoc2VsZWN0aW9uKVxuXHRcdFx0XHQgIHx8IC9eXFxkK1xcLiAvbS50ZXN0KHNlbGVjdGlvbilcblx0XHRcdFx0ICApIHtcblx0XHRcdFx0XHQvLyBkbyBub3RoaW5nXG5cdFx0XHRcdCAgfSBlbHNlIHtcblx0XHRcdFx0XHRzZWxlY3Rpb24gPSBcIi0gXCIgKyBzZWxlY3Rpb25cblx0XHRcdFx0ICB9XG5cdFx0XHRcdG5ldyBBZGRUZXh0VG9Ob3Rlc01vZGFsKHRoaXMuYXBwLCBzZWxlY3Rpb24sIFwiYWRkIHRoZSBzZWxlY3RlZCB0ZXh0XCIsIHRydWUsICgpID0+IHt9KS5vcGVuKClcblx0XHRcdH0sXG5cdFx0XHRob3RrZXlzOiBbXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRtb2RpZmllcnM6IFtgQ3RybGAsIGBNZXRhYCwgYFNoaWZ0YF0sXG5cdFx0XHRcdFx0a2V5OiBgOWAsXG5cdFx0XHRcdH0sXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRtb2RpZmllcnM6IFtgQ3RybGAsIGBBbHRgLCBgU2hpZnRgXSxcblx0XHRcdFx0XHRrZXk6IGA5YCxcblx0XHRcdFx0fSxcblx0XHRcdF1cblx0XHR9KVxuXG5cdFx0dGhpcy5hZGRPYnNpZGlhbkljb24oJ2FkZC1jdXJyZW50LXNlbGVjdGlvbi10by1lbmQtb2Ytbm90ZXMnLCAnKSknKTtcblx0XHR0aGlzLmFkZENvbW1hbmQoe1xuXHRcdFx0aWQ6IFwiYWRkLWN1cnJlbnQtc2VsZWN0aW9uLXRvLWVuZC1vZi1ub3Rlc1wiLFxuXHRcdFx0bmFtZTogXCJTRSApKSBBZGQgY3VycmVudCBzZWxlY3Rpb24gdG8gZW5kIG9mIG5vdGVzXCIsXG5cdFx0XHRpY29uOiBgYWRkLWN1cnJlbnQtc2VsZWN0aW9uLXRvLWVuZC1vZi1ub3Rlc2AsXG5cdFx0XHRlZGl0b3JDYWxsYmFjazogKGVkaXRvcjogRWRpdG9yLCB2aWV3OiBNYXJrZG93blZpZXcpID0+IHtcblx0XHRcdFx0bGV0IHNlbGVjdGlvbiA9IGV4cG9ydEN1cnJlbnRTZWxlY3Rpb24oZWRpdG9yKVxuXHRcdFx0XHRpZiAoL14gICAgKy0gL20udGVzdChzZWxlY3Rpb24pXG5cdFx0XHRcdCAgfHwgL14tIC9tLnRlc3Qoc2VsZWN0aW9uKVxuXHRcdFx0XHQgIHx8IC9eIyAvbS50ZXN0KHNlbGVjdGlvbilcblx0XHRcdFx0ICB8fCAvXmAgL20udGVzdChzZWxlY3Rpb24pXG5cdFx0XHRcdCAgfHwgL14+IC9tLnRlc3Qoc2VsZWN0aW9uKVxuXHRcdFx0XHQgIHx8IC9eXFxkK1xcLiAvbS50ZXN0KHNlbGVjdGlvbilcblx0XHRcdFx0ICApIHtcblx0XHRcdFx0XHQvLyBkbyBub3RoaW5nXG5cdFx0XHRcdCAgfSBlbHNlIHtcblx0XHRcdFx0XHRzZWxlY3Rpb24gPSBcIi0gXCIgKyBzZWxlY3Rpb25cblx0XHRcdFx0ICB9XG5cdFx0XHRcdG5ldyBBZGRUZXh0VG9Ob3Rlc01vZGFsKHRoaXMuYXBwLCBzZWxlY3Rpb24sIFwiYWRkIHRoZSBzZWxlY3RlZCB0ZXh0XCIsIGZhbHNlLCAoKSA9PiB7fSkub3BlbigpXG5cdFx0XHR9LFxuXHRcdFx0aG90a2V5czogW1xuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bW9kaWZpZXJzOiBbYEN0cmxgLCBgTWV0YWAsIGBTaGlmdGBdLFxuXHRcdFx0XHRcdGtleTogYDBgLFxuXHRcdFx0XHR9LFxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bW9kaWZpZXJzOiBbYEN0cmxgLCBgQWx0YCwgYFNoaWZ0YF0sXG5cdFx0XHRcdFx0a2V5OiBgMGAsXG5cdFx0XHRcdH0sXG5cdFx0XHRdXG5cdFx0fSlcblxuXHRcdHRoaXMuYWRkT2JzaWRpYW5JY29uKCdhZGQtY3VycmVudC1saW5rLXRvLWJlZ2lubmluZy1vZi1ub3RlcycsICdbWycpO1xuXHRcdHRoaXMuYWRkQ29tbWFuZCh7XG5cdFx0XHRpZDogXCJhZGQtY3VycmVudC1saW5rLXRvLWJlZ2lubmluZy1vZi1ub3Rlc1wiLFxuXHRcdFx0bmFtZTogXCJMQiBbWyBBZGQgY3VycmVudCBsaW5rIHRvIGJlZ2lubmluZyBvZiBub3Rlc1wiLFxuXHRcdFx0aWNvbjogYGFkZC1jdXJyZW50LWxpbmstdG8tYmVnaW5uaW5nLW9mLW5vdGVzYCxcblx0XHRcdGVkaXRvckNhbGxiYWNrOiAoZWRpdG9yOiBFZGl0b3IsIHZpZXc6IE1hcmtkb3duVmlldykgPT4ge1xuXHRcdFx0XHRjb25zdCBsaW5rID0gXCItIFtbXCIgKyB2aWV3LmZpbGUuYmFzZW5hbWUgKyBcIl1dXCI7XG5cdFx0XHRcdG5ldyBBZGRUZXh0VG9Ob3Rlc01vZGFsKHRoaXMuYXBwLCBsaW5rLCBcImFkZCB0aGUgY3VycmVudCBub3RlIGxpbmtcIiwgdHJ1ZSwgKCkgPT4ge30pLm9wZW4oKVxuXHRcdFx0fSxcblx0XHRcdGhvdGtleXM6IFtcblx0XHRcdFx0e1xuXHRcdFx0XHRcdG1vZGlmaWVyczogW2BDdHJsYCwgYE1ldGFgLCBgU2hpZnRgXSxcblx0XHRcdFx0XHRrZXk6IGBbYCxcblx0XHRcdFx0fSxcblx0XHRcdFx0e1xuXHRcdFx0XHRcdG1vZGlmaWVyczogW2BDdHJsYCwgYEFsdGAsIGBTaGlmdGBdLFxuXHRcdFx0XHRcdGtleTogYFtgLFxuXHRcdFx0XHR9LFxuXHRcdFx0XVxuXHRcdH0pXG5cblx0XHR0aGlzLmFkZE9ic2lkaWFuSWNvbignYWRkLWN1cnJlbnQtbGluay10by1lbmQtb2Ytbm90ZXMnLCAnXV0nKTtcblx0XHR0aGlzLmFkZENvbW1hbmQoe1xuXHRcdFx0aWQ6IFwiYWRkLWN1cnJlbnQtbGluay10by1lbmQtb2Ytbm90ZXNcIixcblx0XHRcdG5hbWU6IFwiTEUgXV0gQWRkIGN1cnJlbnQgbGluayB0byBlbmQtb2Ytbm90ZXNcIixcblx0XHRcdGljb246IGBhZGQtY3VycmVudC1saW5rLXRvLWVuZC1vZi1ub3Rlc2AsXG5cdFx0XHRlZGl0b3JDYWxsYmFjazogKGVkaXRvcjogRWRpdG9yLCB2aWV3OiBNYXJrZG93blZpZXcpID0+IHtcblx0XHRcdFx0Y29uc3QgbGluayA9IFwiLSBbW1wiICsgdmlldy5maWxlLmJhc2VuYW1lICsgXCJdXVwiO1xuXHRcdFx0XHRuZXcgQWRkVGV4dFRvTm90ZXNNb2RhbCh0aGlzLmFwcCwgbGluaywgXCJhZGQgdGhlIGN1cnJlbnQgbm90ZSBsaW5rXCIsIGZhbHNlLCAoKSA9PiB7fSkub3BlbigpXG5cdFx0XHR9LFxuXHRcdFx0aG90a2V5czogW1xuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bW9kaWZpZXJzOiBbYEN0cmxgLCBgTWV0YWAsIGBTaGlmdGBdLFxuXHRcdFx0XHRcdGtleTogYF1gLFxuXHRcdFx0XHR9LFxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bW9kaWZpZXJzOiBbYEN0cmxgLCBgQWx0YCwgYFNoaWZ0YF0sXG5cdFx0XHRcdFx0a2V5OiBgXWAsXG5cdFx0XHRcdH0sXG5cdFx0XHRdXG5cdFx0fSlcblxuXHRcdHRoaXMuYWRkQ29tbWFuZCh7XG5cdFx0XHRpZDogXCJxdWljay1uYXZpZ2F0ZS10by1ub3Rlc1wiLFxuXHRcdFx0bmFtZTogXCJOTiBRdWljayBOYXZpZ2F0ZSB0byBOb3Rlc1wiLFxuXHRcdFx0aWNvbjogYGFwZXJ0dXJlYCxcblx0XHRcdGNhbGxiYWNrOiBhc3luYyAoKSA9PiB7XG5cdFx0XHRcdG5ldyBOYXZpZ2F0ZVRvTm90ZUZyb21UYWdNb2RhbCh0aGlzLmFwcCkub3BlbigpXG5cdFx0XHR9LFxuXHRcdFx0aG90a2V5czogW1xuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bW9kaWZpZXJzOiBbYEN0cmxgLCBgTWV0YWAsIGBTaGlmdGBdLFxuXHRcdFx0XHRcdGtleTogYDtgLFxuXHRcdFx0XHR9LFxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bW9kaWZpZXJzOiBbYEN0cmxgLCBgQWx0YCwgYFNoaWZ0YF0sXG5cdFx0XHRcdFx0a2V5OiBgO2AsXG5cdFx0XHRcdH0sXG5cdFx0XHRdXG5cdFx0fSlcblxuXHRcdHRoaXMuYWRkT2JzaWRpYW5JY29uKCd0aHJlYWRzLXRvLXR3aXR0ZXInLCAnVFgnKTtcblx0XHR0aGlzLmFkZENvbW1hbmQoe1xuXHRcdFx0aWQ6IFwidGhyZWFkcy10by10d2l0dGVyXCIsXG5cdFx0XHRuYW1lOiBcIlRUIFRYIFRocmVhZHMgdG8gVHdpdHRlclwiLFxuXHRcdFx0aWNvbjogYHRocmVhZHMtdG8tdHdpdHRlcmAsXG5cdFx0XHRlZGl0b3JDYWxsYmFjazogKGVkaXRvcjogRWRpdG9yLCB2aWV3OiBNYXJrZG93blZpZXcpID0+IHtcblx0XHRcdFx0Y29uc3QgeyB2YXVsdCB9ID0gdGhpcy5hcHA7XG5cdFx0XHRcdGNvbnN0IHYgPSBlZGl0b3IuZ2V0VmFsdWUoKVxuXHRcdFx0XHRjb25zdCBwYXRoID0gdmlldy5maWxlLnBhdGhcblx0XHRcdFx0aWYgKCFwYXRoLm1hdGNoKC8uXFwvVGhyZWFkcyBcXGRcXGRcXGRcXGRcXGRcXGRcXGRcXGQvKSkge1xuXHRcdFx0XHRcdG5ldyBOb3RpY2UoYFdpbGwgbm90IHByb2NlZWQuIEl0IGlzIG5vdCBhIHRocmVhZHMgcG9zdC5gKTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0Y29uc3QgbmV3UGF0aCA9IHBhdGgucmVwbGFjZSgvKC5cXC8pVGhyZWFkcyAvLCBcIiQxVHdpdHRlciBcIilcblxuXHRcdFx0XHRjb25zdCB7IHdvcmtzcGFjZSB9ID0gdGhpcy5hcHA7XG5cdFx0XHRcdGNvbnN0IGxlYWYgPSB3b3Jrc3BhY2UuZ2V0TGVhZihmYWxzZSk7XG5cdFx0XHRcdFByb21pc2UucmVzb2x2ZSgpXG5cdFx0XHRcdC50aGVuKCgpID0+IHtcblx0XHRcdFx0XHRyZXR1cm4gdmF1bHQuYWRhcHRlci5leGlzdHMobmV3UGF0aCk7XG5cdFx0XHRcdH0pXG5cdFx0XHRcdC50aGVuKChmaWxlRXhpc3RzKSA9PiB7XG5cdFx0XHRcdFx0aWYgKGZpbGVFeGlzdHMpIHtcblx0XHRcdFx0XHRcdG5ldyBOb3RpY2UoYFdpbGwgbm90IHByb2NlZWQuIFR3aXR0ZXIgcG9zdCBhbHJlYWR5IGV4aXN0LmApO1xuXHRcdFx0XHRcdFx0cmV0dXJuIFByb21pc2UucmVqZWN0KFwiVHdpdHRlciBwb3N0IGFscmVhZHkgZXhpc3RcIilcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHZhdWx0LmNyZWF0ZShuZXdQYXRoLCB2KTtcblx0XHRcdFx0fSlcblx0XHRcdFx0LnRoZW4oKHRGaWxlKSA9PiB7XG5cdFx0XHRcdFx0cmV0dXJuIGxlYWYub3BlbkZpbGUodEZpbGUsIHsgYWN0aXZlIDogdHJ1ZX0pO1xuXHRcdFx0XHR9LCByZWFzb24gPT4ge30pXG5cdFx0XHRcdC50aGVuKCgpID0+IHtcblx0XHRcdFx0XHRuZXcgTm90aWNlKGBDcmVhdGVkIGFuZCBvcGVuZWQgVHdpdHRlciBub3RlcyFgKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fSlcblxuXHRcdHRoaXMuYWRkT2JzaWRpYW5JY29uKCdibG9nLXRvLWNsaXBib2FyZC1pY29uJywgJ0JKJyk7XG5cdFx0dGhpcy5hZGRDb21tYW5kKHtcblx0XHRcdGlkOiBcImJsb2ctdG8tY2xpcGJvYXJkXCIsXG5cdFx0XHRuYW1lOiBcIkJKIEJsb2cgY29udGVudCB0byBjbGlwYm9hcmRcIixcblx0XHRcdGljb246IGBibG9nLXRvLWNsaXBib2FyZC1pY29uYCxcblx0XHRcdGVkaXRvckNhbGxiYWNrOiBhc3luYyAoZWRpdG9yOiBFZGl0b3IsIHZpZXc6IE1hcmtkb3duVmlldykgPT4ge1xuXHRcdFx0XHRjb25zdCB2ID0gZWRpdG9yLmdldFZhbHVlKCk7XG5cdFx0XHRcdGlmICh2LmluY2x1ZGVzKFwiI25uXCIpIHx8IHYuaW5jbHVkZXMoXCIjbmxcIikgfHwgdi5pbmNsdWRlcyhcIiNud1wiKSB8fCB2LmluY2x1ZGVzKFwiI3duXCIpIHx8IHYuaW5jbHVkZXMoXCIjd2xcIikgfHwgdi5pbmNsdWRlcyhcIiN3d1wiKSkge1xuXHRcdFx0XHRcdG5ldyBOb3RpY2UoYFdpbGwgbm90IHByb2NlZWQuIEFzIHRoZXJlIGFyZSB1bmZpbmlzaGVkIGFjdGlvbiB0YWcuYCk7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICghdi5pbmNsdWRlcyhcIjwhLS1tb3JlLS0+XCIpKSB7XG5cdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdGF3YWl0IG5hdmlnYXRvci5jbGlwYm9hcmQud3JpdGVUZXh0KFwiPCEtLW1vcmUtLT5cIik7XG5cdFx0XHRcdFx0XHRuZXcgTm90aWNlKGBSZXF1aXJlIFwiPCEtLW1vcmUtLT5cIiBhcyBleGNlcnB0IHNlcGFyYXRvciBiZWZvcmUgcG9zdGluZy5cXG5cIjwhLS1tb3JlLS0+XCIgYWxyZWFkeSBpbiBjbGlwYm9hcmRgKTtcblx0XHRcdFx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0XHRcdFx0bmV3IE5vdGljZShgUmVxdWlyZSBcIjwhLS1tb3JlLS0+XCIgYXMgZXhjZXJwdCBzZXBhcmF0b3IgYmVmb3JlIHBvc3RpbmcuXFxuXCI8IS0tbW9yZS0tPlwiIGNhbm5vdCBiZSBjb3BpZWQgdG8gY2xpcGJvYXJkYCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNvbnN0IHBhdGggPSB2aWV3LmZpbGUucGF0aDtcblx0XHRcdFx0bGV0IGxpbmUgPSBlZGl0b3IubGluZUNvdW50KCk7XG5cdFx0XHRcdGxldCB0ZXh0ID0gXCJcIjtcblx0XHRcdFx0bGV0IG51bUxpbmVGaXJzdENvbnRlbnQgPSAwO1xuXHRcdFx0XHRsZXQgZnJvbnRNYXR0ZXJMaW5lQ291bnQgPSAwO1xuXHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGxpbmU7IGkrKykge1xuXHRcdFx0XHRcdGlmIChmcm9udE1hdHRlckxpbmVDb3VudCA9PSAyKSB7XG5cdFx0XHRcdFx0XHRudW1MaW5lRmlyc3RDb250ZW50ID0gaTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoZWRpdG9yLmdldExpbmUoaSkgPT0gXCItLS1cIikge1xuXHRcdFx0XHRcdFx0ZnJvbnRNYXR0ZXJMaW5lQ291bnQrKztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lOyBpKyspIHtcblx0XHRcdFx0XHRpZiAoZWRpdG9yLmdldExpbmUobnVtTGluZUZpcnN0Q29udGVudCkudHJpbSgpID09IFwiXCIpIHtcblx0XHRcdFx0XHRcdG51bUxpbmVGaXJzdENvbnRlbnQrKztcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0QXJyYXkuZnJvbShBcnJheShsaW5lIC0gbnVtTGluZUZpcnN0Q29udGVudCkua2V5cygpKS5mb3JFYWNoKGkgPT4ge1xuXHRcdFx0XHRcdGNvbnN0IGxpbmUgPSBlZGl0b3IuZ2V0TGluZShpICsgbnVtTGluZUZpcnN0Q29udGVudCk7XG5cdFx0XHRcdFx0dGV4dCA9IHRleHQgKyBsaW5lICsgXCJcXG5cIjtcblx0XHRcdFx0fSk7XG5cdFx0XHRcdHRleHQgPSB0ZXh0LnJlcGxhY2UoL1xcbi0tLVxcblxcbiNuZCBnZW5lcmF0ZSBzdW1tYXJ5IGZvciBtZXRhIGRlc2NyaXB0aW9uIGJlbG93OlxcblteXFxuXSpcXG4oW15cXG5dKilcXG5bXlxcbl0qXFxuLS0tXFxuLywgXCJcXG48IS0tIE1ldGEgU3VtbWFyeSAtLT5cXG48IS0tXFxuJDFcXG4tLT5cXG5cIik7XG5cdFx0XHRcdHRleHQgPSB0ZXh0LnJlcGxhY2UoLyMjIFJlZmVyZW5jZXNcXDooW1xcbl0qLiopKiQvLCBcIlwiKTtcblxuXHRcdFx0XHRjb25zdCBhcHAgPSB0aGlzLmFwcDtcblx0XHRcdFx0Y29uc3QgYmVmb3JlVGFnQ0JSID0gXCJjL2IvclwiO1xuXHRcdFx0XHRjb25zdCBiZWZvcmVUYWdDQkQgPSBcImMvYi9kXCI7XG5cdFx0XHRcdGNvbnN0IGJlZm9yZVRhZ0NCSSA9IFwiYy9iL2lcIjtcblx0XHRcdFx0Y29uc3QgYWZ0ZXJUYWcgPSBcImMvYi9wXCI7XG5cblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRhd2FpdCBuYXZpZ2F0b3IuY2xpcGJvYXJkLndyaXRlVGV4dCh0ZXh0KTtcblx0XHRcdFx0XHRuZXcgTm90aWNlKGBDb3BpZWQgYmxvZyBjb250ZW50IHRvIGNsaXBib2FyZCFgKTtcblx0XHRcdFx0XHRjb25zdCBmb3VuZFRhZ0Zyb21DQlIgPSBhd2FpdCByZW5hbWVUYWcodmlldy5maWxlLCBiZWZvcmVUYWdDQlIsIGFmdGVyVGFnKTtcblx0XHRcdFx0XHRpZiAoZm91bmRUYWdGcm9tQ0JSKSB7XG5cdFx0XHRcdFx0XHRuZXcgTm90aWNlKGBVcGRhdGUgbm90ZXMgdHlwZSBmcm9tIHRhZz1cIiR7YmVmb3JlVGFnQ0JSfVwiIHRvIHRhZz1cIiR7YWZ0ZXJUYWd9IWApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjb25zdCBmb3VuZFRhZ0Zyb21DQkkgPSBhd2FpdCByZW5hbWVUYWcodmlldy5maWxlLCBiZWZvcmVUYWdDQkksIGFmdGVyVGFnKTtcblx0XHRcdFx0XHRpZiAoZm91bmRUYWdGcm9tQ0JJKSB7XG5cdFx0XHRcdFx0XHRuZXcgTm90aWNlKGBVcGRhdGUgbm90ZXMgdHlwZSBmcm9tIHRhZz1cIiR7Zm91bmRUYWdGcm9tQ0JJfVwiIHRvIHRhZz1cIiR7YWZ0ZXJUYWd9IWApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjb25zdCBmb3VuZFRhZ0Zyb21DQkQgPSBhd2FpdCByZW5hbWVUYWcodmlldy5maWxlLCBiZWZvcmVUYWdDQkQsIGFmdGVyVGFnKTtcblx0XHRcdFx0XHRpZiAoZm91bmRUYWdGcm9tQ0JEKSB7XG5cdFx0XHRcdFx0XHRuZXcgTm90aWNlKGBVcGRhdGUgbm90ZXMgdHlwZSBmcm9tIHRhZz1cIiR7YmVmb3JlVGFnQ0JEfVwiIHRvIHRhZz1cIiR7YWZ0ZXJUYWd9IWApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRhd2FpdCByZW5hbWVCbG9nVGl0bGUoYXBwLCBwYXRoLCB2aWV3KTtcblx0XHRcdFx0XHR3aW5kb3cub3Blbihgc2hvcnRjdXRzOi8vcnVuLXNob3J0Y3V0P25hbWU9SmVreWxsJTIwYmxvZyZ4LWNhbmNlbD1vYnNpZGlhbjovLyZ4LWVycm9yPW9ic2lkaWFuOi8vYCk7XG5cdFx0XHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRcdFx0bmV3IE5vdGljZShgRXJyb3Igb2NjdXJyZWQgZHVyaW5nIHRoZSBvcGVyYXRpb246ICR7ZXJyb3J9YCk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0fSk7XG5cblx0XHR0aGlzLmFkZE9ic2lkaWFuSWNvbignZ2VuZXJhdGUtY2hhdGdwdC1wcm9tcHQnLCAnR1AnKTtcblx0XHR0aGlzLmFkZENvbW1hbmQoe1xuXHRcdFx0aWQ6IFwiZ2VuZXJhdGUtY2hhdGdwdC1wcm9tcHRcIixcblx0XHRcdG5hbWU6IFwiR1AgR2VuZXJhdGUgQ2hhdEdQVCBQcm9tcHRcIixcblx0XHRcdGljb246IGBnZW5lcmF0ZS1jaGF0Z3B0LXByb21wdGAsXG5cdFx0XHRlZGl0b3JDYWxsYmFjazogYXN5bmMgKGVkaXRvcjogRWRpdG9yLCB2aWV3OiBNYXJrZG93blZpZXcpID0+IHtcblx0XHRcdFx0bGV0IGxpbmUgPSBlZGl0b3IubGluZUNvdW50KCk7XG5cblx0XHRcdFx0bGV0IHRleHQgPSBcIlx1MzAxMFwiICsgdmlldy5maWxlLmJhc2VuYW1lICsgXCJcdTMwMTFcXG5cXG5cIjtcblx0XHRcdFx0bGV0IG51bUxpbmVGaXJzdENvbnRlbnQgPSAwXG5cdFx0XHRcdGxldCBmcm9udE1hdHRlckxpbmVDb3VudCA9IDBcblx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lOyBpKyspIHtcblx0XHRcdFx0XHRpZiAoZnJvbnRNYXR0ZXJMaW5lQ291bnQgPT0gMikge1xuXHRcdFx0XHRcdFx0bnVtTGluZUZpcnN0Q29udGVudCA9IGk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKGVkaXRvci5nZXRMaW5lKGkpID09IFwiLS0tXCIpIHtcblx0XHRcdFx0XHRcdGZyb250TWF0dGVyTGluZUNvdW50Kytcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lOyBpKyspIHtcblx0XHRcdFx0XHRpZiAoZWRpdG9yLmdldExpbmUobnVtTGluZUZpcnN0Q29udGVudCkudHJpbSgpID09IFwiXCIpIHtcblx0XHRcdFx0XHRcdG51bUxpbmVGaXJzdENvbnRlbnQrKztcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0QXJyYXkuZnJvbShBcnJheShsaW5lIC0gbnVtTGluZUZpcnN0Q29udGVudCkua2V5cygpKS5mb3JFYWNoKGkgPT4ge1xuXHRcdFx0XHRcdGNvbnN0IGxpbmUgPSBlZGl0b3IuZ2V0TGluZShpICsgbnVtTGluZUZpcnN0Q29udGVudCk7XG5cdFx0XHRcdFx0aWYgKCFsaW5lLnN0YXJ0c1dpdGgoXCIlJVwiKSAmJiAhbGluZS5lbmRzV2l0aChcIiUlXCIpKSB7XG5cdFx0XHRcdFx0XHR0ZXh0ID0gdGV4dCArIGxpbmUgKyBcIlxcblwiXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdFx0XG5cdFx0XHRcdHRleHQgPSB0ZXh0LnJlcGxhY2UoLyMjIFJlZmVyZW5jZXNcXDooW1xcbl0qLiopKiQvLCBcIlwiKVxuXHRcdFx0XHRcblx0XHRcdFx0bmF2aWdhdG9yLmNsaXBib2FyZC53cml0ZVRleHQodGV4dCkudGhlbihmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0bmV3IE5vdGljZShgQ29waWVkIGNvbnRlbnQgdG8gY2xpcGJvYXJkIGZvciBnZW5lcmF0aW5nIHByb21wdCFgKTtcblx0XHRcdFx0XHR3aW5kb3cub3Blbihgc2hvcnRjdXRzOi8vcnVuLXNob3J0Y3V0P25hbWU9R2VuZXJhdGUlMjBDaGF0R1BUJTIwUHJvbXB0Jngtc3VjY2Vzcz1vYnNpZGlhbjovLyZ4LWNhbmNlbD1vYnNpZGlhbjovLyZ4LWVycm9yPW9ic2lkaWFuOi8vYCk7XG5cdFx0XHRcdH0sIGZ1bmN0aW9uIChlcnJvcikge1xuXHRcdFx0XHRcdG5ldyBOb3RpY2UoYGVycm9yIHdoZW4gY29weSB0byBjbGlwYm9hcmQhYCk7ICAgXG5cdFx0XHRcdH0pOyAgIFxuXHRcdFx0fSwgICBcblx0XHR9KTsgICBcbiAgIFxuXHRcdHRoaXMuYWRkT2JzaWRpYW5JY29uKCd0aHJlYWRzLXRvLWNsaXBib2FyZC1pY29uJywgJ1RDJyk7ICAgXG5cdFx0dGhpcy5hZGRDb21tYW5kKHsgICBcblx0XHRcdGlkOiBcInRocmVhZHMtdG8tY2xpcGJvYXJkXCIsICAgXG5cdFx0XHRuYW1lOiBcIlRDIFRocmVhZHMgY29udGVudCB0byBjbGlwYm9hcmRcIiwgICBcblx0XHRcdGljb246IGB0aHJlYWRzLXRvLWNsaXBib2FyZC1pY29uYCxcblx0XHRcdGVkaXRvckNhbGxiYWNrOiAoZWRpdG9yOiBFZGl0b3IsIHZpZXc6IE1hcmtkb3duVmlldykgPT4geyAgIFxuXHRcdFx0XHRjb25zdCB2YWx1ZSA9IGVkaXRvci5nZXRWYWx1ZSgpXG5cdFx0XHRcdC8vaWYgKCF2YWx1ZS5jb250YWlucyhcIiUlICN0bSB0byB6ayAlJVwiKSAmJiAhdmFsdWUuY29udGFpbnMoXCIlJSAjbmQgdG8gemsgJSVcIikpIHtcblx0XHRcdFx0Ly9cdHRoaXMuYWRkVGFza1RvUHV0SW50b0NhcmRJblRocmVhZHNDb250ZW50KGVkaXRvcilcblx0XHRcdFx0Ly99XG5cdFx0XHRcdC8vIGNvbnN0IHRleHQgPSB0aGlzLmNvbnZlcnRUaHJlYWRzQ29udGVudFRvRm9ybWF0Rm9yVGhyZWFkc0FwcChlZGl0b3IpXG5cdFx0XHRcdGNvbnN0IHRleHQgPSB0aGlzLmdldFRocmVhZHNTZWdtZW50KGVkaXRvcilcblx0XHRcdFx0Y29uc3QgYmVmb3JlVGFnID0gXCJjL3QvclwiXG5cdFx0XHRcdGNvbnN0IGFmdGVyVGFnID0gXCJjL3QvdFwiXG5cdFx0XHRcblx0XHRcdFx0bmF2aWdhdG9yLmNsaXBib2FyZC53cml0ZVRleHQodGV4dClcblx0XHRcdFx0LnRoZW4oZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdHJldHVybiByZW5hbWVUYWcodmlldy5maWxlLCBiZWZvcmVUYWcsIGFmdGVyVGFnKVxuXHRcdFx0XHR9LCBmdW5jdGlvbiAoZXJyb3IpIHtcblx0XHRcdFx0XHRuZXcgTm90aWNlKGBlcnJvciB3aGVuIGNvcHkgdG8gY2xpcGJvYXJkIWApO1xuXHRcdFx0XHR9KVxuXHRcdFx0XHQudGhlbigoZm91bmRUYWcpID0+IHtcblx0XHRcdFx0XHRpZiAoZm91bmRUYWcpIHtcblx0XHRcdFx0XHRcdG5ldyBOb3RpY2UoYFVwZGF0ZSBub3RlcyB0eXBlIGZyb20gdGFnPVwiJHtiZWZvcmVUYWd9XCIgdG8gdGFnPVwiJHthZnRlclRhZ30hXFxuQ29waWVkIHRocmVhZCBjb250ZW50IHRvIGNsaXBib2FyZCFgKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0bmV3IE5vdGljZShgVGFnIFwiJHtiZWZvcmVUYWd9XCIgbm90IGZvdW5kXFxuQ29waWVkIHRocmVhZCBjb250ZW50IHRvIGNsaXBib2FyZCFgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSxcblx0XHR9KTtcblxuXHRcdHRoaXMuYWRkT2JzaWRpYW5JY29uKCd0d2l0dGVyLXRvLWNoYXRncHQnLCAnWEcnKTtcblx0XHR0aGlzLmFkZENvbW1hbmQoe1xuXHRcdFx0aWQ6IFwidHdpdHRlci10by1jaGF0Z3B0XCIsXG5cdFx0XHRuYW1lOiBcIlhHIFR3aXR0ZXIgdG8gQ2hhdEdQVFwiLFxuXHRcdFx0aWNvbjogYHR3aXR0ZXItdG8tY2hhdGdwdGAsXG5cdFx0XHRlZGl0b3JDYWxsYmFjazogKGVkaXRvcjogRWRpdG9yLCB2aWV3OiBNYXJrZG93blZpZXcpID0+IHtcblx0XHRcdFx0Y29uc3QgdmFsdWUgPSBlZGl0b3IuZ2V0VmFsdWUoKVxuXG5cdFx0XHRcdGlmICghdmlldy5maWxlLmJhc2VuYW1lLmNvbnRhaW5zKFwiVHdpdHRlclwiKSkge1xuXHRcdFx0XHRcdG5ldyBOb3RpY2UoXCJOb3RlIG5hbWUgbm90IGNvbnRhaW5zICdUd2l0dGVyJywgZGlkIG5vdCBjb3B5IGZyb20gdGhyZWFkIG5vdGU/XCIpXG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0XHRsZXQgY29udGVudCA9IHRoaXMuY29udmVydFRocmVhZHNDb250ZW50VG9QT0UoZWRpdG9yKVxuXHRcdFx0XHRsZXQgbnVtVHdlZXQgPSBNYXRoLmNlaWwoY29udGVudC5sZW5ndGggLyAxMTApXG5cdFx0XHRcdGxldCBwcm9tcHQgPSBgXHU2MEE4XHU2NjJGXHU3OTNFXHU0RUE0XHU1QTkyXHU5QUQ0XHU1MTY3XHU1QkI5XHU2NEIwXHU1QkVCXHU1RTJCXHUzMDAyXHU1QzA3XHU0RTBCXHU1MjE3XHU1MTY3XHU1QkI5XHU4RjQ5XHU3MEJBXHU0RTBEXHU4RDg1XHU5MDRFJHtudW1Ud2VldH1cdTY4OURcdTc2ODRcdTYzQThcdTcyNzlcdTRFMzJcdUZGMENcdTRFRTVcdTdFNDFcdTlBRDRcdTRFMkRcdTY1ODdcdTU0NDhcdTczRkVcdTMwMDJcdTRGRERcdTc1NTlcdTZBMTlcdTk4NENcdUZGMENcdTRFMjZcdTVDMDdcdTZBMTlcdTk4NENcdTU0MDhcdTRGNzVcdTUyMzBcdTdCMkNcdTRFMDBcdTY4OURcdTYzQThcdTY1ODdcdTRFMkRcdUZGMENcdTZBMTlcdTk4NENcdTU0OENcdTdCMkNcdTRFMDBcdTY4OURcdTYzQThcdTY1ODdcdTRFNEJcdTk1OTNcdTUyQTBcdTUxNjlcdTUwMEJcdTYzREJcdTg4NENcdTMwMDJcdTZCQ0ZcdTY4OURcdTYzQThcdTY1ODdcdTg5ODFcdThEODVcdTkwNEUxMDBcdTVCNTdcdTRGNDZcdTRFMERcdThEODVcdTkwNEUxNDBcdTVCNTdcdTMwMDJcdTUxNjdcdTVCQjlcdTRFMERcdTdDMjFcdTUzMTZcdUZGMENcdTRFMERcdTY1QjBcdTU4OUVcdTY3MkFcdTYzRDBcdTUzQ0FcdThDQzdcdThBMEFcdTMwMDJcdTRGRERcdTc1NTlcdTUzOUZcdTY1ODdcdTRGOEJcdTVCNTBcdUZGMENcdTRFMERcdTUyQTBcdTZBMTlcdTdDNjRcdTMwMDJcdTYzQThcdTY1ODdcdTRFMkRcdTRFMERcdTUyQTBcdTY1NzhcdTVCNTdcdTMwMDJcdTZCQ0ZcdTY4OURcdTYzQThcdTY1ODdcdTVGOENcdTUyQTBcdTUxNjlcdTUwMEJcdTYzREJcdTg4NENcdTUzQ0FcdTRFMDlcdTUwMEJcdTc3RURcdTUyODNcdTdEREFcdTU0OENcdTUzRTZcdTRFMDBcdTUwMEJcdTYzREJcdTg4NENcdTMwMDJcdTgyRjFcdTY1ODdcdTU0OENcdTRFMkRcdTY1ODdcdTRFNEJcdTk1OTNcdTUyQTBcdTdBN0FcdTY4M0NcdTMwMDJcdTgyRTVcdTUzOUZcdTY1ODdcdTY3MDlcdTdEQjJcdTU3NDBcdUZGMENcdTRGRERcdTc1NTlcdTdEQjJcdTU3NDBcdUZGMENcdTRFMERcdTc1MjhNYXJrZG93blx1NjgzQ1x1NUYwRlx1RkYwQ1x1NEUyNlx1NTcyOFx1N0RCMlx1NTc0MFx1NTI0RFx1NTJBMFx1NTE2OVx1NTAwQlx1NjNEQlx1ODg0Q1x1MzAwMmBcblxuXHRcdFx0XHQvL2xldCBwcm9tcHQgPSBgWW91IGFyZSBhIHNvY2lhbCBtZWRpYSBjb250ZW50IGNvcHl3cml0ZXIuIENvbnZlcnQgdGhlIGZvbGxvd2luZyBjb250ZW50IHRvIHR3aXR0ZXIgdGhyZWFkcyBsZXNzIHRoYW4gJHtudW1Ud2VldH0gdHdlZXQgaW4gdHJhZGl0aW9uYWwgQ2hpbmVzZS4gUHJlc2VydmUgdGhlIHRpdGxlLiBNZXJnZSB0aXRsZSB3aXRoIHRoZSBmaXJzdCB0d2VldCB3aGlsZSBhZGQgMiBuZXdsaW5lIGNoYXJhY3RlcnMgYmV0d2VlbiB0aXRsZSBhbmQgZmlyc3QgdHdlZXQuIEV2ZXJ5IHR3ZWV0IGhhcyB0byBvdmVyIDEwMCBidXQgbGVzcyB0aGFuIDE0MCBDaGluZXNlIGNoYXJhY3RlcnMuIERvIG5vdCBzaW1wbGlmeSB0aGUgY29udGVudC4gRG8gbm90IGFkZCBhbnkgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiB3aGljaCBpcyBub3QgbWVudGlvbmVkIGZyb20gdGhlIG9yaWdpbmFsIGNvbnRlbnQuIFByZXNlcnZlIHRoZSBleGFtcGxlIGZyb20gdGhlIGNvbnRlbnQuIE5vIG5lZWQgdG8gYWRkIGFueSB0YWdzIHRvIHRoZSB0d2VldC4gRG8gbm90IGhhdmUgYW55IG51bWJlciBpbiBlYWNoIHR3ZWV0LiBFYWNoIHR3ZWV0IHNlcGFyYXRlZCBieSAyIG5ld2xpbmUgYW5kIDMgXCItXCIgY2hhcmFjdGVycyBhbmQgYW5vdGhlciBuZXdsaW5lLiBBZGQgYSBzcGFjZSBjaGFyYWN0ZXIgYmV0d2VlbiBlYWNoIEVuZ2xpc2ggY2hhcmFjdGVyIGFuZCBDaGluZXNlIGNoYXJhY3Rlci4gSWYgdGhlIG9yaWdpbmFsIGNvbnRlbnQgY29udGFpbnMgYW55IFVSTCwgcHJlc2VydmUgdGhlIFVSTCBpbiB0aGUgdHdlZXQgd2l0aG91dCB1c2luZyBhbnkgTWFya2Rvd24gZm9ybWF0IGZvciB0aGUgVVJMIHdoaWxlIGFkZCAyIG5ld2xpbmUgY2hhcmFjdGVyIGJlZm9yZSB0aGUgVVJMLmBcblxuXHRcdFx0XHQvL2xldCBwcm9tcHQgPSBgQ29udmVydCB0aGUgZm9sbG93aW5nIGNvbnRlbnQgdG8gdHdpdHRlciB0aHJlYWRzIGxlc3MgdGhhbiAke251bVR3ZWV0fSB0d2VldCBpbiB0cmFkaXRpb25hbCBDaGluZXNlLiBQcmVzZXJ2ZSB0aGUgdGl0bGUuIERvIG5vdCBhZGQgYW55IGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gd2hpY2ggaXMgbm90IG1lbnRpb25lZCBmcm9tIHRoZSBvcmlnaW5hbCBjb250ZW50LiBObyBuZWVkIHRvIGFkZCBhbnkgdGFncyB0byB0aGUgdHdlZXQuIERvIG5vdCBoYXZlIGFueSBudW1iZXIgaW4gZWFjaCB0d2VldC4gRWFjaCB0d2VldCBzZXBhcmF0ZWQgYnkgbmV3bGluZSBjaGFyYWN0ZXIgYW5kIDMgXCItXCIgY2hhcmFjdGVycyBhbmQgYW5vdGhlciBuZXdsaW5lIGNoYXJhY3Rlci5gXG5cdFx0XHRcdHByb21wdCA9IHByb21wdCArIFwiXFxuXFxuXCIgKyBjb250ZW50XG5cdFx0XHRcdHByb21wdCA9IHByb21wdC5yZXBsYWNlKC9cdTI1OEQvZywgXCJcIilcblx0XHRcdFx0cHJvbXB0ID0gcHJvbXB0LnJlcGxhY2UoL1x1MzAxMVxcbitodHRwc1xcOlxcL1xcL2dpdGh1Yi5jb21bXlxcbl0rXFxuL20sIFwiXHUzMDExXFxuXCIpXG5cdFx0XHRcdHByb21wdCA9IHByb21wdC5yZXBsYWNlKC9cXCpcXCovZ20sIFwiXCIpXG5cdFx0XHRcdC8vcHJvbXB0ID0gcHJvbXB0LnJlcGxhY2UoLyFcXFtcXFMqXFxdXFwoKChodHRwczp8aHR0cDp8d3d3XFwuKVxcUyopXFwpL2dtLCBcIiQxXCIpXG5cblx0XHRcdFx0bmF2aWdhdG9yLmNsaXBib2FyZC53cml0ZVRleHQocHJvbXB0KS50aGVuKGZ1bmN0aW9uICgpIHtcblxuXHRcdFx0XHRcdGxldCBsaW5lID0gZWRpdG9yLmxpbmVDb3VudCgpO1xuXG5cdFx0XHRcdFx0bGV0IG51bUxpbmVGaXJzdENvbnRlbnQgPSAwXG5cdFx0XHRcdFx0bGV0IGZyb250TWF0dGVyTGluZUNvdW50ID0gMFxuXHRcdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbGluZTsgaSsrKSB7XG5cdFx0XHRcdFx0XHRpZiAoZnJvbnRNYXR0ZXJMaW5lQ291bnQgPT0gMikge1xuXHRcdFx0XHRcdFx0XHRudW1MaW5lRmlyc3RDb250ZW50ID0gaTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAoZWRpdG9yLmdldExpbmUoaSkgPT0gXCItLS1cIikge1xuXHRcdFx0XHRcdFx0XHRmcm9udE1hdHRlckxpbmVDb3VudCsrXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbGluZTsgaSsrKSB7XG5cdFx0XHRcdFx0XHRpZiAoZWRpdG9yLmdldExpbmUobnVtTGluZUZpcnN0Q29udGVudCkudHJpbSgpID09IFwiXCIpIHtcblx0XHRcdFx0XHRcdFx0bnVtTGluZUZpcnN0Q29udGVudCsrO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0bGV0IHRleHQgPSBcIlwiO1xuXHRcdFx0XHRcdEFycmF5LmZyb20oQXJyYXkobnVtTGluZUZpcnN0Q29udGVudCkua2V5cygpKS5mb3JFYWNoKGkgPT4ge1xuXHRcdFx0XHRcdFx0Y29uc3QgbGluZSA9IGVkaXRvci5nZXRMaW5lKGkpO1xuXHRcdFx0XHRcdFx0dGV4dCA9IHRleHQgKyBsaW5lICsgXCJcXG5cIlxuXHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0ZWRpdG9yLnNldFZhbHVlKHRleHQpXG5cblx0XHRcdFx0XHRyZW5hbWVUYWcodmlldy5maWxlLCBcImMvdC9kXCIsIFwiYy94L2RcIilcblx0XHRcdFx0XHRyZW5hbWVUYWcodmlldy5maWxlLCBcImMvdC9yXCIsIFwiYy94L2RcIilcblx0XHRcdFx0XHRyZW5hbWVUYWcodmlldy5maWxlLCBcImMvdC90XCIsIFwiYy94L2RcIilcblx0XHRcdFx0XHRyZW5hbWVUYWcodmlldy5maWxlLCBcImMvdC9wXCIsIFwiYy94L2RcIilcblxuXHRcdFx0XHRcdGNvbnN0IGN1cnNvciA9IGVkaXRvci5nZXRDdXJzb3IoKVxuXHRcdFx0XHRcdGN1cnNvci5saW5lID0gZWRpdG9yLmxpbmVDb3VudCgpIC0gMVxuXHRcdFx0XHRcdGN1cnNvci5jaCA9IDBcblx0XHRcdFx0XHRlZGl0b3Iuc2V0Q3Vyc29yKGN1cnNvcilcblxuXHRcdFx0XHRcdG5ldyBOb3RpY2UoXCJjb3BpZWQgdG8gY2xpcGJvYXJkLCBwbGVhc2Ugb3BlbiBjaGF0Z3B0IHRvIHBhc3RlXCIpXG5cdFx0XHRcdH0sIGZ1bmN0aW9uIChlcnJvcikge1xuXHRcdFx0XHRcdG5ldyBOb3RpY2UoYGVycm9yIHdoZW4gY29weSB0byBjbGlwYm9hcmQhYCk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSxcblx0XHR9KTtcblxuXHRcdHRoaXMuYWRkT2JzaWRpYW5JY29uKCdjaGF0Z3B0LXRvLXR3aXR0ZXInLCAnR1gnKTtcblx0XHR0aGlzLmFkZENvbW1hbmQoe1xuXHRcdFx0aWQ6IFwiY2hhdGdwdC10by10d2l0dGVyXCIsXG5cdFx0XHRuYW1lOiBcIkdYIENoYXRHUFQgdG8gVHdpdHRlclwiLFxuXHRcdFx0aWNvbjogYGNoYXRncHQtdG8tdHdpdHRlcmAsXG5cdFx0XHRlZGl0b3JDYWxsYmFjazogKGVkaXRvcjogRWRpdG9yLCB2aWV3OiBNYXJrZG93blZpZXcpID0+IHtcblx0XHRcdFx0aWYgKCFlZGl0b3IuZ2V0VmFsdWUoKS5jb250YWlucyhcImMveC9kXCIpKSB7XG5cdFx0XHRcdFx0bmV3IE5vdGljZShcIk5vdGUgdHlwZSBub3QgYy94L2QsIGRvIHRoZSBhY3Rpb24gaW4gd3Jvbmcgbm90ZT9cIilcblx0XHRcdFx0XHRyZXR1cm5cblx0XHRcdFx0fVxuXHRcdFx0XHRjb25zdCBpc1N1Y2Nlc3MgPSB0aGlzLmNvbnZlcnRDaGF0R1BUVG9Ud2l0dGVyRm9ybWF0KGVkaXRvcilcblx0XHRcdFx0aWYgKGlzU3VjY2Vzcylcblx0XHRcdFx0e1xuXHRcdFx0XHRcdHJlbmFtZVRhZyh2aWV3LmZpbGUsIFwiYy94L2RcIiwgXCJjL3gvclwiKVxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdH0pO1xuXG5cdFx0dGhpcy5hZGRPYnNpZGlhbkljb24oJ3JldmVyc2UtdHdpdHRlci1udW1iZXItaWNvbicsICdSVCcpO1xuXHRcdHRoaXMuYWRkQ29tbWFuZCh7XG5cdFx0XHRpZDogXCJyZXZlcnNlLXR3aXR0ZXItbnVtYmVyaW5nXCIsXG5cdFx0XHRuYW1lOiBcIlJUIFJldmVyc2UgVHdpdHRlciBOdW1iZXJpbmdcIixcblx0XHRcdGljb246IGByZXZlcnNlLXR3aXR0ZXItbnVtYmVyLWljb25gLFxuXHRcdFx0ZWRpdG9yQ2FsbGJhY2s6IChlZGl0b3I6IEVkaXRvciwgdmlldzogTWFya2Rvd25WaWV3KSA9PiB7XG5cdFx0XHRcdGlmICghZWRpdG9yLmdldFZhbHVlKCkuY29udGFpbnMoXCJjL3gvclwiKSAmJiAhZWRpdG9yLmdldFZhbHVlKCkuY29udGFpbnMoXCJjL3gvcFwiKSkge1xuXHRcdFx0XHRcdG5ldyBOb3RpY2UoXCJOb3RlIHR5cGUgbm90IGMveC9yIG5vciBjL3gvcCwgZG8gdGhlIGFjdGlvbiBpbiB3cm9uZyBub3RlP1wiKVxuXHRcdFx0XHRcdHJldHVyblxuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMucmV2ZXJzZVR3aXR0ZXJOdW1iZXJpbmcoZWRpdG9yKVxuXHRcdFx0XHRyZW5hbWVUYWcodmlldy5maWxlLCBcImMveC9wXCIsIFwiYy94L2RcIilcblx0XHRcdFx0cmVuYW1lVGFnKHZpZXcuZmlsZSwgXCJjL3gvclwiLCBcImMveC9kXCIpXG5cdFx0XHR9LFxuXHRcdH0pO1xuXG5cdFx0dGhpcy5hZGRPYnNpZGlhbkljb24oJ3RocmVhZHMtYXMtZmFjZWJvb2stcG9zdC10by1jbGlwYm9hcmQtaWNvbicsICdGQycpO1xuXHRcdHRoaXMuYWRkQ29tbWFuZCh7XG5cdFx0XHRpZDogXCJ0aHJlYWRzLWFzLWZhY2Vib29rLXBvc3QtdG8tY2xpcGJvYXJkXCIsXG5cdFx0XHRuYW1lOiBcIkZDIFRocmVhZHMgYXMgRmFjZWJvb2sgcG9zdCBmb3JtYXQgdG8gQ2xpcGJvYXJkXCIsXG5cdFx0XHRpY29uOiBgdGhyZWFkcy1hcy1mYWNlYm9vay1wb3N0LXRvLWNsaXBib2FyZC1pY29uYCxcblx0XHRcdGVkaXRvckNhbGxiYWNrOiAoZWRpdG9yOiBFZGl0b3IsIHZpZXc6IE1hcmtkb3duVmlldykgPT4ge1xuXHRcdFx0XHRjb25zdCB2YWx1ZSA9IGVkaXRvci5nZXRWYWx1ZSgpXG5cdFx0XHRcdC8vaWYgKCF2YWx1ZS5jb250YWlucyhcIiUlICNubSB0byB6ayAlJVwiKSAmJiAhdmFsdWUuY29udGFpbnMoXCIlJSAjbmQgdG8gemsgJSVcIikpIHtcblx0XHRcdFx0Ly9cdHRoaXMuYWRkVGFza1RvUHV0SW50b0NhcmRJblRocmVhZHNDb250ZW50KGVkaXRvcilcblx0XHRcdFx0Ly99XG5cdFx0XHRcdGNvbnN0IHRleHQgPSB0aGlzLmNvbnZlcnRUaHJlYWRzQ29udGVudFRvRm9ybWF0Rm9yRmFjZWJvb2tBcHAoZWRpdG9yKVxuXHRcdFx0XG5cdFx0XHRcdGNvbnN0IGJlZm9yZVRhZyA9IFwiYy90L3RcIlxuXHRcdFx0XHRjb25zdCBhZnRlclRhZyA9IFwiYy90L3BcIlxuXHRcdFx0XG5cdFx0XHRcdG5hdmlnYXRvci5jbGlwYm9hcmQud3JpdGVUZXh0KHRleHQpXG5cdFx0XHRcdC50aGVuKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRyZXR1cm4gcmVuYW1lVGFnKHZpZXcuZmlsZSwgYmVmb3JlVGFnLCBhZnRlclRhZylcblx0XHRcdFx0fSwgZnVuY3Rpb24gKGVycm9yKSB7XG5cdFx0XHRcdFx0bmV3IE5vdGljZShgZXJyb3Igd2hlbiBjb3B5IHRvIGNsaXBib2FyZCFgKTtcblx0XHRcdFx0fSlcblx0XHRcdFx0LnRoZW4oKGZvdW5kVGFnKSA9PiB7XG5cdFx0XHRcdFx0aWYgKGZvdW5kVGFnKSB7XG5cdFx0XHRcdFx0XHRuZXcgTm90aWNlKGBVcGRhdGUgbm90ZXMgdHlwZSBmcm9tIHRhZz1cIiR7YmVmb3JlVGFnfVwiIHRvIHRhZz1cIiR7YWZ0ZXJUYWd9IVxcbkNvcGllZCBmYiBjb250ZW50IHRvIGNsaXBib2FyZCFgKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0bmV3IE5vdGljZShgVGFnIFwiJHtiZWZvcmVUYWd9XCIgbm90IGZvdW5kXFxuQ29waWVkIGZiIGNvbnRlbnQgdG8gY2xpcGJvYXJkIWApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHR9LFxuXHRcdH0pO1xuXG5cdFx0dGhpcy5hZGRPYnNpZGlhbkljb24oJ3RocmVhZHMtYmxvY2stdG8taW1hZ2UnLCAnVEknKTtcblx0XHR0aGlzLmFkZENvbW1hbmQoe1xuXHRcdFx0aWQ6IFwidGhyZWFkcy1ibG9jay10by1pbWFnZVwiLFxuXHRcdFx0bmFtZTogXCJUSSBUaHJlYWRzIHNlZ21lbnQgdG8gaW1hZ2VcIixcblx0XHRcdGljb246IGB0aHJlYWRzLWJsb2NrLXRvLWltYWdlYCxcblx0XHRcdGVkaXRvckNhbGxiYWNrOiAoZWRpdG9yOiBFZGl0b3IsIHZpZXc6IE1hcmtkb3duVmlldykgPT4ge1xuXHRcdFx0XHRjb25zdCB0aHJlYWRTZWdtZW50ID0gdGhpcy5nZXRUaHJlYWRTZWdtZW50KGVkaXRvcilcblx0XHRcdFx0bmV3IFRocmVhZHNUb0ltYWdlc01vZGFsKHRoaXMuYXBwLCB0aHJlYWRTZWdtZW50KS5vcGVuKClcblx0XHRcdH0sXG5cdFx0fSk7XG5cblx0XHR0aGlzLmFkZE9ic2lkaWFuSWNvbignY2hhdGdwdC1nZW5lcmF0ZS1pbWFnZScsICdHSScpO1xuXHRcdHRoaXMuYWRkQ29tbWFuZCh7XG5cdFx0XHRpZDogXCJjaGF0Z3B0LWdlbmVyYXRlLWltYWdlXCIsXG5cdFx0XHRuYW1lOiBcIkdJIENoYXRHUFQgaW1hZ2VcIixcblx0XHRcdGljb246IGBjaGF0Z3B0LWdlbmVyYXRlLWltYWdlYCxcblx0XHRcdGVkaXRvckNhbGxiYWNrOiAoZWRpdG9yOiBFZGl0b3IsIHZpZXc6IE1hcmtkb3duVmlldykgPT4ge1xuXHRcdFx0XHR3aW5kb3cub3Blbignc2hvcnRjdXRzOi8vcnVuLXNob3J0Y3V0P25hbWU9Q2hhdEdQVCUyMEdlbmVyYXRlJTIwSW1hZ2UmeC1zdWNjZXNzPW9ic2lkaWFuOi8vJngtY2FuY2VsPW9ic2lkaWFuOi8vJngtZXJyb3I9b2JzaWRpYW46Ly8nKTtcblx0XHRcdH0sXG5cdFx0fSk7XG5cblx0XHQvKlxuXHRcdHRoaXMuYWRkT2JzaWRpYW5JY29uKCd0aHJlYWRzLXNlZ21lbnQtdG8tY2xpcGJvYXJkJywgJ1NDJyk7XG5cdFx0dGhpcy5hZGRDb21tYW5kKHtcblx0XHRcdGlkOiBcInRocmVhZHMtc2VnbWVudC10by1jbGlwYm9hcmRcIixcblx0XHRcdG5hbWU6IFwiVGhyZWFkcyBzZWdtZW50IHRvIGNsaXBib2FyZFwiLFxuXHRcdFx0aWNvbjogYHRocmVhZHMtc2VnbWVudC10by1jbGlwYm9hcmRgLFxuXHRcdFx0ZWRpdG9yQ2FsbGJhY2s6IChlZGl0b3I6IEVkaXRvciwgdmlldzogTWFya2Rvd25WaWV3KSA9PiB7XG5cdFx0XHRcdGNvbnN0IHRocmVhZFNlZ21lbnQgPSB0aGlzLmdldFRocmVhZFNlZ21lbnQoZWRpdG9yKVxuXHRcdFx0XHRjb25zdCBiZWZvcmVUYWcgPSBcImMveC9yXCJcblx0XHRcdFx0Y29uc3QgYWZ0ZXJUYWcgPSBcImMveC9wXCJcblx0XHRcdFx0bmF2aWdhdG9yLmNsaXBib2FyZC53cml0ZVRleHQodGhyZWFkU2VnbWVudClcblx0XHRcdFx0LnRoZW4oZnVuY3Rpb24gKCkge1x0XG5cdFx0XHRcdFx0cmV0dXJuIHJlbmFtZVRhZyh2aWV3LmZpbGUsIGJlZm9yZVRhZywgYWZ0ZXJUYWcpXG5cdFx0XHRcdH0sIGZ1bmN0aW9uIChlcnJvcikge1xuXHRcdFx0XHRcdG5ldyBOb3RpY2UoYGVycm9yIHdoZW4gY29weSB0byBjbGlwYm9hcmQhYCk7XG5cdFx0XHRcdH0pXG5cdFx0XHRcdC50aGVuKChmb3VuZFRhZykgPT4ge1xuXHRcdFx0XHRcdGlmIChmb3VuZFRhZykge1xuXHRcdFx0XHRcdFx0bmV3IE5vdGljZShgVXBkYXRlIG5vdGVzIHR5cGUgZnJvbSB0YWc9XCIke2JlZm9yZVRhZ31cIiB0byB0YWc9XCIke2FmdGVyVGFnfSFcXG5Db3BpZWRcXG5cXGBcXGBcXGBcXG4ke3RocmVhZFNlZ21lbnR9XFxgXFxgXFxgXFxudG8gY2xpcGJvYXJkIWApO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRuZXcgTm90aWNlKGBUYWcgXCIke2JlZm9yZVRhZ31cIiBub3QgZm91bmRcXG5Db3BpZWRcXG5cXGBcXGBcXGBcXG4ke3RocmVhZFNlZ21lbnR9XFxgXFxgXFxgXFxudG8gY2xpcGJvYXJkIWApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHR9LFxuXHRcdH0pO1xuXHRcdCovXG5cblx0XHR0aGlzLmFkZE9ic2lkaWFuSWNvbigndHdpdHRlci1zZWdtZW50LXRvLWNsaXBib2FyZCcsICdYQycpO1xuXHRcdHRoaXMuYWRkQ29tbWFuZCh7XG5cdFx0XHRpZDogXCJ0d2l0dGVyLXNlZ21lbnQtdG8tY2xpcGJvYXJkXCIsXG5cdFx0XHRuYW1lOiBcIlhDIFR3aXR0ZXIgc2VnbWVudCB0byBjbGlwYm9hcmRcIixcblx0XHRcdGljb246IGB0d2l0dGVyLXNlZ21lbnQtdG8tY2xpcGJvYXJkYCxcblx0XHRcdGVkaXRvckNhbGxiYWNrOiAoZWRpdG9yOiBFZGl0b3IsIHZpZXc6IE1hcmtkb3duVmlldykgPT4ge1xuXHRcdFx0XHRjb25zdCB0aHJlYWRTZWdtZW50ID0gdGhpcy5nZXRUd2l0dGVyU2VnbWVudChlZGl0b3IpXG5cdFx0XHRcdGNvbnN0IGJlZm9yZVRhZyA9IFwiYy94L3JcIlxuXHRcdFx0XHRjb25zdCBhZnRlclRhZyA9IFwiYy94L3BcIlxuXHRcdFx0XHRuYXZpZ2F0b3IuY2xpcGJvYXJkLndyaXRlVGV4dCh0aHJlYWRTZWdtZW50KVxuXHRcdFx0XHQudGhlbihmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHJlbmFtZVRhZyh2aWV3LmZpbGUsIGJlZm9yZVRhZywgYWZ0ZXJUYWcpXG5cdFx0XHRcdH0sIGZ1bmN0aW9uIChlcnJvcikge1xuXHRcdFx0XHRcdG5ldyBOb3RpY2UoYGVycm9yIHdoZW4gY29weSB0byBjbGlwYm9hcmQhYCk7XG5cdFx0XHRcdH0pXG5cdFx0XHRcdC50aGVuKGZvdW5kVGFnID0+IHtcblx0XHRcdFx0XHRpZiAoZm91bmRUYWcpIHtcblx0XHRcdFx0XHRcdG5ldyBOb3RpY2UoYFVwZGF0ZSBub3RlcyB0eXBlIGZyb20gdGFnPVwiJHtiZWZvcmVUYWd9XCIgdG8gdGFnPVwiJHthZnRlclRhZ30hXFxuQ29waWVkXFxuXFxgXFxgXFxgXFxuJHt0aHJlYWRTZWdtZW50fVxcYFxcYFxcYFxcbnRvIGNsaXBib2FyZCFgKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0bmV3IE5vdGljZShgVGFnIFwiJHtiZWZvcmVUYWd9XCIgbm90IGZvdW5kXFxuQ29waWVkXFxuXFxgXFxgXFxgXFxuJHt0aHJlYWRTZWdtZW50fVxcYFxcYFxcYFxcbnRvIGNsaXBib2FyZCFgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSxcblx0XHR9KTtcblxuXHRcdHRoaXMuYWRkT2JzaWRpYW5JY29uKCdzZWdtZW50LXRvLWNsaXBib2FyZCcsICdTQycpO1xuXHRcdHRoaXMuYWRkQ29tbWFuZCh7XG5cdFx0XHRpZDogXCJzZWdtZW50LXRvLWNsaXBib2FyZFwiLFxuXHRcdFx0bmFtZTogXCJTQyBTZWdtZW50IHRvIGNsaXBib2FyZFwiLFxuXHRcdFx0aWNvbjogYHNlZ21lbnQtdG8tY2xpcGJvYXJkYCxcblx0XHRcdGVkaXRvckNhbGxiYWNrOiAoZWRpdG9yOiBFZGl0b3IsIHZpZXc6IE1hcmtkb3duVmlldykgPT4ge1xuXHRcdFx0XHRjb25zdCB0aHJlYWRTZWdtZW50ID0gdGhpcy5nZXRTZWdtZW50KGVkaXRvcilcblx0XHRcdFx0dGhpcy5hZGRUb0NsaXBib2FyZEhpc3RvcnkodGhyZWFkU2VnbWVudClcblx0XHRcdFx0bmF2aWdhdG9yLmNsaXBib2FyZC53cml0ZVRleHQodGhyZWFkU2VnbWVudClcblx0XHRcdFx0LnRoZW4oZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdG5ldyBOb3RpY2UoYENvcGllZFxcblxcYFxcYFxcYFxcbiR7dGhyZWFkU2VnbWVudH1cXGBcXGBcXGBcXG50byBjbGlwYm9hcmQhYCk7XG5cdFx0XHRcdH0sIGZ1bmN0aW9uIChlcnJvcikge1xuXHRcdFx0XHRcdG5ldyBOb3RpY2UoYGVycm9yIHdoZW4gY29weSB0byBjbGlwYm9hcmQhYCk7XG5cdFx0XHRcdH0pXG5cdFx0XHR9LFxuXHRcdH0pO1xuXG5cdFx0dGhpcy5hZGRDb21tYW5kKHtcblx0XHRcdGlkOiBcIm4tZmluZC1yZXBsYWNlXCIsXG5cdFx0XHRuYW1lOiBcIkZpbmQgb3IgUmVwbGFjZVwiLFxuXHRcdFx0aWNvbjogYGZpbGUtc2VhcmNoYCxcblx0XHRcdGVkaXRvckNhbGxiYWNrOiAoZWRpdG9yOiBFZGl0b3IsIHZpZXc6IE1hcmtkb3duVmlldykgPT4ge1xuXHRcdFx0XHRuZXcgRmluZFJlcGxhY2VNb2RhbCh0aGlzLmFwcCkub3BlbigpXG5cdFx0XHR9LFxuXHRcdH0pO1xuXG5cblx0XHQvKlxuXHRcdHRoaXMuYWRkT2JzaWRpYW5JY29uKCduLXByZXZpb3VzLXRhYicsICdUPCcpO1xuXHRcdHRoaXMuYWRkQ29tbWFuZCh7XG5cdFx0XHRpZDogXCJuLXByZXZpb3VzLXRhYlwiLFxuXHRcdFx0bmFtZTogXCJQcmV2aW91cyB0YWJcIixcblx0XHRcdGljb246IGBuLXByZXZpb3VzLXRhYmAsXG5cdFx0XHRlZGl0b3JDYWxsYmFjazogKGVkaXRvcjogRWRpdG9yLCB2aWV3OiBNYXJrZG93blZpZXcpID0+IHtcblx0XHRcdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1jYWxsXG5cdFx0XHRcdC8vY29uc29sZS5sb2codGhpcy5hcHAuY29tbWFuZHMuY29tbWFuZHMpXG5cdFx0XHRcdHRoaXMuYXBwLmNvbW1hbmRzLmV4ZWN1dGVDb21tYW5kQnlJZChcIndvcmtzcGFjZTpwcmV2aW91cy10YWJcIilcblx0XHRcdH0sXG5cdFx0fSk7XG5cblx0XHR0aGlzLmFkZE9ic2lkaWFuSWNvbignbi1uZXh0LXRhYicsICdUPicpO1xuXHRcdHRoaXMuYWRkQ29tbWFuZCh7XG5cdFx0XHRpZDogXCJuLW5leHQtdGFiXCIsXG5cdFx0XHRuYW1lOiBcIk5leHQgdGFiXCIsXG5cdFx0XHRpY29uOiBgbi1uZXh0LXRhYmAsXG5cdFx0XHRlZGl0b3JDYWxsYmFjazogKGVkaXRvcjogRWRpdG9yLCB2aWV3OiBNYXJrZG93blZpZXcpID0+IHtcblx0XHRcdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1jYWxsXG5cdFx0XHRcdC8vY29uc29sZS5sb2codGhpcy5hcHAuY29tbWFuZHMuY29tbWFuZHMpXG5cdFx0XHRcdHRoaXMuYXBwLmNvbW1hbmRzLmV4ZWN1dGVDb21tYW5kQnlJZChcIndvcmtzcGFjZTpuZXh0LXRhYlwiKVxuXHRcdFx0fSxcblx0XHR9KTtcblx0XHQqL1xuXG5cdFx0dGhpcy5hZGRDb21tYW5kKHtcblx0XHRcdGlkOiBcInRvZ2dsZS1idWxsZXQtbnVtYmVyLWxpc3RcIixcblx0XHRcdG5hbWU6IFwiVG9nZ2xlIEJ1bGxldCBOdW1iZXIgTGlzdFwiLFxuXHRcdFx0aWNvbjogYGJ1bGxldC1saXN0YCxcblx0XHRcdGVkaXRvckNhbGxiYWNrOiAoZWRpdG9yOiBFZGl0b3IsIHZpZXc6IE1hcmtkb3duVmlldykgPT4ge1xuXHRcdFx0XHRjb25zdCBjdXJzb3IgPSBlZGl0b3IuZ2V0Q3Vyc29yKClcblx0XHRcdFx0Y29uc3QgY2ggPSBjdXJzb3IuY2hcblx0XHRcdFx0Y29uc3QgbGluZSA9IGN1cnNvci5saW5lXG5cdFx0XHRcdGNvbnN0IGxpbmVDb250ZW50ID0gZWRpdG9yLmdldExpbmUobGluZSlcblx0XHRcdFx0Y29uc3QgcHJldmlvdXNMaW5lQ29udGVudCA9IGxpbmUgPT0gMCA/IFwiXCIgOiBlZGl0b3IuZ2V0TGluZShsaW5lIC0gMSlcblxuXHRcdFx0XHRpZiAoL14oPiApKlxccyotIC8udGVzdChsaW5lQ29udGVudCkpIHsgLy8gYnVsbGV0IGxpc3QgY2FzZVxuXHRcdFx0XHRcdC8vIHRvZ2dsZSB0byBudW1iZXIgbGlzdFxuXHRcdFx0XHRcdGxldCBuID0gXCIxLlwiXG5cdFx0XHRcdFx0Y29uc3QgYSA9IHByZXZpb3VzTGluZUNvbnRlbnQubWF0Y2goL15cXHQqKFxcZCspXFwuIC8pXG5cdFx0XHRcdFx0aWYgKGEpIHtcblx0XHRcdFx0XHRcdGNvbnN0IG5leHROID0gcGFyc2VJbnQoYVswXSkgKyAxXG5cdFx0XHRcdFx0XHRuID0gbmV4dE4udG9TdHJpbmcoKSArIFwiLlwiXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGNvbnN0IHJlcGxhY2VkTGluZUNvbnRlbnQgPSBsaW5lQ29udGVudC5yZXBsYWNlKC9eKCg+ICkqKShcXHMqKS0gLywgXCIkMSQzXCIgKyBuICsgXCIgXCIpXG5cdFx0XHRcdFx0ZWRpdG9yLnNldExpbmUobGluZSwgcmVwbGFjZWRMaW5lQ29udGVudClcblx0XHRcdFx0XHRjdXJzb3IuY2ggPSBjdXJzb3IuY2ggKyBuLmxlbmd0aCAtIDFcblx0XHRcdFx0XHRlZGl0b3Iuc2V0Q3Vyc29yKGN1cnNvcilcblx0XHRcdFx0fSBlbHNlIGlmICgvXig+ICkqXFxzKltcXGRdK1xcLiAvLnRlc3QobGluZUNvbnRlbnQpKSB7IC8vIG51bWJlciBsaXN0IGNhc2Vcblx0XHRcdFx0XHQvLyB0b2dnbGUgdG8gbm9uIGxpc3Rcblx0XHRcdFx0XHRjb25zdCBuID0gbGluZUNvbnRlbnQucmVwbGFjZSgvXigoPiApKikoXFxzKikoW1xcZF0rXFwuICkuKi8sIFwiJDRcIilcblx0XHRcdFx0XHRjb25zdCByZXBsYWNlZExpbmVDb250ZW50ID0gbGluZUNvbnRlbnQucmVwbGFjZSgvXigoPiApKikoXFxzKilbXFxkXStcXC4gLywgXCIkMSQzXCIpXG5cdFx0XHRcdFx0ZWRpdG9yLnNldExpbmUobGluZSwgcmVwbGFjZWRMaW5lQ29udGVudClcblx0XHRcdFx0XHRjdXJzb3IuY2ggPSAoY3Vyc29yLmNoIC0gbi5sZW5ndGgpID4gMCA/IChjdXJzb3IuY2ggLSBuLmxlbmd0aCkgOiAwXG5cdFx0XHRcdFx0ZWRpdG9yLnNldEN1cnNvcihjdXJzb3IpXG5cdFx0XHRcdH0gZWxzZSB7IC8vIG5vIGxpc3Rcblx0XHRcdFx0XHQvLyB0b2dnbGUgdG8gYnVsbGV0IGxpc3Rcblx0XHRcdFx0XHRjb25zdCByZXBsYWNlZExpbmVDb250ZW50ID0gbGluZUNvbnRlbnQucmVwbGFjZSgvXigoPiApKikoXFxzKikvLCBcIiQxJDMtIFwiKVxuXHRcdFx0XHRcdGVkaXRvci5zZXRMaW5lKGxpbmUsIHJlcGxhY2VkTGluZUNvbnRlbnQpXG5cdFx0XHRcdFx0Y3Vyc29yLmNoID0gY3Vyc29yLmNoICsgMlxuXHRcdFx0XHRcdGVkaXRvci5zZXRDdXJzb3IoY3Vyc29yKVxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0aG90a2V5czogW1xuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bW9kaWZpZXJzOiBbYEN0cmxgLCBgTWV0YWAsIGBTaGlmdGBdLFxuXHRcdFx0XHRcdGtleTogYC1gLFxuXHRcdFx0XHR9LFxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bW9kaWZpZXJzOiBbYEN0cmxgLCBgQWx0YCwgYFNoaWZ0YF0sXG5cdFx0XHRcdFx0a2V5OiBgLWAsXG5cdFx0XHRcdH0sXG5cdFx0XHRdXG5cdFx0fSk7XG5cblx0XHR0aGlzLmFkZENvbW1hbmQoe1xuXHRcdFx0aWQ6ICdjb3B5LW9yLW1vdmUtdG8tbmV3LW5vdGUnLFxuXHRcdFx0bmFtZTogJ0NvcHkgb3IgTW92ZSB0byBuZXcgbm90ZSBDTU4nLFxuXHRcdFx0aWNvbjogYGFpcnBsYXlgLFxuXHRcdFx0ZWRpdG9yQ2FsbGJhY2s6IGFzeW5jIChlZGl0b3I6IEVkaXRvciwgdmlldzogTWFya2Rvd25WaWV3KSA9PiB7XG5cdFx0XHRcdG5ldyBDb3B5T3JNb3ZlVG9OZXdOb3RlTW9kYWwodGhpcy5hcHAsIGVkaXRvcikub3BlbigpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0dGhpcy5hZGRDb21tYW5kKHtcblx0XHRcdGlkOiBcImVkaXRvci1jb3B5LWxpbmUtdG8tY2xpcGJvYXJkXCIsXG5cdFx0XHRuYW1lOiBcIkVkaXRvciBDb3B5IExpbmUgdG8gQ2xpcGJvYXJkXCIsXG5cdFx0XHRpY29uOiBgYWxpZ24tdmVydGljYWwtc3BhY2UtYXJvdW5kYCxcblx0XHRcdGVkaXRvckNhbGxiYWNrOiAoZWRpdG9yOiBFZGl0b3IsIHZpZXc6IE1hcmtkb3duVmlldykgPT4ge1xuXHRcdFx0XHRjb25zdCBzZWxlY3Rpb24gPSBleHBvcnRDdXJyZW50U2VsZWN0aW9uKGVkaXRvcik7XG5cdFx0XHRcdGNvbnN0IGNvcHlDb250ZW50ID0gc2VsZWN0aW9uLmNvbnRhaW5zKFwiXFxuXCIpXG5cdFx0XHRcdFx0XHRcdFx0XHQ/IHNlbGVjdGlvblxuXHRcdFx0XHRcdFx0XHRcdFx0OiBzZWxlY3Rpb24ucmVwbGFjZSgvXlxcdCotIC8sICcnKS5yZXBsYWNlKC9eXFx0KlxcZCtcXC4gLywgJycpXG5cdFx0XHRcdHRoaXMuYWRkVG9DbGlwYm9hcmRIaXN0b3J5KGNvcHlDb250ZW50KTtcblx0XHRcdFx0bmF2aWdhdG9yLmNsaXBib2FyZC53cml0ZVRleHQoY29weUNvbnRlbnQpLnRoZW4oZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdG5ldyBOb3RpY2UoYENvcGllZCBjb250ZW50XFxuXFxgXFxgXFxgXFxuJHtjb3B5Q29udGVudH1cXG5cXGBcXGBcXGBcXG50byBjbGlwYm9hcmQhYCk7XG5cdFx0XHRcdH0sIGZ1bmN0aW9uIChlcnJvcikge1xuXHRcdFx0XHRcdG5ldyBOb3RpY2UoYGVycm9yIHdoZW4gY29weSB0byBjbGlwYm9hcmQhYCk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSxcblx0XHRcdGhvdGtleXM6IFtcblx0XHRcdFx0e1xuXHRcdFx0XHRcdG1vZGlmaWVyczogW2BDdHJsYCwgYE1ldGFgLCBgU2hpZnRgXSxcblx0XHRcdFx0XHRrZXk6IFwiL1wiLFxuXHRcdFx0XHR9LFxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bW9kaWZpZXJzOiBbYEN0cmxgLCBgQWx0YCwgYFNoaWZ0YF0sXG5cdFx0XHRcdFx0a2V5OiBcIi9cIixcblx0XHRcdFx0fSxcblx0XHRcdF1cblx0XHR9KVxuXG5cdFx0dGhpcy5hZGRDb21tYW5kKHtcblx0XHRcdGlkOiBcImVkaXRvci1jdXQtbGluZS10by1jbGlwYm9hcmRcIixcblx0XHRcdG5hbWU6IFwiRWRpdG9yIEN1dCBMaW5lIHRvIENsaXBib2FyZFwiLFxuXHRcdFx0aWNvbjogYGFsaWduLXZlcnRpY2FsLWp1c3RpZnktY2VudGVyYCxcblx0XHRcdGVkaXRvckNhbGxiYWNrOiAoZWRpdG9yOiBFZGl0b3IsIHZpZXc6IE1hcmtkb3duVmlldykgPT4ge1xuXHRcdFx0XHRjb25zdCBzZWxlY3Rpb24gPSBleHBvcnRDdXJyZW50U2VsZWN0aW9uKGVkaXRvcik7XG5cdFx0XHRcdGNvbnN0IGN1cnNvciA9IGVkaXRvci5nZXRDdXJzb3IoKVxuXHRcdFx0XHRjb25zdCBjb3B5Q29udGVudCA9IHNlbGVjdGlvbi5jb250YWlucyhcIlxcblwiKVxuXHRcdFx0XHRcdFx0XHRcdFx0PyBzZWxlY3Rpb25cblx0XHRcdFx0XHRcdFx0XHRcdDogc2VsZWN0aW9uLnJlcGxhY2UoL15cXHQqLSAvLCAnJykucmVwbGFjZSgvXlxcdCpcXGQrXFwuIC8sICcnKVxuXHRcdFx0XHRsZXQgbmV3Q29udGVudCA9ICcnXG5cdFx0XHRcdGNvbnN0IHNlbGVjdGlvblJhbmdlOiBTZWxlY3Rpb25SYW5nZSA9IGdldEN1cnJlbnRTZWxlY3Rpb25MaW5lTnVtYmVyKGVkaXRvcilcblx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBlZGl0b3IubGluZUNvdW50KCk7IGkrKykge1xuXHRcdFx0XHRcdGlmIChpIDwgc2VsZWN0aW9uUmFuZ2UuZnJvbUxpbmVOdW0gfHwgaSA+IHNlbGVjdGlvblJhbmdlLnRvTGluZU51bSkge1xuXHRcdFx0XHRcdFx0bmV3Q29udGVudCA9IG5ld0NvbnRlbnQgKyBlZGl0b3IuZ2V0TGluZShpKSArIFwiXFxuXCJcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5hZGRUb0NsaXBib2FyZEhpc3RvcnkoY29weUNvbnRlbnQpO1xuXHRcdFx0XHRuYXZpZ2F0b3IuY2xpcGJvYXJkLndyaXRlVGV4dChjb3B5Q29udGVudCkudGhlbihmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0bmV3IE5vdGljZShgQ29waWVkIGNvbnRlbnRcXG5cXGBcXGBcXGBcXG4ke2NvcHlDb250ZW50fVxcblxcYFxcYFxcYFxcbnRvIGNsaXBib2FyZCFgKTtcblx0XHRcdFx0fSwgZnVuY3Rpb24gKGVycm9yKSB7XG5cdFx0XHRcdFx0bmV3IE5vdGljZShgZXJyb3Igd2hlbiBjb3B5IHRvIGNsaXBib2FyZCFgKTtcblx0XHRcdFx0fSk7XG5cdFx0XHRcdGVkaXRvci5zZXRWYWx1ZShuZXdDb250ZW50KVxuXHRcdFx0XHRjdXJzb3IubGluZSA9IHNlbGVjdGlvblJhbmdlLmZyb21MaW5lTnVtXG5cdFx0XHRcdGlmIChlZGl0b3IuZ2V0TGluZShzZWxlY3Rpb25SYW5nZS5mcm9tTGluZU51bSkubGVuZ3RoIDwgc2VsZWN0aW9uUmFuZ2UuZnJvbUNoKSB7XG5cdFx0XHRcdFx0Y3Vyc29yLmNoID0gZWRpdG9yLmdldExpbmUoc2VsZWN0aW9uUmFuZ2UuZnJvbUxpbmVOdW0pLmxlbmd0aFxuXHRcdFx0XHR9XG5cdFx0XHRcdGVkaXRvci5zZXRDdXJzb3IoY3Vyc29yKVxuXHRcdFx0fSxcblx0XHRcdGhvdGtleXM6IFtcblx0XHRcdFx0e1xuXHRcdFx0XHRcdG1vZGlmaWVyczogW2BDdHJsYCwgYE1ldGFgLCBgU2hpZnRgXSxcblx0XHRcdFx0XHRrZXk6IFwiXFxcXFwiLFxuXHRcdFx0XHR9LFxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bW9kaWZpZXJzOiBbYEN0cmxgLCBgQWx0YCwgYFNoaWZ0YF0sXG5cdFx0XHRcdFx0a2V5OiBcIlxcXFxcIixcblx0XHRcdFx0fSxcblx0XHRcdF1cblx0XHR9KVxuXG5cdFx0dGhpcy5hZGRDb21tYW5kKHtcblx0XHRcdGlkOiBcImVkaXRvci1pbmRlbnQtbGluZVwiLFxuXHRcdFx0bmFtZTogXCJFZGl0b3IgSW5kZW50IFNlbGVjdGlvblwiLFxuXHRcdFx0aWNvbjogYHJpZ2h0LWFycm93LXdpdGgtdGFpbGAsXG5cdFx0XHRlZGl0b3JDYWxsYmFjazogKGVkaXRvcjogRWRpdG9yLCB2aWV3OiBNYXJrZG93blZpZXcpID0+IHtcblx0XHRcdFx0Y29uc3QgbGlzdFNlbGVjdGlvbnMgOiBFZGl0b3JTZWxlY3Rpb25bXSA9IGVkaXRvci5saXN0U2VsZWN0aW9ucygpXG5cdFx0XHRcdGxpc3RTZWxlY3Rpb25zLmZvckVhY2gobGlzdFNlbGVjdGlvbiA9PiB7XG5cdFx0XHRcdFx0Y29uc3QgYSA9IGxpc3RTZWxlY3Rpb24uaGVhZC5saW5lXG5cdFx0XHRcdFx0Y29uc3QgYiA9IGxpc3RTZWxlY3Rpb24uYW5jaG9yLmxpbmVcblx0XHRcdFx0XHRjb25zdCBmcm9tTGluZU51bSA9IGIgPiBhID8gYSA6IGJcblx0XHRcdFx0XHRjb25zdCB0b0xpbmVOdW0gPSBiID4gYSA/IGIgOiBhXG5cdFx0XHRcdFx0Zm9yIChsZXQgaSA9IGZyb21MaW5lTnVtOyBpIDw9IHRvTGluZU51bTsgaSsrKSB7XG5cdFx0XHRcdFx0XHRjb25zdCBsaW5lID0gZWRpdG9yLmdldExpbmUoaSlcblx0XHRcdFx0XHRcdGVkaXRvci5zZXRMaW5lKGksIGxpbmUucmVwbGFjZSgvXi8sIFwiXFx0XCIpKVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSlcblx0XHRcdFx0bGV0IGxzcyA6IEVkaXRvclNlbGVjdGlvbltdID0gW11cblx0XHRcdFx0bGlzdFNlbGVjdGlvbnMuZm9yRWFjaChscyA9PiB7XG5cdFx0XHRcdFx0Y29uc3QgaGVhZCA9IGxzLmhlYWRcblx0XHRcdFx0XHRoZWFkLmNoID0gaGVhZC5jaCArIDFcblx0XHRcdFx0XHRjb25zdCBhbmNob3IgPSBscy5hbmNob3Jcblx0XHRcdFx0XHRhbmNob3IuY2ggPSBhbmNob3IuY2ggKyAxXG5cdFx0XHRcdFx0Y29uc3QgbmV3THM6IEVkaXRvclNlbGVjdGlvbiA9IHthbmNob3IsIGhlYWR9XG5cdFx0XHRcdFx0bHNzLnB1c2gobmV3THMpXG5cdFx0XHRcdH0pXG5cdFx0XHRcdGVkaXRvci5zZXRTZWxlY3Rpb25zKGxzcylcblx0XHRcdH1cblx0XHR9KVxuXG5cdFx0dGhpcy5hZGRDb21tYW5kKHtcblx0XHRcdGlkOiBcImVkaXRvci1vdXRkZW50LWxpbmVcIixcblx0XHRcdG5hbWU6IFwiRWRpdG9yIE91dGRlbnQgU2VsZWN0aW9uXCIsXG5cdFx0XHRpY29uOiBgbGVmdC1hcnJvdy13aXRoLXRhaWxgLFxuXHRcdFx0ZWRpdG9yQ2FsbGJhY2s6IChlZGl0b3I6IEVkaXRvciwgdmlldzogTWFya2Rvd25WaWV3KSA9PiB7XG5cdFx0XHRcdGNvbnN0IGxpc3RTZWxlY3Rpb25zIDogRWRpdG9yU2VsZWN0aW9uW10gPSBlZGl0b3IubGlzdFNlbGVjdGlvbnMoKVxuXHRcdFx0XHRsaXN0U2VsZWN0aW9ucy5mb3JFYWNoKGxpc3RTZWxlY3Rpb24gPT4ge1xuXHRcdFx0XHRcdGNvbnN0IGEgPSBsaXN0U2VsZWN0aW9uLmhlYWQubGluZVxuXHRcdFx0XHRcdGNvbnN0IGIgPSBsaXN0U2VsZWN0aW9uLmFuY2hvci5saW5lXG5cdFx0XHRcdFx0Y29uc3QgZnJvbUxpbmVOdW0gPSBiID4gYSA/IGEgOiBiXG5cdFx0XHRcdFx0Y29uc3QgdG9MaW5lTnVtID0gYiA+IGEgPyBiIDogYVxuXHRcdFx0XHRcdGZvciAobGV0IGkgPSBmcm9tTGluZU51bTsgaSA8PSB0b0xpbmVOdW07IGkrKykge1xuXHRcdFx0XHRcdFx0Y29uc3QgbGluZSA9IGVkaXRvci5nZXRMaW5lKGkpXG5cdFx0XHRcdFx0XHRlZGl0b3Iuc2V0TGluZShpLCBsaW5lLnJlcGxhY2UoL15cXHQvLCBcIlwiKSlcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pXG5cdFx0XHRcdGxldCBsc3MgOiBFZGl0b3JTZWxlY3Rpb25bXSA9IFtdXG5cdFx0XHRcdGxpc3RTZWxlY3Rpb25zLmZvckVhY2gobHMgPT4ge1xuXHRcdFx0XHRcdGNvbnN0IGhlYWQgPSBscy5oZWFkXG5cdFx0XHRcdFx0aGVhZC5jaCA9IGhlYWQuY2ggKyAxXG5cdFx0XHRcdFx0Y29uc3QgYW5jaG9yID0gbHMuYW5jaG9yXG5cdFx0XHRcdFx0YW5jaG9yLmNoID0gYW5jaG9yLmNoICsgMVxuXHRcdFx0XHRcdGNvbnN0IG5ld0xzOiBFZGl0b3JTZWxlY3Rpb24gPSB7YW5jaG9yLCBoZWFkfVxuXHRcdFx0XHRcdGxzcy5wdXNoKG5ld0xzKVxuXHRcdFx0XHR9KVxuXHRcdFx0XHRlZGl0b3Iuc2V0U2VsZWN0aW9ucyhsc3MpXG5cdFx0XHR9XG5cdFx0fSlcblxuXG5cdFx0Ly8gVGhpcyBhZGRzIGEgc2V0dGluZ3MgdGFiIHNvIHRoZSB1c2VyIGNhbiBjb25maWd1cmUgdmFyaW91cyBhc3BlY3RzIG9mIHRoZSBwbHVnaW5cblx0XHR0aGlzLmFkZFNldHRpbmdUYWIobmV3IFNhbXBsZVNldHRpbmdUYWIodGhpcy5hcHAsIHRoaXMpKTtcblx0fVxuXG5cdGNvbnZlcnRDaGF0R1BUVG9Ud2l0dGVyRm9ybWF0KGVkaXRvcjogRWRpdG9yKSA6IGJvb2xlYW4geyAvLyB0cnVlIG1lYW5zIHN1Y2Nlc3Ncblx0XHRsZXQgbGluZSA9IGVkaXRvci5saW5lQ291bnQoKTtcblxuXHRcdGxldCBudW1MaW5lRmlyc3RDb250ZW50ID0gMFxuXHRcdGxldCBmcm9udE1hdHRlckxpbmVDb3VudCA9IDBcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGxpbmU7IGkrKykge1xuXHRcdFx0aWYgKGZyb250TWF0dGVyTGluZUNvdW50ID09IDIpIHtcblx0XHRcdFx0bnVtTGluZUZpcnN0Q29udGVudCA9IGk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGVkaXRvci5nZXRMaW5lKGkpID09IFwiLS0tXCIpIHtcblx0XHRcdFx0ZnJvbnRNYXR0ZXJMaW5lQ291bnQrK1xuXHRcdFx0fVxuXHRcdH1cblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGxpbmU7IGkrKykge1xuXHRcdFx0aWYgKGVkaXRvci5nZXRMaW5lKG51bUxpbmVGaXJzdENvbnRlbnQpLnRyaW0oKSA9PSBcIlwiKSB7XG5cdFx0XHRcdG51bUxpbmVGaXJzdENvbnRlbnQrKztcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGxldCB0b3RhbFR3ZWV0Q291bnQgPSAxXG5cblx0XHRBcnJheS5mcm9tKEFycmF5KGxpbmUgLSBudW1MaW5lRmlyc3RDb250ZW50KS5rZXlzKCkpLmZvckVhY2goaSA9PiB7XG5cdFx0XHRjb25zdCBsaW5lID0gZWRpdG9yLmdldExpbmUoaSArIG51bUxpbmVGaXJzdENvbnRlbnQpO1xuXHRcdFx0bGV0IG1vZGlmaWVkTGluZSA9IGxpbmUucmVwbGFjZSgvXl9fX18rLywgXCItLS1cIikucmVwbGFjZSgvXi0tLS0rLywgXCItLS1cIilcblx0XHRcdGVkaXRvci5zZXRMaW5lKGkgKyBudW1MaW5lRmlyc3RDb250ZW50LCBtb2RpZmllZExpbmUpXG5cdFx0XHRpZiAobW9kaWZpZWRMaW5lID09IFwiLS0tXCIpIHtcblx0XHRcdFx0dG90YWxUd2VldENvdW50ID0gdG90YWxUd2VldENvdW50ICsgMVxuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0bGV0IG51bVR3ZWV0ID0gMVxuXHRcdGxldCByZWFkeVRvQWRkVHdlZXRDb3VudCA9IHRydWVcblxuXHRcdGxldCB0ZXh0ID0gXCJcIjtcblx0XHRBcnJheS5mcm9tKEFycmF5KG51bUxpbmVGaXJzdENvbnRlbnQpLmtleXMoKSkuZm9yRWFjaChpID0+IHtcblx0XHRcdGNvbnN0IGxpbmUgPSBlZGl0b3IuZ2V0TGluZShpKTtcblx0XHRcdHRleHQgPSB0ZXh0ICsgbGluZSArIFwiXFxuXCJcblx0XHR9KVxuXG5cdFx0QXJyYXkuZnJvbShBcnJheShsaW5lIC0gbnVtTGluZUZpcnN0Q29udGVudCkua2V5cygpKS5mb3JFYWNoKGkgPT4ge1xuXHRcdFx0Y29uc3QgbGluZSA9IGVkaXRvci5nZXRMaW5lKGkgKyBudW1MaW5lRmlyc3RDb250ZW50KTtcblx0XHRcdGxldCBtb2RpZmllZExpbmUgPSBsaW5lO1xuXHRcdFx0aWYgKGxpbmUgPT0gXCItLS1cIikge1xuXHRcdFx0XHRyZWFkeVRvQWRkVHdlZXRDb3VudCA9IHRydWVcblx0XHRcdFx0bnVtVHdlZXQgPSBudW1Ud2VldCArIDFcblx0XHRcdH0gZWxzZSBpZiAobGluZSAhPSBcIlwiICYmIHJlYWR5VG9BZGRUd2VldENvdW50KSB7XG5cdFx0XHRcdGlmICghL15cXGQrXFwvXFxkKy4qLy50ZXN0KGxpbmUpKSB7XG5cdFx0XHRcdFx0bW9kaWZpZWRMaW5lID0gYCR7bnVtVHdlZXR9LyR7dG90YWxUd2VldENvdW50fSAke2xpbmV9YFxuXHRcdFx0XHR9XG5cdFx0XHRcdHJlYWR5VG9BZGRUd2VldENvdW50ID0gZmFsc2Vcblx0XHRcdH1cblx0XHRcdHRleHQgPSB0ZXh0ICsgbW9kaWZpZWRMaW5lICsgXCJcXG5cIlxuXHRcdH0pO1xuXG5cdFx0dGV4dCA9IHRleHQucmVwbGFjZShcIlx1MjU4RFwiLCBcIlwiKVxuXG5cdFx0Ly8gc2hvdWxkIEkgYWRkIGNoZWNrIHNlZ21lbnQ/XG5cdFx0Y29uc3QgdHdlZXRzID0gdGV4dC5zcGxpdChcIi0tLVwiKVxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgdHdlZXRzLmxlbmd0aDsgaSsrKVxuXHRcdHtcblx0XHRcdGNvbnN0IHR3ZWV0ID0gdHdlZXRzW2ldLnJlcGxhY2UoLyhodHRwczp8aHR0cDp8d3d3XFwuKVxcUyovZ20sIFwiXCIpLnJlcGxhY2UoL15cXG4rL20sIFwiXCIpLnJlcGxhY2UoL1xcbiskL20sIFwiXCIpXG5cdFx0XHRpZiAodHdlZXQubGVuZ3RoID4gMTQwKVxuXHRcdFx0e1xuXHRcdFx0XHRuZXcgTm90aWNlKFwiYGBgXFxuXCIgKyB0d2VldCArIFwiXFxuYGBgXFxuXFxuZXhjZWVkIDE0MCBjaGFyYWN0ZXJzLiBQcm9iYWJseSBjYW5ub3QgcG9zdCBpbiB0d2l0dGVyLiBQbGVhc2UgcmVmaW5lIHRoZSB0d2VldC4gQWJvcnRpbmdcIilcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGVkaXRvci5zZXRWYWx1ZSh0ZXh0KVxuXHRcdGNvbnN0IGN1cnNvciA9IGVkaXRvci5nZXRDdXJzb3IoKVxuXHRcdGN1cnNvci5saW5lID0gZWRpdG9yLmxpbmVDb3VudCgpIC0gMVxuXHRcdGVkaXRvci5zZXRDdXJzb3IoY3Vyc29yKVxuXHRcdHJldHVybiB0cnVlXG5cdH1cblxuXHRyZXZlcnNlVHdpdHRlck51bWJlcmluZyhlZGl0b3I6IEVkaXRvcikge1xuXHRcdGxldCBsaW5lID0gZWRpdG9yLmxpbmVDb3VudCgpO1xuXG5cdFx0bGV0IG51bUxpbmVGaXJzdENvbnRlbnQgPSAwXG5cdFx0bGV0IGZyb250TWF0dGVyTGluZUNvdW50ID0gMFxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbGluZTsgaSsrKSB7XG5cdFx0XHRpZiAoZnJvbnRNYXR0ZXJMaW5lQ291bnQgPT0gMikge1xuXHRcdFx0XHRudW1MaW5lRmlyc3RDb250ZW50ID0gaTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRpZiAoZWRpdG9yLmdldExpbmUoaSkgPT0gXCItLS1cIikge1xuXHRcdFx0XHRmcm9udE1hdHRlckxpbmVDb3VudCsrXG5cdFx0XHR9XG5cdFx0fVxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbGluZTsgaSsrKSB7XG5cdFx0XHRpZiAoZWRpdG9yLmdldExpbmUobnVtTGluZUZpcnN0Q29udGVudCkudHJpbSgpID09IFwiXCIpIHtcblx0XHRcdFx0bnVtTGluZUZpcnN0Q29udGVudCsrO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0bGV0IHRleHQgPSBcIlwiO1xuXHRcdEFycmF5LmZyb20oQXJyYXkobnVtTGluZUZpcnN0Q29udGVudCkua2V5cygpKS5mb3JFYWNoKGkgPT4ge1xuXHRcdFx0Y29uc3QgbGluZSA9IGVkaXRvci5nZXRMaW5lKGkpO1xuXHRcdFx0dGV4dCA9IHRleHQgKyBsaW5lICsgXCJcXG5cIlxuXHRcdH0pXG5cblx0XHRBcnJheS5mcm9tKEFycmF5KGxpbmUgLSBudW1MaW5lRmlyc3RDb250ZW50KS5rZXlzKCkpLmZvckVhY2goaSA9PiB7XG5cdFx0XHRjb25zdCBsaW5lID0gZWRpdG9yLmdldExpbmUoaSArIG51bUxpbmVGaXJzdENvbnRlbnQpO1xuXHRcdFx0Y29uc3QgbW9kaWZpZWRMaW5lID0gbGluZS5yZXBsYWNlKC9eXFxkK1xcL1xcZCsgLywgXCJcIilcblx0XHRcdHRleHQgPSB0ZXh0ICsgbW9kaWZpZWRMaW5lICsgXCJcXG5cIlxuXHRcdH0pO1xuXG5cdFx0ZWRpdG9yLnNldFZhbHVlKHRleHQpXG5cdFx0Y29uc3QgY3Vyc29yID0gZWRpdG9yLmdldEN1cnNvcigpXG5cdFx0Y3Vyc29yLmxpbmUgPSBlZGl0b3IubGluZUNvdW50KCkgLSAxXG5cdFx0ZWRpdG9yLnNldEN1cnNvcihjdXJzb3IpXG5cdH1cblxuXG5cdGNvbnZlcnRUaHJlYWRzQ29udGVudFRvRm9ybWF0Rm9yVGhyZWFkc0FwcChlZGl0b3I6IEVkaXRvcikgOiBzdHJpbmcge1xuXHRcdGxldCByZXN1bHQgPSB0aGlzLmNvbnZlcnRUaHJlYWRzQ29udGVudFRvTGlnaHRQb3N0Rm9ybWF0KGVkaXRvciwgXCJcdUQ4M0VcdURERjVcIiwgXCJcXG5cXG5cXG5cIilcblx0XHRyZXN1bHQgPSByZXN1bHQucmVwbGFjZSgvaHR0cHNcXDpcXC9cXC9naXRodWIuY29tW15cXG5dK1xcblxcblxcbi9tLCBcIlwiKVxuXHRcdHJldHVybiByZXN1bHRcblx0fVxuXG5cdGNvbnZlcnRUaHJlYWRzQ29udGVudFRvRm9ybWF0Rm9yRmFjZWJvb2tBcHAoZWRpdG9yOiBFZGl0b3IpIDogc3RyaW5nIHtcblx0XHRyZXR1cm4gdGhpcy5jb252ZXJ0VGhyZWFkc0NvbnRlbnRUb0xpZ2h0UG9zdEZvcm1hdChlZGl0b3IsIFwiXCIsIFwiXFxuXFxuXHUxMTczXHUxMTczXHUxMTczXHUxMTczXHUxMTczXHUxMTczXHUxMTczXHUxMTczXHUxMTczXHUxMTczXHUxMTczXHUxMTczXHUxMTczXHUxMTczXHUxMTczXHUxMTczXHUxMTczXHUxMTczXHUxMTczXHUxMTczXHUxMTczXHUxMTczXFxuXFxuXCIsIChhKSA9PiBhLnJlcGxhY2UoXCJcdUQ4M0RcdURDNDdcIiwgXCJcIikpXG5cdH1cblxuXHRjb252ZXJ0VGhyZWFkc0NvbnRlbnRUb1BPRShlZGl0b3I6IEVkaXRvcikgOiBzdHJpbmcge1xuXHRcdHJldHVybiB0aGlzLmNvbnZlcnRUaHJlYWRzQ29udGVudFRvTGlnaHRQb3N0Rm9ybWF0KGVkaXRvciwgXCJcIiwgXCJcXG5cXG4tLS1cXG5cXG5cIiwgKGEpID0+IGEucmVwbGFjZShcIlx1RDgzRFx1REM0N1wiLCBcIlwiKSlcblx0fVxuXG4vKlxuXHRhZGRUYXNrVG9QdXRJbnRvQ2FyZEluVGhyZWFkc0NvbnRlbnQoZWRpdG9yOiBFZGl0b3IpIHtcblx0XHRsZXQgbGluZSA9IGVkaXRvci5saW5lQ291bnQoKTtcblxuXHRcdGxldCBmcm9udE1hdHRlckxpbmVDb3VudCA9IDBcblx0XHRsZXQgdGV4dCA9IFwiXCI7XG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lOyBpKyspIHtcblx0XHRcdGlmIChlZGl0b3IuZ2V0TGluZShpKSA9PSBcIi0tLVwiKSB7XG5cdFx0XHRcdGZyb250TWF0dGVyTGluZUNvdW50Kytcblx0XHRcdH1cblx0XHRcdGNvbnN0IGxpbmUgPSBlZGl0b3IuZ2V0TGluZShpKTtcblx0XHRcdFxuXHRcdFx0Ly9pZiAoZnJvbnRNYXR0ZXJMaW5lQ291bnQgPiAyICYmIGxpbmUgPT0gXCItLS1cIikge1xuXHRcdFx0Ly9cdHRleHQgPSB0ZXh0ICsgXCIlJSAjbm0gdG8gemsgJSVcXG5cXG5cIlxuXHRcdFx0Ly99XG5cdFx0XHR0ZXh0ID0gdGV4dCArIGxpbmUgKyBcIlxcblwiXG5cdFx0fVxuXG5cdFx0ZWRpdG9yLnNldFZhbHVlKHRleHQpO1xuXHR9XG4qL1xuXG5cdGNvbnZlcnRUaHJlYWRzQ29udGVudFRvTGlnaHRQb3N0Rm9ybWF0KGVkaXRvcjogRWRpdG9yLCBoZWFkZXJJY29uOiBzdHJpbmcsIHBhcmFncmFwaFNlcGFyYXRvcjogc3RyaW5nXG5cdFx0LCBhZGRpdGlvblJlcGxhY2VGbjogKGE6IHN0cmluZykgPT4gc3RyaW5nID0gKGEpID0+IGEpIDogc3RyaW5nIHtcblx0XHRsZXQgbGluZSA9IGVkaXRvci5saW5lQ291bnQoKTtcblxuXHRcdGxldCBudW1MaW5lRmlyc3RDb250ZW50ID0gMFxuXHRcdGxldCBmcm9udE1hdHRlckxpbmVDb3VudCA9IDBcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGxpbmU7IGkrKykge1xuXHRcdFx0aWYgKGZyb250TWF0dGVyTGluZUNvdW50ID09IDIpIHtcblx0XHRcdFx0bnVtTGluZUZpcnN0Q29udGVudCA9IGk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGVkaXRvci5nZXRMaW5lKGkpID09IFwiLS0tXCIpIHtcblx0XHRcdFx0ZnJvbnRNYXR0ZXJMaW5lQ291bnQrK1xuXHRcdFx0fVxuXHRcdH1cblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGxpbmU7IGkrKykge1xuXHRcdFx0aWYgKGVkaXRvci5nZXRMaW5lKG51bUxpbmVGaXJzdENvbnRlbnQpLnRyaW0oKSA9PSBcIlwiKSB7XG5cdFx0XHRcdG51bUxpbmVGaXJzdENvbnRlbnQrKztcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGxldCB0ZXh0ID0gXCJcIjtcblx0XHRsZXQgbmV3Q29uc2VjdXRpdmVMaW5lQ291bnQgPSAwO1xuXHRcdEFycmF5LmZyb20oQXJyYXkobGluZSAtIG51bUxpbmVGaXJzdENvbnRlbnQpLmtleXMoKSkuZm9yRWFjaChpID0+IHtcblx0XHRcdGNvbnN0IGxpbmUgPSBlZGl0b3IuZ2V0TGluZShpICsgbnVtTGluZUZpcnN0Q29udGVudCk7XG5cdFx0XHRpZiAoIWxpbmUudHJpbSgpLnN0YXJ0c1dpdGgoXCIlJVwiKSB8fCAhbGluZS50cmltKCkuZW5kc1dpdGgoXCIlJVwiKSkge1xuXHRcdFx0XHRpZiAobGluZSA9PSBcIi0tLVwiKSB7XG5cdFx0XHRcdFx0bmV3Q29uc2VjdXRpdmVMaW5lQ291bnQgPSAwO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChsaW5lID09IFwiXCIpIHtcblx0XHRcdFx0XHRuZXdDb25zZWN1dGl2ZUxpbmVDb3VudCsrO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdG5ld0NvbnNlY3V0aXZlTGluZUNvdW50ID0gMDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAobGluZSA9PSBcIlwiICYmIG5ld0NvbnNlY3V0aXZlTGluZUNvdW50ID4gMSkge1xuXHRcdFx0XHRcdC8vIGRvIG5vdGhpbmdcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRsZXQgbW9kaWZpZWRMaW5lID0gbGluZSA9PSBcIi0tLVwiID8gXCJcIiA6IGxpbmVcblx0XHRcdFx0XHRtb2RpZmllZExpbmUgPSBtb2RpZmllZExpbmUucmVwbGFjZSgvXlx0XHQtIC9nLCBcIlx1MzAwMFx1MzAwMFx1MzAwMFx1MzAwMFx1MjAyMiBcIikucmVwbGFjZSgvXlx0LSAvZywgXCJcdTMwMDBcdTMwMDBcdTIwMjIgXCIpLnJlcGxhY2UoL14tIC8sIFwiXHUyMDIyIFwiKTtcblx0XHRcdFx0XHRtb2RpZmllZExpbmUgPSBtb2RpZmllZExpbmUucmVwbGFjZSgvXlxcWyhbXlxcW1xcXVxcKFxcKV0rKVxcXVxcKFteXFxbXFxdXFwoXFwpXStcXCkvZywgXCIkMVwiKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC5yZXBsYWNlKC9bXiFdXFxbKFteXFxbXFxdXFwoXFwpXSspXFxdXFwoW15cXFtcXF1cXChcXCldK1xcKS9nLCBcIiQxXCIpXG5cdFx0XHRcdFx0bW9kaWZpZWRMaW5lID0gbW9kaWZpZWRMaW5lLnJlcGxhY2UoLyFcXFsoW15cXFtcXF1cXChcXCldKylcXF1cXCgoW15cXFtcXF1cXChcXCldKylcXCkvZywgXCIkMlwiKVxuXHRcdFx0XHRcdG1vZGlmaWVkTGluZSA9IG1vZGlmaWVkTGluZS5yZXBsYWNlKC9cXCpcXCovZ20sIFwiXCIpXG5cdFx0XHRcdFx0dGV4dCA9IHRleHQgKyBtb2RpZmllZExpbmUgKyBcIlxcblwiXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KTtcblx0XHRcblx0XHR0ZXh0ID0gdGV4dC5yZXBsYWNlKC9cdUQ4M0VcdURERjVbIF0rKC4qKS9nLCBoZWFkZXJJY29uICsgXCJcdTMwMTAkMVx1MzAxMVwiKVxuXHRcdHRleHQgPSBhZGRpdGlvblJlcGxhY2VGbih0ZXh0KVxuXHRcdC8vIHRleHQgPSB0ZXh0LnJlcGxhY2UoL15cdFx0LSAvZywgXCJcdTMwMDBcdTMwMDBcdTIwMjIgXCIpLnJlcGxhY2UoL15cdC0gL2csIFwiXHUzMDAwXHUyMDIyIFwiKS5yZXBsYWNlKC9eLSAvLCBcIlx1MjAyMiBcIik7XG5cdFx0Ly90ZXh0ID0gdGV4dC5yZXBsYWNlKC9bXFxuXFxyXXszLH0oW15cXG5cXHJdK1x1MzAwMltcXG5cXHJdKS9nbSwgYCR7cGFyYWdyYXBoU2VwYXJhdG9yfSQxYCk7XG5cdFx0Ly90ZXh0ID0gdGV4dC5yZXBsYWNlKC9bXFxuXFxyXXszLH0oW15cXG5cXHJdK1x1RkYxQVtcXG5cXHJdKS9nbSwgYCR7cGFyYWdyYXBoU2VwYXJhdG9yfSQxYCk7XG5cdFx0Ly90ZXh0ID0gdGV4dC5yZXBsYWNlKC9bXFxuXFxyXXszLH0oaHR0cFteXFxuXFxyXStbXFxuXFxyXSkvZ20sIGAke3BhcmFncmFwaFNlcGFyYXRvcn0kMWApO1xuXHRcdHRleHQgPSB0ZXh0LnJlcGxhY2UoL1tcXG5cXHJdezMsfS9nbSwgYCR7cGFyYWdyYXBoU2VwYXJhdG9yfVx1MjU4RGApO1xuXG5cdFx0dGV4dCA9IHRleHQucmVwbGFjZShcIlxcblx1MTE3M1x1MTE3M1x1MTE3M1x1MTE3M1x1MTE3M1x1MTE3M1x1MTE3M1x1MTE3M1x1MTE3M1x1MTE3M1x1MTE3M1x1MTE3M1x1MTE3M1x1MTE3M1x1MTE3M1x1MTE3M1x1MTE3M1x1MTE3M1x1MTE3M1x1MTE3M1x1MTE3M1x1MTE3M1xcblxcblx1MjU4RFxcblwiLCBcIlwiKSAvLyByZW1vdmUgZW1wdHkgbGluZVxuXG5cdFx0bGV0IHRleHQyID0gXCJcIlxuXG5cdFx0dGV4dC5zcGxpdChcIlxcblwiKS5mb3JFYWNoKGxpbmUgPT4ge1xuXHRcdFx0dmFyIGwgPSBcIlwiXG5cblx0XHRcdGlmIChsaW5lLmVuZHNXaXRoKFwiXHUzMDAyXCIpIHx8IGxpbmUuZW5kc1dpdGgoXCJcdUZGMUFcIikgfHwgbGluZS5lbmRzV2l0aChcIlx1RkY1RVwiKSB8fCBsaW5lLmVuZHNXaXRoKFwiXHVGRjAxXCIpIHx8IGxpbmUuc3RhcnRzV2l0aChcIlx1MjU4RGh0dHBcIikgfHwgbGluZS5zdGFydHNXaXRoKFwiXHUyNThEI1wiKSB8fCBsaW5lID09IFwiXHUyNThEXCIpIHtcblx0XHRcdFx0bCA9IGxpbmUucmVwbGFjZSgvXlx1MjU4RC9nbSwgXCJcIilcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGwgPSBsaW5lXG5cdFx0XHR9XG5cdFx0XHR0ZXh0MiA9IHRleHQyICsgbCArIFwiXFxuXCJcblx0XHR9KVxuXG5cdFx0dGV4dDIgPSB0ZXh0Mi5yZXBsYWNlKFwiXFxuXFxuXFxuXFxuXCIsIFwiXCIpIC8vIHJlbW92ZSBlbXB0eSBsaW5lXG5cdFx0dGV4dDIgPSB0ZXh0Mi5yZXBsYWNlKFwiXFxuXHUxMTczXHUxMTczXHUxMTczXHUxMTczXHUxMTczXHUxMTczXHUxMTczXHUxMTczXHUxMTczXHUxMTczXHUxMTczXHUxMTczXHUxMTczXHUxMTczXHUxMTczXHUxMTczXHUxMTczXHUxMTczXHUxMTczXHUxMTczXHUxMTczXHUxMTczXFxuXFxuXFxuXCIsIFwiXCIpIC8vIHJlbW92ZSBlbXB0eSBsaW5lXG5cdFx0dGV4dDIgPSB0ZXh0Mi5yZXBsYWNlKC9cXG5cXG4jIyBPcGluaW9uIGZyb20gQ2hhdEdQVFxcOihbXFxuXSouKikqJC8sIFwiXCIpXG5cdFx0dGV4dDIgPSB0ZXh0Mi5yZXBsYWNlKC8jIyBSZWZlcmVuY2VzXFw6KFtcXG5dKi4qKSokLywgXCJcIik7XG5cdFx0dGV4dDIgPSB0ZXh0Mi5yZXBsYWNlKC9cXG4rJC8sIFwiXCIpXG5cblx0XHRyZXR1cm4gdGV4dDJcblx0fVxuXG5cdGdldFRocmVhZFNlZ21lbnQoZWRpdG9yOiBFZGl0b3IpIDogc3RyaW5nIHtcblx0XHRsZXQgY3Vyc29yID0gZWRpdG9yLmdldEN1cnNvcigpO1xuXHRcdGxldCBsaW5lID0gY3Vyc29yLmxpbmU7XG5cdFx0bGV0IGFib3ZlID0gbGluZTtcblx0XHRsZXQgYmVsb3cgPSBsaW5lO1xuXHRcdC8vIGZpcnN0IGdldCBhYm92ZVxuXHRcdFxuXHRcdHdoaWxlIChhYm92ZSA+PSAwKSB7XG5cdFx0XHRsZXQgbCA9IGVkaXRvci5nZXRMaW5lKGFib3ZlKTtcblx0XHRcdGlmIChsID09ICctLS0nKSB7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0YWJvdmUtLTtcblx0XHR9XG5cdFx0aWYgKGVkaXRvci5nZXRMaW5lKGFib3ZlKSA9PSAnLS0tJykge1xuXHRcdFx0YWJvdmUrKztcblx0XHR9XG5cdFx0d2hpbGUodHJ1ZSkge1xuXHRcdFx0aWYgKGVkaXRvci5nZXRMaW5lKGFib3ZlKSA9PSAnJykge1xuXHRcdFx0XHRhYm92ZSsrO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gdGhlbiBnZXQgYmVsb3dcblx0XHR3aGlsZSAoYmVsb3cgPCBlZGl0b3IubGluZUNvdW50KCkpIHtcblx0XHRcdGxldCBsID0gZWRpdG9yLmdldExpbmUoYmVsb3cpO1xuXHRcdFx0aWYgKGwgPT0gJy0tLScpIHtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRiZWxvdysrO1xuXHRcdH1cblx0XHRpZiAoZWRpdG9yLmdldExpbmUoYmVsb3cpID09ICctLS0nKSB7XG5cdFx0XHRiZWxvdy0tO1xuXHRcdH1cblxuXHRcdHdoaWxlKHRydWUpIHtcblx0XHRcdGlmIChlZGl0b3IuZ2V0TGluZShiZWxvdykgPT0gJycpIHtcblx0XHRcdFx0YmVsb3ctLTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIHRoZW4gcHV0IHRoZW0gdG8gbGluZVxuXG5cdFx0bGV0IHRleHQgPSBcIlwiO1xuXHRcdEFycmF5LmZyb20oQXJyYXkoYmVsb3cgLSBhYm92ZSArIDEpLmtleXMoKSkuZm9yRWFjaChpID0+IHtcblx0XHRcdGNvbnN0IGxpbmUgPSBlZGl0b3IuZ2V0TGluZShpICsgYWJvdmUpXG5cdFx0XHRpZiAoIWxpbmUudHJpbSgpLnN0YXJ0c1dpdGgoXCIlJVwiKSB8fCAhbGluZS50cmltKCkuZW5kc1dpdGgoXCIlJVwiKSkge1xuXHRcdFx0XHRsZXQgbW9kaWZpZWRMaW5lID0gZWRpdG9yLmdldExpbmUoaSArIGFib3ZlKVxuXHRcdFx0XHRtb2RpZmllZExpbmUgPSBtb2RpZmllZExpbmUucmVwbGFjZSgvXlxcWyhbXlxcW1xcXVxcKFxcKV0rKVxcXVxcKFteXFxbXFxdXFwoXFwpXStcXCkvZywgXCIkMVwiKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQgICAucmVwbGFjZSgvW14hXVxcWyhbXlxcW1xcXVxcKFxcKV0rKVxcXVxcKFteXFxbXFxdXFwoXFwpXStcXCkvZywgXCIkMVwiKVxuXHRcdFx0XHR0ZXh0ID0gdGV4dCArIG1vZGlmaWVkTGluZSArIFwiXFxuXCJcblx0XHRcdH1cblx0XHR9KVxuXHRcdHRleHQgPSB0ZXh0LnJlcGxhY2UoL1xcbiskLywgXCJcIilcblx0XHRyZXR1cm4gdGV4dFxuXHR9XG5cblx0Z2V0U2VnbWVudChlZGl0b3I6IEVkaXRvcikgOiBzdHJpbmcge1xuXHRcdGxldCBjdXJzb3IgPSBlZGl0b3IuZ2V0Q3Vyc29yKCk7XG5cdFx0bGV0IGxpbmUgPSBjdXJzb3IubGluZTtcblx0XHRsZXQgYWJvdmUgPSBsaW5lO1xuXHRcdGxldCBiZWxvdyA9IGxpbmU7XG5cdFx0Ly8gZmlyc3QgZ2V0IGFib3ZlXG5cdFx0XG5cdFx0d2hpbGUgKGFib3ZlID49IDApIHtcblx0XHRcdGxldCBsID0gZWRpdG9yLmdldExpbmUoYWJvdmUpO1xuXHRcdFx0aWYgKGwgPT0gJy0tLScpIHtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRhYm92ZS0tO1xuXHRcdH1cblx0XHRpZiAoZWRpdG9yLmdldExpbmUoYWJvdmUpID09ICctLS0nKSB7XG5cdFx0XHRhYm92ZSsrO1xuXHRcdH1cblx0XHR3aGlsZSh0cnVlKSB7XG5cdFx0XHRpZiAoZWRpdG9yLmdldExpbmUoYWJvdmUpID09ICcnKSB7XG5cdFx0XHRcdGFib3ZlKys7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyB0aGVuIGdldCBiZWxvd1xuXHRcdHdoaWxlIChiZWxvdyA8IGVkaXRvci5saW5lQ291bnQoKSkge1xuXHRcdFx0bGV0IGwgPSBlZGl0b3IuZ2V0TGluZShiZWxvdyk7XG5cdFx0XHRpZiAobCA9PSAnLS0tJykge1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdGJlbG93Kys7XG5cdFx0fVxuXHRcdGlmIChlZGl0b3IuZ2V0TGluZShiZWxvdykgPT0gJy0tLScpIHtcblx0XHRcdGJlbG93LS07XG5cdFx0fVxuXG5cdFx0d2hpbGUodHJ1ZSkge1xuXHRcdFx0aWYgKGVkaXRvci5nZXRMaW5lKGJlbG93KSA9PSAnJykge1xuXHRcdFx0XHRiZWxvdy0tO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gdGhlbiBwdXQgdGhlbSB0byBsaW5lXG5cblx0XHRsZXQgdGV4dCA9IFwiXCI7XG5cdFx0QXJyYXkuZnJvbShBcnJheShiZWxvdyAtIGFib3ZlICsgMSkua2V5cygpKS5mb3JFYWNoKGkgPT4ge1xuXHRcdFx0Y29uc3QgbGluZSA9IGVkaXRvci5nZXRMaW5lKGkgKyBhYm92ZSlcblx0XHRcdHRleHQgPSB0ZXh0ICsgbGluZSArIFwiXFxuXCJcblx0XHR9KVxuXHRcdHRleHQgPSB0ZXh0LnJlcGxhY2UoL1xcbiskLywgXCJcIilcblx0XHRyZXR1cm4gdGV4dFxuXHR9XG5cblx0Z2V0VHdpdHRlclNlZ21lbnQoZWRpdG9yOiBFZGl0b3IpIDogc3RyaW5nIHtcblx0XHRsZXQgY3Vyc29yID0gZWRpdG9yLmdldEN1cnNvcigpO1xuXHRcdGxldCBsaW5lID0gY3Vyc29yLmxpbmU7XG5cdFx0bGV0IGFib3ZlID0gbGluZTtcblx0XHRsZXQgYmVsb3cgPSBsaW5lO1xuXHRcdC8vIGZpcnN0IGdldCBhYm92ZVxuXHRcdFxuXHRcdHdoaWxlIChhYm92ZSA+PSAwKSB7XG5cdFx0XHRsZXQgbCA9IGVkaXRvci5nZXRMaW5lKGFib3ZlKTtcblx0XHRcdGlmIChsID09ICctLS0nKSB7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0YWJvdmUtLTtcblx0XHR9XG5cdFx0aWYgKGVkaXRvci5nZXRMaW5lKGFib3ZlKSA9PSAnLS0tJykge1xuXHRcdFx0YWJvdmUrKztcblx0XHR9XG5cdFx0d2hpbGUodHJ1ZSkge1xuXHRcdFx0aWYgKGVkaXRvci5nZXRMaW5lKGFib3ZlKSA9PSAnJykge1xuXHRcdFx0XHRhYm92ZSsrO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gdGhlbiBnZXQgYmVsb3dcblx0XHR3aGlsZSAoYmVsb3cgPCBlZGl0b3IubGluZUNvdW50KCkpIHtcblx0XHRcdGxldCBsID0gZWRpdG9yLmdldExpbmUoYmVsb3cpO1xuXHRcdFx0aWYgKGwgPT0gJy0tLScpIHtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRiZWxvdysrO1xuXHRcdH1cblx0XHRpZiAoZWRpdG9yLmdldExpbmUoYmVsb3cpID09ICctLS0nKSB7XG5cdFx0XHRiZWxvdy0tO1xuXHRcdH1cblxuXHRcdHdoaWxlKHRydWUpIHtcblx0XHRcdGlmIChlZGl0b3IuZ2V0TGluZShiZWxvdykgPT0gJycpIHtcblx0XHRcdFx0YmVsb3ctLTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIHRoZW4gcHV0IHRoZW0gdG8gbGluZVxuXG5cdFx0bGV0IHRleHQgPSBcIlwiO1xuXHRcdEFycmF5LmZyb20oQXJyYXkoYmVsb3cgLSBhYm92ZSArIDEpLmtleXMoKSkuZm9yRWFjaChpID0+IHtcblx0XHRcdGNvbnN0IGxpbmUgPSBlZGl0b3IuZ2V0TGluZShpICsgYWJvdmUpXG5cdFx0XHRpZiAoIWxpbmUudHJpbSgpLnN0YXJ0c1dpdGgoXCIlJVwiKSB8fCAhbGluZS50cmltKCkuZW5kc1dpdGgoXCIlJVwiKSkge1xuXHRcdFx0XHRsZXQgbW9kaWZpZWRMaW5lID0gZWRpdG9yLmdldExpbmUoaSArIGFib3ZlKVxuXHRcdFx0XHRpZiAoIS9cXGQrXFwvXFxkKyAqXHUzMDEwLipcdTMwMTEvLnRlc3QobW9kaWZpZWRMaW5lKSkge1xuXHRcdFx0XHRcdG1vZGlmaWVkTGluZSA9IG1vZGlmaWVkTGluZS5yZXBsYWNlKC9eXFxbKFteXFxbXFxdXFwoXFwpXSspXFxdXFwoW15cXFtcXF1cXChcXCldK1xcKS9nLCBcIiQxXCIpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0LnJlcGxhY2UoL1teIV1cXFsoW15cXFtcXF1cXChcXCldKylcXF1cXChbXlxcW1xcXVxcKFxcKV0rXFwpL2csIFwiJDFcIilcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQucmVwbGFjZSgvaHR0cHNbXlxcbl0rXFwuanBlZy9nLCBcIlwiKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC5yZXBsYWNlKC9cdUZGMUYoW15cdTMwMTFcdTMwMERcXG5dKS9nLCBcIlx1RkYxRlxcblxcbiQxXCIpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0LnJlcGxhY2UoL1x1MzAwMihbXlx1MzAxMVx1MzAwRFxcbl0pL2csIFwiXHUzMDAyXFxuXFxuJDFcIilcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQucmVwbGFjZSgvXHVGRjAxKFteXHUzMDExXHUzMDBEXFxuXSkvZywgXCJcdUZGMDFcXG5cXG4kMVwiKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC5yZXBsYWNlKC9cdUZGNUUoW15cdTMwMTFcdTMwMERcXG5dKS9nLCBcIlx1RkY1RVxcblxcbiQxXCIpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0LnJlcGxhY2UoL15cXHMrJC8sIFwiXCIpXG5cdFx0XHRcdH1cblx0XHRcdFx0dGV4dCA9IHRleHQgKyBtb2RpZmllZExpbmUgKyBcIlxcblwiXG5cdFx0XHR9XG5cdFx0fSlcblx0XHR0ZXh0ID0gdGV4dC5yZXBsYWNlKC9cXG4rJC8sIFwiXCIpXG5cdFx0cmV0dXJuIHRleHRcblx0fVxuXG5cdGdldFRocmVhZHNTZWdtZW50KGVkaXRvcjogRWRpdG9yKSA6IHN0cmluZyB7XG5cdFx0bGV0IGN1cnNvciA9IGVkaXRvci5nZXRDdXJzb3IoKTtcblx0XHRsZXQgbGluZSA9IGN1cnNvci5saW5lO1xuXHRcdGxldCBhYm92ZSA9IGxpbmU7XG5cdFx0bGV0IGJlbG93ID0gbGluZTtcblx0XHQvLyBmaXJzdCBnZXQgYWJvdmVcblx0XHRcblx0XHR3aGlsZSAoYWJvdmUgPj0gMCkge1xuXHRcdFx0bGV0IGwgPSBlZGl0b3IuZ2V0TGluZShhYm92ZSk7XG5cdFx0XHRpZiAobCA9PSAnLS0tJykge1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdGFib3ZlLS07XG5cdFx0fVxuXHRcdGlmIChlZGl0b3IuZ2V0TGluZShhYm92ZSkgPT0gJy0tLScpIHtcblx0XHRcdGFib3ZlKys7XG5cdFx0fVxuXHRcdHdoaWxlKHRydWUpIHtcblx0XHRcdGlmIChlZGl0b3IuZ2V0TGluZShhYm92ZSkgPT0gJycpIHtcblx0XHRcdFx0YWJvdmUrKztcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIHRoZW4gZ2V0IGJlbG93XG5cdFx0d2hpbGUgKGJlbG93IDwgZWRpdG9yLmxpbmVDb3VudCgpKSB7XG5cdFx0XHRsZXQgbCA9IGVkaXRvci5nZXRMaW5lKGJlbG93KTtcblx0XHRcdGlmIChsID09ICctLS0nKSB7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0YmVsb3crKztcblx0XHR9XG5cdFx0aWYgKGVkaXRvci5nZXRMaW5lKGJlbG93KSA9PSAnLS0tJykge1xuXHRcdFx0YmVsb3ctLTtcblx0XHR9XG5cblx0XHR3aGlsZSh0cnVlKSB7XG5cdFx0XHRpZiAoZWRpdG9yLmdldExpbmUoYmVsb3cpID09ICcnKSB7XG5cdFx0XHRcdGJlbG93LS07XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyB0aGVuIHB1dCB0aGVtIHRvIGxpbmVcblxuXHRcdGxldCB0ZXh0ID0gXCJcIjtcblx0XHRBcnJheS5mcm9tKEFycmF5KGJlbG93IC0gYWJvdmUgKyAxKS5rZXlzKCkpLmZvckVhY2goaSA9PiB7XG5cdFx0XHRjb25zdCBsaW5lID0gZWRpdG9yLmdldExpbmUoaSArIGFib3ZlKVxuXHRcdFx0aWYgKCFsaW5lLnRyaW0oKS5zdGFydHNXaXRoKFwiJSVcIikgfHwgIWxpbmUudHJpbSgpLmVuZHNXaXRoKFwiJSVcIikpIHtcblx0XHRcdFx0bGV0IG1vZGlmaWVkTGluZSA9IGVkaXRvci5nZXRMaW5lKGkgKyBhYm92ZSlcblx0XHRcdFx0aWYgKCEvXFxkK1xcL1xcZCsgKlx1MzAxMC4qXHUzMDExLy50ZXN0KG1vZGlmaWVkTGluZSkpIHtcblx0XHRcdFx0XHRtb2RpZmllZExpbmUgPSBtb2RpZmllZExpbmUucmVwbGFjZSgvXHVEODNFXHVEREY1WyBdKyguKikvZywgaGVhZGVySWNvbiArIFwiXHUzMDEwJDFcdTMwMTFcIilcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQucmVwbGFjZSgvXlxcWyhbXlxcW1xcXVxcKFxcKV0rKVxcXVxcKFteXFxbXFxdXFwoXFwpXStcXCkvZywgXCIkMVwiKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC5yZXBsYWNlKC9bXiFdXFxbKFteXFxbXFxdXFwoXFwpXSspXFxdXFwoW15cXFtcXF1cXChcXCldK1xcKS9nLCBcIiQxXCIpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0LnJlcGxhY2UoLyFcXFsuKlxcXVxcKGh0dHBzW15cXG5dK1xcLmpwZWdcXCkvZywgXCJcIilcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQucmVwbGFjZSgvaHR0cHNbXlxcbl0rXFwuanBlZy9nLCBcIlwiKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC5yZXBsYWNlKC9cdUZGMUYoW15cdTMwMTFcdTMwMERcXG5dKS9nLCBcIlx1RkYxRlxcblxcbiQxXCIpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0LnJlcGxhY2UoL1x1MzAwMihbXlx1MzAxMVx1MzAwRFxcbl0pL2csIFwiXHUzMDAyXFxuXFxuJDFcIilcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQucmVwbGFjZSgvXHVGRjAxKFteXHUzMDExXHUzMDBEXFxuXSkvZywgXCJcdUZGMDFcXG5cXG4kMVwiKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC5yZXBsYWNlKC9cdUZGNUUoW15cdTMwMTFcdTMwMERcXG5dKS9nLCBcIlx1RkY1RVxcblxcbiQxXCIpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0LnJlcGxhY2UoL15cXHMrJC8sIFwiXCIpXG5cdFx0XHRcdH1cblx0XHRcdFx0dGV4dCA9IHRleHQgKyBtb2RpZmllZExpbmUgKyBcIlxcblwiXG5cdFx0XHR9XG5cdFx0fSlcblx0XHR0ZXh0ID0gdGV4dC5yZXBsYWNlKC9cXG4rJC8sIFwiXCIpXG5cdFx0cmV0dXJuIHRleHRcblx0fVxuXG5cblx0YXN5bmMgYWRkM0RheXNBY3Rpb25Ob3RlQ29udGVudCh2YXVsdDogVmF1bHQpIHtcblx0XHRjb25zdCBzY2hlZHVsZU5vdGVXaXRob3V0TWQgPSBcIkQvUXVlcnkgU2NoZWR1bGUgYW5kIEFjdGlvbnMgbmV4dCAzIGRheXNcIlxuXHRcdGNvbnN0IHNjaGVkdWxlTm90ZSA9IGAke3NjaGVkdWxlTm90ZVdpdGhvdXRNZH0ubWRgXHRcdFx0XHRcblx0XHRpZiAodmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKHNjaGVkdWxlTm90ZSkgPT0gbnVsbCkge1xuXHRcdFx0YXdhaXQgdmF1bHQuY3JlYXRlKHNjaGVkdWxlTm90ZSwgXCJcIik7XG5cdFx0fVxuXHRcdGxldCBub3RlQ29udGVudCA9ICdbW1F1ZXJ5IFNjaGVkdWxlIGFuZCBBY3Rpb25zIG5leHQgMyBkYXlzXV1cXG4nXG5cdFx0Y29uc3QgZXhjbHVkZU5vdGVzID0gW3NjaGVkdWxlTm90ZVdpdGhvdXRNZCwgXCJEL1NjaGVkdWxpbmdcIl07XG5cdFx0QXJyYXkuZnJvbShBcnJheSgzKS5rZXlzKCkpLmZvckVhY2goaSA9PiBub3RlQ29udGVudCArPSB0aGlzLmdldFF1ZXJ5RGF0ZUFuZEFjdGlvblN0cmluZyhpLCBleGNsdWRlTm90ZXMpKTtcblx0XHRjb25zdCBvdGhlckRheXMgPSB0aGlzLmdldFF1ZXJ5QWN0aW9uc1RoaXNXZWVrKDMpO1xuXHRcdG5vdGVDb250ZW50ID0gbm90ZUNvbnRlbnQgKyBgIyMgbm4gLyB3blxcblxcYFxcYFxcYHF1ZXJ5XFxudGFnOiNubiBPUiB0YWc6I3duJHtvdGhlckRheXN9XFxuXFxgXFxgXFxgXFxuXFxuIyMgdHRcXG5cXGBcXGBcXGBxdWVyeVxcbnRhZzojdHRcXG5cXGBcXGBcXGBcXG5cXG5gXG5cdFx0bm90ZUNvbnRlbnQgPSBub3RlQ29udGVudCArIHRoaXMuZ2V0UXVlcnlGdXR1cmVEYXlzVGhpc1dlZWsoXCJGdXR1cmUgRGF0ZXNcIiwgMywgNiwgZXhjbHVkZU5vdGVzKVxuXHRcdG5vdGVDb250ZW50ID0gbm90ZUNvbnRlbnQgKyB0aGlzLmdldFF1ZXJ5TmV4dDJNb250aFN0cmluZyhleGNsdWRlTm90ZXMpXG5cdFx0bm90ZUNvbnRlbnQgPSBub3RlQ29udGVudCArIHRoaXMuZ2V0UXVlcnlGdXR1cmVEYXlzVGhpc1dlZWsoXCJQYXN0IERhdGVzXCIsIC03LCAtMSwgZXhjbHVkZU5vdGVzKVxuXHRcdC8vIG5vdGVDb250ZW50ID0gbm90ZUNvbnRlbnQgKyBgXFxuXFxuW1tRdWVyeSBTY2hlZHVsZSBhbmQgQWN0aW9ucyBuZXh0IDMgZGF5c11dYFxuXHRcdHZhdWx0Lm1vZGlmeSh2YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgoc2NoZWR1bGVOb3RlKSBhcyBURmlsZSwgbm90ZUNvbnRlbnQpO1xuXHR9XG5cblx0YXN5bmMgYWRkQWN0aW9uTm90ZUNvbnRlbnQodmF1bHQ6IFZhdWx0LCBmb2xkZXJOYW1lOiBTdHJpbmcsIG5vdGVUaXRsZVdpdGhvdXRNZDogU3RyaW5nLCBzY2hlZHVsZU5vdGVUaXRsZVdpdGhvdXRNZDogU3RyaW5nLCBuT3JXOiBTdHJpbmcpIHtcblx0XHRjb25zdCBub3dBY3Rpb25Ob3RlV2l0aG91dE1kID0gYCR7Zm9sZGVyTmFtZX0vJHtub3RlVGl0bGVXaXRob3V0TWR9YFxuXHRcdGNvbnN0IG5vd0FjdGlvbk5vdGUgPSBgJHtub3dBY3Rpb25Ob3RlV2l0aG91dE1kfS5tZGBcdFx0XHRcdFxuXHRcdGlmICh2YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgobm93QWN0aW9uTm90ZSkgPT0gbnVsbCkge1xuXHRcdFx0YXdhaXQgdmF1bHQuY3JlYXRlKG5vd0FjdGlvbk5vdGUsIFwiXCIpO1xuXHRcdH1cblx0XHRsZXQgbm93QWN0aW9uTm90ZUNvbnRlbnQgPSAnJ1xuXHRcdEFycmF5LmZyb20oQXJyYXkoMikua2V5cygpKS5mb3JFYWNoKGkgPT4gbm93QWN0aW9uTm90ZUNvbnRlbnQgKz0gdGhpcy5nZXRRdWVyeUFjdGlvblN0cmluZyhpLCBuT3JXKSk7XG5cdFx0bm93QWN0aW9uTm90ZUNvbnRlbnQgKz0gYFxcYFxcYFxcYHF1ZXJ5XFxudGFnOiMke25Pcld9dFxcblxcYFxcYFxcYFxcbmBcblx0XHRub3dBY3Rpb25Ob3RlQ29udGVudCArPSBgXFxgXFxgXFxgcXVlcnlcXG5gXG5cdFx0QXJyYXkuZnJvbShBcnJheSg1KS5rZXlzKCkpLmZvckVhY2goaSA9PiBub3dBY3Rpb25Ob3RlQ29udGVudCArPSB0aGlzLmdldFF1ZXJ5V2Vla0RheShpICsgMiwgbk9yVykpO1xuXHRcdG5vd0FjdGlvbk5vdGVDb250ZW50ICs9IGB0YWc6IyR7bk9yV31uXFxuXFxgXFxgXFxgXFxuYFxuXHRcdG5vd0FjdGlvbk5vdGVDb250ZW50ICs9IGBTY2hlZHVsaW5nOiBbWyR7c2NoZWR1bGVOb3RlVGl0bGVXaXRob3V0TWR9XV1cXG5gXG5cdFx0bm93QWN0aW9uTm90ZUNvbnRlbnQgKz0gYFtbJHtub3RlVGl0bGVXaXRob3V0TWR9XV1cXG5gXG5cblx0XHR2YXVsdC5tb2RpZnkodmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKG5vd0FjdGlvbk5vdGUpIGFzIFRGaWxlLCBub3dBY3Rpb25Ob3RlQ29udGVudCk7XG5cdH1cblxuXHRnZXRRdWVyeURhdGVBbmRBY3Rpb25TdHJpbmcoYWRkRGF5OiBudW1iZXIsIGV4Y2x1ZGVOb3RlczogU3RyaW5nW10pOiBzdHJpbmcge1xuXHRcdGNvbnN0IGRhdGVNb21lbnQgPSBtb21lbnQoKS5hZGQoYWRkRGF5LCAnZCcpO1xuXHRcdGNvbnN0IGRhdGVZWVlZTU1ERCA9IGRhdGVNb21lbnQuZm9ybWF0KCdZWVlZTU1ERCcpO1xuXHRcdGNvbnN0IGRhdGVFYWNoWVlERCA9ICdcXFxcZFxcXFxkXFxcXGRcXFxcZCcgKyBkYXRlTW9tZW50LmZvcm1hdCgnTU1ERCcpO1xuXHRcdGNvbnN0IGRhdGVFYWNoREQgPSAnXFxcXGRcXFxcZFxcXFxkXFxcXGRcXFxcZFxcXFxkJyArIGRhdGVNb21lbnQuZm9ybWF0KCdERCcpO1xuXHRcdGNvbnN0IGRheU9mV2VlayA9IGRhdGVNb21lbnQuZm9ybWF0KCdFJyk7XG5cdFx0Y29uc3QgZGF5T2ZXZWVrTG9uZyA9IGRhdGVNb21lbnQuZm9ybWF0KCdkZGQnKTtcblx0XHRjb25zdCBleGNsdWRlTm90ZVN0ciA9IGV4Y2x1ZGVOb3Rlcy5tYXAoZXhjbHVkZU5vdGUgPT4gYC1wYXRoOlwiJHtleGNsdWRlTm90ZX1cIiBgKS5qb2luKFwiXCIpXG5cdFx0cmV0dXJuIGAjIyAke2RhdGVZWVlZTU1ERH0gJHtkYXlPZldlZWtMb25nfVxcblxcYFxcYFxcYHF1ZXJ5XFxuKFwiICR7ZGF0ZVlZWVlNTUREfVwiIE9SIFwiJHtkYXRlWVlZWU1NRER9IFwiIE9SICR7ZGF0ZUVhY2hZWUREfSBPUiAke2RhdGVFYWNoRER9IE9SIHRhZzojbiR7ZGF5T2ZXZWVrfSBPUiB0YWc6I3cke2RheU9mV2Vla30pICR7ZXhjbHVkZU5vdGVTdHJ9LWJsb2NrOihxdWVyeSlcXG5cXGBcXGBcXGBcXG5cXG5gXG5cdH1cblxuXHRnZXRRdWVyeUFjdGlvbnNUaGlzV2VlayhleGNsdWRlTnVtRGF5czogTnVtYmVyKTogc3RyaW5nIHtcblx0XHRsZXQgZXhjbHVkZXMgOiBudW1iZXJbXSA9IFtdXG5cdFx0bGV0IGluY2x1ZGVzIDogbnVtYmVyW10gPSBbMSwgMiwgMywgNCwgNSwgNiwgN11cblx0XHRcblx0XHRBcnJheS5mcm9tKEFycmF5KGV4Y2x1ZGVOdW1EYXlzKS5rZXlzKCkpLmZvckVhY2goaSA9PiB7XG5cdFx0XHRjb25zdCBkYXRlTW9tZW50ID0gbW9tZW50KCkuYWRkKGksICdkJyk7XG5cdFx0XHRjb25zdCBkYXlPZldlZWsgPSBwYXJzZUludChkYXRlTW9tZW50LmZvcm1hdCgnRScpKTtcblx0XHRcdGV4Y2x1ZGVzLnB1c2goZGF5T2ZXZWVrKVxuXHRcdH0pXG5cdFx0bGV0IGFhYSA9IGluY2x1ZGVzLmZpbHRlcihpID0+IHtcblx0XHRcdGZvciAoY29uc3QgZSBvZiBleGNsdWRlcylcblx0XHRcdHtcblx0XHRcdFx0aWYgKGUgPT0gaSlcblx0XHRcdFx0e1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHJ1ZVxuXHRcdH0pXG5cdFx0bGV0IG91dHB1dCA9IFwiXCJcblx0XHRhYWEuZm9yRWFjaChpID0+IG91dHB1dCArPSBgIE9SIHRhZzojbiR7aX0gT1IgdGFnOiN3JHtpfWApXG5cdFx0cmV0dXJuIG91dHB1dFxuXHR9XG5cblx0Z2V0UXVlcnlGdXR1cmVEYXlzVGhpc1dlZWsoaGVhZGVyOiBTdHJpbmcsIGZyb206IG51bWJlciwgdG86IG51bWJlciwgZXhjbHVkZU5vdGVzOiBTdHJpbmdbXSk6IHN0cmluZyB7XG5cdFx0bGV0IGluY2x1ZGVzID0gW11cblx0XHRmb3IgKGxldCBpID0gZnJvbTsgaSA8PSB0bzsgaSsrKSB7XG5cdFx0XHRsZXQgZGF0ZU1vbWVudCA9IG1vbWVudCgpLmFkZChpLCAnZCcpO1xuXHRcdFx0aW5jbHVkZXMucHVzaChkYXRlTW9tZW50KVxuXHRcdH1cblx0XHRsZXQgb3V0cHV0ID0gYCMjICR7aGVhZGVyfVxcblxcYFxcYFxcYHF1ZXJ5XFxuKGBcblx0XHRpbmNsdWRlcy5mb3JFYWNoKGkgPT4ge1xuXHRcdFx0Y29uc3QgZGF0ZVlZWVlNTUREID0gaS5mb3JtYXQoJ1lZWVlNTUREJyk7XG5cdFx0XHRjb25zdCBkYXRlRWFjaFlZREQgPSAnXFxcXGRcXFxcZFxcXFxkXFxcXGQnICsgaS5mb3JtYXQoJ01NREQnKTtcblx0XHRcdGNvbnN0IGRhdGVFYWNoREQgPSAnXFxcXGRcXFxcZFxcXFxkXFxcXGRcXFxcZFxcXFxkJyArIGkuZm9ybWF0KCdERCcpO1xuXHRcdFx0b3V0cHV0ICs9IGBcIiAke2RhdGVZWVlZTU1ERH1cIiBPUiBcIiR7ZGF0ZVlZWVlNTUREfSBcIiBPUiAke2RhdGVFYWNoWVlERH0gT1IgJHtkYXRlRWFjaEREfSBPUiBgXG5cdFx0fSlcblx0XHRvdXRwdXQgPSBvdXRwdXQucmVwbGFjZSgvIE9SICQvLCBcIlwiKVxuXHRcdG91dHB1dCArPSBcIilcIlxuXHRcdGNvbnN0IGV4Y2x1ZGVOb3RlU3RyID0gZXhjbHVkZU5vdGVzLm1hcChleGNsdWRlTm90ZSA9PiBgLXBhdGg6XCIke2V4Y2x1ZGVOb3RlfVwiIGApLmpvaW4oXCJcIilcblx0XHRvdXRwdXQgKz0gYCAke2V4Y2x1ZGVOb3RlU3RyfS1ibG9jazoocXVlcnkpYFxuXHRcdG91dHB1dCArPSBgXFxuXFxgXFxgXFxgXFxuXFxuYFxuXHRcdHJldHVybiBvdXRwdXRcblx0fVxuXG5cdGdldFF1ZXJ5TmV4dDJNb250aFN0cmluZyhleGNsdWRlTm90ZXM6IFN0cmluZ1tdKTogc3RyaW5nIHtcblx0XHRjb25zdCBjdXJyZW50TW9udGhZWVlZTU0gPSBtb21lbnQoKS5mb3JtYXQoJ1lZWVlNTScpO1xuXHRcdGNvbnN0IGRhdGVNb21lbnQgPSBtb21lbnQoKS5hZGQoMSwgJ00nKTtcblx0XHRjb25zdCBuZXh0TW9udGhZWVlZTU0gPSBkYXRlTW9tZW50LmZvcm1hdCgnWVlZWU1NJyk7XG5cdFx0Y29uc3QgZXhjbHVkZU5vdGVTdHIgPSBleGNsdWRlTm90ZXMubWFwKGV4Y2x1ZGVOb3RlID0+IGAtcGF0aDpcIiR7ZXhjbHVkZU5vdGV9XCIgYCkuam9pbihcIlwiKVxuXHRcdHJldHVybiBgIyMgJHtjdXJyZW50TW9udGhZWVlZTU19IGFuZCAke25leHRNb250aFlZWVlNTX1cXG5cXGBcXGBcXGBxdWVyeVxcbigke2N1cnJlbnRNb250aFlZWVlNTX1cXFxcZFxcXFxkIE9SICR7bmV4dE1vbnRoWVlZWU1NfVxcXFxkXFxcXGQgJHtleGNsdWRlTm90ZVN0cn0tcGF0aDpcIkQvU2NoZWR1bGluZ1wiIC1ibG9jazoocXVlcnkpXFxuXFxgXFxgXFxgXFxuXFxuYFxuXHR9XG5cblx0Z2V0UXVlcnlEYXRlU3RyaW5nKGFkZERheTogbnVtYmVyLCBleGNsdWRlTm90ZTogU3RyaW5nKTogc3RyaW5nIHtcblx0XHRjb25zdCBkYXRlTW9tZW50ID0gbW9tZW50KCkuYWRkKGFkZERheSwgJ2QnKTtcblx0XHRjb25zdCBkYXRlWVlZWU1NREQgPSBkYXRlTW9tZW50LmZvcm1hdCgnWVlZWU1NREQnKTtcblx0XHRjb25zdCBkYXRlRWFjaFlZREQgPSAnXFxcXGRcXFxcZFxcXFxkXFxcXGQnICsgZGF0ZU1vbWVudC5mb3JtYXQoJ01NREQnKTtcblx0XHRjb25zdCBkYXRlRWFjaEREID0gJ1xcXFxkXFxcXGRcXFxcZFxcXFxkXFxcXGRcXFxcZCcgKyBkYXRlTW9tZW50LmZvcm1hdCgnREQnKTtcblx0XHRyZXR1cm4gYCR7ZGF0ZVlZWVlNTUREfVxcblxcYFxcYFxcYHF1ZXJ5XFxuKCR7ZGF0ZVlZWVlNTUREfSBPUiAke2RhdGVFYWNoWVlERH0gT1IgJHtkYXRlRWFjaEREfSkgLXBhdGg6XCIke2V4Y2x1ZGVOb3RlfVwiIC1ibG9jazoocXVlcnkpXFxuXFxgXFxgXFxgXFxuYFxuXHR9XG5cblx0Z2V0UXVlcnlBY3Rpb25TdHJpbmcoYWRkRGF5OiBudW1iZXIsIGFjdGlvblR5cGU6IFN0cmluZyk6IHN0cmluZyB7XG5cdFx0Y29uc3QgZGF0ZU1vbWVudCA9IG1vbWVudCgpLmFkZChhZGREYXksICdkJyk7XG5cdFx0Y29uc3QgZGF5T2ZXZWVrID0gZGF0ZU1vbWVudC5mb3JtYXQoJ0UnKTtcblx0XHRyZXR1cm4gYFxcYFxcYFxcYHF1ZXJ5XFxudGFnOiMke2FjdGlvblR5cGV9JHtkYXlPZldlZWt9XFxuXFxgXFxgXFxgXFxuYFxuXHR9XG5cblx0Z2V0UXVlcnlXZWVrRGF5KGFkZERheTogbnVtYmVyLCBhY3Rpb25UeXBlOiBTdHJpbmcpOiBzdHJpbmcge1xuXHRcdGNvbnN0IGRhdGVNb21lbnQgPSBtb21lbnQoKS5hZGQoYWRkRGF5LCAnZCcpO1xuXHRcdGNvbnN0IGRheU9mV2VlayA9IGRhdGVNb21lbnQuZm9ybWF0KCdFJyk7XG5cdFx0cmV0dXJuIGB0YWc6IyR7YWN0aW9uVHlwZX0ke2RheU9mV2Vla30gT1IgYFxuXHR9XG5cdCAgXG5cdGFkZE5ld0xhdGVyQWN0aW9uSWNvbih0OiBzdHJpbmcpIHtcblx0XHR0aGlzLmFkZE9ic2lkaWFuSWNvbihgJHt0fWwtaWNvbi1uZXdgLCBgJHt0fWxgKTtcblx0fVxuXHQgIFxuXHRhZGRBY3Rpb25JY29uKHQ6IHN0cmluZykge1xuXHRcdHRoaXMuYWRkT2JzaWRpYW5JY29uKGAke3R9LWljb25gLCBgIyR7dH1gKTtcblx0fVxuXG5cdGFkZE9ic2lkaWFuSWNvbihpY29uTmFtZTogc3RyaW5nLCBpY29uVGV4dDogc3RyaW5nKSB7XG5cdFx0Y29uc3Qgc3ZnID0gYDx0ZXh0IHN0cm9rZT0nIzAwMCcgdHJhbnNmb3JtPSdtYXRyaXgoMi43OTE2NyAwIDAgMi4xMjY2MyAtMzQuMDQxNyAtMjUuMjA4NCknIHhtbDpzcGFjZT0ncHJlc2VydmUnIHRleHQtYW5jaG9yPSdzdGFydCcgZm9udC1mYW1pbHk9J21vbm9zcGFjZScgZm9udC1zaXplPScyNCcgeT0nNDQnIHg9JzE5JyBzdHJva2Utd2lkdGg9JzAnIGZpbGw9J2N1cnJlbnRDb2xvcic+JHtpY29uVGV4dH08L3RleHQ+YDtcblx0XHRhZGRJY29uKGljb25OYW1lLCBzdmcpO1xuXHR9XG5cblx0YWRkTmV3TGF0ZXJBY3Rpb24odDogc3RyaW5nKSB7XG5cdFx0dGhpcy5hZGRDb21tYW5kKHtcblx0XHRcdGlkOiBgYWRkLW5ldy0ke3R9LWxhdGVyLWFjdGlvbmAsXG5cdFx0XHRuYW1lOiBgQWRkICR7dH1sIHRhc2tgLFxuXHRcdFx0aWNvbjogYCR7dH1sLWljb24tbmV3YCxcblx0XHRcdGVkaXRvckNhbGxiYWNrOiAoZWRpdG9yOiBFZGl0b3IsIHZpZXc6IE1hcmtkb3duVmlldykgPT4ge1xuXHRcdFx0XHRjb25zdCBjdXJzb3IgPSBlZGl0b3IuZ2V0Q3Vyc29yKCk7XG5cdFx0XHRcdGVkaXRvci5yZXBsYWNlUmFuZ2UoYCMke3R9bCBgLCBjdXJzb3IpO1xuXHRcdFx0XHRjdXJzb3IuY2ggPSBjdXJzb3IuY2ggKyA0O1xuXHRcdFx0XHRlZGl0b3Iuc2V0Q3Vyc29yKGN1cnNvcik7XG5cdFx0XHR9LyosXG5cdFx0XHRob3RrZXlzOiBbXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRtb2RpZmllcnM6IFtgQ3RybGAsIGBNZXRhYCwgYFNoaWZ0YF0sXG5cdFx0XHRcdFx0a2V5OiB0ID09ICduJyA/ICcxJyA6ICcyJ1xuXHRcdFx0XHR9LFxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bW9kaWZpZXJzOiBbYEN0cmxgLCBgQWx0YCwgYFNoaWZ0YF0sXG5cdFx0XHRcdFx0a2V5OiB0ID09ICduJyA/ICcxJyA6ICcyJ1xuXHRcdFx0XHR9XG5cdFx0XHRdKi9cblx0XHR9KTtcblx0fVxuXG5cdGFkZEFjdGlvbkNvbW1hbmQodDogc3RyaW5nKSB7XG5cdFx0dGhpcy5hZGRDb21tYW5kKHtcblx0XHRcdGlkOiBgdG8tdyR7dH0tbiR7dH1gLFxuXHRcdFx0bmFtZTogYFRvIHcke3R9IG9yIG4ke3R9YCxcblx0XHRcdGljb246IGAke3R9LWljb25gLFxuXHRcdFx0ZWRpdG9yQ2FsbGJhY2s6IChlZGl0b3I6IEVkaXRvciwgdmlldzogTWFya2Rvd25WaWV3KSA9PiB7XG5cdFx0XHRcdGNvbnNvbGUubG9nKGVkaXRvci5nZXRTZWxlY3Rpb24oKSk7XG5cdFx0XHRcdGNvbnN0IGN1cnNvciA9IGVkaXRvci5nZXRDdXJzb3IoKTtcblx0XHRcdFx0Y29uc3QgbGluZU51bWJlciA9IGVkaXRvci5nZXRDdXJzb3IoKS5saW5lO1xuXHRcdFx0XHRjb25zdCBsaW5lID0gZWRpdG9yLmdldExpbmUobGluZU51bWJlcik7XG5cdFx0XHRcdGNvbnN0IHJlcGxhY2VkTGluZSA9IGxpbmUucmVwbGFjZSgvIGFcXC93XFwvLi8sIGAgYS93LyR7dH1gKVxuXHRcdFx0XHQgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLyBhXFwvblxcLy4vLCBgIGEvbi8ke3R9YClcblx0XHRcdFx0XHRcdFx0XHQgXHQgXHQgLnJlcGxhY2UoLyN3LiAvLCBgI3cke3R9IGApXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCAucmVwbGFjZSgvI24uIC8sIGAjbiR7dH0gYClcblx0XHRcdFx0XHRcdFx0XHRcdFx0IC5yZXBsYWNlKC8jdy4kLywgYCN3JHt0fWApXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCAucmVwbGFjZSgvI24uJC8sIGAjbiR7dH1gKVxuXHRcdFx0XHRpZiAobGluZS5jb250YWlucyhgI24ke3R9IGApIHx8IGxpbmUuY29udGFpbnMoYCN3JHt0fSBgKSkge1xuXHRcdFx0XHRcdGNvbnN0IG50ID0gYCNuJHt0fSBgXG5cdFx0XHRcdFx0Y29uc3Qgd3QgPSBgI3cke3R9IGBcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRjb25zdCByZXBsYWNlTGluZVRvUmVtb3ZlVGFnID0gbGluZS5yZXBsYWNlKGAjbiR7dH0gYCwgYGApLnJlcGxhY2UoYCN3JHt0fSBgLCBgYClcblx0XHRcdFx0XHRlZGl0b3Iuc2V0TGluZShsaW5lTnVtYmVyLCByZXBsYWNlTGluZVRvUmVtb3ZlVGFnKTtcblx0XHRcdFx0XHQvLyBsZXRzIHNheSBcIiNudCBcIiBpcyBhdCAzIChjaGFyIGZvciAjKVxuXHRcdFx0XHRcdC8vIGlmIGNoIDw9IDMgbm8gbmVlZCB0byB1cGRhdGVcblx0XHRcdFx0XHQvLyBpZiBjaCA+PSA3IHRoZW4gbmVlZCB0byAtNFxuXHRcdFx0XHRcdC8vIGVsc2UgY2ggPT0gM1xuXHRcdFx0XHRcdGNvbnN0IG50SW5kZXggPSBsaW5lLmluZGV4T2YobnQpXG5cdFx0XHRcdFx0Y29uc3Qgd3RJbmRleCA9IGxpbmUuaW5kZXhPZih3dClcblx0XHRcdFx0XHRjb25zdCBpbmRleCA9IG50SW5kZXggPT0gLTEgPyB3dEluZGV4IDogbnRJbmRleFxuXHRcdFx0XHRcdGNvbnN0IG5ld0NoID0gY3Vyc29yLmNoIDw9IGluZGV4ID8gY3Vyc29yLmNoIDogKGN1cnNvci5jaCA+PSBpbmRleCArIDQgPyBjdXJzb3IuY2ggLSA0IDogaW5kZXgpXG5cdFx0XHRcdFx0Y3Vyc29yLmNoID0gbmV3Q2hcblx0XHRcdFx0XHRlZGl0b3Iuc2V0Q3Vyc29yKGN1cnNvcik7XG5cdFx0XHRcdH0gZWxzZSBpZiAobGluZS5jb250YWlucyhgICNuJHt0fWApIHx8IGxpbmUuY29udGFpbnMoYCAjdyR7dH1gKSkge1xuXHRcdFx0XHRcdGNvbnN0IG50ID0gYCNuJHt0fSBgXG5cdFx0XHRcdFx0Y29uc3Qgd3QgPSBgI3cke3R9IGBcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRjb25zdCByZXBsYWNlTGluZVRvUmVtb3ZlVGFnID0gbGluZS5yZXBsYWNlKGAgI24ke3R9YCwgYGApLnJlcGxhY2UoYCAjdyR7dH1gLCBgYClcblx0XHRcdFx0XHRlZGl0b3Iuc2V0TGluZShsaW5lTnVtYmVyLCByZXBsYWNlTGluZVRvUmVtb3ZlVGFnKTtcblx0XHRcdFx0XHQvLyBsZXRzIHNheSBcIiNudCBcIiBpcyBhdCAzIChjaGFyIGZvciAjKVxuXHRcdFx0XHRcdC8vIGlmIGNoIDw9IDMgbm8gbmVlZCB0byB1cGRhdGVcblx0XHRcdFx0XHQvLyBpZiBjaCA+PSA3IHRoZW4gbmVlZCB0byAtNFxuXHRcdFx0XHRcdC8vIGVsc2UgY2ggPT0gM1xuXHRcdFx0XHRcdGNvbnN0IG50SW5kZXggPSBsaW5lLmluZGV4T2YobnQpXG5cdFx0XHRcdFx0Y29uc3Qgd3RJbmRleCA9IGxpbmUuaW5kZXhPZih3dClcblx0XHRcdFx0XHRjb25zdCBpbmRleCA9IG50SW5kZXggPT0gLTEgPyB3dEluZGV4IDogbnRJbmRleFxuXHRcdFx0XHRcdGNvbnN0IG5ld0NoID0gY3Vyc29yLmNoIDw9IGluZGV4ID8gY3Vyc29yLmNoIDogKGN1cnNvci5jaCA+PSBpbmRleCArIDQgPyBjdXJzb3IuY2ggLSA0IDogaW5kZXgpXG5cdFx0XHRcdFx0Y3Vyc29yLmNoID0gbmV3Q2hcblx0XHRcdFx0XHRlZGl0b3Iuc2V0Q3Vyc29yKGN1cnNvcik7XG5cdFx0XHRcdH0gZWxzZSBpZiAobGluZS5jb250YWlucyhgIGEvbi8ke3R9YCkgfHwgbGluZS5jb250YWlucyhgIGEvdy8ke3R9YCkpIHtcblx0XHRcdFx0XHQvLyBkbyBub3RoaW5nXG5cdFx0XHRcdH0gZWxzZSBpZiAocmVwbGFjZWRMaW5lID09IGxpbmUpIHsgLy8gbm8gdGFnLCB0byBhZGQgdGFnXG5cdFx0XHRcdFx0bmV3IEFkZFRhc2tUYWdNb2RhbCh0aGlzLmFwcCwgZWRpdG9yLCB0KS5vcGVuKCk7XG5cdFx0XHRcdH0gZWxzZSB7XHRcdFx0IFxuXHRcdFx0XHRcdGVkaXRvci5zZXRMaW5lKGxpbmVOdW1iZXIsIHJlcGxhY2VkTGluZSk7XG5cdFx0XHRcdFx0ZWRpdG9yLnNldEN1cnNvcihjdXJzb3IpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0aG90a2V5czogW1xuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bW9kaWZpZXJzOiB0aGlzLmlzMVRvNyh0KSA/IFtgQ3RybGAsIGBNZXRhYF0gOiBbYEN0cmxgLCBgTWV0YWAsIGBTaGlmdGBdLFxuXHRcdFx0XHRcdGtleTogYCR7dH1gLFxuXHRcdFx0XHR9LFxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bW9kaWZpZXJzOiB0aGlzLmlzMVRvNyh0KSA/IFtgQ3RybGAsIGBBbHRgXSA6IFtgQ3RybGAsIGBBbHRgLCBgU2hpZnRgXSxcblx0XHRcdFx0XHRrZXk6IGAke3R9YCxcblx0XHRcdFx0fVxuXHRcdFx0XVxuXHRcdH0pO1xuXHR9XG5cblx0YWRkRm9sbG93VXBDb21tYW5kKHQ6IHN0cmluZykge1xuXHRcdGxldCBuYW1lID0gXCJcIlxuXHRcdGlmICh0ID09PSAndCcpIHtcblx0XHRcdG5hbWUgPSAnVG8gVHJ5J1xuXHRcdH0gZWxzZSBpZiAodCA9PT0gJ2UnKSB7XG5cdFx0XHRuYW1lID0gJ1RvIEV4cGxvcmUnXG5cdFx0fSBlbHNlIGlmICh0ID09PSAnbScpIHtcblx0XHRcdG5hbWUgPSAnVG8gTW92ZSdcblx0XHR9XG5cdFx0dGhpcy5hZGRDb21tYW5kKHtcblx0XHRcdGlkOiBgdG8tdCR7dH1gLFxuXHRcdFx0bmFtZTogYFRvIHQke3R9ICR7bmFtZX1gLFxuXHRcdFx0aWNvbjogYCR7dH0taWNvbmAsXG5cdFx0XHRlZGl0b3JDYWxsYmFjazogKGVkaXRvcjogRWRpdG9yLCB2aWV3OiBNYXJrZG93blZpZXcpID0+IHtcblx0XHRcdFx0Y29uc29sZS5sb2coZWRpdG9yLmdldFNlbGVjdGlvbigpKTtcblx0XHRcdFx0Y29uc3QgY3Vyc29yID0gZWRpdG9yLmdldEN1cnNvcigpO1xuXHRcdFx0XHRjb25zdCBsaW5lTnVtYmVyID0gZWRpdG9yLmdldEN1cnNvcigpLmxpbmU7XG5cdFx0XHRcdGNvbnN0IGxpbmUgPSBlZGl0b3IuZ2V0TGluZShsaW5lTnVtYmVyKTtcblx0XHRcdFx0Y29uc3QgcmVwbGFjZWRMaW5lID0gbGluZS5yZXBsYWNlKC8jdC4gLywgYCN0JHt0fSBgKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQgLnJlcGxhY2UoLyN0LiQvLCBgI3Qke3R9YClcblx0XHRcdFx0aWYgKGxpbmUuY29udGFpbnMoYCN0JHt0fSBgKSkge1xuXHRcdFx0XHRcdGNvbnN0IHR0ID0gYCN0JHt0fSBgXG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Y29uc3QgcmVwbGFjZUxpbmVUb1JlbW92ZVRhZyA9IGxpbmUucmVwbGFjZShgI3Qke3R9IGAsIGBgKVxuXHRcdFx0XHRcdGVkaXRvci5zZXRMaW5lKGxpbmVOdW1iZXIsIHJlcGxhY2VMaW5lVG9SZW1vdmVUYWcpO1xuXHRcdFx0XHRcdC8vIGxldHMgc2F5IFwiI3R0IFwiIGlzIGF0IDMgKGNoYXIgZm9yICMpXG5cdFx0XHRcdFx0Ly8gaWYgY2ggPD0gMyBubyBuZWVkIHRvIHVwZGF0ZVxuXHRcdFx0XHRcdC8vIGlmIGNoID49IDcgdGhlbiBuZWVkIHRvIC00XG5cdFx0XHRcdFx0Ly8gZWxzZSBjaCA9PSAzXG5cdFx0XHRcdFx0Y29uc3QgdHRJbmRleCA9IGxpbmUuaW5kZXhPZih0dClcblx0XHRcdFx0XHRjb25zdCBpbmRleCA9IHR0SW5kZXhcblx0XHRcdFx0XHRjb25zdCBuZXdDaCA9IGN1cnNvci5jaCA8PSBpbmRleCA/IGN1cnNvci5jaCA6IChjdXJzb3IuY2ggPj0gaW5kZXggKyA0ID8gY3Vyc29yLmNoIC0gNCA6IGluZGV4KVxuXHRcdFx0XHRcdGN1cnNvci5jaCA9IG5ld0NoXG5cdFx0XHRcdFx0ZWRpdG9yLnNldEN1cnNvcihjdXJzb3IpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKGxpbmUuY29udGFpbnMoYCAjdCR7dH1gKSkge1xuXHRcdFx0XHRcdGNvbnN0IHR0ID0gYCN0JHt0fSBgXG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0Y29uc3QgcmVwbGFjZUxpbmVUb1JlbW92ZVRhZyA9IGxpbmUucmVwbGFjZShgICN0JHt0fWAsIGBgKVxuXHRcdFx0XHRcdGVkaXRvci5zZXRMaW5lKGxpbmVOdW1iZXIsIHJlcGxhY2VMaW5lVG9SZW1vdmVUYWcpO1xuXHRcdFx0XHRcdC8vIGxldHMgc2F5IFwiI3R0IFwiIGlzIGF0IDMgKGNoYXIgZm9yICMpXG5cdFx0XHRcdFx0Ly8gaWYgY2ggPD0gMyBubyBuZWVkIHRvIHVwZGF0ZVxuXHRcdFx0XHRcdC8vIGlmIGNoID49IDcgdGhlbiBuZWVkIHRvIC00XG5cdFx0XHRcdFx0Ly8gZWxzZSBjaCA9PSAzXG5cdFx0XHRcdFx0Y29uc3QgdHRJbmRleCA9IGxpbmUuaW5kZXhPZih0dClcblx0XHRcdFx0XHRjb25zdCBpbmRleCA9IHR0SW5kZXhcblx0XHRcdFx0XHRjb25zdCBuZXdDaCA9IGN1cnNvci5jaCA8PSBpbmRleCA/IGN1cnNvci5jaCA6IChjdXJzb3IuY2ggPj0gaW5kZXggKyA0ID8gY3Vyc29yLmNoIC0gNCA6IGluZGV4KVxuXHRcdFx0XHRcdGN1cnNvci5jaCA9IG5ld0NoXG5cdFx0XHRcdFx0ZWRpdG9yLnNldEN1cnNvcihjdXJzb3IpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHJlcGxhY2VkTGluZSA9PSBsaW5lKSB7IC8vIG5vIHRhZywgdG8gYWRkIHRhZ1xuXHRcdFx0XHRcdGNvbnN0IGN1cnNvciA9IGVkaXRvci5nZXRDdXJzb3IoKVxuXHRcdFx0XHRcdGNvbnN0IGxpbmUgPSBlZGl0b3IuZ2V0TGluZShjdXJzb3IubGluZSk7XG5cdFx0XHRcdFx0ZWRpdG9yLnJlcGxhY2VSYW5nZShgJHtsaW5lLmNoYXJBdChjdXJzb3IuY2ggLSAxKSAhPSAnICcgPyAnICcgOiBcIlwifSN0JHt0fSBgLCBjdXJzb3IpOyAgXG5cdFx0XHRcdFx0Y3Vyc29yLmNoID0gY3Vyc29yLmNoICsgNCArIChsaW5lLmNoYXJBdChjdXJzb3IuY2ggLSAxKSAhPSAnICcgPyAxIDogMCk7XG5cdFx0XHRcdFx0ZWRpdG9yLnNldEN1cnNvcihjdXJzb3IpO1xuXHRcdFx0XHR9IGVsc2Uge1x0XHRcdCBcblx0XHRcdFx0XHRlZGl0b3Iuc2V0TGluZShsaW5lTnVtYmVyLCByZXBsYWNlZExpbmUpO1xuXHRcdFx0XHRcdGVkaXRvci5zZXRDdXJzb3IoY3Vyc29yKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGhvdGtleXM6IFtcblx0XHRcdFx0e1xuXHRcdFx0XHRcdG1vZGlmaWVyczogW2BDdHJsYCwgYE1ldGFgLCBgU2hpZnRgXSxcblx0XHRcdFx0XHRrZXk6IGAke3R9YCxcblx0XHRcdFx0fSxcblx0XHRcdFx0e1xuXHRcdFx0XHRcdG1vZGlmaWVyczogW2BDdHJsYCwgYEFsdGAsIGBTaGlmdGBdLFxuXHRcdFx0XHRcdGtleTogYCR7dH1gLFxuXHRcdFx0XHR9XG5cdFx0XHRdXG5cdFx0fSk7XG5cdH1cblxuXG5cdGlzMVRvNyh0OiBzdHJpbmcpIDogYm9vbGVhbiB7XG5cdFx0aWYgKHQgPT0gXCIxXCIgfHwgdCA9PSBcIjJcIiB8fCB0ID09IFwiM1wiIHx8IHQgPT0gXCI0XCIgfHwgdCA9PSBcIjVcIiB8fCB0ID09IFwiNlwiIHx8IHQgPT0gXCI3XCIpIHtcblx0XHRcdHJldHVybiB0cnVlXG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiBmYWxzZVxuXHRcdH1cblx0fVxuXG5cdGFkZFRvQ2xpcGJvYXJkSGlzdG9yeShjb250ZW50OiBzdHJpbmcpIHtcblx0XHRjb25zdCBpbmRleCA9IGNsaXBib2FyZEhpc3RvcnkuaW5kZXhPZihjb250ZW50LCAwKTtcblx0XHRpZiAoaW5kZXggPiAtMSkge1xuXHRcdFx0Y2xpcGJvYXJkSGlzdG9yeS5zcGxpY2UoaW5kZXgsIDEpO1xuXHRcdH1cblx0XHRpZiAoY29udGVudC5sZW5ndGggPiAwKSB7XG5cdFx0XHRjbGlwYm9hcmRIaXN0b3J5LnB1c2goY29udGVudCk7XG5cdFx0fVxuXHR9XG5cblx0b251bmxvYWQoKSB7XG5cblx0fVxuXG5cdGFzeW5jIGxvYWRTZXR0aW5ncygpIHtcblx0XHR0aGlzLnNldHRpbmdzID0gT2JqZWN0LmFzc2lnbih7fSwgREVGQVVMVF9TRVRUSU5HUywgYXdhaXQgdGhpcy5sb2FkRGF0YSgpKTtcblx0fVxuXG5cdGFzeW5jIHNhdmVTZXR0aW5ncygpIHtcblx0XHRhd2FpdCB0aGlzLnNhdmVEYXRhKHRoaXMuc2V0dGluZ3MpO1xuXHR9XG59XG5cbmNsYXNzIFNhbXBsZVNldHRpbmdUYWIgZXh0ZW5kcyBQbHVnaW5TZXR0aW5nVGFiIHtcblx0cGx1Z2luOiBNeVBsdWdpbjtcblxuXHRjb25zdHJ1Y3RvcihhcHA6IEFwcCwgcGx1Z2luOiBNeVBsdWdpbikge1xuXHRcdHN1cGVyKGFwcCwgcGx1Z2luKTtcblx0XHR0aGlzLnBsdWdpbiA9IHBsdWdpbjtcblx0fVxuXG5cdGRpc3BsYXkoKTogdm9pZCB7XG5cdFx0Y29uc3Qge2NvbnRhaW5lckVsfSA9IHRoaXM7XG5cblx0XHRjb250YWluZXJFbC5lbXB0eSgpO1xuXG5cdFx0Y29udGFpbmVyRWwuY3JlYXRlRWwoJ2gyJywge3RleHQ6ICdTZXR0aW5ncyBmb3IgbXkgYXdlc29tZSBwbHVnaW4uJ30pO1xuXG5cdFx0bmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG5cdFx0XHQuc2V0TmFtZSgnU2V0dGluZyAjMScpXG5cdFx0XHQuc2V0RGVzYygnSXRcXCdzIGEgc2VjcmV0Jylcblx0XHRcdC5hZGRUZXh0KHRleHQgPT4gdGV4dFxuXHRcdFx0XHQuc2V0UGxhY2Vob2xkZXIoJ0VudGVyIHlvdXIgc2VjcmV0Jylcblx0XHRcdFx0LnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLm15U2V0dGluZylcblx0XHRcdFx0Lm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuXHRcdFx0XHRcdGNvbnNvbGUubG9nKCdTZWNyZXQ6ICcgKyB2YWx1ZSk7XG5cdFx0XHRcdFx0dGhpcy5wbHVnaW4uc2V0dGluZ3MubXlTZXR0aW5nID0gdmFsdWU7XG5cdFx0XHRcdFx0YXdhaXQgdGhpcy5wbHVnaW4uc2F2ZVNldHRpbmdzKCk7XG5cdFx0XHRcdH0pKTtcblx0fVxufVxuXG5cbiIsICJpbXBvcnQgeyBBcHAsIEVkaXRvciwgRnV6enlTdWdnZXN0TW9kYWwsIEZ1enp5TWF0Y2gsIFRGaWxlLCBOb3RpY2UgfSBmcm9tIFwib2JzaWRpYW5cIjtcbmltcG9ydCB7IGhhc0Zyb250TWF0dGVyLCBoYXNUYWdzLCByZW5hbWVUYWcgfSBmcm9tIFwidGFncmVuYW1lci9yZW5hbWluZ1wiO1xuaW1wb3J0IHtGaWxlfSBmcm9tIFwidGFncmVuYW1lci9GaWxlXCI7XG5cbmludGVyZmFjZSBOb3RlVHlwZSB7XG4gIHR5cGU6IHN0cmluZztcbiAgZGVzY3JpcHRpb246IHN0cmluZztcbn1cblxuY29uc3QgQUxMX1RZUEVTID0gW1xuICB7XG4gICAgdHlwZTogXCJhL24vblwiLFxuICAgIGRlc2NyaXB0aW9uOiBcIk4gQ3VycmVudCBUYXNrXCIsXG4gIH0sXG4gIHtcbiAgICB0eXBlOiBcImEvdy9uXCIsXG4gICAgZGVzY3JpcHRpb246IFwiVyBDdXJyZW50IFRhc2tcIixcbiAgfSxcbiAge1xuICAgIHR5cGU6IFwiYS9uL2xcIixcbiAgICBkZXNjcmlwdGlvbjogXCJOIExhdGVyIFRhc2tcIixcbiAgfSxcbiAge1xuICAgIHR5cGU6IFwiYS93L2xcIixcbiAgICBkZXNjcmlwdGlvbjogXCJXIExhdGVyIFRhc2tcIixcbiAgfSxcbiAge1xuICAgIHR5cGU6IFwiYS9uL3BcIixcbiAgICBkZXNjcmlwdGlvbjogXCJOIFBlcm1hbmVudCBUYXNrXCIsXG4gIH0sXG4gIHtcbiAgICB0eXBlOiBcImEvdy9wXCIsXG4gICAgZGVzY3JpcHRpb246IFwiVyBQZXJtYW5lbnQgVGFza1wiLFxuICB9LFxuICB7XG4gICAgdHlwZTogXCJiL24vc1wiLFxuICAgIGRlc2NyaXB0aW9uOiBcIlpldHRlbGthc3RlbiAtIFNvdXJjZSBub3RlcyAobGlrZSBib29rcyAvIHZpZGVvIC8gdGhvdWdodHMgLyBjb252ZXJzYXRpb24pXCIsXG4gIH0sXG4gIHtcbiAgICB0eXBlOiBcImIvbi9jXCIsXG4gICAgZGVzY3JpcHRpb246IFwiWmV0dGVsa2FzdGVuIC0gQ2FyZHMgKFdpdGggeW91ciBvd24gdGhvdWdodClcIixcbiAgfSxcbiAge1xuICAgIHR5cGU6IFwiYy90L2RcIixcbiAgICBkZXNjcmlwdGlvbjogXCJUaHJlYWRzIHBvc3QgZHJhZnRcIixcbiAgfSxcbiAge1xuICAgIHR5cGU6IFwiYy9iL2RcIixcbiAgICBkZXNjcmlwdGlvbjogXCJCbG9nIHBvc3QgZHJhZnRcIixcbiAgfSxcbiAge1xuICAgIHR5cGU6IFwiYi9uL3VcIixcbiAgICBkZXNjcmlwdGlvbjogXCJaZXR0ZWxrYXN0ZW4gLSBVbnByb2Nlc3NlZCBtYXRlcmlhbCBsaWtlIGFuIGluYm94XCIsXG4gIH0sXG4gIHtcbiAgICB0eXBlOiBcImIvbi9tXCIsXG4gICAgZGVzY3JpcHRpb246IFwiWmV0dGVsa2FzdGVuIC0gTU9DIE5vdGVzIGZvciBhIHNtYWxsIHRvcGljXCIsXG4gIH0sXG4gIHtcbiAgICB0eXBlOiBcImIvbi96XCIsXG4gICAgZGVzY3JpcHRpb246IFwiWmV0dGVsa2FzdGVuIC0gU2xpcCBib3ggKG1haW5seSBvbiB0aG91Z2h0IGFuZCB0aGUgb25lIEkgYW0gaW50ZXJlc3RlZClcIixcbiAgfSxcbiAge1xuICAgIHR5cGU6IFwiYi9uL2lcIixcbiAgICBkZXNjcmlwdGlvbjogXCJJbmRleCBOb3RlcyBmb3Igc2VsZiBmcmFtZXdvcmtcIixcbiAgfSxcbiAge1xuICAgIHR5cGU6IFwiYi9uL3dcIixcbiAgICBkZXNjcmlwdGlvbjogXCJXaWtpIE5vdGVzIGZvciBhIG1lc3N5IHdpa2kgdG9waWNcIixcbiAgfSxcbiAge1xuICAgIHR5cGU6IFwiYi9uL3ZcIixcbiAgICBkZXNjcmlwdGlvbjogXCJaZXR0ZWxrYXN0ZW4gLSBWb2ljZSBzY3JpcHQgKERlcHJlY2F0ZWQ/KVwiLFxuICB9LFxuICB7XG4gICAgdHlwZTogXCJiL24vclwiLFxuICAgIGRlc2NyaXB0aW9uOiBcIlpldHRlbGthc3RlbiAtIFJlZmVyZW5jZSAoRGVwcmVjYXRlZD8pXCIsXG4gIH0sXG4gIHtcbiAgICB0eXBlOiBcImIvbi9wXCIsXG4gICAgZGVzY3JpcHRpb246IFwiUGxhY2Vob2xkZXIgTm90ZXMgKERlcHJlY2F0ZWQ/KVwiLFxuICB9LFxuICB7XG4gICAgdHlwZTogXCJiL2EvcFwiLFxuICAgIGRlc2NyaXB0aW9uOiBcIkFyZWEgb2YgUmVzcG9uc2liaWxpdHkgLSBQcmltYXJ5XCIsXG4gIH0sXG4gIHtcbiAgICB0eXBlOiBcImIvYS9zXCIsXG4gICAgZGVzY3JpcHRpb246IFwiQXJlYSBvZiBSZXNwb25zaWJpbGl0eSAtIFNlY29uZGFyeVwiLFxuICB9LFxuICB7XG4gICAgdHlwZTogXCJjL2IvaVwiLFxuICAgIGRlc2NyaXB0aW9uOiBcIkJsb2cgcG9zdCBjb250ZW50IGNvbXBsZXRlZCBidXQgYXdhaXRpbmcgdXBsb2FkIGltYWdlXCIsXG4gIH0sXG4gIHtcbiAgICB0eXBlOiBcImMvYi9yXCIsXG4gICAgZGVzY3JpcHRpb246IFwiQmxvZyBwb3N0IHJlYWR5IHRvIHB1Ymxpc2hcIixcbiAgfSxcbiAge1xuICAgIHR5cGU6IFwiYy9iL3BcIixcbiAgICBkZXNjcmlwdGlvbjogXCJCbG9nIHBvc3QgcHVibGlzaGVkXCIsXG4gIH0sXG4gIHtcbiAgICB0eXBlOiBcImMvYi9pXCIsXG4gICAgZGVzY3JpcHRpb246IFwiQmxvZyBwb3N0IHNlcmllcyBpbmRleFwiLFxuICB9LFxuICB7XG4gICAgdHlwZTogXCJjL2IvYVwiLFxuICAgIGRlc2NyaXB0aW9uOiBcIkJsb2cgcG9zdCBhYmFuZG9uZWRcIixcbiAgfSxcbiAge1xuICAgIHR5cGU6IFwiYy9iL29cIixcbiAgICBkZXNjcmlwdGlvbjogXCJCbG9nIHBvc3Qgb3V0bGluZWQgKERlcHJlY2F0ZWQ/KVwiLFxuICB9LFxuICB7XG4gICAgdHlwZTogXCJjL2IvZlwiLFxuICAgIGRlc2NyaXB0aW9uOiBcIkJsb2cgcG9zdCBmaW5lIHR1bmVkIChEZXByZWNhdGVkPylcIixcbiAgfSxcbiAge1xuICAgIHR5cGU6IFwiYy90L3JcIixcbiAgICBkZXNjcmlwdGlvbjogXCJUaHJlYWRzIHBvc3QgcmVhZHkgdG8gcG9zdFwiLFxuICB9LFxuICB7XG4gICAgdHlwZTogXCJjL3QvdFwiLFxuICAgIGRlc2NyaXB0aW9uOiBcIlRocmVhZHMgcG9zdCB0aHJlYWRzIHB1Ymxpc2hlZFwiLFxuICB9LFxuICB7XG4gICAgdHlwZTogXCJjL3QvcFwiLFxuICAgIGRlc2NyaXB0aW9uOiBcIlRocmVhZHMgcG9zdCBwdWJsaXNoZWRcIixcbiAgfSxcbiAge1xuICAgIHR5cGU6IFwiYy90L2lcIixcbiAgICBkZXNjcmlwdGlvbjogXCJUaHJlYWRzIHBvc3Qgc2VyaWVzIGluZGV4XCIsXG4gIH0sXG4gIHtcbiAgICB0eXBlOiBcImMvdC9hXCIsXG4gICAgZGVzY3JpcHRpb246IFwiVGhyZWFkcyBwb3N0IGFiYW5kb25lZFwiLFxuICB9LFxuICB7XG4gICAgdHlwZTogXCJjL3gvZFwiLFxuICAgIGRlc2NyaXB0aW9uOiBcIlR3aXR0ZXIgcG9zdCBkcmFmdGluZ1wiLFxuICB9LFxuICB7XG4gICAgdHlwZTogXCJjL3gvclwiLFxuICAgIGRlc2NyaXB0aW9uOiBcIlR3aXR0ZXIgcG9zdCByZWFkeSB0byBwdWJsaXNoXCIsXG4gIH0sXG4gIHtcbiAgICB0eXBlOiBcImMveC9wXCIsXG4gICAgZGVzY3JpcHRpb246IFwiVHdpdHRlciBwb3N0IHB1Ymxpc2hlZFwiLFxuICB9LFxuICB7XG4gICAgdHlwZTogXCJhL24vd1wiLFxuICAgIGRlc2NyaXB0aW9uOiBcIk4gV2FpdGluZyBUYXNrXCIsXG4gIH0sXG4gIHtcbiAgICB0eXBlOiBcImEvbi9kXCIsXG4gICAgZGVzY3JpcHRpb246IFwiTiBEb25lIFRhc2tcIixcbiAgfSxcbiAge1xuICAgIHR5cGU6IFwiYS9uL2FcIixcbiAgICBkZXNjcmlwdGlvbjogXCJOIEFyY2hpdmUgVGFza1wiLFxuICB9LFxuICB7XG4gICAgdHlwZTogXCJhL3cvd1wiLFxuICAgIGRlc2NyaXB0aW9uOiBcIlcgV2FpdGluZyBUYXNrXCIsXG4gIH0sXG4gIHtcbiAgICB0eXBlOiBcImEvdy9kXCIsXG4gICAgZGVzY3JpcHRpb246IFwiVyBEb25lIFRhc2tcIixcbiAgfSxcbiAge1xuICAgIHR5cGU6IFwiYS93L2FcIixcbiAgICBkZXNjcmlwdGlvbjogXCJXIEFyY2hpdmUgVGFza1wiLFxuICB9LFxuXTtcblxuZXhwb3J0IGNsYXNzIFVwZGF0ZU5vdGVUeXBlTW9kYWwgZXh0ZW5kcyBGdXp6eVN1Z2dlc3RNb2RhbDxOb3RlVHlwZT4ge1xuXG4gIGVkaXRvcjogRWRpdG9yXG4gIGZpbGU6IFRGaWxlXG5cbiAgY29uc3RydWN0b3IoYXBwOiBBcHAsIGVkaXRvcjogRWRpdG9yLCBmaWxlOiBURmlsZSlcbiAge1xuICAgIHN1cGVyKGFwcClcbiAgICB0aGlzLmVkaXRvciA9IGVkaXRvclxuICAgIHRoaXMuZmlsZSA9IGZpbGVcbiAgfVxuXG4gIGdldEl0ZW1zKCk6IE5vdGVUeXBlW10ge1xuICAgIHJldHVybiBBTExfVFlQRVM7XG4gIH1cblxuICBnZXRJdGVtVGV4dChub3RlVHlwZTogTm90ZVR5cGUpOiBzdHJpbmcge1xuICAgIHJldHVybiBub3RlVHlwZS50eXBlO1xuICB9XG5cbiAgLy8gUmVuZGVycyBlYWNoIHN1Z2dlc3Rpb24gaXRlbS5cbiAgcmVuZGVyU3VnZ2VzdGlvbihjaG9vc2VuTm90ZVR5cGVNYXRjaDogRnV6enlNYXRjaDxOb3RlVHlwZT4sIGVsOiBIVE1MRWxlbWVudCkge1xuICAgIGNvbnN0IG5vdGVUeXBlID0gY2hvb3Nlbk5vdGVUeXBlTWF0Y2guaXRlbVxuICAgIGVsLmNyZWF0ZUVsKFwiZGl2XCIsIHsgdGV4dDogbm90ZVR5cGUudHlwZSB9KTtcbiAgICBlbC5jcmVhdGVFbChcInNtYWxsXCIsIHsgdGV4dDogbm90ZVR5cGUuZGVzY3JpcHRpb24gfSk7XG4gIH1cblxuICBjb250YWluc1R5cGUobGluZTogU3RyaW5nKSA6IEJvb2xlYW4ge1xuICAgIHJldHVybiBBTExfVFlQRVMuZmlsdGVyKChub3RlVHlwZSkgPT4gbGluZS5jb250YWlucyhub3RlVHlwZS50eXBlKSkubGVuZ3RoID4gMFxuICB9XG5cbiAgYWRkRnJvbnRNYXR0ZXJXaXRoVGFnKHZhbHVlOiBzdHJpbmcpIHtcbiAgICBjb25zdCBjdXJzb3IgPSB0aGlzLmVkaXRvci5nZXRDdXJzb3IoKVxuICAgIGNvbnN0IG9sZExpbmUgPSBjdXJzb3IubGluZVxuICAgIGNvbnN0IG9sZENoID0gY3Vyc29yLmNoXG4gICAgY29uc3QgYWRkVGV4dCA9IGAtLS1cXG50YWdzOiAke3ZhbHVlfVxcbi0tLVxcblxcbiR7dGhpcy5lZGl0b3IuZ2V0VmFsdWUoKX1gXG4gICAgdGhpcy5lZGl0b3Iuc2V0VmFsdWUoYWRkVGV4dClcbiAgICBjdXJzb3IubGluZSA9IG9sZExpbmUgKyA0XG4gICAgY3Vyc29yLmNoID0gb2xkQ2hcbiAgICB0aGlzLmVkaXRvci5zZXRDdXJzb3IoY3Vyc29yKVxuICB9XG5cbiAgYWRkVGFnQXNzdW1pbmdIYXNGcm9udE1hdHRlcih2YWx1ZTogc3RyaW5nKSB7XG4gICAgY29uc3QgY3Vyc29yID0gdGhpcy5lZGl0b3IuZ2V0Q3Vyc29yKClcbiAgICBjb25zdCBvbGRMaW5lID0gY3Vyc29yLmxpbmVcbiAgICBjb25zdCBvbGRDaCA9IGN1cnNvci5jaFxuXG4gICAgbGV0IGZpcnN0TGluZUluZGV4ID0gMDtcbiAgICBjb25zdCBsaW5lQ291bnQgPSB0aGlzLmVkaXRvci5saW5lQ291bnQoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmVDb3VudDsgaSsrKSB7XG4gICAgICBpZiAodGhpcy5lZGl0b3IuZ2V0TGluZShpKS50cmltKCkgPT0gXCItLS1cIi50cmltKCkpIHtcbiAgICAgICAgZmlyc3RMaW5lSW5kZXggPSBpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGZpcnN0TGluZUluZGV4ID09IGxpbmVDb3VudCkge1xuICAgICAgbmV3IE5vdGljZShcIlNvbWV0aGluZyB3cm9uZyBoZXJlXCIpXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCB0ZXh0ID0gXCJcIlxuICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IGZpcnN0TGluZUluZGV4OyBpKyspIHtcbiAgICAgIHRleHQgPSB0ZXh0ICsgdGhpcy5lZGl0b3IuZ2V0TGluZShpKSArIFwiXFxuXCI7XG4gICAgfVxuICAgIHRleHQgPSB0ZXh0ICsgYHRhZ3M6ICR7dmFsdWV9XFxuYFxuICAgIGZvciAobGV0IGkgPSBmaXJzdExpbmVJbmRleCArIDE7IGkgPD0gdGhpcy5lZGl0b3IubGluZUNvdW50KCk7IGkrKykge1xuICAgICAgdGV4dCA9IHRleHQgKyB0aGlzLmVkaXRvci5nZXRMaW5lKGkpICsgXCJcXG5cIjtcbiAgICB9XG5cbiAgICB0aGlzLmVkaXRvci5zZXRWYWx1ZSh0ZXh0KVxuICAgIGN1cnNvci5saW5lID0gb2xkTGluZSArIChvbGRMaW5lIDw9IGZpcnN0TGluZUluZGV4ID8gMCA6IDEpXG4gICAgY3Vyc29yLmNoID0gb2xkQ2hcbiAgICB0aGlzLmVkaXRvci5zZXRDdXJzb3IoY3Vyc29yKVxuICB9XG5cbiAgLy8gUGVyZm9ybSBhY3Rpb24gb24gdGhlIHNlbGVjdGVkIHN1Z2dlc3Rpb24uXG4gIG9uQ2hvb3NlSXRlbShjaG9vc2VuTm90ZVR5cGU6IE5vdGVUeXBlLCBldnQ6IE1vdXNlRXZlbnQgfCBLZXlib2FyZEV2ZW50KSB7XG4gICAgaWYgKCFoYXNGcm9udE1hdHRlcih0aGlzLmZpbGUpKSB7XG4gICAgICB0aGlzLmFkZEZyb250TWF0dGVyV2l0aFRhZyhjaG9vc2VuTm90ZVR5cGUudHlwZSlcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGhhc1RhZ3ModGhpcy5maWxlKSlcbiAgICAgIHtcbiAgICAgICAgQUxMX1RZUEVTLmZvckVhY2godCA9PiB7XG4gICAgICAgICAgcmVuYW1lVGFnKHRoaXMuZmlsZSwgdC50eXBlLCBjaG9vc2VuTm90ZVR5cGUudHlwZSlcbiAgICAgICAgICB9KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gbmV3IE5vdGljZShcImFkZGluZyB0YWcgdG9kb1wiKVxuICAgICAgICAvLyBuZXcgRmlsZShhcHAsIHRoaXMuZmlsZS5wYXRoLCBudWxsLCAwKS5yZXBsYWNlSW5Gcm9udE1hdHRlcjtcblxuICAgICAgICAvLyBUT0RPIGFkZCB0YWdzXG4gICAgICAgIHRoaXMuYWRkVGFnQXNzdW1pbmdIYXNGcm9udE1hdHRlcihjaG9vc2VuTm90ZVR5cGUudHlwZSlcbiAgICAgIH1cbiAgICB9XG4gIH1cbn0iLCAiaW1wb3J0IHtBcHAsIE1hcmtkb3duVmlldywgTm90aWNlLCBUQWJzdHJhY3RGaWxlLCBURmlsZSwgcGFyc2VGcm9udE1hdHRlckFsaWFzZXMsIHBhcnNlRnJvbnRNYXR0ZXJUYWdzfSBmcm9tIFwib2JzaWRpYW5cIjtcbmltcG9ydCB7VGFnLCBSZXBsYWNlbWVudH0gZnJvbSBcIi4vVGFnXCI7XG5pbXBvcnQge0ZpbGV9IGZyb20gXCIuL0ZpbGVcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIGhhc0Zyb250TWF0dGVyKGZpbGU6IFRGaWxlKSA6IGJvb2xlYW4ge1xuICAgIGxldCB7IGZyb250bWF0dGVyIH0gPSBhcHAubWV0YWRhdGFDYWNoZS5nZXRGaWxlQ2FjaGUoZmlsZSkgfHwge307XG4gICAgcmV0dXJuIGZyb250bWF0dGVyICE9IG51bGxcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGhhc1RhZ3MoZmlsZTogVEZpbGUpIDogYm9vbGVhbiB7XG4gICAgbGV0IHsgZnJvbnRtYXR0ZXIgfSA9IGFwcC5tZXRhZGF0YUNhY2hlLmdldEZpbGVDYWNoZShmaWxlKSB8fCB7fTtcbiAgICBjb25zdCBmbXRhZ3MgPSAocGFyc2VGcm9udE1hdHRlclRhZ3MoZnJvbnRtYXR0ZXIpIHx8IFtdKTtcbiAgICBjb25zdCBhbGlhc1RhZ3MgPSAocGFyc2VGcm9udE1hdHRlckFsaWFzZXMoZnJvbnRtYXR0ZXIpIHx8IFtdKS5maWx0ZXIoVGFnLmlzVGFnKTtcbiAgICByZXR1cm4gKGZtdGFncy5sZW5ndGggfHwgYWxpYXNUYWdzLmxlbmd0aCkgPyB0cnVlIDogZmFsc2Vcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJlbmFtZVRhZyhmaWxlOiBURmlsZSwgdGFnTmFtZTogc3RyaW5nLCBuZXdOYW1lOnN0cmluZykgOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICBjb25zdFxuICAgICAgICBvbGRUYWcgID0gbmV3IFRhZyh0YWdOYW1lKSxcbiAgICAgICAgbmV3VGFnICA9IG5ldyBUYWcobmV3TmFtZSksXG4gICAgICAgIHJlcGxhY2UgPSBuZXcgUmVwbGFjZW1lbnQob2xkVGFnLCBuZXdUYWcpXG5cbiAgICBjb25zdCB0YXJnZXQgPSBhd2FpdCBmaW5kVGFyZ2V0cyhvbGRUYWcsIGZpbGUpO1xuICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgYXdhaXQgdGFyZ2V0LnJlbmFtZWQocmVwbGFjZSlcbiAgICByZXR1cm4gdHJ1ZVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZmluZFRhcmdldHModGFnOiBUYWcsIGZpbGU6IFRGaWxlKSB7XG4gICAgbGV0IHsgZnJvbnRtYXR0ZXIsIHRhZ3MgfSA9IGFwcC5tZXRhZGF0YUNhY2hlLmdldEZpbGVDYWNoZShmaWxlKSB8fCB7fTtcbiAgICBjb25zdCBmbXRhZ3MgPSAocGFyc2VGcm9udE1hdHRlclRhZ3MoZnJvbnRtYXR0ZXIpIHx8IFtdKS5maWx0ZXIodGFnLm1hdGNoZXMpO1xuICAgIGNvbnN0IGFsaWFzVGFncyA9IChwYXJzZUZyb250TWF0dGVyQWxpYXNlcyhmcm9udG1hdHRlcikgfHwgW10pLmZpbHRlcihUYWcuaXNUYWcpLmZpbHRlcih0YWcubWF0Y2hlcyk7XG4gICAgaWYgKGZtdGFncy5sZW5ndGggfHwgYWxpYXNUYWdzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gbmV3IEZpbGUoYXBwLCBmaWxlLnBhdGgsIHRhZ3MsIGZtdGFncy5sZW5ndGggKyBhbGlhc1RhZ3MubGVuZ3RoKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZW5hbWVCbG9nVGl0bGUoYXBwIDogQXBwLCBwYXRoOiBzdHJpbmcsIHZpZXc6IE1hcmtkb3duVmlldykgOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBsZXQgbW9tZW50ID0gcmVxdWlyZSgnbW9tZW50Jyk7XG4gICAgY29uc3QgZGF0ZVlZWVlNTUREID0gbW9tZW50KCkuZm9ybWF0KCdZWVlZTU1ERCcpO1xuICAgIGxldCByZW5hbWVkUGF0aCA9IFwiXCJcbiAgICBpZiAocGF0aC5tYXRjaCgvXi5cXC9CbG9nIFxcZFxcZFxcZFxcZFxcZFxcZFxcZFxcZC8pKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxuICAgIH0gZWxzZSBpZiAocGF0aC5tYXRjaCgvXi5cXC9ibG9nIFxcZFxcZFxcZFxcZFxcZFxcZFxcZFxcZC8pKSB7XG4gICAgICAgIG5ldyBOb3RpY2UoXCJzdGFydCB3aXRoIGJsb2cgd2l0aCBkYXRlLCByZW5hbWluZyBibG9nIHRvIEJsb2dcIilcbiAgICAgICAgcmVuYW1lZFBhdGggPSBwYXRoLnJlcGxhY2UoL14oLlxcLylibG9nIC8sIGAkMUJsb2cgYClcbiAgICAgICAgcmV0dXJuIHJlbmFtZUZpbGUoYXBwLCB2aWV3LmZpbGUsIHJlbmFtZWRQYXRoKTtcbiAgICB9IGVsc2UgaWYgKHBhdGgubWF0Y2goL14uXFwvQmxvZyAvKSkge1xuICAgICAgICBuZXcgTm90aWNlKFwic3RhcnRzIHdpdGggQmxvZyBidXQgbm8gZGF0ZSwgYWRkaW5nIGRhdGVcIilcbiAgICAgICAgcmVuYW1lZFBhdGggPSBwYXRoLnJlcGxhY2UoL14oLlxcL0Jsb2cgKS8sIGAkMSR7ZGF0ZVlZWVlNTUREfSBgKVxuICAgICAgICByZXR1cm4gcmVuYW1lRmlsZShhcHAsIHZpZXcuZmlsZSwgcmVuYW1lZFBhdGgpO1xuICAgIH0gZWxzZSBpZiAocGF0aC5tYXRjaCgvXi5cXC9ibG9nIC8pKSB7XG4gICAgICAgIG5ldyBOb3RpY2UoXCJzdGFydHMgd2l0aCBibG9nIGJ1dCBubyBkYXRlLCBhZGRpbmcgZGF0ZVwiKVxuICAgICAgICByZW5hbWVkUGF0aCA9IHBhdGgucmVwbGFjZSgvXiguXFwvKWJsb2cgLywgYCQxQmxvZyAke2RhdGVZWVlZTU1ERH0gYClcbiAgICAgICAgcmV0dXJuIHJlbmFtZUZpbGUoYXBwLCB2aWV3LmZpbGUsIHJlbmFtZWRQYXRoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBuZXcgTm90aWNlKFwic3RhcnRzIHdpdGhvdXQgYmxvZywgYWRkaW5nIEJsb2cgKyBkYXRlXCIpXG4gICAgICAgIHJlbmFtZWRQYXRoID0gcGF0aC5yZXBsYWNlKC9eKC5cXC8pLywgYCQxQmxvZyAke2RhdGVZWVlZTU1ERH0gYClcbiAgICAgICAgcmV0dXJuIHJlbmFtZUZpbGUoYXBwLCB2aWV3LmZpbGUsIHJlbmFtZWRQYXRoKTtcbiAgICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHJlbmFtZUZpbGUoYXBwIDogQXBwLCBmaWxlIDogVEFic3RyYWN0RmlsZSwgbmV3UGF0aDogc3RyaW5nKSB7XG4gICAgYXBwLmZpbGVNYW5hZ2VyLnJlbmFtZUZpbGUoZmlsZSwgbmV3UGF0aClcbn1cblxuXG4iLCAiY29uc3QgdGFnQm9keSA9IC9eI1teXFx1MjAwMC1cXHUyMDZGXFx1MkUwMC1cXHUyRTdGJyFcIiMkJSYoKSorLC46Ozw9Pj9AXmB7fH1+XFxbXFxdXFxcXFxcc10rJC87XG5cbmV4cG9ydCBjbGFzcyBUYWcge1xuICAgIHRhZzogYW55O1xuICAgIGNhbm9uaWNhbF9wcmVmaXg6IHN0cmluZztcbiAgICBjYW5vbmljYWw6IHN0cmluZztcbiAgICBuYW1lOiBhbnk7XG4gICAgbWF0Y2hlczogKHRleHQ6IGFueSkgPT4gYW55O1xuICAgIGNvbnN0cnVjdG9yKG5hbWU6IGFueSkge1xuICAgICAgICBjb25zdFxuICAgICAgICAgICAgaGFzaGVkID0gdGhpcy50YWcgPSBUYWcudG9UYWcobmFtZSksXG4gICAgICAgICAgICBjYW5vbmljYWwgPSB0aGlzLmNhbm9uaWNhbCA9IGhhc2hlZC50b0xvd2VyQ2FzZSgpLFxuICAgICAgICAgICAgY2Fub25pY2FsX3ByZWZpeCA9IHRoaXMuY2Fub25pY2FsX3ByZWZpeCA9IGNhbm9uaWNhbCArIFwiL1wiO1xuICAgICAgICB0aGlzLm5hbWUgPSBoYXNoZWQuc2xpY2UoMSk7XG4gICAgICAgIHRoaXMubWF0Y2hlcyA9IGZ1bmN0aW9uICh0ZXh0KSB7XG4gICAgICAgICAgICB0ZXh0ID0gdGV4dC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgcmV0dXJuIHRleHQgPT0gY2Fub25pY2FsIHx8IHRleHQuc3RhcnRzV2l0aChjYW5vbmljYWxfcHJlZml4KTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7IHJldHVybiB0aGlzLnRhZzsgfVxuXG4gICAgc3RhdGljIGlzVGFnKHM6IHN0cmluZykgeyByZXR1cm4gdGFnQm9keS50ZXN0KHMpOyB9XG5cbiAgICBzdGF0aWMgdG9UYWcobmFtZTogc3RyaW5nKSB7XG4gICAgICAgIHdoaWxlIChuYW1lLnN0YXJ0c1dpdGgoXCIjI1wiKSkgbmFtZSA9IG5hbWUuc2xpY2UoMSk7XG4gICAgICAgIHJldHVybiBuYW1lLnN0YXJ0c1dpdGgoXCIjXCIpID8gbmFtZSA6IFwiI1wiK25hbWU7XG4gICAgfVxuXG4gICAgc3RhdGljIGNhbm9uaWNhbChuYW1lOiBhbnkpIHtcbiAgICAgICAgcmV0dXJuIFRhZy50b1RhZyhuYW1lKS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cbn1cblxuZXhwb3J0IGNsYXNzIFJlcGxhY2VtZW50IHtcbiAgICBpblN0cmluZzogKHRleHQ6IGFueSwgcG9zPzogbnVtYmVyKSA9PiBhbnk7XG4gICAgaW5BcnJheTogKHRhZ3M6IGFueSwgc2tpcE9kZDogYW55LCBpc0FsaWFzOiBhbnkpID0+IGFueTtcbiAgICB3aWxsTWVyZ2VUYWdzOiAodGFnTmFtZXM6IGFueSkgPT4gVGFnW10gfCB1bmRlZmluZWQ7XG5cbiAgICBjb25zdHJ1Y3Rvcihmcm9tVGFnOiBUYWcsIHRvVGFnOiBUYWcpIHtcbiAgICAgICAgY29uc3QgY2FjaGUgPSAgT2JqZWN0LmFzc2lnbihcbiAgICAgICAgICAgIE9iamVjdC5jcmVhdGUobnVsbCksIHtcbiAgICAgICAgICAgICAgICBbZnJvbVRhZy50YWddOiAgdG9UYWcudGFnLFxuICAgICAgICAgICAgICAgIFtmcm9tVGFnLm5hbWVdOiB0b1RhZy5uYW1lLFxuICAgICAgICAgICAgfVxuICAgICAgICApO1xuXG4gICAgICAgIHRoaXMuaW5TdHJpbmcgPSBmdW5jdGlvbih0ZXh0LCBwb3MgPSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGV4dC5zbGljZSgwLCBwb3MpICsgdG9UYWcudGFnICsgdGV4dC5zbGljZShwb3MgKyBmcm9tVGFnLnRhZy5sZW5ndGgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5pbkFycmF5ID0gKHRhZ3MsIHNraXBPZGQsIGlzQWxpYXMpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0YWdzLm1hcCgodDogc3RyaW5nLCBpOiBudW1iZXIpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoc2tpcE9kZCAmJiAoaSAmIDEpKSByZXR1cm4gdDsgICAvLyBsZWF2ZSBvZGQgZW50cmllcyAoc2VwYXJhdG9ycykgYWxvbmVcbiAgICAgICAgICAgICAgICAvLyBPYnNpZGlhbiBhbGxvd3Mgc3BhY2VzIGFzIHNlcGFyYXRvcnMgd2l0aGluIGFycmF5IGVsZW1lbnRzXG4gICAgICAgICAgICAgICAgaWYgKCF0KSByZXR1cm4gdDtcbiAgICAgICAgICAgICAgICAvLyBTa2lwIG5vbi10YWcgcGFydHNcbiAgICAgICAgICAgICAgICBpZiAoaXNBbGlhcykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXQuc3RhcnRzV2l0aChcIiNcIikgfHwgIVRhZy5pc1RhZyh0KSkgcmV0dXJuIHQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICgvWyAsXFxuXS8udGVzdCh0KSkge1xuICAgICAgICAgICAgICAgICAgICAvLyByZXR1cm4gdGhpcy5pbkFycmF5KHQuc3BsaXQoLyhbLCBcXG5dKykvKSwgdHJ1ZSkuam9pbihcIlwiKTsgLy8gbm90IHN1cmVcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5BcnJheSh0LnNwbGl0KC8oWywgXFxuXSspLyksIHRydWUsIGlzQWxpYXMpLmpvaW4oXCJcIik7IC8vIG5vdCBzdXJlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjYWNoZVt0XSkgcmV0dXJuIGNhY2hlW3RdO1xuICAgICAgICAgICAgICAgIGNvbnN0IGxjID0gdC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIGlmIChjYWNoZVtsY10pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhY2hlW3RdID0gY2FjaGVbbGNdO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobGMuc3RhcnRzV2l0aChmcm9tVGFnLmNhbm9uaWNhbF9wcmVmaXgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWNoZVt0XSA9IGNhY2hlW2xjXSA9IHRoaXMuaW5TdHJpbmcodCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICgoXCIjXCIgKyBsYykuc3RhcnRzV2l0aChmcm9tVGFnLmNhbm9uaWNhbF9wcmVmaXgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWNoZVt0XSA9IGNhY2hlW2xjXSA9IHRoaXMuaW5TdHJpbmcoXCIjXCIgKyB0KS5zbGljZSgxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhY2hlW3RdID0gY2FjaGVbbGNdID0gdDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMud2lsbE1lcmdlVGFncyA9IGZ1bmN0aW9uICh0YWdOYW1lcykge1xuICAgICAgICAgICAgLy8gUmVuYW1pbmcgdG8gY2hhbmdlIGNhc2UgZG9lc24ndCBsb3NlIGluZm8sIHNvIGlnbm9yZSBpdFxuICAgICAgICAgICAgaWYgKGZyb21UYWcuY2Fub25pY2FsID09PSB0b1RhZy5jYW5vbmljYWwpIHJldHVybjtcblxuICAgICAgICAgICAgY29uc3QgZXhpc3RpbmcgPSBuZXcgU2V0KHRhZ05hbWVzLm1hcCgoczogc3RyaW5nKSA9PiBzLnRvTG93ZXJDYXNlKCkpKTtcblxuICAgICAgICAgICAgZm9yIChjb25zdCB0YWdOYW1lIG9mIHRhZ05hbWVzLmZpbHRlcihmcm9tVGFnLm1hdGNoZXMpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2hhbmdlZCA9IHRoaXMuaW5TdHJpbmcodGFnTmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKGV4aXN0aW5nLmhhcyhjaGFuZ2VkLnRvTG93ZXJDYXNlKCkpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW25ldyBUYWcodGFnTmFtZSksIG5ldyBUYWcoY2hhbmdlZCldO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cbiAgICB9XG59XG5cblxuIiwgImltcG9ydCB7IE5vdGljZSB9IGZyb20gXCJvYnNpZGlhblwiO1xuaW1wb3J0IHsgQ1NULCBwYXJzZURvY3VtZW50IH0gZnJvbSBcInlhbWxcIjtcbmltcG9ydCB7IFJlcGxhY2VtZW50IH0gZnJvbSBcIi4vVGFnXCI7XG5cbmV4cG9ydCBjbGFzcyBGaWxlIHtcbiAgICBhcHA6IGFueTtcbiAgICBmaWxlbmFtZTogYW55O1xuICAgIGJhc2VuYW1lOiBhbnk7XG4gICAgdGFnUG9zaXRpb25zOiBhbnk7XG4gICAgaGFzRnJvbnRNYXR0ZXI6IGJvb2xlYW47XG5cbiAgICBjb25zdHJ1Y3RvcihhcHA6IGFueSwgZmlsZW5hbWU6IHN0cmluZywgdGFnUG9zaXRpb25zOiBhbnksIGhhc0Zyb250TWF0dGVyOiBudW1iZXIpIHtcbiAgICAgICAgdGhpcy5hcHAgPSBhcHA7XG4gICAgICAgIHRoaXMuZmlsZW5hbWUgPSBmaWxlbmFtZTtcbiAgICAgICAgdGhpcy5iYXNlbmFtZSA9IGZpbGVuYW1lLnNwbGl0KFwiL1wiKS5wb3AoKTtcbiAgICAgICAgdGhpcy50YWdQb3NpdGlvbnMgPSB0YWdQb3NpdGlvbnM7XG4gICAgICAgIHRoaXMuaGFzRnJvbnRNYXR0ZXIgPSAhIWhhc0Zyb250TWF0dGVyO1xuICAgIH1cblxuICAgIC8qKiBAcGFyYW0ge1JlcGxhY2VtZW50fSByZXBsYWNlICovXG4gICAgYXN5bmMgcmVuYW1lZChyZXBsYWNlIDogUmVwbGFjZW1lbnQpIHtcbiAgICAgICAgY29uc3QgZmlsZSA9IHRoaXMuYXBwLnZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aCh0aGlzLmZpbGVuYW1lKTtcbiAgICAgICAgY29uc3Qgb3JpZ2luYWwgPSBhd2FpdCB0aGlzLmFwcC52YXVsdC5yZWFkKGZpbGUpO1xuICAgICAgICBsZXQgdGV4dCA9IG9yaWdpbmFsO1xuXG4gICAgICAgIGlmICh0aGlzLmhhc0Zyb250TWF0dGVyKSB7XG4gICAgICAgICAgICB0ZXh0ID0gdGhpcy5yZXBsYWNlSW5Gcm9udE1hdHRlcih0ZXh0LCByZXBsYWNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0ZXh0ICE9PSBvcmlnaW5hbCkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5hcHAudmF1bHQubW9kaWZ5KGZpbGUsIHRleHQpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogQHBhcmFtIHtSZXBsYWNlbWVudH0gcmVwbGFjZSAqL1xuICAgIHJlcGxhY2VJbkZyb250TWF0dGVyKHRleHQ6IHsgc3BsaXQ6IChhcmcwOiBSZWdFeHAsIGFyZzE6IG51bWJlcikgPT4gW2FueSwgYW55XTsgcmVwbGFjZTogKGFyZzA6IGFueSwgYXJnMTogYW55KSA9PiBhbnk7IH0sIHJlcGxhY2U6IHsgaW5BcnJheTogKGFyZzA6IGFueVtdLCBhcmcxOiBib29sZWFuLCBhcmcyOiBhbnkpID0+IGFueVtdOyB9KSB7XG4gICAgICAgIGNvbnN0IFtlbXB0eSwgZnJvbnRNYXR0ZXJdID0gdGV4dC5zcGxpdCgvXi0tLVxccj8kXFxuPy9tLCAyKTtcblxuICAgICAgICAvLyBDaGVjayBmb3IgdmFsaWQsIG5vbi1lbXB0eSwgcHJvcGVybHkgdGVybWluYXRlZCBmcm9udCBtYXR0ZXJcbiAgICAgICAgaWYgKGVtcHR5LnRyaW0oKSAhPT0gXCJcIiB8fCAhZnJvbnRNYXR0ZXIudHJpbSgpIHx8ICFmcm9udE1hdHRlci5lbmRzV2l0aChcIlxcblwiKSlcbiAgICAgICAgICAgIHJldHVybiB0ZXh0O1xuXG4gICAgICAgIGNvbnN0IHBhcnNlZCA9IHBhcnNlRG9jdW1lbnQoZnJvbnRNYXR0ZXIsIHtrZWVwU291cmNlVG9rZW5zOiB0cnVlfSk7XG4gICAgICAgIGlmIChwYXJzZWQuZXJyb3JzLmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBgWUFNTCBpc3N1ZSB3aXRoICR7dGhpcy5maWxlbmFtZX06ICR7cGFyc2VkLmVycm9yc1swXX1gO1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7IG5ldyBOb3RpY2UoZXJyb3IgKyBcIjsgc2tpcHBpbmcgZnJvbnRtYXR0ZXJcIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgY2hhbmdlZCA9IGZhbHNlLCBqc29uID0gcGFyc2VkLnRvSlNPTigpO1xuXG4gICAgICAgIGZ1bmN0aW9uIHNldEluTm9kZShub2RlOiB7IHNyY1Rva2VuOiBhbnk7IHZhbHVlOiBhbnk7IH0sIHZhbHVlOiBhbnksIGFmdGVyS2V5PWZhbHNlKSB7XG4gICAgICAgICAgICBDU1Quc2V0U2NhbGFyVmFsdWUobm9kZS5zcmNUb2tlbiwgdmFsdWUsIHthZnRlcktleX0pO1xuICAgICAgICAgICAgY2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICBub2RlLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBwcm9jZXNzRmllbGQocHJvcDogc3RyaW5nIHwgbnVtYmVyLCBpc0FsaWFzOiBib29sZWFuKSB7XG4gICAgICAgICAgICBjb25zdCBub2RlID0gcGFyc2VkLmdldChwcm9wLCB0cnVlKTtcbiAgICAgICAgICAgIGlmICghbm9kZSkgcmV0dXJuO1xuICAgICAgICAgICAgY29uc3QgZmllbGQgPSBqc29uW3Byb3BdO1xuICAgICAgICAgICAgaWYgKCFmaWVsZCB8fCAhZmllbGQubGVuZ3RoKSByZXR1cm47XG4gICAgICAgICAgICBpZiAodHlwZW9mIGZpZWxkID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFydHMgPSBmaWVsZC5zcGxpdChpc0FsaWFzID8gLyheXFxzK3xcXHMqLFxccyp8XFxzKyQpLyA6IC8oW1xccyxdKykvKTtcbiAgICAgICAgICAgICAgICBjb25zdCBhZnRlciA9IHJlcGxhY2UuaW5BcnJheShwYXJ0cywgdHJ1ZSwgaXNBbGlhcykuam9pbihcIlwiKTtcbiAgICAgICAgICAgICAgICBpZiAoZmllbGQgIT0gYWZ0ZXIpIHNldEluTm9kZShub2RlLCBhZnRlciwgdHJ1ZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoZmllbGQpKSB7XG4gICAgICAgICAgICAgICAgcmVwbGFjZS5pbkFycmF5KGZpZWxkLCBmYWxzZSwgaXNBbGlhcykuZm9yRWFjaCgodjogYW55LCBpOiBudW1iZXIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpZWxkW2ldICE9PSB2KSBzZXRJbk5vZGUobm9kZS5nZXQoaSwgdHJ1ZSksIHYpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGNvbnN0IHtrZXk6IHt2YWx1ZTpwcm9wfX0gb2YgcGFyc2VkLmNvbnRlbnRzLml0ZW1zKSB7XG4gICAgICAgICAgICBpZiAoL150YWdzPyQvaS50ZXN0KHByb3ApKSB7XG4gICAgICAgICAgICAgICAgcHJvY2Vzc0ZpZWxkKHByb3AsIGZhbHNlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoL15hbGlhcyhlcyk/JC9pLnRlc3QocHJvcCkpIHtcbiAgICAgICAgICAgICAgICBwcm9jZXNzRmllbGQocHJvcCwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNoYW5nZWQgPyB0ZXh0LnJlcGxhY2UoZnJvbnRNYXR0ZXIsIENTVC5zdHJpbmdpZnkocGFyc2VkLmNvbnRlbnRzLnNyY1Rva2VuKSkgOiB0ZXh0O1xuICAgIH1cbn1cbiIsICJjb25zdCBBTElBUyA9IFN5bWJvbC5mb3IoJ3lhbWwuYWxpYXMnKTtcbmNvbnN0IERPQyA9IFN5bWJvbC5mb3IoJ3lhbWwuZG9jdW1lbnQnKTtcbmNvbnN0IE1BUCA9IFN5bWJvbC5mb3IoJ3lhbWwubWFwJyk7XG5jb25zdCBQQUlSID0gU3ltYm9sLmZvcigneWFtbC5wYWlyJyk7XG5jb25zdCBTQ0FMQVIgPSBTeW1ib2wuZm9yKCd5YW1sLnNjYWxhcicpO1xuY29uc3QgU0VRID0gU3ltYm9sLmZvcigneWFtbC5zZXEnKTtcbmNvbnN0IE5PREVfVFlQRSA9IFN5bWJvbC5mb3IoJ3lhbWwubm9kZS50eXBlJyk7XG5jb25zdCBpc0FsaWFzID0gKG5vZGUpID0+ICEhbm9kZSAmJiB0eXBlb2Ygbm9kZSA9PT0gJ29iamVjdCcgJiYgbm9kZVtOT0RFX1RZUEVdID09PSBBTElBUztcbmNvbnN0IGlzRG9jdW1lbnQgPSAobm9kZSkgPT4gISFub2RlICYmIHR5cGVvZiBub2RlID09PSAnb2JqZWN0JyAmJiBub2RlW05PREVfVFlQRV0gPT09IERPQztcbmNvbnN0IGlzTWFwID0gKG5vZGUpID0+ICEhbm9kZSAmJiB0eXBlb2Ygbm9kZSA9PT0gJ29iamVjdCcgJiYgbm9kZVtOT0RFX1RZUEVdID09PSBNQVA7XG5jb25zdCBpc1BhaXIgPSAobm9kZSkgPT4gISFub2RlICYmIHR5cGVvZiBub2RlID09PSAnb2JqZWN0JyAmJiBub2RlW05PREVfVFlQRV0gPT09IFBBSVI7XG5jb25zdCBpc1NjYWxhciA9IChub2RlKSA9PiAhIW5vZGUgJiYgdHlwZW9mIG5vZGUgPT09ICdvYmplY3QnICYmIG5vZGVbTk9ERV9UWVBFXSA9PT0gU0NBTEFSO1xuY29uc3QgaXNTZXEgPSAobm9kZSkgPT4gISFub2RlICYmIHR5cGVvZiBub2RlID09PSAnb2JqZWN0JyAmJiBub2RlW05PREVfVFlQRV0gPT09IFNFUTtcbmZ1bmN0aW9uIGlzQ29sbGVjdGlvbihub2RlKSB7XG4gICAgaWYgKG5vZGUgJiYgdHlwZW9mIG5vZGUgPT09ICdvYmplY3QnKVxuICAgICAgICBzd2l0Y2ggKG5vZGVbTk9ERV9UWVBFXSkge1xuICAgICAgICAgICAgY2FzZSBNQVA6XG4gICAgICAgICAgICBjYXNlIFNFUTpcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGlzTm9kZShub2RlKSB7XG4gICAgaWYgKG5vZGUgJiYgdHlwZW9mIG5vZGUgPT09ICdvYmplY3QnKVxuICAgICAgICBzd2l0Y2ggKG5vZGVbTk9ERV9UWVBFXSkge1xuICAgICAgICAgICAgY2FzZSBBTElBUzpcbiAgICAgICAgICAgIGNhc2UgTUFQOlxuICAgICAgICAgICAgY2FzZSBTQ0FMQVI6XG4gICAgICAgICAgICBjYXNlIFNFUTpcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmNvbnN0IGhhc0FuY2hvciA9IChub2RlKSA9PiAoaXNTY2FsYXIobm9kZSkgfHwgaXNDb2xsZWN0aW9uKG5vZGUpKSAmJiAhIW5vZGUuYW5jaG9yO1xuY2xhc3MgTm9kZUJhc2Uge1xuICAgIGNvbnN0cnVjdG9yKHR5cGUpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIE5PREVfVFlQRSwgeyB2YWx1ZTogdHlwZSB9KTtcbiAgICB9XG4gICAgLyoqIENyZWF0ZSBhIGNvcHkgb2YgdGhpcyBub2RlLiAgKi9cbiAgICBjbG9uZSgpIHtcbiAgICAgICAgY29uc3QgY29weSA9IE9iamVjdC5jcmVhdGUoT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0aGlzKSk7XG4gICAgICAgIGlmICh0aGlzLnJhbmdlKVxuICAgICAgICAgICAgY29weS5yYW5nZSA9IHRoaXMucmFuZ2Uuc2xpY2UoKTtcbiAgICAgICAgcmV0dXJuIGNvcHk7XG4gICAgfVxufVxuXG5leHBvcnQgeyBBTElBUywgRE9DLCBNQVAsIE5PREVfVFlQRSwgTm9kZUJhc2UsIFBBSVIsIFNDQUxBUiwgU0VRLCBoYXNBbmNob3IsIGlzQWxpYXMsIGlzQ29sbGVjdGlvbiwgaXNEb2N1bWVudCwgaXNNYXAsIGlzTm9kZSwgaXNQYWlyLCBpc1NjYWxhciwgaXNTZXEgfTtcbiIsICJpbXBvcnQgeyBpc0RvY3VtZW50LCBpc01hcCwgaXNTZXEsIGlzUGFpciwgaXNTY2FsYXIsIGlzQWxpYXMsIGlzTm9kZSwgaXNDb2xsZWN0aW9uIH0gZnJvbSAnLi9ub2Rlcy9Ob2RlLmpzJztcblxuY29uc3QgQlJFQUsgPSBTeW1ib2woJ2JyZWFrIHZpc2l0Jyk7XG5jb25zdCBTS0lQID0gU3ltYm9sKCdza2lwIGNoaWxkcmVuJyk7XG5jb25zdCBSRU1PVkUgPSBTeW1ib2woJ3JlbW92ZSBub2RlJyk7XG4vKipcbiAqIEFwcGx5IGEgdmlzaXRvciB0byBhbiBBU1Qgbm9kZSBvciBkb2N1bWVudC5cbiAqXG4gKiBXYWxrcyB0aHJvdWdoIHRoZSB0cmVlIChkZXB0aC1maXJzdCkgc3RhcnRpbmcgZnJvbSBgbm9kZWAsIGNhbGxpbmcgYVxuICogYHZpc2l0b3JgIGZ1bmN0aW9uIHdpdGggdGhyZWUgYXJndW1lbnRzOlxuICogICAtIGBrZXlgOiBGb3Igc2VxdWVuY2UgdmFsdWVzIGFuZCBtYXAgYFBhaXJgLCB0aGUgbm9kZSdzIGluZGV4IGluIHRoZVxuICogICAgIGNvbGxlY3Rpb24uIFdpdGhpbiBhIGBQYWlyYCwgYCdrZXknYCBvciBgJ3ZhbHVlJ2AsIGNvcnJlc3BvbmRpbmdseS5cbiAqICAgICBgbnVsbGAgZm9yIHRoZSByb290IG5vZGUuXG4gKiAgIC0gYG5vZGVgOiBUaGUgY3VycmVudCBub2RlLlxuICogICAtIGBwYXRoYDogVGhlIGFuY2VzdHJ5IG9mIHRoZSBjdXJyZW50IG5vZGUuXG4gKlxuICogVGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgdmlzaXRvciBtYXkgYmUgdXNlZCB0byBjb250cm9sIHRoZSB0cmF2ZXJzYWw6XG4gKiAgIC0gYHVuZGVmaW5lZGAgKGRlZmF1bHQpOiBEbyBub3RoaW5nIGFuZCBjb250aW51ZVxuICogICAtIGB2aXNpdC5TS0lQYDogRG8gbm90IHZpc2l0IHRoZSBjaGlsZHJlbiBvZiB0aGlzIG5vZGUsIGNvbnRpbnVlIHdpdGggbmV4dFxuICogICAgIHNpYmxpbmdcbiAqICAgLSBgdmlzaXQuQlJFQUtgOiBUZXJtaW5hdGUgdHJhdmVyc2FsIGNvbXBsZXRlbHlcbiAqICAgLSBgdmlzaXQuUkVNT1ZFYDogUmVtb3ZlIHRoZSBjdXJyZW50IG5vZGUsIHRoZW4gY29udGludWUgd2l0aCB0aGUgbmV4dCBvbmVcbiAqICAgLSBgTm9kZWA6IFJlcGxhY2UgdGhlIGN1cnJlbnQgbm9kZSwgdGhlbiBjb250aW51ZSBieSB2aXNpdGluZyBpdFxuICogICAtIGBudW1iZXJgOiBXaGlsZSBpdGVyYXRpbmcgdGhlIGl0ZW1zIG9mIGEgc2VxdWVuY2Ugb3IgbWFwLCBzZXQgdGhlIGluZGV4XG4gKiAgICAgb2YgdGhlIG5leHQgc3RlcC4gVGhpcyBpcyB1c2VmdWwgZXNwZWNpYWxseSBpZiB0aGUgaW5kZXggb2YgdGhlIGN1cnJlbnRcbiAqICAgICBub2RlIGhhcyBjaGFuZ2VkLlxuICpcbiAqIElmIGB2aXNpdG9yYCBpcyBhIHNpbmdsZSBmdW5jdGlvbiwgaXQgd2lsbCBiZSBjYWxsZWQgd2l0aCBhbGwgdmFsdWVzXG4gKiBlbmNvdW50ZXJlZCBpbiB0aGUgdHJlZSwgaW5jbHVkaW5nIGUuZy4gYG51bGxgIHZhbHVlcy4gQWx0ZXJuYXRpdmVseSxcbiAqIHNlcGFyYXRlIHZpc2l0b3IgZnVuY3Rpb25zIG1heSBiZSBkZWZpbmVkIGZvciBlYWNoIGBNYXBgLCBgUGFpcmAsIGBTZXFgLFxuICogYEFsaWFzYCBhbmQgYFNjYWxhcmAgbm9kZS4gVG8gZGVmaW5lIHRoZSBzYW1lIHZpc2l0b3IgZnVuY3Rpb24gZm9yIG1vcmUgdGhhblxuICogb25lIG5vZGUgdHlwZSwgdXNlIHRoZSBgQ29sbGVjdGlvbmAgKG1hcCBhbmQgc2VxKSwgYFZhbHVlYCAobWFwLCBzZXEgJiBzY2FsYXIpXG4gKiBhbmQgYE5vZGVgIChhbGlhcywgbWFwLCBzZXEgJiBzY2FsYXIpIHRhcmdldHMuIE9mIGFsbCB0aGVzZSwgb25seSB0aGUgbW9zdFxuICogc3BlY2lmaWMgZGVmaW5lZCBvbmUgd2lsbCBiZSB1c2VkIGZvciBlYWNoIG5vZGUuXG4gKi9cbmZ1bmN0aW9uIHZpc2l0KG5vZGUsIHZpc2l0b3IpIHtcbiAgICBpZiAodHlwZW9mIHZpc2l0b3IgPT09ICdvYmplY3QnICYmXG4gICAgICAgICh2aXNpdG9yLkNvbGxlY3Rpb24gfHwgdmlzaXRvci5Ob2RlIHx8IHZpc2l0b3IuVmFsdWUpKSB7XG4gICAgICAgIHZpc2l0b3IgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgIEFsaWFzOiB2aXNpdG9yLk5vZGUsXG4gICAgICAgICAgICBNYXA6IHZpc2l0b3IuTm9kZSxcbiAgICAgICAgICAgIFNjYWxhcjogdmlzaXRvci5Ob2RlLFxuICAgICAgICAgICAgU2VxOiB2aXNpdG9yLk5vZGVcbiAgICAgICAgfSwgdmlzaXRvci5WYWx1ZSAmJiB7XG4gICAgICAgICAgICBNYXA6IHZpc2l0b3IuVmFsdWUsXG4gICAgICAgICAgICBTY2FsYXI6IHZpc2l0b3IuVmFsdWUsXG4gICAgICAgICAgICBTZXE6IHZpc2l0b3IuVmFsdWVcbiAgICAgICAgfSwgdmlzaXRvci5Db2xsZWN0aW9uICYmIHtcbiAgICAgICAgICAgIE1hcDogdmlzaXRvci5Db2xsZWN0aW9uLFxuICAgICAgICAgICAgU2VxOiB2aXNpdG9yLkNvbGxlY3Rpb25cbiAgICAgICAgfSwgdmlzaXRvcik7XG4gICAgfVxuICAgIGlmIChpc0RvY3VtZW50KG5vZGUpKSB7XG4gICAgICAgIGNvbnN0IGNkID0gX3Zpc2l0KG51bGwsIG5vZGUuY29udGVudHMsIHZpc2l0b3IsIE9iamVjdC5mcmVlemUoW25vZGVdKSk7XG4gICAgICAgIGlmIChjZCA9PT0gUkVNT1ZFKVxuICAgICAgICAgICAgbm9kZS5jb250ZW50cyA9IG51bGw7XG4gICAgfVxuICAgIGVsc2VcbiAgICAgICAgX3Zpc2l0KG51bGwsIG5vZGUsIHZpc2l0b3IsIE9iamVjdC5mcmVlemUoW10pKTtcbn1cbi8vIFdpdGhvdXQgdGhlIGBhcyBzeW1ib2xgIGNhc3RzLCBUUyBkZWNsYXJlcyB0aGVzZSBpbiB0aGUgYHZpc2l0YFxuLy8gbmFtZXNwYWNlIHVzaW5nIGB2YXJgLCBidXQgdGhlbiBjb21wbGFpbnMgYWJvdXQgdGhhdCBiZWNhdXNlXG4vLyBgdW5pcXVlIHN5bWJvbGAgbXVzdCBiZSBgY29uc3RgLlxuLyoqIFRlcm1pbmF0ZSB2aXNpdCB0cmF2ZXJzYWwgY29tcGxldGVseSAqL1xudmlzaXQuQlJFQUsgPSBCUkVBSztcbi8qKiBEbyBub3QgdmlzaXQgdGhlIGNoaWxkcmVuIG9mIHRoZSBjdXJyZW50IG5vZGUgKi9cbnZpc2l0LlNLSVAgPSBTS0lQO1xuLyoqIFJlbW92ZSB0aGUgY3VycmVudCBub2RlICovXG52aXNpdC5SRU1PVkUgPSBSRU1PVkU7XG5mdW5jdGlvbiBfdmlzaXQoa2V5LCBub2RlLCB2aXNpdG9yLCBwYXRoKSB7XG4gICAgbGV0IGN0cmwgPSB1bmRlZmluZWQ7XG4gICAgaWYgKHR5cGVvZiB2aXNpdG9yID09PSAnZnVuY3Rpb24nKVxuICAgICAgICBjdHJsID0gdmlzaXRvcihrZXksIG5vZGUsIHBhdGgpO1xuICAgIGVsc2UgaWYgKGlzTWFwKG5vZGUpKSB7XG4gICAgICAgIGlmICh2aXNpdG9yLk1hcClcbiAgICAgICAgICAgIGN0cmwgPSB2aXNpdG9yLk1hcChrZXksIG5vZGUsIHBhdGgpO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc1NlcShub2RlKSkge1xuICAgICAgICBpZiAodmlzaXRvci5TZXEpXG4gICAgICAgICAgICBjdHJsID0gdmlzaXRvci5TZXEoa2V5LCBub2RlLCBwYXRoKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNQYWlyKG5vZGUpKSB7XG4gICAgICAgIGlmICh2aXNpdG9yLlBhaXIpXG4gICAgICAgICAgICBjdHJsID0gdmlzaXRvci5QYWlyKGtleSwgbm9kZSwgcGF0aCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzU2NhbGFyKG5vZGUpKSB7XG4gICAgICAgIGlmICh2aXNpdG9yLlNjYWxhcilcbiAgICAgICAgICAgIGN0cmwgPSB2aXNpdG9yLlNjYWxhcihrZXksIG5vZGUsIHBhdGgpO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc0FsaWFzKG5vZGUpKSB7XG4gICAgICAgIGlmICh2aXNpdG9yLkFsaWFzKVxuICAgICAgICAgICAgY3RybCA9IHZpc2l0b3IuQWxpYXMoa2V5LCBub2RlLCBwYXRoKTtcbiAgICB9XG4gICAgaWYgKGlzTm9kZShjdHJsKSB8fCBpc1BhaXIoY3RybCkpIHtcbiAgICAgICAgY29uc3QgcGFyZW50ID0gcGF0aFtwYXRoLmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAoaXNDb2xsZWN0aW9uKHBhcmVudCkpIHtcbiAgICAgICAgICAgIHBhcmVudC5pdGVtc1trZXldID0gY3RybDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc1BhaXIocGFyZW50KSkge1xuICAgICAgICAgICAgaWYgKGtleSA9PT0gJ2tleScpXG4gICAgICAgICAgICAgICAgcGFyZW50LmtleSA9IGN0cmw7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcGFyZW50LnZhbHVlID0gY3RybDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc0RvY3VtZW50KHBhcmVudCkpIHtcbiAgICAgICAgICAgIHBhcmVudC5jb250ZW50cyA9IGN0cmw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBwdCA9IGlzQWxpYXMocGFyZW50KSA/ICdhbGlhcycgOiAnc2NhbGFyJztcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IHJlcGxhY2Ugbm9kZSB3aXRoICR7cHR9IHBhcmVudGApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfdmlzaXQoa2V5LCBjdHJsLCB2aXNpdG9yLCBwYXRoKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBjdHJsICE9PSAnc3ltYm9sJykge1xuICAgICAgICBpZiAoaXNDb2xsZWN0aW9uKG5vZGUpKSB7XG4gICAgICAgICAgICBwYXRoID0gT2JqZWN0LmZyZWV6ZShwYXRoLmNvbmNhdChub2RlKSk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGUuaXRlbXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaSA9IF92aXNpdChpLCBub2RlLml0ZW1zW2ldLCB2aXNpdG9yLCBwYXRoKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNpID09PSAnbnVtYmVyJylcbiAgICAgICAgICAgICAgICAgICAgaSA9IGNpIC0gMTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjaSA9PT0gQlJFQUspXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBCUkVBSztcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjaSA9PT0gUkVNT1ZFKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUuaXRlbXMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICBpIC09IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzUGFpcihub2RlKSkge1xuICAgICAgICAgICAgcGF0aCA9IE9iamVjdC5mcmVlemUocGF0aC5jb25jYXQobm9kZSkpO1xuICAgICAgICAgICAgY29uc3QgY2sgPSBfdmlzaXQoJ2tleScsIG5vZGUua2V5LCB2aXNpdG9yLCBwYXRoKTtcbiAgICAgICAgICAgIGlmIChjayA9PT0gQlJFQUspXG4gICAgICAgICAgICAgICAgcmV0dXJuIEJSRUFLO1xuICAgICAgICAgICAgZWxzZSBpZiAoY2sgPT09IFJFTU9WRSlcbiAgICAgICAgICAgICAgICBub2RlLmtleSA9IG51bGw7XG4gICAgICAgICAgICBjb25zdCBjdiA9IF92aXNpdCgndmFsdWUnLCBub2RlLnZhbHVlLCB2aXNpdG9yLCBwYXRoKTtcbiAgICAgICAgICAgIGlmIChjdiA9PT0gQlJFQUspXG4gICAgICAgICAgICAgICAgcmV0dXJuIEJSRUFLO1xuICAgICAgICAgICAgZWxzZSBpZiAoY3YgPT09IFJFTU9WRSlcbiAgICAgICAgICAgICAgICBub2RlLnZhbHVlID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY3RybDtcbn1cblxuZXhwb3J0IHsgdmlzaXQgfTtcbiIsICJpbXBvcnQgeyBpc05vZGUgfSBmcm9tICcuLi9ub2Rlcy9Ob2RlLmpzJztcbmltcG9ydCB7IHZpc2l0IH0gZnJvbSAnLi4vdmlzaXQuanMnO1xuXG5jb25zdCBlc2NhcGVDaGFycyA9IHtcbiAgICAnISc6ICclMjEnLFxuICAgICcsJzogJyUyQycsXG4gICAgJ1snOiAnJTVCJyxcbiAgICAnXSc6ICclNUQnLFxuICAgICd7JzogJyU3QicsXG4gICAgJ30nOiAnJTdEJ1xufTtcbmNvbnN0IGVzY2FwZVRhZ05hbWUgPSAodG4pID0+IHRuLnJlcGxhY2UoL1shLFtcXF17fV0vZywgY2ggPT4gZXNjYXBlQ2hhcnNbY2hdKTtcbmNsYXNzIERpcmVjdGl2ZXMge1xuICAgIGNvbnN0cnVjdG9yKHlhbWwsIHRhZ3MpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBkaXJlY3RpdmVzLWVuZC9kb2Mtc3RhcnQgbWFya2VyIGAtLS1gLiBJZiBgbnVsbGAsIGEgbWFya2VyIG1heSBzdGlsbCBiZVxuICAgICAgICAgKiBpbmNsdWRlZCBpbiB0aGUgZG9jdW1lbnQncyBzdHJpbmdpZmllZCByZXByZXNlbnRhdGlvbi5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubWFya2VyID0gbnVsbDtcbiAgICAgICAgdGhpcy55YW1sID0gT2JqZWN0LmFzc2lnbih7fSwgRGlyZWN0aXZlcy5kZWZhdWx0WWFtbCwgeWFtbCk7XG4gICAgICAgIHRoaXMudGFncyA9IE9iamVjdC5hc3NpZ24oe30sIERpcmVjdGl2ZXMuZGVmYXVsdFRhZ3MsIHRhZ3MpO1xuICAgIH1cbiAgICBjbG9uZSgpIHtcbiAgICAgICAgY29uc3QgY29weSA9IG5ldyBEaXJlY3RpdmVzKHRoaXMueWFtbCwgdGhpcy50YWdzKTtcbiAgICAgICAgY29weS5tYXJrZXIgPSB0aGlzLm1hcmtlcjtcbiAgICAgICAgcmV0dXJuIGNvcHk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIER1cmluZyBwYXJzaW5nLCBnZXQgYSBEaXJlY3RpdmVzIGluc3RhbmNlIGZvciB0aGUgY3VycmVudCBkb2N1bWVudCBhbmRcbiAgICAgKiB1cGRhdGUgdGhlIHN0cmVhbSBzdGF0ZSBhY2NvcmRpbmcgdG8gdGhlIGN1cnJlbnQgdmVyc2lvbidzIHNwZWMuXG4gICAgICovXG4gICAgYXREb2N1bWVudCgpIHtcbiAgICAgICAgY29uc3QgcmVzID0gbmV3IERpcmVjdGl2ZXModGhpcy55YW1sLCB0aGlzLnRhZ3MpO1xuICAgICAgICBzd2l0Y2ggKHRoaXMueWFtbC52ZXJzaW9uKSB7XG4gICAgICAgICAgICBjYXNlICcxLjEnOlxuICAgICAgICAgICAgICAgIHRoaXMuYXROZXh0RG9jdW1lbnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnMS4yJzpcbiAgICAgICAgICAgICAgICB0aGlzLmF0TmV4dERvY3VtZW50ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy55YW1sID0ge1xuICAgICAgICAgICAgICAgICAgICBleHBsaWNpdDogRGlyZWN0aXZlcy5kZWZhdWx0WWFtbC5leHBsaWNpdCxcbiAgICAgICAgICAgICAgICAgICAgdmVyc2lvbjogJzEuMidcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHRoaXMudGFncyA9IE9iamVjdC5hc3NpZ24oe30sIERpcmVjdGl2ZXMuZGVmYXVsdFRhZ3MpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBvbkVycm9yIC0gTWF5IGJlIGNhbGxlZCBldmVuIGlmIHRoZSBhY3Rpb24gd2FzIHN1Y2Nlc3NmdWxcbiAgICAgKiBAcmV0dXJucyBgdHJ1ZWAgb24gc3VjY2Vzc1xuICAgICAqL1xuICAgIGFkZChsaW5lLCBvbkVycm9yKSB7XG4gICAgICAgIGlmICh0aGlzLmF0TmV4dERvY3VtZW50KSB7XG4gICAgICAgICAgICB0aGlzLnlhbWwgPSB7IGV4cGxpY2l0OiBEaXJlY3RpdmVzLmRlZmF1bHRZYW1sLmV4cGxpY2l0LCB2ZXJzaW9uOiAnMS4xJyB9O1xuICAgICAgICAgICAgdGhpcy50YWdzID0gT2JqZWN0LmFzc2lnbih7fSwgRGlyZWN0aXZlcy5kZWZhdWx0VGFncyk7XG4gICAgICAgICAgICB0aGlzLmF0TmV4dERvY3VtZW50ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFydHMgPSBsaW5lLnRyaW0oKS5zcGxpdCgvWyBcXHRdKy8pO1xuICAgICAgICBjb25zdCBuYW1lID0gcGFydHMuc2hpZnQoKTtcbiAgICAgICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICAgICAgICBjYXNlICclVEFHJzoge1xuICAgICAgICAgICAgICAgIGlmIChwYXJ0cy5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgb25FcnJvcigwLCAnJVRBRyBkaXJlY3RpdmUgc2hvdWxkIGNvbnRhaW4gZXhhY3RseSB0d28gcGFydHMnKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA8IDIpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IFtoYW5kbGUsIHByZWZpeF0gPSBwYXJ0cztcbiAgICAgICAgICAgICAgICB0aGlzLnRhZ3NbaGFuZGxlXSA9IHByZWZpeDtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJyVZQU1MJzoge1xuICAgICAgICAgICAgICAgIHRoaXMueWFtbC5leHBsaWNpdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA8IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgb25FcnJvcigwLCAnJVlBTUwgZGlyZWN0aXZlIHNob3VsZCBjb250YWluIGV4YWN0bHkgb25lIHBhcnQnKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBbdmVyc2lvbl0gPSBwYXJ0cztcbiAgICAgICAgICAgICAgICBpZiAodmVyc2lvbiA9PT0gJzEuMScgfHwgdmVyc2lvbiA9PT0gJzEuMicpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy55YW1sLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3IoNiwgYFVuc3VwcG9ydGVkIFlBTUwgdmVyc2lvbiAke3ZlcnNpb259YCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIG9uRXJyb3IoMCwgYFVua25vd24gZGlyZWN0aXZlICR7bmFtZX1gLCB0cnVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVzb2x2ZXMgYSB0YWcsIG1hdGNoaW5nIGhhbmRsZXMgdG8gdGhvc2UgZGVmaW5lZCBpbiAlVEFHIGRpcmVjdGl2ZXMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBSZXNvbHZlZCB0YWcsIHdoaWNoIG1heSBhbHNvIGJlIHRoZSBub24tc3BlY2lmaWMgdGFnIGAnISdgIG9yIGFcbiAgICAgKiAgIGAnIWxvY2FsJ2AgdGFnLCBvciBgbnVsbGAgaWYgdW5yZXNvbHZhYmxlLlxuICAgICAqL1xuICAgIHRhZ05hbWUoc291cmNlLCBvbkVycm9yKSB7XG4gICAgICAgIGlmIChzb3VyY2UgPT09ICchJylcbiAgICAgICAgICAgIHJldHVybiAnISc7IC8vIG5vbi1zcGVjaWZpYyB0YWdcbiAgICAgICAgaWYgKHNvdXJjZVswXSAhPT0gJyEnKSB7XG4gICAgICAgICAgICBvbkVycm9yKGBOb3QgYSB2YWxpZCB0YWc6ICR7c291cmNlfWApO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNvdXJjZVsxXSA9PT0gJzwnKSB7XG4gICAgICAgICAgICBjb25zdCB2ZXJiYXRpbSA9IHNvdXJjZS5zbGljZSgyLCAtMSk7XG4gICAgICAgICAgICBpZiAodmVyYmF0aW0gPT09ICchJyB8fCB2ZXJiYXRpbSA9PT0gJyEhJykge1xuICAgICAgICAgICAgICAgIG9uRXJyb3IoYFZlcmJhdGltIHRhZ3MgYXJlbid0IHJlc29sdmVkLCBzbyAke3NvdXJjZX0gaXMgaW52YWxpZC5gKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzb3VyY2Vbc291cmNlLmxlbmd0aCAtIDFdICE9PSAnPicpXG4gICAgICAgICAgICAgICAgb25FcnJvcignVmVyYmF0aW0gdGFncyBtdXN0IGVuZCB3aXRoIGEgPicpO1xuICAgICAgICAgICAgcmV0dXJuIHZlcmJhdGltO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IFssIGhhbmRsZSwgc3VmZml4XSA9IHNvdXJjZS5tYXRjaCgvXiguKiEpKFteIV0qKSQvKTtcbiAgICAgICAgaWYgKCFzdWZmaXgpXG4gICAgICAgICAgICBvbkVycm9yKGBUaGUgJHtzb3VyY2V9IHRhZyBoYXMgbm8gc3VmZml4YCk7XG4gICAgICAgIGNvbnN0IHByZWZpeCA9IHRoaXMudGFnc1toYW5kbGVdO1xuICAgICAgICBpZiAocHJlZml4KVxuICAgICAgICAgICAgcmV0dXJuIHByZWZpeCArIGRlY29kZVVSSUNvbXBvbmVudChzdWZmaXgpO1xuICAgICAgICBpZiAoaGFuZGxlID09PSAnIScpXG4gICAgICAgICAgICByZXR1cm4gc291cmNlOyAvLyBsb2NhbCB0YWdcbiAgICAgICAgb25FcnJvcihgQ291bGQgbm90IHJlc29sdmUgdGFnOiAke3NvdXJjZX1gKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdpdmVuIGEgZnVsbHkgcmVzb2x2ZWQgdGFnLCByZXR1cm5zIGl0cyBwcmludGFibGUgc3RyaW5nIGZvcm0sXG4gICAgICogdGFraW5nIGludG8gYWNjb3VudCBjdXJyZW50IHRhZyBwcmVmaXhlcyBhbmQgZGVmYXVsdHMuXG4gICAgICovXG4gICAgdGFnU3RyaW5nKHRhZykge1xuICAgICAgICBmb3IgKGNvbnN0IFtoYW5kbGUsIHByZWZpeF0gb2YgT2JqZWN0LmVudHJpZXModGhpcy50YWdzKSkge1xuICAgICAgICAgICAgaWYgKHRhZy5zdGFydHNXaXRoKHByZWZpeCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZSArIGVzY2FwZVRhZ05hbWUodGFnLnN1YnN0cmluZyhwcmVmaXgubGVuZ3RoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRhZ1swXSA9PT0gJyEnID8gdGFnIDogYCE8JHt0YWd9PmA7XG4gICAgfVxuICAgIHRvU3RyaW5nKGRvYykge1xuICAgICAgICBjb25zdCBsaW5lcyA9IHRoaXMueWFtbC5leHBsaWNpdFxuICAgICAgICAgICAgPyBbYCVZQU1MICR7dGhpcy55YW1sLnZlcnNpb24gfHwgJzEuMid9YF1cbiAgICAgICAgICAgIDogW107XG4gICAgICAgIGNvbnN0IHRhZ0VudHJpZXMgPSBPYmplY3QuZW50cmllcyh0aGlzLnRhZ3MpO1xuICAgICAgICBsZXQgdGFnTmFtZXM7XG4gICAgICAgIGlmIChkb2MgJiYgdGFnRW50cmllcy5sZW5ndGggPiAwICYmIGlzTm9kZShkb2MuY29udGVudHMpKSB7XG4gICAgICAgICAgICBjb25zdCB0YWdzID0ge307XG4gICAgICAgICAgICB2aXNpdChkb2MuY29udGVudHMsIChfa2V5LCBub2RlKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGlzTm9kZShub2RlKSAmJiBub2RlLnRhZylcbiAgICAgICAgICAgICAgICAgICAgdGFnc1tub2RlLnRhZ10gPSB0cnVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0YWdOYW1lcyA9IE9iamVjdC5rZXlzKHRhZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRhZ05hbWVzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgW2hhbmRsZSwgcHJlZml4XSBvZiB0YWdFbnRyaWVzKSB7XG4gICAgICAgICAgICBpZiAoaGFuZGxlID09PSAnISEnICYmIHByZWZpeCA9PT0gJ3RhZzp5YW1sLm9yZywyMDAyOicpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBpZiAoIWRvYyB8fCB0YWdOYW1lcy5zb21lKHRuID0+IHRuLnN0YXJ0c1dpdGgocHJlZml4KSkpXG4gICAgICAgICAgICAgICAgbGluZXMucHVzaChgJVRBRyAke2hhbmRsZX0gJHtwcmVmaXh9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxpbmVzLmpvaW4oJ1xcbicpO1xuICAgIH1cbn1cbkRpcmVjdGl2ZXMuZGVmYXVsdFlhbWwgPSB7IGV4cGxpY2l0OiBmYWxzZSwgdmVyc2lvbjogJzEuMicgfTtcbkRpcmVjdGl2ZXMuZGVmYXVsdFRhZ3MgPSB7ICchISc6ICd0YWc6eWFtbC5vcmcsMjAwMjonIH07XG5cbmV4cG9ydCB7IERpcmVjdGl2ZXMgfTtcbiIsICJpbXBvcnQgeyBpc1NjYWxhciwgaXNDb2xsZWN0aW9uIH0gZnJvbSAnLi4vbm9kZXMvTm9kZS5qcyc7XG5pbXBvcnQgeyB2aXNpdCB9IGZyb20gJy4uL3Zpc2l0LmpzJztcblxuLyoqXG4gKiBWZXJpZnkgdGhhdCB0aGUgaW5wdXQgc3RyaW5nIGlzIGEgdmFsaWQgYW5jaG9yLlxuICpcbiAqIFdpbGwgdGhyb3cgb24gZXJyb3JzLlxuICovXG5mdW5jdGlvbiBhbmNob3JJc1ZhbGlkKGFuY2hvcikge1xuICAgIGlmICgvW1xceDAwLVxceDE5XFxzLFtcXF17fV0vLnRlc3QoYW5jaG9yKSkge1xuICAgICAgICBjb25zdCBzYSA9IEpTT04uc3RyaW5naWZ5KGFuY2hvcik7XG4gICAgICAgIGNvbnN0IG1zZyA9IGBBbmNob3IgbXVzdCBub3QgY29udGFpbiB3aGl0ZXNwYWNlIG9yIGNvbnRyb2wgY2hhcmFjdGVyczogJHtzYX1gO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBhbmNob3JOYW1lcyhyb290KSB7XG4gICAgY29uc3QgYW5jaG9ycyA9IG5ldyBTZXQoKTtcbiAgICB2aXNpdChyb290LCB7XG4gICAgICAgIFZhbHVlKF9rZXksIG5vZGUpIHtcbiAgICAgICAgICAgIGlmIChub2RlLmFuY2hvcilcbiAgICAgICAgICAgICAgICBhbmNob3JzLmFkZChub2RlLmFuY2hvcik7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gYW5jaG9ycztcbn1cbi8qKiBGaW5kIGEgbmV3IGFuY2hvciBuYW1lIHdpdGggdGhlIGdpdmVuIGBwcmVmaXhgIGFuZCBhIG9uZS1pbmRleGVkIHN1ZmZpeC4gKi9cbmZ1bmN0aW9uIGZpbmROZXdBbmNob3IocHJlZml4LCBleGNsdWRlKSB7XG4gICAgZm9yIChsZXQgaSA9IDE7IHRydWU7ICsraSkge1xuICAgICAgICBjb25zdCBuYW1lID0gYCR7cHJlZml4fSR7aX1gO1xuICAgICAgICBpZiAoIWV4Y2x1ZGUuaGFzKG5hbWUpKVxuICAgICAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgfVxufVxuZnVuY3Rpb24gY3JlYXRlTm9kZUFuY2hvcnMoZG9jLCBwcmVmaXgpIHtcbiAgICBjb25zdCBhbGlhc09iamVjdHMgPSBbXTtcbiAgICBjb25zdCBzb3VyY2VPYmplY3RzID0gbmV3IE1hcCgpO1xuICAgIGxldCBwcmV2QW5jaG9ycyA9IG51bGw7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgb25BbmNob3Ioc291cmNlKSB7XG4gICAgICAgICAgICBhbGlhc09iamVjdHMucHVzaChzb3VyY2UpO1xuICAgICAgICAgICAgaWYgKCFwcmV2QW5jaG9ycylcbiAgICAgICAgICAgICAgICBwcmV2QW5jaG9ycyA9IGFuY2hvck5hbWVzKGRvYyk7XG4gICAgICAgICAgICBjb25zdCBhbmNob3IgPSBmaW5kTmV3QW5jaG9yKHByZWZpeCwgcHJldkFuY2hvcnMpO1xuICAgICAgICAgICAgcHJldkFuY2hvcnMuYWRkKGFuY2hvcik7XG4gICAgICAgICAgICByZXR1cm4gYW5jaG9yO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogV2l0aCBjaXJjdWxhciByZWZlcmVuY2VzLCB0aGUgc291cmNlIG5vZGUgaXMgb25seSByZXNvbHZlZCBhZnRlciBhbGxcbiAgICAgICAgICogb2YgaXRzIGNoaWxkIG5vZGVzIGFyZS4gVGhpcyBpcyB3aHkgYW5jaG9ycyBhcmUgc2V0IG9ubHkgYWZ0ZXIgYWxsIG9mXG4gICAgICAgICAqIHRoZSBub2RlcyBoYXZlIGJlZW4gY3JlYXRlZC5cbiAgICAgICAgICovXG4gICAgICAgIHNldEFuY2hvcnMoKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHNvdXJjZSBvZiBhbGlhc09iamVjdHMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZWYgPSBzb3VyY2VPYmplY3RzLmdldChzb3VyY2UpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcmVmID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgICAgICAgICByZWYuYW5jaG9yICYmXG4gICAgICAgICAgICAgICAgICAgIChpc1NjYWxhcihyZWYubm9kZSkgfHwgaXNDb2xsZWN0aW9uKHJlZi5ub2RlKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVmLm5vZGUuYW5jaG9yID0gcmVmLmFuY2hvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKCdGYWlsZWQgdG8gcmVzb2x2ZSByZXBlYXRlZCBvYmplY3QgKHRoaXMgc2hvdWxkIG5vdCBoYXBwZW4pJyk7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBzb3VyY2VPYmplY3RzXG4gICAgfTtcbn1cblxuZXhwb3J0IHsgYW5jaG9ySXNWYWxpZCwgYW5jaG9yTmFtZXMsIGNyZWF0ZU5vZGVBbmNob3JzLCBmaW5kTmV3QW5jaG9yIH07XG4iLCAiaW1wb3J0IHsgYW5jaG9ySXNWYWxpZCB9IGZyb20gJy4uL2RvYy9hbmNob3JzLmpzJztcbmltcG9ydCB7IHZpc2l0IH0gZnJvbSAnLi4vdmlzaXQuanMnO1xuaW1wb3J0IHsgTm9kZUJhc2UsIEFMSUFTLCBpc0FsaWFzLCBpc0NvbGxlY3Rpb24sIGlzUGFpciB9IGZyb20gJy4vTm9kZS5qcyc7XG5cbmNsYXNzIEFsaWFzIGV4dGVuZHMgTm9kZUJhc2Uge1xuICAgIGNvbnN0cnVjdG9yKHNvdXJjZSkge1xuICAgICAgICBzdXBlcihBTElBUyk7XG4gICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3RhZycsIHtcbiAgICAgICAgICAgIHNldCgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FsaWFzIG5vZGVzIGNhbm5vdCBoYXZlIHRhZ3MnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc29sdmUgdGhlIHZhbHVlIG9mIHRoaXMgYWxpYXMgd2l0aGluIGBkb2NgLCBmaW5kaW5nIHRoZSBsYXN0XG4gICAgICogaW5zdGFuY2Ugb2YgdGhlIGBzb3VyY2VgIGFuY2hvciBiZWZvcmUgdGhpcyBub2RlLlxuICAgICAqL1xuICAgIHJlc29sdmUoZG9jKSB7XG4gICAgICAgIGxldCBmb3VuZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdmlzaXQoZG9jLCB7XG4gICAgICAgICAgICBOb2RlOiAoX2tleSwgbm9kZSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChub2RlID09PSB0aGlzKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmlzaXQuQlJFQUs7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUuYW5jaG9yID09PSB0aGlzLnNvdXJjZSlcbiAgICAgICAgICAgICAgICAgICAgZm91bmQgPSBub2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGZvdW5kO1xuICAgIH1cbiAgICB0b0pTT04oX2FyZywgY3R4KSB7XG4gICAgICAgIGlmICghY3R4KVxuICAgICAgICAgICAgcmV0dXJuIHsgc291cmNlOiB0aGlzLnNvdXJjZSB9O1xuICAgICAgICBjb25zdCB7IGFuY2hvcnMsIGRvYywgbWF4QWxpYXNDb3VudCB9ID0gY3R4O1xuICAgICAgICBjb25zdCBzb3VyY2UgPSB0aGlzLnJlc29sdmUoZG9jKTtcbiAgICAgICAgaWYgKCFzb3VyY2UpIHtcbiAgICAgICAgICAgIGNvbnN0IG1zZyA9IGBVbnJlc29sdmVkIGFsaWFzICh0aGUgYW5jaG9yIG11c3QgYmUgc2V0IGJlZm9yZSB0aGUgYWxpYXMpOiAke3RoaXMuc291cmNlfWA7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IobXNnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkYXRhID0gYW5jaG9ycy5nZXQoc291cmNlKTtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmICghZGF0YSB8fCBkYXRhLnJlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBtc2cgPSAnVGhpcyBzaG91bGQgbm90IGhhcHBlbjogQWxpYXMgYW5jaG9yIHdhcyBub3QgcmVzb2x2ZWQ/JztcbiAgICAgICAgICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihtc2cpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXhBbGlhc0NvdW50ID49IDApIHtcbiAgICAgICAgICAgIGRhdGEuY291bnQgKz0gMTtcbiAgICAgICAgICAgIGlmIChkYXRhLmFsaWFzQ291bnQgPT09IDApXG4gICAgICAgICAgICAgICAgZGF0YS5hbGlhc0NvdW50ID0gZ2V0QWxpYXNDb3VudChkb2MsIHNvdXJjZSwgYW5jaG9ycyk7XG4gICAgICAgICAgICBpZiAoZGF0YS5jb3VudCAqIGRhdGEuYWxpYXNDb3VudCA+IG1heEFsaWFzQ291bnQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtc2cgPSAnRXhjZXNzaXZlIGFsaWFzIGNvdW50IGluZGljYXRlcyBhIHJlc291cmNlIGV4aGF1c3Rpb24gYXR0YWNrJztcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IobXNnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0YS5yZXM7XG4gICAgfVxuICAgIHRvU3RyaW5nKGN0eCwgX29uQ29tbWVudCwgX29uQ2hvbXBLZWVwKSB7XG4gICAgICAgIGNvbnN0IHNyYyA9IGAqJHt0aGlzLnNvdXJjZX1gO1xuICAgICAgICBpZiAoY3R4KSB7XG4gICAgICAgICAgICBhbmNob3JJc1ZhbGlkKHRoaXMuc291cmNlKTtcbiAgICAgICAgICAgIGlmIChjdHgub3B0aW9ucy52ZXJpZnlBbGlhc09yZGVyICYmICFjdHguYW5jaG9ycy5oYXModGhpcy5zb3VyY2UpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbXNnID0gYFVucmVzb2x2ZWQgYWxpYXMgKHRoZSBhbmNob3IgbXVzdCBiZSBzZXQgYmVmb3JlIHRoZSBhbGlhcyk6ICR7dGhpcy5zb3VyY2V9YDtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjdHguaW1wbGljaXRLZXkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGAke3NyY30gYDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3JjO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldEFsaWFzQ291bnQoZG9jLCBub2RlLCBhbmNob3JzKSB7XG4gICAgaWYgKGlzQWxpYXMobm9kZSkpIHtcbiAgICAgICAgY29uc3Qgc291cmNlID0gbm9kZS5yZXNvbHZlKGRvYyk7XG4gICAgICAgIGNvbnN0IGFuY2hvciA9IGFuY2hvcnMgJiYgc291cmNlICYmIGFuY2hvcnMuZ2V0KHNvdXJjZSk7XG4gICAgICAgIHJldHVybiBhbmNob3IgPyBhbmNob3IuY291bnQgKiBhbmNob3IuYWxpYXNDb3VudCA6IDA7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzQ29sbGVjdGlvbihub2RlKSkge1xuICAgICAgICBsZXQgY291bnQgPSAwO1xuICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2Ygbm9kZS5pdGVtcykge1xuICAgICAgICAgICAgY29uc3QgYyA9IGdldEFsaWFzQ291bnQoZG9jLCBpdGVtLCBhbmNob3JzKTtcbiAgICAgICAgICAgIGlmIChjID4gY291bnQpXG4gICAgICAgICAgICAgICAgY291bnQgPSBjO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb3VudDtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNQYWlyKG5vZGUpKSB7XG4gICAgICAgIGNvbnN0IGtjID0gZ2V0QWxpYXNDb3VudChkb2MsIG5vZGUua2V5LCBhbmNob3JzKTtcbiAgICAgICAgY29uc3QgdmMgPSBnZXRBbGlhc0NvdW50KGRvYywgbm9kZS52YWx1ZSwgYW5jaG9ycyk7XG4gICAgICAgIHJldHVybiBNYXRoLm1heChrYywgdmMpO1xuICAgIH1cbiAgICByZXR1cm4gMTtcbn1cblxuZXhwb3J0IHsgQWxpYXMgfTtcbiIsICJpbXBvcnQgeyBoYXNBbmNob3IgfSBmcm9tICcuL05vZGUuanMnO1xuXG4vKipcbiAqIFJlY3Vyc2l2ZWx5IGNvbnZlcnQgYW55IG5vZGUgb3IgaXRzIGNvbnRlbnRzIHRvIG5hdGl2ZSBKYXZhU2NyaXB0XG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIGlucHV0IHZhbHVlXG4gKiBAcGFyYW0gYXJnIC0gSWYgYHZhbHVlYCBkZWZpbmVzIGEgYHRvSlNPTigpYCBtZXRob2QsIHVzZSB0aGlzXG4gKiAgIGFzIGl0cyBmaXJzdCBhcmd1bWVudFxuICogQHBhcmFtIGN0eCAtIENvbnZlcnNpb24gY29udGV4dCwgb3JpZ2luYWxseSBzZXQgaW4gRG9jdW1lbnQjdG9KUygpLiBJZlxuICogICBgeyBrZWVwOiB0cnVlIH1gIGlzIG5vdCBzZXQsIG91dHB1dCBzaG91bGQgYmUgc3VpdGFibGUgZm9yIEpTT05cbiAqICAgc3RyaW5naWZpY2F0aW9uLlxuICovXG5mdW5jdGlvbiB0b0pTKHZhbHVlLCBhcmcsIGN0eCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSlcbiAgICAgICAgcmV0dXJuIHZhbHVlLm1hcCgodiwgaSkgPT4gdG9KUyh2LCBTdHJpbmcoaSksIGN0eCkpO1xuICAgIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUudG9KU09OID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGlmICghY3R4IHx8ICFoYXNBbmNob3IodmFsdWUpKVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnRvSlNPTihhcmcsIGN0eCk7XG4gICAgICAgIGNvbnN0IGRhdGEgPSB7IGFsaWFzQ291bnQ6IDAsIGNvdW50OiAxLCByZXM6IHVuZGVmaW5lZCB9O1xuICAgICAgICBjdHguYW5jaG9ycy5zZXQodmFsdWUsIGRhdGEpO1xuICAgICAgICBjdHgub25DcmVhdGUgPSByZXMgPT4ge1xuICAgICAgICAgICAgZGF0YS5yZXMgPSByZXM7XG4gICAgICAgICAgICBkZWxldGUgY3R4Lm9uQ3JlYXRlO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCByZXMgPSB2YWx1ZS50b0pTT04oYXJnLCBjdHgpO1xuICAgICAgICBpZiAoY3R4Lm9uQ3JlYXRlKVxuICAgICAgICAgICAgY3R4Lm9uQ3JlYXRlKHJlcyk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdiaWdpbnQnICYmICEoY3R4ICYmIGN0eC5rZWVwKSlcbiAgICAgICAgcmV0dXJuIE51bWJlcih2YWx1ZSk7XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuXG5leHBvcnQgeyB0b0pTIH07XG4iLCAiaW1wb3J0IHsgTm9kZUJhc2UsIFNDQUxBUiB9IGZyb20gJy4vTm9kZS5qcyc7XG5pbXBvcnQgeyB0b0pTIH0gZnJvbSAnLi90b0pTLmpzJztcblxuY29uc3QgaXNTY2FsYXJWYWx1ZSA9ICh2YWx1ZSkgPT4gIXZhbHVlIHx8ICh0eXBlb2YgdmFsdWUgIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0Jyk7XG5jbGFzcyBTY2FsYXIgZXh0ZW5kcyBOb2RlQmFzZSB7XG4gICAgY29uc3RydWN0b3IodmFsdWUpIHtcbiAgICAgICAgc3VwZXIoU0NBTEFSKTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICB0b0pTT04oYXJnLCBjdHgpIHtcbiAgICAgICAgcmV0dXJuIGN0eCAmJiBjdHgua2VlcCA/IHRoaXMudmFsdWUgOiB0b0pTKHRoaXMudmFsdWUsIGFyZywgY3R4KTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBTdHJpbmcodGhpcy52YWx1ZSk7XG4gICAgfVxufVxuU2NhbGFyLkJMT0NLX0ZPTERFRCA9ICdCTE9DS19GT0xERUQnO1xuU2NhbGFyLkJMT0NLX0xJVEVSQUwgPSAnQkxPQ0tfTElURVJBTCc7XG5TY2FsYXIuUExBSU4gPSAnUExBSU4nO1xuU2NhbGFyLlFVT1RFX0RPVUJMRSA9ICdRVU9URV9ET1VCTEUnO1xuU2NhbGFyLlFVT1RFX1NJTkdMRSA9ICdRVU9URV9TSU5HTEUnO1xuXG5leHBvcnQgeyBTY2FsYXIsIGlzU2NhbGFyVmFsdWUgfTtcbiIsICJpbXBvcnQgeyBBbGlhcyB9IGZyb20gJy4uL25vZGVzL0FsaWFzLmpzJztcbmltcG9ydCB7IGlzTm9kZSwgaXNQYWlyLCBNQVAsIFNFUSwgaXNEb2N1bWVudCB9IGZyb20gJy4uL25vZGVzL05vZGUuanMnO1xuaW1wb3J0IHsgU2NhbGFyIH0gZnJvbSAnLi4vbm9kZXMvU2NhbGFyLmpzJztcblxuY29uc3QgZGVmYXVsdFRhZ1ByZWZpeCA9ICd0YWc6eWFtbC5vcmcsMjAwMjonO1xuZnVuY3Rpb24gZmluZFRhZ09iamVjdCh2YWx1ZSwgdGFnTmFtZSwgdGFncykge1xuICAgIGlmICh0YWdOYW1lKSB7XG4gICAgICAgIGNvbnN0IG1hdGNoID0gdGFncy5maWx0ZXIodCA9PiB0LnRhZyA9PT0gdGFnTmFtZSk7XG4gICAgICAgIGNvbnN0IHRhZ09iaiA9IG1hdGNoLmZpbmQodCA9PiAhdC5mb3JtYXQpIHx8IG1hdGNoWzBdO1xuICAgICAgICBpZiAoIXRhZ09iailcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVGFnICR7dGFnTmFtZX0gbm90IGZvdW5kYCk7XG4gICAgICAgIHJldHVybiB0YWdPYmo7XG4gICAgfVxuICAgIHJldHVybiB0YWdzLmZpbmQodCA9PiB0LmlkZW50aWZ5ICYmIHQuaWRlbnRpZnkodmFsdWUpICYmICF0LmZvcm1hdCk7XG59XG5mdW5jdGlvbiBjcmVhdGVOb2RlKHZhbHVlLCB0YWdOYW1lLCBjdHgpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGlmIChpc0RvY3VtZW50KHZhbHVlKSlcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5jb250ZW50cztcbiAgICBpZiAoaXNOb2RlKHZhbHVlKSlcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIGlmIChpc1BhaXIodmFsdWUpKSB7XG4gICAgICAgIGNvbnN0IG1hcCA9IChfYiA9IChfYSA9IGN0eC5zY2hlbWFbTUFQXSkuY3JlYXRlTm9kZSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIGN0eC5zY2hlbWEsIG51bGwsIGN0eCk7XG4gICAgICAgIG1hcC5pdGVtcy5wdXNoKHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG1hcDtcbiAgICB9XG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgU3RyaW5nIHx8XG4gICAgICAgIHZhbHVlIGluc3RhbmNlb2YgTnVtYmVyIHx8XG4gICAgICAgIHZhbHVlIGluc3RhbmNlb2YgQm9vbGVhbiB8fFxuICAgICAgICAodHlwZW9mIEJpZ0ludCA9PT0gJ2Z1bmN0aW9uJyAmJiB2YWx1ZSBpbnN0YW5jZW9mIEJpZ0ludCkgLy8gbm90IHN1cHBvcnRlZCBldmVyeXdoZXJlXG4gICAgKSB7XG4gICAgICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtc2VyaWFsaXplanNvbnByb3BlcnR5XG4gICAgICAgIHZhbHVlID0gdmFsdWUudmFsdWVPZigpO1xuICAgIH1cbiAgICBjb25zdCB7IGFsaWFzRHVwbGljYXRlT2JqZWN0cywgb25BbmNob3IsIG9uVGFnT2JqLCBzY2hlbWEsIHNvdXJjZU9iamVjdHMgfSA9IGN0eDtcbiAgICAvLyBEZXRlY3QgZHVwbGljYXRlIHJlZmVyZW5jZXMgdG8gdGhlIHNhbWUgb2JqZWN0ICYgdXNlIEFsaWFzIG5vZGVzIGZvciBhbGxcbiAgICAvLyBhZnRlciBmaXJzdC4gVGhlIGByZWZgIHdyYXBwZXIgYWxsb3dzIGZvciBjaXJjdWxhciByZWZlcmVuY2VzIHRvIHJlc29sdmUuXG4gICAgbGV0IHJlZiA9IHVuZGVmaW5lZDtcbiAgICBpZiAoYWxpYXNEdXBsaWNhdGVPYmplY3RzICYmIHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmVmID0gc291cmNlT2JqZWN0cy5nZXQodmFsdWUpO1xuICAgICAgICBpZiAocmVmKSB7XG4gICAgICAgICAgICBpZiAoIXJlZi5hbmNob3IpXG4gICAgICAgICAgICAgICAgcmVmLmFuY2hvciA9IG9uQW5jaG9yKHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQWxpYXMocmVmLmFuY2hvcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZWYgPSB7IGFuY2hvcjogbnVsbCwgbm9kZTogbnVsbCB9O1xuICAgICAgICAgICAgc291cmNlT2JqZWN0cy5zZXQodmFsdWUsIHJlZik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRhZ05hbWUgJiYgdGFnTmFtZS5zdGFydHNXaXRoKCchIScpKVxuICAgICAgICB0YWdOYW1lID0gZGVmYXVsdFRhZ1ByZWZpeCArIHRhZ05hbWUuc2xpY2UoMik7XG4gICAgbGV0IHRhZ09iaiA9IGZpbmRUYWdPYmplY3QodmFsdWUsIHRhZ05hbWUsIHNjaGVtYS50YWdzKTtcbiAgICBpZiAoIXRhZ09iaikge1xuICAgICAgICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlLnRvSlNPTiA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUudG9KU09OKCk7XG4gICAgICAgIGlmICghdmFsdWUgfHwgdHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgY29uc3Qgbm9kZSA9IG5ldyBTY2FsYXIodmFsdWUpO1xuICAgICAgICAgICAgaWYgKHJlZilcbiAgICAgICAgICAgICAgICByZWYubm9kZSA9IG5vZGU7XG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgfVxuICAgICAgICB0YWdPYmogPVxuICAgICAgICAgICAgdmFsdWUgaW5zdGFuY2VvZiBNYXBcbiAgICAgICAgICAgICAgICA/IHNjaGVtYVtNQVBdXG4gICAgICAgICAgICAgICAgOiBTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KHZhbHVlKVxuICAgICAgICAgICAgICAgICAgICA/IHNjaGVtYVtTRVFdXG4gICAgICAgICAgICAgICAgICAgIDogc2NoZW1hW01BUF07XG4gICAgfVxuICAgIGlmIChvblRhZ09iaikge1xuICAgICAgICBvblRhZ09iaih0YWdPYmopO1xuICAgICAgICBkZWxldGUgY3R4Lm9uVGFnT2JqO1xuICAgIH1cbiAgICBjb25zdCBub2RlID0gKHRhZ09iaiA9PT0gbnVsbCB8fCB0YWdPYmogPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRhZ09iai5jcmVhdGVOb2RlKVxuICAgICAgICA/IHRhZ09iai5jcmVhdGVOb2RlKGN0eC5zY2hlbWEsIHZhbHVlLCBjdHgpXG4gICAgICAgIDogbmV3IFNjYWxhcih2YWx1ZSk7XG4gICAgaWYgKHRhZ05hbWUpXG4gICAgICAgIG5vZGUudGFnID0gdGFnTmFtZTtcbiAgICBpZiAocmVmKVxuICAgICAgICByZWYubm9kZSA9IG5vZGU7XG4gICAgcmV0dXJuIG5vZGU7XG59XG5cbmV4cG9ydCB7IGNyZWF0ZU5vZGUgfTtcbiIsICJpbXBvcnQgeyBjcmVhdGVOb2RlIH0gZnJvbSAnLi4vZG9jL2NyZWF0ZU5vZGUuanMnO1xuaW1wb3J0IHsgTm9kZUJhc2UsIGlzTm9kZSwgaXNQYWlyLCBpc0NvbGxlY3Rpb24sIGlzU2NhbGFyIH0gZnJvbSAnLi9Ob2RlLmpzJztcblxuZnVuY3Rpb24gY29sbGVjdGlvbkZyb21QYXRoKHNjaGVtYSwgcGF0aCwgdmFsdWUpIHtcbiAgICBsZXQgdiA9IHZhbHVlO1xuICAgIGZvciAobGV0IGkgPSBwYXRoLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIGNvbnN0IGsgPSBwYXRoW2ldO1xuICAgICAgICBpZiAodHlwZW9mIGsgPT09ICdudW1iZXInICYmIE51bWJlci5pc0ludGVnZXIoaykgJiYgayA+PSAwKSB7XG4gICAgICAgICAgICBjb25zdCBhID0gW107XG4gICAgICAgICAgICBhW2tdID0gdjtcbiAgICAgICAgICAgIHYgPSBhO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdiA9IG5ldyBNYXAoW1trLCB2XV0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVOb2RlKHYsIHVuZGVmaW5lZCwge1xuICAgICAgICBhbGlhc0R1cGxpY2F0ZU9iamVjdHM6IGZhbHNlLFxuICAgICAgICBrZWVwVW5kZWZpbmVkOiBmYWxzZSxcbiAgICAgICAgb25BbmNob3I6ICgpID0+IHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBzaG91bGQgbm90IGhhcHBlbiwgcGxlYXNlIHJlcG9ydCBhIGJ1Zy4nKTtcbiAgICAgICAgfSxcbiAgICAgICAgc2NoZW1hLFxuICAgICAgICBzb3VyY2VPYmplY3RzOiBuZXcgTWFwKClcbiAgICB9KTtcbn1cbi8vIG51bGwsIHVuZGVmaW5lZCwgb3IgYW4gZW1wdHkgbm9uLXN0cmluZyBpdGVyYWJsZSAoZS5nLiBbXSlcbmNvbnN0IGlzRW1wdHlQYXRoID0gKHBhdGgpID0+IHBhdGggPT0gbnVsbCB8fFxuICAgICh0eXBlb2YgcGF0aCA9PT0gJ29iamVjdCcgJiYgISFwYXRoW1N5bWJvbC5pdGVyYXRvcl0oKS5uZXh0KCkuZG9uZSk7XG5jbGFzcyBDb2xsZWN0aW9uIGV4dGVuZHMgTm9kZUJhc2Uge1xuICAgIGNvbnN0cnVjdG9yKHR5cGUsIHNjaGVtYSkge1xuICAgICAgICBzdXBlcih0eXBlKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdzY2hlbWEnLCB7XG4gICAgICAgICAgICB2YWx1ZTogc2NoZW1hLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgY29weSBvZiB0aGlzIGNvbGxlY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc2NoZW1hIC0gSWYgZGVmaW5lZCwgb3ZlcndyaXRlcyB0aGUgb3JpZ2luYWwncyBzY2hlbWFcbiAgICAgKi9cbiAgICBjbG9uZShzY2hlbWEpIHtcbiAgICAgICAgY29uc3QgY29weSA9IE9iamVjdC5jcmVhdGUoT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0aGlzKSk7XG4gICAgICAgIGlmIChzY2hlbWEpXG4gICAgICAgICAgICBjb3B5LnNjaGVtYSA9IHNjaGVtYTtcbiAgICAgICAgY29weS5pdGVtcyA9IGNvcHkuaXRlbXMubWFwKGl0ID0+IGlzTm9kZShpdCkgfHwgaXNQYWlyKGl0KSA/IGl0LmNsb25lKHNjaGVtYSkgOiBpdCk7XG4gICAgICAgIGlmICh0aGlzLnJhbmdlKVxuICAgICAgICAgICAgY29weS5yYW5nZSA9IHRoaXMucmFuZ2Uuc2xpY2UoKTtcbiAgICAgICAgcmV0dXJuIGNvcHk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYSB2YWx1ZSB0byB0aGUgY29sbGVjdGlvbi4gRm9yIGAhIW1hcGAgYW5kIGAhIW9tYXBgIHRoZSB2YWx1ZSBtdXN0XG4gICAgICogYmUgYSBQYWlyIGluc3RhbmNlIG9yIGEgYHsga2V5LCB2YWx1ZSB9YCBvYmplY3QsIHdoaWNoIG1heSBub3QgaGF2ZSBhIGtleVxuICAgICAqIHRoYXQgYWxyZWFkeSBleGlzdHMgaW4gdGhlIG1hcC5cbiAgICAgKi9cbiAgICBhZGRJbihwYXRoLCB2YWx1ZSkge1xuICAgICAgICBpZiAoaXNFbXB0eVBhdGgocGF0aCkpXG4gICAgICAgICAgICB0aGlzLmFkZCh2YWx1ZSk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgW2tleSwgLi4ucmVzdF0gPSBwYXRoO1xuICAgICAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuZ2V0KGtleSwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAoaXNDb2xsZWN0aW9uKG5vZGUpKVxuICAgICAgICAgICAgICAgIG5vZGUuYWRkSW4ocmVzdCwgdmFsdWUpO1xuICAgICAgICAgICAgZWxzZSBpZiAobm9kZSA9PT0gdW5kZWZpbmVkICYmIHRoaXMuc2NoZW1hKVxuICAgICAgICAgICAgICAgIHRoaXMuc2V0KGtleSwgY29sbGVjdGlvbkZyb21QYXRoKHRoaXMuc2NoZW1hLCByZXN0LCB2YWx1ZSkpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgWUFNTCBjb2xsZWN0aW9uIGF0ICR7a2V5fS4gUmVtYWluaW5nIHBhdGg6ICR7cmVzdH1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGEgdmFsdWUgZnJvbSB0aGUgY29sbGVjdGlvbi5cbiAgICAgKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGl0ZW0gd2FzIGZvdW5kIGFuZCByZW1vdmVkLlxuICAgICAqL1xuICAgIGRlbGV0ZUluKHBhdGgpIHtcbiAgICAgICAgY29uc3QgW2tleSwgLi4ucmVzdF0gPSBwYXRoO1xuICAgICAgICBpZiAocmVzdC5sZW5ndGggPT09IDApXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kZWxldGUoa2V5KTtcbiAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuZ2V0KGtleSwgdHJ1ZSk7XG4gICAgICAgIGlmIChpc0NvbGxlY3Rpb24obm9kZSkpXG4gICAgICAgICAgICByZXR1cm4gbm9kZS5kZWxldGVJbihyZXN0KTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBZQU1MIGNvbGxlY3Rpb24gYXQgJHtrZXl9LiBSZW1haW5pbmcgcGF0aDogJHtyZXN0fWApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGl0ZW0gYXQgYGtleWAsIG9yIGB1bmRlZmluZWRgIGlmIG5vdCBmb3VuZC4gQnkgZGVmYXVsdCB1bndyYXBzXG4gICAgICogc2NhbGFyIHZhbHVlcyBmcm9tIHRoZWlyIHN1cnJvdW5kaW5nIG5vZGU7IHRvIGRpc2FibGUgc2V0IGBrZWVwU2NhbGFyYCB0b1xuICAgICAqIGB0cnVlYCAoY29sbGVjdGlvbnMgYXJlIGFsd2F5cyByZXR1cm5lZCBpbnRhY3QpLlxuICAgICAqL1xuICAgIGdldEluKHBhdGgsIGtlZXBTY2FsYXIpIHtcbiAgICAgICAgY29uc3QgW2tleSwgLi4ucmVzdF0gPSBwYXRoO1xuICAgICAgICBjb25zdCBub2RlID0gdGhpcy5nZXQoa2V5LCB0cnVlKTtcbiAgICAgICAgaWYgKHJlc3QubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuICFrZWVwU2NhbGFyICYmIGlzU2NhbGFyKG5vZGUpID8gbm9kZS52YWx1ZSA6IG5vZGU7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiBpc0NvbGxlY3Rpb24obm9kZSkgPyBub2RlLmdldEluKHJlc3QsIGtlZXBTY2FsYXIpIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICBoYXNBbGxOdWxsVmFsdWVzKGFsbG93U2NhbGFyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLml0ZW1zLmV2ZXJ5KG5vZGUgPT4ge1xuICAgICAgICAgICAgaWYgKCFpc1BhaXIobm9kZSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgY29uc3QgbiA9IG5vZGUudmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gKG4gPT0gbnVsbCB8fFxuICAgICAgICAgICAgICAgIChhbGxvd1NjYWxhciAmJlxuICAgICAgICAgICAgICAgICAgICBpc1NjYWxhcihuKSAmJlxuICAgICAgICAgICAgICAgICAgICBuLnZhbHVlID09IG51bGwgJiZcbiAgICAgICAgICAgICAgICAgICAgIW4uY29tbWVudEJlZm9yZSAmJlxuICAgICAgICAgICAgICAgICAgICAhbi5jb21tZW50ICYmXG4gICAgICAgICAgICAgICAgICAgICFuLnRhZykpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHRoZSBjb2xsZWN0aW9uIGluY2x1ZGVzIGEgdmFsdWUgd2l0aCB0aGUga2V5IGBrZXlgLlxuICAgICAqL1xuICAgIGhhc0luKHBhdGgpIHtcbiAgICAgICAgY29uc3QgW2tleSwgLi4ucmVzdF0gPSBwYXRoO1xuICAgICAgICBpZiAocmVzdC5sZW5ndGggPT09IDApXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5oYXMoa2V5KTtcbiAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuZ2V0KGtleSwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiBpc0NvbGxlY3Rpb24obm9kZSkgPyBub2RlLmhhc0luKHJlc3QpIDogZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgYSB2YWx1ZSBpbiB0aGlzIGNvbGxlY3Rpb24uIEZvciBgISFzZXRgLCBgdmFsdWVgIG5lZWRzIHRvIGJlIGFcbiAgICAgKiBib29sZWFuIHRvIGFkZC9yZW1vdmUgdGhlIGl0ZW0gZnJvbSB0aGUgc2V0LlxuICAgICAqL1xuICAgIHNldEluKHBhdGgsIHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IFtrZXksIC4uLnJlc3RdID0gcGF0aDtcbiAgICAgICAgaWYgKHJlc3QubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLmdldChrZXksIHRydWUpO1xuICAgICAgICAgICAgaWYgKGlzQ29sbGVjdGlvbihub2RlKSlcbiAgICAgICAgICAgICAgICBub2RlLnNldEluKHJlc3QsIHZhbHVlKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKG5vZGUgPT09IHVuZGVmaW5lZCAmJiB0aGlzLnNjaGVtYSlcbiAgICAgICAgICAgICAgICB0aGlzLnNldChrZXksIGNvbGxlY3Rpb25Gcm9tUGF0aCh0aGlzLnNjaGVtYSwgcmVzdCwgdmFsdWUpKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIFlBTUwgY29sbGVjdGlvbiBhdCAke2tleX0uIFJlbWFpbmluZyBwYXRoOiAke3Jlc3R9YCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5Db2xsZWN0aW9uLm1heEZsb3dTdHJpbmdTaW5nbGVMaW5lTGVuZ3RoID0gNjA7XG5cbmV4cG9ydCB7IENvbGxlY3Rpb24sIGNvbGxlY3Rpb25Gcm9tUGF0aCwgaXNFbXB0eVBhdGggfTtcbiIsICIvKipcbiAqIFN0cmluZ2lmaWVzIGEgY29tbWVudC5cbiAqXG4gKiBFbXB0eSBjb21tZW50IGxpbmVzIGFyZSBsZWZ0IGVtcHR5LFxuICogbGluZXMgY29uc2lzdGluZyBvZiBhIHNpbmdsZSBzcGFjZSBhcmUgcmVwbGFjZWQgYnkgYCNgLFxuICogYW5kIGFsbCBvdGhlciBsaW5lcyBhcmUgcHJlZml4ZWQgd2l0aCBhIGAjYC5cbiAqL1xuY29uc3Qgc3RyaW5naWZ5Q29tbWVudCA9IChzdHIpID0+IHN0ci5yZXBsYWNlKC9eKD8hJCkoPzogJCk/L2dtLCAnIycpO1xuZnVuY3Rpb24gaW5kZW50Q29tbWVudChjb21tZW50LCBpbmRlbnQpIHtcbiAgICBpZiAoL15cXG4rJC8udGVzdChjb21tZW50KSlcbiAgICAgICAgcmV0dXJuIGNvbW1lbnQuc3Vic3RyaW5nKDEpO1xuICAgIHJldHVybiBpbmRlbnQgPyBjb21tZW50LnJlcGxhY2UoL14oPyEgKiQpL2dtLCBpbmRlbnQpIDogY29tbWVudDtcbn1cbmNvbnN0IGxpbmVDb21tZW50ID0gKHN0ciwgaW5kZW50LCBjb21tZW50KSA9PiBjb21tZW50LmluY2x1ZGVzKCdcXG4nKVxuICAgID8gJ1xcbicgKyBpbmRlbnRDb21tZW50KGNvbW1lbnQsIGluZGVudClcbiAgICA6IChzdHIuZW5kc1dpdGgoJyAnKSA/ICcnIDogJyAnKSArIGNvbW1lbnQ7XG5cbmV4cG9ydCB7IGluZGVudENvbW1lbnQsIGxpbmVDb21tZW50LCBzdHJpbmdpZnlDb21tZW50IH07XG4iLCAiY29uc3QgRk9MRF9GTE9XID0gJ2Zsb3cnO1xuY29uc3QgRk9MRF9CTE9DSyA9ICdibG9jayc7XG5jb25zdCBGT0xEX1FVT1RFRCA9ICdxdW90ZWQnO1xuLyoqXG4gKiBUcmllcyB0byBrZWVwIGlucHV0IGF0IHVwIHRvIGBsaW5lV2lkdGhgIGNoYXJhY3RlcnMsIHNwbGl0dGluZyBvbmx5IG9uIHNwYWNlc1xuICogbm90IGZvbGxvd2VkIGJ5IG5ld2xpbmVzIG9yIHNwYWNlcyB1bmxlc3MgYG1vZGVgIGlzIGAncXVvdGVkJ2AuIExpbmVzIGFyZVxuICogdGVybWluYXRlZCB3aXRoIGBcXG5gIGFuZCBzdGFydGVkIHdpdGggYGluZGVudGAuXG4gKi9cbmZ1bmN0aW9uIGZvbGRGbG93TGluZXModGV4dCwgaW5kZW50LCBtb2RlID0gJ2Zsb3cnLCB7IGluZGVudEF0U3RhcnQsIGxpbmVXaWR0aCA9IDgwLCBtaW5Db250ZW50V2lkdGggPSAyMCwgb25Gb2xkLCBvbk92ZXJmbG93IH0gPSB7fSkge1xuICAgIGlmICghbGluZVdpZHRoIHx8IGxpbmVXaWR0aCA8IDApXG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgIGNvbnN0IGVuZFN0ZXAgPSBNYXRoLm1heCgxICsgbWluQ29udGVudFdpZHRoLCAxICsgbGluZVdpZHRoIC0gaW5kZW50Lmxlbmd0aCk7XG4gICAgaWYgKHRleHQubGVuZ3RoIDw9IGVuZFN0ZXApXG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgIGNvbnN0IGZvbGRzID0gW107XG4gICAgY29uc3QgZXNjYXBlZEZvbGRzID0ge307XG4gICAgbGV0IGVuZCA9IGxpbmVXaWR0aCAtIGluZGVudC5sZW5ndGg7XG4gICAgaWYgKHR5cGVvZiBpbmRlbnRBdFN0YXJ0ID09PSAnbnVtYmVyJykge1xuICAgICAgICBpZiAoaW5kZW50QXRTdGFydCA+IGxpbmVXaWR0aCAtIE1hdGgubWF4KDIsIG1pbkNvbnRlbnRXaWR0aCkpXG4gICAgICAgICAgICBmb2xkcy5wdXNoKDApO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBlbmQgPSBsaW5lV2lkdGggLSBpbmRlbnRBdFN0YXJ0O1xuICAgIH1cbiAgICBsZXQgc3BsaXQgPSB1bmRlZmluZWQ7XG4gICAgbGV0IHByZXYgPSB1bmRlZmluZWQ7XG4gICAgbGV0IG92ZXJmbG93ID0gZmFsc2U7XG4gICAgbGV0IGkgPSAtMTtcbiAgICBsZXQgZXNjU3RhcnQgPSAtMTtcbiAgICBsZXQgZXNjRW5kID0gLTE7XG4gICAgaWYgKG1vZGUgPT09IEZPTERfQkxPQ0spIHtcbiAgICAgICAgaSA9IGNvbnN1bWVNb3JlSW5kZW50ZWRMaW5lcyh0ZXh0LCBpKTtcbiAgICAgICAgaWYgKGkgIT09IC0xKVxuICAgICAgICAgICAgZW5kID0gaSArIGVuZFN0ZXA7XG4gICAgfVxuICAgIGZvciAobGV0IGNoOyAoY2ggPSB0ZXh0WyhpICs9IDEpXSk7KSB7XG4gICAgICAgIGlmIChtb2RlID09PSBGT0xEX1FVT1RFRCAmJiBjaCA9PT0gJ1xcXFwnKSB7XG4gICAgICAgICAgICBlc2NTdGFydCA9IGk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRleHRbaSArIDFdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAneCc6XG4gICAgICAgICAgICAgICAgICAgIGkgKz0gMztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAndSc6XG4gICAgICAgICAgICAgICAgICAgIGkgKz0gNTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnVSc6XG4gICAgICAgICAgICAgICAgICAgIGkgKz0gOTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaSArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXNjRW5kID0gaTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2ggPT09ICdcXG4nKSB7XG4gICAgICAgICAgICBpZiAobW9kZSA9PT0gRk9MRF9CTE9DSylcbiAgICAgICAgICAgICAgICBpID0gY29uc3VtZU1vcmVJbmRlbnRlZExpbmVzKHRleHQsIGkpO1xuICAgICAgICAgICAgZW5kID0gaSArIGVuZFN0ZXA7XG4gICAgICAgICAgICBzcGxpdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChjaCA9PT0gJyAnICYmXG4gICAgICAgICAgICAgICAgcHJldiAmJlxuICAgICAgICAgICAgICAgIHByZXYgIT09ICcgJyAmJlxuICAgICAgICAgICAgICAgIHByZXYgIT09ICdcXG4nICYmXG4gICAgICAgICAgICAgICAgcHJldiAhPT0gJ1xcdCcpIHtcbiAgICAgICAgICAgICAgICAvLyBzcGFjZSBzdXJyb3VuZGVkIGJ5IG5vbi1zcGFjZSBjYW4gYmUgcmVwbGFjZWQgd2l0aCBuZXdsaW5lICsgaW5kZW50XG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dCA9IHRleHRbaSArIDFdO1xuICAgICAgICAgICAgICAgIGlmIChuZXh0ICYmIG5leHQgIT09ICcgJyAmJiBuZXh0ICE9PSAnXFxuJyAmJiBuZXh0ICE9PSAnXFx0JylcbiAgICAgICAgICAgICAgICAgICAgc3BsaXQgPSBpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGkgPj0gZW5kKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNwbGl0KSB7XG4gICAgICAgICAgICAgICAgICAgIGZvbGRzLnB1c2goc3BsaXQpO1xuICAgICAgICAgICAgICAgICAgICBlbmQgPSBzcGxpdCArIGVuZFN0ZXA7XG4gICAgICAgICAgICAgICAgICAgIHNwbGl0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChtb2RlID09PSBGT0xEX1FVT1RFRCkge1xuICAgICAgICAgICAgICAgICAgICAvLyB3aGl0ZS1zcGFjZSBjb2xsZWN0ZWQgYXQgZW5kIG1heSBzdHJldGNoIHBhc3QgbGluZVdpZHRoXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChwcmV2ID09PSAnICcgfHwgcHJldiA9PT0gJ1xcdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXYgPSBjaDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoID0gdGV4dFsoaSArPSAxKV07XG4gICAgICAgICAgICAgICAgICAgICAgICBvdmVyZmxvdyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gQWNjb3VudCBmb3IgbmV3bGluZSBlc2NhcGUsIGJ1dCBkb24ndCBicmVhayBwcmVjZWRpbmcgZXNjYXBlXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGogPSBpID4gZXNjRW5kICsgMSA/IGkgLSAyIDogZXNjU3RhcnQgLSAxO1xuICAgICAgICAgICAgICAgICAgICAvLyBCYWlsIG91dCBpZiBsaW5lV2lkdGggJiBtaW5Db250ZW50V2lkdGggYXJlIHNob3J0ZXIgdGhhbiBhbiBlc2NhcGUgc3RyaW5nXG4gICAgICAgICAgICAgICAgICAgIGlmIChlc2NhcGVkRm9sZHNbal0pXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGV4dDtcbiAgICAgICAgICAgICAgICAgICAgZm9sZHMucHVzaChqKTtcbiAgICAgICAgICAgICAgICAgICAgZXNjYXBlZEZvbGRzW2pdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgZW5kID0gaiArIGVuZFN0ZXA7XG4gICAgICAgICAgICAgICAgICAgIHNwbGl0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgb3ZlcmZsb3cgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwcmV2ID0gY2g7XG4gICAgfVxuICAgIGlmIChvdmVyZmxvdyAmJiBvbk92ZXJmbG93KVxuICAgICAgICBvbk92ZXJmbG93KCk7XG4gICAgaWYgKGZvbGRzLmxlbmd0aCA9PT0gMClcbiAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgaWYgKG9uRm9sZClcbiAgICAgICAgb25Gb2xkKCk7XG4gICAgbGV0IHJlcyA9IHRleHQuc2xpY2UoMCwgZm9sZHNbMF0pO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZm9sZHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29uc3QgZm9sZCA9IGZvbGRzW2ldO1xuICAgICAgICBjb25zdCBlbmQgPSBmb2xkc1tpICsgMV0gfHwgdGV4dC5sZW5ndGg7XG4gICAgICAgIGlmIChmb2xkID09PSAwKVxuICAgICAgICAgICAgcmVzID0gYFxcbiR7aW5kZW50fSR7dGV4dC5zbGljZSgwLCBlbmQpfWA7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKG1vZGUgPT09IEZPTERfUVVPVEVEICYmIGVzY2FwZWRGb2xkc1tmb2xkXSlcbiAgICAgICAgICAgICAgICByZXMgKz0gYCR7dGV4dFtmb2xkXX1cXFxcYDtcbiAgICAgICAgICAgIHJlcyArPSBgXFxuJHtpbmRlbnR9JHt0ZXh0LnNsaWNlKGZvbGQgKyAxLCBlbmQpfWA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbi8qKlxuICogUHJlc3VtZXMgYGkgKyAxYCBpcyBhdCB0aGUgc3RhcnQgb2YgYSBsaW5lXG4gKiBAcmV0dXJucyBpbmRleCBvZiBsYXN0IG5ld2xpbmUgaW4gbW9yZS1pbmRlbnRlZCBibG9ja1xuICovXG5mdW5jdGlvbiBjb25zdW1lTW9yZUluZGVudGVkTGluZXModGV4dCwgaSkge1xuICAgIGxldCBjaCA9IHRleHRbaSArIDFdO1xuICAgIHdoaWxlIChjaCA9PT0gJyAnIHx8IGNoID09PSAnXFx0Jykge1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICBjaCA9IHRleHRbKGkgKz0gMSldO1xuICAgICAgICB9IHdoaWxlIChjaCAmJiBjaCAhPT0gJ1xcbicpO1xuICAgICAgICBjaCA9IHRleHRbaSArIDFdO1xuICAgIH1cbiAgICByZXR1cm4gaTtcbn1cblxuZXhwb3J0IHsgRk9MRF9CTE9DSywgRk9MRF9GTE9XLCBGT0xEX1FVT1RFRCwgZm9sZEZsb3dMaW5lcyB9O1xuIiwgImltcG9ydCB7IFNjYWxhciB9IGZyb20gJy4uL25vZGVzL1NjYWxhci5qcyc7XG5pbXBvcnQgeyBmb2xkRmxvd0xpbmVzLCBGT0xEX1FVT1RFRCwgRk9MRF9GTE9XLCBGT0xEX0JMT0NLIH0gZnJvbSAnLi9mb2xkRmxvd0xpbmVzLmpzJztcblxuY29uc3QgZ2V0Rm9sZE9wdGlvbnMgPSAoY3R4KSA9PiAoe1xuICAgIGluZGVudEF0U3RhcnQ6IGN0eC5pbmRlbnRBdFN0YXJ0LFxuICAgIGxpbmVXaWR0aDogY3R4Lm9wdGlvbnMubGluZVdpZHRoLFxuICAgIG1pbkNvbnRlbnRXaWR0aDogY3R4Lm9wdGlvbnMubWluQ29udGVudFdpZHRoXG59KTtcbi8vIEFsc28gY2hlY2tzIGZvciBsaW5lcyBzdGFydGluZyB3aXRoICUsIGFzIHBhcnNpbmcgdGhlIG91dHB1dCBhcyBZQU1MIDEuMSB3aWxsXG4vLyBwcmVzdW1lIHRoYXQncyBzdGFydGluZyBhIG5ldyBkb2N1bWVudC5cbmNvbnN0IGNvbnRhaW5zRG9jdW1lbnRNYXJrZXIgPSAoc3RyKSA9PiAvXiglfC0tLXxcXC5cXC5cXC4pL20udGVzdChzdHIpO1xuZnVuY3Rpb24gbGluZUxlbmd0aE92ZXJMaW1pdChzdHIsIGxpbmVXaWR0aCwgaW5kZW50TGVuZ3RoKSB7XG4gICAgaWYgKCFsaW5lV2lkdGggfHwgbGluZVdpZHRoIDwgMClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGNvbnN0IGxpbWl0ID0gbGluZVdpZHRoIC0gaW5kZW50TGVuZ3RoO1xuICAgIGNvbnN0IHN0ckxlbiA9IHN0ci5sZW5ndGg7XG4gICAgaWYgKHN0ckxlbiA8PSBsaW1pdClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGZvciAobGV0IGkgPSAwLCBzdGFydCA9IDA7IGkgPCBzdHJMZW47ICsraSkge1xuICAgICAgICBpZiAoc3RyW2ldID09PSAnXFxuJykge1xuICAgICAgICAgICAgaWYgKGkgLSBzdGFydCA+IGxpbWl0KVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgc3RhcnQgPSBpICsgMTtcbiAgICAgICAgICAgIGlmIChzdHJMZW4gLSBzdGFydCA8PSBsaW1pdClcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBkb3VibGVRdW90ZWRTdHJpbmcodmFsdWUsIGN0eCkge1xuICAgIGNvbnN0IGpzb24gPSBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG4gICAgaWYgKGN0eC5vcHRpb25zLmRvdWJsZVF1b3RlZEFzSlNPTilcbiAgICAgICAgcmV0dXJuIGpzb247XG4gICAgY29uc3QgeyBpbXBsaWNpdEtleSB9ID0gY3R4O1xuICAgIGNvbnN0IG1pbk11bHRpTGluZUxlbmd0aCA9IGN0eC5vcHRpb25zLmRvdWJsZVF1b3RlZE1pbk11bHRpTGluZUxlbmd0aDtcbiAgICBjb25zdCBpbmRlbnQgPSBjdHguaW5kZW50IHx8IChjb250YWluc0RvY3VtZW50TWFya2VyKHZhbHVlKSA/ICcgICcgOiAnJyk7XG4gICAgbGV0IHN0ciA9ICcnO1xuICAgIGxldCBzdGFydCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDAsIGNoID0ganNvbltpXTsgY2g7IGNoID0ganNvblsrK2ldKSB7XG4gICAgICAgIGlmIChjaCA9PT0gJyAnICYmIGpzb25baSArIDFdID09PSAnXFxcXCcgJiYganNvbltpICsgMl0gPT09ICduJykge1xuICAgICAgICAgICAgLy8gc3BhY2UgYmVmb3JlIG5ld2xpbmUgbmVlZHMgdG8gYmUgZXNjYXBlZCB0byBub3QgYmUgZm9sZGVkXG4gICAgICAgICAgICBzdHIgKz0ganNvbi5zbGljZShzdGFydCwgaSkgKyAnXFxcXCAnO1xuICAgICAgICAgICAgaSArPSAxO1xuICAgICAgICAgICAgc3RhcnQgPSBpO1xuICAgICAgICAgICAgY2ggPSAnXFxcXCc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoID09PSAnXFxcXCcpXG4gICAgICAgICAgICBzd2l0Y2ggKGpzb25baSArIDFdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAndSc6XG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSBqc29uLnNsaWNlKHN0YXJ0LCBpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvZGUgPSBqc29uLnN1YnN0cihpICsgMiwgNCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGNvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICcwMDAwJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9ICdcXFxcMCc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJzAwMDcnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gJ1xcXFxhJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnMDAwYic6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSAnXFxcXHYnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICcwMDFiJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9ICdcXFxcZSc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJzAwODUnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gJ1xcXFxOJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnMDBhMCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSAnXFxcXF8nO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICcyMDI4JzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9ICdcXFxcTCc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJzIwMjknOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gJ1xcXFxQJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvZGUuc3Vic3RyKDAsIDIpID09PSAnMDAnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9ICdcXFxceCcgKyBjb2RlLnN1YnN0cigyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9IGpzb24uc3Vic3RyKGksIDYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaSArPSA1O1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSBpICsgMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICduJzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGltcGxpY2l0S2V5IHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBqc29uW2kgKyAyXSA9PT0gJ1wiJyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAganNvbi5sZW5ndGggPCBtaW5NdWx0aUxpbmVMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZvbGRpbmcgd2lsbCBlYXQgZmlyc3QgbmV3bGluZVxuICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9IGpzb24uc2xpY2Uoc3RhcnQsIGkpICsgJ1xcblxcbic7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoanNvbltpICsgMl0gPT09ICdcXFxcJyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpzb25baSArIDNdID09PSAnbicgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqc29uW2kgKyA0XSAhPT0gJ1wiJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSAnXFxuJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpICs9IDI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gaW5kZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3BhY2UgYWZ0ZXIgbmV3bGluZSBuZWVkcyB0byBiZSBlc2NhcGVkIHRvIG5vdCBiZSBmb2xkZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChqc29uW2kgKyAyXSA9PT0gJyAnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSAnXFxcXCc7XG4gICAgICAgICAgICAgICAgICAgICAgICBpICs9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydCA9IGkgKyAxO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICB9XG4gICAgc3RyID0gc3RhcnQgPyBzdHIgKyBqc29uLnNsaWNlKHN0YXJ0KSA6IGpzb247XG4gICAgcmV0dXJuIGltcGxpY2l0S2V5XG4gICAgICAgID8gc3RyXG4gICAgICAgIDogZm9sZEZsb3dMaW5lcyhzdHIsIGluZGVudCwgRk9MRF9RVU9URUQsIGdldEZvbGRPcHRpb25zKGN0eCkpO1xufVxuZnVuY3Rpb24gc2luZ2xlUXVvdGVkU3RyaW5nKHZhbHVlLCBjdHgpIHtcbiAgICBpZiAoY3R4Lm9wdGlvbnMuc2luZ2xlUXVvdGUgPT09IGZhbHNlIHx8XG4gICAgICAgIChjdHguaW1wbGljaXRLZXkgJiYgdmFsdWUuaW5jbHVkZXMoJ1xcbicpKSB8fFxuICAgICAgICAvWyBcXHRdXFxufFxcblsgXFx0XS8udGVzdCh2YWx1ZSkgLy8gc2luZ2xlIHF1b3RlZCBzdHJpbmcgY2FuJ3QgaGF2ZSBsZWFkaW5nIG9yIHRyYWlsaW5nIHdoaXRlc3BhY2UgYXJvdW5kIG5ld2xpbmVcbiAgICApXG4gICAgICAgIHJldHVybiBkb3VibGVRdW90ZWRTdHJpbmcodmFsdWUsIGN0eCk7XG4gICAgY29uc3QgaW5kZW50ID0gY3R4LmluZGVudCB8fCAoY29udGFpbnNEb2N1bWVudE1hcmtlcih2YWx1ZSkgPyAnICAnIDogJycpO1xuICAgIGNvbnN0IHJlcyA9IFwiJ1wiICsgdmFsdWUucmVwbGFjZSgvJy9nLCBcIicnXCIpLnJlcGxhY2UoL1xcbisvZywgYCQmXFxuJHtpbmRlbnR9YCkgKyBcIidcIjtcbiAgICByZXR1cm4gY3R4LmltcGxpY2l0S2V5XG4gICAgICAgID8gcmVzXG4gICAgICAgIDogZm9sZEZsb3dMaW5lcyhyZXMsIGluZGVudCwgRk9MRF9GTE9XLCBnZXRGb2xkT3B0aW9ucyhjdHgpKTtcbn1cbmZ1bmN0aW9uIHF1b3RlZFN0cmluZyh2YWx1ZSwgY3R4KSB7XG4gICAgY29uc3QgeyBzaW5nbGVRdW90ZSB9ID0gY3R4Lm9wdGlvbnM7XG4gICAgbGV0IHFzO1xuICAgIGlmIChzaW5nbGVRdW90ZSA9PT0gZmFsc2UpXG4gICAgICAgIHFzID0gZG91YmxlUXVvdGVkU3RyaW5nO1xuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBoYXNEb3VibGUgPSB2YWx1ZS5pbmNsdWRlcygnXCInKTtcbiAgICAgICAgY29uc3QgaGFzU2luZ2xlID0gdmFsdWUuaW5jbHVkZXMoXCInXCIpO1xuICAgICAgICBpZiAoaGFzRG91YmxlICYmICFoYXNTaW5nbGUpXG4gICAgICAgICAgICBxcyA9IHNpbmdsZVF1b3RlZFN0cmluZztcbiAgICAgICAgZWxzZSBpZiAoaGFzU2luZ2xlICYmICFoYXNEb3VibGUpXG4gICAgICAgICAgICBxcyA9IGRvdWJsZVF1b3RlZFN0cmluZztcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcXMgPSBzaW5nbGVRdW90ZSA/IHNpbmdsZVF1b3RlZFN0cmluZyA6IGRvdWJsZVF1b3RlZFN0cmluZztcbiAgICB9XG4gICAgcmV0dXJuIHFzKHZhbHVlLCBjdHgpO1xufVxuZnVuY3Rpb24gYmxvY2tTdHJpbmcoeyBjb21tZW50LCB0eXBlLCB2YWx1ZSB9LCBjdHgsIG9uQ29tbWVudCwgb25DaG9tcEtlZXApIHtcbiAgICBjb25zdCB7IGJsb2NrUXVvdGUsIGNvbW1lbnRTdHJpbmcsIGxpbmVXaWR0aCB9ID0gY3R4Lm9wdGlvbnM7XG4gICAgLy8gMS4gQmxvY2sgY2FuJ3QgZW5kIGluIHdoaXRlc3BhY2UgdW5sZXNzIHRoZSBsYXN0IGxpbmUgaXMgbm9uLWVtcHR5LlxuICAgIC8vIDIuIFN0cmluZ3MgY29uc2lzdGluZyBvZiBvbmx5IHdoaXRlc3BhY2UgYXJlIGJlc3QgcmVuZGVyZWQgZXhwbGljaXRseS5cbiAgICBpZiAoIWJsb2NrUXVvdGUgfHwgL1xcbltcXHQgXSskLy50ZXN0KHZhbHVlKSB8fCAvXlxccyokLy50ZXN0KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gcXVvdGVkU3RyaW5nKHZhbHVlLCBjdHgpO1xuICAgIH1cbiAgICBjb25zdCBpbmRlbnQgPSBjdHguaW5kZW50IHx8XG4gICAgICAgIChjdHguZm9yY2VCbG9ja0luZGVudCB8fCBjb250YWluc0RvY3VtZW50TWFya2VyKHZhbHVlKSA/ICcgICcgOiAnJyk7XG4gICAgY29uc3QgbGl0ZXJhbCA9IGJsb2NrUXVvdGUgPT09ICdsaXRlcmFsJ1xuICAgICAgICA/IHRydWVcbiAgICAgICAgOiBibG9ja1F1b3RlID09PSAnZm9sZGVkJyB8fCB0eXBlID09PSBTY2FsYXIuQkxPQ0tfRk9MREVEXG4gICAgICAgICAgICA/IGZhbHNlXG4gICAgICAgICAgICA6IHR5cGUgPT09IFNjYWxhci5CTE9DS19MSVRFUkFMXG4gICAgICAgICAgICAgICAgPyB0cnVlXG4gICAgICAgICAgICAgICAgOiAhbGluZUxlbmd0aE92ZXJMaW1pdCh2YWx1ZSwgbGluZVdpZHRoLCBpbmRlbnQubGVuZ3RoKTtcbiAgICBpZiAoIXZhbHVlKVxuICAgICAgICByZXR1cm4gbGl0ZXJhbCA/ICd8XFxuJyA6ICc+XFxuJztcbiAgICAvLyBkZXRlcm1pbmUgY2hvbXBpbmcgZnJvbSB3aGl0ZXNwYWNlIGF0IHZhbHVlIGVuZFxuICAgIGxldCBjaG9tcDtcbiAgICBsZXQgZW5kU3RhcnQ7XG4gICAgZm9yIChlbmRTdGFydCA9IHZhbHVlLmxlbmd0aDsgZW5kU3RhcnQgPiAwOyAtLWVuZFN0YXJ0KSB7XG4gICAgICAgIGNvbnN0IGNoID0gdmFsdWVbZW5kU3RhcnQgLSAxXTtcbiAgICAgICAgaWYgKGNoICE9PSAnXFxuJyAmJiBjaCAhPT0gJ1xcdCcgJiYgY2ggIT09ICcgJylcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBsZXQgZW5kID0gdmFsdWUuc3Vic3RyaW5nKGVuZFN0YXJ0KTtcbiAgICBjb25zdCBlbmRObFBvcyA9IGVuZC5pbmRleE9mKCdcXG4nKTtcbiAgICBpZiAoZW5kTmxQb3MgPT09IC0xKSB7XG4gICAgICAgIGNob21wID0gJy0nOyAvLyBzdHJpcFxuICAgIH1cbiAgICBlbHNlIGlmICh2YWx1ZSA9PT0gZW5kIHx8IGVuZE5sUG9zICE9PSBlbmQubGVuZ3RoIC0gMSkge1xuICAgICAgICBjaG9tcCA9ICcrJzsgLy8ga2VlcFxuICAgICAgICBpZiAob25DaG9tcEtlZXApXG4gICAgICAgICAgICBvbkNob21wS2VlcCgpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY2hvbXAgPSAnJzsgLy8gY2xpcFxuICAgIH1cbiAgICBpZiAoZW5kKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUuc2xpY2UoMCwgLWVuZC5sZW5ndGgpO1xuICAgICAgICBpZiAoZW5kW2VuZC5sZW5ndGggLSAxXSA9PT0gJ1xcbicpXG4gICAgICAgICAgICBlbmQgPSBlbmQuc2xpY2UoMCwgLTEpO1xuICAgICAgICBlbmQgPSBlbmQucmVwbGFjZSgvXFxuKyg/IVxcbnwkKS9nLCBgJCYke2luZGVudH1gKTtcbiAgICB9XG4gICAgLy8gZGV0ZXJtaW5lIGluZGVudCBpbmRpY2F0b3IgZnJvbSB3aGl0ZXNwYWNlIGF0IHZhbHVlIHN0YXJ0XG4gICAgbGV0IHN0YXJ0V2l0aFNwYWNlID0gZmFsc2U7XG4gICAgbGV0IHN0YXJ0RW5kO1xuICAgIGxldCBzdGFydE5sUG9zID0gLTE7XG4gICAgZm9yIChzdGFydEVuZCA9IDA7IHN0YXJ0RW5kIDwgdmFsdWUubGVuZ3RoOyArK3N0YXJ0RW5kKSB7XG4gICAgICAgIGNvbnN0IGNoID0gdmFsdWVbc3RhcnRFbmRdO1xuICAgICAgICBpZiAoY2ggPT09ICcgJylcbiAgICAgICAgICAgIHN0YXJ0V2l0aFNwYWNlID0gdHJ1ZTtcbiAgICAgICAgZWxzZSBpZiAoY2ggPT09ICdcXG4nKVxuICAgICAgICAgICAgc3RhcnRObFBvcyA9IHN0YXJ0RW5kO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgbGV0IHN0YXJ0ID0gdmFsdWUuc3Vic3RyaW5nKDAsIHN0YXJ0TmxQb3MgPCBzdGFydEVuZCA/IHN0YXJ0TmxQb3MgKyAxIDogc3RhcnRFbmQpO1xuICAgIGlmIChzdGFydCkge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLnN1YnN0cmluZyhzdGFydC5sZW5ndGgpO1xuICAgICAgICBzdGFydCA9IHN0YXJ0LnJlcGxhY2UoL1xcbisvZywgYCQmJHtpbmRlbnR9YCk7XG4gICAgfVxuICAgIGNvbnN0IGluZGVudFNpemUgPSBpbmRlbnQgPyAnMicgOiAnMSc7IC8vIHJvb3QgaXMgYXQgLTFcbiAgICBsZXQgaGVhZGVyID0gKGxpdGVyYWwgPyAnfCcgOiAnPicpICsgKHN0YXJ0V2l0aFNwYWNlID8gaW5kZW50U2l6ZSA6ICcnKSArIGNob21wO1xuICAgIGlmIChjb21tZW50KSB7XG4gICAgICAgIGhlYWRlciArPSAnICcgKyBjb21tZW50U3RyaW5nKGNvbW1lbnQucmVwbGFjZSgvID9bXFxyXFxuXSsvZywgJyAnKSk7XG4gICAgICAgIGlmIChvbkNvbW1lbnQpXG4gICAgICAgICAgICBvbkNvbW1lbnQoKTtcbiAgICB9XG4gICAgaWYgKGxpdGVyYWwpIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9cXG4rL2csIGAkJiR7aW5kZW50fWApO1xuICAgICAgICByZXR1cm4gYCR7aGVhZGVyfVxcbiR7aW5kZW50fSR7c3RhcnR9JHt2YWx1ZX0ke2VuZH1gO1xuICAgIH1cbiAgICB2YWx1ZSA9IHZhbHVlXG4gICAgICAgIC5yZXBsYWNlKC9cXG4rL2csICdcXG4kJicpXG4gICAgICAgIC5yZXBsYWNlKC8oPzpefFxcbikoW1xcdCBdLiopKD86KFtcXG5cXHQgXSopXFxuKD8hW1xcblxcdCBdKSk/L2csICckMSQyJykgLy8gbW9yZS1pbmRlbnRlZCBsaW5lcyBhcmVuJ3QgZm9sZGVkXG4gICAgICAgIC8vICAgICAgICAgICAgICAgIF4gbW9yZS1pbmQuIF4gZW1wdHkgICAgIF4gY2FwdHVyZSBuZXh0IGVtcHR5IGxpbmVzIG9ubHkgYXQgZW5kIG9mIGluZGVudFxuICAgICAgICAucmVwbGFjZSgvXFxuKy9nLCBgJCYke2luZGVudH1gKTtcbiAgICBjb25zdCBib2R5ID0gZm9sZEZsb3dMaW5lcyhgJHtzdGFydH0ke3ZhbHVlfSR7ZW5kfWAsIGluZGVudCwgRk9MRF9CTE9DSywgZ2V0Rm9sZE9wdGlvbnMoY3R4KSk7XG4gICAgcmV0dXJuIGAke2hlYWRlcn1cXG4ke2luZGVudH0ke2JvZHl9YDtcbn1cbmZ1bmN0aW9uIHBsYWluU3RyaW5nKGl0ZW0sIGN0eCwgb25Db21tZW50LCBvbkNob21wS2VlcCkge1xuICAgIGNvbnN0IHsgdHlwZSwgdmFsdWUgfSA9IGl0ZW07XG4gICAgY29uc3QgeyBhY3R1YWxTdHJpbmcsIGltcGxpY2l0S2V5LCBpbmRlbnQsIGluRmxvdyB9ID0gY3R4O1xuICAgIGlmICgoaW1wbGljaXRLZXkgJiYgL1tcXG5bXFxde30sXS8udGVzdCh2YWx1ZSkpIHx8XG4gICAgICAgIChpbkZsb3cgJiYgL1tbXFxde30sXS8udGVzdCh2YWx1ZSkpKSB7XG4gICAgICAgIHJldHVybiBxdW90ZWRTdHJpbmcodmFsdWUsIGN0eCk7XG4gICAgfVxuICAgIGlmICghdmFsdWUgfHxcbiAgICAgICAgL15bXFxuXFx0ICxbXFxde30jJiohfD4nXCIlQGBdfF5bPy1dJHxeWz8tXVsgXFx0XXxbXFxuOl1bIFxcdF18WyBcXHRdXFxufFtcXG5cXHQgXSN8W1xcblxcdCA6XSQvLnRlc3QodmFsdWUpKSB7XG4gICAgICAgIC8vIG5vdCBhbGxvd2VkOlxuICAgICAgICAvLyAtIGVtcHR5IHN0cmluZywgJy0nIG9yICc/J1xuICAgICAgICAvLyAtIHN0YXJ0IHdpdGggYW4gaW5kaWNhdG9yIGNoYXJhY3RlciAoZXhjZXB0IFs/Oi1dKSBvciAvWz8tXSAvXG4gICAgICAgIC8vIC0gJ1xcbiAnLCAnOiAnIG9yICcgXFxuJyBhbnl3aGVyZVxuICAgICAgICAvLyAtICcjJyBub3QgcHJlY2VkZWQgYnkgYSBub24tc3BhY2UgY2hhclxuICAgICAgICAvLyAtIGVuZCB3aXRoICcgJyBvciAnOidcbiAgICAgICAgcmV0dXJuIGltcGxpY2l0S2V5IHx8IGluRmxvdyB8fCB2YWx1ZS5pbmRleE9mKCdcXG4nKSA9PT0gLTFcbiAgICAgICAgICAgID8gcXVvdGVkU3RyaW5nKHZhbHVlLCBjdHgpXG4gICAgICAgICAgICA6IGJsb2NrU3RyaW5nKGl0ZW0sIGN0eCwgb25Db21tZW50LCBvbkNob21wS2VlcCk7XG4gICAgfVxuICAgIGlmICghaW1wbGljaXRLZXkgJiZcbiAgICAgICAgIWluRmxvdyAmJlxuICAgICAgICB0eXBlICE9PSBTY2FsYXIuUExBSU4gJiZcbiAgICAgICAgdmFsdWUuaW5kZXhPZignXFxuJykgIT09IC0xKSB7XG4gICAgICAgIC8vIFdoZXJlIGFsbG93ZWQgJiB0eXBlIG5vdCBzZXQgZXhwbGljaXRseSwgcHJlZmVyIGJsb2NrIHN0eWxlIGZvciBtdWx0aWxpbmUgc3RyaW5nc1xuICAgICAgICByZXR1cm4gYmxvY2tTdHJpbmcoaXRlbSwgY3R4LCBvbkNvbW1lbnQsIG9uQ2hvbXBLZWVwKTtcbiAgICB9XG4gICAgaWYgKGluZGVudCA9PT0gJycgJiYgY29udGFpbnNEb2N1bWVudE1hcmtlcih2YWx1ZSkpIHtcbiAgICAgICAgY3R4LmZvcmNlQmxvY2tJbmRlbnQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gYmxvY2tTdHJpbmcoaXRlbSwgY3R4LCBvbkNvbW1lbnQsIG9uQ2hvbXBLZWVwKTtcbiAgICB9XG4gICAgY29uc3Qgc3RyID0gdmFsdWUucmVwbGFjZSgvXFxuKy9nLCBgJCZcXG4ke2luZGVudH1gKTtcbiAgICAvLyBWZXJpZnkgdGhhdCBvdXRwdXQgd2lsbCBiZSBwYXJzZWQgYXMgYSBzdHJpbmcsIGFzIGUuZy4gcGxhaW4gbnVtYmVycyBhbmRcbiAgICAvLyBib29sZWFucyBnZXQgcGFyc2VkIHdpdGggdGhvc2UgdHlwZXMgaW4gdjEuMiAoZS5nLiAnNDInLCAndHJ1ZScgJiAnMC45ZS0zJyksXG4gICAgLy8gYW5kIG90aGVycyBpbiB2MS4xLlxuICAgIGlmIChhY3R1YWxTdHJpbmcpIHtcbiAgICAgICAgY29uc3QgdGVzdCA9ICh0YWcpID0+IHsgdmFyIF9hOyByZXR1cm4gdGFnLmRlZmF1bHQgJiYgdGFnLnRhZyAhPT0gJ3RhZzp5YW1sLm9yZywyMDAyOnN0cicgJiYgKChfYSA9IHRhZy50ZXN0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudGVzdChzdHIpKTsgfTtcbiAgICAgICAgY29uc3QgeyBjb21wYXQsIHRhZ3MgfSA9IGN0eC5kb2Muc2NoZW1hO1xuICAgICAgICBpZiAodGFncy5zb21lKHRlc3QpIHx8IChjb21wYXQgPT09IG51bGwgfHwgY29tcGF0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb21wYXQuc29tZSh0ZXN0KSkpXG4gICAgICAgICAgICByZXR1cm4gcXVvdGVkU3RyaW5nKHZhbHVlLCBjdHgpO1xuICAgIH1cbiAgICByZXR1cm4gaW1wbGljaXRLZXlcbiAgICAgICAgPyBzdHJcbiAgICAgICAgOiBmb2xkRmxvd0xpbmVzKHN0ciwgaW5kZW50LCBGT0xEX0ZMT1csIGdldEZvbGRPcHRpb25zKGN0eCkpO1xufVxuZnVuY3Rpb24gc3RyaW5naWZ5U3RyaW5nKGl0ZW0sIGN0eCwgb25Db21tZW50LCBvbkNob21wS2VlcCkge1xuICAgIGNvbnN0IHsgaW1wbGljaXRLZXksIGluRmxvdyB9ID0gY3R4O1xuICAgIGNvbnN0IHNzID0gdHlwZW9mIGl0ZW0udmFsdWUgPT09ICdzdHJpbmcnXG4gICAgICAgID8gaXRlbVxuICAgICAgICA6IE9iamVjdC5hc3NpZ24oe30sIGl0ZW0sIHsgdmFsdWU6IFN0cmluZyhpdGVtLnZhbHVlKSB9KTtcbiAgICBsZXQgeyB0eXBlIH0gPSBpdGVtO1xuICAgIGlmICh0eXBlICE9PSBTY2FsYXIuUVVPVEVfRE9VQkxFKSB7XG4gICAgICAgIC8vIGZvcmNlIGRvdWJsZSBxdW90ZXMgb24gY29udHJvbCBjaGFyYWN0ZXJzICYgdW5wYWlyZWQgc3Vycm9nYXRlc1xuICAgICAgICBpZiAoL1tcXHgwMC1cXHgwOFxceDBiLVxceDFmXFx4N2YtXFx4OWZcXHV7RDgwMH0tXFx1e0RGRkZ9XS91LnRlc3Qoc3MudmFsdWUpKVxuICAgICAgICAgICAgdHlwZSA9IFNjYWxhci5RVU9URV9ET1VCTEU7XG4gICAgfVxuICAgIGNvbnN0IF9zdHJpbmdpZnkgPSAoX3R5cGUpID0+IHtcbiAgICAgICAgc3dpdGNoIChfdHlwZSkge1xuICAgICAgICAgICAgY2FzZSBTY2FsYXIuQkxPQ0tfRk9MREVEOlxuICAgICAgICAgICAgY2FzZSBTY2FsYXIuQkxPQ0tfTElURVJBTDpcbiAgICAgICAgICAgICAgICByZXR1cm4gaW1wbGljaXRLZXkgfHwgaW5GbG93XG4gICAgICAgICAgICAgICAgICAgID8gcXVvdGVkU3RyaW5nKHNzLnZhbHVlLCBjdHgpIC8vIGJsb2NrcyBhcmUgbm90IHZhbGlkIGluc2lkZSBmbG93IGNvbnRhaW5lcnNcbiAgICAgICAgICAgICAgICAgICAgOiBibG9ja1N0cmluZyhzcywgY3R4LCBvbkNvbW1lbnQsIG9uQ2hvbXBLZWVwKTtcbiAgICAgICAgICAgIGNhc2UgU2NhbGFyLlFVT1RFX0RPVUJMRTpcbiAgICAgICAgICAgICAgICByZXR1cm4gZG91YmxlUXVvdGVkU3RyaW5nKHNzLnZhbHVlLCBjdHgpO1xuICAgICAgICAgICAgY2FzZSBTY2FsYXIuUVVPVEVfU0lOR0xFOlxuICAgICAgICAgICAgICAgIHJldHVybiBzaW5nbGVRdW90ZWRTdHJpbmcoc3MudmFsdWUsIGN0eCk7XG4gICAgICAgICAgICBjYXNlIFNjYWxhci5QTEFJTjpcbiAgICAgICAgICAgICAgICByZXR1cm4gcGxhaW5TdHJpbmcoc3MsIGN0eCwgb25Db21tZW50LCBvbkNob21wS2VlcCk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBsZXQgcmVzID0gX3N0cmluZ2lmeSh0eXBlKTtcbiAgICBpZiAocmVzID09PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IHsgZGVmYXVsdEtleVR5cGUsIGRlZmF1bHRTdHJpbmdUeXBlIH0gPSBjdHgub3B0aW9ucztcbiAgICAgICAgY29uc3QgdCA9IChpbXBsaWNpdEtleSAmJiBkZWZhdWx0S2V5VHlwZSkgfHwgZGVmYXVsdFN0cmluZ1R5cGU7XG4gICAgICAgIHJlcyA9IF9zdHJpbmdpZnkodCk7XG4gICAgICAgIGlmIChyZXMgPT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGRlZmF1bHQgc3RyaW5nIHR5cGUgJHt0fWApO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuXG5leHBvcnQgeyBzdHJpbmdpZnlTdHJpbmcgfTtcbiIsICJpbXBvcnQgeyBhbmNob3JJc1ZhbGlkIH0gZnJvbSAnLi4vZG9jL2FuY2hvcnMuanMnO1xuaW1wb3J0IHsgaXNQYWlyLCBpc0FsaWFzLCBpc05vZGUsIGlzU2NhbGFyLCBpc0NvbGxlY3Rpb24gfSBmcm9tICcuLi9ub2Rlcy9Ob2RlLmpzJztcbmltcG9ydCB7IHN0cmluZ2lmeUNvbW1lbnQgfSBmcm9tICcuL3N0cmluZ2lmeUNvbW1lbnQuanMnO1xuaW1wb3J0IHsgc3RyaW5naWZ5U3RyaW5nIH0gZnJvbSAnLi9zdHJpbmdpZnlTdHJpbmcuanMnO1xuXG5mdW5jdGlvbiBjcmVhdGVTdHJpbmdpZnlDb250ZXh0KGRvYywgb3B0aW9ucykge1xuICAgIGNvbnN0IG9wdCA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgICBibG9ja1F1b3RlOiB0cnVlLFxuICAgICAgICBjb21tZW50U3RyaW5nOiBzdHJpbmdpZnlDb21tZW50LFxuICAgICAgICBkZWZhdWx0S2V5VHlwZTogbnVsbCxcbiAgICAgICAgZGVmYXVsdFN0cmluZ1R5cGU6ICdQTEFJTicsXG4gICAgICAgIGRpcmVjdGl2ZXM6IG51bGwsXG4gICAgICAgIGRvdWJsZVF1b3RlZEFzSlNPTjogZmFsc2UsXG4gICAgICAgIGRvdWJsZVF1b3RlZE1pbk11bHRpTGluZUxlbmd0aDogNDAsXG4gICAgICAgIGZhbHNlU3RyOiAnZmFsc2UnLFxuICAgICAgICBpbmRlbnRTZXE6IHRydWUsXG4gICAgICAgIGxpbmVXaWR0aDogODAsXG4gICAgICAgIG1pbkNvbnRlbnRXaWR0aDogMjAsXG4gICAgICAgIG51bGxTdHI6ICdudWxsJyxcbiAgICAgICAgc2ltcGxlS2V5czogZmFsc2UsXG4gICAgICAgIHNpbmdsZVF1b3RlOiBudWxsLFxuICAgICAgICB0cnVlU3RyOiAndHJ1ZScsXG4gICAgICAgIHZlcmlmeUFsaWFzT3JkZXI6IHRydWVcbiAgICB9LCBkb2Muc2NoZW1hLnRvU3RyaW5nT3B0aW9ucywgb3B0aW9ucyk7XG4gICAgbGV0IGluRmxvdztcbiAgICBzd2l0Y2ggKG9wdC5jb2xsZWN0aW9uU3R5bGUpIHtcbiAgICAgICAgY2FzZSAnYmxvY2snOlxuICAgICAgICAgICAgaW5GbG93ID0gZmFsc2U7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnZmxvdyc6XG4gICAgICAgICAgICBpbkZsb3cgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBpbkZsb3cgPSBudWxsO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBhbmNob3JzOiBuZXcgU2V0KCksXG4gICAgICAgIGRvYyxcbiAgICAgICAgaW5kZW50OiAnJyxcbiAgICAgICAgaW5kZW50U3RlcDogdHlwZW9mIG9wdC5pbmRlbnQgPT09ICdudW1iZXInID8gJyAnLnJlcGVhdChvcHQuaW5kZW50KSA6ICcgICcsXG4gICAgICAgIGluRmxvdyxcbiAgICAgICAgb3B0aW9uczogb3B0XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGdldFRhZ09iamVjdCh0YWdzLCBpdGVtKSB7XG4gICAgaWYgKGl0ZW0udGFnKSB7XG4gICAgICAgIGNvbnN0IG1hdGNoID0gdGFncy5maWx0ZXIodCA9PiB0LnRhZyA9PT0gaXRlbS50YWcpO1xuICAgICAgICBpZiAobWF0Y2gubGVuZ3RoID4gMClcbiAgICAgICAgICAgIHJldHVybiBtYXRjaC5maW5kKHQgPT4gdC5mb3JtYXQgPT09IGl0ZW0uZm9ybWF0KSB8fCBtYXRjaFswXTtcbiAgICB9XG4gICAgbGV0IHRhZ09iaiA9IHVuZGVmaW5lZDtcbiAgICBsZXQgb2JqO1xuICAgIGlmIChpc1NjYWxhcihpdGVtKSkge1xuICAgICAgICBvYmogPSBpdGVtLnZhbHVlO1xuICAgICAgICBjb25zdCBtYXRjaCA9IHRhZ3MuZmlsdGVyKHQgPT4gdC5pZGVudGlmeSAmJiB0LmlkZW50aWZ5KG9iaikpO1xuICAgICAgICB0YWdPYmogPVxuICAgICAgICAgICAgbWF0Y2guZmluZCh0ID0+IHQuZm9ybWF0ID09PSBpdGVtLmZvcm1hdCkgfHwgbWF0Y2guZmluZCh0ID0+ICF0LmZvcm1hdCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBvYmogPSBpdGVtO1xuICAgICAgICB0YWdPYmogPSB0YWdzLmZpbmQodCA9PiB0Lm5vZGVDbGFzcyAmJiBvYmogaW5zdGFuY2VvZiB0Lm5vZGVDbGFzcyk7XG4gICAgfVxuICAgIGlmICghdGFnT2JqKSB7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgY29uc3QgbmFtZSA9IG9iaiAmJiBvYmouY29uc3RydWN0b3IgPyBvYmouY29uc3RydWN0b3IubmFtZSA6IHR5cGVvZiBvYmo7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVGFnIG5vdCByZXNvbHZlZCBmb3IgJHtuYW1lfSB2YWx1ZWApO1xuICAgIH1cbiAgICByZXR1cm4gdGFnT2JqO1xufVxuLy8gbmVlZHMgdG8gYmUgY2FsbGVkIGJlZm9yZSB2YWx1ZSBzdHJpbmdpZmllciB0byBhbGxvdyBmb3IgY2lyY3VsYXIgYW5jaG9yIHJlZnNcbmZ1bmN0aW9uIHN0cmluZ2lmeVByb3BzKG5vZGUsIHRhZ09iaiwgeyBhbmNob3JzLCBkb2MgfSkge1xuICAgIGlmICghZG9jLmRpcmVjdGl2ZXMpXG4gICAgICAgIHJldHVybiAnJztcbiAgICBjb25zdCBwcm9wcyA9IFtdO1xuICAgIGNvbnN0IGFuY2hvciA9IChpc1NjYWxhcihub2RlKSB8fCBpc0NvbGxlY3Rpb24obm9kZSkpICYmIG5vZGUuYW5jaG9yO1xuICAgIGlmIChhbmNob3IgJiYgYW5jaG9ySXNWYWxpZChhbmNob3IpKSB7XG4gICAgICAgIGFuY2hvcnMuYWRkKGFuY2hvcik7XG4gICAgICAgIHByb3BzLnB1c2goYCYke2FuY2hvcn1gKTtcbiAgICB9XG4gICAgY29uc3QgdGFnID0gbm9kZS50YWcgfHwgKHRhZ09iai5kZWZhdWx0ID8gbnVsbCA6IHRhZ09iai50YWcpO1xuICAgIGlmICh0YWcpXG4gICAgICAgIHByb3BzLnB1c2goZG9jLmRpcmVjdGl2ZXMudGFnU3RyaW5nKHRhZykpO1xuICAgIHJldHVybiBwcm9wcy5qb2luKCcgJyk7XG59XG5mdW5jdGlvbiBzdHJpbmdpZnkoaXRlbSwgY3R4LCBvbkNvbW1lbnQsIG9uQ2hvbXBLZWVwKSB7XG4gICAgdmFyIF9hO1xuICAgIGlmIChpc1BhaXIoaXRlbSkpXG4gICAgICAgIHJldHVybiBpdGVtLnRvU3RyaW5nKGN0eCwgb25Db21tZW50LCBvbkNob21wS2VlcCk7XG4gICAgaWYgKGlzQWxpYXMoaXRlbSkpIHtcbiAgICAgICAgaWYgKGN0eC5kb2MuZGlyZWN0aXZlcylcbiAgICAgICAgICAgIHJldHVybiBpdGVtLnRvU3RyaW5nKGN0eCk7XG4gICAgICAgIGlmICgoX2EgPSBjdHgucmVzb2x2ZWRBbGlhc2VzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaGFzKGl0ZW0pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBDYW5ub3Qgc3RyaW5naWZ5IGNpcmN1bGFyIHN0cnVjdHVyZSB3aXRob3V0IGFsaWFzIG5vZGVzYCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoY3R4LnJlc29sdmVkQWxpYXNlcylcbiAgICAgICAgICAgICAgICBjdHgucmVzb2x2ZWRBbGlhc2VzLmFkZChpdGVtKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBjdHgucmVzb2x2ZWRBbGlhc2VzID0gbmV3IFNldChbaXRlbV0pO1xuICAgICAgICAgICAgaXRlbSA9IGl0ZW0ucmVzb2x2ZShjdHguZG9jKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgdGFnT2JqID0gdW5kZWZpbmVkO1xuICAgIGNvbnN0IG5vZGUgPSBpc05vZGUoaXRlbSlcbiAgICAgICAgPyBpdGVtXG4gICAgICAgIDogY3R4LmRvYy5jcmVhdGVOb2RlKGl0ZW0sIHsgb25UYWdPYmo6IG8gPT4gKHRhZ09iaiA9IG8pIH0pO1xuICAgIGlmICghdGFnT2JqKVxuICAgICAgICB0YWdPYmogPSBnZXRUYWdPYmplY3QoY3R4LmRvYy5zY2hlbWEudGFncywgbm9kZSk7XG4gICAgY29uc3QgcHJvcHMgPSBzdHJpbmdpZnlQcm9wcyhub2RlLCB0YWdPYmosIGN0eCk7XG4gICAgaWYgKHByb3BzLmxlbmd0aCA+IDApXG4gICAgICAgIGN0eC5pbmRlbnRBdFN0YXJ0ID0gKGN0eC5pbmRlbnRBdFN0YXJ0IHx8IDApICsgcHJvcHMubGVuZ3RoICsgMTtcbiAgICBjb25zdCBzdHIgPSB0eXBlb2YgdGFnT2JqLnN0cmluZ2lmeSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICA/IHRhZ09iai5zdHJpbmdpZnkobm9kZSwgY3R4LCBvbkNvbW1lbnQsIG9uQ2hvbXBLZWVwKVxuICAgICAgICA6IGlzU2NhbGFyKG5vZGUpXG4gICAgICAgICAgICA/IHN0cmluZ2lmeVN0cmluZyhub2RlLCBjdHgsIG9uQ29tbWVudCwgb25DaG9tcEtlZXApXG4gICAgICAgICAgICA6IG5vZGUudG9TdHJpbmcoY3R4LCBvbkNvbW1lbnQsIG9uQ2hvbXBLZWVwKTtcbiAgICBpZiAoIXByb3BzKVxuICAgICAgICByZXR1cm4gc3RyO1xuICAgIHJldHVybiBpc1NjYWxhcihub2RlKSB8fCBzdHJbMF0gPT09ICd7JyB8fCBzdHJbMF0gPT09ICdbJ1xuICAgICAgICA/IGAke3Byb3BzfSAke3N0cn1gXG4gICAgICAgIDogYCR7cHJvcHN9XFxuJHtjdHguaW5kZW50fSR7c3RyfWA7XG59XG5cbmV4cG9ydCB7IGNyZWF0ZVN0cmluZ2lmeUNvbnRleHQsIHN0cmluZ2lmeSB9O1xuIiwgImltcG9ydCB7IGlzQ29sbGVjdGlvbiwgaXNOb2RlLCBpc1NjYWxhciwgaXNTZXEgfSBmcm9tICcuLi9ub2Rlcy9Ob2RlLmpzJztcbmltcG9ydCB7IFNjYWxhciB9IGZyb20gJy4uL25vZGVzL1NjYWxhci5qcyc7XG5pbXBvcnQgeyBzdHJpbmdpZnkgfSBmcm9tICcuL3N0cmluZ2lmeS5qcyc7XG5pbXBvcnQgeyBsaW5lQ29tbWVudCwgaW5kZW50Q29tbWVudCB9IGZyb20gJy4vc3RyaW5naWZ5Q29tbWVudC5qcyc7XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeVBhaXIoeyBrZXksIHZhbHVlIH0sIGN0eCwgb25Db21tZW50LCBvbkNob21wS2VlcCkge1xuICAgIGNvbnN0IHsgYWxsTnVsbFZhbHVlcywgZG9jLCBpbmRlbnQsIGluZGVudFN0ZXAsIG9wdGlvbnM6IHsgY29tbWVudFN0cmluZywgaW5kZW50U2VxLCBzaW1wbGVLZXlzIH0gfSA9IGN0eDtcbiAgICBsZXQga2V5Q29tbWVudCA9IChpc05vZGUoa2V5KSAmJiBrZXkuY29tbWVudCkgfHwgbnVsbDtcbiAgICBpZiAoc2ltcGxlS2V5cykge1xuICAgICAgICBpZiAoa2V5Q29tbWVudCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXaXRoIHNpbXBsZSBrZXlzLCBrZXkgbm9kZXMgY2Fubm90IGhhdmUgY29tbWVudHMnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNDb2xsZWN0aW9uKGtleSkpIHtcbiAgICAgICAgICAgIGNvbnN0IG1zZyA9ICdXaXRoIHNpbXBsZSBrZXlzLCBjb2xsZWN0aW9uIGNhbm5vdCBiZSB1c2VkIGFzIGEga2V5IHZhbHVlJztcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxldCBleHBsaWNpdEtleSA9ICFzaW1wbGVLZXlzICYmXG4gICAgICAgICgha2V5IHx8XG4gICAgICAgICAgICAoa2V5Q29tbWVudCAmJiB2YWx1ZSA9PSBudWxsICYmICFjdHguaW5GbG93KSB8fFxuICAgICAgICAgICAgaXNDb2xsZWN0aW9uKGtleSkgfHxcbiAgICAgICAgICAgIChpc1NjYWxhcihrZXkpXG4gICAgICAgICAgICAgICAgPyBrZXkudHlwZSA9PT0gU2NhbGFyLkJMT0NLX0ZPTERFRCB8fCBrZXkudHlwZSA9PT0gU2NhbGFyLkJMT0NLX0xJVEVSQUxcbiAgICAgICAgICAgICAgICA6IHR5cGVvZiBrZXkgPT09ICdvYmplY3QnKSk7XG4gICAgY3R4ID0gT2JqZWN0LmFzc2lnbih7fSwgY3R4LCB7XG4gICAgICAgIGFsbE51bGxWYWx1ZXM6IGZhbHNlLFxuICAgICAgICBpbXBsaWNpdEtleTogIWV4cGxpY2l0S2V5ICYmIChzaW1wbGVLZXlzIHx8ICFhbGxOdWxsVmFsdWVzKSxcbiAgICAgICAgaW5kZW50OiBpbmRlbnQgKyBpbmRlbnRTdGVwXG4gICAgfSk7XG4gICAgbGV0IGtleUNvbW1lbnREb25lID0gZmFsc2U7XG4gICAgbGV0IGNob21wS2VlcCA9IGZhbHNlO1xuICAgIGxldCBzdHIgPSBzdHJpbmdpZnkoa2V5LCBjdHgsICgpID0+IChrZXlDb21tZW50RG9uZSA9IHRydWUpLCAoKSA9PiAoY2hvbXBLZWVwID0gdHJ1ZSkpO1xuICAgIGlmICghZXhwbGljaXRLZXkgJiYgIWN0eC5pbkZsb3cgJiYgc3RyLmxlbmd0aCA+IDEwMjQpIHtcbiAgICAgICAgaWYgKHNpbXBsZUtleXMpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dpdGggc2ltcGxlIGtleXMsIHNpbmdsZSBsaW5lIHNjYWxhciBtdXN0IG5vdCBzcGFuIG1vcmUgdGhhbiAxMDI0IGNoYXJhY3RlcnMnKTtcbiAgICAgICAgZXhwbGljaXRLZXkgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoY3R4LmluRmxvdykge1xuICAgICAgICBpZiAoYWxsTnVsbFZhbHVlcyB8fCB2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoa2V5Q29tbWVudERvbmUgJiYgb25Db21tZW50KVxuICAgICAgICAgICAgICAgIG9uQ29tbWVudCgpO1xuICAgICAgICAgICAgcmV0dXJuIGV4cGxpY2l0S2V5ID8gYD8gJHtzdHJ9YCA6IHN0cjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICgoYWxsTnVsbFZhbHVlcyAmJiAhc2ltcGxlS2V5cykgfHwgKHZhbHVlID09IG51bGwgJiYgZXhwbGljaXRLZXkpKSB7XG4gICAgICAgIHN0ciA9IGA/ICR7c3RyfWA7XG4gICAgICAgIGlmIChrZXlDb21tZW50ICYmICFrZXlDb21tZW50RG9uZSkge1xuICAgICAgICAgICAgc3RyICs9IGxpbmVDb21tZW50KHN0ciwgY3R4LmluZGVudCwgY29tbWVudFN0cmluZyhrZXlDb21tZW50KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2hvbXBLZWVwICYmIG9uQ2hvbXBLZWVwKVxuICAgICAgICAgICAgb25DaG9tcEtlZXAoKTtcbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gICAgaWYgKGtleUNvbW1lbnREb25lKVxuICAgICAgICBrZXlDb21tZW50ID0gbnVsbDtcbiAgICBpZiAoZXhwbGljaXRLZXkpIHtcbiAgICAgICAgaWYgKGtleUNvbW1lbnQpXG4gICAgICAgICAgICBzdHIgKz0gbGluZUNvbW1lbnQoc3RyLCBjdHguaW5kZW50LCBjb21tZW50U3RyaW5nKGtleUNvbW1lbnQpKTtcbiAgICAgICAgc3RyID0gYD8gJHtzdHJ9XFxuJHtpbmRlbnR9OmA7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBzdHIgPSBgJHtzdHJ9OmA7XG4gICAgICAgIGlmIChrZXlDb21tZW50KVxuICAgICAgICAgICAgc3RyICs9IGxpbmVDb21tZW50KHN0ciwgY3R4LmluZGVudCwgY29tbWVudFN0cmluZyhrZXlDb21tZW50KSk7XG4gICAgfVxuICAgIGxldCB2Y2IgPSAnJztcbiAgICBsZXQgdmFsdWVDb21tZW50ID0gbnVsbDtcbiAgICBpZiAoaXNOb2RlKHZhbHVlKSkge1xuICAgICAgICBpZiAodmFsdWUuc3BhY2VCZWZvcmUpXG4gICAgICAgICAgICB2Y2IgPSAnXFxuJztcbiAgICAgICAgaWYgKHZhbHVlLmNvbW1lbnRCZWZvcmUpIHtcbiAgICAgICAgICAgIGNvbnN0IGNzID0gY29tbWVudFN0cmluZyh2YWx1ZS5jb21tZW50QmVmb3JlKTtcbiAgICAgICAgICAgIHZjYiArPSBgXFxuJHtpbmRlbnRDb21tZW50KGNzLCBjdHguaW5kZW50KX1gO1xuICAgICAgICB9XG4gICAgICAgIHZhbHVlQ29tbWVudCA9IHZhbHVlLmNvbW1lbnQ7XG4gICAgfVxuICAgIGVsc2UgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgdmFsdWUgPSBkb2MuY3JlYXRlTm9kZSh2YWx1ZSk7XG4gICAgfVxuICAgIGN0eC5pbXBsaWNpdEtleSA9IGZhbHNlO1xuICAgIGlmICghZXhwbGljaXRLZXkgJiYgIWtleUNvbW1lbnQgJiYgaXNTY2FsYXIodmFsdWUpKVxuICAgICAgICBjdHguaW5kZW50QXRTdGFydCA9IHN0ci5sZW5ndGggKyAxO1xuICAgIGNob21wS2VlcCA9IGZhbHNlO1xuICAgIGlmICghaW5kZW50U2VxICYmXG4gICAgICAgIGluZGVudFN0ZXAubGVuZ3RoID49IDIgJiZcbiAgICAgICAgIWN0eC5pbkZsb3cgJiZcbiAgICAgICAgIWV4cGxpY2l0S2V5ICYmXG4gICAgICAgIGlzU2VxKHZhbHVlKSAmJlxuICAgICAgICAhdmFsdWUuZmxvdyAmJlxuICAgICAgICAhdmFsdWUudGFnICYmXG4gICAgICAgICF2YWx1ZS5hbmNob3IpIHtcbiAgICAgICAgLy8gSWYgaW5kZW50U2VxID09PSBmYWxzZSwgY29uc2lkZXIgJy0gJyBhcyBwYXJ0IG9mIGluZGVudGF0aW9uIHdoZXJlIHBvc3NpYmxlXG4gICAgICAgIGN0eC5pbmRlbnQgPSBjdHguaW5kZW50LnN1YnN0cigyKTtcbiAgICB9XG4gICAgbGV0IHZhbHVlQ29tbWVudERvbmUgPSBmYWxzZTtcbiAgICBjb25zdCB2YWx1ZVN0ciA9IHN0cmluZ2lmeSh2YWx1ZSwgY3R4LCAoKSA9PiAodmFsdWVDb21tZW50RG9uZSA9IHRydWUpLCAoKSA9PiAoY2hvbXBLZWVwID0gdHJ1ZSkpO1xuICAgIGxldCB3cyA9ICcgJztcbiAgICBpZiAodmNiIHx8IGtleUNvbW1lbnQpIHtcbiAgICAgICAgd3MgPSB2YWx1ZVN0ciA9PT0gJycgJiYgIWN0eC5pbkZsb3cgPyB2Y2IgOiBgJHt2Y2J9XFxuJHtjdHguaW5kZW50fWA7XG4gICAgfVxuICAgIGVsc2UgaWYgKCFleHBsaWNpdEtleSAmJiBpc0NvbGxlY3Rpb24odmFsdWUpKSB7XG4gICAgICAgIGNvbnN0IGZsb3cgPSB2YWx1ZVN0clswXSA9PT0gJ1snIHx8IHZhbHVlU3RyWzBdID09PSAneyc7XG4gICAgICAgIGlmICghZmxvdyB8fCB2YWx1ZVN0ci5pbmNsdWRlcygnXFxuJykpXG4gICAgICAgICAgICB3cyA9IGBcXG4ke2N0eC5pbmRlbnR9YDtcbiAgICB9XG4gICAgZWxzZSBpZiAodmFsdWVTdHIgPT09ICcnIHx8IHZhbHVlU3RyWzBdID09PSAnXFxuJylcbiAgICAgICAgd3MgPSAnJztcbiAgICBzdHIgKz0gd3MgKyB2YWx1ZVN0cjtcbiAgICBpZiAoY3R4LmluRmxvdykge1xuICAgICAgICBpZiAodmFsdWVDb21tZW50RG9uZSAmJiBvbkNvbW1lbnQpXG4gICAgICAgICAgICBvbkNvbW1lbnQoKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodmFsdWVDb21tZW50ICYmICF2YWx1ZUNvbW1lbnREb25lKSB7XG4gICAgICAgIHN0ciArPSBsaW5lQ29tbWVudChzdHIsIGN0eC5pbmRlbnQsIGNvbW1lbnRTdHJpbmcodmFsdWVDb21tZW50KSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGNob21wS2VlcCAmJiBvbkNob21wS2VlcCkge1xuICAgICAgICBvbkNob21wS2VlcCgpO1xuICAgIH1cbiAgICByZXR1cm4gc3RyO1xufVxuXG5leHBvcnQgeyBzdHJpbmdpZnlQYWlyIH07XG4iLCAiZnVuY3Rpb24gZGVidWcobG9nTGV2ZWwsIC4uLm1lc3NhZ2VzKSB7XG4gICAgaWYgKGxvZ0xldmVsID09PSAnZGVidWcnKVxuICAgICAgICBjb25zb2xlLmxvZyguLi5tZXNzYWdlcyk7XG59XG5mdW5jdGlvbiB3YXJuKGxvZ0xldmVsLCB3YXJuaW5nKSB7XG4gICAgaWYgKGxvZ0xldmVsID09PSAnZGVidWcnIHx8IGxvZ0xldmVsID09PSAnd2FybicpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiBwcm9jZXNzLmVtaXRXYXJuaW5nKVxuICAgICAgICAgICAgcHJvY2Vzcy5lbWl0V2FybmluZyh3YXJuaW5nKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgY29uc29sZS53YXJuKHdhcm5pbmcpO1xuICAgIH1cbn1cblxuZXhwb3J0IHsgZGVidWcsIHdhcm4gfTtcbiIsICJpbXBvcnQgeyB3YXJuIH0gZnJvbSAnLi4vbG9nLmpzJztcbmltcG9ydCB7IGNyZWF0ZVN0cmluZ2lmeUNvbnRleHQgfSBmcm9tICcuLi9zdHJpbmdpZnkvc3RyaW5naWZ5LmpzJztcbmltcG9ydCB7IGlzQWxpYXMsIGlzU2VxLCBpc1NjYWxhciwgaXNNYXAsIGlzTm9kZSB9IGZyb20gJy4vTm9kZS5qcyc7XG5pbXBvcnQgeyBTY2FsYXIgfSBmcm9tICcuL1NjYWxhci5qcyc7XG5pbXBvcnQgeyB0b0pTIH0gZnJvbSAnLi90b0pTLmpzJztcblxuY29uc3QgTUVSR0VfS0VZID0gJzw8JztcbmZ1bmN0aW9uIGFkZFBhaXJUb0pTTWFwKGN0eCwgbWFwLCB7IGtleSwgdmFsdWUgfSkge1xuICAgIGlmIChjdHggJiYgY3R4LmRvYy5zY2hlbWEubWVyZ2UgJiYgaXNNZXJnZUtleShrZXkpKSB7XG4gICAgICAgIHZhbHVlID0gaXNBbGlhcyh2YWx1ZSkgPyB2YWx1ZS5yZXNvbHZlKGN0eC5kb2MpIDogdmFsdWU7XG4gICAgICAgIGlmIChpc1NlcSh2YWx1ZSkpXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGl0IG9mIHZhbHVlLml0ZW1zKVxuICAgICAgICAgICAgICAgIG1lcmdlVG9KU01hcChjdHgsIG1hcCwgaXQpO1xuICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSlcbiAgICAgICAgICAgIGZvciAoY29uc3QgaXQgb2YgdmFsdWUpXG4gICAgICAgICAgICAgICAgbWVyZ2VUb0pTTWFwKGN0eCwgbWFwLCBpdCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIG1lcmdlVG9KU01hcChjdHgsIG1hcCwgdmFsdWUpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QganNLZXkgPSB0b0pTKGtleSwgJycsIGN0eCk7XG4gICAgICAgIGlmIChtYXAgaW5zdGFuY2VvZiBNYXApIHtcbiAgICAgICAgICAgIG1hcC5zZXQoanNLZXksIHRvSlModmFsdWUsIGpzS2V5LCBjdHgpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtYXAgaW5zdGFuY2VvZiBTZXQpIHtcbiAgICAgICAgICAgIG1hcC5hZGQoanNLZXkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3Qgc3RyaW5nS2V5ID0gc3RyaW5naWZ5S2V5KGtleSwganNLZXksIGN0eCk7XG4gICAgICAgICAgICBjb25zdCBqc1ZhbHVlID0gdG9KUyh2YWx1ZSwgc3RyaW5nS2V5LCBjdHgpO1xuICAgICAgICAgICAgaWYgKHN0cmluZ0tleSBpbiBtYXApXG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG1hcCwgc3RyaW5nS2V5LCB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBqc1ZhbHVlLFxuICAgICAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgbWFwW3N0cmluZ0tleV0gPSBqc1ZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtYXA7XG59XG5jb25zdCBpc01lcmdlS2V5ID0gKGtleSkgPT4ga2V5ID09PSBNRVJHRV9LRVkgfHxcbiAgICAoaXNTY2FsYXIoa2V5KSAmJlxuICAgICAgICBrZXkudmFsdWUgPT09IE1FUkdFX0tFWSAmJlxuICAgICAgICAoIWtleS50eXBlIHx8IGtleS50eXBlID09PSBTY2FsYXIuUExBSU4pKTtcbi8vIElmIHRoZSB2YWx1ZSBhc3NvY2lhdGVkIHdpdGggYSBtZXJnZSBrZXkgaXMgYSBzaW5nbGUgbWFwcGluZyBub2RlLCBlYWNoIG9mXG4vLyBpdHMga2V5L3ZhbHVlIHBhaXJzIGlzIGluc2VydGVkIGludG8gdGhlIGN1cnJlbnQgbWFwcGluZywgdW5sZXNzIHRoZSBrZXlcbi8vIGFscmVhZHkgZXhpc3RzIGluIGl0LiBJZiB0aGUgdmFsdWUgYXNzb2NpYXRlZCB3aXRoIHRoZSBtZXJnZSBrZXkgaXMgYVxuLy8gc2VxdWVuY2UsIHRoZW4gdGhpcyBzZXF1ZW5jZSBpcyBleHBlY3RlZCB0byBjb250YWluIG1hcHBpbmcgbm9kZXMgYW5kIGVhY2hcbi8vIG9mIHRoZXNlIG5vZGVzIGlzIG1lcmdlZCBpbiB0dXJuIGFjY29yZGluZyB0byBpdHMgb3JkZXIgaW4gdGhlIHNlcXVlbmNlLlxuLy8gS2V5cyBpbiBtYXBwaW5nIG5vZGVzIGVhcmxpZXIgaW4gdGhlIHNlcXVlbmNlIG92ZXJyaWRlIGtleXMgc3BlY2lmaWVkIGluXG4vLyBsYXRlciBtYXBwaW5nIG5vZGVzLiAtLSBodHRwOi8veWFtbC5vcmcvdHlwZS9tZXJnZS5odG1sXG5mdW5jdGlvbiBtZXJnZVRvSlNNYXAoY3R4LCBtYXAsIHZhbHVlKSB7XG4gICAgY29uc3Qgc291cmNlID0gY3R4ICYmIGlzQWxpYXModmFsdWUpID8gdmFsdWUucmVzb2x2ZShjdHguZG9jKSA6IHZhbHVlO1xuICAgIGlmICghaXNNYXAoc291cmNlKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNZXJnZSBzb3VyY2VzIG11c3QgYmUgbWFwcyBvciBtYXAgYWxpYXNlcycpO1xuICAgIGNvbnN0IHNyY01hcCA9IHNvdXJjZS50b0pTT04obnVsbCwgY3R4LCBNYXApO1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIHNyY01hcCkge1xuICAgICAgICBpZiAobWFwIGluc3RhbmNlb2YgTWFwKSB7XG4gICAgICAgICAgICBpZiAoIW1hcC5oYXMoa2V5KSlcbiAgICAgICAgICAgICAgICBtYXAuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG1hcCBpbnN0YW5jZW9mIFNldCkge1xuICAgICAgICAgICAgbWFwLmFkZChrZXkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobWFwLCBrZXkpKSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobWFwLCBrZXksIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1hcDtcbn1cbmZ1bmN0aW9uIHN0cmluZ2lmeUtleShrZXksIGpzS2V5LCBjdHgpIHtcbiAgICBpZiAoanNLZXkgPT09IG51bGwpXG4gICAgICAgIHJldHVybiAnJztcbiAgICBpZiAodHlwZW9mIGpzS2V5ICE9PSAnb2JqZWN0JylcbiAgICAgICAgcmV0dXJuIFN0cmluZyhqc0tleSk7XG4gICAgaWYgKGlzTm9kZShrZXkpICYmIGN0eCAmJiBjdHguZG9jKSB7XG4gICAgICAgIGNvbnN0IHN0ckN0eCA9IGNyZWF0ZVN0cmluZ2lmeUNvbnRleHQoY3R4LmRvYywge30pO1xuICAgICAgICBzdHJDdHguYW5jaG9ycyA9IG5ldyBTZXQoKTtcbiAgICAgICAgZm9yIChjb25zdCBub2RlIG9mIGN0eC5hbmNob3JzLmtleXMoKSlcbiAgICAgICAgICAgIHN0ckN0eC5hbmNob3JzLmFkZChub2RlLmFuY2hvcik7XG4gICAgICAgIHN0ckN0eC5pbkZsb3cgPSB0cnVlO1xuICAgICAgICBzdHJDdHguaW5TdHJpbmdpZnlLZXkgPSB0cnVlO1xuICAgICAgICBjb25zdCBzdHJLZXkgPSBrZXkudG9TdHJpbmcoc3RyQ3R4KTtcbiAgICAgICAgaWYgKCFjdHgubWFwS2V5V2FybmVkKSB7XG4gICAgICAgICAgICBsZXQganNvblN0ciA9IEpTT04uc3RyaW5naWZ5KHN0cktleSk7XG4gICAgICAgICAgICBpZiAoanNvblN0ci5sZW5ndGggPiA0MClcbiAgICAgICAgICAgICAgICBqc29uU3RyID0ganNvblN0ci5zdWJzdHJpbmcoMCwgMzYpICsgJy4uLlwiJztcbiAgICAgICAgICAgIHdhcm4oY3R4LmRvYy5vcHRpb25zLmxvZ0xldmVsLCBgS2V5cyB3aXRoIGNvbGxlY3Rpb24gdmFsdWVzIHdpbGwgYmUgc3RyaW5naWZpZWQgZHVlIHRvIEpTIE9iamVjdCByZXN0cmljdGlvbnM6ICR7anNvblN0cn0uIFNldCBtYXBBc01hcDogdHJ1ZSB0byB1c2Ugb2JqZWN0IGtleXMuYCk7XG4gICAgICAgICAgICBjdHgubWFwS2V5V2FybmVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyS2V5O1xuICAgIH1cbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoanNLZXkpO1xufVxuXG5leHBvcnQgeyBhZGRQYWlyVG9KU01hcCB9O1xuIiwgImltcG9ydCB7IGNyZWF0ZU5vZGUgfSBmcm9tICcuLi9kb2MvY3JlYXRlTm9kZS5qcyc7XG5pbXBvcnQgeyBzdHJpbmdpZnlQYWlyIH0gZnJvbSAnLi4vc3RyaW5naWZ5L3N0cmluZ2lmeVBhaXIuanMnO1xuaW1wb3J0IHsgYWRkUGFpclRvSlNNYXAgfSBmcm9tICcuL2FkZFBhaXJUb0pTTWFwLmpzJztcbmltcG9ydCB7IE5PREVfVFlQRSwgUEFJUiwgaXNOb2RlIH0gZnJvbSAnLi9Ob2RlLmpzJztcblxuZnVuY3Rpb24gY3JlYXRlUGFpcihrZXksIHZhbHVlLCBjdHgpIHtcbiAgICBjb25zdCBrID0gY3JlYXRlTm9kZShrZXksIHVuZGVmaW5lZCwgY3R4KTtcbiAgICBjb25zdCB2ID0gY3JlYXRlTm9kZSh2YWx1ZSwgdW5kZWZpbmVkLCBjdHgpO1xuICAgIHJldHVybiBuZXcgUGFpcihrLCB2KTtcbn1cbmNsYXNzIFBhaXIge1xuICAgIGNvbnN0cnVjdG9yKGtleSwgdmFsdWUgPSBudWxsKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBOT0RFX1RZUEUsIHsgdmFsdWU6IFBBSVIgfSk7XG4gICAgICAgIHRoaXMua2V5ID0ga2V5O1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIGNsb25lKHNjaGVtYSkge1xuICAgICAgICBsZXQgeyBrZXksIHZhbHVlIH0gPSB0aGlzO1xuICAgICAgICBpZiAoaXNOb2RlKGtleSkpXG4gICAgICAgICAgICBrZXkgPSBrZXkuY2xvbmUoc2NoZW1hKTtcbiAgICAgICAgaWYgKGlzTm9kZSh2YWx1ZSkpXG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLmNsb25lKHNjaGVtYSk7XG4gICAgICAgIHJldHVybiBuZXcgUGFpcihrZXksIHZhbHVlKTtcbiAgICB9XG4gICAgdG9KU09OKF8sIGN0eCkge1xuICAgICAgICBjb25zdCBwYWlyID0gY3R4ICYmIGN0eC5tYXBBc01hcCA/IG5ldyBNYXAoKSA6IHt9O1xuICAgICAgICByZXR1cm4gYWRkUGFpclRvSlNNYXAoY3R4LCBwYWlyLCB0aGlzKTtcbiAgICB9XG4gICAgdG9TdHJpbmcoY3R4LCBvbkNvbW1lbnQsIG9uQ2hvbXBLZWVwKSB7XG4gICAgICAgIHJldHVybiBjdHggJiYgY3R4LmRvY1xuICAgICAgICAgICAgPyBzdHJpbmdpZnlQYWlyKHRoaXMsIGN0eCwgb25Db21tZW50LCBvbkNob21wS2VlcClcbiAgICAgICAgICAgIDogSlNPTi5zdHJpbmdpZnkodGhpcyk7XG4gICAgfVxufVxuXG5leHBvcnQgeyBQYWlyLCBjcmVhdGVQYWlyIH07XG4iLCAiLyoqXG4gKiBgeWFtbGAgZGVmaW5lcyBkb2N1bWVudC1zcGVjaWZpYyBvcHRpb25zIGluIHRocmVlIHBsYWNlczogYXMgYW4gYXJndW1lbnQgb2ZcbiAqIHBhcnNlLCBjcmVhdGUgYW5kIHN0cmluZ2lmeSBjYWxscywgaW4gdGhlIHZhbHVlcyBvZiBgWUFNTC5kZWZhdWx0T3B0aW9uc2AsXG4gKiBhbmQgaW4gdGhlIHZlcnNpb24tZGVwZW5kZW50IGBZQU1MLkRvY3VtZW50LmRlZmF1bHRzYCBvYmplY3QuIFZhbHVlcyBzZXQgaW5cbiAqIGBZQU1MLmRlZmF1bHRPcHRpb25zYCBvdmVycmlkZSB2ZXJzaW9uLWRlcGVuZGVudCBkZWZhdWx0cywgYW5kIGFyZ3VtZW50XG4gKiBvcHRpb25zIG92ZXJyaWRlIGJvdGguXG4gKi9cbmNvbnN0IGRlZmF1bHRPcHRpb25zID0ge1xuICAgIGludEFzQmlnSW50OiBmYWxzZSxcbiAgICBrZWVwU291cmNlVG9rZW5zOiBmYWxzZSxcbiAgICBsb2dMZXZlbDogJ3dhcm4nLFxuICAgIHByZXR0eUVycm9yczogdHJ1ZSxcbiAgICBzdHJpY3Q6IHRydWUsXG4gICAgdW5pcXVlS2V5czogdHJ1ZSxcbiAgICB2ZXJzaW9uOiAnMS4yJ1xufTtcblxuZXhwb3J0IHsgZGVmYXVsdE9wdGlvbnMgfTtcbiIsICJpbXBvcnQgeyBDb2xsZWN0aW9uIH0gZnJvbSAnLi4vbm9kZXMvQ29sbGVjdGlvbi5qcyc7XG5pbXBvcnQgeyBpc05vZGUsIGlzUGFpciB9IGZyb20gJy4uL25vZGVzL05vZGUuanMnO1xuaW1wb3J0IHsgc3RyaW5naWZ5IH0gZnJvbSAnLi9zdHJpbmdpZnkuanMnO1xuaW1wb3J0IHsgbGluZUNvbW1lbnQsIGluZGVudENvbW1lbnQgfSBmcm9tICcuL3N0cmluZ2lmeUNvbW1lbnQuanMnO1xuXG5mdW5jdGlvbiBzdHJpbmdpZnlDb2xsZWN0aW9uKGNvbGxlY3Rpb24sIGN0eCwgb3B0aW9ucykge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBmbG93ID0gKF9hID0gY3R4LmluRmxvdykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogY29sbGVjdGlvbi5mbG93O1xuICAgIGNvbnN0IHN0cmluZ2lmeSA9IGZsb3cgPyBzdHJpbmdpZnlGbG93Q29sbGVjdGlvbiA6IHN0cmluZ2lmeUJsb2NrQ29sbGVjdGlvbjtcbiAgICByZXR1cm4gc3RyaW5naWZ5KGNvbGxlY3Rpb24sIGN0eCwgb3B0aW9ucyk7XG59XG5mdW5jdGlvbiBzdHJpbmdpZnlCbG9ja0NvbGxlY3Rpb24oeyBjb21tZW50LCBpdGVtcyB9LCBjdHgsIHsgYmxvY2tJdGVtUHJlZml4LCBmbG93Q2hhcnMsIGl0ZW1JbmRlbnQsIG9uQ2hvbXBLZWVwLCBvbkNvbW1lbnQgfSkge1xuICAgIGNvbnN0IHsgaW5kZW50LCBvcHRpb25zOiB7IGNvbW1lbnRTdHJpbmcgfSB9ID0gY3R4O1xuICAgIGNvbnN0IGl0ZW1DdHggPSBPYmplY3QuYXNzaWduKHt9LCBjdHgsIHsgaW5kZW50OiBpdGVtSW5kZW50LCB0eXBlOiBudWxsIH0pO1xuICAgIGxldCBjaG9tcEtlZXAgPSBmYWxzZTsgLy8gZmxhZyBmb3IgdGhlIHByZWNlZGluZyBub2RlJ3Mgc3RhdHVzXG4gICAgY29uc3QgbGluZXMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IGl0ZW0gPSBpdGVtc1tpXTtcbiAgICAgICAgbGV0IGNvbW1lbnQgPSBudWxsO1xuICAgICAgICBpZiAoaXNOb2RlKGl0ZW0pKSB7XG4gICAgICAgICAgICBpZiAoIWNob21wS2VlcCAmJiBpdGVtLnNwYWNlQmVmb3JlKVxuICAgICAgICAgICAgICAgIGxpbmVzLnB1c2goJycpO1xuICAgICAgICAgICAgYWRkQ29tbWVudEJlZm9yZShjdHgsIGxpbmVzLCBpdGVtLmNvbW1lbnRCZWZvcmUsIGNob21wS2VlcCk7XG4gICAgICAgICAgICBpZiAoaXRlbS5jb21tZW50KVxuICAgICAgICAgICAgICAgIGNvbW1lbnQgPSBpdGVtLmNvbW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNQYWlyKGl0ZW0pKSB7XG4gICAgICAgICAgICBjb25zdCBpayA9IGlzTm9kZShpdGVtLmtleSkgPyBpdGVtLmtleSA6IG51bGw7XG4gICAgICAgICAgICBpZiAoaWspIHtcbiAgICAgICAgICAgICAgICBpZiAoIWNob21wS2VlcCAmJiBpay5zcGFjZUJlZm9yZSlcbiAgICAgICAgICAgICAgICAgICAgbGluZXMucHVzaCgnJyk7XG4gICAgICAgICAgICAgICAgYWRkQ29tbWVudEJlZm9yZShjdHgsIGxpbmVzLCBpay5jb21tZW50QmVmb3JlLCBjaG9tcEtlZXApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNob21wS2VlcCA9IGZhbHNlO1xuICAgICAgICBsZXQgc3RyID0gc3RyaW5naWZ5KGl0ZW0sIGl0ZW1DdHgsICgpID0+IChjb21tZW50ID0gbnVsbCksICgpID0+IChjaG9tcEtlZXAgPSB0cnVlKSk7XG4gICAgICAgIGlmIChjb21tZW50KVxuICAgICAgICAgICAgc3RyICs9IGxpbmVDb21tZW50KHN0ciwgaXRlbUluZGVudCwgY29tbWVudFN0cmluZyhjb21tZW50KSk7XG4gICAgICAgIGlmIChjaG9tcEtlZXAgJiYgY29tbWVudClcbiAgICAgICAgICAgIGNob21wS2VlcCA9IGZhbHNlO1xuICAgICAgICBsaW5lcy5wdXNoKGJsb2NrSXRlbVByZWZpeCArIHN0cik7XG4gICAgfVxuICAgIGxldCBzdHI7XG4gICAgaWYgKGxpbmVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBzdHIgPSBmbG93Q2hhcnMuc3RhcnQgKyBmbG93Q2hhcnMuZW5kO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgc3RyID0gbGluZXNbMF07XG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgbGluZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IGxpbmUgPSBsaW5lc1tpXTtcbiAgICAgICAgICAgIHN0ciArPSBsaW5lID8gYFxcbiR7aW5kZW50fSR7bGluZX1gIDogJ1xcbic7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNvbW1lbnQpIHtcbiAgICAgICAgc3RyICs9ICdcXG4nICsgaW5kZW50Q29tbWVudChjb21tZW50U3RyaW5nKGNvbW1lbnQpLCBpbmRlbnQpO1xuICAgICAgICBpZiAob25Db21tZW50KVxuICAgICAgICAgICAgb25Db21tZW50KCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGNob21wS2VlcCAmJiBvbkNob21wS2VlcClcbiAgICAgICAgb25DaG9tcEtlZXAoKTtcbiAgICByZXR1cm4gc3RyO1xufVxuZnVuY3Rpb24gc3RyaW5naWZ5Rmxvd0NvbGxlY3Rpb24oeyBjb21tZW50LCBpdGVtcyB9LCBjdHgsIHsgZmxvd0NoYXJzLCBpdGVtSW5kZW50LCBvbkNvbW1lbnQgfSkge1xuICAgIGNvbnN0IHsgaW5kZW50LCBpbmRlbnRTdGVwLCBvcHRpb25zOiB7IGNvbW1lbnRTdHJpbmcgfSB9ID0gY3R4O1xuICAgIGl0ZW1JbmRlbnQgKz0gaW5kZW50U3RlcDtcbiAgICBjb25zdCBpdGVtQ3R4ID0gT2JqZWN0LmFzc2lnbih7fSwgY3R4LCB7XG4gICAgICAgIGluZGVudDogaXRlbUluZGVudCxcbiAgICAgICAgaW5GbG93OiB0cnVlLFxuICAgICAgICB0eXBlOiBudWxsXG4gICAgfSk7XG4gICAgbGV0IHJlcU5ld2xpbmUgPSBmYWxzZTtcbiAgICBsZXQgbGluZXNBdFZhbHVlID0gMDtcbiAgICBjb25zdCBsaW5lcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29uc3QgaXRlbSA9IGl0ZW1zW2ldO1xuICAgICAgICBsZXQgY29tbWVudCA9IG51bGw7XG4gICAgICAgIGlmIChpc05vZGUoaXRlbSkpIHtcbiAgICAgICAgICAgIGlmIChpdGVtLnNwYWNlQmVmb3JlKVxuICAgICAgICAgICAgICAgIGxpbmVzLnB1c2goJycpO1xuICAgICAgICAgICAgYWRkQ29tbWVudEJlZm9yZShjdHgsIGxpbmVzLCBpdGVtLmNvbW1lbnRCZWZvcmUsIGZhbHNlKTtcbiAgICAgICAgICAgIGlmIChpdGVtLmNvbW1lbnQpXG4gICAgICAgICAgICAgICAgY29tbWVudCA9IGl0ZW0uY29tbWVudDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc1BhaXIoaXRlbSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGlrID0gaXNOb2RlKGl0ZW0ua2V5KSA/IGl0ZW0ua2V5IDogbnVsbDtcbiAgICAgICAgICAgIGlmIChpaykge1xuICAgICAgICAgICAgICAgIGlmIChpay5zcGFjZUJlZm9yZSlcbiAgICAgICAgICAgICAgICAgICAgbGluZXMucHVzaCgnJyk7XG4gICAgICAgICAgICAgICAgYWRkQ29tbWVudEJlZm9yZShjdHgsIGxpbmVzLCBpay5jb21tZW50QmVmb3JlLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgaWYgKGlrLmNvbW1lbnQpXG4gICAgICAgICAgICAgICAgICAgIHJlcU5ld2xpbmUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaXYgPSBpc05vZGUoaXRlbS52YWx1ZSkgPyBpdGVtLnZhbHVlIDogbnVsbDtcbiAgICAgICAgICAgIGlmIChpdikge1xuICAgICAgICAgICAgICAgIGlmIChpdi5jb21tZW50KVxuICAgICAgICAgICAgICAgICAgICBjb21tZW50ID0gaXYuY29tbWVudDtcbiAgICAgICAgICAgICAgICBpZiAoaXYuY29tbWVudEJlZm9yZSlcbiAgICAgICAgICAgICAgICAgICAgcmVxTmV3bGluZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpdGVtLnZhbHVlID09IG51bGwgJiYgaWsgJiYgaWsuY29tbWVudCkge1xuICAgICAgICAgICAgICAgIGNvbW1lbnQgPSBpay5jb21tZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjb21tZW50KVxuICAgICAgICAgICAgcmVxTmV3bGluZSA9IHRydWU7XG4gICAgICAgIGxldCBzdHIgPSBzdHJpbmdpZnkoaXRlbSwgaXRlbUN0eCwgKCkgPT4gKGNvbW1lbnQgPSBudWxsKSk7XG4gICAgICAgIGlmIChpIDwgaXRlbXMubGVuZ3RoIC0gMSlcbiAgICAgICAgICAgIHN0ciArPSAnLCc7XG4gICAgICAgIGlmIChjb21tZW50KVxuICAgICAgICAgICAgc3RyICs9IGxpbmVDb21tZW50KHN0ciwgaXRlbUluZGVudCwgY29tbWVudFN0cmluZyhjb21tZW50KSk7XG4gICAgICAgIGlmICghcmVxTmV3bGluZSAmJiAobGluZXMubGVuZ3RoID4gbGluZXNBdFZhbHVlIHx8IHN0ci5pbmNsdWRlcygnXFxuJykpKVxuICAgICAgICAgICAgcmVxTmV3bGluZSA9IHRydWU7XG4gICAgICAgIGxpbmVzLnB1c2goc3RyKTtcbiAgICAgICAgbGluZXNBdFZhbHVlID0gbGluZXMubGVuZ3RoO1xuICAgIH1cbiAgICBsZXQgc3RyO1xuICAgIGNvbnN0IHsgc3RhcnQsIGVuZCB9ID0gZmxvd0NoYXJzO1xuICAgIGlmIChsaW5lcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgc3RyID0gc3RhcnQgKyBlbmQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAoIXJlcU5ld2xpbmUpIHtcbiAgICAgICAgICAgIGNvbnN0IGxlbiA9IGxpbmVzLnJlZHVjZSgoc3VtLCBsaW5lKSA9PiBzdW0gKyBsaW5lLmxlbmd0aCArIDIsIDIpO1xuICAgICAgICAgICAgcmVxTmV3bGluZSA9IGxlbiA+IENvbGxlY3Rpb24ubWF4Rmxvd1N0cmluZ1NpbmdsZUxpbmVMZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlcU5ld2xpbmUpIHtcbiAgICAgICAgICAgIHN0ciA9IHN0YXJ0O1xuICAgICAgICAgICAgZm9yIChjb25zdCBsaW5lIG9mIGxpbmVzKVxuICAgICAgICAgICAgICAgIHN0ciArPSBsaW5lID8gYFxcbiR7aW5kZW50U3RlcH0ke2luZGVudH0ke2xpbmV9YCA6ICdcXG4nO1xuICAgICAgICAgICAgc3RyICs9IGBcXG4ke2luZGVudH0ke2VuZH1gO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RyID0gYCR7c3RhcnR9ICR7bGluZXMuam9pbignICcpfSAke2VuZH1gO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChjb21tZW50KSB7XG4gICAgICAgIHN0ciArPSBsaW5lQ29tbWVudChzdHIsIGNvbW1lbnRTdHJpbmcoY29tbWVudCksIGluZGVudCk7XG4gICAgICAgIGlmIChvbkNvbW1lbnQpXG4gICAgICAgICAgICBvbkNvbW1lbnQoKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0cjtcbn1cbmZ1bmN0aW9uIGFkZENvbW1lbnRCZWZvcmUoeyBpbmRlbnQsIG9wdGlvbnM6IHsgY29tbWVudFN0cmluZyB9IH0sIGxpbmVzLCBjb21tZW50LCBjaG9tcEtlZXApIHtcbiAgICBpZiAoY29tbWVudCAmJiBjaG9tcEtlZXApXG4gICAgICAgIGNvbW1lbnQgPSBjb21tZW50LnJlcGxhY2UoL15cXG4rLywgJycpO1xuICAgIGlmIChjb21tZW50KSB7XG4gICAgICAgIGNvbnN0IGljID0gaW5kZW50Q29tbWVudChjb21tZW50U3RyaW5nKGNvbW1lbnQpLCBpbmRlbnQpO1xuICAgICAgICBsaW5lcy5wdXNoKGljLnRyaW1TdGFydCgpKTsgLy8gQXZvaWQgZG91YmxlIGluZGVudCBvbiBmaXJzdCBsaW5lXG4gICAgfVxufVxuXG5leHBvcnQgeyBzdHJpbmdpZnlDb2xsZWN0aW9uIH07XG4iLCAiaW1wb3J0IHsgc3RyaW5naWZ5Q29sbGVjdGlvbiB9IGZyb20gJy4uL3N0cmluZ2lmeS9zdHJpbmdpZnlDb2xsZWN0aW9uLmpzJztcbmltcG9ydCB7IGFkZFBhaXJUb0pTTWFwIH0gZnJvbSAnLi9hZGRQYWlyVG9KU01hcC5qcyc7XG5pbXBvcnQgeyBDb2xsZWN0aW9uIH0gZnJvbSAnLi9Db2xsZWN0aW9uLmpzJztcbmltcG9ydCB7IGlzUGFpciwgaXNTY2FsYXIsIE1BUCB9IGZyb20gJy4vTm9kZS5qcyc7XG5pbXBvcnQgeyBQYWlyIH0gZnJvbSAnLi9QYWlyLmpzJztcbmltcG9ydCB7IGlzU2NhbGFyVmFsdWUgfSBmcm9tICcuL1NjYWxhci5qcyc7XG5cbmZ1bmN0aW9uIGZpbmRQYWlyKGl0ZW1zLCBrZXkpIHtcbiAgICBjb25zdCBrID0gaXNTY2FsYXIoa2V5KSA/IGtleS52YWx1ZSA6IGtleTtcbiAgICBmb3IgKGNvbnN0IGl0IG9mIGl0ZW1zKSB7XG4gICAgICAgIGlmIChpc1BhaXIoaXQpKSB7XG4gICAgICAgICAgICBpZiAoaXQua2V5ID09PSBrZXkgfHwgaXQua2V5ID09PSBrKVxuICAgICAgICAgICAgICAgIHJldHVybiBpdDtcbiAgICAgICAgICAgIGlmIChpc1NjYWxhcihpdC5rZXkpICYmIGl0LmtleS52YWx1ZSA9PT0gaylcbiAgICAgICAgICAgICAgICByZXR1cm4gaXQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbmNsYXNzIFlBTUxNYXAgZXh0ZW5kcyBDb2xsZWN0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihzY2hlbWEpIHtcbiAgICAgICAgc3VwZXIoTUFQLCBzY2hlbWEpO1xuICAgICAgICB0aGlzLml0ZW1zID0gW107XG4gICAgfVxuICAgIHN0YXRpYyBnZXQgdGFnTmFtZSgpIHtcbiAgICAgICAgcmV0dXJuICd0YWc6eWFtbC5vcmcsMjAwMjptYXAnO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgdmFsdWUgdG8gdGhlIGNvbGxlY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3ZlcndyaXRlIC0gSWYgbm90IHNldCBgdHJ1ZWAsIHVzaW5nIGEga2V5IHRoYXQgaXMgYWxyZWFkeSBpbiB0aGVcbiAgICAgKiAgIGNvbGxlY3Rpb24gd2lsbCB0aHJvdy4gT3RoZXJ3aXNlLCBvdmVyd3JpdGVzIHRoZSBwcmV2aW91cyB2YWx1ZS5cbiAgICAgKi9cbiAgICBhZGQocGFpciwgb3ZlcndyaXRlKSB7XG4gICAgICAgIGxldCBfcGFpcjtcbiAgICAgICAgaWYgKGlzUGFpcihwYWlyKSlcbiAgICAgICAgICAgIF9wYWlyID0gcGFpcjtcbiAgICAgICAgZWxzZSBpZiAoIXBhaXIgfHwgdHlwZW9mIHBhaXIgIT09ICdvYmplY3QnIHx8ICEoJ2tleScgaW4gcGFpcikpIHtcbiAgICAgICAgICAgIC8vIEluIFR5cGVTY3JpcHQsIHRoaXMgbmV2ZXIgaGFwcGVucy5cbiAgICAgICAgICAgIF9wYWlyID0gbmV3IFBhaXIocGFpciwgcGFpci52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgX3BhaXIgPSBuZXcgUGFpcihwYWlyLmtleSwgcGFpci52YWx1ZSk7XG4gICAgICAgIGNvbnN0IHByZXYgPSBmaW5kUGFpcih0aGlzLml0ZW1zLCBfcGFpci5rZXkpO1xuICAgICAgICBjb25zdCBzb3J0RW50cmllcyA9IHRoaXMuc2NoZW1hICYmIHRoaXMuc2NoZW1hLnNvcnRNYXBFbnRyaWVzO1xuICAgICAgICBpZiAocHJldikge1xuICAgICAgICAgICAgaWYgKCFvdmVyd3JpdGUpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBLZXkgJHtfcGFpci5rZXl9IGFscmVhZHkgc2V0YCk7XG4gICAgICAgICAgICAvLyBGb3Igc2NhbGFycywga2VlcCB0aGUgb2xkIG5vZGUgJiBpdHMgY29tbWVudHMgYW5kIGFuY2hvcnNcbiAgICAgICAgICAgIGlmIChpc1NjYWxhcihwcmV2LnZhbHVlKSAmJiBpc1NjYWxhclZhbHVlKF9wYWlyLnZhbHVlKSlcbiAgICAgICAgICAgICAgICBwcmV2LnZhbHVlLnZhbHVlID0gX3BhaXIudmFsdWU7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcHJldi52YWx1ZSA9IF9wYWlyLnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHNvcnRFbnRyaWVzKSB7XG4gICAgICAgICAgICBjb25zdCBpID0gdGhpcy5pdGVtcy5maW5kSW5kZXgoaXRlbSA9PiBzb3J0RW50cmllcyhfcGFpciwgaXRlbSkgPCAwKTtcbiAgICAgICAgICAgIGlmIChpID09PSAtMSlcbiAgICAgICAgICAgICAgICB0aGlzLml0ZW1zLnB1c2goX3BhaXIpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRoaXMuaXRlbXMuc3BsaWNlKGksIDAsIF9wYWlyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaXRlbXMucHVzaChfcGFpcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGVsZXRlKGtleSkge1xuICAgICAgICBjb25zdCBpdCA9IGZpbmRQYWlyKHRoaXMuaXRlbXMsIGtleSk7XG4gICAgICAgIGlmICghaXQpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGNvbnN0IGRlbCA9IHRoaXMuaXRlbXMuc3BsaWNlKHRoaXMuaXRlbXMuaW5kZXhPZihpdCksIDEpO1xuICAgICAgICByZXR1cm4gZGVsLmxlbmd0aCA+IDA7XG4gICAgfVxuICAgIGdldChrZXksIGtlZXBTY2FsYXIpIHtcbiAgICAgICAgY29uc3QgaXQgPSBmaW5kUGFpcih0aGlzLml0ZW1zLCBrZXkpO1xuICAgICAgICBjb25zdCBub2RlID0gaXQgJiYgaXQudmFsdWU7XG4gICAgICAgIHJldHVybiAha2VlcFNjYWxhciAmJiBpc1NjYWxhcihub2RlKSA/IG5vZGUudmFsdWUgOiBub2RlO1xuICAgIH1cbiAgICBoYXMoa2V5KSB7XG4gICAgICAgIHJldHVybiAhIWZpbmRQYWlyKHRoaXMuaXRlbXMsIGtleSk7XG4gICAgfVxuICAgIHNldChrZXksIHZhbHVlKSB7XG4gICAgICAgIHRoaXMuYWRkKG5ldyBQYWlyKGtleSwgdmFsdWUpLCB0cnVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIGN0eCAtIENvbnZlcnNpb24gY29udGV4dCwgb3JpZ2luYWxseSBzZXQgaW4gRG9jdW1lbnQjdG9KUygpXG4gICAgICogQHBhcmFtIHtDbGFzc30gVHlwZSAtIElmIHNldCwgZm9yY2VzIHRoZSByZXR1cm5lZCBjb2xsZWN0aW9uIHR5cGVcbiAgICAgKiBAcmV0dXJucyBJbnN0YW5jZSBvZiBUeXBlLCBNYXAsIG9yIE9iamVjdFxuICAgICAqL1xuICAgIHRvSlNPTihfLCBjdHgsIFR5cGUpIHtcbiAgICAgICAgY29uc3QgbWFwID0gVHlwZSA/IG5ldyBUeXBlKCkgOiBjdHggJiYgY3R4Lm1hcEFzTWFwID8gbmV3IE1hcCgpIDoge307XG4gICAgICAgIGlmIChjdHggJiYgY3R4Lm9uQ3JlYXRlKVxuICAgICAgICAgICAgY3R4Lm9uQ3JlYXRlKG1hcCk7XG4gICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiB0aGlzLml0ZW1zKVxuICAgICAgICAgICAgYWRkUGFpclRvSlNNYXAoY3R4LCBtYXAsIGl0ZW0pO1xuICAgICAgICByZXR1cm4gbWFwO1xuICAgIH1cbiAgICB0b1N0cmluZyhjdHgsIG9uQ29tbWVudCwgb25DaG9tcEtlZXApIHtcbiAgICAgICAgaWYgKCFjdHgpXG4gICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcyk7XG4gICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiB0aGlzLml0ZW1zKSB7XG4gICAgICAgICAgICBpZiAoIWlzUGFpcihpdGVtKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE1hcCBpdGVtcyBtdXN0IGFsbCBiZSBwYWlyczsgZm91bmQgJHtKU09OLnN0cmluZ2lmeShpdGVtKX0gaW5zdGVhZGApO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY3R4LmFsbE51bGxWYWx1ZXMgJiYgdGhpcy5oYXNBbGxOdWxsVmFsdWVzKGZhbHNlKSlcbiAgICAgICAgICAgIGN0eCA9IE9iamVjdC5hc3NpZ24oe30sIGN0eCwgeyBhbGxOdWxsVmFsdWVzOiB0cnVlIH0pO1xuICAgICAgICByZXR1cm4gc3RyaW5naWZ5Q29sbGVjdGlvbih0aGlzLCBjdHgsIHtcbiAgICAgICAgICAgIGJsb2NrSXRlbVByZWZpeDogJycsXG4gICAgICAgICAgICBmbG93Q2hhcnM6IHsgc3RhcnQ6ICd7JywgZW5kOiAnfScgfSxcbiAgICAgICAgICAgIGl0ZW1JbmRlbnQ6IGN0eC5pbmRlbnQgfHwgJycsXG4gICAgICAgICAgICBvbkNob21wS2VlcCxcbiAgICAgICAgICAgIG9uQ29tbWVudFxuICAgICAgICB9KTtcbiAgICB9XG59XG5cbmV4cG9ydCB7IFlBTUxNYXAsIGZpbmRQYWlyIH07XG4iLCAiaW1wb3J0IHsgaXNNYXAgfSBmcm9tICcuLi8uLi9ub2Rlcy9Ob2RlLmpzJztcbmltcG9ydCB7IGNyZWF0ZVBhaXIgfSBmcm9tICcuLi8uLi9ub2Rlcy9QYWlyLmpzJztcbmltcG9ydCB7IFlBTUxNYXAgfSBmcm9tICcuLi8uLi9ub2Rlcy9ZQU1MTWFwLmpzJztcblxuZnVuY3Rpb24gY3JlYXRlTWFwKHNjaGVtYSwgb2JqLCBjdHgpIHtcbiAgICBjb25zdCB7IGtlZXBVbmRlZmluZWQsIHJlcGxhY2VyIH0gPSBjdHg7XG4gICAgY29uc3QgbWFwID0gbmV3IFlBTUxNYXAoc2NoZW1hKTtcbiAgICBjb25zdCBhZGQgPSAoa2V5LCB2YWx1ZSkgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIHJlcGxhY2VyID09PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgdmFsdWUgPSByZXBsYWNlci5jYWxsKG9iaiwga2V5LCB2YWx1ZSk7XG4gICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkocmVwbGFjZXIpICYmICFyZXBsYWNlci5pbmNsdWRlcyhrZXkpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCB8fCBrZWVwVW5kZWZpbmVkKVxuICAgICAgICAgICAgbWFwLml0ZW1zLnB1c2goY3JlYXRlUGFpcihrZXksIHZhbHVlLCBjdHgpKTtcbiAgICB9O1xuICAgIGlmIChvYmogaW5zdGFuY2VvZiBNYXApIHtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2Ygb2JqKVxuICAgICAgICAgICAgYWRkKGtleSwgdmFsdWUpO1xuICAgIH1cbiAgICBlbHNlIGlmIChvYmogJiYgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMob2JqKSlcbiAgICAgICAgICAgIGFkZChrZXksIG9ialtrZXldKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBzY2hlbWEuc29ydE1hcEVudHJpZXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgbWFwLml0ZW1zLnNvcnQoc2NoZW1hLnNvcnRNYXBFbnRyaWVzKTtcbiAgICB9XG4gICAgcmV0dXJuIG1hcDtcbn1cbmNvbnN0IG1hcCA9IHtcbiAgICBjb2xsZWN0aW9uOiAnbWFwJyxcbiAgICBjcmVhdGVOb2RlOiBjcmVhdGVNYXAsXG4gICAgZGVmYXVsdDogdHJ1ZSxcbiAgICBub2RlQ2xhc3M6IFlBTUxNYXAsXG4gICAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6bWFwJyxcbiAgICByZXNvbHZlKG1hcCwgb25FcnJvcikge1xuICAgICAgICBpZiAoIWlzTWFwKG1hcCkpXG4gICAgICAgICAgICBvbkVycm9yKCdFeHBlY3RlZCBhIG1hcHBpbmcgZm9yIHRoaXMgdGFnJyk7XG4gICAgICAgIHJldHVybiBtYXA7XG4gICAgfVxufTtcblxuZXhwb3J0IHsgbWFwIH07XG4iLCAiaW1wb3J0IHsgc3RyaW5naWZ5Q29sbGVjdGlvbiB9IGZyb20gJy4uL3N0cmluZ2lmeS9zdHJpbmdpZnlDb2xsZWN0aW9uLmpzJztcbmltcG9ydCB7IENvbGxlY3Rpb24gfSBmcm9tICcuL0NvbGxlY3Rpb24uanMnO1xuaW1wb3J0IHsgU0VRLCBpc1NjYWxhciB9IGZyb20gJy4vTm9kZS5qcyc7XG5pbXBvcnQgeyBpc1NjYWxhclZhbHVlIH0gZnJvbSAnLi9TY2FsYXIuanMnO1xuaW1wb3J0IHsgdG9KUyB9IGZyb20gJy4vdG9KUy5qcyc7XG5cbmNsYXNzIFlBTUxTZXEgZXh0ZW5kcyBDb2xsZWN0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihzY2hlbWEpIHtcbiAgICAgICAgc3VwZXIoU0VRLCBzY2hlbWEpO1xuICAgICAgICB0aGlzLml0ZW1zID0gW107XG4gICAgfVxuICAgIHN0YXRpYyBnZXQgdGFnTmFtZSgpIHtcbiAgICAgICAgcmV0dXJuICd0YWc6eWFtbC5vcmcsMjAwMjpzZXEnO1xuICAgIH1cbiAgICBhZGQodmFsdWUpIHtcbiAgICAgICAgdGhpcy5pdGVtcy5wdXNoKHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhIHZhbHVlIGZyb20gdGhlIGNvbGxlY3Rpb24uXG4gICAgICpcbiAgICAgKiBga2V5YCBtdXN0IGNvbnRhaW4gYSByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnRlZ2VyIGZvciB0aGlzIHRvIHN1Y2NlZWQuXG4gICAgICogSXQgbWF5IGJlIHdyYXBwZWQgaW4gYSBgU2NhbGFyYC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgaXRlbSB3YXMgZm91bmQgYW5kIHJlbW92ZWQuXG4gICAgICovXG4gICAgZGVsZXRlKGtleSkge1xuICAgICAgICBjb25zdCBpZHggPSBhc0l0ZW1JbmRleChrZXkpO1xuICAgICAgICBpZiAodHlwZW9mIGlkeCAhPT0gJ251bWJlcicpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGNvbnN0IGRlbCA9IHRoaXMuaXRlbXMuc3BsaWNlKGlkeCwgMSk7XG4gICAgICAgIHJldHVybiBkZWwubGVuZ3RoID4gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBpdGVtIGF0IGBrZXlgLCBvciBgdW5kZWZpbmVkYCBpZiBub3QgZm91bmQuIEJ5IGRlZmF1bHQgdW53cmFwc1xuICAgICAqIHNjYWxhciB2YWx1ZXMgZnJvbSB0aGVpciBzdXJyb3VuZGluZyBub2RlOyB0byBkaXNhYmxlIHNldCBga2VlcFNjYWxhcmAgdG9cbiAgICAgKiBgdHJ1ZWAgKGNvbGxlY3Rpb25zIGFyZSBhbHdheXMgcmV0dXJuZWQgaW50YWN0KS5cbiAgICAgKlxuICAgICAqIGBrZXlgIG11c3QgY29udGFpbiBhIHJlcHJlc2VudGF0aW9uIG9mIGFuIGludGVnZXIgZm9yIHRoaXMgdG8gc3VjY2VlZC5cbiAgICAgKiBJdCBtYXkgYmUgd3JhcHBlZCBpbiBhIGBTY2FsYXJgLlxuICAgICAqL1xuICAgIGdldChrZXksIGtlZXBTY2FsYXIpIHtcbiAgICAgICAgY29uc3QgaWR4ID0gYXNJdGVtSW5kZXgoa2V5KTtcbiAgICAgICAgaWYgKHR5cGVvZiBpZHggIT09ICdudW1iZXInKVxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3QgaXQgPSB0aGlzLml0ZW1zW2lkeF07XG4gICAgICAgIHJldHVybiAha2VlcFNjYWxhciAmJiBpc1NjYWxhcihpdCkgPyBpdC52YWx1ZSA6IGl0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGhlIGNvbGxlY3Rpb24gaW5jbHVkZXMgYSB2YWx1ZSB3aXRoIHRoZSBrZXkgYGtleWAuXG4gICAgICpcbiAgICAgKiBga2V5YCBtdXN0IGNvbnRhaW4gYSByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnRlZ2VyIGZvciB0aGlzIHRvIHN1Y2NlZWQuXG4gICAgICogSXQgbWF5IGJlIHdyYXBwZWQgaW4gYSBgU2NhbGFyYC5cbiAgICAgKi9cbiAgICBoYXMoa2V5KSB7XG4gICAgICAgIGNvbnN0IGlkeCA9IGFzSXRlbUluZGV4KGtleSk7XG4gICAgICAgIHJldHVybiB0eXBlb2YgaWR4ID09PSAnbnVtYmVyJyAmJiBpZHggPCB0aGlzLml0ZW1zLmxlbmd0aDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyBhIHZhbHVlIGluIHRoaXMgY29sbGVjdGlvbi4gRm9yIGAhIXNldGAsIGB2YWx1ZWAgbmVlZHMgdG8gYmUgYVxuICAgICAqIGJvb2xlYW4gdG8gYWRkL3JlbW92ZSB0aGUgaXRlbSBmcm9tIHRoZSBzZXQuXG4gICAgICpcbiAgICAgKiBJZiBga2V5YCBkb2VzIG5vdCBjb250YWluIGEgcmVwcmVzZW50YXRpb24gb2YgYW4gaW50ZWdlciwgdGhpcyB3aWxsIHRocm93LlxuICAgICAqIEl0IG1heSBiZSB3cmFwcGVkIGluIGEgYFNjYWxhcmAuXG4gICAgICovXG4gICAgc2V0KGtleSwgdmFsdWUpIHtcbiAgICAgICAgY29uc3QgaWR4ID0gYXNJdGVtSW5kZXgoa2V5KTtcbiAgICAgICAgaWYgKHR5cGVvZiBpZHggIT09ICdudW1iZXInKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBhIHZhbGlkIGluZGV4LCBub3QgJHtrZXl9LmApO1xuICAgICAgICBjb25zdCBwcmV2ID0gdGhpcy5pdGVtc1tpZHhdO1xuICAgICAgICBpZiAoaXNTY2FsYXIocHJldikgJiYgaXNTY2FsYXJWYWx1ZSh2YWx1ZSkpXG4gICAgICAgICAgICBwcmV2LnZhbHVlID0gdmFsdWU7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMuaXRlbXNbaWR4XSA9IHZhbHVlO1xuICAgIH1cbiAgICB0b0pTT04oXywgY3R4KSB7XG4gICAgICAgIGNvbnN0IHNlcSA9IFtdO1xuICAgICAgICBpZiAoY3R4ICYmIGN0eC5vbkNyZWF0ZSlcbiAgICAgICAgICAgIGN0eC5vbkNyZWF0ZShzZXEpO1xuICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiB0aGlzLml0ZW1zKVxuICAgICAgICAgICAgc2VxLnB1c2godG9KUyhpdGVtLCBTdHJpbmcoaSsrKSwgY3R4KSk7XG4gICAgICAgIHJldHVybiBzZXE7XG4gICAgfVxuICAgIHRvU3RyaW5nKGN0eCwgb25Db21tZW50LCBvbkNob21wS2VlcCkge1xuICAgICAgICBpZiAoIWN0eClcbiAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzKTtcbiAgICAgICAgcmV0dXJuIHN0cmluZ2lmeUNvbGxlY3Rpb24odGhpcywgY3R4LCB7XG4gICAgICAgICAgICBibG9ja0l0ZW1QcmVmaXg6ICctICcsXG4gICAgICAgICAgICBmbG93Q2hhcnM6IHsgc3RhcnQ6ICdbJywgZW5kOiAnXScgfSxcbiAgICAgICAgICAgIGl0ZW1JbmRlbnQ6IChjdHguaW5kZW50IHx8ICcnKSArICcgICcsXG4gICAgICAgICAgICBvbkNob21wS2VlcCxcbiAgICAgICAgICAgIG9uQ29tbWVudFxuICAgICAgICB9KTtcbiAgICB9XG59XG5mdW5jdGlvbiBhc0l0ZW1JbmRleChrZXkpIHtcbiAgICBsZXQgaWR4ID0gaXNTY2FsYXIoa2V5KSA/IGtleS52YWx1ZSA6IGtleTtcbiAgICBpZiAoaWR4ICYmIHR5cGVvZiBpZHggPT09ICdzdHJpbmcnKVxuICAgICAgICBpZHggPSBOdW1iZXIoaWR4KTtcbiAgICByZXR1cm4gdHlwZW9mIGlkeCA9PT0gJ251bWJlcicgJiYgTnVtYmVyLmlzSW50ZWdlcihpZHgpICYmIGlkeCA+PSAwXG4gICAgICAgID8gaWR4XG4gICAgICAgIDogbnVsbDtcbn1cblxuZXhwb3J0IHsgWUFNTFNlcSB9O1xuIiwgImltcG9ydCB7IGNyZWF0ZU5vZGUgfSBmcm9tICcuLi8uLi9kb2MvY3JlYXRlTm9kZS5qcyc7XG5pbXBvcnQgeyBpc1NlcSB9IGZyb20gJy4uLy4uL25vZGVzL05vZGUuanMnO1xuaW1wb3J0IHsgWUFNTFNlcSB9IGZyb20gJy4uLy4uL25vZGVzL1lBTUxTZXEuanMnO1xuXG5mdW5jdGlvbiBjcmVhdGVTZXEoc2NoZW1hLCBvYmosIGN0eCkge1xuICAgIGNvbnN0IHsgcmVwbGFjZXIgfSA9IGN0eDtcbiAgICBjb25zdCBzZXEgPSBuZXcgWUFNTFNlcShzY2hlbWEpO1xuICAgIGlmIChvYmogJiYgU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChvYmopKSB7XG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgZm9yIChsZXQgaXQgb2Ygb2JqKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHJlcGxhY2VyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gb2JqIGluc3RhbmNlb2YgU2V0ID8gaXQgOiBTdHJpbmcoaSsrKTtcbiAgICAgICAgICAgICAgICBpdCA9IHJlcGxhY2VyLmNhbGwob2JqLCBrZXksIGl0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlcS5pdGVtcy5wdXNoKGNyZWF0ZU5vZGUoaXQsIHVuZGVmaW5lZCwgY3R4KSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNlcTtcbn1cbmNvbnN0IHNlcSA9IHtcbiAgICBjb2xsZWN0aW9uOiAnc2VxJyxcbiAgICBjcmVhdGVOb2RlOiBjcmVhdGVTZXEsXG4gICAgZGVmYXVsdDogdHJ1ZSxcbiAgICBub2RlQ2xhc3M6IFlBTUxTZXEsXG4gICAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6c2VxJyxcbiAgICByZXNvbHZlKHNlcSwgb25FcnJvcikge1xuICAgICAgICBpZiAoIWlzU2VxKHNlcSkpXG4gICAgICAgICAgICBvbkVycm9yKCdFeHBlY3RlZCBhIHNlcXVlbmNlIGZvciB0aGlzIHRhZycpO1xuICAgICAgICByZXR1cm4gc2VxO1xuICAgIH1cbn07XG5cbmV4cG9ydCB7IHNlcSB9O1xuIiwgImltcG9ydCB7IHN0cmluZ2lmeVN0cmluZyB9IGZyb20gJy4uLy4uL3N0cmluZ2lmeS9zdHJpbmdpZnlTdHJpbmcuanMnO1xuXG5jb25zdCBzdHJpbmcgPSB7XG4gICAgaWRlbnRpZnk6IHZhbHVlID0+IHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycsXG4gICAgZGVmYXVsdDogdHJ1ZSxcbiAgICB0YWc6ICd0YWc6eWFtbC5vcmcsMjAwMjpzdHInLFxuICAgIHJlc29sdmU6IHN0ciA9PiBzdHIsXG4gICAgc3RyaW5naWZ5KGl0ZW0sIGN0eCwgb25Db21tZW50LCBvbkNob21wS2VlcCkge1xuICAgICAgICBjdHggPSBPYmplY3QuYXNzaWduKHsgYWN0dWFsU3RyaW5nOiB0cnVlIH0sIGN0eCk7XG4gICAgICAgIHJldHVybiBzdHJpbmdpZnlTdHJpbmcoaXRlbSwgY3R4LCBvbkNvbW1lbnQsIG9uQ2hvbXBLZWVwKTtcbiAgICB9XG59O1xuXG5leHBvcnQgeyBzdHJpbmcgfTtcbiIsICJpbXBvcnQgeyBTY2FsYXIgfSBmcm9tICcuLi8uLi9ub2Rlcy9TY2FsYXIuanMnO1xuXG5jb25zdCBudWxsVGFnID0ge1xuICAgIGlkZW50aWZ5OiB2YWx1ZSA9PiB2YWx1ZSA9PSBudWxsLFxuICAgIGNyZWF0ZU5vZGU6ICgpID0+IG5ldyBTY2FsYXIobnVsbCksXG4gICAgZGVmYXVsdDogdHJ1ZSxcbiAgICB0YWc6ICd0YWc6eWFtbC5vcmcsMjAwMjpudWxsJyxcbiAgICB0ZXN0OiAvXig/On58W05uXXVsbHxOVUxMKT8kLyxcbiAgICByZXNvbHZlOiAoKSA9PiBuZXcgU2NhbGFyKG51bGwpLFxuICAgIHN0cmluZ2lmeTogKHsgc291cmNlIH0sIGN0eCkgPT4gc291cmNlICYmIG51bGxUYWcudGVzdC50ZXN0KHNvdXJjZSkgPyBzb3VyY2UgOiBjdHgub3B0aW9ucy5udWxsU3RyXG59O1xuXG5leHBvcnQgeyBudWxsVGFnIH07XG4iLCAiaW1wb3J0IHsgU2NhbGFyIH0gZnJvbSAnLi4vLi4vbm9kZXMvU2NhbGFyLmpzJztcblxuY29uc3QgYm9vbFRhZyA9IHtcbiAgICBpZGVudGlmeTogdmFsdWUgPT4gdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicsXG4gICAgZGVmYXVsdDogdHJ1ZSxcbiAgICB0YWc6ICd0YWc6eWFtbC5vcmcsMjAwMjpib29sJyxcbiAgICB0ZXN0OiAvXig/OltUdF1ydWV8VFJVRXxbRmZdYWxzZXxGQUxTRSkkLyxcbiAgICByZXNvbHZlOiBzdHIgPT4gbmV3IFNjYWxhcihzdHJbMF0gPT09ICd0JyB8fCBzdHJbMF0gPT09ICdUJyksXG4gICAgc3RyaW5naWZ5KHsgc291cmNlLCB2YWx1ZSB9LCBjdHgpIHtcbiAgICAgICAgaWYgKHNvdXJjZSAmJiBib29sVGFnLnRlc3QudGVzdChzb3VyY2UpKSB7XG4gICAgICAgICAgICBjb25zdCBzdiA9IHNvdXJjZVswXSA9PT0gJ3QnIHx8IHNvdXJjZVswXSA9PT0gJ1QnO1xuICAgICAgICAgICAgaWYgKHZhbHVlID09PSBzdilcbiAgICAgICAgICAgICAgICByZXR1cm4gc291cmNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZSA/IGN0eC5vcHRpb25zLnRydWVTdHIgOiBjdHgub3B0aW9ucy5mYWxzZVN0cjtcbiAgICB9XG59O1xuXG5leHBvcnQgeyBib29sVGFnIH07XG4iLCAiZnVuY3Rpb24gc3RyaW5naWZ5TnVtYmVyKHsgZm9ybWF0LCBtaW5GcmFjdGlvbkRpZ2l0cywgdGFnLCB2YWx1ZSB9KSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2JpZ2ludCcpXG4gICAgICAgIHJldHVybiBTdHJpbmcodmFsdWUpO1xuICAgIGNvbnN0IG51bSA9IHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgPyB2YWx1ZSA6IE51bWJlcih2YWx1ZSk7XG4gICAgaWYgKCFpc0Zpbml0ZShudW0pKVxuICAgICAgICByZXR1cm4gaXNOYU4obnVtKSA/ICcubmFuJyA6IG51bSA8IDAgPyAnLS5pbmYnIDogJy5pbmYnO1xuICAgIGxldCBuID0gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuICAgIGlmICghZm9ybWF0ICYmXG4gICAgICAgIG1pbkZyYWN0aW9uRGlnaXRzICYmXG4gICAgICAgICghdGFnIHx8IHRhZyA9PT0gJ3RhZzp5YW1sLm9yZywyMDAyOmZsb2F0JykgJiZcbiAgICAgICAgL15cXGQvLnRlc3QobikpIHtcbiAgICAgICAgbGV0IGkgPSBuLmluZGV4T2YoJy4nKTtcbiAgICAgICAgaWYgKGkgPCAwKSB7XG4gICAgICAgICAgICBpID0gbi5sZW5ndGg7XG4gICAgICAgICAgICBuICs9ICcuJztcbiAgICAgICAgfVxuICAgICAgICBsZXQgZCA9IG1pbkZyYWN0aW9uRGlnaXRzIC0gKG4ubGVuZ3RoIC0gaSAtIDEpO1xuICAgICAgICB3aGlsZSAoZC0tID4gMClcbiAgICAgICAgICAgIG4gKz0gJzAnO1xuICAgIH1cbiAgICByZXR1cm4gbjtcbn1cblxuZXhwb3J0IHsgc3RyaW5naWZ5TnVtYmVyIH07XG4iLCAiaW1wb3J0IHsgU2NhbGFyIH0gZnJvbSAnLi4vLi4vbm9kZXMvU2NhbGFyLmpzJztcbmltcG9ydCB7IHN0cmluZ2lmeU51bWJlciB9IGZyb20gJy4uLy4uL3N0cmluZ2lmeS9zdHJpbmdpZnlOdW1iZXIuanMnO1xuXG5jb25zdCBmbG9hdE5hTiA9IHtcbiAgICBpZGVudGlmeTogdmFsdWUgPT4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyxcbiAgICBkZWZhdWx0OiB0cnVlLFxuICAgIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOmZsb2F0JyxcbiAgICB0ZXN0OiAvXig/OlstK10/XFwuKD86aW5mfEluZnxJTkZ8bmFufE5hTnxOQU4pKSQvLFxuICAgIHJlc29sdmU6IHN0ciA9PiBzdHIuc2xpY2UoLTMpLnRvTG93ZXJDYXNlKCkgPT09ICduYW4nXG4gICAgICAgID8gTmFOXG4gICAgICAgIDogc3RyWzBdID09PSAnLSdcbiAgICAgICAgICAgID8gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZXG4gICAgICAgICAgICA6IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSxcbiAgICBzdHJpbmdpZnk6IHN0cmluZ2lmeU51bWJlclxufTtcbmNvbnN0IGZsb2F0RXhwID0ge1xuICAgIGlkZW50aWZ5OiB2YWx1ZSA9PiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInLFxuICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6ZmxvYXQnLFxuICAgIGZvcm1hdDogJ0VYUCcsXG4gICAgdGVzdDogL15bLStdPyg/OlxcLlswLTldK3xbMC05XSsoPzpcXC5bMC05XSopPylbZUVdWy0rXT9bMC05XSskLyxcbiAgICByZXNvbHZlOiBzdHIgPT4gcGFyc2VGbG9hdChzdHIpLFxuICAgIHN0cmluZ2lmeShub2RlKSB7XG4gICAgICAgIGNvbnN0IG51bSA9IE51bWJlcihub2RlLnZhbHVlKTtcbiAgICAgICAgcmV0dXJuIGlzRmluaXRlKG51bSkgPyBudW0udG9FeHBvbmVudGlhbCgpIDogc3RyaW5naWZ5TnVtYmVyKG5vZGUpO1xuICAgIH1cbn07XG5jb25zdCBmbG9hdCA9IHtcbiAgICBpZGVudGlmeTogdmFsdWUgPT4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyxcbiAgICBkZWZhdWx0OiB0cnVlLFxuICAgIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOmZsb2F0JyxcbiAgICB0ZXN0OiAvXlstK10/KD86XFwuWzAtOV0rfFswLTldK1xcLlswLTldKikkLyxcbiAgICByZXNvbHZlKHN0cikge1xuICAgICAgICBjb25zdCBub2RlID0gbmV3IFNjYWxhcihwYXJzZUZsb2F0KHN0cikpO1xuICAgICAgICBjb25zdCBkb3QgPSBzdHIuaW5kZXhPZignLicpO1xuICAgICAgICBpZiAoZG90ICE9PSAtMSAmJiBzdHJbc3RyLmxlbmd0aCAtIDFdID09PSAnMCcpXG4gICAgICAgICAgICBub2RlLm1pbkZyYWN0aW9uRGlnaXRzID0gc3RyLmxlbmd0aCAtIGRvdCAtIDE7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH0sXG4gICAgc3RyaW5naWZ5OiBzdHJpbmdpZnlOdW1iZXJcbn07XG5cbmV4cG9ydCB7IGZsb2F0LCBmbG9hdEV4cCwgZmxvYXROYU4gfTtcbiIsICJpbXBvcnQgeyBzdHJpbmdpZnlOdW1iZXIgfSBmcm9tICcuLi8uLi9zdHJpbmdpZnkvc3RyaW5naWZ5TnVtYmVyLmpzJztcblxuY29uc3QgaW50SWRlbnRpZnkgPSAodmFsdWUpID0+IHR5cGVvZiB2YWx1ZSA9PT0gJ2JpZ2ludCcgfHwgTnVtYmVyLmlzSW50ZWdlcih2YWx1ZSk7XG5jb25zdCBpbnRSZXNvbHZlID0gKHN0ciwgb2Zmc2V0LCByYWRpeCwgeyBpbnRBc0JpZ0ludCB9KSA9PiAoaW50QXNCaWdJbnQgPyBCaWdJbnQoc3RyKSA6IHBhcnNlSW50KHN0ci5zdWJzdHJpbmcob2Zmc2V0KSwgcmFkaXgpKTtcbmZ1bmN0aW9uIGludFN0cmluZ2lmeShub2RlLCByYWRpeCwgcHJlZml4KSB7XG4gICAgY29uc3QgeyB2YWx1ZSB9ID0gbm9kZTtcbiAgICBpZiAoaW50SWRlbnRpZnkodmFsdWUpICYmIHZhbHVlID49IDApXG4gICAgICAgIHJldHVybiBwcmVmaXggKyB2YWx1ZS50b1N0cmluZyhyYWRpeCk7XG4gICAgcmV0dXJuIHN0cmluZ2lmeU51bWJlcihub2RlKTtcbn1cbmNvbnN0IGludE9jdCA9IHtcbiAgICBpZGVudGlmeTogdmFsdWUgPT4gaW50SWRlbnRpZnkodmFsdWUpICYmIHZhbHVlID49IDAsXG4gICAgZGVmYXVsdDogdHJ1ZSxcbiAgICB0YWc6ICd0YWc6eWFtbC5vcmcsMjAwMjppbnQnLFxuICAgIGZvcm1hdDogJ09DVCcsXG4gICAgdGVzdDogL14wb1swLTddKyQvLFxuICAgIHJlc29sdmU6IChzdHIsIF9vbkVycm9yLCBvcHQpID0+IGludFJlc29sdmUoc3RyLCAyLCA4LCBvcHQpLFxuICAgIHN0cmluZ2lmeTogbm9kZSA9PiBpbnRTdHJpbmdpZnkobm9kZSwgOCwgJzBvJylcbn07XG5jb25zdCBpbnQgPSB7XG4gICAgaWRlbnRpZnk6IGludElkZW50aWZ5LFxuICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6aW50JyxcbiAgICB0ZXN0OiAvXlstK10/WzAtOV0rJC8sXG4gICAgcmVzb2x2ZTogKHN0ciwgX29uRXJyb3IsIG9wdCkgPT4gaW50UmVzb2x2ZShzdHIsIDAsIDEwLCBvcHQpLFxuICAgIHN0cmluZ2lmeTogc3RyaW5naWZ5TnVtYmVyXG59O1xuY29uc3QgaW50SGV4ID0ge1xuICAgIGlkZW50aWZ5OiB2YWx1ZSA9PiBpbnRJZGVudGlmeSh2YWx1ZSkgJiYgdmFsdWUgPj0gMCxcbiAgICBkZWZhdWx0OiB0cnVlLFxuICAgIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOmludCcsXG4gICAgZm9ybWF0OiAnSEVYJyxcbiAgICB0ZXN0OiAvXjB4WzAtOWEtZkEtRl0rJC8sXG4gICAgcmVzb2x2ZTogKHN0ciwgX29uRXJyb3IsIG9wdCkgPT4gaW50UmVzb2x2ZShzdHIsIDIsIDE2LCBvcHQpLFxuICAgIHN0cmluZ2lmeTogbm9kZSA9PiBpbnRTdHJpbmdpZnkobm9kZSwgMTYsICcweCcpXG59O1xuXG5leHBvcnQgeyBpbnQsIGludEhleCwgaW50T2N0IH07XG4iLCAiaW1wb3J0IHsgbWFwIH0gZnJvbSAnLi4vY29tbW9uL21hcC5qcyc7XG5pbXBvcnQgeyBudWxsVGFnIH0gZnJvbSAnLi4vY29tbW9uL251bGwuanMnO1xuaW1wb3J0IHsgc2VxIH0gZnJvbSAnLi4vY29tbW9uL3NlcS5qcyc7XG5pbXBvcnQgeyBzdHJpbmcgfSBmcm9tICcuLi9jb21tb24vc3RyaW5nLmpzJztcbmltcG9ydCB7IGJvb2xUYWcgfSBmcm9tICcuL2Jvb2wuanMnO1xuaW1wb3J0IHsgZmxvYXROYU4sIGZsb2F0RXhwLCBmbG9hdCB9IGZyb20gJy4vZmxvYXQuanMnO1xuaW1wb3J0IHsgaW50T2N0LCBpbnQsIGludEhleCB9IGZyb20gJy4vaW50LmpzJztcblxuY29uc3Qgc2NoZW1hID0gW1xuICAgIG1hcCxcbiAgICBzZXEsXG4gICAgc3RyaW5nLFxuICAgIG51bGxUYWcsXG4gICAgYm9vbFRhZyxcbiAgICBpbnRPY3QsXG4gICAgaW50LFxuICAgIGludEhleCxcbiAgICBmbG9hdE5hTixcbiAgICBmbG9hdEV4cCxcbiAgICBmbG9hdFxuXTtcblxuZXhwb3J0IHsgc2NoZW1hIH07XG4iLCAiaW1wb3J0IHsgU2NhbGFyIH0gZnJvbSAnLi4vLi4vbm9kZXMvU2NhbGFyLmpzJztcbmltcG9ydCB7IG1hcCB9IGZyb20gJy4uL2NvbW1vbi9tYXAuanMnO1xuaW1wb3J0IHsgc2VxIH0gZnJvbSAnLi4vY29tbW9uL3NlcS5qcyc7XG5cbmZ1bmN0aW9uIGludElkZW50aWZ5KHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2JpZ2ludCcgfHwgTnVtYmVyLmlzSW50ZWdlcih2YWx1ZSk7XG59XG5jb25zdCBzdHJpbmdpZnlKU09OID0gKHsgdmFsdWUgfSkgPT4gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuY29uc3QganNvblNjYWxhcnMgPSBbXG4gICAge1xuICAgICAgICBpZGVudGlmeTogdmFsdWUgPT4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyxcbiAgICAgICAgZGVmYXVsdDogdHJ1ZSxcbiAgICAgICAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6c3RyJyxcbiAgICAgICAgcmVzb2x2ZTogc3RyID0+IHN0cixcbiAgICAgICAgc3RyaW5naWZ5OiBzdHJpbmdpZnlKU09OXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGlkZW50aWZ5OiB2YWx1ZSA9PiB2YWx1ZSA9PSBudWxsLFxuICAgICAgICBjcmVhdGVOb2RlOiAoKSA9PiBuZXcgU2NhbGFyKG51bGwpLFxuICAgICAgICBkZWZhdWx0OiB0cnVlLFxuICAgICAgICB0YWc6ICd0YWc6eWFtbC5vcmcsMjAwMjpudWxsJyxcbiAgICAgICAgdGVzdDogL15udWxsJC8sXG4gICAgICAgIHJlc29sdmU6ICgpID0+IG51bGwsXG4gICAgICAgIHN0cmluZ2lmeTogc3RyaW5naWZ5SlNPTlxuICAgIH0sXG4gICAge1xuICAgICAgICBpZGVudGlmeTogdmFsdWUgPT4gdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicsXG4gICAgICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgICAgIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOmJvb2wnLFxuICAgICAgICB0ZXN0OiAvXnRydWV8ZmFsc2UkLyxcbiAgICAgICAgcmVzb2x2ZTogc3RyID0+IHN0ciA9PT0gJ3RydWUnLFxuICAgICAgICBzdHJpbmdpZnk6IHN0cmluZ2lmeUpTT05cbiAgICB9LFxuICAgIHtcbiAgICAgICAgaWRlbnRpZnk6IGludElkZW50aWZ5LFxuICAgICAgICBkZWZhdWx0OiB0cnVlLFxuICAgICAgICB0YWc6ICd0YWc6eWFtbC5vcmcsMjAwMjppbnQnLFxuICAgICAgICB0ZXN0OiAvXi0/KD86MHxbMS05XVswLTldKikkLyxcbiAgICAgICAgcmVzb2x2ZTogKHN0ciwgX29uRXJyb3IsIHsgaW50QXNCaWdJbnQgfSkgPT4gaW50QXNCaWdJbnQgPyBCaWdJbnQoc3RyKSA6IHBhcnNlSW50KHN0ciwgMTApLFxuICAgICAgICBzdHJpbmdpZnk6ICh7IHZhbHVlIH0pID0+IGludElkZW50aWZ5KHZhbHVlKSA/IHZhbHVlLnRvU3RyaW5nKCkgOiBKU09OLnN0cmluZ2lmeSh2YWx1ZSlcbiAgICB9LFxuICAgIHtcbiAgICAgICAgaWRlbnRpZnk6IHZhbHVlID0+IHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicsXG4gICAgICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgICAgIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOmZsb2F0JyxcbiAgICAgICAgdGVzdDogL14tPyg/OjB8WzEtOV1bMC05XSopKD86XFwuWzAtOV0qKT8oPzpbZUVdWy0rXT9bMC05XSspPyQvLFxuICAgICAgICByZXNvbHZlOiBzdHIgPT4gcGFyc2VGbG9hdChzdHIpLFxuICAgICAgICBzdHJpbmdpZnk6IHN0cmluZ2lmeUpTT05cbiAgICB9XG5dO1xuY29uc3QganNvbkVycm9yID0ge1xuICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgdGFnOiAnJyxcbiAgICB0ZXN0OiAvXi8sXG4gICAgcmVzb2x2ZShzdHIsIG9uRXJyb3IpIHtcbiAgICAgICAgb25FcnJvcihgVW5yZXNvbHZlZCBwbGFpbiBzY2FsYXIgJHtKU09OLnN0cmluZ2lmeShzdHIpfWApO1xuICAgICAgICByZXR1cm4gc3RyO1xuICAgIH1cbn07XG5jb25zdCBzY2hlbWEgPSBbbWFwLCBzZXFdLmNvbmNhdChqc29uU2NhbGFycywganNvbkVycm9yKTtcblxuZXhwb3J0IHsgc2NoZW1hIH07XG4iLCAiaW1wb3J0IHsgU2NhbGFyIH0gZnJvbSAnLi4vLi4vbm9kZXMvU2NhbGFyLmpzJztcbmltcG9ydCB7IHN0cmluZ2lmeVN0cmluZyB9IGZyb20gJy4uLy4uL3N0cmluZ2lmeS9zdHJpbmdpZnlTdHJpbmcuanMnO1xuXG5jb25zdCBiaW5hcnkgPSB7XG4gICAgaWRlbnRpZnk6IHZhbHVlID0+IHZhbHVlIGluc3RhbmNlb2YgVWludDhBcnJheSxcbiAgICBkZWZhdWx0OiBmYWxzZSxcbiAgICB0YWc6ICd0YWc6eWFtbC5vcmcsMjAwMjpiaW5hcnknLFxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBCdWZmZXIgaW4gbm9kZSBhbmQgYW4gVWludDhBcnJheSBpbiBicm93c2Vyc1xuICAgICAqXG4gICAgICogVG8gdXNlIHRoZSByZXN1bHRpbmcgYnVmZmVyIGFzIGFuIGltYWdlLCB5b3UnbGwgd2FudCB0byBkbyBzb21ldGhpbmcgbGlrZTpcbiAgICAgKlxuICAgICAqICAgY29uc3QgYmxvYiA9IG5ldyBCbG9iKFtidWZmZXJdLCB7IHR5cGU6ICdpbWFnZS9qcGVnJyB9KVxuICAgICAqICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI3Bob3RvJykuc3JjID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKVxuICAgICAqL1xuICAgIHJlc29sdmUoc3JjLCBvbkVycm9yKSB7XG4gICAgICAgIGlmICh0eXBlb2YgQnVmZmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20oc3JjLCAnYmFzZTY0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGF0b2IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIC8vIE9uIElFIDExLCBhdG9iKCkgY2FuJ3QgaGFuZGxlIG5ld2xpbmVzXG4gICAgICAgICAgICBjb25zdCBzdHIgPSBhdG9iKHNyYy5yZXBsYWNlKC9bXFxuXFxyXS9nLCAnJykpO1xuICAgICAgICAgICAgY29uc3QgYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoc3RyLmxlbmd0aCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICBidWZmZXJbaV0gPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgICAgIHJldHVybiBidWZmZXI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvbkVycm9yKCdUaGlzIGVudmlyb25tZW50IGRvZXMgbm90IHN1cHBvcnQgcmVhZGluZyBiaW5hcnkgdGFnczsgZWl0aGVyIEJ1ZmZlciBvciBhdG9iIGlzIHJlcXVpcmVkJyk7XG4gICAgICAgICAgICByZXR1cm4gc3JjO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBzdHJpbmdpZnkoeyBjb21tZW50LCB0eXBlLCB2YWx1ZSB9LCBjdHgsIG9uQ29tbWVudCwgb25DaG9tcEtlZXApIHtcbiAgICAgICAgY29uc3QgYnVmID0gdmFsdWU7IC8vIGNoZWNrZWQgZWFybGllciBieSBiaW5hcnkuaWRlbnRpZnkoKVxuICAgICAgICBsZXQgc3RyO1xuICAgICAgICBpZiAodHlwZW9mIEJ1ZmZlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgc3RyID1cbiAgICAgICAgICAgICAgICBidWYgaW5zdGFuY2VvZiBCdWZmZXJcbiAgICAgICAgICAgICAgICAgICAgPyBidWYudG9TdHJpbmcoJ2Jhc2U2NCcpXG4gICAgICAgICAgICAgICAgICAgIDogQnVmZmVyLmZyb20oYnVmLmJ1ZmZlcikudG9TdHJpbmcoJ2Jhc2U2NCcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBidG9hID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBsZXQgcyA9ICcnO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBidWYubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSk7XG4gICAgICAgICAgICBzdHIgPSBidG9hKHMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIGVudmlyb25tZW50IGRvZXMgbm90IHN1cHBvcnQgd3JpdGluZyBiaW5hcnkgdGFnczsgZWl0aGVyIEJ1ZmZlciBvciBidG9hIGlzIHJlcXVpcmVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0eXBlKVxuICAgICAgICAgICAgdHlwZSA9IFNjYWxhci5CTE9DS19MSVRFUkFMO1xuICAgICAgICBpZiAodHlwZSAhPT0gU2NhbGFyLlFVT1RFX0RPVUJMRSkge1xuICAgICAgICAgICAgY29uc3QgbGluZVdpZHRoID0gTWF0aC5tYXgoY3R4Lm9wdGlvbnMubGluZVdpZHRoIC0gY3R4LmluZGVudC5sZW5ndGgsIGN0eC5vcHRpb25zLm1pbkNvbnRlbnRXaWR0aCk7XG4gICAgICAgICAgICBjb25zdCBuID0gTWF0aC5jZWlsKHN0ci5sZW5ndGggLyBsaW5lV2lkdGgpO1xuICAgICAgICAgICAgY29uc3QgbGluZXMgPSBuZXcgQXJyYXkobik7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbyA9IDA7IGkgPCBuOyArK2ksIG8gKz0gbGluZVdpZHRoKSB7XG4gICAgICAgICAgICAgICAgbGluZXNbaV0gPSBzdHIuc3Vic3RyKG8sIGxpbmVXaWR0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdHIgPSBsaW5lcy5qb2luKHR5cGUgPT09IFNjYWxhci5CTE9DS19MSVRFUkFMID8gJ1xcbicgOiAnICcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHJpbmdpZnlTdHJpbmcoeyBjb21tZW50LCB0eXBlLCB2YWx1ZTogc3RyIH0sIGN0eCwgb25Db21tZW50LCBvbkNob21wS2VlcCk7XG4gICAgfVxufTtcblxuZXhwb3J0IHsgYmluYXJ5IH07XG4iLCAiaW1wb3J0IHsgaXNTZXEsIGlzUGFpciwgaXNNYXAgfSBmcm9tICcuLi8uLi9ub2Rlcy9Ob2RlLmpzJztcbmltcG9ydCB7IFBhaXIsIGNyZWF0ZVBhaXIgfSBmcm9tICcuLi8uLi9ub2Rlcy9QYWlyLmpzJztcbmltcG9ydCB7IFNjYWxhciB9IGZyb20gJy4uLy4uL25vZGVzL1NjYWxhci5qcyc7XG5pbXBvcnQgeyBZQU1MU2VxIH0gZnJvbSAnLi4vLi4vbm9kZXMvWUFNTFNlcS5qcyc7XG5cbmZ1bmN0aW9uIHJlc29sdmVQYWlycyhzZXEsIG9uRXJyb3IpIHtcbiAgICBpZiAoaXNTZXEoc2VxKSkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNlcS5pdGVtcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgbGV0IGl0ZW0gPSBzZXEuaXRlbXNbaV07XG4gICAgICAgICAgICBpZiAoaXNQYWlyKGl0ZW0pKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgZWxzZSBpZiAoaXNNYXAoaXRlbSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbS5pdGVtcy5sZW5ndGggPiAxKVxuICAgICAgICAgICAgICAgICAgICBvbkVycm9yKCdFYWNoIHBhaXIgbXVzdCBoYXZlIGl0cyBvd24gc2VxdWVuY2UgaW5kaWNhdG9yJyk7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFpciA9IGl0ZW0uaXRlbXNbMF0gfHwgbmV3IFBhaXIobmV3IFNjYWxhcihudWxsKSk7XG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0uY29tbWVudEJlZm9yZSlcbiAgICAgICAgICAgICAgICAgICAgcGFpci5rZXkuY29tbWVudEJlZm9yZSA9IHBhaXIua2V5LmNvbW1lbnRCZWZvcmVcbiAgICAgICAgICAgICAgICAgICAgICAgID8gYCR7aXRlbS5jb21tZW50QmVmb3JlfVxcbiR7cGFpci5rZXkuY29tbWVudEJlZm9yZX1gXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGl0ZW0uY29tbWVudEJlZm9yZTtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbS5jb21tZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNuID0gcGFpci52YWx1ZSB8fCBwYWlyLmtleTtcbiAgICAgICAgICAgICAgICAgICAgY24uY29tbWVudCA9IGNuLmNvbW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgID8gYCR7aXRlbS5jb21tZW50fVxcbiR7Y24uY29tbWVudH1gXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGl0ZW0uY29tbWVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaXRlbSA9IHBhaXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXEuaXRlbXNbaV0gPSBpc1BhaXIoaXRlbSkgPyBpdGVtIDogbmV3IFBhaXIoaXRlbSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZVxuICAgICAgICBvbkVycm9yKCdFeHBlY3RlZCBhIHNlcXVlbmNlIGZvciB0aGlzIHRhZycpO1xuICAgIHJldHVybiBzZXE7XG59XG5mdW5jdGlvbiBjcmVhdGVQYWlycyhzY2hlbWEsIGl0ZXJhYmxlLCBjdHgpIHtcbiAgICBjb25zdCB7IHJlcGxhY2VyIH0gPSBjdHg7XG4gICAgY29uc3QgcGFpcnMgPSBuZXcgWUFNTFNlcShzY2hlbWEpO1xuICAgIHBhaXJzLnRhZyA9ICd0YWc6eWFtbC5vcmcsMjAwMjpwYWlycyc7XG4gICAgbGV0IGkgPSAwO1xuICAgIGlmIChpdGVyYWJsZSAmJiBTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGl0ZXJhYmxlKSlcbiAgICAgICAgZm9yIChsZXQgaXQgb2YgaXRlcmFibGUpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcmVwbGFjZXIgPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICAgICAgaXQgPSByZXBsYWNlci5jYWxsKGl0ZXJhYmxlLCBTdHJpbmcoaSsrKSwgaXQpO1xuICAgICAgICAgICAgbGV0IGtleSwgdmFsdWU7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShpdCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXQubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIGtleSA9IGl0WzBdO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGl0WzFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEV4cGVjdGVkIFtrZXksIHZhbHVlXSB0dXBsZTogJHtpdH1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGl0ICYmIGl0IGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGl0KTtcbiAgICAgICAgICAgICAgICBpZiAoa2V5cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAga2V5ID0ga2V5c1swXTtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBpdFtrZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEV4cGVjdGVkIHsga2V5OiB2YWx1ZSB9IHR1cGxlOiAke2l0fWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAga2V5ID0gaXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYWlycy5pdGVtcy5wdXNoKGNyZWF0ZVBhaXIoa2V5LCB2YWx1ZSwgY3R4KSk7XG4gICAgICAgIH1cbiAgICByZXR1cm4gcGFpcnM7XG59XG5jb25zdCBwYWlycyA9IHtcbiAgICBjb2xsZWN0aW9uOiAnc2VxJyxcbiAgICBkZWZhdWx0OiBmYWxzZSxcbiAgICB0YWc6ICd0YWc6eWFtbC5vcmcsMjAwMjpwYWlycycsXG4gICAgcmVzb2x2ZTogcmVzb2x2ZVBhaXJzLFxuICAgIGNyZWF0ZU5vZGU6IGNyZWF0ZVBhaXJzXG59O1xuXG5leHBvcnQgeyBjcmVhdGVQYWlycywgcGFpcnMsIHJlc29sdmVQYWlycyB9O1xuIiwgImltcG9ydCB7IFlBTUxTZXEgfSBmcm9tICcuLi8uLi9ub2Rlcy9ZQU1MU2VxLmpzJztcbmltcG9ydCB7IHRvSlMgfSBmcm9tICcuLi8uLi9ub2Rlcy90b0pTLmpzJztcbmltcG9ydCB7IGlzU2NhbGFyLCBpc1BhaXIgfSBmcm9tICcuLi8uLi9ub2Rlcy9Ob2RlLmpzJztcbmltcG9ydCB7IFlBTUxNYXAgfSBmcm9tICcuLi8uLi9ub2Rlcy9ZQU1MTWFwLmpzJztcbmltcG9ydCB7IHJlc29sdmVQYWlycywgY3JlYXRlUGFpcnMgfSBmcm9tICcuL3BhaXJzLmpzJztcblxuY2xhc3MgWUFNTE9NYXAgZXh0ZW5kcyBZQU1MU2VxIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5hZGQgPSBZQU1MTWFwLnByb3RvdHlwZS5hZGQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5kZWxldGUgPSBZQU1MTWFwLnByb3RvdHlwZS5kZWxldGUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5nZXQgPSBZQU1MTWFwLnByb3RvdHlwZS5nZXQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5oYXMgPSBZQU1MTWFwLnByb3RvdHlwZS5oYXMuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5zZXQgPSBZQU1MTWFwLnByb3RvdHlwZS5zZXQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy50YWcgPSBZQU1MT01hcC50YWc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIElmIGBjdHhgIGlzIGdpdmVuLCB0aGUgcmV0dXJuIHR5cGUgaXMgYWN0dWFsbHkgYE1hcDx1bmtub3duLCB1bmtub3duPmAsXG4gICAgICogYnV0IFR5cGVTY3JpcHQgd29uJ3QgYWxsb3cgd2lkZW5pbmcgdGhlIHNpZ25hdHVyZSBvZiBhIGNoaWxkIG1ldGhvZC5cbiAgICAgKi9cbiAgICB0b0pTT04oXywgY3R4KSB7XG4gICAgICAgIGlmICghY3R4KVxuICAgICAgICAgICAgcmV0dXJuIHN1cGVyLnRvSlNPTihfKTtcbiAgICAgICAgY29uc3QgbWFwID0gbmV3IE1hcCgpO1xuICAgICAgICBpZiAoY3R4ICYmIGN0eC5vbkNyZWF0ZSlcbiAgICAgICAgICAgIGN0eC5vbkNyZWF0ZShtYXApO1xuICAgICAgICBmb3IgKGNvbnN0IHBhaXIgb2YgdGhpcy5pdGVtcykge1xuICAgICAgICAgICAgbGV0IGtleSwgdmFsdWU7XG4gICAgICAgICAgICBpZiAoaXNQYWlyKHBhaXIpKSB7XG4gICAgICAgICAgICAgICAga2V5ID0gdG9KUyhwYWlyLmtleSwgJycsIGN0eCk7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB0b0pTKHBhaXIudmFsdWUsIGtleSwgY3R4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGtleSA9IHRvSlMocGFpciwgJycsIGN0eCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWFwLmhhcyhrZXkpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignT3JkZXJlZCBtYXBzIG11c3Qgbm90IGluY2x1ZGUgZHVwbGljYXRlIGtleXMnKTtcbiAgICAgICAgICAgIG1hcC5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1hcDtcbiAgICB9XG59XG5ZQU1MT01hcC50YWcgPSAndGFnOnlhbWwub3JnLDIwMDI6b21hcCc7XG5jb25zdCBvbWFwID0ge1xuICAgIGNvbGxlY3Rpb246ICdzZXEnLFxuICAgIGlkZW50aWZ5OiB2YWx1ZSA9PiB2YWx1ZSBpbnN0YW5jZW9mIE1hcCxcbiAgICBub2RlQ2xhc3M6IFlBTUxPTWFwLFxuICAgIGRlZmF1bHQ6IGZhbHNlLFxuICAgIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOm9tYXAnLFxuICAgIHJlc29sdmUoc2VxLCBvbkVycm9yKSB7XG4gICAgICAgIGNvbnN0IHBhaXJzID0gcmVzb2x2ZVBhaXJzKHNlcSwgb25FcnJvcik7XG4gICAgICAgIGNvbnN0IHNlZW5LZXlzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgeyBrZXkgfSBvZiBwYWlycy5pdGVtcykge1xuICAgICAgICAgICAgaWYgKGlzU2NhbGFyKGtleSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2VlbktleXMuaW5jbHVkZXMoa2V5LnZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICBvbkVycm9yKGBPcmRlcmVkIG1hcHMgbXVzdCBub3QgaW5jbHVkZSBkdXBsaWNhdGUga2V5czogJHtrZXkudmFsdWV9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzZWVuS2V5cy5wdXNoKGtleS52YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKG5ldyBZQU1MT01hcCgpLCBwYWlycyk7XG4gICAgfSxcbiAgICBjcmVhdGVOb2RlKHNjaGVtYSwgaXRlcmFibGUsIGN0eCkge1xuICAgICAgICBjb25zdCBwYWlycyA9IGNyZWF0ZVBhaXJzKHNjaGVtYSwgaXRlcmFibGUsIGN0eCk7XG4gICAgICAgIGNvbnN0IG9tYXAgPSBuZXcgWUFNTE9NYXAoKTtcbiAgICAgICAgb21hcC5pdGVtcyA9IHBhaXJzLml0ZW1zO1xuICAgICAgICByZXR1cm4gb21hcDtcbiAgICB9XG59O1xuXG5leHBvcnQgeyBZQU1MT01hcCwgb21hcCB9O1xuIiwgImltcG9ydCB7IFNjYWxhciB9IGZyb20gJy4uLy4uL25vZGVzL1NjYWxhci5qcyc7XG5cbmZ1bmN0aW9uIGJvb2xTdHJpbmdpZnkoeyB2YWx1ZSwgc291cmNlIH0sIGN0eCkge1xuICAgIGNvbnN0IGJvb2xPYmogPSB2YWx1ZSA/IHRydWVUYWcgOiBmYWxzZVRhZztcbiAgICBpZiAoc291cmNlICYmIGJvb2xPYmoudGVzdC50ZXN0KHNvdXJjZSkpXG4gICAgICAgIHJldHVybiBzb3VyY2U7XG4gICAgcmV0dXJuIHZhbHVlID8gY3R4Lm9wdGlvbnMudHJ1ZVN0ciA6IGN0eC5vcHRpb25zLmZhbHNlU3RyO1xufVxuY29uc3QgdHJ1ZVRhZyA9IHtcbiAgICBpZGVudGlmeTogdmFsdWUgPT4gdmFsdWUgPT09IHRydWUsXG4gICAgZGVmYXVsdDogdHJ1ZSxcbiAgICB0YWc6ICd0YWc6eWFtbC5vcmcsMjAwMjpib29sJyxcbiAgICB0ZXN0OiAvXig/Oll8eXxbWXldZXN8WUVTfFtUdF1ydWV8VFJVRXxbT29dbnxPTikkLyxcbiAgICByZXNvbHZlOiAoKSA9PiBuZXcgU2NhbGFyKHRydWUpLFxuICAgIHN0cmluZ2lmeTogYm9vbFN0cmluZ2lmeVxufTtcbmNvbnN0IGZhbHNlVGFnID0ge1xuICAgIGlkZW50aWZ5OiB2YWx1ZSA9PiB2YWx1ZSA9PT0gZmFsc2UsXG4gICAgZGVmYXVsdDogdHJ1ZSxcbiAgICB0YWc6ICd0YWc6eWFtbC5vcmcsMjAwMjpib29sJyxcbiAgICB0ZXN0OiAvXig/Ok58bnxbTm5db3xOT3xbRmZdYWxzZXxGQUxTRXxbT29dZmZ8T0ZGKSQvaSxcbiAgICByZXNvbHZlOiAoKSA9PiBuZXcgU2NhbGFyKGZhbHNlKSxcbiAgICBzdHJpbmdpZnk6IGJvb2xTdHJpbmdpZnlcbn07XG5cbmV4cG9ydCB7IGZhbHNlVGFnLCB0cnVlVGFnIH07XG4iLCAiaW1wb3J0IHsgU2NhbGFyIH0gZnJvbSAnLi4vLi4vbm9kZXMvU2NhbGFyLmpzJztcbmltcG9ydCB7IHN0cmluZ2lmeU51bWJlciB9IGZyb20gJy4uLy4uL3N0cmluZ2lmeS9zdHJpbmdpZnlOdW1iZXIuanMnO1xuXG5jb25zdCBmbG9hdE5hTiA9IHtcbiAgICBpZGVudGlmeTogdmFsdWUgPT4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyxcbiAgICBkZWZhdWx0OiB0cnVlLFxuICAgIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOmZsb2F0JyxcbiAgICB0ZXN0OiAvXlstK10/XFwuKD86aW5mfEluZnxJTkZ8bmFufE5hTnxOQU4pJC8sXG4gICAgcmVzb2x2ZTogKHN0cikgPT4gc3RyLnNsaWNlKC0zKS50b0xvd2VyQ2FzZSgpID09PSAnbmFuJ1xuICAgICAgICA/IE5hTlxuICAgICAgICA6IHN0clswXSA9PT0gJy0nXG4gICAgICAgICAgICA/IE51bWJlci5ORUdBVElWRV9JTkZJTklUWVxuICAgICAgICAgICAgOiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksXG4gICAgc3RyaW5naWZ5OiBzdHJpbmdpZnlOdW1iZXJcbn07XG5jb25zdCBmbG9hdEV4cCA9IHtcbiAgICBpZGVudGlmeTogdmFsdWUgPT4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyxcbiAgICBkZWZhdWx0OiB0cnVlLFxuICAgIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOmZsb2F0JyxcbiAgICBmb3JtYXQ6ICdFWFAnLFxuICAgIHRlc3Q6IC9eWy0rXT8oPzpbMC05XVswLTlfXSopPyg/OlxcLlswLTlfXSopP1tlRV1bLStdP1swLTldKyQvLFxuICAgIHJlc29sdmU6IChzdHIpID0+IHBhcnNlRmxvYXQoc3RyLnJlcGxhY2UoL18vZywgJycpKSxcbiAgICBzdHJpbmdpZnkobm9kZSkge1xuICAgICAgICBjb25zdCBudW0gPSBOdW1iZXIobm9kZS52YWx1ZSk7XG4gICAgICAgIHJldHVybiBpc0Zpbml0ZShudW0pID8gbnVtLnRvRXhwb25lbnRpYWwoKSA6IHN0cmluZ2lmeU51bWJlcihub2RlKTtcbiAgICB9XG59O1xuY29uc3QgZmxvYXQgPSB7XG4gICAgaWRlbnRpZnk6IHZhbHVlID0+IHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicsXG4gICAgZGVmYXVsdDogdHJ1ZSxcbiAgICB0YWc6ICd0YWc6eWFtbC5vcmcsMjAwMjpmbG9hdCcsXG4gICAgdGVzdDogL15bLStdPyg/OlswLTldWzAtOV9dKik/XFwuWzAtOV9dKiQvLFxuICAgIHJlc29sdmUoc3RyKSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBuZXcgU2NhbGFyKHBhcnNlRmxvYXQoc3RyLnJlcGxhY2UoL18vZywgJycpKSk7XG4gICAgICAgIGNvbnN0IGRvdCA9IHN0ci5pbmRleE9mKCcuJyk7XG4gICAgICAgIGlmIChkb3QgIT09IC0xKSB7XG4gICAgICAgICAgICBjb25zdCBmID0gc3RyLnN1YnN0cmluZyhkb3QgKyAxKS5yZXBsYWNlKC9fL2csICcnKTtcbiAgICAgICAgICAgIGlmIChmW2YubGVuZ3RoIC0gMV0gPT09ICcwJylcbiAgICAgICAgICAgICAgICBub2RlLm1pbkZyYWN0aW9uRGlnaXRzID0gZi5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfSxcbiAgICBzdHJpbmdpZnk6IHN0cmluZ2lmeU51bWJlclxufTtcblxuZXhwb3J0IHsgZmxvYXQsIGZsb2F0RXhwLCBmbG9hdE5hTiB9O1xuIiwgImltcG9ydCB7IHN0cmluZ2lmeU51bWJlciB9IGZyb20gJy4uLy4uL3N0cmluZ2lmeS9zdHJpbmdpZnlOdW1iZXIuanMnO1xuXG5jb25zdCBpbnRJZGVudGlmeSA9ICh2YWx1ZSkgPT4gdHlwZW9mIHZhbHVlID09PSAnYmlnaW50JyB8fCBOdW1iZXIuaXNJbnRlZ2VyKHZhbHVlKTtcbmZ1bmN0aW9uIGludFJlc29sdmUoc3RyLCBvZmZzZXQsIHJhZGl4LCB7IGludEFzQmlnSW50IH0pIHtcbiAgICBjb25zdCBzaWduID0gc3RyWzBdO1xuICAgIGlmIChzaWduID09PSAnLScgfHwgc2lnbiA9PT0gJysnKVxuICAgICAgICBvZmZzZXQgKz0gMTtcbiAgICBzdHIgPSBzdHIuc3Vic3RyaW5nKG9mZnNldCkucmVwbGFjZSgvXy9nLCAnJyk7XG4gICAgaWYgKGludEFzQmlnSW50KSB7XG4gICAgICAgIHN3aXRjaCAocmFkaXgpIHtcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICBzdHIgPSBgMGIke3N0cn1gO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgIHN0ciA9IGAwbyR7c3RyfWA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDE2OlxuICAgICAgICAgICAgICAgIHN0ciA9IGAweCR7c3RyfWA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbiA9IEJpZ0ludChzdHIpO1xuICAgICAgICByZXR1cm4gc2lnbiA9PT0gJy0nID8gQmlnSW50KC0xKSAqIG4gOiBuO1xuICAgIH1cbiAgICBjb25zdCBuID0gcGFyc2VJbnQoc3RyLCByYWRpeCk7XG4gICAgcmV0dXJuIHNpZ24gPT09ICctJyA/IC0xICogbiA6IG47XG59XG5mdW5jdGlvbiBpbnRTdHJpbmdpZnkobm9kZSwgcmFkaXgsIHByZWZpeCkge1xuICAgIGNvbnN0IHsgdmFsdWUgfSA9IG5vZGU7XG4gICAgaWYgKGludElkZW50aWZ5KHZhbHVlKSkge1xuICAgICAgICBjb25zdCBzdHIgPSB2YWx1ZS50b1N0cmluZyhyYWRpeCk7XG4gICAgICAgIHJldHVybiB2YWx1ZSA8IDAgPyAnLScgKyBwcmVmaXggKyBzdHIuc3Vic3RyKDEpIDogcHJlZml4ICsgc3RyO1xuICAgIH1cbiAgICByZXR1cm4gc3RyaW5naWZ5TnVtYmVyKG5vZGUpO1xufVxuY29uc3QgaW50QmluID0ge1xuICAgIGlkZW50aWZ5OiBpbnRJZGVudGlmeSxcbiAgICBkZWZhdWx0OiB0cnVlLFxuICAgIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOmludCcsXG4gICAgZm9ybWF0OiAnQklOJyxcbiAgICB0ZXN0OiAvXlstK10/MGJbMC0xX10rJC8sXG4gICAgcmVzb2x2ZTogKHN0ciwgX29uRXJyb3IsIG9wdCkgPT4gaW50UmVzb2x2ZShzdHIsIDIsIDIsIG9wdCksXG4gICAgc3RyaW5naWZ5OiBub2RlID0+IGludFN0cmluZ2lmeShub2RlLCAyLCAnMGInKVxufTtcbmNvbnN0IGludE9jdCA9IHtcbiAgICBpZGVudGlmeTogaW50SWRlbnRpZnksXG4gICAgZGVmYXVsdDogdHJ1ZSxcbiAgICB0YWc6ICd0YWc6eWFtbC5vcmcsMjAwMjppbnQnLFxuICAgIGZvcm1hdDogJ09DVCcsXG4gICAgdGVzdDogL15bLStdPzBbMC03X10rJC8sXG4gICAgcmVzb2x2ZTogKHN0ciwgX29uRXJyb3IsIG9wdCkgPT4gaW50UmVzb2x2ZShzdHIsIDEsIDgsIG9wdCksXG4gICAgc3RyaW5naWZ5OiBub2RlID0+IGludFN0cmluZ2lmeShub2RlLCA4LCAnMCcpXG59O1xuY29uc3QgaW50ID0ge1xuICAgIGlkZW50aWZ5OiBpbnRJZGVudGlmeSxcbiAgICBkZWZhdWx0OiB0cnVlLFxuICAgIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOmludCcsXG4gICAgdGVzdDogL15bLStdP1swLTldWzAtOV9dKiQvLFxuICAgIHJlc29sdmU6IChzdHIsIF9vbkVycm9yLCBvcHQpID0+IGludFJlc29sdmUoc3RyLCAwLCAxMCwgb3B0KSxcbiAgICBzdHJpbmdpZnk6IHN0cmluZ2lmeU51bWJlclxufTtcbmNvbnN0IGludEhleCA9IHtcbiAgICBpZGVudGlmeTogaW50SWRlbnRpZnksXG4gICAgZGVmYXVsdDogdHJ1ZSxcbiAgICB0YWc6ICd0YWc6eWFtbC5vcmcsMjAwMjppbnQnLFxuICAgIGZvcm1hdDogJ0hFWCcsXG4gICAgdGVzdDogL15bLStdPzB4WzAtOWEtZkEtRl9dKyQvLFxuICAgIHJlc29sdmU6IChzdHIsIF9vbkVycm9yLCBvcHQpID0+IGludFJlc29sdmUoc3RyLCAyLCAxNiwgb3B0KSxcbiAgICBzdHJpbmdpZnk6IG5vZGUgPT4gaW50U3RyaW5naWZ5KG5vZGUsIDE2LCAnMHgnKVxufTtcblxuZXhwb3J0IHsgaW50LCBpbnRCaW4sIGludEhleCwgaW50T2N0IH07XG4iLCAiaW1wb3J0IHsgaXNNYXAsIGlzUGFpciwgaXNTY2FsYXIgfSBmcm9tICcuLi8uLi9ub2Rlcy9Ob2RlLmpzJztcbmltcG9ydCB7IGNyZWF0ZVBhaXIsIFBhaXIgfSBmcm9tICcuLi8uLi9ub2Rlcy9QYWlyLmpzJztcbmltcG9ydCB7IFlBTUxNYXAsIGZpbmRQYWlyIH0gZnJvbSAnLi4vLi4vbm9kZXMvWUFNTE1hcC5qcyc7XG5cbmNsYXNzIFlBTUxTZXQgZXh0ZW5kcyBZQU1MTWFwIHtcbiAgICBjb25zdHJ1Y3RvcihzY2hlbWEpIHtcbiAgICAgICAgc3VwZXIoc2NoZW1hKTtcbiAgICAgICAgdGhpcy50YWcgPSBZQU1MU2V0LnRhZztcbiAgICB9XG4gICAgYWRkKGtleSkge1xuICAgICAgICBsZXQgcGFpcjtcbiAgICAgICAgaWYgKGlzUGFpcihrZXkpKVxuICAgICAgICAgICAgcGFpciA9IGtleTtcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGtleSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgICdrZXknIGluIGtleSAmJlxuICAgICAgICAgICAgJ3ZhbHVlJyBpbiBrZXkgJiZcbiAgICAgICAgICAgIGtleS52YWx1ZSA9PT0gbnVsbClcbiAgICAgICAgICAgIHBhaXIgPSBuZXcgUGFpcihrZXkua2V5LCBudWxsKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcGFpciA9IG5ldyBQYWlyKGtleSwgbnVsbCk7XG4gICAgICAgIGNvbnN0IHByZXYgPSBmaW5kUGFpcih0aGlzLml0ZW1zLCBwYWlyLmtleSk7XG4gICAgICAgIGlmICghcHJldilcbiAgICAgICAgICAgIHRoaXMuaXRlbXMucHVzaChwYWlyKTtcbiAgICB9XG4gICAgZ2V0KGtleSwga2VlcFBhaXIpIHtcbiAgICAgICAgY29uc3QgcGFpciA9IGZpbmRQYWlyKHRoaXMuaXRlbXMsIGtleSk7XG4gICAgICAgIHJldHVybiAha2VlcFBhaXIgJiYgaXNQYWlyKHBhaXIpXG4gICAgICAgICAgICA/IGlzU2NhbGFyKHBhaXIua2V5KVxuICAgICAgICAgICAgICAgID8gcGFpci5rZXkudmFsdWVcbiAgICAgICAgICAgICAgICA6IHBhaXIua2V5XG4gICAgICAgICAgICA6IHBhaXI7XG4gICAgfVxuICAgIHNldChrZXksIHZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdib29sZWFuJylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgYm9vbGVhbiB2YWx1ZSBmb3Igc2V0KGtleSwgdmFsdWUpIGluIGEgWUFNTCBzZXQsIG5vdCAke3R5cGVvZiB2YWx1ZX1gKTtcbiAgICAgICAgY29uc3QgcHJldiA9IGZpbmRQYWlyKHRoaXMuaXRlbXMsIGtleSk7XG4gICAgICAgIGlmIChwcmV2ICYmICF2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5pdGVtcy5zcGxpY2UodGhpcy5pdGVtcy5pbmRleE9mKHByZXYpLCAxKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghcHJldiAmJiB2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5pdGVtcy5wdXNoKG5ldyBQYWlyKGtleSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRvSlNPTihfLCBjdHgpIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLnRvSlNPTihfLCBjdHgsIFNldCk7XG4gICAgfVxuICAgIHRvU3RyaW5nKGN0eCwgb25Db21tZW50LCBvbkNob21wS2VlcCkge1xuICAgICAgICBpZiAoIWN0eClcbiAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzKTtcbiAgICAgICAgaWYgKHRoaXMuaGFzQWxsTnVsbFZhbHVlcyh0cnVlKSlcbiAgICAgICAgICAgIHJldHVybiBzdXBlci50b1N0cmluZyhPYmplY3QuYXNzaWduKHt9LCBjdHgsIHsgYWxsTnVsbFZhbHVlczogdHJ1ZSB9KSwgb25Db21tZW50LCBvbkNob21wS2VlcCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU2V0IGl0ZW1zIG11c3QgYWxsIGhhdmUgbnVsbCB2YWx1ZXMnKTtcbiAgICB9XG59XG5ZQU1MU2V0LnRhZyA9ICd0YWc6eWFtbC5vcmcsMjAwMjpzZXQnO1xuY29uc3Qgc2V0ID0ge1xuICAgIGNvbGxlY3Rpb246ICdtYXAnLFxuICAgIGlkZW50aWZ5OiB2YWx1ZSA9PiB2YWx1ZSBpbnN0YW5jZW9mIFNldCxcbiAgICBub2RlQ2xhc3M6IFlBTUxTZXQsXG4gICAgZGVmYXVsdDogZmFsc2UsXG4gICAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6c2V0JyxcbiAgICByZXNvbHZlKG1hcCwgb25FcnJvcikge1xuICAgICAgICBpZiAoaXNNYXAobWFwKSkge1xuICAgICAgICAgICAgaWYgKG1hcC5oYXNBbGxOdWxsVmFsdWVzKHRydWUpKVxuICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKG5ldyBZQU1MU2V0KCksIG1hcCk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgb25FcnJvcignU2V0IGl0ZW1zIG11c3QgYWxsIGhhdmUgbnVsbCB2YWx1ZXMnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICBvbkVycm9yKCdFeHBlY3RlZCBhIG1hcHBpbmcgZm9yIHRoaXMgdGFnJyk7XG4gICAgICAgIHJldHVybiBtYXA7XG4gICAgfSxcbiAgICBjcmVhdGVOb2RlKHNjaGVtYSwgaXRlcmFibGUsIGN0eCkge1xuICAgICAgICBjb25zdCB7IHJlcGxhY2VyIH0gPSBjdHg7XG4gICAgICAgIGNvbnN0IHNldCA9IG5ldyBZQU1MU2V0KHNjaGVtYSk7XG4gICAgICAgIGlmIChpdGVyYWJsZSAmJiBTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGl0ZXJhYmxlKSlcbiAgICAgICAgICAgIGZvciAobGV0IHZhbHVlIG9mIGl0ZXJhYmxlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiByZXBsYWNlciA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSByZXBsYWNlci5jYWxsKGl0ZXJhYmxlLCB2YWx1ZSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIHNldC5pdGVtcy5wdXNoKGNyZWF0ZVBhaXIodmFsdWUsIG51bGwsIGN0eCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2V0O1xuICAgIH1cbn07XG5cbmV4cG9ydCB7IFlBTUxTZXQsIHNldCB9O1xuIiwgImltcG9ydCB7IHN0cmluZ2lmeU51bWJlciB9IGZyb20gJy4uLy4uL3N0cmluZ2lmeS9zdHJpbmdpZnlOdW1iZXIuanMnO1xuXG4vKiogSW50ZXJuYWwgdHlwZXMgaGFuZGxlIGJpZ2ludCBhcyBudW1iZXIsIGJlY2F1c2UgVFMgY2FuJ3QgZmlndXJlIGl0IG91dC4gKi9cbmZ1bmN0aW9uIHBhcnNlU2V4YWdlc2ltYWwoc3RyLCBhc0JpZ0ludCkge1xuICAgIGNvbnN0IHNpZ24gPSBzdHJbMF07XG4gICAgY29uc3QgcGFydHMgPSBzaWduID09PSAnLScgfHwgc2lnbiA9PT0gJysnID8gc3RyLnN1YnN0cmluZygxKSA6IHN0cjtcbiAgICBjb25zdCBudW0gPSAobikgPT4gYXNCaWdJbnQgPyBCaWdJbnQobikgOiBOdW1iZXIobik7XG4gICAgY29uc3QgcmVzID0gcGFydHNcbiAgICAgICAgLnJlcGxhY2UoL18vZywgJycpXG4gICAgICAgIC5zcGxpdCgnOicpXG4gICAgICAgIC5yZWR1Y2UoKHJlcywgcCkgPT4gcmVzICogbnVtKDYwKSArIG51bShwKSwgbnVtKDApKTtcbiAgICByZXR1cm4gKHNpZ24gPT09ICctJyA/IG51bSgtMSkgKiByZXMgOiByZXMpO1xufVxuLyoqXG4gKiBoaGhoOm1tOnNzLnNzc1xuICpcbiAqIEludGVybmFsIHR5cGVzIGhhbmRsZSBiaWdpbnQgYXMgbnVtYmVyLCBiZWNhdXNlIFRTIGNhbid0IGZpZ3VyZSBpdCBvdXQuXG4gKi9cbmZ1bmN0aW9uIHN0cmluZ2lmeVNleGFnZXNpbWFsKG5vZGUpIHtcbiAgICBsZXQgeyB2YWx1ZSB9ID0gbm9kZTtcbiAgICBsZXQgbnVtID0gKG4pID0+IG47XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2JpZ2ludCcpXG4gICAgICAgIG51bSA9IG4gPT4gQmlnSW50KG4pO1xuICAgIGVsc2UgaWYgKGlzTmFOKHZhbHVlKSB8fCAhaXNGaW5pdGUodmFsdWUpKVxuICAgICAgICByZXR1cm4gc3RyaW5naWZ5TnVtYmVyKG5vZGUpO1xuICAgIGxldCBzaWduID0gJyc7XG4gICAgaWYgKHZhbHVlIDwgMCkge1xuICAgICAgICBzaWduID0gJy0nO1xuICAgICAgICB2YWx1ZSAqPSBudW0oLTEpO1xuICAgIH1cbiAgICBjb25zdCBfNjAgPSBudW0oNjApO1xuICAgIGNvbnN0IHBhcnRzID0gW3ZhbHVlICUgXzYwXTsgLy8gc2Vjb25kcywgaW5jbHVkaW5nIG1zXG4gICAgaWYgKHZhbHVlIDwgNjApIHtcbiAgICAgICAgcGFydHMudW5zaGlmdCgwKTsgLy8gYXQgbGVhc3Qgb25lIDogaXMgcmVxdWlyZWRcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZhbHVlID0gKHZhbHVlIC0gcGFydHNbMF0pIC8gXzYwO1xuICAgICAgICBwYXJ0cy51bnNoaWZ0KHZhbHVlICUgXzYwKTsgLy8gbWludXRlc1xuICAgICAgICBpZiAodmFsdWUgPj0gNjApIHtcbiAgICAgICAgICAgIHZhbHVlID0gKHZhbHVlIC0gcGFydHNbMF0pIC8gXzYwO1xuICAgICAgICAgICAgcGFydHMudW5zaGlmdCh2YWx1ZSk7IC8vIGhvdXJzXG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIChzaWduICtcbiAgICAgICAgcGFydHNcbiAgICAgICAgICAgIC5tYXAobiA9PiAobiA8IDEwID8gJzAnICsgU3RyaW5nKG4pIDogU3RyaW5nKG4pKSlcbiAgICAgICAgICAgIC5qb2luKCc6JylcbiAgICAgICAgICAgIC5yZXBsYWNlKC8wMDAwMDBcXGQqJC8sICcnKSAvLyAlIDYwIG1heSBpbnRyb2R1Y2UgZXJyb3JcbiAgICApO1xufVxuY29uc3QgaW50VGltZSA9IHtcbiAgICBpZGVudGlmeTogdmFsdWUgPT4gdHlwZW9mIHZhbHVlID09PSAnYmlnaW50JyB8fCBOdW1iZXIuaXNJbnRlZ2VyKHZhbHVlKSxcbiAgICBkZWZhdWx0OiB0cnVlLFxuICAgIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOmludCcsXG4gICAgZm9ybWF0OiAnVElNRScsXG4gICAgdGVzdDogL15bLStdP1swLTldWzAtOV9dKig/OjpbMC01XT9bMC05XSkrJC8sXG4gICAgcmVzb2x2ZTogKHN0ciwgX29uRXJyb3IsIHsgaW50QXNCaWdJbnQgfSkgPT4gcGFyc2VTZXhhZ2VzaW1hbChzdHIsIGludEFzQmlnSW50KSxcbiAgICBzdHJpbmdpZnk6IHN0cmluZ2lmeVNleGFnZXNpbWFsXG59O1xuY29uc3QgZmxvYXRUaW1lID0ge1xuICAgIGlkZW50aWZ5OiB2YWx1ZSA9PiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInLFxuICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6ZmxvYXQnLFxuICAgIGZvcm1hdDogJ1RJTUUnLFxuICAgIHRlc3Q6IC9eWy0rXT9bMC05XVswLTlfXSooPzo6WzAtNV0/WzAtOV0pK1xcLlswLTlfXSokLyxcbiAgICByZXNvbHZlOiBzdHIgPT4gcGFyc2VTZXhhZ2VzaW1hbChzdHIsIGZhbHNlKSxcbiAgICBzdHJpbmdpZnk6IHN0cmluZ2lmeVNleGFnZXNpbWFsXG59O1xuY29uc3QgdGltZXN0YW1wID0ge1xuICAgIGlkZW50aWZ5OiB2YWx1ZSA9PiB2YWx1ZSBpbnN0YW5jZW9mIERhdGUsXG4gICAgZGVmYXVsdDogdHJ1ZSxcbiAgICB0YWc6ICd0YWc6eWFtbC5vcmcsMjAwMjp0aW1lc3RhbXAnLFxuICAgIC8vIElmIHRoZSB0aW1lIHpvbmUgaXMgb21pdHRlZCwgdGhlIHRpbWVzdGFtcCBpcyBhc3N1bWVkIHRvIGJlIHNwZWNpZmllZCBpbiBVVEMuIFRoZSB0aW1lIHBhcnRcbiAgICAvLyBtYXkgYmUgb21pdHRlZCBhbHRvZ2V0aGVyLCByZXN1bHRpbmcgaW4gYSBkYXRlIGZvcm1hdC4gSW4gc3VjaCBhIGNhc2UsIHRoZSB0aW1lIHBhcnQgaXNcbiAgICAvLyBhc3N1bWVkIHRvIGJlIDAwOjAwOjAwWiAoc3RhcnQgb2YgZGF5LCBVVEMpLlxuICAgIHRlc3Q6IFJlZ0V4cCgnXihbMC05XXs0fSktKFswLTldezEsMn0pLShbMC05XXsxLDJ9KScgKyAvLyBZWVlZLU1tLURkXG4gICAgICAgICcoPzonICsgLy8gdGltZSBpcyBvcHRpb25hbFxuICAgICAgICAnKD86dHxUfFsgXFxcXHRdKyknICsgLy8gdCB8IFQgfCB3aGl0ZXNwYWNlXG4gICAgICAgICcoWzAtOV17MSwyfSk6KFswLTldezEsMn0pOihbMC05XXsxLDJ9KFxcXFwuWzAtOV0rKT8pJyArIC8vIEhoOk1tOlNzKC5zcyk/XG4gICAgICAgICcoPzpbIFxcXFx0XSooWnxbLStdWzAxMl0/WzAtOV0oPzo6WzAtOV17Mn0pPykpPycgKyAvLyBaIHwgKzUgfCAtMDM6MzBcbiAgICAgICAgJyk/JCcpLFxuICAgIHJlc29sdmUoc3RyKSB7XG4gICAgICAgIGNvbnN0IG1hdGNoID0gc3RyLm1hdGNoKHRpbWVzdGFtcC50ZXN0KTtcbiAgICAgICAgaWYgKCFtYXRjaClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignISF0aW1lc3RhbXAgZXhwZWN0cyBhIGRhdGUsIHN0YXJ0aW5nIHdpdGggeXl5eS1tbS1kZCcpO1xuICAgICAgICBjb25zdCBbLCB5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZF0gPSBtYXRjaC5tYXAoTnVtYmVyKTtcbiAgICAgICAgY29uc3QgbWlsbGlzZWMgPSBtYXRjaFs3XSA/IE51bWJlcigobWF0Y2hbN10gKyAnMDAnKS5zdWJzdHIoMSwgMykpIDogMDtcbiAgICAgICAgbGV0IGRhdGUgPSBEYXRlLlVUQyh5ZWFyLCBtb250aCAtIDEsIGRheSwgaG91ciB8fCAwLCBtaW51dGUgfHwgMCwgc2Vjb25kIHx8IDAsIG1pbGxpc2VjKTtcbiAgICAgICAgY29uc3QgdHogPSBtYXRjaFs4XTtcbiAgICAgICAgaWYgKHR6ICYmIHR6ICE9PSAnWicpIHtcbiAgICAgICAgICAgIGxldCBkID0gcGFyc2VTZXhhZ2VzaW1hbCh0eiwgZmFsc2UpO1xuICAgICAgICAgICAgaWYgKE1hdGguYWJzKGQpIDwgMzApXG4gICAgICAgICAgICAgICAgZCAqPSA2MDtcbiAgICAgICAgICAgIGRhdGUgLT0gNjAwMDAgKiBkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZShkYXRlKTtcbiAgICB9LFxuICAgIHN0cmluZ2lmeTogKHsgdmFsdWUgfSkgPT4gdmFsdWUudG9JU09TdHJpbmcoKS5yZXBsYWNlKC8oKFQwMDowMCk/OjAwKT9cXC4wMDBaJC8sICcnKVxufTtcblxuZXhwb3J0IHsgZmxvYXRUaW1lLCBpbnRUaW1lLCB0aW1lc3RhbXAgfTtcbiIsICJpbXBvcnQgeyBtYXAgfSBmcm9tICcuLi9jb21tb24vbWFwLmpzJztcbmltcG9ydCB7IG51bGxUYWcgfSBmcm9tICcuLi9jb21tb24vbnVsbC5qcyc7XG5pbXBvcnQgeyBzZXEgfSBmcm9tICcuLi9jb21tb24vc2VxLmpzJztcbmltcG9ydCB7IHN0cmluZyB9IGZyb20gJy4uL2NvbW1vbi9zdHJpbmcuanMnO1xuaW1wb3J0IHsgYmluYXJ5IH0gZnJvbSAnLi9iaW5hcnkuanMnO1xuaW1wb3J0IHsgdHJ1ZVRhZywgZmFsc2VUYWcgfSBmcm9tICcuL2Jvb2wuanMnO1xuaW1wb3J0IHsgZmxvYXROYU4sIGZsb2F0RXhwLCBmbG9hdCB9IGZyb20gJy4vZmxvYXQuanMnO1xuaW1wb3J0IHsgaW50QmluLCBpbnRPY3QsIGludCwgaW50SGV4IH0gZnJvbSAnLi9pbnQuanMnO1xuaW1wb3J0IHsgb21hcCB9IGZyb20gJy4vb21hcC5qcyc7XG5pbXBvcnQgeyBwYWlycyB9IGZyb20gJy4vcGFpcnMuanMnO1xuaW1wb3J0IHsgc2V0IH0gZnJvbSAnLi9zZXQuanMnO1xuaW1wb3J0IHsgaW50VGltZSwgZmxvYXRUaW1lLCB0aW1lc3RhbXAgfSBmcm9tICcuL3RpbWVzdGFtcC5qcyc7XG5cbmNvbnN0IHNjaGVtYSA9IFtcbiAgICBtYXAsXG4gICAgc2VxLFxuICAgIHN0cmluZyxcbiAgICBudWxsVGFnLFxuICAgIHRydWVUYWcsXG4gICAgZmFsc2VUYWcsXG4gICAgaW50QmluLFxuICAgIGludE9jdCxcbiAgICBpbnQsXG4gICAgaW50SGV4LFxuICAgIGZsb2F0TmFOLFxuICAgIGZsb2F0RXhwLFxuICAgIGZsb2F0LFxuICAgIGJpbmFyeSxcbiAgICBvbWFwLFxuICAgIHBhaXJzLFxuICAgIHNldCxcbiAgICBpbnRUaW1lLFxuICAgIGZsb2F0VGltZSxcbiAgICB0aW1lc3RhbXBcbl07XG5cbmV4cG9ydCB7IHNjaGVtYSB9O1xuIiwgImltcG9ydCB7IG1hcCB9IGZyb20gJy4vY29tbW9uL21hcC5qcyc7XG5pbXBvcnQgeyBudWxsVGFnIH0gZnJvbSAnLi9jb21tb24vbnVsbC5qcyc7XG5pbXBvcnQgeyBzZXEgfSBmcm9tICcuL2NvbW1vbi9zZXEuanMnO1xuaW1wb3J0IHsgc3RyaW5nIH0gZnJvbSAnLi9jb21tb24vc3RyaW5nLmpzJztcbmltcG9ydCB7IGJvb2xUYWcgfSBmcm9tICcuL2NvcmUvYm9vbC5qcyc7XG5pbXBvcnQgeyBmbG9hdCwgZmxvYXRFeHAsIGZsb2F0TmFOIH0gZnJvbSAnLi9jb3JlL2Zsb2F0LmpzJztcbmltcG9ydCB7IGludCwgaW50SGV4LCBpbnRPY3QgfSBmcm9tICcuL2NvcmUvaW50LmpzJztcbmltcG9ydCB7IHNjaGVtYSB9IGZyb20gJy4vY29yZS9zY2hlbWEuanMnO1xuaW1wb3J0IHsgc2NoZW1hIGFzIHNjaGVtYSQxIH0gZnJvbSAnLi9qc29uL3NjaGVtYS5qcyc7XG5pbXBvcnQgeyBiaW5hcnkgfSBmcm9tICcuL3lhbWwtMS4xL2JpbmFyeS5qcyc7XG5pbXBvcnQgeyBvbWFwIH0gZnJvbSAnLi95YW1sLTEuMS9vbWFwLmpzJztcbmltcG9ydCB7IHBhaXJzIH0gZnJvbSAnLi95YW1sLTEuMS9wYWlycy5qcyc7XG5pbXBvcnQgeyBzY2hlbWEgYXMgc2NoZW1hJDIgfSBmcm9tICcuL3lhbWwtMS4xL3NjaGVtYS5qcyc7XG5pbXBvcnQgeyBzZXQgfSBmcm9tICcuL3lhbWwtMS4xL3NldC5qcyc7XG5pbXBvcnQgeyBmbG9hdFRpbWUsIGludFRpbWUsIHRpbWVzdGFtcCB9IGZyb20gJy4veWFtbC0xLjEvdGltZXN0YW1wLmpzJztcblxuY29uc3Qgc2NoZW1hcyA9IG5ldyBNYXAoW1xuICAgIFsnY29yZScsIHNjaGVtYV0sXG4gICAgWydmYWlsc2FmZScsIFttYXAsIHNlcSwgc3RyaW5nXV0sXG4gICAgWydqc29uJywgc2NoZW1hJDFdLFxuICAgIFsneWFtbDExJywgc2NoZW1hJDJdLFxuICAgIFsneWFtbC0xLjEnLCBzY2hlbWEkMl1cbl0pO1xuY29uc3QgdGFnc0J5TmFtZSA9IHtcbiAgICBiaW5hcnksXG4gICAgYm9vbDogYm9vbFRhZyxcbiAgICBmbG9hdCxcbiAgICBmbG9hdEV4cCxcbiAgICBmbG9hdE5hTixcbiAgICBmbG9hdFRpbWUsXG4gICAgaW50LFxuICAgIGludEhleCxcbiAgICBpbnRPY3QsXG4gICAgaW50VGltZSxcbiAgICBtYXAsXG4gICAgbnVsbDogbnVsbFRhZyxcbiAgICBvbWFwLFxuICAgIHBhaXJzLFxuICAgIHNlcSxcbiAgICBzZXQsXG4gICAgdGltZXN0YW1wXG59O1xuY29uc3QgY29yZUtub3duVGFncyA9IHtcbiAgICAndGFnOnlhbWwub3JnLDIwMDI6YmluYXJ5JzogYmluYXJ5LFxuICAgICd0YWc6eWFtbC5vcmcsMjAwMjpvbWFwJzogb21hcCxcbiAgICAndGFnOnlhbWwub3JnLDIwMDI6cGFpcnMnOiBwYWlycyxcbiAgICAndGFnOnlhbWwub3JnLDIwMDI6c2V0Jzogc2V0LFxuICAgICd0YWc6eWFtbC5vcmcsMjAwMjp0aW1lc3RhbXAnOiB0aW1lc3RhbXBcbn07XG5mdW5jdGlvbiBnZXRUYWdzKGN1c3RvbVRhZ3MsIHNjaGVtYU5hbWUpIHtcbiAgICBsZXQgdGFncyA9IHNjaGVtYXMuZ2V0KHNjaGVtYU5hbWUpO1xuICAgIGlmICghdGFncykge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjdXN0b21UYWdzKSlcbiAgICAgICAgICAgIHRhZ3MgPSBbXTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBrZXlzID0gQXJyYXkuZnJvbShzY2hlbWFzLmtleXMoKSlcbiAgICAgICAgICAgICAgICAuZmlsdGVyKGtleSA9PiBrZXkgIT09ICd5YW1sMTEnKVxuICAgICAgICAgICAgICAgIC5tYXAoa2V5ID0+IEpTT04uc3RyaW5naWZ5KGtleSkpXG4gICAgICAgICAgICAgICAgLmpvaW4oJywgJyk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gc2NoZW1hIFwiJHtzY2hlbWFOYW1lfVwiOyB1c2Ugb25lIG9mICR7a2V5c30gb3IgZGVmaW5lIGN1c3RvbVRhZ3MgYXJyYXlgKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShjdXN0b21UYWdzKSkge1xuICAgICAgICBmb3IgKGNvbnN0IHRhZyBvZiBjdXN0b21UYWdzKVxuICAgICAgICAgICAgdGFncyA9IHRhZ3MuY29uY2F0KHRhZyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBjdXN0b21UYWdzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRhZ3MgPSBjdXN0b21UYWdzKHRhZ3Muc2xpY2UoKSk7XG4gICAgfVxuICAgIHJldHVybiB0YWdzLm1hcCh0YWcgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIHRhZyAhPT0gJ3N0cmluZycpXG4gICAgICAgICAgICByZXR1cm4gdGFnO1xuICAgICAgICBjb25zdCB0YWdPYmogPSB0YWdzQnlOYW1lW3RhZ107XG4gICAgICAgIGlmICh0YWdPYmopXG4gICAgICAgICAgICByZXR1cm4gdGFnT2JqO1xuICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXModGFnc0J5TmFtZSlcbiAgICAgICAgICAgIC5tYXAoa2V5ID0+IEpTT04uc3RyaW5naWZ5KGtleSkpXG4gICAgICAgICAgICAuam9pbignLCAnKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGN1c3RvbSB0YWcgXCIke3RhZ31cIjsgdXNlIG9uZSBvZiAke2tleXN9YCk7XG4gICAgfSk7XG59XG5cbmV4cG9ydCB7IGNvcmVLbm93blRhZ3MsIGdldFRhZ3MgfTtcbiIsICJpbXBvcnQgeyBNQVAsIFNDQUxBUiwgU0VRIH0gZnJvbSAnLi4vbm9kZXMvTm9kZS5qcyc7XG5pbXBvcnQgeyBtYXAgfSBmcm9tICcuL2NvbW1vbi9tYXAuanMnO1xuaW1wb3J0IHsgc2VxIH0gZnJvbSAnLi9jb21tb24vc2VxLmpzJztcbmltcG9ydCB7IHN0cmluZyB9IGZyb20gJy4vY29tbW9uL3N0cmluZy5qcyc7XG5pbXBvcnQgeyBnZXRUYWdzLCBjb3JlS25vd25UYWdzIH0gZnJvbSAnLi90YWdzLmpzJztcblxuY29uc3Qgc29ydE1hcEVudHJpZXNCeUtleSA9IChhLCBiKSA9PiBhLmtleSA8IGIua2V5ID8gLTEgOiBhLmtleSA+IGIua2V5ID8gMSA6IDA7XG5jbGFzcyBTY2hlbWEge1xuICAgIGNvbnN0cnVjdG9yKHsgY29tcGF0LCBjdXN0b21UYWdzLCBtZXJnZSwgcmVzb2x2ZUtub3duVGFncywgc2NoZW1hLCBzb3J0TWFwRW50cmllcywgdG9TdHJpbmdEZWZhdWx0cyB9KSB7XG4gICAgICAgIHRoaXMuY29tcGF0ID0gQXJyYXkuaXNBcnJheShjb21wYXQpXG4gICAgICAgICAgICA/IGdldFRhZ3MoY29tcGF0LCAnY29tcGF0JylcbiAgICAgICAgICAgIDogY29tcGF0XG4gICAgICAgICAgICAgICAgPyBnZXRUYWdzKG51bGwsIGNvbXBhdClcbiAgICAgICAgICAgICAgICA6IG51bGw7XG4gICAgICAgIHRoaXMubWVyZ2UgPSAhIW1lcmdlO1xuICAgICAgICB0aGlzLm5hbWUgPSAodHlwZW9mIHNjaGVtYSA9PT0gJ3N0cmluZycgJiYgc2NoZW1hKSB8fCAnY29yZSc7XG4gICAgICAgIHRoaXMua25vd25UYWdzID0gcmVzb2x2ZUtub3duVGFncyA/IGNvcmVLbm93blRhZ3MgOiB7fTtcbiAgICAgICAgdGhpcy50YWdzID0gZ2V0VGFncyhjdXN0b21UYWdzLCB0aGlzLm5hbWUpO1xuICAgICAgICB0aGlzLnRvU3RyaW5nT3B0aW9ucyA9IHRvU3RyaW5nRGVmYXVsdHMgfHwgbnVsbDtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIE1BUCwgeyB2YWx1ZTogbWFwIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgU0NBTEFSLCB7IHZhbHVlOiBzdHJpbmcgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBTRVEsIHsgdmFsdWU6IHNlcSB9KTtcbiAgICAgICAgLy8gVXNlZCBieSBjcmVhdGVNYXAoKVxuICAgICAgICB0aGlzLnNvcnRNYXBFbnRyaWVzID1cbiAgICAgICAgICAgIHNvcnRNYXBFbnRyaWVzID09PSB0cnVlID8gc29ydE1hcEVudHJpZXNCeUtleSA6IHNvcnRNYXBFbnRyaWVzIHx8IG51bGw7XG4gICAgfVxuICAgIGNsb25lKCkge1xuICAgICAgICBjb25zdCBjb3B5ID0gT2JqZWN0LmNyZWF0ZShTY2hlbWEucHJvdG90eXBlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0aGlzKSk7XG4gICAgICAgIGNvcHkudGFncyA9IHRoaXMudGFncy5zbGljZSgpO1xuICAgICAgICByZXR1cm4gY29weTtcbiAgICB9XG59XG5cbmV4cG9ydCB7IFNjaGVtYSB9O1xuIiwgImltcG9ydCB7IGlzTm9kZSB9IGZyb20gJy4uL25vZGVzL05vZGUuanMnO1xuaW1wb3J0IHsgY3JlYXRlU3RyaW5naWZ5Q29udGV4dCwgc3RyaW5naWZ5IH0gZnJvbSAnLi9zdHJpbmdpZnkuanMnO1xuaW1wb3J0IHsgaW5kZW50Q29tbWVudCwgbGluZUNvbW1lbnQgfSBmcm9tICcuL3N0cmluZ2lmeUNvbW1lbnQuanMnO1xuXG5mdW5jdGlvbiBzdHJpbmdpZnlEb2N1bWVudChkb2MsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBsaW5lcyA9IFtdO1xuICAgIGxldCBoYXNEaXJlY3RpdmVzID0gb3B0aW9ucy5kaXJlY3RpdmVzID09PSB0cnVlO1xuICAgIGlmIChvcHRpb25zLmRpcmVjdGl2ZXMgIT09IGZhbHNlICYmIGRvYy5kaXJlY3RpdmVzKSB7XG4gICAgICAgIGNvbnN0IGRpciA9IGRvYy5kaXJlY3RpdmVzLnRvU3RyaW5nKGRvYyk7XG4gICAgICAgIGlmIChkaXIpIHtcbiAgICAgICAgICAgIGxpbmVzLnB1c2goZGlyKTtcbiAgICAgICAgICAgIGhhc0RpcmVjdGl2ZXMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRvYy5kaXJlY3RpdmVzLm1hcmtlcilcbiAgICAgICAgICAgIGhhc0RpcmVjdGl2ZXMgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoaGFzRGlyZWN0aXZlcylcbiAgICAgICAgbGluZXMucHVzaCgnLS0tJyk7XG4gICAgY29uc3QgY3R4ID0gY3JlYXRlU3RyaW5naWZ5Q29udGV4dChkb2MsIG9wdGlvbnMpO1xuICAgIGNvbnN0IHsgY29tbWVudFN0cmluZyB9ID0gY3R4Lm9wdGlvbnM7XG4gICAgaWYgKGRvYy5jb21tZW50QmVmb3JlKSB7XG4gICAgICAgIGlmIChsaW5lcy5sZW5ndGggIT09IDEpXG4gICAgICAgICAgICBsaW5lcy51bnNoaWZ0KCcnKTtcbiAgICAgICAgY29uc3QgY3MgPSBjb21tZW50U3RyaW5nKGRvYy5jb21tZW50QmVmb3JlKTtcbiAgICAgICAgbGluZXMudW5zaGlmdChpbmRlbnRDb21tZW50KGNzLCAnJykpO1xuICAgIH1cbiAgICBsZXQgY2hvbXBLZWVwID0gZmFsc2U7XG4gICAgbGV0IGNvbnRlbnRDb21tZW50ID0gbnVsbDtcbiAgICBpZiAoZG9jLmNvbnRlbnRzKSB7XG4gICAgICAgIGlmIChpc05vZGUoZG9jLmNvbnRlbnRzKSkge1xuICAgICAgICAgICAgaWYgKGRvYy5jb250ZW50cy5zcGFjZUJlZm9yZSAmJiBoYXNEaXJlY3RpdmVzKVxuICAgICAgICAgICAgICAgIGxpbmVzLnB1c2goJycpO1xuICAgICAgICAgICAgaWYgKGRvYy5jb250ZW50cy5jb21tZW50QmVmb3JlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY3MgPSBjb21tZW50U3RyaW5nKGRvYy5jb250ZW50cy5jb21tZW50QmVmb3JlKTtcbiAgICAgICAgICAgICAgICBsaW5lcy5wdXNoKGluZGVudENvbW1lbnQoY3MsICcnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB0b3AtbGV2ZWwgYmxvY2sgc2NhbGFycyBuZWVkIHRvIGJlIGluZGVudGVkIGlmIGZvbGxvd2VkIGJ5IGEgY29tbWVudFxuICAgICAgICAgICAgY3R4LmZvcmNlQmxvY2tJbmRlbnQgPSAhIWRvYy5jb21tZW50O1xuICAgICAgICAgICAgY29udGVudENvbW1lbnQgPSBkb2MuY29udGVudHMuY29tbWVudDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvbkNob21wS2VlcCA9IGNvbnRlbnRDb21tZW50ID8gdW5kZWZpbmVkIDogKCkgPT4gKGNob21wS2VlcCA9IHRydWUpO1xuICAgICAgICBsZXQgYm9keSA9IHN0cmluZ2lmeShkb2MuY29udGVudHMsIGN0eCwgKCkgPT4gKGNvbnRlbnRDb21tZW50ID0gbnVsbCksIG9uQ2hvbXBLZWVwKTtcbiAgICAgICAgaWYgKGNvbnRlbnRDb21tZW50KVxuICAgICAgICAgICAgYm9keSArPSBsaW5lQ29tbWVudChib2R5LCAnJywgY29tbWVudFN0cmluZyhjb250ZW50Q29tbWVudCkpO1xuICAgICAgICBpZiAoKGJvZHlbMF0gPT09ICd8JyB8fCBib2R5WzBdID09PSAnPicpICYmXG4gICAgICAgICAgICBsaW5lc1tsaW5lcy5sZW5ndGggLSAxXSA9PT0gJy0tLScpIHtcbiAgICAgICAgICAgIC8vIFRvcC1sZXZlbCBibG9jayBzY2FsYXJzIHdpdGggYSBwcmVjZWRpbmcgZG9jIG1hcmtlciBvdWdodCB0byB1c2UgdGhlXG4gICAgICAgICAgICAvLyBzYW1lIGxpbmUgZm9yIHRoZWlyIGhlYWRlci5cbiAgICAgICAgICAgIGxpbmVzW2xpbmVzLmxlbmd0aCAtIDFdID0gYC0tLSAke2JvZHl9YDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICBsaW5lcy5wdXNoKGJvZHkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbGluZXMucHVzaChzdHJpbmdpZnkoZG9jLmNvbnRlbnRzLCBjdHgpKTtcbiAgICB9XG4gICAgbGV0IGRjID0gZG9jLmNvbW1lbnQ7XG4gICAgaWYgKGRjICYmIGNob21wS2VlcClcbiAgICAgICAgZGMgPSBkYy5yZXBsYWNlKC9eXFxuKy8sICcnKTtcbiAgICBpZiAoZGMpIHtcbiAgICAgICAgaWYgKCghY2hvbXBLZWVwIHx8IGNvbnRlbnRDb21tZW50KSAmJiBsaW5lc1tsaW5lcy5sZW5ndGggLSAxXSAhPT0gJycpXG4gICAgICAgICAgICBsaW5lcy5wdXNoKCcnKTtcbiAgICAgICAgbGluZXMucHVzaChpbmRlbnRDb21tZW50KGNvbW1lbnRTdHJpbmcoZGMpLCAnJykpO1xuICAgIH1cbiAgICByZXR1cm4gbGluZXMuam9pbignXFxuJykgKyAnXFxuJztcbn1cblxuZXhwb3J0IHsgc3RyaW5naWZ5RG9jdW1lbnQgfTtcbiIsICIvKipcbiAqIEFwcGxpZXMgdGhlIEpTT04ucGFyc2UgcmV2aXZlciBhbGdvcml0aG0gYXMgZGVmaW5lZCBpbiB0aGUgRUNNQS0yNjIgc3BlYyxcbiAqIGluIHNlY3Rpb24gMjQuNS4xLjEgXCJSdW50aW1lIFNlbWFudGljczogSW50ZXJuYWxpemVKU09OUHJvcGVydHlcIiBvZiB0aGVcbiAqIDIwMjEgZWRpdGlvbjogaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1qc29uLnBhcnNlXG4gKlxuICogSW5jbHVkZXMgZXh0ZW5zaW9ucyBmb3IgaGFuZGxpbmcgTWFwIGFuZCBTZXQgb2JqZWN0cy5cbiAqL1xuZnVuY3Rpb24gYXBwbHlSZXZpdmVyKHJldml2ZXIsIG9iaiwga2V5LCB2YWwpIHtcbiAgICBpZiAodmFsICYmIHR5cGVvZiB2YWwgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSB2YWwubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2MCA9IHZhbFtpXTtcbiAgICAgICAgICAgICAgICBjb25zdCB2MSA9IGFwcGx5UmV2aXZlcihyZXZpdmVyLCB2YWwsIFN0cmluZyhpKSwgdjApO1xuICAgICAgICAgICAgICAgIGlmICh2MSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdmFsW2ldO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHYxICE9PSB2MClcbiAgICAgICAgICAgICAgICAgICAgdmFsW2ldID0gdjE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmFsIGluc3RhbmNlb2YgTWFwKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGsgb2YgQXJyYXkuZnJvbSh2YWwua2V5cygpKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHYwID0gdmFsLmdldChrKTtcbiAgICAgICAgICAgICAgICBjb25zdCB2MSA9IGFwcGx5UmV2aXZlcihyZXZpdmVyLCB2YWwsIGssIHYwKTtcbiAgICAgICAgICAgICAgICBpZiAodjEgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICAgICAgdmFsLmRlbGV0ZShrKTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh2MSAhPT0gdjApXG4gICAgICAgICAgICAgICAgICAgIHZhbC5zZXQoaywgdjEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZhbCBpbnN0YW5jZW9mIFNldCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCB2MCBvZiBBcnJheS5mcm9tKHZhbCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2MSA9IGFwcGx5UmV2aXZlcihyZXZpdmVyLCB2YWwsIHYwLCB2MCk7XG4gICAgICAgICAgICAgICAgaWYgKHYxID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgICAgIHZhbC5kZWxldGUodjApO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHYxICE9PSB2MCkge1xuICAgICAgICAgICAgICAgICAgICB2YWwuZGVsZXRlKHYwKTtcbiAgICAgICAgICAgICAgICAgICAgdmFsLmFkZCh2MSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yIChjb25zdCBbaywgdjBdIG9mIE9iamVjdC5lbnRyaWVzKHZhbCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2MSA9IGFwcGx5UmV2aXZlcihyZXZpdmVyLCB2YWwsIGssIHYwKTtcbiAgICAgICAgICAgICAgICBpZiAodjEgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHZhbFtrXTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh2MSAhPT0gdjApXG4gICAgICAgICAgICAgICAgICAgIHZhbFtrXSA9IHYxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXZpdmVyLmNhbGwob2JqLCBrZXksIHZhbCk7XG59XG5cbmV4cG9ydCB7IGFwcGx5UmV2aXZlciB9O1xuIiwgImltcG9ydCB7IEFsaWFzIH0gZnJvbSAnLi4vbm9kZXMvQWxpYXMuanMnO1xuaW1wb3J0IHsgaXNFbXB0eVBhdGgsIGNvbGxlY3Rpb25Gcm9tUGF0aCB9IGZyb20gJy4uL25vZGVzL0NvbGxlY3Rpb24uanMnO1xuaW1wb3J0IHsgTk9ERV9UWVBFLCBET0MsIGlzTm9kZSwgaXNDb2xsZWN0aW9uLCBpc1NjYWxhciB9IGZyb20gJy4uL25vZGVzL05vZGUuanMnO1xuaW1wb3J0IHsgUGFpciB9IGZyb20gJy4uL25vZGVzL1BhaXIuanMnO1xuaW1wb3J0IHsgdG9KUyB9IGZyb20gJy4uL25vZGVzL3RvSlMuanMnO1xuaW1wb3J0IHsgZGVmYXVsdE9wdGlvbnMgfSBmcm9tICcuLi9vcHRpb25zLmpzJztcbmltcG9ydCB7IFNjaGVtYSB9IGZyb20gJy4uL3NjaGVtYS9TY2hlbWEuanMnO1xuaW1wb3J0IHsgc3RyaW5naWZ5IH0gZnJvbSAnLi4vc3RyaW5naWZ5L3N0cmluZ2lmeS5qcyc7XG5pbXBvcnQgeyBzdHJpbmdpZnlEb2N1bWVudCB9IGZyb20gJy4uL3N0cmluZ2lmeS9zdHJpbmdpZnlEb2N1bWVudC5qcyc7XG5pbXBvcnQgeyBhbmNob3JOYW1lcywgZmluZE5ld0FuY2hvciwgY3JlYXRlTm9kZUFuY2hvcnMgfSBmcm9tICcuL2FuY2hvcnMuanMnO1xuaW1wb3J0IHsgYXBwbHlSZXZpdmVyIH0gZnJvbSAnLi9hcHBseVJldml2ZXIuanMnO1xuaW1wb3J0IHsgY3JlYXRlTm9kZSB9IGZyb20gJy4vY3JlYXRlTm9kZS5qcyc7XG5pbXBvcnQgeyBEaXJlY3RpdmVzIH0gZnJvbSAnLi9kaXJlY3RpdmVzLmpzJztcblxuY2xhc3MgRG9jdW1lbnQge1xuICAgIGNvbnN0cnVjdG9yKHZhbHVlLCByZXBsYWNlciwgb3B0aW9ucykge1xuICAgICAgICAvKiogQSBjb21tZW50IGJlZm9yZSB0aGlzIERvY3VtZW50ICovXG4gICAgICAgIHRoaXMuY29tbWVudEJlZm9yZSA9IG51bGw7XG4gICAgICAgIC8qKiBBIGNvbW1lbnQgaW1tZWRpYXRlbHkgYWZ0ZXIgdGhpcyBEb2N1bWVudCAqL1xuICAgICAgICB0aGlzLmNvbW1lbnQgPSBudWxsO1xuICAgICAgICAvKiogRXJyb3JzIGVuY291bnRlcmVkIGR1cmluZyBwYXJzaW5nLiAqL1xuICAgICAgICB0aGlzLmVycm9ycyA9IFtdO1xuICAgICAgICAvKiogV2FybmluZ3MgZW5jb3VudGVyZWQgZHVyaW5nIHBhcnNpbmcuICovXG4gICAgICAgIHRoaXMud2FybmluZ3MgPSBbXTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIE5PREVfVFlQRSwgeyB2YWx1ZTogRE9DIH0pO1xuICAgICAgICBsZXQgX3JlcGxhY2VyID0gbnVsbDtcbiAgICAgICAgaWYgKHR5cGVvZiByZXBsYWNlciA9PT0gJ2Z1bmN0aW9uJyB8fCBBcnJheS5pc0FycmF5KHJlcGxhY2VyKSkge1xuICAgICAgICAgICAgX3JlcGxhY2VyID0gcmVwbGFjZXI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3B0aW9ucyA9PT0gdW5kZWZpbmVkICYmIHJlcGxhY2VyKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gcmVwbGFjZXI7XG4gICAgICAgICAgICByZXBsYWNlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvcHQgPSBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0T3B0aW9ucywgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdDtcbiAgICAgICAgbGV0IHsgdmVyc2lvbiB9ID0gb3B0O1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmRpcmVjdGl2ZXMpIHtcbiAgICAgICAgICAgIHRoaXMuZGlyZWN0aXZlcyA9IG9wdGlvbnMuZGlyZWN0aXZlcy5hdERvY3VtZW50KCk7XG4gICAgICAgICAgICBpZiAodGhpcy5kaXJlY3RpdmVzLnlhbWwuZXhwbGljaXQpXG4gICAgICAgICAgICAgICAgdmVyc2lvbiA9IHRoaXMuZGlyZWN0aXZlcy55YW1sLnZlcnNpb247XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy5kaXJlY3RpdmVzID0gbmV3IERpcmVjdGl2ZXMoeyB2ZXJzaW9uIH0pO1xuICAgICAgICB0aGlzLnNldFNjaGVtYSh2ZXJzaW9uLCBvcHRpb25zKTtcbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICB0aGlzLmNvbnRlbnRzID0gbnVsbDtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRlbnRzID0gdGhpcy5jcmVhdGVOb2RlKHZhbHVlLCBfcmVwbGFjZXIsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIGRlZXAgY29weSBvZiB0aGlzIERvY3VtZW50IGFuZCBpdHMgY29udGVudHMuXG4gICAgICpcbiAgICAgKiBDdXN0b20gTm9kZSB2YWx1ZXMgdGhhdCBpbmhlcml0IGZyb20gYE9iamVjdGAgc3RpbGwgcmVmZXIgdG8gdGhlaXIgb3JpZ2luYWwgaW5zdGFuY2VzLlxuICAgICAqL1xuICAgIGNsb25lKCkge1xuICAgICAgICBjb25zdCBjb3B5ID0gT2JqZWN0LmNyZWF0ZShEb2N1bWVudC5wcm90b3R5cGUsIHtcbiAgICAgICAgICAgIFtOT0RFX1RZUEVdOiB7IHZhbHVlOiBET0MgfVxuICAgICAgICB9KTtcbiAgICAgICAgY29weS5jb21tZW50QmVmb3JlID0gdGhpcy5jb21tZW50QmVmb3JlO1xuICAgICAgICBjb3B5LmNvbW1lbnQgPSB0aGlzLmNvbW1lbnQ7XG4gICAgICAgIGNvcHkuZXJyb3JzID0gdGhpcy5lcnJvcnMuc2xpY2UoKTtcbiAgICAgICAgY29weS53YXJuaW5ncyA9IHRoaXMud2FybmluZ3Muc2xpY2UoKTtcbiAgICAgICAgY29weS5vcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5vcHRpb25zKTtcbiAgICAgICAgaWYgKHRoaXMuZGlyZWN0aXZlcylcbiAgICAgICAgICAgIGNvcHkuZGlyZWN0aXZlcyA9IHRoaXMuZGlyZWN0aXZlcy5jbG9uZSgpO1xuICAgICAgICBjb3B5LnNjaGVtYSA9IHRoaXMuc2NoZW1hLmNsb25lKCk7XG4gICAgICAgIGNvcHkuY29udGVudHMgPSBpc05vZGUodGhpcy5jb250ZW50cylcbiAgICAgICAgICAgID8gdGhpcy5jb250ZW50cy5jbG9uZShjb3B5LnNjaGVtYSlcbiAgICAgICAgICAgIDogdGhpcy5jb250ZW50cztcbiAgICAgICAgaWYgKHRoaXMucmFuZ2UpXG4gICAgICAgICAgICBjb3B5LnJhbmdlID0gdGhpcy5yYW5nZS5zbGljZSgpO1xuICAgICAgICByZXR1cm4gY29weTtcbiAgICB9XG4gICAgLyoqIEFkZHMgYSB2YWx1ZSB0byB0aGUgZG9jdW1lbnQuICovXG4gICAgYWRkKHZhbHVlKSB7XG4gICAgICAgIGlmIChhc3NlcnRDb2xsZWN0aW9uKHRoaXMuY29udGVudHMpKVxuICAgICAgICAgICAgdGhpcy5jb250ZW50cy5hZGQodmFsdWUpO1xuICAgIH1cbiAgICAvKiogQWRkcyBhIHZhbHVlIHRvIHRoZSBkb2N1bWVudC4gKi9cbiAgICBhZGRJbihwYXRoLCB2YWx1ZSkge1xuICAgICAgICBpZiAoYXNzZXJ0Q29sbGVjdGlvbih0aGlzLmNvbnRlbnRzKSlcbiAgICAgICAgICAgIHRoaXMuY29udGVudHMuYWRkSW4ocGF0aCwgdmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgYEFsaWFzYCBub2RlLCBlbnN1cmluZyB0aGF0IHRoZSB0YXJnZXQgYG5vZGVgIGhhcyB0aGUgcmVxdWlyZWQgYW5jaG9yLlxuICAgICAqXG4gICAgICogSWYgYG5vZGVgIGFscmVhZHkgaGFzIGFuIGFuY2hvciwgYG5hbWVgIGlzIGlnbm9yZWQuXG4gICAgICogT3RoZXJ3aXNlLCB0aGUgYG5vZGUuYW5jaG9yYCB2YWx1ZSB3aWxsIGJlIHNldCB0byBgbmFtZWAsXG4gICAgICogb3IgaWYgYW4gYW5jaG9yIHdpdGggdGhhdCBuYW1lIGlzIGFscmVhZHkgcHJlc2VudCBpbiB0aGUgZG9jdW1lbnQsXG4gICAgICogYG5hbWVgIHdpbGwgYmUgdXNlZCBhcyBhIHByZWZpeCBmb3IgYSBuZXcgdW5pcXVlIGFuY2hvci5cbiAgICAgKiBJZiBgbmFtZWAgaXMgdW5kZWZpbmVkLCB0aGUgZ2VuZXJhdGVkIGFuY2hvciB3aWxsIHVzZSAnYScgYXMgYSBwcmVmaXguXG4gICAgICovXG4gICAgY3JlYXRlQWxpYXMobm9kZSwgbmFtZSkge1xuICAgICAgICBpZiAoIW5vZGUuYW5jaG9yKSB7XG4gICAgICAgICAgICBjb25zdCBwcmV2ID0gYW5jaG9yTmFtZXModGhpcyk7XG4gICAgICAgICAgICBub2RlLmFuY2hvciA9XG4gICAgICAgICAgICAgICAgIW5hbWUgfHwgcHJldi5oYXMobmFtZSkgPyBmaW5kTmV3QW5jaG9yKG5hbWUgfHwgJ2EnLCBwcmV2KSA6IG5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBBbGlhcyhub2RlLmFuY2hvcik7XG4gICAgfVxuICAgIGNyZWF0ZU5vZGUodmFsdWUsIHJlcGxhY2VyLCBvcHRpb25zKSB7XG4gICAgICAgIGxldCBfcmVwbGFjZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmICh0eXBlb2YgcmVwbGFjZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHZhbHVlID0gcmVwbGFjZXIuY2FsbCh7ICcnOiB2YWx1ZSB9LCAnJywgdmFsdWUpO1xuICAgICAgICAgICAgX3JlcGxhY2VyID0gcmVwbGFjZXI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShyZXBsYWNlcikpIHtcbiAgICAgICAgICAgIGNvbnN0IGtleVRvU3RyID0gKHYpID0+IHR5cGVvZiB2ID09PSAnbnVtYmVyJyB8fCB2IGluc3RhbmNlb2YgU3RyaW5nIHx8IHYgaW5zdGFuY2VvZiBOdW1iZXI7XG4gICAgICAgICAgICBjb25zdCBhc1N0ciA9IHJlcGxhY2VyLmZpbHRlcihrZXlUb1N0cikubWFwKFN0cmluZyk7XG4gICAgICAgICAgICBpZiAoYXNTdHIubGVuZ3RoID4gMClcbiAgICAgICAgICAgICAgICByZXBsYWNlciA9IHJlcGxhY2VyLmNvbmNhdChhc1N0cik7XG4gICAgICAgICAgICBfcmVwbGFjZXIgPSByZXBsYWNlcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvcHRpb25zID09PSB1bmRlZmluZWQgJiYgcmVwbGFjZXIpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSByZXBsYWNlcjtcbiAgICAgICAgICAgIHJlcGxhY2VyID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgYWxpYXNEdXBsaWNhdGVPYmplY3RzLCBhbmNob3JQcmVmaXgsIGZsb3csIGtlZXBVbmRlZmluZWQsIG9uVGFnT2JqLCB0YWcgfSA9IG9wdGlvbnMgfHwge307XG4gICAgICAgIGNvbnN0IHsgb25BbmNob3IsIHNldEFuY2hvcnMsIHNvdXJjZU9iamVjdHMgfSA9IGNyZWF0ZU5vZGVBbmNob3JzKHRoaXMsIGFuY2hvclByZWZpeCB8fCAnYScpO1xuICAgICAgICBjb25zdCBjdHggPSB7XG4gICAgICAgICAgICBhbGlhc0R1cGxpY2F0ZU9iamVjdHM6IGFsaWFzRHVwbGljYXRlT2JqZWN0cyAhPT0gbnVsbCAmJiBhbGlhc0R1cGxpY2F0ZU9iamVjdHMgIT09IHZvaWQgMCA/IGFsaWFzRHVwbGljYXRlT2JqZWN0cyA6IHRydWUsXG4gICAgICAgICAgICBrZWVwVW5kZWZpbmVkOiBrZWVwVW5kZWZpbmVkICE9PSBudWxsICYmIGtlZXBVbmRlZmluZWQgIT09IHZvaWQgMCA/IGtlZXBVbmRlZmluZWQgOiBmYWxzZSxcbiAgICAgICAgICAgIG9uQW5jaG9yLFxuICAgICAgICAgICAgb25UYWdPYmosXG4gICAgICAgICAgICByZXBsYWNlcjogX3JlcGxhY2VyLFxuICAgICAgICAgICAgc2NoZW1hOiB0aGlzLnNjaGVtYSxcbiAgICAgICAgICAgIHNvdXJjZU9iamVjdHNcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgbm9kZSA9IGNyZWF0ZU5vZGUodmFsdWUsIHRhZywgY3R4KTtcbiAgICAgICAgaWYgKGZsb3cgJiYgaXNDb2xsZWN0aW9uKG5vZGUpKVxuICAgICAgICAgICAgbm9kZS5mbG93ID0gdHJ1ZTtcbiAgICAgICAgc2V0QW5jaG9ycygpO1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydCBhIGtleSBhbmQgYSB2YWx1ZSBpbnRvIGEgYFBhaXJgIHVzaW5nIHRoZSBjdXJyZW50IHNjaGVtYSxcbiAgICAgKiByZWN1cnNpdmVseSB3cmFwcGluZyBhbGwgdmFsdWVzIGFzIGBTY2FsYXJgIG9yIGBDb2xsZWN0aW9uYCBub2Rlcy5cbiAgICAgKi9cbiAgICBjcmVhdGVQYWlyKGtleSwgdmFsdWUsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBjb25zdCBrID0gdGhpcy5jcmVhdGVOb2RlKGtleSwgbnVsbCwgb3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IHYgPSB0aGlzLmNyZWF0ZU5vZGUodmFsdWUsIG51bGwsIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gbmV3IFBhaXIoaywgdik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYSB2YWx1ZSBmcm9tIHRoZSBkb2N1bWVudC5cbiAgICAgKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGl0ZW0gd2FzIGZvdW5kIGFuZCByZW1vdmVkLlxuICAgICAqL1xuICAgIGRlbGV0ZShrZXkpIHtcbiAgICAgICAgcmV0dXJuIGFzc2VydENvbGxlY3Rpb24odGhpcy5jb250ZW50cykgPyB0aGlzLmNvbnRlbnRzLmRlbGV0ZShrZXkpIDogZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYSB2YWx1ZSBmcm9tIHRoZSBkb2N1bWVudC5cbiAgICAgKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGl0ZW0gd2FzIGZvdW5kIGFuZCByZW1vdmVkLlxuICAgICAqL1xuICAgIGRlbGV0ZUluKHBhdGgpIHtcbiAgICAgICAgaWYgKGlzRW1wdHlQYXRoKHBhdGgpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jb250ZW50cyA9PSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuY29udGVudHMgPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFzc2VydENvbGxlY3Rpb24odGhpcy5jb250ZW50cylcbiAgICAgICAgICAgID8gdGhpcy5jb250ZW50cy5kZWxldGVJbihwYXRoKVxuICAgICAgICAgICAgOiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBpdGVtIGF0IGBrZXlgLCBvciBgdW5kZWZpbmVkYCBpZiBub3QgZm91bmQuIEJ5IGRlZmF1bHQgdW53cmFwc1xuICAgICAqIHNjYWxhciB2YWx1ZXMgZnJvbSB0aGVpciBzdXJyb3VuZGluZyBub2RlOyB0byBkaXNhYmxlIHNldCBga2VlcFNjYWxhcmAgdG9cbiAgICAgKiBgdHJ1ZWAgKGNvbGxlY3Rpb25zIGFyZSBhbHdheXMgcmV0dXJuZWQgaW50YWN0KS5cbiAgICAgKi9cbiAgICBnZXQoa2V5LCBrZWVwU2NhbGFyKSB7XG4gICAgICAgIHJldHVybiBpc0NvbGxlY3Rpb24odGhpcy5jb250ZW50cylcbiAgICAgICAgICAgID8gdGhpcy5jb250ZW50cy5nZXQoa2V5LCBrZWVwU2NhbGFyKVxuICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgaXRlbSBhdCBgcGF0aGAsIG9yIGB1bmRlZmluZWRgIGlmIG5vdCBmb3VuZC4gQnkgZGVmYXVsdCB1bndyYXBzXG4gICAgICogc2NhbGFyIHZhbHVlcyBmcm9tIHRoZWlyIHN1cnJvdW5kaW5nIG5vZGU7IHRvIGRpc2FibGUgc2V0IGBrZWVwU2NhbGFyYCB0b1xuICAgICAqIGB0cnVlYCAoY29sbGVjdGlvbnMgYXJlIGFsd2F5cyByZXR1cm5lZCBpbnRhY3QpLlxuICAgICAqL1xuICAgIGdldEluKHBhdGgsIGtlZXBTY2FsYXIpIHtcbiAgICAgICAgaWYgKGlzRW1wdHlQYXRoKHBhdGgpKVxuICAgICAgICAgICAgcmV0dXJuICFrZWVwU2NhbGFyICYmIGlzU2NhbGFyKHRoaXMuY29udGVudHMpXG4gICAgICAgICAgICAgICAgPyB0aGlzLmNvbnRlbnRzLnZhbHVlXG4gICAgICAgICAgICAgICAgOiB0aGlzLmNvbnRlbnRzO1xuICAgICAgICByZXR1cm4gaXNDb2xsZWN0aW9uKHRoaXMuY29udGVudHMpXG4gICAgICAgICAgICA/IHRoaXMuY29udGVudHMuZ2V0SW4ocGF0aCwga2VlcFNjYWxhcilcbiAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGhlIGRvY3VtZW50IGluY2x1ZGVzIGEgdmFsdWUgd2l0aCB0aGUga2V5IGBrZXlgLlxuICAgICAqL1xuICAgIGhhcyhrZXkpIHtcbiAgICAgICAgcmV0dXJuIGlzQ29sbGVjdGlvbih0aGlzLmNvbnRlbnRzKSA/IHRoaXMuY29udGVudHMuaGFzKGtleSkgOiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHRoZSBkb2N1bWVudCBpbmNsdWRlcyBhIHZhbHVlIGF0IGBwYXRoYC5cbiAgICAgKi9cbiAgICBoYXNJbihwYXRoKSB7XG4gICAgICAgIGlmIChpc0VtcHR5UGF0aChwYXRoKSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnRlbnRzICE9PSB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiBpc0NvbGxlY3Rpb24odGhpcy5jb250ZW50cykgPyB0aGlzLmNvbnRlbnRzLmhhc0luKHBhdGgpIDogZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgYSB2YWx1ZSBpbiB0aGlzIGRvY3VtZW50LiBGb3IgYCEhc2V0YCwgYHZhbHVlYCBuZWVkcyB0byBiZSBhXG4gICAgICogYm9vbGVhbiB0byBhZGQvcmVtb3ZlIHRoZSBpdGVtIGZyb20gdGhlIHNldC5cbiAgICAgKi9cbiAgICBzZXQoa2V5LCB2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5jb250ZW50cyA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRlbnRzID0gY29sbGVjdGlvbkZyb21QYXRoKHRoaXMuc2NoZW1hLCBba2V5XSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFzc2VydENvbGxlY3Rpb24odGhpcy5jb250ZW50cykpIHtcbiAgICAgICAgICAgIHRoaXMuY29udGVudHMuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgYSB2YWx1ZSBpbiB0aGlzIGRvY3VtZW50LiBGb3IgYCEhc2V0YCwgYHZhbHVlYCBuZWVkcyB0byBiZSBhXG4gICAgICogYm9vbGVhbiB0byBhZGQvcmVtb3ZlIHRoZSBpdGVtIGZyb20gdGhlIHNldC5cbiAgICAgKi9cbiAgICBzZXRJbihwYXRoLCB2YWx1ZSkge1xuICAgICAgICBpZiAoaXNFbXB0eVBhdGgocGF0aCkpXG4gICAgICAgICAgICB0aGlzLmNvbnRlbnRzID0gdmFsdWU7XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuY29udGVudHMgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5jb250ZW50cyA9IGNvbGxlY3Rpb25Gcm9tUGF0aCh0aGlzLnNjaGVtYSwgQXJyYXkuZnJvbShwYXRoKSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFzc2VydENvbGxlY3Rpb24odGhpcy5jb250ZW50cykpIHtcbiAgICAgICAgICAgIHRoaXMuY29udGVudHMuc2V0SW4ocGF0aCwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoYW5nZSB0aGUgWUFNTCB2ZXJzaW9uIGFuZCBzY2hlbWEgdXNlZCBieSB0aGUgZG9jdW1lbnQuXG4gICAgICogQSBgbnVsbGAgdmVyc2lvbiBkaXNhYmxlcyBzdXBwb3J0IGZvciBkaXJlY3RpdmVzLCBleHBsaWNpdCB0YWdzLCBhbmNob3JzLCBhbmQgYWxpYXNlcy5cbiAgICAgKiBJdCBhbHNvIHJlcXVpcmVzIHRoZSBgc2NoZW1hYCBvcHRpb24gdG8gYmUgZ2l2ZW4gYXMgYSBgU2NoZW1hYCBpbnN0YW5jZSB2YWx1ZS5cbiAgICAgKlxuICAgICAqIE92ZXJyaWRlcyBhbGwgcHJldmlvdXNseSBzZXQgc2NoZW1hIG9wdGlvbnMuXG4gICAgICovXG4gICAgc2V0U2NoZW1hKHZlcnNpb24sIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBpZiAodHlwZW9mIHZlcnNpb24gPT09ICdudW1iZXInKVxuICAgICAgICAgICAgdmVyc2lvbiA9IFN0cmluZyh2ZXJzaW9uKTtcbiAgICAgICAgbGV0IG9wdDtcbiAgICAgICAgc3dpdGNoICh2ZXJzaW9uKSB7XG4gICAgICAgICAgICBjYXNlICcxLjEnOlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmRpcmVjdGl2ZXMpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlyZWN0aXZlcy55YW1sLnZlcnNpb24gPSAnMS4xJztcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlyZWN0aXZlcyA9IG5ldyBEaXJlY3RpdmVzKHsgdmVyc2lvbjogJzEuMScgfSk7XG4gICAgICAgICAgICAgICAgb3B0ID0geyBtZXJnZTogdHJ1ZSwgcmVzb2x2ZUtub3duVGFnczogZmFsc2UsIHNjaGVtYTogJ3lhbWwtMS4xJyB9O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnMS4yJzpcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5kaXJlY3RpdmVzKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpcmVjdGl2ZXMueWFtbC52ZXJzaW9uID0gJzEuMic7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpcmVjdGl2ZXMgPSBuZXcgRGlyZWN0aXZlcyh7IHZlcnNpb246ICcxLjInIH0pO1xuICAgICAgICAgICAgICAgIG9wdCA9IHsgbWVyZ2U6IGZhbHNlLCByZXNvbHZlS25vd25UYWdzOiB0cnVlLCBzY2hlbWE6ICdjb3JlJyB9O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBudWxsOlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmRpcmVjdGl2ZXMpXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmRpcmVjdGl2ZXM7XG4gICAgICAgICAgICAgICAgb3B0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdiA9IEpTT04uc3RyaW5naWZ5KHZlcnNpb24pO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgJzEuMScsICcxLjInIG9yIG51bGwgYXMgZmlyc3QgYXJndW1lbnQsIGJ1dCBmb3VuZDogJHtzdn1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBOb3QgdXNpbmcgYGluc3RhbmNlb2YgU2NoZW1hYCB0byBhbGxvdyBmb3IgZHVjayB0eXBpbmdcbiAgICAgICAgaWYgKG9wdGlvbnMuc2NoZW1hIGluc3RhbmNlb2YgT2JqZWN0KVxuICAgICAgICAgICAgdGhpcy5zY2hlbWEgPSBvcHRpb25zLnNjaGVtYTtcbiAgICAgICAgZWxzZSBpZiAob3B0KVxuICAgICAgICAgICAgdGhpcy5zY2hlbWEgPSBuZXcgU2NoZW1hKE9iamVjdC5hc3NpZ24ob3B0LCBvcHRpb25zKSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgV2l0aCBhIG51bGwgWUFNTCB2ZXJzaW9uLCB0aGUgeyBzY2hlbWE6IFNjaGVtYSB9IG9wdGlvbiBpcyByZXF1aXJlZGApO1xuICAgIH1cbiAgICAvLyBqc29uICYganNvbkFyZyBhcmUgb25seSB1c2VkIGZyb20gdG9KU09OKClcbiAgICB0b0pTKHsganNvbiwganNvbkFyZywgbWFwQXNNYXAsIG1heEFsaWFzQ291bnQsIG9uQW5jaG9yLCByZXZpdmVyIH0gPSB7fSkge1xuICAgICAgICBjb25zdCBjdHggPSB7XG4gICAgICAgICAgICBhbmNob3JzOiBuZXcgTWFwKCksXG4gICAgICAgICAgICBkb2M6IHRoaXMsXG4gICAgICAgICAgICBrZWVwOiAhanNvbixcbiAgICAgICAgICAgIG1hcEFzTWFwOiBtYXBBc01hcCA9PT0gdHJ1ZSxcbiAgICAgICAgICAgIG1hcEtleVdhcm5lZDogZmFsc2UsXG4gICAgICAgICAgICBtYXhBbGlhc0NvdW50OiB0eXBlb2YgbWF4QWxpYXNDb3VudCA9PT0gJ251bWJlcicgPyBtYXhBbGlhc0NvdW50IDogMTAwLFxuICAgICAgICAgICAgc3RyaW5naWZ5XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlcyA9IHRvSlModGhpcy5jb250ZW50cywganNvbkFyZyB8fCAnJywgY3R4KTtcbiAgICAgICAgaWYgKHR5cGVvZiBvbkFuY2hvciA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgIGZvciAoY29uc3QgeyBjb3VudCwgcmVzIH0gb2YgY3R4LmFuY2hvcnMudmFsdWVzKCkpXG4gICAgICAgICAgICAgICAgb25BbmNob3IocmVzLCBjb3VudCk7XG4gICAgICAgIHJldHVybiB0eXBlb2YgcmV2aXZlciA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgPyBhcHBseVJldml2ZXIocmV2aXZlciwgeyAnJzogcmVzIH0sICcnLCByZXMpXG4gICAgICAgICAgICA6IHJlcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBKU09OIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBkb2N1bWVudCBgY29udGVudHNgLlxuICAgICAqXG4gICAgICogQHBhcmFtIGpzb25BcmcgVXNlZCBieSBgSlNPTi5zdHJpbmdpZnlgIHRvIGluZGljYXRlIHRoZSBhcnJheSBpbmRleCBvclxuICAgICAqICAgcHJvcGVydHkgbmFtZS5cbiAgICAgKi9cbiAgICB0b0pTT04oanNvbkFyZywgb25BbmNob3IpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9KUyh7IGpzb246IHRydWUsIGpzb25BcmcsIG1hcEFzTWFwOiBmYWxzZSwgb25BbmNob3IgfSk7XG4gICAgfVxuICAgIC8qKiBBIFlBTUwgcmVwcmVzZW50YXRpb24gb2YgdGhlIGRvY3VtZW50LiAqL1xuICAgIHRvU3RyaW5nKG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBpZiAodGhpcy5lcnJvcnMubGVuZ3RoID4gMClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRG9jdW1lbnQgd2l0aCBlcnJvcnMgY2Fubm90IGJlIHN0cmluZ2lmaWVkJyk7XG4gICAgICAgIGlmICgnaW5kZW50JyBpbiBvcHRpb25zICYmXG4gICAgICAgICAgICAoIU51bWJlci5pc0ludGVnZXIob3B0aW9ucy5pbmRlbnQpIHx8IE51bWJlcihvcHRpb25zLmluZGVudCkgPD0gMCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHMgPSBKU09OLnN0cmluZ2lmeShvcHRpb25zLmluZGVudCk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFwiaW5kZW50XCIgb3B0aW9uIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyLCBub3QgJHtzfWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHJpbmdpZnlEb2N1bWVudCh0aGlzLCBvcHRpb25zKTtcbiAgICB9XG59XG5mdW5jdGlvbiBhc3NlcnRDb2xsZWN0aW9uKGNvbnRlbnRzKSB7XG4gICAgaWYgKGlzQ29sbGVjdGlvbihjb250ZW50cykpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgYSBZQU1MIGNvbGxlY3Rpb24gYXMgZG9jdW1lbnQgY29udGVudHMnKTtcbn1cblxuZXhwb3J0IHsgRG9jdW1lbnQgfTtcbiIsICJjbGFzcyBZQU1MRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IobmFtZSwgcG9zLCBjb2RlLCBtZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgICAgIHRoaXMucG9zID0gcG9zO1xuICAgIH1cbn1cbmNsYXNzIFlBTUxQYXJzZUVycm9yIGV4dGVuZHMgWUFNTEVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcihwb3MsIGNvZGUsIG1lc3NhZ2UpIHtcbiAgICAgICAgc3VwZXIoJ1lBTUxQYXJzZUVycm9yJywgcG9zLCBjb2RlLCBtZXNzYWdlKTtcbiAgICB9XG59XG5jbGFzcyBZQU1MV2FybmluZyBleHRlbmRzIFlBTUxFcnJvciB7XG4gICAgY29uc3RydWN0b3IocG9zLCBjb2RlLCBtZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyKCdZQU1MV2FybmluZycsIHBvcywgY29kZSwgbWVzc2FnZSk7XG4gICAgfVxufVxuY29uc3QgcHJldHRpZnlFcnJvciA9IChzcmMsIGxjKSA9PiAoZXJyb3IpID0+IHtcbiAgICBpZiAoZXJyb3IucG9zWzBdID09PSAtMSlcbiAgICAgICAgcmV0dXJuO1xuICAgIGVycm9yLmxpbmVQb3MgPSBlcnJvci5wb3MubWFwKHBvcyA9PiBsYy5saW5lUG9zKHBvcykpO1xuICAgIGNvbnN0IHsgbGluZSwgY29sIH0gPSBlcnJvci5saW5lUG9zWzBdO1xuICAgIGVycm9yLm1lc3NhZ2UgKz0gYCBhdCBsaW5lICR7bGluZX0sIGNvbHVtbiAke2NvbH1gO1xuICAgIGxldCBjaSA9IGNvbCAtIDE7XG4gICAgbGV0IGxpbmVTdHIgPSBzcmNcbiAgICAgICAgLnN1YnN0cmluZyhsYy5saW5lU3RhcnRzW2xpbmUgLSAxXSwgbGMubGluZVN0YXJ0c1tsaW5lXSlcbiAgICAgICAgLnJlcGxhY2UoL1tcXG5cXHJdKyQvLCAnJyk7XG4gICAgLy8gVHJpbSB0byBtYXggODAgY2hhcnMsIGtlZXBpbmcgY29sIHBvc2l0aW9uIG5lYXIgdGhlIG1pZGRsZVxuICAgIGlmIChjaSA+PSA2MCAmJiBsaW5lU3RyLmxlbmd0aCA+IDgwKSB7XG4gICAgICAgIGNvbnN0IHRyaW1TdGFydCA9IE1hdGgubWluKGNpIC0gMzksIGxpbmVTdHIubGVuZ3RoIC0gNzkpO1xuICAgICAgICBsaW5lU3RyID0gJ1x1MjAyNicgKyBsaW5lU3RyLnN1YnN0cmluZyh0cmltU3RhcnQpO1xuICAgICAgICBjaSAtPSB0cmltU3RhcnQgLSAxO1xuICAgIH1cbiAgICBpZiAobGluZVN0ci5sZW5ndGggPiA4MClcbiAgICAgICAgbGluZVN0ciA9IGxpbmVTdHIuc3Vic3RyaW5nKDAsIDc5KSArICdcdTIwMjYnO1xuICAgIC8vIEluY2x1ZGUgcHJldmlvdXMgbGluZSBpbiBjb250ZXh0IGlmIHBvaW50aW5nIGF0IGxpbmUgc3RhcnRcbiAgICBpZiAobGluZSA+IDEgJiYgL14gKiQvLnRlc3QobGluZVN0ci5zdWJzdHJpbmcoMCwgY2kpKSkge1xuICAgICAgICAvLyBSZWdleHAgd29uJ3QgbWF0Y2ggaWYgc3RhcnQgaXMgdHJpbW1lZFxuICAgICAgICBsZXQgcHJldiA9IHNyYy5zdWJzdHJpbmcobGMubGluZVN0YXJ0c1tsaW5lIC0gMl0sIGxjLmxpbmVTdGFydHNbbGluZSAtIDFdKTtcbiAgICAgICAgaWYgKHByZXYubGVuZ3RoID4gODApXG4gICAgICAgICAgICBwcmV2ID0gcHJldi5zdWJzdHJpbmcoMCwgNzkpICsgJ1x1MjAyNlxcbic7XG4gICAgICAgIGxpbmVTdHIgPSBwcmV2ICsgbGluZVN0cjtcbiAgICB9XG4gICAgaWYgKC9bXiBdLy50ZXN0KGxpbmVTdHIpKSB7XG4gICAgICAgIGxldCBjb3VudCA9IDE7XG4gICAgICAgIGNvbnN0IGVuZCA9IGVycm9yLmxpbmVQb3NbMV07XG4gICAgICAgIGlmIChlbmQgJiYgZW5kLmxpbmUgPT09IGxpbmUgJiYgZW5kLmNvbCA+IGNvbCkge1xuICAgICAgICAgICAgY291bnQgPSBNYXRoLm1pbihlbmQuY29sIC0gY29sLCA4MCAtIGNpKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwb2ludGVyID0gJyAnLnJlcGVhdChjaSkgKyAnXicucmVwZWF0KGNvdW50KTtcbiAgICAgICAgZXJyb3IubWVzc2FnZSArPSBgOlxcblxcbiR7bGluZVN0cn1cXG4ke3BvaW50ZXJ9XFxuYDtcbiAgICB9XG59O1xuXG5leHBvcnQgeyBZQU1MRXJyb3IsIFlBTUxQYXJzZUVycm9yLCBZQU1MV2FybmluZywgcHJldHRpZnlFcnJvciB9O1xuIiwgImZ1bmN0aW9uIHJlc29sdmVQcm9wcyh0b2tlbnMsIHsgZmxvdywgaW5kaWNhdG9yLCBuZXh0LCBvZmZzZXQsIG9uRXJyb3IsIHN0YXJ0T25OZXdsaW5lIH0pIHtcbiAgICBsZXQgc3BhY2VCZWZvcmUgPSBmYWxzZTtcbiAgICBsZXQgYXROZXdsaW5lID0gc3RhcnRPbk5ld2xpbmU7XG4gICAgbGV0IGhhc1NwYWNlID0gc3RhcnRPbk5ld2xpbmU7XG4gICAgbGV0IGNvbW1lbnQgPSAnJztcbiAgICBsZXQgY29tbWVudFNlcCA9ICcnO1xuICAgIGxldCBoYXNOZXdsaW5lID0gZmFsc2U7XG4gICAgbGV0IHJlcVNwYWNlID0gZmFsc2U7XG4gICAgbGV0IGFuY2hvciA9IG51bGw7XG4gICAgbGV0IHRhZyA9IG51bGw7XG4gICAgbGV0IGNvbW1hID0gbnVsbDtcbiAgICBsZXQgZm91bmQgPSBudWxsO1xuICAgIGxldCBzdGFydCA9IG51bGw7XG4gICAgZm9yIChjb25zdCB0b2tlbiBvZiB0b2tlbnMpIHtcbiAgICAgICAgaWYgKHJlcVNwYWNlKSB7XG4gICAgICAgICAgICBpZiAodG9rZW4udHlwZSAhPT0gJ3NwYWNlJyAmJlxuICAgICAgICAgICAgICAgIHRva2VuLnR5cGUgIT09ICduZXdsaW5lJyAmJlxuICAgICAgICAgICAgICAgIHRva2VuLnR5cGUgIT09ICdjb21tYScpXG4gICAgICAgICAgICAgICAgb25FcnJvcih0b2tlbi5vZmZzZXQsICdNSVNTSU5HX0NIQVInLCAnVGFncyBhbmQgYW5jaG9ycyBtdXN0IGJlIHNlcGFyYXRlZCBmcm9tIHRoZSBuZXh0IHRva2VuIGJ5IHdoaXRlIHNwYWNlJyk7XG4gICAgICAgICAgICByZXFTcGFjZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAodG9rZW4udHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnc3BhY2UnOlxuICAgICAgICAgICAgICAgIC8vIEF0IHRoZSBkb2MgbGV2ZWwsIHRhYnMgYXQgbGluZSBzdGFydCBtYXkgYmUgcGFyc2VkXG4gICAgICAgICAgICAgICAgLy8gYXMgbGVhZGluZyB3aGl0ZSBzcGFjZSByYXRoZXIgdGhhbiBpbmRlbnRhdGlvbi5cbiAgICAgICAgICAgICAgICAvLyBJbiBhIGZsb3cgY29sbGVjdGlvbiwgb25seSB0aGUgcGFyc2VyIGhhbmRsZXMgaW5kZW50LlxuICAgICAgICAgICAgICAgIGlmICghZmxvdyAmJlxuICAgICAgICAgICAgICAgICAgICBhdE5ld2xpbmUgJiZcbiAgICAgICAgICAgICAgICAgICAgaW5kaWNhdG9yICE9PSAnZG9jLXN0YXJ0JyAmJlxuICAgICAgICAgICAgICAgICAgICB0b2tlbi5zb3VyY2VbMF0gPT09ICdcXHQnKVxuICAgICAgICAgICAgICAgICAgICBvbkVycm9yKHRva2VuLCAnVEFCX0FTX0lOREVOVCcsICdUYWJzIGFyZSBub3QgYWxsb3dlZCBhcyBpbmRlbnRhdGlvbicpO1xuICAgICAgICAgICAgICAgIGhhc1NwYWNlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2NvbW1lbnQnOiB7XG4gICAgICAgICAgICAgICAgaWYgKCFoYXNTcGFjZSlcbiAgICAgICAgICAgICAgICAgICAgb25FcnJvcih0b2tlbiwgJ01JU1NJTkdfQ0hBUicsICdDb21tZW50cyBtdXN0IGJlIHNlcGFyYXRlZCBmcm9tIG90aGVyIHRva2VucyBieSB3aGl0ZSBzcGFjZSBjaGFyYWN0ZXJzJyk7XG4gICAgICAgICAgICAgICAgY29uc3QgY2IgPSB0b2tlbi5zb3VyY2Uuc3Vic3RyaW5nKDEpIHx8ICcgJztcbiAgICAgICAgICAgICAgICBpZiAoIWNvbW1lbnQpXG4gICAgICAgICAgICAgICAgICAgIGNvbW1lbnQgPSBjYjtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGNvbW1lbnQgKz0gY29tbWVudFNlcCArIGNiO1xuICAgICAgICAgICAgICAgIGNvbW1lbnRTZXAgPSAnJztcbiAgICAgICAgICAgICAgICBhdE5ld2xpbmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ25ld2xpbmUnOlxuICAgICAgICAgICAgICAgIGlmIChhdE5ld2xpbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbW1lbnQpXG4gICAgICAgICAgICAgICAgICAgICAgICBjb21tZW50ICs9IHRva2VuLnNvdXJjZTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgc3BhY2VCZWZvcmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGNvbW1lbnRTZXAgKz0gdG9rZW4uc291cmNlO1xuICAgICAgICAgICAgICAgIGF0TmV3bGluZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgaGFzTmV3bGluZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgaGFzU3BhY2UgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnYW5jaG9yJzpcbiAgICAgICAgICAgICAgICBpZiAoYW5jaG9yKVxuICAgICAgICAgICAgICAgICAgICBvbkVycm9yKHRva2VuLCAnTVVMVElQTEVfQU5DSE9SUycsICdBIG5vZGUgY2FuIGhhdmUgYXQgbW9zdCBvbmUgYW5jaG9yJyk7XG4gICAgICAgICAgICAgICAgYW5jaG9yID0gdG9rZW47XG4gICAgICAgICAgICAgICAgaWYgKHN0YXJ0ID09PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICBzdGFydCA9IHRva2VuLm9mZnNldDtcbiAgICAgICAgICAgICAgICBhdE5ld2xpbmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBoYXNTcGFjZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHJlcVNwYWNlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3RhZyc6IHtcbiAgICAgICAgICAgICAgICBpZiAodGFnKVxuICAgICAgICAgICAgICAgICAgICBvbkVycm9yKHRva2VuLCAnTVVMVElQTEVfVEFHUycsICdBIG5vZGUgY2FuIGhhdmUgYXQgbW9zdCBvbmUgdGFnJyk7XG4gICAgICAgICAgICAgICAgdGFnID0gdG9rZW47XG4gICAgICAgICAgICAgICAgaWYgKHN0YXJ0ID09PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICBzdGFydCA9IHRva2VuLm9mZnNldDtcbiAgICAgICAgICAgICAgICBhdE5ld2xpbmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBoYXNTcGFjZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHJlcVNwYWNlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgaW5kaWNhdG9yOlxuICAgICAgICAgICAgICAgIC8vIENvdWxkIGhlcmUgaGFuZGxlIHByZWNlZGluZyBjb21tZW50cyBkaWZmZXJlbnRseVxuICAgICAgICAgICAgICAgIGlmIChhbmNob3IgfHwgdGFnKVxuICAgICAgICAgICAgICAgICAgICBvbkVycm9yKHRva2VuLCAnQkFEX1BST1BfT1JERVInLCBgQW5jaG9ycyBhbmQgdGFncyBtdXN0IGJlIGFmdGVyIHRoZSAke3Rva2VuLnNvdXJjZX0gaW5kaWNhdG9yYCk7XG4gICAgICAgICAgICAgICAgaWYgKGZvdW5kKVxuICAgICAgICAgICAgICAgICAgICBvbkVycm9yKHRva2VuLCAnVU5FWFBFQ1RFRF9UT0tFTicsIGBVbmV4cGVjdGVkICR7dG9rZW4uc291cmNlfSBpbiAke2Zsb3cgfHwgJ2NvbGxlY3Rpb24nfWApO1xuICAgICAgICAgICAgICAgIGZvdW5kID0gdG9rZW47XG4gICAgICAgICAgICAgICAgYXROZXdsaW5lID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaGFzU3BhY2UgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2NvbW1hJzpcbiAgICAgICAgICAgICAgICBpZiAoZmxvdykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29tbWEpXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkVycm9yKHRva2VuLCAnVU5FWFBFQ1RFRF9UT0tFTicsIGBVbmV4cGVjdGVkICwgaW4gJHtmbG93fWApO1xuICAgICAgICAgICAgICAgICAgICBjb21tYSA9IHRva2VuO1xuICAgICAgICAgICAgICAgICAgICBhdE5ld2xpbmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgaGFzU3BhY2UgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZWxzZSBmYWxsdGhyb3VnaFxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBvbkVycm9yKHRva2VuLCAnVU5FWFBFQ1RFRF9UT0tFTicsIGBVbmV4cGVjdGVkICR7dG9rZW4udHlwZX0gdG9rZW5gKTtcbiAgICAgICAgICAgICAgICBhdE5ld2xpbmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBoYXNTcGFjZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGxhc3QgPSB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdO1xuICAgIGNvbnN0IGVuZCA9IGxhc3QgPyBsYXN0Lm9mZnNldCArIGxhc3Quc291cmNlLmxlbmd0aCA6IG9mZnNldDtcbiAgICBpZiAocmVxU3BhY2UgJiZcbiAgICAgICAgbmV4dCAmJlxuICAgICAgICBuZXh0LnR5cGUgIT09ICdzcGFjZScgJiZcbiAgICAgICAgbmV4dC50eXBlICE9PSAnbmV3bGluZScgJiZcbiAgICAgICAgbmV4dC50eXBlICE9PSAnY29tbWEnICYmXG4gICAgICAgIChuZXh0LnR5cGUgIT09ICdzY2FsYXInIHx8IG5leHQuc291cmNlICE9PSAnJykpXG4gICAgICAgIG9uRXJyb3IobmV4dC5vZmZzZXQsICdNSVNTSU5HX0NIQVInLCAnVGFncyBhbmQgYW5jaG9ycyBtdXN0IGJlIHNlcGFyYXRlZCBmcm9tIHRoZSBuZXh0IHRva2VuIGJ5IHdoaXRlIHNwYWNlJyk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY29tbWEsXG4gICAgICAgIGZvdW5kLFxuICAgICAgICBzcGFjZUJlZm9yZSxcbiAgICAgICAgY29tbWVudCxcbiAgICAgICAgaGFzTmV3bGluZSxcbiAgICAgICAgYW5jaG9yLFxuICAgICAgICB0YWcsXG4gICAgICAgIGVuZCxcbiAgICAgICAgc3RhcnQ6IHN0YXJ0ICE9PSBudWxsICYmIHN0YXJ0ICE9PSB2b2lkIDAgPyBzdGFydCA6IGVuZFxuICAgIH07XG59XG5cbmV4cG9ydCB7IHJlc29sdmVQcm9wcyB9O1xuIiwgImZ1bmN0aW9uIGNvbnRhaW5zTmV3bGluZShrZXkpIHtcbiAgICBpZiAoIWtleSlcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgc3dpdGNoIChrZXkudHlwZSkge1xuICAgICAgICBjYXNlICdhbGlhcyc6XG4gICAgICAgIGNhc2UgJ3NjYWxhcic6XG4gICAgICAgIGNhc2UgJ2RvdWJsZS1xdW90ZWQtc2NhbGFyJzpcbiAgICAgICAgY2FzZSAnc2luZ2xlLXF1b3RlZC1zY2FsYXInOlxuICAgICAgICAgICAgaWYgKGtleS5zb3VyY2UuaW5jbHVkZXMoJ1xcbicpKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgaWYgKGtleS5lbmQpXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBzdCBvZiBrZXkuZW5kKVxuICAgICAgICAgICAgICAgICAgICBpZiAoc3QudHlwZSA9PT0gJ25ld2xpbmUnKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGNhc2UgJ2Zsb3ctY29sbGVjdGlvbic6XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGl0IG9mIGtleS5pdGVtcykge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qgc3Qgb2YgaXQuc3RhcnQpXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdC50eXBlID09PSAnbmV3bGluZScpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAoaXQuc2VwKVxuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHN0IG9mIGl0LnNlcClcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdC50eXBlID09PSAnbmV3bGluZScpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKGNvbnRhaW5zTmV3bGluZShpdC5rZXkpIHx8IGNvbnRhaW5zTmV3bGluZShpdC52YWx1ZSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufVxuXG5leHBvcnQgeyBjb250YWluc05ld2xpbmUgfTtcbiIsICJpbXBvcnQgeyBjb250YWluc05ld2xpbmUgfSBmcm9tICcuL3V0aWwtY29udGFpbnMtbmV3bGluZS5qcyc7XG5cbmZ1bmN0aW9uIGZsb3dJbmRlbnRDaGVjayhpbmRlbnQsIGZjLCBvbkVycm9yKSB7XG4gICAgaWYgKChmYyA9PT0gbnVsbCB8fCBmYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZmMudHlwZSkgPT09ICdmbG93LWNvbGxlY3Rpb24nKSB7XG4gICAgICAgIGNvbnN0IGVuZCA9IGZjLmVuZFswXTtcbiAgICAgICAgaWYgKGVuZC5pbmRlbnQgPT09IGluZGVudCAmJlxuICAgICAgICAgICAgKGVuZC5zb3VyY2UgPT09ICddJyB8fCBlbmQuc291cmNlID09PSAnfScpICYmXG4gICAgICAgICAgICBjb250YWluc05ld2xpbmUoZmMpKSB7XG4gICAgICAgICAgICBjb25zdCBtc2cgPSAnRmxvdyBlbmQgaW5kaWNhdG9yIHNob3VsZCBiZSBtb3JlIGluZGVudGVkIHRoYW4gcGFyZW50JztcbiAgICAgICAgICAgIG9uRXJyb3IoZW5kLCAnQkFEX0lOREVOVCcsIG1zZywgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCB7IGZsb3dJbmRlbnRDaGVjayB9O1xuIiwgImltcG9ydCB7IGlzU2NhbGFyIH0gZnJvbSAnLi4vbm9kZXMvTm9kZS5qcyc7XG5cbmZ1bmN0aW9uIG1hcEluY2x1ZGVzKGN0eCwgaXRlbXMsIHNlYXJjaCkge1xuICAgIGNvbnN0IHsgdW5pcXVlS2V5cyB9ID0gY3R4Lm9wdGlvbnM7XG4gICAgaWYgKHVuaXF1ZUtleXMgPT09IGZhbHNlKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgY29uc3QgaXNFcXVhbCA9IHR5cGVvZiB1bmlxdWVLZXlzID09PSAnZnVuY3Rpb24nXG4gICAgICAgID8gdW5pcXVlS2V5c1xuICAgICAgICA6IChhLCBiKSA9PiBhID09PSBiIHx8XG4gICAgICAgICAgICAoaXNTY2FsYXIoYSkgJiZcbiAgICAgICAgICAgICAgICBpc1NjYWxhcihiKSAmJlxuICAgICAgICAgICAgICAgIGEudmFsdWUgPT09IGIudmFsdWUgJiZcbiAgICAgICAgICAgICAgICAhKGEudmFsdWUgPT09ICc8PCcgJiYgY3R4LnNjaGVtYS5tZXJnZSkpO1xuICAgIHJldHVybiBpdGVtcy5zb21lKHBhaXIgPT4gaXNFcXVhbChwYWlyLmtleSwgc2VhcmNoKSk7XG59XG5cbmV4cG9ydCB7IG1hcEluY2x1ZGVzIH07XG4iLCAiaW1wb3J0IHsgUGFpciB9IGZyb20gJy4uL25vZGVzL1BhaXIuanMnO1xuaW1wb3J0IHsgWUFNTE1hcCB9IGZyb20gJy4uL25vZGVzL1lBTUxNYXAuanMnO1xuaW1wb3J0IHsgcmVzb2x2ZVByb3BzIH0gZnJvbSAnLi9yZXNvbHZlLXByb3BzLmpzJztcbmltcG9ydCB7IGNvbnRhaW5zTmV3bGluZSB9IGZyb20gJy4vdXRpbC1jb250YWlucy1uZXdsaW5lLmpzJztcbmltcG9ydCB7IGZsb3dJbmRlbnRDaGVjayB9IGZyb20gJy4vdXRpbC1mbG93LWluZGVudC1jaGVjay5qcyc7XG5pbXBvcnQgeyBtYXBJbmNsdWRlcyB9IGZyb20gJy4vdXRpbC1tYXAtaW5jbHVkZXMuanMnO1xuXG5jb25zdCBzdGFydENvbE1zZyA9ICdBbGwgbWFwcGluZyBpdGVtcyBtdXN0IHN0YXJ0IGF0IHRoZSBzYW1lIGNvbHVtbic7XG5mdW5jdGlvbiByZXNvbHZlQmxvY2tNYXAoeyBjb21wb3NlTm9kZSwgY29tcG9zZUVtcHR5Tm9kZSB9LCBjdHgsIGJtLCBvbkVycm9yKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IG1hcCA9IG5ldyBZQU1MTWFwKGN0eC5zY2hlbWEpO1xuICAgIGlmIChjdHguYXRSb290KVxuICAgICAgICBjdHguYXRSb290ID0gZmFsc2U7XG4gICAgbGV0IG9mZnNldCA9IGJtLm9mZnNldDtcbiAgICBmb3IgKGNvbnN0IGNvbGxJdGVtIG9mIGJtLml0ZW1zKSB7XG4gICAgICAgIGNvbnN0IHsgc3RhcnQsIGtleSwgc2VwLCB2YWx1ZSB9ID0gY29sbEl0ZW07XG4gICAgICAgIC8vIGtleSBwcm9wZXJ0aWVzXG4gICAgICAgIGNvbnN0IGtleVByb3BzID0gcmVzb2x2ZVByb3BzKHN0YXJ0LCB7XG4gICAgICAgICAgICBpbmRpY2F0b3I6ICdleHBsaWNpdC1rZXktaW5kJyxcbiAgICAgICAgICAgIG5leHQ6IGtleSB8fCAoc2VwID09PSBudWxsIHx8IHNlcCA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2VwWzBdKSxcbiAgICAgICAgICAgIG9mZnNldCxcbiAgICAgICAgICAgIG9uRXJyb3IsXG4gICAgICAgICAgICBzdGFydE9uTmV3bGluZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgaW1wbGljaXRLZXkgPSAha2V5UHJvcHMuZm91bmQ7XG4gICAgICAgIGlmIChpbXBsaWNpdEtleSkge1xuICAgICAgICAgICAgaWYgKGtleSkge1xuICAgICAgICAgICAgICAgIGlmIChrZXkudHlwZSA9PT0gJ2Jsb2NrLXNlcScpXG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3Iob2Zmc2V0LCAnQkxPQ0tfQVNfSU1QTElDSVRfS0VZJywgJ0EgYmxvY2sgc2VxdWVuY2UgbWF5IG5vdCBiZSB1c2VkIGFzIGFuIGltcGxpY2l0IG1hcCBrZXknKTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmICgnaW5kZW50JyBpbiBrZXkgJiYga2V5LmluZGVudCAhPT0gYm0uaW5kZW50KVxuICAgICAgICAgICAgICAgICAgICBvbkVycm9yKG9mZnNldCwgJ0JBRF9JTkRFTlQnLCBzdGFydENvbE1zZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWtleVByb3BzLmFuY2hvciAmJiAha2V5UHJvcHMudGFnICYmICFzZXApIHtcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBhc3NlcnQgYmVpbmcgYXQgbGFzdCBpdGVtP1xuICAgICAgICAgICAgICAgIGlmIChrZXlQcm9wcy5jb21tZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXAuY29tbWVudClcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcC5jb21tZW50ICs9ICdcXG4nICsga2V5UHJvcHMuY29tbWVudDtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgbWFwLmNvbW1lbnQgPSBrZXlQcm9wcy5jb21tZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgoKF9hID0ga2V5UHJvcHMuZm91bmQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pbmRlbnQpICE9PSBibS5pbmRlbnQpXG4gICAgICAgICAgICBvbkVycm9yKG9mZnNldCwgJ0JBRF9JTkRFTlQnLCBzdGFydENvbE1zZyk7XG4gICAgICAgIGlmIChpbXBsaWNpdEtleSAmJiBjb250YWluc05ld2xpbmUoa2V5KSlcbiAgICAgICAgICAgIG9uRXJyb3Ioa2V5LCAvLyBjaGVja2VkIGJ5IGNvbnRhaW5zTmV3bGluZSgpXG4gICAgICAgICAgICAnTVVMVElMSU5FX0lNUExJQ0lUX0tFWScsICdJbXBsaWNpdCBrZXlzIG5lZWQgdG8gYmUgb24gYSBzaW5nbGUgbGluZScpO1xuICAgICAgICAvLyBrZXkgdmFsdWVcbiAgICAgICAgY29uc3Qga2V5U3RhcnQgPSBrZXlQcm9wcy5lbmQ7XG4gICAgICAgIGNvbnN0IGtleU5vZGUgPSBrZXlcbiAgICAgICAgICAgID8gY29tcG9zZU5vZGUoY3R4LCBrZXksIGtleVByb3BzLCBvbkVycm9yKVxuICAgICAgICAgICAgOiBjb21wb3NlRW1wdHlOb2RlKGN0eCwga2V5U3RhcnQsIHN0YXJ0LCBudWxsLCBrZXlQcm9wcywgb25FcnJvcik7XG4gICAgICAgIGlmIChjdHguc2NoZW1hLmNvbXBhdClcbiAgICAgICAgICAgIGZsb3dJbmRlbnRDaGVjayhibS5pbmRlbnQsIGtleSwgb25FcnJvcik7XG4gICAgICAgIGlmIChtYXBJbmNsdWRlcyhjdHgsIG1hcC5pdGVtcywga2V5Tm9kZSkpXG4gICAgICAgICAgICBvbkVycm9yKGtleVN0YXJ0LCAnRFVQTElDQVRFX0tFWScsICdNYXAga2V5cyBtdXN0IGJlIHVuaXF1ZScpO1xuICAgICAgICAvLyB2YWx1ZSBwcm9wZXJ0aWVzXG4gICAgICAgIGNvbnN0IHZhbHVlUHJvcHMgPSByZXNvbHZlUHJvcHMoc2VwIHx8IFtdLCB7XG4gICAgICAgICAgICBpbmRpY2F0b3I6ICdtYXAtdmFsdWUtaW5kJyxcbiAgICAgICAgICAgIG5leHQ6IHZhbHVlLFxuICAgICAgICAgICAgb2Zmc2V0OiBrZXlOb2RlLnJhbmdlWzJdLFxuICAgICAgICAgICAgb25FcnJvcixcbiAgICAgICAgICAgIHN0YXJ0T25OZXdsaW5lOiAha2V5IHx8IGtleS50eXBlID09PSAnYmxvY2stc2NhbGFyJ1xuICAgICAgICB9KTtcbiAgICAgICAgb2Zmc2V0ID0gdmFsdWVQcm9wcy5lbmQ7XG4gICAgICAgIGlmICh2YWx1ZVByb3BzLmZvdW5kKSB7XG4gICAgICAgICAgICBpZiAoaW1wbGljaXRLZXkpIHtcbiAgICAgICAgICAgICAgICBpZiAoKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB2b2lkIDAgPyB2b2lkIDAgOiB2YWx1ZS50eXBlKSA9PT0gJ2Jsb2NrLW1hcCcgJiYgIXZhbHVlUHJvcHMuaGFzTmV3bGluZSlcbiAgICAgICAgICAgICAgICAgICAgb25FcnJvcihvZmZzZXQsICdCTE9DS19BU19JTVBMSUNJVF9LRVknLCAnTmVzdGVkIG1hcHBpbmdzIGFyZSBub3QgYWxsb3dlZCBpbiBjb21wYWN0IG1hcHBpbmdzJyk7XG4gICAgICAgICAgICAgICAgaWYgKGN0eC5vcHRpb25zLnN0cmljdCAmJlxuICAgICAgICAgICAgICAgICAgICBrZXlQcm9wcy5zdGFydCA8IHZhbHVlUHJvcHMuZm91bmQub2Zmc2V0IC0gMTAyNClcbiAgICAgICAgICAgICAgICAgICAgb25FcnJvcihrZXlOb2RlLnJhbmdlLCAnS0VZX09WRVJfMTAyNF9DSEFSUycsICdUaGUgOiBpbmRpY2F0b3IgbXVzdCBiZSBhdCBtb3N0IDEwMjQgY2hhcnMgYWZ0ZXIgdGhlIHN0YXJ0IG9mIGFuIGltcGxpY2l0IGJsb2NrIG1hcHBpbmcga2V5Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB2YWx1ZSB2YWx1ZVxuICAgICAgICAgICAgY29uc3QgdmFsdWVOb2RlID0gdmFsdWVcbiAgICAgICAgICAgICAgICA/IGNvbXBvc2VOb2RlKGN0eCwgdmFsdWUsIHZhbHVlUHJvcHMsIG9uRXJyb3IpXG4gICAgICAgICAgICAgICAgOiBjb21wb3NlRW1wdHlOb2RlKGN0eCwgb2Zmc2V0LCBzZXAsIG51bGwsIHZhbHVlUHJvcHMsIG9uRXJyb3IpO1xuICAgICAgICAgICAgaWYgKGN0eC5zY2hlbWEuY29tcGF0KVxuICAgICAgICAgICAgICAgIGZsb3dJbmRlbnRDaGVjayhibS5pbmRlbnQsIHZhbHVlLCBvbkVycm9yKTtcbiAgICAgICAgICAgIG9mZnNldCA9IHZhbHVlTm9kZS5yYW5nZVsyXTtcbiAgICAgICAgICAgIGNvbnN0IHBhaXIgPSBuZXcgUGFpcihrZXlOb2RlLCB2YWx1ZU5vZGUpO1xuICAgICAgICAgICAgaWYgKGN0eC5vcHRpb25zLmtlZXBTb3VyY2VUb2tlbnMpXG4gICAgICAgICAgICAgICAgcGFpci5zcmNUb2tlbiA9IGNvbGxJdGVtO1xuICAgICAgICAgICAgbWFwLml0ZW1zLnB1c2gocGFpcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBrZXkgd2l0aCBubyB2YWx1ZVxuICAgICAgICAgICAgaWYgKGltcGxpY2l0S2V5KVxuICAgICAgICAgICAgICAgIG9uRXJyb3Ioa2V5Tm9kZS5yYW5nZSwgJ01JU1NJTkdfQ0hBUicsICdJbXBsaWNpdCBtYXAga2V5cyBuZWVkIHRvIGJlIGZvbGxvd2VkIGJ5IG1hcCB2YWx1ZXMnKTtcbiAgICAgICAgICAgIGlmICh2YWx1ZVByb3BzLmNvbW1lbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoa2V5Tm9kZS5jb21tZW50KVxuICAgICAgICAgICAgICAgICAgICBrZXlOb2RlLmNvbW1lbnQgKz0gJ1xcbicgKyB2YWx1ZVByb3BzLmNvbW1lbnQ7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBrZXlOb2RlLmNvbW1lbnQgPSB2YWx1ZVByb3BzLmNvbW1lbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwYWlyID0gbmV3IFBhaXIoa2V5Tm9kZSk7XG4gICAgICAgICAgICBpZiAoY3R4Lm9wdGlvbnMua2VlcFNvdXJjZVRva2VucylcbiAgICAgICAgICAgICAgICBwYWlyLnNyY1Rva2VuID0gY29sbEl0ZW07XG4gICAgICAgICAgICBtYXAuaXRlbXMucHVzaChwYWlyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBtYXAucmFuZ2UgPSBbYm0ub2Zmc2V0LCBvZmZzZXQsIG9mZnNldF07XG4gICAgcmV0dXJuIG1hcDtcbn1cblxuZXhwb3J0IHsgcmVzb2x2ZUJsb2NrTWFwIH07XG4iLCAiaW1wb3J0IHsgWUFNTFNlcSB9IGZyb20gJy4uL25vZGVzL1lBTUxTZXEuanMnO1xuaW1wb3J0IHsgcmVzb2x2ZVByb3BzIH0gZnJvbSAnLi9yZXNvbHZlLXByb3BzLmpzJztcbmltcG9ydCB7IGZsb3dJbmRlbnRDaGVjayB9IGZyb20gJy4vdXRpbC1mbG93LWluZGVudC1jaGVjay5qcyc7XG5cbmZ1bmN0aW9uIHJlc29sdmVCbG9ja1NlcSh7IGNvbXBvc2VOb2RlLCBjb21wb3NlRW1wdHlOb2RlIH0sIGN0eCwgYnMsIG9uRXJyb3IpIHtcbiAgICBjb25zdCBzZXEgPSBuZXcgWUFNTFNlcShjdHguc2NoZW1hKTtcbiAgICBpZiAoY3R4LmF0Um9vdClcbiAgICAgICAgY3R4LmF0Um9vdCA9IGZhbHNlO1xuICAgIGxldCBvZmZzZXQgPSBicy5vZmZzZXQ7XG4gICAgZm9yIChjb25zdCB7IHN0YXJ0LCB2YWx1ZSB9IG9mIGJzLml0ZW1zKSB7XG4gICAgICAgIGNvbnN0IHByb3BzID0gcmVzb2x2ZVByb3BzKHN0YXJ0LCB7XG4gICAgICAgICAgICBpbmRpY2F0b3I6ICdzZXEtaXRlbS1pbmQnLFxuICAgICAgICAgICAgbmV4dDogdmFsdWUsXG4gICAgICAgICAgICBvZmZzZXQsXG4gICAgICAgICAgICBvbkVycm9yLFxuICAgICAgICAgICAgc3RhcnRPbk5ld2xpbmU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIG9mZnNldCA9IHByb3BzLmVuZDtcbiAgICAgICAgaWYgKCFwcm9wcy5mb3VuZCkge1xuICAgICAgICAgICAgaWYgKHByb3BzLmFuY2hvciB8fCBwcm9wcy50YWcgfHwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgJiYgdmFsdWUudHlwZSA9PT0gJ2Jsb2NrLXNlcScpXG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3Iob2Zmc2V0LCAnQkFEX0lOREVOVCcsICdBbGwgc2VxdWVuY2UgaXRlbXMgbXVzdCBzdGFydCBhdCB0aGUgc2FtZSBjb2x1bW4nKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3Iob2Zmc2V0LCAnTUlTU0lOR19DSEFSJywgJ1NlcXVlbmNlIGl0ZW0gd2l0aG91dCAtIGluZGljYXRvcicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogYXNzZXJ0IGJlaW5nIGF0IGxhc3QgaXRlbT9cbiAgICAgICAgICAgICAgICBpZiAocHJvcHMuY29tbWVudClcbiAgICAgICAgICAgICAgICAgICAgc2VxLmNvbW1lbnQgPSBwcm9wcy5jb21tZW50O1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5vZGUgPSB2YWx1ZVxuICAgICAgICAgICAgPyBjb21wb3NlTm9kZShjdHgsIHZhbHVlLCBwcm9wcywgb25FcnJvcilcbiAgICAgICAgICAgIDogY29tcG9zZUVtcHR5Tm9kZShjdHgsIG9mZnNldCwgc3RhcnQsIG51bGwsIHByb3BzLCBvbkVycm9yKTtcbiAgICAgICAgaWYgKGN0eC5zY2hlbWEuY29tcGF0KVxuICAgICAgICAgICAgZmxvd0luZGVudENoZWNrKGJzLmluZGVudCwgdmFsdWUsIG9uRXJyb3IpO1xuICAgICAgICBvZmZzZXQgPSBub2RlLnJhbmdlWzJdO1xuICAgICAgICBzZXEuaXRlbXMucHVzaChub2RlKTtcbiAgICB9XG4gICAgc2VxLnJhbmdlID0gW2JzLm9mZnNldCwgb2Zmc2V0LCBvZmZzZXRdO1xuICAgIHJldHVybiBzZXE7XG59XG5cbmV4cG9ydCB7IHJlc29sdmVCbG9ja1NlcSB9O1xuIiwgImZ1bmN0aW9uIHJlc29sdmVFbmQoZW5kLCBvZmZzZXQsIHJlcVNwYWNlLCBvbkVycm9yKSB7XG4gICAgbGV0IGNvbW1lbnQgPSAnJztcbiAgICBpZiAoZW5kKSB7XG4gICAgICAgIGxldCBoYXNTcGFjZSA9IGZhbHNlO1xuICAgICAgICBsZXQgc2VwID0gJyc7XG4gICAgICAgIGZvciAoY29uc3QgdG9rZW4gb2YgZW5kKSB7XG4gICAgICAgICAgICBjb25zdCB7IHNvdXJjZSwgdHlwZSB9ID0gdG9rZW47XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzcGFjZSc6XG4gICAgICAgICAgICAgICAgICAgIGhhc1NwYWNlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnY29tbWVudCc6IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlcVNwYWNlICYmICFoYXNTcGFjZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uRXJyb3IodG9rZW4sICdNSVNTSU5HX0NIQVInLCAnQ29tbWVudHMgbXVzdCBiZSBzZXBhcmF0ZWQgZnJvbSBvdGhlciB0b2tlbnMgYnkgd2hpdGUgc3BhY2UgY2hhcmFjdGVycycpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjYiA9IHNvdXJjZS5zdWJzdHJpbmcoMSkgfHwgJyAnO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbW1lbnQpXG4gICAgICAgICAgICAgICAgICAgICAgICBjb21tZW50ID0gY2I7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1lbnQgKz0gc2VwICsgY2I7XG4gICAgICAgICAgICAgICAgICAgIHNlcCA9ICcnO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAnbmV3bGluZSc6XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb21tZW50KVxuICAgICAgICAgICAgICAgICAgICAgICAgc2VwICs9IHNvdXJjZTtcbiAgICAgICAgICAgICAgICAgICAgaGFzU3BhY2UgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBvbkVycm9yKHRva2VuLCAnVU5FWFBFQ1RFRF9UT0tFTicsIGBVbmV4cGVjdGVkICR7dHlwZX0gYXQgbm9kZSBlbmRgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9mZnNldCArPSBzb3VyY2UubGVuZ3RoO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IGNvbW1lbnQsIG9mZnNldCB9O1xufVxuXG5leHBvcnQgeyByZXNvbHZlRW5kIH07XG4iLCAiaW1wb3J0IHsgaXNQYWlyIH0gZnJvbSAnLi4vbm9kZXMvTm9kZS5qcyc7XG5pbXBvcnQgeyBQYWlyIH0gZnJvbSAnLi4vbm9kZXMvUGFpci5qcyc7XG5pbXBvcnQgeyBZQU1MTWFwIH0gZnJvbSAnLi4vbm9kZXMvWUFNTE1hcC5qcyc7XG5pbXBvcnQgeyBZQU1MU2VxIH0gZnJvbSAnLi4vbm9kZXMvWUFNTFNlcS5qcyc7XG5pbXBvcnQgeyByZXNvbHZlRW5kIH0gZnJvbSAnLi9yZXNvbHZlLWVuZC5qcyc7XG5pbXBvcnQgeyByZXNvbHZlUHJvcHMgfSBmcm9tICcuL3Jlc29sdmUtcHJvcHMuanMnO1xuaW1wb3J0IHsgY29udGFpbnNOZXdsaW5lIH0gZnJvbSAnLi91dGlsLWNvbnRhaW5zLW5ld2xpbmUuanMnO1xuaW1wb3J0IHsgbWFwSW5jbHVkZXMgfSBmcm9tICcuL3V0aWwtbWFwLWluY2x1ZGVzLmpzJztcblxuY29uc3QgYmxvY2tNc2cgPSAnQmxvY2sgY29sbGVjdGlvbnMgYXJlIG5vdCBhbGxvd2VkIHdpdGhpbiBmbG93IGNvbGxlY3Rpb25zJztcbmNvbnN0IGlzQmxvY2sgPSAodG9rZW4pID0+IHRva2VuICYmICh0b2tlbi50eXBlID09PSAnYmxvY2stbWFwJyB8fCB0b2tlbi50eXBlID09PSAnYmxvY2stc2VxJyk7XG5mdW5jdGlvbiByZXNvbHZlRmxvd0NvbGxlY3Rpb24oeyBjb21wb3NlTm9kZSwgY29tcG9zZUVtcHR5Tm9kZSB9LCBjdHgsIGZjLCBvbkVycm9yKSB7XG4gICAgY29uc3QgaXNNYXAgPSBmYy5zdGFydC5zb3VyY2UgPT09ICd7JztcbiAgICBjb25zdCBmY05hbWUgPSBpc01hcCA/ICdmbG93IG1hcCcgOiAnZmxvdyBzZXF1ZW5jZSc7XG4gICAgY29uc3QgY29sbCA9IGlzTWFwXG4gICAgICAgID8gbmV3IFlBTUxNYXAoY3R4LnNjaGVtYSlcbiAgICAgICAgOiBuZXcgWUFNTFNlcShjdHguc2NoZW1hKTtcbiAgICBjb2xsLmZsb3cgPSB0cnVlO1xuICAgIGNvbnN0IGF0Um9vdCA9IGN0eC5hdFJvb3Q7XG4gICAgaWYgKGF0Um9vdClcbiAgICAgICAgY3R4LmF0Um9vdCA9IGZhbHNlO1xuICAgIGxldCBvZmZzZXQgPSBmYy5vZmZzZXQgKyBmYy5zdGFydC5zb3VyY2UubGVuZ3RoO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZmMuaXRlbXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29uc3QgY29sbEl0ZW0gPSBmYy5pdGVtc1tpXTtcbiAgICAgICAgY29uc3QgeyBzdGFydCwga2V5LCBzZXAsIHZhbHVlIH0gPSBjb2xsSXRlbTtcbiAgICAgICAgY29uc3QgcHJvcHMgPSByZXNvbHZlUHJvcHMoc3RhcnQsIHtcbiAgICAgICAgICAgIGZsb3c6IGZjTmFtZSxcbiAgICAgICAgICAgIGluZGljYXRvcjogJ2V4cGxpY2l0LWtleS1pbmQnLFxuICAgICAgICAgICAgbmV4dDoga2V5IHx8IChzZXAgPT09IG51bGwgfHwgc2VwID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzZXBbMF0pLFxuICAgICAgICAgICAgb2Zmc2V0LFxuICAgICAgICAgICAgb25FcnJvcixcbiAgICAgICAgICAgIHN0YXJ0T25OZXdsaW5lOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFwcm9wcy5mb3VuZCkge1xuICAgICAgICAgICAgaWYgKCFwcm9wcy5hbmNob3IgJiYgIXByb3BzLnRhZyAmJiAhc2VwICYmICF2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmIChpID09PSAwICYmIHByb3BzLmNvbW1hKVxuICAgICAgICAgICAgICAgICAgICBvbkVycm9yKHByb3BzLmNvbW1hLCAnVU5FWFBFQ1RFRF9UT0tFTicsIGBVbmV4cGVjdGVkICwgaW4gJHtmY05hbWV9YCk7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaSA8IGZjLml0ZW1zLmxlbmd0aCAtIDEpXG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3IocHJvcHMuc3RhcnQsICdVTkVYUEVDVEVEX1RPS0VOJywgYFVuZXhwZWN0ZWQgZW1wdHkgaXRlbSBpbiAke2ZjTmFtZX1gKTtcbiAgICAgICAgICAgICAgICBpZiAocHJvcHMuY29tbWVudCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29sbC5jb21tZW50KVxuICAgICAgICAgICAgICAgICAgICAgICAgY29sbC5jb21tZW50ICs9ICdcXG4nICsgcHJvcHMuY29tbWVudDtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgY29sbC5jb21tZW50ID0gcHJvcHMuY29tbWVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gcHJvcHMuZW5kO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpc01hcCAmJiBjdHgub3B0aW9ucy5zdHJpY3QgJiYgY29udGFpbnNOZXdsaW5lKGtleSkpXG4gICAgICAgICAgICAgICAgb25FcnJvcihrZXksIC8vIGNoZWNrZWQgYnkgY29udGFpbnNOZXdsaW5lKClcbiAgICAgICAgICAgICAgICAnTVVMVElMSU5FX0lNUExJQ0lUX0tFWScsICdJbXBsaWNpdCBrZXlzIG9mIGZsb3cgc2VxdWVuY2UgcGFpcnMgbmVlZCB0byBiZSBvbiBhIHNpbmdsZSBsaW5lJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgICAgIGlmIChwcm9wcy5jb21tYSlcbiAgICAgICAgICAgICAgICBvbkVycm9yKHByb3BzLmNvbW1hLCAnVU5FWFBFQ1RFRF9UT0tFTicsIGBVbmV4cGVjdGVkICwgaW4gJHtmY05hbWV9YCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoIXByb3BzLmNvbW1hKVxuICAgICAgICAgICAgICAgIG9uRXJyb3IocHJvcHMuc3RhcnQsICdNSVNTSU5HX0NIQVInLCBgTWlzc2luZyAsIGJldHdlZW4gJHtmY05hbWV9IGl0ZW1zYCk7XG4gICAgICAgICAgICBpZiAocHJvcHMuY29tbWVudCkge1xuICAgICAgICAgICAgICAgIGxldCBwcmV2SXRlbUNvbW1lbnQgPSAnJztcbiAgICAgICAgICAgICAgICBsb29wOiBmb3IgKGNvbnN0IHN0IG9mIHN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoc3QudHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnY29tbWEnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnc3BhY2UnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnY29tbWVudCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJldkl0ZW1Db21tZW50ID0gc3Quc291cmNlLnN1YnN0cmluZygxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhayBsb29wO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhayBsb29wO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwcmV2SXRlbUNvbW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHByZXYgPSBjb2xsLml0ZW1zW2NvbGwuaXRlbXMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1BhaXIocHJldikpXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2ID0gcHJldi52YWx1ZSB8fCBwcmV2LmtleTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByZXYuY29tbWVudClcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXYuY29tbWVudCArPSAnXFxuJyArIHByZXZJdGVtQ29tbWVudDtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgcHJldi5jb21tZW50ID0gcHJldkl0ZW1Db21tZW50O1xuICAgICAgICAgICAgICAgICAgICBwcm9wcy5jb21tZW50ID0gcHJvcHMuY29tbWVudC5zdWJzdHJpbmcocHJldkl0ZW1Db21tZW50Lmxlbmd0aCArIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzTWFwICYmICFzZXAgJiYgIXByb3BzLmZvdW5kKSB7XG4gICAgICAgICAgICAvLyBpdGVtIGlzIGEgdmFsdWUgaW4gYSBzZXFcbiAgICAgICAgICAgIC8vIFx1MjE5MiBrZXkgJiBzZXAgYXJlIGVtcHR5LCBzdGFydCBkb2VzIG5vdCBpbmNsdWRlID8gb3IgOlxuICAgICAgICAgICAgY29uc3QgdmFsdWVOb2RlID0gdmFsdWVcbiAgICAgICAgICAgICAgICA/IGNvbXBvc2VOb2RlKGN0eCwgdmFsdWUsIHByb3BzLCBvbkVycm9yKVxuICAgICAgICAgICAgICAgIDogY29tcG9zZUVtcHR5Tm9kZShjdHgsIHByb3BzLmVuZCwgc2VwLCBudWxsLCBwcm9wcywgb25FcnJvcik7XG4gICAgICAgICAgICBjb2xsLml0ZW1zLnB1c2godmFsdWVOb2RlKTtcbiAgICAgICAgICAgIG9mZnNldCA9IHZhbHVlTm9kZS5yYW5nZVsyXTtcbiAgICAgICAgICAgIGlmIChpc0Jsb2NrKHZhbHVlKSlcbiAgICAgICAgICAgICAgICBvbkVycm9yKHZhbHVlTm9kZS5yYW5nZSwgJ0JMT0NLX0lOX0ZMT1cnLCBibG9ja01zZyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBpdGVtIGlzIGEga2V5K3ZhbHVlIHBhaXJcbiAgICAgICAgICAgIC8vIGtleSB2YWx1ZVxuICAgICAgICAgICAgY29uc3Qga2V5U3RhcnQgPSBwcm9wcy5lbmQ7XG4gICAgICAgICAgICBjb25zdCBrZXlOb2RlID0ga2V5XG4gICAgICAgICAgICAgICAgPyBjb21wb3NlTm9kZShjdHgsIGtleSwgcHJvcHMsIG9uRXJyb3IpXG4gICAgICAgICAgICAgICAgOiBjb21wb3NlRW1wdHlOb2RlKGN0eCwga2V5U3RhcnQsIHN0YXJ0LCBudWxsLCBwcm9wcywgb25FcnJvcik7XG4gICAgICAgICAgICBpZiAoaXNCbG9jayhrZXkpKVxuICAgICAgICAgICAgICAgIG9uRXJyb3Ioa2V5Tm9kZS5yYW5nZSwgJ0JMT0NLX0lOX0ZMT1cnLCBibG9ja01zZyk7XG4gICAgICAgICAgICAvLyB2YWx1ZSBwcm9wZXJ0aWVzXG4gICAgICAgICAgICBjb25zdCB2YWx1ZVByb3BzID0gcmVzb2x2ZVByb3BzKHNlcCB8fCBbXSwge1xuICAgICAgICAgICAgICAgIGZsb3c6IGZjTmFtZSxcbiAgICAgICAgICAgICAgICBpbmRpY2F0b3I6ICdtYXAtdmFsdWUtaW5kJyxcbiAgICAgICAgICAgICAgICBuZXh0OiB2YWx1ZSxcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IGtleU5vZGUucmFuZ2VbMl0sXG4gICAgICAgICAgICAgICAgb25FcnJvcixcbiAgICAgICAgICAgICAgICBzdGFydE9uTmV3bGluZTogZmFsc2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHZhbHVlUHJvcHMuZm91bmQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzTWFwICYmICFwcm9wcy5mb3VuZCAmJiBjdHgub3B0aW9ucy5zdHJpY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlcClcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3Qgc3Qgb2Ygc2VwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0ID09PSB2YWx1ZVByb3BzLmZvdW5kKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3QudHlwZSA9PT0gJ25ld2xpbmUnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uRXJyb3Ioc3QsICdNVUxUSUxJTkVfSU1QTElDSVRfS0VZJywgJ0ltcGxpY2l0IGtleXMgb2YgZmxvdyBzZXF1ZW5jZSBwYWlycyBuZWVkIHRvIGJlIG9uIGEgc2luZ2xlIGxpbmUnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocHJvcHMuc3RhcnQgPCB2YWx1ZVByb3BzLmZvdW5kLm9mZnNldCAtIDEwMjQpXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkVycm9yKHZhbHVlUHJvcHMuZm91bmQsICdLRVlfT1ZFUl8xMDI0X0NIQVJTJywgJ1RoZSA6IGluZGljYXRvciBtdXN0IGJlIGF0IG1vc3QgMTAyNCBjaGFycyBhZnRlciB0aGUgc3RhcnQgb2YgYW4gaW1wbGljaXQgZmxvdyBzZXF1ZW5jZSBrZXknKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmICgnc291cmNlJyBpbiB2YWx1ZSAmJiB2YWx1ZS5zb3VyY2UgJiYgdmFsdWUuc291cmNlWzBdID09PSAnOicpXG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3IodmFsdWUsICdNSVNTSU5HX0NIQVInLCBgTWlzc2luZyBzcGFjZSBhZnRlciA6IGluICR7ZmNOYW1lfWApO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgb25FcnJvcih2YWx1ZVByb3BzLnN0YXJ0LCAnTUlTU0lOR19DSEFSJywgYE1pc3NpbmcgLCBvciA6IGJldHdlZW4gJHtmY05hbWV9IGl0ZW1zYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB2YWx1ZSB2YWx1ZVxuICAgICAgICAgICAgY29uc3QgdmFsdWVOb2RlID0gdmFsdWVcbiAgICAgICAgICAgICAgICA/IGNvbXBvc2VOb2RlKGN0eCwgdmFsdWUsIHZhbHVlUHJvcHMsIG9uRXJyb3IpXG4gICAgICAgICAgICAgICAgOiB2YWx1ZVByb3BzLmZvdW5kXG4gICAgICAgICAgICAgICAgICAgID8gY29tcG9zZUVtcHR5Tm9kZShjdHgsIHZhbHVlUHJvcHMuZW5kLCBzZXAsIG51bGwsIHZhbHVlUHJvcHMsIG9uRXJyb3IpXG4gICAgICAgICAgICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgICAgIGlmICh2YWx1ZU5vZGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNCbG9jayh2YWx1ZSkpXG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3IodmFsdWVOb2RlLnJhbmdlLCAnQkxPQ0tfSU5fRkxPVycsIGJsb2NrTXNnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlUHJvcHMuY29tbWVudCkge1xuICAgICAgICAgICAgICAgIGlmIChrZXlOb2RlLmNvbW1lbnQpXG4gICAgICAgICAgICAgICAgICAgIGtleU5vZGUuY29tbWVudCArPSAnXFxuJyArIHZhbHVlUHJvcHMuY29tbWVudDtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGtleU5vZGUuY29tbWVudCA9IHZhbHVlUHJvcHMuY29tbWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHBhaXIgPSBuZXcgUGFpcihrZXlOb2RlLCB2YWx1ZU5vZGUpO1xuICAgICAgICAgICAgaWYgKGN0eC5vcHRpb25zLmtlZXBTb3VyY2VUb2tlbnMpXG4gICAgICAgICAgICAgICAgcGFpci5zcmNUb2tlbiA9IGNvbGxJdGVtO1xuICAgICAgICAgICAgaWYgKGlzTWFwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWFwID0gY29sbDtcbiAgICAgICAgICAgICAgICBpZiAobWFwSW5jbHVkZXMoY3R4LCBtYXAuaXRlbXMsIGtleU5vZGUpKVxuICAgICAgICAgICAgICAgICAgICBvbkVycm9yKGtleVN0YXJ0LCAnRFVQTElDQVRFX0tFWScsICdNYXAga2V5cyBtdXN0IGJlIHVuaXF1ZScpO1xuICAgICAgICAgICAgICAgIG1hcC5pdGVtcy5wdXNoKHBhaXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWFwID0gbmV3IFlBTUxNYXAoY3R4LnNjaGVtYSk7XG4gICAgICAgICAgICAgICAgbWFwLmZsb3cgPSB0cnVlO1xuICAgICAgICAgICAgICAgIG1hcC5pdGVtcy5wdXNoKHBhaXIpO1xuICAgICAgICAgICAgICAgIGNvbGwuaXRlbXMucHVzaChtYXApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2Zmc2V0ID0gdmFsdWVOb2RlID8gdmFsdWVOb2RlLnJhbmdlWzJdIDogdmFsdWVQcm9wcy5lbmQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZXhwZWN0ZWRFbmQgPSBpc01hcCA/ICd9JyA6ICddJztcbiAgICBjb25zdCBbY2UsIC4uLmVlXSA9IGZjLmVuZDtcbiAgICBsZXQgY2VQb3MgPSBvZmZzZXQ7XG4gICAgaWYgKGNlICYmIGNlLnNvdXJjZSA9PT0gZXhwZWN0ZWRFbmQpXG4gICAgICAgIGNlUG9zID0gY2Uub2Zmc2V0ICsgY2Uuc291cmNlLmxlbmd0aDtcbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgbmFtZSA9IGZjTmFtZVswXS50b1VwcGVyQ2FzZSgpICsgZmNOYW1lLnN1YnN0cmluZygxKTtcbiAgICAgICAgY29uc3QgbXNnID0gYXRSb290XG4gICAgICAgICAgICA/IGAke25hbWV9IG11c3QgZW5kIHdpdGggYSAke2V4cGVjdGVkRW5kfWBcbiAgICAgICAgICAgIDogYCR7bmFtZX0gaW4gYmxvY2sgY29sbGVjdGlvbiBtdXN0IGJlIHN1ZmZpY2llbnRseSBpbmRlbnRlZCBhbmQgZW5kIHdpdGggYSAke2V4cGVjdGVkRW5kfWA7XG4gICAgICAgIG9uRXJyb3Iob2Zmc2V0LCBhdFJvb3QgPyAnTUlTU0lOR19DSEFSJyA6ICdCQURfSU5ERU5UJywgbXNnKTtcbiAgICAgICAgaWYgKGNlICYmIGNlLnNvdXJjZS5sZW5ndGggIT09IDEpXG4gICAgICAgICAgICBlZS51bnNoaWZ0KGNlKTtcbiAgICB9XG4gICAgaWYgKGVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3QgZW5kID0gcmVzb2x2ZUVuZChlZSwgY2VQb3MsIGN0eC5vcHRpb25zLnN0cmljdCwgb25FcnJvcik7XG4gICAgICAgIGlmIChlbmQuY29tbWVudCkge1xuICAgICAgICAgICAgaWYgKGNvbGwuY29tbWVudClcbiAgICAgICAgICAgICAgICBjb2xsLmNvbW1lbnQgKz0gJ1xcbicgKyBlbmQuY29tbWVudDtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBjb2xsLmNvbW1lbnQgPSBlbmQuY29tbWVudDtcbiAgICAgICAgfVxuICAgICAgICBjb2xsLnJhbmdlID0gW2ZjLm9mZnNldCwgY2VQb3MsIGVuZC5vZmZzZXRdO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29sbC5yYW5nZSA9IFtmYy5vZmZzZXQsIGNlUG9zLCBjZVBvc107XG4gICAgfVxuICAgIHJldHVybiBjb2xsO1xufVxuXG5leHBvcnQgeyByZXNvbHZlRmxvd0NvbGxlY3Rpb24gfTtcbiIsICJpbXBvcnQgeyBpc05vZGUsIGlzTWFwIH0gZnJvbSAnLi4vbm9kZXMvTm9kZS5qcyc7XG5pbXBvcnQgeyBTY2FsYXIgfSBmcm9tICcuLi9ub2Rlcy9TY2FsYXIuanMnO1xuaW1wb3J0IHsgcmVzb2x2ZUJsb2NrTWFwIH0gZnJvbSAnLi9yZXNvbHZlLWJsb2NrLW1hcC5qcyc7XG5pbXBvcnQgeyByZXNvbHZlQmxvY2tTZXEgfSBmcm9tICcuL3Jlc29sdmUtYmxvY2stc2VxLmpzJztcbmltcG9ydCB7IHJlc29sdmVGbG93Q29sbGVjdGlvbiB9IGZyb20gJy4vcmVzb2x2ZS1mbG93LWNvbGxlY3Rpb24uanMnO1xuXG5mdW5jdGlvbiBjb21wb3NlQ29sbGVjdGlvbihDTiwgY3R4LCB0b2tlbiwgdGFnVG9rZW4sIG9uRXJyb3IpIHtcbiAgICBsZXQgY29sbDtcbiAgICBzd2l0Y2ggKHRva2VuLnR5cGUpIHtcbiAgICAgICAgY2FzZSAnYmxvY2stbWFwJzoge1xuICAgICAgICAgICAgY29sbCA9IHJlc29sdmVCbG9ja01hcChDTiwgY3R4LCB0b2tlbiwgb25FcnJvcik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdibG9jay1zZXEnOiB7XG4gICAgICAgICAgICBjb2xsID0gcmVzb2x2ZUJsb2NrU2VxKENOLCBjdHgsIHRva2VuLCBvbkVycm9yKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ2Zsb3ctY29sbGVjdGlvbic6IHtcbiAgICAgICAgICAgIGNvbGwgPSByZXNvbHZlRmxvd0NvbGxlY3Rpb24oQ04sIGN0eCwgdG9rZW4sIG9uRXJyb3IpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCF0YWdUb2tlbilcbiAgICAgICAgcmV0dXJuIGNvbGw7XG4gICAgY29uc3QgdGFnTmFtZSA9IGN0eC5kaXJlY3RpdmVzLnRhZ05hbWUodGFnVG9rZW4uc291cmNlLCBtc2cgPT4gb25FcnJvcih0YWdUb2tlbiwgJ1RBR19SRVNPTFZFX0ZBSUxFRCcsIG1zZykpO1xuICAgIGlmICghdGFnTmFtZSlcbiAgICAgICAgcmV0dXJuIGNvbGw7XG4gICAgLy8gQ2FzdCBuZWVkZWQgZHVlIHRvOiBodHRwczovL2dpdGh1Yi5jb20vTWljcm9zb2Z0L1R5cGVTY3JpcHQvaXNzdWVzLzM4NDFcbiAgICBjb25zdCBDb2xsID0gY29sbC5jb25zdHJ1Y3RvcjtcbiAgICBpZiAodGFnTmFtZSA9PT0gJyEnIHx8IHRhZ05hbWUgPT09IENvbGwudGFnTmFtZSkge1xuICAgICAgICBjb2xsLnRhZyA9IENvbGwudGFnTmFtZTtcbiAgICAgICAgcmV0dXJuIGNvbGw7XG4gICAgfVxuICAgIGNvbnN0IGV4cFR5cGUgPSBpc01hcChjb2xsKSA/ICdtYXAnIDogJ3NlcSc7XG4gICAgbGV0IHRhZyA9IGN0eC5zY2hlbWEudGFncy5maW5kKHQgPT4gdC5jb2xsZWN0aW9uID09PSBleHBUeXBlICYmIHQudGFnID09PSB0YWdOYW1lKTtcbiAgICBpZiAoIXRhZykge1xuICAgICAgICBjb25zdCBrdCA9IGN0eC5zY2hlbWEua25vd25UYWdzW3RhZ05hbWVdO1xuICAgICAgICBpZiAoa3QgJiYga3QuY29sbGVjdGlvbiA9PT0gZXhwVHlwZSkge1xuICAgICAgICAgICAgY3R4LnNjaGVtYS50YWdzLnB1c2goT2JqZWN0LmFzc2lnbih7fSwga3QsIHsgZGVmYXVsdDogZmFsc2UgfSkpO1xuICAgICAgICAgICAgdGFnID0ga3Q7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvbkVycm9yKHRhZ1Rva2VuLCAnVEFHX1JFU09MVkVfRkFJTEVEJywgYFVucmVzb2x2ZWQgdGFnOiAke3RhZ05hbWV9YCwgdHJ1ZSk7XG4gICAgICAgICAgICBjb2xsLnRhZyA9IHRhZ05hbWU7XG4gICAgICAgICAgICByZXR1cm4gY29sbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCByZXMgPSB0YWcucmVzb2x2ZShjb2xsLCBtc2cgPT4gb25FcnJvcih0YWdUb2tlbiwgJ1RBR19SRVNPTFZFX0ZBSUxFRCcsIG1zZyksIGN0eC5vcHRpb25zKTtcbiAgICBjb25zdCBub2RlID0gaXNOb2RlKHJlcylcbiAgICAgICAgPyByZXNcbiAgICAgICAgOiBuZXcgU2NhbGFyKHJlcyk7XG4gICAgbm9kZS5yYW5nZSA9IGNvbGwucmFuZ2U7XG4gICAgbm9kZS50YWcgPSB0YWdOYW1lO1xuICAgIGlmICh0YWcgPT09IG51bGwgfHwgdGFnID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0YWcuZm9ybWF0KVxuICAgICAgICBub2RlLmZvcm1hdCA9IHRhZy5mb3JtYXQ7XG4gICAgcmV0dXJuIG5vZGU7XG59XG5cbmV4cG9ydCB7IGNvbXBvc2VDb2xsZWN0aW9uIH07XG4iLCAiaW1wb3J0IHsgU2NhbGFyIH0gZnJvbSAnLi4vbm9kZXMvU2NhbGFyLmpzJztcblxuZnVuY3Rpb24gcmVzb2x2ZUJsb2NrU2NhbGFyKHNjYWxhciwgc3RyaWN0LCBvbkVycm9yKSB7XG4gICAgY29uc3Qgc3RhcnQgPSBzY2FsYXIub2Zmc2V0O1xuICAgIGNvbnN0IGhlYWRlciA9IHBhcnNlQmxvY2tTY2FsYXJIZWFkZXIoc2NhbGFyLCBzdHJpY3QsIG9uRXJyb3IpO1xuICAgIGlmICghaGVhZGVyKVxuICAgICAgICByZXR1cm4geyB2YWx1ZTogJycsIHR5cGU6IG51bGwsIGNvbW1lbnQ6ICcnLCByYW5nZTogW3N0YXJ0LCBzdGFydCwgc3RhcnRdIH07XG4gICAgY29uc3QgdHlwZSA9IGhlYWRlci5tb2RlID09PSAnPicgPyBTY2FsYXIuQkxPQ0tfRk9MREVEIDogU2NhbGFyLkJMT0NLX0xJVEVSQUw7XG4gICAgY29uc3QgbGluZXMgPSBzY2FsYXIuc291cmNlID8gc3BsaXRMaW5lcyhzY2FsYXIuc291cmNlKSA6IFtdO1xuICAgIC8vIGRldGVybWluZSB0aGUgZW5kIG9mIGNvbnRlbnQgJiBzdGFydCBvZiBjaG9tcGluZ1xuICAgIGxldCBjaG9tcFN0YXJ0ID0gbGluZXMubGVuZ3RoO1xuICAgIGZvciAobGV0IGkgPSBsaW5lcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICBjb25zdCBjb250ZW50ID0gbGluZXNbaV1bMV07XG4gICAgICAgIGlmIChjb250ZW50ID09PSAnJyB8fCBjb250ZW50ID09PSAnXFxyJylcbiAgICAgICAgICAgIGNob21wU3RhcnQgPSBpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgLy8gc2hvcnRjdXQgZm9yIGVtcHR5IGNvbnRlbnRzXG4gICAgaWYgKCFzY2FsYXIuc291cmNlIHx8IGNob21wU3RhcnQgPT09IDApIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBoZWFkZXIuY2hvbXAgPT09ICcrJyA/ICdcXG4nLnJlcGVhdChNYXRoLm1heCgwLCBsaW5lcy5sZW5ndGggLSAxKSkgOiAnJztcbiAgICAgICAgbGV0IGVuZCA9IHN0YXJ0ICsgaGVhZGVyLmxlbmd0aDtcbiAgICAgICAgaWYgKHNjYWxhci5zb3VyY2UpXG4gICAgICAgICAgICBlbmQgKz0gc2NhbGFyLnNvdXJjZS5sZW5ndGg7XG4gICAgICAgIHJldHVybiB7IHZhbHVlLCB0eXBlLCBjb21tZW50OiBoZWFkZXIuY29tbWVudCwgcmFuZ2U6IFtzdGFydCwgZW5kLCBlbmRdIH07XG4gICAgfVxuICAgIC8vIGZpbmQgdGhlIGluZGVudGF0aW9uIGxldmVsIHRvIHRyaW0gZnJvbSBzdGFydFxuICAgIGxldCB0cmltSW5kZW50ID0gc2NhbGFyLmluZGVudCArIGhlYWRlci5pbmRlbnQ7XG4gICAgbGV0IG9mZnNldCA9IHNjYWxhci5vZmZzZXQgKyBoZWFkZXIubGVuZ3RoO1xuICAgIGxldCBjb250ZW50U3RhcnQgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hvbXBTdGFydDsgKytpKSB7XG4gICAgICAgIGNvbnN0IFtpbmRlbnQsIGNvbnRlbnRdID0gbGluZXNbaV07XG4gICAgICAgIGlmIChjb250ZW50ID09PSAnJyB8fCBjb250ZW50ID09PSAnXFxyJykge1xuICAgICAgICAgICAgaWYgKGhlYWRlci5pbmRlbnQgPT09IDAgJiYgaW5kZW50Lmxlbmd0aCA+IHRyaW1JbmRlbnQpXG4gICAgICAgICAgICAgICAgdHJpbUluZGVudCA9IGluZGVudC5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoaW5kZW50Lmxlbmd0aCA8IHRyaW1JbmRlbnQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gJ0Jsb2NrIHNjYWxhcnMgd2l0aCBtb3JlLWluZGVudGVkIGxlYWRpbmcgZW1wdHkgbGluZXMgbXVzdCB1c2UgYW4gZXhwbGljaXQgaW5kZW50YXRpb24gaW5kaWNhdG9yJztcbiAgICAgICAgICAgICAgICBvbkVycm9yKG9mZnNldCArIGluZGVudC5sZW5ndGgsICdNSVNTSU5HX0NIQVInLCBtZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChoZWFkZXIuaW5kZW50ID09PSAwKVxuICAgICAgICAgICAgICAgIHRyaW1JbmRlbnQgPSBpbmRlbnQubGVuZ3RoO1xuICAgICAgICAgICAgY29udGVudFN0YXJ0ID0gaTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIG9mZnNldCArPSBpbmRlbnQubGVuZ3RoICsgY29udGVudC5sZW5ndGggKyAxO1xuICAgIH1cbiAgICBsZXQgdmFsdWUgPSAnJztcbiAgICBsZXQgc2VwID0gJyc7XG4gICAgbGV0IHByZXZNb3JlSW5kZW50ZWQgPSBmYWxzZTtcbiAgICAvLyBsZWFkaW5nIHdoaXRlc3BhY2UgaXMga2VwdCBpbnRhY3RcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbnRlbnRTdGFydDsgKytpKVxuICAgICAgICB2YWx1ZSArPSBsaW5lc1tpXVswXS5zbGljZSh0cmltSW5kZW50KSArICdcXG4nO1xuICAgIGZvciAobGV0IGkgPSBjb250ZW50U3RhcnQ7IGkgPCBjaG9tcFN0YXJ0OyArK2kpIHtcbiAgICAgICAgbGV0IFtpbmRlbnQsIGNvbnRlbnRdID0gbGluZXNbaV07XG4gICAgICAgIG9mZnNldCArPSBpbmRlbnQubGVuZ3RoICsgY29udGVudC5sZW5ndGggKyAxO1xuICAgICAgICBjb25zdCBjcmxmID0gY29udGVudFtjb250ZW50Lmxlbmd0aCAtIDFdID09PSAnXFxyJztcbiAgICAgICAgaWYgKGNybGYpXG4gICAgICAgICAgICBjb250ZW50ID0gY29udGVudC5zbGljZSgwLCAtMSk7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiBhbHJlYWR5IGNhdWdodCBpbiBsZXhlciAqL1xuICAgICAgICBpZiAoY29udGVudCAmJiBpbmRlbnQubGVuZ3RoIDwgdHJpbUluZGVudCkge1xuICAgICAgICAgICAgY29uc3Qgc3JjID0gaGVhZGVyLmluZGVudFxuICAgICAgICAgICAgICAgID8gJ2V4cGxpY2l0IGluZGVudGF0aW9uIGluZGljYXRvcidcbiAgICAgICAgICAgICAgICA6ICdmaXJzdCBsaW5lJztcbiAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBgQmxvY2sgc2NhbGFyIGxpbmVzIG11c3Qgbm90IGJlIGxlc3MgaW5kZW50ZWQgdGhhbiB0aGVpciAke3NyY31gO1xuICAgICAgICAgICAgb25FcnJvcihvZmZzZXQgLSBjb250ZW50Lmxlbmd0aCAtIChjcmxmID8gMiA6IDEpLCAnQkFEX0lOREVOVCcsIG1lc3NhZ2UpO1xuICAgICAgICAgICAgaW5kZW50ID0gJyc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUgPT09IFNjYWxhci5CTE9DS19MSVRFUkFMKSB7XG4gICAgICAgICAgICB2YWx1ZSArPSBzZXAgKyBpbmRlbnQuc2xpY2UodHJpbUluZGVudCkgKyBjb250ZW50O1xuICAgICAgICAgICAgc2VwID0gJ1xcbic7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaW5kZW50Lmxlbmd0aCA+IHRyaW1JbmRlbnQgfHwgY29udGVudFswXSA9PT0gJ1xcdCcpIHtcbiAgICAgICAgICAgIC8vIG1vcmUtaW5kZW50ZWQgY29udGVudCB3aXRoaW4gYSBmb2xkZWQgYmxvY2tcbiAgICAgICAgICAgIGlmIChzZXAgPT09ICcgJylcbiAgICAgICAgICAgICAgICBzZXAgPSAnXFxuJztcbiAgICAgICAgICAgIGVsc2UgaWYgKCFwcmV2TW9yZUluZGVudGVkICYmIHNlcCA9PT0gJ1xcbicpXG4gICAgICAgICAgICAgICAgc2VwID0gJ1xcblxcbic7XG4gICAgICAgICAgICB2YWx1ZSArPSBzZXAgKyBpbmRlbnQuc2xpY2UodHJpbUluZGVudCkgKyBjb250ZW50O1xuICAgICAgICAgICAgc2VwID0gJ1xcbic7XG4gICAgICAgICAgICBwcmV2TW9yZUluZGVudGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb250ZW50ID09PSAnJykge1xuICAgICAgICAgICAgLy8gZW1wdHkgbGluZVxuICAgICAgICAgICAgaWYgKHNlcCA9PT0gJ1xcbicpXG4gICAgICAgICAgICAgICAgdmFsdWUgKz0gJ1xcbic7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgc2VwID0gJ1xcbic7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YWx1ZSArPSBzZXAgKyBjb250ZW50O1xuICAgICAgICAgICAgc2VwID0gJyAnO1xuICAgICAgICAgICAgcHJldk1vcmVJbmRlbnRlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN3aXRjaCAoaGVhZGVyLmNob21wKSB7XG4gICAgICAgIGNhc2UgJy0nOlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJysnOlxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IGNob21wU3RhcnQ7IGkgPCBsaW5lcy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICB2YWx1ZSArPSAnXFxuJyArIGxpbmVzW2ldWzBdLnNsaWNlKHRyaW1JbmRlbnQpO1xuICAgICAgICAgICAgaWYgKHZhbHVlW3ZhbHVlLmxlbmd0aCAtIDFdICE9PSAnXFxuJylcbiAgICAgICAgICAgICAgICB2YWx1ZSArPSAnXFxuJztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdmFsdWUgKz0gJ1xcbic7XG4gICAgfVxuICAgIGNvbnN0IGVuZCA9IHN0YXJ0ICsgaGVhZGVyLmxlbmd0aCArIHNjYWxhci5zb3VyY2UubGVuZ3RoO1xuICAgIHJldHVybiB7IHZhbHVlLCB0eXBlLCBjb21tZW50OiBoZWFkZXIuY29tbWVudCwgcmFuZ2U6IFtzdGFydCwgZW5kLCBlbmRdIH07XG59XG5mdW5jdGlvbiBwYXJzZUJsb2NrU2NhbGFySGVhZGVyKHsgb2Zmc2V0LCBwcm9wcyB9LCBzdHJpY3QsIG9uRXJyb3IpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgc2hvdWxkIG5vdCBoYXBwZW4gKi9cbiAgICBpZiAocHJvcHNbMF0udHlwZSAhPT0gJ2Jsb2NrLXNjYWxhci1oZWFkZXInKSB7XG4gICAgICAgIG9uRXJyb3IocHJvcHNbMF0sICdJTVBPU1NJQkxFJywgJ0Jsb2NrIHNjYWxhciBoZWFkZXIgbm90IGZvdW5kJyk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCB7IHNvdXJjZSB9ID0gcHJvcHNbMF07XG4gICAgY29uc3QgbW9kZSA9IHNvdXJjZVswXTtcbiAgICBsZXQgaW5kZW50ID0gMDtcbiAgICBsZXQgY2hvbXAgPSAnJztcbiAgICBsZXQgZXJyb3IgPSAtMTtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IHNvdXJjZS5sZW5ndGg7ICsraSkge1xuICAgICAgICBjb25zdCBjaCA9IHNvdXJjZVtpXTtcbiAgICAgICAgaWYgKCFjaG9tcCAmJiAoY2ggPT09ICctJyB8fCBjaCA9PT0gJysnKSlcbiAgICAgICAgICAgIGNob21wID0gY2g7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgbiA9IE51bWJlcihjaCk7XG4gICAgICAgICAgICBpZiAoIWluZGVudCAmJiBuKVxuICAgICAgICAgICAgICAgIGluZGVudCA9IG47XG4gICAgICAgICAgICBlbHNlIGlmIChlcnJvciA9PT0gLTEpXG4gICAgICAgICAgICAgICAgZXJyb3IgPSBvZmZzZXQgKyBpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChlcnJvciAhPT0gLTEpXG4gICAgICAgIG9uRXJyb3IoZXJyb3IsICdVTkVYUEVDVEVEX1RPS0VOJywgYEJsb2NrIHNjYWxhciBoZWFkZXIgaW5jbHVkZXMgZXh0cmEgY2hhcmFjdGVyczogJHtzb3VyY2V9YCk7XG4gICAgbGV0IGhhc1NwYWNlID0gZmFsc2U7XG4gICAgbGV0IGNvbW1lbnQgPSAnJztcbiAgICBsZXQgbGVuZ3RoID0gc291cmNlLmxlbmd0aDtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IHByb3BzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IHRva2VuID0gcHJvcHNbaV07XG4gICAgICAgIHN3aXRjaCAodG9rZW4udHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnc3BhY2UnOlxuICAgICAgICAgICAgICAgIGhhc1NwYWNlID0gdHJ1ZTtcbiAgICAgICAgICAgIC8vIGZhbGx0aHJvdWdoXG4gICAgICAgICAgICBjYXNlICduZXdsaW5lJzpcbiAgICAgICAgICAgICAgICBsZW5ndGggKz0gdG9rZW4uc291cmNlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2NvbW1lbnQnOlxuICAgICAgICAgICAgICAgIGlmIChzdHJpY3QgJiYgIWhhc1NwYWNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSAnQ29tbWVudHMgbXVzdCBiZSBzZXBhcmF0ZWQgZnJvbSBvdGhlciB0b2tlbnMgYnkgd2hpdGUgc3BhY2UgY2hhcmFjdGVycyc7XG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3IodG9rZW4sICdNSVNTSU5HX0NIQVInLCBtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGVuZ3RoICs9IHRva2VuLnNvdXJjZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgY29tbWVudCA9IHRva2VuLnNvdXJjZS5zdWJzdHJpbmcoMSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdlcnJvcic6XG4gICAgICAgICAgICAgICAgb25FcnJvcih0b2tlbiwgJ1VORVhQRUNURURfVE9LRU4nLCB0b2tlbi5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICBsZW5ndGggKz0gdG9rZW4uc291cmNlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0IHNob3VsZCBub3QgaGFwcGVuICovXG4gICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IGBVbmV4cGVjdGVkIHRva2VuIGluIGJsb2NrIHNjYWxhciBoZWFkZXI6ICR7dG9rZW4udHlwZX1gO1xuICAgICAgICAgICAgICAgIG9uRXJyb3IodG9rZW4sICdVTkVYUEVDVEVEX1RPS0VOJywgbWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHMgPSB0b2tlbi5zb3VyY2U7XG4gICAgICAgICAgICAgICAgaWYgKHRzICYmIHR5cGVvZiB0cyA9PT0gJ3N0cmluZycpXG4gICAgICAgICAgICAgICAgICAgIGxlbmd0aCArPSB0cy5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgbW9kZSwgaW5kZW50LCBjaG9tcCwgY29tbWVudCwgbGVuZ3RoIH07XG59XG4vKiogQHJldHVybnMgQXJyYXkgb2YgbGluZXMgc3BsaXQgdXAgYXMgYFtpbmRlbnQsIGNvbnRlbnRdYCAqL1xuZnVuY3Rpb24gc3BsaXRMaW5lcyhzb3VyY2UpIHtcbiAgICBjb25zdCBzcGxpdCA9IHNvdXJjZS5zcGxpdCgvXFxuKCAqKS8pO1xuICAgIGNvbnN0IGZpcnN0ID0gc3BsaXRbMF07XG4gICAgY29uc3QgbSA9IGZpcnN0Lm1hdGNoKC9eKCAqKS8pO1xuICAgIGNvbnN0IGxpbmUwID0gbSAmJiBtWzFdID8gW21bMV0sIGZpcnN0LnNsaWNlKG1bMV0ubGVuZ3RoKV0gOiBbJycsIGZpcnN0XTtcbiAgICBjb25zdCBsaW5lcyA9IFtsaW5lMF07XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBzcGxpdC5sZW5ndGg7IGkgKz0gMilcbiAgICAgICAgbGluZXMucHVzaChbc3BsaXRbaV0sIHNwbGl0W2kgKyAxXV0pO1xuICAgIHJldHVybiBsaW5lcztcbn1cblxuZXhwb3J0IHsgcmVzb2x2ZUJsb2NrU2NhbGFyIH07XG4iLCAiaW1wb3J0IHsgU2NhbGFyIH0gZnJvbSAnLi4vbm9kZXMvU2NhbGFyLmpzJztcbmltcG9ydCB7IHJlc29sdmVFbmQgfSBmcm9tICcuL3Jlc29sdmUtZW5kLmpzJztcblxuZnVuY3Rpb24gcmVzb2x2ZUZsb3dTY2FsYXIoc2NhbGFyLCBzdHJpY3QsIG9uRXJyb3IpIHtcbiAgICBjb25zdCB7IG9mZnNldCwgdHlwZSwgc291cmNlLCBlbmQgfSA9IHNjYWxhcjtcbiAgICBsZXQgX3R5cGU7XG4gICAgbGV0IHZhbHVlO1xuICAgIGNvbnN0IF9vbkVycm9yID0gKHJlbCwgY29kZSwgbXNnKSA9PiBvbkVycm9yKG9mZnNldCArIHJlbCwgY29kZSwgbXNnKTtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSAnc2NhbGFyJzpcbiAgICAgICAgICAgIF90eXBlID0gU2NhbGFyLlBMQUlOO1xuICAgICAgICAgICAgdmFsdWUgPSBwbGFpblZhbHVlKHNvdXJjZSwgX29uRXJyb3IpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3NpbmdsZS1xdW90ZWQtc2NhbGFyJzpcbiAgICAgICAgICAgIF90eXBlID0gU2NhbGFyLlFVT1RFX1NJTkdMRTtcbiAgICAgICAgICAgIHZhbHVlID0gc2luZ2xlUXVvdGVkVmFsdWUoc291cmNlLCBfb25FcnJvcik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnZG91YmxlLXF1b3RlZC1zY2FsYXInOlxuICAgICAgICAgICAgX3R5cGUgPSBTY2FsYXIuUVVPVEVfRE9VQkxFO1xuICAgICAgICAgICAgdmFsdWUgPSBkb3VibGVRdW90ZWRWYWx1ZShzb3VyY2UsIF9vbkVycm9yKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCBzaG91bGQgbm90IGhhcHBlbiAqL1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgb25FcnJvcihzY2FsYXIsICdVTkVYUEVDVEVEX1RPS0VOJywgYEV4cGVjdGVkIGEgZmxvdyBzY2FsYXIgdmFsdWUsIGJ1dCBmb3VuZDogJHt0eXBlfWApO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogJycsXG4gICAgICAgICAgICAgICAgdHlwZTogbnVsbCxcbiAgICAgICAgICAgICAgICBjb21tZW50OiAnJyxcbiAgICAgICAgICAgICAgICByYW5nZTogW29mZnNldCwgb2Zmc2V0ICsgc291cmNlLmxlbmd0aCwgb2Zmc2V0ICsgc291cmNlLmxlbmd0aF1cbiAgICAgICAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHZhbHVlRW5kID0gb2Zmc2V0ICsgc291cmNlLmxlbmd0aDtcbiAgICBjb25zdCByZSA9IHJlc29sdmVFbmQoZW5kLCB2YWx1ZUVuZCwgc3RyaWN0LCBvbkVycm9yKTtcbiAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZSxcbiAgICAgICAgdHlwZTogX3R5cGUsXG4gICAgICAgIGNvbW1lbnQ6IHJlLmNvbW1lbnQsXG4gICAgICAgIHJhbmdlOiBbb2Zmc2V0LCB2YWx1ZUVuZCwgcmUub2Zmc2V0XVxuICAgIH07XG59XG5mdW5jdGlvbiBwbGFpblZhbHVlKHNvdXJjZSwgb25FcnJvcikge1xuICAgIGxldCBiYWRDaGFyID0gJyc7XG4gICAgc3dpdGNoIChzb3VyY2VbMF0pIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgc2hvdWxkIG5vdCBoYXBwZW4gKi9cbiAgICAgICAgY2FzZSAnXFx0JzpcbiAgICAgICAgICAgIGJhZENoYXIgPSAnYSB0YWIgY2hhcmFjdGVyJztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICcsJzpcbiAgICAgICAgICAgIGJhZENoYXIgPSAnZmxvdyBpbmRpY2F0b3IgY2hhcmFjdGVyICwnO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJyUnOlxuICAgICAgICAgICAgYmFkQ2hhciA9ICdkaXJlY3RpdmUgaW5kaWNhdG9yIGNoYXJhY3RlciAlJztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICd8JzpcbiAgICAgICAgY2FzZSAnPic6IHtcbiAgICAgICAgICAgIGJhZENoYXIgPSBgYmxvY2sgc2NhbGFyIGluZGljYXRvciAke3NvdXJjZVswXX1gO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnQCc6XG4gICAgICAgIGNhc2UgJ2AnOiB7XG4gICAgICAgICAgICBiYWRDaGFyID0gYHJlc2VydmVkIGNoYXJhY3RlciAke3NvdXJjZVswXX1gO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGJhZENoYXIpXG4gICAgICAgIG9uRXJyb3IoMCwgJ0JBRF9TQ0FMQVJfU1RBUlQnLCBgUGxhaW4gdmFsdWUgY2Fubm90IHN0YXJ0IHdpdGggJHtiYWRDaGFyfWApO1xuICAgIHJldHVybiBmb2xkTGluZXMoc291cmNlKTtcbn1cbmZ1bmN0aW9uIHNpbmdsZVF1b3RlZFZhbHVlKHNvdXJjZSwgb25FcnJvcikge1xuICAgIGlmIChzb3VyY2Vbc291cmNlLmxlbmd0aCAtIDFdICE9PSBcIidcIiB8fCBzb3VyY2UubGVuZ3RoID09PSAxKVxuICAgICAgICBvbkVycm9yKHNvdXJjZS5sZW5ndGgsICdNSVNTSU5HX0NIQVInLCBcIk1pc3NpbmcgY2xvc2luZyAncXVvdGVcIik7XG4gICAgcmV0dXJuIGZvbGRMaW5lcyhzb3VyY2Uuc2xpY2UoMSwgLTEpKS5yZXBsYWNlKC8nJy9nLCBcIidcIik7XG59XG5mdW5jdGlvbiBmb2xkTGluZXMoc291cmNlKSB7XG4gICAgLyoqXG4gICAgICogVGhlIG5lZ2F0aXZlIGxvb2tiZWhpbmQgaGVyZSBhbmQgaW4gdGhlIGByZWAgUmVnRXhwIGlzIHRvXG4gICAgICogcHJldmVudCBjYXVzaW5nIGEgcG9seW5vbWlhbCBzZWFyY2ggdGltZSBpbiBjZXJ0YWluIGNhc2VzLlxuICAgICAqXG4gICAgICogVGhlIHRyeS1jYXRjaCBpcyBmb3IgU2FmYXJpLCB3aGljaCBkb2Vzbid0IHN1cHBvcnQgdGhpcyB5ZXQ6XG4gICAgICogaHR0cHM6Ly9jYW5pdXNlLmNvbS9qcy1yZWdleHAtbG9va2JlaGluZFxuICAgICAqL1xuICAgIGxldCBmaXJzdCwgbGluZTtcbiAgICB0cnkge1xuICAgICAgICBmaXJzdCA9IG5ldyBSZWdFeHAoJyguKj8pKD88IVsgXFx0XSlbIFxcdF0qXFxyP1xcbicsICdzeScpO1xuICAgICAgICBsaW5lID0gbmV3IFJlZ0V4cCgnWyBcXHRdKiguKj8pKD86KD88IVsgXFx0XSlbIFxcdF0qKT9cXHI/XFxuJywgJ3N5Jyk7XG4gICAgfVxuICAgIGNhdGNoIChfKSB7XG4gICAgICAgIGZpcnN0ID0gLyguKj8pWyBcXHRdKlxccj9cXG4vc3k7XG4gICAgICAgIGxpbmUgPSAvWyBcXHRdKiguKj8pWyBcXHRdKlxccj9cXG4vc3k7XG4gICAgfVxuICAgIGxldCBtYXRjaCA9IGZpcnN0LmV4ZWMoc291cmNlKTtcbiAgICBpZiAoIW1hdGNoKVxuICAgICAgICByZXR1cm4gc291cmNlO1xuICAgIGxldCByZXMgPSBtYXRjaFsxXTtcbiAgICBsZXQgc2VwID0gJyAnO1xuICAgIGxldCBwb3MgPSBmaXJzdC5sYXN0SW5kZXg7XG4gICAgbGluZS5sYXN0SW5kZXggPSBwb3M7XG4gICAgd2hpbGUgKChtYXRjaCA9IGxpbmUuZXhlYyhzb3VyY2UpKSkge1xuICAgICAgICBpZiAobWF0Y2hbMV0gPT09ICcnKSB7XG4gICAgICAgICAgICBpZiAoc2VwID09PSAnXFxuJylcbiAgICAgICAgICAgICAgICByZXMgKz0gc2VwO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHNlcCA9ICdcXG4nO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzICs9IHNlcCArIG1hdGNoWzFdO1xuICAgICAgICAgICAgc2VwID0gJyAnO1xuICAgICAgICB9XG4gICAgICAgIHBvcyA9IGxpbmUubGFzdEluZGV4O1xuICAgIH1cbiAgICBjb25zdCBsYXN0ID0gL1sgXFx0XSooLiopL3N5O1xuICAgIGxhc3QubGFzdEluZGV4ID0gcG9zO1xuICAgIG1hdGNoID0gbGFzdC5leGVjKHNvdXJjZSk7XG4gICAgcmV0dXJuIHJlcyArIHNlcCArICgobWF0Y2ggJiYgbWF0Y2hbMV0pIHx8ICcnKTtcbn1cbmZ1bmN0aW9uIGRvdWJsZVF1b3RlZFZhbHVlKHNvdXJjZSwgb25FcnJvcikge1xuICAgIGxldCByZXMgPSAnJztcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IHNvdXJjZS5sZW5ndGggLSAxOyArK2kpIHtcbiAgICAgICAgY29uc3QgY2ggPSBzb3VyY2VbaV07XG4gICAgICAgIGlmIChjaCA9PT0gJ1xccicgJiYgc291cmNlW2kgKyAxXSA9PT0gJ1xcbicpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgaWYgKGNoID09PSAnXFxuJykge1xuICAgICAgICAgICAgY29uc3QgeyBmb2xkLCBvZmZzZXQgfSA9IGZvbGROZXdsaW5lKHNvdXJjZSwgaSk7XG4gICAgICAgICAgICByZXMgKz0gZm9sZDtcbiAgICAgICAgICAgIGkgPSBvZmZzZXQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2ggPT09ICdcXFxcJykge1xuICAgICAgICAgICAgbGV0IG5leHQgPSBzb3VyY2VbKytpXTtcbiAgICAgICAgICAgIGNvbnN0IGNjID0gZXNjYXBlQ29kZXNbbmV4dF07XG4gICAgICAgICAgICBpZiAoY2MpXG4gICAgICAgICAgICAgICAgcmVzICs9IGNjO1xuICAgICAgICAgICAgZWxzZSBpZiAobmV4dCA9PT0gJ1xcbicpIHtcbiAgICAgICAgICAgICAgICAvLyBza2lwIGVzY2FwZWQgbmV3bGluZXMsIGJ1dCBzdGlsbCB0cmltIHRoZSBmb2xsb3dpbmcgbGluZVxuICAgICAgICAgICAgICAgIG5leHQgPSBzb3VyY2VbaSArIDFdO1xuICAgICAgICAgICAgICAgIHdoaWxlIChuZXh0ID09PSAnICcgfHwgbmV4dCA9PT0gJ1xcdCcpXG4gICAgICAgICAgICAgICAgICAgIG5leHQgPSBzb3VyY2VbKytpICsgMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChuZXh0ID09PSAnXFxyJyAmJiBzb3VyY2VbaSArIDFdID09PSAnXFxuJykge1xuICAgICAgICAgICAgICAgIC8vIHNraXAgZXNjYXBlZCBDUkxGIG5ld2xpbmVzLCBidXQgc3RpbGwgdHJpbSB0aGUgZm9sbG93aW5nIGxpbmVcbiAgICAgICAgICAgICAgICBuZXh0ID0gc291cmNlWysraSArIDFdO1xuICAgICAgICAgICAgICAgIHdoaWxlIChuZXh0ID09PSAnICcgfHwgbmV4dCA9PT0gJ1xcdCcpXG4gICAgICAgICAgICAgICAgICAgIG5leHQgPSBzb3VyY2VbKytpICsgMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChuZXh0ID09PSAneCcgfHwgbmV4dCA9PT0gJ3UnIHx8IG5leHQgPT09ICdVJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IHsgeDogMiwgdTogNCwgVTogOCB9W25leHRdO1xuICAgICAgICAgICAgICAgIHJlcyArPSBwYXJzZUNoYXJDb2RlKHNvdXJjZSwgaSArIDEsIGxlbmd0aCwgb25FcnJvcik7XG4gICAgICAgICAgICAgICAgaSArPSBsZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCByYXcgPSBzb3VyY2Uuc3Vic3RyKGkgLSAxLCAyKTtcbiAgICAgICAgICAgICAgICBvbkVycm9yKGkgLSAxLCAnQkFEX0RRX0VTQ0FQRScsIGBJbnZhbGlkIGVzY2FwZSBzZXF1ZW5jZSAke3Jhd31gKTtcbiAgICAgICAgICAgICAgICByZXMgKz0gcmF3O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNoID09PSAnICcgfHwgY2ggPT09ICdcXHQnKSB7XG4gICAgICAgICAgICAvLyB0cmltIHRyYWlsaW5nIHdoaXRlc3BhY2VcbiAgICAgICAgICAgIGNvbnN0IHdzU3RhcnQgPSBpO1xuICAgICAgICAgICAgbGV0IG5leHQgPSBzb3VyY2VbaSArIDFdO1xuICAgICAgICAgICAgd2hpbGUgKG5leHQgPT09ICcgJyB8fCBuZXh0ID09PSAnXFx0JylcbiAgICAgICAgICAgICAgICBuZXh0ID0gc291cmNlWysraSArIDFdO1xuICAgICAgICAgICAgaWYgKG5leHQgIT09ICdcXG4nICYmICEobmV4dCA9PT0gJ1xccicgJiYgc291cmNlW2kgKyAyXSA9PT0gJ1xcbicpKVxuICAgICAgICAgICAgICAgIHJlcyArPSBpID4gd3NTdGFydCA/IHNvdXJjZS5zbGljZSh3c1N0YXJ0LCBpICsgMSkgOiBjaDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlcyArPSBjaDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoc291cmNlW3NvdXJjZS5sZW5ndGggLSAxXSAhPT0gJ1wiJyB8fCBzb3VyY2UubGVuZ3RoID09PSAxKVxuICAgICAgICBvbkVycm9yKHNvdXJjZS5sZW5ndGgsICdNSVNTSU5HX0NIQVInLCAnTWlzc2luZyBjbG9zaW5nIFwicXVvdGUnKTtcbiAgICByZXR1cm4gcmVzO1xufVxuLyoqXG4gKiBGb2xkIGEgc2luZ2xlIG5ld2xpbmUgaW50byBhIHNwYWNlLCBtdWx0aXBsZSBuZXdsaW5lcyB0byBOIC0gMSBuZXdsaW5lcy5cbiAqIFByZXN1bWVzIGBzb3VyY2Vbb2Zmc2V0XSA9PT0gJ1xcbidgXG4gKi9cbmZ1bmN0aW9uIGZvbGROZXdsaW5lKHNvdXJjZSwgb2Zmc2V0KSB7XG4gICAgbGV0IGZvbGQgPSAnJztcbiAgICBsZXQgY2ggPSBzb3VyY2Vbb2Zmc2V0ICsgMV07XG4gICAgd2hpbGUgKGNoID09PSAnICcgfHwgY2ggPT09ICdcXHQnIHx8IGNoID09PSAnXFxuJyB8fCBjaCA9PT0gJ1xccicpIHtcbiAgICAgICAgaWYgKGNoID09PSAnXFxyJyAmJiBzb3VyY2Vbb2Zmc2V0ICsgMl0gIT09ICdcXG4nKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGlmIChjaCA9PT0gJ1xcbicpXG4gICAgICAgICAgICBmb2xkICs9ICdcXG4nO1xuICAgICAgICBvZmZzZXQgKz0gMTtcbiAgICAgICAgY2ggPSBzb3VyY2Vbb2Zmc2V0ICsgMV07XG4gICAgfVxuICAgIGlmICghZm9sZClcbiAgICAgICAgZm9sZCA9ICcgJztcbiAgICByZXR1cm4geyBmb2xkLCBvZmZzZXQgfTtcbn1cbmNvbnN0IGVzY2FwZUNvZGVzID0ge1xuICAgICcwJzogJ1xcMCcsXG4gICAgYTogJ1xceDA3JyxcbiAgICBiOiAnXFxiJyxcbiAgICBlOiAnXFx4MWInLFxuICAgIGY6ICdcXGYnLFxuICAgIG46ICdcXG4nLFxuICAgIHI6ICdcXHInLFxuICAgIHQ6ICdcXHQnLFxuICAgIHY6ICdcXHYnLFxuICAgIE46ICdcXHUwMDg1JyxcbiAgICBfOiAnXFx1MDBhMCcsXG4gICAgTDogJ1xcdTIwMjgnLFxuICAgIFA6ICdcXHUyMDI5JyxcbiAgICAnICc6ICcgJyxcbiAgICAnXCInOiAnXCInLFxuICAgICcvJzogJy8nLFxuICAgICdcXFxcJzogJ1xcXFwnLFxuICAgICdcXHQnOiAnXFx0J1xufTtcbmZ1bmN0aW9uIHBhcnNlQ2hhckNvZGUoc291cmNlLCBvZmZzZXQsIGxlbmd0aCwgb25FcnJvcikge1xuICAgIGNvbnN0IGNjID0gc291cmNlLnN1YnN0cihvZmZzZXQsIGxlbmd0aCk7XG4gICAgY29uc3Qgb2sgPSBjYy5sZW5ndGggPT09IGxlbmd0aCAmJiAvXlswLTlhLWZBLUZdKyQvLnRlc3QoY2MpO1xuICAgIGNvbnN0IGNvZGUgPSBvayA/IHBhcnNlSW50KGNjLCAxNikgOiBOYU47XG4gICAgaWYgKGlzTmFOKGNvZGUpKSB7XG4gICAgICAgIGNvbnN0IHJhdyA9IHNvdXJjZS5zdWJzdHIob2Zmc2V0IC0gMiwgbGVuZ3RoICsgMik7XG4gICAgICAgIG9uRXJyb3Iob2Zmc2V0IC0gMiwgJ0JBRF9EUV9FU0NBUEUnLCBgSW52YWxpZCBlc2NhcGUgc2VxdWVuY2UgJHtyYXd9YCk7XG4gICAgICAgIHJldHVybiByYXc7XG4gICAgfVxuICAgIHJldHVybiBTdHJpbmcuZnJvbUNvZGVQb2ludChjb2RlKTtcbn1cblxuZXhwb3J0IHsgcmVzb2x2ZUZsb3dTY2FsYXIgfTtcbiIsICJpbXBvcnQgeyBTQ0FMQVIsIGlzU2NhbGFyIH0gZnJvbSAnLi4vbm9kZXMvTm9kZS5qcyc7XG5pbXBvcnQgeyBTY2FsYXIgfSBmcm9tICcuLi9ub2Rlcy9TY2FsYXIuanMnO1xuaW1wb3J0IHsgcmVzb2x2ZUJsb2NrU2NhbGFyIH0gZnJvbSAnLi9yZXNvbHZlLWJsb2NrLXNjYWxhci5qcyc7XG5pbXBvcnQgeyByZXNvbHZlRmxvd1NjYWxhciB9IGZyb20gJy4vcmVzb2x2ZS1mbG93LXNjYWxhci5qcyc7XG5cbmZ1bmN0aW9uIGNvbXBvc2VTY2FsYXIoY3R4LCB0b2tlbiwgdGFnVG9rZW4sIG9uRXJyb3IpIHtcbiAgICBjb25zdCB7IHZhbHVlLCB0eXBlLCBjb21tZW50LCByYW5nZSB9ID0gdG9rZW4udHlwZSA9PT0gJ2Jsb2NrLXNjYWxhcidcbiAgICAgICAgPyByZXNvbHZlQmxvY2tTY2FsYXIodG9rZW4sIGN0eC5vcHRpb25zLnN0cmljdCwgb25FcnJvcilcbiAgICAgICAgOiByZXNvbHZlRmxvd1NjYWxhcih0b2tlbiwgY3R4Lm9wdGlvbnMuc3RyaWN0LCBvbkVycm9yKTtcbiAgICBjb25zdCB0YWdOYW1lID0gdGFnVG9rZW5cbiAgICAgICAgPyBjdHguZGlyZWN0aXZlcy50YWdOYW1lKHRhZ1Rva2VuLnNvdXJjZSwgbXNnID0+IG9uRXJyb3IodGFnVG9rZW4sICdUQUdfUkVTT0xWRV9GQUlMRUQnLCBtc2cpKVxuICAgICAgICA6IG51bGw7XG4gICAgY29uc3QgdGFnID0gdGFnVG9rZW4gJiYgdGFnTmFtZVxuICAgICAgICA/IGZpbmRTY2FsYXJUYWdCeU5hbWUoY3R4LnNjaGVtYSwgdmFsdWUsIHRhZ05hbWUsIHRhZ1Rva2VuLCBvbkVycm9yKVxuICAgICAgICA6IHRva2VuLnR5cGUgPT09ICdzY2FsYXInXG4gICAgICAgICAgICA/IGZpbmRTY2FsYXJUYWdCeVRlc3QoY3R4LCB2YWx1ZSwgdG9rZW4sIG9uRXJyb3IpXG4gICAgICAgICAgICA6IGN0eC5zY2hlbWFbU0NBTEFSXTtcbiAgICBsZXQgc2NhbGFyO1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlcyA9IHRhZy5yZXNvbHZlKHZhbHVlLCBtc2cgPT4gb25FcnJvcih0YWdUb2tlbiB8fCB0b2tlbiwgJ1RBR19SRVNPTFZFX0ZBSUxFRCcsIG1zZyksIGN0eC5vcHRpb25zKTtcbiAgICAgICAgc2NhbGFyID0gaXNTY2FsYXIocmVzKSA/IHJlcyA6IG5ldyBTY2FsYXIocmVzKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnN0IG1zZyA9IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKTtcbiAgICAgICAgb25FcnJvcih0YWdUb2tlbiB8fCB0b2tlbiwgJ1RBR19SRVNPTFZFX0ZBSUxFRCcsIG1zZyk7XG4gICAgICAgIHNjYWxhciA9IG5ldyBTY2FsYXIodmFsdWUpO1xuICAgIH1cbiAgICBzY2FsYXIucmFuZ2UgPSByYW5nZTtcbiAgICBzY2FsYXIuc291cmNlID0gdmFsdWU7XG4gICAgaWYgKHR5cGUpXG4gICAgICAgIHNjYWxhci50eXBlID0gdHlwZTtcbiAgICBpZiAodGFnTmFtZSlcbiAgICAgICAgc2NhbGFyLnRhZyA9IHRhZ05hbWU7XG4gICAgaWYgKHRhZy5mb3JtYXQpXG4gICAgICAgIHNjYWxhci5mb3JtYXQgPSB0YWcuZm9ybWF0O1xuICAgIGlmIChjb21tZW50KVxuICAgICAgICBzY2FsYXIuY29tbWVudCA9IGNvbW1lbnQ7XG4gICAgcmV0dXJuIHNjYWxhcjtcbn1cbmZ1bmN0aW9uIGZpbmRTY2FsYXJUYWdCeU5hbWUoc2NoZW1hLCB2YWx1ZSwgdGFnTmFtZSwgdGFnVG9rZW4sIG9uRXJyb3IpIHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKHRhZ05hbWUgPT09ICchJylcbiAgICAgICAgcmV0dXJuIHNjaGVtYVtTQ0FMQVJdOyAvLyBub24tc3BlY2lmaWMgdGFnXG4gICAgY29uc3QgbWF0Y2hXaXRoVGVzdCA9IFtdO1xuICAgIGZvciAoY29uc3QgdGFnIG9mIHNjaGVtYS50YWdzKSB7XG4gICAgICAgIGlmICghdGFnLmNvbGxlY3Rpb24gJiYgdGFnLnRhZyA9PT0gdGFnTmFtZSkge1xuICAgICAgICAgICAgaWYgKHRhZy5kZWZhdWx0ICYmIHRhZy50ZXN0KVxuICAgICAgICAgICAgICAgIG1hdGNoV2l0aFRlc3QucHVzaCh0YWcpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHJldHVybiB0YWc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCB0YWcgb2YgbWF0Y2hXaXRoVGVzdClcbiAgICAgICAgaWYgKChfYSA9IHRhZy50ZXN0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudGVzdCh2YWx1ZSkpXG4gICAgICAgICAgICByZXR1cm4gdGFnO1xuICAgIGNvbnN0IGt0ID0gc2NoZW1hLmtub3duVGFnc1t0YWdOYW1lXTtcbiAgICBpZiAoa3QgJiYgIWt0LmNvbGxlY3Rpb24pIHtcbiAgICAgICAgLy8gRW5zdXJlIHRoYXQgdGhlIGtub3duIHRhZyBpcyBhdmFpbGFibGUgZm9yIHN0cmluZ2lmeWluZyxcbiAgICAgICAgLy8gYnV0IGRvZXMgbm90IGdldCB1c2VkIGJ5IGRlZmF1bHQuXG4gICAgICAgIHNjaGVtYS50YWdzLnB1c2goT2JqZWN0LmFzc2lnbih7fSwga3QsIHsgZGVmYXVsdDogZmFsc2UsIHRlc3Q6IHVuZGVmaW5lZCB9KSk7XG4gICAgICAgIHJldHVybiBrdDtcbiAgICB9XG4gICAgb25FcnJvcih0YWdUb2tlbiwgJ1RBR19SRVNPTFZFX0ZBSUxFRCcsIGBVbnJlc29sdmVkIHRhZzogJHt0YWdOYW1lfWAsIHRhZ05hbWUgIT09ICd0YWc6eWFtbC5vcmcsMjAwMjpzdHInKTtcbiAgICByZXR1cm4gc2NoZW1hW1NDQUxBUl07XG59XG5mdW5jdGlvbiBmaW5kU2NhbGFyVGFnQnlUZXN0KHsgZGlyZWN0aXZlcywgc2NoZW1hIH0sIHZhbHVlLCB0b2tlbiwgb25FcnJvcikge1xuICAgIGNvbnN0IHRhZyA9IHNjaGVtYS50YWdzLmZpbmQodGFnID0+IHsgdmFyIF9hOyByZXR1cm4gdGFnLmRlZmF1bHQgJiYgKChfYSA9IHRhZy50ZXN0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudGVzdCh2YWx1ZSkpOyB9KSB8fCBzY2hlbWFbU0NBTEFSXTtcbiAgICBpZiAoc2NoZW1hLmNvbXBhdCkge1xuICAgICAgICBjb25zdCBjb21wYXQgPSBzY2hlbWEuY29tcGF0LmZpbmQodGFnID0+IHsgdmFyIF9hOyByZXR1cm4gdGFnLmRlZmF1bHQgJiYgKChfYSA9IHRhZy50ZXN0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudGVzdCh2YWx1ZSkpOyB9KSB8fFxuICAgICAgICAgICAgc2NoZW1hW1NDQUxBUl07XG4gICAgICAgIGlmICh0YWcudGFnICE9PSBjb21wYXQudGFnKSB7XG4gICAgICAgICAgICBjb25zdCB0cyA9IGRpcmVjdGl2ZXMudGFnU3RyaW5nKHRhZy50YWcpO1xuICAgICAgICAgICAgY29uc3QgY3MgPSBkaXJlY3RpdmVzLnRhZ1N0cmluZyhjb21wYXQudGFnKTtcbiAgICAgICAgICAgIGNvbnN0IG1zZyA9IGBWYWx1ZSBtYXkgYmUgcGFyc2VkIGFzIGVpdGhlciAke3RzfSBvciAke2NzfWA7XG4gICAgICAgICAgICBvbkVycm9yKHRva2VuLCAnVEFHX1JFU09MVkVfRkFJTEVEJywgbXNnLCB0cnVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGFnO1xufVxuXG5leHBvcnQgeyBjb21wb3NlU2NhbGFyIH07XG4iLCAiZnVuY3Rpb24gZW1wdHlTY2FsYXJQb3NpdGlvbihvZmZzZXQsIGJlZm9yZSwgcG9zKSB7XG4gICAgaWYgKGJlZm9yZSkge1xuICAgICAgICBpZiAocG9zID09PSBudWxsKVxuICAgICAgICAgICAgcG9zID0gYmVmb3JlLmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgaSA9IHBvcyAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgICAgICBsZXQgc3QgPSBiZWZvcmVbaV07XG4gICAgICAgICAgICBzd2l0Y2ggKHN0LnR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzcGFjZSc6XG4gICAgICAgICAgICAgICAgY2FzZSAnY29tbWVudCc6XG4gICAgICAgICAgICAgICAgY2FzZSAnbmV3bGluZSc6XG4gICAgICAgICAgICAgICAgICAgIG9mZnNldCAtPSBzdC5zb3VyY2UubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFRlY2huaWNhbGx5LCBhbiBlbXB0eSBzY2FsYXIgaXMgaW1tZWRpYXRlbHkgYWZ0ZXIgdGhlIGxhc3Qgbm9uLWVtcHR5XG4gICAgICAgICAgICAvLyBub2RlLCBidXQgaXQncyBtb3JlIHVzZWZ1bCB0byBwbGFjZSBpdCBhZnRlciBhbnkgd2hpdGVzcGFjZS5cbiAgICAgICAgICAgIHN0ID0gYmVmb3JlWysraV07XG4gICAgICAgICAgICB3aGlsZSAoKHN0ID09PSBudWxsIHx8IHN0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzdC50eXBlKSA9PT0gJ3NwYWNlJykge1xuICAgICAgICAgICAgICAgIG9mZnNldCArPSBzdC5zb3VyY2UubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHN0ID0gYmVmb3JlWysraV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2Zmc2V0O1xufVxuXG5leHBvcnQgeyBlbXB0eVNjYWxhclBvc2l0aW9uIH07XG4iLCAiaW1wb3J0IHsgQWxpYXMgfSBmcm9tICcuLi9ub2Rlcy9BbGlhcy5qcyc7XG5pbXBvcnQgeyBjb21wb3NlQ29sbGVjdGlvbiB9IGZyb20gJy4vY29tcG9zZS1jb2xsZWN0aW9uLmpzJztcbmltcG9ydCB7IGNvbXBvc2VTY2FsYXIgfSBmcm9tICcuL2NvbXBvc2Utc2NhbGFyLmpzJztcbmltcG9ydCB7IHJlc29sdmVFbmQgfSBmcm9tICcuL3Jlc29sdmUtZW5kLmpzJztcbmltcG9ydCB7IGVtcHR5U2NhbGFyUG9zaXRpb24gfSBmcm9tICcuL3V0aWwtZW1wdHktc2NhbGFyLXBvc2l0aW9uLmpzJztcblxuY29uc3QgQ04gPSB7IGNvbXBvc2VOb2RlLCBjb21wb3NlRW1wdHlOb2RlIH07XG5mdW5jdGlvbiBjb21wb3NlTm9kZShjdHgsIHRva2VuLCBwcm9wcywgb25FcnJvcikge1xuICAgIGNvbnN0IHsgc3BhY2VCZWZvcmUsIGNvbW1lbnQsIGFuY2hvciwgdGFnIH0gPSBwcm9wcztcbiAgICBsZXQgbm9kZTtcbiAgICBzd2l0Y2ggKHRva2VuLnR5cGUpIHtcbiAgICAgICAgY2FzZSAnYWxpYXMnOlxuICAgICAgICAgICAgbm9kZSA9IGNvbXBvc2VBbGlhcyhjdHgsIHRva2VuLCBvbkVycm9yKTtcbiAgICAgICAgICAgIGlmIChhbmNob3IgfHwgdGFnKVxuICAgICAgICAgICAgICAgIG9uRXJyb3IodG9rZW4sICdBTElBU19QUk9QUycsICdBbiBhbGlhcyBub2RlIG11c3Qgbm90IHNwZWNpZnkgYW55IHByb3BlcnRpZXMnKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdzY2FsYXInOlxuICAgICAgICBjYXNlICdzaW5nbGUtcXVvdGVkLXNjYWxhcic6XG4gICAgICAgIGNhc2UgJ2RvdWJsZS1xdW90ZWQtc2NhbGFyJzpcbiAgICAgICAgY2FzZSAnYmxvY2stc2NhbGFyJzpcbiAgICAgICAgICAgIG5vZGUgPSBjb21wb3NlU2NhbGFyKGN0eCwgdG9rZW4sIHRhZywgb25FcnJvcik7XG4gICAgICAgICAgICBpZiAoYW5jaG9yKVxuICAgICAgICAgICAgICAgIG5vZGUuYW5jaG9yID0gYW5jaG9yLnNvdXJjZS5zdWJzdHJpbmcoMSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnYmxvY2stbWFwJzpcbiAgICAgICAgY2FzZSAnYmxvY2stc2VxJzpcbiAgICAgICAgY2FzZSAnZmxvdy1jb2xsZWN0aW9uJzpcbiAgICAgICAgICAgIG5vZGUgPSBjb21wb3NlQ29sbGVjdGlvbihDTiwgY3R4LCB0b2tlbiwgdGFnLCBvbkVycm9yKTtcbiAgICAgICAgICAgIGlmIChhbmNob3IpXG4gICAgICAgICAgICAgICAgbm9kZS5hbmNob3IgPSBhbmNob3Iuc291cmNlLnN1YnN0cmluZygxKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgY29uc29sZS5sb2codG9rZW4pO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlbiB0b2tlbiB0eXBlOiAke3Rva2VuLnR5cGV9YCk7XG4gICAgfVxuICAgIGlmIChhbmNob3IgJiYgbm9kZS5hbmNob3IgPT09ICcnKVxuICAgICAgICBvbkVycm9yKGFuY2hvciwgJ0JBRF9BTElBUycsICdBbmNob3IgY2Fubm90IGJlIGFuIGVtcHR5IHN0cmluZycpO1xuICAgIGlmIChzcGFjZUJlZm9yZSlcbiAgICAgICAgbm9kZS5zcGFjZUJlZm9yZSA9IHRydWU7XG4gICAgaWYgKGNvbW1lbnQpIHtcbiAgICAgICAgaWYgKHRva2VuLnR5cGUgPT09ICdzY2FsYXInICYmIHRva2VuLnNvdXJjZSA9PT0gJycpXG4gICAgICAgICAgICBub2RlLmNvbW1lbnQgPSBjb21tZW50O1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBub2RlLmNvbW1lbnRCZWZvcmUgPSBjb21tZW50O1xuICAgIH1cbiAgICBpZiAoY3R4Lm9wdGlvbnMua2VlcFNvdXJjZVRva2VucylcbiAgICAgICAgbm9kZS5zcmNUb2tlbiA9IHRva2VuO1xuICAgIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gY29tcG9zZUVtcHR5Tm9kZShjdHgsIG9mZnNldCwgYmVmb3JlLCBwb3MsIHsgc3BhY2VCZWZvcmUsIGNvbW1lbnQsIGFuY2hvciwgdGFnIH0sIG9uRXJyb3IpIHtcbiAgICBjb25zdCB0b2tlbiA9IHtcbiAgICAgICAgdHlwZTogJ3NjYWxhcicsXG4gICAgICAgIG9mZnNldDogZW1wdHlTY2FsYXJQb3NpdGlvbihvZmZzZXQsIGJlZm9yZSwgcG9zKSxcbiAgICAgICAgaW5kZW50OiAtMSxcbiAgICAgICAgc291cmNlOiAnJ1xuICAgIH07XG4gICAgY29uc3Qgbm9kZSA9IGNvbXBvc2VTY2FsYXIoY3R4LCB0b2tlbiwgdGFnLCBvbkVycm9yKTtcbiAgICBpZiAoYW5jaG9yKSB7XG4gICAgICAgIG5vZGUuYW5jaG9yID0gYW5jaG9yLnNvdXJjZS5zdWJzdHJpbmcoMSk7XG4gICAgICAgIGlmIChub2RlLmFuY2hvciA9PT0gJycpXG4gICAgICAgICAgICBvbkVycm9yKGFuY2hvciwgJ0JBRF9BTElBUycsICdBbmNob3IgY2Fubm90IGJlIGFuIGVtcHR5IHN0cmluZycpO1xuICAgIH1cbiAgICBpZiAoc3BhY2VCZWZvcmUpXG4gICAgICAgIG5vZGUuc3BhY2VCZWZvcmUgPSB0cnVlO1xuICAgIGlmIChjb21tZW50KVxuICAgICAgICBub2RlLmNvbW1lbnQgPSBjb21tZW50O1xuICAgIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gY29tcG9zZUFsaWFzKHsgb3B0aW9ucyB9LCB7IG9mZnNldCwgc291cmNlLCBlbmQgfSwgb25FcnJvcikge1xuICAgIGNvbnN0IGFsaWFzID0gbmV3IEFsaWFzKHNvdXJjZS5zdWJzdHJpbmcoMSkpO1xuICAgIGlmIChhbGlhcy5zb3VyY2UgPT09ICcnKVxuICAgICAgICBvbkVycm9yKG9mZnNldCwgJ0JBRF9BTElBUycsICdBbGlhcyBjYW5ub3QgYmUgYW4gZW1wdHkgc3RyaW5nJyk7XG4gICAgY29uc3QgdmFsdWVFbmQgPSBvZmZzZXQgKyBzb3VyY2UubGVuZ3RoO1xuICAgIGNvbnN0IHJlID0gcmVzb2x2ZUVuZChlbmQsIHZhbHVlRW5kLCBvcHRpb25zLnN0cmljdCwgb25FcnJvcik7XG4gICAgYWxpYXMucmFuZ2UgPSBbb2Zmc2V0LCB2YWx1ZUVuZCwgcmUub2Zmc2V0XTtcbiAgICBpZiAocmUuY29tbWVudClcbiAgICAgICAgYWxpYXMuY29tbWVudCA9IHJlLmNvbW1lbnQ7XG4gICAgcmV0dXJuIGFsaWFzO1xufVxuXG5leHBvcnQgeyBjb21wb3NlRW1wdHlOb2RlLCBjb21wb3NlTm9kZSB9O1xuIiwgImltcG9ydCB7IERvY3VtZW50IH0gZnJvbSAnLi4vZG9jL0RvY3VtZW50LmpzJztcbmltcG9ydCB7IGNvbXBvc2VOb2RlLCBjb21wb3NlRW1wdHlOb2RlIH0gZnJvbSAnLi9jb21wb3NlLW5vZGUuanMnO1xuaW1wb3J0IHsgcmVzb2x2ZUVuZCB9IGZyb20gJy4vcmVzb2x2ZS1lbmQuanMnO1xuaW1wb3J0IHsgcmVzb2x2ZVByb3BzIH0gZnJvbSAnLi9yZXNvbHZlLXByb3BzLmpzJztcblxuZnVuY3Rpb24gY29tcG9zZURvYyhvcHRpb25zLCBkaXJlY3RpdmVzLCB7IG9mZnNldCwgc3RhcnQsIHZhbHVlLCBlbmQgfSwgb25FcnJvcikge1xuICAgIGNvbnN0IG9wdHMgPSBPYmplY3QuYXNzaWduKHsgZGlyZWN0aXZlcyB9LCBvcHRpb25zKTtcbiAgICBjb25zdCBkb2MgPSBuZXcgRG9jdW1lbnQodW5kZWZpbmVkLCBvcHRzKTtcbiAgICBjb25zdCBjdHggPSB7XG4gICAgICAgIGF0Um9vdDogdHJ1ZSxcbiAgICAgICAgZGlyZWN0aXZlczogZG9jLmRpcmVjdGl2ZXMsXG4gICAgICAgIG9wdGlvbnM6IGRvYy5vcHRpb25zLFxuICAgICAgICBzY2hlbWE6IGRvYy5zY2hlbWFcbiAgICB9O1xuICAgIGNvbnN0IHByb3BzID0gcmVzb2x2ZVByb3BzKHN0YXJ0LCB7XG4gICAgICAgIGluZGljYXRvcjogJ2RvYy1zdGFydCcsXG4gICAgICAgIG5leHQ6IHZhbHVlIHx8IChlbmQgPT09IG51bGwgfHwgZW5kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlbmRbMF0pLFxuICAgICAgICBvZmZzZXQsXG4gICAgICAgIG9uRXJyb3IsXG4gICAgICAgIHN0YXJ0T25OZXdsaW5lOiB0cnVlXG4gICAgfSk7XG4gICAgaWYgKHByb3BzLmZvdW5kKSB7XG4gICAgICAgIGRvYy5kaXJlY3RpdmVzLm1hcmtlciA9IHRydWU7XG4gICAgICAgIGlmICh2YWx1ZSAmJlxuICAgICAgICAgICAgKHZhbHVlLnR5cGUgPT09ICdibG9jay1tYXAnIHx8IHZhbHVlLnR5cGUgPT09ICdibG9jay1zZXEnKSAmJlxuICAgICAgICAgICAgIXByb3BzLmhhc05ld2xpbmUpXG4gICAgICAgICAgICBvbkVycm9yKHByb3BzLmVuZCwgJ01JU1NJTkdfQ0hBUicsICdCbG9jayBjb2xsZWN0aW9uIGNhbm5vdCBzdGFydCBvbiBzYW1lIGxpbmUgd2l0aCBkaXJlY3RpdmVzLWVuZCBtYXJrZXInKTtcbiAgICB9XG4gICAgZG9jLmNvbnRlbnRzID0gdmFsdWVcbiAgICAgICAgPyBjb21wb3NlTm9kZShjdHgsIHZhbHVlLCBwcm9wcywgb25FcnJvcilcbiAgICAgICAgOiBjb21wb3NlRW1wdHlOb2RlKGN0eCwgcHJvcHMuZW5kLCBzdGFydCwgbnVsbCwgcHJvcHMsIG9uRXJyb3IpO1xuICAgIGNvbnN0IGNvbnRlbnRFbmQgPSBkb2MuY29udGVudHMucmFuZ2VbMl07XG4gICAgY29uc3QgcmUgPSByZXNvbHZlRW5kKGVuZCwgY29udGVudEVuZCwgZmFsc2UsIG9uRXJyb3IpO1xuICAgIGlmIChyZS5jb21tZW50KVxuICAgICAgICBkb2MuY29tbWVudCA9IHJlLmNvbW1lbnQ7XG4gICAgZG9jLnJhbmdlID0gW29mZnNldCwgY29udGVudEVuZCwgcmUub2Zmc2V0XTtcbiAgICByZXR1cm4gZG9jO1xufVxuXG5leHBvcnQgeyBjb21wb3NlRG9jIH07XG4iLCAiaW1wb3J0IHsgRGlyZWN0aXZlcyB9IGZyb20gJy4uL2RvYy9kaXJlY3RpdmVzLmpzJztcbmltcG9ydCB7IERvY3VtZW50IH0gZnJvbSAnLi4vZG9jL0RvY3VtZW50LmpzJztcbmltcG9ydCB7IFlBTUxXYXJuaW5nLCBZQU1MUGFyc2VFcnJvciB9IGZyb20gJy4uL2Vycm9ycy5qcyc7XG5pbXBvcnQgeyBpc0NvbGxlY3Rpb24sIGlzUGFpciB9IGZyb20gJy4uL25vZGVzL05vZGUuanMnO1xuaW1wb3J0IHsgZGVmYXVsdE9wdGlvbnMgfSBmcm9tICcuLi9vcHRpb25zLmpzJztcbmltcG9ydCB7IGNvbXBvc2VEb2MgfSBmcm9tICcuL2NvbXBvc2UtZG9jLmpzJztcbmltcG9ydCB7IHJlc29sdmVFbmQgfSBmcm9tICcuL3Jlc29sdmUtZW5kLmpzJztcblxuZnVuY3Rpb24gZ2V0RXJyb3JQb3Moc3JjKSB7XG4gICAgaWYgKHR5cGVvZiBzcmMgPT09ICdudW1iZXInKVxuICAgICAgICByZXR1cm4gW3NyYywgc3JjICsgMV07XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoc3JjKSlcbiAgICAgICAgcmV0dXJuIHNyYy5sZW5ndGggPT09IDIgPyBzcmMgOiBbc3JjWzBdLCBzcmNbMV1dO1xuICAgIGNvbnN0IHsgb2Zmc2V0LCBzb3VyY2UgfSA9IHNyYztcbiAgICByZXR1cm4gW29mZnNldCwgb2Zmc2V0ICsgKHR5cGVvZiBzb3VyY2UgPT09ICdzdHJpbmcnID8gc291cmNlLmxlbmd0aCA6IDEpXTtcbn1cbmZ1bmN0aW9uIHBhcnNlUHJlbHVkZShwcmVsdWRlKSB7XG4gICAgdmFyIF9hO1xuICAgIGxldCBjb21tZW50ID0gJyc7XG4gICAgbGV0IGF0Q29tbWVudCA9IGZhbHNlO1xuICAgIGxldCBhZnRlckVtcHR5TGluZSA9IGZhbHNlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJlbHVkZS5sZW5ndGg7ICsraSkge1xuICAgICAgICBjb25zdCBzb3VyY2UgPSBwcmVsdWRlW2ldO1xuICAgICAgICBzd2l0Y2ggKHNvdXJjZVswXSkge1xuICAgICAgICAgICAgY2FzZSAnIyc6XG4gICAgICAgICAgICAgICAgY29tbWVudCArPVxuICAgICAgICAgICAgICAgICAgICAoY29tbWVudCA9PT0gJycgPyAnJyA6IGFmdGVyRW1wdHlMaW5lID8gJ1xcblxcbicgOiAnXFxuJykgK1xuICAgICAgICAgICAgICAgICAgICAgICAgKHNvdXJjZS5zdWJzdHJpbmcoMSkgfHwgJyAnKTtcbiAgICAgICAgICAgICAgICBhdENvbW1lbnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGFmdGVyRW1wdHlMaW5lID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICclJzpcbiAgICAgICAgICAgICAgICBpZiAoKChfYSA9IHByZWx1ZGVbaSArIDFdKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbMF0pICE9PSAnIycpXG4gICAgICAgICAgICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgICAgICAgICBhdENvbW1lbnQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBtYXkgYmUgd3JvbmcgYWZ0ZXIgZG9jLWVuZCwgYnV0IGluIHRoYXQgY2FzZSBpdCBkb2Vzbid0IG1hdHRlclxuICAgICAgICAgICAgICAgIGlmICghYXRDb21tZW50KVxuICAgICAgICAgICAgICAgICAgICBhZnRlckVtcHR5TGluZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgYXRDb21tZW50ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgY29tbWVudCwgYWZ0ZXJFbXB0eUxpbmUgfTtcbn1cbi8qKlxuICogQ29tcG9zZSBhIHN0cmVhbSBvZiBDU1Qgbm9kZXMgaW50byBhIHN0cmVhbSBvZiBZQU1MIERvY3VtZW50cy5cbiAqXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgQ29tcG9zZXIsIFBhcnNlciB9IGZyb20gJ3lhbWwnXG4gKlxuICogY29uc3Qgc3JjOiBzdHJpbmcgPSAuLi5cbiAqIGNvbnN0IHRva2VucyA9IG5ldyBQYXJzZXIoKS5wYXJzZShzcmMpXG4gKiBjb25zdCBkb2NzID0gbmV3IENvbXBvc2VyKCkuY29tcG9zZSh0b2tlbnMpXG4gKiBgYGBcbiAqL1xuY2xhc3MgQ29tcG9zZXIge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuICAgICAgICB0aGlzLmRvYyA9IG51bGw7XG4gICAgICAgIHRoaXMuYXREaXJlY3RpdmVzID0gZmFsc2U7XG4gICAgICAgIHRoaXMucHJlbHVkZSA9IFtdO1xuICAgICAgICB0aGlzLmVycm9ycyA9IFtdO1xuICAgICAgICB0aGlzLndhcm5pbmdzID0gW107XG4gICAgICAgIHRoaXMub25FcnJvciA9IChzb3VyY2UsIGNvZGUsIG1lc3NhZ2UsIHdhcm5pbmcpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHBvcyA9IGdldEVycm9yUG9zKHNvdXJjZSk7XG4gICAgICAgICAgICBpZiAod2FybmluZylcbiAgICAgICAgICAgICAgICB0aGlzLndhcm5pbmdzLnB1c2gobmV3IFlBTUxXYXJuaW5nKHBvcywgY29kZSwgbWVzc2FnZSkpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRoaXMuZXJyb3JzLnB1c2gobmV3IFlBTUxQYXJzZUVycm9yKHBvcywgY29kZSwgbWVzc2FnZSkpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmRpcmVjdGl2ZXMgPSBuZXcgRGlyZWN0aXZlcyh7XG4gICAgICAgICAgICB2ZXJzaW9uOiBvcHRpb25zLnZlcnNpb24gfHwgZGVmYXVsdE9wdGlvbnMudmVyc2lvblxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB9XG4gICAgZGVjb3JhdGUoZG9jLCBhZnRlckRvYykge1xuICAgICAgICBjb25zdCB7IGNvbW1lbnQsIGFmdGVyRW1wdHlMaW5lIH0gPSBwYXJzZVByZWx1ZGUodGhpcy5wcmVsdWRlKTtcbiAgICAgICAgLy9jb25zb2xlLmxvZyh7IGRjOiBkb2MuY29tbWVudCwgcHJlbHVkZSwgY29tbWVudCB9KVxuICAgICAgICBpZiAoY29tbWVudCkge1xuICAgICAgICAgICAgY29uc3QgZGMgPSBkb2MuY29udGVudHM7XG4gICAgICAgICAgICBpZiAoYWZ0ZXJEb2MpIHtcbiAgICAgICAgICAgICAgICBkb2MuY29tbWVudCA9IGRvYy5jb21tZW50ID8gYCR7ZG9jLmNvbW1lbnR9XFxuJHtjb21tZW50fWAgOiBjb21tZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYWZ0ZXJFbXB0eUxpbmUgfHwgZG9jLmRpcmVjdGl2ZXMubWFya2VyIHx8ICFkYykge1xuICAgICAgICAgICAgICAgIGRvYy5jb21tZW50QmVmb3JlID0gY29tbWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzQ29sbGVjdGlvbihkYykgJiYgIWRjLmZsb3cgJiYgZGMuaXRlbXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGxldCBpdCA9IGRjLml0ZW1zWzBdO1xuICAgICAgICAgICAgICAgIGlmIChpc1BhaXIoaXQpKVxuICAgICAgICAgICAgICAgICAgICBpdCA9IGl0LmtleTtcbiAgICAgICAgICAgICAgICBjb25zdCBjYiA9IGl0LmNvbW1lbnRCZWZvcmU7XG4gICAgICAgICAgICAgICAgaXQuY29tbWVudEJlZm9yZSA9IGNiID8gYCR7Y29tbWVudH1cXG4ke2NifWAgOiBjb21tZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2IgPSBkYy5jb21tZW50QmVmb3JlO1xuICAgICAgICAgICAgICAgIGRjLmNvbW1lbnRCZWZvcmUgPSBjYiA/IGAke2NvbW1lbnR9XFxuJHtjYn1gIDogY29tbWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYWZ0ZXJEb2MpIHtcbiAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGRvYy5lcnJvcnMsIHRoaXMuZXJyb3JzKTtcbiAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGRvYy53YXJuaW5ncywgdGhpcy53YXJuaW5ncyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkb2MuZXJyb3JzID0gdGhpcy5lcnJvcnM7XG4gICAgICAgICAgICBkb2Mud2FybmluZ3MgPSB0aGlzLndhcm5pbmdzO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucHJlbHVkZSA9IFtdO1xuICAgICAgICB0aGlzLmVycm9ycyA9IFtdO1xuICAgICAgICB0aGlzLndhcm5pbmdzID0gW107XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEN1cnJlbnQgc3RyZWFtIHN0YXR1cyBpbmZvcm1hdGlvbi5cbiAgICAgKlxuICAgICAqIE1vc3RseSB1c2VmdWwgYXQgdGhlIGVuZCBvZiBpbnB1dCBmb3IgYW4gZW1wdHkgc3RyZWFtLlxuICAgICAqL1xuICAgIHN0cmVhbUluZm8oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb21tZW50OiBwYXJzZVByZWx1ZGUodGhpcy5wcmVsdWRlKS5jb21tZW50LFxuICAgICAgICAgICAgZGlyZWN0aXZlczogdGhpcy5kaXJlY3RpdmVzLFxuICAgICAgICAgICAgZXJyb3JzOiB0aGlzLmVycm9ycyxcbiAgICAgICAgICAgIHdhcm5pbmdzOiB0aGlzLndhcm5pbmdzXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbXBvc2UgdG9rZW5zIGludG8gZG9jdW1lbnRzLlxuICAgICAqXG4gICAgICogQHBhcmFtIGZvcmNlRG9jIC0gSWYgdGhlIHN0cmVhbSBjb250YWlucyBubyBkb2N1bWVudCwgc3RpbGwgZW1pdCBhIGZpbmFsIGRvY3VtZW50IGluY2x1ZGluZyBhbnkgY29tbWVudHMgYW5kIGRpcmVjdGl2ZXMgdGhhdCB3b3VsZCBiZSBhcHBsaWVkIHRvIGEgc3Vic2VxdWVudCBkb2N1bWVudC5cbiAgICAgKiBAcGFyYW0gZW5kT2Zmc2V0IC0gU2hvdWxkIGJlIHNldCBpZiBgZm9yY2VEb2NgIGlzIGFsc28gc2V0LCB0byBzZXQgdGhlIGRvY3VtZW50IHJhbmdlIGVuZCBhbmQgdG8gaW5kaWNhdGUgZXJyb3JzIGNvcnJlY3RseS5cbiAgICAgKi9cbiAgICAqY29tcG9zZSh0b2tlbnMsIGZvcmNlRG9jID0gZmFsc2UsIGVuZE9mZnNldCA9IC0xKSB7XG4gICAgICAgIGZvciAoY29uc3QgdG9rZW4gb2YgdG9rZW5zKVxuICAgICAgICAgICAgeWllbGQqIHRoaXMubmV4dCh0b2tlbik7XG4gICAgICAgIHlpZWxkKiB0aGlzLmVuZChmb3JjZURvYywgZW5kT2Zmc2V0KTtcbiAgICB9XG4gICAgLyoqIEFkdmFuY2UgdGhlIGNvbXBvc2VyIGJ5IG9uZSBDU1QgdG9rZW4uICovXG4gICAgKm5leHQodG9rZW4pIHtcbiAgICAgICAgc3dpdGNoICh0b2tlbi50eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdkaXJlY3RpdmUnOlxuICAgICAgICAgICAgICAgIHRoaXMuZGlyZWN0aXZlcy5hZGQodG9rZW4uc291cmNlLCAob2Zmc2V0LCBtZXNzYWdlLCB3YXJuaW5nKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBvcyA9IGdldEVycm9yUG9zKHRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgcG9zWzBdICs9IG9mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vbkVycm9yKHBvcywgJ0JBRF9ESVJFQ1RJVkUnLCBtZXNzYWdlLCB3YXJuaW5nKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLnByZWx1ZGUucHVzaCh0b2tlbi5zb3VyY2UpO1xuICAgICAgICAgICAgICAgIHRoaXMuYXREaXJlY3RpdmVzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2RvY3VtZW50Jzoge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRvYyA9IGNvbXBvc2VEb2ModGhpcy5vcHRpb25zLCB0aGlzLmRpcmVjdGl2ZXMsIHRva2VuLCB0aGlzLm9uRXJyb3IpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmF0RGlyZWN0aXZlcyAmJiAhZG9jLmRpcmVjdGl2ZXMubWFya2VyKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uRXJyb3IodG9rZW4sICdNSVNTSU5HX0NIQVInLCAnTWlzc2luZyBkaXJlY3RpdmVzLWVuZCBpbmRpY2F0b3IgbGluZScpO1xuICAgICAgICAgICAgICAgIHRoaXMuZGVjb3JhdGUoZG9jLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZG9jKVxuICAgICAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLmRvYztcbiAgICAgICAgICAgICAgICB0aGlzLmRvYyA9IGRvYztcbiAgICAgICAgICAgICAgICB0aGlzLmF0RGlyZWN0aXZlcyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnYnl0ZS1vcmRlci1tYXJrJzpcbiAgICAgICAgICAgIGNhc2UgJ3NwYWNlJzpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2NvbW1lbnQnOlxuICAgICAgICAgICAgY2FzZSAnbmV3bGluZSc6XG4gICAgICAgICAgICAgICAgdGhpcy5wcmVsdWRlLnB1c2godG9rZW4uc291cmNlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2Vycm9yJzoge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1zZyA9IHRva2VuLnNvdXJjZVxuICAgICAgICAgICAgICAgICAgICA/IGAke3Rva2VuLm1lc3NhZ2V9OiAke0pTT04uc3RyaW5naWZ5KHRva2VuLnNvdXJjZSl9YFxuICAgICAgICAgICAgICAgICAgICA6IHRva2VuLm1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgWUFNTFBhcnNlRXJyb3IoZ2V0RXJyb3JQb3ModG9rZW4pLCAnVU5FWFBFQ1RFRF9UT0tFTicsIG1zZyk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYXREaXJlY3RpdmVzIHx8ICF0aGlzLmRvYylcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lcnJvcnMucHVzaChlcnJvcik7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRvYy5lcnJvcnMucHVzaChlcnJvcik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdkb2MtZW5kJzoge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5kb2MpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbXNnID0gJ1VuZXhwZWN0ZWQgZG9jLWVuZCB3aXRob3V0IHByZWNlZGluZyBkb2N1bWVudCc7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZXJyb3JzLnB1c2gobmV3IFlBTUxQYXJzZUVycm9yKGdldEVycm9yUG9zKHRva2VuKSwgJ1VORVhQRUNURURfVE9LRU4nLCBtc2cpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGVuZCA9IHJlc29sdmVFbmQodG9rZW4uZW5kLCB0b2tlbi5vZmZzZXQgKyB0b2tlbi5zb3VyY2UubGVuZ3RoLCB0aGlzLmRvYy5vcHRpb25zLnN0cmljdCwgdGhpcy5vbkVycm9yKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRlY29yYXRlKHRoaXMuZG9jLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBpZiAoZW5kLmNvbW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGMgPSB0aGlzLmRvYy5jb21tZW50O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRvYy5jb21tZW50ID0gZGMgPyBgJHtkY31cXG4ke2VuZC5jb21tZW50fWAgOiBlbmQuY29tbWVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5kb2MucmFuZ2VbMl0gPSBlbmQub2Zmc2V0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aGlzLmVycm9ycy5wdXNoKG5ldyBZQU1MUGFyc2VFcnJvcihnZXRFcnJvclBvcyh0b2tlbiksICdVTkVYUEVDVEVEX1RPS0VOJywgYFVuc3VwcG9ydGVkIHRva2VuICR7dG9rZW4udHlwZX1gKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbCBhdCBlbmQgb2YgaW5wdXQgdG8geWllbGQgYW55IHJlbWFpbmluZyBkb2N1bWVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBmb3JjZURvYyAtIElmIHRoZSBzdHJlYW0gY29udGFpbnMgbm8gZG9jdW1lbnQsIHN0aWxsIGVtaXQgYSBmaW5hbCBkb2N1bWVudCBpbmNsdWRpbmcgYW55IGNvbW1lbnRzIGFuZCBkaXJlY3RpdmVzIHRoYXQgd291bGQgYmUgYXBwbGllZCB0byBhIHN1YnNlcXVlbnQgZG9jdW1lbnQuXG4gICAgICogQHBhcmFtIGVuZE9mZnNldCAtIFNob3VsZCBiZSBzZXQgaWYgYGZvcmNlRG9jYCBpcyBhbHNvIHNldCwgdG8gc2V0IHRoZSBkb2N1bWVudCByYW5nZSBlbmQgYW5kIHRvIGluZGljYXRlIGVycm9ycyBjb3JyZWN0bHkuXG4gICAgICovXG4gICAgKmVuZChmb3JjZURvYyA9IGZhbHNlLCBlbmRPZmZzZXQgPSAtMSkge1xuICAgICAgICBpZiAodGhpcy5kb2MpIHtcbiAgICAgICAgICAgIHRoaXMuZGVjb3JhdGUodGhpcy5kb2MsIHRydWUpO1xuICAgICAgICAgICAgeWllbGQgdGhpcy5kb2M7XG4gICAgICAgICAgICB0aGlzLmRvYyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZm9yY2VEb2MpIHtcbiAgICAgICAgICAgIGNvbnN0IG9wdHMgPSBPYmplY3QuYXNzaWduKHsgZGlyZWN0aXZlczogdGhpcy5kaXJlY3RpdmVzIH0sIHRoaXMub3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBkb2MgPSBuZXcgRG9jdW1lbnQodW5kZWZpbmVkLCBvcHRzKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmF0RGlyZWN0aXZlcylcbiAgICAgICAgICAgICAgICB0aGlzLm9uRXJyb3IoZW5kT2Zmc2V0LCAnTUlTU0lOR19DSEFSJywgJ01pc3NpbmcgZGlyZWN0aXZlcy1lbmQgaW5kaWNhdG9yIGxpbmUnKTtcbiAgICAgICAgICAgIGRvYy5yYW5nZSA9IFswLCBlbmRPZmZzZXQsIGVuZE9mZnNldF07XG4gICAgICAgICAgICB0aGlzLmRlY29yYXRlKGRvYywgZmFsc2UpO1xuICAgICAgICAgICAgeWllbGQgZG9jO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgeyBDb21wb3NlciB9O1xuIiwgImV4cG9ydCB7IGNyZWF0ZVNjYWxhclRva2VuLCByZXNvbHZlQXNTY2FsYXIsIHNldFNjYWxhclZhbHVlIH0gZnJvbSAnLi9jc3Qtc2NhbGFyLmpzJztcbmV4cG9ydCB7IHN0cmluZ2lmeSB9IGZyb20gJy4vY3N0LXN0cmluZ2lmeS5qcyc7XG5leHBvcnQgeyB2aXNpdCB9IGZyb20gJy4vY3N0LXZpc2l0LmpzJztcblxuLyoqIFRoZSBieXRlIG9yZGVyIG1hcmsgKi9cbmNvbnN0IEJPTSA9ICdcXHV7RkVGRn0nO1xuLyoqIFN0YXJ0IG9mIGRvYy1tb2RlICovXG5jb25zdCBET0NVTUVOVCA9ICdcXHgwMic7IC8vIEMwOiBTdGFydCBvZiBUZXh0XG4vKiogVW5leHBlY3RlZCBlbmQgb2YgZmxvdy1tb2RlICovXG5jb25zdCBGTE9XX0VORCA9ICdcXHgxOCc7IC8vIEMwOiBDYW5jZWxcbi8qKiBOZXh0IHRva2VuIGlzIGEgc2NhbGFyIHZhbHVlICovXG5jb25zdCBTQ0FMQVIgPSAnXFx4MWYnOyAvLyBDMDogVW5pdCBTZXBhcmF0b3Jcbi8qKiBAcmV0dXJucyBgdHJ1ZWAgaWYgYHRva2VuYCBpcyBhIGZsb3cgb3IgYmxvY2sgY29sbGVjdGlvbiAqL1xuY29uc3QgaXNDb2xsZWN0aW9uID0gKHRva2VuKSA9PiAhIXRva2VuICYmICdpdGVtcycgaW4gdG9rZW47XG4vKiogQHJldHVybnMgYHRydWVgIGlmIGB0b2tlbmAgaXMgYSBmbG93IG9yIGJsb2NrIHNjYWxhcjsgbm90IGFuIGFsaWFzICovXG5jb25zdCBpc1NjYWxhciA9ICh0b2tlbikgPT4gISF0b2tlbiAmJlxuICAgICh0b2tlbi50eXBlID09PSAnc2NhbGFyJyB8fFxuICAgICAgICB0b2tlbi50eXBlID09PSAnc2luZ2xlLXF1b3RlZC1zY2FsYXInIHx8XG4gICAgICAgIHRva2VuLnR5cGUgPT09ICdkb3VibGUtcXVvdGVkLXNjYWxhcicgfHxcbiAgICAgICAgdG9rZW4udHlwZSA9PT0gJ2Jsb2NrLXNjYWxhcicpO1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbi8qKiBHZXQgYSBwcmludGFibGUgcmVwcmVzZW50YXRpb24gb2YgYSBsZXhlciB0b2tlbiAqL1xuZnVuY3Rpb24gcHJldHR5VG9rZW4odG9rZW4pIHtcbiAgICBzd2l0Y2ggKHRva2VuKSB7XG4gICAgICAgIGNhc2UgQk9NOlxuICAgICAgICAgICAgcmV0dXJuICc8Qk9NPic7XG4gICAgICAgIGNhc2UgRE9DVU1FTlQ6XG4gICAgICAgICAgICByZXR1cm4gJzxET0M+JztcbiAgICAgICAgY2FzZSBGTE9XX0VORDpcbiAgICAgICAgICAgIHJldHVybiAnPEZMT1dfRU5EPic7XG4gICAgICAgIGNhc2UgU0NBTEFSOlxuICAgICAgICAgICAgcmV0dXJuICc8U0NBTEFSPic7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodG9rZW4pO1xuICAgIH1cbn1cbi8qKiBJZGVudGlmeSB0aGUgdHlwZSBvZiBhIGxleGVyIHRva2VuLiBNYXkgcmV0dXJuIGBudWxsYCBmb3IgdW5rbm93biB0b2tlbnMuICovXG5mdW5jdGlvbiB0b2tlblR5cGUoc291cmNlKSB7XG4gICAgc3dpdGNoIChzb3VyY2UpIHtcbiAgICAgICAgY2FzZSBCT006XG4gICAgICAgICAgICByZXR1cm4gJ2J5dGUtb3JkZXItbWFyayc7XG4gICAgICAgIGNhc2UgRE9DVU1FTlQ6XG4gICAgICAgICAgICByZXR1cm4gJ2RvYy1tb2RlJztcbiAgICAgICAgY2FzZSBGTE9XX0VORDpcbiAgICAgICAgICAgIHJldHVybiAnZmxvdy1lcnJvci1lbmQnO1xuICAgICAgICBjYXNlIFNDQUxBUjpcbiAgICAgICAgICAgIHJldHVybiAnc2NhbGFyJztcbiAgICAgICAgY2FzZSAnLS0tJzpcbiAgICAgICAgICAgIHJldHVybiAnZG9jLXN0YXJ0JztcbiAgICAgICAgY2FzZSAnLi4uJzpcbiAgICAgICAgICAgIHJldHVybiAnZG9jLWVuZCc7XG4gICAgICAgIGNhc2UgJyc6XG4gICAgICAgIGNhc2UgJ1xcbic6XG4gICAgICAgIGNhc2UgJ1xcclxcbic6XG4gICAgICAgICAgICByZXR1cm4gJ25ld2xpbmUnO1xuICAgICAgICBjYXNlICctJzpcbiAgICAgICAgICAgIHJldHVybiAnc2VxLWl0ZW0taW5kJztcbiAgICAgICAgY2FzZSAnPyc6XG4gICAgICAgICAgICByZXR1cm4gJ2V4cGxpY2l0LWtleS1pbmQnO1xuICAgICAgICBjYXNlICc6JzpcbiAgICAgICAgICAgIHJldHVybiAnbWFwLXZhbHVlLWluZCc7XG4gICAgICAgIGNhc2UgJ3snOlxuICAgICAgICAgICAgcmV0dXJuICdmbG93LW1hcC1zdGFydCc7XG4gICAgICAgIGNhc2UgJ30nOlxuICAgICAgICAgICAgcmV0dXJuICdmbG93LW1hcC1lbmQnO1xuICAgICAgICBjYXNlICdbJzpcbiAgICAgICAgICAgIHJldHVybiAnZmxvdy1zZXEtc3RhcnQnO1xuICAgICAgICBjYXNlICddJzpcbiAgICAgICAgICAgIHJldHVybiAnZmxvdy1zZXEtZW5kJztcbiAgICAgICAgY2FzZSAnLCc6XG4gICAgICAgICAgICByZXR1cm4gJ2NvbW1hJztcbiAgICB9XG4gICAgc3dpdGNoIChzb3VyY2VbMF0pIHtcbiAgICAgICAgY2FzZSAnICc6XG4gICAgICAgIGNhc2UgJ1xcdCc6XG4gICAgICAgICAgICByZXR1cm4gJ3NwYWNlJztcbiAgICAgICAgY2FzZSAnIyc6XG4gICAgICAgICAgICByZXR1cm4gJ2NvbW1lbnQnO1xuICAgICAgICBjYXNlICclJzpcbiAgICAgICAgICAgIHJldHVybiAnZGlyZWN0aXZlLWxpbmUnO1xuICAgICAgICBjYXNlICcqJzpcbiAgICAgICAgICAgIHJldHVybiAnYWxpYXMnO1xuICAgICAgICBjYXNlICcmJzpcbiAgICAgICAgICAgIHJldHVybiAnYW5jaG9yJztcbiAgICAgICAgY2FzZSAnISc6XG4gICAgICAgICAgICByZXR1cm4gJ3RhZyc7XG4gICAgICAgIGNhc2UgXCInXCI6XG4gICAgICAgICAgICByZXR1cm4gJ3NpbmdsZS1xdW90ZWQtc2NhbGFyJztcbiAgICAgICAgY2FzZSAnXCInOlxuICAgICAgICAgICAgcmV0dXJuICdkb3VibGUtcXVvdGVkLXNjYWxhcic7XG4gICAgICAgIGNhc2UgJ3wnOlxuICAgICAgICBjYXNlICc+JzpcbiAgICAgICAgICAgIHJldHVybiAnYmxvY2stc2NhbGFyLWhlYWRlcic7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuXG5leHBvcnQgeyBCT00sIERPQ1VNRU5ULCBGTE9XX0VORCwgU0NBTEFSLCBpc0NvbGxlY3Rpb24sIGlzU2NhbGFyLCBwcmV0dHlUb2tlbiwgdG9rZW5UeXBlIH07XG4iLCAiaW1wb3J0IHsgcmVzb2x2ZUJsb2NrU2NhbGFyIH0gZnJvbSAnLi4vY29tcG9zZS9yZXNvbHZlLWJsb2NrLXNjYWxhci5qcyc7XG5pbXBvcnQgeyByZXNvbHZlRmxvd1NjYWxhciB9IGZyb20gJy4uL2NvbXBvc2UvcmVzb2x2ZS1mbG93LXNjYWxhci5qcyc7XG5pbXBvcnQgeyBZQU1MUGFyc2VFcnJvciB9IGZyb20gJy4uL2Vycm9ycy5qcyc7XG5pbXBvcnQgeyBzdHJpbmdpZnlTdHJpbmcgfSBmcm9tICcuLi9zdHJpbmdpZnkvc3RyaW5naWZ5U3RyaW5nLmpzJztcblxuZnVuY3Rpb24gcmVzb2x2ZUFzU2NhbGFyKHRva2VuLCBzdHJpY3QgPSB0cnVlLCBvbkVycm9yKSB7XG4gICAgaWYgKHRva2VuKSB7XG4gICAgICAgIGNvbnN0IF9vbkVycm9yID0gKHBvcywgY29kZSwgbWVzc2FnZSkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gdHlwZW9mIHBvcyA9PT0gJ251bWJlcicgPyBwb3MgOiBBcnJheS5pc0FycmF5KHBvcykgPyBwb3NbMF0gOiBwb3Mub2Zmc2V0O1xuICAgICAgICAgICAgaWYgKG9uRXJyb3IpXG4gICAgICAgICAgICAgICAgb25FcnJvcihvZmZzZXQsIGNvZGUsIG1lc3NhZ2UpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBZQU1MUGFyc2VFcnJvcihbb2Zmc2V0LCBvZmZzZXQgKyAxXSwgY29kZSwgbWVzc2FnZSk7XG4gICAgICAgIH07XG4gICAgICAgIHN3aXRjaCAodG9rZW4udHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnc2NhbGFyJzpcbiAgICAgICAgICAgIGNhc2UgJ3NpbmdsZS1xdW90ZWQtc2NhbGFyJzpcbiAgICAgICAgICAgIGNhc2UgJ2RvdWJsZS1xdW90ZWQtc2NhbGFyJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZUZsb3dTY2FsYXIodG9rZW4sIHN0cmljdCwgX29uRXJyb3IpO1xuICAgICAgICAgICAgY2FzZSAnYmxvY2stc2NhbGFyJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZUJsb2NrU2NhbGFyKHRva2VuLCBzdHJpY3QsIF9vbkVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbi8qKlxuICogQ3JlYXRlIGEgbmV3IHNjYWxhciB0b2tlbiB3aXRoIGB2YWx1ZWBcbiAqXG4gKiBWYWx1ZXMgdGhhdCByZXByZXNlbnQgYW4gYWN0dWFsIHN0cmluZyBidXQgbWF5IGJlIHBhcnNlZCBhcyBhIGRpZmZlcmVudCB0eXBlIHNob3VsZCB1c2UgYSBgdHlwZWAgb3RoZXIgdGhhbiBgJ1BMQUlOJ2AsXG4gKiBhcyB0aGlzIGZ1bmN0aW9uIGRvZXMgbm90IHN1cHBvcnQgYW55IHNjaGVtYSBvcGVyYXRpb25zIGFuZCB3b24ndCBjaGVjayBmb3Igc3VjaCBjb25mbGljdHMuXG4gKlxuICogQHBhcmFtIHZhbHVlIFRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHZhbHVlLCB3aGljaCB3aWxsIGhhdmUgaXRzIGNvbnRlbnQgcHJvcGVybHkgaW5kZW50ZWQuXG4gKiBAcGFyYW0gY29udGV4dC5lbmQgQ29tbWVudHMgYW5kIHdoaXRlc3BhY2UgYWZ0ZXIgdGhlIGVuZCBvZiB0aGUgdmFsdWUsIG9yIGFmdGVyIHRoZSBibG9jayBzY2FsYXIgaGVhZGVyLiBJZiB1bmRlZmluZWQsIGEgbmV3bGluZSB3aWxsIGJlIGFkZGVkLlxuICogQHBhcmFtIGNvbnRleHQuaW1wbGljaXRLZXkgQmVpbmcgd2l0aGluIGFuIGltcGxpY2l0IGtleSBtYXkgYWZmZWN0IHRoZSByZXNvbHZlZCB0eXBlIG9mIHRoZSB0b2tlbidzIHZhbHVlLlxuICogQHBhcmFtIGNvbnRleHQuaW5kZW50IFRoZSBpbmRlbnQgbGV2ZWwgb2YgdGhlIHRva2VuLlxuICogQHBhcmFtIGNvbnRleHQuaW5GbG93IElzIHRoaXMgc2NhbGFyIHdpdGhpbiBhIGZsb3cgY29sbGVjdGlvbj8gVGhpcyBtYXkgYWZmZWN0IHRoZSByZXNvbHZlZCB0eXBlIG9mIHRoZSB0b2tlbidzIHZhbHVlLlxuICogQHBhcmFtIGNvbnRleHQub2Zmc2V0IFRoZSBvZmZzZXQgcG9zaXRpb24gb2YgdGhlIHRva2VuLlxuICogQHBhcmFtIGNvbnRleHQudHlwZSBUaGUgcHJlZmVycmVkIHR5cGUgb2YgdGhlIHNjYWxhciB0b2tlbi4gSWYgdW5kZWZpbmVkLCB0aGUgcHJldmlvdXMgdHlwZSBvZiB0aGUgYHRva2VuYCB3aWxsIGJlIHVzZWQsIGRlZmF1bHRpbmcgdG8gYCdQTEFJTidgLlxuICovXG5mdW5jdGlvbiBjcmVhdGVTY2FsYXJUb2tlbih2YWx1ZSwgY29udGV4dCkge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCB7IGltcGxpY2l0S2V5ID0gZmFsc2UsIGluZGVudCwgaW5GbG93ID0gZmFsc2UsIG9mZnNldCA9IC0xLCB0eXBlID0gJ1BMQUlOJyB9ID0gY29udGV4dDtcbiAgICBjb25zdCBzb3VyY2UgPSBzdHJpbmdpZnlTdHJpbmcoeyB0eXBlLCB2YWx1ZSB9LCB7XG4gICAgICAgIGltcGxpY2l0S2V5LFxuICAgICAgICBpbmRlbnQ6IGluZGVudCA+IDAgPyAnICcucmVwZWF0KGluZGVudCkgOiAnJyxcbiAgICAgICAgaW5GbG93LFxuICAgICAgICBvcHRpb25zOiB7IGJsb2NrUXVvdGU6IHRydWUsIGxpbmVXaWR0aDogLTEgfVxuICAgIH0pO1xuICAgIGNvbnN0IGVuZCA9IChfYSA9IGNvbnRleHQuZW5kKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBbXG4gICAgICAgIHsgdHlwZTogJ25ld2xpbmUnLCBvZmZzZXQ6IC0xLCBpbmRlbnQsIHNvdXJjZTogJ1xcbicgfVxuICAgIF07XG4gICAgc3dpdGNoIChzb3VyY2VbMF0pIHtcbiAgICAgICAgY2FzZSAnfCc6XG4gICAgICAgIGNhc2UgJz4nOiB7XG4gICAgICAgICAgICBjb25zdCBoZSA9IHNvdXJjZS5pbmRleE9mKCdcXG4nKTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWQgPSBzb3VyY2Uuc3Vic3RyaW5nKDAsIGhlKTtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBzb3VyY2Uuc3Vic3RyaW5nKGhlICsgMSkgKyAnXFxuJztcbiAgICAgICAgICAgIGNvbnN0IHByb3BzID0gW1xuICAgICAgICAgICAgICAgIHsgdHlwZTogJ2Jsb2NrLXNjYWxhci1oZWFkZXInLCBvZmZzZXQsIGluZGVudCwgc291cmNlOiBoZWFkIH1cbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICBpZiAoIWFkZEVuZHRvQmxvY2tQcm9wcyhwcm9wcywgZW5kKSlcbiAgICAgICAgICAgICAgICBwcm9wcy5wdXNoKHsgdHlwZTogJ25ld2xpbmUnLCBvZmZzZXQ6IC0xLCBpbmRlbnQsIHNvdXJjZTogJ1xcbicgfSk7XG4gICAgICAgICAgICByZXR1cm4geyB0eXBlOiAnYmxvY2stc2NhbGFyJywgb2Zmc2V0LCBpbmRlbnQsIHByb3BzLCBzb3VyY2U6IGJvZHkgfTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdcIic6XG4gICAgICAgICAgICByZXR1cm4geyB0eXBlOiAnZG91YmxlLXF1b3RlZC1zY2FsYXInLCBvZmZzZXQsIGluZGVudCwgc291cmNlLCBlbmQgfTtcbiAgICAgICAgY2FzZSBcIidcIjpcbiAgICAgICAgICAgIHJldHVybiB7IHR5cGU6ICdzaW5nbGUtcXVvdGVkLXNjYWxhcicsIG9mZnNldCwgaW5kZW50LCBzb3VyY2UsIGVuZCB9O1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIHsgdHlwZTogJ3NjYWxhcicsIG9mZnNldCwgaW5kZW50LCBzb3VyY2UsIGVuZCB9O1xuICAgIH1cbn1cbi8qKlxuICogU2V0IHRoZSB2YWx1ZSBvZiBgdG9rZW5gIHRvIHRoZSBnaXZlbiBzdHJpbmcgYHZhbHVlYCwgb3ZlcndyaXRpbmcgYW55IHByZXZpb3VzIGNvbnRlbnRzIGFuZCB0eXBlIHRoYXQgaXQgbWF5IGhhdmUuXG4gKlxuICogQmVzdCBlZmZvcnRzIGFyZSBtYWRlIHRvIHJldGFpbiBhbnkgY29tbWVudHMgcHJldmlvdXNseSBhc3NvY2lhdGVkIHdpdGggdGhlIGB0b2tlbmAsXG4gKiB0aG91Z2ggYWxsIGNvbnRlbnRzIHdpdGhpbiBhIGNvbGxlY3Rpb24ncyBgaXRlbXNgIHdpbGwgYmUgb3ZlcndyaXR0ZW4uXG4gKlxuICogVmFsdWVzIHRoYXQgcmVwcmVzZW50IGFuIGFjdHVhbCBzdHJpbmcgYnV0IG1heSBiZSBwYXJzZWQgYXMgYSBkaWZmZXJlbnQgdHlwZSBzaG91bGQgdXNlIGEgYHR5cGVgIG90aGVyIHRoYW4gYCdQTEFJTidgLFxuICogYXMgdGhpcyBmdW5jdGlvbiBkb2VzIG5vdCBzdXBwb3J0IGFueSBzY2hlbWEgb3BlcmF0aW9ucyBhbmQgd29uJ3QgY2hlY2sgZm9yIHN1Y2ggY29uZmxpY3RzLlxuICpcbiAqIEBwYXJhbSB0b2tlbiBBbnkgdG9rZW4uIElmIGl0IGRvZXMgbm90IGluY2x1ZGUgYW4gYGluZGVudGAgdmFsdWUsIHRoZSB2YWx1ZSB3aWxsIGJlIHN0cmluZ2lmaWVkIGFzIGlmIGl0IHdlcmUgYW4gaW1wbGljaXQga2V5LlxuICogQHBhcmFtIHZhbHVlIFRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHZhbHVlLCB3aGljaCB3aWxsIGhhdmUgaXRzIGNvbnRlbnQgcHJvcGVybHkgaW5kZW50ZWQuXG4gKiBAcGFyYW0gY29udGV4dC5hZnRlcktleSBJbiBtb3N0IGNhc2VzLCB2YWx1ZXMgYWZ0ZXIgYSBrZXkgc2hvdWxkIGhhdmUgYW4gYWRkaXRpb25hbCBsZXZlbCBvZiBpbmRlbnRhdGlvbi5cbiAqIEBwYXJhbSBjb250ZXh0LmltcGxpY2l0S2V5IEJlaW5nIHdpdGhpbiBhbiBpbXBsaWNpdCBrZXkgbWF5IGFmZmVjdCB0aGUgcmVzb2x2ZWQgdHlwZSBvZiB0aGUgdG9rZW4ncyB2YWx1ZS5cbiAqIEBwYXJhbSBjb250ZXh0LmluRmxvdyBCZWluZyB3aXRoaW4gYSBmbG93IGNvbGxlY3Rpb24gbWF5IGFmZmVjdCB0aGUgcmVzb2x2ZWQgdHlwZSBvZiB0aGUgdG9rZW4ncyB2YWx1ZS5cbiAqIEBwYXJhbSBjb250ZXh0LnR5cGUgVGhlIHByZWZlcnJlZCB0eXBlIG9mIHRoZSBzY2FsYXIgdG9rZW4uIElmIHVuZGVmaW5lZCwgdGhlIHByZXZpb3VzIHR5cGUgb2YgdGhlIGB0b2tlbmAgd2lsbCBiZSB1c2VkLCBkZWZhdWx0aW5nIHRvIGAnUExBSU4nYC5cbiAqL1xuZnVuY3Rpb24gc2V0U2NhbGFyVmFsdWUodG9rZW4sIHZhbHVlLCBjb250ZXh0ID0ge30pIHtcbiAgICBsZXQgeyBhZnRlcktleSA9IGZhbHNlLCBpbXBsaWNpdEtleSA9IGZhbHNlLCBpbkZsb3cgPSBmYWxzZSwgdHlwZSB9ID0gY29udGV4dDtcbiAgICBsZXQgaW5kZW50ID0gJ2luZGVudCcgaW4gdG9rZW4gPyB0b2tlbi5pbmRlbnQgOiBudWxsO1xuICAgIGlmIChhZnRlcktleSAmJiB0eXBlb2YgaW5kZW50ID09PSAnbnVtYmVyJylcbiAgICAgICAgaW5kZW50ICs9IDI7XG4gICAgaWYgKCF0eXBlKVxuICAgICAgICBzd2l0Y2ggKHRva2VuLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ3NpbmdsZS1xdW90ZWQtc2NhbGFyJzpcbiAgICAgICAgICAgICAgICB0eXBlID0gJ1FVT1RFX1NJTkdMRSc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdkb3VibGUtcXVvdGVkLXNjYWxhcic6XG4gICAgICAgICAgICAgICAgdHlwZSA9ICdRVU9URV9ET1VCTEUnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnYmxvY2stc2NhbGFyJzoge1xuICAgICAgICAgICAgICAgIGNvbnN0IGhlYWRlciA9IHRva2VuLnByb3BzWzBdO1xuICAgICAgICAgICAgICAgIGlmIChoZWFkZXIudHlwZSAhPT0gJ2Jsb2NrLXNjYWxhci1oZWFkZXInKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYmxvY2sgc2NhbGFyIGhlYWRlcicpO1xuICAgICAgICAgICAgICAgIHR5cGUgPSBoZWFkZXIuc291cmNlWzBdID09PSAnPicgPyAnQkxPQ0tfRk9MREVEJyA6ICdCTE9DS19MSVRFUkFMJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdHlwZSA9ICdQTEFJTic7XG4gICAgICAgIH1cbiAgICBjb25zdCBzb3VyY2UgPSBzdHJpbmdpZnlTdHJpbmcoeyB0eXBlLCB2YWx1ZSB9LCB7XG4gICAgICAgIGltcGxpY2l0S2V5OiBpbXBsaWNpdEtleSB8fCBpbmRlbnQgPT09IG51bGwsXG4gICAgICAgIGluZGVudDogaW5kZW50ICE9PSBudWxsICYmIGluZGVudCA+IDAgPyAnICcucmVwZWF0KGluZGVudCkgOiAnJyxcbiAgICAgICAgaW5GbG93LFxuICAgICAgICBvcHRpb25zOiB7IGJsb2NrUXVvdGU6IHRydWUsIGxpbmVXaWR0aDogLTEgfVxuICAgIH0pO1xuICAgIHN3aXRjaCAoc291cmNlWzBdKSB7XG4gICAgICAgIGNhc2UgJ3wnOlxuICAgICAgICBjYXNlICc+JzpcbiAgICAgICAgICAgIHNldEJsb2NrU2NhbGFyVmFsdWUodG9rZW4sIHNvdXJjZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnXCInOlxuICAgICAgICAgICAgc2V0Rmxvd1NjYWxhclZhbHVlKHRva2VuLCBzb3VyY2UsICdkb3VibGUtcXVvdGVkLXNjYWxhcicpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCInXCI6XG4gICAgICAgICAgICBzZXRGbG93U2NhbGFyVmFsdWUodG9rZW4sIHNvdXJjZSwgJ3NpbmdsZS1xdW90ZWQtc2NhbGFyJyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHNldEZsb3dTY2FsYXJWYWx1ZSh0b2tlbiwgc291cmNlLCAnc2NhbGFyJyk7XG4gICAgfVxufVxuZnVuY3Rpb24gc2V0QmxvY2tTY2FsYXJWYWx1ZSh0b2tlbiwgc291cmNlKSB7XG4gICAgY29uc3QgaGUgPSBzb3VyY2UuaW5kZXhPZignXFxuJyk7XG4gICAgY29uc3QgaGVhZCA9IHNvdXJjZS5zdWJzdHJpbmcoMCwgaGUpO1xuICAgIGNvbnN0IGJvZHkgPSBzb3VyY2Uuc3Vic3RyaW5nKGhlICsgMSkgKyAnXFxuJztcbiAgICBpZiAodG9rZW4udHlwZSA9PT0gJ2Jsb2NrLXNjYWxhcicpIHtcbiAgICAgICAgY29uc3QgaGVhZGVyID0gdG9rZW4ucHJvcHNbMF07XG4gICAgICAgIGlmIChoZWFkZXIudHlwZSAhPT0gJ2Jsb2NrLXNjYWxhci1oZWFkZXInKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGJsb2NrIHNjYWxhciBoZWFkZXInKTtcbiAgICAgICAgaGVhZGVyLnNvdXJjZSA9IGhlYWQ7XG4gICAgICAgIHRva2VuLnNvdXJjZSA9IGJvZHk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCB7IG9mZnNldCB9ID0gdG9rZW47XG4gICAgICAgIGNvbnN0IGluZGVudCA9ICdpbmRlbnQnIGluIHRva2VuID8gdG9rZW4uaW5kZW50IDogLTE7XG4gICAgICAgIGNvbnN0IHByb3BzID0gW1xuICAgICAgICAgICAgeyB0eXBlOiAnYmxvY2stc2NhbGFyLWhlYWRlcicsIG9mZnNldCwgaW5kZW50LCBzb3VyY2U6IGhlYWQgfVxuICAgICAgICBdO1xuICAgICAgICBpZiAoIWFkZEVuZHRvQmxvY2tQcm9wcyhwcm9wcywgJ2VuZCcgaW4gdG9rZW4gPyB0b2tlbi5lbmQgOiB1bmRlZmluZWQpKVxuICAgICAgICAgICAgcHJvcHMucHVzaCh7IHR5cGU6ICduZXdsaW5lJywgb2Zmc2V0OiAtMSwgaW5kZW50LCBzb3VyY2U6ICdcXG4nIH0pO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyh0b2tlbikpXG4gICAgICAgICAgICBpZiAoa2V5ICE9PSAndHlwZScgJiYga2V5ICE9PSAnb2Zmc2V0JylcbiAgICAgICAgICAgICAgICBkZWxldGUgdG9rZW5ba2V5XTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbih0b2tlbiwgeyB0eXBlOiAnYmxvY2stc2NhbGFyJywgaW5kZW50LCBwcm9wcywgc291cmNlOiBib2R5IH0pO1xuICAgIH1cbn1cbi8qKiBAcmV0dXJucyBgdHJ1ZWAgaWYgbGFzdCB0b2tlbiBpcyBhIG5ld2xpbmUgKi9cbmZ1bmN0aW9uIGFkZEVuZHRvQmxvY2tQcm9wcyhwcm9wcywgZW5kKSB7XG4gICAgaWYgKGVuZClcbiAgICAgICAgZm9yIChjb25zdCBzdCBvZiBlbmQpXG4gICAgICAgICAgICBzd2l0Y2ggKHN0LnR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdzcGFjZSc6XG4gICAgICAgICAgICAgICAgY2FzZSAnY29tbWVudCc6XG4gICAgICAgICAgICAgICAgICAgIHByb3BzLnB1c2goc3QpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICduZXdsaW5lJzpcbiAgICAgICAgICAgICAgICAgICAgcHJvcHMucHVzaChzdCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHNldEZsb3dTY2FsYXJWYWx1ZSh0b2tlbiwgc291cmNlLCB0eXBlKSB7XG4gICAgc3dpdGNoICh0b2tlbi50eXBlKSB7XG4gICAgICAgIGNhc2UgJ3NjYWxhcic6XG4gICAgICAgIGNhc2UgJ2RvdWJsZS1xdW90ZWQtc2NhbGFyJzpcbiAgICAgICAgY2FzZSAnc2luZ2xlLXF1b3RlZC1zY2FsYXInOlxuICAgICAgICAgICAgdG9rZW4udHlwZSA9IHR5cGU7XG4gICAgICAgICAgICB0b2tlbi5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnYmxvY2stc2NhbGFyJzoge1xuICAgICAgICAgICAgY29uc3QgZW5kID0gdG9rZW4ucHJvcHMuc2xpY2UoMSk7XG4gICAgICAgICAgICBsZXQgb2EgPSBzb3VyY2UubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKHRva2VuLnByb3BzWzBdLnR5cGUgPT09ICdibG9jay1zY2FsYXItaGVhZGVyJylcbiAgICAgICAgICAgICAgICBvYSAtPSB0b2tlbi5wcm9wc1swXS5zb3VyY2UubGVuZ3RoO1xuICAgICAgICAgICAgZm9yIChjb25zdCB0b2sgb2YgZW5kKVxuICAgICAgICAgICAgICAgIHRvay5vZmZzZXQgKz0gb2E7XG4gICAgICAgICAgICBkZWxldGUgdG9rZW4ucHJvcHM7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHRva2VuLCB7IHR5cGUsIHNvdXJjZSwgZW5kIH0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnYmxvY2stbWFwJzpcbiAgICAgICAgY2FzZSAnYmxvY2stc2VxJzoge1xuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gdG9rZW4ub2Zmc2V0ICsgc291cmNlLmxlbmd0aDtcbiAgICAgICAgICAgIGNvbnN0IG5sID0geyB0eXBlOiAnbmV3bGluZScsIG9mZnNldCwgaW5kZW50OiB0b2tlbi5pbmRlbnQsIHNvdXJjZTogJ1xcbicgfTtcbiAgICAgICAgICAgIGRlbGV0ZSB0b2tlbi5pdGVtcztcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odG9rZW4sIHsgdHlwZSwgc291cmNlLCBlbmQ6IFtubF0gfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICBjb25zdCBpbmRlbnQgPSAnaW5kZW50JyBpbiB0b2tlbiA/IHRva2VuLmluZGVudCA6IC0xO1xuICAgICAgICAgICAgY29uc3QgZW5kID0gJ2VuZCcgaW4gdG9rZW4gJiYgQXJyYXkuaXNBcnJheSh0b2tlbi5lbmQpXG4gICAgICAgICAgICAgICAgPyB0b2tlbi5lbmQuZmlsdGVyKHN0ID0+IHN0LnR5cGUgPT09ICdzcGFjZScgfHxcbiAgICAgICAgICAgICAgICAgICAgc3QudHlwZSA9PT0gJ2NvbW1lbnQnIHx8XG4gICAgICAgICAgICAgICAgICAgIHN0LnR5cGUgPT09ICduZXdsaW5lJylcbiAgICAgICAgICAgICAgICA6IFtdO1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXModG9rZW4pKVxuICAgICAgICAgICAgICAgIGlmIChrZXkgIT09ICd0eXBlJyAmJiBrZXkgIT09ICdvZmZzZXQnKVxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdG9rZW5ba2V5XTtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odG9rZW4sIHsgdHlwZSwgaW5kZW50LCBzb3VyY2UsIGVuZCB9KTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IHsgY3JlYXRlU2NhbGFyVG9rZW4sIHJlc29sdmVBc1NjYWxhciwgc2V0U2NhbGFyVmFsdWUgfTtcbiIsICIvKipcbiAqIFN0cmluZ2lmeSBhIENTVCBkb2N1bWVudCwgdG9rZW4sIG9yIGNvbGxlY3Rpb24gaXRlbVxuICpcbiAqIEZhaXIgd2FybmluZzogVGhpcyBhcHBsaWVzIG5vIHZhbGlkYXRpb24gd2hhdHNvZXZlciwgYW5kXG4gKiBzaW1wbHkgY29uY2F0ZW5hdGVzIHRoZSBzb3VyY2VzIGluIHRoZWlyIGxvZ2ljYWwgb3JkZXIuXG4gKi9cbmNvbnN0IHN0cmluZ2lmeSA9IChjc3QpID0+ICd0eXBlJyBpbiBjc3QgPyBzdHJpbmdpZnlUb2tlbihjc3QpIDogc3RyaW5naWZ5SXRlbShjc3QpO1xuZnVuY3Rpb24gc3RyaW5naWZ5VG9rZW4odG9rZW4pIHtcbiAgICBzd2l0Y2ggKHRva2VuLnR5cGUpIHtcbiAgICAgICAgY2FzZSAnYmxvY2stc2NhbGFyJzoge1xuICAgICAgICAgICAgbGV0IHJlcyA9ICcnO1xuICAgICAgICAgICAgZm9yIChjb25zdCB0b2sgb2YgdG9rZW4ucHJvcHMpXG4gICAgICAgICAgICAgICAgcmVzICs9IHN0cmluZ2lmeVRva2VuKHRvayk7XG4gICAgICAgICAgICByZXR1cm4gcmVzICsgdG9rZW4uc291cmNlO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ2Jsb2NrLW1hcCc6XG4gICAgICAgIGNhc2UgJ2Jsb2NrLXNlcSc6IHtcbiAgICAgICAgICAgIGxldCByZXMgPSAnJztcbiAgICAgICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiB0b2tlbi5pdGVtcylcbiAgICAgICAgICAgICAgICByZXMgKz0gc3RyaW5naWZ5SXRlbShpdGVtKTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnZmxvdy1jb2xsZWN0aW9uJzoge1xuICAgICAgICAgICAgbGV0IHJlcyA9IHRva2VuLnN0YXJ0LnNvdXJjZTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiB0b2tlbi5pdGVtcylcbiAgICAgICAgICAgICAgICByZXMgKz0gc3RyaW5naWZ5SXRlbShpdGVtKTtcbiAgICAgICAgICAgIGZvciAoY29uc3Qgc3Qgb2YgdG9rZW4uZW5kKVxuICAgICAgICAgICAgICAgIHJlcyArPSBzdC5zb3VyY2U7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ2RvY3VtZW50Jzoge1xuICAgICAgICAgICAgbGV0IHJlcyA9IHN0cmluZ2lmeUl0ZW0odG9rZW4pO1xuICAgICAgICAgICAgaWYgKHRva2VuLmVuZClcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHN0IG9mIHRva2VuLmVuZClcbiAgICAgICAgICAgICAgICAgICAgcmVzICs9IHN0LnNvdXJjZTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgbGV0IHJlcyA9IHRva2VuLnNvdXJjZTtcbiAgICAgICAgICAgIGlmICgnZW5kJyBpbiB0b2tlbiAmJiB0b2tlbi5lbmQpXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBzdCBvZiB0b2tlbi5lbmQpXG4gICAgICAgICAgICAgICAgICAgIHJlcyArPSBzdC5zb3VyY2U7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gc3RyaW5naWZ5SXRlbSh7IHN0YXJ0LCBrZXksIHNlcCwgdmFsdWUgfSkge1xuICAgIGxldCByZXMgPSAnJztcbiAgICBmb3IgKGNvbnN0IHN0IG9mIHN0YXJ0KVxuICAgICAgICByZXMgKz0gc3Quc291cmNlO1xuICAgIGlmIChrZXkpXG4gICAgICAgIHJlcyArPSBzdHJpbmdpZnlUb2tlbihrZXkpO1xuICAgIGlmIChzZXApXG4gICAgICAgIGZvciAoY29uc3Qgc3Qgb2Ygc2VwKVxuICAgICAgICAgICAgcmVzICs9IHN0LnNvdXJjZTtcbiAgICBpZiAodmFsdWUpXG4gICAgICAgIHJlcyArPSBzdHJpbmdpZnlUb2tlbih2YWx1ZSk7XG4gICAgcmV0dXJuIHJlcztcbn1cblxuZXhwb3J0IHsgc3RyaW5naWZ5IH07XG4iLCAiY29uc3QgQlJFQUsgPSBTeW1ib2woJ2JyZWFrIHZpc2l0Jyk7XG5jb25zdCBTS0lQID0gU3ltYm9sKCdza2lwIGNoaWxkcmVuJyk7XG5jb25zdCBSRU1PVkUgPSBTeW1ib2woJ3JlbW92ZSBpdGVtJyk7XG4vKipcbiAqIEFwcGx5IGEgdmlzaXRvciB0byBhIENTVCBkb2N1bWVudCBvciBpdGVtLlxuICpcbiAqIFdhbGtzIHRocm91Z2ggdGhlIHRyZWUgKGRlcHRoLWZpcnN0KSBzdGFydGluZyBmcm9tIHRoZSByb290LCBjYWxsaW5nIGFcbiAqIGB2aXNpdG9yYCBmdW5jdGlvbiB3aXRoIHR3byBhcmd1bWVudHMgd2hlbiBlbnRlcmluZyBlYWNoIGl0ZW06XG4gKiAgIC0gYGl0ZW1gOiBUaGUgY3VycmVudCBpdGVtLCB3aGljaCBpbmNsdWRlZCB0aGUgZm9sbG93aW5nIG1lbWJlcnM6XG4gKiAgICAgLSBgc3RhcnQ6IFNvdXJjZVRva2VuW11gIFx1MjAxMyBTb3VyY2UgdG9rZW5zIGJlZm9yZSB0aGUga2V5IG9yIHZhbHVlLFxuICogICAgICAgcG9zc2libHkgaW5jbHVkaW5nIGl0cyBhbmNob3Igb3IgdGFnLlxuICogICAgIC0gYGtleT86IFRva2VuIHwgbnVsbGAgXHUyMDEzIFNldCBmb3IgcGFpciB2YWx1ZXMuIE1heSB0aGVuIGJlIGBudWxsYCwgaWZcbiAqICAgICAgIHRoZSBrZXkgYmVmb3JlIHRoZSBgOmAgc2VwYXJhdG9yIGlzIGVtcHR5LlxuICogICAgIC0gYHNlcD86IFNvdXJjZVRva2VuW11gIFx1MjAxMyBTb3VyY2UgdG9rZW5zIGJldHdlZW4gdGhlIGtleSBhbmQgdGhlIHZhbHVlLFxuICogICAgICAgd2hpY2ggc2hvdWxkIGluY2x1ZGUgdGhlIGA6YCBtYXAgdmFsdWUgaW5kaWNhdG9yIGlmIGB2YWx1ZWAgaXMgc2V0LlxuICogICAgIC0gYHZhbHVlPzogVG9rZW5gIFx1MjAxMyBUaGUgdmFsdWUgb2YgYSBzZXF1ZW5jZSBpdGVtLCBvciBvZiBhIG1hcCBwYWlyLlxuICogICAtIGBwYXRoYDogVGhlIHN0ZXBzIGZyb20gdGhlIHJvb3QgdG8gdGhlIGN1cnJlbnQgbm9kZSwgYXMgYW4gYXJyYXkgb2ZcbiAqICAgICBgWydrZXknIHwgJ3ZhbHVlJywgbnVtYmVyXWAgdHVwbGVzLlxuICpcbiAqIFRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIHZpc2l0b3IgbWF5IGJlIHVzZWQgdG8gY29udHJvbCB0aGUgdHJhdmVyc2FsOlxuICogICAtIGB1bmRlZmluZWRgIChkZWZhdWx0KTogRG8gbm90aGluZyBhbmQgY29udGludWVcbiAqICAgLSBgdmlzaXQuU0tJUGA6IERvIG5vdCB2aXNpdCB0aGUgY2hpbGRyZW4gb2YgdGhpcyB0b2tlbiwgY29udGludWUgd2l0aFxuICogICAgICBuZXh0IHNpYmxpbmdcbiAqICAgLSBgdmlzaXQuQlJFQUtgOiBUZXJtaW5hdGUgdHJhdmVyc2FsIGNvbXBsZXRlbHlcbiAqICAgLSBgdmlzaXQuUkVNT1ZFYDogUmVtb3ZlIHRoZSBjdXJyZW50IGl0ZW0sIHRoZW4gY29udGludWUgd2l0aCB0aGUgbmV4dCBvbmVcbiAqICAgLSBgbnVtYmVyYDogU2V0IHRoZSBpbmRleCBvZiB0aGUgbmV4dCBzdGVwLiBUaGlzIGlzIHVzZWZ1bCBlc3BlY2lhbGx5IGlmXG4gKiAgICAgdGhlIGluZGV4IG9mIHRoZSBjdXJyZW50IHRva2VuIGhhcyBjaGFuZ2VkLlxuICogICAtIGBmdW5jdGlvbmA6IERlZmluZSB0aGUgbmV4dCB2aXNpdG9yIGZvciB0aGlzIGl0ZW0uIEFmdGVyIHRoZSBvcmlnaW5hbFxuICogICAgIHZpc2l0b3IgaXMgY2FsbGVkIG9uIGl0ZW0gZW50cnksIG5leHQgdmlzaXRvcnMgYXJlIGNhbGxlZCBhZnRlciBoYW5kbGluZ1xuICogICAgIGEgbm9uLWVtcHR5IGBrZXlgIGFuZCB3aGVuIGV4aXRpbmcgdGhlIGl0ZW0uXG4gKi9cbmZ1bmN0aW9uIHZpc2l0KGNzdCwgdmlzaXRvcikge1xuICAgIGlmICgndHlwZScgaW4gY3N0ICYmIGNzdC50eXBlID09PSAnZG9jdW1lbnQnKVxuICAgICAgICBjc3QgPSB7IHN0YXJ0OiBjc3Quc3RhcnQsIHZhbHVlOiBjc3QudmFsdWUgfTtcbiAgICBfdmlzaXQoT2JqZWN0LmZyZWV6ZShbXSksIGNzdCwgdmlzaXRvcik7XG59XG4vLyBXaXRob3V0IHRoZSBgYXMgc3ltYm9sYCBjYXN0cywgVFMgZGVjbGFyZXMgdGhlc2UgaW4gdGhlIGB2aXNpdGBcbi8vIG5hbWVzcGFjZSB1c2luZyBgdmFyYCwgYnV0IHRoZW4gY29tcGxhaW5zIGFib3V0IHRoYXQgYmVjYXVzZVxuLy8gYHVuaXF1ZSBzeW1ib2xgIG11c3QgYmUgYGNvbnN0YC5cbi8qKiBUZXJtaW5hdGUgdmlzaXQgdHJhdmVyc2FsIGNvbXBsZXRlbHkgKi9cbnZpc2l0LkJSRUFLID0gQlJFQUs7XG4vKiogRG8gbm90IHZpc2l0IHRoZSBjaGlsZHJlbiBvZiB0aGUgY3VycmVudCBpdGVtICovXG52aXNpdC5TS0lQID0gU0tJUDtcbi8qKiBSZW1vdmUgdGhlIGN1cnJlbnQgaXRlbSAqL1xudmlzaXQuUkVNT1ZFID0gUkVNT1ZFO1xuLyoqIEZpbmQgdGhlIGl0ZW0gYXQgYHBhdGhgIGZyb20gYGNzdGAgYXMgdGhlIHJvb3QgKi9cbnZpc2l0Lml0ZW1BdFBhdGggPSAoY3N0LCBwYXRoKSA9PiB7XG4gICAgbGV0IGl0ZW0gPSBjc3Q7XG4gICAgZm9yIChjb25zdCBbZmllbGQsIGluZGV4XSBvZiBwYXRoKSB7XG4gICAgICAgIGNvbnN0IHRvayA9IGl0ZW0gJiYgaXRlbVtmaWVsZF07XG4gICAgICAgIGlmICh0b2sgJiYgJ2l0ZW1zJyBpbiB0b2spIHtcbiAgICAgICAgICAgIGl0ZW0gPSB0b2suaXRlbXNbaW5kZXhdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiBpdGVtO1xufTtcbi8qKlxuICogR2V0IHRoZSBpbW1lZGlhdGUgcGFyZW50IGNvbGxlY3Rpb24gb2YgdGhlIGl0ZW0gYXQgYHBhdGhgIGZyb20gYGNzdGAgYXMgdGhlIHJvb3QuXG4gKlxuICogVGhyb3dzIGFuIGVycm9yIGlmIHRoZSBjb2xsZWN0aW9uIGlzIG5vdCBmb3VuZCwgd2hpY2ggc2hvdWxkIG5ldmVyIGhhcHBlbiBpZiB0aGUgaXRlbSBpdHNlbGYgZXhpc3RzLlxuICovXG52aXNpdC5wYXJlbnRDb2xsZWN0aW9uID0gKGNzdCwgcGF0aCkgPT4ge1xuICAgIGNvbnN0IHBhcmVudCA9IHZpc2l0Lml0ZW1BdFBhdGgoY3N0LCBwYXRoLnNsaWNlKDAsIC0xKSk7XG4gICAgY29uc3QgZmllbGQgPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV1bMF07XG4gICAgY29uc3QgY29sbCA9IHBhcmVudCAmJiBwYXJlbnRbZmllbGRdO1xuICAgIGlmIChjb2xsICYmICdpdGVtcycgaW4gY29sbClcbiAgICAgICAgcmV0dXJuIGNvbGw7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdQYXJlbnQgY29sbGVjdGlvbiBub3QgZm91bmQnKTtcbn07XG5mdW5jdGlvbiBfdmlzaXQocGF0aCwgaXRlbSwgdmlzaXRvcikge1xuICAgIGxldCBjdHJsID0gdmlzaXRvcihpdGVtLCBwYXRoKTtcbiAgICBpZiAodHlwZW9mIGN0cmwgPT09ICdzeW1ib2wnKVxuICAgICAgICByZXR1cm4gY3RybDtcbiAgICBmb3IgKGNvbnN0IGZpZWxkIG9mIFsna2V5JywgJ3ZhbHVlJ10pIHtcbiAgICAgICAgY29uc3QgdG9rZW4gPSBpdGVtW2ZpZWxkXTtcbiAgICAgICAgaWYgKHRva2VuICYmICdpdGVtcycgaW4gdG9rZW4pIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdG9rZW4uaXRlbXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaSA9IF92aXNpdChPYmplY3QuZnJlZXplKHBhdGguY29uY2F0KFtbZmllbGQsIGldXSkpLCB0b2tlbi5pdGVtc1tpXSwgdmlzaXRvcik7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjaSA9PT0gJ251bWJlcicpXG4gICAgICAgICAgICAgICAgICAgIGkgPSBjaSAtIDE7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY2kgPT09IEJSRUFLKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gQlJFQUs7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY2kgPT09IFJFTU9WRSkge1xuICAgICAgICAgICAgICAgICAgICB0b2tlbi5pdGVtcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIGkgLT0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIGN0cmwgPT09ICdmdW5jdGlvbicgJiYgZmllbGQgPT09ICdrZXknKVxuICAgICAgICAgICAgICAgIGN0cmwgPSBjdHJsKGl0ZW0sIHBhdGgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0eXBlb2YgY3RybCA9PT0gJ2Z1bmN0aW9uJyA/IGN0cmwoaXRlbSwgcGF0aCkgOiBjdHJsO1xufVxuXG5leHBvcnQgeyB2aXNpdCB9O1xuIiwgImltcG9ydCB7IEJPTSwgRE9DVU1FTlQsIEZMT1dfRU5ELCBTQ0FMQVIgfSBmcm9tICcuL2NzdC5qcyc7XG5cbi8qXG5TVEFSVCAtPiBzdHJlYW1cblxuc3RyZWFtXG4gIGRpcmVjdGl2ZSAtPiBsaW5lLWVuZCAtPiBzdHJlYW1cbiAgaW5kZW50ICsgbGluZS1lbmQgLT4gc3RyZWFtXG4gIFtlbHNlXSAtPiBsaW5lLXN0YXJ0XG5cbmxpbmUtZW5kXG4gIGNvbW1lbnQgLT4gbGluZS1lbmRcbiAgbmV3bGluZSAtPiAuXG4gIGlucHV0LWVuZCAtPiBFTkRcblxubGluZS1zdGFydFxuICBkb2Mtc3RhcnQgLT4gZG9jXG4gIGRvYy1lbmQgLT4gc3RyZWFtXG4gIFtlbHNlXSAtPiBpbmRlbnQgLT4gYmxvY2stc3RhcnRcblxuYmxvY2stc3RhcnRcbiAgc2VxLWl0ZW0tc3RhcnQgLT4gYmxvY2stc3RhcnRcbiAgZXhwbGljaXQta2V5LXN0YXJ0IC0+IGJsb2NrLXN0YXJ0XG4gIG1hcC12YWx1ZS1zdGFydCAtPiBibG9jay1zdGFydFxuICBbZWxzZV0gLT4gZG9jXG5cbmRvY1xuICBsaW5lLWVuZCAtPiBsaW5lLXN0YXJ0XG4gIHNwYWNlcyAtPiBkb2NcbiAgYW5jaG9yIC0+IGRvY1xuICB0YWcgLT4gZG9jXG4gIGZsb3ctc3RhcnQgLT4gZmxvdyAtPiBkb2NcbiAgZmxvdy1lbmQgLT4gZXJyb3IgLT4gZG9jXG4gIHNlcS1pdGVtLXN0YXJ0IC0+IGVycm9yIC0+IGRvY1xuICBleHBsaWNpdC1rZXktc3RhcnQgLT4gZXJyb3IgLT4gZG9jXG4gIG1hcC12YWx1ZS1zdGFydCAtPiBkb2NcbiAgYWxpYXMgLT4gZG9jXG4gIHF1b3RlLXN0YXJ0IC0+IHF1b3RlZC1zY2FsYXIgLT4gZG9jXG4gIGJsb2NrLXNjYWxhci1oZWFkZXIgLT4gbGluZS1lbmQgLT4gYmxvY2stc2NhbGFyKG1pbikgLT4gbGluZS1zdGFydFxuICBbZWxzZV0gLT4gcGxhaW4tc2NhbGFyKGZhbHNlLCBtaW4pIC0+IGRvY1xuXG5mbG93XG4gIGxpbmUtZW5kIC0+IGZsb3dcbiAgc3BhY2VzIC0+IGZsb3dcbiAgYW5jaG9yIC0+IGZsb3dcbiAgdGFnIC0+IGZsb3dcbiAgZmxvdy1zdGFydCAtPiBmbG93IC0+IGZsb3dcbiAgZmxvdy1lbmQgLT4gLlxuICBzZXEtaXRlbS1zdGFydCAtPiBlcnJvciAtPiBmbG93XG4gIGV4cGxpY2l0LWtleS1zdGFydCAtPiBmbG93XG4gIG1hcC12YWx1ZS1zdGFydCAtPiBmbG93XG4gIGFsaWFzIC0+IGZsb3dcbiAgcXVvdGUtc3RhcnQgLT4gcXVvdGVkLXNjYWxhciAtPiBmbG93XG4gIGNvbW1hIC0+IGZsb3dcbiAgW2Vsc2VdIC0+IHBsYWluLXNjYWxhcih0cnVlLCAwKSAtPiBmbG93XG5cbnF1b3RlZC1zY2FsYXJcbiAgcXVvdGUtZW5kIC0+IC5cbiAgW2Vsc2VdIC0+IHF1b3RlZC1zY2FsYXJcblxuYmxvY2stc2NhbGFyKG1pbilcbiAgbmV3bGluZSArIHBlZWsoaW5kZW50IDwgbWluKSAtPiAuXG4gIFtlbHNlXSAtPiBibG9jay1zY2FsYXIobWluKVxuXG5wbGFpbi1zY2FsYXIoaXMtZmxvdywgbWluKVxuICBzY2FsYXItZW5kKGlzLWZsb3cpIC0+IC5cbiAgcGVlayhuZXdsaW5lICsgKGluZGVudCA8IG1pbikpIC0+IC5cbiAgW2Vsc2VdIC0+IHBsYWluLXNjYWxhcihtaW4pXG4qL1xuZnVuY3Rpb24gaXNFbXB0eShjaCkge1xuICAgIHN3aXRjaCAoY2gpIHtcbiAgICAgICAgY2FzZSB1bmRlZmluZWQ6XG4gICAgICAgIGNhc2UgJyAnOlxuICAgICAgICBjYXNlICdcXG4nOlxuICAgICAgICBjYXNlICdcXHInOlxuICAgICAgICBjYXNlICdcXHQnOlxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuY29uc3QgaGV4RGlnaXRzID0gJzAxMjM0NTY3ODlBQkNERUZhYmNkZWYnLnNwbGl0KCcnKTtcbmNvbnN0IHRhZ0NoYXJzID0gXCIwMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ei0jOy8/OkAmPSskXy4hfionKClcIi5zcGxpdCgnJyk7XG5jb25zdCBpbnZhbGlkRmxvd1NjYWxhckNoYXJzID0gJyxbXXt9Jy5zcGxpdCgnJyk7XG5jb25zdCBpbnZhbGlkQW5jaG9yQ2hhcnMgPSAnICxbXXt9XFxuXFxyXFx0Jy5zcGxpdCgnJyk7XG5jb25zdCBpc05vdEFuY2hvckNoYXIgPSAoY2gpID0+ICFjaCB8fCBpbnZhbGlkQW5jaG9yQ2hhcnMuaW5jbHVkZXMoY2gpO1xuLyoqXG4gKiBTcGxpdHMgYW4gaW5wdXQgc3RyaW5nIGludG8gbGV4aWNhbCB0b2tlbnMsIGkuZS4gc21hbGxlciBzdHJpbmdzIHRoYXQgYXJlXG4gKiBlYXNpbHkgaWRlbnRpZmlhYmxlIGJ5IGB0b2tlbnMudG9rZW5UeXBlKClgLlxuICpcbiAqIExleGluZyBzdGFydHMgYWx3YXlzIGluIGEgXCJzdHJlYW1cIiBjb250ZXh0LiBJbmNvbXBsZXRlIGlucHV0IG1heSBiZSBidWZmZXJlZFxuICogdW50aWwgYSBjb21wbGV0ZSB0b2tlbiBjYW4gYmUgZW1pdHRlZC5cbiAqXG4gKiBJbiBhZGRpdGlvbiB0byBzbGljZXMgb2YgdGhlIG9yaWdpbmFsIGlucHV0LCB0aGUgZm9sbG93aW5nIGNvbnRyb2wgY2hhcmFjdGVyc1xuICogbWF5IGFsc28gYmUgZW1pdHRlZDpcbiAqXG4gKiAtIGBcXHgwMmAgKFN0YXJ0IG9mIFRleHQpOiBBIGRvY3VtZW50IHN0YXJ0cyB3aXRoIHRoZSBuZXh0IHRva2VuXG4gKiAtIGBcXHgxOGAgKENhbmNlbCk6IFVuZXhwZWN0ZWQgZW5kIG9mIGZsb3ctbW9kZSAoaW5kaWNhdGVzIGFuIGVycm9yKVxuICogLSBgXFx4MWZgIChVbml0IFNlcGFyYXRvcik6IE5leHQgdG9rZW4gaXMgYSBzY2FsYXIgdmFsdWVcbiAqIC0gYFxcdXtGRUZGfWAgKEJ5dGUgb3JkZXIgbWFyayk6IEVtaXR0ZWQgc2VwYXJhdGVseSBvdXRzaWRlIGRvY3VtZW50c1xuICovXG5jbGFzcyBMZXhlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGbGFnIGluZGljYXRpbmcgd2hldGhlciB0aGUgZW5kIG9mIHRoZSBjdXJyZW50IGJ1ZmZlciBtYXJrcyB0aGUgZW5kIG9mXG4gICAgICAgICAqIGFsbCBpbnB1dFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hdEVuZCA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogRXhwbGljaXQgaW5kZW50IHNldCBpbiBibG9jayBzY2FsYXIgaGVhZGVyLCBhcyBhbiBvZmZzZXQgZnJvbSB0aGUgY3VycmVudFxuICAgICAgICAgKiBtaW5pbXVtIGluZGVudCwgc28gZS5nLiBzZXQgdG8gMSBmcm9tIGEgaGVhZGVyIGB8MitgLiBTZXQgdG8gLTEgaWYgbm90XG4gICAgICAgICAqIGV4cGxpY2l0bHkgc2V0LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5ibG9ja1NjYWxhckluZGVudCA9IC0xO1xuICAgICAgICAvKipcbiAgICAgICAgICogQmxvY2sgc2NhbGFycyB0aGF0IGluY2x1ZGUgYSArIChrZWVwKSBjaG9tcGluZyBpbmRpY2F0b3IgaW4gdGhlaXIgaGVhZGVyXG4gICAgICAgICAqIGluY2x1ZGUgdHJhaWxpbmcgZW1wdHkgbGluZXMsIHdoaWNoIGFyZSBvdGhlcndpc2UgZXhjbHVkZWQgZnJvbSB0aGVcbiAgICAgICAgICogc2NhbGFyJ3MgY29udGVudHMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmJsb2NrU2NhbGFyS2VlcCA9IGZhbHNlO1xuICAgICAgICAvKiogQ3VycmVudCBpbnB1dCAqL1xuICAgICAgICB0aGlzLmJ1ZmZlciA9ICcnO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmxhZyBub3Rpbmcgd2hldGhlciB0aGUgbWFwIHZhbHVlIGluZGljYXRvciA6IGNhbiBpbW1lZGlhdGVseSBmb2xsb3cgdGhpc1xuICAgICAgICAgKiBub2RlIHdpdGhpbiBhIGZsb3cgY29udGV4dC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZmxvd0tleSA9IGZhbHNlO1xuICAgICAgICAvKiogQ291bnQgb2Ygc3Vycm91bmRpbmcgZmxvdyBjb2xsZWN0aW9uIGxldmVscy4gKi9cbiAgICAgICAgdGhpcy5mbG93TGV2ZWwgPSAwO1xuICAgICAgICAvKipcbiAgICAgICAgICogTWluaW11bSBsZXZlbCBvZiBpbmRlbnRhdGlvbiByZXF1aXJlZCBmb3IgbmV4dCBsaW5lcyB0byBiZSBwYXJzZWQgYXMgYVxuICAgICAgICAgKiBwYXJ0IG9mIHRoZSBjdXJyZW50IHNjYWxhciB2YWx1ZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaW5kZW50TmV4dCA9IDA7XG4gICAgICAgIC8qKiBJbmRlbnRhdGlvbiBsZXZlbCBvZiB0aGUgY3VycmVudCBsaW5lLiAqL1xuICAgICAgICB0aGlzLmluZGVudFZhbHVlID0gMDtcbiAgICAgICAgLyoqIFBvc2l0aW9uIG9mIHRoZSBuZXh0IFxcbiBjaGFyYWN0ZXIuICovXG4gICAgICAgIHRoaXMubGluZUVuZFBvcyA9IG51bGw7XG4gICAgICAgIC8qKiBTdG9yZXMgdGhlIHN0YXRlIG9mIHRoZSBsZXhlciBpZiByZWFjaGluZyB0aGUgZW5kIG9mIGluY3BvbXBsZXRlIGlucHV0ICovXG4gICAgICAgIHRoaXMubmV4dCA9IG51bGw7XG4gICAgICAgIC8qKiBBIHBvaW50ZXIgdG8gYGJ1ZmZlcmA7IHRoZSBjdXJyZW50IHBvc2l0aW9uIG9mIHRoZSBsZXhlci4gKi9cbiAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSBZQU1MIHRva2VucyBmcm9tIHRoZSBgc291cmNlYCBzdHJpbmcuIElmIGBpbmNvbXBsZXRlYCxcbiAgICAgKiBhIHBhcnQgb2YgdGhlIGxhc3QgbGluZSBtYXkgYmUgbGVmdCBhcyBhIGJ1ZmZlciBmb3IgdGhlIG5leHQgY2FsbC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEEgZ2VuZXJhdG9yIG9mIGxleGljYWwgdG9rZW5zXG4gICAgICovXG4gICAgKmxleChzb3VyY2UsIGluY29tcGxldGUgPSBmYWxzZSkge1xuICAgICAgICBpZiAoc291cmNlKSB7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlciA9IHRoaXMuYnVmZmVyID8gdGhpcy5idWZmZXIgKyBzb3VyY2UgOiBzb3VyY2U7XG4gICAgICAgICAgICB0aGlzLmxpbmVFbmRQb3MgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYXRFbmQgPSAhaW5jb21wbGV0ZTtcbiAgICAgICAgbGV0IG5leHQgPSB0aGlzLm5leHQgfHwgJ3N0cmVhbSc7XG4gICAgICAgIHdoaWxlIChuZXh0ICYmIChpbmNvbXBsZXRlIHx8IHRoaXMuaGFzQ2hhcnMoMSkpKVxuICAgICAgICAgICAgbmV4dCA9IHlpZWxkKiB0aGlzLnBhcnNlTmV4dChuZXh0KTtcbiAgICB9XG4gICAgYXRMaW5lRW5kKCkge1xuICAgICAgICBsZXQgaSA9IHRoaXMucG9zO1xuICAgICAgICBsZXQgY2ggPSB0aGlzLmJ1ZmZlcltpXTtcbiAgICAgICAgd2hpbGUgKGNoID09PSAnICcgfHwgY2ggPT09ICdcXHQnKVxuICAgICAgICAgICAgY2ggPSB0aGlzLmJ1ZmZlclsrK2ldO1xuICAgICAgICBpZiAoIWNoIHx8IGNoID09PSAnIycgfHwgY2ggPT09ICdcXG4nKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmIChjaCA9PT0gJ1xccicpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5idWZmZXJbaSArIDFdID09PSAnXFxuJztcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjaGFyQXQobikge1xuICAgICAgICByZXR1cm4gdGhpcy5idWZmZXJbdGhpcy5wb3MgKyBuXTtcbiAgICB9XG4gICAgY29udGludWVTY2FsYXIob2Zmc2V0KSB7XG4gICAgICAgIGxldCBjaCA9IHRoaXMuYnVmZmVyW29mZnNldF07XG4gICAgICAgIGlmICh0aGlzLmluZGVudE5leHQgPiAwKSB7XG4gICAgICAgICAgICBsZXQgaW5kZW50ID0gMDtcbiAgICAgICAgICAgIHdoaWxlIChjaCA9PT0gJyAnKVxuICAgICAgICAgICAgICAgIGNoID0gdGhpcy5idWZmZXJbKytpbmRlbnQgKyBvZmZzZXRdO1xuICAgICAgICAgICAgaWYgKGNoID09PSAnXFxyJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5leHQgPSB0aGlzLmJ1ZmZlcltpbmRlbnQgKyBvZmZzZXQgKyAxXTtcbiAgICAgICAgICAgICAgICBpZiAobmV4dCA9PT0gJ1xcbicgfHwgKCFuZXh0ICYmICF0aGlzLmF0RW5kKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9mZnNldCArIGluZGVudCArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY2ggPT09ICdcXG4nIHx8IGluZGVudCA+PSB0aGlzLmluZGVudE5leHQgfHwgKCFjaCAmJiAhdGhpcy5hdEVuZClcbiAgICAgICAgICAgICAgICA/IG9mZnNldCArIGluZGVudFxuICAgICAgICAgICAgICAgIDogLTE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoID09PSAnLScgfHwgY2ggPT09ICcuJykge1xuICAgICAgICAgICAgY29uc3QgZHQgPSB0aGlzLmJ1ZmZlci5zdWJzdHIob2Zmc2V0LCAzKTtcbiAgICAgICAgICAgIGlmICgoZHQgPT09ICctLS0nIHx8IGR0ID09PSAnLi4uJykgJiYgaXNFbXB0eSh0aGlzLmJ1ZmZlcltvZmZzZXQgKyAzXSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvZmZzZXQ7XG4gICAgfVxuICAgIGdldExpbmUoKSB7XG4gICAgICAgIGxldCBlbmQgPSB0aGlzLmxpbmVFbmRQb3M7XG4gICAgICAgIGlmICh0eXBlb2YgZW5kICE9PSAnbnVtYmVyJyB8fCAoZW5kICE9PSAtMSAmJiBlbmQgPCB0aGlzLnBvcykpIHtcbiAgICAgICAgICAgIGVuZCA9IHRoaXMuYnVmZmVyLmluZGV4T2YoJ1xcbicsIHRoaXMucG9zKTtcbiAgICAgICAgICAgIHRoaXMubGluZUVuZFBvcyA9IGVuZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZW5kID09PSAtMSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmF0RW5kID8gdGhpcy5idWZmZXIuc3Vic3RyaW5nKHRoaXMucG9zKSA6IG51bGw7XG4gICAgICAgIGlmICh0aGlzLmJ1ZmZlcltlbmQgLSAxXSA9PT0gJ1xccicpXG4gICAgICAgICAgICBlbmQgLT0gMTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyLnN1YnN0cmluZyh0aGlzLnBvcywgZW5kKTtcbiAgICB9XG4gICAgaGFzQ2hhcnMobikge1xuICAgICAgICByZXR1cm4gdGhpcy5wb3MgKyBuIDw9IHRoaXMuYnVmZmVyLmxlbmd0aDtcbiAgICB9XG4gICAgc2V0TmV4dChzdGF0ZSkge1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IHRoaXMuYnVmZmVyLnN1YnN0cmluZyh0aGlzLnBvcyk7XG4gICAgICAgIHRoaXMucG9zID0gMDtcbiAgICAgICAgdGhpcy5saW5lRW5kUG9zID0gbnVsbDtcbiAgICAgICAgdGhpcy5uZXh0ID0gc3RhdGU7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBwZWVrKG4pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyLnN1YnN0cih0aGlzLnBvcywgbik7XG4gICAgfVxuICAgICpwYXJzZU5leHQobmV4dCkge1xuICAgICAgICBzd2l0Y2ggKG5leHQpIHtcbiAgICAgICAgICAgIGNhc2UgJ3N0cmVhbSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkKiB0aGlzLnBhcnNlU3RyZWFtKCk7XG4gICAgICAgICAgICBjYXNlICdsaW5lLXN0YXJ0JzpcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQqIHRoaXMucGFyc2VMaW5lU3RhcnQoKTtcbiAgICAgICAgICAgIGNhc2UgJ2Jsb2NrLXN0YXJ0JzpcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQqIHRoaXMucGFyc2VCbG9ja1N0YXJ0KCk7XG4gICAgICAgICAgICBjYXNlICdkb2MnOlxuICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCogdGhpcy5wYXJzZURvY3VtZW50KCk7XG4gICAgICAgICAgICBjYXNlICdmbG93JzpcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQqIHRoaXMucGFyc2VGbG93Q29sbGVjdGlvbigpO1xuICAgICAgICAgICAgY2FzZSAncXVvdGVkLXNjYWxhcic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkKiB0aGlzLnBhcnNlUXVvdGVkU2NhbGFyKCk7XG4gICAgICAgICAgICBjYXNlICdibG9jay1zY2FsYXInOlxuICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCogdGhpcy5wYXJzZUJsb2NrU2NhbGFyKCk7XG4gICAgICAgICAgICBjYXNlICdwbGFpbi1zY2FsYXInOlxuICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCogdGhpcy5wYXJzZVBsYWluU2NhbGFyKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgKnBhcnNlU3RyZWFtKCkge1xuICAgICAgICBsZXQgbGluZSA9IHRoaXMuZ2V0TGluZSgpO1xuICAgICAgICBpZiAobGluZSA9PT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNldE5leHQoJ3N0cmVhbScpO1xuICAgICAgICBpZiAobGluZVswXSA9PT0gQk9NKSB7XG4gICAgICAgICAgICB5aWVsZCogdGhpcy5wdXNoQ291bnQoMSk7XG4gICAgICAgICAgICBsaW5lID0gbGluZS5zdWJzdHJpbmcoMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxpbmVbMF0gPT09ICclJykge1xuICAgICAgICAgICAgbGV0IGRpckVuZCA9IGxpbmUubGVuZ3RoO1xuICAgICAgICAgICAgY29uc3QgY3MgPSBsaW5lLmluZGV4T2YoJyMnKTtcbiAgICAgICAgICAgIGlmIChjcyAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaCA9IGxpbmVbY3MgLSAxXTtcbiAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICcgJyB8fCBjaCA9PT0gJ1xcdCcpXG4gICAgICAgICAgICAgICAgICAgIGRpckVuZCA9IGNzIC0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2ggPSBsaW5lW2RpckVuZCAtIDFdO1xuICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJyAnIHx8IGNoID09PSAnXFx0JylcbiAgICAgICAgICAgICAgICAgICAgZGlyRW5kIC09IDE7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG4gPSAoeWllbGQqIHRoaXMucHVzaENvdW50KGRpckVuZCkpICsgKHlpZWxkKiB0aGlzLnB1c2hTcGFjZXModHJ1ZSkpO1xuICAgICAgICAgICAgeWllbGQqIHRoaXMucHVzaENvdW50KGxpbmUubGVuZ3RoIC0gbik7IC8vIHBvc3NpYmxlIGNvbW1lbnRcbiAgICAgICAgICAgIHRoaXMucHVzaE5ld2xpbmUoKTtcbiAgICAgICAgICAgIHJldHVybiAnc3RyZWFtJztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5hdExpbmVFbmQoKSkge1xuICAgICAgICAgICAgY29uc3Qgc3AgPSB5aWVsZCogdGhpcy5wdXNoU3BhY2VzKHRydWUpO1xuICAgICAgICAgICAgeWllbGQqIHRoaXMucHVzaENvdW50KGxpbmUubGVuZ3RoIC0gc3ApO1xuICAgICAgICAgICAgeWllbGQqIHRoaXMucHVzaE5ld2xpbmUoKTtcbiAgICAgICAgICAgIHJldHVybiAnc3RyZWFtJztcbiAgICAgICAgfVxuICAgICAgICB5aWVsZCBET0NVTUVOVDtcbiAgICAgICAgcmV0dXJuIHlpZWxkKiB0aGlzLnBhcnNlTGluZVN0YXJ0KCk7XG4gICAgfVxuICAgICpwYXJzZUxpbmVTdGFydCgpIHtcbiAgICAgICAgY29uc3QgY2ggPSB0aGlzLmNoYXJBdCgwKTtcbiAgICAgICAgaWYgKCFjaCAmJiAhdGhpcy5hdEVuZClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNldE5leHQoJ2xpbmUtc3RhcnQnKTtcbiAgICAgICAgaWYgKGNoID09PSAnLScgfHwgY2ggPT09ICcuJykge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmF0RW5kICYmICF0aGlzLmhhc0NoYXJzKDQpKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNldE5leHQoJ2xpbmUtc3RhcnQnKTtcbiAgICAgICAgICAgIGNvbnN0IHMgPSB0aGlzLnBlZWsoMyk7XG4gICAgICAgICAgICBpZiAocyA9PT0gJy0tLScgJiYgaXNFbXB0eSh0aGlzLmNoYXJBdCgzKSkpIHtcbiAgICAgICAgICAgICAgICB5aWVsZCogdGhpcy5wdXNoQ291bnQoMyk7XG4gICAgICAgICAgICAgICAgdGhpcy5pbmRlbnRWYWx1ZSA9IDA7XG4gICAgICAgICAgICAgICAgdGhpcy5pbmRlbnROZXh0ID0gMDtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2RvYyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzID09PSAnLi4uJyAmJiBpc0VtcHR5KHRoaXMuY2hhckF0KDMpKSkge1xuICAgICAgICAgICAgICAgIHlpZWxkKiB0aGlzLnB1c2hDb3VudCgzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3N0cmVhbSc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbmRlbnRWYWx1ZSA9IHlpZWxkKiB0aGlzLnB1c2hTcGFjZXMoZmFsc2UpO1xuICAgICAgICBpZiAodGhpcy5pbmRlbnROZXh0ID4gdGhpcy5pbmRlbnRWYWx1ZSAmJiAhaXNFbXB0eSh0aGlzLmNoYXJBdCgxKSkpXG4gICAgICAgICAgICB0aGlzLmluZGVudE5leHQgPSB0aGlzLmluZGVudFZhbHVlO1xuICAgICAgICByZXR1cm4geWllbGQqIHRoaXMucGFyc2VCbG9ja1N0YXJ0KCk7XG4gICAgfVxuICAgICpwYXJzZUJsb2NrU3RhcnQoKSB7XG4gICAgICAgIGNvbnN0IFtjaDAsIGNoMV0gPSB0aGlzLnBlZWsoMik7XG4gICAgICAgIGlmICghY2gxICYmICF0aGlzLmF0RW5kKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0TmV4dCgnYmxvY2stc3RhcnQnKTtcbiAgICAgICAgaWYgKChjaDAgPT09ICctJyB8fCBjaDAgPT09ICc/JyB8fCBjaDAgPT09ICc6JykgJiYgaXNFbXB0eShjaDEpKSB7XG4gICAgICAgICAgICBjb25zdCBuID0gKHlpZWxkKiB0aGlzLnB1c2hDb3VudCgxKSkgKyAoeWllbGQqIHRoaXMucHVzaFNwYWNlcyh0cnVlKSk7XG4gICAgICAgICAgICB0aGlzLmluZGVudE5leHQgPSB0aGlzLmluZGVudFZhbHVlICsgMTtcbiAgICAgICAgICAgIHRoaXMuaW5kZW50VmFsdWUgKz0gbjtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCogdGhpcy5wYXJzZUJsb2NrU3RhcnQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJ2RvYyc7XG4gICAgfVxuICAgICpwYXJzZURvY3VtZW50KCkge1xuICAgICAgICB5aWVsZCogdGhpcy5wdXNoU3BhY2VzKHRydWUpO1xuICAgICAgICBjb25zdCBsaW5lID0gdGhpcy5nZXRMaW5lKCk7XG4gICAgICAgIGlmIChsaW5lID09PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0TmV4dCgnZG9jJyk7XG4gICAgICAgIGxldCBuID0geWllbGQqIHRoaXMucHVzaEluZGljYXRvcnMoKTtcbiAgICAgICAgc3dpdGNoIChsaW5lW25dKSB7XG4gICAgICAgICAgICBjYXNlICcjJzpcbiAgICAgICAgICAgICAgICB5aWVsZCogdGhpcy5wdXNoQ291bnQobGluZS5sZW5ndGggLSBuKTtcbiAgICAgICAgICAgIC8vIGZhbGx0aHJvdWdoXG4gICAgICAgICAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgICAgICAgICAgICB5aWVsZCogdGhpcy5wdXNoTmV3bGluZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCogdGhpcy5wYXJzZUxpbmVTdGFydCgpO1xuICAgICAgICAgICAgY2FzZSAneyc6XG4gICAgICAgICAgICBjYXNlICdbJzpcbiAgICAgICAgICAgICAgICB5aWVsZCogdGhpcy5wdXNoQ291bnQoMSk7XG4gICAgICAgICAgICAgICAgdGhpcy5mbG93S2V5ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5mbG93TGV2ZWwgPSAxO1xuICAgICAgICAgICAgICAgIHJldHVybiAnZmxvdyc7XG4gICAgICAgICAgICBjYXNlICd9JzpcbiAgICAgICAgICAgIGNhc2UgJ10nOlxuICAgICAgICAgICAgICAgIC8vIHRoaXMgaXMgYW4gZXJyb3JcbiAgICAgICAgICAgICAgICB5aWVsZCogdGhpcy5wdXNoQ291bnQoMSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdkb2MnO1xuICAgICAgICAgICAgY2FzZSAnKic6XG4gICAgICAgICAgICAgICAgeWllbGQqIHRoaXMucHVzaFVudGlsKGlzTm90QW5jaG9yQ2hhcik7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdkb2MnO1xuICAgICAgICAgICAgY2FzZSAnXCInOlxuICAgICAgICAgICAgY2FzZSBcIidcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQqIHRoaXMucGFyc2VRdW90ZWRTY2FsYXIoKTtcbiAgICAgICAgICAgIGNhc2UgJ3wnOlxuICAgICAgICAgICAgY2FzZSAnPic6XG4gICAgICAgICAgICAgICAgbiArPSB5aWVsZCogdGhpcy5wYXJzZUJsb2NrU2NhbGFySGVhZGVyKCk7XG4gICAgICAgICAgICAgICAgbiArPSB5aWVsZCogdGhpcy5wdXNoU3BhY2VzKHRydWUpO1xuICAgICAgICAgICAgICAgIHlpZWxkKiB0aGlzLnB1c2hDb3VudChsaW5lLmxlbmd0aCAtIG4pO1xuICAgICAgICAgICAgICAgIHlpZWxkKiB0aGlzLnB1c2hOZXdsaW5lKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkKiB0aGlzLnBhcnNlQmxvY2tTY2FsYXIoKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkKiB0aGlzLnBhcnNlUGxhaW5TY2FsYXIoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAqcGFyc2VGbG93Q29sbGVjdGlvbigpIHtcbiAgICAgICAgbGV0IG5sLCBzcDtcbiAgICAgICAgbGV0IGluZGVudCA9IC0xO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICBubCA9IHlpZWxkKiB0aGlzLnB1c2hOZXdsaW5lKCk7XG4gICAgICAgICAgICBzcCA9IHlpZWxkKiB0aGlzLnB1c2hTcGFjZXModHJ1ZSk7XG4gICAgICAgICAgICBpZiAobmwgPiAwKVxuICAgICAgICAgICAgICAgIHRoaXMuaW5kZW50VmFsdWUgPSBpbmRlbnQgPSBzcDtcbiAgICAgICAgfSB3aGlsZSAobmwgKyBzcCA+IDApO1xuICAgICAgICBjb25zdCBsaW5lID0gdGhpcy5nZXRMaW5lKCk7XG4gICAgICAgIGlmIChsaW5lID09PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0TmV4dCgnZmxvdycpO1xuICAgICAgICBpZiAoKGluZGVudCAhPT0gLTEgJiYgaW5kZW50IDwgdGhpcy5pbmRlbnROZXh0ICYmIGxpbmVbMF0gIT09ICcjJykgfHxcbiAgICAgICAgICAgIChpbmRlbnQgPT09IDAgJiZcbiAgICAgICAgICAgICAgICAobGluZS5zdGFydHNXaXRoKCctLS0nKSB8fCBsaW5lLnN0YXJ0c1dpdGgoJy4uLicpKSAmJlxuICAgICAgICAgICAgICAgIGlzRW1wdHkobGluZVszXSkpKSB7XG4gICAgICAgICAgICAvLyBBbGxvd2luZyBmb3IgdGhlIHRlcm1pbmFsIF0gb3IgfSBhdCB0aGUgc2FtZSAocmF0aGVyIHRoYW4gZ3JlYXRlcilcbiAgICAgICAgICAgIC8vIGluZGVudCBsZXZlbCBhcyB0aGUgaW5pdGlhbCBbIG9yIHsgaXMgdGVjaG5pY2FsbHkgaW52YWxpZCwgYnV0XG4gICAgICAgICAgICAvLyBmYWlsaW5nIGhlcmUgd291bGQgYmUgc3VycHJpc2luZyB0byB1c2Vycy5cbiAgICAgICAgICAgIGNvbnN0IGF0Rmxvd0VuZE1hcmtlciA9IGluZGVudCA9PT0gdGhpcy5pbmRlbnROZXh0IC0gMSAmJlxuICAgICAgICAgICAgICAgIHRoaXMuZmxvd0xldmVsID09PSAxICYmXG4gICAgICAgICAgICAgICAgKGxpbmVbMF0gPT09ICddJyB8fCBsaW5lWzBdID09PSAnfScpO1xuICAgICAgICAgICAgaWYgKCFhdEZsb3dFbmRNYXJrZXIpIHtcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGlzIGFuIGVycm9yXG4gICAgICAgICAgICAgICAgdGhpcy5mbG93TGV2ZWwgPSAwO1xuICAgICAgICAgICAgICAgIHlpZWxkIEZMT1dfRU5EO1xuICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCogdGhpcy5wYXJzZUxpbmVTdGFydCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBuID0gMDtcbiAgICAgICAgd2hpbGUgKGxpbmVbbl0gPT09ICcsJykge1xuICAgICAgICAgICAgbiArPSB5aWVsZCogdGhpcy5wdXNoQ291bnQoMSk7XG4gICAgICAgICAgICBuICs9IHlpZWxkKiB0aGlzLnB1c2hTcGFjZXModHJ1ZSk7XG4gICAgICAgICAgICB0aGlzLmZsb3dLZXkgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBuICs9IHlpZWxkKiB0aGlzLnB1c2hJbmRpY2F0b3JzKCk7XG4gICAgICAgIHN3aXRjaCAobGluZVtuXSkge1xuICAgICAgICAgICAgY2FzZSB1bmRlZmluZWQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuICdmbG93JztcbiAgICAgICAgICAgIGNhc2UgJyMnOlxuICAgICAgICAgICAgICAgIHlpZWxkKiB0aGlzLnB1c2hDb3VudChsaW5lLmxlbmd0aCAtIG4pO1xuICAgICAgICAgICAgICAgIHJldHVybiAnZmxvdyc7XG4gICAgICAgICAgICBjYXNlICd7JzpcbiAgICAgICAgICAgIGNhc2UgJ1snOlxuICAgICAgICAgICAgICAgIHlpZWxkKiB0aGlzLnB1c2hDb3VudCgxKTtcbiAgICAgICAgICAgICAgICB0aGlzLmZsb3dLZXkgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLmZsb3dMZXZlbCArPSAxO1xuICAgICAgICAgICAgICAgIHJldHVybiAnZmxvdyc7XG4gICAgICAgICAgICBjYXNlICd9JzpcbiAgICAgICAgICAgIGNhc2UgJ10nOlxuICAgICAgICAgICAgICAgIHlpZWxkKiB0aGlzLnB1c2hDb3VudCgxKTtcbiAgICAgICAgICAgICAgICB0aGlzLmZsb3dLZXkgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuZmxvd0xldmVsIC09IDE7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmxvd0xldmVsID8gJ2Zsb3cnIDogJ2RvYyc7XG4gICAgICAgICAgICBjYXNlICcqJzpcbiAgICAgICAgICAgICAgICB5aWVsZCogdGhpcy5wdXNoVW50aWwoaXNOb3RBbmNob3JDaGFyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2Zsb3cnO1xuICAgICAgICAgICAgY2FzZSAnXCInOlxuICAgICAgICAgICAgY2FzZSBcIidcIjpcbiAgICAgICAgICAgICAgICB0aGlzLmZsb3dLZXkgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCogdGhpcy5wYXJzZVF1b3RlZFNjYWxhcigpO1xuICAgICAgICAgICAgY2FzZSAnOic6IHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0ID0gdGhpcy5jaGFyQXQoMSk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZmxvd0tleSB8fCBpc0VtcHR5KG5leHQpIHx8IG5leHQgPT09ICcsJykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZsb3dLZXkgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQqIHRoaXMucHVzaENvdW50KDEpO1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCogdGhpcy5wdXNoU3BhY2VzKHRydWUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ2Zsb3cnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGZhbGx0aHJvdWdoXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRoaXMuZmxvd0tleSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCogdGhpcy5wYXJzZVBsYWluU2NhbGFyKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgKnBhcnNlUXVvdGVkU2NhbGFyKCkge1xuICAgICAgICBjb25zdCBxdW90ZSA9IHRoaXMuY2hhckF0KDApO1xuICAgICAgICBsZXQgZW5kID0gdGhpcy5idWZmZXIuaW5kZXhPZihxdW90ZSwgdGhpcy5wb3MgKyAxKTtcbiAgICAgICAgaWYgKHF1b3RlID09PSBcIidcIikge1xuICAgICAgICAgICAgd2hpbGUgKGVuZCAhPT0gLTEgJiYgdGhpcy5idWZmZXJbZW5kICsgMV0gPT09IFwiJ1wiKVxuICAgICAgICAgICAgICAgIGVuZCA9IHRoaXMuYnVmZmVyLmluZGV4T2YoXCInXCIsIGVuZCArIDIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gZG91YmxlLXF1b3RlXG4gICAgICAgICAgICB3aGlsZSAoZW5kICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIGxldCBuID0gMDtcbiAgICAgICAgICAgICAgICB3aGlsZSAodGhpcy5idWZmZXJbZW5kIC0gMSAtIG5dID09PSAnXFxcXCcpXG4gICAgICAgICAgICAgICAgICAgIG4gKz0gMTtcbiAgICAgICAgICAgICAgICBpZiAobiAlIDIgPT09IDApXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGVuZCA9IHRoaXMuYnVmZmVyLmluZGV4T2YoJ1wiJywgZW5kICsgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gT25seSBsb29raW5nIGZvciBuZXdsaW5lcyB3aXRoaW4gdGhlIHF1b3Rlc1xuICAgICAgICBjb25zdCBxYiA9IHRoaXMuYnVmZmVyLnN1YnN0cmluZygwLCBlbmQpO1xuICAgICAgICBsZXQgbmwgPSBxYi5pbmRleE9mKCdcXG4nLCB0aGlzLnBvcyk7XG4gICAgICAgIGlmIChubCAhPT0gLTEpIHtcbiAgICAgICAgICAgIHdoaWxlIChubCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjcyA9IHRoaXMuY29udGludWVTY2FsYXIobmwgKyAxKTtcbiAgICAgICAgICAgICAgICBpZiAoY3MgPT09IC0xKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBubCA9IHFiLmluZGV4T2YoJ1xcbicsIGNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChubCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGlzIGFuIGVycm9yIGNhdXNlZCBieSBhbiB1bmV4cGVjdGVkIHVuaW5kZW50XG4gICAgICAgICAgICAgICAgZW5kID0gbmwgLSAocWJbbmwgLSAxXSA9PT0gJ1xccicgPyAyIDogMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVuZCA9PT0gLTEpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5hdEVuZClcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zZXROZXh0KCdxdW90ZWQtc2NhbGFyJyk7XG4gICAgICAgICAgICBlbmQgPSB0aGlzLmJ1ZmZlci5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgeWllbGQqIHRoaXMucHVzaFRvSW5kZXgoZW5kICsgMSwgZmFsc2UpO1xuICAgICAgICByZXR1cm4gdGhpcy5mbG93TGV2ZWwgPyAnZmxvdycgOiAnZG9jJztcbiAgICB9XG4gICAgKnBhcnNlQmxvY2tTY2FsYXJIZWFkZXIoKSB7XG4gICAgICAgIHRoaXMuYmxvY2tTY2FsYXJJbmRlbnQgPSAtMTtcbiAgICAgICAgdGhpcy5ibG9ja1NjYWxhcktlZXAgPSBmYWxzZTtcbiAgICAgICAgbGV0IGkgPSB0aGlzLnBvcztcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIGNvbnN0IGNoID0gdGhpcy5idWZmZXJbKytpXTtcbiAgICAgICAgICAgIGlmIChjaCA9PT0gJysnKVxuICAgICAgICAgICAgICAgIHRoaXMuYmxvY2tTY2FsYXJLZWVwID0gdHJ1ZTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGNoID4gJzAnICYmIGNoIDw9ICc5JylcbiAgICAgICAgICAgICAgICB0aGlzLmJsb2NrU2NhbGFySW5kZW50ID0gTnVtYmVyKGNoKSAtIDE7XG4gICAgICAgICAgICBlbHNlIGlmIChjaCAhPT0gJy0nKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB5aWVsZCogdGhpcy5wdXNoVW50aWwoY2ggPT4gaXNFbXB0eShjaCkgfHwgY2ggPT09ICcjJyk7XG4gICAgfVxuICAgICpwYXJzZUJsb2NrU2NhbGFyKCkge1xuICAgICAgICBsZXQgbmwgPSB0aGlzLnBvcyAtIDE7IC8vIG1heSBiZSAtMSBpZiB0aGlzLnBvcyA9PT0gMFxuICAgICAgICBsZXQgaW5kZW50ID0gMDtcbiAgICAgICAgbGV0IGNoO1xuICAgICAgICBsb29wOiBmb3IgKGxldCBpID0gdGhpcy5wb3M7IChjaCA9IHRoaXMuYnVmZmVyW2ldKTsgKytpKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGNoKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnICc6XG4gICAgICAgICAgICAgICAgICAgIGluZGVudCArPSAxO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdcXG4nOlxuICAgICAgICAgICAgICAgICAgICBubCA9IGk7XG4gICAgICAgICAgICAgICAgICAgIGluZGVudCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ1xccic6IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV4dCA9IHRoaXMuYnVmZmVyW2kgKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFuZXh0ICYmICF0aGlzLmF0RW5kKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0TmV4dCgnYmxvY2stc2NhbGFyJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0ID09PSAnXFxuJylcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH0gLy8gZmFsbHRocm91Z2hcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBicmVhayBsb29wO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghY2ggJiYgIXRoaXMuYXRFbmQpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZXROZXh0KCdibG9jay1zY2FsYXInKTtcbiAgICAgICAgaWYgKGluZGVudCA+PSB0aGlzLmluZGVudE5leHQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmJsb2NrU2NhbGFySW5kZW50ID09PSAtMSlcbiAgICAgICAgICAgICAgICB0aGlzLmluZGVudE5leHQgPSBpbmRlbnQ7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhpcy5pbmRlbnROZXh0ICs9IHRoaXMuYmxvY2tTY2FsYXJJbmRlbnQ7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgY29uc3QgY3MgPSB0aGlzLmNvbnRpbnVlU2NhbGFyKG5sICsgMSk7XG4gICAgICAgICAgICAgICAgaWYgKGNzID09PSAtMSlcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgbmwgPSB0aGlzLmJ1ZmZlci5pbmRleE9mKCdcXG4nLCBjcyk7XG4gICAgICAgICAgICB9IHdoaWxlIChubCAhPT0gLTEpO1xuICAgICAgICAgICAgaWYgKG5sID09PSAtMSkge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5hdEVuZClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0TmV4dCgnYmxvY2stc2NhbGFyJyk7XG4gICAgICAgICAgICAgICAgbmwgPSB0aGlzLmJ1ZmZlci5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmJsb2NrU2NhbGFyS2VlcCkge1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIGxldCBpID0gbmwgLSAxO1xuICAgICAgICAgICAgICAgIGxldCBjaCA9IHRoaXMuYnVmZmVyW2ldO1xuICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJ1xccicpXG4gICAgICAgICAgICAgICAgICAgIGNoID0gdGhpcy5idWZmZXJbLS1pXTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoY2ggPT09ICcgJyB8fCBjaCA9PT0gJ1xcdCcpXG4gICAgICAgICAgICAgICAgICAgIGNoID0gdGhpcy5idWZmZXJbLS1pXTtcbiAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICdcXG4nICYmIGkgPj0gdGhpcy5wb3MpXG4gICAgICAgICAgICAgICAgICAgIG5sID0gaTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfSB3aGlsZSAodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgeWllbGQgU0NBTEFSO1xuICAgICAgICB5aWVsZCogdGhpcy5wdXNoVG9JbmRleChubCArIDEsIHRydWUpO1xuICAgICAgICByZXR1cm4geWllbGQqIHRoaXMucGFyc2VMaW5lU3RhcnQoKTtcbiAgICB9XG4gICAgKnBhcnNlUGxhaW5TY2FsYXIoKSB7XG4gICAgICAgIGNvbnN0IGluRmxvdyA9IHRoaXMuZmxvd0xldmVsID4gMDtcbiAgICAgICAgbGV0IGVuZCA9IHRoaXMucG9zIC0gMTtcbiAgICAgICAgbGV0IGkgPSB0aGlzLnBvcyAtIDE7XG4gICAgICAgIGxldCBjaDtcbiAgICAgICAgd2hpbGUgKChjaCA9IHRoaXMuYnVmZmVyWysraV0pKSB7XG4gICAgICAgICAgICBpZiAoY2ggPT09ICc6Jykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5leHQgPSB0aGlzLmJ1ZmZlcltpICsgMV07XG4gICAgICAgICAgICAgICAgaWYgKGlzRW1wdHkobmV4dCkgfHwgKGluRmxvdyAmJiBuZXh0ID09PSAnLCcpKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBlbmQgPSBpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNFbXB0eShjaCkpIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IHRoaXMuYnVmZmVyW2kgKyAxXTtcbiAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICdcXHInKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0ID09PSAnXFxuJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaSArPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2ggPSAnXFxuJztcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHQgPSB0aGlzLmJ1ZmZlcltpICsgMV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kID0gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG5leHQgPT09ICcjJyB8fCAoaW5GbG93ICYmIGludmFsaWRGbG93U2NhbGFyQ2hhcnMuaW5jbHVkZXMobmV4dCkpKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICdcXG4nKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNzID0gdGhpcy5jb250aW51ZVNjYWxhcihpICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjcyA9PT0gLTEpXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgaSA9IE1hdGgubWF4KGksIGNzIC0gMik7IC8vIHRvIGFkdmFuY2UsIGJ1dCBzdGlsbCBhY2NvdW50IGZvciAnICMnXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGluRmxvdyAmJiBpbnZhbGlkRmxvd1NjYWxhckNoYXJzLmluY2x1ZGVzKGNoKSlcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZW5kID0gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNoICYmICF0aGlzLmF0RW5kKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0TmV4dCgncGxhaW4tc2NhbGFyJyk7XG4gICAgICAgIHlpZWxkIFNDQUxBUjtcbiAgICAgICAgeWllbGQqIHRoaXMucHVzaFRvSW5kZXgoZW5kICsgMSwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiBpbkZsb3cgPyAnZmxvdycgOiAnZG9jJztcbiAgICB9XG4gICAgKnB1c2hDb3VudChuKSB7XG4gICAgICAgIGlmIChuID4gMCkge1xuICAgICAgICAgICAgeWllbGQgdGhpcy5idWZmZXIuc3Vic3RyKHRoaXMucG9zLCBuKTtcbiAgICAgICAgICAgIHRoaXMucG9zICs9IG47XG4gICAgICAgICAgICByZXR1cm4gbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgKnB1c2hUb0luZGV4KGksIGFsbG93RW1wdHkpIHtcbiAgICAgICAgY29uc3QgcyA9IHRoaXMuYnVmZmVyLnNsaWNlKHRoaXMucG9zLCBpKTtcbiAgICAgICAgaWYgKHMpIHtcbiAgICAgICAgICAgIHlpZWxkIHM7XG4gICAgICAgICAgICB0aGlzLnBvcyArPSBzLmxlbmd0aDtcbiAgICAgICAgICAgIHJldHVybiBzLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhbGxvd0VtcHR5KVxuICAgICAgICAgICAgeWllbGQgJyc7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICAqcHVzaEluZGljYXRvcnMoKSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy5jaGFyQXQoMCkpIHtcbiAgICAgICAgICAgIGNhc2UgJyEnOlxuICAgICAgICAgICAgICAgIHJldHVybiAoKHlpZWxkKiB0aGlzLnB1c2hUYWcoKSkgK1xuICAgICAgICAgICAgICAgICAgICAoeWllbGQqIHRoaXMucHVzaFNwYWNlcyh0cnVlKSkgK1xuICAgICAgICAgICAgICAgICAgICAoeWllbGQqIHRoaXMucHVzaEluZGljYXRvcnMoKSkpO1xuICAgICAgICAgICAgY2FzZSAnJic6XG4gICAgICAgICAgICAgICAgcmV0dXJuICgoeWllbGQqIHRoaXMucHVzaFVudGlsKGlzTm90QW5jaG9yQ2hhcikpICtcbiAgICAgICAgICAgICAgICAgICAgKHlpZWxkKiB0aGlzLnB1c2hTcGFjZXModHJ1ZSkpICtcbiAgICAgICAgICAgICAgICAgICAgKHlpZWxkKiB0aGlzLnB1c2hJbmRpY2F0b3JzKCkpKTtcbiAgICAgICAgICAgIGNhc2UgJzonOlxuICAgICAgICAgICAgY2FzZSAnPyc6IC8vIHRoaXMgaXMgYW4gZXJyb3Igb3V0c2lkZSBmbG93IGNvbGxlY3Rpb25zXG4gICAgICAgICAgICBjYXNlICctJzogLy8gdGhpcyBpcyBhbiBlcnJvclxuICAgICAgICAgICAgICAgIGlmIChpc0VtcHR5KHRoaXMuY2hhckF0KDEpKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5mbG93TGV2ZWwgPT09IDApXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmluZGVudE5leHQgPSB0aGlzLmluZGVudFZhbHVlICsgMTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5mbG93S2V5KVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5mbG93S2V5ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoKHlpZWxkKiB0aGlzLnB1c2hDb3VudCgxKSkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgKHlpZWxkKiB0aGlzLnB1c2hTcGFjZXModHJ1ZSkpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICh5aWVsZCogdGhpcy5wdXNoSW5kaWNhdG9ycygpKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICAqcHVzaFRhZygpIHtcbiAgICAgICAgaWYgKHRoaXMuY2hhckF0KDEpID09PSAnPCcpIHtcbiAgICAgICAgICAgIGxldCBpID0gdGhpcy5wb3MgKyAyO1xuICAgICAgICAgICAgbGV0IGNoID0gdGhpcy5idWZmZXJbaV07XG4gICAgICAgICAgICB3aGlsZSAoIWlzRW1wdHkoY2gpICYmIGNoICE9PSAnPicpXG4gICAgICAgICAgICAgICAgY2ggPSB0aGlzLmJ1ZmZlclsrK2ldO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkKiB0aGlzLnB1c2hUb0luZGV4KGNoID09PSAnPicgPyBpICsgMSA6IGksIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBpID0gdGhpcy5wb3MgKyAxO1xuICAgICAgICAgICAgbGV0IGNoID0gdGhpcy5idWZmZXJbaV07XG4gICAgICAgICAgICB3aGlsZSAoY2gpIHtcbiAgICAgICAgICAgICAgICBpZiAodGFnQ2hhcnMuaW5jbHVkZXMoY2gpKVxuICAgICAgICAgICAgICAgICAgICBjaCA9IHRoaXMuYnVmZmVyWysraV07XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY2ggPT09ICclJyAmJlxuICAgICAgICAgICAgICAgICAgICBoZXhEaWdpdHMuaW5jbHVkZXModGhpcy5idWZmZXJbaSArIDFdKSAmJlxuICAgICAgICAgICAgICAgICAgICBoZXhEaWdpdHMuaW5jbHVkZXModGhpcy5idWZmZXJbaSArIDJdKSkge1xuICAgICAgICAgICAgICAgICAgICBjaCA9IHRoaXMuYnVmZmVyWyhpICs9IDMpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB5aWVsZCogdGhpcy5wdXNoVG9JbmRleChpLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgKnB1c2hOZXdsaW5lKCkge1xuICAgICAgICBjb25zdCBjaCA9IHRoaXMuYnVmZmVyW3RoaXMucG9zXTtcbiAgICAgICAgaWYgKGNoID09PSAnXFxuJylcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCogdGhpcy5wdXNoQ291bnQoMSk7XG4gICAgICAgIGVsc2UgaWYgKGNoID09PSAnXFxyJyAmJiB0aGlzLmNoYXJBdCgxKSA9PT0gJ1xcbicpXG4gICAgICAgICAgICByZXR1cm4geWllbGQqIHRoaXMucHVzaENvdW50KDIpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgKnB1c2hTcGFjZXMoYWxsb3dUYWJzKSB7XG4gICAgICAgIGxldCBpID0gdGhpcy5wb3MgLSAxO1xuICAgICAgICBsZXQgY2g7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIGNoID0gdGhpcy5idWZmZXJbKytpXTtcbiAgICAgICAgfSB3aGlsZSAoY2ggPT09ICcgJyB8fCAoYWxsb3dUYWJzICYmIGNoID09PSAnXFx0JykpO1xuICAgICAgICBjb25zdCBuID0gaSAtIHRoaXMucG9zO1xuICAgICAgICBpZiAobiA+IDApIHtcbiAgICAgICAgICAgIHlpZWxkIHRoaXMuYnVmZmVyLnN1YnN0cih0aGlzLnBvcywgbik7XG4gICAgICAgICAgICB0aGlzLnBvcyA9IGk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG47XG4gICAgfVxuICAgICpwdXNoVW50aWwodGVzdCkge1xuICAgICAgICBsZXQgaSA9IHRoaXMucG9zO1xuICAgICAgICBsZXQgY2ggPSB0aGlzLmJ1ZmZlcltpXTtcbiAgICAgICAgd2hpbGUgKCF0ZXN0KGNoKSlcbiAgICAgICAgICAgIGNoID0gdGhpcy5idWZmZXJbKytpXTtcbiAgICAgICAgcmV0dXJuIHlpZWxkKiB0aGlzLnB1c2hUb0luZGV4KGksIGZhbHNlKTtcbiAgICB9XG59XG5cbmV4cG9ydCB7IExleGVyIH07XG4iLCAiLyoqXG4gKiBUcmFja3MgbmV3bGluZXMgZHVyaW5nIHBhcnNpbmcgaW4gb3JkZXIgdG8gcHJvdmlkZSBhbiBlZmZpY2llbnQgQVBJIGZvclxuICogZGV0ZXJtaW5pbmcgdGhlIG9uZS1pbmRleGVkIGB7IGxpbmUsIGNvbCB9YCBwb3NpdGlvbiBmb3IgYW55IG9mZnNldFxuICogd2l0aGluIHRoZSBpbnB1dC5cbiAqL1xuY2xhc3MgTGluZUNvdW50ZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmxpbmVTdGFydHMgPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNob3VsZCBiZSBjYWxsZWQgaW4gYXNjZW5kaW5nIG9yZGVyLiBPdGhlcndpc2UsIGNhbGxcbiAgICAgICAgICogYGxpbmVDb3VudGVyLmxpbmVTdGFydHMuc29ydCgpYCBiZWZvcmUgY2FsbGluZyBgbGluZVBvcygpYC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYWRkTmV3TGluZSA9IChvZmZzZXQpID0+IHRoaXMubGluZVN0YXJ0cy5wdXNoKG9mZnNldCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQZXJmb3JtcyBhIGJpbmFyeSBzZWFyY2ggYW5kIHJldHVybnMgdGhlIDEtaW5kZXhlZCB7IGxpbmUsIGNvbCB9XG4gICAgICAgICAqIHBvc2l0aW9uIG9mIGBvZmZzZXRgLiBJZiBgbGluZSA9PT0gMGAsIGBhZGROZXdMaW5lYCBoYXMgbmV2ZXIgYmVlblxuICAgICAgICAgKiBjYWxsZWQgb3IgYG9mZnNldGAgaXMgYmVmb3JlIHRoZSBmaXJzdCBrbm93biBuZXdsaW5lLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5saW5lUG9zID0gKG9mZnNldCkgPT4ge1xuICAgICAgICAgICAgbGV0IGxvdyA9IDA7XG4gICAgICAgICAgICBsZXQgaGlnaCA9IHRoaXMubGluZVN0YXJ0cy5sZW5ndGg7XG4gICAgICAgICAgICB3aGlsZSAobG93IDwgaGlnaCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1pZCA9IChsb3cgKyBoaWdoKSA+PiAxOyAvLyBNYXRoLmZsb29yKChsb3cgKyBoaWdoKSAvIDIpXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubGluZVN0YXJ0c1ttaWRdIDwgb2Zmc2V0KVxuICAgICAgICAgICAgICAgICAgICBsb3cgPSBtaWQgKyAxO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgaGlnaCA9IG1pZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmxpbmVTdGFydHNbbG93XSA9PT0gb2Zmc2V0KVxuICAgICAgICAgICAgICAgIHJldHVybiB7IGxpbmU6IGxvdyArIDEsIGNvbDogMSB9O1xuICAgICAgICAgICAgaWYgKGxvdyA9PT0gMClcbiAgICAgICAgICAgICAgICByZXR1cm4geyBsaW5lOiAwLCBjb2w6IG9mZnNldCB9O1xuICAgICAgICAgICAgY29uc3Qgc3RhcnQgPSB0aGlzLmxpbmVTdGFydHNbbG93IC0gMV07XG4gICAgICAgICAgICByZXR1cm4geyBsaW5lOiBsb3csIGNvbDogb2Zmc2V0IC0gc3RhcnQgKyAxIH07XG4gICAgICAgIH07XG4gICAgfVxufVxuXG5leHBvcnQgeyBMaW5lQ291bnRlciB9O1xuIiwgImltcG9ydCB7IHRva2VuVHlwZSB9IGZyb20gJy4vY3N0LmpzJztcbmltcG9ydCB7IExleGVyIH0gZnJvbSAnLi9sZXhlci5qcyc7XG5cbmZ1bmN0aW9uIGluY2x1ZGVzVG9rZW4obGlzdCwgdHlwZSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSlcbiAgICAgICAgaWYgKGxpc3RbaV0udHlwZSA9PT0gdHlwZSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGluY2x1ZGVzTm9uRW1wdHkobGlzdCkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgICAgICBzd2l0Y2ggKGxpc3RbaV0udHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnc3BhY2UnOlxuICAgICAgICAgICAgY2FzZSAnY29tbWVudCc6XG4gICAgICAgICAgICBjYXNlICduZXdsaW5lJzpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gaXNGbG93VG9rZW4odG9rZW4pIHtcbiAgICBzd2l0Y2ggKHRva2VuID09PSBudWxsIHx8IHRva2VuID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0b2tlbi50eXBlKSB7XG4gICAgICAgIGNhc2UgJ2FsaWFzJzpcbiAgICAgICAgY2FzZSAnc2NhbGFyJzpcbiAgICAgICAgY2FzZSAnc2luZ2xlLXF1b3RlZC1zY2FsYXInOlxuICAgICAgICBjYXNlICdkb3VibGUtcXVvdGVkLXNjYWxhcic6XG4gICAgICAgIGNhc2UgJ2Zsb3ctY29sbGVjdGlvbic6XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRQcmV2UHJvcHMocGFyZW50KSB7XG4gICAgc3dpdGNoIChwYXJlbnQudHlwZSkge1xuICAgICAgICBjYXNlICdkb2N1bWVudCc6XG4gICAgICAgICAgICByZXR1cm4gcGFyZW50LnN0YXJ0O1xuICAgICAgICBjYXNlICdibG9jay1tYXAnOiB7XG4gICAgICAgICAgICBjb25zdCBpdCA9IHBhcmVudC5pdGVtc1twYXJlbnQuaXRlbXMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICByZXR1cm4gaXQuc2VwIHx8IGl0LnN0YXJ0O1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ2Jsb2NrLXNlcSc6XG4gICAgICAgICAgICByZXR1cm4gcGFyZW50Lml0ZW1zW3BhcmVudC5pdGVtcy5sZW5ndGggLSAxXS5zdGFydDtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgc2hvdWxkIG5vdCBoYXBwZW4gKi9cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICB9XG59XG4vKiogTm90ZTogTWF5IG1vZGlmeSBpbnB1dCBhcnJheSAqL1xuZnVuY3Rpb24gZ2V0Rmlyc3RLZXlTdGFydFByb3BzKHByZXYpIHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKHByZXYubGVuZ3RoID09PSAwKVxuICAgICAgICByZXR1cm4gW107XG4gICAgbGV0IGkgPSBwcmV2Lmxlbmd0aDtcbiAgICBsb29wOiB3aGlsZSAoLS1pID49IDApIHtcbiAgICAgICAgc3dpdGNoIChwcmV2W2ldLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2RvYy1zdGFydCc6XG4gICAgICAgICAgICBjYXNlICdleHBsaWNpdC1rZXktaW5kJzpcbiAgICAgICAgICAgIGNhc2UgJ21hcC12YWx1ZS1pbmQnOlxuICAgICAgICAgICAgY2FzZSAnc2VxLWl0ZW0taW5kJzpcbiAgICAgICAgICAgIGNhc2UgJ25ld2xpbmUnOlxuICAgICAgICAgICAgICAgIGJyZWFrIGxvb3A7XG4gICAgICAgIH1cbiAgICB9XG4gICAgd2hpbGUgKCgoX2EgPSBwcmV2WysraV0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50eXBlKSA9PT0gJ3NwYWNlJykge1xuICAgICAgICAvKiBsb29wICovXG4gICAgfVxuICAgIHJldHVybiBwcmV2LnNwbGljZShpLCBwcmV2Lmxlbmd0aCk7XG59XG5mdW5jdGlvbiBmaXhGbG93U2VxSXRlbXMoZmMpIHtcbiAgICBpZiAoZmMuc3RhcnQudHlwZSA9PT0gJ2Zsb3ctc2VxLXN0YXJ0Jykge1xuICAgICAgICBmb3IgKGNvbnN0IGl0IG9mIGZjLml0ZW1zKSB7XG4gICAgICAgICAgICBpZiAoaXQuc2VwICYmXG4gICAgICAgICAgICAgICAgIWl0LnZhbHVlICYmXG4gICAgICAgICAgICAgICAgIWluY2x1ZGVzVG9rZW4oaXQuc3RhcnQsICdleHBsaWNpdC1rZXktaW5kJykgJiZcbiAgICAgICAgICAgICAgICAhaW5jbHVkZXNUb2tlbihpdC5zZXAsICdtYXAtdmFsdWUtaW5kJykpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXQua2V5KVxuICAgICAgICAgICAgICAgICAgICBpdC52YWx1ZSA9IGl0LmtleTtcbiAgICAgICAgICAgICAgICBkZWxldGUgaXQua2V5O1xuICAgICAgICAgICAgICAgIGlmIChpc0Zsb3dUb2tlbihpdC52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGl0LnZhbHVlLmVuZClcbiAgICAgICAgICAgICAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGl0LnZhbHVlLmVuZCwgaXQuc2VwKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgaXQudmFsdWUuZW5kID0gaXQuc2VwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGl0LnN0YXJ0LCBpdC5zZXApO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBpdC5zZXA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIEEgWUFNTCBjb25jcmV0ZSBzeW50YXggdHJlZSAoQ1NUKSBwYXJzZXJcbiAqXG4gKiBgYGB0c1xuICogY29uc3Qgc3JjOiBzdHJpbmcgPSAuLi5cbiAqIGZvciAoY29uc3QgdG9rZW4gb2YgbmV3IFBhcnNlcigpLnBhcnNlKHNyYykpIHtcbiAqICAgLy8gdG9rZW46IFRva2VuXG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBUbyB1c2UgdGhlIHBhcnNlciB3aXRoIGEgdXNlci1wcm92aWRlZCBsZXhlcjpcbiAqXG4gKiBgYGB0c1xuICogZnVuY3Rpb24qIHBhcnNlKHNvdXJjZTogc3RyaW5nLCBsZXhlcjogTGV4ZXIpIHtcbiAqICAgY29uc3QgcGFyc2VyID0gbmV3IFBhcnNlcigpXG4gKiAgIGZvciAoY29uc3QgbGV4ZW1lIG9mIGxleGVyLmxleChzb3VyY2UpKVxuICogICAgIHlpZWxkKiBwYXJzZXIubmV4dChsZXhlbWUpXG4gKiAgIHlpZWxkKiBwYXJzZXIuZW5kKClcbiAqIH1cbiAqXG4gKiBjb25zdCBzcmM6IHN0cmluZyA9IC4uLlxuICogY29uc3QgbGV4ZXIgPSBuZXcgTGV4ZXIoKVxuICogZm9yIChjb25zdCB0b2tlbiBvZiBwYXJzZShzcmMsIGxleGVyKSkge1xuICogICAvLyB0b2tlbjogVG9rZW5cbiAqIH1cbiAqIGBgYFxuICovXG5jbGFzcyBQYXJzZXIge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSBvbk5ld0xpbmUgLSBJZiBkZWZpbmVkLCBjYWxsZWQgc2VwYXJhdGVseSB3aXRoIHRoZSBzdGFydCBwb3NpdGlvbiBvZlxuICAgICAqICAgZWFjaCBuZXcgbGluZSAoaW4gYHBhcnNlKClgLCBpbmNsdWRpbmcgdGhlIHN0YXJ0IG9mIGlucHV0KS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihvbk5ld0xpbmUpIHtcbiAgICAgICAgLyoqIElmIHRydWUsIHNwYWNlIGFuZCBzZXF1ZW5jZSBpbmRpY2F0b3JzIGNvdW50IGFzIGluZGVudGF0aW9uICovXG4gICAgICAgIHRoaXMuYXROZXdMaW5lID0gdHJ1ZTtcbiAgICAgICAgLyoqIElmIHRydWUsIG5leHQgdG9rZW4gaXMgYSBzY2FsYXIgdmFsdWUgKi9cbiAgICAgICAgdGhpcy5hdFNjYWxhciA9IGZhbHNlO1xuICAgICAgICAvKiogQ3VycmVudCBpbmRlbnRhdGlvbiBsZXZlbCAqL1xuICAgICAgICB0aGlzLmluZGVudCA9IDA7XG4gICAgICAgIC8qKiBDdXJyZW50IG9mZnNldCBzaW5jZSB0aGUgc3RhcnQgb2YgcGFyc2luZyAqL1xuICAgICAgICB0aGlzLm9mZnNldCA9IDA7XG4gICAgICAgIC8qKiBPbiB0aGUgc2FtZSBsaW5lIHdpdGggYSBibG9jayBtYXAga2V5ICovXG4gICAgICAgIHRoaXMub25LZXlMaW5lID0gZmFsc2U7XG4gICAgICAgIC8qKiBUb3AgaW5kaWNhdGVzIHRoZSBub2RlIHRoYXQncyBjdXJyZW50bHkgYmVpbmcgYnVpbHQgKi9cbiAgICAgICAgdGhpcy5zdGFjayA9IFtdO1xuICAgICAgICAvKiogVGhlIHNvdXJjZSBvZiB0aGUgY3VycmVudCB0b2tlbiwgc2V0IGluIHBhcnNlKCkgKi9cbiAgICAgICAgdGhpcy5zb3VyY2UgPSAnJztcbiAgICAgICAgLyoqIFRoZSB0eXBlIG9mIHRoZSBjdXJyZW50IHRva2VuLCBzZXQgaW4gcGFyc2UoKSAqL1xuICAgICAgICB0aGlzLnR5cGUgPSAnJztcbiAgICAgICAgLy8gTXVzdCBiZSBkZWZpbmVkIGFmdGVyIGBuZXh0KClgXG4gICAgICAgIHRoaXMubGV4ZXIgPSBuZXcgTGV4ZXIoKTtcbiAgICAgICAgdGhpcy5vbk5ld0xpbmUgPSBvbk5ld0xpbmU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBhcnNlIGBzb3VyY2VgIGFzIGEgWUFNTCBzdHJlYW0uXG4gICAgICogSWYgYGluY29tcGxldGVgLCBhIHBhcnQgb2YgdGhlIGxhc3QgbGluZSBtYXkgYmUgbGVmdCBhcyBhIGJ1ZmZlciBmb3IgdGhlIG5leHQgY2FsbC5cbiAgICAgKlxuICAgICAqIEVycm9ycyBhcmUgbm90IHRocm93biwgYnV0IHlpZWxkZWQgYXMgYHsgdHlwZTogJ2Vycm9yJywgbWVzc2FnZSB9YCB0b2tlbnMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBIGdlbmVyYXRvciBvZiB0b2tlbnMgcmVwcmVzZW50aW5nIGVhY2ggZGlyZWN0aXZlLCBkb2N1bWVudCwgYW5kIG90aGVyIHN0cnVjdHVyZS5cbiAgICAgKi9cbiAgICAqcGFyc2Uoc291cmNlLCBpbmNvbXBsZXRlID0gZmFsc2UpIHtcbiAgICAgICAgaWYgKHRoaXMub25OZXdMaW5lICYmIHRoaXMub2Zmc2V0ID09PSAwKVxuICAgICAgICAgICAgdGhpcy5vbk5ld0xpbmUoMCk7XG4gICAgICAgIGZvciAoY29uc3QgbGV4ZW1lIG9mIHRoaXMubGV4ZXIubGV4KHNvdXJjZSwgaW5jb21wbGV0ZSkpXG4gICAgICAgICAgICB5aWVsZCogdGhpcy5uZXh0KGxleGVtZSk7XG4gICAgICAgIGlmICghaW5jb21wbGV0ZSlcbiAgICAgICAgICAgIHlpZWxkKiB0aGlzLmVuZCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZHZhbmNlIHRoZSBwYXJzZXIgYnkgdGhlIGBzb3VyY2VgIG9mIG9uZSBsZXhpY2FsIHRva2VuLlxuICAgICAqL1xuICAgICpuZXh0KHNvdXJjZSkge1xuICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgICAgaWYgKHRoaXMuYXRTY2FsYXIpIHtcbiAgICAgICAgICAgIHRoaXMuYXRTY2FsYXIgPSBmYWxzZTtcbiAgICAgICAgICAgIHlpZWxkKiB0aGlzLnN0ZXAoKTtcbiAgICAgICAgICAgIHRoaXMub2Zmc2V0ICs9IHNvdXJjZS5sZW5ndGg7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdHlwZSA9IHRva2VuVHlwZShzb3VyY2UpO1xuICAgICAgICBpZiAoIXR5cGUpIHtcbiAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBgTm90IGEgWUFNTCB0b2tlbjogJHtzb3VyY2V9YDtcbiAgICAgICAgICAgIHlpZWxkKiB0aGlzLnBvcCh7IHR5cGU6ICdlcnJvcicsIG9mZnNldDogdGhpcy5vZmZzZXQsIG1lc3NhZ2UsIHNvdXJjZSB9KTtcbiAgICAgICAgICAgIHRoaXMub2Zmc2V0ICs9IHNvdXJjZS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gJ3NjYWxhcicpIHtcbiAgICAgICAgICAgIHRoaXMuYXROZXdMaW5lID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmF0U2NhbGFyID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMudHlwZSA9ICdzY2FsYXInO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgICAgIHlpZWxkKiB0aGlzLnN0ZXAoKTtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ25ld2xpbmUnOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmF0TmV3TGluZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5kZW50ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMub25OZXdMaW5lKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vbk5ld0xpbmUodGhpcy5vZmZzZXQgKyBzb3VyY2UubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3BhY2UnOlxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5hdE5ld0xpbmUgJiYgc291cmNlWzBdID09PSAnICcpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmluZGVudCArPSBzb3VyY2UubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdleHBsaWNpdC1rZXktaW5kJzpcbiAgICAgICAgICAgICAgICBjYXNlICdtYXAtdmFsdWUtaW5kJzpcbiAgICAgICAgICAgICAgICBjYXNlICdzZXEtaXRlbS1pbmQnOlxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5hdE5ld0xpbmUpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmluZGVudCArPSBzb3VyY2UubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdkb2MtbW9kZSc6XG4gICAgICAgICAgICAgICAgY2FzZSAnZmxvdy1lcnJvci1lbmQnOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hdE5ld0xpbmUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMub2Zmc2V0ICs9IHNvdXJjZS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqIENhbGwgYXQgZW5kIG9mIGlucHV0IHRvIHB1c2ggb3V0IGFueSByZW1haW5pbmcgY29uc3RydWN0aW9ucyAqL1xuICAgICplbmQoKSB7XG4gICAgICAgIHdoaWxlICh0aGlzLnN0YWNrLmxlbmd0aCA+IDApXG4gICAgICAgICAgICB5aWVsZCogdGhpcy5wb3AoKTtcbiAgICB9XG4gICAgZ2V0IHNvdXJjZVRva2VuKCkge1xuICAgICAgICBjb25zdCBzdCA9IHtcbiAgICAgICAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgICAgICAgIG9mZnNldDogdGhpcy5vZmZzZXQsXG4gICAgICAgICAgICBpbmRlbnQ6IHRoaXMuaW5kZW50LFxuICAgICAgICAgICAgc291cmNlOiB0aGlzLnNvdXJjZVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gc3Q7XG4gICAgfVxuICAgICpzdGVwKCkge1xuICAgICAgICBjb25zdCB0b3AgPSB0aGlzLnBlZWsoMSk7XG4gICAgICAgIGlmICh0aGlzLnR5cGUgPT09ICdkb2MtZW5kJyAmJiAoIXRvcCB8fCB0b3AudHlwZSAhPT0gJ2RvYy1lbmQnKSkge1xuICAgICAgICAgICAgd2hpbGUgKHRoaXMuc3RhY2subGVuZ3RoID4gMClcbiAgICAgICAgICAgICAgICB5aWVsZCogdGhpcy5wb3AoKTtcbiAgICAgICAgICAgIHRoaXMuc3RhY2sucHVzaCh7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2RvYy1lbmQnLFxuICAgICAgICAgICAgICAgIG9mZnNldDogdGhpcy5vZmZzZXQsXG4gICAgICAgICAgICAgICAgc291cmNlOiB0aGlzLnNvdXJjZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0b3ApXG4gICAgICAgICAgICByZXR1cm4geWllbGQqIHRoaXMuc3RyZWFtKCk7XG4gICAgICAgIHN3aXRjaCAodG9wLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2RvY3VtZW50JzpcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQqIHRoaXMuZG9jdW1lbnQodG9wKTtcbiAgICAgICAgICAgIGNhc2UgJ2FsaWFzJzpcbiAgICAgICAgICAgIGNhc2UgJ3NjYWxhcic6XG4gICAgICAgICAgICBjYXNlICdzaW5nbGUtcXVvdGVkLXNjYWxhcic6XG4gICAgICAgICAgICBjYXNlICdkb3VibGUtcXVvdGVkLXNjYWxhcic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkKiB0aGlzLnNjYWxhcih0b3ApO1xuICAgICAgICAgICAgY2FzZSAnYmxvY2stc2NhbGFyJzpcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQqIHRoaXMuYmxvY2tTY2FsYXIodG9wKTtcbiAgICAgICAgICAgIGNhc2UgJ2Jsb2NrLW1hcCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkKiB0aGlzLmJsb2NrTWFwKHRvcCk7XG4gICAgICAgICAgICBjYXNlICdibG9jay1zZXEnOlxuICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCogdGhpcy5ibG9ja1NlcXVlbmNlKHRvcCk7XG4gICAgICAgICAgICBjYXNlICdmbG93LWNvbGxlY3Rpb24nOlxuICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCogdGhpcy5mbG93Q29sbGVjdGlvbih0b3ApO1xuICAgICAgICAgICAgY2FzZSAnZG9jLWVuZCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkKiB0aGlzLmRvY3VtZW50RW5kKHRvcCk7XG4gICAgICAgIH1cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgc2hvdWxkIG5vdCBoYXBwZW4gKi9cbiAgICAgICAgeWllbGQqIHRoaXMucG9wKCk7XG4gICAgfVxuICAgIHBlZWsobikge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIG5dO1xuICAgIH1cbiAgICAqcG9wKGVycm9yKSB7XG4gICAgICAgIGNvbnN0IHRva2VuID0gZXJyb3IgfHwgdGhpcy5zdGFjay5wb3AoKTtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmIHNob3VsZCBub3QgaGFwcGVuICovXG4gICAgICAgIGlmICghdG9rZW4pIHtcbiAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSAnVHJpZWQgdG8gcG9wIGFuIGVtcHR5IHN0YWNrJztcbiAgICAgICAgICAgIHlpZWxkIHsgdHlwZTogJ2Vycm9yJywgb2Zmc2V0OiB0aGlzLm9mZnNldCwgc291cmNlOiAnJywgbWVzc2FnZSB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuc3RhY2subGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB5aWVsZCB0b2tlbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHRvcCA9IHRoaXMucGVlaygxKTtcbiAgICAgICAgICAgIGlmICh0b2tlbi50eXBlID09PSAnYmxvY2stc2NhbGFyJykge1xuICAgICAgICAgICAgICAgIC8vIEJsb2NrIHNjYWxhcnMgdXNlIHRoZWlyIHBhcmVudCByYXRoZXIgdGhhbiBoZWFkZXIgaW5kZW50XG4gICAgICAgICAgICAgICAgdG9rZW4uaW5kZW50ID0gJ2luZGVudCcgaW4gdG9wID8gdG9wLmluZGVudCA6IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0b2tlbi50eXBlID09PSAnZmxvdy1jb2xsZWN0aW9uJyAmJiB0b3AudHlwZSA9PT0gJ2RvY3VtZW50Jykge1xuICAgICAgICAgICAgICAgIC8vIElnbm9yZSBhbGwgaW5kZW50IGZvciB0b3AtbGV2ZWwgZmxvdyBjb2xsZWN0aW9uc1xuICAgICAgICAgICAgICAgIHRva2VuLmluZGVudCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodG9rZW4udHlwZSA9PT0gJ2Zsb3ctY29sbGVjdGlvbicpXG4gICAgICAgICAgICAgICAgZml4Rmxvd1NlcUl0ZW1zKHRva2VuKTtcbiAgICAgICAgICAgIHN3aXRjaCAodG9wLnR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdkb2N1bWVudCc6XG4gICAgICAgICAgICAgICAgICAgIHRvcC52YWx1ZSA9IHRva2VuO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdibG9jay1zY2FsYXInOlxuICAgICAgICAgICAgICAgICAgICB0b3AucHJvcHMucHVzaCh0b2tlbik7IC8vIGVycm9yXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2Jsb2NrLW1hcCc6IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaXQgPSB0b3AuaXRlbXNbdG9wLml0ZW1zLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXQudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvcC5pdGVtcy5wdXNoKHsgc3RhcnQ6IFtdLCBrZXk6IHRva2VuLCBzZXA6IFtdIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vbktleUxpbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGl0LnNlcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXQudmFsdWUgPSB0b2tlbjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oaXQsIHsga2V5OiB0b2tlbiwgc2VwOiBbXSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub25LZXlMaW5lID0gIWluY2x1ZGVzVG9rZW4oaXQuc3RhcnQsICdleHBsaWNpdC1rZXktaW5kJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgJ2Jsb2NrLXNlcSc6IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaXQgPSB0b3AuaXRlbXNbdG9wLml0ZW1zLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXQudmFsdWUpXG4gICAgICAgICAgICAgICAgICAgICAgICB0b3AuaXRlbXMucHVzaCh7IHN0YXJ0OiBbXSwgdmFsdWU6IHRva2VuIH0pO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBpdC52YWx1ZSA9IHRva2VuO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAnZmxvdy1jb2xsZWN0aW9uJzoge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpdCA9IHRvcC5pdGVtc1t0b3AuaXRlbXMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXQgfHwgaXQudmFsdWUpXG4gICAgICAgICAgICAgICAgICAgICAgICB0b3AuaXRlbXMucHVzaCh7IHN0YXJ0OiBbXSwga2V5OiB0b2tlbiwgc2VwOiBbXSB9KTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaXQuc2VwKVxuICAgICAgICAgICAgICAgICAgICAgICAgaXQudmFsdWUgPSB0b2tlbjtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihpdCwgeyBrZXk6IHRva2VuLCBzZXA6IFtdIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0IHNob3VsZCBub3QgaGFwcGVuICovXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgeWllbGQqIHRoaXMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkKiB0aGlzLnBvcCh0b2tlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKHRvcC50eXBlID09PSAnZG9jdW1lbnQnIHx8XG4gICAgICAgICAgICAgICAgdG9wLnR5cGUgPT09ICdibG9jay1tYXAnIHx8XG4gICAgICAgICAgICAgICAgdG9wLnR5cGUgPT09ICdibG9jay1zZXEnKSAmJlxuICAgICAgICAgICAgICAgICh0b2tlbi50eXBlID09PSAnYmxvY2stbWFwJyB8fCB0b2tlbi50eXBlID09PSAnYmxvY2stc2VxJykpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsYXN0ID0gdG9rZW4uaXRlbXNbdG9rZW4uaXRlbXMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgaWYgKGxhc3QgJiZcbiAgICAgICAgICAgICAgICAgICAgIWxhc3Quc2VwICYmXG4gICAgICAgICAgICAgICAgICAgICFsYXN0LnZhbHVlICYmXG4gICAgICAgICAgICAgICAgICAgIGxhc3Quc3RhcnQubGVuZ3RoID4gMCAmJlxuICAgICAgICAgICAgICAgICAgICAhaW5jbHVkZXNOb25FbXB0eShsYXN0LnN0YXJ0KSAmJlxuICAgICAgICAgICAgICAgICAgICAodG9rZW4uaW5kZW50ID09PSAwIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0LnN0YXJ0LmV2ZXJ5KHN0ID0+IHN0LnR5cGUgIT09ICdjb21tZW50JyB8fCBzdC5pbmRlbnQgPCB0b2tlbi5pbmRlbnQpKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodG9wLnR5cGUgPT09ICdkb2N1bWVudCcpXG4gICAgICAgICAgICAgICAgICAgICAgICB0b3AuZW5kID0gbGFzdC5zdGFydDtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgdG9wLml0ZW1zLnB1c2goeyBzdGFydDogbGFzdC5zdGFydCB9KTtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4uaXRlbXMuc3BsaWNlKC0xLCAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgKnN0cmVhbSgpIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2RpcmVjdGl2ZS1saW5lJzpcbiAgICAgICAgICAgICAgICB5aWVsZCB7IHR5cGU6ICdkaXJlY3RpdmUnLCBvZmZzZXQ6IHRoaXMub2Zmc2V0LCBzb3VyY2U6IHRoaXMuc291cmNlIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY2FzZSAnYnl0ZS1vcmRlci1tYXJrJzpcbiAgICAgICAgICAgIGNhc2UgJ3NwYWNlJzpcbiAgICAgICAgICAgIGNhc2UgJ2NvbW1lbnQnOlxuICAgICAgICAgICAgY2FzZSAnbmV3bGluZSc6XG4gICAgICAgICAgICAgICAgeWllbGQgdGhpcy5zb3VyY2VUb2tlbjtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjYXNlICdkb2MtbW9kZSc6XG4gICAgICAgICAgICBjYXNlICdkb2Mtc3RhcnQnOiB7XG4gICAgICAgICAgICAgICAgY29uc3QgZG9jID0ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnZG9jdW1lbnQnLFxuICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IHRoaXMub2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICBzdGFydDogW11cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnR5cGUgPT09ICdkb2Mtc3RhcnQnKVxuICAgICAgICAgICAgICAgICAgICBkb2Muc3RhcnQucHVzaCh0aGlzLnNvdXJjZVRva2VuKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YWNrLnB1c2goZG9jKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgeWllbGQge1xuICAgICAgICAgICAgdHlwZTogJ2Vycm9yJyxcbiAgICAgICAgICAgIG9mZnNldDogdGhpcy5vZmZzZXQsXG4gICAgICAgICAgICBtZXNzYWdlOiBgVW5leHBlY3RlZCAke3RoaXMudHlwZX0gdG9rZW4gaW4gWUFNTCBzdHJlYW1gLFxuICAgICAgICAgICAgc291cmNlOiB0aGlzLnNvdXJjZVxuICAgICAgICB9O1xuICAgIH1cbiAgICAqZG9jdW1lbnQoZG9jKSB7XG4gICAgICAgIGlmIChkb2MudmFsdWUpXG4gICAgICAgICAgICByZXR1cm4geWllbGQqIHRoaXMubGluZUVuZChkb2MpO1xuICAgICAgICBzd2l0Y2ggKHRoaXMudHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnZG9jLXN0YXJ0Jzoge1xuICAgICAgICAgICAgICAgIGlmIChpbmNsdWRlc05vbkVtcHR5KGRvYy5zdGFydCkpIHtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQqIHRoaXMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkKiB0aGlzLnN0ZXAoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBkb2Muc3RhcnQucHVzaCh0aGlzLnNvdXJjZVRva2VuKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdhbmNob3InOlxuICAgICAgICAgICAgY2FzZSAndGFnJzpcbiAgICAgICAgICAgIGNhc2UgJ3NwYWNlJzpcbiAgICAgICAgICAgIGNhc2UgJ2NvbW1lbnQnOlxuICAgICAgICAgICAgY2FzZSAnbmV3bGluZSc6XG4gICAgICAgICAgICAgICAgZG9jLnN0YXJ0LnB1c2godGhpcy5zb3VyY2VUb2tlbik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJ2ID0gdGhpcy5zdGFydEJsb2NrVmFsdWUoZG9jKTtcbiAgICAgICAgaWYgKGJ2KVxuICAgICAgICAgICAgdGhpcy5zdGFjay5wdXNoKGJ2KTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB5aWVsZCB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2Vycm9yJyxcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IHRoaXMub2Zmc2V0LFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGBVbmV4cGVjdGVkICR7dGhpcy50eXBlfSB0b2tlbiBpbiBZQU1MIGRvY3VtZW50YCxcbiAgICAgICAgICAgICAgICBzb3VyY2U6IHRoaXMuc291cmNlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgICpzY2FsYXIoc2NhbGFyKSB7XG4gICAgICAgIGlmICh0aGlzLnR5cGUgPT09ICdtYXAtdmFsdWUtaW5kJykge1xuICAgICAgICAgICAgY29uc3QgcHJldiA9IGdldFByZXZQcm9wcyh0aGlzLnBlZWsoMikpO1xuICAgICAgICAgICAgY29uc3Qgc3RhcnQgPSBnZXRGaXJzdEtleVN0YXJ0UHJvcHMocHJldik7XG4gICAgICAgICAgICBsZXQgc2VwO1xuICAgICAgICAgICAgaWYgKHNjYWxhci5lbmQpIHtcbiAgICAgICAgICAgICAgICBzZXAgPSBzY2FsYXIuZW5kO1xuICAgICAgICAgICAgICAgIHNlcC5wdXNoKHRoaXMuc291cmNlVG9rZW4pO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBzY2FsYXIuZW5kO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHNlcCA9IFt0aGlzLnNvdXJjZVRva2VuXTtcbiAgICAgICAgICAgIGNvbnN0IG1hcCA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnYmxvY2stbWFwJyxcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IHNjYWxhci5vZmZzZXQsXG4gICAgICAgICAgICAgICAgaW5kZW50OiBzY2FsYXIuaW5kZW50LFxuICAgICAgICAgICAgICAgIGl0ZW1zOiBbeyBzdGFydCwga2V5OiBzY2FsYXIsIHNlcCB9XVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMub25LZXlMaW5lID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXSA9IG1hcDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICB5aWVsZCogdGhpcy5saW5lRW5kKHNjYWxhcik7XG4gICAgfVxuICAgICpibG9ja1NjYWxhcihzY2FsYXIpIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ3NwYWNlJzpcbiAgICAgICAgICAgIGNhc2UgJ2NvbW1lbnQnOlxuICAgICAgICAgICAgY2FzZSAnbmV3bGluZSc6XG4gICAgICAgICAgICAgICAgc2NhbGFyLnByb3BzLnB1c2godGhpcy5zb3VyY2VUb2tlbik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY2FzZSAnc2NhbGFyJzpcbiAgICAgICAgICAgICAgICBzY2FsYXIuc291cmNlID0gdGhpcy5zb3VyY2U7XG4gICAgICAgICAgICAgICAgLy8gYmxvY2stc2NhbGFyIHNvdXJjZSBpbmNsdWRlcyB0cmFpbGluZyBuZXdsaW5lXG4gICAgICAgICAgICAgICAgdGhpcy5hdE5ld0xpbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuaW5kZW50ID0gMDtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vbk5ld0xpbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG5sID0gdGhpcy5zb3VyY2UuaW5kZXhPZignXFxuJykgKyAxO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAobmwgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub25OZXdMaW5lKHRoaXMub2Zmc2V0ICsgbmwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmwgPSB0aGlzLnNvdXJjZS5pbmRleE9mKCdcXG4nLCBubCkgKyAxO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHlpZWxkKiB0aGlzLnBvcCgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgc2hvdWxkIG5vdCBoYXBwZW4gKi9cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgeWllbGQqIHRoaXMucG9wKCk7XG4gICAgICAgICAgICAgICAgeWllbGQqIHRoaXMuc3RlcCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgICpibG9ja01hcChtYXApIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBpdCA9IG1hcC5pdGVtc1ttYXAuaXRlbXMubGVuZ3RoIC0gMV07XG4gICAgICAgIC8vIGl0LnNlcCBpcyB0cnVlLWlzaCBpZiBwYWlyIGFscmVhZHkgaGFzIGtleSBvciA6IHNlcGFyYXRvclxuICAgICAgICBzd2l0Y2ggKHRoaXMudHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnbmV3bGluZSc6XG4gICAgICAgICAgICAgICAgdGhpcy5vbktleUxpbmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpZiAoaXQudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZW5kID0gJ2VuZCcgaW4gaXQudmFsdWUgPyBpdC52YWx1ZS5lbmQgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxhc3QgPSBBcnJheS5pc0FycmF5KGVuZCkgPyBlbmRbZW5kLmxlbmd0aCAtIDFdIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICBpZiAoKGxhc3QgPT09IG51bGwgfHwgbGFzdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGFzdC50eXBlKSA9PT0gJ2NvbW1lbnQnKVxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kID09PSBudWxsIHx8IGVuZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogZW5kLnB1c2godGhpcy5zb3VyY2VUb2tlbik7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcC5pdGVtcy5wdXNoKHsgc3RhcnQ6IFt0aGlzLnNvdXJjZVRva2VuXSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXQuc2VwKVxuICAgICAgICAgICAgICAgICAgICBpdC5zZXAucHVzaCh0aGlzLnNvdXJjZVRva2VuKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGl0LnN0YXJ0LnB1c2godGhpcy5zb3VyY2VUb2tlbik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY2FzZSAnc3BhY2UnOlxuICAgICAgICAgICAgY2FzZSAnY29tbWVudCc6XG4gICAgICAgICAgICAgICAgaWYgKGl0LnZhbHVlKVxuICAgICAgICAgICAgICAgICAgICBtYXAuaXRlbXMucHVzaCh7IHN0YXJ0OiBbdGhpcy5zb3VyY2VUb2tlbl0gfSk7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXQuc2VwKVxuICAgICAgICAgICAgICAgICAgICBpdC5zZXAucHVzaCh0aGlzLnNvdXJjZVRva2VuKTtcbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuYXRJbmRlbnRlZENvbW1lbnQoaXQuc3RhcnQsIG1hcC5pbmRlbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwcmV2ID0gbWFwLml0ZW1zW21hcC5pdGVtcy5sZW5ndGggLSAyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVuZCA9IChfYSA9IHByZXYgPT09IG51bGwgfHwgcHJldiA9PT0gdm9pZCAwID8gdm9pZCAwIDogcHJldi52YWx1ZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmVuZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGVuZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShlbmQsIGl0LnN0YXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQucHVzaCh0aGlzLnNvdXJjZVRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXAuaXRlbXMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGl0LnN0YXJ0LnB1c2godGhpcy5zb3VyY2VUb2tlbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pbmRlbnQgPj0gbWFwLmluZGVudCkge1xuICAgICAgICAgICAgY29uc3QgYXROZXh0SXRlbSA9ICF0aGlzLm9uS2V5TGluZSAmJlxuICAgICAgICAgICAgICAgIHRoaXMuaW5kZW50ID09PSBtYXAuaW5kZW50ICYmXG4gICAgICAgICAgICAgICAgKGl0LnNlcCB8fCBpbmNsdWRlc05vbkVtcHR5KGl0LnN0YXJ0KSk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMudHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2FuY2hvcic6XG4gICAgICAgICAgICAgICAgY2FzZSAndGFnJzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGF0TmV4dEl0ZW0gfHwgaXQudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcC5pdGVtcy5wdXNoKHsgc3RhcnQ6IFt0aGlzLnNvdXJjZVRva2VuXSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub25LZXlMaW5lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpdC5zZXApXG4gICAgICAgICAgICAgICAgICAgICAgICBpdC5zZXAucHVzaCh0aGlzLnNvdXJjZVRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgaXQuc3RhcnQucHVzaCh0aGlzLnNvdXJjZVRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2V4cGxpY2l0LWtleS1pbmQnOlxuICAgICAgICAgICAgICAgICAgICBpZiAoIWl0LnNlcCAmJiAhaW5jbHVkZXNUb2tlbihpdC5zdGFydCwgJ2V4cGxpY2l0LWtleS1pbmQnKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0LnN0YXJ0LnB1c2godGhpcy5zb3VyY2VUb2tlbik7XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGF0TmV4dEl0ZW0gfHwgaXQudmFsdWUpXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXAuaXRlbXMucHVzaCh7IHN0YXJ0OiBbdGhpcy5zb3VyY2VUb2tlbl0gfSk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhY2sucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2Jsb2NrLW1hcCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiB0aGlzLm9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRlbnQ6IHRoaXMuaW5kZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1zOiBbeyBzdGFydDogW3RoaXMuc291cmNlVG9rZW5dIH1dXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vbktleUxpbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgY2FzZSAnbWFwLXZhbHVlLWluZCc6XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXQuc2VwKVxuICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihpdCwgeyBrZXk6IG51bGwsIHNlcDogW3RoaXMuc291cmNlVG9rZW5dIH0pO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpdC52YWx1ZSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgKGF0TmV4dEl0ZW0gJiYgIWluY2x1ZGVzVG9rZW4oaXQuc3RhcnQsICdleHBsaWNpdC1rZXktaW5kJykpKVxuICAgICAgICAgICAgICAgICAgICAgICAgbWFwLml0ZW1zLnB1c2goeyBzdGFydDogW10sIGtleTogbnVsbCwgc2VwOiBbdGhpcy5zb3VyY2VUb2tlbl0gfSk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGluY2x1ZGVzVG9rZW4oaXQuc2VwLCAnbWFwLXZhbHVlLWluZCcpKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGFjay5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnYmxvY2stbWFwJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IHRoaXMub2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGVudDogdGhpcy5pbmRlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbXM6IFt7IHN0YXJ0OiBbXSwga2V5OiBudWxsLCBzZXA6IFt0aGlzLnNvdXJjZVRva2VuXSB9XVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGluY2x1ZGVzVG9rZW4oaXQuc3RhcnQsICdleHBsaWNpdC1rZXktaW5kJykgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzRmxvd1Rva2VuKGl0LmtleSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICFpbmNsdWRlc1Rva2VuKGl0LnNlcCwgJ25ld2xpbmUnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RhcnQgPSBnZXRGaXJzdEtleVN0YXJ0UHJvcHMoaXQuc3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gaXQua2V5O1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2VwID0gaXQuc2VwO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VwLnB1c2godGhpcy5zb3VyY2VUb2tlbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlIHR5cGUgZ3VhcmQgaXMgd3JvbmcgaGVyZVxuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGl0LmtleSwgZGVsZXRlIGl0LnNlcDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhY2sucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2Jsb2NrLW1hcCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiB0aGlzLm9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRlbnQ6IHRoaXMuaW5kZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1zOiBbeyBzdGFydCwga2V5LCBzZXAgfV1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0LnNlcC5wdXNoKHRoaXMuc291cmNlVG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uS2V5TGluZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBjYXNlICdhbGlhcyc6XG4gICAgICAgICAgICAgICAgY2FzZSAnc2NhbGFyJzpcbiAgICAgICAgICAgICAgICBjYXNlICdzaW5nbGUtcXVvdGVkLXNjYWxhcic6XG4gICAgICAgICAgICAgICAgY2FzZSAnZG91YmxlLXF1b3RlZC1zY2FsYXInOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZzID0gdGhpcy5mbG93U2NhbGFyKHRoaXMudHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhdE5leHRJdGVtIHx8IGl0LnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXAuaXRlbXMucHVzaCh7IHN0YXJ0OiBbXSwga2V5OiBmcywgc2VwOiBbXSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub25LZXlMaW5lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpdC5zZXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhY2sucHVzaChmcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKGl0LCB7IGtleTogZnMsIHNlcDogW10gfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9uS2V5TGluZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJ2ID0gdGhpcy5zdGFydEJsb2NrVmFsdWUobWFwKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJ2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXROZXh0SXRlbSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ2LnR5cGUgIT09ICdibG9jay1zZXEnICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5jbHVkZXNUb2tlbihpdC5zdGFydCwgJ2V4cGxpY2l0LWtleS1pbmQnKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXAuaXRlbXMucHVzaCh7IHN0YXJ0OiBbXSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhY2sucHVzaChidik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgeWllbGQqIHRoaXMucG9wKCk7XG4gICAgICAgIHlpZWxkKiB0aGlzLnN0ZXAoKTtcbiAgICB9XG4gICAgKmJsb2NrU2VxdWVuY2Uoc2VxKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgaXQgPSBzZXEuaXRlbXNbc2VxLml0ZW1zLmxlbmd0aCAtIDFdO1xuICAgICAgICBzd2l0Y2ggKHRoaXMudHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnbmV3bGluZSc6XG4gICAgICAgICAgICAgICAgaWYgKGl0LnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVuZCA9ICdlbmQnIGluIGl0LnZhbHVlID8gaXQudmFsdWUuZW5kIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsYXN0ID0gQXJyYXkuaXNBcnJheShlbmQpID8gZW5kW2VuZC5sZW5ndGggLSAxXSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKChsYXN0ID09PSBudWxsIHx8IGxhc3QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxhc3QudHlwZSkgPT09ICdjb21tZW50JylcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZCA9PT0gbnVsbCB8fCBlbmQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVuZC5wdXNoKHRoaXMuc291cmNlVG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXEuaXRlbXMucHVzaCh7IHN0YXJ0OiBbdGhpcy5zb3VyY2VUb2tlbl0gfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgaXQuc3RhcnQucHVzaCh0aGlzLnNvdXJjZVRva2VuKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjYXNlICdzcGFjZSc6XG4gICAgICAgICAgICBjYXNlICdjb21tZW50JzpcbiAgICAgICAgICAgICAgICBpZiAoaXQudmFsdWUpXG4gICAgICAgICAgICAgICAgICAgIHNlcS5pdGVtcy5wdXNoKHsgc3RhcnQ6IFt0aGlzLnNvdXJjZVRva2VuXSB9KTtcbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuYXRJbmRlbnRlZENvbW1lbnQoaXQuc3RhcnQsIHNlcS5pbmRlbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwcmV2ID0gc2VxLml0ZW1zW3NlcS5pdGVtcy5sZW5ndGggLSAyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVuZCA9IChfYSA9IHByZXYgPT09IG51bGwgfHwgcHJldiA9PT0gdm9pZCAwID8gdm9pZCAwIDogcHJldi52YWx1ZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmVuZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGVuZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShlbmQsIGl0LnN0YXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQucHVzaCh0aGlzLnNvdXJjZVRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXEuaXRlbXMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGl0LnN0YXJ0LnB1c2godGhpcy5zb3VyY2VUb2tlbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNhc2UgJ2FuY2hvcic6XG4gICAgICAgICAgICBjYXNlICd0YWcnOlxuICAgICAgICAgICAgICAgIGlmIChpdC52YWx1ZSB8fCB0aGlzLmluZGVudCA8PSBzZXEuaW5kZW50KVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBpdC5zdGFydC5wdXNoKHRoaXMuc291cmNlVG9rZW4pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNhc2UgJ3NlcS1pdGVtLWluZCc6XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaW5kZW50ICE9PSBzZXEuaW5kZW50KVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBpZiAoaXQudmFsdWUgfHwgaW5jbHVkZXNUb2tlbihpdC5zdGFydCwgJ3NlcS1pdGVtLWluZCcpKVxuICAgICAgICAgICAgICAgICAgICBzZXEuaXRlbXMucHVzaCh7IHN0YXJ0OiBbdGhpcy5zb3VyY2VUb2tlbl0gfSk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBpdC5zdGFydC5wdXNoKHRoaXMuc291cmNlVG9rZW4pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pbmRlbnQgPiBzZXEuaW5kZW50KSB7XG4gICAgICAgICAgICBjb25zdCBidiA9IHRoaXMuc3RhcnRCbG9ja1ZhbHVlKHNlcSk7XG4gICAgICAgICAgICBpZiAoYnYpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YWNrLnB1c2goYnYpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB5aWVsZCogdGhpcy5wb3AoKTtcbiAgICAgICAgeWllbGQqIHRoaXMuc3RlcCgpO1xuICAgIH1cbiAgICAqZmxvd0NvbGxlY3Rpb24oZmMpIHtcbiAgICAgICAgY29uc3QgaXQgPSBmYy5pdGVtc1tmYy5pdGVtcy5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gJ2Zsb3ctZXJyb3ItZW5kJykge1xuICAgICAgICAgICAgbGV0IHRvcDtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICB5aWVsZCogdGhpcy5wb3AoKTtcbiAgICAgICAgICAgICAgICB0b3AgPSB0aGlzLnBlZWsoMSk7XG4gICAgICAgICAgICB9IHdoaWxlICh0b3AgJiYgdG9wLnR5cGUgPT09ICdmbG93LWNvbGxlY3Rpb24nKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChmYy5lbmQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMudHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2NvbW1hJzpcbiAgICAgICAgICAgICAgICBjYXNlICdleHBsaWNpdC1rZXktaW5kJzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpdCB8fCBpdC5zZXApXG4gICAgICAgICAgICAgICAgICAgICAgICBmYy5pdGVtcy5wdXNoKHsgc3RhcnQ6IFt0aGlzLnNvdXJjZVRva2VuXSB9KTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgaXQuc3RhcnQucHVzaCh0aGlzLnNvdXJjZVRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGNhc2UgJ21hcC12YWx1ZS1pbmQnOlxuICAgICAgICAgICAgICAgICAgICBpZiAoIWl0IHx8IGl0LnZhbHVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgZmMuaXRlbXMucHVzaCh7IHN0YXJ0OiBbXSwga2V5OiBudWxsLCBzZXA6IFt0aGlzLnNvdXJjZVRva2VuXSB9KTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaXQuc2VwKVxuICAgICAgICAgICAgICAgICAgICAgICAgaXQuc2VwLnB1c2godGhpcy5zb3VyY2VUb2tlbik7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oaXQsIHsga2V5OiBudWxsLCBzZXA6IFt0aGlzLnNvdXJjZVRva2VuXSB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3NwYWNlJzpcbiAgICAgICAgICAgICAgICBjYXNlICdjb21tZW50JzpcbiAgICAgICAgICAgICAgICBjYXNlICduZXdsaW5lJzpcbiAgICAgICAgICAgICAgICBjYXNlICdhbmNob3InOlxuICAgICAgICAgICAgICAgIGNhc2UgJ3RhZyc6XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXQgfHwgaXQudmFsdWUpXG4gICAgICAgICAgICAgICAgICAgICAgICBmYy5pdGVtcy5wdXNoKHsgc3RhcnQ6IFt0aGlzLnNvdXJjZVRva2VuXSB9KTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaXQuc2VwKVxuICAgICAgICAgICAgICAgICAgICAgICAgaXQuc2VwLnB1c2godGhpcy5zb3VyY2VUb2tlbik7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0LnN0YXJ0LnB1c2godGhpcy5zb3VyY2VUb2tlbik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBjYXNlICdhbGlhcyc6XG4gICAgICAgICAgICAgICAgY2FzZSAnc2NhbGFyJzpcbiAgICAgICAgICAgICAgICBjYXNlICdzaW5nbGUtcXVvdGVkLXNjYWxhcic6XG4gICAgICAgICAgICAgICAgY2FzZSAnZG91YmxlLXF1b3RlZC1zY2FsYXInOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZzID0gdGhpcy5mbG93U2NhbGFyKHRoaXMudHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXQgfHwgaXQudmFsdWUpXG4gICAgICAgICAgICAgICAgICAgICAgICBmYy5pdGVtcy5wdXNoKHsgc3RhcnQ6IFtdLCBrZXk6IGZzLCBzZXA6IFtdIH0pO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpdC5zZXApXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YWNrLnB1c2goZnMpO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKGl0LCB7IGtleTogZnMsIHNlcDogW10gfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAnZmxvdy1tYXAtZW5kJzpcbiAgICAgICAgICAgICAgICBjYXNlICdmbG93LXNlcS1lbmQnOlxuICAgICAgICAgICAgICAgICAgICBmYy5lbmQucHVzaCh0aGlzLnNvdXJjZVRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYnYgPSB0aGlzLnN0YXJ0QmxvY2tWYWx1ZShmYyk7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSBzaG91bGQgbm90IGhhcHBlbiAqL1xuICAgICAgICAgICAgaWYgKGJ2KVxuICAgICAgICAgICAgICAgIHRoaXMuc3RhY2sucHVzaChidik7XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB5aWVsZCogdGhpcy5wb3AoKTtcbiAgICAgICAgICAgICAgICB5aWVsZCogdGhpcy5zdGVwKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBwYXJlbnQgPSB0aGlzLnBlZWsoMik7XG4gICAgICAgICAgICBpZiAocGFyZW50LnR5cGUgPT09ICdibG9jay1tYXAnICYmXG4gICAgICAgICAgICAgICAgKHRoaXMudHlwZSA9PT0gJ21hcC12YWx1ZS1pbmQnIHx8XG4gICAgICAgICAgICAgICAgICAgICh0aGlzLnR5cGUgPT09ICduZXdsaW5lJyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgIXBhcmVudC5pdGVtc1twYXJlbnQuaXRlbXMubGVuZ3RoIC0gMV0uc2VwKSkpIHtcbiAgICAgICAgICAgICAgICB5aWVsZCogdGhpcy5wb3AoKTtcbiAgICAgICAgICAgICAgICB5aWVsZCogdGhpcy5zdGVwKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLnR5cGUgPT09ICdtYXAtdmFsdWUtaW5kJyAmJlxuICAgICAgICAgICAgICAgIHBhcmVudC50eXBlICE9PSAnZmxvdy1jb2xsZWN0aW9uJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHByZXYgPSBnZXRQcmV2UHJvcHMocGFyZW50KTtcbiAgICAgICAgICAgICAgICBjb25zdCBzdGFydCA9IGdldEZpcnN0S2V5U3RhcnRQcm9wcyhwcmV2KTtcbiAgICAgICAgICAgICAgICBmaXhGbG93U2VxSXRlbXMoZmMpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNlcCA9IGZjLmVuZC5zcGxpY2UoMSwgZmMuZW5kLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgc2VwLnB1c2godGhpcy5zb3VyY2VUb2tlbik7XG4gICAgICAgICAgICAgICAgY29uc3QgbWFwID0ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnYmxvY2stbWFwJyxcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiBmYy5vZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgIGluZGVudDogZmMuaW5kZW50LFxuICAgICAgICAgICAgICAgICAgICBpdGVtczogW3sgc3RhcnQsIGtleTogZmMsIHNlcCB9XVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdGhpcy5vbktleUxpbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXSA9IG1hcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHlpZWxkKiB0aGlzLmxpbmVFbmQoZmMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZsb3dTY2FsYXIodHlwZSkge1xuICAgICAgICBpZiAodGhpcy5vbk5ld0xpbmUpIHtcbiAgICAgICAgICAgIGxldCBubCA9IHRoaXMuc291cmNlLmluZGV4T2YoJ1xcbicpICsgMTtcbiAgICAgICAgICAgIHdoaWxlIChubCAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMub25OZXdMaW5lKHRoaXMub2Zmc2V0ICsgbmwpO1xuICAgICAgICAgICAgICAgIG5sID0gdGhpcy5zb3VyY2UuaW5kZXhPZignXFxuJywgbmwpICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgIG9mZnNldDogdGhpcy5vZmZzZXQsXG4gICAgICAgICAgICBpbmRlbnQ6IHRoaXMuaW5kZW50LFxuICAgICAgICAgICAgc291cmNlOiB0aGlzLnNvdXJjZVxuICAgICAgICB9O1xuICAgIH1cbiAgICBzdGFydEJsb2NrVmFsdWUocGFyZW50KSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy50eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdhbGlhcyc6XG4gICAgICAgICAgICBjYXNlICdzY2FsYXInOlxuICAgICAgICAgICAgY2FzZSAnc2luZ2xlLXF1b3RlZC1zY2FsYXInOlxuICAgICAgICAgICAgY2FzZSAnZG91YmxlLXF1b3RlZC1zY2FsYXInOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZsb3dTY2FsYXIodGhpcy50eXBlKTtcbiAgICAgICAgICAgIGNhc2UgJ2Jsb2NrLXNjYWxhci1oZWFkZXInOlxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdibG9jay1zY2FsYXInLFxuICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IHRoaXMub2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICBpbmRlbnQ6IHRoaXMuaW5kZW50LFxuICAgICAgICAgICAgICAgICAgICBwcm9wczogW3RoaXMuc291cmNlVG9rZW5dLFxuICAgICAgICAgICAgICAgICAgICBzb3VyY2U6ICcnXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNhc2UgJ2Zsb3ctbWFwLXN0YXJ0JzpcbiAgICAgICAgICAgIGNhc2UgJ2Zsb3ctc2VxLXN0YXJ0JzpcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnZmxvdy1jb2xsZWN0aW9uJyxcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiB0aGlzLm9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgaW5kZW50OiB0aGlzLmluZGVudCxcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHRoaXMuc291cmNlVG9rZW4sXG4gICAgICAgICAgICAgICAgICAgIGl0ZW1zOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgZW5kOiBbXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjYXNlICdzZXEtaXRlbS1pbmQnOlxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdibG9jay1zZXEnLFxuICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IHRoaXMub2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICBpbmRlbnQ6IHRoaXMuaW5kZW50LFxuICAgICAgICAgICAgICAgICAgICBpdGVtczogW3sgc3RhcnQ6IFt0aGlzLnNvdXJjZVRva2VuXSB9XVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjYXNlICdleHBsaWNpdC1rZXktaW5kJzoge1xuICAgICAgICAgICAgICAgIHRoaXMub25LZXlMaW5lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjb25zdCBwcmV2ID0gZ2V0UHJldlByb3BzKHBhcmVudCk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhcnQgPSBnZXRGaXJzdEtleVN0YXJ0UHJvcHMocHJldik7XG4gICAgICAgICAgICAgICAgc3RhcnQucHVzaCh0aGlzLnNvdXJjZVRva2VuKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnYmxvY2stbWFwJyxcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiB0aGlzLm9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgaW5kZW50OiB0aGlzLmluZGVudCxcbiAgICAgICAgICAgICAgICAgICAgaXRlbXM6IFt7IHN0YXJ0IH1dXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ21hcC12YWx1ZS1pbmQnOiB7XG4gICAgICAgICAgICAgICAgdGhpcy5vbktleUxpbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNvbnN0IHByZXYgPSBnZXRQcmV2UHJvcHMocGFyZW50KTtcbiAgICAgICAgICAgICAgICBjb25zdCBzdGFydCA9IGdldEZpcnN0S2V5U3RhcnRQcm9wcyhwcmV2KTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnYmxvY2stbWFwJyxcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiB0aGlzLm9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgaW5kZW50OiB0aGlzLmluZGVudCxcbiAgICAgICAgICAgICAgICAgICAgaXRlbXM6IFt7IHN0YXJ0LCBrZXk6IG51bGwsIHNlcDogW3RoaXMuc291cmNlVG9rZW5dIH1dXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgYXRJbmRlbnRlZENvbW1lbnQoc3RhcnQsIGluZGVudCkge1xuICAgICAgICBpZiAodGhpcy50eXBlICE9PSAnY29tbWVudCcpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLmluZGVudCA8PSBpbmRlbnQpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiBzdGFydC5ldmVyeShzdCA9PiBzdC50eXBlID09PSAnbmV3bGluZScgfHwgc3QudHlwZSA9PT0gJ3NwYWNlJyk7XG4gICAgfVxuICAgICpkb2N1bWVudEVuZChkb2NFbmQpIHtcbiAgICAgICAgaWYgKHRoaXMudHlwZSAhPT0gJ2RvYy1tb2RlJykge1xuICAgICAgICAgICAgaWYgKGRvY0VuZC5lbmQpXG4gICAgICAgICAgICAgICAgZG9jRW5kLmVuZC5wdXNoKHRoaXMuc291cmNlVG9rZW4pO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGRvY0VuZC5lbmQgPSBbdGhpcy5zb3VyY2VUb2tlbl07XG4gICAgICAgICAgICBpZiAodGhpcy50eXBlID09PSAnbmV3bGluZScpXG4gICAgICAgICAgICAgICAgeWllbGQqIHRoaXMucG9wKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgKmxpbmVFbmQodG9rZW4pIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2NvbW1hJzpcbiAgICAgICAgICAgIGNhc2UgJ2RvYy1zdGFydCc6XG4gICAgICAgICAgICBjYXNlICdkb2MtZW5kJzpcbiAgICAgICAgICAgIGNhc2UgJ2Zsb3ctc2VxLWVuZCc6XG4gICAgICAgICAgICBjYXNlICdmbG93LW1hcC1lbmQnOlxuICAgICAgICAgICAgY2FzZSAnbWFwLXZhbHVlLWluZCc6XG4gICAgICAgICAgICAgICAgeWllbGQqIHRoaXMucG9wKCk7XG4gICAgICAgICAgICAgICAgeWllbGQqIHRoaXMuc3RlcCgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbmV3bGluZSc6XG4gICAgICAgICAgICAgICAgdGhpcy5vbktleUxpbmUgPSBmYWxzZTtcbiAgICAgICAgICAgIC8vIGZhbGx0aHJvdWdoXG4gICAgICAgICAgICBjYXNlICdzcGFjZSc6XG4gICAgICAgICAgICBjYXNlICdjb21tZW50JzpcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgLy8gYWxsIG90aGVyIHZhbHVlcyBhcmUgZXJyb3JzXG4gICAgICAgICAgICAgICAgaWYgKHRva2VuLmVuZClcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4uZW5kLnB1c2godGhpcy5zb3VyY2VUb2tlbik7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICB0b2tlbi5lbmQgPSBbdGhpcy5zb3VyY2VUb2tlbl07XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gJ25ld2xpbmUnKVxuICAgICAgICAgICAgICAgICAgICB5aWVsZCogdGhpcy5wb3AoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IHsgUGFyc2VyIH07XG4iLCAiaW1wb3J0IHsgQ29tcG9zZXIgfSBmcm9tICcuL2NvbXBvc2UvY29tcG9zZXIuanMnO1xuaW1wb3J0IHsgRG9jdW1lbnQgfSBmcm9tICcuL2RvYy9Eb2N1bWVudC5qcyc7XG5pbXBvcnQgeyBwcmV0dGlmeUVycm9yLCBZQU1MUGFyc2VFcnJvciB9IGZyb20gJy4vZXJyb3JzLmpzJztcbmltcG9ydCB7IHdhcm4gfSBmcm9tICcuL2xvZy5qcyc7XG5pbXBvcnQgeyBMaW5lQ291bnRlciB9IGZyb20gJy4vcGFyc2UvbGluZS1jb3VudGVyLmpzJztcbmltcG9ydCB7IFBhcnNlciB9IGZyb20gJy4vcGFyc2UvcGFyc2VyLmpzJztcblxuZnVuY3Rpb24gcGFyc2VPcHRpb25zKG9wdGlvbnMpIHtcbiAgICBjb25zdCBwcmV0dHlFcnJvcnMgPSBvcHRpb25zLnByZXR0eUVycm9ycyAhPT0gZmFsc2U7XG4gICAgY29uc3QgbGluZUNvdW50ZXIgPSBvcHRpb25zLmxpbmVDb3VudGVyIHx8IChwcmV0dHlFcnJvcnMgJiYgbmV3IExpbmVDb3VudGVyKCkpIHx8IG51bGw7XG4gICAgcmV0dXJuIHsgbGluZUNvdW50ZXIsIHByZXR0eUVycm9ycyB9O1xufVxuLyoqXG4gKiBQYXJzZSB0aGUgaW5wdXQgYXMgYSBzdHJlYW0gb2YgWUFNTCBkb2N1bWVudHMuXG4gKlxuICogRG9jdW1lbnRzIHNob3VsZCBiZSBzZXBhcmF0ZWQgZnJvbSBlYWNoIG90aGVyIGJ5IGAuLi5gIG9yIGAtLS1gIG1hcmtlciBsaW5lcy5cbiAqXG4gKiBAcmV0dXJucyBJZiBhbiBlbXB0eSBgZG9jc2AgYXJyYXkgaXMgcmV0dXJuZWQsIGl0IHdpbGwgYmUgb2YgdHlwZVxuICogICBFbXB0eVN0cmVhbSBhbmQgY29udGFpbiBhZGRpdGlvbmFsIHN0cmVhbSBpbmZvcm1hdGlvbi4gSW5cbiAqICAgVHlwZVNjcmlwdCwgeW91IHNob3VsZCB1c2UgYCdlbXB0eScgaW4gZG9jc2AgYXMgYSB0eXBlIGd1YXJkIGZvciBpdC5cbiAqL1xuZnVuY3Rpb24gcGFyc2VBbGxEb2N1bWVudHMoc291cmNlLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IGxpbmVDb3VudGVyLCBwcmV0dHlFcnJvcnMgfSA9IHBhcnNlT3B0aW9ucyhvcHRpb25zKTtcbiAgICBjb25zdCBwYXJzZXIgPSBuZXcgUGFyc2VyKGxpbmVDb3VudGVyID09PSBudWxsIHx8IGxpbmVDb3VudGVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsaW5lQ291bnRlci5hZGROZXdMaW5lKTtcbiAgICBjb25zdCBjb21wb3NlciA9IG5ldyBDb21wb3NlcihvcHRpb25zKTtcbiAgICBjb25zdCBkb2NzID0gQXJyYXkuZnJvbShjb21wb3Nlci5jb21wb3NlKHBhcnNlci5wYXJzZShzb3VyY2UpKSk7XG4gICAgaWYgKHByZXR0eUVycm9ycyAmJiBsaW5lQ291bnRlcilcbiAgICAgICAgZm9yIChjb25zdCBkb2Mgb2YgZG9jcykge1xuICAgICAgICAgICAgZG9jLmVycm9ycy5mb3JFYWNoKHByZXR0aWZ5RXJyb3Ioc291cmNlLCBsaW5lQ291bnRlcikpO1xuICAgICAgICAgICAgZG9jLndhcm5pbmdzLmZvckVhY2gocHJldHRpZnlFcnJvcihzb3VyY2UsIGxpbmVDb3VudGVyKSk7XG4gICAgICAgIH1cbiAgICBpZiAoZG9jcy5sZW5ndGggPiAwKVxuICAgICAgICByZXR1cm4gZG9jcztcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihbXSwgeyBlbXB0eTogdHJ1ZSB9LCBjb21wb3Nlci5zdHJlYW1JbmZvKCkpO1xufVxuLyoqIFBhcnNlIGFuIGlucHV0IHN0cmluZyBpbnRvIGEgc2luZ2xlIFlBTUwuRG9jdW1lbnQgKi9cbmZ1bmN0aW9uIHBhcnNlRG9jdW1lbnQoc291cmNlLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IGxpbmVDb3VudGVyLCBwcmV0dHlFcnJvcnMgfSA9IHBhcnNlT3B0aW9ucyhvcHRpb25zKTtcbiAgICBjb25zdCBwYXJzZXIgPSBuZXcgUGFyc2VyKGxpbmVDb3VudGVyID09PSBudWxsIHx8IGxpbmVDb3VudGVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsaW5lQ291bnRlci5hZGROZXdMaW5lKTtcbiAgICBjb25zdCBjb21wb3NlciA9IG5ldyBDb21wb3NlcihvcHRpb25zKTtcbiAgICAvLyBgZG9jYCBpcyBhbHdheXMgc2V0IGJ5IGNvbXBvc2UuZW5kKHRydWUpIGF0IHRoZSB2ZXJ5IGxhdGVzdFxuICAgIGxldCBkb2MgPSBudWxsO1xuICAgIGZvciAoY29uc3QgX2RvYyBvZiBjb21wb3Nlci5jb21wb3NlKHBhcnNlci5wYXJzZShzb3VyY2UpLCB0cnVlLCBzb3VyY2UubGVuZ3RoKSkge1xuICAgICAgICBpZiAoIWRvYylcbiAgICAgICAgICAgIGRvYyA9IF9kb2M7XG4gICAgICAgIGVsc2UgaWYgKGRvYy5vcHRpb25zLmxvZ0xldmVsICE9PSAnc2lsZW50Jykge1xuICAgICAgICAgICAgZG9jLmVycm9ycy5wdXNoKG5ldyBZQU1MUGFyc2VFcnJvcihfZG9jLnJhbmdlLnNsaWNlKDAsIDIpLCAnTVVMVElQTEVfRE9DUycsICdTb3VyY2UgY29udGFpbnMgbXVsdGlwbGUgZG9jdW1lbnRzOyBwbGVhc2UgdXNlIFlBTUwucGFyc2VBbGxEb2N1bWVudHMoKScpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChwcmV0dHlFcnJvcnMgJiYgbGluZUNvdW50ZXIpIHtcbiAgICAgICAgZG9jLmVycm9ycy5mb3JFYWNoKHByZXR0aWZ5RXJyb3Ioc291cmNlLCBsaW5lQ291bnRlcikpO1xuICAgICAgICBkb2Mud2FybmluZ3MuZm9yRWFjaChwcmV0dGlmeUVycm9yKHNvdXJjZSwgbGluZUNvdW50ZXIpKTtcbiAgICB9XG4gICAgcmV0dXJuIGRvYztcbn1cbmZ1bmN0aW9uIHBhcnNlKHNyYywgcmV2aXZlciwgb3B0aW9ucykge1xuICAgIGxldCBfcmV2aXZlciA9IHVuZGVmaW5lZDtcbiAgICBpZiAodHlwZW9mIHJldml2ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgX3Jldml2ZXIgPSByZXZpdmVyO1xuICAgIH1cbiAgICBlbHNlIGlmIChvcHRpb25zID09PSB1bmRlZmluZWQgJiYgcmV2aXZlciAmJiB0eXBlb2YgcmV2aXZlciA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgb3B0aW9ucyA9IHJldml2ZXI7XG4gICAgfVxuICAgIGNvbnN0IGRvYyA9IHBhcnNlRG9jdW1lbnQoc3JjLCBvcHRpb25zKTtcbiAgICBpZiAoIWRvYylcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgZG9jLndhcm5pbmdzLmZvckVhY2god2FybmluZyA9PiB3YXJuKGRvYy5vcHRpb25zLmxvZ0xldmVsLCB3YXJuaW5nKSk7XG4gICAgaWYgKGRvYy5lcnJvcnMubGVuZ3RoID4gMCkge1xuICAgICAgICBpZiAoZG9jLm9wdGlvbnMubG9nTGV2ZWwgIT09ICdzaWxlbnQnKVxuICAgICAgICAgICAgdGhyb3cgZG9jLmVycm9yc1swXTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgZG9jLmVycm9ycyA9IFtdO1xuICAgIH1cbiAgICByZXR1cm4gZG9jLnRvSlMoT2JqZWN0LmFzc2lnbih7IHJldml2ZXI6IF9yZXZpdmVyIH0sIG9wdGlvbnMpKTtcbn1cbmZ1bmN0aW9uIHN0cmluZ2lmeSh2YWx1ZSwgcmVwbGFjZXIsIG9wdGlvbnMpIHtcbiAgICBsZXQgX3JlcGxhY2VyID0gbnVsbDtcbiAgICBpZiAodHlwZW9mIHJlcGxhY2VyID09PSAnZnVuY3Rpb24nIHx8IEFycmF5LmlzQXJyYXkocmVwbGFjZXIpKSB7XG4gICAgICAgIF9yZXBsYWNlciA9IHJlcGxhY2VyO1xuICAgIH1cbiAgICBlbHNlIGlmIChvcHRpb25zID09PSB1bmRlZmluZWQgJiYgcmVwbGFjZXIpIHtcbiAgICAgICAgb3B0aW9ucyA9IHJlcGxhY2VyO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdzdHJpbmcnKVxuICAgICAgICBvcHRpb25zID0gb3B0aW9ucy5sZW5ndGg7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnbnVtYmVyJykge1xuICAgICAgICBjb25zdCBpbmRlbnQgPSBNYXRoLnJvdW5kKG9wdGlvbnMpO1xuICAgICAgICBvcHRpb25zID0gaW5kZW50IDwgMSA/IHVuZGVmaW5lZCA6IGluZGVudCA+IDggPyB7IGluZGVudDogOCB9IDogeyBpbmRlbnQgfTtcbiAgICB9XG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3QgeyBrZWVwVW5kZWZpbmVkIH0gPSBvcHRpb25zIHx8IHJlcGxhY2VyIHx8IHt9O1xuICAgICAgICBpZiAoIWtlZXBVbmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IERvY3VtZW50KHZhbHVlLCBfcmVwbGFjZXIsIG9wdGlvbnMpLnRvU3RyaW5nKG9wdGlvbnMpO1xufVxuXG5leHBvcnQgeyBwYXJzZSwgcGFyc2VBbGxEb2N1bWVudHMsIHBhcnNlRG9jdW1lbnQsIHN0cmluZ2lmeSB9O1xuIiwgImltcG9ydCB7IEFwcCwgRWRpdG9yLCBGdXp6eVN1Z2dlc3RNb2RhbCwgRnV6enlNYXRjaCB9IGZyb20gXCJvYnNpZGlhblwiO1xuXG5pbnRlcmZhY2UgRm9vdG5vdGVUeXBlIHtcbiAgdHlwZTogc3RyaW5nO1xuICBkZXNjcmlwdGlvbjogc3RyaW5nO1xufVxuXG5jb25zdCBBTExfVFlQRVMgPSBbXG4gIHtcbiAgICB0eXBlOiBcImQvcXVlc3Rpb25cIixcbiAgICBkZXNjcmlwdGlvbjogXCJRdWVzdGlvblwiXG4gIH0sXG4gIHtcbiAgICB0eXBlOiBcImQvYW5zd2VyXCIsXG4gICAgZGVzY3JpcHRpb246IFwiQW5zd2VyXCJcbiAgfSxcbiAge1xuICAgIHR5cGU6IFwiZC9zb2x2ZXNcIixcbiAgICBkZXNjcmlwdGlvbjogXCJTb2x2ZXMgc29tZSBwcm9ibGVtXCJcbiAgfSxcbiAge1xuICAgIHR5cGU6IFwiZC9yZWZcIixcbiAgICBkZXNjcmlwdGlvbjogXCJSZWZlcmVuY2VcIlxuICB9LFxuICB7XG4gICAgdHlwZTogXCJkL3NlbGZ0aGlua1wiLFxuICAgIGRlc2NyaXB0aW9uOiBcIlNlbGYgdGhpbmtcIlxuICB9LFxuICB7XG4gICAgdHlwZTogXCJkL25vdHN1cmVcIixcbiAgICBkZXNjcmlwdGlvbjogXCJOb3Qgc3VyZVwiXG4gIH0sXG4gIHtcbiAgICB0eXBlOiBcImQvYTFcdTIzRjlcdUZFMEZcIixcbiAgICBkZXNjcmlwdGlvbjogXCJBMSAtIG15IGV4cGVyaWVuY2VcIlxuICB9LFxuICB7XG4gICAgdHlwZTogXCJkL2EyXHUyM0ZBXHVGRTBGXCIsXG4gICAgZGVzY3JpcHRpb246IFwiQTIgLSBmdXR1cmUgYWN0aW9uXCJcbiAgfSxcbiAge1xuICAgIHR5cGU6IFwiZC9jXHVEODNEXHVERDA0XCIsXG4gICAgZGVzY3JpcHRpb246IFwiQ29udGV4dFwiXG4gIH0sXG4gIHtcbiAgICB0eXBlOiBcImQvd1x1MjNFQVwiLFxuICAgIGRlc2NyaXB0aW9uOiBcIklkZWEgQ29tcGFzcyAtIFdlc3QgLSBXaGF0IGFyZSBzaW1pbGFyIC8gc3VwcG9ydGluZyBpZGVhP1wiXG4gIH0sXG4gIHtcbiAgICB0eXBlOiBcImQvblx1MjNFQlwiLFxuICAgIGRlc2NyaXB0aW9uOiBcIklkZWEgQ29tcGFzcyAtIE5vcnRoIC0gV2hlcmUgZG9lcyB0aGlzIGlkZWEgY29tZSBmcm9tP1wiXG4gIH0sXG4gIHtcbiAgICB0eXBlOiBcImQvc1x1MjNFQ1wiLFxuICAgIGRlc2NyaXB0aW9uOiBcIklkZWEgQ29tcGFzcyAtIFNvdXRoIC0gV2hlcmUgZG9lcyB0aGUgaWRlYSBsZWFkIHRvP1wiXG4gIH0sXG4gIHtcbiAgICB0eXBlOiBcImQvdG9NZXJnZVwiLFxuICAgIGRlc2NyaXB0aW9uOiBcIlRPRE8gLSBUbyBNZXJnZSB3aXRoIGFub3RoZXIgbm90ZVwiXG4gIH0sXG4gIHtcbiAgICB0eXBlOiBcImQvdG9Nb3ZlXCIsXG4gICAgZGVzY3JpcHRpb246IFwiVE9ETyAtIFRvIE1lcmdlIHdpdGggYW5vdGhlciBub3RlXCJcbiAgfSxcbiAge1xuICAgIHR5cGU6IFwiZC90b1NwbGl0XCIsXG4gICAgZGVzY3JpcHRpb246IFwiVG9ETyAtIFRvIFNwbGl0IHRvIG11bHRpcGxlIG5vdGVcIlxuICB9LFxuICB7XG4gICAgdHlwZTogXCJkL3RvQ2FyZFwiLFxuICAgIGRlc2NyaXB0aW9uOiBcIlRPRE8gLSBUbyBXcml0ZSBjYXJkXCJcbiAgfSxcbl07XG5cbmV4cG9ydCBjbGFzcyBBZGRGb290bm90ZVRhZ01vZGFsIGV4dGVuZHMgRnV6enlTdWdnZXN0TW9kYWw8Rm9vdG5vdGVUeXBlPiB7XG5cbiAgZWRpdG9yOiBFZGl0b3JcblxuICBjb25zdHJ1Y3RvcihhcHA6IEFwcCwgZWRpdG9yOiBFZGl0b3IpXG4gIHtcbiAgICBzdXBlcihhcHApXG4gICAgdGhpcy5lZGl0b3IgPSBlZGl0b3JcbiAgfVxuXG4gIGdldEl0ZW1zKCk6IEZvb3Rub3RlVHlwZVtdIHtcbiAgICByZXR1cm4gQUxMX1RZUEVTO1xuICB9XG5cbiAgZ2V0SXRlbVRleHQobm90ZVR5cGU6IEZvb3Rub3RlVHlwZSk6IHN0cmluZyB7XG4gICAgcmV0dXJuIG5vdGVUeXBlLnR5cGU7XG4gIH1cblxuICBzdGF0aWMgcmVtb3ZlVGFnKGxpbmU6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgQUxMX1RZUEVTLmZvckVhY2goKG5vdGVUeXBlKSA9PiBsaW5lID0gbGluZS5yZXBsYWNlKGAjJHtub3RlVHlwZS50eXBlfSBgLCAnJykpXG4gICAgcmV0dXJuIGxpbmVcbiAgfVxuXG4gIC8vIFJlbmRlcnMgZWFjaCBzdWdnZXN0aW9uIGl0ZW0uXG4gIHJlbmRlclN1Z2dlc3Rpb24oY2hvb3Nlbk5vdGVUeXBlTWF0Y2g6IEZ1enp5TWF0Y2g8Rm9vdG5vdGVUeXBlPiwgZWw6IEhUTUxFbGVtZW50KSB7XG4gICAgY29uc3Qgbm90ZVR5cGUgPSBjaG9vc2VuTm90ZVR5cGVNYXRjaC5pdGVtXG4gICAgZWwuY3JlYXRlRWwoXCJkaXZcIiwgeyB0ZXh0OiBub3RlVHlwZS50eXBlIH0pO1xuICAgIGVsLmNyZWF0ZUVsKFwic21hbGxcIiwgeyB0ZXh0OiBub3RlVHlwZS5kZXNjcmlwdGlvbiB9KTtcbiAgfVxuXG4gIGNvbnRhaW5zVHlwZShsaW5lOiBTdHJpbmcpIDogQm9vbGVhbiB7XG4gICAgcmV0dXJuIEFMTF9UWVBFUy5maWx0ZXIoKG5vdGVUeXBlKSA9PiBsaW5lLmNvbnRhaW5zKG5vdGVUeXBlLnR5cGUpKS5sZW5ndGggPiAwXG4gIH1cblxuICAvLyBQZXJmb3JtIGFjdGlvbiBvbiB0aGUgc2VsZWN0ZWQgc3VnZ2VzdGlvbi5cbiAgb25DaG9vc2VJdGVtKGNob29zZW5Ob3RlVHlwZTogRm9vdG5vdGVUeXBlLCBldnQ6IE1vdXNlRXZlbnQgfCBLZXlib2FyZEV2ZW50KSB7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gdGhpcy5lZGl0b3IuZ2V0U2VsZWN0aW9uKClcbiAgICBjb25zdCByZXBsYWNlZFN0ciA9IGAjJHtjaG9vc2VuTm90ZVR5cGUudHlwZX0gYFxuICAgIGlmIChzZWxlY3Rpb24ubGVuZ3RoICE9IDApIHtcbiAgICAgICAgdGhpcy5lZGl0b3IucmVwbGFjZVNlbGVjdGlvbihyZXBsYWNlZFN0cik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgY3Vyc29yID0gdGhpcy5lZGl0b3IuZ2V0Q3Vyc29yKCk7XG4gICAgICAgIHRoaXMuZWRpdG9yLnJlcGxhY2VSYW5nZShyZXBsYWNlZFN0ciwgY3Vyc29yKTtcbiAgICAgICAgY3Vyc29yLmNoID0gY3Vyc29yLmNoICsgcmVwbGFjZWRTdHIubGVuZ3RoO1xuICAgICAgICB0aGlzLmVkaXRvci5zZXRDdXJzb3IoY3Vyc29yKTtcbiAgICB9XG4gIH1cbn0iLCAiaW1wb3J0IHsgQXBwLCBFZGl0b3IsIEZ1enp5U3VnZ2VzdE1vZGFsLCBGdXp6eU1hdGNoIH0gZnJvbSBcIm9ic2lkaWFuXCI7XG5cbmludGVyZmFjZSBDb21tZW50VHlwZSB7XG4gIHR5cGU6IHN0cmluZztcbiAgY3Vyc29yOiBzdHJpbmc7XG4gIGRlc2NyaXB0aW9uOiBzdHJpbmc7XG59XG5cbmNvbnN0IEFMTF9UWVBFUyA9IFtcbiAge1xuICAgIHR5cGU6IFwiblwiLFxuICAgIGN1cnNvcjogXCJjXCIsXG4gICAgZGVzY3JpcHRpb246IFwiTiBDdXJzb3JcIlxuICB9LFxuICB7XG4gICAgdHlwZTogXCJuXCIsXG4gICAgY3Vyc29yOiBcImJcIixcbiAgICBkZXNjcmlwdGlvbjogXCJOIEJlZ2lubmluZyBvZiBsaW5lXCJcbiAgfSxcbiAge1xuICAgIHR5cGU6IFwiblwiLFxuICAgIGN1cnNvcjogXCJlXCIsXG4gICAgZGVzY3JpcHRpb246IFwiTiBFbmQgb2YgbGluZVwiXG4gIH0sXG4gIHtcbiAgICB0eXBlOiBcIndcIixcbiAgICBjdXJzb3I6IFwiY1wiLFxuICAgIGRlc2NyaXB0aW9uOiBcIlcgQ3Vyc29yXCJcbiAgfSxcbiAge1xuICAgIHR5cGU6IFwid1wiLFxuICAgIGN1cnNvcjogXCJiXCIsXG4gICAgZGVzY3JpcHRpb246IFwiVyBCZWdpbm5pbmcgb2YgbGluZVwiXG4gIH0sXG4gIHtcbiAgICB0eXBlOiBcIndcIixcbiAgICBjdXJzb3I6IFwiZVwiLFxuICAgIGRlc2NyaXB0aW9uOiBcIlcgRW5kIG9mIGxpbmVcIlxuICB9XG5dO1xuXG5leHBvcnQgY2xhc3MgQWRkVGFza1RhZ01vZGFsIGV4dGVuZHMgRnV6enlTdWdnZXN0TW9kYWw8Q29tbWVudFR5cGU+IHtcblxuICBlZGl0b3I6IEVkaXRvclxuICB0YXNrVHlwZTogU3RyaW5nXG5cbiAgY29uc3RydWN0b3IoYXBwOiBBcHAsIGVkaXRvcjogRWRpdG9yLCB0YXNrVHlwZTogU3RyaW5nKVxuICB7XG4gICAgc3VwZXIoYXBwKVxuICAgIHRoaXMuZWRpdG9yID0gZWRpdG9yXG4gICAgdGhpcy50YXNrVHlwZSA9IHRhc2tUeXBlXG4gIH1cblxuICBnZXRJdGVtcygpOiBDb21tZW50VHlwZVtdIHtcbiAgICByZXR1cm4gQUxMX1RZUEVTO1xuICB9XG5cbiAgZ2V0SXRlbVRleHQobm90ZVR5cGU6IENvbW1lbnRUeXBlKTogc3RyaW5nIHtcbiAgICByZXR1cm4gbm90ZVR5cGUudHlwZSArIG5vdGVUeXBlLmN1cnNvcjtcbiAgfVxuXG4gIC8vIFJlbmRlcnMgZWFjaCBzdWdnZXN0aW9uIGl0ZW0uXG4gIHJlbmRlclN1Z2dlc3Rpb24oY2hvb3Nlbk5vdGVUeXBlTWF0Y2g6IEZ1enp5TWF0Y2g8Q29tbWVudFR5cGU+LCBlbDogSFRNTEVsZW1lbnQpIHtcbiAgICBjb25zdCBub3RlVHlwZSA9IGNob29zZW5Ob3RlVHlwZU1hdGNoLml0ZW1cbiAgICBlbC5jcmVhdGVFbChcImRpdlwiLCB7IHRleHQ6IG5vdGVUeXBlLnR5cGUgKyBcIiBcIiArIG5vdGVUeXBlLmN1cnNvciB9KTtcbiAgICBlbC5jcmVhdGVFbChcInNtYWxsXCIsIHsgdGV4dDogbm90ZVR5cGUuZGVzY3JpcHRpb24gfSk7XG4gIH1cblxuICBjb250YWluc1R5cGUobGluZTogU3RyaW5nKSA6IEJvb2xlYW4ge1xuICAgIHJldHVybiBBTExfVFlQRVMuZmlsdGVyKChub3RlVHlwZSkgPT4gbGluZS5jb250YWlucyhub3RlVHlwZS50eXBlKSkubGVuZ3RoID4gMFxuICB9XG5cbiAgLy8gUGVyZm9ybSBhY3Rpb24gb24gdGhlIHNlbGVjdGVkIHN1Z2dlc3Rpb24uXG4gIG9uQ2hvb3NlSXRlbShjaG9vc2VuTm90ZVR5cGU6IENvbW1lbnRUeXBlLCBldnQ6IE1vdXNlRXZlbnQgfCBLZXlib2FyZEV2ZW50KSB7XG4gICAgY29uc3QgY3Vyc29yID0gdGhpcy5lZGl0b3IuZ2V0Q3Vyc29yKClcbiAgICBjb25zdCBsaW5lID0gdGhpcy5lZGl0b3IuZ2V0TGluZShjdXJzb3IubGluZSk7XG4gICAgXG4gICAgaWYgKGNob29zZW5Ob3RlVHlwZS5jdXJzb3IgPT0gXCJjXCIpIHtcbiAgICAgIHRoaXMuZWRpdG9yLnJlcGxhY2VSYW5nZShgJHtsaW5lLmNoYXJBdChjdXJzb3IuY2ggLSAxKSAhPSAnICcgPyAnICcgOiBcIlwifSMke2Nob29zZW5Ob3RlVHlwZS50eXBlfSR7dGhpcy50YXNrVHlwZX0gYCwgY3Vyc29yKTsgIFxuICAgICAgY3Vyc29yLmNoID0gY3Vyc29yLmNoICsgNCArIChsaW5lLmNoYXJBdChjdXJzb3IuY2ggLSAxKSAhPSAnICcgPyAxIDogMCk7XG5cdFx0ICB0aGlzLmVkaXRvci5zZXRDdXJzb3IoY3Vyc29yKTtcbiAgICB9IGVsc2UgaWYgKGNob29zZW5Ob3RlVHlwZS5jdXJzb3IgPT0gXCJiXCIpIHtcbiAgICAgIGxldCBtb2RpZmllZExpbmUgPSBsaW5lO1xuICAgICAgaWYgKC9eXFx0Ki0gLy50ZXN0KGxpbmUpKSB7XG4gICAgICAgIG1vZGlmaWVkTGluZSA9IGxpbmUucmVwbGFjZSgvXihcXHQqLSApLywgYCQxIyR7Y2hvb3Nlbk5vdGVUeXBlLnR5cGV9JHt0aGlzLnRhc2tUeXBlfSBgKTtcbiAgICAgIH0gZWxzZSBpZiAoL15cXHQqXFxkK1xcLiAvLnRlc3QobGluZSkpIHtcbiAgICAgICAgbW9kaWZpZWRMaW5lID0gbGluZS5yZXBsYWNlKC9eKFxcdCpcXGQrXFwuICkvLCBgJDEke2Nob29zZW5Ob3RlVHlwZS50eXBlfSR7dGhpcy50YXNrVHlwZX0gYCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtb2RpZmllZExpbmUgPSBsaW5lLnJlcGxhY2UoL14vLCBgIyR7Y2hvb3Nlbk5vdGVUeXBlLnR5cGV9JHt0aGlzLnRhc2tUeXBlfSBgKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZWRpdG9yLnNldExpbmUoY3Vyc29yLmxpbmUsIG1vZGlmaWVkTGluZSk7XG4gICAgICBjdXJzb3IuY2ggPSBjdXJzb3IuY2ggKyA0O1xuXHRcdCAgdGhpcy5lZGl0b3Iuc2V0Q3Vyc29yKGN1cnNvcik7XG4gICAgfSBlbHNlIGlmIChjaG9vc2VuTm90ZVR5cGUuY3Vyc29yID09IFwiZVwiKSB7XG4gICAgICBsZXQgbW9kaWZpZWRMaW5lID0gbGluZS5yZXBsYWNlKC8kLywgYCAjJHtjaG9vc2VuTm90ZVR5cGUudHlwZX0ke3RoaXMudGFza1R5cGV9YCk7XG4gICAgICB0aGlzLmVkaXRvci5zZXRMaW5lKGN1cnNvci5saW5lLCBtb2RpZmllZExpbmUpO1xuICAgICAgY3Vyc29yLmNoID0gY3Vyc29yLmNoO1xuXHRcdCAgdGhpcy5lZGl0b3Iuc2V0Q3Vyc29yKGN1cnNvcik7XG4gICAgfVxuICAgIFxuICB9XG59IiwgImltcG9ydCB7IEFwcCwgRWRpdG9yLCBGdXp6eVN1Z2dlc3RNb2RhbCwgRnV6enlNYXRjaCwgTm90aWNlIH0gZnJvbSBcIm9ic2lkaWFuXCI7XG5cbmludGVyZmFjZSBDb21tZW50VHlwZSB7XG4gIHR5cGU6IHN0cmluZztcbiAgZGVzY3JpcHRpb246IHN0cmluZztcbn1cblxuY29uc3QgQUxMX1RZUEVTID0gW1xuICB7XG4gICAgdHlwZTogXCJmaXJzdC1wYWdlXCIsXG4gICAgZGVzY3JpcHRpb246IFwiZmlyc3QgcGFnZVwiXG4gIH0sXG4gIHtcbiAgICB0eXBlOiBcIndpdGgtaGVhZGVyXCIsXG4gICAgZGVzY3JpcHRpb246IFwid2l0aCBoZWFkZXJcIlxuICB9LFxuICB7XG4gICAgdHlwZTogXCJ3aXRob3V0LWhlYWRlclwiLFxuICAgIGRlc2NyaXB0aW9uOiBcIndpdGhvdXQgaGVhZGVyXCJcbiAgfSxcbiAge1xuICAgIHR5cGU6IFwiY3VzdG9tLWZvbnQtc2l6ZVwiLFxuICAgIGRlc2NyaXB0aW9uOiBcImN1c3RvbSBmb250IHNpemVcIlxuICB9LFxuXTtcblxuZXhwb3J0IGNsYXNzIFRocmVhZHNUb0ltYWdlc01vZGFsIGV4dGVuZHMgRnV6enlTdWdnZXN0TW9kYWw8Q29tbWVudFR5cGU+IHtcblxuICB0aHJlYWRTZWdtZW50OiBTdHJpbmdcblxuICBjb25zdHJ1Y3RvcihhcHA6IEFwcCwgdGhyZWFkU2VnbWVudDogU3RyaW5nKVxuICB7XG4gICAgc3VwZXIoYXBwKVxuICAgIHRoaXMudGhyZWFkU2VnbWVudCA9IHRocmVhZFNlZ21lbnRcbiAgfVxuXG4gIGdldEl0ZW1zKCk6IENvbW1lbnRUeXBlW10ge1xuICAgIHJldHVybiBBTExfVFlQRVM7XG4gIH1cblxuICBnZXRJdGVtVGV4dChub3RlVHlwZTogQ29tbWVudFR5cGUpOiBzdHJpbmcge1xuICAgIHJldHVybiBub3RlVHlwZS50eXBlO1xuICB9XG5cbiAgLy8gUmVuZGVycyBlYWNoIHN1Z2dlc3Rpb24gaXRlbS5cbiAgcmVuZGVyU3VnZ2VzdGlvbihjaG9vc2VuTm90ZVR5cGVNYXRjaDogRnV6enlNYXRjaDxDb21tZW50VHlwZT4sIGVsOiBIVE1MRWxlbWVudCkge1xuICAgIGNvbnN0IG5vdGVUeXBlID0gY2hvb3Nlbk5vdGVUeXBlTWF0Y2guaXRlbVxuICAgIGVsLmNyZWF0ZUVsKFwiZGl2XCIsIHsgdGV4dDogbm90ZVR5cGUudHlwZSB9KTtcbiAgICBlbC5jcmVhdGVFbChcInNtYWxsXCIsIHsgdGV4dDogbm90ZVR5cGUuZGVzY3JpcHRpb24gfSk7XG4gIH1cblxuICBjb250YWluc1R5cGUobGluZTogU3RyaW5nKSA6IEJvb2xlYW4ge1xuICAgIHJldHVybiBBTExfVFlQRVMuZmlsdGVyKChub3RlVHlwZSkgPT4gbGluZS5jb250YWlucyhub3RlVHlwZS50eXBlKSkubGVuZ3RoID4gMFxuICB9XG5cbiAgLy8gUGVyZm9ybSBhY3Rpb24gb24gdGhlIHNlbGVjdGVkIHN1Z2dlc3Rpb24uXG4gIG9uQ2hvb3NlSXRlbShjaG9vc2VuTm90ZVR5cGU6IENvbW1lbnRUeXBlLCBldnQ6IE1vdXNlRXZlbnQgfCBLZXlib2FyZEV2ZW50KSB7XG4gICAgbGV0IHBhcmFtID0gY2hvb3Nlbk5vdGVUeXBlLnR5cGVcbiAgICBsZXQgcyA9IHRoaXMudGhyZWFkU2VnbWVudC50b1N0cmluZygpXG4gICAgbmF2aWdhdG9yLmNsaXBib2FyZC53cml0ZVRleHQodGhpcy50aHJlYWRTZWdtZW50LnRvU3RyaW5nKCkpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICBuZXcgTm90aWNlKGBDb3BpZWRcXG5cXGBcXGBcXGBcXG4ke3N9XFxgXFxgXFxgXFxudG8gY2xpcGJvYXJkIWApO1xuICAgICAgICB3aW5kb3cub3Blbihgc2hvcnRjdXRzOi8vcnVuLXNob3J0Y3V0P25hbWU9VGhyZWFkcyUyMHRvJTIwaW1hZ2UmaW5wdXQ9dGV4dCZ0ZXh0PSR7cGFyYW19Jngtc3VjY2Vzcz1vYnNpZGlhbjovLyZ4LWNhbmNlbD1vYnNpZGlhbjovLyZ4LWVycm9yPW9ic2lkaWFuOi8vYCk7XG4gICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgIG5ldyBOb3RpY2UoYGVycm9yIHdoZW4gY29weSB0byBjbGlwYm9hcmQhYCk7XG4gICAgfSk7XG4gIH1cbn0iLCAiaW1wb3J0IHsgQXBwLCBFZGl0b3IsIEZ1enp5U3VnZ2VzdE1vZGFsLCBGdXp6eU1hdGNoLCBURmlsZSwgVmF1bHQgfSBmcm9tIFwib2JzaWRpYW5cIjtcblxuaW50ZXJmYWNlIENvcHlPck1vdmUge1xuICB0eXBlOiBzdHJpbmc7XG4gIGRlc2NyaXB0aW9uOiBzdHJpbmc7XG59XG5cbmNvbnN0IEFMTF9UWVBFUyA9IFtcbiAge1xuICAgIHR5cGU6IFwiY29weVwiLFxuICAgIGRlc2NyaXB0aW9uOiBcIkNvcHlcIlxuICB9LFxuICB7XG4gICAgdHlwZTogXCJtb3ZlXCIsXG4gICAgZGVzY3JpcHRpb246IFwiTW92ZVwiXG4gIH0sXG5dO1xuXG5leHBvcnQgY2xhc3MgQ29weU9yTW92ZVRvTmV3Tm90ZU1vZGFsIGV4dGVuZHMgRnV6enlTdWdnZXN0TW9kYWw8Q29weU9yTW92ZT4ge1xuXG4gIGVkaXRvcjogRWRpdG9yXG4gIHRhc2tUeXBlOiBTdHJpbmdcblxuICBjb25zdHJ1Y3RvcihhcHA6IEFwcCwgZWRpdG9yOiBFZGl0b3IpXG4gIHtcbiAgICBzdXBlcihhcHApXG4gICAgdGhpcy5lZGl0b3IgPSBlZGl0b3JcbiAgICB0aGlzLnNldFBsYWNlaG9sZGVyKGBDb3B5IG9yIG1vdmUgc2VsZWN0aW9uIHRvIG5ldyBub3RlP2ApXG4gIH1cblxuICBnZXRJdGVtcygpOiBDb3B5T3JNb3ZlW10ge1xuICAgIHJldHVybiBBTExfVFlQRVM7XG4gIH1cblxuICBnZXRJdGVtVGV4dChub3RlVHlwZTogQ29weU9yTW92ZSk6IHN0cmluZyB7XG4gICAgcmV0dXJuIG5vdGVUeXBlLnR5cGU7XG4gIH1cblxuICAvLyBSZW5kZXJzIGVhY2ggc3VnZ2VzdGlvbiBpdGVtLlxuICByZW5kZXJTdWdnZXN0aW9uKGNob29zZW5Ob3RlVHlwZU1hdGNoOiBGdXp6eU1hdGNoPENvcHlPck1vdmU+LCBlbDogSFRNTEVsZW1lbnQpIHtcbiAgICBjb25zdCBub3RlVHlwZSA9IGNob29zZW5Ob3RlVHlwZU1hdGNoLml0ZW1cbiAgICBlbC5jcmVhdGVFbChcImRpdlwiLCB7IHRleHQ6IG5vdGVUeXBlLnR5cGUgfSk7XG4gICAgZWwuY3JlYXRlRWwoXCJzbWFsbFwiLCB7IHRleHQ6IG5vdGVUeXBlLmRlc2NyaXB0aW9uIH0pO1xuICB9XG5cbiAgY29udGFpbnNUeXBlKGxpbmU6IFN0cmluZykgOiBCb29sZWFuIHtcbiAgICByZXR1cm4gQUxMX1RZUEVTLmZpbHRlcigobm90ZVR5cGUpID0+IGxpbmUuY29udGFpbnMobm90ZVR5cGUudHlwZSkpLmxlbmd0aCA+IDBcbiAgfVxuXG4gIC8vIFBlcmZvcm0gYWN0aW9uIG9uIHRoZSBzZWxlY3RlZCBzdWdnZXN0aW9uLlxuICBhc3luYyBvbkNob29zZUl0ZW0oY2hvb3Nlbk9wZXJhdGlvbjogQ29weU9yTW92ZSwgZXZ0OiBNb3VzZUV2ZW50IHwgS2V5Ym9hcmRFdmVudCkge1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9IHRoaXMuZWRpdG9yLmdldFNlbGVjdGlvbigpXG4gICAgY29uc3QgbGluZSA9IHRoaXMuZWRpdG9yLmdldEN1cnNvcigpLmxpbmVcbiAgICBjb25zdCB0ZXh0VG9Db3B5T3JNb3ZlID0gKHNlbGVjdGlvbi5sZW5ndGggPT0gMClcbiAgICAgICAgICAgICAgICA/IHRoaXMuZWRpdG9yLmdldExpbmUobGluZSlcbiAgICAgICAgICAgICAgICA6IHNlbGVjdGlvblxuICAgIFxuICAgIGNvbnN0IG5ld0ZpbGVOYW1lID0gXCJJL1VuaXRlZCBQdXNoLm1kXCJcbiAgICBhd2FpdCB0aGlzLmNyZWF0ZU9yQXBwZW5kRmlsZShuZXdGaWxlTmFtZSwgdGV4dFRvQ29weU9yTW92ZSlcblxuICAgIGlmIChjaG9vc2VuT3BlcmF0aW9uLnR5cGUgPT0gXCJtb3ZlXCIpIHtcbiAgICAgIGlmIChzZWxlY3Rpb24ubGVuZ3RoICE9IDApIHtcbiAgICAgICAgdGhpcy5lZGl0b3IucmVwbGFjZVNlbGVjdGlvbihcIlwiKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IGNvbnRlbnQgPSBcIlwiXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5lZGl0b3IubGluZUNvdW50KCk7IGkrKykge1xuICAgICAgICAgIGlmIChpICE9IGxpbmUpIHtcbiAgICAgICAgICAgIGNvbnRlbnQgKz0gdGhpcy5lZGl0b3IuZ2V0TGluZShpKSArIFwiXFxuXCJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lZGl0b3Iuc2V0VmFsdWUoY29udGVudClcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCB7IHZhdWx0IH0gPSB0aGlzLmFwcDtcbiAgICBjb25zdCB7IHdvcmtzcGFjZSB9ID0gdGhpcy5hcHA7XG4gICAgY29uc3QgbW9kZSA9ICh0aGlzLmFwcC52YXVsdCBhcyBhbnkpLmdldENvbmZpZyhcImRlZmF1bHRWaWV3TW9kZVwiKTtcbiAgICBjb25zdCBsZWFmID0gd29ya3NwYWNlLmdldExlYWYoZmFsc2UpO1xuICAgIGF3YWl0IGxlYWYub3BlbkZpbGUodmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKG5ld0ZpbGVOYW1lKSBhcyBURmlsZSwgeyBhY3RpdmUgOiB0cnVlLH0pO1xuICB9XG5cbiAgYXN5bmMgY3JlYXRlT3JBcHBlbmRGaWxlKGZpbGVQYXRoOiBzdHJpbmcsIG5vdGU6IHN0cmluZykge1xuXHRcdC8vSWYgZmlsZXMgZXhpc3RzIHRoZW4gYXBwZW5kIGNvbmVudCB0byBleGlzdGluZyBmaWxlXG5cdFx0Y29uc3QgeyB2YXVsdCB9ID0gdGhpcy5hcHA7XG5cdFx0Y29uc3QgZmlsZUV4aXN0cyA9IGF3YWl0IHZhdWx0LmFkYXB0ZXIuZXhpc3RzKGZpbGVQYXRoKTtcblx0XHRpZihmaWxlRXhpc3RzKXtcblx0XHRcdGF3YWl0IHRoaXMuYXBwZW5kRmlsZSh2YXVsdCwgZmlsZVBhdGgsIG5vdGUpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRhd2FpdCB2YXVsdC5jcmVhdGUoZmlsZVBhdGgsIFwiLS0tXFxudGFnOiBiL24vc1xcbi0tLVxcblxcblwiICsgbm90ZSk7XG5cdFx0fVxuXHRcdHJldHVybiBmaWxlUGF0aDtcblx0fVxuXG4gICAgYXN5bmMgYXBwZW5kRmlsZSh2YXVsdDogVmF1bHQsIGZpbGVQYXRoOiBzdHJpbmcsIG5vdGU6IHN0cmluZykge1xuXHRcdGxldCBleGlzdGluZ0NvbnRlbnQgPSBhd2FpdCB2YXVsdC5hZGFwdGVyLnJlYWQoZmlsZVBhdGgpO1xuXHRcdGlmKGV4aXN0aW5nQ29udGVudC5sZW5ndGggPiAwKSB7XG5cdFx0ICBleGlzdGluZ0NvbnRlbnQgPSBleGlzdGluZ0NvbnRlbnQgKyAnXFxyXFxyJztcblx0XHR9XG5cdFx0YXdhaXQgdmF1bHQuYWRhcHRlci53cml0ZShmaWxlUGF0aCwgZXhpc3RpbmdDb250ZW50ICsgbm90ZSk7XG5cdCAgfVxufSIsICJpbXBvcnQgeyBBcHAsIEVkaXRvciwgRnV6enlTdWdnZXN0TW9kYWwsIEZ1enp5TWF0Y2ggfSBmcm9tIFwib2JzaWRpYW5cIjtcblxuZXhwb3J0IGNsYXNzIENsaXBib2FyZFBhc3RlTW9kYWwgZXh0ZW5kcyBGdXp6eVN1Z2dlc3RNb2RhbDxzdHJpbmc+IHtcblxuICBlZGl0b3I6IEVkaXRvclxuXG4gIGNsaXBib2FyZENvbnRlbnQ6IHN0cmluZ1tdXG5cbiAgY29uc3RydWN0b3IoYXBwOiBBcHAsIGVkaXRvcjogRWRpdG9yLCBjbGlwYm9hcmRDb250ZW50OiBzdHJpbmdbXSlcbiAge1xuICAgIHN1cGVyKGFwcClcbiAgICB0aGlzLmVkaXRvciA9IGVkaXRvclxuICAgIHRoaXMuY2xpcGJvYXJkQ29udGVudCA9IGNsaXBib2FyZENvbnRlbnRcbiAgICB0aGlzLnNldFBsYWNlaG9sZGVyKGBXaGljaCBjbGlwYm9hcmQgY29udGVudCBkbyB5b3Ugd2FudCB0byBwYXN0ZT9gKVxuICB9XG5cbiAgZ2V0SXRlbXMoKTogc3RyaW5nW10ge1xuICAgIHJldHVybiB0aGlzLmNsaXBib2FyZENvbnRlbnQuc2xpY2UoKS5yZXZlcnNlKCk7XG4gIH1cblxuICBnZXRJdGVtVGV4dChpdGVtOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIHJldHVybiBpdGVtO1xuICB9XG5cbiAgLy8gUmVuZGVycyBlYWNoIHN1Z2dlc3Rpb24gaXRlbS5cbiAgcmVuZGVyU3VnZ2VzdGlvbihpOiBGdXp6eU1hdGNoPHN0cmluZz4sIGVsOiBIVE1MRWxlbWVudCkge1xuICAgIGNvbnN0IGl0ZW0gPSBpLml0ZW1cbiAgICAvL2VsLmNyZWF0ZUVsKFwiZGl2XCIsIHsgdGV4dDogaXRlbSB9KTtcbiAgICBlbC5jcmVhdGVFbChcImRpdlwiLCB7IHRleHQ6IFwiXHUyMDIyIFwiICsgaXRlbS5yZXBsYWNlKC9cXG4vZ20sIFwiXCIpLnN1YnN0cmluZygwLCAxMDApIH0pO1xuICB9XG5cbiAgLy8gUGVyZm9ybSBhY3Rpb24gb24gdGhlIHNlbGVjdGVkIHN1Z2dlc3Rpb24uXG4gIG9uQ2hvb3NlSXRlbShzZWxlY3RlZENvbnRlbnQ6IHN0cmluZywgZXZ0OiBNb3VzZUV2ZW50IHwgS2V5Ym9hcmRFdmVudCkge1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5jbGlwYm9hcmRDb250ZW50LmluZGV4T2Yoc2VsZWN0ZWRDb250ZW50LCAwKTtcbiAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgdGhpcy5jbGlwYm9hcmRDb250ZW50LnJlbW92ZShzZWxlY3RlZENvbnRlbnQpO1xuICAgIH1cbiAgICB0aGlzLmNsaXBib2FyZENvbnRlbnQucHVzaChzZWxlY3RlZENvbnRlbnQpO1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9IHRoaXMuZWRpdG9yLmdldFNlbGVjdGlvbigpXG4gICAgY29uc3QgcmVwbGFjZWRTdHIgPSBzZWxlY3RlZENvbnRlbnRcbiAgICBpZiAoc2VsZWN0aW9uLmxlbmd0aCAhPSAwKSB7XG4gICAgICAgIHRoaXMuZWRpdG9yLnJlcGxhY2VTZWxlY3Rpb24ocmVwbGFjZWRTdHIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGN1cnNvciA9IHRoaXMuZWRpdG9yLmdldEN1cnNvcigpO1xuICAgICAgICB0aGlzLmVkaXRvci5yZXBsYWNlUmFuZ2UocmVwbGFjZWRTdHIsIGN1cnNvcik7XG4gICAgICAgIGN1cnNvci5jaCA9IGN1cnNvci5jaCArIHJlcGxhY2VkU3RyLmxlbmd0aDtcbiAgICAgICAgdGhpcy5lZGl0b3Iuc2V0Q3Vyc29yKGN1cnNvcik7XG4gICAgfVxuICB9XG59IiwgImltcG9ydCB7IEFwcCwgRWRpdG9yLCBGdXp6eVN1Z2dlc3RNb2RhbCwgRnV6enlNYXRjaCwgVEZpbGUgfSBmcm9tIFwib2JzaWRpYW5cIjtcblxuZXhwb3J0IGNsYXNzIE9wZW5QbGF5Z3JvdW5kTW9kYWwgZXh0ZW5kcyBGdXp6eVN1Z2dlc3RNb2RhbDxzdHJpbmc+IHtcblxuICByZW1vdmVFeGlzdGluZ0NvbnRlbnQgOiBzdHJpbmcgPSBcIlJlbW92ZSBwbGF5Z3JvdW5kIGNvbnRlbnRcIlxuICBub3RSZW1vdmVFeGlzdGluZ0NvbnRlbnQ6IHN0cmluZyA9IFwiTm90IHJlbW92ZSBleGlzdGluZyBwbGF5Z3JvdW5kIGNvbnRlbnRcIlxuICBwbGF5Z3JvdW5kTWQ6IHN0cmluZyA9IFwiSS9QbGF5Z3JvdW5kLm1kXCJcbiAgb3B0aW9uczogc3RyaW5nW10gPSBbdGhpcy5yZW1vdmVFeGlzdGluZ0NvbnRlbnQsIHRoaXMubm90UmVtb3ZlRXhpc3RpbmdDb250ZW50XVxuXG4gIGNvbnN0cnVjdG9yKGFwcDogQXBwKVxuICB7XG4gICAgc3VwZXIoYXBwKVxuICB9XG5cbiAgZ2V0SXRlbXMoKTogc3RyaW5nW10ge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnMucmV2ZXJzZSgpO1xuICB9XG5cbiAgZ2V0SXRlbVRleHQoaXRlbTogc3RyaW5nKTogc3RyaW5nIHtcbiAgICByZXR1cm4gaXRlbTtcbiAgfVxuXG4gIC8vIFJlbmRlcnMgZWFjaCBzdWdnZXN0aW9uIGl0ZW0uXG4gIHJlbmRlclN1Z2dlc3Rpb24oaTogRnV6enlNYXRjaDxzdHJpbmc+LCBlbDogSFRNTEVsZW1lbnQpIHtcbiAgICBjb25zdCBpdGVtID0gaS5pdGVtXG4gICAgZWwuY3JlYXRlRWwoXCJkaXZcIiwgeyB0ZXh0OiBpdGVtIH0pO1xuICB9XG5cbiAgLy8gUGVyZm9ybSBhY3Rpb24gb24gdGhlIHNlbGVjdGVkIHN1Z2dlc3Rpb24uXG4gIGFzeW5jIG9uQ2hvb3NlSXRlbShzZWxlY3RlZENvbnRlbnQ6IHN0cmluZywgZXZ0OiBNb3VzZUV2ZW50IHwgS2V5Ym9hcmRFdmVudCkge1xuICAgIGNvbnN0IGNob29zZW5PcHRpb24gPSBzZWxlY3RlZENvbnRlbnRcblxuICAgIGNvbnN0IHsgdmF1bHQgfSA9IHRoaXMuYXBwO1xuICAgIGNvbnN0IHsgd29ya3NwYWNlIH0gPSB0aGlzLmFwcDtcbiAgICBjb25zdCBsZWFmID0gd29ya3NwYWNlLmdldExlYWYoZmFsc2UpO1xuXG4gICAgUHJvbWlzZS5yZXNvbHZlKClcbiAgICAudGhlbigoKSA9PiB7XG4gICAgICBpZiAodmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKHRoaXMucGxheWdyb3VuZE1kKSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB2YXVsdC5jcmVhdGUodGhpcy5wbGF5Z3JvdW5kTWQsIFwiXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aCh0aGlzLnBsYXlncm91bmRNZClcbiAgICB9KVxuICAgIC50aGVuKCh0RmlsZSkgPT4ge1xuICAgICAgaWYgKHRoaXMucmVtb3ZlRXhpc3RpbmdDb250ZW50ID09PSBjaG9vc2VuT3B0aW9uKSB7XG4gICAgICAgIHJldHVybiB2YXVsdC5tb2RpZnkodEZpbGUgYXMgVEZpbGUsIFwiXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG4gICAgfSlcbiAgICAudGhlbigoKSA9PiB7XG4gICAgICByZXR1cm4gbGVhZi5vcGVuRmlsZSh2YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgodGhpcy5wbGF5Z3JvdW5kTWQpIGFzIFRGaWxlLCB7IGFjdGl2ZSA6IHRydWV9KTtcbiAgICB9KVxuICB9XG59IiwgImltcG9ydCB7IEFwcCwgRWRpdG9yLCBGdXp6eVN1Z2dlc3RNb2RhbCwgRnV6enlNYXRjaCwgVEZpbGUsIE5vdGljZSwgTWFya2Rvd25WaWV3IH0gZnJvbSBcIm9ic2lkaWFuXCI7XG5cbmV4cG9ydCBjbGFzcyBUaHJlYWRzVG9CbG9nTW9kYWwgZXh0ZW5kcyBGdXp6eVN1Z2dlc3RNb2RhbDxzdHJpbmc+IHtcblxuICB0b05ld05vdGUgOiBzdHJpbmcgPSBcIlRvIE5ldyBOb3RlXCJcbiAgdG9DbGlwYm9hcmQ6IHN0cmluZyA9IFwiVG8gQ2xpcGJvYXJkXCJcbiAgb3B0aW9uczogc3RyaW5nW10gPSBbdGhpcy50b05ld05vdGUsIHRoaXMudG9DbGlwYm9hcmRdXG4gIGVkaXRvcjogRWRpdG9yXG4gIHZpZXc6IE1hcmtkb3duVmlld1xuXG4gIGNvbnN0cnVjdG9yKGFwcDogQXBwLCBlZGl0b3I6IEVkaXRvciwgdmlldzogTWFya2Rvd25WaWV3KVxuICB7XG4gICAgc3VwZXIoYXBwKVxuICAgIHRoaXMuZWRpdG9yID0gZWRpdG9yXG4gICAgdGhpcy52aWV3ID0gdmlld1xuICAgIHRoaXMuc2V0UGxhY2Vob2xkZXIoYFB1dHRpbmcgVGhyZWFkcyBjb250ZW50IHRvIEJsb2cgbm90ZXMuIFdoaWNoIG9wdGlvbiBkbyB5b3Ugd2FudCB0byBwcm9jZWVkP2ApXG4gIH1cblxuICBnZXRJdGVtcygpOiBzdHJpbmdbXSB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucztcbiAgfVxuXG4gIGdldEl0ZW1UZXh0KGl0ZW06IHN0cmluZyk6IHN0cmluZyB7XG4gICAgcmV0dXJuIGl0ZW07XG4gIH1cblxuICAvLyBSZW5kZXJzIGVhY2ggc3VnZ2VzdGlvbiBpdGVtLlxuICByZW5kZXJTdWdnZXN0aW9uKGk6IEZ1enp5TWF0Y2g8c3RyaW5nPiwgZWw6IEhUTUxFbGVtZW50KSB7XG4gICAgY29uc3QgaXRlbSA9IGkuaXRlbVxuICAgIGVsLmNyZWF0ZUVsKFwiZGl2XCIsIHsgdGV4dDogaXRlbSB9KTtcbiAgfVxuXG4gIC8vIFBlcmZvcm0gYWN0aW9uIG9uIHRoZSBzZWxlY3RlZCBzdWdnZXN0aW9uLlxuICBvbkNob29zZUl0ZW0oc2VsZWN0ZWRDb250ZW50OiBzdHJpbmcsIGV2dDogTW91c2VFdmVudCB8IEtleWJvYXJkRXZlbnQpIHtcbiAgICBjb25zdCBjaG9vc2VuT3B0aW9uID0gc2VsZWN0ZWRDb250ZW50XG5cbiAgICBjb25zdCBsaW5lQ291bnQgPSB0aGlzLmVkaXRvci5saW5lQ291bnQoKTtcbiAgICBsZXQgdGFnTGluZU51bWJlciA9IG51bGw7XG4gICAgbGV0IG1ldGFkYXRhTGluZUNvdW50ID0gMDtcbiAgICBsZXQgdGV4dCA9IFwiXCJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmVDb3VudDsgaSsrKSB7XG4gICAgICBsZXQgbGluZSA9IHRoaXMuZWRpdG9yLmdldExpbmUoaSk7XG4gICAgICBpZiAoIWxpbmUudHJpbSgpLnN0YXJ0c1dpdGgoXCIlJVwiKSB8fCAhbGluZS50cmltKCkuZW5kc1dpdGgoXCIlJVwiKSkge1xuICAgICAgICBsZXQgbW9kaWZpZWRMaW5lID0gbGluZS5yZXBsYWNlKCdcdUQ4M0VcdURERjUgJywgJyMgJykucmVwbGFjZSgnXHUzMDEwJywgJycpLnJlcGxhY2UoJ1x1MzAxMScsICcnKS5yZXBsYWNlKCdcdUQ4M0RcdURDNDcnLCAnJylcbiAgICAgICAgaWYgKG1vZGlmaWVkTGluZSA9PSAnLS0tJykge1xuICAgICAgICAgIG1ldGFkYXRhTGluZUNvdW50KytcbiAgICAgICAgICBpZiAobWV0YWRhdGFMaW5lQ291bnQgPiAyKSB7XG4gICAgICAgICAgICBpZiAobWV0YWRhdGFMaW5lQ291bnQgPT0gMykge1xuICAgICAgICAgICAgICBtb2RpZmllZExpbmUgPSBtb2RpZmllZExpbmUucmVwbGFjZSgnLS0tJywgJycpXG4gICAgICAgICAgICB9IGVsc2UgaWYgKG1ldGFkYXRhTGluZUNvdW50ID09IDQpIHtcbiAgICAgICAgICAgICAgbW9kaWZpZWRMaW5lID0gbW9kaWZpZWRMaW5lLnJlcGxhY2UoJy0tLScsICc8IS0tbW9yZS0tPlxcblxcbioqXHU3NkVFXHU5MzA0XHVGRjFBKipcXG5cXG4qIFRhYmxlIG9mIENvbnRlbnRcXG57OnRvY31cXG5cXG4jIyAuJylcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG1vZGlmaWVkTGluZSA9IG1vZGlmaWVkTGluZS5yZXBsYWNlKCctLS0nLCAnIyMgLicpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1ldGFkYXRhTGluZUNvdW50ID09IDEgfHwgbWV0YWRhdGFMaW5lQ291bnQgPT0gMikge1xuICAgICAgICAgIG1vZGlmaWVkTGluZSA9IG1vZGlmaWVkTGluZS5yZXBsYWNlKFwiYy90L3BcIiwgXCJjL2IvZFwiKVxuICAgICAgICAgIG1vZGlmaWVkTGluZSA9IG1vZGlmaWVkTGluZS5yZXBsYWNlKFwiYy90L3RcIiwgXCJjL2IvZFwiKVxuICAgICAgICAgIG1vZGlmaWVkTGluZSA9IG1vZGlmaWVkTGluZS5yZXBsYWNlKFwiYy90L3JcIiwgXCJjL2IvZFwiKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKC9eIVxcWy4qXFxdXFwoLipcXCkvLnRlc3QobW9kaWZpZWRMaW5lLnRyaW0oKSkpIHtcbiAgICAgICAgICBpZiAoIW1vZGlmaWVkTGluZS5jb250YWlucyhcImh0dHBzOi8vcm91bGVzb3BoeS5naXRodWIuaW9cIikpIHtcbiAgICAgICAgICAgIG1vZGlmaWVkTGluZSA9IG1vZGlmaWVkTGluZS5yZXBsYWNlKC8hXFxbKFteXFxbXFxdXFwoXFwpXSspXFxdXFwoKFteXFxbXFxdXFwoXFwpXSspXFwpL2csIFwiJDJcIilcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGV4dCA9IHRleHQgKyBtb2RpZmllZExpbmUgKyBcIlxcblwiO1xuICAgICAgfVxuICAgIH1cbiAgICB0ZXh0ICs9IGBcXG5cXG4tLS1cXG5cXG4jbmwgZ2VuZXJhdGUgc3VtbWFyeSBmb3IgbWV0YSBkZXNjcmlwdGlvbiBiZWxvdzpcXG5cXG5cXG5cXG5gXG4gICAgdGV4dCArPSBgLS0tXFxuXFxuIyMgUmVmZXJlbmNlczpcXG5cXG4tIFRocmVhZCBwb3N0IDE6IFtbJHt0aGlzLnZpZXcuZmlsZS5iYXNlbmFtZX1dXVxcbi0gQmxvZyBsaW5rOiBcXG5gXG5cbiAgICBjb25zdCB7IHZhdWx0IH0gPSB0aGlzLmFwcDtcblxuICAgIGlmICh0aGlzLnRvTmV3Tm90ZSA9PT0gY2hvb3Nlbk9wdGlvbikge1xuICAgICAgY29uc3QgeyB2YXVsdCB9ID0gdGhpcy5hcHA7XG4gICAgICBjb25zdCBwYXRoID0gdGhpcy52aWV3LmZpbGUucGF0aFxuICAgICAgY29uc3QgbmV3UGF0aCA9IHBhdGgubWF0Y2goLy5cXC9UaHJlYWRzIFxcZFxcZFxcZFxcZFxcZFxcZFxcZFxcZC8pXG4gICAgICAgICAgICAgICAgICAgICAgPyBwYXRoLnJlcGxhY2UoLyguXFwvKVRocmVhZHMgXFxkXFxkXFxkXFxkXFxkXFxkXFxkXFxkLywgXCIkMUJsb2cgXCIpXG4gICAgICAgICAgICAgICAgICAgICAgOiBwYXRoLnJlcGxhY2UoLyguXFwvKS8sIFwiJDFCbG9nIFwiKVxuXG4gICAgICBjb25zdCB7IHdvcmtzcGFjZSB9ID0gdGhpcy5hcHA7XG4gICAgICBjb25zdCBsZWFmID0gd29ya3NwYWNlLmdldExlYWYoZmFsc2UpO1xuICAgICAgUHJvbWlzZS5yZXNvbHZlKClcbiAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgcmV0dXJuIHZhdWx0LmFkYXB0ZXIuZXhpc3RzKG5ld1BhdGgpO1xuICAgICAgfSlcbiAgICAgIC50aGVuKChmaWxlRXhpc3RzKSA9PiB7XG4gICAgICAgIGlmIChmaWxlRXhpc3RzKSB7XG4gICAgICAgICAgbmV3IE5vdGljZShgV2lsbCBub3QgcHJvY2VlZC4gQmxvZyBwb3N0IFwiJHtuZXdQYXRofVwiIGFscmVhZHkgZXhpc3QuYCk7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KFwiQmxvZyBwb3N0IGV4aXN0XCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YXVsdC5jcmVhdGUobmV3UGF0aCwgdGV4dCk7XG4gICAgICB9KVxuICAgICAgLnRoZW4oKHRGaWxlKSA9PiB7XG4gICAgICAgIHJldHVybiBsZWFmLm9wZW5GaWxlKHRGaWxlLCB7IGFjdGl2ZSA6IHRydWV9KTtcbiAgICAgIH0sXG4gICAgICAocmVqZWN0UmVhc29uKSA9PiB7fSlcbiAgICB9XG4gICAgaWYgKHRoaXMudG9DbGlwYm9hcmQgPT09IGNob29zZW5PcHRpb24pIHtcbiAgICAgIG5hdmlnYXRvci5jbGlwYm9hcmQud3JpdGVUZXh0KHRleHQpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICBuZXcgTm90aWNlKGBDb3BpZWQgYmxvZyBjb250ZW50IHRvIGNsaXBib2FyZCFgKTtcbiAgICAgIH0sIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICBuZXcgTm90aWNlKGBlcnJvciB3aGVuIGNvcHkgdG8gY2xpcGJvYXJkIWApO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG59IiwgImltcG9ydCB7IEFwcCwgRWRpdG9yLCBGdXp6eVN1Z2dlc3RNb2RhbCwgRnV6enlNYXRjaCwgTm90aWNlIH0gZnJvbSBcIm9ic2lkaWFuXCI7XG5cbmV4cG9ydCBjbGFzcyBDbGlwYm9hcmRSZW1vdmFsTW9kYWwgZXh0ZW5kcyBGdXp6eVN1Z2dlc3RNb2RhbDxzdHJpbmc+IHtcblxuICBlZGl0b3I6IEVkaXRvclxuXG4gIGNsaXBib2FyZENvbnRlbnQ6IHN0cmluZ1tdXG5cbiAgUkVNT1ZFX0FMTCA6IHN0cmluZyA9IFwiUkVNT1ZFIEFMTFwiXG5cbiAgY29uc3RydWN0b3IoYXBwOiBBcHAsIGVkaXRvcjogRWRpdG9yLCBjbGlwYm9hcmRDb250ZW50OiBzdHJpbmdbXSlcbiAge1xuICAgIHN1cGVyKGFwcClcbiAgICB0aGlzLmVkaXRvciA9IGVkaXRvclxuICAgIHRoaXMuY2xpcGJvYXJkQ29udGVudCA9IGNsaXBib2FyZENvbnRlbnRcbiAgICB0aGlzLnNldFBsYWNlaG9sZGVyKGBXaGljaCBjbGlwYm9hcmQgY29udGVudCBkbyB5b3Ugd2FudCB0byByZW1vdmU/YClcbiAgfVxuXG4gIGdldEl0ZW1zKCk6IHN0cmluZ1tdIHtcbiAgICByZXR1cm4gWy4uLlt0aGlzLlJFTU9WRV9BTExdLCAuLi50aGlzLmNsaXBib2FyZENvbnRlbnQuc2xpY2UoKS5yZXZlcnNlKCldO1xuICB9XG5cbiAgZ2V0SXRlbVRleHQoaXRlbTogc3RyaW5nKTogc3RyaW5nIHtcbiAgICByZXR1cm4gaXRlbTtcbiAgfVxuXG4gIC8vIFJlbmRlcnMgZWFjaCBzdWdnZXN0aW9uIGl0ZW0uXG4gIHJlbmRlclN1Z2dlc3Rpb24oaTogRnV6enlNYXRjaDxzdHJpbmc+LCBlbDogSFRNTEVsZW1lbnQpIHtcbiAgICBjb25zdCBpdGVtID0gaS5pdGVtXG4gICAgLy9lbC5jcmVhdGVFbChcImRpdlwiLCB7IHRleHQ6IGl0ZW0gfSk7XG4gICAgZWwuY3JlYXRlRWwoXCJkaXZcIiwgeyB0ZXh0OiBcIlx1MjAyMiBcIiArIGl0ZW0ucmVwbGFjZSgvXFxuL2dtLCBcIlwiKS5zdWJzdHJpbmcoMCwgMTAwKSB9KTtcbiAgfVxuXG4gIC8vIFBlcmZvcm0gYWN0aW9uIG9uIHRoZSBzZWxlY3RlZCBzdWdnZXN0aW9uLlxuICBvbkNob29zZUl0ZW0oc2VsZWN0ZWRDb250ZW50OiBzdHJpbmcsIGV2dDogTW91c2VFdmVudCB8IEtleWJvYXJkRXZlbnQpIHtcbiAgICBpZiAoc2VsZWN0ZWRDb250ZW50ID09PSB0aGlzLlJFTU9WRV9BTEwpIHtcbiAgICAgIG5ldyBOb3RpY2UoXCJoYWhhXCIpXG4gICAgICB3aGlsZSh0aGlzLmNsaXBib2FyZENvbnRlbnQubGVuZ3RoID4gMCkge1xuICAgICAgICB0aGlzLmNsaXBib2FyZENvbnRlbnQucG9wKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5jbGlwYm9hcmRDb250ZW50LmluZGV4T2Yoc2VsZWN0ZWRDb250ZW50LCAwKTtcbiAgICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICAgIHRoaXMuY2xpcGJvYXJkQ29udGVudC5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgfSAgXG4gICAgfVxuICB9XG59IiwgImltcG9ydCB7IEFwcCwgRnV6enlTdWdnZXN0TW9kYWwgfSBmcm9tIFwib2JzaWRpYW5cIjtcbmltcG9ydCB7IGdldEFsbFRhZ3NXaXRoRmlsdGVyIH0gZnJvbSBcInNlbGZ1dGlsL2dldEFsbE5vdGVUYWdzXCI7XG5cbmludGVyZmFjZSBTZWFyY2gge1xuXHRvcGVuR2xvYmFsU2VhcmNoKF86IHN0cmluZyk6IHZvaWQ7XG5cdGdldEdsb2JhbFNlYXJjaFF1ZXJ5KCk6IHN0cmluZztcbn1cblxuZXhwb3J0IGNsYXNzIFRhZ1NlYXJjaE1vZGFsIGV4dGVuZHMgRnV6enlTdWdnZXN0TW9kYWw8c3RyaW5nPiB7XG5cdGNvbnN0cnVjdG9yKHB1YmxpYyBhcHA6IEFwcCwgcHJpdmF0ZSBzZWFyY2g6IFNlYXJjaCkge1xuXHRcdHN1cGVyKGFwcCk7XG5cdFx0dGhpcy5zZWFyY2ggPSBzZWFyY2g7XG5cdH1cblxuXHRnZXRJdGVtcygpOiBzdHJpbmdbXSB7XG5cdFx0cmV0dXJuIGdldEFsbFRhZ3NXaXRoRmlsdGVyKHRoaXMuYXBwKTtcblx0fVxuXG5cdGdldEl0ZW1UZXh0KGl0ZW06IHN0cmluZyk6IHN0cmluZyB7XG5cdFx0cmV0dXJuIGl0ZW07XG5cdH1cblxuXHRvbkNob29zZUl0ZW0oaXRlbTogc3RyaW5nLCBldnQ6IE1vdXNlRXZlbnQgfCBLZXlib2FyZEV2ZW50KTogdm9pZCB7XG5cdFx0Y29uc3QgZGVmYXVsdFRhZ1NlYXJjaFN0cmluZyA9IGB0YWc6JHtpdGVtfWA7XG4gICAgICAgIHRoaXMuc2VhcmNoLm9wZW5HbG9iYWxTZWFyY2goZGVmYXVsdFRhZ1NlYXJjaFN0cmluZyk7XG5cdH1cblxufSIsICJpbXBvcnQgeyBBcHAsIGdldEFsbFRhZ3MgfSBmcm9tIFwib2JzaWRpYW5cIjtcblxuZXhwb3J0IGZ1bmN0aW9uIGdldEFsbE5vdGVUYWdzKGFwcDogQXBwKSB7XG4gICAgcmV0dXJuIGdldEFsbFRhZ3NXaXRoRmlsdGVyKGFwcCwgKHRhZykgPT4gL14jW2Etel1cXC9bYS16XVxcL1thLXpdJC8udGVzdCh0YWcpKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0QWxsVGFnc1dpdGhGaWx0ZXIoYXBwOiBBcHAsIGZpbHRlcj86ICh0YWc6IHN0cmluZykgPT4gYm9vbGVhbiB8IG51bGwpIHtcbiAgICBjb25zdCBmaWxlcyA9IGFwcC52YXVsdC5nZXRNYXJrZG93bkZpbGVzKCk7XG4gICAgY29uc3QgaXRlbXM6IHN0cmluZ1tdID0gW107XG4gICAgZm9yIChjb25zdCBmaWxlIG9mIGZpbGVzKSB7XG4gICAgICAgIGNvbnN0IGNhY2hlID0gYXBwLm1ldGFkYXRhQ2FjaGUuZ2V0Q2FjaGUoZmlsZS5wYXRoKTtcbiAgICAgICAgaWYgKGNhY2hlID09PSBudWxsKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBnZXRBbGxUYWdzKGNhY2hlKT8uZm9yRWFjaCgodGFnKSA9PiB7XG4gICAgICAgICAgICBpZiAoZmlsdGVyID09IG51bGwgfHwgZmlsdGVyKHRhZykpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsYXllck9mVGFnOiBzdHJpbmdbXSA9IGdldExheWVyc09mVGFnKHRhZylcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGxheWVyIG9mIGxheWVyT2ZUYWcpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpdGVtcy5pbmNsdWRlcyhsYXllcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1zLnB1c2gobGF5ZXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGl0ZW1zLnNvcnQoKGE6IHN0cmluZywgYjogc3RyaW5nKSA9PiBhLmxvY2FsZUNvbXBhcmUoYikpO1xufVxuXG5mdW5jdGlvbiBnZXRMYXllcnNPZlRhZyh0YWc6IHN0cmluZyk6IHN0cmluZ1tdIHtcbiAgICAvLyBwcm92aWRlIGEgdGFnIHdpdGggI3p6ei9iYmIvY2NjLCByZXR1cm4gWyN6enosICN6enovYmJiLCAjenp6L2JiYi9jY2NdXG4gICAgLy8gaWYgdGFnIHdpdGhvdXQgLyAoZS5nLiAjenp6KSwgcmV0dXJuIFsjenp6XVxuICAgIGNvbnN0IGxheWVyczogc3RyaW5nW10gPSBbXVxuICAgIGNvbnN0IHRhZ1NwbGl0ID0gdGFnLnNwbGl0KFwiL1wiKVxuICAgIGxldCB0YWdMYXllciA9IHRhZ1NwbGl0WzBdXG4gICAgbGF5ZXJzLnB1c2godGFnTGF5ZXIpXG4gICAgZm9yIChjb25zdCB0YWdQYXJ0IG9mIHRhZ1NwbGl0LnNsaWNlKDEsIHRhZ1NwbGl0Lmxlbmd0aCkpIHtcbiAgICAgICAgdGFnTGF5ZXIgKz0gXCIvXCIgKyB0YWdQYXJ0XG4gICAgICAgIGxheWVycy5wdXNoKHRhZ0xheWVyKVxuICAgIH1cbiAgICByZXR1cm4gbGF5ZXJzXG59IiwgImltcG9ydCB7IEFkZFRleHRUb05vdGVzTW9kYWwgfSBmcm9tIFwiYWRkVGV4dFRvTm90ZXNNb2RhbFwiXG5pbXBvcnQgeyBBcHAsIEZ1enp5U3VnZ2VzdE1vZGFsLCBGdXp6eU1hdGNoIH0gZnJvbSBcIm9ic2lkaWFuXCJcbmltcG9ydCB7IGFkZFRleHRUb05vdGVzIH0gZnJvbSBcInNlbGZ1dGlsL2FkZGxpbmt0b25vdGVzXCJcbmltcG9ydCB7IGZpbGVzV2hlcmVUYWdJc1VzZWQgfSBmcm9tIFwic2VsZnV0aWwvZmluZE5vdGVzRnJvbVRhZ1wiXG5cbmNvbnN0IEJBQ0tfVE9fU0VMRUNUX1RBRyA9IFwiQmFjayB0byBzZWxlY3QgdGFnXCJcblxuZXhwb3J0IGNsYXNzIEFkZFRleHRUb05vdGVzRnJvbVNwZWNpZmljVGFnTW9kYWwgZXh0ZW5kcyBGdXp6eVN1Z2dlc3RNb2RhbDxzdHJpbmc+IHtcblxuICBsaW5rVG9BZGQ6IHN0cmluZ1xuXG4gIHRhZ1RvRmluZDogc3RyaW5nXG5cbiAgZGVzY3JpcHRpb246IHN0cmluZ1xuXG4gIGluc2VydEZyb21CZWdpbm5pbmc6IGJvb2xlYW5cblxuICBwb3N0QWN0aW9uOiAoKSA9PiB2b2lkXG5cbiAgY29uc3RydWN0b3IoYXBwOiBBcHAsIGxpbmtUb0FkZDogc3RyaW5nLCB0YWdUb0ZpbmQ6IHN0cmluZywgZGVzY3JpcHRpb246IHN0cmluZywgaW5zZXJ0RnJvbUJlZ2lubmluZzogYm9vbGVhbiwgcG9zdEFjdGlvbjogKCkgPT4gdm9pZClcbiAge1xuICAgIHN1cGVyKGFwcClcbiAgICB0aGlzLmxpbmtUb0FkZCA9IGxpbmtUb0FkZFxuICAgIHRoaXMudGFnVG9GaW5kID0gdGFnVG9GaW5kXG4gICAgdGhpcy5pbnNlcnRGcm9tQmVnaW5uaW5nID0gaW5zZXJ0RnJvbUJlZ2lubmluZ1xuICAgIHRoaXMuZGVzY3JpcHRpb24gPSBkZXNjcmlwdGlvblxuICAgIHRoaXMucG9zdEFjdGlvbiA9IHBvc3RBY3Rpb25cbiAgICB0aGlzLnNldFBsYWNlaG9sZGVyKGBXaGljaCBub3RlcyB3aXRoIHRhZyAke3RhZ1RvRmluZH0gZG8geW91IHdhbnQgdG8gJHtkZXNjcmlwdGlvbn0gdG8/YClcbiAgICB0aGlzLnNldEluc3RydWN0aW9ucyhbXG4gICAgICB7XG4gICAgICAgIGNvbW1hbmQ6IFwiXCIsXG4gICAgICAgIHB1cnBvc2U6IGBXaGljaCBub3RlcyB3aXRoIHRhZyAke3RhZ1RvRmluZH0gZG8geW91IHdhbnQgdG8gJHtkZXNjcmlwdGlvbn0gdG8/YFxuICAgICAgfVxuICAgIF0pO1xuICB9XG5cbiAgZ2V0SXRlbXMoKTogc3RyaW5nW10ge1xuICAgIHJldHVybiBbLi4uW0JBQ0tfVE9fU0VMRUNUX1RBR10sIC4uLmZpbGVzV2hlcmVUYWdJc1VzZWQodGhpcy50YWdUb0ZpbmQpXTtcbiAgfVxuXG4gIGdldEl0ZW1UZXh0KHBhdGg6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHBhdGg7XG4gIH1cblxuICAvLyBSZW5kZXJzIGVhY2ggc3VnZ2VzdGlvbiBpdGVtLlxuICByZW5kZXJTdWdnZXN0aW9uKHBhdGg6IEZ1enp5TWF0Y2g8c3RyaW5nPiwgZWw6IEhUTUxFbGVtZW50KSB7XG4gICAgY29uc3QgcGF0aEl0ZW06IHN0cmluZyA9IHBhdGguaXRlbVxuICAgIGVsLmNyZWF0ZUVsKFwiZGl2XCIsIHsgdGV4dDogcGF0aEl0ZW0gfSk7XG4gIH1cblxuICAvLyBQZXJmb3JtIGFjdGlvbiBvbiB0aGUgc2VsZWN0ZWQgc3VnZ2VzdGlvbi5cbiAgb25DaG9vc2VJdGVtKHBhdGg6IHN0cmluZywgZXZ0OiBNb3VzZUV2ZW50IHwgS2V5Ym9hcmRFdmVudCkge1xuICAgIGlmIChCQUNLX1RPX1NFTEVDVF9UQUcgPT0gcGF0aCkge1xuICAgICAgbmV3IEFkZFRleHRUb05vdGVzTW9kYWwodGhpcy5hcHAsIHRoaXMubGlua1RvQWRkLCB0aGlzLmRlc2NyaXB0aW9uLCB0aGlzLmluc2VydEZyb21CZWdpbm5pbmcsIHRoaXMucG9zdEFjdGlvbikub3BlbigpXG4gICAgfSBlbHNlIHtcbiAgICAgIGFkZFRleHRUb05vdGVzKHRoaXMubGlua1RvQWRkLCBwYXRoLCB0aGlzLmFwcCwgdGhpcy5pbnNlcnRGcm9tQmVnaW5uaW5nKVxuICAgICAgdGhpcy5wb3N0QWN0aW9uKClcbiAgICB9XG4gIH1cbn0iLCAiaW1wb3J0IHsgQXBwLCBFZGl0b3IsIE1hcmtkb3duVmlldywgTm90aWNlLCBURmlsZSwgVGV4dEZpbGVWaWV3LCBWYXVsdCwgV29ya3NwYWNlIH0gZnJvbSBcIm9ic2lkaWFuXCJcblxuZXhwb3J0IGZ1bmN0aW9uIGFkZFRleHRUb05vdGVzKHRleHRUb0FkZDogc3RyaW5nLCB0b1BhdGg6IHN0cmluZywgYXBwOiBBcHAsIGluc2VydEZyb21CZWdpbm5pbmc6IGJvb2xlYW4pIHtcbiAgICBjb25zdCB2YXVsdDogVmF1bHQgPSB0aGlzLmFwcC52YXVsdDtcbiAgICBjb25zdCB3b3Jrc3BhY2U6IFdvcmtzcGFjZSA9IHRoaXMuYXBwLndvcmtzcGFjZVxuICAgIGNvbnN0IGxlYWYgPSB3b3Jrc3BhY2UuZ2V0TGVhZihmYWxzZSk7XG4gICAgY29uc3QgdEZpbGU6IFRGaWxlID0gdmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKHRvUGF0aCkgYXMgVEZpbGVcbiAgICBjb25zdCBsaW5rID0gdGV4dFRvQWRkXG4gICAgUHJvbWlzZS5yZXNvbHZlKClcbiAgICAudGhlbigoKSA9PiB7XG4gICAgICAgIHJldHVybiBsZWFmLm9wZW5GaWxlKHRGaWxlLCB7IGFjdGl2ZTogdHJ1ZSB9KTtcbiAgICB9KVxuICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgLy9jb25zdCBlZGl0b3IgPSBhcHAud29ya3NwYWNlLmdldEFjdGl2ZVZpZXdPZlR5cGUoVGV4dEZpbGVWaWV3KTtcbiAgICAgICAgY29uc3QgbWFya2Rvd25WaWV3ID0gYXBwLndvcmtzcGFjZS5nZXRBY3RpdmVWaWV3T2ZUeXBlKE1hcmtkb3duVmlldyk7XG4gICAgICAgIGNvbnN0IGVkaXRvciA9IG1hcmtkb3duVmlldz8uZWRpdG9yXG4gICAgICAgIGNvbnN0IHZhbHVlID0gbWFya2Rvd25WaWV3Py5nZXRWaWV3RGF0YSgpXG4gICAgICAgIGlmIChtYXJrZG93blZpZXcgPT0gbnVsbCB8fCBlZGl0b3IgPT0gbnVsbCB8fCB2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBlcnJvclJlYXNvbiA9IGBlZGl0b3Igb3IgdmFsdWUgJHt0b1BhdGh9IG5vdCBleGlzdC4gQWJvcnRpbmcuLi5gXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3JSZWFzb24pXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmICh2YWx1ZS5pbmNsdWRlcyhsaW5rKSkge1xuICAgICAgICAgICAgY29uc3QgZXJyb3JSZWFzb24gPSBgTGluayAke2xpbmt9IGFscmVhZHkgZXhpc3RzIGluICR7dG9QYXRofSFgXG4gICAgICAgICAgICBuZXcgTm90aWNlKGVycm9yUmVhc29uKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgbmV3VmFsdWUgPSBpbnNlcnRGcm9tQmVnaW5uaW5nID8gXG4gICAgICAgICAgICBnZXROb3RlVmFsdWVJbnNlcnRpbmdUZXh0RnJvbVN0YXJ0T2ZOb3Rlcyh2YWx1ZSwgbGluaykgOiBcbiAgICAgICAgICAgIGdldE5vdGVWYWx1ZUluc2VydGluZ1RleHRGcm9tRW5kT2ZOb3Rlcyh2YWx1ZSwgbGluaylcbiAgICAgICAgICAgIG1hcmtkb3duVmlldy5zZXRWaWV3RGF0YShuZXdWYWx1ZSwgZmFsc2UpXG4gICAgICAgICAgICBpZiAoaW5zZXJ0RnJvbUJlZ2lubmluZykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZyb250TWF0dGVyUmVnZXggPSAvXigtLS1cXG5bXFxzXFxTXSo/XFxuLS0tXFxuKS9nbVxuICAgICAgICAgICAgICAgIGlmIChmcm9udE1hdHRlclJlZ2V4LnRlc3QodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGVkaXRvci5zZXRDdXJzb3IoeyBsaW5lOiBnZXRMaW5lQWZ0ZXJGcm9udE1hdHRlcih2YWx1ZSksIGNoOiAwIH0pIFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGVkaXRvci5zZXRDdXJzb3IoeyBsaW5lOiAwLCBjaDogMCB9KVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZWRpdG9yLnNldEN1cnNvcih7IGxpbmU6IGVkaXRvci5saW5lQ291bnQoKSAtIDEsIGNoOiAwIH0pXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXcgTm90aWNlKGBBZGRlZCBsaW5rIHRvICR7aW5zZXJ0RnJvbUJlZ2lubmluZyA/IFwiYmVnaW5uaW5nXCIgOiBcImVuZFwifSBvZiAke3RvUGF0aH0hYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG4gICAgfSlcbiAgICAuY2F0Y2goKHJlYXNvbikgPT4geyBcbiAgICAgICAgbmV3IE5vdGljZShyZWFzb24pXG4gICAgfSlcbiAgICAvKiB0aGlzIHZlcnNpb24gY2Fubm90IHJlZG8sIGNhbiByZW1vdmUgaWYgYWJvdmVcbiAgICBQcm9taXNlLnJlc29sdmUoKVxuICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdmF1bHQucmVhZCh0RmlsZSlcbiAgICAgICAgfSwgcmVhc29uID0+IHsgbmV3IE5vdGljZShcIkVycm9yIG9jY3VycmVkIHdoZW4gcmVhZGluZyBcIiArIHRvUGF0aCkgfSlcbiAgICAgICAgLnRoZW4oKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICBpZiAodmFsdWUuaW5jbHVkZXMobGluaykpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlcnJvclJlYXNvbiA9IGBMaW5rICR7bGlua1RvQWRkfSBhbHJlYWR5IGV4aXN0cyBpbiAke3RvUGF0aH0hYFxuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvclJlYXNvbilcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG5ld1ZhbHVlID0gaW5zZXJ0RnJvbUJlZ2lubmluZyA/IFxuICAgICAgICAgICAgICAgIGdldE5vdGVWYWx1ZUluc2VydGluZ05vdGVMaW5rRnJvbVN0YXJ0T2ZOb3Rlcyh2YWx1ZSwgbGluaykgOiBcbiAgICAgICAgICAgICAgICBnZXROb3RlVmFsdWVJbnNlcnRpbmdOb3RlTGlua0Zyb21FbmRPZk5vdGVzKHZhbHVlLCBsaW5rKVxuICAgICAgICAgICAgcmV0dXJuIHZhdWx0Lm1vZGlmeSh0RmlsZSwgbmV3VmFsdWUpXG4gICAgICAgIH0pXG4gICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIG5ldyBOb3RpY2UoYEFkZGVkIGxpbmsgdG8gJHtpbnNlcnRGcm9tQmVnaW5uaW5nID8gXCJiZWdpbm5pbmdcIiA6IFwiZW5kXCJ9IG9mICR7dG9QYXRofSFgKTtcbiAgICAgICAgICAgIGNvbnN0IGxlYWYgPSB3b3Jrc3BhY2UuZ2V0TGVhZihmYWxzZSk7XG4gICAgICAgICAgICByZXR1cm4gbGVhZi5vcGVuRmlsZSh0RmlsZSwgeyBhY3RpdmU6IHRydWUgfSk7XG4gICAgICAgIH0sIChyZWFzb24pID0+IHsgXG4gICAgICAgICAgICBuZXcgTm90aWNlKHJlYXNvbikgXG4gICAgICAgICAgICBjb25zdCBsZWFmID0gd29ya3NwYWNlLmdldExlYWYoZmFsc2UpO1xuICAgICAgICAgICAgcmV0dXJuIGxlYWYub3BlbkZpbGUodEZpbGUsIHsgYWN0aXZlOiB0cnVlIH0pO1xuICAgICAgICB9KVxuICAgICAgICAqL1xufVxuXG5mdW5jdGlvbiBnZXRMaW5lQWZ0ZXJGcm9udE1hdHRlcih2YWx1ZTogc3RyaW5nKSB7XG4gICAgY29uc3QgdmFsdWVzID0gdmFsdWUuc3BsaXQoXCJcXG5cIilcbiAgICBsZXQgZm1Db3VudCA9IDBcbiAgICBjb25zdCBsaW5lTnVtID0gdmFsdWVzLmxlbmd0aFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZU51bTsgaSsrKSB7XG4gICAgICAgIGlmICh2YWx1ZXNbaV0gPT09IFwiLS0tXCIpIHtcbiAgICAgICAgICAgIGZtQ291bnQrK1xuICAgICAgICB9XG4gICAgICAgIGlmIChmbUNvdW50ID09IDIpIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLm1pbihpICsgMSwgbGluZU51bSAtIDEpXG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGxpbmVOdW0gLSAxXG59XG5cbmZ1bmN0aW9uIGdldE5vdGVWYWx1ZUluc2VydGluZ1RleHRGcm9tU3RhcnRPZk5vdGVzKHZhbHVlOiBzdHJpbmcsIHRleHQ6IHN0cmluZykge1xuICAgIGNvbnN0IGZyb250TWF0dGVyUmVnZXggPSAvXigtLS1cXG5bXFxzXFxTXSo/XFxuLS0tXFxuKS9nbVxuICAgIC8vIC9eLS0tXFxuKC4qKSpcXG4tLS1cXG4vXG4gICAgaWYgKGZyb250TWF0dGVyUmVnZXgudGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLnJlcGxhY2UoZnJvbnRNYXR0ZXJSZWdleCwgXCIkMVwiICsgdGV4dCArIFwiXFxuXCIpXG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRleHQgKyBcIlxcblwiICsgdmFsdWVcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGdldE5vdGVWYWx1ZUluc2VydGluZ1RleHRGcm9tRW5kT2ZOb3Rlcyh2YWx1ZTogc3RyaW5nLCB0ZXh0OiBzdHJpbmcpIHtcbiAgICByZXR1cm4gdmFsdWUgKyBcIlxcblwiICsgdGV4dFxufSIsICJpbXBvcnQgeyBBcHAsIENhY2hlZE1ldGFkYXRhLCBwYXJzZUZyb250TWF0dGVyQWxpYXNlcywgcGFyc2VGcm9udE1hdHRlclRhZ3MgfSBmcm9tIFwib2JzaWRpYW5cIjtcblxuZXhwb3J0IGZ1bmN0aW9uIGZpbGVzV2hlcmVUYWdJc1VzZWQoZmluZFRhZzogc3RyaW5nKTogc3RyaW5nW10ge1xuICAgIGNvbnN0IGZpbGVzTGlzdDogc3RyaW5nW10gPSBbXTtcbiAgICBmb3IgKGNvbnN0IGZpbGVQYXRoIG9mIGxvY2F0aW9uc1doZXJlVGFnSXNVc2VkKGZpbmRUYWcpKSB7XG4gICAgICAgIGlmICghZmlsZXNMaXN0LmluY2x1ZGVzKGZpbGVQYXRoKSkge1xuICAgICAgICAgICAgZmlsZXNMaXN0LnB1c2goZmlsZVBhdGgpXG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZpbGVzTGlzdC5zb3J0KChhOiBzdHJpbmcsIGI6IHN0cmluZykgPT4gYS5sb2NhbGVDb21wYXJlKGIpKTtcbn1cblxuLy8gcmV0dXJuIGFycmF5IG9mIGZpbGUgcGF0aFxuZnVuY3Rpb24gbG9jYXRpb25zV2hlcmVUYWdJc1VzZWQoZmluZFRhZzogc3RyaW5nKTogQXJyYXk8c3RyaW5nPiB7XG4gICAgY29uc3Qgb0FwcDogQXBwID0gYXBwO1xuICAgIGNvbnN0IHJlc3VsdHM6IHN0cmluZ1tdID0gW107XG5cbiAgICBmb3IgKGNvbnN0IGZpbGUgb2Ygb0FwcC52YXVsdC5nZXRNYXJrZG93bkZpbGVzKCkpIHtcbiAgICAgICAgY29uc3QgY2FjaGU6IENhY2hlZE1ldGFkYXRhIHwgbnVsbCA9IG9BcHAubWV0YWRhdGFDYWNoZS5nZXRGaWxlQ2FjaGUoZmlsZSk7XG4gICAgICAgIGlmIChjYWNoZSAhPSBudWxsICYmIGNhY2hlLnRhZ3MpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgdGFnIG9mIGNhY2hlLnRhZ3MpIHtcbiAgICAgICAgICAgICAgICBpZiAoZmluZFRhZyA9PT0gdGFnLnRhZykge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goZmlsZS5wYXRoKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY2FjaGUgIT0gbnVsbCAmJiBjYWNoZS5mcm9udG1hdHRlcikge1xuICAgICAgICAgICAgY29uc3QgZm10YWdzID0gKHBhcnNlRnJvbnRNYXR0ZXJUYWdzKGNhY2hlLmZyb250bWF0dGVyKSB8fCBbXSkuZmlsdGVyKHRhZyA9PiBmaW5kVGFnID09IHRhZyB8fCB0YWcuc3RhcnRzV2l0aChmaW5kVGFnICsgXCIvXCIpKTtcbiAgICAgICAgICAgIGlmIChmbXRhZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGZpbGUucGF0aClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGZtdGFnczIgPSAocGFyc2VGcm9udE1hdHRlckFsaWFzZXMoY2FjaGUuZnJvbnRtYXR0ZXIpIHx8IFtdKS5maWx0ZXIodGFnID0+IGZpbmRUYWcgPT0gdGFnIHx8IHRhZy5zdGFydHNXaXRoKGZpbmRUYWcgKyBcIi9cIikpO1xuICAgICAgICAgICAgaWYgKGZtdGFnczIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGZpbGUucGF0aClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0c1xufSIsICJpbXBvcnQgeyBBZGRUZXh0VG9Ob3Rlc0Zyb21TcGVjaWZpY1RhZ01vZGFsIH0gZnJvbSBcImFkZFRleHRUb05vdGVzRnJvbVNwZWNpZmljVGFnTW9kYWxcIjtcbmltcG9ydCB7IEFwcCwgRnV6enlTdWdnZXN0TW9kYWwsIEZ1enp5TWF0Y2gsIGdldEFsbFRhZ3MgfSBmcm9tIFwib2JzaWRpYW5cIjtcbmltcG9ydCB7IGFkZFRleHRUb05vdGVzIH0gZnJvbSBcInNlbGZ1dGlsL2FkZGxpbmt0b25vdGVzXCI7XG5pbXBvcnQgeyBnZXRBbGxOb3RlVGFncyB9IGZyb20gXCJzZWxmdXRpbC9nZXRBbGxOb3RlVGFnc1wiO1xuaW1wb3J0IHsgZ2V0QWxsTm90ZXMsIGdldFJlY2VudE5vdGVzIH0gZnJvbSBcInNlbGZ1dGlsL2dldFJlY2VudE5vdGVzXCI7XG5cbmV4cG9ydCBjbGFzcyBBZGRUZXh0VG9Ob3Rlc01vZGFsIGV4dGVuZHMgRnV6enlTdWdnZXN0TW9kYWw8c3RyaW5nPiB7XG5cbiAgbGlua1RvQWRkOiBzdHJpbmdcbiAgdGFza1R5cGU6IFN0cmluZ1xuICBkZXNjcmlwdGlvbjogc3RyaW5nXG4gIGluc2VydEZyb21CZWdpbm5pbmc6IGJvb2xlYW5cbiAgcG9zdEFjdGlvbjogKCkgPT4gdm9pZFxuXG4gIGNvbnN0cnVjdG9yKGFwcDogQXBwLCBsaW5rVG9BZGQ6IHN0cmluZywgZGVzY3JpcHRpb246IHN0cmluZywgaW5zZXJ0RnJvbUJlZ2lubmluZzogYm9vbGVhbiwgcG9zdEFjdGlvbjogKCkgPT4gdm9pZClcbiAge1xuICAgIHN1cGVyKGFwcClcbiAgICB0aGlzLmxpbmtUb0FkZCA9IGxpbmtUb0FkZFxuICAgIHRoaXMuZGVzY3JpcHRpb24gPSBkZXNjcmlwdGlvblxuICAgIHRoaXMuaW5zZXJ0RnJvbUJlZ2lubmluZyA9IGluc2VydEZyb21CZWdpbm5pbmdcbiAgICB0aGlzLnBvc3RBY3Rpb24gPSBwb3N0QWN0aW9uXG4gICAgdGhpcy5zZXRQbGFjZWhvbGRlcihgV2hpY2ggbm90ZXMgd2l0aCB0YWdzIGRvIHlvdSB3YW50IHRvICR7ZGVzY3JpcHRpb259IHRvP2ApXG4gICAgdGhpcy5zZXRJbnN0cnVjdGlvbnMoW1xuICAgICAge1xuICAgICAgICBjb21tYW5kOiBcIlwiLFxuICAgICAgICBwdXJwb3NlOiBgV2hpY2ggbm90ZXMgd2l0aCB0YWdzIGRvIHlvdSB3YW50IHRvICR7ZGVzY3JpcHRpb259IHRvP2BcbiAgICAgIH1cbiAgICBdKTtcbiAgfVxuXG4gIGdldEl0ZW1zKCkgOiBzdHJpbmdbXSB7XG5cdFx0Y29uc3QgbCA9IFsuLi5bJ0kvSW5ib3gubWQnXSwgLi4uZ2V0UmVjZW50Tm90ZXModGhpcy5hcHAsIDcpLCAuLi5nZXRBbGxOb3RlVGFncyh0aGlzLmFwcCkubWFwKHMgPT4gcy5yZXBsYWNlKC9eIy8sIFwiQFwiKSksIC4uLmdldEFsbE5vdGVzKHRoaXMuYXBwKV07XG4gICAgLy8gcmVtb3ZlIGR1cGxpY2F0ZSBmb3IgbFxuICAgIHJldHVybiBsLmZpbHRlcigoaXRlbSwgaW5kZXgpID0+IGwuaW5kZXhPZihpdGVtKSA9PT0gaW5kZXgpO1xuICB9XG5cbiAgZ2V0SXRlbVRleHQodmFsdWU6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgLy8gUmVuZGVycyBlYWNoIHN1Z2dlc3Rpb24gaXRlbS5cbiAgcmVuZGVyU3VnZ2VzdGlvbih2YWx1ZTogRnV6enlNYXRjaDxzdHJpbmc+LCBlbDogSFRNTEVsZW1lbnQpIHtcbiAgICBjb25zdCBpdGVtID0gdmFsdWUuaXRlbVxuICAgIGVsLmNyZWF0ZUVsKFwiZGl2XCIsIHsgdGV4dDogaXRlbSB9KVxuICB9XG5cbiAgLy8gUGVyZm9ybSBhY3Rpb24gb24gdGhlIHNlbGVjdGVkIHN1Z2dlc3Rpb24uXG4gIGFzeW5jIG9uQ2hvb3NlSXRlbShjaG9vc2VuVmFsdWU6IHN0cmluZywgZXZ0OiBNb3VzZUV2ZW50IHwgS2V5Ym9hcmRFdmVudCkge1xuICAgIGlmIChjaG9vc2VuVmFsdWUuc3RhcnRzV2l0aChcIkBcIikpIHtcbiAgICAgIG5ldyBBZGRUZXh0VG9Ob3Rlc0Zyb21TcGVjaWZpY1RhZ01vZGFsKHRoaXMuYXBwLCB0aGlzLmxpbmtUb0FkZCwgY2hvb3NlblZhbHVlLnJlcGxhY2UoL15ALywgXCIjXCIpLCB0aGlzLmRlc2NyaXB0aW9uLCB0aGlzLmluc2VydEZyb21CZWdpbm5pbmcsIHRoaXMucG9zdEFjdGlvbikub3BlbigpXG4gICAgfSBlbHNlIHtcbiAgICAgIGFkZFRleHRUb05vdGVzKHRoaXMubGlua1RvQWRkLCBjaG9vc2VuVmFsdWUsIHRoaXMuYXBwLCB0aGlzLmluc2VydEZyb21CZWdpbm5pbmcpXG4gICAgICB0aGlzLnBvc3RBY3Rpb24oKVxuICAgIH1cbiAgfVxufSIsICJpbXBvcnQgeyBBcHAgfSBmcm9tIFwib2JzaWRpYW5cIjtcblxuZXhwb3J0IGZ1bmN0aW9uIGdldFJlY2VudE5vdGVzKGFwcDogQXBwLCBsaW1pdDogbnVtYmVyKTogc3RyaW5nW10ge1xuICBjb25zdCByZWNlbnRWaWV3ZWROb3RlcyA9IGFwcC53b3Jrc3BhY2UuZ2V0TGFzdE9wZW5GaWxlcygpO1xuICByZXR1cm4gcmVjZW50Vmlld2VkTm90ZXMuc2xpY2UoMCwgTWF0aC5taW4obGltaXQsIHJlY2VudFZpZXdlZE5vdGVzLmxlbmd0aCkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0QWxsTm90ZXMoYXBwOiBBcHApOiBzdHJpbmdbXSB7XG4gIGNvbnN0IGZpbGVzID0gYXBwLnZhdWx0LmdldE1hcmtkb3duRmlsZXMoKTtcbiAgY29uc3QgYWxsTm90ZXMgPSBmaWxlcy5tYXAoKGZpbGUpID0+IGZpbGUucGF0aCk7XG4gIHJldHVybiBhbGxOb3Rlcztcbn1cblxuIiwgImltcG9ydCB7IE5hdmlnYXRlVG9Ob3RlRnJvbVRhZ01vZGFsIH0gZnJvbSBcIm5hdmlnYXRlVG9Ob3RlRnJvbVRhZ01vZGFsXCJcbmltcG9ydCB7IEFwcCwgRnV6enlTdWdnZXN0TW9kYWwsIEZ1enp5TWF0Y2gsIE5vdGljZSwgQ2FjaGVkTWV0YWRhdGEsIHBhcnNlRnJvbnRNYXR0ZXJUYWdzLCBwYXJzZUZyb250TWF0dGVyQWxpYXNlcywgVEZpbGUgfSBmcm9tIFwib2JzaWRpYW5cIlxuaW1wb3J0IHsgZmlsZXNXaGVyZVRhZ0lzVXNlZCB9IGZyb20gXCJzZWxmdXRpbC9maW5kTm90ZXNGcm9tVGFnXCJcblxuY29uc3QgQkFDS19UT19TRUxFQ1RfVEFHID0gXCJCYWNrIHRvIHNlbGVjdCB0YWdcIlxuXG5leHBvcnQgY2xhc3MgTmF2aWdhdGVUb05vdGVGcm9tU3BlY2lmaWNUYWdNb2RhbCBleHRlbmRzIEZ1enp5U3VnZ2VzdE1vZGFsPHN0cmluZz4ge1xuXG4gIHRhZ1RvRmluZDogc3RyaW5nXG5cbiAgY29uc3RydWN0b3IoYXBwOiBBcHAsIHRhZ1RvRmluZDogc3RyaW5nKVxuICB7XG4gICAgc3VwZXIoYXBwKVxuICAgIHRoaXMudGFnVG9GaW5kID0gdGFnVG9GaW5kXG4gICAgdGhpcy5zZXRQbGFjZWhvbGRlcihgV2hpY2ggbm90ZXMgd2l0aCB0YWcgJHt0YWdUb0ZpbmR9IGRvIHlvdSB3YW50IHRvIG5hdmlnYXRlIHRvP2ApXG4gICAgdGhpcy5zZXRJbnN0cnVjdGlvbnMoW1xuICAgICAge1xuICAgICAgICBjb21tYW5kOiBcIlwiLFxuICAgICAgICBwdXJwb3NlOiBgV2hpY2ggbm90ZXMgd2l0aCB0YWcgJHt0YWdUb0ZpbmR9IGRvIHlvdSB3YW50IHRvIG5hdmlnYXRlIHRvP2BcbiAgICAgIH1cbiAgICBdKTtcbiAgfVxuXG5cbiAgZ2V0SXRlbXMoKTogc3RyaW5nW10ge1xuICAgIHJldHVybiBbLi4uW0JBQ0tfVE9fU0VMRUNUX1RBR10sIC4uLmZpbGVzV2hlcmVUYWdJc1VzZWQodGhpcy50YWdUb0ZpbmQpXTtcbiAgfVxuXG4gIGdldEl0ZW1UZXh0KHBhdGg6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHBhdGg7XG4gIH1cblxuICAvLyBSZW5kZXJzIGVhY2ggc3VnZ2VzdGlvbiBpdGVtLlxuICByZW5kZXJTdWdnZXN0aW9uKHBhdGg6IEZ1enp5TWF0Y2g8c3RyaW5nPiwgZWw6IEhUTUxFbGVtZW50KSB7XG4gICAgY29uc3QgcGF0aEl0ZW06IHN0cmluZyA9IHBhdGguaXRlbVxuICAgIGVsLmNyZWF0ZUVsKFwiZGl2XCIsIHsgdGV4dDogcGF0aEl0ZW0gfSk7XG4gIH1cblxuICAvLyBQZXJmb3JtIGFjdGlvbiBvbiB0aGUgc2VsZWN0ZWQgc3VnZ2VzdGlvbi5cbiAgb25DaG9vc2VJdGVtKHBhdGg6IHN0cmluZywgZXZ0OiBNb3VzZUV2ZW50IHwgS2V5Ym9hcmRFdmVudCkge1xuICAgIGlmIChCQUNLX1RPX1NFTEVDVF9UQUcgPT0gcGF0aCkge1xuICAgICAgbmV3IE5hdmlnYXRlVG9Ob3RlRnJvbVRhZ01vZGFsKHRoaXMuYXBwKS5vcGVuKClcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgeyB2YXVsdCwgd29ya3NwYWNlIH0gPSB0aGlzLmFwcDtcbiAgICAgIGNvbnN0IGxlYWYgPSB3b3Jrc3BhY2UuZ2V0TGVhZihmYWxzZSk7XG4gICAgICBQcm9taXNlLnJlc29sdmUoKVxuICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgIHJldHVybiBsZWFmLm9wZW5GaWxlKHZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aChwYXRoKSBhcyBURmlsZSwgeyBhY3RpdmUgOiB0cnVlIH0pO1xuICAgICAgfSlcbiAgfVxuICB9XG59IiwgImltcG9ydCB7IE5hdmlnYXRlVG9Ob3RlRnJvbVNwZWNpZmljVGFnTW9kYWwgfSBmcm9tIFwibmF2aWdhdGVUb05vdGVGcm9tU3BlY2lmaWNUYWdNb2RhbFwiO1xuaW1wb3J0IHsgQXBwLCBGdXp6eVN1Z2dlc3RNb2RhbCwgRnV6enlNYXRjaCwgZ2V0QWxsVGFncywgVEZpbGUsIE5vdGljZSwgTWFya2Rvd25WaWV3IH0gZnJvbSBcIm9ic2lkaWFuXCI7XG5pbXBvcnQgeyBnZXRBbGxUYWdzV2l0aEZpbHRlciB9IGZyb20gXCJzZWxmdXRpbC9nZXRBbGxOb3RlVGFnc1wiO1xuaW1wb3J0IHsgZ2V0QWxsTm90ZXMsIGdldFJlY2VudE5vdGVzIH0gZnJvbSBcInNlbGZ1dGlsL2dldFJlY2VudE5vdGVzXCI7XG5cbmludGVyZmFjZSBOb3RlIHtcbiAgc2VhcmNoOiBzdHJpbmcsXG4gIHNlY29uZGFyeTogc3RyaW5nXG4gIHR5cGU6IHN0cmluZ1xufVxuXG5pbnRlcmZhY2UgSGVhZGluZyB7XG4gIG5vdGU6IHN0cmluZyxcbiAgaGVhZGluZzogc3RyaW5nLFxuICBsZXZlbDogbnVtYmVyXG59XG5cbmNvbnN0IG5vdGUgPSBcIm5vdGVcIlxuY29uc3QgdGFnID0gXCJ0YWdcIlxuY29uc3QgaGVhZGluZyA9IFwiaGVhZGluZ1wiXG5cbmV4cG9ydCBjbGFzcyBOYXZpZ2F0ZVRvTm90ZUZyb21UYWdNb2RhbCBleHRlbmRzIEZ1enp5U3VnZ2VzdE1vZGFsPE5vdGU+IHtcblxuICB0YXNrVHlwZTogTm90ZVxuXG4gIGNvbnN0cnVjdG9yKGFwcDogQXBwKVxuICB7XG4gICAgc3VwZXIoYXBwKVxuICAgIHRoaXMuc2V0UGxhY2Vob2xkZXIoYFdoaWNoIG5vdGVzIHdpdGggdGFncyBkbyB5b3Ugd2FudCB0byBuYXZpZ2F0ZSB0bz9gKVxuICAgIHRoaXMuc2V0SW5zdHJ1Y3Rpb25zKFtcbiAgICAgIHtcbiAgICAgICAgY29tbWFuZDogXCJcIixcbiAgICAgICAgcHVycG9zZTogXCJXaGljaCBub3RlcyB3aXRoIHRhZ3MgZG8geW91IHdhbnQgdG8gbmF2aWdhdGUgdG8/XCJcbiAgICAgIH1cbiAgICBdKTtcbiAgfVxuXG4gIGdldEl0ZW1zKCkgOiBOb3RlW10ge1xuICAgIGNvbnN0IGFsbE5vdGVzID0gZ2V0QWxsTm90ZXModGhpcy5hcHApXG4gICAgbGV0IGhlYWRpbmdzOiBIZWFkaW5nW10gPSBbXVxuICAgIGFsbE5vdGVzLmZvckVhY2gobiA9PiB7XG4gICAgICBjb25zdCBmaWxlID0gdGhpcy5hcHAudmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKG4pIGFzIFRGaWxlXG4gICAgICBjb25zdCBmaWxlQ2FjaGUgPSB0aGlzLmFwcC5tZXRhZGF0YUNhY2hlLmdldEZpbGVDYWNoZShmaWxlKVxuICAgICAgaWYgKCFmaWxlQ2FjaGUpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICBpZiAoIWZpbGVDYWNoZS5oZWFkaW5ncykge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIGZpbGVDYWNoZS5oZWFkaW5ncy5mb3JFYWNoKGggPT4ge1xuICAgICAgICBoZWFkaW5ncy5wdXNoKHtub3RlOiBuLCBoZWFkaW5nOiBoLmhlYWRpbmcsIGxldmVsOiBoLmxldmVsfSlcbiAgICAgIH0pXG4gICAgfSlcblx0XHRyZXR1cm4gW1xuICAgICAgLi4uZ2V0UmVjZW50Tm90ZXModGhpcy5hcHAsIDcpLm1hcChuID0+IHtcbiAgICAgICAgcmV0dXJuIHtzZWFyY2g6IG4sIHNlY29uZGFyeTogXCJcIiwgdHlwZTogbm90ZX1cbiAgICAgIH0pLFxuICAgICAgLi4uZ2V0QWxsVGFnc1dpdGhGaWx0ZXIodGhpcy5hcHApLm1hcChuID0+IHtcbiAgICAgICAgcmV0dXJuIHtzZWFyY2g6IG4ucmVwbGFjZSgvXiMvLCBcIkBcIiksIHNlY29uZGFyeTogXCJcIiwgdHlwZTogdGFnfVxuICAgICAgfSksXG4gICAgICAuLi5hbGxOb3Rlcy5tYXAobiA9PiB7XG4gICAgICAgIHJldHVybiB7c2VhcmNoOiBuLCBzZWNvbmRhcnk6IFwiXCIsIHR5cGU6IG5vdGV9XG4gICAgICB9KSxcbiAgICAgIC4uLmhlYWRpbmdzLm1hcChoID0+IHtcbiAgICAgICAgcmV0dXJuIHtzZWFyY2g6ICcjJy5yZXBlYXQoaC5sZXZlbCkgKyBcIiBcIiArIGguaGVhZGluZywgc2Vjb25kYXJ5OiBoLm5vdGUsIHR5cGU6IGhlYWRpbmd9XG4gICAgICB9KVxuICAgIF07XG4gIH1cblxuICBnZXRJdGVtVGV4dCh2YWx1ZTogTm90ZSk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHZhbHVlLnNlYXJjaDtcbiAgfVxuXG4gIC8vIFJlbmRlcnMgZWFjaCBzdWdnZXN0aW9uIGl0ZW0uXG4gIHJlbmRlclN1Z2dlc3Rpb24odmFsdWU6IEZ1enp5TWF0Y2g8Tm90ZT4sIGVsOiBIVE1MRWxlbWVudCkge1xuICAgIGNvbnN0IGl0ZW0gPSB2YWx1ZS5pdGVtXG4gICAgZWwuY3JlYXRlRWwoXCJkaXZcIiwgeyB0ZXh0OiBpdGVtLnNlYXJjaCB9KTtcbiAgICBlbC5jcmVhdGVFbChcInNtYWxsXCIsIHsgdGV4dDogaXRlbS50eXBlICsgXCIgXCIgKyBpdGVtLnNlY29uZGFyeSB9KTtcbiAgfVxuXG4gIC8vIFBlcmZvcm0gYWN0aW9uIG9uIHRoZSBzZWxlY3RlZCBzdWdnZXN0aW9uLlxuICBhc3luYyBvbkNob29zZUl0ZW0oY2hvb3NlblZhbHVlOiBOb3RlLCBldnQ6IE1vdXNlRXZlbnQgfCBLZXlib2FyZEV2ZW50KSB7XG4gICAgaWYgKGNob29zZW5WYWx1ZS50eXBlID09IHRhZykge1xuICAgICAgbmV3IE5hdmlnYXRlVG9Ob3RlRnJvbVNwZWNpZmljVGFnTW9kYWwodGhpcy5hcHAsIGNob29zZW5WYWx1ZS5zZWFyY2gucmVwbGFjZShcIkBcIiwgXCIjXCIpKS5vcGVuKClcbiAgICB9IGVsc2UgaWYgKGNob29zZW5WYWx1ZS50eXBlID09IG5vdGUpIHtcbiAgICAgIGNvbnN0IHsgdmF1bHQsIHdvcmtzcGFjZSB9ID0gdGhpcy5hcHA7XG4gICAgICBjb25zdCBsZWFmID0gd29ya3NwYWNlLmdldExlYWYoZmFsc2UpO1xuICAgICAgUHJvbWlzZS5yZXNvbHZlKClcbiAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICByZXR1cm4gbGVhZi5vcGVuRmlsZSh2YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgoY2hvb3NlblZhbHVlLnNlYXJjaCkgYXMgVEZpbGUsIHsgYWN0aXZlIDogdHJ1ZSB9KTtcbiAgICAgIH0pXG4gICAgfSBlbHNlIGlmIChjaG9vc2VuVmFsdWUudHlwZSA9PSBoZWFkaW5nKSB7XG4gICAgICBjb25zdCB7IHZhdWx0LCB3b3Jrc3BhY2UgfSA9IHRoaXMuYXBwO1xuICAgICAgY29uc3QgbGVhZiA9IHdvcmtzcGFjZS5nZXRMZWFmKGZhbHNlKTtcbiAgICAgIFByb21pc2UucmVzb2x2ZSgpXG4gICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIGxlYWYub3BlbkZpbGUodmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKGNob29zZW5WYWx1ZS5zZWNvbmRhcnkpIGFzIFRGaWxlLCB7IGFjdGl2ZSA6IHRydWUgfSk7XG4gICAgICB9KVxuICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICBjb25zdCBtYXJrZG93blZpZXcgPSBhcHAud29ya3NwYWNlLmdldEFjdGl2ZVZpZXdPZlR5cGUoTWFya2Rvd25WaWV3KTtcbiAgICAgICAgY29uc3QgZWRpdG9yID0gbWFya2Rvd25WaWV3Py5lZGl0b3JcbiAgICAgICAgaWYgKG1hcmtkb3duVmlldyA9PSBudWxsIHx8IGVkaXRvciA9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBlcnJvclJlYXNvbiA9IGBlZGl0b3Igb3IgdmFsdWUgJHtjaG9vc2VuVmFsdWUuc2Vjb25kYXJ5fSBub3QgZXhpc3QuIEFib3J0aW5nLi4uYFxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yUmVhc29uKVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRvdGFsTGluZU51bSA9IGVkaXRvci5saW5lQ291bnQoKVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRvdGFsTGluZU51bTsgaSsrKSB7XG4gICAgICAgICAgY29uc3QgbGluZSA9IGVkaXRvci5nZXRMaW5lKGkpXG4gICAgICAgICAgaWYgKGxpbmUgPT0gY2hvb3NlblZhbHVlLnNlYXJjaCkge1xuICAgICAgICAgICAgZWRpdG9yLnNldEN1cnNvcih7bGluZTogaSwgY2g6IDB9KVxuICAgICAgICAgICAgLy8gc2Nyb2xsIHRoZSB2aWV3IHRvIHRoZSBjdXJzb3JcbiAgICAgICAgICAgIGVkaXRvci5zY3JvbGxJbnRvVmlldyh7ZnJvbToge2xpbmU6IGksIGNoOiAwfSwgdG86IHtsaW5lOiBpLCBjaDogMH19LCB0cnVlKVxuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgfVxufSIsICJpbXBvcnQgeyBFZGl0b3IsIEVkaXRvclNlbGVjdGlvbiB9IGZyb20gXCJvYnNpZGlhblwiXG5cbmV4cG9ydCBmdW5jdGlvbiBleHBvcnRDdXJyZW50U2VsZWN0aW9uKGVkaXRvcjogRWRpdG9yKTogc3RyaW5nIHtcbiAgICBsZXQgdGV4dCA9IFwiXCJcbiAgICBjb25zdCBsaXN0U2VsZWN0aW9uczogRWRpdG9yU2VsZWN0aW9uW10gPSBlZGl0b3IubGlzdFNlbGVjdGlvbnMoKVxuICAgIGxpc3RTZWxlY3Rpb25zLmZvckVhY2gobGlzdFNlbGVjdGlvbiA9PiB7XG4gICAgICAgIGNvbnN0IGEgPSBsaXN0U2VsZWN0aW9uLmhlYWQubGluZVxuICAgICAgICBjb25zdCBiID0gbGlzdFNlbGVjdGlvbi5hbmNob3IubGluZVxuICAgICAgICBjb25zdCBmcm9tTGluZU51bSA9IGIgPiBhID8gYSA6IGJcbiAgICAgICAgY29uc3QgdG9MaW5lTnVtID0gYiA+IGEgPyBiIDogYVxuICAgICAgICBmb3IgKGxldCBpID0gZnJvbUxpbmVOdW07IGkgPD0gdG9MaW5lTnVtOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGxpbmUgPSBlZGl0b3IuZ2V0TGluZShpKVxuICAgICAgICAgICAgdGV4dCArPSBsaW5lICsgXCJcXG5cIlxuICAgICAgICB9XG4gICAgfSlcbiAgICByZXR1cm4gdGV4dC5yZXBsYWNlKC9cXG4kLywgXCJcIilcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTZWxlY3Rpb25SYW5nZSB7XG4gICAgZnJvbUxpbmVOdW06IG51bWJlclxuICAgIGZyb21DaDogbnVtYmVyXG4gICAgdG9MaW5lTnVtOiBudW1iZXJcbiAgICB0b0NoOiBudW1iZXJcbn1cblxuLy8gYXNzdW1lIDEgc2VsZWN0aW9uXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q3VycmVudFNlbGVjdGlvbkxpbmVOdW1iZXIoZWRpdG9yOiBFZGl0b3IpOiBTZWxlY3Rpb25SYW5nZSB7XG4gICAgbGV0IHRleHQgPSBcIlwiXG4gICAgbGV0IGZyb21MaW5lTnVtID0gMFxuICAgIGxldCBmcm9tQ2ggPSAwXG4gICAgbGV0IHRvTGluZU51bSA9IDBcbiAgICBsZXQgdG9DaCA9IDBcbiAgICBjb25zdCBsaXN0U2VsZWN0aW9uczogRWRpdG9yU2VsZWN0aW9uW10gPSBlZGl0b3IubGlzdFNlbGVjdGlvbnMoKVxuICAgIGxpc3RTZWxlY3Rpb25zLmZvckVhY2gobGlzdFNlbGVjdGlvbiA9PiB7XG4gICAgICAgIGNvbnN0IGEgPSBsaXN0U2VsZWN0aW9uLmhlYWQubGluZVxuICAgICAgICBjb25zdCBhY2ggPSBsaXN0U2VsZWN0aW9uLmhlYWQuY2hcbiAgICAgICAgY29uc3QgYiA9IGxpc3RTZWxlY3Rpb24uYW5jaG9yLmxpbmVcbiAgICAgICAgY29uc3QgYmNoID0gbGlzdFNlbGVjdGlvbi5hbmNob3IuY2hcbiAgICAgICAgZnJvbUxpbmVOdW0gPSBiID4gYSA/IGEgOiBiXG4gICAgICAgIGZyb21DaCA9IGIgPiBhID8gYWNoIDogYmNoXG4gICAgICAgIHRvTGluZU51bSA9IGIgPiBhID8gYiA6IGFcbiAgICAgICAgdG9DaCA9IGIgPiBhID8gYmNoIDogYWNoXG4gICAgfSlcbiAgICByZXR1cm4geyBmcm9tTGluZU51bSwgZnJvbUNoLCB0b0xpbmVOdW0sIHRvQ2ggfVxufSIsICJpbXBvcnQgeyBFZGl0b3IgfSBmcm9tIFwib2JzaWRpYW5cIlxuXG5jb25zdCBza2lwRnJvbnRNYXR0ZXJGaWVsZDogc3RyaW5nW10gPSBbXG5cdFwiZnJlZXRpbWV0YXNrOiBcIixcblx0XCJleHBlY3RlZHRpbWU6IFwiLFxuXHRcIm1vZGU6IFwiLFxuXHRcImRheXM6IFwiLFxuXHRcInNob3doZWFkZXJmb290ZXI6IFwiLFxuXHRcInNob3dzdGF0ZTogXCIsXG5cdFwic29ydHN1YnBhZ2VmaWx0ZXI6IFwiLFxuXHRcInRocm91Z2h0dHJlZTogXCIsXG5cdFwidXJnZW50OiBcIixcblx0XCJkaXNwbGF5YXM6IFwiLFxuXHRcInN0YXJ0ZGF0ZTogXCIsXG5cdFwicmVhZHdyaXRlbW9kZTogXCIsXG5cdFwic2hvd0NoYW5kbGVyTm93OiBcIixcblx0XCJkZWVwd29yazogXCIsXG5cdFwiZXhwZWN0ZWR0aW1lOiBcIixcblx0XCJwYXJzZWRhdGU6IFwiLFxuXHRcInRpZHNjb3BlOiBcIixcblx0XCJpbnNlcnR0b2RvYWN0aW9uOiBcIixcblx0XCJvcHRpb25hbDogXCIsXG5cdFwicmVwbGFjZXRvOiBcIixcblx0XCJiYWNrdXB0aWRkbGVyOiBcIixcblx0XCJkZWFkbGluZTogXCIsXG5cdFwiY2FwdGlvbjogXCIsXG5cdFwiY29sbGVjdGlvbjogXCIsXG5cdFwibGlicmFyeTogXCIsXG5cdFwibGlicmFyeV92ZXJzaW9uOiBcIixcblx0XCJkdW1teTogXCIsXG5cdFwidGlkTmFtZTogXCIsXG5cdFwiY2hyb25pY2xlZGF0ZTogXCIsXG5cdFwiZXZlbnRkYXRlOiBcIixcblx0XCJkYWlseWhpZ2hsaWdodDogXCIsXG5cdFwiZGlzcGxheWNhcmRtb2RlOiBcIixcblx0XCJkaXNwbGF5bW9kZTogXCIsXG5cdFwibnVtY29sOiBcIixcblx0XCJkYXRleXl5eW1tZGQ6IFwiLFxuXHRcImdyYXBoZGlzcGxheW1vZGU6IFwiLFxuXHRcIm1heGRlcHRoOiBcIixcblx0XCJqb3VybmFsZGF0ZTogXCIsXG5cdFwidGhpc0JpbGxEYXRlOiBcIixcblx0XCJsYXN0QmlsbERhdGU6IFwiLFxuXHRcInJvb3R0aWRkbGVyOiBcIixcblx0XCJ5ZWFyOiBcIixcblx0XCJ0bzogXCIsXG5cdFwidGlkdGVtcGxhdGU6IFwiLFxuXHRcInRpZGRsZXJuYW1lOiBcIixcblx0XCJ0aGVtZTogXCIsXG5cdFwidGFndmFsdWU6IFwiLFxuXHRcInN1YnRhc2tudW06IFwiLFxuXHRcInJlbW92ZXRhZ3ZhbHVlOiBcIixcblx0XCJyZWN1cnJpbmdldmVudHN0YXJ0ZGF0ZTogXCIsXG5cdFwicmVjdXJyaW5nZXZlbnRlbmRkYXRlOiBcIixcblx0XCJwbHVnaW5uYW1lOiBcIixcblx0XCJwaWQ6IFwiLFxuXHRcIm1hY3JvbmFtZTogXCIsXG5cdFwibGltaXQ6IFwiLFxuXHRcImtleXdvcmQ6IFwiLFxuXHRcImtleXdvcmR0bXA6IFwiLFxuXHRcImZyb206IFwiLFxuXHRcImRlcHJlY2F0ZXJlYXNvbjogXCIsXG5cdFwiZGVlcHdvOiBcIixcblx0XCJjb2xvcjogXCIsXG5cdFwicm93OiBcIixcblx0XCJjb2w6IFwiLFxuXHRcImJvb2ttYXJrZWQ6IFwiLFxuXHRcImJsb2NraW5ncmVtaW5kZXJkYXRlOiBcIixcblx0XCJiYWNrdXA6IFwiXG5dXG5cbmV4cG9ydCBmdW5jdGlvbiByZXBsYWNlVFdVc2VsZXNzVmFsdWUodmFsdWU6IHN0cmluZykgOiBzdHJpbmcge1xuICAgIHJldHVybiB2YWx1ZVxuICAgICAgICAucmVwbGFjZShcIiMjID4gUmVmZXJlbmNlc1xcblxcbiogXFxuXFxuXCIsIFwiXCIpXG4gICAgICAgIC5yZXBsYWNlKFwiIyMgPiBHb2FsIGFuZCBSZWFzb25cXG5cXG4qIFxcblxcblwiLCBcIlwiKVxuICAgICAgICAucmVwbGFjZShcIiMjID4gRGVsaXZlcmFibGUgU3BlY1xcblxcbiogXFxuXFxuXCIsIFwiXCIpXG4gICAgICAgIC5yZXBsYWNlKFwiIyMgPiBDb25kaXRvbiBvZiBkb25lXFxuXFxuKiBcXG5cXG5cIiwgXCJcIilcbiAgICAgICAgLnJlcGxhY2UoXCIjIyA+IFN0ZXBcXG5cXG4qIFxcblxcblwiLCBcIlwiKVxuICAgICAgICAucmVwbGFjZShcIiMjID4gUHJvZ3Jlc3NcXG5cXG4qIFxcblxcblwiLCBcIlwiKVxuICAgICAgICAucmVwbGFjZShcIiMjID4gUmVzdWx0c1xcblxcbiogXFxuXFxuXCIsIFwiXCIpXG4gICAgICAgIC5yZXBsYWNlKFwiIyMgPiBFeHBlcmllbmNlXFxuXFxuKiBcXG5cXG5cIiwgXCJcIilcbiAgICAgICAgLnJlcGxhY2UoXCIjIyA+IFJlZmVyZW5jZXNcXG5cXG4qIFxcblxcblwiLCBcIlwiKVxuICAgICAgICAucmVwbGFjZShcIiMjID4gUmVzdWx0cywgU3RlcHMgYW5kIEV4cFxcblxcbiogXFxuXFxuXCIsIFwiXCIpXG4gICAgICAgIC5yZXBsYWNlKFwiIyMgPiBDaGVja2xpc3RcXG5cXG5bIF0gXFxuXFxuXCIsIFwiXCIpXG4gICAgICAgIC5yZXBsYWNlKC9cXG5cXG5cXG4rLywgXCJcXG5cXG5cIilcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNob3VsZFNraXBGcm9udE1hdHRlcihsaW5lOiBzdHJpbmcpIDogYm9vbGVhbiB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBza2lwRnJvbnRNYXR0ZXJGaWVsZC5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAobGluZS5zdGFydHNXaXRoKHNraXBGcm9udE1hdHRlckZpZWxkW2ldKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2Vcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFBhcmVudExpbmUodmFsdWU6IHN0cmluZykge1xuICAgIGNvbnN0IHZhbHVlcyA9IHZhbHVlLnNwbGl0KFwiXFxuXCIpXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgbGluZUNvbnRlbnQgPSB2YWx1ZXNbaV1cbiAgICAgICAgaWYgKC9ecGFyZW50XFxkKzogLy50ZXN0KGxpbmVDb250ZW50KSB8fCAvXlxcdCstIHBhcmVudFxcZCs6IC8udGVzdChsaW5lQ29udGVudCkpIHtcbiAgICAgICAgICAgIHJldHVybiBpXG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIDBcbn1cblxuZXhwb3J0IGZ1bmN0aW9uXHR0aWR5VXBGcm9udE1hdHRlcm9uRWRpdG9yKGVkaXRvcjogRWRpdG9yKSB7XG4gICAgY29uc3QgdmFsdWUgPSBlZGl0b3IuZ2V0VmFsdWUoKVxuICAgIGNvbnN0IG1vZGlmaWVkVmFsdWUgPSB0aWR5VXBGcm9udE1hdHRlck9uVmFsdWUodmFsdWUpXG4gICAgZWRpdG9yLnNldFZhbHVlKG1vZGlmaWVkVmFsdWUpXG59XG5cbi8qXG5leHBvcnQgZnVuY3Rpb25cdHRpZHlVcEZyb250TWF0dGVyT25WYWx1ZSh2YWx1ZTogU3RyaW5nKSB7XG4gICAgY29uc3QgdmFsdWVzOiBzdHJpbmdbXSA9IHZhbHVlLnNwbGl0KFwiXFxuXCIpXG4gICAgY29uc3QgbGluZUNvdW50ID0gdmFsdWVzLmxlbmd0aFxuXG4gICAgbGV0IGZtID0gXCJcIlxuICAgIGxldCBjID0gXCJcIlxuICAgIGxldCB0ZXh0ID0gXCJcIlxuICAgIGxldCBoM0NvdW50ID0gMDtcbiAgICBsZXQgY29udGVudCA9IFwiXCJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmVDb3VudDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGxpbmUgPSB2YWx1ZXNbaV1cbiAgICAgICAgaWYgKGgzQ291bnQgPT0gMCkge1xuICAgICAgICAgICAgY29udGVudCArPSAobGluZSArIFwiXFxuXCIpXG4gICAgICAgIH0gZWxzZSBpZiAoaDNDb3VudCA9PSAxKSB7XG4gICAgICAgICAgICBpZiAoc2hvdWxkU2tpcEZyb250TWF0dGVyKGxpbmUpKSB7XG4gICAgICAgICAgICAgICAgLy8gZG8gbm90aGluZ1xuICAgICAgICAgICAgfSBlbHNlIGlmICgvXnBhcmVudFxcZCs6IC8udGVzdChsaW5lKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1vZGlmaWVkTGluZSA9IGxpbmUucmVwbGFjZSgvXFwvL2csIFwiX1wiKS5yZXBsYWNlKC9cXD8vZywgXCJfXCIpLnJlcGxhY2UoLzovZywgXCJfXCIpLnJlcGxhY2UoL14ocGFyZW50XFxkKylfIC8sIFwiJDE6IFwiKVxuICAgICAgICAgICAgICAgIGZtICs9IChtb2RpZmllZExpbmUgKyBcIlxcblwiKVxuICAgICAgICAgICAgfSBlbHNlIGlmIChsaW5lLnN0YXJ0c1dpdGgoXCJ0aXRsZTogXCIpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbW9kaWZpZWRMaW5lID0gbGluZS5yZXBsYWNlKC86L2csIFwiX1wiKS5yZXBsYWNlKC9edGl0bGVfIC8sIFwidGl0bGU6IFwiKS5yZXBsYWNlKC9cXC8vZywgXCJfXCIpLnJlcGxhY2UoL1xcPy9nLCBcIl9cIilcbiAgICAgICAgICAgICAgICBmbSArPSAobW9kaWZpZWRMaW5lICsgXCJcXG5cIilcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobGluZSA9PT0gXCJ0YWdzOiBbZXhjYWxpZHJhd11cIil7XG4gICAgICAgICAgICAgICAgZm0gKz0gKGxpbmUgKyBcIlxcblwiKVxuICAgICAgICAgICAgfSBlbHNlIGlmIChsaW5lLnN0YXJ0c1dpdGgoXCJ0YWdzc3M6IFwiKSB8fCBsaW5lLnN0YXJ0c1dpdGgoXCJ0YWdzOiBcIikpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBicmFja2V0UGF0dGVybiA9IC9cXFtcXFsuKj9cXF1cXF0vZztcblxuICAgICAgICAgICAgICAgIC8vIEZpbmQgYWxsIGJyYWNrZXRlZCBpdGVtc1xuICAgICAgICAgICAgICAgIGNvbnN0IGJyYWNrZXRlZEl0ZW1zID0gbGluZS5tYXRjaChicmFja2V0UGF0dGVybikgfHwgW107XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIGJyYWNrZXRlZCBpdGVtcyBmcm9tIHRoZSBpbnB1dCBzdHJpbmcgdG8gZGVhbCB3aXRoIHRoZSByZW1haW5pbmdcbiAgICAgICAgICAgICAgICBjb25zdCByZW1haW5pbmdTdHJpbmcgPSBsaW5lLnJlcGxhY2UoYnJhY2tldFBhdHRlcm4sICcnKS50cmltKCk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gU3BsaXQgdGhlIHJlbWFpbmluZyBzdHJpbmcgYnkgc3BhY2VzIHRvIGdldCB0aGUgaW5kaXZpZHVhbCB3b3Jkc1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlbWFpbmluZ0l0ZW1zID0gcmVtYWluaW5nU3RyaW5nLnNwbGl0KC9cXHMrLykuZmlsdGVyKGl0ZW0gPT4gaXRlbSk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gQ29tYmluZSB0aGUgYnJhY2tldGVkIGl0ZW1zIGFuZCB0aGUgaW5kaXZpZHVhbCB3b3JkcyBpbnRvIG9uZSBhcnJheVxuICAgICAgICAgICAgICAgIGNvbnN0IGZtdGFnc3NzID0gWy4uLmJyYWNrZXRlZEl0ZW1zLCAuLi5yZW1haW5pbmdJdGVtc107XG5cbiAgICAgICAgICAgICAgICBsZXQgcGFyZW50IDogc3RyaW5nW10gPSBbXVxuICAgICAgICAgICAgICAgIGxldCB0YWdzc3MgOiBzdHJpbmdbXSA9IFtdXG4gICAgICAgICAgICAgICAgbGV0IHNraXBzIDogc3RyaW5nW109IFtdXG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgZm10YWdzc3MuZm9yRWFjaCh0YWcgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0YWcgPSB0YWcudHJpbSgpXG4gICAgICAgICAgICAgICAgICAgIC8vIFtbZXZlbnQgbl1dIC8gW1tldmVudCB3XV0gLyByZWdleCBvZiBbWzIwMjIwNzE3IEpvdXJuYWwgKFdlZWsgMjggU3VuKV1dOiBwdXQgaW4gc2tpcHNcbiAgICAgICAgICAgICAgICAgICAgLy8gW1syMDIyMDcyMSBKb3VybmFsIChXZWVrIDI5IFRodSldXVxuICAgICAgICAgICAgICAgICAgICBpZiAodGFnID09PSBcIltbLkhlYWRlciBTaG9ydGN1dF1dXCIgfHwgdGFnID09PSBcIltbLkN1cnJlbnQgUHJvamVjdF1dXCIgfHwgdGFnID09PSBcImNvbmNlcHRcIiB8fCB0YWcgPT09IFwic3BhY2VcIiB8fCB0YWcgPT09IFwicHJvYmxlbVwiIHx8IHRhZyA9PT0gXCJ0YWdzc3M6XCIgfHwgdGFnID09PSBcInRhZ3M6XCIgfHwgdGFnID09PSBcIltbZXZlbnQgbl1dXCIgfHwgdGFnID09PSBcIltbZXZlbnQgd11dXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIHx8IC9cXFtcXFtcXGR7OH0gSm91cm5hbCBcXChXZWVrIFxcZCsgW0EtWmEtel17M31cXClcXF1cXF0vLnRlc3QodGFnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2tpcHMucHVzaCh0YWcpXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGFnID09PSBcInBlcm10YXNrXCIgfHwgXHR0YWcgPT09IFwiTlwiIHx8IHRhZyA9PT0gXCJXXCIgfHwgdGFnID09PSBcIm5vd1wiIHx8IHRhZyA9PT0gXCJsYXRlclwiIHx8IHRhZyA9PT0gXCJ3YWl0aW5nXCIgfHwgdGFnID09PSBcImRvbmVcIiB8fCB0YWcgPT09IFwiYXJjaGl2ZVwiIHx8IHRhZyA9PT0gXCJhY3Rpb25cIiB8fCB0YWcgPT09IFwidGFza1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YWdzc3MucHVzaCh0YWcucmVwbGFjZShcIltbXCIsIFwiXCIpLnJlcGxhY2UoXCJdXVwiLCBcIlwiKSlcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0YWcgPT09IFwicHJlYmxvZ1wiIHx8IHRhZyA9PT0gXCJwcmVwcmVibG9nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudC5wdXNoKFwiW1tCbG9nIF8gUG9zdF1dXCIpXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnQucHVzaCh0YWcpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC8vbmV3IE5vdGljZShza2lwcy5qb2luKFwiXFxuXCIpKVxuICAgICAgICAgICAgICAgIGxldCBtb2RpZmllZExpbmUgPSBcIlwiXG4gICAgICAgICAgICAgICAgaWYgKHRhZ3Nzcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG1vZGlmaWVkTGluZSArPSBcInRhZ3NzczogXCIgKyB0YWdzc3Muam9pbihcIiBcIikgKyBcIlxcblwiXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBwYXJlbnRDb3VudCA9IDFcbiAgICAgICAgICAgICAgICBpZiAocGFyZW50Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdW5pcXVlUGFyZW50ID0gQXJyYXkuZnJvbShuZXcgU2V0KHBhcmVudCkpO1xuICAgICAgICAgICAgICAgICAgICB1bmlxdWVQYXJlbnQuZm9yRWFjaChwID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwLnN0YXJ0c1dpdGgoXCJbW1wiKSAmJiBwLmVuZHNXaXRoKFwiXV1cIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2RpZmllZExpbmUgKz0gXCJwYXJlbnRcIiArIHBhcmVudENvdW50ICsgXCI6IFxcXCJcIiArIHAucmVwbGFjZShcIjpcIiwgXCJfXCIpICsgXCJcXFwiXFxuXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kaWZpZWRMaW5lICs9IFwicGFyZW50XCIgKyBwYXJlbnRDb3VudCArIFwiOiBcXFwiW1tcIiArIHAucmVwbGFjZShcIjpcIiwgXCJfXCIpICsgXCJdXVxcXCJcXG5cIlxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50Q291bnQrK1xuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmbSArPSBtb2RpZmllZExpbmVcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZm0gKz0gKGxpbmUgKyBcIlxcblwiKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChoM0NvdW50ID49IDIpIHtcbiAgICAgICAgICAgIGMgKz0gKGxpbmUgKyBcIlxcblwiKVxuICAgICAgICB9XG4gICAgICAgIGlmIChsaW5lID09PSBcIi0tLVwiKSB7XG4gICAgICAgICAgICBoM0NvdW50Kys7XG4gICAgICAgIH1cbiAgICB9IFxuICAgIHRleHQgKz0gY29udGVudFxuICAgIGlmIChmbS5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRleHQgKz0gZm1cbiAgICB9XG4gICAgdGV4dCArPSBjXG4gICAgXG4gICAgcmV0dXJuIHRleHQucmVwbGFjZSgvXi0tLVxcbi0tLVxcbi9tLCBcIlwiKS5yZXBsYWNlKC9cXG4kLywgXCJcIilcbn1cbiovXG5cbmV4cG9ydCBmdW5jdGlvblx0dGlkeVVwRnJvbnRNYXR0ZXJPblZhbHVlKHZhbHVlOiBTdHJpbmcpIHtcbiAgICBjb25zdCB2YWx1ZXM6IHN0cmluZ1tdID0gdmFsdWUuc3BsaXQoXCJcXG5cIilcbiAgICBjb25zdCBsaW5lQ291bnQgPSB2YWx1ZXMubGVuZ3RoXG5cbiAgICBsZXQgZm0gPSBcIlwiXG4gICAgbGV0IGMgPSBcIlwiXG4gICAgbGV0IHRleHQgPSBcIlwiXG4gICAgbGV0IGgzQ291bnQgPSAwO1xuICAgIGxldCBjb250ZW50ID0gXCJcIlxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZUNvdW50OyBpKyspIHtcbiAgICAgICAgY29uc3QgbGluZSA9IHZhbHVlc1tpXVxuICAgICAgICBpZiAoaDNDb3VudCA9PSAwKSB7XG4gICAgICAgICAgICBjb250ZW50ICs9IChsaW5lICsgXCJcXG5cIilcbiAgICAgICAgfSBlbHNlIGlmIChoM0NvdW50ID09IDEpIHtcbiAgICAgICAgICAgIGlmICgvXmxpc3Q6IC8udGVzdChsaW5lKSkge1xuICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBsaXN0IGZpZWxkXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZtICs9IChsaW5lICsgXCJcXG5cIilcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICBpZiAoL150YWc6IFthLWNdXFwvW2Etel1cXC9bYS16XSQvLnRlc3QobGluZSkpIHtcbiAgICAgICAgICAgICAgICBmbSArPSAobGluZS5yZXBsYWNlKC9edGFnOiAvLCBcInRhZ3M6IFwiKSArIFwiXFxuXCIpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZtICs9IChsaW5lICsgXCJcXG5cIilcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICovXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGgzQ291bnQgPj0gMikge1xuICAgICAgICAgICAgYyArPSAobGluZSArIFwiXFxuXCIpXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxpbmUgPT09IFwiLS0tXCIpIHtcbiAgICAgICAgICAgIGgzQ291bnQrKztcbiAgICAgICAgfVxuICAgIH0gXG4gICAgdGV4dCArPSBjb250ZW50XG4gICAgaWYgKGZtLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGV4dCArPSBmbVxuICAgIH1cbiAgICB0ZXh0ICs9IGNcbiAgICBcbiAgICByZXR1cm4gdGV4dC5yZXBsYWNlKC9eLS0tXFxuLS0tXFxuL20sIFwiXCIpLnJlcGxhY2UoL1xcbiQvLCBcIlwiKVxufSIsICJpbXBvcnQgeyBFZGl0b3IgfSBmcm9tIFwib2JzaWRpYW5cIlxuXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlQ29udGVudEZyb21TdGFydE9mTm90ZVRvQ3Vyc29yKGVkaXRvcjogRWRpdG9yKSB7XG4gICAgY29uc3QgY3Vyc29yID0gZWRpdG9yLmdldEN1cnNvcigpXG4gICAgY29uc3QgbGluZSA9IGN1cnNvci5saW5lXG4gICAgY29uc3QgY2ggPSBjdXJzb3IuY2hcbiAgICBjb25zdCBsaW5lQ29udGVudCA9IGVkaXRvci5nZXRMaW5lKGxpbmUpXG4gICAgLy8gcmVtb3ZlIGNvbnRlbnQgZnJvbSBmaXJzdCBjaGFyYWN0ZXIgdG8gY2ggY2hhcmFjdGVyIG9mIGxpbmVDb250ZW50XG4gICAgbGV0IG5ld0NvbnRlbnQgPSBsaW5lQ29udGVudC5zdWJzdHJpbmcoY2gpXG4gICAgZm9yIChsZXQgaSA9IGxpbmUgKyAxOyBpIDwgZWRpdG9yLmxpbmVDb3VudCgpOyBpKyspIHtcbiAgICAgICAgbmV3Q29udGVudCArPSBcIlxcblwiICsgZWRpdG9yLmdldExpbmUoaSlcbiAgICB9XG4gICAgZWRpdG9yLnNldFZhbHVlKG5ld0NvbnRlbnQpXG4gICAgY3Vyc29yLmxpbmUgPSAwXG4gICAgY3Vyc29yLmNoID0gMFxuICAgIGVkaXRvci5zZXRDdXJzb3IoY3Vyc29yKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlQ29udGVudEZyb21DdXJzb3JUb0VuZE9mTm90ZShlZGl0b3I6IEVkaXRvcikge1xuICAgIGNvbnN0IGN1cnNvciA9IGVkaXRvci5nZXRDdXJzb3IoKVxuICAgIGNvbnN0IGxpbmUgPSBjdXJzb3IubGluZVxuICAgIGNvbnN0IGNoID0gY3Vyc29yLmNoXG4gICAgY29uc3QgbGluZUNvbnRlbnQgPSBlZGl0b3IuZ2V0TGluZShsaW5lKVxuICAgIGxldCBuZXdDb250ZW50ID0gXCJcIlxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZTsgaSsrKSB7XG4gICAgICAgIG5ld0NvbnRlbnQgKz0gZWRpdG9yLmdldExpbmUoaSkgKyBcIlxcblwiXG4gICAgfVxuICAgIG5ld0NvbnRlbnQgKz0gbGluZUNvbnRlbnQuc3Vic3RyaW5nKDAsIGNoKVxuICAgIGVkaXRvci5zZXRWYWx1ZShuZXdDb250ZW50KVxuICAgIGN1cnNvci5saW5lID0gbGluZVxuICAgIGN1cnNvci5jaCA9IGNoXG4gICAgZWRpdG9yLnNldEN1cnNvcihjdXJzb3IpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVDb250ZW50TGVmdFNhbWVMaW5lKGVkaXRvcjogRWRpdG9yKSB7XG4gICAgY29uc3QgY3Vyc29yID0gZWRpdG9yLmdldEN1cnNvcigpXG4gICAgY29uc3QgbGluZSA9IGN1cnNvci5saW5lXG4gICAgY29uc3QgY2ggPSBjdXJzb3IuY2hcbiAgICBjb25zdCBsaW5lQ29udGVudCA9IGVkaXRvci5nZXRMaW5lKGxpbmUpXG4gICAgLy8gcmVtb3ZlIGNvbnRlbnQgZnJvbSBmaXJzdCBjaGFyYWN0ZXIgdG8gY2ggY2hhcmFjdGVyIG9mIGxpbmVDb250ZW50XG4gICAgZWRpdG9yLnNldExpbmUobGluZSwgbGluZUNvbnRlbnQuc3Vic3RyaW5nKGNoKSlcbiAgICBjdXJzb3IuY2ggPSAwXG4gICAgZWRpdG9yLnNldEN1cnNvcihjdXJzb3IpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVDb250ZW50UmlnaHRTYW1lTGluZShlZGl0b3I6IEVkaXRvcikge1xuICAgIGNvbnN0IGN1cnNvciA9IGVkaXRvci5nZXRDdXJzb3IoKVxuICAgIGNvbnN0IGxpbmUgPSBjdXJzb3IubGluZVxuICAgIGNvbnN0IGNoID0gY3Vyc29yLmNoXG4gICAgY29uc3QgbGluZUNvbnRlbnQgPSBlZGl0b3IuZ2V0TGluZShsaW5lKVxuICAgIC8vIHJlbW92ZSBjb250ZW50IGZyb20gY2ggY2hhcmFjdGVyIHRvIGVuZCBvZiBsaW5lQ29udGVudFxuICAgIGVkaXRvci5zZXRMaW5lKGxpbmUsIGxpbmVDb250ZW50LnN1YnN0cmluZygwLCBjaCkpXG4gICAgY3Vyc29yLmNoID0gZWRpdG9yLmdldExpbmUobGluZSkubGVuZ3RoXG4gICAgZWRpdG9yLnNldEN1cnNvcihjdXJzb3IpXG59IiwgImltcG9ydCB7IEFwcCwgRWRpdG9yLCBGdXp6eVN1Z2dlc3RNb2RhbCwgRnV6enlNYXRjaCwgVEZpbGUgfSBmcm9tIFwib2JzaWRpYW5cIjtcbmltcG9ydCB7IHJlbW92ZUNvbnRlbnRGcm9tQ3Vyc29yVG9FbmRPZk5vdGUsIHJlbW92ZUNvbnRlbnRGcm9tU3RhcnRPZk5vdGVUb0N1cnNvciwgcmVtb3ZlQ29udGVudExlZnRTYW1lTGluZSwgcmVtb3ZlQ29udGVudFJpZ2h0U2FtZUxpbmUgfSBmcm9tIFwic2VsZnV0aWwvcmVtb3ZlQ29udGVudEZyb21DdXJzb3JcIjtcblxuZXhwb3J0IGNsYXNzIFJlbW92ZUNvbnRlbnRGcm9tQ3Vyc29yTW9kYWwgZXh0ZW5kcyBGdXp6eVN1Z2dlc3RNb2RhbDxzdHJpbmc+IHtcblxuICByZW1vdmVDb250ZW50TGVmdFNhbWVMaW5lIDogc3RyaW5nID0gXCJSZW1vdmUgY29udGVudCBsZWZ0IHNhbWUgbGluZVwiXG4gIHJlbW92ZUNvbnRlbnRSaWdodFNhbWVMaW5lIDogc3RyaW5nID0gXCJSZW1vdmUgY29udGVudCByaWdodCBzYW1lIGxpbmVcIlxuICByZW1vdmVDb250ZW50RnJvbVN0YXJ0T2ZOb3RlVG9DdXJzb3I6IHN0cmluZyA9IFwiUmVtb3ZlIGNvbnRlbnQgZnJvbSBzdGFydCBvZiBub3RlIHRvIGN1cnNvclwiXG4gIHJlbW92ZUNvbnRlbnRGcm9tQ3Vyc29yVG9FbmRPZk5vdGU6IHN0cmluZyA9IFwiUmVtb3ZlIGNvbnRlbnQgZnJvbSBjdXJzb3IgdG8gZW5kIG9mIG5vdGVcIlxuXG4gIG9wdGlvbnM6IHN0cmluZ1tdID0gW3RoaXMucmVtb3ZlQ29udGVudExlZnRTYW1lTGluZSwgdGhpcy5yZW1vdmVDb250ZW50UmlnaHRTYW1lTGluZSwgdGhpcy5yZW1vdmVDb250ZW50RnJvbVN0YXJ0T2ZOb3RlVG9DdXJzb3IsIHRoaXMucmVtb3ZlQ29udGVudEZyb21DdXJzb3JUb0VuZE9mTm90ZV1cbiAgZWRpdG9yOiBFZGl0b3I7XG5cbiAgY29uc3RydWN0b3IoYXBwOiBBcHAsIGVkaXRvcjogRWRpdG9yKVxuICB7XG4gICAgc3VwZXIoYXBwKVxuICAgIHRoaXMuZWRpdG9yID0gZWRpdG9yXG4gIH1cblxuICBnZXRJdGVtcygpOiBzdHJpbmdbXSB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucztcbiAgfVxuXG4gIGdldEl0ZW1UZXh0KGl0ZW06IHN0cmluZyk6IHN0cmluZyB7XG4gICAgcmV0dXJuIGl0ZW07XG4gIH1cblxuICAvLyBSZW5kZXJzIGVhY2ggc3VnZ2VzdGlvbiBpdGVtLlxuICByZW5kZXJTdWdnZXN0aW9uKGk6IEZ1enp5TWF0Y2g8c3RyaW5nPiwgZWw6IEhUTUxFbGVtZW50KSB7XG4gICAgY29uc3QgaXRlbSA9IGkuaXRlbVxuICAgIGVsLmNyZWF0ZUVsKFwiZGl2XCIsIHsgdGV4dDogaXRlbSB9KTtcbiAgfVxuXG4gIC8vIFBlcmZvcm0gYWN0aW9uIG9uIHRoZSBzZWxlY3RlZCBzdWdnZXN0aW9uLlxuICBhc3luYyBvbkNob29zZUl0ZW0oc2VsZWN0ZWRDb250ZW50OiBzdHJpbmcsIGV2dDogTW91c2VFdmVudCB8IEtleWJvYXJkRXZlbnQpIHtcbiAgICBjb25zdCBjaG9vc2VuT3B0aW9uID0gc2VsZWN0ZWRDb250ZW50XG4gICAgaWYgKGNob29zZW5PcHRpb24gPT09IHRoaXMucmVtb3ZlQ29udGVudExlZnRTYW1lTGluZSkge1xuICAgICAgcmVtb3ZlQ29udGVudExlZnRTYW1lTGluZSh0aGlzLmVkaXRvcilcbiAgICB9IGVsc2UgaWYgKGNob29zZW5PcHRpb24gPT09IHRoaXMucmVtb3ZlQ29udGVudFJpZ2h0U2FtZUxpbmUpIHtcbiAgICAgIHJlbW92ZUNvbnRlbnRSaWdodFNhbWVMaW5lKHRoaXMuZWRpdG9yKVxuICAgIH0gZWxzZSBpZiAoY2hvb3Nlbk9wdGlvbiA9PT0gdGhpcy5yZW1vdmVDb250ZW50RnJvbVN0YXJ0T2ZOb3RlVG9DdXJzb3IpIHtcbiAgICAgIHJlbW92ZUNvbnRlbnRGcm9tU3RhcnRPZk5vdGVUb0N1cnNvcih0aGlzLmVkaXRvcilcbiAgICB9IGVsc2UgaWYgKGNob29zZW5PcHRpb24gPT09IHRoaXMucmVtb3ZlQ29udGVudEZyb21DdXJzb3JUb0VuZE9mTm90ZSkge1xuICAgICAgcmVtb3ZlQ29udGVudEZyb21DdXJzb3JUb0VuZE9mTm90ZSh0aGlzLmVkaXRvcilcbiAgICB9XG4gIH1cbn0iLCAiaW1wb3J0IHsgQXBwLCBFZGl0b3IsIEZ1enp5U3VnZ2VzdE1vZGFsLCBGdXp6eU1hdGNoLCBURmlsZSB9IGZyb20gXCJvYnNpZGlhblwiO1xuXG5leHBvcnQgY2xhc3MgRmluZFJlcGxhY2VNb2RhbCBleHRlbmRzIEZ1enp5U3VnZ2VzdE1vZGFsPHN0cmluZz4ge1xuXG4gIGZpbmQgOiBzdHJpbmcgPSBcImZpbmRcIlxuICByZXBsYWNlOiBzdHJpbmcgPSBcInJlcGxhY2VcIlxuICBvcHRpb25zOiBzdHJpbmdbXSA9IFt0aGlzLmZpbmQsIHRoaXMucmVwbGFjZV1cblxuICBjb25zdHJ1Y3RvcihhcHA6IEFwcClcbiAge1xuICAgIHN1cGVyKGFwcClcbiAgfVxuXG4gIGdldEl0ZW1zKCk6IHN0cmluZ1tdIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zO1xuICB9XG5cbiAgZ2V0SXRlbVRleHQoaXRlbTogc3RyaW5nKTogc3RyaW5nIHtcbiAgICByZXR1cm4gaXRlbTtcbiAgfVxuXG4gIC8vIFJlbmRlcnMgZWFjaCBzdWdnZXN0aW9uIGl0ZW0uXG4gIHJlbmRlclN1Z2dlc3Rpb24oaTogRnV6enlNYXRjaDxzdHJpbmc+LCBlbDogSFRNTEVsZW1lbnQpIHtcbiAgICBjb25zdCBpdGVtID0gaS5pdGVtXG4gICAgZWwuY3JlYXRlRWwoXCJkaXZcIiwgeyB0ZXh0OiBpdGVtIH0pO1xuICB9XG5cbiAgLy8gUGVyZm9ybSBhY3Rpb24gb24gdGhlIHNlbGVjdGVkIHN1Z2dlc3Rpb24uXG4gIGFzeW5jIG9uQ2hvb3NlSXRlbShzZWxlY3RlZENvbnRlbnQ6IHN0cmluZywgZXZ0OiBNb3VzZUV2ZW50IHwgS2V5Ym9hcmRFdmVudCkge1xuICAgIGNvbnN0IGNob29zZW5PcHRpb24gPSBzZWxlY3RlZENvbnRlbnRcbiAgICBpZiAoY2hvb3Nlbk9wdGlvbiA9PT0gdGhpcy5maW5kKVxuICAgIHtcbiAgICAgIC8vIEB0cy1pZ25vcmVcblx0XHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtY2FsbFxuXHRcdFx0XHR0aGlzLmFwcC5jb21tYW5kcy5leGVjdXRlQ29tbWFuZEJ5SWQoXCJlZGl0b3I6b3Blbi1zZWFyY2hcIilcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQHRzLWlnbm9yZVxuXHRcdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1jYWxsXG5cdFx0XHRcdHRoaXMuYXBwLmNvbW1hbmRzLmV4ZWN1dGVDb21tYW5kQnlJZChcIm9ic2lkaWFuLXJlZ2V4LXJlcGxhY2U6b2JzaWRpYW4tcmVnZXgtcmVwbGFjZVwiKVxuICAgIH1cbiAgfVxufSIsICJpbXBvcnQgeyBBZGRUZXh0VG9Ob3Rlc0Zyb21TcGVjaWZpY1RhZ01vZGFsIH0gZnJvbSBcImFkZFRleHRUb05vdGVzRnJvbVNwZWNpZmljVGFnTW9kYWxcIjtcbmltcG9ydCB7IEFwcCwgRnV6enlTdWdnZXN0TW9kYWwsIEZ1enp5TWF0Y2gsIGdldEFsbFRhZ3MsIFRGaWxlLCBFZGl0b3IsIE1hcmtkb3duVmlldywgTm90aWNlIH0gZnJvbSBcIm9ic2lkaWFuXCI7XG5pbXBvcnQgeyBhZGRUZXh0VG9Ob3RlcyB9IGZyb20gXCJzZWxmdXRpbC9hZGRsaW5rdG9ub3Rlc1wiO1xuaW1wb3J0IHsgZmlsZXNXaGVyZVRhZ0lzVXNlZCB9IGZyb20gXCJzZWxmdXRpbC9maW5kTm90ZXNGcm9tVGFnXCI7XG5pbXBvcnQgeyBnZXRBbGxOb3RlVGFncyB9IGZyb20gXCJzZWxmdXRpbC9nZXRBbGxOb3RlVGFnc1wiO1xuaW1wb3J0IHsgZ2V0QWxsTm90ZXMsIGdldFJlY2VudE5vdGVzIH0gZnJvbSBcInNlbGZ1dGlsL2dldFJlY2VudE5vdGVzXCI7XG5cbmV4cG9ydCBjbGFzcyBRdWVyeU9ycGhhbk5vdGVzQnlUYWdNb2RhbCBleHRlbmRzIEZ1enp5U3VnZ2VzdE1vZGFsPHN0cmluZz4ge1xuXG4gIGVkaXRvcjogRWRpdG9yXG4gIHZpZXc6IE1hcmtkb3duVmlld1xuXG4gIGNvbnN0cnVjdG9yKGFwcDogQXBwLCBlZGl0b3I6IEVkaXRvciwgdmlldzogTWFya2Rvd25WaWV3KVxuICB7XG4gICAgc3VwZXIoYXBwKVxuICAgIHRoaXMuc2V0UGxhY2Vob2xkZXIoYFdoaWNoIG5vdGVzIHdpdGggdGFncyBkbyB5b3Ugd2FudCB0byBzZWFyY2ggb3JwaGFuP2ApXG4gICAgdGhpcy5zZXRJbnN0cnVjdGlvbnMoW1xuICAgICAge1xuICAgICAgICBjb21tYW5kOiBcIlwiLFxuICAgICAgICBwdXJwb3NlOiBgV2hpY2ggbm90ZXMgd2l0aCB0YWdzIGRvIHlvdSB3YW50IHRvIHNlYXJjaCBvcnBoYW4/YFxuICAgICAgfVxuICAgIF0pO1xuICAgIHRoaXMuZWRpdG9yID0gZWRpdG9yXG4gICAgdGhpcy52aWV3ID0gdmlld1xuICB9XG5cbiAgZ2V0SXRlbXMoKSA6IHN0cmluZ1tdIHtcblx0XHRjb25zdCBsID0gWy4uLmdldEFsbE5vdGVUYWdzKHRoaXMuYXBwKS5tYXAocyA9PiBzLnJlcGxhY2UoL14jLywgXCJAXCIpKV07XG4gICAgLy8gcmVtb3ZlIGR1cGxpY2F0ZSBmb3IgbFxuICAgIHJldHVybiBsLmZpbHRlcigoaXRlbSwgaW5kZXgpID0+IGwuaW5kZXhPZihpdGVtKSA9PT0gaW5kZXgpO1xuICB9XG5cbiAgZ2V0SXRlbVRleHQodmFsdWU6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgLy8gUmVuZGVycyBlYWNoIHN1Z2dlc3Rpb24gaXRlbS5cbiAgcmVuZGVyU3VnZ2VzdGlvbih2YWx1ZTogRnV6enlNYXRjaDxzdHJpbmc+LCBlbDogSFRNTEVsZW1lbnQpIHtcbiAgICBjb25zdCBpdGVtID0gdmFsdWUuaXRlbVxuICAgIGVsLmNyZWF0ZUVsKFwiZGl2XCIsIHsgdGV4dDogaXRlbSB9KVxuICB9XG5cbiAgLy8gUGVyZm9ybSBhY3Rpb24gb24gdGhlIHNlbGVjdGVkIHN1Z2dlc3Rpb24uXG4gIGFzeW5jIG9uQ2hvb3NlSXRlbShjaG9vc2VuVmFsdWU6IHN0cmluZywgZXZ0OiBNb3VzZUV2ZW50IHwgS2V5Ym9hcmRFdmVudCkge1xuICAgIGNvbnNvbGUubG9nKHRoaXMudmlldy5maWxlLnBhdGgpXG4gICAgY29uc3QgcXVlcnlNZCA9IFwiSS9TZWxmIFF1ZXJ5Lm1kXCJcbiAgICBpZiAodGhpcy52aWV3LmZpbGUucGF0aCA9PT0gcXVlcnlNZCkge1xuICAgICAgbmV3IE5vdGljZShcIkNoZWNraW5nLi4uIG1heSBuZWVkIHNvbWUgdGltZVwiKVxuICAgICAgY29uc3QgdGFnID0gIGNob29zZW5WYWx1ZS5yZXBsYWNlKC9eQC8sIFwiI1wiKVxuICAgICAgY29uc3QgZmlsZVBhdGhzID0gZmlsZXNXaGVyZVRhZ0lzVXNlZCh0YWcpXG4gICAgICBsZXQgcmVzdWx0ID0gXCIjIyBPcnBoYW4gbm90ZXMgZm9yIHRhZyBgXCIgKyB0YWcgKyBcImBcXG5cIlxuICAgICAgZm9yIChjb25zdCBmaWxlUGF0aCBvZiBmaWxlUGF0aHMpIHtcbiAgICAgICAgY29uc29sZS5sb2coYENoZWNraW5nIGJhY2tsaW5rcyBmb3IgJHtmaWxlUGF0aH1gKVxuICAgICAgICBjb25zdCB0RmlsZTogVEZpbGUgPSB0aGlzLmFwcC52YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgoZmlsZVBhdGgpIGFzIFRGaWxlXG4gICAgICAgIGNvbnN0IGJhY2tsaW5rcyA9IHRoaXMuYXBwLm1ldGFkYXRhQ2FjaGUuZ2V0QmFja2xpbmtzRm9yRmlsZSh0RmlsZSlcbiAgICAgICAgY29uc29sZS5sb2coYmFja2xpbmtzKVxuICAgICAgICBjb25zb2xlLmxvZyhiYWNrbGlua3MuZGF0YSlcbiAgICAgICAgaWYgKCFiYWNrbGlua3MgfHwgIWJhY2tsaW5rcy5kYXRhIHx8IE9iamVjdC5rZXlzKGJhY2tsaW5rcy5kYXRhKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhgTm8gYmFja2xpbmtzIGZvciAke3RGaWxlLnBhdGh9YClcbiAgICAgICAgICByZXN1bHQgKz0gXCJcXG5cIiArIFwiLSBbW1wiICsgdEZpbGUuYmFzZW5hbWUgKyBcIl1dXCJcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyByZW1vdmUga2V5IFwiYWFhXCIgZnJvbSBiYWNrbGlua3MuZGF0YVxuICAgICAgICAgIGRlbGV0ZSBiYWNrbGlua3MuZGF0YVtxdWVyeU1kXVxuICAgICAgICAgIGlmIChPYmplY3Qua2V5cyhiYWNrbGlua3MuZGF0YSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgTm8gYmFja2xpbmtzIGZvciAke3RGaWxlLnBhdGh9YClcbiAgICAgICAgICAgIHJlc3VsdCArPSBcIlxcblwiICsgXCItIFtbXCIgKyB0RmlsZS5iYXNlbmFtZSArIFwiXV1cIlxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgSGFzIGJhY2tsaW5rcyBmb3IgJHt0RmlsZS5wYXRofWApXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLmVkaXRvci5zZXRWYWx1ZShyZXN1bHQpXG4gICAgICBuZXcgTm90aWNlKFwiVXBkYXRlZCBvcnBoYW5cIilcbiAgICB9IGVsc2Uge1xuICAgICAgbmV3IE5vdGljZShcIlBsZWFzZSBnbyB0byAnXCIgKyBxdWVyeU1kICsgXCInIHRvIHJ1biB0aGlzIGFjdGlv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QSxFQUNmO0FBQUEsRUFDQTtBQUFBLElBQ0UsTUFBTTtBQUFBLElBQ04sYUFBYTtBQUFBLEVBQ2Y7QUFBQSxFQUNBO0FBQUEsSUFDRSxNQUFNO0FBQUEsSUFDTixhQUFhO0FBQUEsRUFDZjtBQUFBLEVBQ0E7QUFBQSxJQUNFLE1BQU07QUFBQSxJQUNOLGFBQWE7QUFBQSxFQUNmO0FBQUEsRUFDQTtBQUFBLElBQ0UsTUFBTTtBQUFBLElBQ04sYUFBYTtBQUFBLEVBQ2Y7QUFBQSxFQUNBO0FBQUEsSUFDRSxNQUFNO0FBQUEsSUFDTixhQUFhO0FBQUEsRUFDZjtBQUFBLEVBQ0E7QUFBQSxJQUNFLE1BQU07QUFBQSxJQUNOLGFBQWE7QUFBQSxFQUNmO0FBQUEsRUFDQTtBQUFBLElBQ0UsTUFBTTtBQUFBLElBQ04sYUFBYTtBQUFBLEVBQ2Y7QUFBQSxFQUNBO0FBQUEsSUFDRSxNQUFNO0FBQUEsSUFDTixhQUFhO0FBQUEsRUFDZjtBQUFBLEVBQ0E7QUFBQSxJQUNFLE1BQU07QUFBQSxJQUNOLGFBQWE7QUFBQSxFQUNmO0FBQUEsRUFDQTtBQUFBLElBQ0UsTUFBTTtBQUFBLElBQ04sYUFBYTtBQUFBLEVBQ2Y7QUFBQSxFQUNBO0FBQUEsSUFDRSxNQUFNO0FBQUEsSUFDTixhQUFhO0FBQUEsRUFDZjtBQUFBLEVBQ0E7QUFBQSxJQUNFLE1BQU07QUFBQSxJQUNOLGFBQWE7QUFBQSxFQUNmO0FBQUEsRUFDQTtBQUFBLElBQ0UsTUFBTTtBQUFBLElBQ04sYUFBYTtBQUFBLEVBQ2Y7QUFBQSxFQUNBO0FBQUEsSUFDRSxNQUFNO0FBQUEsSUFDTixhQUFhO0FBQUEsRUFDZjtBQUFBLEVBQ0E7QUFBQSxJQUNFLE1BQU07QUFBQSxJQUNOLGFBQWE7QUFBQSxFQUNmO0FBQUEsRUFDQTtBQUFBLElBQ0UsTUFBTTtBQUFBLElBQ04sYUFBYTtBQUFBLEVBQ2Y7QUFBQSxFQUNBO0FBQUEsSUFDRSxNQUFNO0FBQUEsSUFDTixhQUFhO0FBQUEsRUFDZjtBQUFBLEVBQ0E7QUFBQSxJQUNFLE1BQU07QUFBQSxJQUNOLGFBQWE7QUFBQSxFQUNmO0FBQUEsRUFDQTtBQUFBLElBQ0UsTUFBTTtBQUFBLElBQ04sYUFBYTtBQUFBLEVBQ2Y7QUFBQSxFQUNBO0FBQUEsSUFDRSxNQUFNO0FBQUEsSUFDTixhQUFhO0FBQUEsRUFDZjtBQUFBLEVBQ0E7QUFBQSxJQUNFLE1BQU07QUFBQSxJQUNOLGFBQWE7QUFBQSxFQUNmO0FBQUEsRUFDQTtBQUFBLElBQ0UsTUFBTTtBQUFBLElBQ04sYUFBYTtBQUFBLEVBQ2Y7QUFBQSxFQUNBO0FBQUEsSUFDRSxNQUFNO0FBQUEsSUFDTixhQUFhO0FBQUEsRUFDZjtBQUFBLEVBQ0E7QUFBQSxJQUNFLE1BQU07QUFBQSxJQUNOLGFBQWE7QUFBQSxFQUNmO0FBQUEsRUFDQTtBQUFBLElBQ0UsTUFBTTtBQUFBLElBQ04sYUFBYTtBQUFBLEVBQ2Y7QUFBQSxFQUNBO0FBQUEsSUFDRSxNQUFNO0FBQUEsSUFDTixhQUFhO0FBQUEsRUFDZjtBQUFBLEVBQ0E7QUFBQSxJQUNFLE1BQU07QUFBQSxJQUNOLGFBQWE7QUFBQSxFQUNmO0FBQUEsRUFDQTtBQUFBLElBQ0UsTUFBTTtBQUFBLElBQ04sYUFBYTtBQUFBLEVBQ2Y7QUFBQSxFQUNBO0FBQUEsSUFDRSxNQUFNO0FBQUEsSUFDTixhQUFhO0FBQUEsRUFDZjtBQUFBLEVBQ0E7QUFBQSxJQUNFLE1BQU07QUFBQSxJQUNOLGFBQWE7QUFBQSxFQUNmO0FBQUEsRUFDQTtBQUFBLElBQ0UsTUFBTTtBQUFBLElBQ04sYUFBYTtBQUFBLEVBQ2Y7QUFBQSxFQUNBO0FBQUEsSUFDRSxNQUFNO0FBQUEsSUFDTixhQUFhO0FBQUEsRUFDZjtBQUFBLEVBQ0E7QUFBQSxJQUNFLE1BQU07QUFBQSxJQUNOLGFBQWE7QUFBQSxFQUNmO0FBQUEsRUFDQTtBQUFBLElBQ0UsTUFBTTtBQUFBLElBQ04sYUFBYTtBQUFBLEVBQ2Y7QUFBQSxFQUNBO0FBQUEsSUFDRSxNQUFNO0FBQUEsSUFDTixhQUFhO0FBQUEsRUFDZjtBQUFBLEVBQ0E7QUFBQSxJQUNFLE1BQU07QUFBQSxJQUNOLGFBQWE7QUFB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QjtBQUN0QyxVQUFNLFFBQVEsaUJBQWlCLFFBQVEsU0FBUyxDQUFDO0FBQ2pELFFBQUksUUFBUSxJQUFJO0FBQ2YsdUJBQWlCLE9BQU8sT0FBTyxDQUFDO0FBQUEsSUFDakM7QUFDQSxRQUFJLFFBQVEsU0FBUyxHQUFHO0FBQ3ZCLHVCQUFpQixLQUFLLE9BQU87QUFBQSxJQUM5QjtBQUFBLEVBQ0Q7QUFBQSxFQUVBLFdBQVc7QUFBQSxFQUVYO0FBQUEsRUFFQSxNQUFNLGVBQWU7QUFDcEIsU0FBSyxXQUFXLE9BQU8sT0FBTyxDQUFDLEdBQUcsa0JBQWtCLE1BQU0sS0FBSyxTQUFTLENBQUM7QUFBQSxFQUMxRTtBQUFBLEVBRUEsTUFBTSxlQUFlO0FBQ3BCLFVBQU0sS0FBSyxTQUFTLEtBQUssUUFBUTtBQUFBLEVBQ2xDO0FBQ0Q7QUFFQSxJQUFNLG1CQUFOLGNBQStCLG1DQUFpQjtBQUFBLEVBRy9DLFlBQVlILE1BQVUsUUFBa0I7QUFDdkMsVUFBTUEsTUFBSyxNQUFNO0FBQ2pCLFNBQUssU0FBUztBQUFBLEVBQ2Y7QUFBQSxFQUVBLFVBQWdCO0FBQ2YsVUFBTSxFQUFDLFlBQVcsSUFBSTtBQUV0QixnQkFBWSxNQUFNO0FBRWxCLGdCQUFZLFNBQVMsTUFBTSxFQUFDLE1BQU0sa0NBQWlDLENBQUM7QUFFcEUsUUFBSSwwQkFBUSxXQUFXLEVBQ3JCLFFBQVEsWUFBWSxFQUNwQixRQUFRLGVBQWdCLEVBQ3hCLFFBQVEsVUFBUSxLQUNmLGVBQWUsbUJBQW1CLEVBQ2xDLFNBQVMsS0FBSyxPQUFPLFNBQVMsU0FBUyxFQUN2QyxTQUFTLE9BQU8sVUFBVTtBQUMxQixjQUFRLElBQUksYUFBYSxLQUFLO0FBQzlCLFdBQUssT0FBTyxTQUFTLFlBQVk7QUFDakMsWUFBTSxLQUFLLE9BQU8sYUFBYTtBQUFBLElBQ2hDLENBQUMsQ0FBQztBQUFBLEVBQ0w7QUFDRDsiLAogICJuYW1lcyI6IFsibW9kdWxlIiwgIm1hcCIsICJmb3JtYXQiLCAibG9jYWxlIiwgInRvIiwgImZyb20iLCAid2FybiIsICJzZXQiLCAibm93IiwgInNpZ24iLCAidG9rZW4iLCAib3JkaW5hbCIsICJpIiwgInN0cmluZyIsICJkaWZmIiwgImxvY2FsZURhdGEiLCAiaG91cnMiLCAibWludXRlcyIsICJ0b2tlbnMiLCAibWVyaWRpZW0iLCAieWVhcnMiLCAibW9udGhzIiwgIndlZWtzIiwgImRheXMiLCAic2Vjb25kcyIsICJtaWxsaXNlY29uZHMiLCAib2Zmc2V0IiwgInRocmVzaG9sZHMiLCAiaW1wb3J0X29ic2lkaWFuIiwgImltcG9ydF9vYnNpZGlhbiIsICJpc0FsaWFzIiwgInRhZyIsICJyZXMiLCAibWFwIiwgInNjaGVtYSIsICJub2RlIiwgInNjaGVtYSIsICJpIiwgImVuZCIsICJ0YWciLCAidGFnIiwgIm1hcCIsICJ2YWx1ZSIsICJzY2hlbWEiLCAic3RyaW5naWZ5IiwgImNvbW1lbnQiLCAic3RyIiwgInNjaGVtYSIsICJtYXAiLCAic2NoZW1hIiwgIm1hcCIsICJzY2hlbWEiLCAic2VxIiwgInNjaGVtYSIsICJzZXEiLCAidGFnIiwgImludElkZW50aWZ5IiwgInNjaGVtYSIsICJzZXEiLCAic2NoZW1hIiwgInBhaXJzIiwgIm1hcCIsICJzZXEiLCAicGFpcnMiLCAic2NoZW1hIiwgIm9tYXAiLCAiZmxvYXROYU4iLCAiZmxvYXRFeHAiLCAiZmxvYXQiLCAiaW50SWRlbnRpZnkiLCAiaW50UmVzb2x2ZSIsICJuIiwgImludFN0cmluZ2lmeSIsICJpbnRPY3QiLCAiaW50IiwgImludEhleCIsICJzY2hlbWEiLCAibWFwIiwgInNldCIsICJyZXMiLCAic2NoZW1hIiwgImludE9jdCIsICJpbnQiLCAiaW50SGV4IiwgImZsb2F0TmFOIiwgImZsb2F0RXhwIiwgImZsb2F0IiwgInNjaGVtYSIsICJ0YWciLCAic2NoZW1hIiwgInRhZyIsICJyZXMiLCAidGFnIiwgImNvbXBvc2VOb2RlIiwgImNvbXBvc2VFbXB0eU5vZGUiLCAibWFwIiwgImNvbXBvc2VOb2RlIiwgImNvbXBvc2VFbXB0eU5vZGUiLCAic2VxIiwgImNvbXBvc2VOb2RlIiwgImNvbXBvc2VFbXB0eU5vZGUiLCAiaXNNYXAiLCAibWFwIiwgIkNOIiwgInRhZyIsICJ2YWx1ZSIsICJlbmQiLCAidGFnIiwgInNjaGVtYSIsICJ0YWciLCAiU0NBTEFSIiwgImlzQ29sbGVjdGlvbiIsICJpc1NjYWxhciIsICJzdHJpbmdpZnkiLCAidmlzaXQiLCAic3RyaW5naWZ5IiwgIkJSRUFLIiwgIlNLSVAiLCAiUkVNT1ZFIiwgInZpc2l0IiwgIl92aXNpdCIsICJTQ0FMQVIiLCAiaXNDb2xsZWN0aW9uIiwgImlzU2NhbGFyIiwgImNoIiwgIlNDQUxBUiIsICJtYXAiLCAic2VxIiwgImFwcCIsICJoYXNGcm9udE1hdHRlciIsICJpc0FsaWFzIiwgInRhZyIsICJhcHAiLCAibW9tZW50IiwgImFwcCIsICJpbXBvcnRfb2JzaWRpYW4iLCAiaW1wb3J0X29ic2lkaWFuIiwgIkFMTF9UWVBFUyIsICJhcHAiLCAiaW1wb3J0X29ic2lkaWFuIiwgIkFMTF9UWVBFUyIsICJhcHAiLCAiaW1wb3J0X29ic2lkaWFuIiwgIkFMTF9UWVBFUyIsICJhcHAiLCAiaW1wb3J0X29ic2lkaWFuIiwgIkFMTF9UWVBFUyIsICJhcHAiLCAibm90ZSIsICJpbXBvcnRfb2JzaWRpYW4iLCAiYXBwIiwgImltcG9ydF9vYnNpZGlhbiIsICJhcHAiLCAiaW1wb3J0X29ic2lkaWFuIiwgImFwcCIsICJ2YXVsdCIsICJpbXBvcnRfb2JzaWRpYW4iLCAiYXBwIiwgImltcG9ydF9vYnNpZGlhbiIsICJpbXBvcnRfb2JzaWRpYW4iLCAiYXBwIiwgInRhZyIsICJhcHAiLCAiaW1wb3J0X29ic2lkaWFuIiwgImltcG9ydF9vYnNpZGlhbiIsICJpbXBvcnRfb2JzaWRpYW4iLCAiYXBwIiwgImltcG9ydF9vYnNpZGlhbiIsICJ0YWciLCAiYXBwIiwgImltcG9ydF9vYnNpZGlhbiIsICJhcHAiLCAiYXBwIiwgImltcG9ydF9vYnNpZGlhbiIsICJCQUNLX1RPX1NFTEVDVF9UQUciLCAiYXBwIiwgImltcG9ydF9vYnNpZGlhbiIsICJhcHAiLCAiaW1wb3J0X29ic2lkaWFuIiwgImFwcCIsICJpbXBvcnRfb2JzaWRpYW4iLCAiYXBwIiwgImltcG9ydF9vYnNpZGlhbiIsICJhcHAiLCAidGFnIiwgInVucmVzb2x2ZWRMaW5rcyIsICJsaW5lQ29udGVudCIsICJpIiwgInRhZyIsICJsaW5lIiwgImFwcCIsICJoZWFkZXJJY29uIiwgIm1vbWVudCIsICJjdXJzb3IiXQp9Cg==
