/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/moment/moment.js
var require_moment = __commonJS({
  "node_modules/moment/moment.js"(exports, module2) {
    (function(global, factory) {
      typeof exports === "object" && typeof module2 !== "undefined" ? module2.exports = factory() : typeof define === "function" && define.amd ? define(factory) : global.moment = factory();
    })(exports, function() {
      "use strict";
      var hookCallback;
      function hooks() {
        return hookCallback.apply(null, arguments);
      }
      function setHookCallback(callback) {
        hookCallback = callback;
      }
      function isArray(input) {
        return input instanceof Array || Object.prototype.toString.call(input) === "[object Array]";
      }
      function isObject(input) {
        return input != null && Object.prototype.toString.call(input) === "[object Object]";
      }
      function hasOwnProp(a, b) {
        return Object.prototype.hasOwnProperty.call(a, b);
      }
      function isObjectEmpty(obj) {
        if (Object.getOwnPropertyNames) {
          return Object.getOwnPropertyNames(obj).length === 0;
        } else {
          var k;
          for (k in obj) {
            if (hasOwnProp(obj, k)) {
              return false;
            }
          }
          return true;
        }
      }
      function isUndefined(input) {
        return input === void 0;
      }
      function isNumber(input) {
        return typeof input === "number" || Object.prototype.toString.call(input) === "[object Number]";
      }
      function isDate(input) {
        return input instanceof Date || Object.prototype.toString.call(input) === "[object Date]";
      }
      function map2(arr, fn) {
        var res = [], i;
        for (i = 0; i < arr.length; ++i) {
          res.push(fn(arr[i], i));
        }
        return res;
      }
      function extend(a, b) {
        for (var i in b) {
          if (hasOwnProp(b, i)) {
            a[i] = b[i];
          }
        }
        if (hasOwnProp(b, "toString")) {
          a.toString = b.toString;
        }
        if (hasOwnProp(b, "valueOf")) {
          a.valueOf = b.valueOf;
        }
        return a;
      }
      function createUTC(input, format2, locale2, strict) {
        return createLocalOrUTC(input, format2, locale2, strict, true).utc();
      }
      function defaultParsingFlags() {
        return {
          empty: false,
          unusedTokens: [],
          unusedInput: [],
          overflow: -2,
          charsLeftOver: 0,
          nullInput: false,
          invalidEra: null,
          invalidMonth: null,
          invalidFormat: false,
          userInvalidated: false,
          iso: false,
          parsedDateParts: [],
          era: null,
          meridiem: null,
          rfc2822: false,
          weekdayMismatch: false
        };
      }
      function getParsingFlags(m) {
        if (m._pf == null) {
          m._pf = defaultParsingFlags();
        }
        return m._pf;
      }
      var some;
      if (Array.prototype.some) {
        some = Array.prototype.some;
      } else {
        some = function(fun) {
          var t = Object(this), len = t.length >>> 0, i;
          for (i = 0; i < len; i++) {
            if (i in t && fun.call(this, t[i], i, t)) {
              return true;
            }
          }
          return false;
        };
      }
      function isValid(m) {
        if (m._isValid == null) {
          var flags = getParsingFlags(m), parsedParts = some.call(flags.parsedDateParts, function(i) {
            return i != null;
          }), isNowValid = !isNaN(m._d.getTime()) && flags.overflow < 0 && !flags.empty && !flags.invalidEra && !flags.invalidMonth && !flags.invalidWeekday && !flags.weekdayMismatch && !flags.nullInput && !flags.invalidFormat && !flags.userInvalidated && (!flags.meridiem || flags.meridiem && parsedParts);
          if (m._strict) {
            isNowValid = isNowValid && flags.charsLeftOver === 0 && flags.unusedTokens.length === 0 && flags.bigHour === void 0;
          }
          if (Object.isFrozen == null || !Object.isFrozen(m)) {
            m._isValid = isNowValid;
          } else {
            return isNowValid;
          }
        }
        return m._isValid;
      }
      function createInvalid(flags) {
        var m = createUTC(NaN);
        if (flags != null) {
          extend(getParsingFlags(m), flags);
        } else {
          getParsingFlags(m).userInvalidated = true;
        }
        return m;
      }
      var momentProperties = hooks.momentProperties = [], updateInProgress = false;
      function copyConfig(to2, from2) {
        var i, prop, val;
        if (!isUndefined(from2._isAMomentObject)) {
          to2._isAMomentObject = from2._isAMomentObject;
        }
        if (!isUndefined(from2._i)) {
          to2._i = from2._i;
        }
        if (!isUndefined(from2._f)) {
          to2._f = from2._f;
        }
        if (!isUndefined(from2._l)) {
          to2._l = from2._l;
        }
        if (!isUndefined(from2._strict)) {
          to2._strict = from2._strict;
        }
        if (!isUndefined(from2._tzm)) {
          to2._tzm = from2._tzm;
        }
        if (!isUndefined(from2._isUTC)) {
          to2._isUTC = from2._isUTC;
        }
        if (!isUndefined(from2._offset)) {
          to2._offset = from2._offset;
        }
        if (!isUndefined(from2._pf)) {
          to2._pf = getParsingFlags(from2);
        }
        if (!isUndefined(from2._locale)) {
          to2._locale = from2._locale;
        }
        if (momentProperties.length > 0) {
          for (i = 0; i < momentProperties.length; i++) {
            prop = momentProperties[i];
            val = from2[prop];
            if (!isUndefined(val)) {
              to2[prop] = val;
            }
          }
        }
        return to2;
      }
      function Moment(config) {
        copyConfig(this, config);
        this._d = new Date(config._d != null ? config._d.getTime() : NaN);
        if (!this.isValid()) {
          this._d = new Date(NaN);
        }
        if (updateInProgress === false) {
          updateInProgress = true;
          hooks.updateOffset(this);
          updateInProgress = false;
        }
      }
      function isMoment(obj) {
        return obj instanceof Moment || obj != null && obj._isAMomentObject != null;
      }
      function warn2(msg) {
        if (hooks.suppressDeprecationWarnings === false && typeof console !== "undefined" && console.warn) {
          console.warn("Deprecation warning: " + msg);
        }
      }
      function deprecate(msg, fn) {
        var firstTime = true;
        return extend(function() {
          if (hooks.deprecationHandler != null) {
            hooks.deprecationHandler(null, msg);
          }
          if (firstTime) {
            var args = [], arg, i, key;
            for (i = 0; i < arguments.length; i++) {
              arg = "";
              if (typeof arguments[i] === "object") {
                arg += "\n[" + i + "] ";
                for (key in arguments[0]) {
                  if (hasOwnProp(arguments[0], key)) {
                    arg += key + ": " + arguments[0][key] + ", ";
                  }
                }
                arg = arg.slice(0, -2);
              } else {
                arg = arguments[i];
              }
              args.push(arg);
            }
            warn2(
              msg + "\nArguments: " + Array.prototype.slice.call(args).join("") + "\n" + new Error().stack
            );
            firstTime = false;
          }
          return fn.apply(this, arguments);
        }, fn);
      }
      var deprecations = {};
      function deprecateSimple(name, msg) {
        if (hooks.deprecationHandler != null) {
          hooks.deprecationHandler(name, msg);
        }
        if (!deprecations[name]) {
          warn2(msg);
          deprecations[name] = true;
        }
      }
      hooks.suppressDeprecationWarnings = false;
      hooks.deprecationHandler = null;
      function isFunction(input) {
        return typeof Function !== "undefined" && input instanceof Function || Object.prototype.toString.call(input) === "[object Function]";
      }
      function set2(config) {
        var prop, i;
        for (i in config) {
          if (hasOwnProp(config, i)) {
            prop = config[i];
            if (isFunction(prop)) {
              this[i] = prop;
            } else {
              this["_" + i] = prop;
            }
          }
        }
        this._config = config;
        this._dayOfMonthOrdinalParseLenient = new RegExp(
          (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + "|" + /\d{1,2}/.source
        );
      }
      function mergeConfigs(parentConfig, childConfig) {
        var res = extend({}, parentConfig), prop;
        for (prop in childConfig) {
          if (hasOwnProp(childConfig, prop)) {
            if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
              res[prop] = {};
              extend(res[prop], parentConfig[prop]);
              extend(res[prop], childConfig[prop]);
            } else if (childConfig[prop] != null) {
              res[prop] = childConfig[prop];
            } else {
              delete res[prop];
            }
          }
        }
        for (prop in parentConfig) {
          if (hasOwnProp(parentConfig, prop) && !hasOwnProp(childConfig, prop) && isObject(parentConfig[prop])) {
            res[prop] = extend({}, res[prop]);
          }
        }
        return res;
      }
      function Locale(config) {
        if (config != null) {
          this.set(config);
        }
      }
      var keys;
      if (Object.keys) {
        keys = Object.keys;
      } else {
        keys = function(obj) {
          var i, res = [];
          for (i in obj) {
            if (hasOwnProp(obj, i)) {
              res.push(i);
            }
          }
          return res;
        };
      }
      var defaultCalendar = {
        sameDay: "[Today at] LT",
        nextDay: "[Tomorrow at] LT",
        nextWeek: "dddd [at] LT",
        lastDay: "[Yesterday at] LT",
        lastWeek: "[Last] dddd [at] LT",
        sameElse: "L"
      };
      function calendar(key, mom, now2) {
        var output = this._calendar[key] || this._calendar["sameElse"];
        return isFunction(output) ? output.call(mom, now2) : output;
      }
      function zeroFill(number, targetLength, forceSign) {
        var absNumber = "" + Math.abs(number), zerosToFill = targetLength - absNumber.length, sign2 = number >= 0;
        return (sign2 ? forceSign ? "+" : "" : "-") + Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
      }
      var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g, localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g, formatFunctions = {}, formatTokenFunctions = {};
      function addFormatToken(token2, padded, ordinal2, callback) {
        var func = callback;
        if (typeof callback === "string") {
          func = function() {
            return this[callback]();
          };
        }
        if (token2) {
          formatTokenFunctions[token2] = func;
        }
        if (padded) {
          formatTokenFunctions[padded[0]] = function() {
            return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
          };
        }
        if (ordinal2) {
          formatTokenFunctions[ordinal2] = function() {
            return this.localeData().ordinal(
              func.apply(this, arguments),
              token2
            );
          };
        }
      }
      function removeFormattingTokens(input) {
        if (input.match(/\[[\s\S]/)) {
          return input.replace(/^\[|\]$/g, "");
        }
        return input.replace(/\\/g, "");
      }
      function makeFormatFunction(format2) {
        var array = format2.match(formattingTokens), i, length;
        for (i = 0, length = array.length; i < length; i++) {
          if (formatTokenFunctions[array[i]]) {
            array[i] = formatTokenFunctions[array[i]];
          } else {
            array[i] = removeFormattingTokens(array[i]);
          }
        }
        return function(mom) {
          var output = "", i2;
          for (i2 = 0; i2 < length; i2++) {
            output += isFunction(array[i2]) ? array[i2].call(mom, format2) : array[i2];
          }
          return output;
        };
      }
      function formatMoment(m, format2) {
        if (!m.isValid()) {
          return m.localeData().invalidDate();
        }
        format2 = expandFormat(format2, m.localeData());
        formatFunctions[format2] = formatFunctions[format2] || makeFormatFunction(format2);
        return formatFunctions[format2](m);
      }
      function expandFormat(format2, locale2) {
        var i = 5;
        function replaceLongDateFormatTokens(input) {
          return locale2.longDateFormat(input) || input;
        }
        localFormattingTokens.lastIndex = 0;
        while (i >= 0 && localFormattingTokens.test(format2)) {
          format2 = format2.replace(
            localFormattingTokens,
            replaceLongDateFormatTokens
          );
          localFormattingTokens.lastIndex = 0;
          i -= 1;
        }
        return format2;
      }
      var defaultLongDateFormat = {
        LTS: "h:mm:ss A",
        LT: "h:mm A",
        L: "MM/DD/YYYY",
        LL: "MMMM D, YYYY",
        LLL: "MMMM D, YYYY h:mm A",
        LLLL: "dddd, MMMM D, YYYY h:mm A"
      };
      function longDateFormat(key) {
        var format2 = this._longDateFormat[key], formatUpper = this._longDateFormat[key.toUpperCase()];
        if (format2 || !formatUpper) {
          return format2;
        }
        this._longDateFormat[key] = formatUpper.match(formattingTokens).map(function(tok) {
          if (tok === "MMMM" || tok === "MM" || tok === "DD" || tok === "dddd") {
            return tok.slice(1);
          }
          return tok;
        }).join("");
        return this._longDateFormat[key];
      }
      var defaultInvalidDate = "Invalid date";
      function invalidDate() {
        return this._invalidDate;
      }
      var defaultOrdinal = "%d", defaultDayOfMonthOrdinalParse = /\d{1,2}/;
      function ordinal(number) {
        return this._ordinal.replace("%d", number);
      }
      var defaultRelativeTime = {
        future: "in %s",
        past: "%s ago",
        s: "a few seconds",
        ss: "%d seconds",
        m: "a minute",
        mm: "%d minutes",
        h: "an hour",
        hh: "%d hours",
        d: "a day",
        dd: "%d days",
        w: "a week",
        ww: "%d weeks",
        M: "a month",
        MM: "%d months",
        y: "a year",
        yy: "%d years"
      };
      function relativeTime(number, withoutSuffix, string2, isFuture) {
        var output = this._relativeTime[string2];
        return isFunction(output) ? output(number, withoutSuffix, string2, isFuture) : output.replace(/%d/i, number);
      }
      function pastFuture(diff2, output) {
        var format2 = this._relativeTime[diff2 > 0 ? "future" : "past"];
        return isFunction(format2) ? format2(output) : format2.replace(/%s/i, output);
      }
      var aliases = {};
      function addUnitAlias(unit, shorthand) {
        var lowerCase = unit.toLowerCase();
        aliases[lowerCase] = aliases[lowerCase + "s"] = aliases[shorthand] = unit;
      }
      function normalizeUnits(units) {
        return typeof units === "string" ? aliases[units] || aliases[units.toLowerCase()] : void 0;
      }
      function normalizeObjectUnits(inputObject) {
        var normalizedInput = {}, normalizedProp, prop;
        for (prop in inputObject) {
          if (hasOwnProp(inputObject, prop)) {
            normalizedProp = normalizeUnits(prop);
            if (normalizedProp) {
              normalizedInput[normalizedProp] = inputObject[prop];
            }
          }
        }
        return normalizedInput;
      }
      var priorities = {};
      function addUnitPriority(unit, priority) {
        priorities[unit] = priority;
      }
      function getPrioritizedUnits(unitsObj) {
        var units = [], u;
        for (u in unitsObj) {
          if (hasOwnProp(unitsObj, u)) {
            units.push({ unit: u, priority: priorities[u] });
          }
        }
        units.sort(function(a, b) {
          return a.priority - b.priority;
        });
        return units;
      }
      function isLeapYear(year) {
        return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
      }
      function absFloor(number) {
        if (number < 0) {
          return Math.ceil(number) || 0;
        } else {
          return Math.floor(number);
        }
      }
      function toInt(argumentForCoercion) {
        var coercedNumber = +argumentForCoercion, value = 0;
        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
          value = absFloor(coercedNumber);
        }
        return value;
      }
      function makeGetSet(unit, keepTime) {
        return function(value) {
          if (value != null) {
            set$1(this, unit, value);
            hooks.updateOffset(this, keepTime);
            return this;
          } else {
            return get(this, unit);
          }
        };
      }
      function get(mom, unit) {
        return mom.isValid() ? mom._d["get" + (mom._isUTC ? "UTC" : "") + unit]() : NaN;
      }
      function set$1(mom, unit, value) {
        if (mom.isValid() && !isNaN(value)) {
          if (unit === "FullYear" && isLeapYear(mom.year()) && mom.month() === 1 && mom.date() === 29) {
            value = toInt(value);
            mom._d["set" + (mom._isUTC ? "UTC" : "") + unit](
              value,
              mom.month(),
              daysInMonth(value, mom.month())
            );
          } else {
            mom._d["set" + (mom._isUTC ? "UTC" : "") + unit](value);
          }
        }
      }
      function stringGet(units) {
        units = normalizeUnits(units);
        if (isFunction(this[units])) {
          return this[units]();
        }
        return this;
      }
      function stringSet(units, value) {
        if (typeof units === "object") {
          units = normalizeObjectUnits(units);
          var prioritized = getPrioritizedUnits(units), i;
          for (i = 0; i < prioritized.length; i++) {
            this[prioritized[i].unit](units[prioritized[i].unit]);
          }
        } else {
          units = normalizeUnits(units);
          if (isFunction(this[units])) {
            return this[units](value);
          }
        }
        return this;
      }
      var match1 = /\d/, match2 = /\d\d/, match3 = /\d{3}/, match4 = /\d{4}/, match6 = /[+-]?\d{6}/, match1to2 = /\d\d?/, match3to4 = /\d\d\d\d?/, match5to6 = /\d\d\d\d\d\d?/, match1to3 = /\d{1,3}/, match1to4 = /\d{1,4}/, match1to6 = /[+-]?\d{1,6}/, matchUnsigned = /\d+/, matchSigned = /[+-]?\d+/, matchOffset = /Z|[+-]\d\d:?\d\d/gi, matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi, matchTimestamp = /[+-]?\d+(\.\d{1,3})?/, matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i, regexes;
      regexes = {};
      function addRegexToken(token2, regex, strictRegex) {
        regexes[token2] = isFunction(regex) ? regex : function(isStrict, localeData2) {
          return isStrict && strictRegex ? strictRegex : regex;
        };
      }
      function getParseRegexForToken(token2, config) {
        if (!hasOwnProp(regexes, token2)) {
          return new RegExp(unescapeFormat(token2));
        }
        return regexes[token2](config._strict, config._locale);
      }
      function unescapeFormat(s) {
        return regexEscape(
          s.replace("\\", "").replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function(matched, p1, p2, p3, p4) {
            return p1 || p2 || p3 || p4;
          })
        );
      }
      function regexEscape(s) {
        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
      }
      var tokens = {};
      function addParseToken(token2, callback) {
        var i, func = callback;
        if (typeof token2 === "string") {
          token2 = [token2];
        }
        if (isNumber(callback)) {
          func = function(input, array) {
            array[callback] = toInt(input);
          };
        }
        for (i = 0; i < token2.length; i++) {
          tokens[token2[i]] = func;
        }
      }
      function addWeekParseToken(token2, callback) {
        addParseToken(token2, function(input, array, config, token3) {
          config._w = config._w || {};
          callback(input, config._w, config, token3);
        });
      }
      function addTimeToArrayFromToken(token2, input, config) {
        if (input != null && hasOwnProp(tokens, token2)) {
          tokens[token2](input, config._a, config, token2);
        }
      }
      var YEAR = 0, MONTH = 1, DATE = 2, HOUR = 3, MINUTE = 4, SECOND = 5, MILLISECOND = 6, WEEK = 7, WEEKDAY = 8;
      function mod(n, x) {
        return (n % x + x) % x;
      }
      var indexOf;
      if (Array.prototype.indexOf) {
        indexOf = Array.prototype.indexOf;
      } else {
        indexOf = function(o) {
          var i;
          for (i = 0; i < this.length; ++i) {
            if (this[i] === o) {
              return i;
            }
          }
          return -1;
        };
      }
      function daysInMonth(year, month) {
        if (isNaN(year) || isNaN(month)) {
          return NaN;
        }
        var modMonth = mod(month, 12);
        year += (month - modMonth) / 12;
        return modMonth === 1 ? isLeapYear(year) ? 29 : 28 : 31 - modMonth % 7 % 2;
      }
      addFormatToken("M", ["MM", 2], "Mo", function() {
        return this.month() + 1;
      });
      addFormatToken("MMM", 0, 0, function(format2) {
        return this.localeData().monthsShort(this, format2);
      });
      addFormatToken("MMMM", 0, 0, function(format2) {
        return this.localeData().months(this, format2);
      });
      addUnitAlias("month", "M");
      addUnitPriority("month", 8);
      addRegexToken("M", match1to2);
      addRegexToken("MM", match1to2, match2);
      addRegexToken("MMM", function(isStrict, locale2) {
        return locale2.monthsShortRegex(isStrict);
      });
      addRegexToken("MMMM", function(isStrict, locale2) {
        return locale2.monthsRegex(isStrict);
      });
      addParseToken(["M", "MM"], function(input, array) {
        array[MONTH] = toInt(input) - 1;
      });
      addParseToken(["MMM", "MMMM"], function(input, array, config, token2) {
        var month = config._locale.monthsParse(input, token2, config._strict);
        if (month != null) {
          array[MONTH] = month;
        } else {
          getParsingFlags(config).invalidMonth = input;
        }
      });
      var defaultLocaleMonths = "January_February_March_April_May_June_July_August_September_October_November_December".split(
        "_"
      ), defaultLocaleMonthsShort = "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split(
        "_"
      ), MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/, defaultMonthsShortRegex = matchWord, defaultMonthsRegex = matchWord;
      function localeMonths(m, format2) {
        if (!m) {
          return isArray(this._months) ? this._months : this._months["standalone"];
        }
        return isArray(this._months) ? this._months[m.month()] : this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format2) ? "format" : "standalone"][m.month()];
      }
      function localeMonthsShort(m, format2) {
        if (!m) {
          return isArray(this._monthsShort) ? this._monthsShort : this._monthsShort["standalone"];
        }
        return isArray(this._monthsShort) ? this._monthsShort[m.month()] : this._monthsShort[MONTHS_IN_FORMAT.test(format2) ? "format" : "standalone"][m.month()];
      }
      function handleStrictParse(monthName, format2, strict) {
        var i, ii, mom, llc = monthName.toLocaleLowerCase();
        if (!this._monthsParse) {
          this._monthsParse = [];
          this._longMonthsParse = [];
          this._shortMonthsParse = [];
          for (i = 0; i < 12; ++i) {
            mom = createUTC([2e3, i]);
            this._shortMonthsParse[i] = this.monthsShort(
              mom,
              ""
            ).toLocaleLowerCase();
            this._longMonthsParse[i] = this.months(mom, "").toLocaleLowerCase();
          }
        }
        if (strict) {
          if (format2 === "MMM") {
            ii = indexOf.call(this._shortMonthsParse, llc);
            return ii !== -1 ? ii : null;
          } else {
            ii = indexOf.call(this._longMonthsParse, llc);
            return ii !== -1 ? ii : null;
          }
        } else {
          if (format2 === "MMM") {
            ii = indexOf.call(this._shortMonthsParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._longMonthsParse, llc);
            return ii !== -1 ? ii : null;
          } else {
            ii = indexOf.call(this._longMonthsParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._shortMonthsParse, llc);
            return ii !== -1 ? ii : null;
          }
        }
      }
      function localeMonthsParse(monthName, format2, strict) {
        var i, mom, regex;
        if (this._monthsParseExact) {
          return handleStrictParse.call(this, monthName, format2, strict);
        }
        if (!this._monthsParse) {
          this._monthsParse = [];
          this._longMonthsParse = [];
          this._shortMonthsParse = [];
        }
        for (i = 0; i < 12; i++) {
          mom = createUTC([2e3, i]);
          if (strict && !this._longMonthsParse[i]) {
            this._longMonthsParse[i] = new RegExp(
              "^" + this.months(mom, "").replace(".", "") + "$",
              "i"
            );
            this._shortMonthsParse[i] = new RegExp(
              "^" + this.monthsShort(mom, "").replace(".", "") + "$",
              "i"
            );
          }
          if (!strict && !this._monthsParse[i]) {
            regex = "^" + this.months(mom, "") + "|^" + this.monthsShort(mom, "");
            this._monthsParse[i] = new RegExp(regex.replace(".", ""), "i");
          }
          if (strict && format2 === "MMMM" && this._longMonthsParse[i].test(monthName)) {
            return i;
          } else if (strict && format2 === "MMM" && this._shortMonthsParse[i].test(monthName)) {
            return i;
          } else if (!strict && this._monthsParse[i].test(monthName)) {
            return i;
          }
        }
      }
      function setMonth(mom, value) {
        var dayOfMonth;
        if (!mom.isValid()) {
          return mom;
        }
        if (typeof value === "string") {
          if (/^\d+$/.test(value)) {
            value = toInt(value);
          } else {
            value = mom.localeData().monthsParse(value);
            if (!isNumber(value)) {
              return mom;
            }
          }
        }
        dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
        mom._d["set" + (mom._isUTC ? "UTC" : "") + "Month"](value, dayOfMonth);
        return mom;
      }
      function getSetMonth(value) {
        if (value != null) {
          setMonth(this, value);
          hooks.updateOffset(this, true);
          return this;
        } else {
          return get(this, "Month");
        }
      }
      function getDaysInMonth() {
        return daysInMonth(this.year(), this.month());
      }
      function monthsShortRegex(isStrict) {
        if (this._monthsParseExact) {
          if (!hasOwnProp(this, "_monthsRegex")) {
            computeMonthsParse.call(this);
          }
          if (isStrict) {
            return this._monthsShortStrictRegex;
          } else {
            return this._monthsShortRegex;
          }
        } else {
          if (!hasOwnProp(this, "_monthsShortRegex")) {
            this._monthsShortRegex = defaultMonthsShortRegex;
          }
          return this._monthsShortStrictRegex && isStrict ? this._monthsShortStrictRegex : this._monthsShortRegex;
        }
      }
      function monthsRegex(isStrict) {
        if (this._monthsParseExact) {
          if (!hasOwnProp(this, "_monthsRegex")) {
            computeMonthsParse.call(this);
          }
          if (isStrict) {
            return this._monthsStrictRegex;
          } else {
            return this._monthsRegex;
          }
        } else {
          if (!hasOwnProp(this, "_monthsRegex")) {
            this._monthsRegex = defaultMonthsRegex;
          }
          return this._monthsStrictRegex && isStrict ? this._monthsStrictRegex : this._monthsRegex;
        }
      }
      function computeMonthsParse() {
        function cmpLenRev(a, b) {
          return b.length - a.length;
        }
        var shortPieces = [], longPieces = [], mixedPieces = [], i, mom;
        for (i = 0; i < 12; i++) {
          mom = createUTC([2e3, i]);
          shortPieces.push(this.monthsShort(mom, ""));
          longPieces.push(this.months(mom, ""));
          mixedPieces.push(this.months(mom, ""));
          mixedPieces.push(this.monthsShort(mom, ""));
        }
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);
        for (i = 0; i < 12; i++) {
          shortPieces[i] = regexEscape(shortPieces[i]);
          longPieces[i] = regexEscape(longPieces[i]);
        }
        for (i = 0; i < 24; i++) {
          mixedPieces[i] = regexEscape(mixedPieces[i]);
        }
        this._monthsRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
        this._monthsShortRegex = this._monthsRegex;
        this._monthsStrictRegex = new RegExp(
          "^(" + longPieces.join("|") + ")",
          "i"
        );
        this._monthsShortStrictRegex = new RegExp(
          "^(" + shortPieces.join("|") + ")",
          "i"
        );
      }
      addFormatToken("Y", 0, 0, function() {
        var y = this.year();
        return y <= 9999 ? zeroFill(y, 4) : "+" + y;
      });
      addFormatToken(0, ["YY", 2], 0, function() {
        return this.year() % 100;
      });
      addFormatToken(0, ["YYYY", 4], 0, "year");
      addFormatToken(0, ["YYYYY", 5], 0, "year");
      addFormatToken(0, ["YYYYYY", 6, true], 0, "year");
      addUnitAlias("year", "y");
      addUnitPriority("year", 1);
      addRegexToken("Y", matchSigned);
      addRegexToken("YY", match1to2, match2);
      addRegexToken("YYYY", match1to4, match4);
      addRegexToken("YYYYY", match1to6, match6);
      addRegexToken("YYYYYY", match1to6, match6);
      addParseToken(["YYYYY", "YYYYYY"], YEAR);
      addParseToken("YYYY", function(input, array) {
        array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
      });
      addParseToken("YY", function(input, array) {
        array[YEAR] = hooks.parseTwoDigitYear(input);
      });
      addParseToken("Y", function(input, array) {
        array[YEAR] = parseInt(input, 10);
      });
      function daysInYear(year) {
        return isLeapYear(year) ? 366 : 365;
      }
      hooks.parseTwoDigitYear = function(input) {
        return toInt(input) + (toInt(input) > 68 ? 1900 : 2e3);
      };
      var getSetYear = makeGetSet("FullYear", true);
      function getIsLeapYear() {
        return isLeapYear(this.year());
      }
      function createDate(y, m, d, h, M, s, ms) {
        var date;
        if (y < 100 && y >= 0) {
          date = new Date(y + 400, m, d, h, M, s, ms);
          if (isFinite(date.getFullYear())) {
            date.setFullYear(y);
          }
        } else {
          date = new Date(y, m, d, h, M, s, ms);
        }
        return date;
      }
      function createUTCDate(y) {
        var date, args;
        if (y < 100 && y >= 0) {
          args = Array.prototype.slice.call(arguments);
          args[0] = y + 400;
          date = new Date(Date.UTC.apply(null, args));
          if (isFinite(date.getUTCFullYear())) {
            date.setUTCFullYear(y);
          }
        } else {
          date = new Date(Date.UTC.apply(null, arguments));
        }
        return date;
      }
      function firstWeekOffset(year, dow, doy) {
        var fwd = 7 + dow - doy, fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;
        return -fwdlw + fwd - 1;
      }
      function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
        var localWeekday = (7 + weekday - dow) % 7, weekOffset = firstWeekOffset(year, dow, doy), dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset, resYear, resDayOfYear;
        if (dayOfYear <= 0) {
          resYear = year - 1;
          resDayOfYear = daysInYear(resYear) + dayOfYear;
        } else if (dayOfYear > daysInYear(year)) {
          resYear = year + 1;
          resDayOfYear = dayOfYear - daysInYear(year);
        } else {
          resYear = year;
          resDayOfYear = dayOfYear;
        }
        return {
          year: resYear,
          dayOfYear: resDayOfYear
        };
      }
      function weekOfYear(mom, dow, doy) {
        var weekOffset = firstWeekOffset(mom.year(), dow, doy), week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1, resWeek, resYear;
        if (week < 1) {
          resYear = mom.year() - 1;
          resWeek = week + weeksInYear(resYear, dow, doy);
        } else if (week > weeksInYear(mom.year(), dow, doy)) {
          resWeek = week - weeksInYear(mom.year(), dow, doy);
          resYear = mom.year() + 1;
        } else {
          resYear = mom.year();
          resWeek = week;
        }
        return {
          week: resWeek,
          year: resYear
        };
      }
      function weeksInYear(year, dow, doy) {
        var weekOffset = firstWeekOffset(year, dow, doy), weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
        return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
      }
      addFormatToken("w", ["ww", 2], "wo", "week");
      addFormatToken("W", ["WW", 2], "Wo", "isoWeek");
      addUnitAlias("week", "w");
      addUnitAlias("isoWeek", "W");
      addUnitPriority("week", 5);
      addUnitPriority("isoWeek", 5);
      addRegexToken("w", match1to2);
      addRegexToken("ww", match1to2, match2);
      addRegexToken("W", match1to2);
      addRegexToken("WW", match1to2, match2);
      addWeekParseToken(["w", "ww", "W", "WW"], function(input, week, config, token2) {
        week[token2.substr(0, 1)] = toInt(input);
      });
      function localeWeek(mom) {
        return weekOfYear(mom, this._week.dow, this._week.doy).week;
      }
      var defaultLocaleWeek = {
        dow: 0,
        // Sunday is the first day of the week.
        doy: 6
        // The week that contains Jan 6th is the first week of the year.
      };
      function localeFirstDayOfWeek() {
        return this._week.dow;
      }
      function localeFirstDayOfYear() {
        return this._week.doy;
      }
      function getSetWeek(input) {
        var week = this.localeData().week(this);
        return input == null ? week : this.add((input - week) * 7, "d");
      }
      function getSetISOWeek(input) {
        var week = weekOfYear(this, 1, 4).week;
        return input == null ? week : this.add((input - week) * 7, "d");
      }
      addFormatToken("d", 0, "do", "day");
      addFormatToken("dd", 0, 0, function(format2) {
        return this.localeData().weekdaysMin(this, format2);
      });
      addFormatToken("ddd", 0, 0, function(format2) {
        return this.localeData().weekdaysShort(this, format2);
      });
      addFormatToken("dddd", 0, 0, function(format2) {
        return this.localeData().weekdays(this, format2);
      });
      addFormatToken("e", 0, 0, "weekday");
      addFormatToken("E", 0, 0, "isoWeekday");
      addUnitAlias("day", "d");
      addUnitAlias("weekday", "e");
      addUnitAlias("isoWeekday", "E");
      addUnitPriority("day", 11);
      addUnitPriority("weekday", 11);
      addUnitPriority("isoWeekday", 11);
      addRegexToken("d", match1to2);
      addRegexToken("e", match1to2);
      addRegexToken("E", match1to2);
      addRegexToken("dd", function(isStrict, locale2) {
        return locale2.weekdaysMinRegex(isStrict);
      });
      addRegexToken("ddd", function(isStrict, locale2) {
        return locale2.weekdaysShortRegex(isStrict);
      });
      addRegexToken("dddd", function(isStrict, locale2) {
        return locale2.weekdaysRegex(isStrict);
      });
      addWeekParseToken(["dd", "ddd", "dddd"], function(input, week, config, token2) {
        var weekday = config._locale.weekdaysParse(input, token2, config._strict);
        if (weekday != null) {
          week.d = weekday;
        } else {
          getParsingFlags(config).invalidWeekday = input;
        }
      });
      addWeekParseToken(["d", "e", "E"], function(input, week, config, token2) {
        week[token2] = toInt(input);
      });
      function parseWeekday(input, locale2) {
        if (typeof input !== "string") {
          return input;
        }
        if (!isNaN(input)) {
          return parseInt(input, 10);
        }
        input = locale2.weekdaysParse(input);
        if (typeof input === "number") {
          return input;
        }
        return null;
      }
      function parseIsoWeekday(input, locale2) {
        if (typeof input === "string") {
          return locale2.weekdaysParse(input) % 7 || 7;
        }
        return isNaN(input) ? null : input;
      }
      function shiftWeekdays(ws, n) {
        return ws.slice(n, 7).concat(ws.slice(0, n));
      }
      var defaultLocaleWeekdays = "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split(
        "_"
      ), defaultLocaleWeekdaysShort = "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"), defaultLocaleWeekdaysMin = "Su_Mo_Tu_We_Th_Fr_Sa".split("_"), defaultWeekdaysRegex = matchWord, defaultWeekdaysShortRegex = matchWord, defaultWeekdaysMinRegex = matchWord;
      function localeWeekdays(m, format2) {
        var weekdays = isArray(this._weekdays) ? this._weekdays : this._weekdays[m && m !== true && this._weekdays.isFormat.test(format2) ? "format" : "standalone"];
        return m === true ? shiftWeekdays(weekdays, this._week.dow) : m ? weekdays[m.day()] : weekdays;
      }
      function localeWeekdaysShort(m) {
        return m === true ? shiftWeekdays(this._weekdaysShort, this._week.dow) : m ? this._weekdaysShort[m.day()] : this._weekdaysShort;
      }
      function localeWeekdaysMin(m) {
        return m === true ? shiftWeekdays(this._weekdaysMin, this._week.dow) : m ? this._weekdaysMin[m.day()] : this._weekdaysMin;
      }
      function handleStrictParse$1(weekdayName, format2, strict) {
        var i, ii, mom, llc = weekdayName.toLocaleLowerCase();
        if (!this._weekdaysParse) {
          this._weekdaysParse = [];
          this._shortWeekdaysParse = [];
          this._minWeekdaysParse = [];
          for (i = 0; i < 7; ++i) {
            mom = createUTC([2e3, 1]).day(i);
            this._minWeekdaysParse[i] = this.weekdaysMin(
              mom,
              ""
            ).toLocaleLowerCase();
            this._shortWeekdaysParse[i] = this.weekdaysShort(
              mom,
              ""
            ).toLocaleLowerCase();
            this._weekdaysParse[i] = this.weekdays(mom, "").toLocaleLowerCase();
          }
        }
        if (strict) {
          if (format2 === "dddd") {
            ii = indexOf.call(this._weekdaysParse, llc);
            return ii !== -1 ? ii : null;
          } else if (format2 === "ddd") {
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          } else {
            ii = indexOf.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          }
        } else {
          if (format2 === "dddd") {
            ii = indexOf.call(this._weekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          } else if (format2 === "ddd") {
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._weekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          } else {
            ii = indexOf.call(this._minWeekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._weekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          }
        }
      }
      function localeWeekdaysParse(weekdayName, format2, strict) {
        var i, mom, regex;
        if (this._weekdaysParseExact) {
          return handleStrictParse$1.call(this, weekdayName, format2, strict);
        }
        if (!this._weekdaysParse) {
          this._weekdaysParse = [];
          this._minWeekdaysParse = [];
          this._shortWeekdaysParse = [];
          this._fullWeekdaysParse = [];
        }
        for (i = 0; i < 7; i++) {
          mom = createUTC([2e3, 1]).day(i);
          if (strict && !this._fullWeekdaysParse[i]) {
            this._fullWeekdaysParse[i] = new RegExp(
              "^" + this.weekdays(mom, "").replace(".", "\\.?") + "$",
              "i"
            );
            this._shortWeekdaysParse[i] = new RegExp(
              "^" + this.weekdaysShort(mom, "").replace(".", "\\.?") + "$",
              "i"
            );
            this._minWeekdaysParse[i] = new RegExp(
              "^" + this.weekdaysMin(mom, "").replace(".", "\\.?") + "$",
              "i"
            );
          }
          if (!this._weekdaysParse[i]) {
            regex = "^" + this.weekdays(mom, "") + "|^" + this.weekdaysShort(mom, "") + "|^" + this.weekdaysMin(mom, "");
            this._weekdaysParse[i] = new RegExp(regex.replace(".", ""), "i");
          }
          if (strict && format2 === "dddd" && this._fullWeekdaysParse[i].test(weekdayName)) {
            return i;
          } else if (strict && format2 === "ddd" && this._shortWeekdaysParse[i].test(weekdayName)) {
            return i;
          } else if (strict && format2 === "dd" && this._minWeekdaysParse[i].test(weekdayName)) {
            return i;
          } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
            return i;
          }
        }
      }
      function getSetDayOfWeek(input) {
        if (!this.isValid()) {
          return input != null ? this : NaN;
        }
        var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
        if (input != null) {
          input = parseWeekday(input, this.localeData());
          return this.add(input - day, "d");
        } else {
          return day;
        }
      }
      function getSetLocaleDayOfWeek(input) {
        if (!this.isValid()) {
          return input != null ? this : NaN;
        }
        var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
        return input == null ? weekday : this.add(input - weekday, "d");
      }
      function getSetISODayOfWeek(input) {
        if (!this.isValid()) {
          return input != null ? this : NaN;
        }
        if (input != null) {
          var weekday = parseIsoWeekday(input, this.localeData());
          return this.day(this.day() % 7 ? weekday : weekday - 7);
        } else {
          return this.day() || 7;
        }
      }
      function weekdaysRegex(isStrict) {
        if (this._weekdaysParseExact) {
          if (!hasOwnProp(this, "_weekdaysRegex")) {
            computeWeekdaysParse.call(this);
          }
          if (isStrict) {
            return this._weekdaysStrictRegex;
          } else {
            return this._weekdaysRegex;
          }
        } else {
          if (!hasOwnProp(this, "_weekdaysRegex")) {
            this._weekdaysRegex = defaultWeekdaysRegex;
          }
          return this._weekdaysStrictRegex && isStrict ? this._weekdaysStrictRegex : this._weekdaysRegex;
        }
      }
      function weekdaysShortRegex(isStrict) {
        if (this._weekdaysParseExact) {
          if (!hasOwnProp(this, "_weekdaysRegex")) {
            computeWeekdaysParse.call(this);
          }
          if (isStrict) {
            return this._weekdaysShortStrictRegex;
          } else {
            return this._weekdaysShortRegex;
          }
        } else {
          if (!hasOwnProp(this, "_weekdaysShortRegex")) {
            this._weekdaysShortRegex = defaultWeekdaysShortRegex;
          }
          return this._weekdaysShortStrictRegex && isStrict ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
        }
      }
      function weekdaysMinRegex(isStrict) {
        if (this._weekdaysParseExact) {
          if (!hasOwnProp(this, "_weekdaysRegex")) {
            computeWeekdaysParse.call(this);
          }
          if (isStrict) {
            return this._weekdaysMinStrictRegex;
          } else {
            return this._weekdaysMinRegex;
          }
        } else {
          if (!hasOwnProp(this, "_weekdaysMinRegex")) {
            this._weekdaysMinRegex = defaultWeekdaysMinRegex;
          }
          return this._weekdaysMinStrictRegex && isStrict ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
        }
      }
      function computeWeekdaysParse() {
        function cmpLenRev(a, b) {
          return b.length - a.length;
        }
        var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [], i, mom, minp, shortp, longp;
        for (i = 0; i < 7; i++) {
          mom = createUTC([2e3, 1]).day(i);
          minp = regexEscape(this.weekdaysMin(mom, ""));
          shortp = regexEscape(this.weekdaysShort(mom, ""));
          longp = regexEscape(this.weekdays(mom, ""));
          minPieces.push(minp);
          shortPieces.push(shortp);
          longPieces.push(longp);
          mixedPieces.push(minp);
          mixedPieces.push(shortp);
          mixedPieces.push(longp);
        }
        minPieces.sort(cmpLenRev);
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);
        this._weekdaysRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
        this._weekdaysShortRegex = this._weekdaysRegex;
        this._weekdaysMinRegex = this._weekdaysRegex;
        this._weekdaysStrictRegex = new RegExp(
          "^(" + longPieces.join("|") + ")",
          "i"
        );
        this._weekdaysShortStrictRegex = new RegExp(
          "^(" + shortPieces.join("|") + ")",
          "i"
        );
        this._weekdaysMinStrictRegex = new RegExp(
          "^(" + minPieces.join("|") + ")",
          "i"
        );
      }
      function hFormat() {
        return this.hours() % 12 || 12;
      }
      function kFormat() {
        return this.hours() || 24;
      }
      addFormatToken("H", ["HH", 2], 0, "hour");
      addFormatToken("h", ["hh", 2], 0, hFormat);
      addFormatToken("k", ["kk", 2], 0, kFormat);
      addFormatToken("hmm", 0, 0, function() {
        return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2);
      });
      addFormatToken("hmmss", 0, 0, function() {
        return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
      });
      addFormatToken("Hmm", 0, 0, function() {
        return "" + this.hours() + zeroFill(this.minutes(), 2);
      });
      addFormatToken("Hmmss", 0, 0, function() {
        return "" + this.hours() + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
      });
      function meridiem(token2, lowercase) {
        addFormatToken(token2, 0, 0, function() {
          return this.localeData().meridiem(
            this.hours(),
            this.minutes(),
            lowercase
          );
        });
      }
      meridiem("a", true);
      meridiem("A", false);
      addUnitAlias("hour", "h");
      addUnitPriority("hour", 13);
      function matchMeridiem(isStrict, locale2) {
        return locale2._meridiemParse;
      }
      addRegexToken("a", matchMeridiem);
      addRegexToken("A", matchMeridiem);
      addRegexToken("H", match1to2);
      addRegexToken("h", match1to2);
      addRegexToken("k", match1to2);
      addRegexToken("HH", match1to2, match2);
      addRegexToken("hh", match1to2, match2);
      addRegexToken("kk", match1to2, match2);
      addRegexToken("hmm", match3to4);
      addRegexToken("hmmss", match5to6);
      addRegexToken("Hmm", match3to4);
      addRegexToken("Hmmss", match5to6);
      addParseToken(["H", "HH"], HOUR);
      addParseToken(["k", "kk"], function(input, array, config) {
        var kInput = toInt(input);
        array[HOUR] = kInput === 24 ? 0 : kInput;
      });
      addParseToken(["a", "A"], function(input, array, config) {
        config._isPm = config._locale.isPM(input);
        config._meridiem = input;
      });
      addParseToken(["h", "hh"], function(input, array, config) {
        array[HOUR] = toInt(input);
        getParsingFlags(config).bigHour = true;
      });
      addParseToken("hmm", function(input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
        getParsingFlags(config).bigHour = true;
      });
      addParseToken("hmmss", function(input, array, config) {
        var pos1 = input.length - 4, pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
        getParsingFlags(config).bigHour = true;
      });
      addParseToken("Hmm", function(input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
      });
      addParseToken("Hmmss", function(input, array, config) {
        var pos1 = input.length - 4, pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
      });
      function localeIsPM(input) {
        return (input + "").toLowerCase().charAt(0) === "p";
      }
      var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i, getSetHour = makeGetSet("Hours", true);
      function localeMeridiem(hours2, minutes2, isLower) {
        if (hours2 > 11) {
          return isLower ? "pm" : "PM";
        } else {
          return isLower ? "am" : "AM";
        }
      }
      var baseConfig = {
        calendar: defaultCalendar,
        longDateFormat: defaultLongDateFormat,
        invalidDate: defaultInvalidDate,
        ordinal: defaultOrdinal,
        dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
        relativeTime: defaultRelativeTime,
        months: defaultLocaleMonths,
        monthsShort: defaultLocaleMonthsShort,
        week: defaultLocaleWeek,
        weekdays: defaultLocaleWeekdays,
        weekdaysMin: defaultLocaleWeekdaysMin,
        weekdaysShort: defaultLocaleWeekdaysShort,
        meridiemParse: defaultLocaleMeridiemParse
      };
      var locales = {}, localeFamilies = {}, globalLocale;
      function commonPrefix(arr1, arr2) {
        var i, minl = Math.min(arr1.length, arr2.length);
        for (i = 0; i < minl; i += 1) {
          if (arr1[i] !== arr2[i]) {
            return i;
          }
        }
        return minl;
      }
      function normalizeLocale(key) {
        return key ? key.toLowerCase().replace("_", "-") : key;
      }
      function chooseLocale(names) {
        var i = 0, j, next, locale2, split;
        while (i < names.length) {
          split = normalizeLocale(names[i]).split("-");
          j = split.length;
          next = normalizeLocale(names[i + 1]);
          next = next ? next.split("-") : null;
          while (j > 0) {
            locale2 = loadLocale(split.slice(0, j).join("-"));
            if (locale2) {
              return locale2;
            }
            if (next && next.length >= j && commonPrefix(split, next) >= j - 1) {
              break;
            }
            j--;
          }
          i++;
        }
        return globalLocale;
      }
      function loadLocale(name) {
        var oldLocale = null, aliasedRequire;
        if (locales[name] === void 0 && typeof module2 !== "undefined" && module2 && module2.exports) {
          try {
            oldLocale = globalLocale._abbr;
            aliasedRequire = require;
            aliasedRequire("./locale/" + name);
            getSetGlobalLocale(oldLocale);
          } catch (e) {
            locales[name] = null;
          }
        }
        return locales[name];
      }
      function getSetGlobalLocale(key, values) {
        var data;
        if (key) {
          if (isUndefined(values)) {
            data = getLocale(key);
          } else {
            data = defineLocale(key, values);
          }
          if (data) {
            globalLocale = data;
          } else {
            if (typeof console !== "undefined" && console.warn) {
              console.warn(
                "Locale " + key + " not found. Did you forget to load it?"
              );
            }
          }
        }
        return globalLocale._abbr;
      }
      function defineLocale(name, config) {
        if (config !== null) {
          var locale2, parentConfig = baseConfig;
          config.abbr = name;
          if (locales[name] != null) {
            deprecateSimple(
              "defineLocaleOverride",
              "use moment.updateLocale(localeName, config) to change an existing locale. moment.defineLocale(localeName, config) should only be used for creating a new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more info."
            );
            parentConfig = locales[name]._config;
          } else if (config.parentLocale != null) {
            if (locales[config.parentLocale] != null) {
              parentConfig = locales[config.parentLocale]._config;
            } else {
              locale2 = loadLocale(config.parentLocale);
              if (locale2 != null) {
                parentConfig = locale2._config;
              } else {
                if (!localeFamilies[config.parentLocale]) {
                  localeFamilies[config.parentLocale] = [];
                }
                localeFamilies[config.parentLocale].push({
                  name,
                  config
                });
                return null;
              }
            }
          }
          locales[name] = new Locale(mergeConfigs(parentConfig, config));
          if (localeFamilies[name]) {
            localeFamilies[name].forEach(function(x) {
              defineLocale(x.name, x.config);
            });
          }
          getSetGlobalLocale(name);
          return locales[name];
        } else {
          delete locales[name];
          return null;
        }
      }
      function updateLocale(name, config) {
        if (config != null) {
          var locale2, tmpLocale, parentConfig = baseConfig;
          if (locales[name] != null && locales[name].parentLocale != null) {
            locales[name].set(mergeConfigs(locales[name]._config, config));
          } else {
            tmpLocale = loadLocale(name);
            if (tmpLocale != null) {
              parentConfig = tmpLocale._config;
            }
            config = mergeConfigs(parentConfig, config);
            if (tmpLocale == null) {
              config.abbr = name;
            }
            locale2 = new Locale(config);
            locale2.parentLocale = locales[name];
            locales[name] = locale2;
          }
          getSetGlobalLocale(name);
        } else {
          if (locales[name] != null) {
            if (locales[name].parentLocale != null) {
              locales[name] = locales[name].parentLocale;
              if (name === getSetGlobalLocale()) {
                getSetGlobalLocale(name);
              }
            } else if (locales[name] != null) {
              delete locales[name];
            }
          }
        }
        return locales[name];
      }
      function getLocale(key) {
        var locale2;
        if (key && key._locale && key._locale._abbr) {
          key = key._locale._abbr;
        }
        if (!key) {
          return globalLocale;
        }
        if (!isArray(key)) {
          locale2 = loadLocale(key);
          if (locale2) {
            return locale2;
          }
          key = [key];
        }
        return chooseLocale(key);
      }
      function listLocales() {
        return keys(locales);
      }
      function checkOverflow(m) {
        var overflow, a = m._a;
        if (a && getParsingFlags(m).overflow === -2) {
          overflow = a[MONTH] < 0 || a[MONTH] > 11 ? MONTH : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH]) ? DATE : a[HOUR] < 0 || a[HOUR] > 24 || a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0) ? HOUR : a[MINUTE] < 0 || a[MINUTE] > 59 ? MINUTE : a[SECOND] < 0 || a[SECOND] > 59 ? SECOND : a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND : -1;
          if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
            overflow = DATE;
          }
          if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
            overflow = WEEK;
          }
          if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
            overflow = WEEKDAY;
          }
          getParsingFlags(m).overflow = overflow;
        }
        return m;
      }
      var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, tzRegex = /Z|[+-]\d\d(?::?\d\d)?/, isoDates = [
        ["YYYYYY-MM-DD", /[+-]\d{6}-\d\d-\d\d/],
        ["YYYY-MM-DD", /\d{4}-\d\d-\d\d/],
        ["GGGG-[W]WW-E", /\d{4}-W\d\d-\d/],
        ["GGGG-[W]WW", /\d{4}-W\d\d/, false],
        ["YYYY-DDD", /\d{4}-\d{3}/],
        ["YYYY-MM", /\d{4}-\d\d/, false],
        ["YYYYYYMMDD", /[+-]\d{10}/],
        ["YYYYMMDD", /\d{8}/],
        ["GGGG[W]WWE", /\d{4}W\d{3}/],
        ["GGGG[W]WW", /\d{4}W\d{2}/, false],
        ["YYYYDDD", /\d{7}/],
        ["YYYYMM", /\d{6}/, false],
        ["YYYY", /\d{4}/, false]
      ], isoTimes = [
        ["HH:mm:ss.SSSS", /\d\d:\d\d:\d\d\.\d+/],
        ["HH:mm:ss,SSSS", /\d\d:\d\d:\d\d,\d+/],
        ["HH:mm:ss", /\d\d:\d\d:\d\d/],
        ["HH:mm", /\d\d:\d\d/],
        ["HHmmss.SSSS", /\d\d\d\d\d\d\.\d+/],
        ["HHmmss,SSSS", /\d\d\d\d\d\d,\d+/],
        ["HHmmss", /\d\d\d\d\d\d/],
        ["HHmm", /\d\d\d\d/],
        ["HH", /\d\d/]
      ], aspNetJsonRegex = /^\/?Date\((-?\d+)/i, rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/, obsOffsets = {
        UT: 0,
        GMT: 0,
        EDT: -4 * 60,
        EST: -5 * 60,
        CDT: -5 * 60,
        CST: -6 * 60,
        MDT: -6 * 60,
        MST: -7 * 60,
        PDT: -7 * 60,
        PST: -8 * 60
      };
      function configFromISO(config) {
        var i, l, string2 = config._i, match = extendedIsoRegex.exec(string2) || basicIsoRegex.exec(string2), allowTime, dateFormat, timeFormat, tzFormat;
        if (match) {
          getParsingFlags(config).iso = true;
          for (i = 0, l = isoDates.length; i < l; i++) {
            if (isoDates[i][1].exec(match[1])) {
              dateFormat = isoDates[i][0];
              allowTime = isoDates[i][2] !== false;
              break;
            }
          }
          if (dateFormat == null) {
            config._isValid = false;
            return;
          }
          if (match[3]) {
            for (i = 0, l = isoTimes.length; i < l; i++) {
              if (isoTimes[i][1].exec(match[3])) {
                timeFormat = (match[2] || " ") + isoTimes[i][0];
                break;
              }
            }
            if (timeFormat == null) {
              config._isValid = false;
              return;
            }
          }
          if (!allowTime && timeFormat != null) {
            config._isValid = false;
            return;
          }
          if (match[4]) {
            if (tzRegex.exec(match[4])) {
              tzFormat = "Z";
            } else {
              config._isValid = false;
              return;
            }
          }
          config._f = dateFormat + (timeFormat || "") + (tzFormat || "");
          configFromStringAndFormat(config);
        } else {
          config._isValid = false;
        }
      }
      function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
        var result = [
          untruncateYear(yearStr),
          defaultLocaleMonthsShort.indexOf(monthStr),
          parseInt(dayStr, 10),
          parseInt(hourStr, 10),
          parseInt(minuteStr, 10)
        ];
        if (secondStr) {
          result.push(parseInt(secondStr, 10));
        }
        return result;
      }
      function untruncateYear(yearStr) {
        var year = parseInt(yearStr, 10);
        if (year <= 49) {
          return 2e3 + year;
        } else if (year <= 999) {
          return 1900 + year;
        }
        return year;
      }
      function preprocessRFC2822(s) {
        return s.replace(/\([^)]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").replace(/^\s\s*/, "").replace(/\s\s*$/, "");
      }
      function checkWeekday(weekdayStr, parsedInput, config) {
        if (weekdayStr) {
          var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr), weekdayActual = new Date(
            parsedInput[0],
            parsedInput[1],
            parsedInput[2]
          ).getDay();
          if (weekdayProvided !== weekdayActual) {
            getParsingFlags(config).weekdayMismatch = true;
            config._isValid = false;
            return false;
          }
        }
        return true;
      }
      function calculateOffset(obsOffset, militaryOffset, numOffset) {
        if (obsOffset) {
          return obsOffsets[obsOffset];
        } else if (militaryOffset) {
          return 0;
        } else {
          var hm = parseInt(numOffset, 10), m = hm % 100, h = (hm - m) / 100;
          return h * 60 + m;
        }
      }
      function configFromRFC2822(config) {
        var match = rfc2822.exec(preprocessRFC2822(config._i)), parsedArray;
        if (match) {
          parsedArray = extractFromRFC2822Strings(
            match[4],
            match[3],
            match[2],
            match[5],
            match[6],
            match[7]
          );
          if (!checkWeekday(match[1], parsedArray, config)) {
            return;
          }
          config._a = parsedArray;
          config._tzm = calculateOffset(match[8], match[9], match[10]);
          config._d = createUTCDate.apply(null, config._a);
          config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
          getParsingFlags(config).rfc2822 = true;
        } else {
          config._isValid = false;
        }
      }
      function configFromString(config) {
        var matched = aspNetJsonRegex.exec(config._i);
        if (matched !== null) {
          config._d = new Date(+matched[1]);
          return;
        }
        configFromISO(config);
        if (config._isValid === false) {
          delete config._isValid;
        } else {
          return;
        }
        configFromRFC2822(config);
        if (config._isValid === false) {
          delete config._isValid;
        } else {
          return;
        }
        if (config._strict) {
          config._isValid = false;
        } else {
          hooks.createFromInputFallback(config);
        }
      }
      hooks.createFromInputFallback = deprecate(
        "value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.",
        function(config) {
          config._d = new Date(config._i + (config._useUTC ? " UTC" : ""));
        }
      );
      function defaults(a, b, c) {
        if (a != null) {
          return a;
        }
        if (b != null) {
          return b;
        }
        return c;
      }
      function currentDateArray(config) {
        var nowValue = new Date(hooks.now());
        if (config._useUTC) {
          return [
            nowValue.getUTCFullYear(),
            nowValue.getUTCMonth(),
            nowValue.getUTCDate()
          ];
        }
        return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
      }
      function configFromArray(config) {
        var i, date, input = [], currentDate, expectedWeekday, yearToUse;
        if (config._d) {
          return;
        }
        currentDate = currentDateArray(config);
        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
          dayOfYearFromWeekInfo(config);
        }
        if (config._dayOfYear != null) {
          yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);
          if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {
            getParsingFlags(config)._overflowDayOfYear = true;
          }
          date = createUTCDate(yearToUse, 0, config._dayOfYear);
          config._a[MONTH] = date.getUTCMonth();
          config._a[DATE] = date.getUTCDate();
        }
        for (i = 0; i < 3 && config._a[i] == null; ++i) {
          config._a[i] = input[i] = currentDate[i];
        }
        for (; i < 7; i++) {
          config._a[i] = input[i] = config._a[i] == null ? i === 2 ? 1 : 0 : config._a[i];
        }
        if (config._a[HOUR] === 24 && config._a[MINUTE] === 0 && config._a[SECOND] === 0 && config._a[MILLISECOND] === 0) {
          config._nextDay = true;
          config._a[HOUR] = 0;
        }
        config._d = (config._useUTC ? createUTCDate : createDate).apply(
          null,
          input
        );
        expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay();
        if (config._tzm != null) {
          config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
        }
        if (config._nextDay) {
          config._a[HOUR] = 24;
        }
        if (config._w && typeof config._w.d !== "undefined" && config._w.d !== expectedWeekday) {
          getParsingFlags(config).weekdayMismatch = true;
        }
      }
      function dayOfYearFromWeekInfo(config) {
        var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow, curWeek;
        w = config._w;
        if (w.GG != null || w.W != null || w.E != null) {
          dow = 1;
          doy = 4;
          weekYear = defaults(
            w.GG,
            config._a[YEAR],
            weekOfYear(createLocal(), 1, 4).year
          );
          week = defaults(w.W, 1);
          weekday = defaults(w.E, 1);
          if (weekday < 1 || weekday > 7) {
            weekdayOverflow = true;
          }
        } else {
          dow = config._locale._week.dow;
          doy = config._locale._week.doy;
          curWeek = weekOfYear(createLocal(), dow, doy);
          weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);
          week = defaults(w.w, curWeek.week);
          if (w.d != null) {
            weekday = w.d;
            if (weekday < 0 || weekday > 6) {
              weekdayOverflow = true;
            }
          } else if (w.e != null) {
            weekday = w.e + dow;
            if (w.e < 0 || w.e > 6) {
              weekdayOverflow = true;
            }
          } else {
            weekday = dow;
          }
        }
        if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
          getParsingFlags(config)._overflowWeeks = true;
        } else if (weekdayOverflow != null) {
          getParsingFlags(config)._overflowWeekday = true;
        } else {
          temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
          config._a[YEAR] = temp.year;
          config._dayOfYear = temp.dayOfYear;
        }
      }
      hooks.ISO_8601 = function() {
      };
      hooks.RFC_2822 = function() {
      };
      function configFromStringAndFormat(config) {
        if (config._f === hooks.ISO_8601) {
          configFromISO(config);
          return;
        }
        if (config._f === hooks.RFC_2822) {
          configFromRFC2822(config);
          return;
        }
        config._a = [];
        getParsingFlags(config).empty = true;
        var string2 = "" + config._i, i, parsedInput, tokens2, token2, skipped, stringLength = string2.length, totalParsedInputLength = 0, era;
        tokens2 = expandFormat(config._f, config._locale).match(formattingTokens) || [];
        for (i = 0; i < tokens2.length; i++) {
          token2 = tokens2[i];
          parsedInput = (string2.match(getParseRegexForToken(token2, config)) || [])[0];
          if (parsedInput) {
            skipped = string2.substr(0, string2.indexOf(parsedInput));
            if (skipped.length > 0) {
              getParsingFlags(config).unusedInput.push(skipped);
            }
            string2 = string2.slice(
              string2.indexOf(parsedInput) + parsedInput.length
            );
            totalParsedInputLength += parsedInput.length;
          }
          if (formatTokenFunctions[token2]) {
            if (parsedInput) {
              getParsingFlags(config).empty = false;
            } else {
              getParsingFlags(config).unusedTokens.push(token2);
            }
            addTimeToArrayFromToken(token2, parsedInput, config);
          } else if (config._strict && !parsedInput) {
            getParsingFlags(config).unusedTokens.push(token2);
          }
        }
        getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
        if (string2.length > 0) {
          getParsingFlags(config).unusedInput.push(string2);
        }
        if (config._a[HOUR] <= 12 && getParsingFlags(config).bigHour === true && config._a[HOUR] > 0) {
          getParsingFlags(config).bigHour = void 0;
        }
        getParsingFlags(config).parsedDateParts = config._a.slice(0);
        getParsingFlags(config).meridiem = config._meridiem;
        config._a[HOUR] = meridiemFixWrap(
          config._locale,
          config._a[HOUR],
          config._meridiem
        );
        era = getParsingFlags(config).era;
        if (era !== null) {
          config._a[YEAR] = config._locale.erasConvertYear(era, config._a[YEAR]);
        }
        configFromArray(config);
        checkOverflow(config);
      }
      function meridiemFixWrap(locale2, hour, meridiem2) {
        var isPm;
        if (meridiem2 == null) {
          return hour;
        }
        if (locale2.meridiemHour != null) {
          return locale2.meridiemHour(hour, meridiem2);
        } else if (locale2.isPM != null) {
          isPm = locale2.isPM(meridiem2);
          if (isPm && hour < 12) {
            hour += 12;
          }
          if (!isPm && hour === 12) {
            hour = 0;
          }
          return hour;
        } else {
          return hour;
        }
      }
      function configFromStringAndArray(config) {
        var tempConfig, bestMoment, scoreToBeat, i, currentScore, validFormatFound, bestFormatIsValid = false;
        if (config._f.length === 0) {
          getParsingFlags(config).invalidFormat = true;
          config._d = new Date(NaN);
          return;
        }
        for (i = 0; i < config._f.length; i++) {
          currentScore = 0;
          validFormatFound = false;
          tempConfig = copyConfig({}, config);
          if (config._useUTC != null) {
            tempConfig._useUTC = config._useUTC;
          }
          tempConfig._f = config._f[i];
          configFromStringAndFormat(tempConfig);
          if (isValid(tempConfig)) {
            validFormatFound = true;
          }
          currentScore += getParsingFlags(tempConfig).charsLeftOver;
          currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;
          getParsingFlags(tempConfig).score = currentScore;
          if (!bestFormatIsValid) {
            if (scoreToBeat == null || currentScore < scoreToBeat || validFormatFound) {
              scoreToBeat = currentScore;
              bestMoment = tempConfig;
              if (validFormatFound) {
                bestFormatIsValid = true;
              }
            }
          } else {
            if (currentScore < scoreToBeat) {
              scoreToBeat = currentScore;
              bestMoment = tempConfig;
            }
          }
        }
        extend(config, bestMoment || tempConfig);
      }
      function configFromObject(config) {
        if (config._d) {
          return;
        }
        var i = normalizeObjectUnits(config._i), dayOrDate = i.day === void 0 ? i.date : i.day;
        config._a = map2(
          [i.year, i.month, dayOrDate, i.hour, i.minute, i.second, i.millisecond],
          function(obj) {
            return obj && parseInt(obj, 10);
          }
        );
        configFromArray(config);
      }
      function createFromConfig(config) {
        var res = new Moment(checkOverflow(prepareConfig(config)));
        if (res._nextDay) {
          res.add(1, "d");
          res._nextDay = void 0;
        }
        return res;
      }
      function prepareConfig(config) {
        var input = config._i, format2 = config._f;
        config._locale = config._locale || getLocale(config._l);
        if (input === null || format2 === void 0 && input === "") {
          return createInvalid({ nullInput: true });
        }
        if (typeof input === "string") {
          config._i = input = config._locale.preparse(input);
        }
        if (isMoment(input)) {
          return new Moment(checkOverflow(input));
        } else if (isDate(input)) {
          config._d = input;
        } else if (isArray(format2)) {
          configFromStringAndArray(config);
        } else if (format2) {
          configFromStringAndFormat(config);
        } else {
          configFromInput(config);
        }
        if (!isValid(config)) {
          config._d = null;
        }
        return config;
      }
      function configFromInput(config) {
        var input = config._i;
        if (isUndefined(input)) {
          config._d = new Date(hooks.now());
        } else if (isDate(input)) {
          config._d = new Date(input.valueOf());
        } else if (typeof input === "string") {
          configFromString(config);
        } else if (isArray(input)) {
          config._a = map2(input.slice(0), function(obj) {
            return parseInt(obj, 10);
          });
          configFromArray(config);
        } else if (isObject(input)) {
          configFromObject(config);
        } else if (isNumber(input)) {
          config._d = new Date(input);
        } else {
          hooks.createFromInputFallback(config);
        }
      }
      function createLocalOrUTC(input, format2, locale2, strict, isUTC) {
        var c = {};
        if (format2 === true || format2 === false) {
          strict = format2;
          format2 = void 0;
        }
        if (locale2 === true || locale2 === false) {
          strict = locale2;
          locale2 = void 0;
        }
        if (isObject(input) && isObjectEmpty(input) || isArray(input) && input.length === 0) {
          input = void 0;
        }
        c._isAMomentObject = true;
        c._useUTC = c._isUTC = isUTC;
        c._l = locale2;
        c._i = input;
        c._f = format2;
        c._strict = strict;
        return createFromConfig(c);
      }
      function createLocal(input, format2, locale2, strict) {
        return createLocalOrUTC(input, format2, locale2, strict, false);
      }
      var prototypeMin = deprecate(
        "moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/",
        function() {
          var other = createLocal.apply(null, arguments);
          if (this.isValid() && other.isValid()) {
            return other < this ? this : other;
          } else {
            return createInvalid();
          }
        }
      ), prototypeMax = deprecate(
        "moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/",
        function() {
          var other = createLocal.apply(null, arguments);
          if (this.isValid() && other.isValid()) {
            return other > this ? this : other;
          } else {
            return createInvalid();
          }
        }
      );
      function pickBy(fn, moments) {
        var res, i;
        if (moments.length === 1 && isArray(moments[0])) {
          moments = moments[0];
        }
        if (!moments.length) {
          return createLocal();
        }
        res = moments[0];
        for (i = 1; i < moments.length; ++i) {
          if (!moments[i].isValid() || moments[i][fn](res)) {
            res = moments[i];
          }
        }
        return res;
      }
      function min() {
        var args = [].slice.call(arguments, 0);
        return pickBy("isBefore", args);
      }
      function max() {
        var args = [].slice.call(arguments, 0);
        return pickBy("isAfter", args);
      }
      var now = function() {
        return Date.now ? Date.now() : +new Date();
      };
      var ordering = [
        "year",
        "quarter",
        "month",
        "week",
        "day",
        "hour",
        "minute",
        "second",
        "millisecond"
      ];
      function isDurationValid(m) {
        var key, unitHasDecimal = false, i;
        for (key in m) {
          if (hasOwnProp(m, key) && !(indexOf.call(ordering, key) !== -1 && (m[key] == null || !isNaN(m[key])))) {
            return false;
          }
        }
        for (i = 0; i < ordering.length; ++i) {
          if (m[ordering[i]]) {
            if (unitHasDecimal) {
              return false;
            }
            if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
              unitHasDecimal = true;
            }
          }
        }
        return true;
      }
      function isValid$1() {
        return this._isValid;
      }
      function createInvalid$1() {
        return createDuration(NaN);
      }
      function Duration(duration) {
        var normalizedInput = normalizeObjectUnits(duration), years2 = normalizedInput.year || 0, quarters = normalizedInput.quarter || 0, months2 = normalizedInput.month || 0, weeks2 = normalizedInput.week || normalizedInput.isoWeek || 0, days2 = normalizedInput.day || 0, hours2 = normalizedInput.hour || 0, minutes2 = normalizedInput.minute || 0, seconds2 = normalizedInput.second || 0, milliseconds2 = normalizedInput.millisecond || 0;
        this._isValid = isDurationValid(normalizedInput);
        this._milliseconds = +milliseconds2 + seconds2 * 1e3 + // 1000
        minutes2 * 6e4 + // 1000 * 60
        hours2 * 1e3 * 60 * 60;
        this._days = +days2 + weeks2 * 7;
        this._months = +months2 + quarters * 3 + years2 * 12;
        this._data = {};
        this._locale = getLocale();
        this._bubble();
      }
      function isDuration(obj) {
        return obj instanceof Duration;
      }
      function absRound(number) {
        if (number < 0) {
          return Math.round(-1 * number) * -1;
        } else {
          return Math.round(number);
        }
      }
      function compareArrays(array1, array2, dontConvert) {
        var len = Math.min(array1.length, array2.length), lengthDiff = Math.abs(array1.length - array2.length), diffs = 0, i;
        for (i = 0; i < len; i++) {
          if (dontConvert && array1[i] !== array2[i] || !dontConvert && toInt(array1[i]) !== toInt(array2[i])) {
            diffs++;
          }
        }
        return diffs + lengthDiff;
      }
      function offset(token2, separator) {
        addFormatToken(token2, 0, 0, function() {
          var offset2 = this.utcOffset(), sign2 = "+";
          if (offset2 < 0) {
            offset2 = -offset2;
            sign2 = "-";
          }
          return sign2 + zeroFill(~~(offset2 / 60), 2) + separator + zeroFill(~~offset2 % 60, 2);
        });
      }
      offset("Z", ":");
      offset("ZZ", "");
      addRegexToken("Z", matchShortOffset);
      addRegexToken("ZZ", matchShortOffset);
      addParseToken(["Z", "ZZ"], function(input, array, config) {
        config._useUTC = true;
        config._tzm = offsetFromString(matchShortOffset, input);
      });
      var chunkOffset = /([\+\-]|\d\d)/gi;
      function offsetFromString(matcher, string2) {
        var matches = (string2 || "").match(matcher), chunk, parts, minutes2;
        if (matches === null) {
          return null;
        }
        chunk = matches[matches.length - 1] || [];
        parts = (chunk + "").match(chunkOffset) || ["-", 0, 0];
        minutes2 = +(parts[1] * 60) + toInt(parts[2]);
        return minutes2 === 0 ? 0 : parts[0] === "+" ? minutes2 : -minutes2;
      }
      function cloneWithOffset(input, model) {
        var res, diff2;
        if (model._isUTC) {
          res = model.clone();
          diff2 = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
          res._d.setTime(res._d.valueOf() + diff2);
          hooks.updateOffset(res, false);
          return res;
        } else {
          return createLocal(input).local();
        }
      }
      function getDateOffset(m) {
        return -Math.round(m._d.getTimezoneOffset());
      }
      hooks.updateOffset = function() {
      };
      function getSetOffset(input, keepLocalTime, keepMinutes) {
        var offset2 = this._offset || 0, localAdjust;
        if (!this.isValid()) {
          return input != null ? this : NaN;
        }
        if (input != null) {
          if (typeof input === "string") {
            input = offsetFromString(matchShortOffset, input);
            if (input === null) {
              return this;
            }
          } else if (Math.abs(input) < 16 && !keepMinutes) {
            input = input * 60;
          }
          if (!this._isUTC && keepLocalTime) {
            localAdjust = getDateOffset(this);
          }
          this._offset = input;
          this._isUTC = true;
          if (localAdjust != null) {
            this.add(localAdjust, "m");
          }
          if (offset2 !== input) {
            if (!keepLocalTime || this._changeInProgress) {
              addSubtract(
                this,
                createDuration(input - offset2, "m"),
                1,
                false
              );
            } else if (!this._changeInProgress) {
              this._changeInProgress = true;
              hooks.updateOffset(this, true);
              this._changeInProgress = null;
            }
          }
          return this;
        } else {
          return this._isUTC ? offset2 : getDateOffset(this);
        }
      }
      function getSetZone(input, keepLocalTime) {
        if (input != null) {
          if (typeof input !== "string") {
            input = -input;
          }
          this.utcOffset(input, keepLocalTime);
          return this;
        } else {
          return -this.utcOffset();
        }
      }
      function setOffsetToUTC(keepLocalTime) {
        return this.utcOffset(0, keepLocalTime);
      }
      function setOffsetToLocal(keepLocalTime) {
        if (this._isUTC) {
          this.utcOffset(0, keepLocalTime);
          this._isUTC = false;
          if (keepLocalTime) {
            this.subtract(getDateOffset(this), "m");
          }
        }
        return this;
      }
      function setOffsetToParsedOffset() {
        if (this._tzm != null) {
          this.utcOffset(this._tzm, false, true);
        } else if (typeof this._i === "string") {
          var tZone = offsetFromString(matchOffset, this._i);
          if (tZone != null) {
            this.utcOffset(tZone);
          } else {
            this.utcOffset(0, true);
          }
        }
        return this;
      }
      function hasAlignedHourOffset(input) {
        if (!this.isValid()) {
          return false;
        }
        input = input ? createLocal(input).utcOffset() : 0;
        return (this.utcOffset() - input) % 60 === 0;
      }
      function isDaylightSavingTime() {
        return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();
      }
      function isDaylightSavingTimeShifted() {
        if (!isUndefined(this._isDSTShifted)) {
          return this._isDSTShifted;
        }
        var c = {}, other;
        copyConfig(c, this);
        c = prepareConfig(c);
        if (c._a) {
          other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
          this._isDSTShifted = this.isValid() && compareArrays(c._a, other.toArray()) > 0;
        } else {
          this._isDSTShifted = false;
        }
        return this._isDSTShifted;
      }
      function isLocal() {
        return this.isValid() ? !this._isUTC : false;
      }
      function isUtcOffset() {
        return this.isValid() ? this._isUTC : false;
      }
      function isUtc() {
        return this.isValid() ? this._isUTC && this._offset === 0 : false;
      }
      var aspNetRegex = /^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)?)?$/, isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
      function createDuration(input, key) {
        var duration = input, match = null, sign2, ret, diffRes;
        if (isDuration(input)) {
          duration = {
            ms: input._milliseconds,
            d: input._days,
            M: input._months
          };
        } else if (isNumber(input) || !isNaN(+input)) {
          duration = {};
          if (key) {
            duration[key] = +input;
          } else {
            duration.milliseconds = +input;
          }
        } else if (match = aspNetRegex.exec(input)) {
          sign2 = match[1] === "-" ? -1 : 1;
          duration = {
            y: 0,
            d: toInt(match[DATE]) * sign2,
            h: toInt(match[HOUR]) * sign2,
            m: toInt(match[MINUTE]) * sign2,
            s: toInt(match[SECOND]) * sign2,
            ms: toInt(absRound(match[MILLISECOND] * 1e3)) * sign2
            // the millisecond decimal point is included in the match
          };
        } else if (match = isoRegex.exec(input)) {
          sign2 = match[1] === "-" ? -1 : 1;
          duration = {
            y: parseIso(match[2], sign2),
            M: parseIso(match[3], sign2),
            w: parseIso(match[4], sign2),
            d: parseIso(match[5], sign2),
            h: parseIso(match[6], sign2),
            m: parseIso(match[7], sign2),
            s: parseIso(match[8], sign2)
          };
        } else if (duration == null) {
          duration = {};
        } else if (typeof duration === "object" && ("from" in duration || "to" in duration)) {
          diffRes = momentsDifference(
            createLocal(duration.from),
            createLocal(duration.to)
          );
          duration = {};
          duration.ms = diffRes.milliseconds;
          duration.M = diffRes.months;
        }
        ret = new Duration(duration);
        if (isDuration(input) && hasOwnProp(input, "_locale")) {
          ret._locale = input._locale;
        }
        if (isDuration(input) && hasOwnProp(input, "_isValid")) {
          ret._isValid = input._isValid;
        }
        return ret;
      }
      createDuration.fn = Duration.prototype;
      createDuration.invalid = createInvalid$1;
      function parseIso(inp, sign2) {
        var res = inp && parseFloat(inp.replace(",", "."));
        return (isNaN(res) ? 0 : res) * sign2;
      }
      function positiveMomentsDifference(base, other) {
        var res = {};
        res.months = other.month() - base.month() + (other.year() - base.year()) * 12;
        if (base.clone().add(res.months, "M").isAfter(other)) {
          --res.months;
        }
        res.milliseconds = +other - +base.clone().add(res.months, "M");
        return res;
      }
      function momentsDifference(base, other) {
        var res;
        if (!(base.isValid() && other.isValid())) {
          return { milliseconds: 0, months: 0 };
        }
        other = cloneWithOffset(other, base);
        if (base.isBefore(other)) {
          res = positiveMomentsDifference(base, other);
        } else {
          res = positiveMomentsDifference(other, base);
          res.milliseconds = -res.milliseconds;
          res.months = -res.months;
        }
        return res;
      }
      function createAdder(direction, name) {
        return function(val, period) {
          var dur, tmp;
          if (period !== null && !isNaN(+period)) {
            deprecateSimple(
              name,
              "moment()." + name + "(period, number) is deprecated. Please use moment()." + name + "(number, period). See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info."
            );
            tmp = val;
            val = period;
            period = tmp;
          }
          dur = createDuration(val, period);
          addSubtract(this, dur, direction);
          return this;
        };
      }
      function addSubtract(mom, duration, isAdding, updateOffset) {
        var milliseconds2 = duration._milliseconds, days2 = absRound(duration._days), months2 = absRound(duration._months);
        if (!mom.isValid()) {
          return;
        }
        updateOffset = updateOffset == null ? true : updateOffset;
        if (months2) {
          setMonth(mom, get(mom, "Month") + months2 * isAdding);
        }
        if (days2) {
          set$1(mom, "Date", get(mom, "Date") + days2 * isAdding);
        }
        if (milliseconds2) {
          mom._d.setTime(mom._d.valueOf() + milliseconds2 * isAdding);
        }
        if (updateOffset) {
          hooks.updateOffset(mom, days2 || months2);
        }
      }
      var add = createAdder(1, "add"), subtract = createAdder(-1, "subtract");
      function isString(input) {
        return typeof input === "string" || input instanceof String;
      }
      function isMomentInput(input) {
        return isMoment(input) || isDate(input) || isString(input) || isNumber(input) || isNumberOrStringArray(input) || isMomentInputObject(input) || input === null || input === void 0;
      }
      function isMomentInputObject(input) {
        var objectTest = isObject(input) && !isObjectEmpty(input), propertyTest = false, properties = [
          "years",
          "year",
          "y",
          "months",
          "month",
          "M",
          "days",
          "day",
          "d",
          "dates",
          "date",
          "D",
          "hours",
          "hour",
          "h",
          "minutes",
          "minute",
          "m",
          "seconds",
          "second",
          "s",
          "milliseconds",
          "millisecond",
          "ms"
        ], i, property;
        for (i = 0; i < properties.length; i += 1) {
          property = properties[i];
          propertyTest = propertyTest || hasOwnProp(input, property);
        }
        return objectTest && propertyTest;
      }
      function isNumberOrStringArray(input) {
        var arrayTest = isArray(input), dataTypeTest = false;
        if (arrayTest) {
          dataTypeTest = input.filter(function(item) {
            return !isNumber(item) && isString(input);
          }).length === 0;
        }
        return arrayTest && dataTypeTest;
      }
      function isCalendarSpec(input) {
        var objectTest = isObject(input) && !isObjectEmpty(input), propertyTest = false, properties = [
          "sameDay",
          "nextDay",
          "lastDay",
          "nextWeek",
          "lastWeek",
          "sameElse"
        ], i, property;
        for (i = 0; i < properties.length; i += 1) {
          property = properties[i];
          propertyTest = propertyTest || hasOwnProp(input, property);
        }
        return objectTest && propertyTest;
      }
      function getCalendarFormat(myMoment, now2) {
        var diff2 = myMoment.diff(now2, "days", true);
        return diff2 < -6 ? "sameElse" : diff2 < -1 ? "lastWeek" : diff2 < 0 ? "lastDay" : diff2 < 1 ? "sameDay" : diff2 < 2 ? "nextDay" : diff2 < 7 ? "nextWeek" : "sameElse";
      }
      function calendar$1(time, formats) {
        if (arguments.length === 1) {
          if (!arguments[0]) {
            time = void 0;
            formats = void 0;
          } else if (isMomentInput(arguments[0])) {
            time = arguments[0];
            formats = void 0;
          } else if (isCalendarSpec(arguments[0])) {
            formats = arguments[0];
            time = void 0;
          }
        }
        var now2 = time || createLocal(), sod = cloneWithOffset(now2, this).startOf("day"), format2 = hooks.calendarFormat(this, sod) || "sameElse", output = formats && (isFunction(formats[format2]) ? formats[format2].call(this, now2) : formats[format2]);
        return this.format(
          output || this.localeData().calendar(format2, this, createLocal(now2))
        );
      }
      function clone() {
        return new Moment(this);
      }
      function isAfter(input, units) {
        var localInput = isMoment(input) ? input : createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
          return false;
        }
        units = normalizeUnits(units) || "millisecond";
        if (units === "millisecond") {
          return this.valueOf() > localInput.valueOf();
        } else {
          return localInput.valueOf() < this.clone().startOf(units).valueOf();
        }
      }
      function isBefore(input, units) {
        var localInput = isMoment(input) ? input : createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
          return false;
        }
        units = normalizeUnits(units) || "millisecond";
        if (units === "millisecond") {
          return this.valueOf() < localInput.valueOf();
        } else {
          return this.clone().endOf(units).valueOf() < localInput.valueOf();
        }
      }
      function isBetween(from2, to2, units, inclusivity) {
        var localFrom = isMoment(from2) ? from2 : createLocal(from2), localTo = isMoment(to2) ? to2 : createLocal(to2);
        if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
          return false;
        }
        inclusivity = inclusivity || "()";
        return (inclusivity[0] === "(" ? this.isAfter(localFrom, units) : !this.isBefore(localFrom, units)) && (inclusivity[1] === ")" ? this.isBefore(localTo, units) : !this.isAfter(localTo, units));
      }
      function isSame(input, units) {
        var localInput = isMoment(input) ? input : createLocal(input), inputMs;
        if (!(this.isValid() && localInput.isValid())) {
          return false;
        }
        units = normalizeUnits(units) || "millisecond";
        if (units === "millisecond") {
          return this.valueOf() === localInput.valueOf();
        } else {
          inputMs = localInput.valueOf();
          return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
        }
      }
      function isSameOrAfter(input, units) {
        return this.isSame(input, units) || this.isAfter(input, units);
      }
      function isSameOrBefore(input, units) {
        return this.isSame(input, units) || this.isBefore(input, units);
      }
      function diff(input, units, asFloat) {
        var that, zoneDelta, output;
        if (!this.isValid()) {
          return NaN;
        }
        that = cloneWithOffset(input, this);
        if (!that.isValid()) {
          return NaN;
        }
        zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;
        units = normalizeUnits(units);
        switch (units) {
          case "year":
            output = monthDiff(this, that) / 12;
            break;
          case "month":
            output = monthDiff(this, that);
            break;
          case "quarter":
            output = monthDiff(this, that) / 3;
            break;
          case "second":
            output = (this - that) / 1e3;
            break;
          case "minute":
            output = (this - that) / 6e4;
            break;
          case "hour":
            output = (this - that) / 36e5;
            break;
          case "day":
            output = (this - that - zoneDelta) / 864e5;
            break;
          case "week":
            output = (this - that - zoneDelta) / 6048e5;
            break;
          default:
            output = this - that;
        }
        return asFloat ? output : absFloor(output);
      }
      function monthDiff(a, b) {
        if (a.date() < b.date()) {
          return -monthDiff(b, a);
        }
        var wholeMonthDiff = (b.year() - a.year()) * 12 + (b.month() - a.month()), anchor = a.clone().add(wholeMonthDiff, "months"), anchor2, adjust;
        if (b - anchor < 0) {
          anchor2 = a.clone().add(wholeMonthDiff - 1, "months");
          adjust = (b - anchor) / (anchor - anchor2);
        } else {
          anchor2 = a.clone().add(wholeMonthDiff + 1, "months");
          adjust = (b - anchor) / (anchor2 - anchor);
        }
        return -(wholeMonthDiff + adjust) || 0;
      }
      hooks.defaultFormat = "YYYY-MM-DDTHH:mm:ssZ";
      hooks.defaultFormatUtc = "YYYY-MM-DDTHH:mm:ss[Z]";
      function toString() {
        return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
      }
      function toISOString(keepOffset) {
        if (!this.isValid()) {
          return null;
        }
        var utc = keepOffset !== true, m = utc ? this.clone().utc() : this;
        if (m.year() < 0 || m.year() > 9999) {
          return formatMoment(
            m,
            utc ? "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYYYY-MM-DD[T]HH:mm:ss.SSSZ"
          );
        }
        if (isFunction(Date.prototype.toISOString)) {
          if (utc) {
            return this.toDate().toISOString();
          } else {
            return new Date(this.valueOf() + this.utcOffset() * 60 * 1e3).toISOString().replace("Z", formatMoment(m, "Z"));
          }
        }
        return formatMoment(
          m,
          utc ? "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYY-MM-DD[T]HH:mm:ss.SSSZ"
        );
      }
      function inspect() {
        if (!this.isValid()) {
          return "moment.invalid(/* " + this._i + " */)";
        }
        var func = "moment", zone = "", prefix, year, datetime, suffix;
        if (!this.isLocal()) {
          func = this.utcOffset() === 0 ? "moment.utc" : "moment.parseZone";
          zone = "Z";
        }
        prefix = "[" + func + '("]';
        year = 0 <= this.year() && this.year() <= 9999 ? "YYYY" : "YYYYYY";
        datetime = "-MM-DD[T]HH:mm:ss.SSS";
        suffix = zone + '[")]';
        return this.format(prefix + year + datetime + suffix);
      }
      function format(inputString) {
        if (!inputString) {
          inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
        }
        var output = formatMoment(this, inputString);
        return this.localeData().postformat(output);
      }
      function from(time, withoutSuffix) {
        if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
          return createDuration({ to: this, from: time }).locale(this.locale()).humanize(!withoutSuffix);
        } else {
          return this.localeData().invalidDate();
        }
      }
      function fromNow(withoutSuffix) {
        return this.from(createLocal(), withoutSuffix);
      }
      function to(time, withoutSuffix) {
        if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
          return createDuration({ from: this, to: time }).locale(this.locale()).humanize(!withoutSuffix);
        } else {
          return this.localeData().invalidDate();
        }
      }
      function toNow(withoutSuffix) {
        return this.to(createLocal(), withoutSuffix);
      }
      function locale(key) {
        var newLocaleData;
        if (key === void 0) {
          return this._locale._abbr;
        } else {
          newLocaleData = getLocale(key);
          if (newLocaleData != null) {
            this._locale = newLocaleData;
          }
          return this;
        }
      }
      var lang = deprecate(
        "moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.",
        function(key) {
          if (key === void 0) {
            return this.localeData();
          } else {
            return this.locale(key);
          }
        }
      );
      function localeData() {
        return this._locale;
      }
      var MS_PER_SECOND = 1e3, MS_PER_MINUTE = 60 * MS_PER_SECOND, MS_PER_HOUR = 60 * MS_PER_MINUTE, MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;
      function mod$1(dividend, divisor) {
        return (dividend % divisor + divisor) % divisor;
      }
      function localStartOfDate(y, m, d) {
        if (y < 100 && y >= 0) {
          return new Date(y + 400, m, d) - MS_PER_400_YEARS;
        } else {
          return new Date(y, m, d).valueOf();
        }
      }
      function utcStartOfDate(y, m, d) {
        if (y < 100 && y >= 0) {
          return Date.UTC(y + 400, m, d) - MS_PER_400_YEARS;
        } else {
          return Date.UTC(y, m, d);
        }
      }
      function startOf(units) {
        var time, startOfDate;
        units = normalizeUnits(units);
        if (units === void 0 || units === "millisecond" || !this.isValid()) {
          return this;
        }
        startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
        switch (units) {
          case "year":
            time = startOfDate(this.year(), 0, 1);
            break;
          case "quarter":
            time = startOfDate(
              this.year(),
              this.month() - this.month() % 3,
              1
            );
            break;
          case "month":
            time = startOfDate(this.year(), this.month(), 1);
            break;
          case "week":
            time = startOfDate(
              this.year(),
              this.month(),
              this.date() - this.weekday()
            );
            break;
          case "isoWeek":
            time = startOfDate(
              this.year(),
              this.month(),
              this.date() - (this.isoWeekday() - 1)
            );
            break;
          case "day":
          case "date":
            time = startOfDate(this.year(), this.month(), this.date());
            break;
          case "hour":
            time = this._d.valueOf();
            time -= mod$1(
              time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
              MS_PER_HOUR
            );
            break;
          case "minute":
            time = this._d.valueOf();
            time -= mod$1(time, MS_PER_MINUTE);
            break;
          case "second":
            time = this._d.valueOf();
            time -= mod$1(time, MS_PER_SECOND);
            break;
        }
        this._d.setTime(time);
        hooks.updateOffset(this, true);
        return this;
      }
      function endOf(units) {
        var time, startOfDate;
        units = normalizeUnits(units);
        if (units === void 0 || units === "millisecond" || !this.isValid()) {
          return this;
        }
        startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
        switch (units) {
          case "year":
            time = startOfDate(this.year() + 1, 0, 1) - 1;
            break;
          case "quarter":
            time = startOfDate(
              this.year(),
              this.month() - this.month() % 3 + 3,
              1
            ) - 1;
            break;
          case "month":
            time = startOfDate(this.year(), this.month() + 1, 1) - 1;
            break;
          case "week":
            time = startOfDate(
              this.year(),
              this.month(),
              this.date() - this.weekday() + 7
            ) - 1;
            break;
          case "isoWeek":
            time = startOfDate(
              this.year(),
              this.month(),
              this.date() - (this.isoWeekday() - 1) + 7
            ) - 1;
            break;
          case "day":
          case "date":
            time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
            break;
          case "hour":
            time = this._d.valueOf();
            time += MS_PER_HOUR - mod$1(
              time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
              MS_PER_HOUR
            ) - 1;
            break;
          case "minute":
            time = this._d.valueOf();
            time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
            break;
          case "second":
            time = this._d.valueOf();
            time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
            break;
        }
        this._d.setTime(time);
        hooks.updateOffset(this, true);
        return this;
      }
      function valueOf() {
        return this._d.valueOf() - (this._offset || 0) * 6e4;
      }
      function unix() {
        return Math.floor(this.valueOf() / 1e3);
      }
      function toDate() {
        return new Date(this.valueOf());
      }
      function toArray() {
        var m = this;
        return [
          m.year(),
          m.month(),
          m.date(),
          m.hour(),
          m.minute(),
          m.second(),
          m.millisecond()
        ];
      }
      function toObject() {
        var m = this;
        return {
          years: m.year(),
          months: m.month(),
          date: m.date(),
          hours: m.hours(),
          minutes: m.minutes(),
          seconds: m.seconds(),
          milliseconds: m.milliseconds()
        };
      }
      function toJSON() {
        return this.isValid() ? this.toISOString() : null;
      }
      function isValid$2() {
        return isValid(this);
      }
      function parsingFlags() {
        return extend({}, getParsingFlags(this));
      }
      function invalidAt() {
        return getParsingFlags(this).overflow;
      }
      function creationData() {
        return {
          input: this._i,
          format: this._f,
          locale: this._locale,
          isUTC: this._isUTC,
          strict: this._strict
        };
      }
      addFormatToken("N", 0, 0, "eraAbbr");
      addFormatToken("NN", 0, 0, "eraAbbr");
      addFormatToken("NNN", 0, 0, "eraAbbr");
      addFormatToken("NNNN", 0, 0, "eraName");
      addFormatToken("NNNNN", 0, 0, "eraNarrow");
      addFormatToken("y", ["y", 1], "yo", "eraYear");
      addFormatToken("y", ["yy", 2], 0, "eraYear");
      addFormatToken("y", ["yyy", 3], 0, "eraYear");
      addFormatToken("y", ["yyyy", 4], 0, "eraYear");
      addRegexToken("N", matchEraAbbr);
      addRegexToken("NN", matchEraAbbr);
      addRegexToken("NNN", matchEraAbbr);
      addRegexToken("NNNN", matchEraName);
      addRegexToken("NNNNN", matchEraNarrow);
      addParseToken(["N", "NN", "NNN", "NNNN", "NNNNN"], function(input, array, config, token2) {
        var era = config._locale.erasParse(input, token2, config._strict);
        if (era) {
          getParsingFlags(config).era = era;
        } else {
          getParsingFlags(config).invalidEra = input;
        }
      });
      addRegexToken("y", matchUnsigned);
      addRegexToken("yy", matchUnsigned);
      addRegexToken("yyy", matchUnsigned);
      addRegexToken("yyyy", matchUnsigned);
      addRegexToken("yo", matchEraYearOrdinal);
      addParseToken(["y", "yy", "yyy", "yyyy"], YEAR);
      addParseToken(["yo"], function(input, array, config, token2) {
        var match;
        if (config._locale._eraYearOrdinalRegex) {
          match = input.match(config._locale._eraYearOrdinalRegex);
        }
        if (config._locale.eraYearOrdinalParse) {
          array[YEAR] = config._locale.eraYearOrdinalParse(input, match);
        } else {
          array[YEAR] = parseInt(input, 10);
        }
      });
      function localeEras(m, format2) {
        var i, l, date, eras = this._eras || getLocale("en")._eras;
        for (i = 0, l = eras.length; i < l; ++i) {
          switch (typeof eras[i].since) {
            case "string":
              date = hooks(eras[i].since).startOf("day");
              eras[i].since = date.valueOf();
              break;
          }
          switch (typeof eras[i].until) {
            case "undefined":
              eras[i].until = Infinity;
              break;
            case "string":
              date = hooks(eras[i].until).startOf("day").valueOf();
              eras[i].until = date.valueOf();
              break;
          }
        }
        return eras;
      }
      function localeErasParse(eraName, format2, strict) {
        var i, l, eras = this.eras(), name, abbr, narrow;
        eraName = eraName.toUpperCase();
        for (i = 0, l = eras.length; i < l; ++i) {
          name = eras[i].name.toUpperCase();
          abbr = eras[i].abbr.toUpperCase();
          narrow = eras[i].narrow.toUpperCase();
          if (strict) {
            switch (format2) {
              case "N":
              case "NN":
              case "NNN":
                if (abbr === eraName) {
                  return eras[i];
                }
                break;
              case "NNNN":
                if (name === eraName) {
                  return eras[i];
                }
                break;
              case "NNNNN":
                if (narrow === eraName) {
                  return eras[i];
                }
                break;
            }
          } else if ([name, abbr, narrow].indexOf(eraName) >= 0) {
            return eras[i];
          }
        }
      }
      function localeErasConvertYear(era, year) {
        var dir = era.since <= era.until ? 1 : -1;
        if (year === void 0) {
          return hooks(era.since).year();
        } else {
          return hooks(era.since).year() + (year - era.offset) * dir;
        }
      }
      function getEraName() {
        var i, l, val, eras = this.localeData().eras();
        for (i = 0, l = eras.length; i < l; ++i) {
          val = this.clone().startOf("day").valueOf();
          if (eras[i].since <= val && val <= eras[i].until) {
            return eras[i].name;
          }
          if (eras[i].until <= val && val <= eras[i].since) {
            return eras[i].name;
          }
        }
        return "";
      }
      function getEraNarrow() {
        var i, l, val, eras = this.localeData().eras();
        for (i = 0, l = eras.length; i < l; ++i) {
          val = this.clone().startOf("day").valueOf();
          if (eras[i].since <= val && val <= eras[i].until) {
            return eras[i].narrow;
          }
          if (eras[i].until <= val && val <= eras[i].since) {
            return eras[i].narrow;
          }
        }
        return "";
      }
      function getEraAbbr() {
        var i, l, val, eras = this.localeData().eras();
        for (i = 0, l = eras.length; i < l; ++i) {
          val = this.clone().startOf("day").valueOf();
          if (eras[i].since <= val && val <= eras[i].until) {
            return eras[i].abbr;
          }
          if (eras[i].until <= val && val <= eras[i].since) {
            return eras[i].abbr;
          }
        }
        return "";
      }
      function getEraYear() {
        var i, l, dir, val, eras = this.localeData().eras();
        for (i = 0, l = eras.length; i < l; ++i) {
          dir = eras[i].since <= eras[i].until ? 1 : -1;
          val = this.clone().startOf("day").valueOf();
          if (eras[i].since <= val && val <= eras[i].until || eras[i].until <= val && val <= eras[i].since) {
            return (this.year() - hooks(eras[i].since).year()) * dir + eras[i].offset;
          }
        }
        return this.year();
      }
      function erasNameRegex(isStrict) {
        if (!hasOwnProp(this, "_erasNameRegex")) {
          computeErasParse.call(this);
        }
        return isStrict ? this._erasNameRegex : this._erasRegex;
      }
      function erasAbbrRegex(isStrict) {
        if (!hasOwnProp(this, "_erasAbbrRegex")) {
          computeErasParse.call(this);
        }
        return isStrict ? this._erasAbbrRegex : this._erasRegex;
      }
      function erasNarrowRegex(isStrict) {
        if (!hasOwnProp(this, "_erasNarrowRegex")) {
          computeErasParse.call(this);
        }
        return isStrict ? this._erasNarrowRegex : this._erasRegex;
      }
      function matchEraAbbr(isStrict, locale2) {
        return locale2.erasAbbrRegex(isStrict);
      }
      function matchEraName(isStrict, locale2) {
        return locale2.erasNameRegex(isStrict);
      }
      function matchEraNarrow(isStrict, locale2) {
        return locale2.erasNarrowRegex(isStrict);
      }
      function matchEraYearOrdinal(isStrict, locale2) {
        return locale2._eraYearOrdinalRegex || matchUnsigned;
      }
      function computeErasParse() {
        var abbrPieces = [], namePieces = [], narrowPieces = [], mixedPieces = [], i, l, eras = this.eras();
        for (i = 0, l = eras.length; i < l; ++i) {
          namePieces.push(regexEscape(eras[i].name));
          abbrPieces.push(regexEscape(eras[i].abbr));
          narrowPieces.push(regexEscape(eras[i].narrow));
          mixedPieces.push(regexEscape(eras[i].name));
          mixedPieces.push(regexEscape(eras[i].abbr));
          mixedPieces.push(regexEscape(eras[i].narrow));
        }
        this._erasRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
        this._erasNameRegex = new RegExp("^(" + namePieces.join("|") + ")", "i");
        this._erasAbbrRegex = new RegExp("^(" + abbrPieces.join("|") + ")", "i");
        this._erasNarrowRegex = new RegExp(
          "^(" + narrowPieces.join("|") + ")",
          "i"
        );
      }
      addFormatToken(0, ["gg", 2], 0, function() {
        return this.weekYear() % 100;
      });
      addFormatToken(0, ["GG", 2], 0, function() {
        return this.isoWeekYear() % 100;
      });
      function addWeekYearFormatToken(token2, getter) {
        addFormatToken(0, [token2, token2.length], 0, getter);
      }
      addWeekYearFormatToken("gggg", "weekYear");
      addWeekYearFormatToken("ggggg", "weekYear");
      addWeekYearFormatToken("GGGG", "isoWeekYear");
      addWeekYearFormatToken("GGGGG", "isoWeekYear");
      addUnitAlias("weekYear", "gg");
      addUnitAlias("isoWeekYear", "GG");
      addUnitPriority("weekYear", 1);
      addUnitPriority("isoWeekYear", 1);
      addRegexToken("G", matchSigned);
      addRegexToken("g", matchSigned);
      addRegexToken("GG", match1to2, match2);
      addRegexToken("gg", match1to2, match2);
      addRegexToken("GGGG", match1to4, match4);
      addRegexToken("gggg", match1to4, match4);
      addRegexToken("GGGGG", match1to6, match6);
      addRegexToken("ggggg", match1to6, match6);
      addWeekParseToken(["gggg", "ggggg", "GGGG", "GGGGG"], function(input, week, config, token2) {
        week[token2.substr(0, 2)] = toInt(input);
      });
      addWeekParseToken(["gg", "GG"], function(input, week, config, token2) {
        week[token2] = hooks.parseTwoDigitYear(input);
      });
      function getSetWeekYear(input) {
        return getSetWeekYearHelper.call(
          this,
          input,
          this.week(),
          this.weekday(),
          this.localeData()._week.dow,
          this.localeData()._week.doy
        );
      }
      function getSetISOWeekYear(input) {
        return getSetWeekYearHelper.call(
          this,
          input,
          this.isoWeek(),
          this.isoWeekday(),
          1,
          4
        );
      }
      function getISOWeeksInYear() {
        return weeksInYear(this.year(), 1, 4);
      }
      function getISOWeeksInISOWeekYear() {
        return weeksInYear(this.isoWeekYear(), 1, 4);
      }
      function getWeeksInYear() {
        var weekInfo = this.localeData()._week;
        return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
      }
      function getWeeksInWeekYear() {
        var weekInfo = this.localeData()._week;
        return weeksInYear(this.weekYear(), weekInfo.dow, weekInfo.doy);
      }
      function getSetWeekYearHelper(input, week, weekday, dow, doy) {
        var weeksTarget;
        if (input == null) {
          return weekOfYear(this, dow, doy).year;
        } else {
          weeksTarget = weeksInYear(input, dow, doy);
          if (week > weeksTarget) {
            week = weeksTarget;
          }
          return setWeekAll.call(this, input, week, weekday, dow, doy);
        }
      }
      function setWeekAll(weekYear, week, weekday, dow, doy) {
        var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy), date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);
        this.year(date.getUTCFullYear());
        this.month(date.getUTCMonth());
        this.date(date.getUTCDate());
        return this;
      }
      addFormatToken("Q", 0, "Qo", "quarter");
      addUnitAlias("quarter", "Q");
      addUnitPriority("quarter", 7);
      addRegexToken("Q", match1);
      addParseToken("Q", function(input, array) {
        array[MONTH] = (toInt(input) - 1) * 3;
      });
      function getSetQuarter(input) {
        return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
      }
      addFormatToken("D", ["DD", 2], "Do", "date");
      addUnitAlias("date", "D");
      addUnitPriority("date", 9);
      addRegexToken("D", match1to2);
      addRegexToken("DD", match1to2, match2);
      addRegexToken("Do", function(isStrict, locale2) {
        return isStrict ? locale2._dayOfMonthOrdinalParse || locale2._ordinalParse : locale2._dayOfMonthOrdinalParseLenient;
      });
      addParseToken(["D", "DD"], DATE);
      addParseToken("Do", function(input, array) {
        array[DATE] = toInt(input.match(match1to2)[0]);
      });
      var getSetDayOfMonth = makeGetSet("Date", true);
      addFormatToken("DDD", ["DDDD", 3], "DDDo", "dayOfYear");
      addUnitAlias("dayOfYear", "DDD");
      addUnitPriority("dayOfYear", 4);
      addRegexToken("DDD", match1to3);
      addRegexToken("DDDD", match3);
      addParseToken(["DDD", "DDDD"], function(input, array, config) {
        config._dayOfYear = toInt(input);
      });
      function getSetDayOfYear(input) {
        var dayOfYear = Math.round(
          (this.clone().startOf("day") - this.clone().startOf("year")) / 864e5
        ) + 1;
        return input == null ? dayOfYear : this.add(input - dayOfYear, "d");
      }
      addFormatToken("m", ["mm", 2], 0, "minute");
      addUnitAlias("minute", "m");
      addUnitPriority("minute", 14);
      addRegexToken("m", match1to2);
      addRegexToken("mm", match1to2, match2);
      addParseToken(["m", "mm"], MINUTE);
      var getSetMinute = makeGetSet("Minutes", false);
      addFormatToken("s", ["ss", 2], 0, "second");
      addUnitAlias("second", "s");
      addUnitPriority("second", 15);
      addRegexToken("s", match1to2);
      addRegexToken("ss", match1to2, match2);
      addParseToken(["s", "ss"], SECOND);
      var getSetSecond = makeGetSet("Seconds", false);
      addFormatToken("S", 0, 0, function() {
        return ~~(this.millisecond() / 100);
      });
      addFormatToken(0, ["SS", 2], 0, function() {
        return ~~(this.millisecond() / 10);
      });
      addFormatToken(0, ["SSS", 3], 0, "millisecond");
      addFormatToken(0, ["SSSS", 4], 0, function() {
        return this.millisecond() * 10;
      });
      addFormatToken(0, ["SSSSS", 5], 0, function() {
        return this.millisecond() * 100;
      });
      addFormatToken(0, ["SSSSSS", 6], 0, function() {
        return this.millisecond() * 1e3;
      });
      addFormatToken(0, ["SSSSSSS", 7], 0, function() {
        return this.millisecond() * 1e4;
      });
      addFormatToken(0, ["SSSSSSSS", 8], 0, function() {
        return this.millisecond() * 1e5;
      });
      addFormatToken(0, ["SSSSSSSSS", 9], 0, function() {
        return this.millisecond() * 1e6;
      });
      addUnitAlias("millisecond", "ms");
      addUnitPriority("millisecond", 16);
      addRegexToken("S", match1to3, match1);
      addRegexToken("SS", match1to3, match2);
      addRegexToken("SSS", match1to3, match3);
      var token, getSetMillisecond;
      for (token = "SSSS"; token.length <= 9; token += "S") {
        addRegexToken(token, matchUnsigned);
      }
      function parseMs(input, array) {
        array[MILLISECOND] = toInt(("0." + input) * 1e3);
      }
      for (token = "S"; token.length <= 9; token += "S") {
        addParseToken(token, parseMs);
      }
      getSetMillisecond = makeGetSet("Milliseconds", false);
      addFormatToken("z", 0, 0, "zoneAbbr");
      addFormatToken("zz", 0, 0, "zoneName");
      function getZoneAbbr() {
        return this._isUTC ? "UTC" : "";
      }
      function getZoneName() {
        return this._isUTC ? "Coordinated Universal Time" : "";
      }
      var proto = Moment.prototype;
      proto.add = add;
      proto.calendar = calendar$1;
      proto.clone = clone;
      proto.diff = diff;
      proto.endOf = endOf;
      proto.format = format;
      proto.from = from;
      proto.fromNow = fromNow;
      proto.to = to;
      proto.toNow = toNow;
      proto.get = stringGet;
      proto.invalidAt = invalidAt;
      proto.isAfter = isAfter;
      proto.isBefore = isBefore;
      proto.isBetween = isBetween;
      proto.isSame = isSame;
      proto.isSameOrAfter = isSameOrAfter;
      proto.isSameOrBefore = isSameOrBefore;
      proto.isValid = isValid$2;
      proto.lang = lang;
      proto.locale = locale;
      proto.localeData = localeData;
      proto.max = prototypeMax;
      proto.min = prototypeMin;
      proto.parsingFlags = parsingFlags;
      proto.set = stringSet;
      proto.startOf = startOf;
      proto.subtract = subtract;
      proto.toArray = toArray;
      proto.toObject = toObject;
      proto.toDate = toDate;
      proto.toISOString = toISOString;
      proto.inspect = inspect;
      if (typeof Symbol !== "undefined" && Symbol.for != null) {
        proto[Symbol.for("nodejs.util.inspect.custom")] = function() {
          return "Moment<" + this.format() + ">";
        };
      }
      proto.toJSON = toJSON;
      proto.toString = toString;
      proto.unix = unix;
      proto.valueOf = valueOf;
      proto.creationData = creationData;
      proto.eraName = getEraName;
      proto.eraNarrow = getEraNarrow;
      proto.eraAbbr = getEraAbbr;
      proto.eraYear = getEraYear;
      proto.year = getSetYear;
      proto.isLeapYear = getIsLeapYear;
      proto.weekYear = getSetWeekYear;
      proto.isoWeekYear = getSetISOWeekYear;
      proto.quarter = proto.quarters = getSetQuarter;
      proto.month = getSetMonth;
      proto.daysInMonth = getDaysInMonth;
      proto.week = proto.weeks = getSetWeek;
      proto.isoWeek = proto.isoWeeks = getSetISOWeek;
      proto.weeksInYear = getWeeksInYear;
      proto.weeksInWeekYear = getWeeksInWeekYear;
      proto.isoWeeksInYear = getISOWeeksInYear;
      proto.isoWeeksInISOWeekYear = getISOWeeksInISOWeekYear;
      proto.date = getSetDayOfMonth;
      proto.day = proto.days = getSetDayOfWeek;
      proto.weekday = getSetLocaleDayOfWeek;
      proto.isoWeekday = getSetISODayOfWeek;
      proto.dayOfYear = getSetDayOfYear;
      proto.hour = proto.hours = getSetHour;
      proto.minute = proto.minutes = getSetMinute;
      proto.second = proto.seconds = getSetSecond;
      proto.millisecond = proto.milliseconds = getSetMillisecond;
      proto.utcOffset = getSetOffset;
      proto.utc = setOffsetToUTC;
      proto.local = setOffsetToLocal;
      proto.parseZone = setOffsetToParsedOffset;
      proto.hasAlignedHourOffset = hasAlignedHourOffset;
      proto.isDST = isDaylightSavingTime;
      proto.isLocal = isLocal;
      proto.isUtcOffset = isUtcOffset;
      proto.isUtc = isUtc;
      proto.isUTC = isUtc;
      proto.zoneAbbr = getZoneAbbr;
      proto.zoneName = getZoneName;
      proto.dates = deprecate(
        "dates accessor is deprecated. Use date instead.",
        getSetDayOfMonth
      );
      proto.months = deprecate(
        "months accessor is deprecated. Use month instead",
        getSetMonth
      );
      proto.years = deprecate(
        "years accessor is deprecated. Use year instead",
        getSetYear
      );
      proto.zone = deprecate(
        "moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/",
        getSetZone
      );
      proto.isDSTShifted = deprecate(
        "isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information",
        isDaylightSavingTimeShifted
      );
      function createUnix(input) {
        return createLocal(input * 1e3);
      }
      function createInZone() {
        return createLocal.apply(null, arguments).parseZone();
      }
      function preParsePostFormat(string2) {
        return string2;
      }
      var proto$1 = Locale.prototype;
      proto$1.calendar = calendar;
      proto$1.longDateFormat = longDateFormat;
      proto$1.invalidDate = invalidDate;
      proto$1.ordinal = ordinal;
      proto$1.preparse = preParsePostFormat;
      proto$1.postformat = preParsePostFormat;
      proto$1.relativeTime = relativeTime;
      proto$1.pastFuture = pastFuture;
      proto$1.set = set2;
      proto$1.eras = localeEras;
      proto$1.erasParse = localeErasParse;
      proto$1.erasConvertYear = localeErasConvertYear;
      proto$1.erasAbbrRegex = erasAbbrRegex;
      proto$1.erasNameRegex = erasNameRegex;
      proto$1.erasNarrowRegex = erasNarrowRegex;
      proto$1.months = localeMonths;
      proto$1.monthsShort = localeMonthsShort;
      proto$1.monthsParse = localeMonthsParse;
      proto$1.monthsRegex = monthsRegex;
      proto$1.monthsShortRegex = monthsShortRegex;
      proto$1.week = localeWeek;
      proto$1.firstDayOfYear = localeFirstDayOfYear;
      proto$1.firstDayOfWeek = localeFirstDayOfWeek;
      proto$1.weekdays = localeWeekdays;
      proto$1.weekdaysMin = localeWeekdaysMin;
      proto$1.weekdaysShort = localeWeekdaysShort;
      proto$1.weekdaysParse = localeWeekdaysParse;
      proto$1.weekdaysRegex = weekdaysRegex;
      proto$1.weekdaysShortRegex = weekdaysShortRegex;
      proto$1.weekdaysMinRegex = weekdaysMinRegex;
      proto$1.isPM = localeIsPM;
      proto$1.meridiem = localeMeridiem;
      function get$1(format2, index, field, setter) {
        var locale2 = getLocale(), utc = createUTC().set(setter, index);
        return locale2[field](utc, format2);
      }
      function listMonthsImpl(format2, index, field) {
        if (isNumber(format2)) {
          index = format2;
          format2 = void 0;
        }
        format2 = format2 || "";
        if (index != null) {
          return get$1(format2, index, field, "month");
        }
        var i, out = [];
        for (i = 0; i < 12; i++) {
          out[i] = get$1(format2, i, field, "month");
        }
        return out;
      }
      function listWeekdaysImpl(localeSorted, format2, index, field) {
        if (typeof localeSorted === "boolean") {
          if (isNumber(format2)) {
            index = format2;
            format2 = void 0;
          }
          format2 = format2 || "";
        } else {
          format2 = localeSorted;
          index = format2;
          localeSorted = false;
          if (isNumber(format2)) {
            index = format2;
            format2 = void 0;
          }
          format2 = format2 || "";
        }
        var locale2 = getLocale(), shift = localeSorted ? locale2._week.dow : 0, i, out = [];
        if (index != null) {
          return get$1(format2, (index + shift) % 7, field, "day");
        }
        for (i = 0; i < 7; i++) {
          out[i] = get$1(format2, (i + shift) % 7, field, "day");
        }
        return out;
      }
      function listMonths(format2, index) {
        return listMonthsImpl(format2, index, "months");
      }
      function listMonthsShort(format2, index) {
        return listMonthsImpl(format2, index, "monthsShort");
      }
      function listWeekdays(localeSorted, format2, index) {
        return listWeekdaysImpl(localeSorted, format2, index, "weekdays");
      }
      function listWeekdaysShort(localeSorted, format2, index) {
        return listWeekdaysImpl(localeSorted, format2, index, "weekdaysShort");
      }
      function listWeekdaysMin(localeSorted, format2, index) {
        return listWeekdaysImpl(localeSorted, format2, index, "weekdaysMin");
      }
      getSetGlobalLocale("en", {
        eras: [
          {
            since: "0001-01-01",
            until: Infinity,
            offset: 1,
            name: "Anno Domini",
            narrow: "AD",
            abbr: "AD"
          },
          {
            since: "0000-12-31",
            until: -Infinity,
            offset: 1,
            name: "Before Christ",
            narrow: "BC",
            abbr: "BC"
          }
        ],
        dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
        ordinal: function(number) {
          var b = number % 10, output = toInt(number % 100 / 10) === 1 ? "th" : b === 1 ? "st" : b === 2 ? "nd" : b === 3 ? "rd" : "th";
          return number + output;
        }
      });
      hooks.lang = deprecate(
        "moment.lang is deprecated. Use moment.locale instead.",
        getSetGlobalLocale
      );
      hooks.langData = deprecate(
        "moment.langData is deprecated. Use moment.localeData instead.",
        getLocale
      );
      var mathAbs = Math.abs;
      function abs() {
        var data = this._data;
        this._milliseconds = mathAbs(this._milliseconds);
        this._days = mathAbs(this._days);
        this._months = mathAbs(this._months);
        data.milliseconds = mathAbs(data.milliseconds);
        data.seconds = mathAbs(data.seconds);
        data.minutes = mathAbs(data.minutes);
        data.hours = mathAbs(data.hours);
        data.months = mathAbs(data.months);
        data.years = mathAbs(data.years);
        return this;
      }
      function addSubtract$1(duration, input, value, direction) {
        var other = createDuration(input, value);
        duration._milliseconds += direction * other._milliseconds;
        duration._days += direction * other._days;
        duration._months += direction * other._months;
        return duration._bubble();
      }
      function add$1(input, value) {
        return addSubtract$1(this, input, value, 1);
      }
      function subtract$1(input, value) {
        return addSubtract$1(this, input, value, -1);
      }
      function absCeil(number) {
        if (number < 0) {
          return Math.floor(number);
        } else {
          return Math.ceil(number);
        }
      }
      function bubble() {
        var milliseconds2 = this._milliseconds, days2 = this._days, months2 = this._months, data = this._data, seconds2, minutes2, hours2, years2, monthsFromDays;
        if (!(milliseconds2 >= 0 && days2 >= 0 && months2 >= 0 || milliseconds2 <= 0 && days2 <= 0 && months2 <= 0)) {
          milliseconds2 += absCeil(monthsToDays(months2) + days2) * 864e5;
          days2 = 0;
          months2 = 0;
        }
        data.milliseconds = milliseconds2 % 1e3;
        seconds2 = absFloor(milliseconds2 / 1e3);
        data.seconds = seconds2 % 60;
        minutes2 = absFloor(seconds2 / 60);
        data.minutes = minutes2 % 60;
        hours2 = absFloor(minutes2 / 60);
        data.hours = hours2 % 24;
        days2 += absFloor(hours2 / 24);
        monthsFromDays = absFloor(daysToMonths(days2));
        months2 += monthsFromDays;
        days2 -= absCeil(monthsToDays(monthsFromDays));
        years2 = absFloor(months2 / 12);
        months2 %= 12;
        data.days = days2;
        data.months = months2;
        data.years = years2;
        return this;
      }
      function daysToMonths(days2) {
        return days2 * 4800 / 146097;
      }
      function monthsToDays(months2) {
        return months2 * 146097 / 4800;
      }
      function as(units) {
        if (!this.isValid()) {
          return NaN;
        }
        var days2, months2, milliseconds2 = this._milliseconds;
        units = normalizeUnits(units);
        if (units === "month" || units === "quarter" || units === "year") {
          days2 = this._days + milliseconds2 / 864e5;
          months2 = this._months + daysToMonths(days2);
          switch (units) {
            case "month":
              return months2;
            case "quarter":
              return months2 / 3;
            case "year":
              return months2 / 12;
          }
        } else {
          days2 = this._days + Math.round(monthsToDays(this._months));
          switch (units) {
            case "week":
              return days2 / 7 + milliseconds2 / 6048e5;
            case "day":
              return days2 + milliseconds2 / 864e5;
            case "hour":
              return days2 * 24 + milliseconds2 / 36e5;
            case "minute":
              return days2 * 1440 + milliseconds2 / 6e4;
            case "second":
              return days2 * 86400 + milliseconds2 / 1e3;
            case "millisecond":
              return Math.floor(days2 * 864e5) + milliseconds2;
            default:
              throw new Error("Unknown unit " + units);
          }
        }
      }
      function valueOf$1() {
        if (!this.isValid()) {
          return NaN;
        }
        return this._milliseconds + this._days * 864e5 + this._months % 12 * 2592e6 + toInt(this._months / 12) * 31536e6;
      }
      function makeAs(alias) {
        return function() {
          return this.as(alias);
        };
      }
      var asMilliseconds = makeAs("ms"), asSeconds = makeAs("s"), asMinutes = makeAs("m"), asHours = makeAs("h"), asDays = makeAs("d"), asWeeks = makeAs("w"), asMonths = makeAs("M"), asQuarters = makeAs("Q"), asYears = makeAs("y");
      function clone$1() {
        return createDuration(this);
      }
      function get$2(units) {
        units = normalizeUnits(units);
        return this.isValid() ? this[units + "s"]() : NaN;
      }
      function makeGetter(name) {
        return function() {
          return this.isValid() ? this._data[name] : NaN;
        };
      }
      var milliseconds = makeGetter("milliseconds"), seconds = makeGetter("seconds"), minutes = makeGetter("minutes"), hours = makeGetter("hours"), days = makeGetter("days"), months = makeGetter("months"), years = makeGetter("years");
      function weeks() {
        return absFloor(this.days() / 7);
      }
      var round = Math.round, thresholds = {
        ss: 44,
        // a few seconds to seconds
        s: 45,
        // seconds to minute
        m: 45,
        // minutes to hour
        h: 22,
        // hours to day
        d: 26,
        // days to month/week
        w: null,
        // weeks to month
        M: 11
        // months to year
      };
      function substituteTimeAgo(string2, number, withoutSuffix, isFuture, locale2) {
        return locale2.relativeTime(number || 1, !!withoutSuffix, string2, isFuture);
      }
      function relativeTime$1(posNegDuration, withoutSuffix, thresholds2, locale2) {
        var duration = createDuration(posNegDuration).abs(), seconds2 = round(duration.as("s")), minutes2 = round(duration.as("m")), hours2 = round(duration.as("h")), days2 = round(duration.as("d")), months2 = round(duration.as("M")), weeks2 = round(duration.as("w")), years2 = round(duration.as("y")), a = seconds2 <= thresholds2.ss && ["s", seconds2] || seconds2 < thresholds2.s && ["ss", seconds2] || minutes2 <= 1 && ["m"] || minutes2 < thresholds2.m && ["mm", minutes2] || hours2 <= 1 && ["h"] || hours2 < thresholds2.h && ["hh", hours2] || days2 <= 1 && ["d"] || days2 < thresholds2.d && ["dd", days2];
        if (thresholds2.w != null) {
          a = a || weeks2 <= 1 && ["w"] || weeks2 < thresholds2.w && ["ww", weeks2];
        }
        a = a || months2 <= 1 && ["M"] || months2 < thresholds2.M && ["MM", months2] || years2 <= 1 && ["y"] || ["yy", years2];
        a[2] = withoutSuffix;
        a[3] = +posNegDuration > 0;
        a[4] = locale2;
        return substituteTimeAgo.apply(null, a);
      }
      function getSetRelativeTimeRounding(roundingFunction) {
        if (roundingFunction === void 0) {
          return round;
        }
        if (typeof roundingFunction === "function") {
          round = roundingFunction;
          return true;
        }
        return false;
      }
      function getSetRelativeTimeThreshold(threshold, limit) {
        if (thresholds[threshold] === void 0) {
          return false;
        }
        if (limit === void 0) {
          return thresholds[threshold];
        }
        thresholds[threshold] = limit;
        if (threshold === "s") {
          thresholds.ss = limit - 1;
        }
        return true;
      }
      function humanize(argWithSuffix, argThresholds) {
        if (!this.isValid()) {
          return this.localeData().invalidDate();
        }
        var withSuffix = false, th = thresholds, locale2, output;
        if (typeof argWithSuffix === "object") {
          argThresholds = argWithSuffix;
          argWithSuffix = false;
        }
        if (typeof argWithSuffix === "boolean") {
          withSuffix = argWithSuffix;
        }
        if (typeof argThresholds === "object") {
          th = Object.assign({}, thresholds, argThresholds);
          if (argThresholds.s != null && argThresholds.ss == null) {
            th.ss = argThresholds.s - 1;
          }
        }
        locale2 = this.localeData();
        output = relativeTime$1(this, !withSuffix, th, locale2);
        if (withSuffix) {
          output = locale2.pastFuture(+this, output);
        }
        return locale2.postformat(output);
      }
      var abs$1 = Math.abs;
      function sign(x) {
        return (x > 0) - (x < 0) || +x;
      }
      function toISOString$1() {
        if (!this.isValid()) {
          return this.localeData().invalidDate();
        }
        var seconds2 = abs$1(this._milliseconds) / 1e3, days2 = abs$1(this._days), months2 = abs$1(this._months), minutes2, hours2, years2, s, total = this.asSeconds(), totalSign, ymSign, daysSign, hmsSign;
        if (!total) {
          return "P0D";
        }
        minutes2 = absFloor(seconds2 / 60);
        hours2 = absFloor(minutes2 / 60);
        seconds2 %= 60;
        minutes2 %= 60;
        years2 = absFloor(months2 / 12);
        months2 %= 12;
        s = seconds2 ? seconds2.toFixed(3).replace(/\.?0+$/, "") : "";
        totalSign = total < 0 ? "-" : "";
        ymSign = sign(this._months) !== sign(total) ? "-" : "";
        daysSign = sign(this._days) !== sign(total) ? "-" : "";
        hmsSign = sign(this._milliseconds) !== sign(total) ? "-" : "";
        return totalSign + "P" + (years2 ? ymSign + years2 + "Y" : "") + (months2 ? ymSign + months2 + "M" : "") + (days2 ? daysSign + days2 + "D" : "") + (hours2 || minutes2 || seconds2 ? "T" : "") + (hours2 ? hmsSign + hours2 + "H" : "") + (minutes2 ? hmsSign + minutes2 + "M" : "") + (seconds2 ? hmsSign + s + "S" : "");
      }
      var proto$2 = Duration.prototype;
      proto$2.isValid = isValid$1;
      proto$2.abs = abs;
      proto$2.add = add$1;
      proto$2.subtract = subtract$1;
      proto$2.as = as;
      proto$2.asMilliseconds = asMilliseconds;
      proto$2.asSeconds = asSeconds;
      proto$2.asMinutes = asMinutes;
      proto$2.asHours = asHours;
      proto$2.asDays = asDays;
      proto$2.asWeeks = asWeeks;
      proto$2.asMonths = asMonths;
      proto$2.asQuarters = asQuarters;
      proto$2.asYears = asYears;
      proto$2.valueOf = valueOf$1;
      proto$2._bubble = bubble;
      proto$2.clone = clone$1;
      proto$2.get = get$2;
      proto$2.milliseconds = milliseconds;
      proto$2.seconds = seconds;
      proto$2.minutes = minutes;
      proto$2.hours = hours;
      proto$2.days = days;
      proto$2.weeks = weeks;
      proto$2.months = months;
      proto$2.years = years;
      proto$2.humanize = humanize;
      proto$2.toISOString = toISOString$1;
      proto$2.toString = toISOString$1;
      proto$2.toJSON = toISOString$1;
      proto$2.locale = locale;
      proto$2.localeData = localeData;
      proto$2.toIsoString = deprecate(
        "toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)",
        toISOString$1
      );
      proto$2.lang = lang;
      addFormatToken("X", 0, 0, "unix");
      addFormatToken("x", 0, 0, "valueOf");
      addRegexToken("x", matchSigned);
      addRegexToken("X", matchTimestamp);
      addParseToken("X", function(input, array, config) {
        config._d = new Date(parseFloat(input) * 1e3);
      });
      addParseToken("x", function(input, array, config) {
        config._d = new Date(toInt(input));
      });
      hooks.version = "2.29.1";
      setHookCallback(createLocal);
      hooks.fn = proto;
      hooks.min = min;
      hooks.max = max;
      hooks.now = now;
      hooks.utc = createUTC;
      hooks.unix = createUnix;
      hooks.months = listMonths;
      hooks.isDate = isDate;
      hooks.locale = getSetGlobalLocale;
      hooks.invalid = createInvalid;
      hooks.duration = createDuration;
      hooks.isMoment = isMoment;
      hooks.weekdays = listWeekdays;
      hooks.parseZone = createInZone;
      hooks.localeData = getLocale;
      hooks.isDuration = isDuration;
      hooks.monthsShort = listMonthsShort;
      hooks.weekdaysMin = listWeekdaysMin;
      hooks.defineLocale = defineLocale;
      hooks.updateLocale = updateLocale;
      hooks.locales = listLocales;
      hooks.weekdaysShort = listWeekdaysShort;
      hooks.normalizeUnits = normalizeUnits;
      hooks.relativeTimeRounding = getSetRelativeTimeRounding;
      hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
      hooks.calendarFormat = getCalendarFormat;
      hooks.prototype = proto;
      hooks.HTML5_FMT = {
        DATETIME_LOCAL: "YYYY-MM-DDTHH:mm",
        // <input type="datetime-local" />
        DATETIME_LOCAL_SECONDS: "YYYY-MM-DDTHH:mm:ss",
        // <input type="datetime-local" step="1" />
        DATETIME_LOCAL_MS: "YYYY-MM-DDTHH:mm:ss.SSS",
        // <input type="datetime-local" step="0.001" />
        DATE: "YYYY-MM-DD",
        // <input type="date" />
        TIME: "HH:mm",
        // <input type="time" />
        TIME_SECONDS: "HH:mm:ss",
        // <input type="time" step="1" />
        TIME_MS: "HH:mm:ss.SSS",
        // <input type="time" step="0.001" />
        WEEK: "GGGG-[W]WW",
        // <input type="week" />
        MONTH: "YYYY-MM"
        // <input type="month" />
      };
      return hooks;
    });
  }
});

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => MyPlugin
});
module.exports = __toCommonJS(main_exports);

// updateNoteTypeModal.ts
var import_obsidian3 = require("obsidian");

// tagrenamer/renaming.ts
var import_obsidian2 = require("obsidian");

// tagrenamer/Tag.ts
var tagBody = /^#[^\u2000-\u206F\u2E00-\u2E7F'!"#$%&()*+,.:;<=>?@^`{|}~\[\]\\\s]+$/;
var Tag = class {
  constructor(name) {
    const hashed = this.tag = Tag.toTag(name), canonical = this.canonical = hashed.toLowerCase(), canonical_prefix = this.canonical_prefix = canonical + "/";
    this.name = hashed.slice(1);
    this.matches = function(text) {
      text = text.toLowerCase();
      return text == canonical || text.startsWith(canonical_prefix);
    };
  }
  toString() {
    return this.tag;
  }
  static isTag(s) {
    return tagBody.test(s);
  }
  static toTag(name) {
    while (name.startsWith("##"))
      name = name.slice(1);
    return name.startsWith("#") ? name : "#" + name;
  }
  static canonical(name) {
    return Tag.toTag(name).toLowerCase();
  }
};
var Replacement = class {
  constructor(fromTag, toTag) {
    const cache = Object.assign(
      /* @__PURE__ */ Object.create(null),
      {
        [fromTag.tag]: toTag.tag,
        [fromTag.name]: toTag.name
      }
    );
    this.inString = function(text, pos = 0) {
      return text.slice(0, pos) + toTag.tag + text.slice(pos + fromTag.tag.length);
    };
    this.inArray = (tags, skipOdd, isAlias2) => {
      return tags.map((t, i) => {
        if (skipOdd && i & 1)
          return t;
        if (!t)
          return t;
        if (isAlias2) {
          if (!t.startsWith("#") || !Tag.isTag(t))
            return t;
        } else if (/[ ,\n]/.test(t)) {
          return this.inArray(t.split(/([, \n]+)/), true, isAlias2).join("");
        }
        if (cache[t])
          return cache[t];
        const lc = t.toLowerCase();
        if (cache[lc]) {
          return cache[t] = cache[lc];
        } else if (lc.startsWith(fromTag.canonical_prefix)) {
          return cache[t] = cache[lc] = this.inString(t);
        } else if (("#" + lc).startsWith(fromTag.canonical_prefix)) {
          return cache[t] = cache[lc] = this.inString("#" + t).slice(1);
        }
        return cache[t] = cache[lc] = t;
      });
    };
    this.willMergeTags = function(tagNames) {
      if (fromTag.canonical === toTag.canonical)
        return;
      const existing = new Set(tagNames.map((s) => s.toLowerCase()));
      for (const tagName of tagNames.filter(fromTag.matches)) {
        const changed = this.inString(tagName);
        if (existing.has(changed.toLowerCase()))
          return [new Tag(tagName), new Tag(changed)];
      }
    };
  }
};

// tagrenamer/File.ts
var import_obsidian = require("obsidian");

// node_modules/yaml/browser/dist/nodes/Node.js
var ALIAS = Symbol.for("yaml.alias");
var DOC = Symbol.for("yaml.document");
var MAP = Symbol.for("yaml.map");
var PAIR = Symbol.for("yaml.pair");
var SCALAR = Symbol.for("yaml.scalar");
var SEQ = Symbol.for("yaml.seq");
var NODE_TYPE = Symbol.for("yaml.node.type");
var isAlias = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === ALIAS;
var isDocument = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === DOC;
var isMap = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === MAP;
var isPair = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === PAIR;
var isScalar = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === SCALAR;
var isSeq = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === SEQ;
function isCollection(node) {
  if (node && typeof node === "object")
    switch (node[NODE_TYPE]) {
      case MAP:
      case SEQ:
        return true;
    }
  return false;
}
function isNode(node) {
  if (node && typeof node === "object")
    switch (node[NODE_TYPE]) {
      case ALIAS:
      case MAP:
      case SCALAR:
      case SEQ:
        return true;
    }
  return false;
}
var hasAnchor = (node) => (isScalar(node) || isCollection(node)) && !!node.anchor;
var NodeBase = class {
  constructor(type) {
    Object.defineProperty(this, NODE_TYPE, { value: type });
  }
  /** Create a copy of this node.  */
  clone() {
    const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
    if (this.range)
      copy.range = this.range.slice();
    return copy;
  }
};

// node_modules/yaml/browser/dist/visit.js
var BREAK = Symbol("break visit");
var SKIP = Symbol("skip children");
var REMOVE = Symbol("remove node");
function visit(node, visitor) {
  if (typeof visitor === "object" && (visitor.Collection || visitor.Node || visitor.Value)) {
    visitor = Object.assign({
      Alias: visitor.Node,
      Map: visitor.Node,
      Scalar: visitor.Node,
      Seq: visitor.Node
    }, visitor.Value && {
      Map: visitor.Value,
      Scalar: visitor.Value,
      Seq: visitor.Value
    }, visitor.Collection && {
      Map: visitor.Collection,
      Seq: visitor.Collection
    }, visitor);
  }
  if (isDocument(node)) {
    const cd = _visit(null, node.contents, visitor, Object.freeze([node]));
    if (cd === REMOVE)
      node.contents = null;
  } else
    _visit(null, node, visitor, Object.freeze([]));
}
visit.BREAK = BREAK;
visit.SKIP = SKIP;
visit.REMOVE = REMOVE;
function _visit(key, node, visitor, path) {
  let ctrl = void 0;
  if (typeof visitor === "function")
    ctrl = visitor(key, node, path);
  else if (isMap(node)) {
    if (visitor.Map)
      ctrl = visitor.Map(key, node, path);
  } else if (isSeq(node)) {
    if (visitor.Seq)
      ctrl = visitor.Seq(key, node, path);
  } else if (isPair(node)) {
    if (visitor.Pair)
      ctrl = visitor.Pair(key, node, path);
  } else if (isScalar(node)) {
    if (visitor.Scalar)
      ctrl = visitor.Scalar(key, node, path);
  } else if (isAlias(node)) {
    if (visitor.Alias)
      ctrl = visitor.Alias(key, node, path);
  }
  if (isNode(ctrl) || isPair(ctrl)) {
    const parent = path[path.length - 1];
    if (isCollection(parent)) {
      parent.items[key] = ctrl;
    } else if (isPair(parent)) {
      if (key === "key")
        parent.key = ctrl;
      else
        parent.value = ctrl;
    } else if (isDocument(parent)) {
      parent.contents = ctrl;
    } else {
      const pt = isAlias(parent) ? "alias" : "scalar";
      throw new Error(`Cannot replace node with ${pt} parent`);
    }
    return _visit(key, ctrl, visitor, path);
  }
  if (typeof ctrl !== "symbol") {
    if (isCollection(node)) {
      path = Object.freeze(path.concat(node));
      for (let i = 0; i < node.items.length; ++i) {
        const ci = _visit(i, node.items[i], visitor, path);
        if (typeof ci === "number")
          i = ci - 1;
        else if (ci === BREAK)
          return BREAK;
        else if (ci === REMOVE) {
          node.items.splice(i, 1);
          i -= 1;
        }
      }
    } else if (isPair(node)) {
      path = Object.freeze(path.concat(node));
      const ck = _visit("key", node.key, visitor, path);
      if (ck === BREAK)
        return BREAK;
      else if (ck === REMOVE)
        node.key = null;
      const cv = _visit("value", node.value, visitor, path);
      if (cv === BREAK)
        return BREAK;
      else if (cv === REMOVE)
        node.value = null;
    }
  }
  return ctrl;
}

// node_modules/yaml/browser/dist/doc/directives.js
var escapeChars = {
  "!": "%21",
  ",": "%2C",
  "[": "%5B",
  "]": "%5D",
  "{": "%7B",
  "}": "%7D"
};
var escapeTagName = (tn) => tn.replace(/[!,[\]{}]/g, (ch) => escapeChars[ch]);
var Directives = class {
  constructor(yaml, tags) {
    this.marker = null;
    this.yaml = Object.assign({}, Directives.defaultYaml, yaml);
    this.tags = Object.assign({}, Directives.defaultTags, tags);
  }
  clone() {
    const copy = new Directives(this.yaml, this.tags);
    copy.marker = this.marker;
    return copy;
  }
  /**
   * During parsing, get a Directives instance for the current document and
   * update the stream state according to the current version's spec.
   */
  atDocument() {
    const res = new Directives(this.yaml, this.tags);
    switch (this.yaml.version) {
      case "1.1":
        this.atNextDocument = true;
        break;
      case "1.2":
        this.atNextDocument = false;
        this.yaml = {
          explicit: Directives.defaultYaml.explicit,
          version: "1.2"
        };
        this.tags = Object.assign({}, Directives.defaultTags);
        break;
    }
    return res;
  }
  /**
   * @param onError - May be called even if the action was successful
   * @returns `true` on success
   */
  add(line, onError) {
    if (this.atNextDocument) {
      this.yaml = { explicit: Directives.defaultYaml.explicit, version: "1.1" };
      this.tags = Object.assign({}, Directives.defaultTags);
      this.atNextDocument = false;
    }
    const parts = line.trim().split(/[ \t]+/);
    const name = parts.shift();
    switch (name) {
      case "%TAG": {
        if (parts.length !== 2) {
          onError(0, "%TAG directive should contain exactly two parts");
          if (parts.length < 2)
            return false;
        }
        const [handle, prefix] = parts;
        this.tags[handle] = prefix;
        return true;
      }
      case "%YAML": {
        this.yaml.explicit = true;
        if (parts.length < 1) {
          onError(0, "%YAML directive should contain exactly one part");
          return false;
        }
        const [version] = parts;
        if (version === "1.1" || version === "1.2") {
          this.yaml.version = version;
          return true;
        } else {
          onError(6, `Unsupported YAML version ${version}`, true);
          return false;
        }
      }
      default:
        onError(0, `Unknown directive ${name}`, true);
        return false;
    }
  }
  /**
   * Resolves a tag, matching handles to those defined in %TAG directives.
   *
   * @returns Resolved tag, which may also be the non-specific tag `'!'` or a
   *   `'!local'` tag, or `null` if unresolvable.
   */
  tagName(source, onError) {
    if (source === "!")
      return "!";
    if (source[0] !== "!") {
      onError(`Not a valid tag: ${source}`);
      return null;
    }
    if (source[1] === "<") {
      const verbatim = source.slice(2, -1);
      if (verbatim === "!" || verbatim === "!!") {
        onError(`Verbatim tags aren't resolved, so ${source} is invalid.`);
        return null;
      }
      if (source[source.length - 1] !== ">")
        onError("Verbatim tags must end with a >");
      return verbatim;
    }
    const [, handle, suffix] = source.match(/^(.*!)([^!]*)$/);
    if (!suffix)
      onError(`The ${source} tag has no suffix`);
    const prefix = this.tags[handle];
    if (prefix)
      return prefix + decodeURIComponent(suffix);
    if (handle === "!")
      return source;
    onError(`Could not resolve tag: ${source}`);
    return null;
  }
  /**
   * Given a fully resolved tag, returns its printable string form,
   * taking into account current tag prefixes and defaults.
   */
  tagString(tag) {
    for (const [handle, prefix] of Object.entries(this.tags)) {
      if (tag.startsWith(prefix))
        return handle + escapeTagName(tag.substring(prefix.length));
    }
    return tag[0] === "!" ? tag : `!<${tag}>`;
  }
  toString(doc) {
    const lines = this.yaml.explicit ? [`%YAML ${this.yaml.version || "1.2"}`] : [];
    const tagEntries = Object.entries(this.tags);
    let tagNames;
    if (doc && tagEntries.length > 0 && isNode(doc.contents)) {
      const tags = {};
      visit(doc.contents, (_key, node) => {
        if (isNode(node) && node.tag)
          tags[node.tag] = true;
      });
      tagNames = Object.keys(tags);
    } else
      tagNames = [];
    for (const [handle, prefix] of tagEntries) {
      if (handle === "!!" && prefix === "tag:yaml.org,2002:")
        continue;
      if (!doc || tagNames.some((tn) => tn.startsWith(prefix)))
        lines.push(`%TAG ${handle} ${prefix}`);
    }
    return lines.join("\n");
  }
};
Directives.defaultYaml = { explicit: false, version: "1.2" };
Directives.defaultTags = { "!!": "tag:yaml.org,2002:" };

// node_modules/yaml/browser/dist/doc/anchors.js
function anchorIsValid(anchor) {
  if (/[\x00-\x19\s,[\]{}]/.test(anchor)) {
    const sa = JSON.stringify(anchor);
    const msg = `Anchor must not contain whitespace or control characters: ${sa}`;
    throw new Error(msg);
  }
  return true;
}
function anchorNames(root) {
  const anchors = /* @__PURE__ */ new Set();
  visit(root, {
    Value(_key, node) {
      if (node.anchor)
        anchors.add(node.anchor);
    }
  });
  return anchors;
}
function findNewAnchor(prefix, exclude) {
  for (let i = 1; true; ++i) {
    const name = `${prefix}${i}`;
    if (!exclude.has(name))
      return name;
  }
}
function createNodeAnchors(doc, prefix) {
  const aliasObjects = [];
  const sourceObjects = /* @__PURE__ */ new Map();
  let prevAnchors = null;
  return {
    onAnchor(source) {
      aliasObjects.push(source);
      if (!prevAnchors)
        prevAnchors = anchorNames(doc);
      const anchor = findNewAnchor(prefix, prevAnchors);
      prevAnchors.add(anchor);
      return anchor;
    },
    /**
     * With circular references, the source node is only resolved after all
     * of its child nodes are. This is why anchors are set only after all of
     * the nodes have been created.
     */
    setAnchors() {
      for (const source of aliasObjects) {
        const ref = sourceObjects.get(source);
        if (typeof ref === "object" && ref.anchor && (isScalar(ref.node) || isCollection(ref.node))) {
          ref.node.anchor = ref.anchor;
        } else {
          const error = new Error("Failed to resolve repeated object (this should not happen)");
          error.source = source;
          throw error;
        }
      }
    },
    sourceObjects
  };
}

// node_modules/yaml/browser/dist/nodes/Alias.js
var Alias = class extends NodeBase {
  constructor(source) {
    super(ALIAS);
    this.source = source;
    Object.defineProperty(this, "tag", {
      set() {
        throw new Error("Alias nodes cannot have tags");
      }
    });
  }
  /**
   * Resolve the value of this alias within `doc`, finding the last
   * instance of the `source` anchor before this node.
   */
  resolve(doc) {
    let found = void 0;
    visit(doc, {
      Node: (_key, node) => {
        if (node === this)
          return visit.BREAK;
        if (node.anchor === this.source)
          found = node;
      }
    });
    return found;
  }
  toJSON(_arg, ctx) {
    if (!ctx)
      return { source: this.source };
    const { anchors, doc, maxAliasCount } = ctx;
    const source = this.resolve(doc);
    if (!source) {
      const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
      throw new ReferenceError(msg);
    }
    const data = anchors.get(source);
    if (!data || data.res === void 0) {
      const msg = "This should not happen: Alias anchor was not resolved?";
      throw new ReferenceError(msg);
    }
    if (maxAliasCount >= 0) {
      data.count += 1;
      if (data.aliasCount === 0)
        data.aliasCount = getAliasCount(doc, source, anchors);
      if (data.count * data.aliasCount > maxAliasCount) {
        const msg = "Excessive alias count indicates a resource exhaustion attack";
        throw new ReferenceError(msg);
      }
    }
    return data.res;
  }
  toString(ctx, _onComment, _onChompKeep) {
    const src = `*${this.source}`;
    if (ctx) {
      anchorIsValid(this.source);
      if (ctx.options.verifyAliasOrder && !ctx.anchors.has(this.source)) {
        const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
        throw new Error(msg);
      }
      if (ctx.implicitKey)
        return `${src} `;
    }
    return src;
  }
};
function getAliasCount(doc, node, anchors) {
  if (isAlias(node)) {
    const source = node.resolve(doc);
    const anchor = anchors && source && anchors.get(source);
    return anchor ? anchor.count * anchor.aliasCount : 0;
  } else if (isCollection(node)) {
    let count = 0;
    for (const item of node.items) {
      const c = getAliasCount(doc, item, anchors);
      if (c > count)
        count = c;
    }
    return count;
  } else if (isPair(node)) {
    const kc = getAliasCount(doc, node.key, anchors);
    const vc = getAliasCount(doc, node.value, anchors);
    return Math.max(kc, vc);
  }
  return 1;
}

// node_modules/yaml/browser/dist/nodes/toJS.js
function toJS(value, arg, ctx) {
  if (Array.isArray(value))
    return value.map((v, i) => toJS(v, String(i), ctx));
  if (value && typeof value.toJSON === "function") {
    if (!ctx || !hasAnchor(value))
      return value.toJSON(arg, ctx);
    const data = { aliasCount: 0, count: 1, res: void 0 };
    ctx.anchors.set(value, data);
    ctx.onCreate = (res2) => {
      data.res = res2;
      delete ctx.onCreate;
    };
    const res = value.toJSON(arg, ctx);
    if (ctx.onCreate)
      ctx.onCreate(res);
    return res;
  }
  if (typeof value === "bigint" && !(ctx && ctx.keep))
    return Number(value);
  return value;
}

// node_modules/yaml/browser/dist/nodes/Scalar.js
var isScalarValue = (value) => !value || typeof value !== "function" && typeof value !== "object";
var Scalar = class extends NodeBase {
  constructor(value) {
    super(SCALAR);
    this.value = value;
  }
  toJSON(arg, ctx) {
    return ctx && ctx.keep ? this.value : toJS(this.value, arg, ctx);
  }
  toString() {
    return String(this.value);
  }
};
Scalar.BLOCK_FOLDED = "BLOCK_FOLDED";
Scalar.BLOCK_LITERAL = "BLOCK_LITERAL";
Scalar.PLAIN = "PLAIN";
Scalar.QUOTE_DOUBLE = "QUOTE_DOUBLE";
Scalar.QUOTE_SINGLE = "QUOTE_SINGLE";

// node_modules/yaml/browser/dist/doc/createNode.js
var defaultTagPrefix = "tag:yaml.org,2002:";
function findTagObject(value, tagName, tags) {
  if (tagName) {
    const match = tags.filter((t) => t.tag === tagName);
    const tagObj = match.find((t) => !t.format) || match[0];
    if (!tagObj)
      throw new Error(`Tag ${tagName} not found`);
    return tagObj;
  }
  return tags.find((t) => t.identify && t.identify(value) && !t.format);
}
function createNode(value, tagName, ctx) {
  var _a, _b;
  if (isDocument(value))
    value = value.contents;
  if (isNode(value))
    return value;
  if (isPair(value)) {
    const map2 = (_b = (_a = ctx.schema[MAP]).createNode) === null || _b === void 0 ? void 0 : _b.call(_a, ctx.schema, null, ctx);
    map2.items.push(value);
    return map2;
  }
  if (value instanceof String || value instanceof Number || value instanceof Boolean || typeof BigInt === "function" && value instanceof BigInt) {
    value = value.valueOf();
  }
  const { aliasDuplicateObjects, onAnchor, onTagObj, schema: schema4, sourceObjects } = ctx;
  let ref = void 0;
  if (aliasDuplicateObjects && value && typeof value === "object") {
    ref = sourceObjects.get(value);
    if (ref) {
      if (!ref.anchor)
        ref.anchor = onAnchor(value);
      return new Alias(ref.anchor);
    } else {
      ref = { anchor: null, node: null };
      sourceObjects.set(value, ref);
    }
  }
  if (tagName && tagName.startsWith("!!"))
    tagName = defaultTagPrefix + tagName.slice(2);
  let tagObj = findTagObject(value, tagName, schema4.tags);
  if (!tagObj) {
    if (value && typeof value.toJSON === "function")
      value = value.toJSON();
    if (!value || typeof value !== "object") {
      const node2 = new Scalar(value);
      if (ref)
        ref.node = node2;
      return node2;
    }
    tagObj = value instanceof Map ? schema4[MAP] : Symbol.iterator in Object(value) ? schema4[SEQ] : schema4[MAP];
  }
  if (onTagObj) {
    onTagObj(tagObj);
    delete ctx.onTagObj;
  }
  const node = (tagObj === null || tagObj === void 0 ? void 0 : tagObj.createNode) ? tagObj.createNode(ctx.schema, value, ctx) : new Scalar(value);
  if (tagName)
    node.tag = tagName;
  if (ref)
    ref.node = node;
  return node;
}

// node_modules/yaml/browser/dist/nodes/Collection.js
function collectionFromPath(schema4, path, value) {
  let v = value;
  for (let i = path.length - 1; i >= 0; --i) {
    const k = path[i];
    if (typeof k === "number" && Number.isInteger(k) && k >= 0) {
      const a = [];
      a[k] = v;
      v = a;
    } else {
      v = /* @__PURE__ */ new Map([[k, v]]);
    }
  }
  return createNode(v, void 0, {
    aliasDuplicateObjects: false,
    keepUndefined: false,
    onAnchor: () => {
      throw new Error("This should not happen, please report a bug.");
    },
    schema: schema4,
    sourceObjects: /* @__PURE__ */ new Map()
  });
}
var isEmptyPath = (path) => path == null || typeof path === "object" && !!path[Symbol.iterator]().next().done;
var Collection = class extends NodeBase {
  constructor(type, schema4) {
    super(type);
    Object.defineProperty(this, "schema", {
      value: schema4,
      configurable: true,
      enumerable: false,
      writable: true
    });
  }
  /**
   * Create a copy of this collection.
   *
   * @param schema - If defined, overwrites the original's schema
   */
  clone(schema4) {
    const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
    if (schema4)
      copy.schema = schema4;
    copy.items = copy.items.map((it) => isNode(it) || isPair(it) ? it.clone(schema4) : it);
    if (this.range)
      copy.range = this.range.slice();
    return copy;
  }
  /**
   * Adds a value to the collection. For `!!map` and `!!omap` the value must
   * be a Pair instance or a `{ key, value }` object, which may not have a key
   * that already exists in the map.
   */
  addIn(path, value) {
    if (isEmptyPath(path))
      this.add(value);
    else {
      const [key, ...rest] = path;
      const node = this.get(key, true);
      if (isCollection(node))
        node.addIn(rest, value);
      else if (node === void 0 && this.schema)
        this.set(key, collectionFromPath(this.schema, rest, value));
      else
        throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
    }
  }
  /**
   * Removes a value from the collection.
   * @returns `true` if the item was found and removed.
   */
  deleteIn(path) {
    const [key, ...rest] = path;
    if (rest.length === 0)
      return this.delete(key);
    const node = this.get(key, true);
    if (isCollection(node))
      return node.deleteIn(rest);
    else
      throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
  }
  /**
   * Returns item at `key`, or `undefined` if not found. By default unwraps
   * scalar values from their surrounding node; to disable set `keepScalar` to
   * `true` (collections are always returned intact).
   */
  getIn(path, keepScalar) {
    const [key, ...rest] = path;
    const node = this.get(key, true);
    if (rest.length === 0)
      return !keepScalar && isScalar(node) ? node.value : node;
    else
      return isCollection(node) ? node.getIn(rest, keepScalar) : void 0;
  }
  hasAllNullValues(allowScalar) {
    return this.items.every((node) => {
      if (!isPair(node))
        return false;
      const n = node.value;
      return n == null || allowScalar && isScalar(n) && n.value == null && !n.commentBefore && !n.comment && !n.tag;
    });
  }
  /**
   * Checks if the collection includes a value with the key `key`.
   */
  hasIn(path) {
    const [key, ...rest] = path;
    if (rest.length === 0)
      return this.has(key);
    const node = this.get(key, true);
    return isCollection(node) ? node.hasIn(rest) : false;
  }
  /**
   * Sets a value in this collection. For `!!set`, `value` needs to be a
   * boolean to add/remove the item from the set.
   */
  setIn(path, value) {
    const [key, ...rest] = path;
    if (rest.length === 0) {
      this.set(key, value);
    } else {
      const node = this.get(key, true);
      if (isCollection(node))
        node.setIn(rest, value);
      else if (node === void 0 && this.schema)
        this.set(key, collectionFromPath(this.schema, rest, value));
      else
        throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
    }
  }
};
Collection.maxFlowStringSingleLineLength = 60;

// node_modules/yaml/browser/dist/stringify/stringifyComment.js
var stringifyComment = (str) => str.replace(/^(?!$)(?: $)?/gm, "#");
function indentComment(comment, indent) {
  if (/^\n+$/.test(comment))
    return comment.substring(1);
  return indent ? comment.replace(/^(?! *$)/gm, indent) : comment;
}
var lineComment = (str, indent, comment) => comment.includes("\n") ? "\n" + indentComment(comment, indent) : (str.endsWith(" ") ? "" : " ") + comment;

// node_modules/yaml/browser/dist/stringify/foldFlowLines.js
var FOLD_FLOW = "flow";
var FOLD_BLOCK = "block";
var FOLD_QUOTED = "quoted";
function foldFlowLines(text, indent, mode = "flow", { indentAtStart, lineWidth = 80, minContentWidth = 20, onFold, onOverflow } = {}) {
  if (!lineWidth || lineWidth < 0)
    return text;
  const endStep = Math.max(1 + minContentWidth, 1 + lineWidth - indent.length);
  if (text.length <= endStep)
    return text;
  const folds = [];
  const escapedFolds = {};
  let end = lineWidth - indent.length;
  if (typeof indentAtStart === "number") {
    if (indentAtStart > lineWidth - Math.max(2, minContentWidth))
      folds.push(0);
    else
      end = lineWidth - indentAtStart;
  }
  let split = void 0;
  let prev = void 0;
  let overflow = false;
  let i = -1;
  let escStart = -1;
  let escEnd = -1;
  if (mode === FOLD_BLOCK) {
    i = consumeMoreIndentedLines(text, i);
    if (i !== -1)
      end = i + endStep;
  }
  for (let ch; ch = text[i += 1]; ) {
    if (mode === FOLD_QUOTED && ch === "\\") {
      escStart = i;
      switch (text[i + 1]) {
        case "x":
          i += 3;
          break;
        case "u":
          i += 5;
          break;
        case "U":
          i += 9;
          break;
        default:
          i += 1;
      }
      escEnd = i;
    }
    if (ch === "\n") {
      if (mode === FOLD_BLOCK)
        i = consumeMoreIndentedLines(text, i);
      end = i + endStep;
      split = void 0;
    } else {
      if (ch === " " && prev && prev !== " " && prev !== "\n" && prev !== "	") {
        const next = text[i + 1];
        if (next && next !== " " && next !== "\n" && next !== "	")
          split = i;
      }
      if (i >= end) {
        if (split) {
          folds.push(split);
          end = split + endStep;
          split = void 0;
        } else if (mode === FOLD_QUOTED) {
          while (prev === " " || prev === "	") {
            prev = ch;
            ch = text[i += 1];
            overflow = true;
          }
          const j = i > escEnd + 1 ? i - 2 : escStart - 1;
          if (escapedFolds[j])
            return text;
          folds.push(j);
          escapedFolds[j] = true;
          end = j + endStep;
          split = void 0;
        } else {
          overflow = true;
        }
      }
    }
    prev = ch;
  }
  if (overflow && onOverflow)
    onOverflow();
  if (folds.length === 0)
    return text;
  if (onFold)
    onFold();
  let res = text.slice(0, folds[0]);
  for (let i2 = 0; i2 < folds.length; ++i2) {
    const fold = folds[i2];
    const end2 = folds[i2 + 1] || text.length;
    if (fold === 0)
      res = `
${indent}${text.slice(0, end2)}`;
    else {
      if (mode === FOLD_QUOTED && escapedFolds[fold])
        res += `${text[fold]}\\`;
      res += `
${indent}${text.slice(fold + 1, end2)}`;
    }
  }
  return res;
}
function consumeMoreIndentedLines(text, i) {
  let ch = text[i + 1];
  while (ch === " " || ch === "	") {
    do {
      ch = text[i += 1];
    } while (ch && ch !== "\n");
    ch = text[i + 1];
  }
  return i;
}

// node_modules/yaml/browser/dist/stringify/stringifyString.js
var getFoldOptions = (ctx) => ({
  indentAtStart: ctx.indentAtStart,
  lineWidth: ctx.options.lineWidth,
  minContentWidth: ctx.options.minContentWidth
});
var containsDocumentMarker = (str) => /^(%|---|\.\.\.)/m.test(str);
function lineLengthOverLimit(str, lineWidth, indentLength) {
  if (!lineWidth || lineWidth < 0)
    return false;
  const limit = lineWidth - indentLength;
  const strLen = str.length;
  if (strLen <= limit)
    return false;
  for (let i = 0, start = 0; i < strLen; ++i) {
    if (str[i] === "\n") {
      if (i - start > limit)
        return true;
      start = i + 1;
      if (strLen - start <= limit)
        return false;
    }
  }
  return true;
}
function doubleQuotedString(value, ctx) {
  const json = JSON.stringify(value);
  if (ctx.options.doubleQuotedAsJSON)
    return json;
  const { implicitKey } = ctx;
  const minMultiLineLength = ctx.options.doubleQuotedMinMultiLineLength;
  const indent = ctx.indent || (containsDocumentMarker(value) ? "  " : "");
  let str = "";
  let start = 0;
  for (let i = 0, ch = json[i]; ch; ch = json[++i]) {
    if (ch === " " && json[i + 1] === "\\" && json[i + 2] === "n") {
      str += json.slice(start, i) + "\\ ";
      i += 1;
      start = i;
      ch = "\\";
    }
    if (ch === "\\")
      switch (json[i + 1]) {
        case "u":
          {
            str += json.slice(start, i);
            const code = json.substr(i + 2, 4);
            switch (code) {
              case "0000":
                str += "\\0";
                break;
              case "0007":
                str += "\\a";
                break;
              case "000b":
                str += "\\v";
                break;
              case "001b":
                str += "\\e";
                break;
              case "0085":
                str += "\\N";
                break;
              case "00a0":
                str += "\\_";
                break;
              case "2028":
                str += "\\L";
                break;
              case "2029":
                str += "\\P";
                break;
              default:
                if (code.substr(0, 2) === "00")
                  str += "\\x" + code.substr(2);
                else
                  str += json.substr(i, 6);
            }
            i += 5;
            start = i + 1;
          }
          break;
        case "n":
          if (implicitKey || json[i + 2] === '"' || json.length < minMultiLineLength) {
            i += 1;
          } else {
            str += json.slice(start, i) + "\n\n";
            while (json[i + 2] === "\\" && json[i + 3] === "n" && json[i + 4] !== '"') {
              str += "\n";
              i += 2;
            }
            str += indent;
            if (json[i + 2] === " ")
              str += "\\";
            i += 1;
            start = i + 1;
          }
          break;
        default:
          i += 1;
      }
  }
  str = start ? str + json.slice(start) : json;
  return implicitKey ? str : foldFlowLines(str, indent, FOLD_QUOTED, getFoldOptions(ctx));
}
function singleQuotedString(value, ctx) {
  if (ctx.options.singleQuote === false || ctx.implicitKey && value.includes("\n") || /[ \t]\n|\n[ \t]/.test(value))
    return doubleQuotedString(value, ctx);
  const indent = ctx.indent || (containsDocumentMarker(value) ? "  " : "");
  const res = "'" + value.replace(/'/g, "''").replace(/\n+/g, `$&
${indent}`) + "'";
  return ctx.implicitKey ? res : foldFlowLines(res, indent, FOLD_FLOW, getFoldOptions(ctx));
}
function quotedString(value, ctx) {
  const { singleQuote } = ctx.options;
  let qs;
  if (singleQuote === false)
    qs = doubleQuotedString;
  else {
    const hasDouble = value.includes('"');
    const hasSingle = value.includes("'");
    if (hasDouble && !hasSingle)
      qs = singleQuotedString;
    else if (hasSingle && !hasDouble)
      qs = doubleQuotedString;
    else
      qs = singleQuote ? singleQuotedString : doubleQuotedString;
  }
  return qs(value, ctx);
}
function blockString({ comment, type, value }, ctx, onComment, onChompKeep) {
  const { blockQuote, commentString, lineWidth } = ctx.options;
  if (!blockQuote || /\n[\t ]+$/.test(value) || /^\s*$/.test(value)) {
    return quotedString(value, ctx);
  }
  const indent = ctx.indent || (ctx.forceBlockIndent || containsDocumentMarker(value) ? "  " : "");
  const literal = blockQuote === "literal" ? true : blockQuote === "folded" || type === Scalar.BLOCK_FOLDED ? false : type === Scalar.BLOCK_LITERAL ? true : !lineLengthOverLimit(value, lineWidth, indent.length);
  if (!value)
    return literal ? "|\n" : ">\n";
  let chomp;
  let endStart;
  for (endStart = value.length; endStart > 0; --endStart) {
    const ch = value[endStart - 1];
    if (ch !== "\n" && ch !== "	" && ch !== " ")
      break;
  }
  let end = value.substring(endStart);
  const endNlPos = end.indexOf("\n");
  if (endNlPos === -1) {
    chomp = "-";
  } else if (value === end || endNlPos !== end.length - 1) {
    chomp = "+";
    if (onChompKeep)
      onChompKeep();
  } else {
    chomp = "";
  }
  if (end) {
    value = value.slice(0, -end.length);
    if (end[end.length - 1] === "\n")
      end = end.slice(0, -1);
    end = end.replace(/\n+(?!\n|$)/g, `$&${indent}`);
  }
  let startWithSpace = false;
  let startEnd;
  let startNlPos = -1;
  for (startEnd = 0; startEnd < value.length; ++startEnd) {
    const ch = value[startEnd];
    if (ch === " ")
      startWithSpace = true;
    else if (ch === "\n")
      startNlPos = startEnd;
    else
      break;
  }
  let start = value.substring(0, startNlPos < startEnd ? startNlPos + 1 : startEnd);
  if (start) {
    value = value.substring(start.length);
    start = start.replace(/\n+/g, `$&${indent}`);
  }
  const indentSize = indent ? "2" : "1";
  let header = (literal ? "|" : ">") + (startWithSpace ? indentSize : "") + chomp;
  if (comment) {
    header += " " + commentString(comment.replace(/ ?[\r\n]+/g, " "));
    if (onComment)
      onComment();
  }
  if (literal) {
    value = value.replace(/\n+/g, `$&${indent}`);
    return `${header}
${indent}${start}${value}${end}`;
  }
  value = value.replace(/\n+/g, "\n$&").replace(/(?:^|\n)([\t ].*)(?:([\n\t ]*)\n(?![\n\t ]))?/g, "$1$2").replace(/\n+/g, `$&${indent}`);
  const body = foldFlowLines(`${start}${value}${end}`, indent, FOLD_BLOCK, getFoldOptions(ctx));
  return `${header}
${indent}${body}`;
}
function plainString(item, ctx, onComment, onChompKeep) {
  const { type, value } = item;
  const { actualString, implicitKey, indent, inFlow } = ctx;
  if (implicitKey && /[\n[\]{},]/.test(value) || inFlow && /[[\]{},]/.test(value)) {
    return quotedString(value, ctx);
  }
  if (!value || /^[\n\t ,[\]{}#&*!|>'"%@`]|^[?-]$|^[?-][ \t]|[\n:][ \t]|[ \t]\n|[\n\t ]#|[\n\t :]$/.test(value)) {
    return implicitKey || inFlow || value.indexOf("\n") === -1 ? quotedString(value, ctx) : blockString(item, ctx, onComment, onChompKeep);
  }
  if (!implicitKey && !inFlow && type !== Scalar.PLAIN && value.indexOf("\n") !== -1) {
    return blockString(item, ctx, onComment, onChompKeep);
  }
  if (indent === "" && containsDocumentMarker(value)) {
    ctx.forceBlockIndent = true;
    return blockString(item, ctx, onComment, onChompKeep);
  }
  const str = value.replace(/\n+/g, `$&
${indent}`);
  if (actualString) {
    const test = (tag) => {
      var _a;
      return tag.default && tag.tag !== "tag:yaml.org,2002:str" && ((_a = tag.test) === null || _a === void 0 ? void 0 : _a.test(str));
    };
    const { compat, tags } = ctx.doc.schema;
    if (tags.some(test) || (compat === null || compat === void 0 ? void 0 : compat.some(test)))
      return quotedString(value, ctx);
  }
  return implicitKey ? str : foldFlowLines(str, indent, FOLD_FLOW, getFoldOptions(ctx));
}
function stringifyString(item, ctx, onComment, onChompKeep) {
  const { implicitKey, inFlow } = ctx;
  const ss = typeof item.value === "string" ? item : Object.assign({}, item, { value: String(item.value) });
  let { type } = item;
  if (type !== Scalar.QUOTE_DOUBLE) {
    if (/[\x00-\x08\x0b-\x1f\x7f-\x9f\u{D800}-\u{DFFF}]/u.test(ss.value))
      type = Scalar.QUOTE_DOUBLE;
  }
  const _stringify = (_type) => {
    switch (_type) {
      case Scalar.BLOCK_FOLDED:
      case Scalar.BLOCK_LITERAL:
        return implicitKey || inFlow ? quotedString(ss.value, ctx) : blockString(ss, ctx, onComment, onChompKeep);
      case Scalar.QUOTE_DOUBLE:
        return doubleQuotedString(ss.value, ctx);
      case Scalar.QUOTE_SINGLE:
        return singleQuotedString(ss.value, ctx);
      case Scalar.PLAIN:
        return plainString(ss, ctx, onComment, onChompKeep);
      default:
        return null;
    }
  };
  let res = _stringify(type);
  if (res === null) {
    const { defaultKeyType, defaultStringType } = ctx.options;
    const t = implicitKey && defaultKeyType || defaultStringType;
    res = _stringify(t);
    if (res === null)
      throw new Error(`Unsupported default string type ${t}`);
  }
  return res;
}

// node_modules/yaml/browser/dist/stringify/stringify.js
function createStringifyContext(doc, options) {
  const opt = Object.assign({
    blockQuote: true,
    commentString: stringifyComment,
    defaultKeyType: null,
    defaultStringType: "PLAIN",
    directives: null,
    doubleQuotedAsJSON: false,
    doubleQuotedMinMultiLineLength: 40,
    falseStr: "false",
    indentSeq: true,
    lineWidth: 80,
    minContentWidth: 20,
    nullStr: "null",
    simpleKeys: false,
    singleQuote: null,
    trueStr: "true",
    verifyAliasOrder: true
  }, doc.schema.toStringOptions, options);
  let inFlow;
  switch (opt.collectionStyle) {
    case "block":
      inFlow = false;
      break;
    case "flow":
      inFlow = true;
      break;
    default:
      inFlow = null;
  }
  return {
    anchors: /* @__PURE__ */ new Set(),
    doc,
    indent: "",
    indentStep: typeof opt.indent === "number" ? " ".repeat(opt.indent) : "  ",
    inFlow,
    options: opt
  };
}
function getTagObject(tags, item) {
  if (item.tag) {
    const match = tags.filter((t) => t.tag === item.tag);
    if (match.length > 0)
      return match.find((t) => t.format === item.format) || match[0];
  }
  let tagObj = void 0;
  let obj;
  if (isScalar(item)) {
    obj = item.value;
    const match = tags.filter((t) => t.identify && t.identify(obj));
    tagObj = match.find((t) => t.format === item.format) || match.find((t) => !t.format);
  } else {
    obj = item;
    tagObj = tags.find((t) => t.nodeClass && obj instanceof t.nodeClass);
  }
  if (!tagObj) {
    const name = obj && obj.constructor ? obj.constructor.name : typeof obj;
    throw new Error(`Tag not resolved for ${name} value`);
  }
  return tagObj;
}
function stringifyProps(node, tagObj, { anchors, doc }) {
  if (!doc.directives)
    return "";
  const props = [];
  const anchor = (isScalar(node) || isCollection(node)) && node.anchor;
  if (anchor && anchorIsValid(anchor)) {
    anchors.add(anchor);
    props.push(`&${anchor}`);
  }
  const tag = node.tag || (tagObj.default ? null : tagObj.tag);
  if (tag)
    props.push(doc.directives.tagString(tag));
  return props.join(" ");
}
function stringify(item, ctx, onComment, onChompKeep) {
  var _a;
  if (isPair(item))
    return item.toString(ctx, onComment, onChompKeep);
  if (isAlias(item)) {
    if (ctx.doc.directives)
      return item.toString(ctx);
    if ((_a = ctx.resolvedAliases) === null || _a === void 0 ? void 0 : _a.has(item)) {
      throw new TypeError(`Cannot stringify circular structure without alias nodes`);
    } else {
      if (ctx.resolvedAliases)
        ctx.resolvedAliases.add(item);
      else
        ctx.resolvedAliases = /* @__PURE__ */ new Set([item]);
      item = item.resolve(ctx.doc);
    }
  }
  let tagObj = void 0;
  const node = isNode(item) ? item : ctx.doc.createNode(item, { onTagObj: (o) => tagObj = o });
  if (!tagObj)
    tagObj = getTagObject(ctx.doc.schema.tags, node);
  const props = stringifyProps(node, tagObj, ctx);
  if (props.length > 0)
    ctx.indentAtStart = (ctx.indentAtStart || 0) + props.length + 1;
  const str = typeof tagObj.stringify === "function" ? tagObj.stringify(node, ctx, onComment, onChompKeep) : isScalar(node) ? stringifyString(node, ctx, onComment, onChompKeep) : node.toString(ctx, onComment, onChompKeep);
  if (!props)
    return str;
  return isScalar(node) || str[0] === "{" || str[0] === "[" ? `${props} ${str}` : `${props}
${ctx.indent}${str}`;
}

// node_modules/yaml/browser/dist/stringify/stringifyPair.js
function stringifyPair({ key, value }, ctx, onComment, onChompKeep) {
  const { allNullValues, doc, indent, indentStep, options: { commentString, indentSeq, simpleKeys } } = ctx;
  let keyComment = isNode(key) && key.comment || null;
  if (simpleKeys) {
    if (keyComment) {
      throw new Error("With simple keys, key nodes cannot have comments");
    }
    if (isCollection(key)) {
      const msg = "With simple keys, collection cannot be used as a key value";
      throw new Error(msg);
    }
  }
  let explicitKey = !simpleKeys && (!key || keyComment && value == null && !ctx.inFlow || isCollection(key) || (isScalar(key) ? key.type === Scalar.BLOCK_FOLDED || key.type === Scalar.BLOCK_LITERAL : typeof key === "object"));
  ctx = Object.assign({}, ctx, {
    allNullValues: false,
    implicitKey: !explicitKey && (simpleKeys || !allNullValues),
    indent: indent + indentStep
  });
  let keyCommentDone = false;
  let chompKeep = false;
  let str = stringify(key, ctx, () => keyCommentDone = true, () => chompKeep = true);
  if (!explicitKey && !ctx.inFlow && str.length > 1024) {
    if (simpleKeys)
      throw new Error("With simple keys, single line scalar must not span more than 1024 characters");
    explicitKey = true;
  }
  if (ctx.inFlow) {
    if (allNullValues || value == null) {
      if (keyCommentDone && onComment)
        onComment();
      return explicitKey ? `? ${str}` : str;
    }
  } else if (allNullValues && !simpleKeys || value == null && explicitKey) {
    str = `? ${str}`;
    if (keyComment && !keyCommentDone) {
      str += lineComment(str, ctx.indent, commentString(keyComment));
    } else if (chompKeep && onChompKeep)
      onChompKeep();
    return str;
  }
  if (keyCommentDone)
    keyComment = null;
  if (explicitKey) {
    if (keyComment)
      str += lineComment(str, ctx.indent, commentString(keyComment));
    str = `? ${str}
${indent}:`;
  } else {
    str = `${str}:`;
    if (keyComment)
      str += lineComment(str, ctx.indent, commentString(keyComment));
  }
  let vcb = "";
  let valueComment = null;
  if (isNode(value)) {
    if (value.spaceBefore)
      vcb = "\n";
    if (value.commentBefore) {
      const cs = commentString(value.commentBefore);
      vcb += `
${indentComment(cs, ctx.indent)}`;
    }
    valueComment = value.comment;
  } else if (value && typeof value === "object") {
    value = doc.createNode(value);
  }
  ctx.implicitKey = false;
  if (!explicitKey && !keyComment && isScalar(value))
    ctx.indentAtStart = str.length + 1;
  chompKeep = false;
  if (!indentSeq && indentStep.length >= 2 && !ctx.inFlow && !explicitKey && isSeq(value) && !value.flow && !value.tag && !value.anchor) {
    ctx.indent = ctx.indent.substr(2);
  }
  let valueCommentDone = false;
  const valueStr = stringify(value, ctx, () => valueCommentDone = true, () => chompKeep = true);
  let ws = " ";
  if (vcb || keyComment) {
    ws = valueStr === "" && !ctx.inFlow ? vcb : `${vcb}
${ctx.indent}`;
  } else if (!explicitKey && isCollection(value)) {
    const flow = valueStr[0] === "[" || valueStr[0] === "{";
    if (!flow || valueStr.includes("\n"))
      ws = `
${ctx.indent}`;
  } else if (valueStr === "" || valueStr[0] === "\n")
    ws = "";
  str += ws + valueStr;
  if (ctx.inFlow) {
    if (valueCommentDone && onComment)
      onComment();
  } else if (valueComment && !valueCommentDone) {
    str += lineComment(str, ctx.indent, commentString(valueComment));
  } else if (chompKeep && onChompKeep) {
    onChompKeep();
  }
  return str;
}

// node_modules/yaml/browser/dist/log.js
function warn(logLevel, warning) {
  if (logLevel === "debug" || logLevel === "warn") {
    if (typeof process !== "undefined" && process.emitWarning)
      process.emitWarning(warning);
    else
      console.warn(warning);
  }
}

// node_modules/yaml/browser/dist/nodes/addPairToJSMap.js
var MERGE_KEY = "<<";
function addPairToJSMap(ctx, map2, { key, value }) {
  if (ctx && ctx.doc.schema.merge && isMergeKey(key)) {
    value = isAlias(value) ? value.resolve(ctx.doc) : value;
    if (isSeq(value))
      for (const it of value.items)
        mergeToJSMap(ctx, map2, it);
    else if (Array.isArray(value))
      for (const it of value)
        mergeToJSMap(ctx, map2, it);
    else
      mergeToJSMap(ctx, map2, value);
  } else {
    const jsKey = toJS(key, "", ctx);
    if (map2 instanceof Map) {
      map2.set(jsKey, toJS(value, jsKey, ctx));
    } else if (map2 instanceof Set) {
      map2.add(jsKey);
    } else {
      const stringKey = stringifyKey(key, jsKey, ctx);
      const jsValue = toJS(value, stringKey, ctx);
      if (stringKey in map2)
        Object.defineProperty(map2, stringKey, {
          value: jsValue,
          writable: true,
          enumerable: true,
          configurable: true
        });
      else
        map2[stringKey] = jsValue;
    }
  }
  return map2;
}
var isMergeKey = (key) => key === MERGE_KEY || isScalar(key) && key.value === MERGE_KEY && (!key.type || key.type === Scalar.PLAIN);
function mergeToJSMap(ctx, map2, value) {
  const source = ctx && isAlias(value) ? value.resolve(ctx.doc) : value;
  if (!isMap(source))
    throw new Error("Merge sources must be maps or map aliases");
  const srcMap = source.toJSON(null, ctx, Map);
  for (const [key, value2] of srcMap) {
    if (map2 instanceof Map) {
      if (!map2.has(key))
        map2.set(key, value2);
    } else if (map2 instanceof Set) {
      map2.add(key);
    } else if (!Object.prototype.hasOwnProperty.call(map2, key)) {
      Object.defineProperty(map2, key, {
        value: value2,
        writable: true,
        enumerable: true,
        configurable: true
      });
    }
  }
  return map2;
}
function stringifyKey(key, jsKey, ctx) {
  if (jsKey === null)
    return "";
  if (typeof jsKey !== "object")
    return String(jsKey);
  if (isNode(key) && ctx && ctx.doc) {
    const strCtx = createStringifyContext(ctx.doc, {});
    strCtx.anchors = /* @__PURE__ */ new Set();
    for (const node of ctx.anchors.keys())
      strCtx.anchors.add(node.anchor);
    strCtx.inFlow = true;
    strCtx.inStringifyKey = true;
    const strKey = key.toString(strCtx);
    if (!ctx.mapKeyWarned) {
      let jsonStr = JSON.stringify(strKey);
      if (jsonStr.length > 40)
        jsonStr = jsonStr.substring(0, 36) + '..."';
      warn(ctx.doc.options.logLevel, `Keys with collection values will be stringified due to JS Object restrictions: ${jsonStr}. Set mapAsMap: true to use object keys.`);
      ctx.mapKeyWarned = true;
    }
    return strKey;
  }
  return JSON.stringify(jsKey);
}

// node_modules/yaml/browser/dist/nodes/Pair.js
function createPair(key, value, ctx) {
  const k = createNode(key, void 0, ctx);
  const v = createNode(value, void 0, ctx);
  return new Pair(k, v);
}
var Pair = class {
  constructor(key, value = null) {
    Object.defineProperty(this, NODE_TYPE, { value: PAIR });
    this.key = key;
    this.value = value;
  }
  clone(schema4) {
    let { key, value } = this;
    if (isNode(key))
      key = key.clone(schema4);
    if (isNode(value))
      value = value.clone(schema4);
    return new Pair(key, value);
  }
  toJSON(_, ctx) {
    const pair = ctx && ctx.mapAsMap ? /* @__PURE__ */ new Map() : {};
    return addPairToJSMap(ctx, pair, this);
  }
  toString(ctx, onComment, onChompKeep) {
    return ctx && ctx.doc ? stringifyPair(this, ctx, onComment, onChompKeep) : JSON.stringify(this);
  }
};

// node_modules/yaml/browser/dist/options.js
var defaultOptions = {
  intAsBigInt: false,
  keepSourceTokens: false,
  logLevel: "warn",
  prettyErrors: true,
  strict: true,
  uniqueKeys: true,
  version: "1.2"
};

// node_modules/yaml/browser/dist/stringify/stringifyCollection.js
function stringifyCollection(collection, ctx, options) {
  var _a;
  const flow = (_a = ctx.inFlow) !== null && _a !== void 0 ? _a : collection.flow;
  const stringify4 = flow ? stringifyFlowCollection : stringifyBlockCollection;
  return stringify4(collection, ctx, options);
}
function stringifyBlockCollection({ comment, items }, ctx, { blockItemPrefix, flowChars, itemIndent, onChompKeep, onComment }) {
  const { indent, options: { commentString } } = ctx;
  const itemCtx = Object.assign({}, ctx, { indent: itemIndent, type: null });
  let chompKeep = false;
  const lines = [];
  for (let i = 0; i < items.length; ++i) {
    const item = items[i];
    let comment2 = null;
    if (isNode(item)) {
      if (!chompKeep && item.spaceBefore)
        lines.push("");
      addCommentBefore(ctx, lines, item.commentBefore, chompKeep);
      if (item.comment)
        comment2 = item.comment;
    } else if (isPair(item)) {
      const ik = isNode(item.key) ? item.key : null;
      if (ik) {
        if (!chompKeep && ik.spaceBefore)
          lines.push("");
        addCommentBefore(ctx, lines, ik.commentBefore, chompKeep);
      }
    }
    chompKeep = false;
    let str2 = stringify(item, itemCtx, () => comment2 = null, () => chompKeep = true);
    if (comment2)
      str2 += lineComment(str2, itemIndent, commentString(comment2));
    if (chompKeep && comment2)
      chompKeep = false;
    lines.push(blockItemPrefix + str2);
  }
  let str;
  if (lines.length === 0) {
    str = flowChars.start + flowChars.end;
  } else {
    str = lines[0];
    for (let i = 1; i < lines.length; ++i) {
      const line = lines[i];
      str += line ? `
${indent}${line}` : "\n";
    }
  }
  if (comment) {
    str += "\n" + indentComment(commentString(comment), indent);
    if (onComment)
      onComment();
  } else if (chompKeep && onChompKeep)
    onChompKeep();
  return str;
}
function stringifyFlowCollection({ comment, items }, ctx, { flowChars, itemIndent, onComment }) {
  const { indent, indentStep, options: { commentString } } = ctx;
  itemIndent += indentStep;
  const itemCtx = Object.assign({}, ctx, {
    indent: itemIndent,
    inFlow: true,
    type: null
  });
  let reqNewline = false;
  let linesAtValue = 0;
  const lines = [];
  for (let i = 0; i < items.length; ++i) {
    const item = items[i];
    let comment2 = null;
    if (isNode(item)) {
      if (item.spaceBefore)
        lines.push("");
      addCommentBefore(ctx, lines, item.commentBefore, false);
      if (item.comment)
        comment2 = item.comment;
    } else if (isPair(item)) {
      const ik = isNode(item.key) ? item.key : null;
      if (ik) {
        if (ik.spaceBefore)
          lines.push("");
        addCommentBefore(ctx, lines, ik.commentBefore, false);
        if (ik.comment)
          reqNewline = true;
      }
      const iv = isNode(item.value) ? item.value : null;
      if (iv) {
        if (iv.comment)
          comment2 = iv.comment;
        if (iv.commentBefore)
          reqNewline = true;
      } else if (item.value == null && ik && ik.comment) {
        comment2 = ik.comment;
      }
    }
    if (comment2)
      reqNewline = true;
    let str2 = stringify(item, itemCtx, () => comment2 = null);
    if (i < items.length - 1)
      str2 += ",";
    if (comment2)
      str2 += lineComment(str2, itemIndent, commentString(comment2));
    if (!reqNewline && (lines.length > linesAtValue || str2.includes("\n")))
      reqNewline = true;
    lines.push(str2);
    linesAtValue = lines.length;
  }
  let str;
  const { start, end } = flowChars;
  if (lines.length === 0) {
    str = start + end;
  } else {
    if (!reqNewline) {
      const len = lines.reduce((sum, line) => sum + line.length + 2, 2);
      reqNewline = len > Collection.maxFlowStringSingleLineLength;
    }
    if (reqNewline) {
      str = start;
      for (const line of lines)
        str += line ? `
${indentStep}${indent}${line}` : "\n";
      str += `
${indent}${end}`;
    } else {
      str = `${start} ${lines.join(" ")} ${end}`;
    }
  }
  if (comment) {
    str += lineComment(str, commentString(comment), indent);
    if (onComment)
      onComment();
  }
  return str;
}
function addCommentBefore({ indent, options: { commentString } }, lines, comment, chompKeep) {
  if (comment && chompKeep)
    comment = comment.replace(/^\n+/, "");
  if (comment) {
    const ic = indentComment(commentString(comment), indent);
    lines.push(ic.trimStart());
  }
}

// node_modules/yaml/browser/dist/nodes/YAMLMap.js
function findPair(items, key) {
  const k = isScalar(key) ? key.value : key;
  for (const it of items) {
    if (isPair(it)) {
      if (it.key === key || it.key === k)
        return it;
      if (isScalar(it.key) && it.key.value === k)
        return it;
    }
  }
  return void 0;
}
var YAMLMap = class extends Collection {
  constructor(schema4) {
    super(MAP, schema4);
    this.items = [];
  }
  static get tagName() {
    return "tag:yaml.org,2002:map";
  }
  /**
   * Adds a value to the collection.
   *
   * @param overwrite - If not set `true`, using a key that is already in the
   *   collection will throw. Otherwise, overwrites the previous value.
   */
  add(pair, overwrite) {
    let _pair;
    if (isPair(pair))
      _pair = pair;
    else if (!pair || typeof pair !== "object" || !("key" in pair)) {
      _pair = new Pair(pair, pair.value);
    } else
      _pair = new Pair(pair.key, pair.value);
    const prev = findPair(this.items, _pair.key);
    const sortEntries = this.schema && this.schema.sortMapEntries;
    if (prev) {
      if (!overwrite)
        throw new Error(`Key ${_pair.key} already set`);
      if (isScalar(prev.value) && isScalarValue(_pair.value))
        prev.value.value = _pair.value;
      else
        prev.value = _pair.value;
    } else if (sortEntries) {
      const i = this.items.findIndex((item) => sortEntries(_pair, item) < 0);
      if (i === -1)
        this.items.push(_pair);
      else
        this.items.splice(i, 0, _pair);
    } else {
      this.items.push(_pair);
    }
  }
  delete(key) {
    const it = findPair(this.items, key);
    if (!it)
      return false;
    const del = this.items.splice(this.items.indexOf(it), 1);
    return del.length > 0;
  }
  get(key, keepScalar) {
    const it = findPair(this.items, key);
    const node = it && it.value;
    return !keepScalar && isScalar(node) ? node.value : node;
  }
  has(key) {
    return !!findPair(this.items, key);
  }
  set(key, value) {
    this.add(new Pair(key, value), true);
  }
  /**
   * @param ctx - Conversion context, originally set in Document#toJS()
   * @param {Class} Type - If set, forces the returned collection type
   * @returns Instance of Type, Map, or Object
   */
  toJSON(_, ctx, Type) {
    const map2 = Type ? new Type() : ctx && ctx.mapAsMap ? /* @__PURE__ */ new Map() : {};
    if (ctx && ctx.onCreate)
      ctx.onCreate(map2);
    for (const item of this.items)
      addPairToJSMap(ctx, map2, item);
    return map2;
  }
  toString(ctx, onComment, onChompKeep) {
    if (!ctx)
      return JSON.stringify(this);
    for (const item of this.items) {
      if (!isPair(item))
        throw new Error(`Map items must all be pairs; found ${JSON.stringify(item)} instead`);
    }
    if (!ctx.allNullValues && this.hasAllNullValues(false))
      ctx = Object.assign({}, ctx, { allNullValues: true });
    return stringifyCollection(this, ctx, {
      blockItemPrefix: "",
      flowChars: { start: "{", end: "}" },
      itemIndent: ctx.indent || "",
      onChompKeep,
      onComment
    });
  }
};

// node_modules/yaml/browser/dist/schema/common/map.js
function createMap(schema4, obj, ctx) {
  const { keepUndefined, replacer } = ctx;
  const map2 = new YAMLMap(schema4);
  const add = (key, value) => {
    if (typeof replacer === "function")
      value = replacer.call(obj, key, value);
    else if (Array.isArray(replacer) && !replacer.includes(key))
      return;
    if (value !== void 0 || keepUndefined)
      map2.items.push(createPair(key, value, ctx));
  };
  if (obj instanceof Map) {
    for (const [key, value] of obj)
      add(key, value);
  } else if (obj && typeof obj === "object") {
    for (const key of Object.keys(obj))
      add(key, obj[key]);
  }
  if (typeof schema4.sortMapEntries === "function") {
    map2.items.sort(schema4.sortMapEntries);
  }
  return map2;
}
var map = {
  collection: "map",
  createNode: createMap,
  default: true,
  nodeClass: YAMLMap,
  tag: "tag:yaml.org,2002:map",
  resolve(map2, onError) {
    if (!isMap(map2))
      onError("Expected a mapping for this tag");
    return map2;
  }
};

// node_modules/yaml/browser/dist/nodes/YAMLSeq.js
var YAMLSeq = class extends Collection {
  constructor(schema4) {
    super(SEQ, schema4);
    this.items = [];
  }
  static get tagName() {
    return "tag:yaml.org,2002:seq";
  }
  add(value) {
    this.items.push(value);
  }
  /**
   * Removes a value from the collection.
   *
   * `key` must contain a representation of an integer for this to succeed.
   * It may be wrapped in a `Scalar`.
   *
   * @returns `true` if the item was found and removed.
   */
  delete(key) {
    const idx = asItemIndex(key);
    if (typeof idx !== "number")
      return false;
    const del = this.items.splice(idx, 1);
    return del.length > 0;
  }
  /**
   * Returns item at `key`, or `undefined` if not found. By default unwraps
   * scalar values from their surrounding node; to disable set `keepScalar` to
   * `true` (collections are always returned intact).
   *
   * `key` must contain a representation of an integer for this to succeed.
   * It may be wrapped in a `Scalar`.
   */
  get(key, keepScalar) {
    const idx = asItemIndex(key);
    if (typeof idx !== "number")
      return void 0;
    const it = this.items[idx];
    return !keepScalar && isScalar(it) ? it.value : it;
  }
  /**
   * Checks if the collection includes a value with the key `key`.
   *
   * `key` must contain a representation of an integer for this to succeed.
   * It may be wrapped in a `Scalar`.
   */
  has(key) {
    const idx = asItemIndex(key);
    return typeof idx === "number" && idx < this.items.length;
  }
  /**
   * Sets a value in this collection. For `!!set`, `value` needs to be a
   * boolean to add/remove the item from the set.
   *
   * If `key` does not contain a representation of an integer, this will throw.
   * It may be wrapped in a `Scalar`.
   */
  set(key, value) {
    const idx = asItemIndex(key);
    if (typeof idx !== "number")
      throw new Error(`Expected a valid index, not ${key}.`);
    const prev = this.items[idx];
    if (isScalar(prev) && isScalarValue(value))
      prev.value = value;
    else
      this.items[idx] = value;
  }
  toJSON(_, ctx) {
    const seq2 = [];
    if (ctx && ctx.onCreate)
      ctx.onCreate(seq2);
    let i = 0;
    for (const item of this.items)
      seq2.push(toJS(item, String(i++), ctx));
    return seq2;
  }
  toString(ctx, onComment, onChompKeep) {
    if (!ctx)
      return JSON.stringify(this);
    return stringifyCollection(this, ctx, {
      blockItemPrefix: "- ",
      flowChars: { start: "[", end: "]" },
      itemIndent: (ctx.indent || "") + "  ",
      onChompKeep,
      onComment
    });
  }
};
function asItemIndex(key) {
  let idx = isScalar(key) ? key.value : key;
  if (idx && typeof idx === "string")
    idx = Number(idx);
  return typeof idx === "number" && Number.isInteger(idx) && idx >= 0 ? idx : null;
}

// node_modules/yaml/browser/dist/schema/common/seq.js
function createSeq(schema4, obj, ctx) {
  const { replacer } = ctx;
  const seq2 = new YAMLSeq(schema4);
  if (obj && Symbol.iterator in Object(obj)) {
    let i = 0;
    for (let it of obj) {
      if (typeof replacer === "function") {
        const key = obj instanceof Set ? it : String(i++);
        it = replacer.call(obj, key, it);
      }
      seq2.items.push(createNode(it, void 0, ctx));
    }
  }
  return seq2;
}
var seq = {
  collection: "seq",
  createNode: createSeq,
  default: true,
  nodeClass: YAMLSeq,
  tag: "tag:yaml.org,2002:seq",
  resolve(seq2, onError) {
    if (!isSeq(seq2))
      onError("Expected a sequence for this tag");
    return seq2;
  }
};

// node_modules/yaml/browser/dist/schema/common/string.js
var string = {
  identify: (value) => typeof value === "string",
  default: true,
  tag: "tag:yaml.org,2002:str",
  resolve: (str) => str,
  stringify(item, ctx, onComment, onChompKeep) {
    ctx = Object.assign({ actualString: true }, ctx);
    return stringifyString(item, ctx, onComment, onChompKeep);
  }
};

// node_modules/yaml/browser/dist/schema/common/null.js
var nullTag = {
  identify: (value) => value == null,
  createNode: () => new Scalar(null),
  default: true,
  tag: "tag:yaml.org,2002:null",
  test: /^(?:~|[Nn]ull|NULL)?$/,
  resolve: () => new Scalar(null),
  stringify: ({ source }, ctx) => source && nullTag.test.test(source) ? source : ctx.options.nullStr
};

// node_modules/yaml/browser/dist/schema/core/bool.js
var boolTag = {
  identify: (value) => typeof value === "boolean",
  default: true,
  tag: "tag:yaml.org,2002:bool",
  test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,
  resolve: (str) => new Scalar(str[0] === "t" || str[0] === "T"),
  stringify({ source, value }, ctx) {
    if (source && boolTag.test.test(source)) {
      const sv = source[0] === "t" || source[0] === "T";
      if (value === sv)
        return source;
    }
    return value ? ctx.options.trueStr : ctx.options.falseStr;
  }
};

// node_modules/yaml/browser/dist/stringify/stringifyNumber.js
function stringifyNumber({ format, minFractionDigits, tag, value }) {
  if (typeof value === "bigint")
    return String(value);
  const num = typeof value === "number" ? value : Number(value);
  if (!isFinite(num))
    return isNaN(num) ? ".nan" : num < 0 ? "-.inf" : ".inf";
  let n = JSON.stringify(value);
  if (!format && minFractionDigits && (!tag || tag === "tag:yaml.org,2002:float") && /^\d/.test(n)) {
    let i = n.indexOf(".");
    if (i < 0) {
      i = n.length;
      n += ".";
    }
    let d = minFractionDigits - (n.length - i - 1);
    while (d-- > 0)
      n += "0";
  }
  return n;
}

// node_modules/yaml/browser/dist/schema/core/float.js
var floatNaN = {
  identify: (value) => typeof value === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  test: /^(?:[-+]?\.(?:inf|Inf|INF|nan|NaN|NAN))$/,
  resolve: (str) => str.slice(-3).toLowerCase() === "nan" ? NaN : str[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
  stringify: stringifyNumber
};
var floatExp = {
  identify: (value) => typeof value === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  format: "EXP",
  test: /^[-+]?(?:\.[0-9]+|[0-9]+(?:\.[0-9]*)?)[eE][-+]?[0-9]+$/,
  resolve: (str) => parseFloat(str),
  stringify(node) {
    const num = Number(node.value);
    return isFinite(num) ? num.toExponential() : stringifyNumber(node);
  }
};
var float = {
  identify: (value) => typeof value === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  test: /^[-+]?(?:\.[0-9]+|[0-9]+\.[0-9]*)$/,
  resolve(str) {
    const node = new Scalar(parseFloat(str));
    const dot = str.indexOf(".");
    if (dot !== -1 && str[str.length - 1] === "0")
      node.minFractionDigits = str.length - dot - 1;
    return node;
  },
  stringify: stringifyNumber
};

// node_modules/yaml/browser/dist/schema/core/int.js
var intIdentify = (value) => typeof value === "bigint" || Number.isInteger(value);
var intResolve = (str, offset, radix, { intAsBigInt }) => intAsBigInt ? BigInt(str) : parseInt(str.substring(offset), radix);
function intStringify(node, radix, prefix) {
  const { value } = node;
  if (intIdentify(value) && value >= 0)
    return prefix + value.toString(radix);
  return stringifyNumber(node);
}
var intOct = {
  identify: (value) => intIdentify(value) && value >= 0,
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "OCT",
  test: /^0o[0-7]+$/,
  resolve: (str, _onError, opt) => intResolve(str, 2, 8, opt),
  stringify: (node) => intStringify(node, 8, "0o")
};
var int = {
  identify: intIdentify,
  default: true,
  tag: "tag:yaml.org,2002:int",
  test: /^[-+]?[0-9]+$/,
  resolve: (str, _onError, opt) => intResolve(str, 0, 10, opt),
  stringify: stringifyNumber
};
var intHex = {
  identify: (value) => intIdentify(value) && value >= 0,
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "HEX",
  test: /^0x[0-9a-fA-F]+$/,
  resolve: (str, _onError, opt) => intResolve(str, 2, 16, opt),
  stringify: (node) => intStringify(node, 16, "0x")
};

// node_modules/yaml/browser/dist/schema/core/schema.js
var schema = [
  map,
  seq,
  string,
  nullTag,
  boolTag,
  intOct,
  int,
  intHex,
  floatNaN,
  floatExp,
  float
];

// node_modules/yaml/browser/dist/schema/json/schema.js
function intIdentify2(value) {
  return typeof value === "bigint" || Number.isInteger(value);
}
var stringifyJSON = ({ value }) => JSON.stringify(value);
var jsonScalars = [
  {
    identify: (value) => typeof value === "string",
    default: true,
    tag: "tag:yaml.org,2002:str",
    resolve: (str) => str,
    stringify: stringifyJSON
  },
  {
    identify: (value) => value == null,
    createNode: () => new Scalar(null),
    default: true,
    tag: "tag:yaml.org,2002:null",
    test: /^null$/,
    resolve: () => null,
    stringify: stringifyJSON
  },
  {
    identify: (value) => typeof value === "boolean",
    default: true,
    tag: "tag:yaml.org,2002:bool",
    test: /^true|false$/,
    resolve: (str) => str === "true",
    stringify: stringifyJSON
  },
  {
    identify: intIdentify2,
    default: true,
    tag: "tag:yaml.org,2002:int",
    test: /^-?(?:0|[1-9][0-9]*)$/,
    resolve: (str, _onError, { intAsBigInt }) => intAsBigInt ? BigInt(str) : parseInt(str, 10),
    stringify: ({ value }) => intIdentify2(value) ? value.toString() : JSON.stringify(value)
  },
  {
    identify: (value) => typeof value === "number",
    default: true,
    tag: "tag:yaml.org,2002:float",
    test: /^-?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,
    resolve: (str) => parseFloat(str),
    stringify: stringifyJSON
  }
];
var jsonError = {
  default: true,
  tag: "",
  test: /^/,
  resolve(str, onError) {
    onError(`Unresolved plain scalar ${JSON.stringify(str)}`);
    return str;
  }
};
var schema2 = [map, seq].concat(jsonScalars, jsonError);

// node_modules/yaml/browser/dist/schema/yaml-1.1/binary.js
var binary = {
  identify: (value) => value instanceof Uint8Array,
  default: false,
  tag: "tag:yaml.org,2002:binary",
  /**
   * Returns a Buffer in node and an Uint8Array in browsers
   *
   * To use the resulting buffer as an image, you'll want to do something like:
   *
   *   const blob = new Blob([buffer], { type: 'image/jpeg' })
   *   document.querySelector('#photo').src = URL.createObjectURL(blob)
   */
  resolve(src, onError) {
    if (typeof Buffer === "function") {
      return Buffer.from(src, "base64");
    } else if (typeof atob === "function") {
      const str = atob(src.replace(/[\n\r]/g, ""));
      const buffer = new Uint8Array(str.length);
      for (let i = 0; i < str.length; ++i)
        buffer[i] = str.charCodeAt(i);
      return buffer;
    } else {
      onError("This environment does not support reading binary tags; either Buffer or atob is required");
      return src;
    }
  },
  stringify({ comment, type, value }, ctx, onComment, onChompKeep) {
    const buf = value;
    let str;
    if (typeof Buffer === "function") {
      str = buf instanceof Buffer ? buf.toString("base64") : Buffer.from(buf.buffer).toString("base64");
    } else if (typeof btoa === "function") {
      let s = "";
      for (let i = 0; i < buf.length; ++i)
        s += String.fromCharCode(buf[i]);
      str = btoa(s);
    } else {
      throw new Error("This environment does not support writing binary tags; either Buffer or btoa is required");
    }
    if (!type)
      type = Scalar.BLOCK_LITERAL;
    if (type !== Scalar.QUOTE_DOUBLE) {
      const lineWidth = Math.max(ctx.options.lineWidth - ctx.indent.length, ctx.options.minContentWidth);
      const n = Math.ceil(str.length / lineWidth);
      const lines = new Array(n);
      for (let i = 0, o = 0; i < n; ++i, o += lineWidth) {
        lines[i] = str.substr(o, lineWidth);
      }
      str = lines.join(type === Scalar.BLOCK_LITERAL ? "\n" : " ");
    }
    return stringifyString({ comment, type, value: str }, ctx, onComment, onChompKeep);
  }
};

// node_modules/yaml/browser/dist/schema/yaml-1.1/pairs.js
function resolvePairs(seq2, onError) {
  if (isSeq(seq2)) {
    for (let i = 0; i < seq2.items.length; ++i) {
      let item = seq2.items[i];
      if (isPair(item))
        continue;
      else if (isMap(item)) {
        if (item.items.length > 1)
          onError("Each pair must have its own sequence indicator");
        const pair = item.items[0] || new Pair(new Scalar(null));
        if (item.commentBefore)
          pair.key.commentBefore = pair.key.commentBefore ? `${item.commentBefore}
${pair.key.commentBefore}` : item.commentBefore;
        if (item.comment) {
          const cn = pair.value || pair.key;
          cn.comment = cn.comment ? `${item.comment}
${cn.comment}` : item.comment;
        }
        item = pair;
      }
      seq2.items[i] = isPair(item) ? item : new Pair(item);
    }
  } else
    onError("Expected a sequence for this tag");
  return seq2;
}
function createPairs(schema4, iterable, ctx) {
  const { replacer } = ctx;
  const pairs2 = new YAMLSeq(schema4);
  pairs2.tag = "tag:yaml.org,2002:pairs";
  let i = 0;
  if (iterable && Symbol.iterator in Object(iterable))
    for (let it of iterable) {
      if (typeof replacer === "function")
        it = replacer.call(iterable, String(i++), it);
      let key, value;
      if (Array.isArray(it)) {
        if (it.length === 2) {
          key = it[0];
          value = it[1];
        } else
          throw new TypeError(`Expected [key, value] tuple: ${it}`);
      } else if (it && it instanceof Object) {
        const keys = Object.keys(it);
        if (keys.length === 1) {
          key = keys[0];
          value = it[key];
        } else
          throw new TypeError(`Expected { key: value } tuple: ${it}`);
      } else {
        key = it;
      }
      pairs2.items.push(createPair(key, value, ctx));
    }
  return pairs2;
}
var pairs = {
  collection: "seq",
  default: false,
  tag: "tag:yaml.org,2002:pairs",
  resolve: resolvePairs,
  createNode: createPairs
};

// node_modules/yaml/browser/dist/schema/yaml-1.1/omap.js
var YAMLOMap = class extends YAMLSeq {
  constructor() {
    super();
    this.add = YAMLMap.prototype.add.bind(this);
    this.delete = YAMLMap.prototype.delete.bind(this);
    this.get = YAMLMap.prototype.get.bind(this);
    this.has = YAMLMap.prototype.has.bind(this);
    this.set = YAMLMap.prototype.set.bind(this);
    this.tag = YAMLOMap.tag;
  }
  /**
   * If `ctx` is given, the return type is actually `Map<unknown, unknown>`,
   * but TypeScript won't allow widening the signature of a child method.
   */
  toJSON(_, ctx) {
    if (!ctx)
      return super.toJSON(_);
    const map2 = /* @__PURE__ */ new Map();
    if (ctx && ctx.onCreate)
      ctx.onCreate(map2);
    for (const pair of this.items) {
      let key, value;
      if (isPair(pair)) {
        key = toJS(pair.key, "", ctx);
        value = toJS(pair.value, key, ctx);
      } else {
        key = toJS(pair, "", ctx);
      }
      if (map2.has(key))
        throw new Error("Ordered maps must not include duplicate keys");
      map2.set(key, value);
    }
    return map2;
  }
};
YAMLOMap.tag = "tag:yaml.org,2002:omap";
var omap = {
  collection: "seq",
  identify: (value) => value instanceof Map,
  nodeClass: YAMLOMap,
  default: false,
  tag: "tag:yaml.org,2002:omap",
  resolve(seq2, onError) {
    const pairs2 = resolvePairs(seq2, onError);
    const seenKeys = [];
    for (const { key } of pairs2.items) {
      if (isScalar(key)) {
        if (seenKeys.includes(key.value)) {
          onError(`Ordered maps must not include duplicate keys: ${key.value}`);
        } else {
          seenKeys.push(key.value);
        }
      }
    }
    return Object.assign(new YAMLOMap(), pairs2);
  },
  createNode(schema4, iterable, ctx) {
    const pairs2 = createPairs(schema4, iterable, ctx);
    const omap2 = new YAMLOMap();
    omap2.items = pairs2.items;
    return omap2;
  }
};

// node_modules/yaml/browser/dist/schema/yaml-1.1/bool.js
function boolStringify({ value, source }, ctx) {
  const boolObj = value ? trueTag : falseTag;
  if (source && boolObj.test.test(source))
    return source;
  return value ? ctx.options.trueStr : ctx.options.falseStr;
}
var trueTag = {
  identify: (value) => value === true,
  default: true,
  tag: "tag:yaml.org,2002:bool",
  test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,
  resolve: () => new Scalar(true),
  stringify: boolStringify
};
var falseTag = {
  identify: (value) => value === false,
  default: true,
  tag: "tag:yaml.org,2002:bool",
  test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/i,
  resolve: () => new Scalar(false),
  stringify: boolStringify
};

// node_modules/yaml/browser/dist/schema/yaml-1.1/float.js
var floatNaN2 = {
  identify: (value) => typeof value === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  test: /^[-+]?\.(?:inf|Inf|INF|nan|NaN|NAN)$/,
  resolve: (str) => str.slice(-3).toLowerCase() === "nan" ? NaN : str[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
  stringify: stringifyNumber
};
var floatExp2 = {
  identify: (value) => typeof value === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  format: "EXP",
  test: /^[-+]?(?:[0-9][0-9_]*)?(?:\.[0-9_]*)?[eE][-+]?[0-9]+$/,
  resolve: (str) => parseFloat(str.replace(/_/g, "")),
  stringify(node) {
    const num = Number(node.value);
    return isFinite(num) ? num.toExponential() : stringifyNumber(node);
  }
};
var float2 = {
  identify: (value) => typeof value === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  test: /^[-+]?(?:[0-9][0-9_]*)?\.[0-9_]*$/,
  resolve(str) {
    const node = new Scalar(parseFloat(str.replace(/_/g, "")));
    const dot = str.indexOf(".");
    if (dot !== -1) {
      const f = str.substring(dot + 1).replace(/_/g, "");
      if (f[f.length - 1] === "0")
        node.minFractionDigits = f.length;
    }
    return node;
  },
  stringify: stringifyNumber
};

// node_modules/yaml/browser/dist/schema/yaml-1.1/int.js
var intIdentify3 = (value) => typeof value === "bigint" || Number.isInteger(value);
function intResolve2(str, offset, radix, { intAsBigInt }) {
  const sign = str[0];
  if (sign === "-" || sign === "+")
    offset += 1;
  str = str.substring(offset).replace(/_/g, "");
  if (intAsBigInt) {
    switch (radix) {
      case 2:
        str = `0b${str}`;
        break;
      case 8:
        str = `0o${str}`;
        break;
      case 16:
        str = `0x${str}`;
        break;
    }
    const n2 = BigInt(str);
    return sign === "-" ? BigInt(-1) * n2 : n2;
  }
  const n = parseInt(str, radix);
  return sign === "-" ? -1 * n : n;
}
function intStringify2(node, radix, prefix) {
  const { value } = node;
  if (intIdentify3(value)) {
    const str = value.toString(radix);
    return value < 0 ? "-" + prefix + str.substr(1) : prefix + str;
  }
  return stringifyNumber(node);
}
var intBin = {
  identify: intIdentify3,
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "BIN",
  test: /^[-+]?0b[0-1_]+$/,
  resolve: (str, _onError, opt) => intResolve2(str, 2, 2, opt),
  stringify: (node) => intStringify2(node, 2, "0b")
};
var intOct2 = {
  identify: intIdentify3,
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "OCT",
  test: /^[-+]?0[0-7_]+$/,
  resolve: (str, _onError, opt) => intResolve2(str, 1, 8, opt),
  stringify: (node) => intStringify2(node, 8, "0")
};
var int2 = {
  identify: intIdentify3,
  default: true,
  tag: "tag:yaml.org,2002:int",
  test: /^[-+]?[0-9][0-9_]*$/,
  resolve: (str, _onError, opt) => intResolve2(str, 0, 10, opt),
  stringify: stringifyNumber
};
var intHex2 = {
  identify: intIdentify3,
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "HEX",
  test: /^[-+]?0x[0-9a-fA-F_]+$/,
  resolve: (str, _onError, opt) => intResolve2(str, 2, 16, opt),
  stringify: (node) => intStringify2(node, 16, "0x")
};

// node_modules/yaml/browser/dist/schema/yaml-1.1/set.js
var YAMLSet = class extends YAMLMap {
  constructor(schema4) {
    super(schema4);
    this.tag = YAMLSet.tag;
  }
  add(key) {
    let pair;
    if (isPair(key))
      pair = key;
    else if (typeof key === "object" && "key" in key && "value" in key && key.value === null)
      pair = new Pair(key.key, null);
    else
      pair = new Pair(key, null);
    const prev = findPair(this.items, pair.key);
    if (!prev)
      this.items.push(pair);
  }
  get(key, keepPair) {
    const pair = findPair(this.items, key);
    return !keepPair && isPair(pair) ? isScalar(pair.key) ? pair.key.value : pair.key : pair;
  }
  set(key, value) {
    if (typeof value !== "boolean")
      throw new Error(`Expected boolean value for set(key, value) in a YAML set, not ${typeof value}`);
    const prev = findPair(this.items, key);
    if (prev && !value) {
      this.items.splice(this.items.indexOf(prev), 1);
    } else if (!prev && value) {
      this.items.push(new Pair(key));
    }
  }
  toJSON(_, ctx) {
    return super.toJSON(_, ctx, Set);
  }
  toString(ctx, onComment, onChompKeep) {
    if (!ctx)
      return JSON.stringify(this);
    if (this.hasAllNullValues(true))
      return super.toString(Object.assign({}, ctx, { allNullValues: true }), onComment, onChompKeep);
    else
      throw new Error("Set items must all have null values");
  }
};
YAMLSet.tag = "tag:yaml.org,2002:set";
var set = {
  collection: "map",
  identify: (value) => value instanceof Set,
  nodeClass: YAMLSet,
  default: false,
  tag: "tag:yaml.org,2002:set",
  resolve(map2, onError) {
    if (isMap(map2)) {
      if (map2.hasAllNullValues(true))
        return Object.assign(new YAMLSet(), map2);
      else
        onError("Set items must all have null values");
    } else
      onError("Expected a mapping for this tag");
    return map2;
  },
  createNode(schema4, iterable, ctx) {
    const { replacer } = ctx;
    const set2 = new YAMLSet(schema4);
    if (iterable && Symbol.iterator in Object(iterable))
      for (let value of iterable) {
        if (typeof replacer === "function")
          value = replacer.call(iterable, value, value);
        set2.items.push(createPair(value, null, ctx));
      }
    return set2;
  }
};

// node_modules/yaml/browser/dist/schema/yaml-1.1/timestamp.js
function parseSexagesimal(str, asBigInt) {
  const sign = str[0];
  const parts = sign === "-" || sign === "+" ? str.substring(1) : str;
  const num = (n) => asBigInt ? BigInt(n) : Number(n);
  const res = parts.replace(/_/g, "").split(":").reduce((res2, p) => res2 * num(60) + num(p), num(0));
  return sign === "-" ? num(-1) * res : res;
}
function stringifySexagesimal(node) {
  let { value } = node;
  let num = (n) => n;
  if (typeof value === "bigint")
    num = (n) => BigInt(n);
  else if (isNaN(value) || !isFinite(value))
    return stringifyNumber(node);
  let sign = "";
  if (value < 0) {
    sign = "-";
    value *= num(-1);
  }
  const _60 = num(60);
  const parts = [value % _60];
  if (value < 60) {
    parts.unshift(0);
  } else {
    value = (value - parts[0]) / _60;
    parts.unshift(value % _60);
    if (value >= 60) {
      value = (value - parts[0]) / _60;
      parts.unshift(value);
    }
  }
  return sign + parts.map((n) => n < 10 ? "0" + String(n) : String(n)).join(":").replace(/000000\d*$/, "");
}
var intTime = {
  identify: (value) => typeof value === "bigint" || Number.isInteger(value),
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "TIME",
  test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+$/,
  resolve: (str, _onError, { intAsBigInt }) => parseSexagesimal(str, intAsBigInt),
  stringify: stringifySexagesimal
};
var floatTime = {
  identify: (value) => typeof value === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  format: "TIME",
  test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\.[0-9_]*$/,
  resolve: (str) => parseSexagesimal(str, false),
  stringify: stringifySexagesimal
};
var timestamp = {
  identify: (value) => value instanceof Date,
  default: true,
  tag: "tag:yaml.org,2002:timestamp",
  // If the time zone is omitted, the timestamp is assumed to be specified in UTC. The time part
  // may be omitted altogether, resulting in a date format. In such a case, the time part is
  // assumed to be 00:00:00Z (start of day, UTC).
  test: RegExp("^([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})(?:(?:t|T|[ \\t]+)([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\.[0-9]+)?)(?:[ \\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?)?$"),
  resolve(str) {
    const match = str.match(timestamp.test);
    if (!match)
      throw new Error("!!timestamp expects a date, starting with yyyy-mm-dd");
    const [, year, month, day, hour, minute, second] = match.map(Number);
    const millisec = match[7] ? Number((match[7] + "00").substr(1, 3)) : 0;
    let date = Date.UTC(year, month - 1, day, hour || 0, minute || 0, second || 0, millisec);
    const tz = match[8];
    if (tz && tz !== "Z") {
      let d = parseSexagesimal(tz, false);
      if (Math.abs(d) < 30)
        d *= 60;
      date -= 6e4 * d;
    }
    return new Date(date);
  },
  stringify: ({ value }) => value.toISOString().replace(/((T00:00)?:00)?\.000Z$/, "")
};

// node_modules/yaml/browser/dist/schema/yaml-1.1/schema.js
var schema3 = [
  map,
  seq,
  string,
  nullTag,
  trueTag,
  falseTag,
  intBin,
  intOct2,
  int2,
  intHex2,
  floatNaN2,
  floatExp2,
  float2,
  binary,
  omap,
  pairs,
  set,
  intTime,
  floatTime,
  timestamp
];

// node_modules/yaml/browser/dist/schema/tags.js
var schemas = /* @__PURE__ */ new Map([
  ["core", schema],
  ["failsafe", [map, seq, string]],
  ["json", schema2],
  ["yaml11", schema3],
  ["yaml-1.1", schema3]
]);
var tagsByName = {
  binary,
  bool: boolTag,
  float,
  floatExp,
  floatNaN,
  floatTime,
  int,
  intHex,
  intOct,
  intTime,
  map,
  null: nullTag,
  omap,
  pairs,
  seq,
  set,
  timestamp
};
var coreKnownTags = {
  "tag:yaml.org,2002:binary": binary,
  "tag:yaml.org,2002:omap": omap,
  "tag:yaml.org,2002:pairs": pairs,
  "tag:yaml.org,2002:set": set,
  "tag:yaml.org,2002:timestamp": timestamp
};
function getTags(customTags, schemaName) {
  let tags = schemas.get(schemaName);
  if (!tags) {
    if (Array.isArray(customTags))
      tags = [];
    else {
      const keys = Array.from(schemas.keys()).filter((key) => key !== "yaml11").map((key) => JSON.stringify(key)).join(", ");
      throw new Error(`Unknown schema "${schemaName}"; use one of ${keys} or define customTags array`);
    }
  }
  if (Array.isArray(customTags)) {
    for (const tag of customTags)
      tags = tags.concat(tag);
  } else if (typeof customTags === "function") {
    tags = customTags(tags.slice());
  }
  return tags.map((tag) => {
    if (typeof tag !== "string")
      return tag;
    const tagObj = tagsByName[tag];
    if (tagObj)
      return tagObj;
    const keys = Object.keys(tagsByName).map((key) => JSON.stringify(key)).join(", ");
    throw new Error(`Unknown custom tag "${tag}"; use one of ${keys}`);
  });
}

// node_modules/yaml/browser/dist/schema/Schema.js
var sortMapEntriesByKey = (a, b) => a.key < b.key ? -1 : a.key > b.key ? 1 : 0;
var Schema = class {
  constructor({ compat, customTags, merge, resolveKnownTags, schema: schema4, sortMapEntries, toStringDefaults }) {
    this.compat = Array.isArray(compat) ? getTags(compat, "compat") : compat ? getTags(null, compat) : null;
    this.merge = !!merge;
    this.name = typeof schema4 === "string" && schema4 || "core";
    this.knownTags = resolveKnownTags ? coreKnownTags : {};
    this.tags = getTags(customTags, this.name);
    this.toStringOptions = toStringDefaults || null;
    Object.defineProperty(this, MAP, { value: map });
    Object.defineProperty(this, SCALAR, { value: string });
    Object.defineProperty(this, SEQ, { value: seq });
    this.sortMapEntries = sortMapEntries === true ? sortMapEntriesByKey : sortMapEntries || null;
  }
  clone() {
    const copy = Object.create(Schema.prototype, Object.getOwnPropertyDescriptors(this));
    copy.tags = this.tags.slice();
    return copy;
  }
};

// node_modules/yaml/browser/dist/stringify/stringifyDocument.js
function stringifyDocument(doc, options) {
  const lines = [];
  let hasDirectives = options.directives === true;
  if (options.directives !== false && doc.directives) {
    const dir = doc.directives.toString(doc);
    if (dir) {
      lines.push(dir);
      hasDirectives = true;
    } else if (doc.directives.marker)
      hasDirectives = true;
  }
  if (hasDirectives)
    lines.push("---");
  const ctx = createStringifyContext(doc, options);
  const { commentString } = ctx.options;
  if (doc.commentBefore) {
    if (lines.length !== 1)
      lines.unshift("");
    const cs = commentString(doc.commentBefore);
    lines.unshift(indentComment(cs, ""));
  }
  let chompKeep = false;
  let contentComment = null;
  if (doc.contents) {
    if (isNode(doc.contents)) {
      if (doc.contents.spaceBefore && hasDirectives)
        lines.push("");
      if (doc.contents.commentBefore) {
        const cs = commentString(doc.contents.commentBefore);
        lines.push(indentComment(cs, ""));
      }
      ctx.forceBlockIndent = !!doc.comment;
      contentComment = doc.contents.comment;
    }
    const onChompKeep = contentComment ? void 0 : () => chompKeep = true;
    let body = stringify(doc.contents, ctx, () => contentComment = null, onChompKeep);
    if (contentComment)
      body += lineComment(body, "", commentString(contentComment));
    if ((body[0] === "|" || body[0] === ">") && lines[lines.length - 1] === "---") {
      lines[lines.length - 1] = `--- ${body}`;
    } else
      lines.push(body);
  } else {
    lines.push(stringify(doc.contents, ctx));
  }
  let dc = doc.comment;
  if (dc && chompKeep)
    dc = dc.replace(/^\n+/, "");
  if (dc) {
    if ((!chompKeep || contentComment) && lines[lines.length - 1] !== "")
      lines.push("");
    lines.push(indentComment(commentString(dc), ""));
  }
  return lines.join("\n") + "\n";
}

// node_modules/yaml/browser/dist/doc/applyReviver.js
function applyReviver(reviver, obj, key, val) {
  if (val && typeof val === "object") {
    if (Array.isArray(val)) {
      for (let i = 0, len = val.length; i < len; ++i) {
        const v0 = val[i];
        const v1 = applyReviver(reviver, val, String(i), v0);
        if (v1 === void 0)
          delete val[i];
        else if (v1 !== v0)
          val[i] = v1;
      }
    } else if (val instanceof Map) {
      for (const k of Array.from(val.keys())) {
        const v0 = val.get(k);
        const v1 = applyReviver(reviver, val, k, v0);
        if (v1 === void 0)
          val.delete(k);
        else if (v1 !== v0)
          val.set(k, v1);
      }
    } else if (val instanceof Set) {
      for (const v0 of Array.from(val)) {
        const v1 = applyReviver(reviver, val, v0, v0);
        if (v1 === void 0)
          val.delete(v0);
        else if (v1 !== v0) {
          val.delete(v0);
          val.add(v1);
        }
      }
    } else {
      for (const [k, v0] of Object.entries(val)) {
        const v1 = applyReviver(reviver, val, k, v0);
        if (v1 === void 0)
          delete val[k];
        else if (v1 !== v0)
          val[k] = v1;
      }
    }
  }
  return reviver.call(obj, key, val);
}

// node_modules/yaml/browser/dist/doc/Document.js
var Document = class {
  constructor(value, replacer, options) {
    this.commentBefore = null;
    this.comment = null;
    this.errors = [];
    this.warnings = [];
    Object.defineProperty(this, NODE_TYPE, { value: DOC });
    let _replacer = null;
    if (typeof replacer === "function" || Array.isArray(replacer)) {
      _replacer = replacer;
    } else if (options === void 0 && replacer) {
      options = replacer;
      replacer = void 0;
    }
    const opt = Object.assign({}, defaultOptions, options);
    this.options = opt;
    let { version } = opt;
    if (options === null || options === void 0 ? void 0 : options.directives) {
      this.directives = options.directives.atDocument();
      if (this.directives.yaml.explicit)
        version = this.directives.yaml.version;
    } else
      this.directives = new Directives({ version });
    this.setSchema(version, options);
    if (value === void 0)
      this.contents = null;
    else {
      this.contents = this.createNode(value, _replacer, options);
    }
  }
  /**
   * Create a deep copy of this Document and its contents.
   *
   * Custom Node values that inherit from `Object` still refer to their original instances.
   */
  clone() {
    const copy = Object.create(Document.prototype, {
      [NODE_TYPE]: { value: DOC }
    });
    copy.commentBefore = this.commentBefore;
    copy.comment = this.comment;
    copy.errors = this.errors.slice();
    copy.warnings = this.warnings.slice();
    copy.options = Object.assign({}, this.options);
    if (this.directives)
      copy.directives = this.directives.clone();
    copy.schema = this.schema.clone();
    copy.contents = isNode(this.contents) ? this.contents.clone(copy.schema) : this.contents;
    if (this.range)
      copy.range = this.range.slice();
    return copy;
  }
  /** Adds a value to the document. */
  add(value) {
    if (assertCollection(this.contents))
      this.contents.add(value);
  }
  /** Adds a value to the document. */
  addIn(path, value) {
    if (assertCollection(this.contents))
      this.contents.addIn(path, value);
  }
  /**
   * Create a new `Alias` node, ensuring that the target `node` has the required anchor.
   *
   * If `node` already has an anchor, `name` is ignored.
   * Otherwise, the `node.anchor` value will be set to `name`,
   * or if an anchor with that name is already present in the document,
   * `name` will be used as a prefix for a new unique anchor.
   * If `name` is undefined, the generated anchor will use 'a' as a prefix.
   */
  createAlias(node, name) {
    if (!node.anchor) {
      const prev = anchorNames(this);
      node.anchor = !name || prev.has(name) ? findNewAnchor(name || "a", prev) : name;
    }
    return new Alias(node.anchor);
  }
  createNode(value, replacer, options) {
    let _replacer = void 0;
    if (typeof replacer === "function") {
      value = replacer.call({ "": value }, "", value);
      _replacer = replacer;
    } else if (Array.isArray(replacer)) {
      const keyToStr = (v) => typeof v === "number" || v instanceof String || v instanceof Number;
      const asStr = replacer.filter(keyToStr).map(String);
      if (asStr.length > 0)
        replacer = replacer.concat(asStr);
      _replacer = replacer;
    } else if (options === void 0 && replacer) {
      options = replacer;
      replacer = void 0;
    }
    const { aliasDuplicateObjects, anchorPrefix, flow, keepUndefined, onTagObj, tag } = options || {};
    const { onAnchor, setAnchors, sourceObjects } = createNodeAnchors(this, anchorPrefix || "a");
    const ctx = {
      aliasDuplicateObjects: aliasDuplicateObjects !== null && aliasDuplicateObjects !== void 0 ? aliasDuplicateObjects : true,
      keepUndefined: keepUndefined !== null && keepUndefined !== void 0 ? keepUndefined : false,
      onAnchor,
      onTagObj,
      replacer: _replacer,
      schema: this.schema,
      sourceObjects
    };
    const node = createNode(value, tag, ctx);
    if (flow && isCollection(node))
      node.flow = true;
    setAnchors();
    return node;
  }
  /**
   * Convert a key and a value into a `Pair` using the current schema,
   * recursively wrapping all values as `Scalar` or `Collection` nodes.
   */
  createPair(key, value, options = {}) {
    const k = this.createNode(key, null, options);
    const v = this.createNode(value, null, options);
    return new Pair(k, v);
  }
  /**
   * Removes a value from the document.
   * @returns `true` if the item was found and removed.
   */
  delete(key) {
    return assertCollection(this.contents) ? this.contents.delete(key) : false;
  }
  /**
   * Removes a value from the document.
   * @returns `true` if the item was found and removed.
   */
  deleteIn(path) {
    if (isEmptyPath(path)) {
      if (this.contents == null)
        return false;
      this.contents = null;
      return true;
    }
    return assertCollection(this.contents) ? this.contents.deleteIn(path) : false;
  }
  /**
   * Returns item at `key`, or `undefined` if not found. By default unwraps
   * scalar values from their surrounding node; to disable set `keepScalar` to
   * `true` (collections are always returned intact).
   */
  get(key, keepScalar) {
    return isCollection(this.contents) ? this.contents.get(key, keepScalar) : void 0;
  }
  /**
   * Returns item at `path`, or `undefined` if not found. By default unwraps
   * scalar values from their surrounding node; to disable set `keepScalar` to
   * `true` (collections are always returned intact).
   */
  getIn(path, keepScalar) {
    if (isEmptyPath(path))
      return !keepScalar && isScalar(this.contents) ? this.contents.value : this.contents;
    return isCollection(this.contents) ? this.contents.getIn(path, keepScalar) : void 0;
  }
  /**
   * Checks if the document includes a value with the key `key`.
   */
  has(key) {
    return isCollection(this.contents) ? this.contents.has(key) : false;
  }
  /**
   * Checks if the document includes a value at `path`.
   */
  hasIn(path) {
    if (isEmptyPath(path))
      return this.contents !== void 0;
    return isCollection(this.contents) ? this.contents.hasIn(path) : false;
  }
  /**
   * Sets a value in this document. For `!!set`, `value` needs to be a
   * boolean to add/remove the item from the set.
   */
  set(key, value) {
    if (this.contents == null) {
      this.contents = collectionFromPath(this.schema, [key], value);
    } else if (assertCollection(this.contents)) {
      this.contents.set(key, value);
    }
  }
  /**
   * Sets a value in this document. For `!!set`, `value` needs to be a
   * boolean to add/remove the item from the set.
   */
  setIn(path, value) {
    if (isEmptyPath(path))
      this.contents = value;
    else if (this.contents == null) {
      this.contents = collectionFromPath(this.schema, Array.from(path), value);
    } else if (assertCollection(this.contents)) {
      this.contents.setIn(path, value);
    }
  }
  /**
   * Change the YAML version and schema used by the document.
   * A `null` version disables support for directives, explicit tags, anchors, and aliases.
   * It also requires the `schema` option to be given as a `Schema` instance value.
   *
   * Overrides all previously set schema options.
   */
  setSchema(version, options = {}) {
    if (typeof version === "number")
      version = String(version);
    let opt;
    switch (version) {
      case "1.1":
        if (this.directives)
          this.directives.yaml.version = "1.1";
        else
          this.directives = new Directives({ version: "1.1" });
        opt = { merge: true, resolveKnownTags: false, schema: "yaml-1.1" };
        break;
      case "1.2":
        if (this.directives)
          this.directives.yaml.version = "1.2";
        else
          this.directives = new Directives({ version: "1.2" });
        opt = { merge: false, resolveKnownTags: true, schema: "core" };
        break;
      case null:
        if (this.directives)
          delete this.directives;
        opt = null;
        break;
      default: {
        const sv = JSON.stringify(version);
        throw new Error(`Expected '1.1', '1.2' or null as first argument, but found: ${sv}`);
      }
    }
    if (options.schema instanceof Object)
      this.schema = options.schema;
    else if (opt)
      this.schema = new Schema(Object.assign(opt, options));
    else
      throw new Error(`With a null YAML version, the { schema: Schema } option is required`);
  }
  // json & jsonArg are only used from toJSON()
  toJS({ json, jsonArg, mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {
    const ctx = {
      anchors: /* @__PURE__ */ new Map(),
      doc: this,
      keep: !json,
      mapAsMap: mapAsMap === true,
      mapKeyWarned: false,
      maxAliasCount: typeof maxAliasCount === "number" ? maxAliasCount : 100,
      stringify
    };
    const res = toJS(this.contents, jsonArg || "", ctx);
    if (typeof onAnchor === "function")
      for (const { count, res: res2 } of ctx.anchors.values())
        onAnchor(res2, count);
    return typeof reviver === "function" ? applyReviver(reviver, { "": res }, "", res) : res;
  }
  /**
   * A JSON representation of the document `contents`.
   *
   * @param jsonArg Used by `JSON.stringify` to indicate the array index or
   *   property name.
   */
  toJSON(jsonArg, onAnchor) {
    return this.toJS({ json: true, jsonArg, mapAsMap: false, onAnchor });
  }
  /** A YAML representation of the document. */
  toString(options = {}) {
    if (this.errors.length > 0)
      throw new Error("Document with errors cannot be stringified");
    if ("indent" in options && (!Number.isInteger(options.indent) || Number(options.indent) <= 0)) {
      const s = JSON.stringify(options.indent);
      throw new Error(`"indent" option must be a positive integer, not ${s}`);
    }
    return stringifyDocument(this, options);
  }
};
function assertCollection(contents) {
  if (isCollection(contents))
    return true;
  throw new Error("Expected a YAML collection as document contents");
}

// node_modules/yaml/browser/dist/errors.js
var YAMLError = class extends Error {
  constructor(name, pos, code, message) {
    super();
    this.name = name;
    this.code = code;
    this.message = message;
    this.pos = pos;
  }
};
var YAMLParseError = class extends YAMLError {
  constructor(pos, code, message) {
    super("YAMLParseError", pos, code, message);
  }
};
var YAMLWarning = class extends YAMLError {
  constructor(pos, code, message) {
    super("YAMLWarning", pos, code, message);
  }
};
var prettifyError = (src, lc) => (error) => {
  if (error.pos[0] === -1)
    return;
  error.linePos = error.pos.map((pos) => lc.linePos(pos));
  const { line, col } = error.linePos[0];
  error.message += ` at line ${line}, column ${col}`;
  let ci = col - 1;
  let lineStr = src.substring(lc.lineStarts[line - 1], lc.lineStarts[line]).replace(/[\n\r]+$/, "");
  if (ci >= 60 && lineStr.length > 80) {
    const trimStart = Math.min(ci - 39, lineStr.length - 79);
    lineStr = "\u2026" + lineStr.substring(trimStart);
    ci -= trimStart - 1;
  }
  if (lineStr.length > 80)
    lineStr = lineStr.substring(0, 79) + "\u2026";
  if (line > 1 && /^ *$/.test(lineStr.substring(0, ci))) {
    let prev = src.substring(lc.lineStarts[line - 2], lc.lineStarts[line - 1]);
    if (prev.length > 80)
      prev = prev.substring(0, 79) + "\u2026\n";
    lineStr = prev + lineStr;
  }
  if (/[^ ]/.test(lineStr)) {
    let count = 1;
    const end = error.linePos[1];
    if (end && end.line === line && end.col > col) {
      count = Math.min(end.col - col, 80 - ci);
    }
    const pointer = " ".repeat(ci) + "^".repeat(count);
    error.message += `:

${lineStr}
${pointer}
`;
  }
};

// node_modules/yaml/browser/dist/compose/resolve-props.js
function resolveProps(tokens, { flow, indicator, next, offset, onError, startOnNewline }) {
  let spaceBefore = false;
  let atNewline = startOnNewline;
  let hasSpace = startOnNewline;
  let comment = "";
  let commentSep = "";
  let hasNewline = false;
  let reqSpace = false;
  let anchor = null;
  let tag = null;
  let comma = null;
  let found = null;
  let start = null;
  for (const token of tokens) {
    if (reqSpace) {
      if (token.type !== "space" && token.type !== "newline" && token.type !== "comma")
        onError(token.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space");
      reqSpace = false;
    }
    switch (token.type) {
      case "space":
        if (!flow && atNewline && indicator !== "doc-start" && token.source[0] === "	")
          onError(token, "TAB_AS_INDENT", "Tabs are not allowed as indentation");
        hasSpace = true;
        break;
      case "comment": {
        if (!hasSpace)
          onError(token, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
        const cb = token.source.substring(1) || " ";
        if (!comment)
          comment = cb;
        else
          comment += commentSep + cb;
        commentSep = "";
        atNewline = false;
        break;
      }
      case "newline":
        if (atNewline) {
          if (comment)
            comment += token.source;
          else
            spaceBefore = true;
        } else
          commentSep += token.source;
        atNewline = true;
        hasNewline = true;
        hasSpace = true;
        break;
      case "anchor":
        if (anchor)
          onError(token, "MULTIPLE_ANCHORS", "A node can have at most one anchor");
        anchor = token;
        if (start === null)
          start = token.offset;
        atNewline = false;
        hasSpace = false;
        reqSpace = true;
        break;
      case "tag": {
        if (tag)
          onError(token, "MULTIPLE_TAGS", "A node can have at most one tag");
        tag = token;
        if (start === null)
          start = token.offset;
        atNewline = false;
        hasSpace = false;
        reqSpace = true;
        break;
      }
      case indicator:
        if (anchor || tag)
          onError(token, "BAD_PROP_ORDER", `Anchors and tags must be after the ${token.source} indicator`);
        if (found)
          onError(token, "UNEXPECTED_TOKEN", `Unexpected ${token.source} in ${flow || "collection"}`);
        found = token;
        atNewline = false;
        hasSpace = false;
        break;
      case "comma":
        if (flow) {
          if (comma)
            onError(token, "UNEXPECTED_TOKEN", `Unexpected , in ${flow}`);
          comma = token;
          atNewline = false;
          hasSpace = false;
          break;
        }
      default:
        onError(token, "UNEXPECTED_TOKEN", `Unexpected ${token.type} token`);
        atNewline = false;
        hasSpace = false;
    }
  }
  const last = tokens[tokens.length - 1];
  const end = last ? last.offset + last.source.length : offset;
  if (reqSpace && next && next.type !== "space" && next.type !== "newline" && next.type !== "comma" && (next.type !== "scalar" || next.source !== ""))
    onError(next.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space");
  return {
    comma,
    found,
    spaceBefore,
    comment,
    hasNewline,
    anchor,
    tag,
    end,
    start: start !== null && start !== void 0 ? start : end
  };
}

// node_modules/yaml/browser/dist/compose/util-contains-newline.js
function containsNewline(key) {
  if (!key)
    return null;
  switch (key.type) {
    case "alias":
    case "scalar":
    case "double-quoted-scalar":
    case "single-quoted-scalar":
      if (key.source.includes("\n"))
        return true;
      if (key.end) {
        for (const st of key.end)
          if (st.type === "newline")
            return true;
      }
      return false;
    case "flow-collection":
      for (const it of key.items) {
        for (const st of it.start)
          if (st.type === "newline")
            return true;
        if (it.sep) {
          for (const st of it.sep)
            if (st.type === "newline")
              return true;
        }
        if (containsNewline(it.key) || containsNewline(it.value))
          return true;
      }
      return false;
    default:
      return true;
  }
}

// node_modules/yaml/browser/dist/compose/util-flow-indent-check.js
function flowIndentCheck(indent, fc, onError) {
  if ((fc === null || fc === void 0 ? void 0 : fc.type) === "flow-collection") {
    const end = fc.end[0];
    if (end.indent === indent && (end.source === "]" || end.source === "}") && containsNewline(fc)) {
      const msg = "Flow end indicator should be more indented than parent";
      onError(end, "BAD_INDENT", msg, true);
    }
  }
}

// node_modules/yaml/browser/dist/compose/util-map-includes.js
function mapIncludes(ctx, items, search) {
  const { uniqueKeys } = ctx.options;
  if (uniqueKeys === false)
    return false;
  const isEqual = typeof uniqueKeys === "function" ? uniqueKeys : (a, b) => a === b || isScalar(a) && isScalar(b) && a.value === b.value && !(a.value === "<<" && ctx.schema.merge);
  return items.some((pair) => isEqual(pair.key, search));
}

// node_modules/yaml/browser/dist/compose/resolve-block-map.js
var startColMsg = "All mapping items must start at the same column";
function resolveBlockMap({ composeNode: composeNode2, composeEmptyNode: composeEmptyNode2 }, ctx, bm, onError) {
  var _a;
  const map2 = new YAMLMap(ctx.schema);
  if (ctx.atRoot)
    ctx.atRoot = false;
  let offset = bm.offset;
  for (const collItem of bm.items) {
    const { start, key, sep, value } = collItem;
    const keyProps = resolveProps(start, {
      indicator: "explicit-key-ind",
      next: key || (sep === null || sep === void 0 ? void 0 : sep[0]),
      offset,
      onError,
      startOnNewline: true
    });
    const implicitKey = !keyProps.found;
    if (implicitKey) {
      if (key) {
        if (key.type === "block-seq")
          onError(offset, "BLOCK_AS_IMPLICIT_KEY", "A block sequence may not be used as an implicit map key");
        else if ("indent" in key && key.indent !== bm.indent)
          onError(offset, "BAD_INDENT", startColMsg);
      }
      if (!keyProps.anchor && !keyProps.tag && !sep) {
        if (keyProps.comment) {
          if (map2.comment)
            map2.comment += "\n" + keyProps.comment;
          else
            map2.comment = keyProps.comment;
        }
        continue;
      }
    } else if (((_a = keyProps.found) === null || _a === void 0 ? void 0 : _a.indent) !== bm.indent)
      onError(offset, "BAD_INDENT", startColMsg);
    if (implicitKey && containsNewline(key))
      onError(
        key,
        // checked by containsNewline()
        "MULTILINE_IMPLICIT_KEY",
        "Implicit keys need to be on a single line"
      );
    const keyStart = keyProps.end;
    const keyNode = key ? composeNode2(ctx, key, keyProps, onError) : composeEmptyNode2(ctx, keyStart, start, null, keyProps, onError);
    if (ctx.schema.compat)
      flowIndentCheck(bm.indent, key, onError);
    if (mapIncludes(ctx, map2.items, keyNode))
      onError(keyStart, "DUPLICATE_KEY", "Map keys must be unique");
    const valueProps = resolveProps(sep || [], {
      indicator: "map-value-ind",
      next: value,
      offset: keyNode.range[2],
      onError,
      startOnNewline: !key || key.type === "block-scalar"
    });
    offset = valueProps.end;
    if (valueProps.found) {
      if (implicitKey) {
        if ((value === null || value === void 0 ? void 0 : value.type) === "block-map" && !valueProps.hasNewline)
          onError(offset, "BLOCK_AS_IMPLICIT_KEY", "Nested mappings are not allowed in compact mappings");
        if (ctx.options.strict && keyProps.start < valueProps.found.offset - 1024)
          onError(keyNode.range, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit block mapping key");
      }
      const valueNode = value ? composeNode2(ctx, value, valueProps, onError) : composeEmptyNode2(ctx, offset, sep, null, valueProps, onError);
      if (ctx.schema.compat)
        flowIndentCheck(bm.indent, value, onError);
      offset = valueNode.range[2];
      const pair = new Pair(keyNode, valueNode);
      if (ctx.options.keepSourceTokens)
        pair.srcToken = collItem;
      map2.items.push(pair);
    } else {
      if (implicitKey)
        onError(keyNode.range, "MISSING_CHAR", "Implicit map keys need to be followed by map values");
      if (valueProps.comment) {
        if (keyNode.comment)
          keyNode.comment += "\n" + valueProps.comment;
        else
          keyNode.comment = valueProps.comment;
      }
      const pair = new Pair(keyNode);
      if (ctx.options.keepSourceTokens)
        pair.srcToken = collItem;
      map2.items.push(pair);
    }
  }
  map2.range = [bm.offset, offset, offset];
  return map2;
}

// node_modules/yaml/browser/dist/compose/resolve-block-seq.js
function resolveBlockSeq({ composeNode: composeNode2, composeEmptyNode: composeEmptyNode2 }, ctx, bs, onError) {
  const seq2 = new YAMLSeq(ctx.schema);
  if (ctx.atRoot)
    ctx.atRoot = false;
  let offset = bs.offset;
  for (const { start, value } of bs.items) {
    const props = resolveProps(start, {
      indicator: "seq-item-ind",
      next: value,
      offset,
      onError,
      startOnNewline: true
    });
    offset = props.end;
    if (!props.found) {
      if (props.anchor || props.tag || value) {
        if (value && value.type === "block-seq")
          onError(offset, "BAD_INDENT", "All sequence items must start at the same column");
        else
          onError(offset, "MISSING_CHAR", "Sequence item without - indicator");
      } else {
        if (props.comment)
          seq2.comment = props.comment;
        continue;
      }
    }
    const node = value ? composeNode2(ctx, value, props, onError) : composeEmptyNode2(ctx, offset, start, null, props, onError);
    if (ctx.schema.compat)
      flowIndentCheck(bs.indent, value, onError);
    offset = node.range[2];
    seq2.items.push(node);
  }
  seq2.range = [bs.offset, offset, offset];
  return seq2;
}

// node_modules/yaml/browser/dist/compose/resolve-end.js
function resolveEnd(end, offset, reqSpace, onError) {
  let comment = "";
  if (end) {
    let hasSpace = false;
    let sep = "";
    for (const token of end) {
      const { source, type } = token;
      switch (type) {
        case "space":
          hasSpace = true;
          break;
        case "comment": {
          if (reqSpace && !hasSpace)
            onError(token, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
          const cb = source.substring(1) || " ";
          if (!comment)
            comment = cb;
          else
            comment += sep + cb;
          sep = "";
          break;
        }
        case "newline":
          if (comment)
            sep += source;
          hasSpace = true;
          break;
        default:
          onError(token, "UNEXPECTED_TOKEN", `Unexpected ${type} at node end`);
      }
      offset += source.length;
    }
  }
  return { comment, offset };
}

// node_modules/yaml/browser/dist/compose/resolve-flow-collection.js
var blockMsg = "Block collections are not allowed within flow collections";
var isBlock = (token) => token && (token.type === "block-map" || token.type === "block-seq");
function resolveFlowCollection({ composeNode: composeNode2, composeEmptyNode: composeEmptyNode2 }, ctx, fc, onError) {
  const isMap2 = fc.start.source === "{";
  const fcName = isMap2 ? "flow map" : "flow sequence";
  const coll = isMap2 ? new YAMLMap(ctx.schema) : new YAMLSeq(ctx.schema);
  coll.flow = true;
  const atRoot = ctx.atRoot;
  if (atRoot)
    ctx.atRoot = false;
  let offset = fc.offset + fc.start.source.length;
  for (let i = 0; i < fc.items.length; ++i) {
    const collItem = fc.items[i];
    const { start, key, sep, value } = collItem;
    const props = resolveProps(start, {
      flow: fcName,
      indicator: "explicit-key-ind",
      next: key || (sep === null || sep === void 0 ? void 0 : sep[0]),
      offset,
      onError,
      startOnNewline: false
    });
    if (!props.found) {
      if (!props.anchor && !props.tag && !sep && !value) {
        if (i === 0 && props.comma)
          onError(props.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${fcName}`);
        else if (i < fc.items.length - 1)
          onError(props.start, "UNEXPECTED_TOKEN", `Unexpected empty item in ${fcName}`);
        if (props.comment) {
          if (coll.comment)
            coll.comment += "\n" + props.comment;
          else
            coll.comment = props.comment;
        }
        offset = props.end;
        continue;
      }
      if (!isMap2 && ctx.options.strict && containsNewline(key))
        onError(
          key,
          // checked by containsNewline()
          "MULTILINE_IMPLICIT_KEY",
          "Implicit keys of flow sequence pairs need to be on a single line"
        );
    }
    if (i === 0) {
      if (props.comma)
        onError(props.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${fcName}`);
    } else {
      if (!props.comma)
        onError(props.start, "MISSING_CHAR", `Missing , between ${fcName} items`);
      if (props.comment) {
        let prevItemComment = "";
        loop:
          for (const st of start) {
            switch (st.type) {
              case "comma":
              case "space":
                break;
              case "comment":
                prevItemComment = st.source.substring(1);
                break loop;
              default:
                break loop;
            }
          }
        if (prevItemComment) {
          let prev = coll.items[coll.items.length - 1];
          if (isPair(prev))
            prev = prev.value || prev.key;
          if (prev.comment)
            prev.comment += "\n" + prevItemComment;
          else
            prev.comment = prevItemComment;
          props.comment = props.comment.substring(prevItemComment.length + 1);
        }
      }
    }
    if (!isMap2 && !sep && !props.found) {
      const valueNode = value ? composeNode2(ctx, value, props, onError) : composeEmptyNode2(ctx, props.end, sep, null, props, onError);
      coll.items.push(valueNode);
      offset = valueNode.range[2];
      if (isBlock(value))
        onError(valueNode.range, "BLOCK_IN_FLOW", blockMsg);
    } else {
      const keyStart = props.end;
      const keyNode = key ? composeNode2(ctx, key, props, onError) : composeEmptyNode2(ctx, keyStart, start, null, props, onError);
      if (isBlock(key))
        onError(keyNode.range, "BLOCK_IN_FLOW", blockMsg);
      const valueProps = resolveProps(sep || [], {
        flow: fcName,
        indicator: "map-value-ind",
        next: value,
        offset: keyNode.range[2],
        onError,
        startOnNewline: false
      });
      if (valueProps.found) {
        if (!isMap2 && !props.found && ctx.options.strict) {
          if (sep)
            for (const st of sep) {
              if (st === valueProps.found)
                break;
              if (st.type === "newline") {
                onError(st, "MULTILINE_IMPLICIT_KEY", "Implicit keys of flow sequence pairs need to be on a single line");
                break;
              }
            }
          if (props.start < valueProps.found.offset - 1024)
            onError(valueProps.found, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit flow sequence key");
        }
      } else if (value) {
        if ("source" in value && value.source && value.source[0] === ":")
          onError(value, "MISSING_CHAR", `Missing space after : in ${fcName}`);
        else
          onError(valueProps.start, "MISSING_CHAR", `Missing , or : between ${fcName} items`);
      }
      const valueNode = value ? composeNode2(ctx, value, valueProps, onError) : valueProps.found ? composeEmptyNode2(ctx, valueProps.end, sep, null, valueProps, onError) : null;
      if (valueNode) {
        if (isBlock(value))
          onError(valueNode.range, "BLOCK_IN_FLOW", blockMsg);
      } else if (valueProps.comment) {
        if (keyNode.comment)
          keyNode.comment += "\n" + valueProps.comment;
        else
          keyNode.comment = valueProps.comment;
      }
      const pair = new Pair(keyNode, valueNode);
      if (ctx.options.keepSourceTokens)
        pair.srcToken = collItem;
      if (isMap2) {
        const map2 = coll;
        if (mapIncludes(ctx, map2.items, keyNode))
          onError(keyStart, "DUPLICATE_KEY", "Map keys must be unique");
        map2.items.push(pair);
      } else {
        const map2 = new YAMLMap(ctx.schema);
        map2.flow = true;
        map2.items.push(pair);
        coll.items.push(map2);
      }
      offset = valueNode ? valueNode.range[2] : valueProps.end;
    }
  }
  const expectedEnd = isMap2 ? "}" : "]";
  const [ce, ...ee] = fc.end;
  let cePos = offset;
  if (ce && ce.source === expectedEnd)
    cePos = ce.offset + ce.source.length;
  else {
    const name = fcName[0].toUpperCase() + fcName.substring(1);
    const msg = atRoot ? `${name} must end with a ${expectedEnd}` : `${name} in block collection must be sufficiently indented and end with a ${expectedEnd}`;
    onError(offset, atRoot ? "MISSING_CHAR" : "BAD_INDENT", msg);
    if (ce && ce.source.length !== 1)
      ee.unshift(ce);
  }
  if (ee.length > 0) {
    const end = resolveEnd(ee, cePos, ctx.options.strict, onError);
    if (end.comment) {
      if (coll.comment)
        coll.comment += "\n" + end.comment;
      else
        coll.comment = end.comment;
    }
    coll.range = [fc.offset, cePos, end.offset];
  } else {
    coll.range = [fc.offset, cePos, cePos];
  }
  return coll;
}

// node_modules/yaml/browser/dist/compose/compose-collection.js
function composeCollection(CN2, ctx, token, tagToken, onError) {
  let coll;
  switch (token.type) {
    case "block-map": {
      coll = resolveBlockMap(CN2, ctx, token, onError);
      break;
    }
    case "block-seq": {
      coll = resolveBlockSeq(CN2, ctx, token, onError);
      break;
    }
    case "flow-collection": {
      coll = resolveFlowCollection(CN2, ctx, token, onError);
      break;
    }
  }
  if (!tagToken)
    return coll;
  const tagName = ctx.directives.tagName(tagToken.source, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg));
  if (!tagName)
    return coll;
  const Coll = coll.constructor;
  if (tagName === "!" || tagName === Coll.tagName) {
    coll.tag = Coll.tagName;
    return coll;
  }
  const expType = isMap(coll) ? "map" : "seq";
  let tag = ctx.schema.tags.find((t) => t.collection === expType && t.tag === tagName);
  if (!tag) {
    const kt = ctx.schema.knownTags[tagName];
    if (kt && kt.collection === expType) {
      ctx.schema.tags.push(Object.assign({}, kt, { default: false }));
      tag = kt;
    } else {
      onError(tagToken, "TAG_RESOLVE_FAILED", `Unresolved tag: ${tagName}`, true);
      coll.tag = tagName;
      return coll;
    }
  }
  const res = tag.resolve(coll, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg), ctx.options);
  const node = isNode(res) ? res : new Scalar(res);
  node.range = coll.range;
  node.tag = tagName;
  if (tag === null || tag === void 0 ? void 0 : tag.format)
    node.format = tag.format;
  return node;
}

// node_modules/yaml/browser/dist/compose/resolve-block-scalar.js
function resolveBlockScalar(scalar, strict, onError) {
  const start = scalar.offset;
  const header = parseBlockScalarHeader(scalar, strict, onError);
  if (!header)
    return { value: "", type: null, comment: "", range: [start, start, start] };
  const type = header.mode === ">" ? Scalar.BLOCK_FOLDED : Scalar.BLOCK_LITERAL;
  const lines = scalar.source ? splitLines(scalar.source) : [];
  let chompStart = lines.length;
  for (let i = lines.length - 1; i >= 0; --i) {
    const content = lines[i][1];
    if (content === "" || content === "\r")
      chompStart = i;
    else
      break;
  }
  if (!scalar.source || chompStart === 0) {
    const value2 = header.chomp === "+" ? "\n".repeat(Math.max(0, lines.length - 1)) : "";
    let end2 = start + header.length;
    if (scalar.source)
      end2 += scalar.source.length;
    return { value: value2, type, comment: header.comment, range: [start, end2, end2] };
  }
  let trimIndent = scalar.indent + header.indent;
  let offset = scalar.offset + header.length;
  let contentStart = 0;
  for (let i = 0; i < chompStart; ++i) {
    const [indent, content] = lines[i];
    if (content === "" || content === "\r") {
      if (header.indent === 0 && indent.length > trimIndent)
        trimIndent = indent.length;
    } else {
      if (indent.length < trimIndent) {
        const message = "Block scalars with more-indented leading empty lines must use an explicit indentation indicator";
        onError(offset + indent.length, "MISSING_CHAR", message);
      }
      if (header.indent === 0)
        trimIndent = indent.length;
      contentStart = i;
      break;
    }
    offset += indent.length + content.length + 1;
  }
  let value = "";
  let sep = "";
  let prevMoreIndented = false;
  for (let i = 0; i < contentStart; ++i)
    value += lines[i][0].slice(trimIndent) + "\n";
  for (let i = contentStart; i < chompStart; ++i) {
    let [indent, content] = lines[i];
    offset += indent.length + content.length + 1;
    const crlf = content[content.length - 1] === "\r";
    if (crlf)
      content = content.slice(0, -1);
    if (content && indent.length < trimIndent) {
      const src = header.indent ? "explicit indentation indicator" : "first line";
      const message = `Block scalar lines must not be less indented than their ${src}`;
      onError(offset - content.length - (crlf ? 2 : 1), "BAD_INDENT", message);
      indent = "";
    }
    if (type === Scalar.BLOCK_LITERAL) {
      value += sep + indent.slice(trimIndent) + content;
      sep = "\n";
    } else if (indent.length > trimIndent || content[0] === "	") {
      if (sep === " ")
        sep = "\n";
      else if (!prevMoreIndented && sep === "\n")
        sep = "\n\n";
      value += sep + indent.slice(trimIndent) + content;
      sep = "\n";
      prevMoreIndented = true;
    } else if (content === "") {
      if (sep === "\n")
        value += "\n";
      else
        sep = "\n";
    } else {
      value += sep + content;
      sep = " ";
      prevMoreIndented = false;
    }
  }
  switch (header.chomp) {
    case "-":
      break;
    case "+":
      for (let i = chompStart; i < lines.length; ++i)
        value += "\n" + lines[i][0].slice(trimIndent);
      if (value[value.length - 1] !== "\n")
        value += "\n";
      break;
    default:
      value += "\n";
  }
  const end = start + header.length + scalar.source.length;
  return { value, type, comment: header.comment, range: [start, end, end] };
}
function parseBlockScalarHeader({ offset, props }, strict, onError) {
  if (props[0].type !== "block-scalar-header") {
    onError(props[0], "IMPOSSIBLE", "Block scalar header not found");
    return null;
  }
  const { source } = props[0];
  const mode = source[0];
  let indent = 0;
  let chomp = "";
  let error = -1;
  for (let i = 1; i < source.length; ++i) {
    const ch = source[i];
    if (!chomp && (ch === "-" || ch === "+"))
      chomp = ch;
    else {
      const n = Number(ch);
      if (!indent && n)
        indent = n;
      else if (error === -1)
        error = offset + i;
    }
  }
  if (error !== -1)
    onError(error, "UNEXPECTED_TOKEN", `Block scalar header includes extra characters: ${source}`);
  let hasSpace = false;
  let comment = "";
  let length = source.length;
  for (let i = 1; i < props.length; ++i) {
    const token = props[i];
    switch (token.type) {
      case "space":
        hasSpace = true;
      case "newline":
        length += token.source.length;
        break;
      case "comment":
        if (strict && !hasSpace) {
          const message = "Comments must be separated from other tokens by white space characters";
          onError(token, "MISSING_CHAR", message);
        }
        length += token.source.length;
        comment = token.source.substring(1);
        break;
      case "error":
        onError(token, "UNEXPECTED_TOKEN", token.message);
        length += token.source.length;
        break;
      default: {
        const message = `Unexpected token in block scalar header: ${token.type}`;
        onError(token, "UNEXPECTED_TOKEN", message);
        const ts = token.source;
        if (ts && typeof ts === "string")
          length += ts.length;
      }
    }
  }
  return { mode, indent, chomp, comment, length };
}
function splitLines(source) {
  const split = source.split(/\n( *)/);
  const first = split[0];
  const m = first.match(/^( *)/);
  const line0 = m && m[1] ? [m[1], first.slice(m[1].length)] : ["", first];
  const lines = [line0];
  for (let i = 1; i < split.length; i += 2)
    lines.push([split[i], split[i + 1]]);
  return lines;
}

// node_modules/yaml/browser/dist/compose/resolve-flow-scalar.js
function resolveFlowScalar(scalar, strict, onError) {
  const { offset, type, source, end } = scalar;
  let _type;
  let value;
  const _onError = (rel, code, msg) => onError(offset + rel, code, msg);
  switch (type) {
    case "scalar":
      _type = Scalar.PLAIN;
      value = plainValue(source, _onError);
      break;
    case "single-quoted-scalar":
      _type = Scalar.QUOTE_SINGLE;
      value = singleQuotedValue(source, _onError);
      break;
    case "double-quoted-scalar":
      _type = Scalar.QUOTE_DOUBLE;
      value = doubleQuotedValue(source, _onError);
      break;
    default:
      onError(scalar, "UNEXPECTED_TOKEN", `Expected a flow scalar value, but found: ${type}`);
      return {
        value: "",
        type: null,
        comment: "",
        range: [offset, offset + source.length, offset + source.length]
      };
  }
  const valueEnd = offset + source.length;
  const re = resolveEnd(end, valueEnd, strict, onError);
  return {
    value,
    type: _type,
    comment: re.comment,
    range: [offset, valueEnd, re.offset]
  };
}
function plainValue(source, onError) {
  let badChar = "";
  switch (source[0]) {
    case "	":
      badChar = "a tab character";
      break;
    case ",":
      badChar = "flow indicator character ,";
      break;
    case "%":
      badChar = "directive indicator character %";
      break;
    case "|":
    case ">": {
      badChar = `block scalar indicator ${source[0]}`;
      break;
    }
    case "@":
    case "`": {
      badChar = `reserved character ${source[0]}`;
      break;
    }
  }
  if (badChar)
    onError(0, "BAD_SCALAR_START", `Plain value cannot start with ${badChar}`);
  return foldLines(source);
}
function singleQuotedValue(source, onError) {
  if (source[source.length - 1] !== "'" || source.length === 1)
    onError(source.length, "MISSING_CHAR", "Missing closing 'quote");
  return foldLines(source.slice(1, -1)).replace(/''/g, "'");
}
function foldLines(source) {
  let first, line;
  try {
    first = new RegExp("(.*?)(?<![ 	])[ 	]*\r?\n", "sy");
    line = new RegExp("[ 	]*(.*?)(?:(?<![ 	])[ 	]*)?\r?\n", "sy");
  } catch (_) {
    first = /(.*?)[ \t]*\r?\n/sy;
    line = /[ \t]*(.*?)[ \t]*\r?\n/sy;
  }
  let match = first.exec(source);
  if (!match)
    return source;
  let res = match[1];
  let sep = " ";
  let pos = first.lastIndex;
  line.lastIndex = pos;
  while (match = line.exec(source)) {
    if (match[1] === "") {
      if (sep === "\n")
        res += sep;
      else
        sep = "\n";
    } else {
      res += sep + match[1];
      sep = " ";
    }
    pos = line.lastIndex;
  }
  const last = /[ \t]*(.*)/sy;
  last.lastIndex = pos;
  match = last.exec(source);
  return res + sep + (match && match[1] || "");
}
function doubleQuotedValue(source, onError) {
  let res = "";
  for (let i = 1; i < source.length - 1; ++i) {
    const ch = source[i];
    if (ch === "\r" && source[i + 1] === "\n")
      continue;
    if (ch === "\n") {
      const { fold, offset } = foldNewline(source, i);
      res += fold;
      i = offset;
    } else if (ch === "\\") {
      let next = source[++i];
      const cc = escapeCodes[next];
      if (cc)
        res += cc;
      else if (next === "\n") {
        next = source[i + 1];
        while (next === " " || next === "	")
          next = source[++i + 1];
      } else if (next === "\r" && source[i + 1] === "\n") {
        next = source[++i + 1];
        while (next === " " || next === "	")
          next = source[++i + 1];
      } else if (next === "x" || next === "u" || next === "U") {
        const length = { x: 2, u: 4, U: 8 }[next];
        res += parseCharCode(source, i + 1, length, onError);
        i += length;
      } else {
        const raw = source.substr(i - 1, 2);
        onError(i - 1, "BAD_DQ_ESCAPE", `Invalid escape sequence ${raw}`);
        res += raw;
      }
    } else if (ch === " " || ch === "	") {
      const wsStart = i;
      let next = source[i + 1];
      while (next === " " || next === "	")
        next = source[++i + 1];
      if (next !== "\n" && !(next === "\r" && source[i + 2] === "\n"))
        res += i > wsStart ? source.slice(wsStart, i + 1) : ch;
    } else {
      res += ch;
    }
  }
  if (source[source.length - 1] !== '"' || source.length === 1)
    onError(source.length, "MISSING_CHAR", 'Missing closing "quote');
  return res;
}
function foldNewline(source, offset) {
  let fold = "";
  let ch = source[offset + 1];
  while (ch === " " || ch === "	" || ch === "\n" || ch === "\r") {
    if (ch === "\r" && source[offset + 2] !== "\n")
      break;
    if (ch === "\n")
      fold += "\n";
    offset += 1;
    ch = source[offset + 1];
  }
  if (!fold)
    fold = " ";
  return { fold, offset };
}
var escapeCodes = {
  "0": "\0",
  a: "\x07",
  b: "\b",
  e: "\x1B",
  f: "\f",
  n: "\n",
  r: "\r",
  t: "	",
  v: "\v",
  N: "\x85",
  _: "\xA0",
  L: "\u2028",
  P: "\u2029",
  " ": " ",
  '"': '"',
  "/": "/",
  "\\": "\\",
  "	": "	"
};
function parseCharCode(source, offset, length, onError) {
  const cc = source.substr(offset, length);
  const ok = cc.length === length && /^[0-9a-fA-F]+$/.test(cc);
  const code = ok ? parseInt(cc, 16) : NaN;
  if (isNaN(code)) {
    const raw = source.substr(offset - 2, length + 2);
    onError(offset - 2, "BAD_DQ_ESCAPE", `Invalid escape sequence ${raw}`);
    return raw;
  }
  return String.fromCodePoint(code);
}

// node_modules/yaml/browser/dist/compose/compose-scalar.js
function composeScalar(ctx, token, tagToken, onError) {
  const { value, type, comment, range } = token.type === "block-scalar" ? resolveBlockScalar(token, ctx.options.strict, onError) : resolveFlowScalar(token, ctx.options.strict, onError);
  const tagName = tagToken ? ctx.directives.tagName(tagToken.source, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg)) : null;
  const tag = tagToken && tagName ? findScalarTagByName(ctx.schema, value, tagName, tagToken, onError) : token.type === "scalar" ? findScalarTagByTest(ctx, value, token, onError) : ctx.schema[SCALAR];
  let scalar;
  try {
    const res = tag.resolve(value, (msg) => onError(tagToken || token, "TAG_RESOLVE_FAILED", msg), ctx.options);
    scalar = isScalar(res) ? res : new Scalar(res);
  } catch (error) {
    const msg = error instanceof Error ? error.message : String(error);
    onError(tagToken || token, "TAG_RESOLVE_FAILED", msg);
    scalar = new Scalar(value);
  }
  scalar.range = range;
  scalar.source = value;
  if (type)
    scalar.type = type;
  if (tagName)
    scalar.tag = tagName;
  if (tag.format)
    scalar.format = tag.format;
  if (comment)
    scalar.comment = comment;
  return scalar;
}
function findScalarTagByName(schema4, value, tagName, tagToken, onError) {
  var _a;
  if (tagName === "!")
    return schema4[SCALAR];
  const matchWithTest = [];
  for (const tag of schema4.tags) {
    if (!tag.collection && tag.tag === tagName) {
      if (tag.default && tag.test)
        matchWithTest.push(tag);
      else
        return tag;
    }
  }
  for (const tag of matchWithTest)
    if ((_a = tag.test) === null || _a === void 0 ? void 0 : _a.test(value))
      return tag;
  const kt = schema4.knownTags[tagName];
  if (kt && !kt.collection) {
    schema4.tags.push(Object.assign({}, kt, { default: false, test: void 0 }));
    return kt;
  }
  onError(tagToken, "TAG_RESOLVE_FAILED", `Unresolved tag: ${tagName}`, tagName !== "tag:yaml.org,2002:str");
  return schema4[SCALAR];
}
function findScalarTagByTest({ directives, schema: schema4 }, value, token, onError) {
  const tag = schema4.tags.find((tag2) => {
    var _a;
    return tag2.default && ((_a = tag2.test) === null || _a === void 0 ? void 0 : _a.test(value));
  }) || schema4[SCALAR];
  if (schema4.compat) {
    const compat = schema4.compat.find((tag2) => {
      var _a;
      return tag2.default && ((_a = tag2.test) === null || _a === void 0 ? void 0 : _a.test(value));
    }) || schema4[SCALAR];
    if (tag.tag !== compat.tag) {
      const ts = directives.tagString(tag.tag);
      const cs = directives.tagString(compat.tag);
      const msg = `Value may be parsed as either ${ts} or ${cs}`;
      onError(token, "TAG_RESOLVE_FAILED", msg, true);
    }
  }
  return tag;
}

// node_modules/yaml/browser/dist/compose/util-empty-scalar-position.js
function emptyScalarPosition(offset, before, pos) {
  if (before) {
    if (pos === null)
      pos = before.length;
    for (let i = pos - 1; i >= 0; --i) {
      let st = before[i];
      switch (st.type) {
        case "space":
        case "comment":
        case "newline":
          offset -= st.source.length;
          continue;
      }
      st = before[++i];
      while ((st === null || st === void 0 ? void 0 : st.type) === "space") {
        offset += st.source.length;
        st = before[++i];
      }
      break;
    }
  }
  return offset;
}

// node_modules/yaml/browser/dist/compose/compose-node.js
var CN = { composeNode, composeEmptyNode };
function composeNode(ctx, token, props, onError) {
  const { spaceBefore, comment, anchor, tag } = props;
  let node;
  switch (token.type) {
    case "alias":
      node = composeAlias(ctx, token, onError);
      if (anchor || tag)
        onError(token, "ALIAS_PROPS", "An alias node must not specify any properties");
      break;
    case "scalar":
    case "single-quoted-scalar":
    case "double-quoted-scalar":
    case "block-scalar":
      node = composeScalar(ctx, token, tag, onError);
      if (anchor)
        node.anchor = anchor.source.substring(1);
      break;
    case "block-map":
    case "block-seq":
    case "flow-collection":
      node = composeCollection(CN, ctx, token, tag, onError);
      if (anchor)
        node.anchor = anchor.source.substring(1);
      break;
    default:
      console.log(token);
      throw new Error(`Unsupporten token type: ${token.type}`);
  }
  if (anchor && node.anchor === "")
    onError(anchor, "BAD_ALIAS", "Anchor cannot be an empty string");
  if (spaceBefore)
    node.spaceBefore = true;
  if (comment) {
    if (token.type === "scalar" && token.source === "")
      node.comment = comment;
    else
      node.commentBefore = comment;
  }
  if (ctx.options.keepSourceTokens)
    node.srcToken = token;
  return node;
}
function composeEmptyNode(ctx, offset, before, pos, { spaceBefore, comment, anchor, tag }, onError) {
  const token = {
    type: "scalar",
    offset: emptyScalarPosition(offset, before, pos),
    indent: -1,
    source: ""
  };
  const node = composeScalar(ctx, token, tag, onError);
  if (anchor) {
    node.anchor = anchor.source.substring(1);
    if (node.anchor === "")
      onError(anchor, "BAD_ALIAS", "Anchor cannot be an empty string");
  }
  if (spaceBefore)
    node.spaceBefore = true;
  if (comment)
    node.comment = comment;
  return node;
}
function composeAlias({ options }, { offset, source, end }, onError) {
  const alias = new Alias(source.substring(1));
  if (alias.source === "")
    onError(offset, "BAD_ALIAS", "Alias cannot be an empty string");
  const valueEnd = offset + source.length;
  const re = resolveEnd(end, valueEnd, options.strict, onError);
  alias.range = [offset, valueEnd, re.offset];
  if (re.comment)
    alias.comment = re.comment;
  return alias;
}

// node_modules/yaml/browser/dist/compose/compose-doc.js
function composeDoc(options, directives, { offset, start, value, end }, onError) {
  const opts = Object.assign({ directives }, options);
  const doc = new Document(void 0, opts);
  const ctx = {
    atRoot: true,
    directives: doc.directives,
    options: doc.options,
    schema: doc.schema
  };
  const props = resolveProps(start, {
    indicator: "doc-start",
    next: value || (end === null || end === void 0 ? void 0 : end[0]),
    offset,
    onError,
    startOnNewline: true
  });
  if (props.found) {
    doc.directives.marker = true;
    if (value && (value.type === "block-map" || value.type === "block-seq") && !props.hasNewline)
      onError(props.end, "MISSING_CHAR", "Block collection cannot start on same line with directives-end marker");
  }
  doc.contents = value ? composeNode(ctx, value, props, onError) : composeEmptyNode(ctx, props.end, start, null, props, onError);
  const contentEnd = doc.contents.range[2];
  const re = resolveEnd(end, contentEnd, false, onError);
  if (re.comment)
    doc.comment = re.comment;
  doc.range = [offset, contentEnd, re.offset];
  return doc;
}

// node_modules/yaml/browser/dist/compose/composer.js
function getErrorPos(src) {
  if (typeof src === "number")
    return [src, src + 1];
  if (Array.isArray(src))
    return src.length === 2 ? src : [src[0], src[1]];
  const { offset, source } = src;
  return [offset, offset + (typeof source === "string" ? source.length : 1)];
}
function parsePrelude(prelude) {
  var _a;
  let comment = "";
  let atComment = false;
  let afterEmptyLine = false;
  for (let i = 0; i < prelude.length; ++i) {
    const source = prelude[i];
    switch (source[0]) {
      case "#":
        comment += (comment === "" ? "" : afterEmptyLine ? "\n\n" : "\n") + (source.substring(1) || " ");
        atComment = true;
        afterEmptyLine = false;
        break;
      case "%":
        if (((_a = prelude[i + 1]) === null || _a === void 0 ? void 0 : _a[0]) !== "#")
          i += 1;
        atComment = false;
        break;
      default:
        if (!atComment)
          afterEmptyLine = true;
        atComment = false;
    }
  }
  return { comment, afterEmptyLine };
}
var Composer = class {
  constructor(options = {}) {
    this.doc = null;
    this.atDirectives = false;
    this.prelude = [];
    this.errors = [];
    this.warnings = [];
    this.onError = (source, code, message, warning) => {
      const pos = getErrorPos(source);
      if (warning)
        this.warnings.push(new YAMLWarning(pos, code, message));
      else
        this.errors.push(new YAMLParseError(pos, code, message));
    };
    this.directives = new Directives({
      version: options.version || defaultOptions.version
    });
    this.options = options;
  }
  decorate(doc, afterDoc) {
    const { comment, afterEmptyLine } = parsePrelude(this.prelude);
    if (comment) {
      const dc = doc.contents;
      if (afterDoc) {
        doc.comment = doc.comment ? `${doc.comment}
${comment}` : comment;
      } else if (afterEmptyLine || doc.directives.marker || !dc) {
        doc.commentBefore = comment;
      } else if (isCollection(dc) && !dc.flow && dc.items.length > 0) {
        let it = dc.items[0];
        if (isPair(it))
          it = it.key;
        const cb = it.commentBefore;
        it.commentBefore = cb ? `${comment}
${cb}` : comment;
      } else {
        const cb = dc.commentBefore;
        dc.commentBefore = cb ? `${comment}
${cb}` : comment;
      }
    }
    if (afterDoc) {
      Array.prototype.push.apply(doc.errors, this.errors);
      Array.prototype.push.apply(doc.warnings, this.warnings);
    } else {
      doc.errors = this.errors;
      doc.warnings = this.warnings;
    }
    this.prelude = [];
    this.errors = [];
    this.warnings = [];
  }
  /**
   * Current stream status information.
   *
   * Mostly useful at the end of input for an empty stream.
   */
  streamInfo() {
    return {
      comment: parsePrelude(this.prelude).comment,
      directives: this.directives,
      errors: this.errors,
      warnings: this.warnings
    };
  }
  /**
   * Compose tokens into documents.
   *
   * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
   * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
   */
  *compose(tokens, forceDoc = false, endOffset = -1) {
    for (const token of tokens)
      yield* this.next(token);
    yield* this.end(forceDoc, endOffset);
  }
  /** Advance the composer by one CST token. */
  *next(token) {
    switch (token.type) {
      case "directive":
        this.directives.add(token.source, (offset, message, warning) => {
          const pos = getErrorPos(token);
          pos[0] += offset;
          this.onError(pos, "BAD_DIRECTIVE", message, warning);
        });
        this.prelude.push(token.source);
        this.atDirectives = true;
        break;
      case "document": {
        const doc = composeDoc(this.options, this.directives, token, this.onError);
        if (this.atDirectives && !doc.directives.marker)
          this.onError(token, "MISSING_CHAR", "Missing directives-end indicator line");
        this.decorate(doc, false);
        if (this.doc)
          yield this.doc;
        this.doc = doc;
        this.atDirectives = false;
        break;
      }
      case "byte-order-mark":
      case "space":
        break;
      case "comment":
      case "newline":
        this.prelude.push(token.source);
        break;
      case "error": {
        const msg = token.source ? `${token.message}: ${JSON.stringify(token.source)}` : token.message;
        const error = new YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", msg);
        if (this.atDirectives || !this.doc)
          this.errors.push(error);
        else
          this.doc.errors.push(error);
        break;
      }
      case "doc-end": {
        if (!this.doc) {
          const msg = "Unexpected doc-end without preceding document";
          this.errors.push(new YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", msg));
          break;
        }
        const end = resolveEnd(token.end, token.offset + token.source.length, this.doc.options.strict, this.onError);
        this.decorate(this.doc, true);
        if (end.comment) {
          const dc = this.doc.comment;
          this.doc.comment = dc ? `${dc}
${end.comment}` : end.comment;
        }
        this.doc.range[2] = end.offset;
        break;
      }
      default:
        this.errors.push(new YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", `Unsupported token ${token.type}`));
    }
  }
  /**
   * Call at end of input to yield any remaining document.
   *
   * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
   * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
   */
  *end(forceDoc = false, endOffset = -1) {
    if (this.doc) {
      this.decorate(this.doc, true);
      yield this.doc;
      this.doc = null;
    } else if (forceDoc) {
      const opts = Object.assign({ directives: this.directives }, this.options);
      const doc = new Document(void 0, opts);
      if (this.atDirectives)
        this.onError(endOffset, "MISSING_CHAR", "Missing directives-end indicator line");
      doc.range = [0, endOffset, endOffset];
      this.decorate(doc, false);
      yield doc;
    }
  }
};

// node_modules/yaml/browser/dist/parse/cst.js
var cst_exports = {};
__export(cst_exports, {
  BOM: () => BOM,
  DOCUMENT: () => DOCUMENT,
  FLOW_END: () => FLOW_END,
  SCALAR: () => SCALAR2,
  createScalarToken: () => createScalarToken,
  isCollection: () => isCollection2,
  isScalar: () => isScalar2,
  prettyToken: () => prettyToken,
  resolveAsScalar: () => resolveAsScalar,
  setScalarValue: () => setScalarValue,
  stringify: () => stringify2,
  tokenType: () => tokenType,
  visit: () => visit2
});

// node_modules/yaml/browser/dist/parse/cst-scalar.js
function resolveAsScalar(token, strict = true, onError) {
  if (token) {
    const _onError = (pos, code, message) => {
      const offset = typeof pos === "number" ? pos : Array.isArray(pos) ? pos[0] : pos.offset;
      if (onError)
        onError(offset, code, message);
      else
        throw new YAMLParseError([offset, offset + 1], code, message);
    };
    switch (token.type) {
      case "scalar":
      case "single-quoted-scalar":
      case "double-quoted-scalar":
        return resolveFlowScalar(token, strict, _onError);
      case "block-scalar":
        return resolveBlockScalar(token, strict, _onError);
    }
  }
  return null;
}
function createScalarToken(value, context) {
  var _a;
  const { implicitKey = false, indent, inFlow = false, offset = -1, type = "PLAIN" } = context;
  const source = stringifyString({ type, value }, {
    implicitKey,
    indent: indent > 0 ? " ".repeat(indent) : "",
    inFlow,
    options: { blockQuote: true, lineWidth: -1 }
  });
  const end = (_a = context.end) !== null && _a !== void 0 ? _a : [
    { type: "newline", offset: -1, indent, source: "\n" }
  ];
  switch (source[0]) {
    case "|":
    case ">": {
      const he = source.indexOf("\n");
      const head = source.substring(0, he);
      const body = source.substring(he + 1) + "\n";
      const props = [
        { type: "block-scalar-header", offset, indent, source: head }
      ];
      if (!addEndtoBlockProps(props, end))
        props.push({ type: "newline", offset: -1, indent, source: "\n" });
      return { type: "block-scalar", offset, indent, props, source: body };
    }
    case '"':
      return { type: "double-quoted-scalar", offset, indent, source, end };
    case "'":
      return { type: "single-quoted-scalar", offset, indent, source, end };
    default:
      return { type: "scalar", offset, indent, source, end };
  }
}
function setScalarValue(token, value, context = {}) {
  let { afterKey = false, implicitKey = false, inFlow = false, type } = context;
  let indent = "indent" in token ? token.indent : null;
  if (afterKey && typeof indent === "number")
    indent += 2;
  if (!type)
    switch (token.type) {
      case "single-quoted-scalar":
        type = "QUOTE_SINGLE";
        break;
      case "double-quoted-scalar":
        type = "QUOTE_DOUBLE";
        break;
      case "block-scalar": {
        const header = token.props[0];
        if (header.type !== "block-scalar-header")
          throw new Error("Invalid block scalar header");
        type = header.source[0] === ">" ? "BLOCK_FOLDED" : "BLOCK_LITERAL";
        break;
      }
      default:
        type = "PLAIN";
    }
  const source = stringifyString({ type, value }, {
    implicitKey: implicitKey || indent === null,
    indent: indent !== null && indent > 0 ? " ".repeat(indent) : "",
    inFlow,
    options: { blockQuote: true, lineWidth: -1 }
  });
  switch (source[0]) {
    case "|":
    case ">":
      setBlockScalarValue(token, source);
      break;
    case '"':
      setFlowScalarValue(token, source, "double-quoted-scalar");
      break;
    case "'":
      setFlowScalarValue(token, source, "single-quoted-scalar");
      break;
    default:
      setFlowScalarValue(token, source, "scalar");
  }
}
function setBlockScalarValue(token, source) {
  const he = source.indexOf("\n");
  const head = source.substring(0, he);
  const body = source.substring(he + 1) + "\n";
  if (token.type === "block-scalar") {
    const header = token.props[0];
    if (header.type !== "block-scalar-header")
      throw new Error("Invalid block scalar header");
    header.source = head;
    token.source = body;
  } else {
    const { offset } = token;
    const indent = "indent" in token ? token.indent : -1;
    const props = [
      { type: "block-scalar-header", offset, indent, source: head }
    ];
    if (!addEndtoBlockProps(props, "end" in token ? token.end : void 0))
      props.push({ type: "newline", offset: -1, indent, source: "\n" });
    for (const key of Object.keys(token))
      if (key !== "type" && key !== "offset")
        delete token[key];
    Object.assign(token, { type: "block-scalar", indent, props, source: body });
  }
}
function addEndtoBlockProps(props, end) {
  if (end)
    for (const st of end)
      switch (st.type) {
        case "space":
        case "comment":
          props.push(st);
          break;
        case "newline":
          props.push(st);
          return true;
      }
  return false;
}
function setFlowScalarValue(token, source, type) {
  switch (token.type) {
    case "scalar":
    case "double-quoted-scalar":
    case "single-quoted-scalar":
      token.type = type;
      token.source = source;
      break;
    case "block-scalar": {
      const end = token.props.slice(1);
      let oa = source.length;
      if (token.props[0].type === "block-scalar-header")
        oa -= token.props[0].source.length;
      for (const tok of end)
        tok.offset += oa;
      delete token.props;
      Object.assign(token, { type, source, end });
      break;
    }
    case "block-map":
    case "block-seq": {
      const offset = token.offset + source.length;
      const nl = { type: "newline", offset, indent: token.indent, source: "\n" };
      delete token.items;
      Object.assign(token, { type, source, end: [nl] });
      break;
    }
    default: {
      const indent = "indent" in token ? token.indent : -1;
      const end = "end" in token && Array.isArray(token.end) ? token.end.filter((st) => st.type === "space" || st.type === "comment" || st.type === "newline") : [];
      for (const key of Object.keys(token))
        if (key !== "type" && key !== "offset")
          delete token[key];
      Object.assign(token, { type, indent, source, end });
    }
  }
}

// node_modules/yaml/browser/dist/parse/cst-stringify.js
var stringify2 = (cst) => "type" in cst ? stringifyToken(cst) : stringifyItem(cst);
function stringifyToken(token) {
  switch (token.type) {
    case "block-scalar": {
      let res = "";
      for (const tok of token.props)
        res += stringifyToken(tok);
      return res + token.source;
    }
    case "block-map":
    case "block-seq": {
      let res = "";
      for (const item of token.items)
        res += stringifyItem(item);
      return res;
    }
    case "flow-collection": {
      let res = token.start.source;
      for (const item of token.items)
        res += stringifyItem(item);
      for (const st of token.end)
        res += st.source;
      return res;
    }
    case "document": {
      let res = stringifyItem(token);
      if (token.end)
        for (const st of token.end)
          res += st.source;
      return res;
    }
    default: {
      let res = token.source;
      if ("end" in token && token.end)
        for (const st of token.end)
          res += st.source;
      return res;
    }
  }
}
function stringifyItem({ start, key, sep, value }) {
  let res = "";
  for (const st of start)
    res += st.source;
  if (key)
    res += stringifyToken(key);
  if (sep)
    for (const st of sep)
      res += st.source;
  if (value)
    res += stringifyToken(value);
  return res;
}

// node_modules/yaml/browser/dist/parse/cst-visit.js
var BREAK2 = Symbol("break visit");
var SKIP2 = Symbol("skip children");
var REMOVE2 = Symbol("remove item");
function visit2(cst, visitor) {
  if ("type" in cst && cst.type === "document")
    cst = { start: cst.start, value: cst.value };
  _visit2(Object.freeze([]), cst, visitor);
}
visit2.BREAK = BREAK2;
visit2.SKIP = SKIP2;
visit2.REMOVE = REMOVE2;
visit2.itemAtPath = (cst, path) => {
  let item = cst;
  for (const [field, index] of path) {
    const tok = item && item[field];
    if (tok && "items" in tok) {
      item = tok.items[index];
    } else
      return void 0;
  }
  return item;
};
visit2.parentCollection = (cst, path) => {
  const parent = visit2.itemAtPath(cst, path.slice(0, -1));
  const field = path[path.length - 1][0];
  const coll = parent && parent[field];
  if (coll && "items" in coll)
    return coll;
  throw new Error("Parent collection not found");
};
function _visit2(path, item, visitor) {
  let ctrl = visitor(item, path);
  if (typeof ctrl === "symbol")
    return ctrl;
  for (const field of ["key", "value"]) {
    const token = item[field];
    if (token && "items" in token) {
      for (let i = 0; i < token.items.length; ++i) {
        const ci = _visit2(Object.freeze(path.concat([[field, i]])), token.items[i], visitor);
        if (typeof ci === "number")
          i = ci - 1;
        else if (ci === BREAK2)
          return BREAK2;
        else if (ci === REMOVE2) {
          token.items.splice(i, 1);
          i -= 1;
        }
      }
      if (typeof ctrl === "function" && field === "key")
        ctrl = ctrl(item, path);
    }
  }
  return typeof ctrl === "function" ? ctrl(item, path) : ctrl;
}

// node_modules/yaml/browser/dist/parse/cst.js
var BOM = "\uFEFF";
var DOCUMENT = "";
var FLOW_END = "";
var SCALAR2 = "";
var isCollection2 = (token) => !!token && "items" in token;
var isScalar2 = (token) => !!token && (token.type === "scalar" || token.type === "single-quoted-scalar" || token.type === "double-quoted-scalar" || token.type === "block-scalar");
function prettyToken(token) {
  switch (token) {
    case BOM:
      return "<BOM>";
    case DOCUMENT:
      return "<DOC>";
    case FLOW_END:
      return "<FLOW_END>";
    case SCALAR2:
      return "<SCALAR>";
    default:
      return JSON.stringify(token);
  }
}
function tokenType(source) {
  switch (source) {
    case BOM:
      return "byte-order-mark";
    case DOCUMENT:
      return "doc-mode";
    case FLOW_END:
      return "flow-error-end";
    case SCALAR2:
      return "scalar";
    case "---":
      return "doc-start";
    case "...":
      return "doc-end";
    case "":
    case "\n":
    case "\r\n":
      return "newline";
    case "-":
      return "seq-item-ind";
    case "?":
      return "explicit-key-ind";
    case ":":
      return "map-value-ind";
    case "{":
      return "flow-map-start";
    case "}":
      return "flow-map-end";
    case "[":
      return "flow-seq-start";
    case "]":
      return "flow-seq-end";
    case ",":
      return "comma";
  }
  switch (source[0]) {
    case " ":
    case "	":
      return "space";
    case "#":
      return "comment";
    case "%":
      return "directive-line";
    case "*":
      return "alias";
    case "&":
      return "anchor";
    case "!":
      return "tag";
    case "'":
      return "single-quoted-scalar";
    case '"':
      return "double-quoted-scalar";
    case "|":
    case ">":
      return "block-scalar-header";
  }
  return null;
}

// node_modules/yaml/browser/dist/parse/lexer.js
function isEmpty(ch) {
  switch (ch) {
    case void 0:
    case " ":
    case "\n":
    case "\r":
    case "	":
      return true;
    default:
      return false;
  }
}
var hexDigits = "0123456789ABCDEFabcdef".split("");
var tagChars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-#;/?:@&=+$_.!~*'()".split("");
var invalidFlowScalarChars = ",[]{}".split("");
var invalidAnchorChars = " ,[]{}\n\r	".split("");
var isNotAnchorChar = (ch) => !ch || invalidAnchorChars.includes(ch);
var Lexer = class {
  constructor() {
    this.atEnd = false;
    this.blockScalarIndent = -1;
    this.blockScalarKeep = false;
    this.buffer = "";
    this.flowKey = false;
    this.flowLevel = 0;
    this.indentNext = 0;
    this.indentValue = 0;
    this.lineEndPos = null;
    this.next = null;
    this.pos = 0;
  }
  /**
   * Generate YAML tokens from the `source` string. If `incomplete`,
   * a part of the last line may be left as a buffer for the next call.
   *
   * @returns A generator of lexical tokens
   */
  *lex(source, incomplete = false) {
    if (source) {
      this.buffer = this.buffer ? this.buffer + source : source;
      this.lineEndPos = null;
    }
    this.atEnd = !incomplete;
    let next = this.next || "stream";
    while (next && (incomplete || this.hasChars(1)))
      next = yield* this.parseNext(next);
  }
  atLineEnd() {
    let i = this.pos;
    let ch = this.buffer[i];
    while (ch === " " || ch === "	")
      ch = this.buffer[++i];
    if (!ch || ch === "#" || ch === "\n")
      return true;
    if (ch === "\r")
      return this.buffer[i + 1] === "\n";
    return false;
  }
  charAt(n) {
    return this.buffer[this.pos + n];
  }
  continueScalar(offset) {
    let ch = this.buffer[offset];
    if (this.indentNext > 0) {
      let indent = 0;
      while (ch === " ")
        ch = this.buffer[++indent + offset];
      if (ch === "\r") {
        const next = this.buffer[indent + offset + 1];
        if (next === "\n" || !next && !this.atEnd)
          return offset + indent + 1;
      }
      return ch === "\n" || indent >= this.indentNext || !ch && !this.atEnd ? offset + indent : -1;
    }
    if (ch === "-" || ch === ".") {
      const dt = this.buffer.substr(offset, 3);
      if ((dt === "---" || dt === "...") && isEmpty(this.buffer[offset + 3]))
        return -1;
    }
    return offset;
  }
  getLine() {
    let end = this.lineEndPos;
    if (typeof end !== "number" || end !== -1 && end < this.pos) {
      end = this.buffer.indexOf("\n", this.pos);
      this.lineEndPos = end;
    }
    if (end === -1)
      return this.atEnd ? this.buffer.substring(this.pos) : null;
    if (this.buffer[end - 1] === "\r")
      end -= 1;
    return this.buffer.substring(this.pos, end);
  }
  hasChars(n) {
    return this.pos + n <= this.buffer.length;
  }
  setNext(state) {
    this.buffer = this.buffer.substring(this.pos);
    this.pos = 0;
    this.lineEndPos = null;
    this.next = state;
    return null;
  }
  peek(n) {
    return this.buffer.substr(this.pos, n);
  }
  *parseNext(next) {
    switch (next) {
      case "stream":
        return yield* this.parseStream();
      case "line-start":
        return yield* this.parseLineStart();
      case "block-start":
        return yield* this.parseBlockStart();
      case "doc":
        return yield* this.parseDocument();
      case "flow":
        return yield* this.parseFlowCollection();
      case "quoted-scalar":
        return yield* this.parseQuotedScalar();
      case "block-scalar":
        return yield* this.parseBlockScalar();
      case "plain-scalar":
        return yield* this.parsePlainScalar();
    }
  }
  *parseStream() {
    let line = this.getLine();
    if (line === null)
      return this.setNext("stream");
    if (line[0] === BOM) {
      yield* this.pushCount(1);
      line = line.substring(1);
    }
    if (line[0] === "%") {
      let dirEnd = line.length;
      const cs = line.indexOf("#");
      if (cs !== -1) {
        const ch = line[cs - 1];
        if (ch === " " || ch === "	")
          dirEnd = cs - 1;
      }
      while (true) {
        const ch = line[dirEnd - 1];
        if (ch === " " || ch === "	")
          dirEnd -= 1;
        else
          break;
      }
      const n = (yield* this.pushCount(dirEnd)) + (yield* this.pushSpaces(true));
      yield* this.pushCount(line.length - n);
      this.pushNewline();
      return "stream";
    }
    if (this.atLineEnd()) {
      const sp = yield* this.pushSpaces(true);
      yield* this.pushCount(line.length - sp);
      yield* this.pushNewline();
      return "stream";
    }
    yield DOCUMENT;
    return yield* this.parseLineStart();
  }
  *parseLineStart() {
    const ch = this.charAt(0);
    if (!ch && !this.atEnd)
      return this.setNext("line-start");
    if (ch === "-" || ch === ".") {
      if (!this.atEnd && !this.hasChars(4))
        return this.setNext("line-start");
      const s = this.peek(3);
      if (s === "---" && isEmpty(this.charAt(3))) {
        yield* this.pushCount(3);
        this.indentValue = 0;
        this.indentNext = 0;
        return "doc";
      } else if (s === "..." && isEmpty(this.charAt(3))) {
        yield* this.pushCount(3);
        return "stream";
      }
    }
    this.indentValue = yield* this.pushSpaces(false);
    if (this.indentNext > this.indentValue && !isEmpty(this.charAt(1)))
      this.indentNext = this.indentValue;
    return yield* this.parseBlockStart();
  }
  *parseBlockStart() {
    const [ch0, ch1] = this.peek(2);
    if (!ch1 && !this.atEnd)
      return this.setNext("block-start");
    if ((ch0 === "-" || ch0 === "?" || ch0 === ":") && isEmpty(ch1)) {
      const n = (yield* this.pushCount(1)) + (yield* this.pushSpaces(true));
      this.indentNext = this.indentValue + 1;
      this.indentValue += n;
      return yield* this.parseBlockStart();
    }
    return "doc";
  }
  *parseDocument() {
    yield* this.pushSpaces(true);
    const line = this.getLine();
    if (line === null)
      return this.setNext("doc");
    let n = yield* this.pushIndicators();
    switch (line[n]) {
      case "#":
        yield* this.pushCount(line.length - n);
      case void 0:
        yield* this.pushNewline();
        return yield* this.parseLineStart();
      case "{":
      case "[":
        yield* this.pushCount(1);
        this.flowKey = false;
        this.flowLevel = 1;
        return "flow";
      case "}":
      case "]":
        yield* this.pushCount(1);
        return "doc";
      case "*":
        yield* this.pushUntil(isNotAnchorChar);
        return "doc";
      case '"':
      case "'":
        return yield* this.parseQuotedScalar();
      case "|":
      case ">":
        n += yield* this.parseBlockScalarHeader();
        n += yield* this.pushSpaces(true);
        yield* this.pushCount(line.length - n);
        yield* this.pushNewline();
        return yield* this.parseBlockScalar();
      default:
        return yield* this.parsePlainScalar();
    }
  }
  *parseFlowCollection() {
    let nl, sp;
    let indent = -1;
    do {
      nl = yield* this.pushNewline();
      sp = yield* this.pushSpaces(true);
      if (nl > 0)
        this.indentValue = indent = sp;
    } while (nl + sp > 0);
    const line = this.getLine();
    if (line === null)
      return this.setNext("flow");
    if (indent !== -1 && indent < this.indentNext && line[0] !== "#" || indent === 0 && (line.startsWith("---") || line.startsWith("...")) && isEmpty(line[3])) {
      const atFlowEndMarker = indent === this.indentNext - 1 && this.flowLevel === 1 && (line[0] === "]" || line[0] === "}");
      if (!atFlowEndMarker) {
        this.flowLevel = 0;
        yield FLOW_END;
        return yield* this.parseLineStart();
      }
    }
    let n = 0;
    while (line[n] === ",") {
      n += yield* this.pushCount(1);
      n += yield* this.pushSpaces(true);
      this.flowKey = false;
    }
    n += yield* this.pushIndicators();
    switch (line[n]) {
      case void 0:
        return "flow";
      case "#":
        yield* this.pushCount(line.length - n);
        return "flow";
      case "{":
      case "[":
        yield* this.pushCount(1);
        this.flowKey = false;
        this.flowLevel += 1;
        return "flow";
      case "}":
      case "]":
        yield* this.pushCount(1);
        this.flowKey = true;
        this.flowLevel -= 1;
        return this.flowLevel ? "flow" : "doc";
      case "*":
        yield* this.pushUntil(isNotAnchorChar);
        return "flow";
      case '"':
      case "'":
        this.flowKey = true;
        return yield* this.parseQuotedScalar();
      case ":": {
        const next = this.charAt(1);
        if (this.flowKey || isEmpty(next) || next === ",") {
          this.flowKey = false;
          yield* this.pushCount(1);
          yield* this.pushSpaces(true);
          return "flow";
        }
      }
      default:
        this.flowKey = false;
        return yield* this.parsePlainScalar();
    }
  }
  *parseQuotedScalar() {
    const quote = this.charAt(0);
    let end = this.buffer.indexOf(quote, this.pos + 1);
    if (quote === "'") {
      while (end !== -1 && this.buffer[end + 1] === "'")
        end = this.buffer.indexOf("'", end + 2);
    } else {
      while (end !== -1) {
        let n = 0;
        while (this.buffer[end - 1 - n] === "\\")
          n += 1;
        if (n % 2 === 0)
          break;
        end = this.buffer.indexOf('"', end + 1);
      }
    }
    const qb = this.buffer.substring(0, end);
    let nl = qb.indexOf("\n", this.pos);
    if (nl !== -1) {
      while (nl !== -1) {
        const cs = this.continueScalar(nl + 1);
        if (cs === -1)
          break;
        nl = qb.indexOf("\n", cs);
      }
      if (nl !== -1) {
        end = nl - (qb[nl - 1] === "\r" ? 2 : 1);
      }
    }
    if (end === -1) {
      if (!this.atEnd)
        return this.setNext("quoted-scalar");
      end = this.buffer.length;
    }
    yield* this.pushToIndex(end + 1, false);
    return this.flowLevel ? "flow" : "doc";
  }
  *parseBlockScalarHeader() {
    this.blockScalarIndent = -1;
    this.blockScalarKeep = false;
    let i = this.pos;
    while (true) {
      const ch = this.buffer[++i];
      if (ch === "+")
        this.blockScalarKeep = true;
      else if (ch > "0" && ch <= "9")
        this.blockScalarIndent = Number(ch) - 1;
      else if (ch !== "-")
        break;
    }
    return yield* this.pushUntil((ch) => isEmpty(ch) || ch === "#");
  }
  *parseBlockScalar() {
    let nl = this.pos - 1;
    let indent = 0;
    let ch;
    loop:
      for (let i = this.pos; ch = this.buffer[i]; ++i) {
        switch (ch) {
          case " ":
            indent += 1;
            break;
          case "\n":
            nl = i;
            indent = 0;
            break;
          case "\r": {
            const next = this.buffer[i + 1];
            if (!next && !this.atEnd)
              return this.setNext("block-scalar");
            if (next === "\n")
              break;
          }
          default:
            break loop;
        }
      }
    if (!ch && !this.atEnd)
      return this.setNext("block-scalar");
    if (indent >= this.indentNext) {
      if (this.blockScalarIndent === -1)
        this.indentNext = indent;
      else
        this.indentNext += this.blockScalarIndent;
      do {
        const cs = this.continueScalar(nl + 1);
        if (cs === -1)
          break;
        nl = this.buffer.indexOf("\n", cs);
      } while (nl !== -1);
      if (nl === -1) {
        if (!this.atEnd)
          return this.setNext("block-scalar");
        nl = this.buffer.length;
      }
    }
    if (!this.blockScalarKeep) {
      do {
        let i = nl - 1;
        let ch2 = this.buffer[i];
        if (ch2 === "\r")
          ch2 = this.buffer[--i];
        while (ch2 === " " || ch2 === "	")
          ch2 = this.buffer[--i];
        if (ch2 === "\n" && i >= this.pos)
          nl = i;
        else
          break;
      } while (true);
    }
    yield SCALAR2;
    yield* this.pushToIndex(nl + 1, true);
    return yield* this.parseLineStart();
  }
  *parsePlainScalar() {
    const inFlow = this.flowLevel > 0;
    let end = this.pos - 1;
    let i = this.pos - 1;
    let ch;
    while (ch = this.buffer[++i]) {
      if (ch === ":") {
        const next = this.buffer[i + 1];
        if (isEmpty(next) || inFlow && next === ",")
          break;
        end = i;
      } else if (isEmpty(ch)) {
        let next = this.buffer[i + 1];
        if (ch === "\r") {
          if (next === "\n") {
            i += 1;
            ch = "\n";
            next = this.buffer[i + 1];
          } else
            end = i;
        }
        if (next === "#" || inFlow && invalidFlowScalarChars.includes(next))
          break;
        if (ch === "\n") {
          const cs = this.continueScalar(i + 1);
          if (cs === -1)
            break;
          i = Math.max(i, cs - 2);
        }
      } else {
        if (inFlow && invalidFlowScalarChars.includes(ch))
          break;
        end = i;
      }
    }
    if (!ch && !this.atEnd)
      return this.setNext("plain-scalar");
    yield SCALAR2;
    yield* this.pushToIndex(end + 1, true);
    return inFlow ? "flow" : "doc";
  }
  *pushCount(n) {
    if (n > 0) {
      yield this.buffer.substr(this.pos, n);
      this.pos += n;
      return n;
    }
    return 0;
  }
  *pushToIndex(i, allowEmpty) {
    const s = this.buffer.slice(this.pos, i);
    if (s) {
      yield s;
      this.pos += s.length;
      return s.length;
    } else if (allowEmpty)
      yield "";
    return 0;
  }
  *pushIndicators() {
    switch (this.charAt(0)) {
      case "!":
        return (yield* this.pushTag()) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
      case "&":
        return (yield* this.pushUntil(isNotAnchorChar)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
      case ":":
      case "?":
      case "-":
        if (isEmpty(this.charAt(1))) {
          if (this.flowLevel === 0)
            this.indentNext = this.indentValue + 1;
          else if (this.flowKey)
            this.flowKey = false;
          return (yield* this.pushCount(1)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
        }
    }
    return 0;
  }
  *pushTag() {
    if (this.charAt(1) === "<") {
      let i = this.pos + 2;
      let ch = this.buffer[i];
      while (!isEmpty(ch) && ch !== ">")
        ch = this.buffer[++i];
      return yield* this.pushToIndex(ch === ">" ? i + 1 : i, false);
    } else {
      let i = this.pos + 1;
      let ch = this.buffer[i];
      while (ch) {
        if (tagChars.includes(ch))
          ch = this.buffer[++i];
        else if (ch === "%" && hexDigits.includes(this.buffer[i + 1]) && hexDigits.includes(this.buffer[i + 2])) {
          ch = this.buffer[i += 3];
        } else
          break;
      }
      return yield* this.pushToIndex(i, false);
    }
  }
  *pushNewline() {
    const ch = this.buffer[this.pos];
    if (ch === "\n")
      return yield* this.pushCount(1);
    else if (ch === "\r" && this.charAt(1) === "\n")
      return yield* this.pushCount(2);
    else
      return 0;
  }
  *pushSpaces(allowTabs) {
    let i = this.pos - 1;
    let ch;
    do {
      ch = this.buffer[++i];
    } while (ch === " " || allowTabs && ch === "	");
    const n = i - this.pos;
    if (n > 0) {
      yield this.buffer.substr(this.pos, n);
      this.pos = i;
    }
    return n;
  }
  *pushUntil(test) {
    let i = this.pos;
    let ch = this.buffer[i];
    while (!test(ch))
      ch = this.buffer[++i];
    return yield* this.pushToIndex(i, false);
  }
};

// node_modules/yaml/browser/dist/parse/line-counter.js
var LineCounter = class {
  constructor() {
    this.lineStarts = [];
    this.addNewLine = (offset) => this.lineStarts.push(offset);
    this.linePos = (offset) => {
      let low = 0;
      let high = this.lineStarts.length;
      while (low < high) {
        const mid = low + high >> 1;
        if (this.lineStarts[mid] < offset)
          low = mid + 1;
        else
          high = mid;
      }
      if (this.lineStarts[low] === offset)
        return { line: low + 1, col: 1 };
      if (low === 0)
        return { line: 0, col: offset };
      const start = this.lineStarts[low - 1];
      return { line: low, col: offset - start + 1 };
    };
  }
};

// node_modules/yaml/browser/dist/parse/parser.js
function includesToken(list, type) {
  for (let i = 0; i < list.length; ++i)
    if (list[i].type === type)
      return true;
  return false;
}
function includesNonEmpty(list) {
  for (let i = 0; i < list.length; ++i) {
    switch (list[i].type) {
      case "space":
      case "comment":
      case "newline":
        break;
      default:
        return true;
    }
  }
  return false;
}
function isFlowToken(token) {
  switch (token === null || token === void 0 ? void 0 : token.type) {
    case "alias":
    case "scalar":
    case "single-quoted-scalar":
    case "double-quoted-scalar":
    case "flow-collection":
      return true;
    default:
      return false;
  }
}
function getPrevProps(parent) {
  switch (parent.type) {
    case "document":
      return parent.start;
    case "block-map": {
      const it = parent.items[parent.items.length - 1];
      return it.sep || it.start;
    }
    case "block-seq":
      return parent.items[parent.items.length - 1].start;
    default:
      return [];
  }
}
function getFirstKeyStartProps(prev) {
  var _a;
  if (prev.length === 0)
    return [];
  let i = prev.length;
  loop:
    while (--i >= 0) {
      switch (prev[i].type) {
        case "doc-start":
        case "explicit-key-ind":
        case "map-value-ind":
        case "seq-item-ind":
        case "newline":
          break loop;
      }
    }
  while (((_a = prev[++i]) === null || _a === void 0 ? void 0 : _a.type) === "space") {
  }
  return prev.splice(i, prev.length);
}
function fixFlowSeqItems(fc) {
  if (fc.start.type === "flow-seq-start") {
    for (const it of fc.items) {
      if (it.sep && !it.value && !includesToken(it.start, "explicit-key-ind") && !includesToken(it.sep, "map-value-ind")) {
        if (it.key)
          it.value = it.key;
        delete it.key;
        if (isFlowToken(it.value)) {
          if (it.value.end)
            Array.prototype.push.apply(it.value.end, it.sep);
          else
            it.value.end = it.sep;
        } else
          Array.prototype.push.apply(it.start, it.sep);
        delete it.sep;
      }
    }
  }
}
var Parser = class {
  /**
   * @param onNewLine - If defined, called separately with the start position of
   *   each new line (in `parse()`, including the start of input).
   */
  constructor(onNewLine) {
    this.atNewLine = true;
    this.atScalar = false;
    this.indent = 0;
    this.offset = 0;
    this.onKeyLine = false;
    this.stack = [];
    this.source = "";
    this.type = "";
    this.lexer = new Lexer();
    this.onNewLine = onNewLine;
  }
  /**
   * Parse `source` as a YAML stream.
   * If `incomplete`, a part of the last line may be left as a buffer for the next call.
   *
   * Errors are not thrown, but yielded as `{ type: 'error', message }` tokens.
   *
   * @returns A generator of tokens representing each directive, document, and other structure.
   */
  *parse(source, incomplete = false) {
    if (this.onNewLine && this.offset === 0)
      this.onNewLine(0);
    for (const lexeme of this.lexer.lex(source, incomplete))
      yield* this.next(lexeme);
    if (!incomplete)
      yield* this.end();
  }
  /**
   * Advance the parser by the `source` of one lexical token.
   */
  *next(source) {
    this.source = source;
    if (this.atScalar) {
      this.atScalar = false;
      yield* this.step();
      this.offset += source.length;
      return;
    }
    const type = tokenType(source);
    if (!type) {
      const message = `Not a YAML token: ${source}`;
      yield* this.pop({ type: "error", offset: this.offset, message, source });
      this.offset += source.length;
    } else if (type === "scalar") {
      this.atNewLine = false;
      this.atScalar = true;
      this.type = "scalar";
    } else {
      this.type = type;
      yield* this.step();
      switch (type) {
        case "newline":
          this.atNewLine = true;
          this.indent = 0;
          if (this.onNewLine)
            this.onNewLine(this.offset + source.length);
          break;
        case "space":
          if (this.atNewLine && source[0] === " ")
            this.indent += source.length;
          break;
        case "explicit-key-ind":
        case "map-value-ind":
        case "seq-item-ind":
          if (this.atNewLine)
            this.indent += source.length;
          break;
        case "doc-mode":
        case "flow-error-end":
          return;
        default:
          this.atNewLine = false;
      }
      this.offset += source.length;
    }
  }
  /** Call at end of input to push out any remaining constructions */
  *end() {
    while (this.stack.length > 0)
      yield* this.pop();
  }
  get sourceToken() {
    const st = {
      type: this.type,
      offset: this.offset,
      indent: this.indent,
      source: this.source
    };
    return st;
  }
  *step() {
    const top = this.peek(1);
    if (this.type === "doc-end" && (!top || top.type !== "doc-end")) {
      while (this.stack.length > 0)
        yield* this.pop();
      this.stack.push({
        type: "doc-end",
        offset: this.offset,
        source: this.source
      });
      return;
    }
    if (!top)
      return yield* this.stream();
    switch (top.type) {
      case "document":
        return yield* this.document(top);
      case "alias":
      case "scalar":
      case "single-quoted-scalar":
      case "double-quoted-scalar":
        return yield* this.scalar(top);
      case "block-scalar":
        return yield* this.blockScalar(top);
      case "block-map":
        return yield* this.blockMap(top);
      case "block-seq":
        return yield* this.blockSequence(top);
      case "flow-collection":
        return yield* this.flowCollection(top);
      case "doc-end":
        return yield* this.documentEnd(top);
    }
    yield* this.pop();
  }
  peek(n) {
    return this.stack[this.stack.length - n];
  }
  *pop(error) {
    const token = error || this.stack.pop();
    if (!token) {
      const message = "Tried to pop an empty stack";
      yield { type: "error", offset: this.offset, source: "", message };
    } else if (this.stack.length === 0) {
      yield token;
    } else {
      const top = this.peek(1);
      if (token.type === "block-scalar") {
        token.indent = "indent" in top ? top.indent : 0;
      } else if (token.type === "flow-collection" && top.type === "document") {
        token.indent = 0;
      }
      if (token.type === "flow-collection")
        fixFlowSeqItems(token);
      switch (top.type) {
        case "document":
          top.value = token;
          break;
        case "block-scalar":
          top.props.push(token);
          break;
        case "block-map": {
          const it = top.items[top.items.length - 1];
          if (it.value) {
            top.items.push({ start: [], key: token, sep: [] });
            this.onKeyLine = true;
            return;
          } else if (it.sep) {
            it.value = token;
          } else {
            Object.assign(it, { key: token, sep: [] });
            this.onKeyLine = !includesToken(it.start, "explicit-key-ind");
            return;
          }
          break;
        }
        case "block-seq": {
          const it = top.items[top.items.length - 1];
          if (it.value)
            top.items.push({ start: [], value: token });
          else
            it.value = token;
          break;
        }
        case "flow-collection": {
          const it = top.items[top.items.length - 1];
          if (!it || it.value)
            top.items.push({ start: [], key: token, sep: [] });
          else if (it.sep)
            it.value = token;
          else
            Object.assign(it, { key: token, sep: [] });
          return;
        }
        default:
          yield* this.pop();
          yield* this.pop(token);
      }
      if ((top.type === "document" || top.type === "block-map" || top.type === "block-seq") && (token.type === "block-map" || token.type === "block-seq")) {
        const last = token.items[token.items.length - 1];
        if (last && !last.sep && !last.value && last.start.length > 0 && !includesNonEmpty(last.start) && (token.indent === 0 || last.start.every((st) => st.type !== "comment" || st.indent < token.indent))) {
          if (top.type === "document")
            top.end = last.start;
          else
            top.items.push({ start: last.start });
          token.items.splice(-1, 1);
        }
      }
    }
  }
  *stream() {
    switch (this.type) {
      case "directive-line":
        yield { type: "directive", offset: this.offset, source: this.source };
        return;
      case "byte-order-mark":
      case "space":
      case "comment":
      case "newline":
        yield this.sourceToken;
        return;
      case "doc-mode":
      case "doc-start": {
        const doc = {
          type: "document",
          offset: this.offset,
          start: []
        };
        if (this.type === "doc-start")
          doc.start.push(this.sourceToken);
        this.stack.push(doc);
        return;
      }
    }
    yield {
      type: "error",
      offset: this.offset,
      message: `Unexpected ${this.type} token in YAML stream`,
      source: this.source
    };
  }
  *document(doc) {
    if (doc.value)
      return yield* this.lineEnd(doc);
    switch (this.type) {
      case "doc-start": {
        if (includesNonEmpty(doc.start)) {
          yield* this.pop();
          yield* this.step();
        } else
          doc.start.push(this.sourceToken);
        return;
      }
      case "anchor":
      case "tag":
      case "space":
      case "comment":
      case "newline":
        doc.start.push(this.sourceToken);
        return;
    }
    const bv = this.startBlockValue(doc);
    if (bv)
      this.stack.push(bv);
    else {
      yield {
        type: "error",
        offset: this.offset,
        message: `Unexpected ${this.type} token in YAML document`,
        source: this.source
      };
    }
  }
  *scalar(scalar) {
    if (this.type === "map-value-ind") {
      const prev = getPrevProps(this.peek(2));
      const start = getFirstKeyStartProps(prev);
      let sep;
      if (scalar.end) {
        sep = scalar.end;
        sep.push(this.sourceToken);
        delete scalar.end;
      } else
        sep = [this.sourceToken];
      const map2 = {
        type: "block-map",
        offset: scalar.offset,
        indent: scalar.indent,
        items: [{ start, key: scalar, sep }]
      };
      this.onKeyLine = true;
      this.stack[this.stack.length - 1] = map2;
    } else
      yield* this.lineEnd(scalar);
  }
  *blockScalar(scalar) {
    switch (this.type) {
      case "space":
      case "comment":
      case "newline":
        scalar.props.push(this.sourceToken);
        return;
      case "scalar":
        scalar.source = this.source;
        this.atNewLine = true;
        this.indent = 0;
        if (this.onNewLine) {
          let nl = this.source.indexOf("\n") + 1;
          while (nl !== 0) {
            this.onNewLine(this.offset + nl);
            nl = this.source.indexOf("\n", nl) + 1;
          }
        }
        yield* this.pop();
        break;
      default:
        yield* this.pop();
        yield* this.step();
    }
  }
  *blockMap(map2) {
    var _a;
    const it = map2.items[map2.items.length - 1];
    switch (this.type) {
      case "newline":
        this.onKeyLine = false;
        if (it.value) {
          const end = "end" in it.value ? it.value.end : void 0;
          const last = Array.isArray(end) ? end[end.length - 1] : void 0;
          if ((last === null || last === void 0 ? void 0 : last.type) === "comment")
            end === null || end === void 0 ? void 0 : end.push(this.sourceToken);
          else
            map2.items.push({ start: [this.sourceToken] });
        } else if (it.sep)
          it.sep.push(this.sourceToken);
        else
          it.start.push(this.sourceToken);
        return;
      case "space":
      case "comment":
        if (it.value)
          map2.items.push({ start: [this.sourceToken] });
        else if (it.sep)
          it.sep.push(this.sourceToken);
        else {
          if (this.atIndentedComment(it.start, map2.indent)) {
            const prev = map2.items[map2.items.length - 2];
            const end = (_a = prev === null || prev === void 0 ? void 0 : prev.value) === null || _a === void 0 ? void 0 : _a.end;
            if (Array.isArray(end)) {
              Array.prototype.push.apply(end, it.start);
              end.push(this.sourceToken);
              map2.items.pop();
              return;
            }
          }
          it.start.push(this.sourceToken);
        }
        return;
    }
    if (this.indent >= map2.indent) {
      const atNextItem = !this.onKeyLine && this.indent === map2.indent && (it.sep || includesNonEmpty(it.start));
      switch (this.type) {
        case "anchor":
        case "tag":
          if (atNextItem || it.value) {
            map2.items.push({ start: [this.sourceToken] });
            this.onKeyLine = true;
          } else if (it.sep)
            it.sep.push(this.sourceToken);
          else
            it.start.push(this.sourceToken);
          return;
        case "explicit-key-ind":
          if (!it.sep && !includesToken(it.start, "explicit-key-ind"))
            it.start.push(this.sourceToken);
          else if (atNextItem || it.value)
            map2.items.push({ start: [this.sourceToken] });
          else
            this.stack.push({
              type: "block-map",
              offset: this.offset,
              indent: this.indent,
              items: [{ start: [this.sourceToken] }]
            });
          this.onKeyLine = true;
          return;
        case "map-value-ind":
          if (!it.sep)
            Object.assign(it, { key: null, sep: [this.sourceToken] });
          else if (it.value || atNextItem && !includesToken(it.start, "explicit-key-ind"))
            map2.items.push({ start: [], key: null, sep: [this.sourceToken] });
          else if (includesToken(it.sep, "map-value-ind"))
            this.stack.push({
              type: "block-map",
              offset: this.offset,
              indent: this.indent,
              items: [{ start: [], key: null, sep: [this.sourceToken] }]
            });
          else if (includesToken(it.start, "explicit-key-ind") && isFlowToken(it.key) && !includesToken(it.sep, "newline")) {
            const start = getFirstKeyStartProps(it.start);
            const key = it.key;
            const sep = it.sep;
            sep.push(this.sourceToken);
            delete it.key, delete it.sep;
            this.stack.push({
              type: "block-map",
              offset: this.offset,
              indent: this.indent,
              items: [{ start, key, sep }]
            });
          } else
            it.sep.push(this.sourceToken);
          this.onKeyLine = true;
          return;
        case "alias":
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar": {
          const fs = this.flowScalar(this.type);
          if (atNextItem || it.value) {
            map2.items.push({ start: [], key: fs, sep: [] });
            this.onKeyLine = true;
          } else if (it.sep) {
            this.stack.push(fs);
          } else {
            Object.assign(it, { key: fs, sep: [] });
            this.onKeyLine = true;
          }
          return;
        }
        default: {
          const bv = this.startBlockValue(map2);
          if (bv) {
            if (atNextItem && bv.type !== "block-seq" && includesToken(it.start, "explicit-key-ind"))
              map2.items.push({ start: [] });
            this.stack.push(bv);
            return;
          }
        }
      }
    }
    yield* this.pop();
    yield* this.step();
  }
  *blockSequence(seq2) {
    var _a;
    const it = seq2.items[seq2.items.length - 1];
    switch (this.type) {
      case "newline":
        if (it.value) {
          const end = "end" in it.value ? it.value.end : void 0;
          const last = Array.isArray(end) ? end[end.length - 1] : void 0;
          if ((last === null || last === void 0 ? void 0 : last.type) === "comment")
            end === null || end === void 0 ? void 0 : end.push(this.sourceToken);
          else
            seq2.items.push({ start: [this.sourceToken] });
        } else
          it.start.push(this.sourceToken);
        return;
      case "space":
      case "comment":
        if (it.value)
          seq2.items.push({ start: [this.sourceToken] });
        else {
          if (this.atIndentedComment(it.start, seq2.indent)) {
            const prev = seq2.items[seq2.items.length - 2];
            const end = (_a = prev === null || prev === void 0 ? void 0 : prev.value) === null || _a === void 0 ? void 0 : _a.end;
            if (Array.isArray(end)) {
              Array.prototype.push.apply(end, it.start);
              end.push(this.sourceToken);
              seq2.items.pop();
              return;
            }
          }
          it.start.push(this.sourceToken);
        }
        return;
      case "anchor":
      case "tag":
        if (it.value || this.indent <= seq2.indent)
          break;
        it.start.push(this.sourceToken);
        return;
      case "seq-item-ind":
        if (this.indent !== seq2.indent)
          break;
        if (it.value || includesToken(it.start, "seq-item-ind"))
          seq2.items.push({ start: [this.sourceToken] });
        else
          it.start.push(this.sourceToken);
        return;
    }
    if (this.indent > seq2.indent) {
      const bv = this.startBlockValue(seq2);
      if (bv) {
        this.stack.push(bv);
        return;
      }
    }
    yield* this.pop();
    yield* this.step();
  }
  *flowCollection(fc) {
    const it = fc.items[fc.items.length - 1];
    if (this.type === "flow-error-end") {
      let top;
      do {
        yield* this.pop();
        top = this.peek(1);
      } while (top && top.type === "flow-collection");
    } else if (fc.end.length === 0) {
      switch (this.type) {
        case "comma":
        case "explicit-key-ind":
          if (!it || it.sep)
            fc.items.push({ start: [this.sourceToken] });
          else
            it.start.push(this.sourceToken);
          return;
        case "map-value-ind":
          if (!it || it.value)
            fc.items.push({ start: [], key: null, sep: [this.sourceToken] });
          else if (it.sep)
            it.sep.push(this.sourceToken);
          else
            Object.assign(it, { key: null, sep: [this.sourceToken] });
          return;
        case "space":
        case "comment":
        case "newline":
        case "anchor":
        case "tag":
          if (!it || it.value)
            fc.items.push({ start: [this.sourceToken] });
          else if (it.sep)
            it.sep.push(this.sourceToken);
          else
            it.start.push(this.sourceToken);
          return;
        case "alias":
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar": {
          const fs = this.flowScalar(this.type);
          if (!it || it.value)
            fc.items.push({ start: [], key: fs, sep: [] });
          else if (it.sep)
            this.stack.push(fs);
          else
            Object.assign(it, { key: fs, sep: [] });
          return;
        }
        case "flow-map-end":
        case "flow-seq-end":
          fc.end.push(this.sourceToken);
          return;
      }
      const bv = this.startBlockValue(fc);
      if (bv)
        this.stack.push(bv);
      else {
        yield* this.pop();
        yield* this.step();
      }
    } else {
      const parent = this.peek(2);
      if (parent.type === "block-map" && (this.type === "map-value-ind" || this.type === "newline" && !parent.items[parent.items.length - 1].sep)) {
        yield* this.pop();
        yield* this.step();
      } else if (this.type === "map-value-ind" && parent.type !== "flow-collection") {
        const prev = getPrevProps(parent);
        const start = getFirstKeyStartProps(prev);
        fixFlowSeqItems(fc);
        const sep = fc.end.splice(1, fc.end.length);
        sep.push(this.sourceToken);
        const map2 = {
          type: "block-map",
          offset: fc.offset,
          indent: fc.indent,
          items: [{ start, key: fc, sep }]
        };
        this.onKeyLine = true;
        this.stack[this.stack.length - 1] = map2;
      } else {
        yield* this.lineEnd(fc);
      }
    }
  }
  flowScalar(type) {
    if (this.onNewLine) {
      let nl = this.source.indexOf("\n") + 1;
      while (nl !== 0) {
        this.onNewLine(this.offset + nl);
        nl = this.source.indexOf("\n", nl) + 1;
      }
    }
    return {
      type,
      offset: this.offset,
      indent: this.indent,
      source: this.source
    };
  }
  startBlockValue(parent) {
    switch (this.type) {
      case "alias":
      case "scalar":
      case "single-quoted-scalar":
      case "double-quoted-scalar":
        return this.flowScalar(this.type);
      case "block-scalar-header":
        return {
          type: "block-scalar",
          offset: this.offset,
          indent: this.indent,
          props: [this.sourceToken],
          source: ""
        };
      case "flow-map-start":
      case "flow-seq-start":
        return {
          type: "flow-collection",
          offset: this.offset,
          indent: this.indent,
          start: this.sourceToken,
          items: [],
          end: []
        };
      case "seq-item-ind":
        return {
          type: "block-seq",
          offset: this.offset,
          indent: this.indent,
          items: [{ start: [this.sourceToken] }]
        };
      case "explicit-key-ind": {
        this.onKeyLine = true;
        const prev = getPrevProps(parent);
        const start = getFirstKeyStartProps(prev);
        start.push(this.sourceToken);
        return {
          type: "block-map",
          offset: this.offset,
          indent: this.indent,
          items: [{ start }]
        };
      }
      case "map-value-ind": {
        this.onKeyLine = true;
        const prev = getPrevProps(parent);
        const start = getFirstKeyStartProps(prev);
        return {
          type: "block-map",
          offset: this.offset,
          indent: this.indent,
          items: [{ start, key: null, sep: [this.sourceToken] }]
        };
      }
    }
    return null;
  }
  atIndentedComment(start, indent) {
    if (this.type !== "comment")
      return false;
    if (this.indent <= indent)
      return false;
    return start.every((st) => st.type === "newline" || st.type === "space");
  }
  *documentEnd(docEnd) {
    if (this.type !== "doc-mode") {
      if (docEnd.end)
        docEnd.end.push(this.sourceToken);
      else
        docEnd.end = [this.sourceToken];
      if (this.type === "newline")
        yield* this.pop();
    }
  }
  *lineEnd(token) {
    switch (this.type) {
      case "comma":
      case "doc-start":
      case "doc-end":
      case "flow-seq-end":
      case "flow-map-end":
      case "map-value-ind":
        yield* this.pop();
        yield* this.step();
        break;
      case "newline":
        this.onKeyLine = false;
      case "space":
      case "comment":
      default:
        if (token.end)
          token.end.push(this.sourceToken);
        else
          token.end = [this.sourceToken];
        if (this.type === "newline")
          yield* this.pop();
    }
  }
};

// node_modules/yaml/browser/dist/public-api.js
function parseOptions(options) {
  const prettyErrors = options.prettyErrors !== false;
  const lineCounter = options.lineCounter || prettyErrors && new LineCounter() || null;
  return { lineCounter, prettyErrors };
}
function parseDocument(source, options = {}) {
  const { lineCounter, prettyErrors } = parseOptions(options);
  const parser = new Parser(lineCounter === null || lineCounter === void 0 ? void 0 : lineCounter.addNewLine);
  const composer = new Composer(options);
  let doc = null;
  for (const _doc of composer.compose(parser.parse(source), true, source.length)) {
    if (!doc)
      doc = _doc;
    else if (doc.options.logLevel !== "silent") {
      doc.errors.push(new YAMLParseError(_doc.range.slice(0, 2), "MULTIPLE_DOCS", "Source contains multiple documents; please use YAML.parseAllDocuments()"));
      break;
    }
  }
  if (prettyErrors && lineCounter) {
    doc.errors.forEach(prettifyError(source, lineCounter));
    doc.warnings.forEach(prettifyError(source, lineCounter));
  }
  return doc;
}

// tagrenamer/File.ts
var File = class {
  constructor(app2, filename, tagPositions, hasFrontMatter2) {
    this.app = app2;
    this.filename = filename;
    this.basename = filename.split("/").pop();
    this.tagPositions = tagPositions;
    this.hasFrontMatter = !!hasFrontMatter2;
  }
  /** @param {Replacement} replace */
  async renamed(replace) {
    const file = this.app.vault.getAbstractFileByPath(this.filename);
    const original = await this.app.vault.read(file);
    let text = original;
    if (this.hasFrontMatter) {
      text = this.replaceInFrontMatter(text, replace);
    }
    if (text !== original) {
      await this.app.vault.modify(file, text);
      return true;
    }
  }
  /** @param {Replacement} replace */
  replaceInFrontMatter(text, replace) {
    const [empty, frontMatter] = text.split(/^---\r?$\n?/m, 2);
    if (empty.trim() !== "" || !frontMatter.trim() || !frontMatter.endsWith("\n"))
      return text;
    const parsed = parseDocument(frontMatter, { keepSourceTokens: true });
    if (parsed.errors.length) {
      const error = `YAML issue with ${this.filename}: ${parsed.errors[0]}`;
      console.error(error);
      new import_obsidian.Notice(error + "; skipping frontmatter");
      return;
    }
    let changed = false, json = parsed.toJSON();
    function setInNode(node, value, afterKey = false) {
      cst_exports.setScalarValue(node.srcToken, value, { afterKey });
      changed = true;
      node.value = value;
    }
    function processField(prop, isAlias2) {
      const node = parsed.get(prop, true);
      if (!node)
        return;
      const field = json[prop];
      if (!field || !field.length)
        return;
      if (typeof field === "string") {
        const parts = field.split(isAlias2 ? /(^\s+|\s*,\s*|\s+$)/ : /([\s,]+)/);
        const after = replace.inArray(parts, true, isAlias2).join("");
        if (field != after)
          setInNode(node, after, true);
      } else if (Array.isArray(field)) {
        replace.inArray(field, false, isAlias2).forEach((v, i) => {
          if (field[i] !== v)
            setInNode(node.get(i, true), v);
        });
      }
    }
    for (const { key: { value: prop } } of parsed.contents.items) {
      if (/^tags?$/i.test(prop)) {
        processField(prop, false);
      } else if (/^alias(es)?$/i.test(prop)) {
        processField(prop, true);
      }
    }
    return changed ? text.replace(frontMatter, cst_exports.stringify(parsed.contents.srcToken)) : text;
  }
};

// tagrenamer/renaming.ts
function hasFrontMatter(file) {
  let { frontmatter } = app.metadataCache.getFileCache(file) || {};
  return frontmatter != null;
}
function hasTags(file) {
  let { frontmatter } = app.metadataCache.getFileCache(file) || {};
  const fmtags = (0, import_obsidian2.parseFrontMatterTags)(frontmatter) || [];
  const aliasTags = ((0, import_obsidian2.parseFrontMatterAliases)(frontmatter) || []).filter(Tag.isTag);
  return fmtags.length || aliasTags.length ? true : false;
}
async function renameTag(file, tagName, newName) {
  const oldTag = new Tag(tagName), newTag = new Tag(newName), replace = new Replacement(oldTag, newTag);
  const target = await findTargets(oldTag, file);
  if (!target) {
    return false;
  }
  await target.renamed(replace);
  return true;
}
async function findTargets(tag, file) {
  let { frontmatter, tags } = app.metadataCache.getFileCache(file) || {};
  const fmtags = ((0, import_obsidian2.parseFrontMatterTags)(frontmatter) || []).filter(tag.matches);
  const aliasTags = ((0, import_obsidian2.parseFrontMatterAliases)(frontmatter) || []).filter(Tag.isTag).filter(tag.matches);
  if (fmtags.length || aliasTags.length) {
    return new File(app, file.path, tags, fmtags.length + aliasTags.length);
  }
  return null;
}
function renameBlogTitle(app2, path, view) {
  let moment2 = require_moment();
  const dateYYYYMMDD = moment2().format("YYYYMMDD");
  let renamedPath = "";
  if (path.match(/^.\/Blog \d\d\d\d\d\d\d\d/)) {
    return Promise.resolve();
  } else if (path.match(/^.\/blog \d\d\d\d\d\d\d\d/)) {
    new import_obsidian2.Notice("start with blog with date, renaming blog to Blog");
    renamedPath = path.replace(/^(.\/)blog /, `$1Blog `);
    return renameFile(app2, view.file, renamedPath);
  } else if (path.match(/^.\/Blog /)) {
    new import_obsidian2.Notice("starts with Blog but no date, adding date");
    renamedPath = path.replace(/^(.\/Blog )/, `$1${dateYYYYMMDD} `);
    return renameFile(app2, view.file, renamedPath);
  } else if (path.match(/^.\/blog /)) {
    new import_obsidian2.Notice("starts with blog but no date, adding date");
    renamedPath = path.replace(/^(.\/)blog /, `$1Blog ${dateYYYYMMDD} `);
    return renameFile(app2, view.file, renamedPath);
  } else {
    new import_obsidian2.Notice("starts without blog, adding Blog + date");
    renamedPath = path.replace(/^(.\/)/, `$1Blog ${dateYYYYMMDD} `);
    return renameFile(app2, view.file, renamedPath);
  }
}
async function renameFile(app2, file, newPath) {
  app2.fileManager.renameFile(file, newPath);
}

// updateNoteTypeModal.ts
var ALL_TYPES = [
  {
    type: "a/n/n",
    description: "N Current Task"
  },
  {
    type: "a/w/n",
    description: "W Current Task"
  },
  {
    type: "a/n/l",
    description: "N Later Task"
  },
  {
    type: "a/w/l",
    description: "W Later Task"
  },
  {
    type: "a/n/p",
    description: "N Permanent Task"
  },
  {
    type: "a/w/p",
    description: "W Permanent Task"
  },
  {
    type: "b/n/s",
    description: "Zettelkasten - Source notes (like books / video / thoughts / conversation)"
  },
  {
    type: "b/n/c",
    description: "Zettelkasten - Cards (With your own thought)"
  },
  {
    type: "c/t/d",
    description: "Threads post draft"
  },
  {
    type: "c/b/d",
    description: "Blog post draft"
  },
  {
    type: "b/n/u",
    description: "Zettelkasten - Unprocessed material like an inbox"
  },
  {
    type: "b/n/m",
    description: "Zettelkasten - MOC Notes for a small topic"
  },
  {
    type: "b/n/z",
    description: "Zettelkasten - Slip box"
  },
  {
    type: "b/n/i",
    description: "Index Notes for a big topic"
  },
  {
    type: "b/n/n",
    description: "Zettelkasten - Notes (Deprecated)"
  },
  {
    type: "b/n/v",
    description: "Zettelkasten - Voice script (Deprecated?)"
  },
  {
    type: "b/n/r",
    description: "Zettelkasten - Reference (Deprecated?)"
  },
  {
    type: "b/n/p",
    description: "Placeholder Notes (Deprecated?)"
  },
  {
    type: "b/a/p",
    description: "Area of Responsibility - Primary"
  },
  {
    type: "b/a/s",
    description: "Area of Responsibility - Secondary"
  },
  {
    type: "c/b/i",
    description: "Blog post content completed but awaiting upload image"
  },
  {
    type: "c/b/r",
    description: "Blog post ready to publish"
  },
  {
    type: "c/b/p",
    description: "Blog post published"
  },
  {
    type: "c/b/i",
    description: "Blog post series index"
  },
  {
    type: "c/b/a",
    description: "Blog post abandoned"
  },
  {
    type: "c/b/o",
    description: "Blog post outlined (Deprecated?)"
  },
  {
    type: "c/b/f",
    description: "Blog post fine tuned (Deprecated?)"
  },
  {
    type: "c/t/r",
    description: "Threads post ready to post"
  },
  {
    type: "c/t/t",
    description: "Threads post threads published"
  },
  {
    type: "c/t/p",
    description: "Threads post published"
  },
  {
    type: "c/t/i",
    description: "Threads post series index"
  },
  {
    type: "c/t/a",
    description: "Threads post abandoned"
  },
  {
    type: "c/x/d",
    description: "Twitter post drafting"
  },
  {
    type: "c/x/r",
    description: "Twitter post ready to publish"
  },
  {
    type: "c/x/p",
    description: "Twitter post published"
  },
  {
    type: "a/n/w",
    description: "N Waiting Task"
  },
  {
    type: "a/n/d",
    description: "N Done Task"
  },
  {
    type: "a/n/a",
    description: "N Archive Task"
  },
  {
    type: "a/w/w",
    description: "W Waiting Task"
  },
  {
    type: "a/w/d",
    description: "W Done Task"
  },
  {
    type: "a/w/a",
    description: "W Archive Task"
  }
];
var UpdateNoteTypeModal = class extends import_obsidian3.FuzzySuggestModal {
  constructor(app2, editor, file) {
    super(app2);
    this.editor = editor;
    this.file = file;
  }
  getItems() {
    return ALL_TYPES;
  }
  getItemText(noteType) {
    return noteType.type;
  }
  // Renders each suggestion item.
  renderSuggestion(choosenNoteTypeMatch, el) {
    const noteType = choosenNoteTypeMatch.item;
    el.createEl("div", { text: noteType.type });
    el.createEl("small", { text: noteType.description });
  }
  containsType(line) {
    return ALL_TYPES.filter((noteType) => line.contains(noteType.type)).length > 0;
  }
  addFrontMatterWithTag(value) {
    const cursor = this.editor.getCursor();
    const oldLine = cursor.line;
    const oldCh = cursor.ch;
    const addText = `---
tag: ${value}
---

${this.editor.getValue()}`;
    this.editor.setValue(addText);
    cursor.line = oldLine + 4;
    cursor.ch = oldCh;
    this.editor.setCursor(cursor);
  }
  addTagAssumingHasFrontMatter(value) {
    const cursor = this.editor.getCursor();
    const oldLine = cursor.line;
    const oldCh = cursor.ch;
    let firstLineIndex = 0;
    const lineCount = this.editor.lineCount();
    for (let i = 0; i < lineCount; i++) {
      if (this.editor.getLine(i).trim() == "---".trim()) {
        firstLineIndex = i;
        break;
      }
    }
    if (firstLineIndex == lineCount) {
      new import_obsidian3.Notice("Something wrong here");
      return;
    }
    let text = "";
    for (let i = 0; i <= firstLineIndex; i++) {
      text = text + this.editor.getLine(i) + "\n";
    }
    text = text + `tag: ${value}
`;
    for (let i = firstLineIndex + 1; i <= this.editor.lineCount(); i++) {
      text = text + this.editor.getLine(i) + "\n";
    }
    this.editor.setValue(text);
    cursor.line = oldLine + (oldLine <= firstLineIndex ? 0 : 1);
    cursor.ch = oldCh;
    this.editor.setCursor(cursor);
  }
  // Perform action on the selected suggestion.
  onChooseItem(choosenNoteType, evt) {
    if (!hasFrontMatter(this.file)) {
      this.addFrontMatterWithTag(choosenNoteType.type);
    } else {
      if (hasTags(this.file)) {
        ALL_TYPES.forEach((t) => {
          renameTag(this.file, t.type, choosenNoteType.type);
        });
      } else {
        this.addTagAssumingHasFrontMatter(choosenNoteType.type);
      }
    }
  }
};

// main.ts
var import_obsidian20 = require("obsidian");

// addCommentTagModal.ts
var import_obsidian4 = require("obsidian");
var ALL_TYPES2 = [
  {
    type: "d/question",
    description: "Question"
  },
  {
    type: "d/answer",
    description: "Answer"
  },
  {
    type: "d/solves",
    description: "Solves some problem"
  },
  {
    type: "d/ref",
    description: "Reference"
  },
  {
    type: "d/selfthink",
    description: "Self think"
  },
  {
    type: "d/notsure",
    description: "Not sure"
  },
  {
    type: "d/a1\u23F9\uFE0F",
    description: "A1 - my experience"
  },
  {
    type: "d/a2\u23FA\uFE0F",
    description: "A2 - future action"
  },
  {
    type: "d/c\u{1F504}",
    description: "Context"
  },
  {
    type: "d/w\u23EA",
    description: "Idea Compass - West - What are similar / supporting idea?"
  },
  {
    type: "d/n\u23EB",
    description: "Idea Compass - North - Where does this idea come from?"
  },
  {
    type: "d/s\u23EC",
    description: "Idea Compass - South - Where does the idea lead to?"
  },
  {
    type: "d/toMerge",
    description: "TODO - To Merge with another note"
  },
  {
    type: "d/toMove",
    description: "TODO - To Merge with another note"
  },
  {
    type: "d/toSplit",
    description: "ToDO - To Split to multiple note"
  },
  {
    type: "d/toCard",
    description: "TODO - To Write card"
  }
];
var AddFootnoteTagModal = class extends import_obsidian4.FuzzySuggestModal {
  constructor(app2, editor) {
    super(app2);
    this.editor = editor;
  }
  getItems() {
    return ALL_TYPES2;
  }
  getItemText(noteType) {
    return noteType.type;
  }
  static removeTag(line) {
    ALL_TYPES2.forEach((noteType) => line = line.replace(`#${noteType.type} `, ""));
    return line;
  }
  // Renders each suggestion item.
  renderSuggestion(choosenNoteTypeMatch, el) {
    const noteType = choosenNoteTypeMatch.item;
    el.createEl("div", { text: noteType.type });
    el.createEl("small", { text: noteType.description });
  }
  containsType(line) {
    return ALL_TYPES2.filter((noteType) => line.contains(noteType.type)).length > 0;
  }
  // Perform action on the selected suggestion.
  onChooseItem(choosenNoteType, evt) {
    const selection = this.editor.getSelection();
    const replacedStr = `#${choosenNoteType.type} `;
    if (selection.length != 0) {
      this.editor.replaceSelection(replacedStr);
    } else {
      const cursor = this.editor.getCursor();
      this.editor.replaceRange(replacedStr, cursor);
      cursor.ch = cursor.ch + replacedStr.length;
      this.editor.setCursor(cursor);
    }
  }
};

// addTaskTagModal.ts
var import_obsidian5 = require("obsidian");
var ALL_TYPES3 = [
  {
    type: "n",
    description: "N"
  },
  {
    type: "w",
    description: "W"
  },
  {
    type: "n",
    description: "N"
  },
  {
    type: "w",
    description: "W"
  },
  {
    type: "n",
    description: "N"
  },
  {
    type: "w",
    description: "W"
  },
  {
    type: "n",
    description: "N"
  },
  {
    type: "w",
    description: "W"
  },
  {
    type: "n",
    description: "N"
  },
  {
    type: "w",
    description: "W"
  }
];
var AddTaskTagModal = class extends import_obsidian5.FuzzySuggestModal {
  constructor(app2, editor, taskType) {
    super(app2);
    this.editor = editor;
    this.taskType = taskType;
  }
  getItems() {
    return ALL_TYPES3;
  }
  getItemText(noteType) {
    return noteType.type;
  }
  // Renders each suggestion item.
  renderSuggestion(choosenNoteTypeMatch, el) {
    const noteType = choosenNoteTypeMatch.item;
    el.createEl("div", { text: noteType.type });
    el.createEl("small", { text: noteType.description });
  }
  containsType(line) {
    return ALL_TYPES3.filter((noteType) => line.contains(noteType.type)).length > 0;
  }
  // Perform action on the selected suggestion.
  onChooseItem(choosenNoteType, evt) {
    const cursor = this.editor.getCursor();
    const line = this.editor.getLine(cursor.line);
    this.editor.replaceRange(`${line.charAt(cursor.ch - 1) != " " ? " " : ""}#${choosenNoteType.type}${this.taskType} `, cursor);
    cursor.ch = cursor.ch + 4 + (line.charAt(cursor.ch - 1) != " " ? 1 : 0);
    this.editor.setCursor(cursor);
  }
};

// ThreadsToImagesModal.ts
var import_obsidian6 = require("obsidian");
var ALL_TYPES4 = [
  {
    type: "first-page",
    description: "first page"
  },
  {
    type: "with-header",
    description: "with header"
  },
  {
    type: "without-header",
    description: "without header"
  },
  {
    type: "custom-font-size",
    description: "custom font size"
  }
];
var ThreadsToImagesModal = class extends import_obsidian6.FuzzySuggestModal {
  constructor(app2, threadSegment) {
    super(app2);
    this.threadSegment = threadSegment;
  }
  getItems() {
    return ALL_TYPES4;
  }
  getItemText(noteType) {
    return noteType.type;
  }
  // Renders each suggestion item.
  renderSuggestion(choosenNoteTypeMatch, el) {
    const noteType = choosenNoteTypeMatch.item;
    el.createEl("div", { text: noteType.type });
    el.createEl("small", { text: noteType.description });
  }
  containsType(line) {
    return ALL_TYPES4.filter((noteType) => line.contains(noteType.type)).length > 0;
  }
  // Perform action on the selected suggestion.
  onChooseItem(choosenNoteType, evt) {
    let param = choosenNoteType.type;
    let s = this.threadSegment.toString();
    navigator.clipboard.writeText(this.threadSegment.toString()).then(function() {
      new import_obsidian6.Notice(`Copied
\`\`\`
${s}\`\`\`
to clipboard!`);
      window.open(`shortcuts://run-shortcut?name=Threads%20to%20image&input=text&text=${param}&x-success=obsidian://&x-cancel=obsidian://&x-error=obsidian://`);
    }, function(error) {
      new import_obsidian6.Notice(`error when copy to clipboard!`);
    });
  }
};

// copyOrMoveToNewNoteModal.ts
var import_obsidian7 = require("obsidian");
var ALL_TYPES5 = [
  {
    type: "copy",
    description: "Copy"
  },
  {
    type: "move",
    description: "Move"
  }
];
var CopyOrMoveToNewNoteModal = class extends import_obsidian7.FuzzySuggestModal {
  constructor(app2, editor) {
    super(app2);
    this.editor = editor;
  }
  getItems() {
    return ALL_TYPES5;
  }
  getItemText(noteType) {
    return noteType.type;
  }
  // Renders each suggestion item.
  renderSuggestion(choosenNoteTypeMatch, el) {
    const noteType = choosenNoteTypeMatch.item;
    el.createEl("div", { text: noteType.type });
    el.createEl("small", { text: noteType.description });
  }
  containsType(line) {
    return ALL_TYPES5.filter((noteType) => line.contains(noteType.type)).length > 0;
  }
  // Perform action on the selected suggestion.
  async onChooseItem(choosenOperation, evt) {
    const selection = this.editor.getSelection();
    const line = this.editor.getCursor().line;
    const textToCopyOrMove = selection.length == 0 ? this.editor.getLine(line) : selection;
    const newFileName = "I/United Push.md";
    await this.createOrAppendFile(newFileName, textToCopyOrMove);
    if (choosenOperation.type == "move") {
      if (selection.length != 0) {
        this.editor.replaceSelection("");
      } else {
        let content = "";
        for (let i = 0; i < this.editor.lineCount(); i++) {
          if (i != line) {
            content += this.editor.getLine(i) + "\n";
          }
        }
        this.editor.setValue(content);
      }
    }
    const { vault } = this.app;
    const { workspace } = this.app;
    const mode = this.app.vault.getConfig("defaultViewMode");
    const leaf = workspace.getLeaf(false);
    await leaf.openFile(vault.getAbstractFileByPath(newFileName), { active: true });
  }
  async createOrAppendFile(filePath, note) {
    const { vault } = this.app;
    const fileExists = await vault.adapter.exists(filePath);
    if (fileExists) {
      await this.appendFile(vault, filePath, note);
    } else {
      await vault.create(filePath, "---\ntag: b/n/s\n---\n\n" + note);
    }
    return filePath;
  }
  async appendFile(vault, filePath, note) {
    let existingContent = await vault.adapter.read(filePath);
    if (existingContent.length > 0) {
      existingContent = existingContent + "\r\r";
    }
    await vault.adapter.write(filePath, existingContent + note);
  }
};

// clipboardPasteModal.ts
var import_obsidian8 = require("obsidian");
var ClipboardPasteModal = class extends import_obsidian8.FuzzySuggestModal {
  constructor(app2, editor, clipboardContent) {
    super(app2);
    this.editor = editor;
    this.clipboardContent = clipboardContent;
  }
  getItems() {
    return this.clipboardContent.reverse();
  }
  getItemText(item) {
    return item;
  }
  // Renders each suggestion item.
  renderSuggestion(i, el) {
    const item = i.item;
    el.createEl("div", { text: "\u2022 " + item.replace(/\n/gm, "").substring(0, 100) });
  }
  // Perform action on the selected suggestion.
  onChooseItem(selectedContent, evt) {
    const index = this.clipboardContent.indexOf(selectedContent, 0);
    if (index > -1) {
      this.clipboardContent.splice(index, 1);
    }
    this.clipboardContent.push(selectedContent);
    const selection = this.editor.getSelection();
    const replacedStr = selectedContent;
    if (selection.length != 0) {
      this.editor.replaceSelection(replacedStr);
    } else {
      const cursor = this.editor.getCursor();
      this.editor.replaceRange(replacedStr, cursor);
      cursor.ch = cursor.ch + replacedStr.length;
      this.editor.setCursor(cursor);
    }
  }
};

// openPlaygroundModal.ts
var import_obsidian9 = require("obsidian");
var OpenPlaygroundModal = class extends import_obsidian9.FuzzySuggestModal {
  constructor(app2) {
    super(app2);
    this.removeExistingContent = "Remove playground content";
    this.notRemoveExistingContent = "Not remove existing playground content";
    this.playgroundMd = "I/Playground.md";
    this.options = [this.removeExistingContent, this.notRemoveExistingContent];
  }
  getItems() {
    return this.options.reverse();
  }
  getItemText(item) {
    return item;
  }
  // Renders each suggestion item.
  renderSuggestion(i, el) {
    const item = i.item;
    el.createEl("div", { text: item });
  }
  // Perform action on the selected suggestion.
  async onChooseItem(selectedContent, evt) {
    const choosenOption = selectedContent;
    const { vault } = this.app;
    const { workspace } = this.app;
    const leaf = workspace.getLeaf(false);
    Promise.resolve().then(() => {
      if (vault.getAbstractFileByPath(this.playgroundMd) == null) {
        return vault.create(this.playgroundMd, "");
      }
      return vault.getAbstractFileByPath(this.playgroundMd);
    }).then((tFile) => {
      if (this.removeExistingContent === choosenOption) {
        return vault.modify(tFile, "");
      }
      return Promise.resolve();
    }).then(() => {
      return leaf.openFile(vault.getAbstractFileByPath(this.playgroundMd), { active: true });
    });
  }
};

// threadsToBlogModal.ts
var import_obsidian10 = require("obsidian");
var ThreadsToBlogModal = class extends import_obsidian10.FuzzySuggestModal {
  constructor(app2, editor, view) {
    super(app2);
    this.toNewNote = "To New Note";
    this.toClipboard = "To Clipboard";
    this.options = [this.toNewNote, this.toClipboard];
    this.editor = editor;
    this.view = view;
  }
  getItems() {
    return this.options;
  }
  getItemText(item) {
    return item;
  }
  // Renders each suggestion item.
  renderSuggestion(i, el) {
    const item = i.item;
    el.createEl("div", { text: item });
  }
  // Perform action on the selected suggestion.
  onChooseItem(selectedContent, evt) {
    const choosenOption = selectedContent;
    const lineCount = this.editor.lineCount();
    let tagLineNumber = null;
    let metadataLineCount = 0;
    let text = "";
    for (let i = 0; i < lineCount; i++) {
      let line = this.editor.getLine(i);
      if (!line.trim().startsWith("%%") || !line.trim().endsWith("%%")) {
        let modifiedLine = line.replace("\u{1F9F5} ", "# ").replace("\u3010", "").replace("\u3011", "").replace("\u{1F447}", "");
        if (modifiedLine == "---") {
          metadataLineCount++;
          if (metadataLineCount > 2) {
            if (metadataLineCount == 3) {
              modifiedLine = modifiedLine.replace("---", "");
            } else if (metadataLineCount == 4) {
              modifiedLine = modifiedLine.replace("---", "<!--more-->\n\n**\u76EE\u9304\uFF1A**\n\n* Table of Content\n{:toc}\n\n## .");
            } else {
              modifiedLine = modifiedLine.replace("---", "## .");
            }
          }
        }
        if (metadataLineCount == 1 || metadataLineCount == 2) {
          modifiedLine = modifiedLine.replace("c/t/p", "c/b/d");
          modifiedLine = modifiedLine.replace("c/t/t", "c/b/d");
          modifiedLine = modifiedLine.replace("c/t/r", "c/b/d");
        }
        if (/^!\[.*\]\(.*\)/.test(modifiedLine.trim())) {
          if (!modifiedLine.contains("https://roulesophy.github.io")) {
            modifiedLine = modifiedLine.replace(/!\[([^\[\]\(\)]+)\]\(([^\[\]\(\)]+)\)/g, "$2");
          }
        }
        text = text + modifiedLine + "\n";
      }
    }
    text += `

---

#nl generate summary for meta description below:



`;
    text += `---

## References:

- Thread post 1: [[${this.view.file.basename}]]
- Blog link: 
`;
    const { vault } = this.app;
    if (this.toNewNote === choosenOption) {
      const { vault: vault2 } = this.app;
      const path = this.view.file.path;
      const newPath = path.match(/.\/Threads \d\d\d\d\d\d\d\d/) ? path.replace(/(.\/)Threads \d\d\d\d\d\d\d\d/, "$1Blog ") : path.replace(/(.\/)/, "$1Blog ");
      const { workspace } = this.app;
      const leaf = workspace.getLeaf(false);
      Promise.resolve().then(() => {
        return vault2.adapter.exists(newPath);
      }).then((fileExists) => {
        if (fileExists) {
          new import_obsidian10.Notice(`Will not proceed. Blog post "${newPath}" already exist.`);
          return Promise.reject("Blog post exist");
        }
        return vault2.create(newPath, text);
      }).then(
        (tFile) => {
          return leaf.openFile(tFile, { active: true });
        },
        (rejectReason) => {
        }
      );
    }
    if (this.toClipboard === choosenOption) {
      navigator.clipboard.writeText(text).then(function() {
        new import_obsidian10.Notice(`Copied blog content to clipboard!`);
      }, function(error) {
        new import_obsidian10.Notice(`error when copy to clipboard!`);
      });
    }
  }
};

// clipboardRemovalModal.ts
var import_obsidian11 = require("obsidian");
var ClipboardRemovalModal = class extends import_obsidian11.FuzzySuggestModal {
  constructor(app2, editor, clipboardContent) {
    super(app2);
    this.REMOVE_ALL = "REMOVE ALL";
    this.editor = editor;
    this.clipboardContent = clipboardContent;
  }
  getItems() {
    return [...[this.REMOVE_ALL], ...this.clipboardContent.reverse()];
  }
  getItemText(item) {
    return item;
  }
  // Renders each suggestion item.
  renderSuggestion(i, el) {
    const item = i.item;
    el.createEl("div", { text: "\u2022 " + item.replace(/\n/gm, "").substring(0, 100) });
  }
  // Perform action on the selected suggestion.
  onChooseItem(selectedContent, evt) {
    if (selectedContent === this.REMOVE_ALL) {
      new import_obsidian11.Notice("haha");
      while (this.clipboardContent.length > 0) {
        this.clipboardContent.pop();
      }
    } else {
      const index = this.clipboardContent.indexOf(selectedContent, 0);
      if (index > -1) {
        this.clipboardContent.splice(index, 1);
      }
    }
  }
};

// tagSearchModal.ts
var import_obsidian13 = require("obsidian");

// selfutil/getAllNoteTags.ts
var import_obsidian12 = require("obsidian");
function getAllNoteTags(app2) {
  return getAllTagsWithFilter(app2, (tag) => /^#[a-z]\/[a-z]\/[a-z]$/.test(tag));
}
function getAllTagsWithFilter(app2, filter) {
  var _a;
  const files = app2.vault.getMarkdownFiles();
  const items = [];
  for (const file of files) {
    const cache = app2.metadataCache.getCache(file.path);
    if (cache === null) {
      continue;
    }
    (_a = (0, import_obsidian12.getAllTags)(cache)) == null ? void 0 : _a.forEach((tag) => {
      if (filter == null || filter(tag)) {
        const layerOfTag = getLayersOfTag(tag);
        for (const layer of layerOfTag) {
          if (!items.includes(layer)) {
            items.push(layer);
          }
        }
      }
    });
  }
  return items.sort((a, b) => a.localeCompare(b));
}
function getLayersOfTag(tag) {
  const layers = [];
  const tagSplit = tag.split("/");
  let tagLayer = tagSplit[0];
  layers.push(tagLayer);
  for (const tagPart of tagSplit.slice(1, tagSplit.length)) {
    tagLayer += "/" + tagPart;
    layers.push(tagLayer);
  }
  return layers;
}

// tagSearchModal.ts
var TagSearchModal = class extends import_obsidian13.FuzzySuggestModal {
  constructor(app2, search) {
    super(app2);
    this.app = app2;
    this.search = search;
    this.search = search;
  }
  getItems() {
    return getAllTagsWithFilter(this.app);
  }
  getItemText(item) {
    return item;
  }
  onChooseItem(item, evt) {
    const defaultTagSearchString = `tag:${item}`;
    this.search.openGlobalSearch(defaultTagSearchString);
  }
};

// main.ts
var import_obsidian21 = require("obsidian");
var import_moment = __toESM(require_moment());

// addTextToNotesFromSpecificTagModal.ts
var import_obsidian16 = require("obsidian");

// selfutil/addlinktonotes.ts
var import_obsidian14 = require("obsidian");
function addTextToNotes(textToAdd, toPath, app2, insertFromBeginning) {
  const vault = this.app.vault;
  const workspace = this.app.workspace;
  const leaf = workspace.getLeaf(false);
  const tFile = vault.getAbstractFileByPath(toPath);
  const link = textToAdd;
  Promise.resolve().then(() => {
    return leaf.openFile(tFile, { active: true });
  }).then(() => {
    const editor = app2.workspace.getActiveViewOfType(import_obsidian14.TextFileView);
    const value = editor == null ? void 0 : editor.getViewData();
    if (editor == null || value == null) {
      const errorReason = `editor or value ${toPath} not exist. Aborting...`;
      return Promise.reject(errorReason);
    }
    if (value.includes(link)) {
      const errorReason = `Link ${link} already exists in ${toPath}!`;
      new import_obsidian14.Notice(errorReason);
    } else {
      const newValue = insertFromBeginning ? getNoteValueInsertingTextFromStartOfNotes(value, link) : getNoteValueInsertingTextFromEndOfNotes(value, link);
      editor.setViewData(newValue, false);
      new import_obsidian14.Notice(`Added link to ${insertFromBeginning ? "beginning" : "end"} of ${toPath}!`);
    }
    return Promise.resolve();
  }).catch((reason) => {
    new import_obsidian14.Notice(reason);
  });
}
function getNoteValueInsertingTextFromStartOfNotes(value, text) {
  const frontMatterRegex = /^(---\n[\s\S]*?\n---\n)/gm;
  if (frontMatterRegex.test(value)) {
    return value.replace(frontMatterRegex, "$1" + text + "\n");
  } else {
    return text + "\n" + value;
  }
}
function getNoteValueInsertingTextFromEndOfNotes(value, text) {
  return value + "\n" + text;
}

// selfutil/findNotesFromTag.ts
var import_obsidian15 = require("obsidian");
function filesWhereTagIsUsed(findTag) {
  const filesList = [];
  for (const filePath of locationsWhereTagIsUsed(findTag)) {
    if (!filesList.includes(filePath)) {
      filesList.push(filePath);
    }
  }
  return filesList.sort((a, b) => a.localeCompare(b));
}
function locationsWhereTagIsUsed(findTag) {
  const oApp = app;
  const results = [];
  for (const file of oApp.vault.getMarkdownFiles()) {
    const cache = oApp.metadataCache.getFileCache(file);
    if (cache != null && cache.tags) {
      for (const tag of cache.tags) {
        if (findTag === tag.tag) {
          results.push(file.path);
        }
      }
    }
    if (cache != null && cache.frontmatter) {
      const fmtags = ((0, import_obsidian15.parseFrontMatterTags)(cache.frontmatter) || []).filter((tag) => findTag == tag || tag.startsWith(findTag + "/"));
      if (fmtags.length) {
        results.push(file.path);
      }
      const fmtags2 = ((0, import_obsidian15.parseFrontMatterAliases)(cache.frontmatter) || []).filter((tag) => findTag == tag || tag.startsWith(findTag + "/"));
      if (fmtags2.length) {
        results.push(file.path);
      }
    }
  }
  return results;
}

// addTextToNotesFromSpecificTagModal.ts
var BACK_TO_SELECT_TAG = "Back to select tag";
var AddTextToNotesFromSpecificTagModal = class extends import_obsidian16.FuzzySuggestModal {
  constructor(app2, linkToAdd, tagToFind, description, insertFromBeginning, postAction) {
    super(app2);
    this.linkToAdd = linkToAdd;
    this.tagToFind = tagToFind;
    this.insertFromBeginning = insertFromBeginning;
    this.description = description;
    this.postAction = postAction;
    this.setInstructions([
      {
        command: "",
        purpose: `Which notes with tag ${tagToFind} do you want to ${description} to?`
      }
    ]);
  }
  getItems() {
    return [...[BACK_TO_SELECT_TAG], ...filesWhereTagIsUsed(this.tagToFind)];
  }
  getItemText(path) {
    return path;
  }
  // Renders each suggestion item.
  renderSuggestion(path, el) {
    const pathItem = path.item;
    el.createEl("div", { text: pathItem });
  }
  // Perform action on the selected suggestion.
  onChooseItem(path, evt) {
    if (BACK_TO_SELECT_TAG == path) {
      new AddTextToNotesModal(this.app, this.linkToAdd, this.description, this.insertFromBeginning, this.postAction).open();
    } else {
      addTextToNotes(this.linkToAdd, path, this.app, this.insertFromBeginning);
      this.postAction();
    }
  }
};

// addTextToNotesModal.ts
var import_obsidian17 = require("obsidian");

// selfutil/getRecentNotes.ts
function getRecentNotes(app2, limit) {
  const recentViewedNotes = app2.workspace.getLastOpenFiles();
  return recentViewedNotes.slice(0, Math.min(limit, recentViewedNotes.length));
}
function getAllNotes(app2) {
  const files = app2.vault.getMarkdownFiles();
  const allNotes = files.map((file) => file.path);
  return allNotes;
}

// addTextToNotesModal.ts
var AddTextToNotesModal = class extends import_obsidian17.FuzzySuggestModal {
  constructor(app2, linkToAdd, description, insertFromBeginning, postAction) {
    super(app2);
    this.linkToAdd = linkToAdd;
    this.description = description;
    this.insertFromBeginning = insertFromBeginning;
    this.postAction = postAction;
    this.setInstructions([
      {
        command: "",
        purpose: `Which notes with tags do you want to ${description} to?`
      }
    ]);
  }
  getItems() {
    return [...["I/Inbox.md"], ...getRecentNotes(this.app, 7), ...getAllNoteTags(this.app), ...getAllNotes(this.app)];
  }
  getItemText(value) {
    return value;
  }
  // Renders each suggestion item.
  renderSuggestion(value, el) {
    const item = value.item;
    el.createEl("div", { text: item });
  }
  // Perform action on the selected suggestion.
  async onChooseItem(choosenValue, evt) {
    if (choosenValue.startsWith("#")) {
      new AddTextToNotesFromSpecificTagModal(this.app, this.linkToAdd, choosenValue, this.description, this.insertFromBeginning, this.postAction).open();
    } else {
      addTextToNotes(this.linkToAdd, choosenValue, this.app, this.insertFromBeginning);
      this.postAction();
    }
  }
};

// navigateToNoteFromSpecificTagModal.ts
var import_obsidian18 = require("obsidian");
var BACK_TO_SELECT_TAG2 = "Back to select tag";
var NavigateToNoteFromSpecificTagModal = class extends import_obsidian18.FuzzySuggestModal {
  constructor(app2, tagToFind) {
    super(app2);
    this.tagToFind = tagToFind;
    this.setInstructions([
      {
        command: "",
        purpose: `Which notes with tag ${tagToFind} do you want to navigate to?`
      }
    ]);
  }
  getItems() {
    return [...[BACK_TO_SELECT_TAG2], ...filesWhereTagIsUsed(this.tagToFind)];
  }
  getItemText(path) {
    return path;
  }
  // Renders each suggestion item.
  renderSuggestion(path, el) {
    const pathItem = path.item;
    el.createEl("div", { text: pathItem });
  }
  // Perform action on the selected suggestion.
  onChooseItem(path, evt) {
    if (BACK_TO_SELECT_TAG2 == path) {
      new NavigateToNoteFromTagModal(this.app).open();
    } else {
      const { vault, workspace } = this.app;
      const leaf = workspace.getLeaf(false);
      Promise.resolve().then(() => {
        return leaf.openFile(vault.getAbstractFileByPath(path), { active: true });
      });
    }
  }
};

// navigateToNoteFromTagModal.ts
var import_obsidian19 = require("obsidian");
var NavigateToNoteFromTagModal = class extends import_obsidian19.FuzzySuggestModal {
  constructor(app2) {
    super(app2);
    this.setInstructions([
      {
        command: "",
        purpose: "Which notes with tags do you want to navigate to?"
      }
    ]);
  }
  getItems() {
    return [...getRecentNotes(this.app, 7), ...getAllTagsWithFilter(this.app), ...getAllNotes(this.app)];
  }
  getItemText(value) {
    return value;
  }
  // Renders each suggestion item.
  renderSuggestion(value, el) {
    const item = value.item;
    el.createEl("div", { text: item });
  }
  // Perform action on the selected suggestion.
  async onChooseItem(choosenValue, evt) {
    if (choosenValue.startsWith("#")) {
      new NavigateToNoteFromSpecificTagModal(this.app, choosenValue).open();
    } else {
      const { vault, workspace } = this.app;
      const leaf = workspace.getLeaf(false);
      Promise.resolve().then(() => {
        return leaf.openFile(vault.getAbstractFileByPath(choosenValue), { active: true });
      });
    }
  }
};

// selfutil/extractSelection.ts
function exportCurrentSelection(editor) {
  let text = "";
  const listSelections = editor.listSelections();
  listSelections.forEach((listSelection) => {
    const a = listSelection.head.line;
    const b = listSelection.anchor.line;
    const fromLineNum = b > a ? a : b;
    const toLineNum = b > a ? b : a;
    for (let i = fromLineNum; i <= toLineNum; i++) {
      const line = editor.getLine(i);
      text += line + "\n";
    }
  });
  return text.replace(/\n$/, "");
}
function getCurrentSelectionLineNumber(editor) {
  let text = "";
  let fromLineNum = 0;
  let fromCh = 0;
  let toLineNum = 0;
  let toCh = 0;
  const listSelections = editor.listSelections();
  listSelections.forEach((listSelection) => {
    const a = listSelection.head.line;
    const ach = listSelection.head.ch;
    const b = listSelection.anchor.line;
    const bch = listSelection.anchor.ch;
    fromLineNum = b > a ? a : b;
    fromCh = b > a ? ach : bch;
    toLineNum = b > a ? b : a;
    toCh = b > a ? bch : ach;
  });
  return { fromLineNum, fromCh, toLineNum, toCh };
}

// main.ts
var DEFAULT_SETTINGS = {
  mySetting: "default"
};
var clipboardHistory = [];
var skipFrontMatterField = [
  "freetimetask: ",
  "expectedtime: ",
  "mode: ",
  "days: ",
  "showheaderfooter: ",
  "showstate: ",
  "sortsubpagefilter: ",
  "throughttree: ",
  "urgent: ",
  "displayas: ",
  "startdate: ",
  "readwritemode: ",
  "showChandlerNow: ",
  "deepwork: ",
  "expectedtime: ",
  "parsedate: ",
  "tidscope: ",
  "inserttodoaction: ",
  "optional: ",
  "replaceto: ",
  "backuptiddler: ",
  "deadline: ",
  "caption: ",
  "collection: ",
  "library: ",
  "library_version: ",
  "dummy: ",
  "tidName: ",
  "chronicledate: ",
  "eventdate: ",
  "dailyhighlight: ",
  "displaycardmode: ",
  "displaymode: ",
  "numcol: ",
  "dateyyyymmdd: ",
  "graphdisplaymode: ",
  "maxdepth: ",
  "journaldate: ",
  "thisBillDate: ",
  "lastBillDate: ",
  "roottiddler: ",
  "year: ",
  "to: ",
  "tidtemplate: ",
  "tiddlername: ",
  "theme: ",
  "tagvalue: ",
  "subtasknum: ",
  "removetagvalue: ",
  "recurringeventstartdate: ",
  "recurringeventenddate: ",
  "pluginname: ",
  "pid: ",
  "macroname: ",
  "limit: ",
  "keyword: ",
  "keywordtmp: ",
  "from: ",
  "deprecatereason: ",
  "deepwo: ",
  "color: ",
  "row: ",
  "col: ",
  "bookmarked: ",
  "blockingreminderdate: ",
  "backup: "
];
var MyPlugin = class extends import_obsidian20.Plugin {
  async onload() {
    await this.loadSettings();
    if (navigator.clipboard) {
      document.addEventListener("copy", (event) => {
        var _a;
        const copiedText = (_a = event.clipboardData) == null ? void 0 : _a.getData("text/plain");
        if (copiedText != null) {
          this.addToClipboardHistory(copiedText);
        }
      });
      document.addEventListener("cut", (event) => {
        var _a;
        const copiedText = (_a = event.clipboardData) == null ? void 0 : _a.getData("text/plain");
        if (copiedText != null) {
          this.addToClipboardHistory(copiedText);
        }
      });
    } else {
      console.log("Clipboard API is not supported in this browser.");
    }
    ["n", "l", "w", "d", "a", "1", "2", "3", "4", "5", "6", "7"].forEach((t) => {
      this.addActionIcon(t);
      this.addActionCommand(t);
    });
    ["t", "m", "e"].forEach((t) => {
      this.addActionIcon(t);
      this.addFollowUpCommand(t);
    });
    ["n", "w"].forEach((t) => {
      this.addNewLaterActionIcon(t);
      this.addNewLaterAction(t);
    });
    this.addCommand({
      id: "obsidian-remove-clipboard-content",
      name: "RC Obsidian Remove Clipboard Content",
      icon: "obsidian-remove-clipboard-content",
      editorCallback: (editor, view) => {
        new ClipboardRemovalModal(this.app, editor, clipboardHistory).open();
      }
    });
    this.addCommand({
      id: "open-tag-search",
      name: "Open tag search",
      icon: "hash",
      callback: () => {
        const searchPlugin = this.app.internalPlugins.getPluginById("global-search");
        const search = searchPlugin && searchPlugin.instance;
        if (searchPlugin && searchPlugin.instance) {
          new TagSearchModal(this.app, search).open();
        } else {
          new import_obsidian20.Notice("Please enable the search core plugin!");
        }
      },
      hotkeys: [
        {
          modifiers: [`Ctrl`, `Meta`, `Shift`],
          key: `s`
        },
        {
          modifiers: [`Ctrl`, `Alt`, `Shift`],
          key: `s`
        }
      ]
    });
    this.addObsidianIcon("obsidian-paste", "\u2318V");
    this.addCommand({
      id: "obsidian-paste",
      name: "Obsidian Paste",
      icon: "obsidian-paste",
      editorCallback: (editor, view) => {
        new ClipboardPasteModal(this.app, editor, clipboardHistory).open();
      },
      hotkeys: [
        {
          modifiers: [`Meta`, `Shift`],
          key: `v`
        }
      ]
    });
    this.addObsidianIcon("update-note-type-icon", "NT");
    this.addCommand({
      id: "update-note-type",
      name: "Update Note Type",
      icon: `update-note-type-icon`,
      editorCallback: (editor, view) => {
        new UpdateNoteTypeModal(this.app, editor, view.file).open();
      },
      hotkeys: [
        {
          modifiers: [`Ctrl`, `Meta`, `Shift`],
          key: `c`
        },
        {
          modifiers: [`Ctrl`, `Alt`, `Shift`],
          key: `c`
        }
      ]
    });
    this.addCommand({
      id: "open-recent-days-schedule-with-updated-schedule",
      name: "OR Open Recent Days Updated Schedule",
      icon: "open-recent-day-schedule-icon",
      callback: async () => {
        const { vault } = this.app;
        const scheduleNoteWithoutMd = "D/Scheduling";
        const scheduleNote = `${scheduleNoteWithoutMd}.md`;
        if (vault.getAbstractFileByPath(scheduleNote) == null) {
          await vault.create(scheduleNote, "");
        }
        let noteContent = "";
        Array.from(Array(7).keys()).forEach((i) => noteContent += this.getQueryDateString(i, scheduleNoteWithoutMd));
        vault.modify(vault.getAbstractFileByPath(scheduleNote), noteContent);
        this.addActionNoteContent(vault, "D", "Query W now actions", "Weekly Schedule W", "w");
        this.addActionNoteContent(vault, "D", "Query N now actions", "Weekly Schedule N", "n");
        this.add3DaysActionNoteContent(vault);
        new import_obsidian20.Notice("Updated schedule");
        const { workspace } = this.app;
        const dashboardCanvas = "D/Query Schedule and Actions next 3 days.md";
        const mode = this.app.vault.getConfig("defaultViewMode");
        const leaf = workspace.getLeaf(false);
        await leaf.openFile(vault.getAbstractFileByPath(dashboardCanvas), {
          active: true
          /* mode */
        });
      }
    });
    this.addObsidianIcon("update-scheduling-icon", "US");
    this.addCommand({
      id: "update-scheduling",
      name: "Update Scheduling",
      icon: "update-scheduling-icon",
      callback: async () => {
        const { vault } = this.app;
        const scheduleNoteWithoutMd = "D/Scheduling";
        const scheduleNote = `${scheduleNoteWithoutMd}.md`;
        if (vault.getAbstractFileByPath(scheduleNote) == null) {
          await vault.create(scheduleNote, "");
        }
        let noteContent = "";
        Array.from(Array(7).keys()).forEach((i) => noteContent += this.getQueryDateString(i, scheduleNoteWithoutMd));
        vault.modify(vault.getAbstractFileByPath(scheduleNote), noteContent);
        this.addActionNoteContent(vault, "D", "Query W now actions", "Weekly Schedule W", "w");
        this.addActionNoteContent(vault, "D", "Query N now actions", "Weekly Schedule N", "n");
        this.add3DaysActionNoteContent(vault);
        new import_obsidian20.Notice("Updated schedule");
      }
      /*,
      hotkeys: [
      	{
      		modifiers: [`Ctrl`, `Meta`, `Shift`],
      		key: `u`,
      	},
      	{
      		modifiers: [`Ctrl`, `Alt`, `Shift`],
      		key: `u`,
      	},
      ]*/
    });
    this.addObsidianIcon("open-recent-day-schedule-icon", "OR");
    this.addCommand({
      id: "open-recent-days-schedule",
      name: "Open Recent Days Schedule",
      icon: "open-recent-day-schedule-icon",
      callback: async () => {
        const { vault, workspace } = this.app;
        const dashboardCanvas = "D/Query Schedule and Actions next 3 days.md";
        const leaf = workspace.getLeaf(false);
        await leaf.openFile(vault.getAbstractFileByPath(dashboardCanvas), { active: true });
      }
    });
    this.addObsidianIcon("open-inbox-icon", "OI");
    this.addCommand({
      id: "open-inbox",
      name: "OI Open Inbox",
      icon: "open-inbox-icon",
      callback: async () => {
        const { vault, workspace } = this.app;
        const inboxMd = "I/Inbox.md";
        const leaf = workspace.getLeaf(false);
        await leaf.openFile(vault.getAbstractFileByPath(inboxMd), { active: true });
      }
    });
    this.addObsidianIcon("open-playground-icon", "OP");
    this.addCommand({
      id: "open-playground",
      name: "OP Open Playground",
      icon: "open-playground-icon",
      callback: async () => {
        new OpenPlaygroundModal(this.app).open();
      },
      hotkeys: [
        {
          modifiers: [`Ctrl`, `Meta`, `Shift`],
          key: `p`
        },
        {
          modifiers: [`Ctrl`, `Alt`, `Shift`],
          key: `p`
        }
      ]
    });
    this.addObsidianIcon("open-braindump-icon", "OB");
    this.addCommand({
      id: "open-braindump",
      name: "OB Open BrainDump",
      icon: "open-braindump-icon",
      callback: async () => {
        const { vault, workspace } = this.app;
        const inboxMd = "I/Brain Dump.md";
        const leaf = workspace.getLeaf(false);
        await leaf.openFile(vault.getAbstractFileByPath(inboxMd), { active: true });
      }
    });
    this.addObsidianIcon("format-all-notes-custom", "FA");
    this.addCommand({
      id: "format-all-notes-custom",
      name: "FA Format All Notes (Custom usage)",
      icon: `format-all-notes-custom`,
      callback: async () => {
        const vault = this.app.vault;
        let startCount = 0;
        let finishedCount = 0;
        const files = vault.getMarkdownFiles();
        new import_obsidian20.Notice("all=" + files.length);
        console.log("all=" + files.length);
        for (const file of files) {
          console.log("s: " + startCount);
          vault.read(file).then((content) => {
            const modifiedValue = this.tidyUpFrontMatterOnValue(content);
            return vault.modify(file, modifiedValue);
          }).then(() => {
            console.log("f: " + finishedCount);
            finishedCount++;
            if (finishedCount == files.length) {
              console.log("finished");
              new import_obsidian20.Notice("finished");
            }
          });
          startCount++;
        }
      },
      hotkeys: [
        {
          modifiers: [`Ctrl`, `Meta`, `Shift`],
          key: `1`
        },
        {
          modifiers: [`Ctrl`, `Alt`, `Shift`],
          key: `1`
        }
      ]
    });
    this.addObsidianIcon("format-notes-custom", "FN");
    this.addCommand({
      id: "format-notes-custom",
      name: "FN Format Notes (Custom usage)",
      icon: `format-notes-custom`,
      editorCallback: (editor, view) => {
        this.tidyUpFrontMatteronEditor(editor);
      },
      hotkeys: [
        {
          modifiers: [`Ctrl`, `Meta`, `Shift`],
          key: `2`
        },
        {
          modifiers: [`Ctrl`, `Alt`, `Shift`],
          key: `2`
        }
      ]
    });
    this.addObsidianIcon("tw-get-parent-link", "[]");
    this.addCommand({
      id: "tw-get-parent-link",
      name: "tw-get-parent-link",
      icon: `tw-get-parent-link`,
      editorCallback: (editor, view) => {
        const cursor = editor.getCursor();
        const line = cursor.line;
        const ch = cursor.ch;
        const lineContent = editor.getLine(line);
        if (/^parent\d+: /.test(lineContent) || /^\t+- parent\d+: /.test(lineContent)) {
          const parentLink = lineContent.replace(/^parent\d+: /, "").replace(/^\t+- parent\d+: /, "").replace(/"/g, "").replace(/\[\[/, "").replace(/\]\]/, "");
          navigator.clipboard.writeText(parentLink).then(() => {
            editor.replaceRange("", { line, ch: 0 }, { line, ch: lineContent.length });
          });
        }
      },
      hotkeys: [
        {
          modifiers: [`Ctrl`, `Meta`, `Shift`],
          key: `7`
        },
        {
          modifiers: [`Ctrl`, `Alt`, `Shift`],
          key: `7`
        }
      ]
    });
    this.addObsidianIcon("tw-task", "--");
    this.addCommand({
      id: "tw-task",
      name: "TT TW Task",
      icon: `tw-task`,
      editorCallback: (editor, view) => {
        const checkboxMap = /* @__PURE__ */ new Map();
        const lineCount = editor.lineCount();
        let fm = "";
        let c = "";
        let text = "";
        let h3Count = 0;
        let content = "";
        let taskTag = "";
        for (let i = 0; i < lineCount; i++) {
          const line = editor.getLine(i);
          if (h3Count == 0) {
            content += line + "\n";
          } else if (h3Count == 1) {
            if (line.startsWith("title: ")) {
            } else if (line.startsWith("tagsss: ")) {
              taskTag = "a/";
              if (/ N /.test(line) || / N$/.test(line)) {
                taskTag += "n/";
              }
              if (/ W /.test(line) || / W$/.test(line)) {
                taskTag += "w/";
              }
              if (/ now /.test(line) || / now$/.test(line)) {
                taskTag += "n";
              }
              if (/ later /.test(line) || / later$/.test(line)) {
                taskTag += "l";
              }
              if (/ waiting /.test(line) || / waiting$/.test(line)) {
                taskTag += "w";
              }
              if (/ done /.test(line) || / done$/.test(line)) {
                taskTag += "d";
              }
              if (/ archive /.test(line) || / archine$/.test(line)) {
                taskTag += "a";
              }
              if (taskTag.length == 5) {
                fm += "tag: " + taskTag + "\n";
              } else {
                new import_obsidian20.Notice("error on setting action tag");
                fm += line + "\n";
              }
            } else {
              fm += line + "\n";
            }
          }
          if (h3Count >= 2) {
            let modifiedLine = line;
            c += modifiedLine + "\n";
          }
          if (line === "---") {
            h3Count++;
          }
        }
        text += content;
        if (fm.length > 0) {
          text += fm;
        }
        text += c;
        text = text.replace(/^---\n---\n/m, "").replace(/\n$/, "");
        editor.setValue(text);
      },
      hotkeys: [
        {
          modifiers: [`Ctrl`, `Meta`, `Shift`],
          key: `7`
        },
        {
          modifiers: [`Ctrl`, `Alt`, `Shift`],
          key: `7`
        }
      ]
    });
    this.addObsidianIcon("note-to-tree-list", "**");
    this.addCommand({
      id: "note-to-tree-list",
      name: "NT Note to Tree List",
      icon: `note-to-tree-list`,
      editorCallback: (editor, view) => {
        const checkboxMap = /* @__PURE__ */ new Map();
        const lineCount = editor.lineCount();
        if (editor.getValue().startsWith("- " + view.file.basename + "\n")) {
          const filename = view.file.basename;
          let text = "";
          for (let i = 0; i < lineCount; i++) {
            const line = editor.getLine(i);
            if (line.trim().length != 0) {
              if (!/^\t*- $/.test(line) && !/^\t*\d+\. $/.test(line)) {
                let modLine = line.replace(`${filename} _ `, "");
                if (line !== `- ${view.file.basename}` && /^- /.test(line)) {
                  modLine = "	" + modLine;
                }
                text += modLine + "\n";
              }
            }
          }
          editor.setValue(text.replace(/\n$/m, ""));
        } else {
          let text = "- ";
          let h3Count = 0;
          let actionTag = "";
          let content = "";
          for (let i = 0; i < lineCount; i++) {
            const line = editor.getLine(i);
            if (h3Count == 0) {
              if (line.trim().length != 0 && line != "---") {
                let modifiedLine = line;
                for (let i2 = 0; i2 < 9; i2++) {
                  modifiedLine = modifiedLine.replace(/^    /, "	");
                }
                modifiedLine = modifiedLine.replace(/^(\t*)\*\s/, "$1- ");
                modifiedLine = /^\t*- /.test(modifiedLine) || /^\t*\d+\. /.test(modifiedLine) ? "	" + modifiedLine : "	- " + modifiedLine;
                content += "\n" + modifiedLine;
              }
            } else if (h3Count == 1) {
              if (line === "---" || this.shouldSkipFrontMatter(line) || line.startsWith("title: ")) {
              } else if (line.startsWith("tagsss: ")) {
                if (/ N /.test(line) || / N$/.test(line)) {
                  actionTag = "n";
                }
                if (/ W /.test(line) || / W$/.test(line)) {
                  actionTag = "w";
                }
                if (/ now /.test(line) || / now$/.test(line)) {
                  actionTag += "n";
                }
                if (/ later /.test(line) || / later$/.test(line)) {
                  actionTag += "l";
                }
                if (/ waiting /.test(line) || / waiting$/.test(line)) {
                  actionTag += "w";
                }
                if (/ done /.test(line) || / done$/.test(line)) {
                  actionTag += "d";
                }
                if (/ archive /.test(line) || / archine$/.test(line)) {
                  actionTag += "w";
                }
                if (actionTag.length == 2) {
                  actionTag = "#" + actionTag + " ";
                } else if (actionTag.length == 1) {
                  new import_obsidian20.Notice("error on setting action tag");
                }
              } else if (line.startsWith("checkboxbytime_")) {
                const keyValueArray = line.split(":").map((item) => item.trim());
                if (keyValueArray.length === 2) {
                  const key = keyValueArray[0];
                  const value = keyValueArray[1];
                  const splitArray = key.split("_");
                  const modifiedKey = `<<checkboxByTime "${splitArray[1]}">>`;
                  checkboxMap.set(modifiedKey, value === "open" ? "[x]" : "[ ]");
                }
              } else {
                if (line.trim().length != 0) {
                  let modifiedLine = line;
                  for (let i2 = 0; i2 < 9; i2++) {
                    modifiedLine = modifiedLine.replace(/^    /, "	");
                  }
                  modifiedLine = modifiedLine.replace(/^(\t*)\*\s/, "$1- ");
                  modifiedLine = /^\t*- /.test(modifiedLine) || /^\t*\d+\. /.test(modifiedLine) ? "	" + modifiedLine : "	- " + modifiedLine;
                  content += "\n" + modifiedLine;
                }
              }
            }
            if (h3Count >= 2 && line.trim().length != 0) {
              let modifiedLine = line === "[ ] " ? "" : line;
              if (modifiedLine.trim().length != 0) {
                for (let i2 = 0; i2 < 9; i2++) {
                  modifiedLine = modifiedLine.replace(/^    /, "	");
                }
                modifiedLine = modifiedLine.replace(/^(\t*)\*\s/, "$1- ");
                modifiedLine = /^\t*- /.test(modifiedLine) || /^\t*\d+\. /.test(modifiedLine) ? "	" + modifiedLine : "	- " + modifiedLine;
                for (const [key, value] of checkboxMap) {
                  modifiedLine = modifiedLine.replace(new RegExp(key, "g"), value);
                }
                modifiedLine = modifiedLine.replace(/<<checkboxByTime "[A-Za-z0-9_]+">>/g, "[ ]");
                text += "\n" + modifiedLine;
              }
            }
            if (line === "---") {
              let beforeH3 = h3Count;
              h3Count++;
              if (beforeH3 == 1 && h3Count == 2) {
                text += actionTag + view.file.basename;
              }
            }
          }
          if (h3Count < 2) {
            text += view.file.basename;
          }
          text += content;
          editor.setValue(text);
        }
      },
      hotkeys: [
        {
          modifiers: [`Ctrl`, `Meta`, `Shift`],
          key: `8`
        },
        {
          modifiers: [`Ctrl`, `Alt`, `Shift`],
          key: `8`
        }
      ]
    });
    this.addObsidianIcon("threads-to-blog-icon", "TB");
    this.addCommand({
      id: "threads-to-blog",
      name: "TB Threads as pre Blog format to Clipboard",
      icon: `threads-to-blog-icon`,
      editorCallback: (editor, view) => {
        new ThreadsToBlogModal(this.app, editor, view).open();
      }
    });
    this.addObsidianIcon("add-comment-tag-icon", "CT");
    this.addCommand({
      id: "add-comment-tag",
      name: "CT Add Comment Tag",
      icon: `add-comment-tag-icon`,
      editorCallback: (editor, view) => {
        new AddFootnoteTagModal(this.app, editor).open();
      },
      hotkeys: [
        {
          modifiers: [`Ctrl`, `Meta`, `Shift`],
          key: `z`
        },
        {
          modifiers: [`Ctrl`, `Alt`, `Shift`],
          key: `z`
        }
      ]
    });
    this.addObsidianIcon("action-tag-count-icon", "CA");
    this.addCommand({
      id: "action-tag-count-icon",
      name: "CA Count Action Tag",
      icon: `action-tag-count-icon`,
      editorCallback: (editor, view) => {
        const tags = ["nn", "nl", "nw", "n1", "n2", "n3", "n4", "n5", "n6", "n7", "wn", "wl", "ww", "w1", "w2", "w3", "w4", "w5", "w6", "w7"];
        const matches = [];
        const lineNum = editor.lineCount();
        for (let i = 0; i < lineNum; i++) {
          const line = editor.getLine(i);
          const match = tags.some((tag) => new RegExp(`#${tag} `, "g").test(line) || new RegExp(` #${tag}`, "g").test(line));
          if (match) {
            matches.push(`Line ${i}:
${line.trim()}`);
          }
        }
        const trimmedAndJoinedString = matches.join("\n\n");
        const tasks = matches.length > 0 ? `
Tasks:

${trimmedAndJoinedString}` : ``;
        new import_obsidian20.Notice(`There are ${matches.length} outstanding actions in this notes${tasks}`);
      }
    });
    this.addObsidianIcon("toggle-n-w-task", "#=");
    this.addCommand({
      id: `toggle-n-w-task`,
      name: `Toggle N W Task`,
      icon: `toggle-n-w-task`,
      editorCallback: (editor, view) => {
        console.log(editor.getSelection());
        const cursor = editor.getCursor();
        const lineNumber = editor.getCursor().line;
        const line = editor.getLine(lineNumber);
        if (line.match(/ a\/w\/./)) {
          const replacedLine = line.replace(/ a\/w\/(.)/, ` a/n/$1`);
          editor.setLine(lineNumber, replacedLine);
          editor.setCursor(cursor);
        } else if (line.match(/ a\/n\/./)) {
          const replacedLine = line.replace(/ a\/n\/(.)/, ` a/w/$1`);
          editor.setLine(lineNumber, replacedLine);
          editor.setCursor(cursor);
        } else if (line.match(/#w. /)) {
          const replacedLine = line.replace(/#w(.) /, `#n$1 `);
          editor.setLine(lineNumber, replacedLine);
          editor.setCursor(cursor);
        } else if (line.match(/#n. /)) {
          const replacedLine = line.replace(/#n(.) /, `#w$1 `);
          editor.setLine(lineNumber, replacedLine);
          editor.setCursor(cursor);
        } else if (line.match(/ #w./)) {
          const replacedLine = line.replace(/ #w(.)/, ` #n$1`);
          editor.setLine(lineNumber, replacedLine);
          editor.setCursor(cursor);
        } else if (line.match(/ #n./)) {
          const replacedLine = line.replace(/ #n(.)/, ` #w$1`);
          editor.setLine(lineNumber, replacedLine);
          editor.setCursor(cursor);
        }
      },
      hotkeys: [
        {
          modifiers: [`Ctrl`, `Meta`, `Shift`],
          key: `=`
        },
        {
          modifiers: [`Ctrl`, `Alt`, `Shift`],
          key: `=`
        }
      ]
    });
    this.addCommand({
      id: "cursor-go-to-start-of-line",
      name: "Cursor go to start of line",
      icon: `arrow-big-left`,
      editorCallback: (editor, view) => {
        const cursor = editor.getCursor();
        cursor.ch = 0;
        editor.setCursor(cursor);
      }
    });
    this.addCommand({
      id: "cursor-go-to-end-of-line",
      name: "Cursor go to end of line",
      icon: `arrow-big-right`,
      editorCallback: (editor, view) => {
        const cursor = editor.getCursor();
        const lineNum = cursor.line;
        const line = editor.getLine(lineNum);
        const length = line.length;
        cursor.ch = length;
        editor.setCursor(cursor);
      }
    });
    this.addObsidianIcon("event-to-fantastical-icon", "FE");
    this.addCommand({
      id: "add-fantastical-event",
      name: "FE Add Fantastical Event",
      icon: `event-to-fantastical-icon`,
      editorCallback: (editor, view) => {
        let text = "";
        const listSelections = editor.listSelections();
        listSelections.forEach((listSelection) => {
          const a = listSelection.head.line;
          const b = listSelection.anchor.line;
          const fromLineNum = b > a ? a : b;
          const toLineNum = b > a ? b : a;
          for (let i = fromLineNum; i <= toLineNum; i++) {
            const line = editor.getLine(i);
            if (/^- \d\d\d\d-\d\d-\d\d \d\d:\d\d /.test(line)) {
              const modifiedLine = line.replace(/^- /, `- #tm `);
              editor.setLine(i, modifiedLine);
              text += line + "\n";
            }
          }
        });
        if (text.length != 0) {
          text = encodeURI(text);
          window.open(`shortcuts://run-shortcut?name=Add%20Obsidian%20Inbox%20Event%20via%20Fantastical&input=text&text=${text}&x-success=obsidian://&x-cancel=obsidian://&x-error=obsidian://`);
        }
      }
    });
    this.addCommand({
      id: "grep-title-as-link-to-clipboard",
      name: "Grep Title as link to clipboard",
      icon: `clipboard-list`,
      editorCallback: async (editor, view) => {
        const title = view.file.basename;
        const titleAsLink = `[[${title}]]`;
        try {
          this.addToClipboardHistory(titleAsLink);
          await navigator.clipboard.writeText(titleAsLink);
          new import_obsidian20.Notice(`Copied title "${title}" as link to clipboard!`);
        } catch (error) {
          new import_obsidian20.Notice(`Error occurred when copying to clipboard: ${error}`);
        }
      },
      hotkeys: [
        {
          modifiers: [`Meta`, `Shift`],
          key: `l`
        },
        {
          modifiers: [`Ctrl`, `Shift`],
          key: `l`
        }
      ]
    });
    this.addObsidianIcon("move-current-selection-to-beginning-of-notes", "<<");
    this.addCommand({
      id: "move-current-selection-to-beginning-of-notes",
      name: "MB << Move current selection to beginning of notes",
      icon: `move-current-selection-to-beginning-of-notes`,
      editorCallback: (editor, view) => {
        let selection = exportCurrentSelection(editor);
        if (/^    +- /m.test(selection) || /^- /m.test(selection) || /^# /m.test(selection) || /^` /m.test(selection) || /^> /m.test(selection) || /^\d+\. /m.test(selection)) {
        } else {
          selection = "- " + selection;
        }
        let newContent = "";
        const selectionRange = getCurrentSelectionLineNumber(editor);
        for (let i = 0; i < editor.lineCount(); i++) {
          if (i < selectionRange.fromLineNum || i > selectionRange.toLineNum) {
            newContent = newContent + editor.getLine(i) + "\n";
          }
        }
        new AddTextToNotesModal(this.app, selection, "move the selected text", true, () => editor.setValue(newContent.replace(/\n$/m, ""))).open();
      },
      hotkeys: [
        {
          modifiers: [`Ctrl`, `Meta`, `Shift`],
          key: `,`
        },
        {
          modifiers: [`Ctrl`, `Alt`, `Shift`],
          key: `,`
        }
      ]
    });
    this.addObsidianIcon("move-current-selection-to-end-of-notes", ">>");
    this.addCommand({
      id: "move-current-selection-to-end-of-notes",
      name: "ME >> Move current selection to beginning of notes",
      icon: `move-current-selection-to-end-of-notes`,
      editorCallback: (editor, view) => {
        let selection = exportCurrentSelection(editor);
        if (/^    +- /m.test(selection) || /^- /m.test(selection) || /^# /m.test(selection) || /^` /m.test(selection) || /^> /m.test(selection) || /^\d+\. /m.test(selection)) {
        } else {
          selection = "- " + selection;
        }
        let newContent = "";
        const selectionRange = getCurrentSelectionLineNumber(editor);
        for (let i = 0; i < editor.lineCount(); i++) {
          if (i < selectionRange.fromLineNum || i > selectionRange.toLineNum) {
            newContent = newContent + editor.getLine(i) + "\n";
          }
        }
        new AddTextToNotesModal(this.app, selection, "move the selected text", false, () => editor.setValue(newContent.replace(/\n$/m, ""))).open();
      },
      hotkeys: [
        {
          modifiers: [`Ctrl`, `Meta`, `Shift`],
          key: `.`
        },
        {
          modifiers: [`Ctrl`, `Alt`, `Shift`],
          key: `.`
        }
      ]
    });
    this.addObsidianIcon("add-current-selection-to-beginning-of-notes", "((");
    this.addCommand({
      id: "add-current-selection-to-beginning-of-notes",
      name: "SB (( Add current selection to beginning of notes",
      icon: `add-current-selection-to-beginning-of-notes`,
      editorCallback: (editor, view) => {
        let selection = exportCurrentSelection(editor);
        if (/^    +- /m.test(selection) || /^- /m.test(selection) || /^# /m.test(selection) || /^` /m.test(selection) || /^> /m.test(selection) || /^\d+\. /m.test(selection)) {
        } else {
          selection = "- " + selection;
        }
        new AddTextToNotesModal(this.app, selection, "add the selected text", true, () => {
        }).open();
      },
      hotkeys: [
        {
          modifiers: [`Ctrl`, `Meta`, `Shift`],
          key: `9`
        },
        {
          modifiers: [`Ctrl`, `Alt`, `Shift`],
          key: `9`
        }
      ]
    });
    this.addObsidianIcon("add-current-selection-to-end-of-notes", "))");
    this.addCommand({
      id: "add-current-selection-to-end-of-notes",
      name: "SE )) Add current selection to end of notes",
      icon: `add-current-selection-to-end-of-notes`,
      editorCallback: (editor, view) => {
        let selection = exportCurrentSelection(editor);
        if (/^    +- /m.test(selection) || /^- /m.test(selection) || /^# /m.test(selection) || /^` /m.test(selection) || /^> /m.test(selection) || /^\d+\. /m.test(selection)) {
        } else {
          selection = "- " + selection;
        }
        new AddTextToNotesModal(this.app, selection, "add the selected text", false, () => {
        }).open();
      },
      hotkeys: [
        {
          modifiers: [`Ctrl`, `Meta`, `Shift`],
          key: `0`
        },
        {
          modifiers: [`Ctrl`, `Alt`, `Shift`],
          key: `0`
        }
      ]
    });
    this.addObsidianIcon("add-current-link-to-beginning-of-notes", "[[");
    this.addCommand({
      id: "add-current-link-to-beginning-of-notes",
      name: "LB [[ Add current link to beginning of notes",
      icon: `add-current-link-to-beginning-of-notes`,
      editorCallback: (editor, view) => {
        const link = "- [[" + view.file.basename + "]]";
        new AddTextToNotesModal(this.app, link, "add the current note link", true, () => {
        }).open();
      },
      hotkeys: [
        {
          modifiers: [`Ctrl`, `Meta`, `Shift`],
          key: `[`
        },
        {
          modifiers: [`Ctrl`, `Alt`, `Shift`],
          key: `[`
        }
      ]
    });
    this.addObsidianIcon("add-current-link-to-end-of-notes", "]]");
    this.addCommand({
      id: "add-current-link-to-end-of-notes",
      name: "LE ]] Add current link to end-of-notes",
      icon: `add-current-link-to-end-of-notes`,
      editorCallback: (editor, view) => {
        const link = "- [[" + view.file.basename + "]]";
        new AddTextToNotesModal(this.app, link, "add the current note link", false, () => {
        }).open();
      },
      hotkeys: [
        {
          modifiers: [`Ctrl`, `Meta`, `Shift`],
          key: `]`
        },
        {
          modifiers: [`Ctrl`, `Alt`, `Shift`],
          key: `]`
        }
      ]
    });
    this.addCommand({
      id: "quick-navigate-to-notes",
      name: "NN Quick Navigate to Notes",
      icon: `aperture`,
      callback: async () => {
        new NavigateToNoteFromTagModal(this.app).open();
      },
      hotkeys: [
        {
          modifiers: [`Ctrl`, `Meta`, `Shift`],
          key: `;`
        },
        {
          modifiers: [`Ctrl`, `Alt`, `Shift`],
          key: `;`
        }
      ]
    });
    this.addObsidianIcon("threads-to-twitter", "TX");
    this.addCommand({
      id: "threads-to-twitter",
      name: "TT TX Threads to Twitter",
      icon: `threads-to-twitter`,
      editorCallback: (editor, view) => {
        const { vault } = this.app;
        const v = editor.getValue();
        const path = view.file.path;
        if (!path.match(/.\/Threads \d\d\d\d\d\d\d\d/)) {
          new import_obsidian20.Notice(`Will not proceed. It is not a threads post.`);
          return;
        }
        const newPath = path.replace(/(.\/)Threads /, "$1Twitter ");
        const { workspace } = this.app;
        const leaf = workspace.getLeaf(false);
        Promise.resolve().then(() => {
          return vault.adapter.exists(newPath);
        }).then((fileExists) => {
          if (fileExists) {
            new import_obsidian20.Notice(`Will not proceed. Twitter post already exist.`);
            return Promise.reject("Twitter post already exist");
          }
          return vault.create(newPath, v);
        }).then((tFile) => {
          return leaf.openFile(tFile, { active: true });
        }, (reason) => {
        }).then(() => {
          new import_obsidian20.Notice(`Created and opened Twitter notes!`);
        });
      }
    });
    this.addObsidianIcon("blog-to-clipboard-icon", "BJ");
    this.addCommand({
      id: "blog-to-clipboard",
      name: "BJ Blog content to clipboard",
      icon: `blog-to-clipboard-icon`,
      editorCallback: async (editor, view) => {
        const v = editor.getValue();
        if (v.includes("#nn") || v.includes("#nl") || v.includes("#nw") || v.includes("#wn") || v.includes("#wl") || v.includes("#ww")) {
          new import_obsidian20.Notice(`Will not proceed. As there are unfinished action tag.`);
          return;
        }
        if (!v.includes("<!--more-->")) {
          try {
            await navigator.clipboard.writeText("<!--more-->");
            new import_obsidian20.Notice(`Require "<!--more-->" as excerpt separator before posting.
"<!--more-->" already in clipboard`);
          } catch (error) {
            new import_obsidian20.Notice(`Require "<!--more-->" as excerpt separator before posting.
"<!--more-->" cannot be copied to clipboard`);
          }
          return;
        }
        const path = view.file.path;
        let line = editor.lineCount();
        let text = "";
        let numLineFirstContent = 0;
        let frontMatterLineCount = 0;
        for (let i = 0; i < line; i++) {
          if (frontMatterLineCount == 2) {
            numLineFirstContent = i;
            break;
          }
          if (editor.getLine(i) == "---") {
            frontMatterLineCount++;
          }
        }
        for (let i = 0; i < line; i++) {
          if (editor.getLine(numLineFirstContent).trim() == "") {
            numLineFirstContent++;
          } else {
            break;
          }
        }
        Array.from(Array(line - numLineFirstContent).keys()).forEach((i) => {
          const line2 = editor.getLine(i + numLineFirstContent);
          text = text + line2 + "\n";
        });
        text = text.replace(/\n---\n\n#nd generate summary for meta description below:\n[^\n]*\n([^\n]*)\n[^\n]*\n---\n/, "\n<!-- Meta Summary -->\n<!--\n$1\n-->\n");
        text = text.replace(/## References\:([\n]*.*)*$/, "");
        const app2 = this.app;
        const beforeTagCBR = "c/b/r";
        const beforeTagCBD = "c/b/d";
        const beforeTagCBI = "c/b/i";
        const afterTag = "c/b/p";
        try {
          await navigator.clipboard.writeText(text);
          new import_obsidian20.Notice(`Copied blog content to clipboard!`);
          const foundTagFromCBR = await renameTag(view.file, beforeTagCBR, afterTag);
          if (foundTagFromCBR) {
            new import_obsidian20.Notice(`Update notes type from tag="${beforeTagCBR}" to tag="${afterTag}!`);
          }
          const foundTagFromCBI = await renameTag(view.file, beforeTagCBI, afterTag);
          if (foundTagFromCBI) {
            new import_obsidian20.Notice(`Update notes type from tag="${foundTagFromCBI}" to tag="${afterTag}!`);
          }
          const foundTagFromCBD = await renameTag(view.file, beforeTagCBD, afterTag);
          if (foundTagFromCBD) {
            new import_obsidian20.Notice(`Update notes type from tag="${beforeTagCBD}" to tag="${afterTag}!`);
          }
          await renameBlogTitle(app2, path, view);
          window.open(`shortcuts://run-shortcut?name=Jekyll%20blog&x-cancel=obsidian://&x-error=obsidian://`);
        } catch (error) {
          new import_obsidian20.Notice(`Error occurred during the operation: ${error}`);
        }
      }
    });
    this.addObsidianIcon("generate-chatgpt-prompt", "GP");
    this.addCommand({
      id: "generate-chatgpt-prompt",
      name: "GP Generate ChatGPT Prompt",
      icon: `generate-chatgpt-prompt`,
      editorCallback: async (editor, view) => {
        let line = editor.lineCount();
        let text = "\u3010" + view.file.basename + "\u3011\n\n";
        let numLineFirstContent = 0;
        let frontMatterLineCount = 0;
        for (let i = 0; i < line; i++) {
          if (frontMatterLineCount == 2) {
            numLineFirstContent = i;
            break;
          }
          if (editor.getLine(i) == "---") {
            frontMatterLineCount++;
          }
        }
        for (let i = 0; i < line; i++) {
          if (editor.getLine(numLineFirstContent).trim() == "") {
            numLineFirstContent++;
          } else {
            break;
          }
        }
        Array.from(Array(line - numLineFirstContent).keys()).forEach((i) => {
          const line2 = editor.getLine(i + numLineFirstContent);
          if (!line2.startsWith("%%") && !line2.endsWith("%%")) {
            text = text + line2 + "\n";
          }
        });
        text = text.replace(/## References\:([\n]*.*)*$/, "");
        navigator.clipboard.writeText(text).then(function() {
          new import_obsidian20.Notice(`Copied content to clipboard for generating prompt!`);
          window.open(`shortcuts://run-shortcut?name=Generate%20ChatGPT%20Prompt&x-success=obsidian://&x-cancel=obsidian://&x-error=obsidian://`);
        }, function(error) {
          new import_obsidian20.Notice(`error when copy to clipboard!`);
        });
      }
    });
    this.addObsidianIcon("threads-to-clipboard-icon", "TC");
    this.addCommand({
      id: "threads-to-clipboard",
      name: "TC Threads content to clipboard",
      icon: `threads-to-clipboard-icon`,
      editorCallback: (editor, view) => {
        const value = editor.getValue();
        const text = this.convertThreadsContentToFormatForThreadsApp(editor);
        const beforeTag = "c/t/r";
        const afterTag = "c/t/t";
        navigator.clipboard.writeText(text).then(function() {
          return renameTag(view.file, beforeTag, afterTag);
        }, function(error) {
          new import_obsidian20.Notice(`error when copy to clipboard!`);
        }).then((foundTag) => {
          if (foundTag) {
            new import_obsidian20.Notice(`Update notes type from tag="${beforeTag}" to tag="${afterTag}!
Copied thread content to clipboard!`);
          } else {
            new import_obsidian20.Notice(`Tag "${beforeTag}" not found
Copied thread content to clipboard!`);
          }
        });
      }
    });
    this.addObsidianIcon("twitter-to-chatgpt", "XG");
    this.addCommand({
      id: "twitter-to-chatgpt",
      name: "XG Twitter to ChatGPT",
      icon: `twitter-to-chatgpt`,
      editorCallback: (editor, view) => {
        const value = editor.getValue();
        if (!view.file.basename.contains("Twitter")) {
          new import_obsidian20.Notice("Note name not contains 'Twitter', did not copy from thread note?");
          return;
        }
        let content = this.convertThreadsContentToFormatForFacebookApp(editor);
        let numTweet = Math.ceil(content.length / 110);
        let prompt = `You are a social media content copywriter. Convert the following content to twitter threads less than ${numTweet} tweet in traditional Chinese. Preserve the title. Merge title with the first tweet while add 2 newline characters between title and first tweet. Every tweet has to over 100 but less than 140 Chinese characters. Do not simplify the content. Do not add any additional information which is not mentioned from the original content. Preserve the example from the content. No need to add any tags to the tweet. Do not have any number in each tweet. Each tweet separated by 2 newline and 3 "-" characters and another newline. Add a space character between each English character and Chinese character. If the original content contains any URL, preserve the URL in the tweet without using any Markdown format for the URL while add 2 newline character before the URL.`;
        prompt = prompt + "\n\n" + content;
        prompt = prompt.replace(//g, "");
        prompt = prompt.replace(/\n+https\:\/\/github.com[^\n]+\n/m, "\u3011\n");
        prompt = prompt.replace(/\*\*/gm, "");
        navigator.clipboard.writeText(prompt).then(function() {
          let line = editor.lineCount();
          let numLineFirstContent = 0;
          let frontMatterLineCount = 0;
          for (let i = 0; i < line; i++) {
            if (frontMatterLineCount == 2) {
              numLineFirstContent = i;
              break;
            }
            if (editor.getLine(i) == "---") {
              frontMatterLineCount++;
            }
          }
          for (let i = 0; i < line; i++) {
            if (editor.getLine(numLineFirstContent).trim() == "") {
              numLineFirstContent++;
            } else {
              break;
            }
          }
          let text = "";
          Array.from(Array(numLineFirstContent).keys()).forEach((i) => {
            const line2 = editor.getLine(i);
            text = text + line2 + "\n";
          });
          editor.setValue(text);
          renameTag(view.file, "c/t/d", "c/x/d");
          renameTag(view.file, "c/t/r", "c/x/d");
          renameTag(view.file, "c/t/t", "c/x/d");
          renameTag(view.file, "c/t/p", "c/x/d");
          const cursor = editor.getCursor();
          cursor.line = editor.lineCount() - 1;
          cursor.ch = 0;
          editor.setCursor(cursor);
          new import_obsidian20.Notice("copied to clipboard, please open chatgpt to paste");
        }, function(error) {
          new import_obsidian20.Notice(`error when copy to clipboard!`);
        });
      }
    });
    this.addObsidianIcon("chatgpt-to-twitter", "GX");
    this.addCommand({
      id: "chatgpt-to-twitter",
      name: "GX ChatGPT to Twitter",
      icon: `chatgpt-to-twitter`,
      editorCallback: (editor, view) => {
        if (!editor.getValue().contains("c/x/d")) {
          new import_obsidian20.Notice("Note type not c/x/d, do the action in wrong note?");
          return;
        }
        const isSuccess = this.convertChatGPTToTwitterFormat(editor);
        if (isSuccess) {
          renameTag(view.file, "c/x/d", "c/x/r");
        }
      }
    });
    this.addObsidianIcon("reverse-twitter-number-icon", "RT");
    this.addCommand({
      id: "reverse-twitter-numbering",
      name: "RT Reverse Twitter Numbering",
      icon: `reverse-twitter-number-icon`,
      editorCallback: (editor, view) => {
        if (!editor.getValue().contains("c/x/r") && !editor.getValue().contains("c/x/p")) {
          new import_obsidian20.Notice("Note type not c/x/r nor c/x/p, do the action in wrong note?");
          return;
        }
        this.reverseTwitterNumbering(editor);
        renameTag(view.file, "c/x/p", "c/x/d");
        renameTag(view.file, "c/x/r", "c/x/d");
      }
    });
    this.addObsidianIcon("threads-as-facebook-post-to-clipboard-icon", "FC");
    this.addCommand({
      id: "threads-as-facebook-post-to-clipboard",
      name: "FC Threads as Facebook post format to Clipboard",
      icon: `threads-as-facebook-post-to-clipboard-icon`,
      editorCallback: (editor, view) => {
        const value = editor.getValue();
        const text = this.convertThreadsContentToFormatForFacebookApp(editor);
        const beforeTag = "c/t/t";
        const afterTag = "c/t/p";
        navigator.clipboard.writeText(text).then(function() {
          return renameTag(view.file, beforeTag, afterTag);
        }, function(error) {
          new import_obsidian20.Notice(`error when copy to clipboard!`);
        }).then((foundTag) => {
          if (foundTag) {
            new import_obsidian20.Notice(`Update notes type from tag="${beforeTag}" to tag="${afterTag}!
Copied fb content to clipboard!`);
          } else {
            new import_obsidian20.Notice(`Tag "${beforeTag}" not found
Copied fb content to clipboard!`);
          }
        });
      }
    });
    this.addObsidianIcon("threads-block-to-image", "TI");
    this.addCommand({
      id: "threads-block-to-image",
      name: "TI Threads segment to image",
      icon: `threads-block-to-image`,
      editorCallback: (editor, view) => {
        const threadSegment = this.getThreadSegment(editor);
        new ThreadsToImagesModal(this.app, threadSegment).open();
      }
    });
    this.addObsidianIcon("chatgpt-generate-image", "GI");
    this.addCommand({
      id: "chatgpt-generate-image",
      name: "GI ChatGPT image",
      icon: `chatgpt-generate-image`,
      editorCallback: (editor, view) => {
        window.open("shortcuts://run-shortcut?name=ChatGPT%20Generate%20Image&x-success=obsidian://&x-cancel=obsidian://&x-error=obsidian://");
      }
    });
    this.addObsidianIcon("twitter-segment-to-clipboard", "XC");
    this.addCommand({
      id: "twitter-segment-to-clipboard",
      name: "XC Twitter segment to clipboard",
      icon: `twitter-segment-to-clipboard`,
      editorCallback: (editor, view) => {
        const threadSegment = this.getTwitterSegment(editor);
        const beforeTag = "c/x/r";
        const afterTag = "c/x/p";
        navigator.clipboard.writeText(threadSegment).then(function() {
          return renameTag(view.file, beforeTag, afterTag);
        }, function(error) {
          new import_obsidian20.Notice(`error when copy to clipboard!`);
        }).then((foundTag) => {
          if (foundTag) {
            new import_obsidian20.Notice(`Update notes type from tag="${beforeTag}" to tag="${afterTag}!
Copied
\`\`\`
${threadSegment}\`\`\`
to clipboard!`);
          } else {
            new import_obsidian20.Notice(`Tag "${beforeTag}" not found
Copied
\`\`\`
${threadSegment}\`\`\`
to clipboard!`);
          }
        });
      }
    });
    this.addObsidianIcon("segment-to-clipboard", "SC");
    this.addCommand({
      id: "segment-to-clipboard",
      name: "SC Segment to clipboard",
      icon: `segment-to-clipboard`,
      editorCallback: (editor, view) => {
        const threadSegment = this.getSegment(editor);
        this.addToClipboardHistory(threadSegment);
        navigator.clipboard.writeText(threadSegment).then(function() {
          new import_obsidian20.Notice(`Copied
\`\`\`
${threadSegment}\`\`\`
to clipboard!`);
        }, function(error) {
          new import_obsidian20.Notice(`error when copy to clipboard!`);
        });
      }
    });
    this.addCommand({
      id: "toggle-bullet-number-list",
      name: "Toggle Bullet Number List",
      icon: `bullet-list`,
      editorCallback: (editor, view) => {
        const cursor = editor.getCursor();
        const ch = cursor.ch;
        const line = cursor.line;
        const lineContent = editor.getLine(line);
        if (/^(> )*\s*- /.test(lineContent)) {
          const replacedLineContent = lineContent.replace(/^((> )*)(\s*)- /, "$1$31. ");
          editor.setLine(line, replacedLineContent);
          cursor.ch = cursor.ch + 1;
          editor.setCursor(cursor);
        } else if (/^(> )*\s*[\d]+\. /.test(lineContent)) {
          const replacedLineContent = lineContent.replace(/^((> )*)(\s*)[\d]+\. /, "$1$3");
          editor.setLine(line, replacedLineContent);
          cursor.ch = cursor.ch - 3;
          editor.setCursor(cursor);
        } else {
          const replacedLineContent = lineContent.replace(/^((> )*)(\s*)/, "$1$3- ");
          editor.setLine(line, replacedLineContent);
          cursor.ch = cursor.ch + 2;
          editor.setCursor(cursor);
        }
      },
      hotkeys: [
        {
          modifiers: [`Ctrl`, `Meta`, `Shift`],
          key: `-`
        },
        {
          modifiers: [`Ctrl`, `Alt`, `Shift`],
          key: `-`
        }
      ]
    });
    this.addCommand({
      id: "copy-or-move-to-new-note",
      name: "Copy or Move to new note CMN",
      icon: `airplay`,
      editorCallback: async (editor, view) => {
        new CopyOrMoveToNewNoteModal(this.app, editor).open();
      }
    });
    this.addCommand({
      id: "editor-copy-line-to-clipboard",
      name: "Editor Copy Line to Clipboard",
      icon: `align-vertical-space-around`,
      editorCallback: (editor, view) => {
        const selection = exportCurrentSelection(editor);
        const copyContent = selection.contains("\n") ? selection : selection.replace(/^\t*- /, "").replace(/^\t*\d+\. /, "");
        this.addToClipboardHistory(copyContent);
        navigator.clipboard.writeText(copyContent).then(function() {
          new import_obsidian20.Notice(`Copied content
\`\`\`
${copyContent}
\`\`\`
to clipboard!`);
        }, function(error) {
          new import_obsidian20.Notice(`error when copy to clipboard!`);
        });
      },
      hotkeys: [
        {
          modifiers: [`Ctrl`, `Meta`, `Shift`],
          key: "/"
        },
        {
          modifiers: [`Ctrl`, `Alt`, `Shift`],
          key: "/"
        }
      ]
    });
    this.addCommand({
      id: "editor-cut-line-to-clipboard",
      name: "Editor Cut Line to Clipboard",
      icon: `align-vertical-justify-center`,
      editorCallback: (editor, view) => {
        const selection = exportCurrentSelection(editor);
        const cursor = editor.getCursor();
        const copyContent = selection.contains("\n") ? selection : selection.replace(/^\t*- /, "").replace(/^\t*\d+\. /, "");
        let newContent = "";
        const selectionRange = getCurrentSelectionLineNumber(editor);
        for (let i = 0; i < editor.lineCount(); i++) {
          if (i < selectionRange.fromLineNum || i > selectionRange.toLineNum) {
            newContent = newContent + editor.getLine(i) + "\n";
          }
        }
        this.addToClipboardHistory(copyContent);
        navigator.clipboard.writeText(copyContent).then(function() {
          new import_obsidian20.Notice(`Copied content
\`\`\`
${copyContent}
\`\`\`
to clipboard!`);
        }, function(error) {
          new import_obsidian20.Notice(`error when copy to clipboard!`);
        });
        editor.setValue(newContent);
        cursor.line = selectionRange.fromLineNum;
        if (editor.getLine(selectionRange.fromLineNum).length < selectionRange.fromCh) {
          cursor.ch = editor.getLine(selectionRange.fromLineNum).length;
        }
        editor.setCursor(cursor);
      },
      hotkeys: [
        {
          modifiers: [`Ctrl`, `Meta`, `Shift`],
          key: "\\"
        },
        {
          modifiers: [`Ctrl`, `Alt`, `Shift`],
          key: "\\"
        }
      ]
    });
    this.addCommand({
      id: "editor-indent-line",
      name: "Editor Indent Selection",
      icon: `right-arrow-with-tail`,
      editorCallback: (editor, view) => {
        const listSelections = editor.listSelections();
        listSelections.forEach((listSelection) => {
          const a = listSelection.head.line;
          const b = listSelection.anchor.line;
          const fromLineNum = b > a ? a : b;
          const toLineNum = b > a ? b : a;
          for (let i = fromLineNum; i <= toLineNum; i++) {
            const line = editor.getLine(i);
            editor.setLine(i, line.replace(/^/, "	"));
          }
        });
        let lss = [];
        listSelections.forEach((ls) => {
          const head = ls.head;
          head.ch = head.ch + 1;
          const anchor = ls.anchor;
          anchor.ch = anchor.ch + 1;
          const newLs = { anchor, head };
          lss.push(newLs);
        });
        editor.setSelections(lss);
      }
    });
    this.addCommand({
      id: "editor-outdent-line",
      name: "Editor Outdent Selection",
      icon: `left-arrow-with-tail`,
      editorCallback: (editor, view) => {
        const listSelections = editor.listSelections();
        listSelections.forEach((listSelection) => {
          const a = listSelection.head.line;
          const b = listSelection.anchor.line;
          const fromLineNum = b > a ? a : b;
          const toLineNum = b > a ? b : a;
          for (let i = fromLineNum; i <= toLineNum; i++) {
            const line = editor.getLine(i);
            editor.setLine(i, line.replace(/^\t/, ""));
          }
        });
        let lss = [];
        listSelections.forEach((ls) => {
          const head = ls.head;
          head.ch = head.ch + 1;
          const anchor = ls.anchor;
          anchor.ch = anchor.ch + 1;
          const newLs = { anchor, head };
          lss.push(newLs);
        });
        editor.setSelections(lss);
      }
    });
    this.addSettingTab(new SampleSettingTab(this.app, this));
  }
  convertChatGPTToTwitterFormat(editor) {
    let line = editor.lineCount();
    let numLineFirstContent = 0;
    let frontMatterLineCount = 0;
    for (let i = 0; i < line; i++) {
      if (frontMatterLineCount == 2) {
        numLineFirstContent = i;
        break;
      }
      if (editor.getLine(i) == "---") {
        frontMatterLineCount++;
      }
    }
    for (let i = 0; i < line; i++) {
      if (editor.getLine(numLineFirstContent).trim() == "") {
        numLineFirstContent++;
      } else {
        break;
      }
    }
    let totalTweetCount = 1;
    Array.from(Array(line - numLineFirstContent).keys()).forEach((i) => {
      const line2 = editor.getLine(i + numLineFirstContent);
      let modifiedLine = line2.replace(/^____+/, "---").replace(/^----+/, "---");
      editor.setLine(i + numLineFirstContent, modifiedLine);
      if (modifiedLine == "---") {
        totalTweetCount = totalTweetCount + 1;
      }
    });
    let numTweet = 1;
    let readyToAddTweetCount = true;
    let text = "";
    Array.from(Array(numLineFirstContent).keys()).forEach((i) => {
      const line2 = editor.getLine(i);
      text = text + line2 + "\n";
    });
    Array.from(Array(line - numLineFirstContent).keys()).forEach((i) => {
      const line2 = editor.getLine(i + numLineFirstContent);
      let modifiedLine = line2;
      if (line2 == "---") {
        readyToAddTweetCount = true;
        numTweet = numTweet + 1;
      } else if (line2 != "" && readyToAddTweetCount) {
        if (!/^\d+\/\d+.*/.test(line2)) {
          modifiedLine = `${numTweet}/${totalTweetCount} ${line2}`;
        }
        readyToAddTweetCount = false;
      }
      text = text + modifiedLine + "\n";
    });
    text = text.replace("\u258D", "");
    const tweets = text.split("---");
    for (let i = 0; i < tweets.length; i++) {
      const tweet = tweets[i].replace(/(https:|http:|www\.)\S*/gm, "").replace(/^\n+/m, "").replace(/\n+$/m, "");
      if (tweet.length > 140) {
        new import_obsidian20.Notice("```\n" + tweet + "\n```\n\nexceed 140 characters. Probably cannot post in twitter. Please refine the tweet. Aborting");
        return false;
      }
    }
    editor.setValue(text);
    const cursor = editor.getCursor();
    cursor.line = editor.lineCount() - 1;
    editor.setCursor(cursor);
    return true;
  }
  reverseTwitterNumbering(editor) {
    let line = editor.lineCount();
    let numLineFirstContent = 0;
    let frontMatterLineCount = 0;
    for (let i = 0; i < line; i++) {
      if (frontMatterLineCount == 2) {
        numLineFirstContent = i;
        break;
      }
      if (editor.getLine(i) == "---") {
        frontMatterLineCount++;
      }
    }
    for (let i = 0; i < line; i++) {
      if (editor.getLine(numLineFirstContent).trim() == "") {
        numLineFirstContent++;
      } else {
        break;
      }
    }
    let text = "";
    Array.from(Array(numLineFirstContent).keys()).forEach((i) => {
      const line2 = editor.getLine(i);
      text = text + line2 + "\n";
    });
    Array.from(Array(line - numLineFirstContent).keys()).forEach((i) => {
      const line2 = editor.getLine(i + numLineFirstContent);
      const modifiedLine = line2.replace(/^\d+\/\d+ /, "");
      text = text + modifiedLine + "\n";
    });
    editor.setValue(text);
    const cursor = editor.getCursor();
    cursor.line = editor.lineCount() - 1;
    editor.setCursor(cursor);
  }
  convertThreadsContentToFormatForThreadsApp(editor) {
    return this.convertThreadsContentToLightPostFormat(editor, "\u{1F9F5}", "\n\n\n");
  }
  convertThreadsContentToFormatForFacebookApp(editor) {
    return this.convertThreadsContentToLightPostFormat(editor, "", "\n\n\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\n\n", (a) => a.replace("\u{1F447}", ""));
  }
  /*
  	addTaskToPutIntoCardInThreadsContent(editor: Editor) {
  		let line = editor.lineCount();
  
  		let frontMatterLineCount = 0
  		let text = "";
  		for (let i = 0; i < line; i++) {
  			if (editor.getLine(i) == "---") {
  				frontMatterLineCount++
  			}
  			const line = editor.getLine(i);
  			
  			//if (frontMatterLineCount > 2 && line == "---") {
  			//	text = text + "%% #nm to zk %%\n\n"
  			//}
  			text = text + line + "\n"
  		}
  
  		editor.setValue(text);
  	}
  */
  tidyUpFrontMatteronEditor(editor) {
    const value = editor.getValue();
    const modifiedValue = this.tidyUpFrontMatterOnValue(value);
    editor.setValue(modifiedValue);
  }
  tidyUpFrontMatterOnValue(value) {
    const values = value.split("\n");
    const lineCount = values.length;
    let fm = "";
    let c = "";
    let text = "";
    let h3Count = 0;
    let content = "";
    for (let i = 0; i < lineCount; i++) {
      const line = values[i];
      if (h3Count == 0) {
        content += line + "\n";
      } else if (h3Count == 1) {
        if (this.shouldSkipFrontMatter(line)) {
        } else if (line.startsWith("title: ")) {
          const modifiedLine = line.replace(/:/g, "_").replace(/^title_ /, "title: ");
          fm += modifiedLine + "\n";
        } else if (line === "tags: [excalidraw]") {
          fm += line + "\n";
        } else if (line.startsWith("tagsss: ") || line.startsWith("tags: ")) {
          const bracketPattern = /\[\[.*?\]\]/g;
          const bracketedItems = line.match(bracketPattern) || [];
          const remainingString = line.replace(bracketPattern, "").trim();
          const remainingItems = remainingString.split(/\s+/).filter((item) => item);
          const fmtagsss = [...bracketedItems, ...remainingItems];
          let parent = [];
          let tagsss = [];
          let skips = [];
          fmtagsss.forEach((tag) => {
            tag = tag.trim();
            if (tag === "[[.Header Shortcut]]" || tag === "[[.Current Project]]" || tag === "concept" || tag === "space" || tag === "problem" || tag === "tagsss:" || tag === "tags:" || tag === "[[event n]]" || tag === "[[event w]]" || /\[\[\d{8} Journal \(Week \d+ [A-Za-z]{3}\)\]\]/.test(tag)) {
              skips.push(tag);
            } else if (tag === "permtask" || tag === "N" || tag === "W" || tag === "now" || tag === "later" || tag === "waiting" || tag === "done" || tag === "archive" || tag === "action" || tag === "task") {
              tagsss.push(tag.replace("[[", "").replace("]]", ""));
            } else if (tag === "preblog" || tag === "prepreblog") {
              parent.push("[[Blog _ Post]]");
            } else {
              parent.push(tag);
            }
          });
          let modifiedLine = "";
          if (tagsss.length > 0) {
            modifiedLine += "tagsss: " + tagsss.join(" ") + "\n";
          }
          let parentCount = 1;
          if (parent.length > 0) {
            const uniqueParent = Array.from(new Set(parent));
            uniqueParent.forEach((p) => {
              if (p.startsWith("[[") && p.endsWith("]]")) {
                modifiedLine += "parent" + parentCount + ': "' + p.replace(":", "_") + '"\n';
              } else {
                modifiedLine += "parent" + parentCount + ': "[[' + p.replace(":", "_") + ']]"\n';
              }
              parentCount++;
            });
          }
          fm += modifiedLine;
        } else {
          fm += line + "\n";
        }
      }
      if (h3Count >= 2) {
        c += line + "\n";
      }
      if (line === "---") {
        h3Count++;
      }
    }
    text += content;
    if (fm.length > 0) {
      text += fm;
    }
    text += c;
    return text.replace(/^---\n---\n/m, "").replace(/\n$/, "");
  }
  shouldSkipFrontMatter(line) {
    for (let i = 0; i < skipFrontMatterField.length; i++) {
      if (line.startsWith(skipFrontMatterField[i])) {
        return true;
      }
    }
    return false;
  }
  convertThreadsContentToLightPostFormat(editor, headerIcon, paragraphSeparator, additionReplaceFn = (a) => a) {
    let line = editor.lineCount();
    let numLineFirstContent = 0;
    let frontMatterLineCount = 0;
    for (let i = 0; i < line; i++) {
      if (frontMatterLineCount == 2) {
        numLineFirstContent = i;
        break;
      }
      if (editor.getLine(i) == "---") {
        frontMatterLineCount++;
      }
    }
    for (let i = 0; i < line; i++) {
      if (editor.getLine(numLineFirstContent).trim() == "") {
        numLineFirstContent++;
      } else {
        break;
      }
    }
    let text = "";
    let newConsecutiveLineCount = 0;
    Array.from(Array(line - numLineFirstContent).keys()).forEach((i) => {
      const line2 = editor.getLine(i + numLineFirstContent);
      if (!line2.trim().startsWith("%%") || !line2.trim().endsWith("%%")) {
        if (line2 == "---") {
          newConsecutiveLineCount = 0;
        }
        if (line2 == "") {
          newConsecutiveLineCount++;
        } else {
          newConsecutiveLineCount = 0;
        }
        if (line2 == "" && newConsecutiveLineCount > 1) {
        } else {
          let modifiedLine = line2 == "---" ? "" : line2;
          modifiedLine = modifiedLine.replace(/^		- /g, "\u3000\u3000\u3000\u3000\u2022 ").replace(/^	- /g, "\u3000\u3000\u2022 ").replace(/^- /, "\u2022 ");
          modifiedLine = modifiedLine.replace(/^\[([^\[\]\(\)]+)\]\([^\[\]\(\)]+\)/g, "$1").replace(/[^!]\[([^\[\]\(\)]+)\]\([^\[\]\(\)]+\)/g, "$1");
          modifiedLine = modifiedLine.replace(/!\[([^\[\]\(\)]+)\]\(([^\[\]\(\)]+)\)/g, "$2");
          modifiedLine = modifiedLine.replace(/\*\*/gm, "");
          text = text + modifiedLine + "\n";
        }
      }
    });
    text = text.replace(/[ ]+(.*)/g, headerIcon + "\u3010$1\u3011");
    text = additionReplaceFn(text);
    text = text.replace(/[\n\r]{3,}/gm, `${paragraphSeparator}\u258D`);
    text = text.replace("\n\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\n\n\u258D\n", "");
    let text2 = "";
    text.split("\n").forEach((line2) => {
      var l = "";
      if (line2.endsWith("\u3002") || line2.endsWith("\uFF1A") || line2.endsWith("\uFF5E") || line2.endsWith("\uFF01") || line2.startsWith("\u258Dhttp") || line2.startsWith("\u258D#") || line2 == "\u258D") {
        l = line2.replace(/^/gm, "");
      } else {
        l = line2;
      }
      text2 = text2 + l + "\n";
    });
    text2 = text2.replace("\n\n\n\n", "");
    text2 = text2.replace("\n\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\u1173\n\n\n", "");
    text2 = text2.replace(/\n\n## Opinion from ChatGPT\:([\n]*.*)*$/, "");
    text2 = text2.replace(/## References\:([\n]*.*)*$/, "");
    text2 = text2.replace(/\n+$/, "");
    return text2;
  }
  getThreadSegment(editor) {
    let cursor = editor.getCursor();
    let line = cursor.line;
    let above = line;
    let below = line;
    while (above >= 0) {
      let l = editor.getLine(above);
      if (l == "---") {
        break;
      }
      above--;
    }
    if (editor.getLine(above) == "---") {
      above++;
    }
    while (true) {
      if (editor.getLine(above) == "") {
        above++;
      } else {
        break;
      }
    }
    while (below < editor.lineCount()) {
      let l = editor.getLine(below);
      if (l == "---") {
        break;
      }
      below++;
    }
    if (editor.getLine(below) == "---") {
      below--;
    }
    while (true) {
      if (editor.getLine(below) == "") {
        below--;
      } else {
        break;
      }
    }
    let text = "";
    Array.from(Array(below - above + 1).keys()).forEach((i) => {
      const line2 = editor.getLine(i + above);
      if (!line2.trim().startsWith("%%") || !line2.trim().endsWith("%%")) {
        let modifiedLine = editor.getLine(i + above);
        modifiedLine = modifiedLine.replace(/^\[([^\[\]\(\)]+)\]\([^\[\]\(\)]+\)/g, "$1").replace(/[^!]\[([^\[\]\(\)]+)\]\([^\[\]\(\)]+\)/g, "$1");
        text = text + modifiedLine + "\n";
      }
    });
    text = text.replace(/\n+$/, "");
    return text;
  }
  getSegment(editor) {
    let cursor = editor.getCursor();
    let line = cursor.line;
    let above = line;
    let below = line;
    while (above >= 0) {
      let l = editor.getLine(above);
      if (l == "---") {
        break;
      }
      above--;
    }
    if (editor.getLine(above) == "---") {
      above++;
    }
    while (true) {
      if (editor.getLine(above) == "") {
        above++;
      } else {
        break;
      }
    }
    while (below < editor.lineCount()) {
      let l = editor.getLine(below);
      if (l == "---") {
        break;
      }
      below++;
    }
    if (editor.getLine(below) == "---") {
      below--;
    }
    while (true) {
      if (editor.getLine(below) == "") {
        below--;
      } else {
        break;
      }
    }
    let text = "";
    Array.from(Array(below - above + 1).keys()).forEach((i) => {
      const line2 = editor.getLine(i + above);
      text = text + line2 + "\n";
    });
    text = text.replace(/\n+$/, "");
    return text;
  }
  getTwitterSegment(editor) {
    let cursor = editor.getCursor();
    let line = cursor.line;
    let above = line;
    let below = line;
    while (above >= 0) {
      let l = editor.getLine(above);
      if (l == "---") {
        break;
      }
      above--;
    }
    if (editor.getLine(above) == "---") {
      above++;
    }
    while (true) {
      if (editor.getLine(above) == "") {
        above++;
      } else {
        break;
      }
    }
    while (below < editor.lineCount()) {
      let l = editor.getLine(below);
      if (l == "---") {
        break;
      }
      below++;
    }
    if (editor.getLine(below) == "---") {
      below--;
    }
    while (true) {
      if (editor.getLine(below) == "") {
        below--;
      } else {
        break;
      }
    }
    let text = "";
    Array.from(Array(below - above + 1).keys()).forEach((i) => {
      const line2 = editor.getLine(i + above);
      if (!line2.trim().startsWith("%%") || !line2.trim().endsWith("%%")) {
        let modifiedLine = editor.getLine(i + above);
        if (!/\d+\/\d+ *.*/.test(modifiedLine)) {
          modifiedLine = modifiedLine.replace(/^\[([^\[\]\(\)]+)\]\([^\[\]\(\)]+\)/g, "$1").replace(/[^!]\[([^\[\]\(\)]+)\]\([^\[\]\(\)]+\)/g, "$1").replace(/https[^\n]+\.jpeg/g, "").replace(/([^\n])/g, "\uFF1F\n\n$1").replace(/([^\n])/g, "\u3002\n\n$1").replace(/([^\n])/g, "\uFF01\n\n$1").replace(/([^\n])/g, "\uFF5E\n\n$1").replace(/^\s+$/, "");
        }
        text = text + modifiedLine + "\n";
      }
    });
    text = text.replace(/\n+$/, "");
    return text;
  }
  async add3DaysActionNoteContent(vault) {
    const scheduleNoteWithoutMd = "D/Query Schedule and Actions next 3 days";
    const scheduleNote = `${scheduleNoteWithoutMd}.md`;
    if (vault.getAbstractFileByPath(scheduleNote) == null) {
      await vault.create(scheduleNote, "");
    }
    let noteContent = "[[Query Schedule and Actions next 3 days]]\n";
    const excludeNotes = [scheduleNoteWithoutMd, "D/Scheduling"];
    Array.from(Array(3).keys()).forEach((i) => noteContent += this.getQueryDateAndActionString(i, excludeNotes));
    const otherDays = this.getQueryActionsThisWeek(3);
    noteContent = noteContent + `## nn / wn
\`\`\`query
tag:#nn OR tag:#wn${otherDays}
\`\`\`

## tt
\`\`\`query
tag:#tt
\`\`\`

`;
    noteContent = noteContent + this.getQueryFutureDaysThisWeek("Future Dates", 3, 6, excludeNotes);
    noteContent = noteContent + this.getQueryNext2MonthString(excludeNotes);
    noteContent = noteContent + this.getQueryFutureDaysThisWeek("Past Dates", -7, -1, excludeNotes);
    vault.modify(vault.getAbstractFileByPath(scheduleNote), noteContent);
  }
  async addActionNoteContent(vault, folderName, noteTitleWithoutMd, scheduleNoteTitleWithoutMd, nOrW) {
    const nowActionNoteWithoutMd = `${folderName}/${noteTitleWithoutMd}`;
    const nowActionNote = `${nowActionNoteWithoutMd}.md`;
    if (vault.getAbstractFileByPath(nowActionNote) == null) {
      await vault.create(nowActionNote, "");
    }
    let nowActionNoteContent = "";
    Array.from(Array(2).keys()).forEach((i) => nowActionNoteContent += this.getQueryActionString(i, nOrW));
    nowActionNoteContent += `\`\`\`query
tag:#${nOrW}t
\`\`\`
`;
    nowActionNoteContent += `\`\`\`query
`;
    Array.from(Array(5).keys()).forEach((i) => nowActionNoteContent += this.getQueryWeekDay(i + 2, nOrW));
    nowActionNoteContent += `tag:#${nOrW}n
\`\`\`
`;
    nowActionNoteContent += `Scheduling: [[${scheduleNoteTitleWithoutMd}]]
`;
    nowActionNoteContent += `[[${noteTitleWithoutMd}]]
`;
    vault.modify(vault.getAbstractFileByPath(nowActionNote), nowActionNoteContent);
  }
  getQueryDateAndActionString(addDay, excludeNotes) {
    const dateMoment = (0, import_moment.default)().add(addDay, "d");
    const dateYYYYMMDD = dateMoment.format("YYYYMMDD");
    const dateEachYYDD = "\\d\\d\\d\\d" + dateMoment.format("MMDD");
    const dateEachDD = "\\d\\d\\d\\d\\d\\d" + dateMoment.format("DD");
    const dayOfWeek = dateMoment.format("E");
    const dayOfWeekLong = dateMoment.format("ddd");
    const excludeNoteStr = excludeNotes.map((excludeNote) => `-path:"${excludeNote}" `).join("");
    return `## ${dateYYYYMMDD} ${dayOfWeekLong}
\`\`\`query
(" ${dateYYYYMMDD}" OR "${dateYYYYMMDD} " OR ${dateEachYYDD} OR ${dateEachDD} OR tag:#n${dayOfWeek} OR tag:#w${dayOfWeek}) ${excludeNoteStr}-block:(query)
\`\`\`

`;
  }
  getQueryActionsThisWeek(excludeNumDays) {
    let excludes = [];
    let includes = [1, 2, 3, 4, 5, 6, 7];
    Array.from(Array(excludeNumDays).keys()).forEach((i) => {
      const dateMoment = (0, import_moment.default)().add(i, "d");
      const dayOfWeek = parseInt(dateMoment.format("E"));
      excludes.push(dayOfWeek);
    });
    let aaa = includes.filter((i) => {
      for (const e of excludes) {
        if (e == i) {
          return false;
        }
      }
      return true;
    });
    let output = "";
    aaa.forEach((i) => output += ` OR tag:#n${i} OR tag:#w${i}`);
    return output;
  }
  getQueryFutureDaysThisWeek(header, from, to, excludeNotes) {
    let includes = [];
    for (let i = from; i <= to; i++) {
      let dateMoment = (0, import_moment.default)().add(i, "d");
      includes.push(dateMoment);
    }
    let output = `## ${header}
\`\`\`query
(`;
    includes.forEach((i) => {
      const dateYYYYMMDD = i.format("YYYYMMDD");
      const dateEachYYDD = "\\d\\d\\d\\d" + i.format("MMDD");
      const dateEachDD = "\\d\\d\\d\\d\\d\\d" + i.format("DD");
      output += `" ${dateYYYYMMDD}" OR "${dateYYYYMMDD} " OR ${dateEachYYDD} OR ${dateEachDD} OR `;
    });
    output = output.replace(/ OR $/, "");
    output += ")";
    const excludeNoteStr = excludeNotes.map((excludeNote) => `-path:"${excludeNote}" `).join("");
    output += ` ${excludeNoteStr}-block:(query)`;
    output += `
\`\`\`

`;
    return output;
  }
  getQueryNext2MonthString(excludeNotes) {
    const currentMonthYYYYMM = (0, import_moment.default)().format("YYYYMM");
    const dateMoment = (0, import_moment.default)().add(1, "M");
    const nextMonthYYYYMM = dateMoment.format("YYYYMM");
    const excludeNoteStr = excludeNotes.map((excludeNote) => `-path:"${excludeNote}" `).join("");
    return `## ${currentMonthYYYYMM} and ${nextMonthYYYYMM}
\`\`\`query
(${currentMonthYYYYMM}\\d\\d OR ${nextMonthYYYYMM}\\d\\d ${excludeNoteStr}-path:"D/Scheduling" -block:(query)
\`\`\`

`;
  }
  getQueryDateString(addDay, excludeNote) {
    const dateMoment = (0, import_moment.default)().add(addDay, "d");
    const dateYYYYMMDD = dateMoment.format("YYYYMMDD");
    const dateEachYYDD = "\\d\\d\\d\\d" + dateMoment.format("MMDD");
    const dateEachDD = "\\d\\d\\d\\d\\d\\d" + dateMoment.format("DD");
    return `${dateYYYYMMDD}
\`\`\`query
(${dateYYYYMMDD} OR ${dateEachYYDD} OR ${dateEachDD}) -path:"${excludeNote}" -block:(query)
\`\`\`
`;
  }
  getQueryActionString(addDay, actionType) {
    const dateMoment = (0, import_moment.default)().add(addDay, "d");
    const dayOfWeek = dateMoment.format("E");
    return `\`\`\`query
tag:#${actionType}${dayOfWeek}
\`\`\`
`;
  }
  getQueryWeekDay(addDay, actionType) {
    const dateMoment = (0, import_moment.default)().add(addDay, "d");
    const dayOfWeek = dateMoment.format("E");
    return `tag:#${actionType}${dayOfWeek} OR `;
  }
  addNewLaterActionIcon(t) {
    this.addObsidianIcon(`${t}l-icon-new`, `${t}l`);
  }
  addActionIcon(t) {
    this.addObsidianIcon(`${t}-icon`, `#${t}`);
  }
  addObsidianIcon(iconName, iconText) {
    const svg = `<text stroke='#000' transform='matrix(2.79167 0 0 2.12663 -34.0417 -25.2084)' xml:space='preserve' text-anchor='start' font-family='monospace' font-size='24' y='44' x='19' stroke-width='0' fill='currentColor'>${iconText}</text>`;
    (0, import_obsidian21.addIcon)(iconName, svg);
  }
  addNewLaterAction(t) {
    this.addCommand({
      id: `add-new-${t}-later-action`,
      name: `Add ${t}l task`,
      icon: `${t}l-icon-new`,
      editorCallback: (editor, view) => {
        const cursor = editor.getCursor();
        editor.replaceRange(`#${t}l `, cursor);
        cursor.ch = cursor.ch + 4;
        editor.setCursor(cursor);
      },
      hotkeys: [
        {
          modifiers: [`Ctrl`, `Meta`, `Shift`],
          key: t == "n" ? "1" : "2"
        },
        {
          modifiers: [`Ctrl`, `Alt`, `Shift`],
          key: t == "n" ? "1" : "2"
        }
      ]
    });
  }
  addActionCommand(t) {
    this.addCommand({
      id: `to-w${t}-n${t}`,
      name: `To w${t} or n${t}`,
      icon: `${t}-icon`,
      editorCallback: (editor, view) => {
        console.log(editor.getSelection());
        const cursor = editor.getCursor();
        const lineNumber = editor.getCursor().line;
        const line = editor.getLine(lineNumber);
        const replacedLine = line.replace(/ a\/w\/./, ` a/w/${t}`).replace(/ a\/n\/./, ` a/n/${t}`).replace(/#w. /, `#w${t} `).replace(/#n. /, `#n${t} `).replace(/#w.$/, `#w${t}`).replace(/#n.$/, `#n${t}`);
        if (line.contains(`#n${t} `) || line.contains(`#w${t} `)) {
          const nt = `#n${t} `;
          const wt = `#w${t} `;
          const replaceLineToRemoveTag = line.replace(`#n${t} `, ``).replace(`#w${t} `, ``);
          editor.setLine(lineNumber, replaceLineToRemoveTag);
          const ntIndex = line.indexOf(nt);
          const wtIndex = line.indexOf(wt);
          const index = ntIndex == -1 ? wtIndex : ntIndex;
          const newCh = cursor.ch <= index ? cursor.ch : cursor.ch >= index + 4 ? cursor.ch - 4 : index;
          cursor.ch = newCh;
          editor.setCursor(cursor);
        } else if (line.contains(` #n${t}`) || line.contains(` #w${t}`)) {
          const nt = `#n${t} `;
          const wt = `#w${t} `;
          const replaceLineToRemoveTag = line.replace(` #n${t}`, ``).replace(` #w${t}`, ``);
          editor.setLine(lineNumber, replaceLineToRemoveTag);
          const ntIndex = line.indexOf(nt);
          const wtIndex = line.indexOf(wt);
          const index = ntIndex == -1 ? wtIndex : ntIndex;
          const newCh = cursor.ch <= index ? cursor.ch : cursor.ch >= index + 4 ? cursor.ch - 4 : index;
          cursor.ch = newCh;
          editor.setCursor(cursor);
        } else if (line.contains(` a/n/${t}`) || line.contains(` a/w/${t}`)) {
        } else if (replacedLine == line) {
          new AddTaskTagModal(this.app, editor, t).open();
        } else {
          editor.setLine(lineNumber, replacedLine);
          editor.setCursor(cursor);
        }
      },
      hotkeys: [
        {
          modifiers: this.is1To7(t) ? [`Ctrl`, `Meta`] : [`Ctrl`, `Meta`, `Shift`],
          key: `${t}`
        },
        {
          modifiers: this.is1To7(t) ? [`Ctrl`, `Alt`] : [`Ctrl`, `Alt`, `Shift`],
          key: `${t}`
        }
      ]
    });
  }
  addFollowUpCommand(t) {
    let name = "";
    if (t === "t") {
      name = "To Try";
    } else if (t === "e") {
      name = "To Explore";
    } else if (t === "m") {
      name = "To Move";
    }
    this.addCommand({
      id: `to-t${t}`,
      name: `To t${t} ${name}`,
      icon: `${t}-icon`,
      editorCallback: (editor, view) => {
        console.log(editor.getSelection());
        const cursor = editor.getCursor();
        const lineNumber = editor.getCursor().line;
        const line = editor.getLine(lineNumber);
        const replacedLine = line.replace(/#t. /, `#t${t} `).replace(/#t.$/, `#t${t}`);
        if (line.contains(`#t${t} `)) {
          const tt = `#t${t} `;
          const replaceLineToRemoveTag = line.replace(`#t${t} `, ``);
          editor.setLine(lineNumber, replaceLineToRemoveTag);
          const ttIndex = line.indexOf(tt);
          const index = ttIndex;
          const newCh = cursor.ch <= index ? cursor.ch : cursor.ch >= index + 4 ? cursor.ch - 4 : index;
          cursor.ch = newCh;
          editor.setCursor(cursor);
        } else if (line.contains(` #t${t}`)) {
          const tt = `#t${t} `;
          const replaceLineToRemoveTag = line.replace(` #t${t}`, ``);
          editor.setLine(lineNumber, replaceLineToRemoveTag);
          const ttIndex = line.indexOf(tt);
          const index = ttIndex;
          const newCh = cursor.ch <= index ? cursor.ch : cursor.ch >= index + 4 ? cursor.ch - 4 : index;
          cursor.ch = newCh;
          editor.setCursor(cursor);
        } else if (replacedLine == line) {
          const cursor2 = editor.getCursor();
          const line2 = editor.getLine(cursor2.line);
          editor.replaceRange(`${line2.charAt(cursor2.ch - 1) != " " ? " " : ""}#t${t} `, cursor2);
          cursor2.ch = cursor2.ch + 4 + (line2.charAt(cursor2.ch - 1) != " " ? 1 : 0);
          editor.setCursor(cursor2);
        } else {
          editor.setLine(lineNumber, replacedLine);
          editor.setCursor(cursor);
        }
      },
      hotkeys: [
        {
          modifiers: [`Ctrl`, `Meta`, `Shift`],
          key: `${t}`
        },
        {
          modifiers: [`Ctrl`, `Alt`, `Shift`],
          key: `${t}`
        }
      ]
    });
  }
  is1To7(t) {
    if (t == "1" || t == "2" || t == "3" || t == "4" || t == "5" || t == "6" || t == "7") {
      return true;
    } else {
      return false;
    }
  }
  addToClipboardHistory(content) {
    const index = clipboardHistory.indexOf(content, 0);
    if (index > -1) {
      clipboardHistory.splice(index, 1);
    }
    if (content.length > 0) {
      clipboardHistory.push(content);
    }
  }
  onunload() {
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
var SampleSettingTab = class extends import_obsidian20.PluginSettingTab {
  constructor(app2, plugin) {
    super(app2, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Settings for my awesome plugin." });
    new import_obsidian20.Setting(containerEl).setName("Setting #1").setDesc("It's a secret").addText((text) => text.setPlaceholder("Enter your secret").setValue(this.plugin.settings.mySetting).onChange(async (value) => {
      console.log("Secret: " + value);
      this.plugin.settings.mySetting = value;
      await this.plugin.saveSettings();
    }));
  }
};
/*! Bundled license information:

moment/moment.js:
  (*! moment.js *)
  (*! version : 2.29.1 *)
  (*! authors : Tim Wood, Iskren Chernev, Moment.js contributors *)
  (*! license : MIT *)
  (*! momentjs.com *)
*/
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsibm9kZV9tb2R1bGVzL21vbWVudC9tb21lbnQuanMiLCAibWFpbi50cyIsICJ1cGRhdGVOb3RlVHlwZU1vZGFsLnRzIiwgInRhZ3JlbmFtZXIvcmVuYW1pbmcudHMiLCAidGFncmVuYW1lci9UYWcudHMiLCAidGFncmVuYW1lci9GaWxlLnRzIiwgIm5vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9ub2Rlcy9Ob2RlLmpzIiwgIm5vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC92aXNpdC5qcyIsICJub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3QvZG9jL2RpcmVjdGl2ZXMuanMiLCAibm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L2RvYy9hbmNob3JzLmpzIiwgIm5vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9ub2Rlcy9BbGlhcy5qcyIsICJub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3Qvbm9kZXMvdG9KUy5qcyIsICJub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3Qvbm9kZXMvU2NhbGFyLmpzIiwgIm5vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9kb2MvY3JlYXRlTm9kZS5qcyIsICJub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3Qvbm9kZXMvQ29sbGVjdGlvbi5qcyIsICJub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3Qvc3RyaW5naWZ5L3N0cmluZ2lmeUNvbW1lbnQuanMiLCAibm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L3N0cmluZ2lmeS9mb2xkRmxvd0xpbmVzLmpzIiwgIm5vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9zdHJpbmdpZnkvc3RyaW5naWZ5U3RyaW5nLmpzIiwgIm5vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9zdHJpbmdpZnkvc3RyaW5naWZ5LmpzIiwgIm5vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9zdHJpbmdpZnkvc3RyaW5naWZ5UGFpci5qcyIsICJub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3QvbG9nLmpzIiwgIm5vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9ub2Rlcy9hZGRQYWlyVG9KU01hcC5qcyIsICJub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3Qvbm9kZXMvUGFpci5qcyIsICJub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3Qvb3B0aW9ucy5qcyIsICJub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3Qvc3RyaW5naWZ5L3N0cmluZ2lmeUNvbGxlY3Rpb24uanMiLCAibm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L25vZGVzL1lBTUxNYXAuanMiLCAibm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L3NjaGVtYS9jb21tb24vbWFwLmpzIiwgIm5vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9ub2Rlcy9ZQU1MU2VxLmpzIiwgIm5vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9zY2hlbWEvY29tbW9uL3NlcS5qcyIsICJub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3Qvc2NoZW1hL2NvbW1vbi9zdHJpbmcuanMiLCAibm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L3NjaGVtYS9jb21tb24vbnVsbC5qcyIsICJub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3Qvc2NoZW1hL2NvcmUvYm9vbC5qcyIsICJub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3Qvc3RyaW5naWZ5L3N0cmluZ2lmeU51bWJlci5qcyIsICJub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3Qvc2NoZW1hL2NvcmUvZmxvYXQuanMiLCAibm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L3NjaGVtYS9jb3JlL2ludC5qcyIsICJub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3Qvc2NoZW1hL2NvcmUvc2NoZW1hLmpzIiwgIm5vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9zY2hlbWEvanNvbi9zY2hlbWEuanMiLCAibm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L3NjaGVtYS95YW1sLTEuMS9iaW5hcnkuanMiLCAibm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L3NjaGVtYS95YW1sLTEuMS9wYWlycy5qcyIsICJub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3Qvc2NoZW1hL3lhbWwtMS4xL29tYXAuanMiLCAibm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L3NjaGVtYS95YW1sLTEuMS9ib29sLmpzIiwgIm5vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9zY2hlbWEveWFtbC0xLjEvZmxvYXQuanMiLCAibm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L3NjaGVtYS95YW1sLTEuMS9pbnQuanMiLCAibm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L3NjaGVtYS95YW1sLTEuMS9zZXQuanMiLCAibm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L3NjaGVtYS95YW1sLTEuMS90aW1lc3RhbXAuanMiLCAibm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L3NjaGVtYS95YW1sLTEuMS9zY2hlbWEuanMiLCAibm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L3NjaGVtYS90YWdzLmpzIiwgIm5vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9zY2hlbWEvU2NoZW1hLmpzIiwgIm5vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9zdHJpbmdpZnkvc3RyaW5naWZ5RG9jdW1lbnQuanMiLCAibm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L2RvYy9hcHBseVJldml2ZXIuanMiLCAibm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L2RvYy9Eb2N1bWVudC5qcyIsICJub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3QvZXJyb3JzLmpzIiwgIm5vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9jb21wb3NlL3Jlc29sdmUtcHJvcHMuanMiLCAibm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L2NvbXBvc2UvdXRpbC1jb250YWlucy1uZXdsaW5lLmpzIiwgIm5vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9jb21wb3NlL3V0aWwtZmxvdy1pbmRlbnQtY2hlY2suanMiLCAibm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L2NvbXBvc2UvdXRpbC1tYXAtaW5jbHVkZXMuanMiLCAibm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L2NvbXBvc2UvcmVzb2x2ZS1ibG9jay1tYXAuanMiLCAibm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L2NvbXBvc2UvcmVzb2x2ZS1ibG9jay1zZXEuanMiLCAibm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L2NvbXBvc2UvcmVzb2x2ZS1lbmQuanMiLCAibm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L2NvbXBvc2UvcmVzb2x2ZS1mbG93LWNvbGxlY3Rpb24uanMiLCAibm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L2NvbXBvc2UvY29tcG9zZS1jb2xsZWN0aW9uLmpzIiwgIm5vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9jb21wb3NlL3Jlc29sdmUtYmxvY2stc2NhbGFyLmpzIiwgIm5vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9jb21wb3NlL3Jlc29sdmUtZmxvdy1zY2FsYXIuanMiLCAibm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L2NvbXBvc2UvY29tcG9zZS1zY2FsYXIuanMiLCAibm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L2NvbXBvc2UvdXRpbC1lbXB0eS1zY2FsYXItcG9zaXRpb24uanMiLCAibm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L2NvbXBvc2UvY29tcG9zZS1ub2RlLmpzIiwgIm5vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9jb21wb3NlL2NvbXBvc2UtZG9jLmpzIiwgIm5vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9jb21wb3NlL2NvbXBvc2VyLmpzIiwgIm5vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9wYXJzZS9jc3QuanMiLCAibm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L3BhcnNlL2NzdC1zY2FsYXIuanMiLCAibm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L3BhcnNlL2NzdC1zdHJpbmdpZnkuanMiLCAibm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L3BhcnNlL2NzdC12aXNpdC5qcyIsICJub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3QvcGFyc2UvbGV4ZXIuanMiLCAibm9kZV9tb2R1bGVzL3lhbWwvYnJvd3Nlci9kaXN0L3BhcnNlL2xpbmUtY291bnRlci5qcyIsICJub2RlX21vZHVsZXMveWFtbC9icm93c2VyL2Rpc3QvcGFyc2UvcGFyc2VyLmpzIiwgIm5vZGVfbW9kdWxlcy95YW1sL2Jyb3dzZXIvZGlzdC9wdWJsaWMtYXBpLmpzIiwgImFkZENvbW1lbnRUYWdNb2RhbC50cyIsICJhZGRUYXNrVGFnTW9kYWwudHMiLCAiVGhyZWFkc1RvSW1hZ2VzTW9kYWwudHMiLCAiY29weU9yTW92ZVRvTmV3Tm90ZU1vZGFsLnRzIiwgImNsaXBib2FyZFBhc3RlTW9kYWwudHMiLCAib3BlblBsYXlncm91bmRNb2RhbC50cyIsICJ0aHJlYWRzVG9CbG9nTW9kYWwudHMiLCAiY2xpcGJvYXJkUmVtb3ZhbE1vZGFsLnRzIiwgInRhZ1NlYXJjaE1vZGFsLnRzIiwgInNlbGZ1dGlsL2dldEFsbE5vdGVUYWdzLnRzIiwgImFkZFRleHRUb05vdGVzRnJvbVNwZWNpZmljVGFnTW9kYWwudHMiLCAic2VsZnV0aWwvYWRkbGlua3Rvbm90ZXMudHMiLCAic2VsZnV0aWwvZmluZE5vdGVzRnJvbVRhZy50cyIsICJhZGRUZXh0VG9Ob3Rlc01vZGFsLnRzIiwgInNlbGZ1dGlsL2dldFJlY2VudE5vdGVzLnRzIiwgIm5hdmlnYXRlVG9Ob3RlRnJvbVNwZWNpZmljVGFnTW9kYWwudHMiLCAibmF2aWdhdGVUb05vdGVGcm9tVGFnTW9kYWwudHMiLCAic2VsZnV0aWwvZXh0cmFjdFNlbGVjdGlvbi50cyJdLAogICJzb3VyY2VzQ29udGVudCI6IFsiLy8hIG1vbWVudC5qc1xuLy8hIHZlcnNpb24gOiAyLjI5LjFcbi8vISBhdXRob3JzIDogVGltIFdvb2QsIElza3JlbiBDaGVybmV2LCBNb21lbnQuanMgY29udHJpYnV0b3JzXG4vLyEgbGljZW5zZSA6IE1JVFxuLy8hIG1vbWVudGpzLmNvbVxuXG47KGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKSA6XG4gICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKGZhY3RvcnkpIDpcbiAgICBnbG9iYWwubW9tZW50ID0gZmFjdG9yeSgpXG59KHRoaXMsIChmdW5jdGlvbiAoKSB7ICd1c2Ugc3RyaWN0JztcblxuICAgIHZhciBob29rQ2FsbGJhY2s7XG5cbiAgICBmdW5jdGlvbiBob29rcygpIHtcbiAgICAgICAgcmV0dXJuIGhvb2tDYWxsYmFjay5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIC8vIFRoaXMgaXMgZG9uZSB0byByZWdpc3RlciB0aGUgbWV0aG9kIGNhbGxlZCB3aXRoIG1vbWVudCgpXG4gICAgLy8gd2l0aG91dCBjcmVhdGluZyBjaXJjdWxhciBkZXBlbmRlbmNpZXMuXG4gICAgZnVuY3Rpb24gc2V0SG9va0NhbGxiYWNrKGNhbGxiYWNrKSB7XG4gICAgICAgIGhvb2tDYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzQXJyYXkoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIGlucHV0IGluc3RhbmNlb2YgQXJyYXkgfHxcbiAgICAgICAgICAgIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpbnB1dCkgPT09ICdbb2JqZWN0IEFycmF5XSdcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc09iamVjdChpbnB1dCkge1xuICAgICAgICAvLyBJRTggd2lsbCB0cmVhdCB1bmRlZmluZWQgYW5kIG51bGwgYXMgb2JqZWN0IGlmIGl0IHdhc24ndCBmb3JcbiAgICAgICAgLy8gaW5wdXQgIT0gbnVsbFxuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgaW5wdXQgIT0gbnVsbCAmJlxuICAgICAgICAgICAgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGlucHV0KSA9PT0gJ1tvYmplY3QgT2JqZWN0XSdcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYXNPd25Qcm9wKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChhLCBiKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc09iamVjdEVtcHR5KG9iaikge1xuICAgICAgICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvYmopLmxlbmd0aCA9PT0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBrO1xuICAgICAgICAgICAgZm9yIChrIGluIG9iaikge1xuICAgICAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wKG9iaiwgaykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNVbmRlZmluZWQoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0ID09PSB2b2lkIDA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNOdW1iZXIoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHR5cGVvZiBpbnB1dCA9PT0gJ251bWJlcicgfHxcbiAgICAgICAgICAgIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpbnB1dCkgPT09ICdbb2JqZWN0IE51bWJlcl0nXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNEYXRlKGlucHV0KSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBpbnB1dCBpbnN0YW5jZW9mIERhdGUgfHxcbiAgICAgICAgICAgIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpbnB1dCkgPT09ICdbb2JqZWN0IERhdGVdJ1xuICAgICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1hcChhcnIsIGZuKSB7XG4gICAgICAgIHZhciByZXMgPSBbXSxcbiAgICAgICAgICAgIGk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHJlcy5wdXNoKGZuKGFycltpXSwgaSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXh0ZW5kKGEsIGIpIHtcbiAgICAgICAgZm9yICh2YXIgaSBpbiBiKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcChiLCBpKSkge1xuICAgICAgICAgICAgICAgIGFbaV0gPSBiW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGhhc093blByb3AoYiwgJ3RvU3RyaW5nJykpIHtcbiAgICAgICAgICAgIGEudG9TdHJpbmcgPSBiLnRvU3RyaW5nO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGhhc093blByb3AoYiwgJ3ZhbHVlT2YnKSkge1xuICAgICAgICAgICAgYS52YWx1ZU9mID0gYi52YWx1ZU9mO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGE7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlVVRDKGlucHV0LCBmb3JtYXQsIGxvY2FsZSwgc3RyaWN0KSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVMb2NhbE9yVVRDKGlucHV0LCBmb3JtYXQsIGxvY2FsZSwgc3RyaWN0LCB0cnVlKS51dGMoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkZWZhdWx0UGFyc2luZ0ZsYWdzKCkge1xuICAgICAgICAvLyBXZSBuZWVkIHRvIGRlZXAgY2xvbmUgdGhpcyBvYmplY3QuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBlbXB0eTogZmFsc2UsXG4gICAgICAgICAgICB1bnVzZWRUb2tlbnM6IFtdLFxuICAgICAgICAgICAgdW51c2VkSW5wdXQ6IFtdLFxuICAgICAgICAgICAgb3ZlcmZsb3c6IC0yLFxuICAgICAgICAgICAgY2hhcnNMZWZ0T3ZlcjogMCxcbiAgICAgICAgICAgIG51bGxJbnB1dDogZmFsc2UsXG4gICAgICAgICAgICBpbnZhbGlkRXJhOiBudWxsLFxuICAgICAgICAgICAgaW52YWxpZE1vbnRoOiBudWxsLFxuICAgICAgICAgICAgaW52YWxpZEZvcm1hdDogZmFsc2UsXG4gICAgICAgICAgICB1c2VySW52YWxpZGF0ZWQ6IGZhbHNlLFxuICAgICAgICAgICAgaXNvOiBmYWxzZSxcbiAgICAgICAgICAgIHBhcnNlZERhdGVQYXJ0czogW10sXG4gICAgICAgICAgICBlcmE6IG51bGwsXG4gICAgICAgICAgICBtZXJpZGllbTogbnVsbCxcbiAgICAgICAgICAgIHJmYzI4MjI6IGZhbHNlLFxuICAgICAgICAgICAgd2Vla2RheU1pc21hdGNoOiBmYWxzZSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRQYXJzaW5nRmxhZ3MobSkge1xuICAgICAgICBpZiAobS5fcGYgPT0gbnVsbCkge1xuICAgICAgICAgICAgbS5fcGYgPSBkZWZhdWx0UGFyc2luZ0ZsYWdzKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG0uX3BmO1xuICAgIH1cblxuICAgIHZhciBzb21lO1xuICAgIGlmIChBcnJheS5wcm90b3R5cGUuc29tZSkge1xuICAgICAgICBzb21lID0gQXJyYXkucHJvdG90eXBlLnNvbWU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgc29tZSA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICAgICAgICAgIHZhciB0ID0gT2JqZWN0KHRoaXMpLFxuICAgICAgICAgICAgICAgIGxlbiA9IHQubGVuZ3RoID4+PiAwLFxuICAgICAgICAgICAgICAgIGk7XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChpIGluIHQgJiYgZnVuLmNhbGwodGhpcywgdFtpXSwgaSwgdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNWYWxpZChtKSB7XG4gICAgICAgIGlmIChtLl9pc1ZhbGlkID09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBmbGFncyA9IGdldFBhcnNpbmdGbGFncyhtKSxcbiAgICAgICAgICAgICAgICBwYXJzZWRQYXJ0cyA9IHNvbWUuY2FsbChmbGFncy5wYXJzZWREYXRlUGFydHMsIGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpICE9IG51bGw7XG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgaXNOb3dWYWxpZCA9XG4gICAgICAgICAgICAgICAgICAgICFpc05hTihtLl9kLmdldFRpbWUoKSkgJiZcbiAgICAgICAgICAgICAgICAgICAgZmxhZ3Mub3ZlcmZsb3cgPCAwICYmXG4gICAgICAgICAgICAgICAgICAgICFmbGFncy5lbXB0eSAmJlxuICAgICAgICAgICAgICAgICAgICAhZmxhZ3MuaW52YWxpZEVyYSAmJlxuICAgICAgICAgICAgICAgICAgICAhZmxhZ3MuaW52YWxpZE1vbnRoICYmXG4gICAgICAgICAgICAgICAgICAgICFmbGFncy5pbnZhbGlkV2Vla2RheSAmJlxuICAgICAgICAgICAgICAgICAgICAhZmxhZ3Mud2Vla2RheU1pc21hdGNoICYmXG4gICAgICAgICAgICAgICAgICAgICFmbGFncy5udWxsSW5wdXQgJiZcbiAgICAgICAgICAgICAgICAgICAgIWZsYWdzLmludmFsaWRGb3JtYXQgJiZcbiAgICAgICAgICAgICAgICAgICAgIWZsYWdzLnVzZXJJbnZhbGlkYXRlZCAmJlxuICAgICAgICAgICAgICAgICAgICAoIWZsYWdzLm1lcmlkaWVtIHx8IChmbGFncy5tZXJpZGllbSAmJiBwYXJzZWRQYXJ0cykpO1xuXG4gICAgICAgICAgICBpZiAobS5fc3RyaWN0KSB7XG4gICAgICAgICAgICAgICAgaXNOb3dWYWxpZCA9XG4gICAgICAgICAgICAgICAgICAgIGlzTm93VmFsaWQgJiZcbiAgICAgICAgICAgICAgICAgICAgZmxhZ3MuY2hhcnNMZWZ0T3ZlciA9PT0gMCAmJlxuICAgICAgICAgICAgICAgICAgICBmbGFncy51bnVzZWRUb2tlbnMubGVuZ3RoID09PSAwICYmXG4gICAgICAgICAgICAgICAgICAgIGZsYWdzLmJpZ0hvdXIgPT09IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKE9iamVjdC5pc0Zyb3plbiA9PSBudWxsIHx8ICFPYmplY3QuaXNGcm96ZW4obSkpIHtcbiAgICAgICAgICAgICAgICBtLl9pc1ZhbGlkID0gaXNOb3dWYWxpZDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzTm93VmFsaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG0uX2lzVmFsaWQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlSW52YWxpZChmbGFncykge1xuICAgICAgICB2YXIgbSA9IGNyZWF0ZVVUQyhOYU4pO1xuICAgICAgICBpZiAoZmxhZ3MgIT0gbnVsbCkge1xuICAgICAgICAgICAgZXh0ZW5kKGdldFBhcnNpbmdGbGFncyhtKSwgZmxhZ3MpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKG0pLnVzZXJJbnZhbGlkYXRlZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbTtcbiAgICB9XG5cbiAgICAvLyBQbHVnaW5zIHRoYXQgYWRkIHByb3BlcnRpZXMgc2hvdWxkIGFsc28gYWRkIHRoZSBrZXkgaGVyZSAobnVsbCB2YWx1ZSksXG4gICAgLy8gc28gd2UgY2FuIHByb3Blcmx5IGNsb25lIG91cnNlbHZlcy5cbiAgICB2YXIgbW9tZW50UHJvcGVydGllcyA9IChob29rcy5tb21lbnRQcm9wZXJ0aWVzID0gW10pLFxuICAgICAgICB1cGRhdGVJblByb2dyZXNzID0gZmFsc2U7XG5cbiAgICBmdW5jdGlvbiBjb3B5Q29uZmlnKHRvLCBmcm9tKSB7XG4gICAgICAgIHZhciBpLCBwcm9wLCB2YWw7XG5cbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9pc0FNb21lbnRPYmplY3QpKSB7XG4gICAgICAgICAgICB0by5faXNBTW9tZW50T2JqZWN0ID0gZnJvbS5faXNBTW9tZW50T2JqZWN0O1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5faSkpIHtcbiAgICAgICAgICAgIHRvLl9pID0gZnJvbS5faTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX2YpKSB7XG4gICAgICAgICAgICB0by5fZiA9IGZyb20uX2Y7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9sKSkge1xuICAgICAgICAgICAgdG8uX2wgPSBmcm9tLl9sO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5fc3RyaWN0KSkge1xuICAgICAgICAgICAgdG8uX3N0cmljdCA9IGZyb20uX3N0cmljdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX3R6bSkpIHtcbiAgICAgICAgICAgIHRvLl90em0gPSBmcm9tLl90em07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9pc1VUQykpIHtcbiAgICAgICAgICAgIHRvLl9pc1VUQyA9IGZyb20uX2lzVVRDO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5fb2Zmc2V0KSkge1xuICAgICAgICAgICAgdG8uX29mZnNldCA9IGZyb20uX29mZnNldDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX3BmKSkge1xuICAgICAgICAgICAgdG8uX3BmID0gZ2V0UGFyc2luZ0ZsYWdzKGZyb20pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5fbG9jYWxlKSkge1xuICAgICAgICAgICAgdG8uX2xvY2FsZSA9IGZyb20uX2xvY2FsZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtb21lbnRQcm9wZXJ0aWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBtb21lbnRQcm9wZXJ0aWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcHJvcCA9IG1vbWVudFByb3BlcnRpZXNbaV07XG4gICAgICAgICAgICAgICAgdmFsID0gZnJvbVtwcm9wXTtcbiAgICAgICAgICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKHZhbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9bcHJvcF0gPSB2YWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRvO1xuICAgIH1cblxuICAgIC8vIE1vbWVudCBwcm90b3R5cGUgb2JqZWN0XG4gICAgZnVuY3Rpb24gTW9tZW50KGNvbmZpZykge1xuICAgICAgICBjb3B5Q29uZmlnKHRoaXMsIGNvbmZpZyk7XG4gICAgICAgIHRoaXMuX2QgPSBuZXcgRGF0ZShjb25maWcuX2QgIT0gbnVsbCA/IGNvbmZpZy5fZC5nZXRUaW1lKCkgOiBOYU4pO1xuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICB0aGlzLl9kID0gbmV3IERhdGUoTmFOKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBQcmV2ZW50IGluZmluaXRlIGxvb3AgaW4gY2FzZSB1cGRhdGVPZmZzZXQgY3JlYXRlcyBuZXcgbW9tZW50XG4gICAgICAgIC8vIG9iamVjdHMuXG4gICAgICAgIGlmICh1cGRhdGVJblByb2dyZXNzID09PSBmYWxzZSkge1xuICAgICAgICAgICAgdXBkYXRlSW5Qcm9ncmVzcyA9IHRydWU7XG4gICAgICAgICAgICBob29rcy51cGRhdGVPZmZzZXQodGhpcyk7XG4gICAgICAgICAgICB1cGRhdGVJblByb2dyZXNzID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc01vbWVudChvYmopIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIG9iaiBpbnN0YW5jZW9mIE1vbWVudCB8fCAob2JqICE9IG51bGwgJiYgb2JqLl9pc0FNb21lbnRPYmplY3QgIT0gbnVsbClcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB3YXJuKG1zZykge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgICBob29rcy5zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZ3MgPT09IGZhbHNlICYmXG4gICAgICAgICAgICB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgIGNvbnNvbGUud2FyblxuICAgICAgICApIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignRGVwcmVjYXRpb24gd2FybmluZzogJyArIG1zZyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkZXByZWNhdGUobXNnLCBmbikge1xuICAgICAgICB2YXIgZmlyc3RUaW1lID0gdHJ1ZTtcblxuICAgICAgICByZXR1cm4gZXh0ZW5kKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChob29rcy5kZXByZWNhdGlvbkhhbmRsZXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGhvb2tzLmRlcHJlY2F0aW9uSGFuZGxlcihudWxsLCBtc2cpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZpcnN0VGltZSkge1xuICAgICAgICAgICAgICAgIHZhciBhcmdzID0gW10sXG4gICAgICAgICAgICAgICAgICAgIGFyZyxcbiAgICAgICAgICAgICAgICAgICAgaSxcbiAgICAgICAgICAgICAgICAgICAga2V5O1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgYXJnID0gJyc7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgYXJndW1lbnRzW2ldID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJnICs9ICdcXG5bJyArIGkgKyAnXSAnO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChrZXkgaW4gYXJndW1lbnRzWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhhc093blByb3AoYXJndW1lbnRzWzBdLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZyArPSBrZXkgKyAnOiAnICsgYXJndW1lbnRzWzBdW2tleV0gKyAnLCAnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZyA9IGFyZy5zbGljZSgwLCAtMik7IC8vIFJlbW92ZSB0cmFpbGluZyBjb21tYSBhbmQgc3BhY2VcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBhcmdzLnB1c2goYXJnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgd2FybihcbiAgICAgICAgICAgICAgICAgICAgbXNnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdcXG5Bcmd1bWVudHM6ICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJncykuam9pbignJykgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ1xcbicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3IEVycm9yKCkuc3RhY2tcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGZpcnN0VGltZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0sIGZuKTtcbiAgICB9XG5cbiAgICB2YXIgZGVwcmVjYXRpb25zID0ge307XG5cbiAgICBmdW5jdGlvbiBkZXByZWNhdGVTaW1wbGUobmFtZSwgbXNnKSB7XG4gICAgICAgIGlmIChob29rcy5kZXByZWNhdGlvbkhhbmRsZXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgaG9va3MuZGVwcmVjYXRpb25IYW5kbGVyKG5hbWUsIG1zZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkZXByZWNhdGlvbnNbbmFtZV0pIHtcbiAgICAgICAgICAgIHdhcm4obXNnKTtcbiAgICAgICAgICAgIGRlcHJlY2F0aW9uc1tuYW1lXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBob29rcy5zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZ3MgPSBmYWxzZTtcbiAgICBob29rcy5kZXByZWNhdGlvbkhhbmRsZXIgPSBudWxsO1xuXG4gICAgZnVuY3Rpb24gaXNGdW5jdGlvbihpbnB1dCkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgKHR5cGVvZiBGdW5jdGlvbiAhPT0gJ3VuZGVmaW5lZCcgJiYgaW5wdXQgaW5zdGFuY2VvZiBGdW5jdGlvbikgfHxcbiAgICAgICAgICAgIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpbnB1dCkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSdcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXQoY29uZmlnKSB7XG4gICAgICAgIHZhciBwcm9wLCBpO1xuICAgICAgICBmb3IgKGkgaW4gY29uZmlnKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcChjb25maWcsIGkpKSB7XG4gICAgICAgICAgICAgICAgcHJvcCA9IGNvbmZpZ1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoaXNGdW5jdGlvbihwcm9wKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzW2ldID0gcHJvcDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzWydfJyArIGldID0gcHJvcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY29uZmlnID0gY29uZmlnO1xuICAgICAgICAvLyBMZW5pZW50IG9yZGluYWwgcGFyc2luZyBhY2NlcHRzIGp1c3QgYSBudW1iZXIgaW4gYWRkaXRpb24gdG9cbiAgICAgICAgLy8gbnVtYmVyICsgKHBvc3NpYmx5KSBzdHVmZiBjb21pbmcgZnJvbSBfZGF5T2ZNb250aE9yZGluYWxQYXJzZS5cbiAgICAgICAgLy8gVE9ETzogUmVtb3ZlIFwib3JkaW5hbFBhcnNlXCIgZmFsbGJhY2sgaW4gbmV4dCBtYWpvciByZWxlYXNlLlxuICAgICAgICB0aGlzLl9kYXlPZk1vbnRoT3JkaW5hbFBhcnNlTGVuaWVudCA9IG5ldyBSZWdFeHAoXG4gICAgICAgICAgICAodGhpcy5fZGF5T2ZNb250aE9yZGluYWxQYXJzZS5zb3VyY2UgfHwgdGhpcy5fb3JkaW5hbFBhcnNlLnNvdXJjZSkgK1xuICAgICAgICAgICAgICAgICd8JyArXG4gICAgICAgICAgICAgICAgL1xcZHsxLDJ9Ly5zb3VyY2VcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtZXJnZUNvbmZpZ3MocGFyZW50Q29uZmlnLCBjaGlsZENvbmZpZykge1xuICAgICAgICB2YXIgcmVzID0gZXh0ZW5kKHt9LCBwYXJlbnRDb25maWcpLFxuICAgICAgICAgICAgcHJvcDtcbiAgICAgICAgZm9yIChwcm9wIGluIGNoaWxkQ29uZmlnKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcChjaGlsZENvbmZpZywgcHJvcCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNPYmplY3QocGFyZW50Q29uZmlnW3Byb3BdKSAmJiBpc09iamVjdChjaGlsZENvbmZpZ1twcm9wXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzW3Byb3BdID0ge307XG4gICAgICAgICAgICAgICAgICAgIGV4dGVuZChyZXNbcHJvcF0sIHBhcmVudENvbmZpZ1twcm9wXSk7XG4gICAgICAgICAgICAgICAgICAgIGV4dGVuZChyZXNbcHJvcF0sIGNoaWxkQ29uZmlnW3Byb3BdKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNoaWxkQ29uZmlnW3Byb3BdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzW3Byb3BdID0gY2hpbGRDb25maWdbcHJvcF07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHJlc1twcm9wXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChwcm9wIGluIHBhcmVudENvbmZpZykge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIGhhc093blByb3AocGFyZW50Q29uZmlnLCBwcm9wKSAmJlxuICAgICAgICAgICAgICAgICFoYXNPd25Qcm9wKGNoaWxkQ29uZmlnLCBwcm9wKSAmJlxuICAgICAgICAgICAgICAgIGlzT2JqZWN0KHBhcmVudENvbmZpZ1twcm9wXSlcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSBjaGFuZ2VzIHRvIHByb3BlcnRpZXMgZG9uJ3QgbW9kaWZ5IHBhcmVudCBjb25maWdcbiAgICAgICAgICAgICAgICByZXNbcHJvcF0gPSBleHRlbmQoe30sIHJlc1twcm9wXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBMb2NhbGUoY29uZmlnKSB7XG4gICAgICAgIGlmIChjb25maWcgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5zZXQoY29uZmlnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBrZXlzO1xuXG4gICAgaWYgKE9iamVjdC5rZXlzKSB7XG4gICAgICAgIGtleXMgPSBPYmplY3Qua2V5cztcbiAgICB9IGVsc2Uge1xuICAgICAgICBrZXlzID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgICAgdmFyIGksXG4gICAgICAgICAgICAgICAgcmVzID0gW107XG4gICAgICAgICAgICBmb3IgKGkgaW4gb2JqKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhhc093blByb3Aob2JqLCBpKSkge1xuICAgICAgICAgICAgICAgICAgICByZXMucHVzaChpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0Q2FsZW5kYXIgPSB7XG4gICAgICAgIHNhbWVEYXk6ICdbVG9kYXkgYXRdIExUJyxcbiAgICAgICAgbmV4dERheTogJ1tUb21vcnJvdyBhdF0gTFQnLFxuICAgICAgICBuZXh0V2VlazogJ2RkZGQgW2F0XSBMVCcsXG4gICAgICAgIGxhc3REYXk6ICdbWWVzdGVyZGF5IGF0XSBMVCcsXG4gICAgICAgIGxhc3RXZWVrOiAnW0xhc3RdIGRkZGQgW2F0XSBMVCcsXG4gICAgICAgIHNhbWVFbHNlOiAnTCcsXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGNhbGVuZGFyKGtleSwgbW9tLCBub3cpIHtcbiAgICAgICAgdmFyIG91dHB1dCA9IHRoaXMuX2NhbGVuZGFyW2tleV0gfHwgdGhpcy5fY2FsZW5kYXJbJ3NhbWVFbHNlJ107XG4gICAgICAgIHJldHVybiBpc0Z1bmN0aW9uKG91dHB1dCkgPyBvdXRwdXQuY2FsbChtb20sIG5vdykgOiBvdXRwdXQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gemVyb0ZpbGwobnVtYmVyLCB0YXJnZXRMZW5ndGgsIGZvcmNlU2lnbikge1xuICAgICAgICB2YXIgYWJzTnVtYmVyID0gJycgKyBNYXRoLmFicyhudW1iZXIpLFxuICAgICAgICAgICAgemVyb3NUb0ZpbGwgPSB0YXJnZXRMZW5ndGggLSBhYnNOdW1iZXIubGVuZ3RoLFxuICAgICAgICAgICAgc2lnbiA9IG51bWJlciA+PSAwO1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgKHNpZ24gPyAoZm9yY2VTaWduID8gJysnIDogJycpIDogJy0nKSArXG4gICAgICAgICAgICBNYXRoLnBvdygxMCwgTWF0aC5tYXgoMCwgemVyb3NUb0ZpbGwpKS50b1N0cmluZygpLnN1YnN0cigxKSArXG4gICAgICAgICAgICBhYnNOdW1iZXJcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICB2YXIgZm9ybWF0dGluZ1Rva2VucyA9IC8oXFxbW15cXFtdKlxcXSl8KFxcXFwpPyhbSGhdbW0oc3MpP3xNb3xNTT9NP00/fERvfERERG98REQ/RD9EP3xkZGQ/ZD98ZG8/fHdbb3x3XT98V1tvfFddP3xRbz98TnsxLDV9fFlZWVlZWXxZWVlZWXxZWVlZfFlZfHl7Miw0fXx5bz98Z2coZ2dnPyk/fEdHKEdHRz8pP3xlfEV8YXxBfGhoP3xISD98a2s/fG1tP3xzcz98U3sxLDl9fHh8WHx6ej98Wlo/fC4pL2csXG4gICAgICAgIGxvY2FsRm9ybWF0dGluZ1Rva2VucyA9IC8oXFxbW15cXFtdKlxcXSl8KFxcXFwpPyhMVFN8TFR8TEw/TD9MP3xsezEsNH0pL2csXG4gICAgICAgIGZvcm1hdEZ1bmN0aW9ucyA9IHt9LFxuICAgICAgICBmb3JtYXRUb2tlbkZ1bmN0aW9ucyA9IHt9O1xuXG4gICAgLy8gdG9rZW46ICAgICdNJ1xuICAgIC8vIHBhZGRlZDogICBbJ01NJywgMl1cbiAgICAvLyBvcmRpbmFsOiAgJ01vJ1xuICAgIC8vIGNhbGxiYWNrOiBmdW5jdGlvbiAoKSB7IHRoaXMubW9udGgoKSArIDEgfVxuICAgIGZ1bmN0aW9uIGFkZEZvcm1hdFRva2VuKHRva2VuLCBwYWRkZWQsIG9yZGluYWwsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBmdW5jID0gY2FsbGJhY2s7XG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBmdW5jID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzW2NhbGxiYWNrXSgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodG9rZW4pIHtcbiAgICAgICAgICAgIGZvcm1hdFRva2VuRnVuY3Rpb25zW3Rva2VuXSA9IGZ1bmM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhZGRlZCkge1xuICAgICAgICAgICAgZm9ybWF0VG9rZW5GdW5jdGlvbnNbcGFkZGVkWzBdXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gemVyb0ZpbGwoZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpLCBwYWRkZWRbMV0sIHBhZGRlZFsyXSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcmRpbmFsKSB7XG4gICAgICAgICAgICBmb3JtYXRUb2tlbkZ1bmN0aW9uc1tvcmRpbmFsXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkub3JkaW5hbChcbiAgICAgICAgICAgICAgICAgICAgZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpLFxuICAgICAgICAgICAgICAgICAgICB0b2tlblxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVtb3ZlRm9ybWF0dGluZ1Rva2VucyhpbnB1dCkge1xuICAgICAgICBpZiAoaW5wdXQubWF0Y2goL1xcW1tcXHNcXFNdLykpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dC5yZXBsYWNlKC9eXFxbfFxcXSQvZywgJycpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbnB1dC5yZXBsYWNlKC9cXFxcL2csICcnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYWtlRm9ybWF0RnVuY3Rpb24oZm9ybWF0KSB7XG4gICAgICAgIHZhciBhcnJheSA9IGZvcm1hdC5tYXRjaChmb3JtYXR0aW5nVG9rZW5zKSxcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICBsZW5ndGg7XG5cbiAgICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gYXJyYXkubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChmb3JtYXRUb2tlbkZ1bmN0aW9uc1thcnJheVtpXV0pIHtcbiAgICAgICAgICAgICAgICBhcnJheVtpXSA9IGZvcm1hdFRva2VuRnVuY3Rpb25zW2FycmF5W2ldXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYXJyYXlbaV0gPSByZW1vdmVGb3JtYXR0aW5nVG9rZW5zKGFycmF5W2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAobW9tKSB7XG4gICAgICAgICAgICB2YXIgb3V0cHV0ID0gJycsXG4gICAgICAgICAgICAgICAgaTtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIG91dHB1dCArPSBpc0Z1bmN0aW9uKGFycmF5W2ldKVxuICAgICAgICAgICAgICAgICAgICA/IGFycmF5W2ldLmNhbGwobW9tLCBmb3JtYXQpXG4gICAgICAgICAgICAgICAgICAgIDogYXJyYXlbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIGZvcm1hdCBkYXRlIHVzaW5nIG5hdGl2ZSBkYXRlIG9iamVjdFxuICAgIGZ1bmN0aW9uIGZvcm1hdE1vbWVudChtLCBmb3JtYXQpIHtcbiAgICAgICAgaWYgKCFtLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIG0ubG9jYWxlRGF0YSgpLmludmFsaWREYXRlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3JtYXQgPSBleHBhbmRGb3JtYXQoZm9ybWF0LCBtLmxvY2FsZURhdGEoKSk7XG4gICAgICAgIGZvcm1hdEZ1bmN0aW9uc1tmb3JtYXRdID1cbiAgICAgICAgICAgIGZvcm1hdEZ1bmN0aW9uc1tmb3JtYXRdIHx8IG1ha2VGb3JtYXRGdW5jdGlvbihmb3JtYXQpO1xuXG4gICAgICAgIHJldHVybiBmb3JtYXRGdW5jdGlvbnNbZm9ybWF0XShtKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBleHBhbmRGb3JtYXQoZm9ybWF0LCBsb2NhbGUpIHtcbiAgICAgICAgdmFyIGkgPSA1O1xuXG4gICAgICAgIGZ1bmN0aW9uIHJlcGxhY2VMb25nRGF0ZUZvcm1hdFRva2VucyhpbnB1dCkge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsZS5sb25nRGF0ZUZvcm1hdChpbnB1dCkgfHwgaW5wdXQ7XG4gICAgICAgIH1cblxuICAgICAgICBsb2NhbEZvcm1hdHRpbmdUb2tlbnMubGFzdEluZGV4ID0gMDtcbiAgICAgICAgd2hpbGUgKGkgPj0gMCAmJiBsb2NhbEZvcm1hdHRpbmdUb2tlbnMudGVzdChmb3JtYXQpKSB7XG4gICAgICAgICAgICBmb3JtYXQgPSBmb3JtYXQucmVwbGFjZShcbiAgICAgICAgICAgICAgICBsb2NhbEZvcm1hdHRpbmdUb2tlbnMsXG4gICAgICAgICAgICAgICAgcmVwbGFjZUxvbmdEYXRlRm9ybWF0VG9rZW5zXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgbG9jYWxGb3JtYXR0aW5nVG9rZW5zLmxhc3RJbmRleCA9IDA7XG4gICAgICAgICAgICBpIC09IDE7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZm9ybWF0O1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0TG9uZ0RhdGVGb3JtYXQgPSB7XG4gICAgICAgIExUUzogJ2g6bW06c3MgQScsXG4gICAgICAgIExUOiAnaDptbSBBJyxcbiAgICAgICAgTDogJ01NL0REL1lZWVknLFxuICAgICAgICBMTDogJ01NTU0gRCwgWVlZWScsXG4gICAgICAgIExMTDogJ01NTU0gRCwgWVlZWSBoOm1tIEEnLFxuICAgICAgICBMTExMOiAnZGRkZCwgTU1NTSBELCBZWVlZIGg6bW0gQScsXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGxvbmdEYXRlRm9ybWF0KGtleSkge1xuICAgICAgICB2YXIgZm9ybWF0ID0gdGhpcy5fbG9uZ0RhdGVGb3JtYXRba2V5XSxcbiAgICAgICAgICAgIGZvcm1hdFVwcGVyID0gdGhpcy5fbG9uZ0RhdGVGb3JtYXRba2V5LnRvVXBwZXJDYXNlKCldO1xuXG4gICAgICAgIGlmIChmb3JtYXQgfHwgIWZvcm1hdFVwcGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gZm9ybWF0O1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fbG9uZ0RhdGVGb3JtYXRba2V5XSA9IGZvcm1hdFVwcGVyXG4gICAgICAgICAgICAubWF0Y2goZm9ybWF0dGluZ1Rva2VucylcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKHRvaykge1xuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgdG9rID09PSAnTU1NTScgfHxcbiAgICAgICAgICAgICAgICAgICAgdG9rID09PSAnTU0nIHx8XG4gICAgICAgICAgICAgICAgICAgIHRvayA9PT0gJ0REJyB8fFxuICAgICAgICAgICAgICAgICAgICB0b2sgPT09ICdkZGRkJ1xuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG9rLnNsaWNlKDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdG9rO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5qb2luKCcnKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5fbG9uZ0RhdGVGb3JtYXRba2V5XTtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdEludmFsaWREYXRlID0gJ0ludmFsaWQgZGF0ZSc7XG5cbiAgICBmdW5jdGlvbiBpbnZhbGlkRGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludmFsaWREYXRlO1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0T3JkaW5hbCA9ICclZCcsXG4gICAgICAgIGRlZmF1bHREYXlPZk1vbnRoT3JkaW5hbFBhcnNlID0gL1xcZHsxLDJ9LztcblxuICAgIGZ1bmN0aW9uIG9yZGluYWwobnVtYmVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9vcmRpbmFsLnJlcGxhY2UoJyVkJywgbnVtYmVyKTtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdFJlbGF0aXZlVGltZSA9IHtcbiAgICAgICAgZnV0dXJlOiAnaW4gJXMnLFxuICAgICAgICBwYXN0OiAnJXMgYWdvJyxcbiAgICAgICAgczogJ2EgZmV3IHNlY29uZHMnLFxuICAgICAgICBzczogJyVkIHNlY29uZHMnLFxuICAgICAgICBtOiAnYSBtaW51dGUnLFxuICAgICAgICBtbTogJyVkIG1pbnV0ZXMnLFxuICAgICAgICBoOiAnYW4gaG91cicsXG4gICAgICAgIGhoOiAnJWQgaG91cnMnLFxuICAgICAgICBkOiAnYSBkYXknLFxuICAgICAgICBkZDogJyVkIGRheXMnLFxuICAgICAgICB3OiAnYSB3ZWVrJyxcbiAgICAgICAgd3c6ICclZCB3ZWVrcycsXG4gICAgICAgIE06ICdhIG1vbnRoJyxcbiAgICAgICAgTU06ICclZCBtb250aHMnLFxuICAgICAgICB5OiAnYSB5ZWFyJyxcbiAgICAgICAgeXk6ICclZCB5ZWFycycsXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHJlbGF0aXZlVGltZShudW1iZXIsIHdpdGhvdXRTdWZmaXgsIHN0cmluZywgaXNGdXR1cmUpIHtcbiAgICAgICAgdmFyIG91dHB1dCA9IHRoaXMuX3JlbGF0aXZlVGltZVtzdHJpbmddO1xuICAgICAgICByZXR1cm4gaXNGdW5jdGlvbihvdXRwdXQpXG4gICAgICAgICAgICA/IG91dHB1dChudW1iZXIsIHdpdGhvdXRTdWZmaXgsIHN0cmluZywgaXNGdXR1cmUpXG4gICAgICAgICAgICA6IG91dHB1dC5yZXBsYWNlKC8lZC9pLCBudW1iZXIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhc3RGdXR1cmUoZGlmZiwgb3V0cHV0KSB7XG4gICAgICAgIHZhciBmb3JtYXQgPSB0aGlzLl9yZWxhdGl2ZVRpbWVbZGlmZiA+IDAgPyAnZnV0dXJlJyA6ICdwYXN0J107XG4gICAgICAgIHJldHVybiBpc0Z1bmN0aW9uKGZvcm1hdCkgPyBmb3JtYXQob3V0cHV0KSA6IGZvcm1hdC5yZXBsYWNlKC8lcy9pLCBvdXRwdXQpO1xuICAgIH1cblxuICAgIHZhciBhbGlhc2VzID0ge307XG5cbiAgICBmdW5jdGlvbiBhZGRVbml0QWxpYXModW5pdCwgc2hvcnRoYW5kKSB7XG4gICAgICAgIHZhciBsb3dlckNhc2UgPSB1bml0LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGFsaWFzZXNbbG93ZXJDYXNlXSA9IGFsaWFzZXNbbG93ZXJDYXNlICsgJ3MnXSA9IGFsaWFzZXNbc2hvcnRoYW5kXSA9IHVuaXQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbm9ybWFsaXplVW5pdHModW5pdHMpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB1bml0cyA9PT0gJ3N0cmluZydcbiAgICAgICAgICAgID8gYWxpYXNlc1t1bml0c10gfHwgYWxpYXNlc1t1bml0cy50b0xvd2VyQ2FzZSgpXVxuICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbm9ybWFsaXplT2JqZWN0VW5pdHMoaW5wdXRPYmplY3QpIHtcbiAgICAgICAgdmFyIG5vcm1hbGl6ZWRJbnB1dCA9IHt9LFxuICAgICAgICAgICAgbm9ybWFsaXplZFByb3AsXG4gICAgICAgICAgICBwcm9wO1xuXG4gICAgICAgIGZvciAocHJvcCBpbiBpbnB1dE9iamVjdCkge1xuICAgICAgICAgICAgaWYgKGhhc093blByb3AoaW5wdXRPYmplY3QsIHByb3ApKSB7XG4gICAgICAgICAgICAgICAgbm9ybWFsaXplZFByb3AgPSBub3JtYWxpemVVbml0cyhwcm9wKTtcbiAgICAgICAgICAgICAgICBpZiAobm9ybWFsaXplZFByb3ApIHtcbiAgICAgICAgICAgICAgICAgICAgbm9ybWFsaXplZElucHV0W25vcm1hbGl6ZWRQcm9wXSA9IGlucHV0T2JqZWN0W3Byb3BdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBub3JtYWxpemVkSW5wdXQ7XG4gICAgfVxuXG4gICAgdmFyIHByaW9yaXRpZXMgPSB7fTtcblxuICAgIGZ1bmN0aW9uIGFkZFVuaXRQcmlvcml0eSh1bml0LCBwcmlvcml0eSkge1xuICAgICAgICBwcmlvcml0aWVzW3VuaXRdID0gcHJpb3JpdHk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0UHJpb3JpdGl6ZWRVbml0cyh1bml0c09iaikge1xuICAgICAgICB2YXIgdW5pdHMgPSBbXSxcbiAgICAgICAgICAgIHU7XG4gICAgICAgIGZvciAodSBpbiB1bml0c09iaikge1xuICAgICAgICAgICAgaWYgKGhhc093blByb3AodW5pdHNPYmosIHUpKSB7XG4gICAgICAgICAgICAgICAgdW5pdHMucHVzaCh7IHVuaXQ6IHUsIHByaW9yaXR5OiBwcmlvcml0aWVzW3VdIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHVuaXRzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgIHJldHVybiBhLnByaW9yaXR5IC0gYi5wcmlvcml0eTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB1bml0cztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0xlYXBZZWFyKHllYXIpIHtcbiAgICAgICAgcmV0dXJuICh5ZWFyICUgNCA9PT0gMCAmJiB5ZWFyICUgMTAwICE9PSAwKSB8fCB5ZWFyICUgNDAwID09PSAwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFic0Zsb29yKG51bWJlcikge1xuICAgICAgICBpZiAobnVtYmVyIDwgMCkge1xuICAgICAgICAgICAgLy8gLTAgLT4gMFxuICAgICAgICAgICAgcmV0dXJuIE1hdGguY2VpbChudW1iZXIpIHx8IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihudW1iZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9JbnQoYXJndW1lbnRGb3JDb2VyY2lvbikge1xuICAgICAgICB2YXIgY29lcmNlZE51bWJlciA9ICthcmd1bWVudEZvckNvZXJjaW9uLFxuICAgICAgICAgICAgdmFsdWUgPSAwO1xuXG4gICAgICAgIGlmIChjb2VyY2VkTnVtYmVyICE9PSAwICYmIGlzRmluaXRlKGNvZXJjZWROdW1iZXIpKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGFic0Zsb29yKGNvZXJjZWROdW1iZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1ha2VHZXRTZXQodW5pdCwga2VlcFRpbWUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBzZXQkMSh0aGlzLCB1bml0LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgaG9va3MudXBkYXRlT2Zmc2V0KHRoaXMsIGtlZXBUaW1lKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldCh0aGlzLCB1bml0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXQobW9tLCB1bml0KSB7XG4gICAgICAgIHJldHVybiBtb20uaXNWYWxpZCgpXG4gICAgICAgICAgICA/IG1vbS5fZFsnZ2V0JyArIChtb20uX2lzVVRDID8gJ1VUQycgOiAnJykgKyB1bml0XSgpXG4gICAgICAgICAgICA6IE5hTjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXQkMShtb20sIHVuaXQsIHZhbHVlKSB7XG4gICAgICAgIGlmIChtb20uaXNWYWxpZCgpICYmICFpc05hTih2YWx1ZSkpIHtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICB1bml0ID09PSAnRnVsbFllYXInICYmXG4gICAgICAgICAgICAgICAgaXNMZWFwWWVhcihtb20ueWVhcigpKSAmJlxuICAgICAgICAgICAgICAgIG1vbS5tb250aCgpID09PSAxICYmXG4gICAgICAgICAgICAgICAgbW9tLmRhdGUoKSA9PT0gMjlcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdG9JbnQodmFsdWUpO1xuICAgICAgICAgICAgICAgIG1vbS5fZFsnc2V0JyArIChtb20uX2lzVVRDID8gJ1VUQycgOiAnJykgKyB1bml0XShcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIG1vbS5tb250aCgpLFxuICAgICAgICAgICAgICAgICAgICBkYXlzSW5Nb250aCh2YWx1ZSwgbW9tLm1vbnRoKCkpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbW9tLl9kWydzZXQnICsgKG1vbS5faXNVVEMgPyAnVVRDJyA6ICcnKSArIHVuaXRdKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIE1PTUVOVFNcblxuICAgIGZ1bmN0aW9uIHN0cmluZ0dldCh1bml0cykge1xuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcbiAgICAgICAgaWYgKGlzRnVuY3Rpb24odGhpc1t1bml0c10pKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpc1t1bml0c10oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzdHJpbmdTZXQodW5pdHMsIHZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdW5pdHMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZU9iamVjdFVuaXRzKHVuaXRzKTtcbiAgICAgICAgICAgIHZhciBwcmlvcml0aXplZCA9IGdldFByaW9yaXRpemVkVW5pdHModW5pdHMpLFxuICAgICAgICAgICAgICAgIGk7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcHJpb3JpdGl6ZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzW3ByaW9yaXRpemVkW2ldLnVuaXRdKHVuaXRzW3ByaW9yaXRpemVkW2ldLnVuaXRdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xuICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24odGhpc1t1bml0c10pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNbdW5pdHNdKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB2YXIgbWF0Y2gxID0gL1xcZC8sIC8vICAgICAgIDAgLSA5XG4gICAgICAgIG1hdGNoMiA9IC9cXGRcXGQvLCAvLyAgICAgIDAwIC0gOTlcbiAgICAgICAgbWF0Y2gzID0gL1xcZHszfS8sIC8vICAgICAwMDAgLSA5OTlcbiAgICAgICAgbWF0Y2g0ID0gL1xcZHs0fS8sIC8vICAgIDAwMDAgLSA5OTk5XG4gICAgICAgIG1hdGNoNiA9IC9bKy1dP1xcZHs2fS8sIC8vIC05OTk5OTkgLSA5OTk5OTlcbiAgICAgICAgbWF0Y2gxdG8yID0gL1xcZFxcZD8vLCAvLyAgICAgICAwIC0gOTlcbiAgICAgICAgbWF0Y2gzdG80ID0gL1xcZFxcZFxcZFxcZD8vLCAvLyAgICAgOTk5IC0gOTk5OVxuICAgICAgICBtYXRjaDV0bzYgPSAvXFxkXFxkXFxkXFxkXFxkXFxkPy8sIC8vICAgOTk5OTkgLSA5OTk5OTlcbiAgICAgICAgbWF0Y2gxdG8zID0gL1xcZHsxLDN9LywgLy8gICAgICAgMCAtIDk5OVxuICAgICAgICBtYXRjaDF0bzQgPSAvXFxkezEsNH0vLCAvLyAgICAgICAwIC0gOTk5OVxuICAgICAgICBtYXRjaDF0bzYgPSAvWystXT9cXGR7MSw2fS8sIC8vIC05OTk5OTkgLSA5OTk5OTlcbiAgICAgICAgbWF0Y2hVbnNpZ25lZCA9IC9cXGQrLywgLy8gICAgICAgMCAtIGluZlxuICAgICAgICBtYXRjaFNpZ25lZCA9IC9bKy1dP1xcZCsvLCAvLyAgICAtaW5mIC0gaW5mXG4gICAgICAgIG1hdGNoT2Zmc2V0ID0gL1p8WystXVxcZFxcZDo/XFxkXFxkL2dpLCAvLyArMDA6MDAgLTAwOjAwICswMDAwIC0wMDAwIG9yIFpcbiAgICAgICAgbWF0Y2hTaG9ydE9mZnNldCA9IC9afFsrLV1cXGRcXGQoPzo6P1xcZFxcZCk/L2dpLCAvLyArMDAgLTAwICswMDowMCAtMDA6MDAgKzAwMDAgLTAwMDAgb3IgWlxuICAgICAgICBtYXRjaFRpbWVzdGFtcCA9IC9bKy1dP1xcZCsoXFwuXFxkezEsM30pPy8sIC8vIDEyMzQ1Njc4OSAxMjM0NTY3ODkuMTIzXG4gICAgICAgIC8vIGFueSB3b3JkIChvciB0d28pIGNoYXJhY3RlcnMgb3IgbnVtYmVycyBpbmNsdWRpbmcgdHdvL3RocmVlIHdvcmQgbW9udGggaW4gYXJhYmljLlxuICAgICAgICAvLyBpbmNsdWRlcyBzY290dGlzaCBnYWVsaWMgdHdvIHdvcmQgYW5kIGh5cGhlbmF0ZWQgbW9udGhzXG4gICAgICAgIG1hdGNoV29yZCA9IC9bMC05XXswLDI1Nn1bJ2EtelxcdTAwQTAtXFx1MDVGRlxcdTA3MDAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkYwN1xcdUZGMTAtXFx1RkZFRl17MSwyNTZ9fFtcXHUwNjAwLVxcdTA2RkZcXC9dezEsMjU2fShcXHMqP1tcXHUwNjAwLVxcdTA2RkZdezEsMjU2fSl7MSwyfS9pLFxuICAgICAgICByZWdleGVzO1xuXG4gICAgcmVnZXhlcyA9IHt9O1xuXG4gICAgZnVuY3Rpb24gYWRkUmVnZXhUb2tlbih0b2tlbiwgcmVnZXgsIHN0cmljdFJlZ2V4KSB7XG4gICAgICAgIHJlZ2V4ZXNbdG9rZW5dID0gaXNGdW5jdGlvbihyZWdleClcbiAgICAgICAgICAgID8gcmVnZXhcbiAgICAgICAgICAgIDogZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGVEYXRhKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gaXNTdHJpY3QgJiYgc3RyaWN0UmVnZXggPyBzdHJpY3RSZWdleCA6IHJlZ2V4O1xuICAgICAgICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFBhcnNlUmVnZXhGb3JUb2tlbih0b2tlbiwgY29uZmlnKSB7XG4gICAgICAgIGlmICghaGFzT3duUHJvcChyZWdleGVzLCB0b2tlbikpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVnRXhwKHVuZXNjYXBlRm9ybWF0KHRva2VuKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVnZXhlc1t0b2tlbl0oY29uZmlnLl9zdHJpY3QsIGNvbmZpZy5fbG9jYWxlKTtcbiAgICB9XG5cbiAgICAvLyBDb2RlIGZyb20gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8zNTYxNDkzL2lzLXRoZXJlLWEtcmVnZXhwLWVzY2FwZS1mdW5jdGlvbi1pbi1qYXZhc2NyaXB0XG4gICAgZnVuY3Rpb24gdW5lc2NhcGVGb3JtYXQocykge1xuICAgICAgICByZXR1cm4gcmVnZXhFc2NhcGUoXG4gICAgICAgICAgICBzXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoJ1xcXFwnLCAnJylcbiAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXChcXFspfFxcXFwoXFxdKXxcXFsoW15cXF1cXFtdKilcXF18XFxcXCguKS9nLCBmdW5jdGlvbiAoXG4gICAgICAgICAgICAgICAgICAgIG1hdGNoZWQsXG4gICAgICAgICAgICAgICAgICAgIHAxLFxuICAgICAgICAgICAgICAgICAgICBwMixcbiAgICAgICAgICAgICAgICAgICAgcDMsXG4gICAgICAgICAgICAgICAgICAgIHA0XG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwMSB8fCBwMiB8fCBwMyB8fCBwNDtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlZ2V4RXNjYXBlKHMpIHtcbiAgICAgICAgcmV0dXJuIHMucmVwbGFjZSgvWy1cXC9cXFxcXiQqKz8uKCl8W1xcXXt9XS9nLCAnXFxcXCQmJyk7XG4gICAgfVxuXG4gICAgdmFyIHRva2VucyA9IHt9O1xuXG4gICAgZnVuY3Rpb24gYWRkUGFyc2VUb2tlbih0b2tlbiwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIGksXG4gICAgICAgICAgICBmdW5jID0gY2FsbGJhY2s7XG4gICAgICAgIGlmICh0eXBlb2YgdG9rZW4gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0b2tlbiA9IFt0b2tlbl07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzTnVtYmVyKGNhbGxiYWNrKSkge1xuICAgICAgICAgICAgZnVuYyA9IGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICAgICAgICAgICAgICBhcnJheVtjYWxsYmFja10gPSB0b0ludChpbnB1dCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0b2tlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdG9rZW5zW3Rva2VuW2ldXSA9IGZ1bmM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRXZWVrUGFyc2VUb2tlbih0b2tlbiwgY2FsbGJhY2spIHtcbiAgICAgICAgYWRkUGFyc2VUb2tlbih0b2tlbiwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnLCB0b2tlbikge1xuICAgICAgICAgICAgY29uZmlnLl93ID0gY29uZmlnLl93IHx8IHt9O1xuICAgICAgICAgICAgY2FsbGJhY2soaW5wdXQsIGNvbmZpZy5fdywgY29uZmlnLCB0b2tlbik7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZFRpbWVUb0FycmF5RnJvbVRva2VuKHRva2VuLCBpbnB1dCwgY29uZmlnKSB7XG4gICAgICAgIGlmIChpbnB1dCAhPSBudWxsICYmIGhhc093blByb3AodG9rZW5zLCB0b2tlbikpIHtcbiAgICAgICAgICAgIHRva2Vuc1t0b2tlbl0oaW5wdXQsIGNvbmZpZy5fYSwgY29uZmlnLCB0b2tlbik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgWUVBUiA9IDAsXG4gICAgICAgIE1PTlRIID0gMSxcbiAgICAgICAgREFURSA9IDIsXG4gICAgICAgIEhPVVIgPSAzLFxuICAgICAgICBNSU5VVEUgPSA0LFxuICAgICAgICBTRUNPTkQgPSA1LFxuICAgICAgICBNSUxMSVNFQ09ORCA9IDYsXG4gICAgICAgIFdFRUsgPSA3LFxuICAgICAgICBXRUVLREFZID0gODtcblxuICAgIGZ1bmN0aW9uIG1vZChuLCB4KSB7XG4gICAgICAgIHJldHVybiAoKG4gJSB4KSArIHgpICUgeDtcbiAgICB9XG5cbiAgICB2YXIgaW5kZXhPZjtcblxuICAgIGlmIChBcnJheS5wcm90b3R5cGUuaW5kZXhPZikge1xuICAgICAgICBpbmRleE9mID0gQXJyYXkucHJvdG90eXBlLmluZGV4T2Y7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaW5kZXhPZiA9IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgICAgICAvLyBJIGtub3dcbiAgICAgICAgICAgIHZhciBpO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpc1tpXSA9PT0gbykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGF5c0luTW9udGgoeWVhciwgbW9udGgpIHtcbiAgICAgICAgaWYgKGlzTmFOKHllYXIpIHx8IGlzTmFOKG1vbnRoKSkge1xuICAgICAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbW9kTW9udGggPSBtb2QobW9udGgsIDEyKTtcbiAgICAgICAgeWVhciArPSAobW9udGggLSBtb2RNb250aCkgLyAxMjtcbiAgICAgICAgcmV0dXJuIG1vZE1vbnRoID09PSAxXG4gICAgICAgICAgICA/IGlzTGVhcFllYXIoeWVhcilcbiAgICAgICAgICAgICAgICA/IDI5XG4gICAgICAgICAgICAgICAgOiAyOFxuICAgICAgICAgICAgOiAzMSAtICgobW9kTW9udGggJSA3KSAlIDIpO1xuICAgIH1cblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCdNJywgWydNTScsIDJdLCAnTW8nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vbnRoKCkgKyAxO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ01NTScsIDAsIDAsIGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLm1vbnRoc1Nob3J0KHRoaXMsIGZvcm1hdCk7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignTU1NTScsIDAsIDAsIGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLm1vbnRocyh0aGlzLCBmb3JtYXQpO1xuICAgIH0pO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCdtb250aCcsICdNJyk7XG5cbiAgICAvLyBQUklPUklUWVxuXG4gICAgYWRkVW5pdFByaW9yaXR5KCdtb250aCcsIDgpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignTScsIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignTU0nLCBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgYWRkUmVnZXhUb2tlbignTU1NJywgZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZS5tb250aHNTaG9ydFJlZ2V4KGlzU3RyaWN0KTtcbiAgICB9KTtcbiAgICBhZGRSZWdleFRva2VuKCdNTU1NJywgZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZS5tb250aHNSZWdleChpc1N0cmljdCk7XG4gICAgfSk7XG5cbiAgICBhZGRQYXJzZVRva2VuKFsnTScsICdNTSddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgICAgIGFycmF5W01PTlRIXSA9IHRvSW50KGlucHV0KSAtIDE7XG4gICAgfSk7XG5cbiAgICBhZGRQYXJzZVRva2VuKFsnTU1NJywgJ01NTU0nXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnLCB0b2tlbikge1xuICAgICAgICB2YXIgbW9udGggPSBjb25maWcuX2xvY2FsZS5tb250aHNQYXJzZShpbnB1dCwgdG9rZW4sIGNvbmZpZy5fc3RyaWN0KTtcbiAgICAgICAgLy8gaWYgd2UgZGlkbid0IGZpbmQgYSBtb250aCBuYW1lLCBtYXJrIHRoZSBkYXRlIGFzIGludmFsaWQuXG4gICAgICAgIGlmIChtb250aCAhPSBudWxsKSB7XG4gICAgICAgICAgICBhcnJheVtNT05USF0gPSBtb250aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmludmFsaWRNb250aCA9IGlucHV0O1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBMT0NBTEVTXG5cbiAgICB2YXIgZGVmYXVsdExvY2FsZU1vbnRocyA9ICdKYW51YXJ5X0ZlYnJ1YXJ5X01hcmNoX0FwcmlsX01heV9KdW5lX0p1bHlfQXVndXN0X1NlcHRlbWJlcl9PY3RvYmVyX05vdmVtYmVyX0RlY2VtYmVyJy5zcGxpdChcbiAgICAgICAgICAgICdfJ1xuICAgICAgICApLFxuICAgICAgICBkZWZhdWx0TG9jYWxlTW9udGhzU2hvcnQgPSAnSmFuX0ZlYl9NYXJfQXByX01heV9KdW5fSnVsX0F1Z19TZXBfT2N0X05vdl9EZWMnLnNwbGl0KFxuICAgICAgICAgICAgJ18nXG4gICAgICAgICksXG4gICAgICAgIE1PTlRIU19JTl9GT1JNQVQgPSAvRFtvRF0/KFxcW1teXFxbXFxdXSpcXF18XFxzKStNTU1NPy8sXG4gICAgICAgIGRlZmF1bHRNb250aHNTaG9ydFJlZ2V4ID0gbWF0Y2hXb3JkLFxuICAgICAgICBkZWZhdWx0TW9udGhzUmVnZXggPSBtYXRjaFdvcmQ7XG5cbiAgICBmdW5jdGlvbiBsb2NhbGVNb250aHMobSwgZm9ybWF0KSB7XG4gICAgICAgIGlmICghbSkge1xuICAgICAgICAgICAgcmV0dXJuIGlzQXJyYXkodGhpcy5fbW9udGhzKVxuICAgICAgICAgICAgICAgID8gdGhpcy5fbW9udGhzXG4gICAgICAgICAgICAgICAgOiB0aGlzLl9tb250aHNbJ3N0YW5kYWxvbmUnXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXNBcnJheSh0aGlzLl9tb250aHMpXG4gICAgICAgICAgICA/IHRoaXMuX21vbnRoc1ttLm1vbnRoKCldXG4gICAgICAgICAgICA6IHRoaXMuX21vbnRoc1tcbiAgICAgICAgICAgICAgICAgICh0aGlzLl9tb250aHMuaXNGb3JtYXQgfHwgTU9OVEhTX0lOX0ZPUk1BVCkudGVzdChmb3JtYXQpXG4gICAgICAgICAgICAgICAgICAgICAgPyAnZm9ybWF0J1xuICAgICAgICAgICAgICAgICAgICAgIDogJ3N0YW5kYWxvbmUnXG4gICAgICAgICAgICAgIF1bbS5tb250aCgpXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb2NhbGVNb250aHNTaG9ydChtLCBmb3JtYXQpIHtcbiAgICAgICAgaWYgKCFtKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNBcnJheSh0aGlzLl9tb250aHNTaG9ydClcbiAgICAgICAgICAgICAgICA/IHRoaXMuX21vbnRoc1Nob3J0XG4gICAgICAgICAgICAgICAgOiB0aGlzLl9tb250aHNTaG9ydFsnc3RhbmRhbG9uZSddO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpc0FycmF5KHRoaXMuX21vbnRoc1Nob3J0KVxuICAgICAgICAgICAgPyB0aGlzLl9tb250aHNTaG9ydFttLm1vbnRoKCldXG4gICAgICAgICAgICA6IHRoaXMuX21vbnRoc1Nob3J0W1xuICAgICAgICAgICAgICAgICAgTU9OVEhTX0lOX0ZPUk1BVC50ZXN0KGZvcm1hdCkgPyAnZm9ybWF0JyA6ICdzdGFuZGFsb25lJ1xuICAgICAgICAgICAgICBdW20ubW9udGgoKV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFuZGxlU3RyaWN0UGFyc2UobW9udGhOYW1lLCBmb3JtYXQsIHN0cmljdCkge1xuICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgIGlpLFxuICAgICAgICAgICAgbW9tLFxuICAgICAgICAgICAgbGxjID0gbW9udGhOYW1lLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmICghdGhpcy5fbW9udGhzUGFyc2UpIHtcbiAgICAgICAgICAgIC8vIHRoaXMgaXMgbm90IHVzZWRcbiAgICAgICAgICAgIHRoaXMuX21vbnRoc1BhcnNlID0gW107XG4gICAgICAgICAgICB0aGlzLl9sb25nTW9udGhzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX3Nob3J0TW9udGhzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCAxMjsgKytpKSB7XG4gICAgICAgICAgICAgICAgbW9tID0gY3JlYXRlVVRDKFsyMDAwLCBpXSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2hvcnRNb250aHNQYXJzZVtpXSA9IHRoaXMubW9udGhzU2hvcnQoXG4gICAgICAgICAgICAgICAgICAgIG1vbSxcbiAgICAgICAgICAgICAgICAgICAgJydcbiAgICAgICAgICAgICAgICApLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fbG9uZ01vbnRoc1BhcnNlW2ldID0gdGhpcy5tb250aHMobW9tLCAnJykudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdHJpY3QpIHtcbiAgICAgICAgICAgIGlmIChmb3JtYXQgPT09ICdNTU0nKSB7XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fc2hvcnRNb250aHNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9sb25nTW9udGhzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChmb3JtYXQgPT09ICdNTU0nKSB7XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fc2hvcnRNb250aHNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICBpZiAoaWkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fbG9uZ01vbnRoc1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX2xvbmdNb250aHNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICBpZiAoaWkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fc2hvcnRNb250aHNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9jYWxlTW9udGhzUGFyc2UobW9udGhOYW1lLCBmb3JtYXQsIHN0cmljdCkge1xuICAgICAgICB2YXIgaSwgbW9tLCByZWdleDtcblxuICAgICAgICBpZiAodGhpcy5fbW9udGhzUGFyc2VFeGFjdCkge1xuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZVN0cmljdFBhcnNlLmNhbGwodGhpcywgbW9udGhOYW1lLCBmb3JtYXQsIHN0cmljdCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuX21vbnRoc1BhcnNlKSB7XG4gICAgICAgICAgICB0aGlzLl9tb250aHNQYXJzZSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fbG9uZ01vbnRoc1BhcnNlID0gW107XG4gICAgICAgICAgICB0aGlzLl9zaG9ydE1vbnRoc1BhcnNlID0gW107XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUT0RPOiBhZGQgc29ydGluZ1xuICAgICAgICAvLyBTb3J0aW5nIG1ha2VzIHN1cmUgaWYgb25lIG1vbnRoIChvciBhYmJyKSBpcyBhIHByZWZpeCBvZiBhbm90aGVyXG4gICAgICAgIC8vIHNlZSBzb3J0aW5nIGluIGNvbXB1dGVNb250aHNQYXJzZVxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMTI7IGkrKykge1xuICAgICAgICAgICAgLy8gbWFrZSB0aGUgcmVnZXggaWYgd2UgZG9uJ3QgaGF2ZSBpdCBhbHJlYWR5XG4gICAgICAgICAgICBtb20gPSBjcmVhdGVVVEMoWzIwMDAsIGldKTtcbiAgICAgICAgICAgIGlmIChzdHJpY3QgJiYgIXRoaXMuX2xvbmdNb250aHNQYXJzZVtpXSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xvbmdNb250aHNQYXJzZVtpXSA9IG5ldyBSZWdFeHAoXG4gICAgICAgICAgICAgICAgICAgICdeJyArIHRoaXMubW9udGhzKG1vbSwgJycpLnJlcGxhY2UoJy4nLCAnJykgKyAnJCcsXG4gICAgICAgICAgICAgICAgICAgICdpJ1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2hvcnRNb250aHNQYXJzZVtpXSA9IG5ldyBSZWdFeHAoXG4gICAgICAgICAgICAgICAgICAgICdeJyArIHRoaXMubW9udGhzU2hvcnQobW9tLCAnJykucmVwbGFjZSgnLicsICcnKSArICckJyxcbiAgICAgICAgICAgICAgICAgICAgJ2knXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghc3RyaWN0ICYmICF0aGlzLl9tb250aHNQYXJzZVtpXSkge1xuICAgICAgICAgICAgICAgIHJlZ2V4ID1cbiAgICAgICAgICAgICAgICAgICAgJ14nICsgdGhpcy5tb250aHMobW9tLCAnJykgKyAnfF4nICsgdGhpcy5tb250aHNTaG9ydChtb20sICcnKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9tb250aHNQYXJzZVtpXSA9IG5ldyBSZWdFeHAocmVnZXgucmVwbGFjZSgnLicsICcnKSwgJ2knKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHRlc3QgdGhlIHJlZ2V4XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgc3RyaWN0ICYmXG4gICAgICAgICAgICAgICAgZm9ybWF0ID09PSAnTU1NTScgJiZcbiAgICAgICAgICAgICAgICB0aGlzLl9sb25nTW9udGhzUGFyc2VbaV0udGVzdChtb250aE5hbWUpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICAgICAgc3RyaWN0ICYmXG4gICAgICAgICAgICAgICAgZm9ybWF0ID09PSAnTU1NJyAmJlxuICAgICAgICAgICAgICAgIHRoaXMuX3Nob3J0TW9udGhzUGFyc2VbaV0udGVzdChtb250aE5hbWUpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIXN0cmljdCAmJiB0aGlzLl9tb250aHNQYXJzZVtpXS50ZXN0KG1vbnRoTmFtZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIE1PTUVOVFNcblxuICAgIGZ1bmN0aW9uIHNldE1vbnRoKG1vbSwgdmFsdWUpIHtcbiAgICAgICAgdmFyIGRheU9mTW9udGg7XG5cbiAgICAgICAgaWYgKCFtb20uaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICAvLyBObyBvcFxuICAgICAgICAgICAgcmV0dXJuIG1vbTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBpZiAoL15cXGQrJC8udGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHRvSW50KHZhbHVlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBtb20ubG9jYWxlRGF0YSgpLm1vbnRoc1BhcnNlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBBbm90aGVyIHNpbGVudCBmYWlsdXJlP1xuICAgICAgICAgICAgICAgIGlmICghaXNOdW1iZXIodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtb207XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZGF5T2ZNb250aCA9IE1hdGgubWluKG1vbS5kYXRlKCksIGRheXNJbk1vbnRoKG1vbS55ZWFyKCksIHZhbHVlKSk7XG4gICAgICAgIG1vbS5fZFsnc2V0JyArIChtb20uX2lzVVRDID8gJ1VUQycgOiAnJykgKyAnTW9udGgnXSh2YWx1ZSwgZGF5T2ZNb250aCk7XG4gICAgICAgIHJldHVybiBtb207XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U2V0TW9udGgodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHNldE1vbnRoKHRoaXMsIHZhbHVlKTtcbiAgICAgICAgICAgIGhvb2tzLnVwZGF0ZU9mZnNldCh0aGlzLCB0cnVlKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGdldCh0aGlzLCAnTW9udGgnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldERheXNJbk1vbnRoKCkge1xuICAgICAgICByZXR1cm4gZGF5c0luTW9udGgodGhpcy55ZWFyKCksIHRoaXMubW9udGgoKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbW9udGhzU2hvcnRSZWdleChpc1N0cmljdCkge1xuICAgICAgICBpZiAodGhpcy5fbW9udGhzUGFyc2VFeGFjdCkge1xuICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfbW9udGhzUmVnZXgnKSkge1xuICAgICAgICAgICAgICAgIGNvbXB1dGVNb250aHNQYXJzZS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzU3RyaWN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21vbnRoc1Nob3J0U3RyaWN0UmVnZXg7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9tb250aHNTaG9ydFJlZ2V4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfbW9udGhzU2hvcnRSZWdleCcpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbW9udGhzU2hvcnRSZWdleCA9IGRlZmF1bHRNb250aHNTaG9ydFJlZ2V4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21vbnRoc1Nob3J0U3RyaWN0UmVnZXggJiYgaXNTdHJpY3RcbiAgICAgICAgICAgICAgICA/IHRoaXMuX21vbnRoc1Nob3J0U3RyaWN0UmVnZXhcbiAgICAgICAgICAgICAgICA6IHRoaXMuX21vbnRoc1Nob3J0UmVnZXg7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtb250aHNSZWdleChpc1N0cmljdCkge1xuICAgICAgICBpZiAodGhpcy5fbW9udGhzUGFyc2VFeGFjdCkge1xuICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfbW9udGhzUmVnZXgnKSkge1xuICAgICAgICAgICAgICAgIGNvbXB1dGVNb250aHNQYXJzZS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzU3RyaWN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21vbnRoc1N0cmljdFJlZ2V4O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzUmVnZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ19tb250aHNSZWdleCcpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbW9udGhzUmVnZXggPSBkZWZhdWx0TW9udGhzUmVnZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzU3RyaWN0UmVnZXggJiYgaXNTdHJpY3RcbiAgICAgICAgICAgICAgICA/IHRoaXMuX21vbnRoc1N0cmljdFJlZ2V4XG4gICAgICAgICAgICAgICAgOiB0aGlzLl9tb250aHNSZWdleDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbXB1dGVNb250aHNQYXJzZSgpIHtcbiAgICAgICAgZnVuY3Rpb24gY21wTGVuUmV2KGEsIGIpIHtcbiAgICAgICAgICAgIHJldHVybiBiLmxlbmd0aCAtIGEubGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNob3J0UGllY2VzID0gW10sXG4gICAgICAgICAgICBsb25nUGllY2VzID0gW10sXG4gICAgICAgICAgICBtaXhlZFBpZWNlcyA9IFtdLFxuICAgICAgICAgICAgaSxcbiAgICAgICAgICAgIG1vbTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDEyOyBpKyspIHtcbiAgICAgICAgICAgIC8vIG1ha2UgdGhlIHJlZ2V4IGlmIHdlIGRvbid0IGhhdmUgaXQgYWxyZWFkeVxuICAgICAgICAgICAgbW9tID0gY3JlYXRlVVRDKFsyMDAwLCBpXSk7XG4gICAgICAgICAgICBzaG9ydFBpZWNlcy5wdXNoKHRoaXMubW9udGhzU2hvcnQobW9tLCAnJykpO1xuICAgICAgICAgICAgbG9uZ1BpZWNlcy5wdXNoKHRoaXMubW9udGhzKG1vbSwgJycpKTtcbiAgICAgICAgICAgIG1peGVkUGllY2VzLnB1c2godGhpcy5tb250aHMobW9tLCAnJykpO1xuICAgICAgICAgICAgbWl4ZWRQaWVjZXMucHVzaCh0aGlzLm1vbnRoc1Nob3J0KG1vbSwgJycpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTb3J0aW5nIG1ha2VzIHN1cmUgaWYgb25lIG1vbnRoIChvciBhYmJyKSBpcyBhIHByZWZpeCBvZiBhbm90aGVyIGl0XG4gICAgICAgIC8vIHdpbGwgbWF0Y2ggdGhlIGxvbmdlciBwaWVjZS5cbiAgICAgICAgc2hvcnRQaWVjZXMuc29ydChjbXBMZW5SZXYpO1xuICAgICAgICBsb25nUGllY2VzLnNvcnQoY21wTGVuUmV2KTtcbiAgICAgICAgbWl4ZWRQaWVjZXMuc29ydChjbXBMZW5SZXYpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMTI7IGkrKykge1xuICAgICAgICAgICAgc2hvcnRQaWVjZXNbaV0gPSByZWdleEVzY2FwZShzaG9ydFBpZWNlc1tpXSk7XG4gICAgICAgICAgICBsb25nUGllY2VzW2ldID0gcmVnZXhFc2NhcGUobG9uZ1BpZWNlc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDI0OyBpKyspIHtcbiAgICAgICAgICAgIG1peGVkUGllY2VzW2ldID0gcmVnZXhFc2NhcGUobWl4ZWRQaWVjZXNbaV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fbW9udGhzUmVnZXggPSBuZXcgUmVnRXhwKCdeKCcgKyBtaXhlZFBpZWNlcy5qb2luKCd8JykgKyAnKScsICdpJyk7XG4gICAgICAgIHRoaXMuX21vbnRoc1Nob3J0UmVnZXggPSB0aGlzLl9tb250aHNSZWdleDtcbiAgICAgICAgdGhpcy5fbW9udGhzU3RyaWN0UmVnZXggPSBuZXcgUmVnRXhwKFxuICAgICAgICAgICAgJ14oJyArIGxvbmdQaWVjZXMuam9pbignfCcpICsgJyknLFxuICAgICAgICAgICAgJ2knXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuX21vbnRoc1Nob3J0U3RyaWN0UmVnZXggPSBuZXcgUmVnRXhwKFxuICAgICAgICAgICAgJ14oJyArIHNob3J0UGllY2VzLmpvaW4oJ3wnKSArICcpJyxcbiAgICAgICAgICAgICdpJ1xuICAgICAgICApO1xuICAgIH1cblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCdZJywgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgeSA9IHRoaXMueWVhcigpO1xuICAgICAgICByZXR1cm4geSA8PSA5OTk5ID8gemVyb0ZpbGwoeSwgNCkgOiAnKycgKyB5O1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydZWScsIDJdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnllYXIoKSAlIDEwMDtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnWVlZWScsIDRdLCAwLCAneWVhcicpO1xuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnWVlZWVknLCA1XSwgMCwgJ3llYXInKTtcbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1lZWVlZWScsIDYsIHRydWVdLCAwLCAneWVhcicpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCd5ZWFyJywgJ3knKTtcblxuICAgIC8vIFBSSU9SSVRJRVNcblxuICAgIGFkZFVuaXRQcmlvcml0eSgneWVhcicsIDEpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignWScsIG1hdGNoU2lnbmVkKTtcbiAgICBhZGRSZWdleFRva2VuKCdZWScsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdZWVlZJywgbWF0Y2gxdG80LCBtYXRjaDQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1lZWVlZJywgbWF0Y2gxdG82LCBtYXRjaDYpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1lZWVlZWScsIG1hdGNoMXRvNiwgbWF0Y2g2KTtcblxuICAgIGFkZFBhcnNlVG9rZW4oWydZWVlZWScsICdZWVlZWVknXSwgWUVBUik7XG4gICAgYWRkUGFyc2VUb2tlbignWVlZWScsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICAgICAgYXJyYXlbWUVBUl0gPVxuICAgICAgICAgICAgaW5wdXQubGVuZ3RoID09PSAyID8gaG9va3MucGFyc2VUd29EaWdpdFllYXIoaW5wdXQpIDogdG9JbnQoaW5wdXQpO1xuICAgIH0pO1xuICAgIGFkZFBhcnNlVG9rZW4oJ1lZJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSkge1xuICAgICAgICBhcnJheVtZRUFSXSA9IGhvb2tzLnBhcnNlVHdvRGlnaXRZZWFyKGlucHV0KTtcbiAgICB9KTtcbiAgICBhZGRQYXJzZVRva2VuKCdZJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSkge1xuICAgICAgICBhcnJheVtZRUFSXSA9IHBhcnNlSW50KGlucHV0LCAxMCk7XG4gICAgfSk7XG5cbiAgICAvLyBIRUxQRVJTXG5cbiAgICBmdW5jdGlvbiBkYXlzSW5ZZWFyKHllYXIpIHtcbiAgICAgICAgcmV0dXJuIGlzTGVhcFllYXIoeWVhcikgPyAzNjYgOiAzNjU7XG4gICAgfVxuXG4gICAgLy8gSE9PS1NcblxuICAgIGhvb2tzLnBhcnNlVHdvRGlnaXRZZWFyID0gZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICAgIHJldHVybiB0b0ludChpbnB1dCkgKyAodG9JbnQoaW5wdXQpID4gNjggPyAxOTAwIDogMjAwMCk7XG4gICAgfTtcblxuICAgIC8vIE1PTUVOVFNcblxuICAgIHZhciBnZXRTZXRZZWFyID0gbWFrZUdldFNldCgnRnVsbFllYXInLCB0cnVlKTtcblxuICAgIGZ1bmN0aW9uIGdldElzTGVhcFllYXIoKSB7XG4gICAgICAgIHJldHVybiBpc0xlYXBZZWFyKHRoaXMueWVhcigpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVEYXRlKHksIG0sIGQsIGgsIE0sIHMsIG1zKSB7XG4gICAgICAgIC8vIGNhbid0IGp1c3QgYXBwbHkoKSB0byBjcmVhdGUgYSBkYXRlOlxuICAgICAgICAvLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3EvMTgxMzQ4XG4gICAgICAgIHZhciBkYXRlO1xuICAgICAgICAvLyB0aGUgZGF0ZSBjb25zdHJ1Y3RvciByZW1hcHMgeWVhcnMgMC05OSB0byAxOTAwLTE5OTlcbiAgICAgICAgaWYgKHkgPCAxMDAgJiYgeSA+PSAwKSB7XG4gICAgICAgICAgICAvLyBwcmVzZXJ2ZSBsZWFwIHllYXJzIHVzaW5nIGEgZnVsbCA0MDAgeWVhciBjeWNsZSwgdGhlbiByZXNldFxuICAgICAgICAgICAgZGF0ZSA9IG5ldyBEYXRlKHkgKyA0MDAsIG0sIGQsIGgsIE0sIHMsIG1zKTtcbiAgICAgICAgICAgIGlmIChpc0Zpbml0ZShkYXRlLmdldEZ1bGxZZWFyKCkpKSB7XG4gICAgICAgICAgICAgICAgZGF0ZS5zZXRGdWxsWWVhcih5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRhdGUgPSBuZXcgRGF0ZSh5LCBtLCBkLCBoLCBNLCBzLCBtcyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGF0ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVVVENEYXRlKHkpIHtcbiAgICAgICAgdmFyIGRhdGUsIGFyZ3M7XG4gICAgICAgIC8vIHRoZSBEYXRlLlVUQyBmdW5jdGlvbiByZW1hcHMgeWVhcnMgMC05OSB0byAxOTAwLTE5OTlcbiAgICAgICAgaWYgKHkgPCAxMDAgJiYgeSA+PSAwKSB7XG4gICAgICAgICAgICBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgICAgICAgIC8vIHByZXNlcnZlIGxlYXAgeWVhcnMgdXNpbmcgYSBmdWxsIDQwMCB5ZWFyIGN5Y2xlLCB0aGVuIHJlc2V0XG4gICAgICAgICAgICBhcmdzWzBdID0geSArIDQwMDtcbiAgICAgICAgICAgIGRhdGUgPSBuZXcgRGF0ZShEYXRlLlVUQy5hcHBseShudWxsLCBhcmdzKSk7XG4gICAgICAgICAgICBpZiAoaXNGaW5pdGUoZGF0ZS5nZXRVVENGdWxsWWVhcigpKSkge1xuICAgICAgICAgICAgICAgIGRhdGUuc2V0VVRDRnVsbFllYXIoeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkYXRlID0gbmV3IERhdGUoRGF0ZS5VVEMuYXBwbHkobnVsbCwgYXJndW1lbnRzKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGF0ZTtcbiAgICB9XG5cbiAgICAvLyBzdGFydC1vZi1maXJzdC13ZWVrIC0gc3RhcnQtb2YteWVhclxuICAgIGZ1bmN0aW9uIGZpcnN0V2Vla09mZnNldCh5ZWFyLCBkb3csIGRveSkge1xuICAgICAgICB2YXIgLy8gZmlyc3Qtd2VlayBkYXkgLS0gd2hpY2ggamFudWFyeSBpcyBhbHdheXMgaW4gdGhlIGZpcnN0IHdlZWsgKDQgZm9yIGlzbywgMSBmb3Igb3RoZXIpXG4gICAgICAgICAgICBmd2QgPSA3ICsgZG93IC0gZG95LFxuICAgICAgICAgICAgLy8gZmlyc3Qtd2VlayBkYXkgbG9jYWwgd2Vla2RheSAtLSB3aGljaCBsb2NhbCB3ZWVrZGF5IGlzIGZ3ZFxuICAgICAgICAgICAgZndkbHcgPSAoNyArIGNyZWF0ZVVUQ0RhdGUoeWVhciwgMCwgZndkKS5nZXRVVENEYXkoKSAtIGRvdykgJSA3O1xuXG4gICAgICAgIHJldHVybiAtZndkbHcgKyBmd2QgLSAxO1xuICAgIH1cblxuICAgIC8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lTT193ZWVrX2RhdGUjQ2FsY3VsYXRpbmdfYV9kYXRlX2dpdmVuX3RoZV95ZWFyLjJDX3dlZWtfbnVtYmVyX2FuZF93ZWVrZGF5XG4gICAgZnVuY3Rpb24gZGF5T2ZZZWFyRnJvbVdlZWtzKHllYXIsIHdlZWssIHdlZWtkYXksIGRvdywgZG95KSB7XG4gICAgICAgIHZhciBsb2NhbFdlZWtkYXkgPSAoNyArIHdlZWtkYXkgLSBkb3cpICUgNyxcbiAgICAgICAgICAgIHdlZWtPZmZzZXQgPSBmaXJzdFdlZWtPZmZzZXQoeWVhciwgZG93LCBkb3kpLFxuICAgICAgICAgICAgZGF5T2ZZZWFyID0gMSArIDcgKiAod2VlayAtIDEpICsgbG9jYWxXZWVrZGF5ICsgd2Vla09mZnNldCxcbiAgICAgICAgICAgIHJlc1llYXIsXG4gICAgICAgICAgICByZXNEYXlPZlllYXI7XG5cbiAgICAgICAgaWYgKGRheU9mWWVhciA8PSAwKSB7XG4gICAgICAgICAgICByZXNZZWFyID0geWVhciAtIDE7XG4gICAgICAgICAgICByZXNEYXlPZlllYXIgPSBkYXlzSW5ZZWFyKHJlc1llYXIpICsgZGF5T2ZZZWFyO1xuICAgICAgICB9IGVsc2UgaWYgKGRheU9mWWVhciA+IGRheXNJblllYXIoeWVhcikpIHtcbiAgICAgICAgICAgIHJlc1llYXIgPSB5ZWFyICsgMTtcbiAgICAgICAgICAgIHJlc0RheU9mWWVhciA9IGRheU9mWWVhciAtIGRheXNJblllYXIoeWVhcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXNZZWFyID0geWVhcjtcbiAgICAgICAgICAgIHJlc0RheU9mWWVhciA9IGRheU9mWWVhcjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB5ZWFyOiByZXNZZWFyLFxuICAgICAgICAgICAgZGF5T2ZZZWFyOiByZXNEYXlPZlllYXIsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gd2Vla09mWWVhcihtb20sIGRvdywgZG95KSB7XG4gICAgICAgIHZhciB3ZWVrT2Zmc2V0ID0gZmlyc3RXZWVrT2Zmc2V0KG1vbS55ZWFyKCksIGRvdywgZG95KSxcbiAgICAgICAgICAgIHdlZWsgPSBNYXRoLmZsb29yKChtb20uZGF5T2ZZZWFyKCkgLSB3ZWVrT2Zmc2V0IC0gMSkgLyA3KSArIDEsXG4gICAgICAgICAgICByZXNXZWVrLFxuICAgICAgICAgICAgcmVzWWVhcjtcblxuICAgICAgICBpZiAod2VlayA8IDEpIHtcbiAgICAgICAgICAgIHJlc1llYXIgPSBtb20ueWVhcigpIC0gMTtcbiAgICAgICAgICAgIHJlc1dlZWsgPSB3ZWVrICsgd2Vla3NJblllYXIocmVzWWVhciwgZG93LCBkb3kpO1xuICAgICAgICB9IGVsc2UgaWYgKHdlZWsgPiB3ZWVrc0luWWVhcihtb20ueWVhcigpLCBkb3csIGRveSkpIHtcbiAgICAgICAgICAgIHJlc1dlZWsgPSB3ZWVrIC0gd2Vla3NJblllYXIobW9tLnllYXIoKSwgZG93LCBkb3kpO1xuICAgICAgICAgICAgcmVzWWVhciA9IG1vbS55ZWFyKCkgKyAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzWWVhciA9IG1vbS55ZWFyKCk7XG4gICAgICAgICAgICByZXNXZWVrID0gd2VlaztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB3ZWVrOiByZXNXZWVrLFxuICAgICAgICAgICAgeWVhcjogcmVzWWVhcixcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB3ZWVrc0luWWVhcih5ZWFyLCBkb3csIGRveSkge1xuICAgICAgICB2YXIgd2Vla09mZnNldCA9IGZpcnN0V2Vla09mZnNldCh5ZWFyLCBkb3csIGRveSksXG4gICAgICAgICAgICB3ZWVrT2Zmc2V0TmV4dCA9IGZpcnN0V2Vla09mZnNldCh5ZWFyICsgMSwgZG93LCBkb3kpO1xuICAgICAgICByZXR1cm4gKGRheXNJblllYXIoeWVhcikgLSB3ZWVrT2Zmc2V0ICsgd2Vla09mZnNldE5leHQpIC8gNztcbiAgICB9XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbigndycsIFsnd3cnLCAyXSwgJ3dvJywgJ3dlZWsnKTtcbiAgICBhZGRGb3JtYXRUb2tlbignVycsIFsnV1cnLCAyXSwgJ1dvJywgJ2lzb1dlZWsnKTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygnd2VlaycsICd3Jyk7XG4gICAgYWRkVW5pdEFsaWFzKCdpc29XZWVrJywgJ1cnKTtcblxuICAgIC8vIFBSSU9SSVRJRVNcblxuICAgIGFkZFVuaXRQcmlvcml0eSgnd2VlaycsIDUpO1xuICAgIGFkZFVuaXRQcmlvcml0eSgnaXNvV2VlaycsIDUpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbigndycsIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignd3cnLCBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgYWRkUmVnZXhUb2tlbignVycsIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignV1cnLCBtYXRjaDF0bzIsIG1hdGNoMik7XG5cbiAgICBhZGRXZWVrUGFyc2VUb2tlbihbJ3cnLCAnd3cnLCAnVycsICdXVyddLCBmdW5jdGlvbiAoXG4gICAgICAgIGlucHV0LFxuICAgICAgICB3ZWVrLFxuICAgICAgICBjb25maWcsXG4gICAgICAgIHRva2VuXG4gICAgKSB7XG4gICAgICAgIHdlZWtbdG9rZW4uc3Vic3RyKDAsIDEpXSA9IHRvSW50KGlucHV0KTtcbiAgICB9KTtcblxuICAgIC8vIEhFTFBFUlNcblxuICAgIC8vIExPQ0FMRVNcblxuICAgIGZ1bmN0aW9uIGxvY2FsZVdlZWsobW9tKSB7XG4gICAgICAgIHJldHVybiB3ZWVrT2ZZZWFyKG1vbSwgdGhpcy5fd2Vlay5kb3csIHRoaXMuX3dlZWsuZG95KS53ZWVrO1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0TG9jYWxlV2VlayA9IHtcbiAgICAgICAgZG93OiAwLCAvLyBTdW5kYXkgaXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cbiAgICAgICAgZG95OiA2LCAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiA2dGggaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGxvY2FsZUZpcnN0RGF5T2ZXZWVrKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd2Vlay5kb3c7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9jYWxlRmlyc3REYXlPZlllYXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93ZWVrLmRveTtcbiAgICB9XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICBmdW5jdGlvbiBnZXRTZXRXZWVrKGlucHV0KSB7XG4gICAgICAgIHZhciB3ZWVrID0gdGhpcy5sb2NhbGVEYXRhKCkud2Vlayh0aGlzKTtcbiAgICAgICAgcmV0dXJuIGlucHV0ID09IG51bGwgPyB3ZWVrIDogdGhpcy5hZGQoKGlucHV0IC0gd2VlaykgKiA3LCAnZCcpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFNldElTT1dlZWsoaW5wdXQpIHtcbiAgICAgICAgdmFyIHdlZWsgPSB3ZWVrT2ZZZWFyKHRoaXMsIDEsIDQpLndlZWs7XG4gICAgICAgIHJldHVybiBpbnB1dCA9PSBudWxsID8gd2VlayA6IHRoaXMuYWRkKChpbnB1dCAtIHdlZWspICogNywgJ2QnKTtcbiAgICB9XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbignZCcsIDAsICdkbycsICdkYXknKTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdkZCcsIDAsIDAsIGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLndlZWtkYXlzTWluKHRoaXMsIGZvcm1hdCk7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignZGRkJywgMCwgMCwgZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkud2Vla2RheXNTaG9ydCh0aGlzLCBmb3JtYXQpO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ2RkZGQnLCAwLCAwLCBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS53ZWVrZGF5cyh0aGlzLCBmb3JtYXQpO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ2UnLCAwLCAwLCAnd2Vla2RheScpO1xuICAgIGFkZEZvcm1hdFRva2VuKCdFJywgMCwgMCwgJ2lzb1dlZWtkYXknKTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygnZGF5JywgJ2QnKTtcbiAgICBhZGRVbml0QWxpYXMoJ3dlZWtkYXknLCAnZScpO1xuICAgIGFkZFVuaXRBbGlhcygnaXNvV2Vla2RheScsICdFJyk7XG5cbiAgICAvLyBQUklPUklUWVxuICAgIGFkZFVuaXRQcmlvcml0eSgnZGF5JywgMTEpO1xuICAgIGFkZFVuaXRQcmlvcml0eSgnd2Vla2RheScsIDExKTtcbiAgICBhZGRVbml0UHJpb3JpdHkoJ2lzb1dlZWtkYXknLCAxMSk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdkJywgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdlJywgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdFJywgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdkZCcsIGZ1bmN0aW9uIChpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGUud2Vla2RheXNNaW5SZWdleChpc1N0cmljdCk7XG4gICAgfSk7XG4gICAgYWRkUmVnZXhUb2tlbignZGRkJywgZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZS53ZWVrZGF5c1Nob3J0UmVnZXgoaXNTdHJpY3QpO1xuICAgIH0pO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2RkZGQnLCBmdW5jdGlvbiAoaXNTdHJpY3QsIGxvY2FsZSkge1xuICAgICAgICByZXR1cm4gbG9jYWxlLndlZWtkYXlzUmVnZXgoaXNTdHJpY3QpO1xuICAgIH0pO1xuXG4gICAgYWRkV2Vla1BhcnNlVG9rZW4oWydkZCcsICdkZGQnLCAnZGRkZCddLCBmdW5jdGlvbiAoaW5wdXQsIHdlZWssIGNvbmZpZywgdG9rZW4pIHtcbiAgICAgICAgdmFyIHdlZWtkYXkgPSBjb25maWcuX2xvY2FsZS53ZWVrZGF5c1BhcnNlKGlucHV0LCB0b2tlbiwgY29uZmlnLl9zdHJpY3QpO1xuICAgICAgICAvLyBpZiB3ZSBkaWRuJ3QgZ2V0IGEgd2Vla2RheSBuYW1lLCBtYXJrIHRoZSBkYXRlIGFzIGludmFsaWRcbiAgICAgICAgaWYgKHdlZWtkYXkgIT0gbnVsbCkge1xuICAgICAgICAgICAgd2Vlay5kID0gd2Vla2RheTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmludmFsaWRXZWVrZGF5ID0gaW5wdXQ7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGFkZFdlZWtQYXJzZVRva2VuKFsnZCcsICdlJywgJ0UnXSwgZnVuY3Rpb24gKGlucHV0LCB3ZWVrLCBjb25maWcsIHRva2VuKSB7XG4gICAgICAgIHdlZWtbdG9rZW5dID0gdG9JbnQoaW5wdXQpO1xuICAgIH0pO1xuXG4gICAgLy8gSEVMUEVSU1xuXG4gICAgZnVuY3Rpb24gcGFyc2VXZWVrZGF5KGlucHV0LCBsb2NhbGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNOYU4oaW5wdXQpKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQoaW5wdXQsIDEwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlucHV0ID0gbG9jYWxlLndlZWtkYXlzUGFyc2UoaW5wdXQpO1xuICAgICAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VJc29XZWVrZGF5KGlucHV0LCBsb2NhbGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbGUud2Vla2RheXNQYXJzZShpbnB1dCkgJSA3IHx8IDc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlzTmFOKGlucHV0KSA/IG51bGwgOiBpbnB1dDtcbiAgICB9XG5cbiAgICAvLyBMT0NBTEVTXG4gICAgZnVuY3Rpb24gc2hpZnRXZWVrZGF5cyh3cywgbikge1xuICAgICAgICByZXR1cm4gd3Muc2xpY2UobiwgNykuY29uY2F0KHdzLnNsaWNlKDAsIG4pKTtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdExvY2FsZVdlZWtkYXlzID0gJ1N1bmRheV9Nb25kYXlfVHVlc2RheV9XZWRuZXNkYXlfVGh1cnNkYXlfRnJpZGF5X1NhdHVyZGF5Jy5zcGxpdChcbiAgICAgICAgICAgICdfJ1xuICAgICAgICApLFxuICAgICAgICBkZWZhdWx0TG9jYWxlV2Vla2RheXNTaG9ydCA9ICdTdW5fTW9uX1R1ZV9XZWRfVGh1X0ZyaV9TYXQnLnNwbGl0KCdfJyksXG4gICAgICAgIGRlZmF1bHRMb2NhbGVXZWVrZGF5c01pbiA9ICdTdV9Nb19UdV9XZV9UaF9Gcl9TYScuc3BsaXQoJ18nKSxcbiAgICAgICAgZGVmYXVsdFdlZWtkYXlzUmVnZXggPSBtYXRjaFdvcmQsXG4gICAgICAgIGRlZmF1bHRXZWVrZGF5c1Nob3J0UmVnZXggPSBtYXRjaFdvcmQsXG4gICAgICAgIGRlZmF1bHRXZWVrZGF5c01pblJlZ2V4ID0gbWF0Y2hXb3JkO1xuXG4gICAgZnVuY3Rpb24gbG9jYWxlV2Vla2RheXMobSwgZm9ybWF0KSB7XG4gICAgICAgIHZhciB3ZWVrZGF5cyA9IGlzQXJyYXkodGhpcy5fd2Vla2RheXMpXG4gICAgICAgICAgICA/IHRoaXMuX3dlZWtkYXlzXG4gICAgICAgICAgICA6IHRoaXMuX3dlZWtkYXlzW1xuICAgICAgICAgICAgICAgICAgbSAmJiBtICE9PSB0cnVlICYmIHRoaXMuX3dlZWtkYXlzLmlzRm9ybWF0LnRlc3QoZm9ybWF0KVxuICAgICAgICAgICAgICAgICAgICAgID8gJ2Zvcm1hdCdcbiAgICAgICAgICAgICAgICAgICAgICA6ICdzdGFuZGFsb25lJ1xuICAgICAgICAgICAgICBdO1xuICAgICAgICByZXR1cm4gbSA9PT0gdHJ1ZVxuICAgICAgICAgICAgPyBzaGlmdFdlZWtkYXlzKHdlZWtkYXlzLCB0aGlzLl93ZWVrLmRvdylcbiAgICAgICAgICAgIDogbVxuICAgICAgICAgICAgPyB3ZWVrZGF5c1ttLmRheSgpXVxuICAgICAgICAgICAgOiB3ZWVrZGF5cztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb2NhbGVXZWVrZGF5c1Nob3J0KG0pIHtcbiAgICAgICAgcmV0dXJuIG0gPT09IHRydWVcbiAgICAgICAgICAgID8gc2hpZnRXZWVrZGF5cyh0aGlzLl93ZWVrZGF5c1Nob3J0LCB0aGlzLl93ZWVrLmRvdylcbiAgICAgICAgICAgIDogbVxuICAgICAgICAgICAgPyB0aGlzLl93ZWVrZGF5c1Nob3J0W20uZGF5KCldXG4gICAgICAgICAgICA6IHRoaXMuX3dlZWtkYXlzU2hvcnQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9jYWxlV2Vla2RheXNNaW4obSkge1xuICAgICAgICByZXR1cm4gbSA9PT0gdHJ1ZVxuICAgICAgICAgICAgPyBzaGlmdFdlZWtkYXlzKHRoaXMuX3dlZWtkYXlzTWluLCB0aGlzLl93ZWVrLmRvdylcbiAgICAgICAgICAgIDogbVxuICAgICAgICAgICAgPyB0aGlzLl93ZWVrZGF5c01pblttLmRheSgpXVxuICAgICAgICAgICAgOiB0aGlzLl93ZWVrZGF5c01pbjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYW5kbGVTdHJpY3RQYXJzZSQxKHdlZWtkYXlOYW1lLCBmb3JtYXQsIHN0cmljdCkge1xuICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgIGlpLFxuICAgICAgICAgICAgbW9tLFxuICAgICAgICAgICAgbGxjID0gd2Vla2RheU5hbWUudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKCF0aGlzLl93ZWVrZGF5c1BhcnNlKSB7XG4gICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1BhcnNlID0gW107XG4gICAgICAgICAgICB0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX21pbldlZWtkYXlzUGFyc2UgPSBbXTtcblxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IDc7ICsraSkge1xuICAgICAgICAgICAgICAgIG1vbSA9IGNyZWF0ZVVUQyhbMjAwMCwgMV0pLmRheShpKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9taW5XZWVrZGF5c1BhcnNlW2ldID0gdGhpcy53ZWVrZGF5c01pbihcbiAgICAgICAgICAgICAgICAgICAgbW9tLFxuICAgICAgICAgICAgICAgICAgICAnJ1xuICAgICAgICAgICAgICAgICkudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2VbaV0gPSB0aGlzLndlZWtkYXlzU2hvcnQoXG4gICAgICAgICAgICAgICAgICAgIG1vbSxcbiAgICAgICAgICAgICAgICAgICAgJydcbiAgICAgICAgICAgICAgICApLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNQYXJzZVtpXSA9IHRoaXMud2Vla2RheXMobW9tLCAnJykudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdHJpY3QpIHtcbiAgICAgICAgICAgIGlmIChmb3JtYXQgPT09ICdkZGRkJykge1xuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3dlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZm9ybWF0ID09PSAnZGRkJykge1xuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9taW5XZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoZm9ybWF0ID09PSAnZGRkZCcpIHtcbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl93ZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIGlmIChpaSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX21pbldlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZm9ybWF0ID09PSAnZGRkJykge1xuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICBpZiAoaWkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fd2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICBpZiAoaWkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fbWluV2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9taW5XZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIGlmIChpaSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl93ZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIGlmIChpaSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvY2FsZVdlZWtkYXlzUGFyc2Uod2Vla2RheU5hbWUsIGZvcm1hdCwgc3RyaWN0KSB7XG4gICAgICAgIHZhciBpLCBtb20sIHJlZ2V4O1xuXG4gICAgICAgIGlmICh0aGlzLl93ZWVrZGF5c1BhcnNlRXhhY3QpIHtcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGVTdHJpY3RQYXJzZSQxLmNhbGwodGhpcywgd2Vla2RheU5hbWUsIGZvcm1hdCwgc3RyaWN0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5fd2Vla2RheXNQYXJzZSkge1xuICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNQYXJzZSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fbWluV2Vla2RheXNQYXJzZSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlID0gW107XG4gICAgICAgICAgICB0aGlzLl9mdWxsV2Vla2RheXNQYXJzZSA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDc7IGkrKykge1xuICAgICAgICAgICAgLy8gbWFrZSB0aGUgcmVnZXggaWYgd2UgZG9uJ3QgaGF2ZSBpdCBhbHJlYWR5XG5cbiAgICAgICAgICAgIG1vbSA9IGNyZWF0ZVVUQyhbMjAwMCwgMV0pLmRheShpKTtcbiAgICAgICAgICAgIGlmIChzdHJpY3QgJiYgIXRoaXMuX2Z1bGxXZWVrZGF5c1BhcnNlW2ldKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZnVsbFdlZWtkYXlzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKFxuICAgICAgICAgICAgICAgICAgICAnXicgKyB0aGlzLndlZWtkYXlzKG1vbSwgJycpLnJlcGxhY2UoJy4nLCAnXFxcXC4/JykgKyAnJCcsXG4gICAgICAgICAgICAgICAgICAgICdpJ1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlW2ldID0gbmV3IFJlZ0V4cChcbiAgICAgICAgICAgICAgICAgICAgJ14nICsgdGhpcy53ZWVrZGF5c1Nob3J0KG1vbSwgJycpLnJlcGxhY2UoJy4nLCAnXFxcXC4/JykgKyAnJCcsXG4gICAgICAgICAgICAgICAgICAgICdpJ1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgdGhpcy5fbWluV2Vla2RheXNQYXJzZVtpXSA9IG5ldyBSZWdFeHAoXG4gICAgICAgICAgICAgICAgICAgICdeJyArIHRoaXMud2Vla2RheXNNaW4obW9tLCAnJykucmVwbGFjZSgnLicsICdcXFxcLj8nKSArICckJyxcbiAgICAgICAgICAgICAgICAgICAgJ2knXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5fd2Vla2RheXNQYXJzZVtpXSkge1xuICAgICAgICAgICAgICAgIHJlZ2V4ID1cbiAgICAgICAgICAgICAgICAgICAgJ14nICtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy53ZWVrZGF5cyhtb20sICcnKSArXG4gICAgICAgICAgICAgICAgICAgICd8XicgK1xuICAgICAgICAgICAgICAgICAgICB0aGlzLndlZWtkYXlzU2hvcnQobW9tLCAnJykgK1xuICAgICAgICAgICAgICAgICAgICAnfF4nICtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy53ZWVrZGF5c01pbihtb20sICcnKTtcbiAgICAgICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1BhcnNlW2ldID0gbmV3IFJlZ0V4cChyZWdleC5yZXBsYWNlKCcuJywgJycpLCAnaScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdGVzdCB0aGUgcmVnZXhcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBzdHJpY3QgJiZcbiAgICAgICAgICAgICAgICBmb3JtYXQgPT09ICdkZGRkJyAmJlxuICAgICAgICAgICAgICAgIHRoaXMuX2Z1bGxXZWVrZGF5c1BhcnNlW2ldLnRlc3Qod2Vla2RheU5hbWUpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICAgICAgc3RyaWN0ICYmXG4gICAgICAgICAgICAgICAgZm9ybWF0ID09PSAnZGRkJyAmJlxuICAgICAgICAgICAgICAgIHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZVtpXS50ZXN0KHdlZWtkYXlOYW1lKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgICAgIHN0cmljdCAmJlxuICAgICAgICAgICAgICAgIGZvcm1hdCA9PT0gJ2RkJyAmJlxuICAgICAgICAgICAgICAgIHRoaXMuX21pbldlZWtkYXlzUGFyc2VbaV0udGVzdCh3ZWVrZGF5TmFtZSlcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghc3RyaWN0ICYmIHRoaXMuX3dlZWtkYXlzUGFyc2VbaV0udGVzdCh3ZWVrZGF5TmFtZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIE1PTUVOVFNcblxuICAgIGZ1bmN0aW9uIGdldFNldERheU9mV2VlayhpbnB1dCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQgIT0gbnVsbCA/IHRoaXMgOiBOYU47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRheSA9IHRoaXMuX2lzVVRDID8gdGhpcy5fZC5nZXRVVENEYXkoKSA6IHRoaXMuX2QuZ2V0RGF5KCk7XG4gICAgICAgIGlmIChpbnB1dCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpbnB1dCA9IHBhcnNlV2Vla2RheShpbnB1dCwgdGhpcy5sb2NhbGVEYXRhKCkpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWRkKGlucHV0IC0gZGF5LCAnZCcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGRheTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFNldExvY2FsZURheU9mV2VlayhpbnB1dCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQgIT0gbnVsbCA/IHRoaXMgOiBOYU47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHdlZWtkYXkgPSAodGhpcy5kYXkoKSArIDcgLSB0aGlzLmxvY2FsZURhdGEoKS5fd2Vlay5kb3cpICUgNztcbiAgICAgICAgcmV0dXJuIGlucHV0ID09IG51bGwgPyB3ZWVrZGF5IDogdGhpcy5hZGQoaW5wdXQgLSB3ZWVrZGF5LCAnZCcpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFNldElTT0RheU9mV2VlayhpbnB1dCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQgIT0gbnVsbCA/IHRoaXMgOiBOYU47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBiZWhhdmVzIHRoZSBzYW1lIGFzIG1vbWVudCNkYXkgZXhjZXB0XG4gICAgICAgIC8vIGFzIGEgZ2V0dGVyLCByZXR1cm5zIDcgaW5zdGVhZCBvZiAwICgxLTcgcmFuZ2UgaW5zdGVhZCBvZiAwLTYpXG4gICAgICAgIC8vIGFzIGEgc2V0dGVyLCBzdW5kYXkgc2hvdWxkIGJlbG9uZyB0byB0aGUgcHJldmlvdXMgd2Vlay5cblxuICAgICAgICBpZiAoaW5wdXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIHdlZWtkYXkgPSBwYXJzZUlzb1dlZWtkYXkoaW5wdXQsIHRoaXMubG9jYWxlRGF0YSgpKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRheSh0aGlzLmRheSgpICUgNyA/IHdlZWtkYXkgOiB3ZWVrZGF5IC0gNyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXkoKSB8fCA3O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gd2Vla2RheXNSZWdleChpc1N0cmljdCkge1xuICAgICAgICBpZiAodGhpcy5fd2Vla2RheXNQYXJzZUV4YWN0KSB7XG4gICAgICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ193ZWVrZGF5c1JlZ2V4JykpIHtcbiAgICAgICAgICAgICAgICBjb21wdXRlV2Vla2RheXNQYXJzZS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzU3RyaWN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzU3RyaWN0UmVnZXg7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c1JlZ2V4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfd2Vla2RheXNSZWdleCcpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNSZWdleCA9IGRlZmF1bHRXZWVrZGF5c1JlZ2V4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzU3RyaWN0UmVnZXggJiYgaXNTdHJpY3RcbiAgICAgICAgICAgICAgICA/IHRoaXMuX3dlZWtkYXlzU3RyaWN0UmVnZXhcbiAgICAgICAgICAgICAgICA6IHRoaXMuX3dlZWtkYXlzUmVnZXg7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB3ZWVrZGF5c1Nob3J0UmVnZXgoaXNTdHJpY3QpIHtcbiAgICAgICAgaWYgKHRoaXMuX3dlZWtkYXlzUGFyc2VFeGFjdCkge1xuICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfd2Vla2RheXNSZWdleCcpKSB7XG4gICAgICAgICAgICAgICAgY29tcHV0ZVdlZWtkYXlzUGFyc2UuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1N0cmljdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c1Nob3J0U3RyaWN0UmVnZXg7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c1Nob3J0UmVnZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ193ZWVrZGF5c1Nob3J0UmVnZXgnKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzU2hvcnRSZWdleCA9IGRlZmF1bHRXZWVrZGF5c1Nob3J0UmVnZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNTaG9ydFN0cmljdFJlZ2V4ICYmIGlzU3RyaWN0XG4gICAgICAgICAgICAgICAgPyB0aGlzLl93ZWVrZGF5c1Nob3J0U3RyaWN0UmVnZXhcbiAgICAgICAgICAgICAgICA6IHRoaXMuX3dlZWtkYXlzU2hvcnRSZWdleDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHdlZWtkYXlzTWluUmVnZXgoaXNTdHJpY3QpIHtcbiAgICAgICAgaWYgKHRoaXMuX3dlZWtkYXlzUGFyc2VFeGFjdCkge1xuICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfd2Vla2RheXNSZWdleCcpKSB7XG4gICAgICAgICAgICAgICAgY29tcHV0ZVdlZWtkYXlzUGFyc2UuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1N0cmljdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c01pblN0cmljdFJlZ2V4O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNNaW5SZWdleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX3dlZWtkYXlzTWluUmVnZXgnKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzTWluUmVnZXggPSBkZWZhdWx0V2Vla2RheXNNaW5SZWdleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c01pblN0cmljdFJlZ2V4ICYmIGlzU3RyaWN0XG4gICAgICAgICAgICAgICAgPyB0aGlzLl93ZWVrZGF5c01pblN0cmljdFJlZ2V4XG4gICAgICAgICAgICAgICAgOiB0aGlzLl93ZWVrZGF5c01pblJlZ2V4O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29tcHV0ZVdlZWtkYXlzUGFyc2UoKSB7XG4gICAgICAgIGZ1bmN0aW9uIGNtcExlblJldihhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gYi5sZW5ndGggLSBhLmxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBtaW5QaWVjZXMgPSBbXSxcbiAgICAgICAgICAgIHNob3J0UGllY2VzID0gW10sXG4gICAgICAgICAgICBsb25nUGllY2VzID0gW10sXG4gICAgICAgICAgICBtaXhlZFBpZWNlcyA9IFtdLFxuICAgICAgICAgICAgaSxcbiAgICAgICAgICAgIG1vbSxcbiAgICAgICAgICAgIG1pbnAsXG4gICAgICAgICAgICBzaG9ydHAsXG4gICAgICAgICAgICBsb25ncDtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDc7IGkrKykge1xuICAgICAgICAgICAgLy8gbWFrZSB0aGUgcmVnZXggaWYgd2UgZG9uJ3QgaGF2ZSBpdCBhbHJlYWR5XG4gICAgICAgICAgICBtb20gPSBjcmVhdGVVVEMoWzIwMDAsIDFdKS5kYXkoaSk7XG4gICAgICAgICAgICBtaW5wID0gcmVnZXhFc2NhcGUodGhpcy53ZWVrZGF5c01pbihtb20sICcnKSk7XG4gICAgICAgICAgICBzaG9ydHAgPSByZWdleEVzY2FwZSh0aGlzLndlZWtkYXlzU2hvcnQobW9tLCAnJykpO1xuICAgICAgICAgICAgbG9uZ3AgPSByZWdleEVzY2FwZSh0aGlzLndlZWtkYXlzKG1vbSwgJycpKTtcbiAgICAgICAgICAgIG1pblBpZWNlcy5wdXNoKG1pbnApO1xuICAgICAgICAgICAgc2hvcnRQaWVjZXMucHVzaChzaG9ydHApO1xuICAgICAgICAgICAgbG9uZ1BpZWNlcy5wdXNoKGxvbmdwKTtcbiAgICAgICAgICAgIG1peGVkUGllY2VzLnB1c2gobWlucCk7XG4gICAgICAgICAgICBtaXhlZFBpZWNlcy5wdXNoKHNob3J0cCk7XG4gICAgICAgICAgICBtaXhlZFBpZWNlcy5wdXNoKGxvbmdwKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTb3J0aW5nIG1ha2VzIHN1cmUgaWYgb25lIHdlZWtkYXkgKG9yIGFiYnIpIGlzIGEgcHJlZml4IG9mIGFub3RoZXIgaXRcbiAgICAgICAgLy8gd2lsbCBtYXRjaCB0aGUgbG9uZ2VyIHBpZWNlLlxuICAgICAgICBtaW5QaWVjZXMuc29ydChjbXBMZW5SZXYpO1xuICAgICAgICBzaG9ydFBpZWNlcy5zb3J0KGNtcExlblJldik7XG4gICAgICAgIGxvbmdQaWVjZXMuc29ydChjbXBMZW5SZXYpO1xuICAgICAgICBtaXhlZFBpZWNlcy5zb3J0KGNtcExlblJldik7XG5cbiAgICAgICAgdGhpcy5fd2Vla2RheXNSZWdleCA9IG5ldyBSZWdFeHAoJ14oJyArIG1peGVkUGllY2VzLmpvaW4oJ3wnKSArICcpJywgJ2knKTtcbiAgICAgICAgdGhpcy5fd2Vla2RheXNTaG9ydFJlZ2V4ID0gdGhpcy5fd2Vla2RheXNSZWdleDtcbiAgICAgICAgdGhpcy5fd2Vla2RheXNNaW5SZWdleCA9IHRoaXMuX3dlZWtkYXlzUmVnZXg7XG5cbiAgICAgICAgdGhpcy5fd2Vla2RheXNTdHJpY3RSZWdleCA9IG5ldyBSZWdFeHAoXG4gICAgICAgICAgICAnXignICsgbG9uZ1BpZWNlcy5qb2luKCd8JykgKyAnKScsXG4gICAgICAgICAgICAnaSdcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5fd2Vla2RheXNTaG9ydFN0cmljdFJlZ2V4ID0gbmV3IFJlZ0V4cChcbiAgICAgICAgICAgICdeKCcgKyBzaG9ydFBpZWNlcy5qb2luKCd8JykgKyAnKScsXG4gICAgICAgICAgICAnaSdcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5fd2Vla2RheXNNaW5TdHJpY3RSZWdleCA9IG5ldyBSZWdFeHAoXG4gICAgICAgICAgICAnXignICsgbWluUGllY2VzLmpvaW4oJ3wnKSArICcpJyxcbiAgICAgICAgICAgICdpJ1xuICAgICAgICApO1xuICAgIH1cblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGZ1bmN0aW9uIGhGb3JtYXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhvdXJzKCkgJSAxMiB8fCAxMjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBrRm9ybWF0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ob3VycygpIHx8IDI0O1xuICAgIH1cblxuICAgIGFkZEZvcm1hdFRva2VuKCdIJywgWydISCcsIDJdLCAwLCAnaG91cicpO1xuICAgIGFkZEZvcm1hdFRva2VuKCdoJywgWydoaCcsIDJdLCAwLCBoRm9ybWF0KTtcbiAgICBhZGRGb3JtYXRUb2tlbignaycsIFsna2snLCAyXSwgMCwga0Zvcm1hdCk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignaG1tJywgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJycgKyBoRm9ybWF0LmFwcGx5KHRoaXMpICsgemVyb0ZpbGwodGhpcy5taW51dGVzKCksIDIpO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ2htbXNzJywgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgJycgK1xuICAgICAgICAgICAgaEZvcm1hdC5hcHBseSh0aGlzKSArXG4gICAgICAgICAgICB6ZXJvRmlsbCh0aGlzLm1pbnV0ZXMoKSwgMikgK1xuICAgICAgICAgICAgemVyb0ZpbGwodGhpcy5zZWNvbmRzKCksIDIpXG4gICAgICAgICk7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignSG1tJywgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJycgKyB0aGlzLmhvdXJzKCkgKyB6ZXJvRmlsbCh0aGlzLm1pbnV0ZXMoKSwgMik7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignSG1tc3MnLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAnJyArXG4gICAgICAgICAgICB0aGlzLmhvdXJzKCkgK1xuICAgICAgICAgICAgemVyb0ZpbGwodGhpcy5taW51dGVzKCksIDIpICtcbiAgICAgICAgICAgIHplcm9GaWxsKHRoaXMuc2Vjb25kcygpLCAyKVxuICAgICAgICApO1xuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gbWVyaWRpZW0odG9rZW4sIGxvd2VyY2FzZSkge1xuICAgICAgICBhZGRGb3JtYXRUb2tlbih0b2tlbiwgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLm1lcmlkaWVtKFxuICAgICAgICAgICAgICAgIHRoaXMuaG91cnMoKSxcbiAgICAgICAgICAgICAgICB0aGlzLm1pbnV0ZXMoKSxcbiAgICAgICAgICAgICAgICBsb3dlcmNhc2VcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIG1lcmlkaWVtKCdhJywgdHJ1ZSk7XG4gICAgbWVyaWRpZW0oJ0EnLCBmYWxzZSk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ2hvdXInLCAnaCcpO1xuXG4gICAgLy8gUFJJT1JJVFlcbiAgICBhZGRVbml0UHJpb3JpdHkoJ2hvdXInLCAxMyk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBmdW5jdGlvbiBtYXRjaE1lcmlkaWVtKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZS5fbWVyaWRpZW1QYXJzZTtcbiAgICB9XG5cbiAgICBhZGRSZWdleFRva2VuKCdhJywgbWF0Y2hNZXJpZGllbSk7XG4gICAgYWRkUmVnZXhUb2tlbignQScsIG1hdGNoTWVyaWRpZW0pO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0gnLCBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2gnLCBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2snLCBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0hIJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2hoJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2trJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuXG4gICAgYWRkUmVnZXhUb2tlbignaG1tJywgbWF0Y2gzdG80KTtcbiAgICBhZGRSZWdleFRva2VuKCdobW1zcycsIG1hdGNoNXRvNik7XG4gICAgYWRkUmVnZXhUb2tlbignSG1tJywgbWF0Y2gzdG80KTtcbiAgICBhZGRSZWdleFRva2VuKCdIbW1zcycsIG1hdGNoNXRvNik7XG5cbiAgICBhZGRQYXJzZVRva2VuKFsnSCcsICdISCddLCBIT1VSKTtcbiAgICBhZGRQYXJzZVRva2VuKFsnaycsICdrayddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgdmFyIGtJbnB1dCA9IHRvSW50KGlucHV0KTtcbiAgICAgICAgYXJyYXlbSE9VUl0gPSBrSW5wdXQgPT09IDI0ID8gMCA6IGtJbnB1dDtcbiAgICB9KTtcbiAgICBhZGRQYXJzZVRva2VuKFsnYScsICdBJ10sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICBjb25maWcuX2lzUG0gPSBjb25maWcuX2xvY2FsZS5pc1BNKGlucHV0KTtcbiAgICAgICAgY29uZmlnLl9tZXJpZGllbSA9IGlucHV0O1xuICAgIH0pO1xuICAgIGFkZFBhcnNlVG9rZW4oWydoJywgJ2hoJ10sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICBhcnJheVtIT1VSXSA9IHRvSW50KGlucHV0KTtcbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuYmlnSG91ciA9IHRydWU7XG4gICAgfSk7XG4gICAgYWRkUGFyc2VUb2tlbignaG1tJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIHZhciBwb3MgPSBpbnB1dC5sZW5ndGggLSAyO1xuICAgICAgICBhcnJheVtIT1VSXSA9IHRvSW50KGlucHV0LnN1YnN0cigwLCBwb3MpKTtcbiAgICAgICAgYXJyYXlbTUlOVVRFXSA9IHRvSW50KGlucHV0LnN1YnN0cihwb3MpKTtcbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuYmlnSG91ciA9IHRydWU7XG4gICAgfSk7XG4gICAgYWRkUGFyc2VUb2tlbignaG1tc3MnLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgdmFyIHBvczEgPSBpbnB1dC5sZW5ndGggLSA0LFxuICAgICAgICAgICAgcG9zMiA9IGlucHV0Lmxlbmd0aCAtIDI7XG4gICAgICAgIGFycmF5W0hPVVJdID0gdG9JbnQoaW5wdXQuc3Vic3RyKDAsIHBvczEpKTtcbiAgICAgICAgYXJyYXlbTUlOVVRFXSA9IHRvSW50KGlucHV0LnN1YnN0cihwb3MxLCAyKSk7XG4gICAgICAgIGFycmF5W1NFQ09ORF0gPSB0b0ludChpbnB1dC5zdWJzdHIocG9zMikpO1xuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5iaWdIb3VyID0gdHJ1ZTtcbiAgICB9KTtcbiAgICBhZGRQYXJzZVRva2VuKCdIbW0nLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgdmFyIHBvcyA9IGlucHV0Lmxlbmd0aCAtIDI7XG4gICAgICAgIGFycmF5W0hPVVJdID0gdG9JbnQoaW5wdXQuc3Vic3RyKDAsIHBvcykpO1xuICAgICAgICBhcnJheVtNSU5VVEVdID0gdG9JbnQoaW5wdXQuc3Vic3RyKHBvcykpO1xuICAgIH0pO1xuICAgIGFkZFBhcnNlVG9rZW4oJ0htbXNzJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIHZhciBwb3MxID0gaW5wdXQubGVuZ3RoIC0gNCxcbiAgICAgICAgICAgIHBvczIgPSBpbnB1dC5sZW5ndGggLSAyO1xuICAgICAgICBhcnJheVtIT1VSXSA9IHRvSW50KGlucHV0LnN1YnN0cigwLCBwb3MxKSk7XG4gICAgICAgIGFycmF5W01JTlVURV0gPSB0b0ludChpbnB1dC5zdWJzdHIocG9zMSwgMikpO1xuICAgICAgICBhcnJheVtTRUNPTkRdID0gdG9JbnQoaW5wdXQuc3Vic3RyKHBvczIpKTtcbiAgICB9KTtcblxuICAgIC8vIExPQ0FMRVNcblxuICAgIGZ1bmN0aW9uIGxvY2FsZUlzUE0oaW5wdXQpIHtcbiAgICAgICAgLy8gSUU4IFF1aXJrcyBNb2RlICYgSUU3IFN0YW5kYXJkcyBNb2RlIGRvIG5vdCBhbGxvdyBhY2Nlc3Npbmcgc3RyaW5ncyBsaWtlIGFycmF5c1xuICAgICAgICAvLyBVc2luZyBjaGFyQXQgc2hvdWxkIGJlIG1vcmUgY29tcGF0aWJsZS5cbiAgICAgICAgcmV0dXJuIChpbnB1dCArICcnKS50b0xvd2VyQ2FzZSgpLmNoYXJBdCgwKSA9PT0gJ3AnO1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0TG9jYWxlTWVyaWRpZW1QYXJzZSA9IC9bYXBdXFwuP20/XFwuPy9pLFxuICAgICAgICAvLyBTZXR0aW5nIHRoZSBob3VyIHNob3VsZCBrZWVwIHRoZSB0aW1lLCBiZWNhdXNlIHRoZSB1c2VyIGV4cGxpY2l0bHlcbiAgICAgICAgLy8gc3BlY2lmaWVkIHdoaWNoIGhvdXIgdGhleSB3YW50LiBTbyB0cnlpbmcgdG8gbWFpbnRhaW4gdGhlIHNhbWUgaG91ciAoaW5cbiAgICAgICAgLy8gYSBuZXcgdGltZXpvbmUpIG1ha2VzIHNlbnNlLiBBZGRpbmcvc3VidHJhY3RpbmcgaG91cnMgZG9lcyBub3QgZm9sbG93XG4gICAgICAgIC8vIHRoaXMgcnVsZS5cbiAgICAgICAgZ2V0U2V0SG91ciA9IG1ha2VHZXRTZXQoJ0hvdXJzJywgdHJ1ZSk7XG5cbiAgICBmdW5jdGlvbiBsb2NhbGVNZXJpZGllbShob3VycywgbWludXRlcywgaXNMb3dlcikge1xuICAgICAgICBpZiAoaG91cnMgPiAxMSkge1xuICAgICAgICAgICAgcmV0dXJuIGlzTG93ZXIgPyAncG0nIDogJ1BNJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBpc0xvd2VyID8gJ2FtJyA6ICdBTSc7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgYmFzZUNvbmZpZyA9IHtcbiAgICAgICAgY2FsZW5kYXI6IGRlZmF1bHRDYWxlbmRhcixcbiAgICAgICAgbG9uZ0RhdGVGb3JtYXQ6IGRlZmF1bHRMb25nRGF0ZUZvcm1hdCxcbiAgICAgICAgaW52YWxpZERhdGU6IGRlZmF1bHRJbnZhbGlkRGF0ZSxcbiAgICAgICAgb3JkaW5hbDogZGVmYXVsdE9yZGluYWwsXG4gICAgICAgIGRheU9mTW9udGhPcmRpbmFsUGFyc2U6IGRlZmF1bHREYXlPZk1vbnRoT3JkaW5hbFBhcnNlLFxuICAgICAgICByZWxhdGl2ZVRpbWU6IGRlZmF1bHRSZWxhdGl2ZVRpbWUsXG5cbiAgICAgICAgbW9udGhzOiBkZWZhdWx0TG9jYWxlTW9udGhzLFxuICAgICAgICBtb250aHNTaG9ydDogZGVmYXVsdExvY2FsZU1vbnRoc1Nob3J0LFxuXG4gICAgICAgIHdlZWs6IGRlZmF1bHRMb2NhbGVXZWVrLFxuXG4gICAgICAgIHdlZWtkYXlzOiBkZWZhdWx0TG9jYWxlV2Vla2RheXMsXG4gICAgICAgIHdlZWtkYXlzTWluOiBkZWZhdWx0TG9jYWxlV2Vla2RheXNNaW4sXG4gICAgICAgIHdlZWtkYXlzU2hvcnQ6IGRlZmF1bHRMb2NhbGVXZWVrZGF5c1Nob3J0LFxuXG4gICAgICAgIG1lcmlkaWVtUGFyc2U6IGRlZmF1bHRMb2NhbGVNZXJpZGllbVBhcnNlLFxuICAgIH07XG5cbiAgICAvLyBpbnRlcm5hbCBzdG9yYWdlIGZvciBsb2NhbGUgY29uZmlnIGZpbGVzXG4gICAgdmFyIGxvY2FsZXMgPSB7fSxcbiAgICAgICAgbG9jYWxlRmFtaWxpZXMgPSB7fSxcbiAgICAgICAgZ2xvYmFsTG9jYWxlO1xuXG4gICAgZnVuY3Rpb24gY29tbW9uUHJlZml4KGFycjEsIGFycjIpIHtcbiAgICAgICAgdmFyIGksXG4gICAgICAgICAgICBtaW5sID0gTWF0aC5taW4oYXJyMS5sZW5ndGgsIGFycjIubGVuZ3RoKTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG1pbmw7IGkgKz0gMSkge1xuICAgICAgICAgICAgaWYgKGFycjFbaV0gIT09IGFycjJbaV0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWlubDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBub3JtYWxpemVMb2NhbGUoa2V5KSB7XG4gICAgICAgIHJldHVybiBrZXkgPyBrZXkudG9Mb3dlckNhc2UoKS5yZXBsYWNlKCdfJywgJy0nKSA6IGtleTtcbiAgICB9XG5cbiAgICAvLyBwaWNrIHRoZSBsb2NhbGUgZnJvbSB0aGUgYXJyYXlcbiAgICAvLyB0cnkgWydlbi1hdScsICdlbi1nYiddIGFzICdlbi1hdScsICdlbi1nYicsICdlbicsIGFzIGluIG1vdmUgdGhyb3VnaCB0aGUgbGlzdCB0cnlpbmcgZWFjaFxuICAgIC8vIHN1YnN0cmluZyBmcm9tIG1vc3Qgc3BlY2lmaWMgdG8gbGVhc3QsIGJ1dCBtb3ZlIHRvIHRoZSBuZXh0IGFycmF5IGl0ZW0gaWYgaXQncyBhIG1vcmUgc3BlY2lmaWMgdmFyaWFudCB0aGFuIHRoZSBjdXJyZW50IHJvb3RcbiAgICBmdW5jdGlvbiBjaG9vc2VMb2NhbGUobmFtZXMpIHtcbiAgICAgICAgdmFyIGkgPSAwLFxuICAgICAgICAgICAgaixcbiAgICAgICAgICAgIG5leHQsXG4gICAgICAgICAgICBsb2NhbGUsXG4gICAgICAgICAgICBzcGxpdDtcblxuICAgICAgICB3aGlsZSAoaSA8IG5hbWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgc3BsaXQgPSBub3JtYWxpemVMb2NhbGUobmFtZXNbaV0pLnNwbGl0KCctJyk7XG4gICAgICAgICAgICBqID0gc3BsaXQubGVuZ3RoO1xuICAgICAgICAgICAgbmV4dCA9IG5vcm1hbGl6ZUxvY2FsZShuYW1lc1tpICsgMV0pO1xuICAgICAgICAgICAgbmV4dCA9IG5leHQgPyBuZXh0LnNwbGl0KCctJykgOiBudWxsO1xuICAgICAgICAgICAgd2hpbGUgKGogPiAwKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxlID0gbG9hZExvY2FsZShzcGxpdC5zbGljZSgwLCBqKS5qb2luKCctJykpO1xuICAgICAgICAgICAgICAgIGlmIChsb2NhbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxvY2FsZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICBuZXh0ICYmXG4gICAgICAgICAgICAgICAgICAgIG5leHQubGVuZ3RoID49IGogJiZcbiAgICAgICAgICAgICAgICAgICAgY29tbW9uUHJlZml4KHNwbGl0LCBuZXh0KSA+PSBqIC0gMVxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAvL3RoZSBuZXh0IGFycmF5IGl0ZW0gaXMgYmV0dGVyIHRoYW4gYSBzaGFsbG93ZXIgc3Vic3RyaW5nIG9mIHRoaXMgb25lXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBqLS07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdsb2JhbExvY2FsZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb2FkTG9jYWxlKG5hbWUpIHtcbiAgICAgICAgdmFyIG9sZExvY2FsZSA9IG51bGwsXG4gICAgICAgICAgICBhbGlhc2VkUmVxdWlyZTtcbiAgICAgICAgLy8gVE9ETzogRmluZCBhIGJldHRlciB3YXkgdG8gcmVnaXN0ZXIgYW5kIGxvYWQgYWxsIHRoZSBsb2NhbGVzIGluIE5vZGVcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgbG9jYWxlc1tuYW1lXSA9PT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgbW9kdWxlICYmXG4gICAgICAgICAgICBtb2R1bGUuZXhwb3J0c1xuICAgICAgICApIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgb2xkTG9jYWxlID0gZ2xvYmFsTG9jYWxlLl9hYmJyO1xuICAgICAgICAgICAgICAgIGFsaWFzZWRSZXF1aXJlID0gcmVxdWlyZTtcbiAgICAgICAgICAgICAgICBhbGlhc2VkUmVxdWlyZSgnLi9sb2NhbGUvJyArIG5hbWUpO1xuICAgICAgICAgICAgICAgIGdldFNldEdsb2JhbExvY2FsZShvbGRMb2NhbGUpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIC8vIG1hcmsgYXMgbm90IGZvdW5kIHRvIGF2b2lkIHJlcGVhdGluZyBleHBlbnNpdmUgZmlsZSByZXF1aXJlIGNhbGwgY2F1c2luZyBoaWdoIENQVVxuICAgICAgICAgICAgICAgIC8vIHdoZW4gdHJ5aW5nIHRvIGZpbmQgZW4tVVMsIGVuX1VTLCBlbi11cyBmb3IgZXZlcnkgZm9ybWF0IGNhbGxcbiAgICAgICAgICAgICAgICBsb2NhbGVzW25hbWVdID0gbnVsbDsgLy8gbnVsbCBtZWFucyBub3QgZm91bmRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbG9jYWxlc1tuYW1lXTtcbiAgICB9XG5cbiAgICAvLyBUaGlzIGZ1bmN0aW9uIHdpbGwgbG9hZCBsb2NhbGUgYW5kIHRoZW4gc2V0IHRoZSBnbG9iYWwgbG9jYWxlLiAgSWZcbiAgICAvLyBubyBhcmd1bWVudHMgYXJlIHBhc3NlZCBpbiwgaXQgd2lsbCBzaW1wbHkgcmV0dXJuIHRoZSBjdXJyZW50IGdsb2JhbFxuICAgIC8vIGxvY2FsZSBrZXkuXG4gICAgZnVuY3Rpb24gZ2V0U2V0R2xvYmFsTG9jYWxlKGtleSwgdmFsdWVzKSB7XG4gICAgICAgIHZhciBkYXRhO1xuICAgICAgICBpZiAoa2V5KSB7XG4gICAgICAgICAgICBpZiAoaXNVbmRlZmluZWQodmFsdWVzKSkge1xuICAgICAgICAgICAgICAgIGRhdGEgPSBnZXRMb2NhbGUoa2V5KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IGRlZmluZUxvY2FsZShrZXksIHZhbHVlcyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgLy8gbW9tZW50LmR1cmF0aW9uLl9sb2NhbGUgPSBtb21lbnQuX2xvY2FsZSA9IGRhdGE7XG4gICAgICAgICAgICAgICAgZ2xvYmFsTG9jYWxlID0gZGF0YTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJiBjb25zb2xlLndhcm4pIHtcbiAgICAgICAgICAgICAgICAgICAgLy93YXJuIHVzZXIgaWYgYXJndW1lbnRzIGFyZSBwYXNzZWQgYnV0IHRoZSBsb2NhbGUgY291bGQgbm90IGJlIHNldFxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAgICAgICAgICAgICAnTG9jYWxlICcgKyBrZXkgKyAnIG5vdCBmb3VuZC4gRGlkIHlvdSBmb3JnZXQgdG8gbG9hZCBpdD8nXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGdsb2JhbExvY2FsZS5fYWJicjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkZWZpbmVMb2NhbGUobmFtZSwgY29uZmlnKSB7XG4gICAgICAgIGlmIChjb25maWcgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBsb2NhbGUsXG4gICAgICAgICAgICAgICAgcGFyZW50Q29uZmlnID0gYmFzZUNvbmZpZztcbiAgICAgICAgICAgIGNvbmZpZy5hYmJyID0gbmFtZTtcbiAgICAgICAgICAgIGlmIChsb2NhbGVzW25hbWVdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBkZXByZWNhdGVTaW1wbGUoXG4gICAgICAgICAgICAgICAgICAgICdkZWZpbmVMb2NhbGVPdmVycmlkZScsXG4gICAgICAgICAgICAgICAgICAgICd1c2UgbW9tZW50LnVwZGF0ZUxvY2FsZShsb2NhbGVOYW1lLCBjb25maWcpIHRvIGNoYW5nZSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdhbiBleGlzdGluZyBsb2NhbGUuIG1vbWVudC5kZWZpbmVMb2NhbGUobG9jYWxlTmFtZSwgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnY29uZmlnKSBzaG91bGQgb25seSBiZSB1c2VkIGZvciBjcmVhdGluZyBhIG5ldyBsb2NhbGUgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnU2VlIGh0dHA6Ly9tb21lbnRqcy5jb20vZ3VpZGVzLyMvd2FybmluZ3MvZGVmaW5lLWxvY2FsZS8gZm9yIG1vcmUgaW5mby4nXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBwYXJlbnRDb25maWcgPSBsb2NhbGVzW25hbWVdLl9jb25maWc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNvbmZpZy5wYXJlbnRMb2NhbGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmIChsb2NhbGVzW2NvbmZpZy5wYXJlbnRMb2NhbGVdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50Q29uZmlnID0gbG9jYWxlc1tjb25maWcucGFyZW50TG9jYWxlXS5fY29uZmlnO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxvY2FsZSA9IGxvYWRMb2NhbGUoY29uZmlnLnBhcmVudExvY2FsZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsb2NhbGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50Q29uZmlnID0gbG9jYWxlLl9jb25maWc7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWxvY2FsZUZhbWlsaWVzW2NvbmZpZy5wYXJlbnRMb2NhbGVdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxlRmFtaWxpZXNbY29uZmlnLnBhcmVudExvY2FsZV0gPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsZUZhbWlsaWVzW2NvbmZpZy5wYXJlbnRMb2NhbGVdLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnOiBjb25maWcsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9jYWxlc1tuYW1lXSA9IG5ldyBMb2NhbGUobWVyZ2VDb25maWdzKHBhcmVudENvbmZpZywgY29uZmlnKSk7XG5cbiAgICAgICAgICAgIGlmIChsb2NhbGVGYW1pbGllc1tuYW1lXSkge1xuICAgICAgICAgICAgICAgIGxvY2FsZUZhbWlsaWVzW25hbWVdLmZvckVhY2goZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVmaW5lTG9jYWxlKHgubmFtZSwgeC5jb25maWcpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBiYWNrd2FyZHMgY29tcGF0IGZvciBub3c6IGFsc28gc2V0IHRoZSBsb2NhbGVcbiAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSB3ZSBzZXQgdGhlIGxvY2FsZSBBRlRFUiBhbGwgY2hpbGQgbG9jYWxlcyBoYXZlIGJlZW5cbiAgICAgICAgICAgIC8vIGNyZWF0ZWQsIHNvIHdlIHdvbid0IGVuZCB1cCB3aXRoIHRoZSBjaGlsZCBsb2NhbGUgc2V0LlxuICAgICAgICAgICAgZ2V0U2V0R2xvYmFsTG9jYWxlKG5hbWUpO1xuXG4gICAgICAgICAgICByZXR1cm4gbG9jYWxlc1tuYW1lXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHVzZWZ1bCBmb3IgdGVzdGluZ1xuICAgICAgICAgICAgZGVsZXRlIGxvY2FsZXNbbmFtZV07XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVwZGF0ZUxvY2FsZShuYW1lLCBjb25maWcpIHtcbiAgICAgICAgaWYgKGNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgbG9jYWxlLFxuICAgICAgICAgICAgICAgIHRtcExvY2FsZSxcbiAgICAgICAgICAgICAgICBwYXJlbnRDb25maWcgPSBiYXNlQ29uZmlnO1xuXG4gICAgICAgICAgICBpZiAobG9jYWxlc1tuYW1lXSAhPSBudWxsICYmIGxvY2FsZXNbbmFtZV0ucGFyZW50TG9jYWxlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgZXhpc3RpbmcgY2hpbGQgbG9jYWxlIGluLXBsYWNlIHRvIGF2b2lkIG1lbW9yeS1sZWFrc1xuICAgICAgICAgICAgICAgIGxvY2FsZXNbbmFtZV0uc2V0KG1lcmdlQ29uZmlncyhsb2NhbGVzW25hbWVdLl9jb25maWcsIGNvbmZpZykpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBNRVJHRVxuICAgICAgICAgICAgICAgIHRtcExvY2FsZSA9IGxvYWRMb2NhbGUobmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKHRtcExvY2FsZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmVudENvbmZpZyA9IHRtcExvY2FsZS5fY29uZmlnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25maWcgPSBtZXJnZUNvbmZpZ3MocGFyZW50Q29uZmlnLCBjb25maWcpO1xuICAgICAgICAgICAgICAgIGlmICh0bXBMb2NhbGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyB1cGRhdGVMb2NhbGUgaXMgY2FsbGVkIGZvciBjcmVhdGluZyBhIG5ldyBsb2NhbGVcbiAgICAgICAgICAgICAgICAgICAgLy8gU2V0IGFiYnIgc28gaXQgd2lsbCBoYXZlIGEgbmFtZSAoZ2V0dGVycyByZXR1cm5cbiAgICAgICAgICAgICAgICAgICAgLy8gdW5kZWZpbmVkIG90aGVyd2lzZSkuXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZy5hYmJyID0gbmFtZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbG9jYWxlID0gbmV3IExvY2FsZShjb25maWcpO1xuICAgICAgICAgICAgICAgIGxvY2FsZS5wYXJlbnRMb2NhbGUgPSBsb2NhbGVzW25hbWVdO1xuICAgICAgICAgICAgICAgIGxvY2FsZXNbbmFtZV0gPSBsb2NhbGU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGJhY2t3YXJkcyBjb21wYXQgZm9yIG5vdzogYWxzbyBzZXQgdGhlIGxvY2FsZVxuICAgICAgICAgICAgZ2V0U2V0R2xvYmFsTG9jYWxlKG5hbWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gcGFzcyBudWxsIGZvciBjb25maWcgdG8gdW51cGRhdGUsIHVzZWZ1bCBmb3IgdGVzdHNcbiAgICAgICAgICAgIGlmIChsb2NhbGVzW25hbWVdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAobG9jYWxlc1tuYW1lXS5wYXJlbnRMb2NhbGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBsb2NhbGVzW25hbWVdID0gbG9jYWxlc1tuYW1lXS5wYXJlbnRMb2NhbGU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuYW1lID09PSBnZXRTZXRHbG9iYWxMb2NhbGUoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0U2V0R2xvYmFsTG9jYWxlKG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChsb2NhbGVzW25hbWVdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGxvY2FsZXNbbmFtZV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsb2NhbGVzW25hbWVdO1xuICAgIH1cblxuICAgIC8vIHJldHVybnMgbG9jYWxlIGRhdGFcbiAgICBmdW5jdGlvbiBnZXRMb2NhbGUoa2V5KSB7XG4gICAgICAgIHZhciBsb2NhbGU7XG5cbiAgICAgICAgaWYgKGtleSAmJiBrZXkuX2xvY2FsZSAmJiBrZXkuX2xvY2FsZS5fYWJicikge1xuICAgICAgICAgICAga2V5ID0ga2V5Ll9sb2NhbGUuX2FiYnI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWtleSkge1xuICAgICAgICAgICAgcmV0dXJuIGdsb2JhbExvY2FsZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNBcnJheShrZXkpKSB7XG4gICAgICAgICAgICAvL3Nob3J0LWNpcmN1aXQgZXZlcnl0aGluZyBlbHNlXG4gICAgICAgICAgICBsb2NhbGUgPSBsb2FkTG9jYWxlKGtleSk7XG4gICAgICAgICAgICBpZiAobG9jYWxlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvY2FsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGtleSA9IFtrZXldO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNob29zZUxvY2FsZShrZXkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpc3RMb2NhbGVzKCkge1xuICAgICAgICByZXR1cm4ga2V5cyhsb2NhbGVzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjaGVja092ZXJmbG93KG0pIHtcbiAgICAgICAgdmFyIG92ZXJmbG93LFxuICAgICAgICAgICAgYSA9IG0uX2E7XG5cbiAgICAgICAgaWYgKGEgJiYgZ2V0UGFyc2luZ0ZsYWdzKG0pLm92ZXJmbG93ID09PSAtMikge1xuICAgICAgICAgICAgb3ZlcmZsb3cgPVxuICAgICAgICAgICAgICAgIGFbTU9OVEhdIDwgMCB8fCBhW01PTlRIXSA+IDExXG4gICAgICAgICAgICAgICAgICAgID8gTU9OVEhcbiAgICAgICAgICAgICAgICAgICAgOiBhW0RBVEVdIDwgMSB8fCBhW0RBVEVdID4gZGF5c0luTW9udGgoYVtZRUFSXSwgYVtNT05USF0pXG4gICAgICAgICAgICAgICAgICAgID8gREFURVxuICAgICAgICAgICAgICAgICAgICA6IGFbSE9VUl0gPCAwIHx8XG4gICAgICAgICAgICAgICAgICAgICAgYVtIT1VSXSA+IDI0IHx8XG4gICAgICAgICAgICAgICAgICAgICAgKGFbSE9VUl0gPT09IDI0ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgIChhW01JTlVURV0gIT09IDAgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFbU0VDT05EXSAhPT0gMCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYVtNSUxMSVNFQ09ORF0gIT09IDApKVxuICAgICAgICAgICAgICAgICAgICA/IEhPVVJcbiAgICAgICAgICAgICAgICAgICAgOiBhW01JTlVURV0gPCAwIHx8IGFbTUlOVVRFXSA+IDU5XG4gICAgICAgICAgICAgICAgICAgID8gTUlOVVRFXG4gICAgICAgICAgICAgICAgICAgIDogYVtTRUNPTkRdIDwgMCB8fCBhW1NFQ09ORF0gPiA1OVxuICAgICAgICAgICAgICAgICAgICA/IFNFQ09ORFxuICAgICAgICAgICAgICAgICAgICA6IGFbTUlMTElTRUNPTkRdIDwgMCB8fCBhW01JTExJU0VDT05EXSA+IDk5OVxuICAgICAgICAgICAgICAgICAgICA/IE1JTExJU0VDT05EXG4gICAgICAgICAgICAgICAgICAgIDogLTE7XG5cbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MobSkuX292ZXJmbG93RGF5T2ZZZWFyICYmXG4gICAgICAgICAgICAgICAgKG92ZXJmbG93IDwgWUVBUiB8fCBvdmVyZmxvdyA+IERBVEUpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBvdmVyZmxvdyA9IERBVEU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZ2V0UGFyc2luZ0ZsYWdzKG0pLl9vdmVyZmxvd1dlZWtzICYmIG92ZXJmbG93ID09PSAtMSkge1xuICAgICAgICAgICAgICAgIG92ZXJmbG93ID0gV0VFSztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChnZXRQYXJzaW5nRmxhZ3MobSkuX292ZXJmbG93V2Vla2RheSAmJiBvdmVyZmxvdyA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBvdmVyZmxvdyA9IFdFRUtEQVk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhtKS5vdmVyZmxvdyA9IG92ZXJmbG93O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG07XG4gICAgfVxuXG4gICAgLy8gaXNvIDg2MDEgcmVnZXhcbiAgICAvLyAwMDAwLTAwLTAwIDAwMDAtVzAwIG9yIDAwMDAtVzAwLTAgKyBUICsgMDAgb3IgMDA6MDAgb3IgMDA6MDA6MDAgb3IgMDA6MDA6MDAuMDAwICsgKzAwOjAwIG9yICswMDAwIG9yICswMClcbiAgICB2YXIgZXh0ZW5kZWRJc29SZWdleCA9IC9eXFxzKigoPzpbKy1dXFxkezZ9fFxcZHs0fSktKD86XFxkXFxkLVxcZFxcZHxXXFxkXFxkLVxcZHxXXFxkXFxkfFxcZFxcZFxcZHxcXGRcXGQpKSg/OihUfCApKFxcZFxcZCg/OjpcXGRcXGQoPzo6XFxkXFxkKD86Wy4sXVxcZCspPyk/KT8pKFsrLV1cXGRcXGQoPzo6P1xcZFxcZCk/fFxccypaKT8pPyQvLFxuICAgICAgICBiYXNpY0lzb1JlZ2V4ID0gL15cXHMqKCg/OlsrLV1cXGR7Nn18XFxkezR9KSg/OlxcZFxcZFxcZFxcZHxXXFxkXFxkXFxkfFdcXGRcXGR8XFxkXFxkXFxkfFxcZFxcZHwpKSg/OihUfCApKFxcZFxcZCg/OlxcZFxcZCg/OlxcZFxcZCg/OlsuLF1cXGQrKT8pPyk/KShbKy1dXFxkXFxkKD86Oj9cXGRcXGQpP3xcXHMqWik/KT8kLyxcbiAgICAgICAgdHpSZWdleCA9IC9afFsrLV1cXGRcXGQoPzo6P1xcZFxcZCk/LyxcbiAgICAgICAgaXNvRGF0ZXMgPSBbXG4gICAgICAgICAgICBbJ1lZWVlZWS1NTS1ERCcsIC9bKy1dXFxkezZ9LVxcZFxcZC1cXGRcXGQvXSxcbiAgICAgICAgICAgIFsnWVlZWS1NTS1ERCcsIC9cXGR7NH0tXFxkXFxkLVxcZFxcZC9dLFxuICAgICAgICAgICAgWydHR0dHLVtXXVdXLUUnLCAvXFxkezR9LVdcXGRcXGQtXFxkL10sXG4gICAgICAgICAgICBbJ0dHR0ctW1ddV1cnLCAvXFxkezR9LVdcXGRcXGQvLCBmYWxzZV0sXG4gICAgICAgICAgICBbJ1lZWVktREREJywgL1xcZHs0fS1cXGR7M30vXSxcbiAgICAgICAgICAgIFsnWVlZWS1NTScsIC9cXGR7NH0tXFxkXFxkLywgZmFsc2VdLFxuICAgICAgICAgICAgWydZWVlZWVlNTUREJywgL1srLV1cXGR7MTB9L10sXG4gICAgICAgICAgICBbJ1lZWVlNTUREJywgL1xcZHs4fS9dLFxuICAgICAgICAgICAgWydHR0dHW1ddV1dFJywgL1xcZHs0fVdcXGR7M30vXSxcbiAgICAgICAgICAgIFsnR0dHR1tXXVdXJywgL1xcZHs0fVdcXGR7Mn0vLCBmYWxzZV0sXG4gICAgICAgICAgICBbJ1lZWVlEREQnLCAvXFxkezd9L10sXG4gICAgICAgICAgICBbJ1lZWVlNTScsIC9cXGR7Nn0vLCBmYWxzZV0sXG4gICAgICAgICAgICBbJ1lZWVknLCAvXFxkezR9LywgZmFsc2VdLFxuICAgICAgICBdLFxuICAgICAgICAvLyBpc28gdGltZSBmb3JtYXRzIGFuZCByZWdleGVzXG4gICAgICAgIGlzb1RpbWVzID0gW1xuICAgICAgICAgICAgWydISDptbTpzcy5TU1NTJywgL1xcZFxcZDpcXGRcXGQ6XFxkXFxkXFwuXFxkKy9dLFxuICAgICAgICAgICAgWydISDptbTpzcyxTU1NTJywgL1xcZFxcZDpcXGRcXGQ6XFxkXFxkLFxcZCsvXSxcbiAgICAgICAgICAgIFsnSEg6bW06c3MnLCAvXFxkXFxkOlxcZFxcZDpcXGRcXGQvXSxcbiAgICAgICAgICAgIFsnSEg6bW0nLCAvXFxkXFxkOlxcZFxcZC9dLFxuICAgICAgICAgICAgWydISG1tc3MuU1NTUycsIC9cXGRcXGRcXGRcXGRcXGRcXGRcXC5cXGQrL10sXG4gICAgICAgICAgICBbJ0hIbW1zcyxTU1NTJywgL1xcZFxcZFxcZFxcZFxcZFxcZCxcXGQrL10sXG4gICAgICAgICAgICBbJ0hIbW1zcycsIC9cXGRcXGRcXGRcXGRcXGRcXGQvXSxcbiAgICAgICAgICAgIFsnSEhtbScsIC9cXGRcXGRcXGRcXGQvXSxcbiAgICAgICAgICAgIFsnSEgnLCAvXFxkXFxkL10sXG4gICAgICAgIF0sXG4gICAgICAgIGFzcE5ldEpzb25SZWdleCA9IC9eXFwvP0RhdGVcXCgoLT9cXGQrKS9pLFxuICAgICAgICAvLyBSRkMgMjgyMiByZWdleDogRm9yIGRldGFpbHMgc2VlIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMyODIyI3NlY3Rpb24tMy4zXG4gICAgICAgIHJmYzI4MjIgPSAvXig/OihNb258VHVlfFdlZHxUaHV8RnJpfFNhdHxTdW4pLD9cXHMpPyhcXGR7MSwyfSlcXHMoSmFufEZlYnxNYXJ8QXByfE1heXxKdW58SnVsfEF1Z3xTZXB8T2N0fE5vdnxEZWMpXFxzKFxcZHsyLDR9KVxccyhcXGRcXGQpOihcXGRcXGQpKD86OihcXGRcXGQpKT9cXHMoPzooVVR8R01UfFtFQ01QXVtTRF1UKXwoW1p6XSl8KFsrLV1cXGR7NH0pKSQvLFxuICAgICAgICBvYnNPZmZzZXRzID0ge1xuICAgICAgICAgICAgVVQ6IDAsXG4gICAgICAgICAgICBHTVQ6IDAsXG4gICAgICAgICAgICBFRFQ6IC00ICogNjAsXG4gICAgICAgICAgICBFU1Q6IC01ICogNjAsXG4gICAgICAgICAgICBDRFQ6IC01ICogNjAsXG4gICAgICAgICAgICBDU1Q6IC02ICogNjAsXG4gICAgICAgICAgICBNRFQ6IC02ICogNjAsXG4gICAgICAgICAgICBNU1Q6IC03ICogNjAsXG4gICAgICAgICAgICBQRFQ6IC03ICogNjAsXG4gICAgICAgICAgICBQU1Q6IC04ICogNjAsXG4gICAgICAgIH07XG5cbiAgICAvLyBkYXRlIGZyb20gaXNvIGZvcm1hdFxuICAgIGZ1bmN0aW9uIGNvbmZpZ0Zyb21JU08oY29uZmlnKSB7XG4gICAgICAgIHZhciBpLFxuICAgICAgICAgICAgbCxcbiAgICAgICAgICAgIHN0cmluZyA9IGNvbmZpZy5faSxcbiAgICAgICAgICAgIG1hdGNoID0gZXh0ZW5kZWRJc29SZWdleC5leGVjKHN0cmluZykgfHwgYmFzaWNJc29SZWdleC5leGVjKHN0cmluZyksXG4gICAgICAgICAgICBhbGxvd1RpbWUsXG4gICAgICAgICAgICBkYXRlRm9ybWF0LFxuICAgICAgICAgICAgdGltZUZvcm1hdCxcbiAgICAgICAgICAgIHR6Rm9ybWF0O1xuXG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuaXNvID0gdHJ1ZTtcblxuICAgICAgICAgICAgZm9yIChpID0gMCwgbCA9IGlzb0RhdGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChpc29EYXRlc1tpXVsxXS5leGVjKG1hdGNoWzFdKSkge1xuICAgICAgICAgICAgICAgICAgICBkYXRlRm9ybWF0ID0gaXNvRGF0ZXNbaV1bMF07XG4gICAgICAgICAgICAgICAgICAgIGFsbG93VGltZSA9IGlzb0RhdGVzW2ldWzJdICE9PSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRhdGVGb3JtYXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbmZpZy5faXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYXRjaFszXSkge1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGwgPSBpc29UaW1lcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzb1RpbWVzW2ldWzFdLmV4ZWMobWF0Y2hbM10pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBtYXRjaFsyXSBzaG91bGQgYmUgJ1QnIG9yIHNwYWNlXG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lRm9ybWF0ID0gKG1hdGNoWzJdIHx8ICcgJykgKyBpc29UaW1lc1tpXVswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aW1lRm9ybWF0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWFsbG93VGltZSAmJiB0aW1lRm9ybWF0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb25maWcuX2lzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWF0Y2hbNF0pIHtcbiAgICAgICAgICAgICAgICBpZiAodHpSZWdleC5leGVjKG1hdGNoWzRdKSkge1xuICAgICAgICAgICAgICAgICAgICB0ekZvcm1hdCA9ICdaJztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25maWcuX2lzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbmZpZy5fZiA9IGRhdGVGb3JtYXQgKyAodGltZUZvcm1hdCB8fCAnJykgKyAodHpGb3JtYXQgfHwgJycpO1xuICAgICAgICAgICAgY29uZmlnRnJvbVN0cmluZ0FuZEZvcm1hdChjb25maWcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uZmlnLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBleHRyYWN0RnJvbVJGQzI4MjJTdHJpbmdzKFxuICAgICAgICB5ZWFyU3RyLFxuICAgICAgICBtb250aFN0cixcbiAgICAgICAgZGF5U3RyLFxuICAgICAgICBob3VyU3RyLFxuICAgICAgICBtaW51dGVTdHIsXG4gICAgICAgIHNlY29uZFN0clxuICAgICkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gW1xuICAgICAgICAgICAgdW50cnVuY2F0ZVllYXIoeWVhclN0ciksXG4gICAgICAgICAgICBkZWZhdWx0TG9jYWxlTW9udGhzU2hvcnQuaW5kZXhPZihtb250aFN0ciksXG4gICAgICAgICAgICBwYXJzZUludChkYXlTdHIsIDEwKSxcbiAgICAgICAgICAgIHBhcnNlSW50KGhvdXJTdHIsIDEwKSxcbiAgICAgICAgICAgIHBhcnNlSW50KG1pbnV0ZVN0ciwgMTApLFxuICAgICAgICBdO1xuXG4gICAgICAgIGlmIChzZWNvbmRTdHIpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHBhcnNlSW50KHNlY29uZFN0ciwgMTApKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdW50cnVuY2F0ZVllYXIoeWVhclN0cikge1xuICAgICAgICB2YXIgeWVhciA9IHBhcnNlSW50KHllYXJTdHIsIDEwKTtcbiAgICAgICAgaWYgKHllYXIgPD0gNDkpIHtcbiAgICAgICAgICAgIHJldHVybiAyMDAwICsgeWVhcjtcbiAgICAgICAgfSBlbHNlIGlmICh5ZWFyIDw9IDk5OSkge1xuICAgICAgICAgICAgcmV0dXJuIDE5MDAgKyB5ZWFyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB5ZWFyO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHByZXByb2Nlc3NSRkMyODIyKHMpIHtcbiAgICAgICAgLy8gUmVtb3ZlIGNvbW1lbnRzIGFuZCBmb2xkaW5nIHdoaXRlc3BhY2UgYW5kIHJlcGxhY2UgbXVsdGlwbGUtc3BhY2VzIHdpdGggYSBzaW5nbGUgc3BhY2VcbiAgICAgICAgcmV0dXJuIHNcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXChbXildKlxcKXxbXFxuXFx0XS9nLCAnICcpXG4gICAgICAgICAgICAucmVwbGFjZSgvKFxcc1xccyspL2csICcgJylcbiAgICAgICAgICAgIC5yZXBsYWNlKC9eXFxzXFxzKi8sICcnKVxuICAgICAgICAgICAgLnJlcGxhY2UoL1xcc1xccyokLywgJycpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNoZWNrV2Vla2RheSh3ZWVrZGF5U3RyLCBwYXJzZWRJbnB1dCwgY29uZmlnKSB7XG4gICAgICAgIGlmICh3ZWVrZGF5U3RyKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBSZXBsYWNlIHRoZSB2YW5pbGxhIEpTIERhdGUgb2JqZWN0IHdpdGggYW4gaW5kZXBlbmRlbnQgZGF5LW9mLXdlZWsgY2hlY2suXG4gICAgICAgICAgICB2YXIgd2Vla2RheVByb3ZpZGVkID0gZGVmYXVsdExvY2FsZVdlZWtkYXlzU2hvcnQuaW5kZXhPZih3ZWVrZGF5U3RyKSxcbiAgICAgICAgICAgICAgICB3ZWVrZGF5QWN0dWFsID0gbmV3IERhdGUoXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZElucHV0WzBdLFxuICAgICAgICAgICAgICAgICAgICBwYXJzZWRJbnB1dFsxXSxcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VkSW5wdXRbMl1cbiAgICAgICAgICAgICAgICApLmdldERheSgpO1xuICAgICAgICAgICAgaWYgKHdlZWtkYXlQcm92aWRlZCAhPT0gd2Vla2RheUFjdHVhbCkge1xuICAgICAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLndlZWtkYXlNaXNtYXRjaCA9IHRydWU7XG4gICAgICAgICAgICAgICAgY29uZmlnLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNhbGN1bGF0ZU9mZnNldChvYnNPZmZzZXQsIG1pbGl0YXJ5T2Zmc2V0LCBudW1PZmZzZXQpIHtcbiAgICAgICAgaWYgKG9ic09mZnNldCkge1xuICAgICAgICAgICAgcmV0dXJuIG9ic09mZnNldHNbb2JzT2Zmc2V0XTtcbiAgICAgICAgfSBlbHNlIGlmIChtaWxpdGFyeU9mZnNldCkge1xuICAgICAgICAgICAgLy8gdGhlIG9ubHkgYWxsb3dlZCBtaWxpdGFyeSB0eiBpcyBaXG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBobSA9IHBhcnNlSW50KG51bU9mZnNldCwgMTApLFxuICAgICAgICAgICAgICAgIG0gPSBobSAlIDEwMCxcbiAgICAgICAgICAgICAgICBoID0gKGhtIC0gbSkgLyAxMDA7XG4gICAgICAgICAgICByZXR1cm4gaCAqIDYwICsgbTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGRhdGUgYW5kIHRpbWUgZnJvbSByZWYgMjgyMiBmb3JtYXRcbiAgICBmdW5jdGlvbiBjb25maWdGcm9tUkZDMjgyMihjb25maWcpIHtcbiAgICAgICAgdmFyIG1hdGNoID0gcmZjMjgyMi5leGVjKHByZXByb2Nlc3NSRkMyODIyKGNvbmZpZy5faSkpLFxuICAgICAgICAgICAgcGFyc2VkQXJyYXk7XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgcGFyc2VkQXJyYXkgPSBleHRyYWN0RnJvbVJGQzI4MjJTdHJpbmdzKFxuICAgICAgICAgICAgICAgIG1hdGNoWzRdLFxuICAgICAgICAgICAgICAgIG1hdGNoWzNdLFxuICAgICAgICAgICAgICAgIG1hdGNoWzJdLFxuICAgICAgICAgICAgICAgIG1hdGNoWzVdLFxuICAgICAgICAgICAgICAgIG1hdGNoWzZdLFxuICAgICAgICAgICAgICAgIG1hdGNoWzddXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKCFjaGVja1dlZWtkYXkobWF0Y2hbMV0sIHBhcnNlZEFycmF5LCBjb25maWcpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25maWcuX2EgPSBwYXJzZWRBcnJheTtcbiAgICAgICAgICAgIGNvbmZpZy5fdHptID0gY2FsY3VsYXRlT2Zmc2V0KG1hdGNoWzhdLCBtYXRjaFs5XSwgbWF0Y2hbMTBdKTtcblxuICAgICAgICAgICAgY29uZmlnLl9kID0gY3JlYXRlVVRDRGF0ZS5hcHBseShudWxsLCBjb25maWcuX2EpO1xuICAgICAgICAgICAgY29uZmlnLl9kLnNldFVUQ01pbnV0ZXMoY29uZmlnLl9kLmdldFVUQ01pbnV0ZXMoKSAtIGNvbmZpZy5fdHptKTtcblxuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykucmZjMjgyMiA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25maWcuX2lzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGRhdGUgZnJvbSAxKSBBU1AuTkVULCAyKSBJU08sIDMpIFJGQyAyODIyIGZvcm1hdHMsIG9yIDQpIG9wdGlvbmFsIGZhbGxiYWNrIGlmIHBhcnNpbmcgaXNuJ3Qgc3RyaWN0XG4gICAgZnVuY3Rpb24gY29uZmlnRnJvbVN0cmluZyhjb25maWcpIHtcbiAgICAgICAgdmFyIG1hdGNoZWQgPSBhc3BOZXRKc29uUmVnZXguZXhlYyhjb25maWcuX2kpO1xuICAgICAgICBpZiAobWF0Y2hlZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUoK21hdGNoZWRbMV0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uZmlnRnJvbUlTTyhjb25maWcpO1xuICAgICAgICBpZiAoY29uZmlnLl9pc1ZhbGlkID09PSBmYWxzZSkge1xuICAgICAgICAgICAgZGVsZXRlIGNvbmZpZy5faXNWYWxpZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbmZpZ0Zyb21SRkMyODIyKGNvbmZpZyk7XG4gICAgICAgIGlmIChjb25maWcuX2lzVmFsaWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBkZWxldGUgY29uZmlnLl9pc1ZhbGlkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbmZpZy5fc3RyaWN0KSB7XG4gICAgICAgICAgICBjb25maWcuX2lzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEZpbmFsIGF0dGVtcHQsIHVzZSBJbnB1dCBGYWxsYmFja1xuICAgICAgICAgICAgaG9va3MuY3JlYXRlRnJvbUlucHV0RmFsbGJhY2soY29uZmlnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGhvb2tzLmNyZWF0ZUZyb21JbnB1dEZhbGxiYWNrID0gZGVwcmVjYXRlKFxuICAgICAgICAndmFsdWUgcHJvdmlkZWQgaXMgbm90IGluIGEgcmVjb2duaXplZCBSRkMyODIyIG9yIElTTyBmb3JtYXQuIG1vbWVudCBjb25zdHJ1Y3Rpb24gZmFsbHMgYmFjayB0byBqcyBEYXRlKCksICcgK1xuICAgICAgICAgICAgJ3doaWNoIGlzIG5vdCByZWxpYWJsZSBhY3Jvc3MgYWxsIGJyb3dzZXJzIGFuZCB2ZXJzaW9ucy4gTm9uIFJGQzI4MjIvSVNPIGRhdGUgZm9ybWF0cyBhcmUgJyArXG4gICAgICAgICAgICAnZGlzY291cmFnZWQuIFBsZWFzZSByZWZlciB0byBodHRwOi8vbW9tZW50anMuY29tL2d1aWRlcy8jL3dhcm5pbmdzL2pzLWRhdGUvIGZvciBtb3JlIGluZm8uJyxcbiAgICAgICAgZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUoY29uZmlnLl9pICsgKGNvbmZpZy5fdXNlVVRDID8gJyBVVEMnIDogJycpKTtcbiAgICAgICAgfVxuICAgICk7XG5cbiAgICAvLyBQaWNrIHRoZSBmaXJzdCBkZWZpbmVkIG9mIHR3byBvciB0aHJlZSBhcmd1bWVudHMuXG4gICAgZnVuY3Rpb24gZGVmYXVsdHMoYSwgYiwgYykge1xuICAgICAgICBpZiAoYSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gYTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYiAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gYjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjdXJyZW50RGF0ZUFycmF5KGNvbmZpZykge1xuICAgICAgICAvLyBob29rcyBpcyBhY3R1YWxseSB0aGUgZXhwb3J0ZWQgbW9tZW50IG9iamVjdFxuICAgICAgICB2YXIgbm93VmFsdWUgPSBuZXcgRGF0ZShob29rcy5ub3coKSk7XG4gICAgICAgIGlmIChjb25maWcuX3VzZVVUQykge1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICBub3dWYWx1ZS5nZXRVVENGdWxsWWVhcigpLFxuICAgICAgICAgICAgICAgIG5vd1ZhbHVlLmdldFVUQ01vbnRoKCksXG4gICAgICAgICAgICAgICAgbm93VmFsdWUuZ2V0VVRDRGF0ZSgpLFxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW25vd1ZhbHVlLmdldEZ1bGxZZWFyKCksIG5vd1ZhbHVlLmdldE1vbnRoKCksIG5vd1ZhbHVlLmdldERhdGUoKV07XG4gICAgfVxuXG4gICAgLy8gY29udmVydCBhbiBhcnJheSB0byBhIGRhdGUuXG4gICAgLy8gdGhlIGFycmF5IHNob3VsZCBtaXJyb3IgdGhlIHBhcmFtZXRlcnMgYmVsb3dcbiAgICAvLyBub3RlOiBhbGwgdmFsdWVzIHBhc3QgdGhlIHllYXIgYXJlIG9wdGlvbmFsIGFuZCB3aWxsIGRlZmF1bHQgdG8gdGhlIGxvd2VzdCBwb3NzaWJsZSB2YWx1ZS5cbiAgICAvLyBbeWVhciwgbW9udGgsIGRheSAsIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZF1cbiAgICBmdW5jdGlvbiBjb25maWdGcm9tQXJyYXkoY29uZmlnKSB7XG4gICAgICAgIHZhciBpLFxuICAgICAgICAgICAgZGF0ZSxcbiAgICAgICAgICAgIGlucHV0ID0gW10sXG4gICAgICAgICAgICBjdXJyZW50RGF0ZSxcbiAgICAgICAgICAgIGV4cGVjdGVkV2Vla2RheSxcbiAgICAgICAgICAgIHllYXJUb1VzZTtcblxuICAgICAgICBpZiAoY29uZmlnLl9kKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjdXJyZW50RGF0ZSA9IGN1cnJlbnREYXRlQXJyYXkoY29uZmlnKTtcblxuICAgICAgICAvL2NvbXB1dGUgZGF5IG9mIHRoZSB5ZWFyIGZyb20gd2Vla3MgYW5kIHdlZWtkYXlzXG4gICAgICAgIGlmIChjb25maWcuX3cgJiYgY29uZmlnLl9hW0RBVEVdID09IG51bGwgJiYgY29uZmlnLl9hW01PTlRIXSA9PSBudWxsKSB7XG4gICAgICAgICAgICBkYXlPZlllYXJGcm9tV2Vla0luZm8oY29uZmlnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vaWYgdGhlIGRheSBvZiB0aGUgeWVhciBpcyBzZXQsIGZpZ3VyZSBvdXQgd2hhdCBpdCBpc1xuICAgICAgICBpZiAoY29uZmlnLl9kYXlPZlllYXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgeWVhclRvVXNlID0gZGVmYXVsdHMoY29uZmlnLl9hW1lFQVJdLCBjdXJyZW50RGF0ZVtZRUFSXSk7XG5cbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBjb25maWcuX2RheU9mWWVhciA+IGRheXNJblllYXIoeWVhclRvVXNlKSB8fFxuICAgICAgICAgICAgICAgIGNvbmZpZy5fZGF5T2ZZZWFyID09PSAwXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5fb3ZlcmZsb3dEYXlPZlllYXIgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkYXRlID0gY3JlYXRlVVRDRGF0ZSh5ZWFyVG9Vc2UsIDAsIGNvbmZpZy5fZGF5T2ZZZWFyKTtcbiAgICAgICAgICAgIGNvbmZpZy5fYVtNT05USF0gPSBkYXRlLmdldFVUQ01vbnRoKCk7XG4gICAgICAgICAgICBjb25maWcuX2FbREFURV0gPSBkYXRlLmdldFVUQ0RhdGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERlZmF1bHQgdG8gY3VycmVudCBkYXRlLlxuICAgICAgICAvLyAqIGlmIG5vIHllYXIsIG1vbnRoLCBkYXkgb2YgbW9udGggYXJlIGdpdmVuLCBkZWZhdWx0IHRvIHRvZGF5XG4gICAgICAgIC8vICogaWYgZGF5IG9mIG1vbnRoIGlzIGdpdmVuLCBkZWZhdWx0IG1vbnRoIGFuZCB5ZWFyXG4gICAgICAgIC8vICogaWYgbW9udGggaXMgZ2l2ZW4sIGRlZmF1bHQgb25seSB5ZWFyXG4gICAgICAgIC8vICogaWYgeWVhciBpcyBnaXZlbiwgZG9uJ3QgZGVmYXVsdCBhbnl0aGluZ1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMyAmJiBjb25maWcuX2FbaV0gPT0gbnVsbDsgKytpKSB7XG4gICAgICAgICAgICBjb25maWcuX2FbaV0gPSBpbnB1dFtpXSA9IGN1cnJlbnREYXRlW2ldO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gWmVybyBvdXQgd2hhdGV2ZXIgd2FzIG5vdCBkZWZhdWx0ZWQsIGluY2x1ZGluZyB0aW1lXG4gICAgICAgIGZvciAoOyBpIDwgNzsgaSsrKSB7XG4gICAgICAgICAgICBjb25maWcuX2FbaV0gPSBpbnB1dFtpXSA9XG4gICAgICAgICAgICAgICAgY29uZmlnLl9hW2ldID09IG51bGwgPyAoaSA9PT0gMiA/IDEgOiAwKSA6IGNvbmZpZy5fYVtpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrIGZvciAyNDowMDowMC4wMDBcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgY29uZmlnLl9hW0hPVVJdID09PSAyNCAmJlxuICAgICAgICAgICAgY29uZmlnLl9hW01JTlVURV0gPT09IDAgJiZcbiAgICAgICAgICAgIGNvbmZpZy5fYVtTRUNPTkRdID09PSAwICYmXG4gICAgICAgICAgICBjb25maWcuX2FbTUlMTElTRUNPTkRdID09PSAwXG4gICAgICAgICkge1xuICAgICAgICAgICAgY29uZmlnLl9uZXh0RGF5ID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbmZpZy5fYVtIT1VSXSA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBjb25maWcuX2QgPSAoY29uZmlnLl91c2VVVEMgPyBjcmVhdGVVVENEYXRlIDogY3JlYXRlRGF0ZSkuYXBwbHkoXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgaW5wdXRcbiAgICAgICAgKTtcbiAgICAgICAgZXhwZWN0ZWRXZWVrZGF5ID0gY29uZmlnLl91c2VVVENcbiAgICAgICAgICAgID8gY29uZmlnLl9kLmdldFVUQ0RheSgpXG4gICAgICAgICAgICA6IGNvbmZpZy5fZC5nZXREYXkoKTtcblxuICAgICAgICAvLyBBcHBseSB0aW1lem9uZSBvZmZzZXQgZnJvbSBpbnB1dC4gVGhlIGFjdHVhbCB1dGNPZmZzZXQgY2FuIGJlIGNoYW5nZWRcbiAgICAgICAgLy8gd2l0aCBwYXJzZVpvbmUuXG4gICAgICAgIGlmIChjb25maWcuX3R6bSAhPSBudWxsKSB7XG4gICAgICAgICAgICBjb25maWcuX2Quc2V0VVRDTWludXRlcyhjb25maWcuX2QuZ2V0VVRDTWludXRlcygpIC0gY29uZmlnLl90em0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbmZpZy5fbmV4dERheSkge1xuICAgICAgICAgICAgY29uZmlnLl9hW0hPVVJdID0gMjQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjaGVjayBmb3IgbWlzbWF0Y2hpbmcgZGF5IG9mIHdlZWtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgY29uZmlnLl93ICYmXG4gICAgICAgICAgICB0eXBlb2YgY29uZmlnLl93LmQgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICBjb25maWcuX3cuZCAhPT0gZXhwZWN0ZWRXZWVrZGF5XG4gICAgICAgICkge1xuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykud2Vla2RheU1pc21hdGNoID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRheU9mWWVhckZyb21XZWVrSW5mbyhjb25maWcpIHtcbiAgICAgICAgdmFyIHcsIHdlZWtZZWFyLCB3ZWVrLCB3ZWVrZGF5LCBkb3csIGRveSwgdGVtcCwgd2Vla2RheU92ZXJmbG93LCBjdXJXZWVrO1xuXG4gICAgICAgIHcgPSBjb25maWcuX3c7XG4gICAgICAgIGlmICh3LkdHICE9IG51bGwgfHwgdy5XICE9IG51bGwgfHwgdy5FICE9IG51bGwpIHtcbiAgICAgICAgICAgIGRvdyA9IDE7XG4gICAgICAgICAgICBkb3kgPSA0O1xuXG4gICAgICAgICAgICAvLyBUT0RPOiBXZSBuZWVkIHRvIHRha2UgdGhlIGN1cnJlbnQgaXNvV2Vla1llYXIsIGJ1dCB0aGF0IGRlcGVuZHMgb25cbiAgICAgICAgICAgIC8vIGhvdyB3ZSBpbnRlcnByZXQgbm93IChsb2NhbCwgdXRjLCBmaXhlZCBvZmZzZXQpLiBTbyBjcmVhdGVcbiAgICAgICAgICAgIC8vIGEgbm93IHZlcnNpb24gb2YgY3VycmVudCBjb25maWcgKHRha2UgbG9jYWwvdXRjL29mZnNldCBmbGFncywgYW5kXG4gICAgICAgICAgICAvLyBjcmVhdGUgbm93KS5cbiAgICAgICAgICAgIHdlZWtZZWFyID0gZGVmYXVsdHMoXG4gICAgICAgICAgICAgICAgdy5HRyxcbiAgICAgICAgICAgICAgICBjb25maWcuX2FbWUVBUl0sXG4gICAgICAgICAgICAgICAgd2Vla09mWWVhcihjcmVhdGVMb2NhbCgpLCAxLCA0KS55ZWFyXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgd2VlayA9IGRlZmF1bHRzKHcuVywgMSk7XG4gICAgICAgICAgICB3ZWVrZGF5ID0gZGVmYXVsdHMody5FLCAxKTtcbiAgICAgICAgICAgIGlmICh3ZWVrZGF5IDwgMSB8fCB3ZWVrZGF5ID4gNykge1xuICAgICAgICAgICAgICAgIHdlZWtkYXlPdmVyZmxvdyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkb3cgPSBjb25maWcuX2xvY2FsZS5fd2Vlay5kb3c7XG4gICAgICAgICAgICBkb3kgPSBjb25maWcuX2xvY2FsZS5fd2Vlay5kb3k7XG5cbiAgICAgICAgICAgIGN1cldlZWsgPSB3ZWVrT2ZZZWFyKGNyZWF0ZUxvY2FsKCksIGRvdywgZG95KTtcblxuICAgICAgICAgICAgd2Vla1llYXIgPSBkZWZhdWx0cyh3LmdnLCBjb25maWcuX2FbWUVBUl0sIGN1cldlZWsueWVhcik7XG5cbiAgICAgICAgICAgIC8vIERlZmF1bHQgdG8gY3VycmVudCB3ZWVrLlxuICAgICAgICAgICAgd2VlayA9IGRlZmF1bHRzKHcudywgY3VyV2Vlay53ZWVrKTtcblxuICAgICAgICAgICAgaWYgKHcuZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLy8gd2Vla2RheSAtLSBsb3cgZGF5IG51bWJlcnMgYXJlIGNvbnNpZGVyZWQgbmV4dCB3ZWVrXG4gICAgICAgICAgICAgICAgd2Vla2RheSA9IHcuZDtcbiAgICAgICAgICAgICAgICBpZiAod2Vla2RheSA8IDAgfHwgd2Vla2RheSA+IDYpIHtcbiAgICAgICAgICAgICAgICAgICAgd2Vla2RheU92ZXJmbG93ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHcuZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLy8gbG9jYWwgd2Vla2RheSAtLSBjb3VudGluZyBzdGFydHMgZnJvbSBiZWdpbm5pbmcgb2Ygd2Vla1xuICAgICAgICAgICAgICAgIHdlZWtkYXkgPSB3LmUgKyBkb3c7XG4gICAgICAgICAgICAgICAgaWYgKHcuZSA8IDAgfHwgdy5lID4gNikge1xuICAgICAgICAgICAgICAgICAgICB3ZWVrZGF5T3ZlcmZsb3cgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gZGVmYXVsdCB0byBiZWdpbm5pbmcgb2Ygd2Vla1xuICAgICAgICAgICAgICAgIHdlZWtkYXkgPSBkb3c7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdlZWsgPCAxIHx8IHdlZWsgPiB3ZWVrc0luWWVhcih3ZWVrWWVhciwgZG93LCBkb3kpKSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5fb3ZlcmZsb3dXZWVrcyA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAod2Vla2RheU92ZXJmbG93ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLl9vdmVyZmxvd1dlZWtkYXkgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGVtcCA9IGRheU9mWWVhckZyb21XZWVrcyh3ZWVrWWVhciwgd2Vlaywgd2Vla2RheSwgZG93LCBkb3kpO1xuICAgICAgICAgICAgY29uZmlnLl9hW1lFQVJdID0gdGVtcC55ZWFyO1xuICAgICAgICAgICAgY29uZmlnLl9kYXlPZlllYXIgPSB0ZW1wLmRheU9mWWVhcjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGNvbnN0YW50IHRoYXQgcmVmZXJzIHRvIHRoZSBJU08gc3RhbmRhcmRcbiAgICBob29rcy5JU09fODYwMSA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gICAgLy8gY29uc3RhbnQgdGhhdCByZWZlcnMgdG8gdGhlIFJGQyAyODIyIGZvcm1cbiAgICBob29rcy5SRkNfMjgyMiA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gICAgLy8gZGF0ZSBmcm9tIHN0cmluZyBhbmQgZm9ybWF0IHN0cmluZ1xuICAgIGZ1bmN0aW9uIGNvbmZpZ0Zyb21TdHJpbmdBbmRGb3JtYXQoY29uZmlnKSB7XG4gICAgICAgIC8vIFRPRE86IE1vdmUgdGhpcyB0byBhbm90aGVyIHBhcnQgb2YgdGhlIGNyZWF0aW9uIGZsb3cgdG8gcHJldmVudCBjaXJjdWxhciBkZXBzXG4gICAgICAgIGlmIChjb25maWcuX2YgPT09IGhvb2tzLklTT184NjAxKSB7XG4gICAgICAgICAgICBjb25maWdGcm9tSVNPKGNvbmZpZyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbmZpZy5fZiA9PT0gaG9va3MuUkZDXzI4MjIpIHtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21SRkMyODIyKGNvbmZpZyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uZmlnLl9hID0gW107XG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmVtcHR5ID0gdHJ1ZTtcblxuICAgICAgICAvLyBUaGlzIGFycmF5IGlzIHVzZWQgdG8gbWFrZSBhIERhdGUsIGVpdGhlciB3aXRoIGBuZXcgRGF0ZWAgb3IgYERhdGUuVVRDYFxuICAgICAgICB2YXIgc3RyaW5nID0gJycgKyBjb25maWcuX2ksXG4gICAgICAgICAgICBpLFxuICAgICAgICAgICAgcGFyc2VkSW5wdXQsXG4gICAgICAgICAgICB0b2tlbnMsXG4gICAgICAgICAgICB0b2tlbixcbiAgICAgICAgICAgIHNraXBwZWQsXG4gICAgICAgICAgICBzdHJpbmdMZW5ndGggPSBzdHJpbmcubGVuZ3RoLFxuICAgICAgICAgICAgdG90YWxQYXJzZWRJbnB1dExlbmd0aCA9IDAsXG4gICAgICAgICAgICBlcmE7XG5cbiAgICAgICAgdG9rZW5zID1cbiAgICAgICAgICAgIGV4cGFuZEZvcm1hdChjb25maWcuX2YsIGNvbmZpZy5fbG9jYWxlKS5tYXRjaChmb3JtYXR0aW5nVG9rZW5zKSB8fCBbXTtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0b2tlbiA9IHRva2Vuc1tpXTtcbiAgICAgICAgICAgIHBhcnNlZElucHV0ID0gKHN0cmluZy5tYXRjaChnZXRQYXJzZVJlZ2V4Rm9yVG9rZW4odG9rZW4sIGNvbmZpZykpIHx8XG4gICAgICAgICAgICAgICAgW10pWzBdO1xuICAgICAgICAgICAgaWYgKHBhcnNlZElucHV0KSB7XG4gICAgICAgICAgICAgICAgc2tpcHBlZCA9IHN0cmluZy5zdWJzdHIoMCwgc3RyaW5nLmluZGV4T2YocGFyc2VkSW5wdXQpKTtcbiAgICAgICAgICAgICAgICBpZiAoc2tpcHBlZC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLnVudXNlZElucHV0LnB1c2goc2tpcHBlZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN0cmluZyA9IHN0cmluZy5zbGljZShcbiAgICAgICAgICAgICAgICAgICAgc3RyaW5nLmluZGV4T2YocGFyc2VkSW5wdXQpICsgcGFyc2VkSW5wdXQubGVuZ3RoXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB0b3RhbFBhcnNlZElucHV0TGVuZ3RoICs9IHBhcnNlZElucHV0Lmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGRvbid0IHBhcnNlIGlmIGl0J3Mgbm90IGEga25vd24gdG9rZW5cbiAgICAgICAgICAgIGlmIChmb3JtYXRUb2tlbkZ1bmN0aW9uc1t0b2tlbl0pIHtcbiAgICAgICAgICAgICAgICBpZiAocGFyc2VkSW5wdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuZW1wdHkgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS51bnVzZWRUb2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFkZFRpbWVUb0FycmF5RnJvbVRva2VuKHRva2VuLCBwYXJzZWRJbnB1dCwgY29uZmlnKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY29uZmlnLl9zdHJpY3QgJiYgIXBhcnNlZElucHV0KSB7XG4gICAgICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykudW51c2VkVG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gYWRkIHJlbWFpbmluZyB1bnBhcnNlZCBpbnB1dCBsZW5ndGggdG8gdGhlIHN0cmluZ1xuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5jaGFyc0xlZnRPdmVyID1cbiAgICAgICAgICAgIHN0cmluZ0xlbmd0aCAtIHRvdGFsUGFyc2VkSW5wdXRMZW5ndGg7XG4gICAgICAgIGlmIChzdHJpbmcubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykudW51c2VkSW5wdXQucHVzaChzdHJpbmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY2xlYXIgXzEyaCBmbGFnIGlmIGhvdXIgaXMgPD0gMTJcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgY29uZmlnLl9hW0hPVVJdIDw9IDEyICYmXG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5iaWdIb3VyID09PSB0cnVlICYmXG4gICAgICAgICAgICBjb25maWcuX2FbSE9VUl0gPiAwXG4gICAgICAgICkge1xuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuYmlnSG91ciA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLnBhcnNlZERhdGVQYXJ0cyA9IGNvbmZpZy5fYS5zbGljZSgwKTtcbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykubWVyaWRpZW0gPSBjb25maWcuX21lcmlkaWVtO1xuICAgICAgICAvLyBoYW5kbGUgbWVyaWRpZW1cbiAgICAgICAgY29uZmlnLl9hW0hPVVJdID0gbWVyaWRpZW1GaXhXcmFwKFxuICAgICAgICAgICAgY29uZmlnLl9sb2NhbGUsXG4gICAgICAgICAgICBjb25maWcuX2FbSE9VUl0sXG4gICAgICAgICAgICBjb25maWcuX21lcmlkaWVtXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gaGFuZGxlIGVyYVxuICAgICAgICBlcmEgPSBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5lcmE7XG4gICAgICAgIGlmIChlcmEgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fYVtZRUFSXSA9IGNvbmZpZy5fbG9jYWxlLmVyYXNDb252ZXJ0WWVhcihlcmEsIGNvbmZpZy5fYVtZRUFSXSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25maWdGcm9tQXJyYXkoY29uZmlnKTtcbiAgICAgICAgY2hlY2tPdmVyZmxvdyhjb25maWcpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1lcmlkaWVtRml4V3JhcChsb2NhbGUsIGhvdXIsIG1lcmlkaWVtKSB7XG4gICAgICAgIHZhciBpc1BtO1xuXG4gICAgICAgIGlmIChtZXJpZGllbSA9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBub3RoaW5nIHRvIGRvXG4gICAgICAgICAgICByZXR1cm4gaG91cjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobG9jYWxlLm1lcmlkaWVtSG91ciAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxlLm1lcmlkaWVtSG91cihob3VyLCBtZXJpZGllbSk7XG4gICAgICAgIH0gZWxzZSBpZiAobG9jYWxlLmlzUE0gIT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gRmFsbGJhY2tcbiAgICAgICAgICAgIGlzUG0gPSBsb2NhbGUuaXNQTShtZXJpZGllbSk7XG4gICAgICAgICAgICBpZiAoaXNQbSAmJiBob3VyIDwgMTIpIHtcbiAgICAgICAgICAgICAgICBob3VyICs9IDEyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpc1BtICYmIGhvdXIgPT09IDEyKSB7XG4gICAgICAgICAgICAgICAgaG91ciA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaG91cjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHRoaXMgaXMgbm90IHN1cHBvc2VkIHRvIGhhcHBlblxuICAgICAgICAgICAgcmV0dXJuIGhvdXI7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBkYXRlIGZyb20gc3RyaW5nIGFuZCBhcnJheSBvZiBmb3JtYXQgc3RyaW5nc1xuICAgIGZ1bmN0aW9uIGNvbmZpZ0Zyb21TdHJpbmdBbmRBcnJheShjb25maWcpIHtcbiAgICAgICAgdmFyIHRlbXBDb25maWcsXG4gICAgICAgICAgICBiZXN0TW9tZW50LFxuICAgICAgICAgICAgc2NvcmVUb0JlYXQsXG4gICAgICAgICAgICBpLFxuICAgICAgICAgICAgY3VycmVudFNjb3JlLFxuICAgICAgICAgICAgdmFsaWRGb3JtYXRGb3VuZCxcbiAgICAgICAgICAgIGJlc3RGb3JtYXRJc1ZhbGlkID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKGNvbmZpZy5fZi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmludmFsaWRGb3JtYXQgPSB0cnVlO1xuICAgICAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUoTmFOKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb25maWcuX2YubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGN1cnJlbnRTY29yZSA9IDA7XG4gICAgICAgICAgICB2YWxpZEZvcm1hdEZvdW5kID0gZmFsc2U7XG4gICAgICAgICAgICB0ZW1wQ29uZmlnID0gY29weUNvbmZpZyh7fSwgY29uZmlnKTtcbiAgICAgICAgICAgIGlmIChjb25maWcuX3VzZVVUQyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGVtcENvbmZpZy5fdXNlVVRDID0gY29uZmlnLl91c2VVVEM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0ZW1wQ29uZmlnLl9mID0gY29uZmlnLl9mW2ldO1xuICAgICAgICAgICAgY29uZmlnRnJvbVN0cmluZ0FuZEZvcm1hdCh0ZW1wQ29uZmlnKTtcblxuICAgICAgICAgICAgaWYgKGlzVmFsaWQodGVtcENvbmZpZykpIHtcbiAgICAgICAgICAgICAgICB2YWxpZEZvcm1hdEZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaWYgdGhlcmUgaXMgYW55IGlucHV0IHRoYXQgd2FzIG5vdCBwYXJzZWQgYWRkIGEgcGVuYWx0eSBmb3IgdGhhdCBmb3JtYXRcbiAgICAgICAgICAgIGN1cnJlbnRTY29yZSArPSBnZXRQYXJzaW5nRmxhZ3ModGVtcENvbmZpZykuY2hhcnNMZWZ0T3ZlcjtcblxuICAgICAgICAgICAgLy9vciB0b2tlbnNcbiAgICAgICAgICAgIGN1cnJlbnRTY29yZSArPSBnZXRQYXJzaW5nRmxhZ3ModGVtcENvbmZpZykudW51c2VkVG9rZW5zLmxlbmd0aCAqIDEwO1xuXG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3ModGVtcENvbmZpZykuc2NvcmUgPSBjdXJyZW50U2NvcmU7XG5cbiAgICAgICAgICAgIGlmICghYmVzdEZvcm1hdElzVmFsaWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgIHNjb3JlVG9CZWF0ID09IG51bGwgfHxcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFNjb3JlIDwgc2NvcmVUb0JlYXQgfHxcbiAgICAgICAgICAgICAgICAgICAgdmFsaWRGb3JtYXRGb3VuZFxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICBzY29yZVRvQmVhdCA9IGN1cnJlbnRTY29yZTtcbiAgICAgICAgICAgICAgICAgICAgYmVzdE1vbWVudCA9IHRlbXBDb25maWc7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWxpZEZvcm1hdEZvdW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBiZXN0Rm9ybWF0SXNWYWxpZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50U2NvcmUgPCBzY29yZVRvQmVhdCkge1xuICAgICAgICAgICAgICAgICAgICBzY29yZVRvQmVhdCA9IGN1cnJlbnRTY29yZTtcbiAgICAgICAgICAgICAgICAgICAgYmVzdE1vbWVudCA9IHRlbXBDb25maWc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZXh0ZW5kKGNvbmZpZywgYmVzdE1vbWVudCB8fCB0ZW1wQ29uZmlnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb25maWdGcm9tT2JqZWN0KGNvbmZpZykge1xuICAgICAgICBpZiAoY29uZmlnLl9kKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaSA9IG5vcm1hbGl6ZU9iamVjdFVuaXRzKGNvbmZpZy5faSksXG4gICAgICAgICAgICBkYXlPckRhdGUgPSBpLmRheSA9PT0gdW5kZWZpbmVkID8gaS5kYXRlIDogaS5kYXk7XG4gICAgICAgIGNvbmZpZy5fYSA9IG1hcChcbiAgICAgICAgICAgIFtpLnllYXIsIGkubW9udGgsIGRheU9yRGF0ZSwgaS5ob3VyLCBpLm1pbnV0ZSwgaS5zZWNvbmQsIGkubWlsbGlzZWNvbmRdLFxuICAgICAgICAgICAgZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgICAgICAgIHJldHVybiBvYmogJiYgcGFyc2VJbnQob2JqLCAxMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICk7XG5cbiAgICAgICAgY29uZmlnRnJvbUFycmF5KGNvbmZpZyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlRnJvbUNvbmZpZyhjb25maWcpIHtcbiAgICAgICAgdmFyIHJlcyA9IG5ldyBNb21lbnQoY2hlY2tPdmVyZmxvdyhwcmVwYXJlQ29uZmlnKGNvbmZpZykpKTtcbiAgICAgICAgaWYgKHJlcy5fbmV4dERheSkge1xuICAgICAgICAgICAgLy8gQWRkaW5nIGlzIHNtYXJ0IGVub3VnaCBhcm91bmQgRFNUXG4gICAgICAgICAgICByZXMuYWRkKDEsICdkJyk7XG4gICAgICAgICAgICByZXMuX25leHREYXkgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHByZXBhcmVDb25maWcoY29uZmlnKSB7XG4gICAgICAgIHZhciBpbnB1dCA9IGNvbmZpZy5faSxcbiAgICAgICAgICAgIGZvcm1hdCA9IGNvbmZpZy5fZjtcblxuICAgICAgICBjb25maWcuX2xvY2FsZSA9IGNvbmZpZy5fbG9jYWxlIHx8IGdldExvY2FsZShjb25maWcuX2wpO1xuXG4gICAgICAgIGlmIChpbnB1dCA9PT0gbnVsbCB8fCAoZm9ybWF0ID09PSB1bmRlZmluZWQgJiYgaW5wdXQgPT09ICcnKSkge1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUludmFsaWQoeyBudWxsSW5wdXQ6IHRydWUgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgY29uZmlnLl9pID0gaW5wdXQgPSBjb25maWcuX2xvY2FsZS5wcmVwYXJzZShpbnB1dCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNNb21lbnQoaW5wdXQpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IE1vbWVudChjaGVja092ZXJmbG93KGlucHV0KSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNEYXRlKGlucHV0KSkge1xuICAgICAgICAgICAgY29uZmlnLl9kID0gaW5wdXQ7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNBcnJheShmb3JtYXQpKSB7XG4gICAgICAgICAgICBjb25maWdGcm9tU3RyaW5nQW5kQXJyYXkoY29uZmlnKTtcbiAgICAgICAgfSBlbHNlIGlmIChmb3JtYXQpIHtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21TdHJpbmdBbmRGb3JtYXQoY29uZmlnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21JbnB1dChjb25maWcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc1ZhbGlkKGNvbmZpZykpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY29uZmlnO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbmZpZ0Zyb21JbnB1dChjb25maWcpIHtcbiAgICAgICAgdmFyIGlucHV0ID0gY29uZmlnLl9pO1xuICAgICAgICBpZiAoaXNVbmRlZmluZWQoaW5wdXQpKSB7XG4gICAgICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZShob29rcy5ub3coKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNEYXRlKGlucHV0KSkge1xuICAgICAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUoaW5wdXQudmFsdWVPZigpKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBjb25maWdGcm9tU3RyaW5nKGNvbmZpZyk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNBcnJheShpbnB1dCkpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fYSA9IG1hcChpbnB1dC5zbGljZSgwKSwgZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUludChvYmosIDEwKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uZmlnRnJvbUFycmF5KGNvbmZpZyk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNPYmplY3QoaW5wdXQpKSB7XG4gICAgICAgICAgICBjb25maWdGcm9tT2JqZWN0KGNvbmZpZyk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNOdW1iZXIoaW5wdXQpKSB7XG4gICAgICAgICAgICAvLyBmcm9tIG1pbGxpc2Vjb25kc1xuICAgICAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUoaW5wdXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaG9va3MuY3JlYXRlRnJvbUlucHV0RmFsbGJhY2soY29uZmlnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUxvY2FsT3JVVEMoaW5wdXQsIGZvcm1hdCwgbG9jYWxlLCBzdHJpY3QsIGlzVVRDKSB7XG4gICAgICAgIHZhciBjID0ge307XG5cbiAgICAgICAgaWYgKGZvcm1hdCA9PT0gdHJ1ZSB8fCBmb3JtYXQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBzdHJpY3QgPSBmb3JtYXQ7XG4gICAgICAgICAgICBmb3JtYXQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobG9jYWxlID09PSB0cnVlIHx8IGxvY2FsZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHN0cmljdCA9IGxvY2FsZTtcbiAgICAgICAgICAgIGxvY2FsZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIChpc09iamVjdChpbnB1dCkgJiYgaXNPYmplY3RFbXB0eShpbnB1dCkpIHx8XG4gICAgICAgICAgICAoaXNBcnJheShpbnB1dCkgJiYgaW5wdXQubGVuZ3RoID09PSAwKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIGlucHV0ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIC8vIG9iamVjdCBjb25zdHJ1Y3Rpb24gbXVzdCBiZSBkb25lIHRoaXMgd2F5LlxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbW9tZW50L21vbWVudC9pc3N1ZXMvMTQyM1xuICAgICAgICBjLl9pc0FNb21lbnRPYmplY3QgPSB0cnVlO1xuICAgICAgICBjLl91c2VVVEMgPSBjLl9pc1VUQyA9IGlzVVRDO1xuICAgICAgICBjLl9sID0gbG9jYWxlO1xuICAgICAgICBjLl9pID0gaW5wdXQ7XG4gICAgICAgIGMuX2YgPSBmb3JtYXQ7XG4gICAgICAgIGMuX3N0cmljdCA9IHN0cmljdDtcblxuICAgICAgICByZXR1cm4gY3JlYXRlRnJvbUNvbmZpZyhjKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVMb2NhbChpbnB1dCwgZm9ybWF0LCBsb2NhbGUsIHN0cmljdCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlTG9jYWxPclVUQyhpbnB1dCwgZm9ybWF0LCBsb2NhbGUsIHN0cmljdCwgZmFsc2UpO1xuICAgIH1cblxuICAgIHZhciBwcm90b3R5cGVNaW4gPSBkZXByZWNhdGUoXG4gICAgICAgICAgICAnbW9tZW50KCkubWluIGlzIGRlcHJlY2F0ZWQsIHVzZSBtb21lbnQubWF4IGluc3RlYWQuIGh0dHA6Ly9tb21lbnRqcy5jb20vZ3VpZGVzLyMvd2FybmluZ3MvbWluLW1heC8nLFxuICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBvdGhlciA9IGNyZWF0ZUxvY2FsLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNWYWxpZCgpICYmIG90aGVyLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3RoZXIgPCB0aGlzID8gdGhpcyA6IG90aGVyO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVJbnZhbGlkKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICApLFxuICAgICAgICBwcm90b3R5cGVNYXggPSBkZXByZWNhdGUoXG4gICAgICAgICAgICAnbW9tZW50KCkubWF4IGlzIGRlcHJlY2F0ZWQsIHVzZSBtb21lbnQubWluIGluc3RlYWQuIGh0dHA6Ly9tb21lbnRqcy5jb20vZ3VpZGVzLyMvd2FybmluZ3MvbWluLW1heC8nLFxuICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBvdGhlciA9IGNyZWF0ZUxvY2FsLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNWYWxpZCgpICYmIG90aGVyLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3RoZXIgPiB0aGlzID8gdGhpcyA6IG90aGVyO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVJbnZhbGlkKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICApO1xuXG4gICAgLy8gUGljayBhIG1vbWVudCBtIGZyb20gbW9tZW50cyBzbyB0aGF0IG1bZm5dKG90aGVyKSBpcyB0cnVlIGZvciBhbGxcbiAgICAvLyBvdGhlci4gVGhpcyByZWxpZXMgb24gdGhlIGZ1bmN0aW9uIGZuIHRvIGJlIHRyYW5zaXRpdmUuXG4gICAgLy9cbiAgICAvLyBtb21lbnRzIHNob3VsZCBlaXRoZXIgYmUgYW4gYXJyYXkgb2YgbW9tZW50IG9iamVjdHMgb3IgYW4gYXJyYXksIHdob3NlXG4gICAgLy8gZmlyc3QgZWxlbWVudCBpcyBhbiBhcnJheSBvZiBtb21lbnQgb2JqZWN0cy5cbiAgICBmdW5jdGlvbiBwaWNrQnkoZm4sIG1vbWVudHMpIHtcbiAgICAgICAgdmFyIHJlcywgaTtcbiAgICAgICAgaWYgKG1vbWVudHMubGVuZ3RoID09PSAxICYmIGlzQXJyYXkobW9tZW50c1swXSkpIHtcbiAgICAgICAgICAgIG1vbWVudHMgPSBtb21lbnRzWzBdO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbW9tZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVMb2NhbCgpO1xuICAgICAgICB9XG4gICAgICAgIHJlcyA9IG1vbWVudHNbMF07XG4gICAgICAgIGZvciAoaSA9IDE7IGkgPCBtb21lbnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBpZiAoIW1vbWVudHNbaV0uaXNWYWxpZCgpIHx8IG1vbWVudHNbaV1bZm5dKHJlcykpIHtcbiAgICAgICAgICAgICAgICByZXMgPSBtb21lbnRzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgLy8gVE9ETzogVXNlIFtdLnNvcnQgaW5zdGVhZD9cbiAgICBmdW5jdGlvbiBtaW4oKSB7XG4gICAgICAgIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuXG4gICAgICAgIHJldHVybiBwaWNrQnkoJ2lzQmVmb3JlJywgYXJncyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWF4KCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcblxuICAgICAgICByZXR1cm4gcGlja0J5KCdpc0FmdGVyJywgYXJncyk7XG4gICAgfVxuXG4gICAgdmFyIG5vdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIERhdGUubm93ID8gRGF0ZS5ub3coKSA6ICtuZXcgRGF0ZSgpO1xuICAgIH07XG5cbiAgICB2YXIgb3JkZXJpbmcgPSBbXG4gICAgICAgICd5ZWFyJyxcbiAgICAgICAgJ3F1YXJ0ZXInLFxuICAgICAgICAnbW9udGgnLFxuICAgICAgICAnd2VlaycsXG4gICAgICAgICdkYXknLFxuICAgICAgICAnaG91cicsXG4gICAgICAgICdtaW51dGUnLFxuICAgICAgICAnc2Vjb25kJyxcbiAgICAgICAgJ21pbGxpc2Vjb25kJyxcbiAgICBdO1xuXG4gICAgZnVuY3Rpb24gaXNEdXJhdGlvblZhbGlkKG0pIHtcbiAgICAgICAgdmFyIGtleSxcbiAgICAgICAgICAgIHVuaXRIYXNEZWNpbWFsID0gZmFsc2UsXG4gICAgICAgICAgICBpO1xuICAgICAgICBmb3IgKGtleSBpbiBtKSB7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgaGFzT3duUHJvcChtLCBrZXkpICYmXG4gICAgICAgICAgICAgICAgIShcbiAgICAgICAgICAgICAgICAgICAgaW5kZXhPZi5jYWxsKG9yZGVyaW5nLCBrZXkpICE9PSAtMSAmJlxuICAgICAgICAgICAgICAgICAgICAobVtrZXldID09IG51bGwgfHwgIWlzTmFOKG1ba2V5XSkpXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG9yZGVyaW5nLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBpZiAobVtvcmRlcmluZ1tpXV0pIHtcbiAgICAgICAgICAgICAgICBpZiAodW5pdEhhc0RlY2ltYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBvbmx5IGFsbG93IG5vbi1pbnRlZ2VycyBmb3Igc21hbGxlc3QgdW5pdFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocGFyc2VGbG9hdChtW29yZGVyaW5nW2ldXSkgIT09IHRvSW50KG1bb3JkZXJpbmdbaV1dKSkge1xuICAgICAgICAgICAgICAgICAgICB1bml0SGFzRGVjaW1hbCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNWYWxpZCQxKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNWYWxpZDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVJbnZhbGlkJDEoKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVEdXJhdGlvbihOYU4pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIER1cmF0aW9uKGR1cmF0aW9uKSB7XG4gICAgICAgIHZhciBub3JtYWxpemVkSW5wdXQgPSBub3JtYWxpemVPYmplY3RVbml0cyhkdXJhdGlvbiksXG4gICAgICAgICAgICB5ZWFycyA9IG5vcm1hbGl6ZWRJbnB1dC55ZWFyIHx8IDAsXG4gICAgICAgICAgICBxdWFydGVycyA9IG5vcm1hbGl6ZWRJbnB1dC5xdWFydGVyIHx8IDAsXG4gICAgICAgICAgICBtb250aHMgPSBub3JtYWxpemVkSW5wdXQubW9udGggfHwgMCxcbiAgICAgICAgICAgIHdlZWtzID0gbm9ybWFsaXplZElucHV0LndlZWsgfHwgbm9ybWFsaXplZElucHV0Lmlzb1dlZWsgfHwgMCxcbiAgICAgICAgICAgIGRheXMgPSBub3JtYWxpemVkSW5wdXQuZGF5IHx8IDAsXG4gICAgICAgICAgICBob3VycyA9IG5vcm1hbGl6ZWRJbnB1dC5ob3VyIHx8IDAsXG4gICAgICAgICAgICBtaW51dGVzID0gbm9ybWFsaXplZElucHV0Lm1pbnV0ZSB8fCAwLFxuICAgICAgICAgICAgc2Vjb25kcyA9IG5vcm1hbGl6ZWRJbnB1dC5zZWNvbmQgfHwgMCxcbiAgICAgICAgICAgIG1pbGxpc2Vjb25kcyA9IG5vcm1hbGl6ZWRJbnB1dC5taWxsaXNlY29uZCB8fCAwO1xuXG4gICAgICAgIHRoaXMuX2lzVmFsaWQgPSBpc0R1cmF0aW9uVmFsaWQobm9ybWFsaXplZElucHV0KTtcblxuICAgICAgICAvLyByZXByZXNlbnRhdGlvbiBmb3IgZGF0ZUFkZFJlbW92ZVxuICAgICAgICB0aGlzLl9taWxsaXNlY29uZHMgPVxuICAgICAgICAgICAgK21pbGxpc2Vjb25kcyArXG4gICAgICAgICAgICBzZWNvbmRzICogMWUzICsgLy8gMTAwMFxuICAgICAgICAgICAgbWludXRlcyAqIDZlNCArIC8vIDEwMDAgKiA2MFxuICAgICAgICAgICAgaG91cnMgKiAxMDAwICogNjAgKiA2MDsgLy91c2luZyAxMDAwICogNjAgKiA2MCBpbnN0ZWFkIG9mIDM2ZTUgdG8gYXZvaWQgZmxvYXRpbmcgcG9pbnQgcm91bmRpbmcgZXJyb3JzIGh0dHBzOi8vZ2l0aHViLmNvbS9tb21lbnQvbW9tZW50L2lzc3Vlcy8yOTc4XG4gICAgICAgIC8vIEJlY2F1c2Ugb2YgZGF0ZUFkZFJlbW92ZSB0cmVhdHMgMjQgaG91cnMgYXMgZGlmZmVyZW50IGZyb20gYVxuICAgICAgICAvLyBkYXkgd2hlbiB3b3JraW5nIGFyb3VuZCBEU1QsIHdlIG5lZWQgdG8gc3RvcmUgdGhlbSBzZXBhcmF0ZWx5XG4gICAgICAgIHRoaXMuX2RheXMgPSArZGF5cyArIHdlZWtzICogNztcbiAgICAgICAgLy8gSXQgaXMgaW1wb3NzaWJsZSB0byB0cmFuc2xhdGUgbW9udGhzIGludG8gZGF5cyB3aXRob3V0IGtub3dpbmdcbiAgICAgICAgLy8gd2hpY2ggbW9udGhzIHlvdSBhcmUgYXJlIHRhbGtpbmcgYWJvdXQsIHNvIHdlIGhhdmUgdG8gc3RvcmVcbiAgICAgICAgLy8gaXQgc2VwYXJhdGVseS5cbiAgICAgICAgdGhpcy5fbW9udGhzID0gK21vbnRocyArIHF1YXJ0ZXJzICogMyArIHllYXJzICogMTI7XG5cbiAgICAgICAgdGhpcy5fZGF0YSA9IHt9O1xuXG4gICAgICAgIHRoaXMuX2xvY2FsZSA9IGdldExvY2FsZSgpO1xuXG4gICAgICAgIHRoaXMuX2J1YmJsZSgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzRHVyYXRpb24ob2JqKSB7XG4gICAgICAgIHJldHVybiBvYmogaW5zdGFuY2VvZiBEdXJhdGlvbjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhYnNSb3VuZChudW1iZXIpIHtcbiAgICAgICAgaWYgKG51bWJlciA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLnJvdW5kKC0xICogbnVtYmVyKSAqIC0xO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGgucm91bmQobnVtYmVyKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGNvbXBhcmUgdHdvIGFycmF5cywgcmV0dXJuIHRoZSBudW1iZXIgb2YgZGlmZmVyZW5jZXNcbiAgICBmdW5jdGlvbiBjb21wYXJlQXJyYXlzKGFycmF5MSwgYXJyYXkyLCBkb250Q29udmVydCkge1xuICAgICAgICB2YXIgbGVuID0gTWF0aC5taW4oYXJyYXkxLmxlbmd0aCwgYXJyYXkyLmxlbmd0aCksXG4gICAgICAgICAgICBsZW5ndGhEaWZmID0gTWF0aC5hYnMoYXJyYXkxLmxlbmd0aCAtIGFycmF5Mi5sZW5ndGgpLFxuICAgICAgICAgICAgZGlmZnMgPSAwLFxuICAgICAgICAgICAgaTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgKGRvbnRDb252ZXJ0ICYmIGFycmF5MVtpXSAhPT0gYXJyYXkyW2ldKSB8fFxuICAgICAgICAgICAgICAgICghZG9udENvbnZlcnQgJiYgdG9JbnQoYXJyYXkxW2ldKSAhPT0gdG9JbnQoYXJyYXkyW2ldKSlcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIGRpZmZzKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRpZmZzICsgbGVuZ3RoRGlmZjtcbiAgICB9XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBmdW5jdGlvbiBvZmZzZXQodG9rZW4sIHNlcGFyYXRvcikge1xuICAgICAgICBhZGRGb3JtYXRUb2tlbih0b2tlbiwgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG9mZnNldCA9IHRoaXMudXRjT2Zmc2V0KCksXG4gICAgICAgICAgICAgICAgc2lnbiA9ICcrJztcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPCAwKSB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gLW9mZnNldDtcbiAgICAgICAgICAgICAgICBzaWduID0gJy0nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICBzaWduICtcbiAgICAgICAgICAgICAgICB6ZXJvRmlsbCh+fihvZmZzZXQgLyA2MCksIDIpICtcbiAgICAgICAgICAgICAgICBzZXBhcmF0b3IgK1xuICAgICAgICAgICAgICAgIHplcm9GaWxsKH5+b2Zmc2V0ICUgNjAsIDIpXG4gICAgICAgICAgICApO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBvZmZzZXQoJ1onLCAnOicpO1xuICAgIG9mZnNldCgnWlonLCAnJyk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdaJywgbWF0Y2hTaG9ydE9mZnNldCk7XG4gICAgYWRkUmVnZXhUb2tlbignWlonLCBtYXRjaFNob3J0T2Zmc2V0KTtcbiAgICBhZGRQYXJzZVRva2VuKFsnWicsICdaWiddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgY29uZmlnLl91c2VVVEMgPSB0cnVlO1xuICAgICAgICBjb25maWcuX3R6bSA9IG9mZnNldEZyb21TdHJpbmcobWF0Y2hTaG9ydE9mZnNldCwgaW5wdXQpO1xuICAgIH0pO1xuXG4gICAgLy8gSEVMUEVSU1xuXG4gICAgLy8gdGltZXpvbmUgY2h1bmtlclxuICAgIC8vICcrMTA6MDAnID4gWycxMCcsICAnMDAnXVxuICAgIC8vICctMTUzMCcgID4gWyctMTUnLCAnMzAnXVxuICAgIHZhciBjaHVua09mZnNldCA9IC8oW1xcK1xcLV18XFxkXFxkKS9naTtcblxuICAgIGZ1bmN0aW9uIG9mZnNldEZyb21TdHJpbmcobWF0Y2hlciwgc3RyaW5nKSB7XG4gICAgICAgIHZhciBtYXRjaGVzID0gKHN0cmluZyB8fCAnJykubWF0Y2gobWF0Y2hlciksXG4gICAgICAgICAgICBjaHVuayxcbiAgICAgICAgICAgIHBhcnRzLFxuICAgICAgICAgICAgbWludXRlcztcblxuICAgICAgICBpZiAobWF0Y2hlcyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBjaHVuayA9IG1hdGNoZXNbbWF0Y2hlcy5sZW5ndGggLSAxXSB8fCBbXTtcbiAgICAgICAgcGFydHMgPSAoY2h1bmsgKyAnJykubWF0Y2goY2h1bmtPZmZzZXQpIHx8IFsnLScsIDAsIDBdO1xuICAgICAgICBtaW51dGVzID0gKyhwYXJ0c1sxXSAqIDYwKSArIHRvSW50KHBhcnRzWzJdKTtcblxuICAgICAgICByZXR1cm4gbWludXRlcyA9PT0gMCA/IDAgOiBwYXJ0c1swXSA9PT0gJysnID8gbWludXRlcyA6IC1taW51dGVzO1xuICAgIH1cblxuICAgIC8vIFJldHVybiBhIG1vbWVudCBmcm9tIGlucHV0LCB0aGF0IGlzIGxvY2FsL3V0Yy96b25lIGVxdWl2YWxlbnQgdG8gbW9kZWwuXG4gICAgZnVuY3Rpb24gY2xvbmVXaXRoT2Zmc2V0KGlucHV0LCBtb2RlbCkge1xuICAgICAgICB2YXIgcmVzLCBkaWZmO1xuICAgICAgICBpZiAobW9kZWwuX2lzVVRDKSB7XG4gICAgICAgICAgICByZXMgPSBtb2RlbC5jbG9uZSgpO1xuICAgICAgICAgICAgZGlmZiA9XG4gICAgICAgICAgICAgICAgKGlzTW9tZW50KGlucHV0KSB8fCBpc0RhdGUoaW5wdXQpXG4gICAgICAgICAgICAgICAgICAgID8gaW5wdXQudmFsdWVPZigpXG4gICAgICAgICAgICAgICAgICAgIDogY3JlYXRlTG9jYWwoaW5wdXQpLnZhbHVlT2YoKSkgLSByZXMudmFsdWVPZigpO1xuICAgICAgICAgICAgLy8gVXNlIGxvdy1sZXZlbCBhcGksIGJlY2F1c2UgdGhpcyBmbiBpcyBsb3ctbGV2ZWwgYXBpLlxuICAgICAgICAgICAgcmVzLl9kLnNldFRpbWUocmVzLl9kLnZhbHVlT2YoKSArIGRpZmYpO1xuICAgICAgICAgICAgaG9va3MudXBkYXRlT2Zmc2V0KHJlcywgZmFsc2UpO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVMb2NhbChpbnB1dCkubG9jYWwoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldERhdGVPZmZzZXQobSkge1xuICAgICAgICAvLyBPbiBGaXJlZm94LjI0IERhdGUjZ2V0VGltZXpvbmVPZmZzZXQgcmV0dXJucyBhIGZsb2F0aW5nIHBvaW50LlxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbW9tZW50L21vbWVudC9wdWxsLzE4NzFcbiAgICAgICAgcmV0dXJuIC1NYXRoLnJvdW5kKG0uX2QuZ2V0VGltZXpvbmVPZmZzZXQoKSk7XG4gICAgfVxuXG4gICAgLy8gSE9PS1NcblxuICAgIC8vIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgd2hlbmV2ZXIgYSBtb21lbnQgaXMgbXV0YXRlZC5cbiAgICAvLyBJdCBpcyBpbnRlbmRlZCB0byBrZWVwIHRoZSBvZmZzZXQgaW4gc3luYyB3aXRoIHRoZSB0aW1lem9uZS5cbiAgICBob29rcy51cGRhdGVPZmZzZXQgPSBmdW5jdGlvbiAoKSB7fTtcblxuICAgIC8vIE1PTUVOVFNcblxuICAgIC8vIGtlZXBMb2NhbFRpbWUgPSB0cnVlIG1lYW5zIG9ubHkgY2hhbmdlIHRoZSB0aW1lem9uZSwgd2l0aG91dFxuICAgIC8vIGFmZmVjdGluZyB0aGUgbG9jYWwgaG91ci4gU28gNTozMToyNiArMDMwMCAtLVt1dGNPZmZzZXQoMiwgdHJ1ZSldLS0+XG4gICAgLy8gNTozMToyNiArMDIwMCBJdCBpcyBwb3NzaWJsZSB0aGF0IDU6MzE6MjYgZG9lc24ndCBleGlzdCB3aXRoIG9mZnNldFxuICAgIC8vICswMjAwLCBzbyB3ZSBhZGp1c3QgdGhlIHRpbWUgYXMgbmVlZGVkLCB0byBiZSB2YWxpZC5cbiAgICAvL1xuICAgIC8vIEtlZXBpbmcgdGhlIHRpbWUgYWN0dWFsbHkgYWRkcy9zdWJ0cmFjdHMgKG9uZSBob3VyKVxuICAgIC8vIGZyb20gdGhlIGFjdHVhbCByZXByZXNlbnRlZCB0aW1lLiBUaGF0IGlzIHdoeSB3ZSBjYWxsIHVwZGF0ZU9mZnNldFxuICAgIC8vIGEgc2Vjb25kIHRpbWUuIEluIGNhc2UgaXQgd2FudHMgdXMgdG8gY2hhbmdlIHRoZSBvZmZzZXQgYWdhaW5cbiAgICAvLyBfY2hhbmdlSW5Qcm9ncmVzcyA9PSB0cnVlIGNhc2UsIHRoZW4gd2UgaGF2ZSB0byBhZGp1c3QsIGJlY2F1c2VcbiAgICAvLyB0aGVyZSBpcyBubyBzdWNoIHRpbWUgaW4gdGhlIGdpdmVuIHRpbWV6b25lLlxuICAgIGZ1bmN0aW9uIGdldFNldE9mZnNldChpbnB1dCwga2VlcExvY2FsVGltZSwga2VlcE1pbnV0ZXMpIHtcbiAgICAgICAgdmFyIG9mZnNldCA9IHRoaXMuX29mZnNldCB8fCAwLFxuICAgICAgICAgICAgbG9jYWxBZGp1c3Q7XG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dCAhPSBudWxsID8gdGhpcyA6IE5hTjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5wdXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBpbnB1dCA9IG9mZnNldEZyb21TdHJpbmcobWF0Y2hTaG9ydE9mZnNldCwgaW5wdXQpO1xuICAgICAgICAgICAgICAgIGlmIChpbnB1dCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKE1hdGguYWJzKGlucHV0KSA8IDE2ICYmICFrZWVwTWludXRlcykge1xuICAgICAgICAgICAgICAgIGlucHV0ID0gaW5wdXQgKiA2MDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5faXNVVEMgJiYga2VlcExvY2FsVGltZSkge1xuICAgICAgICAgICAgICAgIGxvY2FsQWRqdXN0ID0gZ2V0RGF0ZU9mZnNldCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX29mZnNldCA9IGlucHV0O1xuICAgICAgICAgICAgdGhpcy5faXNVVEMgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKGxvY2FsQWRqdXN0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZChsb2NhbEFkanVzdCwgJ20nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvZmZzZXQgIT09IGlucHV0KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFrZWVwTG9jYWxUaW1lIHx8IHRoaXMuX2NoYW5nZUluUHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkU3VidHJhY3QoXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICAgICAgICAgICAgY3JlYXRlRHVyYXRpb24oaW5wdXQgLSBvZmZzZXQsICdtJyksXG4gICAgICAgICAgICAgICAgICAgICAgICAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLl9jaGFuZ2VJblByb2dyZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NoYW5nZUluUHJvZ3Jlc3MgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBob29rcy51cGRhdGVPZmZzZXQodGhpcywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NoYW5nZUluUHJvZ3Jlc3MgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2lzVVRDID8gb2Zmc2V0IDogZ2V0RGF0ZU9mZnNldCh0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFNldFpvbmUoaW5wdXQsIGtlZXBMb2NhbFRpbWUpIHtcbiAgICAgICAgaWYgKGlucHV0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaW5wdXQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgaW5wdXQgPSAtaW5wdXQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMudXRjT2Zmc2V0KGlucHV0LCBrZWVwTG9jYWxUaW1lKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gLXRoaXMudXRjT2Zmc2V0KCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRPZmZzZXRUb1VUQyhrZWVwTG9jYWxUaW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnV0Y09mZnNldCgwLCBrZWVwTG9jYWxUaW1lKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRPZmZzZXRUb0xvY2FsKGtlZXBMb2NhbFRpbWUpIHtcbiAgICAgICAgaWYgKHRoaXMuX2lzVVRDKSB7XG4gICAgICAgICAgICB0aGlzLnV0Y09mZnNldCgwLCBrZWVwTG9jYWxUaW1lKTtcbiAgICAgICAgICAgIHRoaXMuX2lzVVRDID0gZmFsc2U7XG5cbiAgICAgICAgICAgIGlmIChrZWVwTG9jYWxUaW1lKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdWJ0cmFjdChnZXREYXRlT2Zmc2V0KHRoaXMpLCAnbScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldE9mZnNldFRvUGFyc2VkT2Zmc2V0KCkge1xuICAgICAgICBpZiAodGhpcy5fdHptICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMudXRjT2Zmc2V0KHRoaXMuX3R6bSwgZmFsc2UsIHRydWUpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB0aGlzLl9pID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdmFyIHRab25lID0gb2Zmc2V0RnJvbVN0cmluZyhtYXRjaE9mZnNldCwgdGhpcy5faSk7XG4gICAgICAgICAgICBpZiAodFpvbmUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMudXRjT2Zmc2V0KHRab25lKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy51dGNPZmZzZXQoMCwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFzQWxpZ25lZEhvdXJPZmZzZXQoaW5wdXQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlucHV0ID0gaW5wdXQgPyBjcmVhdGVMb2NhbChpbnB1dCkudXRjT2Zmc2V0KCkgOiAwO1xuXG4gICAgICAgIHJldHVybiAodGhpcy51dGNPZmZzZXQoKSAtIGlucHV0KSAlIDYwID09PSAwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzRGF5bGlnaHRTYXZpbmdUaW1lKCkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgdGhpcy51dGNPZmZzZXQoKSA+IHRoaXMuY2xvbmUoKS5tb250aCgwKS51dGNPZmZzZXQoKSB8fFxuICAgICAgICAgICAgdGhpcy51dGNPZmZzZXQoKSA+IHRoaXMuY2xvbmUoKS5tb250aCg1KS51dGNPZmZzZXQoKVxuICAgICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzRGF5bGlnaHRTYXZpbmdUaW1lU2hpZnRlZCgpIHtcbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZCh0aGlzLl9pc0RTVFNoaWZ0ZWQpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faXNEU1RTaGlmdGVkO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGMgPSB7fSxcbiAgICAgICAgICAgIG90aGVyO1xuXG4gICAgICAgIGNvcHlDb25maWcoYywgdGhpcyk7XG4gICAgICAgIGMgPSBwcmVwYXJlQ29uZmlnKGMpO1xuXG4gICAgICAgIGlmIChjLl9hKSB7XG4gICAgICAgICAgICBvdGhlciA9IGMuX2lzVVRDID8gY3JlYXRlVVRDKGMuX2EpIDogY3JlYXRlTG9jYWwoYy5fYSk7XG4gICAgICAgICAgICB0aGlzLl9pc0RTVFNoaWZ0ZWQgPVxuICAgICAgICAgICAgICAgIHRoaXMuaXNWYWxpZCgpICYmIGNvbXBhcmVBcnJheXMoYy5fYSwgb3RoZXIudG9BcnJheSgpKSA+IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9pc0RTVFNoaWZ0ZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLl9pc0RTVFNoaWZ0ZWQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNMb2NhbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNWYWxpZCgpID8gIXRoaXMuX2lzVVRDIDogZmFsc2U7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNVdGNPZmZzZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzVmFsaWQoKSA/IHRoaXMuX2lzVVRDIDogZmFsc2U7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNVdGMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzVmFsaWQoKSA/IHRoaXMuX2lzVVRDICYmIHRoaXMuX29mZnNldCA9PT0gMCA6IGZhbHNlO1xuICAgIH1cblxuICAgIC8vIEFTUC5ORVQganNvbiBkYXRlIGZvcm1hdCByZWdleFxuICAgIHZhciBhc3BOZXRSZWdleCA9IC9eKC18XFwrKT8oPzooXFxkKilbLiBdKT8oXFxkKyk6KFxcZCspKD86OihcXGQrKShcXC5cXGQqKT8pPyQvLFxuICAgICAgICAvLyBmcm9tIGh0dHA6Ly9kb2NzLmNsb3N1cmUtbGlicmFyeS5nb29nbGVjb2RlLmNvbS9naXQvY2xvc3VyZV9nb29nX2RhdGVfZGF0ZS5qcy5zb3VyY2UuaHRtbFxuICAgICAgICAvLyBzb21ld2hhdCBtb3JlIGluIGxpbmUgd2l0aCA0LjQuMy4yIDIwMDQgc3BlYywgYnV0IGFsbG93cyBkZWNpbWFsIGFueXdoZXJlXG4gICAgICAgIC8vIGFuZCBmdXJ0aGVyIG1vZGlmaWVkIHRvIGFsbG93IGZvciBzdHJpbmdzIGNvbnRhaW5pbmcgYm90aCB3ZWVrIGFuZCBkYXlcbiAgICAgICAgaXNvUmVnZXggPSAvXigtfFxcKyk/UCg/OihbLStdP1swLTksLl0qKVkpPyg/OihbLStdP1swLTksLl0qKU0pPyg/OihbLStdP1swLTksLl0qKVcpPyg/OihbLStdP1swLTksLl0qKUQpPyg/OlQoPzooWy0rXT9bMC05LC5dKilIKT8oPzooWy0rXT9bMC05LC5dKilNKT8oPzooWy0rXT9bMC05LC5dKilTKT8pPyQvO1xuXG4gICAgZnVuY3Rpb24gY3JlYXRlRHVyYXRpb24oaW5wdXQsIGtleSkge1xuICAgICAgICB2YXIgZHVyYXRpb24gPSBpbnB1dCxcbiAgICAgICAgICAgIC8vIG1hdGNoaW5nIGFnYWluc3QgcmVnZXhwIGlzIGV4cGVuc2l2ZSwgZG8gaXQgb24gZGVtYW5kXG4gICAgICAgICAgICBtYXRjaCA9IG51bGwsXG4gICAgICAgICAgICBzaWduLFxuICAgICAgICAgICAgcmV0LFxuICAgICAgICAgICAgZGlmZlJlcztcblxuICAgICAgICBpZiAoaXNEdXJhdGlvbihpbnB1dCkpIHtcbiAgICAgICAgICAgIGR1cmF0aW9uID0ge1xuICAgICAgICAgICAgICAgIG1zOiBpbnB1dC5fbWlsbGlzZWNvbmRzLFxuICAgICAgICAgICAgICAgIGQ6IGlucHV0Ll9kYXlzLFxuICAgICAgICAgICAgICAgIE06IGlucHV0Ll9tb250aHMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKGlzTnVtYmVyKGlucHV0KSB8fCAhaXNOYU4oK2lucHV0KSkge1xuICAgICAgICAgICAgZHVyYXRpb24gPSB7fTtcbiAgICAgICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgICAgICAgICBkdXJhdGlvbltrZXldID0gK2lucHV0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkdXJhdGlvbi5taWxsaXNlY29uZHMgPSAraW5wdXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoKG1hdGNoID0gYXNwTmV0UmVnZXguZXhlYyhpbnB1dCkpKSB7XG4gICAgICAgICAgICBzaWduID0gbWF0Y2hbMV0gPT09ICctJyA/IC0xIDogMTtcbiAgICAgICAgICAgIGR1cmF0aW9uID0ge1xuICAgICAgICAgICAgICAgIHk6IDAsXG4gICAgICAgICAgICAgICAgZDogdG9JbnQobWF0Y2hbREFURV0pICogc2lnbixcbiAgICAgICAgICAgICAgICBoOiB0b0ludChtYXRjaFtIT1VSXSkgKiBzaWduLFxuICAgICAgICAgICAgICAgIG06IHRvSW50KG1hdGNoW01JTlVURV0pICogc2lnbixcbiAgICAgICAgICAgICAgICBzOiB0b0ludChtYXRjaFtTRUNPTkRdKSAqIHNpZ24sXG4gICAgICAgICAgICAgICAgbXM6IHRvSW50KGFic1JvdW5kKG1hdGNoW01JTExJU0VDT05EXSAqIDEwMDApKSAqIHNpZ24sIC8vIHRoZSBtaWxsaXNlY29uZCBkZWNpbWFsIHBvaW50IGlzIGluY2x1ZGVkIGluIHRoZSBtYXRjaFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmICgobWF0Y2ggPSBpc29SZWdleC5leGVjKGlucHV0KSkpIHtcbiAgICAgICAgICAgIHNpZ24gPSBtYXRjaFsxXSA9PT0gJy0nID8gLTEgOiAxO1xuICAgICAgICAgICAgZHVyYXRpb24gPSB7XG4gICAgICAgICAgICAgICAgeTogcGFyc2VJc28obWF0Y2hbMl0sIHNpZ24pLFxuICAgICAgICAgICAgICAgIE06IHBhcnNlSXNvKG1hdGNoWzNdLCBzaWduKSxcbiAgICAgICAgICAgICAgICB3OiBwYXJzZUlzbyhtYXRjaFs0XSwgc2lnbiksXG4gICAgICAgICAgICAgICAgZDogcGFyc2VJc28obWF0Y2hbNV0sIHNpZ24pLFxuICAgICAgICAgICAgICAgIGg6IHBhcnNlSXNvKG1hdGNoWzZdLCBzaWduKSxcbiAgICAgICAgICAgICAgICBtOiBwYXJzZUlzbyhtYXRjaFs3XSwgc2lnbiksXG4gICAgICAgICAgICAgICAgczogcGFyc2VJc28obWF0Y2hbOF0sIHNpZ24pLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmIChkdXJhdGlvbiA9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBjaGVja3MgZm9yIG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICBkdXJhdGlvbiA9IHt9O1xuICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgdHlwZW9mIGR1cmF0aW9uID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgKCdmcm9tJyBpbiBkdXJhdGlvbiB8fCAndG8nIGluIGR1cmF0aW9uKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIGRpZmZSZXMgPSBtb21lbnRzRGlmZmVyZW5jZShcbiAgICAgICAgICAgICAgICBjcmVhdGVMb2NhbChkdXJhdGlvbi5mcm9tKSxcbiAgICAgICAgICAgICAgICBjcmVhdGVMb2NhbChkdXJhdGlvbi50bylcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGR1cmF0aW9uID0ge307XG4gICAgICAgICAgICBkdXJhdGlvbi5tcyA9IGRpZmZSZXMubWlsbGlzZWNvbmRzO1xuICAgICAgICAgICAgZHVyYXRpb24uTSA9IGRpZmZSZXMubW9udGhzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0ID0gbmV3IER1cmF0aW9uKGR1cmF0aW9uKTtcblxuICAgICAgICBpZiAoaXNEdXJhdGlvbihpbnB1dCkgJiYgaGFzT3duUHJvcChpbnB1dCwgJ19sb2NhbGUnKSkge1xuICAgICAgICAgICAgcmV0Ll9sb2NhbGUgPSBpbnB1dC5fbG9jYWxlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzRHVyYXRpb24oaW5wdXQpICYmIGhhc093blByb3AoaW5wdXQsICdfaXNWYWxpZCcpKSB7XG4gICAgICAgICAgICByZXQuX2lzVmFsaWQgPSBpbnB1dC5faXNWYWxpZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuXG4gICAgY3JlYXRlRHVyYXRpb24uZm4gPSBEdXJhdGlvbi5wcm90b3R5cGU7XG4gICAgY3JlYXRlRHVyYXRpb24uaW52YWxpZCA9IGNyZWF0ZUludmFsaWQkMTtcblxuICAgIGZ1bmN0aW9uIHBhcnNlSXNvKGlucCwgc2lnbikge1xuICAgICAgICAvLyBXZSdkIG5vcm1hbGx5IHVzZSB+fmlucCBmb3IgdGhpcywgYnV0IHVuZm9ydHVuYXRlbHkgaXQgYWxzb1xuICAgICAgICAvLyBjb252ZXJ0cyBmbG9hdHMgdG8gaW50cy5cbiAgICAgICAgLy8gaW5wIG1heSBiZSB1bmRlZmluZWQsIHNvIGNhcmVmdWwgY2FsbGluZyByZXBsYWNlIG9uIGl0LlxuICAgICAgICB2YXIgcmVzID0gaW5wICYmIHBhcnNlRmxvYXQoaW5wLnJlcGxhY2UoJywnLCAnLicpKTtcbiAgICAgICAgLy8gYXBwbHkgc2lnbiB3aGlsZSB3ZSdyZSBhdCBpdFxuICAgICAgICByZXR1cm4gKGlzTmFOKHJlcykgPyAwIDogcmVzKSAqIHNpZ247XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcG9zaXRpdmVNb21lbnRzRGlmZmVyZW5jZShiYXNlLCBvdGhlcikge1xuICAgICAgICB2YXIgcmVzID0ge307XG5cbiAgICAgICAgcmVzLm1vbnRocyA9XG4gICAgICAgICAgICBvdGhlci5tb250aCgpIC0gYmFzZS5tb250aCgpICsgKG90aGVyLnllYXIoKSAtIGJhc2UueWVhcigpKSAqIDEyO1xuICAgICAgICBpZiAoYmFzZS5jbG9uZSgpLmFkZChyZXMubW9udGhzLCAnTScpLmlzQWZ0ZXIob3RoZXIpKSB7XG4gICAgICAgICAgICAtLXJlcy5tb250aHM7XG4gICAgICAgIH1cblxuICAgICAgICByZXMubWlsbGlzZWNvbmRzID0gK290aGVyIC0gK2Jhc2UuY2xvbmUoKS5hZGQocmVzLm1vbnRocywgJ00nKTtcblxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1vbWVudHNEaWZmZXJlbmNlKGJhc2UsIG90aGVyKSB7XG4gICAgICAgIHZhciByZXM7XG4gICAgICAgIGlmICghKGJhc2UuaXNWYWxpZCgpICYmIG90aGVyLmlzVmFsaWQoKSkpIHtcbiAgICAgICAgICAgIHJldHVybiB7IG1pbGxpc2Vjb25kczogMCwgbW9udGhzOiAwIH07XG4gICAgICAgIH1cblxuICAgICAgICBvdGhlciA9IGNsb25lV2l0aE9mZnNldChvdGhlciwgYmFzZSk7XG4gICAgICAgIGlmIChiYXNlLmlzQmVmb3JlKG90aGVyKSkge1xuICAgICAgICAgICAgcmVzID0gcG9zaXRpdmVNb21lbnRzRGlmZmVyZW5jZShiYXNlLCBvdGhlcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXMgPSBwb3NpdGl2ZU1vbWVudHNEaWZmZXJlbmNlKG90aGVyLCBiYXNlKTtcbiAgICAgICAgICAgIHJlcy5taWxsaXNlY29uZHMgPSAtcmVzLm1pbGxpc2Vjb25kcztcbiAgICAgICAgICAgIHJlcy5tb250aHMgPSAtcmVzLm1vbnRocztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgLy8gVE9ETzogcmVtb3ZlICduYW1lJyBhcmcgYWZ0ZXIgZGVwcmVjYXRpb24gaXMgcmVtb3ZlZFxuICAgIGZ1bmN0aW9uIGNyZWF0ZUFkZGVyKGRpcmVjdGlvbiwgbmFtZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHZhbCwgcGVyaW9kKSB7XG4gICAgICAgICAgICB2YXIgZHVyLCB0bXA7XG4gICAgICAgICAgICAvL2ludmVydCB0aGUgYXJndW1lbnRzLCBidXQgY29tcGxhaW4gYWJvdXQgaXRcbiAgICAgICAgICAgIGlmIChwZXJpb2QgIT09IG51bGwgJiYgIWlzTmFOKCtwZXJpb2QpKSB7XG4gICAgICAgICAgICAgICAgZGVwcmVjYXRlU2ltcGxlKFxuICAgICAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgICAgICAnbW9tZW50KCkuJyArXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lICtcbiAgICAgICAgICAgICAgICAgICAgICAgICcocGVyaW9kLCBudW1iZXIpIGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgbW9tZW50KCkuJyArXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lICtcbiAgICAgICAgICAgICAgICAgICAgICAgICcobnVtYmVyLCBwZXJpb2QpLiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdTZWUgaHR0cDovL21vbWVudGpzLmNvbS9ndWlkZXMvIy93YXJuaW5ncy9hZGQtaW52ZXJ0ZWQtcGFyYW0vIGZvciBtb3JlIGluZm8uJ1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgdG1wID0gdmFsO1xuICAgICAgICAgICAgICAgIHZhbCA9IHBlcmlvZDtcbiAgICAgICAgICAgICAgICBwZXJpb2QgPSB0bXA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGR1ciA9IGNyZWF0ZUR1cmF0aW9uKHZhbCwgcGVyaW9kKTtcbiAgICAgICAgICAgIGFkZFN1YnRyYWN0KHRoaXMsIGR1ciwgZGlyZWN0aW9uKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZFN1YnRyYWN0KG1vbSwgZHVyYXRpb24sIGlzQWRkaW5nLCB1cGRhdGVPZmZzZXQpIHtcbiAgICAgICAgdmFyIG1pbGxpc2Vjb25kcyA9IGR1cmF0aW9uLl9taWxsaXNlY29uZHMsXG4gICAgICAgICAgICBkYXlzID0gYWJzUm91bmQoZHVyYXRpb24uX2RheXMpLFxuICAgICAgICAgICAgbW9udGhzID0gYWJzUm91bmQoZHVyYXRpb24uX21vbnRocyk7XG5cbiAgICAgICAgaWYgKCFtb20uaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICAvLyBObyBvcFxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdXBkYXRlT2Zmc2V0ID0gdXBkYXRlT2Zmc2V0ID09IG51bGwgPyB0cnVlIDogdXBkYXRlT2Zmc2V0O1xuXG4gICAgICAgIGlmIChtb250aHMpIHtcbiAgICAgICAgICAgIHNldE1vbnRoKG1vbSwgZ2V0KG1vbSwgJ01vbnRoJykgKyBtb250aHMgKiBpc0FkZGluZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRheXMpIHtcbiAgICAgICAgICAgIHNldCQxKG1vbSwgJ0RhdGUnLCBnZXQobW9tLCAnRGF0ZScpICsgZGF5cyAqIGlzQWRkaW5nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWlsbGlzZWNvbmRzKSB7XG4gICAgICAgICAgICBtb20uX2Quc2V0VGltZShtb20uX2QudmFsdWVPZigpICsgbWlsbGlzZWNvbmRzICogaXNBZGRpbmcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1cGRhdGVPZmZzZXQpIHtcbiAgICAgICAgICAgIGhvb2tzLnVwZGF0ZU9mZnNldChtb20sIGRheXMgfHwgbW9udGhzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBhZGQgPSBjcmVhdGVBZGRlcigxLCAnYWRkJyksXG4gICAgICAgIHN1YnRyYWN0ID0gY3JlYXRlQWRkZXIoLTEsICdzdWJ0cmFjdCcpO1xuXG4gICAgZnVuY3Rpb24gaXNTdHJpbmcoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycgfHwgaW5wdXQgaW5zdGFuY2VvZiBTdHJpbmc7XG4gICAgfVxuXG4gICAgLy8gdHlwZSBNb21lbnRJbnB1dCA9IE1vbWVudCB8IERhdGUgfCBzdHJpbmcgfCBudW1iZXIgfCAobnVtYmVyIHwgc3RyaW5nKVtdIHwgTW9tZW50SW5wdXRPYmplY3QgfCB2b2lkOyAvLyBudWxsIHwgdW5kZWZpbmVkXG4gICAgZnVuY3Rpb24gaXNNb21lbnRJbnB1dChpbnB1dCkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgaXNNb21lbnQoaW5wdXQpIHx8XG4gICAgICAgICAgICBpc0RhdGUoaW5wdXQpIHx8XG4gICAgICAgICAgICBpc1N0cmluZyhpbnB1dCkgfHxcbiAgICAgICAgICAgIGlzTnVtYmVyKGlucHV0KSB8fFxuICAgICAgICAgICAgaXNOdW1iZXJPclN0cmluZ0FycmF5KGlucHV0KSB8fFxuICAgICAgICAgICAgaXNNb21lbnRJbnB1dE9iamVjdChpbnB1dCkgfHxcbiAgICAgICAgICAgIGlucHV0ID09PSBudWxsIHx8XG4gICAgICAgICAgICBpbnB1dCA9PT0gdW5kZWZpbmVkXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNNb21lbnRJbnB1dE9iamVjdChpbnB1dCkge1xuICAgICAgICB2YXIgb2JqZWN0VGVzdCA9IGlzT2JqZWN0KGlucHV0KSAmJiAhaXNPYmplY3RFbXB0eShpbnB1dCksXG4gICAgICAgICAgICBwcm9wZXJ0eVRlc3QgPSBmYWxzZSxcbiAgICAgICAgICAgIHByb3BlcnRpZXMgPSBbXG4gICAgICAgICAgICAgICAgJ3llYXJzJyxcbiAgICAgICAgICAgICAgICAneWVhcicsXG4gICAgICAgICAgICAgICAgJ3knLFxuICAgICAgICAgICAgICAgICdtb250aHMnLFxuICAgICAgICAgICAgICAgICdtb250aCcsXG4gICAgICAgICAgICAgICAgJ00nLFxuICAgICAgICAgICAgICAgICdkYXlzJyxcbiAgICAgICAgICAgICAgICAnZGF5JyxcbiAgICAgICAgICAgICAgICAnZCcsXG4gICAgICAgICAgICAgICAgJ2RhdGVzJyxcbiAgICAgICAgICAgICAgICAnZGF0ZScsXG4gICAgICAgICAgICAgICAgJ0QnLFxuICAgICAgICAgICAgICAgICdob3VycycsXG4gICAgICAgICAgICAgICAgJ2hvdXInLFxuICAgICAgICAgICAgICAgICdoJyxcbiAgICAgICAgICAgICAgICAnbWludXRlcycsXG4gICAgICAgICAgICAgICAgJ21pbnV0ZScsXG4gICAgICAgICAgICAgICAgJ20nLFxuICAgICAgICAgICAgICAgICdzZWNvbmRzJyxcbiAgICAgICAgICAgICAgICAnc2Vjb25kJyxcbiAgICAgICAgICAgICAgICAncycsXG4gICAgICAgICAgICAgICAgJ21pbGxpc2Vjb25kcycsXG4gICAgICAgICAgICAgICAgJ21pbGxpc2Vjb25kJyxcbiAgICAgICAgICAgICAgICAnbXMnLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICBwcm9wZXJ0eTtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcHJvcGVydGllcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgcHJvcGVydHkgPSBwcm9wZXJ0aWVzW2ldO1xuICAgICAgICAgICAgcHJvcGVydHlUZXN0ID0gcHJvcGVydHlUZXN0IHx8IGhhc093blByb3AoaW5wdXQsIHByb3BlcnR5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvYmplY3RUZXN0ICYmIHByb3BlcnR5VGVzdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc051bWJlck9yU3RyaW5nQXJyYXkoaW5wdXQpIHtcbiAgICAgICAgdmFyIGFycmF5VGVzdCA9IGlzQXJyYXkoaW5wdXQpLFxuICAgICAgICAgICAgZGF0YVR5cGVUZXN0ID0gZmFsc2U7XG4gICAgICAgIGlmIChhcnJheVRlc3QpIHtcbiAgICAgICAgICAgIGRhdGFUeXBlVGVzdCA9XG4gICAgICAgICAgICAgICAgaW5wdXQuZmlsdGVyKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAhaXNOdW1iZXIoaXRlbSkgJiYgaXNTdHJpbmcoaW5wdXQpO1xuICAgICAgICAgICAgICAgIH0pLmxlbmd0aCA9PT0gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJyYXlUZXN0ICYmIGRhdGFUeXBlVGVzdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0NhbGVuZGFyU3BlYyhpbnB1dCkge1xuICAgICAgICB2YXIgb2JqZWN0VGVzdCA9IGlzT2JqZWN0KGlucHV0KSAmJiAhaXNPYmplY3RFbXB0eShpbnB1dCksXG4gICAgICAgICAgICBwcm9wZXJ0eVRlc3QgPSBmYWxzZSxcbiAgICAgICAgICAgIHByb3BlcnRpZXMgPSBbXG4gICAgICAgICAgICAgICAgJ3NhbWVEYXknLFxuICAgICAgICAgICAgICAgICduZXh0RGF5JyxcbiAgICAgICAgICAgICAgICAnbGFzdERheScsXG4gICAgICAgICAgICAgICAgJ25leHRXZWVrJyxcbiAgICAgICAgICAgICAgICAnbGFzdFdlZWsnLFxuICAgICAgICAgICAgICAgICdzYW1lRWxzZScsXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgaSxcbiAgICAgICAgICAgIHByb3BlcnR5O1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBwcm9wZXJ0aWVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICBwcm9wZXJ0eSA9IHByb3BlcnRpZXNbaV07XG4gICAgICAgICAgICBwcm9wZXJ0eVRlc3QgPSBwcm9wZXJ0eVRlc3QgfHwgaGFzT3duUHJvcChpbnB1dCwgcHJvcGVydHkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG9iamVjdFRlc3QgJiYgcHJvcGVydHlUZXN0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldENhbGVuZGFyRm9ybWF0KG15TW9tZW50LCBub3cpIHtcbiAgICAgICAgdmFyIGRpZmYgPSBteU1vbWVudC5kaWZmKG5vdywgJ2RheXMnLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIGRpZmYgPCAtNlxuICAgICAgICAgICAgPyAnc2FtZUVsc2UnXG4gICAgICAgICAgICA6IGRpZmYgPCAtMVxuICAgICAgICAgICAgPyAnbGFzdFdlZWsnXG4gICAgICAgICAgICA6IGRpZmYgPCAwXG4gICAgICAgICAgICA/ICdsYXN0RGF5J1xuICAgICAgICAgICAgOiBkaWZmIDwgMVxuICAgICAgICAgICAgPyAnc2FtZURheSdcbiAgICAgICAgICAgIDogZGlmZiA8IDJcbiAgICAgICAgICAgID8gJ25leHREYXknXG4gICAgICAgICAgICA6IGRpZmYgPCA3XG4gICAgICAgICAgICA/ICduZXh0V2VlaydcbiAgICAgICAgICAgIDogJ3NhbWVFbHNlJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjYWxlbmRhciQxKHRpbWUsIGZvcm1hdHMpIHtcbiAgICAgICAgLy8gU3VwcG9ydCBmb3Igc2luZ2xlIHBhcmFtZXRlciwgZm9ybWF0cyBvbmx5IG92ZXJsb2FkIHRvIHRoZSBjYWxlbmRhciBmdW5jdGlvblxuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgaWYgKCFhcmd1bWVudHNbMF0pIHtcbiAgICAgICAgICAgICAgICB0aW1lID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGZvcm1hdHMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzTW9tZW50SW5wdXQoYXJndW1lbnRzWzBdKSkge1xuICAgICAgICAgICAgICAgIHRpbWUgPSBhcmd1bWVudHNbMF07XG4gICAgICAgICAgICAgICAgZm9ybWF0cyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNDYWxlbmRhclNwZWMoYXJndW1lbnRzWzBdKSkge1xuICAgICAgICAgICAgICAgIGZvcm1hdHMgPSBhcmd1bWVudHNbMF07XG4gICAgICAgICAgICAgICAgdGltZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBXZSB3YW50IHRvIGNvbXBhcmUgdGhlIHN0YXJ0IG9mIHRvZGF5LCB2cyB0aGlzLlxuICAgICAgICAvLyBHZXR0aW5nIHN0YXJ0LW9mLXRvZGF5IGRlcGVuZHMgb24gd2hldGhlciB3ZSdyZSBsb2NhbC91dGMvb2Zmc2V0IG9yIG5vdC5cbiAgICAgICAgdmFyIG5vdyA9IHRpbWUgfHwgY3JlYXRlTG9jYWwoKSxcbiAgICAgICAgICAgIHNvZCA9IGNsb25lV2l0aE9mZnNldChub3csIHRoaXMpLnN0YXJ0T2YoJ2RheScpLFxuICAgICAgICAgICAgZm9ybWF0ID0gaG9va3MuY2FsZW5kYXJGb3JtYXQodGhpcywgc29kKSB8fCAnc2FtZUVsc2UnLFxuICAgICAgICAgICAgb3V0cHV0ID1cbiAgICAgICAgICAgICAgICBmb3JtYXRzICYmXG4gICAgICAgICAgICAgICAgKGlzRnVuY3Rpb24oZm9ybWF0c1tmb3JtYXRdKVxuICAgICAgICAgICAgICAgICAgICA/IGZvcm1hdHNbZm9ybWF0XS5jYWxsKHRoaXMsIG5vdylcbiAgICAgICAgICAgICAgICAgICAgOiBmb3JtYXRzW2Zvcm1hdF0pO1xuXG4gICAgICAgIHJldHVybiB0aGlzLmZvcm1hdChcbiAgICAgICAgICAgIG91dHB1dCB8fCB0aGlzLmxvY2FsZURhdGEoKS5jYWxlbmRhcihmb3JtYXQsIHRoaXMsIGNyZWF0ZUxvY2FsKG5vdykpXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xvbmUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgTW9tZW50KHRoaXMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzQWZ0ZXIoaW5wdXQsIHVuaXRzKSB7XG4gICAgICAgIHZhciBsb2NhbElucHV0ID0gaXNNb21lbnQoaW5wdXQpID8gaW5wdXQgOiBjcmVhdGVMb2NhbChpbnB1dCk7XG4gICAgICAgIGlmICghKHRoaXMuaXNWYWxpZCgpICYmIGxvY2FsSW5wdXQuaXNWYWxpZCgpKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpIHx8ICdtaWxsaXNlY29uZCc7XG4gICAgICAgIGlmICh1bml0cyA9PT0gJ21pbGxpc2Vjb25kJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVPZigpID4gbG9jYWxJbnB1dC52YWx1ZU9mKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxJbnB1dC52YWx1ZU9mKCkgPCB0aGlzLmNsb25lKCkuc3RhcnRPZih1bml0cykudmFsdWVPZigpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNCZWZvcmUoaW5wdXQsIHVuaXRzKSB7XG4gICAgICAgIHZhciBsb2NhbElucHV0ID0gaXNNb21lbnQoaW5wdXQpID8gaW5wdXQgOiBjcmVhdGVMb2NhbChpbnB1dCk7XG4gICAgICAgIGlmICghKHRoaXMuaXNWYWxpZCgpICYmIGxvY2FsSW5wdXQuaXNWYWxpZCgpKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpIHx8ICdtaWxsaXNlY29uZCc7XG4gICAgICAgIGlmICh1bml0cyA9PT0gJ21pbGxpc2Vjb25kJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVPZigpIDwgbG9jYWxJbnB1dC52YWx1ZU9mKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmVuZE9mKHVuaXRzKS52YWx1ZU9mKCkgPCBsb2NhbElucHV0LnZhbHVlT2YoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzQmV0d2Vlbihmcm9tLCB0bywgdW5pdHMsIGluY2x1c2l2aXR5KSB7XG4gICAgICAgIHZhciBsb2NhbEZyb20gPSBpc01vbWVudChmcm9tKSA/IGZyb20gOiBjcmVhdGVMb2NhbChmcm9tKSxcbiAgICAgICAgICAgIGxvY2FsVG8gPSBpc01vbWVudCh0bykgPyB0byA6IGNyZWF0ZUxvY2FsKHRvKTtcbiAgICAgICAgaWYgKCEodGhpcy5pc1ZhbGlkKCkgJiYgbG9jYWxGcm9tLmlzVmFsaWQoKSAmJiBsb2NhbFRvLmlzVmFsaWQoKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpbmNsdXNpdml0eSA9IGluY2x1c2l2aXR5IHx8ICcoKSc7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAoaW5jbHVzaXZpdHlbMF0gPT09ICcoJ1xuICAgICAgICAgICAgICAgID8gdGhpcy5pc0FmdGVyKGxvY2FsRnJvbSwgdW5pdHMpXG4gICAgICAgICAgICAgICAgOiAhdGhpcy5pc0JlZm9yZShsb2NhbEZyb20sIHVuaXRzKSkgJiZcbiAgICAgICAgICAgIChpbmNsdXNpdml0eVsxXSA9PT0gJyknXG4gICAgICAgICAgICAgICAgPyB0aGlzLmlzQmVmb3JlKGxvY2FsVG8sIHVuaXRzKVxuICAgICAgICAgICAgICAgIDogIXRoaXMuaXNBZnRlcihsb2NhbFRvLCB1bml0cykpXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNTYW1lKGlucHV0LCB1bml0cykge1xuICAgICAgICB2YXIgbG9jYWxJbnB1dCA9IGlzTW9tZW50KGlucHV0KSA/IGlucHV0IDogY3JlYXRlTG9jYWwoaW5wdXQpLFxuICAgICAgICAgICAgaW5wdXRNcztcbiAgICAgICAgaWYgKCEodGhpcy5pc1ZhbGlkKCkgJiYgbG9jYWxJbnB1dC5pc1ZhbGlkKCkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cykgfHwgJ21pbGxpc2Vjb25kJztcbiAgICAgICAgaWYgKHVuaXRzID09PSAnbWlsbGlzZWNvbmQnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZU9mKCkgPT09IGxvY2FsSW5wdXQudmFsdWVPZigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaW5wdXRNcyA9IGxvY2FsSW5wdXQudmFsdWVPZigpO1xuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICB0aGlzLmNsb25lKCkuc3RhcnRPZih1bml0cykudmFsdWVPZigpIDw9IGlucHV0TXMgJiZcbiAgICAgICAgICAgICAgICBpbnB1dE1zIDw9IHRoaXMuY2xvbmUoKS5lbmRPZih1bml0cykudmFsdWVPZigpXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNTYW1lT3JBZnRlcihpbnB1dCwgdW5pdHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNTYW1lKGlucHV0LCB1bml0cykgfHwgdGhpcy5pc0FmdGVyKGlucHV0LCB1bml0cyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNTYW1lT3JCZWZvcmUoaW5wdXQsIHVuaXRzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzU2FtZShpbnB1dCwgdW5pdHMpIHx8IHRoaXMuaXNCZWZvcmUoaW5wdXQsIHVuaXRzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkaWZmKGlucHV0LCB1bml0cywgYXNGbG9hdCkge1xuICAgICAgICB2YXIgdGhhdCwgem9uZURlbHRhLCBvdXRwdXQ7XG5cbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoYXQgPSBjbG9uZVdpdGhPZmZzZXQoaW5wdXQsIHRoaXMpO1xuXG4gICAgICAgIGlmICghdGhhdC5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBOYU47XG4gICAgICAgIH1cblxuICAgICAgICB6b25lRGVsdGEgPSAodGhhdC51dGNPZmZzZXQoKSAtIHRoaXMudXRjT2Zmc2V0KCkpICogNmU0O1xuXG4gICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xuXG4gICAgICAgIHN3aXRjaCAodW5pdHMpIHtcbiAgICAgICAgICAgIGNhc2UgJ3llYXInOlxuICAgICAgICAgICAgICAgIG91dHB1dCA9IG1vbnRoRGlmZih0aGlzLCB0aGF0KSAvIDEyO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbW9udGgnOlxuICAgICAgICAgICAgICAgIG91dHB1dCA9IG1vbnRoRGlmZih0aGlzLCB0aGF0KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3F1YXJ0ZXInOlxuICAgICAgICAgICAgICAgIG91dHB1dCA9IG1vbnRoRGlmZih0aGlzLCB0aGF0KSAvIDM7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdzZWNvbmQnOlxuICAgICAgICAgICAgICAgIG91dHB1dCA9ICh0aGlzIC0gdGhhdCkgLyAxZTM7XG4gICAgICAgICAgICAgICAgYnJlYWs7IC8vIDEwMDBcbiAgICAgICAgICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gKHRoaXMgLSB0aGF0KSAvIDZlNDtcbiAgICAgICAgICAgICAgICBicmVhazsgLy8gMTAwMCAqIDYwXG4gICAgICAgICAgICBjYXNlICdob3VyJzpcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSAodGhpcyAtIHRoYXQpIC8gMzZlNTtcbiAgICAgICAgICAgICAgICBicmVhazsgLy8gMTAwMCAqIDYwICogNjBcbiAgICAgICAgICAgIGNhc2UgJ2RheSc6XG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gKHRoaXMgLSB0aGF0IC0gem9uZURlbHRhKSAvIDg2NGU1O1xuICAgICAgICAgICAgICAgIGJyZWFrOyAvLyAxMDAwICogNjAgKiA2MCAqIDI0LCBuZWdhdGUgZHN0XG4gICAgICAgICAgICBjYXNlICd3ZWVrJzpcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSAodGhpcyAtIHRoYXQgLSB6b25lRGVsdGEpIC8gNjA0OGU1O1xuICAgICAgICAgICAgICAgIGJyZWFrOyAvLyAxMDAwICogNjAgKiA2MCAqIDI0ICogNywgbmVnYXRlIGRzdFxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSB0aGlzIC0gdGhhdDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhc0Zsb2F0ID8gb3V0cHV0IDogYWJzRmxvb3Iob3V0cHV0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtb250aERpZmYoYSwgYikge1xuICAgICAgICBpZiAoYS5kYXRlKCkgPCBiLmRhdGUoKSkge1xuICAgICAgICAgICAgLy8gZW5kLW9mLW1vbnRoIGNhbGN1bGF0aW9ucyB3b3JrIGNvcnJlY3Qgd2hlbiB0aGUgc3RhcnQgbW9udGggaGFzIG1vcmVcbiAgICAgICAgICAgIC8vIGRheXMgdGhhbiB0aGUgZW5kIG1vbnRoLlxuICAgICAgICAgICAgcmV0dXJuIC1tb250aERpZmYoYiwgYSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZGlmZmVyZW5jZSBpbiBtb250aHNcbiAgICAgICAgdmFyIHdob2xlTW9udGhEaWZmID0gKGIueWVhcigpIC0gYS55ZWFyKCkpICogMTIgKyAoYi5tb250aCgpIC0gYS5tb250aCgpKSxcbiAgICAgICAgICAgIC8vIGIgaXMgaW4gKGFuY2hvciAtIDEgbW9udGgsIGFuY2hvciArIDEgbW9udGgpXG4gICAgICAgICAgICBhbmNob3IgPSBhLmNsb25lKCkuYWRkKHdob2xlTW9udGhEaWZmLCAnbW9udGhzJyksXG4gICAgICAgICAgICBhbmNob3IyLFxuICAgICAgICAgICAgYWRqdXN0O1xuXG4gICAgICAgIGlmIChiIC0gYW5jaG9yIDwgMCkge1xuICAgICAgICAgICAgYW5jaG9yMiA9IGEuY2xvbmUoKS5hZGQod2hvbGVNb250aERpZmYgLSAxLCAnbW9udGhzJyk7XG4gICAgICAgICAgICAvLyBsaW5lYXIgYWNyb3NzIHRoZSBtb250aFxuICAgICAgICAgICAgYWRqdXN0ID0gKGIgLSBhbmNob3IpIC8gKGFuY2hvciAtIGFuY2hvcjIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYW5jaG9yMiA9IGEuY2xvbmUoKS5hZGQod2hvbGVNb250aERpZmYgKyAxLCAnbW9udGhzJyk7XG4gICAgICAgICAgICAvLyBsaW5lYXIgYWNyb3NzIHRoZSBtb250aFxuICAgICAgICAgICAgYWRqdXN0ID0gKGIgLSBhbmNob3IpIC8gKGFuY2hvcjIgLSBhbmNob3IpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9jaGVjayBmb3IgbmVnYXRpdmUgemVybywgcmV0dXJuIHplcm8gaWYgbmVnYXRpdmUgemVyb1xuICAgICAgICByZXR1cm4gLSh3aG9sZU1vbnRoRGlmZiArIGFkanVzdCkgfHwgMDtcbiAgICB9XG5cbiAgICBob29rcy5kZWZhdWx0Rm9ybWF0ID0gJ1lZWVktTU0tRERUSEg6bW06c3NaJztcbiAgICBob29rcy5kZWZhdWx0Rm9ybWF0VXRjID0gJ1lZWVktTU0tRERUSEg6bW06c3NbWl0nO1xuXG4gICAgZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsb25lKCkubG9jYWxlKCdlbicpLmZvcm1hdCgnZGRkIE1NTSBERCBZWVlZIEhIOm1tOnNzIFtHTVRdWlonKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b0lTT1N0cmluZyhrZWVwT2Zmc2V0KSB7XG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciB1dGMgPSBrZWVwT2Zmc2V0ICE9PSB0cnVlLFxuICAgICAgICAgICAgbSA9IHV0YyA/IHRoaXMuY2xvbmUoKS51dGMoKSA6IHRoaXM7XG4gICAgICAgIGlmIChtLnllYXIoKSA8IDAgfHwgbS55ZWFyKCkgPiA5OTk5KSB7XG4gICAgICAgICAgICByZXR1cm4gZm9ybWF0TW9tZW50KFxuICAgICAgICAgICAgICAgIG0sXG4gICAgICAgICAgICAgICAgdXRjXG4gICAgICAgICAgICAgICAgICAgID8gJ1lZWVlZWS1NTS1ERFtUXUhIOm1tOnNzLlNTU1taXSdcbiAgICAgICAgICAgICAgICAgICAgOiAnWVlZWVlZLU1NLUREW1RdSEg6bW06c3MuU1NTWidcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzRnVuY3Rpb24oRGF0ZS5wcm90b3R5cGUudG9JU09TdHJpbmcpKSB7XG4gICAgICAgICAgICAvLyBuYXRpdmUgaW1wbGVtZW50YXRpb24gaXMgfjUweCBmYXN0ZXIsIHVzZSBpdCB3aGVuIHdlIGNhblxuICAgICAgICAgICAgaWYgKHV0Yykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRvRGF0ZSgpLnRvSVNPU3RyaW5nKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZSh0aGlzLnZhbHVlT2YoKSArIHRoaXMudXRjT2Zmc2V0KCkgKiA2MCAqIDEwMDApXG4gICAgICAgICAgICAgICAgICAgIC50b0lTT1N0cmluZygpXG4gICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKCdaJywgZm9ybWF0TW9tZW50KG0sICdaJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmb3JtYXRNb21lbnQoXG4gICAgICAgICAgICBtLFxuICAgICAgICAgICAgdXRjID8gJ1lZWVktTU0tRERbVF1ISDptbTpzcy5TU1NbWl0nIDogJ1lZWVktTU0tRERbVF1ISDptbTpzcy5TU1NaJ1xuICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBhIGh1bWFuIHJlYWRhYmxlIHJlcHJlc2VudGF0aW9uIG9mIGEgbW9tZW50IHRoYXQgY2FuXG4gICAgICogYWxzbyBiZSBldmFsdWF0ZWQgdG8gZ2V0IGEgbmV3IG1vbWVudCB3aGljaCBpcyB0aGUgc2FtZVxuICAgICAqXG4gICAgICogQGxpbmsgaHR0cHM6Ly9ub2RlanMub3JnL2Rpc3QvbGF0ZXN0L2RvY3MvYXBpL3V0aWwuaHRtbCN1dGlsX2N1c3RvbV9pbnNwZWN0X2Z1bmN0aW9uX29uX29iamVjdHNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbnNwZWN0KCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ21vbWVudC5pbnZhbGlkKC8qICcgKyB0aGlzLl9pICsgJyAqLyknO1xuICAgICAgICB9XG4gICAgICAgIHZhciBmdW5jID0gJ21vbWVudCcsXG4gICAgICAgICAgICB6b25lID0gJycsXG4gICAgICAgICAgICBwcmVmaXgsXG4gICAgICAgICAgICB5ZWFyLFxuICAgICAgICAgICAgZGF0ZXRpbWUsXG4gICAgICAgICAgICBzdWZmaXg7XG4gICAgICAgIGlmICghdGhpcy5pc0xvY2FsKCkpIHtcbiAgICAgICAgICAgIGZ1bmMgPSB0aGlzLnV0Y09mZnNldCgpID09PSAwID8gJ21vbWVudC51dGMnIDogJ21vbWVudC5wYXJzZVpvbmUnO1xuICAgICAgICAgICAgem9uZSA9ICdaJztcbiAgICAgICAgfVxuICAgICAgICBwcmVmaXggPSAnWycgKyBmdW5jICsgJyhcIl0nO1xuICAgICAgICB5ZWFyID0gMCA8PSB0aGlzLnllYXIoKSAmJiB0aGlzLnllYXIoKSA8PSA5OTk5ID8gJ1lZWVknIDogJ1lZWVlZWSc7XG4gICAgICAgIGRhdGV0aW1lID0gJy1NTS1ERFtUXUhIOm1tOnNzLlNTUyc7XG4gICAgICAgIHN1ZmZpeCA9IHpvbmUgKyAnW1wiKV0nO1xuXG4gICAgICAgIHJldHVybiB0aGlzLmZvcm1hdChwcmVmaXggKyB5ZWFyICsgZGF0ZXRpbWUgKyBzdWZmaXgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZvcm1hdChpbnB1dFN0cmluZykge1xuICAgICAgICBpZiAoIWlucHV0U3RyaW5nKSB7XG4gICAgICAgICAgICBpbnB1dFN0cmluZyA9IHRoaXMuaXNVdGMoKVxuICAgICAgICAgICAgICAgID8gaG9va3MuZGVmYXVsdEZvcm1hdFV0Y1xuICAgICAgICAgICAgICAgIDogaG9va3MuZGVmYXVsdEZvcm1hdDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb3V0cHV0ID0gZm9ybWF0TW9tZW50KHRoaXMsIGlucHV0U3RyaW5nKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLnBvc3Rmb3JtYXQob3V0cHV0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmcm9tKHRpbWUsIHdpdGhvdXRTdWZmaXgpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgdGhpcy5pc1ZhbGlkKCkgJiZcbiAgICAgICAgICAgICgoaXNNb21lbnQodGltZSkgJiYgdGltZS5pc1ZhbGlkKCkpIHx8IGNyZWF0ZUxvY2FsKHRpbWUpLmlzVmFsaWQoKSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlRHVyYXRpb24oeyB0bzogdGhpcywgZnJvbTogdGltZSB9KVxuICAgICAgICAgICAgICAgIC5sb2NhbGUodGhpcy5sb2NhbGUoKSlcbiAgICAgICAgICAgICAgICAuaHVtYW5pemUoIXdpdGhvdXRTdWZmaXgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLmludmFsaWREYXRlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmcm9tTm93KHdpdGhvdXRTdWZmaXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZnJvbShjcmVhdGVMb2NhbCgpLCB3aXRob3V0U3VmZml4KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0byh0aW1lLCB3aXRob3V0U3VmZml4KSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgIHRoaXMuaXNWYWxpZCgpICYmXG4gICAgICAgICAgICAoKGlzTW9tZW50KHRpbWUpICYmIHRpbWUuaXNWYWxpZCgpKSB8fCBjcmVhdGVMb2NhbCh0aW1lKS5pc1ZhbGlkKCkpXG4gICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUR1cmF0aW9uKHsgZnJvbTogdGhpcywgdG86IHRpbWUgfSlcbiAgICAgICAgICAgICAgICAubG9jYWxlKHRoaXMubG9jYWxlKCkpXG4gICAgICAgICAgICAgICAgLmh1bWFuaXplKCF3aXRob3V0U3VmZml4KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5pbnZhbGlkRGF0ZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9Ob3cod2l0aG91dFN1ZmZpeCkge1xuICAgICAgICByZXR1cm4gdGhpcy50byhjcmVhdGVMb2NhbCgpLCB3aXRob3V0U3VmZml4KTtcbiAgICB9XG5cbiAgICAvLyBJZiBwYXNzZWQgYSBsb2NhbGUga2V5LCBpdCB3aWxsIHNldCB0aGUgbG9jYWxlIGZvciB0aGlzXG4gICAgLy8gaW5zdGFuY2UuICBPdGhlcndpc2UsIGl0IHdpbGwgcmV0dXJuIHRoZSBsb2NhbGUgY29uZmlndXJhdGlvblxuICAgIC8vIHZhcmlhYmxlcyBmb3IgdGhpcyBpbnN0YW5jZS5cbiAgICBmdW5jdGlvbiBsb2NhbGUoa2V5KSB7XG4gICAgICAgIHZhciBuZXdMb2NhbGVEYXRhO1xuXG4gICAgICAgIGlmIChrZXkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xvY2FsZS5fYWJicjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5ld0xvY2FsZURhdGEgPSBnZXRMb2NhbGUoa2V5KTtcbiAgICAgICAgICAgIGlmIChuZXdMb2NhbGVEYXRhICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2NhbGUgPSBuZXdMb2NhbGVEYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgbGFuZyA9IGRlcHJlY2F0ZShcbiAgICAgICAgJ21vbWVudCgpLmxhbmcoKSBpcyBkZXByZWNhdGVkLiBJbnN0ZWFkLCB1c2UgbW9tZW50KCkubG9jYWxlRGF0YSgpIHRvIGdldCB0aGUgbGFuZ3VhZ2UgY29uZmlndXJhdGlvbi4gVXNlIG1vbWVudCgpLmxvY2FsZSgpIHRvIGNoYW5nZSBsYW5ndWFnZXMuJyxcbiAgICAgICAgZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgaWYgKGtleSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGUoa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICk7XG5cbiAgICBmdW5jdGlvbiBsb2NhbGVEYXRhKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbG9jYWxlO1xuICAgIH1cblxuICAgIHZhciBNU19QRVJfU0VDT05EID0gMTAwMCxcbiAgICAgICAgTVNfUEVSX01JTlVURSA9IDYwICogTVNfUEVSX1NFQ09ORCxcbiAgICAgICAgTVNfUEVSX0hPVVIgPSA2MCAqIE1TX1BFUl9NSU5VVEUsXG4gICAgICAgIE1TX1BFUl80MDBfWUVBUlMgPSAoMzY1ICogNDAwICsgOTcpICogMjQgKiBNU19QRVJfSE9VUjtcblxuICAgIC8vIGFjdHVhbCBtb2R1bG8gLSBoYW5kbGVzIG5lZ2F0aXZlIG51bWJlcnMgKGZvciBkYXRlcyBiZWZvcmUgMTk3MCk6XG4gICAgZnVuY3Rpb24gbW9kJDEoZGl2aWRlbmQsIGRpdmlzb3IpIHtcbiAgICAgICAgcmV0dXJuICgoZGl2aWRlbmQgJSBkaXZpc29yKSArIGRpdmlzb3IpICUgZGl2aXNvcjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb2NhbFN0YXJ0T2ZEYXRlKHksIG0sIGQpIHtcbiAgICAgICAgLy8gdGhlIGRhdGUgY29uc3RydWN0b3IgcmVtYXBzIHllYXJzIDAtOTkgdG8gMTkwMC0xOTk5XG4gICAgICAgIGlmICh5IDwgMTAwICYmIHkgPj0gMCkge1xuICAgICAgICAgICAgLy8gcHJlc2VydmUgbGVhcCB5ZWFycyB1c2luZyBhIGZ1bGwgNDAwIHllYXIgY3ljbGUsIHRoZW4gcmVzZXRcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZSh5ICsgNDAwLCBtLCBkKSAtIE1TX1BFUl80MDBfWUVBUlM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IERhdGUoeSwgbSwgZCkudmFsdWVPZigpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdXRjU3RhcnRPZkRhdGUoeSwgbSwgZCkge1xuICAgICAgICAvLyBEYXRlLlVUQyByZW1hcHMgeWVhcnMgMC05OSB0byAxOTAwLTE5OTlcbiAgICAgICAgaWYgKHkgPCAxMDAgJiYgeSA+PSAwKSB7XG4gICAgICAgICAgICAvLyBwcmVzZXJ2ZSBsZWFwIHllYXJzIHVzaW5nIGEgZnVsbCA0MDAgeWVhciBjeWNsZSwgdGhlbiByZXNldFxuICAgICAgICAgICAgcmV0dXJuIERhdGUuVVRDKHkgKyA0MDAsIG0sIGQpIC0gTVNfUEVSXzQwMF9ZRUFSUztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBEYXRlLlVUQyh5LCBtLCBkKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHN0YXJ0T2YodW5pdHMpIHtcbiAgICAgICAgdmFyIHRpbWUsIHN0YXJ0T2ZEYXRlO1xuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcbiAgICAgICAgaWYgKHVuaXRzID09PSB1bmRlZmluZWQgfHwgdW5pdHMgPT09ICdtaWxsaXNlY29uZCcgfHwgIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXJ0T2ZEYXRlID0gdGhpcy5faXNVVEMgPyB1dGNTdGFydE9mRGF0ZSA6IGxvY2FsU3RhcnRPZkRhdGU7XG5cbiAgICAgICAgc3dpdGNoICh1bml0cykge1xuICAgICAgICAgICAgY2FzZSAneWVhcic6XG4gICAgICAgICAgICAgICAgdGltZSA9IHN0YXJ0T2ZEYXRlKHRoaXMueWVhcigpLCAwLCAxKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3F1YXJ0ZXInOlxuICAgICAgICAgICAgICAgIHRpbWUgPSBzdGFydE9mRGF0ZShcbiAgICAgICAgICAgICAgICAgICAgdGhpcy55ZWFyKCksXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubW9udGgoKSAtICh0aGlzLm1vbnRoKCkgJSAzKSxcbiAgICAgICAgICAgICAgICAgICAgMVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdtb250aCc6XG4gICAgICAgICAgICAgICAgdGltZSA9IHN0YXJ0T2ZEYXRlKHRoaXMueWVhcigpLCB0aGlzLm1vbnRoKCksIDEpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnd2Vlayc6XG4gICAgICAgICAgICAgICAgdGltZSA9IHN0YXJ0T2ZEYXRlKFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnllYXIoKSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tb250aCgpLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRhdGUoKSAtIHRoaXMud2Vla2RheSgpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2lzb1dlZWsnOlxuICAgICAgICAgICAgICAgIHRpbWUgPSBzdGFydE9mRGF0ZShcbiAgICAgICAgICAgICAgICAgICAgdGhpcy55ZWFyKCksXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubW9udGgoKSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kYXRlKCkgLSAodGhpcy5pc29XZWVrZGF5KCkgLSAxKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdkYXknOlxuICAgICAgICAgICAgY2FzZSAnZGF0ZSc6XG4gICAgICAgICAgICAgICAgdGltZSA9IHN0YXJ0T2ZEYXRlKHRoaXMueWVhcigpLCB0aGlzLm1vbnRoKCksIHRoaXMuZGF0ZSgpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2hvdXInOlxuICAgICAgICAgICAgICAgIHRpbWUgPSB0aGlzLl9kLnZhbHVlT2YoKTtcbiAgICAgICAgICAgICAgICB0aW1lIC09IG1vZCQxKFxuICAgICAgICAgICAgICAgICAgICB0aW1lICsgKHRoaXMuX2lzVVRDID8gMCA6IHRoaXMudXRjT2Zmc2V0KCkgKiBNU19QRVJfTUlOVVRFKSxcbiAgICAgICAgICAgICAgICAgICAgTVNfUEVSX0hPVVJcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbWludXRlJzpcbiAgICAgICAgICAgICAgICB0aW1lID0gdGhpcy5fZC52YWx1ZU9mKCk7XG4gICAgICAgICAgICAgICAgdGltZSAtPSBtb2QkMSh0aW1lLCBNU19QRVJfTUlOVVRFKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgICAgICAgICAgICAgdGltZSA9IHRoaXMuX2QudmFsdWVPZigpO1xuICAgICAgICAgICAgICAgIHRpbWUgLT0gbW9kJDEodGltZSwgTVNfUEVSX1NFQ09ORCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9kLnNldFRpbWUodGltZSk7XG4gICAgICAgIGhvb2tzLnVwZGF0ZU9mZnNldCh0aGlzLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZW5kT2YodW5pdHMpIHtcbiAgICAgICAgdmFyIHRpbWUsIHN0YXJ0T2ZEYXRlO1xuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcbiAgICAgICAgaWYgKHVuaXRzID09PSB1bmRlZmluZWQgfHwgdW5pdHMgPT09ICdtaWxsaXNlY29uZCcgfHwgIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXJ0T2ZEYXRlID0gdGhpcy5faXNVVEMgPyB1dGNTdGFydE9mRGF0ZSA6IGxvY2FsU3RhcnRPZkRhdGU7XG5cbiAgICAgICAgc3dpdGNoICh1bml0cykge1xuICAgICAgICAgICAgY2FzZSAneWVhcic6XG4gICAgICAgICAgICAgICAgdGltZSA9IHN0YXJ0T2ZEYXRlKHRoaXMueWVhcigpICsgMSwgMCwgMSkgLSAxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAncXVhcnRlcic6XG4gICAgICAgICAgICAgICAgdGltZSA9XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0T2ZEYXRlKFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy55ZWFyKCksXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1vbnRoKCkgLSAodGhpcy5tb250aCgpICUgMykgKyAzLFxuICAgICAgICAgICAgICAgICAgICAgICAgMVxuICAgICAgICAgICAgICAgICAgICApIC0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ21vbnRoJzpcbiAgICAgICAgICAgICAgICB0aW1lID0gc3RhcnRPZkRhdGUodGhpcy55ZWFyKCksIHRoaXMubW9udGgoKSArIDEsIDEpIC0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3dlZWsnOlxuICAgICAgICAgICAgICAgIHRpbWUgPVxuICAgICAgICAgICAgICAgICAgICBzdGFydE9mRGF0ZShcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMueWVhcigpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tb250aCgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kYXRlKCkgLSB0aGlzLndlZWtkYXkoKSArIDdcbiAgICAgICAgICAgICAgICAgICAgKSAtIDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdpc29XZWVrJzpcbiAgICAgICAgICAgICAgICB0aW1lID1cbiAgICAgICAgICAgICAgICAgICAgc3RhcnRPZkRhdGUoXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnllYXIoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubW9udGgoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGF0ZSgpIC0gKHRoaXMuaXNvV2Vla2RheSgpIC0gMSkgKyA3XG4gICAgICAgICAgICAgICAgICAgICkgLSAxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnZGF5JzpcbiAgICAgICAgICAgIGNhc2UgJ2RhdGUnOlxuICAgICAgICAgICAgICAgIHRpbWUgPSBzdGFydE9mRGF0ZSh0aGlzLnllYXIoKSwgdGhpcy5tb250aCgpLCB0aGlzLmRhdGUoKSArIDEpIC0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2hvdXInOlxuICAgICAgICAgICAgICAgIHRpbWUgPSB0aGlzLl9kLnZhbHVlT2YoKTtcbiAgICAgICAgICAgICAgICB0aW1lICs9XG4gICAgICAgICAgICAgICAgICAgIE1TX1BFUl9IT1VSIC1cbiAgICAgICAgICAgICAgICAgICAgbW9kJDEoXG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lICsgKHRoaXMuX2lzVVRDID8gMCA6IHRoaXMudXRjT2Zmc2V0KCkgKiBNU19QRVJfTUlOVVRFKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIE1TX1BFUl9IT1VSXG4gICAgICAgICAgICAgICAgICAgICkgLVxuICAgICAgICAgICAgICAgICAgICAxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbWludXRlJzpcbiAgICAgICAgICAgICAgICB0aW1lID0gdGhpcy5fZC52YWx1ZU9mKCk7XG4gICAgICAgICAgICAgICAgdGltZSArPSBNU19QRVJfTUlOVVRFIC0gbW9kJDEodGltZSwgTVNfUEVSX01JTlVURSkgLSAxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnc2Vjb25kJzpcbiAgICAgICAgICAgICAgICB0aW1lID0gdGhpcy5fZC52YWx1ZU9mKCk7XG4gICAgICAgICAgICAgICAgdGltZSArPSBNU19QRVJfU0VDT05EIC0gbW9kJDEodGltZSwgTVNfUEVSX1NFQ09ORCkgLSAxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fZC5zZXRUaW1lKHRpbWUpO1xuICAgICAgICBob29rcy51cGRhdGVPZmZzZXQodGhpcywgdHJ1ZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHZhbHVlT2YoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kLnZhbHVlT2YoKSAtICh0aGlzLl9vZmZzZXQgfHwgMCkgKiA2MDAwMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1bml4KCkge1xuICAgICAgICByZXR1cm4gTWF0aC5mbG9vcih0aGlzLnZhbHVlT2YoKSAvIDEwMDApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvRGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHRoaXMudmFsdWVPZigpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b0FycmF5KCkge1xuICAgICAgICB2YXIgbSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBtLnllYXIoKSxcbiAgICAgICAgICAgIG0ubW9udGgoKSxcbiAgICAgICAgICAgIG0uZGF0ZSgpLFxuICAgICAgICAgICAgbS5ob3VyKCksXG4gICAgICAgICAgICBtLm1pbnV0ZSgpLFxuICAgICAgICAgICAgbS5zZWNvbmQoKSxcbiAgICAgICAgICAgIG0ubWlsbGlzZWNvbmQoKSxcbiAgICAgICAgXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b09iamVjdCgpIHtcbiAgICAgICAgdmFyIG0gPSB0aGlzO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeWVhcnM6IG0ueWVhcigpLFxuICAgICAgICAgICAgbW9udGhzOiBtLm1vbnRoKCksXG4gICAgICAgICAgICBkYXRlOiBtLmRhdGUoKSxcbiAgICAgICAgICAgIGhvdXJzOiBtLmhvdXJzKCksXG4gICAgICAgICAgICBtaW51dGVzOiBtLm1pbnV0ZXMoKSxcbiAgICAgICAgICAgIHNlY29uZHM6IG0uc2Vjb25kcygpLFxuICAgICAgICAgICAgbWlsbGlzZWNvbmRzOiBtLm1pbGxpc2Vjb25kcygpLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgICAgLy8gbmV3IERhdGUoTmFOKS50b0pTT04oKSA9PT0gbnVsbFxuICAgICAgICByZXR1cm4gdGhpcy5pc1ZhbGlkKCkgPyB0aGlzLnRvSVNPU3RyaW5nKCkgOiBudWxsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzVmFsaWQkMigpIHtcbiAgICAgICAgcmV0dXJuIGlzVmFsaWQodGhpcyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2luZ0ZsYWdzKCkge1xuICAgICAgICByZXR1cm4gZXh0ZW5kKHt9LCBnZXRQYXJzaW5nRmxhZ3ModGhpcykpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGludmFsaWRBdCgpIHtcbiAgICAgICAgcmV0dXJuIGdldFBhcnNpbmdGbGFncyh0aGlzKS5vdmVyZmxvdztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGlvbkRhdGEoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpbnB1dDogdGhpcy5faSxcbiAgICAgICAgICAgIGZvcm1hdDogdGhpcy5fZixcbiAgICAgICAgICAgIGxvY2FsZTogdGhpcy5fbG9jYWxlLFxuICAgICAgICAgICAgaXNVVEM6IHRoaXMuX2lzVVRDLFxuICAgICAgICAgICAgc3RyaWN0OiB0aGlzLl9zdHJpY3QsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ04nLCAwLCAwLCAnZXJhQWJicicpO1xuICAgIGFkZEZvcm1hdFRva2VuKCdOTicsIDAsIDAsICdlcmFBYmJyJyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oJ05OTicsIDAsIDAsICdlcmFBYmJyJyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oJ05OTk4nLCAwLCAwLCAnZXJhTmFtZScpO1xuICAgIGFkZEZvcm1hdFRva2VuKCdOTk5OTicsIDAsIDAsICdlcmFOYXJyb3cnKTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCd5JywgWyd5JywgMV0sICd5bycsICdlcmFZZWFyJyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oJ3knLCBbJ3l5JywgMl0sIDAsICdlcmFZZWFyJyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oJ3knLCBbJ3l5eScsIDNdLCAwLCAnZXJhWWVhcicpO1xuICAgIGFkZEZvcm1hdFRva2VuKCd5JywgWyd5eXl5JywgNF0sIDAsICdlcmFZZWFyJyk7XG5cbiAgICBhZGRSZWdleFRva2VuKCdOJywgbWF0Y2hFcmFBYmJyKTtcbiAgICBhZGRSZWdleFRva2VuKCdOTicsIG1hdGNoRXJhQWJicik7XG4gICAgYWRkUmVnZXhUb2tlbignTk5OJywgbWF0Y2hFcmFBYmJyKTtcbiAgICBhZGRSZWdleFRva2VuKCdOTk5OJywgbWF0Y2hFcmFOYW1lKTtcbiAgICBhZGRSZWdleFRva2VuKCdOTk5OTicsIG1hdGNoRXJhTmFycm93KTtcblxuICAgIGFkZFBhcnNlVG9rZW4oWydOJywgJ05OJywgJ05OTicsICdOTk5OJywgJ05OTk5OJ10sIGZ1bmN0aW9uIChcbiAgICAgICAgaW5wdXQsXG4gICAgICAgIGFycmF5LFxuICAgICAgICBjb25maWcsXG4gICAgICAgIHRva2VuXG4gICAgKSB7XG4gICAgICAgIHZhciBlcmEgPSBjb25maWcuX2xvY2FsZS5lcmFzUGFyc2UoaW5wdXQsIHRva2VuLCBjb25maWcuX3N0cmljdCk7XG4gICAgICAgIGlmIChlcmEpIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmVyYSA9IGVyYTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmludmFsaWRFcmEgPSBpbnB1dDtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgYWRkUmVnZXhUb2tlbigneScsIG1hdGNoVW5zaWduZWQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ3l5JywgbWF0Y2hVbnNpZ25lZCk7XG4gICAgYWRkUmVnZXhUb2tlbigneXl5JywgbWF0Y2hVbnNpZ25lZCk7XG4gICAgYWRkUmVnZXhUb2tlbigneXl5eScsIG1hdGNoVW5zaWduZWQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ3lvJywgbWF0Y2hFcmFZZWFyT3JkaW5hbCk7XG5cbiAgICBhZGRQYXJzZVRva2VuKFsneScsICd5eScsICd5eXknLCAneXl5eSddLCBZRUFSKTtcbiAgICBhZGRQYXJzZVRva2VuKFsneW8nXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnLCB0b2tlbikge1xuICAgICAgICB2YXIgbWF0Y2g7XG4gICAgICAgIGlmIChjb25maWcuX2xvY2FsZS5fZXJhWWVhck9yZGluYWxSZWdleCkge1xuICAgICAgICAgICAgbWF0Y2ggPSBpbnB1dC5tYXRjaChjb25maWcuX2xvY2FsZS5fZXJhWWVhck9yZGluYWxSZWdleCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29uZmlnLl9sb2NhbGUuZXJhWWVhck9yZGluYWxQYXJzZSkge1xuICAgICAgICAgICAgYXJyYXlbWUVBUl0gPSBjb25maWcuX2xvY2FsZS5lcmFZZWFyT3JkaW5hbFBhcnNlKGlucHV0LCBtYXRjaCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhcnJheVtZRUFSXSA9IHBhcnNlSW50KGlucHV0LCAxMCk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIGxvY2FsZUVyYXMobSwgZm9ybWF0KSB7XG4gICAgICAgIHZhciBpLFxuICAgICAgICAgICAgbCxcbiAgICAgICAgICAgIGRhdGUsXG4gICAgICAgICAgICBlcmFzID0gdGhpcy5fZXJhcyB8fCBnZXRMb2NhbGUoJ2VuJykuX2VyYXM7XG4gICAgICAgIGZvciAoaSA9IDAsIGwgPSBlcmFzLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlb2YgZXJhc1tpXS5zaW5jZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICAgICAgICAgIC8vIHRydW5jYXRlIHRpbWVcbiAgICAgICAgICAgICAgICAgICAgZGF0ZSA9IGhvb2tzKGVyYXNbaV0uc2luY2UpLnN0YXJ0T2YoJ2RheScpO1xuICAgICAgICAgICAgICAgICAgICBlcmFzW2ldLnNpbmNlID0gZGF0ZS52YWx1ZU9mKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiBlcmFzW2ldLnVudGlsKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAndW5kZWZpbmVkJzpcbiAgICAgICAgICAgICAgICAgICAgZXJhc1tpXS51bnRpbCA9ICtJbmZpbml0eTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICAgICAgLy8gdHJ1bmNhdGUgdGltZVxuICAgICAgICAgICAgICAgICAgICBkYXRlID0gaG9va3MoZXJhc1tpXS51bnRpbCkuc3RhcnRPZignZGF5JykudmFsdWVPZigpO1xuICAgICAgICAgICAgICAgICAgICBlcmFzW2ldLnVudGlsID0gZGF0ZS52YWx1ZU9mKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlcmFzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvY2FsZUVyYXNQYXJzZShlcmFOYW1lLCBmb3JtYXQsIHN0cmljdCkge1xuICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgIGwsXG4gICAgICAgICAgICBlcmFzID0gdGhpcy5lcmFzKCksXG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgYWJicixcbiAgICAgICAgICAgIG5hcnJvdztcbiAgICAgICAgZXJhTmFtZSA9IGVyYU5hbWUudG9VcHBlckNhc2UoKTtcblxuICAgICAgICBmb3IgKGkgPSAwLCBsID0gZXJhcy5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgICAgIG5hbWUgPSBlcmFzW2ldLm5hbWUudG9VcHBlckNhc2UoKTtcbiAgICAgICAgICAgIGFiYnIgPSBlcmFzW2ldLmFiYnIudG9VcHBlckNhc2UoKTtcbiAgICAgICAgICAgIG5hcnJvdyA9IGVyYXNbaV0ubmFycm93LnRvVXBwZXJDYXNlKCk7XG5cbiAgICAgICAgICAgIGlmIChzdHJpY3QpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGZvcm1hdCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdOJzpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnTk4nOlxuICAgICAgICAgICAgICAgICAgICBjYXNlICdOTk4nOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFiYnIgPT09IGVyYU5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXJhc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ05OTk4nOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5hbWUgPT09IGVyYU5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXJhc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ05OTk5OJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuYXJyb3cgPT09IGVyYU5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXJhc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoW25hbWUsIGFiYnIsIG5hcnJvd10uaW5kZXhPZihlcmFOYW1lKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVyYXNbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb2NhbGVFcmFzQ29udmVydFllYXIoZXJhLCB5ZWFyKSB7XG4gICAgICAgIHZhciBkaXIgPSBlcmEuc2luY2UgPD0gZXJhLnVudGlsID8gKzEgOiAtMTtcbiAgICAgICAgaWYgKHllYXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGhvb2tzKGVyYS5zaW5jZSkueWVhcigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGhvb2tzKGVyYS5zaW5jZSkueWVhcigpICsgKHllYXIgLSBlcmEub2Zmc2V0KSAqIGRpcjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldEVyYU5hbWUoKSB7XG4gICAgICAgIHZhciBpLFxuICAgICAgICAgICAgbCxcbiAgICAgICAgICAgIHZhbCxcbiAgICAgICAgICAgIGVyYXMgPSB0aGlzLmxvY2FsZURhdGEoKS5lcmFzKCk7XG4gICAgICAgIGZvciAoaSA9IDAsIGwgPSBlcmFzLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgICAgICAgICAgLy8gdHJ1bmNhdGUgdGltZVxuICAgICAgICAgICAgdmFsID0gdGhpcy5jbG9uZSgpLnN0YXJ0T2YoJ2RheScpLnZhbHVlT2YoKTtcblxuICAgICAgICAgICAgaWYgKGVyYXNbaV0uc2luY2UgPD0gdmFsICYmIHZhbCA8PSBlcmFzW2ldLnVudGlsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVyYXNbaV0ubmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlcmFzW2ldLnVudGlsIDw9IHZhbCAmJiB2YWwgPD0gZXJhc1tpXS5zaW5jZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlcmFzW2ldLm5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0RXJhTmFycm93KCkge1xuICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgIGwsXG4gICAgICAgICAgICB2YWwsXG4gICAgICAgICAgICBlcmFzID0gdGhpcy5sb2NhbGVEYXRhKCkuZXJhcygpO1xuICAgICAgICBmb3IgKGkgPSAwLCBsID0gZXJhcy5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgICAgIC8vIHRydW5jYXRlIHRpbWVcbiAgICAgICAgICAgIHZhbCA9IHRoaXMuY2xvbmUoKS5zdGFydE9mKCdkYXknKS52YWx1ZU9mKCk7XG5cbiAgICAgICAgICAgIGlmIChlcmFzW2ldLnNpbmNlIDw9IHZhbCAmJiB2YWwgPD0gZXJhc1tpXS51bnRpbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlcmFzW2ldLm5hcnJvdztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlcmFzW2ldLnVudGlsIDw9IHZhbCAmJiB2YWwgPD0gZXJhc1tpXS5zaW5jZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlcmFzW2ldLm5hcnJvdztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRFcmFBYmJyKCkge1xuICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgIGwsXG4gICAgICAgICAgICB2YWwsXG4gICAgICAgICAgICBlcmFzID0gdGhpcy5sb2NhbGVEYXRhKCkuZXJhcygpO1xuICAgICAgICBmb3IgKGkgPSAwLCBsID0gZXJhcy5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgICAgIC8vIHRydW5jYXRlIHRpbWVcbiAgICAgICAgICAgIHZhbCA9IHRoaXMuY2xvbmUoKS5zdGFydE9mKCdkYXknKS52YWx1ZU9mKCk7XG5cbiAgICAgICAgICAgIGlmIChlcmFzW2ldLnNpbmNlIDw9IHZhbCAmJiB2YWwgPD0gZXJhc1tpXS51bnRpbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlcmFzW2ldLmFiYnI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXJhc1tpXS51bnRpbCA8PSB2YWwgJiYgdmFsIDw9IGVyYXNbaV0uc2luY2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXJhc1tpXS5hYmJyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldEVyYVllYXIoKSB7XG4gICAgICAgIHZhciBpLFxuICAgICAgICAgICAgbCxcbiAgICAgICAgICAgIGRpcixcbiAgICAgICAgICAgIHZhbCxcbiAgICAgICAgICAgIGVyYXMgPSB0aGlzLmxvY2FsZURhdGEoKS5lcmFzKCk7XG4gICAgICAgIGZvciAoaSA9IDAsIGwgPSBlcmFzLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgICAgICAgICAgZGlyID0gZXJhc1tpXS5zaW5jZSA8PSBlcmFzW2ldLnVudGlsID8gKzEgOiAtMTtcblxuICAgICAgICAgICAgLy8gdHJ1bmNhdGUgdGltZVxuICAgICAgICAgICAgdmFsID0gdGhpcy5jbG9uZSgpLnN0YXJ0T2YoJ2RheScpLnZhbHVlT2YoKTtcblxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIChlcmFzW2ldLnNpbmNlIDw9IHZhbCAmJiB2YWwgPD0gZXJhc1tpXS51bnRpbCkgfHxcbiAgICAgICAgICAgICAgICAoZXJhc1tpXS51bnRpbCA8PSB2YWwgJiYgdmFsIDw9IGVyYXNbaV0uc2luY2UpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgICAgICAodGhpcy55ZWFyKCkgLSBob29rcyhlcmFzW2ldLnNpbmNlKS55ZWFyKCkpICogZGlyICtcbiAgICAgICAgICAgICAgICAgICAgZXJhc1tpXS5vZmZzZXRcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMueWVhcigpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVyYXNOYW1lUmVnZXgoaXNTdHJpY3QpIHtcbiAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfZXJhc05hbWVSZWdleCcpKSB7XG4gICAgICAgICAgICBjb21wdXRlRXJhc1BhcnNlLmNhbGwodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlzU3RyaWN0ID8gdGhpcy5fZXJhc05hbWVSZWdleCA6IHRoaXMuX2VyYXNSZWdleDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlcmFzQWJiclJlZ2V4KGlzU3RyaWN0KSB7XG4gICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX2VyYXNBYmJyUmVnZXgnKSkge1xuICAgICAgICAgICAgY29tcHV0ZUVyYXNQYXJzZS5jYWxsKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpc1N0cmljdCA/IHRoaXMuX2VyYXNBYmJyUmVnZXggOiB0aGlzLl9lcmFzUmVnZXg7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXJhc05hcnJvd1JlZ2V4KGlzU3RyaWN0KSB7XG4gICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX2VyYXNOYXJyb3dSZWdleCcpKSB7XG4gICAgICAgICAgICBjb21wdXRlRXJhc1BhcnNlLmNhbGwodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlzU3RyaWN0ID8gdGhpcy5fZXJhc05hcnJvd1JlZ2V4IDogdGhpcy5fZXJhc1JlZ2V4O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1hdGNoRXJhQWJicihpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGUuZXJhc0FiYnJSZWdleChpc1N0cmljdCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWF0Y2hFcmFOYW1lKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZS5lcmFzTmFtZVJlZ2V4KGlzU3RyaWN0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYXRjaEVyYU5hcnJvdyhpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGUuZXJhc05hcnJvd1JlZ2V4KGlzU3RyaWN0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYXRjaEVyYVllYXJPcmRpbmFsKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZS5fZXJhWWVhck9yZGluYWxSZWdleCB8fCBtYXRjaFVuc2lnbmVkO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbXB1dGVFcmFzUGFyc2UoKSB7XG4gICAgICAgIHZhciBhYmJyUGllY2VzID0gW10sXG4gICAgICAgICAgICBuYW1lUGllY2VzID0gW10sXG4gICAgICAgICAgICBuYXJyb3dQaWVjZXMgPSBbXSxcbiAgICAgICAgICAgIG1peGVkUGllY2VzID0gW10sXG4gICAgICAgICAgICBpLFxuICAgICAgICAgICAgbCxcbiAgICAgICAgICAgIGVyYXMgPSB0aGlzLmVyYXMoKTtcblxuICAgICAgICBmb3IgKGkgPSAwLCBsID0gZXJhcy5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgICAgIG5hbWVQaWVjZXMucHVzaChyZWdleEVzY2FwZShlcmFzW2ldLm5hbWUpKTtcbiAgICAgICAgICAgIGFiYnJQaWVjZXMucHVzaChyZWdleEVzY2FwZShlcmFzW2ldLmFiYnIpKTtcbiAgICAgICAgICAgIG5hcnJvd1BpZWNlcy5wdXNoKHJlZ2V4RXNjYXBlKGVyYXNbaV0ubmFycm93KSk7XG5cbiAgICAgICAgICAgIG1peGVkUGllY2VzLnB1c2gocmVnZXhFc2NhcGUoZXJhc1tpXS5uYW1lKSk7XG4gICAgICAgICAgICBtaXhlZFBpZWNlcy5wdXNoKHJlZ2V4RXNjYXBlKGVyYXNbaV0uYWJicikpO1xuICAgICAgICAgICAgbWl4ZWRQaWVjZXMucHVzaChyZWdleEVzY2FwZShlcmFzW2ldLm5hcnJvdykpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fZXJhc1JlZ2V4ID0gbmV3IFJlZ0V4cCgnXignICsgbWl4ZWRQaWVjZXMuam9pbignfCcpICsgJyknLCAnaScpO1xuICAgICAgICB0aGlzLl9lcmFzTmFtZVJlZ2V4ID0gbmV3IFJlZ0V4cCgnXignICsgbmFtZVBpZWNlcy5qb2luKCd8JykgKyAnKScsICdpJyk7XG4gICAgICAgIHRoaXMuX2VyYXNBYmJyUmVnZXggPSBuZXcgUmVnRXhwKCdeKCcgKyBhYmJyUGllY2VzLmpvaW4oJ3wnKSArICcpJywgJ2knKTtcbiAgICAgICAgdGhpcy5fZXJhc05hcnJvd1JlZ2V4ID0gbmV3IFJlZ0V4cChcbiAgICAgICAgICAgICdeKCcgKyBuYXJyb3dQaWVjZXMuam9pbignfCcpICsgJyknLFxuICAgICAgICAgICAgJ2knXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydnZycsIDJdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndlZWtZZWFyKCkgJSAxMDA7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ0dHJywgMl0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNvV2Vla1llYXIoKSAlIDEwMDtcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIGFkZFdlZWtZZWFyRm9ybWF0VG9rZW4odG9rZW4sIGdldHRlcikge1xuICAgICAgICBhZGRGb3JtYXRUb2tlbigwLCBbdG9rZW4sIHRva2VuLmxlbmd0aF0sIDAsIGdldHRlcik7XG4gICAgfVxuXG4gICAgYWRkV2Vla1llYXJGb3JtYXRUb2tlbignZ2dnZycsICd3ZWVrWWVhcicpO1xuICAgIGFkZFdlZWtZZWFyRm9ybWF0VG9rZW4oJ2dnZ2dnJywgJ3dlZWtZZWFyJyk7XG4gICAgYWRkV2Vla1llYXJGb3JtYXRUb2tlbignR0dHRycsICdpc29XZWVrWWVhcicpO1xuICAgIGFkZFdlZWtZZWFyRm9ybWF0VG9rZW4oJ0dHR0dHJywgJ2lzb1dlZWtZZWFyJyk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ3dlZWtZZWFyJywgJ2dnJyk7XG4gICAgYWRkVW5pdEFsaWFzKCdpc29XZWVrWWVhcicsICdHRycpO1xuXG4gICAgLy8gUFJJT1JJVFlcblxuICAgIGFkZFVuaXRQcmlvcml0eSgnd2Vla1llYXInLCAxKTtcbiAgICBhZGRVbml0UHJpb3JpdHkoJ2lzb1dlZWtZZWFyJywgMSk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdHJywgbWF0Y2hTaWduZWQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2cnLCBtYXRjaFNpZ25lZCk7XG4gICAgYWRkUmVnZXhUb2tlbignR0cnLCBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgYWRkUmVnZXhUb2tlbignZ2cnLCBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgYWRkUmVnZXhUb2tlbignR0dHRycsIG1hdGNoMXRvNCwgbWF0Y2g0KTtcbiAgICBhZGRSZWdleFRva2VuKCdnZ2dnJywgbWF0Y2gxdG80LCBtYXRjaDQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0dHR0dHJywgbWF0Y2gxdG82LCBtYXRjaDYpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2dnZ2dnJywgbWF0Y2gxdG82LCBtYXRjaDYpO1xuXG4gICAgYWRkV2Vla1BhcnNlVG9rZW4oWydnZ2dnJywgJ2dnZ2dnJywgJ0dHR0cnLCAnR0dHR0cnXSwgZnVuY3Rpb24gKFxuICAgICAgICBpbnB1dCxcbiAgICAgICAgd2VlayxcbiAgICAgICAgY29uZmlnLFxuICAgICAgICB0b2tlblxuICAgICkge1xuICAgICAgICB3ZWVrW3Rva2VuLnN1YnN0cigwLCAyKV0gPSB0b0ludChpbnB1dCk7XG4gICAgfSk7XG5cbiAgICBhZGRXZWVrUGFyc2VUb2tlbihbJ2dnJywgJ0dHJ10sIGZ1bmN0aW9uIChpbnB1dCwgd2VlaywgY29uZmlnLCB0b2tlbikge1xuICAgICAgICB3ZWVrW3Rva2VuXSA9IGhvb2tzLnBhcnNlVHdvRGlnaXRZZWFyKGlucHV0KTtcbiAgICB9KTtcblxuICAgIC8vIE1PTUVOVFNcblxuICAgIGZ1bmN0aW9uIGdldFNldFdlZWtZZWFyKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBnZXRTZXRXZWVrWWVhckhlbHBlci5jYWxsKFxuICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgdGhpcy53ZWVrKCksXG4gICAgICAgICAgICB0aGlzLndlZWtkYXkoKSxcbiAgICAgICAgICAgIHRoaXMubG9jYWxlRGF0YSgpLl93ZWVrLmRvdyxcbiAgICAgICAgICAgIHRoaXMubG9jYWxlRGF0YSgpLl93ZWVrLmRveVxuICAgICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFNldElTT1dlZWtZZWFyKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBnZXRTZXRXZWVrWWVhckhlbHBlci5jYWxsKFxuICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgdGhpcy5pc29XZWVrKCksXG4gICAgICAgICAgICB0aGlzLmlzb1dlZWtkYXkoKSxcbiAgICAgICAgICAgIDEsXG4gICAgICAgICAgICA0XG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0SVNPV2Vla3NJblllYXIoKSB7XG4gICAgICAgIHJldHVybiB3ZWVrc0luWWVhcih0aGlzLnllYXIoKSwgMSwgNCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0SVNPV2Vla3NJbklTT1dlZWtZZWFyKCkge1xuICAgICAgICByZXR1cm4gd2Vla3NJblllYXIodGhpcy5pc29XZWVrWWVhcigpLCAxLCA0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRXZWVrc0luWWVhcigpIHtcbiAgICAgICAgdmFyIHdlZWtJbmZvID0gdGhpcy5sb2NhbGVEYXRhKCkuX3dlZWs7XG4gICAgICAgIHJldHVybiB3ZWVrc0luWWVhcih0aGlzLnllYXIoKSwgd2Vla0luZm8uZG93LCB3ZWVrSW5mby5kb3kpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFdlZWtzSW5XZWVrWWVhcigpIHtcbiAgICAgICAgdmFyIHdlZWtJbmZvID0gdGhpcy5sb2NhbGVEYXRhKCkuX3dlZWs7XG4gICAgICAgIHJldHVybiB3ZWVrc0luWWVhcih0aGlzLndlZWtZZWFyKCksIHdlZWtJbmZvLmRvdywgd2Vla0luZm8uZG95KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTZXRXZWVrWWVhckhlbHBlcihpbnB1dCwgd2Vlaywgd2Vla2RheSwgZG93LCBkb3kpIHtcbiAgICAgICAgdmFyIHdlZWtzVGFyZ2V0O1xuICAgICAgICBpZiAoaW5wdXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHdlZWtPZlllYXIodGhpcywgZG93LCBkb3kpLnllYXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB3ZWVrc1RhcmdldCA9IHdlZWtzSW5ZZWFyKGlucHV0LCBkb3csIGRveSk7XG4gICAgICAgICAgICBpZiAod2VlayA+IHdlZWtzVGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgd2VlayA9IHdlZWtzVGFyZ2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNldFdlZWtBbGwuY2FsbCh0aGlzLCBpbnB1dCwgd2Vlaywgd2Vla2RheSwgZG93LCBkb3kpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0V2Vla0FsbCh3ZWVrWWVhciwgd2Vlaywgd2Vla2RheSwgZG93LCBkb3kpIHtcbiAgICAgICAgdmFyIGRheU9mWWVhckRhdGEgPSBkYXlPZlllYXJGcm9tV2Vla3Mod2Vla1llYXIsIHdlZWssIHdlZWtkYXksIGRvdywgZG95KSxcbiAgICAgICAgICAgIGRhdGUgPSBjcmVhdGVVVENEYXRlKGRheU9mWWVhckRhdGEueWVhciwgMCwgZGF5T2ZZZWFyRGF0YS5kYXlPZlllYXIpO1xuXG4gICAgICAgIHRoaXMueWVhcihkYXRlLmdldFVUQ0Z1bGxZZWFyKCkpO1xuICAgICAgICB0aGlzLm1vbnRoKGRhdGUuZ2V0VVRDTW9udGgoKSk7XG4gICAgICAgIHRoaXMuZGF0ZShkYXRlLmdldFVUQ0RhdGUoKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCdRJywgMCwgJ1FvJywgJ3F1YXJ0ZXInKTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygncXVhcnRlcicsICdRJyk7XG5cbiAgICAvLyBQUklPUklUWVxuXG4gICAgYWRkVW5pdFByaW9yaXR5KCdxdWFydGVyJywgNyk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdRJywgbWF0Y2gxKTtcbiAgICBhZGRQYXJzZVRva2VuKCdRJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSkge1xuICAgICAgICBhcnJheVtNT05USF0gPSAodG9JbnQoaW5wdXQpIC0gMSkgKiAzO1xuICAgIH0pO1xuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgZnVuY3Rpb24gZ2V0U2V0UXVhcnRlcihpbnB1dCkge1xuICAgICAgICByZXR1cm4gaW5wdXQgPT0gbnVsbFxuICAgICAgICAgICAgPyBNYXRoLmNlaWwoKHRoaXMubW9udGgoKSArIDEpIC8gMylcbiAgICAgICAgICAgIDogdGhpcy5tb250aCgoaW5wdXQgLSAxKSAqIDMgKyAodGhpcy5tb250aCgpICUgMykpO1xuICAgIH1cblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCdEJywgWydERCcsIDJdLCAnRG8nLCAnZGF0ZScpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCdkYXRlJywgJ0QnKTtcblxuICAgIC8vIFBSSU9SSVRZXG4gICAgYWRkVW5pdFByaW9yaXR5KCdkYXRlJywgOSk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdEJywgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdERCcsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdEbycsIGZ1bmN0aW9uIChpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgICAgIC8vIFRPRE86IFJlbW92ZSBcIm9yZGluYWxQYXJzZVwiIGZhbGxiYWNrIGluIG5leHQgbWFqb3IgcmVsZWFzZS5cbiAgICAgICAgcmV0dXJuIGlzU3RyaWN0XG4gICAgICAgICAgICA/IGxvY2FsZS5fZGF5T2ZNb250aE9yZGluYWxQYXJzZSB8fCBsb2NhbGUuX29yZGluYWxQYXJzZVxuICAgICAgICAgICAgOiBsb2NhbGUuX2RheU9mTW9udGhPcmRpbmFsUGFyc2VMZW5pZW50O1xuICAgIH0pO1xuXG4gICAgYWRkUGFyc2VUb2tlbihbJ0QnLCAnREQnXSwgREFURSk7XG4gICAgYWRkUGFyc2VUb2tlbignRG8nLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgICAgIGFycmF5W0RBVEVdID0gdG9JbnQoaW5wdXQubWF0Y2gobWF0Y2gxdG8yKVswXSk7XG4gICAgfSk7XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICB2YXIgZ2V0U2V0RGF5T2ZNb250aCA9IG1ha2VHZXRTZXQoJ0RhdGUnLCB0cnVlKTtcblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCdEREQnLCBbJ0REREQnLCAzXSwgJ0RERG8nLCAnZGF5T2ZZZWFyJyk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ2RheU9mWWVhcicsICdEREQnKTtcblxuICAgIC8vIFBSSU9SSVRZXG4gICAgYWRkVW5pdFByaW9yaXR5KCdkYXlPZlllYXInLCA0KTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ0RERCcsIG1hdGNoMXRvMyk7XG4gICAgYWRkUmVnZXhUb2tlbignRERERCcsIG1hdGNoMyk7XG4gICAgYWRkUGFyc2VUb2tlbihbJ0RERCcsICdEREREJ10sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICBjb25maWcuX2RheU9mWWVhciA9IHRvSW50KGlucHV0KTtcbiAgICB9KTtcblxuICAgIC8vIEhFTFBFUlNcblxuICAgIC8vIE1PTUVOVFNcblxuICAgIGZ1bmN0aW9uIGdldFNldERheU9mWWVhcihpbnB1dCkge1xuICAgICAgICB2YXIgZGF5T2ZZZWFyID1cbiAgICAgICAgICAgIE1hdGgucm91bmQoXG4gICAgICAgICAgICAgICAgKHRoaXMuY2xvbmUoKS5zdGFydE9mKCdkYXknKSAtIHRoaXMuY2xvbmUoKS5zdGFydE9mKCd5ZWFyJykpIC8gODY0ZTVcbiAgICAgICAgICAgICkgKyAxO1xuICAgICAgICByZXR1cm4gaW5wdXQgPT0gbnVsbCA/IGRheU9mWWVhciA6IHRoaXMuYWRkKGlucHV0IC0gZGF5T2ZZZWFyLCAnZCcpO1xuICAgIH1cblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCdtJywgWydtbScsIDJdLCAwLCAnbWludXRlJyk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ21pbnV0ZScsICdtJyk7XG5cbiAgICAvLyBQUklPUklUWVxuXG4gICAgYWRkVW5pdFByaW9yaXR5KCdtaW51dGUnLCAxNCk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdtJywgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdtbScsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRQYXJzZVRva2VuKFsnbScsICdtbSddLCBNSU5VVEUpO1xuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgdmFyIGdldFNldE1pbnV0ZSA9IG1ha2VHZXRTZXQoJ01pbnV0ZXMnLCBmYWxzZSk7XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbigncycsIFsnc3MnLCAyXSwgMCwgJ3NlY29uZCcpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCdzZWNvbmQnLCAncycpO1xuXG4gICAgLy8gUFJJT1JJVFlcblxuICAgIGFkZFVuaXRQcmlvcml0eSgnc2Vjb25kJywgMTUpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbigncycsIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignc3MnLCBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgYWRkUGFyc2VUb2tlbihbJ3MnLCAnc3MnXSwgU0VDT05EKTtcblxuICAgIC8vIE1PTUVOVFNcblxuICAgIHZhciBnZXRTZXRTZWNvbmQgPSBtYWtlR2V0U2V0KCdTZWNvbmRzJywgZmFsc2UpO1xuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ1MnLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB+fih0aGlzLm1pbGxpc2Vjb25kKCkgLyAxMDApO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTUycsIDJdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB+fih0aGlzLm1pbGxpc2Vjb25kKCkgLyAxMCk7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1NTUycsIDNdLCAwLCAnbWlsbGlzZWNvbmQnKTtcbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1NTU1MnLCA0XSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZCgpICogMTA7XG4gICAgfSk7XG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTUycsIDVdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbGxpc2Vjb25kKCkgKiAxMDA7XG4gICAgfSk7XG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTU1MnLCA2XSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZCgpICogMTAwMDtcbiAgICB9KTtcbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1NTU1NTU1MnLCA3XSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZCgpICogMTAwMDA7XG4gICAgfSk7XG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTU1NTUycsIDhdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbGxpc2Vjb25kKCkgKiAxMDAwMDA7XG4gICAgfSk7XG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTU1NTU1MnLCA5XSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZCgpICogMTAwMDAwMDtcbiAgICB9KTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygnbWlsbGlzZWNvbmQnLCAnbXMnKTtcblxuICAgIC8vIFBSSU9SSVRZXG5cbiAgICBhZGRVbml0UHJpb3JpdHkoJ21pbGxpc2Vjb25kJywgMTYpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignUycsIG1hdGNoMXRvMywgbWF0Y2gxKTtcbiAgICBhZGRSZWdleFRva2VuKCdTUycsIG1hdGNoMXRvMywgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdTU1MnLCBtYXRjaDF0bzMsIG1hdGNoMyk7XG5cbiAgICB2YXIgdG9rZW4sIGdldFNldE1pbGxpc2Vjb25kO1xuICAgIGZvciAodG9rZW4gPSAnU1NTUyc7IHRva2VuLmxlbmd0aCA8PSA5OyB0b2tlbiArPSAnUycpIHtcbiAgICAgICAgYWRkUmVnZXhUb2tlbih0b2tlbiwgbWF0Y2hVbnNpZ25lZCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VNcyhpbnB1dCwgYXJyYXkpIHtcbiAgICAgICAgYXJyYXlbTUlMTElTRUNPTkRdID0gdG9JbnQoKCcwLicgKyBpbnB1dCkgKiAxMDAwKTtcbiAgICB9XG5cbiAgICBmb3IgKHRva2VuID0gJ1MnOyB0b2tlbi5sZW5ndGggPD0gOTsgdG9rZW4gKz0gJ1MnKSB7XG4gICAgICAgIGFkZFBhcnNlVG9rZW4odG9rZW4sIHBhcnNlTXMpO1xuICAgIH1cblxuICAgIGdldFNldE1pbGxpc2Vjb25kID0gbWFrZUdldFNldCgnTWlsbGlzZWNvbmRzJywgZmFsc2UpO1xuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ3onLCAwLCAwLCAnem9uZUFiYnInKTtcbiAgICBhZGRGb3JtYXRUb2tlbignenonLCAwLCAwLCAnem9uZU5hbWUnKTtcblxuICAgIC8vIE1PTUVOVFNcblxuICAgIGZ1bmN0aW9uIGdldFpvbmVBYmJyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNVVEMgPyAnVVRDJyA6ICcnO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFpvbmVOYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNVVEMgPyAnQ29vcmRpbmF0ZWQgVW5pdmVyc2FsIFRpbWUnIDogJyc7XG4gICAgfVxuXG4gICAgdmFyIHByb3RvID0gTW9tZW50LnByb3RvdHlwZTtcblxuICAgIHByb3RvLmFkZCA9IGFkZDtcbiAgICBwcm90by5jYWxlbmRhciA9IGNhbGVuZGFyJDE7XG4gICAgcHJvdG8uY2xvbmUgPSBjbG9uZTtcbiAgICBwcm90by5kaWZmID0gZGlmZjtcbiAgICBwcm90by5lbmRPZiA9IGVuZE9mO1xuICAgIHByb3RvLmZvcm1hdCA9IGZvcm1hdDtcbiAgICBwcm90by5mcm9tID0gZnJvbTtcbiAgICBwcm90by5mcm9tTm93ID0gZnJvbU5vdztcbiAgICBwcm90by50byA9IHRvO1xuICAgIHByb3RvLnRvTm93ID0gdG9Ob3c7XG4gICAgcHJvdG8uZ2V0ID0gc3RyaW5nR2V0O1xuICAgIHByb3RvLmludmFsaWRBdCA9IGludmFsaWRBdDtcbiAgICBwcm90by5pc0FmdGVyID0gaXNBZnRlcjtcbiAgICBwcm90by5pc0JlZm9yZSA9IGlzQmVmb3JlO1xuICAgIHByb3RvLmlzQmV0d2VlbiA9IGlzQmV0d2VlbjtcbiAgICBwcm90by5pc1NhbWUgPSBpc1NhbWU7XG4gICAgcHJvdG8uaXNTYW1lT3JBZnRlciA9IGlzU2FtZU9yQWZ0ZXI7XG4gICAgcHJvdG8uaXNTYW1lT3JCZWZvcmUgPSBpc1NhbWVPckJlZm9yZTtcbiAgICBwcm90by5pc1ZhbGlkID0gaXNWYWxpZCQyO1xuICAgIHByb3RvLmxhbmcgPSBsYW5nO1xuICAgIHByb3RvLmxvY2FsZSA9IGxvY2FsZTtcbiAgICBwcm90by5sb2NhbGVEYXRhID0gbG9jYWxlRGF0YTtcbiAgICBwcm90by5tYXggPSBwcm90b3R5cGVNYXg7XG4gICAgcHJvdG8ubWluID0gcHJvdG90eXBlTWluO1xuICAgIHByb3RvLnBhcnNpbmdGbGFncyA9IHBhcnNpbmdGbGFncztcbiAgICBwcm90by5zZXQgPSBzdHJpbmdTZXQ7XG4gICAgcHJvdG8uc3RhcnRPZiA9IHN0YXJ0T2Y7XG4gICAgcHJvdG8uc3VidHJhY3QgPSBzdWJ0cmFjdDtcbiAgICBwcm90by50b0FycmF5ID0gdG9BcnJheTtcbiAgICBwcm90by50b09iamVjdCA9IHRvT2JqZWN0O1xuICAgIHByb3RvLnRvRGF0ZSA9IHRvRGF0ZTtcbiAgICBwcm90by50b0lTT1N0cmluZyA9IHRvSVNPU3RyaW5nO1xuICAgIHByb3RvLmluc3BlY3QgPSBpbnNwZWN0O1xuICAgIGlmICh0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wuZm9yICE9IG51bGwpIHtcbiAgICAgICAgcHJvdG9bU3ltYm9sLmZvcignbm9kZWpzLnV0aWwuaW5zcGVjdC5jdXN0b20nKV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gJ01vbWVudDwnICsgdGhpcy5mb3JtYXQoKSArICc+JztcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcHJvdG8udG9KU09OID0gdG9KU09OO1xuICAgIHByb3RvLnRvU3RyaW5nID0gdG9TdHJpbmc7XG4gICAgcHJvdG8udW5peCA9IHVuaXg7XG4gICAgcHJvdG8udmFsdWVPZiA9IHZhbHVlT2Y7XG4gICAgcHJvdG8uY3JlYXRpb25EYXRhID0gY3JlYXRpb25EYXRhO1xuICAgIHByb3RvLmVyYU5hbWUgPSBnZXRFcmFOYW1lO1xuICAgIHByb3RvLmVyYU5hcnJvdyA9IGdldEVyYU5hcnJvdztcbiAgICBwcm90by5lcmFBYmJyID0gZ2V0RXJhQWJicjtcbiAgICBwcm90by5lcmFZZWFyID0gZ2V0RXJhWWVhcjtcbiAgICBwcm90by55ZWFyID0gZ2V0U2V0WWVhcjtcbiAgICBwcm90by5pc0xlYXBZZWFyID0gZ2V0SXNMZWFwWWVhcjtcbiAgICBwcm90by53ZWVrWWVhciA9IGdldFNldFdlZWtZZWFyO1xuICAgIHByb3RvLmlzb1dlZWtZZWFyID0gZ2V0U2V0SVNPV2Vla1llYXI7XG4gICAgcHJvdG8ucXVhcnRlciA9IHByb3RvLnF1YXJ0ZXJzID0gZ2V0U2V0UXVhcnRlcjtcbiAgICBwcm90by5tb250aCA9IGdldFNldE1vbnRoO1xuICAgIHByb3RvLmRheXNJbk1vbnRoID0gZ2V0RGF5c0luTW9udGg7XG4gICAgcHJvdG8ud2VlayA9IHByb3RvLndlZWtzID0gZ2V0U2V0V2VlaztcbiAgICBwcm90by5pc29XZWVrID0gcHJvdG8uaXNvV2Vla3MgPSBnZXRTZXRJU09XZWVrO1xuICAgIHByb3RvLndlZWtzSW5ZZWFyID0gZ2V0V2Vla3NJblllYXI7XG4gICAgcHJvdG8ud2Vla3NJbldlZWtZZWFyID0gZ2V0V2Vla3NJbldlZWtZZWFyO1xuICAgIHByb3RvLmlzb1dlZWtzSW5ZZWFyID0gZ2V0SVNPV2Vla3NJblllYXI7XG4gICAgcHJvdG8uaXNvV2Vla3NJbklTT1dlZWtZZWFyID0gZ2V0SVNPV2Vla3NJbklTT1dlZWtZZWFyO1xuICAgIHByb3RvLmRhdGUgPSBnZXRTZXREYXlPZk1vbnRoO1xuICAgIHByb3RvLmRheSA9IHByb3RvLmRheXMgPSBnZXRTZXREYXlPZldlZWs7XG4gICAgcHJvdG8ud2Vla2RheSA9IGdldFNldExvY2FsZURheU9mV2VlaztcbiAgICBwcm90by5pc29XZWVrZGF5ID0gZ2V0U2V0SVNPRGF5T2ZXZWVrO1xuICAgIHByb3RvLmRheU9mWWVhciA9IGdldFNldERheU9mWWVhcjtcbiAgICBwcm90by5ob3VyID0gcHJvdG8uaG91cnMgPSBnZXRTZXRIb3VyO1xuICAgIHByb3RvLm1pbnV0ZSA9IHByb3RvLm1pbnV0ZXMgPSBnZXRTZXRNaW51dGU7XG4gICAgcHJvdG8uc2Vjb25kID0gcHJvdG8uc2Vjb25kcyA9IGdldFNldFNlY29uZDtcbiAgICBwcm90by5taWxsaXNlY29uZCA9IHByb3RvLm1pbGxpc2Vjb25kcyA9IGdldFNldE1pbGxpc2Vjb25kO1xuICAgIHByb3RvLnV0Y09mZnNldCA9IGdldFNldE9mZnNldDtcbiAgICBwcm90by51dGMgPSBzZXRPZmZzZXRUb1VUQztcbiAgICBwcm90by5sb2NhbCA9IHNldE9mZnNldFRvTG9jYWw7XG4gICAgcHJvdG8ucGFyc2Vab25lID0gc2V0T2Zmc2V0VG9QYXJzZWRPZmZzZXQ7XG4gICAgcHJvdG8uaGFzQWxpZ25lZEhvdXJPZmZzZXQgPSBoYXNBbGlnbmVkSG91ck9mZnNldDtcbiAgICBwcm90by5pc0RTVCA9IGlzRGF5bGlnaHRTYXZpbmdUaW1lO1xuICAgIHByb3RvLmlzTG9jYWwgPSBpc0xvY2FsO1xuICAgIHByb3RvLmlzVXRjT2Zmc2V0ID0gaXNVdGNPZmZzZXQ7XG4gICAgcHJvdG8uaXNVdGMgPSBpc1V0YztcbiAgICBwcm90by5pc1VUQyA9IGlzVXRjO1xuICAgIHByb3RvLnpvbmVBYmJyID0gZ2V0Wm9uZUFiYnI7XG4gICAgcHJvdG8uem9uZU5hbWUgPSBnZXRab25lTmFtZTtcbiAgICBwcm90by5kYXRlcyA9IGRlcHJlY2F0ZShcbiAgICAgICAgJ2RhdGVzIGFjY2Vzc29yIGlzIGRlcHJlY2F0ZWQuIFVzZSBkYXRlIGluc3RlYWQuJyxcbiAgICAgICAgZ2V0U2V0RGF5T2ZNb250aFxuICAgICk7XG4gICAgcHJvdG8ubW9udGhzID0gZGVwcmVjYXRlKFxuICAgICAgICAnbW9udGhzIGFjY2Vzc29yIGlzIGRlcHJlY2F0ZWQuIFVzZSBtb250aCBpbnN0ZWFkJyxcbiAgICAgICAgZ2V0U2V0TW9udGhcbiAgICApO1xuICAgIHByb3RvLnllYXJzID0gZGVwcmVjYXRlKFxuICAgICAgICAneWVhcnMgYWNjZXNzb3IgaXMgZGVwcmVjYXRlZC4gVXNlIHllYXIgaW5zdGVhZCcsXG4gICAgICAgIGdldFNldFllYXJcbiAgICApO1xuICAgIHByb3RvLnpvbmUgPSBkZXByZWNhdGUoXG4gICAgICAgICdtb21lbnQoKS56b25lIGlzIGRlcHJlY2F0ZWQsIHVzZSBtb21lbnQoKS51dGNPZmZzZXQgaW5zdGVhZC4gaHR0cDovL21vbWVudGpzLmNvbS9ndWlkZXMvIy93YXJuaW5ncy96b25lLycsXG4gICAgICAgIGdldFNldFpvbmVcbiAgICApO1xuICAgIHByb3RvLmlzRFNUU2hpZnRlZCA9IGRlcHJlY2F0ZShcbiAgICAgICAgJ2lzRFNUU2hpZnRlZCBpcyBkZXByZWNhdGVkLiBTZWUgaHR0cDovL21vbWVudGpzLmNvbS9ndWlkZXMvIy93YXJuaW5ncy9kc3Qtc2hpZnRlZC8gZm9yIG1vcmUgaW5mb3JtYXRpb24nLFxuICAgICAgICBpc0RheWxpZ2h0U2F2aW5nVGltZVNoaWZ0ZWRcbiAgICApO1xuXG4gICAgZnVuY3Rpb24gY3JlYXRlVW5peChpbnB1dCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlTG9jYWwoaW5wdXQgKiAxMDAwKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVJblpvbmUoKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVMb2NhbC5hcHBseShudWxsLCBhcmd1bWVudHMpLnBhcnNlWm9uZSgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHByZVBhcnNlUG9zdEZvcm1hdChzdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICB9XG5cbiAgICB2YXIgcHJvdG8kMSA9IExvY2FsZS5wcm90b3R5cGU7XG5cbiAgICBwcm90byQxLmNhbGVuZGFyID0gY2FsZW5kYXI7XG4gICAgcHJvdG8kMS5sb25nRGF0ZUZvcm1hdCA9IGxvbmdEYXRlRm9ybWF0O1xuICAgIHByb3RvJDEuaW52YWxpZERhdGUgPSBpbnZhbGlkRGF0ZTtcbiAgICBwcm90byQxLm9yZGluYWwgPSBvcmRpbmFsO1xuICAgIHByb3RvJDEucHJlcGFyc2UgPSBwcmVQYXJzZVBvc3RGb3JtYXQ7XG4gICAgcHJvdG8kMS5wb3N0Zm9ybWF0ID0gcHJlUGFyc2VQb3N0Rm9ybWF0O1xuICAgIHByb3RvJDEucmVsYXRpdmVUaW1lID0gcmVsYXRpdmVUaW1lO1xuICAgIHByb3RvJDEucGFzdEZ1dHVyZSA9IHBhc3RGdXR1cmU7XG4gICAgcHJvdG8kMS5zZXQgPSBzZXQ7XG4gICAgcHJvdG8kMS5lcmFzID0gbG9jYWxlRXJhcztcbiAgICBwcm90byQxLmVyYXNQYXJzZSA9IGxvY2FsZUVyYXNQYXJzZTtcbiAgICBwcm90byQxLmVyYXNDb252ZXJ0WWVhciA9IGxvY2FsZUVyYXNDb252ZXJ0WWVhcjtcbiAgICBwcm90byQxLmVyYXNBYmJyUmVnZXggPSBlcmFzQWJiclJlZ2V4O1xuICAgIHByb3RvJDEuZXJhc05hbWVSZWdleCA9IGVyYXNOYW1lUmVnZXg7XG4gICAgcHJvdG8kMS5lcmFzTmFycm93UmVnZXggPSBlcmFzTmFycm93UmVnZXg7XG5cbiAgICBwcm90byQxLm1vbnRocyA9IGxvY2FsZU1vbnRocztcbiAgICBwcm90byQxLm1vbnRoc1Nob3J0ID0gbG9jYWxlTW9udGhzU2hvcnQ7XG4gICAgcHJvdG8kMS5tb250aHNQYXJzZSA9IGxvY2FsZU1vbnRoc1BhcnNlO1xuICAgIHByb3RvJDEubW9udGhzUmVnZXggPSBtb250aHNSZWdleDtcbiAgICBwcm90byQxLm1vbnRoc1Nob3J0UmVnZXggPSBtb250aHNTaG9ydFJlZ2V4O1xuICAgIHByb3RvJDEud2VlayA9IGxvY2FsZVdlZWs7XG4gICAgcHJvdG8kMS5maXJzdERheU9mWWVhciA9IGxvY2FsZUZpcnN0RGF5T2ZZZWFyO1xuICAgIHByb3RvJDEuZmlyc3REYXlPZldlZWsgPSBsb2NhbGVGaXJzdERheU9mV2VlaztcblxuICAgIHByb3RvJDEud2Vla2RheXMgPSBsb2NhbGVXZWVrZGF5cztcbiAgICBwcm90byQxLndlZWtkYXlzTWluID0gbG9jYWxlV2Vla2RheXNNaW47XG4gICAgcHJvdG8kMS53ZWVrZGF5c1Nob3J0ID0gbG9jYWxlV2Vla2RheXNTaG9ydDtcbiAgICBwcm90byQxLndlZWtkYXlzUGFyc2UgPSBsb2NhbGVXZWVrZGF5c1BhcnNlO1xuXG4gICAgcHJvdG8kMS53ZWVrZGF5c1JlZ2V4ID0gd2Vla2RheXNSZWdleDtcbiAgICBwcm90byQxLndlZWtkYXlzU2hvcnRSZWdleCA9IHdlZWtkYXlzU2hvcnRSZWdleDtcbiAgICBwcm90byQxLndlZWtkYXlzTWluUmVnZXggPSB3ZWVrZGF5c01pblJlZ2V4O1xuXG4gICAgcHJvdG8kMS5pc1BNID0gbG9jYWxlSXNQTTtcbiAgICBwcm90byQxLm1lcmlkaWVtID0gbG9jYWxlTWVyaWRpZW07XG5cbiAgICBmdW5jdGlvbiBnZXQkMShmb3JtYXQsIGluZGV4LCBmaWVsZCwgc2V0dGVyKSB7XG4gICAgICAgIHZhciBsb2NhbGUgPSBnZXRMb2NhbGUoKSxcbiAgICAgICAgICAgIHV0YyA9IGNyZWF0ZVVUQygpLnNldChzZXR0ZXIsIGluZGV4KTtcbiAgICAgICAgcmV0dXJuIGxvY2FsZVtmaWVsZF0odXRjLCBmb3JtYXQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpc3RNb250aHNJbXBsKGZvcm1hdCwgaW5kZXgsIGZpZWxkKSB7XG4gICAgICAgIGlmIChpc051bWJlcihmb3JtYXQpKSB7XG4gICAgICAgICAgICBpbmRleCA9IGZvcm1hdDtcbiAgICAgICAgICAgIGZvcm1hdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvcm1hdCA9IGZvcm1hdCB8fCAnJztcblxuICAgICAgICBpZiAoaW5kZXggIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGdldCQxKGZvcm1hdCwgaW5kZXgsIGZpZWxkLCAnbW9udGgnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpLFxuICAgICAgICAgICAgb3V0ID0gW107XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCAxMjsgaSsrKSB7XG4gICAgICAgICAgICBvdXRbaV0gPSBnZXQkMShmb3JtYXQsIGksIGZpZWxkLCAnbW9udGgnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cblxuICAgIC8vICgpXG4gICAgLy8gKDUpXG4gICAgLy8gKGZtdCwgNSlcbiAgICAvLyAoZm10KVxuICAgIC8vICh0cnVlKVxuICAgIC8vICh0cnVlLCA1KVxuICAgIC8vICh0cnVlLCBmbXQsIDUpXG4gICAgLy8gKHRydWUsIGZtdClcbiAgICBmdW5jdGlvbiBsaXN0V2Vla2RheXNJbXBsKGxvY2FsZVNvcnRlZCwgZm9ybWF0LCBpbmRleCwgZmllbGQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBsb2NhbGVTb3J0ZWQgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgaWYgKGlzTnVtYmVyKGZvcm1hdCkpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IGZvcm1hdDtcbiAgICAgICAgICAgICAgICBmb3JtYXQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvcm1hdCA9IGZvcm1hdCB8fCAnJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvcm1hdCA9IGxvY2FsZVNvcnRlZDtcbiAgICAgICAgICAgIGluZGV4ID0gZm9ybWF0O1xuICAgICAgICAgICAgbG9jYWxlU29ydGVkID0gZmFsc2U7XG5cbiAgICAgICAgICAgIGlmIChpc051bWJlcihmb3JtYXQpKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBmb3JtYXQ7XG4gICAgICAgICAgICAgICAgZm9ybWF0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3JtYXQgPSBmb3JtYXQgfHwgJyc7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbG9jYWxlID0gZ2V0TG9jYWxlKCksXG4gICAgICAgICAgICBzaGlmdCA9IGxvY2FsZVNvcnRlZCA/IGxvY2FsZS5fd2Vlay5kb3cgOiAwLFxuICAgICAgICAgICAgaSxcbiAgICAgICAgICAgIG91dCA9IFtdO1xuXG4gICAgICAgIGlmIChpbmRleCAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0JDEoZm9ybWF0LCAoaW5kZXggKyBzaGlmdCkgJSA3LCBmaWVsZCwgJ2RheScpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDc7IGkrKykge1xuICAgICAgICAgICAgb3V0W2ldID0gZ2V0JDEoZm9ybWF0LCAoaSArIHNoaWZ0KSAlIDcsIGZpZWxkLCAnZGF5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaXN0TW9udGhzKGZvcm1hdCwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGxpc3RNb250aHNJbXBsKGZvcm1hdCwgaW5kZXgsICdtb250aHMnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaXN0TW9udGhzU2hvcnQoZm9ybWF0LCBpbmRleCkge1xuICAgICAgICByZXR1cm4gbGlzdE1vbnRoc0ltcGwoZm9ybWF0LCBpbmRleCwgJ21vbnRoc1Nob3J0Jyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGlzdFdlZWtkYXlzKGxvY2FsZVNvcnRlZCwgZm9ybWF0LCBpbmRleCkge1xuICAgICAgICByZXR1cm4gbGlzdFdlZWtkYXlzSW1wbChsb2NhbGVTb3J0ZWQsIGZvcm1hdCwgaW5kZXgsICd3ZWVrZGF5cycpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpc3RXZWVrZGF5c1Nob3J0KGxvY2FsZVNvcnRlZCwgZm9ybWF0LCBpbmRleCkge1xuICAgICAgICByZXR1cm4gbGlzdFdlZWtkYXlzSW1wbChsb2NhbGVTb3J0ZWQsIGZvcm1hdCwgaW5kZXgsICd3ZWVrZGF5c1Nob3J0Jyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGlzdFdlZWtkYXlzTWluKGxvY2FsZVNvcnRlZCwgZm9ybWF0LCBpbmRleCkge1xuICAgICAgICByZXR1cm4gbGlzdFdlZWtkYXlzSW1wbChsb2NhbGVTb3J0ZWQsIGZvcm1hdCwgaW5kZXgsICd3ZWVrZGF5c01pbicpO1xuICAgIH1cblxuICAgIGdldFNldEdsb2JhbExvY2FsZSgnZW4nLCB7XG4gICAgICAgIGVyYXM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzaW5jZTogJzAwMDEtMDEtMDEnLFxuICAgICAgICAgICAgICAgIHVudGlsOiArSW5maW5pdHksXG4gICAgICAgICAgICAgICAgb2Zmc2V0OiAxLFxuICAgICAgICAgICAgICAgIG5hbWU6ICdBbm5vIERvbWluaScsXG4gICAgICAgICAgICAgICAgbmFycm93OiAnQUQnLFxuICAgICAgICAgICAgICAgIGFiYnI6ICdBRCcsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHNpbmNlOiAnMDAwMC0xMi0zMScsXG4gICAgICAgICAgICAgICAgdW50aWw6IC1JbmZpbml0eSxcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IDEsXG4gICAgICAgICAgICAgICAgbmFtZTogJ0JlZm9yZSBDaHJpc3QnLFxuICAgICAgICAgICAgICAgIG5hcnJvdzogJ0JDJyxcbiAgICAgICAgICAgICAgICBhYmJyOiAnQkMnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICAgICAgZGF5T2ZNb250aE9yZGluYWxQYXJzZTogL1xcZHsxLDJ9KHRofHN0fG5kfHJkKS8sXG4gICAgICAgIG9yZGluYWw6IGZ1bmN0aW9uIChudW1iZXIpIHtcbiAgICAgICAgICAgIHZhciBiID0gbnVtYmVyICUgMTAsXG4gICAgICAgICAgICAgICAgb3V0cHV0ID1cbiAgICAgICAgICAgICAgICAgICAgdG9JbnQoKG51bWJlciAlIDEwMCkgLyAxMCkgPT09IDFcbiAgICAgICAgICAgICAgICAgICAgICAgID8gJ3RoJ1xuICAgICAgICAgICAgICAgICAgICAgICAgOiBiID09PSAxXG4gICAgICAgICAgICAgICAgICAgICAgICA/ICdzdCdcbiAgICAgICAgICAgICAgICAgICAgICAgIDogYiA9PT0gMlxuICAgICAgICAgICAgICAgICAgICAgICAgPyAnbmQnXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGIgPT09IDNcbiAgICAgICAgICAgICAgICAgICAgICAgID8gJ3JkJ1xuICAgICAgICAgICAgICAgICAgICAgICAgOiAndGgnO1xuICAgICAgICAgICAgcmV0dXJuIG51bWJlciArIG91dHB1dDtcbiAgICAgICAgfSxcbiAgICB9KTtcblxuICAgIC8vIFNpZGUgZWZmZWN0IGltcG9ydHNcblxuICAgIGhvb2tzLmxhbmcgPSBkZXByZWNhdGUoXG4gICAgICAgICdtb21lbnQubGFuZyBpcyBkZXByZWNhdGVkLiBVc2UgbW9tZW50LmxvY2FsZSBpbnN0ZWFkLicsXG4gICAgICAgIGdldFNldEdsb2JhbExvY2FsZVxuICAgICk7XG4gICAgaG9va3MubGFuZ0RhdGEgPSBkZXByZWNhdGUoXG4gICAgICAgICdtb21lbnQubGFuZ0RhdGEgaXMgZGVwcmVjYXRlZC4gVXNlIG1vbWVudC5sb2NhbGVEYXRhIGluc3RlYWQuJyxcbiAgICAgICAgZ2V0TG9jYWxlXG4gICAgKTtcblxuICAgIHZhciBtYXRoQWJzID0gTWF0aC5hYnM7XG5cbiAgICBmdW5jdGlvbiBhYnMoKSB7XG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5fZGF0YTtcblxuICAgICAgICB0aGlzLl9taWxsaXNlY29uZHMgPSBtYXRoQWJzKHRoaXMuX21pbGxpc2Vjb25kcyk7XG4gICAgICAgIHRoaXMuX2RheXMgPSBtYXRoQWJzKHRoaXMuX2RheXMpO1xuICAgICAgICB0aGlzLl9tb250aHMgPSBtYXRoQWJzKHRoaXMuX21vbnRocyk7XG5cbiAgICAgICAgZGF0YS5taWxsaXNlY29uZHMgPSBtYXRoQWJzKGRhdGEubWlsbGlzZWNvbmRzKTtcbiAgICAgICAgZGF0YS5zZWNvbmRzID0gbWF0aEFicyhkYXRhLnNlY29uZHMpO1xuICAgICAgICBkYXRhLm1pbnV0ZXMgPSBtYXRoQWJzKGRhdGEubWludXRlcyk7XG4gICAgICAgIGRhdGEuaG91cnMgPSBtYXRoQWJzKGRhdGEuaG91cnMpO1xuICAgICAgICBkYXRhLm1vbnRocyA9IG1hdGhBYnMoZGF0YS5tb250aHMpO1xuICAgICAgICBkYXRhLnllYXJzID0gbWF0aEFicyhkYXRhLnllYXJzKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRTdWJ0cmFjdCQxKGR1cmF0aW9uLCBpbnB1dCwgdmFsdWUsIGRpcmVjdGlvbikge1xuICAgICAgICB2YXIgb3RoZXIgPSBjcmVhdGVEdXJhdGlvbihpbnB1dCwgdmFsdWUpO1xuXG4gICAgICAgIGR1cmF0aW9uLl9taWxsaXNlY29uZHMgKz0gZGlyZWN0aW9uICogb3RoZXIuX21pbGxpc2Vjb25kcztcbiAgICAgICAgZHVyYXRpb24uX2RheXMgKz0gZGlyZWN0aW9uICogb3RoZXIuX2RheXM7XG4gICAgICAgIGR1cmF0aW9uLl9tb250aHMgKz0gZGlyZWN0aW9uICogb3RoZXIuX21vbnRocztcblxuICAgICAgICByZXR1cm4gZHVyYXRpb24uX2J1YmJsZSgpO1xuICAgIH1cblxuICAgIC8vIHN1cHBvcnRzIG9ubHkgMi4wLXN0eWxlIGFkZCgxLCAncycpIG9yIGFkZChkdXJhdGlvbilcbiAgICBmdW5jdGlvbiBhZGQkMShpbnB1dCwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGFkZFN1YnRyYWN0JDEodGhpcywgaW5wdXQsIHZhbHVlLCAxKTtcbiAgICB9XG5cbiAgICAvLyBzdXBwb3J0cyBvbmx5IDIuMC1zdHlsZSBzdWJ0cmFjdCgxLCAncycpIG9yIHN1YnRyYWN0KGR1cmF0aW9uKVxuICAgIGZ1bmN0aW9uIHN1YnRyYWN0JDEoaW5wdXQsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBhZGRTdWJ0cmFjdCQxKHRoaXMsIGlucHV0LCB2YWx1ZSwgLTEpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFic0NlaWwobnVtYmVyKSB7XG4gICAgICAgIGlmIChudW1iZXIgPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihudW1iZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguY2VpbChudW1iZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYnViYmxlKCkge1xuICAgICAgICB2YXIgbWlsbGlzZWNvbmRzID0gdGhpcy5fbWlsbGlzZWNvbmRzLFxuICAgICAgICAgICAgZGF5cyA9IHRoaXMuX2RheXMsXG4gICAgICAgICAgICBtb250aHMgPSB0aGlzLl9tb250aHMsXG4gICAgICAgICAgICBkYXRhID0gdGhpcy5fZGF0YSxcbiAgICAgICAgICAgIHNlY29uZHMsXG4gICAgICAgICAgICBtaW51dGVzLFxuICAgICAgICAgICAgaG91cnMsXG4gICAgICAgICAgICB5ZWFycyxcbiAgICAgICAgICAgIG1vbnRoc0Zyb21EYXlzO1xuXG4gICAgICAgIC8vIGlmIHdlIGhhdmUgYSBtaXggb2YgcG9zaXRpdmUgYW5kIG5lZ2F0aXZlIHZhbHVlcywgYnViYmxlIGRvd24gZmlyc3RcbiAgICAgICAgLy8gY2hlY2s6IGh0dHBzOi8vZ2l0aHViLmNvbS9tb21lbnQvbW9tZW50L2lzc3Vlcy8yMTY2XG4gICAgICAgIGlmIChcbiAgICAgICAgICAgICEoXG4gICAgICAgICAgICAgICAgKG1pbGxpc2Vjb25kcyA+PSAwICYmIGRheXMgPj0gMCAmJiBtb250aHMgPj0gMCkgfHxcbiAgICAgICAgICAgICAgICAobWlsbGlzZWNvbmRzIDw9IDAgJiYgZGF5cyA8PSAwICYmIG1vbnRocyA8PSAwKVxuICAgICAgICAgICAgKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIG1pbGxpc2Vjb25kcyArPSBhYnNDZWlsKG1vbnRoc1RvRGF5cyhtb250aHMpICsgZGF5cykgKiA4NjRlNTtcbiAgICAgICAgICAgIGRheXMgPSAwO1xuICAgICAgICAgICAgbW9udGhzID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRoZSBmb2xsb3dpbmcgY29kZSBidWJibGVzIHVwIHZhbHVlcywgc2VlIHRoZSB0ZXN0cyBmb3JcbiAgICAgICAgLy8gZXhhbXBsZXMgb2Ygd2hhdCB0aGF0IG1lYW5zLlxuICAgICAgICBkYXRhLm1pbGxpc2Vjb25kcyA9IG1pbGxpc2Vjb25kcyAlIDEwMDA7XG5cbiAgICAgICAgc2Vjb25kcyA9IGFic0Zsb29yKG1pbGxpc2Vjb25kcyAvIDEwMDApO1xuICAgICAgICBkYXRhLnNlY29uZHMgPSBzZWNvbmRzICUgNjA7XG5cbiAgICAgICAgbWludXRlcyA9IGFic0Zsb29yKHNlY29uZHMgLyA2MCk7XG4gICAgICAgIGRhdGEubWludXRlcyA9IG1pbnV0ZXMgJSA2MDtcblxuICAgICAgICBob3VycyA9IGFic0Zsb29yKG1pbnV0ZXMgLyA2MCk7XG4gICAgICAgIGRhdGEuaG91cnMgPSBob3VycyAlIDI0O1xuXG4gICAgICAgIGRheXMgKz0gYWJzRmxvb3IoaG91cnMgLyAyNCk7XG5cbiAgICAgICAgLy8gY29udmVydCBkYXlzIHRvIG1vbnRoc1xuICAgICAgICBtb250aHNGcm9tRGF5cyA9IGFic0Zsb29yKGRheXNUb01vbnRocyhkYXlzKSk7XG4gICAgICAgIG1vbnRocyArPSBtb250aHNGcm9tRGF5cztcbiAgICAgICAgZGF5cyAtPSBhYnNDZWlsKG1vbnRoc1RvRGF5cyhtb250aHNGcm9tRGF5cykpO1xuXG4gICAgICAgIC8vIDEyIG1vbnRocyAtPiAxIHllYXJcbiAgICAgICAgeWVhcnMgPSBhYnNGbG9vcihtb250aHMgLyAxMik7XG4gICAgICAgIG1vbnRocyAlPSAxMjtcblxuICAgICAgICBkYXRhLmRheXMgPSBkYXlzO1xuICAgICAgICBkYXRhLm1vbnRocyA9IG1vbnRocztcbiAgICAgICAgZGF0YS55ZWFycyA9IHllYXJzO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRheXNUb01vbnRocyhkYXlzKSB7XG4gICAgICAgIC8vIDQwMCB5ZWFycyBoYXZlIDE0NjA5NyBkYXlzICh0YWtpbmcgaW50byBhY2NvdW50IGxlYXAgeWVhciBydWxlcylcbiAgICAgICAgLy8gNDAwIHllYXJzIGhhdmUgMTIgbW9udGhzID09PSA0ODAwXG4gICAgICAgIHJldHVybiAoZGF5cyAqIDQ4MDApIC8gMTQ2MDk3O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1vbnRoc1RvRGF5cyhtb250aHMpIHtcbiAgICAgICAgLy8gdGhlIHJldmVyc2Ugb2YgZGF5c1RvTW9udGhzXG4gICAgICAgIHJldHVybiAobW9udGhzICogMTQ2MDk3KSAvIDQ4MDA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYXModW5pdHMpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGF5cyxcbiAgICAgICAgICAgIG1vbnRocyxcbiAgICAgICAgICAgIG1pbGxpc2Vjb25kcyA9IHRoaXMuX21pbGxpc2Vjb25kcztcblxuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcblxuICAgICAgICBpZiAodW5pdHMgPT09ICdtb250aCcgfHwgdW5pdHMgPT09ICdxdWFydGVyJyB8fCB1bml0cyA9PT0gJ3llYXInKSB7XG4gICAgICAgICAgICBkYXlzID0gdGhpcy5fZGF5cyArIG1pbGxpc2Vjb25kcyAvIDg2NGU1O1xuICAgICAgICAgICAgbW9udGhzID0gdGhpcy5fbW9udGhzICsgZGF5c1RvTW9udGhzKGRheXMpO1xuICAgICAgICAgICAgc3dpdGNoICh1bml0cykge1xuICAgICAgICAgICAgICAgIGNhc2UgJ21vbnRoJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1vbnRocztcbiAgICAgICAgICAgICAgICBjYXNlICdxdWFydGVyJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1vbnRocyAvIDM7XG4gICAgICAgICAgICAgICAgY2FzZSAneWVhcic6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtb250aHMgLyAxMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGhhbmRsZSBtaWxsaXNlY29uZHMgc2VwYXJhdGVseSBiZWNhdXNlIG9mIGZsb2F0aW5nIHBvaW50IG1hdGggZXJyb3JzIChpc3N1ZSAjMTg2NylcbiAgICAgICAgICAgIGRheXMgPSB0aGlzLl9kYXlzICsgTWF0aC5yb3VuZChtb250aHNUb0RheXModGhpcy5fbW9udGhzKSk7XG4gICAgICAgICAgICBzd2l0Y2ggKHVuaXRzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnd2Vlayc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXlzIC8gNyArIG1pbGxpc2Vjb25kcyAvIDYwNDhlNTtcbiAgICAgICAgICAgICAgICBjYXNlICdkYXknOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF5cyArIG1pbGxpc2Vjb25kcyAvIDg2NGU1O1xuICAgICAgICAgICAgICAgIGNhc2UgJ2hvdXInOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF5cyAqIDI0ICsgbWlsbGlzZWNvbmRzIC8gMzZlNTtcbiAgICAgICAgICAgICAgICBjYXNlICdtaW51dGUnOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF5cyAqIDE0NDAgKyBtaWxsaXNlY29uZHMgLyA2ZTQ7XG4gICAgICAgICAgICAgICAgY2FzZSAnc2Vjb25kJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRheXMgKiA4NjQwMCArIG1pbGxpc2Vjb25kcyAvIDEwMDA7XG4gICAgICAgICAgICAgICAgLy8gTWF0aC5mbG9vciBwcmV2ZW50cyBmbG9hdGluZyBwb2ludCBtYXRoIGVycm9ycyBoZXJlXG4gICAgICAgICAgICAgICAgY2FzZSAnbWlsbGlzZWNvbmQnOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihkYXlzICogODY0ZTUpICsgbWlsbGlzZWNvbmRzO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biB1bml0ICcgKyB1bml0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUT0RPOiBVc2UgdGhpcy5hcygnbXMnKT9cbiAgICBmdW5jdGlvbiB2YWx1ZU9mJDEoKSB7XG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBOYU47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHRoaXMuX21pbGxpc2Vjb25kcyArXG4gICAgICAgICAgICB0aGlzLl9kYXlzICogODY0ZTUgK1xuICAgICAgICAgICAgKHRoaXMuX21vbnRocyAlIDEyKSAqIDI1OTJlNiArXG4gICAgICAgICAgICB0b0ludCh0aGlzLl9tb250aHMgLyAxMikgKiAzMTUzNmU2XG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFrZUFzKGFsaWFzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hcyhhbGlhcyk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIGFzTWlsbGlzZWNvbmRzID0gbWFrZUFzKCdtcycpLFxuICAgICAgICBhc1NlY29uZHMgPSBtYWtlQXMoJ3MnKSxcbiAgICAgICAgYXNNaW51dGVzID0gbWFrZUFzKCdtJyksXG4gICAgICAgIGFzSG91cnMgPSBtYWtlQXMoJ2gnKSxcbiAgICAgICAgYXNEYXlzID0gbWFrZUFzKCdkJyksXG4gICAgICAgIGFzV2Vla3MgPSBtYWtlQXMoJ3cnKSxcbiAgICAgICAgYXNNb250aHMgPSBtYWtlQXMoJ00nKSxcbiAgICAgICAgYXNRdWFydGVycyA9IG1ha2VBcygnUScpLFxuICAgICAgICBhc1llYXJzID0gbWFrZUFzKCd5Jyk7XG5cbiAgICBmdW5jdGlvbiBjbG9uZSQxKCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlRHVyYXRpb24odGhpcyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0JDIodW5pdHMpIHtcbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG4gICAgICAgIHJldHVybiB0aGlzLmlzVmFsaWQoKSA/IHRoaXNbdW5pdHMgKyAncyddKCkgOiBOYU47XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFrZUdldHRlcihuYW1lKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pc1ZhbGlkKCkgPyB0aGlzLl9kYXRhW25hbWVdIDogTmFOO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHZhciBtaWxsaXNlY29uZHMgPSBtYWtlR2V0dGVyKCdtaWxsaXNlY29uZHMnKSxcbiAgICAgICAgc2Vjb25kcyA9IG1ha2VHZXR0ZXIoJ3NlY29uZHMnKSxcbiAgICAgICAgbWludXRlcyA9IG1ha2VHZXR0ZXIoJ21pbnV0ZXMnKSxcbiAgICAgICAgaG91cnMgPSBtYWtlR2V0dGVyKCdob3VycycpLFxuICAgICAgICBkYXlzID0gbWFrZUdldHRlcignZGF5cycpLFxuICAgICAgICBtb250aHMgPSBtYWtlR2V0dGVyKCdtb250aHMnKSxcbiAgICAgICAgeWVhcnMgPSBtYWtlR2V0dGVyKCd5ZWFycycpO1xuXG4gICAgZnVuY3Rpb24gd2Vla3MoKSB7XG4gICAgICAgIHJldHVybiBhYnNGbG9vcih0aGlzLmRheXMoKSAvIDcpO1xuICAgIH1cblxuICAgIHZhciByb3VuZCA9IE1hdGgucm91bmQsXG4gICAgICAgIHRocmVzaG9sZHMgPSB7XG4gICAgICAgICAgICBzczogNDQsIC8vIGEgZmV3IHNlY29uZHMgdG8gc2Vjb25kc1xuICAgICAgICAgICAgczogNDUsIC8vIHNlY29uZHMgdG8gbWludXRlXG4gICAgICAgICAgICBtOiA0NSwgLy8gbWludXRlcyB0byBob3VyXG4gICAgICAgICAgICBoOiAyMiwgLy8gaG91cnMgdG8gZGF5XG4gICAgICAgICAgICBkOiAyNiwgLy8gZGF5cyB0byBtb250aC93ZWVrXG4gICAgICAgICAgICB3OiBudWxsLCAvLyB3ZWVrcyB0byBtb250aFxuICAgICAgICAgICAgTTogMTEsIC8vIG1vbnRocyB0byB5ZWFyXG4gICAgICAgIH07XG5cbiAgICAvLyBoZWxwZXIgZnVuY3Rpb24gZm9yIG1vbWVudC5mbi5mcm9tLCBtb21lbnQuZm4uZnJvbU5vdywgYW5kIG1vbWVudC5kdXJhdGlvbi5mbi5odW1hbml6ZVxuICAgIGZ1bmN0aW9uIHN1YnN0aXR1dGVUaW1lQWdvKHN0cmluZywgbnVtYmVyLCB3aXRob3V0U3VmZml4LCBpc0Z1dHVyZSwgbG9jYWxlKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGUucmVsYXRpdmVUaW1lKG51bWJlciB8fCAxLCAhIXdpdGhvdXRTdWZmaXgsIHN0cmluZywgaXNGdXR1cmUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlbGF0aXZlVGltZSQxKHBvc05lZ0R1cmF0aW9uLCB3aXRob3V0U3VmZml4LCB0aHJlc2hvbGRzLCBsb2NhbGUpIHtcbiAgICAgICAgdmFyIGR1cmF0aW9uID0gY3JlYXRlRHVyYXRpb24ocG9zTmVnRHVyYXRpb24pLmFicygpLFxuICAgICAgICAgICAgc2Vjb25kcyA9IHJvdW5kKGR1cmF0aW9uLmFzKCdzJykpLFxuICAgICAgICAgICAgbWludXRlcyA9IHJvdW5kKGR1cmF0aW9uLmFzKCdtJykpLFxuICAgICAgICAgICAgaG91cnMgPSByb3VuZChkdXJhdGlvbi5hcygnaCcpKSxcbiAgICAgICAgICAgIGRheXMgPSByb3VuZChkdXJhdGlvbi5hcygnZCcpKSxcbiAgICAgICAgICAgIG1vbnRocyA9IHJvdW5kKGR1cmF0aW9uLmFzKCdNJykpLFxuICAgICAgICAgICAgd2Vla3MgPSByb3VuZChkdXJhdGlvbi5hcygndycpKSxcbiAgICAgICAgICAgIHllYXJzID0gcm91bmQoZHVyYXRpb24uYXMoJ3knKSksXG4gICAgICAgICAgICBhID1cbiAgICAgICAgICAgICAgICAoc2Vjb25kcyA8PSB0aHJlc2hvbGRzLnNzICYmIFsncycsIHNlY29uZHNdKSB8fFxuICAgICAgICAgICAgICAgIChzZWNvbmRzIDwgdGhyZXNob2xkcy5zICYmIFsnc3MnLCBzZWNvbmRzXSkgfHxcbiAgICAgICAgICAgICAgICAobWludXRlcyA8PSAxICYmIFsnbSddKSB8fFxuICAgICAgICAgICAgICAgIChtaW51dGVzIDwgdGhyZXNob2xkcy5tICYmIFsnbW0nLCBtaW51dGVzXSkgfHxcbiAgICAgICAgICAgICAgICAoaG91cnMgPD0gMSAmJiBbJ2gnXSkgfHxcbiAgICAgICAgICAgICAgICAoaG91cnMgPCB0aHJlc2hvbGRzLmggJiYgWydoaCcsIGhvdXJzXSkgfHxcbiAgICAgICAgICAgICAgICAoZGF5cyA8PSAxICYmIFsnZCddKSB8fFxuICAgICAgICAgICAgICAgIChkYXlzIDwgdGhyZXNob2xkcy5kICYmIFsnZGQnLCBkYXlzXSk7XG5cbiAgICAgICAgaWYgKHRocmVzaG9sZHMudyAhPSBudWxsKSB7XG4gICAgICAgICAgICBhID1cbiAgICAgICAgICAgICAgICBhIHx8XG4gICAgICAgICAgICAgICAgKHdlZWtzIDw9IDEgJiYgWyd3J10pIHx8XG4gICAgICAgICAgICAgICAgKHdlZWtzIDwgdGhyZXNob2xkcy53ICYmIFsnd3cnLCB3ZWVrc10pO1xuICAgICAgICB9XG4gICAgICAgIGEgPSBhIHx8XG4gICAgICAgICAgICAobW9udGhzIDw9IDEgJiYgWydNJ10pIHx8XG4gICAgICAgICAgICAobW9udGhzIDwgdGhyZXNob2xkcy5NICYmIFsnTU0nLCBtb250aHNdKSB8fFxuICAgICAgICAgICAgKHllYXJzIDw9IDEgJiYgWyd5J10pIHx8IFsneXknLCB5ZWFyc107XG5cbiAgICAgICAgYVsyXSA9IHdpdGhvdXRTdWZmaXg7XG4gICAgICAgIGFbM10gPSArcG9zTmVnRHVyYXRpb24gPiAwO1xuICAgICAgICBhWzRdID0gbG9jYWxlO1xuICAgICAgICByZXR1cm4gc3Vic3RpdHV0ZVRpbWVBZ28uYXBwbHkobnVsbCwgYSk7XG4gICAgfVxuXG4gICAgLy8gVGhpcyBmdW5jdGlvbiBhbGxvd3MgeW91IHRvIHNldCB0aGUgcm91bmRpbmcgZnVuY3Rpb24gZm9yIHJlbGF0aXZlIHRpbWUgc3RyaW5nc1xuICAgIGZ1bmN0aW9uIGdldFNldFJlbGF0aXZlVGltZVJvdW5kaW5nKHJvdW5kaW5nRnVuY3Rpb24pIHtcbiAgICAgICAgaWYgKHJvdW5kaW5nRnVuY3Rpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHJvdW5kO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygcm91bmRpbmdGdW5jdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcm91bmQgPSByb3VuZGluZ0Z1bmN0aW9uO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIFRoaXMgZnVuY3Rpb24gYWxsb3dzIHlvdSB0byBzZXQgYSB0aHJlc2hvbGQgZm9yIHJlbGF0aXZlIHRpbWUgc3RyaW5nc1xuICAgIGZ1bmN0aW9uIGdldFNldFJlbGF0aXZlVGltZVRocmVzaG9sZCh0aHJlc2hvbGQsIGxpbWl0KSB7XG4gICAgICAgIGlmICh0aHJlc2hvbGRzW3RocmVzaG9sZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsaW1pdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhyZXNob2xkc1t0aHJlc2hvbGRdO1xuICAgICAgICB9XG4gICAgICAgIHRocmVzaG9sZHNbdGhyZXNob2xkXSA9IGxpbWl0O1xuICAgICAgICBpZiAodGhyZXNob2xkID09PSAncycpIHtcbiAgICAgICAgICAgIHRocmVzaG9sZHMuc3MgPSBsaW1pdCAtIDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaHVtYW5pemUoYXJnV2l0aFN1ZmZpeCwgYXJnVGhyZXNob2xkcykge1xuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkuaW52YWxpZERhdGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB3aXRoU3VmZml4ID0gZmFsc2UsXG4gICAgICAgICAgICB0aCA9IHRocmVzaG9sZHMsXG4gICAgICAgICAgICBsb2NhbGUsXG4gICAgICAgICAgICBvdXRwdXQ7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBhcmdXaXRoU3VmZml4ID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgYXJnVGhyZXNob2xkcyA9IGFyZ1dpdGhTdWZmaXg7XG4gICAgICAgICAgICBhcmdXaXRoU3VmZml4ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBhcmdXaXRoU3VmZml4ID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgIHdpdGhTdWZmaXggPSBhcmdXaXRoU3VmZml4O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgYXJnVGhyZXNob2xkcyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHRoID0gT2JqZWN0LmFzc2lnbih7fSwgdGhyZXNob2xkcywgYXJnVGhyZXNob2xkcyk7XG4gICAgICAgICAgICBpZiAoYXJnVGhyZXNob2xkcy5zICE9IG51bGwgJiYgYXJnVGhyZXNob2xkcy5zcyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGguc3MgPSBhcmdUaHJlc2hvbGRzLnMgLSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbG9jYWxlID0gdGhpcy5sb2NhbGVEYXRhKCk7XG4gICAgICAgIG91dHB1dCA9IHJlbGF0aXZlVGltZSQxKHRoaXMsICF3aXRoU3VmZml4LCB0aCwgbG9jYWxlKTtcblxuICAgICAgICBpZiAod2l0aFN1ZmZpeCkge1xuICAgICAgICAgICAgb3V0cHV0ID0gbG9jYWxlLnBhc3RGdXR1cmUoK3RoaXMsIG91dHB1dCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbG9jYWxlLnBvc3Rmb3JtYXQob3V0cHV0KTtcbiAgICB9XG5cbiAgICB2YXIgYWJzJDEgPSBNYXRoLmFicztcblxuICAgIGZ1bmN0aW9uIHNpZ24oeCkge1xuICAgICAgICByZXR1cm4gKHggPiAwKSAtICh4IDwgMCkgfHwgK3g7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9JU09TdHJpbmckMSgpIHtcbiAgICAgICAgLy8gZm9yIElTTyBzdHJpbmdzIHdlIGRvIG5vdCB1c2UgdGhlIG5vcm1hbCBidWJibGluZyBydWxlczpcbiAgICAgICAgLy8gICogbWlsbGlzZWNvbmRzIGJ1YmJsZSB1cCB1bnRpbCB0aGV5IGJlY29tZSBob3Vyc1xuICAgICAgICAvLyAgKiBkYXlzIGRvIG5vdCBidWJibGUgYXQgYWxsXG4gICAgICAgIC8vICAqIG1vbnRocyBidWJibGUgdXAgdW50aWwgdGhleSBiZWNvbWUgeWVhcnNcbiAgICAgICAgLy8gVGhpcyBpcyBiZWNhdXNlIHRoZXJlIGlzIG5vIGNvbnRleHQtZnJlZSBjb252ZXJzaW9uIGJldHdlZW4gaG91cnMgYW5kIGRheXNcbiAgICAgICAgLy8gKHRoaW5rIG9mIGNsb2NrIGNoYW5nZXMpXG4gICAgICAgIC8vIGFuZCBhbHNvIG5vdCBiZXR3ZWVuIGRheXMgYW5kIG1vbnRocyAoMjgtMzEgZGF5cyBwZXIgbW9udGgpXG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5pbnZhbGlkRGF0ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNlY29uZHMgPSBhYnMkMSh0aGlzLl9taWxsaXNlY29uZHMpIC8gMTAwMCxcbiAgICAgICAgICAgIGRheXMgPSBhYnMkMSh0aGlzLl9kYXlzKSxcbiAgICAgICAgICAgIG1vbnRocyA9IGFicyQxKHRoaXMuX21vbnRocyksXG4gICAgICAgICAgICBtaW51dGVzLFxuICAgICAgICAgICAgaG91cnMsXG4gICAgICAgICAgICB5ZWFycyxcbiAgICAgICAgICAgIHMsXG4gICAgICAgICAgICB0b3RhbCA9IHRoaXMuYXNTZWNvbmRzKCksXG4gICAgICAgICAgICB0b3RhbFNpZ24sXG4gICAgICAgICAgICB5bVNpZ24sXG4gICAgICAgICAgICBkYXlzU2lnbixcbiAgICAgICAgICAgIGhtc1NpZ247XG5cbiAgICAgICAgaWYgKCF0b3RhbCkge1xuICAgICAgICAgICAgLy8gdGhpcyBpcyB0aGUgc2FtZSBhcyBDIydzIChOb2RhKSBhbmQgcHl0aG9uIChpc29kYXRlKS4uLlxuICAgICAgICAgICAgLy8gYnV0IG5vdCBvdGhlciBKUyAoZ29vZy5kYXRlKVxuICAgICAgICAgICAgcmV0dXJuICdQMEQnO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gMzYwMCBzZWNvbmRzIC0+IDYwIG1pbnV0ZXMgLT4gMSBob3VyXG4gICAgICAgIG1pbnV0ZXMgPSBhYnNGbG9vcihzZWNvbmRzIC8gNjApO1xuICAgICAgICBob3VycyA9IGFic0Zsb29yKG1pbnV0ZXMgLyA2MCk7XG4gICAgICAgIHNlY29uZHMgJT0gNjA7XG4gICAgICAgIG1pbnV0ZXMgJT0gNjA7XG5cbiAgICAgICAgLy8gMTIgbW9udGhzIC0+IDEgeWVhclxuICAgICAgICB5ZWFycyA9IGFic0Zsb29yKG1vbnRocyAvIDEyKTtcbiAgICAgICAgbW9udGhzICU9IDEyO1xuXG4gICAgICAgIC8vIGluc3BpcmVkIGJ5IGh0dHBzOi8vZ2l0aHViLmNvbS9kb3JkaWxsZS9tb21lbnQtaXNvZHVyYXRpb24vYmxvYi9tYXN0ZXIvbW9tZW50Lmlzb2R1cmF0aW9uLmpzXG4gICAgICAgIHMgPSBzZWNvbmRzID8gc2Vjb25kcy50b0ZpeGVkKDMpLnJlcGxhY2UoL1xcLj8wKyQvLCAnJykgOiAnJztcblxuICAgICAgICB0b3RhbFNpZ24gPSB0b3RhbCA8IDAgPyAnLScgOiAnJztcbiAgICAgICAgeW1TaWduID0gc2lnbih0aGlzLl9tb250aHMpICE9PSBzaWduKHRvdGFsKSA/ICctJyA6ICcnO1xuICAgICAgICBkYXlzU2lnbiA9IHNpZ24odGhpcy5fZGF5cykgIT09IHNpZ24odG90YWwpID8gJy0nIDogJyc7XG4gICAgICAgIGhtc1NpZ24gPSBzaWduKHRoaXMuX21pbGxpc2Vjb25kcykgIT09IHNpZ24odG90YWwpID8gJy0nIDogJyc7XG5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHRvdGFsU2lnbiArXG4gICAgICAgICAgICAnUCcgK1xuICAgICAgICAgICAgKHllYXJzID8geW1TaWduICsgeWVhcnMgKyAnWScgOiAnJykgK1xuICAgICAgICAgICAgKG1vbnRocyA/IHltU2lnbiArIG1vbnRocyArICdNJyA6ICcnKSArXG4gICAgICAgICAgICAoZGF5cyA/IGRheXNTaWduICsgZGF5cyArICdEJyA6ICcnKSArXG4gICAgICAgICAgICAoaG91cnMgfHwgbWludXRlcyB8fCBzZWNvbmRzID8gJ1QnIDogJycpICtcbiAgICAgICAgICAgIChob3VycyA/IGhtc1NpZ24gKyBob3VycyArICdIJyA6ICcnKSArXG4gICAgICAgICAgICAobWludXRlcyA/IGhtc1NpZ24gKyBtaW51dGVzICsgJ00nIDogJycpICtcbiAgICAgICAgICAgIChzZWNvbmRzID8gaG1zU2lnbiArIHMgKyAnUycgOiAnJylcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICB2YXIgcHJvdG8kMiA9IER1cmF0aW9uLnByb3RvdHlwZTtcblxuICAgIHByb3RvJDIuaXNWYWxpZCA9IGlzVmFsaWQkMTtcbiAgICBwcm90byQyLmFicyA9IGFicztcbiAgICBwcm90byQyLmFkZCA9IGFkZCQxO1xuICAgIHByb3RvJDIuc3VidHJhY3QgPSBzdWJ0cmFjdCQxO1xuICAgIHByb3RvJDIuYXMgPSBhcztcbiAgICBwcm90byQyLmFzTWlsbGlzZWNvbmRzID0gYXNNaWxsaXNlY29uZHM7XG4gICAgcHJvdG8kMi5hc1NlY29uZHMgPSBhc1NlY29uZHM7XG4gICAgcHJvdG8kMi5hc01pbnV0ZXMgPSBhc01pbnV0ZXM7XG4gICAgcHJvdG8kMi5hc0hvdXJzID0gYXNIb3VycztcbiAgICBwcm90byQyLmFzRGF5cyA9IGFzRGF5cztcbiAgICBwcm90byQyLmFzV2Vla3MgPSBhc1dlZWtzO1xuICAgIHByb3RvJDIuYXNNb250aHMgPSBhc01vbnRocztcbiAgICBwcm90byQyLmFzUXVhcnRlcnMgPSBhc1F1YXJ0ZXJzO1xuICAgIHByb3RvJDIuYXNZZWFycyA9IGFzWWVhcnM7XG4gICAgcHJvdG8kMi52YWx1ZU9mID0gdmFsdWVPZiQxO1xuICAgIHByb3RvJDIuX2J1YmJsZSA9IGJ1YmJsZTtcbiAgICBwcm90byQyLmNsb25lID0gY2xvbmUkMTtcbiAgICBwcm90byQyLmdldCA9IGdldCQyO1xuICAgIHByb3RvJDIubWlsbGlzZWNvbmRzID0gbWlsbGlzZWNvbmRzO1xuICAgIHByb3RvJDIuc2Vjb25kcyA9IHNlY29uZHM7XG4gICAgcHJvdG8kMi5taW51dGVzID0gbWludXRlcztcbiAgICBwcm90byQyLmhvdXJzID0gaG91cnM7XG4gICAgcHJvdG8kMi5kYXlzID0gZGF5cztcbiAgICBwcm90byQyLndlZWtzID0gd2Vla3M7XG4gICAgcHJvdG8kMi5tb250aHMgPSBtb250aHM7XG4gICAgcHJvdG8kMi55ZWFycyA9IHllYXJzO1xuICAgIHByb3RvJDIuaHVtYW5pemUgPSBodW1hbml6ZTtcbiAgICBwcm90byQyLnRvSVNPU3RyaW5nID0gdG9JU09TdHJpbmckMTtcbiAgICBwcm90byQyLnRvU3RyaW5nID0gdG9JU09TdHJpbmckMTtcbiAgICBwcm90byQyLnRvSlNPTiA9IHRvSVNPU3RyaW5nJDE7XG4gICAgcHJvdG8kMi5sb2NhbGUgPSBsb2NhbGU7XG4gICAgcHJvdG8kMi5sb2NhbGVEYXRhID0gbG9jYWxlRGF0YTtcblxuICAgIHByb3RvJDIudG9Jc29TdHJpbmcgPSBkZXByZWNhdGUoXG4gICAgICAgICd0b0lzb1N0cmluZygpIGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgdG9JU09TdHJpbmcoKSBpbnN0ZWFkIChub3RpY2UgdGhlIGNhcGl0YWxzKScsXG4gICAgICAgIHRvSVNPU3RyaW5nJDFcbiAgICApO1xuICAgIHByb3RvJDIubGFuZyA9IGxhbmc7XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbignWCcsIDAsIDAsICd1bml4Jyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oJ3gnLCAwLCAwLCAndmFsdWVPZicpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbigneCcsIG1hdGNoU2lnbmVkKTtcbiAgICBhZGRSZWdleFRva2VuKCdYJywgbWF0Y2hUaW1lc3RhbXApO1xuICAgIGFkZFBhcnNlVG9rZW4oJ1gnLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUocGFyc2VGbG9hdChpbnB1dCkgKiAxMDAwKTtcbiAgICB9KTtcbiAgICBhZGRQYXJzZVRva2VuKCd4JywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKHRvSW50KGlucHV0KSk7XG4gICAgfSk7XG5cbiAgICAvLyEgbW9tZW50LmpzXG5cbiAgICBob29rcy52ZXJzaW9uID0gJzIuMjkuMSc7XG5cbiAgICBzZXRIb29rQ2FsbGJhY2soY3JlYXRlTG9jYWwpO1xuXG4gICAgaG9va3MuZm4gPSBwcm90bztcbiAgICBob29rcy5taW4gPSBtaW47XG4gICAgaG9va3MubWF4ID0gbWF4O1xuICAgIGhvb2tzLm5vdyA9IG5vdztcbiAgICBob29rcy51dGMgPSBjcmVhdGVVVEM7XG4gICAgaG9va3MudW5peCA9IGNyZWF0ZVVuaXg7XG4gICAgaG9va3MubW9udGhzID0gbGlzdE1vbnRocztcbiAgICBob29rcy5pc0RhdGUgPSBpc0RhdGU7XG4gICAgaG9va3MubG9jYWxlID0gZ2V0U2V0R2xvYmFsTG9jYWxlO1xuICAgIGhvb2tzLmludmFsaWQgPSBjcmVhdGVJbnZhbGlkO1xuICAgIGhvb2tzLmR1cmF0aW9uID0gY3JlYXRlRHVyYXRpb247XG4gICAgaG9va3MuaXNNb21lbnQgPSBpc01vbWVudDtcbiAgICBob29rcy53ZWVrZGF5cyA9IGxpc3RXZWVrZGF5cztcbiAgICBob29rcy5wYXJzZVpvbmUgPSBjcmVhdGVJblpvbmU7XG4gICAgaG9va3MubG9jYWxlRGF0YSA9IGdldExvY2FsZTtcbiAgICBob29rcy5pc0R1cmF0aW9uID0gaXNEdXJhdGlvbjtcbiAgICBob29rcy5tb250aHNTaG9ydCA9IGxpc3RNb250aHNTaG9ydDtcbiAgICBob29rcy53ZWVrZGF5c01pbiA9IGxpc3RXZWVrZGF5c01pbjtcbiAgICBob29rcy5kZWZpbmVMb2NhbGUgPSBkZWZpbmVMb2NhbGU7XG4gICAgaG9va3MudXBkYXRlTG9jYWxlID0gdXBkYXRlTG9jYWxlO1xuICAgIGhvb2tzLmxvY2FsZXMgPSBsaXN0TG9jYWxlcztcbiAgICBob29rcy53ZWVrZGF5c1Nob3J0ID0gbGlzdFdlZWtkYXlzU2hvcnQ7XG4gICAgaG9va3Mubm9ybWFsaXplVW5pdHMgPSBub3JtYWxpemVVbml0cztcbiAgICBob29rcy5yZWxhdGl2ZVRpbWVSb3VuZGluZyA9IGdldFNldFJlbGF0aXZlVGltZVJvdW5kaW5nO1xuICAgIGhvb2tzLnJlbGF0aXZlVGltZVRocmVzaG9sZCA9IGdldFNldFJlbGF0aXZlVGltZVRocmVzaG9sZDtcbiAgICBob29rcy5jYWxlbmRhckZvcm1hdCA9IGdldENhbGVuZGFyRm9ybWF0O1xuICAgIGhvb2tzLnByb3RvdHlwZSA9IHByb3RvO1xuXG4gICAgLy8gY3VycmVudGx5IEhUTUw1IGlucHV0IHR5cGUgb25seSBzdXBwb3J0cyAyNC1ob3VyIGZvcm1hdHNcbiAgICBob29rcy5IVE1MNV9GTVQgPSB7XG4gICAgICAgIERBVEVUSU1FX0xPQ0FMOiAnWVlZWS1NTS1ERFRISDptbScsIC8vIDxpbnB1dCB0eXBlPVwiZGF0ZXRpbWUtbG9jYWxcIiAvPlxuICAgICAgICBEQVRFVElNRV9MT0NBTF9TRUNPTkRTOiAnWVlZWS1NTS1ERFRISDptbTpzcycsIC8vIDxpbnB1dCB0eXBlPVwiZGF0ZXRpbWUtbG9jYWxcIiBzdGVwPVwiMVwiIC8+XG4gICAgICAgIERBVEVUSU1FX0xPQ0FMX01TOiAnWVlZWS1NTS1ERFRISDptbTpzcy5TU1MnLCAvLyA8aW5wdXQgdHlwZT1cImRhdGV0aW1lLWxvY2FsXCIgc3RlcD1cIjAuMDAxXCIgLz5cbiAgICAgICAgREFURTogJ1lZWVktTU0tREQnLCAvLyA8aW5wdXQgdHlwZT1cImRhdGVcIiAvPlxuICAgICAgICBUSU1FOiAnSEg6bW0nLCAvLyA8aW5wdXQgdHlwZT1cInRpbWVcIiAvPlxuICAgICAgICBUSU1FX1NFQ09ORFM6ICdISDptbTpzcycsIC8vIDxpbnB1dCB0eXBlPVwidGltZVwiIHN0ZXA9XCIxXCIgLz5cbiAgICAgICAgVElNRV9NUzogJ0hIOm1tOnNzLlNTUycsIC8vIDxpbnB1dCB0eXBlPVwidGltZVwiIHN0ZXA9XCIwLjAwMVwiIC8+XG4gICAgICAgIFdFRUs6ICdHR0dHLVtXXVdXJywgLy8gPGlucHV0IHR5cGU9XCJ3ZWVrXCIgLz5cbiAgICAgICAgTU9OVEg6ICdZWVlZLU1NJywgLy8gPGlucHV0IHR5cGU9XCJtb250aFwiIC8+XG4gICAgfTtcblxuICAgIHJldHVybiBob29rcztcblxufSkpKTtcbiIsICJpbXBvcnQgeyBVcGRhdGVOb3RlVHlwZU1vZGFsIH0gZnJvbSAndXBkYXRlTm90ZVR5cGVNb2RhbCc7XG5pbXBvcnQgeyBBcHAsIEVkaXRvciwgTWFya2Rvd25WaWV3LCBOb3RpY2UsIFBsdWdpbiwgUGx1Z2luU2V0dGluZ1RhYiwgU2V0dGluZywgVEZpbGUsIFZhdWx0LCBFZGl0b3JTZWxlY3Rpb24sIFdvcmtzcGFjZSB9IGZyb20gJ29ic2lkaWFuJztcbmltcG9ydCB7IEFkZEZvb3Rub3RlVGFnTW9kYWwgfSBmcm9tICdhZGRDb21tZW50VGFnTW9kYWwnO1xuaW1wb3J0IHsgQWRkVGFza1RhZ01vZGFsIH0gZnJvbSAnYWRkVGFza1RhZ01vZGFsJztcbmltcG9ydCB7IHJlbmFtZUJsb2dUaXRsZSwgcmVuYW1lVGFnIH0gZnJvbSAndGFncmVuYW1lci9yZW5hbWluZyc7XG5pbXBvcnQgeyBUaHJlYWRzVG9JbWFnZXNNb2RhbCB9IGZyb20gJ1RocmVhZHNUb0ltYWdlc01vZGFsJztcbmltcG9ydCB7IENvcHlPck1vdmVUb05ld05vdGVNb2RhbCB9IGZyb20gJ2NvcHlPck1vdmVUb05ld05vdGVNb2RhbCc7XG5pbXBvcnQgeyBDbGlwYm9hcmRQYXN0ZU1vZGFsIH0gZnJvbSAnY2xpcGJvYXJkUGFzdGVNb2RhbCc7XG5pbXBvcnQgeyBPcGVuUGxheWdyb3VuZE1vZGFsIH0gZnJvbSAnb3BlblBsYXlncm91bmRNb2RhbCc7XG5pbXBvcnQgeyBUaHJlYWRzVG9CbG9nTW9kYWwgfSBmcm9tICd0aHJlYWRzVG9CbG9nTW9kYWwnO1xuaW1wb3J0IHsgQ2xpcGJvYXJkUmVtb3ZhbE1vZGFsIH0gZnJvbSAnY2xpcGJvYXJkUmVtb3ZhbE1vZGFsJztcbmltcG9ydCB7IFRhZ1NlYXJjaE1vZGFsIH0gZnJvbSAndGFnU2VhcmNoTW9kYWwnO1xuaW1wb3J0IHsgYWRkSWNvbiB9IGZyb20gJ29ic2lkaWFuJztcbmltcG9ydCBtb21lbnQgZnJvbSAnbW9tZW50JztcbmltcG9ydCB7IEFkZFRleHRUb05vdGVzTW9kYWwgfSBmcm9tICdhZGRUZXh0VG9Ob3Rlc01vZGFsJztcbmltcG9ydCB7IE5hdmlnYXRlVG9Ob3RlRnJvbVRhZ01vZGFsIH0gZnJvbSAnbmF2aWdhdGVUb05vdGVGcm9tVGFnTW9kYWwnO1xuaW1wb3J0IHsgU2VsZWN0aW9uUmFuZ2UsIGV4cG9ydEN1cnJlbnRTZWxlY3Rpb24sIGdldEN1cnJlbnRTZWxlY3Rpb25MaW5lTnVtYmVyIH0gZnJvbSAnc2VsZnV0aWwvZXh0cmFjdFNlbGVjdGlvbic7XG5cbi8vIFJlbWVtYmVyIHRvIHJlbmFtZSB0aGVzZSBjbGFzc2VzIGFuZCBpbnRlcmZhY2VzIVxuXG5pbnRlcmZhY2UgTXlQbHVnaW5TZXR0aW5ncyB7XG5cdG15U2V0dGluZzogc3RyaW5nO1xufVxuXG5jb25zdCBERUZBVUxUX1NFVFRJTkdTOiBNeVBsdWdpblNldHRpbmdzID0ge1xuXHRteVNldHRpbmc6ICdkZWZhdWx0J1xufVxuXG5jb25zdCBjbGlwYm9hcmRIaXN0b3J5OiBzdHJpbmdbXSA9IFtdXG5cbmNvbnN0IHNraXBGcm9udE1hdHRlckZpZWxkOiBzdHJpbmdbXSA9IFtcblx0XCJmcmVldGltZXRhc2s6IFwiLFxuXHRcImV4cGVjdGVkdGltZTogXCIsXG5cdFwibW9kZTogXCIsXG5cdFwiZGF5czogXCIsXG5cdFwic2hvd2hlYWRlcmZvb3RlcjogXCIsXG5cdFwic2hvd3N0YXRlOiBcIixcblx0XCJzb3J0c3VicGFnZWZpbHRlcjogXCIsXG5cdFwidGhyb3VnaHR0cmVlOiBcIixcblx0XCJ1cmdlbnQ6IFwiLFxuXHRcImRpc3BsYXlhczogXCIsXG5cdFwic3RhcnRkYXRlOiBcIixcblx0XCJyZWFkd3JpdGVtb2RlOiBcIixcblx0XCJzaG93Q2hhbmRsZXJOb3c6IFwiLFxuXHRcImRlZXB3b3JrOiBcIixcblx0XCJleHBlY3RlZHRpbWU6IFwiLFxuXHRcInBhcnNlZGF0ZTogXCIsXG5cdFwidGlkc2NvcGU6IFwiLFxuXHRcImluc2VydHRvZG9hY3Rpb246IFwiLFxuXHRcIm9wdGlvbmFsOiBcIixcblx0XCJyZXBsYWNldG86IFwiLFxuXHRcImJhY2t1cHRpZGRsZXI6IFwiLFxuXHRcImRlYWRsaW5lOiBcIixcblx0XCJjYXB0aW9uOiBcIixcblx0XCJjb2xsZWN0aW9uOiBcIixcblx0XCJsaWJyYXJ5OiBcIixcblx0XCJsaWJyYXJ5X3ZlcnNpb246IFwiLFxuXHRcImR1bW15OiBcIixcblx0XCJ0aWROYW1lOiBcIixcblx0XCJjaHJvbmljbGVkYXRlOiBcIixcblx0XCJldmVudGRhdGU6IFwiLFxuXHRcImRhaWx5aGlnaGxpZ2h0OiBcIixcblx0XCJkaXNwbGF5Y2FyZG1vZGU6IFwiLFxuXHRcImRpc3BsYXltb2RlOiBcIixcblx0XCJudW1jb2w6IFwiLFxuXHRcImRhdGV5eXl5bW1kZDogXCIsXG5cdFwiZ3JhcGhkaXNwbGF5bW9kZTogXCIsXG5cdFwibWF4ZGVwdGg6IFwiLFxuXHRcImpvdXJuYWxkYXRlOiBcIixcblx0XCJ0aGlzQmlsbERhdGU6IFwiLFxuXHRcImxhc3RCaWxsRGF0ZTogXCIsXG5cdFwicm9vdHRpZGRsZXI6IFwiLFxuXHRcInllYXI6IFwiLFxuXHRcInRvOiBcIixcblx0XCJ0aWR0ZW1wbGF0ZTogXCIsXG5cdFwidGlkZGxlcm5hbWU6IFwiLFxuXHRcInRoZW1lOiBcIixcblx0XCJ0YWd2YWx1ZTogXCIsXG5cdFwic3VidGFza251bTogXCIsXG5cdFwicmVtb3ZldGFndmFsdWU6IFwiLFxuXHRcInJlY3VycmluZ2V2ZW50c3RhcnRkYXRlOiBcIixcblx0XCJyZWN1cnJpbmdldmVudGVuZGRhdGU6IFwiLFxuXHRcInBsdWdpbm5hbWU6IFwiLFxuXHRcInBpZDogXCIsXG5cdFwibWFjcm9uYW1lOiBcIixcblx0XCJsaW1pdDogXCIsXG5cdFwia2V5d29yZDogXCIsXG5cdFwia2V5d29yZHRtcDogXCIsXG5cdFwiZnJvbTogXCIsXG5cdFwiZGVwcmVjYXRlcmVhc29uOiBcIixcblx0XCJkZWVwd286IFwiLFxuXHRcImNvbG9yOiBcIixcblx0XCJyb3c6IFwiLFxuXHRcImNvbDogXCIsXG5cdFwiYm9va21hcmtlZDogXCIsXG5cdFwiYmxvY2tpbmdyZW1pbmRlcmRhdGU6IFwiLFxuXHRcImJhY2t1cDogXCJcbl1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTXlQbHVnaW4gZXh0ZW5kcyBQbHVnaW4ge1xuXHRzZXR0aW5nczogTXlQbHVnaW5TZXR0aW5ncztcblx0dmlldzogTWFya2Rvd25WaWV3O1xuXG5cdGFzeW5jIG9ubG9hZCgpIHtcblx0XHRhd2FpdCB0aGlzLmxvYWRTZXR0aW5ncygpO1xuXG5cdFx0Lypcblx0XHQvL2Z1bmN0aW9uIGRpc3BsYXlOb3RlSW5MZWZ0VmlldyhhcHA6IEFwcCwgbm90ZVBhdGg6IHN0cmluZykge1xuXHRcdFx0Y29uc29sZS5sb2coXCI9PT0xXCIpXG5cdFx0XHQvL2NvbnN0IHZpZXcgPSBuZXcgTWFya2Rvd25WaWV3KHRoaXMuYXBwLndvcmtzcGFjZS5nZXRMZWFmKCkpO1xuXHRcdFx0Ly9jb25zb2xlLmxvZyhcIj09PTJcIilcblx0XHRcdC8vdmlldy5zZXRFcGhlbWVyYWxTdGF0ZSh7IHBhdGg6IFwiSS9JbmJveC5tZFwiIH0pO1xuXHRcdFx0Ly9jb25zb2xlLmxvZyhcIj09PTNcIilcblx0XHRcdC8vYXBwLndvcmtzcGFjZS5nZXRMZWFmKCkuc2V0Vmlld1N0YXRlKHsgdHlwZTogXCJtYXJrZG93blwiLCBzdGF0ZTogdmlldy5nZXRTdGF0ZSgpIH0pO1xuXHRcdFx0Ly9jb25zb2xlLmxvZyhcIj09PTRcIilcblxuXHRcdFx0XG5cdFx0XHR0aGlzLnJlZ2lzdGVyVmlldyhcblx0XHRcdFx0XCJpbmJveFwiLFxuXHRcdFx0XHQobGVhZikgPT4ge1xuXHRcdFx0XHRcdHRoaXMudmlldyA9IG5ldyBNYXJrZG93blZpZXcobGVhZilcblx0XHRcdFx0XHR0aGlzLnZpZXcuc2V0RXBoZW1lcmFsU3RhdGUoeyBwYXRoOiBcIkkvSW5ib3gubWRcIiB9KTtcblx0XHRcdFx0XHRjb25zdCBzdGF0ZSA9IHRoaXMudmlldy5nZXRTdGF0ZSgpXG5cdFx0XHRcdFx0c3RhdGUucGlubmVkID0gdHJ1ZVxuXHRcdFx0XHRcdGxlYWYuc2V0Vmlld1N0YXRlKHsgdHlwZTogXCJtYXJrZG93blwiLCBzdGF0ZTogc3RhdGUgfSk7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMudmlld1xuXHRcdFx0XHR9LFxuXHRcdFx0ICApO1xuXHRcdCAgLy99XG5cblx0XHQgIGNvbnNvbGUubG9nKFwiPT09MlwiKVxuXG5cdFx0ICB0aGlzLmFkZENvbW1hbmQoe1xuXHRcdFx0aWQ6ICdyZWNlbnQtZmlsZXMtb3BlbicsXG5cdFx0XHRuYW1lOiAnT3BlbiBYWFgnLFxuXHRcdFx0Y2FsbGJhY2s6IGFzeW5jICgpID0+IHtcblx0XHRcdCAgbGV0IFtsZWFmXSA9IHRoaXMuYXBwLndvcmtzcGFjZS5nZXRMZWF2ZXNPZlR5cGUoXG5cdFx0XHRcdFwiaW5ib3hcIixcblx0XHRcdCAgKTtcblx0XHRcdCAgaWYgKCFsZWFmKSB7XG5cdFx0XHRcdGxlYWYgPSB0aGlzLmFwcC53b3Jrc3BhY2UuZ2V0TGVmdExlYWYoZmFsc2UpO1xuXHRcdFx0XHRhd2FpdCBsZWFmLnNldFZpZXdTdGF0ZSh7IHR5cGU6IFwiaW5ib3hcIiB9KTtcblx0XHRcdCAgfVxuXHQgIFxuXHRcdFx0ICB0aGlzLmFwcC53b3Jrc3BhY2UucmV2ZWFsTGVhZihsZWFmKTtcblx0XHRcdH0sXG5cdFx0ICB9KTtcblxuXHRcdCAgY29uc29sZS5sb2coXCI9PT0zXCIpXG5cdFx0ICAqL1xuXHRcdCAgXG5cblx0XHRpZiAobmF2aWdhdG9yLmNsaXBib2FyZCkge1xuXHRcdFx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY29weScsIChldmVudDogQ2xpcGJvYXJkRXZlbnQpID0+IHtcblx0XHRcdFx0Y29uc3QgY29waWVkVGV4dCA9IGV2ZW50LmNsaXBib2FyZERhdGE/LmdldERhdGEoJ3RleHQvcGxhaW4nKTtcblx0XHRcdFx0aWYgKGNvcGllZFRleHQgIT0gbnVsbCkge1xuXHRcdFx0XHRcdHRoaXMuYWRkVG9DbGlwYm9hcmRIaXN0b3J5KGNvcGllZFRleHQpXG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdFx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY3V0JywgKGV2ZW50OiBDbGlwYm9hcmRFdmVudCkgPT4ge1xuXHRcdFx0XHRjb25zdCBjb3BpZWRUZXh0ID0gZXZlbnQuY2xpcGJvYXJkRGF0YT8uZ2V0RGF0YSgndGV4dC9wbGFpbicpO1xuXHRcdFx0XHRpZiAoY29waWVkVGV4dCAhPSBudWxsKSB7XG5cdFx0XHRcdFx0dGhpcy5hZGRUb0NsaXBib2FyZEhpc3RvcnkoY29waWVkVGV4dClcblx0XHRcdFx0fVxuXHRcdFx0ICB9KTtcblx0XHQgIH0gZWxzZSB7XG5cdFx0XHRjb25zb2xlLmxvZygnQ2xpcGJvYXJkIEFQSSBpcyBub3Qgc3VwcG9ydGVkIGluIHRoaXMgYnJvd3Nlci4nKTtcblx0XHQgIH1cblxuXHRcdFsnbicsICdsJywgJ3cnLCAnZCcsICdhJywgJzEnLCAnMicsICczJywgJzQnLCAnNScsICc2JywgJzcnXS5mb3JFYWNoKHQgPT4ge1xuXHRcdFx0dGhpcy5hZGRBY3Rpb25JY29uKHQpO1xuXHRcdFx0dGhpcy5hZGRBY3Rpb25Db21tYW5kKHQpO1xuXHRcdH0pO1xuXG5cdFx0Wyd0JywgJ20nLCAnZSddLmZvckVhY2godCA9PiB7XG5cdFx0XHR0aGlzLmFkZEFjdGlvbkljb24odCk7XG5cdFx0XHR0aGlzLmFkZEZvbGxvd1VwQ29tbWFuZCh0KTtcblx0XHR9KTtcblxuXHRcdFsnbicsICd3J10uZm9yRWFjaCh0ID0+IHtcblx0XHRcdHRoaXMuYWRkTmV3TGF0ZXJBY3Rpb25JY29uKHQpO1xuXHRcdFx0dGhpcy5hZGROZXdMYXRlckFjdGlvbih0KTtcblx0XHR9KTtcblxuXHRcdHRoaXMuYWRkQ29tbWFuZCh7XG5cdFx0XHRpZDogXCJvYnNpZGlhbi1yZW1vdmUtY2xpcGJvYXJkLWNvbnRlbnRcIixcblx0XHRcdG5hbWU6IFwiUkMgT2JzaWRpYW4gUmVtb3ZlIENsaXBib2FyZCBDb250ZW50XCIsXG5cdFx0XHRpY29uOiBcIm9ic2lkaWFuLXJlbW92ZS1jbGlwYm9hcmQtY29udGVudFwiLFxuXHRcdFx0ZWRpdG9yQ2FsbGJhY2s6IChlZGl0b3I6IEVkaXRvciwgdmlldzogTWFya2Rvd25WaWV3KSA9PiB7XG5cdFx0XHRcdG5ldyBDbGlwYm9hcmRSZW1vdmFsTW9kYWwodGhpcy5hcHAsIGVkaXRvciwgY2xpcGJvYXJkSGlzdG9yeSkub3BlbigpO1x0XHRcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdC8qXG5cdFx0dGhpcy5hZGRPYnNpZGlhbkljb24oJ29ic2lkaWFuLWNvcHknLCAnXHUyMzE4QycpO1xuXHRcdHRoaXMuYWRkQ29tbWFuZCh7XG5cdFx0XHRpZDogXCJvYnNpZGlhbi1jb3B5XCIsXG5cdFx0XHRuYW1lOiBcIk9ic2lkaWFuIENvcHlcIixcblx0XHRcdGljb246IFwib2JzaWRpYW4tY29weVwiLFxuXHRcdFx0ZWRpdG9yQ2FsbGJhY2s6IChlZGl0b3I6IEVkaXRvciwgdmlldzogTWFya2Rvd25WaWV3KSA9PiB7XG5cdFx0XHRcdGxldCBjb250ZW50ID0gZWRpdG9yLmdldFNlbGVjdGlvbigpLnRvU3RyaW5nKClcblx0XHRcdFx0aWYgKGNvbnRlbnQubGVuZ3RoID09IDApIHtcblx0XHRcdFx0XHRjb250ZW50ID0gZWRpdG9yLmdldExpbmUoZWRpdG9yLmdldEN1cnNvcigpLmxpbmUpXG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5hZGRUb0NsaXBib2FyZEhpc3RvcnkoY29udGVudCk7XG5cdFx0XHRcdG5ldyBOb3RpY2UoXCJgYGBcXG5cIiArIGNvbnRlbnQgKyBcIlxcbmBgYFxcbmlzIGNvcGllZCB0byBjbGlwYm9hcmQhXCIpXG5cdFx0XHR9LFxuXHRcdFx0aG90a2V5czogW1xuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bW9kaWZpZXJzOiBbYE1ldGFgLCBgU2hpZnRgXSxcblx0XHRcdFx0XHRrZXk6IGBjYCxcblx0XHRcdFx0fVxuXHRcdFx0XVxuXHRcdH0pO1xuXHRcdCovXG5cblx0XHQvKlxuXHRcdHRoaXMuYWRkT2JzaWRpYW5JY29uKCdvYnNpZGlhbi1jdXQnLCAnXHUyMzE4WCcpO1xuXHRcdHRoaXMuYWRkQ29tbWFuZCh7XG5cdFx0XHRpZDogXCJvYnNpZGlhbi1jdXRcIixcblx0XHRcdG5hbWU6IFwiT2JzaWRpYW4gQ3V0XCIsXG5cdFx0XHRpY29uOiBcIm9ic2lkaWFuLWN1dFwiLFxuXHRcdFx0ZWRpdG9yQ2FsbGJhY2s6IChlZGl0b3I6IEVkaXRvciwgdmlldzogTWFya2Rvd25WaWV3KSA9PiB7XG5cdFx0XHRcdGxldCBjb250ZW50ID0gZWRpdG9yLmdldFNlbGVjdGlvbigpLnRvU3RyaW5nKClcblx0XHRcdFx0aWYgKGNvbnRlbnQubGVuZ3RoID09IDApIHtcblx0XHRcdFx0XHRjb250ZW50ID0gZWRpdG9yLmdldExpbmUoZWRpdG9yLmdldEN1cnNvcigpLmxpbmUpXG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5hZGRUb0NsaXBib2FyZEhpc3RvcnkoY29udGVudCk7XG5cdFx0XHRcdGVkaXRvci5yZXBsYWNlU2VsZWN0aW9uKFwiXCIpXG5cdFx0XHRcdG5ldyBOb3RpY2UoXCJgYGBcXG5cIiArIGNvbnRlbnQgKyBcIlxcbmBgYFxcbmlzIGN1dCB0byBjbGlwYm9hcmQhXCIpXG5cdFx0XHR9LFxuXHRcdFx0aG90a2V5czogW1xuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bW9kaWZpZXJzOiBbYE1ldGFgLCBgU2hpZnRgXSxcblx0XHRcdFx0XHRrZXk6IGB4YCxcblx0XHRcdFx0fVxuXHRcdFx0XVxuXHRcdH0pO1xuXHQqL1xuXG5cdFx0dGhpcy5hZGRDb21tYW5kKHtcblx0XHRcdGlkOiBcIm9wZW4tdGFnLXNlYXJjaFwiLFxuXHRcdFx0bmFtZTogXCJPcGVuIHRhZyBzZWFyY2hcIixcblx0XHRcdGljb246IFwiaGFzaFwiLFxuXHRcdFx0Y2FsbGJhY2s6ICgpID0+IHtcblx0XHRcdFx0LyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSAqL1xuXHRcdFx0XHRjb25zdCBzZWFyY2hQbHVnaW4gPSAoXG5cdFx0XHRcdFx0dGhpcy5hcHAgYXMgYW55XG5cdFx0XHRcdCkuaW50ZXJuYWxQbHVnaW5zLmdldFBsdWdpbkJ5SWQoXCJnbG9iYWwtc2VhcmNoXCIpO1xuXHRcdFx0XHQvKiBlc2xpbnQtZW5hYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnkgKi9cblx0XHRcdFx0Y29uc3Qgc2VhcmNoID0gc2VhcmNoUGx1Z2luICYmIHNlYXJjaFBsdWdpbi5pbnN0YW5jZTtcblxuXHRcdFx0XHRpZiAoc2VhcmNoUGx1Z2luICYmIHNlYXJjaFBsdWdpbi5pbnN0YW5jZSkge1xuXHRcdFx0XHRcdG5ldyBUYWdTZWFyY2hNb2RhbCh0aGlzLmFwcCwgc2VhcmNoKS5vcGVuKCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0bmV3IE5vdGljZShcIlBsZWFzZSBlbmFibGUgdGhlIHNlYXJjaCBjb3JlIHBsdWdpbiFcIik7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRob3RrZXlzOiBbXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRtb2RpZmllcnM6IFtgQ3RybGAsIGBNZXRhYCwgYFNoaWZ0YF0sXG5cdFx0XHRcdFx0a2V5OiBgc2AsXG5cdFx0XHRcdH0sXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRtb2RpZmllcnM6IFtgQ3RybGAsIGBBbHRgLCBgU2hpZnRgXSxcblx0XHRcdFx0XHRrZXk6IGBzYCxcblx0XHRcdFx0fSxcblx0XHRcdF1cblx0XHR9KTtcblxuXHRcdHRoaXMuYWRkT2JzaWRpYW5JY29uKCdvYnNpZGlhbi1wYXN0ZScsICdcdTIzMThWJyk7XG5cdFx0dGhpcy5hZGRDb21tYW5kKHtcblx0XHRcdGlkOiBcIm9ic2lkaWFuLXBhc3RlXCIsXG5cdFx0XHRuYW1lOiBcIk9ic2lkaWFuIFBhc3RlXCIsXG5cdFx0XHRpY29uOiBcIm9ic2lkaWFuLXBhc3RlXCIsXG5cdFx0XHRlZGl0b3JDYWxsYmFjazogKGVkaXRvcjogRWRpdG9yLCB2aWV3OiBNYXJrZG93blZpZXcpID0+IHtcblx0XHRcdFx0bmV3IENsaXBib2FyZFBhc3RlTW9kYWwodGhpcy5hcHAsIGVkaXRvciwgY2xpcGJvYXJkSGlzdG9yeSkub3BlbigpO1x0XHRcblx0XHRcdH0sXG5cdFx0XHRob3RrZXlzOiBbXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRtb2RpZmllcnM6IFtgTWV0YWAsIGBTaGlmdGBdLFxuXHRcdFx0XHRcdGtleTogYHZgLFxuXHRcdFx0XHR9XG5cdFx0XHRdXG5cdFx0fSk7XG5cblx0XHR0aGlzLmFkZE9ic2lkaWFuSWNvbigndXBkYXRlLW5vdGUtdHlwZS1pY29uJywgJ05UJyk7XG5cdFx0dGhpcy5hZGRDb21tYW5kKHtcblx0XHRcdGlkOiBcInVwZGF0ZS1ub3RlLXR5cGVcIixcblx0XHRcdG5hbWU6IFwiVXBkYXRlIE5vdGUgVHlwZVwiLFxuXHRcdFx0aWNvbjogYHVwZGF0ZS1ub3RlLXR5cGUtaWNvbmAsXG5cdFx0XHRlZGl0b3JDYWxsYmFjazogKGVkaXRvcjogRWRpdG9yLCB2aWV3OiBNYXJrZG93blZpZXcpID0+IHtcblx0XHRcdCAgbmV3IFVwZGF0ZU5vdGVUeXBlTW9kYWwodGhpcy5hcHAsIGVkaXRvciwgdmlldy5maWxlKS5vcGVuKCk7XG5cdFx0XHR9LFxuXHRcdFx0aG90a2V5czogW1xuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bW9kaWZpZXJzOiBbYEN0cmxgLCBgTWV0YWAsIGBTaGlmdGBdLFxuXHRcdFx0XHRcdGtleTogYGNgLFxuXHRcdFx0XHR9LFxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bW9kaWZpZXJzOiBbYEN0cmxgLCBgQWx0YCwgYFNoaWZ0YF0sXG5cdFx0XHRcdFx0a2V5OiBgY2AsXG5cdFx0XHRcdH0sXG5cdFx0XHRdXG5cdFx0fSk7XG5cblxuXHRcdC8vIGNvbWJpbmVkIHZlcnNpb25cblx0XHQvL3RoaXMudXBkYXRlU2NoZWR1bGluZ0ljb24oKVxuXHRcdHRoaXMuYWRkQ29tbWFuZCh7XG5cdFx0XHRpZDogXCJvcGVuLXJlY2VudC1kYXlzLXNjaGVkdWxlLXdpdGgtdXBkYXRlZC1zY2hlZHVsZVwiLFxuXHRcdFx0bmFtZTogXCJPUiBPcGVuIFJlY2VudCBEYXlzIFVwZGF0ZWQgU2NoZWR1bGVcIixcblx0XHRcdGljb246IFwib3Blbi1yZWNlbnQtZGF5LXNjaGVkdWxlLWljb25cIixcblx0XHRcdGNhbGxiYWNrOiBhc3luYyAoKSA9PiB7XG5cdFx0XHRcdC8vIHVwZGF0ZSBzY2hlZHVsaW5nIHBhcnRcblx0XHRcdFx0Y29uc3QgeyB2YXVsdCB9ID0gdGhpcy5hcHA7XG5cdFx0XHRcdGNvbnN0IHNjaGVkdWxlTm90ZVdpdGhvdXRNZCA9IFwiRC9TY2hlZHVsaW5nXCJcblx0XHRcdFx0Y29uc3Qgc2NoZWR1bGVOb3RlID0gYCR7c2NoZWR1bGVOb3RlV2l0aG91dE1kfS5tZGBcdFx0XHRcdFxuXHRcdFx0XHRpZiAodmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKHNjaGVkdWxlTm90ZSkgPT0gbnVsbCkge1xuXHRcdFx0XHRcdGF3YWl0IHZhdWx0LmNyZWF0ZShzY2hlZHVsZU5vdGUsIFwiXCIpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGxldCBub3RlQ29udGVudCA9ICcnXG5cdFx0XHRcdEFycmF5LmZyb20oQXJyYXkoNykua2V5cygpKS5mb3JFYWNoKGkgPT4gbm90ZUNvbnRlbnQgKz0gdGhpcy5nZXRRdWVyeURhdGVTdHJpbmcoaSwgc2NoZWR1bGVOb3RlV2l0aG91dE1kKSk7XG5cdFx0XHRcdHZhdWx0Lm1vZGlmeSh2YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgoc2NoZWR1bGVOb3RlKSBhcyBURmlsZSwgbm90ZUNvbnRlbnQpO1xuXG5cdFx0XHRcdHRoaXMuYWRkQWN0aW9uTm90ZUNvbnRlbnQodmF1bHQsIFwiRFwiLCBcIlF1ZXJ5IFcgbm93IGFjdGlvbnNcIiwgXCJXZWVrbHkgU2NoZWR1bGUgV1wiLCBcIndcIilcblx0XHRcdFx0dGhpcy5hZGRBY3Rpb25Ob3RlQ29udGVudCh2YXVsdCwgXCJEXCIsIFwiUXVlcnkgTiBub3cgYWN0aW9uc1wiLCBcIldlZWtseSBTY2hlZHVsZSBOXCIsIFwiblwiKVxuXHRcdFx0XHR0aGlzLmFkZDNEYXlzQWN0aW9uTm90ZUNvbnRlbnQodmF1bHQpO1xuXHRcdFx0XHRuZXcgTm90aWNlKFwiVXBkYXRlZCBzY2hlZHVsZVwiKTtcblxuXHRcdFx0XHQvLyBvcGVuIHNjaGVkdWxlIHBhcnRcblx0XHRcdFx0Y29uc3QgeyB3b3Jrc3BhY2UgfSA9IHRoaXMuYXBwO1xuXHRcdFx0XHRjb25zdCBkYXNoYm9hcmRDYW52YXMgPSBcIkQvUXVlcnkgU2NoZWR1bGUgYW5kIEFjdGlvbnMgbmV4dCAzIGRheXMubWRcIlxuXHRcdFx0XHRjb25zdCBtb2RlID0gKHRoaXMuYXBwLnZhdWx0IGFzIGFueSkuZ2V0Q29uZmlnKFwiZGVmYXVsdFZpZXdNb2RlXCIpO1xuXHRcdFx0XHRjb25zdCBsZWFmID0gd29ya3NwYWNlLmdldExlYWYoZmFsc2UpO1xuXHRcdFx0XHRhd2FpdCBsZWFmLm9wZW5GaWxlKHZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aChkYXNoYm9hcmRDYW52YXMpIGFzIFRGaWxlLCB7IGFjdGl2ZSA6IHRydWUsLyogbW9kZSAqL30pO1xuXHRcdFx0fVxuXHRcdH0pXG5cblx0XHR0aGlzLmFkZE9ic2lkaWFuSWNvbigndXBkYXRlLXNjaGVkdWxpbmctaWNvbicsICdVUycpO1xuXHRcdHRoaXMuYWRkQ29tbWFuZCh7XG5cdFx0XHRpZDogXCJ1cGRhdGUtc2NoZWR1bGluZ1wiLFxuXHRcdFx0bmFtZTogXCJVcGRhdGUgU2NoZWR1bGluZ1wiLFxuXHRcdFx0aWNvbjogXCJ1cGRhdGUtc2NoZWR1bGluZy1pY29uXCIsXG5cdFx0XHRjYWxsYmFjazogYXN5bmMgKCkgPT4ge1xuXHRcdFx0XHRjb25zdCB7IHZhdWx0IH0gPSB0aGlzLmFwcDtcblx0XHRcdFx0Y29uc3Qgc2NoZWR1bGVOb3RlV2l0aG91dE1kID0gXCJEL1NjaGVkdWxpbmdcIlxuXHRcdFx0XHRjb25zdCBzY2hlZHVsZU5vdGUgPSBgJHtzY2hlZHVsZU5vdGVXaXRob3V0TWR9Lm1kYFx0XHRcdFx0XG5cdFx0XHRcdGlmICh2YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgoc2NoZWR1bGVOb3RlKSA9PSBudWxsKSB7XG5cdFx0XHRcdFx0YXdhaXQgdmF1bHQuY3JlYXRlKHNjaGVkdWxlTm90ZSwgXCJcIik7XG5cdFx0XHRcdH1cblx0XHRcdFx0bGV0IG5vdGVDb250ZW50ID0gJydcblx0XHRcdFx0QXJyYXkuZnJvbShBcnJheSg3KS5rZXlzKCkpLmZvckVhY2goaSA9PiBub3RlQ29udGVudCArPSB0aGlzLmdldFF1ZXJ5RGF0ZVN0cmluZyhpLCBzY2hlZHVsZU5vdGVXaXRob3V0TWQpKTtcblx0XHRcdFx0dmF1bHQubW9kaWZ5KHZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aChzY2hlZHVsZU5vdGUpIGFzIFRGaWxlLCBub3RlQ29udGVudCk7XG5cblx0XHRcdFx0dGhpcy5hZGRBY3Rpb25Ob3RlQ29udGVudCh2YXVsdCwgXCJEXCIsIFwiUXVlcnkgVyBub3cgYWN0aW9uc1wiLCBcIldlZWtseSBTY2hlZHVsZSBXXCIsIFwid1wiKVxuXHRcdFx0XHR0aGlzLmFkZEFjdGlvbk5vdGVDb250ZW50KHZhdWx0LCBcIkRcIiwgXCJRdWVyeSBOIG5vdyBhY3Rpb25zXCIsIFwiV2Vla2x5IFNjaGVkdWxlIE5cIiwgXCJuXCIpXG5cdFx0XHRcdHRoaXMuYWRkM0RheXNBY3Rpb25Ob3RlQ29udGVudCh2YXVsdCk7XG5cdFx0XHRcdG5ldyBOb3RpY2UoXCJVcGRhdGVkIHNjaGVkdWxlXCIpO1xuXHRcdFx0fS8qLFxuXHRcdFx0aG90a2V5czogW1xuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bW9kaWZpZXJzOiBbYEN0cmxgLCBgTWV0YWAsIGBTaGlmdGBdLFxuXHRcdFx0XHRcdGtleTogYHVgLFxuXHRcdFx0XHR9LFxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bW9kaWZpZXJzOiBbYEN0cmxgLCBgQWx0YCwgYFNoaWZ0YF0sXG5cdFx0XHRcdFx0a2V5OiBgdWAsXG5cdFx0XHRcdH0sXG5cdFx0XHRdKi9cblx0XHR9KVxuXG5cdFx0Lypcblx0XHR0aGlzLmFkZE9ic2lkaWFuSWNvbignb3Blbi1kYXNoYm9hcmQtaWNvbicsICdPRCcpO1xuXHRcdHRoaXMuYWRkQ29tbWFuZCh7XG5cdFx0XHRpZDogXCJvcGVuLWRhc2hib2FyZFwiLFxuXHRcdFx0bmFtZTogXCJPcGVuIERhc2hib2FyZFwiLFxuXHRcdFx0aWNvbjogXCJvcGVuLWRhc2hib2FyZC1pY29uXCIsXG5cdFx0XHRjYWxsYmFjazogYXN5bmMgKCkgPT4ge1xuXHRcdFx0XHRjb25zdCB7IHZhdWx0IH0gPSB0aGlzLmFwcDtcblx0XHRcdFx0Y29uc3QgeyB3b3Jrc3BhY2UgfSA9IHRoaXMuYXBwO1xuXHRcdFx0XHRjb25zdCBkYXNoYm9hcmRDYW52YXMgPSBcIkQvRGFzaGJvYXJkLmNhbnZhc1wiXG5cdFx0XHRcdGNvbnN0IG1vZGUgPSAodGhpcy5hcHAudmF1bHQgYXMgYW55KS5nZXRDb25maWcoXCJkZWZhdWx0Vmlld01vZGVcIik7XG5cdFx0XHRcdGNvbnN0IGxlYWYgPSB3b3Jrc3BhY2UuZ2V0TGVhZihmYWxzZSk7XG5cdFx0XHRcdGF3YWl0IGxlYWYub3BlbkZpbGUodmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKGRhc2hib2FyZENhbnZhcykgYXMgVEZpbGUsIHsgYWN0aXZlIDogdHJ1ZX0pO1xuXHRcdFx0fSxcblx0XHR9KVxuXHRcdCovXG5cblx0XHR0aGlzLmFkZE9ic2lkaWFuSWNvbignb3Blbi1yZWNlbnQtZGF5LXNjaGVkdWxlLWljb24nLCAnT1InKTtcblx0XHR0aGlzLmFkZENvbW1hbmQoe1xuXHRcdFx0aWQ6IFwib3Blbi1yZWNlbnQtZGF5cy1zY2hlZHVsZVwiLFxuXHRcdFx0bmFtZTogXCJPcGVuIFJlY2VudCBEYXlzIFNjaGVkdWxlXCIsXG5cdFx0XHRpY29uOiBcIm9wZW4tcmVjZW50LWRheS1zY2hlZHVsZS1pY29uXCIsXG5cdFx0XHRjYWxsYmFjazogYXN5bmMgKCkgPT4ge1xuXHRcdFx0XHRjb25zdCB7IHZhdWx0LCB3b3Jrc3BhY2UgfSA9IHRoaXMuYXBwO1xuXHRcdFx0XHRjb25zdCBkYXNoYm9hcmRDYW52YXMgPSBcIkQvUXVlcnkgU2NoZWR1bGUgYW5kIEFjdGlvbnMgbmV4dCAzIGRheXMubWRcIlxuXHRcdFx0XHRjb25zdCBsZWFmID0gd29ya3NwYWNlLmdldExlYWYoZmFsc2UpO1xuXHRcdFx0XHRhd2FpdCBsZWFmLm9wZW5GaWxlKHZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aChkYXNoYm9hcmRDYW52YXMpIGFzIFRGaWxlLCB7IGFjdGl2ZSA6IHRydWUgfSk7XG5cdFx0XHR9LFxuXHRcdH0pXG5cblx0XHR0aGlzLmFkZE9ic2lkaWFuSWNvbignb3Blbi1pbmJveC1pY29uJywgJ09JJyk7XG5cdFx0dGhpcy5hZGRDb21tYW5kKHtcblx0XHRcdGlkOiBcIm9wZW4taW5ib3hcIixcblx0XHRcdG5hbWU6IFwiT0kgT3BlbiBJbmJveFwiLFxuXHRcdFx0aWNvbjogXCJvcGVuLWluYm94LWljb25cIixcblx0XHRcdGNhbGxiYWNrOiBhc3luYyAoKSA9PiB7XG5cdFx0XHRcdGNvbnN0IHsgdmF1bHQsIHdvcmtzcGFjZSB9ID0gdGhpcy5hcHA7XG5cdFx0XHRcdGNvbnN0IGluYm94TWQgPSBcIkkvSW5ib3gubWRcIlxuXHRcdFx0XHRjb25zdCBsZWFmID0gd29ya3NwYWNlLmdldExlYWYoZmFsc2UpO1xuXHRcdFx0XHRhd2FpdCBsZWFmLm9wZW5GaWxlKHZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aChpbmJveE1kKSBhcyBURmlsZSwgeyBhY3RpdmUgOiB0cnVlIH0pO1xuXHRcdFx0fSxcblx0XHR9KVxuXG5cdFx0dGhpcy5hZGRPYnNpZGlhbkljb24oJ29wZW4tcGxheWdyb3VuZC1pY29uJywgJ09QJyk7XG5cdFx0dGhpcy5hZGRDb21tYW5kKHtcblx0XHRcdGlkOiBcIm9wZW4tcGxheWdyb3VuZFwiLFxuXHRcdFx0bmFtZTogXCJPUCBPcGVuIFBsYXlncm91bmRcIixcblx0XHRcdGljb246IFwib3Blbi1wbGF5Z3JvdW5kLWljb25cIixcblx0XHRcdGNhbGxiYWNrOiBhc3luYyAoKSA9PiB7XG5cdFx0XHRcdG5ldyBPcGVuUGxheWdyb3VuZE1vZGFsKHRoaXMuYXBwKS5vcGVuKClcblx0XHRcdH0sXG5cdFx0XHRob3RrZXlzOiBbXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRtb2RpZmllcnM6IFtgQ3RybGAsIGBNZXRhYCwgYFNoaWZ0YF0sXG5cdFx0XHRcdFx0a2V5OiBgcGAsXG5cdFx0XHRcdH0sXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRtb2RpZmllcnM6IFtgQ3RybGAsIGBBbHRgLCBgU2hpZnRgXSxcblx0XHRcdFx0XHRrZXk6IGBwYCxcblx0XHRcdFx0fSxcblx0XHRcdF1cblx0XHR9KVxuXG5cdFx0dGhpcy5hZGRPYnNpZGlhbkljb24oJ29wZW4tYnJhaW5kdW1wLWljb24nLCAnT0InKTtcblx0XHR0aGlzLmFkZENvbW1hbmQoe1xuXHRcdFx0aWQ6IFwib3Blbi1icmFpbmR1bXBcIixcblx0XHRcdG5hbWU6IFwiT0IgT3BlbiBCcmFpbkR1bXBcIixcblx0XHRcdGljb246IFwib3Blbi1icmFpbmR1bXAtaWNvblwiLFxuXHRcdFx0Y2FsbGJhY2s6IGFzeW5jICgpID0+IHtcblx0XHRcdFx0Y29uc3QgeyB2YXVsdCwgd29ya3NwYWNlIH0gPSB0aGlzLmFwcDtcblx0XHRcdFx0Y29uc3QgaW5ib3hNZCA9IFwiSS9CcmFpbiBEdW1wLm1kXCJcblx0XHRcdFx0Y29uc3QgbGVhZiA9IHdvcmtzcGFjZS5nZXRMZWFmKGZhbHNlKTtcblx0XHRcdFx0YXdhaXQgbGVhZi5vcGVuRmlsZSh2YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgoaW5ib3hNZCkgYXMgVEZpbGUsIHsgYWN0aXZlIDogdHJ1ZSB9KTtcblx0XHRcdH0sXG5cdFx0fSlcblxuXHRcdC8qXG5cdFx0dGhpcy5hZGRDb21tYW5kKHtcblx0XHRcdGlkOiBcIm9wZW4tYWN0aW9uc1wiLFxuXHRcdFx0bmFtZTogXCJPcGVuIEFjdGlvbnNcIixcblx0XHRcdGljb246IGBhcGVydHVyZWAsXG5cdFx0XHRlZGl0b3JDYWxsYmFjazogKGVkaXRvcjogRWRpdG9yLCB2aWV3OiBNYXJrZG93blZpZXcpID0+IHtcblx0XHRcdCAgbmV3IE9wZW5BY3Rpb25zTW9kYWwodGhpcy5hcHApLm9wZW4oKTtcblx0XHRcdH0sXG5cdFx0XHRob3RrZXlzOiBbXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRtb2RpZmllcnM6IFtgQ3RybGAsIGBNZXRhYCwgYFNoaWZ0YF0sXG5cdFx0XHRcdFx0a2V5OiBgeGAsXG5cdFx0XHRcdH0sXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRtb2RpZmllcnM6IFtgQ3RybGAsIGBBbHRgLCBgU2hpZnRgXSxcblx0XHRcdFx0XHRrZXk6IGB4YCxcblx0XHRcdFx0fSxcblx0XHRcdF1cblx0XHR9KTtcblx0XHQqL1xuXG5cdFx0Ly8gVE9ETyByZW1vdmUgYWZ0ZXIgVFcgbWlncmF0ZSBmaW5pc2hcblx0XHR0aGlzLmFkZE9ic2lkaWFuSWNvbignZm9ybWF0LWFsbC1ub3Rlcy1jdXN0b20nLCAnRkEnKTtcblx0XHR0aGlzLmFkZENvbW1hbmQoe1xuXHRcdFx0aWQ6IFwiZm9ybWF0LWFsbC1ub3Rlcy1jdXN0b21cIixcblx0XHRcdG5hbWU6IFwiRkEgRm9ybWF0IEFsbCBOb3RlcyAoQ3VzdG9tIHVzYWdlKVwiLFxuXHRcdFx0aWNvbjogYGZvcm1hdC1hbGwtbm90ZXMtY3VzdG9tYCxcblx0XHRcdGNhbGxiYWNrOiBhc3luYyAoKSA9PiB7XG5cdFx0XHRcdGNvbnN0IHZhdWx0OiBWYXVsdCA9IHRoaXMuYXBwLnZhdWx0O1xuXHRcdFx0XHRcblx0XHRcdFx0bGV0IHN0YXJ0Q291bnQgPSAwXG5cdFx0XHRcdGxldCBmaW5pc2hlZENvdW50ID0gMFxuXHRcdFx0XHRjb25zdCBmaWxlcyA9IHZhdWx0LmdldE1hcmtkb3duRmlsZXMoKVxuXHRcdFx0XHRuZXcgTm90aWNlKFwiYWxsPVwiICsgZmlsZXMubGVuZ3RoKVxuXHRcdFx0XHRjb25zb2xlLmxvZyhcImFsbD1cIiArIGZpbGVzLmxlbmd0aClcblx0XHRcdFx0Zm9yIChjb25zdCBmaWxlIG9mIGZpbGVzKSB7XG5cdFx0XHRcdFx0Ly8gbm90ZSB0aGF0IHN0aWxsIGFzeW5jXG5cdFx0XHRcdFx0Y29uc29sZS5sb2coXCJzOiBcIiArIHN0YXJ0Q291bnQpXG5cdFx0XHRcdFx0dmF1bHQucmVhZChmaWxlKS50aGVuKChjb250ZW50KSA9PiB7XG5cdFx0XHRcdFx0XHRjb25zdCBtb2RpZmllZFZhbHVlID0gdGhpcy50aWR5VXBGcm9udE1hdHRlck9uVmFsdWUoY29udGVudClcblx0XHRcdFx0XHRcdHJldHVybiB2YXVsdC5tb2RpZnkoZmlsZSwgbW9kaWZpZWRWYWx1ZSk7XG5cdFx0XHRcdFx0fSkudGhlbigoKSA9PiB7XG5cdFx0XHRcdFx0XHRjb25zb2xlLmxvZyhcImY6IFwiICsgZmluaXNoZWRDb3VudClcblx0XHRcdFx0XHRcdGZpbmlzaGVkQ291bnQrK1xuXHRcdFx0XHRcdFx0aWYgKGZpbmlzaGVkQ291bnQgPT0gZmlsZXMubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRcdGNvbnNvbGUubG9nKFwiZmluaXNoZWRcIilcblx0XHRcdFx0XHRcdFx0bmV3IE5vdGljZShcImZpbmlzaGVkXCIpXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSlcblx0XHRcdFx0XHRzdGFydENvdW50Kytcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGhvdGtleXM6IFtcblx0XHRcdFx0e1xuXHRcdFx0XHRcdG1vZGlmaWVyczogW2BDdHJsYCwgYE1ldGFgLCBgU2hpZnRgXSxcblx0XHRcdFx0XHRrZXk6IGAxYCxcblx0XHRcdFx0fSxcblx0XHRcdFx0e1xuXHRcdFx0XHRcdG1vZGlmaWVyczogW2BDdHJsYCwgYEFsdGAsIGBTaGlmdGBdLFxuXHRcdFx0XHRcdGtleTogYDFgLFxuXHRcdFx0XHR9LFxuXHRcdFx0XVxuXHRcdH0pO1xuXG5cdFx0Ly8gVE9ETyByZW1vdmUgYWZ0ZXIgVFcgbWlncmF0ZSBmaW5pc2hcblx0XHR0aGlzLmFkZE9ic2lkaWFuSWNvbignZm9ybWF0LW5vdGVzLWN1c3RvbScsICdGTicpO1xuXHRcdHRoaXMuYWRkQ29tbWFuZCh7XG5cdFx0XHRpZDogXCJmb3JtYXQtbm90ZXMtY3VzdG9tXCIsXG5cdFx0XHRuYW1lOiBcIkZOIEZvcm1hdCBOb3RlcyAoQ3VzdG9tIHVzYWdlKVwiLFxuXHRcdFx0aWNvbjogYGZvcm1hdC1ub3Rlcy1jdXN0b21gLFxuXHRcdFx0ZWRpdG9yQ2FsbGJhY2s6IChlZGl0b3I6IEVkaXRvciwgdmlldzogTWFya2Rvd25WaWV3KSA9PiB7XG5cdFx0XHRcdHRoaXMudGlkeVVwRnJvbnRNYXR0ZXJvbkVkaXRvcihlZGl0b3IpXG5cdFx0XHR9LFxuXHRcdFx0aG90a2V5czogW1xuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bW9kaWZpZXJzOiBbYEN0cmxgLCBgTWV0YWAsIGBTaGlmdGBdLFxuXHRcdFx0XHRcdGtleTogYDJgLFxuXHRcdFx0XHR9LFxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bW9kaWZpZXJzOiBbYEN0cmxgLCBgQWx0YCwgYFNoaWZ0YF0sXG5cdFx0XHRcdFx0a2V5OiBgMmAsXG5cdFx0XHRcdH0sXG5cdFx0XHRdXG5cdFx0fSk7XG5cbi8vIFRPRE8gcmVtb3ZlIGFmdGVyIFRXIG1pZ3JhdGUgZmluaXNoXG50aGlzLmFkZE9ic2lkaWFuSWNvbigndHctZ2V0LXBhcmVudC1saW5rJywgJ1tdJyk7XG50aGlzLmFkZENvbW1hbmQoe1xuXHRpZDogXCJ0dy1nZXQtcGFyZW50LWxpbmtcIixcblx0bmFtZTogXCJ0dy1nZXQtcGFyZW50LWxpbmtcIixcblx0aWNvbjogYHR3LWdldC1wYXJlbnQtbGlua2AsXG5cdGVkaXRvckNhbGxiYWNrOiAoZWRpdG9yOiBFZGl0b3IsIHZpZXc6IE1hcmtkb3duVmlldykgPT4ge1xuXHRcdC8vIGV4YW1wbGUgY3Vyc29yIGxpbmUgaXMgZWl0aGVyIG9uZSBvZiBmb2xsb3dpbmc6XG5cdFx0Ly8gcGFyZW50MTogXCJbW0lUSVZJVEkgXyBBU1ggVHJhZGluZ11dXCJcblx0XHQvLyAtIHBhcmVudDE6IFwiW1tJVElWSVRJIF8gQVNYIFRyYWRpbmddXVwiXG5cdFx0Ly8gZ29hbCBpcyB0byBjb3B5IFwiSVRJVklUSSBfIEFTWCBUcmFkaW5nXCIgdG8gY2xpcGJvYXJkIGFuZCByZW1vdmUgdGhpcyBsaW5lXG5cdFx0Y29uc3QgY3Vyc29yID0gZWRpdG9yLmdldEN1cnNvcigpXG5cdFx0Y29uc3QgbGluZSA9IGN1cnNvci5saW5lXG5cdFx0Y29uc3QgY2ggPSBjdXJzb3IuY2hcblx0XHRjb25zdCBsaW5lQ29udGVudCA9IGVkaXRvci5nZXRMaW5lKGxpbmUpXG5cdFx0aWYgKC9ecGFyZW50XFxkKzogLy50ZXN0KGxpbmVDb250ZW50KSB8fCAvXlxcdCstIHBhcmVudFxcZCs6IC8udGVzdChsaW5lQ29udGVudCkpIHtcblx0XHRcdGNvbnN0IHBhcmVudExpbmsgPSBsaW5lQ29udGVudC5yZXBsYWNlKC9ecGFyZW50XFxkKzogLywgXCJcIikucmVwbGFjZSgvXlxcdCstIHBhcmVudFxcZCs6IC8sIFwiXCIpLnJlcGxhY2UoL1wiL2csIFwiXCIpLnJlcGxhY2UoL1xcW1xcWy8sIFwiXCIpLnJlcGxhY2UoL1xcXVxcXS8sIFwiXCIpXG5cdFx0XHRuYXZpZ2F0b3IuY2xpcGJvYXJkLndyaXRlVGV4dChwYXJlbnRMaW5rKS50aGVuKCgpID0+IHtcblx0XHRcdFx0ZWRpdG9yLnJlcGxhY2VSYW5nZShcIlwiLCB7bGluZTogbGluZSwgY2g6IDB9LCB7bGluZTogbGluZSwgY2g6IGxpbmVDb250ZW50Lmxlbmd0aH0pXG5cdFx0XHR9KVxuXHRcdH1cblx0fSxcblx0aG90a2V5czogW1xuXHRcdHtcblx0XHRcdG1vZGlmaWVyczogW2BDdHJsYCwgYE1ldGFgLCBgU2hpZnRgXSxcblx0XHRcdGtleTogYDdgLFxuXHRcdH0sXG5cdFx0e1xuXHRcdFx0bW9kaWZpZXJzOiBbYEN0cmxgLCBgQWx0YCwgYFNoaWZ0YF0sXG5cdFx0XHRrZXk6IGA3YCxcblx0XHR9LFxuXHRdXG59KTtcblxuXG4vLyBUT0RPIHJlbW92ZSBhZnRlciBUVyBtaWdyYXRlIGZpbmlzaFxudGhpcy5hZGRPYnNpZGlhbkljb24oJ3R3LXRhc2snLCAnLS0nKTtcbnRoaXMuYWRkQ29tbWFuZCh7XG5cdGlkOiBcInR3LXRhc2tcIixcblx0bmFtZTogXCJUVCBUVyBUYXNrXCIsXG5cdGljb246IGB0dy10YXNrYCxcblx0ZWRpdG9yQ2FsbGJhY2s6IChlZGl0b3I6IEVkaXRvciwgdmlldzogTWFya2Rvd25WaWV3KSA9PiB7XG5cdFx0Y29uc3QgY2hlY2tib3hNYXAgPSBuZXcgTWFwPHN0cmluZywgc3RyaW5nPigpO1xuXHRcdGNvbnN0IGxpbmVDb3VudCA9IGVkaXRvci5saW5lQ291bnQoKVxuXG5cdFx0bGV0IGZtID0gXCJcIlxuXHRcdGxldCBjID0gXCJcIlxuXHRcdGxldCB0ZXh0ID0gXCJcIlxuXHRcdGxldCBoM0NvdW50ID0gMDtcblx0XHRsZXQgY29udGVudCA9IFwiXCJcblx0XHRsZXQgdGFza1RhZyA9IFwiXCJcblx0XHQvL2xldCBwYXJlbnQgPSBcIlwiXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lQ291bnQ7IGkrKykge1xuXHRcdFx0Y29uc3QgbGluZSA9IGVkaXRvci5nZXRMaW5lKGkpXG5cdFx0XHRpZiAoaDNDb3VudCA9PSAwKSB7XG5cdFx0XHRcdGNvbnRlbnQgKz0gKGxpbmUgKyBcIlxcblwiKVxuXHRcdFx0fSBlbHNlIGlmIChoM0NvdW50ID09IDEpIHtcblx0XHRcdFx0aWYgKGxpbmUuc3RhcnRzV2l0aChcInRpdGxlOiBcIikpIHtcblx0XHRcdFx0XHQvLyBkbyBub3RoaW5nXG5cdFx0XHRcdC8vfSBlbHNlIGlmICgvXnBhcmVudFxcZCs6IC8udGVzdChsaW5lKSkge1xuXHRcdFx0XHQvL1x0cGFyZW50ICs9IChsaW5lLnJlcGxhY2UoL15wYXJlbnRcXGQrOiAvLCBcIlwiKSArIFwiIC8gXCIpXG5cdFx0XHRcdH0gZWxzZSBpZiAobGluZS5zdGFydHNXaXRoKFwidGFnc3NzOiBcIikpIHtcblx0XHRcdFx0XHR0YXNrVGFnID0gXCJhL1wiXG5cdFx0XHRcdFx0aWYgKC8gTiAvLnRlc3QobGluZSkgfHwgLyBOJC8udGVzdChsaW5lKSkge1xuXHRcdFx0XHRcdFx0dGFza1RhZyArPSBcIm4vXCJcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKC8gVyAvLnRlc3QobGluZSkgfHwgLyBXJC8udGVzdChsaW5lKSkge1xuXHRcdFx0XHRcdFx0dGFza1RhZyArPSBcIncvXCJcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKC8gbm93IC8udGVzdChsaW5lKSB8fCAvIG5vdyQvLnRlc3QobGluZSkpIHtcblx0XHRcdFx0XHRcdHRhc2tUYWcgKz0gXCJuXCJcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKC8gbGF0ZXIgLy50ZXN0KGxpbmUpIHx8IC8gbGF0ZXIkLy50ZXN0KGxpbmUpKSB7XG5cdFx0XHRcdFx0XHR0YXNrVGFnICs9IFwibFwiXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICgvIHdhaXRpbmcgLy50ZXN0KGxpbmUpIHx8IC8gd2FpdGluZyQvLnRlc3QobGluZSkpIHtcblx0XHRcdFx0XHRcdHRhc2tUYWcgKz0gXCJ3XCJcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKC8gZG9uZSAvLnRlc3QobGluZSkgfHwgLyBkb25lJC8udGVzdChsaW5lKSkge1xuXHRcdFx0XHRcdFx0dGFza1RhZyArPSBcImRcIlxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoLyBhcmNoaXZlIC8udGVzdChsaW5lKSB8fCAvIGFyY2hpbmUkLy50ZXN0KGxpbmUpKSB7XG5cdFx0XHRcdFx0XHR0YXNrVGFnICs9IFwiYVwiXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICh0YXNrVGFnLmxlbmd0aCA9PSA1KSB7XG5cdFx0XHRcdFx0XHRmbSArPSAoXCJ0YWc6IFwiICsgdGFza1RhZyArIFwiXFxuXCIpXG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdG5ldyBOb3RpY2UoXCJlcnJvciBvbiBzZXR0aW5nIGFjdGlvbiB0YWdcIilcblx0XHRcdFx0XHRcdGZtICs9IChsaW5lICsgXCJcXG5cIilcblx0XHRcdFx0XHR9XHRcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRmbSArPSAobGluZSArIFwiXFxuXCIpXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmIChoM0NvdW50ID49IDIpIHtcblx0XHRcdFx0bGV0IG1vZGlmaWVkTGluZSA9IGxpbmVcblx0XHRcdFx0YyArPSAobW9kaWZpZWRMaW5lICsgXCJcXG5cIilcblx0XHRcdH1cblx0XHRcdGlmIChsaW5lID09PSBcIi0tLVwiKSB7XG5cdFx0XHRcdGgzQ291bnQrKztcblx0XHRcdH1cblx0XHR9IFxuXHRcdHRleHQgKz0gY29udGVudFxuXHRcdGlmIChmbS5sZW5ndGggPiAwKSB7XG5cdFx0XHR0ZXh0ICs9IGZtXG5cdFx0fVxuXHRcdC8vaWYgKHBhcmVudC5sZW5ndGggPiAwKSB7XG5cdFx0Ly9cdHRleHQgKz0gXCJcXG5QYXJlbnQgbGluazogXCIgKyBwYXJlbnQgKyBcIlxcblwiXG5cdFx0Ly99XG5cdFx0dGV4dCArPSBjXG5cdFx0dGV4dCA9IHRleHQucmVwbGFjZSgvXi0tLVxcbi0tLVxcbi9tLCBcIlwiKS5yZXBsYWNlKC9cXG4kLywgXCJcIilcblx0XHRlZGl0b3Iuc2V0VmFsdWUodGV4dClcblx0fSxcblx0aG90a2V5czogW1xuXHRcdHtcblx0XHRcdG1vZGlmaWVyczogW2BDdHJsYCwgYE1ldGFgLCBgU2hpZnRgXSxcblx0XHRcdGtleTogYDdgLFxuXHRcdH0sXG5cdFx0e1xuXHRcdFx0bW9kaWZpZXJzOiBbYEN0cmxgLCBgQWx0YCwgYFNoaWZ0YF0sXG5cdFx0XHRrZXk6IGA3YCxcblx0XHR9LFxuXHRdXG59KTtcblxuXG4vKlxuXHRcdC8vIFRPRE8gcmVtb3ZlIGFmdGVyIFRXIG1pZ3JhdGUgZmluaXNoXG5cdFx0dGhpcy5hZGRPYnNpZGlhbkljb24oJ3R3LWNoZWNrYm94JywgJ1tdJyk7XG5cdFx0dGhpcy5hZGRDb21tYW5kKHtcblx0XHRcdGlkOiBcInR3LWNoZWNrYm94XCIsXG5cdFx0XHRuYW1lOiBcIkNCIFRXIENoZWNrYm94XCIsXG5cdFx0XHRpY29uOiBgdHctY2hlY2tib3hgLFxuXHRcdFx0ZWRpdG9yQ2FsbGJhY2s6IChlZGl0b3I6IEVkaXRvciwgdmlldzogTWFya2Rvd25WaWV3KSA9PiB7XG5cdFx0XHRcdGNvbnN0IGNoZWNrYm94TWFwID0gbmV3IE1hcDxzdHJpbmcsIHN0cmluZz4oKTtcblx0XHRcdFx0Y29uc3QgbGluZUNvdW50ID0gZWRpdG9yLmxpbmVDb3VudCgpXG5cblx0XHRcdFx0bGV0IGZtID0gXCJcIlxuXHRcdFx0XHRsZXQgYyA9IFwiXCJcblx0XHRcdFx0bGV0IHRleHQgPSBcIlwiXG5cdFx0XHRcdGxldCBoM0NvdW50ID0gMDtcblx0XHRcdFx0bGV0IGNvbnRlbnQgPSBcIlwiXG5cdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbGluZUNvdW50OyBpKyspIHtcblx0XHRcdFx0XHRjb25zdCBsaW5lID0gZWRpdG9yLmdldExpbmUoaSlcblx0XHRcdFx0XHRpZiAoaDNDb3VudCA9PSAwKSB7XG5cdFx0XHRcdFx0XHRjb250ZW50ICs9IChsaW5lICsgXCJcXG5cIilcblx0XHRcdFx0XHR9IGVsc2UgaWYgKGgzQ291bnQgPT0gMSkge1xuXHRcdFx0XHRcdFx0aWYgKGxpbmUuc3RhcnRzV2l0aChcImNoZWNrYm94Ynl0aW1lX1wiKSkge1xuXHRcdFx0XHRcdFx0XHRjb25zdCBrZXlWYWx1ZUFycmF5ID0gbGluZS5zcGxpdChcIjpcIikubWFwKGl0ZW0gPT4gaXRlbS50cmltKCkpO1xuXHRcdFx0XHRcdFx0XHRpZiAoa2V5VmFsdWVBcnJheS5sZW5ndGggPT09IDIpIHtcblx0XHRcdFx0XHRcdFx0XHRjb25zdCBrZXkgPSBrZXlWYWx1ZUFycmF5WzBdO1xuXHRcdFx0XHRcdFx0XHRcdGNvbnN0IHZhbHVlID0ga2V5VmFsdWVBcnJheVsxXTtcblxuXHRcdFx0XHRcdFx0XHRcdGNvbnN0IHNwbGl0QXJyYXkgPSBrZXkuc3BsaXQoXCJfXCIpO1xuXHRcdFx0XHRcdFx0XHRcdGNvbnN0IG1vZGlmaWVkS2V5ID0gYDw8Y2hlY2tib3hCeVRpbWUgXCIke3NwbGl0QXJyYXlbMV19XCI+PmA7XG5cblx0XHRcdFx0XHRcdFx0XHRjaGVja2JveE1hcC5zZXQobW9kaWZpZWRLZXksIHZhbHVlID09PSBcIm9wZW5cIiA/IFwiW3hdXCIgOiBcIlsgXVwiKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0Zm0gKz0gKGxpbmUgKyBcIlxcblwiKVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoaDNDb3VudCA+PSAyKSB7XG5cdFx0XHRcdFx0XHRsZXQgbW9kaWZpZWRMaW5lID0gbGluZVxuXG5cdFx0XHRcdFx0XHRmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBjaGVja2JveE1hcCkge1xuXHRcdFx0XHRcdFx0XHRtb2RpZmllZExpbmUgPSBtb2RpZmllZExpbmUucmVwbGFjZShuZXcgUmVnRXhwKGtleSwgXCJnXCIpLCB2YWx1ZSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRtb2RpZmllZExpbmUgPSBtb2RpZmllZExpbmUucmVwbGFjZSgvPDxjaGVja2JveEJ5VGltZSBcIltBLVphLXowLTlfXStcIj4+L2csIFwiWyBdXCIpXG5cblx0XHRcdFx0XHRcdGMgKz0gKG1vZGlmaWVkTGluZSArIFwiXFxuXCIpXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChsaW5lID09PSBcIi0tLVwiKSB7XG5cdFx0XHRcdFx0XHRoM0NvdW50Kys7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IFxuXHRcdFx0XHR0ZXh0ICs9IGNvbnRlbnRcblx0XHRcdFx0aWYgKGZtLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0XHR0ZXh0ICs9IGZtXG5cdFx0XHRcdFx0Ly90ZXh0ICs9IFwiLS0tXFxuXCIgKyBmbSArIFwiLS0tXFxuXCJcblx0XHRcdFx0fVxuXHRcdFx0XHR0ZXh0ICs9IGNcblx0XHRcdFx0XG5cdFx0XHRcdGVkaXRvci5zZXRWYWx1ZSh0ZXh0LnJlcGxhY2UoL1xcbiQvLCBcIlwiKSlcblx0XHRcdH0sXG5cdFx0XHRob3RrZXlzOiBbXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRtb2RpZmllcnM6IFtgQ3RybGAsIGBNZXRhYCwgYFNoaWZ0YF0sXG5cdFx0XHRcdFx0a2V5OiBgN2AsXG5cdFx0XHRcdH0sXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRtb2RpZmllcnM6IFtgQ3RybGAsIGBBbHRgLCBgU2hpZnRgXSxcblx0XHRcdFx0XHRrZXk6IGA3YCxcblx0XHRcdFx0fSxcblx0XHRcdF1cblx0XHR9KTtcbiovXG5cblx0XHQvLyBUT0RPIHJlbW92ZSBhZnRlciBUVyBtaWdyYXRlIGZpbmlzaFxuXHRcdHRoaXMuYWRkT2JzaWRpYW5JY29uKCdub3RlLXRvLXRyZWUtbGlzdCcsICcqKicpO1xuXHRcdHRoaXMuYWRkQ29tbWFuZCh7XG5cdFx0XHRpZDogXCJub3RlLXRvLXRyZWUtbGlzdFwiLFxuXHRcdFx0bmFtZTogXCJOVCBOb3RlIHRvIFRyZWUgTGlzdFwiLFxuXHRcdFx0aWNvbjogYG5vdGUtdG8tdHJlZS1saXN0YCxcblx0XHRcdGVkaXRvckNhbGxiYWNrOiAoZWRpdG9yOiBFZGl0b3IsIHZpZXc6IE1hcmtkb3duVmlldykgPT4ge1xuXHRcdFx0XHRjb25zdCBjaGVja2JveE1hcCA9IG5ldyBNYXA8c3RyaW5nLCBzdHJpbmc+KCk7XG5cdFx0XHRcdGNvbnN0IGxpbmVDb3VudCA9IGVkaXRvci5saW5lQ291bnQoKVxuXHRcdFx0XHRpZiAoZWRpdG9yLmdldFZhbHVlKCkuc3RhcnRzV2l0aChcIi0gXCIgKyB2aWV3LmZpbGUuYmFzZW5hbWUgKyBcIlxcblwiKSkge1xuXHRcdFx0XHRcdC8vIGFscmVhZHkgdGlkeSBvbmNlLCBoZXJlIG9ubHkgc2hvdWxkIHJlbW92ZSBlbXB0eSBsaW5lIGFuZCByZW1vdmUgZHVwbGljYXRlIGxpc3QgbmFtZSAodHcgaGllcmFyY2h5KVxuXHRcdFx0XHRcdGNvbnN0IGZpbGVuYW1lID0gdmlldy5maWxlLmJhc2VuYW1lXG5cdFx0XHRcdFx0bGV0IHRleHQgPSBcIlwiXG5cdFx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lQ291bnQ7IGkrKykge1xuXHRcdFx0XHRcdFx0Y29uc3QgbGluZSA9IGVkaXRvci5nZXRMaW5lKGkpXG5cdFx0XHRcdFx0XHRpZiAobGluZS50cmltKCkubGVuZ3RoICE9IDApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCEvXlxcdCotICQvLnRlc3QobGluZSkgJiYgIS9eXFx0KlxcZCtcXC4gJC8udGVzdChsaW5lKSkgeyAvLyBlbXB0eSBsaXN0IGl0ZW1cblx0XHRcdFx0XHRcdFx0XHRsZXQgbW9kTGluZSA9IGxpbmUucmVwbGFjZShgJHtmaWxlbmFtZX0gXyBgLCBcIlwiKVxuXHRcdFx0XHRcdFx0XHRcdGlmIChsaW5lICE9PSBgLSAke3ZpZXcuZmlsZS5iYXNlbmFtZX1gICYmIC9eLSAvLnRlc3QobGluZSkpe1xuXHRcdFx0XHRcdFx0XHRcdFx0bW9kTGluZSA9IFwiXFx0XCIgKyBtb2RMaW5lXG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdHRleHQgKz0gbW9kTGluZSArIFwiXFxuXCJcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlZGl0b3Iuc2V0VmFsdWUodGV4dC5yZXBsYWNlKC9cXG4kL20sIFwiXCIpKVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGxldCB0ZXh0ID0gXCItIFwiXG5cdFx0XHRcdFx0bGV0IGgzQ291bnQgPSAwO1xuXHRcdFx0XHRcdGxldCBhY3Rpb25UYWcgPSBcIlwiXG5cdFx0XHRcdFx0bGV0IGNvbnRlbnQgPSBcIlwiXG5cdFx0XHRcdFx0Ly9sZXQgcGFyZW50ID0gXCJcIlxuXHRcdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbGluZUNvdW50OyBpKyspIHtcblx0XHRcdFx0XHRcdGNvbnN0IGxpbmUgPSBlZGl0b3IuZ2V0TGluZShpKVxuXHRcdFx0XHRcdFx0aWYgKGgzQ291bnQgPT0gMCkge1xuXHRcdFx0XHRcdFx0XHRpZiAobGluZS50cmltKCkubGVuZ3RoICE9IDAgJiYgbGluZSAhPSBcIi0tLVwiKSB7XG5cdFx0XHRcdFx0XHRcdFx0bGV0IG1vZGlmaWVkTGluZSA9IGxpbmVcblx0XHRcdFx0XHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IDk7IGkrKykge1xuXHRcdFx0XHRcdFx0XHRcdFx0bW9kaWZpZWRMaW5lID0gbW9kaWZpZWRMaW5lLnJlcGxhY2UoL14gICAgLywgXCJcXHRcIilcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0bW9kaWZpZWRMaW5lID0gbW9kaWZpZWRMaW5lLnJlcGxhY2UoL14oXFx0KilcXCpcXHMvLCBcIiQxLSBcIilcblx0XHRcdFx0XHRcdFx0XHRtb2RpZmllZExpbmUgPSAoL15cXHQqLSAvLnRlc3QobW9kaWZpZWRMaW5lKSB8fCAvXlxcdCpcXGQrXFwuIC8udGVzdChtb2RpZmllZExpbmUpKSA/IChcIlxcdFwiICsgbW9kaWZpZWRMaW5lKSA6IChcIlxcdC0gXCIgKyBtb2RpZmllZExpbmUpXG5cdFx0XHRcdFx0XHRcdFx0Y29udGVudCArPSBcIlxcblwiICsgbW9kaWZpZWRMaW5lXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoaDNDb3VudCA9PSAxKSB7XG5cdFx0XHRcdFx0XHRcdGlmIChsaW5lID09PSBcIi0tLVwiIHx8IHRoaXMuc2hvdWxkU2tpcEZyb250TWF0dGVyKGxpbmUpIHx8IGxpbmUuc3RhcnRzV2l0aChcInRpdGxlOiBcIikpIHtcblx0XHRcdFx0XHRcdFx0Ly9cdHRleHQgKz0gbGluZS5yZXBsYWNlKFwidGl0bGU6IFwiLCBcIlwiKVxuXHRcdFx0XHRcdFx0XHQvL30gZWxzZSBpZiAoL15wYXJlbnRcXGQrOiAvLnRlc3QobGluZSkpIHtcblx0XHRcdFx0XHRcdFx0Ly9cdHBhcmVudCArPSAobGluZS5yZXBsYWNlKC9ecGFyZW50XFxkKzogLywgXCJcIikgKyBcIiAvIFwiKVxuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKGxpbmUuc3RhcnRzV2l0aChcInRhZ3NzczogXCIpKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKC8gTiAvLnRlc3QobGluZSkgfHwgLyBOJC8udGVzdChsaW5lKSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0YWN0aW9uVGFnID0gXCJuXCJcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0aWYgKC8gVyAvLnRlc3QobGluZSkgfHwgLyBXJC8udGVzdChsaW5lKSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0YWN0aW9uVGFnID0gXCJ3XCJcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0aWYgKC8gbm93IC8udGVzdChsaW5lKSB8fCAvIG5vdyQvLnRlc3QobGluZSkpIHtcblx0XHRcdFx0XHRcdFx0XHRcdGFjdGlvblRhZyArPSBcIm5cIlxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRpZiAoLyBsYXRlciAvLnRlc3QobGluZSkgfHwgLyBsYXRlciQvLnRlc3QobGluZSkpIHtcblx0XHRcdFx0XHRcdFx0XHRcdGFjdGlvblRhZyArPSBcImxcIlxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRpZiAoLyB3YWl0aW5nIC8udGVzdChsaW5lKSB8fCAvIHdhaXRpbmckLy50ZXN0KGxpbmUpKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRhY3Rpb25UYWcgKz0gXCJ3XCJcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0aWYgKC8gZG9uZSAvLnRlc3QobGluZSkgfHwgLyBkb25lJC8udGVzdChsaW5lKSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0YWN0aW9uVGFnICs9IFwiZFwiXG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdGlmICgvIGFyY2hpdmUgLy50ZXN0KGxpbmUpIHx8IC8gYXJjaGluZSQvLnRlc3QobGluZSkpIHtcblx0XHRcdFx0XHRcdFx0XHRcdGFjdGlvblRhZyArPSBcIndcIlxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRpZiAoYWN0aW9uVGFnLmxlbmd0aCA9PSAyKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRhY3Rpb25UYWcgPSBcIiNcIiArIGFjdGlvblRhZyArIFwiIFwiXG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmIChhY3Rpb25UYWcubGVuZ3RoID09IDEpIHtcblx0XHRcdFx0XHRcdFx0XHRcdG5ldyBOb3RpY2UoXCJlcnJvciBvbiBzZXR0aW5nIGFjdGlvbiB0YWdcIilcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAobGluZS5zdGFydHNXaXRoKFwiY2hlY2tib3hieXRpbWVfXCIpKSB7XG5cdFx0XHRcdFx0XHRcdFx0Y29uc3Qga2V5VmFsdWVBcnJheSA9IGxpbmUuc3BsaXQoXCI6XCIpLm1hcChpdGVtID0+IGl0ZW0udHJpbSgpKTtcblx0XHRcdFx0XHRcdFx0XHRpZiAoa2V5VmFsdWVBcnJheS5sZW5ndGggPT09IDIpIHtcblx0XHRcdFx0XHRcdFx0XHRcdGNvbnN0IGtleSA9IGtleVZhbHVlQXJyYXlbMF07XG5cdFx0XHRcdFx0XHRcdFx0XHRjb25zdCB2YWx1ZSA9IGtleVZhbHVlQXJyYXlbMV07XG5cblx0XHRcdFx0XHRcdFx0XHRcdGNvbnN0IHNwbGl0QXJyYXkgPSBrZXkuc3BsaXQoXCJfXCIpO1xuXHRcdFx0XHRcdFx0XHRcdFx0Y29uc3QgbW9kaWZpZWRLZXkgPSBgPDxjaGVja2JveEJ5VGltZSBcIiR7c3BsaXRBcnJheVsxXX1cIj4+YDtcblxuXHRcdFx0XHRcdFx0XHRcdFx0Y2hlY2tib3hNYXAuc2V0KG1vZGlmaWVkS2V5LCB2YWx1ZSA9PT0gXCJvcGVuXCIgPyBcIlt4XVwiIDogXCJbIF1cIik7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdGlmIChsaW5lLnRyaW0oKS5sZW5ndGggIT0gMCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0bGV0IG1vZGlmaWVkTGluZSA9IGxpbmVcblx0XHRcdFx0XHRcdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgOTsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG1vZGlmaWVkTGluZSA9IG1vZGlmaWVkTGluZS5yZXBsYWNlKC9eICAgIC8sIFwiXFx0XCIpXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRtb2RpZmllZExpbmUgPSBtb2RpZmllZExpbmUucmVwbGFjZSgvXihcXHQqKVxcKlxccy8sIFwiJDEtIFwiKVxuXHRcdFx0XHRcdFx0XHRcdFx0bW9kaWZpZWRMaW5lID0gKC9eXFx0Ki0gLy50ZXN0KG1vZGlmaWVkTGluZSkgfHwgL15cXHQqXFxkK1xcLiAvLnRlc3QobW9kaWZpZWRMaW5lKSkgPyAoXCJcXHRcIiArIG1vZGlmaWVkTGluZSkgOiAoXCJcXHQtIFwiICsgbW9kaWZpZWRMaW5lKVxuXHRcdFx0XHRcdFx0XHRcdFx0Y29udGVudCArPSBcIlxcblwiICsgbW9kaWZpZWRMaW5lXG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAoaDNDb3VudCA+PSAyICYmIGxpbmUudHJpbSgpLmxlbmd0aCAhPSAwKSB7XG5cdFx0XHRcdFx0XHRcdGxldCBtb2RpZmllZExpbmUgPSAobGluZSA9PT0gXCJbIF0gXCIpID8gXCJcIiA6IGxpbmVcblx0XHRcdFx0XHRcdFx0aWYgKG1vZGlmaWVkTGluZS50cmltKCkubGVuZ3RoICE9IDApIHtcblx0XHRcdFx0XHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IDk7IGkrKykge1xuXHRcdFx0XHRcdFx0XHRcdFx0bW9kaWZpZWRMaW5lID0gbW9kaWZpZWRMaW5lLnJlcGxhY2UoL14gICAgLywgXCJcXHRcIilcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0bW9kaWZpZWRMaW5lID0gbW9kaWZpZWRMaW5lLnJlcGxhY2UoL14oXFx0KilcXCpcXHMvLCBcIiQxLSBcIilcblx0XHRcdFx0XHRcdFx0XHRtb2RpZmllZExpbmUgPSAoL15cXHQqLSAvLnRlc3QobW9kaWZpZWRMaW5lKSB8fCAvXlxcdCpcXGQrXFwuIC8udGVzdChtb2RpZmllZExpbmUpKSA/IChcIlxcdFwiICsgbW9kaWZpZWRMaW5lKSA6IChcIlxcdC0gXCIgKyBtb2RpZmllZExpbmUpXG5cdFx0XHRcdFx0XHRcdFx0Ly8gbW9kaWZpZWRMaW5lID0gbGluZSA9PT0gXCItLS1cIiA/IFwiLS0tXCIgOiBtb2RpZmllZExpbmVcblxuXHRcdFx0XHRcdFx0XHRcdGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIGNoZWNrYm94TWFwKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRtb2RpZmllZExpbmUgPSBtb2RpZmllZExpbmUucmVwbGFjZShuZXcgUmVnRXhwKGtleSwgXCJnXCIpLCB2YWx1ZSk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdG1vZGlmaWVkTGluZSA9IG1vZGlmaWVkTGluZS5yZXBsYWNlKC88PGNoZWNrYm94QnlUaW1lIFwiW0EtWmEtejAtOV9dK1wiPj4vZywgXCJbIF1cIilcblxuXHRcdFx0XHRcdFx0XHRcdHRleHQgKz0gKFwiXFxuXCIgKyBtb2RpZmllZExpbmUpXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmIChsaW5lID09PSBcIi0tLVwiKSB7XG5cdFx0XHRcdFx0XHRcdGxldCBiZWZvcmVIMyA9IGgzQ291bnRcblx0XHRcdFx0XHRcdFx0aDNDb3VudCsrO1xuXHRcdFx0XHRcdFx0XHRpZiAoYmVmb3JlSDMgPT0gMSAmJiBoM0NvdW50ID09IDIpIHtcblx0XHRcdFx0XHRcdFx0XHR0ZXh0ICs9IGFjdGlvblRhZyArIHZpZXcuZmlsZS5iYXNlbmFtZVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmIChoM0NvdW50IDwgMikgeyAvLyBubyBmcm9udG1hdHRlclxuXHRcdFx0XHRcdFx0dGV4dCArPSB2aWV3LmZpbGUuYmFzZW5hbWVcblx0XHRcdFx0XHR9IFxuXHRcdFx0XHRcdHRleHQgKz0gY29udGVudFxuXHRcdFx0XHRcdGVkaXRvci5zZXRWYWx1ZSh0ZXh0KVxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0aG90a2V5czogW1xuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bW9kaWZpZXJzOiBbYEN0cmxgLCBgTWV0YWAsIGBTaGlmdGBdLFxuXHRcdFx0XHRcdGtleTogYDhgLFxuXHRcdFx0XHR9LFxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bW9kaWZpZXJzOiBbYEN0cmxgLCBgQWx0YCwgYFNoaWZ0YF0sXG5cdFx0XHRcdFx0a2V5OiBgOGAsXG5cdFx0XHRcdH0sXG5cdFx0XHRdXG5cdFx0fSk7XG5cblx0XHR0aGlzLmFkZE9ic2lkaWFuSWNvbigndGhyZWFkcy10by1ibG9nLWljb24nLCAnVEInKTtcblx0XHR0aGlzLmFkZENvbW1hbmQoe1xuXHRcdFx0aWQ6IFwidGhyZWFkcy10by1ibG9nXCIsXG5cdFx0XHRuYW1lOiBcIlRCIFRocmVhZHMgYXMgcHJlIEJsb2cgZm9ybWF0IHRvIENsaXBib2FyZFwiLFxuXHRcdFx0aWNvbjogYHRocmVhZHMtdG8tYmxvZy1pY29uYCxcblx0XHRcdGVkaXRvckNhbGxiYWNrOiAoZWRpdG9yOiBFZGl0b3IsIHZpZXc6IE1hcmtkb3duVmlldykgPT4ge1xuXHRcdFx0XHRuZXcgVGhyZWFkc1RvQmxvZ01vZGFsKHRoaXMuYXBwLCBlZGl0b3IsIHZpZXcpLm9wZW4oKVxuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0Lypcblx0XHR0aGlzLmFkZE9ic2lkaWFuSWNvbignY2hhdGdwdC1wcm9tcHQtZm9yLWdlbmVyYXRpbmctc3VtbWFyeS10by1jbGlwYm9hcmQnLCAnR1MnKTtcblx0XHR0aGlzLmFkZENvbW1hbmQoe1xuXHRcdFx0aWQ6IFwiY2hhdGdwdC1wcm9tcHQtZm9yLWdlbmVyYXRpbmctc3VtbWFyeS10by1jbGlwYm9hcmRcIixcblx0XHRcdG5hbWU6IFwiR1MgQ2hhdEdQVCBwcm9tcHQgZm9yIGdlbmVyYXRpbmcgc3VtbWFyeSB0byBjbGlwYm9hcmRcIixcblx0XHRcdGljb246IGBjaGF0Z3B0LXByb21wdC1mb3ItZ2VuZXJhdGluZy1zdW1tYXJ5LXRvLWNsaXBib2FyZGAsXG5cdFx0XHRlZGl0b3JDYWxsYmFjazogKGVkaXRvcjogRWRpdG9yLCB2aWV3OiBNYXJrZG93blZpZXcpID0+IHtcblx0XHRcdFx0Y29uc3QgcHJvbXB0ID0gXCJcdThBQ0JcdTVDMDdcdTRFRTVcdTRFMEJcdTc2ODRcdTY1ODdcdTdBRTBcdTdCQzBcdTkzMDRcdTdFMkVcdTc3RURcdTYyMTBcdTdEMDQxNTBcdTVCNTdcdTc2ODRcdTRFMkRcdTY1ODdcdTY0NThcdTg5ODFcdUZGMENcdTc4QkFcdTRGRERcdTY0NThcdTg5ODFcdTUxNjdcdTVCQjlcdTdDQkVcdTcxNDlcdTRFMTRcdTdBODFcdTUxRkFcdTkxQ0RcdTlFREVcdTMwMDJcdTRGNjBcdTk3MDBcdTg5ODFcdTZDRThcdTYxMEZcdTRFRTVcdTRFMEJcdTVFN0VcdTlFREVcdUZGMUFcXG5cIiArXG5cdFx0XHRcdFx0XHRcdCAgIFwiXFxuXCIgK1xuXHRcdFx0XHRcdFx0XHQgICBcIjEuIFx1NUMwN1x1OTU3N1x1N0JDN1x1NTkyN1x1OEFENlx1N0UyRVx1NzdFRFx1RkYwQ1x1NTNFQVx1NEZERFx1NzU1OVx1NjcwMFx1OTFDRFx1ODk4MVx1NzY4NFx1OEEwQVx1NjA2Rlx1NTQ4Q1x1NEUzQlx1OTg0Q1x1MzAwMlxcblwiICtcblx0XHRcdFx0XHRcdFx0ICAgXCIyLiBcdTUzQkJcdTk2NjRcdTk3NUVcdTVGQzVcdTg5ODFcdTc2ODRcdThBNzNcdTdEMzBcdThBMEFcdTYwNkZcdUZGMENcdTRFMjZcdTkwN0ZcdTUxNERcdTRGN0ZcdTc1MjhcdTkwNEVcdTY1QkNcdTdFNDFcdTg5MDdcdTYyMTZcdTRFMERcdTVGQzVcdTg5ODFcdTc2ODRcdThBOUVcdThBMDBcdTMwMDJcXG5cIiArXG5cdFx0XHRcdFx0XHRcdCAgIFwiMy4gXHU0RkREXHU3NTU5XHU2NTg3XHU3QUUwXHU0RTJEXHU2NzAwXHU5MUNEXHU4OTgxXHU3Njg0XHU0RTNCXHU5ODRDXHU1NDhDXHU4QTBBXHU2MDZGXHVGRjBDXHU0RTI2XHU3OEJBXHU0RkREXHU5MDE5XHU0RTlCXHU4QTBBXHU2MDZGXHU1NzI4XHU2NDU4XHU4OTgxXHU0RTJEXHU2RTA1XHU2OTVBXHU1NzMwXHU4ODY4XHU5MDU0XHU1MUZBXHU0Rjg2XHUzMDAyXFxuXCIgK1xuXHRcdFx0XHRcdFx0XHQgICBcIjQuIFx1NEY3Rlx1NzUyOFx1N0NCRVx1NzE0OVx1NEUxNFx1NzZGNFx1NjNBNVx1NzY4NFx1OEE5RVx1OEEwMFx1RkYwQ1x1NEVFNVx1NTQzOFx1NUYxNVx1NEVCQVx1NzY4NFx1NjVCOVx1NUYwRlx1ODg2OFx1OTA1NFx1NEY1Q1x1ODAwNVx1NUMwN1x1NTcyOFx1NjU4N1x1N0FFMFx1NEUyRFx1NkRGMVx1NTE2NVx1NTIwNlx1NEVBQlx1OTAxOVx1NEU5Qlx1NEUzQlx1OTg0Q1x1NzY4NFx1NjEwRlx1NTcxNlx1MzAwMlxcblwiICtcblx0XHRcdFx0XHRcdFx0ICAgXCI1LiBcdTRGN0ZcdTc1MjhcdTMwMENcdTYyMTFcdTMwMERcdTRGODZcdTYzMDdcdTdBMzFcdTMwMENcdTRGNUNcdTgwMDVcdTMwMERcdUZGMENcdTMwMENcdTRGNjBcdTMwMERcdTRGODZcdTYzMDdcdTdBMzFcdThCODBcdTgwMDVcdTMwMDJcXG5cIiArXG5cdFx0XHRcdFx0XHRcdCAgIFwiXFxuXCIgK1xuXHRcdFx0XHRcdFx0XHQgICBcIlx1NTE3N1x1OUFENFx1NEY4Nlx1OEFBQVx1RkYwQ1x1NEY2MFx1OTcwMFx1ODk4MVx1NzhCQVx1NEZERFx1NEVFNVx1NEUwQlx1OTFDRFx1OUVERVx1OEEwQVx1NjA2Rlx1ODhBQlx1NTMwNVx1NTQyQlx1NTE3Nlx1NEUyRFx1RkYxQVxcblwiICtcblx0XHRcdFx0XHRcdFx0ICAgXCIxLiBcdTY1ODdcdTdBRTBcdTc2ODRcdTRFM0JcdTg5ODFcdTRFM0JcdTk4NENcdTYyMTZcdTkxQ0RcdTlFREVcdThBMEVcdThBRDZcdTMwMDJcXG5cIiArXG5cdFx0XHRcdFx0XHRcdCAgIFwiMi4gXHU0RjVDXHU4MDA1XHU2M0QwXHU1MUZBXHU3Njg0XHU1RUZBXHU4QjcwXHUzMDAxXHU3QjU2XHU3NTY1XHU2MjE2XHU5MUNEXHU4OTgxXHU4OUMwXHU5RURFXHUzMDAyXFxuXCIgK1xuXHRcdFx0XHRcdFx0XHQgICBcIjMuIFx1OTAxOVx1NEU5Qlx1NUVGQVx1OEI3MFx1NjIxNlx1N0I1Nlx1NzU2NVx1NzY4NFx1NTE3N1x1OUFENFx1NjU0OFx1NzZDQVx1NjIxNlx1N0Q1MFx1Njc5Q1x1MzAwMlxcblwiICtcblx0XHRcdFx0XHRcdFx0ICAgXCJcXG5cIiArXG5cdFx0XHRcdFx0XHRcdCAgIFwiXHU2NzAwXHU1RjhDXHVGRjBDXHU0RUU1XHU1NDM4XHU1RjE1XHU0RTI2XHU5RjEzXHU1MkY1XHU4QjgwXHU4MDA1XHU5MDMyXHU4ODRDXHU0RTBCXHU0RTAwXHU2QjY1XHU4ODRDXHU1MkQ1XHU3Njg0XHU2NUI5XHU1RjBGXHU3REU4XHU1QkVCXHU2NDU4XHU4OTgxXHVGRjBDXHU0RTI2XHU4ODY4XHU5MDU0XHU1MUZBXHU2NTg3XHU3QUUwXHU0RTJEXHU2NkY0XHU1OTFBXHU2REYxXHU1MTY1XHU3Njg0XHU1MTY3XHU1QkI5XHU3QjQ5XHU1Rjg1XHU4QjgwXHU4MDA1XHU1M0JCXHU2M0EyXHU3RDIyXHUzMDAyXFxuXCIgK1xuXHRcdFx0XHRcdFx0XHQgICBcIlx1OEFDQlx1NUJFQlx1NTFGQTNcdTUwMEJcdTcyNDhcdTY3MkNcdTMwMDJcXG5cXG5cIiArIGVkaXRvci5nZXRWYWx1ZSgpO1xuXG5cdFx0XHRcdG5hdmlnYXRvci5jbGlwYm9hcmQud3JpdGVUZXh0KHByb21wdCkudGhlbihmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0bmV3IE5vdGljZShgQ29waWVkIHByb21wdCBmb3IgZ2VuZXJhdGUgc3VtbWFyeSB0byBjbGlwYm9hcmQhYCk7XG5cdFx0XHRcdH0sIGZ1bmN0aW9uIChlcnJvcikge1xuXHRcdFx0XHRcdG5ldyBOb3RpY2UoYGVycm9yIHdoZW4gY29weSB0byBjbGlwYm9hcmQhYCk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdCovXG5cblx0XHR0aGlzLmFkZE9ic2lkaWFuSWNvbignYWRkLWNvbW1lbnQtdGFnLWljb24nLCAnQ1QnKTtcblx0XHR0aGlzLmFkZENvbW1hbmQoe1xuXHRcdFx0aWQ6IFwiYWRkLWNvbW1lbnQtdGFnXCIsXG5cdFx0XHRuYW1lOiBcIkNUIEFkZCBDb21tZW50IFRhZ1wiLFxuXHRcdFx0aWNvbjogYGFkZC1jb21tZW50LXRhZy1pY29uYCxcblx0XHRcdGVkaXRvckNhbGxiYWNrOiAoZWRpdG9yOiBFZGl0b3IsIHZpZXc6IE1hcmtkb3duVmlldykgPT4ge1xuXHRcdFx0ICBuZXcgQWRkRm9vdG5vdGVUYWdNb2RhbCh0aGlzLmFwcCwgZWRpdG9yKS5vcGVuKCk7XG5cdFx0XHR9LFxuXHRcdFx0aG90a2V5czogW1xuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bW9kaWZpZXJzOiBbYEN0cmxgLCBgTWV0YWAsIGBTaGlmdGBdLFxuXHRcdFx0XHRcdGtleTogYHpgLFxuXHRcdFx0XHR9LFxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bW9kaWZpZXJzOiBbYEN0cmxgLCBgQWx0YCwgYFNoaWZ0YF0sXG5cdFx0XHRcdFx0a2V5OiBgemAsXG5cdFx0XHRcdH0sXG5cdFx0XHRdXG5cdFx0fSk7XG5cblx0XHR0aGlzLmFkZE9ic2lkaWFuSWNvbignYWN0aW9uLXRhZy1jb3VudC1pY29uJywgJ0NBJyk7XG5cdFx0dGhpcy5hZGRDb21tYW5kKHtcblx0XHRcdGlkOiBcImFjdGlvbi10YWctY291bnQtaWNvblwiLFxuXHRcdFx0bmFtZTogXCJDQSBDb3VudCBBY3Rpb24gVGFnXCIsXG5cdFx0XHRpY29uOiBgYWN0aW9uLXRhZy1jb3VudC1pY29uYCxcblx0XHRcdGVkaXRvckNhbGxiYWNrOiAoZWRpdG9yOiBFZGl0b3IsIHZpZXc6IE1hcmtkb3duVmlldykgPT4ge1xuXHRcdFx0XHRjb25zdCB0YWdzID0gW1wibm5cIiwgXCJubFwiLCBcIm53XCIsIFwibjFcIiwgXCJuMlwiLCBcIm4zXCIsIFwibjRcIiwgXCJuNVwiLCBcIm42XCIsIFwibjdcIiwgXCJ3blwiLCBcIndsXCIsIFwid3dcIiwgXCJ3MVwiLCBcIncyXCIsIFwidzNcIiwgXCJ3NFwiLCBcInc1XCIsIFwidzZcIiwgXCJ3N1wiXTtcblx0XHRcdFx0Y29uc3QgbWF0Y2hlczogc3RyaW5nW10gPSBbXTtcblx0XHRcdFx0Y29uc3QgbGluZU51bSA9IGVkaXRvci5saW5lQ291bnQoKTtcblx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lTnVtOyBpKyspIHtcblx0XHRcdFx0XHRjb25zdCBsaW5lID0gZWRpdG9yLmdldExpbmUoaSlcblx0XHRcdFx0XHRjb25zdCBtYXRjaCA9IHRhZ3Muc29tZSh0YWcgPT4gbmV3IFJlZ0V4cChgIyR7dGFnfSBgLCBcImdcIikudGVzdChsaW5lKSB8fCBuZXcgUmVnRXhwKGAgIyR7dGFnfWAsIFwiZ1wiKS50ZXN0KGxpbmUpKTtcblx0XHRcdFx0XHRpZiAobWF0Y2gpIHtcblx0XHRcdFx0XHRcdG1hdGNoZXMucHVzaChgTGluZSAke2l9OlxcbiR7bGluZS50cmltKCl9YCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGNvbnN0IHRyaW1tZWRBbmRKb2luZWRTdHJpbmc6IHN0cmluZyA9IG1hdGNoZXMuam9pbihcIlxcblxcblwiKTtcblx0XHRcdFx0Y29uc3QgdGFza3MgPSBtYXRjaGVzLmxlbmd0aCA+IDAgPyBgXFxuVGFza3M6XFxuXFxuJHt0cmltbWVkQW5kSm9pbmVkU3RyaW5nfWAgOiBgYFxuXHRcdFx0XHRuZXcgTm90aWNlKGBUaGVyZSBhcmUgJHttYXRjaGVzLmxlbmd0aH0gb3V0c3RhbmRpbmcgYWN0aW9ucyBpbiB0aGlzIG5vdGVzJHt0YXNrc31gKTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdHRoaXMuYWRkT2JzaWRpYW5JY29uKCd0b2dnbGUtbi13LXRhc2snLCAnIz0nKTtcblx0XHR0aGlzLmFkZENvbW1hbmQoe1xuXHRcdFx0aWQ6IGB0b2dnbGUtbi13LXRhc2tgLFxuXHRcdFx0bmFtZTogYFRvZ2dsZSBOIFcgVGFza2AsXG5cdFx0XHRpY29uOiBgdG9nZ2xlLW4tdy10YXNrYCxcblx0XHRcdGVkaXRvckNhbGxiYWNrOiAoZWRpdG9yOiBFZGl0b3IsIHZpZXc6IE1hcmtkb3duVmlldykgPT4ge1xuXHRcdFx0XHRjb25zb2xlLmxvZyhlZGl0b3IuZ2V0U2VsZWN0aW9uKCkpO1xuXHRcdFx0XHRjb25zdCBjdXJzb3IgPSBlZGl0b3IuZ2V0Q3Vyc29yKCk7XG5cdFx0XHRcdGNvbnN0IGxpbmVOdW1iZXIgPSBlZGl0b3IuZ2V0Q3Vyc29yKCkubGluZTtcblx0XHRcdFx0Y29uc3QgbGluZSA9IGVkaXRvci5nZXRMaW5lKGxpbmVOdW1iZXIpO1xuXHRcdFx0XHRpZiAobGluZS5tYXRjaCgvIGFcXC93XFwvLi8pKSB7XG5cdFx0XHRcdFx0Y29uc3QgcmVwbGFjZWRMaW5lID0gbGluZS5yZXBsYWNlKC8gYVxcL3dcXC8oLikvLCBgIGEvbi8kMWApXG5cdFx0XHRcdFx0ZWRpdG9yLnNldExpbmUobGluZU51bWJlciwgcmVwbGFjZWRMaW5lKTtcblx0XHRcdFx0XHRlZGl0b3Iuc2V0Q3Vyc29yKGN1cnNvcilcblx0XHRcdFx0fSBlbHNlIGlmIChsaW5lLm1hdGNoKC8gYVxcL25cXC8uLykpIHtcblx0XHRcdFx0XHRjb25zdCByZXBsYWNlZExpbmUgPSBsaW5lLnJlcGxhY2UoLyBhXFwvblxcLyguKS8sIGAgYS93LyQxYClcblx0XHRcdFx0XHRlZGl0b3Iuc2V0TGluZShsaW5lTnVtYmVyLCByZXBsYWNlZExpbmUpO1xuXHRcdFx0XHRcdGVkaXRvci5zZXRDdXJzb3IoY3Vyc29yKVxuXHRcdFx0XHR9IGVsc2UgaWYgKGxpbmUubWF0Y2goLyN3LiAvKSkge1xuXHRcdFx0XHRcdGNvbnN0IHJlcGxhY2VkTGluZSA9IGxpbmUucmVwbGFjZSgvI3coLikgLywgYCNuJDEgYClcblx0XHRcdFx0XHRlZGl0b3Iuc2V0TGluZShsaW5lTnVtYmVyLCByZXBsYWNlZExpbmUpO1xuXHRcdFx0XHRcdGVkaXRvci5zZXRDdXJzb3IoY3Vyc29yKVxuXHRcdFx0XHR9IGVsc2UgaWYgKGxpbmUubWF0Y2goLyNuLiAvKSkge1xuXHRcdFx0XHRcdGNvbnN0IHJlcGxhY2VkTGluZSA9IGxpbmUucmVwbGFjZSgvI24oLikgLywgYCN3JDEgYClcblx0XHRcdFx0XHRlZGl0b3Iuc2V0TGluZShsaW5lTnVtYmVyLCByZXBsYWNlZExpbmUpO1xuXHRcdFx0XHRcdGVkaXRvci5zZXRDdXJzb3IoY3Vyc29yKVxuXHRcdFx0XHR9IGVsc2UgaWYgKGxpbmUubWF0Y2goLyAjdy4vKSkge1xuXHRcdFx0XHRcdGNvbnN0IHJlcGxhY2VkTGluZSA9IGxpbmUucmVwbGFjZSgvICN3KC4pLywgYCAjbiQxYClcblx0XHRcdFx0XHRlZGl0b3Iuc2V0TGluZShsaW5lTnVtYmVyLCByZXBsYWNlZExpbmUpO1xuXHRcdFx0XHRcdGVkaXRvci5zZXRDdXJzb3IoY3Vyc29yKVxuXHRcdFx0XHR9IGVsc2UgaWYgKGxpbmUubWF0Y2goLyAjbi4vKSkge1xuXHRcdFx0XHRcdGNvbnN0IHJlcGxhY2VkTGluZSA9IGxpbmUucmVwbGFjZSgvICNuKC4pLywgYCAjdyQxYClcblx0XHRcdFx0XHRlZGl0b3Iuc2V0TGluZShsaW5lTnVtYmVyLCByZXBsYWNlZExpbmUpO1xuXHRcdFx0XHRcdGVkaXRvci5zZXRDdXJzb3IoY3Vyc29yKVxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0aG90a2V5czogW1xuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bW9kaWZpZXJzOiBbYEN0cmxgLCBgTWV0YWAsIGBTaGlmdGBdLFxuXHRcdFx0XHRcdGtleTogYD1gLFxuXHRcdFx0XHR9LFxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bW9kaWZpZXJzOiBbYEN0cmxgLCBgQWx0YCwgYFNoaWZ0YF0sXG5cdFx0XHRcdFx0a2V5OiBgPWAsXG5cdFx0XHRcdH1cblx0XHRcdF1cblx0XHR9KTtcblxuXHRcdC8qXG5cdFx0dGhpcy5hZGRPYnNpZGlhbkljb24oJ3JlbW92ZS1hY3Rpb24taWNvbicsICctIycpO1xuXHRcdHRoaXMuYWRkQ29tbWFuZCh7XG5cdFx0XHRpZDogXCJyZW1vdmUtYWN0aW9uXCIsXG5cdFx0XHRuYW1lOiBcIlJlbW92ZSBhY3Rpb25cIixcblx0XHRcdGljb246IGByZW1vdmUtYWN0aW9uLWljb25gLFxuXHRcdFx0ZWRpdG9yQ2FsbGJhY2s6IChlZGl0b3I6IEVkaXRvciwgdmlldzogTWFya2Rvd25WaWV3KSA9PiB7XG5cdFx0XHRcdGNvbnN0IGN1cnNvciA9IGVkaXRvci5nZXRDdXJzb3IoKTtcblx0XHRcdFx0Y29uc3QgbGluZU51bWJlciA9IGVkaXRvci5nZXRDdXJzb3IoKS5saW5lO1xuXHRcdFx0XHRjb25zdCBsaW5lID0gZWRpdG9yLmdldExpbmUobGluZU51bWJlcik7XG5cdFx0XHRcdGxldCByZXBsYWNlZExpbmUgPSBsaW5lLnJlcGxhY2UoJyNubiAnLCAnJylcblx0XHRcdFx0ICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKCcjbmwgJywgJycpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCAucmVwbGFjZSgnI253ICcsICcnKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQgLnJlcGxhY2UoJyNuZCAnLCAnJylcblx0XHRcdFx0XHRcdFx0XHRcdFx0IC5yZXBsYWNlKCcjbmEgJywgJycpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCAucmVwbGFjZSgnI250ICcsICcnKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQgLnJlcGxhY2UoJyNuMSAnLCAnJylcblx0XHRcdFx0XHRcdFx0XHRcdFx0IC5yZXBsYWNlKCcjbjIgJywgJycpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCAucmVwbGFjZSgnI24zICcsICcnKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQgLnJlcGxhY2UoJyNuNCAnLCAnJylcblx0XHRcdFx0XHRcdFx0XHRcdFx0IC5yZXBsYWNlKCcjbjUgJywgJycpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCAucmVwbGFjZSgnI242ICcsICcnKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQgLnJlcGxhY2UoJyNuNyAnLCAnJylcblx0XHRcdFx0XHRcdFx0XHRcdFx0IC5yZXBsYWNlKCcjd24gJywgJycpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCAucmVwbGFjZSgnI3dsICcsICcnKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQgLnJlcGxhY2UoJyN3dyAnLCAnJylcblx0XHRcdFx0XHRcdFx0XHRcdFx0IC5yZXBsYWNlKCcjd2QgJywgJycpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCAucmVwbGFjZSgnI3dhICcsICcnKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQgLnJlcGxhY2UoJyN3dCAnLCAnJylcblx0XHRcdFx0XHRcdFx0XHRcdFx0IC5yZXBsYWNlKCcjdzEgJywgJycpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCAucmVwbGFjZSgnI3cyICcsICcnKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQgLnJlcGxhY2UoJyN3MyAnLCAnJylcblx0XHRcdFx0XHRcdFx0XHRcdFx0IC5yZXBsYWNlKCcjdzQgJywgJycpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCAucmVwbGFjZSgnI3c1ICcsICcnKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQgLnJlcGxhY2UoJyN3NiAnLCAnJylcblx0XHRcdFx0XHRcdFx0XHRcdFx0IC5yZXBsYWNlKCcjdzcgJywgJycpXG5cdFx0XHRcdHJlcGxhY2VkTGluZSA9IEFkZEZvb3Rub3RlVGFnTW9kYWwucmVtb3ZlVGFnKHJlcGxhY2VkTGluZSlcblx0XHRcdFx0ZWRpdG9yLnNldExpbmUobGluZU51bWJlciwgcmVwbGFjZWRMaW5lKTtcblx0XHRcdFx0ZWRpdG9yLnNldEN1cnNvcihjdXJzb3IpO1xuXHRcdFx0fSxcblx0XHRcdGhvdGtleXM6IFtcblx0XHRcdFx0e1xuXHRcdFx0XHRcdG1vZGlmaWVyczogW2BDdHJsYCwgYE1ldGFgLCBgU2hpZnRgXSxcblx0XHRcdFx0XHRrZXk6IGB4YCxcblx0XHRcdFx0fSxcblx0XHRcdFx0e1xuXHRcdFx0XHRcdG1vZGlmaWVyczogW2BDdHJsYCwgYEFsdGAsIGBTaGlmdGBdLFxuXHRcdFx0XHRcdGtleTogYHhgLFxuXHRcdFx0XHR9XG5cdFx0XHRdXG5cdFx0fSk7XG5cdFx0Ki9cblxuXHRcdHRoaXMuYWRkQ29tbWFuZCh7XG5cdFx0XHRpZDogXCJjdXJzb3ItZ28tdG8tc3RhcnQtb2YtbGluZVwiLFxuXHRcdFx0bmFtZTogXCJDdXJzb3IgZ28gdG8gc3RhcnQgb2YgbGluZVwiLFxuXHRcdFx0aWNvbjogYGFycm93LWJpZy1sZWZ0YCxcblx0XHRcdGVkaXRvckNhbGxiYWNrOiAoZWRpdG9yOiBFZGl0b3IsIHZpZXc6IE1hcmtkb3duVmlldykgPT4ge1xuXHRcdFx0XHRjb25zdCBjdXJzb3IgPSBlZGl0b3IuZ2V0Q3Vyc29yKCk7XG5cdFx0XHRcdGN1cnNvci5jaCA9IDA7XG5cdFx0XHRcdGVkaXRvci5zZXRDdXJzb3IoY3Vyc29yKTtcblx0XHRcdH0sXG5cdFx0fSk7XG5cblx0XHR0aGlzLmFkZENvbW1hbmQoe1xuXHRcdFx0aWQ6IFwiY3Vyc29yLWdvLXRvLWVuZC1vZi1saW5lXCIsXG5cdFx0XHRuYW1lOiBcIkN1cnNvciBnbyB0byBlbmQgb2YgbGluZVwiLFxuXHRcdFx0aWNvbjogYGFycm93LWJpZy1yaWdodGAsXG5cdFx0XHRlZGl0b3JDYWxsYmFjazogKGVkaXRvcjogRWRpdG9yLCB2aWV3OiBNYXJrZG93blZpZXcpID0+IHtcblx0XHRcdFx0Y29uc3QgY3Vyc29yID0gZWRpdG9yLmdldEN1cnNvcigpO1xuXHRcdFx0XHRjb25zdCBsaW5lTnVtID0gY3Vyc29yLmxpbmU7XG5cdFx0XHRcdGNvbnN0IGxpbmUgPSBlZGl0b3IuZ2V0TGluZShsaW5lTnVtKTtcblx0XHRcdFx0Y29uc3QgbGVuZ3RoID0gbGluZS5sZW5ndGg7XG5cdFx0XHRcdGN1cnNvci5jaCA9IGxlbmd0aDtcblx0XHRcdFx0ZWRpdG9yLnNldEN1cnNvcihjdXJzb3IpO1xuXHRcdFx0fSxcblx0XHR9KTtcblxuXHRcdHRoaXMuYWRkT2JzaWRpYW5JY29uKCdldmVudC10by1mYW50YXN0aWNhbC1pY29uJywgJ0ZFJyk7XG5cdFx0dGhpcy5hZGRDb21tYW5kKHtcblx0XHRcdGlkOiBcImFkZC1mYW50YXN0aWNhbC1ldmVudFwiLFxuXHRcdFx0bmFtZTogXCJGRSBBZGQgRmFudGFzdGljYWwgRXZlbnRcIixcblx0XHRcdGljb246IGBldmVudC10by1mYW50YXN0aWNhbC1pY29uYCxcblx0XHRcdGVkaXRvckNhbGxiYWNrOiAoZWRpdG9yOiBFZGl0b3IsIHZpZXc6IE1hcmtkb3duVmlldykgPT4ge1xuXHRcdFx0XHRsZXQgdGV4dCA9IFwiXCJcblx0XHRcdFx0Y29uc3QgbGlzdFNlbGVjdGlvbnMgOiBFZGl0b3JTZWxlY3Rpb25bXSA9IGVkaXRvci5saXN0U2VsZWN0aW9ucygpXG5cdFx0XHRcdGxpc3RTZWxlY3Rpb25zLmZvckVhY2gobGlzdFNlbGVjdGlvbiA9PiB7XG5cdFx0XHRcdFx0Y29uc3QgYSA9IGxpc3RTZWxlY3Rpb24uaGVhZC5saW5lXG5cdFx0XHRcdFx0Y29uc3QgYiA9IGxpc3RTZWxlY3Rpb24uYW5jaG9yLmxpbmVcblx0XHRcdFx0XHRjb25zdCBmcm9tTGluZU51bSA9IGIgPiBhID8gYSA6IGJcblx0XHRcdFx0XHRjb25zdCB0b0xpbmVOdW0gPSBiID4gYSA/IGIgOiBhXG5cdFx0XHRcdFx0Zm9yIChsZXQgaSA9IGZyb21MaW5lTnVtOyBpIDw9IHRvTGluZU51bTsgaSsrKSB7XG5cdFx0XHRcdFx0XHRjb25zdCBsaW5lID0gZWRpdG9yLmdldExpbmUoaSlcblx0XHRcdFx0XHRcdGlmICgvXi0gXFxkXFxkXFxkXFxkLVxcZFxcZC1cXGRcXGQgXFxkXFxkOlxcZFxcZCAvLnRlc3QobGluZSkpIHtcblx0XHRcdFx0XHRcdFx0Y29uc3QgbW9kaWZpZWRMaW5lID0gbGluZS5yZXBsYWNlKC9eLSAvLCBgLSAjdG0gYClcblx0XHRcdFx0XHRcdFx0ZWRpdG9yLnNldExpbmUoaSwgbW9kaWZpZWRMaW5lKTtcblx0XHRcdFx0XHRcdFx0dGV4dCArPSBsaW5lICsgXCJcXG5cIlxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSlcblx0XHRcdFx0aWYgKHRleHQubGVuZ3RoICE9IDApIHtcblx0XHRcdFx0XHR0ZXh0ID0gZW5jb2RlVVJJKHRleHQpXG5cdFx0XHRcdFx0d2luZG93Lm9wZW4oYHNob3J0Y3V0czovL3J1bi1zaG9ydGN1dD9uYW1lPUFkZCUyME9ic2lkaWFuJTIwSW5ib3glMjBFdmVudCUyMHZpYSUyMEZhbnRhc3RpY2FsJmlucHV0PXRleHQmdGV4dD0ke3RleHR9Jngtc3VjY2Vzcz1vYnNpZGlhbjovLyZ4LWNhbmNlbD1vYnNpZGlhbjovLyZ4LWVycm9yPW9ic2lkaWFuOi8vYCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdC8qXG5cdFx0dGhpcy5hZGRDb21tYW5kKHtcblx0XHRcdGlkOiBcInJlbW92ZS1maXJzdC10YWItZnJvbS1zZWxlY3RlZC1saW5lc1wiLFxuXHRcdFx0bmFtZTogXCJSZW1vdmUgZmlyc3QgdGFiIGZyb20gc2VsZWN0ZWQgbGluZXNcIixcblx0XHRcdGVkaXRvckNhbGxiYWNrOiAoZWRpdG9yOiBFZGl0b3IsIHZpZXc6IE1hcmtkb3duVmlldykgPT4ge1xuXHRcdFx0XHRjb25zdCBsaXN0U2VsZWN0aW9ucyA9IGVkaXRvci5saXN0U2VsZWN0aW9ucygpO1xuXHRcdFx0XHRsaXN0U2VsZWN0aW9ucy5mb3JFYWNoKGxpc3RTZWxlY3Rpb24gPT4ge1xuXHRcdFx0XHRcdGNvbnN0IGZyb21MaW5lTnVtID0gbGlzdFNlbGVjdGlvbi5oZWFkLmxpbmVcblx0XHRcdFx0XHRjb25zdCB0b0xpbmVOdW0gPSBsaXN0U2VsZWN0aW9uLmFuY2hvci5saW5lXG5cdFx0XHRcdFx0Zm9yIChsZXQgaSA9IGZyb21MaW5lTnVtOyBpIDw9IHRvTGluZU51bTsgaSsrKSB7XG5cdFx0XHRcdFx0XHRjb25zdCBsaW5lID0gZWRpdG9yLmdldExpbmUoaSlcblx0XHRcdFx0XHRcdGNvbnN0IG1vZGlmaWVkTGluZSA9IGxpbmUucmVwbGFjZSgvXFx0LywgJycpXG5cdFx0XHRcdFx0XHRlZGl0b3Iuc2V0TGluZShpLCBtb2RpZmllZExpbmUpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSlcblx0XHRcdH0sXG5cdFx0fSk7XG5cdFx0Ki9cblxuXHRcdHRoaXMuYWRkQ29tbWFuZCh7XG5cdFx0XHRpZDogXCJncmVwLXRpdGxlLWFzLWxpbmstdG8tY2xpcGJvYXJkXCIsXG5cdFx0XHRuYW1lOiBcIkdyZXAgVGl0bGUgYXMgbGluayB0byBjbGlwYm9hcmRcIixcblx0XHRcdGljb246IGBjbGlwYm9hcmQtbGlzdGAsXG5cdFx0XHRlZGl0b3JDYWxsYmFjazogYXN5bmMgKGVkaXRvcjogRWRpdG9yLCB2aWV3OiBNYXJrZG93blZpZXcpID0+IHtcblx0XHRcdFx0Y29uc3QgdGl0bGUgPSB2aWV3LmZpbGUuYmFzZW5hbWU7XG5cdFx0XHRcdGNvbnN0IHRpdGxlQXNMaW5rID0gYFtbJHt0aXRsZX1dXWA7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0dGhpcy5hZGRUb0NsaXBib2FyZEhpc3RvcnkodGl0bGVBc0xpbmspO1xuXHRcdFx0XHRcdGF3YWl0IG5hdmlnYXRvci5jbGlwYm9hcmQud3JpdGVUZXh0KHRpdGxlQXNMaW5rKTtcblx0XHRcdFx0XHRuZXcgTm90aWNlKGBDb3BpZWQgdGl0bGUgXCIke3RpdGxlfVwiIGFzIGxpbmsgdG8gY2xpcGJvYXJkIWApO1xuXHRcdFx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0XHRcdG5ldyBOb3RpY2UoYEVycm9yIG9jY3VycmVkIHdoZW4gY29weWluZyB0byBjbGlwYm9hcmQ6ICR7ZXJyb3J9YCk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRob3RrZXlzOiBbXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRtb2RpZmllcnM6IFtgTWV0YWAsIGBTaGlmdGBdLFxuXHRcdFx0XHRcdGtleTogYGxgLFxuXHRcdFx0XHR9LFxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bW9kaWZpZXJzOiBbYEN0cmxgLCBgU2hpZnRgXSxcblx0XHRcdFx0XHRrZXk6IGBsYCxcblx0XHRcdFx0fVxuXHRcdFx0XVxuXHRcdH0pO1xuXG5cdFx0dGhpcy5hZGRPYnNpZGlhbkljb24oJ21vdmUtY3VycmVudC1zZWxlY3Rpb24tdG8tYmVnaW5uaW5nLW9mLW5vdGVzJywgJzw8Jyk7XG5cdFx0dGhpcy5hZGRDb21tYW5kKHtcblx0XHRcdGlkOiBcIm1vdmUtY3VycmVudC1zZWxlY3Rpb24tdG8tYmVnaW5uaW5nLW9mLW5vdGVzXCIsXG5cdFx0XHRuYW1lOiBcIk1CIDw8IE1vdmUgY3VycmVudCBzZWxlY3Rpb24gdG8gYmVnaW5uaW5nIG9mIG5vdGVzXCIsXG5cdFx0XHRpY29uOiBgbW92ZS1jdXJyZW50LXNlbGVjdGlvbi10by1iZWdpbm5pbmctb2Ytbm90ZXNgLFxuXHRcdFx0ZWRpdG9yQ2FsbGJhY2s6IChlZGl0b3I6IEVkaXRvciwgdmlldzogTWFya2Rvd25WaWV3KSA9PiB7XG5cdFx0XHRcdGxldCBzZWxlY3Rpb24gPSBleHBvcnRDdXJyZW50U2VsZWN0aW9uKGVkaXRvcilcblx0XHRcdFx0aWYgKC9eICAgICstIC9tLnRlc3Qoc2VsZWN0aW9uKVxuXHRcdFx0XHQgIHx8IC9eLSAvbS50ZXN0KHNlbGVjdGlvbilcblx0XHRcdFx0ICB8fCAvXiMgL20udGVzdChzZWxlY3Rpb24pXG5cdFx0XHRcdCAgfHwgL15gIC9tLnRlc3Qoc2VsZWN0aW9uKVxuXHRcdFx0XHQgIHx8IC9ePiAvbS50ZXN0KHNlbGVjdGlvbilcblx0XHRcdFx0ICB8fCAvXlxcZCtcXC4gL20udGVzdChzZWxlY3Rpb24pXG5cdFx0XHRcdCAgKVxuXHRcdFx0XHR7XG5cdFx0XHRcdC8vIGRvIG5vdGhpbmdcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRzZWxlY3Rpb24gPSBcIi0gXCIgKyBzZWxlY3Rpb25cblx0XHRcdFx0fVxuXHRcdFx0XHRsZXQgbmV3Q29udGVudCA9ICcnXG5cdFx0XHRcdGNvbnN0IHNlbGVjdGlvblJhbmdlOiBTZWxlY3Rpb25SYW5nZSA9IGdldEN1cnJlbnRTZWxlY3Rpb25MaW5lTnVtYmVyKGVkaXRvcilcblx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBlZGl0b3IubGluZUNvdW50KCk7IGkrKykge1xuXHRcdFx0XHRcdGlmIChpIDwgc2VsZWN0aW9uUmFuZ2UuZnJvbUxpbmVOdW0gfHwgaSA+IHNlbGVjdGlvblJhbmdlLnRvTGluZU51bSkge1xuXHRcdFx0XHRcdFx0bmV3Q29udGVudCA9IG5ld0NvbnRlbnQgKyBlZGl0b3IuZ2V0TGluZShpKSArIFwiXFxuXCJcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHRcdG5ldyBBZGRUZXh0VG9Ob3Rlc01vZGFsKHRoaXMuYXBwLCBzZWxlY3Rpb24sIFwibW92ZSB0aGUgc2VsZWN0ZWQgdGV4dFwiLCB0cnVlLCAoKSA9PiBlZGl0b3Iuc2V0VmFsdWUobmV3Q29udGVudC5yZXBsYWNlKC9cXG4kL20sIFwiXCIpKSkub3BlbigpXG5cdFx0XHR9LFxuXHRcdFx0aG90a2V5czogW1xuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bW9kaWZpZXJzOiBbYEN0cmxgLCBgTWV0YWAsIGBTaGlmdGBdLFxuXHRcdFx0XHRcdGtleTogYCxgLFxuXHRcdFx0XHR9LFxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bW9kaWZpZXJzOiBbYEN0cmxgLCBgQWx0YCwgYFNoaWZ0YF0sXG5cdFx0XHRcdFx0a2V5OiBgLGAsXG5cdFx0XHRcdH0sXG5cdFx0XHRdXG5cdFx0fSlcblxuXHRcdHRoaXMuYWRkT2JzaWRpYW5JY29uKCdtb3ZlLWN1cnJlbnQtc2VsZWN0aW9uLXRvLWVuZC1vZi1ub3RlcycsICc+PicpO1xuXHRcdHRoaXMuYWRkQ29tbWFuZCh7XG5cdFx0XHRpZDogXCJtb3ZlLWN1cnJlbnQtc2VsZWN0aW9uLXRvLWVuZC1vZi1ub3Rlc1wiLFxuXHRcdFx0bmFtZTogXCJNRSA+PiBNb3ZlIGN1cnJlbnQgc2VsZWN0aW9uIHRvIGJlZ2lubmluZyBvZiBub3Rlc1wiLFxuXHRcdFx0aWNvbjogYG1vdmUtY3VycmVudC1zZWxlY3Rpb24tdG8tZW5kLW9mLW5vdGVzYCxcblx0XHRcdGVkaXRvckNhbGxiYWNrOiAoZWRpdG9yOiBFZGl0b3IsIHZpZXc6IE1hcmtkb3duVmlldykgPT4ge1xuXHRcdFx0XHRsZXQgc2VsZWN0aW9uID0gZXhwb3J0Q3VycmVudFNlbGVjdGlvbihlZGl0b3IpXG5cdFx0XHRcdGlmICgvXiAgICArLSAvbS50ZXN0KHNlbGVjdGlvbilcblx0XHRcdFx0ICB8fCAvXi0gL20udGVzdChzZWxlY3Rpb24pXG5cdFx0XHRcdCAgfHwgL14jIC9tLnRlc3Qoc2VsZWN0aW9uKVxuXHRcdFx0XHQgIHx8IC9eYCAvbS50ZXN0KHNlbGVjdGlvbilcblx0XHRcdFx0ICB8fCAvXj4gL20udGVzdChzZWxlY3Rpb24pXG5cdFx0XHRcdCAgfHwgL15cXGQrXFwuIC9tLnRlc3Qoc2VsZWN0aW9uKVxuXHRcdFx0XHQgIClcblx0XHRcdFx0e1xuXHRcdFx0XHQvLyBkbyBub3RoaW5nXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0c2VsZWN0aW9uID0gXCItIFwiICsgc2VsZWN0aW9uXG5cdFx0XHRcdH1cblx0XHRcdFx0bGV0IG5ld0NvbnRlbnQgPSAnJ1xuXHRcdFx0XHRjb25zdCBzZWxlY3Rpb25SYW5nZTogU2VsZWN0aW9uUmFuZ2UgPSBnZXRDdXJyZW50U2VsZWN0aW9uTGluZU51bWJlcihlZGl0b3IpXG5cdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgZWRpdG9yLmxpbmVDb3VudCgpOyBpKyspIHtcblx0XHRcdFx0XHRpZiAoaSA8IHNlbGVjdGlvblJhbmdlLmZyb21MaW5lTnVtIHx8IGkgPiBzZWxlY3Rpb25SYW5nZS50b0xpbmVOdW0pIHtcblx0XHRcdFx0XHRcdG5ld0NvbnRlbnQgPSBuZXdDb250ZW50ICsgZWRpdG9yLmdldExpbmUoaSkgKyBcIlxcblwiXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0XHRuZXcgQWRkVGV4dFRvTm90ZXNNb2RhbCh0aGlzLmFwcCwgc2VsZWN0aW9uLCBcIm1vdmUgdGhlIHNlbGVjdGVkIHRleHRcIiwgZmFsc2UsICgpID0+IGVkaXRvci5zZXRWYWx1ZShuZXdDb250ZW50LnJlcGxhY2UoL1xcbiQvbSwgXCJcIikpKS5vcGVuKClcblx0XHRcdH0sXG5cdFx0XHRob3RrZXlzOiBbXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRtb2RpZmllcnM6IFtgQ3RybGAsIGBNZXRhYCwgYFNoaWZ0YF0sXG5cdFx0XHRcdFx0a2V5OiBgLmAsXG5cdFx0XHRcdH0sXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRtb2RpZmllcnM6IFtgQ3RybGAsIGBBbHRgLCBgU2hpZnRgXSxcblx0XHRcdFx0XHRrZXk6IGAuYCxcblx0XHRcdFx0fSxcblx0XHRcdF1cblx0XHR9KVxuXG5cdFx0dGhpcy5hZGRPYnNpZGlhbkljb24oJ2FkZC1jdXJyZW50LXNlbGVjdGlvbi10by1iZWdpbm5pbmctb2Ytbm90ZXMnLCAnKCgnKTtcblx0XHR0aGlzLmFkZENvbW1hbmQoe1xuXHRcdFx0aWQ6IFwiYWRkLWN1cnJlbnQtc2VsZWN0aW9uLXRvLWJlZ2lubmluZy1vZi1ub3Rlc1wiLFxuXHRcdFx0bmFtZTogXCJTQiAoKCBBZGQgY3VycmVudCBzZWxlY3Rpb24gdG8gYmVnaW5uaW5nIG9mIG5vdGVzXCIsXG5cdFx0XHRpY29uOiBgYWRkLWN1cnJlbnQtc2VsZWN0aW9uLXRvLWJlZ2lubmluZy1vZi1ub3Rlc2AsXG5cdFx0XHRlZGl0b3JDYWxsYmFjazogKGVkaXRvcjogRWRpdG9yLCB2aWV3OiBNYXJrZG93blZpZXcpID0+IHtcblx0XHRcdFx0bGV0IHNlbGVjdGlvbiA9IGV4cG9ydEN1cnJlbnRTZWxlY3Rpb24oZWRpdG9yKVxuXHRcdFx0XHRpZiAoL14gICAgKy0gL20udGVzdChzZWxlY3Rpb24pXG5cdFx0XHRcdCAgfHwgL14tIC9tLnRlc3Qoc2VsZWN0aW9uKVxuXHRcdFx0XHQgIHx8IC9eIyAvbS50ZXN0KHNlbGVjdGlvbilcblx0XHRcdFx0ICB8fCAvXmAgL20udGVzdChzZWxlY3Rpb24pXG5cdFx0XHRcdCAgfHwgL14+IC9tLnRlc3Qoc2VsZWN0aW9uKVxuXHRcdFx0XHQgIHx8IC9eXFxkK1xcLiAvbS50ZXN0KHNlbGVjdGlvbilcblx0XHRcdFx0ICApIHtcblx0XHRcdFx0XHQvLyBkbyBub3RoaW5nXG5cdFx0XHRcdCAgfSBlbHNlIHtcblx0XHRcdFx0XHRzZWxlY3Rpb24gPSBcIi0gXCIgKyBzZWxlY3Rpb25cblx0XHRcdFx0ICB9XG5cdFx0XHRcdG5ldyBBZGRUZXh0VG9Ob3Rlc01vZGFsKHRoaXMuYXBwLCBzZWxlY3Rpb24sIFwiYWRkIHRoZSBzZWxlY3RlZCB0ZXh0XCIsIHRydWUsICgpID0+IHt9KS5vcGVuKClcblx0XHRcdH0sXG5cdFx0XHRob3RrZXlzOiBbXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRtb2RpZmllcnM6IFtgQ3RybGAsIGBNZXRhYCwgYFNoaWZ0YF0sXG5cdFx0XHRcdFx0a2V5OiBgOWAsXG5cdFx0XHRcdH0sXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRtb2RpZmllcnM6IFtgQ3RybGAsIGBBbHRgLCBgU2hpZnRgXSxcblx0XHRcdFx0XHRrZXk6IGA5YCxcblx0XHRcdFx0fSxcblx0XHRcdF1cblx0XHR9KVxuXG5cdFx0dGhpcy5hZGRPYnNpZGlhbkljb24oJ2FkZC1jdXJyZW50LXNlbGVjdGlvbi10by1lbmQtb2Ytbm90ZXMnLCAnKSknKTtcblx0XHR0aGlzLmFkZENvbW1hbmQoe1xuXHRcdFx0aWQ6IFwiYWRkLWN1cnJlbnQtc2VsZWN0aW9uLXRvLWVuZC1vZi1ub3Rlc1wiLFxuXHRcdFx0bmFtZTogXCJTRSApKSBBZGQgY3VycmVudCBzZWxlY3Rpb24gdG8gZW5kIG9mIG5vdGVzXCIsXG5cdFx0XHRpY29uOiBgYWRkLWN1cnJlbnQtc2VsZWN0aW9uLXRvLWVuZC1vZi1ub3Rlc2AsXG5cdFx0XHRlZGl0b3JDYWxsYmFjazogKGVkaXRvcjogRWRpdG9yLCB2aWV3OiBNYXJrZG93blZpZXcpID0+IHtcblx0XHRcdFx0bGV0IHNlbGVjdGlvbiA9IGV4cG9ydEN1cnJlbnRTZWxlY3Rpb24oZWRpdG9yKVxuXHRcdFx0XHRpZiAoL14gICAgKy0gL20udGVzdChzZWxlY3Rpb24pXG5cdFx0XHRcdCAgfHwgL14tIC9tLnRlc3Qoc2VsZWN0aW9uKVxuXHRcdFx0XHQgIHx8IC9eIyAvbS50ZXN0KHNlbGVjdGlvbilcblx0XHRcdFx0ICB8fCAvXmAgL20udGVzdChzZWxlY3Rpb24pXG5cdFx0XHRcdCAgfHwgL14+IC9tLnRlc3Qoc2VsZWN0aW9uKVxuXHRcdFx0XHQgIHx8IC9eXFxkK1xcLiAvbS50ZXN0KHNlbGVjdGlvbilcblx0XHRcdFx0ICApIHtcblx0XHRcdFx0XHQvLyBkbyBub3RoaW5nXG5cdFx0XHRcdCAgfSBlbHNlIHtcblx0XHRcdFx0XHRzZWxlY3Rpb24gPSBcIi0gXCIgKyBzZWxlY3Rpb25cblx0XHRcdFx0ICB9XG5cdFx0XHRcdG5ldyBBZGRUZXh0VG9Ob3Rlc01vZGFsKHRoaXMuYXBwLCBzZWxlY3Rpb24sIFwiYWRkIHRoZSBzZWxlY3RlZCB0ZXh0XCIsIGZhbHNlLCAoKSA9PiB7fSkub3BlbigpXG5cdFx0XHR9LFxuXHRcdFx0aG90a2V5czogW1xuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bW9kaWZpZXJzOiBbYEN0cmxgLCBgTWV0YWAsIGBTaGlmdGBdLFxuXHRcdFx0XHRcdGtleTogYDBgLFxuXHRcdFx0XHR9LFxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bW9kaWZpZXJzOiBbYEN0cmxgLCBgQWx0YCwgYFNoaWZ0YF0sXG5cdFx0XHRcdFx0a2V5OiBgMGAsXG5cdFx0XHRcdH0sXG5cdFx0XHRdXG5cdFx0fSlcblxuXHRcdHRoaXMuYWRkT2JzaWRpYW5JY29uKCdhZGQtY3VycmVudC1saW5rLXRvLWJlZ2lubmluZy1vZi1ub3RlcycsICdbWycpO1xuXHRcdHRoaXMuYWRkQ29tbWFuZCh7XG5cdFx0XHRpZDogXCJhZGQtY3VycmVudC1saW5rLXRvLWJlZ2lubmluZy1vZi1ub3Rlc1wiLFxuXHRcdFx0bmFtZTogXCJMQiBbWyBBZGQgY3VycmVudCBsaW5rIHRvIGJlZ2lubmluZyBvZiBub3Rlc1wiLFxuXHRcdFx0aWNvbjogYGFkZC1jdXJyZW50LWxpbmstdG8tYmVnaW5uaW5nLW9mLW5vdGVzYCxcblx0XHRcdGVkaXRvckNhbGxiYWNrOiAoZWRpdG9yOiBFZGl0b3IsIHZpZXc6IE1hcmtkb3duVmlldykgPT4ge1xuXHRcdFx0XHRjb25zdCBsaW5rID0gXCItIFtbXCIgKyB2aWV3LmZpbGUuYmFzZW5hbWUgKyBcIl1dXCI7XG5cdFx0XHRcdG5ldyBBZGRUZXh0VG9Ob3Rlc01vZGFsKHRoaXMuYXBwLCBsaW5rLCBcImFkZCB0aGUgY3VycmVudCBub3RlIGxpbmtcIiwgdHJ1ZSwgKCkgPT4ge30pLm9wZW4oKVxuXHRcdFx0fSxcblx0XHRcdGhvdGtleXM6IFtcblx0XHRcdFx0e1xuXHRcdFx0XHRcdG1vZGlmaWVyczogW2BDdHJsYCwgYE1ldGFgLCBgU2hpZnRgXSxcblx0XHRcdFx0XHRrZXk6IGBbYCxcblx0XHRcdFx0fSxcblx0XHRcdFx0e1xuXHRcdFx0XHRcdG1vZGlmaWVyczogW2BDdHJsYCwgYEFsdGAsIGBTaGlmdGBdLFxuXHRcdFx0XHRcdGtleTogYFtgLFxuXHRcdFx0XHR9LFxuXHRcdFx0XVxuXHRcdH0pXG5cblx0XHR0aGlzLmFkZE9ic2lkaWFuSWNvbignYWRkLWN1cnJlbnQtbGluay10by1lbmQtb2Ytbm90ZXMnLCAnXV0nKTtcblx0XHR0aGlzLmFkZENvbW1hbmQoe1xuXHRcdFx0aWQ6IFwiYWRkLWN1cnJlbnQtbGluay10by1lbmQtb2Ytbm90ZXNcIixcblx0XHRcdG5hbWU6IFwiTEUgXV0gQWRkIGN1cnJlbnQgbGluayB0byBlbmQtb2Ytbm90ZXNcIixcblx0XHRcdGljb246IGBhZGQtY3VycmVudC1saW5rLXRvLWVuZC1vZi1ub3Rlc2AsXG5cdFx0XHRlZGl0b3JDYWxsYmFjazogKGVkaXRvcjogRWRpdG9yLCB2aWV3OiBNYXJrZG93blZpZXcpID0+IHtcblx0XHRcdFx0Y29uc3QgbGluayA9IFwiLSBbW1wiICsgdmlldy5maWxlLmJhc2VuYW1lICsgXCJdXVwiO1xuXHRcdFx0XHRuZXcgQWRkVGV4dFRvTm90ZXNNb2RhbCh0aGlzLmFwcCwgbGluaywgXCJhZGQgdGhlIGN1cnJlbnQgbm90ZSBsaW5rXCIsIGZhbHNlLCAoKSA9PiB7fSkub3BlbigpXG5cdFx0XHR9LFxuXHRcdFx0aG90a2V5czogW1xuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bW9kaWZpZXJzOiBbYEN0cmxgLCBgTWV0YWAsIGBTaGlmdGBdLFxuXHRcdFx0XHRcdGtleTogYF1gLFxuXHRcdFx0XHR9LFxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bW9kaWZpZXJzOiBbYEN0cmxgLCBgQWx0YCwgYFNoaWZ0YF0sXG5cdFx0XHRcdFx0a2V5OiBgXWAsXG5cdFx0XHRcdH0sXG5cdFx0XHRdXG5cdFx0fSlcblxuXHRcdHRoaXMuYWRkQ29tbWFuZCh7XG5cdFx0XHRpZDogXCJxdWljay1uYXZpZ2F0ZS10by1ub3Rlc1wiLFxuXHRcdFx0bmFtZTogXCJOTiBRdWljayBOYXZpZ2F0ZSB0byBOb3Rlc1wiLFxuXHRcdFx0aWNvbjogYGFwZXJ0dXJlYCxcblx0XHRcdGNhbGxiYWNrOiBhc3luYyAoKSA9PiB7XG5cdFx0XHRcdG5ldyBOYXZpZ2F0ZVRvTm90ZUZyb21UYWdNb2RhbCh0aGlzLmFwcCkub3BlbigpXG5cdFx0XHR9LFxuXHRcdFx0aG90a2V5czogW1xuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bW9kaWZpZXJzOiBbYEN0cmxgLCBgTWV0YWAsIGBTaGlmdGBdLFxuXHRcdFx0XHRcdGtleTogYDtgLFxuXHRcdFx0XHR9LFxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bW9kaWZpZXJzOiBbYEN0cmxgLCBgQWx0YCwgYFNoaWZ0YF0sXG5cdFx0XHRcdFx0a2V5OiBgO2AsXG5cdFx0XHRcdH0sXG5cdFx0XHRdXG5cdFx0fSlcblxuXHRcdHRoaXMuYWRkT2JzaWRpYW5JY29uKCd0aHJlYWRzLXRvLXR3aXR0ZXInLCAnVFgnKTtcblx0XHR0aGlzLmFkZENvbW1hbmQoe1xuXHRcdFx0aWQ6IFwidGhyZWFkcy10by10d2l0dGVyXCIsXG5cdFx0XHRuYW1lOiBcIlRUIFRYIFRocmVhZHMgdG8gVHdpdHRlclwiLFxuXHRcdFx0aWNvbjogYHRocmVhZHMtdG8tdHdpdHRlcmAsXG5cdFx0XHRlZGl0b3JDYWxsYmFjazogKGVkaXRvcjogRWRpdG9yLCB2aWV3OiBNYXJrZG93blZpZXcpID0+IHtcblx0XHRcdFx0Y29uc3QgeyB2YXVsdCB9ID0gdGhpcy5hcHA7XG5cdFx0XHRcdGNvbnN0IHYgPSBlZGl0b3IuZ2V0VmFsdWUoKVxuXHRcdFx0XHRjb25zdCBwYXRoID0gdmlldy5maWxlLnBhdGhcblx0XHRcdFx0aWYgKCFwYXRoLm1hdGNoKC8uXFwvVGhyZWFkcyBcXGRcXGRcXGRcXGRcXGRcXGRcXGRcXGQvKSkge1xuXHRcdFx0XHRcdG5ldyBOb3RpY2UoYFdpbGwgbm90IHByb2NlZWQuIEl0IGlzIG5vdCBhIHRocmVhZHMgcG9zdC5gKTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0Y29uc3QgbmV3UGF0aCA9IHBhdGgucmVwbGFjZSgvKC5cXC8pVGhyZWFkcyAvLCBcIiQxVHdpdHRlciBcIilcblxuXHRcdFx0XHRjb25zdCB7IHdvcmtzcGFjZSB9ID0gdGhpcy5hcHA7XG5cdFx0XHRcdGNvbnN0IGxlYWYgPSB3b3Jrc3BhY2UuZ2V0TGVhZihmYWxzZSk7XG5cdFx0XHRcdFByb21pc2UucmVzb2x2ZSgpXG5cdFx0XHRcdC50aGVuKCgpID0+IHtcblx0XHRcdFx0XHRyZXR1cm4gdmF1bHQuYWRhcHRlci5leGlzdHMobmV3UGF0aCk7XG5cdFx0XHRcdH0pXG5cdFx0XHRcdC50aGVuKChmaWxlRXhpc3RzKSA9PiB7XG5cdFx0XHRcdFx0aWYgKGZpbGVFeGlzdHMpIHtcblx0XHRcdFx0XHRcdG5ldyBOb3RpY2UoYFdpbGwgbm90IHByb2NlZWQuIFR3aXR0ZXIgcG9zdCBhbHJlYWR5IGV4aXN0LmApO1xuXHRcdFx0XHRcdFx0cmV0dXJuIFByb21pc2UucmVqZWN0KFwiVHdpdHRlciBwb3N0IGFscmVhZHkgZXhpc3RcIilcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHZhdWx0LmNyZWF0ZShuZXdQYXRoLCB2KTtcblx0XHRcdFx0fSlcblx0XHRcdFx0LnRoZW4oKHRGaWxlKSA9PiB7XG5cdFx0XHRcdFx0cmV0dXJuIGxlYWYub3BlbkZpbGUodEZpbGUsIHsgYWN0aXZlIDogdHJ1ZX0pO1xuXHRcdFx0XHR9LCByZWFzb24gPT4ge30pXG5cdFx0XHRcdC50aGVuKCgpID0+IHtcblx0XHRcdFx0XHRuZXcgTm90aWNlKGBDcmVhdGVkIGFuZCBvcGVuZWQgVHdpdHRlciBub3RlcyFgKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fSlcblxuXHRcdHRoaXMuYWRkT2JzaWRpYW5JY29uKCdibG9nLXRvLWNsaXBib2FyZC1pY29uJywgJ0JKJyk7XG5cdFx0dGhpcy5hZGRDb21tYW5kKHtcblx0XHRcdGlkOiBcImJsb2ctdG8tY2xpcGJvYXJkXCIsXG5cdFx0XHRuYW1lOiBcIkJKIEJsb2cgY29udGVudCB0byBjbGlwYm9hcmRcIixcblx0XHRcdGljb246IGBibG9nLXRvLWNsaXBib2FyZC1pY29uYCxcblx0XHRcdGVkaXRvckNhbGxiYWNrOiBhc3luYyAoZWRpdG9yOiBFZGl0b3IsIHZpZXc6IE1hcmtkb3duVmlldykgPT4ge1xuXHRcdFx0XHRjb25zdCB2ID0gZWRpdG9yLmdldFZhbHVlKCk7XG5cdFx0XHRcdGlmICh2LmluY2x1ZGVzKFwiI25uXCIpIHx8IHYuaW5jbHVkZXMoXCIjbmxcIikgfHwgdi5pbmNsdWRlcyhcIiNud1wiKSB8fCB2LmluY2x1ZGVzKFwiI3duXCIpIHx8IHYuaW5jbHVkZXMoXCIjd2xcIikgfHwgdi5pbmNsdWRlcyhcIiN3d1wiKSkge1xuXHRcdFx0XHRcdG5ldyBOb3RpY2UoYFdpbGwgbm90IHByb2NlZWQuIEFzIHRoZXJlIGFyZSB1bmZpbmlzaGVkIGFjdGlvbiB0YWcuYCk7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICghdi5pbmNsdWRlcyhcIjwhLS1tb3JlLS0+XCIpKSB7XG5cdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdGF3YWl0IG5hdmlnYXRvci5jbGlwYm9hcmQud3JpdGVUZXh0KFwiPCEtLW1vcmUtLT5cIik7XG5cdFx0XHRcdFx0XHRuZXcgTm90aWNlKGBSZXF1aXJlIFwiPCEtLW1vcmUtLT5cIiBhcyBleGNlcnB0IHNlcGFyYXRvciBiZWZvcmUgcG9zdGluZy5cXG5cIjwhLS1tb3JlLS0+XCIgYWxyZWFkeSBpbiBjbGlwYm9hcmRgKTtcblx0XHRcdFx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0XHRcdFx0bmV3IE5vdGljZShgUmVxdWlyZSBcIjwhLS1tb3JlLS0+XCIgYXMgZXhjZXJwdCBzZXBhcmF0b3IgYmVmb3JlIHBvc3RpbmcuXFxuXCI8IS0tbW9yZS0tPlwiIGNhbm5vdCBiZSBjb3BpZWQgdG8gY2xpcGJvYXJkYCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNvbnN0IHBhdGggPSB2aWV3LmZpbGUucGF0aDtcblx0XHRcdFx0bGV0IGxpbmUgPSBlZGl0b3IubGluZUNvdW50KCk7XG5cdFx0XHRcdGxldCB0ZXh0ID0gXCJcIjtcblx0XHRcdFx0bGV0IG51bUxpbmVGaXJzdENvbnRlbnQgPSAwO1xuXHRcdFx0XHRsZXQgZnJvbnRNYXR0ZXJMaW5lQ291bnQgPSAwO1xuXHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGxpbmU7IGkrKykge1xuXHRcdFx0XHRcdGlmIChmcm9udE1hdHRlckxpbmVDb3VudCA9PSAyKSB7XG5cdFx0XHRcdFx0XHRudW1MaW5lRmlyc3RDb250ZW50ID0gaTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoZWRpdG9yLmdldExpbmUoaSkgPT0gXCItLS1cIikge1xuXHRcdFx0XHRcdFx0ZnJvbnRNYXR0ZXJMaW5lQ291bnQrKztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lOyBpKyspIHtcblx0XHRcdFx0XHRpZiAoZWRpdG9yLmdldExpbmUobnVtTGluZUZpcnN0Q29udGVudCkudHJpbSgpID09IFwiXCIpIHtcblx0XHRcdFx0XHRcdG51bUxpbmVGaXJzdENvbnRlbnQrKztcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0QXJyYXkuZnJvbShBcnJheShsaW5lIC0gbnVtTGluZUZpcnN0Q29udGVudCkua2V5cygpKS5mb3JFYWNoKGkgPT4ge1xuXHRcdFx0XHRcdGNvbnN0IGxpbmUgPSBlZGl0b3IuZ2V0TGluZShpICsgbnVtTGluZUZpcnN0Q29udGVudCk7XG5cdFx0XHRcdFx0dGV4dCA9IHRleHQgKyBsaW5lICsgXCJcXG5cIjtcblx0XHRcdFx0fSk7XG5cdFx0XHRcdHRleHQgPSB0ZXh0LnJlcGxhY2UoL1xcbi0tLVxcblxcbiNuZCBnZW5lcmF0ZSBzdW1tYXJ5IGZvciBtZXRhIGRlc2NyaXB0aW9uIGJlbG93OlxcblteXFxuXSpcXG4oW15cXG5dKilcXG5bXlxcbl0qXFxuLS0tXFxuLywgXCJcXG48IS0tIE1ldGEgU3VtbWFyeSAtLT5cXG48IS0tXFxuJDFcXG4tLT5cXG5cIik7XG5cdFx0XHRcdHRleHQgPSB0ZXh0LnJlcGxhY2UoLyMjIFJlZmVyZW5jZXNcXDooW1xcbl0qLiopKiQvLCBcIlwiKTtcblxuXHRcdFx0XHRjb25zdCBhcHAgPSB0aGlzLmFwcDtcblx0XHRcdFx0Y29uc3QgYmVmb3JlVGFnQ0JSID0gXCJjL2IvclwiO1xuXHRcdFx0XHRjb25zdCBiZWZvcmVUYWdDQkQgPSBcImMvYi9kXCI7XG5cdFx0XHRcdGNvbnN0IGJlZm9yZVRhZ0NCSSA9IFwiYy9iL2lcIjtcblx0XHRcdFx0Y29uc3QgYWZ0ZXJUYWcgPSBcImMvYi9wXCI7XG5cblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRhd2FpdCBuYXZpZ2F0b3IuY2xpcGJvYXJkLndyaXRlVGV4dCh0ZXh0KTtcblx0XHRcdFx0XHRuZXcgTm90aWNlKGBDb3BpZWQgYmxvZyBjb250ZW50IHRvIGNsaXBib2FyZCFgKTtcblx0XHRcdFx0XHRjb25zdCBmb3VuZFRhZ0Zyb21DQlIgPSBhd2FpdCByZW5hbWVUYWcodmlldy5maWxlLCBiZWZvcmVUYWdDQlIsIGFmdGVyVGFnKTtcblx0XHRcdFx0XHRpZiAoZm91bmRUYWdGcm9tQ0JSKSB7XG5cdFx0XHRcdFx0XHRuZXcgTm90aWNlKGBVcGRhdGUgbm90ZXMgdHlwZSBmcm9tIHRhZz1cIiR7YmVmb3JlVGFnQ0JSfVwiIHRvIHRhZz1cIiR7YWZ0ZXJUYWd9IWApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjb25zdCBmb3VuZFRhZ0Zyb21DQkkgPSBhd2FpdCByZW5hbWVUYWcodmlldy5maWxlLCBiZWZvcmVUYWdDQkksIGFmdGVyVGFnKTtcblx0XHRcdFx0XHRpZiAoZm91bmRUYWdGcm9tQ0JJKSB7XG5cdFx0XHRcdFx0XHRuZXcgTm90aWNlKGBVcGRhdGUgbm90ZXMgdHlwZSBmcm9tIHRhZz1cIiR7Zm91bmRUYWdGcm9tQ0JJfVwiIHRvIHRhZz1cIiR7YWZ0ZXJUYWd9IWApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjb25zdCBmb3VuZFRhZ0Zyb21DQkQgPSBhd2FpdCByZW5hbWVUYWcodmlldy5maWxlLCBiZWZvcmVUYWdDQkQsIGFmdGVyVGFnKTtcblx0XHRcdFx0XHRpZiAoZm91bmRUYWdGcm9tQ0JEKSB7XG5cdFx0XHRcdFx0XHRuZXcgTm90aWNlKGBVcGRhdGUgbm90ZXMgdHlwZSBmcm9tIHRhZz1cIiR7YmVmb3JlVGFnQ0JEfVwiIHRvIHRhZz1cIiR7YWZ0ZXJUYWd9IWApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRhd2FpdCByZW5hbWVCbG9nVGl0bGUoYXBwLCBwYXRoLCB2aWV3KTtcblx0XHRcdFx0XHR3aW5kb3cub3Blbihgc2hvcnRjdXRzOi8vcnVuLXNob3J0Y3V0P25hbWU9SmVreWxsJTIwYmxvZyZ4LWNhbmNlbD1vYnNpZGlhbjovLyZ4LWVycm9yPW9ic2lkaWFuOi8vYCk7XG5cdFx0XHRcdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRcdFx0bmV3IE5vdGljZShgRXJyb3Igb2NjdXJyZWQgZHVyaW5nIHRoZSBvcGVyYXRpb246ICR7ZXJyb3J9YCk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0fSk7XG5cblx0XHR0aGlzLmFkZE9ic2lkaWFuSWNvbignZ2VuZXJhdGUtY2hhdGdwdC1wcm9tcHQnLCAnR1AnKTtcblx0XHR0aGlzLmFkZENvbW1hbmQoe1xuXHRcdFx0aWQ6IFwiZ2VuZXJhdGUtY2hhdGdwdC1wcm9tcHRcIixcblx0XHRcdG5hbWU6IFwiR1AgR2VuZXJhdGUgQ2hhdEdQVCBQcm9tcHRcIixcblx0XHRcdGljb246IGBnZW5lcmF0ZS1jaGF0Z3B0LXByb21wdGAsXG5cdFx0XHRlZGl0b3JDYWxsYmFjazogYXN5bmMgKGVkaXRvcjogRWRpdG9yLCB2aWV3OiBNYXJrZG93blZpZXcpID0+IHtcblx0XHRcdFx0bGV0IGxpbmUgPSBlZGl0b3IubGluZUNvdW50KCk7XG5cblx0XHRcdFx0bGV0IHRleHQgPSBcIlx1MzAxMFwiICsgdmlldy5maWxlLmJhc2VuYW1lICsgXCJcdTMwMTFcXG5cXG5cIjtcblx0XHRcdFx0bGV0IG51bUxpbmVGaXJzdENvbnRlbnQgPSAwXG5cdFx0XHRcdGxldCBmcm9udE1hdHRlckxpbmVDb3VudCA9IDBcblx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lOyBpKyspIHtcblx0XHRcdFx0XHRpZiAoZnJvbnRNYXR0ZXJMaW5lQ291bnQgPT0gMikge1xuXHRcdFx0XHRcdFx0bnVtTGluZUZpcnN0Q29udGVudCA9IGk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKGVkaXRvci5nZXRMaW5lKGkpID09IFwiLS0tXCIpIHtcblx0XHRcdFx0XHRcdGZyb250TWF0dGVyTGluZUNvdW50Kytcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lOyBpKyspIHtcblx0XHRcdFx0XHRpZiAoZWRpdG9yLmdldExpbmUobnVtTGluZUZpcnN0Q29udGVudCkudHJpbSgpID09IFwiXCIpIHtcblx0XHRcdFx0XHRcdG51bUxpbmVGaXJzdENvbnRlbnQrKztcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0QXJyYXkuZnJvbShBcnJheShsaW5lIC0gbnVtTGluZUZpcnN0Q29udGVudCkua2V5cygpKS5mb3JFYWNoKGkgPT4ge1xuXHRcdFx0XHRcdGNvbnN0IGxpbmUgPSBlZGl0b3IuZ2V0TGluZShpICsgbnVtTGluZUZpcnN0Q29udGVudCk7XG5cdFx0XHRcdFx0aWYgKCFsaW5lLnN0YXJ0c1dpdGgoXCIlJVwiKSAmJiAhbGluZS5lbmRzV2l0aChcIiUlXCIpKSB7XG5cdFx0XHRcdFx0XHR0ZXh0ID0gdGV4dCArIGxpbmUgKyBcIlxcblwiXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdFx0XG5cdFx0XHRcdHRleHQgPSB0ZXh0LnJlcGxhY2UoLyMjIFJlZmVyZW5jZXNcXDooW1xcbl0qLiopKiQvLCBcIlwiKVxuXHRcdFx0XHRcblx0XHRcdFx0bmF2aWdhdG9yLmNsaXBib2FyZC53cml0ZVRleHQodGV4dCkudGhlbihmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0bmV3IE5vdGljZShgQ29waWVkIGNvbnRlbnQgdG8gY2xpcGJvYXJkIGZvciBnZW5lcmF0aW5nIHByb21wdCFgKTtcblx0XHRcdFx0XHR3aW5kb3cub3Blbihgc2hvcnRjdXRzOi8vcnVuLXNob3J0Y3V0P25hbWU9R2VuZXJhdGUlMjBDaGF0R1BUJTIwUHJvbXB0Jngtc3VjY2Vzcz1vYnNpZGlhbjovLyZ4LWNhbmNlbD1vYnNpZGlhbjovLyZ4LWVycm9yPW9ic2lkaWFuOi8vYCk7XG5cdFx0XHRcdH0sIGZ1bmN0aW9uIChlcnJvcikge1xuXHRcdFx0XHRcdG5ldyBOb3RpY2UoYGVycm9yIHdoZW4gY29weSB0byBjbGlwYm9hcmQhYCk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSxcblx0XHR9KTtcblxuXHRcdHRoaXMuYWRkT2JzaWRpYW5JY29uKCd0aHJlYWRzLXRvLWNsaXBib2FyZC1pY29uJywgJ1RDJyk7XG5cdFx0dGhpcy5hZGRDb21tYW5kKHtcblx0XHRcdGlkOiBcInRocmVhZHMtdG8tY2xpcGJvYXJkXCIsXG5cdFx0XHRuYW1lOiBcIlRDIFRocmVhZHMgY29udGVudCB0byBjbGlwYm9hcmRcIixcblx0XHRcdGljb246IGB0aHJlYWRzLXRvLWNsaXBib2FyZC1pY29uYCxcblx0XHRcdGVkaXRvckNhbGxiYWNrOiAoZWRpdG9yOiBFZGl0b3IsIHZpZXc6IE1hcmtkb3duVmlldykgPT4ge1xuXHRcdFx0XHRjb25zdCB2YWx1ZSA9IGVkaXRvci5nZXRWYWx1ZSgpXG5cdFx0XHRcdC8vaWYgKCF2YWx1ZS5jb250YWlucyhcIiUlICN0bSB0byB6ayAlJVwiKSAmJiAhdmFsdWUuY29udGFpbnMoXCIlJSAjbmQgdG8gemsgJSVcIikpIHtcblx0XHRcdFx0Ly9cdHRoaXMuYWRkVGFza1RvUHV0SW50b0NhcmRJblRocmVhZHNDb250ZW50KGVkaXRvcilcblx0XHRcdFx0Ly99XG5cdFx0XHRcdGNvbnN0IHRleHQgPSB0aGlzLmNvbnZlcnRUaHJlYWRzQ29udGVudFRvRm9ybWF0Rm9yVGhyZWFkc0FwcChlZGl0b3IpXG5cdFx0XHRcdGNvbnN0IGJlZm9yZVRhZyA9IFwiYy90L3JcIlxuXHRcdFx0XHRjb25zdCBhZnRlclRhZyA9IFwiYy90L3RcIlxuXHRcdFx0XG5cdFx0XHRcdG5hdmlnYXRvci5jbGlwYm9hcmQud3JpdGVUZXh0KHRleHQpXG5cdFx0XHRcdC50aGVuKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRyZXR1cm4gcmVuYW1lVGFnKHZpZXcuZmlsZSwgYmVmb3JlVGFnLCBhZnRlclRhZylcblx0XHRcdFx0fSwgZnVuY3Rpb24gKGVycm9yKSB7XG5cdFx0XHRcdFx0bmV3IE5vdGljZShgZXJyb3Igd2hlbiBjb3B5IHRvIGNsaXBib2FyZCFgKTtcblx0XHRcdFx0fSlcblx0XHRcdFx0LnRoZW4oKGZvdW5kVGFnKSA9PiB7XG5cdFx0XHRcdFx0aWYgKGZvdW5kVGFnKSB7XG5cdFx0XHRcdFx0XHRuZXcgTm90aWNlKGBVcGRhdGUgbm90ZXMgdHlwZSBmcm9tIHRhZz1cIiR7YmVmb3JlVGFnfVwiIHRvIHRhZz1cIiR7YWZ0ZXJUYWd9IVxcbkNvcGllZCB0aHJlYWQgY29udGVudCB0byBjbGlwYm9hcmQhYCk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdG5ldyBOb3RpY2UoYFRhZyBcIiR7YmVmb3JlVGFnfVwiIG5vdCBmb3VuZFxcbkNvcGllZCB0aHJlYWQgY29udGVudCB0byBjbGlwYm9hcmQhYCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdH0sXG5cdFx0fSk7XG5cblx0XHR0aGlzLmFkZE9ic2lkaWFuSWNvbigndHdpdHRlci10by1jaGF0Z3B0JywgJ1hHJyk7XG5cdFx0dGhpcy5hZGRDb21tYW5kKHtcblx0XHRcdGlkOiBcInR3aXR0ZXItdG8tY2hhdGdwdFwiLFxuXHRcdFx0bmFtZTogXCJYRyBUd2l0dGVyIHRvIENoYXRHUFRcIixcblx0XHRcdGljb246IGB0d2l0dGVyLXRvLWNoYXRncHRgLFxuXHRcdFx0ZWRpdG9yQ2FsbGJhY2s6IChlZGl0b3I6IEVkaXRvciwgdmlldzogTWFya2Rvd25WaWV3KSA9PiB7XG5cdFx0XHRcdGNvbnN0IHZhbHVlID0gZWRpdG9yLmdldFZhbHVlKClcblxuXHRcdFx0XHRpZiAoIXZpZXcuZmlsZS5iYXNlbmFtZS5jb250YWlucyhcIlR3aXR0ZXJcIikpIHtcblx0XHRcdFx0XHRuZXcgTm90aWNlKFwiTm90ZSBuYW1lIG5vdCBjb250YWlucyAnVHdpdHRlcicsIGRpZCBub3QgY29weSBmcm9tIHRocmVhZCBub3RlP1wiKVxuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0bGV0IGNvbnRlbnQgPSB0aGlzLmNvbnZlcnRUaHJlYWRzQ29udGVudFRvRm9ybWF0Rm9yRmFjZWJvb2tBcHAoZWRpdG9yKVxuXHRcdFx0XHRsZXQgbnVtVHdlZXQgPSBNYXRoLmNlaWwoY29udGVudC5sZW5ndGggLyAxMTApXG5cdFx0XHRcdGxldCBwcm9tcHQgPSBgWW91IGFyZSBhIHNvY2lhbCBtZWRpYSBjb250ZW50IGNvcHl3cml0ZXIuIENvbnZlcnQgdGhlIGZvbGxvd2luZyBjb250ZW50IHRvIHR3aXR0ZXIgdGhyZWFkcyBsZXNzIHRoYW4gJHtudW1Ud2VldH0gdHdlZXQgaW4gdHJhZGl0aW9uYWwgQ2hpbmVzZS4gUHJlc2VydmUgdGhlIHRpdGxlLiBNZXJnZSB0aXRsZSB3aXRoIHRoZSBmaXJzdCB0d2VldCB3aGlsZSBhZGQgMiBuZXdsaW5lIGNoYXJhY3RlcnMgYmV0d2VlbiB0aXRsZSBhbmQgZmlyc3QgdHdlZXQuIEV2ZXJ5IHR3ZWV0IGhhcyB0byBvdmVyIDEwMCBidXQgbGVzcyB0aGFuIDE0MCBDaGluZXNlIGNoYXJhY3RlcnMuIERvIG5vdCBzaW1wbGlmeSB0aGUgY29udGVudC4gRG8gbm90IGFkZCBhbnkgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiB3aGljaCBpcyBub3QgbWVudGlvbmVkIGZyb20gdGhlIG9yaWdpbmFsIGNvbnRlbnQuIFByZXNlcnZlIHRoZSBleGFtcGxlIGZyb20gdGhlIGNvbnRlbnQuIE5vIG5lZWQgdG8gYWRkIGFueSB0YWdzIHRvIHRoZSB0d2VldC4gRG8gbm90IGhhdmUgYW55IG51bWJlciBpbiBlYWNoIHR3ZWV0LiBFYWNoIHR3ZWV0IHNlcGFyYXRlZCBieSAyIG5ld2xpbmUgYW5kIDMgXCItXCIgY2hhcmFjdGVycyBhbmQgYW5vdGhlciBuZXdsaW5lLiBBZGQgYSBzcGFjZSBjaGFyYWN0ZXIgYmV0d2VlbiBlYWNoIEVuZ2xpc2ggY2hhcmFjdGVyIGFuZCBDaGluZXNlIGNoYXJhY3Rlci4gSWYgdGhlIG9yaWdpbmFsIGNvbnRlbnQgY29udGFpbnMgYW55IFVSTCwgcHJlc2VydmUgdGhlIFVSTCBpbiB0aGUgdHdlZXQgd2l0aG91dCB1c2luZyBhbnkgTWFya2Rvd24gZm9ybWF0IGZvciB0aGUgVVJMIHdoaWxlIGFkZCAyIG5ld2xpbmUgY2hhcmFjdGVyIGJlZm9yZSB0aGUgVVJMLmBcblx0XHRcdFx0Ly9sZXQgcHJvbXB0ID0gYENvbnZlcnQgdGhlIGZvbGxvd2luZyBjb250ZW50IHRvIHR3aXR0ZXIgdGhyZWFkcyBsZXNzIHRoYW4gJHtudW1Ud2VldH0gdHdlZXQgaW4gdHJhZGl0aW9uYWwgQ2hpbmVzZS4gUHJlc2VydmUgdGhlIHRpdGxlLiBEbyBub3QgYWRkIGFueSBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIHdoaWNoIGlzIG5vdCBtZW50aW9uZWQgZnJvbSB0aGUgb3JpZ2luYWwgY29udGVudC4gTm8gbmVlZCB0byBhZGQgYW55IHRhZ3MgdG8gdGhlIHR3ZWV0LiBEbyBub3QgaGF2ZSBhbnkgbnVtYmVyIGluIGVhY2ggdHdlZXQuIEVhY2ggdHdlZXQgc2VwYXJhdGVkIGJ5IG5ld2xpbmUgY2hhcmFjdGVyIGFuZCAzIFwiLVwiIGNoYXJhY3RlcnMgYW5kIGFub3RoZXIgbmV3bGluZSBjaGFyYWN0ZXIuYFxuXHRcdFx0XHRwcm9tcHQgPSBwcm9tcHQgKyBcIlxcblxcblwiICsgY29udGVudFxuXHRcdFx0XHRwcm9tcHQgPSBwcm9tcHQucmVwbGFjZSgvXHUyNThEL2csIFwiXCIpXG5cdFx0XHRcdHByb21wdCA9IHByb21wdC5yZXBsYWNlKC9cdTMwMTFcXG4raHR0cHNcXDpcXC9cXC9naXRodWIuY29tW15cXG5dK1xcbi9tLCBcIlx1MzAxMVxcblwiKVxuXHRcdFx0XHRwcm9tcHQgPSBwcm9tcHQucmVwbGFjZSgvXFwqXFwqL2dtLCBcIlwiKVxuXHRcdFx0XHQvL3Byb21wdCA9IHByb21wdC5yZXBsYWNlKC8hXFxbXFxTKlxcXVxcKCgoaHR0cHM6fGh0dHA6fHd3d1xcLilcXFMqKVxcKS9nbSwgXCIkMVwiKVxuXG5cdFx0XHRcdG5hdmlnYXRvci5jbGlwYm9hcmQud3JpdGVUZXh0KHByb21wdCkudGhlbihmdW5jdGlvbiAoKSB7XG5cblx0XHRcdFx0XHRsZXQgbGluZSA9IGVkaXRvci5saW5lQ291bnQoKTtcblxuXHRcdFx0XHRcdGxldCBudW1MaW5lRmlyc3RDb250ZW50ID0gMFxuXHRcdFx0XHRcdGxldCBmcm9udE1hdHRlckxpbmVDb3VudCA9IDBcblx0XHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGxpbmU7IGkrKykge1xuXHRcdFx0XHRcdFx0aWYgKGZyb250TWF0dGVyTGluZUNvdW50ID09IDIpIHtcblx0XHRcdFx0XHRcdFx0bnVtTGluZUZpcnN0Q29udGVudCA9IGk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKGVkaXRvci5nZXRMaW5lKGkpID09IFwiLS0tXCIpIHtcblx0XHRcdFx0XHRcdFx0ZnJvbnRNYXR0ZXJMaW5lQ291bnQrK1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGxpbmU7IGkrKykge1xuXHRcdFx0XHRcdFx0aWYgKGVkaXRvci5nZXRMaW5lKG51bUxpbmVGaXJzdENvbnRlbnQpLnRyaW0oKSA9PSBcIlwiKSB7XG5cdFx0XHRcdFx0XHRcdG51bUxpbmVGaXJzdENvbnRlbnQrKztcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGxldCB0ZXh0ID0gXCJcIjtcblx0XHRcdFx0XHRBcnJheS5mcm9tKEFycmF5KG51bUxpbmVGaXJzdENvbnRlbnQpLmtleXMoKSkuZm9yRWFjaChpID0+IHtcblx0XHRcdFx0XHRcdGNvbnN0IGxpbmUgPSBlZGl0b3IuZ2V0TGluZShpKTtcblx0XHRcdFx0XHRcdHRleHQgPSB0ZXh0ICsgbGluZSArIFwiXFxuXCJcblx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdGVkaXRvci5zZXRWYWx1ZSh0ZXh0KVxuXG5cdFx0XHRcdFx0cmVuYW1lVGFnKHZpZXcuZmlsZSwgXCJjL3QvZFwiLCBcImMveC9kXCIpXG5cdFx0XHRcdFx0cmVuYW1lVGFnKHZpZXcuZmlsZSwgXCJjL3QvclwiLCBcImMveC9kXCIpXG5cdFx0XHRcdFx0cmVuYW1lVGFnKHZpZXcuZmlsZSwgXCJjL3QvdFwiLCBcImMveC9kXCIpXG5cdFx0XHRcdFx0cmVuYW1lVGFnKHZpZXcuZmlsZSwgXCJjL3QvcFwiLCBcImMveC9kXCIpXG5cblx0XHRcdFx0XHRjb25zdCBjdXJzb3IgPSBlZGl0b3IuZ2V0Q3Vyc29yKClcblx0XHRcdFx0XHRjdXJzb3IubGluZSA9IGVkaXRvci5saW5lQ291bnQoKSAtIDFcblx0XHRcdFx0XHRjdXJzb3IuY2ggPSAwXG5cdFx0XHRcdFx0ZWRpdG9yLnNldEN1cnNvcihjdXJzb3IpXG5cblx0XHRcdFx0XHRuZXcgTm90aWNlKFwiY29waWVkIHRvIGNsaXBib2FyZCwgcGxlYXNlIG9wZW4gY2hhdGdwdCB0byBwYXN0ZVwiKVxuXHRcdFx0XHR9LCBmdW5jdGlvbiAoZXJyb3IpIHtcblx0XHRcdFx0XHRuZXcgTm90aWNlKGBlcnJvciB3aGVuIGNvcHkgdG8gY2xpcGJvYXJkIWApO1xuXHRcdFx0XHR9KTtcblx0XHRcdH0sXG5cdFx0fSk7XG5cblx0XHR0aGlzLmFkZE9ic2lkaWFuSWNvbignY2hhdGdwdC10by10d2l0dGVyJywgJ0dYJyk7XG5cdFx0dGhpcy5hZGRDb21tYW5kKHtcblx0XHRcdGlkOiBcImNoYXRncHQtdG8tdHdpdHRlclwiLFxuXHRcdFx0bmFtZTogXCJHWCBDaGF0R1BUIHRvIFR3aXR0ZXJcIixcblx0XHRcdGljb246IGBjaGF0Z3B0LXRvLXR3aXR0ZXJgLFxuXHRcdFx0ZWRpdG9yQ2FsbGJhY2s6IChlZGl0b3I6IEVkaXRvciwgdmlldzogTWFya2Rvd25WaWV3KSA9PiB7XG5cdFx0XHRcdGlmICghZWRpdG9yLmdldFZhbHVlKCkuY29udGFpbnMoXCJjL3gvZFwiKSkge1xuXHRcdFx0XHRcdG5ldyBOb3RpY2UoXCJOb3RlIHR5cGUgbm90IGMveC9kLCBkbyB0aGUgYWN0aW9uIGluIHdyb25nIG5vdGU/XCIpXG5cdFx0XHRcdFx0cmV0dXJuXG5cdFx0XHRcdH1cblx0XHRcdFx0Y29uc3QgaXNTdWNjZXNzID0gdGhpcy5jb252ZXJ0Q2hhdEdQVFRvVHdpdHRlckZvcm1hdChlZGl0b3IpXG5cdFx0XHRcdGlmIChpc1N1Y2Nlc3MpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRyZW5hbWVUYWcodmlldy5maWxlLCBcImMveC9kXCIsIFwiYy94L3JcIilcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHR9KTtcblxuXHRcdHRoaXMuYWRkT2JzaWRpYW5JY29uKCdyZXZlcnNlLXR3aXR0ZXItbnVtYmVyLWljb24nLCAnUlQnKTtcblx0XHR0aGlzLmFkZENvbW1hbmQoe1xuXHRcdFx0aWQ6IFwicmV2ZXJzZS10d2l0dGVyLW51bWJlcmluZ1wiLFxuXHRcdFx0bmFtZTogXCJSVCBSZXZlcnNlIFR3aXR0ZXIgTnVtYmVyaW5nXCIsXG5cdFx0XHRpY29uOiBgcmV2ZXJzZS10d2l0dGVyLW51bWJlci1pY29uYCxcblx0XHRcdGVkaXRvckNhbGxiYWNrOiAoZWRpdG9yOiBFZGl0b3IsIHZpZXc6IE1hcmtkb3duVmlldykgPT4ge1xuXHRcdFx0XHRpZiAoIWVkaXRvci5nZXRWYWx1ZSgpLmNvbnRhaW5zKFwiYy94L3JcIikgJiYgIWVkaXRvci5nZXRWYWx1ZSgpLmNvbnRhaW5zKFwiYy94L3BcIikpIHtcblx0XHRcdFx0XHRuZXcgTm90aWNlKFwiTm90ZSB0eXBlIG5vdCBjL3gvciBub3IgYy94L3AsIGRvIHRoZSBhY3Rpb24gaW4gd3Jvbmcgbm90ZT9cIilcblx0XHRcdFx0XHRyZXR1cm5cblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLnJldmVyc2VUd2l0dGVyTnVtYmVyaW5nKGVkaXRvcilcblx0XHRcdFx0cmVuYW1lVGFnKHZpZXcuZmlsZSwgXCJjL3gvcFwiLCBcImMveC9kXCIpXG5cdFx0XHRcdHJlbmFtZVRhZyh2aWV3LmZpbGUsIFwiYy94L3JcIiwgXCJjL3gvZFwiKVxuXHRcdFx0fSxcblx0XHR9KTtcblxuXHRcdHRoaXMuYWRkT2JzaWRpYW5JY29uKCd0aHJlYWRzLWFzLWZhY2Vib29rLXBvc3QtdG8tY2xpcGJvYXJkLWljb24nLCAnRkMnKTtcblx0XHR0aGlzLmFkZENvbW1hbmQoe1xuXHRcdFx0aWQ6IFwidGhyZWFkcy1hcy1mYWNlYm9vay1wb3N0LXRvLWNsaXBib2FyZFwiLFxuXHRcdFx0bmFtZTogXCJGQyBUaHJlYWRzIGFzIEZhY2Vib29rIHBvc3QgZm9ybWF0IHRvIENsaXBib2FyZFwiLFxuXHRcdFx0aWNvbjogYHRocmVhZHMtYXMtZmFjZWJvb2stcG9zdC10by1jbGlwYm9hcmQtaWNvbmAsXG5cdFx0XHRlZGl0b3JDYWxsYmFjazogKGVkaXRvcjogRWRpdG9yLCB2aWV3OiBNYXJrZG93blZpZXcpID0+IHtcblx0XHRcdFx0Y29uc3QgdmFsdWUgPSBlZGl0b3IuZ2V0VmFsdWUoKVxuXHRcdFx0XHQvL2lmICghdmFsdWUuY29udGFpbnMoXCIlJSAjbm0gdG8gemsgJSVcIikgJiYgIXZhbHVlLmNvbnRhaW5zKFwiJSUgI25kIHRvIHprICUlXCIpKSB7XG5cdFx0XHRcdC8vXHR0aGlzLmFkZFRhc2tUb1B1dEludG9DYXJkSW5UaHJlYWRzQ29udGVudChlZGl0b3IpXG5cdFx0XHRcdC8vfVxuXHRcdFx0XHRjb25zdCB0ZXh0ID0gdGhpcy5jb252ZXJ0VGhyZWFkc0NvbnRlbnRUb0Zvcm1hdEZvckZhY2Vib29rQXBwKGVkaXRvcilcblx0XHRcdFxuXHRcdFx0XHRjb25zdCBiZWZvcmVUYWcgPSBcImMvdC90XCJcblx0XHRcdFx0Y29uc3QgYWZ0ZXJUYWcgPSBcImMvdC9wXCJcblx0XHRcdFxuXHRcdFx0XHRuYXZpZ2F0b3IuY2xpcGJvYXJkLndyaXRlVGV4dCh0ZXh0KVxuXHRcdFx0XHQudGhlbihmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHJlbmFtZVRhZyh2aWV3LmZpbGUsIGJlZm9yZVRhZywgYWZ0ZXJUYWcpXG5cdFx0XHRcdH0sIGZ1bmN0aW9uIChlcnJvcikge1xuXHRcdFx0XHRcdG5ldyBOb3RpY2UoYGVycm9yIHdoZW4gY29weSB0byBjbGlwYm9hcmQhYCk7XG5cdFx0XHRcdH0pXG5cdFx0XHRcdC50aGVuKChmb3VuZFRhZykgPT4ge1xuXHRcdFx0XHRcdGlmIChmb3VuZFRhZykge1xuXHRcdFx0XHRcdFx0bmV3IE5vdGljZShgVXBkYXRlIG5vdGVzIHR5cGUgZnJvbSB0YWc9XCIke2JlZm9yZVRhZ31cIiB0byB0YWc9XCIke2FmdGVyVGFnfSFcXG5Db3BpZWQgZmIgY29udGVudCB0byBjbGlwYm9hcmQhYCk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdG5ldyBOb3RpY2UoYFRhZyBcIiR7YmVmb3JlVGFnfVwiIG5vdCBmb3VuZFxcbkNvcGllZCBmYiBjb250ZW50IHRvIGNsaXBib2FyZCFgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSxcblx0XHR9KTtcblxuXHRcdHRoaXMuYWRkT2JzaWRpYW5JY29uKCd0aHJlYWRzLWJsb2NrLXRvLWltYWdlJywgJ1RJJyk7XG5cdFx0dGhpcy5hZGRDb21tYW5kKHtcblx0XHRcdGlkOiBcInRocmVhZHMtYmxvY2stdG8taW1hZ2VcIixcblx0XHRcdG5hbWU6IFwiVEkgVGhyZWFkcyBzZWdtZW50IHRvIGltYWdlXCIsXG5cdFx0XHRpY29uOiBgdGhyZWFkcy1ibG9jay10by1pbWFnZWAsXG5cdFx0XHRlZGl0b3JDYWxsYmFjazogKGVkaXRvcjogRWRpdG9yLCB2aWV3OiBNYXJrZG93blZpZXcpID0+IHtcblx0XHRcdFx0Y29uc3QgdGhyZWFkU2VnbWVudCA9IHRoaXMuZ2V0VGhyZWFkU2VnbWVudChlZGl0b3IpXG5cdFx0XHRcdG5ldyBUaHJlYWRzVG9JbWFnZXNNb2RhbCh0aGlzLmFwcCwgdGhyZWFkU2VnbWVudCkub3BlbigpXG5cdFx0XHR9LFxuXHRcdH0pO1xuXG5cdFx0dGhpcy5hZGRPYnNpZGlhbkljb24oJ2NoYXRncHQtZ2VuZXJhdGUtaW1hZ2UnLCAnR0knKTtcblx0XHR0aGlzLmFkZENvbW1hbmQoe1xuXHRcdFx0aWQ6IFwiY2hhdGdwdC1nZW5lcmF0ZS1pbWFnZVwiLFxuXHRcdFx0bmFtZTogXCJHSSBDaGF0R1BUIGltYWdlXCIsXG5cdFx0XHRpY29uOiBgY2hhdGdwdC1nZW5lcmF0ZS1pbWFnZWAsXG5cdFx0XHRlZGl0b3JDYWxsYmFjazogKGVkaXRvcjogRWRpdG9yLCB2aWV3OiBNYXJrZG93blZpZXcpID0+IHtcblx0XHRcdFx0d2luZG93Lm9wZW4oJ3Nob3J0Y3V0czovL3J1bi1zaG9ydGN1dD9uYW1lPUNoYXRHUFQlMjBHZW5lcmF0ZSUyMEltYWdlJngtc3VjY2Vzcz1vYnNpZGlhbjovLyZ4LWNhbmNlbD1vYnNpZGlhbjovLyZ4LWVycm9yPW9ic2lkaWFuOi8vJyk7XG5cdFx0XHR9LFxuXHRcdH0pO1xuXG5cdFx0Lypcblx0XHR0aGlzLmFkZE9ic2lkaWFuSWNvbigndGhyZWFkcy1zZWdtZW50LXRvLWNsaXBib2FyZCcsICdTQycpO1xuXHRcdHRoaXMuYWRkQ29tbWFuZCh7XG5cdFx0XHRpZDogXCJ0aHJlYWRzLXNlZ21lbnQtdG8tY2xpcGJvYXJkXCIsXG5cdFx0XHRuYW1lOiBcIlRocmVhZHMgc2VnbWVudCB0byBjbGlwYm9hcmRcIixcblx0XHRcdGljb246IGB0aHJlYWRzLXNlZ21lbnQtdG8tY2xpcGJvYXJkYCxcblx0XHRcdGVkaXRvckNhbGxiYWNrOiAoZWRpdG9yOiBFZGl0b3IsIHZpZXc6IE1hcmtkb3duVmlldykgPT4ge1xuXHRcdFx0XHRjb25zdCB0aHJlYWRTZWdtZW50ID0gdGhpcy5nZXRUaHJlYWRTZWdtZW50KGVkaXRvcilcblx0XHRcdFx0Y29uc3QgYmVmb3JlVGFnID0gXCJjL3gvclwiXG5cdFx0XHRcdGNvbnN0IGFmdGVyVGFnID0gXCJjL3gvcFwiXG5cdFx0XHRcdG5hdmlnYXRvci5jbGlwYm9hcmQud3JpdGVUZXh0KHRocmVhZFNlZ21lbnQpXG5cdFx0XHRcdC50aGVuKGZ1bmN0aW9uICgpIHtcdFxuXHRcdFx0XHRcdHJldHVybiByZW5hbWVUYWcodmlldy5maWxlLCBiZWZvcmVUYWcsIGFmdGVyVGFnKVxuXHRcdFx0XHR9LCBmdW5jdGlvbiAoZXJyb3IpIHtcblx0XHRcdFx0XHRuZXcgTm90aWNlKGBlcnJvciB3aGVuIGNvcHkgdG8gY2xpcGJvYXJkIWApO1xuXHRcdFx0XHR9KVxuXHRcdFx0XHQudGhlbigoZm91bmRUYWcpID0+IHtcblx0XHRcdFx0XHRpZiAoZm91bmRUYWcpIHtcblx0XHRcdFx0XHRcdG5ldyBOb3RpY2UoYFVwZGF0ZSBub3RlcyB0eXBlIGZyb20gdGFnPVwiJHtiZWZvcmVUYWd9XCIgdG8gdGFnPVwiJHthZnRlclRhZ30hXFxuQ29waWVkXFxuXFxgXFxgXFxgXFxuJHt0aHJlYWRTZWdtZW50fVxcYFxcYFxcYFxcbnRvIGNsaXBib2FyZCFgKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0bmV3IE5vdGljZShgVGFnIFwiJHtiZWZvcmVUYWd9XCIgbm90IGZvdW5kXFxuQ29waWVkXFxuXFxgXFxgXFxgXFxuJHt0aHJlYWRTZWdtZW50fVxcYFxcYFxcYFxcbnRvIGNsaXBib2FyZCFgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSxcblx0XHR9KTtcblx0XHQqL1xuXG5cdFx0dGhpcy5hZGRPYnNpZGlhbkljb24oJ3R3aXR0ZXItc2VnbWVudC10by1jbGlwYm9hcmQnLCAnWEMnKTtcblx0XHR0aGlzLmFkZENvbW1hbmQoe1xuXHRcdFx0aWQ6IFwidHdpdHRlci1zZWdtZW50LXRvLWNsaXBib2FyZFwiLFxuXHRcdFx0bmFtZTogXCJYQyBUd2l0dGVyIHNlZ21lbnQgdG8gY2xpcGJvYXJkXCIsXG5cdFx0XHRpY29uOiBgdHdpdHRlci1zZWdtZW50LXRvLWNsaXBib2FyZGAsXG5cdFx0XHRlZGl0b3JDYWxsYmFjazogKGVkaXRvcjogRWRpdG9yLCB2aWV3OiBNYXJrZG93blZpZXcpID0+IHtcblx0XHRcdFx0Y29uc3QgdGhyZWFkU2VnbWVudCA9IHRoaXMuZ2V0VHdpdHRlclNlZ21lbnQoZWRpdG9yKVxuXHRcdFx0XHRjb25zdCBiZWZvcmVUYWcgPSBcImMveC9yXCJcblx0XHRcdFx0Y29uc3QgYWZ0ZXJUYWcgPSBcImMveC9wXCJcblx0XHRcdFx0bmF2aWdhdG9yLmNsaXBib2FyZC53cml0ZVRleHQodGhyZWFkU2VnbWVudClcblx0XHRcdFx0LnRoZW4oZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdHJldHVybiByZW5hbWVUYWcodmlldy5maWxlLCBiZWZvcmVUYWcsIGFmdGVyVGFnKVxuXHRcdFx0XHR9LCBmdW5jdGlvbiAoZXJyb3IpIHtcblx0XHRcdFx0XHRuZXcgTm90aWNlKGBlcnJvciB3aGVuIGNvcHkgdG8gY2xpcGJvYXJkIWApO1xuXHRcdFx0XHR9KVxuXHRcdFx0XHQudGhlbihmb3VuZFRhZyA9PiB7XG5cdFx0XHRcdFx0aWYgKGZvdW5kVGFnKSB7XG5cdFx0XHRcdFx0XHRuZXcgTm90aWNlKGBVcGRhdGUgbm90ZXMgdHlwZSBmcm9tIHRhZz1cIiR7YmVmb3JlVGFnfVwiIHRvIHRhZz1cIiR7YWZ0ZXJUYWd9IVxcbkNvcGllZFxcblxcYFxcYFxcYFxcbiR7dGhyZWFkU2VnbWVudH1cXGBcXGBcXGBcXG50byBjbGlwYm9hcmQhYCk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdG5ldyBOb3RpY2UoYFRhZyBcIiR7YmVmb3JlVGFnfVwiIG5vdCBmb3VuZFxcbkNvcGllZFxcblxcYFxcYFxcYFxcbiR7dGhyZWFkU2VnbWVudH1cXGBcXGBcXGBcXG50byBjbGlwYm9hcmQhYCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdH0sXG5cdFx0fSk7XG5cblx0XHR0aGlzLmFkZE9ic2lkaWFuSWNvbignc2VnbWVudC10by1jbGlwYm9hcmQnLCAnU0MnKTtcblx0XHR0aGlzLmFkZENvbW1hbmQoe1xuXHRcdFx0aWQ6IFwic2VnbWVudC10by1jbGlwYm9hcmRcIixcblx0XHRcdG5hbWU6IFwiU0MgU2VnbWVudCB0byBjbGlwYm9hcmRcIixcblx0XHRcdGljb246IGBzZWdtZW50LXRvLWNsaXBib2FyZGAsXG5cdFx0XHRlZGl0b3JDYWxsYmFjazogKGVkaXRvcjogRWRpdG9yLCB2aWV3OiBNYXJrZG93blZpZXcpID0+IHtcblx0XHRcdFx0Y29uc3QgdGhyZWFkU2VnbWVudCA9IHRoaXMuZ2V0U2VnbWVudChlZGl0b3IpXG5cdFx0XHRcdHRoaXMuYWRkVG9DbGlwYm9hcmRIaXN0b3J5KHRocmVhZFNlZ21lbnQpXG5cdFx0XHRcdG5hdmlnYXRvci5jbGlwYm9hcmQud3JpdGVUZXh0KHRocmVhZFNlZ21lbnQpXG5cdFx0XHRcdC50aGVuKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRuZXcgTm90aWNlKGBDb3BpZWRcXG5cXGBcXGBcXGBcXG4ke3RocmVhZFNlZ21lbnR9XFxgXFxgXFxgXFxudG8gY2xpcGJvYXJkIWApO1xuXHRcdFx0XHR9LCBmdW5jdGlvbiAoZXJyb3IpIHtcblx0XHRcdFx0XHRuZXcgTm90aWNlKGBlcnJvciB3aGVuIGNvcHkgdG8gY2xpcGJvYXJkIWApO1xuXHRcdFx0XHR9KVxuXHRcdFx0fSxcblx0XHR9KTtcblxuXHRcdHRoaXMuYWRkQ29tbWFuZCh7XG5cdFx0XHRpZDogXCJ0b2dnbGUtYnVsbGV0LW51bWJlci1saXN0XCIsXG5cdFx0XHRuYW1lOiBcIlRvZ2dsZSBCdWxsZXQgTnVtYmVyIExpc3RcIixcblx0XHRcdGljb246IGBidWxsZXQtbGlzdGAsXG5cdFx0XHRlZGl0b3JDYWxsYmFjazogKGVkaXRvcjogRWRpdG9yLCB2aWV3OiBNYXJrZG93blZpZXcpID0+IHtcblx0XHRcdFx0Y29uc3QgY3Vyc29yID0gZWRpdG9yLmdldEN1cnNvcigpXG5cdFx0XHRcdGNvbnN0IGNoID0gY3Vyc29yLmNoXG5cdFx0XHRcdGNvbnN0IGxpbmUgPSBjdXJzb3IubGluZVxuXHRcdFx0XHRjb25zdCBsaW5lQ29udGVudCA9IGVkaXRvci5nZXRMaW5lKGxpbmUpXG5cblx0XHRcdFx0aWYgKC9eKD4gKSpcXHMqLSAvLnRlc3QobGluZUNvbnRlbnQpKSB7IC8vIGJ1bGxldCBsaXN0IGNhc2Vcblx0XHRcdFx0XHQvLyB0b2dnbGUgdG8gbnVtYmVyIGxpc3Rcblx0XHRcdFx0XHRjb25zdCByZXBsYWNlZExpbmVDb250ZW50ID0gbGluZUNvbnRlbnQucmVwbGFjZSgvXigoPiApKikoXFxzKiktIC8sIFwiJDEkMzEuIFwiKVxuXHRcdFx0XHRcdGVkaXRvci5zZXRMaW5lKGxpbmUsIHJlcGxhY2VkTGluZUNvbnRlbnQpXG5cdFx0XHRcdFx0Y3Vyc29yLmNoID0gY3Vyc29yLmNoICsgMVxuXHRcdFx0XHRcdGVkaXRvci5zZXRDdXJzb3IoY3Vyc29yKVxuXHRcdFx0XHR9IGVsc2UgaWYgKC9eKD4gKSpcXHMqW1xcZF0rXFwuIC8udGVzdChsaW5lQ29udGVudCkpIHsgLy8gbnVtYmVyIGxpc3QgY2FzZVxuXHRcdFx0XHRcdC8vIHRvZ2dsZSB0byBub24gbGlzdFxuXHRcdFx0XHRcdGNvbnN0IHJlcGxhY2VkTGluZUNvbnRlbnQgPSBsaW5lQ29udGVudC5yZXBsYWNlKC9eKCg+ICkqKShcXHMqKVtcXGRdK1xcLiAvLCBcIiQxJDNcIilcblx0XHRcdFx0XHRlZGl0b3Iuc2V0TGluZShsaW5lLCByZXBsYWNlZExpbmVDb250ZW50KVxuXHRcdFx0XHRcdGN1cnNvci5jaCA9IGN1cnNvci5jaCAtIDNcblx0XHRcdFx0XHRlZGl0b3Iuc2V0Q3Vyc29yKGN1cnNvcilcblx0XHRcdFx0fSBlbHNlIHsgLy8gbm8gbGlzdFxuXHRcdFx0XHRcdC8vIHRvZ2dsZSB0byBidWxsZXQgbGlzdFxuXHRcdFx0XHRcdGNvbnN0IHJlcGxhY2VkTGluZUNvbnRlbnQgPSBsaW5lQ29udGVudC5yZXBsYWNlKC9eKCg+ICkqKShcXHMqKS8sIFwiJDEkMy0gXCIpXG5cdFx0XHRcdFx0ZWRpdG9yLnNldExpbmUobGluZSwgcmVwbGFjZWRMaW5lQ29udGVudClcblx0XHRcdFx0XHRjdXJzb3IuY2ggPSBjdXJzb3IuY2ggKyAyXG5cdFx0XHRcdFx0ZWRpdG9yLnNldEN1cnNvcihjdXJzb3IpXG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRob3RrZXlzOiBbXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRtb2RpZmllcnM6IFtgQ3RybGAsIGBNZXRhYCwgYFNoaWZ0YF0sXG5cdFx0XHRcdFx0a2V5OiBgLWAsXG5cdFx0XHRcdH0sXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRtb2RpZmllcnM6IFtgQ3RybGAsIGBBbHRgLCBgU2hpZnRgXSxcblx0XHRcdFx0XHRrZXk6IGAtYCxcblx0XHRcdFx0fSxcblx0XHRcdF1cblx0XHR9KTtcblxuXHRcdHRoaXMuYWRkQ29tbWFuZCh7XG5cdFx0XHRpZDogJ2NvcHktb3ItbW92ZS10by1uZXctbm90ZScsXG5cdFx0XHRuYW1lOiAnQ29weSBvciBNb3ZlIHRvIG5ldyBub3RlIENNTicsXG5cdFx0XHRpY29uOiBgYWlycGxheWAsXG5cdFx0XHRlZGl0b3JDYWxsYmFjazogYXN5bmMgKGVkaXRvcjogRWRpdG9yLCB2aWV3OiBNYXJrZG93blZpZXcpID0+IHtcblx0XHRcdFx0bmV3IENvcHlPck1vdmVUb05ld05vdGVNb2RhbCh0aGlzLmFwcCwgZWRpdG9yKS5vcGVuKCk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHR0aGlzLmFkZENvbW1hbmQoe1xuXHRcdFx0aWQ6IFwiZWRpdG9yLWNvcHktbGluZS10by1jbGlwYm9hcmRcIixcblx0XHRcdG5hbWU6IFwiRWRpdG9yIENvcHkgTGluZSB0byBDbGlwYm9hcmRcIixcblx0XHRcdGljb246IGBhbGlnbi12ZXJ0aWNhbC1zcGFjZS1hcm91bmRgLFxuXHRcdFx0ZWRpdG9yQ2FsbGJhY2s6IChlZGl0b3I6IEVkaXRvciwgdmlldzogTWFya2Rvd25WaWV3KSA9PiB7XG5cdFx0XHRcdGNvbnN0IHNlbGVjdGlvbiA9IGV4cG9ydEN1cnJlbnRTZWxlY3Rpb24oZWRpdG9yKTtcblx0XHRcdFx0Y29uc3QgY29weUNvbnRlbnQgPSBzZWxlY3Rpb24uY29udGFpbnMoXCJcXG5cIilcblx0XHRcdFx0XHRcdFx0XHRcdD8gc2VsZWN0aW9uXG5cdFx0XHRcdFx0XHRcdFx0XHQ6IHNlbGVjdGlvbi5yZXBsYWNlKC9eXFx0Ki0gLywgJycpLnJlcGxhY2UoL15cXHQqXFxkK1xcLiAvLCAnJylcblx0XHRcdFx0dGhpcy5hZGRUb0NsaXBib2FyZEhpc3RvcnkoY29weUNvbnRlbnQpO1xuXHRcdFx0XHRuYXZpZ2F0b3IuY2xpcGJvYXJkLndyaXRlVGV4dChjb3B5Q29udGVudCkudGhlbihmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0bmV3IE5vdGljZShgQ29waWVkIGNvbnRlbnRcXG5cXGBcXGBcXGBcXG4ke2NvcHlDb250ZW50fVxcblxcYFxcYFxcYFxcbnRvIGNsaXBib2FyZCFgKTtcblx0XHRcdFx0fSwgZnVuY3Rpb24gKGVycm9yKSB7XG5cdFx0XHRcdFx0bmV3IE5vdGljZShgZXJyb3Igd2hlbiBjb3B5IHRvIGNsaXBib2FyZCFgKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9LFxuXHRcdFx0aG90a2V5czogW1xuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bW9kaWZpZXJzOiBbYEN0cmxgLCBgTWV0YWAsIGBTaGlmdGBdLFxuXHRcdFx0XHRcdGtleTogXCIvXCIsXG5cdFx0XHRcdH0sXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRtb2RpZmllcnM6IFtgQ3RybGAsIGBBbHRgLCBgU2hpZnRgXSxcblx0XHRcdFx0XHRrZXk6IFwiL1wiLFxuXHRcdFx0XHR9LFxuXHRcdFx0XVxuXHRcdH0pXG5cblx0XHR0aGlzLmFkZENvbW1hbmQoe1xuXHRcdFx0aWQ6IFwiZWRpdG9yLWN1dC1saW5lLXRvLWNsaXBib2FyZFwiLFxuXHRcdFx0bmFtZTogXCJFZGl0b3IgQ3V0IExpbmUgdG8gQ2xpcGJvYXJkXCIsXG5cdFx0XHRpY29uOiBgYWxpZ24tdmVydGljYWwtanVzdGlmeS1jZW50ZXJgLFxuXHRcdFx0ZWRpdG9yQ2FsbGJhY2s6IChlZGl0b3I6IEVkaXRvciwgdmlldzogTWFya2Rvd25WaWV3KSA9PiB7XG5cdFx0XHRcdGNvbnN0IHNlbGVjdGlvbiA9IGV4cG9ydEN1cnJlbnRTZWxlY3Rpb24oZWRpdG9yKTtcblx0XHRcdFx0Y29uc3QgY3Vyc29yID0gZWRpdG9yLmdldEN1cnNvcigpXG5cdFx0XHRcdGNvbnN0IGNvcHlDb250ZW50ID0gc2VsZWN0aW9uLmNvbnRhaW5zKFwiXFxuXCIpXG5cdFx0XHRcdFx0XHRcdFx0XHQ/IHNlbGVjdGlvblxuXHRcdFx0XHRcdFx0XHRcdFx0OiBzZWxlY3Rpb24ucmVwbGFjZSgvXlxcdCotIC8sICcnKS5yZXBsYWNlKC9eXFx0KlxcZCtcXC4gLywgJycpXG5cdFx0XHRcdGxldCBuZXdDb250ZW50ID0gJydcblx0XHRcdFx0Y29uc3Qgc2VsZWN0aW9uUmFuZ2U6IFNlbGVjdGlvblJhbmdlID0gZ2V0Q3VycmVudFNlbGVjdGlvbkxpbmVOdW1iZXIoZWRpdG9yKVxuXHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGVkaXRvci5saW5lQ291bnQoKTsgaSsrKSB7XG5cdFx0XHRcdFx0aWYgKGkgPCBzZWxlY3Rpb25SYW5nZS5mcm9tTGluZU51bSB8fCBpID4gc2VsZWN0aW9uUmFuZ2UudG9MaW5lTnVtKSB7XG5cdFx0XHRcdFx0XHRuZXdDb250ZW50ID0gbmV3Q29udGVudCArIGVkaXRvci5nZXRMaW5lKGkpICsgXCJcXG5cIlxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLmFkZFRvQ2xpcGJvYXJkSGlzdG9yeShjb3B5Q29udGVudCk7XG5cdFx0XHRcdG5hdmlnYXRvci5jbGlwYm9hcmQud3JpdGVUZXh0KGNvcHlDb250ZW50KS50aGVuKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRuZXcgTm90aWNlKGBDb3BpZWQgY29udGVudFxcblxcYFxcYFxcYFxcbiR7Y29weUNvbnRlbnR9XFxuXFxgXFxgXFxgXFxudG8gY2xpcGJvYXJkIWApO1xuXHRcdFx0XHR9LCBmdW5jdGlvbiAoZXJyb3IpIHtcblx0XHRcdFx0XHRuZXcgTm90aWNlKGBlcnJvciB3aGVuIGNvcHkgdG8gY2xpcGJvYXJkIWApO1xuXHRcdFx0XHR9KTtcblx0XHRcdFx0ZWRpdG9yLnNldFZhbHVlKG5ld0NvbnRlbnQpXG5cdFx0XHRcdGN1cnNvci5saW5lID0gc2VsZWN0aW9uUmFuZ2UuZnJvbUxpbmVOdW1cblx0XHRcdFx0aWYgKGVkaXRvci5nZXRMaW5lKHNlbGVjdGlvblJhbmdlLmZyb21MaW5lTnVtKS5sZW5ndGggPCBzZWxlY3Rpb25SYW5nZS5mcm9tQ2gpIHtcblx0XHRcdFx0XHRjdXJzb3IuY2ggPSBlZGl0b3IuZ2V0TGluZShzZWxlY3Rpb25SYW5nZS5mcm9tTGluZU51bSkubGVuZ3RoXG5cdFx0XHRcdH1cblx0XHRcdFx0ZWRpdG9yLnNldEN1cnNvcihjdXJzb3IpXG5cdFx0XHR9LFxuXHRcdFx0aG90a2V5czogW1xuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bW9kaWZpZXJzOiBbYEN0cmxgLCBgTWV0YWAsIGBTaGlmdGBdLFxuXHRcdFx0XHRcdGtleTogXCJcXFxcXCIsXG5cdFx0XHRcdH0sXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRtb2RpZmllcnM6IFtgQ3RybGAsIGBBbHRgLCBgU2hpZnRgXSxcblx0XHRcdFx0XHRrZXk6IFwiXFxcXFwiLFxuXHRcdFx0XHR9LFxuXHRcdFx0XVxuXHRcdH0pXG5cblx0XHR0aGlzLmFkZENvbW1hbmQoe1xuXHRcdFx0aWQ6IFwiZWRpdG9yLWluZGVudC1saW5lXCIsXG5cdFx0XHRuYW1lOiBcIkVkaXRvciBJbmRlbnQgU2VsZWN0aW9uXCIsXG5cdFx0XHRpY29uOiBgcmlnaHQtYXJyb3ctd2l0aC10YWlsYCxcblx0XHRcdGVkaXRvckNhbGxiYWNrOiAoZWRpdG9yOiBFZGl0b3IsIHZpZXc6IE1hcmtkb3duVmlldykgPT4ge1xuXHRcdFx0XHRjb25zdCBsaXN0U2VsZWN0aW9ucyA6IEVkaXRvclNlbGVjdGlvbltdID0gZWRpdG9yLmxpc3RTZWxlY3Rpb25zKClcblx0XHRcdFx0bGlzdFNlbGVjdGlvbnMuZm9yRWFjaChsaXN0U2VsZWN0aW9uID0+IHtcblx0XHRcdFx0XHRjb25zdCBhID0gbGlzdFNlbGVjdGlvbi5oZWFkLmxpbmVcblx0XHRcdFx0XHRjb25zdCBiID0gbGlzdFNlbGVjdGlvbi5hbmNob3IubGluZVxuXHRcdFx0XHRcdGNvbnN0IGZyb21MaW5lTnVtID0gYiA+IGEgPyBhIDogYlxuXHRcdFx0XHRcdGNvbnN0IHRvTGluZU51bSA9IGIgPiBhID8gYiA6IGFcblx0XHRcdFx0XHRmb3IgKGxldCBpID0gZnJvbUxpbmVOdW07IGkgPD0gdG9MaW5lTnVtOyBpKyspIHtcblx0XHRcdFx0XHRcdGNvbnN0IGxpbmUgPSBlZGl0b3IuZ2V0TGluZShpKVxuXHRcdFx0XHRcdFx0ZWRpdG9yLnNldExpbmUoaSwgbGluZS5yZXBsYWNlKC9eLywgXCJcXHRcIikpXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KVxuXHRcdFx0XHRsZXQgbHNzIDogRWRpdG9yU2VsZWN0aW9uW10gPSBbXVxuXHRcdFx0XHRsaXN0U2VsZWN0aW9ucy5mb3JFYWNoKGxzID0+IHtcblx0XHRcdFx0XHRjb25zdCBoZWFkID0gbHMuaGVhZFxuXHRcdFx0XHRcdGhlYWQuY2ggPSBoZWFkLmNoICsgMVxuXHRcdFx0XHRcdGNvbnN0IGFuY2hvciA9IGxzLmFuY2hvclxuXHRcdFx0XHRcdGFuY2hvci5jaCA9IGFuY2hvci5jaCArIDFcblx0XHRcdFx0XHRjb25zdCBuZXdMczogRWRpdG9yU2VsZWN0aW9uID0ge2FuY2hvciwgaGVhZH1cblx0XHRcdFx0XHRsc3MucHVzaChuZXdMcylcblx0XHRcdFx0fSlcblx0XHRcdFx0ZWRpdG9yLnNldFNlbGVjdGlvbnMobHNzKVxuXHRcdFx0fVxuXHRcdH0pXG5cblx0XHR0aGlzLmFkZENvbW1hbmQoe1xuXHRcdFx0aWQ6IFwiZWRpdG9yLW91dGRlbnQtbGluZVwiLFxuXHRcdFx0bmFtZTogXCJFZGl0b3IgT3V0ZGVudCBTZWxlY3Rpb25cIixcblx0XHRcdGljb246IGBsZWZ0LWFycm93LXdpdGgtdGFpbGAsXG5cdFx0XHRlZGl0b3JDYWxsYmFjazogKGVkaXRvcjogRWRpdG9yLCB2aWV3OiBNYXJrZG93blZpZXcpID0+IHtcblx0XHRcdFx0Y29uc3QgbGlzdFNlbGVjdGlvbnMgOiBFZGl0b3JTZWxlY3Rpb25bXSA9IGVkaXRvci5saXN0U2VsZWN0aW9ucygpXG5cdFx0XHRcdGxpc3RTZWxlY3Rpb25zLmZvckVhY2gobGlzdFNlbGVjdGlvbiA9PiB7XG5cdFx0XHRcdFx0Y29uc3QgYSA9IGxpc3RTZWxlY3Rpb24uaGVhZC5saW5lXG5cdFx0XHRcdFx0Y29uc3QgYiA9IGxpc3RTZWxlY3Rpb24uYW5jaG9yLmxpbmVcblx0XHRcdFx0XHRjb25zdCBmcm9tTGluZU51bSA9IGIgPiBhID8gYSA6IGJcblx0XHRcdFx0XHRjb25zdCB0b0xpbmVOdW0gPSBiID4gYSA/IGIgOiBhXG5cdFx0XHRcdFx0Zm9yIChsZXQgaSA9IGZyb21MaW5lTnVtOyBpIDw9IHRvTGluZU51bTsgaSsrKSB7XG5cdFx0XHRcdFx0XHRjb25zdCBsaW5lID0gZWRpdG9yLmdldExpbmUoaSlcblx0XHRcdFx0XHRcdGVkaXRvci5zZXRMaW5lKGksIGxpbmUucmVwbGFjZSgvXlxcdC8sIFwiXCIpKVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSlcblx0XHRcdFx0bGV0IGxzcyA6IEVkaXRvclNlbGVjdGlvbltdID0gW11cblx0XHRcdFx0bGlzdFNlbGVjdGlvbnMuZm9yRWFjaChscyA9PiB7XG5cdFx0XHRcdFx0Y29uc3QgaGVhZCA9IGxzLmhlYWRcblx0XHRcdFx0XHRoZWFkLmNoID0gaGVhZC5jaCArIDFcblx0XHRcdFx0XHRjb25zdCBhbmNob3IgPSBscy5hbmNob3Jcblx0XHRcdFx0XHRhbmNob3IuY2ggPSBhbmNob3IuY2ggKyAxXG5cdFx0XHRcdFx0Y29uc3QgbmV3THM6IEVkaXRvclNlbGVjdGlvbiA9IHthbmNob3IsIGhlYWR9XG5cdFx0XHRcdFx0bHNzLnB1c2gobmV3THMpXG5cdFx0XHRcdH0pXG5cdFx0XHRcdGVkaXRvci5zZXRTZWxlY3Rpb25zKGxzcylcblx0XHRcdH1cblx0XHR9KVxuXG5cblx0XHQvLyBUaGlzIGFkZHMgYSBzZXR0aW5ncyB0YWIgc28gdGhlIHVzZXIgY2FuIGNvbmZpZ3VyZSB2YXJpb3VzIGFzcGVjdHMgb2YgdGhlIHBsdWdpblxuXHRcdHRoaXMuYWRkU2V0dGluZ1RhYihuZXcgU2FtcGxlU2V0dGluZ1RhYih0aGlzLmFwcCwgdGhpcykpO1xuXHR9XG5cblx0Y29udmVydENoYXRHUFRUb1R3aXR0ZXJGb3JtYXQoZWRpdG9yOiBFZGl0b3IpIDogYm9vbGVhbiB7IC8vIHRydWUgbWVhbnMgc3VjY2Vzc1xuXHRcdGxldCBsaW5lID0gZWRpdG9yLmxpbmVDb3VudCgpO1xuXG5cdFx0bGV0IG51bUxpbmVGaXJzdENvbnRlbnQgPSAwXG5cdFx0bGV0IGZyb250TWF0dGVyTGluZUNvdW50ID0gMFxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbGluZTsgaSsrKSB7XG5cdFx0XHRpZiAoZnJvbnRNYXR0ZXJMaW5lQ291bnQgPT0gMikge1xuXHRcdFx0XHRudW1MaW5lRmlyc3RDb250ZW50ID0gaTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRpZiAoZWRpdG9yLmdldExpbmUoaSkgPT0gXCItLS1cIikge1xuXHRcdFx0XHRmcm9udE1hdHRlckxpbmVDb3VudCsrXG5cdFx0XHR9XG5cdFx0fVxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbGluZTsgaSsrKSB7XG5cdFx0XHRpZiAoZWRpdG9yLmdldExpbmUobnVtTGluZUZpcnN0Q29udGVudCkudHJpbSgpID09IFwiXCIpIHtcblx0XHRcdFx0bnVtTGluZUZpcnN0Q29udGVudCsrO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0bGV0IHRvdGFsVHdlZXRDb3VudCA9IDFcblxuXHRcdEFycmF5LmZyb20oQXJyYXkobGluZSAtIG51bUxpbmVGaXJzdENvbnRlbnQpLmtleXMoKSkuZm9yRWFjaChpID0+IHtcblx0XHRcdGNvbnN0IGxpbmUgPSBlZGl0b3IuZ2V0TGluZShpICsgbnVtTGluZUZpcnN0Q29udGVudCk7XG5cdFx0XHRsZXQgbW9kaWZpZWRMaW5lID0gbGluZS5yZXBsYWNlKC9eX19fXysvLCBcIi0tLVwiKS5yZXBsYWNlKC9eLS0tLSsvLCBcIi0tLVwiKVxuXHRcdFx0ZWRpdG9yLnNldExpbmUoaSArIG51bUxpbmVGaXJzdENvbnRlbnQsIG1vZGlmaWVkTGluZSlcblx0XHRcdGlmIChtb2RpZmllZExpbmUgPT0gXCItLS1cIikge1xuXHRcdFx0XHR0b3RhbFR3ZWV0Q291bnQgPSB0b3RhbFR3ZWV0Q291bnQgKyAxXG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRsZXQgbnVtVHdlZXQgPSAxXG5cdFx0bGV0IHJlYWR5VG9BZGRUd2VldENvdW50ID0gdHJ1ZVxuXG5cdFx0bGV0IHRleHQgPSBcIlwiO1xuXHRcdEFycmF5LmZyb20oQXJyYXkobnVtTGluZUZpcnN0Q29udGVudCkua2V5cygpKS5mb3JFYWNoKGkgPT4ge1xuXHRcdFx0Y29uc3QgbGluZSA9IGVkaXRvci5nZXRMaW5lKGkpO1xuXHRcdFx0dGV4dCA9IHRleHQgKyBsaW5lICsgXCJcXG5cIlxuXHRcdH0pXG5cblx0XHRBcnJheS5mcm9tKEFycmF5KGxpbmUgLSBudW1MaW5lRmlyc3RDb250ZW50KS5rZXlzKCkpLmZvckVhY2goaSA9PiB7XG5cdFx0XHRjb25zdCBsaW5lID0gZWRpdG9yLmdldExpbmUoaSArIG51bUxpbmVGaXJzdENvbnRlbnQpO1xuXHRcdFx0bGV0IG1vZGlmaWVkTGluZSA9IGxpbmU7XG5cdFx0XHRpZiAobGluZSA9PSBcIi0tLVwiKSB7XG5cdFx0XHRcdHJlYWR5VG9BZGRUd2VldENvdW50ID0gdHJ1ZVxuXHRcdFx0XHRudW1Ud2VldCA9IG51bVR3ZWV0ICsgMVxuXHRcdFx0fSBlbHNlIGlmIChsaW5lICE9IFwiXCIgJiYgcmVhZHlUb0FkZFR3ZWV0Q291bnQpIHtcblx0XHRcdFx0aWYgKCEvXlxcZCtcXC9cXGQrLiovLnRlc3QobGluZSkpIHtcblx0XHRcdFx0XHRtb2RpZmllZExpbmUgPSBgJHtudW1Ud2VldH0vJHt0b3RhbFR3ZWV0Q291bnR9ICR7bGluZX1gXG5cdFx0XHRcdH1cblx0XHRcdFx0cmVhZHlUb0FkZFR3ZWV0Q291bnQgPSBmYWxzZVxuXHRcdFx0fVxuXHRcdFx0dGV4dCA9IHRleHQgKyBtb2RpZmllZExpbmUgKyBcIlxcblwiXG5cdFx0fSk7XG5cblx0XHR0ZXh0ID0gdGV4dC5yZXBsYWNlKFwiXHUyNThEXCIsIFwiXCIpXG5cblx0XHQvLyBzaG91bGQgSSBhZGQgY2hlY2sgc2VnbWVudD9cblx0XHRjb25zdCB0d2VldHMgPSB0ZXh0LnNwbGl0KFwiLS0tXCIpXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCB0d2VldHMubGVuZ3RoOyBpKyspXG5cdFx0e1xuXHRcdFx0Y29uc3QgdHdlZXQgPSB0d2VldHNbaV0ucmVwbGFjZSgvKGh0dHBzOnxodHRwOnx3d3dcXC4pXFxTKi9nbSwgXCJcIikucmVwbGFjZSgvXlxcbisvbSwgXCJcIikucmVwbGFjZSgvXFxuKyQvbSwgXCJcIilcblx0XHRcdGlmICh0d2VldC5sZW5ndGggPiAxNDApXG5cdFx0XHR7XG5cdFx0XHRcdG5ldyBOb3RpY2UoXCJgYGBcXG5cIiArIHR3ZWV0ICsgXCJcXG5gYGBcXG5cXG5leGNlZWQgMTQwIGNoYXJhY3RlcnMuIFByb2JhYmx5IGNhbm5vdCBwb3N0IGluIHR3aXR0ZXIuIFBsZWFzZSByZWZpbmUgdGhlIHR3ZWV0LiBBYm9ydGluZ1wiKVxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZWRpdG9yLnNldFZhbHVlKHRleHQpXG5cdFx0Y29uc3QgY3Vyc29yID0gZWRpdG9yLmdldEN1cnNvcigpXG5cdFx0Y3Vyc29yLmxpbmUgPSBlZGl0b3IubGluZUNvdW50KCkgLSAxXG5cdFx0ZWRpdG9yLnNldEN1cnNvcihjdXJzb3IpXG5cdFx0cmV0dXJuIHRydWVcblx0fVxuXG5cdHJldmVyc2VUd2l0dGVyTnVtYmVyaW5nKGVkaXRvcjogRWRpdG9yKSB7XG5cdFx0bGV0IGxpbmUgPSBlZGl0b3IubGluZUNvdW50KCk7XG5cblx0XHRsZXQgbnVtTGluZUZpcnN0Q29udGVudCA9IDBcblx0XHRsZXQgZnJvbnRNYXR0ZXJMaW5lQ291bnQgPSAwXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lOyBpKyspIHtcblx0XHRcdGlmIChmcm9udE1hdHRlckxpbmVDb3VudCA9PSAyKSB7XG5cdFx0XHRcdG51bUxpbmVGaXJzdENvbnRlbnQgPSBpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdGlmIChlZGl0b3IuZ2V0TGluZShpKSA9PSBcIi0tLVwiKSB7XG5cdFx0XHRcdGZyb250TWF0dGVyTGluZUNvdW50Kytcblx0XHRcdH1cblx0XHR9XG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lOyBpKyspIHtcblx0XHRcdGlmIChlZGl0b3IuZ2V0TGluZShudW1MaW5lRmlyc3RDb250ZW50KS50cmltKCkgPT0gXCJcIikge1xuXHRcdFx0XHRudW1MaW5lRmlyc3RDb250ZW50Kys7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cblx0XHRsZXQgdGV4dCA9IFwiXCI7XG5cdFx0QXJyYXkuZnJvbShBcnJheShudW1MaW5lRmlyc3RDb250ZW50KS5rZXlzKCkpLmZvckVhY2goaSA9PiB7XG5cdFx0XHRjb25zdCBsaW5lID0gZWRpdG9yLmdldExpbmUoaSk7XG5cdFx0XHR0ZXh0ID0gdGV4dCArIGxpbmUgKyBcIlxcblwiXG5cdFx0fSlcblxuXHRcdEFycmF5LmZyb20oQXJyYXkobGluZSAtIG51bUxpbmVGaXJzdENvbnRlbnQpLmtleXMoKSkuZm9yRWFjaChpID0+IHtcblx0XHRcdGNvbnN0IGxpbmUgPSBlZGl0b3IuZ2V0TGluZShpICsgbnVtTGluZUZpcnN0Q29udGVudCk7XG5cdFx0XHRjb25zdCBtb2RpZmllZExpbmUgPSBsaW5lLnJlcGxhY2UoL15cXGQrXFwvXFxkKyAvLCBcIlwiKVxuXHRcdFx0dGV4dCA9IHRleHQgKyBtb2RpZmllZExpbmUgKyBcIlxcblwiXG5cdFx0fSk7XG5cblx0XHRlZGl0b3Iuc2V0VmFsdWUodGV4dClcblx0XHRjb25zdCBjdXJzb3IgPSBlZGl0b3IuZ2V0Q3Vyc29yKClcblx0XHRjdXJzb3IubGluZSA9IGVkaXRvci5saW5lQ291bnQoKSAtIDFcblx0XHRlZGl0b3Iuc2V0Q3Vyc29yKGN1cnNvcilcblx0fVxuXG5cblx0Y29udmVydFRocmVhZHNDb250ZW50VG9Gb3JtYXRGb3JUaHJlYWRzQXBwKGVkaXRvcjogRWRpdG9yKSA6IHN0cmluZyB7XG5cdFx0cmV0dXJuIHRoaXMuY29udmVydFRocmVhZHNDb250ZW50VG9MaWdodFBvc3RGb3JtYXQoZWRpdG9yLCBcIlx1RDgzRVx1RERGNVwiLCBcIlxcblxcblxcblwiKVxuXHR9XG5cblx0Y29udmVydFRocmVhZHNDb250ZW50VG9Gb3JtYXRGb3JGYWNlYm9va0FwcChlZGl0b3I6IEVkaXRvcikgOiBzdHJpbmcge1xuXHRcdHJldHVybiB0aGlzLmNvbnZlcnRUaHJlYWRzQ29udGVudFRvTGlnaHRQb3N0Rm9ybWF0KGVkaXRvciwgXCJcIiwgXCJcXG5cXG5cdTExNzNcdTExNzNcdTExNzNcdTExNzNcdTExNzNcdTExNzNcdTExNzNcdTExNzNcdTExNzNcdTExNzNcdTExNzNcdTExNzNcdTExNzNcdTExNzNcdTExNzNcdTExNzNcdTExNzNcdTExNzNcdTExNzNcdTExNzNcdTExNzNcdTExNzNcXG5cXG5cIiwgKGEpID0+IGEucmVwbGFjZShcIlx1RDgzRFx1REM0N1wiLCBcIlwiKSlcblx0fVxuXG4vKlxuXHRhZGRUYXNrVG9QdXRJbnRvQ2FyZEluVGhyZWFkc0NvbnRlbnQoZWRpdG9yOiBFZGl0b3IpIHtcblx0XHRsZXQgbGluZSA9IGVkaXRvci5saW5lQ291bnQoKTtcblxuXHRcdGxldCBmcm9udE1hdHRlckxpbmVDb3VudCA9IDBcblx0XHRsZXQgdGV4dCA9IFwiXCI7XG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lOyBpKyspIHtcblx0XHRcdGlmIChlZGl0b3IuZ2V0TGluZShpKSA9PSBcIi0tLVwiKSB7XG5cdFx0XHRcdGZyb250TWF0dGVyTGluZUNvdW50Kytcblx0XHRcdH1cblx0XHRcdGNvbnN0IGxpbmUgPSBlZGl0b3IuZ2V0TGluZShpKTtcblx0XHRcdFxuXHRcdFx0Ly9pZiAoZnJvbnRNYXR0ZXJMaW5lQ291bnQgPiAyICYmIGxpbmUgPT0gXCItLS1cIikge1xuXHRcdFx0Ly9cdHRleHQgPSB0ZXh0ICsgXCIlJSAjbm0gdG8gemsgJSVcXG5cXG5cIlxuXHRcdFx0Ly99XG5cdFx0XHR0ZXh0ID0gdGV4dCArIGxpbmUgKyBcIlxcblwiXG5cdFx0fVxuXG5cdFx0ZWRpdG9yLnNldFZhbHVlKHRleHQpO1xuXHR9XG4qL1xuXHR0aWR5VXBGcm9udE1hdHRlcm9uRWRpdG9yKGVkaXRvcjogRWRpdG9yKSB7XG5cdFx0Y29uc3QgdmFsdWUgPSBlZGl0b3IuZ2V0VmFsdWUoKVxuXHRcdGNvbnN0IG1vZGlmaWVkVmFsdWUgPSB0aGlzLnRpZHlVcEZyb250TWF0dGVyT25WYWx1ZSh2YWx1ZSlcblx0XHRlZGl0b3Iuc2V0VmFsdWUobW9kaWZpZWRWYWx1ZSlcblx0fVxuXG5cdHRpZHlVcEZyb250TWF0dGVyT25WYWx1ZSh2YWx1ZTogU3RyaW5nKSB7XG5cdFx0Y29uc3QgdmFsdWVzOiBzdHJpbmdbXSA9IHZhbHVlLnNwbGl0KFwiXFxuXCIpXG5cdFx0Y29uc3QgbGluZUNvdW50ID0gdmFsdWVzLmxlbmd0aFxuXG5cdFx0bGV0IGZtID0gXCJcIlxuXHRcdGxldCBjID0gXCJcIlxuXHRcdGxldCB0ZXh0ID0gXCJcIlxuXHRcdGxldCBoM0NvdW50ID0gMDtcblx0XHRsZXQgY29udGVudCA9IFwiXCJcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGxpbmVDb3VudDsgaSsrKSB7XG5cdFx0XHRjb25zdCBsaW5lID0gdmFsdWVzW2ldXG5cdFx0XHRpZiAoaDNDb3VudCA9PSAwKSB7XG5cdFx0XHRcdGNvbnRlbnQgKz0gKGxpbmUgKyBcIlxcblwiKVxuXHRcdFx0fSBlbHNlIGlmIChoM0NvdW50ID09IDEpIHtcblx0XHRcdFx0aWYgKHRoaXMuc2hvdWxkU2tpcEZyb250TWF0dGVyKGxpbmUpKSB7XG5cdFx0XHRcdFx0Ly8gZG8gbm90aGluZ1xuXHRcdFx0XHR9IGVsc2UgaWYgKGxpbmUuc3RhcnRzV2l0aChcInRpdGxlOiBcIikpIHtcblx0XHRcdFx0XHRjb25zdCBtb2RpZmllZExpbmUgPSBsaW5lLnJlcGxhY2UoLzovZywgXCJfXCIpLnJlcGxhY2UoL150aXRsZV8gLywgXCJ0aXRsZTogXCIpXG5cdFx0XHRcdFx0Zm0gKz0gKG1vZGlmaWVkTGluZSArIFwiXFxuXCIpXG5cdFx0XHRcdH0gZWxzZSBpZiAobGluZSA9PT0gXCJ0YWdzOiBbZXhjYWxpZHJhd11cIil7XG5cdFx0XHRcdFx0Zm0gKz0gKGxpbmUgKyBcIlxcblwiKVxuXHRcdFx0XHR9IGVsc2UgaWYgKGxpbmUuc3RhcnRzV2l0aChcInRhZ3NzczogXCIpIHx8IGxpbmUuc3RhcnRzV2l0aChcInRhZ3M6IFwiKSkge1xuXHRcdFx0XHRcdGNvbnN0IGJyYWNrZXRQYXR0ZXJuID0gL1xcW1xcWy4qP1xcXVxcXS9nO1xuXG5cdFx0XHRcdFx0Ly8gRmluZCBhbGwgYnJhY2tldGVkIGl0ZW1zXG5cdFx0XHRcdFx0Y29uc3QgYnJhY2tldGVkSXRlbXMgPSBsaW5lLm1hdGNoKGJyYWNrZXRQYXR0ZXJuKSB8fCBbXTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHQvLyBSZW1vdmUgYnJhY2tldGVkIGl0ZW1zIGZyb20gdGhlIGlucHV0IHN0cmluZyB0byBkZWFsIHdpdGggdGhlIHJlbWFpbmluZ1xuXHRcdFx0XHRcdGNvbnN0IHJlbWFpbmluZ1N0cmluZyA9IGxpbmUucmVwbGFjZShicmFja2V0UGF0dGVybiwgJycpLnRyaW0oKTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHQvLyBTcGxpdCB0aGUgcmVtYWluaW5nIHN0cmluZyBieSBzcGFjZXMgdG8gZ2V0IHRoZSBpbmRpdmlkdWFsIHdvcmRzXG5cdFx0XHRcdFx0Y29uc3QgcmVtYWluaW5nSXRlbXMgPSByZW1haW5pbmdTdHJpbmcuc3BsaXQoL1xccysvKS5maWx0ZXIoaXRlbSA9PiBpdGVtKTtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHQvLyBDb21iaW5lIHRoZSBicmFja2V0ZWQgaXRlbXMgYW5kIHRoZSBpbmRpdmlkdWFsIHdvcmRzIGludG8gb25lIGFycmF5XG5cdFx0XHRcdFx0Y29uc3QgZm10YWdzc3MgPSBbLi4uYnJhY2tldGVkSXRlbXMsIC4uLnJlbWFpbmluZ0l0ZW1zXTtcblxuXHRcdFx0XHRcdGxldCBwYXJlbnQgOiBzdHJpbmdbXSA9IFtdXG5cdFx0XHRcdFx0bGV0IHRhZ3NzcyA6IHN0cmluZ1tdID0gW11cblx0XHRcdFx0XHRsZXQgc2tpcHMgOiBzdHJpbmdbXT0gW11cblx0XHRcdFx0XHRcblx0XHRcdFx0XHRmbXRhZ3Nzcy5mb3JFYWNoKHRhZyA9PiB7XG5cdFx0XHRcdFx0XHR0YWcgPSB0YWcudHJpbSgpXG5cdFx0XHRcdFx0XHQvLyBbW2V2ZW50IG5dXSAvIFtbZXZlbnQgd11dIC8gcmVnZXggb2YgW1syMDIyMDcxNyBKb3VybmFsIChXZWVrIDI4IFN1bildXTogcHV0IGluIHNraXBzXG5cdFx0XHRcdFx0XHQvLyBbWzIwMjIwNzIxIEpvdXJuYWwgKFdlZWsgMjkgVGh1KV1dXG5cdFx0XHRcdFx0XHRpZiAodGFnID09PSBcIltbLkhlYWRlciBTaG9ydGN1dF1dXCIgfHwgdGFnID09PSBcIltbLkN1cnJlbnQgUHJvamVjdF1dXCIgfHwgdGFnID09PSBcImNvbmNlcHRcIiB8fCB0YWcgPT09IFwic3BhY2VcIiB8fCB0YWcgPT09IFwicHJvYmxlbVwiIHx8IHRhZyA9PT0gXCJ0YWdzc3M6XCIgfHwgdGFnID09PSBcInRhZ3M6XCIgfHwgdGFnID09PSBcIltbZXZlbnQgbl1dXCIgfHwgdGFnID09PSBcIltbZXZlbnQgd11dXCJcblx0XHRcdFx0XHRcdFx0fHwgL1xcW1xcW1xcZHs4fSBKb3VybmFsIFxcKFdlZWsgXFxkKyBbQS1aYS16XXszfVxcKVxcXVxcXS8udGVzdCh0YWcpKSB7XG5cdFx0XHRcdFx0XHRcdHNraXBzLnB1c2godGFnKVxuXHRcdFx0XHRcdFx0fSBlbHNlIGlmICh0YWcgPT09IFwicGVybXRhc2tcIiB8fCBcdHRhZyA9PT0gXCJOXCIgfHwgdGFnID09PSBcIldcIiB8fCB0YWcgPT09IFwibm93XCIgfHwgdGFnID09PSBcImxhdGVyXCIgfHwgdGFnID09PSBcIndhaXRpbmdcIiB8fCB0YWcgPT09IFwiZG9uZVwiIHx8IHRhZyA9PT0gXCJhcmNoaXZlXCIgfHwgdGFnID09PSBcImFjdGlvblwiIHx8IHRhZyA9PT0gXCJ0YXNrXCIpIHtcblx0XHRcdFx0XHRcdFx0dGFnc3NzLnB1c2godGFnLnJlcGxhY2UoXCJbW1wiLCBcIlwiKS5yZXBsYWNlKFwiXV1cIiwgXCJcIikpXG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKHRhZyA9PT0gXCJwcmVibG9nXCIgfHwgdGFnID09PSBcInByZXByZWJsb2dcIikge1xuXHRcdFx0XHRcdFx0XHRwYXJlbnQucHVzaChcIltbQmxvZyBfIFBvc3RdXVwiKVxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0cGFyZW50LnB1c2godGFnKVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0Ly9uZXcgTm90aWNlKHNraXBzLmpvaW4oXCJcXG5cIikpXG5cdFx0XHRcdFx0bGV0IG1vZGlmaWVkTGluZSA9IFwiXCJcblx0XHRcdFx0XHRpZiAodGFnc3NzLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0XHRcdG1vZGlmaWVkTGluZSArPSBcInRhZ3NzczogXCIgKyB0YWdzc3Muam9pbihcIiBcIikgKyBcIlxcblwiXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGxldCBwYXJlbnRDb3VudCA9IDFcblx0XHRcdFx0XHRpZiAocGFyZW50Lmxlbmd0aCA+IDApIHtcblx0XHRcdFx0XHRcdGNvbnN0IHVuaXF1ZVBhcmVudCA9IEFycmF5LmZyb20obmV3IFNldChwYXJlbnQpKTtcblx0XHRcdFx0XHRcdHVuaXF1ZVBhcmVudC5mb3JFYWNoKHAgPT4ge1xuXHRcdFx0XHRcdFx0XHRpZiAocC5zdGFydHNXaXRoKFwiW1tcIikgJiYgcC5lbmRzV2l0aChcIl1dXCIpKSB7XG5cdFx0XHRcdFx0XHRcdFx0bW9kaWZpZWRMaW5lICs9IFwicGFyZW50XCIgKyBwYXJlbnRDb3VudCArIFwiOiBcXFwiXCIgKyBwLnJlcGxhY2UoXCI6XCIsIFwiX1wiKSArIFwiXFxcIlxcblwiXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0bW9kaWZpZWRMaW5lICs9IFwicGFyZW50XCIgKyBwYXJlbnRDb3VudCArIFwiOiBcXFwiW1tcIiArIHAucmVwbGFjZShcIjpcIiwgXCJfXCIpICsgXCJdXVxcXCJcXG5cIlxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHBhcmVudENvdW50Kytcblx0XHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGZtICs9IG1vZGlmaWVkTGluZVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGZtICs9IChsaW5lICsgXCJcXG5cIilcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKGgzQ291bnQgPj0gMikge1xuXHRcdFx0XHRjICs9IChsaW5lICsgXCJcXG5cIilcblx0XHRcdH1cblx0XHRcdGlmIChsaW5lID09PSBcIi0tLVwiKSB7XG5cdFx0XHRcdGgzQ291bnQrKztcblx0XHRcdH1cblx0XHR9IFxuXHRcdHRleHQgKz0gY29udGVudFxuXHRcdGlmIChmbS5sZW5ndGggPiAwKSB7XG5cdFx0XHR0ZXh0ICs9IGZtXG5cdFx0fVxuXHRcdHRleHQgKz0gY1xuXHRcdFxuXHRcdHJldHVybiB0ZXh0LnJlcGxhY2UoL14tLS1cXG4tLS1cXG4vbSwgXCJcIikucmVwbGFjZSgvXFxuJC8sIFwiXCIpXG5cdH1cblxuXHRzaG91bGRTa2lwRnJvbnRNYXR0ZXIobGluZTogc3RyaW5nKSA6IGJvb2xlYW4ge1xuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgc2tpcEZyb250TWF0dGVyRmllbGQubGVuZ3RoOyBpKyspIHtcblx0XHRcdGlmIChsaW5lLnN0YXJ0c1dpdGgoc2tpcEZyb250TWF0dGVyRmllbGRbaV0pKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlXG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZVxuXHR9XG5cblx0Y29udmVydFRocmVhZHNDb250ZW50VG9MaWdodFBvc3RGb3JtYXQoZWRpdG9yOiBFZGl0b3IsIGhlYWRlckljb246IHN0cmluZywgcGFyYWdyYXBoU2VwYXJhdG9yOiBzdHJpbmdcblx0XHQsIGFkZGl0aW9uUmVwbGFjZUZuOiAoYTogc3RyaW5nKSA9PiBzdHJpbmcgPSAoYSkgPT4gYSkgOiBzdHJpbmcge1xuXHRcdGxldCBsaW5lID0gZWRpdG9yLmxpbmVDb3VudCgpO1xuXG5cdFx0bGV0IG51bUxpbmVGaXJzdENvbnRlbnQgPSAwXG5cdFx0bGV0IGZyb250TWF0dGVyTGluZUNvdW50ID0gMFxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbGluZTsgaSsrKSB7XG5cdFx0XHRpZiAoZnJvbnRNYXR0ZXJMaW5lQ291bnQgPT0gMikge1xuXHRcdFx0XHRudW1MaW5lRmlyc3RDb250ZW50ID0gaTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRpZiAoZWRpdG9yLmdldExpbmUoaSkgPT0gXCItLS1cIikge1xuXHRcdFx0XHRmcm9udE1hdHRlckxpbmVDb3VudCsrXG5cdFx0XHR9XG5cdFx0fVxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbGluZTsgaSsrKSB7XG5cdFx0XHRpZiAoZWRpdG9yLmdldExpbmUobnVtTGluZUZpcnN0Q29udGVudCkudHJpbSgpID09IFwiXCIpIHtcblx0XHRcdFx0bnVtTGluZUZpcnN0Q29udGVudCsrO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0bGV0IHRleHQgPSBcIlwiO1xuXHRcdGxldCBuZXdDb25zZWN1dGl2ZUxpbmVDb3VudCA9IDA7XG5cdFx0QXJyYXkuZnJvbShBcnJheShsaW5lIC0gbnVtTGluZUZpcnN0Q29udGVudCkua2V5cygpKS5mb3JFYWNoKGkgPT4ge1xuXHRcdFx0Y29uc3QgbGluZSA9IGVkaXRvci5nZXRMaW5lKGkgKyBudW1MaW5lRmlyc3RDb250ZW50KTtcblx0XHRcdGlmICghbGluZS50cmltKCkuc3RhcnRzV2l0aChcIiUlXCIpIHx8ICFsaW5lLnRyaW0oKS5lbmRzV2l0aChcIiUlXCIpKSB7XG5cdFx0XHRcdGlmIChsaW5lID09IFwiLS0tXCIpIHtcblx0XHRcdFx0XHRuZXdDb25zZWN1dGl2ZUxpbmVDb3VudCA9IDA7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGxpbmUgPT0gXCJcIikge1xuXHRcdFx0XHRcdG5ld0NvbnNlY3V0aXZlTGluZUNvdW50Kys7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0bmV3Q29uc2VjdXRpdmVMaW5lQ291bnQgPSAwO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChsaW5lID09IFwiXCIgJiYgbmV3Q29uc2VjdXRpdmVMaW5lQ291bnQgPiAxKSB7XG5cdFx0XHRcdFx0Ly8gZG8gbm90aGluZ1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGxldCBtb2RpZmllZExpbmUgPSBsaW5lID09IFwiLS0tXCIgPyBcIlwiIDogbGluZVxuXHRcdFx0XHRcdG1vZGlmaWVkTGluZSA9IG1vZGlmaWVkTGluZS5yZXBsYWNlKC9eXHRcdC0gL2csIFwiXHUzMDAwXHUzMDAwXHUzMDAwXHUzMDAwXHUyMDIyIFwiKS5yZXBsYWNlKC9eXHQtIC9nLCBcIlx1MzAwMFx1MzAwMFx1MjAyMiBcIikucmVwbGFjZSgvXi0gLywgXCJcdTIwMjIgXCIpO1xuXHRcdFx0XHRcdG1vZGlmaWVkTGluZSA9IG1vZGlmaWVkTGluZS5yZXBsYWNlKC9eXFxbKFteXFxbXFxdXFwoXFwpXSspXFxdXFwoW15cXFtcXF1cXChcXCldK1xcKS9nLCBcIiQxXCIpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0LnJlcGxhY2UoL1teIV1cXFsoW15cXFtcXF1cXChcXCldKylcXF1cXChbXlxcW1xcXVxcKFxcKV0rXFwpL2csIFwiJDFcIilcblx0XHRcdFx0XHRtb2RpZmllZExpbmUgPSBtb2RpZmllZExpbmUucmVwbGFjZSgvIVxcWyhbXlxcW1xcXVxcKFxcKV0rKVxcXVxcKChbXlxcW1xcXVxcKFxcKV0rKVxcKS9nLCBcIiQyXCIpXG5cdFx0XHRcdFx0bW9kaWZpZWRMaW5lID0gbW9kaWZpZWRMaW5lLnJlcGxhY2UoL1xcKlxcKi9nbSwgXCJcIilcblx0XHRcdFx0XHR0ZXh0ID0gdGV4dCArIG1vZGlmaWVkTGluZSArIFwiXFxuXCJcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdFxuXHRcdHRleHQgPSB0ZXh0LnJlcGxhY2UoL1x1RDgzRVx1RERGNVsgXSsoLiopL2csIGhlYWRlckljb24gKyBcIlx1MzAxMCQxXHUzMDExXCIpXG5cdFx0dGV4dCA9IGFkZGl0aW9uUmVwbGFjZUZuKHRleHQpXG5cdFx0Ly8gdGV4dCA9IHRleHQucmVwbGFjZSgvXlx0XHQtIC9nLCBcIlx1MzAwMFx1MzAwMFx1MjAyMiBcIikucmVwbGFjZSgvXlx0LSAvZywgXCJcdTMwMDBcdTIwMjIgXCIpLnJlcGxhY2UoL14tIC8sIFwiXHUyMDIyIFwiKTtcblx0XHQvL3RleHQgPSB0ZXh0LnJlcGxhY2UoL1tcXG5cXHJdezMsfShbXlxcblxccl0rXHUzMDAyW1xcblxccl0pL2dtLCBgJHtwYXJhZ3JhcGhTZXBhcmF0b3J9JDFgKTtcblx0XHQvL3RleHQgPSB0ZXh0LnJlcGxhY2UoL1tcXG5cXHJdezMsfShbXlxcblxccl0rXHVGRjFBW1xcblxccl0pL2dtLCBgJHtwYXJhZ3JhcGhTZXBhcmF0b3J9JDFgKTtcblx0XHQvL3RleHQgPSB0ZXh0LnJlcGxhY2UoL1tcXG5cXHJdezMsfShodHRwW15cXG5cXHJdK1tcXG5cXHJdKS9nbSwgYCR7cGFyYWdyYXBoU2VwYXJhdG9yfSQxYCk7XG5cdFx0dGV4dCA9IHRleHQucmVwbGFjZSgvW1xcblxccl17Myx9L2dtLCBgJHtwYXJhZ3JhcGhTZXBhcmF0b3J9XHUyNThEYCk7XG5cblx0XHR0ZXh0ID0gdGV4dC5yZXBsYWNlKFwiXFxuXHUxMTczXHUxMTczXHUxMTczXHUxMTczXHUxMTczXHUxMTczXHUxMTczXHUxMTczXHUxMTczXHUxMTczXHUxMTczXHUxMTczXHUxMTczXHUxMTczXHUxMTczXHUxMTczXHUxMTczXHUxMTczXHUxMTczXHUxMTczXHUxMTczXHUxMTczXFxuXFxuXHUyNThEXFxuXCIsIFwiXCIpIC8vIHJlbW92ZSBlbXB0eSBsaW5lXG5cblx0XHRsZXQgdGV4dDIgPSBcIlwiXG5cblx0XHR0ZXh0LnNwbGl0KFwiXFxuXCIpLmZvckVhY2gobGluZSA9PiB7XG5cdFx0XHR2YXIgbCA9IFwiXCJcblxuXHRcdFx0aWYgKGxpbmUuZW5kc1dpdGgoXCJcdTMwMDJcIikgfHwgbGluZS5lbmRzV2l0aChcIlx1RkYxQVwiKSB8fCBsaW5lLmVuZHNXaXRoKFwiXHVGRjVFXCIpIHx8IGxpbmUuZW5kc1dpdGgoXCJcdUZGMDFcIikgfHwgbGluZS5zdGFydHNXaXRoKFwiXHUyNThEaHR0cFwiKSB8fCBsaW5lLnN0YXJ0c1dpdGgoXCJcdTI1OEQjXCIpIHx8IGxpbmUgPT0gXCJcdTI1OERcIikge1xuXHRcdFx0XHRsID0gbGluZS5yZXBsYWNlKC9eXHUyNThEL2dtLCBcIlwiKVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bCA9IGxpbmVcblx0XHRcdH1cblx0XHRcdHRleHQyID0gdGV4dDIgKyBsICsgXCJcXG5cIlxuXHRcdH0pXG5cblx0XHR0ZXh0MiA9IHRleHQyLnJlcGxhY2UoXCJcXG5cXG5cXG5cXG5cIiwgXCJcIikgLy8gcmVtb3ZlIGVtcHR5IGxpbmVcblx0XHR0ZXh0MiA9IHRleHQyLnJlcGxhY2UoXCJcXG5cdTExNzNcdTExNzNcdTExNzNcdTExNzNcdTExNzNcdTExNzNcdTExNzNcdTExNzNcdTExNzNcdTExNzNcdTExNzNcdTExNzNcdTExNzNcdTExNzNcdTExNzNcdTExNzNcdTExNzNcdTExNzNcdTExNzNcdTExNzNcdTExNzNcdTExNzNcXG5cXG5cXG5cIiwgXCJcIikgLy8gcmVtb3ZlIGVtcHR5IGxpbmVcblx0XHR0ZXh0MiA9IHRleHQyLnJlcGxhY2UoL1xcblxcbiMjIE9waW5pb24gZnJvbSBDaGF0R1BUXFw6KFtcXG5dKi4qKSokLywgXCJcIilcblx0XHR0ZXh0MiA9IHRleHQyLnJlcGxhY2UoLyMjIFJlZmVyZW5jZXNcXDooW1xcbl0qLiopKiQvLCBcIlwiKTtcblx0XHR0ZXh0MiA9IHRleHQyLnJlcGxhY2UoL1xcbiskLywgXCJcIilcblxuXHRcdHJldHVybiB0ZXh0MlxuXHR9XG5cblx0Z2V0VGhyZWFkU2VnbWVudChlZGl0b3I6IEVkaXRvcikgOiBzdHJpbmcge1xuXHRcdGxldCBjdXJzb3IgPSBlZGl0b3IuZ2V0Q3Vyc29yKCk7XG5cdFx0bGV0IGxpbmUgPSBjdXJzb3IubGluZTtcblx0XHRsZXQgYWJvdmUgPSBsaW5lO1xuXHRcdGxldCBiZWxvdyA9IGxpbmU7XG5cdFx0Ly8gZmlyc3QgZ2V0IGFib3ZlXG5cdFx0XG5cdFx0d2hpbGUgKGFib3ZlID49IDApIHtcblx0XHRcdGxldCBsID0gZWRpdG9yLmdldExpbmUoYWJvdmUpO1xuXHRcdFx0aWYgKGwgPT0gJy0tLScpIHtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRhYm92ZS0tO1xuXHRcdH1cblx0XHRpZiAoZWRpdG9yLmdldExpbmUoYWJvdmUpID09ICctLS0nKSB7XG5cdFx0XHRhYm92ZSsrO1xuXHRcdH1cblx0XHR3aGlsZSh0cnVlKSB7XG5cdFx0XHRpZiAoZWRpdG9yLmdldExpbmUoYWJvdmUpID09ICcnKSB7XG5cdFx0XHRcdGFib3ZlKys7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyB0aGVuIGdldCBiZWxvd1xuXHRcdHdoaWxlIChiZWxvdyA8IGVkaXRvci5saW5lQ291bnQoKSkge1xuXHRcdFx0bGV0IGwgPSBlZGl0b3IuZ2V0TGluZShiZWxvdyk7XG5cdFx0XHRpZiAobCA9PSAnLS0tJykge1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdGJlbG93Kys7XG5cdFx0fVxuXHRcdGlmIChlZGl0b3IuZ2V0TGluZShiZWxvdykgPT0gJy0tLScpIHtcblx0XHRcdGJlbG93LS07XG5cdFx0fVxuXG5cdFx0d2hpbGUodHJ1ZSkge1xuXHRcdFx0aWYgKGVkaXRvci5nZXRMaW5lKGJlbG93KSA9PSAnJykge1xuXHRcdFx0XHRiZWxvdy0tO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gdGhlbiBwdXQgdGhlbSB0byBsaW5lXG5cblx0XHRsZXQgdGV4dCA9IFwiXCI7XG5cdFx0QXJyYXkuZnJvbShBcnJheShiZWxvdyAtIGFib3ZlICsgMSkua2V5cygpKS5mb3JFYWNoKGkgPT4ge1xuXHRcdFx0Y29uc3QgbGluZSA9IGVkaXRvci5nZXRMaW5lKGkgKyBhYm92ZSlcblx0XHRcdGlmICghbGluZS50cmltKCkuc3RhcnRzV2l0aChcIiUlXCIpIHx8ICFsaW5lLnRyaW0oKS5lbmRzV2l0aChcIiUlXCIpKSB7XG5cdFx0XHRcdGxldCBtb2RpZmllZExpbmUgPSBlZGl0b3IuZ2V0TGluZShpICsgYWJvdmUpXG5cdFx0XHRcdG1vZGlmaWVkTGluZSA9IG1vZGlmaWVkTGluZS5yZXBsYWNlKC9eXFxbKFteXFxbXFxdXFwoXFwpXSspXFxdXFwoW15cXFtcXF1cXChcXCldK1xcKS9nLCBcIiQxXCIpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCAgIC5yZXBsYWNlKC9bXiFdXFxbKFteXFxbXFxdXFwoXFwpXSspXFxdXFwoW15cXFtcXF1cXChcXCldK1xcKS9nLCBcIiQxXCIpXG5cdFx0XHRcdHRleHQgPSB0ZXh0ICsgbW9kaWZpZWRMaW5lICsgXCJcXG5cIlxuXHRcdFx0fVxuXHRcdH0pXG5cdFx0dGV4dCA9IHRleHQucmVwbGFjZSgvXFxuKyQvLCBcIlwiKVxuXHRcdHJldHVybiB0ZXh0XG5cdH1cblxuXHRnZXRTZWdtZW50KGVkaXRvcjogRWRpdG9yKSA6IHN0cmluZyB7XG5cdFx0bGV0IGN1cnNvciA9IGVkaXRvci5nZXRDdXJzb3IoKTtcblx0XHRsZXQgbGluZSA9IGN1cnNvci5saW5lO1xuXHRcdGxldCBhYm92ZSA9IGxpbmU7XG5cdFx0bGV0IGJlbG93ID0gbGluZTtcblx0XHQvLyBmaXJzdCBnZXQgYWJvdmVcblx0XHRcblx0XHR3aGlsZSAoYWJvdmUgPj0gMCkge1xuXHRcdFx0bGV0IGwgPSBlZGl0b3IuZ2V0TGluZShhYm92ZSk7XG5cdFx0XHRpZiAobCA9PSAnLS0tJykge1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdGFib3ZlLS07XG5cdFx0fVxuXHRcdGlmIChlZGl0b3IuZ2V0TGluZShhYm92ZSkgPT0gJy0tLScpIHtcblx0XHRcdGFib3ZlKys7XG5cdFx0fVxuXHRcdHdoaWxlKHRydWUpIHtcblx0XHRcdGlmIChlZGl0b3IuZ2V0TGluZShhYm92ZSkgPT0gJycpIHtcblx0XHRcdFx0YWJvdmUrKztcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIHRoZW4gZ2V0IGJlbG93XG5cdFx0d2hpbGUgKGJlbG93IDwgZWRpdG9yLmxpbmVDb3VudCgpKSB7XG5cdFx0XHRsZXQgbCA9IGVkaXRvci5nZXRMaW5lKGJlbG93KTtcblx0XHRcdGlmIChsID09ICctLS0nKSB7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0YmVsb3crKztcblx0XHR9XG5cdFx0aWYgKGVkaXRvci5nZXRMaW5lKGJlbG93KSA9PSAnLS0tJykge1xuXHRcdFx0YmVsb3ctLTtcblx0XHR9XG5cblx0XHR3aGlsZSh0cnVlKSB7XG5cdFx0XHRpZiAoZWRpdG9yLmdldExpbmUoYmVsb3cpID09ICcnKSB7XG5cdFx0XHRcdGJlbG93LS07XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyB0aGVuIHB1dCB0aGVtIHRvIGxpbmVcblxuXHRcdGxldCB0ZXh0ID0gXCJcIjtcblx0XHRBcnJheS5mcm9tKEFycmF5KGJlbG93IC0gYWJvdmUgKyAxKS5rZXlzKCkpLmZvckVhY2goaSA9PiB7XG5cdFx0XHRjb25zdCBsaW5lID0gZWRpdG9yLmdldExpbmUoaSArIGFib3ZlKVxuXHRcdFx0dGV4dCA9IHRleHQgKyBsaW5lICsgXCJcXG5cIlxuXHRcdH0pXG5cdFx0dGV4dCA9IHRleHQucmVwbGFjZSgvXFxuKyQvLCBcIlwiKVxuXHRcdHJldHVybiB0ZXh0XG5cdH1cblxuXHRnZXRUd2l0dGVyU2VnbWVudChlZGl0b3I6IEVkaXRvcikgOiBzdHJpbmcge1xuXHRcdGxldCBjdXJzb3IgPSBlZGl0b3IuZ2V0Q3Vyc29yKCk7XG5cdFx0bGV0IGxpbmUgPSBjdXJzb3IubGluZTtcblx0XHRsZXQgYWJvdmUgPSBsaW5lO1xuXHRcdGxldCBiZWxvdyA9IGxpbmU7XG5cdFx0Ly8gZmlyc3QgZ2V0IGFib3ZlXG5cdFx0XG5cdFx0d2hpbGUgKGFib3ZlID49IDApIHtcblx0XHRcdGxldCBsID0gZWRpdG9yLmdldExpbmUoYWJvdmUpO1xuXHRcdFx0aWYgKGwgPT0gJy0tLScpIHtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRhYm92ZS0tO1xuXHRcdH1cblx0XHRpZiAoZWRpdG9yLmdldExpbmUoYWJvdmUpID09ICctLS0nKSB7XG5cdFx0XHRhYm92ZSsrO1xuXHRcdH1cblx0XHR3aGlsZSh0cnVlKSB7XG5cdFx0XHRpZiAoZWRpdG9yLmdldExpbmUoYWJvdmUpID09ICcnKSB7XG5cdFx0XHRcdGFib3ZlKys7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyB0aGVuIGdldCBiZWxvd1xuXHRcdHdoaWxlIChiZWxvdyA8IGVkaXRvci5saW5lQ291bnQoKSkge1xuXHRcdFx0bGV0IGwgPSBlZGl0b3IuZ2V0TGluZShiZWxvdyk7XG5cdFx0XHRpZiAobCA9PSAnLS0tJykge1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdGJlbG93Kys7XG5cdFx0fVxuXHRcdGlmIChlZGl0b3IuZ2V0TGluZShiZWxvdykgPT0gJy0tLScpIHtcblx0XHRcdGJlbG93LS07XG5cdFx0fVxuXG5cdFx0d2hpbGUodHJ1ZSkge1xuXHRcdFx0aWYgKGVkaXRvci5nZXRMaW5lKGJlbG93KSA9PSAnJykge1xuXHRcdFx0XHRiZWxvdy0tO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gdGhlbiBwdXQgdGhlbSB0byBsaW5lXG5cblx0XHRsZXQgdGV4dCA9IFwiXCI7XG5cdFx0QXJyYXkuZnJvbShBcnJheShiZWxvdyAtIGFib3ZlICsgMSkua2V5cygpKS5mb3JFYWNoKGkgPT4ge1xuXHRcdFx0Y29uc3QgbGluZSA9IGVkaXRvci5nZXRMaW5lKGkgKyBhYm92ZSlcblx0XHRcdGlmICghbGluZS50cmltKCkuc3RhcnRzV2l0aChcIiUlXCIpIHx8ICFsaW5lLnRyaW0oKS5lbmRzV2l0aChcIiUlXCIpKSB7XG5cdFx0XHRcdGxldCBtb2RpZmllZExpbmUgPSBlZGl0b3IuZ2V0TGluZShpICsgYWJvdmUpXG5cdFx0XHRcdGlmICghL1xcZCtcXC9cXGQrICpcdTMwMTAuKlx1MzAxMS8udGVzdChtb2RpZmllZExpbmUpKSB7XG5cdFx0XHRcdFx0bW9kaWZpZWRMaW5lID0gbW9kaWZpZWRMaW5lLnJlcGxhY2UoL15cXFsoW15cXFtcXF1cXChcXCldKylcXF1cXChbXlxcW1xcXVxcKFxcKV0rXFwpL2csIFwiJDFcIilcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQucmVwbGFjZSgvW14hXVxcWyhbXlxcW1xcXVxcKFxcKV0rKVxcXVxcKFteXFxbXFxdXFwoXFwpXStcXCkvZywgXCIkMVwiKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC5yZXBsYWNlKC9odHRwc1teXFxuXStcXC5qcGVnL2csIFwiXCIpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0LnJlcGxhY2UoL1x1RkYxRihbXlx1MzAxMVx1MzAwRFxcbl0pL2csIFwiXHVGRjFGXFxuXFxuJDFcIilcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQucmVwbGFjZSgvXHUzMDAyKFteXHUzMDExXHUzMDBEXFxuXSkvZywgXCJcdTMwMDJcXG5cXG4kMVwiKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC5yZXBsYWNlKC9cdUZGMDEoW15cdTMwMTFcdTMwMERcXG5dKS9nLCBcIlx1RkYwMVxcblxcbiQxXCIpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0LnJlcGxhY2UoL1x1RkY1RShbXlx1MzAxMVx1MzAwRFxcbl0pL2csIFwiXHVGRjVFXFxuXFxuJDFcIilcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQucmVwbGFjZSgvXlxccyskLywgXCJcIilcblx0XHRcdFx0fVxuXHRcdFx0XHR0ZXh0ID0gdGV4dCArIG1vZGlmaWVkTGluZSArIFwiXFxuXCJcblx0XHRcdH1cblx0XHR9KVxuXHRcdHRleHQgPSB0ZXh0LnJlcGxhY2UoL1xcbiskLywgXCJcIilcblx0XHRyZXR1cm4gdGV4dFxuXHR9XG5cblx0YXN5bmMgYWRkM0RheXNBY3Rpb25Ob3RlQ29udGVudCh2YXVsdDogVmF1bHQpIHtcblx0XHRjb25zdCBzY2hlZHVsZU5vdGVXaXRob3V0TWQgPSBcIkQvUXVlcnkgU2NoZWR1bGUgYW5kIEFjdGlvbnMgbmV4dCAzIGRheXNcIlxuXHRcdGNvbnN0IHNjaGVkdWxlTm90ZSA9IGAke3NjaGVkdWxlTm90ZVdpdGhvdXRNZH0ubWRgXHRcdFx0XHRcblx0XHRpZiAodmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKHNjaGVkdWxlTm90ZSkgPT0gbnVsbCkge1xuXHRcdFx0YXdhaXQgdmF1bHQuY3JlYXRlKHNjaGVkdWxlTm90ZSwgXCJcIik7XG5cdFx0fVxuXHRcdGxldCBub3RlQ29udGVudCA9ICdbW1F1ZXJ5IFNjaGVkdWxlIGFuZCBBY3Rpb25zIG5leHQgMyBkYXlzXV1cXG4nXG5cdFx0Y29uc3QgZXhjbHVkZU5vdGVzID0gW3NjaGVkdWxlTm90ZVdpdGhvdXRNZCwgXCJEL1NjaGVkdWxpbmdcIl07XG5cdFx0QXJyYXkuZnJvbShBcnJheSgzKS5rZXlzKCkpLmZvckVhY2goaSA9PiBub3RlQ29udGVudCArPSB0aGlzLmdldFF1ZXJ5RGF0ZUFuZEFjdGlvblN0cmluZyhpLCBleGNsdWRlTm90ZXMpKTtcblx0XHRjb25zdCBvdGhlckRheXMgPSB0aGlzLmdldFF1ZXJ5QWN0aW9uc1RoaXNXZWVrKDMpO1xuXHRcdG5vdGVDb250ZW50ID0gbm90ZUNvbnRlbnQgKyBgIyMgbm4gLyB3blxcblxcYFxcYFxcYHF1ZXJ5XFxudGFnOiNubiBPUiB0YWc6I3duJHtvdGhlckRheXN9XFxuXFxgXFxgXFxgXFxuXFxuIyMgdHRcXG5cXGBcXGBcXGBxdWVyeVxcbnRhZzojdHRcXG5cXGBcXGBcXGBcXG5cXG5gXG5cdFx0bm90ZUNvbnRlbnQgPSBub3RlQ29udGVudCArIHRoaXMuZ2V0UXVlcnlGdXR1cmVEYXlzVGhpc1dlZWsoXCJGdXR1cmUgRGF0ZXNcIiwgMywgNiwgZXhjbHVkZU5vdGVzKVxuXHRcdG5vdGVDb250ZW50ID0gbm90ZUNvbnRlbnQgKyB0aGlzLmdldFF1ZXJ5TmV4dDJNb250aFN0cmluZyhleGNsdWRlTm90ZXMpXG5cdFx0bm90ZUNvbnRlbnQgPSBub3RlQ29udGVudCArIHRoaXMuZ2V0UXVlcnlGdXR1cmVEYXlzVGhpc1dlZWsoXCJQYXN0IERhdGVzXCIsIC03LCAtMSwgZXhjbHVkZU5vdGVzKVxuXHRcdC8vIG5vdGVDb250ZW50ID0gbm90ZUNvbnRlbnQgKyBgXFxuXFxuW1tRdWVyeSBTY2hlZHVsZSBhbmQgQWN0aW9ucyBuZXh0IDMgZGF5c11dYFxuXHRcdHZhdWx0Lm1vZGlmeSh2YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgoc2NoZWR1bGVOb3RlKSBhcyBURmlsZSwgbm90ZUNvbnRlbnQpO1xuXHR9XG5cblx0YXN5bmMgYWRkQWN0aW9uTm90ZUNvbnRlbnQodmF1bHQ6IFZhdWx0LCBmb2xkZXJOYW1lOiBTdHJpbmcsIG5vdGVUaXRsZVdpdGhvdXRNZDogU3RyaW5nLCBzY2hlZHVsZU5vdGVUaXRsZVdpdGhvdXRNZDogU3RyaW5nLCBuT3JXOiBTdHJpbmcpIHtcblx0XHRjb25zdCBub3dBY3Rpb25Ob3RlV2l0aG91dE1kID0gYCR7Zm9sZGVyTmFtZX0vJHtub3RlVGl0bGVXaXRob3V0TWR9YFxuXHRcdGNvbnN0IG5vd0FjdGlvbk5vdGUgPSBgJHtub3dBY3Rpb25Ob3RlV2l0aG91dE1kfS5tZGBcdFx0XHRcdFxuXHRcdGlmICh2YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgobm93QWN0aW9uTm90ZSkgPT0gbnVsbCkge1xuXHRcdFx0YXdhaXQgdmF1bHQuY3JlYXRlKG5vd0FjdGlvbk5vdGUsIFwiXCIpO1xuXHRcdH1cblx0XHRsZXQgbm93QWN0aW9uTm90ZUNvbnRlbnQgPSAnJ1xuXHRcdEFycmF5LmZyb20oQXJyYXkoMikua2V5cygpKS5mb3JFYWNoKGkgPT4gbm93QWN0aW9uTm90ZUNvbnRlbnQgKz0gdGhpcy5nZXRRdWVyeUFjdGlvblN0cmluZyhpLCBuT3JXKSk7XG5cdFx0bm93QWN0aW9uTm90ZUNvbnRlbnQgKz0gYFxcYFxcYFxcYHF1ZXJ5XFxudGFnOiMke25Pcld9dFxcblxcYFxcYFxcYFxcbmBcblx0XHRub3dBY3Rpb25Ob3RlQ29udGVudCArPSBgXFxgXFxgXFxgcXVlcnlcXG5gXG5cdFx0QXJyYXkuZnJvbShBcnJheSg1KS5rZXlzKCkpLmZvckVhY2goaSA9PiBub3dBY3Rpb25Ob3RlQ29udGVudCArPSB0aGlzLmdldFF1ZXJ5V2Vla0RheShpICsgMiwgbk9yVykpO1xuXHRcdG5vd0FjdGlvbk5vdGVDb250ZW50ICs9IGB0YWc6IyR7bk9yV31uXFxuXFxgXFxgXFxgXFxuYFxuXHRcdG5vd0FjdGlvbk5vdGVDb250ZW50ICs9IGBTY2hlZHVsaW5nOiBbWyR7c2NoZWR1bGVOb3RlVGl0bGVXaXRob3V0TWR9XV1cXG5gXG5cdFx0bm93QWN0aW9uTm90ZUNvbnRlbnQgKz0gYFtbJHtub3RlVGl0bGVXaXRob3V0TWR9XV1cXG5gXG5cblx0XHR2YXVsdC5tb2RpZnkodmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKG5vd0FjdGlvbk5vdGUpIGFzIFRGaWxlLCBub3dBY3Rpb25Ob3RlQ29udGVudCk7XG5cdH1cblxuXHRnZXRRdWVyeURhdGVBbmRBY3Rpb25TdHJpbmcoYWRkRGF5OiBudW1iZXIsIGV4Y2x1ZGVOb3RlczogU3RyaW5nW10pOiBzdHJpbmcge1xuXHRcdGNvbnN0IGRhdGVNb21lbnQgPSBtb21lbnQoKS5hZGQoYWRkRGF5LCAnZCcpO1xuXHRcdGNvbnN0IGRhdGVZWVlZTU1ERCA9IGRhdGVNb21lbnQuZm9ybWF0KCdZWVlZTU1ERCcpO1xuXHRcdGNvbnN0IGRhdGVFYWNoWVlERCA9ICdcXFxcZFxcXFxkXFxcXGRcXFxcZCcgKyBkYXRlTW9tZW50LmZvcm1hdCgnTU1ERCcpO1xuXHRcdGNvbnN0IGRhdGVFYWNoREQgPSAnXFxcXGRcXFxcZFxcXFxkXFxcXGRcXFxcZFxcXFxkJyArIGRhdGVNb21lbnQuZm9ybWF0KCdERCcpO1xuXHRcdGNvbnN0IGRheU9mV2VlayA9IGRhdGVNb21lbnQuZm9ybWF0KCdFJyk7XG5cdFx0Y29uc3QgZGF5T2ZXZWVrTG9uZyA9IGRhdGVNb21lbnQuZm9ybWF0KCdkZGQnKTtcblx0XHRjb25zdCBleGNsdWRlTm90ZVN0ciA9IGV4Y2x1ZGVOb3Rlcy5tYXAoZXhjbHVkZU5vdGUgPT4gYC1wYXRoOlwiJHtleGNsdWRlTm90ZX1cIiBgKS5qb2luKFwiXCIpXG5cdFx0cmV0dXJuIGAjIyAke2RhdGVZWVlZTU1ERH0gJHtkYXlPZldlZWtMb25nfVxcblxcYFxcYFxcYHF1ZXJ5XFxuKFwiICR7ZGF0ZVlZWVlNTUREfVwiIE9SIFwiJHtkYXRlWVlZWU1NRER9IFwiIE9SICR7ZGF0ZUVhY2hZWUREfSBPUiAke2RhdGVFYWNoRER9IE9SIHRhZzojbiR7ZGF5T2ZXZWVrfSBPUiB0YWc6I3cke2RheU9mV2Vla30pICR7ZXhjbHVkZU5vdGVTdHJ9LWJsb2NrOihxdWVyeSlcXG5cXGBcXGBcXGBcXG5cXG5gXG5cdH1cblxuXHRnZXRRdWVyeUFjdGlvbnNUaGlzV2VlayhleGNsdWRlTnVtRGF5czogTnVtYmVyKTogc3RyaW5nIHtcblx0XHRsZXQgZXhjbHVkZXMgOiBudW1iZXJbXSA9IFtdXG5cdFx0bGV0IGluY2x1ZGVzIDogbnVtYmVyW10gPSBbMSwgMiwgMywgNCwgNSwgNiwgN11cblx0XHRcblx0XHRBcnJheS5mcm9tKEFycmF5KGV4Y2x1ZGVOdW1EYXlzKS5rZXlzKCkpLmZvckVhY2goaSA9PiB7XG5cdFx0XHRjb25zdCBkYXRlTW9tZW50ID0gbW9tZW50KCkuYWRkKGksICdkJyk7XG5cdFx0XHRjb25zdCBkYXlPZldlZWsgPSBwYXJzZUludChkYXRlTW9tZW50LmZvcm1hdCgnRScpKTtcblx0XHRcdGV4Y2x1ZGVzLnB1c2goZGF5T2ZXZWVrKVxuXHRcdH0pXG5cdFx0bGV0IGFhYSA9IGluY2x1ZGVzLmZpbHRlcihpID0+IHtcblx0XHRcdGZvciAoY29uc3QgZSBvZiBleGNsdWRlcylcblx0XHRcdHtcblx0XHRcdFx0aWYgKGUgPT0gaSlcblx0XHRcdFx0e1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHJ1ZVxuXHRcdH0pXG5cdFx0bGV0IG91dHB1dCA9IFwiXCJcblx0XHRhYWEuZm9yRWFjaChpID0+IG91dHB1dCArPSBgIE9SIHRhZzojbiR7aX0gT1IgdGFnOiN3JHtpfWApXG5cdFx0cmV0dXJuIG91dHB1dFxuXHR9XG5cblx0Z2V0UXVlcnlGdXR1cmVEYXlzVGhpc1dlZWsoaGVhZGVyOiBTdHJpbmcsIGZyb206IG51bWJlciwgdG86IG51bWJlciwgZXhjbHVkZU5vdGVzOiBTdHJpbmdbXSk6IHN0cmluZyB7XG5cdFx0bGV0IGluY2x1ZGVzID0gW11cblx0XHRmb3IgKGxldCBpID0gZnJvbTsgaSA8PSB0bzsgaSsrKSB7XG5cdFx0XHRsZXQgZGF0ZU1vbWVudCA9IG1vbWVudCgpLmFkZChpLCAnZCcpO1xuXHRcdFx0aW5jbHVkZXMucHVzaChkYXRlTW9tZW50KVxuXHRcdH1cblx0XHRsZXQgb3V0cHV0ID0gYCMjICR7aGVhZGVyfVxcblxcYFxcYFxcYHF1ZXJ5XFxuKGBcblx0XHRpbmNsdWRlcy5mb3JFYWNoKGkgPT4ge1xuXHRcdFx0Y29uc3QgZGF0ZVlZWVlNTUREID0gaS5mb3JtYXQoJ1lZWVlNTUREJyk7XG5cdFx0XHRjb25zdCBkYXRlRWFjaFlZREQgPSAnXFxcXGRcXFxcZFxcXFxkXFxcXGQnICsgaS5mb3JtYXQoJ01NREQnKTtcblx0XHRcdGNvbnN0IGRhdGVFYWNoREQgPSAnXFxcXGRcXFxcZFxcXFxkXFxcXGRcXFxcZFxcXFxkJyArIGkuZm9ybWF0KCdERCcpO1xuXHRcdFx0b3V0cHV0ICs9IGBcIiAke2RhdGVZWVlZTU1ERH1cIiBPUiBcIiR7ZGF0ZVlZWVlNTUREfSBcIiBPUiAke2RhdGVFYWNoWVlERH0gT1IgJHtkYXRlRWFjaEREfSBPUiBgXG5cdFx0fSlcblx0XHRvdXRwdXQgPSBvdXRwdXQucmVwbGFjZSgvIE9SICQvLCBcIlwiKVxuXHRcdG91dHB1dCArPSBcIilcIlxuXHRcdGNvbnN0IGV4Y2x1ZGVOb3RlU3RyID0gZXhjbHVkZU5vdGVzLm1hcChleGNsdWRlTm90ZSA9PiBgLXBhdGg6XCIke2V4Y2x1ZGVOb3RlfVwiIGApLmpvaW4oXCJcIilcblx0XHRvdXRwdXQgKz0gYCAke2V4Y2x1ZGVOb3RlU3RyfS1ibG9jazoocXVlcnkpYFxuXHRcdG91dHB1dCArPSBgXFxuXFxgXFxgXFxgXFxuXFxuYFxuXHRcdHJldHVybiBvdXRwdXRcblx0fVxuXG5cdGdldFF1ZXJ5TmV4dDJNb250aFN0cmluZyhleGNsdWRlTm90ZXM6IFN0cmluZ1tdKTogc3RyaW5nIHtcblx0XHRjb25zdCBjdXJyZW50TW9udGhZWVlZTU0gPSBtb21lbnQoKS5mb3JtYXQoJ1lZWVlNTScpO1xuXHRcdGNvbnN0IGRhdGVNb21lbnQgPSBtb21lbnQoKS5hZGQoMSwgJ00nKTtcblx0XHRjb25zdCBuZXh0TW9udGhZWVlZTU0gPSBkYXRlTW9tZW50LmZvcm1hdCgnWVlZWU1NJyk7XG5cdFx0Y29uc3QgZXhjbHVkZU5vdGVTdHIgPSBleGNsdWRlTm90ZXMubWFwKGV4Y2x1ZGVOb3RlID0+IGAtcGF0aDpcIiR7ZXhjbHVkZU5vdGV9XCIgYCkuam9pbihcIlwiKVxuXHRcdHJldHVybiBgIyMgJHtjdXJyZW50TW9udGhZWVlZTU19IGFuZCAke25leHRNb250aFlZWVlNTX1cXG5cXGBcXGBcXGBxdWVyeVxcbigke2N1cnJlbnRNb250aFlZWVlNTX1cXFxcZFxcXFxkIE9SICR7bmV4dE1vbnRoWVlZWU1NfVxcXFxkXFxcXGQgJHtleGNsdWRlTm90ZVN0cn0tcGF0aDpcIkQvU2NoZWR1bGluZ1wiIC1ibG9jazoocXVlcnkpXFxuXFxgXFxgXFxgXFxuXFxuYFxuXHR9XG5cblx0Z2V0UXVlcnlEYXRlU3RyaW5nKGFkZERheTogbnVtYmVyLCBleGNsdWRlTm90ZTogU3RyaW5nKTogc3RyaW5nIHtcblx0XHRjb25zdCBkYXRlTW9tZW50ID0gbW9tZW50KCkuYWRkKGFkZERheSwgJ2QnKTtcblx0XHRjb25zdCBkYXRlWVlZWU1NREQgPSBkYXRlTW9tZW50LmZvcm1hdCgnWVlZWU1NREQnKTtcblx0XHRjb25zdCBkYXRlRWFjaFlZREQgPSAnXFxcXGRcXFxcZFxcXFxkXFxcXGQnICsgZGF0ZU1vbWVudC5mb3JtYXQoJ01NREQnKTtcblx0XHRjb25zdCBkYXRlRWFjaEREID0gJ1xcXFxkXFxcXGRcXFxcZFxcXFxkXFxcXGRcXFxcZCcgKyBkYXRlTW9tZW50LmZvcm1hdCgnREQnKTtcblx0XHRyZXR1cm4gYCR7ZGF0ZVlZWVlNTUREfVxcblxcYFxcYFxcYHF1ZXJ5XFxuKCR7ZGF0ZVlZWVlNTUREfSBPUiAke2RhdGVFYWNoWVlERH0gT1IgJHtkYXRlRWFjaEREfSkgLXBhdGg6XCIke2V4Y2x1ZGVOb3RlfVwiIC1ibG9jazoocXVlcnkpXFxuXFxgXFxgXFxgXFxuYFxuXHR9XG5cblx0Z2V0UXVlcnlBY3Rpb25TdHJpbmcoYWRkRGF5OiBudW1iZXIsIGFjdGlvblR5cGU6IFN0cmluZyk6IHN0cmluZyB7XG5cdFx0Y29uc3QgZGF0ZU1vbWVudCA9IG1vbWVudCgpLmFkZChhZGREYXksICdkJyk7XG5cdFx0Y29uc3QgZGF5T2ZXZWVrID0gZGF0ZU1vbWVudC5mb3JtYXQoJ0UnKTtcblx0XHRyZXR1cm4gYFxcYFxcYFxcYHF1ZXJ5XFxudGFnOiMke2FjdGlvblR5cGV9JHtkYXlPZldlZWt9XFxuXFxgXFxgXFxgXFxuYFxuXHR9XG5cblx0Z2V0UXVlcnlXZWVrRGF5KGFkZERheTogbnVtYmVyLCBhY3Rpb25UeXBlOiBTdHJpbmcpOiBzdHJpbmcge1xuXHRcdGNvbnN0IGRhdGVNb21lbnQgPSBtb21lbnQoKS5hZGQoYWRkRGF5LCAnZCcpO1xuXHRcdGNvbnN0IGRheU9mV2VlayA9IGRhdGVNb21lbnQuZm9ybWF0KCdFJyk7XG5cdFx0cmV0dXJuIGB0YWc6IyR7YWN0aW9uVHlwZX0ke2RheU9mV2Vla30gT1IgYFxuXHR9XG5cdCAgXG5cdGFkZE5ld0xhdGVyQWN0aW9uSWNvbih0OiBzdHJpbmcpIHtcblx0XHR0aGlzLmFkZE9ic2lkaWFuSWNvbihgJHt0fWwtaWNvbi1uZXdgLCBgJHt0fWxgKTtcblx0fVxuXHQgIFxuXHRhZGRBY3Rpb25JY29uKHQ6IHN0cmluZykge1xuXHRcdHRoaXMuYWRkT2JzaWRpYW5JY29uKGAke3R9LWljb25gLCBgIyR7dH1gKTtcblx0fVxuXG5cdGFkZE9ic2lkaWFuSWNvbihpY29uTmFtZTogc3RyaW5nLCBpY29uVGV4dDogc3RyaW5nKSB7XG5cdFx0Y29uc3Qgc3ZnID0gYDx0ZXh0IHN0cm9rZT0nIzAwMCcgdHJhbnNmb3JtPSdtYXRyaXgoMi43OTE2NyAwIDAgMi4xMjY2MyAtMzQuMDQxNyAtMjUuMjA4NCknIHhtbDpzcGFjZT0ncHJlc2VydmUnIHRleHQtYW5jaG9yPSdzdGFydCcgZm9udC1mYW1pbHk9J21vbm9zcGFjZScgZm9udC1zaXplPScyNCcgeT0nNDQnIHg9JzE5JyBzdHJva2Utd2lkdGg9JzAnIGZpbGw9J2N1cnJlbnRDb2xvcic+JHtpY29uVGV4dH08L3RleHQ+YDtcblx0XHRhZGRJY29uKGljb25OYW1lLCBzdmcpO1xuXHR9XG5cblx0YWRkTmV3TGF0ZXJBY3Rpb24odDogc3RyaW5nKSB7XG5cdFx0dGhpcy5hZGRDb21tYW5kKHtcblx0XHRcdGlkOiBgYWRkLW5ldy0ke3R9LWxhdGVyLWFjdGlvbmAsXG5cdFx0XHRuYW1lOiBgQWRkICR7dH1sIHRhc2tgLFxuXHRcdFx0aWNvbjogYCR7dH1sLWljb24tbmV3YCxcblx0XHRcdGVkaXRvckNhbGxiYWNrOiAoZWRpdG9yOiBFZGl0b3IsIHZpZXc6IE1hcmtkb3duVmlldykgPT4ge1xuXHRcdFx0XHRjb25zdCBjdXJzb3IgPSBlZGl0b3IuZ2V0Q3Vyc29yKCk7XG5cdFx0XHRcdGVkaXRvci5yZXBsYWNlUmFuZ2UoYCMke3R9bCBgLCBjdXJzb3IpO1xuXHRcdFx0XHRjdXJzb3IuY2ggPSBjdXJzb3IuY2ggKyA0O1xuXHRcdFx0XHRlZGl0b3Iuc2V0Q3Vyc29yKGN1cnNvcik7XG5cdFx0XHR9LFxuXHRcdFx0aG90a2V5czogW1xuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bW9kaWZpZXJzOiBbYEN0cmxgLCBgTWV0YWAsIGBTaGlmdGBdLFxuXHRcdFx0XHRcdGtleTogdCA9PSAnbicgPyAnMScgOiAnMidcblx0XHRcdFx0fSxcblx0XHRcdFx0e1xuXHRcdFx0XHRcdG1vZGlmaWVyczogW2BDdHJsYCwgYEFsdGAsIGBTaGlmdGBdLFxuXHRcdFx0XHRcdGtleTogdCA9PSAnbicgPyAnMScgOiAnMidcblx0XHRcdFx0fVxuXHRcdFx0XVxuXHRcdH0pO1xuXHR9XG5cblx0YWRkQWN0aW9uQ29tbWFuZCh0OiBzdHJpbmcpIHtcblx0XHR0aGlzLmFkZENvbW1hbmQoe1xuXHRcdFx0aWQ6IGB0by13JHt0fS1uJHt0fWAsXG5cdFx0XHRuYW1lOiBgVG8gdyR7dH0gb3IgbiR7dH1gLFxuXHRcdFx0aWNvbjogYCR7dH0taWNvbmAsXG5cdFx0XHRlZGl0b3JDYWxsYmFjazogKGVkaXRvcjogRWRpdG9yLCB2aWV3OiBNYXJrZG93blZpZXcpID0+IHtcblx0XHRcdFx0Y29uc29sZS5sb2coZWRpdG9yLmdldFNlbGVjdGlvbigpKTtcblx0XHRcdFx0Y29uc3QgY3Vyc29yID0gZWRpdG9yLmdldEN1cnNvcigpO1xuXHRcdFx0XHRjb25zdCBsaW5lTnVtYmVyID0gZWRpdG9yLmdldEN1cnNvcigpLmxpbmU7XG5cdFx0XHRcdGNvbnN0IGxpbmUgPSBlZGl0b3IuZ2V0TGluZShsaW5lTnVtYmVyKTtcblx0XHRcdFx0Y29uc3QgcmVwbGFjZWRMaW5lID0gbGluZS5yZXBsYWNlKC8gYVxcL3dcXC8uLywgYCBhL3cvJHt0fWApXG5cdFx0XHRcdCAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvIGFcXC9uXFwvLi8sIGAgYS9uLyR7dH1gKVxuXHRcdFx0XHRcdFx0XHRcdCBcdCBcdCAucmVwbGFjZSgvI3cuIC8sIGAjdyR7dH0gYClcblx0XHRcdFx0XHRcdFx0XHRcdFx0IC5yZXBsYWNlKC8jbi4gLywgYCNuJHt0fSBgKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQgLnJlcGxhY2UoLyN3LiQvLCBgI3cke3R9YClcblx0XHRcdFx0XHRcdFx0XHRcdFx0IC5yZXBsYWNlKC8jbi4kLywgYCNuJHt0fWApXG5cdFx0XHRcdGlmIChsaW5lLmNvbnRhaW5zKGAjbiR7dH0gYCkgfHwgbGluZS5jb250YWlucyhgI3cke3R9IGApKSB7XG5cdFx0XHRcdFx0Y29uc3QgbnQgPSBgI24ke3R9IGBcblx0XHRcdFx0XHRjb25zdCB3dCA9IGAjdyR7dH0gYFxuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGNvbnN0IHJlcGxhY2VMaW5lVG9SZW1vdmVUYWcgPSBsaW5lLnJlcGxhY2UoYCNuJHt0fSBgLCBgYCkucmVwbGFjZShgI3cke3R9IGAsIGBgKVxuXHRcdFx0XHRcdGVkaXRvci5zZXRMaW5lKGxpbmVOdW1iZXIsIHJlcGxhY2VMaW5lVG9SZW1vdmVUYWcpO1xuXHRcdFx0XHRcdC8vIGxldHMgc2F5IFwiI250IFwiIGlzIGF0IDMgKGNoYXIgZm9yICMpXG5cdFx0XHRcdFx0Ly8gaWYgY2ggPD0gMyBubyBuZWVkIHRvIHVwZGF0ZVxuXHRcdFx0XHRcdC8vIGlmIGNoID49IDcgdGhlbiBuZWVkIHRvIC00XG5cdFx0XHRcdFx0Ly8gZWxzZSBjaCA9PSAzXG5cdFx0XHRcdFx0Y29uc3QgbnRJbmRleCA9IGxpbmUuaW5kZXhPZihudClcblx0XHRcdFx0XHRjb25zdCB3dEluZGV4ID0gbGluZS5pbmRleE9mKHd0KVxuXHRcdFx0XHRcdGNvbnN0IGluZGV4ID0gbnRJbmRleCA9PSAtMSA/IHd0SW5kZXggOiBudEluZGV4XG5cdFx0XHRcdFx0Y29uc3QgbmV3Q2ggPSBjdXJzb3IuY2ggPD0gaW5kZXggPyBjdXJzb3IuY2ggOiAoY3Vyc29yLmNoID49IGluZGV4ICsgNCA/IGN1cnNvci5jaCAtIDQgOiBpbmRleClcblx0XHRcdFx0XHRjdXJzb3IuY2ggPSBuZXdDaFxuXHRcdFx0XHRcdGVkaXRvci5zZXRDdXJzb3IoY3Vyc29yKTtcblx0XHRcdFx0fSBlbHNlIGlmIChsaW5lLmNvbnRhaW5zKGAgI24ke3R9YCkgfHwgbGluZS5jb250YWlucyhgICN3JHt0fWApKSB7XG5cdFx0XHRcdFx0Y29uc3QgbnQgPSBgI24ke3R9IGBcblx0XHRcdFx0XHRjb25zdCB3dCA9IGAjdyR7dH0gYFxuXHRcdFx0XHRcdFxuXHRcdFx0XHRcdGNvbnN0IHJlcGxhY2VMaW5lVG9SZW1vdmVUYWcgPSBsaW5lLnJlcGxhY2UoYCAjbiR7dH1gLCBgYCkucmVwbGFjZShgICN3JHt0fWAsIGBgKVxuXHRcdFx0XHRcdGVkaXRvci5zZXRMaW5lKGxpbmVOdW1iZXIsIHJlcGxhY2VMaW5lVG9SZW1vdmVUYWcpO1xuXHRcdFx0XHRcdC8vIGxldHMgc2F5IFwiI250IFwiIGlzIGF0IDMgKGNoYXIgZm9yICMpXG5cdFx0XHRcdFx0Ly8gaWYgY2ggPD0gMyBubyBuZWVkIHRvIHVwZGF0ZVxuXHRcdFx0XHRcdC8vIGlmIGNoID49IDcgdGhlbiBuZWVkIHRvIC00XG5cdFx0XHRcdFx0Ly8gZWxzZSBjaCA9PSAzXG5cdFx0XHRcdFx0Y29uc3QgbnRJbmRleCA9IGxpbmUuaW5kZXhPZihudClcblx0XHRcdFx0XHRjb25zdCB3dEluZGV4ID0gbGluZS5pbmRleE9mKHd0KVxuXHRcdFx0XHRcdGNvbnN0IGluZGV4ID0gbnRJbmRleCA9PSAtMSA/IHd0SW5kZXggOiBudEluZGV4XG5cdFx0XHRcdFx0Y29uc3QgbmV3Q2ggPSBjdXJzb3IuY2ggPD0gaW5kZXggPyBjdXJzb3IuY2ggOiAoY3Vyc29yLmNoID49IGluZGV4ICsgNCA/IGN1cnNvci5jaCAtIDQgOiBpbmRleClcblx0XHRcdFx0XHRjdXJzb3IuY2ggPSBuZXdDaFxuXHRcdFx0XHRcdGVkaXRvci5zZXRDdXJzb3IoY3Vyc29yKTtcblx0XHRcdFx0fSBlbHNlIGlmIChsaW5lLmNvbnRhaW5zKGAgYS9uLyR7dH1gKSB8fCBsaW5lLmNvbnRhaW5zKGAgYS93LyR7dH1gKSkge1xuXHRcdFx0XHRcdC8vIGRvIG5vdGhpbmdcblx0XHRcdFx0fSBlbHNlIGlmIChyZXBsYWNlZExpbmUgPT0gbGluZSkgeyAvLyBubyB0YWcsIHRvIGFkZCB0YWdcblx0XHRcdFx0XHRuZXcgQWRkVGFza1RhZ01vZGFsKHRoaXMuYXBwLCBlZGl0b3IsIHQpLm9wZW4oKTtcblx0XHRcdFx0fSBlbHNlIHtcdFx0XHQgXG5cdFx0XHRcdFx0ZWRpdG9yLnNldExpbmUobGluZU51bWJlciwgcmVwbGFjZWRMaW5lKTtcblx0XHRcdFx0XHRlZGl0b3Iuc2V0Q3Vyc29yKGN1cnNvcik7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRob3RrZXlzOiBbXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRtb2RpZmllcnM6IHRoaXMuaXMxVG83KHQpID8gW2BDdHJsYCwgYE1ldGFgXSA6IFtgQ3RybGAsIGBNZXRhYCwgYFNoaWZ0YF0sXG5cdFx0XHRcdFx0a2V5OiBgJHt0fWAsXG5cdFx0XHRcdH0sXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRtb2RpZmllcnM6IHRoaXMuaXMxVG83KHQpID8gW2BDdHJsYCwgYEFsdGBdIDogW2BDdHJsYCwgYEFsdGAsIGBTaGlmdGBdLFxuXHRcdFx0XHRcdGtleTogYCR7dH1gLFxuXHRcdFx0XHR9XG5cdFx0XHRdXG5cdFx0fSk7XG5cdH1cblxuXHRhZGRGb2xsb3dVcENvbW1hbmQodDogc3RyaW5nKSB7XG5cdFx0bGV0IG5hbWUgPSBcIlwiXG5cdFx0aWYgKHQgPT09ICd0Jykge1xuXHRcdFx0bmFtZSA9ICdUbyBUcnknXG5cdFx0fSBlbHNlIGlmICh0ID09PSAnZScpIHtcblx0XHRcdG5hbWUgPSAnVG8gRXhwbG9yZSdcblx0XHR9IGVsc2UgaWYgKHQgPT09ICdtJykge1xuXHRcdFx0bmFtZSA9ICdUbyBNb3ZlJ1xuXHRcdH1cblx0XHR0aGlzLmFkZENvbW1hbmQoe1xuXHRcdFx0aWQ6IGB0by10JHt0fWAsXG5cdFx0XHRuYW1lOiBgVG8gdCR7dH0gJHtuYW1lfWAsXG5cdFx0XHRpY29uOiBgJHt0fS1pY29uYCxcblx0XHRcdGVkaXRvckNhbGxiYWNrOiAoZWRpdG9yOiBFZGl0b3IsIHZpZXc6IE1hcmtkb3duVmlldykgPT4ge1xuXHRcdFx0XHRjb25zb2xlLmxvZyhlZGl0b3IuZ2V0U2VsZWN0aW9uKCkpO1xuXHRcdFx0XHRjb25zdCBjdXJzb3IgPSBlZGl0b3IuZ2V0Q3Vyc29yKCk7XG5cdFx0XHRcdGNvbnN0IGxpbmVOdW1iZXIgPSBlZGl0b3IuZ2V0Q3Vyc29yKCkubGluZTtcblx0XHRcdFx0Y29uc3QgbGluZSA9IGVkaXRvci5nZXRMaW5lKGxpbmVOdW1iZXIpO1xuXHRcdFx0XHRjb25zdCByZXBsYWNlZExpbmUgPSBsaW5lLnJlcGxhY2UoLyN0LiAvLCBgI3Qke3R9IGApXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCAucmVwbGFjZSgvI3QuJC8sIGAjdCR7dH1gKVxuXHRcdFx0XHRpZiAobGluZS5jb250YWlucyhgI3Qke3R9IGApKSB7XG5cdFx0XHRcdFx0Y29uc3QgdHQgPSBgI3Qke3R9IGBcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRjb25zdCByZXBsYWNlTGluZVRvUmVtb3ZlVGFnID0gbGluZS5yZXBsYWNlKGAjdCR7dH0gYCwgYGApXG5cdFx0XHRcdFx0ZWRpdG9yLnNldExpbmUobGluZU51bWJlciwgcmVwbGFjZUxpbmVUb1JlbW92ZVRhZyk7XG5cdFx0XHRcdFx0Ly8gbGV0cyBzYXkgXCIjdHQgXCIgaXMgYXQgMyAoY2hhciBmb3IgIylcblx0XHRcdFx0XHQvLyBpZiBjaCA8PSAzIG5vIG5lZWQgdG8gdXBkYXRlXG5cdFx0XHRcdFx0Ly8gaWYgY2ggPj0gNyB0aGVuIG5lZWQgdG8gLTRcblx0XHRcdFx0XHQvLyBlbHNlIGNoID09IDNcblx0XHRcdFx0XHRjb25zdCB0dEluZGV4ID0gbGluZS5pbmRleE9mKHR0KVxuXHRcdFx0XHRcdGNvbnN0IGluZGV4ID0gdHRJbmRleFxuXHRcdFx0XHRcdGNvbnN0IG5ld0NoID0gY3Vyc29yLmNoIDw9IGluZGV4ID8gY3Vyc29yLmNoIDogKGN1cnNvci5jaCA+PSBpbmRleCArIDQgPyBjdXJzb3IuY2ggLSA0IDogaW5kZXgpXG5cdFx0XHRcdFx0Y3Vyc29yLmNoID0gbmV3Q2hcblx0XHRcdFx0XHRlZGl0b3Iuc2V0Q3Vyc29yKGN1cnNvcik7XG5cdFx0XHRcdH0gZWxzZSBpZiAobGluZS5jb250YWlucyhgICN0JHt0fWApKSB7XG5cdFx0XHRcdFx0Y29uc3QgdHQgPSBgI3Qke3R9IGBcblx0XHRcdFx0XHRcblx0XHRcdFx0XHRjb25zdCByZXBsYWNlTGluZVRvUmVtb3ZlVGFnID0gbGluZS5yZXBsYWNlKGAgI3Qke3R9YCwgYGApXG5cdFx0XHRcdFx0ZWRpdG9yLnNldExpbmUobGluZU51bWJlciwgcmVwbGFjZUxpbmVUb1JlbW92ZVRhZyk7XG5cdFx0XHRcdFx0Ly8gbGV0cyBzYXkgXCIjdHQgXCIgaXMgYXQgMyAoY2hhciBmb3IgIylcblx0XHRcdFx0XHQvLyBpZiBjaCA8PSAzIG5vIG5lZWQgdG8gdXBkYXRlXG5cdFx0XHRcdFx0Ly8gaWYgY2ggPj0gNyB0aGVuIG5lZWQgdG8gLTRcblx0XHRcdFx0XHQvLyBlbHNlIGNoID09IDNcblx0XHRcdFx0XHRjb25zdCB0dEluZGV4ID0gbGluZS5pbmRleE9mKHR0KVxuXHRcdFx0XHRcdGNvbnN0IGluZGV4ID0gdHRJbmRleFxuXHRcdFx0XHRcdGNvbnN0IG5ld0NoID0gY3Vyc29yLmNoIDw9IGluZGV4ID8gY3Vyc29yLmNoIDogKGN1cnNvci5jaCA+PSBpbmRleCArIDQgPyBjdXJzb3IuY2ggLSA0IDogaW5kZXgpXG5cdFx0XHRcdFx0Y3Vyc29yLmNoID0gbmV3Q2hcblx0XHRcdFx0XHRlZGl0b3Iuc2V0Q3Vyc29yKGN1cnNvcik7XG5cdFx0XHRcdH0gZWxzZSBpZiAocmVwbGFjZWRMaW5lID09IGxpbmUpIHsgLy8gbm8gdGFnLCB0byBhZGQgdGFnXG5cdFx0XHRcdFx0Y29uc3QgY3Vyc29yID0gZWRpdG9yLmdldEN1cnNvcigpXG5cdFx0XHRcdFx0Y29uc3QgbGluZSA9IGVkaXRvci5nZXRMaW5lKGN1cnNvci5saW5lKTtcblx0XHRcdFx0XHRlZGl0b3IucmVwbGFjZVJhbmdlKGAke2xpbmUuY2hhckF0KGN1cnNvci5jaCAtIDEpICE9ICcgJyA/ICcgJyA6IFwiXCJ9I3Qke3R9IGAsIGN1cnNvcik7ICBcblx0XHRcdFx0XHRjdXJzb3IuY2ggPSBjdXJzb3IuY2ggKyA0ICsgKGxpbmUuY2hhckF0KGN1cnNvci5jaCAtIDEpICE9ICcgJyA/IDEgOiAwKTtcblx0XHRcdFx0XHRlZGl0b3Iuc2V0Q3Vyc29yKGN1cnNvcik7XG5cdFx0XHRcdH0gZWxzZSB7XHRcdFx0IFxuXHRcdFx0XHRcdGVkaXRvci5zZXRMaW5lKGxpbmVOdW1iZXIsIHJlcGxhY2VkTGluZSk7XG5cdFx0XHRcdFx0ZWRpdG9yLnNldEN1cnNvcihjdXJzb3IpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0aG90a2V5czogW1xuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bW9kaWZpZXJzOiBbYEN0cmxgLCBgTWV0YWAsIGBTaGlmdGBdLFxuXHRcdFx0XHRcdGtleTogYCR7dH1gLFxuXHRcdFx0XHR9LFxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bW9kaWZpZXJzOiBbYEN0cmxgLCBgQWx0YCwgYFNoaWZ0YF0sXG5cdFx0XHRcdFx0a2V5OiBgJHt0fWAsXG5cdFx0XHRcdH1cblx0XHRcdF1cblx0XHR9KTtcblx0fVxuXG5cblx0aXMxVG83KHQ6IHN0cmluZykgOiBib29sZWFuIHtcblx0XHRpZiAodCA9PSBcIjFcIiB8fCB0ID09IFwiMlwiIHx8IHQgPT0gXCIzXCIgfHwgdCA9PSBcIjRcIiB8fCB0ID09IFwiNVwiIHx8IHQgPT0gXCI2XCIgfHwgdCA9PSBcIjdcIikge1xuXHRcdFx0cmV0dXJuIHRydWVcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIGZhbHNlXG5cdFx0fVxuXHR9XG5cblx0YWRkVG9DbGlwYm9hcmRIaXN0b3J5KGNvbnRlbnQ6IHN0cmluZykge1xuXHRcdGNvbnN0IGluZGV4ID0gY2xpcGJvYXJkSGlzdG9yeS5pbmRleE9mKGNvbnRlbnQsIDApO1xuXHRcdGlmIChpbmRleCA+IC0xKSB7XG5cdFx0XHRjbGlwYm9hcmRIaXN0b3J5LnNwbGljZShpbmRleCwgMSk7XG5cdFx0fVxuXHRcdGlmIChjb250ZW50Lmxlbmd0aCA+IDApIHtcblx0XHRcdGNsaXBib2FyZEhpc3RvcnkucHVzaChjb250ZW50KTtcblx0XHR9XG5cdH1cblxuXHRvbnVubG9hZCgpIHtcblxuXHR9XG5cblx0YXN5bmMgbG9hZFNldHRpbmdzKCkge1xuXHRcdHRoaXMuc2V0dGluZ3MgPSBPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUX1NFVFRJTkdTLCBhd2FpdCB0aGlzLmxvYWREYXRhKCkpO1xuXHR9XG5cblx0YXN5bmMgc2F2ZVNldHRpbmdzKCkge1xuXHRcdGF3YWl0IHRoaXMuc2F2ZURhdGEodGhpcy5zZXR0aW5ncyk7XG5cdH1cbn1cblxuY2xhc3MgU2FtcGxlU2V0dGluZ1RhYiBleHRlbmRzIFBsdWdpblNldHRpbmdUYWIge1xuXHRwbHVnaW46IE15UGx1Z2luO1xuXG5cdGNvbnN0cnVjdG9yKGFwcDogQXBwLCBwbHVnaW46IE15UGx1Z2luKSB7XG5cdFx0c3VwZXIoYXBwLCBwbHVnaW4pO1xuXHRcdHRoaXMucGx1Z2luID0gcGx1Z2luO1xuXHR9XG5cblx0ZGlzcGxheSgpOiB2b2lkIHtcblx0XHRjb25zdCB7Y29udGFpbmVyRWx9ID0gdGhpcztcblxuXHRcdGNvbnRhaW5lckVsLmVtcHR5KCk7XG5cblx0XHRjb250YWluZXJFbC5jcmVhdGVFbCgnaDInLCB7dGV4dDogJ1NldHRpbmdzIGZvciBteSBhd2Vzb21lIHBsdWdpbi4nfSk7XG5cblx0XHRuZXcgU2V0dGluZyhjb250YWluZXJFbClcblx0XHRcdC5zZXROYW1lKCdTZXR0aW5nICMxJylcblx0XHRcdC5zZXREZXNjKCdJdFxcJ3MgYSBzZWNyZXQnKVxuXHRcdFx0LmFkZFRleHQodGV4dCA9PiB0ZXh0XG5cdFx0XHRcdC5zZXRQbGFjZWhvbGRlcignRW50ZXIgeW91ciBzZWNyZXQnKVxuXHRcdFx0XHQuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MubXlTZXR0aW5nKVxuXHRcdFx0XHQub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG5cdFx0XHRcdFx0Y29uc29sZS5sb2coJ1NlY3JldDogJyArIHZhbHVlKTtcblx0XHRcdFx0XHR0aGlzLnBsdWdpbi5zZXR0aW5ncy5teVNldHRpbmcgPSB2YWx1ZTtcblx0XHRcdFx0XHRhd2FpdCB0aGlzLnBsdWdpbi5zYXZlU2V0dGluZ3MoKTtcblx0XHRcdFx0fSkpO1xuXHR9XG59XG4iLCAiaW1wb3J0IHsgQXBwLCBFZGl0b3IsIEZ1enp5U3VnZ2VzdE1vZGFsLCBGdXp6eU1hdGNoLCBURmlsZSwgTm90aWNlIH0gZnJvbSBcIm9ic2lkaWFuXCI7XG5pbXBvcnQgeyBoYXNGcm9udE1hdHRlciwgaGFzVGFncywgcmVuYW1lVGFnIH0gZnJvbSBcInRhZ3JlbmFtZXIvcmVuYW1pbmdcIjtcbmltcG9ydCB7RmlsZX0gZnJvbSBcInRhZ3JlbmFtZXIvRmlsZVwiO1xuXG5pbnRlcmZhY2UgTm90ZVR5cGUge1xuICB0eXBlOiBzdHJpbmc7XG4gIGRlc2NyaXB0aW9uOiBzdHJpbmc7XG59XG5cbmNvbnN0IEFMTF9UWVBFUyA9IFtcbiAge1xuICAgIHR5cGU6IFwiYS9uL25cIixcbiAgICBkZXNjcmlwdGlvbjogXCJOIEN1cnJlbnQgVGFza1wiLFxuICB9LFxuICB7XG4gICAgdHlwZTogXCJhL3cvblwiLFxuICAgIGRlc2NyaXB0aW9uOiBcIlcgQ3VycmVudCBUYXNrXCIsXG4gIH0sXG4gIHtcbiAgICB0eXBlOiBcImEvbi9sXCIsXG4gICAgZGVzY3JpcHRpb246IFwiTiBMYXRlciBUYXNrXCIsXG4gIH0sXG4gIHtcbiAgICB0eXBlOiBcImEvdy9sXCIsXG4gICAgZGVzY3JpcHRpb246IFwiVyBMYXRlciBUYXNrXCIsXG4gIH0sXG4gIHtcbiAgICB0eXBlOiBcImEvbi9wXCIsXG4gICAgZGVzY3JpcHRpb246IFwiTiBQZXJtYW5lbnQgVGFza1wiLFxuICB9LFxuICB7XG4gICAgdHlwZTogXCJhL3cvcFwiLFxuICAgIGRlc2NyaXB0aW9uOiBcIlcgUGVybWFuZW50IFRhc2tcIixcbiAgfSxcbiAge1xuICAgIHR5cGU6IFwiYi9uL3NcIixcbiAgICBkZXNjcmlwdGlvbjogXCJaZXR0ZWxrYXN0ZW4gLSBTb3VyY2Ugbm90ZXMgKGxpa2UgYm9va3MgLyB2aWRlbyAvIHRob3VnaHRzIC8gY29udmVyc2F0aW9uKVwiLFxuICB9LFxuICB7XG4gICAgdHlwZTogXCJiL24vY1wiLFxuICAgIGRlc2NyaXB0aW9uOiBcIlpldHRlbGthc3RlbiAtIENhcmRzIChXaXRoIHlvdXIgb3duIHRob3VnaHQpXCIsXG4gIH0sXG4gIHtcbiAgICB0eXBlOiBcImMvdC9kXCIsXG4gICAgZGVzY3JpcHRpb246IFwiVGhyZWFkcyBwb3N0IGRyYWZ0XCIsXG4gIH0sXG4gIHtcbiAgICB0eXBlOiBcImMvYi9kXCIsXG4gICAgZGVzY3JpcHRpb246IFwiQmxvZyBwb3N0IGRyYWZ0XCIsXG4gIH0sXG4gIHtcbiAgICB0eXBlOiBcImIvbi91XCIsXG4gICAgZGVzY3JpcHRpb246IFwiWmV0dGVsa2FzdGVuIC0gVW5wcm9jZXNzZWQgbWF0ZXJpYWwgbGlrZSBhbiBpbmJveFwiLFxuICB9LFxuICB7XG4gICAgdHlwZTogXCJiL24vbVwiLFxuICAgIGRlc2NyaXB0aW9uOiBcIlpldHRlbGthc3RlbiAtIE1PQyBOb3RlcyBmb3IgYSBzbWFsbCB0b3BpY1wiLFxuICB9LFxuICB7XG4gICAgdHlwZTogXCJiL24velwiLFxuICAgIGRlc2NyaXB0aW9uOiBcIlpldHRlbGthc3RlbiAtIFNsaXAgYm94XCIsXG4gIH0sXG4gIHtcbiAgICB0eXBlOiBcImIvbi9pXCIsXG4gICAgZGVzY3JpcHRpb246IFwiSW5kZXggTm90ZXMgZm9yIGEgYmlnIHRvcGljXCIsXG4gIH0sXG4gIHtcbiAgICB0eXBlOiBcImIvbi9uXCIsXG4gICAgZGVzY3JpcHRpb246IFwiWmV0dGVsa2FzdGVuIC0gTm90ZXMgKERlcHJlY2F0ZWQpXCIsXG4gIH0sXG4gIHtcbiAgICB0eXBlOiBcImIvbi92XCIsXG4gICAgZGVzY3JpcHRpb246IFwiWmV0dGVsa2FzdGVuIC0gVm9pY2Ugc2NyaXB0IChEZXByZWNhdGVkPylcIixcbiAgfSxcbiAge1xuICAgIHR5cGU6IFwiYi9uL3JcIixcbiAgICBkZXNjcmlwdGlvbjogXCJaZXR0ZWxrYXN0ZW4gLSBSZWZlcmVuY2UgKERlcHJlY2F0ZWQ/KVwiLFxuICB9LFxuICB7XG4gICAgdHlwZTogXCJiL24vcFwiLFxuICAgIGRlc2NyaXB0aW9uOiBcIlBsYWNlaG9sZGVyIE5vdGVzIChEZXByZWNhdGVkPylcIixcbiAgfSxcbiAge1xuICAgIHR5cGU6IFwiYi9hL3BcIixcbiAgICBkZXNjcmlwdGlvbjogXCJBcmVhIG9mIFJlc3BvbnNpYmlsaXR5IC0gUHJpbWFyeVwiLFxuICB9LFxuICB7XG4gICAgdHlwZTogXCJiL2Evc1wiLFxuICAgIGRlc2NyaXB0aW9uOiBcIkFyZWEgb2YgUmVzcG9uc2liaWxpdHkgLSBTZWNvbmRhcnlcIixcbiAgfSxcbiAge1xuICAgIHR5cGU6IFwiYy9iL2lcIixcbiAgICBkZXNjcmlwdGlvbjogXCJCbG9nIHBvc3QgY29udGVudCBjb21wbGV0ZWQgYnV0IGF3YWl0aW5nIHVwbG9hZCBpbWFnZVwiLFxuICB9LFxuICB7XG4gICAgdHlwZTogXCJjL2IvclwiLFxuICAgIGRlc2NyaXB0aW9uOiBcIkJsb2cgcG9zdCByZWFkeSB0byBwdWJsaXNoXCIsXG4gIH0sXG4gIHtcbiAgICB0eXBlOiBcImMvYi9wXCIsXG4gICAgZGVzY3JpcHRpb246IFwiQmxvZyBwb3N0IHB1Ymxpc2hlZFwiLFxuICB9LFxuICB7XG4gICAgdHlwZTogXCJjL2IvaVwiLFxuICAgIGRlc2NyaXB0aW9uOiBcIkJsb2cgcG9zdCBzZXJpZXMgaW5kZXhcIixcbiAgfSxcbiAge1xuICAgIHR5cGU6IFwiYy9iL2FcIixcbiAgICBkZXNjcmlwdGlvbjogXCJCbG9nIHBvc3QgYWJhbmRvbmVkXCIsXG4gIH0sXG4gIHtcbiAgICB0eXBlOiBcImMvYi9vXCIsXG4gICAgZGVzY3JpcHRpb246IFwiQmxvZyBwb3N0IG91dGxpbmVkIChEZXByZWNhdGVkPylcIixcbiAgfSxcbiAge1xuICAgIHR5cGU6IFwiYy9iL2ZcIixcbiAgICBkZXNjcmlwdGlvbjogXCJCbG9nIHBvc3QgZmluZSB0dW5lZCAoRGVwcmVjYXRlZD8pXCIsXG4gIH0sXG4gIHtcbiAgICB0eXBlOiBcImMvdC9yXCIsXG4gICAgZGVzY3JpcHRpb246IFwiVGhyZWFkcyBwb3N0IHJlYWR5IHRvIHBvc3RcIixcbiAgfSxcbiAge1xuICAgIHR5cGU6IFwiYy90L3RcIixcbiAgICBkZXNjcmlwdGlvbjogXCJUaHJlYWRzIHBvc3QgdGhyZWFkcyBwdWJsaXNoZWRcIixcbiAgfSxcbiAge1xuICAgIHR5cGU6IFwiYy90L3BcIixcbiAgICBkZXNjcmlwdGlvbjogXCJUaHJlYWRzIHBvc3QgcHVibGlzaGVkXCIsXG4gIH0sXG4gIHtcbiAgICB0eXBlOiBcImMvdC9pXCIsXG4gICAgZGVzY3JpcHRpb246IFwiVGhyZWFkcyBwb3N0IHNlcmllcyBpbmRleFwiLFxuICB9LFxuICB7XG4gICAgdHlwZTogXCJjL3QvYVwiLFxuICAgIGRlc2NyaXB0aW9uOiBcIlRocmVhZHMgcG9zdCBhYmFuZG9uZWRcIixcbiAgfSxcbiAge1xuICAgIHR5cGU6IFwiYy94L2RcIixcbiAgICBkZXNjcmlwdGlvbjogXCJUd2l0dGVyIHBvc3QgZHJhZnRpbmdcIixcbiAgfSxcbiAge1xuICAgIHR5cGU6IFwiYy94L3JcIixcbiAgICBkZXNjcmlwdGlvbjogXCJUd2l0dGVyIHBvc3QgcmVhZHkgdG8gcHVibGlzaFwiLFxuICB9LFxuICB7XG4gICAgdHlwZTogXCJjL3gvcFwiLFxuICAgIGRlc2NyaXB0aW9uOiBcIlR3aXR0ZXIgcG9zdCBwdWJsaXNoZWRcIixcbiAgfSxcbiAge1xuICAgIHR5cGU6IFwiYS9uL3dcIixcbiAgICBkZXNjcmlwdGlvbjogXCJOIFdhaXRpbmcgVGFza1wiLFxuICB9LFxuICB7XG4gICAgdHlwZTogXCJhL24vZFwiLFxuICAgIGRlc2NyaXB0aW9uOiBcIk4gRG9uZSBUYXNrXCIsXG4gIH0sXG4gIHtcbiAgICB0eXBlOiBcImEvbi9hXCIsXG4gICAgZGVzY3JpcHRpb246IFwiTiBBcmNoaXZlIFRhc2tcIixcbiAgfSxcbiAge1xuICAgIHR5cGU6IFwiYS93L3dcIixcbiAgICBkZXNjcmlwdGlvbjogXCJXIFdhaXRpbmcgVGFza1wiLFxuICB9LFxuICB7XG4gICAgdHlwZTogXCJhL3cvZFwiLFxuICAgIGRlc2NyaXB0aW9uOiBcIlcgRG9uZSBUYXNrXCIsXG4gIH0sXG4gIHtcbiAgICB0eXBlOiBcImEvdy9hXCIsXG4gICAgZGVzY3JpcHRpb246IFwiVyBBcmNoaXZlIFRhc2tcIixcbiAgfSxcbl07XG5cbmV4cG9ydCBjbGFzcyBVcGRhdGVOb3RlVHlwZU1vZGFsIGV4dGVuZHMgRnV6enlTdWdnZXN0TW9kYWw8Tm90ZVR5cGU+IHtcblxuICBlZGl0b3I6IEVkaXRvclxuICBmaWxlOiBURmlsZVxuXG4gIGNvbnN0cnVjdG9yKGFwcDogQXBwLCBlZGl0b3I6IEVkaXRvciwgZmlsZTogVEZpbGUpXG4gIHtcbiAgICBzdXBlcihhcHApXG4gICAgdGhpcy5lZGl0b3IgPSBlZGl0b3JcbiAgICB0aGlzLmZpbGUgPSBmaWxlXG4gIH1cblxuICBnZXRJdGVtcygpOiBOb3RlVHlwZVtdIHtcbiAgICByZXR1cm4gQUxMX1RZUEVTO1xuICB9XG5cbiAgZ2V0SXRlbVRleHQobm90ZVR5cGU6IE5vdGVUeXBlKTogc3RyaW5nIHtcbiAgICByZXR1cm4gbm90ZVR5cGUudHlwZTtcbiAgfVxuXG4gIC8vIFJlbmRlcnMgZWFjaCBzdWdnZXN0aW9uIGl0ZW0uXG4gIHJlbmRlclN1Z2dlc3Rpb24oY2hvb3Nlbk5vdGVUeXBlTWF0Y2g6IEZ1enp5TWF0Y2g8Tm90ZVR5cGU+LCBlbDogSFRNTEVsZW1lbnQpIHtcbiAgICBjb25zdCBub3RlVHlwZSA9IGNob29zZW5Ob3RlVHlwZU1hdGNoLml0ZW1cbiAgICBlbC5jcmVhdGVFbChcImRpdlwiLCB7IHRleHQ6IG5vdGVUeXBlLnR5cGUgfSk7XG4gICAgZWwuY3JlYXRlRWwoXCJzbWFsbFwiLCB7IHRleHQ6IG5vdGVUeXBlLmRlc2NyaXB0aW9uIH0pO1xuICB9XG5cbiAgY29udGFpbnNUeXBlKGxpbmU6IFN0cmluZykgOiBCb29sZWFuIHtcbiAgICByZXR1cm4gQUxMX1RZUEVTLmZpbHRlcigobm90ZVR5cGUpID0+IGxpbmUuY29udGFpbnMobm90ZVR5cGUudHlwZSkpLmxlbmd0aCA+IDBcbiAgfVxuXG4gIGFkZEZyb250TWF0dGVyV2l0aFRhZyh2YWx1ZTogc3RyaW5nKSB7XG4gICAgY29uc3QgY3Vyc29yID0gdGhpcy5lZGl0b3IuZ2V0Q3Vyc29yKClcbiAgICBjb25zdCBvbGRMaW5lID0gY3Vyc29yLmxpbmVcbiAgICBjb25zdCBvbGRDaCA9IGN1cnNvci5jaFxuICAgIGNvbnN0IGFkZFRleHQgPSBgLS0tXFxudGFnOiAke3ZhbHVlfVxcbi0tLVxcblxcbiR7dGhpcy5lZGl0b3IuZ2V0VmFsdWUoKX1gXG4gICAgdGhpcy5lZGl0b3Iuc2V0VmFsdWUoYWRkVGV4dClcbiAgICBjdXJzb3IubGluZSA9IG9sZExpbmUgKyA0XG4gICAgY3Vyc29yLmNoID0gb2xkQ2hcbiAgICB0aGlzLmVkaXRvci5zZXRDdXJzb3IoY3Vyc29yKVxuICB9XG5cbiAgYWRkVGFnQXNzdW1pbmdIYXNGcm9udE1hdHRlcih2YWx1ZTogc3RyaW5nKSB7XG4gICAgY29uc3QgY3Vyc29yID0gdGhpcy5lZGl0b3IuZ2V0Q3Vyc29yKClcbiAgICBjb25zdCBvbGRMaW5lID0gY3Vyc29yLmxpbmVcbiAgICBjb25zdCBvbGRDaCA9IGN1cnNvci5jaFxuXG4gICAgbGV0IGZpcnN0TGluZUluZGV4ID0gMDtcbiAgICBjb25zdCBsaW5lQ291bnQgPSB0aGlzLmVkaXRvci5saW5lQ291bnQoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmVDb3VudDsgaSsrKSB7XG4gICAgICBpZiAodGhpcy5lZGl0b3IuZ2V0TGluZShpKS50cmltKCkgPT0gXCItLS1cIi50cmltKCkpIHtcbiAgICAgICAgZmlyc3RMaW5lSW5kZXggPSBpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGZpcnN0TGluZUluZGV4ID09IGxpbmVDb3VudCkge1xuICAgICAgbmV3IE5vdGljZShcIlNvbWV0aGluZyB3cm9uZyBoZXJlXCIpXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCB0ZXh0ID0gXCJcIlxuICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IGZpcnN0TGluZUluZGV4OyBpKyspIHtcbiAgICAgIHRleHQgPSB0ZXh0ICsgdGhpcy5lZGl0b3IuZ2V0TGluZShpKSArIFwiXFxuXCI7XG4gICAgfVxuICAgIHRleHQgPSB0ZXh0ICsgYHRhZzogJHt2YWx1ZX1cXG5gXG4gICAgZm9yIChsZXQgaSA9IGZpcnN0TGluZUluZGV4ICsgMTsgaSA8PSB0aGlzLmVkaXRvci5saW5lQ291bnQoKTsgaSsrKSB7XG4gICAgICB0ZXh0ID0gdGV4dCArIHRoaXMuZWRpdG9yLmdldExpbmUoaSkgKyBcIlxcblwiO1xuICAgIH1cblxuICAgIHRoaXMuZWRpdG9yLnNldFZhbHVlKHRleHQpXG4gICAgY3Vyc29yLmxpbmUgPSBvbGRMaW5lICsgKG9sZExpbmUgPD0gZmlyc3RMaW5lSW5kZXggPyAwIDogMSlcbiAgICBjdXJzb3IuY2ggPSBvbGRDaFxuICAgIHRoaXMuZWRpdG9yLnNldEN1cnNvcihjdXJzb3IpXG4gIH1cblxuICAvLyBQZXJmb3JtIGFjdGlvbiBvbiB0aGUgc2VsZWN0ZWQgc3VnZ2VzdGlvbi5cbiAgb25DaG9vc2VJdGVtKGNob29zZW5Ob3RlVHlwZTogTm90ZVR5cGUsIGV2dDogTW91c2VFdmVudCB8IEtleWJvYXJkRXZlbnQpIHtcbiAgICBpZiAoIWhhc0Zyb250TWF0dGVyKHRoaXMuZmlsZSkpIHtcbiAgICAgIHRoaXMuYWRkRnJvbnRNYXR0ZXJXaXRoVGFnKGNob29zZW5Ob3RlVHlwZS50eXBlKVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaGFzVGFncyh0aGlzLmZpbGUpKVxuICAgICAge1xuICAgICAgICBBTExfVFlQRVMuZm9yRWFjaCh0ID0+IHtcbiAgICAgICAgICByZW5hbWVUYWcodGhpcy5maWxlLCB0LnR5cGUsIGNob29zZW5Ob3RlVHlwZS50eXBlKVxuICAgICAgICAgIH0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBuZXcgTm90aWNlKFwiYWRkaW5nIHRhZyB0b2RvXCIpXG4gICAgICAgIC8vIG5ldyBGaWxlKGFwcCwgdGhpcy5maWxlLnBhdGgsIG51bGwsIDApLnJlcGxhY2VJbkZyb250TWF0dGVyO1xuXG4gICAgICAgIC8vIFRPRE8gYWRkIHRhZ3NcbiAgICAgICAgdGhpcy5hZGRUYWdBc3N1bWluZ0hhc0Zyb250TWF0dGVyKGNob29zZW5Ob3RlVHlwZS50eXBlKVxuICAgICAgfVxuICAgIH1cbiAgfVxufSIsICJpbXBvcnQge0FwcCwgTWFya2Rvd25WaWV3LCBOb3RpY2UsIFRBYnN0cmFjdEZpbGUsIFRGaWxlLCBwYXJzZUZyb250TWF0dGVyQWxpYXNlcywgcGFyc2VGcm9udE1hdHRlclRhZ3N9IGZyb20gXCJvYnNpZGlhblwiO1xuaW1wb3J0IHtUYWcsIFJlcGxhY2VtZW50fSBmcm9tIFwiLi9UYWdcIjtcbmltcG9ydCB7RmlsZX0gZnJvbSBcIi4vRmlsZVwiO1xuXG5leHBvcnQgZnVuY3Rpb24gaGFzRnJvbnRNYXR0ZXIoZmlsZTogVEZpbGUpIDogYm9vbGVhbiB7XG4gICAgbGV0IHsgZnJvbnRtYXR0ZXIgfSA9IGFwcC5tZXRhZGF0YUNhY2hlLmdldEZpbGVDYWNoZShmaWxlKSB8fCB7fTtcbiAgICByZXR1cm4gZnJvbnRtYXR0ZXIgIT0gbnVsbFxufVxuXG5leHBvcnQgZnVuY3Rpb24gaGFzVGFncyhmaWxlOiBURmlsZSkgOiBib29sZWFuIHtcbiAgICBsZXQgeyBmcm9udG1hdHRlciB9ID0gYXBwLm1ldGFkYXRhQ2FjaGUuZ2V0RmlsZUNhY2hlKGZpbGUpIHx8IHt9O1xuICAgIGNvbnN0IGZtdGFncyA9IChwYXJzZUZyb250TWF0dGVyVGFncyhmcm9udG1hdHRlcikgfHwgW10pO1xuICAgIGNvbnN0IGFsaWFzVGFncyA9IChwYXJzZUZyb250TWF0dGVyQWxpYXNlcyhmcm9udG1hdHRlcikgfHwgW10pLmZpbHRlcihUYWcuaXNUYWcpO1xuICAgIHJldHVybiAoZm10YWdzLmxlbmd0aCB8fCBhbGlhc1RhZ3MubGVuZ3RoKSA/IHRydWUgOiBmYWxzZVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmVuYW1lVGFnKGZpbGU6IFRGaWxlLCB0YWdOYW1lOiBzdHJpbmcsIG5ld05hbWU6c3RyaW5nKSA6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIGNvbnN0XG4gICAgICAgIG9sZFRhZyAgPSBuZXcgVGFnKHRhZ05hbWUpLFxuICAgICAgICBuZXdUYWcgID0gbmV3IFRhZyhuZXdOYW1lKSxcbiAgICAgICAgcmVwbGFjZSA9IG5ldyBSZXBsYWNlbWVudChvbGRUYWcsIG5ld1RhZylcblxuICAgIGNvbnN0IHRhcmdldCA9IGF3YWl0IGZpbmRUYXJnZXRzKG9sZFRhZywgZmlsZSk7XG4gICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBhd2FpdCB0YXJnZXQucmVuYW1lZChyZXBsYWNlKVxuICAgIHJldHVybiB0cnVlXG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBmaW5kVGFyZ2V0cyh0YWc6IFRhZywgZmlsZTogVEZpbGUpIHtcbiAgICBsZXQgeyBmcm9udG1hdHRlciwgdGFncyB9ID0gYXBwLm1ldGFkYXRhQ2FjaGUuZ2V0RmlsZUNhY2hlKGZpbGUpIHx8IHt9O1xuICAgIGNvbnN0IGZtdGFncyA9IChwYXJzZUZyb250TWF0dGVyVGFncyhmcm9udG1hdHRlcikgfHwgW10pLmZpbHRlcih0YWcubWF0Y2hlcyk7XG4gICAgY29uc3QgYWxpYXNUYWdzID0gKHBhcnNlRnJvbnRNYXR0ZXJBbGlhc2VzKGZyb250bWF0dGVyKSB8fCBbXSkuZmlsdGVyKFRhZy5pc1RhZykuZmlsdGVyKHRhZy5tYXRjaGVzKTtcbiAgICBpZiAoZm10YWdzLmxlbmd0aCB8fCBhbGlhc1RhZ3MubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBuZXcgRmlsZShhcHAsIGZpbGUucGF0aCwgdGFncywgZm10YWdzLmxlbmd0aCArIGFsaWFzVGFncy5sZW5ndGgpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlbmFtZUJsb2dUaXRsZShhcHAgOiBBcHAsIHBhdGg6IHN0cmluZywgdmlldzogTWFya2Rvd25WaWV3KSA6IFByb21pc2U8dm9pZD4ge1xuICAgIGxldCBtb21lbnQgPSByZXF1aXJlKCdtb21lbnQnKTtcbiAgICBjb25zdCBkYXRlWVlZWU1NREQgPSBtb21lbnQoKS5mb3JtYXQoJ1lZWVlNTUREJyk7XG4gICAgbGV0IHJlbmFtZWRQYXRoID0gXCJcIlxuICAgIGlmIChwYXRoLm1hdGNoKC9eLlxcL0Jsb2cgXFxkXFxkXFxkXFxkXFxkXFxkXFxkXFxkLykpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG4gICAgfSBlbHNlIGlmIChwYXRoLm1hdGNoKC9eLlxcL2Jsb2cgXFxkXFxkXFxkXFxkXFxkXFxkXFxkXFxkLykpIHtcbiAgICAgICAgbmV3IE5vdGljZShcInN0YXJ0IHdpdGggYmxvZyB3aXRoIGRhdGUsIHJlbmFtaW5nIGJsb2cgdG8gQmxvZ1wiKVxuICAgICAgICByZW5hbWVkUGF0aCA9IHBhdGgucmVwbGFjZSgvXiguXFwvKWJsb2cgLywgYCQxQmxvZyBgKVxuICAgICAgICByZXR1cm4gcmVuYW1lRmlsZShhcHAsIHZpZXcuZmlsZSwgcmVuYW1lZFBhdGgpO1xuICAgIH0gZWxzZSBpZiAocGF0aC5tYXRjaCgvXi5cXC9CbG9nIC8pKSB7XG4gICAgICAgIG5ldyBOb3RpY2UoXCJzdGFydHMgd2l0aCBCbG9nIGJ1dCBubyBkYXRlLCBhZGRpbmcgZGF0ZVwiKVxuICAgICAgICByZW5hbWVkUGF0aCA9IHBhdGgucmVwbGFjZSgvXiguXFwvQmxvZyApLywgYCQxJHtkYXRlWVlZWU1NRER9IGApXG4gICAgICAgIHJldHVybiByZW5hbWVGaWxlKGFwcCwgdmlldy5maWxlLCByZW5hbWVkUGF0aCk7XG4gICAgfSBlbHNlIGlmIChwYXRoLm1hdGNoKC9eLlxcL2Jsb2cgLykpIHtcbiAgICAgICAgbmV3IE5vdGljZShcInN0YXJ0cyB3aXRoIGJsb2cgYnV0IG5vIGRhdGUsIGFkZGluZyBkYXRlXCIpXG4gICAgICAgIHJlbmFtZWRQYXRoID0gcGF0aC5yZXBsYWNlKC9eKC5cXC8pYmxvZyAvLCBgJDFCbG9nICR7ZGF0ZVlZWVlNTUREfSBgKVxuICAgICAgICByZXR1cm4gcmVuYW1lRmlsZShhcHAsIHZpZXcuZmlsZSwgcmVuYW1lZFBhdGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG5ldyBOb3RpY2UoXCJzdGFydHMgd2l0aG91dCBibG9nLCBhZGRpbmcgQmxvZyArIGRhdGVcIilcbiAgICAgICAgcmVuYW1lZFBhdGggPSBwYXRoLnJlcGxhY2UoL14oLlxcLykvLCBgJDFCbG9nICR7ZGF0ZVlZWVlNTUREfSBgKVxuICAgICAgICByZXR1cm4gcmVuYW1lRmlsZShhcHAsIHZpZXcuZmlsZSwgcmVuYW1lZFBhdGgpO1xuICAgIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gcmVuYW1lRmlsZShhcHAgOiBBcHAsIGZpbGUgOiBUQWJzdHJhY3RGaWxlLCBuZXdQYXRoOiBzdHJpbmcpIHtcbiAgICBhcHAuZmlsZU1hbmFnZXIucmVuYW1lRmlsZShmaWxlLCBuZXdQYXRoKVxufVxuXG5cbiIsICJjb25zdCB0YWdCb2R5ID0gL14jW15cXHUyMDAwLVxcdTIwNkZcXHUyRTAwLVxcdTJFN0YnIVwiIyQlJigpKissLjo7PD0+P0BeYHt8fX5cXFtcXF1cXFxcXFxzXSskLztcblxuZXhwb3J0IGNsYXNzIFRhZyB7XG4gICAgdGFnOiBhbnk7XG4gICAgY2Fub25pY2FsX3ByZWZpeDogc3RyaW5nO1xuICAgIGNhbm9uaWNhbDogc3RyaW5nO1xuICAgIG5hbWU6IGFueTtcbiAgICBtYXRjaGVzOiAodGV4dDogYW55KSA9PiBhbnk7XG4gICAgY29uc3RydWN0b3IobmFtZTogYW55KSB7XG4gICAgICAgIGNvbnN0XG4gICAgICAgICAgICBoYXNoZWQgPSB0aGlzLnRhZyA9IFRhZy50b1RhZyhuYW1lKSxcbiAgICAgICAgICAgIGNhbm9uaWNhbCA9IHRoaXMuY2Fub25pY2FsID0gaGFzaGVkLnRvTG93ZXJDYXNlKCksXG4gICAgICAgICAgICBjYW5vbmljYWxfcHJlZml4ID0gdGhpcy5jYW5vbmljYWxfcHJlZml4ID0gY2Fub25pY2FsICsgXCIvXCI7XG4gICAgICAgIHRoaXMubmFtZSA9IGhhc2hlZC5zbGljZSgxKTtcbiAgICAgICAgdGhpcy5tYXRjaGVzID0gZnVuY3Rpb24gKHRleHQpIHtcbiAgICAgICAgICAgIHRleHQgPSB0ZXh0LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICByZXR1cm4gdGV4dCA9PSBjYW5vbmljYWwgfHwgdGV4dC5zdGFydHNXaXRoKGNhbm9uaWNhbF9wcmVmaXgpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICB0b1N0cmluZygpIHsgcmV0dXJuIHRoaXMudGFnOyB9XG5cbiAgICBzdGF0aWMgaXNUYWcoczogc3RyaW5nKSB7IHJldHVybiB0YWdCb2R5LnRlc3Qocyk7IH1cblxuICAgIHN0YXRpYyB0b1RhZyhuYW1lOiBzdHJpbmcpIHtcbiAgICAgICAgd2hpbGUgKG5hbWUuc3RhcnRzV2l0aChcIiMjXCIpKSBuYW1lID0gbmFtZS5zbGljZSgxKTtcbiAgICAgICAgcmV0dXJuIG5hbWUuc3RhcnRzV2l0aChcIiNcIikgPyBuYW1lIDogXCIjXCIrbmFtZTtcbiAgICB9XG5cbiAgICBzdGF0aWMgY2Fub25pY2FsKG5hbWU6IGFueSkge1xuICAgICAgICByZXR1cm4gVGFnLnRvVGFnKG5hbWUpLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxufVxuXG5leHBvcnQgY2xhc3MgUmVwbGFjZW1lbnQge1xuICAgIGluU3RyaW5nOiAodGV4dDogYW55LCBwb3M/OiBudW1iZXIpID0+IGFueTtcbiAgICBpbkFycmF5OiAodGFnczogYW55LCBza2lwT2RkOiBhbnksIGlzQWxpYXM6IGFueSkgPT4gYW55O1xuICAgIHdpbGxNZXJnZVRhZ3M6ICh0YWdOYW1lczogYW55KSA9PiBUYWdbXSB8IHVuZGVmaW5lZDtcblxuICAgIGNvbnN0cnVjdG9yKGZyb21UYWc6IFRhZywgdG9UYWc6IFRhZykge1xuICAgICAgICBjb25zdCBjYWNoZSA9ICBPYmplY3QuYXNzaWduKFxuICAgICAgICAgICAgT2JqZWN0LmNyZWF0ZShudWxsKSwge1xuICAgICAgICAgICAgICAgIFtmcm9tVGFnLnRhZ106ICB0b1RhZy50YWcsXG4gICAgICAgICAgICAgICAgW2Zyb21UYWcubmFtZV06IHRvVGFnLm5hbWUsXG4gICAgICAgICAgICB9XG4gICAgICAgICk7XG5cbiAgICAgICAgdGhpcy5pblN0cmluZyA9IGZ1bmN0aW9uKHRleHQsIHBvcyA9IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0ZXh0LnNsaWNlKDAsIHBvcykgKyB0b1RhZy50YWcgKyB0ZXh0LnNsaWNlKHBvcyArIGZyb21UYWcudGFnLmxlbmd0aCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmluQXJyYXkgPSAodGFncywgc2tpcE9kZCwgaXNBbGlhcykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRhZ3MubWFwKCh0OiBzdHJpbmcsIGk6IG51bWJlcikgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChza2lwT2RkICYmIChpICYgMSkpIHJldHVybiB0OyAgIC8vIGxlYXZlIG9kZCBlbnRyaWVzIChzZXBhcmF0b3JzKSBhbG9uZVxuICAgICAgICAgICAgICAgIC8vIE9ic2lkaWFuIGFsbG93cyBzcGFjZXMgYXMgc2VwYXJhdG9ycyB3aXRoaW4gYXJyYXkgZWxlbWVudHNcbiAgICAgICAgICAgICAgICBpZiAoIXQpIHJldHVybiB0O1xuICAgICAgICAgICAgICAgIC8vIFNraXAgbm9uLXRhZyBwYXJ0c1xuICAgICAgICAgICAgICAgIGlmIChpc0FsaWFzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdC5zdGFydHNXaXRoKFwiI1wiKSB8fCAhVGFnLmlzVGFnKHQpKSByZXR1cm4gdDtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKC9bICxcXG5dLy50ZXN0KHQpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHJldHVybiB0aGlzLmluQXJyYXkodC5zcGxpdCgvKFssIFxcbl0rKS8pLCB0cnVlKS5qb2luKFwiXCIpOyAvLyBub3Qgc3VyZVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pbkFycmF5KHQuc3BsaXQoLyhbLCBcXG5dKykvKSwgdHJ1ZSwgaXNBbGlhcykuam9pbihcIlwiKTsgLy8gbm90IHN1cmVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNhY2hlW3RdKSByZXR1cm4gY2FjaGVbdF07XG4gICAgICAgICAgICAgICAgY29uc3QgbGMgPSB0LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgaWYgKGNhY2hlW2xjXSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FjaGVbdF0gPSBjYWNoZVtsY107XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChsYy5zdGFydHNXaXRoKGZyb21UYWcuY2Fub25pY2FsX3ByZWZpeCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhY2hlW3RdID0gY2FjaGVbbGNdID0gdGhpcy5pblN0cmluZyh0KTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKChcIiNcIiArIGxjKS5zdGFydHNXaXRoKGZyb21UYWcuY2Fub25pY2FsX3ByZWZpeCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhY2hlW3RdID0gY2FjaGVbbGNdID0gdGhpcy5pblN0cmluZyhcIiNcIiArIHQpLnNsaWNlKDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gY2FjaGVbdF0gPSBjYWNoZVtsY10gPSB0O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy53aWxsTWVyZ2VUYWdzID0gZnVuY3Rpb24gKHRhZ05hbWVzKSB7XG4gICAgICAgICAgICAvLyBSZW5hbWluZyB0byBjaGFuZ2UgY2FzZSBkb2Vzbid0IGxvc2UgaW5mbywgc28gaWdub3JlIGl0XG4gICAgICAgICAgICBpZiAoZnJvbVRhZy5jYW5vbmljYWwgPT09IHRvVGFnLmNhbm9uaWNhbCkgcmV0dXJuO1xuXG4gICAgICAgICAgICBjb25zdCBleGlzdGluZyA9IG5ldyBTZXQodGFnTmFtZXMubWFwKChzOiBzdHJpbmcpID0+IHMudG9Mb3dlckNhc2UoKSkpO1xuXG4gICAgICAgICAgICBmb3IgKGNvbnN0IHRhZ05hbWUgb2YgdGFnTmFtZXMuZmlsdGVyKGZyb21UYWcubWF0Y2hlcykpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGFuZ2VkID0gdGhpcy5pblN0cmluZyh0YWdOYW1lKTtcbiAgICAgICAgICAgICAgICBpZiAoZXhpc3RpbmcuaGFzKGNoYW5nZWQudG9Mb3dlckNhc2UoKSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbbmV3IFRhZyh0YWdOYW1lKSwgbmV3IFRhZyhjaGFuZ2VkKV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuICAgIH1cbn1cblxuXG4iLCAiaW1wb3J0IHsgTm90aWNlIH0gZnJvbSBcIm9ic2lkaWFuXCI7XG5pbXBvcnQgeyBDU1QsIHBhcnNlRG9jdW1lbnQgfSBmcm9tIFwieWFtbFwiO1xuaW1wb3J0IHsgUmVwbGFjZW1lbnQgfSBmcm9tIFwiLi9UYWdcIjtcblxuZXhwb3J0IGNsYXNzIEZpbGUge1xuICAgIGFwcDogYW55O1xuICAgIGZpbGVuYW1lOiBhbnk7XG4gICAgYmFzZW5hbWU6IGFueTtcbiAgICB0YWdQb3NpdGlvbnM6IGFueTtcbiAgICBoYXNGcm9udE1hdHRlcjogYm9vbGVhbjtcblxuICAgIGNvbnN0cnVjdG9yKGFwcDogYW55LCBmaWxlbmFtZTogc3RyaW5nLCB0YWdQb3NpdGlvbnM6IGFueSwgaGFzRnJvbnRNYXR0ZXI6IG51bWJlcikge1xuICAgICAgICB0aGlzLmFwcCA9IGFwcDtcbiAgICAgICAgdGhpcy5maWxlbmFtZSA9IGZpbGVuYW1lO1xuICAgICAgICB0aGlzLmJhc2VuYW1lID0gZmlsZW5hbWUuc3BsaXQoXCIvXCIpLnBvcCgpO1xuICAgICAgICB0aGlzLnRhZ1Bvc2l0aW9ucyA9IHRhZ1Bvc2l0aW9ucztcbiAgICAgICAgdGhpcy5oYXNGcm9udE1hdHRlciA9ICEhaGFzRnJvbnRNYXR0ZXI7XG4gICAgfVxuXG4gICAgLyoqIEBwYXJhbSB7UmVwbGFjZW1lbnR9IHJlcGxhY2UgKi9cbiAgICBhc3luYyByZW5hbWVkKHJlcGxhY2UgOiBSZXBsYWNlbWVudCkge1xuICAgICAgICBjb25zdCBmaWxlID0gdGhpcy5hcHAudmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKHRoaXMuZmlsZW5hbWUpO1xuICAgICAgICBjb25zdCBvcmlnaW5hbCA9IGF3YWl0IHRoaXMuYXBwLnZhdWx0LnJlYWQoZmlsZSk7XG4gICAgICAgIGxldCB0ZXh0ID0gb3JpZ2luYWw7XG5cbiAgICAgICAgaWYgKHRoaXMuaGFzRnJvbnRNYXR0ZXIpIHtcbiAgICAgICAgICAgIHRleHQgPSB0aGlzLnJlcGxhY2VJbkZyb250TWF0dGVyKHRleHQsIHJlcGxhY2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRleHQgIT09IG9yaWdpbmFsKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmFwcC52YXVsdC5tb2RpZnkoZmlsZSwgdGV4dCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKiBAcGFyYW0ge1JlcGxhY2VtZW50fSByZXBsYWNlICovXG4gICAgcmVwbGFjZUluRnJvbnRNYXR0ZXIodGV4dDogeyBzcGxpdDogKGFyZzA6IFJlZ0V4cCwgYXJnMTogbnVtYmVyKSA9PiBbYW55LCBhbnldOyByZXBsYWNlOiAoYXJnMDogYW55LCBhcmcxOiBhbnkpID0+IGFueTsgfSwgcmVwbGFjZTogeyBpbkFycmF5OiAoYXJnMDogYW55W10sIGFyZzE6IGJvb2xlYW4sIGFyZzI6IGFueSkgPT4gYW55W107IH0pIHtcbiAgICAgICAgY29uc3QgW2VtcHR5LCBmcm9udE1hdHRlcl0gPSB0ZXh0LnNwbGl0KC9eLS0tXFxyPyRcXG4/L20sIDIpO1xuXG4gICAgICAgIC8vIENoZWNrIGZvciB2YWxpZCwgbm9uLWVtcHR5LCBwcm9wZXJseSB0ZXJtaW5hdGVkIGZyb250IG1hdHRlclxuICAgICAgICBpZiAoZW1wdHkudHJpbSgpICE9PSBcIlwiIHx8ICFmcm9udE1hdHRlci50cmltKCkgfHwgIWZyb250TWF0dGVyLmVuZHNXaXRoKFwiXFxuXCIpKVxuICAgICAgICAgICAgcmV0dXJuIHRleHQ7XG5cbiAgICAgICAgY29uc3QgcGFyc2VkID0gcGFyc2VEb2N1bWVudChmcm9udE1hdHRlciwge2tlZXBTb3VyY2VUb2tlbnM6IHRydWV9KTtcbiAgICAgICAgaWYgKHBhcnNlZC5lcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCBlcnJvciA9IGBZQU1MIGlzc3VlIHdpdGggJHt0aGlzLmZpbGVuYW1lfTogJHtwYXJzZWQuZXJyb3JzWzBdfWA7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yKTsgbmV3IE5vdGljZShlcnJvciArIFwiOyBza2lwcGluZyBmcm9udG1hdHRlclwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBjaGFuZ2VkID0gZmFsc2UsIGpzb24gPSBwYXJzZWQudG9KU09OKCk7XG5cbiAgICAgICAgZnVuY3Rpb24gc2V0SW5Ob2RlKG5vZGU6IHsgc3JjVG9rZW46IGFueTsgdmFsdWU6IGFueTsgfSwgdmFsdWU6IGFueSwgYWZ0ZXJLZXk9ZmFsc2UpIHtcbiAgICAgICAgICAgIENTVC5zZXRTY2FsYXJWYWx1ZShub2RlLnNyY1Rva2VuLCB2YWx1ZSwge2FmdGVyS2V5fSk7XG4gICAgICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIG5vZGUudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHByb2Nlc3NGaWVsZChwcm9wOiBzdHJpbmcgfCBudW1iZXIsIGlzQWxpYXM6IGJvb2xlYW4pIHtcbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBwYXJzZWQuZ2V0KHByb3AsIHRydWUpO1xuICAgICAgICAgICAgaWYgKCFub2RlKSByZXR1cm47XG4gICAgICAgICAgICBjb25zdCBmaWVsZCA9IGpzb25bcHJvcF07XG4gICAgICAgICAgICBpZiAoIWZpZWxkIHx8ICFmaWVsZC5sZW5ndGgpIHJldHVybjtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZmllbGQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJ0cyA9IGZpZWxkLnNwbGl0KGlzQWxpYXMgPyAvKF5cXHMrfFxccyosXFxzKnxcXHMrJCkvIDogLyhbXFxzLF0rKS8pO1xuICAgICAgICAgICAgICAgIGNvbnN0IGFmdGVyID0gcmVwbGFjZS5pbkFycmF5KHBhcnRzLCB0cnVlLCBpc0FsaWFzKS5qb2luKFwiXCIpO1xuICAgICAgICAgICAgICAgIGlmIChmaWVsZCAhPSBhZnRlcikgc2V0SW5Ob2RlKG5vZGUsIGFmdGVyLCB0cnVlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShmaWVsZCkpIHtcbiAgICAgICAgICAgICAgICByZXBsYWNlLmluQXJyYXkoZmllbGQsIGZhbHNlLCBpc0FsaWFzKS5mb3JFYWNoKCh2OiBhbnksIGk6IG51bWJlcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmllbGRbaV0gIT09IHYpIHNldEluTm9kZShub2RlLmdldChpLCB0cnVlKSwgdilcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoY29uc3Qge2tleToge3ZhbHVlOnByb3B9fSBvZiBwYXJzZWQuY29udGVudHMuaXRlbXMpIHtcbiAgICAgICAgICAgIGlmICgvXnRhZ3M/JC9pLnRlc3QocHJvcCkpIHtcbiAgICAgICAgICAgICAgICBwcm9jZXNzRmllbGQocHJvcCwgZmFsc2UpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICgvXmFsaWFzKGVzKT8kL2kudGVzdChwcm9wKSkge1xuICAgICAgICAgICAgICAgIHByb2Nlc3NGaWVsZChwcm9wLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2hhbmdlZCA/IHRleHQucmVwbGFjZShmcm9udE1hdHRlciwgQ1NULnN0cmluZ2lmeShwYXJzZWQuY29udGVudHMuc3JjVG9rZW4pKSA6IHRleHQ7XG4gICAgfVxufVxuIiwgImNvbnN0IEFMSUFTID0gU3ltYm9sLmZvcigneWFtbC5hbGlhcycpO1xuY29uc3QgRE9DID0gU3ltYm9sLmZvcigneWFtbC5kb2N1bWVudCcpO1xuY29uc3QgTUFQID0gU3ltYm9sLmZvcigneWFtbC5tYXAnKTtcbmNvbnN0IFBBSVIgPSBTeW1ib2wuZm9yKCd5YW1sLnBhaXInKTtcbmNvbnN0IFNDQUxBUiA9IFN5bWJvbC5mb3IoJ3lhbWwuc2NhbGFyJyk7XG5jb25zdCBTRVEgPSBTeW1ib2wuZm9yKCd5YW1sLnNlcScpO1xuY29uc3QgTk9ERV9UWVBFID0gU3ltYm9sLmZvcigneWFtbC5ub2RlLnR5cGUnKTtcbmNvbnN0IGlzQWxpYXMgPSAobm9kZSkgPT4gISFub2RlICYmIHR5cGVvZiBub2RlID09PSAnb2JqZWN0JyAmJiBub2RlW05PREVfVFlQRV0gPT09IEFMSUFTO1xuY29uc3QgaXNEb2N1bWVudCA9IChub2RlKSA9PiAhIW5vZGUgJiYgdHlwZW9mIG5vZGUgPT09ICdvYmplY3QnICYmIG5vZGVbTk9ERV9UWVBFXSA9PT0gRE9DO1xuY29uc3QgaXNNYXAgPSAobm9kZSkgPT4gISFub2RlICYmIHR5cGVvZiBub2RlID09PSAnb2JqZWN0JyAmJiBub2RlW05PREVfVFlQRV0gPT09IE1BUDtcbmNvbnN0IGlzUGFpciA9IChub2RlKSA9PiAhIW5vZGUgJiYgdHlwZW9mIG5vZGUgPT09ICdvYmplY3QnICYmIG5vZGVbTk9ERV9UWVBFXSA9PT0gUEFJUjtcbmNvbnN0IGlzU2NhbGFyID0gKG5vZGUpID0+ICEhbm9kZSAmJiB0eXBlb2Ygbm9kZSA9PT0gJ29iamVjdCcgJiYgbm9kZVtOT0RFX1RZUEVdID09PSBTQ0FMQVI7XG5jb25zdCBpc1NlcSA9IChub2RlKSA9PiAhIW5vZGUgJiYgdHlwZW9mIG5vZGUgPT09ICdvYmplY3QnICYmIG5vZGVbTk9ERV9UWVBFXSA9PT0gU0VRO1xuZnVuY3Rpb24gaXNDb2xsZWN0aW9uKG5vZGUpIHtcbiAgICBpZiAobm9kZSAmJiB0eXBlb2Ygbm9kZSA9PT0gJ29iamVjdCcpXG4gICAgICAgIHN3aXRjaCAobm9kZVtOT0RFX1RZUEVdKSB7XG4gICAgICAgICAgICBjYXNlIE1BUDpcbiAgICAgICAgICAgIGNhc2UgU0VROlxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gaXNOb2RlKG5vZGUpIHtcbiAgICBpZiAobm9kZSAmJiB0eXBlb2Ygbm9kZSA9PT0gJ29iamVjdCcpXG4gICAgICAgIHN3aXRjaCAobm9kZVtOT0RFX1RZUEVdKSB7XG4gICAgICAgICAgICBjYXNlIEFMSUFTOlxuICAgICAgICAgICAgY2FzZSBNQVA6XG4gICAgICAgICAgICBjYXNlIFNDQUxBUjpcbiAgICAgICAgICAgIGNhc2UgU0VROlxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuY29uc3QgaGFzQW5jaG9yID0gKG5vZGUpID0+IChpc1NjYWxhcihub2RlKSB8fCBpc0NvbGxlY3Rpb24obm9kZSkpICYmICEhbm9kZS5hbmNob3I7XG5jbGFzcyBOb2RlQmFzZSB7XG4gICAgY29uc3RydWN0b3IodHlwZSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgTk9ERV9UWVBFLCB7IHZhbHVlOiB0eXBlIH0pO1xuICAgIH1cbiAgICAvKiogQ3JlYXRlIGEgY29weSBvZiB0aGlzIG5vZGUuICAqL1xuICAgIGNsb25lKCkge1xuICAgICAgICBjb25zdCBjb3B5ID0gT2JqZWN0LmNyZWF0ZShPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcyksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHRoaXMpKTtcbiAgICAgICAgaWYgKHRoaXMucmFuZ2UpXG4gICAgICAgICAgICBjb3B5LnJhbmdlID0gdGhpcy5yYW5nZS5zbGljZSgpO1xuICAgICAgICByZXR1cm4gY29weTtcbiAgICB9XG59XG5cbmV4cG9ydCB7IEFMSUFTLCBET0MsIE1BUCwgTk9ERV9UWVBFLCBOb2RlQmFzZSwgUEFJUiwgU0NBTEFSLCBTRVEsIGhhc0FuY2hvciwgaXNBbGlhcywgaXNDb2xsZWN0aW9uLCBpc0RvY3VtZW50LCBpc01hcCwgaXNOb2RlLCBpc1BhaXIsIGlzU2NhbGFyLCBpc1NlcSB9O1xuIiwgImltcG9ydCB7IGlzRG9jdW1lbnQsIGlzTWFwLCBpc1NlcSwgaXNQYWlyLCBpc1NjYWxhciwgaXNBbGlhcywgaXNOb2RlLCBpc0NvbGxlY3Rpb24gfSBmcm9tICcuL25vZGVzL05vZGUuanMnO1xuXG5jb25zdCBCUkVBSyA9IFN5bWJvbCgnYnJlYWsgdmlzaXQnKTtcbmNvbnN0IFNLSVAgPSBTeW1ib2woJ3NraXAgY2hpbGRyZW4nKTtcbmNvbnN0IFJFTU9WRSA9IFN5bWJvbCgncmVtb3ZlIG5vZGUnKTtcbi8qKlxuICogQXBwbHkgYSB2aXNpdG9yIHRvIGFuIEFTVCBub2RlIG9yIGRvY3VtZW50LlxuICpcbiAqIFdhbGtzIHRocm91Z2ggdGhlIHRyZWUgKGRlcHRoLWZpcnN0KSBzdGFydGluZyBmcm9tIGBub2RlYCwgY2FsbGluZyBhXG4gKiBgdmlzaXRvcmAgZnVuY3Rpb24gd2l0aCB0aHJlZSBhcmd1bWVudHM6XG4gKiAgIC0gYGtleWA6IEZvciBzZXF1ZW5jZSB2YWx1ZXMgYW5kIG1hcCBgUGFpcmAsIHRoZSBub2RlJ3MgaW5kZXggaW4gdGhlXG4gKiAgICAgY29sbGVjdGlvbi4gV2l0aGluIGEgYFBhaXJgLCBgJ2tleSdgIG9yIGAndmFsdWUnYCwgY29ycmVzcG9uZGluZ2x5LlxuICogICAgIGBudWxsYCBmb3IgdGhlIHJvb3Qgbm9kZS5cbiAqICAgLSBgbm9kZWA6IFRoZSBjdXJyZW50IG5vZGUuXG4gKiAgIC0gYHBhdGhgOiBUaGUgYW5jZXN0cnkgb2YgdGhlIGN1cnJlbnQgbm9kZS5cbiAqXG4gKiBUaGUgcmV0dXJuIHZhbHVlIG9mIHRoZSB2aXNpdG9yIG1heSBiZSB1c2VkIHRvIGNvbnRyb2wgdGhlIHRyYXZlcnNhbDpcbiAqICAgLSBgdW5kZWZpbmVkYCAoZGVmYXVsdCk6IERvIG5vdGhpbmcgYW5kIGNvbnRpbnVlXG4gKiAgIC0gYHZpc2l0LlNLSVBgOiBEbyBub3QgdmlzaXQgdGhlIGNoaWxkcmVuIG9mIHRoaXMgbm9kZSwgY29udGludWUgd2l0aCBuZXh0XG4gKiAgICAgc2libGluZ1xuICogICAtIGB2aXNpdC5CUkVBS2A6IFRlcm1pbmF0ZSB0cmF2ZXJzYWwgY29tcGxldGVseVxuICogICAtIGB2aXNpdC5SRU1PVkVgOiBSZW1vdmUgdGhlIGN1cnJlbnQgbm9kZSwgdGhlbiBjb250aW51ZSB3aXRoIHRoZSBuZXh0IG9uZVxuICogICAtIGBOb2RlYDogUmVwbGFjZSB0aGUgY3VycmVudCBub2RlLCB0aGVuIGNvbnRpbnVlIGJ5IHZpc2l0aW5nIGl0XG4gKiAgIC0gYG51bWJlcmA6IFdoaWxlIGl0ZXJhdGluZyB0aGUgaXRlbXMgb2YgYSBzZXF1ZW5jZSBvciBtYXAsIHNldCB0aGUgaW5kZXhcbiAqICAgICBvZiB0aGUgbmV4dCBzdGVwLiBUaGlzIGlzIHVzZWZ1bCBlc3BlY2lhbGx5IGlmIHRoZSBpbmRleCBvZiB0aGUgY3VycmVudFxuICogICAgIG5vZGUgaGFzIGNoYW5nZWQuXG4gKlxuICogSWYgYHZpc2l0b3JgIGlzIGEgc2luZ2xlIGZ1bmN0aW9uLCBpdCB3aWxsIGJlIGNhbGxlZCB3aXRoIGFsbCB2YWx1ZXNcbiAqIGVuY291bnRlcmVkIGluIHRoZSB0cmVlLCBpbmNsdWRpbmcgZS5nLiBgbnVsbGAgdmFsdWVzLiBBbHRlcm5hdGl2ZWx5LFxuICogc2VwYXJhdGUgdmlzaXRvciBmdW5jdGlvbnMgbWF5IGJlIGRlZmluZWQgZm9yIGVhY2ggYE1hcGAsIGBQYWlyYCwgYFNlcWAsXG4gKiBgQWxpYXNgIGFuZCBgU2NhbGFyYCBub2RlLiBUbyBkZWZpbmUgdGhlIHNhbWUgdmlzaXRvciBmdW5jdGlvbiBmb3IgbW9yZSB0aGFuXG4gKiBvbmUgbm9kZSB0eXBlLCB1c2UgdGhlIGBDb2xsZWN0aW9uYCAobWFwIGFuZCBzZXEpLCBgVmFsdWVgIChtYXAsIHNlcSAmIHNjYWxhcilcbiAqIGFuZCBgTm9kZWAgKGFsaWFzLCBtYXAsIHNlcSAmIHNjYWxhcikgdGFyZ2V0cy4gT2YgYWxsIHRoZXNlLCBvbmx5IHRoZSBtb3N0XG4gKiBzcGVjaWZpYyBkZWZpbmVkIG9uZSB3aWxsIGJlIHVzZWQgZm9yIGVhY2ggbm9kZS5cbiAqL1xuZnVuY3Rpb24gdmlzaXQobm9kZSwgdmlzaXRvcikge1xuICAgIGlmICh0eXBlb2YgdmlzaXRvciA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgKHZpc2l0b3IuQ29sbGVjdGlvbiB8fCB2aXNpdG9yLk5vZGUgfHwgdmlzaXRvci5WYWx1ZSkpIHtcbiAgICAgICAgdmlzaXRvciA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgQWxpYXM6IHZpc2l0b3IuTm9kZSxcbiAgICAgICAgICAgIE1hcDogdmlzaXRvci5Ob2RlLFxuICAgICAgICAgICAgU2NhbGFyOiB2aXNpdG9yLk5vZGUsXG4gICAgICAgICAgICBTZXE6IHZpc2l0b3IuTm9kZVxuICAgICAgICB9LCB2aXNpdG9yLlZhbHVlICYmIHtcbiAgICAgICAgICAgIE1hcDogdmlzaXRvci5WYWx1ZSxcbiAgICAgICAgICAgIFNjYWxhcjogdmlzaXRvci5WYWx1ZSxcbiAgICAgICAgICAgIFNlcTogdmlzaXRvci5WYWx1ZVxuICAgICAgICB9LCB2aXNpdG9yLkNvbGxlY3Rpb24gJiYge1xuICAgICAgICAgICAgTWFwOiB2aXNpdG9yLkNvbGxlY3Rpb24sXG4gICAgICAgICAgICBTZXE6IHZpc2l0b3IuQ29sbGVjdGlvblxuICAgICAgICB9LCB2aXNpdG9yKTtcbiAgICB9XG4gICAgaWYgKGlzRG9jdW1lbnQobm9kZSkpIHtcbiAgICAgICAgY29uc3QgY2QgPSBfdmlzaXQobnVsbCwgbm9kZS5jb250ZW50cywgdmlzaXRvciwgT2JqZWN0LmZyZWV6ZShbbm9kZV0pKTtcbiAgICAgICAgaWYgKGNkID09PSBSRU1PVkUpXG4gICAgICAgICAgICBub2RlLmNvbnRlbnRzID0gbnVsbDtcbiAgICB9XG4gICAgZWxzZVxuICAgICAgICBfdmlzaXQobnVsbCwgbm9kZSwgdmlzaXRvciwgT2JqZWN0LmZyZWV6ZShbXSkpO1xufVxuLy8gV2l0aG91dCB0aGUgYGFzIHN5bWJvbGAgY2FzdHMsIFRTIGRlY2xhcmVzIHRoZXNlIGluIHRoZSBgdmlzaXRgXG4vLyBuYW1lc3BhY2UgdXNpbmcgYHZhcmAsIGJ1dCB0aGVuIGNvbXBsYWlucyBhYm91dCB0aGF0IGJlY2F1c2Vcbi8vIGB1bmlxdWUgc3ltYm9sYCBtdXN0IGJlIGBjb25zdGAuXG4vKiogVGVybWluYXRlIHZpc2l0IHRyYXZlcnNhbCBjb21wbGV0ZWx5ICovXG52aXNpdC5CUkVBSyA9IEJSRUFLO1xuLyoqIERvIG5vdCB2aXNpdCB0aGUgY2hpbGRyZW4gb2YgdGhlIGN1cnJlbnQgbm9kZSAqL1xudmlzaXQuU0tJUCA9IFNLSVA7XG4vKiogUmVtb3ZlIHRoZSBjdXJyZW50IG5vZGUgKi9cbnZpc2l0LlJFTU9WRSA9IFJFTU9WRTtcbmZ1bmN0aW9uIF92aXNpdChrZXksIG5vZGUsIHZpc2l0b3IsIHBhdGgpIHtcbiAgICBsZXQgY3RybCA9IHVuZGVmaW5lZDtcbiAgICBpZiAodHlwZW9mIHZpc2l0b3IgPT09ICdmdW5jdGlvbicpXG4gICAgICAgIGN0cmwgPSB2aXNpdG9yKGtleSwgbm9kZSwgcGF0aCk7XG4gICAgZWxzZSBpZiAoaXNNYXAobm9kZSkpIHtcbiAgICAgICAgaWYgKHZpc2l0b3IuTWFwKVxuICAgICAgICAgICAgY3RybCA9IHZpc2l0b3IuTWFwKGtleSwgbm9kZSwgcGF0aCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzU2VxKG5vZGUpKSB7XG4gICAgICAgIGlmICh2aXNpdG9yLlNlcSlcbiAgICAgICAgICAgIGN0cmwgPSB2aXNpdG9yLlNlcShrZXksIG5vZGUsIHBhdGgpO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc1BhaXIobm9kZSkpIHtcbiAgICAgICAgaWYgKHZpc2l0b3IuUGFpcilcbiAgICAgICAgICAgIGN0cmwgPSB2aXNpdG9yLlBhaXIoa2V5LCBub2RlLCBwYXRoKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNTY2FsYXIobm9kZSkpIHtcbiAgICAgICAgaWYgKHZpc2l0b3IuU2NhbGFyKVxuICAgICAgICAgICAgY3RybCA9IHZpc2l0b3IuU2NhbGFyKGtleSwgbm9kZSwgcGF0aCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzQWxpYXMobm9kZSkpIHtcbiAgICAgICAgaWYgKHZpc2l0b3IuQWxpYXMpXG4gICAgICAgICAgICBjdHJsID0gdmlzaXRvci5BbGlhcyhrZXksIG5vZGUsIHBhdGgpO1xuICAgIH1cbiAgICBpZiAoaXNOb2RlKGN0cmwpIHx8IGlzUGFpcihjdHJsKSkge1xuICAgICAgICBjb25zdCBwYXJlbnQgPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV07XG4gICAgICAgIGlmIChpc0NvbGxlY3Rpb24ocGFyZW50KSkge1xuICAgICAgICAgICAgcGFyZW50Lml0ZW1zW2tleV0gPSBjdHJsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzUGFpcihwYXJlbnQpKSB7XG4gICAgICAgICAgICBpZiAoa2V5ID09PSAna2V5JylcbiAgICAgICAgICAgICAgICBwYXJlbnQua2V5ID0gY3RybDtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBwYXJlbnQudmFsdWUgPSBjdHJsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzRG9jdW1lbnQocGFyZW50KSkge1xuICAgICAgICAgICAgcGFyZW50LmNvbnRlbnRzID0gY3RybDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHB0ID0gaXNBbGlhcyhwYXJlbnQpID8gJ2FsaWFzJyA6ICdzY2FsYXInO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgcmVwbGFjZSBub2RlIHdpdGggJHtwdH0gcGFyZW50YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF92aXNpdChrZXksIGN0cmwsIHZpc2l0b3IsIHBhdGgpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGN0cmwgIT09ICdzeW1ib2wnKSB7XG4gICAgICAgIGlmIChpc0NvbGxlY3Rpb24obm9kZSkpIHtcbiAgICAgICAgICAgIHBhdGggPSBPYmplY3QuZnJlZXplKHBhdGguY29uY2F0KG5vZGUpKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5pdGVtcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNpID0gX3Zpc2l0KGksIG5vZGUuaXRlbXNbaV0sIHZpc2l0b3IsIHBhdGgpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY2kgPT09ICdudW1iZXInKVxuICAgICAgICAgICAgICAgICAgICBpID0gY2kgLSAxO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNpID09PSBCUkVBSylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEJSRUFLO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNpID09PSBSRU1PVkUpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5pdGVtcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIGkgLT0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNQYWlyKG5vZGUpKSB7XG4gICAgICAgICAgICBwYXRoID0gT2JqZWN0LmZyZWV6ZShwYXRoLmNvbmNhdChub2RlKSk7XG4gICAgICAgICAgICBjb25zdCBjayA9IF92aXNpdCgna2V5Jywgbm9kZS5rZXksIHZpc2l0b3IsIHBhdGgpO1xuICAgICAgICAgICAgaWYgKGNrID09PSBCUkVBSylcbiAgICAgICAgICAgICAgICByZXR1cm4gQlJFQUs7XG4gICAgICAgICAgICBlbHNlIGlmIChjayA9PT0gUkVNT1ZFKVxuICAgICAgICAgICAgICAgIG5vZGUua2V5ID0gbnVsbDtcbiAgICAgICAgICAgIGNvbnN0IGN2ID0gX3Zpc2l0KCd2YWx1ZScsIG5vZGUudmFsdWUsIHZpc2l0b3IsIHBhdGgpO1xuICAgICAgICAgICAgaWYgKGN2ID09PSBCUkVBSylcbiAgICAgICAgICAgICAgICByZXR1cm4gQlJFQUs7XG4gICAgICAgICAgICBlbHNlIGlmIChjdiA9PT0gUkVNT1ZFKVxuICAgICAgICAgICAgICAgIG5vZGUudmFsdWUgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjdHJsO1xufVxuXG5leHBvcnQgeyB2aXNpdCB9O1xuIiwgImltcG9ydCB7IGlzTm9kZSB9IGZyb20gJy4uL25vZGVzL05vZGUuanMnO1xuaW1wb3J0IHsgdmlzaXQgfSBmcm9tICcuLi92aXNpdC5qcyc7XG5cbmNvbnN0IGVzY2FwZUNoYXJzID0ge1xuICAgICchJzogJyUyMScsXG4gICAgJywnOiAnJTJDJyxcbiAgICAnWyc6ICclNUInLFxuICAgICddJzogJyU1RCcsXG4gICAgJ3snOiAnJTdCJyxcbiAgICAnfSc6ICclN0QnXG59O1xuY29uc3QgZXNjYXBlVGFnTmFtZSA9ICh0bikgPT4gdG4ucmVwbGFjZSgvWyEsW1xcXXt9XS9nLCBjaCA9PiBlc2NhcGVDaGFyc1tjaF0pO1xuY2xhc3MgRGlyZWN0aXZlcyB7XG4gICAgY29uc3RydWN0b3IoeWFtbCwgdGFncykge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGRpcmVjdGl2ZXMtZW5kL2RvYy1zdGFydCBtYXJrZXIgYC0tLWAuIElmIGBudWxsYCwgYSBtYXJrZXIgbWF5IHN0aWxsIGJlXG4gICAgICAgICAqIGluY2x1ZGVkIGluIHRoZSBkb2N1bWVudCdzIHN0cmluZ2lmaWVkIHJlcHJlc2VudGF0aW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5tYXJrZXIgPSBudWxsO1xuICAgICAgICB0aGlzLnlhbWwgPSBPYmplY3QuYXNzaWduKHt9LCBEaXJlY3RpdmVzLmRlZmF1bHRZYW1sLCB5YW1sKTtcbiAgICAgICAgdGhpcy50YWdzID0gT2JqZWN0LmFzc2lnbih7fSwgRGlyZWN0aXZlcy5kZWZhdWx0VGFncywgdGFncyk7XG4gICAgfVxuICAgIGNsb25lKCkge1xuICAgICAgICBjb25zdCBjb3B5ID0gbmV3IERpcmVjdGl2ZXModGhpcy55YW1sLCB0aGlzLnRhZ3MpO1xuICAgICAgICBjb3B5Lm1hcmtlciA9IHRoaXMubWFya2VyO1xuICAgICAgICByZXR1cm4gY29weTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRHVyaW5nIHBhcnNpbmcsIGdldCBhIERpcmVjdGl2ZXMgaW5zdGFuY2UgZm9yIHRoZSBjdXJyZW50IGRvY3VtZW50IGFuZFxuICAgICAqIHVwZGF0ZSB0aGUgc3RyZWFtIHN0YXRlIGFjY29yZGluZyB0byB0aGUgY3VycmVudCB2ZXJzaW9uJ3Mgc3BlYy5cbiAgICAgKi9cbiAgICBhdERvY3VtZW50KCkge1xuICAgICAgICBjb25zdCByZXMgPSBuZXcgRGlyZWN0aXZlcyh0aGlzLnlhbWwsIHRoaXMudGFncyk7XG4gICAgICAgIHN3aXRjaCAodGhpcy55YW1sLnZlcnNpb24pIHtcbiAgICAgICAgICAgIGNhc2UgJzEuMSc6XG4gICAgICAgICAgICAgICAgdGhpcy5hdE5leHREb2N1bWVudCA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICcxLjInOlxuICAgICAgICAgICAgICAgIHRoaXMuYXROZXh0RG9jdW1lbnQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLnlhbWwgPSB7XG4gICAgICAgICAgICAgICAgICAgIGV4cGxpY2l0OiBEaXJlY3RpdmVzLmRlZmF1bHRZYW1sLmV4cGxpY2l0LFxuICAgICAgICAgICAgICAgICAgICB2ZXJzaW9uOiAnMS4yJ1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdGhpcy50YWdzID0gT2JqZWN0LmFzc2lnbih7fSwgRGlyZWN0aXZlcy5kZWZhdWx0VGFncyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIG9uRXJyb3IgLSBNYXkgYmUgY2FsbGVkIGV2ZW4gaWYgdGhlIGFjdGlvbiB3YXMgc3VjY2Vzc2Z1bFxuICAgICAqIEByZXR1cm5zIGB0cnVlYCBvbiBzdWNjZXNzXG4gICAgICovXG4gICAgYWRkKGxpbmUsIG9uRXJyb3IpIHtcbiAgICAgICAgaWYgKHRoaXMuYXROZXh0RG9jdW1lbnQpIHtcbiAgICAgICAgICAgIHRoaXMueWFtbCA9IHsgZXhwbGljaXQ6IERpcmVjdGl2ZXMuZGVmYXVsdFlhbWwuZXhwbGljaXQsIHZlcnNpb246ICcxLjEnIH07XG4gICAgICAgICAgICB0aGlzLnRhZ3MgPSBPYmplY3QuYXNzaWduKHt9LCBEaXJlY3RpdmVzLmRlZmF1bHRUYWdzKTtcbiAgICAgICAgICAgIHRoaXMuYXROZXh0RG9jdW1lbnQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJ0cyA9IGxpbmUudHJpbSgpLnNwbGl0KC9bIFxcdF0rLyk7XG4gICAgICAgIGNvbnN0IG5hbWUgPSBwYXJ0cy5zaGlmdCgpO1xuICAgICAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgICAgICAgIGNhc2UgJyVUQUcnOiB7XG4gICAgICAgICAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCAhPT0gMikge1xuICAgICAgICAgICAgICAgICAgICBvbkVycm9yKDAsICclVEFHIGRpcmVjdGl2ZSBzaG91bGQgY29udGFpbiBleGFjdGx5IHR3byBwYXJ0cycpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocGFydHMubGVuZ3RoIDwgMilcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgW2hhbmRsZSwgcHJlZml4XSA9IHBhcnRzO1xuICAgICAgICAgICAgICAgIHRoaXMudGFnc1toYW5kbGVdID0gcHJlZml4O1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnJVlBTUwnOiB7XG4gICAgICAgICAgICAgICAgdGhpcy55YW1sLmV4cGxpY2l0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAocGFydHMubGVuZ3RoIDwgMSkge1xuICAgICAgICAgICAgICAgICAgICBvbkVycm9yKDAsICclWUFNTCBkaXJlY3RpdmUgc2hvdWxkIGNvbnRhaW4gZXhhY3RseSBvbmUgcGFydCcpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IFt2ZXJzaW9uXSA9IHBhcnRzO1xuICAgICAgICAgICAgICAgIGlmICh2ZXJzaW9uID09PSAnMS4xJyB8fCB2ZXJzaW9uID09PSAnMS4yJykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnlhbWwudmVyc2lvbiA9IHZlcnNpb247XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgb25FcnJvcig2LCBgVW5zdXBwb3J0ZWQgWUFNTCB2ZXJzaW9uICR7dmVyc2lvbn1gLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgb25FcnJvcigwLCBgVW5rbm93biBkaXJlY3RpdmUgJHtuYW1lfWAsIHRydWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXNvbHZlcyBhIHRhZywgbWF0Y2hpbmcgaGFuZGxlcyB0byB0aG9zZSBkZWZpbmVkIGluICVUQUcgZGlyZWN0aXZlcy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFJlc29sdmVkIHRhZywgd2hpY2ggbWF5IGFsc28gYmUgdGhlIG5vbi1zcGVjaWZpYyB0YWcgYCchJ2Agb3IgYVxuICAgICAqICAgYCchbG9jYWwnYCB0YWcsIG9yIGBudWxsYCBpZiB1bnJlc29sdmFibGUuXG4gICAgICovXG4gICAgdGFnTmFtZShzb3VyY2UsIG9uRXJyb3IpIHtcbiAgICAgICAgaWYgKHNvdXJjZSA9PT0gJyEnKVxuICAgICAgICAgICAgcmV0dXJuICchJzsgLy8gbm9uLXNwZWNpZmljIHRhZ1xuICAgICAgICBpZiAoc291cmNlWzBdICE9PSAnIScpIHtcbiAgICAgICAgICAgIG9uRXJyb3IoYE5vdCBhIHZhbGlkIHRhZzogJHtzb3VyY2V9YCk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc291cmNlWzFdID09PSAnPCcpIHtcbiAgICAgICAgICAgIGNvbnN0IHZlcmJhdGltID0gc291cmNlLnNsaWNlKDIsIC0xKTtcbiAgICAgICAgICAgIGlmICh2ZXJiYXRpbSA9PT0gJyEnIHx8IHZlcmJhdGltID09PSAnISEnKSB7XG4gICAgICAgICAgICAgICAgb25FcnJvcihgVmVyYmF0aW0gdGFncyBhcmVuJ3QgcmVzb2x2ZWQsIHNvICR7c291cmNlfSBpcyBpbnZhbGlkLmApO1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNvdXJjZVtzb3VyY2UubGVuZ3RoIC0gMV0gIT09ICc+JylcbiAgICAgICAgICAgICAgICBvbkVycm9yKCdWZXJiYXRpbSB0YWdzIG11c3QgZW5kIHdpdGggYSA+Jyk7XG4gICAgICAgICAgICByZXR1cm4gdmVyYmF0aW07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgWywgaGFuZGxlLCBzdWZmaXhdID0gc291cmNlLm1hdGNoKC9eKC4qISkoW14hXSopJC8pO1xuICAgICAgICBpZiAoIXN1ZmZpeClcbiAgICAgICAgICAgIG9uRXJyb3IoYFRoZSAke3NvdXJjZX0gdGFnIGhhcyBubyBzdWZmaXhgKTtcbiAgICAgICAgY29uc3QgcHJlZml4ID0gdGhpcy50YWdzW2hhbmRsZV07XG4gICAgICAgIGlmIChwcmVmaXgpXG4gICAgICAgICAgICByZXR1cm4gcHJlZml4ICsgZGVjb2RlVVJJQ29tcG9uZW50KHN1ZmZpeCk7XG4gICAgICAgIGlmIChoYW5kbGUgPT09ICchJylcbiAgICAgICAgICAgIHJldHVybiBzb3VyY2U7IC8vIGxvY2FsIHRhZ1xuICAgICAgICBvbkVycm9yKGBDb3VsZCBub3QgcmVzb2x2ZSB0YWc6ICR7c291cmNlfWApO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2l2ZW4gYSBmdWxseSByZXNvbHZlZCB0YWcsIHJldHVybnMgaXRzIHByaW50YWJsZSBzdHJpbmcgZm9ybSxcbiAgICAgKiB0YWtpbmcgaW50byBhY2NvdW50IGN1cnJlbnQgdGFnIHByZWZpeGVzIGFuZCBkZWZhdWx0cy5cbiAgICAgKi9cbiAgICB0YWdTdHJpbmcodGFnKSB7XG4gICAgICAgIGZvciAoY29uc3QgW2hhbmRsZSwgcHJlZml4XSBvZiBPYmplY3QuZW50cmllcyh0aGlzLnRhZ3MpKSB7XG4gICAgICAgICAgICBpZiAodGFnLnN0YXJ0c1dpdGgocHJlZml4KSlcbiAgICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlICsgZXNjYXBlVGFnTmFtZSh0YWcuc3Vic3RyaW5nKHByZWZpeC5sZW5ndGgpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGFnWzBdID09PSAnIScgPyB0YWcgOiBgITwke3RhZ30+YDtcbiAgICB9XG4gICAgdG9TdHJpbmcoZG9jKSB7XG4gICAgICAgIGNvbnN0IGxpbmVzID0gdGhpcy55YW1sLmV4cGxpY2l0XG4gICAgICAgICAgICA/IFtgJVlBTUwgJHt0aGlzLnlhbWwudmVyc2lvbiB8fCAnMS4yJ31gXVxuICAgICAgICAgICAgOiBbXTtcbiAgICAgICAgY29uc3QgdGFnRW50cmllcyA9IE9iamVjdC5lbnRyaWVzKHRoaXMudGFncyk7XG4gICAgICAgIGxldCB0YWdOYW1lcztcbiAgICAgICAgaWYgKGRvYyAmJiB0YWdFbnRyaWVzLmxlbmd0aCA+IDAgJiYgaXNOb2RlKGRvYy5jb250ZW50cykpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhZ3MgPSB7fTtcbiAgICAgICAgICAgIHZpc2l0KGRvYy5jb250ZW50cywgKF9rZXksIG5vZGUpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoaXNOb2RlKG5vZGUpICYmIG5vZGUudGFnKVxuICAgICAgICAgICAgICAgICAgICB0YWdzW25vZGUudGFnXSA9IHRydWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRhZ05hbWVzID0gT2JqZWN0LmtleXModGFncyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGFnTmFtZXMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBbaGFuZGxlLCBwcmVmaXhdIG9mIHRhZ0VudHJpZXMpIHtcbiAgICAgICAgICAgIGlmIChoYW5kbGUgPT09ICchIScgJiYgcHJlZml4ID09PSAndGFnOnlhbWwub3JnLDIwMDI6JylcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGlmICghZG9jIHx8IHRhZ05hbWVzLnNvbWUodG4gPT4gdG4uc3RhcnRzV2l0aChwcmVmaXgpKSlcbiAgICAgICAgICAgICAgICBsaW5lcy5wdXNoKGAlVEFHICR7aGFuZGxlfSAke3ByZWZpeH1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGluZXMuam9pbignXFxuJyk7XG4gICAgfVxufVxuRGlyZWN0aXZlcy5kZWZhdWx0WWFtbCA9IHsgZXhwbGljaXQ6IGZhbHNlLCB2ZXJzaW9uOiAnMS4yJyB9O1xuRGlyZWN0aXZlcy5kZWZhdWx0VGFncyA9IHsgJyEhJzogJ3RhZzp5YW1sLm9yZywyMDAyOicgfTtcblxuZXhwb3J0IHsgRGlyZWN0aXZlcyB9O1xuIiwgImltcG9ydCB7IGlzU2NhbGFyLCBpc0NvbGxlY3Rpb24gfSBmcm9tICcuLi9ub2Rlcy9Ob2RlLmpzJztcbmltcG9ydCB7IHZpc2l0IH0gZnJvbSAnLi4vdmlzaXQuanMnO1xuXG4vKipcbiAqIFZlcmlmeSB0aGF0IHRoZSBpbnB1dCBzdHJpbmcgaXMgYSB2YWxpZCBhbmNob3IuXG4gKlxuICogV2lsbCB0aHJvdyBvbiBlcnJvcnMuXG4gKi9cbmZ1bmN0aW9uIGFuY2hvcklzVmFsaWQoYW5jaG9yKSB7XG4gICAgaWYgKC9bXFx4MDAtXFx4MTlcXHMsW1xcXXt9XS8udGVzdChhbmNob3IpKSB7XG4gICAgICAgIGNvbnN0IHNhID0gSlNPTi5zdHJpbmdpZnkoYW5jaG9yKTtcbiAgICAgICAgY29uc3QgbXNnID0gYEFuY2hvciBtdXN0IG5vdCBjb250YWluIHdoaXRlc3BhY2Ugb3IgY29udHJvbCBjaGFyYWN0ZXJzOiAke3NhfWA7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGFuY2hvck5hbWVzKHJvb3QpIHtcbiAgICBjb25zdCBhbmNob3JzID0gbmV3IFNldCgpO1xuICAgIHZpc2l0KHJvb3QsIHtcbiAgICAgICAgVmFsdWUoX2tleSwgbm9kZSkge1xuICAgICAgICAgICAgaWYgKG5vZGUuYW5jaG9yKVxuICAgICAgICAgICAgICAgIGFuY2hvcnMuYWRkKG5vZGUuYW5jaG9yKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBhbmNob3JzO1xufVxuLyoqIEZpbmQgYSBuZXcgYW5jaG9yIG5hbWUgd2l0aCB0aGUgZ2l2ZW4gYHByZWZpeGAgYW5kIGEgb25lLWluZGV4ZWQgc3VmZml4LiAqL1xuZnVuY3Rpb24gZmluZE5ld0FuY2hvcihwcmVmaXgsIGV4Y2x1ZGUpIHtcbiAgICBmb3IgKGxldCBpID0gMTsgdHJ1ZTsgKytpKSB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSBgJHtwcmVmaXh9JHtpfWA7XG4gICAgICAgIGlmICghZXhjbHVkZS5oYXMobmFtZSkpXG4gICAgICAgICAgICByZXR1cm4gbmFtZTtcbiAgICB9XG59XG5mdW5jdGlvbiBjcmVhdGVOb2RlQW5jaG9ycyhkb2MsIHByZWZpeCkge1xuICAgIGNvbnN0IGFsaWFzT2JqZWN0cyA9IFtdO1xuICAgIGNvbnN0IHNvdXJjZU9iamVjdHMgPSBuZXcgTWFwKCk7XG4gICAgbGV0IHByZXZBbmNob3JzID0gbnVsbDtcbiAgICByZXR1cm4ge1xuICAgICAgICBvbkFuY2hvcihzb3VyY2UpIHtcbiAgICAgICAgICAgIGFsaWFzT2JqZWN0cy5wdXNoKHNvdXJjZSk7XG4gICAgICAgICAgICBpZiAoIXByZXZBbmNob3JzKVxuICAgICAgICAgICAgICAgIHByZXZBbmNob3JzID0gYW5jaG9yTmFtZXMoZG9jKTtcbiAgICAgICAgICAgIGNvbnN0IGFuY2hvciA9IGZpbmROZXdBbmNob3IocHJlZml4LCBwcmV2QW5jaG9ycyk7XG4gICAgICAgICAgICBwcmV2QW5jaG9ycy5hZGQoYW5jaG9yKTtcbiAgICAgICAgICAgIHJldHVybiBhbmNob3I7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaXRoIGNpcmN1bGFyIHJlZmVyZW5jZXMsIHRoZSBzb3VyY2Ugbm9kZSBpcyBvbmx5IHJlc29sdmVkIGFmdGVyIGFsbFxuICAgICAgICAgKiBvZiBpdHMgY2hpbGQgbm9kZXMgYXJlLiBUaGlzIGlzIHdoeSBhbmNob3JzIGFyZSBzZXQgb25seSBhZnRlciBhbGwgb2ZcbiAgICAgICAgICogdGhlIG5vZGVzIGhhdmUgYmVlbiBjcmVhdGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgc2V0QW5jaG9ycygpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3Qgc291cmNlIG9mIGFsaWFzT2JqZWN0cykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlZiA9IHNvdXJjZU9iamVjdHMuZ2V0KHNvdXJjZSk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiByZWYgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICAgICAgICAgIHJlZi5hbmNob3IgJiZcbiAgICAgICAgICAgICAgICAgICAgKGlzU2NhbGFyKHJlZi5ub2RlKSB8fCBpc0NvbGxlY3Rpb24ocmVmLm5vZGUpKSkge1xuICAgICAgICAgICAgICAgICAgICByZWYubm9kZS5hbmNob3IgPSByZWYuYW5jaG9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoJ0ZhaWxlZCB0byByZXNvbHZlIHJlcGVhdGVkIG9iamVjdCAodGhpcyBzaG91bGQgbm90IGhhcHBlbiknKTtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3Iuc291cmNlID0gc291cmNlO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHNvdXJjZU9iamVjdHNcbiAgICB9O1xufVxuXG5leHBvcnQgeyBhbmNob3JJc1ZhbGlkLCBhbmNob3JOYW1lcywgY3JlYXRlTm9kZUFuY2hvcnMsIGZpbmROZXdBbmNob3IgfTtcbiIsICJpbXBvcnQgeyBhbmNob3JJc1ZhbGlkIH0gZnJvbSAnLi4vZG9jL2FuY2hvcnMuanMnO1xuaW1wb3J0IHsgdmlzaXQgfSBmcm9tICcuLi92aXNpdC5qcyc7XG5pbXBvcnQgeyBOb2RlQmFzZSwgQUxJQVMsIGlzQWxpYXMsIGlzQ29sbGVjdGlvbiwgaXNQYWlyIH0gZnJvbSAnLi9Ob2RlLmpzJztcblxuY2xhc3MgQWxpYXMgZXh0ZW5kcyBOb2RlQmFzZSB7XG4gICAgY29uc3RydWN0b3Ioc291cmNlKSB7XG4gICAgICAgIHN1cGVyKEFMSUFTKTtcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAndGFnJywge1xuICAgICAgICAgICAgc2V0KCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQWxpYXMgbm9kZXMgY2Fubm90IGhhdmUgdGFncycpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVzb2x2ZSB0aGUgdmFsdWUgb2YgdGhpcyBhbGlhcyB3aXRoaW4gYGRvY2AsIGZpbmRpbmcgdGhlIGxhc3RcbiAgICAgKiBpbnN0YW5jZSBvZiB0aGUgYHNvdXJjZWAgYW5jaG9yIGJlZm9yZSB0aGlzIG5vZGUuXG4gICAgICovXG4gICAgcmVzb2x2ZShkb2MpIHtcbiAgICAgICAgbGV0IGZvdW5kID0gdW5kZWZpbmVkO1xuICAgICAgICB2aXNpdChkb2MsIHtcbiAgICAgICAgICAgIE5vZGU6IChfa2V5LCBub2RlKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUgPT09IHRoaXMpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2aXNpdC5CUkVBSztcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5hbmNob3IgPT09IHRoaXMuc291cmNlKVxuICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IG5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZm91bmQ7XG4gICAgfVxuICAgIHRvSlNPTihfYXJnLCBjdHgpIHtcbiAgICAgICAgaWYgKCFjdHgpXG4gICAgICAgICAgICByZXR1cm4geyBzb3VyY2U6IHRoaXMuc291cmNlIH07XG4gICAgICAgIGNvbnN0IHsgYW5jaG9ycywgZG9jLCBtYXhBbGlhc0NvdW50IH0gPSBjdHg7XG4gICAgICAgIGNvbnN0IHNvdXJjZSA9IHRoaXMucmVzb2x2ZShkb2MpO1xuICAgICAgICBpZiAoIXNvdXJjZSkge1xuICAgICAgICAgICAgY29uc3QgbXNnID0gYFVucmVzb2x2ZWQgYWxpYXMgKHRoZSBhbmNob3IgbXVzdCBiZSBzZXQgYmVmb3JlIHRoZSBhbGlhcyk6ICR7dGhpcy5zb3VyY2V9YDtcbiAgICAgICAgICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihtc2cpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRhdGEgPSBhbmNob3JzLmdldChzb3VyY2UpO1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKCFkYXRhIHx8IGRhdGEucmVzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IG1zZyA9ICdUaGlzIHNob3VsZCBub3QgaGFwcGVuOiBBbGlhcyBhbmNob3Igd2FzIG5vdCByZXNvbHZlZD8nO1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKG1zZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1heEFsaWFzQ291bnQgPj0gMCkge1xuICAgICAgICAgICAgZGF0YS5jb3VudCArPSAxO1xuICAgICAgICAgICAgaWYgKGRhdGEuYWxpYXNDb3VudCA9PT0gMClcbiAgICAgICAgICAgICAgICBkYXRhLmFsaWFzQ291bnQgPSBnZXRBbGlhc0NvdW50KGRvYywgc291cmNlLCBhbmNob3JzKTtcbiAgICAgICAgICAgIGlmIChkYXRhLmNvdW50ICogZGF0YS5hbGlhc0NvdW50ID4gbWF4QWxpYXNDb3VudCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1zZyA9ICdFeGNlc3NpdmUgYWxpYXMgY291bnQgaW5kaWNhdGVzIGEgcmVzb3VyY2UgZXhoYXVzdGlvbiBhdHRhY2snO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihtc2cpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRhLnJlcztcbiAgICB9XG4gICAgdG9TdHJpbmcoY3R4LCBfb25Db21tZW50LCBfb25DaG9tcEtlZXApIHtcbiAgICAgICAgY29uc3Qgc3JjID0gYCoke3RoaXMuc291cmNlfWA7XG4gICAgICAgIGlmIChjdHgpIHtcbiAgICAgICAgICAgIGFuY2hvcklzVmFsaWQodGhpcy5zb3VyY2UpO1xuICAgICAgICAgICAgaWYgKGN0eC5vcHRpb25zLnZlcmlmeUFsaWFzT3JkZXIgJiYgIWN0eC5hbmNob3JzLmhhcyh0aGlzLnNvdXJjZSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtc2cgPSBgVW5yZXNvbHZlZCBhbGlhcyAodGhlIGFuY2hvciBtdXN0IGJlIHNldCBiZWZvcmUgdGhlIGFsaWFzKTogJHt0aGlzLnNvdXJjZX1gO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGN0eC5pbXBsaWNpdEtleSlcbiAgICAgICAgICAgICAgICByZXR1cm4gYCR7c3JjfSBgO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzcmM7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0QWxpYXNDb3VudChkb2MsIG5vZGUsIGFuY2hvcnMpIHtcbiAgICBpZiAoaXNBbGlhcyhub2RlKSkge1xuICAgICAgICBjb25zdCBzb3VyY2UgPSBub2RlLnJlc29sdmUoZG9jKTtcbiAgICAgICAgY29uc3QgYW5jaG9yID0gYW5jaG9ycyAmJiBzb3VyY2UgJiYgYW5jaG9ycy5nZXQoc291cmNlKTtcbiAgICAgICAgcmV0dXJuIGFuY2hvciA/IGFuY2hvci5jb3VudCAqIGFuY2hvci5hbGlhc0NvdW50IDogMDtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNDb2xsZWN0aW9uKG5vZGUpKSB7XG4gICAgICAgIGxldCBjb3VudCA9IDA7XG4gICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBub2RlLml0ZW1zKSB7XG4gICAgICAgICAgICBjb25zdCBjID0gZ2V0QWxpYXNDb3VudChkb2MsIGl0ZW0sIGFuY2hvcnMpO1xuICAgICAgICAgICAgaWYgKGMgPiBjb3VudClcbiAgICAgICAgICAgICAgICBjb3VudCA9IGM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvdW50O1xuICAgIH1cbiAgICBlbHNlIGlmIChpc1BhaXIobm9kZSkpIHtcbiAgICAgICAgY29uc3Qga2MgPSBnZXRBbGlhc0NvdW50KGRvYywgbm9kZS5rZXksIGFuY2hvcnMpO1xuICAgICAgICBjb25zdCB2YyA9IGdldEFsaWFzQ291bnQoZG9jLCBub2RlLnZhbHVlLCBhbmNob3JzKTtcbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KGtjLCB2Yyk7XG4gICAgfVxuICAgIHJldHVybiAxO1xufVxuXG5leHBvcnQgeyBBbGlhcyB9O1xuIiwgImltcG9ydCB7IGhhc0FuY2hvciB9IGZyb20gJy4vTm9kZS5qcyc7XG5cbi8qKlxuICogUmVjdXJzaXZlbHkgY29udmVydCBhbnkgbm9kZSBvciBpdHMgY29udGVudHMgdG8gbmF0aXZlIEphdmFTY3JpcHRcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgaW5wdXQgdmFsdWVcbiAqIEBwYXJhbSBhcmcgLSBJZiBgdmFsdWVgIGRlZmluZXMgYSBgdG9KU09OKClgIG1ldGhvZCwgdXNlIHRoaXNcbiAqICAgYXMgaXRzIGZpcnN0IGFyZ3VtZW50XG4gKiBAcGFyYW0gY3R4IC0gQ29udmVyc2lvbiBjb250ZXh0LCBvcmlnaW5hbGx5IHNldCBpbiBEb2N1bWVudCN0b0pTKCkuIElmXG4gKiAgIGB7IGtlZXA6IHRydWUgfWAgaXMgbm90IHNldCwgb3V0cHV0IHNob3VsZCBiZSBzdWl0YWJsZSBmb3IgSlNPTlxuICogICBzdHJpbmdpZmljYXRpb24uXG4gKi9cbmZ1bmN0aW9uIHRvSlModmFsdWUsIGFyZywgY3R4KSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKVxuICAgICAgICByZXR1cm4gdmFsdWUubWFwKCh2LCBpKSA9PiB0b0pTKHYsIFN0cmluZyhpKSwgY3R4KSk7XG4gICAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZS50b0pTT04gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgaWYgKCFjdHggfHwgIWhhc0FuY2hvcih2YWx1ZSkpXG4gICAgICAgICAgICByZXR1cm4gdmFsdWUudG9KU09OKGFyZywgY3R4KTtcbiAgICAgICAgY29uc3QgZGF0YSA9IHsgYWxpYXNDb3VudDogMCwgY291bnQ6IDEsIHJlczogdW5kZWZpbmVkIH07XG4gICAgICAgIGN0eC5hbmNob3JzLnNldCh2YWx1ZSwgZGF0YSk7XG4gICAgICAgIGN0eC5vbkNyZWF0ZSA9IHJlcyA9PiB7XG4gICAgICAgICAgICBkYXRhLnJlcyA9IHJlcztcbiAgICAgICAgICAgIGRlbGV0ZSBjdHgub25DcmVhdGU7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlcyA9IHZhbHVlLnRvSlNPTihhcmcsIGN0eCk7XG4gICAgICAgIGlmIChjdHgub25DcmVhdGUpXG4gICAgICAgICAgICBjdHgub25DcmVhdGUocmVzKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2JpZ2ludCcgJiYgIShjdHggJiYgY3R4LmtlZXApKVxuICAgICAgICByZXR1cm4gTnVtYmVyKHZhbHVlKTtcbiAgICByZXR1cm4gdmFsdWU7XG59XG5cbmV4cG9ydCB7IHRvSlMgfTtcbiIsICJpbXBvcnQgeyBOb2RlQmFzZSwgU0NBTEFSIH0gZnJvbSAnLi9Ob2RlLmpzJztcbmltcG9ydCB7IHRvSlMgfSBmcm9tICcuL3RvSlMuanMnO1xuXG5jb25zdCBpc1NjYWxhclZhbHVlID0gKHZhbHVlKSA9PiAhdmFsdWUgfHwgKHR5cGVvZiB2YWx1ZSAhPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnKTtcbmNsYXNzIFNjYWxhciBleHRlbmRzIE5vZGVCYXNlIHtcbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZSkge1xuICAgICAgICBzdXBlcihTQ0FMQVIpO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIHRvSlNPTihhcmcsIGN0eCkge1xuICAgICAgICByZXR1cm4gY3R4ICYmIGN0eC5rZWVwID8gdGhpcy52YWx1ZSA6IHRvSlModGhpcy52YWx1ZSwgYXJnLCBjdHgpO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIFN0cmluZyh0aGlzLnZhbHVlKTtcbiAgICB9XG59XG5TY2FsYXIuQkxPQ0tfRk9MREVEID0gJ0JMT0NLX0ZPTERFRCc7XG5TY2FsYXIuQkxPQ0tfTElURVJBTCA9ICdCTE9DS19MSVRFUkFMJztcblNjYWxhci5QTEFJTiA9ICdQTEFJTic7XG5TY2FsYXIuUVVPVEVfRE9VQkxFID0gJ1FVT1RFX0RPVUJMRSc7XG5TY2FsYXIuUVVPVEVfU0lOR0xFID0gJ1FVT1RFX1NJTkdMRSc7XG5cbmV4cG9ydCB7IFNjYWxhciwgaXNTY2FsYXJWYWx1ZSB9O1xuIiwgImltcG9ydCB7IEFsaWFzIH0gZnJvbSAnLi4vbm9kZXMvQWxpYXMuanMnO1xuaW1wb3J0IHsgaXNOb2RlLCBpc1BhaXIsIE1BUCwgU0VRLCBpc0RvY3VtZW50IH0gZnJvbSAnLi4vbm9kZXMvTm9kZS5qcyc7XG5pbXBvcnQgeyBTY2FsYXIgfSBmcm9tICcuLi9ub2Rlcy9TY2FsYXIuanMnO1xuXG5jb25zdCBkZWZhdWx0VGFnUHJlZml4ID0gJ3RhZzp5YW1sLm9yZywyMDAyOic7XG5mdW5jdGlvbiBmaW5kVGFnT2JqZWN0KHZhbHVlLCB0YWdOYW1lLCB0YWdzKSB7XG4gICAgaWYgKHRhZ05hbWUpIHtcbiAgICAgICAgY29uc3QgbWF0Y2ggPSB0YWdzLmZpbHRlcih0ID0+IHQudGFnID09PSB0YWdOYW1lKTtcbiAgICAgICAgY29uc3QgdGFnT2JqID0gbWF0Y2guZmluZCh0ID0+ICF0LmZvcm1hdCkgfHwgbWF0Y2hbMF07XG4gICAgICAgIGlmICghdGFnT2JqKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUYWcgJHt0YWdOYW1lfSBub3QgZm91bmRgKTtcbiAgICAgICAgcmV0dXJuIHRhZ09iajtcbiAgICB9XG4gICAgcmV0dXJuIHRhZ3MuZmluZCh0ID0+IHQuaWRlbnRpZnkgJiYgdC5pZGVudGlmeSh2YWx1ZSkgJiYgIXQuZm9ybWF0KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZU5vZGUodmFsdWUsIHRhZ05hbWUsIGN0eCkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgaWYgKGlzRG9jdW1lbnQodmFsdWUpKVxuICAgICAgICB2YWx1ZSA9IHZhbHVlLmNvbnRlbnRzO1xuICAgIGlmIChpc05vZGUodmFsdWUpKVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgaWYgKGlzUGFpcih2YWx1ZSkpIHtcbiAgICAgICAgY29uc3QgbWFwID0gKF9iID0gKF9hID0gY3R4LnNjaGVtYVtNQVBdKS5jcmVhdGVOb2RlKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSwgY3R4LnNjaGVtYSwgbnVsbCwgY3R4KTtcbiAgICAgICAgbWFwLml0ZW1zLnB1c2godmFsdWUpO1xuICAgICAgICByZXR1cm4gbWFwO1xuICAgIH1cbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBTdHJpbmcgfHxcbiAgICAgICAgdmFsdWUgaW5zdGFuY2VvZiBOdW1iZXIgfHxcbiAgICAgICAgdmFsdWUgaW5zdGFuY2VvZiBCb29sZWFuIHx8XG4gICAgICAgICh0eXBlb2YgQmlnSW50ID09PSAnZnVuY3Rpb24nICYmIHZhbHVlIGluc3RhbmNlb2YgQmlnSW50KSAvLyBub3Qgc3VwcG9ydGVkIGV2ZXJ5d2hlcmVcbiAgICApIHtcbiAgICAgICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1zZXJpYWxpemVqc29ucHJvcGVydHlcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS52YWx1ZU9mKCk7XG4gICAgfVxuICAgIGNvbnN0IHsgYWxpYXNEdXBsaWNhdGVPYmplY3RzLCBvbkFuY2hvciwgb25UYWdPYmosIHNjaGVtYSwgc291cmNlT2JqZWN0cyB9ID0gY3R4O1xuICAgIC8vIERldGVjdCBkdXBsaWNhdGUgcmVmZXJlbmNlcyB0byB0aGUgc2FtZSBvYmplY3QgJiB1c2UgQWxpYXMgbm9kZXMgZm9yIGFsbFxuICAgIC8vIGFmdGVyIGZpcnN0LiBUaGUgYHJlZmAgd3JhcHBlciBhbGxvd3MgZm9yIGNpcmN1bGFyIHJlZmVyZW5jZXMgdG8gcmVzb2x2ZS5cbiAgICBsZXQgcmVmID0gdW5kZWZpbmVkO1xuICAgIGlmIChhbGlhc0R1cGxpY2F0ZU9iamVjdHMgJiYgdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgICAgICByZWYgPSBzb3VyY2VPYmplY3RzLmdldCh2YWx1ZSk7XG4gICAgICAgIGlmIChyZWYpIHtcbiAgICAgICAgICAgIGlmICghcmVmLmFuY2hvcilcbiAgICAgICAgICAgICAgICByZWYuYW5jaG9yID0gb25BbmNob3IodmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBBbGlhcyhyZWYuYW5jaG9yKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlZiA9IHsgYW5jaG9yOiBudWxsLCBub2RlOiBudWxsIH07XG4gICAgICAgICAgICBzb3VyY2VPYmplY3RzLnNldCh2YWx1ZSwgcmVmKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAodGFnTmFtZSAmJiB0YWdOYW1lLnN0YXJ0c1dpdGgoJyEhJykpXG4gICAgICAgIHRhZ05hbWUgPSBkZWZhdWx0VGFnUHJlZml4ICsgdGFnTmFtZS5zbGljZSgyKTtcbiAgICBsZXQgdGFnT2JqID0gZmluZFRhZ09iamVjdCh2YWx1ZSwgdGFnTmFtZSwgc2NoZW1hLnRhZ3MpO1xuICAgIGlmICghdGFnT2JqKSB7XG4gICAgICAgIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUudG9KU09OID09PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS50b0pTT04oKTtcbiAgICAgICAgaWYgKCF2YWx1ZSB8fCB0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBjb25zdCBub2RlID0gbmV3IFNjYWxhcih2YWx1ZSk7XG4gICAgICAgICAgICBpZiAocmVmKVxuICAgICAgICAgICAgICAgIHJlZi5ub2RlID0gbm9kZTtcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICB9XG4gICAgICAgIHRhZ09iaiA9XG4gICAgICAgICAgICB2YWx1ZSBpbnN0YW5jZW9mIE1hcFxuICAgICAgICAgICAgICAgID8gc2NoZW1hW01BUF1cbiAgICAgICAgICAgICAgICA6IFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QodmFsdWUpXG4gICAgICAgICAgICAgICAgICAgID8gc2NoZW1hW1NFUV1cbiAgICAgICAgICAgICAgICAgICAgOiBzY2hlbWFbTUFQXTtcbiAgICB9XG4gICAgaWYgKG9uVGFnT2JqKSB7XG4gICAgICAgIG9uVGFnT2JqKHRhZ09iaik7XG4gICAgICAgIGRlbGV0ZSBjdHgub25UYWdPYmo7XG4gICAgfVxuICAgIGNvbnN0IG5vZGUgPSAodGFnT2JqID09PSBudWxsIHx8IHRhZ09iaiA9PT0gdm9pZCAwID8gdm9pZCAwIDogdGFnT2JqLmNyZWF0ZU5vZGUpXG4gICAgICAgID8gdGFnT2JqLmNyZWF0ZU5vZGUoY3R4LnNjaGVtYSwgdmFsdWUsIGN0eClcbiAgICAgICAgOiBuZXcgU2NhbGFyKHZhbHVlKTtcbiAgICBpZiAodGFnTmFtZSlcbiAgICAgICAgbm9kZS50YWcgPSB0YWdOYW1lO1xuICAgIGlmIChyZWYpXG4gICAgICAgIHJlZi5ub2RlID0gbm9kZTtcbiAgICByZXR1cm4gbm9kZTtcbn1cblxuZXhwb3J0IHsgY3JlYXRlTm9kZSB9O1xuIiwgImltcG9ydCB7IGNyZWF0ZU5vZGUgfSBmcm9tICcuLi9kb2MvY3JlYXRlTm9kZS5qcyc7XG5pbXBvcnQgeyBOb2RlQmFzZSwgaXNOb2RlLCBpc1BhaXIsIGlzQ29sbGVjdGlvbiwgaXNTY2FsYXIgfSBmcm9tICcuL05vZGUuanMnO1xuXG5mdW5jdGlvbiBjb2xsZWN0aW9uRnJvbVBhdGgoc2NoZW1hLCBwYXRoLCB2YWx1ZSkge1xuICAgIGxldCB2ID0gdmFsdWU7XG4gICAgZm9yIChsZXQgaSA9IHBhdGgubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgY29uc3QgayA9IHBhdGhbaV07XG4gICAgICAgIGlmICh0eXBlb2YgayA9PT0gJ251bWJlcicgJiYgTnVtYmVyLmlzSW50ZWdlcihrKSAmJiBrID49IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGEgPSBbXTtcbiAgICAgICAgICAgIGFba10gPSB2O1xuICAgICAgICAgICAgdiA9IGE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2ID0gbmV3IE1hcChbW2ssIHZdXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZU5vZGUodiwgdW5kZWZpbmVkLCB7XG4gICAgICAgIGFsaWFzRHVwbGljYXRlT2JqZWN0czogZmFsc2UsXG4gICAgICAgIGtlZXBVbmRlZmluZWQ6IGZhbHNlLFxuICAgICAgICBvbkFuY2hvcjogKCkgPT4ge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIHNob3VsZCBub3QgaGFwcGVuLCBwbGVhc2UgcmVwb3J0IGEgYnVnLicpO1xuICAgICAgICB9LFxuICAgICAgICBzY2hlbWEsXG4gICAgICAgIHNvdXJjZU9iamVjdHM6IG5ldyBNYXAoKVxuICAgIH0pO1xufVxuLy8gbnVsbCwgdW5kZWZpbmVkLCBvciBhbiBlbXB0eSBub24tc3RyaW5nIGl0ZXJhYmxlIChlLmcuIFtdKVxuY29uc3QgaXNFbXB0eVBhdGggPSAocGF0aCkgPT4gcGF0aCA9PSBudWxsIHx8XG4gICAgKHR5cGVvZiBwYXRoID09PSAnb2JqZWN0JyAmJiAhIXBhdGhbU3ltYm9sLml0ZXJhdG9yXSgpLm5leHQoKS5kb25lKTtcbmNsYXNzIENvbGxlY3Rpb24gZXh0ZW5kcyBOb2RlQmFzZSB7XG4gICAgY29uc3RydWN0b3IodHlwZSwgc2NoZW1hKSB7XG4gICAgICAgIHN1cGVyKHR5cGUpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3NjaGVtYScsIHtcbiAgICAgICAgICAgIHZhbHVlOiBzY2hlbWEsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBjb3B5IG9mIHRoaXMgY29sbGVjdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzY2hlbWEgLSBJZiBkZWZpbmVkLCBvdmVyd3JpdGVzIHRoZSBvcmlnaW5hbCdzIHNjaGVtYVxuICAgICAqL1xuICAgIGNsb25lKHNjaGVtYSkge1xuICAgICAgICBjb25zdCBjb3B5ID0gT2JqZWN0LmNyZWF0ZShPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcyksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHRoaXMpKTtcbiAgICAgICAgaWYgKHNjaGVtYSlcbiAgICAgICAgICAgIGNvcHkuc2NoZW1hID0gc2NoZW1hO1xuICAgICAgICBjb3B5Lml0ZW1zID0gY29weS5pdGVtcy5tYXAoaXQgPT4gaXNOb2RlKGl0KSB8fCBpc1BhaXIoaXQpID8gaXQuY2xvbmUoc2NoZW1hKSA6IGl0KTtcbiAgICAgICAgaWYgKHRoaXMucmFuZ2UpXG4gICAgICAgICAgICBjb3B5LnJhbmdlID0gdGhpcy5yYW5nZS5zbGljZSgpO1xuICAgICAgICByZXR1cm4gY29weTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBhIHZhbHVlIHRvIHRoZSBjb2xsZWN0aW9uLiBGb3IgYCEhbWFwYCBhbmQgYCEhb21hcGAgdGhlIHZhbHVlIG11c3RcbiAgICAgKiBiZSBhIFBhaXIgaW5zdGFuY2Ugb3IgYSBgeyBrZXksIHZhbHVlIH1gIG9iamVjdCwgd2hpY2ggbWF5IG5vdCBoYXZlIGEga2V5XG4gICAgICogdGhhdCBhbHJlYWR5IGV4aXN0cyBpbiB0aGUgbWFwLlxuICAgICAqL1xuICAgIGFkZEluKHBhdGgsIHZhbHVlKSB7XG4gICAgICAgIGlmIChpc0VtcHR5UGF0aChwYXRoKSlcbiAgICAgICAgICAgIHRoaXMuYWRkKHZhbHVlKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBba2V5LCAuLi5yZXN0XSA9IHBhdGg7XG4gICAgICAgICAgICBjb25zdCBub2RlID0gdGhpcy5nZXQoa2V5LCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChpc0NvbGxlY3Rpb24obm9kZSkpXG4gICAgICAgICAgICAgICAgbm9kZS5hZGRJbihyZXN0LCB2YWx1ZSk7XG4gICAgICAgICAgICBlbHNlIGlmIChub2RlID09PSB1bmRlZmluZWQgJiYgdGhpcy5zY2hlbWEpXG4gICAgICAgICAgICAgICAgdGhpcy5zZXQoa2V5LCBjb2xsZWN0aW9uRnJvbVBhdGgodGhpcy5zY2hlbWEsIHJlc3QsIHZhbHVlKSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBZQU1MIGNvbGxlY3Rpb24gYXQgJHtrZXl9LiBSZW1haW5pbmcgcGF0aDogJHtyZXN0fWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYSB2YWx1ZSBmcm9tIHRoZSBjb2xsZWN0aW9uLlxuICAgICAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgaXRlbSB3YXMgZm91bmQgYW5kIHJlbW92ZWQuXG4gICAgICovXG4gICAgZGVsZXRlSW4ocGF0aCkge1xuICAgICAgICBjb25zdCBba2V5LCAuLi5yZXN0XSA9IHBhdGg7XG4gICAgICAgIGlmIChyZXN0Lmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRlbGV0ZShrZXkpO1xuICAgICAgICBjb25zdCBub2RlID0gdGhpcy5nZXQoa2V5LCB0cnVlKTtcbiAgICAgICAgaWYgKGlzQ29sbGVjdGlvbihub2RlKSlcbiAgICAgICAgICAgIHJldHVybiBub2RlLmRlbGV0ZUluKHJlc3QpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIFlBTUwgY29sbGVjdGlvbiBhdCAke2tleX0uIFJlbWFpbmluZyBwYXRoOiAke3Jlc3R9YCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgaXRlbSBhdCBga2V5YCwgb3IgYHVuZGVmaW5lZGAgaWYgbm90IGZvdW5kLiBCeSBkZWZhdWx0IHVud3JhcHNcbiAgICAgKiBzY2FsYXIgdmFsdWVzIGZyb20gdGhlaXIgc3Vycm91bmRpbmcgbm9kZTsgdG8gZGlzYWJsZSBzZXQgYGtlZXBTY2FsYXJgIHRvXG4gICAgICogYHRydWVgIChjb2xsZWN0aW9ucyBhcmUgYWx3YXlzIHJldHVybmVkIGludGFjdCkuXG4gICAgICovXG4gICAgZ2V0SW4ocGF0aCwga2VlcFNjYWxhcikge1xuICAgICAgICBjb25zdCBba2V5LCAuLi5yZXN0XSA9IHBhdGg7XG4gICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLmdldChrZXksIHRydWUpO1xuICAgICAgICBpZiAocmVzdC5sZW5ndGggPT09IDApXG4gICAgICAgICAgICByZXR1cm4gIWtlZXBTY2FsYXIgJiYgaXNTY2FsYXIobm9kZSkgPyBub2RlLnZhbHVlIDogbm9kZTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIGlzQ29sbGVjdGlvbihub2RlKSA/IG5vZGUuZ2V0SW4ocmVzdCwga2VlcFNjYWxhcikgOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGhhc0FsbE51bGxWYWx1ZXMoYWxsb3dTY2FsYXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXRlbXMuZXZlcnkobm9kZSA9PiB7XG4gICAgICAgICAgICBpZiAoIWlzUGFpcihub2RlKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBjb25zdCBuID0gbm9kZS52YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiAobiA9PSBudWxsIHx8XG4gICAgICAgICAgICAgICAgKGFsbG93U2NhbGFyICYmXG4gICAgICAgICAgICAgICAgICAgIGlzU2NhbGFyKG4pICYmXG4gICAgICAgICAgICAgICAgICAgIG4udmFsdWUgPT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgICAgICAhbi5jb21tZW50QmVmb3JlICYmXG4gICAgICAgICAgICAgICAgICAgICFuLmNvbW1lbnQgJiZcbiAgICAgICAgICAgICAgICAgICAgIW4udGFnKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGhlIGNvbGxlY3Rpb24gaW5jbHVkZXMgYSB2YWx1ZSB3aXRoIHRoZSBrZXkgYGtleWAuXG4gICAgICovXG4gICAgaGFzSW4ocGF0aCkge1xuICAgICAgICBjb25zdCBba2V5LCAuLi5yZXN0XSA9IHBhdGg7XG4gICAgICAgIGlmIChyZXN0Lmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmhhcyhrZXkpO1xuICAgICAgICBjb25zdCBub2RlID0gdGhpcy5nZXQoa2V5LCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIGlzQ29sbGVjdGlvbihub2RlKSA/IG5vZGUuaGFzSW4ocmVzdCkgOiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyBhIHZhbHVlIGluIHRoaXMgY29sbGVjdGlvbi4gRm9yIGAhIXNldGAsIGB2YWx1ZWAgbmVlZHMgdG8gYmUgYVxuICAgICAqIGJvb2xlYW4gdG8gYWRkL3JlbW92ZSB0aGUgaXRlbSBmcm9tIHRoZSBzZXQuXG4gICAgICovXG4gICAgc2V0SW4ocGF0aCwgdmFsdWUpIHtcbiAgICAgICAgY29uc3QgW2tleSwgLi4ucmVzdF0gPSBwYXRoO1xuICAgICAgICBpZiAocmVzdC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuZ2V0KGtleSwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAoaXNDb2xsZWN0aW9uKG5vZGUpKVxuICAgICAgICAgICAgICAgIG5vZGUuc2V0SW4ocmVzdCwgdmFsdWUpO1xuICAgICAgICAgICAgZWxzZSBpZiAobm9kZSA9PT0gdW5kZWZpbmVkICYmIHRoaXMuc2NoZW1hKVxuICAgICAgICAgICAgICAgIHRoaXMuc2V0KGtleSwgY29sbGVjdGlvbkZyb21QYXRoKHRoaXMuc2NoZW1hLCByZXN0LCB2YWx1ZSkpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgWUFNTCBjb2xsZWN0aW9uIGF0ICR7a2V5fS4gUmVtYWluaW5nIHBhdGg6ICR7cmVzdH1gKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbkNvbGxlY3Rpb24ubWF4Rmxvd1N0cmluZ1NpbmdsZUxpbmVMZW5ndGggPSA2MDtcblxuZXhwb3J0IHsgQ29sbGVjdGlvbiwgY29sbGVjdGlvbkZyb21QYXRoLCBpc0VtcHR5UGF0aCB9O1xuIiwgIi8qKlxuICogU3RyaW5naWZpZXMgYSBjb21tZW50LlxuICpcbiAqIEVtcHR5IGNvbW1lbnQgbGluZXMgYXJlIGxlZnQgZW1wdHksXG4gKiBsaW5lcyBjb25zaXN0aW5nIG9mIGEgc2luZ2xlIHNwYWNlIGFyZSByZXBsYWNlZCBieSBgI2AsXG4gKiBhbmQgYWxsIG90aGVyIGxpbmVzIGFyZSBwcmVmaXhlZCB3aXRoIGEgYCNgLlxuICovXG5jb25zdCBzdHJpbmdpZnlDb21tZW50ID0gKHN0cikgPT4gc3RyLnJlcGxhY2UoL14oPyEkKSg/OiAkKT8vZ20sICcjJyk7XG5mdW5jdGlvbiBpbmRlbnRDb21tZW50KGNvbW1lbnQsIGluZGVudCkge1xuICAgIGlmICgvXlxcbiskLy50ZXN0KGNvbW1lbnQpKVxuICAgICAgICByZXR1cm4gY29tbWVudC5zdWJzdHJpbmcoMSk7XG4gICAgcmV0dXJuIGluZGVudCA/IGNvbW1lbnQucmVwbGFjZSgvXig/ISAqJCkvZ20sIGluZGVudCkgOiBjb21tZW50O1xufVxuY29uc3QgbGluZUNvbW1lbnQgPSAoc3RyLCBpbmRlbnQsIGNvbW1lbnQpID0+IGNvbW1lbnQuaW5jbHVkZXMoJ1xcbicpXG4gICAgPyAnXFxuJyArIGluZGVudENvbW1lbnQoY29tbWVudCwgaW5kZW50KVxuICAgIDogKHN0ci5lbmRzV2l0aCgnICcpID8gJycgOiAnICcpICsgY29tbWVudDtcblxuZXhwb3J0IHsgaW5kZW50Q29tbWVudCwgbGluZUNvbW1lbnQsIHN0cmluZ2lmeUNvbW1lbnQgfTtcbiIsICJjb25zdCBGT0xEX0ZMT1cgPSAnZmxvdyc7XG5jb25zdCBGT0xEX0JMT0NLID0gJ2Jsb2NrJztcbmNvbnN0IEZPTERfUVVPVEVEID0gJ3F1b3RlZCc7XG4vKipcbiAqIFRyaWVzIHRvIGtlZXAgaW5wdXQgYXQgdXAgdG8gYGxpbmVXaWR0aGAgY2hhcmFjdGVycywgc3BsaXR0aW5nIG9ubHkgb24gc3BhY2VzXG4gKiBub3QgZm9sbG93ZWQgYnkgbmV3bGluZXMgb3Igc3BhY2VzIHVubGVzcyBgbW9kZWAgaXMgYCdxdW90ZWQnYC4gTGluZXMgYXJlXG4gKiB0ZXJtaW5hdGVkIHdpdGggYFxcbmAgYW5kIHN0YXJ0ZWQgd2l0aCBgaW5kZW50YC5cbiAqL1xuZnVuY3Rpb24gZm9sZEZsb3dMaW5lcyh0ZXh0LCBpbmRlbnQsIG1vZGUgPSAnZmxvdycsIHsgaW5kZW50QXRTdGFydCwgbGluZVdpZHRoID0gODAsIG1pbkNvbnRlbnRXaWR0aCA9IDIwLCBvbkZvbGQsIG9uT3ZlcmZsb3cgfSA9IHt9KSB7XG4gICAgaWYgKCFsaW5lV2lkdGggfHwgbGluZVdpZHRoIDwgMClcbiAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgY29uc3QgZW5kU3RlcCA9IE1hdGgubWF4KDEgKyBtaW5Db250ZW50V2lkdGgsIDEgKyBsaW5lV2lkdGggLSBpbmRlbnQubGVuZ3RoKTtcbiAgICBpZiAodGV4dC5sZW5ndGggPD0gZW5kU3RlcClcbiAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgY29uc3QgZm9sZHMgPSBbXTtcbiAgICBjb25zdCBlc2NhcGVkRm9sZHMgPSB7fTtcbiAgICBsZXQgZW5kID0gbGluZVdpZHRoIC0gaW5kZW50Lmxlbmd0aDtcbiAgICBpZiAodHlwZW9mIGluZGVudEF0U3RhcnQgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGlmIChpbmRlbnRBdFN0YXJ0ID4gbGluZVdpZHRoIC0gTWF0aC5tYXgoMiwgbWluQ29udGVudFdpZHRoKSlcbiAgICAgICAgICAgIGZvbGRzLnB1c2goMCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGVuZCA9IGxpbmVXaWR0aCAtIGluZGVudEF0U3RhcnQ7XG4gICAgfVxuICAgIGxldCBzcGxpdCA9IHVuZGVmaW5lZDtcbiAgICBsZXQgcHJldiA9IHVuZGVmaW5lZDtcbiAgICBsZXQgb3ZlcmZsb3cgPSBmYWxzZTtcbiAgICBsZXQgaSA9IC0xO1xuICAgIGxldCBlc2NTdGFydCA9IC0xO1xuICAgIGxldCBlc2NFbmQgPSAtMTtcbiAgICBpZiAobW9kZSA9PT0gRk9MRF9CTE9DSykge1xuICAgICAgICBpID0gY29uc3VtZU1vcmVJbmRlbnRlZExpbmVzKHRleHQsIGkpO1xuICAgICAgICBpZiAoaSAhPT0gLTEpXG4gICAgICAgICAgICBlbmQgPSBpICsgZW5kU3RlcDtcbiAgICB9XG4gICAgZm9yIChsZXQgY2g7IChjaCA9IHRleHRbKGkgKz0gMSldKTspIHtcbiAgICAgICAgaWYgKG1vZGUgPT09IEZPTERfUVVPVEVEICYmIGNoID09PSAnXFxcXCcpIHtcbiAgICAgICAgICAgIGVzY1N0YXJ0ID0gaTtcbiAgICAgICAgICAgIHN3aXRjaCAodGV4dFtpICsgMV0pIHtcbiAgICAgICAgICAgICAgICBjYXNlICd4JzpcbiAgICAgICAgICAgICAgICAgICAgaSArPSAzO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICd1JzpcbiAgICAgICAgICAgICAgICAgICAgaSArPSA1O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdVJzpcbiAgICAgICAgICAgICAgICAgICAgaSArPSA5O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBpICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlc2NFbmQgPSBpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaCA9PT0gJ1xcbicpIHtcbiAgICAgICAgICAgIGlmIChtb2RlID09PSBGT0xEX0JMT0NLKVxuICAgICAgICAgICAgICAgIGkgPSBjb25zdW1lTW9yZUluZGVudGVkTGluZXModGV4dCwgaSk7XG4gICAgICAgICAgICBlbmQgPSBpICsgZW5kU3RlcDtcbiAgICAgICAgICAgIHNwbGl0ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGNoID09PSAnICcgJiZcbiAgICAgICAgICAgICAgICBwcmV2ICYmXG4gICAgICAgICAgICAgICAgcHJldiAhPT0gJyAnICYmXG4gICAgICAgICAgICAgICAgcHJldiAhPT0gJ1xcbicgJiZcbiAgICAgICAgICAgICAgICBwcmV2ICE9PSAnXFx0Jykge1xuICAgICAgICAgICAgICAgIC8vIHNwYWNlIHN1cnJvdW5kZWQgYnkgbm9uLXNwYWNlIGNhbiBiZSByZXBsYWNlZCB3aXRoIG5ld2xpbmUgKyBpbmRlbnRcbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0ID0gdGV4dFtpICsgMV07XG4gICAgICAgICAgICAgICAgaWYgKG5leHQgJiYgbmV4dCAhPT0gJyAnICYmIG5leHQgIT09ICdcXG4nICYmIG5leHQgIT09ICdcXHQnKVxuICAgICAgICAgICAgICAgICAgICBzcGxpdCA9IGk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaSA+PSBlbmQpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3BsaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9sZHMucHVzaChzcGxpdCk7XG4gICAgICAgICAgICAgICAgICAgIGVuZCA9IHNwbGl0ICsgZW5kU3RlcDtcbiAgICAgICAgICAgICAgICAgICAgc3BsaXQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1vZGUgPT09IEZPTERfUVVPVEVEKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHdoaXRlLXNwYWNlIGNvbGxlY3RlZCBhdCBlbmQgbWF5IHN0cmV0Y2ggcGFzdCBsaW5lV2lkdGhcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHByZXYgPT09ICcgJyB8fCBwcmV2ID09PSAnXFx0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJldiA9IGNoO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2ggPSB0ZXh0WyhpICs9IDEpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJmbG93ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBBY2NvdW50IGZvciBuZXdsaW5lIGVzY2FwZSwgYnV0IGRvbid0IGJyZWFrIHByZWNlZGluZyBlc2NhcGVcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaiA9IGkgPiBlc2NFbmQgKyAxID8gaSAtIDIgOiBlc2NTdGFydCAtIDE7XG4gICAgICAgICAgICAgICAgICAgIC8vIEJhaWwgb3V0IGlmIGxpbmVXaWR0aCAmIG1pbkNvbnRlbnRXaWR0aCBhcmUgc2hvcnRlciB0aGFuIGFuIGVzY2FwZSBzdHJpbmdcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVzY2FwZWRGb2xkc1tqXSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0ZXh0O1xuICAgICAgICAgICAgICAgICAgICBmb2xkcy5wdXNoKGopO1xuICAgICAgICAgICAgICAgICAgICBlc2NhcGVkRm9sZHNbal0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBlbmQgPSBqICsgZW5kU3RlcDtcbiAgICAgICAgICAgICAgICAgICAgc3BsaXQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBvdmVyZmxvdyA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHByZXYgPSBjaDtcbiAgICB9XG4gICAgaWYgKG92ZXJmbG93ICYmIG9uT3ZlcmZsb3cpXG4gICAgICAgIG9uT3ZlcmZsb3coKTtcbiAgICBpZiAoZm9sZHMubGVuZ3RoID09PSAwKVxuICAgICAgICByZXR1cm4gdGV4dDtcbiAgICBpZiAob25Gb2xkKVxuICAgICAgICBvbkZvbGQoKTtcbiAgICBsZXQgcmVzID0gdGV4dC5zbGljZSgwLCBmb2xkc1swXSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmb2xkcy5sZW5ndGg7ICsraSkge1xuICAgICAgICBjb25zdCBmb2xkID0gZm9sZHNbaV07XG4gICAgICAgIGNvbnN0IGVuZCA9IGZvbGRzW2kgKyAxXSB8fCB0ZXh0Lmxlbmd0aDtcbiAgICAgICAgaWYgKGZvbGQgPT09IDApXG4gICAgICAgICAgICByZXMgPSBgXFxuJHtpbmRlbnR9JHt0ZXh0LnNsaWNlKDAsIGVuZCl9YDtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAobW9kZSA9PT0gRk9MRF9RVU9URUQgJiYgZXNjYXBlZEZvbGRzW2ZvbGRdKVxuICAgICAgICAgICAgICAgIHJlcyArPSBgJHt0ZXh0W2ZvbGRdfVxcXFxgO1xuICAgICAgICAgICAgcmVzICs9IGBcXG4ke2luZGVudH0ke3RleHQuc2xpY2UoZm9sZCArIDEsIGVuZCl9YDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuLyoqXG4gKiBQcmVzdW1lcyBgaSArIDFgIGlzIGF0IHRoZSBzdGFydCBvZiBhIGxpbmVcbiAqIEByZXR1cm5zIGluZGV4IG9mIGxhc3QgbmV3bGluZSBpbiBtb3JlLWluZGVudGVkIGJsb2NrXG4gKi9cbmZ1bmN0aW9uIGNvbnN1bWVNb3JlSW5kZW50ZWRMaW5lcyh0ZXh0LCBpKSB7XG4gICAgbGV0IGNoID0gdGV4dFtpICsgMV07XG4gICAgd2hpbGUgKGNoID09PSAnICcgfHwgY2ggPT09ICdcXHQnKSB7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIGNoID0gdGV4dFsoaSArPSAxKV07XG4gICAgICAgIH0gd2hpbGUgKGNoICYmIGNoICE9PSAnXFxuJyk7XG4gICAgICAgIGNoID0gdGV4dFtpICsgMV07XG4gICAgfVxuICAgIHJldHVybiBpO1xufVxuXG5leHBvcnQgeyBGT0xEX0JMT0NLLCBGT0xEX0ZMT1csIEZPTERfUVVPVEVELCBmb2xkRmxvd0xpbmVzIH07XG4iLCAiaW1wb3J0IHsgU2NhbGFyIH0gZnJvbSAnLi4vbm9kZXMvU2NhbGFyLmpzJztcbmltcG9ydCB7IGZvbGRGbG93TGluZXMsIEZPTERfUVVPVEVELCBGT0xEX0ZMT1csIEZPTERfQkxPQ0sgfSBmcm9tICcuL2ZvbGRGbG93TGluZXMuanMnO1xuXG5jb25zdCBnZXRGb2xkT3B0aW9ucyA9IChjdHgpID0+ICh7XG4gICAgaW5kZW50QXRTdGFydDogY3R4LmluZGVudEF0U3RhcnQsXG4gICAgbGluZVdpZHRoOiBjdHgub3B0aW9ucy5saW5lV2lkdGgsXG4gICAgbWluQ29udGVudFdpZHRoOiBjdHgub3B0aW9ucy5taW5Db250ZW50V2lkdGhcbn0pO1xuLy8gQWxzbyBjaGVja3MgZm9yIGxpbmVzIHN0YXJ0aW5nIHdpdGggJSwgYXMgcGFyc2luZyB0aGUgb3V0cHV0IGFzIFlBTUwgMS4xIHdpbGxcbi8vIHByZXN1bWUgdGhhdCdzIHN0YXJ0aW5nIGEgbmV3IGRvY3VtZW50LlxuY29uc3QgY29udGFpbnNEb2N1bWVudE1hcmtlciA9IChzdHIpID0+IC9eKCV8LS0tfFxcLlxcLlxcLikvbS50ZXN0KHN0cik7XG5mdW5jdGlvbiBsaW5lTGVuZ3RoT3ZlckxpbWl0KHN0ciwgbGluZVdpZHRoLCBpbmRlbnRMZW5ndGgpIHtcbiAgICBpZiAoIWxpbmVXaWR0aCB8fCBsaW5lV2lkdGggPCAwKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgY29uc3QgbGltaXQgPSBsaW5lV2lkdGggLSBpbmRlbnRMZW5ndGg7XG4gICAgY29uc3Qgc3RyTGVuID0gc3RyLmxlbmd0aDtcbiAgICBpZiAoc3RyTGVuIDw9IGxpbWl0KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgZm9yIChsZXQgaSA9IDAsIHN0YXJ0ID0gMDsgaSA8IHN0ckxlbjsgKytpKSB7XG4gICAgICAgIGlmIChzdHJbaV0gPT09ICdcXG4nKSB7XG4gICAgICAgICAgICBpZiAoaSAtIHN0YXJ0ID4gbGltaXQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBzdGFydCA9IGkgKyAxO1xuICAgICAgICAgICAgaWYgKHN0ckxlbiAtIHN0YXJ0IDw9IGxpbWl0KVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGRvdWJsZVF1b3RlZFN0cmluZyh2YWx1ZSwgY3R4KSB7XG4gICAgY29uc3QganNvbiA9IEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcbiAgICBpZiAoY3R4Lm9wdGlvbnMuZG91YmxlUXVvdGVkQXNKU09OKVxuICAgICAgICByZXR1cm4ganNvbjtcbiAgICBjb25zdCB7IGltcGxpY2l0S2V5IH0gPSBjdHg7XG4gICAgY29uc3QgbWluTXVsdGlMaW5lTGVuZ3RoID0gY3R4Lm9wdGlvbnMuZG91YmxlUXVvdGVkTWluTXVsdGlMaW5lTGVuZ3RoO1xuICAgIGNvbnN0IGluZGVudCA9IGN0eC5pbmRlbnQgfHwgKGNvbnRhaW5zRG9jdW1lbnRNYXJrZXIodmFsdWUpID8gJyAgJyA6ICcnKTtcbiAgICBsZXQgc3RyID0gJyc7XG4gICAgbGV0IHN0YXJ0ID0gMDtcbiAgICBmb3IgKGxldCBpID0gMCwgY2ggPSBqc29uW2ldOyBjaDsgY2ggPSBqc29uWysraV0pIHtcbiAgICAgICAgaWYgKGNoID09PSAnICcgJiYganNvbltpICsgMV0gPT09ICdcXFxcJyAmJiBqc29uW2kgKyAyXSA9PT0gJ24nKSB7XG4gICAgICAgICAgICAvLyBzcGFjZSBiZWZvcmUgbmV3bGluZSBuZWVkcyB0byBiZSBlc2NhcGVkIHRvIG5vdCBiZSBmb2xkZWRcbiAgICAgICAgICAgIHN0ciArPSBqc29uLnNsaWNlKHN0YXJ0LCBpKSArICdcXFxcICc7XG4gICAgICAgICAgICBpICs9IDE7XG4gICAgICAgICAgICBzdGFydCA9IGk7XG4gICAgICAgICAgICBjaCA9ICdcXFxcJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2ggPT09ICdcXFxcJylcbiAgICAgICAgICAgIHN3aXRjaCAoanNvbltpICsgMV0pIHtcbiAgICAgICAgICAgICAgICBjYXNlICd1JzpcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9IGpzb24uc2xpY2Uoc3RhcnQsIGkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY29kZSA9IGpzb24uc3Vic3RyKGkgKyAyLCA0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoY29kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJzAwMDAnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gJ1xcXFwwJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnMDAwNyc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSAnXFxcXGEnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICcwMDBiJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9ICdcXFxcdic7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJzAwMWInOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gJ1xcXFxlJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnMDA4NSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSAnXFxcXE4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICcwMGEwJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9ICdcXFxcXyc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJzIwMjgnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gJ1xcXFxMJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnMjAyOSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSAnXFxcXFAnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29kZS5zdWJzdHIoMCwgMikgPT09ICcwMCcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0gJ1xcXFx4JyArIGNvZGUuc3Vic3RyKDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0ganNvbi5zdWJzdHIoaSwgNik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpICs9IDU7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydCA9IGkgKyAxO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ24nOlxuICAgICAgICAgICAgICAgICAgICBpZiAoaW1wbGljaXRLZXkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIGpzb25baSArIDJdID09PSAnXCInIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBqc29uLmxlbmd0aCA8IG1pbk11bHRpTGluZUxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaSArPSAxO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZm9sZGluZyB3aWxsIGVhdCBmaXJzdCBuZXdsaW5lXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHIgKz0ganNvbi5zbGljZShzdGFydCwgaSkgKyAnXFxuXFxuJztcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChqc29uW2kgKyAyXSA9PT0gJ1xcXFwnICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAganNvbltpICsgM10gPT09ICduJyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpzb25baSArIDRdICE9PSAnXCInKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9ICdcXG4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgKz0gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHN0ciArPSBpbmRlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzcGFjZSBhZnRlciBuZXdsaW5lIG5lZWRzIHRvIGJlIGVzY2FwZWQgdG8gbm90IGJlIGZvbGRlZFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGpzb25baSArIDJdID09PSAnICcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyICs9ICdcXFxcJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gaSArIDE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaSArPSAxO1xuICAgICAgICAgICAgfVxuICAgIH1cbiAgICBzdHIgPSBzdGFydCA/IHN0ciArIGpzb24uc2xpY2Uoc3RhcnQpIDoganNvbjtcbiAgICByZXR1cm4gaW1wbGljaXRLZXlcbiAgICAgICAgPyBzdHJcbiAgICAgICAgOiBmb2xkRmxvd0xpbmVzKHN0ciwgaW5kZW50LCBGT0xEX1FVT1RFRCwgZ2V0Rm9sZE9wdGlvbnMoY3R4KSk7XG59XG5mdW5jdGlvbiBzaW5nbGVRdW90ZWRTdHJpbmcodmFsdWUsIGN0eCkge1xuICAgIGlmIChjdHgub3B0aW9ucy5zaW5nbGVRdW90ZSA9PT0gZmFsc2UgfHxcbiAgICAgICAgKGN0eC5pbXBsaWNpdEtleSAmJiB2YWx1ZS5pbmNsdWRlcygnXFxuJykpIHx8XG4gICAgICAgIC9bIFxcdF1cXG58XFxuWyBcXHRdLy50ZXN0KHZhbHVlKSAvLyBzaW5nbGUgcXVvdGVkIHN0cmluZyBjYW4ndCBoYXZlIGxlYWRpbmcgb3IgdHJhaWxpbmcgd2hpdGVzcGFjZSBhcm91bmQgbmV3bGluZVxuICAgIClcbiAgICAgICAgcmV0dXJuIGRvdWJsZVF1b3RlZFN0cmluZyh2YWx1ZSwgY3R4KTtcbiAgICBjb25zdCBpbmRlbnQgPSBjdHguaW5kZW50IHx8IChjb250YWluc0RvY3VtZW50TWFya2VyKHZhbHVlKSA/ICcgICcgOiAnJyk7XG4gICAgY29uc3QgcmVzID0gXCInXCIgKyB2YWx1ZS5yZXBsYWNlKC8nL2csIFwiJydcIikucmVwbGFjZSgvXFxuKy9nLCBgJCZcXG4ke2luZGVudH1gKSArIFwiJ1wiO1xuICAgIHJldHVybiBjdHguaW1wbGljaXRLZXlcbiAgICAgICAgPyByZXNcbiAgICAgICAgOiBmb2xkRmxvd0xpbmVzKHJlcywgaW5kZW50LCBGT0xEX0ZMT1csIGdldEZvbGRPcHRpb25zKGN0eCkpO1xufVxuZnVuY3Rpb24gcXVvdGVkU3RyaW5nKHZhbHVlLCBjdHgpIHtcbiAgICBjb25zdCB7IHNpbmdsZVF1b3RlIH0gPSBjdHgub3B0aW9ucztcbiAgICBsZXQgcXM7XG4gICAgaWYgKHNpbmdsZVF1b3RlID09PSBmYWxzZSlcbiAgICAgICAgcXMgPSBkb3VibGVRdW90ZWRTdHJpbmc7XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IGhhc0RvdWJsZSA9IHZhbHVlLmluY2x1ZGVzKCdcIicpO1xuICAgICAgICBjb25zdCBoYXNTaW5nbGUgPSB2YWx1ZS5pbmNsdWRlcyhcIidcIik7XG4gICAgICAgIGlmIChoYXNEb3VibGUgJiYgIWhhc1NpbmdsZSlcbiAgICAgICAgICAgIHFzID0gc2luZ2xlUXVvdGVkU3RyaW5nO1xuICAgICAgICBlbHNlIGlmIChoYXNTaW5nbGUgJiYgIWhhc0RvdWJsZSlcbiAgICAgICAgICAgIHFzID0gZG91YmxlUXVvdGVkU3RyaW5nO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBxcyA9IHNpbmdsZVF1b3RlID8gc2luZ2xlUXVvdGVkU3RyaW5nIDogZG91YmxlUXVvdGVkU3RyaW5nO1xuICAgIH1cbiAgICByZXR1cm4gcXModmFsdWUsIGN0eCk7XG59XG5mdW5jdGlvbiBibG9ja1N0cmluZyh7IGNvbW1lbnQsIHR5cGUsIHZhbHVlIH0sIGN0eCwgb25Db21tZW50LCBvbkNob21wS2VlcCkge1xuICAgIGNvbnN0IHsgYmxvY2tRdW90ZSwgY29tbWVudFN0cmluZywgbGluZVdpZHRoIH0gPSBjdHgub3B0aW9ucztcbiAgICAvLyAxLiBCbG9jayBjYW4ndCBlbmQgaW4gd2hpdGVzcGFjZSB1bmxlc3MgdGhlIGxhc3QgbGluZSBpcyBub24tZW1wdHkuXG4gICAgLy8gMi4gU3RyaW5ncyBjb25zaXN0aW5nIG9mIG9ubHkgd2hpdGVzcGFjZSBhcmUgYmVzdCByZW5kZXJlZCBleHBsaWNpdGx5LlxuICAgIGlmICghYmxvY2tRdW90ZSB8fCAvXFxuW1xcdCBdKyQvLnRlc3QodmFsdWUpIHx8IC9eXFxzKiQvLnRlc3QodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBxdW90ZWRTdHJpbmcodmFsdWUsIGN0eCk7XG4gICAgfVxuICAgIGNvbnN0IGluZGVudCA9IGN0eC5pbmRlbnQgfHxcbiAgICAgICAgKGN0eC5mb3JjZUJsb2NrSW5kZW50IHx8IGNvbnRhaW5zRG9jdW1lbnRNYXJrZXIodmFsdWUpID8gJyAgJyA6ICcnKTtcbiAgICBjb25zdCBsaXRlcmFsID0gYmxvY2tRdW90ZSA9PT0gJ2xpdGVyYWwnXG4gICAgICAgID8gdHJ1ZVxuICAgICAgICA6IGJsb2NrUXVvdGUgPT09ICdmb2xkZWQnIHx8IHR5cGUgPT09IFNjYWxhci5CTE9DS19GT0xERURcbiAgICAgICAgICAgID8gZmFsc2VcbiAgICAgICAgICAgIDogdHlwZSA9PT0gU2NhbGFyLkJMT0NLX0xJVEVSQUxcbiAgICAgICAgICAgICAgICA/IHRydWVcbiAgICAgICAgICAgICAgICA6ICFsaW5lTGVuZ3RoT3ZlckxpbWl0KHZhbHVlLCBsaW5lV2lkdGgsIGluZGVudC5sZW5ndGgpO1xuICAgIGlmICghdmFsdWUpXG4gICAgICAgIHJldHVybiBsaXRlcmFsID8gJ3xcXG4nIDogJz5cXG4nO1xuICAgIC8vIGRldGVybWluZSBjaG9tcGluZyBmcm9tIHdoaXRlc3BhY2UgYXQgdmFsdWUgZW5kXG4gICAgbGV0IGNob21wO1xuICAgIGxldCBlbmRTdGFydDtcbiAgICBmb3IgKGVuZFN0YXJ0ID0gdmFsdWUubGVuZ3RoOyBlbmRTdGFydCA+IDA7IC0tZW5kU3RhcnQpIHtcbiAgICAgICAgY29uc3QgY2ggPSB2YWx1ZVtlbmRTdGFydCAtIDFdO1xuICAgICAgICBpZiAoY2ggIT09ICdcXG4nICYmIGNoICE9PSAnXFx0JyAmJiBjaCAhPT0gJyAnKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGxldCBlbmQgPSB2YWx1ZS5zdWJzdHJpbmcoZW5kU3RhcnQpO1xuICAgIGNvbnN0IGVuZE5sUG9zID0gZW5kLmluZGV4T2YoJ1xcbicpO1xuICAgIGlmIChlbmRObFBvcyA9PT0gLTEpIHtcbiAgICAgICAgY2hvbXAgPSAnLSc7IC8vIHN0cmlwXG4gICAgfVxuICAgIGVsc2UgaWYgKHZhbHVlID09PSBlbmQgfHwgZW5kTmxQb3MgIT09IGVuZC5sZW5ndGggLSAxKSB7XG4gICAgICAgIGNob21wID0gJysnOyAvLyBrZWVwXG4gICAgICAgIGlmIChvbkNob21wS2VlcClcbiAgICAgICAgICAgIG9uQ2hvbXBLZWVwKCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjaG9tcCA9ICcnOyAvLyBjbGlwXG4gICAgfVxuICAgIGlmIChlbmQpIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5zbGljZSgwLCAtZW5kLmxlbmd0aCk7XG4gICAgICAgIGlmIChlbmRbZW5kLmxlbmd0aCAtIDFdID09PSAnXFxuJylcbiAgICAgICAgICAgIGVuZCA9IGVuZC5zbGljZSgwLCAtMSk7XG4gICAgICAgIGVuZCA9IGVuZC5yZXBsYWNlKC9cXG4rKD8hXFxufCQpL2csIGAkJiR7aW5kZW50fWApO1xuICAgIH1cbiAgICAvLyBkZXRlcm1pbmUgaW5kZW50IGluZGljYXRvciBmcm9tIHdoaXRlc3BhY2UgYXQgdmFsdWUgc3RhcnRcbiAgICBsZXQgc3RhcnRXaXRoU3BhY2UgPSBmYWxzZTtcbiAgICBsZXQgc3RhcnRFbmQ7XG4gICAgbGV0IHN0YXJ0TmxQb3MgPSAtMTtcbiAgICBmb3IgKHN0YXJ0RW5kID0gMDsgc3RhcnRFbmQgPCB2YWx1ZS5sZW5ndGg7ICsrc3RhcnRFbmQpIHtcbiAgICAgICAgY29uc3QgY2ggPSB2YWx1ZVtzdGFydEVuZF07XG4gICAgICAgIGlmIChjaCA9PT0gJyAnKVxuICAgICAgICAgICAgc3RhcnRXaXRoU3BhY2UgPSB0cnVlO1xuICAgICAgICBlbHNlIGlmIChjaCA9PT0gJ1xcbicpXG4gICAgICAgICAgICBzdGFydE5sUG9zID0gc3RhcnRFbmQ7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBsZXQgc3RhcnQgPSB2YWx1ZS5zdWJzdHJpbmcoMCwgc3RhcnRObFBvcyA8IHN0YXJ0RW5kID8gc3RhcnRObFBvcyArIDEgOiBzdGFydEVuZCk7XG4gICAgaWYgKHN0YXJ0KSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUuc3Vic3RyaW5nKHN0YXJ0Lmxlbmd0aCk7XG4gICAgICAgIHN0YXJ0ID0gc3RhcnQucmVwbGFjZSgvXFxuKy9nLCBgJCYke2luZGVudH1gKTtcbiAgICB9XG4gICAgY29uc3QgaW5kZW50U2l6ZSA9IGluZGVudCA/ICcyJyA6ICcxJzsgLy8gcm9vdCBpcyBhdCAtMVxuICAgIGxldCBoZWFkZXIgPSAobGl0ZXJhbCA/ICd8JyA6ICc+JykgKyAoc3RhcnRXaXRoU3BhY2UgPyBpbmRlbnRTaXplIDogJycpICsgY2hvbXA7XG4gICAgaWYgKGNvbW1lbnQpIHtcbiAgICAgICAgaGVhZGVyICs9ICcgJyArIGNvbW1lbnRTdHJpbmcoY29tbWVudC5yZXBsYWNlKC8gP1tcXHJcXG5dKy9nLCAnICcpKTtcbiAgICAgICAgaWYgKG9uQ29tbWVudClcbiAgICAgICAgICAgIG9uQ29tbWVudCgpO1xuICAgIH1cbiAgICBpZiAobGl0ZXJhbCkge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL1xcbisvZywgYCQmJHtpbmRlbnR9YCk7XG4gICAgICAgIHJldHVybiBgJHtoZWFkZXJ9XFxuJHtpbmRlbnR9JHtzdGFydH0ke3ZhbHVlfSR7ZW5kfWA7XG4gICAgfVxuICAgIHZhbHVlID0gdmFsdWVcbiAgICAgICAgLnJlcGxhY2UoL1xcbisvZywgJ1xcbiQmJylcbiAgICAgICAgLnJlcGxhY2UoLyg/Ol58XFxuKShbXFx0IF0uKikoPzooW1xcblxcdCBdKilcXG4oPyFbXFxuXFx0IF0pKT8vZywgJyQxJDInKSAvLyBtb3JlLWluZGVudGVkIGxpbmVzIGFyZW4ndCBmb2xkZWRcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgXiBtb3JlLWluZC4gXiBlbXB0eSAgICAgXiBjYXB0dXJlIG5leHQgZW1wdHkgbGluZXMgb25seSBhdCBlbmQgb2YgaW5kZW50XG4gICAgICAgIC5yZXBsYWNlKC9cXG4rL2csIGAkJiR7aW5kZW50fWApO1xuICAgIGNvbnN0IGJvZHkgPSBmb2xkRmxvd0xpbmVzKGAke3N0YXJ0fSR7dmFsdWV9JHtlbmR9YCwgaW5kZW50LCBGT0xEX0JMT0NLLCBnZXRGb2xkT3B0aW9ucyhjdHgpKTtcbiAgICByZXR1cm4gYCR7aGVhZGVyfVxcbiR7aW5kZW50fSR7Ym9keX1gO1xufVxuZnVuY3Rpb24gcGxhaW5TdHJpbmcoaXRlbSwgY3R4LCBvbkNvbW1lbnQsIG9uQ2hvbXBLZWVwKSB7XG4gICAgY29uc3QgeyB0eXBlLCB2YWx1ZSB9ID0gaXRlbTtcbiAgICBjb25zdCB7IGFjdHVhbFN0cmluZywgaW1wbGljaXRLZXksIGluZGVudCwgaW5GbG93IH0gPSBjdHg7XG4gICAgaWYgKChpbXBsaWNpdEtleSAmJiAvW1xcbltcXF17fSxdLy50ZXN0KHZhbHVlKSkgfHxcbiAgICAgICAgKGluRmxvdyAmJiAvW1tcXF17fSxdLy50ZXN0KHZhbHVlKSkpIHtcbiAgICAgICAgcmV0dXJuIHF1b3RlZFN0cmluZyh2YWx1ZSwgY3R4KTtcbiAgICB9XG4gICAgaWYgKCF2YWx1ZSB8fFxuICAgICAgICAvXltcXG5cXHQgLFtcXF17fSMmKiF8PidcIiVAYF18Xls/LV0kfF5bPy1dWyBcXHRdfFtcXG46XVsgXFx0XXxbIFxcdF1cXG58W1xcblxcdCBdI3xbXFxuXFx0IDpdJC8udGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgLy8gbm90IGFsbG93ZWQ6XG4gICAgICAgIC8vIC0gZW1wdHkgc3RyaW5nLCAnLScgb3IgJz8nXG4gICAgICAgIC8vIC0gc3RhcnQgd2l0aCBhbiBpbmRpY2F0b3IgY2hhcmFjdGVyIChleGNlcHQgWz86LV0pIG9yIC9bPy1dIC9cbiAgICAgICAgLy8gLSAnXFxuICcsICc6ICcgb3IgJyBcXG4nIGFueXdoZXJlXG4gICAgICAgIC8vIC0gJyMnIG5vdCBwcmVjZWRlZCBieSBhIG5vbi1zcGFjZSBjaGFyXG4gICAgICAgIC8vIC0gZW5kIHdpdGggJyAnIG9yICc6J1xuICAgICAgICByZXR1cm4gaW1wbGljaXRLZXkgfHwgaW5GbG93IHx8IHZhbHVlLmluZGV4T2YoJ1xcbicpID09PSAtMVxuICAgICAgICAgICAgPyBxdW90ZWRTdHJpbmcodmFsdWUsIGN0eClcbiAgICAgICAgICAgIDogYmxvY2tTdHJpbmcoaXRlbSwgY3R4LCBvbkNvbW1lbnQsIG9uQ2hvbXBLZWVwKTtcbiAgICB9XG4gICAgaWYgKCFpbXBsaWNpdEtleSAmJlxuICAgICAgICAhaW5GbG93ICYmXG4gICAgICAgIHR5cGUgIT09IFNjYWxhci5QTEFJTiAmJlxuICAgICAgICB2YWx1ZS5pbmRleE9mKCdcXG4nKSAhPT0gLTEpIHtcbiAgICAgICAgLy8gV2hlcmUgYWxsb3dlZCAmIHR5cGUgbm90IHNldCBleHBsaWNpdGx5LCBwcmVmZXIgYmxvY2sgc3R5bGUgZm9yIG11bHRpbGluZSBzdHJpbmdzXG4gICAgICAgIHJldHVybiBibG9ja1N0cmluZyhpdGVtLCBjdHgsIG9uQ29tbWVudCwgb25DaG9tcEtlZXApO1xuICAgIH1cbiAgICBpZiAoaW5kZW50ID09PSAnJyAmJiBjb250YWluc0RvY3VtZW50TWFya2VyKHZhbHVlKSkge1xuICAgICAgICBjdHguZm9yY2VCbG9ja0luZGVudCA9IHRydWU7XG4gICAgICAgIHJldHVybiBibG9ja1N0cmluZyhpdGVtLCBjdHgsIG9uQ29tbWVudCwgb25DaG9tcEtlZXApO1xuICAgIH1cbiAgICBjb25zdCBzdHIgPSB2YWx1ZS5yZXBsYWNlKC9cXG4rL2csIGAkJlxcbiR7aW5kZW50fWApO1xuICAgIC8vIFZlcmlmeSB0aGF0IG91dHB1dCB3aWxsIGJlIHBhcnNlZCBhcyBhIHN0cmluZywgYXMgZS5nLiBwbGFpbiBudW1iZXJzIGFuZFxuICAgIC8vIGJvb2xlYW5zIGdldCBwYXJzZWQgd2l0aCB0aG9zZSB0eXBlcyBpbiB2MS4yIChlLmcuICc0MicsICd0cnVlJyAmICcwLjllLTMnKSxcbiAgICAvLyBhbmQgb3RoZXJzIGluIHYxLjEuXG4gICAgaWYgKGFjdHVhbFN0cmluZykge1xuICAgICAgICBjb25zdCB0ZXN0ID0gKHRhZykgPT4geyB2YXIgX2E7IHJldHVybiB0YWcuZGVmYXVsdCAmJiB0YWcudGFnICE9PSAndGFnOnlhbWwub3JnLDIwMDI6c3RyJyAmJiAoKF9hID0gdGFnLnRlc3QpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50ZXN0KHN0cikpOyB9O1xuICAgICAgICBjb25zdCB7IGNvbXBhdCwgdGFncyB9ID0gY3R4LmRvYy5zY2hlbWE7XG4gICAgICAgIGlmICh0YWdzLnNvbWUodGVzdCkgfHwgKGNvbXBhdCA9PT0gbnVsbCB8fCBjb21wYXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbXBhdC5zb21lKHRlc3QpKSlcbiAgICAgICAgICAgIHJldHVybiBxdW90ZWRTdHJpbmcodmFsdWUsIGN0eCk7XG4gICAgfVxuICAgIHJldHVybiBpbXBsaWNpdEtleVxuICAgICAgICA/IHN0clxuICAgICAgICA6IGZvbGRGbG93TGluZXMoc3RyLCBpbmRlbnQsIEZPTERfRkxPVywgZ2V0Rm9sZE9wdGlvbnMoY3R4KSk7XG59XG5mdW5jdGlvbiBzdHJpbmdpZnlTdHJpbmcoaXRlbSwgY3R4LCBvbkNvbW1lbnQsIG9uQ2hvbXBLZWVwKSB7XG4gICAgY29uc3QgeyBpbXBsaWNpdEtleSwgaW5GbG93IH0gPSBjdHg7XG4gICAgY29uc3Qgc3MgPSB0eXBlb2YgaXRlbS52YWx1ZSA9PT0gJ3N0cmluZydcbiAgICAgICAgPyBpdGVtXG4gICAgICAgIDogT2JqZWN0LmFzc2lnbih7fSwgaXRlbSwgeyB2YWx1ZTogU3RyaW5nKGl0ZW0udmFsdWUpIH0pO1xuICAgIGxldCB7IHR5cGUgfSA9IGl0ZW07XG4gICAgaWYgKHR5cGUgIT09IFNjYWxhci5RVU9URV9ET1VCTEUpIHtcbiAgICAgICAgLy8gZm9yY2UgZG91YmxlIHF1b3RlcyBvbiBjb250cm9sIGNoYXJhY3RlcnMgJiB1bnBhaXJlZCBzdXJyb2dhdGVzXG4gICAgICAgIGlmICgvW1xceDAwLVxceDA4XFx4MGItXFx4MWZcXHg3Zi1cXHg5ZlxcdXtEODAwfS1cXHV7REZGRn1dL3UudGVzdChzcy52YWx1ZSkpXG4gICAgICAgICAgICB0eXBlID0gU2NhbGFyLlFVT1RFX0RPVUJMRTtcbiAgICB9XG4gICAgY29uc3QgX3N0cmluZ2lmeSA9IChfdHlwZSkgPT4ge1xuICAgICAgICBzd2l0Y2ggKF90eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFNjYWxhci5CTE9DS19GT0xERUQ6XG4gICAgICAgICAgICBjYXNlIFNjYWxhci5CTE9DS19MSVRFUkFMOlxuICAgICAgICAgICAgICAgIHJldHVybiBpbXBsaWNpdEtleSB8fCBpbkZsb3dcbiAgICAgICAgICAgICAgICAgICAgPyBxdW90ZWRTdHJpbmcoc3MudmFsdWUsIGN0eCkgLy8gYmxvY2tzIGFyZSBub3QgdmFsaWQgaW5zaWRlIGZsb3cgY29udGFpbmVyc1xuICAgICAgICAgICAgICAgICAgICA6IGJsb2NrU3RyaW5nKHNzLCBjdHgsIG9uQ29tbWVudCwgb25DaG9tcEtlZXApO1xuICAgICAgICAgICAgY2FzZSBTY2FsYXIuUVVPVEVfRE9VQkxFOlxuICAgICAgICAgICAgICAgIHJldHVybiBkb3VibGVRdW90ZWRTdHJpbmcoc3MudmFsdWUsIGN0eCk7XG4gICAgICAgICAgICBjYXNlIFNjYWxhci5RVU9URV9TSU5HTEU6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNpbmdsZVF1b3RlZFN0cmluZyhzcy52YWx1ZSwgY3R4KTtcbiAgICAgICAgICAgIGNhc2UgU2NhbGFyLlBMQUlOOlxuICAgICAgICAgICAgICAgIHJldHVybiBwbGFpblN0cmluZyhzcywgY3R4LCBvbkNvbW1lbnQsIG9uQ2hvbXBLZWVwKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGxldCByZXMgPSBfc3RyaW5naWZ5KHR5cGUpO1xuICAgIGlmIChyZXMgPT09IG51bGwpIHtcbiAgICAgICAgY29uc3QgeyBkZWZhdWx0S2V5VHlwZSwgZGVmYXVsdFN0cmluZ1R5cGUgfSA9IGN0eC5vcHRpb25zO1xuICAgICAgICBjb25zdCB0ID0gKGltcGxpY2l0S2V5ICYmIGRlZmF1bHRLZXlUeXBlKSB8fCBkZWZhdWx0U3RyaW5nVHlwZTtcbiAgICAgICAgcmVzID0gX3N0cmluZ2lmeSh0KTtcbiAgICAgICAgaWYgKHJlcyA9PT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgZGVmYXVsdCBzdHJpbmcgdHlwZSAke3R9YCk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5cbmV4cG9ydCB7IHN0cmluZ2lmeVN0cmluZyB9O1xuIiwgImltcG9ydCB7IGFuY2hvcklzVmFsaWQgfSBmcm9tICcuLi9kb2MvYW5jaG9ycy5qcyc7XG5pbXBvcnQgeyBpc1BhaXIsIGlzQWxpYXMsIGlzTm9kZSwgaXNTY2FsYXIsIGlzQ29sbGVjdGlvbiB9IGZyb20gJy4uL25vZGVzL05vZGUuanMnO1xuaW1wb3J0IHsgc3RyaW5naWZ5Q29tbWVudCB9IGZyb20gJy4vc3RyaW5naWZ5Q29tbWVudC5qcyc7XG5pbXBvcnQgeyBzdHJpbmdpZnlTdHJpbmcgfSBmcm9tICcuL3N0cmluZ2lmeVN0cmluZy5qcyc7XG5cbmZ1bmN0aW9uIGNyZWF0ZVN0cmluZ2lmeUNvbnRleHQoZG9jLCBvcHRpb25zKSB7XG4gICAgY29uc3Qgb3B0ID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgIGJsb2NrUXVvdGU6IHRydWUsXG4gICAgICAgIGNvbW1lbnRTdHJpbmc6IHN0cmluZ2lmeUNvbW1lbnQsXG4gICAgICAgIGRlZmF1bHRLZXlUeXBlOiBudWxsLFxuICAgICAgICBkZWZhdWx0U3RyaW5nVHlwZTogJ1BMQUlOJyxcbiAgICAgICAgZGlyZWN0aXZlczogbnVsbCxcbiAgICAgICAgZG91YmxlUXVvdGVkQXNKU09OOiBmYWxzZSxcbiAgICAgICAgZG91YmxlUXVvdGVkTWluTXVsdGlMaW5lTGVuZ3RoOiA0MCxcbiAgICAgICAgZmFsc2VTdHI6ICdmYWxzZScsXG4gICAgICAgIGluZGVudFNlcTogdHJ1ZSxcbiAgICAgICAgbGluZVdpZHRoOiA4MCxcbiAgICAgICAgbWluQ29udGVudFdpZHRoOiAyMCxcbiAgICAgICAgbnVsbFN0cjogJ251bGwnLFxuICAgICAgICBzaW1wbGVLZXlzOiBmYWxzZSxcbiAgICAgICAgc2luZ2xlUXVvdGU6IG51bGwsXG4gICAgICAgIHRydWVTdHI6ICd0cnVlJyxcbiAgICAgICAgdmVyaWZ5QWxpYXNPcmRlcjogdHJ1ZVxuICAgIH0sIGRvYy5zY2hlbWEudG9TdHJpbmdPcHRpb25zLCBvcHRpb25zKTtcbiAgICBsZXQgaW5GbG93O1xuICAgIHN3aXRjaCAob3B0LmNvbGxlY3Rpb25TdHlsZSkge1xuICAgICAgICBjYXNlICdibG9jayc6XG4gICAgICAgICAgICBpbkZsb3cgPSBmYWxzZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdmbG93JzpcbiAgICAgICAgICAgIGluRmxvdyA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGluRmxvdyA9IG51bGw7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGFuY2hvcnM6IG5ldyBTZXQoKSxcbiAgICAgICAgZG9jLFxuICAgICAgICBpbmRlbnQ6ICcnLFxuICAgICAgICBpbmRlbnRTdGVwOiB0eXBlb2Ygb3B0LmluZGVudCA9PT0gJ251bWJlcicgPyAnICcucmVwZWF0KG9wdC5pbmRlbnQpIDogJyAgJyxcbiAgICAgICAgaW5GbG93LFxuICAgICAgICBvcHRpb25zOiBvcHRcbiAgICB9O1xufVxuZnVuY3Rpb24gZ2V0VGFnT2JqZWN0KHRhZ3MsIGl0ZW0pIHtcbiAgICBpZiAoaXRlbS50YWcpIHtcbiAgICAgICAgY29uc3QgbWF0Y2ggPSB0YWdzLmZpbHRlcih0ID0+IHQudGFnID09PSBpdGVtLnRhZyk7XG4gICAgICAgIGlmIChtYXRjaC5sZW5ndGggPiAwKVxuICAgICAgICAgICAgcmV0dXJuIG1hdGNoLmZpbmQodCA9PiB0LmZvcm1hdCA9PT0gaXRlbS5mb3JtYXQpIHx8IG1hdGNoWzBdO1xuICAgIH1cbiAgICBsZXQgdGFnT2JqID0gdW5kZWZpbmVkO1xuICAgIGxldCBvYmo7XG4gICAgaWYgKGlzU2NhbGFyKGl0ZW0pKSB7XG4gICAgICAgIG9iaiA9IGl0ZW0udmFsdWU7XG4gICAgICAgIGNvbnN0IG1hdGNoID0gdGFncy5maWx0ZXIodCA9PiB0LmlkZW50aWZ5ICYmIHQuaWRlbnRpZnkob2JqKSk7XG4gICAgICAgIHRhZ09iaiA9XG4gICAgICAgICAgICBtYXRjaC5maW5kKHQgPT4gdC5mb3JtYXQgPT09IGl0ZW0uZm9ybWF0KSB8fCBtYXRjaC5maW5kKHQgPT4gIXQuZm9ybWF0KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIG9iaiA9IGl0ZW07XG4gICAgICAgIHRhZ09iaiA9IHRhZ3MuZmluZCh0ID0+IHQubm9kZUNsYXNzICYmIG9iaiBpbnN0YW5jZW9mIHQubm9kZUNsYXNzKTtcbiAgICB9XG4gICAgaWYgKCF0YWdPYmopIHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBjb25zdCBuYW1lID0gb2JqICYmIG9iai5jb25zdHJ1Y3RvciA/IG9iai5jb25zdHJ1Y3Rvci5uYW1lIDogdHlwZW9mIG9iajtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUYWcgbm90IHJlc29sdmVkIGZvciAke25hbWV9IHZhbHVlYCk7XG4gICAgfVxuICAgIHJldHVybiB0YWdPYmo7XG59XG4vLyBuZWVkcyB0byBiZSBjYWxsZWQgYmVmb3JlIHZhbHVlIHN0cmluZ2lmaWVyIHRvIGFsbG93IGZvciBjaXJjdWxhciBhbmNob3IgcmVmc1xuZnVuY3Rpb24gc3RyaW5naWZ5UHJvcHMobm9kZSwgdGFnT2JqLCB7IGFuY2hvcnMsIGRvYyB9KSB7XG4gICAgaWYgKCFkb2MuZGlyZWN0aXZlcylcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIGNvbnN0IHByb3BzID0gW107XG4gICAgY29uc3QgYW5jaG9yID0gKGlzU2NhbGFyKG5vZGUpIHx8IGlzQ29sbGVjdGlvbihub2RlKSkgJiYgbm9kZS5hbmNob3I7XG4gICAgaWYgKGFuY2hvciAmJiBhbmNob3JJc1ZhbGlkKGFuY2hvcikpIHtcbiAgICAgICAgYW5jaG9ycy5hZGQoYW5jaG9yKTtcbiAgICAgICAgcHJvcHMucHVzaChgJiR7YW5jaG9yfWApO1xuICAgIH1cbiAgICBjb25zdCB0YWcgPSBub2RlLnRhZyB8fCAodGFnT2JqLmRlZmF1bHQgPyBudWxsIDogdGFnT2JqLnRhZyk7XG4gICAgaWYgKHRhZylcbiAgICAgICAgcHJvcHMucHVzaChkb2MuZGlyZWN0aXZlcy50YWdTdHJpbmcodGFnKSk7XG4gICAgcmV0dXJuIHByb3BzLmpvaW4oJyAnKTtcbn1cbmZ1bmN0aW9uIHN0cmluZ2lmeShpdGVtLCBjdHgsIG9uQ29tbWVudCwgb25DaG9tcEtlZXApIHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKGlzUGFpcihpdGVtKSlcbiAgICAgICAgcmV0dXJuIGl0ZW0udG9TdHJpbmcoY3R4LCBvbkNvbW1lbnQsIG9uQ2hvbXBLZWVwKTtcbiAgICBpZiAoaXNBbGlhcyhpdGVtKSkge1xuICAgICAgICBpZiAoY3R4LmRvYy5kaXJlY3RpdmVzKVxuICAgICAgICAgICAgcmV0dXJuIGl0ZW0udG9TdHJpbmcoY3R4KTtcbiAgICAgICAgaWYgKChfYSA9IGN0eC5yZXNvbHZlZEFsaWFzZXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5oYXMoaXRlbSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYENhbm5vdCBzdHJpbmdpZnkgY2lyY3VsYXIgc3RydWN0dXJlIHdpdGhvdXQgYWxpYXMgbm9kZXNgKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChjdHgucmVzb2x2ZWRBbGlhc2VzKVxuICAgICAgICAgICAgICAgIGN0eC5yZXNvbHZlZEFsaWFzZXMuYWRkKGl0ZW0pO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGN0eC5yZXNvbHZlZEFsaWFzZXMgPSBuZXcgU2V0KFtpdGVtXSk7XG4gICAgICAgICAgICBpdGVtID0gaXRlbS5yZXNvbHZlKGN0eC5kb2MpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxldCB0YWdPYmogPSB1bmRlZmluZWQ7XG4gICAgY29uc3Qgbm9kZSA9IGlzTm9kZShpdGVtKVxuICAgICAgICA/IGl0ZW1cbiAgICAgICAgOiBjdHguZG9jLmNyZWF0ZU5vZGUoaXRlbSwgeyBvblRhZ09iajogbyA9PiAodGFnT2JqID0gbykgfSk7XG4gICAgaWYgKCF0YWdPYmopXG4gICAgICAgIHRhZ09iaiA9IGdldFRhZ09iamVjdChjdHguZG9jLnNjaGVtYS50YWdzLCBub2RlKTtcbiAgICBjb25zdCBwcm9wcyA9IHN0cmluZ2lmeVByb3BzKG5vZGUsIHRhZ09iaiwgY3R4KTtcbiAgICBpZiAocHJvcHMubGVuZ3RoID4gMClcbiAgICAgICAgY3R4LmluZGVudEF0U3RhcnQgPSAoY3R4LmluZGVudEF0U3RhcnQgfHwgMCkgKyBwcm9wcy5sZW5ndGggKyAxO1xuICAgIGNvbnN0IHN0ciA9IHR5cGVvZiB0YWdPYmouc3RyaW5naWZ5ID09PSAnZnVuY3Rpb24nXG4gICAgICAgID8gdGFnT2JqLnN0cmluZ2lmeShub2RlLCBjdHgsIG9uQ29tbWVudCwgb25DaG9tcEtlZXApXG4gICAgICAgIDogaXNTY2FsYXIobm9kZSlcbiAgICAgICAgICAgID8gc3RyaW5naWZ5U3RyaW5nKG5vZGUsIGN0eCwgb25Db21tZW50LCBvbkNob21wS2VlcClcbiAgICAgICAgICAgIDogbm9kZS50b1N0cmluZyhjdHgsIG9uQ29tbWVudCwgb25DaG9tcEtlZXApO1xuICAgIGlmICghcHJvcHMpXG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgcmV0dXJuIGlzU2NhbGFyKG5vZGUpIHx8IHN0clswXSA9PT0gJ3snIHx8IHN0clswXSA9PT0gJ1snXG4gICAgICAgID8gYCR7cHJvcHN9ICR7c3RyfWBcbiAgICAgICAgOiBgJHtwcm9wc31cXG4ke2N0eC5pbmRlbnR9JHtzdHJ9YDtcbn1cblxuZXhwb3J0IHsgY3JlYXRlU3RyaW5naWZ5Q29udGV4dCwgc3RyaW5naWZ5IH07XG4iLCAiaW1wb3J0IHsgaXNDb2xsZWN0aW9uLCBpc05vZGUsIGlzU2NhbGFyLCBpc1NlcSB9IGZyb20gJy4uL25vZGVzL05vZGUuanMnO1xuaW1wb3J0IHsgU2NhbGFyIH0gZnJvbSAnLi4vbm9kZXMvU2NhbGFyLmpzJztcbmltcG9ydCB7IHN0cmluZ2lmeSB9IGZyb20gJy4vc3RyaW5naWZ5LmpzJztcbmltcG9ydCB7IGxpbmVDb21tZW50LCBpbmRlbnRDb21tZW50IH0gZnJvbSAnLi9zdHJpbmdpZnlDb21tZW50LmpzJztcblxuZnVuY3Rpb24gc3RyaW5naWZ5UGFpcih7IGtleSwgdmFsdWUgfSwgY3R4LCBvbkNvbW1lbnQsIG9uQ2hvbXBLZWVwKSB7XG4gICAgY29uc3QgeyBhbGxOdWxsVmFsdWVzLCBkb2MsIGluZGVudCwgaW5kZW50U3RlcCwgb3B0aW9uczogeyBjb21tZW50U3RyaW5nLCBpbmRlbnRTZXEsIHNpbXBsZUtleXMgfSB9ID0gY3R4O1xuICAgIGxldCBrZXlDb21tZW50ID0gKGlzTm9kZShrZXkpICYmIGtleS5jb21tZW50KSB8fCBudWxsO1xuICAgIGlmIChzaW1wbGVLZXlzKSB7XG4gICAgICAgIGlmIChrZXlDb21tZW50KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dpdGggc2ltcGxlIGtleXMsIGtleSBub2RlcyBjYW5ub3QgaGF2ZSBjb21tZW50cycpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0NvbGxlY3Rpb24oa2V5KSkge1xuICAgICAgICAgICAgY29uc3QgbXNnID0gJ1dpdGggc2ltcGxlIGtleXMsIGNvbGxlY3Rpb24gY2Fubm90IGJlIHVzZWQgYXMgYSBrZXkgdmFsdWUnO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IGV4cGxpY2l0S2V5ID0gIXNpbXBsZUtleXMgJiZcbiAgICAgICAgKCFrZXkgfHxcbiAgICAgICAgICAgIChrZXlDb21tZW50ICYmIHZhbHVlID09IG51bGwgJiYgIWN0eC5pbkZsb3cpIHx8XG4gICAgICAgICAgICBpc0NvbGxlY3Rpb24oa2V5KSB8fFxuICAgICAgICAgICAgKGlzU2NhbGFyKGtleSlcbiAgICAgICAgICAgICAgICA/IGtleS50eXBlID09PSBTY2FsYXIuQkxPQ0tfRk9MREVEIHx8IGtleS50eXBlID09PSBTY2FsYXIuQkxPQ0tfTElURVJBTFxuICAgICAgICAgICAgICAgIDogdHlwZW9mIGtleSA9PT0gJ29iamVjdCcpKTtcbiAgICBjdHggPSBPYmplY3QuYXNzaWduKHt9LCBjdHgsIHtcbiAgICAgICAgYWxsTnVsbFZhbHVlczogZmFsc2UsXG4gICAgICAgIGltcGxpY2l0S2V5OiAhZXhwbGljaXRLZXkgJiYgKHNpbXBsZUtleXMgfHwgIWFsbE51bGxWYWx1ZXMpLFxuICAgICAgICBpbmRlbnQ6IGluZGVudCArIGluZGVudFN0ZXBcbiAgICB9KTtcbiAgICBsZXQga2V5Q29tbWVudERvbmUgPSBmYWxzZTtcbiAgICBsZXQgY2hvbXBLZWVwID0gZmFsc2U7XG4gICAgbGV0IHN0ciA9IHN0cmluZ2lmeShrZXksIGN0eCwgKCkgPT4gKGtleUNvbW1lbnREb25lID0gdHJ1ZSksICgpID0+IChjaG9tcEtlZXAgPSB0cnVlKSk7XG4gICAgaWYgKCFleHBsaWNpdEtleSAmJiAhY3R4LmluRmxvdyAmJiBzdHIubGVuZ3RoID4gMTAyNCkge1xuICAgICAgICBpZiAoc2ltcGxlS2V5cylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignV2l0aCBzaW1wbGUga2V5cywgc2luZ2xlIGxpbmUgc2NhbGFyIG11c3Qgbm90IHNwYW4gbW9yZSB0aGFuIDEwMjQgY2hhcmFjdGVycycpO1xuICAgICAgICBleHBsaWNpdEtleSA9IHRydWU7XG4gICAgfVxuICAgIGlmIChjdHguaW5GbG93KSB7XG4gICAgICAgIGlmIChhbGxOdWxsVmFsdWVzIHx8IHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChrZXlDb21tZW50RG9uZSAmJiBvbkNvbW1lbnQpXG4gICAgICAgICAgICAgICAgb25Db21tZW50KCk7XG4gICAgICAgICAgICByZXR1cm4gZXhwbGljaXRLZXkgPyBgPyAke3N0cn1gIDogc3RyO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKChhbGxOdWxsVmFsdWVzICYmICFzaW1wbGVLZXlzKSB8fCAodmFsdWUgPT0gbnVsbCAmJiBleHBsaWNpdEtleSkpIHtcbiAgICAgICAgc3RyID0gYD8gJHtzdHJ9YDtcbiAgICAgICAgaWYgKGtleUNvbW1lbnQgJiYgIWtleUNvbW1lbnREb25lKSB7XG4gICAgICAgICAgICBzdHIgKz0gbGluZUNvbW1lbnQoc3RyLCBjdHguaW5kZW50LCBjb21tZW50U3RyaW5nKGtleUNvbW1lbnQpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjaG9tcEtlZXAgJiYgb25DaG9tcEtlZXApXG4gICAgICAgICAgICBvbkNob21wS2VlcCgpO1xuICAgICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgICBpZiAoa2V5Q29tbWVudERvbmUpXG4gICAgICAgIGtleUNvbW1lbnQgPSBudWxsO1xuICAgIGlmIChleHBsaWNpdEtleSkge1xuICAgICAgICBpZiAoa2V5Q29tbWVudClcbiAgICAgICAgICAgIHN0ciArPSBsaW5lQ29tbWVudChzdHIsIGN0eC5pbmRlbnQsIGNvbW1lbnRTdHJpbmcoa2V5Q29tbWVudCkpO1xuICAgICAgICBzdHIgPSBgPyAke3N0cn1cXG4ke2luZGVudH06YDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHN0ciA9IGAke3N0cn06YDtcbiAgICAgICAgaWYgKGtleUNvbW1lbnQpXG4gICAgICAgICAgICBzdHIgKz0gbGluZUNvbW1lbnQoc3RyLCBjdHguaW5kZW50LCBjb21tZW50U3RyaW5nKGtleUNvbW1lbnQpKTtcbiAgICB9XG4gICAgbGV0IHZjYiA9ICcnO1xuICAgIGxldCB2YWx1ZUNvbW1lbnQgPSBudWxsO1xuICAgIGlmIChpc05vZGUodmFsdWUpKSB7XG4gICAgICAgIGlmICh2YWx1ZS5zcGFjZUJlZm9yZSlcbiAgICAgICAgICAgIHZjYiA9ICdcXG4nO1xuICAgICAgICBpZiAodmFsdWUuY29tbWVudEJlZm9yZSkge1xuICAgICAgICAgICAgY29uc3QgY3MgPSBjb21tZW50U3RyaW5nKHZhbHVlLmNvbW1lbnRCZWZvcmUpO1xuICAgICAgICAgICAgdmNiICs9IGBcXG4ke2luZGVudENvbW1lbnQoY3MsIGN0eC5pbmRlbnQpfWA7XG4gICAgICAgIH1cbiAgICAgICAgdmFsdWVDb21tZW50ID0gdmFsdWUuY29tbWVudDtcbiAgICB9XG4gICAgZWxzZSBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgICAgICB2YWx1ZSA9IGRvYy5jcmVhdGVOb2RlKHZhbHVlKTtcbiAgICB9XG4gICAgY3R4LmltcGxpY2l0S2V5ID0gZmFsc2U7XG4gICAgaWYgKCFleHBsaWNpdEtleSAmJiAha2V5Q29tbWVudCAmJiBpc1NjYWxhcih2YWx1ZSkpXG4gICAgICAgIGN0eC5pbmRlbnRBdFN0YXJ0ID0gc3RyLmxlbmd0aCArIDE7XG4gICAgY2hvbXBLZWVwID0gZmFsc2U7XG4gICAgaWYgKCFpbmRlbnRTZXEgJiZcbiAgICAgICAgaW5kZW50U3RlcC5sZW5ndGggPj0gMiAmJlxuICAgICAgICAhY3R4LmluRmxvdyAmJlxuICAgICAgICAhZXhwbGljaXRLZXkgJiZcbiAgICAgICAgaXNTZXEodmFsdWUpICYmXG4gICAgICAgICF2YWx1ZS5mbG93ICYmXG4gICAgICAgICF2YWx1ZS50YWcgJiZcbiAgICAgICAgIXZhbHVlLmFuY2hvcikge1xuICAgICAgICAvLyBJZiBpbmRlbnRTZXEgPT09IGZhbHNlLCBjb25zaWRlciAnLSAnIGFzIHBhcnQgb2YgaW5kZW50YXRpb24gd2hlcmUgcG9zc2libGVcbiAgICAgICAgY3R4LmluZGVudCA9IGN0eC5pbmRlbnQuc3Vic3RyKDIpO1xuICAgIH1cbiAgICBsZXQgdmFsdWVDb21tZW50RG9uZSA9IGZhbHNlO1xuICAgIGNvbnN0IHZhbHVlU3RyID0gc3RyaW5naWZ5KHZhbHVlLCBjdHgsICgpID0+ICh2YWx1ZUNvbW1lbnREb25lID0gdHJ1ZSksICgpID0+IChjaG9tcEtlZXAgPSB0cnVlKSk7XG4gICAgbGV0IHdzID0gJyAnO1xuICAgIGlmICh2Y2IgfHwga2V5Q29tbWVudCkge1xuICAgICAgICB3cyA9IHZhbHVlU3RyID09PSAnJyAmJiAhY3R4LmluRmxvdyA/IHZjYiA6IGAke3ZjYn1cXG4ke2N0eC5pbmRlbnR9YDtcbiAgICB9XG4gICAgZWxzZSBpZiAoIWV4cGxpY2l0S2V5ICYmIGlzQ29sbGVjdGlvbih2YWx1ZSkpIHtcbiAgICAgICAgY29uc3QgZmxvdyA9IHZhbHVlU3RyWzBdID09PSAnWycgfHwgdmFsdWVTdHJbMF0gPT09ICd7JztcbiAgICAgICAgaWYgKCFmbG93IHx8IHZhbHVlU3RyLmluY2x1ZGVzKCdcXG4nKSlcbiAgICAgICAgICAgIHdzID0gYFxcbiR7Y3R4LmluZGVudH1gO1xuICAgIH1cbiAgICBlbHNlIGlmICh2YWx1ZVN0ciA9PT0gJycgfHwgdmFsdWVTdHJbMF0gPT09ICdcXG4nKVxuICAgICAgICB3cyA9ICcnO1xuICAgIHN0ciArPSB3cyArIHZhbHVlU3RyO1xuICAgIGlmIChjdHguaW5GbG93KSB7XG4gICAgICAgIGlmICh2YWx1ZUNvbW1lbnREb25lICYmIG9uQ29tbWVudClcbiAgICAgICAgICAgIG9uQ29tbWVudCgpO1xuICAgIH1cbiAgICBlbHNlIGlmICh2YWx1ZUNvbW1lbnQgJiYgIXZhbHVlQ29tbWVudERvbmUpIHtcbiAgICAgICAgc3RyICs9IGxpbmVDb21tZW50KHN0ciwgY3R4LmluZGVudCwgY29tbWVudFN0cmluZyh2YWx1ZUNvbW1lbnQpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoY2hvbXBLZWVwICYmIG9uQ2hvbXBLZWVwKSB7XG4gICAgICAgIG9uQ2hvbXBLZWVwKCk7XG4gICAgfVxuICAgIHJldHVybiBzdHI7XG59XG5cbmV4cG9ydCB7IHN0cmluZ2lmeVBhaXIgfTtcbiIsICJmdW5jdGlvbiBkZWJ1Zyhsb2dMZXZlbCwgLi4ubWVzc2FnZXMpIHtcbiAgICBpZiAobG9nTGV2ZWwgPT09ICdkZWJ1ZycpXG4gICAgICAgIGNvbnNvbGUubG9nKC4uLm1lc3NhZ2VzKTtcbn1cbmZ1bmN0aW9uIHdhcm4obG9nTGV2ZWwsIHdhcm5pbmcpIHtcbiAgICBpZiAobG9nTGV2ZWwgPT09ICdkZWJ1ZycgfHwgbG9nTGV2ZWwgPT09ICd3YXJuJykge1xuICAgICAgICBpZiAodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHByb2Nlc3MuZW1pdFdhcm5pbmcpXG4gICAgICAgICAgICBwcm9jZXNzLmVtaXRXYXJuaW5nKHdhcm5pbmcpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBjb25zb2xlLndhcm4od2FybmluZyk7XG4gICAgfVxufVxuXG5leHBvcnQgeyBkZWJ1Zywgd2FybiB9O1xuIiwgImltcG9ydCB7IHdhcm4gfSBmcm9tICcuLi9sb2cuanMnO1xuaW1wb3J0IHsgY3JlYXRlU3RyaW5naWZ5Q29udGV4dCB9IGZyb20gJy4uL3N0cmluZ2lmeS9zdHJpbmdpZnkuanMnO1xuaW1wb3J0IHsgaXNBbGlhcywgaXNTZXEsIGlzU2NhbGFyLCBpc01hcCwgaXNOb2RlIH0gZnJvbSAnLi9Ob2RlLmpzJztcbmltcG9ydCB7IFNjYWxhciB9IGZyb20gJy4vU2NhbGFyLmpzJztcbmltcG9ydCB7IHRvSlMgfSBmcm9tICcuL3RvSlMuanMnO1xuXG5jb25zdCBNRVJHRV9LRVkgPSAnPDwnO1xuZnVuY3Rpb24gYWRkUGFpclRvSlNNYXAoY3R4LCBtYXAsIHsga2V5LCB2YWx1ZSB9KSB7XG4gICAgaWYgKGN0eCAmJiBjdHguZG9jLnNjaGVtYS5tZXJnZSAmJiBpc01lcmdlS2V5KGtleSkpIHtcbiAgICAgICAgdmFsdWUgPSBpc0FsaWFzKHZhbHVlKSA/IHZhbHVlLnJlc29sdmUoY3R4LmRvYykgOiB2YWx1ZTtcbiAgICAgICAgaWYgKGlzU2VxKHZhbHVlKSlcbiAgICAgICAgICAgIGZvciAoY29uc3QgaXQgb2YgdmFsdWUuaXRlbXMpXG4gICAgICAgICAgICAgICAgbWVyZ2VUb0pTTWFwKGN0eCwgbWFwLCBpdCk7XG4gICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKVxuICAgICAgICAgICAgZm9yIChjb25zdCBpdCBvZiB2YWx1ZSlcbiAgICAgICAgICAgICAgICBtZXJnZVRvSlNNYXAoY3R4LCBtYXAsIGl0KTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgbWVyZ2VUb0pTTWFwKGN0eCwgbWFwLCB2YWx1ZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBqc0tleSA9IHRvSlMoa2V5LCAnJywgY3R4KTtcbiAgICAgICAgaWYgKG1hcCBpbnN0YW5jZW9mIE1hcCkge1xuICAgICAgICAgICAgbWFwLnNldChqc0tleSwgdG9KUyh2YWx1ZSwganNLZXksIGN0eCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG1hcCBpbnN0YW5jZW9mIFNldCkge1xuICAgICAgICAgICAgbWFwLmFkZChqc0tleSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBzdHJpbmdLZXkgPSBzdHJpbmdpZnlLZXkoa2V5LCBqc0tleSwgY3R4KTtcbiAgICAgICAgICAgIGNvbnN0IGpzVmFsdWUgPSB0b0pTKHZhbHVlLCBzdHJpbmdLZXksIGN0eCk7XG4gICAgICAgICAgICBpZiAoc3RyaW5nS2V5IGluIG1hcClcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobWFwLCBzdHJpbmdLZXksIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGpzVmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBtYXBbc3RyaW5nS2V5XSA9IGpzVmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1hcDtcbn1cbmNvbnN0IGlzTWVyZ2VLZXkgPSAoa2V5KSA9PiBrZXkgPT09IE1FUkdFX0tFWSB8fFxuICAgIChpc1NjYWxhcihrZXkpICYmXG4gICAgICAgIGtleS52YWx1ZSA9PT0gTUVSR0VfS0VZICYmXG4gICAgICAgICgha2V5LnR5cGUgfHwga2V5LnR5cGUgPT09IFNjYWxhci5QTEFJTikpO1xuLy8gSWYgdGhlIHZhbHVlIGFzc29jaWF0ZWQgd2l0aCBhIG1lcmdlIGtleSBpcyBhIHNpbmdsZSBtYXBwaW5nIG5vZGUsIGVhY2ggb2Zcbi8vIGl0cyBrZXkvdmFsdWUgcGFpcnMgaXMgaW5zZXJ0ZWQgaW50byB0aGUgY3VycmVudCBtYXBwaW5nLCB1bmxlc3MgdGhlIGtleVxuLy8gYWxyZWFkeSBleGlzdHMgaW4gaXQuIElmIHRoZSB2YWx1ZSBhc3NvY2lhdGVkIHdpdGggdGhlIG1lcmdlIGtleSBpcyBhXG4vLyBzZXF1ZW5jZSwgdGhlbiB0aGlzIHNlcXVlbmNlIGlzIGV4cGVjdGVkIHRvIGNvbnRhaW4gbWFwcGluZyBub2RlcyBhbmQgZWFjaFxuLy8gb2YgdGhlc2Ugbm9kZXMgaXMgbWVyZ2VkIGluIHR1cm4gYWNjb3JkaW5nIHRvIGl0cyBvcmRlciBpbiB0aGUgc2VxdWVuY2UuXG4vLyBLZXlzIGluIG1hcHBpbmcgbm9kZXMgZWFybGllciBpbiB0aGUgc2VxdWVuY2Ugb3ZlcnJpZGUga2V5cyBzcGVjaWZpZWQgaW5cbi8vIGxhdGVyIG1hcHBpbmcgbm9kZXMuIC0tIGh0dHA6Ly95YW1sLm9yZy90eXBlL21lcmdlLmh0bWxcbmZ1bmN0aW9uIG1lcmdlVG9KU01hcChjdHgsIG1hcCwgdmFsdWUpIHtcbiAgICBjb25zdCBzb3VyY2UgPSBjdHggJiYgaXNBbGlhcyh2YWx1ZSkgPyB2YWx1ZS5yZXNvbHZlKGN0eC5kb2MpIDogdmFsdWU7XG4gICAgaWYgKCFpc01hcChzb3VyY2UpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01lcmdlIHNvdXJjZXMgbXVzdCBiZSBtYXBzIG9yIG1hcCBhbGlhc2VzJyk7XG4gICAgY29uc3Qgc3JjTWFwID0gc291cmNlLnRvSlNPTihudWxsLCBjdHgsIE1hcCk7XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2Ygc3JjTWFwKSB7XG4gICAgICAgIGlmIChtYXAgaW5zdGFuY2VvZiBNYXApIHtcbiAgICAgICAgICAgIGlmICghbWFwLmhhcyhrZXkpKVxuICAgICAgICAgICAgICAgIG1hcC5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobWFwIGluc3RhbmNlb2YgU2V0KSB7XG4gICAgICAgICAgICBtYXAuYWRkKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtYXAsIGtleSkpIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtYXAsIGtleSwge1xuICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWFwO1xufVxuZnVuY3Rpb24gc3RyaW5naWZ5S2V5KGtleSwganNLZXksIGN0eCkge1xuICAgIGlmIChqc0tleSA9PT0gbnVsbClcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIGlmICh0eXBlb2YganNLZXkgIT09ICdvYmplY3QnKVxuICAgICAgICByZXR1cm4gU3RyaW5nKGpzS2V5KTtcbiAgICBpZiAoaXNOb2RlKGtleSkgJiYgY3R4ICYmIGN0eC5kb2MpIHtcbiAgICAgICAgY29uc3Qgc3RyQ3R4ID0gY3JlYXRlU3RyaW5naWZ5Q29udGV4dChjdHguZG9jLCB7fSk7XG4gICAgICAgIHN0ckN0eC5hbmNob3JzID0gbmV3IFNldCgpO1xuICAgICAgICBmb3IgKGNvbnN0IG5vZGUgb2YgY3R4LmFuY2hvcnMua2V5cygpKVxuICAgICAgICAgICAgc3RyQ3R4LmFuY2hvcnMuYWRkKG5vZGUuYW5jaG9yKTtcbiAgICAgICAgc3RyQ3R4LmluRmxvdyA9IHRydWU7XG4gICAgICAgIHN0ckN0eC5pblN0cmluZ2lmeUtleSA9IHRydWU7XG4gICAgICAgIGNvbnN0IHN0cktleSA9IGtleS50b1N0cmluZyhzdHJDdHgpO1xuICAgICAgICBpZiAoIWN0eC5tYXBLZXlXYXJuZWQpIHtcbiAgICAgICAgICAgIGxldCBqc29uU3RyID0gSlNPTi5zdHJpbmdpZnkoc3RyS2V5KTtcbiAgICAgICAgICAgIGlmIChqc29uU3RyLmxlbmd0aCA+IDQwKVxuICAgICAgICAgICAgICAgIGpzb25TdHIgPSBqc29uU3RyLnN1YnN0cmluZygwLCAzNikgKyAnLi4uXCInO1xuICAgICAgICAgICAgd2FybihjdHguZG9jLm9wdGlvbnMubG9nTGV2ZWwsIGBLZXlzIHdpdGggY29sbGVjdGlvbiB2YWx1ZXMgd2lsbCBiZSBzdHJpbmdpZmllZCBkdWUgdG8gSlMgT2JqZWN0IHJlc3RyaWN0aW9uczogJHtqc29uU3RyfS4gU2V0IG1hcEFzTWFwOiB0cnVlIHRvIHVzZSBvYmplY3Qga2V5cy5gKTtcbiAgICAgICAgICAgIGN0eC5tYXBLZXlXYXJuZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHJLZXk7XG4gICAgfVxuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShqc0tleSk7XG59XG5cbmV4cG9ydCB7IGFkZFBhaXJUb0pTTWFwIH07XG4iLCAiaW1wb3J0IHsgY3JlYXRlTm9kZSB9IGZyb20gJy4uL2RvYy9jcmVhdGVOb2RlLmpzJztcbmltcG9ydCB7IHN0cmluZ2lmeVBhaXIgfSBmcm9tICcuLi9zdHJpbmdpZnkvc3RyaW5naWZ5UGFpci5qcyc7XG5pbXBvcnQgeyBhZGRQYWlyVG9KU01hcCB9IGZyb20gJy4vYWRkUGFpclRvSlNNYXAuanMnO1xuaW1wb3J0IHsgTk9ERV9UWVBFLCBQQUlSLCBpc05vZGUgfSBmcm9tICcuL05vZGUuanMnO1xuXG5mdW5jdGlvbiBjcmVhdGVQYWlyKGtleSwgdmFsdWUsIGN0eCkge1xuICAgIGNvbnN0IGsgPSBjcmVhdGVOb2RlKGtleSwgdW5kZWZpbmVkLCBjdHgpO1xuICAgIGNvbnN0IHYgPSBjcmVhdGVOb2RlKHZhbHVlLCB1bmRlZmluZWQsIGN0eCk7XG4gICAgcmV0dXJuIG5ldyBQYWlyKGssIHYpO1xufVxuY2xhc3MgUGFpciB7XG4gICAgY29uc3RydWN0b3Ioa2V5LCB2YWx1ZSA9IG51bGwpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIE5PREVfVFlQRSwgeyB2YWx1ZTogUEFJUiB9KTtcbiAgICAgICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gICAgY2xvbmUoc2NoZW1hKSB7XG4gICAgICAgIGxldCB7IGtleSwgdmFsdWUgfSA9IHRoaXM7XG4gICAgICAgIGlmIChpc05vZGUoa2V5KSlcbiAgICAgICAgICAgIGtleSA9IGtleS5jbG9uZShzY2hlbWEpO1xuICAgICAgICBpZiAoaXNOb2RlKHZhbHVlKSlcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuY2xvbmUoc2NoZW1hKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQYWlyKGtleSwgdmFsdWUpO1xuICAgIH1cbiAgICB0b0pTT04oXywgY3R4KSB7XG4gICAgICAgIGNvbnN0IHBhaXIgPSBjdHggJiYgY3R4Lm1hcEFzTWFwID8gbmV3IE1hcCgpIDoge307XG4gICAgICAgIHJldHVybiBhZGRQYWlyVG9KU01hcChjdHgsIHBhaXIsIHRoaXMpO1xuICAgIH1cbiAgICB0b1N0cmluZyhjdHgsIG9uQ29tbWVudCwgb25DaG9tcEtlZXApIHtcbiAgICAgICAgcmV0dXJuIGN0eCAmJiBjdHguZG9jXG4gICAgICAgICAgICA/IHN0cmluZ2lmeVBhaXIodGhpcywgY3R4LCBvbkNvbW1lbnQsIG9uQ2hvbXBLZWVwKVxuICAgICAgICAgICAgOiBKU09OLnN0cmluZ2lmeSh0aGlzKTtcbiAgICB9XG59XG5cbmV4cG9ydCB7IFBhaXIsIGNyZWF0ZVBhaXIgfTtcbiIsICIvKipcbiAqIGB5YW1sYCBkZWZpbmVzIGRvY3VtZW50LXNwZWNpZmljIG9wdGlvbnMgaW4gdGhyZWUgcGxhY2VzOiBhcyBhbiBhcmd1bWVudCBvZlxuICogcGFyc2UsIGNyZWF0ZSBhbmQgc3RyaW5naWZ5IGNhbGxzLCBpbiB0aGUgdmFsdWVzIG9mIGBZQU1MLmRlZmF1bHRPcHRpb25zYCxcbiAqIGFuZCBpbiB0aGUgdmVyc2lvbi1kZXBlbmRlbnQgYFlBTUwuRG9jdW1lbnQuZGVmYXVsdHNgIG9iamVjdC4gVmFsdWVzIHNldCBpblxuICogYFlBTUwuZGVmYXVsdE9wdGlvbnNgIG92ZXJyaWRlIHZlcnNpb24tZGVwZW5kZW50IGRlZmF1bHRzLCBhbmQgYXJndW1lbnRcbiAqIG9wdGlvbnMgb3ZlcnJpZGUgYm90aC5cbiAqL1xuY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgaW50QXNCaWdJbnQ6IGZhbHNlLFxuICAgIGtlZXBTb3VyY2VUb2tlbnM6IGZhbHNlLFxuICAgIGxvZ0xldmVsOiAnd2FybicsXG4gICAgcHJldHR5RXJyb3JzOiB0cnVlLFxuICAgIHN0cmljdDogdHJ1ZSxcbiAgICB1bmlxdWVLZXlzOiB0cnVlLFxuICAgIHZlcnNpb246ICcxLjInXG59O1xuXG5leHBvcnQgeyBkZWZhdWx0T3B0aW9ucyB9O1xuIiwgImltcG9ydCB7IENvbGxlY3Rpb24gfSBmcm9tICcuLi9ub2Rlcy9Db2xsZWN0aW9uLmpzJztcbmltcG9ydCB7IGlzTm9kZSwgaXNQYWlyIH0gZnJvbSAnLi4vbm9kZXMvTm9kZS5qcyc7XG5pbXBvcnQgeyBzdHJpbmdpZnkgfSBmcm9tICcuL3N0cmluZ2lmeS5qcyc7XG5pbXBvcnQgeyBsaW5lQ29tbWVudCwgaW5kZW50Q29tbWVudCB9IGZyb20gJy4vc3RyaW5naWZ5Q29tbWVudC5qcyc7XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeUNvbGxlY3Rpb24oY29sbGVjdGlvbiwgY3R4LCBvcHRpb25zKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IGZsb3cgPSAoX2EgPSBjdHguaW5GbG93KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBjb2xsZWN0aW9uLmZsb3c7XG4gICAgY29uc3Qgc3RyaW5naWZ5ID0gZmxvdyA/IHN0cmluZ2lmeUZsb3dDb2xsZWN0aW9uIDogc3RyaW5naWZ5QmxvY2tDb2xsZWN0aW9uO1xuICAgIHJldHVybiBzdHJpbmdpZnkoY29sbGVjdGlvbiwgY3R4LCBvcHRpb25zKTtcbn1cbmZ1bmN0aW9uIHN0cmluZ2lmeUJsb2NrQ29sbGVjdGlvbih7IGNvbW1lbnQsIGl0ZW1zIH0sIGN0eCwgeyBibG9ja0l0ZW1QcmVmaXgsIGZsb3dDaGFycywgaXRlbUluZGVudCwgb25DaG9tcEtlZXAsIG9uQ29tbWVudCB9KSB7XG4gICAgY29uc3QgeyBpbmRlbnQsIG9wdGlvbnM6IHsgY29tbWVudFN0cmluZyB9IH0gPSBjdHg7XG4gICAgY29uc3QgaXRlbUN0eCA9IE9iamVjdC5hc3NpZ24oe30sIGN0eCwgeyBpbmRlbnQ6IGl0ZW1JbmRlbnQsIHR5cGU6IG51bGwgfSk7XG4gICAgbGV0IGNob21wS2VlcCA9IGZhbHNlOyAvLyBmbGFnIGZvciB0aGUgcHJlY2VkaW5nIG5vZGUncyBzdGF0dXNcbiAgICBjb25zdCBsaW5lcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29uc3QgaXRlbSA9IGl0ZW1zW2ldO1xuICAgICAgICBsZXQgY29tbWVudCA9IG51bGw7XG4gICAgICAgIGlmIChpc05vZGUoaXRlbSkpIHtcbiAgICAgICAgICAgIGlmICghY2hvbXBLZWVwICYmIGl0ZW0uc3BhY2VCZWZvcmUpXG4gICAgICAgICAgICAgICAgbGluZXMucHVzaCgnJyk7XG4gICAgICAgICAgICBhZGRDb21tZW50QmVmb3JlKGN0eCwgbGluZXMsIGl0ZW0uY29tbWVudEJlZm9yZSwgY2hvbXBLZWVwKTtcbiAgICAgICAgICAgIGlmIChpdGVtLmNvbW1lbnQpXG4gICAgICAgICAgICAgICAgY29tbWVudCA9IGl0ZW0uY29tbWVudDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc1BhaXIoaXRlbSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGlrID0gaXNOb2RlKGl0ZW0ua2V5KSA/IGl0ZW0ua2V5IDogbnVsbDtcbiAgICAgICAgICAgIGlmIChpaykge1xuICAgICAgICAgICAgICAgIGlmICghY2hvbXBLZWVwICYmIGlrLnNwYWNlQmVmb3JlKVxuICAgICAgICAgICAgICAgICAgICBsaW5lcy5wdXNoKCcnKTtcbiAgICAgICAgICAgICAgICBhZGRDb21tZW50QmVmb3JlKGN0eCwgbGluZXMsIGlrLmNvbW1lbnRCZWZvcmUsIGNob21wS2VlcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2hvbXBLZWVwID0gZmFsc2U7XG4gICAgICAgIGxldCBzdHIgPSBzdHJpbmdpZnkoaXRlbSwgaXRlbUN0eCwgKCkgPT4gKGNvbW1lbnQgPSBudWxsKSwgKCkgPT4gKGNob21wS2VlcCA9IHRydWUpKTtcbiAgICAgICAgaWYgKGNvbW1lbnQpXG4gICAgICAgICAgICBzdHIgKz0gbGluZUNvbW1lbnQoc3RyLCBpdGVtSW5kZW50LCBjb21tZW50U3RyaW5nKGNvbW1lbnQpKTtcbiAgICAgICAgaWYgKGNob21wS2VlcCAmJiBjb21tZW50KVxuICAgICAgICAgICAgY2hvbXBLZWVwID0gZmFsc2U7XG4gICAgICAgIGxpbmVzLnB1c2goYmxvY2tJdGVtUHJlZml4ICsgc3RyKTtcbiAgICB9XG4gICAgbGV0IHN0cjtcbiAgICBpZiAobGluZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHN0ciA9IGZsb3dDaGFycy5zdGFydCArIGZsb3dDaGFycy5lbmQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBzdHIgPSBsaW5lc1swXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBsaW5lcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgY29uc3QgbGluZSA9IGxpbmVzW2ldO1xuICAgICAgICAgICAgc3RyICs9IGxpbmUgPyBgXFxuJHtpbmRlbnR9JHtsaW5lfWAgOiAnXFxuJztcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoY29tbWVudCkge1xuICAgICAgICBzdHIgKz0gJ1xcbicgKyBpbmRlbnRDb21tZW50KGNvbW1lbnRTdHJpbmcoY29tbWVudCksIGluZGVudCk7XG4gICAgICAgIGlmIChvbkNvbW1lbnQpXG4gICAgICAgICAgICBvbkNvbW1lbnQoKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoY2hvbXBLZWVwICYmIG9uQ2hvbXBLZWVwKVxuICAgICAgICBvbkNob21wS2VlcCgpO1xuICAgIHJldHVybiBzdHI7XG59XG5mdW5jdGlvbiBzdHJpbmdpZnlGbG93Q29sbGVjdGlvbih7IGNvbW1lbnQsIGl0ZW1zIH0sIGN0eCwgeyBmbG93Q2hhcnMsIGl0ZW1JbmRlbnQsIG9uQ29tbWVudCB9KSB7XG4gICAgY29uc3QgeyBpbmRlbnQsIGluZGVudFN0ZXAsIG9wdGlvbnM6IHsgY29tbWVudFN0cmluZyB9IH0gPSBjdHg7XG4gICAgaXRlbUluZGVudCArPSBpbmRlbnRTdGVwO1xuICAgIGNvbnN0IGl0ZW1DdHggPSBPYmplY3QuYXNzaWduKHt9LCBjdHgsIHtcbiAgICAgICAgaW5kZW50OiBpdGVtSW5kZW50LFxuICAgICAgICBpbkZsb3c6IHRydWUsXG4gICAgICAgIHR5cGU6IG51bGxcbiAgICB9KTtcbiAgICBsZXQgcmVxTmV3bGluZSA9IGZhbHNlO1xuICAgIGxldCBsaW5lc0F0VmFsdWUgPSAwO1xuICAgIGNvbnN0IGxpbmVzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7ICsraSkge1xuICAgICAgICBjb25zdCBpdGVtID0gaXRlbXNbaV07XG4gICAgICAgIGxldCBjb21tZW50ID0gbnVsbDtcbiAgICAgICAgaWYgKGlzTm9kZShpdGVtKSkge1xuICAgICAgICAgICAgaWYgKGl0ZW0uc3BhY2VCZWZvcmUpXG4gICAgICAgICAgICAgICAgbGluZXMucHVzaCgnJyk7XG4gICAgICAgICAgICBhZGRDb21tZW50QmVmb3JlKGN0eCwgbGluZXMsIGl0ZW0uY29tbWVudEJlZm9yZSwgZmFsc2UpO1xuICAgICAgICAgICAgaWYgKGl0ZW0uY29tbWVudClcbiAgICAgICAgICAgICAgICBjb21tZW50ID0gaXRlbS5jb21tZW50O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzUGFpcihpdGVtKSkge1xuICAgICAgICAgICAgY29uc3QgaWsgPSBpc05vZGUoaXRlbS5rZXkpID8gaXRlbS5rZXkgOiBudWxsO1xuICAgICAgICAgICAgaWYgKGlrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlrLnNwYWNlQmVmb3JlKVxuICAgICAgICAgICAgICAgICAgICBsaW5lcy5wdXNoKCcnKTtcbiAgICAgICAgICAgICAgICBhZGRDb21tZW50QmVmb3JlKGN0eCwgbGluZXMsIGlrLmNvbW1lbnRCZWZvcmUsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICBpZiAoaWsuY29tbWVudClcbiAgICAgICAgICAgICAgICAgICAgcmVxTmV3bGluZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBpdiA9IGlzTm9kZShpdGVtLnZhbHVlKSA/IGl0ZW0udmFsdWUgOiBudWxsO1xuICAgICAgICAgICAgaWYgKGl2KSB7XG4gICAgICAgICAgICAgICAgaWYgKGl2LmNvbW1lbnQpXG4gICAgICAgICAgICAgICAgICAgIGNvbW1lbnQgPSBpdi5jb21tZW50O1xuICAgICAgICAgICAgICAgIGlmIChpdi5jb21tZW50QmVmb3JlKVxuICAgICAgICAgICAgICAgICAgICByZXFOZXdsaW5lID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGl0ZW0udmFsdWUgPT0gbnVsbCAmJiBpayAmJiBpay5jb21tZW50KSB7XG4gICAgICAgICAgICAgICAgY29tbWVudCA9IGlrLmNvbW1lbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbW1lbnQpXG4gICAgICAgICAgICByZXFOZXdsaW5lID0gdHJ1ZTtcbiAgICAgICAgbGV0IHN0ciA9IHN0cmluZ2lmeShpdGVtLCBpdGVtQ3R4LCAoKSA9PiAoY29tbWVudCA9IG51bGwpKTtcbiAgICAgICAgaWYgKGkgPCBpdGVtcy5sZW5ndGggLSAxKVxuICAgICAgICAgICAgc3RyICs9ICcsJztcbiAgICAgICAgaWYgKGNvbW1lbnQpXG4gICAgICAgICAgICBzdHIgKz0gbGluZUNvbW1lbnQoc3RyLCBpdGVtSW5kZW50LCBjb21tZW50U3RyaW5nKGNvbW1lbnQpKTtcbiAgICAgICAgaWYgKCFyZXFOZXdsaW5lICYmIChsaW5lcy5sZW5ndGggPiBsaW5lc0F0VmFsdWUgfHwgc3RyLmluY2x1ZGVzKCdcXG4nKSkpXG4gICAgICAgICAgICByZXFOZXdsaW5lID0gdHJ1ZTtcbiAgICAgICAgbGluZXMucHVzaChzdHIpO1xuICAgICAgICBsaW5lc0F0VmFsdWUgPSBsaW5lcy5sZW5ndGg7XG4gICAgfVxuICAgIGxldCBzdHI7XG4gICAgY29uc3QgeyBzdGFydCwgZW5kIH0gPSBmbG93Q2hhcnM7XG4gICAgaWYgKGxpbmVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBzdHIgPSBzdGFydCArIGVuZDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmICghcmVxTmV3bGluZSkge1xuICAgICAgICAgICAgY29uc3QgbGVuID0gbGluZXMucmVkdWNlKChzdW0sIGxpbmUpID0+IHN1bSArIGxpbmUubGVuZ3RoICsgMiwgMik7XG4gICAgICAgICAgICByZXFOZXdsaW5lID0gbGVuID4gQ29sbGVjdGlvbi5tYXhGbG93U3RyaW5nU2luZ2xlTGluZUxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVxTmV3bGluZSkge1xuICAgICAgICAgICAgc3RyID0gc3RhcnQ7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGxpbmUgb2YgbGluZXMpXG4gICAgICAgICAgICAgICAgc3RyICs9IGxpbmUgPyBgXFxuJHtpbmRlbnRTdGVwfSR7aW5kZW50fSR7bGluZX1gIDogJ1xcbic7XG4gICAgICAgICAgICBzdHIgKz0gYFxcbiR7aW5kZW50fSR7ZW5kfWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdHIgPSBgJHtzdGFydH0gJHtsaW5lcy5qb2luKCcgJyl9ICR7ZW5kfWA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNvbW1lbnQpIHtcbiAgICAgICAgc3RyICs9IGxpbmVDb21tZW50KHN0ciwgY29tbWVudFN0cmluZyhjb21tZW50KSwgaW5kZW50KTtcbiAgICAgICAgaWYgKG9uQ29tbWVudClcbiAgICAgICAgICAgIG9uQ29tbWVudCgpO1xuICAgIH1cbiAgICByZXR1cm4gc3RyO1xufVxuZnVuY3Rpb24gYWRkQ29tbWVudEJlZm9yZSh7IGluZGVudCwgb3B0aW9uczogeyBjb21tZW50U3RyaW5nIH0gfSwgbGluZXMsIGNvbW1lbnQsIGNob21wS2VlcCkge1xuICAgIGlmIChjb21tZW50ICYmIGNob21wS2VlcClcbiAgICAgICAgY29tbWVudCA9IGNvbW1lbnQucmVwbGFjZSgvXlxcbisvLCAnJyk7XG4gICAgaWYgKGNvbW1lbnQpIHtcbiAgICAgICAgY29uc3QgaWMgPSBpbmRlbnRDb21tZW50KGNvbW1lbnRTdHJpbmcoY29tbWVudCksIGluZGVudCk7XG4gICAgICAgIGxpbmVzLnB1c2goaWMudHJpbVN0YXJ0KCkpOyAvLyBBdm9pZCBkb3VibGUgaW5kZW50IG9uIGZpcnN0IGxpbmVcbiAgICB9XG59XG5cbmV4cG9ydCB7IHN0cmluZ2lmeUNvbGxlY3Rpb24gfTtcbiIsICJpbXBvcnQgeyBzdHJpbmdpZnlDb2xsZWN0aW9uIH0gZnJvbSAnLi4vc3RyaW5naWZ5L3N0cmluZ2lmeUNvbGxlY3Rpb24uanMnO1xuaW1wb3J0IHsgYWRkUGFpclRvSlNNYXAgfSBmcm9tICcuL2FkZFBhaXJUb0pTTWFwLmpzJztcbmltcG9ydCB7IENvbGxlY3Rpb24gfSBmcm9tICcuL0NvbGxlY3Rpb24uanMnO1xuaW1wb3J0IHsgaXNQYWlyLCBpc1NjYWxhciwgTUFQIH0gZnJvbSAnLi9Ob2RlLmpzJztcbmltcG9ydCB7IFBhaXIgfSBmcm9tICcuL1BhaXIuanMnO1xuaW1wb3J0IHsgaXNTY2FsYXJWYWx1ZSB9IGZyb20gJy4vU2NhbGFyLmpzJztcblxuZnVuY3Rpb24gZmluZFBhaXIoaXRlbXMsIGtleSkge1xuICAgIGNvbnN0IGsgPSBpc1NjYWxhcihrZXkpID8ga2V5LnZhbHVlIDoga2V5O1xuICAgIGZvciAoY29uc3QgaXQgb2YgaXRlbXMpIHtcbiAgICAgICAgaWYgKGlzUGFpcihpdCkpIHtcbiAgICAgICAgICAgIGlmIChpdC5rZXkgPT09IGtleSB8fCBpdC5rZXkgPT09IGspXG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0O1xuICAgICAgICAgICAgaWYgKGlzU2NhbGFyKGl0LmtleSkgJiYgaXQua2V5LnZhbHVlID09PSBrKVxuICAgICAgICAgICAgICAgIHJldHVybiBpdDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuY2xhc3MgWUFNTE1hcCBleHRlbmRzIENvbGxlY3Rpb24ge1xuICAgIGNvbnN0cnVjdG9yKHNjaGVtYSkge1xuICAgICAgICBzdXBlcihNQVAsIHNjaGVtYSk7XG4gICAgICAgIHRoaXMuaXRlbXMgPSBbXTtcbiAgICB9XG4gICAgc3RhdGljIGdldCB0YWdOYW1lKCkge1xuICAgICAgICByZXR1cm4gJ3RhZzp5YW1sLm9yZywyMDAyOm1hcCc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYSB2YWx1ZSB0byB0aGUgY29sbGVjdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvdmVyd3JpdGUgLSBJZiBub3Qgc2V0IGB0cnVlYCwgdXNpbmcgYSBrZXkgdGhhdCBpcyBhbHJlYWR5IGluIHRoZVxuICAgICAqICAgY29sbGVjdGlvbiB3aWxsIHRocm93LiBPdGhlcndpc2UsIG92ZXJ3cml0ZXMgdGhlIHByZXZpb3VzIHZhbHVlLlxuICAgICAqL1xuICAgIGFkZChwYWlyLCBvdmVyd3JpdGUpIHtcbiAgICAgICAgbGV0IF9wYWlyO1xuICAgICAgICBpZiAoaXNQYWlyKHBhaXIpKVxuICAgICAgICAgICAgX3BhaXIgPSBwYWlyO1xuICAgICAgICBlbHNlIGlmICghcGFpciB8fCB0eXBlb2YgcGFpciAhPT0gJ29iamVjdCcgfHwgISgna2V5JyBpbiBwYWlyKSkge1xuICAgICAgICAgICAgLy8gSW4gVHlwZVNjcmlwdCwgdGhpcyBuZXZlciBoYXBwZW5zLlxuICAgICAgICAgICAgX3BhaXIgPSBuZXcgUGFpcihwYWlyLCBwYWlyLnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICBfcGFpciA9IG5ldyBQYWlyKHBhaXIua2V5LCBwYWlyLnZhbHVlKTtcbiAgICAgICAgY29uc3QgcHJldiA9IGZpbmRQYWlyKHRoaXMuaXRlbXMsIF9wYWlyLmtleSk7XG4gICAgICAgIGNvbnN0IHNvcnRFbnRyaWVzID0gdGhpcy5zY2hlbWEgJiYgdGhpcy5zY2hlbWEuc29ydE1hcEVudHJpZXM7XG4gICAgICAgIGlmIChwcmV2KSB7XG4gICAgICAgICAgICBpZiAoIW92ZXJ3cml0ZSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEtleSAke19wYWlyLmtleX0gYWxyZWFkeSBzZXRgKTtcbiAgICAgICAgICAgIC8vIEZvciBzY2FsYXJzLCBrZWVwIHRoZSBvbGQgbm9kZSAmIGl0cyBjb21tZW50cyBhbmQgYW5jaG9yc1xuICAgICAgICAgICAgaWYgKGlzU2NhbGFyKHByZXYudmFsdWUpICYmIGlzU2NhbGFyVmFsdWUoX3BhaXIudmFsdWUpKVxuICAgICAgICAgICAgICAgIHByZXYudmFsdWUudmFsdWUgPSBfcGFpci52YWx1ZTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBwcmV2LnZhbHVlID0gX3BhaXIudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc29ydEVudHJpZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGkgPSB0aGlzLml0ZW1zLmZpbmRJbmRleChpdGVtID0+IHNvcnRFbnRyaWVzKF9wYWlyLCBpdGVtKSA8IDApO1xuICAgICAgICAgICAgaWYgKGkgPT09IC0xKVxuICAgICAgICAgICAgICAgIHRoaXMuaXRlbXMucHVzaChfcGFpcik7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhpcy5pdGVtcy5zcGxpY2UoaSwgMCwgX3BhaXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5pdGVtcy5wdXNoKF9wYWlyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkZWxldGUoa2V5KSB7XG4gICAgICAgIGNvbnN0IGl0ID0gZmluZFBhaXIodGhpcy5pdGVtcywga2V5KTtcbiAgICAgICAgaWYgKCFpdClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgY29uc3QgZGVsID0gdGhpcy5pdGVtcy5zcGxpY2UodGhpcy5pdGVtcy5pbmRleE9mKGl0KSwgMSk7XG4gICAgICAgIHJldHVybiBkZWwubGVuZ3RoID4gMDtcbiAgICB9XG4gICAgZ2V0KGtleSwga2VlcFNjYWxhcikge1xuICAgICAgICBjb25zdCBpdCA9IGZpbmRQYWlyKHRoaXMuaXRlbXMsIGtleSk7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBpdCAmJiBpdC52YWx1ZTtcbiAgICAgICAgcmV0dXJuICFrZWVwU2NhbGFyICYmIGlzU2NhbGFyKG5vZGUpID8gbm9kZS52YWx1ZSA6IG5vZGU7XG4gICAgfVxuICAgIGhhcyhrZXkpIHtcbiAgICAgICAgcmV0dXJuICEhZmluZFBhaXIodGhpcy5pdGVtcywga2V5KTtcbiAgICB9XG4gICAgc2V0KGtleSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5hZGQobmV3IFBhaXIoa2V5LCB2YWx1ZSksIHRydWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gY3R4IC0gQ29udmVyc2lvbiBjb250ZXh0LCBvcmlnaW5hbGx5IHNldCBpbiBEb2N1bWVudCN0b0pTKClcbiAgICAgKiBAcGFyYW0ge0NsYXNzfSBUeXBlIC0gSWYgc2V0LCBmb3JjZXMgdGhlIHJldHVybmVkIGNvbGxlY3Rpb24gdHlwZVxuICAgICAqIEByZXR1cm5zIEluc3RhbmNlIG9mIFR5cGUsIE1hcCwgb3IgT2JqZWN0XG4gICAgICovXG4gICAgdG9KU09OKF8sIGN0eCwgVHlwZSkge1xuICAgICAgICBjb25zdCBtYXAgPSBUeXBlID8gbmV3IFR5cGUoKSA6IGN0eCAmJiBjdHgubWFwQXNNYXAgPyBuZXcgTWFwKCkgOiB7fTtcbiAgICAgICAgaWYgKGN0eCAmJiBjdHgub25DcmVhdGUpXG4gICAgICAgICAgICBjdHgub25DcmVhdGUobWFwKTtcbiAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIHRoaXMuaXRlbXMpXG4gICAgICAgICAgICBhZGRQYWlyVG9KU01hcChjdHgsIG1hcCwgaXRlbSk7XG4gICAgICAgIHJldHVybiBtYXA7XG4gICAgfVxuICAgIHRvU3RyaW5nKGN0eCwgb25Db21tZW50LCBvbkNob21wS2VlcCkge1xuICAgICAgICBpZiAoIWN0eClcbiAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzKTtcbiAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIHRoaXMuaXRlbXMpIHtcbiAgICAgICAgICAgIGlmICghaXNQYWlyKGl0ZW0pKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTWFwIGl0ZW1zIG11c3QgYWxsIGJlIHBhaXJzOyBmb3VuZCAke0pTT04uc3RyaW5naWZ5KGl0ZW0pfSBpbnN0ZWFkYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjdHguYWxsTnVsbFZhbHVlcyAmJiB0aGlzLmhhc0FsbE51bGxWYWx1ZXMoZmFsc2UpKVxuICAgICAgICAgICAgY3R4ID0gT2JqZWN0LmFzc2lnbih7fSwgY3R4LCB7IGFsbE51bGxWYWx1ZXM6IHRydWUgfSk7XG4gICAgICAgIHJldHVybiBzdHJpbmdpZnlDb2xsZWN0aW9uKHRoaXMsIGN0eCwge1xuICAgICAgICAgICAgYmxvY2tJdGVtUHJlZml4OiAnJyxcbiAgICAgICAgICAgIGZsb3dDaGFyczogeyBzdGFydDogJ3snLCBlbmQ6ICd9JyB9LFxuICAgICAgICAgICAgaXRlbUluZGVudDogY3R4LmluZGVudCB8fCAnJyxcbiAgICAgICAgICAgIG9uQ2hvbXBLZWVwLFxuICAgICAgICAgICAgb25Db21tZW50XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuZXhwb3J0IHsgWUFNTE1hcCwgZmluZFBhaXIgfTtcbiIsICJpbXBvcnQgeyBpc01hcCB9IGZyb20gJy4uLy4uL25vZGVzL05vZGUuanMnO1xuaW1wb3J0IHsgY3JlYXRlUGFpciB9IGZyb20gJy4uLy4uL25vZGVzL1BhaXIuanMnO1xuaW1wb3J0IHsgWUFNTE1hcCB9IGZyb20gJy4uLy4uL25vZGVzL1lBTUxNYXAuanMnO1xuXG5mdW5jdGlvbiBjcmVhdGVNYXAoc2NoZW1hLCBvYmosIGN0eCkge1xuICAgIGNvbnN0IHsga2VlcFVuZGVmaW5lZCwgcmVwbGFjZXIgfSA9IGN0eDtcbiAgICBjb25zdCBtYXAgPSBuZXcgWUFNTE1hcChzY2hlbWEpO1xuICAgIGNvbnN0IGFkZCA9IChrZXksIHZhbHVlKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgcmVwbGFjZXIgPT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICB2YWx1ZSA9IHJlcGxhY2VyLmNhbGwob2JqLCBrZXksIHZhbHVlKTtcbiAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShyZXBsYWNlcikgJiYgIXJlcGxhY2VyLmluY2x1ZGVzKGtleSkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkIHx8IGtlZXBVbmRlZmluZWQpXG4gICAgICAgICAgICBtYXAuaXRlbXMucHVzaChjcmVhdGVQYWlyKGtleSwgdmFsdWUsIGN0eCkpO1xuICAgIH07XG4gICAgaWYgKG9iaiBpbnN0YW5jZW9mIE1hcCkge1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBvYmopXG4gICAgICAgICAgICBhZGQoa2V5LCB2YWx1ZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKG9iaiAmJiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0Jykge1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhvYmopKVxuICAgICAgICAgICAgYWRkKGtleSwgb2JqW2tleV0pO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHNjaGVtYS5zb3J0TWFwRW50cmllcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBtYXAuaXRlbXMuc29ydChzY2hlbWEuc29ydE1hcEVudHJpZXMpO1xuICAgIH1cbiAgICByZXR1cm4gbWFwO1xufVxuY29uc3QgbWFwID0ge1xuICAgIGNvbGxlY3Rpb246ICdtYXAnLFxuICAgIGNyZWF0ZU5vZGU6IGNyZWF0ZU1hcCxcbiAgICBkZWZhdWx0OiB0cnVlLFxuICAgIG5vZGVDbGFzczogWUFNTE1hcCxcbiAgICB0YWc6ICd0YWc6eWFtbC5vcmcsMjAwMjptYXAnLFxuICAgIHJlc29sdmUobWFwLCBvbkVycm9yKSB7XG4gICAgICAgIGlmICghaXNNYXAobWFwKSlcbiAgICAgICAgICAgIG9uRXJyb3IoJ0V4cGVjdGVkIGEgbWFwcGluZyBmb3IgdGhpcyB0YWcnKTtcbiAgICAgICAgcmV0dXJuIG1hcDtcbiAgICB9XG59O1xuXG5leHBvcnQgeyBtYXAgfTtcbiIsICJpbXBvcnQgeyBzdHJpbmdpZnlDb2xsZWN0aW9uIH0gZnJvbSAnLi4vc3RyaW5naWZ5L3N0cmluZ2lmeUNvbGxlY3Rpb24uanMnO1xuaW1wb3J0IHsgQ29sbGVjdGlvbiB9IGZyb20gJy4vQ29sbGVjdGlvbi5qcyc7XG5pbXBvcnQgeyBTRVEsIGlzU2NhbGFyIH0gZnJvbSAnLi9Ob2RlLmpzJztcbmltcG9ydCB7IGlzU2NhbGFyVmFsdWUgfSBmcm9tICcuL1NjYWxhci5qcyc7XG5pbXBvcnQgeyB0b0pTIH0gZnJvbSAnLi90b0pTLmpzJztcblxuY2xhc3MgWUFNTFNlcSBleHRlbmRzIENvbGxlY3Rpb24ge1xuICAgIGNvbnN0cnVjdG9yKHNjaGVtYSkge1xuICAgICAgICBzdXBlcihTRVEsIHNjaGVtYSk7XG4gICAgICAgIHRoaXMuaXRlbXMgPSBbXTtcbiAgICB9XG4gICAgc3RhdGljIGdldCB0YWdOYW1lKCkge1xuICAgICAgICByZXR1cm4gJ3RhZzp5YW1sLm9yZywyMDAyOnNlcSc7XG4gICAgfVxuICAgIGFkZCh2YWx1ZSkge1xuICAgICAgICB0aGlzLml0ZW1zLnB1c2godmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGEgdmFsdWUgZnJvbSB0aGUgY29sbGVjdGlvbi5cbiAgICAgKlxuICAgICAqIGBrZXlgIG11c3QgY29udGFpbiBhIHJlcHJlc2VudGF0aW9uIG9mIGFuIGludGVnZXIgZm9yIHRoaXMgdG8gc3VjY2VlZC5cbiAgICAgKiBJdCBtYXkgYmUgd3JhcHBlZCBpbiBhIGBTY2FsYXJgLlxuICAgICAqXG4gICAgICogQHJldHVybnMgYHRydWVgIGlmIHRoZSBpdGVtIHdhcyBmb3VuZCBhbmQgcmVtb3ZlZC5cbiAgICAgKi9cbiAgICBkZWxldGUoa2V5KSB7XG4gICAgICAgIGNvbnN0IGlkeCA9IGFzSXRlbUluZGV4KGtleSk7XG4gICAgICAgIGlmICh0eXBlb2YgaWR4ICE9PSAnbnVtYmVyJylcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgY29uc3QgZGVsID0gdGhpcy5pdGVtcy5zcGxpY2UoaWR4LCAxKTtcbiAgICAgICAgcmV0dXJuIGRlbC5sZW5ndGggPiAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGl0ZW0gYXQgYGtleWAsIG9yIGB1bmRlZmluZWRgIGlmIG5vdCBmb3VuZC4gQnkgZGVmYXVsdCB1bndyYXBzXG4gICAgICogc2NhbGFyIHZhbHVlcyBmcm9tIHRoZWlyIHN1cnJvdW5kaW5nIG5vZGU7IHRvIGRpc2FibGUgc2V0IGBrZWVwU2NhbGFyYCB0b1xuICAgICAqIGB0cnVlYCAoY29sbGVjdGlvbnMgYXJlIGFsd2F5cyByZXR1cm5lZCBpbnRhY3QpLlxuICAgICAqXG4gICAgICogYGtleWAgbXVzdCBjb250YWluIGEgcmVwcmVzZW50YXRpb24gb2YgYW4gaW50ZWdlciBmb3IgdGhpcyB0byBzdWNjZWVkLlxuICAgICAqIEl0IG1heSBiZSB3cmFwcGVkIGluIGEgYFNjYWxhcmAuXG4gICAgICovXG4gICAgZ2V0KGtleSwga2VlcFNjYWxhcikge1xuICAgICAgICBjb25zdCBpZHggPSBhc0l0ZW1JbmRleChrZXkpO1xuICAgICAgICBpZiAodHlwZW9mIGlkeCAhPT0gJ251bWJlcicpXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCBpdCA9IHRoaXMuaXRlbXNbaWR4XTtcbiAgICAgICAgcmV0dXJuICFrZWVwU2NhbGFyICYmIGlzU2NhbGFyKGl0KSA/IGl0LnZhbHVlIDogaXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGUgY29sbGVjdGlvbiBpbmNsdWRlcyBhIHZhbHVlIHdpdGggdGhlIGtleSBga2V5YC5cbiAgICAgKlxuICAgICAqIGBrZXlgIG11c3QgY29udGFpbiBhIHJlcHJlc2VudGF0aW9uIG9mIGFuIGludGVnZXIgZm9yIHRoaXMgdG8gc3VjY2VlZC5cbiAgICAgKiBJdCBtYXkgYmUgd3JhcHBlZCBpbiBhIGBTY2FsYXJgLlxuICAgICAqL1xuICAgIGhhcyhrZXkpIHtcbiAgICAgICAgY29uc3QgaWR4ID0gYXNJdGVtSW5kZXgoa2V5KTtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBpZHggPT09ICdudW1iZXInICYmIGlkeCA8IHRoaXMuaXRlbXMubGVuZ3RoO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIGEgdmFsdWUgaW4gdGhpcyBjb2xsZWN0aW9uLiBGb3IgYCEhc2V0YCwgYHZhbHVlYCBuZWVkcyB0byBiZSBhXG4gICAgICogYm9vbGVhbiB0byBhZGQvcmVtb3ZlIHRoZSBpdGVtIGZyb20gdGhlIHNldC5cbiAgICAgKlxuICAgICAqIElmIGBrZXlgIGRvZXMgbm90IGNvbnRhaW4gYSByZXByZXNlbnRhdGlvbiBvZiBhbiBpbnRlZ2VyLCB0aGlzIHdpbGwgdGhyb3cuXG4gICAgICogSXQgbWF5IGJlIHdyYXBwZWQgaW4gYSBgU2NhbGFyYC5cbiAgICAgKi9cbiAgICBzZXQoa2V5LCB2YWx1ZSkge1xuICAgICAgICBjb25zdCBpZHggPSBhc0l0ZW1JbmRleChrZXkpO1xuICAgICAgICBpZiAodHlwZW9mIGlkeCAhPT0gJ251bWJlcicpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIGEgdmFsaWQgaW5kZXgsIG5vdCAke2tleX0uYCk7XG4gICAgICAgIGNvbnN0IHByZXYgPSB0aGlzLml0ZW1zW2lkeF07XG4gICAgICAgIGlmIChpc1NjYWxhcihwcmV2KSAmJiBpc1NjYWxhclZhbHVlKHZhbHVlKSlcbiAgICAgICAgICAgIHByZXYudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy5pdGVtc1tpZHhdID0gdmFsdWU7XG4gICAgfVxuICAgIHRvSlNPTihfLCBjdHgpIHtcbiAgICAgICAgY29uc3Qgc2VxID0gW107XG4gICAgICAgIGlmIChjdHggJiYgY3R4Lm9uQ3JlYXRlKVxuICAgICAgICAgICAgY3R4Lm9uQ3JlYXRlKHNlcSk7XG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIHRoaXMuaXRlbXMpXG4gICAgICAgICAgICBzZXEucHVzaCh0b0pTKGl0ZW0sIFN0cmluZyhpKyspLCBjdHgpKTtcbiAgICAgICAgcmV0dXJuIHNlcTtcbiAgICB9XG4gICAgdG9TdHJpbmcoY3R4LCBvbkNvbW1lbnQsIG9uQ2hvbXBLZWVwKSB7XG4gICAgICAgIGlmICghY3R4KVxuICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMpO1xuICAgICAgICByZXR1cm4gc3RyaW5naWZ5Q29sbGVjdGlvbih0aGlzLCBjdHgsIHtcbiAgICAgICAgICAgIGJsb2NrSXRlbVByZWZpeDogJy0gJyxcbiAgICAgICAgICAgIGZsb3dDaGFyczogeyBzdGFydDogJ1snLCBlbmQ6ICddJyB9LFxuICAgICAgICAgICAgaXRlbUluZGVudDogKGN0eC5pbmRlbnQgfHwgJycpICsgJyAgJyxcbiAgICAgICAgICAgIG9uQ2hvbXBLZWVwLFxuICAgICAgICAgICAgb25Db21tZW50XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGFzSXRlbUluZGV4KGtleSkge1xuICAgIGxldCBpZHggPSBpc1NjYWxhcihrZXkpID8ga2V5LnZhbHVlIDoga2V5O1xuICAgIGlmIChpZHggJiYgdHlwZW9mIGlkeCA9PT0gJ3N0cmluZycpXG4gICAgICAgIGlkeCA9IE51bWJlcihpZHgpO1xuICAgIHJldHVybiB0eXBlb2YgaWR4ID09PSAnbnVtYmVyJyAmJiBOdW1iZXIuaXNJbnRlZ2VyKGlkeCkgJiYgaWR4ID49IDBcbiAgICAgICAgPyBpZHhcbiAgICAgICAgOiBudWxsO1xufVxuXG5leHBvcnQgeyBZQU1MU2VxIH07XG4iLCAiaW1wb3J0IHsgY3JlYXRlTm9kZSB9IGZyb20gJy4uLy4uL2RvYy9jcmVhdGVOb2RlLmpzJztcbmltcG9ydCB7IGlzU2VxIH0gZnJvbSAnLi4vLi4vbm9kZXMvTm9kZS5qcyc7XG5pbXBvcnQgeyBZQU1MU2VxIH0gZnJvbSAnLi4vLi4vbm9kZXMvWUFNTFNlcS5qcyc7XG5cbmZ1bmN0aW9uIGNyZWF0ZVNlcShzY2hlbWEsIG9iaiwgY3R4KSB7XG4gICAgY29uc3QgeyByZXBsYWNlciB9ID0gY3R4O1xuICAgIGNvbnN0IHNlcSA9IG5ldyBZQU1MU2VxKHNjaGVtYSk7XG4gICAgaWYgKG9iaiAmJiBTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KG9iaikpIHtcbiAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICBmb3IgKGxldCBpdCBvZiBvYmopIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcmVwbGFjZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBvYmogaW5zdGFuY2VvZiBTZXQgPyBpdCA6IFN0cmluZyhpKyspO1xuICAgICAgICAgICAgICAgIGl0ID0gcmVwbGFjZXIuY2FsbChvYmosIGtleSwgaXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VxLml0ZW1zLnB1c2goY3JlYXRlTm9kZShpdCwgdW5kZWZpbmVkLCBjdHgpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2VxO1xufVxuY29uc3Qgc2VxID0ge1xuICAgIGNvbGxlY3Rpb246ICdzZXEnLFxuICAgIGNyZWF0ZU5vZGU6IGNyZWF0ZVNlcSxcbiAgICBkZWZhdWx0OiB0cnVlLFxuICAgIG5vZGVDbGFzczogWUFNTFNlcSxcbiAgICB0YWc6ICd0YWc6eWFtbC5vcmcsMjAwMjpzZXEnLFxuICAgIHJlc29sdmUoc2VxLCBvbkVycm9yKSB7XG4gICAgICAgIGlmICghaXNTZXEoc2VxKSlcbiAgICAgICAgICAgIG9uRXJyb3IoJ0V4cGVjdGVkIGEgc2VxdWVuY2UgZm9yIHRoaXMgdGFnJyk7XG4gICAgICAgIHJldHVybiBzZXE7XG4gICAgfVxufTtcblxuZXhwb3J0IHsgc2VxIH07XG4iLCAiaW1wb3J0IHsgc3RyaW5naWZ5U3RyaW5nIH0gZnJvbSAnLi4vLi4vc3RyaW5naWZ5L3N0cmluZ2lmeVN0cmluZy5qcyc7XG5cbmNvbnN0IHN0cmluZyA9IHtcbiAgICBpZGVudGlmeTogdmFsdWUgPT4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyxcbiAgICBkZWZhdWx0OiB0cnVlLFxuICAgIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOnN0cicsXG4gICAgcmVzb2x2ZTogc3RyID0+IHN0cixcbiAgICBzdHJpbmdpZnkoaXRlbSwgY3R4LCBvbkNvbW1lbnQsIG9uQ2hvbXBLZWVwKSB7XG4gICAgICAgIGN0eCA9IE9iamVjdC5hc3NpZ24oeyBhY3R1YWxTdHJpbmc6IHRydWUgfSwgY3R4KTtcbiAgICAgICAgcmV0dXJuIHN0cmluZ2lmeVN0cmluZyhpdGVtLCBjdHgsIG9uQ29tbWVudCwgb25DaG9tcEtlZXApO1xuICAgIH1cbn07XG5cbmV4cG9ydCB7IHN0cmluZyB9O1xuIiwgImltcG9ydCB7IFNjYWxhciB9IGZyb20gJy4uLy4uL25vZGVzL1NjYWxhci5qcyc7XG5cbmNvbnN0IG51bGxUYWcgPSB7XG4gICAgaWRlbnRpZnk6IHZhbHVlID0+IHZhbHVlID09IG51bGwsXG4gICAgY3JlYXRlTm9kZTogKCkgPT4gbmV3IFNjYWxhcihudWxsKSxcbiAgICBkZWZhdWx0OiB0cnVlLFxuICAgIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOm51bGwnLFxuICAgIHRlc3Q6IC9eKD86fnxbTm5ddWxsfE5VTEwpPyQvLFxuICAgIHJlc29sdmU6ICgpID0+IG5ldyBTY2FsYXIobnVsbCksXG4gICAgc3RyaW5naWZ5OiAoeyBzb3VyY2UgfSwgY3R4KSA9PiBzb3VyY2UgJiYgbnVsbFRhZy50ZXN0LnRlc3Qoc291cmNlKSA/IHNvdXJjZSA6IGN0eC5vcHRpb25zLm51bGxTdHJcbn07XG5cbmV4cG9ydCB7IG51bGxUYWcgfTtcbiIsICJpbXBvcnQgeyBTY2FsYXIgfSBmcm9tICcuLi8uLi9ub2Rlcy9TY2FsYXIuanMnO1xuXG5jb25zdCBib29sVGFnID0ge1xuICAgIGlkZW50aWZ5OiB2YWx1ZSA9PiB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJyxcbiAgICBkZWZhdWx0OiB0cnVlLFxuICAgIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOmJvb2wnLFxuICAgIHRlc3Q6IC9eKD86W1R0XXJ1ZXxUUlVFfFtGZl1hbHNlfEZBTFNFKSQvLFxuICAgIHJlc29sdmU6IHN0ciA9PiBuZXcgU2NhbGFyKHN0clswXSA9PT0gJ3QnIHx8IHN0clswXSA9PT0gJ1QnKSxcbiAgICBzdHJpbmdpZnkoeyBzb3VyY2UsIHZhbHVlIH0sIGN0eCkge1xuICAgICAgICBpZiAoc291cmNlICYmIGJvb2xUYWcudGVzdC50ZXN0KHNvdXJjZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHN2ID0gc291cmNlWzBdID09PSAndCcgfHwgc291cmNlWzBdID09PSAnVCc7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IHN2KVxuICAgICAgICAgICAgICAgIHJldHVybiBzb3VyY2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlID8gY3R4Lm9wdGlvbnMudHJ1ZVN0ciA6IGN0eC5vcHRpb25zLmZhbHNlU3RyO1xuICAgIH1cbn07XG5cbmV4cG9ydCB7IGJvb2xUYWcgfTtcbiIsICJmdW5jdGlvbiBzdHJpbmdpZnlOdW1iZXIoeyBmb3JtYXQsIG1pbkZyYWN0aW9uRGlnaXRzLCB0YWcsIHZhbHVlIH0pIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnYmlnaW50JylcbiAgICAgICAgcmV0dXJuIFN0cmluZyh2YWx1ZSk7XG4gICAgY29uc3QgbnVtID0gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyA/IHZhbHVlIDogTnVtYmVyKHZhbHVlKTtcbiAgICBpZiAoIWlzRmluaXRlKG51bSkpXG4gICAgICAgIHJldHVybiBpc05hTihudW0pID8gJy5uYW4nIDogbnVtIDwgMCA/ICctLmluZicgOiAnLmluZic7XG4gICAgbGV0IG4gPSBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG4gICAgaWYgKCFmb3JtYXQgJiZcbiAgICAgICAgbWluRnJhY3Rpb25EaWdpdHMgJiZcbiAgICAgICAgKCF0YWcgfHwgdGFnID09PSAndGFnOnlhbWwub3JnLDIwMDI6ZmxvYXQnKSAmJlxuICAgICAgICAvXlxcZC8udGVzdChuKSkge1xuICAgICAgICBsZXQgaSA9IG4uaW5kZXhPZignLicpO1xuICAgICAgICBpZiAoaSA8IDApIHtcbiAgICAgICAgICAgIGkgPSBuLmxlbmd0aDtcbiAgICAgICAgICAgIG4gKz0gJy4nO1xuICAgICAgICB9XG4gICAgICAgIGxldCBkID0gbWluRnJhY3Rpb25EaWdpdHMgLSAobi5sZW5ndGggLSBpIC0gMSk7XG4gICAgICAgIHdoaWxlIChkLS0gPiAwKVxuICAgICAgICAgICAgbiArPSAnMCc7XG4gICAgfVxuICAgIHJldHVybiBuO1xufVxuXG5leHBvcnQgeyBzdHJpbmdpZnlOdW1iZXIgfTtcbiIsICJpbXBvcnQgeyBTY2FsYXIgfSBmcm9tICcuLi8uLi9ub2Rlcy9TY2FsYXIuanMnO1xuaW1wb3J0IHsgc3RyaW5naWZ5TnVtYmVyIH0gZnJvbSAnLi4vLi4vc3RyaW5naWZ5L3N0cmluZ2lmeU51bWJlci5qcyc7XG5cbmNvbnN0IGZsb2F0TmFOID0ge1xuICAgIGlkZW50aWZ5OiB2YWx1ZSA9PiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInLFxuICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6ZmxvYXQnLFxuICAgIHRlc3Q6IC9eKD86Wy0rXT9cXC4oPzppbmZ8SW5mfElORnxuYW58TmFOfE5BTikpJC8sXG4gICAgcmVzb2x2ZTogc3RyID0+IHN0ci5zbGljZSgtMykudG9Mb3dlckNhc2UoKSA9PT0gJ25hbidcbiAgICAgICAgPyBOYU5cbiAgICAgICAgOiBzdHJbMF0gPT09ICctJ1xuICAgICAgICAgICAgPyBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFlcbiAgICAgICAgICAgIDogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLFxuICAgIHN0cmluZ2lmeTogc3RyaW5naWZ5TnVtYmVyXG59O1xuY29uc3QgZmxvYXRFeHAgPSB7XG4gICAgaWRlbnRpZnk6IHZhbHVlID0+IHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicsXG4gICAgZGVmYXVsdDogdHJ1ZSxcbiAgICB0YWc6ICd0YWc6eWFtbC5vcmcsMjAwMjpmbG9hdCcsXG4gICAgZm9ybWF0OiAnRVhQJyxcbiAgICB0ZXN0OiAvXlstK10/KD86XFwuWzAtOV0rfFswLTldKyg/OlxcLlswLTldKik/KVtlRV1bLStdP1swLTldKyQvLFxuICAgIHJlc29sdmU6IHN0ciA9PiBwYXJzZUZsb2F0KHN0ciksXG4gICAgc3RyaW5naWZ5KG5vZGUpIHtcbiAgICAgICAgY29uc3QgbnVtID0gTnVtYmVyKG5vZGUudmFsdWUpO1xuICAgICAgICByZXR1cm4gaXNGaW5pdGUobnVtKSA/IG51bS50b0V4cG9uZW50aWFsKCkgOiBzdHJpbmdpZnlOdW1iZXIobm9kZSk7XG4gICAgfVxufTtcbmNvbnN0IGZsb2F0ID0ge1xuICAgIGlkZW50aWZ5OiB2YWx1ZSA9PiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInLFxuICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6ZmxvYXQnLFxuICAgIHRlc3Q6IC9eWy0rXT8oPzpcXC5bMC05XSt8WzAtOV0rXFwuWzAtOV0qKSQvLFxuICAgIHJlc29sdmUoc3RyKSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBuZXcgU2NhbGFyKHBhcnNlRmxvYXQoc3RyKSk7XG4gICAgICAgIGNvbnN0IGRvdCA9IHN0ci5pbmRleE9mKCcuJyk7XG4gICAgICAgIGlmIChkb3QgIT09IC0xICYmIHN0cltzdHIubGVuZ3RoIC0gMV0gPT09ICcwJylcbiAgICAgICAgICAgIG5vZGUubWluRnJhY3Rpb25EaWdpdHMgPSBzdHIubGVuZ3RoIC0gZG90IC0gMTtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfSxcbiAgICBzdHJpbmdpZnk6IHN0cmluZ2lmeU51bWJlclxufTtcblxuZXhwb3J0IHsgZmxvYXQsIGZsb2F0RXhwLCBmbG9hdE5hTiB9O1xuIiwgImltcG9ydCB7IHN0cmluZ2lmeU51bWJlciB9IGZyb20gJy4uLy4uL3N0cmluZ2lmeS9zdHJpbmdpZnlOdW1iZXIuanMnO1xuXG5jb25zdCBpbnRJZGVudGlmeSA9ICh2YWx1ZSkgPT4gdHlwZW9mIHZhbHVlID09PSAnYmlnaW50JyB8fCBOdW1iZXIuaXNJbnRlZ2VyKHZhbHVlKTtcbmNvbnN0IGludFJlc29sdmUgPSAoc3RyLCBvZmZzZXQsIHJhZGl4LCB7IGludEFzQmlnSW50IH0pID0+IChpbnRBc0JpZ0ludCA/IEJpZ0ludChzdHIpIDogcGFyc2VJbnQoc3RyLnN1YnN0cmluZyhvZmZzZXQpLCByYWRpeCkpO1xuZnVuY3Rpb24gaW50U3RyaW5naWZ5KG5vZGUsIHJhZGl4LCBwcmVmaXgpIHtcbiAgICBjb25zdCB7IHZhbHVlIH0gPSBub2RlO1xuICAgIGlmIChpbnRJZGVudGlmeSh2YWx1ZSkgJiYgdmFsdWUgPj0gMClcbiAgICAgICAgcmV0dXJuIHByZWZpeCArIHZhbHVlLnRvU3RyaW5nKHJhZGl4KTtcbiAgICByZXR1cm4gc3RyaW5naWZ5TnVtYmVyKG5vZGUpO1xufVxuY29uc3QgaW50T2N0ID0ge1xuICAgIGlkZW50aWZ5OiB2YWx1ZSA9PiBpbnRJZGVudGlmeSh2YWx1ZSkgJiYgdmFsdWUgPj0gMCxcbiAgICBkZWZhdWx0OiB0cnVlLFxuICAgIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOmludCcsXG4gICAgZm9ybWF0OiAnT0NUJyxcbiAgICB0ZXN0OiAvXjBvWzAtN10rJC8sXG4gICAgcmVzb2x2ZTogKHN0ciwgX29uRXJyb3IsIG9wdCkgPT4gaW50UmVzb2x2ZShzdHIsIDIsIDgsIG9wdCksXG4gICAgc3RyaW5naWZ5OiBub2RlID0+IGludFN0cmluZ2lmeShub2RlLCA4LCAnMG8nKVxufTtcbmNvbnN0IGludCA9IHtcbiAgICBpZGVudGlmeTogaW50SWRlbnRpZnksXG4gICAgZGVmYXVsdDogdHJ1ZSxcbiAgICB0YWc6ICd0YWc6eWFtbC5vcmcsMjAwMjppbnQnLFxuICAgIHRlc3Q6IC9eWy0rXT9bMC05XSskLyxcbiAgICByZXNvbHZlOiAoc3RyLCBfb25FcnJvciwgb3B0KSA9PiBpbnRSZXNvbHZlKHN0ciwgMCwgMTAsIG9wdCksXG4gICAgc3RyaW5naWZ5OiBzdHJpbmdpZnlOdW1iZXJcbn07XG5jb25zdCBpbnRIZXggPSB7XG4gICAgaWRlbnRpZnk6IHZhbHVlID0+IGludElkZW50aWZ5KHZhbHVlKSAmJiB2YWx1ZSA+PSAwLFxuICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6aW50JyxcbiAgICBmb3JtYXQ6ICdIRVgnLFxuICAgIHRlc3Q6IC9eMHhbMC05YS1mQS1GXSskLyxcbiAgICByZXNvbHZlOiAoc3RyLCBfb25FcnJvciwgb3B0KSA9PiBpbnRSZXNvbHZlKHN0ciwgMiwgMTYsIG9wdCksXG4gICAgc3RyaW5naWZ5OiBub2RlID0+IGludFN0cmluZ2lmeShub2RlLCAxNiwgJzB4Jylcbn07XG5cbmV4cG9ydCB7IGludCwgaW50SGV4LCBpbnRPY3QgfTtcbiIsICJpbXBvcnQgeyBtYXAgfSBmcm9tICcuLi9jb21tb24vbWFwLmpzJztcbmltcG9ydCB7IG51bGxUYWcgfSBmcm9tICcuLi9jb21tb24vbnVsbC5qcyc7XG5pbXBvcnQgeyBzZXEgfSBmcm9tICcuLi9jb21tb24vc2VxLmpzJztcbmltcG9ydCB7IHN0cmluZyB9IGZyb20gJy4uL2NvbW1vbi9zdHJpbmcuanMnO1xuaW1wb3J0IHsgYm9vbFRhZyB9IGZyb20gJy4vYm9vbC5qcyc7XG5pbXBvcnQgeyBmbG9hdE5hTiwgZmxvYXRFeHAsIGZsb2F0IH0gZnJvbSAnLi9mbG9hdC5qcyc7XG5pbXBvcnQgeyBpbnRPY3QsIGludCwgaW50SGV4IH0gZnJvbSAnLi9pbnQuanMnO1xuXG5jb25zdCBzY2hlbWEgPSBbXG4gICAgbWFwLFxuICAgIHNlcSxcbiAgICBzdHJpbmcsXG4gICAgbnVsbFRhZyxcbiAgICBib29sVGFnLFxuICAgIGludE9jdCxcbiAgICBpbnQsXG4gICAgaW50SGV4LFxuICAgIGZsb2F0TmFOLFxuICAgIGZsb2F0RXhwLFxuICAgIGZsb2F0XG5dO1xuXG5leHBvcnQgeyBzY2hlbWEgfTtcbiIsICJpbXBvcnQgeyBTY2FsYXIgfSBmcm9tICcuLi8uLi9ub2Rlcy9TY2FsYXIuanMnO1xuaW1wb3J0IHsgbWFwIH0gZnJvbSAnLi4vY29tbW9uL21hcC5qcyc7XG5pbXBvcnQgeyBzZXEgfSBmcm9tICcuLi9jb21tb24vc2VxLmpzJztcblxuZnVuY3Rpb24gaW50SWRlbnRpZnkodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnYmlnaW50JyB8fCBOdW1iZXIuaXNJbnRlZ2VyKHZhbHVlKTtcbn1cbmNvbnN0IHN0cmluZ2lmeUpTT04gPSAoeyB2YWx1ZSB9KSA9PiBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG5jb25zdCBqc29uU2NhbGFycyA9IFtcbiAgICB7XG4gICAgICAgIGlkZW50aWZ5OiB2YWx1ZSA9PiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnLFxuICAgICAgICBkZWZhdWx0OiB0cnVlLFxuICAgICAgICB0YWc6ICd0YWc6eWFtbC5vcmcsMjAwMjpzdHInLFxuICAgICAgICByZXNvbHZlOiBzdHIgPT4gc3RyLFxuICAgICAgICBzdHJpbmdpZnk6IHN0cmluZ2lmeUpTT05cbiAgICB9LFxuICAgIHtcbiAgICAgICAgaWRlbnRpZnk6IHZhbHVlID0+IHZhbHVlID09IG51bGwsXG4gICAgICAgIGNyZWF0ZU5vZGU6ICgpID0+IG5ldyBTY2FsYXIobnVsbCksXG4gICAgICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgICAgIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOm51bGwnLFxuICAgICAgICB0ZXN0OiAvXm51bGwkLyxcbiAgICAgICAgcmVzb2x2ZTogKCkgPT4gbnVsbCxcbiAgICAgICAgc3RyaW5naWZ5OiBzdHJpbmdpZnlKU09OXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGlkZW50aWZ5OiB2YWx1ZSA9PiB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJyxcbiAgICAgICAgZGVmYXVsdDogdHJ1ZSxcbiAgICAgICAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6Ym9vbCcsXG4gICAgICAgIHRlc3Q6IC9edHJ1ZXxmYWxzZSQvLFxuICAgICAgICByZXNvbHZlOiBzdHIgPT4gc3RyID09PSAndHJ1ZScsXG4gICAgICAgIHN0cmluZ2lmeTogc3RyaW5naWZ5SlNPTlxuICAgIH0sXG4gICAge1xuICAgICAgICBpZGVudGlmeTogaW50SWRlbnRpZnksXG4gICAgICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgICAgIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOmludCcsXG4gICAgICAgIHRlc3Q6IC9eLT8oPzowfFsxLTldWzAtOV0qKSQvLFxuICAgICAgICByZXNvbHZlOiAoc3RyLCBfb25FcnJvciwgeyBpbnRBc0JpZ0ludCB9KSA9PiBpbnRBc0JpZ0ludCA/IEJpZ0ludChzdHIpIDogcGFyc2VJbnQoc3RyLCAxMCksXG4gICAgICAgIHN0cmluZ2lmeTogKHsgdmFsdWUgfSkgPT4gaW50SWRlbnRpZnkodmFsdWUpID8gdmFsdWUudG9TdHJpbmcoKSA6IEpTT04uc3RyaW5naWZ5KHZhbHVlKVxuICAgIH0sXG4gICAge1xuICAgICAgICBpZGVudGlmeTogdmFsdWUgPT4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyxcbiAgICAgICAgZGVmYXVsdDogdHJ1ZSxcbiAgICAgICAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6ZmxvYXQnLFxuICAgICAgICB0ZXN0OiAvXi0/KD86MHxbMS05XVswLTldKikoPzpcXC5bMC05XSopPyg/OltlRV1bLStdP1swLTldKyk/JC8sXG4gICAgICAgIHJlc29sdmU6IHN0ciA9PiBwYXJzZUZsb2F0KHN0ciksXG4gICAgICAgIHN0cmluZ2lmeTogc3RyaW5naWZ5SlNPTlxuICAgIH1cbl07XG5jb25zdCBqc29uRXJyb3IgPSB7XG4gICAgZGVmYXVsdDogdHJ1ZSxcbiAgICB0YWc6ICcnLFxuICAgIHRlc3Q6IC9eLyxcbiAgICByZXNvbHZlKHN0ciwgb25FcnJvcikge1xuICAgICAgICBvbkVycm9yKGBVbnJlc29sdmVkIHBsYWluIHNjYWxhciAke0pTT04uc3RyaW5naWZ5KHN0cil9YCk7XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgfVxufTtcbmNvbnN0IHNjaGVtYSA9IFttYXAsIHNlcV0uY29uY2F0KGpzb25TY2FsYXJzLCBqc29uRXJyb3IpO1xuXG5leHBvcnQgeyBzY2hlbWEgfTtcbiIsICJpbXBvcnQgeyBTY2FsYXIgfSBmcm9tICcuLi8uLi9ub2Rlcy9TY2FsYXIuanMnO1xuaW1wb3J0IHsgc3RyaW5naWZ5U3RyaW5nIH0gZnJvbSAnLi4vLi4vc3RyaW5naWZ5L3N0cmluZ2lmeVN0cmluZy5qcyc7XG5cbmNvbnN0IGJpbmFyeSA9IHtcbiAgICBpZGVudGlmeTogdmFsdWUgPT4gdmFsdWUgaW5zdGFuY2VvZiBVaW50OEFycmF5LFxuICAgIGRlZmF1bHQ6IGZhbHNlLFxuICAgIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOmJpbmFyeScsXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIEJ1ZmZlciBpbiBub2RlIGFuZCBhbiBVaW50OEFycmF5IGluIGJyb3dzZXJzXG4gICAgICpcbiAgICAgKiBUbyB1c2UgdGhlIHJlc3VsdGluZyBidWZmZXIgYXMgYW4gaW1hZ2UsIHlvdSdsbCB3YW50IHRvIGRvIHNvbWV0aGluZyBsaWtlOlxuICAgICAqXG4gICAgICogICBjb25zdCBibG9iID0gbmV3IEJsb2IoW2J1ZmZlcl0sIHsgdHlwZTogJ2ltYWdlL2pwZWcnIH0pXG4gICAgICogICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjcGhvdG8nKS5zcmMgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpXG4gICAgICovXG4gICAgcmVzb2x2ZShzcmMsIG9uRXJyb3IpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBCdWZmZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybiBCdWZmZXIuZnJvbShzcmMsICdiYXNlNjQnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgYXRvYiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgLy8gT24gSUUgMTEsIGF0b2IoKSBjYW4ndCBoYW5kbGUgbmV3bGluZXNcbiAgICAgICAgICAgIGNvbnN0IHN0ciA9IGF0b2Ioc3JjLnJlcGxhY2UoL1tcXG5cXHJdL2csICcnKSk7XG4gICAgICAgICAgICBjb25zdCBidWZmZXIgPSBuZXcgVWludDhBcnJheShzdHIubGVuZ3RoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgIGJ1ZmZlcltpXSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICAgICAgcmV0dXJuIGJ1ZmZlcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9uRXJyb3IoJ1RoaXMgZW52aXJvbm1lbnQgZG9lcyBub3Qgc3VwcG9ydCByZWFkaW5nIGJpbmFyeSB0YWdzOyBlaXRoZXIgQnVmZmVyIG9yIGF0b2IgaXMgcmVxdWlyZWQnKTtcbiAgICAgICAgICAgIHJldHVybiBzcmM7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHN0cmluZ2lmeSh7IGNvbW1lbnQsIHR5cGUsIHZhbHVlIH0sIGN0eCwgb25Db21tZW50LCBvbkNob21wS2VlcCkge1xuICAgICAgICBjb25zdCBidWYgPSB2YWx1ZTsgLy8gY2hlY2tlZCBlYXJsaWVyIGJ5IGJpbmFyeS5pZGVudGlmeSgpXG4gICAgICAgIGxldCBzdHI7XG4gICAgICAgIGlmICh0eXBlb2YgQnVmZmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBzdHIgPVxuICAgICAgICAgICAgICAgIGJ1ZiBpbnN0YW5jZW9mIEJ1ZmZlclxuICAgICAgICAgICAgICAgICAgICA/IGJ1Zi50b1N0cmluZygnYmFzZTY0JylcbiAgICAgICAgICAgICAgICAgICAgOiBCdWZmZXIuZnJvbShidWYuYnVmZmVyKS50b1N0cmluZygnYmFzZTY0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGJ0b2EgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGxldCBzID0gJyc7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ1Zi5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICBzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKTtcbiAgICAgICAgICAgIHN0ciA9IGJ0b2Eocyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgZW52aXJvbm1lbnQgZG9lcyBub3Qgc3VwcG9ydCB3cml0aW5nIGJpbmFyeSB0YWdzOyBlaXRoZXIgQnVmZmVyIG9yIGJ0b2EgaXMgcmVxdWlyZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXR5cGUpXG4gICAgICAgICAgICB0eXBlID0gU2NhbGFyLkJMT0NLX0xJVEVSQUw7XG4gICAgICAgIGlmICh0eXBlICE9PSBTY2FsYXIuUVVPVEVfRE9VQkxFKSB7XG4gICAgICAgICAgICBjb25zdCBsaW5lV2lkdGggPSBNYXRoLm1heChjdHgub3B0aW9ucy5saW5lV2lkdGggLSBjdHguaW5kZW50Lmxlbmd0aCwgY3R4Lm9wdGlvbnMubWluQ29udGVudFdpZHRoKTtcbiAgICAgICAgICAgIGNvbnN0IG4gPSBNYXRoLmNlaWwoc3RyLmxlbmd0aCAvIGxpbmVXaWR0aCk7XG4gICAgICAgICAgICBjb25zdCBsaW5lcyA9IG5ldyBBcnJheShuKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBvID0gMDsgaSA8IG47ICsraSwgbyArPSBsaW5lV2lkdGgpIHtcbiAgICAgICAgICAgICAgICBsaW5lc1tpXSA9IHN0ci5zdWJzdHIobywgbGluZVdpZHRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0ciA9IGxpbmVzLmpvaW4odHlwZSA9PT0gU2NhbGFyLkJMT0NLX0xJVEVSQUwgPyAnXFxuJyA6ICcgJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0cmluZ2lmeVN0cmluZyh7IGNvbW1lbnQsIHR5cGUsIHZhbHVlOiBzdHIgfSwgY3R4LCBvbkNvbW1lbnQsIG9uQ2hvbXBLZWVwKTtcbiAgICB9XG59O1xuXG5leHBvcnQgeyBiaW5hcnkgfTtcbiIsICJpbXBvcnQgeyBpc1NlcSwgaXNQYWlyLCBpc01hcCB9IGZyb20gJy4uLy4uL25vZGVzL05vZGUuanMnO1xuaW1wb3J0IHsgUGFpciwgY3JlYXRlUGFpciB9IGZyb20gJy4uLy4uL25vZGVzL1BhaXIuanMnO1xuaW1wb3J0IHsgU2NhbGFyIH0gZnJvbSAnLi4vLi4vbm9kZXMvU2NhbGFyLmpzJztcbmltcG9ydCB7IFlBTUxTZXEgfSBmcm9tICcuLi8uLi9ub2Rlcy9ZQU1MU2VxLmpzJztcblxuZnVuY3Rpb24gcmVzb2x2ZVBhaXJzKHNlcSwgb25FcnJvcikge1xuICAgIGlmIChpc1NlcShzZXEpKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2VxLml0ZW1zLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBsZXQgaXRlbSA9IHNlcS5pdGVtc1tpXTtcbiAgICAgICAgICAgIGlmIChpc1BhaXIoaXRlbSkpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBlbHNlIGlmIChpc01hcChpdGVtKSkge1xuICAgICAgICAgICAgICAgIGlmIChpdGVtLml0ZW1zLmxlbmd0aCA+IDEpXG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3IoJ0VhY2ggcGFpciBtdXN0IGhhdmUgaXRzIG93biBzZXF1ZW5jZSBpbmRpY2F0b3InKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwYWlyID0gaXRlbS5pdGVtc1swXSB8fCBuZXcgUGFpcihuZXcgU2NhbGFyKG51bGwpKTtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbS5jb21tZW50QmVmb3JlKVxuICAgICAgICAgICAgICAgICAgICBwYWlyLmtleS5jb21tZW50QmVmb3JlID0gcGFpci5rZXkuY29tbWVudEJlZm9yZVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBgJHtpdGVtLmNvbW1lbnRCZWZvcmV9XFxuJHtwYWlyLmtleS5jb21tZW50QmVmb3JlfWBcbiAgICAgICAgICAgICAgICAgICAgICAgIDogaXRlbS5jb21tZW50QmVmb3JlO1xuICAgICAgICAgICAgICAgIGlmIChpdGVtLmNvbW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY24gPSBwYWlyLnZhbHVlIHx8IHBhaXIua2V5O1xuICAgICAgICAgICAgICAgICAgICBjbi5jb21tZW50ID0gY24uY29tbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgPyBgJHtpdGVtLmNvbW1lbnR9XFxuJHtjbi5jb21tZW50fWBcbiAgICAgICAgICAgICAgICAgICAgICAgIDogaXRlbS5jb21tZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpdGVtID0gcGFpcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlcS5pdGVtc1tpXSA9IGlzUGFpcihpdGVtKSA/IGl0ZW0gOiBuZXcgUGFpcihpdGVtKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlXG4gICAgICAgIG9uRXJyb3IoJ0V4cGVjdGVkIGEgc2VxdWVuY2UgZm9yIHRoaXMgdGFnJyk7XG4gICAgcmV0dXJuIHNlcTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVBhaXJzKHNjaGVtYSwgaXRlcmFibGUsIGN0eCkge1xuICAgIGNvbnN0IHsgcmVwbGFjZXIgfSA9IGN0eDtcbiAgICBjb25zdCBwYWlycyA9IG5ldyBZQU1MU2VxKHNjaGVtYSk7XG4gICAgcGFpcnMudGFnID0gJ3RhZzp5YW1sLm9yZywyMDAyOnBhaXJzJztcbiAgICBsZXQgaSA9IDA7XG4gICAgaWYgKGl0ZXJhYmxlICYmIFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoaXRlcmFibGUpKVxuICAgICAgICBmb3IgKGxldCBpdCBvZiBpdGVyYWJsZSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiByZXBsYWNlciA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgICAgICBpdCA9IHJlcGxhY2VyLmNhbGwoaXRlcmFibGUsIFN0cmluZyhpKyspLCBpdCk7XG4gICAgICAgICAgICBsZXQga2V5LCB2YWx1ZTtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGl0KSkge1xuICAgICAgICAgICAgICAgIGlmIChpdC5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAga2V5ID0gaXRbMF07XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gaXRbMV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgRXhwZWN0ZWQgW2tleSwgdmFsdWVdIHR1cGxlOiAke2l0fWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXQgJiYgaXQgaW5zdGFuY2VvZiBPYmplY3QpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoaXQpO1xuICAgICAgICAgICAgICAgIGlmIChrZXlzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICBrZXkgPSBrZXlzWzBdO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGl0W2tleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgRXhwZWN0ZWQgeyBrZXk6IHZhbHVlIH0gdHVwbGU6ICR7aXR9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBrZXkgPSBpdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhaXJzLml0ZW1zLnB1c2goY3JlYXRlUGFpcihrZXksIHZhbHVlLCBjdHgpKTtcbiAgICAgICAgfVxuICAgIHJldHVybiBwYWlycztcbn1cbmNvbnN0IHBhaXJzID0ge1xuICAgIGNvbGxlY3Rpb246ICdzZXEnLFxuICAgIGRlZmF1bHQ6IGZhbHNlLFxuICAgIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOnBhaXJzJyxcbiAgICByZXNvbHZlOiByZXNvbHZlUGFpcnMsXG4gICAgY3JlYXRlTm9kZTogY3JlYXRlUGFpcnNcbn07XG5cbmV4cG9ydCB7IGNyZWF0ZVBhaXJzLCBwYWlycywgcmVzb2x2ZVBhaXJzIH07XG4iLCAiaW1wb3J0IHsgWUFNTFNlcSB9IGZyb20gJy4uLy4uL25vZGVzL1lBTUxTZXEuanMnO1xuaW1wb3J0IHsgdG9KUyB9IGZyb20gJy4uLy4uL25vZGVzL3RvSlMuanMnO1xuaW1wb3J0IHsgaXNTY2FsYXIsIGlzUGFpciB9IGZyb20gJy4uLy4uL25vZGVzL05vZGUuanMnO1xuaW1wb3J0IHsgWUFNTE1hcCB9IGZyb20gJy4uLy4uL25vZGVzL1lBTUxNYXAuanMnO1xuaW1wb3J0IHsgcmVzb2x2ZVBhaXJzLCBjcmVhdGVQYWlycyB9IGZyb20gJy4vcGFpcnMuanMnO1xuXG5jbGFzcyBZQU1MT01hcCBleHRlbmRzIFlBTUxTZXEge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmFkZCA9IFlBTUxNYXAucHJvdG90eXBlLmFkZC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmRlbGV0ZSA9IFlBTUxNYXAucHJvdG90eXBlLmRlbGV0ZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmdldCA9IFlBTUxNYXAucHJvdG90eXBlLmdldC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmhhcyA9IFlBTUxNYXAucHJvdG90eXBlLmhhcy5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnNldCA9IFlBTUxNYXAucHJvdG90eXBlLnNldC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnRhZyA9IFlBTUxPTWFwLnRhZztcbiAgICB9XG4gICAgLyoqXG4gICAgICogSWYgYGN0eGAgaXMgZ2l2ZW4sIHRoZSByZXR1cm4gdHlwZSBpcyBhY3R1YWxseSBgTWFwPHVua25vd24sIHVua25vd24+YCxcbiAgICAgKiBidXQgVHlwZVNjcmlwdCB3b24ndCBhbGxvdyB3aWRlbmluZyB0aGUgc2lnbmF0dXJlIG9mIGEgY2hpbGQgbWV0aG9kLlxuICAgICAqL1xuICAgIHRvSlNPTihfLCBjdHgpIHtcbiAgICAgICAgaWYgKCFjdHgpXG4gICAgICAgICAgICByZXR1cm4gc3VwZXIudG9KU09OKF8pO1xuICAgICAgICBjb25zdCBtYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIGlmIChjdHggJiYgY3R4Lm9uQ3JlYXRlKVxuICAgICAgICAgICAgY3R4Lm9uQ3JlYXRlKG1hcCk7XG4gICAgICAgIGZvciAoY29uc3QgcGFpciBvZiB0aGlzLml0ZW1zKSB7XG4gICAgICAgICAgICBsZXQga2V5LCB2YWx1ZTtcbiAgICAgICAgICAgIGlmIChpc1BhaXIocGFpcikpIHtcbiAgICAgICAgICAgICAgICBrZXkgPSB0b0pTKHBhaXIua2V5LCAnJywgY3R4KTtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHRvSlMocGFpci52YWx1ZSwga2V5LCBjdHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAga2V5ID0gdG9KUyhwYWlyLCAnJywgY3R4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYXAuaGFzKGtleSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdPcmRlcmVkIG1hcHMgbXVzdCBub3QgaW5jbHVkZSBkdXBsaWNhdGUga2V5cycpO1xuICAgICAgICAgICAgbWFwLnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWFwO1xuICAgIH1cbn1cbllBTUxPTWFwLnRhZyA9ICd0YWc6eWFtbC5vcmcsMjAwMjpvbWFwJztcbmNvbnN0IG9tYXAgPSB7XG4gICAgY29sbGVjdGlvbjogJ3NlcScsXG4gICAgaWRlbnRpZnk6IHZhbHVlID0+IHZhbHVlIGluc3RhbmNlb2YgTWFwLFxuICAgIG5vZGVDbGFzczogWUFNTE9NYXAsXG4gICAgZGVmYXVsdDogZmFsc2UsXG4gICAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6b21hcCcsXG4gICAgcmVzb2x2ZShzZXEsIG9uRXJyb3IpIHtcbiAgICAgICAgY29uc3QgcGFpcnMgPSByZXNvbHZlUGFpcnMoc2VxLCBvbkVycm9yKTtcbiAgICAgICAgY29uc3Qgc2VlbktleXMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCB7IGtleSB9IG9mIHBhaXJzLml0ZW1zKSB7XG4gICAgICAgICAgICBpZiAoaXNTY2FsYXIoa2V5KSkge1xuICAgICAgICAgICAgICAgIGlmIChzZWVuS2V5cy5pbmNsdWRlcyhrZXkudmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3IoYE9yZGVyZWQgbWFwcyBtdXN0IG5vdCBpbmNsdWRlIGR1cGxpY2F0ZSBrZXlzOiAke2tleS52YWx1ZX1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNlZW5LZXlzLnB1c2goa2V5LnZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24obmV3IFlBTUxPTWFwKCksIHBhaXJzKTtcbiAgICB9LFxuICAgIGNyZWF0ZU5vZGUoc2NoZW1hLCBpdGVyYWJsZSwgY3R4KSB7XG4gICAgICAgIGNvbnN0IHBhaXJzID0gY3JlYXRlUGFpcnMoc2NoZW1hLCBpdGVyYWJsZSwgY3R4KTtcbiAgICAgICAgY29uc3Qgb21hcCA9IG5ldyBZQU1MT01hcCgpO1xuICAgICAgICBvbWFwLml0ZW1zID0gcGFpcnMuaXRlbXM7XG4gICAgICAgIHJldHVybiBvbWFwO1xuICAgIH1cbn07XG5cbmV4cG9ydCB7IFlBTUxPTWFwLCBvbWFwIH07XG4iLCAiaW1wb3J0IHsgU2NhbGFyIH0gZnJvbSAnLi4vLi4vbm9kZXMvU2NhbGFyLmpzJztcblxuZnVuY3Rpb24gYm9vbFN0cmluZ2lmeSh7IHZhbHVlLCBzb3VyY2UgfSwgY3R4KSB7XG4gICAgY29uc3QgYm9vbE9iaiA9IHZhbHVlID8gdHJ1ZVRhZyA6IGZhbHNlVGFnO1xuICAgIGlmIChzb3VyY2UgJiYgYm9vbE9iai50ZXN0LnRlc3Qoc291cmNlKSlcbiAgICAgICAgcmV0dXJuIHNvdXJjZTtcbiAgICByZXR1cm4gdmFsdWUgPyBjdHgub3B0aW9ucy50cnVlU3RyIDogY3R4Lm9wdGlvbnMuZmFsc2VTdHI7XG59XG5jb25zdCB0cnVlVGFnID0ge1xuICAgIGlkZW50aWZ5OiB2YWx1ZSA9PiB2YWx1ZSA9PT0gdHJ1ZSxcbiAgICBkZWZhdWx0OiB0cnVlLFxuICAgIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOmJvb2wnLFxuICAgIHRlc3Q6IC9eKD86WXx5fFtZeV1lc3xZRVN8W1R0XXJ1ZXxUUlVFfFtPb11ufE9OKSQvLFxuICAgIHJlc29sdmU6ICgpID0+IG5ldyBTY2FsYXIodHJ1ZSksXG4gICAgc3RyaW5naWZ5OiBib29sU3RyaW5naWZ5XG59O1xuY29uc3QgZmFsc2VUYWcgPSB7XG4gICAgaWRlbnRpZnk6IHZhbHVlID0+IHZhbHVlID09PSBmYWxzZSxcbiAgICBkZWZhdWx0OiB0cnVlLFxuICAgIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOmJvb2wnLFxuICAgIHRlc3Q6IC9eKD86TnxufFtObl1vfE5PfFtGZl1hbHNlfEZBTFNFfFtPb11mZnxPRkYpJC9pLFxuICAgIHJlc29sdmU6ICgpID0+IG5ldyBTY2FsYXIoZmFsc2UpLFxuICAgIHN0cmluZ2lmeTogYm9vbFN0cmluZ2lmeVxufTtcblxuZXhwb3J0IHsgZmFsc2VUYWcsIHRydWVUYWcgfTtcbiIsICJpbXBvcnQgeyBTY2FsYXIgfSBmcm9tICcuLi8uLi9ub2Rlcy9TY2FsYXIuanMnO1xuaW1wb3J0IHsgc3RyaW5naWZ5TnVtYmVyIH0gZnJvbSAnLi4vLi4vc3RyaW5naWZ5L3N0cmluZ2lmeU51bWJlci5qcyc7XG5cbmNvbnN0IGZsb2F0TmFOID0ge1xuICAgIGlkZW50aWZ5OiB2YWx1ZSA9PiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInLFxuICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6ZmxvYXQnLFxuICAgIHRlc3Q6IC9eWy0rXT9cXC4oPzppbmZ8SW5mfElORnxuYW58TmFOfE5BTikkLyxcbiAgICByZXNvbHZlOiAoc3RyKSA9PiBzdHIuc2xpY2UoLTMpLnRvTG93ZXJDYXNlKCkgPT09ICduYW4nXG4gICAgICAgID8gTmFOXG4gICAgICAgIDogc3RyWzBdID09PSAnLSdcbiAgICAgICAgICAgID8gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZXG4gICAgICAgICAgICA6IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSxcbiAgICBzdHJpbmdpZnk6IHN0cmluZ2lmeU51bWJlclxufTtcbmNvbnN0IGZsb2F0RXhwID0ge1xuICAgIGlkZW50aWZ5OiB2YWx1ZSA9PiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInLFxuICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6ZmxvYXQnLFxuICAgIGZvcm1hdDogJ0VYUCcsXG4gICAgdGVzdDogL15bLStdPyg/OlswLTldWzAtOV9dKik/KD86XFwuWzAtOV9dKik/W2VFXVstK10/WzAtOV0rJC8sXG4gICAgcmVzb2x2ZTogKHN0cikgPT4gcGFyc2VGbG9hdChzdHIucmVwbGFjZSgvXy9nLCAnJykpLFxuICAgIHN0cmluZ2lmeShub2RlKSB7XG4gICAgICAgIGNvbnN0IG51bSA9IE51bWJlcihub2RlLnZhbHVlKTtcbiAgICAgICAgcmV0dXJuIGlzRmluaXRlKG51bSkgPyBudW0udG9FeHBvbmVudGlhbCgpIDogc3RyaW5naWZ5TnVtYmVyKG5vZGUpO1xuICAgIH1cbn07XG5jb25zdCBmbG9hdCA9IHtcbiAgICBpZGVudGlmeTogdmFsdWUgPT4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyxcbiAgICBkZWZhdWx0OiB0cnVlLFxuICAgIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOmZsb2F0JyxcbiAgICB0ZXN0OiAvXlstK10/KD86WzAtOV1bMC05X10qKT9cXC5bMC05X10qJC8sXG4gICAgcmVzb2x2ZShzdHIpIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IG5ldyBTY2FsYXIocGFyc2VGbG9hdChzdHIucmVwbGFjZSgvXy9nLCAnJykpKTtcbiAgICAgICAgY29uc3QgZG90ID0gc3RyLmluZGV4T2YoJy4nKTtcbiAgICAgICAgaWYgKGRvdCAhPT0gLTEpIHtcbiAgICAgICAgICAgIGNvbnN0IGYgPSBzdHIuc3Vic3RyaW5nKGRvdCArIDEpLnJlcGxhY2UoL18vZywgJycpO1xuICAgICAgICAgICAgaWYgKGZbZi5sZW5ndGggLSAxXSA9PT0gJzAnKVxuICAgICAgICAgICAgICAgIG5vZGUubWluRnJhY3Rpb25EaWdpdHMgPSBmLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9LFxuICAgIHN0cmluZ2lmeTogc3RyaW5naWZ5TnVtYmVyXG59O1xuXG5leHBvcnQgeyBmbG9hdCwgZmxvYXRFeHAsIGZsb2F0TmFOIH07XG4iLCAiaW1wb3J0IHsgc3RyaW5naWZ5TnVtYmVyIH0gZnJvbSAnLi4vLi4vc3RyaW5naWZ5L3N0cmluZ2lmeU51bWJlci5qcyc7XG5cbmNvbnN0IGludElkZW50aWZ5ID0gKHZhbHVlKSA9PiB0eXBlb2YgdmFsdWUgPT09ICdiaWdpbnQnIHx8IE51bWJlci5pc0ludGVnZXIodmFsdWUpO1xuZnVuY3Rpb24gaW50UmVzb2x2ZShzdHIsIG9mZnNldCwgcmFkaXgsIHsgaW50QXNCaWdJbnQgfSkge1xuICAgIGNvbnN0IHNpZ24gPSBzdHJbMF07XG4gICAgaWYgKHNpZ24gPT09ICctJyB8fCBzaWduID09PSAnKycpXG4gICAgICAgIG9mZnNldCArPSAxO1xuICAgIHN0ciA9IHN0ci5zdWJzdHJpbmcob2Zmc2V0KS5yZXBsYWNlKC9fL2csICcnKTtcbiAgICBpZiAoaW50QXNCaWdJbnQpIHtcbiAgICAgICAgc3dpdGNoIChyYWRpeCkge1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIHN0ciA9IGAwYiR7c3RyfWA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgc3RyID0gYDBvJHtzdHJ9YDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMTY6XG4gICAgICAgICAgICAgICAgc3RyID0gYDB4JHtzdHJ9YDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuID0gQmlnSW50KHN0cik7XG4gICAgICAgIHJldHVybiBzaWduID09PSAnLScgPyBCaWdJbnQoLTEpICogbiA6IG47XG4gICAgfVxuICAgIGNvbnN0IG4gPSBwYXJzZUludChzdHIsIHJhZGl4KTtcbiAgICByZXR1cm4gc2lnbiA9PT0gJy0nID8gLTEgKiBuIDogbjtcbn1cbmZ1bmN0aW9uIGludFN0cmluZ2lmeShub2RlLCByYWRpeCwgcHJlZml4KSB7XG4gICAgY29uc3QgeyB2YWx1ZSB9ID0gbm9kZTtcbiAgICBpZiAoaW50SWRlbnRpZnkodmFsdWUpKSB7XG4gICAgICAgIGNvbnN0IHN0ciA9IHZhbHVlLnRvU3RyaW5nKHJhZGl4KTtcbiAgICAgICAgcmV0dXJuIHZhbHVlIDwgMCA/ICctJyArIHByZWZpeCArIHN0ci5zdWJzdHIoMSkgOiBwcmVmaXggKyBzdHI7XG4gICAgfVxuICAgIHJldHVybiBzdHJpbmdpZnlOdW1iZXIobm9kZSk7XG59XG5jb25zdCBpbnRCaW4gPSB7XG4gICAgaWRlbnRpZnk6IGludElkZW50aWZ5LFxuICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6aW50JyxcbiAgICBmb3JtYXQ6ICdCSU4nLFxuICAgIHRlc3Q6IC9eWy0rXT8wYlswLTFfXSskLyxcbiAgICByZXNvbHZlOiAoc3RyLCBfb25FcnJvciwgb3B0KSA9PiBpbnRSZXNvbHZlKHN0ciwgMiwgMiwgb3B0KSxcbiAgICBzdHJpbmdpZnk6IG5vZGUgPT4gaW50U3RyaW5naWZ5KG5vZGUsIDIsICcwYicpXG59O1xuY29uc3QgaW50T2N0ID0ge1xuICAgIGlkZW50aWZ5OiBpbnRJZGVudGlmeSxcbiAgICBkZWZhdWx0OiB0cnVlLFxuICAgIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOmludCcsXG4gICAgZm9ybWF0OiAnT0NUJyxcbiAgICB0ZXN0OiAvXlstK10/MFswLTdfXSskLyxcbiAgICByZXNvbHZlOiAoc3RyLCBfb25FcnJvciwgb3B0KSA9PiBpbnRSZXNvbHZlKHN0ciwgMSwgOCwgb3B0KSxcbiAgICBzdHJpbmdpZnk6IG5vZGUgPT4gaW50U3RyaW5naWZ5KG5vZGUsIDgsICcwJylcbn07XG5jb25zdCBpbnQgPSB7XG4gICAgaWRlbnRpZnk6IGludElkZW50aWZ5LFxuICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6aW50JyxcbiAgICB0ZXN0OiAvXlstK10/WzAtOV1bMC05X10qJC8sXG4gICAgcmVzb2x2ZTogKHN0ciwgX29uRXJyb3IsIG9wdCkgPT4gaW50UmVzb2x2ZShzdHIsIDAsIDEwLCBvcHQpLFxuICAgIHN0cmluZ2lmeTogc3RyaW5naWZ5TnVtYmVyXG59O1xuY29uc3QgaW50SGV4ID0ge1xuICAgIGlkZW50aWZ5OiBpbnRJZGVudGlmeSxcbiAgICBkZWZhdWx0OiB0cnVlLFxuICAgIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOmludCcsXG4gICAgZm9ybWF0OiAnSEVYJyxcbiAgICB0ZXN0OiAvXlstK10/MHhbMC05YS1mQS1GX10rJC8sXG4gICAgcmVzb2x2ZTogKHN0ciwgX29uRXJyb3IsIG9wdCkgPT4gaW50UmVzb2x2ZShzdHIsIDIsIDE2LCBvcHQpLFxuICAgIHN0cmluZ2lmeTogbm9kZSA9PiBpbnRTdHJpbmdpZnkobm9kZSwgMTYsICcweCcpXG59O1xuXG5leHBvcnQgeyBpbnQsIGludEJpbiwgaW50SGV4LCBpbnRPY3QgfTtcbiIsICJpbXBvcnQgeyBpc01hcCwgaXNQYWlyLCBpc1NjYWxhciB9IGZyb20gJy4uLy4uL25vZGVzL05vZGUuanMnO1xuaW1wb3J0IHsgY3JlYXRlUGFpciwgUGFpciB9IGZyb20gJy4uLy4uL25vZGVzL1BhaXIuanMnO1xuaW1wb3J0IHsgWUFNTE1hcCwgZmluZFBhaXIgfSBmcm9tICcuLi8uLi9ub2Rlcy9ZQU1MTWFwLmpzJztcblxuY2xhc3MgWUFNTFNldCBleHRlbmRzIFlBTUxNYXAge1xuICAgIGNvbnN0cnVjdG9yKHNjaGVtYSkge1xuICAgICAgICBzdXBlcihzY2hlbWEpO1xuICAgICAgICB0aGlzLnRhZyA9IFlBTUxTZXQudGFnO1xuICAgIH1cbiAgICBhZGQoa2V5KSB7XG4gICAgICAgIGxldCBwYWlyO1xuICAgICAgICBpZiAoaXNQYWlyKGtleSkpXG4gICAgICAgICAgICBwYWlyID0ga2V5O1xuICAgICAgICBlbHNlIGlmICh0eXBlb2Yga2V5ID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgJ2tleScgaW4ga2V5ICYmXG4gICAgICAgICAgICAndmFsdWUnIGluIGtleSAmJlxuICAgICAgICAgICAga2V5LnZhbHVlID09PSBudWxsKVxuICAgICAgICAgICAgcGFpciA9IG5ldyBQYWlyKGtleS5rZXksIG51bGwpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBwYWlyID0gbmV3IFBhaXIoa2V5LCBudWxsKTtcbiAgICAgICAgY29uc3QgcHJldiA9IGZpbmRQYWlyKHRoaXMuaXRlbXMsIHBhaXIua2V5KTtcbiAgICAgICAgaWYgKCFwcmV2KVxuICAgICAgICAgICAgdGhpcy5pdGVtcy5wdXNoKHBhaXIpO1xuICAgIH1cbiAgICBnZXQoa2V5LCBrZWVwUGFpcikge1xuICAgICAgICBjb25zdCBwYWlyID0gZmluZFBhaXIodGhpcy5pdGVtcywga2V5KTtcbiAgICAgICAgcmV0dXJuICFrZWVwUGFpciAmJiBpc1BhaXIocGFpcilcbiAgICAgICAgICAgID8gaXNTY2FsYXIocGFpci5rZXkpXG4gICAgICAgICAgICAgICAgPyBwYWlyLmtleS52YWx1ZVxuICAgICAgICAgICAgICAgIDogcGFpci5rZXlcbiAgICAgICAgICAgIDogcGFpcjtcbiAgICB9XG4gICAgc2V0KGtleSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ2Jvb2xlYW4nKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBib29sZWFuIHZhbHVlIGZvciBzZXQoa2V5LCB2YWx1ZSkgaW4gYSBZQU1MIHNldCwgbm90ICR7dHlwZW9mIHZhbHVlfWApO1xuICAgICAgICBjb25zdCBwcmV2ID0gZmluZFBhaXIodGhpcy5pdGVtcywga2V5KTtcbiAgICAgICAgaWYgKHByZXYgJiYgIXZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLml0ZW1zLnNwbGljZSh0aGlzLml0ZW1zLmluZGV4T2YocHJldiksIDEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFwcmV2ICYmIHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLml0ZW1zLnB1c2gobmV3IFBhaXIoa2V5KSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdG9KU09OKF8sIGN0eCkge1xuICAgICAgICByZXR1cm4gc3VwZXIudG9KU09OKF8sIGN0eCwgU2V0KTtcbiAgICB9XG4gICAgdG9TdHJpbmcoY3R4LCBvbkNvbW1lbnQsIG9uQ2hvbXBLZWVwKSB7XG4gICAgICAgIGlmICghY3R4KVxuICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMpO1xuICAgICAgICBpZiAodGhpcy5oYXNBbGxOdWxsVmFsdWVzKHRydWUpKVxuICAgICAgICAgICAgcmV0dXJuIHN1cGVyLnRvU3RyaW5nKE9iamVjdC5hc3NpZ24oe30sIGN0eCwgeyBhbGxOdWxsVmFsdWVzOiB0cnVlIH0pLCBvbkNvbW1lbnQsIG9uQ2hvbXBLZWVwKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTZXQgaXRlbXMgbXVzdCBhbGwgaGF2ZSBudWxsIHZhbHVlcycpO1xuICAgIH1cbn1cbllBTUxTZXQudGFnID0gJ3RhZzp5YW1sLm9yZywyMDAyOnNldCc7XG5jb25zdCBzZXQgPSB7XG4gICAgY29sbGVjdGlvbjogJ21hcCcsXG4gICAgaWRlbnRpZnk6IHZhbHVlID0+IHZhbHVlIGluc3RhbmNlb2YgU2V0LFxuICAgIG5vZGVDbGFzczogWUFNTFNldCxcbiAgICBkZWZhdWx0OiBmYWxzZSxcbiAgICB0YWc6ICd0YWc6eWFtbC5vcmcsMjAwMjpzZXQnLFxuICAgIHJlc29sdmUobWFwLCBvbkVycm9yKSB7XG4gICAgICAgIGlmIChpc01hcChtYXApKSB7XG4gICAgICAgICAgICBpZiAobWFwLmhhc0FsbE51bGxWYWx1ZXModHJ1ZSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24obmV3IFlBTUxTZXQoKSwgbWFwKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBvbkVycm9yKCdTZXQgaXRlbXMgbXVzdCBhbGwgaGF2ZSBudWxsIHZhbHVlcycpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIG9uRXJyb3IoJ0V4cGVjdGVkIGEgbWFwcGluZyBmb3IgdGhpcyB0YWcnKTtcbiAgICAgICAgcmV0dXJuIG1hcDtcbiAgICB9LFxuICAgIGNyZWF0ZU5vZGUoc2NoZW1hLCBpdGVyYWJsZSwgY3R4KSB7XG4gICAgICAgIGNvbnN0IHsgcmVwbGFjZXIgfSA9IGN0eDtcbiAgICAgICAgY29uc3Qgc2V0ID0gbmV3IFlBTUxTZXQoc2NoZW1hKTtcbiAgICAgICAgaWYgKGl0ZXJhYmxlICYmIFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoaXRlcmFibGUpKVxuICAgICAgICAgICAgZm9yIChsZXQgdmFsdWUgb2YgaXRlcmFibGUpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHJlcGxhY2VyID09PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHJlcGxhY2VyLmNhbGwoaXRlcmFibGUsIHZhbHVlLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgc2V0Lml0ZW1zLnB1c2goY3JlYXRlUGFpcih2YWx1ZSwgbnVsbCwgY3R4KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZXQ7XG4gICAgfVxufTtcblxuZXhwb3J0IHsgWUFNTFNldCwgc2V0IH07XG4iLCAiaW1wb3J0IHsgc3RyaW5naWZ5TnVtYmVyIH0gZnJvbSAnLi4vLi4vc3RyaW5naWZ5L3N0cmluZ2lmeU51bWJlci5qcyc7XG5cbi8qKiBJbnRlcm5hbCB0eXBlcyBoYW5kbGUgYmlnaW50IGFzIG51bWJlciwgYmVjYXVzZSBUUyBjYW4ndCBmaWd1cmUgaXQgb3V0LiAqL1xuZnVuY3Rpb24gcGFyc2VTZXhhZ2VzaW1hbChzdHIsIGFzQmlnSW50KSB7XG4gICAgY29uc3Qgc2lnbiA9IHN0clswXTtcbiAgICBjb25zdCBwYXJ0cyA9IHNpZ24gPT09ICctJyB8fCBzaWduID09PSAnKycgPyBzdHIuc3Vic3RyaW5nKDEpIDogc3RyO1xuICAgIGNvbnN0IG51bSA9IChuKSA9PiBhc0JpZ0ludCA/IEJpZ0ludChuKSA6IE51bWJlcihuKTtcbiAgICBjb25zdCByZXMgPSBwYXJ0c1xuICAgICAgICAucmVwbGFjZSgvXy9nLCAnJylcbiAgICAgICAgLnNwbGl0KCc6JylcbiAgICAgICAgLnJlZHVjZSgocmVzLCBwKSA9PiByZXMgKiBudW0oNjApICsgbnVtKHApLCBudW0oMCkpO1xuICAgIHJldHVybiAoc2lnbiA9PT0gJy0nID8gbnVtKC0xKSAqIHJlcyA6IHJlcyk7XG59XG4vKipcbiAqIGhoaGg6bW06c3Muc3NzXG4gKlxuICogSW50ZXJuYWwgdHlwZXMgaGFuZGxlIGJpZ2ludCBhcyBudW1iZXIsIGJlY2F1c2UgVFMgY2FuJ3QgZmlndXJlIGl0IG91dC5cbiAqL1xuZnVuY3Rpb24gc3RyaW5naWZ5U2V4YWdlc2ltYWwobm9kZSkge1xuICAgIGxldCB7IHZhbHVlIH0gPSBub2RlO1xuICAgIGxldCBudW0gPSAobikgPT4gbjtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnYmlnaW50JylcbiAgICAgICAgbnVtID0gbiA9PiBCaWdJbnQobik7XG4gICAgZWxzZSBpZiAoaXNOYU4odmFsdWUpIHx8ICFpc0Zpbml0ZSh2YWx1ZSkpXG4gICAgICAgIHJldHVybiBzdHJpbmdpZnlOdW1iZXIobm9kZSk7XG4gICAgbGV0IHNpZ24gPSAnJztcbiAgICBpZiAodmFsdWUgPCAwKSB7XG4gICAgICAgIHNpZ24gPSAnLSc7XG4gICAgICAgIHZhbHVlICo9IG51bSgtMSk7XG4gICAgfVxuICAgIGNvbnN0IF82MCA9IG51bSg2MCk7XG4gICAgY29uc3QgcGFydHMgPSBbdmFsdWUgJSBfNjBdOyAvLyBzZWNvbmRzLCBpbmNsdWRpbmcgbXNcbiAgICBpZiAodmFsdWUgPCA2MCkge1xuICAgICAgICBwYXJ0cy51bnNoaWZ0KDApOyAvLyBhdCBsZWFzdCBvbmUgOiBpcyByZXF1aXJlZFxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmFsdWUgPSAodmFsdWUgLSBwYXJ0c1swXSkgLyBfNjA7XG4gICAgICAgIHBhcnRzLnVuc2hpZnQodmFsdWUgJSBfNjApOyAvLyBtaW51dGVzXG4gICAgICAgIGlmICh2YWx1ZSA+PSA2MCkge1xuICAgICAgICAgICAgdmFsdWUgPSAodmFsdWUgLSBwYXJ0c1swXSkgLyBfNjA7XG4gICAgICAgICAgICBwYXJ0cy51bnNoaWZ0KHZhbHVlKTsgLy8gaG91cnNcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gKHNpZ24gK1xuICAgICAgICBwYXJ0c1xuICAgICAgICAgICAgLm1hcChuID0+IChuIDwgMTAgPyAnMCcgKyBTdHJpbmcobikgOiBTdHJpbmcobikpKVxuICAgICAgICAgICAgLmpvaW4oJzonKVxuICAgICAgICAgICAgLnJlcGxhY2UoLzAwMDAwMFxcZCokLywgJycpIC8vICUgNjAgbWF5IGludHJvZHVjZSBlcnJvclxuICAgICk7XG59XG5jb25zdCBpbnRUaW1lID0ge1xuICAgIGlkZW50aWZ5OiB2YWx1ZSA9PiB0eXBlb2YgdmFsdWUgPT09ICdiaWdpbnQnIHx8IE51bWJlci5pc0ludGVnZXIodmFsdWUpLFxuICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgdGFnOiAndGFnOnlhbWwub3JnLDIwMDI6aW50JyxcbiAgICBmb3JtYXQ6ICdUSU1FJyxcbiAgICB0ZXN0OiAvXlstK10/WzAtOV1bMC05X10qKD86OlswLTVdP1swLTldKSskLyxcbiAgICByZXNvbHZlOiAoc3RyLCBfb25FcnJvciwgeyBpbnRBc0JpZ0ludCB9KSA9PiBwYXJzZVNleGFnZXNpbWFsKHN0ciwgaW50QXNCaWdJbnQpLFxuICAgIHN0cmluZ2lmeTogc3RyaW5naWZ5U2V4YWdlc2ltYWxcbn07XG5jb25zdCBmbG9hdFRpbWUgPSB7XG4gICAgaWRlbnRpZnk6IHZhbHVlID0+IHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicsXG4gICAgZGVmYXVsdDogdHJ1ZSxcbiAgICB0YWc6ICd0YWc6eWFtbC5vcmcsMjAwMjpmbG9hdCcsXG4gICAgZm9ybWF0OiAnVElNRScsXG4gICAgdGVzdDogL15bLStdP1swLTldWzAtOV9dKig/OjpbMC01XT9bMC05XSkrXFwuWzAtOV9dKiQvLFxuICAgIHJlc29sdmU6IHN0ciA9PiBwYXJzZVNleGFnZXNpbWFsKHN0ciwgZmFsc2UpLFxuICAgIHN0cmluZ2lmeTogc3RyaW5naWZ5U2V4YWdlc2ltYWxcbn07XG5jb25zdCB0aW1lc3RhbXAgPSB7XG4gICAgaWRlbnRpZnk6IHZhbHVlID0+IHZhbHVlIGluc3RhbmNlb2YgRGF0ZSxcbiAgICBkZWZhdWx0OiB0cnVlLFxuICAgIHRhZzogJ3RhZzp5YW1sLm9yZywyMDAyOnRpbWVzdGFtcCcsXG4gICAgLy8gSWYgdGhlIHRpbWUgem9uZSBpcyBvbWl0dGVkLCB0aGUgdGltZXN0YW1wIGlzIGFzc3VtZWQgdG8gYmUgc3BlY2lmaWVkIGluIFVUQy4gVGhlIHRpbWUgcGFydFxuICAgIC8vIG1heSBiZSBvbWl0dGVkIGFsdG9nZXRoZXIsIHJlc3VsdGluZyBpbiBhIGRhdGUgZm9ybWF0LiBJbiBzdWNoIGEgY2FzZSwgdGhlIHRpbWUgcGFydCBpc1xuICAgIC8vIGFzc3VtZWQgdG8gYmUgMDA6MDA6MDBaIChzdGFydCBvZiBkYXksIFVUQykuXG4gICAgdGVzdDogUmVnRXhwKCdeKFswLTldezR9KS0oWzAtOV17MSwyfSktKFswLTldezEsMn0pJyArIC8vIFlZWVktTW0tRGRcbiAgICAgICAgJyg/OicgKyAvLyB0aW1lIGlzIG9wdGlvbmFsXG4gICAgICAgICcoPzp0fFR8WyBcXFxcdF0rKScgKyAvLyB0IHwgVCB8IHdoaXRlc3BhY2VcbiAgICAgICAgJyhbMC05XXsxLDJ9KTooWzAtOV17MSwyfSk6KFswLTldezEsMn0oXFxcXC5bMC05XSspPyknICsgLy8gSGg6TW06U3MoLnNzKT9cbiAgICAgICAgJyg/OlsgXFxcXHRdKihafFstK11bMDEyXT9bMC05XSg/OjpbMC05XXsyfSk/KSk/JyArIC8vIFogfCArNSB8IC0wMzozMFxuICAgICAgICAnKT8kJyksXG4gICAgcmVzb2x2ZShzdHIpIHtcbiAgICAgICAgY29uc3QgbWF0Y2ggPSBzdHIubWF0Y2godGltZXN0YW1wLnRlc3QpO1xuICAgICAgICBpZiAoIW1hdGNoKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCchIXRpbWVzdGFtcCBleHBlY3RzIGEgZGF0ZSwgc3RhcnRpbmcgd2l0aCB5eXl5LW1tLWRkJyk7XG4gICAgICAgIGNvbnN0IFssIHllYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbnV0ZSwgc2Vjb25kXSA9IG1hdGNoLm1hcChOdW1iZXIpO1xuICAgICAgICBjb25zdCBtaWxsaXNlYyA9IG1hdGNoWzddID8gTnVtYmVyKChtYXRjaFs3XSArICcwMCcpLnN1YnN0cigxLCAzKSkgOiAwO1xuICAgICAgICBsZXQgZGF0ZSA9IERhdGUuVVRDKHllYXIsIG1vbnRoIC0gMSwgZGF5LCBob3VyIHx8IDAsIG1pbnV0ZSB8fCAwLCBzZWNvbmQgfHwgMCwgbWlsbGlzZWMpO1xuICAgICAgICBjb25zdCB0eiA9IG1hdGNoWzhdO1xuICAgICAgICBpZiAodHogJiYgdHogIT09ICdaJykge1xuICAgICAgICAgICAgbGV0IGQgPSBwYXJzZVNleGFnZXNpbWFsKHR6LCBmYWxzZSk7XG4gICAgICAgICAgICBpZiAoTWF0aC5hYnMoZCkgPCAzMClcbiAgICAgICAgICAgICAgICBkICo9IDYwO1xuICAgICAgICAgICAgZGF0ZSAtPSA2MDAwMCAqIGQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKGRhdGUpO1xuICAgIH0sXG4gICAgc3RyaW5naWZ5OiAoeyB2YWx1ZSB9KSA9PiB2YWx1ZS50b0lTT1N0cmluZygpLnJlcGxhY2UoLygoVDAwOjAwKT86MDApP1xcLjAwMFokLywgJycpXG59O1xuXG5leHBvcnQgeyBmbG9hdFRpbWUsIGludFRpbWUsIHRpbWVzdGFtcCB9O1xuIiwgImltcG9ydCB7IG1hcCB9IGZyb20gJy4uL2NvbW1vbi9tYXAuanMnO1xuaW1wb3J0IHsgbnVsbFRhZyB9IGZyb20gJy4uL2NvbW1vbi9udWxsLmpzJztcbmltcG9ydCB7IHNlcSB9IGZyb20gJy4uL2NvbW1vbi9zZXEuanMnO1xuaW1wb3J0IHsgc3RyaW5nIH0gZnJvbSAnLi4vY29tbW9uL3N0cmluZy5qcyc7XG5pbXBvcnQgeyBiaW5hcnkgfSBmcm9tICcuL2JpbmFyeS5qcyc7XG5pbXBvcnQgeyB0cnVlVGFnLCBmYWxzZVRhZyB9IGZyb20gJy4vYm9vbC5qcyc7XG5pbXBvcnQgeyBmbG9hdE5hTiwgZmxvYXRFeHAsIGZsb2F0IH0gZnJvbSAnLi9mbG9hdC5qcyc7XG5pbXBvcnQgeyBpbnRCaW4sIGludE9jdCwgaW50LCBpbnRIZXggfSBmcm9tICcuL2ludC5qcyc7XG5pbXBvcnQgeyBvbWFwIH0gZnJvbSAnLi9vbWFwLmpzJztcbmltcG9ydCB7IHBhaXJzIH0gZnJvbSAnLi9wYWlycy5qcyc7XG5pbXBvcnQgeyBzZXQgfSBmcm9tICcuL3NldC5qcyc7XG5pbXBvcnQgeyBpbnRUaW1lLCBmbG9hdFRpbWUsIHRpbWVzdGFtcCB9IGZyb20gJy4vdGltZXN0YW1wLmpzJztcblxuY29uc3Qgc2NoZW1hID0gW1xuICAgIG1hcCxcbiAgICBzZXEsXG4gICAgc3RyaW5nLFxuICAgIG51bGxUYWcsXG4gICAgdHJ1ZVRhZyxcbiAgICBmYWxzZVRhZyxcbiAgICBpbnRCaW4sXG4gICAgaW50T2N0LFxuICAgIGludCxcbiAgICBpbnRIZXgsXG4gICAgZmxvYXROYU4sXG4gICAgZmxvYXRFeHAsXG4gICAgZmxvYXQsXG4gICAgYmluYXJ5LFxuICAgIG9tYXAsXG4gICAgcGFpcnMsXG4gICAgc2V0LFxuICAgIGludFRpbWUsXG4gICAgZmxvYXRUaW1lLFxuICAgIHRpbWVzdGFtcFxuXTtcblxuZXhwb3J0IHsgc2NoZW1hIH07XG4iLCAiaW1wb3J0IHsgbWFwIH0gZnJvbSAnLi9jb21tb24vbWFwLmpzJztcbmltcG9ydCB7IG51bGxUYWcgfSBmcm9tICcuL2NvbW1vbi9udWxsLmpzJztcbmltcG9ydCB7IHNlcSB9IGZyb20gJy4vY29tbW9uL3NlcS5qcyc7XG5pbXBvcnQgeyBzdHJpbmcgfSBmcm9tICcuL2NvbW1vbi9zdHJpbmcuanMnO1xuaW1wb3J0IHsgYm9vbFRhZyB9IGZyb20gJy4vY29yZS9ib29sLmpzJztcbmltcG9ydCB7IGZsb2F0LCBmbG9hdEV4cCwgZmxvYXROYU4gfSBmcm9tICcuL2NvcmUvZmxvYXQuanMnO1xuaW1wb3J0IHsgaW50LCBpbnRIZXgsIGludE9jdCB9IGZyb20gJy4vY29yZS9pbnQuanMnO1xuaW1wb3J0IHsgc2NoZW1hIH0gZnJvbSAnLi9jb3JlL3NjaGVtYS5qcyc7XG5pbXBvcnQgeyBzY2hlbWEgYXMgc2NoZW1hJDEgfSBmcm9tICcuL2pzb24vc2NoZW1hLmpzJztcbmltcG9ydCB7IGJpbmFyeSB9IGZyb20gJy4veWFtbC0xLjEvYmluYXJ5LmpzJztcbmltcG9ydCB7IG9tYXAgfSBmcm9tICcuL3lhbWwtMS4xL29tYXAuanMnO1xuaW1wb3J0IHsgcGFpcnMgfSBmcm9tICcuL3lhbWwtMS4xL3BhaXJzLmpzJztcbmltcG9ydCB7IHNjaGVtYSBhcyBzY2hlbWEkMiB9IGZyb20gJy4veWFtbC0xLjEvc2NoZW1hLmpzJztcbmltcG9ydCB7IHNldCB9IGZyb20gJy4veWFtbC0xLjEvc2V0LmpzJztcbmltcG9ydCB7IGZsb2F0VGltZSwgaW50VGltZSwgdGltZXN0YW1wIH0gZnJvbSAnLi95YW1sLTEuMS90aW1lc3RhbXAuanMnO1xuXG5jb25zdCBzY2hlbWFzID0gbmV3IE1hcChbXG4gICAgWydjb3JlJywgc2NoZW1hXSxcbiAgICBbJ2ZhaWxzYWZlJywgW21hcCwgc2VxLCBzdHJpbmddXSxcbiAgICBbJ2pzb24nLCBzY2hlbWEkMV0sXG4gICAgWyd5YW1sMTEnLCBzY2hlbWEkMl0sXG4gICAgWyd5YW1sLTEuMScsIHNjaGVtYSQyXVxuXSk7XG5jb25zdCB0YWdzQnlOYW1lID0ge1xuICAgIGJpbmFyeSxcbiAgICBib29sOiBib29sVGFnLFxuICAgIGZsb2F0LFxuICAgIGZsb2F0RXhwLFxuICAgIGZsb2F0TmFOLFxuICAgIGZsb2F0VGltZSxcbiAgICBpbnQsXG4gICAgaW50SGV4LFxuICAgIGludE9jdCxcbiAgICBpbnRUaW1lLFxuICAgIG1hcCxcbiAgICBudWxsOiBudWxsVGFnLFxuICAgIG9tYXAsXG4gICAgcGFpcnMsXG4gICAgc2VxLFxuICAgIHNldCxcbiAgICB0aW1lc3RhbXBcbn07XG5jb25zdCBjb3JlS25vd25UYWdzID0ge1xuICAgICd0YWc6eWFtbC5vcmcsMjAwMjpiaW5hcnknOiBiaW5hcnksXG4gICAgJ3RhZzp5YW1sLm9yZywyMDAyOm9tYXAnOiBvbWFwLFxuICAgICd0YWc6eWFtbC5vcmcsMjAwMjpwYWlycyc6IHBhaXJzLFxuICAgICd0YWc6eWFtbC5vcmcsMjAwMjpzZXQnOiBzZXQsXG4gICAgJ3RhZzp5YW1sLm9yZywyMDAyOnRpbWVzdGFtcCc6IHRpbWVzdGFtcFxufTtcbmZ1bmN0aW9uIGdldFRhZ3MoY3VzdG9tVGFncywgc2NoZW1hTmFtZSkge1xuICAgIGxldCB0YWdzID0gc2NoZW1hcy5nZXQoc2NoZW1hTmFtZSk7XG4gICAgaWYgKCF0YWdzKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGN1c3RvbVRhZ3MpKVxuICAgICAgICAgICAgdGFncyA9IFtdO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGtleXMgPSBBcnJheS5mcm9tKHNjaGVtYXMua2V5cygpKVxuICAgICAgICAgICAgICAgIC5maWx0ZXIoa2V5ID0+IGtleSAhPT0gJ3lhbWwxMScpXG4gICAgICAgICAgICAgICAgLm1hcChrZXkgPT4gSlNPTi5zdHJpbmdpZnkoa2V5KSlcbiAgICAgICAgICAgICAgICAuam9pbignLCAnKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBzY2hlbWEgXCIke3NjaGVtYU5hbWV9XCI7IHVzZSBvbmUgb2YgJHtrZXlzfSBvciBkZWZpbmUgY3VzdG9tVGFncyBhcnJheWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KGN1c3RvbVRhZ3MpKSB7XG4gICAgICAgIGZvciAoY29uc3QgdGFnIG9mIGN1c3RvbVRhZ3MpXG4gICAgICAgICAgICB0YWdzID0gdGFncy5jb25jYXQodGFnKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGN1c3RvbVRhZ3MgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGFncyA9IGN1c3RvbVRhZ3ModGFncy5zbGljZSgpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRhZ3MubWFwKHRhZyA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgdGFnICE9PSAnc3RyaW5nJylcbiAgICAgICAgICAgIHJldHVybiB0YWc7XG4gICAgICAgIGNvbnN0IHRhZ09iaiA9IHRhZ3NCeU5hbWVbdGFnXTtcbiAgICAgICAgaWYgKHRhZ09iailcbiAgICAgICAgICAgIHJldHVybiB0YWdPYmo7XG4gICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyh0YWdzQnlOYW1lKVxuICAgICAgICAgICAgLm1hcChrZXkgPT4gSlNPTi5zdHJpbmdpZnkoa2V5KSlcbiAgICAgICAgICAgIC5qb2luKCcsICcpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gY3VzdG9tIHRhZyBcIiR7dGFnfVwiOyB1c2Ugb25lIG9mICR7a2V5c31gKTtcbiAgICB9KTtcbn1cblxuZXhwb3J0IHsgY29yZUtub3duVGFncywgZ2V0VGFncyB9O1xuIiwgImltcG9ydCB7IE1BUCwgU0NBTEFSLCBTRVEgfSBmcm9tICcuLi9ub2Rlcy9Ob2RlLmpzJztcbmltcG9ydCB7IG1hcCB9IGZyb20gJy4vY29tbW9uL21hcC5qcyc7XG5pbXBvcnQgeyBzZXEgfSBmcm9tICcuL2NvbW1vbi9zZXEuanMnO1xuaW1wb3J0IHsgc3RyaW5nIH0gZnJvbSAnLi9jb21tb24vc3RyaW5nLmpzJztcbmltcG9ydCB7IGdldFRhZ3MsIGNvcmVLbm93blRhZ3MgfSBmcm9tICcuL3RhZ3MuanMnO1xuXG5jb25zdCBzb3J0TWFwRW50cmllc0J5S2V5ID0gKGEsIGIpID0+IGEua2V5IDwgYi5rZXkgPyAtMSA6IGEua2V5ID4gYi5rZXkgPyAxIDogMDtcbmNsYXNzIFNjaGVtYSB7XG4gICAgY29uc3RydWN0b3IoeyBjb21wYXQsIGN1c3RvbVRhZ3MsIG1lcmdlLCByZXNvbHZlS25vd25UYWdzLCBzY2hlbWEsIHNvcnRNYXBFbnRyaWVzLCB0b1N0cmluZ0RlZmF1bHRzIH0pIHtcbiAgICAgICAgdGhpcy5jb21wYXQgPSBBcnJheS5pc0FycmF5KGNvbXBhdClcbiAgICAgICAgICAgID8gZ2V0VGFncyhjb21wYXQsICdjb21wYXQnKVxuICAgICAgICAgICAgOiBjb21wYXRcbiAgICAgICAgICAgICAgICA/IGdldFRhZ3MobnVsbCwgY29tcGF0KVxuICAgICAgICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgdGhpcy5tZXJnZSA9ICEhbWVyZ2U7XG4gICAgICAgIHRoaXMubmFtZSA9ICh0eXBlb2Ygc2NoZW1hID09PSAnc3RyaW5nJyAmJiBzY2hlbWEpIHx8ICdjb3JlJztcbiAgICAgICAgdGhpcy5rbm93blRhZ3MgPSByZXNvbHZlS25vd25UYWdzID8gY29yZUtub3duVGFncyA6IHt9O1xuICAgICAgICB0aGlzLnRhZ3MgPSBnZXRUYWdzKGN1c3RvbVRhZ3MsIHRoaXMubmFtZSk7XG4gICAgICAgIHRoaXMudG9TdHJpbmdPcHRpb25zID0gdG9TdHJpbmdEZWZhdWx0cyB8fCBudWxsO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgTUFQLCB7IHZhbHVlOiBtYXAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBTQ0FMQVIsIHsgdmFsdWU6IHN0cmluZyB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFNFUSwgeyB2YWx1ZTogc2VxIH0pO1xuICAgICAgICAvLyBVc2VkIGJ5IGNyZWF0ZU1hcCgpXG4gICAgICAgIHRoaXMuc29ydE1hcEVudHJpZXMgPVxuICAgICAgICAgICAgc29ydE1hcEVudHJpZXMgPT09IHRydWUgPyBzb3J0TWFwRW50cmllc0J5S2V5IDogc29ydE1hcEVudHJpZXMgfHwgbnVsbDtcbiAgICB9XG4gICAgY2xvbmUoKSB7XG4gICAgICAgIGNvbnN0IGNvcHkgPSBPYmplY3QuY3JlYXRlKFNjaGVtYS5wcm90b3R5cGUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHRoaXMpKTtcbiAgICAgICAgY29weS50YWdzID0gdGhpcy50YWdzLnNsaWNlKCk7XG4gICAgICAgIHJldHVybiBjb3B5O1xuICAgIH1cbn1cblxuZXhwb3J0IHsgU2NoZW1hIH07XG4iLCAiaW1wb3J0IHsgaXNOb2RlIH0gZnJvbSAnLi4vbm9kZXMvTm9kZS5qcyc7XG5pbXBvcnQgeyBjcmVhdGVTdHJpbmdpZnlDb250ZXh0LCBzdHJpbmdpZnkgfSBmcm9tICcuL3N0cmluZ2lmeS5qcyc7XG5pbXBvcnQgeyBpbmRlbnRDb21tZW50LCBsaW5lQ29tbWVudCB9IGZyb20gJy4vc3RyaW5naWZ5Q29tbWVudC5qcyc7XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeURvY3VtZW50KGRvYywgb3B0aW9ucykge1xuICAgIGNvbnN0IGxpbmVzID0gW107XG4gICAgbGV0IGhhc0RpcmVjdGl2ZXMgPSBvcHRpb25zLmRpcmVjdGl2ZXMgPT09IHRydWU7XG4gICAgaWYgKG9wdGlvbnMuZGlyZWN0aXZlcyAhPT0gZmFsc2UgJiYgZG9jLmRpcmVjdGl2ZXMpIHtcbiAgICAgICAgY29uc3QgZGlyID0gZG9jLmRpcmVjdGl2ZXMudG9TdHJpbmcoZG9jKTtcbiAgICAgICAgaWYgKGRpcikge1xuICAgICAgICAgICAgbGluZXMucHVzaChkaXIpO1xuICAgICAgICAgICAgaGFzRGlyZWN0aXZlcyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZG9jLmRpcmVjdGl2ZXMubWFya2VyKVxuICAgICAgICAgICAgaGFzRGlyZWN0aXZlcyA9IHRydWU7XG4gICAgfVxuICAgIGlmIChoYXNEaXJlY3RpdmVzKVxuICAgICAgICBsaW5lcy5wdXNoKCctLS0nKTtcbiAgICBjb25zdCBjdHggPSBjcmVhdGVTdHJpbmdpZnlDb250ZXh0KGRvYywgb3B0aW9ucyk7XG4gICAgY29uc3QgeyBjb21tZW50U3RyaW5nIH0gPSBjdHgub3B0aW9ucztcbiAgICBpZiAoZG9jLmNvbW1lbnRCZWZvcmUpIHtcbiAgICAgICAgaWYgKGxpbmVzLmxlbmd0aCAhPT0gMSlcbiAgICAgICAgICAgIGxpbmVzLnVuc2hpZnQoJycpO1xuICAgICAgICBjb25zdCBjcyA9IGNvbW1lbnRTdHJpbmcoZG9jLmNvbW1lbnRCZWZvcmUpO1xuICAgICAgICBsaW5lcy51bnNoaWZ0KGluZGVudENvbW1lbnQoY3MsICcnKSk7XG4gICAgfVxuICAgIGxldCBjaG9tcEtlZXAgPSBmYWxzZTtcbiAgICBsZXQgY29udGVudENvbW1lbnQgPSBudWxsO1xuICAgIGlmIChkb2MuY29udGVudHMpIHtcbiAgICAgICAgaWYgKGlzTm9kZShkb2MuY29udGVudHMpKSB7XG4gICAgICAgICAgICBpZiAoZG9jLmNvbnRlbnRzLnNwYWNlQmVmb3JlICYmIGhhc0RpcmVjdGl2ZXMpXG4gICAgICAgICAgICAgICAgbGluZXMucHVzaCgnJyk7XG4gICAgICAgICAgICBpZiAoZG9jLmNvbnRlbnRzLmNvbW1lbnRCZWZvcmUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjcyA9IGNvbW1lbnRTdHJpbmcoZG9jLmNvbnRlbnRzLmNvbW1lbnRCZWZvcmUpO1xuICAgICAgICAgICAgICAgIGxpbmVzLnB1c2goaW5kZW50Q29tbWVudChjcywgJycpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHRvcC1sZXZlbCBibG9jayBzY2FsYXJzIG5lZWQgdG8gYmUgaW5kZW50ZWQgaWYgZm9sbG93ZWQgYnkgYSBjb21tZW50XG4gICAgICAgICAgICBjdHguZm9yY2VCbG9ja0luZGVudCA9ICEhZG9jLmNvbW1lbnQ7XG4gICAgICAgICAgICBjb250ZW50Q29tbWVudCA9IGRvYy5jb250ZW50cy5jb21tZW50O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9uQ2hvbXBLZWVwID0gY29udGVudENvbW1lbnQgPyB1bmRlZmluZWQgOiAoKSA9PiAoY2hvbXBLZWVwID0gdHJ1ZSk7XG4gICAgICAgIGxldCBib2R5ID0gc3RyaW5naWZ5KGRvYy5jb250ZW50cywgY3R4LCAoKSA9PiAoY29udGVudENvbW1lbnQgPSBudWxsKSwgb25DaG9tcEtlZXApO1xuICAgICAgICBpZiAoY29udGVudENvbW1lbnQpXG4gICAgICAgICAgICBib2R5ICs9IGxpbmVDb21tZW50KGJvZHksICcnLCBjb21tZW50U3RyaW5nKGNvbnRlbnRDb21tZW50KSk7XG4gICAgICAgIGlmICgoYm9keVswXSA9PT0gJ3wnIHx8IGJvZHlbMF0gPT09ICc+JykgJiZcbiAgICAgICAgICAgIGxpbmVzW2xpbmVzLmxlbmd0aCAtIDFdID09PSAnLS0tJykge1xuICAgICAgICAgICAgLy8gVG9wLWxldmVsIGJsb2NrIHNjYWxhcnMgd2l0aCBhIHByZWNlZGluZyBkb2MgbWFya2VyIG91Z2h0IHRvIHVzZSB0aGVcbiAgICAgICAgICAgIC8vIHNhbWUgbGluZSBmb3IgdGhlaXIgaGVhZGVyLlxuICAgICAgICAgICAgbGluZXNbbGluZXMubGVuZ3RoIC0gMV0gPSBgLS0tICR7Ym9keX1gO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGxpbmVzLnB1c2goYm9keSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBsaW5lcy5wdXNoKHN0cmluZ2lmeShkb2MuY29udGVudHMsIGN0eCkpO1xuICAgIH1cbiAgICBsZXQgZGMgPSBkb2MuY29tbWVudDtcbiAgICBpZiAoZGMgJiYgY2hvbXBLZWVwKVxuICAgICAgICBkYyA9IGRjLnJlcGxhY2UoL15cXG4rLywgJycpO1xuICAgIGlmIChkYykge1xuICAgICAgICBpZiAoKCFjaG9tcEtlZXAgfHwgY29udGVudENvbW1lbnQpICYmIGxpbmVzW2xpbmVzLmxlbmd0aCAtIDFdICE9PSAnJylcbiAgICAgICAgICAgIGxpbmVzLnB1c2goJycpO1xuICAgICAgICBsaW5lcy5wdXNoKGluZGVudENvbW1lbnQoY29tbWVudFN0cmluZyhkYyksICcnKSk7XG4gICAgfVxuICAgIHJldHVybiBsaW5lcy5qb2luKCdcXG4nKSArICdcXG4nO1xufVxuXG5leHBvcnQgeyBzdHJpbmdpZnlEb2N1bWVudCB9O1xuIiwgIi8qKlxuICogQXBwbGllcyB0aGUgSlNPTi5wYXJzZSByZXZpdmVyIGFsZ29yaXRobSBhcyBkZWZpbmVkIGluIHRoZSBFQ01BLTI2MiBzcGVjLFxuICogaW4gc2VjdGlvbiAyNC41LjEuMSBcIlJ1bnRpbWUgU2VtYW50aWNzOiBJbnRlcm5hbGl6ZUpTT05Qcm9wZXJ0eVwiIG9mIHRoZVxuICogMjAyMSBlZGl0aW9uOiBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWpzb24ucGFyc2VcbiAqXG4gKiBJbmNsdWRlcyBleHRlbnNpb25zIGZvciBoYW5kbGluZyBNYXAgYW5kIFNldCBvYmplY3RzLlxuICovXG5mdW5jdGlvbiBhcHBseVJldml2ZXIocmV2aXZlciwgb2JqLCBrZXksIHZhbCkge1xuICAgIGlmICh2YWwgJiYgdHlwZW9mIHZhbCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHZhbC5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHYwID0gdmFsW2ldO1xuICAgICAgICAgICAgICAgIGNvbnN0IHYxID0gYXBwbHlSZXZpdmVyKHJldml2ZXIsIHZhbCwgU3RyaW5nKGkpLCB2MCk7XG4gICAgICAgICAgICAgICAgaWYgKHYxID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB2YWxbaV07XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodjEgIT09IHYwKVxuICAgICAgICAgICAgICAgICAgICB2YWxbaV0gPSB2MTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2YWwgaW5zdGFuY2VvZiBNYXApIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgayBvZiBBcnJheS5mcm9tKHZhbC5rZXlzKCkpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdjAgPSB2YWwuZ2V0KGspO1xuICAgICAgICAgICAgICAgIGNvbnN0IHYxID0gYXBwbHlSZXZpdmVyKHJldml2ZXIsIHZhbCwgaywgdjApO1xuICAgICAgICAgICAgICAgIGlmICh2MSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgICAgICB2YWwuZGVsZXRlKGspO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHYxICE9PSB2MClcbiAgICAgICAgICAgICAgICAgICAgdmFsLnNldChrLCB2MSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmFsIGluc3RhbmNlb2YgU2V0KSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHYwIG9mIEFycmF5LmZyb20odmFsKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHYxID0gYXBwbHlSZXZpdmVyKHJldml2ZXIsIHZhbCwgdjAsIHYwKTtcbiAgICAgICAgICAgICAgICBpZiAodjEgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICAgICAgdmFsLmRlbGV0ZSh2MCk7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodjEgIT09IHYwKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbC5kZWxldGUodjApO1xuICAgICAgICAgICAgICAgICAgICB2YWwuYWRkKHYxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtrLCB2MF0gb2YgT2JqZWN0LmVudHJpZXModmFsKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHYxID0gYXBwbHlSZXZpdmVyKHJldml2ZXIsIHZhbCwgaywgdjApO1xuICAgICAgICAgICAgICAgIGlmICh2MSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdmFsW2tdO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHYxICE9PSB2MClcbiAgICAgICAgICAgICAgICAgICAgdmFsW2tdID0gdjE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJldml2ZXIuY2FsbChvYmosIGtleSwgdmFsKTtcbn1cblxuZXhwb3J0IHsgYXBwbHlSZXZpdmVyIH07XG4iLCAiaW1wb3J0IHsgQWxpYXMgfSBmcm9tICcuLi9ub2Rlcy9BbGlhcy5qcyc7XG5pbXBvcnQgeyBpc0VtcHR5UGF0aCwgY29sbGVjdGlvbkZyb21QYXRoIH0gZnJvbSAnLi4vbm9kZXMvQ29sbGVjdGlvbi5qcyc7XG5pbXBvcnQgeyBOT0RFX1RZUEUsIERPQywgaXNOb2RlLCBpc0NvbGxlY3Rpb24sIGlzU2NhbGFyIH0gZnJvbSAnLi4vbm9kZXMvTm9kZS5qcyc7XG5pbXBvcnQgeyBQYWlyIH0gZnJvbSAnLi4vbm9kZXMvUGFpci5qcyc7XG5pbXBvcnQgeyB0b0pTIH0gZnJvbSAnLi4vbm9kZXMvdG9KUy5qcyc7XG5pbXBvcnQgeyBkZWZhdWx0T3B0aW9ucyB9IGZyb20gJy4uL29wdGlvbnMuanMnO1xuaW1wb3J0IHsgU2NoZW1hIH0gZnJvbSAnLi4vc2NoZW1hL1NjaGVtYS5qcyc7XG5pbXBvcnQgeyBzdHJpbmdpZnkgfSBmcm9tICcuLi9zdHJpbmdpZnkvc3RyaW5naWZ5LmpzJztcbmltcG9ydCB7IHN0cmluZ2lmeURvY3VtZW50IH0gZnJvbSAnLi4vc3RyaW5naWZ5L3N0cmluZ2lmeURvY3VtZW50LmpzJztcbmltcG9ydCB7IGFuY2hvck5hbWVzLCBmaW5kTmV3QW5jaG9yLCBjcmVhdGVOb2RlQW5jaG9ycyB9IGZyb20gJy4vYW5jaG9ycy5qcyc7XG5pbXBvcnQgeyBhcHBseVJldml2ZXIgfSBmcm9tICcuL2FwcGx5UmV2aXZlci5qcyc7XG5pbXBvcnQgeyBjcmVhdGVOb2RlIH0gZnJvbSAnLi9jcmVhdGVOb2RlLmpzJztcbmltcG9ydCB7IERpcmVjdGl2ZXMgfSBmcm9tICcuL2RpcmVjdGl2ZXMuanMnO1xuXG5jbGFzcyBEb2N1bWVudCB7XG4gICAgY29uc3RydWN0b3IodmFsdWUsIHJlcGxhY2VyLCBvcHRpb25zKSB7XG4gICAgICAgIC8qKiBBIGNvbW1lbnQgYmVmb3JlIHRoaXMgRG9jdW1lbnQgKi9cbiAgICAgICAgdGhpcy5jb21tZW50QmVmb3JlID0gbnVsbDtcbiAgICAgICAgLyoqIEEgY29tbWVudCBpbW1lZGlhdGVseSBhZnRlciB0aGlzIERvY3VtZW50ICovXG4gICAgICAgIHRoaXMuY29tbWVudCA9IG51bGw7XG4gICAgICAgIC8qKiBFcnJvcnMgZW5jb3VudGVyZWQgZHVyaW5nIHBhcnNpbmcuICovXG4gICAgICAgIHRoaXMuZXJyb3JzID0gW107XG4gICAgICAgIC8qKiBXYXJuaW5ncyBlbmNvdW50ZXJlZCBkdXJpbmcgcGFyc2luZy4gKi9cbiAgICAgICAgdGhpcy53YXJuaW5ncyA9IFtdO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgTk9ERV9UWVBFLCB7IHZhbHVlOiBET0MgfSk7XG4gICAgICAgIGxldCBfcmVwbGFjZXIgPSBudWxsO1xuICAgICAgICBpZiAodHlwZW9mIHJlcGxhY2VyID09PSAnZnVuY3Rpb24nIHx8IEFycmF5LmlzQXJyYXkocmVwbGFjZXIpKSB7XG4gICAgICAgICAgICBfcmVwbGFjZXIgPSByZXBsYWNlcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvcHRpb25zID09PSB1bmRlZmluZWQgJiYgcmVwbGFjZXIpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSByZXBsYWNlcjtcbiAgICAgICAgICAgIHJlcGxhY2VyID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9wdCA9IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRPcHRpb25zLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0O1xuICAgICAgICBsZXQgeyB2ZXJzaW9uIH0gPSBvcHQ7XG4gICAgICAgIGlmIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZGlyZWN0aXZlcykge1xuICAgICAgICAgICAgdGhpcy5kaXJlY3RpdmVzID0gb3B0aW9ucy5kaXJlY3RpdmVzLmF0RG9jdW1lbnQoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmRpcmVjdGl2ZXMueWFtbC5leHBsaWNpdClcbiAgICAgICAgICAgICAgICB2ZXJzaW9uID0gdGhpcy5kaXJlY3RpdmVzLnlhbWwudmVyc2lvbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLmRpcmVjdGl2ZXMgPSBuZXcgRGlyZWN0aXZlcyh7IHZlcnNpb24gfSk7XG4gICAgICAgIHRoaXMuc2V0U2NoZW1hKHZlcnNpb24sIG9wdGlvbnMpO1xuICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHRoaXMuY29udGVudHMgPSBudWxsO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY29udGVudHMgPSB0aGlzLmNyZWF0ZU5vZGUodmFsdWUsIF9yZXBsYWNlciwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgZGVlcCBjb3B5IG9mIHRoaXMgRG9jdW1lbnQgYW5kIGl0cyBjb250ZW50cy5cbiAgICAgKlxuICAgICAqIEN1c3RvbSBOb2RlIHZhbHVlcyB0aGF0IGluaGVyaXQgZnJvbSBgT2JqZWN0YCBzdGlsbCByZWZlciB0byB0aGVpciBvcmlnaW5hbCBpbnN0YW5jZXMuXG4gICAgICovXG4gICAgY2xvbmUoKSB7XG4gICAgICAgIGNvbnN0IGNvcHkgPSBPYmplY3QuY3JlYXRlKERvY3VtZW50LnByb3RvdHlwZSwge1xuICAgICAgICAgICAgW05PREVfVFlQRV06IHsgdmFsdWU6IERPQyB9XG4gICAgICAgIH0pO1xuICAgICAgICBjb3B5LmNvbW1lbnRCZWZvcmUgPSB0aGlzLmNvbW1lbnRCZWZvcmU7XG4gICAgICAgIGNvcHkuY29tbWVudCA9IHRoaXMuY29tbWVudDtcbiAgICAgICAgY29weS5lcnJvcnMgPSB0aGlzLmVycm9ycy5zbGljZSgpO1xuICAgICAgICBjb3B5Lndhcm5pbmdzID0gdGhpcy53YXJuaW5ncy5zbGljZSgpO1xuICAgICAgICBjb3B5Lm9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLm9wdGlvbnMpO1xuICAgICAgICBpZiAodGhpcy5kaXJlY3RpdmVzKVxuICAgICAgICAgICAgY29weS5kaXJlY3RpdmVzID0gdGhpcy5kaXJlY3RpdmVzLmNsb25lKCk7XG4gICAgICAgIGNvcHkuc2NoZW1hID0gdGhpcy5zY2hlbWEuY2xvbmUoKTtcbiAgICAgICAgY29weS5jb250ZW50cyA9IGlzTm9kZSh0aGlzLmNvbnRlbnRzKVxuICAgICAgICAgICAgPyB0aGlzLmNvbnRlbnRzLmNsb25lKGNvcHkuc2NoZW1hKVxuICAgICAgICAgICAgOiB0aGlzLmNvbnRlbnRzO1xuICAgICAgICBpZiAodGhpcy5yYW5nZSlcbiAgICAgICAgICAgIGNvcHkucmFuZ2UgPSB0aGlzLnJhbmdlLnNsaWNlKCk7XG4gICAgICAgIHJldHVybiBjb3B5O1xuICAgIH1cbiAgICAvKiogQWRkcyBhIHZhbHVlIHRvIHRoZSBkb2N1bWVudC4gKi9cbiAgICBhZGQodmFsdWUpIHtcbiAgICAgICAgaWYgKGFzc2VydENvbGxlY3Rpb24odGhpcy5jb250ZW50cykpXG4gICAgICAgICAgICB0aGlzLmNvbnRlbnRzLmFkZCh2YWx1ZSk7XG4gICAgfVxuICAgIC8qKiBBZGRzIGEgdmFsdWUgdG8gdGhlIGRvY3VtZW50LiAqL1xuICAgIGFkZEluKHBhdGgsIHZhbHVlKSB7XG4gICAgICAgIGlmIChhc3NlcnRDb2xsZWN0aW9uKHRoaXMuY29udGVudHMpKVxuICAgICAgICAgICAgdGhpcy5jb250ZW50cy5hZGRJbihwYXRoLCB2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBgQWxpYXNgIG5vZGUsIGVuc3VyaW5nIHRoYXQgdGhlIHRhcmdldCBgbm9kZWAgaGFzIHRoZSByZXF1aXJlZCBhbmNob3IuXG4gICAgICpcbiAgICAgKiBJZiBgbm9kZWAgYWxyZWFkeSBoYXMgYW4gYW5jaG9yLCBgbmFtZWAgaXMgaWdub3JlZC5cbiAgICAgKiBPdGhlcndpc2UsIHRoZSBgbm9kZS5hbmNob3JgIHZhbHVlIHdpbGwgYmUgc2V0IHRvIGBuYW1lYCxcbiAgICAgKiBvciBpZiBhbiBhbmNob3Igd2l0aCB0aGF0IG5hbWUgaXMgYWxyZWFkeSBwcmVzZW50IGluIHRoZSBkb2N1bWVudCxcbiAgICAgKiBgbmFtZWAgd2lsbCBiZSB1c2VkIGFzIGEgcHJlZml4IGZvciBhIG5ldyB1bmlxdWUgYW5jaG9yLlxuICAgICAqIElmIGBuYW1lYCBpcyB1bmRlZmluZWQsIHRoZSBnZW5lcmF0ZWQgYW5jaG9yIHdpbGwgdXNlICdhJyBhcyBhIHByZWZpeC5cbiAgICAgKi9cbiAgICBjcmVhdGVBbGlhcyhub2RlLCBuYW1lKSB7XG4gICAgICAgIGlmICghbm9kZS5hbmNob3IpIHtcbiAgICAgICAgICAgIGNvbnN0IHByZXYgPSBhbmNob3JOYW1lcyh0aGlzKTtcbiAgICAgICAgICAgIG5vZGUuYW5jaG9yID1cbiAgICAgICAgICAgICAgICAhbmFtZSB8fCBwcmV2LmhhcyhuYW1lKSA/IGZpbmROZXdBbmNob3IobmFtZSB8fCAnYScsIHByZXYpIDogbmFtZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEFsaWFzKG5vZGUuYW5jaG9yKTtcbiAgICB9XG4gICAgY3JlYXRlTm9kZSh2YWx1ZSwgcmVwbGFjZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgbGV0IF9yZXBsYWNlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHR5cGVvZiByZXBsYWNlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdmFsdWUgPSByZXBsYWNlci5jYWxsKHsgJyc6IHZhbHVlIH0sICcnLCB2YWx1ZSk7XG4gICAgICAgICAgICBfcmVwbGFjZXIgPSByZXBsYWNlcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHJlcGxhY2VyKSkge1xuICAgICAgICAgICAgY29uc3Qga2V5VG9TdHIgPSAodikgPT4gdHlwZW9mIHYgPT09ICdudW1iZXInIHx8IHYgaW5zdGFuY2VvZiBTdHJpbmcgfHwgdiBpbnN0YW5jZW9mIE51bWJlcjtcbiAgICAgICAgICAgIGNvbnN0IGFzU3RyID0gcmVwbGFjZXIuZmlsdGVyKGtleVRvU3RyKS5tYXAoU3RyaW5nKTtcbiAgICAgICAgICAgIGlmIChhc1N0ci5sZW5ndGggPiAwKVxuICAgICAgICAgICAgICAgIHJlcGxhY2VyID0gcmVwbGFjZXIuY29uY2F0KGFzU3RyKTtcbiAgICAgICAgICAgIF9yZXBsYWNlciA9IHJlcGxhY2VyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9wdGlvbnMgPT09IHVuZGVmaW5lZCAmJiByZXBsYWNlcikge1xuICAgICAgICAgICAgb3B0aW9ucyA9IHJlcGxhY2VyO1xuICAgICAgICAgICAgcmVwbGFjZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBhbGlhc0R1cGxpY2F0ZU9iamVjdHMsIGFuY2hvclByZWZpeCwgZmxvdywga2VlcFVuZGVmaW5lZCwgb25UYWdPYmosIHRhZyB9ID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgY29uc3QgeyBvbkFuY2hvciwgc2V0QW5jaG9ycywgc291cmNlT2JqZWN0cyB9ID0gY3JlYXRlTm9kZUFuY2hvcnModGhpcywgYW5jaG9yUHJlZml4IHx8ICdhJyk7XG4gICAgICAgIGNvbnN0IGN0eCA9IHtcbiAgICAgICAgICAgIGFsaWFzRHVwbGljYXRlT2JqZWN0czogYWxpYXNEdXBsaWNhdGVPYmplY3RzICE9PSBudWxsICYmIGFsaWFzRHVwbGljYXRlT2JqZWN0cyAhPT0gdm9pZCAwID8gYWxpYXNEdXBsaWNhdGVPYmplY3RzIDogdHJ1ZSxcbiAgICAgICAgICAgIGtlZXBVbmRlZmluZWQ6IGtlZXBVbmRlZmluZWQgIT09IG51bGwgJiYga2VlcFVuZGVmaW5lZCAhPT0gdm9pZCAwID8ga2VlcFVuZGVmaW5lZCA6IGZhbHNlLFxuICAgICAgICAgICAgb25BbmNob3IsXG4gICAgICAgICAgICBvblRhZ09iaixcbiAgICAgICAgICAgIHJlcGxhY2VyOiBfcmVwbGFjZXIsXG4gICAgICAgICAgICBzY2hlbWE6IHRoaXMuc2NoZW1hLFxuICAgICAgICAgICAgc291cmNlT2JqZWN0c1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBub2RlID0gY3JlYXRlTm9kZSh2YWx1ZSwgdGFnLCBjdHgpO1xuICAgICAgICBpZiAoZmxvdyAmJiBpc0NvbGxlY3Rpb24obm9kZSkpXG4gICAgICAgICAgICBub2RlLmZsb3cgPSB0cnVlO1xuICAgICAgICBzZXRBbmNob3JzKCk7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IGEga2V5IGFuZCBhIHZhbHVlIGludG8gYSBgUGFpcmAgdXNpbmcgdGhlIGN1cnJlbnQgc2NoZW1hLFxuICAgICAqIHJlY3Vyc2l2ZWx5IHdyYXBwaW5nIGFsbCB2YWx1ZXMgYXMgYFNjYWxhcmAgb3IgYENvbGxlY3Rpb25gIG5vZGVzLlxuICAgICAqL1xuICAgIGNyZWF0ZVBhaXIoa2V5LCB2YWx1ZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IGsgPSB0aGlzLmNyZWF0ZU5vZGUoa2V5LCBudWxsLCBvcHRpb25zKTtcbiAgICAgICAgY29uc3QgdiA9IHRoaXMuY3JlYXRlTm9kZSh2YWx1ZSwgbnVsbCwgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBuZXcgUGFpcihrLCB2KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhIHZhbHVlIGZyb20gdGhlIGRvY3VtZW50LlxuICAgICAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgaXRlbSB3YXMgZm91bmQgYW5kIHJlbW92ZWQuXG4gICAgICovXG4gICAgZGVsZXRlKGtleSkge1xuICAgICAgICByZXR1cm4gYXNzZXJ0Q29sbGVjdGlvbih0aGlzLmNvbnRlbnRzKSA/IHRoaXMuY29udGVudHMuZGVsZXRlKGtleSkgOiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhIHZhbHVlIGZyb20gdGhlIGRvY3VtZW50LlxuICAgICAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgaXRlbSB3YXMgZm91bmQgYW5kIHJlbW92ZWQuXG4gICAgICovXG4gICAgZGVsZXRlSW4ocGF0aCkge1xuICAgICAgICBpZiAoaXNFbXB0eVBhdGgocGF0aCkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbnRlbnRzID09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5jb250ZW50cyA9IG51bGw7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXNzZXJ0Q29sbGVjdGlvbih0aGlzLmNvbnRlbnRzKVxuICAgICAgICAgICAgPyB0aGlzLmNvbnRlbnRzLmRlbGV0ZUluKHBhdGgpXG4gICAgICAgICAgICA6IGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGl0ZW0gYXQgYGtleWAsIG9yIGB1bmRlZmluZWRgIGlmIG5vdCBmb3VuZC4gQnkgZGVmYXVsdCB1bndyYXBzXG4gICAgICogc2NhbGFyIHZhbHVlcyBmcm9tIHRoZWlyIHN1cnJvdW5kaW5nIG5vZGU7IHRvIGRpc2FibGUgc2V0IGBrZWVwU2NhbGFyYCB0b1xuICAgICAqIGB0cnVlYCAoY29sbGVjdGlvbnMgYXJlIGFsd2F5cyByZXR1cm5lZCBpbnRhY3QpLlxuICAgICAqL1xuICAgIGdldChrZXksIGtlZXBTY2FsYXIpIHtcbiAgICAgICAgcmV0dXJuIGlzQ29sbGVjdGlvbih0aGlzLmNvbnRlbnRzKVxuICAgICAgICAgICAgPyB0aGlzLmNvbnRlbnRzLmdldChrZXksIGtlZXBTY2FsYXIpXG4gICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBpdGVtIGF0IGBwYXRoYCwgb3IgYHVuZGVmaW5lZGAgaWYgbm90IGZvdW5kLiBCeSBkZWZhdWx0IHVud3JhcHNcbiAgICAgKiBzY2FsYXIgdmFsdWVzIGZyb20gdGhlaXIgc3Vycm91bmRpbmcgbm9kZTsgdG8gZGlzYWJsZSBzZXQgYGtlZXBTY2FsYXJgIHRvXG4gICAgICogYHRydWVgIChjb2xsZWN0aW9ucyBhcmUgYWx3YXlzIHJldHVybmVkIGludGFjdCkuXG4gICAgICovXG4gICAgZ2V0SW4ocGF0aCwga2VlcFNjYWxhcikge1xuICAgICAgICBpZiAoaXNFbXB0eVBhdGgocGF0aCkpXG4gICAgICAgICAgICByZXR1cm4gIWtlZXBTY2FsYXIgJiYgaXNTY2FsYXIodGhpcy5jb250ZW50cylcbiAgICAgICAgICAgICAgICA/IHRoaXMuY29udGVudHMudmFsdWVcbiAgICAgICAgICAgICAgICA6IHRoaXMuY29udGVudHM7XG4gICAgICAgIHJldHVybiBpc0NvbGxlY3Rpb24odGhpcy5jb250ZW50cylcbiAgICAgICAgICAgID8gdGhpcy5jb250ZW50cy5nZXRJbihwYXRoLCBrZWVwU2NhbGFyKVxuICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGUgZG9jdW1lbnQgaW5jbHVkZXMgYSB2YWx1ZSB3aXRoIHRoZSBrZXkgYGtleWAuXG4gICAgICovXG4gICAgaGFzKGtleSkge1xuICAgICAgICByZXR1cm4gaXNDb2xsZWN0aW9uKHRoaXMuY29udGVudHMpID8gdGhpcy5jb250ZW50cy5oYXMoa2V5KSA6IGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGhlIGRvY3VtZW50IGluY2x1ZGVzIGEgdmFsdWUgYXQgYHBhdGhgLlxuICAgICAqL1xuICAgIGhhc0luKHBhdGgpIHtcbiAgICAgICAgaWYgKGlzRW1wdHlQYXRoKHBhdGgpKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udGVudHMgIT09IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIGlzQ29sbGVjdGlvbih0aGlzLmNvbnRlbnRzKSA/IHRoaXMuY29udGVudHMuaGFzSW4ocGF0aCkgOiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyBhIHZhbHVlIGluIHRoaXMgZG9jdW1lbnQuIEZvciBgISFzZXRgLCBgdmFsdWVgIG5lZWRzIHRvIGJlIGFcbiAgICAgKiBib29sZWFuIHRvIGFkZC9yZW1vdmUgdGhlIGl0ZW0gZnJvbSB0aGUgc2V0LlxuICAgICAqL1xuICAgIHNldChrZXksIHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbnRlbnRzID09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuY29udGVudHMgPSBjb2xsZWN0aW9uRnJvbVBhdGgodGhpcy5zY2hlbWEsIFtrZXldLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYXNzZXJ0Q29sbGVjdGlvbih0aGlzLmNvbnRlbnRzKSkge1xuICAgICAgICAgICAgdGhpcy5jb250ZW50cy5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyBhIHZhbHVlIGluIHRoaXMgZG9jdW1lbnQuIEZvciBgISFzZXRgLCBgdmFsdWVgIG5lZWRzIHRvIGJlIGFcbiAgICAgKiBib29sZWFuIHRvIGFkZC9yZW1vdmUgdGhlIGl0ZW0gZnJvbSB0aGUgc2V0LlxuICAgICAqL1xuICAgIHNldEluKHBhdGgsIHZhbHVlKSB7XG4gICAgICAgIGlmIChpc0VtcHR5UGF0aChwYXRoKSlcbiAgICAgICAgICAgIHRoaXMuY29udGVudHMgPSB2YWx1ZTtcbiAgICAgICAgZWxzZSBpZiAodGhpcy5jb250ZW50cyA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRlbnRzID0gY29sbGVjdGlvbkZyb21QYXRoKHRoaXMuc2NoZW1hLCBBcnJheS5mcm9tKHBhdGgpLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYXNzZXJ0Q29sbGVjdGlvbih0aGlzLmNvbnRlbnRzKSkge1xuICAgICAgICAgICAgdGhpcy5jb250ZW50cy5zZXRJbihwYXRoLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hhbmdlIHRoZSBZQU1MIHZlcnNpb24gYW5kIHNjaGVtYSB1c2VkIGJ5IHRoZSBkb2N1bWVudC5cbiAgICAgKiBBIGBudWxsYCB2ZXJzaW9uIGRpc2FibGVzIHN1cHBvcnQgZm9yIGRpcmVjdGl2ZXMsIGV4cGxpY2l0IHRhZ3MsIGFuY2hvcnMsIGFuZCBhbGlhc2VzLlxuICAgICAqIEl0IGFsc28gcmVxdWlyZXMgdGhlIGBzY2hlbWFgIG9wdGlvbiB0byBiZSBnaXZlbiBhcyBhIGBTY2hlbWFgIGluc3RhbmNlIHZhbHVlLlxuICAgICAqXG4gICAgICogT3ZlcnJpZGVzIGFsbCBwcmV2aW91c2x5IHNldCBzY2hlbWEgb3B0aW9ucy5cbiAgICAgKi9cbiAgICBzZXRTY2hlbWEodmVyc2lvbiwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmVyc2lvbiA9PT0gJ251bWJlcicpXG4gICAgICAgICAgICB2ZXJzaW9uID0gU3RyaW5nKHZlcnNpb24pO1xuICAgICAgICBsZXQgb3B0O1xuICAgICAgICBzd2l0Y2ggKHZlcnNpb24pIHtcbiAgICAgICAgICAgIGNhc2UgJzEuMSc6XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZGlyZWN0aXZlcylcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXJlY3RpdmVzLnlhbWwudmVyc2lvbiA9ICcxLjEnO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXJlY3RpdmVzID0gbmV3IERpcmVjdGl2ZXMoeyB2ZXJzaW9uOiAnMS4xJyB9KTtcbiAgICAgICAgICAgICAgICBvcHQgPSB7IG1lcmdlOiB0cnVlLCByZXNvbHZlS25vd25UYWdzOiBmYWxzZSwgc2NoZW1hOiAneWFtbC0xLjEnIH07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICcxLjInOlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmRpcmVjdGl2ZXMpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlyZWN0aXZlcy55YW1sLnZlcnNpb24gPSAnMS4yJztcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlyZWN0aXZlcyA9IG5ldyBEaXJlY3RpdmVzKHsgdmVyc2lvbjogJzEuMicgfSk7XG4gICAgICAgICAgICAgICAgb3B0ID0geyBtZXJnZTogZmFsc2UsIHJlc29sdmVLbm93blRhZ3M6IHRydWUsIHNjaGVtYTogJ2NvcmUnIH07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIG51bGw6XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZGlyZWN0aXZlcylcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuZGlyZWN0aXZlcztcbiAgICAgICAgICAgICAgICBvcHQgPSBudWxsO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN2ID0gSlNPTi5zdHJpbmdpZnkodmVyc2lvbik7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCAnMS4xJywgJzEuMicgb3IgbnVsbCBhcyBmaXJzdCBhcmd1bWVudCwgYnV0IGZvdW5kOiAke3N2fWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIE5vdCB1c2luZyBgaW5zdGFuY2VvZiBTY2hlbWFgIHRvIGFsbG93IGZvciBkdWNrIHR5cGluZ1xuICAgICAgICBpZiAob3B0aW9ucy5zY2hlbWEgaW5zdGFuY2VvZiBPYmplY3QpXG4gICAgICAgICAgICB0aGlzLnNjaGVtYSA9IG9wdGlvbnMuc2NoZW1hO1xuICAgICAgICBlbHNlIGlmIChvcHQpXG4gICAgICAgICAgICB0aGlzLnNjaGVtYSA9IG5ldyBTY2hlbWEoT2JqZWN0LmFzc2lnbihvcHQsIG9wdGlvbnMpKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBXaXRoIGEgbnVsbCBZQU1MIHZlcnNpb24sIHRoZSB7IHNjaGVtYTogU2NoZW1hIH0gb3B0aW9uIGlzIHJlcXVpcmVkYCk7XG4gICAgfVxuICAgIC8vIGpzb24gJiBqc29uQXJnIGFyZSBvbmx5IHVzZWQgZnJvbSB0b0pTT04oKVxuICAgIHRvSlMoeyBqc29uLCBqc29uQXJnLCBtYXBBc01hcCwgbWF4QWxpYXNDb3VudCwgb25BbmNob3IsIHJldml2ZXIgfSA9IHt9KSB7XG4gICAgICAgIGNvbnN0IGN0eCA9IHtcbiAgICAgICAgICAgIGFuY2hvcnM6IG5ldyBNYXAoKSxcbiAgICAgICAgICAgIGRvYzogdGhpcyxcbiAgICAgICAgICAgIGtlZXA6ICFqc29uLFxuICAgICAgICAgICAgbWFwQXNNYXA6IG1hcEFzTWFwID09PSB0cnVlLFxuICAgICAgICAgICAgbWFwS2V5V2FybmVkOiBmYWxzZSxcbiAgICAgICAgICAgIG1heEFsaWFzQ291bnQ6IHR5cGVvZiBtYXhBbGlhc0NvdW50ID09PSAnbnVtYmVyJyA/IG1heEFsaWFzQ291bnQgOiAxMDAsXG4gICAgICAgICAgICBzdHJpbmdpZnlcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcmVzID0gdG9KUyh0aGlzLmNvbnRlbnRzLCBqc29uQXJnIHx8ICcnLCBjdHgpO1xuICAgICAgICBpZiAodHlwZW9mIG9uQW5jaG9yID09PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgZm9yIChjb25zdCB7IGNvdW50LCByZXMgfSBvZiBjdHguYW5jaG9ycy52YWx1ZXMoKSlcbiAgICAgICAgICAgICAgICBvbkFuY2hvcihyZXMsIGNvdW50KTtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiByZXZpdmVyID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgICA/IGFwcGx5UmV2aXZlcihyZXZpdmVyLCB7ICcnOiByZXMgfSwgJycsIHJlcylcbiAgICAgICAgICAgIDogcmVzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIEpTT04gcmVwcmVzZW50YXRpb24gb2YgdGhlIGRvY3VtZW50IGBjb250ZW50c2AuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ganNvbkFyZyBVc2VkIGJ5IGBKU09OLnN0cmluZ2lmeWAgdG8gaW5kaWNhdGUgdGhlIGFycmF5IGluZGV4IG9yXG4gICAgICogICBwcm9wZXJ0eSBuYW1lLlxuICAgICAqL1xuICAgIHRvSlNPTihqc29uQXJnLCBvbkFuY2hvcikge1xuICAgICAgICByZXR1cm4gdGhpcy50b0pTKHsganNvbjogdHJ1ZSwganNvbkFyZywgbWFwQXNNYXA6IGZhbHNlLCBvbkFuY2hvciB9KTtcbiAgICB9XG4gICAgLyoqIEEgWUFNTCByZXByZXNlbnRhdGlvbiBvZiB0aGUgZG9jdW1lbnQuICovXG4gICAgdG9TdHJpbmcob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGlmICh0aGlzLmVycm9ycy5sZW5ndGggPiAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEb2N1bWVudCB3aXRoIGVycm9ycyBjYW5ub3QgYmUgc3RyaW5naWZpZWQnKTtcbiAgICAgICAgaWYgKCdpbmRlbnQnIGluIG9wdGlvbnMgJiZcbiAgICAgICAgICAgICghTnVtYmVyLmlzSW50ZWdlcihvcHRpb25zLmluZGVudCkgfHwgTnVtYmVyKG9wdGlvbnMuaW5kZW50KSA8PSAwKSkge1xuICAgICAgICAgICAgY29uc3QgcyA9IEpTT04uc3RyaW5naWZ5KG9wdGlvbnMuaW5kZW50KTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgXCJpbmRlbnRcIiBvcHRpb24gbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXIsIG5vdCAke3N9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0cmluZ2lmeURvY3VtZW50KHRoaXMsIG9wdGlvbnMpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGFzc2VydENvbGxlY3Rpb24oY29udGVudHMpIHtcbiAgICBpZiAoaXNDb2xsZWN0aW9uKGNvbnRlbnRzKSlcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBhIFlBTUwgY29sbGVjdGlvbiBhcyBkb2N1bWVudCBjb250ZW50cycpO1xufVxuXG5leHBvcnQgeyBEb2N1bWVudCB9O1xuIiwgImNsYXNzIFlBTUxFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihuYW1lLCBwb3MsIGNvZGUsIG1lc3NhZ2UpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5jb2RlID0gY29kZTtcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICAgICAgdGhpcy5wb3MgPSBwb3M7XG4gICAgfVxufVxuY2xhc3MgWUFNTFBhcnNlRXJyb3IgZXh0ZW5kcyBZQU1MRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHBvcywgY29kZSwgbWVzc2FnZSkge1xuICAgICAgICBzdXBlcignWUFNTFBhcnNlRXJyb3InLCBwb3MsIGNvZGUsIG1lc3NhZ2UpO1xuICAgIH1cbn1cbmNsYXNzIFlBTUxXYXJuaW5nIGV4dGVuZHMgWUFNTEVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcihwb3MsIGNvZGUsIG1lc3NhZ2UpIHtcbiAgICAgICAgc3VwZXIoJ1lBTUxXYXJuaW5nJywgcG9zLCBjb2RlLCBtZXNzYWdlKTtcbiAgICB9XG59XG5jb25zdCBwcmV0dGlmeUVycm9yID0gKHNyYywgbGMpID0+IChlcnJvcikgPT4ge1xuICAgIGlmIChlcnJvci5wb3NbMF0gPT09IC0xKVxuICAgICAgICByZXR1cm47XG4gICAgZXJyb3IubGluZVBvcyA9IGVycm9yLnBvcy5tYXAocG9zID0+IGxjLmxpbmVQb3MocG9zKSk7XG4gICAgY29uc3QgeyBsaW5lLCBjb2wgfSA9IGVycm9yLmxpbmVQb3NbMF07XG4gICAgZXJyb3IubWVzc2FnZSArPSBgIGF0IGxpbmUgJHtsaW5lfSwgY29sdW1uICR7Y29sfWA7XG4gICAgbGV0IGNpID0gY29sIC0gMTtcbiAgICBsZXQgbGluZVN0ciA9IHNyY1xuICAgICAgICAuc3Vic3RyaW5nKGxjLmxpbmVTdGFydHNbbGluZSAtIDFdLCBsYy5saW5lU3RhcnRzW2xpbmVdKVxuICAgICAgICAucmVwbGFjZSgvW1xcblxccl0rJC8sICcnKTtcbiAgICAvLyBUcmltIHRvIG1heCA4MCBjaGFycywga2VlcGluZyBjb2wgcG9zaXRpb24gbmVhciB0aGUgbWlkZGxlXG4gICAgaWYgKGNpID49IDYwICYmIGxpbmVTdHIubGVuZ3RoID4gODApIHtcbiAgICAgICAgY29uc3QgdHJpbVN0YXJ0ID0gTWF0aC5taW4oY2kgLSAzOSwgbGluZVN0ci5sZW5ndGggLSA3OSk7XG4gICAgICAgIGxpbmVTdHIgPSAnXHUyMDI2JyArIGxpbmVTdHIuc3Vic3RyaW5nKHRyaW1TdGFydCk7XG4gICAgICAgIGNpIC09IHRyaW1TdGFydCAtIDE7XG4gICAgfVxuICAgIGlmIChsaW5lU3RyLmxlbmd0aCA+IDgwKVxuICAgICAgICBsaW5lU3RyID0gbGluZVN0ci5zdWJzdHJpbmcoMCwgNzkpICsgJ1x1MjAyNic7XG4gICAgLy8gSW5jbHVkZSBwcmV2aW91cyBsaW5lIGluIGNvbnRleHQgaWYgcG9pbnRpbmcgYXQgbGluZSBzdGFydFxuICAgIGlmIChsaW5lID4gMSAmJiAvXiAqJC8udGVzdChsaW5lU3RyLnN1YnN0cmluZygwLCBjaSkpKSB7XG4gICAgICAgIC8vIFJlZ2V4cCB3b24ndCBtYXRjaCBpZiBzdGFydCBpcyB0cmltbWVkXG4gICAgICAgIGxldCBwcmV2ID0gc3JjLnN1YnN0cmluZyhsYy5saW5lU3RhcnRzW2xpbmUgLSAyXSwgbGMubGluZVN0YXJ0c1tsaW5lIC0gMV0pO1xuICAgICAgICBpZiAocHJldi5sZW5ndGggPiA4MClcbiAgICAgICAgICAgIHByZXYgPSBwcmV2LnN1YnN0cmluZygwLCA3OSkgKyAnXHUyMDI2XFxuJztcbiAgICAgICAgbGluZVN0ciA9IHByZXYgKyBsaW5lU3RyO1xuICAgIH1cbiAgICBpZiAoL1teIF0vLnRlc3QobGluZVN0cikpIHtcbiAgICAgICAgbGV0IGNvdW50ID0gMTtcbiAgICAgICAgY29uc3QgZW5kID0gZXJyb3IubGluZVBvc1sxXTtcbiAgICAgICAgaWYgKGVuZCAmJiBlbmQubGluZSA9PT0gbGluZSAmJiBlbmQuY29sID4gY29sKSB7XG4gICAgICAgICAgICBjb3VudCA9IE1hdGgubWluKGVuZC5jb2wgLSBjb2wsIDgwIC0gY2kpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBvaW50ZXIgPSAnICcucmVwZWF0KGNpKSArICdeJy5yZXBlYXQoY291bnQpO1xuICAgICAgICBlcnJvci5tZXNzYWdlICs9IGA6XFxuXFxuJHtsaW5lU3RyfVxcbiR7cG9pbnRlcn1cXG5gO1xuICAgIH1cbn07XG5cbmV4cG9ydCB7IFlBTUxFcnJvciwgWUFNTFBhcnNlRXJyb3IsIFlBTUxXYXJuaW5nLCBwcmV0dGlmeUVycm9yIH07XG4iLCAiZnVuY3Rpb24gcmVzb2x2ZVByb3BzKHRva2VucywgeyBmbG93LCBpbmRpY2F0b3IsIG5leHQsIG9mZnNldCwgb25FcnJvciwgc3RhcnRPbk5ld2xpbmUgfSkge1xuICAgIGxldCBzcGFjZUJlZm9yZSA9IGZhbHNlO1xuICAgIGxldCBhdE5ld2xpbmUgPSBzdGFydE9uTmV3bGluZTtcbiAgICBsZXQgaGFzU3BhY2UgPSBzdGFydE9uTmV3bGluZTtcbiAgICBsZXQgY29tbWVudCA9ICcnO1xuICAgIGxldCBjb21tZW50U2VwID0gJyc7XG4gICAgbGV0IGhhc05ld2xpbmUgPSBmYWxzZTtcbiAgICBsZXQgcmVxU3BhY2UgPSBmYWxzZTtcbiAgICBsZXQgYW5jaG9yID0gbnVsbDtcbiAgICBsZXQgdGFnID0gbnVsbDtcbiAgICBsZXQgY29tbWEgPSBudWxsO1xuICAgIGxldCBmb3VuZCA9IG51bGw7XG4gICAgbGV0IHN0YXJ0ID0gbnVsbDtcbiAgICBmb3IgKGNvbnN0IHRva2VuIG9mIHRva2Vucykge1xuICAgICAgICBpZiAocmVxU3BhY2UpIHtcbiAgICAgICAgICAgIGlmICh0b2tlbi50eXBlICE9PSAnc3BhY2UnICYmXG4gICAgICAgICAgICAgICAgdG9rZW4udHlwZSAhPT0gJ25ld2xpbmUnICYmXG4gICAgICAgICAgICAgICAgdG9rZW4udHlwZSAhPT0gJ2NvbW1hJylcbiAgICAgICAgICAgICAgICBvbkVycm9yKHRva2VuLm9mZnNldCwgJ01JU1NJTkdfQ0hBUicsICdUYWdzIGFuZCBhbmNob3JzIG11c3QgYmUgc2VwYXJhdGVkIGZyb20gdGhlIG5leHQgdG9rZW4gYnkgd2hpdGUgc3BhY2UnKTtcbiAgICAgICAgICAgIHJlcVNwYWNlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoICh0b2tlbi50eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdzcGFjZSc6XG4gICAgICAgICAgICAgICAgLy8gQXQgdGhlIGRvYyBsZXZlbCwgdGFicyBhdCBsaW5lIHN0YXJ0IG1heSBiZSBwYXJzZWRcbiAgICAgICAgICAgICAgICAvLyBhcyBsZWFkaW5nIHdoaXRlIHNwYWNlIHJhdGhlciB0aGFuIGluZGVudGF0aW9uLlxuICAgICAgICAgICAgICAgIC8vIEluIGEgZmxvdyBjb2xsZWN0aW9uLCBvbmx5IHRoZSBwYXJzZXIgaGFuZGxlcyBpbmRlbnQuXG4gICAgICAgICAgICAgICAgaWYgKCFmbG93ICYmXG4gICAgICAgICAgICAgICAgICAgIGF0TmV3bGluZSAmJlxuICAgICAgICAgICAgICAgICAgICBpbmRpY2F0b3IgIT09ICdkb2Mtc3RhcnQnICYmXG4gICAgICAgICAgICAgICAgICAgIHRva2VuLnNvdXJjZVswXSA9PT0gJ1xcdCcpXG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3IodG9rZW4sICdUQUJfQVNfSU5ERU5UJywgJ1RhYnMgYXJlIG5vdCBhbGxvd2VkIGFzIGluZGVudGF0aW9uJyk7XG4gICAgICAgICAgICAgICAgaGFzU3BhY2UgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnY29tbWVudCc6IHtcbiAgICAgICAgICAgICAgICBpZiAoIWhhc1NwYWNlKVxuICAgICAgICAgICAgICAgICAgICBvbkVycm9yKHRva2VuLCAnTUlTU0lOR19DSEFSJywgJ0NvbW1lbnRzIG11c3QgYmUgc2VwYXJhdGVkIGZyb20gb3RoZXIgdG9rZW5zIGJ5IHdoaXRlIHNwYWNlIGNoYXJhY3RlcnMnKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjYiA9IHRva2VuLnNvdXJjZS5zdWJzdHJpbmcoMSkgfHwgJyAnO1xuICAgICAgICAgICAgICAgIGlmICghY29tbWVudClcbiAgICAgICAgICAgICAgICAgICAgY29tbWVudCA9IGNiO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgY29tbWVudCArPSBjb21tZW50U2VwICsgY2I7XG4gICAgICAgICAgICAgICAgY29tbWVudFNlcCA9ICcnO1xuICAgICAgICAgICAgICAgIGF0TmV3bGluZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnbmV3bGluZSc6XG4gICAgICAgICAgICAgICAgaWYgKGF0TmV3bGluZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29tbWVudClcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1lbnQgKz0gdG9rZW4uc291cmNlO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBzcGFjZUJlZm9yZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgY29tbWVudFNlcCArPSB0b2tlbi5zb3VyY2U7XG4gICAgICAgICAgICAgICAgYXROZXdsaW5lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBoYXNOZXdsaW5lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBoYXNTcGFjZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdhbmNob3InOlxuICAgICAgICAgICAgICAgIGlmIChhbmNob3IpXG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3IodG9rZW4sICdNVUxUSVBMRV9BTkNIT1JTJywgJ0Egbm9kZSBjYW4gaGF2ZSBhdCBtb3N0IG9uZSBhbmNob3InKTtcbiAgICAgICAgICAgICAgICBhbmNob3IgPSB0b2tlbjtcbiAgICAgICAgICAgICAgICBpZiAoc3RhcnQgPT09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gdG9rZW4ub2Zmc2V0O1xuICAgICAgICAgICAgICAgIGF0TmV3bGluZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGhhc1NwYWNlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcmVxU3BhY2UgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAndGFnJzoge1xuICAgICAgICAgICAgICAgIGlmICh0YWcpXG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3IodG9rZW4sICdNVUxUSVBMRV9UQUdTJywgJ0Egbm9kZSBjYW4gaGF2ZSBhdCBtb3N0IG9uZSB0YWcnKTtcbiAgICAgICAgICAgICAgICB0YWcgPSB0b2tlbjtcbiAgICAgICAgICAgICAgICBpZiAoc3RhcnQgPT09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gdG9rZW4ub2Zmc2V0O1xuICAgICAgICAgICAgICAgIGF0TmV3bGluZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGhhc1NwYWNlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcmVxU3BhY2UgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBpbmRpY2F0b3I6XG4gICAgICAgICAgICAgICAgLy8gQ291bGQgaGVyZSBoYW5kbGUgcHJlY2VkaW5nIGNvbW1lbnRzIGRpZmZlcmVudGx5XG4gICAgICAgICAgICAgICAgaWYgKGFuY2hvciB8fCB0YWcpXG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3IodG9rZW4sICdCQURfUFJPUF9PUkRFUicsIGBBbmNob3JzIGFuZCB0YWdzIG11c3QgYmUgYWZ0ZXIgdGhlICR7dG9rZW4uc291cmNlfSBpbmRpY2F0b3JgKTtcbiAgICAgICAgICAgICAgICBpZiAoZm91bmQpXG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3IodG9rZW4sICdVTkVYUEVDVEVEX1RPS0VOJywgYFVuZXhwZWN0ZWQgJHt0b2tlbi5zb3VyY2V9IGluICR7ZmxvdyB8fCAnY29sbGVjdGlvbid9YCk7XG4gICAgICAgICAgICAgICAgZm91bmQgPSB0b2tlbjtcbiAgICAgICAgICAgICAgICBhdE5ld2xpbmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBoYXNTcGFjZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnY29tbWEnOlxuICAgICAgICAgICAgICAgIGlmIChmbG93KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb21tYSlcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uRXJyb3IodG9rZW4sICdVTkVYUEVDVEVEX1RPS0VOJywgYFVuZXhwZWN0ZWQgLCBpbiAke2Zsb3d9YCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbW1hID0gdG9rZW47XG4gICAgICAgICAgICAgICAgICAgIGF0TmV3bGluZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBoYXNTcGFjZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBlbHNlIGZhbGx0aHJvdWdoXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIG9uRXJyb3IodG9rZW4sICdVTkVYUEVDVEVEX1RPS0VOJywgYFVuZXhwZWN0ZWQgJHt0b2tlbi50eXBlfSB0b2tlbmApO1xuICAgICAgICAgICAgICAgIGF0TmV3bGluZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGhhc1NwYWNlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgbGFzdCA9IHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV07XG4gICAgY29uc3QgZW5kID0gbGFzdCA/IGxhc3Qub2Zmc2V0ICsgbGFzdC5zb3VyY2UubGVuZ3RoIDogb2Zmc2V0O1xuICAgIGlmIChyZXFTcGFjZSAmJlxuICAgICAgICBuZXh0ICYmXG4gICAgICAgIG5leHQudHlwZSAhPT0gJ3NwYWNlJyAmJlxuICAgICAgICBuZXh0LnR5cGUgIT09ICduZXdsaW5lJyAmJlxuICAgICAgICBuZXh0LnR5cGUgIT09ICdjb21tYScgJiZcbiAgICAgICAgKG5leHQudHlwZSAhPT0gJ3NjYWxhcicgfHwgbmV4dC5zb3VyY2UgIT09ICcnKSlcbiAgICAgICAgb25FcnJvcihuZXh0Lm9mZnNldCwgJ01JU1NJTkdfQ0hBUicsICdUYWdzIGFuZCBhbmNob3JzIG11c3QgYmUgc2VwYXJhdGVkIGZyb20gdGhlIG5leHQgdG9rZW4gYnkgd2hpdGUgc3BhY2UnKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBjb21tYSxcbiAgICAgICAgZm91bmQsXG4gICAgICAgIHNwYWNlQmVmb3JlLFxuICAgICAgICBjb21tZW50LFxuICAgICAgICBoYXNOZXdsaW5lLFxuICAgICAgICBhbmNob3IsXG4gICAgICAgIHRhZyxcbiAgICAgICAgZW5kLFxuICAgICAgICBzdGFydDogc3RhcnQgIT09IG51bGwgJiYgc3RhcnQgIT09IHZvaWQgMCA/IHN0YXJ0IDogZW5kXG4gICAgfTtcbn1cblxuZXhwb3J0IHsgcmVzb2x2ZVByb3BzIH07XG4iLCAiZnVuY3Rpb24gY29udGFpbnNOZXdsaW5lKGtleSkge1xuICAgIGlmICgha2V5KVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBzd2l0Y2ggKGtleS50eXBlKSB7XG4gICAgICAgIGNhc2UgJ2FsaWFzJzpcbiAgICAgICAgY2FzZSAnc2NhbGFyJzpcbiAgICAgICAgY2FzZSAnZG91YmxlLXF1b3RlZC1zY2FsYXInOlxuICAgICAgICBjYXNlICdzaW5nbGUtcXVvdGVkLXNjYWxhcic6XG4gICAgICAgICAgICBpZiAoa2V5LnNvdXJjZS5pbmNsdWRlcygnXFxuJykpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBpZiAoa2V5LmVuZClcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHN0IG9mIGtleS5lbmQpXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdC50eXBlID09PSAnbmV3bGluZScpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgY2FzZSAnZmxvdy1jb2xsZWN0aW9uJzpcbiAgICAgICAgICAgIGZvciAoY29uc3QgaXQgb2Yga2V5Lml0ZW1zKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBzdCBvZiBpdC5zdGFydClcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0LnR5cGUgPT09ICduZXdsaW5lJylcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIGlmIChpdC5zZXApXG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3Qgc3Qgb2YgaXQuc2VwKVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0LnR5cGUgPT09ICduZXdsaW5lJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAoY29udGFpbnNOZXdsaW5lKGl0LmtleSkgfHwgY29udGFpbnNOZXdsaW5lKGl0LnZhbHVlKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59XG5cbmV4cG9ydCB7IGNvbnRhaW5zTmV3bGluZSB9O1xuIiwgImltcG9ydCB7IGNvbnRhaW5zTmV3bGluZSB9IGZyb20gJy4vdXRpbC1jb250YWlucy1uZXdsaW5lLmpzJztcblxuZnVuY3Rpb24gZmxvd0luZGVudENoZWNrKGluZGVudCwgZmMsIG9uRXJyb3IpIHtcbiAgICBpZiAoKGZjID09PSBudWxsIHx8IGZjID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmYy50eXBlKSA9PT0gJ2Zsb3ctY29sbGVjdGlvbicpIHtcbiAgICAgICAgY29uc3QgZW5kID0gZmMuZW5kWzBdO1xuICAgICAgICBpZiAoZW5kLmluZGVudCA9PT0gaW5kZW50ICYmXG4gICAgICAgICAgICAoZW5kLnNvdXJjZSA9PT0gJ10nIHx8IGVuZC5zb3VyY2UgPT09ICd9JykgJiZcbiAgICAgICAgICAgIGNvbnRhaW5zTmV3bGluZShmYykpIHtcbiAgICAgICAgICAgIGNvbnN0IG1zZyA9ICdGbG93IGVuZCBpbmRpY2F0b3Igc2hvdWxkIGJlIG1vcmUgaW5kZW50ZWQgdGhhbiBwYXJlbnQnO1xuICAgICAgICAgICAgb25FcnJvcihlbmQsICdCQURfSU5ERU5UJywgbXNnLCB0cnVlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IHsgZmxvd0luZGVudENoZWNrIH07XG4iLCAiaW1wb3J0IHsgaXNTY2FsYXIgfSBmcm9tICcuLi9ub2Rlcy9Ob2RlLmpzJztcblxuZnVuY3Rpb24gbWFwSW5jbHVkZXMoY3R4LCBpdGVtcywgc2VhcmNoKSB7XG4gICAgY29uc3QgeyB1bmlxdWVLZXlzIH0gPSBjdHgub3B0aW9ucztcbiAgICBpZiAodW5pcXVlS2V5cyA9PT0gZmFsc2UpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCBpc0VxdWFsID0gdHlwZW9mIHVuaXF1ZUtleXMgPT09ICdmdW5jdGlvbidcbiAgICAgICAgPyB1bmlxdWVLZXlzXG4gICAgICAgIDogKGEsIGIpID0+IGEgPT09IGIgfHxcbiAgICAgICAgICAgIChpc1NjYWxhcihhKSAmJlxuICAgICAgICAgICAgICAgIGlzU2NhbGFyKGIpICYmXG4gICAgICAgICAgICAgICAgYS52YWx1ZSA9PT0gYi52YWx1ZSAmJlxuICAgICAgICAgICAgICAgICEoYS52YWx1ZSA9PT0gJzw8JyAmJiBjdHguc2NoZW1hLm1lcmdlKSk7XG4gICAgcmV0dXJuIGl0ZW1zLnNvbWUocGFpciA9PiBpc0VxdWFsKHBhaXIua2V5LCBzZWFyY2gpKTtcbn1cblxuZXhwb3J0IHsgbWFwSW5jbHVkZXMgfTtcbiIsICJpbXBvcnQgeyBQYWlyIH0gZnJvbSAnLi4vbm9kZXMvUGFpci5qcyc7XG5pbXBvcnQgeyBZQU1MTWFwIH0gZnJvbSAnLi4vbm9kZXMvWUFNTE1hcC5qcyc7XG5pbXBvcnQgeyByZXNvbHZlUHJvcHMgfSBmcm9tICcuL3Jlc29sdmUtcHJvcHMuanMnO1xuaW1wb3J0IHsgY29udGFpbnNOZXdsaW5lIH0gZnJvbSAnLi91dGlsLWNvbnRhaW5zLW5ld2xpbmUuanMnO1xuaW1wb3J0IHsgZmxvd0luZGVudENoZWNrIH0gZnJvbSAnLi91dGlsLWZsb3ctaW5kZW50LWNoZWNrLmpzJztcbmltcG9ydCB7IG1hcEluY2x1ZGVzIH0gZnJvbSAnLi91dGlsLW1hcC1pbmNsdWRlcy5qcyc7XG5cbmNvbnN0IHN0YXJ0Q29sTXNnID0gJ0FsbCBtYXBwaW5nIGl0ZW1zIG11c3Qgc3RhcnQgYXQgdGhlIHNhbWUgY29sdW1uJztcbmZ1bmN0aW9uIHJlc29sdmVCbG9ja01hcCh7IGNvbXBvc2VOb2RlLCBjb21wb3NlRW1wdHlOb2RlIH0sIGN0eCwgYm0sIG9uRXJyb3IpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgbWFwID0gbmV3IFlBTUxNYXAoY3R4LnNjaGVtYSk7XG4gICAgaWYgKGN0eC5hdFJvb3QpXG4gICAgICAgIGN0eC5hdFJvb3QgPSBmYWxzZTtcbiAgICBsZXQgb2Zmc2V0ID0gYm0ub2Zmc2V0O1xuICAgIGZvciAoY29uc3QgY29sbEl0ZW0gb2YgYm0uaXRlbXMpIHtcbiAgICAgICAgY29uc3QgeyBzdGFydCwga2V5LCBzZXAsIHZhbHVlIH0gPSBjb2xsSXRlbTtcbiAgICAgICAgLy8ga2V5IHByb3BlcnRpZXNcbiAgICAgICAgY29uc3Qga2V5UHJvcHMgPSByZXNvbHZlUHJvcHMoc3RhcnQsIHtcbiAgICAgICAgICAgIGluZGljYXRvcjogJ2V4cGxpY2l0LWtleS1pbmQnLFxuICAgICAgICAgICAgbmV4dDoga2V5IHx8IChzZXAgPT09IG51bGwgfHwgc2VwID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzZXBbMF0pLFxuICAgICAgICAgICAgb2Zmc2V0LFxuICAgICAgICAgICAgb25FcnJvcixcbiAgICAgICAgICAgIHN0YXJ0T25OZXdsaW5lOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBpbXBsaWNpdEtleSA9ICFrZXlQcm9wcy5mb3VuZDtcbiAgICAgICAgaWYgKGltcGxpY2l0S2V5KSB7XG4gICAgICAgICAgICBpZiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgaWYgKGtleS50eXBlID09PSAnYmxvY2stc2VxJylcbiAgICAgICAgICAgICAgICAgICAgb25FcnJvcihvZmZzZXQsICdCTE9DS19BU19JTVBMSUNJVF9LRVknLCAnQSBibG9jayBzZXF1ZW5jZSBtYXkgbm90IGJlIHVzZWQgYXMgYW4gaW1wbGljaXQgbWFwIGtleScpO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCdpbmRlbnQnIGluIGtleSAmJiBrZXkuaW5kZW50ICE9PSBibS5pbmRlbnQpXG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3Iob2Zmc2V0LCAnQkFEX0lOREVOVCcsIHN0YXJ0Q29sTXNnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgha2V5UHJvcHMuYW5jaG9yICYmICFrZXlQcm9wcy50YWcgJiYgIXNlcCkge1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IGFzc2VydCBiZWluZyBhdCBsYXN0IGl0ZW0/XG4gICAgICAgICAgICAgICAgaWYgKGtleVByb3BzLmNvbW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hcC5jb21tZW50KVxuICAgICAgICAgICAgICAgICAgICAgICAgbWFwLmNvbW1lbnQgKz0gJ1xcbicgKyBrZXlQcm9wcy5jb21tZW50O1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXAuY29tbWVudCA9IGtleVByb3BzLmNvbW1lbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCgoX2EgPSBrZXlQcm9wcy5mb3VuZCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmluZGVudCkgIT09IGJtLmluZGVudClcbiAgICAgICAgICAgIG9uRXJyb3Iob2Zmc2V0LCAnQkFEX0lOREVOVCcsIHN0YXJ0Q29sTXNnKTtcbiAgICAgICAgaWYgKGltcGxpY2l0S2V5ICYmIGNvbnRhaW5zTmV3bGluZShrZXkpKVxuICAgICAgICAgICAgb25FcnJvcihrZXksIC8vIGNoZWNrZWQgYnkgY29udGFpbnNOZXdsaW5lKClcbiAgICAgICAgICAgICdNVUxUSUxJTkVfSU1QTElDSVRfS0VZJywgJ0ltcGxpY2l0IGtleXMgbmVlZCB0byBiZSBvbiBhIHNpbmdsZSBsaW5lJyk7XG4gICAgICAgIC8vIGtleSB2YWx1ZVxuICAgICAgICBjb25zdCBrZXlTdGFydCA9IGtleVByb3BzLmVuZDtcbiAgICAgICAgY29uc3Qga2V5Tm9kZSA9IGtleVxuICAgICAgICAgICAgPyBjb21wb3NlTm9kZShjdHgsIGtleSwga2V5UHJvcHMsIG9uRXJyb3IpXG4gICAgICAgICAgICA6IGNvbXBvc2VFbXB0eU5vZGUoY3R4LCBrZXlTdGFydCwgc3RhcnQsIG51bGwsIGtleVByb3BzLCBvbkVycm9yKTtcbiAgICAgICAgaWYgKGN0eC5zY2hlbWEuY29tcGF0KVxuICAgICAgICAgICAgZmxvd0luZGVudENoZWNrKGJtLmluZGVudCwga2V5LCBvbkVycm9yKTtcbiAgICAgICAgaWYgKG1hcEluY2x1ZGVzKGN0eCwgbWFwLml0ZW1zLCBrZXlOb2RlKSlcbiAgICAgICAgICAgIG9uRXJyb3Ioa2V5U3RhcnQsICdEVVBMSUNBVEVfS0VZJywgJ01hcCBrZXlzIG11c3QgYmUgdW5pcXVlJyk7XG4gICAgICAgIC8vIHZhbHVlIHByb3BlcnRpZXNcbiAgICAgICAgY29uc3QgdmFsdWVQcm9wcyA9IHJlc29sdmVQcm9wcyhzZXAgfHwgW10sIHtcbiAgICAgICAgICAgIGluZGljYXRvcjogJ21hcC12YWx1ZS1pbmQnLFxuICAgICAgICAgICAgbmV4dDogdmFsdWUsXG4gICAgICAgICAgICBvZmZzZXQ6IGtleU5vZGUucmFuZ2VbMl0sXG4gICAgICAgICAgICBvbkVycm9yLFxuICAgICAgICAgICAgc3RhcnRPbk5ld2xpbmU6ICFrZXkgfHwga2V5LnR5cGUgPT09ICdibG9jay1zY2FsYXInXG4gICAgICAgIH0pO1xuICAgICAgICBvZmZzZXQgPSB2YWx1ZVByb3BzLmVuZDtcbiAgICAgICAgaWYgKHZhbHVlUHJvcHMuZm91bmQpIHtcbiAgICAgICAgICAgIGlmIChpbXBsaWNpdEtleSkge1xuICAgICAgICAgICAgICAgIGlmICgodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHZhbHVlLnR5cGUpID09PSAnYmxvY2stbWFwJyAmJiAhdmFsdWVQcm9wcy5oYXNOZXdsaW5lKVxuICAgICAgICAgICAgICAgICAgICBvbkVycm9yKG9mZnNldCwgJ0JMT0NLX0FTX0lNUExJQ0lUX0tFWScsICdOZXN0ZWQgbWFwcGluZ3MgYXJlIG5vdCBhbGxvd2VkIGluIGNvbXBhY3QgbWFwcGluZ3MnKTtcbiAgICAgICAgICAgICAgICBpZiAoY3R4Lm9wdGlvbnMuc3RyaWN0ICYmXG4gICAgICAgICAgICAgICAgICAgIGtleVByb3BzLnN0YXJ0IDwgdmFsdWVQcm9wcy5mb3VuZC5vZmZzZXQgLSAxMDI0KVxuICAgICAgICAgICAgICAgICAgICBvbkVycm9yKGtleU5vZGUucmFuZ2UsICdLRVlfT1ZFUl8xMDI0X0NIQVJTJywgJ1RoZSA6IGluZGljYXRvciBtdXN0IGJlIGF0IG1vc3QgMTAyNCBjaGFycyBhZnRlciB0aGUgc3RhcnQgb2YgYW4gaW1wbGljaXQgYmxvY2sgbWFwcGluZyBrZXknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHZhbHVlIHZhbHVlXG4gICAgICAgICAgICBjb25zdCB2YWx1ZU5vZGUgPSB2YWx1ZVxuICAgICAgICAgICAgICAgID8gY29tcG9zZU5vZGUoY3R4LCB2YWx1ZSwgdmFsdWVQcm9wcywgb25FcnJvcilcbiAgICAgICAgICAgICAgICA6IGNvbXBvc2VFbXB0eU5vZGUoY3R4LCBvZmZzZXQsIHNlcCwgbnVsbCwgdmFsdWVQcm9wcywgb25FcnJvcik7XG4gICAgICAgICAgICBpZiAoY3R4LnNjaGVtYS5jb21wYXQpXG4gICAgICAgICAgICAgICAgZmxvd0luZGVudENoZWNrKGJtLmluZGVudCwgdmFsdWUsIG9uRXJyb3IpO1xuICAgICAgICAgICAgb2Zmc2V0ID0gdmFsdWVOb2RlLnJhbmdlWzJdO1xuICAgICAgICAgICAgY29uc3QgcGFpciA9IG5ldyBQYWlyKGtleU5vZGUsIHZhbHVlTm9kZSk7XG4gICAgICAgICAgICBpZiAoY3R4Lm9wdGlvbnMua2VlcFNvdXJjZVRva2VucylcbiAgICAgICAgICAgICAgICBwYWlyLnNyY1Rva2VuID0gY29sbEl0ZW07XG4gICAgICAgICAgICBtYXAuaXRlbXMucHVzaChwYWlyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGtleSB3aXRoIG5vIHZhbHVlXG4gICAgICAgICAgICBpZiAoaW1wbGljaXRLZXkpXG4gICAgICAgICAgICAgICAgb25FcnJvcihrZXlOb2RlLnJhbmdlLCAnTUlTU0lOR19DSEFSJywgJ0ltcGxpY2l0IG1hcCBrZXlzIG5lZWQgdG8gYmUgZm9sbG93ZWQgYnkgbWFwIHZhbHVlcycpO1xuICAgICAgICAgICAgaWYgKHZhbHVlUHJvcHMuY29tbWVudCkge1xuICAgICAgICAgICAgICAgIGlmIChrZXlOb2RlLmNvbW1lbnQpXG4gICAgICAgICAgICAgICAgICAgIGtleU5vZGUuY29tbWVudCArPSAnXFxuJyArIHZhbHVlUHJvcHMuY29tbWVudDtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGtleU5vZGUuY29tbWVudCA9IHZhbHVlUHJvcHMuY29tbWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHBhaXIgPSBuZXcgUGFpcihrZXlOb2RlKTtcbiAgICAgICAgICAgIGlmIChjdHgub3B0aW9ucy5rZWVwU291cmNlVG9rZW5zKVxuICAgICAgICAgICAgICAgIHBhaXIuc3JjVG9rZW4gPSBjb2xsSXRlbTtcbiAgICAgICAgICAgIG1hcC5pdGVtcy5wdXNoKHBhaXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG1hcC5yYW5nZSA9IFtibS5vZmZzZXQsIG9mZnNldCwgb2Zmc2V0XTtcbiAgICByZXR1cm4gbWFwO1xufVxuXG5leHBvcnQgeyByZXNvbHZlQmxvY2tNYXAgfTtcbiIsICJpbXBvcnQgeyBZQU1MU2VxIH0gZnJvbSAnLi4vbm9kZXMvWUFNTFNlcS5qcyc7XG5pbXBvcnQgeyByZXNvbHZlUHJvcHMgfSBmcm9tICcuL3Jlc29sdmUtcHJvcHMuanMnO1xuaW1wb3J0IHsgZmxvd0luZGVudENoZWNrIH0gZnJvbSAnLi91dGlsLWZsb3ctaW5kZW50LWNoZWNrLmpzJztcblxuZnVuY3Rpb24gcmVzb2x2ZUJsb2NrU2VxKHsgY29tcG9zZU5vZGUsIGNvbXBvc2VFbXB0eU5vZGUgfSwgY3R4LCBicywgb25FcnJvcikge1xuICAgIGNvbnN0IHNlcSA9IG5ldyBZQU1MU2VxKGN0eC5zY2hlbWEpO1xuICAgIGlmIChjdHguYXRSb290KVxuICAgICAgICBjdHguYXRSb290ID0gZmFsc2U7XG4gICAgbGV0IG9mZnNldCA9IGJzLm9mZnNldDtcbiAgICBmb3IgKGNvbnN0IHsgc3RhcnQsIHZhbHVlIH0gb2YgYnMuaXRlbXMpIHtcbiAgICAgICAgY29uc3QgcHJvcHMgPSByZXNvbHZlUHJvcHMoc3RhcnQsIHtcbiAgICAgICAgICAgIGluZGljYXRvcjogJ3NlcS1pdGVtLWluZCcsXG4gICAgICAgICAgICBuZXh0OiB2YWx1ZSxcbiAgICAgICAgICAgIG9mZnNldCxcbiAgICAgICAgICAgIG9uRXJyb3IsXG4gICAgICAgICAgICBzdGFydE9uTmV3bGluZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgb2Zmc2V0ID0gcHJvcHMuZW5kO1xuICAgICAgICBpZiAoIXByb3BzLmZvdW5kKSB7XG4gICAgICAgICAgICBpZiAocHJvcHMuYW5jaG9yIHx8IHByb3BzLnRhZyB8fCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAmJiB2YWx1ZS50eXBlID09PSAnYmxvY2stc2VxJylcbiAgICAgICAgICAgICAgICAgICAgb25FcnJvcihvZmZzZXQsICdCQURfSU5ERU5UJywgJ0FsbCBzZXF1ZW5jZSBpdGVtcyBtdXN0IHN0YXJ0IGF0IHRoZSBzYW1lIGNvbHVtbicpO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgb25FcnJvcihvZmZzZXQsICdNSVNTSU5HX0NIQVInLCAnU2VxdWVuY2UgaXRlbSB3aXRob3V0IC0gaW5kaWNhdG9yJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBhc3NlcnQgYmVpbmcgYXQgbGFzdCBpdGVtP1xuICAgICAgICAgICAgICAgIGlmIChwcm9wcy5jb21tZW50KVxuICAgICAgICAgICAgICAgICAgICBzZXEuY29tbWVudCA9IHByb3BzLmNvbW1lbnQ7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgbm9kZSA9IHZhbHVlXG4gICAgICAgICAgICA/IGNvbXBvc2VOb2RlKGN0eCwgdmFsdWUsIHByb3BzLCBvbkVycm9yKVxuICAgICAgICAgICAgOiBjb21wb3NlRW1wdHlOb2RlKGN0eCwgb2Zmc2V0LCBzdGFydCwgbnVsbCwgcHJvcHMsIG9uRXJyb3IpO1xuICAgICAgICBpZiAoY3R4LnNjaGVtYS5jb21wYXQpXG4gICAgICAgICAgICBmbG93SW5kZW50Q2hlY2soYnMuaW5kZW50LCB2YWx1ZSwgb25FcnJvcik7XG4gICAgICAgIG9mZnNldCA9IG5vZGUucmFuZ2VbMl07XG4gICAgICAgIHNlcS5pdGVtcy5wdXNoKG5vZGUpO1xuICAgIH1cbiAgICBzZXEucmFuZ2UgPSBbYnMub2Zmc2V0LCBvZmZzZXQsIG9mZnNldF07XG4gICAgcmV0dXJuIHNlcTtcbn1cblxuZXhwb3J0IHsgcmVzb2x2ZUJsb2NrU2VxIH07XG4iLCAiZnVuY3Rpb24gcmVzb2x2ZUVuZChlbmQsIG9mZnNldCwgcmVxU3BhY2UsIG9uRXJyb3IpIHtcbiAgICBsZXQgY29tbWVudCA9ICcnO1xuICAgIGlmIChlbmQpIHtcbiAgICAgICAgbGV0IGhhc1NwYWNlID0gZmFsc2U7XG4gICAgICAgIGxldCBzZXAgPSAnJztcbiAgICAgICAgZm9yIChjb25zdCB0b2tlbiBvZiBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgc291cmNlLCB0eXBlIH0gPSB0b2tlbjtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3NwYWNlJzpcbiAgICAgICAgICAgICAgICAgICAgaGFzU3BhY2UgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdjb21tZW50Jzoge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVxU3BhY2UgJiYgIWhhc1NwYWNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgb25FcnJvcih0b2tlbiwgJ01JU1NJTkdfQ0hBUicsICdDb21tZW50cyBtdXN0IGJlIHNlcGFyYXRlZCBmcm9tIG90aGVyIHRva2VucyBieSB3aGl0ZSBzcGFjZSBjaGFyYWN0ZXJzJyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNiID0gc291cmNlLnN1YnN0cmluZygxKSB8fCAnICc7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY29tbWVudClcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1lbnQgPSBjYjtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgY29tbWVudCArPSBzZXAgKyBjYjtcbiAgICAgICAgICAgICAgICAgICAgc2VwID0gJyc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlICduZXdsaW5lJzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbW1lbnQpXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXAgKz0gc291cmNlO1xuICAgICAgICAgICAgICAgICAgICBoYXNTcGFjZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3IodG9rZW4sICdVTkVYUEVDVEVEX1RPS0VOJywgYFVuZXhwZWN0ZWQgJHt0eXBlfSBhdCBub2RlIGVuZGApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2Zmc2V0ICs9IHNvdXJjZS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgY29tbWVudCwgb2Zmc2V0IH07XG59XG5cbmV4cG9ydCB7IHJlc29sdmVFbmQgfTtcbiIsICJpbXBvcnQgeyBpc1BhaXIgfSBmcm9tICcuLi9ub2Rlcy9Ob2RlLmpzJztcbmltcG9ydCB7IFBhaXIgfSBmcm9tICcuLi9ub2Rlcy9QYWlyLmpzJztcbmltcG9ydCB7IFlBTUxNYXAgfSBmcm9tICcuLi9ub2Rlcy9ZQU1MTWFwLmpzJztcbmltcG9ydCB7IFlBTUxTZXEgfSBmcm9tICcuLi9ub2Rlcy9ZQU1MU2VxLmpzJztcbmltcG9ydCB7IHJlc29sdmVFbmQgfSBmcm9tICcuL3Jlc29sdmUtZW5kLmpzJztcbmltcG9ydCB7IHJlc29sdmVQcm9wcyB9IGZyb20gJy4vcmVzb2x2ZS1wcm9wcy5qcyc7XG5pbXBvcnQgeyBjb250YWluc05ld2xpbmUgfSBmcm9tICcuL3V0aWwtY29udGFpbnMtbmV3bGluZS5qcyc7XG5pbXBvcnQgeyBtYXBJbmNsdWRlcyB9IGZyb20gJy4vdXRpbC1tYXAtaW5jbHVkZXMuanMnO1xuXG5jb25zdCBibG9ja01zZyA9ICdCbG9jayBjb2xsZWN0aW9ucyBhcmUgbm90IGFsbG93ZWQgd2l0aGluIGZsb3cgY29sbGVjdGlvbnMnO1xuY29uc3QgaXNCbG9jayA9ICh0b2tlbikgPT4gdG9rZW4gJiYgKHRva2VuLnR5cGUgPT09ICdibG9jay1tYXAnIHx8IHRva2VuLnR5cGUgPT09ICdibG9jay1zZXEnKTtcbmZ1bmN0aW9uIHJlc29sdmVGbG93Q29sbGVjdGlvbih7IGNvbXBvc2VOb2RlLCBjb21wb3NlRW1wdHlOb2RlIH0sIGN0eCwgZmMsIG9uRXJyb3IpIHtcbiAgICBjb25zdCBpc01hcCA9IGZjLnN0YXJ0LnNvdXJjZSA9PT0gJ3snO1xuICAgIGNvbnN0IGZjTmFtZSA9IGlzTWFwID8gJ2Zsb3cgbWFwJyA6ICdmbG93IHNlcXVlbmNlJztcbiAgICBjb25zdCBjb2xsID0gaXNNYXBcbiAgICAgICAgPyBuZXcgWUFNTE1hcChjdHguc2NoZW1hKVxuICAgICAgICA6IG5ldyBZQU1MU2VxKGN0eC5zY2hlbWEpO1xuICAgIGNvbGwuZmxvdyA9IHRydWU7XG4gICAgY29uc3QgYXRSb290ID0gY3R4LmF0Um9vdDtcbiAgICBpZiAoYXRSb290KVxuICAgICAgICBjdHguYXRSb290ID0gZmFsc2U7XG4gICAgbGV0IG9mZnNldCA9IGZjLm9mZnNldCArIGZjLnN0YXJ0LnNvdXJjZS5sZW5ndGg7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmYy5pdGVtcy5sZW5ndGg7ICsraSkge1xuICAgICAgICBjb25zdCBjb2xsSXRlbSA9IGZjLml0ZW1zW2ldO1xuICAgICAgICBjb25zdCB7IHN0YXJ0LCBrZXksIHNlcCwgdmFsdWUgfSA9IGNvbGxJdGVtO1xuICAgICAgICBjb25zdCBwcm9wcyA9IHJlc29sdmVQcm9wcyhzdGFydCwge1xuICAgICAgICAgICAgZmxvdzogZmNOYW1lLFxuICAgICAgICAgICAgaW5kaWNhdG9yOiAnZXhwbGljaXQta2V5LWluZCcsXG4gICAgICAgICAgICBuZXh0OiBrZXkgfHwgKHNlcCA9PT0gbnVsbCB8fCBzZXAgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNlcFswXSksXG4gICAgICAgICAgICBvZmZzZXQsXG4gICAgICAgICAgICBvbkVycm9yLFxuICAgICAgICAgICAgc3RhcnRPbk5ld2xpbmU6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIXByb3BzLmZvdW5kKSB7XG4gICAgICAgICAgICBpZiAoIXByb3BzLmFuY2hvciAmJiAhcHJvcHMudGFnICYmICFzZXAgJiYgIXZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgPT09IDAgJiYgcHJvcHMuY29tbWEpXG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3IocHJvcHMuY29tbWEsICdVTkVYUEVDVEVEX1RPS0VOJywgYFVuZXhwZWN0ZWQgLCBpbiAke2ZjTmFtZX1gKTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpIDwgZmMuaXRlbXMubGVuZ3RoIC0gMSlcbiAgICAgICAgICAgICAgICAgICAgb25FcnJvcihwcm9wcy5zdGFydCwgJ1VORVhQRUNURURfVE9LRU4nLCBgVW5leHBlY3RlZCBlbXB0eSBpdGVtIGluICR7ZmNOYW1lfWApO1xuICAgICAgICAgICAgICAgIGlmIChwcm9wcy5jb21tZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb2xsLmNvbW1lbnQpXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xsLmNvbW1lbnQgKz0gJ1xcbicgKyBwcm9wcy5jb21tZW50O1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xsLmNvbW1lbnQgPSBwcm9wcy5jb21tZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvZmZzZXQgPSBwcm9wcy5lbmQ7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWlzTWFwICYmIGN0eC5vcHRpb25zLnN0cmljdCAmJiBjb250YWluc05ld2xpbmUoa2V5KSlcbiAgICAgICAgICAgICAgICBvbkVycm9yKGtleSwgLy8gY2hlY2tlZCBieSBjb250YWluc05ld2xpbmUoKVxuICAgICAgICAgICAgICAgICdNVUxUSUxJTkVfSU1QTElDSVRfS0VZJywgJ0ltcGxpY2l0IGtleXMgb2YgZmxvdyBzZXF1ZW5jZSBwYWlycyBuZWVkIHRvIGJlIG9uIGEgc2luZ2xlIGxpbmUnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgICAgaWYgKHByb3BzLmNvbW1hKVxuICAgICAgICAgICAgICAgIG9uRXJyb3IocHJvcHMuY29tbWEsICdVTkVYUEVDVEVEX1RPS0VOJywgYFVuZXhwZWN0ZWQgLCBpbiAke2ZjTmFtZX1gKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICghcHJvcHMuY29tbWEpXG4gICAgICAgICAgICAgICAgb25FcnJvcihwcm9wcy5zdGFydCwgJ01JU1NJTkdfQ0hBUicsIGBNaXNzaW5nICwgYmV0d2VlbiAke2ZjTmFtZX0gaXRlbXNgKTtcbiAgICAgICAgICAgIGlmIChwcm9wcy5jb21tZW50KSB7XG4gICAgICAgICAgICAgICAgbGV0IHByZXZJdGVtQ29tbWVudCA9ICcnO1xuICAgICAgICAgICAgICAgIGxvb3A6IGZvciAoY29uc3Qgc3Qgb2Ygc3RhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChzdC50eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdjb21tYSc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdzcGFjZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdjb21tZW50JzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmV2SXRlbUNvbW1lbnQgPSBzdC5zb3VyY2Uuc3Vic3RyaW5nKDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIGxvb3A7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIGxvb3A7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHByZXZJdGVtQ29tbWVudCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcHJldiA9IGNvbGwuaXRlbXNbY29sbC5pdGVtcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzUGFpcihwcmV2KSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXYgPSBwcmV2LnZhbHVlIHx8IHByZXYua2V5O1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJldi5jb21tZW50KVxuICAgICAgICAgICAgICAgICAgICAgICAgcHJldi5jb21tZW50ICs9ICdcXG4nICsgcHJldkl0ZW1Db21tZW50O1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2LmNvbW1lbnQgPSBwcmV2SXRlbUNvbW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgIHByb3BzLmNvbW1lbnQgPSBwcm9wcy5jb21tZW50LnN1YnN0cmluZyhwcmV2SXRlbUNvbW1lbnQubGVuZ3RoICsgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghaXNNYXAgJiYgIXNlcCAmJiAhcHJvcHMuZm91bmQpIHtcbiAgICAgICAgICAgIC8vIGl0ZW0gaXMgYSB2YWx1ZSBpbiBhIHNlcVxuICAgICAgICAgICAgLy8gXHUyMTkyIGtleSAmIHNlcCBhcmUgZW1wdHksIHN0YXJ0IGRvZXMgbm90IGluY2x1ZGUgPyBvciA6XG4gICAgICAgICAgICBjb25zdCB2YWx1ZU5vZGUgPSB2YWx1ZVxuICAgICAgICAgICAgICAgID8gY29tcG9zZU5vZGUoY3R4LCB2YWx1ZSwgcHJvcHMsIG9uRXJyb3IpXG4gICAgICAgICAgICAgICAgOiBjb21wb3NlRW1wdHlOb2RlKGN0eCwgcHJvcHMuZW5kLCBzZXAsIG51bGwsIHByb3BzLCBvbkVycm9yKTtcbiAgICAgICAgICAgIGNvbGwuaXRlbXMucHVzaCh2YWx1ZU5vZGUpO1xuICAgICAgICAgICAgb2Zmc2V0ID0gdmFsdWVOb2RlLnJhbmdlWzJdO1xuICAgICAgICAgICAgaWYgKGlzQmxvY2sodmFsdWUpKVxuICAgICAgICAgICAgICAgIG9uRXJyb3IodmFsdWVOb2RlLnJhbmdlLCAnQkxPQ0tfSU5fRkxPVycsIGJsb2NrTXNnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGl0ZW0gaXMgYSBrZXkrdmFsdWUgcGFpclxuICAgICAgICAgICAgLy8ga2V5IHZhbHVlXG4gICAgICAgICAgICBjb25zdCBrZXlTdGFydCA9IHByb3BzLmVuZDtcbiAgICAgICAgICAgIGNvbnN0IGtleU5vZGUgPSBrZXlcbiAgICAgICAgICAgICAgICA/IGNvbXBvc2VOb2RlKGN0eCwga2V5LCBwcm9wcywgb25FcnJvcilcbiAgICAgICAgICAgICAgICA6IGNvbXBvc2VFbXB0eU5vZGUoY3R4LCBrZXlTdGFydCwgc3RhcnQsIG51bGwsIHByb3BzLCBvbkVycm9yKTtcbiAgICAgICAgICAgIGlmIChpc0Jsb2NrKGtleSkpXG4gICAgICAgICAgICAgICAgb25FcnJvcihrZXlOb2RlLnJhbmdlLCAnQkxPQ0tfSU5fRkxPVycsIGJsb2NrTXNnKTtcbiAgICAgICAgICAgIC8vIHZhbHVlIHByb3BlcnRpZXNcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlUHJvcHMgPSByZXNvbHZlUHJvcHMoc2VwIHx8IFtdLCB7XG4gICAgICAgICAgICAgICAgZmxvdzogZmNOYW1lLFxuICAgICAgICAgICAgICAgIGluZGljYXRvcjogJ21hcC12YWx1ZS1pbmQnLFxuICAgICAgICAgICAgICAgIG5leHQ6IHZhbHVlLFxuICAgICAgICAgICAgICAgIG9mZnNldDoga2V5Tm9kZS5yYW5nZVsyXSxcbiAgICAgICAgICAgICAgICBvbkVycm9yLFxuICAgICAgICAgICAgICAgIHN0YXJ0T25OZXdsaW5lOiBmYWxzZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAodmFsdWVQcm9wcy5mb3VuZCkge1xuICAgICAgICAgICAgICAgIGlmICghaXNNYXAgJiYgIXByb3BzLmZvdW5kICYmIGN0eC5vcHRpb25zLnN0cmljdCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VwKVxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBzdCBvZiBzZXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3QgPT09IHZhbHVlUHJvcHMuZm91bmQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdC50eXBlID09PSAnbmV3bGluZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25FcnJvcihzdCwgJ01VTFRJTElORV9JTVBMSUNJVF9LRVknLCAnSW1wbGljaXQga2V5cyBvZiBmbG93IHNlcXVlbmNlIHBhaXJzIG5lZWQgdG8gYmUgb24gYSBzaW5nbGUgbGluZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9wcy5zdGFydCA8IHZhbHVlUHJvcHMuZm91bmQub2Zmc2V0IC0gMTAyNClcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uRXJyb3IodmFsdWVQcm9wcy5mb3VuZCwgJ0tFWV9PVkVSXzEwMjRfQ0hBUlMnLCAnVGhlIDogaW5kaWNhdG9yIG11c3QgYmUgYXQgbW9zdCAxMDI0IGNoYXJzIGFmdGVyIHRoZSBzdGFydCBvZiBhbiBpbXBsaWNpdCBmbG93IHNlcXVlbmNlIGtleScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCdzb3VyY2UnIGluIHZhbHVlICYmIHZhbHVlLnNvdXJjZSAmJiB2YWx1ZS5zb3VyY2VbMF0gPT09ICc6JylcbiAgICAgICAgICAgICAgICAgICAgb25FcnJvcih2YWx1ZSwgJ01JU1NJTkdfQ0hBUicsIGBNaXNzaW5nIHNwYWNlIGFmdGVyIDogaW4gJHtmY05hbWV9YCk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBvbkVycm9yKHZhbHVlUHJvcHMuc3RhcnQsICdNSVNTSU5HX0NIQVInLCBgTWlzc2luZyAsIG9yIDogYmV0d2VlbiAke2ZjTmFtZX0gaXRlbXNgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHZhbHVlIHZhbHVlXG4gICAgICAgICAgICBjb25zdCB2YWx1ZU5vZGUgPSB2YWx1ZVxuICAgICAgICAgICAgICAgID8gY29tcG9zZU5vZGUoY3R4LCB2YWx1ZSwgdmFsdWVQcm9wcywgb25FcnJvcilcbiAgICAgICAgICAgICAgICA6IHZhbHVlUHJvcHMuZm91bmRcbiAgICAgICAgICAgICAgICAgICAgPyBjb21wb3NlRW1wdHlOb2RlKGN0eCwgdmFsdWVQcm9wcy5lbmQsIHNlcCwgbnVsbCwgdmFsdWVQcm9wcywgb25FcnJvcilcbiAgICAgICAgICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICAgICAgaWYgKHZhbHVlTm9kZSkge1xuICAgICAgICAgICAgICAgIGlmIChpc0Jsb2NrKHZhbHVlKSlcbiAgICAgICAgICAgICAgICAgICAgb25FcnJvcih2YWx1ZU5vZGUucmFuZ2UsICdCTE9DS19JTl9GTE9XJywgYmxvY2tNc2cpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWVQcm9wcy5jb21tZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKGtleU5vZGUuY29tbWVudClcbiAgICAgICAgICAgICAgICAgICAga2V5Tm9kZS5jb21tZW50ICs9ICdcXG4nICsgdmFsdWVQcm9wcy5jb21tZW50O1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAga2V5Tm9kZS5jb21tZW50ID0gdmFsdWVQcm9wcy5jb21tZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcGFpciA9IG5ldyBQYWlyKGtleU5vZGUsIHZhbHVlTm9kZSk7XG4gICAgICAgICAgICBpZiAoY3R4Lm9wdGlvbnMua2VlcFNvdXJjZVRva2VucylcbiAgICAgICAgICAgICAgICBwYWlyLnNyY1Rva2VuID0gY29sbEl0ZW07XG4gICAgICAgICAgICBpZiAoaXNNYXApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXAgPSBjb2xsO1xuICAgICAgICAgICAgICAgIGlmIChtYXBJbmNsdWRlcyhjdHgsIG1hcC5pdGVtcywga2V5Tm9kZSkpXG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3Ioa2V5U3RhcnQsICdEVVBMSUNBVEVfS0VZJywgJ01hcCBrZXlzIG11c3QgYmUgdW5pcXVlJyk7XG4gICAgICAgICAgICAgICAgbWFwLml0ZW1zLnB1c2gocGFpcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXAgPSBuZXcgWUFNTE1hcChjdHguc2NoZW1hKTtcbiAgICAgICAgICAgICAgICBtYXAuZmxvdyA9IHRydWU7XG4gICAgICAgICAgICAgICAgbWFwLml0ZW1zLnB1c2gocGFpcik7XG4gICAgICAgICAgICAgICAgY29sbC5pdGVtcy5wdXNoKG1hcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvZmZzZXQgPSB2YWx1ZU5vZGUgPyB2YWx1ZU5vZGUucmFuZ2VbMl0gOiB2YWx1ZVByb3BzLmVuZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBleHBlY3RlZEVuZCA9IGlzTWFwID8gJ30nIDogJ10nO1xuICAgIGNvbnN0IFtjZSwgLi4uZWVdID0gZmMuZW5kO1xuICAgIGxldCBjZVBvcyA9IG9mZnNldDtcbiAgICBpZiAoY2UgJiYgY2Uuc291cmNlID09PSBleHBlY3RlZEVuZClcbiAgICAgICAgY2VQb3MgPSBjZS5vZmZzZXQgKyBjZS5zb3VyY2UubGVuZ3RoO1xuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBuYW1lID0gZmNOYW1lWzBdLnRvVXBwZXJDYXNlKCkgKyBmY05hbWUuc3Vic3RyaW5nKDEpO1xuICAgICAgICBjb25zdCBtc2cgPSBhdFJvb3RcbiAgICAgICAgICAgID8gYCR7bmFtZX0gbXVzdCBlbmQgd2l0aCBhICR7ZXhwZWN0ZWRFbmR9YFxuICAgICAgICAgICAgOiBgJHtuYW1lfSBpbiBibG9jayBjb2xsZWN0aW9uIG11c3QgYmUgc3VmZmljaWVudGx5IGluZGVudGVkIGFuZCBlbmQgd2l0aCBhICR7ZXhwZWN0ZWRFbmR9YDtcbiAgICAgICAgb25FcnJvcihvZmZzZXQsIGF0Um9vdCA/ICdNSVNTSU5HX0NIQVInIDogJ0JBRF9JTkRFTlQnLCBtc2cpO1xuICAgICAgICBpZiAoY2UgJiYgY2Uuc291cmNlLmxlbmd0aCAhPT0gMSlcbiAgICAgICAgICAgIGVlLnVuc2hpZnQoY2UpO1xuICAgIH1cbiAgICBpZiAoZWUubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCBlbmQgPSByZXNvbHZlRW5kKGVlLCBjZVBvcywgY3R4Lm9wdGlvbnMuc3RyaWN0LCBvbkVycm9yKTtcbiAgICAgICAgaWYgKGVuZC5jb21tZW50KSB7XG4gICAgICAgICAgICBpZiAoY29sbC5jb21tZW50KVxuICAgICAgICAgICAgICAgIGNvbGwuY29tbWVudCArPSAnXFxuJyArIGVuZC5jb21tZW50O1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGNvbGwuY29tbWVudCA9IGVuZC5jb21tZW50O1xuICAgICAgICB9XG4gICAgICAgIGNvbGwucmFuZ2UgPSBbZmMub2Zmc2V0LCBjZVBvcywgZW5kLm9mZnNldF07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb2xsLnJhbmdlID0gW2ZjLm9mZnNldCwgY2VQb3MsIGNlUG9zXTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbGw7XG59XG5cbmV4cG9ydCB7IHJlc29sdmVGbG93Q29sbGVjdGlvbiB9O1xuIiwgImltcG9ydCB7IGlzTm9kZSwgaXNNYXAgfSBmcm9tICcuLi9ub2Rlcy9Ob2RlLmpzJztcbmltcG9ydCB7IFNjYWxhciB9IGZyb20gJy4uL25vZGVzL1NjYWxhci5qcyc7XG5pbXBvcnQgeyByZXNvbHZlQmxvY2tNYXAgfSBmcm9tICcuL3Jlc29sdmUtYmxvY2stbWFwLmpzJztcbmltcG9ydCB7IHJlc29sdmVCbG9ja1NlcSB9IGZyb20gJy4vcmVzb2x2ZS1ibG9jay1zZXEuanMnO1xuaW1wb3J0IHsgcmVzb2x2ZUZsb3dDb2xsZWN0aW9uIH0gZnJvbSAnLi9yZXNvbHZlLWZsb3ctY29sbGVjdGlvbi5qcyc7XG5cbmZ1bmN0aW9uIGNvbXBvc2VDb2xsZWN0aW9uKENOLCBjdHgsIHRva2VuLCB0YWdUb2tlbiwgb25FcnJvcikge1xuICAgIGxldCBjb2xsO1xuICAgIHN3aXRjaCAodG9rZW4udHlwZSkge1xuICAgICAgICBjYXNlICdibG9jay1tYXAnOiB7XG4gICAgICAgICAgICBjb2xsID0gcmVzb2x2ZUJsb2NrTWFwKENOLCBjdHgsIHRva2VuLCBvbkVycm9yKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ2Jsb2NrLXNlcSc6IHtcbiAgICAgICAgICAgIGNvbGwgPSByZXNvbHZlQmxvY2tTZXEoQ04sIGN0eCwgdG9rZW4sIG9uRXJyb3IpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnZmxvdy1jb2xsZWN0aW9uJzoge1xuICAgICAgICAgICAgY29sbCA9IHJlc29sdmVGbG93Q29sbGVjdGlvbihDTiwgY3R4LCB0b2tlbiwgb25FcnJvcik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXRhZ1Rva2VuKVxuICAgICAgICByZXR1cm4gY29sbDtcbiAgICBjb25zdCB0YWdOYW1lID0gY3R4LmRpcmVjdGl2ZXMudGFnTmFtZSh0YWdUb2tlbi5zb3VyY2UsIG1zZyA9PiBvbkVycm9yKHRhZ1Rva2VuLCAnVEFHX1JFU09MVkVfRkFJTEVEJywgbXNnKSk7XG4gICAgaWYgKCF0YWdOYW1lKVxuICAgICAgICByZXR1cm4gY29sbDtcbiAgICAvLyBDYXN0IG5lZWRlZCBkdWUgdG86IGh0dHBzOi8vZ2l0aHViLmNvbS9NaWNyb3NvZnQvVHlwZVNjcmlwdC9pc3N1ZXMvMzg0MVxuICAgIGNvbnN0IENvbGwgPSBjb2xsLmNvbnN0cnVjdG9yO1xuICAgIGlmICh0YWdOYW1lID09PSAnIScgfHwgdGFnTmFtZSA9PT0gQ29sbC50YWdOYW1lKSB7XG4gICAgICAgIGNvbGwudGFnID0gQ29sbC50YWdOYW1lO1xuICAgICAgICByZXR1cm4gY29sbDtcbiAgICB9XG4gICAgY29uc3QgZXhwVHlwZSA9IGlzTWFwKGNvbGwpID8gJ21hcCcgOiAnc2VxJztcbiAgICBsZXQgdGFnID0gY3R4LnNjaGVtYS50YWdzLmZpbmQodCA9PiB0LmNvbGxlY3Rpb24gPT09IGV4cFR5cGUgJiYgdC50YWcgPT09IHRhZ05hbWUpO1xuICAgIGlmICghdGFnKSB7XG4gICAgICAgIGNvbnN0IGt0ID0gY3R4LnNjaGVtYS5rbm93blRhZ3NbdGFnTmFtZV07XG4gICAgICAgIGlmIChrdCAmJiBrdC5jb2xsZWN0aW9uID09PSBleHBUeXBlKSB7XG4gICAgICAgICAgICBjdHguc2NoZW1hLnRhZ3MucHVzaChPYmplY3QuYXNzaWduKHt9LCBrdCwgeyBkZWZhdWx0OiBmYWxzZSB9KSk7XG4gICAgICAgICAgICB0YWcgPSBrdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9uRXJyb3IodGFnVG9rZW4sICdUQUdfUkVTT0xWRV9GQUlMRUQnLCBgVW5yZXNvbHZlZCB0YWc6ICR7dGFnTmFtZX1gLCB0cnVlKTtcbiAgICAgICAgICAgIGNvbGwudGFnID0gdGFnTmFtZTtcbiAgICAgICAgICAgIHJldHVybiBjb2xsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHJlcyA9IHRhZy5yZXNvbHZlKGNvbGwsIG1zZyA9PiBvbkVycm9yKHRhZ1Rva2VuLCAnVEFHX1JFU09MVkVfRkFJTEVEJywgbXNnKSwgY3R4Lm9wdGlvbnMpO1xuICAgIGNvbnN0IG5vZGUgPSBpc05vZGUocmVzKVxuICAgICAgICA/IHJlc1xuICAgICAgICA6IG5ldyBTY2FsYXIocmVzKTtcbiAgICBub2RlLnJhbmdlID0gY29sbC5yYW5nZTtcbiAgICBub2RlLnRhZyA9IHRhZ05hbWU7XG4gICAgaWYgKHRhZyA9PT0gbnVsbCB8fCB0YWcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRhZy5mb3JtYXQpXG4gICAgICAgIG5vZGUuZm9ybWF0ID0gdGFnLmZvcm1hdDtcbiAgICByZXR1cm4gbm9kZTtcbn1cblxuZXhwb3J0IHsgY29tcG9zZUNvbGxlY3Rpb24gfTtcbiIsICJpbXBvcnQgeyBTY2FsYXIgfSBmcm9tICcuLi9ub2Rlcy9TY2FsYXIuanMnO1xuXG5mdW5jdGlvbiByZXNvbHZlQmxvY2tTY2FsYXIoc2NhbGFyLCBzdHJpY3QsIG9uRXJyb3IpIHtcbiAgICBjb25zdCBzdGFydCA9IHNjYWxhci5vZmZzZXQ7XG4gICAgY29uc3QgaGVhZGVyID0gcGFyc2VCbG9ja1NjYWxhckhlYWRlcihzY2FsYXIsIHN0cmljdCwgb25FcnJvcik7XG4gICAgaWYgKCFoZWFkZXIpXG4gICAgICAgIHJldHVybiB7IHZhbHVlOiAnJywgdHlwZTogbnVsbCwgY29tbWVudDogJycsIHJhbmdlOiBbc3RhcnQsIHN0YXJ0LCBzdGFydF0gfTtcbiAgICBjb25zdCB0eXBlID0gaGVhZGVyLm1vZGUgPT09ICc+JyA/IFNjYWxhci5CTE9DS19GT0xERUQgOiBTY2FsYXIuQkxPQ0tfTElURVJBTDtcbiAgICBjb25zdCBsaW5lcyA9IHNjYWxhci5zb3VyY2UgPyBzcGxpdExpbmVzKHNjYWxhci5zb3VyY2UpIDogW107XG4gICAgLy8gZGV0ZXJtaW5lIHRoZSBlbmQgb2YgY29udGVudCAmIHN0YXJ0IG9mIGNob21waW5nXG4gICAgbGV0IGNob21wU3RhcnQgPSBsaW5lcy5sZW5ndGg7XG4gICAgZm9yIChsZXQgaSA9IGxpbmVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIGNvbnN0IGNvbnRlbnQgPSBsaW5lc1tpXVsxXTtcbiAgICAgICAgaWYgKGNvbnRlbnQgPT09ICcnIHx8IGNvbnRlbnQgPT09ICdcXHInKVxuICAgICAgICAgICAgY2hvbXBTdGFydCA9IGk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICAvLyBzaG9ydGN1dCBmb3IgZW1wdHkgY29udGVudHNcbiAgICBpZiAoIXNjYWxhci5zb3VyY2UgfHwgY2hvbXBTdGFydCA9PT0gMCkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGhlYWRlci5jaG9tcCA9PT0gJysnID8gJ1xcbicucmVwZWF0KE1hdGgubWF4KDAsIGxpbmVzLmxlbmd0aCAtIDEpKSA6ICcnO1xuICAgICAgICBsZXQgZW5kID0gc3RhcnQgKyBoZWFkZXIubGVuZ3RoO1xuICAgICAgICBpZiAoc2NhbGFyLnNvdXJjZSlcbiAgICAgICAgICAgIGVuZCArPSBzY2FsYXIuc291cmNlLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHsgdmFsdWUsIHR5cGUsIGNvbW1lbnQ6IGhlYWRlci5jb21tZW50LCByYW5nZTogW3N0YXJ0LCBlbmQsIGVuZF0gfTtcbiAgICB9XG4gICAgLy8gZmluZCB0aGUgaW5kZW50YXRpb24gbGV2ZWwgdG8gdHJpbSBmcm9tIHN0YXJ0XG4gICAgbGV0IHRyaW1JbmRlbnQgPSBzY2FsYXIuaW5kZW50ICsgaGVhZGVyLmluZGVudDtcbiAgICBsZXQgb2Zmc2V0ID0gc2NhbGFyLm9mZnNldCArIGhlYWRlci5sZW5ndGg7XG4gICAgbGV0IGNvbnRlbnRTdGFydCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaG9tcFN0YXJ0OyArK2kpIHtcbiAgICAgICAgY29uc3QgW2luZGVudCwgY29udGVudF0gPSBsaW5lc1tpXTtcbiAgICAgICAgaWYgKGNvbnRlbnQgPT09ICcnIHx8IGNvbnRlbnQgPT09ICdcXHInKSB7XG4gICAgICAgICAgICBpZiAoaGVhZGVyLmluZGVudCA9PT0gMCAmJiBpbmRlbnQubGVuZ3RoID4gdHJpbUluZGVudClcbiAgICAgICAgICAgICAgICB0cmltSW5kZW50ID0gaW5kZW50Lmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChpbmRlbnQubGVuZ3RoIDwgdHJpbUluZGVudCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSAnQmxvY2sgc2NhbGFycyB3aXRoIG1vcmUtaW5kZW50ZWQgbGVhZGluZyBlbXB0eSBsaW5lcyBtdXN0IHVzZSBhbiBleHBsaWNpdCBpbmRlbnRhdGlvbiBpbmRpY2F0b3InO1xuICAgICAgICAgICAgICAgIG9uRXJyb3Iob2Zmc2V0ICsgaW5kZW50Lmxlbmd0aCwgJ01JU1NJTkdfQ0hBUicsIG1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGhlYWRlci5pbmRlbnQgPT09IDApXG4gICAgICAgICAgICAgICAgdHJpbUluZGVudCA9IGluZGVudC5sZW5ndGg7XG4gICAgICAgICAgICBjb250ZW50U3RhcnQgPSBpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgb2Zmc2V0ICs9IGluZGVudC5sZW5ndGggKyBjb250ZW50Lmxlbmd0aCArIDE7XG4gICAgfVxuICAgIGxldCB2YWx1ZSA9ICcnO1xuICAgIGxldCBzZXAgPSAnJztcbiAgICBsZXQgcHJldk1vcmVJbmRlbnRlZCA9IGZhbHNlO1xuICAgIC8vIGxlYWRpbmcgd2hpdGVzcGFjZSBpcyBrZXB0IGludGFjdFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29udGVudFN0YXJ0OyArK2kpXG4gICAgICAgIHZhbHVlICs9IGxpbmVzW2ldWzBdLnNsaWNlKHRyaW1JbmRlbnQpICsgJ1xcbic7XG4gICAgZm9yIChsZXQgaSA9IGNvbnRlbnRTdGFydDsgaSA8IGNob21wU3RhcnQ7ICsraSkge1xuICAgICAgICBsZXQgW2luZGVudCwgY29udGVudF0gPSBsaW5lc1tpXTtcbiAgICAgICAgb2Zmc2V0ICs9IGluZGVudC5sZW5ndGggKyBjb250ZW50Lmxlbmd0aCArIDE7XG4gICAgICAgIGNvbnN0IGNybGYgPSBjb250ZW50W2NvbnRlbnQubGVuZ3RoIC0gMV0gPT09ICdcXHInO1xuICAgICAgICBpZiAoY3JsZilcbiAgICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50LnNsaWNlKDAsIC0xKTtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmIGFscmVhZHkgY2F1Z2h0IGluIGxleGVyICovXG4gICAgICAgIGlmIChjb250ZW50ICYmIGluZGVudC5sZW5ndGggPCB0cmltSW5kZW50KSB7XG4gICAgICAgICAgICBjb25zdCBzcmMgPSBoZWFkZXIuaW5kZW50XG4gICAgICAgICAgICAgICAgPyAnZXhwbGljaXQgaW5kZW50YXRpb24gaW5kaWNhdG9yJ1xuICAgICAgICAgICAgICAgIDogJ2ZpcnN0IGxpbmUnO1xuICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IGBCbG9jayBzY2FsYXIgbGluZXMgbXVzdCBub3QgYmUgbGVzcyBpbmRlbnRlZCB0aGFuIHRoZWlyICR7c3JjfWA7XG4gICAgICAgICAgICBvbkVycm9yKG9mZnNldCAtIGNvbnRlbnQubGVuZ3RoIC0gKGNybGYgPyAyIDogMSksICdCQURfSU5ERU5UJywgbWVzc2FnZSk7XG4gICAgICAgICAgICBpbmRlbnQgPSAnJztcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZSA9PT0gU2NhbGFyLkJMT0NLX0xJVEVSQUwpIHtcbiAgICAgICAgICAgIHZhbHVlICs9IHNlcCArIGluZGVudC5zbGljZSh0cmltSW5kZW50KSArIGNvbnRlbnQ7XG4gICAgICAgICAgICBzZXAgPSAnXFxuJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpbmRlbnQubGVuZ3RoID4gdHJpbUluZGVudCB8fCBjb250ZW50WzBdID09PSAnXFx0Jykge1xuICAgICAgICAgICAgLy8gbW9yZS1pbmRlbnRlZCBjb250ZW50IHdpdGhpbiBhIGZvbGRlZCBibG9ja1xuICAgICAgICAgICAgaWYgKHNlcCA9PT0gJyAnKVxuICAgICAgICAgICAgICAgIHNlcCA9ICdcXG4nO1xuICAgICAgICAgICAgZWxzZSBpZiAoIXByZXZNb3JlSW5kZW50ZWQgJiYgc2VwID09PSAnXFxuJylcbiAgICAgICAgICAgICAgICBzZXAgPSAnXFxuXFxuJztcbiAgICAgICAgICAgIHZhbHVlICs9IHNlcCArIGluZGVudC5zbGljZSh0cmltSW5kZW50KSArIGNvbnRlbnQ7XG4gICAgICAgICAgICBzZXAgPSAnXFxuJztcbiAgICAgICAgICAgIHByZXZNb3JlSW5kZW50ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvbnRlbnQgPT09ICcnKSB7XG4gICAgICAgICAgICAvLyBlbXB0eSBsaW5lXG4gICAgICAgICAgICBpZiAoc2VwID09PSAnXFxuJylcbiAgICAgICAgICAgICAgICB2YWx1ZSArPSAnXFxuJztcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBzZXAgPSAnXFxuJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhbHVlICs9IHNlcCArIGNvbnRlbnQ7XG4gICAgICAgICAgICBzZXAgPSAnICc7XG4gICAgICAgICAgICBwcmV2TW9yZUluZGVudGVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3dpdGNoIChoZWFkZXIuY2hvbXApIHtcbiAgICAgICAgY2FzZSAnLSc6XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnKyc6XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gY2hvbXBTdGFydDsgaSA8IGxpbmVzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgIHZhbHVlICs9ICdcXG4nICsgbGluZXNbaV1bMF0uc2xpY2UodHJpbUluZGVudCk7XG4gICAgICAgICAgICBpZiAodmFsdWVbdmFsdWUubGVuZ3RoIC0gMV0gIT09ICdcXG4nKVxuICAgICAgICAgICAgICAgIHZhbHVlICs9ICdcXG4nO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB2YWx1ZSArPSAnXFxuJztcbiAgICB9XG4gICAgY29uc3QgZW5kID0gc3RhcnQgKyBoZWFkZXIubGVuZ3RoICsgc2NhbGFyLnNvdXJjZS5sZW5ndGg7XG4gICAgcmV0dXJuIHsgdmFsdWUsIHR5cGUsIGNvbW1lbnQ6IGhlYWRlci5jb21tZW50LCByYW5nZTogW3N0YXJ0LCBlbmQsIGVuZF0gfTtcbn1cbmZ1bmN0aW9uIHBhcnNlQmxvY2tTY2FsYXJIZWFkZXIoeyBvZmZzZXQsIHByb3BzIH0sIHN0cmljdCwgb25FcnJvcikge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiBzaG91bGQgbm90IGhhcHBlbiAqL1xuICAgIGlmIChwcm9wc1swXS50eXBlICE9PSAnYmxvY2stc2NhbGFyLWhlYWRlcicpIHtcbiAgICAgICAgb25FcnJvcihwcm9wc1swXSwgJ0lNUE9TU0lCTEUnLCAnQmxvY2sgc2NhbGFyIGhlYWRlciBub3QgZm91bmQnKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHsgc291cmNlIH0gPSBwcm9wc1swXTtcbiAgICBjb25zdCBtb2RlID0gc291cmNlWzBdO1xuICAgIGxldCBpbmRlbnQgPSAwO1xuICAgIGxldCBjaG9tcCA9ICcnO1xuICAgIGxldCBlcnJvciA9IC0xO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgc291cmNlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IGNoID0gc291cmNlW2ldO1xuICAgICAgICBpZiAoIWNob21wICYmIChjaCA9PT0gJy0nIHx8IGNoID09PSAnKycpKVxuICAgICAgICAgICAgY2hvbXAgPSBjaDtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBuID0gTnVtYmVyKGNoKTtcbiAgICAgICAgICAgIGlmICghaW5kZW50ICYmIG4pXG4gICAgICAgICAgICAgICAgaW5kZW50ID0gbjtcbiAgICAgICAgICAgIGVsc2UgaWYgKGVycm9yID09PSAtMSlcbiAgICAgICAgICAgICAgICBlcnJvciA9IG9mZnNldCArIGk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGVycm9yICE9PSAtMSlcbiAgICAgICAgb25FcnJvcihlcnJvciwgJ1VORVhQRUNURURfVE9LRU4nLCBgQmxvY2sgc2NhbGFyIGhlYWRlciBpbmNsdWRlcyBleHRyYSBjaGFyYWN0ZXJzOiAke3NvdXJjZX1gKTtcbiAgICBsZXQgaGFzU3BhY2UgPSBmYWxzZTtcbiAgICBsZXQgY29tbWVudCA9ICcnO1xuICAgIGxldCBsZW5ndGggPSBzb3VyY2UubGVuZ3RoO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgcHJvcHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29uc3QgdG9rZW4gPSBwcm9wc1tpXTtcbiAgICAgICAgc3dpdGNoICh0b2tlbi50eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdzcGFjZSc6XG4gICAgICAgICAgICAgICAgaGFzU3BhY2UgPSB0cnVlO1xuICAgICAgICAgICAgLy8gZmFsbHRocm91Z2hcbiAgICAgICAgICAgIGNhc2UgJ25ld2xpbmUnOlxuICAgICAgICAgICAgICAgIGxlbmd0aCArPSB0b2tlbi5zb3VyY2UubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnY29tbWVudCc6XG4gICAgICAgICAgICAgICAgaWYgKHN0cmljdCAmJiAhaGFzU3BhY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9ICdDb21tZW50cyBtdXN0IGJlIHNlcGFyYXRlZCBmcm9tIG90aGVyIHRva2VucyBieSB3aGl0ZSBzcGFjZSBjaGFyYWN0ZXJzJztcbiAgICAgICAgICAgICAgICAgICAgb25FcnJvcih0b2tlbiwgJ01JU1NJTkdfQ0hBUicsIG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZW5ndGggKz0gdG9rZW4uc291cmNlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBjb21tZW50ID0gdG9rZW4uc291cmNlLnN1YnN0cmluZygxKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2Vycm9yJzpcbiAgICAgICAgICAgICAgICBvbkVycm9yKHRva2VuLCAnVU5FWFBFQ1RFRF9UT0tFTicsIHRva2VuLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIGxlbmd0aCArPSB0b2tlbi5zb3VyY2UubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgc2hvdWxkIG5vdCBoYXBwZW4gKi9cbiAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gYFVuZXhwZWN0ZWQgdG9rZW4gaW4gYmxvY2sgc2NhbGFyIGhlYWRlcjogJHt0b2tlbi50eXBlfWA7XG4gICAgICAgICAgICAgICAgb25FcnJvcih0b2tlbiwgJ1VORVhQRUNURURfVE9LRU4nLCBtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0cyA9IHRva2VuLnNvdXJjZTtcbiAgICAgICAgICAgICAgICBpZiAodHMgJiYgdHlwZW9mIHRzID09PSAnc3RyaW5nJylcbiAgICAgICAgICAgICAgICAgICAgbGVuZ3RoICs9IHRzLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBtb2RlLCBpbmRlbnQsIGNob21wLCBjb21tZW50LCBsZW5ndGggfTtcbn1cbi8qKiBAcmV0dXJucyBBcnJheSBvZiBsaW5lcyBzcGxpdCB1cCBhcyBgW2luZGVudCwgY29udGVudF1gICovXG5mdW5jdGlvbiBzcGxpdExpbmVzKHNvdXJjZSkge1xuICAgIGNvbnN0IHNwbGl0ID0gc291cmNlLnNwbGl0KC9cXG4oICopLyk7XG4gICAgY29uc3QgZmlyc3QgPSBzcGxpdFswXTtcbiAgICBjb25zdCBtID0gZmlyc3QubWF0Y2goL14oICopLyk7XG4gICAgY29uc3QgbGluZTAgPSBtICYmIG1bMV0gPyBbbVsxXSwgZmlyc3Quc2xpY2UobVsxXS5sZW5ndGgpXSA6IFsnJywgZmlyc3RdO1xuICAgIGNvbnN0IGxpbmVzID0gW2xpbmUwXTtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IHNwbGl0Lmxlbmd0aDsgaSArPSAyKVxuICAgICAgICBsaW5lcy5wdXNoKFtzcGxpdFtpXSwgc3BsaXRbaSArIDFdXSk7XG4gICAgcmV0dXJuIGxpbmVzO1xufVxuXG5leHBvcnQgeyByZXNvbHZlQmxvY2tTY2FsYXIgfTtcbiIsICJpbXBvcnQgeyBTY2FsYXIgfSBmcm9tICcuLi9ub2Rlcy9TY2FsYXIuanMnO1xuaW1wb3J0IHsgcmVzb2x2ZUVuZCB9IGZyb20gJy4vcmVzb2x2ZS1lbmQuanMnO1xuXG5mdW5jdGlvbiByZXNvbHZlRmxvd1NjYWxhcihzY2FsYXIsIHN0cmljdCwgb25FcnJvcikge1xuICAgIGNvbnN0IHsgb2Zmc2V0LCB0eXBlLCBzb3VyY2UsIGVuZCB9ID0gc2NhbGFyO1xuICAgIGxldCBfdHlwZTtcbiAgICBsZXQgdmFsdWU7XG4gICAgY29uc3QgX29uRXJyb3IgPSAocmVsLCBjb2RlLCBtc2cpID0+IG9uRXJyb3Iob2Zmc2V0ICsgcmVsLCBjb2RlLCBtc2cpO1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlICdzY2FsYXInOlxuICAgICAgICAgICAgX3R5cGUgPSBTY2FsYXIuUExBSU47XG4gICAgICAgICAgICB2YWx1ZSA9IHBsYWluVmFsdWUoc291cmNlLCBfb25FcnJvcik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnc2luZ2xlLXF1b3RlZC1zY2FsYXInOlxuICAgICAgICAgICAgX3R5cGUgPSBTY2FsYXIuUVVPVEVfU0lOR0xFO1xuICAgICAgICAgICAgdmFsdWUgPSBzaW5nbGVRdW90ZWRWYWx1ZShzb3VyY2UsIF9vbkVycm9yKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdkb3VibGUtcXVvdGVkLXNjYWxhcic6XG4gICAgICAgICAgICBfdHlwZSA9IFNjYWxhci5RVU9URV9ET1VCTEU7XG4gICAgICAgICAgICB2YWx1ZSA9IGRvdWJsZVF1b3RlZFZhbHVlKHNvdXJjZSwgX29uRXJyb3IpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0IHNob3VsZCBub3QgaGFwcGVuICovXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBvbkVycm9yKHNjYWxhciwgJ1VORVhQRUNURURfVE9LRU4nLCBgRXhwZWN0ZWQgYSBmbG93IHNjYWxhciB2YWx1ZSwgYnV0IGZvdW5kOiAke3R5cGV9YCk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHZhbHVlOiAnJyxcbiAgICAgICAgICAgICAgICB0eXBlOiBudWxsLFxuICAgICAgICAgICAgICAgIGNvbW1lbnQ6ICcnLFxuICAgICAgICAgICAgICAgIHJhbmdlOiBbb2Zmc2V0LCBvZmZzZXQgKyBzb3VyY2UubGVuZ3RoLCBvZmZzZXQgKyBzb3VyY2UubGVuZ3RoXVxuICAgICAgICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgdmFsdWVFbmQgPSBvZmZzZXQgKyBzb3VyY2UubGVuZ3RoO1xuICAgIGNvbnN0IHJlID0gcmVzb2x2ZUVuZChlbmQsIHZhbHVlRW5kLCBzdHJpY3QsIG9uRXJyb3IpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlLFxuICAgICAgICB0eXBlOiBfdHlwZSxcbiAgICAgICAgY29tbWVudDogcmUuY29tbWVudCxcbiAgICAgICAgcmFuZ2U6IFtvZmZzZXQsIHZhbHVlRW5kLCByZS5vZmZzZXRdXG4gICAgfTtcbn1cbmZ1bmN0aW9uIHBsYWluVmFsdWUoc291cmNlLCBvbkVycm9yKSB7XG4gICAgbGV0IGJhZENoYXIgPSAnJztcbiAgICBzd2l0Y2ggKHNvdXJjZVswXSkge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCBzaG91bGQgbm90IGhhcHBlbiAqL1xuICAgICAgICBjYXNlICdcXHQnOlxuICAgICAgICAgICAgYmFkQ2hhciA9ICdhIHRhYiBjaGFyYWN0ZXInO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJywnOlxuICAgICAgICAgICAgYmFkQ2hhciA9ICdmbG93IGluZGljYXRvciBjaGFyYWN0ZXIgLCc7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnJSc6XG4gICAgICAgICAgICBiYWRDaGFyID0gJ2RpcmVjdGl2ZSBpbmRpY2F0b3IgY2hhcmFjdGVyICUnO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3wnOlxuICAgICAgICBjYXNlICc+Jzoge1xuICAgICAgICAgICAgYmFkQ2hhciA9IGBibG9jayBzY2FsYXIgaW5kaWNhdG9yICR7c291cmNlWzBdfWA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdAJzpcbiAgICAgICAgY2FzZSAnYCc6IHtcbiAgICAgICAgICAgIGJhZENoYXIgPSBgcmVzZXJ2ZWQgY2hhcmFjdGVyICR7c291cmNlWzBdfWA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoYmFkQ2hhcilcbiAgICAgICAgb25FcnJvcigwLCAnQkFEX1NDQUxBUl9TVEFSVCcsIGBQbGFpbiB2YWx1ZSBjYW5ub3Qgc3RhcnQgd2l0aCAke2JhZENoYXJ9YCk7XG4gICAgcmV0dXJuIGZvbGRMaW5lcyhzb3VyY2UpO1xufVxuZnVuY3Rpb24gc2luZ2xlUXVvdGVkVmFsdWUoc291cmNlLCBvbkVycm9yKSB7XG4gICAgaWYgKHNvdXJjZVtzb3VyY2UubGVuZ3RoIC0gMV0gIT09IFwiJ1wiIHx8IHNvdXJjZS5sZW5ndGggPT09IDEpXG4gICAgICAgIG9uRXJyb3Ioc291cmNlLmxlbmd0aCwgJ01JU1NJTkdfQ0hBUicsIFwiTWlzc2luZyBjbG9zaW5nICdxdW90ZVwiKTtcbiAgICByZXR1cm4gZm9sZExpbmVzKHNvdXJjZS5zbGljZSgxLCAtMSkpLnJlcGxhY2UoLycnL2csIFwiJ1wiKTtcbn1cbmZ1bmN0aW9uIGZvbGRMaW5lcyhzb3VyY2UpIHtcbiAgICAvKipcbiAgICAgKiBUaGUgbmVnYXRpdmUgbG9va2JlaGluZCBoZXJlIGFuZCBpbiB0aGUgYHJlYCBSZWdFeHAgaXMgdG9cbiAgICAgKiBwcmV2ZW50IGNhdXNpbmcgYSBwb2x5bm9taWFsIHNlYXJjaCB0aW1lIGluIGNlcnRhaW4gY2FzZXMuXG4gICAgICpcbiAgICAgKiBUaGUgdHJ5LWNhdGNoIGlzIGZvciBTYWZhcmksIHdoaWNoIGRvZXNuJ3Qgc3VwcG9ydCB0aGlzIHlldDpcbiAgICAgKiBodHRwczovL2Nhbml1c2UuY29tL2pzLXJlZ2V4cC1sb29rYmVoaW5kXG4gICAgICovXG4gICAgbGV0IGZpcnN0LCBsaW5lO1xuICAgIHRyeSB7XG4gICAgICAgIGZpcnN0ID0gbmV3IFJlZ0V4cCgnKC4qPykoPzwhWyBcXHRdKVsgXFx0XSpcXHI/XFxuJywgJ3N5Jyk7XG4gICAgICAgIGxpbmUgPSBuZXcgUmVnRXhwKCdbIFxcdF0qKC4qPykoPzooPzwhWyBcXHRdKVsgXFx0XSopP1xccj9cXG4nLCAnc3knKTtcbiAgICB9XG4gICAgY2F0Y2ggKF8pIHtcbiAgICAgICAgZmlyc3QgPSAvKC4qPylbIFxcdF0qXFxyP1xcbi9zeTtcbiAgICAgICAgbGluZSA9IC9bIFxcdF0qKC4qPylbIFxcdF0qXFxyP1xcbi9zeTtcbiAgICB9XG4gICAgbGV0IG1hdGNoID0gZmlyc3QuZXhlYyhzb3VyY2UpO1xuICAgIGlmICghbWF0Y2gpXG4gICAgICAgIHJldHVybiBzb3VyY2U7XG4gICAgbGV0IHJlcyA9IG1hdGNoWzFdO1xuICAgIGxldCBzZXAgPSAnICc7XG4gICAgbGV0IHBvcyA9IGZpcnN0Lmxhc3RJbmRleDtcbiAgICBsaW5lLmxhc3RJbmRleCA9IHBvcztcbiAgICB3aGlsZSAoKG1hdGNoID0gbGluZS5leGVjKHNvdXJjZSkpKSB7XG4gICAgICAgIGlmIChtYXRjaFsxXSA9PT0gJycpIHtcbiAgICAgICAgICAgIGlmIChzZXAgPT09ICdcXG4nKVxuICAgICAgICAgICAgICAgIHJlcyArPSBzZXA7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgc2VwID0gJ1xcbic7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXMgKz0gc2VwICsgbWF0Y2hbMV07XG4gICAgICAgICAgICBzZXAgPSAnICc7XG4gICAgICAgIH1cbiAgICAgICAgcG9zID0gbGluZS5sYXN0SW5kZXg7XG4gICAgfVxuICAgIGNvbnN0IGxhc3QgPSAvWyBcXHRdKiguKikvc3k7XG4gICAgbGFzdC5sYXN0SW5kZXggPSBwb3M7XG4gICAgbWF0Y2ggPSBsYXN0LmV4ZWMoc291cmNlKTtcbiAgICByZXR1cm4gcmVzICsgc2VwICsgKChtYXRjaCAmJiBtYXRjaFsxXSkgfHwgJycpO1xufVxuZnVuY3Rpb24gZG91YmxlUXVvdGVkVmFsdWUoc291cmNlLCBvbkVycm9yKSB7XG4gICAgbGV0IHJlcyA9ICcnO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgc291cmNlLmxlbmd0aCAtIDE7ICsraSkge1xuICAgICAgICBjb25zdCBjaCA9IHNvdXJjZVtpXTtcbiAgICAgICAgaWYgKGNoID09PSAnXFxyJyAmJiBzb3VyY2VbaSArIDFdID09PSAnXFxuJylcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBpZiAoY2ggPT09ICdcXG4nKSB7XG4gICAgICAgICAgICBjb25zdCB7IGZvbGQsIG9mZnNldCB9ID0gZm9sZE5ld2xpbmUoc291cmNlLCBpKTtcbiAgICAgICAgICAgIHJlcyArPSBmb2xkO1xuICAgICAgICAgICAgaSA9IG9mZnNldDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjaCA9PT0gJ1xcXFwnKSB7XG4gICAgICAgICAgICBsZXQgbmV4dCA9IHNvdXJjZVsrK2ldO1xuICAgICAgICAgICAgY29uc3QgY2MgPSBlc2NhcGVDb2Rlc1tuZXh0XTtcbiAgICAgICAgICAgIGlmIChjYylcbiAgICAgICAgICAgICAgICByZXMgKz0gY2M7XG4gICAgICAgICAgICBlbHNlIGlmIChuZXh0ID09PSAnXFxuJykge1xuICAgICAgICAgICAgICAgIC8vIHNraXAgZXNjYXBlZCBuZXdsaW5lcywgYnV0IHN0aWxsIHRyaW0gdGhlIGZvbGxvd2luZyBsaW5lXG4gICAgICAgICAgICAgICAgbmV4dCA9IHNvdXJjZVtpICsgMV07XG4gICAgICAgICAgICAgICAgd2hpbGUgKG5leHQgPT09ICcgJyB8fCBuZXh0ID09PSAnXFx0JylcbiAgICAgICAgICAgICAgICAgICAgbmV4dCA9IHNvdXJjZVsrK2kgKyAxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG5leHQgPT09ICdcXHInICYmIHNvdXJjZVtpICsgMV0gPT09ICdcXG4nKSB7XG4gICAgICAgICAgICAgICAgLy8gc2tpcCBlc2NhcGVkIENSTEYgbmV3bGluZXMsIGJ1dCBzdGlsbCB0cmltIHRoZSBmb2xsb3dpbmcgbGluZVxuICAgICAgICAgICAgICAgIG5leHQgPSBzb3VyY2VbKytpICsgMV07XG4gICAgICAgICAgICAgICAgd2hpbGUgKG5leHQgPT09ICcgJyB8fCBuZXh0ID09PSAnXFx0JylcbiAgICAgICAgICAgICAgICAgICAgbmV4dCA9IHNvdXJjZVsrK2kgKyAxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG5leHQgPT09ICd4JyB8fCBuZXh0ID09PSAndScgfHwgbmV4dCA9PT0gJ1UnKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0geyB4OiAyLCB1OiA0LCBVOiA4IH1bbmV4dF07XG4gICAgICAgICAgICAgICAgcmVzICs9IHBhcnNlQ2hhckNvZGUoc291cmNlLCBpICsgMSwgbGVuZ3RoLCBvbkVycm9yKTtcbiAgICAgICAgICAgICAgICBpICs9IGxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJhdyA9IHNvdXJjZS5zdWJzdHIoaSAtIDEsIDIpO1xuICAgICAgICAgICAgICAgIG9uRXJyb3IoaSAtIDEsICdCQURfRFFfRVNDQVBFJywgYEludmFsaWQgZXNjYXBlIHNlcXVlbmNlICR7cmF3fWApO1xuICAgICAgICAgICAgICAgIHJlcyArPSByYXc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2ggPT09ICcgJyB8fCBjaCA9PT0gJ1xcdCcpIHtcbiAgICAgICAgICAgIC8vIHRyaW0gdHJhaWxpbmcgd2hpdGVzcGFjZVxuICAgICAgICAgICAgY29uc3Qgd3NTdGFydCA9IGk7XG4gICAgICAgICAgICBsZXQgbmV4dCA9IHNvdXJjZVtpICsgMV07XG4gICAgICAgICAgICB3aGlsZSAobmV4dCA9PT0gJyAnIHx8IG5leHQgPT09ICdcXHQnKVxuICAgICAgICAgICAgICAgIG5leHQgPSBzb3VyY2VbKytpICsgMV07XG4gICAgICAgICAgICBpZiAobmV4dCAhPT0gJ1xcbicgJiYgIShuZXh0ID09PSAnXFxyJyAmJiBzb3VyY2VbaSArIDJdID09PSAnXFxuJykpXG4gICAgICAgICAgICAgICAgcmVzICs9IGkgPiB3c1N0YXJ0ID8gc291cmNlLnNsaWNlKHdzU3RhcnQsIGkgKyAxKSA6IGNoO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzICs9IGNoO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChzb3VyY2Vbc291cmNlLmxlbmd0aCAtIDFdICE9PSAnXCInIHx8IHNvdXJjZS5sZW5ndGggPT09IDEpXG4gICAgICAgIG9uRXJyb3Ioc291cmNlLmxlbmd0aCwgJ01JU1NJTkdfQ0hBUicsICdNaXNzaW5nIGNsb3NpbmcgXCJxdW90ZScpO1xuICAgIHJldHVybiByZXM7XG59XG4vKipcbiAqIEZvbGQgYSBzaW5nbGUgbmV3bGluZSBpbnRvIGEgc3BhY2UsIG11bHRpcGxlIG5ld2xpbmVzIHRvIE4gLSAxIG5ld2xpbmVzLlxuICogUHJlc3VtZXMgYHNvdXJjZVtvZmZzZXRdID09PSAnXFxuJ2BcbiAqL1xuZnVuY3Rpb24gZm9sZE5ld2xpbmUoc291cmNlLCBvZmZzZXQpIHtcbiAgICBsZXQgZm9sZCA9ICcnO1xuICAgIGxldCBjaCA9IHNvdXJjZVtvZmZzZXQgKyAxXTtcbiAgICB3aGlsZSAoY2ggPT09ICcgJyB8fCBjaCA9PT0gJ1xcdCcgfHwgY2ggPT09ICdcXG4nIHx8IGNoID09PSAnXFxyJykge1xuICAgICAgICBpZiAoY2ggPT09ICdcXHInICYmIHNvdXJjZVtvZmZzZXQgKyAyXSAhPT0gJ1xcbicpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgaWYgKGNoID09PSAnXFxuJylcbiAgICAgICAgICAgIGZvbGQgKz0gJ1xcbic7XG4gICAgICAgIG9mZnNldCArPSAxO1xuICAgICAgICBjaCA9IHNvdXJjZVtvZmZzZXQgKyAxXTtcbiAgICB9XG4gICAgaWYgKCFmb2xkKVxuICAgICAgICBmb2xkID0gJyAnO1xuICAgIHJldHVybiB7IGZvbGQsIG9mZnNldCB9O1xufVxuY29uc3QgZXNjYXBlQ29kZXMgPSB7XG4gICAgJzAnOiAnXFwwJyxcbiAgICBhOiAnXFx4MDcnLFxuICAgIGI6ICdcXGInLFxuICAgIGU6ICdcXHgxYicsXG4gICAgZjogJ1xcZicsXG4gICAgbjogJ1xcbicsXG4gICAgcjogJ1xccicsXG4gICAgdDogJ1xcdCcsXG4gICAgdjogJ1xcdicsXG4gICAgTjogJ1xcdTAwODUnLFxuICAgIF86ICdcXHUwMGEwJyxcbiAgICBMOiAnXFx1MjAyOCcsXG4gICAgUDogJ1xcdTIwMjknLFxuICAgICcgJzogJyAnLFxuICAgICdcIic6ICdcIicsXG4gICAgJy8nOiAnLycsXG4gICAgJ1xcXFwnOiAnXFxcXCcsXG4gICAgJ1xcdCc6ICdcXHQnXG59O1xuZnVuY3Rpb24gcGFyc2VDaGFyQ29kZShzb3VyY2UsIG9mZnNldCwgbGVuZ3RoLCBvbkVycm9yKSB7XG4gICAgY29uc3QgY2MgPSBzb3VyY2Uuc3Vic3RyKG9mZnNldCwgbGVuZ3RoKTtcbiAgICBjb25zdCBvayA9IGNjLmxlbmd0aCA9PT0gbGVuZ3RoICYmIC9eWzAtOWEtZkEtRl0rJC8udGVzdChjYyk7XG4gICAgY29uc3QgY29kZSA9IG9rID8gcGFyc2VJbnQoY2MsIDE2KSA6IE5hTjtcbiAgICBpZiAoaXNOYU4oY29kZSkpIHtcbiAgICAgICAgY29uc3QgcmF3ID0gc291cmNlLnN1YnN0cihvZmZzZXQgLSAyLCBsZW5ndGggKyAyKTtcbiAgICAgICAgb25FcnJvcihvZmZzZXQgLSAyLCAnQkFEX0RRX0VTQ0FQRScsIGBJbnZhbGlkIGVzY2FwZSBzZXF1ZW5jZSAke3Jhd31gKTtcbiAgICAgICAgcmV0dXJuIHJhdztcbiAgICB9XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ29kZVBvaW50KGNvZGUpO1xufVxuXG5leHBvcnQgeyByZXNvbHZlRmxvd1NjYWxhciB9O1xuIiwgImltcG9ydCB7IFNDQUxBUiwgaXNTY2FsYXIgfSBmcm9tICcuLi9ub2Rlcy9Ob2RlLmpzJztcbmltcG9ydCB7IFNjYWxhciB9IGZyb20gJy4uL25vZGVzL1NjYWxhci5qcyc7XG5pbXBvcnQgeyByZXNvbHZlQmxvY2tTY2FsYXIgfSBmcm9tICcuL3Jlc29sdmUtYmxvY2stc2NhbGFyLmpzJztcbmltcG9ydCB7IHJlc29sdmVGbG93U2NhbGFyIH0gZnJvbSAnLi9yZXNvbHZlLWZsb3ctc2NhbGFyLmpzJztcblxuZnVuY3Rpb24gY29tcG9zZVNjYWxhcihjdHgsIHRva2VuLCB0YWdUb2tlbiwgb25FcnJvcikge1xuICAgIGNvbnN0IHsgdmFsdWUsIHR5cGUsIGNvbW1lbnQsIHJhbmdlIH0gPSB0b2tlbi50eXBlID09PSAnYmxvY2stc2NhbGFyJ1xuICAgICAgICA/IHJlc29sdmVCbG9ja1NjYWxhcih0b2tlbiwgY3R4Lm9wdGlvbnMuc3RyaWN0LCBvbkVycm9yKVxuICAgICAgICA6IHJlc29sdmVGbG93U2NhbGFyKHRva2VuLCBjdHgub3B0aW9ucy5zdHJpY3QsIG9uRXJyb3IpO1xuICAgIGNvbnN0IHRhZ05hbWUgPSB0YWdUb2tlblxuICAgICAgICA/IGN0eC5kaXJlY3RpdmVzLnRhZ05hbWUodGFnVG9rZW4uc291cmNlLCBtc2cgPT4gb25FcnJvcih0YWdUb2tlbiwgJ1RBR19SRVNPTFZFX0ZBSUxFRCcsIG1zZykpXG4gICAgICAgIDogbnVsbDtcbiAgICBjb25zdCB0YWcgPSB0YWdUb2tlbiAmJiB0YWdOYW1lXG4gICAgICAgID8gZmluZFNjYWxhclRhZ0J5TmFtZShjdHguc2NoZW1hLCB2YWx1ZSwgdGFnTmFtZSwgdGFnVG9rZW4sIG9uRXJyb3IpXG4gICAgICAgIDogdG9rZW4udHlwZSA9PT0gJ3NjYWxhcidcbiAgICAgICAgICAgID8gZmluZFNjYWxhclRhZ0J5VGVzdChjdHgsIHZhbHVlLCB0b2tlbiwgb25FcnJvcilcbiAgICAgICAgICAgIDogY3R4LnNjaGVtYVtTQ0FMQVJdO1xuICAgIGxldCBzY2FsYXI7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzID0gdGFnLnJlc29sdmUodmFsdWUsIG1zZyA9PiBvbkVycm9yKHRhZ1Rva2VuIHx8IHRva2VuLCAnVEFHX1JFU09MVkVfRkFJTEVEJywgbXNnKSwgY3R4Lm9wdGlvbnMpO1xuICAgICAgICBzY2FsYXIgPSBpc1NjYWxhcihyZXMpID8gcmVzIDogbmV3IFNjYWxhcihyZXMpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc3QgbXNnID0gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpO1xuICAgICAgICBvbkVycm9yKHRhZ1Rva2VuIHx8IHRva2VuLCAnVEFHX1JFU09MVkVfRkFJTEVEJywgbXNnKTtcbiAgICAgICAgc2NhbGFyID0gbmV3IFNjYWxhcih2YWx1ZSk7XG4gICAgfVxuICAgIHNjYWxhci5yYW5nZSA9IHJhbmdlO1xuICAgIHNjYWxhci5zb3VyY2UgPSB2YWx1ZTtcbiAgICBpZiAodHlwZSlcbiAgICAgICAgc2NhbGFyLnR5cGUgPSB0eXBlO1xuICAgIGlmICh0YWdOYW1lKVxuICAgICAgICBzY2FsYXIudGFnID0gdGFnTmFtZTtcbiAgICBpZiAodGFnLmZvcm1hdClcbiAgICAgICAgc2NhbGFyLmZvcm1hdCA9IHRhZy5mb3JtYXQ7XG4gICAgaWYgKGNvbW1lbnQpXG4gICAgICAgIHNjYWxhci5jb21tZW50ID0gY29tbWVudDtcbiAgICByZXR1cm4gc2NhbGFyO1xufVxuZnVuY3Rpb24gZmluZFNjYWxhclRhZ0J5TmFtZShzY2hlbWEsIHZhbHVlLCB0YWdOYW1lLCB0YWdUb2tlbiwgb25FcnJvcikge1xuICAgIHZhciBfYTtcbiAgICBpZiAodGFnTmFtZSA9PT0gJyEnKVxuICAgICAgICByZXR1cm4gc2NoZW1hW1NDQUxBUl07IC8vIG5vbi1zcGVjaWZpYyB0YWdcbiAgICBjb25zdCBtYXRjaFdpdGhUZXN0ID0gW107XG4gICAgZm9yIChjb25zdCB0YWcgb2Ygc2NoZW1hLnRhZ3MpIHtcbiAgICAgICAgaWYgKCF0YWcuY29sbGVjdGlvbiAmJiB0YWcudGFnID09PSB0YWdOYW1lKSB7XG4gICAgICAgICAgICBpZiAodGFnLmRlZmF1bHQgJiYgdGFnLnRlc3QpXG4gICAgICAgICAgICAgICAgbWF0Y2hXaXRoVGVzdC5wdXNoKHRhZyk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhZztcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IHRhZyBvZiBtYXRjaFdpdGhUZXN0KVxuICAgICAgICBpZiAoKF9hID0gdGFnLnRlc3QpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50ZXN0KHZhbHVlKSlcbiAgICAgICAgICAgIHJldHVybiB0YWc7XG4gICAgY29uc3Qga3QgPSBzY2hlbWEua25vd25UYWdzW3RhZ05hbWVdO1xuICAgIGlmIChrdCAmJiAha3QuY29sbGVjdGlvbikge1xuICAgICAgICAvLyBFbnN1cmUgdGhhdCB0aGUga25vd24gdGFnIGlzIGF2YWlsYWJsZSBmb3Igc3RyaW5naWZ5aW5nLFxuICAgICAgICAvLyBidXQgZG9lcyBub3QgZ2V0IHVzZWQgYnkgZGVmYXVsdC5cbiAgICAgICAgc2NoZW1hLnRhZ3MucHVzaChPYmplY3QuYXNzaWduKHt9LCBrdCwgeyBkZWZhdWx0OiBmYWxzZSwgdGVzdDogdW5kZWZpbmVkIH0pKTtcbiAgICAgICAgcmV0dXJuIGt0O1xuICAgIH1cbiAgICBvbkVycm9yKHRhZ1Rva2VuLCAnVEFHX1JFU09MVkVfRkFJTEVEJywgYFVucmVzb2x2ZWQgdGFnOiAke3RhZ05hbWV9YCwgdGFnTmFtZSAhPT0gJ3RhZzp5YW1sLm9yZywyMDAyOnN0cicpO1xuICAgIHJldHVybiBzY2hlbWFbU0NBTEFSXTtcbn1cbmZ1bmN0aW9uIGZpbmRTY2FsYXJUYWdCeVRlc3QoeyBkaXJlY3RpdmVzLCBzY2hlbWEgfSwgdmFsdWUsIHRva2VuLCBvbkVycm9yKSB7XG4gICAgY29uc3QgdGFnID0gc2NoZW1hLnRhZ3MuZmluZCh0YWcgPT4geyB2YXIgX2E7IHJldHVybiB0YWcuZGVmYXVsdCAmJiAoKF9hID0gdGFnLnRlc3QpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50ZXN0KHZhbHVlKSk7IH0pIHx8IHNjaGVtYVtTQ0FMQVJdO1xuICAgIGlmIChzY2hlbWEuY29tcGF0KSB7XG4gICAgICAgIGNvbnN0IGNvbXBhdCA9IHNjaGVtYS5jb21wYXQuZmluZCh0YWcgPT4geyB2YXIgX2E7IHJldHVybiB0YWcuZGVmYXVsdCAmJiAoKF9hID0gdGFnLnRlc3QpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50ZXN0KHZhbHVlKSk7IH0pIHx8XG4gICAgICAgICAgICBzY2hlbWFbU0NBTEFSXTtcbiAgICAgICAgaWYgKHRhZy50YWcgIT09IGNvbXBhdC50YWcpIHtcbiAgICAgICAgICAgIGNvbnN0IHRzID0gZGlyZWN0aXZlcy50YWdTdHJpbmcodGFnLnRhZyk7XG4gICAgICAgICAgICBjb25zdCBjcyA9IGRpcmVjdGl2ZXMudGFnU3RyaW5nKGNvbXBhdC50YWcpO1xuICAgICAgICAgICAgY29uc3QgbXNnID0gYFZhbHVlIG1heSBiZSBwYXJzZWQgYXMgZWl0aGVyICR7dHN9IG9yICR7Y3N9YDtcbiAgICAgICAgICAgIG9uRXJyb3IodG9rZW4sICdUQUdfUkVTT0xWRV9GQUlMRUQnLCBtc2csIHRydWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0YWc7XG59XG5cbmV4cG9ydCB7IGNvbXBvc2VTY2FsYXIgfTtcbiIsICJmdW5jdGlvbiBlbXB0eVNjYWxhclBvc2l0aW9uKG9mZnNldCwgYmVmb3JlLCBwb3MpIHtcbiAgICBpZiAoYmVmb3JlKSB7XG4gICAgICAgIGlmIChwb3MgPT09IG51bGwpXG4gICAgICAgICAgICBwb3MgPSBiZWZvcmUubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBpID0gcG9zIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgICAgIGxldCBzdCA9IGJlZm9yZVtpXTtcbiAgICAgICAgICAgIHN3aXRjaCAoc3QudHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3NwYWNlJzpcbiAgICAgICAgICAgICAgICBjYXNlICdjb21tZW50JzpcbiAgICAgICAgICAgICAgICBjYXNlICduZXdsaW5lJzpcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0IC09IHN0LnNvdXJjZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVGVjaG5pY2FsbHksIGFuIGVtcHR5IHNjYWxhciBpcyBpbW1lZGlhdGVseSBhZnRlciB0aGUgbGFzdCBub24tZW1wdHlcbiAgICAgICAgICAgIC8vIG5vZGUsIGJ1dCBpdCdzIG1vcmUgdXNlZnVsIHRvIHBsYWNlIGl0IGFmdGVyIGFueSB3aGl0ZXNwYWNlLlxuICAgICAgICAgICAgc3QgPSBiZWZvcmVbKytpXTtcbiAgICAgICAgICAgIHdoaWxlICgoc3QgPT09IG51bGwgfHwgc3QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHN0LnR5cGUpID09PSAnc3BhY2UnKSB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ICs9IHN0LnNvdXJjZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgc3QgPSBiZWZvcmVbKytpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvZmZzZXQ7XG59XG5cbmV4cG9ydCB7IGVtcHR5U2NhbGFyUG9zaXRpb24gfTtcbiIsICJpbXBvcnQgeyBBbGlhcyB9IGZyb20gJy4uL25vZGVzL0FsaWFzLmpzJztcbmltcG9ydCB7IGNvbXBvc2VDb2xsZWN0aW9uIH0gZnJvbSAnLi9jb21wb3NlLWNvbGxlY3Rpb24uanMnO1xuaW1wb3J0IHsgY29tcG9zZVNjYWxhciB9IGZyb20gJy4vY29tcG9zZS1zY2FsYXIuanMnO1xuaW1wb3J0IHsgcmVzb2x2ZUVuZCB9IGZyb20gJy4vcmVzb2x2ZS1lbmQuanMnO1xuaW1wb3J0IHsgZW1wdHlTY2FsYXJQb3NpdGlvbiB9IGZyb20gJy4vdXRpbC1lbXB0eS1zY2FsYXItcG9zaXRpb24uanMnO1xuXG5jb25zdCBDTiA9IHsgY29tcG9zZU5vZGUsIGNvbXBvc2VFbXB0eU5vZGUgfTtcbmZ1bmN0aW9uIGNvbXBvc2VOb2RlKGN0eCwgdG9rZW4sIHByb3BzLCBvbkVycm9yKSB7XG4gICAgY29uc3QgeyBzcGFjZUJlZm9yZSwgY29tbWVudCwgYW5jaG9yLCB0YWcgfSA9IHByb3BzO1xuICAgIGxldCBub2RlO1xuICAgIHN3aXRjaCAodG9rZW4udHlwZSkge1xuICAgICAgICBjYXNlICdhbGlhcyc6XG4gICAgICAgICAgICBub2RlID0gY29tcG9zZUFsaWFzKGN0eCwgdG9rZW4sIG9uRXJyb3IpO1xuICAgICAgICAgICAgaWYgKGFuY2hvciB8fCB0YWcpXG4gICAgICAgICAgICAgICAgb25FcnJvcih0b2tlbiwgJ0FMSUFTX1BST1BTJywgJ0FuIGFsaWFzIG5vZGUgbXVzdCBub3Qgc3BlY2lmeSBhbnkgcHJvcGVydGllcycpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3NjYWxhcic6XG4gICAgICAgIGNhc2UgJ3NpbmdsZS1xdW90ZWQtc2NhbGFyJzpcbiAgICAgICAgY2FzZSAnZG91YmxlLXF1b3RlZC1zY2FsYXInOlxuICAgICAgICBjYXNlICdibG9jay1zY2FsYXInOlxuICAgICAgICAgICAgbm9kZSA9IGNvbXBvc2VTY2FsYXIoY3R4LCB0b2tlbiwgdGFnLCBvbkVycm9yKTtcbiAgICAgICAgICAgIGlmIChhbmNob3IpXG4gICAgICAgICAgICAgICAgbm9kZS5hbmNob3IgPSBhbmNob3Iuc291cmNlLnN1YnN0cmluZygxKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdibG9jay1tYXAnOlxuICAgICAgICBjYXNlICdibG9jay1zZXEnOlxuICAgICAgICBjYXNlICdmbG93LWNvbGxlY3Rpb24nOlxuICAgICAgICAgICAgbm9kZSA9IGNvbXBvc2VDb2xsZWN0aW9uKENOLCBjdHgsIHRva2VuLCB0YWcsIG9uRXJyb3IpO1xuICAgICAgICAgICAgaWYgKGFuY2hvcilcbiAgICAgICAgICAgICAgICBub2RlLmFuY2hvciA9IGFuY2hvci5zb3VyY2Uuc3Vic3RyaW5nKDEpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBjb25zb2xlLmxvZyh0b2tlbik7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVuIHRva2VuIHR5cGU6ICR7dG9rZW4udHlwZX1gKTtcbiAgICB9XG4gICAgaWYgKGFuY2hvciAmJiBub2RlLmFuY2hvciA9PT0gJycpXG4gICAgICAgIG9uRXJyb3IoYW5jaG9yLCAnQkFEX0FMSUFTJywgJ0FuY2hvciBjYW5ub3QgYmUgYW4gZW1wdHkgc3RyaW5nJyk7XG4gICAgaWYgKHNwYWNlQmVmb3JlKVxuICAgICAgICBub2RlLnNwYWNlQmVmb3JlID0gdHJ1ZTtcbiAgICBpZiAoY29tbWVudCkge1xuICAgICAgICBpZiAodG9rZW4udHlwZSA9PT0gJ3NjYWxhcicgJiYgdG9rZW4uc291cmNlID09PSAnJylcbiAgICAgICAgICAgIG5vZGUuY29tbWVudCA9IGNvbW1lbnQ7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIG5vZGUuY29tbWVudEJlZm9yZSA9IGNvbW1lbnQ7XG4gICAgfVxuICAgIGlmIChjdHgub3B0aW9ucy5rZWVwU291cmNlVG9rZW5zKVxuICAgICAgICBub2RlLnNyY1Rva2VuID0gdG9rZW47XG4gICAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiBjb21wb3NlRW1wdHlOb2RlKGN0eCwgb2Zmc2V0LCBiZWZvcmUsIHBvcywgeyBzcGFjZUJlZm9yZSwgY29tbWVudCwgYW5jaG9yLCB0YWcgfSwgb25FcnJvcikge1xuICAgIGNvbnN0IHRva2VuID0ge1xuICAgICAgICB0eXBlOiAnc2NhbGFyJyxcbiAgICAgICAgb2Zmc2V0OiBlbXB0eVNjYWxhclBvc2l0aW9uKG9mZnNldCwgYmVmb3JlLCBwb3MpLFxuICAgICAgICBpbmRlbnQ6IC0xLFxuICAgICAgICBzb3VyY2U6ICcnXG4gICAgfTtcbiAgICBjb25zdCBub2RlID0gY29tcG9zZVNjYWxhcihjdHgsIHRva2VuLCB0YWcsIG9uRXJyb3IpO1xuICAgIGlmIChhbmNob3IpIHtcbiAgICAgICAgbm9kZS5hbmNob3IgPSBhbmNob3Iuc291cmNlLnN1YnN0cmluZygxKTtcbiAgICAgICAgaWYgKG5vZGUuYW5jaG9yID09PSAnJylcbiAgICAgICAgICAgIG9uRXJyb3IoYW5jaG9yLCAnQkFEX0FMSUFTJywgJ0FuY2hvciBjYW5ub3QgYmUgYW4gZW1wdHkgc3RyaW5nJyk7XG4gICAgfVxuICAgIGlmIChzcGFjZUJlZm9yZSlcbiAgICAgICAgbm9kZS5zcGFjZUJlZm9yZSA9IHRydWU7XG4gICAgaWYgKGNvbW1lbnQpXG4gICAgICAgIG5vZGUuY29tbWVudCA9IGNvbW1lbnQ7XG4gICAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiBjb21wb3NlQWxpYXMoeyBvcHRpb25zIH0sIHsgb2Zmc2V0LCBzb3VyY2UsIGVuZCB9LCBvbkVycm9yKSB7XG4gICAgY29uc3QgYWxpYXMgPSBuZXcgQWxpYXMoc291cmNlLnN1YnN0cmluZygxKSk7XG4gICAgaWYgKGFsaWFzLnNvdXJjZSA9PT0gJycpXG4gICAgICAgIG9uRXJyb3Iob2Zmc2V0LCAnQkFEX0FMSUFTJywgJ0FsaWFzIGNhbm5vdCBiZSBhbiBlbXB0eSBzdHJpbmcnKTtcbiAgICBjb25zdCB2YWx1ZUVuZCA9IG9mZnNldCArIHNvdXJjZS5sZW5ndGg7XG4gICAgY29uc3QgcmUgPSByZXNvbHZlRW5kKGVuZCwgdmFsdWVFbmQsIG9wdGlvbnMuc3RyaWN0LCBvbkVycm9yKTtcbiAgICBhbGlhcy5yYW5nZSA9IFtvZmZzZXQsIHZhbHVlRW5kLCByZS5vZmZzZXRdO1xuICAgIGlmIChyZS5jb21tZW50KVxuICAgICAgICBhbGlhcy5jb21tZW50ID0gcmUuY29tbWVudDtcbiAgICByZXR1cm4gYWxpYXM7XG59XG5cbmV4cG9ydCB7IGNvbXBvc2VFbXB0eU5vZGUsIGNvbXBvc2VOb2RlIH07XG4iLCAiaW1wb3J0IHsgRG9jdW1lbnQgfSBmcm9tICcuLi9kb2MvRG9jdW1lbnQuanMnO1xuaW1wb3J0IHsgY29tcG9zZU5vZGUsIGNvbXBvc2VFbXB0eU5vZGUgfSBmcm9tICcuL2NvbXBvc2Utbm9kZS5qcyc7XG5pbXBvcnQgeyByZXNvbHZlRW5kIH0gZnJvbSAnLi9yZXNvbHZlLWVuZC5qcyc7XG5pbXBvcnQgeyByZXNvbHZlUHJvcHMgfSBmcm9tICcuL3Jlc29sdmUtcHJvcHMuanMnO1xuXG5mdW5jdGlvbiBjb21wb3NlRG9jKG9wdGlvbnMsIGRpcmVjdGl2ZXMsIHsgb2Zmc2V0LCBzdGFydCwgdmFsdWUsIGVuZCB9LCBvbkVycm9yKSB7XG4gICAgY29uc3Qgb3B0cyA9IE9iamVjdC5hc3NpZ24oeyBkaXJlY3RpdmVzIH0sIG9wdGlvbnMpO1xuICAgIGNvbnN0IGRvYyA9IG5ldyBEb2N1bWVudCh1bmRlZmluZWQsIG9wdHMpO1xuICAgIGNvbnN0IGN0eCA9IHtcbiAgICAgICAgYXRSb290OiB0cnVlLFxuICAgICAgICBkaXJlY3RpdmVzOiBkb2MuZGlyZWN0aXZlcyxcbiAgICAgICAgb3B0aW9uczogZG9jLm9wdGlvbnMsXG4gICAgICAgIHNjaGVtYTogZG9jLnNjaGVtYVxuICAgIH07XG4gICAgY29uc3QgcHJvcHMgPSByZXNvbHZlUHJvcHMoc3RhcnQsIHtcbiAgICAgICAgaW5kaWNhdG9yOiAnZG9jLXN0YXJ0JyxcbiAgICAgICAgbmV4dDogdmFsdWUgfHwgKGVuZCA9PT0gbnVsbCB8fCBlbmQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVuZFswXSksXG4gICAgICAgIG9mZnNldCxcbiAgICAgICAgb25FcnJvcixcbiAgICAgICAgc3RhcnRPbk5ld2xpbmU6IHRydWVcbiAgICB9KTtcbiAgICBpZiAocHJvcHMuZm91bmQpIHtcbiAgICAgICAgZG9jLmRpcmVjdGl2ZXMubWFya2VyID0gdHJ1ZTtcbiAgICAgICAgaWYgKHZhbHVlICYmXG4gICAgICAgICAgICAodmFsdWUudHlwZSA9PT0gJ2Jsb2NrLW1hcCcgfHwgdmFsdWUudHlwZSA9PT0gJ2Jsb2NrLXNlcScpICYmXG4gICAgICAgICAgICAhcHJvcHMuaGFzTmV3bGluZSlcbiAgICAgICAgICAgIG9uRXJyb3IocHJvcHMuZW5kLCAnTUlTU0lOR19DSEFSJywgJ0Jsb2NrIGNvbGxlY3Rpb24gY2Fubm90IHN0YXJ0IG9uIHNhbWUgbGluZSB3aXRoIGRpcmVjdGl2ZXMtZW5kIG1hcmtlcicpO1xuICAgIH1cbiAgICBkb2MuY29udGVudHMgPSB2YWx1ZVxuICAgICAgICA/IGNvbXBvc2VOb2RlKGN0eCwgdmFsdWUsIHByb3BzLCBvbkVycm9yKVxuICAgICAgICA6IGNvbXBvc2VFbXB0eU5vZGUoY3R4LCBwcm9wcy5lbmQsIHN0YXJ0LCBudWxsLCBwcm9wcywgb25FcnJvcik7XG4gICAgY29uc3QgY29udGVudEVuZCA9IGRvYy5jb250ZW50cy5yYW5nZVsyXTtcbiAgICBjb25zdCByZSA9IHJlc29sdmVFbmQoZW5kLCBjb250ZW50RW5kLCBmYWxzZSwgb25FcnJvcik7XG4gICAgaWYgKHJlLmNvbW1lbnQpXG4gICAgICAgIGRvYy5jb21tZW50ID0gcmUuY29tbWVudDtcbiAgICBkb2MucmFuZ2UgPSBbb2Zmc2V0LCBjb250ZW50RW5kLCByZS5vZmZzZXRdO1xuICAgIHJldHVybiBkb2M7XG59XG5cbmV4cG9ydCB7IGNvbXBvc2VEb2MgfTtcbiIsICJpbXBvcnQgeyBEaXJlY3RpdmVzIH0gZnJvbSAnLi4vZG9jL2RpcmVjdGl2ZXMuanMnO1xuaW1wb3J0IHsgRG9jdW1lbnQgfSBmcm9tICcuLi9kb2MvRG9jdW1lbnQuanMnO1xuaW1wb3J0IHsgWUFNTFdhcm5pbmcsIFlBTUxQYXJzZUVycm9yIH0gZnJvbSAnLi4vZXJyb3JzLmpzJztcbmltcG9ydCB7IGlzQ29sbGVjdGlvbiwgaXNQYWlyIH0gZnJvbSAnLi4vbm9kZXMvTm9kZS5qcyc7XG5pbXBvcnQgeyBkZWZhdWx0T3B0aW9ucyB9IGZyb20gJy4uL29wdGlvbnMuanMnO1xuaW1wb3J0IHsgY29tcG9zZURvYyB9IGZyb20gJy4vY29tcG9zZS1kb2MuanMnO1xuaW1wb3J0IHsgcmVzb2x2ZUVuZCB9IGZyb20gJy4vcmVzb2x2ZS1lbmQuanMnO1xuXG5mdW5jdGlvbiBnZXRFcnJvclBvcyhzcmMpIHtcbiAgICBpZiAodHlwZW9mIHNyYyA9PT0gJ251bWJlcicpXG4gICAgICAgIHJldHVybiBbc3JjLCBzcmMgKyAxXTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShzcmMpKVxuICAgICAgICByZXR1cm4gc3JjLmxlbmd0aCA9PT0gMiA/IHNyYyA6IFtzcmNbMF0sIHNyY1sxXV07XG4gICAgY29uc3QgeyBvZmZzZXQsIHNvdXJjZSB9ID0gc3JjO1xuICAgIHJldHVybiBbb2Zmc2V0LCBvZmZzZXQgKyAodHlwZW9mIHNvdXJjZSA9PT0gJ3N0cmluZycgPyBzb3VyY2UubGVuZ3RoIDogMSldO1xufVxuZnVuY3Rpb24gcGFyc2VQcmVsdWRlKHByZWx1ZGUpIHtcbiAgICB2YXIgX2E7XG4gICAgbGV0IGNvbW1lbnQgPSAnJztcbiAgICBsZXQgYXRDb21tZW50ID0gZmFsc2U7XG4gICAgbGV0IGFmdGVyRW1wdHlMaW5lID0gZmFsc2U7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcmVsdWRlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IHNvdXJjZSA9IHByZWx1ZGVbaV07XG4gICAgICAgIHN3aXRjaCAoc291cmNlWzBdKSB7XG4gICAgICAgICAgICBjYXNlICcjJzpcbiAgICAgICAgICAgICAgICBjb21tZW50ICs9XG4gICAgICAgICAgICAgICAgICAgIChjb21tZW50ID09PSAnJyA/ICcnIDogYWZ0ZXJFbXB0eUxpbmUgPyAnXFxuXFxuJyA6ICdcXG4nKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAoc291cmNlLnN1YnN0cmluZygxKSB8fCAnICcpO1xuICAgICAgICAgICAgICAgIGF0Q29tbWVudCA9IHRydWU7XG4gICAgICAgICAgICAgICAgYWZ0ZXJFbXB0eUxpbmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJyUnOlxuICAgICAgICAgICAgICAgIGlmICgoKF9hID0gcHJlbHVkZVtpICsgMV0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVswXSkgIT09ICcjJylcbiAgICAgICAgICAgICAgICAgICAgaSArPSAxO1xuICAgICAgICAgICAgICAgIGF0Q29tbWVudCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAvLyBUaGlzIG1heSBiZSB3cm9uZyBhZnRlciBkb2MtZW5kLCBidXQgaW4gdGhhdCBjYXNlIGl0IGRvZXNuJ3QgbWF0dGVyXG4gICAgICAgICAgICAgICAgaWYgKCFhdENvbW1lbnQpXG4gICAgICAgICAgICAgICAgICAgIGFmdGVyRW1wdHlMaW5lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBhdENvbW1lbnQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBjb21tZW50LCBhZnRlckVtcHR5TGluZSB9O1xufVxuLyoqXG4gKiBDb21wb3NlIGEgc3RyZWFtIG9mIENTVCBub2RlcyBpbnRvIGEgc3RyZWFtIG9mIFlBTUwgRG9jdW1lbnRzLlxuICpcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBDb21wb3NlciwgUGFyc2VyIH0gZnJvbSAneWFtbCdcbiAqXG4gKiBjb25zdCBzcmM6IHN0cmluZyA9IC4uLlxuICogY29uc3QgdG9rZW5zID0gbmV3IFBhcnNlcigpLnBhcnNlKHNyYylcbiAqIGNvbnN0IGRvY3MgPSBuZXcgQ29tcG9zZXIoKS5jb21wb3NlKHRva2VucylcbiAqIGBgYFxuICovXG5jbGFzcyBDb21wb3NlciB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHRoaXMuZG9jID0gbnVsbDtcbiAgICAgICAgdGhpcy5hdERpcmVjdGl2ZXMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5wcmVsdWRlID0gW107XG4gICAgICAgIHRoaXMuZXJyb3JzID0gW107XG4gICAgICAgIHRoaXMud2FybmluZ3MgPSBbXTtcbiAgICAgICAgdGhpcy5vbkVycm9yID0gKHNvdXJjZSwgY29kZSwgbWVzc2FnZSwgd2FybmluZykgPT4ge1xuICAgICAgICAgICAgY29uc3QgcG9zID0gZ2V0RXJyb3JQb3Moc291cmNlKTtcbiAgICAgICAgICAgIGlmICh3YXJuaW5nKVxuICAgICAgICAgICAgICAgIHRoaXMud2FybmluZ3MucHVzaChuZXcgWUFNTFdhcm5pbmcocG9zLCBjb2RlLCBtZXNzYWdlKSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhpcy5lcnJvcnMucHVzaChuZXcgWUFNTFBhcnNlRXJyb3IocG9zLCBjb2RlLCBtZXNzYWdlKSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZGlyZWN0aXZlcyA9IG5ldyBEaXJlY3RpdmVzKHtcbiAgICAgICAgICAgIHZlcnNpb246IG9wdGlvbnMudmVyc2lvbiB8fCBkZWZhdWx0T3B0aW9ucy52ZXJzaW9uXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIH1cbiAgICBkZWNvcmF0ZShkb2MsIGFmdGVyRG9jKSB7XG4gICAgICAgIGNvbnN0IHsgY29tbWVudCwgYWZ0ZXJFbXB0eUxpbmUgfSA9IHBhcnNlUHJlbHVkZSh0aGlzLnByZWx1ZGUpO1xuICAgICAgICAvL2NvbnNvbGUubG9nKHsgZGM6IGRvYy5jb21tZW50LCBwcmVsdWRlLCBjb21tZW50IH0pXG4gICAgICAgIGlmIChjb21tZW50KSB7XG4gICAgICAgICAgICBjb25zdCBkYyA9IGRvYy5jb250ZW50cztcbiAgICAgICAgICAgIGlmIChhZnRlckRvYykge1xuICAgICAgICAgICAgICAgIGRvYy5jb21tZW50ID0gZG9jLmNvbW1lbnQgPyBgJHtkb2MuY29tbWVudH1cXG4ke2NvbW1lbnR9YCA6IGNvbW1lbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChhZnRlckVtcHR5TGluZSB8fCBkb2MuZGlyZWN0aXZlcy5tYXJrZXIgfHwgIWRjKSB7XG4gICAgICAgICAgICAgICAgZG9jLmNvbW1lbnRCZWZvcmUgPSBjb21tZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNDb2xsZWN0aW9uKGRjKSAmJiAhZGMuZmxvdyAmJiBkYy5pdGVtcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgbGV0IGl0ID0gZGMuaXRlbXNbMF07XG4gICAgICAgICAgICAgICAgaWYgKGlzUGFpcihpdCkpXG4gICAgICAgICAgICAgICAgICAgIGl0ID0gaXQua2V5O1xuICAgICAgICAgICAgICAgIGNvbnN0IGNiID0gaXQuY29tbWVudEJlZm9yZTtcbiAgICAgICAgICAgICAgICBpdC5jb21tZW50QmVmb3JlID0gY2IgPyBgJHtjb21tZW50fVxcbiR7Y2J9YCA6IGNvbW1lbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjYiA9IGRjLmNvbW1lbnRCZWZvcmU7XG4gICAgICAgICAgICAgICAgZGMuY29tbWVudEJlZm9yZSA9IGNiID8gYCR7Y29tbWVudH1cXG4ke2NifWAgOiBjb21tZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChhZnRlckRvYykge1xuICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkoZG9jLmVycm9ycywgdGhpcy5lcnJvcnMpO1xuICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkoZG9jLndhcm5pbmdzLCB0aGlzLndhcm5pbmdzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRvYy5lcnJvcnMgPSB0aGlzLmVycm9ycztcbiAgICAgICAgICAgIGRvYy53YXJuaW5ncyA9IHRoaXMud2FybmluZ3M7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wcmVsdWRlID0gW107XG4gICAgICAgIHRoaXMuZXJyb3JzID0gW107XG4gICAgICAgIHRoaXMud2FybmluZ3MgPSBbXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3VycmVudCBzdHJlYW0gc3RhdHVzIGluZm9ybWF0aW9uLlxuICAgICAqXG4gICAgICogTW9zdGx5IHVzZWZ1bCBhdCB0aGUgZW5kIG9mIGlucHV0IGZvciBhbiBlbXB0eSBzdHJlYW0uXG4gICAgICovXG4gICAgc3RyZWFtSW5mbygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvbW1lbnQ6IHBhcnNlUHJlbHVkZSh0aGlzLnByZWx1ZGUpLmNvbW1lbnQsXG4gICAgICAgICAgICBkaXJlY3RpdmVzOiB0aGlzLmRpcmVjdGl2ZXMsXG4gICAgICAgICAgICBlcnJvcnM6IHRoaXMuZXJyb3JzLFxuICAgICAgICAgICAgd2FybmluZ3M6IHRoaXMud2FybmluZ3NcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29tcG9zZSB0b2tlbnMgaW50byBkb2N1bWVudHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZm9yY2VEb2MgLSBJZiB0aGUgc3RyZWFtIGNvbnRhaW5zIG5vIGRvY3VtZW50LCBzdGlsbCBlbWl0IGEgZmluYWwgZG9jdW1lbnQgaW5jbHVkaW5nIGFueSBjb21tZW50cyBhbmQgZGlyZWN0aXZlcyB0aGF0IHdvdWxkIGJlIGFwcGxpZWQgdG8gYSBzdWJzZXF1ZW50IGRvY3VtZW50LlxuICAgICAqIEBwYXJhbSBlbmRPZmZzZXQgLSBTaG91bGQgYmUgc2V0IGlmIGBmb3JjZURvY2AgaXMgYWxzbyBzZXQsIHRvIHNldCB0aGUgZG9jdW1lbnQgcmFuZ2UgZW5kIGFuZCB0byBpbmRpY2F0ZSBlcnJvcnMgY29ycmVjdGx5LlxuICAgICAqL1xuICAgICpjb21wb3NlKHRva2VucywgZm9yY2VEb2MgPSBmYWxzZSwgZW5kT2Zmc2V0ID0gLTEpIHtcbiAgICAgICAgZm9yIChjb25zdCB0b2tlbiBvZiB0b2tlbnMpXG4gICAgICAgICAgICB5aWVsZCogdGhpcy5uZXh0KHRva2VuKTtcbiAgICAgICAgeWllbGQqIHRoaXMuZW5kKGZvcmNlRG9jLCBlbmRPZmZzZXQpO1xuICAgIH1cbiAgICAvKiogQWR2YW5jZSB0aGUgY29tcG9zZXIgYnkgb25lIENTVCB0b2tlbi4gKi9cbiAgICAqbmV4dCh0b2tlbikge1xuICAgICAgICBzd2l0Y2ggKHRva2VuLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2RpcmVjdGl2ZSc6XG4gICAgICAgICAgICAgICAgdGhpcy5kaXJlY3RpdmVzLmFkZCh0b2tlbi5zb3VyY2UsIChvZmZzZXQsIG1lc3NhZ2UsIHdhcm5pbmcpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcG9zID0gZ2V0RXJyb3JQb3ModG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICBwb3NbMF0gKz0gb2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uRXJyb3IocG9zLCAnQkFEX0RJUkVDVElWRScsIG1lc3NhZ2UsIHdhcm5pbmcpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMucHJlbHVkZS5wdXNoKHRva2VuLnNvdXJjZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5hdERpcmVjdGl2ZXMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnZG9jdW1lbnQnOiB7XG4gICAgICAgICAgICAgICAgY29uc3QgZG9jID0gY29tcG9zZURvYyh0aGlzLm9wdGlvbnMsIHRoaXMuZGlyZWN0aXZlcywgdG9rZW4sIHRoaXMub25FcnJvcik7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYXREaXJlY3RpdmVzICYmICFkb2MuZGlyZWN0aXZlcy5tYXJrZXIpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25FcnJvcih0b2tlbiwgJ01JU1NJTkdfQ0hBUicsICdNaXNzaW5nIGRpcmVjdGl2ZXMtZW5kIGluZGljYXRvciBsaW5lJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWNvcmF0ZShkb2MsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5kb2MpXG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMuZG9jO1xuICAgICAgICAgICAgICAgIHRoaXMuZG9jID0gZG9jO1xuICAgICAgICAgICAgICAgIHRoaXMuYXREaXJlY3RpdmVzID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdieXRlLW9yZGVyLW1hcmsnOlxuICAgICAgICAgICAgY2FzZSAnc3BhY2UnOlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnY29tbWVudCc6XG4gICAgICAgICAgICBjYXNlICduZXdsaW5lJzpcbiAgICAgICAgICAgICAgICB0aGlzLnByZWx1ZGUucHVzaCh0b2tlbi5zb3VyY2UpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnZXJyb3InOiB7XG4gICAgICAgICAgICAgICAgY29uc3QgbXNnID0gdG9rZW4uc291cmNlXG4gICAgICAgICAgICAgICAgICAgID8gYCR7dG9rZW4ubWVzc2FnZX06ICR7SlNPTi5zdHJpbmdpZnkodG9rZW4uc291cmNlKX1gXG4gICAgICAgICAgICAgICAgICAgIDogdG9rZW4ubWVzc2FnZTtcbiAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBZQU1MUGFyc2VFcnJvcihnZXRFcnJvclBvcyh0b2tlbiksICdVTkVYUEVDVEVEX1RPS0VOJywgbXNnKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5hdERpcmVjdGl2ZXMgfHwgIXRoaXMuZG9jKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVycm9ycy5wdXNoKGVycm9yKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZG9jLmVycm9ycy5wdXNoKGVycm9yKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ2RvYy1lbmQnOiB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmRvYykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtc2cgPSAnVW5leHBlY3RlZCBkb2MtZW5kIHdpdGhvdXQgcHJlY2VkaW5nIGRvY3VtZW50JztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lcnJvcnMucHVzaChuZXcgWUFNTFBhcnNlRXJyb3IoZ2V0RXJyb3JQb3ModG9rZW4pLCAnVU5FWFBFQ1RFRF9UT0tFTicsIG1zZykpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgZW5kID0gcmVzb2x2ZUVuZCh0b2tlbi5lbmQsIHRva2VuLm9mZnNldCArIHRva2VuLnNvdXJjZS5sZW5ndGgsIHRoaXMuZG9jLm9wdGlvbnMuc3RyaWN0LCB0aGlzLm9uRXJyb3IpO1xuICAgICAgICAgICAgICAgIHRoaXMuZGVjb3JhdGUodGhpcy5kb2MsIHRydWUpO1xuICAgICAgICAgICAgICAgIGlmIChlbmQuY29tbWVudCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkYyA9IHRoaXMuZG9jLmNvbW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZG9jLmNvbW1lbnQgPSBkYyA/IGAke2RjfVxcbiR7ZW5kLmNvbW1lbnR9YCA6IGVuZC5jb21tZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmRvYy5yYW5nZVsyXSA9IGVuZC5vZmZzZXQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRoaXMuZXJyb3JzLnB1c2gobmV3IFlBTUxQYXJzZUVycm9yKGdldEVycm9yUG9zKHRva2VuKSwgJ1VORVhQRUNURURfVE9LRU4nLCBgVW5zdXBwb3J0ZWQgdG9rZW4gJHt0b2tlbi50eXBlfWApKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsIGF0IGVuZCBvZiBpbnB1dCB0byB5aWVsZCBhbnkgcmVtYWluaW5nIGRvY3VtZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIGZvcmNlRG9jIC0gSWYgdGhlIHN0cmVhbSBjb250YWlucyBubyBkb2N1bWVudCwgc3RpbGwgZW1pdCBhIGZpbmFsIGRvY3VtZW50IGluY2x1ZGluZyBhbnkgY29tbWVudHMgYW5kIGRpcmVjdGl2ZXMgdGhhdCB3b3VsZCBiZSBhcHBsaWVkIHRvIGEgc3Vic2VxdWVudCBkb2N1bWVudC5cbiAgICAgKiBAcGFyYW0gZW5kT2Zmc2V0IC0gU2hvdWxkIGJlIHNldCBpZiBgZm9yY2VEb2NgIGlzIGFsc28gc2V0LCB0byBzZXQgdGhlIGRvY3VtZW50IHJhbmdlIGVuZCBhbmQgdG8gaW5kaWNhdGUgZXJyb3JzIGNvcnJlY3RseS5cbiAgICAgKi9cbiAgICAqZW5kKGZvcmNlRG9jID0gZmFsc2UsIGVuZE9mZnNldCA9IC0xKSB7XG4gICAgICAgIGlmICh0aGlzLmRvYykge1xuICAgICAgICAgICAgdGhpcy5kZWNvcmF0ZSh0aGlzLmRvYywgdHJ1ZSk7XG4gICAgICAgICAgICB5aWVsZCB0aGlzLmRvYztcbiAgICAgICAgICAgIHRoaXMuZG9jID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChmb3JjZURvYykge1xuICAgICAgICAgICAgY29uc3Qgb3B0cyA9IE9iamVjdC5hc3NpZ24oeyBkaXJlY3RpdmVzOiB0aGlzLmRpcmVjdGl2ZXMgfSwgdGhpcy5vcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGRvYyA9IG5ldyBEb2N1bWVudCh1bmRlZmluZWQsIG9wdHMpO1xuICAgICAgICAgICAgaWYgKHRoaXMuYXREaXJlY3RpdmVzKVxuICAgICAgICAgICAgICAgIHRoaXMub25FcnJvcihlbmRPZmZzZXQsICdNSVNTSU5HX0NIQVInLCAnTWlzc2luZyBkaXJlY3RpdmVzLWVuZCBpbmRpY2F0b3IgbGluZScpO1xuICAgICAgICAgICAgZG9jLnJhbmdlID0gWzAsIGVuZE9mZnNldCwgZW5kT2Zmc2V0XTtcbiAgICAgICAgICAgIHRoaXMuZGVjb3JhdGUoZG9jLCBmYWxzZSk7XG4gICAgICAgICAgICB5aWVsZCBkb2M7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCB7IENvbXBvc2VyIH07XG4iLCAiZXhwb3J0IHsgY3JlYXRlU2NhbGFyVG9rZW4sIHJlc29sdmVBc1NjYWxhciwgc2V0U2NhbGFyVmFsdWUgfSBmcm9tICcuL2NzdC1zY2FsYXIuanMnO1xuZXhwb3J0IHsgc3RyaW5naWZ5IH0gZnJvbSAnLi9jc3Qtc3RyaW5naWZ5LmpzJztcbmV4cG9ydCB7IHZpc2l0IH0gZnJvbSAnLi9jc3QtdmlzaXQuanMnO1xuXG4vKiogVGhlIGJ5dGUgb3JkZXIgbWFyayAqL1xuY29uc3QgQk9NID0gJ1xcdXtGRUZGfSc7XG4vKiogU3RhcnQgb2YgZG9jLW1vZGUgKi9cbmNvbnN0IERPQ1VNRU5UID0gJ1xceDAyJzsgLy8gQzA6IFN0YXJ0IG9mIFRleHRcbi8qKiBVbmV4cGVjdGVkIGVuZCBvZiBmbG93LW1vZGUgKi9cbmNvbnN0IEZMT1dfRU5EID0gJ1xceDE4JzsgLy8gQzA6IENhbmNlbFxuLyoqIE5leHQgdG9rZW4gaXMgYSBzY2FsYXIgdmFsdWUgKi9cbmNvbnN0IFNDQUxBUiA9ICdcXHgxZic7IC8vIEMwOiBVbml0IFNlcGFyYXRvclxuLyoqIEByZXR1cm5zIGB0cnVlYCBpZiBgdG9rZW5gIGlzIGEgZmxvdyBvciBibG9jayBjb2xsZWN0aW9uICovXG5jb25zdCBpc0NvbGxlY3Rpb24gPSAodG9rZW4pID0+ICEhdG9rZW4gJiYgJ2l0ZW1zJyBpbiB0b2tlbjtcbi8qKiBAcmV0dXJucyBgdHJ1ZWAgaWYgYHRva2VuYCBpcyBhIGZsb3cgb3IgYmxvY2sgc2NhbGFyOyBub3QgYW4gYWxpYXMgKi9cbmNvbnN0IGlzU2NhbGFyID0gKHRva2VuKSA9PiAhIXRva2VuICYmXG4gICAgKHRva2VuLnR5cGUgPT09ICdzY2FsYXInIHx8XG4gICAgICAgIHRva2VuLnR5cGUgPT09ICdzaW5nbGUtcXVvdGVkLXNjYWxhcicgfHxcbiAgICAgICAgdG9rZW4udHlwZSA9PT0gJ2RvdWJsZS1xdW90ZWQtc2NhbGFyJyB8fFxuICAgICAgICB0b2tlbi50eXBlID09PSAnYmxvY2stc2NhbGFyJyk7XG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuLyoqIEdldCBhIHByaW50YWJsZSByZXByZXNlbnRhdGlvbiBvZiBhIGxleGVyIHRva2VuICovXG5mdW5jdGlvbiBwcmV0dHlUb2tlbih0b2tlbikge1xuICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgICAgY2FzZSBCT006XG4gICAgICAgICAgICByZXR1cm4gJzxCT00+JztcbiAgICAgICAgY2FzZSBET0NVTUVOVDpcbiAgICAgICAgICAgIHJldHVybiAnPERPQz4nO1xuICAgICAgICBjYXNlIEZMT1dfRU5EOlxuICAgICAgICAgICAgcmV0dXJuICc8RkxPV19FTkQ+JztcbiAgICAgICAgY2FzZSBTQ0FMQVI6XG4gICAgICAgICAgICByZXR1cm4gJzxTQ0FMQVI+JztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh0b2tlbik7XG4gICAgfVxufVxuLyoqIElkZW50aWZ5IHRoZSB0eXBlIG9mIGEgbGV4ZXIgdG9rZW4uIE1heSByZXR1cm4gYG51bGxgIGZvciB1bmtub3duIHRva2Vucy4gKi9cbmZ1bmN0aW9uIHRva2VuVHlwZShzb3VyY2UpIHtcbiAgICBzd2l0Y2ggKHNvdXJjZSkge1xuICAgICAgICBjYXNlIEJPTTpcbiAgICAgICAgICAgIHJldHVybiAnYnl0ZS1vcmRlci1tYXJrJztcbiAgICAgICAgY2FzZSBET0NVTUVOVDpcbiAgICAgICAgICAgIHJldHVybiAnZG9jLW1vZGUnO1xuICAgICAgICBjYXNlIEZMT1dfRU5EOlxuICAgICAgICAgICAgcmV0dXJuICdmbG93LWVycm9yLWVuZCc7XG4gICAgICAgIGNhc2UgU0NBTEFSOlxuICAgICAgICAgICAgcmV0dXJuICdzY2FsYXInO1xuICAgICAgICBjYXNlICctLS0nOlxuICAgICAgICAgICAgcmV0dXJuICdkb2Mtc3RhcnQnO1xuICAgICAgICBjYXNlICcuLi4nOlxuICAgICAgICAgICAgcmV0dXJuICdkb2MtZW5kJztcbiAgICAgICAgY2FzZSAnJzpcbiAgICAgICAgY2FzZSAnXFxuJzpcbiAgICAgICAgY2FzZSAnXFxyXFxuJzpcbiAgICAgICAgICAgIHJldHVybiAnbmV3bGluZSc7XG4gICAgICAgIGNhc2UgJy0nOlxuICAgICAgICAgICAgcmV0dXJuICdzZXEtaXRlbS1pbmQnO1xuICAgICAgICBjYXNlICc/JzpcbiAgICAgICAgICAgIHJldHVybiAnZXhwbGljaXQta2V5LWluZCc7XG4gICAgICAgIGNhc2UgJzonOlxuICAgICAgICAgICAgcmV0dXJuICdtYXAtdmFsdWUtaW5kJztcbiAgICAgICAgY2FzZSAneyc6XG4gICAgICAgICAgICByZXR1cm4gJ2Zsb3ctbWFwLXN0YXJ0JztcbiAgICAgICAgY2FzZSAnfSc6XG4gICAgICAgICAgICByZXR1cm4gJ2Zsb3ctbWFwLWVuZCc7XG4gICAgICAgIGNhc2UgJ1snOlxuICAgICAgICAgICAgcmV0dXJuICdmbG93LXNlcS1zdGFydCc7XG4gICAgICAgIGNhc2UgJ10nOlxuICAgICAgICAgICAgcmV0dXJuICdmbG93LXNlcS1lbmQnO1xuICAgICAgICBjYXNlICcsJzpcbiAgICAgICAgICAgIHJldHVybiAnY29tbWEnO1xuICAgIH1cbiAgICBzd2l0Y2ggKHNvdXJjZVswXSkge1xuICAgICAgICBjYXNlICcgJzpcbiAgICAgICAgY2FzZSAnXFx0JzpcbiAgICAgICAgICAgIHJldHVybiAnc3BhY2UnO1xuICAgICAgICBjYXNlICcjJzpcbiAgICAgICAgICAgIHJldHVybiAnY29tbWVudCc7XG4gICAgICAgIGNhc2UgJyUnOlxuICAgICAgICAgICAgcmV0dXJuICdkaXJlY3RpdmUtbGluZSc7XG4gICAgICAgIGNhc2UgJyonOlxuICAgICAgICAgICAgcmV0dXJuICdhbGlhcyc7XG4gICAgICAgIGNhc2UgJyYnOlxuICAgICAgICAgICAgcmV0dXJuICdhbmNob3InO1xuICAgICAgICBjYXNlICchJzpcbiAgICAgICAgICAgIHJldHVybiAndGFnJztcbiAgICAgICAgY2FzZSBcIidcIjpcbiAgICAgICAgICAgIHJldHVybiAnc2luZ2xlLXF1b3RlZC1zY2FsYXInO1xuICAgICAgICBjYXNlICdcIic6XG4gICAgICAgICAgICByZXR1cm4gJ2RvdWJsZS1xdW90ZWQtc2NhbGFyJztcbiAgICAgICAgY2FzZSAnfCc6XG4gICAgICAgIGNhc2UgJz4nOlxuICAgICAgICAgICAgcmV0dXJuICdibG9jay1zY2FsYXItaGVhZGVyJztcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5cbmV4cG9ydCB7IEJPTSwgRE9DVU1FTlQsIEZMT1dfRU5ELCBTQ0FMQVIsIGlzQ29sbGVjdGlvbiwgaXNTY2FsYXIsIHByZXR0eVRva2VuLCB0b2tlblR5cGUgfTtcbiIsICJpbXBvcnQgeyByZXNvbHZlQmxvY2tTY2FsYXIgfSBmcm9tICcuLi9jb21wb3NlL3Jlc29sdmUtYmxvY2stc2NhbGFyLmpzJztcbmltcG9ydCB7IHJlc29sdmVGbG93U2NhbGFyIH0gZnJvbSAnLi4vY29tcG9zZS9yZXNvbHZlLWZsb3ctc2NhbGFyLmpzJztcbmltcG9ydCB7IFlBTUxQYXJzZUVycm9yIH0gZnJvbSAnLi4vZXJyb3JzLmpzJztcbmltcG9ydCB7IHN0cmluZ2lmeVN0cmluZyB9IGZyb20gJy4uL3N0cmluZ2lmeS9zdHJpbmdpZnlTdHJpbmcuanMnO1xuXG5mdW5jdGlvbiByZXNvbHZlQXNTY2FsYXIodG9rZW4sIHN0cmljdCA9IHRydWUsIG9uRXJyb3IpIHtcbiAgICBpZiAodG9rZW4pIHtcbiAgICAgICAgY29uc3QgX29uRXJyb3IgPSAocG9zLCBjb2RlLCBtZXNzYWdlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBvZmZzZXQgPSB0eXBlb2YgcG9zID09PSAnbnVtYmVyJyA/IHBvcyA6IEFycmF5LmlzQXJyYXkocG9zKSA/IHBvc1swXSA6IHBvcy5vZmZzZXQ7XG4gICAgICAgICAgICBpZiAob25FcnJvcilcbiAgICAgICAgICAgICAgICBvbkVycm9yKG9mZnNldCwgY29kZSwgbWVzc2FnZSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFlBTUxQYXJzZUVycm9yKFtvZmZzZXQsIG9mZnNldCArIDFdLCBjb2RlLCBtZXNzYWdlKTtcbiAgICAgICAgfTtcbiAgICAgICAgc3dpdGNoICh0b2tlbi50eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdzY2FsYXInOlxuICAgICAgICAgICAgY2FzZSAnc2luZ2xlLXF1b3RlZC1zY2FsYXInOlxuICAgICAgICAgICAgY2FzZSAnZG91YmxlLXF1b3RlZC1zY2FsYXInOlxuICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlRmxvd1NjYWxhcih0b2tlbiwgc3RyaWN0LCBfb25FcnJvcik7XG4gICAgICAgICAgICBjYXNlICdibG9jay1zY2FsYXInOlxuICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlQmxvY2tTY2FsYXIodG9rZW4sIHN0cmljdCwgX29uRXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgc2NhbGFyIHRva2VuIHdpdGggYHZhbHVlYFxuICpcbiAqIFZhbHVlcyB0aGF0IHJlcHJlc2VudCBhbiBhY3R1YWwgc3RyaW5nIGJ1dCBtYXkgYmUgcGFyc2VkIGFzIGEgZGlmZmVyZW50IHR5cGUgc2hvdWxkIHVzZSBhIGB0eXBlYCBvdGhlciB0aGFuIGAnUExBSU4nYCxcbiAqIGFzIHRoaXMgZnVuY3Rpb24gZG9lcyBub3Qgc3VwcG9ydCBhbnkgc2NoZW1hIG9wZXJhdGlvbnMgYW5kIHdvbid0IGNoZWNrIGZvciBzdWNoIGNvbmZsaWN0cy5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgVGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgdmFsdWUsIHdoaWNoIHdpbGwgaGF2ZSBpdHMgY29udGVudCBwcm9wZXJseSBpbmRlbnRlZC5cbiAqIEBwYXJhbSBjb250ZXh0LmVuZCBDb21tZW50cyBhbmQgd2hpdGVzcGFjZSBhZnRlciB0aGUgZW5kIG9mIHRoZSB2YWx1ZSwgb3IgYWZ0ZXIgdGhlIGJsb2NrIHNjYWxhciBoZWFkZXIuIElmIHVuZGVmaW5lZCwgYSBuZXdsaW5lIHdpbGwgYmUgYWRkZWQuXG4gKiBAcGFyYW0gY29udGV4dC5pbXBsaWNpdEtleSBCZWluZyB3aXRoaW4gYW4gaW1wbGljaXQga2V5IG1heSBhZmZlY3QgdGhlIHJlc29sdmVkIHR5cGUgb2YgdGhlIHRva2VuJ3MgdmFsdWUuXG4gKiBAcGFyYW0gY29udGV4dC5pbmRlbnQgVGhlIGluZGVudCBsZXZlbCBvZiB0aGUgdG9rZW4uXG4gKiBAcGFyYW0gY29udGV4dC5pbkZsb3cgSXMgdGhpcyBzY2FsYXIgd2l0aGluIGEgZmxvdyBjb2xsZWN0aW9uPyBUaGlzIG1heSBhZmZlY3QgdGhlIHJlc29sdmVkIHR5cGUgb2YgdGhlIHRva2VuJ3MgdmFsdWUuXG4gKiBAcGFyYW0gY29udGV4dC5vZmZzZXQgVGhlIG9mZnNldCBwb3NpdGlvbiBvZiB0aGUgdG9rZW4uXG4gKiBAcGFyYW0gY29udGV4dC50eXBlIFRoZSBwcmVmZXJyZWQgdHlwZSBvZiB0aGUgc2NhbGFyIHRva2VuLiBJZiB1bmRlZmluZWQsIHRoZSBwcmV2aW91cyB0eXBlIG9mIHRoZSBgdG9rZW5gIHdpbGwgYmUgdXNlZCwgZGVmYXVsdGluZyB0byBgJ1BMQUlOJ2AuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVNjYWxhclRva2VuKHZhbHVlLCBjb250ZXh0KSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHsgaW1wbGljaXRLZXkgPSBmYWxzZSwgaW5kZW50LCBpbkZsb3cgPSBmYWxzZSwgb2Zmc2V0ID0gLTEsIHR5cGUgPSAnUExBSU4nIH0gPSBjb250ZXh0O1xuICAgIGNvbnN0IHNvdXJjZSA9IHN0cmluZ2lmeVN0cmluZyh7IHR5cGUsIHZhbHVlIH0sIHtcbiAgICAgICAgaW1wbGljaXRLZXksXG4gICAgICAgIGluZGVudDogaW5kZW50ID4gMCA/ICcgJy5yZXBlYXQoaW5kZW50KSA6ICcnLFxuICAgICAgICBpbkZsb3csXG4gICAgICAgIG9wdGlvbnM6IHsgYmxvY2tRdW90ZTogdHJ1ZSwgbGluZVdpZHRoOiAtMSB9XG4gICAgfSk7XG4gICAgY29uc3QgZW5kID0gKF9hID0gY29udGV4dC5lbmQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFtcbiAgICAgICAgeyB0eXBlOiAnbmV3bGluZScsIG9mZnNldDogLTEsIGluZGVudCwgc291cmNlOiAnXFxuJyB9XG4gICAgXTtcbiAgICBzd2l0Y2ggKHNvdXJjZVswXSkge1xuICAgICAgICBjYXNlICd8JzpcbiAgICAgICAgY2FzZSAnPic6IHtcbiAgICAgICAgICAgIGNvbnN0IGhlID0gc291cmNlLmluZGV4T2YoJ1xcbicpO1xuICAgICAgICAgICAgY29uc3QgaGVhZCA9IHNvdXJjZS5zdWJzdHJpbmcoMCwgaGUpO1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IHNvdXJjZS5zdWJzdHJpbmcoaGUgKyAxKSArICdcXG4nO1xuICAgICAgICAgICAgY29uc3QgcHJvcHMgPSBbXG4gICAgICAgICAgICAgICAgeyB0eXBlOiAnYmxvY2stc2NhbGFyLWhlYWRlcicsIG9mZnNldCwgaW5kZW50LCBzb3VyY2U6IGhlYWQgfVxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIGlmICghYWRkRW5kdG9CbG9ja1Byb3BzKHByb3BzLCBlbmQpKVxuICAgICAgICAgICAgICAgIHByb3BzLnB1c2goeyB0eXBlOiAnbmV3bGluZScsIG9mZnNldDogLTEsIGluZGVudCwgc291cmNlOiAnXFxuJyB9KTtcbiAgICAgICAgICAgIHJldHVybiB7IHR5cGU6ICdibG9jay1zY2FsYXInLCBvZmZzZXQsIGluZGVudCwgcHJvcHMsIHNvdXJjZTogYm9keSB9O1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ1wiJzpcbiAgICAgICAgICAgIHJldHVybiB7IHR5cGU6ICdkb3VibGUtcXVvdGVkLXNjYWxhcicsIG9mZnNldCwgaW5kZW50LCBzb3VyY2UsIGVuZCB9O1xuICAgICAgICBjYXNlIFwiJ1wiOlxuICAgICAgICAgICAgcmV0dXJuIHsgdHlwZTogJ3NpbmdsZS1xdW90ZWQtc2NhbGFyJywgb2Zmc2V0LCBpbmRlbnQsIHNvdXJjZSwgZW5kIH07XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4geyB0eXBlOiAnc2NhbGFyJywgb2Zmc2V0LCBpbmRlbnQsIHNvdXJjZSwgZW5kIH07XG4gICAgfVxufVxuLyoqXG4gKiBTZXQgdGhlIHZhbHVlIG9mIGB0b2tlbmAgdG8gdGhlIGdpdmVuIHN0cmluZyBgdmFsdWVgLCBvdmVyd3JpdGluZyBhbnkgcHJldmlvdXMgY29udGVudHMgYW5kIHR5cGUgdGhhdCBpdCBtYXkgaGF2ZS5cbiAqXG4gKiBCZXN0IGVmZm9ydHMgYXJlIG1hZGUgdG8gcmV0YWluIGFueSBjb21tZW50cyBwcmV2aW91c2x5IGFzc29jaWF0ZWQgd2l0aCB0aGUgYHRva2VuYCxcbiAqIHRob3VnaCBhbGwgY29udGVudHMgd2l0aGluIGEgY29sbGVjdGlvbidzIGBpdGVtc2Agd2lsbCBiZSBvdmVyd3JpdHRlbi5cbiAqXG4gKiBWYWx1ZXMgdGhhdCByZXByZXNlbnQgYW4gYWN0dWFsIHN0cmluZyBidXQgbWF5IGJlIHBhcnNlZCBhcyBhIGRpZmZlcmVudCB0eXBlIHNob3VsZCB1c2UgYSBgdHlwZWAgb3RoZXIgdGhhbiBgJ1BMQUlOJ2AsXG4gKiBhcyB0aGlzIGZ1bmN0aW9uIGRvZXMgbm90IHN1cHBvcnQgYW55IHNjaGVtYSBvcGVyYXRpb25zIGFuZCB3b24ndCBjaGVjayBmb3Igc3VjaCBjb25mbGljdHMuXG4gKlxuICogQHBhcmFtIHRva2VuIEFueSB0b2tlbi4gSWYgaXQgZG9lcyBub3QgaW5jbHVkZSBhbiBgaW5kZW50YCB2YWx1ZSwgdGhlIHZhbHVlIHdpbGwgYmUgc3RyaW5naWZpZWQgYXMgaWYgaXQgd2VyZSBhbiBpbXBsaWNpdCBrZXkuXG4gKiBAcGFyYW0gdmFsdWUgVGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgdmFsdWUsIHdoaWNoIHdpbGwgaGF2ZSBpdHMgY29udGVudCBwcm9wZXJseSBpbmRlbnRlZC5cbiAqIEBwYXJhbSBjb250ZXh0LmFmdGVyS2V5IEluIG1vc3QgY2FzZXMsIHZhbHVlcyBhZnRlciBhIGtleSBzaG91bGQgaGF2ZSBhbiBhZGRpdGlvbmFsIGxldmVsIG9mIGluZGVudGF0aW9uLlxuICogQHBhcmFtIGNvbnRleHQuaW1wbGljaXRLZXkgQmVpbmcgd2l0aGluIGFuIGltcGxpY2l0IGtleSBtYXkgYWZmZWN0IHRoZSByZXNvbHZlZCB0eXBlIG9mIHRoZSB0b2tlbidzIHZhbHVlLlxuICogQHBhcmFtIGNvbnRleHQuaW5GbG93IEJlaW5nIHdpdGhpbiBhIGZsb3cgY29sbGVjdGlvbiBtYXkgYWZmZWN0IHRoZSByZXNvbHZlZCB0eXBlIG9mIHRoZSB0b2tlbidzIHZhbHVlLlxuICogQHBhcmFtIGNvbnRleHQudHlwZSBUaGUgcHJlZmVycmVkIHR5cGUgb2YgdGhlIHNjYWxhciB0b2tlbi4gSWYgdW5kZWZpbmVkLCB0aGUgcHJldmlvdXMgdHlwZSBvZiB0aGUgYHRva2VuYCB3aWxsIGJlIHVzZWQsIGRlZmF1bHRpbmcgdG8gYCdQTEFJTidgLlxuICovXG5mdW5jdGlvbiBzZXRTY2FsYXJWYWx1ZSh0b2tlbiwgdmFsdWUsIGNvbnRleHQgPSB7fSkge1xuICAgIGxldCB7IGFmdGVyS2V5ID0gZmFsc2UsIGltcGxpY2l0S2V5ID0gZmFsc2UsIGluRmxvdyA9IGZhbHNlLCB0eXBlIH0gPSBjb250ZXh0O1xuICAgIGxldCBpbmRlbnQgPSAnaW5kZW50JyBpbiB0b2tlbiA/IHRva2VuLmluZGVudCA6IG51bGw7XG4gICAgaWYgKGFmdGVyS2V5ICYmIHR5cGVvZiBpbmRlbnQgPT09ICdudW1iZXInKVxuICAgICAgICBpbmRlbnQgKz0gMjtcbiAgICBpZiAoIXR5cGUpXG4gICAgICAgIHN3aXRjaCAodG9rZW4udHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnc2luZ2xlLXF1b3RlZC1zY2FsYXInOlxuICAgICAgICAgICAgICAgIHR5cGUgPSAnUVVPVEVfU0lOR0xFJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2RvdWJsZS1xdW90ZWQtc2NhbGFyJzpcbiAgICAgICAgICAgICAgICB0eXBlID0gJ1FVT1RFX0RPVUJMRSc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdibG9jay1zY2FsYXInOiB7XG4gICAgICAgICAgICAgICAgY29uc3QgaGVhZGVyID0gdG9rZW4ucHJvcHNbMF07XG4gICAgICAgICAgICAgICAgaWYgKGhlYWRlci50eXBlICE9PSAnYmxvY2stc2NhbGFyLWhlYWRlcicpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBibG9jayBzY2FsYXIgaGVhZGVyJyk7XG4gICAgICAgICAgICAgICAgdHlwZSA9IGhlYWRlci5zb3VyY2VbMF0gPT09ICc+JyA/ICdCTE9DS19GT0xERUQnIDogJ0JMT0NLX0xJVEVSQUwnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0eXBlID0gJ1BMQUlOJztcbiAgICAgICAgfVxuICAgIGNvbnN0IHNvdXJjZSA9IHN0cmluZ2lmeVN0cmluZyh7IHR5cGUsIHZhbHVlIH0sIHtcbiAgICAgICAgaW1wbGljaXRLZXk6IGltcGxpY2l0S2V5IHx8IGluZGVudCA9PT0gbnVsbCxcbiAgICAgICAgaW5kZW50OiBpbmRlbnQgIT09IG51bGwgJiYgaW5kZW50ID4gMCA/ICcgJy5yZXBlYXQoaW5kZW50KSA6ICcnLFxuICAgICAgICBpbkZsb3csXG4gICAgICAgIG9wdGlvbnM6IHsgYmxvY2tRdW90ZTogdHJ1ZSwgbGluZVdpZHRoOiAtMSB9XG4gICAgfSk7XG4gICAgc3dpdGNoIChzb3VyY2VbMF0pIHtcbiAgICAgICAgY2FzZSAnfCc6XG4gICAgICAgIGNhc2UgJz4nOlxuICAgICAgICAgICAgc2V0QmxvY2tTY2FsYXJWYWx1ZSh0b2tlbiwgc291cmNlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdcIic6XG4gICAgICAgICAgICBzZXRGbG93U2NhbGFyVmFsdWUodG9rZW4sIHNvdXJjZSwgJ2RvdWJsZS1xdW90ZWQtc2NhbGFyJyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIidcIjpcbiAgICAgICAgICAgIHNldEZsb3dTY2FsYXJWYWx1ZSh0b2tlbiwgc291cmNlLCAnc2luZ2xlLXF1b3RlZC1zY2FsYXInKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgc2V0Rmxvd1NjYWxhclZhbHVlKHRva2VuLCBzb3VyY2UsICdzY2FsYXInKTtcbiAgICB9XG59XG5mdW5jdGlvbiBzZXRCbG9ja1NjYWxhclZhbHVlKHRva2VuLCBzb3VyY2UpIHtcbiAgICBjb25zdCBoZSA9IHNvdXJjZS5pbmRleE9mKCdcXG4nKTtcbiAgICBjb25zdCBoZWFkID0gc291cmNlLnN1YnN0cmluZygwLCBoZSk7XG4gICAgY29uc3QgYm9keSA9IHNvdXJjZS5zdWJzdHJpbmcoaGUgKyAxKSArICdcXG4nO1xuICAgIGlmICh0b2tlbi50eXBlID09PSAnYmxvY2stc2NhbGFyJykge1xuICAgICAgICBjb25zdCBoZWFkZXIgPSB0b2tlbi5wcm9wc1swXTtcbiAgICAgICAgaWYgKGhlYWRlci50eXBlICE9PSAnYmxvY2stc2NhbGFyLWhlYWRlcicpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYmxvY2sgc2NhbGFyIGhlYWRlcicpO1xuICAgICAgICBoZWFkZXIuc291cmNlID0gaGVhZDtcbiAgICAgICAgdG9rZW4uc291cmNlID0gYm9keTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IHsgb2Zmc2V0IH0gPSB0b2tlbjtcbiAgICAgICAgY29uc3QgaW5kZW50ID0gJ2luZGVudCcgaW4gdG9rZW4gPyB0b2tlbi5pbmRlbnQgOiAtMTtcbiAgICAgICAgY29uc3QgcHJvcHMgPSBbXG4gICAgICAgICAgICB7IHR5cGU6ICdibG9jay1zY2FsYXItaGVhZGVyJywgb2Zmc2V0LCBpbmRlbnQsIHNvdXJjZTogaGVhZCB9XG4gICAgICAgIF07XG4gICAgICAgIGlmICghYWRkRW5kdG9CbG9ja1Byb3BzKHByb3BzLCAnZW5kJyBpbiB0b2tlbiA/IHRva2VuLmVuZCA6IHVuZGVmaW5lZCkpXG4gICAgICAgICAgICBwcm9wcy5wdXNoKHsgdHlwZTogJ25ld2xpbmUnLCBvZmZzZXQ6IC0xLCBpbmRlbnQsIHNvdXJjZTogJ1xcbicgfSk7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHRva2VuKSlcbiAgICAgICAgICAgIGlmIChrZXkgIT09ICd0eXBlJyAmJiBrZXkgIT09ICdvZmZzZXQnKVxuICAgICAgICAgICAgICAgIGRlbGV0ZSB0b2tlbltrZXldO1xuICAgICAgICBPYmplY3QuYXNzaWduKHRva2VuLCB7IHR5cGU6ICdibG9jay1zY2FsYXInLCBpbmRlbnQsIHByb3BzLCBzb3VyY2U6IGJvZHkgfSk7XG4gICAgfVxufVxuLyoqIEByZXR1cm5zIGB0cnVlYCBpZiBsYXN0IHRva2VuIGlzIGEgbmV3bGluZSAqL1xuZnVuY3Rpb24gYWRkRW5kdG9CbG9ja1Byb3BzKHByb3BzLCBlbmQpIHtcbiAgICBpZiAoZW5kKVxuICAgICAgICBmb3IgKGNvbnN0IHN0IG9mIGVuZClcbiAgICAgICAgICAgIHN3aXRjaCAoc3QudHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3NwYWNlJzpcbiAgICAgICAgICAgICAgICBjYXNlICdjb21tZW50JzpcbiAgICAgICAgICAgICAgICAgICAgcHJvcHMucHVzaChzdCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ25ld2xpbmUnOlxuICAgICAgICAgICAgICAgICAgICBwcm9wcy5wdXNoKHN0KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gc2V0Rmxvd1NjYWxhclZhbHVlKHRva2VuLCBzb3VyY2UsIHR5cGUpIHtcbiAgICBzd2l0Y2ggKHRva2VuLnR5cGUpIHtcbiAgICAgICAgY2FzZSAnc2NhbGFyJzpcbiAgICAgICAgY2FzZSAnZG91YmxlLXF1b3RlZC1zY2FsYXInOlxuICAgICAgICBjYXNlICdzaW5nbGUtcXVvdGVkLXNjYWxhcic6XG4gICAgICAgICAgICB0b2tlbi50eXBlID0gdHlwZTtcbiAgICAgICAgICAgIHRva2VuLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdibG9jay1zY2FsYXInOiB7XG4gICAgICAgICAgICBjb25zdCBlbmQgPSB0b2tlbi5wcm9wcy5zbGljZSgxKTtcbiAgICAgICAgICAgIGxldCBvYSA9IHNvdXJjZS5sZW5ndGg7XG4gICAgICAgICAgICBpZiAodG9rZW4ucHJvcHNbMF0udHlwZSA9PT0gJ2Jsb2NrLXNjYWxhci1oZWFkZXInKVxuICAgICAgICAgICAgICAgIG9hIC09IHRva2VuLnByb3BzWzBdLnNvdXJjZS5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHRvayBvZiBlbmQpXG4gICAgICAgICAgICAgICAgdG9rLm9mZnNldCArPSBvYTtcbiAgICAgICAgICAgIGRlbGV0ZSB0b2tlbi5wcm9wcztcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odG9rZW4sIHsgdHlwZSwgc291cmNlLCBlbmQgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdibG9jay1tYXAnOlxuICAgICAgICBjYXNlICdibG9jay1zZXEnOiB7XG4gICAgICAgICAgICBjb25zdCBvZmZzZXQgPSB0b2tlbi5vZmZzZXQgKyBzb3VyY2UubGVuZ3RoO1xuICAgICAgICAgICAgY29uc3QgbmwgPSB7IHR5cGU6ICduZXdsaW5lJywgb2Zmc2V0LCBpbmRlbnQ6IHRva2VuLmluZGVudCwgc291cmNlOiAnXFxuJyB9O1xuICAgICAgICAgICAgZGVsZXRlIHRva2VuLml0ZW1zO1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0b2tlbiwgeyB0eXBlLCBzb3VyY2UsIGVuZDogW25sXSB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgIGNvbnN0IGluZGVudCA9ICdpbmRlbnQnIGluIHRva2VuID8gdG9rZW4uaW5kZW50IDogLTE7XG4gICAgICAgICAgICBjb25zdCBlbmQgPSAnZW5kJyBpbiB0b2tlbiAmJiBBcnJheS5pc0FycmF5KHRva2VuLmVuZClcbiAgICAgICAgICAgICAgICA/IHRva2VuLmVuZC5maWx0ZXIoc3QgPT4gc3QudHlwZSA9PT0gJ3NwYWNlJyB8fFxuICAgICAgICAgICAgICAgICAgICBzdC50eXBlID09PSAnY29tbWVudCcgfHxcbiAgICAgICAgICAgICAgICAgICAgc3QudHlwZSA9PT0gJ25ld2xpbmUnKVxuICAgICAgICAgICAgICAgIDogW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyh0b2tlbikpXG4gICAgICAgICAgICAgICAgaWYgKGtleSAhPT0gJ3R5cGUnICYmIGtleSAhPT0gJ29mZnNldCcpXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0b2tlbltrZXldO1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0b2tlbiwgeyB0eXBlLCBpbmRlbnQsIHNvdXJjZSwgZW5kIH0pO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgeyBjcmVhdGVTY2FsYXJUb2tlbiwgcmVzb2x2ZUFzU2NhbGFyLCBzZXRTY2FsYXJWYWx1ZSB9O1xuIiwgIi8qKlxuICogU3RyaW5naWZ5IGEgQ1NUIGRvY3VtZW50LCB0b2tlbiwgb3IgY29sbGVjdGlvbiBpdGVtXG4gKlxuICogRmFpciB3YXJuaW5nOiBUaGlzIGFwcGxpZXMgbm8gdmFsaWRhdGlvbiB3aGF0c29ldmVyLCBhbmRcbiAqIHNpbXBseSBjb25jYXRlbmF0ZXMgdGhlIHNvdXJjZXMgaW4gdGhlaXIgbG9naWNhbCBvcmRlci5cbiAqL1xuY29uc3Qgc3RyaW5naWZ5ID0gKGNzdCkgPT4gJ3R5cGUnIGluIGNzdCA/IHN0cmluZ2lmeVRva2VuKGNzdCkgOiBzdHJpbmdpZnlJdGVtKGNzdCk7XG5mdW5jdGlvbiBzdHJpbmdpZnlUb2tlbih0b2tlbikge1xuICAgIHN3aXRjaCAodG9rZW4udHlwZSkge1xuICAgICAgICBjYXNlICdibG9jay1zY2FsYXInOiB7XG4gICAgICAgICAgICBsZXQgcmVzID0gJyc7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHRvayBvZiB0b2tlbi5wcm9wcylcbiAgICAgICAgICAgICAgICByZXMgKz0gc3RyaW5naWZ5VG9rZW4odG9rKTtcbiAgICAgICAgICAgIHJldHVybiByZXMgKyB0b2tlbi5zb3VyY2U7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnYmxvY2stbWFwJzpcbiAgICAgICAgY2FzZSAnYmxvY2stc2VxJzoge1xuICAgICAgICAgICAgbGV0IHJlcyA9ICcnO1xuICAgICAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIHRva2VuLml0ZW1zKVxuICAgICAgICAgICAgICAgIHJlcyArPSBzdHJpbmdpZnlJdGVtKGl0ZW0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdmbG93LWNvbGxlY3Rpb24nOiB7XG4gICAgICAgICAgICBsZXQgcmVzID0gdG9rZW4uc3RhcnQuc291cmNlO1xuICAgICAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIHRva2VuLml0ZW1zKVxuICAgICAgICAgICAgICAgIHJlcyArPSBzdHJpbmdpZnlJdGVtKGl0ZW0pO1xuICAgICAgICAgICAgZm9yIChjb25zdCBzdCBvZiB0b2tlbi5lbmQpXG4gICAgICAgICAgICAgICAgcmVzICs9IHN0LnNvdXJjZTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnZG9jdW1lbnQnOiB7XG4gICAgICAgICAgICBsZXQgcmVzID0gc3RyaW5naWZ5SXRlbSh0b2tlbik7XG4gICAgICAgICAgICBpZiAodG9rZW4uZW5kKVxuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qgc3Qgb2YgdG9rZW4uZW5kKVxuICAgICAgICAgICAgICAgICAgICByZXMgKz0gc3Quc291cmNlO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICBsZXQgcmVzID0gdG9rZW4uc291cmNlO1xuICAgICAgICAgICAgaWYgKCdlbmQnIGluIHRva2VuICYmIHRva2VuLmVuZClcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHN0IG9mIHRva2VuLmVuZClcbiAgICAgICAgICAgICAgICAgICAgcmVzICs9IHN0LnNvdXJjZTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBzdHJpbmdpZnlJdGVtKHsgc3RhcnQsIGtleSwgc2VwLCB2YWx1ZSB9KSB7XG4gICAgbGV0IHJlcyA9ICcnO1xuICAgIGZvciAoY29uc3Qgc3Qgb2Ygc3RhcnQpXG4gICAgICAgIHJlcyArPSBzdC5zb3VyY2U7XG4gICAgaWYgKGtleSlcbiAgICAgICAgcmVzICs9IHN0cmluZ2lmeVRva2VuKGtleSk7XG4gICAgaWYgKHNlcClcbiAgICAgICAgZm9yIChjb25zdCBzdCBvZiBzZXApXG4gICAgICAgICAgICByZXMgKz0gc3Quc291cmNlO1xuICAgIGlmICh2YWx1ZSlcbiAgICAgICAgcmVzICs9IHN0cmluZ2lmeVRva2VuKHZhbHVlKTtcbiAgICByZXR1cm4gcmVzO1xufVxuXG5leHBvcnQgeyBzdHJpbmdpZnkgfTtcbiIsICJjb25zdCBCUkVBSyA9IFN5bWJvbCgnYnJlYWsgdmlzaXQnKTtcbmNvbnN0IFNLSVAgPSBTeW1ib2woJ3NraXAgY2hpbGRyZW4nKTtcbmNvbnN0IFJFTU9WRSA9IFN5bWJvbCgncmVtb3ZlIGl0ZW0nKTtcbi8qKlxuICogQXBwbHkgYSB2aXNpdG9yIHRvIGEgQ1NUIGRvY3VtZW50IG9yIGl0ZW0uXG4gKlxuICogV2Fsa3MgdGhyb3VnaCB0aGUgdHJlZSAoZGVwdGgtZmlyc3QpIHN0YXJ0aW5nIGZyb20gdGhlIHJvb3QsIGNhbGxpbmcgYVxuICogYHZpc2l0b3JgIGZ1bmN0aW9uIHdpdGggdHdvIGFyZ3VtZW50cyB3aGVuIGVudGVyaW5nIGVhY2ggaXRlbTpcbiAqICAgLSBgaXRlbWA6IFRoZSBjdXJyZW50IGl0ZW0sIHdoaWNoIGluY2x1ZGVkIHRoZSBmb2xsb3dpbmcgbWVtYmVyczpcbiAqICAgICAtIGBzdGFydDogU291cmNlVG9rZW5bXWAgXHUyMDEzIFNvdXJjZSB0b2tlbnMgYmVmb3JlIHRoZSBrZXkgb3IgdmFsdWUsXG4gKiAgICAgICBwb3NzaWJseSBpbmNsdWRpbmcgaXRzIGFuY2hvciBvciB0YWcuXG4gKiAgICAgLSBga2V5PzogVG9rZW4gfCBudWxsYCBcdTIwMTMgU2V0IGZvciBwYWlyIHZhbHVlcy4gTWF5IHRoZW4gYmUgYG51bGxgLCBpZlxuICogICAgICAgdGhlIGtleSBiZWZvcmUgdGhlIGA6YCBzZXBhcmF0b3IgaXMgZW1wdHkuXG4gKiAgICAgLSBgc2VwPzogU291cmNlVG9rZW5bXWAgXHUyMDEzIFNvdXJjZSB0b2tlbnMgYmV0d2VlbiB0aGUga2V5IGFuZCB0aGUgdmFsdWUsXG4gKiAgICAgICB3aGljaCBzaG91bGQgaW5jbHVkZSB0aGUgYDpgIG1hcCB2YWx1ZSBpbmRpY2F0b3IgaWYgYHZhbHVlYCBpcyBzZXQuXG4gKiAgICAgLSBgdmFsdWU/OiBUb2tlbmAgXHUyMDEzIFRoZSB2YWx1ZSBvZiBhIHNlcXVlbmNlIGl0ZW0sIG9yIG9mIGEgbWFwIHBhaXIuXG4gKiAgIC0gYHBhdGhgOiBUaGUgc3RlcHMgZnJvbSB0aGUgcm9vdCB0byB0aGUgY3VycmVudCBub2RlLCBhcyBhbiBhcnJheSBvZlxuICogICAgIGBbJ2tleScgfCAndmFsdWUnLCBudW1iZXJdYCB0dXBsZXMuXG4gKlxuICogVGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgdmlzaXRvciBtYXkgYmUgdXNlZCB0byBjb250cm9sIHRoZSB0cmF2ZXJzYWw6XG4gKiAgIC0gYHVuZGVmaW5lZGAgKGRlZmF1bHQpOiBEbyBub3RoaW5nIGFuZCBjb250aW51ZVxuICogICAtIGB2aXNpdC5TS0lQYDogRG8gbm90IHZpc2l0IHRoZSBjaGlsZHJlbiBvZiB0aGlzIHRva2VuLCBjb250aW51ZSB3aXRoXG4gKiAgICAgIG5leHQgc2libGluZ1xuICogICAtIGB2aXNpdC5CUkVBS2A6IFRlcm1pbmF0ZSB0cmF2ZXJzYWwgY29tcGxldGVseVxuICogICAtIGB2aXNpdC5SRU1PVkVgOiBSZW1vdmUgdGhlIGN1cnJlbnQgaXRlbSwgdGhlbiBjb250aW51ZSB3aXRoIHRoZSBuZXh0IG9uZVxuICogICAtIGBudW1iZXJgOiBTZXQgdGhlIGluZGV4IG9mIHRoZSBuZXh0IHN0ZXAuIFRoaXMgaXMgdXNlZnVsIGVzcGVjaWFsbHkgaWZcbiAqICAgICB0aGUgaW5kZXggb2YgdGhlIGN1cnJlbnQgdG9rZW4gaGFzIGNoYW5nZWQuXG4gKiAgIC0gYGZ1bmN0aW9uYDogRGVmaW5lIHRoZSBuZXh0IHZpc2l0b3IgZm9yIHRoaXMgaXRlbS4gQWZ0ZXIgdGhlIG9yaWdpbmFsXG4gKiAgICAgdmlzaXRvciBpcyBjYWxsZWQgb24gaXRlbSBlbnRyeSwgbmV4dCB2aXNpdG9ycyBhcmUgY2FsbGVkIGFmdGVyIGhhbmRsaW5nXG4gKiAgICAgYSBub24tZW1wdHkgYGtleWAgYW5kIHdoZW4gZXhpdGluZyB0aGUgaXRlbS5cbiAqL1xuZnVuY3Rpb24gdmlzaXQoY3N0LCB2aXNpdG9yKSB7XG4gICAgaWYgKCd0eXBlJyBpbiBjc3QgJiYgY3N0LnR5cGUgPT09ICdkb2N1bWVudCcpXG4gICAgICAgIGNzdCA9IHsgc3RhcnQ6IGNzdC5zdGFydCwgdmFsdWU6IGNzdC52YWx1ZSB9O1xuICAgIF92aXNpdChPYmplY3QuZnJlZXplKFtdKSwgY3N0LCB2aXNpdG9yKTtcbn1cbi8vIFdpdGhvdXQgdGhlIGBhcyBzeW1ib2xgIGNhc3RzLCBUUyBkZWNsYXJlcyB0aGVzZSBpbiB0aGUgYHZpc2l0YFxuLy8gbmFtZXNwYWNlIHVzaW5nIGB2YXJgLCBidXQgdGhlbiBjb21wbGFpbnMgYWJvdXQgdGhhdCBiZWNhdXNlXG4vLyBgdW5pcXVlIHN5bWJvbGAgbXVzdCBiZSBgY29uc3RgLlxuLyoqIFRlcm1pbmF0ZSB2aXNpdCB0cmF2ZXJzYWwgY29tcGxldGVseSAqL1xudmlzaXQuQlJFQUsgPSBCUkVBSztcbi8qKiBEbyBub3QgdmlzaXQgdGhlIGNoaWxkcmVuIG9mIHRoZSBjdXJyZW50IGl0ZW0gKi9cbnZpc2l0LlNLSVAgPSBTS0lQO1xuLyoqIFJlbW92ZSB0aGUgY3VycmVudCBpdGVtICovXG52aXNpdC5SRU1PVkUgPSBSRU1PVkU7XG4vKiogRmluZCB0aGUgaXRlbSBhdCBgcGF0aGAgZnJvbSBgY3N0YCBhcyB0aGUgcm9vdCAqL1xudmlzaXQuaXRlbUF0UGF0aCA9IChjc3QsIHBhdGgpID0+IHtcbiAgICBsZXQgaXRlbSA9IGNzdDtcbiAgICBmb3IgKGNvbnN0IFtmaWVsZCwgaW5kZXhdIG9mIHBhdGgpIHtcbiAgICAgICAgY29uc3QgdG9rID0gaXRlbSAmJiBpdGVtW2ZpZWxkXTtcbiAgICAgICAgaWYgKHRvayAmJiAnaXRlbXMnIGluIHRvaykge1xuICAgICAgICAgICAgaXRlbSA9IHRvay5pdGVtc1tpbmRleF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIGl0ZW07XG59O1xuLyoqXG4gKiBHZXQgdGhlIGltbWVkaWF0ZSBwYXJlbnQgY29sbGVjdGlvbiBvZiB0aGUgaXRlbSBhdCBgcGF0aGAgZnJvbSBgY3N0YCBhcyB0aGUgcm9vdC5cbiAqXG4gKiBUaHJvd3MgYW4gZXJyb3IgaWYgdGhlIGNvbGxlY3Rpb24gaXMgbm90IGZvdW5kLCB3aGljaCBzaG91bGQgbmV2ZXIgaGFwcGVuIGlmIHRoZSBpdGVtIGl0c2VsZiBleGlzdHMuXG4gKi9cbnZpc2l0LnBhcmVudENvbGxlY3Rpb24gPSAoY3N0LCBwYXRoKSA9PiB7XG4gICAgY29uc3QgcGFyZW50ID0gdmlzaXQuaXRlbUF0UGF0aChjc3QsIHBhdGguc2xpY2UoMCwgLTEpKTtcbiAgICBjb25zdCBmaWVsZCA9IHBhdGhbcGF0aC5sZW5ndGggLSAxXVswXTtcbiAgICBjb25zdCBjb2xsID0gcGFyZW50ICYmIHBhcmVudFtmaWVsZF07XG4gICAgaWYgKGNvbGwgJiYgJ2l0ZW1zJyBpbiBjb2xsKVxuICAgICAgICByZXR1cm4gY29sbDtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1BhcmVudCBjb2xsZWN0aW9uIG5vdCBmb3VuZCcpO1xufTtcbmZ1bmN0aW9uIF92aXNpdChwYXRoLCBpdGVtLCB2aXNpdG9yKSB7XG4gICAgbGV0IGN0cmwgPSB2aXNpdG9yKGl0ZW0sIHBhdGgpO1xuICAgIGlmICh0eXBlb2YgY3RybCA9PT0gJ3N5bWJvbCcpXG4gICAgICAgIHJldHVybiBjdHJsO1xuICAgIGZvciAoY29uc3QgZmllbGQgb2YgWydrZXknLCAndmFsdWUnXSkge1xuICAgICAgICBjb25zdCB0b2tlbiA9IGl0ZW1bZmllbGRdO1xuICAgICAgICBpZiAodG9rZW4gJiYgJ2l0ZW1zJyBpbiB0b2tlbikge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b2tlbi5pdGVtcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNpID0gX3Zpc2l0KE9iamVjdC5mcmVlemUocGF0aC5jb25jYXQoW1tmaWVsZCwgaV1dKSksIHRva2VuLml0ZW1zW2ldLCB2aXNpdG9yKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNpID09PSAnbnVtYmVyJylcbiAgICAgICAgICAgICAgICAgICAgaSA9IGNpIC0gMTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjaSA9PT0gQlJFQUspXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBCUkVBSztcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjaSA9PT0gUkVNT1ZFKSB7XG4gICAgICAgICAgICAgICAgICAgIHRva2VuLml0ZW1zLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgaSAtPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgY3RybCA9PT0gJ2Z1bmN0aW9uJyAmJiBmaWVsZCA9PT0gJ2tleScpXG4gICAgICAgICAgICAgICAgY3RybCA9IGN0cmwoaXRlbSwgcGF0aCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHR5cGVvZiBjdHJsID09PSAnZnVuY3Rpb24nID8gY3RybChpdGVtLCBwYXRoKSA6IGN0cmw7XG59XG5cbmV4cG9ydCB7IHZpc2l0IH07XG4iLCAiaW1wb3J0IHsgQk9NLCBET0NVTUVOVCwgRkxPV19FTkQsIFNDQUxBUiB9IGZyb20gJy4vY3N0LmpzJztcblxuLypcblNUQVJUIC0+IHN0cmVhbVxuXG5zdHJlYW1cbiAgZGlyZWN0aXZlIC0+IGxpbmUtZW5kIC0+IHN0cmVhbVxuICBpbmRlbnQgKyBsaW5lLWVuZCAtPiBzdHJlYW1cbiAgW2Vsc2VdIC0+IGxpbmUtc3RhcnRcblxubGluZS1lbmRcbiAgY29tbWVudCAtPiBsaW5lLWVuZFxuICBuZXdsaW5lIC0+IC5cbiAgaW5wdXQtZW5kIC0+IEVORFxuXG5saW5lLXN0YXJ0XG4gIGRvYy1zdGFydCAtPiBkb2NcbiAgZG9jLWVuZCAtPiBzdHJlYW1cbiAgW2Vsc2VdIC0+IGluZGVudCAtPiBibG9jay1zdGFydFxuXG5ibG9jay1zdGFydFxuICBzZXEtaXRlbS1zdGFydCAtPiBibG9jay1zdGFydFxuICBleHBsaWNpdC1rZXktc3RhcnQgLT4gYmxvY2stc3RhcnRcbiAgbWFwLXZhbHVlLXN0YXJ0IC0+IGJsb2NrLXN0YXJ0XG4gIFtlbHNlXSAtPiBkb2NcblxuZG9jXG4gIGxpbmUtZW5kIC0+IGxpbmUtc3RhcnRcbiAgc3BhY2VzIC0+IGRvY1xuICBhbmNob3IgLT4gZG9jXG4gIHRhZyAtPiBkb2NcbiAgZmxvdy1zdGFydCAtPiBmbG93IC0+IGRvY1xuICBmbG93LWVuZCAtPiBlcnJvciAtPiBkb2NcbiAgc2VxLWl0ZW0tc3RhcnQgLT4gZXJyb3IgLT4gZG9jXG4gIGV4cGxpY2l0LWtleS1zdGFydCAtPiBlcnJvciAtPiBkb2NcbiAgbWFwLXZhbHVlLXN0YXJ0IC0+IGRvY1xuICBhbGlhcyAtPiBkb2NcbiAgcXVvdGUtc3RhcnQgLT4gcXVvdGVkLXNjYWxhciAtPiBkb2NcbiAgYmxvY2stc2NhbGFyLWhlYWRlciAtPiBsaW5lLWVuZCAtPiBibG9jay1zY2FsYXIobWluKSAtPiBsaW5lLXN0YXJ0XG4gIFtlbHNlXSAtPiBwbGFpbi1zY2FsYXIoZmFsc2UsIG1pbikgLT4gZG9jXG5cbmZsb3dcbiAgbGluZS1lbmQgLT4gZmxvd1xuICBzcGFjZXMgLT4gZmxvd1xuICBhbmNob3IgLT4gZmxvd1xuICB0YWcgLT4gZmxvd1xuICBmbG93LXN0YXJ0IC0+IGZsb3cgLT4gZmxvd1xuICBmbG93LWVuZCAtPiAuXG4gIHNlcS1pdGVtLXN0YXJ0IC0+IGVycm9yIC0+IGZsb3dcbiAgZXhwbGljaXQta2V5LXN0YXJ0IC0+IGZsb3dcbiAgbWFwLXZhbHVlLXN0YXJ0IC0+IGZsb3dcbiAgYWxpYXMgLT4gZmxvd1xuICBxdW90ZS1zdGFydCAtPiBxdW90ZWQtc2NhbGFyIC0+IGZsb3dcbiAgY29tbWEgLT4gZmxvd1xuICBbZWxzZV0gLT4gcGxhaW4tc2NhbGFyKHRydWUsIDApIC0+IGZsb3dcblxucXVvdGVkLXNjYWxhclxuICBxdW90ZS1lbmQgLT4gLlxuICBbZWxzZV0gLT4gcXVvdGVkLXNjYWxhclxuXG5ibG9jay1zY2FsYXIobWluKVxuICBuZXdsaW5lICsgcGVlayhpbmRlbnQgPCBtaW4pIC0+IC5cbiAgW2Vsc2VdIC0+IGJsb2NrLXNjYWxhcihtaW4pXG5cbnBsYWluLXNjYWxhcihpcy1mbG93LCBtaW4pXG4gIHNjYWxhci1lbmQoaXMtZmxvdykgLT4gLlxuICBwZWVrKG5ld2xpbmUgKyAoaW5kZW50IDwgbWluKSkgLT4gLlxuICBbZWxzZV0gLT4gcGxhaW4tc2NhbGFyKG1pbilcbiovXG5mdW5jdGlvbiBpc0VtcHR5KGNoKSB7XG4gICAgc3dpdGNoIChjaCkge1xuICAgICAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgICAgY2FzZSAnICc6XG4gICAgICAgIGNhc2UgJ1xcbic6XG4gICAgICAgIGNhc2UgJ1xccic6XG4gICAgICAgIGNhc2UgJ1xcdCc6XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5jb25zdCBoZXhEaWdpdHMgPSAnMDEyMzQ1Njc4OUFCQ0RFRmFiY2RlZicuc3BsaXQoJycpO1xuY29uc3QgdGFnQ2hhcnMgPSBcIjAxMjM0NTY3ODlBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6LSM7Lz86QCY9KyRfLiF+KicoKVwiLnNwbGl0KCcnKTtcbmNvbnN0IGludmFsaWRGbG93U2NhbGFyQ2hhcnMgPSAnLFtde30nLnNwbGl0KCcnKTtcbmNvbnN0IGludmFsaWRBbmNob3JDaGFycyA9ICcgLFtde31cXG5cXHJcXHQnLnNwbGl0KCcnKTtcbmNvbnN0IGlzTm90QW5jaG9yQ2hhciA9IChjaCkgPT4gIWNoIHx8IGludmFsaWRBbmNob3JDaGFycy5pbmNsdWRlcyhjaCk7XG4vKipcbiAqIFNwbGl0cyBhbiBpbnB1dCBzdHJpbmcgaW50byBsZXhpY2FsIHRva2VucywgaS5lLiBzbWFsbGVyIHN0cmluZ3MgdGhhdCBhcmVcbiAqIGVhc2lseSBpZGVudGlmaWFibGUgYnkgYHRva2Vucy50b2tlblR5cGUoKWAuXG4gKlxuICogTGV4aW5nIHN0YXJ0cyBhbHdheXMgaW4gYSBcInN0cmVhbVwiIGNvbnRleHQuIEluY29tcGxldGUgaW5wdXQgbWF5IGJlIGJ1ZmZlcmVkXG4gKiB1bnRpbCBhIGNvbXBsZXRlIHRva2VuIGNhbiBiZSBlbWl0dGVkLlxuICpcbiAqIEluIGFkZGl0aW9uIHRvIHNsaWNlcyBvZiB0aGUgb3JpZ2luYWwgaW5wdXQsIHRoZSBmb2xsb3dpbmcgY29udHJvbCBjaGFyYWN0ZXJzXG4gKiBtYXkgYWxzbyBiZSBlbWl0dGVkOlxuICpcbiAqIC0gYFxceDAyYCAoU3RhcnQgb2YgVGV4dCk6IEEgZG9jdW1lbnQgc3RhcnRzIHdpdGggdGhlIG5leHQgdG9rZW5cbiAqIC0gYFxceDE4YCAoQ2FuY2VsKTogVW5leHBlY3RlZCBlbmQgb2YgZmxvdy1tb2RlIChpbmRpY2F0ZXMgYW4gZXJyb3IpXG4gKiAtIGBcXHgxZmAgKFVuaXQgU2VwYXJhdG9yKTogTmV4dCB0b2tlbiBpcyBhIHNjYWxhciB2YWx1ZVxuICogLSBgXFx1e0ZFRkZ9YCAoQnl0ZSBvcmRlciBtYXJrKTogRW1pdHRlZCBzZXBhcmF0ZWx5IG91dHNpZGUgZG9jdW1lbnRzXG4gKi9cbmNsYXNzIExleGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZsYWcgaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBlbmQgb2YgdGhlIGN1cnJlbnQgYnVmZmVyIG1hcmtzIHRoZSBlbmQgb2ZcbiAgICAgICAgICogYWxsIGlucHV0XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmF0RW5kID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFeHBsaWNpdCBpbmRlbnQgc2V0IGluIGJsb2NrIHNjYWxhciBoZWFkZXIsIGFzIGFuIG9mZnNldCBmcm9tIHRoZSBjdXJyZW50XG4gICAgICAgICAqIG1pbmltdW0gaW5kZW50LCBzbyBlLmcuIHNldCB0byAxIGZyb20gYSBoZWFkZXIgYHwyK2AuIFNldCB0byAtMSBpZiBub3RcbiAgICAgICAgICogZXhwbGljaXRseSBzZXQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmJsb2NrU2NhbGFySW5kZW50ID0gLTE7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBCbG9jayBzY2FsYXJzIHRoYXQgaW5jbHVkZSBhICsgKGtlZXApIGNob21waW5nIGluZGljYXRvciBpbiB0aGVpciBoZWFkZXJcbiAgICAgICAgICogaW5jbHVkZSB0cmFpbGluZyBlbXB0eSBsaW5lcywgd2hpY2ggYXJlIG90aGVyd2lzZSBleGNsdWRlZCBmcm9tIHRoZVxuICAgICAgICAgKiBzY2FsYXIncyBjb250ZW50cy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYmxvY2tTY2FsYXJLZWVwID0gZmFsc2U7XG4gICAgICAgIC8qKiBDdXJyZW50IGlucHV0ICovXG4gICAgICAgIHRoaXMuYnVmZmVyID0gJyc7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGbGFnIG5vdGluZyB3aGV0aGVyIHRoZSBtYXAgdmFsdWUgaW5kaWNhdG9yIDogY2FuIGltbWVkaWF0ZWx5IGZvbGxvdyB0aGlzXG4gICAgICAgICAqIG5vZGUgd2l0aGluIGEgZmxvdyBjb250ZXh0LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5mbG93S2V5ID0gZmFsc2U7XG4gICAgICAgIC8qKiBDb3VudCBvZiBzdXJyb3VuZGluZyBmbG93IGNvbGxlY3Rpb24gbGV2ZWxzLiAqL1xuICAgICAgICB0aGlzLmZsb3dMZXZlbCA9IDA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNaW5pbXVtIGxldmVsIG9mIGluZGVudGF0aW9uIHJlcXVpcmVkIGZvciBuZXh0IGxpbmVzIHRvIGJlIHBhcnNlZCBhcyBhXG4gICAgICAgICAqIHBhcnQgb2YgdGhlIGN1cnJlbnQgc2NhbGFyIHZhbHVlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pbmRlbnROZXh0ID0gMDtcbiAgICAgICAgLyoqIEluZGVudGF0aW9uIGxldmVsIG9mIHRoZSBjdXJyZW50IGxpbmUuICovXG4gICAgICAgIHRoaXMuaW5kZW50VmFsdWUgPSAwO1xuICAgICAgICAvKiogUG9zaXRpb24gb2YgdGhlIG5leHQgXFxuIGNoYXJhY3Rlci4gKi9cbiAgICAgICAgdGhpcy5saW5lRW5kUG9zID0gbnVsbDtcbiAgICAgICAgLyoqIFN0b3JlcyB0aGUgc3RhdGUgb2YgdGhlIGxleGVyIGlmIHJlYWNoaW5nIHRoZSBlbmQgb2YgaW5jcG9tcGxldGUgaW5wdXQgKi9cbiAgICAgICAgdGhpcy5uZXh0ID0gbnVsbDtcbiAgICAgICAgLyoqIEEgcG9pbnRlciB0byBgYnVmZmVyYDsgdGhlIGN1cnJlbnQgcG9zaXRpb24gb2YgdGhlIGxleGVyLiAqL1xuICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlIFlBTUwgdG9rZW5zIGZyb20gdGhlIGBzb3VyY2VgIHN0cmluZy4gSWYgYGluY29tcGxldGVgLFxuICAgICAqIGEgcGFydCBvZiB0aGUgbGFzdCBsaW5lIG1heSBiZSBsZWZ0IGFzIGEgYnVmZmVyIGZvciB0aGUgbmV4dCBjYWxsLlxuICAgICAqXG4gICAgICogQHJldHVybnMgQSBnZW5lcmF0b3Igb2YgbGV4aWNhbCB0b2tlbnNcbiAgICAgKi9cbiAgICAqbGV4KHNvdXJjZSwgaW5jb21wbGV0ZSA9IGZhbHNlKSB7XG4gICAgICAgIGlmIChzb3VyY2UpIHtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyID0gdGhpcy5idWZmZXIgPyB0aGlzLmJ1ZmZlciArIHNvdXJjZSA6IHNvdXJjZTtcbiAgICAgICAgICAgIHRoaXMubGluZUVuZFBvcyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hdEVuZCA9ICFpbmNvbXBsZXRlO1xuICAgICAgICBsZXQgbmV4dCA9IHRoaXMubmV4dCB8fCAnc3RyZWFtJztcbiAgICAgICAgd2hpbGUgKG5leHQgJiYgKGluY29tcGxldGUgfHwgdGhpcy5oYXNDaGFycygxKSkpXG4gICAgICAgICAgICBuZXh0ID0geWllbGQqIHRoaXMucGFyc2VOZXh0KG5leHQpO1xuICAgIH1cbiAgICBhdExpbmVFbmQoKSB7XG4gICAgICAgIGxldCBpID0gdGhpcy5wb3M7XG4gICAgICAgIGxldCBjaCA9IHRoaXMuYnVmZmVyW2ldO1xuICAgICAgICB3aGlsZSAoY2ggPT09ICcgJyB8fCBjaCA9PT0gJ1xcdCcpXG4gICAgICAgICAgICBjaCA9IHRoaXMuYnVmZmVyWysraV07XG4gICAgICAgIGlmICghY2ggfHwgY2ggPT09ICcjJyB8fCBjaCA9PT0gJ1xcbicpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKGNoID09PSAnXFxyJylcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJ1ZmZlcltpICsgMV0gPT09ICdcXG4nO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNoYXJBdChuKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJ1ZmZlclt0aGlzLnBvcyArIG5dO1xuICAgIH1cbiAgICBjb250aW51ZVNjYWxhcihvZmZzZXQpIHtcbiAgICAgICAgbGV0IGNoID0gdGhpcy5idWZmZXJbb2Zmc2V0XTtcbiAgICAgICAgaWYgKHRoaXMuaW5kZW50TmV4dCA+IDApIHtcbiAgICAgICAgICAgIGxldCBpbmRlbnQgPSAwO1xuICAgICAgICAgICAgd2hpbGUgKGNoID09PSAnICcpXG4gICAgICAgICAgICAgICAgY2ggPSB0aGlzLmJ1ZmZlclsrK2luZGVudCArIG9mZnNldF07XG4gICAgICAgICAgICBpZiAoY2ggPT09ICdcXHInKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dCA9IHRoaXMuYnVmZmVyW2luZGVudCArIG9mZnNldCArIDFdO1xuICAgICAgICAgICAgICAgIGlmIChuZXh0ID09PSAnXFxuJyB8fCAoIW5leHQgJiYgIXRoaXMuYXRFbmQpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2Zmc2V0ICsgaW5kZW50ICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjaCA9PT0gJ1xcbicgfHwgaW5kZW50ID49IHRoaXMuaW5kZW50TmV4dCB8fCAoIWNoICYmICF0aGlzLmF0RW5kKVxuICAgICAgICAgICAgICAgID8gb2Zmc2V0ICsgaW5kZW50XG4gICAgICAgICAgICAgICAgOiAtMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2ggPT09ICctJyB8fCBjaCA9PT0gJy4nKSB7XG4gICAgICAgICAgICBjb25zdCBkdCA9IHRoaXMuYnVmZmVyLnN1YnN0cihvZmZzZXQsIDMpO1xuICAgICAgICAgICAgaWYgKChkdCA9PT0gJy0tLScgfHwgZHQgPT09ICcuLi4nKSAmJiBpc0VtcHR5KHRoaXMuYnVmZmVyW29mZnNldCArIDNdKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9mZnNldDtcbiAgICB9XG4gICAgZ2V0TGluZSgpIHtcbiAgICAgICAgbGV0IGVuZCA9IHRoaXMubGluZUVuZFBvcztcbiAgICAgICAgaWYgKHR5cGVvZiBlbmQgIT09ICdudW1iZXInIHx8IChlbmQgIT09IC0xICYmIGVuZCA8IHRoaXMucG9zKSkge1xuICAgICAgICAgICAgZW5kID0gdGhpcy5idWZmZXIuaW5kZXhPZignXFxuJywgdGhpcy5wb3MpO1xuICAgICAgICAgICAgdGhpcy5saW5lRW5kUG9zID0gZW5kO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbmQgPT09IC0xKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXRFbmQgPyB0aGlzLmJ1ZmZlci5zdWJzdHJpbmcodGhpcy5wb3MpIDogbnVsbDtcbiAgICAgICAgaWYgKHRoaXMuYnVmZmVyW2VuZCAtIDFdID09PSAnXFxyJylcbiAgICAgICAgICAgIGVuZCAtPSAxO1xuICAgICAgICByZXR1cm4gdGhpcy5idWZmZXIuc3Vic3RyaW5nKHRoaXMucG9zLCBlbmQpO1xuICAgIH1cbiAgICBoYXNDaGFycyhuKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBvcyArIG4gPD0gdGhpcy5idWZmZXIubGVuZ3RoO1xuICAgIH1cbiAgICBzZXROZXh0KHN0YXRlKSB7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gdGhpcy5idWZmZXIuc3Vic3RyaW5nKHRoaXMucG9zKTtcbiAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgICAgICB0aGlzLmxpbmVFbmRQb3MgPSBudWxsO1xuICAgICAgICB0aGlzLm5leHQgPSBzdGF0ZTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHBlZWsobikge1xuICAgICAgICByZXR1cm4gdGhpcy5idWZmZXIuc3Vic3RyKHRoaXMucG9zLCBuKTtcbiAgICB9XG4gICAgKnBhcnNlTmV4dChuZXh0KSB7XG4gICAgICAgIHN3aXRjaCAobmV4dCkge1xuICAgICAgICAgICAgY2FzZSAnc3RyZWFtJzpcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQqIHRoaXMucGFyc2VTdHJlYW0oKTtcbiAgICAgICAgICAgIGNhc2UgJ2xpbmUtc3RhcnQnOlxuICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCogdGhpcy5wYXJzZUxpbmVTdGFydCgpO1xuICAgICAgICAgICAgY2FzZSAnYmxvY2stc3RhcnQnOlxuICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCogdGhpcy5wYXJzZUJsb2NrU3RhcnQoKTtcbiAgICAgICAgICAgIGNhc2UgJ2RvYyc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkKiB0aGlzLnBhcnNlRG9jdW1lbnQoKTtcbiAgICAgICAgICAgIGNhc2UgJ2Zsb3cnOlxuICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCogdGhpcy5wYXJzZUZsb3dDb2xsZWN0aW9uKCk7XG4gICAgICAgICAgICBjYXNlICdxdW90ZWQtc2NhbGFyJzpcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQqIHRoaXMucGFyc2VRdW90ZWRTY2FsYXIoKTtcbiAgICAgICAgICAgIGNhc2UgJ2Jsb2NrLXNjYWxhcic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkKiB0aGlzLnBhcnNlQmxvY2tTY2FsYXIoKTtcbiAgICAgICAgICAgIGNhc2UgJ3BsYWluLXNjYWxhcic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkKiB0aGlzLnBhcnNlUGxhaW5TY2FsYXIoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAqcGFyc2VTdHJlYW0oKSB7XG4gICAgICAgIGxldCBsaW5lID0gdGhpcy5nZXRMaW5lKCk7XG4gICAgICAgIGlmIChsaW5lID09PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0TmV4dCgnc3RyZWFtJyk7XG4gICAgICAgIGlmIChsaW5lWzBdID09PSBCT00pIHtcbiAgICAgICAgICAgIHlpZWxkKiB0aGlzLnB1c2hDb3VudCgxKTtcbiAgICAgICAgICAgIGxpbmUgPSBsaW5lLnN1YnN0cmluZygxKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGluZVswXSA9PT0gJyUnKSB7XG4gICAgICAgICAgICBsZXQgZGlyRW5kID0gbGluZS5sZW5ndGg7XG4gICAgICAgICAgICBjb25zdCBjcyA9IGxpbmUuaW5kZXhPZignIycpO1xuICAgICAgICAgICAgaWYgKGNzICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoID0gbGluZVtjcyAtIDFdO1xuICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJyAnIHx8IGNoID09PSAnXFx0JylcbiAgICAgICAgICAgICAgICAgICAgZGlyRW5kID0gY3MgLSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaCA9IGxpbmVbZGlyRW5kIC0gMV07XG4gICAgICAgICAgICAgICAgaWYgKGNoID09PSAnICcgfHwgY2ggPT09ICdcXHQnKVxuICAgICAgICAgICAgICAgICAgICBkaXJFbmQgLT0gMTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbiA9ICh5aWVsZCogdGhpcy5wdXNoQ291bnQoZGlyRW5kKSkgKyAoeWllbGQqIHRoaXMucHVzaFNwYWNlcyh0cnVlKSk7XG4gICAgICAgICAgICB5aWVsZCogdGhpcy5wdXNoQ291bnQobGluZS5sZW5ndGggLSBuKTsgLy8gcG9zc2libGUgY29tbWVudFxuICAgICAgICAgICAgdGhpcy5wdXNoTmV3bGluZSgpO1xuICAgICAgICAgICAgcmV0dXJuICdzdHJlYW0nO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmF0TGluZUVuZCgpKSB7XG4gICAgICAgICAgICBjb25zdCBzcCA9IHlpZWxkKiB0aGlzLnB1c2hTcGFjZXModHJ1ZSk7XG4gICAgICAgICAgICB5aWVsZCogdGhpcy5wdXNoQ291bnQobGluZS5sZW5ndGggLSBzcCk7XG4gICAgICAgICAgICB5aWVsZCogdGhpcy5wdXNoTmV3bGluZSgpO1xuICAgICAgICAgICAgcmV0dXJuICdzdHJlYW0nO1xuICAgICAgICB9XG4gICAgICAgIHlpZWxkIERPQ1VNRU5UO1xuICAgICAgICByZXR1cm4geWllbGQqIHRoaXMucGFyc2VMaW5lU3RhcnQoKTtcbiAgICB9XG4gICAgKnBhcnNlTGluZVN0YXJ0KCkge1xuICAgICAgICBjb25zdCBjaCA9IHRoaXMuY2hhckF0KDApO1xuICAgICAgICBpZiAoIWNoICYmICF0aGlzLmF0RW5kKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0TmV4dCgnbGluZS1zdGFydCcpO1xuICAgICAgICBpZiAoY2ggPT09ICctJyB8fCBjaCA9PT0gJy4nKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuYXRFbmQgJiYgIXRoaXMuaGFzQ2hhcnMoNCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0TmV4dCgnbGluZS1zdGFydCcpO1xuICAgICAgICAgICAgY29uc3QgcyA9IHRoaXMucGVlaygzKTtcbiAgICAgICAgICAgIGlmIChzID09PSAnLS0tJyAmJiBpc0VtcHR5KHRoaXMuY2hhckF0KDMpKSkge1xuICAgICAgICAgICAgICAgIHlpZWxkKiB0aGlzLnB1c2hDb3VudCgzKTtcbiAgICAgICAgICAgICAgICB0aGlzLmluZGVudFZhbHVlID0gMDtcbiAgICAgICAgICAgICAgICB0aGlzLmluZGVudE5leHQgPSAwO1xuICAgICAgICAgICAgICAgIHJldHVybiAnZG9jJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHMgPT09ICcuLi4nICYmIGlzRW1wdHkodGhpcy5jaGFyQXQoMykpKSB7XG4gICAgICAgICAgICAgICAgeWllbGQqIHRoaXMucHVzaENvdW50KDMpO1xuICAgICAgICAgICAgICAgIHJldHVybiAnc3RyZWFtJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmluZGVudFZhbHVlID0geWllbGQqIHRoaXMucHVzaFNwYWNlcyhmYWxzZSk7XG4gICAgICAgIGlmICh0aGlzLmluZGVudE5leHQgPiB0aGlzLmluZGVudFZhbHVlICYmICFpc0VtcHR5KHRoaXMuY2hhckF0KDEpKSlcbiAgICAgICAgICAgIHRoaXMuaW5kZW50TmV4dCA9IHRoaXMuaW5kZW50VmFsdWU7XG4gICAgICAgIHJldHVybiB5aWVsZCogdGhpcy5wYXJzZUJsb2NrU3RhcnQoKTtcbiAgICB9XG4gICAgKnBhcnNlQmxvY2tTdGFydCgpIHtcbiAgICAgICAgY29uc3QgW2NoMCwgY2gxXSA9IHRoaXMucGVlaygyKTtcbiAgICAgICAgaWYgKCFjaDEgJiYgIXRoaXMuYXRFbmQpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZXROZXh0KCdibG9jay1zdGFydCcpO1xuICAgICAgICBpZiAoKGNoMCA9PT0gJy0nIHx8IGNoMCA9PT0gJz8nIHx8IGNoMCA9PT0gJzonKSAmJiBpc0VtcHR5KGNoMSkpIHtcbiAgICAgICAgICAgIGNvbnN0IG4gPSAoeWllbGQqIHRoaXMucHVzaENvdW50KDEpKSArICh5aWVsZCogdGhpcy5wdXNoU3BhY2VzKHRydWUpKTtcbiAgICAgICAgICAgIHRoaXMuaW5kZW50TmV4dCA9IHRoaXMuaW5kZW50VmFsdWUgKyAxO1xuICAgICAgICAgICAgdGhpcy5pbmRlbnRWYWx1ZSArPSBuO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkKiB0aGlzLnBhcnNlQmxvY2tTdGFydCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnZG9jJztcbiAgICB9XG4gICAgKnBhcnNlRG9jdW1lbnQoKSB7XG4gICAgICAgIHlpZWxkKiB0aGlzLnB1c2hTcGFjZXModHJ1ZSk7XG4gICAgICAgIGNvbnN0IGxpbmUgPSB0aGlzLmdldExpbmUoKTtcbiAgICAgICAgaWYgKGxpbmUgPT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZXROZXh0KCdkb2MnKTtcbiAgICAgICAgbGV0IG4gPSB5aWVsZCogdGhpcy5wdXNoSW5kaWNhdG9ycygpO1xuICAgICAgICBzd2l0Y2ggKGxpbmVbbl0pIHtcbiAgICAgICAgICAgIGNhc2UgJyMnOlxuICAgICAgICAgICAgICAgIHlpZWxkKiB0aGlzLnB1c2hDb3VudChsaW5lLmxlbmd0aCAtIG4pO1xuICAgICAgICAgICAgLy8gZmFsbHRocm91Z2hcbiAgICAgICAgICAgIGNhc2UgdW5kZWZpbmVkOlxuICAgICAgICAgICAgICAgIHlpZWxkKiB0aGlzLnB1c2hOZXdsaW5lKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkKiB0aGlzLnBhcnNlTGluZVN0YXJ0KCk7XG4gICAgICAgICAgICBjYXNlICd7JzpcbiAgICAgICAgICAgIGNhc2UgJ1snOlxuICAgICAgICAgICAgICAgIHlpZWxkKiB0aGlzLnB1c2hDb3VudCgxKTtcbiAgICAgICAgICAgICAgICB0aGlzLmZsb3dLZXkgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLmZsb3dMZXZlbCA9IDE7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdmbG93JztcbiAgICAgICAgICAgIGNhc2UgJ30nOlxuICAgICAgICAgICAgY2FzZSAnXSc6XG4gICAgICAgICAgICAgICAgLy8gdGhpcyBpcyBhbiBlcnJvclxuICAgICAgICAgICAgICAgIHlpZWxkKiB0aGlzLnB1c2hDb3VudCgxKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2RvYyc7XG4gICAgICAgICAgICBjYXNlICcqJzpcbiAgICAgICAgICAgICAgICB5aWVsZCogdGhpcy5wdXNoVW50aWwoaXNOb3RBbmNob3JDaGFyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2RvYyc7XG4gICAgICAgICAgICBjYXNlICdcIic6XG4gICAgICAgICAgICBjYXNlIFwiJ1wiOlxuICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCogdGhpcy5wYXJzZVF1b3RlZFNjYWxhcigpO1xuICAgICAgICAgICAgY2FzZSAnfCc6XG4gICAgICAgICAgICBjYXNlICc+JzpcbiAgICAgICAgICAgICAgICBuICs9IHlpZWxkKiB0aGlzLnBhcnNlQmxvY2tTY2FsYXJIZWFkZXIoKTtcbiAgICAgICAgICAgICAgICBuICs9IHlpZWxkKiB0aGlzLnB1c2hTcGFjZXModHJ1ZSk7XG4gICAgICAgICAgICAgICAgeWllbGQqIHRoaXMucHVzaENvdW50KGxpbmUubGVuZ3RoIC0gbik7XG4gICAgICAgICAgICAgICAgeWllbGQqIHRoaXMucHVzaE5ld2xpbmUoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQqIHRoaXMucGFyc2VCbG9ja1NjYWxhcigpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQqIHRoaXMucGFyc2VQbGFpblNjYWxhcigpO1xuICAgICAgICB9XG4gICAgfVxuICAgICpwYXJzZUZsb3dDb2xsZWN0aW9uKCkge1xuICAgICAgICBsZXQgbmwsIHNwO1xuICAgICAgICBsZXQgaW5kZW50ID0gLTE7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIG5sID0geWllbGQqIHRoaXMucHVzaE5ld2xpbmUoKTtcbiAgICAgICAgICAgIHNwID0geWllbGQqIHRoaXMucHVzaFNwYWNlcyh0cnVlKTtcbiAgICAgICAgICAgIGlmIChubCA+IDApXG4gICAgICAgICAgICAgICAgdGhpcy5pbmRlbnRWYWx1ZSA9IGluZGVudCA9IHNwO1xuICAgICAgICB9IHdoaWxlIChubCArIHNwID4gMCk7XG4gICAgICAgIGNvbnN0IGxpbmUgPSB0aGlzLmdldExpbmUoKTtcbiAgICAgICAgaWYgKGxpbmUgPT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZXROZXh0KCdmbG93Jyk7XG4gICAgICAgIGlmICgoaW5kZW50ICE9PSAtMSAmJiBpbmRlbnQgPCB0aGlzLmluZGVudE5leHQgJiYgbGluZVswXSAhPT0gJyMnKSB8fFxuICAgICAgICAgICAgKGluZGVudCA9PT0gMCAmJlxuICAgICAgICAgICAgICAgIChsaW5lLnN0YXJ0c1dpdGgoJy0tLScpIHx8IGxpbmUuc3RhcnRzV2l0aCgnLi4uJykpICYmXG4gICAgICAgICAgICAgICAgaXNFbXB0eShsaW5lWzNdKSkpIHtcbiAgICAgICAgICAgIC8vIEFsbG93aW5nIGZvciB0aGUgdGVybWluYWwgXSBvciB9IGF0IHRoZSBzYW1lIChyYXRoZXIgdGhhbiBncmVhdGVyKVxuICAgICAgICAgICAgLy8gaW5kZW50IGxldmVsIGFzIHRoZSBpbml0aWFsIFsgb3IgeyBpcyB0ZWNobmljYWxseSBpbnZhbGlkLCBidXRcbiAgICAgICAgICAgIC8vIGZhaWxpbmcgaGVyZSB3b3VsZCBiZSBzdXJwcmlzaW5nIHRvIHVzZXJzLlxuICAgICAgICAgICAgY29uc3QgYXRGbG93RW5kTWFya2VyID0gaW5kZW50ID09PSB0aGlzLmluZGVudE5leHQgLSAxICYmXG4gICAgICAgICAgICAgICAgdGhpcy5mbG93TGV2ZWwgPT09IDEgJiZcbiAgICAgICAgICAgICAgICAobGluZVswXSA9PT0gJ10nIHx8IGxpbmVbMF0gPT09ICd9Jyk7XG4gICAgICAgICAgICBpZiAoIWF0Rmxvd0VuZE1hcmtlcikge1xuICAgICAgICAgICAgICAgIC8vIHRoaXMgaXMgYW4gZXJyb3JcbiAgICAgICAgICAgICAgICB0aGlzLmZsb3dMZXZlbCA9IDA7XG4gICAgICAgICAgICAgICAgeWllbGQgRkxPV19FTkQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkKiB0aGlzLnBhcnNlTGluZVN0YXJ0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG4gPSAwO1xuICAgICAgICB3aGlsZSAobGluZVtuXSA9PT0gJywnKSB7XG4gICAgICAgICAgICBuICs9IHlpZWxkKiB0aGlzLnB1c2hDb3VudCgxKTtcbiAgICAgICAgICAgIG4gKz0geWllbGQqIHRoaXMucHVzaFNwYWNlcyh0cnVlKTtcbiAgICAgICAgICAgIHRoaXMuZmxvd0tleSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIG4gKz0geWllbGQqIHRoaXMucHVzaEluZGljYXRvcnMoKTtcbiAgICAgICAgc3dpdGNoIChsaW5lW25dKSB7XG4gICAgICAgICAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2Zsb3cnO1xuICAgICAgICAgICAgY2FzZSAnIyc6XG4gICAgICAgICAgICAgICAgeWllbGQqIHRoaXMucHVzaENvdW50KGxpbmUubGVuZ3RoIC0gbik7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdmbG93JztcbiAgICAgICAgICAgIGNhc2UgJ3snOlxuICAgICAgICAgICAgY2FzZSAnWyc6XG4gICAgICAgICAgICAgICAgeWllbGQqIHRoaXMucHVzaENvdW50KDEpO1xuICAgICAgICAgICAgICAgIHRoaXMuZmxvd0tleSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMuZmxvd0xldmVsICs9IDE7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdmbG93JztcbiAgICAgICAgICAgIGNhc2UgJ30nOlxuICAgICAgICAgICAgY2FzZSAnXSc6XG4gICAgICAgICAgICAgICAgeWllbGQqIHRoaXMucHVzaENvdW50KDEpO1xuICAgICAgICAgICAgICAgIHRoaXMuZmxvd0tleSA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5mbG93TGV2ZWwgLT0gMTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5mbG93TGV2ZWwgPyAnZmxvdycgOiAnZG9jJztcbiAgICAgICAgICAgIGNhc2UgJyonOlxuICAgICAgICAgICAgICAgIHlpZWxkKiB0aGlzLnB1c2hVbnRpbChpc05vdEFuY2hvckNoYXIpO1xuICAgICAgICAgICAgICAgIHJldHVybiAnZmxvdyc7XG4gICAgICAgICAgICBjYXNlICdcIic6XG4gICAgICAgICAgICBjYXNlIFwiJ1wiOlxuICAgICAgICAgICAgICAgIHRoaXMuZmxvd0tleSA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkKiB0aGlzLnBhcnNlUXVvdGVkU2NhbGFyKCk7XG4gICAgICAgICAgICBjYXNlICc6Jzoge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5leHQgPSB0aGlzLmNoYXJBdCgxKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5mbG93S2V5IHx8IGlzRW1wdHkobmV4dCkgfHwgbmV4dCA9PT0gJywnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmxvd0tleSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCogdGhpcy5wdXNoQ291bnQoMSk7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkKiB0aGlzLnB1c2hTcGFjZXModHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnZmxvdyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZmFsbHRocm91Z2hcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhpcy5mbG93S2V5ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkKiB0aGlzLnBhcnNlUGxhaW5TY2FsYXIoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAqcGFyc2VRdW90ZWRTY2FsYXIoKSB7XG4gICAgICAgIGNvbnN0IHF1b3RlID0gdGhpcy5jaGFyQXQoMCk7XG4gICAgICAgIGxldCBlbmQgPSB0aGlzLmJ1ZmZlci5pbmRleE9mKHF1b3RlLCB0aGlzLnBvcyArIDEpO1xuICAgICAgICBpZiAocXVvdGUgPT09IFwiJ1wiKSB7XG4gICAgICAgICAgICB3aGlsZSAoZW5kICE9PSAtMSAmJiB0aGlzLmJ1ZmZlcltlbmQgKyAxXSA9PT0gXCInXCIpXG4gICAgICAgICAgICAgICAgZW5kID0gdGhpcy5idWZmZXIuaW5kZXhPZihcIidcIiwgZW5kICsgMik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBkb3VibGUtcXVvdGVcbiAgICAgICAgICAgIHdoaWxlIChlbmQgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgbGV0IG4gPSAwO1xuICAgICAgICAgICAgICAgIHdoaWxlICh0aGlzLmJ1ZmZlcltlbmQgLSAxIC0gbl0gPT09ICdcXFxcJylcbiAgICAgICAgICAgICAgICAgICAgbiArPSAxO1xuICAgICAgICAgICAgICAgIGlmIChuICUgMiA9PT0gMClcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZW5kID0gdGhpcy5idWZmZXIuaW5kZXhPZignXCInLCBlbmQgKyAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBPbmx5IGxvb2tpbmcgZm9yIG5ld2xpbmVzIHdpdGhpbiB0aGUgcXVvdGVzXG4gICAgICAgIGNvbnN0IHFiID0gdGhpcy5idWZmZXIuc3Vic3RyaW5nKDAsIGVuZCk7XG4gICAgICAgIGxldCBubCA9IHFiLmluZGV4T2YoJ1xcbicsIHRoaXMucG9zKTtcbiAgICAgICAgaWYgKG5sICE9PSAtMSkge1xuICAgICAgICAgICAgd2hpbGUgKG5sICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNzID0gdGhpcy5jb250aW51ZVNjYWxhcihubCArIDEpO1xuICAgICAgICAgICAgICAgIGlmIChjcyA9PT0gLTEpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIG5sID0gcWIuaW5kZXhPZignXFxuJywgY3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5sICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIC8vIHRoaXMgaXMgYW4gZXJyb3IgY2F1c2VkIGJ5IGFuIHVuZXhwZWN0ZWQgdW5pbmRlbnRcbiAgICAgICAgICAgICAgICBlbmQgPSBubCAtIChxYltubCAtIDFdID09PSAnXFxyJyA/IDIgOiAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZW5kID09PSAtMSkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmF0RW5kKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNldE5leHQoJ3F1b3RlZC1zY2FsYXInKTtcbiAgICAgICAgICAgIGVuZCA9IHRoaXMuYnVmZmVyLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICB5aWVsZCogdGhpcy5wdXNoVG9JbmRleChlbmQgKyAxLCBmYWxzZSk7XG4gICAgICAgIHJldHVybiB0aGlzLmZsb3dMZXZlbCA/ICdmbG93JyA6ICdkb2MnO1xuICAgIH1cbiAgICAqcGFyc2VCbG9ja1NjYWxhckhlYWRlcigpIHtcbiAgICAgICAgdGhpcy5ibG9ja1NjYWxhckluZGVudCA9IC0xO1xuICAgICAgICB0aGlzLmJsb2NrU2NhbGFyS2VlcCA9IGZhbHNlO1xuICAgICAgICBsZXQgaSA9IHRoaXMucG9zO1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgY29uc3QgY2ggPSB0aGlzLmJ1ZmZlclsrK2ldO1xuICAgICAgICAgICAgaWYgKGNoID09PSAnKycpXG4gICAgICAgICAgICAgICAgdGhpcy5ibG9ja1NjYWxhcktlZXAgPSB0cnVlO1xuICAgICAgICAgICAgZWxzZSBpZiAoY2ggPiAnMCcgJiYgY2ggPD0gJzknKVxuICAgICAgICAgICAgICAgIHRoaXMuYmxvY2tTY2FsYXJJbmRlbnQgPSBOdW1iZXIoY2gpIC0gMTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGNoICE9PSAnLScpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHlpZWxkKiB0aGlzLnB1c2hVbnRpbChjaCA9PiBpc0VtcHR5KGNoKSB8fCBjaCA9PT0gJyMnKTtcbiAgICB9XG4gICAgKnBhcnNlQmxvY2tTY2FsYXIoKSB7XG4gICAgICAgIGxldCBubCA9IHRoaXMucG9zIC0gMTsgLy8gbWF5IGJlIC0xIGlmIHRoaXMucG9zID09PSAwXG4gICAgICAgIGxldCBpbmRlbnQgPSAwO1xuICAgICAgICBsZXQgY2g7XG4gICAgICAgIGxvb3A6IGZvciAobGV0IGkgPSB0aGlzLnBvczsgKGNoID0gdGhpcy5idWZmZXJbaV0pOyArK2kpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoY2gpIHtcbiAgICAgICAgICAgICAgICBjYXNlICcgJzpcbiAgICAgICAgICAgICAgICAgICAgaW5kZW50ICs9IDE7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ1xcbic6XG4gICAgICAgICAgICAgICAgICAgIG5sID0gaTtcbiAgICAgICAgICAgICAgICAgICAgaW5kZW50ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnXFxyJzoge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXh0ID0gdGhpcy5idWZmZXJbaSArIDFdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW5leHQgJiYgIXRoaXMuYXRFbmQpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zZXROZXh0KCdibG9jay1zY2FsYXInKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5leHQgPT09ICdcXG4nKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfSAvLyBmYWxsdGhyb3VnaFxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrIGxvb3A7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjaCAmJiAhdGhpcy5hdEVuZClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNldE5leHQoJ2Jsb2NrLXNjYWxhcicpO1xuICAgICAgICBpZiAoaW5kZW50ID49IHRoaXMuaW5kZW50TmV4dCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuYmxvY2tTY2FsYXJJbmRlbnQgPT09IC0xKVxuICAgICAgICAgICAgICAgIHRoaXMuaW5kZW50TmV4dCA9IGluZGVudDtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aGlzLmluZGVudE5leHQgKz0gdGhpcy5ibG9ja1NjYWxhckluZGVudDtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjcyA9IHRoaXMuY29udGludWVTY2FsYXIobmwgKyAxKTtcbiAgICAgICAgICAgICAgICBpZiAoY3MgPT09IC0xKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBubCA9IHRoaXMuYnVmZmVyLmluZGV4T2YoJ1xcbicsIGNzKTtcbiAgICAgICAgICAgIH0gd2hpbGUgKG5sICE9PSAtMSk7XG4gICAgICAgICAgICBpZiAobmwgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmF0RW5kKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zZXROZXh0KCdibG9jay1zY2FsYXInKTtcbiAgICAgICAgICAgICAgICBubCA9IHRoaXMuYnVmZmVyLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuYmxvY2tTY2FsYXJLZWVwKSB7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgbGV0IGkgPSBubCAtIDE7XG4gICAgICAgICAgICAgICAgbGV0IGNoID0gdGhpcy5idWZmZXJbaV07XG4gICAgICAgICAgICAgICAgaWYgKGNoID09PSAnXFxyJylcbiAgICAgICAgICAgICAgICAgICAgY2ggPSB0aGlzLmJ1ZmZlclstLWldO1xuICAgICAgICAgICAgICAgIHdoaWxlIChjaCA9PT0gJyAnIHx8IGNoID09PSAnXFx0JylcbiAgICAgICAgICAgICAgICAgICAgY2ggPSB0aGlzLmJ1ZmZlclstLWldO1xuICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJ1xcbicgJiYgaSA+PSB0aGlzLnBvcylcbiAgICAgICAgICAgICAgICAgICAgbmwgPSBpO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9IHdoaWxlICh0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICB5aWVsZCBTQ0FMQVI7XG4gICAgICAgIHlpZWxkKiB0aGlzLnB1c2hUb0luZGV4KG5sICsgMSwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiB5aWVsZCogdGhpcy5wYXJzZUxpbmVTdGFydCgpO1xuICAgIH1cbiAgICAqcGFyc2VQbGFpblNjYWxhcigpIHtcbiAgICAgICAgY29uc3QgaW5GbG93ID0gdGhpcy5mbG93TGV2ZWwgPiAwO1xuICAgICAgICBsZXQgZW5kID0gdGhpcy5wb3MgLSAxO1xuICAgICAgICBsZXQgaSA9IHRoaXMucG9zIC0gMTtcbiAgICAgICAgbGV0IGNoO1xuICAgICAgICB3aGlsZSAoKGNoID0gdGhpcy5idWZmZXJbKytpXSkpIHtcbiAgICAgICAgICAgIGlmIChjaCA9PT0gJzonKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dCA9IHRoaXMuYnVmZmVyW2kgKyAxXTtcbiAgICAgICAgICAgICAgICBpZiAoaXNFbXB0eShuZXh0KSB8fCAoaW5GbG93ICYmIG5leHQgPT09ICcsJykpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGVuZCA9IGk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc0VtcHR5KGNoKSkge1xuICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gdGhpcy5idWZmZXJbaSArIDFdO1xuICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJ1xccicpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5leHQgPT09ICdcXG4nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpICs9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaCA9ICdcXG4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCA9IHRoaXMuYnVmZmVyW2kgKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmQgPSBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobmV4dCA9PT0gJyMnIHx8IChpbkZsb3cgJiYgaW52YWxpZEZsb3dTY2FsYXJDaGFycy5pbmNsdWRlcyhuZXh0KSkpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJ1xcbicpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY3MgPSB0aGlzLmNvbnRpbnVlU2NhbGFyKGkgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNzID09PSAtMSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBpID0gTWF0aC5tYXgoaSwgY3MgLSAyKTsgLy8gdG8gYWR2YW5jZSwgYnV0IHN0aWxsIGFjY291bnQgZm9yICcgIydcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5GbG93ICYmIGludmFsaWRGbG93U2NhbGFyQ2hhcnMuaW5jbHVkZXMoY2gpKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBlbmQgPSBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghY2ggJiYgIXRoaXMuYXRFbmQpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZXROZXh0KCdwbGFpbi1zY2FsYXInKTtcbiAgICAgICAgeWllbGQgU0NBTEFSO1xuICAgICAgICB5aWVsZCogdGhpcy5wdXNoVG9JbmRleChlbmQgKyAxLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIGluRmxvdyA/ICdmbG93JyA6ICdkb2MnO1xuICAgIH1cbiAgICAqcHVzaENvdW50KG4pIHtcbiAgICAgICAgaWYgKG4gPiAwKSB7XG4gICAgICAgICAgICB5aWVsZCB0aGlzLmJ1ZmZlci5zdWJzdHIodGhpcy5wb3MsIG4pO1xuICAgICAgICAgICAgdGhpcy5wb3MgKz0gbjtcbiAgICAgICAgICAgIHJldHVybiBuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICAqcHVzaFRvSW5kZXgoaSwgYWxsb3dFbXB0eSkge1xuICAgICAgICBjb25zdCBzID0gdGhpcy5idWZmZXIuc2xpY2UodGhpcy5wb3MsIGkpO1xuICAgICAgICBpZiAocykge1xuICAgICAgICAgICAgeWllbGQgcztcbiAgICAgICAgICAgIHRoaXMucG9zICs9IHMubGVuZ3RoO1xuICAgICAgICAgICAgcmV0dXJuIHMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFsbG93RW1wdHkpXG4gICAgICAgICAgICB5aWVsZCAnJztcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgICpwdXNoSW5kaWNhdG9ycygpIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLmNoYXJBdCgwKSkge1xuICAgICAgICAgICAgY2FzZSAnISc6XG4gICAgICAgICAgICAgICAgcmV0dXJuICgoeWllbGQqIHRoaXMucHVzaFRhZygpKSArXG4gICAgICAgICAgICAgICAgICAgICh5aWVsZCogdGhpcy5wdXNoU3BhY2VzKHRydWUpKSArXG4gICAgICAgICAgICAgICAgICAgICh5aWVsZCogdGhpcy5wdXNoSW5kaWNhdG9ycygpKSk7XG4gICAgICAgICAgICBjYXNlICcmJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gKCh5aWVsZCogdGhpcy5wdXNoVW50aWwoaXNOb3RBbmNob3JDaGFyKSkgK1xuICAgICAgICAgICAgICAgICAgICAoeWllbGQqIHRoaXMucHVzaFNwYWNlcyh0cnVlKSkgK1xuICAgICAgICAgICAgICAgICAgICAoeWllbGQqIHRoaXMucHVzaEluZGljYXRvcnMoKSkpO1xuICAgICAgICAgICAgY2FzZSAnOic6XG4gICAgICAgICAgICBjYXNlICc/JzogLy8gdGhpcyBpcyBhbiBlcnJvciBvdXRzaWRlIGZsb3cgY29sbGVjdGlvbnNcbiAgICAgICAgICAgIGNhc2UgJy0nOiAvLyB0aGlzIGlzIGFuIGVycm9yXG4gICAgICAgICAgICAgICAgaWYgKGlzRW1wdHkodGhpcy5jaGFyQXQoMSkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmZsb3dMZXZlbCA9PT0gMClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW5kZW50TmV4dCA9IHRoaXMuaW5kZW50VmFsdWUgKyAxO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLmZsb3dLZXkpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZsb3dLZXkgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgoeWllbGQqIHRoaXMucHVzaENvdW50KDEpKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAoeWllbGQqIHRoaXMucHVzaFNwYWNlcyh0cnVlKSkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgKHlpZWxkKiB0aGlzLnB1c2hJbmRpY2F0b3JzKCkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgICpwdXNoVGFnKCkge1xuICAgICAgICBpZiAodGhpcy5jaGFyQXQoMSkgPT09ICc8Jykge1xuICAgICAgICAgICAgbGV0IGkgPSB0aGlzLnBvcyArIDI7XG4gICAgICAgICAgICBsZXQgY2ggPSB0aGlzLmJ1ZmZlcltpXTtcbiAgICAgICAgICAgIHdoaWxlICghaXNFbXB0eShjaCkgJiYgY2ggIT09ICc+JylcbiAgICAgICAgICAgICAgICBjaCA9IHRoaXMuYnVmZmVyWysraV07XG4gICAgICAgICAgICByZXR1cm4geWllbGQqIHRoaXMucHVzaFRvSW5kZXgoY2ggPT09ICc+JyA/IGkgKyAxIDogaSwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IGkgPSB0aGlzLnBvcyArIDE7XG4gICAgICAgICAgICBsZXQgY2ggPSB0aGlzLmJ1ZmZlcltpXTtcbiAgICAgICAgICAgIHdoaWxlIChjaCkge1xuICAgICAgICAgICAgICAgIGlmICh0YWdDaGFycy5pbmNsdWRlcyhjaCkpXG4gICAgICAgICAgICAgICAgICAgIGNoID0gdGhpcy5idWZmZXJbKytpXTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjaCA9PT0gJyUnICYmXG4gICAgICAgICAgICAgICAgICAgIGhleERpZ2l0cy5pbmNsdWRlcyh0aGlzLmJ1ZmZlcltpICsgMV0pICYmXG4gICAgICAgICAgICAgICAgICAgIGhleERpZ2l0cy5pbmNsdWRlcyh0aGlzLmJ1ZmZlcltpICsgMl0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoID0gdGhpcy5idWZmZXJbKGkgKz0gMyldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHlpZWxkKiB0aGlzLnB1c2hUb0luZGV4KGksIGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAqcHVzaE5ld2xpbmUoKSB7XG4gICAgICAgIGNvbnN0IGNoID0gdGhpcy5idWZmZXJbdGhpcy5wb3NdO1xuICAgICAgICBpZiAoY2ggPT09ICdcXG4nKVxuICAgICAgICAgICAgcmV0dXJuIHlpZWxkKiB0aGlzLnB1c2hDb3VudCgxKTtcbiAgICAgICAgZWxzZSBpZiAoY2ggPT09ICdcXHInICYmIHRoaXMuY2hhckF0KDEpID09PSAnXFxuJylcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCogdGhpcy5wdXNoQ291bnQoMik7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICAqcHVzaFNwYWNlcyhhbGxvd1RhYnMpIHtcbiAgICAgICAgbGV0IGkgPSB0aGlzLnBvcyAtIDE7XG4gICAgICAgIGxldCBjaDtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgY2ggPSB0aGlzLmJ1ZmZlclsrK2ldO1xuICAgICAgICB9IHdoaWxlIChjaCA9PT0gJyAnIHx8IChhbGxvd1RhYnMgJiYgY2ggPT09ICdcXHQnKSk7XG4gICAgICAgIGNvbnN0IG4gPSBpIC0gdGhpcy5wb3M7XG4gICAgICAgIGlmIChuID4gMCkge1xuICAgICAgICAgICAgeWllbGQgdGhpcy5idWZmZXIuc3Vic3RyKHRoaXMucG9zLCBuKTtcbiAgICAgICAgICAgIHRoaXMucG9zID0gaTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbjtcbiAgICB9XG4gICAgKnB1c2hVbnRpbCh0ZXN0KSB7XG4gICAgICAgIGxldCBpID0gdGhpcy5wb3M7XG4gICAgICAgIGxldCBjaCA9IHRoaXMuYnVmZmVyW2ldO1xuICAgICAgICB3aGlsZSAoIXRlc3QoY2gpKVxuICAgICAgICAgICAgY2ggPSB0aGlzLmJ1ZmZlclsrK2ldO1xuICAgICAgICByZXR1cm4geWllbGQqIHRoaXMucHVzaFRvSW5kZXgoaSwgZmFsc2UpO1xuICAgIH1cbn1cblxuZXhwb3J0IHsgTGV4ZXIgfTtcbiIsICIvKipcbiAqIFRyYWNrcyBuZXdsaW5lcyBkdXJpbmcgcGFyc2luZyBpbiBvcmRlciB0byBwcm92aWRlIGFuIGVmZmljaWVudCBBUEkgZm9yXG4gKiBkZXRlcm1pbmluZyB0aGUgb25lLWluZGV4ZWQgYHsgbGluZSwgY29sIH1gIHBvc2l0aW9uIGZvciBhbnkgb2Zmc2V0XG4gKiB3aXRoaW4gdGhlIGlucHV0LlxuICovXG5jbGFzcyBMaW5lQ291bnRlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMubGluZVN0YXJ0cyA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgICogU2hvdWxkIGJlIGNhbGxlZCBpbiBhc2NlbmRpbmcgb3JkZXIuIE90aGVyd2lzZSwgY2FsbFxuICAgICAgICAgKiBgbGluZUNvdW50ZXIubGluZVN0YXJ0cy5zb3J0KClgIGJlZm9yZSBjYWxsaW5nIGBsaW5lUG9zKClgLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hZGROZXdMaW5lID0gKG9mZnNldCkgPT4gdGhpcy5saW5lU3RhcnRzLnB1c2gob2Zmc2V0KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFBlcmZvcm1zIGEgYmluYXJ5IHNlYXJjaCBhbmQgcmV0dXJucyB0aGUgMS1pbmRleGVkIHsgbGluZSwgY29sIH1cbiAgICAgICAgICogcG9zaXRpb24gb2YgYG9mZnNldGAuIElmIGBsaW5lID09PSAwYCwgYGFkZE5ld0xpbmVgIGhhcyBuZXZlciBiZWVuXG4gICAgICAgICAqIGNhbGxlZCBvciBgb2Zmc2V0YCBpcyBiZWZvcmUgdGhlIGZpcnN0IGtub3duIG5ld2xpbmUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmxpbmVQb3MgPSAob2Zmc2V0KSA9PiB7XG4gICAgICAgICAgICBsZXQgbG93ID0gMDtcbiAgICAgICAgICAgIGxldCBoaWdoID0gdGhpcy5saW5lU3RhcnRzLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlIChsb3cgPCBoaWdoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWlkID0gKGxvdyArIGhpZ2gpID4+IDE7IC8vIE1hdGguZmxvb3IoKGxvdyArIGhpZ2gpIC8gMilcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5saW5lU3RhcnRzW21pZF0gPCBvZmZzZXQpXG4gICAgICAgICAgICAgICAgICAgIGxvdyA9IG1pZCArIDE7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBoaWdoID0gbWlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMubGluZVN0YXJ0c1tsb3ddID09PSBvZmZzZXQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgbGluZTogbG93ICsgMSwgY29sOiAxIH07XG4gICAgICAgICAgICBpZiAobG93ID09PSAwKVxuICAgICAgICAgICAgICAgIHJldHVybiB7IGxpbmU6IDAsIGNvbDogb2Zmc2V0IH07XG4gICAgICAgICAgICBjb25zdCBzdGFydCA9IHRoaXMubGluZVN0YXJ0c1tsb3cgLSAxXTtcbiAgICAgICAgICAgIHJldHVybiB7IGxpbmU6IGxvdywgY29sOiBvZmZzZXQgLSBzdGFydCArIDEgfTtcbiAgICAgICAgfTtcbiAgICB9XG59XG5cbmV4cG9ydCB7IExpbmVDb3VudGVyIH07XG4iLCAiaW1wb3J0IHsgdG9rZW5UeXBlIH0gZnJvbSAnLi9jc3QuanMnO1xuaW1wb3J0IHsgTGV4ZXIgfSBmcm9tICcuL2xleGVyLmpzJztcblxuZnVuY3Rpb24gaW5jbHVkZXNUb2tlbihsaXN0LCB0eXBlKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKVxuICAgICAgICBpZiAobGlzdFtpXS50eXBlID09PSB0eXBlKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gaW5jbHVkZXNOb25FbXB0eShsaXN0KSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHN3aXRjaCAobGlzdFtpXS50eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdzcGFjZSc6XG4gICAgICAgICAgICBjYXNlICdjb21tZW50JzpcbiAgICAgICAgICAgIGNhc2UgJ25ld2xpbmUnOlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBpc0Zsb3dUb2tlbih0b2tlbikge1xuICAgIHN3aXRjaCAodG9rZW4gPT09IG51bGwgfHwgdG9rZW4gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRva2VuLnR5cGUpIHtcbiAgICAgICAgY2FzZSAnYWxpYXMnOlxuICAgICAgICBjYXNlICdzY2FsYXInOlxuICAgICAgICBjYXNlICdzaW5nbGUtcXVvdGVkLXNjYWxhcic6XG4gICAgICAgIGNhc2UgJ2RvdWJsZS1xdW90ZWQtc2NhbGFyJzpcbiAgICAgICAgY2FzZSAnZmxvdy1jb2xsZWN0aW9uJzpcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldFByZXZQcm9wcyhwYXJlbnQpIHtcbiAgICBzd2l0Y2ggKHBhcmVudC50eXBlKSB7XG4gICAgICAgIGNhc2UgJ2RvY3VtZW50JzpcbiAgICAgICAgICAgIHJldHVybiBwYXJlbnQuc3RhcnQ7XG4gICAgICAgIGNhc2UgJ2Jsb2NrLW1hcCc6IHtcbiAgICAgICAgICAgIGNvbnN0IGl0ID0gcGFyZW50Lml0ZW1zW3BhcmVudC5pdGVtcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIHJldHVybiBpdC5zZXAgfHwgaXQuc3RhcnQ7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnYmxvY2stc2VxJzpcbiAgICAgICAgICAgIHJldHVybiBwYXJlbnQuaXRlbXNbcGFyZW50Lml0ZW1zLmxlbmd0aCAtIDFdLnN0YXJ0O1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCBzaG91bGQgbm90IGhhcHBlbiAqL1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbn1cbi8qKiBOb3RlOiBNYXkgbW9kaWZ5IGlucHV0IGFycmF5ICovXG5mdW5jdGlvbiBnZXRGaXJzdEtleVN0YXJ0UHJvcHMocHJldikge1xuICAgIHZhciBfYTtcbiAgICBpZiAocHJldi5sZW5ndGggPT09IDApXG4gICAgICAgIHJldHVybiBbXTtcbiAgICBsZXQgaSA9IHByZXYubGVuZ3RoO1xuICAgIGxvb3A6IHdoaWxlICgtLWkgPj0gMCkge1xuICAgICAgICBzd2l0Y2ggKHByZXZbaV0udHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnZG9jLXN0YXJ0JzpcbiAgICAgICAgICAgIGNhc2UgJ2V4cGxpY2l0LWtleS1pbmQnOlxuICAgICAgICAgICAgY2FzZSAnbWFwLXZhbHVlLWluZCc6XG4gICAgICAgICAgICBjYXNlICdzZXEtaXRlbS1pbmQnOlxuICAgICAgICAgICAgY2FzZSAnbmV3bGluZSc6XG4gICAgICAgICAgICAgICAgYnJlYWsgbG9vcDtcbiAgICAgICAgfVxuICAgIH1cbiAgICB3aGlsZSAoKChfYSA9IHByZXZbKytpXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnR5cGUpID09PSAnc3BhY2UnKSB7XG4gICAgICAgIC8qIGxvb3AgKi9cbiAgICB9XG4gICAgcmV0dXJuIHByZXYuc3BsaWNlKGksIHByZXYubGVuZ3RoKTtcbn1cbmZ1bmN0aW9uIGZpeEZsb3dTZXFJdGVtcyhmYykge1xuICAgIGlmIChmYy5zdGFydC50eXBlID09PSAnZmxvdy1zZXEtc3RhcnQnKSB7XG4gICAgICAgIGZvciAoY29uc3QgaXQgb2YgZmMuaXRlbXMpIHtcbiAgICAgICAgICAgIGlmIChpdC5zZXAgJiZcbiAgICAgICAgICAgICAgICAhaXQudmFsdWUgJiZcbiAgICAgICAgICAgICAgICAhaW5jbHVkZXNUb2tlbihpdC5zdGFydCwgJ2V4cGxpY2l0LWtleS1pbmQnKSAmJlxuICAgICAgICAgICAgICAgICFpbmNsdWRlc1Rva2VuKGl0LnNlcCwgJ21hcC12YWx1ZS1pbmQnKSkge1xuICAgICAgICAgICAgICAgIGlmIChpdC5rZXkpXG4gICAgICAgICAgICAgICAgICAgIGl0LnZhbHVlID0gaXQua2V5O1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBpdC5rZXk7XG4gICAgICAgICAgICAgICAgaWYgKGlzRmxvd1Rva2VuKGl0LnZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXQudmFsdWUuZW5kKVxuICAgICAgICAgICAgICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkoaXQudmFsdWUuZW5kLCBpdC5zZXApO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBpdC52YWx1ZS5lbmQgPSBpdC5zZXA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkoaXQuc3RhcnQsIGl0LnNlcCk7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGl0LnNlcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogQSBZQU1MIGNvbmNyZXRlIHN5bnRheCB0cmVlIChDU1QpIHBhcnNlclxuICpcbiAqIGBgYHRzXG4gKiBjb25zdCBzcmM6IHN0cmluZyA9IC4uLlxuICogZm9yIChjb25zdCB0b2tlbiBvZiBuZXcgUGFyc2VyKCkucGFyc2Uoc3JjKSkge1xuICogICAvLyB0b2tlbjogVG9rZW5cbiAqIH1cbiAqIGBgYFxuICpcbiAqIFRvIHVzZSB0aGUgcGFyc2VyIHdpdGggYSB1c2VyLXByb3ZpZGVkIGxleGVyOlxuICpcbiAqIGBgYHRzXG4gKiBmdW5jdGlvbiogcGFyc2Uoc291cmNlOiBzdHJpbmcsIGxleGVyOiBMZXhlcikge1xuICogICBjb25zdCBwYXJzZXIgPSBuZXcgUGFyc2VyKClcbiAqICAgZm9yIChjb25zdCBsZXhlbWUgb2YgbGV4ZXIubGV4KHNvdXJjZSkpXG4gKiAgICAgeWllbGQqIHBhcnNlci5uZXh0KGxleGVtZSlcbiAqICAgeWllbGQqIHBhcnNlci5lbmQoKVxuICogfVxuICpcbiAqIGNvbnN0IHNyYzogc3RyaW5nID0gLi4uXG4gKiBjb25zdCBsZXhlciA9IG5ldyBMZXhlcigpXG4gKiBmb3IgKGNvbnN0IHRva2VuIG9mIHBhcnNlKHNyYywgbGV4ZXIpKSB7XG4gKiAgIC8vIHRva2VuOiBUb2tlblxuICogfVxuICogYGBgXG4gKi9cbmNsYXNzIFBhcnNlciB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIG9uTmV3TGluZSAtIElmIGRlZmluZWQsIGNhbGxlZCBzZXBhcmF0ZWx5IHdpdGggdGhlIHN0YXJ0IHBvc2l0aW9uIG9mXG4gICAgICogICBlYWNoIG5ldyBsaW5lIChpbiBgcGFyc2UoKWAsIGluY2x1ZGluZyB0aGUgc3RhcnQgb2YgaW5wdXQpLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG9uTmV3TGluZSkge1xuICAgICAgICAvKiogSWYgdHJ1ZSwgc3BhY2UgYW5kIHNlcXVlbmNlIGluZGljYXRvcnMgY291bnQgYXMgaW5kZW50YXRpb24gKi9cbiAgICAgICAgdGhpcy5hdE5ld0xpbmUgPSB0cnVlO1xuICAgICAgICAvKiogSWYgdHJ1ZSwgbmV4dCB0b2tlbiBpcyBhIHNjYWxhciB2YWx1ZSAqL1xuICAgICAgICB0aGlzLmF0U2NhbGFyID0gZmFsc2U7XG4gICAgICAgIC8qKiBDdXJyZW50IGluZGVudGF0aW9uIGxldmVsICovXG4gICAgICAgIHRoaXMuaW5kZW50ID0gMDtcbiAgICAgICAgLyoqIEN1cnJlbnQgb2Zmc2V0IHNpbmNlIHRoZSBzdGFydCBvZiBwYXJzaW5nICovXG4gICAgICAgIHRoaXMub2Zmc2V0ID0gMDtcbiAgICAgICAgLyoqIE9uIHRoZSBzYW1lIGxpbmUgd2l0aCBhIGJsb2NrIG1hcCBrZXkgKi9cbiAgICAgICAgdGhpcy5vbktleUxpbmUgPSBmYWxzZTtcbiAgICAgICAgLyoqIFRvcCBpbmRpY2F0ZXMgdGhlIG5vZGUgdGhhdCdzIGN1cnJlbnRseSBiZWluZyBidWlsdCAqL1xuICAgICAgICB0aGlzLnN0YWNrID0gW107XG4gICAgICAgIC8qKiBUaGUgc291cmNlIG9mIHRoZSBjdXJyZW50IHRva2VuLCBzZXQgaW4gcGFyc2UoKSAqL1xuICAgICAgICB0aGlzLnNvdXJjZSA9ICcnO1xuICAgICAgICAvKiogVGhlIHR5cGUgb2YgdGhlIGN1cnJlbnQgdG9rZW4sIHNldCBpbiBwYXJzZSgpICovXG4gICAgICAgIHRoaXMudHlwZSA9ICcnO1xuICAgICAgICAvLyBNdXN0IGJlIGRlZmluZWQgYWZ0ZXIgYG5leHQoKWBcbiAgICAgICAgdGhpcy5sZXhlciA9IG5ldyBMZXhlcigpO1xuICAgICAgICB0aGlzLm9uTmV3TGluZSA9IG9uTmV3TGluZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGFyc2UgYHNvdXJjZWAgYXMgYSBZQU1MIHN0cmVhbS5cbiAgICAgKiBJZiBgaW5jb21wbGV0ZWAsIGEgcGFydCBvZiB0aGUgbGFzdCBsaW5lIG1heSBiZSBsZWZ0IGFzIGEgYnVmZmVyIGZvciB0aGUgbmV4dCBjYWxsLlxuICAgICAqXG4gICAgICogRXJyb3JzIGFyZSBub3QgdGhyb3duLCBidXQgeWllbGRlZCBhcyBgeyB0eXBlOiAnZXJyb3InLCBtZXNzYWdlIH1gIHRva2Vucy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEEgZ2VuZXJhdG9yIG9mIHRva2VucyByZXByZXNlbnRpbmcgZWFjaCBkaXJlY3RpdmUsIGRvY3VtZW50LCBhbmQgb3RoZXIgc3RydWN0dXJlLlxuICAgICAqL1xuICAgICpwYXJzZShzb3VyY2UsIGluY29tcGxldGUgPSBmYWxzZSkge1xuICAgICAgICBpZiAodGhpcy5vbk5ld0xpbmUgJiYgdGhpcy5vZmZzZXQgPT09IDApXG4gICAgICAgICAgICB0aGlzLm9uTmV3TGluZSgwKTtcbiAgICAgICAgZm9yIChjb25zdCBsZXhlbWUgb2YgdGhpcy5sZXhlci5sZXgoc291cmNlLCBpbmNvbXBsZXRlKSlcbiAgICAgICAgICAgIHlpZWxkKiB0aGlzLm5leHQobGV4ZW1lKTtcbiAgICAgICAgaWYgKCFpbmNvbXBsZXRlKVxuICAgICAgICAgICAgeWllbGQqIHRoaXMuZW5kKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkdmFuY2UgdGhlIHBhcnNlciBieSB0aGUgYHNvdXJjZWAgb2Ygb25lIGxleGljYWwgdG9rZW4uXG4gICAgICovXG4gICAgKm5leHQoc291cmNlKSB7XG4gICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgICBpZiAodGhpcy5hdFNjYWxhcikge1xuICAgICAgICAgICAgdGhpcy5hdFNjYWxhciA9IGZhbHNlO1xuICAgICAgICAgICAgeWllbGQqIHRoaXMuc3RlcCgpO1xuICAgICAgICAgICAgdGhpcy5vZmZzZXQgKz0gc291cmNlLmxlbmd0aDtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0eXBlID0gdG9rZW5UeXBlKHNvdXJjZSk7XG4gICAgICAgIGlmICghdHlwZSkge1xuICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IGBOb3QgYSBZQU1MIHRva2VuOiAke3NvdXJjZX1gO1xuICAgICAgICAgICAgeWllbGQqIHRoaXMucG9wKHsgdHlwZTogJ2Vycm9yJywgb2Zmc2V0OiB0aGlzLm9mZnNldCwgbWVzc2FnZSwgc291cmNlIH0pO1xuICAgICAgICAgICAgdGhpcy5vZmZzZXQgKz0gc291cmNlLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlID09PSAnc2NhbGFyJykge1xuICAgICAgICAgICAgdGhpcy5hdE5ld0xpbmUgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuYXRTY2FsYXIgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy50eXBlID0gJ3NjYWxhcic7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICAgICAgeWllbGQqIHRoaXMuc3RlcCgpO1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnbmV3bGluZSc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXROZXdMaW5lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmRlbnQgPSAwO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5vbk5ld0xpbmUpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9uTmV3TGluZSh0aGlzLm9mZnNldCArIHNvdXJjZS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdzcGFjZSc6XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmF0TmV3TGluZSAmJiBzb3VyY2VbMF0gPT09ICcgJylcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW5kZW50ICs9IHNvdXJjZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2V4cGxpY2l0LWtleS1pbmQnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ21hcC12YWx1ZS1pbmQnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ3NlcS1pdGVtLWluZCc6XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmF0TmV3TGluZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW5kZW50ICs9IHNvdXJjZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2RvYy1tb2RlJzpcbiAgICAgICAgICAgICAgICBjYXNlICdmbG93LWVycm9yLWVuZCc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmF0TmV3TGluZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5vZmZzZXQgKz0gc291cmNlLmxlbmd0aDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiogQ2FsbCBhdCBlbmQgb2YgaW5wdXQgdG8gcHVzaCBvdXQgYW55IHJlbWFpbmluZyBjb25zdHJ1Y3Rpb25zICovXG4gICAgKmVuZCgpIHtcbiAgICAgICAgd2hpbGUgKHRoaXMuc3RhY2subGVuZ3RoID4gMClcbiAgICAgICAgICAgIHlpZWxkKiB0aGlzLnBvcCgpO1xuICAgIH1cbiAgICBnZXQgc291cmNlVG9rZW4oKSB7XG4gICAgICAgIGNvbnN0IHN0ID0ge1xuICAgICAgICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgICAgICAgb2Zmc2V0OiB0aGlzLm9mZnNldCxcbiAgICAgICAgICAgIGluZGVudDogdGhpcy5pbmRlbnQsXG4gICAgICAgICAgICBzb3VyY2U6IHRoaXMuc291cmNlXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBzdDtcbiAgICB9XG4gICAgKnN0ZXAoKSB7XG4gICAgICAgIGNvbnN0IHRvcCA9IHRoaXMucGVlaygxKTtcbiAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gJ2RvYy1lbmQnICYmICghdG9wIHx8IHRvcC50eXBlICE9PSAnZG9jLWVuZCcpKSB7XG4gICAgICAgICAgICB3aGlsZSAodGhpcy5zdGFjay5sZW5ndGggPiAwKVxuICAgICAgICAgICAgICAgIHlpZWxkKiB0aGlzLnBvcCgpO1xuICAgICAgICAgICAgdGhpcy5zdGFjay5wdXNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnZG9jLWVuZCcsXG4gICAgICAgICAgICAgICAgb2Zmc2V0OiB0aGlzLm9mZnNldCxcbiAgICAgICAgICAgICAgICBzb3VyY2U6IHRoaXMuc291cmNlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRvcClcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCogdGhpcy5zdHJlYW0oKTtcbiAgICAgICAgc3dpdGNoICh0b3AudHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnZG9jdW1lbnQnOlxuICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCogdGhpcy5kb2N1bWVudCh0b3ApO1xuICAgICAgICAgICAgY2FzZSAnYWxpYXMnOlxuICAgICAgICAgICAgY2FzZSAnc2NhbGFyJzpcbiAgICAgICAgICAgIGNhc2UgJ3NpbmdsZS1xdW90ZWQtc2NhbGFyJzpcbiAgICAgICAgICAgIGNhc2UgJ2RvdWJsZS1xdW90ZWQtc2NhbGFyJzpcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQqIHRoaXMuc2NhbGFyKHRvcCk7XG4gICAgICAgICAgICBjYXNlICdibG9jay1zY2FsYXInOlxuICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCogdGhpcy5ibG9ja1NjYWxhcih0b3ApO1xuICAgICAgICAgICAgY2FzZSAnYmxvY2stbWFwJzpcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQqIHRoaXMuYmxvY2tNYXAodG9wKTtcbiAgICAgICAgICAgIGNhc2UgJ2Jsb2NrLXNlcSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkKiB0aGlzLmJsb2NrU2VxdWVuY2UodG9wKTtcbiAgICAgICAgICAgIGNhc2UgJ2Zsb3ctY29sbGVjdGlvbic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkKiB0aGlzLmZsb3dDb2xsZWN0aW9uKHRvcCk7XG4gICAgICAgICAgICBjYXNlICdkb2MtZW5kJzpcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQqIHRoaXMuZG9jdW1lbnRFbmQodG9wKTtcbiAgICAgICAgfVxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCBzaG91bGQgbm90IGhhcHBlbiAqL1xuICAgICAgICB5aWVsZCogdGhpcy5wb3AoKTtcbiAgICB9XG4gICAgcGVlayhuKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gbl07XG4gICAgfVxuICAgICpwb3AoZXJyb3IpIHtcbiAgICAgICAgY29uc3QgdG9rZW4gPSBlcnJvciB8fCB0aGlzLnN0YWNrLnBvcCgpO1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgc2hvdWxkIG5vdCBoYXBwZW4gKi9cbiAgICAgICAgaWYgKCF0b2tlbikge1xuICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9ICdUcmllZCB0byBwb3AgYW4gZW1wdHkgc3RhY2snO1xuICAgICAgICAgICAgeWllbGQgeyB0eXBlOiAnZXJyb3InLCBvZmZzZXQ6IHRoaXMub2Zmc2V0LCBzb3VyY2U6ICcnLCBtZXNzYWdlIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5zdGFjay5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHlpZWxkIHRva2VuO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgdG9wID0gdGhpcy5wZWVrKDEpO1xuICAgICAgICAgICAgaWYgKHRva2VuLnR5cGUgPT09ICdibG9jay1zY2FsYXInKSB7XG4gICAgICAgICAgICAgICAgLy8gQmxvY2sgc2NhbGFycyB1c2UgdGhlaXIgcGFyZW50IHJhdGhlciB0aGFuIGhlYWRlciBpbmRlbnRcbiAgICAgICAgICAgICAgICB0b2tlbi5pbmRlbnQgPSAnaW5kZW50JyBpbiB0b3AgPyB0b3AuaW5kZW50IDogMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRva2VuLnR5cGUgPT09ICdmbG93LWNvbGxlY3Rpb24nICYmIHRvcC50eXBlID09PSAnZG9jdW1lbnQnKSB7XG4gICAgICAgICAgICAgICAgLy8gSWdub3JlIGFsbCBpbmRlbnQgZm9yIHRvcC1sZXZlbCBmbG93IGNvbGxlY3Rpb25zXG4gICAgICAgICAgICAgICAgdG9rZW4uaW5kZW50ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0b2tlbi50eXBlID09PSAnZmxvdy1jb2xsZWN0aW9uJylcbiAgICAgICAgICAgICAgICBmaXhGbG93U2VxSXRlbXModG9rZW4pO1xuICAgICAgICAgICAgc3dpdGNoICh0b3AudHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2RvY3VtZW50JzpcbiAgICAgICAgICAgICAgICAgICAgdG9wLnZhbHVlID0gdG9rZW47XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2Jsb2NrLXNjYWxhcic6XG4gICAgICAgICAgICAgICAgICAgIHRvcC5wcm9wcy5wdXNoKHRva2VuKTsgLy8gZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnYmxvY2stbWFwJzoge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpdCA9IHRvcC5pdGVtc1t0b3AuaXRlbXMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChpdC52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9wLml0ZW1zLnB1c2goeyBzdGFydDogW10sIGtleTogdG9rZW4sIHNlcDogW10gfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9uS2V5TGluZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaXQuc2VwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdC52YWx1ZSA9IHRva2VuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihpdCwgeyBrZXk6IHRva2VuLCBzZXA6IFtdIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vbktleUxpbmUgPSAhaW5jbHVkZXNUb2tlbihpdC5zdGFydCwgJ2V4cGxpY2l0LWtleS1pbmQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAnYmxvY2stc2VxJzoge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpdCA9IHRvcC5pdGVtc1t0b3AuaXRlbXMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChpdC52YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvcC5pdGVtcy5wdXNoKHsgc3RhcnQ6IFtdLCB2YWx1ZTogdG9rZW4gfSk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0LnZhbHVlID0gdG9rZW47XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlICdmbG93LWNvbGxlY3Rpb24nOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGl0ID0gdG9wLml0ZW1zW3RvcC5pdGVtcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpdCB8fCBpdC52YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvcC5pdGVtcy5wdXNoKHsgc3RhcnQ6IFtdLCBrZXk6IHRva2VuLCBzZXA6IFtdIH0pO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpdC5zZXApXG4gICAgICAgICAgICAgICAgICAgICAgICBpdC52YWx1ZSA9IHRva2VuO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKGl0LCB7IGtleTogdG9rZW4sIHNlcDogW10gfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgc2hvdWxkIG5vdCBoYXBwZW4gKi9cbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB5aWVsZCogdGhpcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQqIHRoaXMucG9wKHRva2VuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgodG9wLnR5cGUgPT09ICdkb2N1bWVudCcgfHxcbiAgICAgICAgICAgICAgICB0b3AudHlwZSA9PT0gJ2Jsb2NrLW1hcCcgfHxcbiAgICAgICAgICAgICAgICB0b3AudHlwZSA9PT0gJ2Jsb2NrLXNlcScpICYmXG4gICAgICAgICAgICAgICAgKHRva2VuLnR5cGUgPT09ICdibG9jay1tYXAnIHx8IHRva2VuLnR5cGUgPT09ICdibG9jay1zZXEnKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxhc3QgPSB0b2tlbi5pdGVtc1t0b2tlbi5pdGVtcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICBpZiAobGFzdCAmJlxuICAgICAgICAgICAgICAgICAgICAhbGFzdC5zZXAgJiZcbiAgICAgICAgICAgICAgICAgICAgIWxhc3QudmFsdWUgJiZcbiAgICAgICAgICAgICAgICAgICAgbGFzdC5zdGFydC5sZW5ndGggPiAwICYmXG4gICAgICAgICAgICAgICAgICAgICFpbmNsdWRlc05vbkVtcHR5KGxhc3Quc3RhcnQpICYmXG4gICAgICAgICAgICAgICAgICAgICh0b2tlbi5pbmRlbnQgPT09IDAgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3Quc3RhcnQuZXZlcnkoc3QgPT4gc3QudHlwZSAhPT0gJ2NvbW1lbnQnIHx8IHN0LmluZGVudCA8IHRva2VuLmluZGVudCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0b3AudHlwZSA9PT0gJ2RvY3VtZW50JylcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvcC5lbmQgPSBsYXN0LnN0YXJ0O1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICB0b3AuaXRlbXMucHVzaCh7IHN0YXJ0OiBsYXN0LnN0YXJ0IH0pO1xuICAgICAgICAgICAgICAgICAgICB0b2tlbi5pdGVtcy5zcGxpY2UoLTEsIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAqc3RyZWFtKCkge1xuICAgICAgICBzd2l0Y2ggKHRoaXMudHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnZGlyZWN0aXZlLWxpbmUnOlxuICAgICAgICAgICAgICAgIHlpZWxkIHsgdHlwZTogJ2RpcmVjdGl2ZScsIG9mZnNldDogdGhpcy5vZmZzZXQsIHNvdXJjZTogdGhpcy5zb3VyY2UgfTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjYXNlICdieXRlLW9yZGVyLW1hcmsnOlxuICAgICAgICAgICAgY2FzZSAnc3BhY2UnOlxuICAgICAgICAgICAgY2FzZSAnY29tbWVudCc6XG4gICAgICAgICAgICBjYXNlICduZXdsaW5lJzpcbiAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLnNvdXJjZVRva2VuO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNhc2UgJ2RvYy1tb2RlJzpcbiAgICAgICAgICAgIGNhc2UgJ2RvYy1zdGFydCc6IHtcbiAgICAgICAgICAgICAgICBjb25zdCBkb2MgPSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdkb2N1bWVudCcsXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldDogdGhpcy5vZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBbXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gJ2RvYy1zdGFydCcpXG4gICAgICAgICAgICAgICAgICAgIGRvYy5zdGFydC5wdXNoKHRoaXMuc291cmNlVG9rZW4pO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhY2sucHVzaChkb2MpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB5aWVsZCB7XG4gICAgICAgICAgICB0eXBlOiAnZXJyb3InLFxuICAgICAgICAgICAgb2Zmc2V0OiB0aGlzLm9mZnNldCxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGBVbmV4cGVjdGVkICR7dGhpcy50eXBlfSB0b2tlbiBpbiBZQU1MIHN0cmVhbWAsXG4gICAgICAgICAgICBzb3VyY2U6IHRoaXMuc291cmNlXG4gICAgICAgIH07XG4gICAgfVxuICAgICpkb2N1bWVudChkb2MpIHtcbiAgICAgICAgaWYgKGRvYy52YWx1ZSlcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCogdGhpcy5saW5lRW5kKGRvYyk7XG4gICAgICAgIHN3aXRjaCAodGhpcy50eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdkb2Mtc3RhcnQnOiB7XG4gICAgICAgICAgICAgICAgaWYgKGluY2x1ZGVzTm9uRW1wdHkoZG9jLnN0YXJ0KSkge1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCogdGhpcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQqIHRoaXMuc3RlcCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGRvYy5zdGFydC5wdXNoKHRoaXMuc291cmNlVG9rZW4pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ2FuY2hvcic6XG4gICAgICAgICAgICBjYXNlICd0YWcnOlxuICAgICAgICAgICAgY2FzZSAnc3BhY2UnOlxuICAgICAgICAgICAgY2FzZSAnY29tbWVudCc6XG4gICAgICAgICAgICBjYXNlICduZXdsaW5lJzpcbiAgICAgICAgICAgICAgICBkb2Muc3RhcnQucHVzaCh0aGlzLnNvdXJjZVRva2VuKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYnYgPSB0aGlzLnN0YXJ0QmxvY2tWYWx1ZShkb2MpO1xuICAgICAgICBpZiAoYnYpXG4gICAgICAgICAgICB0aGlzLnN0YWNrLnB1c2goYnYpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHlpZWxkIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnZXJyb3InLFxuICAgICAgICAgICAgICAgIG9mZnNldDogdGhpcy5vZmZzZXQsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogYFVuZXhwZWN0ZWQgJHt0aGlzLnR5cGV9IHRva2VuIGluIFlBTUwgZG9jdW1lbnRgLFxuICAgICAgICAgICAgICAgIHNvdXJjZTogdGhpcy5zb3VyY2VcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgKnNjYWxhcihzY2FsYXIpIHtcbiAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gJ21hcC12YWx1ZS1pbmQnKSB7XG4gICAgICAgICAgICBjb25zdCBwcmV2ID0gZ2V0UHJldlByb3BzKHRoaXMucGVlaygyKSk7XG4gICAgICAgICAgICBjb25zdCBzdGFydCA9IGdldEZpcnN0S2V5U3RhcnRQcm9wcyhwcmV2KTtcbiAgICAgICAgICAgIGxldCBzZXA7XG4gICAgICAgICAgICBpZiAoc2NhbGFyLmVuZCkge1xuICAgICAgICAgICAgICAgIHNlcCA9IHNjYWxhci5lbmQ7XG4gICAgICAgICAgICAgICAgc2VwLnB1c2godGhpcy5zb3VyY2VUb2tlbik7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHNjYWxhci5lbmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgc2VwID0gW3RoaXMuc291cmNlVG9rZW5dO1xuICAgICAgICAgICAgY29uc3QgbWFwID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdibG9jay1tYXAnLFxuICAgICAgICAgICAgICAgIG9mZnNldDogc2NhbGFyLm9mZnNldCxcbiAgICAgICAgICAgICAgICBpbmRlbnQ6IHNjYWxhci5pbmRlbnQsXG4gICAgICAgICAgICAgICAgaXRlbXM6IFt7IHN0YXJ0LCBrZXk6IHNjYWxhciwgc2VwIH1dXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5vbktleUxpbmUgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdID0gbWFwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHlpZWxkKiB0aGlzLmxpbmVFbmQoc2NhbGFyKTtcbiAgICB9XG4gICAgKmJsb2NrU2NhbGFyKHNjYWxhcikge1xuICAgICAgICBzd2l0Y2ggKHRoaXMudHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnc3BhY2UnOlxuICAgICAgICAgICAgY2FzZSAnY29tbWVudCc6XG4gICAgICAgICAgICBjYXNlICduZXdsaW5lJzpcbiAgICAgICAgICAgICAgICBzY2FsYXIucHJvcHMucHVzaCh0aGlzLnNvdXJjZVRva2VuKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjYXNlICdzY2FsYXInOlxuICAgICAgICAgICAgICAgIHNjYWxhci5zb3VyY2UgPSB0aGlzLnNvdXJjZTtcbiAgICAgICAgICAgICAgICAvLyBibG9jay1zY2FsYXIgc291cmNlIGluY2x1ZGVzIHRyYWlsaW5nIG5ld2xpbmVcbiAgICAgICAgICAgICAgICB0aGlzLmF0TmV3TGluZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5pbmRlbnQgPSAwO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9uTmV3TGluZSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbmwgPSB0aGlzLnNvdXJjZS5pbmRleE9mKCdcXG4nKSArIDE7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChubCAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vbk5ld0xpbmUodGhpcy5vZmZzZXQgKyBubCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBubCA9IHRoaXMuc291cmNlLmluZGV4T2YoJ1xcbicsIG5sKSArIDE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgeWllbGQqIHRoaXMucG9wKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCBzaG91bGQgbm90IGhhcHBlbiAqL1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB5aWVsZCogdGhpcy5wb3AoKTtcbiAgICAgICAgICAgICAgICB5aWVsZCogdGhpcy5zdGVwKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgKmJsb2NrTWFwKG1hcCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IGl0ID0gbWFwLml0ZW1zW21hcC5pdGVtcy5sZW5ndGggLSAxXTtcbiAgICAgICAgLy8gaXQuc2VwIGlzIHRydWUtaXNoIGlmIHBhaXIgYWxyZWFkeSBoYXMga2V5IG9yIDogc2VwYXJhdG9yXG4gICAgICAgIHN3aXRjaCAodGhpcy50eXBlKSB7XG4gICAgICAgICAgICBjYXNlICduZXdsaW5lJzpcbiAgICAgICAgICAgICAgICB0aGlzLm9uS2V5TGluZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGlmIChpdC52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlbmQgPSAnZW5kJyBpbiBpdC52YWx1ZSA/IGl0LnZhbHVlLmVuZCA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGFzdCA9IEFycmF5LmlzQXJyYXkoZW5kKSA/IGVuZFtlbmQubGVuZ3RoIC0gMV0gOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICgobGFzdCA9PT0gbnVsbCB8fCBsYXN0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsYXN0LnR5cGUpID09PSAnY29tbWVudCcpXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmQgPT09IG51bGwgfHwgZW5kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlbmQucHVzaCh0aGlzLnNvdXJjZVRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgbWFwLml0ZW1zLnB1c2goeyBzdGFydDogW3RoaXMuc291cmNlVG9rZW5dIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpdC5zZXApXG4gICAgICAgICAgICAgICAgICAgIGl0LnNlcC5wdXNoKHRoaXMuc291cmNlVG9rZW4pO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgaXQuc3RhcnQucHVzaCh0aGlzLnNvdXJjZVRva2VuKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjYXNlICdzcGFjZSc6XG4gICAgICAgICAgICBjYXNlICdjb21tZW50JzpcbiAgICAgICAgICAgICAgICBpZiAoaXQudmFsdWUpXG4gICAgICAgICAgICAgICAgICAgIG1hcC5pdGVtcy5wdXNoKHsgc3RhcnQ6IFt0aGlzLnNvdXJjZVRva2VuXSB9KTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpdC5zZXApXG4gICAgICAgICAgICAgICAgICAgIGl0LnNlcC5wdXNoKHRoaXMuc291cmNlVG9rZW4pO1xuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5hdEluZGVudGVkQ29tbWVudChpdC5zdGFydCwgbWFwLmluZGVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHByZXYgPSBtYXAuaXRlbXNbbWFwLml0ZW1zLmxlbmd0aCAtIDJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZW5kID0gKF9hID0gcHJldiA9PT0gbnVsbCB8fCBwcmV2ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwcmV2LnZhbHVlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZW5kO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZW5kKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGVuZCwgaXQuc3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZC5wdXNoKHRoaXMuc291cmNlVG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcC5pdGVtcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaXQuc3RhcnQucHVzaCh0aGlzLnNvdXJjZVRva2VuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmluZGVudCA+PSBtYXAuaW5kZW50KSB7XG4gICAgICAgICAgICBjb25zdCBhdE5leHRJdGVtID0gIXRoaXMub25LZXlMaW5lICYmXG4gICAgICAgICAgICAgICAgdGhpcy5pbmRlbnQgPT09IG1hcC5pbmRlbnQgJiZcbiAgICAgICAgICAgICAgICAoaXQuc2VwIHx8IGluY2x1ZGVzTm9uRW1wdHkoaXQuc3RhcnQpKTtcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy50eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnYW5jaG9yJzpcbiAgICAgICAgICAgICAgICBjYXNlICd0YWcnOlxuICAgICAgICAgICAgICAgICAgICBpZiAoYXROZXh0SXRlbSB8fCBpdC52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFwLml0ZW1zLnB1c2goeyBzdGFydDogW3RoaXMuc291cmNlVG9rZW5dIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vbktleUxpbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGl0LnNlcClcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0LnNlcC5wdXNoKHRoaXMuc291cmNlVG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBpdC5zdGFydC5wdXNoKHRoaXMuc291cmNlVG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgY2FzZSAnZXhwbGljaXQta2V5LWluZCc6XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXQuc2VwICYmICFpbmNsdWRlc1Rva2VuKGl0LnN0YXJ0LCAnZXhwbGljaXQta2V5LWluZCcpKVxuICAgICAgICAgICAgICAgICAgICAgICAgaXQuc3RhcnQucHVzaCh0aGlzLnNvdXJjZVRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoYXROZXh0SXRlbSB8fCBpdC52YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcC5pdGVtcy5wdXNoKHsgc3RhcnQ6IFt0aGlzLnNvdXJjZVRva2VuXSB9KTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGFjay5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnYmxvY2stbWFwJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IHRoaXMub2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGVudDogdGhpcy5pbmRlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbXM6IFt7IHN0YXJ0OiBbdGhpcy5zb3VyY2VUb2tlbl0gfV1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uS2V5TGluZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBjYXNlICdtYXAtdmFsdWUtaW5kJzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpdC5zZXApXG4gICAgICAgICAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKGl0LCB7IGtleTogbnVsbCwgc2VwOiBbdGhpcy5zb3VyY2VUb2tlbl0gfSk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGl0LnZhbHVlIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAoYXROZXh0SXRlbSAmJiAhaW5jbHVkZXNUb2tlbihpdC5zdGFydCwgJ2V4cGxpY2l0LWtleS1pbmQnKSkpXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXAuaXRlbXMucHVzaCh7IHN0YXJ0OiBbXSwga2V5OiBudWxsLCBzZXA6IFt0aGlzLnNvdXJjZVRva2VuXSB9KTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaW5jbHVkZXNUb2tlbihpdC5zZXAsICdtYXAtdmFsdWUtaW5kJykpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YWNrLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdibG9jay1tYXAnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldDogdGhpcy5vZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZW50OiB0aGlzLmluZGVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtczogW3sgc3RhcnQ6IFtdLCBrZXk6IG51bGwsIHNlcDogW3RoaXMuc291cmNlVG9rZW5dIH1dXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaW5jbHVkZXNUb2tlbihpdC5zdGFydCwgJ2V4cGxpY2l0LWtleS1pbmQnKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgaXNGbG93VG9rZW4oaXQua2V5KSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgIWluY2x1ZGVzVG9rZW4oaXQuc2VwLCAnbmV3bGluZScpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzdGFydCA9IGdldEZpcnN0S2V5U3RhcnRQcm9wcyhpdC5zdGFydCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBpdC5rZXk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzZXAgPSBpdC5zZXA7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXAucHVzaCh0aGlzLnNvdXJjZVRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmUgdHlwZSBndWFyZCBpcyB3cm9uZyBoZXJlXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgaXQua2V5LCBkZWxldGUgaXQuc2VwO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGFjay5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnYmxvY2stbWFwJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IHRoaXMub2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGVudDogdGhpcy5pbmRlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbXM6IFt7IHN0YXJ0LCBrZXksIHNlcCB9XVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgaXQuc2VwLnB1c2godGhpcy5zb3VyY2VUb2tlbik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25LZXlMaW5lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2FsaWFzJzpcbiAgICAgICAgICAgICAgICBjYXNlICdzY2FsYXInOlxuICAgICAgICAgICAgICAgIGNhc2UgJ3NpbmdsZS1xdW90ZWQtc2NhbGFyJzpcbiAgICAgICAgICAgICAgICBjYXNlICdkb3VibGUtcXVvdGVkLXNjYWxhcic6IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZnMgPSB0aGlzLmZsb3dTY2FsYXIodGhpcy50eXBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGF0TmV4dEl0ZW0gfHwgaXQudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcC5pdGVtcy5wdXNoKHsgc3RhcnQ6IFtdLCBrZXk6IGZzLCBzZXA6IFtdIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vbktleUxpbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGl0LnNlcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGFjay5wdXNoKGZzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oaXQsIHsga2V5OiBmcywgc2VwOiBbXSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub25LZXlMaW5lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYnYgPSB0aGlzLnN0YXJ0QmxvY2tWYWx1ZShtYXApO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYnYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhdE5leHRJdGVtICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnYudHlwZSAhPT0gJ2Jsb2NrLXNlcScgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmNsdWRlc1Rva2VuKGl0LnN0YXJ0LCAnZXhwbGljaXQta2V5LWluZCcpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcC5pdGVtcy5wdXNoKHsgc3RhcnQ6IFtdIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGFjay5wdXNoKGJ2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB5aWVsZCogdGhpcy5wb3AoKTtcbiAgICAgICAgeWllbGQqIHRoaXMuc3RlcCgpO1xuICAgIH1cbiAgICAqYmxvY2tTZXF1ZW5jZShzZXEpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBpdCA9IHNlcS5pdGVtc1tzZXEuaXRlbXMubGVuZ3RoIC0gMV07XG4gICAgICAgIHN3aXRjaCAodGhpcy50eXBlKSB7XG4gICAgICAgICAgICBjYXNlICduZXdsaW5lJzpcbiAgICAgICAgICAgICAgICBpZiAoaXQudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZW5kID0gJ2VuZCcgaW4gaXQudmFsdWUgPyBpdC52YWx1ZS5lbmQgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxhc3QgPSBBcnJheS5pc0FycmF5KGVuZCkgPyBlbmRbZW5kLmxlbmd0aCAtIDFdIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICBpZiAoKGxhc3QgPT09IG51bGwgfHwgbGFzdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGFzdC50eXBlKSA9PT0gJ2NvbW1lbnQnKVxuICAgICAgICAgICAgICAgICAgICAgICAgZW5kID09PSBudWxsIHx8IGVuZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogZW5kLnB1c2godGhpcy5zb3VyY2VUb2tlbik7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcS5pdGVtcy5wdXNoKHsgc3RhcnQ6IFt0aGlzLnNvdXJjZVRva2VuXSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBpdC5zdGFydC5wdXNoKHRoaXMuc291cmNlVG9rZW4pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNhc2UgJ3NwYWNlJzpcbiAgICAgICAgICAgIGNhc2UgJ2NvbW1lbnQnOlxuICAgICAgICAgICAgICAgIGlmIChpdC52YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgc2VxLml0ZW1zLnB1c2goeyBzdGFydDogW3RoaXMuc291cmNlVG9rZW5dIH0pO1xuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5hdEluZGVudGVkQ29tbWVudChpdC5zdGFydCwgc2VxLmluZGVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHByZXYgPSBzZXEuaXRlbXNbc2VxLml0ZW1zLmxlbmd0aCAtIDJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZW5kID0gKF9hID0gcHJldiA9PT0gbnVsbCB8fCBwcmV2ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwcmV2LnZhbHVlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZW5kO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZW5kKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGVuZCwgaXQuc3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZC5wdXNoKHRoaXMuc291cmNlVG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlcS5pdGVtcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaXQuc3RhcnQucHVzaCh0aGlzLnNvdXJjZVRva2VuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY2FzZSAnYW5jaG9yJzpcbiAgICAgICAgICAgIGNhc2UgJ3RhZyc6XG4gICAgICAgICAgICAgICAgaWYgKGl0LnZhbHVlIHx8IHRoaXMuaW5kZW50IDw9IHNlcS5pbmRlbnQpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGl0LnN0YXJ0LnB1c2godGhpcy5zb3VyY2VUb2tlbik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY2FzZSAnc2VxLWl0ZW0taW5kJzpcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pbmRlbnQgIT09IHNlcS5pbmRlbnQpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGlmIChpdC52YWx1ZSB8fCBpbmNsdWRlc1Rva2VuKGl0LnN0YXJ0LCAnc2VxLWl0ZW0taW5kJykpXG4gICAgICAgICAgICAgICAgICAgIHNlcS5pdGVtcy5wdXNoKHsgc3RhcnQ6IFt0aGlzLnNvdXJjZVRva2VuXSB9KTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGl0LnN0YXJ0LnB1c2godGhpcy5zb3VyY2VUb2tlbik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmluZGVudCA+IHNlcS5pbmRlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IGJ2ID0gdGhpcy5zdGFydEJsb2NrVmFsdWUoc2VxKTtcbiAgICAgICAgICAgIGlmIChidikge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhY2sucHVzaChidik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHlpZWxkKiB0aGlzLnBvcCgpO1xuICAgICAgICB5aWVsZCogdGhpcy5zdGVwKCk7XG4gICAgfVxuICAgICpmbG93Q29sbGVjdGlvbihmYykge1xuICAgICAgICBjb25zdCBpdCA9IGZjLml0ZW1zW2ZjLml0ZW1zLmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAodGhpcy50eXBlID09PSAnZmxvdy1lcnJvci1lbmQnKSB7XG4gICAgICAgICAgICBsZXQgdG9wO1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIHlpZWxkKiB0aGlzLnBvcCgpO1xuICAgICAgICAgICAgICAgIHRvcCA9IHRoaXMucGVlaygxKTtcbiAgICAgICAgICAgIH0gd2hpbGUgKHRvcCAmJiB0b3AudHlwZSA9PT0gJ2Zsb3ctY29sbGVjdGlvbicpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGZjLmVuZC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy50eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnY29tbWEnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2V4cGxpY2l0LWtleS1pbmQnOlxuICAgICAgICAgICAgICAgICAgICBpZiAoIWl0IHx8IGl0LnNlcClcbiAgICAgICAgICAgICAgICAgICAgICAgIGZjLml0ZW1zLnB1c2goeyBzdGFydDogW3RoaXMuc291cmNlVG9rZW5dIH0pO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBpdC5zdGFydC5wdXNoKHRoaXMuc291cmNlVG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgY2FzZSAnbWFwLXZhbHVlLWluZCc6XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXQgfHwgaXQudmFsdWUpXG4gICAgICAgICAgICAgICAgICAgICAgICBmYy5pdGVtcy5wdXNoKHsgc3RhcnQ6IFtdLCBrZXk6IG51bGwsIHNlcDogW3RoaXMuc291cmNlVG9rZW5dIH0pO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpdC5zZXApXG4gICAgICAgICAgICAgICAgICAgICAgICBpdC5zZXAucHVzaCh0aGlzLnNvdXJjZVRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihpdCwgeyBrZXk6IG51bGwsIHNlcDogW3RoaXMuc291cmNlVG9rZW5dIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgY2FzZSAnc3BhY2UnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2NvbW1lbnQnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ25ld2xpbmUnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2FuY2hvcic6XG4gICAgICAgICAgICAgICAgY2FzZSAndGFnJzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpdCB8fCBpdC52YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGZjLml0ZW1zLnB1c2goeyBzdGFydDogW3RoaXMuc291cmNlVG9rZW5dIH0pO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpdC5zZXApXG4gICAgICAgICAgICAgICAgICAgICAgICBpdC5zZXAucHVzaCh0aGlzLnNvdXJjZVRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgaXQuc3RhcnQucHVzaCh0aGlzLnNvdXJjZVRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2FsaWFzJzpcbiAgICAgICAgICAgICAgICBjYXNlICdzY2FsYXInOlxuICAgICAgICAgICAgICAgIGNhc2UgJ3NpbmdsZS1xdW90ZWQtc2NhbGFyJzpcbiAgICAgICAgICAgICAgICBjYXNlICdkb3VibGUtcXVvdGVkLXNjYWxhcic6IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZnMgPSB0aGlzLmZsb3dTY2FsYXIodGhpcy50eXBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpdCB8fCBpdC52YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGZjLml0ZW1zLnB1c2goeyBzdGFydDogW10sIGtleTogZnMsIHNlcDogW10gfSk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGl0LnNlcClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhY2sucHVzaChmcyk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oaXQsIHsga2V5OiBmcywgc2VwOiBbXSB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlICdmbG93LW1hcC1lbmQnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2Zsb3ctc2VxLWVuZCc6XG4gICAgICAgICAgICAgICAgICAgIGZjLmVuZC5wdXNoKHRoaXMuc291cmNlVG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBidiA9IHRoaXMuc3RhcnRCbG9ja1ZhbHVlKGZjKTtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlIHNob3VsZCBub3QgaGFwcGVuICovXG4gICAgICAgICAgICBpZiAoYnYpXG4gICAgICAgICAgICAgICAgdGhpcy5zdGFjay5wdXNoKGJ2KTtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHlpZWxkKiB0aGlzLnBvcCgpO1xuICAgICAgICAgICAgICAgIHlpZWxkKiB0aGlzLnN0ZXAoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcmVudCA9IHRoaXMucGVlaygyKTtcbiAgICAgICAgICAgIGlmIChwYXJlbnQudHlwZSA9PT0gJ2Jsb2NrLW1hcCcgJiZcbiAgICAgICAgICAgICAgICAodGhpcy50eXBlID09PSAnbWFwLXZhbHVlLWluZCcgfHxcbiAgICAgICAgICAgICAgICAgICAgKHRoaXMudHlwZSA9PT0gJ25ld2xpbmUnICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAhcGFyZW50Lml0ZW1zW3BhcmVudC5pdGVtcy5sZW5ndGggLSAxXS5zZXApKSkge1xuICAgICAgICAgICAgICAgIHlpZWxkKiB0aGlzLnBvcCgpO1xuICAgICAgICAgICAgICAgIHlpZWxkKiB0aGlzLnN0ZXAoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMudHlwZSA9PT0gJ21hcC12YWx1ZS1pbmQnICYmXG4gICAgICAgICAgICAgICAgcGFyZW50LnR5cGUgIT09ICdmbG93LWNvbGxlY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJldiA9IGdldFByZXZQcm9wcyhwYXJlbnQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gZ2V0Rmlyc3RLZXlTdGFydFByb3BzKHByZXYpO1xuICAgICAgICAgICAgICAgIGZpeEZsb3dTZXFJdGVtcyhmYyk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2VwID0gZmMuZW5kLnNwbGljZSgxLCBmYy5lbmQubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBzZXAucHVzaCh0aGlzLnNvdXJjZVRva2VuKTtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXAgPSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdibG9jay1tYXAnLFxuICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IGZjLm9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgaW5kZW50OiBmYy5pbmRlbnQsXG4gICAgICAgICAgICAgICAgICAgIGl0ZW1zOiBbeyBzdGFydCwga2V5OiBmYywgc2VwIH1dXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0aGlzLm9uS2V5TGluZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdID0gbWFwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgeWllbGQqIHRoaXMubGluZUVuZChmYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZmxvd1NjYWxhcih0eXBlKSB7XG4gICAgICAgIGlmICh0aGlzLm9uTmV3TGluZSkge1xuICAgICAgICAgICAgbGV0IG5sID0gdGhpcy5zb3VyY2UuaW5kZXhPZignXFxuJykgKyAxO1xuICAgICAgICAgICAgd2hpbGUgKG5sICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vbk5ld0xpbmUodGhpcy5vZmZzZXQgKyBubCk7XG4gICAgICAgICAgICAgICAgbmwgPSB0aGlzLnNvdXJjZS5pbmRleE9mKCdcXG4nLCBubCkgKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgb2Zmc2V0OiB0aGlzLm9mZnNldCxcbiAgICAgICAgICAgIGluZGVudDogdGhpcy5pbmRlbnQsXG4gICAgICAgICAgICBzb3VyY2U6IHRoaXMuc291cmNlXG4gICAgICAgIH07XG4gICAgfVxuICAgIHN0YXJ0QmxvY2tWYWx1ZShwYXJlbnQpIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2FsaWFzJzpcbiAgICAgICAgICAgIGNhc2UgJ3NjYWxhcic6XG4gICAgICAgICAgICBjYXNlICdzaW5nbGUtcXVvdGVkLXNjYWxhcic6XG4gICAgICAgICAgICBjYXNlICdkb3VibGUtcXVvdGVkLXNjYWxhcic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmxvd1NjYWxhcih0aGlzLnR5cGUpO1xuICAgICAgICAgICAgY2FzZSAnYmxvY2stc2NhbGFyLWhlYWRlcic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2Jsb2NrLXNjYWxhcicsXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldDogdGhpcy5vZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgIGluZGVudDogdGhpcy5pbmRlbnQsXG4gICAgICAgICAgICAgICAgICAgIHByb3BzOiBbdGhpcy5zb3VyY2VUb2tlbl0sXG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZTogJydcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgY2FzZSAnZmxvdy1tYXAtc3RhcnQnOlxuICAgICAgICAgICAgY2FzZSAnZmxvdy1zZXEtc3RhcnQnOlxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdmbG93LWNvbGxlY3Rpb24nLFxuICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IHRoaXMub2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICBpbmRlbnQ6IHRoaXMuaW5kZW50LFxuICAgICAgICAgICAgICAgICAgICBzdGFydDogdGhpcy5zb3VyY2VUb2tlbixcbiAgICAgICAgICAgICAgICAgICAgaXRlbXM6IFtdLFxuICAgICAgICAgICAgICAgICAgICBlbmQ6IFtdXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNhc2UgJ3NlcS1pdGVtLWluZCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2Jsb2NrLXNlcScsXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldDogdGhpcy5vZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgIGluZGVudDogdGhpcy5pbmRlbnQsXG4gICAgICAgICAgICAgICAgICAgIGl0ZW1zOiBbeyBzdGFydDogW3RoaXMuc291cmNlVG9rZW5dIH1dXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNhc2UgJ2V4cGxpY2l0LWtleS1pbmQnOiB7XG4gICAgICAgICAgICAgICAgdGhpcy5vbktleUxpbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNvbnN0IHByZXYgPSBnZXRQcmV2UHJvcHMocGFyZW50KTtcbiAgICAgICAgICAgICAgICBjb25zdCBzdGFydCA9IGdldEZpcnN0S2V5U3RhcnRQcm9wcyhwcmV2KTtcbiAgICAgICAgICAgICAgICBzdGFydC5wdXNoKHRoaXMuc291cmNlVG9rZW4pO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdibG9jay1tYXAnLFxuICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IHRoaXMub2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICBpbmRlbnQ6IHRoaXMuaW5kZW50LFxuICAgICAgICAgICAgICAgICAgICBpdGVtczogW3sgc3RhcnQgfV1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnbWFwLXZhbHVlLWluZCc6IHtcbiAgICAgICAgICAgICAgICB0aGlzLm9uS2V5TGluZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJldiA9IGdldFByZXZQcm9wcyhwYXJlbnQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gZ2V0Rmlyc3RLZXlTdGFydFByb3BzKHByZXYpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdibG9jay1tYXAnLFxuICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IHRoaXMub2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICBpbmRlbnQ6IHRoaXMuaW5kZW50LFxuICAgICAgICAgICAgICAgICAgICBpdGVtczogW3sgc3RhcnQsIGtleTogbnVsbCwgc2VwOiBbdGhpcy5zb3VyY2VUb2tlbl0gfV1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBhdEluZGVudGVkQ29tbWVudChzdGFydCwgaW5kZW50KSB7XG4gICAgICAgIGlmICh0aGlzLnR5cGUgIT09ICdjb21tZW50JylcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuaW5kZW50IDw9IGluZGVudClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHN0YXJ0LmV2ZXJ5KHN0ID0+IHN0LnR5cGUgPT09ICduZXdsaW5lJyB8fCBzdC50eXBlID09PSAnc3BhY2UnKTtcbiAgICB9XG4gICAgKmRvY3VtZW50RW5kKGRvY0VuZCkge1xuICAgICAgICBpZiAodGhpcy50eXBlICE9PSAnZG9jLW1vZGUnKSB7XG4gICAgICAgICAgICBpZiAoZG9jRW5kLmVuZClcbiAgICAgICAgICAgICAgICBkb2NFbmQuZW5kLnB1c2godGhpcy5zb3VyY2VUb2tlbik7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgZG9jRW5kLmVuZCA9IFt0aGlzLnNvdXJjZVRva2VuXTtcbiAgICAgICAgICAgIGlmICh0aGlzLnR5cGUgPT09ICduZXdsaW5lJylcbiAgICAgICAgICAgICAgICB5aWVsZCogdGhpcy5wb3AoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAqbGluZUVuZCh0b2tlbikge1xuICAgICAgICBzd2l0Y2ggKHRoaXMudHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnY29tbWEnOlxuICAgICAgICAgICAgY2FzZSAnZG9jLXN0YXJ0JzpcbiAgICAgICAgICAgIGNhc2UgJ2RvYy1lbmQnOlxuICAgICAgICAgICAgY2FzZSAnZmxvdy1zZXEtZW5kJzpcbiAgICAgICAgICAgIGNhc2UgJ2Zsb3ctbWFwLWVuZCc6XG4gICAgICAgICAgICBjYXNlICdtYXAtdmFsdWUtaW5kJzpcbiAgICAgICAgICAgICAgICB5aWVsZCogdGhpcy5wb3AoKTtcbiAgICAgICAgICAgICAgICB5aWVsZCogdGhpcy5zdGVwKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICduZXdsaW5lJzpcbiAgICAgICAgICAgICAgICB0aGlzLm9uS2V5TGluZSA9IGZhbHNlO1xuICAgICAgICAgICAgLy8gZmFsbHRocm91Z2hcbiAgICAgICAgICAgIGNhc2UgJ3NwYWNlJzpcbiAgICAgICAgICAgIGNhc2UgJ2NvbW1lbnQnOlxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAvLyBhbGwgb3RoZXIgdmFsdWVzIGFyZSBlcnJvcnNcbiAgICAgICAgICAgICAgICBpZiAodG9rZW4uZW5kKVxuICAgICAgICAgICAgICAgICAgICB0b2tlbi5lbmQucHVzaCh0aGlzLnNvdXJjZVRva2VuKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHRva2VuLmVuZCA9IFt0aGlzLnNvdXJjZVRva2VuXTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy50eXBlID09PSAnbmV3bGluZScpXG4gICAgICAgICAgICAgICAgICAgIHlpZWxkKiB0aGlzLnBvcCgpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgeyBQYXJzZXIgfTtcbiIsICJpbXBvcnQgeyBDb21wb3NlciB9IGZyb20gJy4vY29tcG9zZS9jb21wb3Nlci5qcyc7XG5pbXBvcnQgeyBEb2N1bWVudCB9IGZyb20gJy4vZG9jL0RvY3VtZW50LmpzJztcbmltcG9ydCB7IHByZXR0aWZ5RXJyb3IsIFlBTUxQYXJzZUVycm9yIH0gZnJvbSAnLi9lcnJvcnMuanMnO1xuaW1wb3J0IHsgd2FybiB9IGZyb20gJy4vbG9nLmpzJztcbmltcG9ydCB7IExpbmVDb3VudGVyIH0gZnJvbSAnLi9wYXJzZS9saW5lLWNvdW50ZXIuanMnO1xuaW1wb3J0IHsgUGFyc2VyIH0gZnJvbSAnLi9wYXJzZS9wYXJzZXIuanMnO1xuXG5mdW5jdGlvbiBwYXJzZU9wdGlvbnMob3B0aW9ucykge1xuICAgIGNvbnN0IHByZXR0eUVycm9ycyA9IG9wdGlvbnMucHJldHR5RXJyb3JzICE9PSBmYWxzZTtcbiAgICBjb25zdCBsaW5lQ291bnRlciA9IG9wdGlvbnMubGluZUNvdW50ZXIgfHwgKHByZXR0eUVycm9ycyAmJiBuZXcgTGluZUNvdW50ZXIoKSkgfHwgbnVsbDtcbiAgICByZXR1cm4geyBsaW5lQ291bnRlciwgcHJldHR5RXJyb3JzIH07XG59XG4vKipcbiAqIFBhcnNlIHRoZSBpbnB1dCBhcyBhIHN0cmVhbSBvZiBZQU1MIGRvY3VtZW50cy5cbiAqXG4gKiBEb2N1bWVudHMgc2hvdWxkIGJlIHNlcGFyYXRlZCBmcm9tIGVhY2ggb3RoZXIgYnkgYC4uLmAgb3IgYC0tLWAgbWFya2VyIGxpbmVzLlxuICpcbiAqIEByZXR1cm5zIElmIGFuIGVtcHR5IGBkb2NzYCBhcnJheSBpcyByZXR1cm5lZCwgaXQgd2lsbCBiZSBvZiB0eXBlXG4gKiAgIEVtcHR5U3RyZWFtIGFuZCBjb250YWluIGFkZGl0aW9uYWwgc3RyZWFtIGluZm9ybWF0aW9uLiBJblxuICogICBUeXBlU2NyaXB0LCB5b3Ugc2hvdWxkIHVzZSBgJ2VtcHR5JyBpbiBkb2NzYCBhcyBhIHR5cGUgZ3VhcmQgZm9yIGl0LlxuICovXG5mdW5jdGlvbiBwYXJzZUFsbERvY3VtZW50cyhzb3VyY2UsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgbGluZUNvdW50ZXIsIHByZXR0eUVycm9ycyB9ID0gcGFyc2VPcHRpb25zKG9wdGlvbnMpO1xuICAgIGNvbnN0IHBhcnNlciA9IG5ldyBQYXJzZXIobGluZUNvdW50ZXIgPT09IG51bGwgfHwgbGluZUNvdW50ZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxpbmVDb3VudGVyLmFkZE5ld0xpbmUpO1xuICAgIGNvbnN0IGNvbXBvc2VyID0gbmV3IENvbXBvc2VyKG9wdGlvbnMpO1xuICAgIGNvbnN0IGRvY3MgPSBBcnJheS5mcm9tKGNvbXBvc2VyLmNvbXBvc2UocGFyc2VyLnBhcnNlKHNvdXJjZSkpKTtcbiAgICBpZiAocHJldHR5RXJyb3JzICYmIGxpbmVDb3VudGVyKVxuICAgICAgICBmb3IgKGNvbnN0IGRvYyBvZiBkb2NzKSB7XG4gICAgICAgICAgICBkb2MuZXJyb3JzLmZvckVhY2gocHJldHRpZnlFcnJvcihzb3VyY2UsIGxpbmVDb3VudGVyKSk7XG4gICAgICAgICAgICBkb2Mud2FybmluZ3MuZm9yRWFjaChwcmV0dGlmeUVycm9yKHNvdXJjZSwgbGluZUNvdW50ZXIpKTtcbiAgICAgICAgfVxuICAgIGlmIChkb2NzLmxlbmd0aCA+IDApXG4gICAgICAgIHJldHVybiBkb2NzO1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKFtdLCB7IGVtcHR5OiB0cnVlIH0sIGNvbXBvc2VyLnN0cmVhbUluZm8oKSk7XG59XG4vKiogUGFyc2UgYW4gaW5wdXQgc3RyaW5nIGludG8gYSBzaW5nbGUgWUFNTC5Eb2N1bWVudCAqL1xuZnVuY3Rpb24gcGFyc2VEb2N1bWVudChzb3VyY2UsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgbGluZUNvdW50ZXIsIHByZXR0eUVycm9ycyB9ID0gcGFyc2VPcHRpb25zKG9wdGlvbnMpO1xuICAgIGNvbnN0IHBhcnNlciA9IG5ldyBQYXJzZXIobGluZUNvdW50ZXIgPT09IG51bGwgfHwgbGluZUNvdW50ZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxpbmVDb3VudGVyLmFkZE5ld0xpbmUpO1xuICAgIGNvbnN0IGNvbXBvc2VyID0gbmV3IENvbXBvc2VyKG9wdGlvbnMpO1xuICAgIC8vIGBkb2NgIGlzIGFsd2F5cyBzZXQgYnkgY29tcG9zZS5lbmQodHJ1ZSkgYXQgdGhlIHZlcnkgbGF0ZXN0XG4gICAgbGV0IGRvYyA9IG51bGw7XG4gICAgZm9yIChjb25zdCBfZG9jIG9mIGNvbXBvc2VyLmNvbXBvc2UocGFyc2VyLnBhcnNlKHNvdXJjZSksIHRydWUsIHNvdXJjZS5sZW5ndGgpKSB7XG4gICAgICAgIGlmICghZG9jKVxuICAgICAgICAgICAgZG9jID0gX2RvYztcbiAgICAgICAgZWxzZSBpZiAoZG9jLm9wdGlvbnMubG9nTGV2ZWwgIT09ICdzaWxlbnQnKSB7XG4gICAgICAgICAgICBkb2MuZXJyb3JzLnB1c2gobmV3IFlBTUxQYXJzZUVycm9yKF9kb2MucmFuZ2Uuc2xpY2UoMCwgMiksICdNVUxUSVBMRV9ET0NTJywgJ1NvdXJjZSBjb250YWlucyBtdWx0aXBsZSBkb2N1bWVudHM7IHBsZWFzZSB1c2UgWUFNTC5wYXJzZUFsbERvY3VtZW50cygpJykpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHByZXR0eUVycm9ycyAmJiBsaW5lQ291bnRlcikge1xuICAgICAgICBkb2MuZXJyb3JzLmZvckVhY2gocHJldHRpZnlFcnJvcihzb3VyY2UsIGxpbmVDb3VudGVyKSk7XG4gICAgICAgIGRvYy53YXJuaW5ncy5mb3JFYWNoKHByZXR0aWZ5RXJyb3Ioc291cmNlLCBsaW5lQ291bnRlcikpO1xuICAgIH1cbiAgICByZXR1cm4gZG9jO1xufVxuZnVuY3Rpb24gcGFyc2Uoc3JjLCByZXZpdmVyLCBvcHRpb25zKSB7XG4gICAgbGV0IF9yZXZpdmVyID0gdW5kZWZpbmVkO1xuICAgIGlmICh0eXBlb2YgcmV2aXZlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBfcmV2aXZlciA9IHJldml2ZXI7XG4gICAgfVxuICAgIGVsc2UgaWYgKG9wdGlvbnMgPT09IHVuZGVmaW5lZCAmJiByZXZpdmVyICYmIHR5cGVvZiByZXZpdmVyID09PSAnb2JqZWN0Jykge1xuICAgICAgICBvcHRpb25zID0gcmV2aXZlcjtcbiAgICB9XG4gICAgY29uc3QgZG9jID0gcGFyc2VEb2N1bWVudChzcmMsIG9wdGlvbnMpO1xuICAgIGlmICghZG9jKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBkb2Mud2FybmluZ3MuZm9yRWFjaCh3YXJuaW5nID0+IHdhcm4oZG9jLm9wdGlvbnMubG9nTGV2ZWwsIHdhcm5pbmcpKTtcbiAgICBpZiAoZG9jLmVycm9ycy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGlmIChkb2Mub3B0aW9ucy5sb2dMZXZlbCAhPT0gJ3NpbGVudCcpXG4gICAgICAgICAgICB0aHJvdyBkb2MuZXJyb3JzWzBdO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBkb2MuZXJyb3JzID0gW107XG4gICAgfVxuICAgIHJldHVybiBkb2MudG9KUyhPYmplY3QuYXNzaWduKHsgcmV2aXZlcjogX3Jldml2ZXIgfSwgb3B0aW9ucykpO1xufVxuZnVuY3Rpb24gc3RyaW5naWZ5KHZhbHVlLCByZXBsYWNlciwgb3B0aW9ucykge1xuICAgIGxldCBfcmVwbGFjZXIgPSBudWxsO1xuICAgIGlmICh0eXBlb2YgcmVwbGFjZXIgPT09ICdmdW5jdGlvbicgfHwgQXJyYXkuaXNBcnJheShyZXBsYWNlcikpIHtcbiAgICAgICAgX3JlcGxhY2VyID0gcmVwbGFjZXI7XG4gICAgfVxuICAgIGVsc2UgaWYgKG9wdGlvbnMgPT09IHVuZGVmaW5lZCAmJiByZXBsYWNlcikge1xuICAgICAgICBvcHRpb25zID0gcmVwbGFjZXI7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ3N0cmluZycpXG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zLmxlbmd0aDtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGNvbnN0IGluZGVudCA9IE1hdGgucm91bmQob3B0aW9ucyk7XG4gICAgICAgIG9wdGlvbnMgPSBpbmRlbnQgPCAxID8gdW5kZWZpbmVkIDogaW5kZW50ID4gOCA/IHsgaW5kZW50OiA4IH0gOiB7IGluZGVudCB9O1xuICAgIH1cbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCB7IGtlZXBVbmRlZmluZWQgfSA9IG9wdGlvbnMgfHwgcmVwbGFjZXIgfHwge307XG4gICAgICAgIGlmICgha2VlcFVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiBuZXcgRG9jdW1lbnQodmFsdWUsIF9yZXBsYWNlciwgb3B0aW9ucykudG9TdHJpbmcob3B0aW9ucyk7XG59XG5cbmV4cG9ydCB7IHBhcnNlLCBwYXJzZUFsbERvY3VtZW50cywgcGFyc2VEb2N1bWVudCwgc3RyaW5naWZ5IH07XG4iLCAiaW1wb3J0IHsgQXBwLCBFZGl0b3IsIEZ1enp5U3VnZ2VzdE1vZGFsLCBGdXp6eU1hdGNoIH0gZnJvbSBcIm9ic2lkaWFuXCI7XG5cbmludGVyZmFjZSBGb290bm90ZVR5cGUge1xuICB0eXBlOiBzdHJpbmc7XG4gIGRlc2NyaXB0aW9uOiBzdHJpbmc7XG59XG5cbmNvbnN0IEFMTF9UWVBFUyA9IFtcbiAge1xuICAgIHR5cGU6IFwiZC9xdWVzdGlvblwiLFxuICAgIGRlc2NyaXB0aW9uOiBcIlF1ZXN0aW9uXCJcbiAgfSxcbiAge1xuICAgIHR5cGU6IFwiZC9hbnN3ZXJcIixcbiAgICBkZXNjcmlwdGlvbjogXCJBbnN3ZXJcIlxuICB9LFxuICB7XG4gICAgdHlwZTogXCJkL3NvbHZlc1wiLFxuICAgIGRlc2NyaXB0aW9uOiBcIlNvbHZlcyBzb21lIHByb2JsZW1cIlxuICB9LFxuICB7XG4gICAgdHlwZTogXCJkL3JlZlwiLFxuICAgIGRlc2NyaXB0aW9uOiBcIlJlZmVyZW5jZVwiXG4gIH0sXG4gIHtcbiAgICB0eXBlOiBcImQvc2VsZnRoaW5rXCIsXG4gICAgZGVzY3JpcHRpb246IFwiU2VsZiB0aGlua1wiXG4gIH0sXG4gIHtcbiAgICB0eXBlOiBcImQvbm90c3VyZVwiLFxuICAgIGRlc2NyaXB0aW9uOiBcIk5vdCBzdXJlXCJcbiAgfSxcbiAge1xuICAgIHR5cGU6IFwiZC9hMVx1MjNGOVx1RkUwRlwiLFxuICAgIGRlc2NyaXB0aW9uOiBcIkExIC0gbXkgZXhwZXJpZW5jZVwiXG4gIH0sXG4gIHtcbiAgICB0eXBlOiBcImQvYTJcdTIzRkFcdUZFMEZcIixcbiAgICBkZXNjcmlwdGlvbjogXCJBMiAtIGZ1dHVyZSBhY3Rpb25cIlxuICB9LFxuICB7XG4gICAgdHlwZTogXCJkL2NcdUQ4M0RcdUREMDRcIixcbiAgICBkZXNjcmlwdGlvbjogXCJDb250ZXh0XCJcbiAgfSxcbiAge1xuICAgIHR5cGU6IFwiZC93XHUyM0VBXCIsXG4gICAgZGVzY3JpcHRpb246IFwiSWRlYSBDb21wYXNzIC0gV2VzdCAtIFdoYXQgYXJlIHNpbWlsYXIgLyBzdXBwb3J0aW5nIGlkZWE/XCJcbiAgfSxcbiAge1xuICAgIHR5cGU6IFwiZC9uXHUyM0VCXCIsXG4gICAgZGVzY3JpcHRpb246IFwiSWRlYSBDb21wYXNzIC0gTm9ydGggLSBXaGVyZSBkb2VzIHRoaXMgaWRlYSBjb21lIGZyb20/XCJcbiAgfSxcbiAge1xuICAgIHR5cGU6IFwiZC9zXHUyM0VDXCIsXG4gICAgZGVzY3JpcHRpb246IFwiSWRlYSBDb21wYXNzIC0gU291dGggLSBXaGVyZSBkb2VzIHRoZSBpZGVhIGxlYWQgdG8/XCJcbiAgfSxcbiAge1xuICAgIHR5cGU6IFwiZC90b01lcmdlXCIsXG4gICAgZGVzY3JpcHRpb246IFwiVE9ETyAtIFRvIE1lcmdlIHdpdGggYW5vdGhlciBub3RlXCJcbiAgfSxcbiAge1xuICAgIHR5cGU6IFwiZC90b01vdmVcIixcbiAgICBkZXNjcmlwdGlvbjogXCJUT0RPIC0gVG8gTWVyZ2Ugd2l0aCBhbm90aGVyIG5vdGVcIlxuICB9LFxuICB7XG4gICAgdHlwZTogXCJkL3RvU3BsaXRcIixcbiAgICBkZXNjcmlwdGlvbjogXCJUb0RPIC0gVG8gU3BsaXQgdG8gbXVsdGlwbGUgbm90ZVwiXG4gIH0sXG4gIHtcbiAgICB0eXBlOiBcImQvdG9DYXJkXCIsXG4gICAgZGVzY3JpcHRpb246IFwiVE9ETyAtIFRvIFdyaXRlIGNhcmRcIlxuICB9LFxuXTtcblxuZXhwb3J0IGNsYXNzIEFkZEZvb3Rub3RlVGFnTW9kYWwgZXh0ZW5kcyBGdXp6eVN1Z2dlc3RNb2RhbDxGb290bm90ZVR5cGU+IHtcblxuICBlZGl0b3I6IEVkaXRvclxuXG4gIGNvbnN0cnVjdG9yKGFwcDogQXBwLCBlZGl0b3I6IEVkaXRvcilcbiAge1xuICAgIHN1cGVyKGFwcClcbiAgICB0aGlzLmVkaXRvciA9IGVkaXRvclxuICB9XG5cbiAgZ2V0SXRlbXMoKTogRm9vdG5vdGVUeXBlW10ge1xuICAgIHJldHVybiBBTExfVFlQRVM7XG4gIH1cblxuICBnZXRJdGVtVGV4dChub3RlVHlwZTogRm9vdG5vdGVUeXBlKTogc3RyaW5nIHtcbiAgICByZXR1cm4gbm90ZVR5cGUudHlwZTtcbiAgfVxuXG4gIHN0YXRpYyByZW1vdmVUYWcobGluZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgICBBTExfVFlQRVMuZm9yRWFjaCgobm90ZVR5cGUpID0+IGxpbmUgPSBsaW5lLnJlcGxhY2UoYCMke25vdGVUeXBlLnR5cGV9IGAsICcnKSlcbiAgICByZXR1cm4gbGluZVxuICB9XG5cbiAgLy8gUmVuZGVycyBlYWNoIHN1Z2dlc3Rpb24gaXRlbS5cbiAgcmVuZGVyU3VnZ2VzdGlvbihjaG9vc2VuTm90ZVR5cGVNYXRjaDogRnV6enlNYXRjaDxGb290bm90ZVR5cGU+LCBlbDogSFRNTEVsZW1lbnQpIHtcbiAgICBjb25zdCBub3RlVHlwZSA9IGNob29zZW5Ob3RlVHlwZU1hdGNoLml0ZW1cbiAgICBlbC5jcmVhdGVFbChcImRpdlwiLCB7IHRleHQ6IG5vdGVUeXBlLnR5cGUgfSk7XG4gICAgZWwuY3JlYXRlRWwoXCJzbWFsbFwiLCB7IHRleHQ6IG5vdGVUeXBlLmRlc2NyaXB0aW9uIH0pO1xuICB9XG5cbiAgY29udGFpbnNUeXBlKGxpbmU6IFN0cmluZykgOiBCb29sZWFuIHtcbiAgICByZXR1cm4gQUxMX1RZUEVTLmZpbHRlcigobm90ZVR5cGUpID0+IGxpbmUuY29udGFpbnMobm90ZVR5cGUudHlwZSkpLmxlbmd0aCA+IDBcbiAgfVxuXG4gIC8vIFBlcmZvcm0gYWN0aW9uIG9uIHRoZSBzZWxlY3RlZCBzdWdnZXN0aW9uLlxuICBvbkNob29zZUl0ZW0oY2hvb3Nlbk5vdGVUeXBlOiBGb290bm90ZVR5cGUsIGV2dDogTW91c2VFdmVudCB8IEtleWJvYXJkRXZlbnQpIHtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSB0aGlzLmVkaXRvci5nZXRTZWxlY3Rpb24oKVxuICAgIGNvbnN0IHJlcGxhY2VkU3RyID0gYCMke2Nob29zZW5Ob3RlVHlwZS50eXBlfSBgXG4gICAgaWYgKHNlbGVjdGlvbi5sZW5ndGggIT0gMCkge1xuICAgICAgICB0aGlzLmVkaXRvci5yZXBsYWNlU2VsZWN0aW9uKHJlcGxhY2VkU3RyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBjdXJzb3IgPSB0aGlzLmVkaXRvci5nZXRDdXJzb3IoKTtcbiAgICAgICAgdGhpcy5lZGl0b3IucmVwbGFjZVJhbmdlKHJlcGxhY2VkU3RyLCBjdXJzb3IpO1xuICAgICAgICBjdXJzb3IuY2ggPSBjdXJzb3IuY2ggKyByZXBsYWNlZFN0ci5sZW5ndGg7XG4gICAgICAgIHRoaXMuZWRpdG9yLnNldEN1cnNvcihjdXJzb3IpO1xuICAgIH1cbiAgfVxufSIsICJpbXBvcnQgeyBBcHAsIEVkaXRvciwgRnV6enlTdWdnZXN0TW9kYWwsIEZ1enp5TWF0Y2ggfSBmcm9tIFwib2JzaWRpYW5cIjtcblxuaW50ZXJmYWNlIENvbW1lbnRUeXBlIHtcbiAgdHlwZTogc3RyaW5nO1xuICBkZXNjcmlwdGlvbjogc3RyaW5nO1xufVxuXG5jb25zdCBBTExfVFlQRVMgPSBbXG4gIHtcbiAgICB0eXBlOiBcIm5cIixcbiAgICBkZXNjcmlwdGlvbjogXCJOXCJcbiAgfSxcbiAge1xuICAgIHR5cGU6IFwid1wiLFxuICAgIGRlc2NyaXB0aW9uOiBcIldcIlxuICB9LFxuICB7XG4gICAgdHlwZTogXCJuXCIsXG4gICAgZGVzY3JpcHRpb246IFwiTlwiXG4gIH0sXG4gIHtcbiAgICB0eXBlOiBcIndcIixcbiAgICBkZXNjcmlwdGlvbjogXCJXXCJcbiAgfSxcbiAge1xuICAgIHR5cGU6IFwiblwiLFxuICAgIGRlc2NyaXB0aW9uOiBcIk5cIlxuICB9LFxuICB7XG4gICAgdHlwZTogXCJ3XCIsXG4gICAgZGVzY3JpcHRpb246IFwiV1wiXG4gIH0sXG4gIHtcbiAgICB0eXBlOiBcIm5cIixcbiAgICBkZXNjcmlwdGlvbjogXCJOXCJcbiAgfSxcbiAge1xuICAgIHR5cGU6IFwid1wiLFxuICAgIGRlc2NyaXB0aW9uOiBcIldcIlxuICB9LFxuICB7XG4gICAgdHlwZTogXCJuXCIsXG4gICAgZGVzY3JpcHRpb246IFwiTlwiXG4gIH0sXG4gIHtcbiAgICB0eXBlOiBcIndcIixcbiAgICBkZXNjcmlwdGlvbjogXCJXXCJcbiAgfVxuXTtcblxuZXhwb3J0IGNsYXNzIEFkZFRhc2tUYWdNb2RhbCBleHRlbmRzIEZ1enp5U3VnZ2VzdE1vZGFsPENvbW1lbnRUeXBlPiB7XG5cbiAgZWRpdG9yOiBFZGl0b3JcbiAgdGFza1R5cGU6IFN0cmluZ1xuXG4gIGNvbnN0cnVjdG9yKGFwcDogQXBwLCBlZGl0b3I6IEVkaXRvciwgdGFza1R5cGU6IFN0cmluZylcbiAge1xuICAgIHN1cGVyKGFwcClcbiAgICB0aGlzLmVkaXRvciA9IGVkaXRvclxuICAgIHRoaXMudGFza1R5cGUgPSB0YXNrVHlwZVxuICB9XG5cbiAgZ2V0SXRlbXMoKTogQ29tbWVudFR5cGVbXSB7XG4gICAgcmV0dXJuIEFMTF9UWVBFUztcbiAgfVxuXG4gIGdldEl0ZW1UZXh0KG5vdGVUeXBlOiBDb21tZW50VHlwZSk6IHN0cmluZyB7XG4gICAgcmV0dXJuIG5vdGVUeXBlLnR5cGU7XG4gIH1cblxuICAvLyBSZW5kZXJzIGVhY2ggc3VnZ2VzdGlvbiBpdGVtLlxuICByZW5kZXJTdWdnZXN0aW9uKGNob29zZW5Ob3RlVHlwZU1hdGNoOiBGdXp6eU1hdGNoPENvbW1lbnRUeXBlPiwgZWw6IEhUTUxFbGVtZW50KSB7XG4gICAgY29uc3Qgbm90ZVR5cGUgPSBjaG9vc2VuTm90ZVR5cGVNYXRjaC5pdGVtXG4gICAgZWwuY3JlYXRlRWwoXCJkaXZcIiwgeyB0ZXh0OiBub3RlVHlwZS50eXBlIH0pO1xuICAgIGVsLmNyZWF0ZUVsKFwic21hbGxcIiwgeyB0ZXh0OiBub3RlVHlwZS5kZXNjcmlwdGlvbiB9KTtcbiAgfVxuXG4gIGNvbnRhaW5zVHlwZShsaW5lOiBTdHJpbmcpIDogQm9vbGVhbiB7XG4gICAgcmV0dXJuIEFMTF9UWVBFUy5maWx0ZXIoKG5vdGVUeXBlKSA9PiBsaW5lLmNvbnRhaW5zKG5vdGVUeXBlLnR5cGUpKS5sZW5ndGggPiAwXG4gIH1cblxuICAvLyBQZXJmb3JtIGFjdGlvbiBvbiB0aGUgc2VsZWN0ZWQgc3VnZ2VzdGlvbi5cbiAgb25DaG9vc2VJdGVtKGNob29zZW5Ob3RlVHlwZTogQ29tbWVudFR5cGUsIGV2dDogTW91c2VFdmVudCB8IEtleWJvYXJkRXZlbnQpIHtcbiAgICBjb25zdCBjdXJzb3IgPSB0aGlzLmVkaXRvci5nZXRDdXJzb3IoKVxuICAgIGNvbnN0IGxpbmUgPSB0aGlzLmVkaXRvci5nZXRMaW5lKGN1cnNvci5saW5lKTtcbiAgICBcbiAgICB0aGlzLmVkaXRvci5yZXBsYWNlUmFuZ2UoYCR7bGluZS5jaGFyQXQoY3Vyc29yLmNoIC0gMSkgIT0gJyAnID8gJyAnIDogXCJcIn0jJHtjaG9vc2VuTm90ZVR5cGUudHlwZX0ke3RoaXMudGFza1R5cGV9IGAsIGN1cnNvcik7ICBcbiAgICBjdXJzb3IuY2ggPSBjdXJzb3IuY2ggKyA0ICsgKGxpbmUuY2hhckF0KGN1cnNvci5jaCAtIDEpICE9ICcgJyA/IDEgOiAwKTtcblx0XHR0aGlzLmVkaXRvci5zZXRDdXJzb3IoY3Vyc29yKTtcbiAgfVxufSIsICJpbXBvcnQgeyBBcHAsIEVkaXRvciwgRnV6enlTdWdnZXN0TW9kYWwsIEZ1enp5TWF0Y2gsIE5vdGljZSB9IGZyb20gXCJvYnNpZGlhblwiO1xuXG5pbnRlcmZhY2UgQ29tbWVudFR5cGUge1xuICB0eXBlOiBzdHJpbmc7XG4gIGRlc2NyaXB0aW9uOiBzdHJpbmc7XG59XG5cbmNvbnN0IEFMTF9UWVBFUyA9IFtcbiAge1xuICAgIHR5cGU6IFwiZmlyc3QtcGFnZVwiLFxuICAgIGRlc2NyaXB0aW9uOiBcImZpcnN0IHBhZ2VcIlxuICB9LFxuICB7XG4gICAgdHlwZTogXCJ3aXRoLWhlYWRlclwiLFxuICAgIGRlc2NyaXB0aW9uOiBcIndpdGggaGVhZGVyXCJcbiAgfSxcbiAge1xuICAgIHR5cGU6IFwid2l0aG91dC1oZWFkZXJcIixcbiAgICBkZXNjcmlwdGlvbjogXCJ3aXRob3V0IGhlYWRlclwiXG4gIH0sXG4gIHtcbiAgICB0eXBlOiBcImN1c3RvbS1mb250LXNpemVcIixcbiAgICBkZXNjcmlwdGlvbjogXCJjdXN0b20gZm9udCBzaXplXCJcbiAgfSxcbl07XG5cbmV4cG9ydCBjbGFzcyBUaHJlYWRzVG9JbWFnZXNNb2RhbCBleHRlbmRzIEZ1enp5U3VnZ2VzdE1vZGFsPENvbW1lbnRUeXBlPiB7XG5cbiAgdGhyZWFkU2VnbWVudDogU3RyaW5nXG5cbiAgY29uc3RydWN0b3IoYXBwOiBBcHAsIHRocmVhZFNlZ21lbnQ6IFN0cmluZylcbiAge1xuICAgIHN1cGVyKGFwcClcbiAgICB0aGlzLnRocmVhZFNlZ21lbnQgPSB0aHJlYWRTZWdtZW50XG4gIH1cblxuICBnZXRJdGVtcygpOiBDb21tZW50VHlwZVtdIHtcbiAgICByZXR1cm4gQUxMX1RZUEVTO1xuICB9XG5cbiAgZ2V0SXRlbVRleHQobm90ZVR5cGU6IENvbW1lbnRUeXBlKTogc3RyaW5nIHtcbiAgICByZXR1cm4gbm90ZVR5cGUudHlwZTtcbiAgfVxuXG4gIC8vIFJlbmRlcnMgZWFjaCBzdWdnZXN0aW9uIGl0ZW0uXG4gIHJlbmRlclN1Z2dlc3Rpb24oY2hvb3Nlbk5vdGVUeXBlTWF0Y2g6IEZ1enp5TWF0Y2g8Q29tbWVudFR5cGU+LCBlbDogSFRNTEVsZW1lbnQpIHtcbiAgICBjb25zdCBub3RlVHlwZSA9IGNob29zZW5Ob3RlVHlwZU1hdGNoLml0ZW1cbiAgICBlbC5jcmVhdGVFbChcImRpdlwiLCB7IHRleHQ6IG5vdGVUeXBlLnR5cGUgfSk7XG4gICAgZWwuY3JlYXRlRWwoXCJzbWFsbFwiLCB7IHRleHQ6IG5vdGVUeXBlLmRlc2NyaXB0aW9uIH0pO1xuICB9XG5cbiAgY29udGFpbnNUeXBlKGxpbmU6IFN0cmluZykgOiBCb29sZWFuIHtcbiAgICByZXR1cm4gQUxMX1RZUEVTLmZpbHRlcigobm90ZVR5cGUpID0+IGxpbmUuY29udGFpbnMobm90ZVR5cGUudHlwZSkpLmxlbmd0aCA+IDBcbiAgfVxuXG4gIC8vIFBlcmZvcm0gYWN0aW9uIG9uIHRoZSBzZWxlY3RlZCBzdWdnZXN0aW9uLlxuICBvbkNob29zZUl0ZW0oY2hvb3Nlbk5vdGVUeXBlOiBDb21tZW50VHlwZSwgZXZ0OiBNb3VzZUV2ZW50IHwgS2V5Ym9hcmRFdmVudCkge1xuICAgIGxldCBwYXJhbSA9IGNob29zZW5Ob3RlVHlwZS50eXBlXG4gICAgbGV0IHMgPSB0aGlzLnRocmVhZFNlZ21lbnQudG9TdHJpbmcoKVxuICAgIG5hdmlnYXRvci5jbGlwYm9hcmQud3JpdGVUZXh0KHRoaXMudGhyZWFkU2VnbWVudC50b1N0cmluZygpKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbmV3IE5vdGljZShgQ29waWVkXFxuXFxgXFxgXFxgXFxuJHtzfVxcYFxcYFxcYFxcbnRvIGNsaXBib2FyZCFgKTtcbiAgICAgICAgd2luZG93Lm9wZW4oYHNob3J0Y3V0czovL3J1bi1zaG9ydGN1dD9uYW1lPVRocmVhZHMlMjB0byUyMGltYWdlJmlucHV0PXRleHQmdGV4dD0ke3BhcmFtfSZ4LXN1Y2Nlc3M9b2JzaWRpYW46Ly8meC1jYW5jZWw9b2JzaWRpYW46Ly8meC1lcnJvcj1vYnNpZGlhbjovL2ApO1xuICAgIH0sIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICBuZXcgTm90aWNlKGBlcnJvciB3aGVuIGNvcHkgdG8gY2xpcGJvYXJkIWApO1xuICAgIH0pO1xuICB9XG59IiwgImltcG9ydCB7IEFwcCwgRWRpdG9yLCBGdXp6eVN1Z2dlc3RNb2RhbCwgRnV6enlNYXRjaCwgVEZpbGUsIFZhdWx0IH0gZnJvbSBcIm9ic2lkaWFuXCI7XG5cbmludGVyZmFjZSBDb3B5T3JNb3ZlIHtcbiAgdHlwZTogc3RyaW5nO1xuICBkZXNjcmlwdGlvbjogc3RyaW5nO1xufVxuXG5jb25zdCBBTExfVFlQRVMgPSBbXG4gIHtcbiAgICB0eXBlOiBcImNvcHlcIixcbiAgICBkZXNjcmlwdGlvbjogXCJDb3B5XCJcbiAgfSxcbiAge1xuICAgIHR5cGU6IFwibW92ZVwiLFxuICAgIGRlc2NyaXB0aW9uOiBcIk1vdmVcIlxuICB9LFxuXTtcblxuZXhwb3J0IGNsYXNzIENvcHlPck1vdmVUb05ld05vdGVNb2RhbCBleHRlbmRzIEZ1enp5U3VnZ2VzdE1vZGFsPENvcHlPck1vdmU+IHtcblxuICBlZGl0b3I6IEVkaXRvclxuICB0YXNrVHlwZTogU3RyaW5nXG5cbiAgY29uc3RydWN0b3IoYXBwOiBBcHAsIGVkaXRvcjogRWRpdG9yKVxuICB7XG4gICAgc3VwZXIoYXBwKVxuICAgIHRoaXMuZWRpdG9yID0gZWRpdG9yXG4gIH1cblxuICBnZXRJdGVtcygpOiBDb3B5T3JNb3ZlW10ge1xuICAgIHJldHVybiBBTExfVFlQRVM7XG4gIH1cblxuICBnZXRJdGVtVGV4dChub3RlVHlwZTogQ29weU9yTW92ZSk6IHN0cmluZyB7XG4gICAgcmV0dXJuIG5vdGVUeXBlLnR5cGU7XG4gIH1cblxuICAvLyBSZW5kZXJzIGVhY2ggc3VnZ2VzdGlvbiBpdGVtLlxuICByZW5kZXJTdWdnZXN0aW9uKGNob29zZW5Ob3RlVHlwZU1hdGNoOiBGdXp6eU1hdGNoPENvcHlPck1vdmU+LCBlbDogSFRNTEVsZW1lbnQpIHtcbiAgICBjb25zdCBub3RlVHlwZSA9IGNob29zZW5Ob3RlVHlwZU1hdGNoLml0ZW1cbiAgICBlbC5jcmVhdGVFbChcImRpdlwiLCB7IHRleHQ6IG5vdGVUeXBlLnR5cGUgfSk7XG4gICAgZWwuY3JlYXRlRWwoXCJzbWFsbFwiLCB7IHRleHQ6IG5vdGVUeXBlLmRlc2NyaXB0aW9uIH0pO1xuICB9XG5cbiAgY29udGFpbnNUeXBlKGxpbmU6IFN0cmluZykgOiBCb29sZWFuIHtcbiAgICByZXR1cm4gQUxMX1RZUEVTLmZpbHRlcigobm90ZVR5cGUpID0+IGxpbmUuY29udGFpbnMobm90ZVR5cGUudHlwZSkpLmxlbmd0aCA+IDBcbiAgfVxuXG4gIC8vIFBlcmZvcm0gYWN0aW9uIG9uIHRoZSBzZWxlY3RlZCBzdWdnZXN0aW9uLlxuICBhc3luYyBvbkNob29zZUl0ZW0oY2hvb3Nlbk9wZXJhdGlvbjogQ29weU9yTW92ZSwgZXZ0OiBNb3VzZUV2ZW50IHwgS2V5Ym9hcmRFdmVudCkge1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9IHRoaXMuZWRpdG9yLmdldFNlbGVjdGlvbigpXG4gICAgY29uc3QgbGluZSA9IHRoaXMuZWRpdG9yLmdldEN1cnNvcigpLmxpbmVcbiAgICBjb25zdCB0ZXh0VG9Db3B5T3JNb3ZlID0gKHNlbGVjdGlvbi5sZW5ndGggPT0gMClcbiAgICAgICAgICAgICAgICA/IHRoaXMuZWRpdG9yLmdldExpbmUobGluZSlcbiAgICAgICAgICAgICAgICA6IHNlbGVjdGlvblxuICAgIFxuICAgIGNvbnN0IG5ld0ZpbGVOYW1lID0gXCJJL1VuaXRlZCBQdXNoLm1kXCJcbiAgICBhd2FpdCB0aGlzLmNyZWF0ZU9yQXBwZW5kRmlsZShuZXdGaWxlTmFtZSwgdGV4dFRvQ29weU9yTW92ZSlcblxuICAgIGlmIChjaG9vc2VuT3BlcmF0aW9uLnR5cGUgPT0gXCJtb3ZlXCIpIHtcbiAgICAgIGlmIChzZWxlY3Rpb24ubGVuZ3RoICE9IDApIHtcbiAgICAgICAgdGhpcy5lZGl0b3IucmVwbGFjZVNlbGVjdGlvbihcIlwiKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IGNvbnRlbnQgPSBcIlwiXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5lZGl0b3IubGluZUNvdW50KCk7IGkrKykge1xuICAgICAgICAgIGlmIChpICE9IGxpbmUpIHtcbiAgICAgICAgICAgIGNvbnRlbnQgKz0gdGhpcy5lZGl0b3IuZ2V0TGluZShpKSArIFwiXFxuXCJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lZGl0b3Iuc2V0VmFsdWUoY29udGVudClcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCB7IHZhdWx0IH0gPSB0aGlzLmFwcDtcbiAgICBjb25zdCB7IHdvcmtzcGFjZSB9ID0gdGhpcy5hcHA7XG4gICAgY29uc3QgbW9kZSA9ICh0aGlzLmFwcC52YXVsdCBhcyBhbnkpLmdldENvbmZpZyhcImRlZmF1bHRWaWV3TW9kZVwiKTtcbiAgICBjb25zdCBsZWFmID0gd29ya3NwYWNlLmdldExlYWYoZmFsc2UpO1xuICAgIGF3YWl0IGxlYWYub3BlbkZpbGUodmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKG5ld0ZpbGVOYW1lKSBhcyBURmlsZSwgeyBhY3RpdmUgOiB0cnVlLH0pO1xuICB9XG5cbiAgYXN5bmMgY3JlYXRlT3JBcHBlbmRGaWxlKGZpbGVQYXRoOiBzdHJpbmcsIG5vdGU6IHN0cmluZykge1xuXHRcdC8vSWYgZmlsZXMgZXhpc3RzIHRoZW4gYXBwZW5kIGNvbmVudCB0byBleGlzdGluZyBmaWxlXG5cdFx0Y29uc3QgeyB2YXVsdCB9ID0gdGhpcy5hcHA7XG5cdFx0Y29uc3QgZmlsZUV4aXN0cyA9IGF3YWl0IHZhdWx0LmFkYXB0ZXIuZXhpc3RzKGZpbGVQYXRoKTtcblx0XHRpZihmaWxlRXhpc3RzKXtcblx0XHRcdGF3YWl0IHRoaXMuYXBwZW5kRmlsZSh2YXVsdCwgZmlsZVBhdGgsIG5vdGUpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRhd2FpdCB2YXVsdC5jcmVhdGUoZmlsZVBhdGgsIFwiLS0tXFxudGFnOiBiL24vc1xcbi0tLVxcblxcblwiICsgbm90ZSk7XG5cdFx0fVxuXHRcdHJldHVybiBmaWxlUGF0aDtcblx0fVxuXG4gICAgYXN5bmMgYXBwZW5kRmlsZSh2YXVsdDogVmF1bHQsIGZpbGVQYXRoOiBzdHJpbmcsIG5vdGU6IHN0cmluZykge1xuXHRcdGxldCBleGlzdGluZ0NvbnRlbnQgPSBhd2FpdCB2YXVsdC5hZGFwdGVyLnJlYWQoZmlsZVBhdGgpO1xuXHRcdGlmKGV4aXN0aW5nQ29udGVudC5sZW5ndGggPiAwKSB7XG5cdFx0ICBleGlzdGluZ0NvbnRlbnQgPSBleGlzdGluZ0NvbnRlbnQgKyAnXFxyXFxyJztcblx0XHR9XG5cdFx0YXdhaXQgdmF1bHQuYWRhcHRlci53cml0ZShmaWxlUGF0aCwgZXhpc3RpbmdDb250ZW50ICsgbm90ZSk7XG5cdCAgfVxufSIsICJpbXBvcnQgeyBBcHAsIEVkaXRvciwgRnV6enlTdWdnZXN0TW9kYWwsIEZ1enp5TWF0Y2ggfSBmcm9tIFwib2JzaWRpYW5cIjtcblxuZXhwb3J0IGNsYXNzIENsaXBib2FyZFBhc3RlTW9kYWwgZXh0ZW5kcyBGdXp6eVN1Z2dlc3RNb2RhbDxzdHJpbmc+IHtcblxuICBlZGl0b3I6IEVkaXRvclxuXG4gIGNsaXBib2FyZENvbnRlbnQ6IHN0cmluZ1tdXG5cbiAgY29uc3RydWN0b3IoYXBwOiBBcHAsIGVkaXRvcjogRWRpdG9yLCBjbGlwYm9hcmRDb250ZW50OiBzdHJpbmdbXSlcbiAge1xuICAgIHN1cGVyKGFwcClcbiAgICB0aGlzLmVkaXRvciA9IGVkaXRvclxuICAgIHRoaXMuY2xpcGJvYXJkQ29udGVudCA9IGNsaXBib2FyZENvbnRlbnRcbiAgfVxuXG4gIGdldEl0ZW1zKCk6IHN0cmluZ1tdIHtcbiAgICByZXR1cm4gdGhpcy5jbGlwYm9hcmRDb250ZW50LnJldmVyc2UoKTtcbiAgfVxuXG4gIGdldEl0ZW1UZXh0KGl0ZW06IHN0cmluZyk6IHN0cmluZyB7XG4gICAgcmV0dXJuIGl0ZW07XG4gIH1cblxuICAvLyBSZW5kZXJzIGVhY2ggc3VnZ2VzdGlvbiBpdGVtLlxuICByZW5kZXJTdWdnZXN0aW9uKGk6IEZ1enp5TWF0Y2g8c3RyaW5nPiwgZWw6IEhUTUxFbGVtZW50KSB7XG4gICAgY29uc3QgaXRlbSA9IGkuaXRlbVxuICAgIC8vZWwuY3JlYXRlRWwoXCJkaXZcIiwgeyB0ZXh0OiBpdGVtIH0pO1xuICAgIGVsLmNyZWF0ZUVsKFwiZGl2XCIsIHsgdGV4dDogXCJcdTIwMjIgXCIgKyBpdGVtLnJlcGxhY2UoL1xcbi9nbSwgXCJcIikuc3Vic3RyaW5nKDAsIDEwMCkgfSk7XG4gIH1cblxuICAvLyBQZXJmb3JtIGFjdGlvbiBvbiB0aGUgc2VsZWN0ZWQgc3VnZ2VzdGlvbi5cbiAgb25DaG9vc2VJdGVtKHNlbGVjdGVkQ29udGVudDogc3RyaW5nLCBldnQ6IE1vdXNlRXZlbnQgfCBLZXlib2FyZEV2ZW50KSB7XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLmNsaXBib2FyZENvbnRlbnQuaW5kZXhPZihzZWxlY3RlZENvbnRlbnQsIDApO1xuICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICB0aGlzLmNsaXBib2FyZENvbnRlbnQuc3BsaWNlKGluZGV4LCAxKTtcbiAgICB9XG4gICAgdGhpcy5jbGlwYm9hcmRDb250ZW50LnB1c2goc2VsZWN0ZWRDb250ZW50KTtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSB0aGlzLmVkaXRvci5nZXRTZWxlY3Rpb24oKVxuICAgIGNvbnN0IHJlcGxhY2VkU3RyID0gc2VsZWN0ZWRDb250ZW50XG4gICAgaWYgKHNlbGVjdGlvbi5sZW5ndGggIT0gMCkge1xuICAgICAgICB0aGlzLmVkaXRvci5yZXBsYWNlU2VsZWN0aW9uKHJlcGxhY2VkU3RyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBjdXJzb3IgPSB0aGlzLmVkaXRvci5nZXRDdXJzb3IoKTtcbiAgICAgICAgdGhpcy5lZGl0b3IucmVwbGFjZVJhbmdlKHJlcGxhY2VkU3RyLCBjdXJzb3IpO1xuICAgICAgICBjdXJzb3IuY2ggPSBjdXJzb3IuY2ggKyByZXBsYWNlZFN0ci5sZW5ndGg7XG4gICAgICAgIHRoaXMuZWRpdG9yLnNldEN1cnNvcihjdXJzb3IpO1xuICAgIH1cbiAgfVxufSIsICJpbXBvcnQgeyBBcHAsIEVkaXRvciwgRnV6enlTdWdnZXN0TW9kYWwsIEZ1enp5TWF0Y2gsIFRGaWxlIH0gZnJvbSBcIm9ic2lkaWFuXCI7XG5cbmV4cG9ydCBjbGFzcyBPcGVuUGxheWdyb3VuZE1vZGFsIGV4dGVuZHMgRnV6enlTdWdnZXN0TW9kYWw8c3RyaW5nPiB7XG5cbiAgcmVtb3ZlRXhpc3RpbmdDb250ZW50IDogc3RyaW5nID0gXCJSZW1vdmUgcGxheWdyb3VuZCBjb250ZW50XCJcbiAgbm90UmVtb3ZlRXhpc3RpbmdDb250ZW50OiBzdHJpbmcgPSBcIk5vdCByZW1vdmUgZXhpc3RpbmcgcGxheWdyb3VuZCBjb250ZW50XCJcbiAgcGxheWdyb3VuZE1kOiBzdHJpbmcgPSBcIkkvUGxheWdyb3VuZC5tZFwiXG4gIG9wdGlvbnM6IHN0cmluZ1tdID0gW3RoaXMucmVtb3ZlRXhpc3RpbmdDb250ZW50LCB0aGlzLm5vdFJlbW92ZUV4aXN0aW5nQ29udGVudF1cblxuICBjb25zdHJ1Y3RvcihhcHA6IEFwcClcbiAge1xuICAgIHN1cGVyKGFwcClcbiAgfVxuXG4gIGdldEl0ZW1zKCk6IHN0cmluZ1tdIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLnJldmVyc2UoKTtcbiAgfVxuXG4gIGdldEl0ZW1UZXh0KGl0ZW06IHN0cmluZyk6IHN0cmluZyB7XG4gICAgcmV0dXJuIGl0ZW07XG4gIH1cblxuICAvLyBSZW5kZXJzIGVhY2ggc3VnZ2VzdGlvbiBpdGVtLlxuICByZW5kZXJTdWdnZXN0aW9uKGk6IEZ1enp5TWF0Y2g8c3RyaW5nPiwgZWw6IEhUTUxFbGVtZW50KSB7XG4gICAgY29uc3QgaXRlbSA9IGkuaXRlbVxuICAgIGVsLmNyZWF0ZUVsKFwiZGl2XCIsIHsgdGV4dDogaXRlbSB9KTtcbiAgfVxuXG4gIC8vIFBlcmZvcm0gYWN0aW9uIG9uIHRoZSBzZWxlY3RlZCBzdWdnZXN0aW9uLlxuICBhc3luYyBvbkNob29zZUl0ZW0oc2VsZWN0ZWRDb250ZW50OiBzdHJpbmcsIGV2dDogTW91c2VFdmVudCB8IEtleWJvYXJkRXZlbnQpIHtcbiAgICBjb25zdCBjaG9vc2VuT3B0aW9uID0gc2VsZWN0ZWRDb250ZW50XG5cbiAgICBjb25zdCB7IHZhdWx0IH0gPSB0aGlzLmFwcDtcbiAgICBjb25zdCB7IHdvcmtzcGFjZSB9ID0gdGhpcy5hcHA7XG4gICAgY29uc3QgbGVhZiA9IHdvcmtzcGFjZS5nZXRMZWFmKGZhbHNlKTtcblxuICAgIFByb21pc2UucmVzb2x2ZSgpXG4gICAgLnRoZW4oKCkgPT4ge1xuICAgICAgaWYgKHZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aCh0aGlzLnBsYXlncm91bmRNZCkgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdmF1bHQuY3JlYXRlKHRoaXMucGxheWdyb3VuZE1kLCBcIlwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgodGhpcy5wbGF5Z3JvdW5kTWQpXG4gICAgfSlcbiAgICAudGhlbigodEZpbGUpID0+IHtcbiAgICAgIGlmICh0aGlzLnJlbW92ZUV4aXN0aW5nQ29udGVudCA9PT0gY2hvb3Nlbk9wdGlvbikge1xuICAgICAgICByZXR1cm4gdmF1bHQubW9kaWZ5KHRGaWxlIGFzIFRGaWxlLCBcIlwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxuICAgIH0pXG4gICAgLnRoZW4oKCkgPT4ge1xuICAgICAgcmV0dXJuIGxlYWYub3BlbkZpbGUodmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKHRoaXMucGxheWdyb3VuZE1kKSBhcyBURmlsZSwgeyBhY3RpdmUgOiB0cnVlfSk7XG4gICAgfSlcbiAgfVxufSIsICJpbXBvcnQgeyBBcHAsIEVkaXRvciwgRnV6enlTdWdnZXN0TW9kYWwsIEZ1enp5TWF0Y2gsIFRGaWxlLCBOb3RpY2UsIE1hcmtkb3duVmlldyB9IGZyb20gXCJvYnNpZGlhblwiO1xuXG5leHBvcnQgY2xhc3MgVGhyZWFkc1RvQmxvZ01vZGFsIGV4dGVuZHMgRnV6enlTdWdnZXN0TW9kYWw8c3RyaW5nPiB7XG5cbiAgdG9OZXdOb3RlIDogc3RyaW5nID0gXCJUbyBOZXcgTm90ZVwiXG4gIHRvQ2xpcGJvYXJkOiBzdHJpbmcgPSBcIlRvIENsaXBib2FyZFwiXG4gIG9wdGlvbnM6IHN0cmluZ1tdID0gW3RoaXMudG9OZXdOb3RlLCB0aGlzLnRvQ2xpcGJvYXJkXVxuICBlZGl0b3I6IEVkaXRvclxuICB2aWV3OiBNYXJrZG93blZpZXdcblxuICBjb25zdHJ1Y3RvcihhcHA6IEFwcCwgZWRpdG9yOiBFZGl0b3IsIHZpZXc6IE1hcmtkb3duVmlldylcbiAge1xuICAgIHN1cGVyKGFwcClcbiAgICB0aGlzLmVkaXRvciA9IGVkaXRvclxuICAgIHRoaXMudmlldyA9IHZpZXdcbiAgfVxuXG4gIGdldEl0ZW1zKCk6IHN0cmluZ1tdIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zO1xuICB9XG5cbiAgZ2V0SXRlbVRleHQoaXRlbTogc3RyaW5nKTogc3RyaW5nIHtcbiAgICByZXR1cm4gaXRlbTtcbiAgfVxuXG4gIC8vIFJlbmRlcnMgZWFjaCBzdWdnZXN0aW9uIGl0ZW0uXG4gIHJlbmRlclN1Z2dlc3Rpb24oaTogRnV6enlNYXRjaDxzdHJpbmc+LCBlbDogSFRNTEVsZW1lbnQpIHtcbiAgICBjb25zdCBpdGVtID0gaS5pdGVtXG4gICAgZWwuY3JlYXRlRWwoXCJkaXZcIiwgeyB0ZXh0OiBpdGVtIH0pO1xuICB9XG5cbiAgLy8gUGVyZm9ybSBhY3Rpb24gb24gdGhlIHNlbGVjdGVkIHN1Z2dlc3Rpb24uXG4gIG9uQ2hvb3NlSXRlbShzZWxlY3RlZENvbnRlbnQ6IHN0cmluZywgZXZ0OiBNb3VzZUV2ZW50IHwgS2V5Ym9hcmRFdmVudCkge1xuICAgIGNvbnN0IGNob29zZW5PcHRpb24gPSBzZWxlY3RlZENvbnRlbnRcblxuICAgIGNvbnN0IGxpbmVDb3VudCA9IHRoaXMuZWRpdG9yLmxpbmVDb3VudCgpO1xuICAgIGxldCB0YWdMaW5lTnVtYmVyID0gbnVsbDtcbiAgICBsZXQgbWV0YWRhdGFMaW5lQ291bnQgPSAwO1xuICAgIGxldCB0ZXh0ID0gXCJcIlxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZUNvdW50OyBpKyspIHtcbiAgICAgIGxldCBsaW5lID0gdGhpcy5lZGl0b3IuZ2V0TGluZShpKTtcbiAgICAgIGlmICghbGluZS50cmltKCkuc3RhcnRzV2l0aChcIiUlXCIpIHx8ICFsaW5lLnRyaW0oKS5lbmRzV2l0aChcIiUlXCIpKSB7XG4gICAgICAgIGxldCBtb2RpZmllZExpbmUgPSBsaW5lLnJlcGxhY2UoJ1x1RDgzRVx1RERGNSAnLCAnIyAnKS5yZXBsYWNlKCdcdTMwMTAnLCAnJykucmVwbGFjZSgnXHUzMDExJywgJycpLnJlcGxhY2UoJ1x1RDgzRFx1REM0NycsICcnKVxuICAgICAgICBpZiAobW9kaWZpZWRMaW5lID09ICctLS0nKSB7XG4gICAgICAgICAgbWV0YWRhdGFMaW5lQ291bnQrK1xuICAgICAgICAgIGlmIChtZXRhZGF0YUxpbmVDb3VudCA+IDIpIHtcbiAgICAgICAgICAgIGlmIChtZXRhZGF0YUxpbmVDb3VudCA9PSAzKSB7XG4gICAgICAgICAgICAgIG1vZGlmaWVkTGluZSA9IG1vZGlmaWVkTGluZS5yZXBsYWNlKCctLS0nLCAnJylcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobWV0YWRhdGFMaW5lQ291bnQgPT0gNCkge1xuICAgICAgICAgICAgICBtb2RpZmllZExpbmUgPSBtb2RpZmllZExpbmUucmVwbGFjZSgnLS0tJywgJzwhLS1tb3JlLS0+XFxuXFxuKipcdTc2RUVcdTkzMDRcdUZGMUEqKlxcblxcbiogVGFibGUgb2YgQ29udGVudFxcbns6dG9jfVxcblxcbiMjIC4nKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbW9kaWZpZWRMaW5lID0gbW9kaWZpZWRMaW5lLnJlcGxhY2UoJy0tLScsICcjIyAuJylcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobWV0YWRhdGFMaW5lQ291bnQgPT0gMSB8fCBtZXRhZGF0YUxpbmVDb3VudCA9PSAyKSB7XG4gICAgICAgICAgbW9kaWZpZWRMaW5lID0gbW9kaWZpZWRMaW5lLnJlcGxhY2UoXCJjL3QvcFwiLCBcImMvYi9kXCIpXG4gICAgICAgICAgbW9kaWZpZWRMaW5lID0gbW9kaWZpZWRMaW5lLnJlcGxhY2UoXCJjL3QvdFwiLCBcImMvYi9kXCIpXG4gICAgICAgICAgbW9kaWZpZWRMaW5lID0gbW9kaWZpZWRMaW5lLnJlcGxhY2UoXCJjL3QvclwiLCBcImMvYi9kXCIpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoL14hXFxbLipcXF1cXCguKlxcKS8udGVzdChtb2RpZmllZExpbmUudHJpbSgpKSkge1xuICAgICAgICAgIGlmICghbW9kaWZpZWRMaW5lLmNvbnRhaW5zKFwiaHR0cHM6Ly9yb3VsZXNvcGh5LmdpdGh1Yi5pb1wiKSkge1xuICAgICAgICAgICAgbW9kaWZpZWRMaW5lID0gbW9kaWZpZWRMaW5lLnJlcGxhY2UoLyFcXFsoW15cXFtcXF1cXChcXCldKylcXF1cXCgoW15cXFtcXF1cXChcXCldKylcXCkvZywgXCIkMlwiKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0ZXh0ID0gdGV4dCArIG1vZGlmaWVkTGluZSArIFwiXFxuXCI7XG4gICAgICB9XG4gICAgfVxuICAgIHRleHQgKz0gYFxcblxcbi0tLVxcblxcbiNubCBnZW5lcmF0ZSBzdW1tYXJ5IGZvciBtZXRhIGRlc2NyaXB0aW9uIGJlbG93OlxcblxcblxcblxcbmBcbiAgICB0ZXh0ICs9IGAtLS1cXG5cXG4jIyBSZWZlcmVuY2VzOlxcblxcbi0gVGhyZWFkIHBvc3QgMTogW1ske3RoaXMudmlldy5maWxlLmJhc2VuYW1lfV1dXFxuLSBCbG9nIGxpbms6IFxcbmBcblxuICAgIGNvbnN0IHsgdmF1bHQgfSA9IHRoaXMuYXBwO1xuXG4gICAgaWYgKHRoaXMudG9OZXdOb3RlID09PSBjaG9vc2VuT3B0aW9uKSB7XG4gICAgICBjb25zdCB7IHZhdWx0IH0gPSB0aGlzLmFwcDtcbiAgICAgIGNvbnN0IHBhdGggPSB0aGlzLnZpZXcuZmlsZS5wYXRoXG4gICAgICBjb25zdCBuZXdQYXRoID0gcGF0aC5tYXRjaCgvLlxcL1RocmVhZHMgXFxkXFxkXFxkXFxkXFxkXFxkXFxkXFxkLylcbiAgICAgICAgICAgICAgICAgICAgICA/IHBhdGgucmVwbGFjZSgvKC5cXC8pVGhyZWFkcyBcXGRcXGRcXGRcXGRcXGRcXGRcXGRcXGQvLCBcIiQxQmxvZyBcIilcbiAgICAgICAgICAgICAgICAgICAgICA6IHBhdGgucmVwbGFjZSgvKC5cXC8pLywgXCIkMUJsb2cgXCIpXG5cbiAgICAgIGNvbnN0IHsgd29ya3NwYWNlIH0gPSB0aGlzLmFwcDtcbiAgICAgIGNvbnN0IGxlYWYgPSB3b3Jrc3BhY2UuZ2V0TGVhZihmYWxzZSk7XG4gICAgICBQcm9taXNlLnJlc29sdmUoKVxuICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICByZXR1cm4gdmF1bHQuYWRhcHRlci5leGlzdHMobmV3UGF0aCk7XG4gICAgICB9KVxuICAgICAgLnRoZW4oKGZpbGVFeGlzdHMpID0+IHtcbiAgICAgICAgaWYgKGZpbGVFeGlzdHMpIHtcbiAgICAgICAgICBuZXcgTm90aWNlKGBXaWxsIG5vdCBwcm9jZWVkLiBCbG9nIHBvc3QgXCIke25ld1BhdGh9XCIgYWxyZWFkeSBleGlzdC5gKTtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoXCJCbG9nIHBvc3QgZXhpc3RcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhdWx0LmNyZWF0ZShuZXdQYXRoLCB0ZXh0KTtcbiAgICAgIH0pXG4gICAgICAudGhlbigodEZpbGUpID0+IHtcbiAgICAgICAgcmV0dXJuIGxlYWYub3BlbkZpbGUodEZpbGUsIHsgYWN0aXZlIDogdHJ1ZX0pO1xuICAgICAgfSxcbiAgICAgIChyZWplY3RSZWFzb24pID0+IHt9KVxuICAgIH1cbiAgICBpZiAodGhpcy50b0NsaXBib2FyZCA9PT0gY2hvb3Nlbk9wdGlvbikge1xuICAgICAgbmF2aWdhdG9yLmNsaXBib2FyZC53cml0ZVRleHQodGV4dCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIG5ldyBOb3RpY2UoYENvcGllZCBibG9nIGNvbnRlbnQgdG8gY2xpcGJvYXJkIWApO1xuICAgICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgIG5ldyBOb3RpY2UoYGVycm9yIHdoZW4gY29weSB0byBjbGlwYm9hcmQhYCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn0iLCAiaW1wb3J0IHsgQXBwLCBFZGl0b3IsIEZ1enp5U3VnZ2VzdE1vZGFsLCBGdXp6eU1hdGNoLCBOb3RpY2UgfSBmcm9tIFwib2JzaWRpYW5cIjtcblxuZXhwb3J0IGNsYXNzIENsaXBib2FyZFJlbW92YWxNb2RhbCBleHRlbmRzIEZ1enp5U3VnZ2VzdE1vZGFsPHN0cmluZz4ge1xuXG4gIGVkaXRvcjogRWRpdG9yXG5cbiAgY2xpcGJvYXJkQ29udGVudDogc3RyaW5nW11cblxuICBSRU1PVkVfQUxMIDogc3RyaW5nID0gXCJSRU1PVkUgQUxMXCJcblxuICBjb25zdHJ1Y3RvcihhcHA6IEFwcCwgZWRpdG9yOiBFZGl0b3IsIGNsaXBib2FyZENvbnRlbnQ6IHN0cmluZ1tdKVxuICB7XG4gICAgc3VwZXIoYXBwKVxuICAgIHRoaXMuZWRpdG9yID0gZWRpdG9yXG4gICAgdGhpcy5jbGlwYm9hcmRDb250ZW50ID0gY2xpcGJvYXJkQ29udGVudFxuICB9XG5cbiAgZ2V0SXRlbXMoKTogc3RyaW5nW10ge1xuICAgIHJldHVybiBbLi4uW3RoaXMuUkVNT1ZFX0FMTF0sIC4uLnRoaXMuY2xpcGJvYXJkQ29udGVudC5yZXZlcnNlKCldO1xuICB9XG5cbiAgZ2V0SXRlbVRleHQoaXRlbTogc3RyaW5nKTogc3RyaW5nIHtcbiAgICByZXR1cm4gaXRlbTtcbiAgfVxuXG4gIC8vIFJlbmRlcnMgZWFjaCBzdWdnZXN0aW9uIGl0ZW0uXG4gIHJlbmRlclN1Z2dlc3Rpb24oaTogRnV6enlNYXRjaDxzdHJpbmc+LCBlbDogSFRNTEVsZW1lbnQpIHtcbiAgICBjb25zdCBpdGVtID0gaS5pdGVtXG4gICAgLy9lbC5jcmVhdGVFbChcImRpdlwiLCB7IHRleHQ6IGl0ZW0gfSk7XG4gICAgZWwuY3JlYXRlRWwoXCJkaXZcIiwgeyB0ZXh0OiBcIlx1MjAyMiBcIiArIGl0ZW0ucmVwbGFjZSgvXFxuL2dtLCBcIlwiKS5zdWJzdHJpbmcoMCwgMTAwKSB9KTtcbiAgfVxuXG4gIC8vIFBlcmZvcm0gYWN0aW9uIG9uIHRoZSBzZWxlY3RlZCBzdWdnZXN0aW9uLlxuICBvbkNob29zZUl0ZW0oc2VsZWN0ZWRDb250ZW50OiBzdHJpbmcsIGV2dDogTW91c2VFdmVudCB8IEtleWJvYXJkRXZlbnQpIHtcbiAgICBpZiAoc2VsZWN0ZWRDb250ZW50ID09PSB0aGlzLlJFTU9WRV9BTEwpIHtcbiAgICAgIG5ldyBOb3RpY2UoXCJoYWhhXCIpXG4gICAgICB3aGlsZSh0aGlzLmNsaXBib2FyZENvbnRlbnQubGVuZ3RoID4gMCkge1xuICAgICAgICB0aGlzLmNsaXBib2FyZENvbnRlbnQucG9wKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5jbGlwYm9hcmRDb250ZW50LmluZGV4T2Yoc2VsZWN0ZWRDb250ZW50LCAwKTtcbiAgICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICAgIHRoaXMuY2xpcGJvYXJkQ29udGVudC5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgfSAgXG4gICAgfVxuICB9XG59IiwgImltcG9ydCB7IEFwcCwgRnV6enlTdWdnZXN0TW9kYWwgfSBmcm9tIFwib2JzaWRpYW5cIjtcbmltcG9ydCB7IGdldEFsbFRhZ3NXaXRoRmlsdGVyIH0gZnJvbSBcInNlbGZ1dGlsL2dldEFsbE5vdGVUYWdzXCI7XG5cbmludGVyZmFjZSBTZWFyY2gge1xuXHRvcGVuR2xvYmFsU2VhcmNoKF86IHN0cmluZyk6IHZvaWQ7XG5cdGdldEdsb2JhbFNlYXJjaFF1ZXJ5KCk6IHN0cmluZztcbn1cblxuZXhwb3J0IGNsYXNzIFRhZ1NlYXJjaE1vZGFsIGV4dGVuZHMgRnV6enlTdWdnZXN0TW9kYWw8c3RyaW5nPiB7XG5cdGNvbnN0cnVjdG9yKHB1YmxpYyBhcHA6IEFwcCwgcHJpdmF0ZSBzZWFyY2g6IFNlYXJjaCkge1xuXHRcdHN1cGVyKGFwcCk7XG5cdFx0dGhpcy5zZWFyY2ggPSBzZWFyY2g7XG5cdH1cblxuXHRnZXRJdGVtcygpOiBzdHJpbmdbXSB7XG5cdFx0cmV0dXJuIGdldEFsbFRhZ3NXaXRoRmlsdGVyKHRoaXMuYXBwKTtcblx0fVxuXG5cdGdldEl0ZW1UZXh0KGl0ZW06IHN0cmluZyk6IHN0cmluZyB7XG5cdFx0cmV0dXJuIGl0ZW07XG5cdH1cblxuXHRvbkNob29zZUl0ZW0oaXRlbTogc3RyaW5nLCBldnQ6IE1vdXNlRXZlbnQgfCBLZXlib2FyZEV2ZW50KTogdm9pZCB7XG5cdFx0Y29uc3QgZGVmYXVsdFRhZ1NlYXJjaFN0cmluZyA9IGB0YWc6JHtpdGVtfWA7XG4gICAgICAgIHRoaXMuc2VhcmNoLm9wZW5HbG9iYWxTZWFyY2goZGVmYXVsdFRhZ1NlYXJjaFN0cmluZyk7XG5cdH1cblxufSIsICJpbXBvcnQgeyBBcHAsIGdldEFsbFRhZ3MgfSBmcm9tIFwib2JzaWRpYW5cIjtcblxuZXhwb3J0IGZ1bmN0aW9uIGdldEFsbE5vdGVUYWdzKGFwcDogQXBwKSB7XG4gICAgcmV0dXJuIGdldEFsbFRhZ3NXaXRoRmlsdGVyKGFwcCwgKHRhZykgPT4gL14jW2Etel1cXC9bYS16XVxcL1thLXpdJC8udGVzdCh0YWcpKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0QWxsVGFnc1dpdGhGaWx0ZXIoYXBwOiBBcHAsIGZpbHRlcj86ICh0YWc6IHN0cmluZykgPT4gYm9vbGVhbiB8IG51bGwpIHtcbiAgICBjb25zdCBmaWxlcyA9IGFwcC52YXVsdC5nZXRNYXJrZG93bkZpbGVzKCk7XG4gICAgY29uc3QgaXRlbXM6IHN0cmluZ1tdID0gW107XG4gICAgZm9yIChjb25zdCBmaWxlIG9mIGZpbGVzKSB7XG4gICAgICAgIGNvbnN0IGNhY2hlID0gYXBwLm1ldGFkYXRhQ2FjaGUuZ2V0Q2FjaGUoZmlsZS5wYXRoKTtcbiAgICAgICAgaWYgKGNhY2hlID09PSBudWxsKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBnZXRBbGxUYWdzKGNhY2hlKT8uZm9yRWFjaCgodGFnKSA9PiB7XG4gICAgICAgICAgICBpZiAoZmlsdGVyID09IG51bGwgfHwgZmlsdGVyKHRhZykpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsYXllck9mVGFnOiBzdHJpbmdbXSA9IGdldExheWVyc09mVGFnKHRhZylcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGxheWVyIG9mIGxheWVyT2ZUYWcpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpdGVtcy5pbmNsdWRlcyhsYXllcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1zLnB1c2gobGF5ZXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGl0ZW1zLnNvcnQoKGE6IHN0cmluZywgYjogc3RyaW5nKSA9PiBhLmxvY2FsZUNvbXBhcmUoYikpO1xufVxuXG5mdW5jdGlvbiBnZXRMYXllcnNPZlRhZyh0YWc6IHN0cmluZyk6IHN0cmluZ1tdIHtcbiAgICAvLyBwcm92aWRlIGEgdGFnIHdpdGggI3p6ei9iYmIvY2NjLCByZXR1cm4gWyN6enosICN6enovYmJiLCAjenp6L2JiYi9jY2NdXG4gICAgLy8gaWYgdGFnIHdpdGhvdXQgLyAoZS5nLiAjenp6KSwgcmV0dXJuIFsjenp6XVxuICAgIGNvbnN0IGxheWVyczogc3RyaW5nW10gPSBbXVxuICAgIGNvbnN0IHRhZ1NwbGl0ID0gdGFnLnNwbGl0KFwiL1wiKVxuICAgIGxldCB0YWdMYXllciA9IHRhZ1NwbGl0WzBdXG4gICAgbGF5ZXJzLnB1c2godGFnTGF5ZXIpXG4gICAgZm9yIChjb25zdCB0YWdQYXJ0IG9mIHRhZ1NwbGl0LnNsaWNlKDEsIHRhZ1NwbGl0Lmxlbmd0aCkpIHtcbiAgICAgICAgdGFnTGF5ZXIgKz0gXCIvXCIgKyB0YWdQYXJ0XG4gICAgICAgIGxheWVycy5wdXNoKHRhZ0xheWVyKVxuICAgIH1cbiAgICByZXR1cm4gbGF5ZXJzXG59IiwgImltcG9ydCB7IEFkZFRleHRUb05vdGVzTW9kYWwgfSBmcm9tIFwiYWRkVGV4dFRvTm90ZXNNb2RhbFwiXG5pbXBvcnQgeyBBcHAsIEZ1enp5U3VnZ2VzdE1vZGFsLCBGdXp6eU1hdGNoIH0gZnJvbSBcIm9ic2lkaWFuXCJcbmltcG9ydCB7IGFkZFRleHRUb05vdGVzIH0gZnJvbSBcInNlbGZ1dGlsL2FkZGxpbmt0b25vdGVzXCJcbmltcG9ydCB7IGZpbGVzV2hlcmVUYWdJc1VzZWQgfSBmcm9tIFwic2VsZnV0aWwvZmluZE5vdGVzRnJvbVRhZ1wiXG5cbmNvbnN0IEJBQ0tfVE9fU0VMRUNUX1RBRyA9IFwiQmFjayB0byBzZWxlY3QgdGFnXCJcblxuZXhwb3J0IGNsYXNzIEFkZFRleHRUb05vdGVzRnJvbVNwZWNpZmljVGFnTW9kYWwgZXh0ZW5kcyBGdXp6eVN1Z2dlc3RNb2RhbDxzdHJpbmc+IHtcblxuICBsaW5rVG9BZGQ6IHN0cmluZ1xuXG4gIHRhZ1RvRmluZDogc3RyaW5nXG5cbiAgZGVzY3JpcHRpb246IHN0cmluZ1xuXG4gIGluc2VydEZyb21CZWdpbm5pbmc6IGJvb2xlYW5cblxuICBwb3N0QWN0aW9uOiAoKSA9PiB2b2lkXG5cbiAgY29uc3RydWN0b3IoYXBwOiBBcHAsIGxpbmtUb0FkZDogc3RyaW5nLCB0YWdUb0ZpbmQ6IHN0cmluZywgZGVzY3JpcHRpb246IHN0cmluZywgaW5zZXJ0RnJvbUJlZ2lubmluZzogYm9vbGVhbiwgcG9zdEFjdGlvbjogKCkgPT4gdm9pZClcbiAge1xuICAgIHN1cGVyKGFwcClcbiAgICB0aGlzLmxpbmtUb0FkZCA9IGxpbmtUb0FkZFxuICAgIHRoaXMudGFnVG9GaW5kID0gdGFnVG9GaW5kXG4gICAgdGhpcy5pbnNlcnRGcm9tQmVnaW5uaW5nID0gaW5zZXJ0RnJvbUJlZ2lubmluZ1xuICAgIHRoaXMuZGVzY3JpcHRpb24gPSBkZXNjcmlwdGlvblxuICAgIHRoaXMucG9zdEFjdGlvbiA9IHBvc3RBY3Rpb25cbiAgICB0aGlzLnNldEluc3RydWN0aW9ucyhbXG4gICAgICB7XG4gICAgICAgIGNvbW1hbmQ6IFwiXCIsXG4gICAgICAgIHB1cnBvc2U6IGBXaGljaCBub3RlcyB3aXRoIHRhZyAke3RhZ1RvRmluZH0gZG8geW91IHdhbnQgdG8gJHtkZXNjcmlwdGlvbn0gdG8/YFxuICAgICAgfVxuICAgIF0pO1xuICB9XG5cbiAgZ2V0SXRlbXMoKTogc3RyaW5nW10ge1xuICAgIHJldHVybiBbLi4uW0JBQ0tfVE9fU0VMRUNUX1RBR10sIC4uLmZpbGVzV2hlcmVUYWdJc1VzZWQodGhpcy50YWdUb0ZpbmQpXTtcbiAgfVxuXG4gIGdldEl0ZW1UZXh0KHBhdGg6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHBhdGg7XG4gIH1cblxuICAvLyBSZW5kZXJzIGVhY2ggc3VnZ2VzdGlvbiBpdGVtLlxuICByZW5kZXJTdWdnZXN0aW9uKHBhdGg6IEZ1enp5TWF0Y2g8c3RyaW5nPiwgZWw6IEhUTUxFbGVtZW50KSB7XG4gICAgY29uc3QgcGF0aEl0ZW06IHN0cmluZyA9IHBhdGguaXRlbVxuICAgIGVsLmNyZWF0ZUVsKFwiZGl2XCIsIHsgdGV4dDogcGF0aEl0ZW0gfSk7XG4gIH1cblxuICAvLyBQZXJmb3JtIGFjdGlvbiBvbiB0aGUgc2VsZWN0ZWQgc3VnZ2VzdGlvbi5cbiAgb25DaG9vc2VJdGVtKHBhdGg6IHN0cmluZywgZXZ0OiBNb3VzZUV2ZW50IHwgS2V5Ym9hcmRFdmVudCkge1xuICAgIGlmIChCQUNLX1RPX1NFTEVDVF9UQUcgPT0gcGF0aCkge1xuICAgICAgbmV3IEFkZFRleHRUb05vdGVzTW9kYWwodGhpcy5hcHAsIHRoaXMubGlua1RvQWRkLCB0aGlzLmRlc2NyaXB0aW9uLCB0aGlzLmluc2VydEZyb21CZWdpbm5pbmcsIHRoaXMucG9zdEFjdGlvbikub3BlbigpXG4gICAgfSBlbHNlIHtcbiAgICAgIGFkZFRleHRUb05vdGVzKHRoaXMubGlua1RvQWRkLCBwYXRoLCB0aGlzLmFwcCwgdGhpcy5pbnNlcnRGcm9tQmVnaW5uaW5nKVxuICAgICAgdGhpcy5wb3N0QWN0aW9uKClcbiAgICB9XG4gIH1cbn0iLCAiaW1wb3J0IHsgQXBwLCBOb3RpY2UsIFRGaWxlLCBUZXh0RmlsZVZpZXcsIFZhdWx0LCBXb3Jrc3BhY2UgfSBmcm9tIFwib2JzaWRpYW5cIlxuXG5leHBvcnQgZnVuY3Rpb24gYWRkVGV4dFRvTm90ZXModGV4dFRvQWRkOiBzdHJpbmcsIHRvUGF0aDogc3RyaW5nLCBhcHA6IEFwcCwgaW5zZXJ0RnJvbUJlZ2lubmluZzogYm9vbGVhbikge1xuICAgIGNvbnN0IHZhdWx0OiBWYXVsdCA9IHRoaXMuYXBwLnZhdWx0O1xuICAgIGNvbnN0IHdvcmtzcGFjZTogV29ya3NwYWNlID0gdGhpcy5hcHAud29ya3NwYWNlXG4gICAgY29uc3QgbGVhZiA9IHdvcmtzcGFjZS5nZXRMZWFmKGZhbHNlKTtcbiAgICBjb25zdCB0RmlsZTogVEZpbGUgPSB2YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgodG9QYXRoKSBhcyBURmlsZVxuICAgIGNvbnN0IGxpbmsgPSB0ZXh0VG9BZGRcbiAgICBQcm9taXNlLnJlc29sdmUoKVxuICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgcmV0dXJuIGxlYWYub3BlbkZpbGUodEZpbGUsIHsgYWN0aXZlOiB0cnVlIH0pO1xuICAgIH0pXG4gICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICBjb25zdCBlZGl0b3IgPSBhcHAud29ya3NwYWNlLmdldEFjdGl2ZVZpZXdPZlR5cGUoVGV4dEZpbGVWaWV3KTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBlZGl0b3I/LmdldFZpZXdEYXRhKClcbiAgICAgICAgaWYgKGVkaXRvciA9PSBudWxsIHx8IHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yUmVhc29uID0gYGVkaXRvciBvciB2YWx1ZSAke3RvUGF0aH0gbm90IGV4aXN0LiBBYm9ydGluZy4uLmBcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvclJlYXNvbilcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYgKHZhbHVlLmluY2x1ZGVzKGxpbmspKSB7XG4gICAgICAgICAgICBjb25zdCBlcnJvclJlYXNvbiA9IGBMaW5rICR7bGlua30gYWxyZWFkeSBleGlzdHMgaW4gJHt0b1BhdGh9IWBcbiAgICAgICAgICAgIG5ldyBOb3RpY2UoZXJyb3JSZWFzb24pXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBuZXdWYWx1ZSA9IGluc2VydEZyb21CZWdpbm5pbmcgPyBcbiAgICAgICAgICAgIGdldE5vdGVWYWx1ZUluc2VydGluZ1RleHRGcm9tU3RhcnRPZk5vdGVzKHZhbHVlLCBsaW5rKSA6IFxuICAgICAgICAgICAgZ2V0Tm90ZVZhbHVlSW5zZXJ0aW5nVGV4dEZyb21FbmRPZk5vdGVzKHZhbHVlLCBsaW5rKVxuICAgICAgICAgICAgZWRpdG9yLnNldFZpZXdEYXRhKG5ld1ZhbHVlLCBmYWxzZSlcbiAgICAgICAgICAgIG5ldyBOb3RpY2UoYEFkZGVkIGxpbmsgdG8gJHtpbnNlcnRGcm9tQmVnaW5uaW5nID8gXCJiZWdpbm5pbmdcIiA6IFwiZW5kXCJ9IG9mICR7dG9QYXRofSFgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKClcbiAgICB9KVxuICAgIC5jYXRjaCgocmVhc29uKSA9PiB7IFxuICAgICAgICBuZXcgTm90aWNlKHJlYXNvbilcbiAgICB9KVxuICAgIC8qIHRoaXMgdmVyc2lvbiBjYW5ub3QgcmVkbywgY2FuIHJlbW92ZSBpZiBhYm92ZVxuICAgIFByb21pc2UucmVzb2x2ZSgpXG4gICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB2YXVsdC5yZWFkKHRGaWxlKVxuICAgICAgICB9LCByZWFzb24gPT4geyBuZXcgTm90aWNlKFwiRXJyb3Igb2NjdXJyZWQgd2hlbiByZWFkaW5nIFwiICsgdG9QYXRoKSB9KVxuICAgICAgICAudGhlbigodmFsdWUpID0+IHtcbiAgICAgICAgICAgIGlmICh2YWx1ZS5pbmNsdWRlcyhsaW5rKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yUmVhc29uID0gYExpbmsgJHtsaW5rVG9BZGR9IGFscmVhZHkgZXhpc3RzIGluICR7dG9QYXRofSFgXG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yUmVhc29uKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbmV3VmFsdWUgPSBpbnNlcnRGcm9tQmVnaW5uaW5nID8gXG4gICAgICAgICAgICAgICAgZ2V0Tm90ZVZhbHVlSW5zZXJ0aW5nTm90ZUxpbmtGcm9tU3RhcnRPZk5vdGVzKHZhbHVlLCBsaW5rKSA6IFxuICAgICAgICAgICAgICAgIGdldE5vdGVWYWx1ZUluc2VydGluZ05vdGVMaW5rRnJvbUVuZE9mTm90ZXModmFsdWUsIGxpbmspXG4gICAgICAgICAgICByZXR1cm4gdmF1bHQubW9kaWZ5KHRGaWxlLCBuZXdWYWx1ZSlcbiAgICAgICAgfSlcbiAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgbmV3IE5vdGljZShgQWRkZWQgbGluayB0byAke2luc2VydEZyb21CZWdpbm5pbmcgPyBcImJlZ2lubmluZ1wiIDogXCJlbmRcIn0gb2YgJHt0b1BhdGh9IWApO1xuICAgICAgICAgICAgY29uc3QgbGVhZiA9IHdvcmtzcGFjZS5nZXRMZWFmKGZhbHNlKTtcbiAgICAgICAgICAgIHJldHVybiBsZWFmLm9wZW5GaWxlKHRGaWxlLCB7IGFjdGl2ZTogdHJ1ZSB9KTtcbiAgICAgICAgfSwgKHJlYXNvbikgPT4geyBcbiAgICAgICAgICAgIG5ldyBOb3RpY2UocmVhc29uKSBcbiAgICAgICAgICAgIGNvbnN0IGxlYWYgPSB3b3Jrc3BhY2UuZ2V0TGVhZihmYWxzZSk7XG4gICAgICAgICAgICByZXR1cm4gbGVhZi5vcGVuRmlsZSh0RmlsZSwgeyBhY3RpdmU6IHRydWUgfSk7XG4gICAgICAgIH0pXG4gICAgICAgICovXG59XG5cbmZ1bmN0aW9uIGdldE5vdGVWYWx1ZUluc2VydGluZ1RleHRGcm9tU3RhcnRPZk5vdGVzKHZhbHVlOiBzdHJpbmcsIHRleHQ6IHN0cmluZykge1xuICAgIGNvbnN0IGZyb250TWF0dGVyUmVnZXggPSAvXigtLS1cXG5bXFxzXFxTXSo/XFxuLS0tXFxuKS9nbVxuICAgIC8vIC9eLS0tXFxuKC4qKSpcXG4tLS1cXG4vXG4gICAgaWYgKGZyb250TWF0dGVyUmVnZXgudGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLnJlcGxhY2UoZnJvbnRNYXR0ZXJSZWdleCwgXCIkMVwiICsgdGV4dCArIFwiXFxuXCIpXG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRleHQgKyBcIlxcblwiICsgdmFsdWVcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGdldE5vdGVWYWx1ZUluc2VydGluZ1RleHRGcm9tRW5kT2ZOb3Rlcyh2YWx1ZTogc3RyaW5nLCB0ZXh0OiBzdHJpbmcpIHtcbiAgICByZXR1cm4gdmFsdWUgKyBcIlxcblwiICsgdGV4dFxufSIsICJpbXBvcnQgeyBBcHAsIENhY2hlZE1ldGFkYXRhLCBwYXJzZUZyb250TWF0dGVyQWxpYXNlcywgcGFyc2VGcm9udE1hdHRlclRhZ3MgfSBmcm9tIFwib2JzaWRpYW5cIjtcblxuZXhwb3J0IGZ1bmN0aW9uIGZpbGVzV2hlcmVUYWdJc1VzZWQoZmluZFRhZzogc3RyaW5nKTogc3RyaW5nW10ge1xuICAgIGNvbnN0IGZpbGVzTGlzdDogc3RyaW5nW10gPSBbXTtcbiAgICBmb3IgKGNvbnN0IGZpbGVQYXRoIG9mIGxvY2F0aW9uc1doZXJlVGFnSXNVc2VkKGZpbmRUYWcpKSB7XG4gICAgICAgIGlmICghZmlsZXNMaXN0LmluY2x1ZGVzKGZpbGVQYXRoKSkge1xuICAgICAgICAgICAgZmlsZXNMaXN0LnB1c2goZmlsZVBhdGgpXG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZpbGVzTGlzdC5zb3J0KChhOiBzdHJpbmcsIGI6IHN0cmluZykgPT4gYS5sb2NhbGVDb21wYXJlKGIpKTtcbn1cblxuLy8gcmV0dXJuIGFycmF5IG9mIGZpbGUgcGF0aFxuZnVuY3Rpb24gbG9jYXRpb25zV2hlcmVUYWdJc1VzZWQoZmluZFRhZzogc3RyaW5nKTogQXJyYXk8c3RyaW5nPiB7XG4gICAgY29uc3Qgb0FwcDogQXBwID0gYXBwO1xuICAgIGNvbnN0IHJlc3VsdHM6IHN0cmluZ1tdID0gW107XG5cbiAgICBmb3IgKGNvbnN0IGZpbGUgb2Ygb0FwcC52YXVsdC5nZXRNYXJrZG93bkZpbGVzKCkpIHtcbiAgICAgICAgY29uc3QgY2FjaGU6IENhY2hlZE1ldGFkYXRhIHwgbnVsbCA9IG9BcHAubWV0YWRhdGFDYWNoZS5nZXRGaWxlQ2FjaGUoZmlsZSk7XG4gICAgICAgIGlmIChjYWNoZSAhPSBudWxsICYmIGNhY2hlLnRhZ3MpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgdGFnIG9mIGNhY2hlLnRhZ3MpIHtcbiAgICAgICAgICAgICAgICBpZiAoZmluZFRhZyA9PT0gdGFnLnRhZykge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goZmlsZS5wYXRoKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY2FjaGUgIT0gbnVsbCAmJiBjYWNoZS5mcm9udG1hdHRlcikge1xuICAgICAgICAgICAgY29uc3QgZm10YWdzID0gKHBhcnNlRnJvbnRNYXR0ZXJUYWdzKGNhY2hlLmZyb250bWF0dGVyKSB8fCBbXSkuZmlsdGVyKHRhZyA9PiBmaW5kVGFnID09IHRhZyB8fCB0YWcuc3RhcnRzV2l0aChmaW5kVGFnICsgXCIvXCIpKTtcbiAgICAgICAgICAgIGlmIChmbXRhZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGZpbGUucGF0aClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGZtdGFnczIgPSAocGFyc2VGcm9udE1hdHRlckFsaWFzZXMoY2FjaGUuZnJvbnRtYXR0ZXIpIHx8IFtdKS5maWx0ZXIodGFnID0+IGZpbmRUYWcgPT0gdGFnIHx8IHRhZy5zdGFydHNXaXRoKGZpbmRUYWcgKyBcIi9cIikpO1xuICAgICAgICAgICAgaWYgKGZtdGFnczIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGZpbGUucGF0aClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0c1xufSIsICJpbXBvcnQgeyBBZGRUZXh0VG9Ob3Rlc0Zyb21TcGVjaWZpY1RhZ01vZGFsIH0gZnJvbSBcImFkZFRleHRUb05vdGVzRnJvbVNwZWNpZmljVGFnTW9kYWxcIjtcbmltcG9ydCB7IEFwcCwgRnV6enlTdWdnZXN0TW9kYWwsIEZ1enp5TWF0Y2gsIGdldEFsbFRhZ3MgfSBmcm9tIFwib2JzaWRpYW5cIjtcbmltcG9ydCB7IGFkZFRleHRUb05vdGVzIH0gZnJvbSBcInNlbGZ1dGlsL2FkZGxpbmt0b25vdGVzXCI7XG5pbXBvcnQgeyBnZXRBbGxOb3RlVGFncyB9IGZyb20gXCJzZWxmdXRpbC9nZXRBbGxOb3RlVGFnc1wiO1xuaW1wb3J0IHsgZ2V0QWxsTm90ZXMsIGdldFJlY2VudE5vdGVzIH0gZnJvbSBcInNlbGZ1dGlsL2dldFJlY2VudE5vdGVzXCI7XG5cbmV4cG9ydCBjbGFzcyBBZGRUZXh0VG9Ob3Rlc01vZGFsIGV4dGVuZHMgRnV6enlTdWdnZXN0TW9kYWw8c3RyaW5nPiB7XG5cbiAgbGlua1RvQWRkOiBzdHJpbmdcbiAgdGFza1R5cGU6IFN0cmluZ1xuICBkZXNjcmlwdGlvbjogc3RyaW5nXG4gIGluc2VydEZyb21CZWdpbm5pbmc6IGJvb2xlYW5cbiAgcG9zdEFjdGlvbjogKCkgPT4gdm9pZFxuXG4gIGNvbnN0cnVjdG9yKGFwcDogQXBwLCBsaW5rVG9BZGQ6IHN0cmluZywgZGVzY3JpcHRpb246IHN0cmluZywgaW5zZXJ0RnJvbUJlZ2lubmluZzogYm9vbGVhbiwgcG9zdEFjdGlvbjogKCkgPT4gdm9pZClcbiAge1xuICAgIHN1cGVyKGFwcClcbiAgICB0aGlzLmxpbmtUb0FkZCA9IGxpbmtUb0FkZFxuICAgIHRoaXMuZGVzY3JpcHRpb24gPSBkZXNjcmlwdGlvblxuICAgIHRoaXMuaW5zZXJ0RnJvbUJlZ2lubmluZyA9IGluc2VydEZyb21CZWdpbm5pbmdcbiAgICB0aGlzLnBvc3RBY3Rpb24gPSBwb3N0QWN0aW9uXG4gICAgdGhpcy5zZXRJbnN0cnVjdGlvbnMoW1xuICAgICAge1xuICAgICAgICBjb21tYW5kOiBcIlwiLFxuICAgICAgICBwdXJwb3NlOiBgV2hpY2ggbm90ZXMgd2l0aCB0YWdzIGRvIHlvdSB3YW50IHRvICR7ZGVzY3JpcHRpb259IHRvP2BcbiAgICAgIH1cbiAgICBdKTtcbiAgfVxuXG4gIGdldEl0ZW1zKCkgOiBzdHJpbmdbXSB7XG5cdFx0cmV0dXJuIFsuLi5bJ0kvSW5ib3gubWQnXSwgLi4uZ2V0UmVjZW50Tm90ZXModGhpcy5hcHAsIDcpLCAuLi5nZXRBbGxOb3RlVGFncyh0aGlzLmFwcCksIC4uLmdldEFsbE5vdGVzKHRoaXMuYXBwKV07XG4gIH1cblxuICBnZXRJdGVtVGV4dCh2YWx1ZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICAvLyBSZW5kZXJzIGVhY2ggc3VnZ2VzdGlvbiBpdGVtLlxuICByZW5kZXJTdWdnZXN0aW9uKHZhbHVlOiBGdXp6eU1hdGNoPHN0cmluZz4sIGVsOiBIVE1MRWxlbWVudCkge1xuICAgIGNvbnN0IGl0ZW0gPSB2YWx1ZS5pdGVtXG4gICAgZWwuY3JlYXRlRWwoXCJkaXZcIiwgeyB0ZXh0OiBpdGVtIH0pO1xuICB9XG5cbiAgLy8gUGVyZm9ybSBhY3Rpb24gb24gdGhlIHNlbGVjdGVkIHN1Z2dlc3Rpb24uXG4gIGFzeW5jIG9uQ2hvb3NlSXRlbShjaG9vc2VuVmFsdWU6IHN0cmluZywgZXZ0OiBNb3VzZUV2ZW50IHwgS2V5Ym9hcmRFdmVudCkge1xuICAgIGlmIChjaG9vc2VuVmFsdWUuc3RhcnRzV2l0aChcIiNcIikpIHtcbiAgICAgIG5ldyBBZGRUZXh0VG9Ob3Rlc0Zyb21TcGVjaWZpY1RhZ01vZGFsKHRoaXMuYXBwLCB0aGlzLmxpbmtUb0FkZCwgY2hvb3NlblZhbHVlLCB0aGlzLmRlc2NyaXB0aW9uLCB0aGlzLmluc2VydEZyb21CZWdpbm5pbmcsIHRoaXMucG9zdEFjdGlvbikub3BlbigpXG4gICAgfSBlbHNlIHtcbiAgICAgIGFkZFRleHRUb05vdGVzKHRoaXMubGlua1RvQWRkLCBjaG9vc2VuVmFsdWUsIHRoaXMuYXBwLCB0aGlzLmluc2VydEZyb21CZWdpbm5pbmcpXG4gICAgICB0aGlzLnBvc3RBY3Rpb24oKVxuICAgIH1cbiAgfVxufSIsICJpbXBvcnQgeyBBcHAgfSBmcm9tIFwib2JzaWRpYW5cIjtcblxuZXhwb3J0IGZ1bmN0aW9uIGdldFJlY2VudE5vdGVzKGFwcDogQXBwLCBsaW1pdDogbnVtYmVyKTogc3RyaW5nW10ge1xuICBjb25zdCByZWNlbnRWaWV3ZWROb3RlcyA9IGFwcC53b3Jrc3BhY2UuZ2V0TGFzdE9wZW5GaWxlcygpO1xuICByZXR1cm4gcmVjZW50Vmlld2VkTm90ZXMuc2xpY2UoMCwgTWF0aC5taW4obGltaXQsIHJlY2VudFZpZXdlZE5vdGVzLmxlbmd0aCkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0QWxsTm90ZXMoYXBwOiBBcHApOiBzdHJpbmdbXSB7XG4gIGNvbnN0IGZpbGVzID0gYXBwLnZhdWx0LmdldE1hcmtkb3duRmlsZXMoKTtcbiAgY29uc3QgYWxsTm90ZXMgPSBmaWxlcy5tYXAoKGZpbGUpID0+IGZpbGUucGF0aCk7XG4gIHJldHVybiBhbGxOb3Rlcztcbn0iLCAiaW1wb3J0IHsgTmF2aWdhdGVUb05vdGVGcm9tVGFnTW9kYWwgfSBmcm9tIFwibmF2aWdhdGVUb05vdGVGcm9tVGFnTW9kYWxcIlxuaW1wb3J0IHsgQXBwLCBGdXp6eVN1Z2dlc3RNb2RhbCwgRnV6enlNYXRjaCwgTm90aWNlLCBDYWNoZWRNZXRhZGF0YSwgcGFyc2VGcm9udE1hdHRlclRhZ3MsIHBhcnNlRnJvbnRNYXR0ZXJBbGlhc2VzLCBURmlsZSB9IGZyb20gXCJvYnNpZGlhblwiXG5pbXBvcnQgeyBmaWxlc1doZXJlVGFnSXNVc2VkIH0gZnJvbSBcInNlbGZ1dGlsL2ZpbmROb3Rlc0Zyb21UYWdcIlxuXG5jb25zdCBCQUNLX1RPX1NFTEVDVF9UQUcgPSBcIkJhY2sgdG8gc2VsZWN0IHRhZ1wiXG5cbmV4cG9ydCBjbGFzcyBOYXZpZ2F0ZVRvTm90ZUZyb21TcGVjaWZpY1RhZ01vZGFsIGV4dGVuZHMgRnV6enlTdWdnZXN0TW9kYWw8c3RyaW5nPiB7XG5cbiAgdGFnVG9GaW5kOiBzdHJpbmdcblxuICBjb25zdHJ1Y3RvcihhcHA6IEFwcCwgdGFnVG9GaW5kOiBzdHJpbmcpXG4gIHtcbiAgICBzdXBlcihhcHApXG4gICAgdGhpcy50YWdUb0ZpbmQgPSB0YWdUb0ZpbmRcbiAgICB0aGlzLnNldEluc3RydWN0aW9ucyhbXG4gICAgICB7XG4gICAgICAgIGNvbW1hbmQ6IFwiXCIsXG4gICAgICAgIHB1cnBvc2U6IGBXaGljaCBub3RlcyB3aXRoIHRhZyAke3RhZ1RvRmluZH0gZG8geW91IHdhbnQgdG8gbmF2aWdhdGUgdG8/YFxuICAgICAgfVxuICAgIF0pO1xuICB9XG5cblxuICBnZXRJdGVtcygpOiBzdHJpbmdbXSB7XG4gICAgcmV0dXJuIFsuLi5bQkFDS19UT19TRUxFQ1RfVEFHXSwgLi4uZmlsZXNXaGVyZVRhZ0lzVXNlZCh0aGlzLnRhZ1RvRmluZCldO1xuICB9XG5cbiAgZ2V0SXRlbVRleHQocGF0aDogc3RyaW5nKTogc3RyaW5nIHtcbiAgICByZXR1cm4gcGF0aDtcbiAgfVxuXG4gIC8vIFJlbmRlcnMgZWFjaCBzdWdnZXN0aW9uIGl0ZW0uXG4gIHJlbmRlclN1Z2dlc3Rpb24ocGF0aDogRnV6enlNYXRjaDxzdHJpbmc+LCBlbDogSFRNTEVsZW1lbnQpIHtcbiAgICBjb25zdCBwYXRoSXRlbTogc3RyaW5nID0gcGF0aC5pdGVtXG4gICAgZWwuY3JlYXRlRWwoXCJkaXZcIiwgeyB0ZXh0OiBwYXRoSXRlbSB9KTtcbiAgfVxuXG4gIC8vIFBlcmZvcm0gYWN0aW9uIG9uIHRoZSBzZWxlY3RlZCBzdWdnZXN0aW9uLlxuICBvbkNob29zZUl0ZW0ocGF0aDogc3RyaW5nLCBldnQ6IE1vdXNlRXZlbnQgfCBLZXlib2FyZEV2ZW50KSB7XG4gICAgaWYgKEJBQ0tfVE9fU0VMRUNUX1RBRyA9PSBwYXRoKSB7XG4gICAgICBuZXcgTmF2aWdhdGVUb05vdGVGcm9tVGFnTW9kYWwodGhpcy5hcHApLm9wZW4oKVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB7IHZhdWx0LCB3b3Jrc3BhY2UgfSA9IHRoaXMuYXBwO1xuICAgICAgY29uc3QgbGVhZiA9IHdvcmtzcGFjZS5nZXRMZWFmKGZhbHNlKTtcbiAgICAgIFByb21pc2UucmVzb2x2ZSgpXG4gICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIGxlYWYub3BlbkZpbGUodmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKHBhdGgpIGFzIFRGaWxlLCB7IGFjdGl2ZSA6IHRydWUgfSk7XG4gICAgICB9KVxuICB9XG4gIH1cbn0iLCAiaW1wb3J0IHsgTmF2aWdhdGVUb05vdGVGcm9tU3BlY2lmaWNUYWdNb2RhbCB9IGZyb20gXCJuYXZpZ2F0ZVRvTm90ZUZyb21TcGVjaWZpY1RhZ01vZGFsXCI7XG5pbXBvcnQgeyBBcHAsIEZ1enp5U3VnZ2VzdE1vZGFsLCBGdXp6eU1hdGNoLCBnZXRBbGxUYWdzLCBURmlsZSwgTm90aWNlIH0gZnJvbSBcIm9ic2lkaWFuXCI7XG5pbXBvcnQgeyBnZXRBbGxUYWdzV2l0aEZpbHRlciB9IGZyb20gXCJzZWxmdXRpbC9nZXRBbGxOb3RlVGFnc1wiO1xuaW1wb3J0IHsgZ2V0QWxsTm90ZXMsIGdldFJlY2VudE5vdGVzIH0gZnJvbSBcInNlbGZ1dGlsL2dldFJlY2VudE5vdGVzXCI7XG5cbmV4cG9ydCBjbGFzcyBOYXZpZ2F0ZVRvTm90ZUZyb21UYWdNb2RhbCBleHRlbmRzIEZ1enp5U3VnZ2VzdE1vZGFsPHN0cmluZz4ge1xuXG4gIHRhc2tUeXBlOiBTdHJpbmdcblxuICBjb25zdHJ1Y3RvcihhcHA6IEFwcClcbiAge1xuICAgIHN1cGVyKGFwcClcbiAgICB0aGlzLnNldEluc3RydWN0aW9ucyhbXG4gICAgICB7XG4gICAgICAgIGNvbW1hbmQ6IFwiXCIsXG4gICAgICAgIHB1cnBvc2U6IFwiV2hpY2ggbm90ZXMgd2l0aCB0YWdzIGRvIHlvdSB3YW50IHRvIG5hdmlnYXRlIHRvP1wiXG4gICAgICB9XG4gICAgXSk7XG4gIH1cblxuICBnZXRJdGVtcygpIDogc3RyaW5nW10ge1xuXHRcdHJldHVybiBbLi4uZ2V0UmVjZW50Tm90ZXModGhpcy5hcHAsIDcpLCAuLi5nZXRBbGxUYWdzV2l0aEZpbHRlcih0aGlzLmFwcCksIC4uLmdldEFsbE5vdGVzKHRoaXMuYXBwKV07XG4gIH1cblxuICBnZXRJdGVtVGV4dCh2YWx1ZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICAvLyBSZW5kZXJzIGVhY2ggc3VnZ2VzdGlvbiBpdGVtLlxuICByZW5kZXJTdWdnZXN0aW9uKHZhbHVlOiBGdXp6eU1hdGNoPHN0cmluZz4sIGVsOiBIVE1MRWxlbWVudCkge1xuICAgIGNvbnN0IGl0ZW0gPSB2YWx1ZS5pdGVtXG4gICAgZWwuY3JlYXRlRWwoXCJkaXZcIiwgeyB0ZXh0OiBpdGVtIH0pO1xuICB9XG5cbiAgLy8gUGVyZm9ybSBhY3Rpb24gb24gdGhlIHNlbGVjdGVkIHN1Z2dlc3Rpb24uXG4gIGFzeW5jIG9uQ2hvb3NlSXRlbShjaG9vc2VuVmFsdWU6IHN0cmluZywgZXZ0OiBNb3VzZUV2ZW50IHwgS2V5Ym9hcmRFdmVudCkge1xuICAgIGlmIChjaG9vc2VuVmFsdWUuc3RhcnRzV2l0aChcIiNcIikpIHtcbiAgICAgIG5ldyBOYXZpZ2F0ZVRvTm90ZUZyb21TcGVjaWZpY1RhZ01vZGFsKHRoaXMuYXBwLCBjaG9vc2VuVmFsdWUpLm9wZW4oKVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB7IHZhdWx0LCB3b3Jrc3BhY2UgfSA9IHRoaXMuYXBwO1xuICAgICAgY29uc3QgbGVhZiA9IHdvcmtzcGFjZS5nZXRMZWFmKGZhbHNlKTtcbiAgICAgIFByb21pc2UucmVzb2x2ZSgpXG4gICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIGxlYWYub3BlbkZpbGUodmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKGNob29zZW5WYWx1ZSkgYXMgVEZpbGUsIHsgYWN0aXZlIDogdHJ1ZSB9KTtcbiAgICAgIH0pXG4gICAgfVxuICB9XG59IiwgImltcG9ydCB7IEVkaXRvciwgRWRpdG9yU2VsZWN0aW9uIH0gZnJvbSBcIm9ic2lkaWFuXCJcblxuZXhwb3J0IGZ1bmN0aW9uIGV4cG9ydEN1cnJlbnRTZWxlY3Rpb24oZWRpdG9yOiBFZGl0b3IpOiBzdHJpbmcge1xuICAgIGxldCB0ZXh0ID0gXCJcIlxuICAgIGNvbnN0IGxpc3RTZWxlY3Rpb25zOiBFZGl0b3JTZWxlY3Rpb25bXSA9IGVkaXRvci5saXN0U2VsZWN0aW9ucygpXG4gICAgbGlzdFNlbGVjdGlvbnMuZm9yRWFjaChsaXN0U2VsZWN0aW9uID0+IHtcbiAgICAgICAgY29uc3QgYSA9IGxpc3RTZWxlY3Rpb24uaGVhZC5saW5lXG4gICAgICAgIGNvbnN0IGIgPSBsaXN0U2VsZWN0aW9uLmFuY2hvci5saW5lXG4gICAgICAgIGNvbnN0IGZyb21MaW5lTnVtID0gYiA+IGEgPyBhIDogYlxuICAgICAgICBjb25zdCB0b0xpbmVOdW0gPSBiID4gYSA/IGIgOiBhXG4gICAgICAgIGZvciAobGV0IGkgPSBmcm9tTGluZU51bTsgaSA8PSB0b0xpbmVOdW07IGkrKykge1xuICAgICAgICAgICAgY29uc3QgbGluZSA9IGVkaXRvci5nZXRMaW5lKGkpXG4gICAgICAgICAgICB0ZXh0ICs9IGxpbmUgKyBcIlxcblwiXG4gICAgICAgIH1cbiAgICB9KVxuICAgIHJldHVybiB0ZXh0LnJlcGxhY2UoL1xcbiQvLCBcIlwiKVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFNlbGVjdGlvblJhbmdlIHtcbiAgICBmcm9tTGluZU51bTogbnVtYmVyXG4gICAgZnJvbUNoOiBudW1iZXJcbiAgICB0b0xpbmVOdW06IG51bWJlclxuICAgIHRvQ2g6IG51bWJlclxufVxuXG4vLyBhc3N1bWUgMSBzZWxlY3Rpb25cbmV4cG9ydCBmdW5jdGlvbiBnZXRDdXJyZW50U2VsZWN0aW9uTGluZU51bWJlcihlZGl0b3I6IEVkaXRvcik6IFNlbGVjdGlvblJhbmdlIHtcbiAgICBsZXQgdGV4dCA9IFwiXCJcbiAgICBsZXQgZnJvbUxpbmVOdW0gPSAwXG4gICAgbGV0IGZyb21DaCA9IDBcbiAgICBsZXQgdG9MaW5lTnVtID0gMFxuICAgIGxldCB0b0NoID0gMFxuICAgIGNvbnN0IGxpc3RTZWxlY3Rpb25zOiBFZGl0b3JTZWxlY3Rpb25bXSA9IGVkaXRvci5saXN0U2VsZWN0aW9ucygpXG4gICAgbGlzdFNlbGVjdGlvbnMuZm9yRWFjaChsaXN0U2VsZWN0aW9uID0+IHtcbiAgICAgICAgY29uc3QgYSA9IGxpc3RTZWxlY3Rpb24uaGVhZC5saW5lXG4gICAgICAgIGNvbnN0IGFjaCA9IGxpc3RTZWxlY3Rpb24uaGVhZC5jaFxuICAgICAgICBjb25zdCBiID0gbGlzdFNlbGVjdGlvbi5hbmNob3IubGluZVxuICAgICAgICBjb25zdCBiY2ggPSBsaXN0U2VsZWN0aW9uLmFuY2hvci5jaFxuICAgICAgICBmcm9tTGluZU51bSA9IGIgPiBhID8gYSA6IGJcbiAgICAgICAgZnJvbUNoID0gYiA+IGEgPyBhY2ggOiBiY2hcbiAgICAgICAgdG9MaW5lTnVtID0gYiA+IGEgPyBiIDogYVxuICAgICAgICB0b0NoID0gYiA+IGEgPyBiY2ggOiBhY2hcbiAgICB9KVxuICAgIHJldHVybiB7IGZyb21MaW5lTnVtLCBmcm9tQ2gsIHRvTGluZU51bSwgdG9DaCB9XG59Il0sCiAgIm1hcHBpbmdzIjogIjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQUEsMkNBQUFBLFNBQUE7QUFNQyxLQUFDLFNBQVUsUUFBUSxTQUFTO0FBQ3pCLGFBQU8sWUFBWSxZQUFZLE9BQU9BLFlBQVcsY0FBY0EsUUFBTyxVQUFVLFFBQVEsSUFDeEYsT0FBTyxXQUFXLGNBQWMsT0FBTyxNQUFNLE9BQU8sT0FBTyxJQUMzRCxPQUFPLFNBQVMsUUFBUTtBQUFBLElBQzVCLEdBQUUsU0FBTyxXQUFZO0FBQUU7QUFFbkIsVUFBSTtBQUVKLGVBQVMsUUFBUTtBQUNiLGVBQU8sYUFBYSxNQUFNLE1BQU0sU0FBUztBQUFBLE1BQzdDO0FBSUEsZUFBUyxnQkFBZ0IsVUFBVTtBQUMvQix1QkFBZTtBQUFBLE1BQ25CO0FBRUEsZUFBUyxRQUFRLE9BQU87QUFDcEIsZUFDSSxpQkFBaUIsU0FDakIsT0FBTyxVQUFVLFNBQVMsS0FBSyxLQUFLLE1BQU07QUFB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V0EsTUFBVyxNQUFzQixTQUFpQjtBQUN4RSxFQUFBQSxLQUFJLFlBQVksV0FBVyxNQUFNLE9BQU87QUFDNUM7OztBRDFEQSxJQUFNLFlBQVk7QUFBQSxFQUNoQjtBQUFBLElBQ0UsTUFBTTtBQUFBLElBQ04sYUFBYTtBQUFBLEVBQ2Y7QUFBQSxFQUNBO0FBQUEsSUFDRSxNQUFNO0FBQUEsSUFDTixhQUFhO0FBQUEsRUFDZjtBQUFBLEVBQ0E7QUFBQSxJQUNFLE1BQU07QUFBQSxJQUNOLGFBQWE7QUFBQSxFQUNmO0FBQUEsRUFDQTtBQUFBLElBQ0UsTUFBTTtBQUFBLElBQ04sYUFBYTtBQUFBLEVBQ2Y7QUFBQSxFQUNBO0FBQUEsSUFDRSxNQUFNO0FBQUEsSUFDTixhQUFhO0FBQUEsRUFDZjtBQUFBLEVBQ0E7QUFBQSxJQUNFLE1BQU07QUFBQSxJQUNOLGFBQWE7QUFBQSxFQUNmO0FBQUEsRUFDQTtBQUFBLElBQ0UsTUFBTTtBQUFBLElBQ04sYUFBYTtBQUFBLEVBQ2Y7QUFBQSxFQUNBO0FBQUEsSUFDRSxNQUFNO0FBQUEsSUFDTixhQUFhO0FBQUEsRUFDZjtBQUFBLEVBQ0E7QUFBQSxJQUNFLE1BQU07QUFBQSxJQUNOLGFBQWE7QUFBQSxFQUNmO0FBQUEsRUFDQTtBQUFBLElBQ0UsTUFBTTtBQUFBLElBQ04sYUFBYTtBQUFBLEVBQ2Y7QUFBQSxFQUNBO0FBQUEsSUFDRSxNQUFNO0FBQUEsSUFDTixhQUFhO0FBQUEsRUFDZjtBQUFBLEVBQ0E7QUFBQSxJQUNFLE1BQU07QUFBQSxJQUNOLGFBQWE7QUFBQSxFQUNmO0FBQUEsRUFDQTtBQUFBLElBQ0UsTUFBTTtBQUFBLElBQ04sYUFBYTtBQUFBLEVBQ2Y7QUFBQSxFQUNBO0FBQUEsSUFDRSxNQUFNO0FBQUEsSUFDTixhQUFhO0FBQUEsRUFDZjtBQUFBLEVBQ0E7QUFBQSxJQUNFLE1BQU07QUFBQSxJQUNOLGFBQWE7QUFBQSxFQUNmO0FBQUEsRUFDQTtBQUFBLElBQ0UsTUFBTTtBQUFBLElBQ04sYUFBYTtBQUFBLEVBQ2Y7QUFBQSxFQUNBO0FBQUEsSUFDRSxNQUFNO0FBQUEsSUFDTixhQUFhO0FBQUEsRUFDZjtBQUFBLEVBQ0E7QUFBQSxJQUNFLE1BQU07QUFBQSxJQUNOLGFBQWE7QUFBQSxFQUNmO0FBQUEsRUFDQTtBQUFBLElBQ0UsTUFBTTtBQUFBLElBQ04sYUFBYTtBQUFBLEVBQ2Y7QUFBQSxFQUNBO0FBQUEsSUFDRSxNQUFNO0FBQUEsSUFDTixhQUFhO0FBQUEsRUFDZjtBQUFBLEVBQ0E7QUFBQSxJQUNFLE1BQU07QUFBQSxJQUNOLGFBQWE7QUFBQSxFQUNmO0FBQUEsRUFDQTtBQUFBLElBQ0UsTUFBTTtBQUFBLElBQ04sYUFBYTtBQUFBLEVBQ2Y7QUFBQSxFQUNBO0FBQUEsSUFDRSxNQUFNO0FBQUEsSUFDTixhQUFhO0FBQUEsRUFDZjtBQUFBLEVBQ0E7QUFBQSxJQUNFLE1BQU07QUFBQSxJQUNOLGFBQWE7QUFBQSxFQUNmO0FBQUEsRUFDQTtBQUFBLElBQ0UsTUFBTTtBQUFBLElBQ04sYUFBYTtBQUFBLEVBQ2Y7QUFBQSxFQUNBO0FBQUEsSUFDRSxNQUFNO0FBQUEsSUFDTixhQUFhO0FBQUEsRUFDZjtBQUFBLEVBQ0E7QUFBQSxJQUNFLE1BQU07QUFBQSxJQUNOLGFBQWE7QUFBQSxFQUNmO0FBQUEsRUFDQTtBQUFBLElBQ0UsTUFBTTtBQUFBLElBQ04sYUFBYTtBQUFBLEVBQ2Y7QUFBQSxFQUNBO0FBQUEsSUFDRSxNQUFNO0FBQUEsSUFDTixhQUFhO0FBQUEsRUFDZjtBQUFBLEVBQ0E7QUFBQSxJQUNFLE1BQU07QUFBQSxJQUNOLGFBQWE7QUFBQSxFQUNmO0FBQUEsRUFDQTtBQUFBLElBQ0UsTUFBTTtBQUFBLElBQ04sYUFBYTtBQUFBLEVBQ2Y7QUFBQSxFQUNBO0FBQUEsSUFDRSxNQUFNO0FBQUEsSUFDTixhQUFhO0FBQUEsRUFDZjtBQUFBLEVBQ0E7QUFBQSxJQUNFLE1BQU07QUFBQSxJQUNOLGFBQWE7QUFBQSxFQUNmO0FBQUEsRUFDQTtBQUFBLElBQ0UsTUFBTTtBQUFBLElBQ04sYUFBYTtBQUFBLEVBQ2Y7QUFBQSxFQUNBO0FBQUEsSUFD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LENBQUM7QUFDakQsUUFBSSxRQUFRLElBQUk7QUFDZix1QkFBaUIsT0FBTyxPQUFPLENBQUM7QUFBQSxJQUNqQztBQUNBLFFBQUksUUFBUSxTQUFTLEdBQUc7QUFDdkIsdUJBQWlCLEtBQUssT0FBTztBQUFBLElBQzlCO0FBQUEsRUFDRDtBQUFBLEVBRUEsV0FBVztBQUFBLEVBRVg7QUFBQSxFQUVBLE1BQU0sZUFBZTtBQUNwQixTQUFLLFdBQVcsT0FBTyxPQUFPLENBQUMsR0FBRyxrQkFBa0IsTUFBTSxLQUFLLFNBQVMsQ0FBQztBQUFBLEVBQzFFO0FBQUEsRUFFQSxNQUFNLGVBQWU7QUFDcEIsVUFBTSxLQUFLLFNBQVMsS0FBSyxRQUFRO0FBQUEsRUFDbEM7QUFDRDtBQUVBLElBQU0sbUJBQU4sY0FBK0IsbUNBQWlCO0FBQUEsRUFHL0MsWUFBWUYsTUFBVSxRQUFrQjtBQUN2QyxVQUFNQSxNQUFLLE1BQU07QUFDakIsU0FBSyxTQUFTO0FBQUEsRUFDZjtBQUFBLEVBRUEsVUFBZ0I7QUFDZixVQUFNLEVBQUMsWUFBVyxJQUFJO0FBRXRCLGdCQUFZLE1BQU07QUFFbEIsZ0JBQVksU0FBUyxNQUFNLEVBQUMsTUFBTSxrQ0FBaUMsQ0FBQztBQUVwRSxRQUFJLDBCQUFRLFdBQVcsRUFDckIsUUFBUSxZQUFZLEVBQ3BCLFFBQVEsZUFBZ0IsRUFDeEIsUUFBUSxVQUFRLEtBQ2YsZUFBZSxtQkFBbUIsRUFDbEMsU0FBUyxLQUFLLE9BQU8sU0FBUyxTQUFTLEVBQ3ZDLFNBQVMsT0FBTyxVQUFVO0FBQzFCLGNBQVEsSUFBSSxhQUFhLEtBQUs7QUFDOUIsV0FBSyxPQUFPLFNBQVMsWUFBWTtBQUNqQyxZQUFNLEtBQUssT0FBTyxhQUFhO0FBQUEsSUFDaEMsQ0FBQyxDQUFDO0FBQUEsRUFDTDtBQUNEOyIsCiAgIm5hbWVzIjogWyJtb2R1bGUiLCAibWFwIiwgImZvcm1hdCIsICJsb2NhbGUiLCAidG8iLCAiZnJvbSIsICJ3YXJuIiwgInNldCIsICJub3ciLCAic2lnbiIsICJ0b2tlbiIsICJvcmRpbmFsIiwgImkiLCAic3RyaW5nIiwgImRpZmYiLCAibG9jYWxlRGF0YSIsICJob3VycyIsICJtaW51dGVzIiwgInRva2VucyIsICJtZXJpZGllbSIsICJ5ZWFycyIsICJtb250aHMiLCAid2Vla3MiLCAiZGF5cyIsICJzZWNvbmRzIiwgIm1pbGxpc2Vjb25kcyIsICJvZmZzZXQiLCAidGhyZXNob2xkcyIsICJpbXBvcnRfb2JzaWRpYW4iLCAiaW1wb3J0X29ic2lkaWFuIiwgImlzQWxpYXMiLCAicmVzIiwgIm1hcCIsICJzY2hlbWEiLCAibm9kZSIsICJzY2hlbWEiLCAiaSIsICJlbmQiLCAibWFwIiwgInZhbHVlIiwgInNjaGVtYSIsICJzdHJpbmdpZnkiLCAiY29tbWVudCIsICJzdHIiLCAic2NoZW1hIiwgIm1hcCIsICJzY2hlbWEiLCAibWFwIiwgInNjaGVtYSIsICJzZXEiLCAic2NoZW1hIiwgInNlcSIsICJpbnRJZGVudGlmeSIsICJzY2hlbWEiLCAic2VxIiwgInNjaGVtYSIsICJwYWlycyIsICJtYXAiLCAic2VxIiwgInBhaXJzIiwgInNjaGVtYSIsICJvbWFwIiwgImZsb2F0TmFOIiwgImZsb2F0RXhwIiwgImZsb2F0IiwgImludElkZW50aWZ5IiwgImludFJlc29sdmUiLCAibiIsICJpbnRTdHJpbmdpZnkiLCAiaW50T2N0IiwgImludCIsICJpbnRIZXgiLCAic2NoZW1hIiwgIm1hcCIsICJzZXQiLCAicmVzIiwgInNjaGVtYSIsICJpbnRPY3QiLCAiaW50IiwgImludEhleCIsICJmbG9hdE5hTiIsICJmbG9hdEV4cCIsICJmbG9hdCIsICJzY2hlbWEiLCAic2NoZW1hIiwgInJlcyIsICJjb21wb3NlTm9kZSIsICJjb21wb3NlRW1wdHlOb2RlIiwgIm1hcCIsICJjb21wb3NlTm9kZSIsICJjb21wb3NlRW1wdHlOb2RlIiwgInNlcSIsICJjb21wb3NlTm9kZSIsICJjb21wb3NlRW1wdHlOb2RlIiwgImlzTWFwIiwgIm1hcCIsICJDTiIsICJ2YWx1ZSIsICJlbmQiLCAic2NoZW1hIiwgInRhZyIsICJTQ0FMQVIiLCAiaXNDb2xsZWN0aW9uIiwgImlzU2NhbGFyIiwgInN0cmluZ2lmeSIsICJ2aXNpdCIsICJzdHJpbmdpZnkiLCAiQlJFQUsiLCAiU0tJUCIsICJSRU1PVkUiLCAidmlzaXQiLCAiX3Zpc2l0IiwgIlNDQUxBUiIsICJpc0NvbGxlY3Rpb24iLCAiaXNTY2FsYXIiLCAiY2giLCAiU0NBTEFSIiwgIm1hcCIsICJzZXEiLCAiYXBwIiwgImhhc0Zyb250TWF0dGVyIiwgImlzQWxpYXMiLCAiYXBwIiwgIm1vbWVudCIsICJhcHAiLCAiaW1wb3J0X29ic2lkaWFuIiwgImltcG9ydF9vYnNpZGlhbiIsICJBTExfVFlQRVMiLCAiYXBwIiwgImltcG9ydF9vYnNpZGlhbiIsICJBTExfVFlQRVMiLCAiYXBwIiwgImltcG9ydF9vYnNpZGlhbiIsICJBTExfVFlQRVMiLCAiYXBwIiwgImltcG9ydF9vYnNpZGlhbiIsICJBTExfVFlQRVMiLCAiYXBwIiwgImltcG9ydF9vYnNpZGlhbiIsICJhcHAiLCAiaW1wb3J0X29ic2lkaWFuIiwgImFwcCIsICJpbXBvcnRfb2JzaWRpYW4iLCAiYXBwIiwgInZhdWx0IiwgImltcG9ydF9vYnNpZGlhbiIsICJhcHAiLCAiaW1wb3J0X29ic2lkaWFuIiwgImltcG9ydF9vYnNpZGlhbiIsICJhcHAiLCAiYXBwIiwgImltcG9ydF9vYnNpZGlhbiIsICJpbXBvcnRfb2JzaWRpYW4iLCAiaW1wb3J0X29ic2lkaWFuIiwgImFwcCIsICJpbXBvcnRfb2JzaWRpYW4iLCAiYXBwIiwgImltcG9ydF9vYnNpZGlhbiIsICJhcHAiLCAiYXBwIiwgImltcG9ydF9vYnNpZGlhbiIsICJCQUNLX1RPX1NFTEVDVF9UQUciLCAiYXBwIiwgImltcG9ydF9vYnNpZGlhbiIsICJhcHAiLCAiaSIsICJsaW5lIiwgImFwcCIsICJtb21lbnQiLCAiY3Vyc29yIl0KfQo=
